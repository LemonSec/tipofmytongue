1
00:00:00,480 --> 00:00:04,140
hello how are you good rest it feels

2
00:00:04,140 --> 00:00:06,960
good great because now we are going to

3
00:00:06,960 --> 00:00:09,660
talk about Tiara and my experience with

4
00:00:09,660 --> 00:00:13,019
performance issues with yellow rules so

5
00:00:13,019 --> 00:00:16,079
I will tell you some tips and tricks how

6
00:00:16,079 --> 00:00:18,060
to speed up your rules

7
00:00:18,060 --> 00:00:19,920
before that I would like to introduce

8
00:00:19,920 --> 00:00:23,939
myself my pronouns are she her hers and

9
00:00:23,939 --> 00:00:26,279
I'm a researcher at the Gen before

10
00:00:26,279 --> 00:00:28,560
merger with Norton it was known as

11
00:00:28,560 --> 00:00:32,640
Everest I'm also doing my PhD at the

12
00:00:32,640 --> 00:00:35,840
University of University of Technology

13
00:00:35,840 --> 00:00:39,140
and during my project I cooperated with

14
00:00:39,140 --> 00:00:42,960
European space agency and Czech police

15
00:00:42,960 --> 00:00:45,420
my research is focused mainly on for

16
00:00:45,420 --> 00:00:49,160
models and languages in security

17
00:00:49,160 --> 00:00:51,539
I'm also focusing on pattern matching

18
00:00:51,539 --> 00:00:53,760
and sometimes I even look into

19
00:00:53,760 --> 00:00:55,379
blockchain technology

20
00:00:55,379 --> 00:00:57,180
I had

21
00:00:57,180 --> 00:01:00,660
talked the last year on what conf but do

22
00:01:00,660 --> 00:01:03,780
not worry you don't have to know much

23
00:01:03,780 --> 00:01:08,520
about Tiara or this talk at all I will

24
00:01:08,520 --> 00:01:11,280
like provide you more information than

25
00:01:11,280 --> 00:01:14,040
an EF

26
00:01:14,040 --> 00:01:15,960
my motivation for this talk

27
00:01:15,960 --> 00:01:18,479
uh at gen I'm working with Marvel

28
00:01:18,479 --> 00:01:22,920
analysts I'm not modernized myself but

29
00:01:22,920 --> 00:01:26,880
because I know it is quite hard and

30
00:01:26,880 --> 00:01:28,680
challenging to write their rules that

31
00:01:28,680 --> 00:01:29,600
are

32
00:01:29,600 --> 00:01:33,060
very precise they take only in the

33
00:01:33,060 --> 00:01:35,759
family you want and on top of that to

34
00:01:35,759 --> 00:01:37,680
deal with like speed issues and stuff

35
00:01:37,680 --> 00:01:39,240
like that it can be really complicated

36
00:01:39,240 --> 00:01:42,740
so I'm helping with these kind of issues

37
00:01:42,740 --> 00:01:46,020
I'm trying to help analysts to achieve

38
00:01:46,020 --> 00:01:49,200
more precise detections a few of false

39
00:01:49,200 --> 00:01:52,560
positives and also fix issues with too

40
00:01:52,560 --> 00:01:56,399
many matches or slow down scanning and

41
00:01:56,399 --> 00:01:59,659
other stuff like that

42
00:02:00,240 --> 00:02:03,180
I believe there is no need to introduce

43
00:02:03,180 --> 00:02:05,820
the era in this audience but

44
00:02:05,820 --> 00:02:09,060
even that I would like to go briefly

45
00:02:09,060 --> 00:02:12,180
through some Basics or we are all in on

46
00:02:12,180 --> 00:02:13,560
the same page

47
00:02:13,560 --> 00:02:17,700
and also I will look with you under the

48
00:02:17,700 --> 00:02:21,239
hood of Viera so once I will explain

49
00:02:21,239 --> 00:02:24,660
some specific details how to speed up

50
00:02:24,660 --> 00:02:27,620
your error rules you understand

51
00:02:27,620 --> 00:02:31,580
why is that the and the reason behind it

52
00:02:31,580 --> 00:02:35,280
there is like very very simple of a rule

53
00:02:35,280 --> 00:02:38,280
and you can see there's three parts meta

54
00:02:38,280 --> 00:02:40,080
strings and conditions

55
00:02:40,080 --> 00:02:42,500
condition is only like mandatory

56
00:02:42,500 --> 00:02:45,360
mandatory part of the era rules and it's

57
00:02:45,360 --> 00:02:48,840
basically building Expressions which is

58
00:02:48,840 --> 00:02:52,080
evaluated through then the sample which

59
00:02:52,080 --> 00:02:54,360
is currently being scanned is evaluated

60
00:02:54,360 --> 00:02:57,480
as matched or it's false and then the

61
00:02:57,480 --> 00:03:00,360
the sample is not being matched by the

62
00:03:00,360 --> 00:03:01,860
rule

63
00:03:01,860 --> 00:03:05,220
here you can see there are some logical

64
00:03:05,220 --> 00:03:06,900
operations like all and stuff like that

65
00:03:06,900 --> 00:03:10,500
and we can also use strings which will

66
00:03:10,500 --> 00:03:13,440
Define in a minute and also you can use

67
00:03:13,440 --> 00:03:16,080
some functions from modules for example

68
00:03:16,080 --> 00:03:18,540
Cuco models and stuff like that

69
00:03:18,540 --> 00:03:21,780
meta information is very very useful uh

70
00:03:21,780 --> 00:03:24,000
besides like outer information you can

71
00:03:24,000 --> 00:03:26,819
write here malware family you want to

72
00:03:26,819 --> 00:03:29,940
Target and versioning for example and

73
00:03:29,940 --> 00:03:31,140
stuff like that

74
00:03:31,140 --> 00:03:35,459
and the strings uh the name is kind of

75
00:03:35,459 --> 00:03:38,819
explaining all uh you have things you

76
00:03:38,819 --> 00:03:41,819
want to match in your samples you have

77
00:03:41,819 --> 00:03:44,420
three times types of string you can use

78
00:03:44,420 --> 00:03:49,920
the text or plain text strings here I am

79
00:03:49,920 --> 00:03:51,379
matching hello world

80
00:03:51,379 --> 00:03:55,680
and you can also use regular expressions

81
00:03:55,680 --> 00:03:59,400
and hexadecimal strings here I also use

82
00:03:59,400 --> 00:04:01,920
two from many options you can also use

83
00:04:01,920 --> 00:04:05,760
forward means we are searching these

84
00:04:05,760 --> 00:04:07,519
Rings between

85
00:04:07,519 --> 00:04:09,420
non-alphanumerical strings so some

86
00:04:09,420 --> 00:04:12,480
spaces between between around them and

87
00:04:12,480 --> 00:04:16,320
no case means that matching is done like

88
00:04:16,320 --> 00:04:19,500
case insensitive so we don't care about

89
00:04:19,500 --> 00:04:22,560
the lettering

90
00:04:22,560 --> 00:04:23,820
now

91
00:04:23,820 --> 00:04:26,699
uh I will not bother you with too much

92
00:04:26,699 --> 00:04:29,460
detail about how VR actually works but

93
00:04:29,460 --> 00:04:32,400
some key elements are quite crucial to

94
00:04:32,400 --> 00:04:35,280
understand why for example your errors

95
00:04:35,280 --> 00:04:37,919
is generating some warnings and even

96
00:04:37,919 --> 00:04:41,300
maybe errors so they can actually

97
00:04:41,300 --> 00:04:46,259
complicated your life uh yeah is firstly

98
00:04:46,259 --> 00:04:48,919
searching for Strings you defined

99
00:04:48,919 --> 00:04:52,620
previously and to explain how it is done

100
00:04:52,620 --> 00:04:56,340
I choose this regular Expressions as an

101
00:04:56,340 --> 00:04:57,419
example

102
00:04:57,419 --> 00:04:58,860
ah

103
00:04:58,860 --> 00:05:02,639
the interference phase era is looking

104
00:05:02,639 --> 00:05:05,639
for every string you define either in

105
00:05:05,639 --> 00:05:08,639
one row if you are using only like uh

106
00:05:08,639 --> 00:05:12,360
one rule for scanning or every Row in

107
00:05:12,360 --> 00:05:15,180
your research you can scan all these

108
00:05:15,180 --> 00:05:18,479
rules basically like advance

109
00:05:18,479 --> 00:05:24,479
uh and it doesn't look uh for like the

110
00:05:24,479 --> 00:05:27,240
whole string but firstly in the first

111
00:05:27,240 --> 00:05:30,479
step it selects so-called atoms which

112
00:05:30,479 --> 00:05:33,840
are substring uh based on the heuristic

113
00:05:33,840 --> 00:05:36,660
from like zero which is problematic I

114
00:05:36,660 --> 00:05:39,240
will talk about it in a minute up to

115
00:05:39,240 --> 00:05:42,600
four bytes which should be like the most

116
00:05:42,600 --> 00:05:45,720
unique the most interesting substring of

117
00:05:45,720 --> 00:05:48,720
your strings in this case in our regex

118
00:05:48,720 --> 00:05:51,840
it will be selecting a b c d

119
00:05:51,840 --> 00:05:55,199
and from that it builds so-called how

120
00:05:55,199 --> 00:05:58,620
thoracic algorithm automaton sorry

121
00:05:58,620 --> 00:06:02,400
you don't need to know much details

122
00:06:02,400 --> 00:06:06,720
about this automaton just it is very

123
00:06:06,720 --> 00:06:09,240
simple find out automaton it's actually

124
00:06:09,240 --> 00:06:12,539
prefix 3 which is nice because it's

125
00:06:12,539 --> 00:06:15,419
saving space and what's magical about

126
00:06:15,419 --> 00:06:19,380
this is that it can search for every

127
00:06:19,380 --> 00:06:22,259
matches in one go so it's actually scan

128
00:06:22,259 --> 00:06:25,620
your your file only once and it finds

129
00:06:25,620 --> 00:06:29,340
every possible match that could be in

130
00:06:29,340 --> 00:06:33,719
that file I'm like

131
00:06:34,319 --> 00:06:37,979
I would like to for like really really

132
00:06:37,979 --> 00:06:41,039
uh focus on their potential matches they

133
00:06:41,039 --> 00:06:43,560
are not real matches because as you can

134
00:06:43,560 --> 00:06:47,400
see for example from this Imaging uh

135
00:06:47,400 --> 00:06:49,020
image or sample or something like that

136
00:06:49,020 --> 00:06:52,080
there are two potential matches but they

137
00:06:52,080 --> 00:06:55,620
are not real ones until it's really like

138
00:06:55,620 --> 00:06:59,280
confirmed and this confirmation is done

139
00:06:59,280 --> 00:07:02,819
by butco byte code engine

140
00:07:02,819 --> 00:07:06,360
which is actually like

141
00:07:06,360 --> 00:07:09,000
uh looking for all information you

142
00:07:09,000 --> 00:07:12,240
provided whole strings all the options

143
00:07:12,240 --> 00:07:14,819
and stuff like that and said yes this is

144
00:07:14,819 --> 00:07:16,979
actually match we found the string in

145
00:07:16,979 --> 00:07:19,440
the file or not this is not much for

146
00:07:19,440 --> 00:07:22,800
example in my uh in these two matches

147
00:07:22,800 --> 00:07:25,800
you can see that the second case is

148
00:07:25,800 --> 00:07:28,620
ending with symbol F which is not in the

149
00:07:28,620 --> 00:07:30,840
original regular expression so it's not

150
00:07:30,840 --> 00:07:31,979
the real match

151
00:07:31,979 --> 00:07:34,139
just after that and this is really

152
00:07:34,139 --> 00:07:37,340
important I will resonate to it later

153
00:07:37,340 --> 00:07:41,819
the condition is evaluated so yeah I

154
00:07:41,819 --> 00:07:44,180
will look into the condition I said okay

155
00:07:44,180 --> 00:07:48,120
uh the author said that if we found this

156
00:07:48,120 --> 00:07:52,080
regex it's a match so it will report yes

157
00:07:52,080 --> 00:07:56,039
this sample is matching matched by the

158
00:07:56,039 --> 00:07:57,539
room

159
00:07:57,539 --> 00:08:01,500
uh these are important step because in

160
00:08:01,500 --> 00:08:05,340
each phase the errors and warnings can

161
00:08:05,340 --> 00:08:06,479
be generated

162
00:08:06,479 --> 00:08:10,800
for example in the first space here

163
00:08:10,800 --> 00:08:16,139
if your strings are too general or too

164
00:08:16,139 --> 00:08:19,379
complex for Yara and we I will show that

165
00:08:19,379 --> 00:08:22,199
it's quite easy to overcome yeah about

166
00:08:22,199 --> 00:08:26,039
it it will select uh very short atoms

167
00:08:26,039 --> 00:08:30,240
which are not not very efficient or it

168
00:08:30,240 --> 00:08:33,059
will choose like nothing at all like

169
00:08:33,059 --> 00:08:36,360
zero length term and in that case which

170
00:08:36,360 --> 00:08:39,958
is like the worst possible scenario you

171
00:08:39,958 --> 00:08:43,559
are searching every byte of your input

172
00:08:43,559 --> 00:08:47,300
samples which is like the most trivial

173
00:08:47,300 --> 00:08:51,540
uh searching algorithm possible and it's

174
00:08:51,540 --> 00:08:55,740
the sodium yellows significantly

175
00:08:55,740 --> 00:09:01,019
also here comes the warning about uh the

176
00:09:01,019 --> 00:09:03,420
very annoying this may slow down your

177
00:09:03,420 --> 00:09:05,940
scanning or something like that because

178
00:09:05,940 --> 00:09:09,899
there is some heuristic developing the

179
00:09:09,899 --> 00:09:13,019
quality of atoms and then there is not

180
00:09:13,019 --> 00:09:15,540
happy happy about them it will generate

181
00:09:15,540 --> 00:09:18,360
this warning I will show you later how

182
00:09:18,360 --> 00:09:20,940
to overcome this issue because

183
00:09:20,940 --> 00:09:23,880
these limitations These Warnings are

184
00:09:23,880 --> 00:09:25,980
limiting you from using your rules for

185
00:09:25,980 --> 00:09:29,399
example at uh virus total hunting page

186
00:09:29,399 --> 00:09:32,300
and stuff like that

187
00:09:32,300 --> 00:09:36,959
here when the matching is being done you

188
00:09:36,959 --> 00:09:40,560
can also get previous it was error now

189
00:09:40,560 --> 00:09:42,060
it's just a warning but it's still

190
00:09:42,060 --> 00:09:45,240
problematic that Tierra is generating

191
00:09:45,240 --> 00:09:46,860
too many matches

192
00:09:46,860 --> 00:09:51,000
this means that the rule itself is maybe

193
00:09:51,000 --> 00:09:54,600
false so it doesn't detect some false

194
00:09:54,600 --> 00:09:58,260
positives but you overcome Yara with too

195
00:09:58,260 --> 00:10:00,240
many matches the limit is currently like

196
00:10:00,240 --> 00:10:03,480
1 million uh per file or something like

197
00:10:03,480 --> 00:10:07,620
that so it's also a quite good idea to

198
00:10:07,620 --> 00:10:09,899
think about that if you see such a

199
00:10:09,899 --> 00:10:13,200
warning that your you is too General and

200
00:10:13,200 --> 00:10:15,240
you are matching probably more than than

201
00:10:15,240 --> 00:10:17,279
you actually want

202
00:10:17,279 --> 00:10:20,820
and of course the condition it's

203
00:10:20,820 --> 00:10:25,740
good to think about how to write

204
00:10:25,740 --> 00:10:28,860
correct and good conditions of course

205
00:10:28,860 --> 00:10:32,399
but in many cases it's like the last

206
00:10:32,399 --> 00:10:35,940
break and it will not improve the the

207
00:10:35,940 --> 00:10:39,540
overall itself without changing the

208
00:10:39,540 --> 00:10:41,459
strings

209
00:10:41,459 --> 00:10:42,980
I could

210
00:10:42,980 --> 00:10:46,380
explain you some cases I will show you

211
00:10:46,380 --> 00:10:50,399
and said hey this my my version the

212
00:10:50,399 --> 00:10:52,800
second version is just better it's

213
00:10:52,800 --> 00:10:55,980
faster and you can trust me because I'm

214
00:10:55,980 --> 00:10:59,279
going to be a doctor right but it's

215
00:10:59,279 --> 00:11:03,839
probably not like enough so I created a

216
00:11:03,839 --> 00:11:05,760
very simple data set it's publicly

217
00:11:05,760 --> 00:11:08,220
available and all the tests are by the

218
00:11:08,220 --> 00:11:11,100
way in the paper which will be published

219
00:11:11,100 --> 00:11:14,000
not just some some basic idea about it

220
00:11:14,000 --> 00:11:18,140
there are some clean and malware samples

221
00:11:18,140 --> 00:11:21,680
that are publicly available some texts

222
00:11:21,680 --> 00:11:24,959
textbook or something like that but

223
00:11:24,959 --> 00:11:28,500
mainly I use it as like a Big Blob of

224
00:11:28,500 --> 00:11:31,019
data the meaning behind that is not that

225
00:11:31,019 --> 00:11:34,579
important I use version four to three

226
00:11:34,579 --> 00:11:39,060
for these experiments and uh

227
00:11:39,060 --> 00:11:42,839
for like a baseline for our Baseline I

228
00:11:42,839 --> 00:11:45,180
created the simplest rule possible which

229
00:11:45,180 --> 00:11:47,519
is always about it as false so it

230
00:11:47,519 --> 00:11:50,339
doesn't even look into into the files so

231
00:11:50,339 --> 00:11:52,800
it should be like the fastest row

232
00:11:52,800 --> 00:11:56,279
possible and on my machine which was

233
00:11:56,279 --> 00:11:59,820
server of Ubuntu Server it ran for

234
00:11:59,820 --> 00:12:04,500
around 6 36 seconds so we are trying to

235
00:12:04,500 --> 00:12:06,959
get to this number as close to the

236
00:12:06,959 --> 00:12:08,579
possible

237
00:12:08,579 --> 00:12:11,339
now first study

238
00:12:11,339 --> 00:12:13,079
um

239
00:12:13,079 --> 00:12:16,620
we're trying to match first couple of

240
00:12:16,620 --> 00:12:20,880
bytes in the samples by the way these

241
00:12:20,880 --> 00:12:23,640
values were obviously changed they don't

242
00:12:23,640 --> 00:12:26,940
refer any specific malware family but

243
00:12:26,940 --> 00:12:29,940
the main idea Remains the Same and I

244
00:12:29,940 --> 00:12:32,880
will show you the the speed of them and

245
00:12:32,880 --> 00:12:34,160
stuff like that

246
00:12:34,160 --> 00:12:38,940
uh on the first look they all look quite

247
00:12:38,940 --> 00:12:40,560
simple

248
00:12:40,560 --> 00:12:44,519
they don't look that bad but there can

249
00:12:44,519 --> 00:12:48,480
be always like improve a little bit

250
00:12:48,480 --> 00:12:55,160
here he also limit the size of the files

251
00:12:55,160 --> 00:12:59,519
which were interesting for him but as I

252
00:12:59,519 --> 00:13:01,620
said before and I will repeat it like

253
00:13:01,620 --> 00:13:04,079
multiple times during this talk the

254
00:13:04,079 --> 00:13:06,660
conditions are about it after the fact

255
00:13:06,660 --> 00:13:08,940
that string are matched

256
00:13:08,940 --> 00:13:13,260
so even files that are bigger than

257
00:13:13,260 --> 00:13:17,160
here one a kilobyte are still being

258
00:13:17,160 --> 00:13:20,760
scanned so you are losing precious time

259
00:13:20,760 --> 00:13:24,079
and on larger data sets like imagine

260
00:13:24,079 --> 00:13:27,180
terabytes petabytes of data you are

261
00:13:27,180 --> 00:13:29,040
losing precious time

262
00:13:29,040 --> 00:13:31,860
and even the second part of the

263
00:13:31,860 --> 00:13:34,620
condition that we want to match this

264
00:13:34,620 --> 00:13:39,060
this string at position zero at the

265
00:13:39,060 --> 00:13:41,519
beginning of file is unfortunately

266
00:13:41,519 --> 00:13:45,600
checked after after the fact that we got

267
00:13:45,600 --> 00:13:48,660
all these possible matches so we are

268
00:13:48,660 --> 00:13:51,060
returning actually even the matches from

269
00:13:51,060 --> 00:13:54,180
the end of the fires and stuff like that

270
00:13:54,180 --> 00:13:57,839
this could be change in future there are

271
00:13:57,839 --> 00:13:59,579
lots of discussions with main authors

272
00:13:59,579 --> 00:14:02,820
but for now it is how it is and we have

273
00:14:02,820 --> 00:14:05,040
to deal with it

274
00:14:05,040 --> 00:14:07,200
luckily for us

275
00:14:07,200 --> 00:14:09,360
there is a way how to go around it

276
00:14:09,360 --> 00:14:14,000
because I have a very useful functions

277
00:14:14,000 --> 00:14:20,760
and x and U in X where you can specify

278
00:14:20,760 --> 00:14:24,240
in the condition itself that you want to

279
00:14:24,240 --> 00:14:27,000
look at specific position in the file

280
00:14:27,000 --> 00:14:31,760
and check corresponding number of bytes

281
00:14:31,760 --> 00:14:35,700
uh note that this is in little Indian

282
00:14:35,700 --> 00:14:38,399
there are also version for big Indian if

283
00:14:38,399 --> 00:14:41,959
you are if you prefer it

284
00:14:41,959 --> 00:14:45,660
and like that we are removing the string

285
00:14:45,660 --> 00:14:49,139
part completely and uh we are starting

286
00:14:49,139 --> 00:14:52,440
with file size here there is also like

287
00:14:52,440 --> 00:14:57,480
good uh Improvement that the Tiara has a

288
00:14:57,480 --> 00:15:00,360
shortcut evaluation which means that if

289
00:15:00,360 --> 00:15:02,100
the file size is bigger than the

290
00:15:02,100 --> 00:15:05,060
condition the rest of it is just

291
00:15:05,060 --> 00:15:08,399
thrashed and we don't care about calling

292
00:15:08,399 --> 00:15:10,620
this function anymore which is even

293
00:15:10,620 --> 00:15:13,560
better than than before the timer

294
00:15:13,560 --> 00:15:16,079
difference is about 10 percent faster

295
00:15:16,079 --> 00:15:19,800
which is like like who cares right but

296
00:15:19,800 --> 00:15:24,180
in case of larger data sets it can be

297
00:15:24,180 --> 00:15:28,260
very significant and also it depends on

298
00:15:28,260 --> 00:15:31,440
the contents of the files because if you

299
00:15:31,440 --> 00:15:34,500
had files they actually matching a lot

300
00:15:34,500 --> 00:15:37,500
of these these byte sequences where for

301
00:15:37,500 --> 00:15:39,779
example the zeros are quite common right

302
00:15:39,779 --> 00:15:42,899
and we have also the question mark so

303
00:15:42,899 --> 00:15:44,820
you can have whatever you want there

304
00:15:44,820 --> 00:15:47,820
that

305
00:15:48,120 --> 00:15:52,760
speed up could be even even better

306
00:15:52,800 --> 00:15:55,139
wasn't sure there this was a really

307
00:15:55,139 --> 00:15:58,260
interesting case and I have to say I

308
00:15:58,260 --> 00:16:00,540
feel a little bit like guilty about this

309
00:16:00,540 --> 00:16:03,959
solution because I use my knowledge how

310
00:16:03,959 --> 00:16:08,459
Yara works and just give give it exactly

311
00:16:08,459 --> 00:16:12,779
what what it wants but it's not like the

312
00:16:12,779 --> 00:16:15,660
clean solution but so in some cases it's

313
00:16:15,660 --> 00:16:19,339
just what you need what you have to use

314
00:16:19,339 --> 00:16:23,279
uh Dennis was starting to find the what

315
00:16:23,279 --> 00:16:27,660
Powershell but in the samples there are

316
00:16:27,660 --> 00:16:30,440
some special like coding I would say

317
00:16:30,440 --> 00:16:33,199
where in some cases

318
00:16:33,199 --> 00:16:36,180
carrot symbol was inserted between the

319
00:16:36,180 --> 00:16:39,480
letters in a random like order and

320
00:16:39,480 --> 00:16:43,040
random placement so he created

321
00:16:43,040 --> 00:16:45,779
naturally the rule that is actually

322
00:16:45,779 --> 00:16:48,240
trying to match all possible version of

323
00:16:48,240 --> 00:16:51,180
it where you see there are question

324
00:16:51,180 --> 00:16:54,360
marks almost everywhere but how how can

325
00:16:54,360 --> 00:16:58,199
this be like solve better right

326
00:16:58,199 --> 00:17:01,680
uh the problem is that in this case here

327
00:17:01,680 --> 00:17:04,919
is complaining about uh

328
00:17:04,919 --> 00:17:08,280
possible slowing down and it's because

329
00:17:08,280 --> 00:17:09,959
when

330
00:17:09,959 --> 00:17:14,160
searching for items atoms uh

331
00:17:14,160 --> 00:17:17,819
it's found only the letter p

332
00:17:17,819 --> 00:17:21,359
because if other symbols

333
00:17:21,359 --> 00:17:25,760
are possibly not there

334
00:17:27,500 --> 00:17:30,740
algorithm because it would be generating

335
00:17:30,740 --> 00:17:33,840
falsely matches and stuff like that

336
00:17:33,840 --> 00:17:37,200
that's a problem because the

337
00:17:37,200 --> 00:17:40,799
heuristics are set up currently that way

338
00:17:40,799 --> 00:17:43,980
it requires at least two

339
00:17:43,980 --> 00:17:47,400
symbols to be happy which is still not

340
00:17:47,400 --> 00:17:50,460
ideal don't get me wrong you want to aim

341
00:17:50,460 --> 00:17:54,960
for at least three or five symbols for

342
00:17:54,960 --> 00:17:59,039
your classic automaton but in this case

343
00:17:59,039 --> 00:18:02,700
vrs currently set this way so

344
00:18:02,700 --> 00:18:06,480
I tried it to use it this knowledge and

345
00:18:06,480 --> 00:18:10,020
I came with idea okay let's say we split

346
00:18:10,020 --> 00:18:12,299
the definition of the string in two

347
00:18:12,299 --> 00:18:15,900
version in one after the letter B There

348
00:18:15,900 --> 00:18:19,260
is carrot and in the second one there is

349
00:18:19,260 --> 00:18:21,840
no correct present and write it like

350
00:18:21,840 --> 00:18:25,200
that in this little trick and um I said

351
00:18:25,200 --> 00:18:27,600
before I'm not really happy about it but

352
00:18:27,600 --> 00:18:30,679
it worked uh you have

353
00:18:30,679 --> 00:18:35,640
two items actually created one is from

354
00:18:35,640 --> 00:18:38,220
two bytes and second one is

355
00:18:38,220 --> 00:18:42,059
created by free bytes and from that Yara

356
00:18:42,059 --> 00:18:46,260
is Happy actually about it and

357
00:18:46,260 --> 00:18:50,520
firstly the annoying warning is gone no

358
00:18:50,520 --> 00:18:55,440
more warnings here and also it speed up

359
00:18:55,440 --> 00:18:59,700
a little bit process around 15 so it's

360
00:18:59,700 --> 00:19:03,059
not that much faster but if you needed

361
00:19:03,059 --> 00:19:07,080
to use it for example in virus total you

362
00:19:07,080 --> 00:19:10,220
can use this trick

363
00:19:10,320 --> 00:19:12,240
other nations

364
00:19:12,240 --> 00:19:15,059
uh other topics I'm not really happy

365
00:19:15,059 --> 00:19:16,640
about Indiana

366
00:19:16,640 --> 00:19:20,220
era doesn't understand alternation that

367
00:19:20,220 --> 00:19:25,380
much in sense it cannot connect them

368
00:19:25,380 --> 00:19:28,020
with rest of the string this is issue

369
00:19:28,020 --> 00:19:31,820
because mainly for strong short strings

370
00:19:31,820 --> 00:19:35,160
you'll end up often with warnings about

371
00:19:35,160 --> 00:19:37,919
slowing down scanning and other other

372
00:19:37,919 --> 00:19:39,600
issues

373
00:19:39,600 --> 00:19:43,280
in this case there are two versions of

374
00:19:43,280 --> 00:19:47,039
hexadecimal strings and it for us it's

375
00:19:47,039 --> 00:19:49,919
nature to write it in short way like

376
00:19:49,919 --> 00:19:53,220
this but for Yara she basically don't

377
00:19:53,220 --> 00:19:56,240
understand it and doesn't understand it

378
00:19:56,240 --> 00:19:58,380
and uh

379
00:19:58,380 --> 00:20:00,660
the solution for it it's simply

380
00:20:00,660 --> 00:20:04,080
revelated in way it actually understand

381
00:20:04,080 --> 00:20:07,620
it so just split it into two two strings

382
00:20:07,620 --> 00:20:11,160
and in that way yeah it's not using only

383
00:20:11,160 --> 00:20:17,039
one byte of uh or two atoms or a

384
00:20:17,039 --> 00:20:19,679
wavelength of one byte but actually is

385
00:20:19,679 --> 00:20:21,740
using the full potential of this

386
00:20:21,740 --> 00:20:23,820
hexadecimal strings

387
00:20:23,820 --> 00:20:27,240
uh you can also see again slowing down

388
00:20:27,240 --> 00:20:31,799
warning is gone now and the the second

389
00:20:31,799 --> 00:20:36,960
rule is about 20 faster and again in a

390
00:20:36,960 --> 00:20:40,160
large data set on specific samples where

391
00:20:40,160 --> 00:20:43,559
these sequences would be more prevalent

392
00:20:43,559 --> 00:20:48,020
this could be even even faster

393
00:20:51,299 --> 00:20:53,960
too General

394
00:20:53,960 --> 00:20:58,799
uh this this problem is quite often I

395
00:20:58,799 --> 00:21:01,860
would say because it's natural to

396
00:21:01,860 --> 00:21:07,500
provide era more context for our rules

397
00:21:07,500 --> 00:21:10,740
right but in some way we can actually

398
00:21:10,740 --> 00:21:13,380
harm the speed of the scanning without

399
00:21:13,380 --> 00:21:16,760
actually knowing about it in this case

400
00:21:16,760 --> 00:21:20,220
analysts were looking for some simple

401
00:21:20,220 --> 00:21:23,460
name of file dot Excel where the name

402
00:21:23,460 --> 00:21:27,000
was so Random they just decided to go

403
00:21:27,000 --> 00:21:30,659
with DOT star which is Magic basically

404
00:21:30,659 --> 00:21:33,440
everything right

405
00:21:33,440 --> 00:21:36,140
doesn't like it a lot

406
00:21:36,140 --> 00:21:39,419
uh you will see eliminate that actually

407
00:21:39,419 --> 00:21:42,840
doesn't generate warning about uh

408
00:21:42,840 --> 00:21:45,500
slowing down the scanning surprisingly

409
00:21:45,500 --> 00:21:49,500
because the dot X is actually long

410
00:21:49,500 --> 00:21:52,980
enough to create atom but for the byte

411
00:21:52,980 --> 00:21:55,380
code engine this is like the ultimate

412
00:21:55,380 --> 00:21:56,400
killer

413
00:21:56,400 --> 00:21:59,280
and we are solving down the rule very

414
00:21:59,280 --> 00:22:01,440
very much you will see the numbers maybe

415
00:22:01,440 --> 00:22:03,900
it will be even surprising for you

416
00:22:03,900 --> 00:22:06,240
the same applies for a great expression

417
00:22:06,240 --> 00:22:11,940
such as dot Plus or with Dot and range

418
00:22:11,940 --> 00:22:14,460
where you don't set up the upper limit

419
00:22:14,460 --> 00:22:17,280
so you are basically saying Okay match

420
00:22:17,280 --> 00:22:18,960
one

421
00:22:18,960 --> 00:22:22,140
two trillion million

422
00:22:22,140 --> 00:22:24,480
and uh

423
00:22:24,480 --> 00:22:26,820
basically any other number of characters

424
00:22:26,820 --> 00:22:29,580
that are available this is promoting

425
00:22:29,580 --> 00:22:32,220
mainly on the beginning of the files

426
00:22:32,220 --> 00:22:35,179
because

427
00:22:35,720 --> 00:22:40,200
machine works it is tied to match every

428
00:22:40,200 --> 00:22:41,539
possible

429
00:22:41,539 --> 00:22:45,539
like version of the string so if you

430
00:22:45,539 --> 00:22:48,600
imagine for example name there would be

431
00:22:48,600 --> 00:22:52,200
like 12 letters a DOT x a you're

432
00:22:52,200 --> 00:22:57,299
returning dot XE and also 12 variants of

433
00:22:57,299 --> 00:23:01,260
the name starting with a DOT x a then a

434
00:23:01,260 --> 00:23:04,520
a DOT X and stuff like that and this can

435
00:23:04,520 --> 00:23:08,240
quickly like

436
00:23:08,240 --> 00:23:11,460
escalate to 1 million matches and now

437
00:23:11,460 --> 00:23:12,840
you have problem

438
00:23:12,840 --> 00:23:15,840
and it also time consuming because here

439
00:23:15,840 --> 00:23:19,679
is trying to basically match uh the same

440
00:23:19,679 --> 00:23:22,919
symbols multiple times

441
00:23:22,919 --> 00:23:27,840
so even though it's probably like not uh

442
00:23:27,840 --> 00:23:30,000
that intuitive

443
00:23:30,000 --> 00:23:32,940
sometimes less is more actually

444
00:23:32,940 --> 00:23:38,580
and if you ever if you in the future

445
00:23:38,580 --> 00:23:41,700
will write the rules and you have like

446
00:23:41,700 --> 00:23:44,480
feeling like yeah maybe I should

447
00:23:44,480 --> 00:23:47,700
use dot star because there's some random

448
00:23:47,700 --> 00:23:48,900
numbers

449
00:23:48,900 --> 00:23:52,140
maybe think about it maybe even like try

450
00:23:52,140 --> 00:23:55,200
to split the strings uh like into two if

451
00:23:55,200 --> 00:23:57,360
you you have the random part in the

452
00:23:57,360 --> 00:24:00,240
middle because in some cases it will

453
00:24:00,240 --> 00:24:03,240
actually be more effective for error and

454
00:24:03,240 --> 00:24:06,059
you speed up your rules that way and

455
00:24:06,059 --> 00:24:10,320
also uh even in practice uh this these

456
00:24:10,320 --> 00:24:14,280
random numbers or random sequences are

457
00:24:14,280 --> 00:24:17,100
probably not bringing much context if

458
00:24:17,100 --> 00:24:19,500
you don't know the specific line

459
00:24:19,500 --> 00:24:22,020
this is like the the maybe one

460
00:24:22,020 --> 00:24:24,480
exceptions if you know for example that

461
00:24:24,480 --> 00:24:28,679
all strings have I don't know 42 random

462
00:24:28,679 --> 00:24:31,500
letters between then yes you can use it

463
00:24:31,500 --> 00:24:34,100
use range of course

464
00:24:34,100 --> 00:24:36,240
and uh

465
00:24:36,240 --> 00:24:39,299
think about it also if this couldn't be

466
00:24:39,299 --> 00:24:41,580
changed in the future future version of

467
00:24:41,580 --> 00:24:45,059
of Marvel but that's possible but if you

468
00:24:45,059 --> 00:24:47,460
don't know the length of or its two

469
00:24:47,460 --> 00:24:50,880
variable then think about it twice or

470
00:24:50,880 --> 00:24:54,960
maybe even try it like uh I always

471
00:24:54,960 --> 00:24:59,059
advice to analyst just just write

472
00:24:59,059 --> 00:25:03,059
look select some random files and scan

473
00:25:03,059 --> 00:25:06,299
it with your rules and look search if if

474
00:25:06,299 --> 00:25:09,000
you have feelings that it's too long

475
00:25:09,000 --> 00:25:13,080
taking too long or if it's kinda okay in

476
00:25:13,080 --> 00:25:16,640
some cases it can be and of course again

477
00:25:16,640 --> 00:25:19,919
uh we are asking quite a large amount of

478
00:25:19,919 --> 00:25:24,299
files so even like uh

479
00:25:24,299 --> 00:25:27,720
10 percent different is really really

480
00:25:27,720 --> 00:25:31,380
big difference for us but for you if you

481
00:25:31,380 --> 00:25:33,480
for example need to scan just a few

482
00:25:33,480 --> 00:25:37,380
samples uh and at the same time it could

483
00:25:37,380 --> 00:25:40,020
be okay even with this distal version of

484
00:25:40,020 --> 00:25:42,539
rules so I'm not saying that

485
00:25:42,539 --> 00:25:45,360
bad in any way most of them are quite

486
00:25:45,360 --> 00:25:49,200
good earners are very smart people and

487
00:25:49,200 --> 00:25:53,520
admire them a lot but I'm just trying to

488
00:25:53,520 --> 00:25:56,100
help them to create the best rules

489
00:25:56,100 --> 00:25:57,960
possible

490
00:25:57,960 --> 00:26:01,620
and this is our new new version the

491
00:26:01,620 --> 00:26:06,000
another note about that Yara can sense

492
00:26:06,000 --> 00:26:07,340
or

493
00:26:07,340 --> 00:26:10,039
detect that's probably the better word

494
00:26:10,039 --> 00:26:13,020
that you are using regular expressions

495
00:26:13,020 --> 00:26:16,260
denotations with such that are actually

496
00:26:16,260 --> 00:26:18,480
like playing text

497
00:26:18,480 --> 00:26:22,380
but why not tell the area directly by

498
00:26:22,380 --> 00:26:26,580
using quotes it's even real better for

499
00:26:26,580 --> 00:26:30,059
humans for us it's readable more and

500
00:26:30,059 --> 00:26:32,400
also in the future it will not be

501
00:26:32,400 --> 00:26:35,159
surprised like why I'm actually using

502
00:26:35,159 --> 00:26:37,020
regular expression when it's just a

503
00:26:37,020 --> 00:26:38,159
string

504
00:26:38,159 --> 00:26:41,220
as I said before it is interesting that

505
00:26:41,220 --> 00:26:43,559
Nera is not complaining about slowing

506
00:26:43,559 --> 00:26:46,980
down even though it looks like almost

507
00:26:46,980 --> 00:26:50,460
twice the speed of the fastest rule to

508
00:26:50,460 --> 00:26:53,159
scan the files so there are definitely

509
00:26:53,159 --> 00:26:54,260
so

510
00:26:54,260 --> 00:26:57,960
it was slower than usually but there is

511
00:26:57,960 --> 00:27:01,320
specific warning you may see about the

512
00:27:01,320 --> 00:27:04,020
upper upper limit in the ranges and

513
00:27:04,020 --> 00:27:07,080
actually a good idea to look into this

514
00:27:07,080 --> 00:27:10,320
because yeah basically is trying to help

515
00:27:10,320 --> 00:27:13,380
you in many cases and These Warnings are

516
00:27:13,380 --> 00:27:14,580
tied to

517
00:27:14,580 --> 00:27:17,779
I give you idea what can be done better

518
00:27:17,779 --> 00:27:21,539
and in the second row even though we

519
00:27:21,539 --> 00:27:24,140
didn't change that much

520
00:27:24,140 --> 00:27:28,080
the rule is about 40 percent faster

521
00:27:28,080 --> 00:27:30,659
which is which is nice and also there

522
00:27:30,659 --> 00:27:31,980
are no more

523
00:27:31,980 --> 00:27:34,880
warnings

524
00:27:35,460 --> 00:27:38,220
in the last study the Allies were

525
00:27:38,220 --> 00:27:42,120
looking for IPv6 addresses and in this

526
00:27:42,120 --> 00:27:45,000
case is it is really important to for me

527
00:27:45,000 --> 00:27:47,700
at least to understand what they

528
00:27:47,700 --> 00:27:49,740
actually want to achieve in these cases

529
00:27:49,740 --> 00:27:52,320
so there are usually some discussions

530
00:27:52,320 --> 00:27:55,799
before we optimize the rule together so

531
00:27:55,799 --> 00:27:57,380
I understand

532
00:27:57,380 --> 00:28:02,279
what are the samples for example uh

533
00:28:02,279 --> 00:28:04,860
the most common cases and stuff like

534
00:28:04,860 --> 00:28:09,480
that here we had discussions that his

535
00:28:09,480 --> 00:28:13,820
general form of address was too General

536
00:28:13,820 --> 00:28:17,100
basically and he was matching uh too

537
00:28:17,100 --> 00:28:19,980
many things there's too many uh like

538
00:28:19,980 --> 00:28:22,799
false positives and stuff like that even

539
00:28:22,799 --> 00:28:25,620
though he tried to try to limit it with

540
00:28:25,620 --> 00:28:28,559
ASCII so he was matching only the ASCII

541
00:28:28,559 --> 00:28:32,100
characters but still and also of course

542
00:28:32,100 --> 00:28:34,279
it was also also slow

543
00:28:34,279 --> 00:28:38,700
so we thought about that and we found

544
00:28:38,700 --> 00:28:41,520
out that he needs actually to search

545
00:28:41,520 --> 00:28:46,400
only for specific addresses

546
00:28:46,400 --> 00:28:49,140
specifically for Global unicast

547
00:28:49,140 --> 00:28:51,620
addresses starting with prefix

548
00:28:51,620 --> 00:28:53,400
2001

549
00:28:53,400 --> 00:28:57,480
so we together came with a little bit

550
00:28:57,480 --> 00:29:01,080
different notation for it and what's

551
00:29:01,080 --> 00:29:03,900
also very good the prefix if you know

552
00:29:03,900 --> 00:29:05,820
the prefix it's like the win-win

553
00:29:05,820 --> 00:29:08,120
situation because

554
00:29:08,120 --> 00:29:11,940
you are limiting uh the

555
00:29:11,940 --> 00:29:14,820
option of the matches and also yeah it's

556
00:29:14,820 --> 00:29:19,799
very very pleased and uh she it's uh

557
00:29:19,799 --> 00:29:22,440
yeah it's been my situation for for both

558
00:29:22,440 --> 00:29:24,179
of you

559
00:29:24,179 --> 00:29:29,700
in that case again we have warning about

560
00:29:29,700 --> 00:29:32,520
slowing down it was caused in the

561
00:29:32,520 --> 00:29:35,580
original rule because again

562
00:29:35,580 --> 00:29:37,080
Yara

563
00:29:37,080 --> 00:29:40,140
is supporting regular Expressions that's

564
00:29:40,140 --> 00:29:43,740
true but under the hood there are some

565
00:29:43,740 --> 00:29:48,480
strong limitations what does it uh

566
00:29:48,480 --> 00:29:52,320
can take as atoms and what not and in

567
00:29:52,320 --> 00:29:55,799
this case basically

568
00:29:56,039 --> 00:29:59,399
it was lost so that's why there is the

569
00:29:59,399 --> 00:30:03,239
warning here and

570
00:30:03,919 --> 00:30:07,679
the second case as I said before the

571
00:30:07,679 --> 00:30:11,580
prefix was was the cure for for this

572
00:30:11,580 --> 00:30:12,480
problem

573
00:30:12,480 --> 00:30:18,059
in our data set we achieved about like

574
00:30:18,059 --> 00:30:20,580
50 faster scanning which is which is

575
00:30:20,580 --> 00:30:25,260
cool and also we had zero uh false

576
00:30:25,260 --> 00:30:27,480
positives which is also like important

577
00:30:27,480 --> 00:30:30,720
goal in our mission of course the role

578
00:30:30,720 --> 00:30:33,419
was a little bit more complicated than

579
00:30:33,419 --> 00:30:37,200
that but for simplification I narrow it

580
00:30:37,200 --> 00:30:40,559
down here and choose the main main focus

581
00:30:40,559 --> 00:30:43,020
of our changes

582
00:30:43,020 --> 00:30:47,580
and for conclusions era is great I

583
00:30:47,580 --> 00:30:51,600
really love era and Jen we are using it

584
00:30:51,600 --> 00:30:55,260
very patiently but there are some limits

585
00:30:55,260 --> 00:30:57,960
we need to keep in mind when writing era

586
00:30:57,960 --> 00:31:00,840
rules so we are not creating false

587
00:31:00,840 --> 00:31:04,440
positives and we are not uh sewing down

588
00:31:04,440 --> 00:31:06,659
yeah significantly

589
00:31:06,659 --> 00:31:09,899
uh the first thing I want you everyone

590
00:31:09,899 --> 00:31:12,299
to remember the condition part it's

591
00:31:12,299 --> 00:31:16,200
evaluated after the strings so think

592
00:31:16,200 --> 00:31:20,159
about your strengths please because they

593
00:31:20,159 --> 00:31:23,580
can all like completely kill your rules

594
00:31:23,580 --> 00:31:27,779
and even your rule sets so if you have

595
00:31:27,779 --> 00:31:31,260
sometimes problem on larger larger rule

596
00:31:31,260 --> 00:31:34,320
set search for the strings first because

597
00:31:34,320 --> 00:31:38,520
they are most like likely the culpriter

598
00:31:38,520 --> 00:31:40,340
ah

599
00:31:40,340 --> 00:31:45,840
also don't use two general patterns like

600
00:31:45,840 --> 00:31:49,500
I know it's tempting to create as many

601
00:31:49,500 --> 00:31:51,480
things and possible because you are the

602
00:31:51,480 --> 00:31:54,299
script describing the samples in best

603
00:31:54,299 --> 00:31:56,520
way possible but sometimes we are

604
00:31:56,520 --> 00:31:59,880
hurting era because she it just can't

605
00:31:59,880 --> 00:32:04,140
take it and sometimes the less is more

606
00:32:04,140 --> 00:32:06,600
and the last

607
00:32:06,600 --> 00:32:08,880
think about how you're writing these

608
00:32:08,880 --> 00:32:12,779
things because Yara is smart but not

609
00:32:12,779 --> 00:32:16,080
that smart so sometimes it needs a lot

610
00:32:16,080 --> 00:32:19,140
of help to understand how to work with

611
00:32:19,140 --> 00:32:21,960
these things and even surprisingly small

612
00:32:21,960 --> 00:32:24,960
changes can solve your problems with

613
00:32:24,960 --> 00:32:27,320
warnings and stuff like that

614
00:32:27,320 --> 00:32:30,419
and that's everything for me thank you

615
00:32:30,419 --> 00:32:32,340
for your attention and I'm ready for

616
00:32:32,340 --> 00:32:33,130
your question

617
00:32:33,130 --> 00:32:43,650
[Applause]

618
00:32:48,679 --> 00:32:51,539
your really interesting presentation I'm

619
00:32:51,539 --> 00:32:53,520
working on Siri guitar and we have kind

620
00:32:53,520 --> 00:32:55,799
of the same issue with multiple matching

621
00:32:55,799 --> 00:32:58,260
and one solution we have is that we have

622
00:32:58,260 --> 00:33:00,960
a fast pattern keyword that we can use

623
00:33:00,960 --> 00:33:02,940
to say put this string in the first

624
00:33:02,940 --> 00:33:06,960
pattern so we can specify where we want

625
00:33:06,960 --> 00:33:09,960
to optimize the multi-patter matching is

626
00:33:09,960 --> 00:33:11,580
this something that is available in Yara

627
00:33:11,580 --> 00:33:13,039
or benefit

628
00:33:13,039 --> 00:33:16,380
unfortunately not yet but again there

629
00:33:16,380 --> 00:33:21,240
are quite like personal discussions

630
00:33:21,240 --> 00:33:24,179
about these options because even main

631
00:33:24,179 --> 00:33:27,679
authors they know the limits

632
00:33:27,679 --> 00:33:32,600
but the approach for now it's uh

633
00:33:32,600 --> 00:33:37,140
they want to keep some Basics the same

634
00:33:37,140 --> 00:33:39,899
and reverse in the future if we could

635
00:33:39,899 --> 00:33:42,679
for example like push them a little bit

636
00:33:42,679 --> 00:33:45,480
to implement this but it's it yes sorry

637
00:33:45,480 --> 00:33:47,880
Kata is great uh

638
00:33:47,880 --> 00:33:51,179
project I like it as well and this

639
00:33:51,179 --> 00:33:55,880
option is definitely useful so thank you

640
00:33:58,320 --> 00:34:00,240
you're raising your hand over there or

641
00:34:00,240 --> 00:34:03,860
you were maybe stretching yeah

642
00:34:09,899 --> 00:34:11,940
I've got a question on for example one

643
00:34:11,940 --> 00:34:14,879
because basically on the studio one what

644
00:34:14,879 --> 00:34:18,060
what you are doing is escape the multi

645
00:34:18,060 --> 00:34:19,679
pattern matching

646
00:34:19,679 --> 00:34:22,379
base so it is going to work if you have

647
00:34:22,379 --> 00:34:24,418
one single rule you want to evaluate

648
00:34:24,418 --> 00:34:26,760
but if you want to put it in a bigger

649
00:34:26,760 --> 00:34:29,520
rule set then in this case you will have

650
00:34:29,520 --> 00:34:31,440
a cost of a multi pattern matching

651
00:34:31,440 --> 00:34:34,020
algorithm so you don't really care about

652
00:34:34,020 --> 00:34:35,760
doing this trick

653
00:34:35,760 --> 00:34:37,320
well

654
00:34:37,320 --> 00:34:40,980
the problem is that the byteco engine is

655
00:34:40,980 --> 00:34:43,560
like really slow in this case

656
00:34:43,560 --> 00:34:47,960
and because there is the gap

657
00:34:47,960 --> 00:34:53,179
it can overlap a lot

658
00:34:54,139 --> 00:34:58,200
data set like we try it and this video

659
00:34:58,200 --> 00:35:01,200
was there still even on 100 data set but

660
00:35:01,200 --> 00:35:05,520
I I get the idea you have but there are

661
00:35:05,520 --> 00:35:09,480
more aspects to the evaluation so there

662
00:35:09,480 --> 00:35:12,300
are more things to think about and they

663
00:35:12,300 --> 00:35:14,940
can actually like the negative effect

664
00:35:14,940 --> 00:35:18,140
can multiply inside

665
00:35:20,640 --> 00:35:23,118
yes

666
00:35:25,619 --> 00:35:27,119
um I had a question about the data set

667
00:35:27,119 --> 00:35:30,359
while building I I try to evaluate the

668
00:35:30,359 --> 00:35:31,920
yellow performance as well and building

669
00:35:31,920 --> 00:35:33,960
that set I find it was super difficult

670
00:35:33,960 --> 00:35:35,820
because

671
00:35:35,820 --> 00:35:38,520
Europe rule performances depends a lot

672
00:35:38,520 --> 00:35:40,020
on

673
00:35:40,020 --> 00:35:41,820
what kind of file it would run against

674
00:35:41,820 --> 00:35:44,280
like on the content of the file because

675
00:35:44,280 --> 00:35:46,140
you may have one

676
00:35:46,140 --> 00:35:48,780
weird patterns that will only trigger

677
00:35:48,780 --> 00:35:50,280
like a thousand time in one specific

678
00:35:50,280 --> 00:35:52,320
files but you will not see it until you

679
00:35:52,320 --> 00:35:54,839
hit this one specific file and it was

680
00:35:54,839 --> 00:35:56,579
like super hard to evaluate overall

681
00:35:56,579 --> 00:35:58,079
performances this is some issue you

682
00:35:58,079 --> 00:36:01,680
faced yeah actually for example now I

683
00:36:01,680 --> 00:36:05,400
remember the one case when my colleague

684
00:36:05,400 --> 00:36:07,760
also not modernized

685
00:36:07,760 --> 00:36:11,820
he was trying to match like Json format

686
00:36:11,820 --> 00:36:14,640
and then run it over like a little set

687
00:36:14,640 --> 00:36:17,880
of Json files and he was horrified how

688
00:36:17,880 --> 00:36:20,099
slow it was because it was matching

689
00:36:20,099 --> 00:36:21,619
basically like everything

690
00:36:21,619 --> 00:36:25,680
and yeah yeah it's a highly dependent on

691
00:36:25,680 --> 00:36:29,720
the on the input files but

692
00:36:29,720 --> 00:36:33,180
you can also like if you choose the

693
00:36:33,180 --> 00:36:36,540
random my data set for example like

694
00:36:36,540 --> 00:36:40,440
selection of green fires malware ideally

695
00:36:40,440 --> 00:36:42,599
the malware you want to Target and stuff

696
00:36:42,599 --> 00:36:45,420
like that then you can have a quite good

697
00:36:45,420 --> 00:36:48,660
idea how the rule behaves but it is true

698
00:36:48,660 --> 00:36:51,619
that for example even with these rules

699
00:36:51,619 --> 00:36:55,500
uh the difference between speed would be

700
00:36:55,500 --> 00:36:59,400
even more significant because there will

701
00:36:59,400 --> 00:37:01,560
be lots of matches on the data side so

702
00:37:01,560 --> 00:37:03,839
yeah that's that's the issue about

703
00:37:03,839 --> 00:37:07,560
I would say don't like spent too much

704
00:37:07,560 --> 00:37:12,480
time about on this because you have like

705
00:37:12,480 --> 00:37:16,940
already very very challenging job to do

706
00:37:16,940 --> 00:37:20,820
and rather than that care about it only

707
00:37:20,820 --> 00:37:22,500
when it's really

708
00:37:22,500 --> 00:37:24,060
slow

709
00:37:24,060 --> 00:37:26,520
and maybe just keep the main concept in

710
00:37:26,520 --> 00:37:31,020
the mind and that that's it like

711
00:37:31,020 --> 00:37:34,140
you we cannot be perfect right we have

712
00:37:34,140 --> 00:37:38,099
only 24 hours hopefully everyone so uh

713
00:37:38,099 --> 00:37:41,579
yeah that time just do our best

714
00:37:41,579 --> 00:37:44,760
thank you I also had a question

715
00:37:44,760 --> 00:37:47,099
um very very good talk and also I could

716
00:37:47,099 --> 00:37:49,020
see that you have a strong expert

717
00:37:49,020 --> 00:37:52,020
knowledge and maybe more than many

718
00:37:52,020 --> 00:37:54,420
people in this room but then it's your

719
00:37:54,420 --> 00:37:56,579
day in day out job and have you thought

720
00:37:56,579 --> 00:37:59,339
of like you know maybe writing a tool or

721
00:37:59,339 --> 00:38:01,380
something like that which would analyze

722
00:38:01,380 --> 00:38:04,140
the semantics of the rules people send

723
00:38:04,140 --> 00:38:07,140
you and then we'll guide them how to

724
00:38:07,140 --> 00:38:09,720
improve because you had like basic tips

725
00:38:09,720 --> 00:38:11,940
of how to significantly improve your

726
00:38:11,940 --> 00:38:14,400
performance of the rule would that work

727
00:38:14,400 --> 00:38:16,980
or did you consider that they're

728
00:38:16,980 --> 00:38:20,579
actually working or created some tools

729
00:38:20,579 --> 00:38:24,800
before for example my colleague

730
00:38:24,800 --> 00:38:27,780
created a very nice debugger for Yara

731
00:38:27,780 --> 00:38:30,420
which is actually open source like wing

732
00:38:30,420 --> 00:38:35,119
wing and it can help you to understand

733
00:38:35,119 --> 00:38:37,920
for example how the condition is

734
00:38:37,920 --> 00:38:41,160
behaving and how many matches are

735
00:38:41,160 --> 00:38:44,099
actually found in the file so you can

736
00:38:44,099 --> 00:38:47,940
actually like then uh find out yeah we

737
00:38:47,940 --> 00:38:49,320
have too many matches we have to do

738
00:38:49,320 --> 00:38:53,099
something like that I also uh promised

739
00:38:53,099 --> 00:38:56,099
for another conference to create some

740
00:38:56,099 --> 00:38:59,180
updates about the warnings and

741
00:38:59,180 --> 00:39:04,200
additional information that I will

742
00:39:04,200 --> 00:39:08,359
sent to the official report of official

743
00:39:08,359 --> 00:39:11,660
repository of era so it will be there

744
00:39:11,660 --> 00:39:16,560
but in so in general

745
00:39:16,560 --> 00:39:18,839
it's a little bit tricky because you

746
00:39:18,839 --> 00:39:21,119
need the context for example the last

747
00:39:21,119 --> 00:39:25,500
case the IPv6 in some cases it cannot be

748
00:39:25,500 --> 00:39:27,599
changed because you will lose some

749
00:39:27,599 --> 00:39:30,980
matches you would actually like to have

750
00:39:30,980 --> 00:39:34,500
so maybe in the future in like in

751
00:39:34,500 --> 00:39:36,839
Collective effort there will be some

752
00:39:36,839 --> 00:39:40,859
truth for that but for now the warnings

753
00:39:40,859 --> 00:39:43,859
and stuff like that are the best the

754
00:39:43,859 --> 00:39:46,680
last thing I would like to say uh on

755
00:39:46,680 --> 00:39:49,619
Twitter you can search for

756
00:39:49,619 --> 00:39:53,000
a very nice tutorials and tips

757
00:39:53,000 --> 00:39:56,280
additional tips how to speed up your app

758
00:39:56,280 --> 00:40:01,800
so maybe try to search takiera here and

759
00:40:01,800 --> 00:40:04,140
there are lots of more information about

760
00:40:04,140 --> 00:40:08,540
how to speed up your rules

761
00:40:11,099 --> 00:40:13,820
last question

762
00:40:20,820 --> 00:40:23,760
though it it's just a a simple question

763
00:40:23,760 --> 00:40:27,060
did you try to optimize your Yara rules

764
00:40:27,060 --> 00:40:30,380
with chat GPT for example

765
00:40:30,380 --> 00:40:32,940
I'm sorry I don't want to upset anyone

766
00:40:32,940 --> 00:40:37,560
but I am I'm not that big fan of AI so

767
00:40:37,560 --> 00:40:40,560
no but maybe it would be interesting if

768
00:40:40,560 --> 00:40:41,400
someone

769
00:40:41,400 --> 00:40:43,920
want to try please let me know the

770
00:40:43,920 --> 00:40:47,520
results but now um I'm not friend of gbt

771
00:40:47,520 --> 00:40:49,880
I'm sorry

772
00:40:52,140 --> 00:40:55,140
okay

773
00:41:00,480 --> 00:41:02,599
so hello very nice presentation

774
00:41:02,599 --> 00:41:06,980
so if I get the idea the main idea is to

775
00:41:06,980 --> 00:41:10,940
have good atoms for classical

776
00:41:10,940 --> 00:41:14,579
so I think for your explanation maybe it

777
00:41:14,579 --> 00:41:18,000
would be nice to have a built-in feature

778
00:41:18,000 --> 00:41:20,880
in Yaga to show what atoms actually come

779
00:41:20,880 --> 00:41:23,420
to that Arrow classical

780
00:41:23,420 --> 00:41:26,220
would it be good approach for

781
00:41:26,220 --> 00:41:29,280
explanation what Sierra does actually

782
00:41:29,280 --> 00:41:32,640
it can be confusing because the

783
00:41:32,640 --> 00:41:35,220
heuristics that are actually leading for

784
00:41:35,220 --> 00:41:37,980
to selection are changing like quite

785
00:41:37,980 --> 00:41:38,960
often

786
00:41:38,960 --> 00:41:43,140
uh but yeah for example in um

787
00:41:43,140 --> 00:41:45,000
my boss is here so I hopefully not

788
00:41:45,000 --> 00:41:47,099
telling something like a super secret

789
00:41:47,099 --> 00:41:50,599
but uh for aranas I actually created

790
00:41:50,599 --> 00:41:53,880
some extra layer of information we call

791
00:41:53,880 --> 00:41:56,760
it like hints and I'm actually like yes

792
00:41:56,760 --> 00:42:00,240
saying analyst hey in this string we are

793
00:42:00,240 --> 00:42:02,579
certain things only one one symbol or

794
00:42:02,579 --> 00:42:05,640
even like the no symbol possible to

795
00:42:05,640 --> 00:42:10,200
create to atoms so check this out and uh

796
00:42:10,200 --> 00:42:12,839
maybe think about it a little bit so we

797
00:42:12,839 --> 00:42:14,480
are actually providing this information

798
00:42:14,480 --> 00:42:17,460
these things are actually not publicly

799
00:42:17,460 --> 00:42:19,980
available yet but maybe also in the

800
00:42:19,980 --> 00:42:22,260
future there will be and they can be

801
00:42:22,260 --> 00:42:24,359
helpful but also

802
00:42:24,359 --> 00:42:26,460
you need a little bit feedback to

803
00:42:26,460 --> 00:42:28,020
understand it like

804
00:42:28,020 --> 00:42:30,900
what they actually are because other

805
00:42:30,900 --> 00:42:33,420
than in the codes they are not mentioned

806
00:42:33,420 --> 00:42:37,140
in the documentation so for new users it

807
00:42:37,140 --> 00:42:38,640
could be actually quite like

808
00:42:38,640 --> 00:42:40,980
overwhelming like

809
00:42:40,980 --> 00:42:43,560
but the warning is saying I don't

810
00:42:43,560 --> 00:42:45,599
understand help me please

811
00:42:45,599 --> 00:42:48,180
yeah so

812
00:42:48,180 --> 00:42:51,000
maybe in the future

813
00:42:51,000 --> 00:42:53,339
okay thank you

814
00:42:53,339 --> 00:42:55,940
thank you

815
00:42:56,339 --> 00:42:58,680
thank you very much

816
00:42:58,680 --> 00:43:01,220
yeah

