1
00:00:00,640 --> 00:00:03,280
all right hello everybody my name is

2
00:00:02,480 --> 00:00:05,439
michelle

3
00:00:03,280 --> 00:00:07,119
i'm a phd student at cispa and i'm going

4
00:00:05,440 --> 00:00:08,160
to present to you our paper called

5
00:00:07,120 --> 00:00:10,320
xlasik

6
00:00:08,160 --> 00:00:12,240
leveraging os diversity to automatically

7
00:00:10,320 --> 00:00:14,240
extract malware code signatures

8
00:00:12,240 --> 00:00:15,839
this is joint work with my supervisor

9
00:00:14,240 --> 00:00:17,760
christian rosso

10
00:00:15,839 --> 00:00:18,880
now to motivate our work what we are

11
00:00:17,760 --> 00:00:20,640
actually trying to achieve

12
00:00:18,880 --> 00:00:22,720
is that given a memory dump of an

13
00:00:20,640 --> 00:00:24,400
infected system we want to

14
00:00:22,720 --> 00:00:26,320
attribute which malware infected the

15
00:00:24,400 --> 00:00:28,560
system that is we want to

16
00:00:26,320 --> 00:00:30,320
automatically create signatures to do

17
00:00:28,560 --> 00:00:32,159
this task

18
00:00:30,320 --> 00:00:34,079
now if we look at existing solutions

19
00:00:32,159 --> 00:00:34,480
that we could possibly use for such a

20
00:00:34,079 --> 00:00:38,079
task

21
00:00:34,480 --> 00:00:40,319
is a b labels or error signatures

22
00:00:38,079 --> 00:00:42,480
the problem is these are usually very

23
00:00:40,320 --> 00:00:44,239
sort of generic signatures as it turns

24
00:00:42,480 --> 00:00:46,559
out they are not very accurate because

25
00:00:44,239 --> 00:00:48,640
they mostly focus on strings and data

26
00:00:46,559 --> 00:00:49,760
so if you have ever worked with yahoo

27
00:00:48,640 --> 00:00:51,120
signatures

28
00:00:49,760 --> 00:00:52,719
you probably know this right you apply

29
00:00:51,120 --> 00:00:54,160
it to a sample and it shows something

30
00:00:52,719 --> 00:00:56,559
that doesn't really make sense it

31
00:00:54,160 --> 00:00:57,839
matches random data as belonging to a

32
00:00:56,559 --> 00:00:59,519
certain mobile family or

33
00:00:57,840 --> 00:01:00,960
something like that so it doesn't really

34
00:00:59,520 --> 00:01:03,120
work that well

35
00:01:00,960 --> 00:01:04,400
now this by itself is a problem you

36
00:01:03,120 --> 00:01:05,920
could say you just need to improve the

37
00:01:04,400 --> 00:01:06,880
signature that's fine but another

38
00:01:05,920 --> 00:01:08,720
problem that we find

39
00:01:06,880 --> 00:01:10,880
is that usually off-the-shelf signatures

40
00:01:08,720 --> 00:01:12,560
that you can find online for example

41
00:01:10,880 --> 00:01:14,080
are not really intended for being used

42
00:01:12,560 --> 00:01:17,040
with memory amps

43
00:01:14,080 --> 00:01:18,080
that's actually a big problem in our

44
00:01:17,040 --> 00:01:20,159
experience they

45
00:01:18,080 --> 00:01:21,520
really are intended to work with samples

46
00:01:20,159 --> 00:01:24,080
and if you try to blend them to marine

47
00:01:21,520 --> 00:01:26,320
labs they simply don't work

48
00:01:24,080 --> 00:01:27,840
so we basically want a solution to

49
00:01:26,320 --> 00:01:29,839
overcome that we want a solution to

50
00:01:27,840 --> 00:01:32,640
automatically create such signatures

51
00:01:29,840 --> 00:01:34,320
and that they work with memory dumps now

52
00:01:32,640 --> 00:01:36,400
a big problem here is that we want to do

53
00:01:34,320 --> 00:01:37,199
this in a very in a completely forensic

54
00:01:36,400 --> 00:01:38,960
setting

55
00:01:37,200 --> 00:01:40,880
and therefore the analysis surface is

56
00:01:38,960 --> 00:01:42,320
the whole memory number of the system

57
00:01:40,880 --> 00:01:44,399
and as you will see soon this is

58
00:01:42,320 --> 00:01:46,880
actually quite a challenge

59
00:01:44,399 --> 00:01:48,079
now why is this actually a big challenge

60
00:01:46,880 --> 00:01:50,079
so the problem is

61
00:01:48,079 --> 00:01:51,119
that if we look at the memory right here

62
00:01:50,079 --> 00:01:52,720
on the left

63
00:01:51,119 --> 00:01:54,479
that is infected by a malware as

64
00:01:52,720 --> 00:01:55,679
indicated by this little red guy down

65
00:01:54,479 --> 00:01:57,920
here

66
00:01:55,680 --> 00:01:58,719
now if we want to understand how we can

67
00:01:57,920 --> 00:02:01,119
analyze this

68
00:01:58,719 --> 00:02:01,919
we have to think of the memory as memory

69
00:02:01,119 --> 00:02:04,560
pages right

70
00:02:01,920 --> 00:02:06,240
as you probably know memory is allocated

71
00:02:04,560 --> 00:02:08,878
at a page granularity

72
00:02:06,240 --> 00:02:10,799
and it makes sense to look at pages as a

73
00:02:08,878 --> 00:02:12,399
natural boundary of the memory dump sort

74
00:02:10,800 --> 00:02:14,080
of

75
00:02:12,400 --> 00:02:15,520
now if you think of a memory dump it's

76
00:02:14,080 --> 00:02:17,040
quite big right it

77
00:02:15,520 --> 00:02:19,760
could be multiples of gigabyte on a

78
00:02:17,040 --> 00:02:21,679
modern system and however if we actually

79
00:02:19,760 --> 00:02:24,160
look at the footprint of the malware we

80
00:02:21,680 --> 00:02:24,720
will find that only a very few pages are

81
00:02:24,160 --> 00:02:26,879
actually

82
00:02:24,720 --> 00:02:28,239
infected right so here we have this huge

83
00:02:26,879 --> 00:02:30,959
number of pages

84
00:02:28,239 --> 00:02:31,519
and we have like one two three four five

85
00:02:30,959 --> 00:02:33,440
in fact

86
00:02:31,519 --> 00:02:35,360
pages and of course in practice it's

87
00:02:33,440 --> 00:02:37,519
even much worse we're talking about

88
00:02:35,360 --> 00:02:41,760
hundreds of thousands if not millions of

89
00:02:37,519 --> 00:02:44,160
nine pages and maybe 100 or a few dozen

90
00:02:41,760 --> 00:02:45,920
of uh infected pages so it's really a

91
00:02:44,160 --> 00:02:46,959
needle in a haystack problem so how can

92
00:02:45,920 --> 00:02:48,799
we actually

93
00:02:46,959 --> 00:02:51,040
as a first step understand which of the

94
00:02:48,800 --> 00:02:53,280
pages are actually interesting

95
00:02:51,040 --> 00:02:54,959
in terms of being attributed to the

96
00:02:53,280 --> 00:02:56,480
malware and then we can start thinking

97
00:02:54,959 --> 00:02:57,920
about how we can generate the signature

98
00:02:56,480 --> 00:02:59,760
of those pages

99
00:02:57,920 --> 00:03:02,839
but the first and the really important

100
00:02:59,760 --> 00:03:05,519
step is to find those pages

101
00:03:02,840 --> 00:03:07,599
automatically

102
00:03:05,519 --> 00:03:09,200
our idea to solve this problem is called

103
00:03:07,599 --> 00:03:10,640
cross os execution

104
00:03:09,200 --> 00:03:12,879
so here i'm going to give you a very

105
00:03:10,640 --> 00:03:14,640
high level overview of our approach

106
00:03:12,879 --> 00:03:17,599
and later on i'm going to refine the

107
00:03:14,640 --> 00:03:20,480
actual details as we have implemented it

108
00:03:17,599 --> 00:03:21,440
in practice so what you can see here is

109
00:03:20,480 --> 00:03:24,159
a very basic

110
00:03:21,440 --> 00:03:25,680
pipeline of a malware analysis system on

111
00:03:24,159 --> 00:03:27,280
the left hand side we have a

112
00:03:25,680 --> 00:03:28,879
set of malware samples that we want to

113
00:03:27,280 --> 00:03:31,840
analyze

114
00:03:28,879 --> 00:03:33,760
and in the middle we have a sandbox or

115
00:03:31,840 --> 00:03:35,440
sandboxes that we will use to analyze

116
00:03:33,760 --> 00:03:36,560
the samples so the way it works here we

117
00:03:35,440 --> 00:03:39,599
take this

118
00:03:36,560 --> 00:03:41,440
black sample and we execute it

119
00:03:39,599 --> 00:03:44,640
now however the interesting step is we

120
00:03:41,440 --> 00:03:46,640
execute this in two different machines

121
00:03:44,640 --> 00:03:48,319
in particular we executed in a windows

122
00:03:46,640 --> 00:03:50,238
xp machine and then a windows

123
00:03:48,319 --> 00:03:53,119
7 machine those are virtual machines

124
00:03:50,239 --> 00:03:55,040
with a predefined snapshot

125
00:03:53,120 --> 00:03:57,599
and we execute those and then we take

126
00:03:55,040 --> 00:03:59,120
the memory dump of both systems

127
00:03:57,599 --> 00:04:01,040
and now we have those two memory dumps

128
00:03:59,120 --> 00:04:03,280
and they both have

129
00:04:01,040 --> 00:04:05,040
infected memory pages that are infected

130
00:04:03,280 --> 00:04:07,599
by the same moment

131
00:04:05,040 --> 00:04:09,120
now how do we solve the problem of

132
00:04:07,599 --> 00:04:11,359
actually understanding which of the

133
00:04:09,120 --> 00:04:13,040
pages are interesting

134
00:04:11,360 --> 00:04:15,200
and as it turns out what is a really

135
00:04:13,040 --> 00:04:17,440
useful way to do this in practice is

136
00:04:15,200 --> 00:04:20,320
that we take those two memory knobs

137
00:04:17,440 --> 00:04:20,959
and we intersect them now what does that

138
00:04:20,320 --> 00:04:23,440
mean

139
00:04:20,959 --> 00:04:25,199
i will tell you later in detail but the

140
00:04:23,440 --> 00:04:29,120
basic idea is those systems

141
00:04:25,199 --> 00:04:32,400
are similar not identical

142
00:04:29,120 --> 00:04:36,080
and their similarities should be mainly

143
00:04:32,400 --> 00:04:37,919
the memory footprint of the malware

144
00:04:36,080 --> 00:04:40,400
and if we do this the really important

145
00:04:37,919 --> 00:04:41,919
aspect is that as i have said before

146
00:04:40,400 --> 00:04:43,599
the windows extreme redundant the

147
00:04:41,919 --> 00:04:47,280
windows 7 when we're done

148
00:04:43,600 --> 00:04:48,400
are inside in the order of gigabytes in

149
00:04:47,280 --> 00:04:50,320
size

150
00:04:48,400 --> 00:04:51,758
and the actual footprint that we get by

151
00:04:50,320 --> 00:04:53,440
intersecting is much smaller we're

152
00:04:51,759 --> 00:04:57,680
talking about a few kilobytes

153
00:04:53,440 --> 00:05:00,080
maybe so the very basic motivation

154
00:04:57,680 --> 00:05:01,039
and observations of this idea are as

155
00:05:00,080 --> 00:05:02,560
false

156
00:05:01,039 --> 00:05:04,719
first of all as i've previously

157
00:05:02,560 --> 00:05:07,520
mentioned most of the pages in memory

158
00:05:04,720 --> 00:05:08,080
are really uninteresting for us they are

159
00:05:07,520 --> 00:05:09,520
basically

160
00:05:08,080 --> 00:05:12,000
we can basically consider that noise

161
00:05:09,520 --> 00:05:13,359
right so we have b9 processors we have

162
00:05:12,000 --> 00:05:16,479
services we have

163
00:05:13,360 --> 00:05:18,160
kernel code we have libraries device

164
00:05:16,479 --> 00:05:19,680
drivers and so on

165
00:05:18,160 --> 00:05:21,600
they are not interesting and completely

166
00:05:19,680 --> 00:05:24,560
useless for us in terms of generating a

167
00:05:21,600 --> 00:05:26,639
signature for the malware

168
00:05:24,560 --> 00:05:28,800
and the other observation is that we

169
00:05:26,639 --> 00:05:31,600
have two systems that are similar

170
00:05:28,800 --> 00:05:33,520
but compatible in particular this means

171
00:05:31,600 --> 00:05:35,039
the malware is very likely to run on

172
00:05:33,520 --> 00:05:36,880
both systems

173
00:05:35,039 --> 00:05:38,880
first of all because in our case we use

174
00:05:36,880 --> 00:05:40,400
windows and windows is the ecosystem

175
00:05:38,880 --> 00:05:43,360
that is very well known for its

176
00:05:40,400 --> 00:05:46,560
backwards compatibility

177
00:05:43,360 --> 00:05:48,720
and also malware authors usually

178
00:05:46,560 --> 00:05:50,720
try to make sure that their marble runs

179
00:05:48,720 --> 00:05:53,919
on as many systems as possible

180
00:05:50,720 --> 00:05:55,759
for obvious reasons and the interesting

181
00:05:53,919 --> 00:05:56,880
aspect here is that the forensic

182
00:05:55,759 --> 00:06:00,080
footprint of those

183
00:05:56,880 --> 00:06:02,639
operating systems is not identical it's

184
00:06:00,080 --> 00:06:05,039
actually vastly different

185
00:06:02,639 --> 00:06:06,639
so by intersecting the memory pages

186
00:06:05,039 --> 00:06:08,080
again we will get into the details of

187
00:06:06,639 --> 00:06:09,440
how this actually works

188
00:06:08,080 --> 00:06:11,039
but by doing that we can actually

189
00:06:09,440 --> 00:06:13,360
abstract from the background noise

190
00:06:11,039 --> 00:06:14,639
automatically

191
00:06:13,360 --> 00:06:16,479
now a problem that i can already

192
00:06:14,639 --> 00:06:18,560
foreshadow at this point is that the two

193
00:06:16,479 --> 00:06:20,800
operating systems

194
00:06:18,560 --> 00:06:22,319
while not being identical they are still

195
00:06:20,800 --> 00:06:24,960
similar and they still

196
00:06:22,319 --> 00:06:26,560
share some footprints so as is probably

197
00:06:24,960 --> 00:06:28,560
not really surprising

198
00:06:26,560 --> 00:06:29,759
there is legacy code in windows that

199
00:06:28,560 --> 00:06:30,880
will be shared between different

200
00:06:29,759 --> 00:06:33,360
questions

201
00:06:30,880 --> 00:06:34,400
and part of our task will be to identify

202
00:06:33,360 --> 00:06:35,840
those similarities

203
00:06:34,400 --> 00:06:38,400
and abstract from them in the learning

204
00:06:35,840 --> 00:06:40,400
phase of our system

205
00:06:38,400 --> 00:06:42,400
so here we can see a more detailed

206
00:06:40,400 --> 00:06:43,120
overview of how our approach actually

207
00:06:42,400 --> 00:06:45,280
works

208
00:06:43,120 --> 00:06:47,120
this is a figure that can be found in

209
00:06:45,280 --> 00:06:50,159
our paper

210
00:06:47,120 --> 00:06:52,720
we will in the following slides go into

211
00:06:50,160 --> 00:06:54,960
the details of every step

212
00:06:52,720 --> 00:06:55,759
the way it works as a very high level

213
00:06:54,960 --> 00:06:57,758
idea is

214
00:06:55,759 --> 00:06:59,840
on the very left hand side we start with

215
00:06:57,759 --> 00:07:02,639
malware that is executed

216
00:06:59,840 --> 00:07:04,400
on two different windows versions then

217
00:07:02,639 --> 00:07:05,759
it goes to some process

218
00:07:04,400 --> 00:07:07,679
that we will describe in the following

219
00:07:05,759 --> 00:07:09,520
slides and on the

220
00:07:07,680 --> 00:07:11,599
right hand side you can see the final

221
00:07:09,520 --> 00:07:14,159
result of this process which is a

222
00:07:11,599 --> 00:07:16,479
fingerprint for this number

223
00:07:14,160 --> 00:07:17,520
and as i've said we will now go into the

224
00:07:16,479 --> 00:07:20,639
details

225
00:07:17,520 --> 00:07:22,080
of every step of this procedure now the

226
00:07:20,639 --> 00:07:24,560
first two steps of our

227
00:07:22,080 --> 00:07:26,080
approach are explained here the very

228
00:07:24,560 --> 00:07:28,000
first step the execution step

229
00:07:26,080 --> 00:07:29,440
i think it doesn't really need that much

230
00:07:28,000 --> 00:07:31,520
explanation we basically

231
00:07:29,440 --> 00:07:33,199
take the malware and execute it in two

232
00:07:31,520 --> 00:07:35,120
different virtual machines with

233
00:07:33,199 --> 00:07:36,560
different versions of windows

234
00:07:35,120 --> 00:07:38,560
the only thing that might be interesting

235
00:07:36,560 --> 00:07:39,919
to mention here is we use

236
00:07:38,560 --> 00:07:41,759
snapshots that we have previously

237
00:07:39,919 --> 00:07:44,799
created and we execute the malware on

238
00:07:41,759 --> 00:07:46,960
both systems for the same amount of time

239
00:07:44,800 --> 00:07:48,560
after that we take a memory dump a

240
00:07:46,960 --> 00:07:50,400
memory dump here is represented with

241
00:07:48,560 --> 00:07:52,160
such a grid

242
00:07:50,400 --> 00:07:54,159
and each cell in the grid represents the

243
00:07:52,160 --> 00:07:55,759
memory page

244
00:07:54,160 --> 00:07:57,759
the individual letters stand for

245
00:07:55,759 --> 00:07:58,479
different contents so if two cells share

246
00:07:57,759 --> 00:08:00,560
the same letter

247
00:07:58,479 --> 00:08:02,560
that means they have the same content

248
00:08:00,560 --> 00:08:04,080
and the x suffix in some of the cells

249
00:08:02,560 --> 00:08:05,840
means that the page is considered

250
00:08:04,080 --> 00:08:07,280
executable by the operating system

251
00:08:05,840 --> 00:08:09,359
so in the page tables it has the

252
00:08:07,280 --> 00:08:12,000
execution bit set

253
00:08:09,360 --> 00:08:13,199
and we will use this later because as i

254
00:08:12,000 --> 00:08:13,840
have previously mentioned we are

255
00:08:13,199 --> 00:08:17,680
interested

256
00:08:13,840 --> 00:08:20,878
in code signatures now the next step

257
00:08:17,680 --> 00:08:23,520
is the unique step in this step

258
00:08:20,879 --> 00:08:26,400
we filter out all the pages that are not

259
00:08:23,520 --> 00:08:28,878
unique in the memory dump

260
00:08:26,400 --> 00:08:30,560
to understand this first of all i think

261
00:08:28,879 --> 00:08:32,000
it's intuitive to understand that

262
00:08:30,560 --> 00:08:34,080
something that appears

263
00:08:32,000 --> 00:08:35,760
let's say 20 times in the memory lamp so

264
00:08:34,080 --> 00:08:37,120
one page appears 20 times

265
00:08:35,760 --> 00:08:39,838
it's probably not characteristic for the

266
00:08:37,120 --> 00:08:40,399
marble in practice what we have seen for

267
00:08:39,839 --> 00:08:44,000
example

268
00:08:40,399 --> 00:08:45,440
is that it's very likely that

269
00:08:44,000 --> 00:08:47,519
several processes on the operating

270
00:08:45,440 --> 00:08:49,360
system use the same library or maybe

271
00:08:47,519 --> 00:08:51,680
study link for example

272
00:08:49,360 --> 00:08:53,440
and because of that we will have the

273
00:08:51,680 --> 00:08:54,880
same code multiple times on the system

274
00:08:53,440 --> 00:08:55,120
and that's of course not interesting for

275
00:08:54,880 --> 00:08:57,600
us

276
00:08:55,120 --> 00:09:00,080
right um so it allows us basically to

277
00:08:57,600 --> 00:09:01,839
abstract from such noise in a very easy

278
00:09:00,080 --> 00:09:02,800
manner so what you can see here is for

279
00:09:01,839 --> 00:09:05,120
example that

280
00:09:02,800 --> 00:09:06,560
the a page the executable a page is

281
00:09:05,120 --> 00:09:08,800
filtered out

282
00:09:06,560 --> 00:09:10,160
the b pages footed out on the top

283
00:09:08,800 --> 00:09:13,279
because

284
00:09:10,160 --> 00:09:15,199
those are all not unique in the marina

285
00:09:13,279 --> 00:09:17,600
so a appears multiple times

286
00:09:15,200 --> 00:09:19,200
once it's executable one is not and

287
00:09:17,600 --> 00:09:21,040
that's because it's sorted out b appears

288
00:09:19,200 --> 00:09:22,560
multiple times c and so on

289
00:09:21,040 --> 00:09:24,399
and all these pages are filled out in

290
00:09:22,560 --> 00:09:26,719
this step and the result of this

291
00:09:24,399 --> 00:09:28,399
are the memory dumps on your right hand

292
00:09:26,720 --> 00:09:30,560
side

293
00:09:28,399 --> 00:09:32,399
the next step is called the common step

294
00:09:30,560 --> 00:09:34,839
it's also a very simple step but it's

295
00:09:32,399 --> 00:09:36,000
very central and very important to our

296
00:09:34,839 --> 00:09:38,160
approach

297
00:09:36,000 --> 00:09:39,760
in this step we are basically

298
00:09:38,160 --> 00:09:41,439
abstracting from

299
00:09:39,760 --> 00:09:43,839
background noise of the operating

300
00:09:41,440 --> 00:09:47,200
systems and the way this works

301
00:09:43,839 --> 00:09:49,360
is we basically only consider the

302
00:09:47,200 --> 00:09:50,320
memory pages that are shared in both

303
00:09:49,360 --> 00:09:52,240
memory dumps

304
00:09:50,320 --> 00:09:54,080
and by that we filter out the pages that

305
00:09:52,240 --> 00:09:56,000
are not shared which we consider the

306
00:09:54,080 --> 00:09:57,600
noise of the operating system

307
00:09:56,000 --> 00:09:59,120
so in this case as you can see in the

308
00:09:57,600 --> 00:10:01,760
first memory dump h

309
00:09:59,120 --> 00:10:02,560
is not shared in with the secondary

310
00:10:01,760 --> 00:10:04,720
number

311
00:10:02,560 --> 00:10:06,800
and j and k of the second memory dump is

312
00:10:04,720 --> 00:10:09,360
not shared with the first one we done

313
00:10:06,800 --> 00:10:10,319
and therefore we consider h j and k

314
00:10:09,360 --> 00:10:13,600
noise

315
00:10:10,320 --> 00:10:14,399
and we keep d e f and g and by the way

316
00:10:13,600 --> 00:10:16,480
that they appear

317
00:10:14,399 --> 00:10:18,640
at the same offset here does not matter

318
00:10:16,480 --> 00:10:21,839
d could also appear in the first

319
00:10:18,640 --> 00:10:23,279
position it's just coincidence in this

320
00:10:21,839 --> 00:10:26,399
case

321
00:10:23,279 --> 00:10:27,120
and this basically is where the strength

322
00:10:26,399 --> 00:10:28,800
of our

323
00:10:27,120 --> 00:10:30,160
approach comes in because this

324
00:10:28,800 --> 00:10:34,000
automatically

325
00:10:30,160 --> 00:10:36,959
abstracts from noise as i have mentioned

326
00:10:34,000 --> 00:10:37,839
before the operating systems while being

327
00:10:36,959 --> 00:10:41,199
different

328
00:10:37,839 --> 00:10:42,480
they are still similar and they share

329
00:10:41,200 --> 00:10:44,880
legacy code and

330
00:10:42,480 --> 00:10:45,600
data that we cannot necessarily abstract

331
00:10:44,880 --> 00:10:48,800
from with

332
00:10:45,600 --> 00:10:51,120
our intersection idea

333
00:10:48,800 --> 00:10:51,839
in this step we want to solve this

334
00:10:51,120 --> 00:10:53,839
problem

335
00:10:51,839 --> 00:10:55,040
so what we have done so far we have

336
00:10:53,839 --> 00:10:58,160
computed the unique

337
00:10:55,040 --> 00:10:59,519
and common pages in this step we want to

338
00:10:58,160 --> 00:11:00,959
understand which pages are

339
00:10:59,519 --> 00:11:02,800
characteristic

340
00:11:00,959 --> 00:11:05,439
so it's basically the last that

341
00:11:02,800 --> 00:11:08,560
abstracts from all the noise

342
00:11:05,440 --> 00:11:10,240
and to abstract from the noise we have a

343
00:11:08,560 --> 00:11:13,359
deny list a deny list

344
00:11:10,240 --> 00:11:16,880
is a list of pages that we learn

345
00:11:13,360 --> 00:11:20,000
in a learning phase once that

346
00:11:16,880 --> 00:11:21,839
exactly contain this noise these noisy

347
00:11:20,000 --> 00:11:23,440
pages that we cannot abstract from by

348
00:11:21,839 --> 00:11:25,040
intersecting

349
00:11:23,440 --> 00:11:26,800
we will surely get into how we build

350
00:11:25,040 --> 00:11:28,800
this deny list

351
00:11:26,800 --> 00:11:30,079
but at this point we just use the deny

352
00:11:28,800 --> 00:11:32,240
list

353
00:11:30,079 --> 00:11:34,160
and we use it in a very simple fashion

354
00:11:32,240 --> 00:11:35,360
we take the memory pages of the memory

355
00:11:34,160 --> 00:11:37,680
then and we remove

356
00:11:35,360 --> 00:11:38,880
all the pages that are contained in the

357
00:11:37,680 --> 00:11:41,120
denial list

358
00:11:38,880 --> 00:11:43,279
so in this case e and f are in the deny

359
00:11:41,120 --> 00:11:44,160
list and they are removed and we are

360
00:11:43,279 --> 00:11:47,360
left with d

361
00:11:44,160 --> 00:11:49,920
and g which we can which we calling

362
00:11:47,360 --> 00:11:51,760
the characteristic pages of the malware

363
00:11:49,920 --> 00:11:55,199
that has been executed

364
00:11:51,760 --> 00:11:55,760
now to build the deny list we proceed as

365
00:11:55,200 --> 00:11:59,040
follows

366
00:11:55,760 --> 00:12:00,319
the procedure is outlined here first of

367
00:11:59,040 --> 00:12:02,560
all we start with

368
00:12:00,320 --> 00:12:04,240
an empty list an empty denial list in

369
00:12:02,560 --> 00:12:06,160
the first step

370
00:12:04,240 --> 00:12:08,320
and then we do something which we call

371
00:12:06,160 --> 00:12:10,959
an idle execution

372
00:12:08,320 --> 00:12:12,399
we basically run this whole crossos

373
00:12:10,959 --> 00:12:13,279
apparatus that i have previously

374
00:12:12,399 --> 00:12:15,200
described

375
00:12:13,279 --> 00:12:17,200
but we do not insert the malware into

376
00:12:15,200 --> 00:12:18,240
the system we just let it run without

377
00:12:17,200 --> 00:12:20,480
the malware

378
00:12:18,240 --> 00:12:22,720
for the same amount of time that we

379
00:12:20,480 --> 00:12:25,120
would run it with the malware

380
00:12:22,720 --> 00:12:26,399
but it basically just idles it does

381
00:12:25,120 --> 00:12:29,600
nothing interesting from

382
00:12:26,399 --> 00:12:31,680
malware and that is point of view

383
00:12:29,600 --> 00:12:33,440
um then we take the memory dump and we

384
00:12:31,680 --> 00:12:36,719
extract the unique common pages

385
00:12:33,440 --> 00:12:39,120
as before and then we add those pages to

386
00:12:36,720 --> 00:12:41,519
the denial list

387
00:12:39,120 --> 00:12:42,480
if we have added a new entry to the deny

388
00:12:41,519 --> 00:12:44,720
list we

389
00:12:42,480 --> 00:12:46,320
proceed again from step two so we repeat

390
00:12:44,720 --> 00:12:51,600
the whole thing and we repeat that

391
00:12:46,320 --> 00:12:53,120
until we do not have any new pages

392
00:12:51,600 --> 00:12:54,880
it turns out in practice that this

393
00:12:53,120 --> 00:12:55,839
process terminates quite quickly so it

394
00:12:54,880 --> 00:12:57,519
maybe takes like

395
00:12:55,839 --> 00:12:59,519
three or four iterations before we do

396
00:12:57,519 --> 00:13:00,880
not see any new pages

397
00:12:59,519 --> 00:13:02,560
and that's mainly because we use

398
00:13:00,880 --> 00:13:04,800
snapshots and

399
00:13:02,560 --> 00:13:08,079
things are rather deterministic every

400
00:13:04,800 --> 00:13:10,479
time we start the operating system

401
00:13:08,079 --> 00:13:12,479
so after this we have learned the pages

402
00:13:10,480 --> 00:13:15,519
we have a denylus that we can use

403
00:13:12,480 --> 00:13:18,399
as previously described the final two

404
00:13:15,519 --> 00:13:21,839
steps of our approach are explained here

405
00:13:18,399 --> 00:13:22,880
the first step is the code extraction

406
00:13:21,839 --> 00:13:25,360
step

407
00:13:22,880 --> 00:13:26,560
in this step we simply remove all pages

408
00:13:25,360 --> 00:13:29,040
that do not contain

409
00:13:26,560 --> 00:13:30,000
code so in this case the g page will be

410
00:13:29,040 --> 00:13:32,719
removed

411
00:13:30,000 --> 00:13:34,079
and we are only left with the page that

412
00:13:32,720 --> 00:13:36,399
will be used for the fingerprint

413
00:13:34,079 --> 00:13:38,479
generation which is the last step the

414
00:13:36,399 --> 00:13:41,040
fingerprint generation works by

415
00:13:38,480 --> 00:13:43,199
extracting engrams so the way it works

416
00:13:41,040 --> 00:13:46,639
is we use the sliding window

417
00:13:43,199 --> 00:13:47,599
that we slide over the d page and we

418
00:13:46,639 --> 00:13:50,480
extract its

419
00:13:47,600 --> 00:13:51,760
n-grams and these engrams will then

420
00:13:50,480 --> 00:13:55,760
later be used

421
00:13:51,760 --> 00:13:57,760
for uh matching a memory dump that is we

422
00:13:55,760 --> 00:13:59,600
compute all the engrams of memory dump

423
00:13:57,760 --> 00:14:02,720
and we intersect it with the

424
00:13:59,600 --> 00:14:04,320
engrams of the generated fingerprint and

425
00:14:02,720 --> 00:14:05,199
depending on the size of the

426
00:14:04,320 --> 00:14:06,639
intersection

427
00:14:05,199 --> 00:14:08,959
we will have a match but we will get

428
00:14:06,639 --> 00:14:10,880
into that later

429
00:14:08,959 --> 00:14:12,239
the only important step here to mention

430
00:14:10,880 --> 00:14:14,639
is that for the

431
00:14:12,240 --> 00:14:16,000
code extraction we use a quote heuristic

432
00:14:14,639 --> 00:14:19,040
that disassembles the

433
00:14:16,000 --> 00:14:21,920
page and looks for a common

434
00:14:19,040 --> 00:14:23,439
x86 code patterns like for example a

435
00:14:21,920 --> 00:14:25,120
push to push a call

436
00:14:23,440 --> 00:14:26,560
then you do a call a test and then a

437
00:14:25,120 --> 00:14:29,279
conditional jump

438
00:14:26,560 --> 00:14:30,000
and depending on how many of those

439
00:14:29,279 --> 00:14:33,439
patterns you find

440
00:14:30,000 --> 00:14:35,120
we consider a page code page

441
00:14:33,440 --> 00:14:37,600
and the details can be found in the

442
00:14:35,120 --> 00:14:39,279
paper it's important here to mention

443
00:14:37,600 --> 00:14:40,240
that we do not rely on page table

444
00:14:39,279 --> 00:14:42,399
information

445
00:14:40,240 --> 00:14:44,079
or os information because we want our

446
00:14:42,399 --> 00:14:47,120
approach to be

447
00:14:44,079 --> 00:14:47,839
generic basically our approach depends

448
00:14:47,120 --> 00:14:49,360
on nothing

449
00:14:47,839 --> 00:14:51,680
except for the instruction set

450
00:14:49,360 --> 00:14:53,680
architecture x86

451
00:14:51,680 --> 00:14:55,359
but changing that is merely an

452
00:14:53,680 --> 00:14:57,439
engineering effort

453
00:14:55,360 --> 00:14:58,480
so after this step we have finally a

454
00:14:57,440 --> 00:15:02,399
fingerprint that

455
00:14:58,480 --> 00:15:03,920
can be used for detecting

456
00:15:02,399 --> 00:15:05,839
the presence of a malware family in my

457
00:15:03,920 --> 00:15:08,160
radars

458
00:15:05,839 --> 00:15:09,680
now let's come to the evaluation of our

459
00:15:08,160 --> 00:15:11,279
paper

460
00:15:09,680 --> 00:15:13,599
so first of all i'm going to explain the

461
00:15:11,279 --> 00:15:15,600
data set and the setup that we have used

462
00:15:13,600 --> 00:15:17,040
we have used the virtualbox hypervisor a

463
00:15:15,600 --> 00:15:17,760
windows xp virtual machine and the

464
00:15:17,040 --> 00:15:21,120
windows 7

465
00:15:17,760 --> 00:15:22,560
virtual machine um virtualbox that

466
00:15:21,120 --> 00:15:24,639
doesn't really matter you can use any

467
00:15:22,560 --> 00:15:26,000
hypervisor you like as long as it is

468
00:15:24,639 --> 00:15:27,760
capable of creating a memory

469
00:15:26,000 --> 00:15:29,440
dump which i guess pretty much every

470
00:15:27,760 --> 00:15:31,439
hypervisor can do

471
00:15:29,440 --> 00:15:33,519
the only interesting part here is that

472
00:15:31,440 --> 00:15:34,320
we have taken great care to set up the

473
00:15:33,519 --> 00:15:37,279
vms to

474
00:15:34,320 --> 00:15:39,199
have a rather silent memory footprint so

475
00:15:37,279 --> 00:15:40,959
we have disabled as many services as

476
00:15:39,199 --> 00:15:43,758
possible

477
00:15:40,959 --> 00:15:45,439
we have made sure that there is not

478
00:15:43,759 --> 00:15:48,240
really any network activity

479
00:15:45,440 --> 00:15:49,920
there isn't really any new processes

480
00:15:48,240 --> 00:15:53,120
being spawned that much

481
00:15:49,920 --> 00:15:56,399
so we have basically taken care that the

482
00:15:53,120 --> 00:15:58,560
systems are really silent

483
00:15:56,399 --> 00:16:00,959
that basically makes for example

484
00:15:58,560 --> 00:16:04,000
generating the denial list

485
00:16:00,959 --> 00:16:07,199
a lot more efficient and it also

486
00:16:04,000 --> 00:16:08,240
makes sure that we do not introduce any

487
00:16:07,199 --> 00:16:11,279
new noise

488
00:16:08,240 --> 00:16:13,199
we reduce that as much as possible we

489
00:16:11,279 --> 00:16:15,439
have used 70 popular marble families

490
00:16:13,199 --> 00:16:16,160
such as carbon microtrans timber and so

491
00:16:15,440 --> 00:16:19,279
on

492
00:16:16,160 --> 00:16:20,880
and in total we had 197 malware samples

493
00:16:19,279 --> 00:16:22,480
the full list of the families can be

494
00:16:20,880 --> 00:16:24,959
found in the paper

495
00:16:22,480 --> 00:16:26,880
now this number 197 might sound a little

496
00:16:24,959 --> 00:16:28,638
small

497
00:16:26,880 --> 00:16:32,079
but we want to mention that we have

498
00:16:28,639 --> 00:16:34,000
taken great care to create a very high

499
00:16:32,079 --> 00:16:36,560
quality data set so we have basically

500
00:16:34,000 --> 00:16:39,279
executed all those smarter samples into

501
00:16:36,560 --> 00:16:41,279
the two vms windows xp and windows 7 vm

502
00:16:39,279 --> 00:16:43,920
and we have basically babysitted all of

503
00:16:41,279 --> 00:16:44,959
the 394 marble executions and have made

504
00:16:43,920 --> 00:16:47,519
sure that the

505
00:16:44,959 --> 00:16:48,880
actual family really becomes active in

506
00:16:47,519 --> 00:16:50,959
the system

507
00:16:48,880 --> 00:16:53,920
so basically we can be sure that all the

508
00:16:50,959 --> 00:16:56,800
labels of all the memory lamps are 100

509
00:16:53,920 --> 00:16:58,719
correct now as a first step of our

510
00:16:56,800 --> 00:17:00,399
evaluation we wanted to understand the

511
00:16:58,720 --> 00:17:02,000
family uniformity

512
00:17:00,399 --> 00:17:03,680
this graph can be found in the paper and

513
00:17:02,000 --> 00:17:05,280
without going into too much detail what

514
00:17:03,680 --> 00:17:07,438
we actually want to know here is how

515
00:17:05,280 --> 00:17:10,639
many samples of family do we need

516
00:17:07,439 --> 00:17:12,400
to reliably detect the whole family

517
00:17:10,640 --> 00:17:15,120
so basically this works here is on the

518
00:17:12,400 --> 00:17:17,039
excesses we have the number of family

519
00:17:15,119 --> 00:17:18,958
samples that we can use to build a

520
00:17:17,039 --> 00:17:20,720
fingerprint so for example if we have

521
00:17:18,959 --> 00:17:22,400
three samples we create a fingerprint as

522
00:17:20,720 --> 00:17:24,079
described before for each sample and

523
00:17:22,400 --> 00:17:26,160
then we

524
00:17:24,079 --> 00:17:27,438
take a union of all those engrams and

525
00:17:26,160 --> 00:17:29,839
this is now our fingerprint for the

526
00:17:27,439 --> 00:17:29,839
family

527
00:17:30,000 --> 00:17:37,520
and on the y-axis we have

528
00:17:33,440 --> 00:17:38,320
how many engrams we have left if we

529
00:17:37,520 --> 00:17:41,280
intersect

530
00:17:38,320 --> 00:17:44,320
this fingerprint with the engrams of all

531
00:17:41,280 --> 00:17:46,240
the memory dumps of the family

532
00:17:44,320 --> 00:17:47,918
so for instance to give you an example

533
00:17:46,240 --> 00:17:48,480
to make this more clear let's look at

534
00:17:47,919 --> 00:17:52,080
the

535
00:17:48,480 --> 00:17:54,160
kilios this red dashed line case

536
00:17:52,080 --> 00:17:56,559
in this case even if we have just one

537
00:17:54,160 --> 00:17:58,320
sample and we learn the fingerprints

538
00:17:56,559 --> 00:18:00,000
and we intersect those encryams with the

539
00:17:58,320 --> 00:18:02,480
engrams of all killers memory

540
00:18:00,000 --> 00:18:04,559
loss we see that we have more almost 1

541
00:18:02,480 --> 00:18:08,080
million

542
00:18:04,559 --> 00:18:10,000
n-grams after the intersection

543
00:18:08,080 --> 00:18:12,320
so that means knowing one sample is

544
00:18:10,000 --> 00:18:14,400
already enough

545
00:18:12,320 --> 00:18:15,439
if we compare this for example with

546
00:18:14,400 --> 00:18:19,760
let's say this

547
00:18:15,440 --> 00:18:22,400
uh purple line which is in my main

548
00:18:19,760 --> 00:18:22,799
one sample does not work that well we

549
00:18:22,400 --> 00:18:25,840
only have

550
00:18:22,799 --> 00:18:28,480
very few engrams and

551
00:18:25,840 --> 00:18:29,760
if we have two it gets better and three

552
00:18:28,480 --> 00:18:31,280
and of course the more we have the

553
00:18:29,760 --> 00:18:33,520
better it gets

554
00:18:31,280 --> 00:18:35,360
so we can see some families are more

555
00:18:33,520 --> 00:18:36,559
uniform than others

556
00:18:35,360 --> 00:18:38,240
and we can also see that the

557
00:18:36,559 --> 00:18:38,559
intersection size is vastly different

558
00:18:38,240 --> 00:18:40,960
right

559
00:18:38,559 --> 00:18:42,960
so for examples is very uniform and

560
00:18:40,960 --> 00:18:46,240
contains almost one million

561
00:18:42,960 --> 00:18:47,840
encrypts in the intersection but

562
00:18:46,240 --> 00:18:49,919
for other families it's vastly different

563
00:18:47,840 --> 00:18:51,360
for drydex we need to know a lot of

564
00:18:49,919 --> 00:18:55,120
samples because there's probably much

565
00:18:51,360 --> 00:18:55,120
more diversity in the drydex family

566
00:18:55,200 --> 00:18:58,400
and we need to know like uh one two

567
00:18:56,880 --> 00:19:01,600
three four five six

568
00:18:58,400 --> 00:19:05,200
samples to probably properly detect

569
00:19:01,600 --> 00:19:07,360
drivings and so on

570
00:19:05,200 --> 00:19:09,200
so for other uh the families are quite

571
00:19:07,360 --> 00:19:11,120
different in both aspects which

572
00:19:09,200 --> 00:19:12,320
is important for later when we actually

573
00:19:11,120 --> 00:19:14,559
want to

574
00:19:12,320 --> 00:19:17,120
develop a mechanism to detect those

575
00:19:14,559 --> 00:19:19,360
families and memory items

576
00:19:17,120 --> 00:19:20,559
now here we have the most important part

577
00:19:19,360 --> 00:19:22,639
of our evaluation

578
00:19:20,559 --> 00:19:24,000
where we have actually taken out an

579
00:19:22,640 --> 00:19:26,160
experiment to develop

580
00:19:24,000 --> 00:19:27,039
a mechanism to see how well we can

581
00:19:26,160 --> 00:19:29,120
detect the

582
00:19:27,039 --> 00:19:31,039
presence of a marble family in a memory

583
00:19:29,120 --> 00:19:32,799
dump

584
00:19:31,039 --> 00:19:34,640
the way this works is as follows for

585
00:19:32,799 --> 00:19:36,960
each marble family we have created an

586
00:19:34,640 --> 00:19:38,559
equal split of the malware samples

587
00:19:36,960 --> 00:19:40,240
so for example in the case of carbonart

588
00:19:38,559 --> 00:19:41,360
we have used five malware samples for

589
00:19:40,240 --> 00:19:43,520
learning

590
00:19:41,360 --> 00:19:45,600
the fingerprint and then the memory

591
00:19:43,520 --> 00:19:48,480
dumps of the five remaining samples for

592
00:19:45,600 --> 00:19:49,520
a matching fingerprint and you can see

593
00:19:48,480 --> 00:19:52,640
here in the

594
00:19:49,520 --> 00:19:54,639
corresponding cell that on average 5.51

595
00:19:52,640 --> 00:19:56,320
of the fingerprint have matched and the

596
00:19:54,640 --> 00:20:00,400
average entropy of the

597
00:19:56,320 --> 00:20:03,039
matching engrams was 4.26

598
00:20:00,400 --> 00:20:04,000
and in you can see in the other cases so

599
00:20:03,039 --> 00:20:05,360
in the case of carbon

600
00:20:04,000 --> 00:20:07,039
only carbonar conventional average

601
00:20:05,360 --> 00:20:08,320
variable in the other cases it did not

602
00:20:07,039 --> 00:20:12,559
match that well

603
00:20:08,320 --> 00:20:14,240
it's not really 0 but we excluded

604
00:20:12,559 --> 00:20:18,720
a result from the table if the average

605
00:20:14,240 --> 00:20:21,440
was below 0.01 percent

606
00:20:18,720 --> 00:20:23,280
chest for readability reasons and based

607
00:20:21,440 --> 00:20:25,679
on those results we have then

608
00:20:23,280 --> 00:20:27,039
evaluated optimal thresholds for both

609
00:20:25,679 --> 00:20:30,240
the average matching

610
00:20:27,039 --> 00:20:33,520
portion of memory lamps and also

611
00:20:30,240 --> 00:20:37,120
for the average entropy

612
00:20:33,520 --> 00:20:40,158
um as we can see on average

613
00:20:37,120 --> 00:20:42,000
it works out as expected so the

614
00:20:40,159 --> 00:20:43,360
family a fingerprint for family on

615
00:20:42,000 --> 00:20:46,640
average matches

616
00:20:43,360 --> 00:20:48,559
really well only with its own family

617
00:20:46,640 --> 00:20:50,159
in the case of forum we have one false

618
00:20:48,559 --> 00:20:52,000
positive

619
00:20:50,159 --> 00:20:53,600
that is explained in detail in the paper

620
00:20:52,000 --> 00:20:56,080
why we have that false positive

621
00:20:53,600 --> 00:20:58,399
just to say that our approach of course

622
00:20:56,080 --> 00:21:01,520
also has limitations

623
00:20:58,400 --> 00:21:03,280
and if we proceed with the remaining

624
00:21:01,520 --> 00:21:05,280
family members so the table is split in

625
00:21:03,280 --> 00:21:07,600
two for readability reasons

626
00:21:05,280 --> 00:21:08,799
and we can see that it also worked

627
00:21:07,600 --> 00:21:12,719
pretty well for

628
00:21:08,799 --> 00:21:14,840
others we did not

629
00:21:12,720 --> 00:21:17,440
get all true positives in the case of

630
00:21:14,840 --> 00:21:20,080
nymane and also virat also had some

631
00:21:17,440 --> 00:21:21,760
cases where it didn't work that well

632
00:21:20,080 --> 00:21:23,678
but all those for all those cases we

633
00:21:21,760 --> 00:21:26,480
actually did case studies

634
00:21:23,679 --> 00:21:28,080
with quite some interesting insights

635
00:21:26,480 --> 00:21:31,440
that can all be found

636
00:21:28,080 --> 00:21:33,120
in the paper in total the result of this

637
00:21:31,440 --> 00:21:34,960
evaluation is that our

638
00:21:33,120 --> 00:21:36,320
approach gives a true positive rate of

639
00:21:34,960 --> 00:21:39,440
93

640
00:21:36,320 --> 00:21:40,960
and a false positive rate of 0.15 which

641
00:21:39,440 --> 00:21:43,039
shows

642
00:21:40,960 --> 00:21:44,480
the feasibility of our approach in

643
00:21:43,039 --> 00:21:46,480
practice

644
00:21:44,480 --> 00:21:47,520
now let's talk about the limitations of

645
00:21:46,480 --> 00:21:50,240
our approach

646
00:21:47,520 --> 00:21:52,400
um so we make some assumptions that

647
00:21:50,240 --> 00:21:55,440
could be challenged by some people

648
00:21:52,400 --> 00:21:57,600
so for example what could happen is that

649
00:21:55,440 --> 00:21:58,799
the malware behaves differently on two

650
00:21:57,600 --> 00:22:00,559
operating systems

651
00:21:58,799 --> 00:22:03,360
and has a different memory footprint so

652
00:22:00,559 --> 00:22:05,600
the intersection won't really work

653
00:22:03,360 --> 00:22:07,678
that can happen it mainly applies to

654
00:22:05,600 --> 00:22:09,600
droppers so a dropper might drop a

655
00:22:07,679 --> 00:22:11,360
different campaign on windows xp than it

656
00:22:09,600 --> 00:22:13,120
does on windows 7

657
00:22:11,360 --> 00:22:14,719
might show up something randomly for

658
00:22:13,120 --> 00:22:17,280
other reasons that

659
00:22:14,720 --> 00:22:17,919
i don't that we cannot know in advance

660
00:22:17,280 --> 00:22:20,000
um

661
00:22:17,919 --> 00:22:22,000
so in this case of course our approach

662
00:22:20,000 --> 00:22:24,799
won't work

663
00:22:22,000 --> 00:22:28,080
another problem is that we assume that

664
00:22:24,799 --> 00:22:30,639
the malware is always present in memory

665
00:22:28,080 --> 00:22:32,480
which might not necessarily be the case

666
00:22:30,640 --> 00:22:33,280
for example you think of ransomware so

667
00:22:32,480 --> 00:22:35,280
there's

668
00:22:33,280 --> 00:22:36,960
there are ransomwares that just change

669
00:22:35,280 --> 00:22:38,960
the desktop background once and then

670
00:22:36,960 --> 00:22:40,480
they exit and then leave the memory

671
00:22:38,960 --> 00:22:42,559
and the desktop background then contains

672
00:22:40,480 --> 00:22:43,919
the ransom message so in this case if

673
00:22:42,559 --> 00:22:44,720
there is no memory footprint of the

674
00:22:43,919 --> 00:22:47,200
malware

675
00:22:44,720 --> 00:22:48,880
our system doesn't work however the

676
00:22:47,200 --> 00:22:51,679
infected memory dump will also not

677
00:22:48,880 --> 00:22:53,280
really have that information in memory

678
00:22:51,679 --> 00:22:55,600
because for example in the case of the

679
00:22:53,280 --> 00:22:58,000
change desktop picture it will be

680
00:22:55,600 --> 00:22:59,678
on the disk right so yeah it cannot work

681
00:22:58,000 --> 00:23:01,600
in the case

682
00:22:59,679 --> 00:23:03,760
then there are also very complex packing

683
00:23:01,600 --> 00:23:04,639
schemes or fiscation schemes that we

684
00:23:03,760 --> 00:23:06,240
cannot deal with

685
00:23:04,640 --> 00:23:08,720
so for example if you have something

686
00:23:06,240 --> 00:23:10,960
like vm obfuscation or you have packing

687
00:23:08,720 --> 00:23:13,919
schemes where functions are

688
00:23:10,960 --> 00:23:15,360
lazily packed and unpacked on demand so

689
00:23:13,919 --> 00:23:17,200
whenever you need a function you unpack

690
00:23:15,360 --> 00:23:20,559
it and when you don't need the function

691
00:23:17,200 --> 00:23:22,000
you pack it again that's really out of

692
00:23:20,559 --> 00:23:23,600
scope for us that doesn't really work

693
00:23:22,000 --> 00:23:26,240
because at the time we take the memory

694
00:23:23,600 --> 00:23:26,959
dump we can only see what is unpacked at

695
00:23:26,240 --> 00:23:28,400
that moment

696
00:23:26,960 --> 00:23:33,039
and that can be different on both

697
00:23:28,400 --> 00:23:33,039
systems so these are also out of scope

698
00:23:33,200 --> 00:23:36,960
in the reviews we have also seen that

699
00:23:35,039 --> 00:23:39,039
some people mentioned alternative

700
00:23:36,960 --> 00:23:41,520
instruction set architectures

701
00:23:39,039 --> 00:23:43,679
that's not really a limitation because

702
00:23:41,520 --> 00:23:45,279
adding a new adding support for new

703
00:23:43,679 --> 00:23:46,880
instructions and architecture is merely

704
00:23:45,279 --> 00:23:49,360
an engineering effort so for example if

705
00:23:46,880 --> 00:23:51,200
you want netbyte code you just need to

706
00:23:49,360 --> 00:23:52,559
add a disassembler for that bytecode and

707
00:23:51,200 --> 00:23:56,960
write a new card heuristic

708
00:23:52,559 --> 00:24:00,000
so that works now to conclude

709
00:23:56,960 --> 00:24:02,080
i have presented exo-essic with the

710
00:24:00,000 --> 00:24:04,080
crossos execution which is the first

711
00:24:02,080 --> 00:24:07,199
methodology to exploit us diversity

712
00:24:04,080 --> 00:24:08,480
from for malware analysis it works in a

713
00:24:07,200 --> 00:24:10,720
purely forensic setting

714
00:24:08,480 --> 00:24:12,320
it is completely automatic and most

715
00:24:10,720 --> 00:24:13,279
importantly it is also completely

716
00:24:12,320 --> 00:24:17,760
independent of

717
00:24:13,279 --> 00:24:19,760
any os or idiosyncrasies in particular

718
00:24:17,760 --> 00:24:21,520
i don't see why this wouldn't also work

719
00:24:19,760 --> 00:24:23,600
for linux for example or any other

720
00:24:21,520 --> 00:24:26,879
operating system

721
00:24:23,600 --> 00:24:28,639
we have seen a promising evaluation

722
00:24:26,880 --> 00:24:30,720
that shows that our approach is actually

723
00:24:28,640 --> 00:24:33,760
feasible in practice with a 93

724
00:24:30,720 --> 00:24:35,600
true positive rate and a 0.15 false

725
00:24:33,760 --> 00:24:37,520
positive rate

726
00:24:35,600 --> 00:24:39,120
so that's it for my talk you can see

727
00:24:37,520 --> 00:24:41,918
again the overview of how

728
00:24:39,120 --> 00:24:46,080
our system works and i'd be happy to

729
00:24:41,919 --> 00:24:46,080
answer questions

