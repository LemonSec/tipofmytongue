1
00:00:00,560 --> 00:00:03,389
you're the last one yeah best whatever

2
00:00:03,389 --> 00:00:09,870
yeah actually great crowd so we're

3
00:00:09,870 --> 00:00:12,769
finishing with an academic presentation

4
00:00:12,769 --> 00:00:16,109
so no no I take a kid I guess yeah

5
00:00:16,109 --> 00:00:19,080
energy in between your from academia yes

6
00:00:19,080 --> 00:00:20,310
I'm like an email yeah but I'm also

7
00:00:20,310 --> 00:00:22,640
doing a lot of reverse engineering so

8
00:00:22,640 --> 00:00:27,090
and all this conference has been to be

9
00:00:27,090 --> 00:00:29,189
bringing together people from the

10
00:00:29,189 --> 00:00:31,109
private sector from academia from law

11
00:00:31,109 --> 00:00:34,350
enforcement and so on so I'm happy that

12
00:00:34,350 --> 00:00:38,010
we finish with you Thomas you have the

13
00:00:38,010 --> 00:00:40,590
floor ok thank you hello my name is

14
00:00:40,590 --> 00:00:44,969
Tomas vamos and I'm from 405 kie and I

15
00:00:44,969 --> 00:00:46,440
think would like to take everybody

16
00:00:46,440 --> 00:00:48,660
that's still here even though it's the

17
00:00:48,660 --> 00:00:51,770
last lot today I'm going to talk about

18
00:00:51,770 --> 00:00:54,570
behavior driven development in math

19
00:00:54,570 --> 00:00:57,989
analysis might sound strange at first so

20
00:00:57,989 --> 00:01:00,719
therefore that's actually the word cloud

21
00:01:00,719 --> 00:01:02,309
of the loot paperboard for this

22
00:01:02,309 --> 00:01:04,729
presentation and our three words that

23
00:01:04,729 --> 00:01:07,170
the actually should strike your eyelids

24
00:01:07,170 --> 00:01:09,630
test code and maybe and you might be

25
00:01:09,630 --> 00:01:11,970
asking well there's one outlier white

26
00:01:11,970 --> 00:01:15,060
may be called and maybe that works but

27
00:01:15,060 --> 00:01:18,630
testing so and depth what my talk is

28
00:01:18,630 --> 00:01:21,780
going to be about so how we could

29
00:01:21,780 --> 00:01:24,540
improve basically some parts of the mavs

30
00:01:24,540 --> 00:01:26,580
analysis process by using basically

31
00:01:26,580 --> 00:01:29,130
something like testing or behavioral

32
00:01:29,130 --> 00:01:35,130
development so as a quick motivation as

33
00:01:35,130 --> 00:01:37,680
you all know really maybe analysis

34
00:01:37,680 --> 00:01:39,659
continues to be tedious and very

35
00:01:39,659 --> 00:01:43,649
time-consuming and some people might

36
00:01:43,649 --> 00:01:47,850
call it job security you have to if you

37
00:01:47,850 --> 00:01:50,009
really want to do profound analysis you

38
00:01:50,009 --> 00:01:52,740
have to get your hands on it and some

39
00:01:52,740 --> 00:01:56,070
one of those task you actually doing on

40
00:01:56,070 --> 00:01:59,340
a daily basis or it's the extraction of

41
00:01:59,340 --> 00:02:02,040
certain behavior from a malicious binary

42
00:02:02,040 --> 00:02:06,119
let's say the network protocol or a GGA

43
00:02:06,119 --> 00:02:10,590
and what you usually would do is you

44
00:02:10,590 --> 00:02:13,590
analyze the probably obfuscated by

45
00:02:13,590 --> 00:02:16,379
we code and then you basically we

46
00:02:16,379 --> 00:02:19,260
implemented in a higher higher language

47
00:02:19,260 --> 00:02:21,629
like C and pious in order to be able to

48
00:02:21,629 --> 00:02:24,200
execute this behavior what happens is

49
00:02:24,200 --> 00:02:26,670
many people what many people do and I

50
00:02:26,670 --> 00:02:28,410
count my cell phone because I do it

51
00:02:28,410 --> 00:02:30,450
sometimes as well as that you you

52
00:02:30,450 --> 00:02:33,599
basically are a poor decompiler you

53
00:02:33,599 --> 00:02:35,879
basically I'm just translating the code

54
00:02:35,879 --> 00:02:39,299
from assembly to python and the exs and

55
00:02:39,299 --> 00:02:41,819
EB exes are still floating around in the

56
00:02:41,819 --> 00:02:45,239
Python code so and also you don't

57
00:02:45,239 --> 00:02:47,880
actually ensure the functionality so you

58
00:02:47,880 --> 00:02:50,010
don't know if it's really working for

59
00:02:50,010 --> 00:02:52,739
for a lot of cases or just the strange

60
00:02:52,739 --> 00:02:56,430
corner kasem you picked and we added

61
00:02:56,430 --> 00:02:59,819
durability might be very poor you don't

62
00:02:59,819 --> 00:03:01,349
have actually the communication of this

63
00:03:01,349 --> 00:03:03,709
code how you can interact with this so

64
00:03:03,709 --> 00:03:07,230
maybe other people you give it a handout

65
00:03:07,230 --> 00:03:09,810
have to reverse this code as well and

66
00:03:09,810 --> 00:03:12,299
yeah the an annoying semantics are

67
00:03:12,299 --> 00:03:13,920
sometimes not CLE because you don't

68
00:03:13,920 --> 00:03:15,959
think about it you just decompiling it

69
00:03:15,959 --> 00:03:19,230
so I propose maybe a solution to maybe

70
00:03:19,230 --> 00:03:21,510
improve this process here little bit so

71
00:03:21,510 --> 00:03:25,680
let's see how this might work before I

72
00:03:25,680 --> 00:03:27,209
would like to talk about related work

73
00:03:27,209 --> 00:03:30,180
they think what we wanted to have would

74
00:03:30,180 --> 00:03:32,400
be something that we could automatically

75
00:03:32,400 --> 00:03:35,519
expect this malicious behavior in serie

76
00:03:35,519 --> 00:03:37,980
this is this actually works according to

77
00:03:37,980 --> 00:03:40,530
the academic papers that they'd have

78
00:03:40,530 --> 00:03:43,500
been written so we just pinpoint to

79
00:03:43,500 --> 00:03:46,169
behavior and extracted and have our our

80
00:03:46,169 --> 00:03:48,690
self contained binary but in practice

81
00:03:48,690 --> 00:03:51,030
there are so many so many urban problems

82
00:03:51,030 --> 00:03:52,799
that have to be tacit that this stuff

83
00:03:52,799 --> 00:03:57,000
does not work in practice and also in

84
00:03:57,000 --> 00:03:58,889
many cases it's it's not publicly

85
00:03:58,889 --> 00:04:03,870
available so then what people also tried

86
00:04:03,870 --> 00:04:08,480
and they I'm kind of what I'm like I'm

87
00:04:08,480 --> 00:04:12,239
going to do is that they they applied

88
00:04:12,239 --> 00:04:14,190
test even development to reverse

89
00:04:14,190 --> 00:04:16,320
engineering in order to improve it

90
00:04:16,320 --> 00:04:21,539
somehow but there are per day they

91
00:04:21,539 --> 00:04:23,039
demand that the source code and

92
00:04:23,039 --> 00:04:25,080
documentation is there which is not

93
00:04:25,080 --> 00:04:26,560
always the case in

94
00:04:26,560 --> 00:04:31,360
of Navy so then I thought about what

95
00:04:31,360 --> 00:04:33,430
what I wanted to get from of a proper

96
00:04:33,430 --> 00:04:36,580
solution in order to improve it so what

97
00:04:36,580 --> 00:04:39,310
I want to f is is that it's the analyst

98
00:04:39,310 --> 00:04:42,310
allows first to describe concisely and

99
00:04:42,310 --> 00:04:44,410
naturally what he's observing in the

100
00:04:44,410 --> 00:04:46,660
binary and what's the behavior and all

101
00:04:46,660 --> 00:04:48,310
its certain modes actually doing a

102
00:04:48,310 --> 00:04:50,620
natural language so by describing it

103
00:04:50,620 --> 00:04:52,960
you're improving your understanding of

104
00:04:52,960 --> 00:04:56,290
it then cheering implementing it I

105
00:04:56,290 --> 00:04:59,200
wanted to work continuously so I want to

106
00:04:59,200 --> 00:05:01,060
have my test let's say well this subtle

107
00:05:01,060 --> 00:05:03,400
do works and keeps on working while I'm

108
00:05:03,400 --> 00:05:06,360
working on an hour sub-module maybe and

109
00:05:06,360 --> 00:05:10,510
then the resulting code should be should

110
00:05:10,510 --> 00:05:14,850
be concise documented and readable and

111
00:05:14,850 --> 00:05:17,740
finally I would like to increase may be

112
00:05:17,740 --> 00:05:20,650
the focus of an analyst by doing it so

113
00:05:20,650 --> 00:05:22,720
my solution would be just to try

114
00:05:22,720 --> 00:05:24,669
something like a test to like a starch

115
00:05:24,669 --> 00:05:26,500
room development process in this case

116
00:05:26,500 --> 00:05:28,720
behavior to have development and apply

117
00:05:28,720 --> 00:05:32,289
to meta-analysis so before i'm going to

118
00:05:32,289 --> 00:05:34,690
talk about and how I'm going to do it

119
00:05:34,690 --> 00:05:37,660
I'm just giving quick recap about statue

120
00:05:37,660 --> 00:05:41,110
of development and first there was

121
00:05:41,110 --> 00:05:44,260
basically software testing and what it

122
00:05:44,260 --> 00:05:46,150
was in software testing we're doing it

123
00:05:46,150 --> 00:05:49,120
since a couple of decades what it

124
00:05:49,120 --> 00:05:51,100
actually does the test test whether

125
00:05:51,100 --> 00:05:54,280
software that's what it's supposed to do

126
00:05:54,280 --> 00:05:58,539
and Sons through the law but in in the

127
00:05:58,539 --> 00:06:00,550
end this shows also quality to the

128
00:06:00,550 --> 00:06:03,610
stakeholders they maybe pay you for the

129
00:06:03,610 --> 00:06:07,360
software your programming and yeah the

130
00:06:07,360 --> 00:06:08,680
problems here is if you're doing it

131
00:06:08,680 --> 00:06:10,630
infrequently for example if people did

132
00:06:10,630 --> 00:06:13,000
in a waterfall model then you you'd

133
00:06:13,000 --> 00:06:14,800
write a concept you want to software a

134
00:06:14,800 --> 00:06:16,960
couple of weeks you doing the testing by

135
00:06:16,960 --> 00:06:19,000
another team this does not work that

136
00:06:19,000 --> 00:06:22,660
good also if you first write the code

137
00:06:22,660 --> 00:06:24,700
and then try to test that you won't have

138
00:06:24,700 --> 00:06:26,530
a very high code coverage of the test

139
00:06:26,530 --> 00:06:28,750
and yeah if you do if you don't

140
00:06:28,750 --> 00:06:31,150
automatic doing it automatically yeah

141
00:06:31,150 --> 00:06:34,120
it's not that efficient so people at the

142
00:06:34,120 --> 00:06:35,590
beginning of the millennium basically

143
00:06:35,590 --> 00:06:37,000
came up was test with the development

144
00:06:37,000 --> 00:06:39,460
and the idea is that you write the test

145
00:06:39,460 --> 00:06:40,060
first

146
00:06:40,060 --> 00:06:43,270
and then you implement some actually

147
00:06:43,270 --> 00:06:47,250
what your what what you're testing so

148
00:06:47,250 --> 00:06:49,180
interesting development we've got this

149
00:06:49,180 --> 00:06:55,419
the small circle here and it's contains

150
00:06:55,419 --> 00:06:58,450
the 33 different steps at first you

151
00:06:58,450 --> 00:07:01,780
write actually the chest what of what

152
00:07:01,780 --> 00:07:06,060
you what you want to implement and then

153
00:07:06,060 --> 00:07:10,600
then you you you see the test fail you

154
00:07:10,600 --> 00:07:12,540
executed of course automatically and

155
00:07:12,540 --> 00:07:15,790
then you implement as much gold as you

156
00:07:15,790 --> 00:07:18,520
as you need in order to make this test

157
00:07:18,520 --> 00:07:22,630
pass so this ensures that for example

158
00:07:22,630 --> 00:07:25,600
you've gotta want ideally you that you

159
00:07:25,600 --> 00:07:29,560
got 10 percent on pest college in last

160
00:07:29,560 --> 00:07:31,570
step you actually refactoring it and we

161
00:07:31,570 --> 00:07:33,070
affect doing it's always a touchy

162
00:07:33,070 --> 00:07:35,650
subject because people if you if you

163
00:07:35,650 --> 00:07:37,270
don't have tests and you have to be fact

164
00:07:37,270 --> 00:07:39,940
like something on the other end of the

165
00:07:39,940 --> 00:07:42,669
software you might break it on the other

166
00:07:42,669 --> 00:07:45,820
hand side so if you got tests and you

167
00:07:45,820 --> 00:07:48,010
get directly notice that if you break

168
00:07:48,010 --> 00:07:50,530
something well then then you're very

169
00:07:50,530 --> 00:07:52,539
confident to do it furthermore those

170
00:07:52,539 --> 00:07:55,539
tests actually serve as a low level as a

171
00:07:55,539 --> 00:07:57,669
low-level documentation of your code

172
00:07:57,669 --> 00:07:59,950
because because they show how to

173
00:07:59,950 --> 00:08:01,810
interact with the with the modules that

174
00:08:01,810 --> 00:08:03,669
you're writing so programmers can we

175
00:08:03,669 --> 00:08:05,880
chose test and know how to use this code

176
00:08:05,880 --> 00:08:08,350
so then people came up actually with

177
00:08:08,350 --> 00:08:10,350
behavior to whom development which

178
00:08:10,350 --> 00:08:13,780
encounter HOTD focuses more on a clean

179
00:08:13,780 --> 00:08:15,610
understanding of the software behavior

180
00:08:15,610 --> 00:08:18,010
instead of let's say on a function level

181
00:08:18,010 --> 00:08:22,840
and very low level so they are a little

182
00:08:22,840 --> 00:08:25,750
bit high level basically on BDD emerged

183
00:08:25,750 --> 00:08:29,220
from Trinity and half a year ago I I

184
00:08:29,220 --> 00:08:31,990
write on their website they are still

185
00:08:31,990 --> 00:08:34,270
discussing what's actually be DD so

186
00:08:34,270 --> 00:08:36,159
there's nothing like Instagram they say

187
00:08:36,159 --> 00:08:38,110
if you don't do this you don't do scrum

188
00:08:38,110 --> 00:08:40,450
they're more like they're not that much

189
00:08:40,450 --> 00:08:42,010
trick they say yeah if you do this this

190
00:08:42,010 --> 00:08:45,100
could be also be DD the the good thing

191
00:08:45,100 --> 00:08:47,020
the important thing here to notice is

192
00:08:47,020 --> 00:08:49,540
that where the test cases you're

193
00:08:49,540 --> 00:08:51,550
basically writing are in natural

194
00:08:51,550 --> 00:08:53,320
language so and

195
00:08:53,320 --> 00:08:57,290
this allows you to first express your

196
00:08:57,290 --> 00:09:00,279
thoughts like you actually thinking and

197
00:09:00,279 --> 00:09:02,779
even though you expecting the don't

198
00:09:02,779 --> 00:09:05,660
stuff in natural language you've got a

199
00:09:05,660 --> 00:09:08,120
storm Fay theoretic foundation maybe

200
00:09:08,120 --> 00:09:10,520
using using basically the whole logic

201
00:09:10,520 --> 00:09:14,180
which is used in order to prove the

202
00:09:14,180 --> 00:09:16,300
partial correctness of computer programs

203
00:09:16,300 --> 00:09:19,610
here on the bottom part of the bottom

204
00:09:19,610 --> 00:09:21,230
part of the slide you can see the

205
00:09:21,230 --> 00:09:24,700
so-called horrible which is basically

206
00:09:24,700 --> 00:09:27,980
pcq and it's a stand as a set of peace

207
00:09:27,980 --> 00:09:30,770
which is which are preconditions and see

208
00:09:30,770 --> 00:09:32,660
is a command and if this command is

209
00:09:32,660 --> 00:09:34,279
executed with this set of preconditions

210
00:09:34,279 --> 00:09:38,600
then he has to hold well basically this

211
00:09:38,600 --> 00:09:40,820
is then expressed in natural language

212
00:09:40,820 --> 00:09:44,930
like given when then so typical BDD test

213
00:09:44,930 --> 00:09:47,089
looks like this let's say you've got is

214
00:09:47,089 --> 00:09:49,580
got a coffee maker and implementing the

215
00:09:49,580 --> 00:09:52,850
scenario that you did you adding the

216
00:09:52,850 --> 00:09:55,400
sugar to the coffee so you given that

217
00:09:55,400 --> 00:09:57,740
the customer has pressed the shutter

218
00:09:57,740 --> 00:10:01,310
button when the customer passes the code

219
00:10:01,310 --> 00:10:03,200
button in order to make this ultra

220
00:10:03,200 --> 00:10:05,660
Buddhist coffee then actually the coffee

221
00:10:05,660 --> 00:10:10,850
shall have sugar within it so now i'm

222
00:10:10,850 --> 00:10:13,220
showing you how to how we could apply

223
00:10:13,220 --> 00:10:16,690
apply actually just to two meth analysis

224
00:10:16,690 --> 00:10:21,230
so that's the overview how you would do

225
00:10:21,230 --> 00:10:24,500
how you could do it and so it's there to

226
00:10:24,500 --> 00:10:26,870
actually to two phases so we've got a

227
00:10:26,870 --> 00:10:30,170
preparation phase where you basically

228
00:10:30,170 --> 00:10:32,839
get you your machines ready your virtual

229
00:10:32,839 --> 00:10:36,950
machines ready but also you hear your

230
00:10:36,950 --> 00:10:39,709
you're writing an initial end-to-end

231
00:10:39,709 --> 00:10:41,270
acceptance test of the behavior that

232
00:10:41,270 --> 00:10:44,530
youtube that your we implementing and

233
00:10:44,530 --> 00:10:48,170
once this acceptance test passes mess

234
00:10:48,170 --> 00:10:50,680
you Selita then you know that you've

235
00:10:50,680 --> 00:10:54,620
100% implemented this behavior and once

236
00:10:54,620 --> 00:10:56,690
you've finished this preparation phase

237
00:10:56,690 --> 00:10:58,010
you're going into the implementation

238
00:10:58,010 --> 00:11:01,190
phase which is kind of inspired by just

239
00:11:01,190 --> 00:11:03,360
tdg cycle it's

240
00:11:03,360 --> 00:11:05,660
it's the first you've got an observe

241
00:11:05,660 --> 00:11:09,720
fair step where you basically looking at

242
00:11:09,720 --> 00:11:11,610
the binary and trying to understand what

243
00:11:11,610 --> 00:11:13,709
are what is happening then you're

244
00:11:13,709 --> 00:11:15,269
writing a test for the part that you are

245
00:11:15,269 --> 00:11:17,940
we implementing then you then you're

246
00:11:17,940 --> 00:11:19,980
actually implementing what are you am

247
00:11:19,980 --> 00:11:21,870
going to be implemented and then you're

248
00:11:21,870 --> 00:11:23,670
going to refactor it in order to make it

249
00:11:23,670 --> 00:11:27,510
nice and concisely now I'm going into

250
00:11:27,510 --> 00:11:29,490
the detail of all the phases first I'm

251
00:11:29,490 --> 00:11:31,890
starting with the preparation faced with

252
00:11:31,890 --> 00:11:34,410
very important thing here is you have to

253
00:11:34,410 --> 00:11:36,360
pinpoint basically the behavior at first

254
00:11:36,360 --> 00:11:38,010
of the binary otherwise you won't be

255
00:11:38,010 --> 00:11:39,930
able to reverse it so that's the first

256
00:11:39,930 --> 00:11:42,680
step and and what are you doing is that

257
00:11:42,680 --> 00:11:45,600
you're basically trying to find an entry

258
00:11:45,600 --> 00:11:48,180
point of this behavior just let's assume

259
00:11:48,180 --> 00:11:50,430
it's a DJ because we all by now we all

260
00:11:50,430 --> 00:11:54,269
lofty GS so where let's say something is

261
00:11:54,269 --> 00:11:57,300
pest in that's dead CS the entry point

262
00:11:57,300 --> 00:12:00,810
and then at some point the behavior or

263
00:12:00,810 --> 00:12:02,700
the algorithm that is associated with

264
00:12:02,700 --> 00:12:06,060
the behavior and so that's our one on

265
00:12:06,060 --> 00:12:07,620
multiple exit points because there might

266
00:12:07,620 --> 00:12:08,940
be error conditions and so on and so

267
00:12:08,940 --> 00:12:12,810
forth at those are basically borders of

268
00:12:12,810 --> 00:12:15,149
of the behavior you would extract

269
00:12:15,149 --> 00:12:19,110
initial test data so you actually

270
00:12:19,110 --> 00:12:21,600
acquiring a set of input and output data

271
00:12:21,600 --> 00:12:24,480
and using this phone and acceptance test

272
00:12:24,480 --> 00:12:27,839
and this acceptance test basically gate

273
00:12:27,839 --> 00:12:31,829
guides you through through the food of

274
00:12:31,829 --> 00:12:34,890
implementation process because at first

275
00:12:34,890 --> 00:12:36,600
if you first execute it you don't have

276
00:12:36,600 --> 00:12:41,490
any code it will fail but then if you if

277
00:12:41,490 --> 00:12:43,230
you if you re implemented to be everyone

278
00:12:43,230 --> 00:12:46,050
a percent and this acceptance test will

279
00:12:46,050 --> 00:12:51,779
or should definitely pass so as an

280
00:12:51,779 --> 00:12:54,779
example again here a BGA how could one a

281
00:12:54,779 --> 00:12:58,440
pinpoint DGA I don't have to say that

282
00:12:58,440 --> 00:13:00,959
much about each years we saw saw a lot

283
00:13:00,959 --> 00:13:03,300
of them so basically there's a

284
00:13:03,300 --> 00:13:05,490
classification how you could classify

285
00:13:05,490 --> 00:13:07,620
them so there is a deterministic or non

286
00:13:07,620 --> 00:13:09,779
deterministic or a time dependent or

287
00:13:09,779 --> 00:13:13,910
time independent and most of them are

288
00:13:13,910 --> 00:13:16,610
time dependent so

289
00:13:16,610 --> 00:13:19,380
what what what what one could do you see

290
00:13:19,380 --> 00:13:21,570
you basically doing a naive approach and

291
00:13:21,570 --> 00:13:24,240
now if approached doing a forward

292
00:13:24,240 --> 00:13:26,130
analysis and just looking at the time

293
00:13:26,130 --> 00:13:30,540
sources and the idea here is well if the

294
00:13:30,540 --> 00:13:33,840
if the DJ is really time dependent then

295
00:13:33,840 --> 00:13:35,880
just break on all the time sources and

296
00:13:35,880 --> 00:13:38,520
follow the data to maybe the beginning

297
00:13:38,520 --> 00:13:41,040
of the behavior this would be the

298
00:13:41,040 --> 00:13:43,500
forward approach backwards well if it's

299
00:13:43,500 --> 00:13:46,500
really dg8 at some point this those

300
00:13:46,500 --> 00:13:49,280
domain names that are generated gets get

301
00:13:49,280 --> 00:13:53,520
resolved by DNS and well then you could

302
00:13:53,520 --> 00:13:56,400
put some a breakpoint on such a PS like

303
00:13:56,400 --> 00:13:58,920
get host by name and follow it backwards

304
00:13:58,920 --> 00:14:00,510
to the code to the end of the year of

305
00:14:00,510 --> 00:14:03,960
the behavior in the paper I explain

306
00:14:03,960 --> 00:14:09,330
another case but yeah well then that

307
00:14:09,330 --> 00:14:11,610
we're coming out to the real

308
00:14:11,610 --> 00:14:13,440
implementation phase and that's the

309
00:14:13,440 --> 00:14:16,290
first step which is basically observing

310
00:14:16,290 --> 00:14:18,540
the behavior and what we are doing is

311
00:14:18,540 --> 00:14:20,430
we're basically using a top-down

312
00:14:20,430 --> 00:14:24,600
approach and first want to get get a

313
00:14:24,600 --> 00:14:26,370
rough overview of the behavior of the

314
00:14:26,370 --> 00:14:28,410
algorithm and then dive deeper into the

315
00:14:28,410 --> 00:14:32,060
sub algorithms sub modules and

316
00:14:32,060 --> 00:14:36,750
identified these individual features as

317
00:14:36,750 --> 00:14:39,870
a call here and your interfaces very

318
00:14:39,870 --> 00:14:42,210
important is also that we first

319
00:14:42,210 --> 00:14:47,330
implemented on a high level so and then

320
00:14:47,330 --> 00:14:50,660
gather at those interfaces that we've

321
00:14:50,660 --> 00:14:55,410
that we've basically identified this

322
00:14:55,410 --> 00:14:59,760
test a test data for other tests and for

323
00:14:59,760 --> 00:15:03,300
excuse me for for using it and for

324
00:15:03,300 --> 00:15:08,370
mocking it first so this is what what

325
00:15:08,370 --> 00:15:10,260
what I'm going here to talk about it

326
00:15:10,260 --> 00:15:12,420
then when we know what we are going what

327
00:15:12,420 --> 00:15:13,890
part of the behavior we going to

328
00:15:13,890 --> 00:15:15,870
implement and we're stating basically

329
00:15:15,870 --> 00:15:19,260
just this test in a given then when form

330
00:15:19,260 --> 00:15:24,000
and implement testing it's from a high

331
00:15:24,000 --> 00:15:27,840
level and basically one fundamental idea

332
00:15:27,840 --> 00:15:30,000
is that we lose use a lot of

333
00:15:30,000 --> 00:15:33,840
PX and behavior that features that are

334
00:15:33,840 --> 00:15:36,950
very down into the behavior shouldn't be

335
00:15:36,950 --> 00:15:39,360
shouldn't be looked at at first this

336
00:15:39,360 --> 00:15:44,250
helps also to do focus on on one part at

337
00:15:44,250 --> 00:15:47,280
a time so therefore we we just gather at

338
00:15:47,280 --> 00:15:51,150
the interfaces of those sub modules test

339
00:15:51,150 --> 00:15:54,330
data and use more objects and those mock

340
00:15:54,330 --> 00:15:57,150
objects are typically used to mimic real

341
00:15:57,150 --> 00:15:59,430
objects and software development there

342
00:15:59,430 --> 00:16:01,620
for example to replace modern objects

343
00:16:01,620 --> 00:16:04,260
that you cannot accept that you cannot

344
00:16:04,260 --> 00:16:06,900
access due to timing constraints like

345
00:16:06,900 --> 00:16:10,410
databases maybe are non existing objects

346
00:16:10,410 --> 00:16:12,540
and here in our case basically we used

347
00:16:12,540 --> 00:16:14,850
those mock objects to we present parts

348
00:16:14,850 --> 00:16:17,910
of the code that we have understood one

349
00:16:17,910 --> 00:16:22,530
percent yeah then and the in the third

350
00:16:22,530 --> 00:16:25,380
step oh excuse me that's an example

351
00:16:25,380 --> 00:16:27,630
actually how we how we would do it so

352
00:16:27,630 --> 00:16:31,490
that's the behavior which has a main

353
00:16:31,490 --> 00:16:34,290
this is the main behavior and it

354
00:16:34,290 --> 00:16:37,670
consists of three sub modules basically

355
00:16:37,670 --> 00:16:40,110
initialization another sub module called

356
00:16:40,110 --> 00:16:43,800
a main and the initialization and then

357
00:16:43,800 --> 00:16:46,740
this a main also has two sub module a1

358
00:16:46,740 --> 00:16:49,140
and a2 and what we are doing when we

359
00:16:49,140 --> 00:16:51,480
were implementing a menos basically we

360
00:16:51,480 --> 00:16:55,500
mocking a1 and a2 and don't don't deal

361
00:16:55,500 --> 00:16:58,230
with with this at first so we'll be

362
00:16:58,230 --> 00:17:02,130
going from the top to the bottom so in

363
00:17:02,130 --> 00:17:06,030
the third step basically we we trying to

364
00:17:06,030 --> 00:17:10,230
make this justice test for the sub- to

365
00:17:10,230 --> 00:17:13,319
pass and why just enough code to do this

366
00:17:13,319 --> 00:17:16,380
and again we have to we have to look at

367
00:17:16,380 --> 00:17:19,230
the binary this is the this is the valid

368
00:17:19,230 --> 00:17:23,010
system specification that we that we

369
00:17:23,010 --> 00:17:27,660
that we have to we implement and here we

370
00:17:27,660 --> 00:17:29,970
shouldn't care about optimization

371
00:17:29,970 --> 00:17:32,070
because at this stage we should just get

372
00:17:32,070 --> 00:17:34,110
it first white and make the test pass

373
00:17:34,110 --> 00:17:37,440
and then we can optimize it later namely

374
00:17:37,440 --> 00:17:39,140
in the third and fourth step where we

375
00:17:39,140 --> 00:17:41,400
refactoring our code in order to market

376
00:17:41,400 --> 00:17:43,270
more concisely and

377
00:17:43,270 --> 00:17:46,420
readable we affect I mean basically is

378
00:17:46,420 --> 00:17:48,550
its altering of the syntax of the code

379
00:17:48,550 --> 00:17:52,720
without altering the semantics so there

380
00:17:52,720 --> 00:17:54,880
are so many refactorings out there is a

381
00:17:54,880 --> 00:17:57,340
very interesting book with my father a

382
00:17:57,340 --> 00:17:59,320
couple of years ago where you can find a

383
00:17:59,320 --> 00:18:01,860
lot in the case of reverse engineering

384
00:18:01,860 --> 00:18:05,230
we might for example we factoring in

385
00:18:05,230 --> 00:18:07,420
light coat that we've actually we

386
00:18:07,420 --> 00:18:09,280
implemented let's say mm copy your

387
00:18:09,280 --> 00:18:11,410
source alike that we could wake up

388
00:18:11,410 --> 00:18:14,320
complex expression or remove dead

389
00:18:14,320 --> 00:18:17,170
expressions actually at this point in

390
00:18:17,170 --> 00:18:20,050
time we we have a look at this initial

391
00:18:20,050 --> 00:18:23,650
acceptance test that we wrote and look

392
00:18:23,650 --> 00:18:26,350
if this it's passing well then this

393
00:18:26,350 --> 00:18:29,320
means that we've we implemented the

394
00:18:29,320 --> 00:18:32,230
behavior from the from the beginning to

395
00:18:32,230 --> 00:18:34,720
the end basically if it does not pass we

396
00:18:34,720 --> 00:18:37,660
have to go through this cycle one more

397
00:18:37,660 --> 00:18:41,170
time or several times so let's talk a

398
00:18:41,170 --> 00:18:45,030
little bit about limitations critics so

399
00:18:45,030 --> 00:18:47,920
one limitation might be the quiescent

400
00:18:47,920 --> 00:18:51,670
time efficiency we had that's debts that

401
00:18:51,670 --> 00:18:53,380
might be true for example if you think

402
00:18:53,380 --> 00:18:57,280
about some TDD people estimated that

403
00:18:57,280 --> 00:19:01,930
there might be a time time decrease the

404
00:19:01,930 --> 00:19:04,920
time efficiency of between 15 to 35

405
00:19:04,920 --> 00:19:09,700
percent but I think if you if you're

406
00:19:09,700 --> 00:19:13,090
doing it this way the exit sign may pay

407
00:19:13,090 --> 00:19:15,610
off to just several benefits like for

408
00:19:15,610 --> 00:19:18,670
example you're focusing on one part at a

409
00:19:18,670 --> 00:19:21,370
time and the thing is stated for example

410
00:19:21,370 --> 00:19:22,720
having the code working constantly

411
00:19:22,720 --> 00:19:24,880
constantly throughout the implementation

412
00:19:24,880 --> 00:19:29,590
process is of is very very nice to have

413
00:19:29,590 --> 00:19:31,720
so for example if you don't do it and

414
00:19:31,720 --> 00:19:33,190
you introduce the bucket to your code

415
00:19:33,190 --> 00:19:35,440
you could the bucket maybe for fun half

416
00:19:35,440 --> 00:19:38,370
an hour and that makes you also slower

417
00:19:38,370 --> 00:19:41,260
yeah maybe this is more like a critic

418
00:19:41,260 --> 00:19:44,650
that were TD dbdg it's usually for

419
00:19:44,650 --> 00:19:46,180
normal software development why we

420
00:19:46,180 --> 00:19:50,100
shouldn't do apply to Maeve analysis

421
00:19:50,100 --> 00:19:53,230
people say it's throw records it so we

422
00:19:53,230 --> 00:19:56,510
use a nobility might be not needed

423
00:19:56,510 --> 00:19:59,840
and I would say that's that's not too

424
00:19:59,840 --> 00:20:03,200
and we've got long-running projects that

425
00:20:03,200 --> 00:20:05,380
based on court of it was engineers and

426
00:20:05,380 --> 00:20:08,090
therefore it's um first it's important

427
00:20:08,090 --> 00:20:13,730
to have this discord so in order to to

428
00:20:13,730 --> 00:20:15,650
get you to show you how you could use

429
00:20:15,650 --> 00:20:18,620
the practice I want to do a case study

430
00:20:18,620 --> 00:20:21,520
on my name it's maybe topper and

431
00:20:21,520 --> 00:20:24,440
unfortunately I picked on the DJ of my

432
00:20:24,440 --> 00:20:30,890
memory yeah so anyway nine men it's the

433
00:20:30,890 --> 00:20:33,770
neighbor chopper how mainly but also

434
00:20:33,770 --> 00:20:36,380
it's cami it's using parts i think of

435
00:20:36,380 --> 00:20:38,240
the pony loader code in order to grant

436
00:20:38,240 --> 00:20:42,470
stick credentials it's it has socks

437
00:20:42,470 --> 00:20:46,220
boxes what's very interesting about the

438
00:20:46,220 --> 00:20:48,530
family is that it's very heavily

439
00:20:48,530 --> 00:20:50,960
obfuscated it so you would see that in a

440
00:20:50,960 --> 00:20:54,890
minute and i think especially in those

441
00:20:54,890 --> 00:20:57,800
cases some what what I've what I'm

442
00:20:57,800 --> 00:21:00,040
proposing here helps you a lot in our to

443
00:21:00,040 --> 00:21:04,100
to get more get this stuff done more

444
00:21:04,100 --> 00:21:07,480
efficiently there's a little bit work on

445
00:21:07,480 --> 00:21:10,310
decompiling of an older so I not

446
00:21:10,310 --> 00:21:13,880
decompiling of deer for skating this

447
00:21:13,880 --> 00:21:15,740
code of linemen by Danny blown on I'm

448
00:21:15,740 --> 00:21:21,220
called AI de patchwork it's an Ida Ida

449
00:21:21,220 --> 00:21:24,850
plugin but those guys are keep on

450
00:21:24,850 --> 00:21:29,360
obfuscating an obfuscation so yeah it's

451
00:21:29,360 --> 00:21:33,130
it's unfortunately those are very good

452
00:21:33,130 --> 00:21:37,340
so here you can see in a sample unpacked

453
00:21:37,340 --> 00:21:40,430
while example I've analyzed the summer

454
00:21:40,430 --> 00:21:43,940
and what you can see if you can see it

455
00:21:43,940 --> 00:21:47,780
is that it's unpacked the functions look

456
00:21:47,780 --> 00:21:50,570
quite quite regular they are no stones

457
00:21:50,570 --> 00:21:52,790
strange content constants actually those

458
00:21:52,790 --> 00:21:56,630
constants that are there are there are

459
00:21:56,630 --> 00:21:58,880
there are annotated by the prose so

460
00:21:58,880 --> 00:22:02,870
that's that's quite useful the imports

461
00:22:02,870 --> 00:22:05,600
are resolved they seem most reasonable

462
00:22:05,600 --> 00:22:08,330
so you first set some sort options and

463
00:22:08,330 --> 00:22:08,970
then you do

464
00:22:08,970 --> 00:22:12,480
some ever operation on the network API

465
00:22:12,480 --> 00:22:14,669
so this seems reasonable the control

466
00:22:14,669 --> 00:22:17,090
flow also seems reasonable so if you got

467
00:22:17,090 --> 00:22:19,650
experience and we were engineering you

468
00:22:19,650 --> 00:22:21,679
could with this more or less like a book

469
00:22:21,679 --> 00:22:24,690
in contrary if you look at an unpacked

470
00:22:24,690 --> 00:22:29,450
my math sample you you see that the

471
00:22:29,450 --> 00:22:33,360
deaths it's it's full of irregular

472
00:22:33,360 --> 00:22:36,030
functions there is no clear function and

473
00:22:36,030 --> 00:22:40,890
plan or clear function entries also they

474
00:22:40,890 --> 00:22:42,630
are strange constants and actually those

475
00:22:42,630 --> 00:22:44,820
strange constants are for example used

476
00:22:44,820 --> 00:22:49,080
in order to dynamically computer control

477
00:22:49,080 --> 00:22:53,429
flow furthermore this also confuses the

478
00:22:53,429 --> 00:22:55,770
disassembler soraida pro gives you very

479
00:22:55,770 --> 00:23:00,000
poor results and it's basically very

480
00:23:00,000 --> 00:23:04,710
very hard to to statically analyze it

481
00:23:04,710 --> 00:23:06,750
steadily but also it's very hard to

482
00:23:06,750 --> 00:23:12,360
analyze it dynamically because because

483
00:23:12,360 --> 00:23:15,059
all those control flow changes and those

484
00:23:15,059 --> 00:23:17,460
dynamic control flow computations also

485
00:23:17,460 --> 00:23:18,780
met a little bit with your breakpoints

486
00:23:18,780 --> 00:23:24,120
and that's not that much fun what I'd

487
00:23:24,120 --> 00:23:26,190
useful tools for basically the

488
00:23:26,190 --> 00:23:30,270
implementing DJ is that I used standard

489
00:23:30,270 --> 00:23:32,640
tools immunity debugger I de Perrault

490
00:23:32,640 --> 00:23:36,480
used the mandiant APA APA TD national to

491
00:23:36,480 --> 00:23:40,620
fake DNS responses we implemented to

492
00:23:40,620 --> 00:23:42,780
behavior in Python and used as a BDD

493
00:23:42,780 --> 00:23:46,020
library behave later on I'm going to

494
00:23:46,020 --> 00:23:48,539
push the source code to bitbucket so you

495
00:23:48,539 --> 00:23:51,690
can can have a look and I think that's

496
00:23:51,690 --> 00:23:53,490
always better than talking about source

497
00:23:53,490 --> 00:23:56,520
code in slides so you should definitely

498
00:23:56,520 --> 00:23:58,980
have a look and see how it and how one

499
00:23:58,980 --> 00:24:03,659
could do this so what I did was that our

500
00:24:03,659 --> 00:24:05,429
first basically i did some first

501
00:24:05,429 --> 00:24:08,190
observations and i did some basic black

502
00:24:08,190 --> 00:24:11,190
boxing and what I saw the domains that

503
00:24:11,190 --> 00:24:13,770
were resolved basically how looked like

504
00:24:13,770 --> 00:24:15,960
hard-coded domains first of all

505
00:24:15,960 --> 00:24:18,690
connectivity check to Google and then

506
00:24:18,690 --> 00:24:21,720
some something else which look rather

507
00:24:21,720 --> 00:24:22,700
hardcore

508
00:24:22,700 --> 00:24:27,930
then when when when those domains failed

509
00:24:27,930 --> 00:24:30,510
some when many couldn't contact those

510
00:24:30,510 --> 00:24:32,910
domains basically it started to generate

511
00:24:32,910 --> 00:24:36,660
a random domains as you can see there

512
00:24:36,660 --> 00:24:39,420
and I checked it basically quickly and

513
00:24:39,420 --> 00:24:41,370
two different vm saw that the results

514
00:24:41,370 --> 00:24:43,620
are the same and basically then it's

515
00:24:43,620 --> 00:24:47,309
deterministic I supposed and basically

516
00:24:47,309 --> 00:24:50,640
then I changed the time and so yeah

517
00:24:50,640 --> 00:24:54,510
that's time-dependent because on

518
00:24:54,510 --> 00:24:56,790
different dates the the domains are

519
00:24:56,790 --> 00:24:59,340
different so what I did basically I

520
00:24:59,340 --> 00:25:03,030
thought we could break on gets us some

521
00:25:03,030 --> 00:25:06,170
time and bingo it worked so I knew that

522
00:25:06,170 --> 00:25:10,230
this was when I was important api for

523
00:25:10,230 --> 00:25:14,130
for the DJ and we had extra the import

524
00:25:14,130 --> 00:25:16,590
with which was the time more

525
00:25:16,590 --> 00:25:18,960
specifically a certain strike that as we

526
00:25:18,960 --> 00:25:22,410
chart by get system time which was then

527
00:25:22,410 --> 00:25:26,360
later used as a seed and it out put it

528
00:25:26,360 --> 00:25:29,640
basically 30 domain names so then

529
00:25:29,640 --> 00:25:32,010
basically still end up in the

530
00:25:32,010 --> 00:25:36,600
preparation phase we we already knew

531
00:25:36,600 --> 00:25:39,890
very important parameters so we knew the

532
00:25:39,890 --> 00:25:42,780
start and the exit point of the cyber

533
00:25:42,780 --> 00:25:45,270
wisdom saw the interfaces so then we

534
00:25:45,270 --> 00:25:47,550
basically let the battery 1 i've worked

535
00:25:47,550 --> 00:25:49,050
at the beginning of worked at the end

536
00:25:49,050 --> 00:25:51,240
leaded one and gather basically the data

537
00:25:51,240 --> 00:25:54,290
at both ends and wrote an initial

538
00:25:54,290 --> 00:25:57,690
initial acceptance test which guided me

539
00:25:57,690 --> 00:25:59,100
through the implementation showed me

540
00:25:59,100 --> 00:26:02,490
when i've basically finished d behavior

541
00:26:02,490 --> 00:26:06,929
we implementation so this was basically

542
00:26:06,929 --> 00:26:10,850
the first so now we are Ward's the first

543
00:26:10,850 --> 00:26:15,630
this initial acceptance test and this is

544
00:26:15,630 --> 00:26:17,220
a describing the whole behavior so

545
00:26:17,220 --> 00:26:20,190
scenario was that 9am DJ computes

546
00:26:20,190 --> 00:26:24,690
domains on a specific date given the

547
00:26:24,690 --> 00:26:27,570
state blah blah blah that when digit dta

548
00:26:27,570 --> 00:26:30,450
computes the domains for the states then

549
00:26:30,450 --> 00:26:32,700
the domain should be blah blah blah and

550
00:26:32,700 --> 00:26:34,870
they will go 30 domains

551
00:26:34,870 --> 00:26:37,760
what happens is if you executed without

552
00:26:37,760 --> 00:26:39,920
having written code it fails and yeah

553
00:26:39,920 --> 00:26:44,320
well I had to had to be implemented so

554
00:26:44,320 --> 00:26:48,980
what I then I first entered the cycle

555
00:26:48,980 --> 00:26:51,650
first I wasn't this observing face and a

556
00:26:51,650 --> 00:26:53,150
step through the code and notice that

557
00:26:53,150 --> 00:26:55,750
there are several several algorithms

558
00:26:55,750 --> 00:26:57,470
involved like there was an

559
00:26:57,470 --> 00:27:00,590
initialization where the seats at the

560
00:27:00,590 --> 00:27:04,130
time was used and this was there were

561
00:27:04,130 --> 00:27:06,440
some computation with the time and some

562
00:27:06,440 --> 00:27:09,740
hard coded seeds and then it entered as

563
00:27:09,740 --> 00:27:15,050
a main logic and in this main logic the

564
00:27:15,050 --> 00:27:17,600
domains were generated and just main

565
00:27:17,600 --> 00:27:20,960
logic car communicated with another

566
00:27:20,960 --> 00:27:23,120
module which was a pseudo-random number

567
00:27:23,120 --> 00:27:26,990
generator which later then turned out to

568
00:27:26,990 --> 00:27:31,490
be short shift and what what I did

569
00:27:31,490 --> 00:27:34,430
basically I focused on one component at

570
00:27:34,430 --> 00:27:38,000
a time and first we was the main logic

571
00:27:38,000 --> 00:27:41,210
and mocked arrest so that's only part of

572
00:27:41,210 --> 00:27:44,480
the main logic what I die what I did

573
00:27:44,480 --> 00:27:46,520
just try to follow food I did it in the

574
00:27:46,520 --> 00:27:48,830
bar graph I found it to be easier than

575
00:27:48,830 --> 00:27:50,380
doing it statically to do the heavy

576
00:27:50,380 --> 00:27:54,580
obfuscations and basically came up with

577
00:27:54,580 --> 00:28:02,270
came up with this code and then I start

578
00:28:02,270 --> 00:28:04,490
a part of this is only the main the main

579
00:28:04,490 --> 00:28:07,880
module and all the stuff that is that it

580
00:28:07,880 --> 00:28:10,250
is called from there it's still not

581
00:28:10,250 --> 00:28:12,230
implemented so then I thought well it's

582
00:28:12,230 --> 00:28:15,080
no time to focus on another part going

583
00:28:15,080 --> 00:28:18,140
one step deeper and looking at how to

584
00:28:18,140 --> 00:28:21,680
basically compute the teal TLD of a

585
00:28:21,680 --> 00:28:28,880
domain so basically we i mocked

586
00:28:28,880 --> 00:28:34,010
everything the west and then I came up

587
00:28:34,010 --> 00:28:37,340
with the tsunami 444 implement we

588
00:28:37,340 --> 00:28:38,510
implementing this part that actually

589
00:28:38,510 --> 00:28:42,380
computes the td's so I've given scenario

590
00:28:42,380 --> 00:28:44,780
at the name mbj chooses the correct

591
00:28:44,780 --> 00:28:48,320
indieformer set that I that I saw there

592
00:28:48,320 --> 00:28:52,250
and give them some seeds when the TD

593
00:28:52,250 --> 00:28:55,009
should be computed basically this the

594
00:28:55,009 --> 00:29:00,850
tilde should be are you and then I

595
00:29:00,850 --> 00:29:04,970
consulted to binary we looked how it is

596
00:29:04,970 --> 00:29:07,700
done we implemented it data refactoring

597
00:29:07,700 --> 00:29:11,240
moved on to the next part then I already

598
00:29:11,240 --> 00:29:13,130
talked about this from the seeds and the

599
00:29:13,130 --> 00:29:15,110
pseudo-random number generator which was

600
00:29:15,110 --> 00:29:18,259
another module I first just mocked so I

601
00:29:18,259 --> 00:29:20,690
had seats that going in seats that

602
00:29:20,690 --> 00:29:24,019
coming out and furthermore some random

603
00:29:24,019 --> 00:29:26,570
number that was that was generated by it

604
00:29:26,570 --> 00:29:29,960
that I used for an ox now it was time to

605
00:29:29,960 --> 00:29:33,019
to really dive into this pseudo random

606
00:29:33,019 --> 00:29:34,820
number generator at this moment I didn't

607
00:29:34,820 --> 00:29:39,230
know anything about so shift so i

608
00:29:39,230 --> 00:29:44,029
basically arrested and as you can see

609
00:29:44,029 --> 00:29:46,840
here for this has takes five integers

610
00:29:46,840 --> 00:29:49,909
four of them are seeds and one model

611
00:29:49,909 --> 00:29:52,789
module and outputs an integer and the

612
00:29:52,789 --> 00:29:55,909
range of them from silver to multi loom

613
00:29:55,909 --> 00:30:00,110
minus one so one has to be careful here

614
00:30:00,110 --> 00:30:03,440
because the seeds did this the execution

615
00:30:03,440 --> 00:30:04,850
of the speedo random number generator

616
00:30:04,850 --> 00:30:07,870
had basically side effects on the seats

617
00:30:07,870 --> 00:30:11,240
so then I came again first with the test

618
00:30:11,240 --> 00:30:14,809
what I wanted to test and I dived into

619
00:30:14,809 --> 00:30:17,600
the any binary we implemented it we

620
00:30:17,600 --> 00:30:20,210
factor with we moved all the eax and

621
00:30:20,210 --> 00:30:24,529
gave it actually I think by just my

622
00:30:24,529 --> 00:30:28,490
colleague Daniel could quite easily see

623
00:30:28,490 --> 00:30:31,399
that it's sort of any prepare to slide

624
00:30:31,399 --> 00:30:33,200
for this presentation because actually

625
00:30:33,200 --> 00:30:35,809
they use the wikipedia entry they use

626
00:30:35,809 --> 00:30:40,009
also ABC so there was to assemble ten

627
00:30:40,009 --> 00:30:44,090
quite nicely what what do you know

628
00:30:44,090 --> 00:30:46,960
reimplemented implementation looks like

629
00:30:46,960 --> 00:30:51,889
so the results basically were that this

630
00:30:51,889 --> 00:30:54,230
full feature at the end passed after a

631
00:30:54,230 --> 00:30:56,960
couple of tests that I vote for further

632
00:30:56,960 --> 00:31:00,820
sub modules and

633
00:31:01,070 --> 00:31:04,110
that the code basically was readable it

634
00:31:04,110 --> 00:31:07,500
was split and several classes and here

635
00:31:07,500 --> 00:31:11,220
that's the outcome basically confusion

636
00:31:11,220 --> 00:31:14,549
and future work now it's today I showed

637
00:31:14,549 --> 00:31:18,029
you how you could be improved the mavs

638
00:31:18,029 --> 00:31:20,789
analysis venue analysis process when you

639
00:31:20,789 --> 00:31:25,230
we implement behaviors I told you why

640
00:31:25,230 --> 00:31:28,590
you want considering dis approach and i

641
00:31:28,590 --> 00:31:30,480
showed you case study on my name and the

642
00:31:30,480 --> 00:31:32,220
source code and all the tests and slides

643
00:31:32,220 --> 00:31:33,750
and the paper will be also on bitbucket

644
00:31:33,750 --> 00:31:37,380
so you can check it later out future

645
00:31:37,380 --> 00:31:40,409
work would be to to automate a lot of

646
00:31:40,409 --> 00:31:43,770
this stuff what I'm done here manually

647
00:31:43,770 --> 00:31:46,620
for example tools for just gathering the

648
00:31:46,620 --> 00:31:48,270
test data at the interface is just

649
00:31:48,270 --> 00:31:51,570
giving it to maybe writing a tool and

650
00:31:51,570 --> 00:31:54,299
giving it two points in the code and

651
00:31:54,299 --> 00:31:57,210
then executing it and gathering the day

652
00:31:57,210 --> 00:31:59,970
input and output and i'm using it also

653
00:31:59,970 --> 00:32:02,309
for automatic test case generation may

654
00:32:02,309 --> 00:32:05,940
be in order to further improve this so

655
00:32:05,940 --> 00:32:09,539
thank you very much and so i'm open to

656
00:32:09,539 --> 00:32:11,960
questions

657
00:32:18,789 --> 00:32:21,789
questions

658
00:32:27,149 --> 00:32:29,539
very good conference academic

659
00:32:29,539 --> 00:32:35,249
presentation you because you want to use

660
00:32:35,249 --> 00:32:37,289
test techniques from software

661
00:32:37,289 --> 00:32:38,999
engineering to malware analysis is very

662
00:32:38,999 --> 00:32:43,710
good idea but you can't you are only on

663
00:32:43,710 --> 00:32:47,070
what in specific case because we you can

664
00:32:47,070 --> 00:32:50,639
apply your logic only to one single

665
00:32:50,639 --> 00:32:55,379
model deterministic and seek ensure it

666
00:32:55,379 --> 00:32:57,269
is not the case you can't apply these

667
00:32:57,269 --> 00:33:00,029
techniques to multimodal a synchronous

668
00:33:00,029 --> 00:33:03,839
parallel okay in the next step you you

669
00:33:03,839 --> 00:33:08,309
must use formal methods but but have

670
00:33:08,309 --> 00:33:11,099
semantic of non deterministic they have

671
00:33:11,099 --> 00:33:13,799
your a synchronous and with more

672
00:33:13,799 --> 00:33:16,049
complicated with theories sings definite

673
00:33:16,049 --> 00:33:18,239
sons definitely interesting I guess

674
00:33:18,239 --> 00:33:21,109
there is no framework for this yet so in

675
00:33:21,109 --> 00:33:24,179
like I mean vdd is relying on it but

676
00:33:24,179 --> 00:33:26,580
yeah we can talk about this later sounds

677
00:33:26,580 --> 00:33:33,109
very interesting thanks another question

678
00:33:33,950 --> 00:33:39,330
really the last question of the day okay

679
00:33:39,330 --> 00:33:41,749
thank you

