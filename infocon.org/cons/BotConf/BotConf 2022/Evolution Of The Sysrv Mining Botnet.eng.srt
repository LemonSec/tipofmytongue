1
00:00:00,320 --> 00:00:02,240
uh you have the floor thank you thank

2
00:00:02,240 --> 00:00:02,960
you

3
00:00:02,960 --> 00:00:05,440
hi everyone i know that we are the last

4
00:00:05,440 --> 00:00:07,440
one the only one between you and all

5
00:00:07,440 --> 00:00:09,040
your cocktails

6
00:00:09,040 --> 00:00:11,759
and it must be

7
00:00:11,759 --> 00:00:13,360
after a long and

8
00:00:13,360 --> 00:00:15,519
exhausting day after such a lot of

9
00:00:15,519 --> 00:00:17,760
information so we try to keep it short

10
00:00:17,760 --> 00:00:19,279
and hopefully still

11
00:00:19,279 --> 00:00:22,720
interesting we will talk about the sysrv

12
00:00:22,720 --> 00:00:25,119
mining botnet and in the first half of

13
00:00:25,119 --> 00:00:26,720
the presentation and on the in the

14
00:00:26,720 --> 00:00:28,960
second half how to reverse golang

15
00:00:28,960 --> 00:00:31,279
binaries using uh gidra

16
00:00:31,279 --> 00:00:32,719
and just a

17
00:00:32,719 --> 00:00:35,520
few words about who we are so we both

18
00:00:35,520 --> 00:00:37,760
work at cujo ai i

19
00:00:37,760 --> 00:00:39,520
mainly studied mathematics and

20
00:00:39,520 --> 00:00:42,079
cryptography and somehow just reverse

21
00:00:42,079 --> 00:00:44,719
engineering swooped me in because it's

22
00:00:44,719 --> 00:00:46,879
like solving puzzles so i really

23
00:00:46,879 --> 00:00:48,320
enjoy

24
00:00:48,320 --> 00:00:49,680
doing

25
00:00:49,680 --> 00:00:51,840
these kind of things and basically i

26
00:00:51,840 --> 00:00:54,320
just started there

27
00:00:54,320 --> 00:00:57,680
and also i would like to thank albert

28
00:00:57,680 --> 00:01:00,879
gigovic burke who was who was helping us

29
00:01:00,879 --> 00:01:02,640
in the research in the beginning

30
00:01:02,640 --> 00:01:05,519
and now i will give the floor to jury he

31
00:01:05,519 --> 00:01:07,360
will start the presentation and then i

32
00:01:07,360 --> 00:01:10,080
will continue

33
00:01:11,360 --> 00:01:14,320
yeah so thank you uh so i'm your luck

34
00:01:14,320 --> 00:01:16,560
tag and i'm a junior your friend

35
00:01:16,560 --> 00:01:18,479
researcher at google ai

36
00:01:18,479 --> 00:01:20,400
i started that last

37
00:01:20,400 --> 00:01:22,640
september and

38
00:01:22,640 --> 00:01:24,320
i have a bachelor's degree in computer

39
00:01:24,320 --> 00:01:27,200
science and i'm currently pursuing a

40
00:01:27,200 --> 00:01:29,040
master's in computer science and i.t

41
00:01:29,040 --> 00:01:31,200
security at a local university in

42
00:01:31,200 --> 00:01:34,159
hungary budapest

43
00:01:34,799 --> 00:01:37,680
yeah so a little background about why we

44
00:01:37,680 --> 00:01:39,680
did this research

45
00:01:39,680 --> 00:01:40,799
so we had

46
00:01:40,799 --> 00:01:43,040
the threat intel team at cujo ai i'm

47
00:01:43,040 --> 00:01:45,280
focusing mainly on iot and linux mapper

48
00:01:45,280 --> 00:01:46,720
research

49
00:01:46,720 --> 00:01:49,600
mainly because

50
00:01:49,680 --> 00:01:52,479
unix like operation systems nowadays can

51
00:01:52,479 --> 00:01:54,560
be as promising target as a windows

52
00:01:54,560 --> 00:01:55,600
endpoint

53
00:01:55,600 --> 00:01:58,479
because there are even increasing number

54
00:01:58,479 --> 00:01:59,200
of

55
00:01:59,200 --> 00:02:01,119
servers that use some units like

56
00:02:01,119 --> 00:02:02,880
operation system because it's

57
00:02:02,880 --> 00:02:05,520
reliability and operability

58
00:02:05,520 --> 00:02:08,000
and also there are a lot of iot devices

59
00:02:08,000 --> 00:02:08,800
that

60
00:02:08,800 --> 00:02:12,000
run some unix like operation system

61
00:02:12,000 --> 00:02:14,560
and these especially have

62
00:02:14,560 --> 00:02:16,640
some serious security flows that can be

63
00:02:16,640 --> 00:02:18,480
easily exploited

64
00:02:18,480 --> 00:02:23,360
so csrv is a botnet that targets also

65
00:02:23,360 --> 00:02:25,120
linux and windows

66
00:02:25,120 --> 00:02:26,800
servers

67
00:02:26,800 --> 00:02:27,680
and

68
00:02:27,680 --> 00:02:29,440
it was written in the golang or go

69
00:02:29,440 --> 00:02:30,800
language

70
00:02:30,800 --> 00:02:32,640
and there are an increasing number of

71
00:02:32,640 --> 00:02:35,280
mothers written in this language

72
00:02:35,280 --> 00:02:36,720
mainly because it supports

73
00:02:36,720 --> 00:02:39,040
cross-compiling so you have to maintain

74
00:02:39,040 --> 00:02:41,680
only one code base to get a binary that

75
00:02:41,680 --> 00:02:42,800
runs on

76
00:02:42,800 --> 00:02:45,760
windows mac os or linux

77
00:02:45,760 --> 00:02:48,160
but as we found reverse engineering

78
00:02:48,160 --> 00:02:51,680
binaries can be really challenging

79
00:02:51,680 --> 00:02:53,360
some reasons for this

80
00:02:53,360 --> 00:02:55,280
is that

81
00:02:55,280 --> 00:02:56,959
googling uses

82
00:02:56,959 --> 00:02:59,599
static linking in its

83
00:02:59,599 --> 00:03:01,760
compiling process by default which

84
00:03:01,760 --> 00:03:04,239
results in a huge file size and and a

85
00:03:04,239 --> 00:03:06,480
lot of functions though to go through

86
00:03:06,480 --> 00:03:08,640
when you analyze a good binary

87
00:03:08,640 --> 00:03:11,440
it handles strings in a unique way that

88
00:03:11,440 --> 00:03:14,480
differs from like c language

89
00:03:14,480 --> 00:03:15,280
and

90
00:03:15,280 --> 00:03:17,200
there are the general problem of strip

91
00:03:17,200 --> 00:03:19,920
binaries then there are no debug symbols

92
00:03:19,920 --> 00:03:23,040
to use for reverse engineering

93
00:03:23,040 --> 00:03:25,280
for this research we use gidra

94
00:03:25,280 --> 00:03:27,680
which is due to its early stage in open

95
00:03:27,680 --> 00:03:29,840
source development

96
00:03:29,840 --> 00:03:33,040
only covers part of these problems

97
00:03:33,040 --> 00:03:35,599
so the goal of the research was to

98
00:03:35,599 --> 00:03:37,440
understand

99
00:03:37,440 --> 00:03:40,560
how the csrv botnet evolved over time

100
00:03:40,560 --> 00:03:42,480
and in the process

101
00:03:42,480 --> 00:03:44,319
making reverse engineering go binaries

102
00:03:44,319 --> 00:03:46,400
with github easier

103
00:03:46,400 --> 00:03:48,080
the latter one resulted in several

104
00:03:48,080 --> 00:03:49,120
scripts

105
00:03:49,120 --> 00:03:50,159
that

106
00:03:50,159 --> 00:03:52,400
solve some of the issues

107
00:03:52,400 --> 00:03:56,560
that you can find in this github repo

108
00:03:56,560 --> 00:03:58,239
this is our agenda for today's

109
00:03:58,239 --> 00:04:01,040
presentation that dork already mentioned

110
00:04:01,040 --> 00:04:02,959
uh i will begin by

111
00:04:02,959 --> 00:04:05,120
introducing the csri botnet

112
00:04:05,120 --> 00:04:07,280
and going through its main parts the

113
00:04:07,280 --> 00:04:09,680
downloader script the malicious binary

114
00:04:09,680 --> 00:04:13,040
and the miner itself with the exploits

115
00:04:13,040 --> 00:04:16,320
that the csrv implements to infect other

116
00:04:16,320 --> 00:04:17,358
systems

117
00:04:17,358 --> 00:04:20,000
and also because csrv is also a crypto

118
00:04:20,000 --> 00:04:20,959
miner

119
00:04:20,959 --> 00:04:22,880
we are looking into its mining operation

120
00:04:22,880 --> 00:04:25,199
and its monetization scheme

121
00:04:25,199 --> 00:04:27,360
then dork will talk about how we

122
00:04:27,360 --> 00:04:29,040
analyzed

123
00:04:29,040 --> 00:04:31,919
the cesare botnet and how we solved some

124
00:04:31,919 --> 00:04:35,280
of the issues that i just mentioned

125
00:04:35,280 --> 00:04:37,360
so the caesarea botnet was first

126
00:04:37,360 --> 00:04:40,080
mentioned in december 2020 by multiple

127
00:04:40,080 --> 00:04:43,040
sources first by integer than by other

128
00:04:43,040 --> 00:04:44,800
blocks also

129
00:04:44,800 --> 00:04:46,479
as i mentioned it is a worm and a

130
00:04:46,479 --> 00:04:48,160
cryptocurrency miner

131
00:04:48,160 --> 00:04:49,840
and it stood out due to its use of the

132
00:04:49,840 --> 00:04:51,759
golang language which

133
00:04:51,759 --> 00:04:53,840
is

134
00:04:53,840 --> 00:04:55,520
relatively new

135
00:04:55,520 --> 00:04:56,800
language

136
00:04:56,800 --> 00:04:58,800
the botnet is distributed for both linux

137
00:04:58,800 --> 00:05:01,039
and windows environments but we are only

138
00:05:01,039 --> 00:05:03,199
focusing on the linux ones

139
00:05:03,199 --> 00:05:05,120
and the botnet is still active today as

140
00:05:05,120 --> 00:05:07,199
you can see on the image the

141
00:05:07,199 --> 00:05:08,240
last

142
00:05:08,240 --> 00:05:10,800
binary that we analyzed was submitted to

143
00:05:10,800 --> 00:05:14,880
virustotal on the 19th of april 2022

144
00:05:14,880 --> 00:05:16,000
and

145
00:05:16,000 --> 00:05:18,080
although it's not a relatively new

146
00:05:18,080 --> 00:05:19,919
botnet because

147
00:05:19,919 --> 00:05:22,560
as you can see it was first mentioned in

148
00:05:22,560 --> 00:05:26,160
two years ago now only four antivirus

149
00:05:26,160 --> 00:05:28,320
products can detect it as malicious out

150
00:05:28,320 --> 00:05:31,039
of 60.

151
00:05:32,479 --> 00:05:33,600
first i want to talk about the

152
00:05:33,600 --> 00:05:36,160
downloader script so

153
00:05:36,160 --> 00:05:39,199
it is called ldr.sa for the linux and

154
00:05:39,199 --> 00:05:42,960
ldr that's ps1 for the windows versions

155
00:05:42,960 --> 00:05:45,440
and we divided the

156
00:05:45,440 --> 00:05:47,280
process of the development

157
00:05:47,280 --> 00:05:50,240
of the downloader script to three parts

158
00:05:50,240 --> 00:05:52,880
at the beginning of each part some major

159
00:05:52,880 --> 00:05:55,120
changes was made to the script compared

160
00:05:55,120 --> 00:05:56,960
to the previous version

161
00:05:56,960 --> 00:05:59,840
so the first version included only a

162
00:05:59,840 --> 00:06:02,240
hard-coded c2 server ip address and

163
00:06:02,240 --> 00:06:04,000
c-service version

164
00:06:04,000 --> 00:06:07,039
and only curl and we get unix comments

165
00:06:07,039 --> 00:06:08,960
to download the binary itself a

166
00:06:08,960 --> 00:06:12,800
different fund for 32 and 64-bit systems

167
00:06:12,800 --> 00:06:15,360
then in just a few iterations it quickly

168
00:06:15,360 --> 00:06:17,120
introduced some more advanced features

169
00:06:17,120 --> 00:06:20,240
like killing other minor processes and

170
00:06:20,240 --> 00:06:22,400
docker images too and in general

171
00:06:22,400 --> 00:06:25,039
processes with the high cpu usage

172
00:06:25,039 --> 00:06:27,919
it also removed or disabled some system

173
00:06:27,919 --> 00:06:29,520
security services

174
00:06:29,520 --> 00:06:31,520
and implemented some chrome based

175
00:06:31,520 --> 00:06:33,759
persistence

176
00:06:33,759 --> 00:06:36,080
then in the second start uh at the end

177
00:06:36,080 --> 00:06:38,800
of february 2021 we saw that

178
00:06:38,800 --> 00:06:41,520
uh the script reverted back to a more

179
00:06:41,520 --> 00:06:42,880
simple version

180
00:06:42,880 --> 00:06:45,600
uh to just uh downloading the binary

181
00:06:45,600 --> 00:06:48,479
itself and from there more slow paced

182
00:06:48,479 --> 00:06:51,199
expansion was

183
00:06:51,199 --> 00:06:52,400
begun

184
00:06:52,400 --> 00:06:55,199
which included some pre-introduction of

185
00:06:55,199 --> 00:06:57,039
the lost parts of the script

186
00:06:57,039 --> 00:06:59,280
but the developers also added some new

187
00:06:59,280 --> 00:07:02,720
ones like a randomized icsrv version or

188
00:07:02,720 --> 00:07:04,639
installing chrome if it

189
00:07:04,639 --> 00:07:08,080
is not existing on the system

190
00:07:08,080 --> 00:07:10,400
killing processes listening on specific

191
00:07:10,400 --> 00:07:13,039
ports that the csrv itself wanted to use

192
00:07:13,039 --> 00:07:14,319
later on

193
00:07:14,319 --> 00:07:17,039
and also spreading via ssh with

194
00:07:17,039 --> 00:07:20,080
collected information like host names

195
00:07:20,080 --> 00:07:22,080
and keepers

196
00:07:22,080 --> 00:07:24,560
uh to spread

197
00:07:24,560 --> 00:07:26,240
itself yeah

198
00:07:26,240 --> 00:07:29,039
one interesting part of the second part

199
00:07:29,039 --> 00:07:30,960
was

200
00:07:30,960 --> 00:07:32,960
as i mentioned it killed other mining

201
00:07:32,960 --> 00:07:35,680
processes as well and this included a

202
00:07:35,680 --> 00:07:39,759
process named kfreddi which mimics

203
00:07:39,759 --> 00:07:42,720
legit unix process kenya process name k

204
00:07:42,720 --> 00:07:44,479
thread d

205
00:07:44,479 --> 00:07:46,000
but later

206
00:07:46,000 --> 00:07:48,960
it looked like that it used as its own

207
00:07:48,960 --> 00:07:52,160
cryptominer process because

208
00:07:52,160 --> 00:07:54,000
it the script only downloaded the

209
00:07:54,000 --> 00:07:56,639
current csrv version if

210
00:07:56,639 --> 00:07:59,120
the di process was not found running on

211
00:07:59,120 --> 00:08:00,319
the system

212
00:08:00,319 --> 00:08:02,400
and the script also included a rev

213
00:08:02,400 --> 00:08:03,360
written

214
00:08:03,360 --> 00:08:06,879
top unix command that excluded the

215
00:08:06,879 --> 00:08:09,680
kfredi from its result list

216
00:08:09,680 --> 00:08:11,039
but anyway

217
00:08:11,039 --> 00:08:12,960
later we saw that

218
00:08:12,960 --> 00:08:15,039
the k3di process was renamed by a

219
00:08:15,039 --> 00:08:19,199
similar one called k fred jk

220
00:08:19,840 --> 00:08:22,240
in the beginning of this year

221
00:08:22,240 --> 00:08:25,199
we saw another batch of changes made to

222
00:08:25,199 --> 00:08:27,280
the script

223
00:08:27,280 --> 00:08:29,039
the script itself builds onto the

224
00:08:29,039 --> 00:08:30,400
previous version

225
00:08:30,400 --> 00:08:32,479
but it now includes some low level

226
00:08:32,479 --> 00:08:35,200
custom curl or we get like code

227
00:08:35,200 --> 00:08:37,279
and also it

228
00:08:37,279 --> 00:08:39,360
also downloads a second script that you

229
00:08:39,360 --> 00:08:41,039
can see on the slide

230
00:08:41,039 --> 00:08:43,599
that also helps

231
00:08:43,599 --> 00:08:46,480
in the persistence of the csrv by

232
00:08:46,480 --> 00:08:48,399
in an infinite loop it

233
00:08:48,399 --> 00:08:52,240
kills other mining processes and if the

234
00:08:52,240 --> 00:08:53,760
has processed process clip-to-minor

235
00:08:53,760 --> 00:08:55,200
process is not found running on the

236
00:08:55,200 --> 00:08:57,519
system it downloads the downloader

237
00:08:57,519 --> 00:08:58,800
script

238
00:08:58,800 --> 00:09:01,680
and executes it

239
00:09:01,680 --> 00:09:03,600
now turning our focus on the binaries

240
00:09:03,600 --> 00:09:05,760
itself as i mentioned there are separate

241
00:09:05,760 --> 00:09:08,399
ones for 32 and 64-bit

242
00:09:08,399 --> 00:09:10,480
architectures and we analyzed more than

243
00:09:10,480 --> 00:09:11,920
100

244
00:09:11,920 --> 00:09:13,519
health binaries

245
00:09:13,519 --> 00:09:15,920
a fundamental part of the research was

246
00:09:15,920 --> 00:09:18,640
trying to sort or organize

247
00:09:18,640 --> 00:09:20,959
the different samples into different

248
00:09:20,959 --> 00:09:23,600
groups by specific characteristics for

249
00:09:23,600 --> 00:09:26,480
this we decided to use the binaries

250
00:09:26,480 --> 00:09:29,279
package structures as you can see in go

251
00:09:29,279 --> 00:09:31,279
programs

252
00:09:31,279 --> 00:09:32,959
so go programs are organized into

253
00:09:32,959 --> 00:09:34,880
packages and the package is a collection

254
00:09:34,880 --> 00:09:37,200
of source files in the same directory

255
00:09:37,200 --> 00:09:39,760
that or compile together and functions

256
00:09:39,760 --> 00:09:41,920
types variables and constants defined in

257
00:09:41,920 --> 00:09:44,320
one source phi are visible to all other

258
00:09:44,320 --> 00:09:46,800
source files within the same package

259
00:09:46,800 --> 00:09:48,000
for this

260
00:09:48,000 --> 00:09:51,040
we used a tool called redress

261
00:09:51,040 --> 00:09:53,600
which is a utility for analyzing script

262
00:09:53,600 --> 00:09:55,090
go binaries on the

263
00:09:55,090 --> 00:09:56,560
[Music]

264
00:09:56,560 --> 00:09:58,560
image on the left you can see the

265
00:09:58,560 --> 00:10:01,440
package structure of the

266
00:10:01,440 --> 00:10:04,240
of that most of the samples or c-service

267
00:10:04,240 --> 00:10:07,040
samples used

268
00:10:08,160 --> 00:10:08,880
so

269
00:10:08,880 --> 00:10:10,880
most of the samples was packed by

270
00:10:10,880 --> 00:10:14,800
vanilla upx and we did not see any other

271
00:10:14,800 --> 00:10:18,320
packer used by the mother developers and

272
00:10:18,320 --> 00:10:21,040
the first samples was not using any

273
00:10:21,040 --> 00:10:23,279
obfuscation at all

274
00:10:23,279 --> 00:10:24,800
the first of whose creative sample

275
00:10:24,800 --> 00:10:27,760
appeared at the end of march 2021 and

276
00:10:27,760 --> 00:10:28,640
used

277
00:10:28,640 --> 00:10:32,160
known go utility called gofusgate

278
00:10:32,160 --> 00:10:34,240
first they only obfuscated package names

279
00:10:34,240 --> 00:10:36,160
as you can see on the image in the

280
00:10:36,160 --> 00:10:37,200
middle

281
00:10:37,200 --> 00:10:39,519
and for the later samples some of the

282
00:10:39,519 --> 00:10:42,320
function names whose goal was to try to

283
00:10:42,320 --> 00:10:43,920
execute

284
00:10:43,920 --> 00:10:47,200
the different exploits that the binary

285
00:10:47,200 --> 00:10:51,440
implemented so this was obfuscated

286
00:10:51,440 --> 00:10:54,560
but fortunately as you can see on the

287
00:10:54,560 --> 00:10:57,760
comparison between the

288
00:10:59,040 --> 00:11:01,839
yeah sorry

289
00:11:03,120 --> 00:11:04,560
yeah

290
00:11:04,560 --> 00:11:06,480
so as you can see by the comparison of

291
00:11:06,480 --> 00:11:08,880
the affiliated and the not obfuscated

292
00:11:08,880 --> 00:11:12,399
function names uh this not presented a

293
00:11:12,399 --> 00:11:14,959
difficulty for us because this can be

294
00:11:14,959 --> 00:11:18,479
easily correlated to each other

295
00:11:19,600 --> 00:11:21,680
the csr rebotnet is primarily targeting

296
00:11:21,680 --> 00:11:24,240
linux and windows servers and not iot

297
00:11:24,240 --> 00:11:25,440
devices

298
00:11:25,440 --> 00:11:27,600
the initial campaigns and versions

299
00:11:27,600 --> 00:11:29,760
included only a small set of exploits

300
00:11:29,760 --> 00:11:31,200
but

301
00:11:31,200 --> 00:11:33,600
as time went on it incorporated a lot

302
00:11:33,600 --> 00:11:34,800
more of them

303
00:11:34,800 --> 00:11:36,399
and interestingly

304
00:11:36,399 --> 00:11:38,880
some specific exploits in itself

305
00:11:38,880 --> 00:11:41,120
underwent several development stages

306
00:11:41,120 --> 00:11:42,399
where we saw that

307
00:11:42,399 --> 00:11:44,320
the developers updated some functions

308
00:11:44,320 --> 00:11:46,720
until they reached a satisfying result

309
00:11:46,720 --> 00:11:49,680
or simply got rid of that exploit that's

310
00:11:49,680 --> 00:11:51,920
why as you can see

311
00:11:51,920 --> 00:11:54,079
some of the used exploits were only

312
00:11:54,079 --> 00:11:56,959
present in one or two samples or two

313
00:11:56,959 --> 00:11:58,399
versions and

314
00:11:58,399 --> 00:12:00,320
while others remained in the code base

315
00:12:00,320 --> 00:12:02,320
for a very long time

316
00:12:02,320 --> 00:12:04,399
you can see also some of the latest

317
00:12:04,399 --> 00:12:06,240
exploits

318
00:12:06,240 --> 00:12:08,800
used by the cesari botnet and as you can

319
00:12:08,800 --> 00:12:10,880
see sometimes the

320
00:12:10,880 --> 00:12:14,160
time frame between the publication of

321
00:12:14,160 --> 00:12:16,880
exploit and its usage in csr is only two

322
00:12:16,880 --> 00:12:19,120
months

323
00:12:20,560 --> 00:12:22,720
this is a complete list of the

324
00:12:22,720 --> 00:12:24,320
vulnerabilities exploited by the

325
00:12:24,320 --> 00:12:25,920
ccre.net

326
00:12:25,920 --> 00:12:28,959
in some version of it

327
00:12:28,959 --> 00:12:30,240
as you can see

328
00:12:30,240 --> 00:12:33,839
it attacks a whole variety of services

329
00:12:33,839 --> 00:12:34,880
and

330
00:12:34,880 --> 00:12:36,800
all of the vulnerabilities exploited are

331
00:12:36,800 --> 00:12:38,560
belonging to the commanding junction

332
00:12:38,560 --> 00:12:41,519
category and none of them

333
00:12:41,519 --> 00:12:44,240
exploits memory vulnerability or memory

334
00:12:44,240 --> 00:12:47,360
corruption vulnerability

335
00:12:49,279 --> 00:12:50,839
now onto the miner

336
00:12:50,839 --> 00:12:53,920
itself cesari mines the monero

337
00:12:53,920 --> 00:12:55,519
cryptocurrency

338
00:12:55,519 --> 00:12:57,279
because it's a tempting choice for

339
00:12:57,279 --> 00:13:00,240
mother developers because

340
00:13:00,240 --> 00:13:02,959
its transactions are harder to trace and

341
00:13:02,959 --> 00:13:04,800
it can use the

342
00:13:04,800 --> 00:13:07,839
cp of the or of an ordinary system

343
00:13:07,839 --> 00:13:10,399
it uses the open source xm rig project

344
00:13:10,399 --> 00:13:12,240
to mine monero which can be found on

345
00:13:12,240 --> 00:13:13,360
github

346
00:13:13,360 --> 00:13:15,040
and

347
00:13:15,040 --> 00:13:17,600
but the configuration files of each

348
00:13:17,600 --> 00:13:20,320
version of the csrv botnet slightly

349
00:13:20,320 --> 00:13:22,480
differs from each other

350
00:13:22,480 --> 00:13:25,360
the mining address was the following for

351
00:13:25,360 --> 00:13:27,760
all but one of the samples

352
00:13:27,760 --> 00:13:30,800
and the following mining pools was used

353
00:13:30,800 --> 00:13:33,839
my xmr f2 pool nanopool and later a

354
00:13:33,839 --> 00:13:35,519
specific ip

355
00:13:35,519 --> 00:13:37,600
address and port combination that i will

356
00:13:37,600 --> 00:13:40,639
talk about later on

357
00:13:42,160 --> 00:13:44,560
in this slide you can see how the mining

358
00:13:44,560 --> 00:13:46,800
operation changed over time

359
00:13:46,800 --> 00:13:49,600
so the beginning in december 2020 the

360
00:13:49,600 --> 00:13:52,800
miner was embedded embedded as a jzip

361
00:13:52,800 --> 00:13:54,079
compressed file

362
00:13:54,079 --> 00:13:56,480
uh which once uh with the

363
00:13:56,480 --> 00:13:57,440
it was

364
00:13:57,440 --> 00:14:00,480
embedded with the go bin data package

365
00:14:00,480 --> 00:14:02,399
or library

366
00:14:02,399 --> 00:14:04,800
and once extracted to the temp folder it

367
00:14:04,800 --> 00:14:06,000
was named

368
00:14:06,000 --> 00:14:08,639
uh like network zero one and executed

369
00:14:08,639 --> 00:14:10,000
like that

370
00:14:10,000 --> 00:14:12,560
yeah at the start it only used one

371
00:14:12,560 --> 00:14:15,360
mining pool the mine xmr one

372
00:14:15,360 --> 00:14:17,360
then later on we saw that the miner was

373
00:14:17,360 --> 00:14:19,760
moved into the separate file as and it

374
00:14:19,760 --> 00:14:21,600
was executed by the

375
00:14:21,600 --> 00:14:24,320
downloader script and it also added a

376
00:14:24,320 --> 00:14:25,440
second

377
00:14:25,440 --> 00:14:28,560
mining pool the f2 pool

378
00:14:28,560 --> 00:14:31,040
in february 2021 the miner was once

379
00:14:31,040 --> 00:14:33,839
again embedded as a jzip and it added a

380
00:14:33,839 --> 00:14:36,000
first pool the nanopool

381
00:14:36,000 --> 00:14:39,199
and later on it was embedded and as elf

382
00:14:39,199 --> 00:14:40,480
file

383
00:14:40,480 --> 00:14:42,880
and there was a single sample that used

384
00:14:42,880 --> 00:14:45,440
a different mining address that differed

385
00:14:45,440 --> 00:14:46,639
from the

386
00:14:46,639 --> 00:14:48,720
other one that i just showed you on the

387
00:14:48,720 --> 00:14:49,920
previous slide

388
00:14:49,920 --> 00:14:53,199
and this monero address was tied to

389
00:14:53,199 --> 00:14:54,320
watchdog

390
00:14:54,320 --> 00:14:55,920
campaigns

391
00:14:55,920 --> 00:14:58,560
from july 2021

392
00:14:58,560 --> 00:14:59,839
[Music]

393
00:14:59,839 --> 00:15:02,800
the access to a mining to pool was done

394
00:15:02,800 --> 00:15:04,560
through a proxy

395
00:15:04,560 --> 00:15:06,959
so this is done via the

396
00:15:06,959 --> 00:15:09,680
specific iphs and port combination that

397
00:15:09,680 --> 00:15:11,519
you can see on the slide

398
00:15:11,519 --> 00:15:13,680
i have to mention that this ip address

399
00:15:13,680 --> 00:15:14,870
was used as

400
00:15:14,870 --> 00:15:16,399
[Music]

401
00:15:16,399 --> 00:15:18,240
the mother distribution idea just was

402
00:15:18,240 --> 00:15:20,880
the same yeah

403
00:15:22,720 --> 00:15:24,720
we also looked inside the monetization

404
00:15:24,720 --> 00:15:27,440
scheme to see how lucrative uh how much

405
00:15:27,440 --> 00:15:30,079
lucrative for it was it for the

406
00:15:30,079 --> 00:15:31,839
threat actors

407
00:15:31,839 --> 00:15:34,720
and we simply looked inside the

408
00:15:34,720 --> 00:15:36,560
different pools that

409
00:15:36,560 --> 00:15:38,160
i just

410
00:15:38,160 --> 00:15:42,720
talked about so the f2 pool uh

411
00:15:42,720 --> 00:15:44,560
wallet account style was started in

412
00:15:44,560 --> 00:15:47,199
november 2020 and

413
00:15:47,199 --> 00:15:48,959
on the top image you can see a total

414
00:15:48,959 --> 00:15:51,839
paid amount of xml of 15 which is around

415
00:15:51,839 --> 00:15:54,480
4000 us dollars

416
00:15:54,480 --> 00:15:56,800
but this xml mining pool was closed

417
00:15:56,800 --> 00:15:59,920
venue later in november 2021

418
00:15:59,920 --> 00:16:01,759
and the image

419
00:16:01,759 --> 00:16:04,720
shown is from september 2021

420
00:16:04,720 --> 00:16:07,199
the mining summer account

421
00:16:07,199 --> 00:16:09,680
was suspended uh because of both net

422
00:16:09,680 --> 00:16:10,880
activity

423
00:16:10,880 --> 00:16:14,639
and the nano pool shows a total paid xmr

424
00:16:14,639 --> 00:16:18,800
of 76 which is around 20 000 us dollars

425
00:16:18,800 --> 00:16:20,560
and the first payment was conducted on

426
00:16:20,560 --> 00:16:23,920
the end of february 2021 and the last

427
00:16:23,920 --> 00:16:26,399
the beginning of july from there as i

428
00:16:26,399 --> 00:16:28,880
mentioned

429
00:16:29,360 --> 00:16:31,040
the mining pool was

430
00:16:31,040 --> 00:16:32,639
so the communication to the mining pool

431
00:16:32,639 --> 00:16:34,800
was done through a proxy and we couldn't

432
00:16:34,800 --> 00:16:37,360
follow that and

433
00:16:37,360 --> 00:16:39,040
see any gains from

434
00:16:39,040 --> 00:16:41,680
this part

435
00:16:42,000 --> 00:16:46,160
and now i will turn it over to darker

436
00:16:47,440 --> 00:16:51,120
so as you can see from jury's

437
00:16:51,120 --> 00:16:55,839
part csrv is not as a high scale botnet

438
00:16:55,839 --> 00:16:58,320
that we have heard about today so it

439
00:16:58,320 --> 00:17:01,199
didn't gain that much money we don't

440
00:17:01,199 --> 00:17:02,880
probably most of you never even heard

441
00:17:02,880 --> 00:17:05,439
about it so why are we still talking

442
00:17:05,439 --> 00:17:07,359
about why is it interesting

443
00:17:07,359 --> 00:17:08,240
so

444
00:17:08,240 --> 00:17:10,799
as jury already said for us the primary

445
00:17:10,799 --> 00:17:12,720
reason was that we could use it very

446
00:17:12,720 --> 00:17:14,000
well in our

447
00:17:14,000 --> 00:17:16,559
goal and binary analysis so in the rest

448
00:17:16,559 --> 00:17:20,400
of the time i would like to show you uh

449
00:17:20,400 --> 00:17:23,359
what kind of scripts we created for a go

450
00:17:23,359 --> 00:17:24,959
binary analysis

451
00:17:24,959 --> 00:17:26,240
and

452
00:17:26,240 --> 00:17:28,799
how you could use it in your work if you

453
00:17:28,799 --> 00:17:30,320
need it

454
00:17:30,320 --> 00:17:33,679
we primarily use uh guidra so all the

455
00:17:33,679 --> 00:17:35,280
scripts and everything that i will show

456
00:17:35,280 --> 00:17:36,080
will

457
00:17:36,080 --> 00:17:38,720
uh be shown in ghidra

458
00:17:38,720 --> 00:17:40,400
i don't really want to take much time

459
00:17:40,400 --> 00:17:42,960
about talking about go i

460
00:17:42,960 --> 00:17:45,280
sure that all of you you know

461
00:17:45,280 --> 00:17:46,400
go it's a

462
00:17:46,400 --> 00:17:49,600
current version is 1.18

463
00:17:49,600 --> 00:17:51,919
during our research most of the malware

464
00:17:51,919 --> 00:17:54,400
families that we have analyzed

465
00:17:54,400 --> 00:17:58,160
use older versions and many of the

466
00:17:58,160 --> 00:18:01,200
problems that you will see here are

467
00:18:01,200 --> 00:18:03,840
related to older versions of go and it

468
00:18:03,840 --> 00:18:06,080
changed a little bit during the last few

469
00:18:06,080 --> 00:18:08,720
versions but i will uh talk a little bit

470
00:18:08,720 --> 00:18:11,919
about that as well well uh so

471
00:18:11,919 --> 00:18:13,280
this

472
00:18:13,280 --> 00:18:14,880
programming language is getting more and

473
00:18:14,880 --> 00:18:17,679
more more popular amongst develop

474
00:18:17,679 --> 00:18:20,000
developers but not just the general

475
00:18:20,000 --> 00:18:22,160
developers but also

476
00:18:22,160 --> 00:18:23,760
malware developers

477
00:18:23,760 --> 00:18:26,240
so this is what we observed and this is

478
00:18:26,240 --> 00:18:28,880
how we started to look into the reverse

479
00:18:28,880 --> 00:18:32,080
engineering aspect of golang

480
00:18:32,080 --> 00:18:35,360
it is very simple easy to start to

481
00:18:35,360 --> 00:18:38,000
write programs with using go

482
00:18:38,000 --> 00:18:39,120
and as

483
00:18:39,120 --> 00:18:42,400
we already mentioned one of the best

484
00:18:42,400 --> 00:18:44,320
functionality for malware developers is

485
00:18:44,320 --> 00:18:46,160
the cross compiling functionality so

486
00:18:46,160 --> 00:18:48,480
they don't have to create different uh

487
00:18:48,480 --> 00:18:51,039
code base for each like for linux and

488
00:18:51,039 --> 00:18:53,600
windows but they can just use one and

489
00:18:53,600 --> 00:18:56,559
compile it separately so

490
00:18:56,559 --> 00:18:59,360
let's uh jump into the like the very

491
00:18:59,360 --> 00:19:02,080
basics and then i will show uh some code

492
00:19:02,080 --> 00:19:04,720
from the csrv botnet

493
00:19:04,720 --> 00:19:05,600
uh

494
00:19:05,600 --> 00:19:08,880
so the first pro problem with the go

495
00:19:08,880 --> 00:19:11,200
binaries that they are huge so they are

496
00:19:11,200 --> 00:19:14,400
statically linked uh by default

497
00:19:14,400 --> 00:19:15,200
and

498
00:19:15,200 --> 00:19:17,760
that's why we get a huge

499
00:19:17,760 --> 00:19:20,080
executable images

500
00:19:20,080 --> 00:19:22,720
there are very many drawbacks of it of

501
00:19:22,720 --> 00:19:24,640
course the malware distribution can be

502
00:19:24,640 --> 00:19:26,160
more difficult

503
00:19:26,160 --> 00:19:28,559
and also for us reverse engineering can

504
00:19:28,559 --> 00:19:32,240
be more difficult just for a comparison

505
00:19:32,240 --> 00:19:33,840
these are the uh

506
00:19:33,840 --> 00:19:35,919
simple hello world programs written in c

507
00:19:35,919 --> 00:19:39,039
and go and as you can see in the sea

508
00:19:39,039 --> 00:19:42,160
version it's like 16 kilobytes while in

509
00:19:42,160 --> 00:19:44,559
go it's two megabytes

510
00:19:44,559 --> 00:19:47,840
and uh since uh we are talking about uh

511
00:19:47,840 --> 00:19:51,520
maver usually we are handling strip

512
00:19:51,520 --> 00:19:55,440
binaries which means that

513
00:19:55,440 --> 00:19:59,919
we cannot see nice function names the

514
00:19:59,919 --> 00:20:02,559
these are all

515
00:20:02,559 --> 00:20:05,200
discarded of course the size will be

516
00:20:05,200 --> 00:20:06,480
reduced but

517
00:20:06,480 --> 00:20:09,120
the reverse engineering can be harder

518
00:20:09,120 --> 00:20:11,360
since we don't see nice shiny function

519
00:20:11,360 --> 00:20:13,120
names or only

520
00:20:13,120 --> 00:20:15,120
some general

521
00:20:15,120 --> 00:20:18,000
naming conventions and

522
00:20:18,000 --> 00:20:20,080
if you look at the same example again in

523
00:20:20,080 --> 00:20:21,840
the stripped version of the hello world

524
00:20:21,840 --> 00:20:24,000
we can see that the

525
00:20:24,000 --> 00:20:26,799
binary is still quite large so what does

526
00:20:26,799 --> 00:20:29,760
it mean if we look at real word example

527
00:20:29,760 --> 00:20:31,039
for

528
00:20:31,039 --> 00:20:32,799
the rest of the presentation mainly i

529
00:20:32,799 --> 00:20:36,799
will use one of the latest csrv uh

530
00:20:36,799 --> 00:20:39,520
binaries here is the hash and also so if

531
00:20:39,520 --> 00:20:41,760
anyone is interested or what you want to

532
00:20:41,760 --> 00:20:44,000
dive a little bit deeper into this kind

533
00:20:44,000 --> 00:20:46,080
of reverse engineering then you can just

534
00:20:46,080 --> 00:20:47,840
simply use this file and follow the

535
00:20:47,840 --> 00:20:50,320
steps on the slide

536
00:20:50,320 --> 00:20:52,720
and as jury mentioned these are usually

537
00:20:52,720 --> 00:20:55,440
up expect so this is here the unpacked

538
00:20:55,440 --> 00:20:57,360
version which is as you can see is huge

539
00:20:57,360 --> 00:20:59,280
like 12 megabytes

540
00:20:59,280 --> 00:21:02,559
and this is how uh it looks like when we

541
00:21:02,559 --> 00:21:04,559
look at the functions in

542
00:21:04,559 --> 00:21:07,600
in gidra so there are like almost 9 000

543
00:21:07,600 --> 00:21:09,520
different functions

544
00:21:09,520 --> 00:21:12,559
uh without proper function names so how

545
00:21:12,559 --> 00:21:14,480
how do we start so we would like to find

546
00:21:14,480 --> 00:21:16,000
something interesting we would like to

547
00:21:16,000 --> 00:21:17,760
figure out what this

548
00:21:17,760 --> 00:21:20,159
binary is doing what kind of malware it

549
00:21:20,159 --> 00:21:21,600
is

550
00:21:21,600 --> 00:21:24,080
this is not really a helpful place to

551
00:21:24,080 --> 00:21:25,919
start like to look at the function names

552
00:21:25,919 --> 00:21:27,440
but

553
00:21:27,440 --> 00:21:30,080
luckily with go binaries there is hope

554
00:21:30,080 --> 00:21:32,720
for it so

555
00:21:32,720 --> 00:21:35,679
if for example if we use redress that we

556
00:21:35,679 --> 00:21:38,080
already mentioned before

557
00:21:38,080 --> 00:21:40,640
it will show you all the

558
00:21:40,640 --> 00:21:42,559
different packages that were used in the

559
00:21:42,559 --> 00:21:46,240
same stripped gold binary and also we

560
00:21:46,240 --> 00:21:49,440
can find some function names so

561
00:21:49,440 --> 00:21:51,679
if we for example one

562
00:21:51,679 --> 00:21:54,320
we know that there should be a main dot

563
00:21:54,320 --> 00:21:55,360
main

564
00:21:55,360 --> 00:21:58,080
function then we just simply uh look for

565
00:21:58,080 --> 00:22:00,799
this string within the binary

566
00:22:00,799 --> 00:22:03,760
and once we find the marine dot main

567
00:22:03,760 --> 00:22:06,159
this is our lucky time

568
00:22:06,159 --> 00:22:08,640
even in the stripped version the string

569
00:22:08,640 --> 00:22:10,880
is still there that's a good start so

570
00:22:10,880 --> 00:22:13,360
what can we do now

571
00:22:13,360 --> 00:22:15,120
the first thing is to figure out where

572
00:22:15,120 --> 00:22:17,440
this string is located so we open up the

573
00:22:17,440 --> 00:22:19,120
memory map and we

574
00:22:19,120 --> 00:22:20,960
look at the section names

575
00:22:20,960 --> 00:22:23,679
i hope you can see it but if not then

576
00:22:23,679 --> 00:22:26,159
basically there is a specific section

577
00:22:26,159 --> 00:22:28,480
called go pcl and tab and this is where

578
00:22:28,480 --> 00:22:30,640
we just simply find a string that we

579
00:22:30,640 --> 00:22:33,360
expect to be a function name so this is

580
00:22:33,360 --> 00:22:34,480
a very good

581
00:22:34,480 --> 00:22:36,720
start it is very promising

582
00:22:36,720 --> 00:22:38,640
so what we can do next is try to figure

583
00:22:38,640 --> 00:22:40,880
out what is going on in this gold pcln

584
00:22:40,880 --> 00:22:43,440
tab and there is a very nice clear

585
00:22:43,440 --> 00:22:46,000
documentation about the pcl tab

586
00:22:46,000 --> 00:22:49,200
structure it usually starts with uh

587
00:22:49,200 --> 00:22:52,080
it always starts with a magic value and

588
00:22:52,080 --> 00:22:54,720
then the instruction size quantum

589
00:22:54,720 --> 00:22:57,679
pointer size and then there is uh

590
00:22:57,679 --> 00:22:59,600
there are there is a list of function

591
00:22:59,600 --> 00:23:02,159
addresses followed by function metadata

592
00:23:02,159 --> 00:23:05,600
pointer so it means that there is uh for

593
00:23:05,600 --> 00:23:08,400
each function we can find its address

594
00:23:08,400 --> 00:23:11,039
within the code and then there is a

595
00:23:11,039 --> 00:23:13,919
pointer to the to a so-called metadata

596
00:23:13,919 --> 00:23:16,080
table which i will explain shortly what

597
00:23:16,080 --> 00:23:17,679
it is exactly

598
00:23:17,679 --> 00:23:18,720
so

599
00:23:18,720 --> 00:23:20,159
just a

600
00:23:20,159 --> 00:23:21,679
quick side note

601
00:23:21,679 --> 00:23:23,760
during this presentation we are focusing

602
00:23:23,760 --> 00:23:26,880
on linux binaries uh but it's very very

603
00:23:26,880 --> 00:23:28,880
similar in windows

604
00:23:28,880 --> 00:23:31,919
in windows we won't find pcl and tab

605
00:23:31,919 --> 00:23:34,799
section or go pcl and tab but the

606
00:23:34,799 --> 00:23:36,559
structure since it's very clear it's

607
00:23:36,559 --> 00:23:38,400
well documented we know what to expect

608
00:23:38,400 --> 00:23:39,919
we can just simply look for the magic

609
00:23:39,919 --> 00:23:41,840
value and what other values we would

610
00:23:41,840 --> 00:23:43,760
expect after that

611
00:23:43,760 --> 00:23:46,559
and that's it this is how we can uh find

612
00:23:46,559 --> 00:23:49,440
uh this uh structure

613
00:23:49,440 --> 00:23:53,840
like very easily as in linux so once we

614
00:23:53,840 --> 00:23:57,279
find the function addresses then we will

615
00:23:57,279 --> 00:23:59,520
fi then we can also

616
00:23:59,520 --> 00:24:01,279
follow the pointers and look at the

617
00:24:01,279 --> 00:24:04,000
function metadata tables in these tables

618
00:24:04,000 --> 00:24:06,880
are several useful information regarding

619
00:24:06,880 --> 00:24:08,240
the

620
00:24:08,240 --> 00:24:09,520
the functions

621
00:24:09,520 --> 00:24:11,919
and if we look closely the first entry

622
00:24:11,919 --> 00:24:14,400
is basically again the address of the

623
00:24:14,400 --> 00:24:15,360
function

624
00:24:15,360 --> 00:24:17,360
and the second one is an offset to the

625
00:24:17,360 --> 00:24:20,240
function name so that's that's also very

626
00:24:20,240 --> 00:24:22,480
promising and uh

627
00:24:22,480 --> 00:24:25,200
yes before i move on so this is what we

628
00:24:25,200 --> 00:24:26,559
really need to

629
00:24:26,559 --> 00:24:27,679
to build

630
00:24:27,679 --> 00:24:30,080
back up and have a

631
00:24:30,080 --> 00:24:31,919
better list where we can actually read

632
00:24:31,919 --> 00:24:33,760
the functions and have some id function

633
00:24:33,760 --> 00:24:35,360
names and have some idea what is going

634
00:24:35,360 --> 00:24:38,240
on there so before i move forward i have

635
00:24:38,240 --> 00:24:40,400
to mention that it is changed a little

636
00:24:40,400 --> 00:24:43,120
bit in the latest go versions

637
00:24:43,120 --> 00:24:44,240
so

638
00:24:44,240 --> 00:24:47,600
everything is still there but uh the

639
00:24:47,600 --> 00:24:50,159
uh for example the function name offset

640
00:24:50,159 --> 00:24:53,039
is moved a little bit different place

641
00:24:53,039 --> 00:24:54,240
it's uh

642
00:24:54,240 --> 00:24:56,720
just uh takes a few lines in a script

643
00:24:56,720 --> 00:24:57,840
and then

644
00:24:57,840 --> 00:24:59,919
it can be solved easily but we have to

645
00:24:59,919 --> 00:25:02,320
take into consideration so that's the

646
00:25:02,320 --> 00:25:04,080
thing we do go we have to keep up with

647
00:25:04,080 --> 00:25:07,279
the changes all the time and edges are

648
00:25:07,279 --> 00:25:10,240
scripted to these and but it's a very

649
00:25:10,240 --> 00:25:13,120
easy the documentation for go is is

650
00:25:13,120 --> 00:25:15,679
super clear so we can just follow

651
00:25:15,679 --> 00:25:18,159
find these magic values and based on

652
00:25:18,159 --> 00:25:20,320
that we will know which route to take

653
00:25:20,320 --> 00:25:22,080
how we will find the necessary

654
00:25:22,080 --> 00:25:24,880
information like the function name but i

655
00:25:24,880 --> 00:25:27,279
won't go into the details of this at the

656
00:25:27,279 --> 00:25:28,960
moment so here

657
00:25:28,960 --> 00:25:30,240
is a

658
00:25:30,240 --> 00:25:32,320
an actual example

659
00:25:32,320 --> 00:25:34,880
uh from the same file that i showed

660
00:25:34,880 --> 00:25:36,480
earlier so if someone wants to do some

661
00:25:36,480 --> 00:25:38,720
reverse engineering hands-on actually

662
00:25:38,720 --> 00:25:40,400
sit down and do it you can just follow

663
00:25:40,400 --> 00:25:43,279
these steps so first we need to locate

664
00:25:43,279 --> 00:25:45,360
the pcl and tab structure in linux it's

665
00:25:45,360 --> 00:25:48,080
very easy we just find this section

666
00:25:48,080 --> 00:25:49,679
and then

667
00:25:49,679 --> 00:25:51,919
one by one we can extract the function

668
00:25:51,919 --> 00:25:54,720
addresses and then the function name

669
00:25:54,720 --> 00:25:56,960
find the function name offsets so for

670
00:25:56,960 --> 00:26:01,440
example here uh you can oh i'm so sorry

671
00:26:01,440 --> 00:26:04,480
here you can see the uh

672
00:26:04,480 --> 00:26:05,600
function

673
00:26:05,600 --> 00:26:07,120
address

674
00:26:07,120 --> 00:26:09,120
with the red

675
00:26:09,120 --> 00:26:10,799
par and then

676
00:26:10,799 --> 00:26:13,520
uh underneath is the metadata

677
00:26:13,520 --> 00:26:15,440
table pointer and if you follow that

678
00:26:15,440 --> 00:26:17,600
then there is again the address of a

679
00:26:17,600 --> 00:26:19,440
function so this is

680
00:26:19,440 --> 00:26:21,120
the our function that we are looking at

681
00:26:21,120 --> 00:26:23,600
and then the offset of the function name

682
00:26:23,600 --> 00:26:25,760
and if we just calculate this and follow

683
00:26:25,760 --> 00:26:27,919
we will see that there is main.main so

684
00:26:27,919 --> 00:26:29,120
this is

685
00:26:29,120 --> 00:26:31,120
very easy steps and this is what our

686
00:26:31,120 --> 00:26:33,760
script is doing if we execute the script

687
00:26:33,760 --> 00:26:36,000
then it will find the name of every

688
00:26:36,000 --> 00:26:38,400
single function and just rename it and

689
00:26:38,400 --> 00:26:40,480
now it's if you look at it it looks much

690
00:26:40,480 --> 00:26:42,799
nicer than looking at all these

691
00:26:42,799 --> 00:26:45,600
uh fun functions so on the right side

692
00:26:45,600 --> 00:26:46,880
you can see that

693
00:26:46,880 --> 00:26:49,279
now it's almost 7 000 different

694
00:26:49,279 --> 00:26:51,360
functions are identified so it even

695
00:26:51,360 --> 00:26:52,880
helped in that one

696
00:26:52,880 --> 00:26:55,520
but now we can actually focus on the

697
00:26:55,520 --> 00:26:57,440
interesting ones of course we can get

698
00:26:57,440 --> 00:26:59,440
rid of all the go

699
00:26:59,440 --> 00:27:01,279
stuff that we don't need

700
00:27:01,279 --> 00:27:03,440
and like here main dot main but if you

701
00:27:03,440 --> 00:27:05,200
look a little bit up then there are

702
00:27:05,200 --> 00:27:07,520
these exploit functions and

703
00:27:07,520 --> 00:27:08,799
when you do reverse engineering it's

704
00:27:08,799 --> 00:27:10,960
much easier like you can go through the

705
00:27:10,960 --> 00:27:12,559
function names and just find what is

706
00:27:12,559 --> 00:27:14,559
interesting and start

707
00:27:14,559 --> 00:27:18,640
your research or analysis there

708
00:27:18,640 --> 00:27:21,279
and uh so this is the function part and

709
00:27:21,279 --> 00:27:22,559
now

710
00:27:22,559 --> 00:27:25,440
uh i would like to move on uh to the

711
00:27:25,440 --> 00:27:28,720
part of analyzing strings or recovering

712
00:27:28,720 --> 00:27:31,679
strings within the binary binaries so in

713
00:27:31,679 --> 00:27:34,880
gitra uh there is a so-called defined

714
00:27:34,880 --> 00:27:37,200
strings window where you can

715
00:27:37,200 --> 00:27:39,760
see all the strings that you that gidra

716
00:27:39,760 --> 00:27:42,640
found within the binary so for example

717
00:27:42,640 --> 00:27:45,120
it's also a good start you have no idea

718
00:27:45,120 --> 00:27:46,720
what this mother is doing and you're

719
00:27:46,720 --> 00:27:49,279
just browsing through the strings and

720
00:27:49,279 --> 00:27:51,600
try to find some clue what to do and how

721
00:27:51,600 --> 00:27:53,840
to start it

722
00:27:53,840 --> 00:27:55,679
the problem here is that we have almost

723
00:27:55,679 --> 00:27:58,080
21 000 strings so good luck with

724
00:27:58,080 --> 00:28:00,320
browsing through and find interesting

725
00:28:00,320 --> 00:28:01,679
stuff but

726
00:28:01,679 --> 00:28:04,159
that's the problem of go and the other

727
00:28:04,159 --> 00:28:07,279
problem is that do we does it include

728
00:28:07,279 --> 00:28:10,799
everything that we actually need so as

729
00:28:10,799 --> 00:28:13,039
for example previously you heard from

730
00:28:13,039 --> 00:28:15,760
jury there there is this specific mining

731
00:28:15,760 --> 00:28:18,240
pool urls and the url and if we try to

732
00:28:18,240 --> 00:28:20,080
look for it in the define strings window

733
00:28:20,080 --> 00:28:22,640
we just simply cannot find it okay maybe

734
00:28:22,640 --> 00:28:25,600
that it's not even in the binary but

735
00:28:25,600 --> 00:28:28,159
it is if we look at with like a simple

736
00:28:28,159 --> 00:28:30,240
strings command we can find this

737
00:28:30,240 --> 00:28:32,159
specific string so what's the problem is

738
00:28:32,159 --> 00:28:34,159
here but what the problem is here there

739
00:28:34,159 --> 00:28:35,840
is a string we can which we can just

740
00:28:35,840 --> 00:28:37,520
simply look at looking at the binary

741
00:28:37,520 --> 00:28:39,679
graphing for this we can find but when

742
00:28:39,679 --> 00:28:42,399
we look into gidra we look at the define

743
00:28:42,399 --> 00:28:44,720
strings window we have 20 000 strings

744
00:28:44,720 --> 00:28:47,279
and we still don't find the one that we

745
00:28:47,279 --> 00:28:48,720
are looking for

746
00:28:48,720 --> 00:28:50,559
and the answer is that

747
00:28:50,559 --> 00:28:53,440
go is handling strings or defining

748
00:28:53,440 --> 00:28:56,159
strings in a very different way than c

749
00:28:56,159 --> 00:28:58,880
so in c uh

750
00:28:58,880 --> 00:29:01,039
strings are sequence of characters and

751
00:29:01,039 --> 00:29:02,960
terminated with the null character but

752
00:29:02,960 --> 00:29:05,840
in go it's different there is a specific

753
00:29:05,840 --> 00:29:08,320
structure called a string structure so

754
00:29:08,320 --> 00:29:10,159
there is which consists of two things

755
00:29:10,159 --> 00:29:11,919
first of all there is a pointer which

756
00:29:11,919 --> 00:29:14,320
points to the beginning of the string

757
00:29:14,320 --> 00:29:17,120
and then there is an integer which will

758
00:29:17,120 --> 00:29:19,360
show you the length of the string

759
00:29:19,360 --> 00:29:22,000
and there is no null termination

760
00:29:22,000 --> 00:29:24,320
in fact in many cases these string these

761
00:29:24,320 --> 00:29:26,480
small strings are concatenated

762
00:29:26,480 --> 00:29:28,799
together and just stored as a large

763
00:29:28,799 --> 00:29:32,000
string block be within the binary so

764
00:29:32,000 --> 00:29:35,120
there is no easy way to differentiate

765
00:29:35,120 --> 00:29:37,039
where one string ends and the other one

766
00:29:37,039 --> 00:29:39,120
starts it's not like zero

767
00:29:39,120 --> 00:29:42,000
zero bytes between them so

768
00:29:42,000 --> 00:29:44,480
uh that's why didra also has a hard time

769
00:29:44,480 --> 00:29:47,120
to define these uh string within strings

770
00:29:47,120 --> 00:29:49,279
within google binaries

771
00:29:49,279 --> 00:29:51,760
and what our script is doing here is we

772
00:29:51,760 --> 00:29:53,120
try to find

773
00:29:53,120 --> 00:29:55,600
try to help guidra to find these

774
00:29:55,600 --> 00:29:56,960
structures

775
00:29:56,960 --> 00:29:59,440
these structures can be created in many

776
00:29:59,440 --> 00:30:01,360
different ways they can be allocated

777
00:30:01,360 --> 00:30:03,360
dynamically or statically it is

778
00:30:03,360 --> 00:30:05,360
different for architecture there are

779
00:30:05,360 --> 00:30:07,679
different solutions within architectures

780
00:30:07,679 --> 00:30:08,559
and

781
00:30:08,559 --> 00:30:11,200
as you will see it can change over go

782
00:30:11,200 --> 00:30:13,520
versions as well but

783
00:30:13,520 --> 00:30:16,640
uh there with one with a couple of uh

784
00:30:16,640 --> 00:30:18,880
solutions we managed to

785
00:30:18,880 --> 00:30:21,200
create scripts that recover the strings

786
00:30:21,200 --> 00:30:23,919
that we need in like 98 percent of the

787
00:30:23,919 --> 00:30:25,840
time when we were analyzing different

788
00:30:25,840 --> 00:30:28,559
other families written in goal

789
00:30:28,559 --> 00:30:29,840
so

790
00:30:29,840 --> 00:30:31,600
let's start with the dynamically

791
00:30:31,600 --> 00:30:34,559
allocated string structure

792
00:30:34,559 --> 00:30:37,120
this means that this string structure is

793
00:30:37,120 --> 00:30:40,640
created runtime there are different uh

794
00:30:40,640 --> 00:30:42,720
scenarios based on the architecture now

795
00:30:42,720 --> 00:30:44,880
we are looking into one specific

796
00:30:44,880 --> 00:30:47,440
function of csrv this is the

797
00:30:47,440 --> 00:30:49,760
xml run function of the minor

798
00:30:49,760 --> 00:30:52,640
functionality and if we look a little

799
00:30:52,640 --> 00:30:56,000
bit closer then we will see that before

800
00:30:56,000 --> 00:30:58,399
this call to the string to slice byte

801
00:30:58,399 --> 00:30:59,679
function

802
00:30:59,679 --> 00:31:02,720
then then there is a

803
00:31:02,720 --> 00:31:05,279
an address placed to into the register

804
00:31:05,279 --> 00:31:07,200
then moved on to the stack

805
00:31:07,200 --> 00:31:08,399
and

806
00:31:08,399 --> 00:31:11,200
then there is a number basically the

807
00:31:11,200 --> 00:31:13,600
length moved on to the stack as well and

808
00:31:13,600 --> 00:31:15,679
if we follow the address we will see

809
00:31:15,679 --> 00:31:18,640
that there is some kind of uh string

810
00:31:18,640 --> 00:31:20,720
there so

811
00:31:20,720 --> 00:31:23,120
the idea here is to create these uh

812
00:31:23,120 --> 00:31:25,760
sequence of inter instructions

813
00:31:25,760 --> 00:31:27,440
and uh

814
00:31:27,440 --> 00:31:29,679
just to tell didra just look for these

815
00:31:29,679 --> 00:31:31,840
sequences and if you find this thing

816
00:31:31,840 --> 00:31:34,159
this sequence then you will know which

817
00:31:34,159 --> 00:31:36,320
one very what is the string address and

818
00:31:36,320 --> 00:31:38,880
what is the length of the that specific

819
00:31:38,880 --> 00:31:41,679
string and you can just uh define uh

820
00:31:41,679 --> 00:31:43,840
easily the string that you find there

821
00:31:43,840 --> 00:31:44,720
here

822
00:31:44,720 --> 00:31:48,799
you can see the same example

823
00:31:48,799 --> 00:31:52,000
it's almost the same for 32 and

824
00:31:52,000 --> 00:31:53,760
64

825
00:31:53,760 --> 00:31:54,799
versions

826
00:31:54,799 --> 00:31:56,480
and

827
00:31:56,480 --> 00:31:58,559
this is what happens after we execute

828
00:31:58,559 --> 00:32:00,880
the script and the strings are defined

829
00:32:00,880 --> 00:32:04,000
so first of all in the code now you can

830
00:32:04,000 --> 00:32:06,399
see a string that's just a like

831
00:32:06,399 --> 00:32:08,559
reference to an address but the an

832
00:32:08,559 --> 00:32:10,799
actual string which will help to read

833
00:32:10,799 --> 00:32:12,720
the code in many cases so for example if

834
00:32:12,720 --> 00:32:14,799
it's a ransomware then you will see that

835
00:32:14,799 --> 00:32:16,880
there is the name of the ransom node or

836
00:32:16,880 --> 00:32:18,880
something like that so it's much easier

837
00:32:18,880 --> 00:32:21,679
to actually look at the code and

838
00:32:21,679 --> 00:32:24,480
like simply read it like from a from us

839
00:32:24,480 --> 00:32:26,080
like like a source code or something

840
00:32:26,080 --> 00:32:27,840
almost because there are these strings

841
00:32:27,840 --> 00:32:30,399
that help and also if you full now you

842
00:32:30,399 --> 00:32:32,080
now you know that there is an address

843
00:32:32,080 --> 00:32:33,679
and if you followed you will see that

844
00:32:33,679 --> 00:32:35,200
there is a

845
00:32:35,200 --> 00:32:38,399
huge uh string over there which is um

846
00:32:38,399 --> 00:32:41,600
uh you know it helps in it the part of

847
00:32:41,600 --> 00:32:43,679
the config file of the

848
00:32:43,679 --> 00:32:44,799
miner

849
00:32:44,799 --> 00:32:45,919
and

850
00:32:45,919 --> 00:32:47,760
after this uh

851
00:32:47,760 --> 00:32:50,640
string was created now we can

852
00:32:50,640 --> 00:32:52,399
look at the defined strings window

853
00:32:52,399 --> 00:32:54,000
search for the string that we were

854
00:32:54,000 --> 00:32:57,039
searching before and now it's there so

855
00:32:57,039 --> 00:32:58,399
basically this

856
00:32:58,399 --> 00:33:01,120
url is within the configuration file of

857
00:33:01,120 --> 00:33:03,440
the miner and now that we created this

858
00:33:03,440 --> 00:33:04,880
string it's much

859
00:33:04,880 --> 00:33:06,880
uh easier to

860
00:33:06,880 --> 00:33:09,360
to look uh to look for so and now we

861
00:33:09,360 --> 00:33:11,440
have much more strings that we had

862
00:33:11,440 --> 00:33:13,760
before

863
00:33:13,760 --> 00:33:14,960
and

864
00:33:14,960 --> 00:33:16,880
as i said the problem is with different

865
00:33:16,880 --> 00:33:19,039
instruction sets i didn't want to go

866
00:33:19,039 --> 00:33:21,200
into details about

867
00:33:21,200 --> 00:33:24,480
these today to keep it fairly short but

868
00:33:24,480 --> 00:33:27,679
you can find some documentation about it

869
00:33:27,679 --> 00:33:31,200
on our uh blog and also in our script so

870
00:33:31,200 --> 00:33:33,760
for example how to what instruction

871
00:33:33,760 --> 00:33:36,960
sequence we use for rm or this kind of

872
00:33:36,960 --> 00:33:38,720
thing and it's also a work in progress

873
00:33:38,720 --> 00:33:41,120
so we are adding more and more as we as

874
00:33:41,120 --> 00:33:44,880
we need those uh and uh it's of course

875
00:33:44,880 --> 00:33:47,279
it's something that's very easy to break

876
00:33:47,279 --> 00:33:49,840
so it's sequence that if it's

877
00:33:49,840 --> 00:33:51,519
the other way around or something then

878
00:33:51,519 --> 00:33:55,840
it it can be broken easily but uh but as

879
00:33:55,840 --> 00:33:57,679
i already mentioned in most of the time

880
00:33:57,679 --> 00:33:59,279
in most of the cases it's it's just

881
00:33:59,279 --> 00:34:01,679
simply working and when we find

882
00:34:01,679 --> 00:34:03,840
something that is coming up frequently

883
00:34:03,840 --> 00:34:05,519
and we should take into consideration

884
00:34:05,519 --> 00:34:08,480
it's very easy to just to add it edit to

885
00:34:08,480 --> 00:34:10,480
our script and then next time we will

886
00:34:10,480 --> 00:34:13,760
find uh that as well

887
00:34:13,760 --> 00:34:16,079
uh and

888
00:34:16,079 --> 00:34:18,159
as a last example i would like to go

889
00:34:18,159 --> 00:34:20,800
through the statically allocated string

890
00:34:20,800 --> 00:34:22,320
structure

891
00:34:22,320 --> 00:34:23,199
so

892
00:34:23,199 --> 00:34:24,719
here what we do

893
00:34:24,719 --> 00:34:28,159
is we look for the pointers followed by

894
00:34:28,159 --> 00:34:30,320
the possible string val use so it's

895
00:34:30,320 --> 00:34:32,320
basically a list of

896
00:34:32,320 --> 00:34:34,639
addresses followed by

897
00:34:34,639 --> 00:34:36,560
integers address integer so something

898
00:34:36,560 --> 00:34:37,918
like this and we

899
00:34:37,918 --> 00:34:40,399
it it's easier to

900
00:34:40,399 --> 00:34:42,399
create false positives so we limit the

901
00:34:42,399 --> 00:34:44,320
length string lengths and also only

902
00:34:44,320 --> 00:34:47,280
search for printable characters but if

903
00:34:47,280 --> 00:34:49,520
someone is using these for their own

904
00:34:49,520 --> 00:34:52,320
purposes it's um fairly easy just to

905
00:34:52,320 --> 00:34:53,760
change these

906
00:34:53,760 --> 00:34:55,359
according to your needs because those

907
00:34:55,359 --> 00:34:58,720
three can be much larger or you look for

908
00:34:58,720 --> 00:35:00,640
some specific characters so you can

909
00:35:00,640 --> 00:35:02,560
change the character set as well

910
00:35:02,560 --> 00:35:03,440
and

911
00:35:03,440 --> 00:35:05,440
we only check it in data sections and

912
00:35:05,440 --> 00:35:06,800
luckily it's not

913
00:35:06,800 --> 00:35:08,640
architecture specific

914
00:35:08,640 --> 00:35:11,599
and one fun fact about this one it

915
00:35:11,599 --> 00:35:14,320
actually works with rust samples as well

916
00:35:14,320 --> 00:35:16,400
so that was just something that we

917
00:35:16,400 --> 00:35:17,599
gained with

918
00:35:17,599 --> 00:35:19,839
uh with this script

919
00:35:19,839 --> 00:35:22,800
so in this example the there is one

920
00:35:22,800 --> 00:35:25,359
pointer already defined because it is uh

921
00:35:25,359 --> 00:35:27,839
directly referenced from the code but

922
00:35:27,839 --> 00:35:29,920
after that we see that these look like

923
00:35:29,920 --> 00:35:33,119
as integers followed by addresses but we

924
00:35:33,119 --> 00:35:35,920
don't really know what it is

925
00:35:35,920 --> 00:35:38,320
but if for example we follow these

926
00:35:38,320 --> 00:35:40,320
addresses then we will see that there

927
00:35:40,320 --> 00:35:42,320
are strings that are not defined but

928
00:35:42,320 --> 00:35:44,880
still there is something that is clearly

929
00:35:44,880 --> 00:35:47,040
visible we can human readable so it

930
00:35:47,040 --> 00:35:50,240
would be nice if it would be uh defined

931
00:35:50,240 --> 00:35:52,320
and we could read it and use it in our

932
00:35:52,320 --> 00:35:54,720
research or analysis

933
00:35:54,720 --> 00:35:57,359
so what happens after we execute the

934
00:35:57,359 --> 00:35:58,800
script

935
00:35:58,800 --> 00:35:59,680
uh

936
00:35:59,680 --> 00:36:02,079
all the addresses will be created i'll

937
00:36:02,079 --> 00:36:05,440
aim into all the pointers and these all

938
00:36:05,440 --> 00:36:07,839
these all named very nicely so you can

939
00:36:07,839 --> 00:36:10,960
see that there is some string there like

940
00:36:10,960 --> 00:36:14,160
root root a one two three four five six

941
00:36:14,160 --> 00:36:15,839
and also all the

942
00:36:15,839 --> 00:36:18,480
integers will be created so how long is

943
00:36:18,480 --> 00:36:20,880
the string that we expect to to see

944
00:36:20,880 --> 00:36:21,839
there

945
00:36:21,839 --> 00:36:24,640
and uh so for example and also the

946
00:36:24,640 --> 00:36:26,720
strings will be defined that were not

947
00:36:26,720 --> 00:36:28,320
before

948
00:36:28,320 --> 00:36:30,400
so for here when we look at this for

949
00:36:30,400 --> 00:36:32,800
example like this is one of the exploit

950
00:36:32,800 --> 00:36:34,079
functions

951
00:36:34,079 --> 00:36:36,560
then coming here and instead of only

952
00:36:36,560 --> 00:36:39,040
seeing this like basically nothing we

953
00:36:39,040 --> 00:36:42,320
will see this and it already helps to

954
00:36:42,320 --> 00:36:43,680
figure out that

955
00:36:43,680 --> 00:36:45,760
probably some brute forcing will go on

956
00:36:45,760 --> 00:36:48,320
here like a list of

957
00:36:48,320 --> 00:36:51,520
usernames and passwords

958
00:36:51,520 --> 00:36:54,720
and a few words about what kind of uh

959
00:36:54,720 --> 00:36:56,720
challenges we had with the string

960
00:36:56,720 --> 00:36:58,079
recovery

961
00:36:58,079 --> 00:37:00,640
one of them is when gidra is defining

962
00:37:00,640 --> 00:37:02,400
falsely defining

963
00:37:02,400 --> 00:37:04,640
data types so for in many cases it

964
00:37:04,640 --> 00:37:06,480
happens that we want to create a data

965
00:37:06,480 --> 00:37:09,119
type but something is already there

966
00:37:09,119 --> 00:37:10,800
in most of the cases the problem was

967
00:37:10,800 --> 00:37:12,000
that there is the

968
00:37:12,000 --> 00:37:14,400
so-called undefined data type already

969
00:37:14,400 --> 00:37:17,119
there which is actually a defined data

970
00:37:17,119 --> 00:37:19,920
type so to solve this problem

971
00:37:19,920 --> 00:37:20,800
here

972
00:37:20,800 --> 00:37:22,560
in this example

973
00:37:22,560 --> 00:37:24,400
this is uh from the minor one of the

974
00:37:24,400 --> 00:37:26,000
minor functions

975
00:37:26,000 --> 00:37:28,640
uh where they kill the old version

976
00:37:28,640 --> 00:37:31,760
uh it and if we run simply our script

977
00:37:31,760 --> 00:37:34,320
then it it won't create the strings here

978
00:37:34,320 --> 00:37:36,640
because instead of the integer there is

979
00:37:36,640 --> 00:37:38,800
already something there and the the data

980
00:37:38,800 --> 00:37:41,040
type just simply cannot be created so

981
00:37:41,040 --> 00:37:43,599
what we do here is just remove these

982
00:37:43,599 --> 00:37:46,320
undefined data types when we suspect

983
00:37:46,320 --> 00:37:48,960
that we need something meaningful there

984
00:37:48,960 --> 00:37:51,040
and then

985
00:37:51,040 --> 00:37:53,440
just change it to an integer add the

986
00:37:53,440 --> 00:37:56,400
address here and it will show to the

987
00:37:56,400 --> 00:37:58,480
it will point to the uh

988
00:37:58,480 --> 00:38:00,800
string which will be defined created and

989
00:38:00,800 --> 00:38:03,680
again we can read the code

990
00:38:03,680 --> 00:38:04,400
much

991
00:38:04,400 --> 00:38:06,160
easier

992
00:38:06,160 --> 00:38:09,839
and the last one is when

993
00:38:09,839 --> 00:38:11,280
the

994
00:38:11,280 --> 00:38:13,359
star as i already mentioned it happens

995
00:38:13,359 --> 00:38:14,640
that these smaller strings are

996
00:38:14,640 --> 00:38:18,720
concatenated and the large string blob

997
00:38:18,720 --> 00:38:21,200
is uh stored within the binary this is

998
00:38:21,200 --> 00:38:22,480
how go

999
00:38:22,480 --> 00:38:24,960
handle strings and sometimes if there is

1000
00:38:24,960 --> 00:38:26,480
a

1001
00:38:26,480 --> 00:38:28,320
null byte then

1002
00:38:28,320 --> 00:38:29,760
guidra will

1003
00:38:29,760 --> 00:38:31,119
define this

1004
00:38:31,119 --> 00:38:34,160
lot of smaller strings as one huge

1005
00:38:34,160 --> 00:38:36,720
string so when you want to create

1006
00:38:36,720 --> 00:38:38,240
your the pieces of the strings you won't

1007
00:38:38,240 --> 00:38:40,880
be able because there is already a huge

1008
00:38:40,880 --> 00:38:44,720
string so usually before we run run and

1009
00:38:44,720 --> 00:38:46,480
execute our script

1010
00:38:46,480 --> 00:38:47,680
script

1011
00:38:47,680 --> 00:38:50,640
what we do is looking into the define

1012
00:38:50,640 --> 00:38:54,720
strings window and find those

1013
00:38:54,720 --> 00:38:56,720
strings where the offcut references

1014
00:38:56,720 --> 00:39:00,320
count is high this means that there are

1015
00:39:00,320 --> 00:39:02,880
uh from the code reference different uh

1016
00:39:02,880 --> 00:39:04,640
parts of this string so not the

1017
00:39:04,640 --> 00:39:05,920
beginning but

1018
00:39:05,920 --> 00:39:06,800
other

1019
00:39:06,800 --> 00:39:08,560
uh parts of this huge string which

1020
00:39:08,560 --> 00:39:10,160
probably means that it was falsely

1021
00:39:10,160 --> 00:39:14,000
identified so we simply get rid of this

1022
00:39:14,000 --> 00:39:15,760
string and define

1023
00:39:15,760 --> 00:39:17,040
it and then

1024
00:39:17,040 --> 00:39:19,440
run our scripts so they can be

1025
00:39:19,440 --> 00:39:20,960
uh they can be

1026
00:39:20,960 --> 00:39:22,960
executed properly

1027
00:39:22,960 --> 00:39:24,079
so

1028
00:39:24,079 --> 00:39:29,040
uh before uh i conclude there is uh our

1029
00:39:29,040 --> 00:39:31,040
other work which we didn't include they

1030
00:39:31,040 --> 00:39:33,680
don't want it to be too long where we uh

1031
00:39:33,680 --> 00:39:36,560
work on uh to identify different types

1032
00:39:36,560 --> 00:39:38,000
of uh

1033
00:39:38,000 --> 00:39:40,160
within the go binary so that will be

1034
00:39:40,160 --> 00:39:40,960
much

1035
00:39:40,960 --> 00:39:43,359
easier to read but everything will be

1036
00:39:43,359 --> 00:39:45,440
uploaded to our github and

1037
00:39:45,440 --> 00:39:47,200
most of the scripts are already there

1038
00:39:47,200 --> 00:39:50,000
you can use it freely if you

1039
00:39:50,000 --> 00:39:51,359
happen to

1040
00:39:51,359 --> 00:39:52,880
bump into a go

1041
00:39:52,880 --> 00:39:54,640
binary and you need to

1042
00:39:54,640 --> 00:39:57,839
analyze it uh also there are hundreds of

1043
00:39:57,839 --> 00:39:59,839
other researchers were

1044
00:39:59,839 --> 00:40:00,800
not

1045
00:40:00,800 --> 00:40:03,280
specifically for gydra but other tools

1046
00:40:03,280 --> 00:40:05,680
like ida or other tools

1047
00:40:05,680 --> 00:40:08,160
which are like perfect and excellent we

1048
00:40:08,160 --> 00:40:11,359
were focusing on uh ghidra but if you

1049
00:40:11,359 --> 00:40:14,079
use something else then there are tons

1050
00:40:14,079 --> 00:40:17,280
of possibilities to use those uh and

1051
00:40:17,280 --> 00:40:18,560
also like

1052
00:40:18,560 --> 00:40:20,640
there are some references to

1053
00:40:20,640 --> 00:40:23,040
which we included here like about deep

1054
00:40:23,040 --> 00:40:26,000
botnet and many of those about how to

1055
00:40:26,000 --> 00:40:28,560
analyze uh golang

1056
00:40:28,560 --> 00:40:30,000
binaries

1057
00:40:30,000 --> 00:40:33,200
and uh with this i i would conclude our

1058
00:40:33,200 --> 00:40:34,880
talk for today thank you for your

1059
00:40:34,880 --> 00:40:36,240
attention and

1060
00:40:36,240 --> 00:40:39,280
you can find us here on twitter here is

1061
00:40:39,280 --> 00:40:41,760
our github repository so

1062
00:40:41,760 --> 00:40:43,839
feel free to use our scripts and also we

1063
00:40:43,839 --> 00:40:46,480
will upload all the iocs regarding the

1064
00:40:46,480 --> 00:40:47,839
botnet so

1065
00:40:47,839 --> 00:40:49,839
thank you very much and enjoy the rest

1066
00:40:49,839 --> 00:40:51,310
of the evening

1067
00:40:51,310 --> 00:41:01,119
[Applause]

1068
00:41:01,119 --> 00:41:02,240
okay

1069
00:41:02,240 --> 00:41:06,520
we we have some time for questions

1070
00:41:06,560 --> 00:41:08,800
because the the beers won't be available

1071
00:41:08,800 --> 00:41:12,240
before 6 30 so

1072
00:41:12,240 --> 00:41:14,799
be quiet

1073
00:41:17,920 --> 00:41:21,839
come on guys girls

1074
00:41:22,480 --> 00:41:24,640
i have a question

1075
00:41:24,640 --> 00:41:27,599
uh are you willing to to make a workshop

1076
00:41:27,599 --> 00:41:30,720
for for next year

1077
00:41:30,720 --> 00:41:32,480
because this would fit

1078
00:41:32,480 --> 00:41:35,119
into a workshop like uh spending some

1079
00:41:35,119 --> 00:41:37,599
time with people explaining them for

1080
00:41:37,599 --> 00:41:40,079
three or four hours and go in detail and

1081
00:41:40,079 --> 00:41:40,960
uh

1082
00:41:40,960 --> 00:41:42,880
would be nice yeah yeah we were actually

1083
00:41:42,880 --> 00:41:45,359
considering it to creating

1084
00:41:45,359 --> 00:41:47,280
basically we have everything for it like

1085
00:41:47,280 --> 00:41:48,640
tools and

1086
00:41:48,640 --> 00:41:49,680
all the

1087
00:41:49,680 --> 00:41:51,680
so yes why not that

1088
00:41:51,680 --> 00:41:54,000
would work

1089
00:41:54,630 --> 00:41:58,400
[Applause]

1090
00:41:58,400 --> 00:42:02,200
you have a question yeah

1091
00:42:08,960 --> 00:42:11,520
so uh during your analysis did you have

1092
00:42:11,520 --> 00:42:12,880
any problems

1093
00:42:12,880 --> 00:42:15,599
with functions not getting recognized

1094
00:42:15,599 --> 00:42:16,560
and

1095
00:42:16,560 --> 00:42:20,160
does your tool do anything with that

1096
00:42:20,160 --> 00:42:21,119
uh

1097
00:42:21,119 --> 00:42:23,839
yeah so as i've shown before they're

1098
00:42:23,839 --> 00:42:28,000
like i i go back i think

1099
00:42:28,000 --> 00:42:29,680
so

1100
00:42:29,680 --> 00:42:31,680
here

1101
00:42:31,680 --> 00:42:34,160
just a second where is this yeah so we

1102
00:42:34,160 --> 00:42:37,200
have like 3800 functions recognized and

1103
00:42:37,200 --> 00:42:39,760
when we execute our

1104
00:42:39,760 --> 00:42:42,480
script it will be 6900

1105
00:42:42,480 --> 00:42:45,280
so it's uh something not

1106
00:42:45,280 --> 00:42:48,319
like we deliberately did it but uh since

1107
00:42:48,319 --> 00:42:49,599
we are just

1108
00:42:49,599 --> 00:42:51,680
finding the addresses and the names and

1109
00:42:51,680 --> 00:42:54,319
then we add the command to actually

1110
00:42:54,319 --> 00:42:56,400
create the functions then yes this will

1111
00:42:56,400 --> 00:42:58,800
automatically create all these missing

1112
00:42:58,800 --> 00:43:01,200
functions

1113
00:43:09,760 --> 00:43:12,079
honestly i'm not closely familiar with

1114
00:43:12,079 --> 00:43:13,760
with the goal link internals but i'm

1115
00:43:13,760 --> 00:43:15,200
just curious like if you strip down the

1116
00:43:15,200 --> 00:43:16,240
binary

1117
00:43:16,240 --> 00:43:18,079
why does it leave the function name

1118
00:43:18,079 --> 00:43:19,920
information is that required somehow by

1119
00:43:19,920 --> 00:43:23,440
the runtime or um is that

1120
00:43:23,440 --> 00:43:25,440
something that can be let's say removed

1121
00:43:25,440 --> 00:43:27,680
later by some

1122
00:43:27,680 --> 00:43:29,359
additional uh

1123
00:43:29,359 --> 00:43:32,160
protector or obfuscator to obscure you

1124
00:43:32,160 --> 00:43:34,000
know the analysis even feather

1125
00:43:34,000 --> 00:43:35,599
yeah so that's that's a very good

1126
00:43:35,599 --> 00:43:38,160
question actually i was trying to

1127
00:43:38,160 --> 00:43:41,040
read really hard after it how to like to

1128
00:43:41,040 --> 00:43:42,880
create something without these function

1129
00:43:42,880 --> 00:43:46,160
names or but uh

1130
00:43:46,160 --> 00:43:48,400
i i cannot really answer

1131
00:43:48,400 --> 00:43:50,400
exactly why they need it or keep it the

1132
00:43:50,400 --> 00:43:52,560
only thing i know that there is a like a

1133
00:43:52,560 --> 00:43:54,720
long going discussion of getting rid of

1134
00:43:54,720 --> 00:43:57,359
these but they are still there

1135
00:43:57,359 --> 00:43:58,240
so

1136
00:43:58,240 --> 00:44:01,280
yeah i try to find somewhere very where

1137
00:44:01,280 --> 00:44:03,040
there are no function names but i

1138
00:44:03,040 --> 00:44:04,000
couldn't

1139
00:44:04,000 --> 00:44:05,920
so it's for some reason which i cannot

1140
00:44:05,920 --> 00:44:07,920
really explain explain

1141
00:44:07,920 --> 00:44:10,400
they are there

1142
00:44:15,520 --> 00:44:18,560
i think i can try to elaborate on that

1143
00:44:18,560 --> 00:44:20,160
why they are not probably because

1144
00:44:20,160 --> 00:44:21,680
the stripping tool is using different

1145
00:44:21,680 --> 00:44:23,920
section in elf binaries but the question

1146
00:44:23,920 --> 00:44:25,760
is actually if you remove the strings

1147
00:44:25,760 --> 00:44:28,880
manually the go binary is still running

1148
00:44:28,880 --> 00:44:30,240
so let's say you just you know remove

1149
00:44:30,240 --> 00:44:33,280
the the function name strings like

1150
00:44:33,280 --> 00:44:34,640
by accelerator or something like that

1151
00:44:34,640 --> 00:44:35,920
yeah that's a good question i've never

1152
00:44:35,920 --> 00:44:39,280
tried but i will i will uh also did you

1153
00:44:39,280 --> 00:44:41,520
try to using uh this

1154
00:44:41,520 --> 00:44:44,480
i'm an ida pro guy for life uh but gidra

1155
00:44:44,480 --> 00:44:46,240
has this fancy language in terms of

1156
00:44:46,240 --> 00:44:48,319
intermediate language right did you try

1157
00:44:48,319 --> 00:44:50,640
using it for the pattern matching

1158
00:44:50,640 --> 00:44:53,520
no okay

1159
00:45:01,680 --> 00:45:05,720
other golden questions

1160
00:45:06,800 --> 00:45:09,440
are you sure

1161
00:45:11,359 --> 00:45:14,560
okay i'm i'm go don't leave

1162
00:45:14,560 --> 00:45:16,319
i'm going to make a short presentation

1163
00:45:16,319 --> 00:45:19,290
so first thank you

1164
00:45:19,290 --> 00:45:27,699
[Applause]

