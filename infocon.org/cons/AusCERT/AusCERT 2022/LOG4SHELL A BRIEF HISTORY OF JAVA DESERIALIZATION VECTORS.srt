1
00:00:07,279 --> 00:00:10,639
good afternoon everyone

2
00:00:10,800 --> 00:00:12,559
so today i'd like to introduce david

3
00:00:12,559 --> 00:00:14,799
john david has been in the tech industry

4
00:00:14,799 --> 00:00:16,480
in australia for more than 20 years we

5
00:00:16,480 --> 00:00:18,000
just worked out we'd met

6
00:00:18,000 --> 00:00:19,279
a long time ago we're not going to say

7
00:00:19,279 --> 00:00:20,880
how old we are

8
00:00:20,880 --> 00:00:22,880
uh from government he's worked with

9
00:00:22,880 --> 00:00:24,720
vendors and now he's at a fintech

10
00:00:24,720 --> 00:00:26,800
venture scaler x-15

11
00:00:26,800 --> 00:00:29,039
today he's talking about log for shell

12
00:00:29,039 --> 00:00:31,359
which is the early christmas present a

13
00:00:31,359 --> 00:00:33,520
lot of us last year so

14
00:00:33,520 --> 00:00:36,320
please welcome david

15
00:00:40,480 --> 00:00:43,040
hey everybody mike levels good okay

16
00:00:43,040 --> 00:00:45,280
great i tend to move around the stage a

17
00:00:45,280 --> 00:00:46,800
bit so i hope that's okay for people

18
00:00:46,800 --> 00:00:48,320
viewing at home

19
00:00:48,320 --> 00:00:49,680
just a little intro on me if you don't

20
00:00:49,680 --> 00:00:51,120
know me i'm the head of security for

21
00:00:51,120 --> 00:00:53,920
x-15 ventures x-15 ventures is

22
00:00:53,920 --> 00:00:55,520
the financial technology arm of the

23
00:00:55,520 --> 00:00:57,440
commonwealth bank so the traditional

24
00:00:57,440 --> 00:00:59,680
banking model is under threat by things

25
00:00:59,680 --> 00:01:00,800
like

26
00:01:00,800 --> 00:01:03,520
cryptocurrency uh after pay all this

27
00:01:03,520 --> 00:01:06,560
kind of stuff so in order to compete in

28
00:01:06,560 --> 00:01:08,240
that space they've funded a venture

29
00:01:08,240 --> 00:01:10,320
scaler and we create fintech ventures

30
00:01:10,320 --> 00:01:11,520
that then try and integrate back with

31
00:01:11,520 --> 00:01:14,159
the the bank's customer base and i'm the

32
00:01:14,159 --> 00:01:15,600
head of security for

33
00:01:15,600 --> 00:01:17,119
that arm of the bank previously i've

34
00:01:17,119 --> 00:01:18,479
been a penetration tester and a product

35
00:01:18,479 --> 00:01:20,640
security engineer and previously to that

36
00:01:20,640 --> 00:01:22,080
i was a software developer and previous

37
00:01:22,080 --> 00:01:24,320
to that i was an aviation meteorologist

38
00:01:24,320 --> 00:01:25,920
my claim to fame i think i've been

39
00:01:25,920 --> 00:01:27,360
saying this for 10 years now but it's

40
00:01:27,360 --> 00:01:29,280
still true is any time you go on a plane

41
00:01:29,280 --> 00:01:30,960
in australia and the captain comes on

42
00:01:30,960 --> 00:01:32,240
tells you what the weather is when the

43
00:01:32,240 --> 00:01:34,640
plane's about to land i coded the system

44
00:01:34,640 --> 00:01:37,119
that um that transmits that information

45
00:01:37,119 --> 00:01:39,680
into planes and it's coded entirely in

46
00:01:39,680 --> 00:01:41,600
oracle pl sql it's probably some of the

47
00:01:41,600 --> 00:01:43,920
worst production code ever but it's it's

48
00:01:43,920 --> 00:01:45,840
still there i also teach cyber security

49
00:01:45,840 --> 00:01:47,360
at unsw i'm currently teaching a

50
00:01:47,360 --> 00:01:49,360
master's level course online and i've

51
00:01:49,360 --> 00:01:51,920
been speaking also for a long time um

52
00:01:51,920 --> 00:01:53,600
this little photo here is my favorite

53
00:01:53,600 --> 00:01:56,560
ulcer presentation which was in 2014 i

54
00:01:56,560 --> 00:01:58,640
think when i was doing the stuff on the

55
00:01:58,640 --> 00:02:00,799
north korean um

56
00:02:00,799 --> 00:02:03,200
missile tests and then afterwards some

57
00:02:03,200 --> 00:02:04,880
asia dudes hit me up out the back and

58
00:02:04,880 --> 00:02:07,840
they were like don't go to north korea

59
00:02:07,840 --> 00:02:09,520
that was fun this is not nearly as

60
00:02:09,520 --> 00:02:11,360
interesting but

61
00:02:11,360 --> 00:02:13,520
it's an interesting story and it's a

62
00:02:13,520 --> 00:02:16,319
story about java deserialization rce and

63
00:02:16,319 --> 00:02:18,080
a story about how

64
00:02:18,080 --> 00:02:18,879
the

65
00:02:18,879 --> 00:02:20,800
log for shell vulnerability came about

66
00:02:20,800 --> 00:02:22,720
and the whole history of that

67
00:02:22,720 --> 00:02:24,640
so the countries that are highlighted on

68
00:02:24,640 --> 00:02:26,000
this map

69
00:02:26,000 --> 00:02:27,200
no it's not countries that use the

70
00:02:27,200 --> 00:02:28,800
metric system or something that's just

71
00:02:28,800 --> 00:02:30,239
don't use the metric system that's just

72
00:02:30,239 --> 00:02:32,319
liberia in america

73
00:02:32,319 --> 00:02:34,400
it's countries that have people involved

74
00:02:34,400 --> 00:02:36,000
in this story so it's been a really

75
00:02:36,000 --> 00:02:38,160
interesting story and we'll go through

76
00:02:38,160 --> 00:02:39,920
it chronologically

77
00:02:39,920 --> 00:02:42,319
and it begins here in australia in

78
00:02:42,319 --> 00:02:43,280
brisbane

79
00:02:43,280 --> 00:02:44,879
at the red hat office where me and my

80
00:02:44,879 --> 00:02:46,080
colleague arun were sitting there at

81
00:02:46,080 --> 00:02:48,000
about six o'clock one night i think it

82
00:02:48,000 --> 00:02:49,440
was a friday night i can't remember i

83
00:02:49,440 --> 00:02:50,480
think it was

84
00:02:50,480 --> 00:02:52,959
and we got this email that was entirely

85
00:02:52,959 --> 00:02:54,959
in japanese like the subject line the

86
00:02:54,959 --> 00:02:57,840
entire email body is in japanese

87
00:02:57,840 --> 00:02:59,519
but it's got all these strings in it

88
00:02:59,519 --> 00:03:00,440
like

89
00:03:00,440 --> 00:03:02,519
exploit.class and java you know

90
00:03:02,519 --> 00:03:04,480
payload.java and stuff and we're like

91
00:03:04,480 --> 00:03:06,959
huh okay what's this we ran it through

92
00:03:06,959 --> 00:03:08,879
google translate and it didn't really

93
00:03:08,879 --> 00:03:10,159
give us anything meaningful we could

94
00:03:10,159 --> 00:03:12,319
figure out it was a vulnerability report

95
00:03:12,319 --> 00:03:14,319
but anything that technical google

96
00:03:14,319 --> 00:03:16,640
translates a little bit useless

97
00:03:16,640 --> 00:03:18,800
so fortunately for us

98
00:03:18,800 --> 00:03:21,519
uh at the time red hat's asia pacific

99
00:03:21,519 --> 00:03:23,599
headquarters was in brisbane and we had

100
00:03:23,599 --> 00:03:25,519
the localization team that would do the

101
00:03:25,519 --> 00:03:26,959
translation of all like the colonel

102
00:03:26,959 --> 00:03:29,840
docks and stuff from english into asian

103
00:03:29,840 --> 00:03:32,480
languages including japanese so we went

104
00:03:32,480 --> 00:03:34,879
to the head japanese translator gave her

105
00:03:34,879 --> 00:03:37,840
this email and she perfectly translated

106
00:03:37,840 --> 00:03:39,519
it into english for us

107
00:03:39,519 --> 00:03:42,560
and it was the report of the first ever

108
00:03:42,560 --> 00:03:46,560
java deserialization rc vulnerability

109
00:03:46,560 --> 00:03:50,400
and that vulnerability was cve 2013-2165

110
00:03:50,400 --> 00:03:52,159
in jboss rich faces now we got the

111
00:03:52,159 --> 00:03:54,720
report because jboss was an open source

112
00:03:54,720 --> 00:03:57,200
project that was auspiced by red hat so

113
00:03:57,200 --> 00:03:59,040
somewhere on the jboss.org page it said

114
00:03:59,040 --> 00:04:00,959
report security issues to secureload at

115
00:04:00,959 --> 00:04:03,599
redhat.com and therefore we got it

116
00:04:03,599 --> 00:04:05,680
the guy who reported it so the second

117
00:04:05,680 --> 00:04:08,959
country on that map japan takeshi tarata

118
00:04:08,959 --> 00:04:10,480
i just want to take a second to point

119
00:04:10,480 --> 00:04:12,879
him out nobody's heard of takeshi tarata

120
00:04:12,879 --> 00:04:14,400
he's never spoken at a conference he

121
00:04:14,400 --> 00:04:16,238
doesn't publish anything in english he

122
00:04:16,238 --> 00:04:17,519
doesn't write white papers and he

123
00:04:17,519 --> 00:04:19,759
doesn't really have cves but if you go

124
00:04:19,759 --> 00:04:22,000
on to the jvn which is the japanese

125
00:04:22,000 --> 00:04:23,440
equivalent of

126
00:04:23,440 --> 00:04:25,759
the nvd of the cve database because they

127
00:04:25,759 --> 00:04:28,320
have a kind of closed tech ecosystem

128
00:04:28,320 --> 00:04:31,520
both in japan and china so in japan they

129
00:04:31,520 --> 00:04:34,000
have the jvn in china they have the cnvd

130
00:04:34,000 --> 00:04:36,080
their own equivalent of the cve or nvd

131
00:04:36,080 --> 00:04:38,720
database if you go on to the jvn he's

132
00:04:38,720 --> 00:04:40,080
all over it

133
00:04:40,080 --> 00:04:41,840
amazing security research that nobody's

134
00:04:41,840 --> 00:04:43,040
heard of

135
00:04:43,040 --> 00:04:45,199
and he found this whole vulnerability

136
00:04:45,199 --> 00:04:46,320
this is the most amazing thing this

137
00:04:46,320 --> 00:04:48,479
whole vulnerability that unpacked an

138
00:04:48,479 --> 00:04:51,360
entire class of vulnerabilities he found

139
00:04:51,360 --> 00:04:53,600
us doing a client pen test that happened

140
00:04:53,600 --> 00:04:55,360
to be against the target running jboss

141
00:04:55,360 --> 00:04:56,479
ridge faces

142
00:04:56,479 --> 00:04:57,680
far out

143
00:04:57,680 --> 00:04:59,680
so a flaw was found in the way that rich

144
00:04:59,680 --> 00:05:02,400
faces handled deserialization now

145
00:05:02,400 --> 00:05:06,000
rich faces is an mvc

146
00:05:06,000 --> 00:05:06,960
web

147
00:05:06,960 --> 00:05:09,520
platform and it maintains state with the

148
00:05:09,520 --> 00:05:11,840
client using a serialized string similar

149
00:05:11,840 --> 00:05:13,919
to like asp.net uses asp.net session

150
00:05:13,919 --> 00:05:14,960
state

151
00:05:14,960 --> 00:05:17,840
um it used this serialized string that

152
00:05:17,840 --> 00:05:19,840
would be passed in sorry view state they

153
00:05:19,840 --> 00:05:22,320
call it asp.net view state

154
00:05:22,320 --> 00:05:23,840
they use this view state string that we

155
00:05:23,840 --> 00:05:25,199
pass between the client and the server

156
00:05:25,199 --> 00:05:27,520
to maintain session state and it turns

157
00:05:27,520 --> 00:05:29,440
out that that string

158
00:05:29,440 --> 00:05:32,479
was a serialized java object a native

159
00:05:32,479 --> 00:05:34,639
serialized java object

160
00:05:34,639 --> 00:05:36,880
so that was the root cause of the

161
00:05:36,880 --> 00:05:39,680
vulnerability now

162
00:05:39,680 --> 00:05:42,400
why does that allow you to get rce

163
00:05:42,400 --> 00:05:44,479
so any classes that implement

164
00:05:44,479 --> 00:05:46,639
java.io.serializable

165
00:05:46,639 --> 00:05:49,680
can be serialized automatically by java

166
00:05:49,680 --> 00:05:52,160
it's got its own native binary format

167
00:05:52,160 --> 00:05:53,680
that it will serialize the data into

168
00:05:53,680 --> 00:05:55,840
it's not xml it's not json or yaml it's

169
00:05:55,840 --> 00:05:56,880
this native

170
00:05:56,880 --> 00:05:58,800
binary format

171
00:05:58,800 --> 00:06:00,400
and all they have to do is implement

172
00:06:00,400 --> 00:06:02,319
serializable so if you've got a simple

173
00:06:02,319 --> 00:06:04,080
class that just has some methods and

174
00:06:04,080 --> 00:06:06,880
attributes you just implement java diode

175
00:06:06,880 --> 00:06:08,960
at serializable boom nothing nothing

176
00:06:08,960 --> 00:06:11,600
else to do if however you wish to

177
00:06:11,600 --> 00:06:13,680
implement some custom logic that will

178
00:06:13,680 --> 00:06:15,840
occur upon deserialization of this

179
00:06:15,840 --> 00:06:17,759
object there are two methods that are

180
00:06:17,759 --> 00:06:19,680
provided to you by that serializable

181
00:06:19,680 --> 00:06:20,639
interface

182
00:06:20,639 --> 00:06:22,160
one called read object and one called

183
00:06:22,160 --> 00:06:24,080
read resolve if i remember correctly

184
00:06:24,080 --> 00:06:26,479
read resolve executes first oh sorry

185
00:06:26,479 --> 00:06:28,160
read resolve executes later according to

186
00:06:28,160 --> 00:06:30,880
my slide um read object is executed

187
00:06:30,880 --> 00:06:31,759
first

188
00:06:31,759 --> 00:06:33,199
read object is the one that's nearly

189
00:06:33,199 --> 00:06:35,039
always used read resolve seems to be

190
00:06:35,039 --> 00:06:37,919
some quite obscure use case

191
00:06:37,919 --> 00:06:39,600
but you can implement things in there

192
00:06:39,600 --> 00:06:40,639
like say

193
00:06:40,639 --> 00:06:42,639
you're deserializing something that

194
00:06:42,639 --> 00:06:44,960
represents a file on disk and you

195
00:06:44,960 --> 00:06:46,800
actually want to then put the data of

196
00:06:46,800 --> 00:06:48,960
the file on disk during deserialization

197
00:06:48,960 --> 00:06:50,160
you would implement that in the read

198
00:06:50,160 --> 00:06:51,840
object method

199
00:06:51,840 --> 00:06:53,440
and it's also notable that when you

200
00:06:53,440 --> 00:06:55,919
serialize objects all of the access

201
00:06:55,919 --> 00:06:57,520
modifiers don't matter so private

202
00:06:57,520 --> 00:06:59,199
protected member variables you can set

203
00:06:59,199 --> 00:07:01,520
whatever you want when you serialize an

204
00:07:01,520 --> 00:07:03,599
object

205
00:07:03,599 --> 00:07:05,520
so that was part one was you had jboss

206
00:07:05,520 --> 00:07:08,240
rich faces would maintain its view state

207
00:07:08,240 --> 00:07:10,560
using a serialized object part two was

208
00:07:10,560 --> 00:07:12,880
the fact that these serialized objects

209
00:07:12,880 --> 00:07:14,639
have a read object method that can

210
00:07:14,639 --> 00:07:16,400
contain custom code

211
00:07:16,400 --> 00:07:18,880
part three was that apache commons file

212
00:07:18,880 --> 00:07:21,280
upload which is a it is what it says on

213
00:07:21,280 --> 00:07:23,199
the label it's a library that allows you

214
00:07:23,199 --> 00:07:25,840
to do file uploads in web apps

215
00:07:25,840 --> 00:07:28,479
has a class called disk file item in it

216
00:07:28,479 --> 00:07:31,520
that is a disk file item that represents

217
00:07:31,520 --> 00:07:33,360
a file that you're uploading and when

218
00:07:33,360 --> 00:07:36,240
you deserialize it it writes that file

219
00:07:36,240 --> 00:07:38,400
to the temp directory on disk does all

220
00:07:38,400 --> 00:07:40,479
that for you automatically

221
00:07:40,479 --> 00:07:42,960
and it does that securely by correctly

222
00:07:42,960 --> 00:07:44,560
setting up a temporary directory and a

223
00:07:44,560 --> 00:07:46,639
temporary file name and putting the file

224
00:07:46,639 --> 00:07:48,080
there so that you can't just write to an

225
00:07:48,080 --> 00:07:50,000
arbitrary location

226
00:07:50,000 --> 00:07:52,800
however the fourth part of this is

227
00:07:52,800 --> 00:07:55,199
that the actual underlying

228
00:07:55,199 --> 00:07:58,240
jre java on-time environment code that

229
00:07:58,240 --> 00:08:01,280
writes that file to disk calls native c

230
00:08:01,280 --> 00:08:04,160
code and that native c code had a poison

231
00:08:04,160 --> 00:08:05,840
null byte floor in it

232
00:08:05,840 --> 00:08:06,639
so

233
00:08:06,639 --> 00:08:09,919
in c code a string in memory is just

234
00:08:09,919 --> 00:08:11,520
represented as a chunk of arbitrary

235
00:08:11,520 --> 00:08:13,919
memory that's terminated with a null by

236
00:08:13,919 --> 00:08:15,199
and that's how you know the string is

237
00:08:15,199 --> 00:08:16,240
ended

238
00:08:16,240 --> 00:08:18,400
so if you can inject a null byte

239
00:08:18,400 --> 00:08:20,080
somewhere into a string

240
00:08:20,080 --> 00:08:21,520
in the middle of the string then when

241
00:08:21,520 --> 00:08:22,879
that's being read in memory it will be

242
00:08:22,879 --> 00:08:25,120
interpreted as the end of the string and

243
00:08:25,120 --> 00:08:27,919
you can then truncate the file name

244
00:08:27,919 --> 00:08:29,280
so that's a very old-school

245
00:08:29,280 --> 00:08:31,599
vulnerability from like the late 90s

246
00:08:31,599 --> 00:08:33,039
so once

247
00:08:33,039 --> 00:08:35,360
by combining all of these things you

248
00:08:35,360 --> 00:08:39,519
could create a view state in rich faces

249
00:08:39,519 --> 00:08:41,519
that has a serialized object that is a

250
00:08:41,519 --> 00:08:44,880
disk file item that dis file item has a

251
00:08:44,880 --> 00:08:47,519
file name and that file name has a

252
00:08:47,519 --> 00:08:49,920
poison null byte attached to it so that

253
00:08:49,920 --> 00:08:52,240
when it attempts to concatenate that

254
00:08:52,240 --> 00:08:53,200
string

255
00:08:53,200 --> 00:08:54,880
with the temporary path that it's going

256
00:08:54,880 --> 00:08:57,120
to write to it interprets the end of the

257
00:08:57,120 --> 00:08:58,480
string and therefore the string that you

258
00:08:58,480 --> 00:09:00,160
have written as the file name is the

259
00:09:00,160 --> 00:09:02,160
absolute file path of that and that's

260
00:09:02,160 --> 00:09:03,920
where it will be written on disk

261
00:09:03,920 --> 00:09:05,760
so now you create a serialized instance

262
00:09:05,760 --> 00:09:08,399
of like shell.jsp you control the path

263
00:09:08,399 --> 00:09:10,160
to which it's written and now you've got

264
00:09:10,160 --> 00:09:11,760
remote code execution

265
00:09:11,760 --> 00:09:13,279
and he found all of this doing a client

266
00:09:13,279 --> 00:09:16,080
pen test it's like

267
00:09:16,560 --> 00:09:18,320
so that's how

268
00:09:18,320 --> 00:09:20,839
this whole thing started in

269
00:09:20,839 --> 00:09:25,040
2013. around 2015 the next country

270
00:09:25,040 --> 00:09:27,120
on that map was the united states chris

271
00:09:27,120 --> 00:09:28,560
frohoff

272
00:09:28,560 --> 00:09:30,240
picked this work up

273
00:09:30,240 --> 00:09:32,399
and started to realize that this was a

274
00:09:32,399 --> 00:09:34,320
more extensive issue because we'll get

275
00:09:34,320 --> 00:09:36,480
to the mitigations in a minute but

276
00:09:36,480 --> 00:09:38,560
um that all got patched

277
00:09:38,560 --> 00:09:40,880
but what he started to realize was that

278
00:09:40,880 --> 00:09:42,959
it wasn't just the case of

279
00:09:42,959 --> 00:09:44,560
disc file item where there was this

280
00:09:44,560 --> 00:09:46,399
combination of the fact it was directly

281
00:09:46,399 --> 00:09:48,080
representing a file on disk and a poison

282
00:09:48,080 --> 00:09:50,480
null byte floor in the jre which all got

283
00:09:50,480 --> 00:09:51,760
patched

284
00:09:51,760 --> 00:09:54,240
but this whole design pattern was

285
00:09:54,240 --> 00:09:56,240
fundamentally insecure

286
00:09:56,240 --> 00:09:58,720
and it looks sort of like rot

287
00:09:58,720 --> 00:09:59,600
that

288
00:09:59,600 --> 00:10:01,440
what you need to do is serialize an

289
00:10:01,440 --> 00:10:04,240
object graph and that object graph has a

290
00:10:04,240 --> 00:10:05,200
source

291
00:10:05,200 --> 00:10:07,519
that is some sort of serializable object

292
00:10:07,519 --> 00:10:09,839
that has a custom read object method in

293
00:10:09,839 --> 00:10:10,560
it

294
00:10:10,560 --> 00:10:12,399
and then you need to create in that

295
00:10:12,399 --> 00:10:15,040
object graph a series of other objects

296
00:10:15,040 --> 00:10:17,040
that will call into other methods of

297
00:10:17,040 --> 00:10:19,279
other objects that read object method

298
00:10:19,279 --> 00:10:21,360
we'll call method x of class y we'll

299
00:10:21,360 --> 00:10:23,200
call method z of class b

300
00:10:23,200 --> 00:10:24,959
and if you finally can then in that

301
00:10:24,959 --> 00:10:28,079
object graph land into a sync method

302
00:10:28,079 --> 00:10:30,160
that will allow you to control

303
00:10:30,160 --> 00:10:32,560
a call to code exec then you will get

304
00:10:32,560 --> 00:10:33,680
code exec

305
00:10:33,680 --> 00:10:34,720
and this

306
00:10:34,720 --> 00:10:37,279
sort of style of thing was was coined as

307
00:10:37,279 --> 00:10:39,120
property oriented programming rather

308
00:10:39,120 --> 00:10:40,399
than return oriented programming for

309
00:10:40,399 --> 00:10:42,240
prop rop it's property oriented

310
00:10:42,240 --> 00:10:43,760
programming and you could create what

311
00:10:43,760 --> 00:10:46,399
they call gadgets of these serialized

312
00:10:46,399 --> 00:10:49,120
class instances or object graphs that

313
00:10:49,120 --> 00:10:51,519
would land you in rce

314
00:10:51,519 --> 00:10:53,519
this was originally identified as an

315
00:10:53,519 --> 00:10:55,360
exploitable pattern in php by stefan

316
00:10:55,360 --> 00:10:56,959
essa several years earlier and then

317
00:10:56,959 --> 00:10:58,880
chris rohoff picked it up and turned it

318
00:10:58,880 --> 00:11:00,959
into java he created this project with

319
00:11:00,959 --> 00:11:02,399
some of you may have heard of called yso

320
00:11:02,399 --> 00:11:04,640
serial where he's enumerated all of the

321
00:11:04,640 --> 00:11:08,399
known instances of these gadget classes

322
00:11:08,399 --> 00:11:10,399
and then created a tool that allows you

323
00:11:10,399 --> 00:11:13,279
to easily instantiate payloads against

324
00:11:13,279 --> 00:11:15,920
them so if you have any of these

325
00:11:15,920 --> 00:11:17,680
vulnerable classes

326
00:11:17,680 --> 00:11:20,079
on the class path on the server side

327
00:11:20,079 --> 00:11:21,600
then you can

328
00:11:21,600 --> 00:11:23,279
create a payload that will do it now

329
00:11:23,279 --> 00:11:25,279
this is an important point to know

330
00:11:25,279 --> 00:11:27,440
this all relies on what's on the class

331
00:11:27,440 --> 00:11:29,279
path on the server side when you're

332
00:11:29,279 --> 00:11:30,880
providing these serialized objects

333
00:11:30,880 --> 00:11:32,720
you're not defining the structure of the

334
00:11:32,720 --> 00:11:35,279
object and then giving it to the server

335
00:11:35,279 --> 00:11:37,760
you're defining an instance of an object

336
00:11:37,760 --> 00:11:39,760
type that the server should already know

337
00:11:39,760 --> 00:11:42,079
about because it's on its class path in

338
00:11:42,079 --> 00:11:43,120
memory

339
00:11:43,120 --> 00:11:44,880
so it relies on there being an

340
00:11:44,880 --> 00:11:47,040
exploitable gadget chain that is on the

341
00:11:47,040 --> 00:11:50,959
class path of the target application

342
00:11:50,959 --> 00:11:52,880
but if you look at some of these things

343
00:11:52,880 --> 00:11:55,120
like commons collection extremely widely

344
00:11:55,120 --> 00:11:58,880
used spring extremely widely used

345
00:11:58,880 --> 00:12:00,720
file upload extremely widely used so

346
00:12:00,720 --> 00:12:02,320
many many applications will have these

347
00:12:02,320 --> 00:12:04,560
gadgets on the class path and therefore

348
00:12:04,560 --> 00:12:06,560
if they are deserializing untrusted user

349
00:12:06,560 --> 00:12:09,200
supplied input you will get remote code

350
00:12:09,200 --> 00:12:11,279
execution

351
00:12:11,279 --> 00:12:14,959
so that was the state of play circa 2015

352
00:12:14,959 --> 00:12:16,240
and

353
00:12:16,240 --> 00:12:17,600
it was the conclusion of the community

354
00:12:17,600 --> 00:12:18,959
that anyone who's deserializing

355
00:12:18,959 --> 00:12:21,360
untrusted user supplied input in java is

356
00:12:21,360 --> 00:12:22,880
vulnerable to rce because there's an

357
00:12:22,880 --> 00:12:24,959
unknown number of gadget chains we've

358
00:12:24,959 --> 00:12:26,959
already enumerated a couple of dozen of

359
00:12:26,959 --> 00:12:29,279
them there could be infinitely many more

360
00:12:29,279 --> 00:12:30,800
so just don't deserialize untrusted

361
00:12:30,800 --> 00:12:32,639
user-supplied data

362
00:12:32,639 --> 00:12:34,800
my view back in 2014 was somewhat

363
00:12:34,800 --> 00:12:36,480
different when we originally patched

364
00:12:36,480 --> 00:12:38,800
this issue my and this this is an

365
00:12:38,800 --> 00:12:40,720
excerpt from a blog post i wrote on the

366
00:12:40,720 --> 00:12:42,720
red hat security blog was that the

367
00:12:42,720 --> 00:12:44,399
vulnerability yes existed in the

368
00:12:44,399 --> 00:12:46,800
deserialization of untrusted data but it

369
00:12:46,800 --> 00:12:50,000
also existed in disk file item in this

370
00:12:50,000 --> 00:12:52,959
class that exposed this

371
00:12:52,959 --> 00:12:54,720
vulnerable use case and that every

372
00:12:54,720 --> 00:12:57,200
gadget chain was actually an instance of

373
00:12:57,200 --> 00:12:58,720
a vulnerability not just the

374
00:12:58,720 --> 00:13:00,880
deserializing class and we should patch

375
00:13:00,880 --> 00:13:02,320
both

376
00:13:02,320 --> 00:13:05,120
this was resoundly rejected by everybody

377
00:13:05,120 --> 00:13:07,760
else in the security world they said no

378
00:13:07,760 --> 00:13:09,680
that's insane it's like saying that

379
00:13:09,680 --> 00:13:11,760
every you know every piece of code is

380
00:13:11,760 --> 00:13:14,320
vulnerable to rob you can't do that the

381
00:13:14,320 --> 00:13:16,480
serialization is the vulnerability so

382
00:13:16,480 --> 00:13:20,240
even though i assigned a second cve to

383
00:13:20,240 --> 00:13:23,120
disk file item and they patched it

384
00:13:23,120 --> 00:13:24,959
the apache software foundation didn't

385
00:13:24,959 --> 00:13:27,279
recognize that cve and just said this is

386
00:13:27,279 --> 00:13:28,800
a non-security fix this is like a

387
00:13:28,800 --> 00:13:30,079
hardening fix

388
00:13:30,079 --> 00:13:32,079
and so all the other gadgets that got

389
00:13:32,079 --> 00:13:34,639
exposed never got patched and never got

390
00:13:34,639 --> 00:13:37,200
cves

391
00:13:37,760 --> 00:13:39,199
okay

392
00:13:39,199 --> 00:13:42,560
so moving forward enter jndi and ldap so

393
00:13:42,560 --> 00:13:44,480
that was just the history of how we got

394
00:13:44,480 --> 00:13:46,399
to java deserialization vulnerabilities

395
00:13:46,399 --> 00:13:48,240
we're going to build up to the picture

396
00:13:48,240 --> 00:13:50,639
of how we got to

397
00:13:50,639 --> 00:13:52,720
to log for shell

398
00:13:52,720 --> 00:13:54,639
jndi is the java naming and directory

399
00:13:54,639 --> 00:13:55,760
interface

400
00:13:55,760 --> 00:13:57,519
and all of these acronyms if you go back

401
00:13:57,519 --> 00:14:00,000
to the mid-90s some microsystems when

402
00:14:00,000 --> 00:14:01,920
they used to run java and before they

403
00:14:01,920 --> 00:14:04,240
got destroyed by oracle

404
00:14:04,240 --> 00:14:06,800
they used to have this great vision of

405
00:14:06,800 --> 00:14:08,480
the network is the computer i think that

406
00:14:08,480 --> 00:14:10,800
was their their tagline and the way they

407
00:14:10,800 --> 00:14:12,720
wanted to implement this was to have i

408
00:14:12,720 --> 00:14:14,639
guess it was an early version of web

409
00:14:14,639 --> 00:14:16,880
services that you would have small

410
00:14:16,880 --> 00:14:18,480
pieces of code hosted on different

411
00:14:18,480 --> 00:14:20,720
servers distributed across a network and

412
00:14:20,720 --> 00:14:22,480
that they would make interoperable calls

413
00:14:22,480 --> 00:14:23,600
to each other

414
00:14:23,600 --> 00:14:26,000
now web services implements that using

415
00:14:26,000 --> 00:14:28,320
largely xml and http as encoding and

416
00:14:28,320 --> 00:14:31,040
transport mechanisms before that existed

417
00:14:31,040 --> 00:14:34,320
all of these things ldap rmi corba

418
00:14:34,320 --> 00:14:36,880
jndi were created as mechanisms to allow

419
00:14:36,880 --> 00:14:38,399
for this distribution of code across

420
00:14:38,399 --> 00:14:40,240
computer networks

421
00:14:40,240 --> 00:14:42,320
the basic way that it works is jndi

422
00:14:42,320 --> 00:14:45,519
allows you to look up a remote instance

423
00:14:45,519 --> 00:14:46,320
of

424
00:14:46,320 --> 00:14:48,959
some code it's totally over complicated

425
00:14:48,959 --> 00:14:50,399
everything to do with java is totally

426
00:14:50,399 --> 00:14:52,720
cooked by the way if it's not obvious

427
00:14:52,720 --> 00:14:54,560
so over complicated so jndi lets you

428
00:14:54,560 --> 00:14:56,079
look up an arbitrary remote code

429
00:14:56,079 --> 00:14:59,040
resource ldap is an implementation of

430
00:14:59,040 --> 00:15:00,480
how you can look up a remote code

431
00:15:00,480 --> 00:15:03,839
resource by specifying it as an item in

432
00:15:03,839 --> 00:15:06,399
an ldap directory which then points you

433
00:15:06,399 --> 00:15:09,360
to a url of where that resource is

434
00:15:09,360 --> 00:15:11,440
actually hosted

435
00:15:11,440 --> 00:15:12,639
um

436
00:15:12,639 --> 00:15:13,680
now

437
00:15:13,680 --> 00:15:16,079
this is by design a remote code

438
00:15:16,079 --> 00:15:18,079
execution vector if you look at this

439
00:15:18,079 --> 00:15:20,160
example code down the bottom what's

440
00:15:20,160 --> 00:15:22,959
happening is it's connecting to rmi

441
00:15:22,959 --> 00:15:24,399
which is remote method invocation

442
00:15:24,399 --> 00:15:25,600
another one of these protocols on

443
00:15:25,600 --> 00:15:28,399
localhost 1099 which if you run java

444
00:15:28,399 --> 00:15:31,040
anywhere it listens to 1099 locally for

445
00:15:31,040 --> 00:15:33,440
rmi

446
00:15:33,440 --> 00:15:36,000
and then it goes and looks up a class

447
00:15:36,000 --> 00:15:37,440
called foo

448
00:15:37,440 --> 00:15:40,639
and the value of local obj will be set

449
00:15:40,639 --> 00:15:43,519
to an instance of the foo class

450
00:15:43,519 --> 00:15:47,360
as that class is defined by

451
00:15:47,360 --> 00:15:48,959
what's hosted on this remote method

452
00:15:48,959 --> 00:15:51,199
invocation server so it's by designer

453
00:15:51,199 --> 00:15:54,320
remote code execution mechanism and it's

454
00:15:54,320 --> 00:15:56,560
obviously implicit that applications

455
00:15:56,560 --> 00:15:58,560
should never look up a user controlled

456
00:15:58,560 --> 00:16:01,440
jngi string

457
00:16:01,440 --> 00:16:03,839
the next country in that map was spain

458
00:16:03,839 --> 00:16:05,920
so alvaro munoz another highly

459
00:16:05,920 --> 00:16:08,720
underrated security researcher

460
00:16:08,720 --> 00:16:11,120
he presented this at blackout 2016 where

461
00:16:11,120 --> 00:16:12,800
yes we know that you shouldn't look up

462
00:16:12,800 --> 00:16:14,880
arbitrary use supply j and the i strings

463
00:16:14,880 --> 00:16:16,480
it's obvious but there's a whole lot

464
00:16:16,480 --> 00:16:18,639
more nuance to this

465
00:16:18,639 --> 00:16:20,480
he's it's a fantastic paper by the way i

466
00:16:20,480 --> 00:16:23,600
would highly recommend going through it

467
00:16:23,600 --> 00:16:25,600
but as an example of the kind of thing

468
00:16:25,600 --> 00:16:27,839
that he was able to demonstrate

469
00:16:27,839 --> 00:16:29,920
in this case you

470
00:16:29,920 --> 00:16:32,720
create a

471
00:16:32,720 --> 00:16:35,440
jndi reference to

472
00:16:35,440 --> 00:16:38,639
a secure rmi server that you control so

473
00:16:38,639 --> 00:16:40,880
you think i've given it this contextual

474
00:16:40,880 --> 00:16:43,680
url it's only going to load methods from

475
00:16:43,680 --> 00:16:44,959
that server

476
00:16:44,959 --> 00:16:46,959
but then if you give it essentially an

477
00:16:46,959 --> 00:16:49,040
absolute url path in the lookup that's

478
00:16:49,040 --> 00:16:50,560
attacker controlled it overrides that

479
00:16:50,560 --> 00:16:52,800
completely and just goes to the absolute

480
00:16:52,800 --> 00:16:54,560
path that you've defined rather than the

481
00:16:54,560 --> 00:16:57,279
relative path to that secure server

482
00:16:57,279 --> 00:16:59,600
so what it implies is any way that an

483
00:16:59,600 --> 00:17:01,120
attacker and this this paper is really

484
00:17:01,120 --> 00:17:02,880
extensive it's like 70 slides of

485
00:17:02,880 --> 00:17:04,640
hardcore technical stuff

486
00:17:04,640 --> 00:17:07,679
any way that an attacker can get a jndi

487
00:17:07,679 --> 00:17:10,400
string into a context.lookup they are

488
00:17:10,400 --> 00:17:13,359
going to get rce that's the conclusion

489
00:17:13,359 --> 00:17:16,319
of of his work

490
00:17:17,439 --> 00:17:20,000
enter log4j

491
00:17:20,000 --> 00:17:22,000
log4j is the most popular

492
00:17:22,000 --> 00:17:23,679
logging library in java and it's

493
00:17:23,679 --> 00:17:25,839
absolutely ubiquitous

494
00:17:25,839 --> 00:17:28,160
so java largely uses a dependency

495
00:17:28,160 --> 00:17:30,080
management system called maven there is

496
00:17:30,080 --> 00:17:32,720
an alternative called gradle and it's

497
00:17:32,720 --> 00:17:35,120
notorious for creating huge dependency

498
00:17:35,120 --> 00:17:36,320
graphs

499
00:17:36,320 --> 00:17:38,799
because the architecture of java is that

500
00:17:38,799 --> 00:17:40,480
everything has been modularized into

501
00:17:40,480 --> 00:17:43,200
small components once you include one

502
00:17:43,200 --> 00:17:44,880
component it's then got dependencies on

503
00:17:44,880 --> 00:17:46,160
another 10 that have dependencies in

504
00:17:46,160 --> 00:17:47,679
another five and another

505
00:17:47,679 --> 00:17:49,039
and all of a sudden you just wanted to

506
00:17:49,039 --> 00:17:50,480
includes like

507
00:17:50,480 --> 00:17:53,039
apache common file upload in order to

508
00:17:53,039 --> 00:17:55,520
upload some files and now you've got 15

509
00:17:55,520 --> 00:17:57,120
different libraries in your dependency

510
00:17:57,120 --> 00:17:58,000
graph

511
00:17:58,000 --> 00:18:00,080
so large enterprise applications can

512
00:18:00,080 --> 00:18:02,000
easily easily have upwards of 100

513
00:18:02,000 --> 00:18:04,000
dependencies in their graph and i've

514
00:18:04,000 --> 00:18:05,440
never seen an enterprise application

515
00:18:05,440 --> 00:18:07,600
that doesn't have log4j somehow in there

516
00:18:07,600 --> 00:18:09,919
because it's so ubiquitous

517
00:18:09,919 --> 00:18:13,679
this is an erd of the structure of

518
00:18:13,679 --> 00:18:14,880
log4j

519
00:18:14,880 --> 00:18:16,480
the main point is that it's got a

520
00:18:16,480 --> 00:18:19,120
contextual logging capability

521
00:18:19,120 --> 00:18:23,440
and the philosophy of log4j is that you

522
00:18:23,440 --> 00:18:25,520
should never have to use a debugger you

523
00:18:25,520 --> 00:18:26,960
should contextually log everything

524
00:18:26,960 --> 00:18:28,480
because you can you know you can say

525
00:18:28,480 --> 00:18:30,480
this is a debug log this is a normal log

526
00:18:30,480 --> 00:18:32,320
this is a that log whatever and you

527
00:18:32,320 --> 00:18:33,600
should never actually have to run your

528
00:18:33,600 --> 00:18:35,600
code through a debugger because you log

529
00:18:35,600 --> 00:18:37,840
everything verbosely

530
00:18:37,840 --> 00:18:40,320
and that's what everybody does

531
00:18:40,320 --> 00:18:43,600
so then enter log for shell

532
00:18:43,600 --> 00:18:45,120
and this is where we get to i think the

533
00:18:45,120 --> 00:18:46,400
last country in that map of the world

534
00:18:46,400 --> 00:18:48,960
which is china so chen jajun who found

535
00:18:48,960 --> 00:18:50,400
this vulnerability

536
00:18:50,400 --> 00:18:51,440
um

537
00:18:51,440 --> 00:18:54,880
identified that log for j

538
00:18:54,880 --> 00:18:57,039
has a lot of advanced capabilities you

539
00:18:57,039 --> 00:18:59,600
can use it to just log strings

540
00:18:59,600 --> 00:19:01,679
but those strings are not just string

541
00:19:01,679 --> 00:19:02,799
literals

542
00:19:02,799 --> 00:19:05,200
they contain an expression language

543
00:19:05,200 --> 00:19:07,120
and that expression language can be used

544
00:19:07,120 --> 00:19:09,039
to bind variables

545
00:19:09,039 --> 00:19:10,400
similar to the way that you might do

546
00:19:10,400 --> 00:19:13,600
something like bind um

547
00:19:13,600 --> 00:19:15,760
sql parameters you know in a query

548
00:19:15,760 --> 00:19:17,440
string or something like that you can

549
00:19:17,440 --> 00:19:19,600
bind variables and you know like a

550
00:19:19,600 --> 00:19:21,840
format string sort of thing but it's got

551
00:19:21,840 --> 00:19:23,280
all this advanced functionality and one

552
00:19:23,280 --> 00:19:24,960
of the things that you can do is

553
00:19:24,960 --> 00:19:27,919
actually give it a jndi uri

554
00:19:27,919 --> 00:19:31,840
and that jndi uri will be resolved and

555
00:19:31,840 --> 00:19:33,760
executed

556
00:19:33,760 --> 00:19:36,880
so an attacker who can control input

557
00:19:36,880 --> 00:19:38,640
into log messages or log message

558
00:19:38,640 --> 00:19:39,919
parameters

559
00:19:39,919 --> 00:19:42,240
can use that to inject

560
00:19:42,240 --> 00:19:44,720
a jndi url which as we then said if you

561
00:19:44,720 --> 00:19:46,799
do a context lookup on a jndi url you

562
00:19:46,799 --> 00:19:49,360
get remote code exec

563
00:19:49,360 --> 00:19:51,360
and therefore because everything is

564
00:19:51,360 --> 00:19:52,799
using log4j

565
00:19:52,799 --> 00:19:54,880
everything is logging something supplied

566
00:19:54,880 --> 00:19:57,600
by a user everything is vulnerable

567
00:19:57,600 --> 00:19:59,600
here's some example code which i don't

568
00:19:59,600 --> 00:20:01,919
know if is sufficiently visible in that

569
00:20:01,919 --> 00:20:05,280
shitty resolution i apologize

570
00:20:05,280 --> 00:20:08,240
but basically it's that you have a http

571
00:20:08,240 --> 00:20:10,000
server with an attacker controlled

572
00:20:10,000 --> 00:20:11,520
variable that goes in one of the the

573
00:20:11,520 --> 00:20:13,440
variables that was very commonly used to

574
00:20:13,440 --> 00:20:16,240
exploit this was the user agent string

575
00:20:16,240 --> 00:20:17,919
because the user agent strings just a

576
00:20:17,919 --> 00:20:20,480
http request header but it's logged

577
00:20:20,480 --> 00:20:22,000
almost ubiquitously because everybody

578
00:20:22,000 --> 00:20:24,000
wants to do analytics to determine what

579
00:20:24,000 --> 00:20:25,600
browser everybody's using right so it's

580
00:20:25,600 --> 00:20:27,280
going to get into a log file somewhere

581
00:20:27,280 --> 00:20:29,600
so just inject the user agent that gets

582
00:20:29,600 --> 00:20:31,520
logged and what you put in the user

583
00:20:31,520 --> 00:20:32,640
agent is

584
00:20:32,640 --> 00:20:35,200
this jndi string

585
00:20:35,200 --> 00:20:37,360
so this is what an attack chain looks

586
00:20:37,360 --> 00:20:39,760
like you make a request including that

587
00:20:39,760 --> 00:20:42,960
string and so those curly braces are how

588
00:20:42,960 --> 00:20:45,919
the expression language format

589
00:20:45,919 --> 00:20:47,600
within

590
00:20:47,600 --> 00:20:51,200
log4j identifies that it's got a jndi

591
00:20:51,200 --> 00:20:53,919
uri that it wants to interpolate

592
00:20:53,919 --> 00:20:56,080
you pass that into the target server it

593
00:20:56,080 --> 00:20:57,840
will then make a request back to that

594
00:20:57,840 --> 00:20:59,600
url which should

595
00:20:59,600 --> 00:21:01,520
point to a server that you control which

596
00:21:01,520 --> 00:21:03,600
will host a malicious class

597
00:21:03,600 --> 00:21:05,120
that malicious class will then be sent

598
00:21:05,120 --> 00:21:06,320
to the server and it will be

599
00:21:06,320 --> 00:21:07,919
deserialized

600
00:21:07,919 --> 00:21:10,559
you get straight code exec now

601
00:21:10,559 --> 00:21:12,080
going back to what we were talking about

602
00:21:12,080 --> 00:21:13,919
at the very start of this talk about how

603
00:21:13,919 --> 00:21:16,480
deserialization rce works this isn't the

604
00:21:16,480 --> 00:21:18,799
case here this is literally just you

605
00:21:18,799 --> 00:21:20,400
define a class

606
00:21:20,400 --> 00:21:22,559
that has whatever you want in it you

607
00:21:22,559 --> 00:21:24,400
pass a reference to it to the server it

608
00:21:24,400 --> 00:21:26,080
goes and retrieves it and then it

609
00:21:26,080 --> 00:21:27,600
deserializes your class and does

610
00:21:27,600 --> 00:21:30,000
whatever you want it doesn't rely on any

611
00:21:30,000 --> 00:21:31,679
of that stuff that we spoke about

612
00:21:31,679 --> 00:21:33,600
earlier

613
00:21:33,600 --> 00:21:35,440
however

614
00:21:35,440 --> 00:21:37,840
that was only exploitable under a whole

615
00:21:37,840 --> 00:21:39,360
set of conditions

616
00:21:39,360 --> 00:21:40,880
the application has to use a vulnerable

617
00:21:40,880 --> 00:21:42,480
version of log4j

618
00:21:42,480 --> 00:21:44,799
it has to log arbitrary strings provided

619
00:21:44,799 --> 00:21:47,200
by the user those are pretty easily met

620
00:21:47,200 --> 00:21:48,799
there's no log for j specific

621
00:21:48,799 --> 00:21:50,720
mitigations so people were trying all

622
00:21:50,720 --> 00:21:53,280
these things like i'll set this jvm flag

623
00:21:53,280 --> 00:21:55,679
at runtime to disable blah blah blah and

624
00:21:55,679 --> 00:21:57,200
it will fix it

625
00:21:57,200 --> 00:22:00,480
and you had to have a specific version

626
00:22:00,480 --> 00:22:03,919
of the jre or jdk that was vulnerable

627
00:22:03,919 --> 00:22:06,080
for it to work now the reason you had to

628
00:22:06,080 --> 00:22:08,159
have a specific version of java to be

629
00:22:08,159 --> 00:22:11,120
vulnerable was that they realized there

630
00:22:11,120 --> 00:22:13,840
was an insecure default property

631
00:22:13,840 --> 00:22:16,799
so this ldap.object that trust url code

632
00:22:16,799 --> 00:22:17,679
base

633
00:22:17,679 --> 00:22:20,000
is the configuration parameter that

634
00:22:20,000 --> 00:22:22,559
allows by default

635
00:22:22,559 --> 00:22:24,320
you to just

636
00:22:24,320 --> 00:22:26,800
pass in an attacker controlled

637
00:22:26,800 --> 00:22:28,000
[Music]

638
00:22:28,000 --> 00:22:30,000
jndi url and have it resolved no

639
00:22:30,000 --> 00:22:31,600
questions asked

640
00:22:31,600 --> 00:22:32,400
if

641
00:22:32,400 --> 00:22:33,760
this parameter is set to this

642
00:22:33,760 --> 00:22:36,080
configuration parameter is set to false

643
00:22:36,080 --> 00:22:38,559
that functionality will be disabled out

644
00:22:38,559 --> 00:22:39,760
of the box

645
00:22:39,760 --> 00:22:42,080
and finally after however many years of

646
00:22:42,080 --> 00:22:44,559
java being around somebody realized we

647
00:22:44,559 --> 00:22:47,520
should set this to false by default

648
00:22:47,520 --> 00:22:49,520
and they did that before the log for

649
00:22:49,520 --> 00:22:51,679
show vulnerability came out

650
00:22:51,679 --> 00:22:54,400
but not sufficiently long ago that a lot

651
00:22:54,400 --> 00:22:56,000
of people weren't running vulnerable

652
00:22:56,000 --> 00:22:57,440
versions of java

653
00:22:57,440 --> 00:23:01,039
now as a brief aside to this

654
00:23:01,039 --> 00:23:03,200
this is a common historical theme with

655
00:23:03,200 --> 00:23:05,360
java of having really bad insecure

656
00:23:05,360 --> 00:23:08,559
defaults my favorite story is about xxe

657
00:23:08,559 --> 00:23:10,480
vulnerabilities in java

658
00:23:10,480 --> 00:23:13,039
because if you go back to 2003 somewhere

659
00:23:13,039 --> 00:23:16,080
on the microsoft msdn forums there's

660
00:23:16,080 --> 00:23:18,400
some post in 2003 where somebody has

661
00:23:18,400 --> 00:23:21,039
recognized the xxe vulnerability class

662
00:23:21,039 --> 00:23:23,600
and said hey in the xml parsers we

663
00:23:23,600 --> 00:23:25,520
should disable the expansion of external

664
00:23:25,520 --> 00:23:28,000
entities by default and only enable it

665
00:23:28,000 --> 00:23:30,720
when you know when requested and like a

666
00:23:30,720 --> 00:23:32,320
few months later microsoft are like this

667
00:23:32,320 --> 00:23:35,200
is in msdn patch bar and since then it's

668
00:23:35,200 --> 00:23:37,200
been fixed in.net which is why net

669
00:23:37,200 --> 00:23:39,440
applications have hardly had any xxe

670
00:23:39,440 --> 00:23:40,960
vulnerabilities

671
00:23:40,960 --> 00:23:42,480
java apps on the other case had it

672
00:23:42,480 --> 00:23:44,720
enabled by default and when this started

673
00:23:44,720 --> 00:23:48,000
to become a bit of a pandemic circa 2012

674
00:23:48,000 --> 00:23:50,480
of all these xxe volumes in java i tried

675
00:23:50,480 --> 00:23:52,240
to work with the java developers to

676
00:23:52,240 --> 00:23:54,320
disable it by default and they said

677
00:23:54,320 --> 00:23:55,840
actually we can't

678
00:23:55,840 --> 00:23:57,679
because the way java is designed you

679
00:23:57,679 --> 00:23:59,919
have these specifications

680
00:23:59,919 --> 00:24:01,840
that i think they call jsrs java

681
00:24:01,840 --> 00:24:03,760
specification requests to define how

682
00:24:03,760 --> 00:24:05,520
everything will work and because there's

683
00:24:05,520 --> 00:24:07,200
heterogeneous implementations of

684
00:24:07,200 --> 00:24:09,039
everything that's like the hp

685
00:24:09,039 --> 00:24:12,640
jvm the ibm jvm the open jvm the all

686
00:24:12,640 --> 00:24:14,960
these the sun jvm oracle jvm

687
00:24:14,960 --> 00:24:16,640
they all implement this contract

688
00:24:16,640 --> 00:24:17,919
specification in order to be

689
00:24:17,919 --> 00:24:19,600
interoperable and the contract

690
00:24:19,600 --> 00:24:23,679
specification had stated that you must

691
00:24:23,679 --> 00:24:25,360
expand

692
00:24:25,360 --> 00:24:27,200
external entities in xml parsers by

693
00:24:27,200 --> 00:24:29,120
default so they couldn't patch the

694
00:24:29,120 --> 00:24:30,159
vulnerability because it would break the

695
00:24:30,159 --> 00:24:31,120
contracts and hence you have this

696
00:24:31,120 --> 00:24:33,520
pandemic of x6 vons in java so the point

697
00:24:33,520 --> 00:24:35,120
of the story was they've had a bad track

698
00:24:35,120 --> 00:24:37,918
record with this one

699
00:24:38,640 --> 00:24:39,760
so

700
00:24:39,760 --> 00:24:41,919
what then was possible

701
00:24:41,919 --> 00:24:44,960
on these non-vulnerable versions of java

702
00:24:44,960 --> 00:24:46,880
was you could go back to this original

703
00:24:46,880 --> 00:24:49,080
thing you could go back to

704
00:24:49,080 --> 00:24:50,640
deserializing

705
00:24:50,640 --> 00:24:52,480
a class that existed because you could

706
00:24:52,480 --> 00:24:54,240
no longer deserialize a remotely

707
00:24:54,240 --> 00:24:56,000
supplied class

708
00:24:56,000 --> 00:24:58,240
you could deserialize a locally supplied

709
00:24:58,240 --> 00:25:01,120
class and then if that local class had

710
00:25:01,120 --> 00:25:02,799
because this configuration parameter

711
00:25:02,799 --> 00:25:04,880
prevented you from loading your external

712
00:25:04,880 --> 00:25:06,559
code but it didn't prevent you from

713
00:25:06,559 --> 00:25:08,720
pointing to a local class and if you

714
00:25:08,720 --> 00:25:10,559
could point to a local class that

715
00:25:10,559 --> 00:25:13,120
contained an exploitable gadget chain

716
00:25:13,120 --> 00:25:15,520
then you would land in rce the same way

717
00:25:15,520 --> 00:25:17,279
that takeshi torada had figured out back

718
00:25:17,279 --> 00:25:18,960
in 2013.

719
00:25:18,960 --> 00:25:21,039
bypassed all the controls

720
00:25:21,039 --> 00:25:23,600
and required them to to issue reissue

721
00:25:23,600 --> 00:25:25,520
the patch for this

722
00:25:25,520 --> 00:25:27,760
now this is my smug little moment where

723
00:25:27,760 --> 00:25:30,640
i get to say i told you so because if we

724
00:25:30,640 --> 00:25:33,039
had actually patched all of the gadget

725
00:25:33,039 --> 00:25:35,600
chains as originally proposed

726
00:25:35,600 --> 00:25:36,799
and considered those to be a

727
00:25:36,799 --> 00:25:38,000
vulnerability

728
00:25:38,000 --> 00:25:39,760
none of this would have happened

729
00:25:39,760 --> 00:25:41,279
but because those gadget chains were

730
00:25:41,279 --> 00:25:43,440
left unpatched and the deserialization

731
00:25:43,440 --> 00:25:45,360
was considered to be the vulnerability

732
00:25:45,360 --> 00:25:46,799
this whole thing was exposed to a

733
00:25:46,799 --> 00:25:50,400
broader audience than it needed to be

734
00:25:50,799 --> 00:25:54,440
that's the end of my presentation

735
00:26:13,200 --> 00:26:15,200
yeah i can

736
00:26:15,200 --> 00:26:16,880
hey man yeah so yeah dave that was great

737
00:26:16,880 --> 00:26:18,559
talk um

738
00:26:18,559 --> 00:26:19,919
especially if you think of how things

739
00:26:19,919 --> 00:26:22,320
could have been different back in 2013

740
00:26:22,320 --> 00:26:23,760
if things had it's yeah it's an

741
00:26:23,760 --> 00:26:25,279
interesting it's interesting what if

742
00:26:25,279 --> 00:26:26,799
yeah and then people wouldn't be like

743
00:26:26,799 --> 00:26:29,520
renaming their teslas and iphones to

744
00:26:29,520 --> 00:26:31,360
jndi ldap

745
00:26:31,360 --> 00:26:32,320
um

746
00:26:32,320 --> 00:26:34,320
we don't have any questions but um

747
00:26:34,320 --> 00:26:35,919
it's alright so it might be a great time

748
00:26:35,919 --> 00:26:37,360
to go early to lunch draw dave would

749
00:26:37,360 --> 00:26:39,279
love to catch up outside he's a really

750
00:26:39,279 --> 00:26:40,480
smart guy really great guy so yeah

751
00:26:40,480 --> 00:26:41,600
please thank david again thank you

752
00:26:41,600 --> 00:26:43,160
everybody

753
00:26:43,160 --> 00:26:46,380
[Applause]

