1
00:00:01,360 --> 00:00:05,040
hi everyone welcome to the talk on

2
00:00:03,120 --> 00:00:06,399
modern browser security the first line

3
00:00:05,040 --> 00:00:09,440
of defense presented at

4
00:00:06,399 --> 00:00:11,280
officer 2020

5
00:00:09,440 --> 00:00:12,559
a quick introduction about myself so my

6
00:00:11,280 --> 00:00:14,399
name is pratik

7
00:00:12,559 --> 00:00:15,759
i'm a security researcher and i'm

8
00:00:14,400 --> 00:00:16,880
interested in mobile and browser

9
00:00:15,759 --> 00:00:19,760
security

10
00:00:16,880 --> 00:00:22,560
i blog at highlititudetax.com i'm also

11
00:00:19,760 --> 00:00:24,400
the author of a damn vulnerable ios app

12
00:00:22,560 --> 00:00:26,640
and i've spoken and trained and trained

13
00:00:24,400 --> 00:00:30,159
at conferences such as black hat defcon

14
00:00:26,640 --> 00:00:33,360
hack in paris positive hack days etc

15
00:00:30,160 --> 00:00:36,480
and you can find the github link

16
00:00:33,360 --> 00:00:38,320
to my to my github repository over here

17
00:00:36,480 --> 00:00:40,398
so let's talk about what we're going to

18
00:00:38,320 --> 00:00:41,680
discuss today so we're going to discuss

19
00:00:40,399 --> 00:00:44,320
a little bit about the browser

20
00:00:41,680 --> 00:00:46,559
architecture then we will discuss

21
00:00:44,320 --> 00:00:48,559
some javascript internals followed by

22
00:00:46,559 --> 00:00:49,440
some of the latest browser mitigations

23
00:00:48,559 --> 00:00:51,360
which are

24
00:00:49,440 --> 00:00:53,440
being applied in the browsers today

25
00:00:51,360 --> 00:00:54,079
we'll also look at attacking javascript

26
00:00:53,440 --> 00:00:56,839
core

27
00:00:54,079 --> 00:00:58,160
which is most like is most commonly

28
00:00:56,840 --> 00:01:00,800
attacked

29
00:00:58,160 --> 00:01:03,120
part of a browser these days and then we

30
00:01:00,800 --> 00:01:05,119
look at how to build expert primitives

31
00:01:03,120 --> 00:01:06,960
and using this exploit primitives how we

32
00:01:05,119 --> 00:01:08,720
achieve arbitrary read write

33
00:01:06,960 --> 00:01:10,399
finally we'll conclude with some advice

34
00:01:08,720 --> 00:01:12,479
on fuzzing webkit

35
00:01:10,400 --> 00:01:14,320
so why do we need browsers well browsers

36
00:01:12,479 --> 00:01:16,320
have a huge attack surface

37
00:01:14,320 --> 00:01:17,439
um and the data is actually loaded and

38
00:01:16,320 --> 00:01:20,559
rendered from the internet

39
00:01:17,439 --> 00:01:20,559
so you don't need there is no

40
00:01:21,439 --> 00:01:25,360
challenge in executing in basically

41
00:01:23,520 --> 00:01:26,960
getting code execution because the data

42
00:01:25,360 --> 00:01:28,080
is itself loaded and rendered from the

43
00:01:26,960 --> 00:01:30,880
internet

44
00:01:28,080 --> 00:01:31,759
it's also almost as complicated as an

45
00:01:30,880 --> 00:01:34,320
operating system

46
00:01:31,759 --> 00:01:35,280
in terms of the lines of code and this

47
00:01:34,320 --> 00:01:37,919
basically

48
00:01:35,280 --> 00:01:39,520
gives it a big attack surface it has a

49
00:01:37,920 --> 00:01:40,720
lot of entry points for remote code

50
00:01:39,520 --> 00:01:42,880
execution

51
00:01:40,720 --> 00:01:44,158
which we'll see later in this talk and

52
00:01:42,880 --> 00:01:45,839
it also has something called jit

53
00:01:44,159 --> 00:01:46,640
compilers which makes for a very easy

54
00:01:45,840 --> 00:01:48,720
target

55
00:01:46,640 --> 00:01:50,479
simply because it has a mapping which is

56
00:01:48,720 --> 00:01:52,880
read write and executable

57
00:01:50,479 --> 00:01:55,759
it also has relaxed code signing which

58
00:01:52,880 --> 00:01:58,399
means the code which is being run

59
00:01:55,759 --> 00:01:59,040
in a in a jit region is not checked for

60
00:01:58,399 --> 00:02:02,000
its

61
00:01:59,040 --> 00:02:03,360
code signature let's talk a little about

62
00:02:02,000 --> 00:02:06,399
browser architecture

63
00:02:03,360 --> 00:02:07,759
so so the first thing to discuss here is

64
00:02:06,399 --> 00:02:09,360
a user interface

65
00:02:07,759 --> 00:02:11,440
so the user interface is a component

66
00:02:09,360 --> 00:02:12,800
that allows the end users to interact

67
00:02:11,440 --> 00:02:15,680
with all visual elements

68
00:02:12,800 --> 00:02:17,360
available on the web page this could be

69
00:02:15,680 --> 00:02:19,520
the address bar the home button

70
00:02:17,360 --> 00:02:21,200
the next button and so on then we have

71
00:02:19,520 --> 00:02:23,599
the browser engine which is a core

72
00:02:21,200 --> 00:02:26,079
component of every web browser

73
00:02:23,599 --> 00:02:27,920
this actually acts as an intermediary or

74
00:02:26,080 --> 00:02:29,440
a bridge between the user interface and

75
00:02:27,920 --> 00:02:31,599
the rendering engine

76
00:02:29,440 --> 00:02:33,760
it queries and handles the rendering

77
00:02:31,599 --> 00:02:35,359
engine as per the

78
00:02:33,760 --> 00:02:37,280
inputs it receives from the user

79
00:02:35,360 --> 00:02:38,959
interface then we have the rendering

80
00:02:37,280 --> 00:02:40,879
engine which as the name suggests is

81
00:02:38,959 --> 00:02:42,080
responsible for rendering a specific web

82
00:02:40,879 --> 00:02:44,319
page

83
00:02:42,080 --> 00:02:46,160
we also have a networking layer and we

84
00:02:44,319 --> 00:02:47,518
also have a javascript interpreter which

85
00:02:46,160 --> 00:02:50,640
is more important

86
00:02:47,519 --> 00:02:52,480
from an exploitation context because it

87
00:02:50,640 --> 00:02:54,000
is responsible for parsing and executing

88
00:02:52,480 --> 00:02:55,679
the javascript code embedded in the

89
00:02:54,000 --> 00:02:57,760
website

90
00:02:55,680 --> 00:03:00,720
so we'll look at how we can exploit this

91
00:02:57,760 --> 00:03:02,879
then we have a ui backend

92
00:03:00,720 --> 00:03:04,400
which uses the use the user interface

93
00:03:02,879 --> 00:03:06,159
methods of the underlying operating

94
00:03:04,400 --> 00:03:08,560
system for

95
00:03:06,159 --> 00:03:09,760
ui stuff for example like drawing

96
00:03:08,560 --> 00:03:11,360
widgets and stuff

97
00:03:09,760 --> 00:03:12,959
and then we have a persistent layer

98
00:03:11,360 --> 00:03:15,599
which is

99
00:03:12,959 --> 00:03:16,560
a data persistence layer which is used

100
00:03:15,599 --> 00:03:19,679
to store data

101
00:03:16,560 --> 00:03:21,680
locally for example uh cookies

102
00:03:19,680 --> 00:03:24,000
so in this talk we are mostly focused on

103
00:03:21,680 --> 00:03:26,319
the webkit which is the rendering engine

104
00:03:24,000 --> 00:03:27,680
of the browser

105
00:03:26,319 --> 00:03:29,440
so what is the rendering engine so the

106
00:03:27,680 --> 00:03:31,440
rendering engine is responsible for

107
00:03:29,440 --> 00:03:34,000
displaying the requested content could

108
00:03:31,440 --> 00:03:35,680
be html css javascript

109
00:03:34,000 --> 00:03:37,360
we are mostly interested in finding

110
00:03:35,680 --> 00:03:39,760
vulnerabilities in the resin ring engine

111
00:03:37,360 --> 00:03:42,640
because it has a huge attack surface

112
00:03:39,760 --> 00:03:45,200
and many pass vulnerabilities it's also

113
00:03:42,640 --> 00:03:47,200
open source for all the major browsers

114
00:03:45,200 --> 00:03:49,679
and also debuggable so you can build a

115
00:03:47,200 --> 00:03:52,798
debug version of the

116
00:03:49,680 --> 00:03:54,640
of the rendering engine and debug it so

117
00:03:52,799 --> 00:03:57,439
the rendering engine used for ie

118
00:03:54,640 --> 00:04:00,079
is trident for firefox it's gecko and

119
00:03:57,439 --> 00:04:02,000
for safari it's webkit

120
00:04:00,080 --> 00:04:03,519
the chrome and opera they use a blink

121
00:04:02,000 --> 00:04:04,879
which is a fork of webkit

122
00:04:03,519 --> 00:04:08,400
it's important to know that all these

123
00:04:04,879 --> 00:04:08,399
rendering engines are open source

124
00:04:08,640 --> 00:04:12,559
so if you actually open safari and you

125
00:04:10,720 --> 00:04:15,040
open different apps you will see that

126
00:04:12,560 --> 00:04:16,478
all these tabs run as their own process

127
00:04:15,040 --> 00:04:17,759
and the name of the process is web

128
00:04:16,478 --> 00:04:20,399
content

129
00:04:17,759 --> 00:04:22,079
so this is a way to implement a same

130
00:04:20,399 --> 00:04:25,758
origin policy within the browser

131
00:04:22,079 --> 00:04:29,440
however the the different tabs can also

132
00:04:25,759 --> 00:04:31,600
communicate to each other using ipc

133
00:04:29,440 --> 00:04:33,919
so we'll look into this later on how we

134
00:04:31,600 --> 00:04:35,680
can bypass same origin policy once we

135
00:04:33,919 --> 00:04:38,880
get free dot executable

136
00:04:35,680 --> 00:04:40,479
read write primitive

137
00:04:38,880 --> 00:04:43,120
or within the context from the rendering

138
00:04:40,479 --> 00:04:45,520
engine and this is how

139
00:04:43,120 --> 00:04:46,560
the rendered process will look like when

140
00:04:45,520 --> 00:04:48,240
you run ps

141
00:04:46,560 --> 00:04:49,600
aux command you will see all the tabs

142
00:04:48,240 --> 00:04:51,040
have their own process

143
00:04:49,600 --> 00:04:53,040
and the name of the process is web

144
00:04:51,040 --> 00:04:55,440
content

145
00:04:53,040 --> 00:04:56,720
so webkit is the open source web browser

146
00:04:55,440 --> 00:05:00,400
engine uh which is

147
00:04:56,720 --> 00:05:02,000
powering um safari on ios and mac os

148
00:05:00,400 --> 00:05:03,440
it's open source and it's

149
00:05:02,000 --> 00:05:06,000
uh some of different projects such as

150
00:05:03,440 --> 00:05:06,960
webcore javascript core and web template

151
00:05:06,000 --> 00:05:10,320
framework

152
00:05:06,960 --> 00:05:11,680
so the javascript code is the javascript

153
00:05:10,320 --> 00:05:14,560
engine which is used to run

154
00:05:11,680 --> 00:05:16,479
render javascript code in this

155
00:05:14,560 --> 00:05:18,000
presentation we will be focusing mostly

156
00:05:16,479 --> 00:05:20,400
on javascript code

157
00:05:18,000 --> 00:05:22,800
now the code the browser that we have on

158
00:05:20,400 --> 00:05:26,320
ios and mac os which is a safari

159
00:05:22,800 --> 00:05:28,400
it basically wraps webkit with some os

160
00:05:26,320 --> 00:05:30,719
or ios specific code so with some

161
00:05:28,400 --> 00:05:32,400
platform specific code

162
00:05:30,720 --> 00:05:33,759
we have something called webkit ports

163
00:05:32,400 --> 00:05:36,638
which is a

164
00:05:33,759 --> 00:05:39,520
combination of some platform

165
00:05:36,639 --> 00:05:41,759
technologies that allow it to run

166
00:05:39,520 --> 00:05:43,919
the browser the webkit browser engines

167
00:05:41,759 --> 00:05:46,080
so for to give you an example the webkit

168
00:05:43,919 --> 00:05:48,560
is used in several places it use

169
00:05:46,080 --> 00:05:49,599
on playstation devices it's used in

170
00:05:48,560 --> 00:05:51,919
tesla

171
00:05:49,600 --> 00:05:54,560
so the ports allow you to build webkit

172
00:05:51,919 --> 00:05:56,080
specific to that platform

173
00:05:54,560 --> 00:05:58,080
now these are some instructions on how

174
00:05:56,080 --> 00:05:59,680
you can set up webkit so you just clone

175
00:05:58,080 --> 00:06:00,000
the repository and then you can check

176
00:05:59,680 --> 00:06:02,160
out

177
00:06:00,000 --> 00:06:03,039
whatever revision you want you can

178
00:06:02,160 --> 00:06:06,240
either check out

179
00:06:03,039 --> 00:06:07,440
a webkit from svn or you can download it

180
00:06:06,240 --> 00:06:10,080
from github

181
00:06:07,440 --> 00:06:12,400
so the the copy on github is not the

182
00:06:10,080 --> 00:06:16,400
official one but it's

183
00:06:12,400 --> 00:06:19,280
a copy it's an unofficial copy of the

184
00:06:16,400 --> 00:06:20,880
of the repository which is hosted on svn

185
00:06:19,280 --> 00:06:22,400
then you can either

186
00:06:20,880 --> 00:06:23,759
configure webkit for the debug

187
00:06:22,400 --> 00:06:24,719
environment or for the release

188
00:06:23,759 --> 00:06:26,720
environment

189
00:06:24,720 --> 00:06:28,319
you can also build webkit with some

190
00:06:26,720 --> 00:06:29,759
address sanitizer support which will

191
00:06:28,319 --> 00:06:31,199
help you to detect memory corruption

192
00:06:29,759 --> 00:06:32,639
vulnerabilities

193
00:06:31,199 --> 00:06:34,000
then you can either build the entire

194
00:06:32,639 --> 00:06:36,240
webkit or you can just build the

195
00:06:34,000 --> 00:06:37,520
javascript component of the webkit

196
00:06:36,240 --> 00:06:39,840
so if you want to find out which

197
00:06:37,520 --> 00:06:41,520
particular version of webkit is used in

198
00:06:39,840 --> 00:06:42,318
safari you can go to this particular

199
00:06:41,520 --> 00:06:44,318
place

200
00:06:42,319 --> 00:06:46,080
in safari so you just go to safari and

201
00:06:44,319 --> 00:06:48,160
click on about safari

202
00:06:46,080 --> 00:06:49,840
and you can find this string here which

203
00:06:48,160 --> 00:06:52,639
is which denotes the webkit version

204
00:06:49,840 --> 00:06:52,638
which is being used

205
00:06:55,360 --> 00:06:58,639
um what are the advantages of building

206
00:06:58,000 --> 00:07:01,520
webkit

207
00:06:58,639 --> 00:07:03,520
for debug versus release well the debug

208
00:07:01,520 --> 00:07:05,039
build has

209
00:07:03,520 --> 00:07:07,758
it's slower to build but it has the

210
00:07:05,039 --> 00:07:09,440
symbols however it also has some assets

211
00:07:07,759 --> 00:07:12,080
which might block exploits

212
00:07:09,440 --> 00:07:13,759
the release build is faster however it

213
00:07:12,080 --> 00:07:15,280
is not good for debugging

214
00:07:13,759 --> 00:07:17,039
simply because it doesn't have the

215
00:07:15,280 --> 00:07:18,799
symbols and stuff like that

216
00:07:17,039 --> 00:07:21,039
however it is good for testing the final

217
00:07:18,800 --> 00:07:22,560
exploit so these are some instructions

218
00:07:21,039 --> 00:07:23,520
on how you can build in this case i'm

219
00:07:22,560 --> 00:07:25,440
building uh

220
00:07:23,520 --> 00:07:27,039
setting the webkit configuration to

221
00:07:25,440 --> 00:07:28,800
support address sanitizer and then

222
00:07:27,039 --> 00:07:31,120
building it with

223
00:07:28,800 --> 00:07:33,120
the debug flags and also only building

224
00:07:31,120 --> 00:07:35,120
the javascript code component

225
00:07:33,120 --> 00:07:37,919
and once webcam is built you can run it

226
00:07:35,120 --> 00:07:40,160
using the following command

227
00:07:37,919 --> 00:07:41,120
uh in javascript code for the debug

228
00:07:40,160 --> 00:07:42,639
build you have something called a

229
00:07:41,120 --> 00:07:45,440
describe function which you can

230
00:07:42,639 --> 00:07:47,599
as you can look here it gives you the

231
00:07:45,440 --> 00:07:49,199
address of that particular object

232
00:07:47,599 --> 00:07:51,840
and this is a very useful function which

233
00:07:49,199 --> 00:07:53,440
we will look at

234
00:07:51,840 --> 00:07:54,878
in the coming slides you can also see

235
00:07:53,440 --> 00:07:56,960
that

236
00:07:54,879 --> 00:07:58,160
the structure id is being incremented by

237
00:07:56,960 --> 00:08:00,239
one over here

238
00:07:58,160 --> 00:08:01,599
however with some recent mitigations

239
00:08:00,240 --> 00:08:03,199
this has been fixed

240
00:08:01,599 --> 00:08:06,560
so we also look at what is a structure

241
00:08:03,199 --> 00:08:06,560
id and how this can be exploited

242
00:08:06,720 --> 00:08:11,280
then you can also you should also

243
00:08:10,000 --> 00:08:13,680
understand how to convert

244
00:08:11,280 --> 00:08:14,960
unsigned long long integer to audible

245
00:08:13,680 --> 00:08:18,160
simply because in

246
00:08:14,960 --> 00:08:19,758
javascript code when you store doubles

247
00:08:18,160 --> 00:08:20,479
it's stored as an unsigned long long

248
00:08:19,759 --> 00:08:22,000
integer

249
00:08:20,479 --> 00:08:23,680
so these are some instructions on how

250
00:08:22,000 --> 00:08:26,800
you can use python and using

251
00:08:23,680 --> 00:08:29,919
use the struct module to convert

252
00:08:26,800 --> 00:08:29,919
our audible to

253
00:08:30,800 --> 00:08:36,399
an unsigned long long int and vice versa

254
00:08:34,399 --> 00:08:40,000
so talking about javascript so all the

255
00:08:36,399 --> 00:08:42,880
modern browsers are using javascript

256
00:08:40,000 --> 00:08:43,679
it has two different kinds of data types

257
00:08:42,880 --> 00:08:46,160
one of which

258
00:08:43,679 --> 00:08:47,839
is uh the primitive types and the other

259
00:08:46,160 --> 00:08:50,160
one is the object types

260
00:08:47,839 --> 00:08:52,080
now different browsers implement their

261
00:08:50,160 --> 00:08:53,920
own javascript engine so for example for

262
00:08:52,080 --> 00:08:57,120
safari you have javascript core

263
00:08:53,920 --> 00:08:59,040
and for chrome we have v8 however the

264
00:08:57,120 --> 00:09:00,959
vulnerabilities exploited are very

265
00:08:59,040 --> 00:09:02,560
similar so for example

266
00:09:00,959 --> 00:09:05,040
uh if you have a type confusion

267
00:09:02,560 --> 00:09:07,359
vulnerability in javascript core

268
00:09:05,040 --> 00:09:08,240
the exploitation would be very similar

269
00:09:07,360 --> 00:09:10,160
to

270
00:09:08,240 --> 00:09:14,160
let's say attacking the same let's

271
00:09:10,160 --> 00:09:16,719
exploring the same vulnerability on v8

272
00:09:14,160 --> 00:09:18,480
so primitive types have uh immutable

273
00:09:16,720 --> 00:09:21,360
data types so they cannot be

274
00:09:18,480 --> 00:09:22,560
uh changed uh so there are six primitive

275
00:09:21,360 --> 00:09:25,680
types boolean

276
00:09:22,560 --> 00:09:26,719
null undefined number string and a

277
00:09:25,680 --> 00:09:29,519
symbol

278
00:09:26,720 --> 00:09:31,360
so a primitive is basically an object

279
00:09:29,519 --> 00:09:33,360
which has no methods of its own and

280
00:09:31,360 --> 00:09:35,200
they're also not mutable

281
00:09:33,360 --> 00:09:36,880
so these are the six types which are

282
00:09:35,200 --> 00:09:38,959
considered to be primitive

283
00:09:36,880 --> 00:09:39,920
then for object types object types are

284
00:09:38,959 --> 00:09:41,920
something that are

285
00:09:39,920 --> 00:09:43,279
mutable and their values can be changed

286
00:09:41,920 --> 00:09:45,519
after getting created

287
00:09:43,279 --> 00:09:48,000
so an example for an object types would

288
00:09:45,519 --> 00:09:49,600
be let's say an array

289
00:09:48,000 --> 00:09:51,440
the properties in javascript can be

290
00:09:49,600 --> 00:09:54,320
either indexed or named so

291
00:09:51,440 --> 00:09:56,399
if you want to find a fetch index

292
00:09:54,320 --> 00:09:58,399
property use the square brackets

293
00:09:56,399 --> 00:09:59,760
whereas to get a name property use the

294
00:09:58,399 --> 00:10:02,800
the dot sign

295
00:09:59,760 --> 00:10:05,760
so this is how you can fetch

296
00:10:02,800 --> 00:10:06,880
indexed versus name properties in

297
00:10:05,760 --> 00:10:09,600
javascript uh

298
00:10:06,880 --> 00:10:11,200
you have also have functions so in

299
00:10:09,600 --> 00:10:12,079
functions are considered as objects in

300
00:10:11,200 --> 00:10:14,000
javascript

301
00:10:12,079 --> 00:10:15,760
so which means you can assign functions

302
00:10:14,000 --> 00:10:16,720
to variables to an array element or to

303
00:10:15,760 --> 00:10:18,240
other objects

304
00:10:16,720 --> 00:10:20,240
they can also be passed around as

305
00:10:18,240 --> 00:10:22,240
arguments to different functions

306
00:10:20,240 --> 00:10:23,920
so i've given some examples on how you

307
00:10:22,240 --> 00:10:26,640
can use a function

308
00:10:23,920 --> 00:10:27,920
to pass it around as an object then we

309
00:10:26,640 --> 00:10:29,199
have something called function

310
00:10:27,920 --> 00:10:31,599
overriding

311
00:10:29,200 --> 00:10:32,800
which is basically overriding a specific

312
00:10:31,600 --> 00:10:35,680
function

313
00:10:32,800 --> 00:10:36,079
of an object so for example every object

314
00:10:35,680 --> 00:10:38,000
has

315
00:10:36,079 --> 00:10:39,680
a two-string function that can get

316
00:10:38,000 --> 00:10:40,560
invoked whenever it is being converted

317
00:10:39,680 --> 00:10:42,640
to a string

318
00:10:40,560 --> 00:10:44,399
for example if you're adding two strings

319
00:10:42,640 --> 00:10:46,720
and one of the

320
00:10:44,399 --> 00:10:48,800
the add one of the added values is a

321
00:10:46,720 --> 00:10:50,720
number then before addition the two

322
00:10:48,800 --> 00:10:52,399
string function will be called on that

323
00:10:50,720 --> 00:10:55,120
so you can overwrite that method by

324
00:10:52,399 --> 00:10:57,680
defining its own uh

325
00:10:55,120 --> 00:10:59,519
two string function uh and once the

326
00:10:57,680 --> 00:11:00,959
addition happens the tostring function

327
00:10:59,519 --> 00:11:02,480
will get invoked

328
00:11:00,959 --> 00:11:04,399
and whatever code you put inside that

329
00:11:02,480 --> 00:11:05,920
will be called okay

330
00:11:04,399 --> 00:11:08,959
so for example in this case we are

331
00:11:05,920 --> 00:11:11,920
overriding the tostring function of

332
00:11:08,959 --> 00:11:11,920
the dog object

333
00:11:12,240 --> 00:11:16,320
this is how do you debug a javascript

334
00:11:14,240 --> 00:11:18,800
code so debugging of javascript code can

335
00:11:16,320 --> 00:11:21,040
be done using either ltp or gdp

336
00:11:18,800 --> 00:11:22,479
depending on depending on which platform

337
00:11:21,040 --> 00:11:24,319
you're running it on

338
00:11:22,480 --> 00:11:25,920
um you can also set several environment

339
00:11:24,320 --> 00:11:26,880
variables that can help you in getting a

340
00:11:25,920 --> 00:11:29,199
lot of information

341
00:11:26,880 --> 00:11:31,040
as you can see in the image below so

342
00:11:29,200 --> 00:11:33,600
here are some examples on how you can

343
00:11:31,040 --> 00:11:37,279
debug javascript core

344
00:11:33,600 --> 00:11:39,839
using lldp on a linux machine

345
00:11:37,279 --> 00:11:40,720
now what is jsl so jsl is a simplex

346
00:11:39,839 --> 00:11:42,800
object class

347
00:11:40,720 --> 00:11:44,399
in javascript each object which is

348
00:11:42,800 --> 00:11:45,519
allocated through javascript is actually

349
00:11:44,399 --> 00:11:47,680
wrapped into a js

350
00:11:45,519 --> 00:11:49,040
cell structure there are eight bytes

351
00:11:47,680 --> 00:11:50,638
header for every object

352
00:11:49,040 --> 00:11:53,040
that denotes several properties about

353
00:11:50,639 --> 00:11:54,959
the object and why this is important

354
00:11:53,040 --> 00:11:56,480
from an exploitation point of view

355
00:11:54,959 --> 00:11:58,638
is that whenever you want to fake an

356
00:11:56,480 --> 00:12:01,920
object in javascript you need to add

357
00:11:58,639 --> 00:12:03,920
very valid headers right

358
00:12:01,920 --> 00:12:05,680
so one of the important things in the

359
00:12:03,920 --> 00:12:07,519
jsl header is the structure id which

360
00:12:05,680 --> 00:12:09,920
determines the index

361
00:12:07,519 --> 00:12:11,440
into a structured id table now why this

362
00:12:09,920 --> 00:12:13,040
is important is that whenever you want

363
00:12:11,440 --> 00:12:15,600
to fake an object you need to guess a

364
00:12:13,040 --> 00:12:18,959
valid structure id

365
00:12:15,600 --> 00:12:20,560
um and without guessing without

366
00:12:18,959 --> 00:12:22,479
guessing that valid structure id will

367
00:12:20,560 --> 00:12:25,279
not be able to create

368
00:12:22,480 --> 00:12:27,760
a fake object so in the old webkit the

369
00:12:25,279 --> 00:12:30,160
structure id used to be incremented uh

370
00:12:27,760 --> 00:12:30,800
by one whenever you add a new named

371
00:12:30,160 --> 00:12:32,719
property

372
00:12:30,800 --> 00:12:34,000
however and this was useful for several

373
00:12:32,720 --> 00:12:35,920
exploitations

374
00:12:34,000 --> 00:12:37,440
because you can just space spray certain

375
00:12:35,920 --> 00:12:38,479
properties and then guess a value

376
00:12:37,440 --> 00:12:40,880
structure id

377
00:12:38,480 --> 00:12:42,880
however with the new webkit there has

378
00:12:40,880 --> 00:12:44,160
been structure added randomness added to

379
00:12:42,880 --> 00:12:45,760
the webkit

380
00:12:44,160 --> 00:12:48,480
which means that the bottom seven bits

381
00:12:45,760 --> 00:12:50,720
of the structure id are now randomized

382
00:12:48,480 --> 00:12:52,320
now so now in order to create a valid

383
00:12:50,720 --> 00:12:54,720
fake object you must leak

384
00:12:52,320 --> 00:12:55,920
a js cell header using some kind of

385
00:12:54,720 --> 00:12:59,040
expert primitive

386
00:12:55,920 --> 00:13:03,279
and then use that to basically

387
00:12:59,040 --> 00:13:05,279
fake an object so nowadays as we discuss

388
00:13:03,279 --> 00:13:07,600
the structure ids and randomize and

389
00:13:05,279 --> 00:13:09,360
hence leaking the jsl header is

390
00:13:07,600 --> 00:13:10,959
important in creating valid fake objects

391
00:13:09,360 --> 00:13:13,200
so in this case you can see that you

392
00:13:10,959 --> 00:13:16,319
have an object called person

393
00:13:13,200 --> 00:13:17,519
and this the jsl header is located at

394
00:13:16,320 --> 00:13:19,279
this address

395
00:13:17,519 --> 00:13:20,639
so in this case you can see that the

396
00:13:19,279 --> 00:13:22,560
address of the object is

397
00:13:20,639 --> 00:13:24,800
four zero eight zero starts at four zero

398
00:13:22,560 --> 00:13:27,518
eight zero so the jst header comes at

399
00:13:24,800 --> 00:13:27,519
the very first

400
00:13:28,959 --> 00:13:32,560
and now you have certain indexing types

401
00:13:30,639 --> 00:13:34,320
for arrays as well so for example

402
00:13:32,560 --> 00:13:35,839
depending on what objects are present in

403
00:13:34,320 --> 00:13:36,880
the arrays there will be an indexing

404
00:13:35,839 --> 00:13:38,560
type for it

405
00:13:36,880 --> 00:13:41,040
so for example if you just create an

406
00:13:38,560 --> 00:13:42,719
empty object empty array the type would

407
00:13:41,040 --> 00:13:44,560
be arrayed with undecided

408
00:13:42,720 --> 00:13:46,240
if you have only integers it will be

409
00:13:44,560 --> 00:13:48,079
arrayed within 32

410
00:13:46,240 --> 00:13:49,519
if we have an integer and double it will

411
00:13:48,079 --> 00:13:51,279
be array with double

412
00:13:49,519 --> 00:13:53,040
if you push an object as well it will be

413
00:13:51,279 --> 00:13:56,480
arrayed with contiguous

414
00:13:53,040 --> 00:13:56,480
um yeah

415
00:13:56,800 --> 00:14:00,639
now coming to js value we already

416
00:13:58,639 --> 00:14:01,360
discussed what is jsl so what is a js

417
00:14:00,639 --> 00:14:04,079
value

418
00:14:01,360 --> 00:14:07,440
so many different kinds of values are

419
00:14:04,079 --> 00:14:10,479
handled by the class js value

420
00:14:07,440 --> 00:14:11,440
so if you look at the inside the file

421
00:14:10,480 --> 00:14:14,399
jsc

422
00:14:11,440 --> 00:14:16,240
js value.h inside the folder inside the

423
00:14:14,399 --> 00:14:18,880
webkit code you will identify

424
00:14:16,240 --> 00:14:20,399
a lot of different types of objects that

425
00:14:18,880 --> 00:14:24,240
it can handle so for example it can

426
00:14:20,399 --> 00:14:25,839
handle a pointer a double integer etc

427
00:14:24,240 --> 00:14:27,440
now how does it find out whether it's an

428
00:14:25,839 --> 00:14:29,600
integer pointer double

429
00:14:27,440 --> 00:14:31,199
the highest bits determine what of an

430
00:14:29,600 --> 00:14:33,040
object it is

431
00:14:31,199 --> 00:14:35,199
and this technique is called a nand

432
00:14:33,040 --> 00:14:37,040
boxing

433
00:14:35,199 --> 00:14:38,399
so you can see that a pointer will

434
00:14:37,040 --> 00:14:41,519
usually have uh

435
00:14:38,399 --> 00:14:44,560
the first four bytes

436
00:14:41,519 --> 00:14:45,279
set to all zeros right for integer it

437
00:14:44,560 --> 00:14:48,479
will be

438
00:14:45,279 --> 00:14:50,959
um all f's here anything in between will

439
00:14:48,480 --> 00:14:52,639
be a double

440
00:14:50,959 --> 00:14:55,040
now you can try it out yourself so for

441
00:14:52,639 --> 00:14:57,360
example um in this case we are creating

442
00:14:55,040 --> 00:15:00,560
an array with certain objects right

443
00:14:57,360 --> 00:15:02,079
and we will look at the address of the

444
00:15:00,560 --> 00:15:03,119
butterfly now what is a butterfly we'll

445
00:15:02,079 --> 00:15:04,399
look into it later

446
00:15:03,120 --> 00:15:06,320
but what we're doing here is that we're

447
00:15:04,399 --> 00:15:07,120
examining the memory starting from the

448
00:15:06,320 --> 00:15:09,519
object

449
00:15:07,120 --> 00:15:10,320
and now the first value is actually all

450
00:15:09,519 --> 00:15:12,480
f's in the

451
00:15:10,320 --> 00:15:14,240
beginning which means it's an integer

452
00:15:12,480 --> 00:15:17,440
and the value is one

453
00:15:14,240 --> 00:15:20,320
okay and similarly by following the the

454
00:15:17,440 --> 00:15:21,519
method the description provided here you

455
00:15:20,320 --> 00:15:23,360
can find out

456
00:15:21,519 --> 00:15:25,440
that this is a pointer to the string

457
00:15:23,360 --> 00:15:27,279
because as we discussed

458
00:15:25,440 --> 00:15:29,600
if there is a string then it will be

459
00:15:27,279 --> 00:15:31,120
stored as a pointer and the pointer

460
00:15:29,600 --> 00:15:33,839
usually has

461
00:15:31,120 --> 00:15:34,240
the first four bits set to zero right so

462
00:15:33,839 --> 00:15:37,839
if

463
00:15:34,240 --> 00:15:37,839
this is actually a pointer to the string

464
00:15:37,920 --> 00:15:41,759
and similarly you have the float which

465
00:15:39,839 --> 00:15:43,759
is as we discussed previously stored as

466
00:15:41,759 --> 00:15:46,639
unsigned long long int

467
00:15:43,759 --> 00:15:48,639
um and then we have specific values for

468
00:15:46,639 --> 00:15:49,600
a boolean statement so for example false

469
00:15:48,639 --> 00:15:51,759
is six

470
00:15:49,600 --> 00:15:53,360
you can also see over here that false is

471
00:15:51,759 --> 00:15:55,759
stored as six and true is stored as

472
00:15:53,360 --> 00:15:58,800
seven

473
00:15:55,759 --> 00:16:01,440
every object in javascript core is

474
00:15:58,800 --> 00:16:03,120
a js object in a way it has a mandatory

475
00:16:01,440 --> 00:16:06,079
a butterfly pointer

476
00:16:03,120 --> 00:16:07,920
and can also store inline properties so

477
00:16:06,079 --> 00:16:09,040
as we discussed before that we can use

478
00:16:07,920 --> 00:16:11,920
the describe

479
00:16:09,040 --> 00:16:12,719
function to find out the address of an

480
00:16:11,920 --> 00:16:14,479
object

481
00:16:12,720 --> 00:16:16,959
just next to it lies the butterfly

482
00:16:14,480 --> 00:16:18,320
address which points to a memory region

483
00:16:16,959 --> 00:16:20,839
and to the right of the memory region

484
00:16:18,320 --> 00:16:22,000
are the elements and to the left are the

485
00:16:20,839 --> 00:16:23,279
properties

486
00:16:22,000 --> 00:16:25,040
just before the properties you have

487
00:16:23,279 --> 00:16:26,880
something called a called the length

488
00:16:25,040 --> 00:16:29,040
which stores the public and the vector

489
00:16:26,880 --> 00:16:30,880
length of the object

490
00:16:29,040 --> 00:16:32,079
so you can try it out write it out

491
00:16:30,880 --> 00:16:34,720
yourself um

492
00:16:32,079 --> 00:16:37,040
see how you can define an object a and

493
00:16:34,720 --> 00:16:39,040
you can assign some um

494
00:16:37,040 --> 00:16:40,880
name properties to it and when you go to

495
00:16:39,040 --> 00:16:43,680
the butterfly address which is

496
00:16:40,880 --> 00:16:45,839
um four zero two eight so if you go to

497
00:16:43,680 --> 00:16:48,000
the four zero to it you will see just

498
00:16:45,839 --> 00:16:49,040
on the left of it it's the public and

499
00:16:48,000 --> 00:16:51,120
the vector length

500
00:16:49,040 --> 00:16:52,639
and then to the left of that is the

501
00:16:51,120 --> 00:16:55,680
first property which is 4 and

502
00:16:52,639 --> 00:16:57,600
the right of that is 5 now to the right

503
00:16:55,680 --> 00:16:59,279
of the butterfly is

504
00:16:57,600 --> 00:17:01,839
the elements which were stored

505
00:16:59,279 --> 00:17:01,839
previously

506
00:17:02,000 --> 00:17:05,359
now if there are no index properties uh

507
00:17:04,480 --> 00:17:08,319
in an object

508
00:17:05,359 --> 00:17:10,000
then the the values are stored in line

509
00:17:08,319 --> 00:17:11,760
for example in this case it's an empty

510
00:17:10,000 --> 00:17:12,400
array it has doesn't have any index

511
00:17:11,760 --> 00:17:15,119
property

512
00:17:12,400 --> 00:17:17,039
it only has name properties then the

513
00:17:15,119 --> 00:17:18,000
values are stored just to the right of

514
00:17:17,039 --> 00:17:20,879
the object

515
00:17:18,000 --> 00:17:21,839
so in this case the address is 4080

516
00:17:20,880 --> 00:17:23,600
which points here

517
00:17:21,839 --> 00:17:24,879
now this thing the first thing is the

518
00:17:23,599 --> 00:17:26,719
jsl header

519
00:17:24,880 --> 00:17:29,280
followed by the butterfly which is

520
00:17:26,720 --> 00:17:31,120
nothing so in case there are no

521
00:17:29,280 --> 00:17:32,720
index properties then the butterfly is

522
00:17:31,120 --> 00:17:35,039
zero right

523
00:17:32,720 --> 00:17:35,840
followed by the value one and two which

524
00:17:35,039 --> 00:17:38,400
are

525
00:17:35,840 --> 00:17:39,120
um then the the named properties for

526
00:17:38,400 --> 00:17:41,520
that array

527
00:17:39,120 --> 00:17:42,879
okay another thing you need to note is

528
00:17:41,520 --> 00:17:44,400
boxed and unboxed

529
00:17:42,880 --> 00:17:46,400
array so the unboxed arrays are

530
00:17:44,400 --> 00:17:48,160
basically

531
00:17:46,400 --> 00:17:49,520
arrays that only contain double values

532
00:17:48,160 --> 00:17:51,600
whereas the box one are

533
00:17:49,520 --> 00:17:54,160
one which contain double as well as

534
00:17:51,600 --> 00:17:55,840
object what you need to know is that

535
00:17:54,160 --> 00:17:58,880
in case it's an array with contiguous

536
00:17:55,840 --> 00:18:01,199
which means it's a boxed array

537
00:17:58,880 --> 00:18:03,520
the value of this particular value is

538
00:18:01,200 --> 00:18:07,440
added to the double

539
00:18:03,520 --> 00:18:10,000
we can also see that over here

540
00:18:07,440 --> 00:18:11,600
you can see that a 64 bit integer

541
00:18:10,000 --> 00:18:14,240
addition of the value to the 12

542
00:18:11,600 --> 00:18:15,918
or 48 is added to the number okay in

543
00:18:14,240 --> 00:18:17,200
case this is a js object which

544
00:18:15,919 --> 00:18:19,120
which means it's an array with

545
00:18:17,200 --> 00:18:20,640
contiguous okay

546
00:18:19,120 --> 00:18:22,559
now let's discuss what is a compiler

547
00:18:20,640 --> 00:18:24,480
versus interpreter so interpreter is

548
00:18:22,559 --> 00:18:25,520
quick to get up and running and

549
00:18:24,480 --> 00:18:27,280
since we don't need to do any

550
00:18:25,520 --> 00:18:29,280
compilations however if you have code

551
00:18:27,280 --> 00:18:31,120
which is repeated several times

552
00:18:29,280 --> 00:18:33,280
you still need to interpret it every

553
00:18:31,120 --> 00:18:36,479
time and that will cause some kind of

554
00:18:33,280 --> 00:18:38,559
delay it's suitable for javascript since

555
00:18:36,480 --> 00:18:40,960
it provides on-the-fly translation

556
00:18:38,559 --> 00:18:42,559
whereas a compiler takes time initially

557
00:18:40,960 --> 00:18:44,080
to go to the compilation

558
00:18:42,559 --> 00:18:45,600
during the compilation it makes certain

559
00:18:44,080 --> 00:18:47,439
optimizations to improve

560
00:18:45,600 --> 00:18:49,199
the performance and this is suitable for

561
00:18:47,440 --> 00:18:50,240
repeated runs of the same code core you

562
00:18:49,200 --> 00:18:52,640
have a 32

563
00:18:50,240 --> 00:18:54,080
mb you read executable jit region and

564
00:18:52,640 --> 00:18:57,120
there are several types of execution

565
00:18:54,080 --> 00:18:57,840
when you want to execute javascript code

566
00:18:57,120 --> 00:18:59,199
the first one

567
00:18:57,840 --> 00:19:00,879
the only the first one is the

568
00:18:59,200 --> 00:19:03,600
interpreted one the all

569
00:19:00,880 --> 00:19:05,440
the other three ones are compilation so

570
00:19:03,600 --> 00:19:06,399
what is jit what does justin time

571
00:19:05,440 --> 00:19:08,400
compilation means

572
00:19:06,400 --> 00:19:10,080
so just in time compilation means the

573
00:19:08,400 --> 00:19:12,720
compilation happens during runtime

574
00:19:10,080 --> 00:19:14,559
rather than prior what the way it works

575
00:19:12,720 --> 00:19:16,320
is that the javascript bytecode is

576
00:19:14,559 --> 00:19:17,200
compiled into machine code by the jit

577
00:19:16,320 --> 00:19:18,720
compiler

578
00:19:17,200 --> 00:19:20,640
and then later executed by the

579
00:19:18,720 --> 00:19:22,160
javascript virtual machine or the java

580
00:19:20,640 --> 00:19:23,919
virtual machine sorry

581
00:19:22,160 --> 00:19:26,640
the code is monitored as it's running

582
00:19:23,919 --> 00:19:28,160
and uh and it sends the hard codes pass

583
00:19:26,640 --> 00:19:31,039
to be optimized

584
00:19:28,160 --> 00:19:33,280
so what this means is that if a function

585
00:19:31,039 --> 00:19:35,840
is executing several times

586
00:19:33,280 --> 00:19:37,520
that will be sent for optimization and

587
00:19:35,840 --> 00:19:38,720
the kind of optimization depends on the

588
00:19:37,520 --> 00:19:40,480
tire of execution

589
00:19:38,720 --> 00:19:41,760
so there are the four different tires of

590
00:19:40,480 --> 00:19:44,320
execution and

591
00:19:41,760 --> 00:19:45,440
higher the tire the higher the compile

592
00:19:44,320 --> 00:19:47,678
time

593
00:19:45,440 --> 00:19:49,280
however the best throughput would be

594
00:19:47,679 --> 00:19:50,559
achieved with that so for example if we

595
00:19:49,280 --> 00:19:51,678
have a function which is getting

596
00:19:50,559 --> 00:19:53,440
executed

597
00:19:51,679 --> 00:19:55,120
let's say 100 or 200 times it might be

598
00:19:53,440 --> 00:19:58,000
sent to tyre too

599
00:19:55,120 --> 00:19:59,678
and but if it's not executing 1000 times

600
00:19:58,000 --> 00:20:00,960
it needs more optimization it will be

601
00:19:59,679 --> 00:20:03,840
sent for tire 3

602
00:20:00,960 --> 00:20:06,480
and for more it will be sent for tire 4

603
00:20:03,840 --> 00:20:08,000
so the higher the tire is

604
00:20:06,480 --> 00:20:10,000
the higher will be the compile time

605
00:20:08,000 --> 00:20:12,559
because the javascript core will try to

606
00:20:10,000 --> 00:20:14,080
do as many optimizations on it as it can

607
00:20:12,559 --> 00:20:16,240
however in the end it will lead to the

608
00:20:14,080 --> 00:20:18,240
best throughput

609
00:20:16,240 --> 00:20:19,280
the way the optimization work is one of

610
00:20:18,240 --> 00:20:21,200
the ways is that

611
00:20:19,280 --> 00:20:23,039
it works is that it can it starts to

612
00:20:21,200 --> 00:20:24,640
guess the types of the object

613
00:20:23,039 --> 00:20:26,080
uh so for example if there's an array

614
00:20:24,640 --> 00:20:29,200
which is getting called which has

615
00:20:26,080 --> 00:20:29,600
uh let's say a string then and which and

616
00:20:29,200 --> 00:20:32,159
it's

617
00:20:29,600 --> 00:20:34,080
concatenating some other string then

618
00:20:32,159 --> 00:20:36,720
javascript code will not check

619
00:20:34,080 --> 00:20:37,520
um let's say remove the type checks for

620
00:20:36,720 --> 00:20:39,120
that string

621
00:20:37,520 --> 00:20:40,559
right so it will just assume whatever

622
00:20:39,120 --> 00:20:42,559
input it gets is a string

623
00:20:40,559 --> 00:20:43,918
so it's in a way assuming the type of

624
00:20:42,559 --> 00:20:46,320
that object

625
00:20:43,919 --> 00:20:48,159
now since it's now removing the check

626
00:20:46,320 --> 00:20:49,678
for that specific type this can cause

627
00:20:48,159 --> 00:20:51,440
several security issues

628
00:20:49,679 --> 00:20:52,799
and it gives to rise to a specific

629
00:20:51,440 --> 00:20:54,720
category of vulnerability which is

630
00:20:52,799 --> 00:20:57,280
called type confusion

631
00:20:54,720 --> 00:20:58,159
okay however in order to optimize the

632
00:20:57,280 --> 00:20:59,840
code

633
00:20:58,159 --> 00:21:01,200
uh since we discussed there are several

634
00:20:59,840 --> 00:21:03,840
assumptions which are being made

635
00:21:01,200 --> 00:21:05,760
right such as let's say assuming types

636
00:21:03,840 --> 00:21:08,799
are in also certain cases removing

637
00:21:05,760 --> 00:21:10,640
bound checks okay this but these actions

638
00:21:08,799 --> 00:21:12,320
can be potentially dangerous and change

639
00:21:10,640 --> 00:21:15,360
the program state

640
00:21:12,320 --> 00:21:17,200
um and the jet code might use the code

641
00:21:15,360 --> 00:21:19,280
without checking the type of the object

642
00:21:17,200 --> 00:21:20,640
which might give rise to several type

643
00:21:19,280 --> 00:21:22,399
confusion vulnerabilities

644
00:21:20,640 --> 00:21:24,400
this kind of an effect is called a side

645
00:21:22,400 --> 00:21:27,200
effect because it's a side effect

646
00:21:24,400 --> 00:21:28,880
of optimizing the code however the

647
00:21:27,200 --> 00:21:30,480
webkit developers are aware about these

648
00:21:28,880 --> 00:21:33,360
kind of issues

649
00:21:30,480 --> 00:21:34,320
and they can break these assumptions

650
00:21:33,360 --> 00:21:37,678
using

651
00:21:34,320 --> 00:21:39,840
several operations right so

652
00:21:37,679 --> 00:21:41,280
assuming certain things are valid or

653
00:21:39,840 --> 00:21:44,080
some things happen

654
00:21:41,280 --> 00:21:45,760
which are not expected the javascript

655
00:21:44,080 --> 00:21:47,120
developers have written code that will

656
00:21:45,760 --> 00:21:51,679
break the assumptions

657
00:21:47,120 --> 00:21:51,678
and throw it back to tire one okay

658
00:21:52,240 --> 00:21:55,679
so for example if there's a dangerous

659
00:21:53,679 --> 00:21:57,679
operation which is happening

660
00:21:55,679 --> 00:21:59,280
the execution will remove all the

661
00:21:57,679 --> 00:22:00,640
assumptions made and it would cause

662
00:21:59,280 --> 00:22:03,280
something called a bailout

663
00:22:00,640 --> 00:22:05,679
okay and the bailout is usually done by

664
00:22:03,280 --> 00:22:07,440
calling a function named clobberworld

665
00:22:05,679 --> 00:22:09,120
this breaks all the assumptions which

666
00:22:07,440 --> 00:22:11,200
are made by the compiler

667
00:22:09,120 --> 00:22:13,439
and the execution is now switching from

668
00:22:11,200 --> 00:22:15,600
the compiled code to interpreted code

669
00:22:13,440 --> 00:22:17,280
so you can see examples of clover world

670
00:22:15,600 --> 00:22:18,879
in several places in the webkit source

671
00:22:17,280 --> 00:22:22,320
code

672
00:22:18,880 --> 00:22:22,320
this is an example of

673
00:22:22,720 --> 00:22:26,559
the different jit tires so what you can

674
00:22:24,559 --> 00:22:30,000
do is that you can

675
00:22:26,559 --> 00:22:31,600
attach ldb to javascript code

676
00:22:30,000 --> 00:22:33,280
then you can set this particular

677
00:22:31,600 --> 00:22:35,719
environment variable to true

678
00:22:33,280 --> 00:22:37,918
and then you can have a files let's say

679
00:22:35,720 --> 00:22:40,799
jitters.js which would have a specific

680
00:22:37,919 --> 00:22:42,640
for loop now what you need to do is that

681
00:22:40,799 --> 00:22:44,559
just change the counter on the for loop

682
00:22:42,640 --> 00:22:48,159
from 100 to 1000

683
00:22:44,559 --> 00:22:50,158
and then 1000 to 10 000 right

684
00:22:48,159 --> 00:22:51,600
and then see what the output is so you

685
00:22:50,159 --> 00:22:53,840
will see that it's switching

686
00:22:51,600 --> 00:22:56,399
the the tire levels as you increase the

687
00:22:53,840 --> 00:22:58,158
name of the number of the counters

688
00:22:56,400 --> 00:23:00,240
now what is web code so the web code

689
00:22:58,159 --> 00:23:01,440
webcore is responsible for laying out

690
00:23:00,240 --> 00:23:04,400
rendering

691
00:23:01,440 --> 00:23:06,159
um and displaying the html and svg

692
00:23:04,400 --> 00:23:07,919
content on the browser right

693
00:23:06,159 --> 00:23:09,200
then in the past there have been several

694
00:23:07,919 --> 00:23:12,320
rc's um

695
00:23:09,200 --> 00:23:14,000
on or because of use after free

696
00:23:12,320 --> 00:23:16,000
vulnerabilities in the dom

697
00:23:14,000 --> 00:23:17,520
uh one of the reasons for this is

698
00:23:16,000 --> 00:23:19,039
reference counting bugs where you are

699
00:23:17,520 --> 00:23:20,400
able to decrease the reference count of

700
00:23:19,039 --> 00:23:21,919
an object to zero

701
00:23:20,400 --> 00:23:23,600
and then trigger a callback to that

702
00:23:21,919 --> 00:23:25,280
particular object which will cause a use

703
00:23:23,600 --> 00:23:26,879
after frame

704
00:23:25,280 --> 00:23:29,200
the way the exploitation usually happens

705
00:23:26,880 --> 00:23:31,280
is by saving a reference on the stack

706
00:23:29,200 --> 00:23:33,200
uh triggering a callback a javascript

707
00:23:31,280 --> 00:23:35,760
callback to drop the reference

708
00:23:33,200 --> 00:23:37,280
and then using that same reference to

709
00:23:35,760 --> 00:23:40,000
cause i use after free

710
00:23:37,280 --> 00:23:42,158
however in the past there have been some

711
00:23:40,000 --> 00:23:45,279
recent mitigations which have made

712
00:23:42,159 --> 00:23:45,679
exploiting such bugs much harder so some

713
00:23:45,279 --> 00:23:47,039
of the

714
00:23:45,679 --> 00:23:49,279
recent mitigations which have been

715
00:23:47,039 --> 00:23:52,799
implemented in webkit are iso heaps

716
00:23:49,279 --> 00:23:54,480
giga cage bulletproof jeep which is only

717
00:23:52,799 --> 00:23:56,000
applicable for ios

718
00:23:54,480 --> 00:23:57,200
then you have structure added randomness

719
00:23:56,000 --> 00:23:58,159
and you have pack which is pointer

720
00:23:57,200 --> 00:24:01,679
authentication check

721
00:23:58,159 --> 00:24:03,840
again only for ios devices so the idea

722
00:24:01,679 --> 00:24:06,159
for iso heaps is that

723
00:24:03,840 --> 00:24:07,760
the idea is to provide separate heaps

724
00:24:06,159 --> 00:24:09,279
for different kinds of objects

725
00:24:07,760 --> 00:24:11,039
because the way they use after free

726
00:24:09,279 --> 00:24:13,360
exploits work is that you are able to

727
00:24:11,039 --> 00:24:15,440
free an object and then overwrite it

728
00:24:13,360 --> 00:24:16,879
with another object of different type

729
00:24:15,440 --> 00:24:17,600
right which will allow you to do certain

730
00:24:16,880 --> 00:24:20,559
things

731
00:24:17,600 --> 00:24:21,360
however if objects of the same type are

732
00:24:20,559 --> 00:24:23,520
saved in

733
00:24:21,360 --> 00:24:24,639
separate heaps this becomes much more

734
00:24:23,520 --> 00:24:26,799
difficult

735
00:24:24,640 --> 00:24:29,120
so in this case you can see that there's

736
00:24:26,799 --> 00:24:29,520
an iso heap being created for the object

737
00:24:29,120 --> 00:24:33,199
type

738
00:24:29,520 --> 00:24:34,960
svg element okay next we have giga gauge

739
00:24:33,200 --> 00:24:38,080
type which basically prevents um

740
00:24:34,960 --> 00:24:40,080
out of bond access um

741
00:24:38,080 --> 00:24:41,678
so it will basically prevent you from

742
00:24:40,080 --> 00:24:43,279
out of bond access vulnerabilities and

743
00:24:41,679 --> 00:24:45,520
the way it works is that

744
00:24:43,279 --> 00:24:47,440
different objects are caged and they're

745
00:24:45,520 --> 00:24:48,158
caged between something which we call

746
00:24:47,440 --> 00:24:50,480
runway

747
00:24:48,159 --> 00:24:52,159
now the runway the size of the runway is

748
00:24:50,480 --> 00:24:54,559
the maximum value

749
00:24:52,159 --> 00:24:56,159
of an integer which is 32 bits what this

750
00:24:54,559 --> 00:24:58,960
means is that even if we have an

751
00:24:56,159 --> 00:24:59,600
out of bounds array access the maximum

752
00:24:58,960 --> 00:25:02,320
value of

753
00:24:59,600 --> 00:25:04,639
the integer in the array or the index in

754
00:25:02,320 --> 00:25:06,720
in the array can be 32 bits right

755
00:25:04,640 --> 00:25:08,480
so even if you can put a very big value

756
00:25:06,720 --> 00:25:11,520
on it it will most likely end up

757
00:25:08,480 --> 00:25:14,720
in the runway between those two objects

758
00:25:11,520 --> 00:25:16,720
okay so you can see um

759
00:25:14,720 --> 00:25:18,080
several examples of different kinds of

760
00:25:16,720 --> 00:25:19,919
giga cages here

761
00:25:18,080 --> 00:25:21,120
so in this case the primitive giga cage

762
00:25:19,919 --> 00:25:23,120
is used for

763
00:25:21,120 --> 00:25:24,959
uh the primitive objects the js value

764
00:25:23,120 --> 00:25:27,039
gear cage is used for js value objects

765
00:25:24,960 --> 00:25:30,799
and so on signing is relaxed

766
00:25:27,039 --> 00:25:32,080
for in ios the code signing is relaxed

767
00:25:30,799 --> 00:25:33,520
for webkit by using

768
00:25:32,080 --> 00:25:36,320
the dynamic hyphen code signing

769
00:25:33,520 --> 00:25:37,120
entitlement which means that the code

770
00:25:36,320 --> 00:25:38,799
can

771
00:25:37,120 --> 00:25:40,399
read and write in the same memory region

772
00:25:38,799 --> 00:25:41,039
rewrite and execute on the same memory

773
00:25:40,400 --> 00:25:42,559
region

774
00:25:41,039 --> 00:25:44,000
so the previous exploit what they used

775
00:25:42,559 --> 00:25:45,120
to do is that they used to write the

776
00:25:44,000 --> 00:25:47,200
shell code

777
00:25:45,120 --> 00:25:49,360
using the initial write primitive that

778
00:25:47,200 --> 00:25:50,400
they get and then just jump to the cell

779
00:25:49,360 --> 00:25:53,120
code

780
00:25:50,400 --> 00:25:54,640
however in safari it does not host the

781
00:25:53,120 --> 00:25:56,479
javascript engine rather

782
00:25:54,640 --> 00:25:58,480
as we discussed previously the

783
00:25:56,480 --> 00:26:00,240
javascript engine is run in a separate

784
00:25:58,480 --> 00:26:02,400
web content process

785
00:26:00,240 --> 00:26:04,159
in arm v8 it introduced support for

786
00:26:02,400 --> 00:26:05,120
something called execute only memory

787
00:26:04,159 --> 00:26:06,880
protection

788
00:26:05,120 --> 00:26:08,639
which means on certain memory mappings

789
00:26:06,880 --> 00:26:10,640
the processor can execute

790
00:26:08,640 --> 00:26:12,240
but cannot read and this was used to

791
00:26:10,640 --> 00:26:13,840
implement hardened webkit

792
00:26:12,240 --> 00:26:15,360
however before discussing that let's

793
00:26:13,840 --> 00:26:17,600
discuss what is a mem copy

794
00:26:15,360 --> 00:26:18,959
so in map copy the first argument is the

795
00:26:17,600 --> 00:26:20,320
destination which is the pointer to the

796
00:26:18,960 --> 00:26:23,279
destination array

797
00:26:20,320 --> 00:26:24,000
where the content is to be copied then

798
00:26:23,279 --> 00:26:25,440
you have the source

799
00:26:24,000 --> 00:26:27,279
which is the pointer to the source of

800
00:26:25,440 --> 00:26:28,480
the data to be copied followed by the

801
00:26:27,279 --> 00:26:29,919
third argument which is

802
00:26:28,480 --> 00:26:31,679
number which is the number of bytes to

803
00:26:29,919 --> 00:26:34,640
copy right so the

804
00:26:31,679 --> 00:26:36,480
idea of hardened hard end webkit is that

805
00:26:34,640 --> 00:26:38,240
you are kind of creating two virtual

806
00:26:36,480 --> 00:26:40,000
mappings of the same memory

807
00:26:38,240 --> 00:26:42,240
one of them is executable and the other

808
00:26:40,000 --> 00:26:44,080
one is writable right

809
00:26:42,240 --> 00:26:45,840
and the writeable mapping to the jet

810
00:26:44,080 --> 00:26:48,879
region is

811
00:26:45,840 --> 00:26:49,439
randomly located okay now what happens

812
00:26:48,880 --> 00:26:52,080
is that

813
00:26:49,440 --> 00:26:53,600
uh javascript core will exec emit a

814
00:26:52,080 --> 00:26:55,520
specialized mem copy

815
00:26:53,600 --> 00:26:57,199
and this in this mem copy the base

816
00:26:55,520 --> 00:27:00,158
destination address will be

817
00:26:57,200 --> 00:27:03,200
already hard coded okay and then this

818
00:27:00,159 --> 00:27:05,120
mem copy would be made as execute only

819
00:27:03,200 --> 00:27:07,279
and this specialized mem copy will now

820
00:27:05,120 --> 00:27:10,799
be used for all jit right operations

821
00:27:07,279 --> 00:27:13,919
right so there's only a specific special

822
00:27:10,799 --> 00:27:15,039
jet mem copy function which will be

823
00:27:13,919 --> 00:27:17,919
executed

824
00:27:15,039 --> 00:27:18,960
okay now this means that an attacker

825
00:27:17,919 --> 00:27:21,679
cannot copy

826
00:27:18,960 --> 00:27:23,919
uh just call the mem copy function

827
00:27:21,679 --> 00:27:27,279
through its code it needs to call

828
00:27:23,919 --> 00:27:28,640
that specific mem copy okay now this can

829
00:27:27,279 --> 00:27:30,720
be mitigated using

830
00:27:28,640 --> 00:27:32,399
uh as you've already guessed rob attacks

831
00:27:30,720 --> 00:27:36,000
which is returned oriented programming

832
00:27:32,399 --> 00:27:38,639
right and this was in a way an early um

833
00:27:36,000 --> 00:27:40,480
in a way this mitigation is useless uh

834
00:27:38,640 --> 00:27:41,440
unless there is like a control flow

835
00:27:40,480 --> 00:27:43,440
integrity

836
00:27:41,440 --> 00:27:45,360
present in there and this was like an

837
00:27:43,440 --> 00:27:49,760
early warning for the attackers that

838
00:27:45,360 --> 00:27:52,240
control flow integrity is coming right

839
00:27:49,760 --> 00:27:54,320
so this is some code uh that is used to

840
00:27:52,240 --> 00:27:55,760
implement uh to basically emit that

841
00:27:54,320 --> 00:27:57,520
specialized mem copy

842
00:27:55,760 --> 00:28:00,000
i would highly recommend that you check

843
00:27:57,520 --> 00:28:02,799
out e1 christic stock in black hat

844
00:28:00,000 --> 00:28:04,080
on the link below however in the recent

845
00:28:02,799 --> 00:28:06,799
webkit versions it was

846
00:28:04,080 --> 00:28:08,399
replaced by aprr and pack which is

847
00:28:06,799 --> 00:28:10,320
pointer authentication checks i would

848
00:28:08,399 --> 00:28:13,520
recommend you check out this talk again

849
00:28:10,320 --> 00:28:15,439
uh from blackhead 2019. okay

850
00:28:13,520 --> 00:28:17,039
so what is a what is an excellent

851
00:28:15,440 --> 00:28:18,080
primitive so in computer science a

852
00:28:17,039 --> 00:28:20,320
primitive

853
00:28:18,080 --> 00:28:21,279
is a fundamental data type that cannot

854
00:28:20,320 --> 00:28:23,360
be broken down

855
00:28:21,279 --> 00:28:24,320
into let's say more simpler data types

856
00:28:23,360 --> 00:28:27,360
right

857
00:28:24,320 --> 00:28:29,360
uh so the idea here is a primitive

858
00:28:27,360 --> 00:28:31,520
is something that lets you achieve one

859
00:28:29,360 --> 00:28:35,360
particular task and nothing less

860
00:28:31,520 --> 00:28:38,559
okay and nothing more um

861
00:28:35,360 --> 00:28:40,240
so in this case uh you need to

862
00:28:38,559 --> 00:28:41,600
break down the exploitation strategies

863
00:28:40,240 --> 00:28:43,919
into different steps

864
00:28:41,600 --> 00:28:46,158
which we call exploit primitives right

865
00:28:43,919 --> 00:28:48,000
so the first exploit primitive is that

866
00:28:46,159 --> 00:28:49,679
you need to achieve something called an

867
00:28:48,000 --> 00:28:51,600
address of primitive

868
00:28:49,679 --> 00:28:55,120
then you need to achieve the fake object

869
00:28:51,600 --> 00:28:56,959
primitive after that you need to achieve

870
00:28:55,120 --> 00:28:59,039
the read write arbitrary read write

871
00:28:56,960 --> 00:29:01,760
primitive followed by let's say a

872
00:28:59,039 --> 00:29:03,360
universal exercise or a sandbox escape

873
00:29:01,760 --> 00:29:05,120
let's say if you want to get the data

874
00:29:03,360 --> 00:29:06,479
from other tabs you will probably do a

875
00:29:05,120 --> 00:29:08,320
universal exercise

876
00:29:06,480 --> 00:29:09,760
however if you want to execute code on

877
00:29:08,320 --> 00:29:11,120
the victim's device you will be doing

878
00:29:09,760 --> 00:29:13,600
sandbox escape

879
00:29:11,120 --> 00:29:14,799
and then finally go to code execution

880
00:29:13,600 --> 00:29:16,639
okay

881
00:29:14,799 --> 00:29:18,399
now what are address often fake object

882
00:29:16,640 --> 00:29:20,399
primitives so

883
00:29:18,399 --> 00:29:22,399
the address of primitive allows you to

884
00:29:20,399 --> 00:29:24,158
find out the address of an object

885
00:29:22,399 --> 00:29:26,080
the way it works is that whenever you

886
00:29:24,159 --> 00:29:28,880
store a js object value

887
00:29:26,080 --> 00:29:30,480
it is stored as a js value as we

888
00:29:28,880 --> 00:29:31,600
discussed so what it stores is that it

889
00:29:30,480 --> 00:29:33,440
stores

890
00:29:31,600 --> 00:29:34,879
uh the address to that object as a

891
00:29:33,440 --> 00:29:37,200
pointer okay

892
00:29:34,880 --> 00:29:39,039
now let's assume that you kind of cause

893
00:29:37,200 --> 00:29:41,360
a type confusion vulnerability

894
00:29:39,039 --> 00:29:42,960
and now this pointer is interpreted as a

895
00:29:41,360 --> 00:29:45,360
double now using

896
00:29:42,960 --> 00:29:46,799
by reading that property if you read

897
00:29:45,360 --> 00:29:48,799
that property as a double

898
00:29:46,799 --> 00:29:50,080
uh you will be able to read this pointer

899
00:29:48,799 --> 00:29:53,120
value right so

900
00:29:50,080 --> 00:29:55,678
in a way able to find out the address of

901
00:29:53,120 --> 00:29:57,199
a particular object and this is the

902
00:29:55,679 --> 00:29:59,039
address of primitive

903
00:29:57,200 --> 00:30:01,360
similarly if you think about the

904
00:29:59,039 --> 00:30:03,840
opposite of this is the fake object

905
00:30:01,360 --> 00:30:05,918
we are able to write a native devil

906
00:30:03,840 --> 00:30:06,959
which is then interpreted as an object

907
00:30:05,919 --> 00:30:08,720
as a pointer

908
00:30:06,960 --> 00:30:11,840
using another using the same type

909
00:30:08,720 --> 00:30:11,840
confusion vulnerability

910
00:30:11,919 --> 00:30:15,039
when you're writing let's say a native

911
00:30:14,240 --> 00:30:17,039
double

912
00:30:15,039 --> 00:30:18,559
which is being interpreted as a js value

913
00:30:17,039 --> 00:30:21,360
you need to make sure

914
00:30:18,559 --> 00:30:22,639
that the double value is actually

915
00:30:21,360 --> 00:30:25,760
interpreted as a proper

916
00:30:22,640 --> 00:30:27,919
object so for example we discuss that

917
00:30:25,760 --> 00:30:28,879
the first eight bytes of the object are

918
00:30:27,919 --> 00:30:30,559
the headers

919
00:30:28,880 --> 00:30:32,159
so when you're writing a native double

920
00:30:30,559 --> 00:30:34,960
in your exploit you need to make sure

921
00:30:32,159 --> 00:30:36,880
they are valid headers right one of the

922
00:30:34,960 --> 00:30:38,159
important things in the header was the

923
00:30:36,880 --> 00:30:40,399
structure id

924
00:30:38,159 --> 00:30:41,919
so you need to add a varied structure id

925
00:30:40,399 --> 00:30:42,479
so you cannot just write any native

926
00:30:41,919 --> 00:30:44,559
double

927
00:30:42,480 --> 00:30:46,880
you need to have specific headers and

928
00:30:44,559 --> 00:30:47,918
then based on what butterfly you want to

929
00:30:46,880 --> 00:30:51,600
add or bait

930
00:30:47,919 --> 00:30:51,919
what um values you want to add you will

931
00:30:51,600 --> 00:30:54,719
add

932
00:30:51,919 --> 00:30:55,279
specific doubles related to that right

933
00:30:54,720 --> 00:30:57,360
one thing

934
00:30:55,279 --> 00:30:59,919
one important thing which which i forgot

935
00:30:57,360 --> 00:31:03,199
to mention is that

936
00:30:59,919 --> 00:31:05,360
let's go back to the butterfly slides

937
00:31:03,200 --> 00:31:06,720
is that one of the most important things

938
00:31:05,360 --> 00:31:09,760
in an exploit

939
00:31:06,720 --> 00:31:11,039
is being able to manipulate the

940
00:31:09,760 --> 00:31:13,039
butterfly address

941
00:31:11,039 --> 00:31:14,399
let's say if you get some kind of

942
00:31:13,039 --> 00:31:16,480
primitive we are able to

943
00:31:14,399 --> 00:31:18,158
modify the value of a butterfly of an

944
00:31:16,480 --> 00:31:20,799
object what this means

945
00:31:18,159 --> 00:31:21,360
is that you have arbitrary read and

946
00:31:20,799 --> 00:31:23,039
write

947
00:31:21,360 --> 00:31:24,559
now what does it mean how do i have

948
00:31:23,039 --> 00:31:26,320
arbitrary read and write by just

949
00:31:24,559 --> 00:31:30,320
manipulating the butterfly address

950
00:31:26,320 --> 00:31:33,600
okay let's assume if i want to read

951
00:31:30,320 --> 00:31:36,559
the address at a particular value

952
00:31:33,600 --> 00:31:38,320
let's say x okay what i will do is that

953
00:31:36,559 --> 00:31:41,360
i will set the butterfly value

954
00:31:38,320 --> 00:31:44,559
as x now what i'm going to do is try to

955
00:31:41,360 --> 00:31:46,240
access the first element of this object

956
00:31:44,559 --> 00:31:47,678
now when i try to access the first

957
00:31:46,240 --> 00:31:48,960
element of this object

958
00:31:47,679 --> 00:31:50,880
it's going to go to the butterfly

959
00:31:48,960 --> 00:31:53,200
address which is x

960
00:31:50,880 --> 00:31:54,480
and then it's going to read the value

961
00:31:53,200 --> 00:31:57,360
from that address

962
00:31:54,480 --> 00:31:58,799
right so based on what value we put in

963
00:31:57,360 --> 00:32:02,158
the butterfly we're able

964
00:31:58,799 --> 00:32:04,480
to read certain values and similarly

965
00:32:02,159 --> 00:32:05,440
the opposite of it is that you are you

966
00:32:04,480 --> 00:32:07,760
will be able

967
00:32:05,440 --> 00:32:08,799
to write values at certain places so for

968
00:32:07,760 --> 00:32:10,240
example

969
00:32:08,799 --> 00:32:12,158
if i want to write a value at the

970
00:32:10,240 --> 00:32:14,000
address x i'm going to change the

971
00:32:12,159 --> 00:32:16,159
butterfly to x

972
00:32:14,000 --> 00:32:17,760
and then i'm going to say x uh i'm going

973
00:32:16,159 --> 00:32:19,840
to manipulate this object

974
00:32:17,760 --> 00:32:21,840
and change the first element whatever i

975
00:32:19,840 --> 00:32:24,879
want so let's say i say

976
00:32:21,840 --> 00:32:26,158
a of 0 is 2.5 what it's going to do is

977
00:32:24,880 --> 00:32:27,120
that it's going to go to the butterfly

978
00:32:26,159 --> 00:32:28,960
address

979
00:32:27,120 --> 00:32:31,279
go to this address x which you want to

980
00:32:28,960 --> 00:32:32,960
write to and then change the first value

981
00:32:31,279 --> 00:32:35,120
so in this way we are able to achieve

982
00:32:32,960 --> 00:32:37,679
arbitrary read and write of memory

983
00:32:35,120 --> 00:32:39,600
from pawn to one 2020 i highly recommend

984
00:32:37,679 --> 00:32:41,760
that you check out the write-up here

985
00:32:39,600 --> 00:32:42,959
so the way this works is that it defines

986
00:32:41,760 --> 00:32:46,000
a function

987
00:32:42,960 --> 00:32:47,679
which calls the in operator on an array

988
00:32:46,000 --> 00:32:49,600
now the way the inoperator works is that

989
00:32:47,679 --> 00:32:51,039
it returns true if the specified

990
00:32:49,600 --> 00:32:53,279
property

991
00:32:51,039 --> 00:32:54,320
is found in the object or in its

992
00:32:53,279 --> 00:32:57,600
prototype chain

993
00:32:54,320 --> 00:33:00,158
okay then it calls this function

994
00:32:57,600 --> 00:33:01,519
several times which does which does

995
00:33:00,159 --> 00:33:04,480
optimization in it

996
00:33:01,519 --> 00:33:06,240
so by optimization it does some kind of

997
00:33:04,480 --> 00:33:10,320
type assumptions on this object

998
00:33:06,240 --> 00:33:13,600
okay then it assigns the um

999
00:33:10,320 --> 00:33:14,559
the proto proto object to the embed

1000
00:33:13,600 --> 00:33:16,799
element

1001
00:33:14,559 --> 00:33:19,120
okay and then it adds an event listener

1002
00:33:16,799 --> 00:33:21,200
for the event dom subtree modified

1003
00:33:19,120 --> 00:33:22,559
and then it removes the embed elements

1004
00:33:21,200 --> 00:33:24,080
finally it calls this function

1005
00:33:22,559 --> 00:33:26,480
now what happens is that when it calls

1006
00:33:24,080 --> 00:33:27,279
this function uh it finds out that the

1007
00:33:26,480 --> 00:33:29,679
100 value

1008
00:33:27,279 --> 00:33:30,320
100 of 100 index is not available in

1009
00:33:29,679 --> 00:33:32,240
array

1010
00:33:30,320 --> 00:33:33,678
so it looks for the router property

1011
00:33:32,240 --> 00:33:36,799
which means it looks at

1012
00:33:33,679 --> 00:33:39,120
the embed object okay the embed element

1013
00:33:36,799 --> 00:33:41,120
and internally this calls the function

1014
00:33:39,120 --> 00:33:43,039
append child

1015
00:33:41,120 --> 00:33:44,479
one set function is called the dom

1016
00:33:43,039 --> 00:33:47,600
subtree event

1017
00:33:44,480 --> 00:33:50,480
handler is called which instead

1018
00:33:47,600 --> 00:33:50,959
change the first index of the array

1019
00:33:50,480 --> 00:33:53,679
object

1020
00:33:50,960 --> 00:33:55,279
to this one curly braces right so now

1021
00:33:53,679 --> 00:33:58,399
this array is an array with

1022
00:33:55,279 --> 00:33:58,960
contiguous which means the address of

1023
00:33:58,399 --> 00:34:02,158
this

1024
00:33:58,960 --> 00:34:04,960
curly brace is stored in the memory of

1025
00:34:02,159 --> 00:34:06,399
array okay and now over here when it

1026
00:34:04,960 --> 00:34:08,720
returns array 0

1027
00:34:06,399 --> 00:34:11,440
since there is type assumption that this

1028
00:34:08,719 --> 00:34:14,000
array is just an array with integers

1029
00:34:11,440 --> 00:34:15,119
it just returns the first index of the

1030
00:34:14,000 --> 00:34:18,239
array which is not

1031
00:34:15,119 --> 00:34:19,040
1.1 but it's actually the address of

1032
00:34:18,239 --> 00:34:21,359
this object

1033
00:34:19,040 --> 00:34:23,839
okay thereby creating an exploit

1034
00:34:21,359 --> 00:34:23,839
primitive

1035
00:34:24,719 --> 00:34:27,839
now getting the address of primitive

1036
00:34:26,480 --> 00:34:28,960
will also give you the fake object

1037
00:34:27,839 --> 00:34:30,960
primitive however

1038
00:34:28,960 --> 00:34:32,639
however in order to create fake objects

1039
00:34:30,960 --> 00:34:34,320
you must be able to

1040
00:34:32,639 --> 00:34:35,679
create valid headers and one of the

1041
00:34:34,320 --> 00:34:36,399
important things in creating valid

1042
00:34:35,679 --> 00:34:38,800
headers

1043
00:34:36,399 --> 00:34:40,799
is creating valid structure ids so in

1044
00:34:38,800 --> 00:34:42,560
this case the structure id is leaked

1045
00:34:40,800 --> 00:34:43,960
by making a fake function object and

1046
00:34:42,560 --> 00:34:45,679
then calling the

1047
00:34:43,960 --> 00:34:48,000
function.prototype.tostring

1048
00:34:45,679 --> 00:34:50,159
function on it and the output will

1049
00:34:48,000 --> 00:34:51,839
basically contain a function name

1050
00:34:50,159 --> 00:34:53,760
which will represent the structure id as

1051
00:34:51,839 --> 00:34:55,520
a utf-16 string

1052
00:34:53,760 --> 00:34:57,359
then you can create a fake object using

1053
00:34:55,520 --> 00:35:00,400
the leak structure id

1054
00:34:57,359 --> 00:35:01,440
eventually being able to override the

1055
00:35:00,400 --> 00:35:03,440
butterfly

1056
00:35:01,440 --> 00:35:05,119
pointer of an object that you control

1057
00:35:03,440 --> 00:35:06,320
which as we discussed will give you

1058
00:35:05,119 --> 00:35:08,160
arbitrary redred

1059
00:35:06,320 --> 00:35:10,000
right so this is this exploit is very

1060
00:35:08,160 --> 00:35:10,480
complicated to explain in a 40 minute

1061
00:35:10,000 --> 00:35:12,640
hour

1062
00:35:10,480 --> 00:35:15,280
talk i would highly recommend you go

1063
00:35:12,640 --> 00:35:18,879
through this link and read the write-up

1064
00:35:15,280 --> 00:35:20,800
now these primitives were actually first

1065
00:35:18,880 --> 00:35:23,040
written by a known researcher called

1066
00:35:20,800 --> 00:35:25,119
samuel grab from project zero however

1067
00:35:23,040 --> 00:35:26,240
we however the project zero team has

1068
00:35:25,119 --> 00:35:28,960
also find

1069
00:35:26,240 --> 00:35:31,118
found out the use of these chains or

1070
00:35:28,960 --> 00:35:33,359
these primitives being used in the world

1071
00:35:31,119 --> 00:35:35,760
in policy so an origin is defined as a

1072
00:35:33,359 --> 00:35:37,680
combination of a url scheme a host name

1073
00:35:35,760 --> 00:35:39,440
and a port number

1074
00:35:37,680 --> 00:35:41,279
the same origin policy in a way

1075
00:35:39,440 --> 00:35:42,880
restricts which network messages one

1076
00:35:41,280 --> 00:35:44,960
origin can send to another

1077
00:35:42,880 --> 00:35:46,480
think of it as two tabs open in a

1078
00:35:44,960 --> 00:35:48,400
browser and one tab

1079
00:35:46,480 --> 00:35:50,400
not being able to access the data from

1080
00:35:48,400 --> 00:35:51,680
other tab and this is what same origin

1081
00:35:50,400 --> 00:35:53,280
column says and it's actually

1082
00:35:51,680 --> 00:35:57,118
implemented in the browser

1083
00:35:53,280 --> 00:35:59,920
okay so however in webkit

1084
00:35:57,119 --> 00:36:00,720
the value uh the whether same origin

1085
00:35:59,920 --> 00:36:02,960
policy

1086
00:36:00,720 --> 00:36:04,480
is implemented or not is stored in a

1087
00:36:02,960 --> 00:36:05,680
boolean value which is m underscore

1088
00:36:04,480 --> 00:36:07,599
universal access

1089
00:36:05,680 --> 00:36:09,598
what this means that if an exploit can

1090
00:36:07,599 --> 00:36:11,440
somehow get rbt read write

1091
00:36:09,599 --> 00:36:13,280
within the rendered process it can

1092
00:36:11,440 --> 00:36:16,079
modify the value of this object

1093
00:36:13,280 --> 00:36:17,760
okay so this this property is defined in

1094
00:36:16,079 --> 00:36:18,160
the renderer and since we have arbitrary

1095
00:36:17,760 --> 00:36:19,680
read

1096
00:36:18,160 --> 00:36:22,399
primitive we can override this value to

1097
00:36:19,680 --> 00:36:24,399
one however how do we find the place

1098
00:36:22,400 --> 00:36:26,000
in memory where this value is stored

1099
00:36:24,400 --> 00:36:27,680
this can be done by dereferencing

1100
00:36:26,000 --> 00:36:29,359
certain pointers and calculating certain

1101
00:36:27,680 --> 00:36:30,799
offsets okay

1102
00:36:29,359 --> 00:36:32,319
so i would highly recommend you go

1103
00:36:30,800 --> 00:36:34,079
through this code snippet mention in

1104
00:36:32,320 --> 00:36:36,160
this

1105
00:36:34,079 --> 00:36:38,320
mention in this link to understand how

1106
00:36:36,160 --> 00:36:41,118
this this particular exploit

1107
00:36:38,320 --> 00:36:42,079
ah which is written by nicholas b was

1108
00:36:41,119 --> 00:36:44,400
able to

1109
00:36:42,079 --> 00:36:47,040
use rbt read write primitive in order to

1110
00:36:44,400 --> 00:36:51,040
change the value of the universal xss

1111
00:36:47,040 --> 00:36:54,079
property so in this case your

1112
00:36:51,040 --> 00:36:56,720
once this is disabled you can

1113
00:36:54,079 --> 00:36:58,079
in a way make a cross origin request

1114
00:36:56,720 --> 00:37:00,319
right so in this case

1115
00:36:58,079 --> 00:37:02,720
you have your code running on one tab

1116
00:37:00,320 --> 00:37:05,200
which is able to access your gmail data

1117
00:37:02,720 --> 00:37:06,000
which is probably open in another tab

1118
00:37:05,200 --> 00:37:08,560
okay

1119
00:37:06,000 --> 00:37:10,240
so this thing is also known as universal

1120
00:37:08,560 --> 00:37:12,720
exercise

1121
00:37:10,240 --> 00:37:14,160
now concluding with this talk we will uh

1122
00:37:12,720 --> 00:37:16,078
we can quickly discuss what is

1123
00:37:14,160 --> 00:37:17,839
fuzzing so you can actually first

1124
00:37:16,079 --> 00:37:19,599
javascript code as well

1125
00:37:17,839 --> 00:37:21,359
two of the most recommended tools out

1126
00:37:19,599 --> 00:37:23,359
there is fuzzily which is written by

1127
00:37:21,359 --> 00:37:25,279
samuel graf from project zero

1128
00:37:23,359 --> 00:37:27,920
and dharma which is a grammar based

1129
00:37:25,280 --> 00:37:29,680
fuzzer i've seen many people use their

1130
00:37:27,920 --> 00:37:31,280
own grammars with dharma which

1131
00:37:29,680 --> 00:37:34,160
turned out to be very effective however

1132
00:37:31,280 --> 00:37:35,839
also welcome to try out fazilium

1133
00:37:34,160 --> 00:37:37,759
both these tools are open source you can

1134
00:37:35,839 --> 00:37:39,920
modify and write your own implementation

1135
00:37:37,760 --> 00:37:41,440
on top of it

1136
00:37:39,920 --> 00:37:45,119
these are the list of works which were

1137
00:37:41,440 --> 00:37:47,200
fixed in ios 13.6 as you can see

1138
00:37:45,119 --> 00:37:49,040
webkit to this day remains a very big

1139
00:37:47,200 --> 00:37:51,118
attack surface and vulnerabilities have

1140
00:37:49,040 --> 00:37:53,440
been constantly found out

1141
00:37:51,119 --> 00:37:54,720
in it and reported and fixed so it's a

1142
00:37:53,440 --> 00:37:57,520
very um

1143
00:37:54,720 --> 00:37:58,480
interesting area to get into these days

1144
00:37:57,520 --> 00:38:00,880
so all things

1145
00:37:58,480 --> 00:38:02,560
which we did not discuss today is how we

1146
00:38:00,880 --> 00:38:04,240
do we survive the garbage collector in

1147
00:38:02,560 --> 00:38:05,759
case we have an expert running

1148
00:38:04,240 --> 00:38:08,078
how do we actually find out the jit

1149
00:38:05,760 --> 00:38:10,800
region and execute the shell code

1150
00:38:08,079 --> 00:38:13,040
we also did not discuss how we will how

1151
00:38:10,800 --> 00:38:14,880
we create our own shell code

1152
00:38:13,040 --> 00:38:16,640
and we also didn't discuss how do we

1153
00:38:14,880 --> 00:38:19,200
bypass certain specific challenges

1154
00:38:16,640 --> 00:38:21,520
related to ios which is bulletproof jeet

1155
00:38:19,200 --> 00:38:23,919
we also did not discuss sandbox escape

1156
00:38:21,520 --> 00:38:25,440
maybe in a in a new workshop

1157
00:38:23,920 --> 00:38:28,000
sometime i will discuss all of these

1158
00:38:25,440 --> 00:38:28,720
things these are some of the recommended

1159
00:38:28,000 --> 00:38:31,200
resources

1160
00:38:28,720 --> 00:38:33,359
which i found very useful and highly

1161
00:38:31,200 --> 00:38:35,040
recommend you go through them as well

1162
00:38:33,359 --> 00:38:37,040
thank you very much for listening to my

1163
00:38:35,040 --> 00:38:39,200
presentation if you have any questions

1164
00:38:37,040 --> 00:38:40,240
you can contact me on twitter or add me

1165
00:38:39,200 --> 00:38:42,078
on linkedin

1166
00:38:40,240 --> 00:38:44,839
and i'll be available for qa after this

1167
00:38:42,079 --> 00:38:47,839
talk in case you guys have any more

1168
00:38:44,839 --> 00:38:47,839
questions

1169
00:38:48,400 --> 00:38:50,480
you

