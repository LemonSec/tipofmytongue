1
00:00:04,910 --> 00:00:11,459
so now we will have another talk about

2
00:00:11,459 --> 00:00:14,520
JRuby will be presented by Charles and

3
00:00:14,520 --> 00:00:18,480
uh and thumb that will contributors and

4
00:00:18,480 --> 00:00:21,570
maintenance of the derby project they

5
00:00:21,570 --> 00:00:25,050
work at red ox having they are kind of

6
00:00:25,050 --> 00:00:28,199
veteran of the first M in the low beams

7
00:00:28,199 --> 00:00:30,599
I'm sure that's why they come for two

8
00:00:30,599 --> 00:00:36,800
thousand every year yeah come with me

9
00:00:39,710 --> 00:00:41,580
all right hopefully there's microphones

10
00:00:41,580 --> 00:00:44,430
picking up okay uh let's get right into

11
00:00:44,430 --> 00:00:45,810
this

12
00:00:45,810 --> 00:00:47,670
we've already pretty much been

13
00:00:47,670 --> 00:00:49,650
introduced so we've been doing we

14
00:00:49,650 --> 00:00:52,070
working on JRuby full-time for like

15
00:00:52,070 --> 00:00:56,400
eleven years 2006 yeah since 2006 so

16
00:00:56,400 --> 00:00:57,720
we've been we've been doing this for a

17
00:00:57,720 --> 00:00:58,350
while

18
00:00:58,350 --> 00:01:00,600
we've both been doing Java since one dot

19
00:01:00,600 --> 00:01:03,180
oh so like 20 years of Java development

20
00:01:03,180 --> 00:01:06,150
and we still love it yes and we and we

21
00:01:06,150 --> 00:01:08,520
love coming to conferences to meet folks

22
00:01:08,520 --> 00:01:11,759
and to find new beers to try so first

23
00:01:11,759 --> 00:01:12,990
off we're gonna do a quick update on

24
00:01:12,990 --> 00:01:14,429
where we stand with JRuby current

25
00:01:14,429 --> 00:01:16,320
versions and whatnot current version of

26
00:01:16,320 --> 00:01:18,240
JRuby is nine one seven part of our

27
00:01:18,240 --> 00:01:20,780
JRuby 9000 series

28
00:01:20,780 --> 00:01:23,039
we just released that a few weeks ago

29
00:01:23,039 --> 00:01:25,109
lots of issues but the same number of

30
00:01:25,109 --> 00:01:26,549
issues as the previous release so each

31
00:01:26,549 --> 00:01:29,880
time it's like in the 70 to 80 range of

32
00:01:29,880 --> 00:01:32,460
issues that we fixed and this one

33
00:01:32,460 --> 00:01:35,460
appears to have even solved a lot of

34
00:01:35,460 --> 00:01:36,780
problems that people are having with the

35
00:01:36,780 --> 00:01:40,439
previous several releases not as many

36
00:01:40,439 --> 00:01:42,119
problems is not not a lot of reports

37
00:01:42,119 --> 00:01:43,710
coming in from folks it seems like it's

38
00:01:43,710 --> 00:01:46,770
going fairly well here's our roadmap

39
00:01:46,770 --> 00:01:48,420
going forward

40
00:01:48,420 --> 00:01:54,569
so with RIT with JRuby 9.1 we made the

41
00:01:54,569 --> 00:01:57,539
move to Ruby 2.3 compatibility so for

42
00:01:57,539 --> 00:02:00,719
the first time ever we were only a

43
00:02:00,719 --> 00:02:03,270
couple months off from see Ruby

44
00:02:03,270 --> 00:02:05,639
releasing their new version and then we

45
00:02:05,639 --> 00:02:07,920
had a JRuby that supported it we are

46
00:02:07,920 --> 00:02:10,110
working on 2.4 support which will be

47
00:02:10,110 --> 00:02:12,720
part of the 9.2 series and we're only

48
00:02:12,720 --> 00:02:14,819
going to maintain one of those minor

49
00:02:14,819 --> 00:02:17,250
versions so once we have 9.2 out

50
00:02:17,250 --> 00:02:18,540
the nine one series will won't be

51
00:02:18,540 --> 00:02:19,740
maintaining anymore we'll just keep

52
00:02:19,740 --> 00:02:21,270
people on the latest version of Ruby I

53
00:02:21,270 --> 00:02:22,920
think we might still put nine eleven

54
00:02:22,920 --> 00:02:24,660
eight out yeah as a possibility when we

55
00:02:24,660 --> 00:02:26,010
do one one more maintenance release

56
00:02:26,010 --> 00:02:28,770
because 9.2 is still on its way and I'll

57
00:02:28,770 --> 00:02:31,950
talk about that next once we do get 9.2

58
00:02:31,950 --> 00:02:33,990
out we're hoping to also resolve

59
00:02:33,990 --> 00:02:36,090
anybody's remaining migration issues

60
00:02:36,090 --> 00:02:38,190
from JRuby 1.7 because we want to kind

61
00:02:38,190 --> 00:02:40,920
of kill that that that version and get

62
00:02:40,920 --> 00:02:43,380
people all on 9000 is there anyone using

63
00:02:43,380 --> 00:02:49,380
JIRA v17 here yeah if you if you have if

64
00:02:49,380 --> 00:02:52,230
you are on one seven and haven't tried

65
00:02:52,230 --> 00:02:54,330
9,000 give it a shot let us know if

66
00:02:54,330 --> 00:02:55,650
there's any problems things that seem

67
00:02:55,650 --> 00:02:56,940
like they need to be fixed because

68
00:02:56,940 --> 00:03:00,930
that's a big goal for us okay so Jared

69
00:03:00,930 --> 00:03:02,940
b92 like I was just talking about

70
00:03:02,940 --> 00:03:06,810
we support Ruby 2.4 features and there's

71
00:03:06,810 --> 00:03:08,340
the github issue if you want to track

72
00:03:08,340 --> 00:03:12,260
progress I was just kind of estimating

73
00:03:12,260 --> 00:03:15,750
probably about 75% complete of the

74
00:03:15,750 --> 00:03:17,520
bullets that are listed on there which

75
00:03:17,520 --> 00:03:19,320
are basically out of rubies news file

76
00:03:19,320 --> 00:03:21,540
and list all the updated features about

77
00:03:21,540 --> 00:03:23,220
half of those bullets are done but a lot

78
00:03:23,220 --> 00:03:25,769
of them are really small bullets some of

79
00:03:25,769 --> 00:03:27,750
them are really big things like bignum

80
00:03:27,750 --> 00:03:29,280
and fixing them are now the same class

81
00:03:29,280 --> 00:03:30,959
they're all just integer at this point

82
00:03:30,959 --> 00:03:34,620
and that's done so it's more than 50

83
00:03:34,620 --> 00:03:36,390
percent less than 100 percent in roughly

84
00:03:36,390 --> 00:03:39,150
75 I'd say and like I said we want to

85
00:03:39,150 --> 00:03:41,130
try and resolve any remaining 1-7

86
00:03:41,130 --> 00:03:43,560
migration issues I'd like to be able to

87
00:03:43,560 --> 00:03:45,000
get this mostly finished by the end of

88
00:03:45,000 --> 00:03:46,709
the month we'll evaluate how many

89
00:03:46,709 --> 00:03:48,180
features we've got finished and how

90
00:03:48,180 --> 00:03:50,730
close we are we may not have everything

91
00:03:50,730 --> 00:03:52,620
done for the initial nine to release but

92
00:03:52,620 --> 00:03:55,610
we'll get the big bullets taken care of

93
00:03:55,610 --> 00:03:58,049
this is one of our favorite slides a

94
00:03:58,049 --> 00:04:00,540
couple years back we asked for folks to

95
00:04:00,540 --> 00:04:04,260
to tweet us their company logos if they

96
00:04:04,260 --> 00:04:06,480
are using JRuby in production and this

97
00:04:06,480 --> 00:04:08,910
is one day's worth of responses to that

98
00:04:08,910 --> 00:04:13,200
tweet it really was unbelievable to see

99
00:04:13,200 --> 00:04:14,910
how many people and how many different

100
00:04:14,910 --> 00:04:16,890
companies out there including big ones

101
00:04:16,890 --> 00:04:19,709
like BBC News all the election results

102
00:04:19,709 --> 00:04:21,418
that you get reported on BBC News

103
00:04:21,418 --> 00:04:24,930
that's a JRuby application at square

104
00:04:24,930 --> 00:04:26,610
they were using JRuby for all the

105
00:04:26,610 --> 00:04:28,140
transactions that we're going through

106
00:04:28,140 --> 00:04:29,729
the system so pretty much everybody

107
00:04:29,729 --> 00:04:30,520
anytime you paid

108
00:04:30,520 --> 00:04:32,770
a square device it was going through

109
00:04:32,770 --> 00:04:35,650
JRuby and so on and then a couple other

110
00:04:35,650 --> 00:04:37,780
more recent ones that are still that are

111
00:04:37,780 --> 00:04:40,720
still big JRuby fans break man Pro which

112
00:04:40,720 --> 00:04:42,909
is the commercial version of break man

113
00:04:42,909 --> 00:04:45,849
for doing code analysis stuff and puppet

114
00:04:45,849 --> 00:04:48,370
server actually has used JRuby on the

115
00:04:48,370 --> 00:04:50,470
server side so there's there's lots of

116
00:04:50,470 --> 00:04:52,780
folks out there and I kind of like this

117
00:04:52,780 --> 00:04:55,690
tweet from Zack the key point here if

118
00:04:55,690 --> 00:04:58,120
you want isomorphism if you want a ruby

119
00:04:58,120 --> 00:05:01,030
implementation today that really can

120
00:05:01,030 --> 00:05:04,090
replace MRI for your applications JRuby

121
00:05:04,090 --> 00:05:06,849
is the only option at this point and you

122
00:05:06,849 --> 00:05:08,080
can make your application a lot better

123
00:05:08,080 --> 00:05:10,569
as we'll show as we go on here so our

124
00:05:10,569 --> 00:05:12,610
number one priority has always been to

125
00:05:12,610 --> 00:05:14,860
users this means that we don't

126
00:05:14,860 --> 00:05:16,300
necessarily have as much time as we'd

127
00:05:16,300 --> 00:05:17,830
like to work on performance and other

128
00:05:17,830 --> 00:05:20,830
things but it means we're focusing on

129
00:05:20,830 --> 00:05:23,590
usability of JRuby first and then edge

130
00:05:23,590 --> 00:05:25,539
case features performance will come

131
00:05:25,539 --> 00:05:28,719
after that but always trying to make

132
00:05:28,719 --> 00:05:29,710
sure that users have a good experience

133
00:05:29,710 --> 00:05:33,789
with JRuby so along with making sure

134
00:05:33,789 --> 00:05:35,949
that it works for users and they can use

135
00:05:35,949 --> 00:05:37,300
JRuby is trying to keep up with

136
00:05:37,300 --> 00:05:39,039
compatibility and as I mentioned we're

137
00:05:39,039 --> 00:05:41,530
very excited that this past year we

138
00:05:41,530 --> 00:05:43,750
actually are at current ruby version

139
00:05:43,750 --> 00:05:45,969
finally we always lagged behind a couple

140
00:05:45,969 --> 00:05:47,080
versions because it was a lot of

141
00:05:47,080 --> 00:05:48,219
catch-up work to do

142
00:05:48,219 --> 00:05:51,039
we've finally caught that up we also run

143
00:05:51,039 --> 00:05:52,599
more tests than any other Ruby

144
00:05:52,599 --> 00:05:55,569
implementation we run Ruby spec the

145
00:05:55,569 --> 00:05:58,419
specs the Ruby spec in our Ruby / spec

146
00:05:58,419 --> 00:06:00,490
we run C Ruby

147
00:06:00,490 --> 00:06:03,880
MRIs test Suites which is some hundred

148
00:06:03,880 --> 00:06:06,880
thousand assertions we run our own suite

149
00:06:06,880 --> 00:06:09,190
that's for things that are kind of weird

150
00:06:09,190 --> 00:06:11,319
to us specific to JRuby or related to

151
00:06:11,319 --> 00:06:13,779
integrating with the JVM JRuby specific

152
00:06:13,779 --> 00:06:16,360
features and then we permute a lot of

153
00:06:16,360 --> 00:06:18,009
these over our different runtime modes

154
00:06:18,009 --> 00:06:19,900
we have an interpreter we have a JIT and

155
00:06:19,900 --> 00:06:21,909
so some of these Suites run three or

156
00:06:21,909 --> 00:06:24,969
four times and CI I think our entire

157
00:06:24,969 --> 00:06:29,590
Travis job takes according to Travis is

158
00:06:29,590 --> 00:06:30,880
something in the neighborhood of four to

159
00:06:30,880 --> 00:06:33,310
five hours of CPU time to run the entire

160
00:06:33,310 --> 00:06:35,169
suite only around seven and eight to

161
00:06:35,169 --> 00:06:37,120
four Java and we run seven and eight to

162
00:06:37,120 --> 00:06:38,889
try making sure that we're still

163
00:06:38,889 --> 00:06:40,960
compatible with older Java versions so

164
00:06:40,960 --> 00:06:43,270
we work very hard on this

165
00:06:43,270 --> 00:06:45,010
there are also a lot of challenges to

166
00:06:45,010 --> 00:06:47,140
this probably the biggest one is see

167
00:06:47,140 --> 00:06:49,570
extensions that continue to plague the

168
00:06:49,570 --> 00:06:54,250
the C world if you saw the previous talk

169
00:06:54,250 --> 00:06:57,000
C extensions are a pain across platforms

170
00:06:57,000 --> 00:06:58,720
sometimes they just don't build

171
00:06:58,720 --> 00:07:00,340
sometimes on Windows you don't have

172
00:07:00,340 --> 00:07:02,860
tools to even build them with and then

173
00:07:02,860 --> 00:07:04,510
of course on JRuby we don't have support

174
00:07:04,510 --> 00:07:07,570
for C Ruby's extension API it's a very

175
00:07:07,570 --> 00:07:09,910
invasive very low level you can go and

176
00:07:09,910 --> 00:07:11,950
poke direct pointers to objects in

177
00:07:11,950 --> 00:07:14,620
memory we had experimental support for

178
00:07:14,620 --> 00:07:15,700
it for a while but it just never really

179
00:07:15,700 --> 00:07:19,120
panned out sometimes the library authors

180
00:07:19,120 --> 00:07:21,280
are actually a challenge there's a lot

181
00:07:21,280 --> 00:07:24,360
of libraries that maybe you're just

182
00:07:24,360 --> 00:07:26,680
uninterested in supporting JRuby so they

183
00:07:26,680 --> 00:07:29,080
don't test on it some minor quirks or

184
00:07:29,080 --> 00:07:30,850
differences in behavior and then we get

185
00:07:30,850 --> 00:07:34,510
bug reports on the JRuby project we try

186
00:07:34,510 --> 00:07:36,010
to work with all authors and make sure

187
00:07:36,010 --> 00:07:38,200
that day Ruby runs their stuff well try

188
00:07:38,200 --> 00:07:40,120
to get more libraries running JRuby in

189
00:07:40,120 --> 00:07:43,300
Travis or CI but there's some challenges

190
00:07:43,300 --> 00:07:46,330
there there are a few users that are a

191
00:07:46,330 --> 00:07:47,980
few library authors that are simply

192
00:07:47,980 --> 00:07:50,110
hostile to anything that's JVM related

193
00:07:50,110 --> 00:07:53,020
like they they were beaten as a child by

194
00:07:53,020 --> 00:07:55,090
the JVM and so now they're never gonna

195
00:07:55,090 --> 00:07:57,610
support it but usually most folks if we

196
00:07:57,610 --> 00:08:00,340
reach out and talk to him or you as ruby

197
00:08:00,340 --> 00:08:01,810
users reach out and say I'd really like

198
00:08:01,810 --> 00:08:04,120
JRuby support they're usually usually

199
00:08:04,120 --> 00:08:08,830
pretty welcome to that idea and then of

200
00:08:08,830 --> 00:08:09,880
course this takes a lot of time as I

201
00:08:09,880 --> 00:08:11,650
mentioned which takes away from other

202
00:08:11,650 --> 00:08:13,630
performance stuff we're glad to finally

203
00:08:13,630 --> 00:08:14,830
be caught up because it means we can

204
00:08:14,830 --> 00:08:18,460
start focusing on those things more so a

205
00:08:18,460 --> 00:08:20,740
few numbers on where we stand as far as

206
00:08:20,740 --> 00:08:24,730
running tests on the Ruby specs the base

207
00:08:24,730 --> 00:08:29,050
language ruby specs we run 98 you know

208
00:08:29,050 --> 00:08:31,480
it's approaching 99% on some of this

209
00:08:31,480 --> 00:08:33,789
stuff the things that aren't in there

210
00:08:33,789 --> 00:08:36,820
are usually either minor items it's

211
00:08:36,820 --> 00:08:39,730
something that we don't run properly in

212
00:08:39,730 --> 00:08:41,650
Ruby spec but has never been reported

213
00:08:41,650 --> 00:08:44,049
well we don't we don't spin our wheels

214
00:08:44,049 --> 00:08:45,880
wasting time on edge features that no

215
00:08:45,880 --> 00:08:48,100
one's using there are also some rare

216
00:08:48,100 --> 00:08:49,330
features or features that are difficult

217
00:08:49,330 --> 00:08:53,710
to do on the JVM like continuations and

218
00:08:53,710 --> 00:08:54,670
so on and

219
00:08:54,670 --> 00:08:56,260
don't just don't run those tests so that

220
00:08:56,260 --> 00:08:57,850
lowers our percentages a little bit

221
00:08:57,850 --> 00:08:59,470
could be another percent higher if we

222
00:08:59,470 --> 00:09:01,780
just resupport a flip-flop operator

223
00:09:01,780 --> 00:09:04,120
yeah we like flip-flops is it how many

224
00:09:04,120 --> 00:09:05,830
rubyists have ever used the flip-flop

225
00:09:05,830 --> 00:09:08,740
operator that's exactly why we don't

226
00:09:08,740 --> 00:09:10,450
bother implementing a that particular

227
00:09:10,450 --> 00:09:12,850
feature it's in there but go look it up

228
00:09:12,850 --> 00:09:14,560
and try to figure out how to wrap your

229
00:09:14,560 --> 00:09:15,880
head around what's actually doing I

230
00:09:15,880 --> 00:09:17,920
broke it and then I didn't fix it

231
00:09:17,920 --> 00:09:19,150
because I wanted to see when someone

232
00:09:19,150 --> 00:09:20,740
would actually report it as an issue and

233
00:09:20,740 --> 00:09:25,510
it's been like two years yeah so so the

234
00:09:25,510 --> 00:09:27,580
core stuff is a little bit lower this is

235
00:09:27,580 --> 00:09:28,900
this includes all of the core classes

236
00:09:28,900 --> 00:09:32,140
string array and so on the base ones

237
00:09:32,140 --> 00:09:33,490
that you would expect like string and

238
00:09:33,490 --> 00:09:35,080
array are pretty darn close to a hundred

239
00:09:35,080 --> 00:09:37,720
percent passing on these specs but then

240
00:09:37,720 --> 00:09:39,610
you get into weird edge cases again like

241
00:09:39,610 --> 00:09:43,500
Cobra continuations some oddities of

242
00:09:43,500 --> 00:09:46,510
fibers things like plat like fork that

243
00:09:46,510 --> 00:09:48,850
are not supported on the JVM that's

244
00:09:48,850 --> 00:09:50,560
where we end up losing a few dings here

245
00:09:50,560 --> 00:09:52,180
but we we were really happy with these

246
00:09:52,180 --> 00:09:54,720
numbers and we continue to improve this

247
00:09:54,720 --> 00:09:57,970
mris tests is a it's an extremely large

248
00:09:57,970 --> 00:10:00,520
suite most new features and changes that

249
00:10:00,520 --> 00:10:01,660
go into C Ruby

250
00:10:01,660 --> 00:10:03,820
usually go into this test suite we'd

251
00:10:03,820 --> 00:10:05,320
like four more of them to go into the

252
00:10:05,320 --> 00:10:06,670
Ruby specs because they're nice and

253
00:10:06,670 --> 00:10:08,410
readable we'd like to have just one

254
00:10:08,410 --> 00:10:11,410
suite but the truth of the matter is

255
00:10:11,410 --> 00:10:13,390
today if you're not running both Ruby

256
00:10:13,390 --> 00:10:16,450
specs and mris tests you're not getting

257
00:10:16,450 --> 00:10:18,820
the coverage that you could you were

258
00:10:18,820 --> 00:10:21,100
really missing out on a lot of stuff so

259
00:10:21,100 --> 00:10:24,070
we keep our tests updated and pull in C

260
00:10:24,070 --> 00:10:25,840
Ruby's tests we have a system for

261
00:10:25,840 --> 00:10:28,360
excluding anything that we fail and we

262
00:10:28,360 --> 00:10:30,790
pass and run about 83 percent of the

263
00:10:30,790 --> 00:10:32,530
tests that are in an MRI suite which is

264
00:10:32,530 --> 00:10:34,960
a pretty good number again lots of weird

265
00:10:34,960 --> 00:10:37,210
stuff in there and some of these some of

266
00:10:37,210 --> 00:10:38,710
these libraries will never support like

267
00:10:38,710 --> 00:10:41,590
all the gdb and other ones that are C

268
00:10:41,590 --> 00:10:43,990
bindings open SSL we test separately so

269
00:10:43,990 --> 00:10:45,660
that's not part of this metric either

270
00:10:45,660 --> 00:10:47,470
and then of course one of the biggest

271
00:10:47,470 --> 00:10:50,740
things for compatibility is making sure

272
00:10:50,740 --> 00:10:53,560
that rails works now up to rails 4 we've

273
00:10:53,560 --> 00:10:55,000
done a pretty good job of keeping up

274
00:10:55,000 --> 00:10:55,690
with it

275
00:10:55,690 --> 00:10:58,000
and and rails 4 applications should work

276
00:10:58,000 --> 00:11:00,850
great on JRuby rails 5 made enough

277
00:11:00,850 --> 00:11:03,040
changes in how active records done that

278
00:11:03,040 --> 00:11:05,830
we're still kind of catching up on that

279
00:11:05,830 --> 00:11:07,750
we have done some of the initial work

280
00:11:07,750 --> 00:11:10,390
the sequel Lite support is very good as

281
00:11:10,390 --> 00:11:12,490
you can see here only 13 failures three

282
00:11:12,490 --> 00:11:14,080
errors out of all of those tests for

283
00:11:14,080 --> 00:11:16,750
sequel light and that sets the baseline

284
00:11:16,750 --> 00:11:18,399
for the other database adapters it

285
00:11:18,399 --> 00:11:20,680
shouldn't be hard for us to also get my

286
00:11:20,680 --> 00:11:21,940
sequel Postgres and the other one

287
00:11:21,940 --> 00:11:24,160
supported just as well and so for the

288
00:11:24,160 --> 00:11:26,140
first time we should be able to catch up

289
00:11:26,140 --> 00:11:27,550
and get a hundred percent on active

290
00:11:27,550 --> 00:11:29,769
record for all these databases and of

291
00:11:29,769 --> 00:11:31,000
course everything except active record

292
00:11:31,000 --> 00:11:34,140
is nearly a hundred percent on here

293
00:11:34,140 --> 00:11:38,380
alright so I went and updated a document

294
00:11:38,380 --> 00:11:40,149
on our wiki on how we were doing the

295
00:11:40,149 --> 00:11:42,370
optimization and then Chris eaten from

296
00:11:42,370 --> 00:11:45,040
the Ruby truffle team went and noticed

297
00:11:45,040 --> 00:11:47,200
that and I thought be fun to talk about

298
00:11:47,200 --> 00:11:49,750
the optimization so why are we even

299
00:11:49,750 --> 00:11:51,490
talking about the optimization shouldn't

300
00:11:51,490 --> 00:11:54,250
we be optimizing code so let's let's

301
00:11:54,250 --> 00:11:55,360
let's figure this out

302
00:11:55,360 --> 00:11:57,640
if you think about the universe of all

303
00:11:57,640 --> 00:11:59,769
the optimizations you can do with with

304
00:11:59,769 --> 00:12:02,230
software and then you consider what you

305
00:12:02,230 --> 00:12:04,060
can do initially with Ruby it's quite

306
00:12:04,060 --> 00:12:06,550
small and that's because Ruby is not

307
00:12:06,550 --> 00:12:08,500
amenable to static analysis it's not

308
00:12:08,500 --> 00:12:13,270
like C so the real problem is that we

309
00:12:13,270 --> 00:12:15,399
lack the additional information we need

310
00:12:15,399 --> 00:12:16,600
to actually do these bigger

311
00:12:16,600 --> 00:12:20,470
optimizations so like most dynamic

312
00:12:20,470 --> 00:12:22,930
languages we make up for that by doing

313
00:12:22,930 --> 00:12:26,050
profiling we just study its execution

314
00:12:26,050 --> 00:12:28,690
try to figure out if one method is

315
00:12:28,690 --> 00:12:31,630
always calling the same method or if a

316
00:12:31,630 --> 00:12:34,959
variables always a fixnum we maybe can

317
00:12:34,959 --> 00:12:39,910
do more optimizations all right

318
00:12:39,910 --> 00:12:43,320
however we only know what we've seen

319
00:12:43,320 --> 00:12:48,130
things can change so we're running some

320
00:12:48,130 --> 00:12:52,149
code ten million times this variable is

321
00:12:52,149 --> 00:12:54,010
a fixnum and then suddenly it becomes a

322
00:12:54,010 --> 00:12:57,730
big num well we have to cope with that

323
00:12:57,730 --> 00:12:59,230
because you want your program to

324
00:12:59,230 --> 00:13:02,970
actually run correctly so in that case

325
00:13:02,970 --> 00:13:06,160
we have to go and check do some chucker

326
00:13:06,160 --> 00:13:08,910
check a precondition and if that

327
00:13:08,910 --> 00:13:11,649
precondition ever fails then we have to

328
00:13:11,649 --> 00:13:13,810
fall back to a correct version of our

329
00:13:13,810 --> 00:13:16,589
program

330
00:13:18,100 --> 00:13:21,760
so the optimization is very important to

331
00:13:21,760 --> 00:13:24,070
maintain correctness but it also has a

332
00:13:24,070 --> 00:13:26,710
nice secondary benefit that you can be

333
00:13:26,710 --> 00:13:28,540
very aggressive with the optimizations

334
00:13:28,540 --> 00:13:30,130
you try to do initially to try to get

335
00:13:30,130 --> 00:13:33,460
great performance and if it works out

336
00:13:33,460 --> 00:13:36,130
then 10 times performance if it doesn't

337
00:13:36,130 --> 00:13:38,830
work out then you fall back to safe and

338
00:13:38,830 --> 00:13:41,110
then maybe you try something else

339
00:13:41,110 --> 00:13:43,810
and this is where we can see a warm-up

340
00:13:43,810 --> 00:13:48,610
occurring in VMs another nice thing

341
00:13:48,610 --> 00:13:55,360
about being able to deoptimization UPS

342
00:13:55,360 --> 00:13:57,760
it becomes a big numb butt and some

343
00:13:57,760 --> 00:13:59,860
numeric algorithm were it just continues

344
00:13:59,860 --> 00:14:01,960
to increase now all of a sudden that's

345
00:14:01,960 --> 00:14:03,820
always a big number well maybe we can do

346
00:14:03,820 --> 00:14:07,630
an optimization there as you'll see

347
00:14:07,630 --> 00:14:11,560
later the code that has the ability to

348
00:14:11,560 --> 00:14:16,270
deoptimization code they can't and the

349
00:14:16,270 --> 00:14:18,630
most important

350
00:14:18,630 --> 00:14:23,380
VM for us is the JVM and so Charlie

351
00:14:23,380 --> 00:14:25,240
replied to Chris saying we've been doing

352
00:14:25,240 --> 00:14:28,630
D optimization forever on JRuby right I

353
00:14:28,630 --> 00:14:30,970
mean the JVM has this as part of its way

354
00:14:30,970 --> 00:14:33,340
of optimizing job I can do aggressive

355
00:14:33,340 --> 00:14:36,160
optimizations and back off and since we

356
00:14:36,160 --> 00:14:38,680
actually have been emitting JVM bytecode

357
00:14:38,680 --> 00:14:41,830
for Ruby for years since 2007 or so

358
00:14:41,830 --> 00:14:43,390
we've actually been doing the

359
00:14:43,390 --> 00:14:45,010
optimization since then and we were the

360
00:14:45,010 --> 00:14:48,610
first JIT for Ruby anywhere just because

361
00:14:48,610 --> 00:14:51,760
we could run on top of the JVM so now

362
00:14:51,760 --> 00:14:53,080
we'll take a step back here and kind of

363
00:14:53,080 --> 00:14:55,240
talk through some of the the steps the

364
00:14:55,240 --> 00:14:56,680
strategies we've been using to improve

365
00:14:56,680 --> 00:14:58,900
performance on on route on JRuby these

366
00:14:58,900 --> 00:15:01,300
days the first thing that we did when we

367
00:15:01,300 --> 00:15:04,060
released 9000 last year I think the

368
00:15:04,060 --> 00:15:07,750
first release of it we introduced a new

369
00:15:07,750 --> 00:15:10,060
I our new intermediate representation

370
00:15:10,060 --> 00:15:13,360
for Ruby code previously we just parsed

371
00:15:13,360 --> 00:15:16,000
to an ast and then we walk the ast and

372
00:15:16,000 --> 00:15:17,980
then eventually the JIT will walk the

373
00:15:17,980 --> 00:15:19,540
ast and turn it into byte code and

374
00:15:19,540 --> 00:15:22,840
that's about as far as it would go the

375
00:15:22,840 --> 00:15:25,420
new ir however is more like a standard

376
00:15:25,420 --> 00:15:28,900
like cs101 compiler it has optimization

377
00:15:28,900 --> 00:15:29,410
past

378
00:15:29,410 --> 00:15:31,449
we have a data flow graph a control flow

379
00:15:31,449 --> 00:15:33,850
graph we can see how the code actually

380
00:15:33,850 --> 00:15:36,190
works and get a much better picture of

381
00:15:36,190 --> 00:15:38,949
it from a static view and now of course

382
00:15:38,949 --> 00:15:40,629
like Tom mentioned being able to do some

383
00:15:40,629 --> 00:15:42,519
more profiling all because we've got

384
00:15:42,519 --> 00:15:43,870
this IR that's much more of a

385
00:15:43,870 --> 00:15:48,040
traditional compiler architecture so

386
00:15:48,040 --> 00:15:49,569
then we've got our IR and we can do our

387
00:15:49,569 --> 00:15:51,189
own passes in our own compiler

388
00:15:51,189 --> 00:15:52,810
optimizations textbook sort of

389
00:15:52,810 --> 00:15:55,269
optimizations we still of course then

390
00:15:55,269 --> 00:15:57,730
also JIT to the JVM get down to JVM

391
00:15:57,730 --> 00:15:59,439
bytecode and we've been doing this for a

392
00:15:59,439 --> 00:16:01,269
long time but the code that we're

393
00:16:01,269 --> 00:16:03,250
producing now is much better because of

394
00:16:03,250 --> 00:16:05,740
the IR because it can improve the code

395
00:16:05,740 --> 00:16:09,490
before we feed it to the JVM so we emit

396
00:16:09,490 --> 00:16:11,709
JVM bytecode the JVM takes over and then

397
00:16:11,709 --> 00:16:13,180
depending on which one you're running

398
00:16:13,180 --> 00:16:15,339
eventually it will also chip art

399
00:16:15,339 --> 00:16:17,560
bytecode down into native code so dear

400
00:16:17,560 --> 00:16:19,959
who's the first native JIT for for Ruby

401
00:16:19,959 --> 00:16:22,360
as a result of that we try to make the

402
00:16:22,360 --> 00:16:24,160
bytecode as simple as possible and make

403
00:16:24,160 --> 00:16:26,589
it fit into the JVM and sometimes we

404
00:16:26,589 --> 00:16:29,439
yell at the JVM with flags and other

405
00:16:29,439 --> 00:16:31,660
tweaks and suggestions to try and get it

406
00:16:31,660 --> 00:16:33,430
to work but this kind of a wrestling

407
00:16:33,430 --> 00:16:36,089
match we have a very blunt tool for

408
00:16:36,089 --> 00:16:39,130
expressing Ruby across that boundary to

409
00:16:39,130 --> 00:16:41,800
the JVM and sometimes we don't get the

410
00:16:41,800 --> 00:16:43,329
performance that we want but it's

411
00:16:43,329 --> 00:16:44,319
certainly a lot faster than the

412
00:16:44,319 --> 00:16:46,509
interpreter anywhere from 2 to 10 times

413
00:16:46,509 --> 00:16:47,860
faster depending on what kind of loads

414
00:16:47,860 --> 00:16:50,860
you're running so more recently in Java

415
00:16:50,860 --> 00:16:53,019
7 feature was introduced called invoke

416
00:16:53,019 --> 00:16:55,569
dynamic invoke dynamic is basically a

417
00:16:55,569 --> 00:16:57,550
feature for doing fast dynamic calls at

418
00:16:57,550 --> 00:16:59,800
the JVM level and having them optimize

419
00:16:59,800 --> 00:17:02,410
an in line like Java does and we've been

420
00:17:02,410 --> 00:17:05,380
using this heavily over the years much

421
00:17:05,380 --> 00:17:07,720
of JRuby right now uses it for constant

422
00:17:07,720 --> 00:17:09,939
lookup for method calls for instance

423
00:17:09,939 --> 00:17:11,799
variables and this gives us another

424
00:17:11,799 --> 00:17:13,720
three to five times improvement over

425
00:17:13,720 --> 00:17:18,699
just the JIT alone so the JVM gives us a

426
00:17:18,699 --> 00:17:22,480
lot so why are we working on our own D

427
00:17:22,480 --> 00:17:25,569
optimization basically just to make up

428
00:17:25,569 --> 00:17:27,669
for a few things that the JVM just can't

429
00:17:27,669 --> 00:17:31,450
provide for us today in particular if we

430
00:17:31,450 --> 00:17:33,669
call a method and supply block that's

431
00:17:33,669 --> 00:17:35,590
something that the JVM can't in line for

432
00:17:35,590 --> 00:17:39,220
us and that's a pretty big penalty which

433
00:17:39,220 --> 00:17:42,280
also affects Java lambdas as well same

434
00:17:42,280 --> 00:17:43,150
sort of problem

435
00:17:43,150 --> 00:17:44,980
you've got one method that receives lots

436
00:17:44,980 --> 00:17:46,690
of different lambdas it doesn't know how

437
00:17:46,690 --> 00:17:48,430
to optimize it as well

438
00:17:48,430 --> 00:17:50,580
another one is numeric specialization

439
00:17:50,580 --> 00:17:53,140
realizing that a fixnum is really just a

440
00:17:53,140 --> 00:17:56,020
primitive Java long and actually the JVM

441
00:17:56,020 --> 00:17:58,360
can do this it's just we just have a

442
00:17:58,360 --> 00:18:00,010
little too much code for it to actually

443
00:18:00,010 --> 00:18:04,360
be able to see it third one slightly

444
00:18:04,360 --> 00:18:08,440
slightly less useful but if we go and

445
00:18:08,440 --> 00:18:11,530
call us the square bracket method we

446
00:18:11,530 --> 00:18:12,940
don't know which version of the square

447
00:18:12,940 --> 00:18:15,160
bracket method there is and there's one

448
00:18:15,160 --> 00:18:17,410
in the standard library that actually

449
00:18:17,410 --> 00:18:19,530
sets a global variable as a side-effect

450
00:18:19,530 --> 00:18:22,720
so we always have to like account for

451
00:18:22,720 --> 00:18:24,040
the fact that we might have to set this

452
00:18:24,040 --> 00:18:27,580
side-effect now at the optimization we

453
00:18:27,580 --> 00:18:29,500
can call and then if we realize it's

454
00:18:29,500 --> 00:18:31,540
that version will be optimized and then

455
00:18:31,540 --> 00:18:33,520
lazily add that state right so we don't

456
00:18:33,520 --> 00:18:35,320
need to set it up every time just in

457
00:18:35,320 --> 00:18:37,540
case we call that one weird method we

458
00:18:37,540 --> 00:18:41,110
can do it after the fact before we can

459
00:18:41,110 --> 00:18:42,730
go into this more we need to talk a

460
00:18:42,730 --> 00:18:43,840
little more about our internal

461
00:18:43,840 --> 00:18:47,140
representation itself as Charlie pointed

462
00:18:47,140 --> 00:18:49,510
out we now have a traditional compiler

463
00:18:49,510 --> 00:18:51,610
architecture back in the one seven days

464
00:18:51,610 --> 00:18:53,470
we did everything with the abstract

465
00:18:53,470 --> 00:18:56,860
syntax tree he opened up any compilers

466
00:18:56,860 --> 00:18:59,380
book these five boxes on the left would

467
00:18:59,380 --> 00:19:01,210
be what you'd read in the first chapter

468
00:19:01,210 --> 00:19:05,020
but but for today we'll just look at our

469
00:19:05,020 --> 00:19:07,600
eye our instructions themselves they're

470
00:19:07,600 --> 00:19:09,160
just some virtual machine instructions

471
00:19:09,160 --> 00:19:12,900
we we made that represent Ruby semantics

472
00:19:12,900 --> 00:19:16,840
so for the method on the Left here's

473
00:19:16,840 --> 00:19:18,429
some instructions on the right that

474
00:19:18,429 --> 00:19:22,210
represent it I'll just go over a few so

475
00:19:22,210 --> 00:19:24,610
we check arity if we pass more than one

476
00:19:24,610 --> 00:19:25,809
argument then this would raise an

477
00:19:25,809 --> 00:19:27,190
exception so that's what that

478
00:19:27,190 --> 00:19:30,520
instruction does likewise receive arg0

479
00:19:30,520 --> 00:19:33,100
we take the zeroth argument passed in

480
00:19:33,100 --> 00:19:37,110
and bind it to the local variable b

481
00:19:37,110 --> 00:19:40,500
where we have a call instruction so B's

482
00:19:40,500 --> 00:19:42,640
getting the double equal method called

483
00:19:42,640 --> 00:19:45,910
on it and passing it one b equals 1 we

484
00:19:45,910 --> 00:19:48,850
have temporary variables which we use

485
00:19:48,850 --> 00:19:51,389
for various things

486
00:19:52,190 --> 00:19:54,080
we have a bunch of branch instructions

487
00:19:54,080 --> 00:19:56,510
so here we're just checking to see if

488
00:19:56,510 --> 00:19:58,669
this is false or not and if it is false

489
00:19:58,669 --> 00:20:01,580
then we go down our else branch so I

490
00:20:01,580 --> 00:20:05,059
think the assembly is pretty easy to

491
00:20:05,059 --> 00:20:09,380
grok in truth we have a lot more

492
00:20:09,380 --> 00:20:11,659
information on every instruction I don't

493
00:20:11,659 --> 00:20:13,250
expect you to be able to read that but

494
00:20:13,250 --> 00:20:16,039
each one of those yellow boxes is an

495
00:20:16,039 --> 00:20:19,490
instruction and this is the ideal graph

496
00:20:19,490 --> 00:20:22,010
visualizer tool we just recently started

497
00:20:22,010 --> 00:20:24,260
using this and it's great you can just

498
00:20:24,260 --> 00:20:25,909
pop over and select which method you

499
00:20:25,909 --> 00:20:28,429
want to look at see how it compiled you

500
00:20:28,429 --> 00:20:32,779
get a nice visualization of flow here's

501
00:20:32,779 --> 00:20:34,700
all the compiler passes we run for this

502
00:20:34,700 --> 00:20:38,630
compilation unit in that pink bar across

503
00:20:38,630 --> 00:20:41,360
the top you can drag that and have it

504
00:20:41,360 --> 00:20:44,149
span whatever number of passes you want

505
00:20:44,149 --> 00:20:46,940
and then it'll show you which codes been

506
00:20:46,940 --> 00:20:48,649
added and which codes been removed or

507
00:20:48,649 --> 00:20:52,460
changed so this is a super super fun new

508
00:20:52,460 --> 00:20:54,980
toy so we can actually use this to see

509
00:20:54,980 --> 00:20:57,140
whether our optimizations are doing what

510
00:20:57,140 --> 00:20:59,539
they're supposed to step-by-step all

511
00:20:59,539 --> 00:21:03,409
along the way so we'll talk about

512
00:21:03,409 --> 00:21:06,649
profiling a little bit I find that a lot

513
00:21:06,649 --> 00:21:07,940
of people don't know what the term call

514
00:21:07,940 --> 00:21:10,669
sight means it's just the location of

515
00:21:10,669 --> 00:21:13,010
the call or the sight of the call so

516
00:21:13,010 --> 00:21:15,529
line one object out execute our call

517
00:21:15,529 --> 00:21:19,399
sight so we're only interested in call

518
00:21:19,399 --> 00:21:22,010
sights right now for our profilers so we

519
00:21:22,010 --> 00:21:23,840
just record which methods being called

520
00:21:23,840 --> 00:21:26,149
at each time and how many times that's

521
00:21:26,149 --> 00:21:29,480
been called that count is really just a

522
00:21:29,480 --> 00:21:31,669
mechanism for determining hotness and

523
00:21:31,669 --> 00:21:34,429
it's absolutely the simplest one that we

524
00:21:34,429 --> 00:21:36,529
could have picked so we might change

525
00:21:36,529 --> 00:21:38,840
that in the future but it's working okay

526
00:21:38,840 --> 00:21:41,419
for right now but we're really

527
00:21:41,419 --> 00:21:44,830
interested in in monomorphic call sights

528
00:21:44,830 --> 00:21:47,690
other VMs can deal with things with with

529
00:21:47,690 --> 00:21:49,820
more than one site but for us again this

530
00:21:49,820 --> 00:21:52,250
is the simplest thing we can do and it

531
00:21:52,250 --> 00:21:54,620
it gets the highest payback yeah the

532
00:21:54,620 --> 00:21:56,390
vast majority of calls in Ruby are

533
00:21:56,390 --> 00:21:58,039
always do the same method

534
00:21:58,039 --> 00:22:02,070
so once we have monomorphic call sites

535
00:22:02,070 --> 00:22:04,409
we can look to see if we can do numeric

536
00:22:04,409 --> 00:22:09,059
specialization and convert that to Java

537
00:22:09,059 --> 00:22:10,769
primitive math instead of actually

538
00:22:10,769 --> 00:22:12,359
calling through the more expensive Ruby

539
00:22:12,359 --> 00:22:15,139
versions of those methods and then the

540
00:22:15,139 --> 00:22:18,570
500-pound gorilla of optimizations we

541
00:22:18,570 --> 00:22:21,059
can start in lighting methods basically

542
00:22:21,059 --> 00:22:23,190
just grab the body out of that method

543
00:22:23,190 --> 00:22:25,080
you're calling and just paste it in

544
00:22:25,080 --> 00:22:27,509
place of where the call was then you

545
00:22:27,509 --> 00:22:29,009
don't have to set up a stack frame or

546
00:22:29,009 --> 00:22:31,320
any other data structures set up because

547
00:22:31,320 --> 00:22:33,149
you're still executing in the original

548
00:22:33,149 --> 00:22:35,969
method now just to be clear the JVM has

549
00:22:35,969 --> 00:22:37,589
been doing inlining for us for years

550
00:22:37,589 --> 00:22:40,259
because we emit bytecode but sometimes

551
00:22:40,259 --> 00:22:42,359
the methods too big sometimes it's

552
00:22:42,359 --> 00:22:44,549
Thursday it could be anything

553
00:22:44,549 --> 00:22:47,339
yeah JVM decides not to do it so this is

554
00:22:47,339 --> 00:22:49,080
our way of kind of getting back at the

555
00:22:49,080 --> 00:22:50,789
JVM saying if you're not gonna inline

556
00:22:50,789 --> 00:22:52,589
this well we're gonna inline it and

557
00:22:52,589 --> 00:22:54,359
you're just gonna take it yeah and we

558
00:22:54,359 --> 00:22:58,649
route we really you we really want to

559
00:22:58,649 --> 00:23:00,690
focus on on the calls where we pass a

560
00:23:00,690 --> 00:23:02,519
block because that's something that that

561
00:23:02,519 --> 00:23:04,799
you'll never never in lines yeah

562
00:23:04,799 --> 00:23:07,950
particularly bad case so this was our

563
00:23:07,950 --> 00:23:11,700
original inliner so we have some Ruby

564
00:23:11,700 --> 00:23:13,529
code on the left just counting down from

565
00:23:13,529 --> 00:23:15,450
a million calling this decrement one

566
00:23:15,450 --> 00:23:17,729
method none on the right is pseudo code

567
00:23:17,729 --> 00:23:19,679
because I don't want to show you ir it

568
00:23:19,679 --> 00:23:21,440
wouldn't fit on this slide anyways so

569
00:23:21,440 --> 00:23:25,879
let's just walk through how this worked

570
00:23:25,879 --> 00:23:29,909
this is a non d optimizing pass so we

571
00:23:29,909 --> 00:23:31,139
still have that check to make sure that

572
00:23:31,139 --> 00:23:33,269
something didn't change if it didn't

573
00:23:33,269 --> 00:23:35,399
change then we just execute the body of

574
00:23:35,399 --> 00:23:37,639
that method

575
00:23:39,270 --> 00:23:42,120
with Wow transitions are we adhere on

576
00:23:42,120 --> 00:23:43,049
the screen Wow

577
00:23:43,049 --> 00:23:45,059
otherwise we just have to fall back and

578
00:23:45,059 --> 00:23:47,159
just start you know doing a method call

579
00:23:47,159 --> 00:23:49,590
again and so this was good because we

580
00:23:49,590 --> 00:23:51,630
didn't have to do Mize and it ended up

581
00:23:51,630 --> 00:23:55,080
being surprisingly simple to write but

582
00:23:55,080 --> 00:23:58,049
there's a couple problems one it

583
00:23:58,049 --> 00:24:02,159
increases the code size of bed and if

584
00:24:02,159 --> 00:24:04,490
you look at these top three uses of AI

585
00:24:04,490 --> 00:24:07,320
you can you can figure out that this is

586
00:24:07,320 --> 00:24:09,419
going to be numeric thought on the

587
00:24:09,419 --> 00:24:10,980
failure case we don't know what that's

588
00:24:10,980 --> 00:24:13,500
going to be and that that defeats any

589
00:24:13,500 --> 00:24:15,779
any other optimizations after that all

590
00:24:15,779 --> 00:24:19,070
right so here's our current inliner

591
00:24:19,070 --> 00:24:21,390
instead of having that if-else statement

592
00:24:21,390 --> 00:24:24,000
we're gonna throw an exception and that

593
00:24:24,000 --> 00:24:25,830
exception is going to mean that we have

594
00:24:25,830 --> 00:24:28,260
to go back to a safe version but now if

595
00:24:28,260 --> 00:24:31,980
you look at the the three uses of AI we

596
00:24:31,980 --> 00:24:33,809
now have a chance to do some numeric

597
00:24:33,809 --> 00:24:36,630
specialization and I guess I call this a

598
00:24:36,630 --> 00:24:39,059
virtuous cycle because this optimization

599
00:24:39,059 --> 00:24:40,770
allowed us to see something else that we

600
00:24:40,770 --> 00:24:42,899
couldn't see before and that's pretty

601
00:24:42,899 --> 00:24:45,020
awesome

602
00:24:45,350 --> 00:24:48,840
here's the basic strategy when we

603
00:24:48,840 --> 00:24:50,880
generate the optimized version when we

604
00:24:50,880 --> 00:24:53,419
create that guard to make sure that

605
00:24:53,419 --> 00:24:56,220
whether we need to fall back or not it

606
00:24:56,220 --> 00:24:58,559
records where we need to go back into

607
00:24:58,559 --> 00:25:00,779
the safe method or an instruction

608
00:25:00,779 --> 00:25:03,539
pointer basically yeah and we throw an

609
00:25:03,539 --> 00:25:06,870
exception and then we dump all the

610
00:25:06,870 --> 00:25:08,640
temporary variables that we have and

611
00:25:08,640 --> 00:25:11,100
then the safe version will be able to

612
00:25:11,100 --> 00:25:13,020
use those same ones because it was a

613
00:25:13,020 --> 00:25:14,909
property we have an IR that all temp

614
00:25:14,909 --> 00:25:16,830
variables are used for a single purpose

615
00:25:16,830 --> 00:25:19,230
so the safe version can still consume

616
00:25:19,230 --> 00:25:22,049
those if we actually look at the

617
00:25:22,049 --> 00:25:24,179
implementation I did this with Ruby

618
00:25:24,179 --> 00:25:26,100
pseudocode again because it would be a

619
00:25:26,100 --> 00:25:29,039
mixture of Java and IR so the inline

620
00:25:29,039 --> 00:25:32,010
methods in the gray box but when the

621
00:25:32,010 --> 00:25:34,529
guard fails we'll raise an exception

622
00:25:34,529 --> 00:25:37,980
with where it's supposed to go we'll set

623
00:25:37,980 --> 00:25:42,090
some state to make sure that the method

624
00:25:42,090 --> 00:25:43,980
clean up stuff doesn't execute from

625
00:25:43,980 --> 00:25:46,740
there things down only want to unlock a

626
00:25:46,740 --> 00:25:48,899
lock once so if we're backing off for

627
00:25:48,899 --> 00:25:50,610
deoptimization purposes we have to say

628
00:25:50,610 --> 00:25:52,890
we're going to do this finally

629
00:25:52,890 --> 00:25:54,930
sure block later on yeah the safe

630
00:25:54,930 --> 00:25:56,600
versions going to handle it for us and

631
00:25:56,600 --> 00:25:59,070
and that's the thing next is we call

632
00:25:59,070 --> 00:26:00,810
into the safe version saying we want to

633
00:26:00,810 --> 00:26:03,720
start at that particular on location and

634
00:26:03,720 --> 00:26:06,960
then we dump the temp virus this ended

635
00:26:06,960 --> 00:26:10,080
up being a lot simpler than I had

636
00:26:10,080 --> 00:26:12,860
originally anticipated

637
00:26:12,860 --> 00:26:16,140
but at this point we created a branch we

638
00:26:16,140 --> 00:26:20,010
got this working we think for tracing

639
00:26:20,010 --> 00:26:22,050
through stuff it seems to work but the

640
00:26:22,050 --> 00:26:24,630
real goal here was to try to figure out

641
00:26:24,630 --> 00:26:26,070
if we had any big problems with this

642
00:26:26,070 --> 00:26:29,460
strategy and so far it seems like it's

643
00:26:29,460 --> 00:26:32,400
working out really well so well we'll

644
00:26:32,400 --> 00:26:36,150
make it robust and clean next but we

645
00:26:36,150 --> 00:26:37,820
always have to give numbers because

646
00:26:37,820 --> 00:26:40,110
people that's the exciting part right

647
00:26:40,110 --> 00:26:41,600
it's time to wake up

648
00:26:41,600 --> 00:26:46,170
so you can pretend for this micro

649
00:26:46,170 --> 00:26:48,270
benchmark that the small loops are array

650
00:26:48,270 --> 00:26:49,920
each that's something that's just

651
00:26:49,920 --> 00:26:51,990
iterating over elements and calling a

652
00:26:51,990 --> 00:26:54,240
block constantly and then big loop is

653
00:26:54,240 --> 00:26:58,730
just calling that as a monomorphic call

654
00:26:58,730 --> 00:27:04,500
so in C Ruby this took about 34 seconds

655
00:27:04,500 --> 00:27:08,640
to run and for us it took 27 point 2 but

656
00:27:08,640 --> 00:27:10,410
once we inline the method and in line

657
00:27:10,410 --> 00:27:12,840
that block back and went down to 6.2

658
00:27:12,840 --> 00:27:15,290
seconds

659
00:27:17,720 --> 00:27:21,029
everyone knows about the Ruby 3x3 thing

660
00:27:21,029 --> 00:27:22,679
that I'm trying to make make Ruby three

661
00:27:22,679 --> 00:27:24,840
three times faster than Ruby - you're

662
00:27:24,840 --> 00:27:29,760
like I feel like in such a dick so but

663
00:27:29,760 --> 00:27:31,559
of course we can we can add our

664
00:27:31,559 --> 00:27:34,260
invokedynamic flags and you can see that

665
00:27:34,260 --> 00:27:35,730
the before is just a little bit faster

666
00:27:35,730 --> 00:27:42,299
than it was and now after it's just

667
00:27:42,299 --> 00:27:44,820
getting better and better as yet so this

668
00:27:44,820 --> 00:27:47,460
is pretty awesome um so there's some

669
00:27:47,460 --> 00:27:49,500
limitations right now we only inline a

670
00:27:49,500 --> 00:27:53,909
single single call site per method we'll

671
00:27:53,909 --> 00:27:55,380
get rid of that limitation once things

672
00:27:55,380 --> 00:27:59,519
are solid as as we've mentioned a couple

673
00:27:59,519 --> 00:28:00,799
times already

674
00:28:00,799 --> 00:28:03,059
typically the JVM does such a good job

675
00:28:03,059 --> 00:28:05,070
in lining method to method calls it only

676
00:28:05,070 --> 00:28:06,269
makes sense to do this when we're

677
00:28:06,269 --> 00:28:10,049
passing a block however if we can do

678
00:28:10,049 --> 00:28:11,549
numeric specialization some other

679
00:28:11,549 --> 00:28:13,590
optimizations that might make more sense

680
00:28:13,590 --> 00:28:15,510
for us to start attempting that with

681
00:28:15,510 --> 00:28:22,019
regular method calls and it's early

682
00:28:22,019 --> 00:28:24,720
proud early early days but hopefully

683
00:28:24,720 --> 00:28:26,100
hopefully soon we'll be able to get this

684
00:28:26,100 --> 00:28:28,590
out as an option for users when I repeat

685
00:28:28,590 --> 00:28:31,710
this is on a branch and do not expect

686
00:28:31,710 --> 00:28:33,179
all your code to get four to six times

687
00:28:33,179 --> 00:28:35,789
faster yeah we found one one sticky area

688
00:28:35,789 --> 00:28:39,480
that we we improved quite a bit and so I

689
00:28:39,480 --> 00:28:40,679
mentioned there was the the very

690
00:28:40,679 --> 00:28:42,059
strategies that we followed over the

691
00:28:42,059 --> 00:28:44,070
years the latest one that we're starting

692
00:28:44,070 --> 00:28:47,039
to explore now in addition to jetting

693
00:28:47,039 --> 00:28:49,220
and better compiler and invoke dynamic

694
00:28:49,220 --> 00:28:52,380
is to actually be able to tweak the JIT

695
00:28:52,380 --> 00:28:54,809
that we that the JVM uses give it better

696
00:28:54,809 --> 00:28:57,409
information about how Ruby code works

697
00:28:57,409 --> 00:29:00,899
and so the experiment that I did before

698
00:29:00,899 --> 00:29:04,080
FOSDEM just last week literally was to

699
00:29:04,080 --> 00:29:07,649
try using the growl JIT which is a pure

700
00:29:07,649 --> 00:29:09,690
Java JIT that this is now getting a lot

701
00:29:09,690 --> 00:29:12,179
of attention truffle Ruby depends on it

702
00:29:12,179 --> 00:29:14,100
a lot of other projects in the JVM world

703
00:29:14,100 --> 00:29:15,990
are depending on this this JIT framework

704
00:29:15,990 --> 00:29:17,880
but the nice thing about it is you can

705
00:29:17,880 --> 00:29:21,120
swap it in through a JVM through some

706
00:29:21,120 --> 00:29:21,929
new feat

707
00:29:21,929 --> 00:29:24,110
new api's that are coming in Java 9 and

708
00:29:24,110 --> 00:29:27,179
we can directly influence how the JIT

709
00:29:27,179 --> 00:29:29,010
works we can give it better information

710
00:29:29,010 --> 00:29:30,990
out that this is a number or that this

711
00:29:30,990 --> 00:29:33,210
is a particular kind of loop or that we

712
00:29:33,210 --> 00:29:35,640
want to specialize some code and so this

713
00:29:35,640 --> 00:29:37,170
is actually starting to pay off pretty

714
00:29:37,170 --> 00:29:39,810
well we've managed to get Gras working

715
00:29:39,810 --> 00:29:42,570
knowing a bit more about JRuby and then

716
00:29:42,570 --> 00:29:45,240
run some benchmarks through it and so if

717
00:29:45,240 --> 00:29:47,940
we look at Toms example just throwing a

718
00:29:47,940 --> 00:29:50,640
few minor tweaks at growl and running it

719
00:29:50,640 --> 00:29:52,950
for even this simple example which which

720
00:29:52,950 --> 00:29:54,330
we didn't think would have a lot of

721
00:29:54,330 --> 00:29:56,190
benefit and you've got six point eight

722
00:29:56,190 --> 00:29:58,110
faster so let's just say let's just say

723
00:29:58,110 --> 00:30:00,930
seven times for that because you know

724
00:30:00,930 --> 00:30:02,700
it's it's within within the margin of

725
00:30:02,700 --> 00:30:06,870
error there and let's actually look at

726
00:30:06,870 --> 00:30:08,160
this a little more graphically so we'll

727
00:30:08,160 --> 00:30:10,230
wrap this up and kind of show what sort

728
00:30:10,230 --> 00:30:12,420
of progress we've made so with the the

729
00:30:12,420 --> 00:30:14,130
blocky loop bench of Toms

730
00:30:14,130 --> 00:30:16,620
we've got Jay Ruby's JIT that does a

731
00:30:16,620 --> 00:30:17,970
certain amount of improvement for us

732
00:30:17,970 --> 00:30:19,830
this is how many times faster that we

733
00:30:19,830 --> 00:30:22,350
are then see Ruby 2.4 the current

734
00:30:22,350 --> 00:30:24,720
version of it so that gets us like

735
00:30:24,720 --> 00:30:27,900
roughly 1.25 times faster if we add

736
00:30:27,900 --> 00:30:29,790
invokedynamic it bumps up a little bit

737
00:30:29,790 --> 00:30:31,590
and we get like one point three five or

738
00:30:31,590 --> 00:30:34,920
one point four times faster then we

739
00:30:34,920 --> 00:30:36,540
start doing the inlining and that makes

740
00:30:36,540 --> 00:30:39,000
a huge difference the cost of the block

741
00:30:39,000 --> 00:30:41,340
overhead and it that intermediate call

742
00:30:41,340 --> 00:30:43,500
really hurts us hurts us a lot more than

743
00:30:43,500 --> 00:30:45,720
C Ruby so being able to inline takes a

744
00:30:45,720 --> 00:30:48,900
lot of that away again in D here like

745
00:30:48,900 --> 00:30:51,210
tom was talking about the virtuous cycle

746
00:30:51,210 --> 00:30:53,040
now that we're able to inline

747
00:30:53,040 --> 00:30:54,600
invokedynamic is actually doing

748
00:30:54,600 --> 00:30:56,040
significantly better job of optimizing

749
00:30:56,040 --> 00:30:58,770
this code so we get another boost up

750
00:30:58,770 --> 00:31:02,240
over seven times faster than C Ruby here

751
00:31:02,240 --> 00:31:04,050
and then the growl thing that I

752
00:31:04,050 --> 00:31:05,760
mentioned it's a smaller bump for this

753
00:31:05,760 --> 00:31:07,440
particular benchmark but that even

754
00:31:07,440 --> 00:31:09,090
brings things up so we're getting close

755
00:31:09,090 --> 00:31:11,460
to an eight and a half nine times faster

756
00:31:11,460 --> 00:31:14,250
on what is a fairly standard sort of

757
00:31:14,250 --> 00:31:16,950
piece of Ruby code now we really wanted

758
00:31:16,950 --> 00:31:18,390
to kind of see how far we could push

759
00:31:18,390 --> 00:31:21,240
this growl tweak and prove it out that

760
00:31:21,240 --> 00:31:22,170
it's going to be something worth

761
00:31:22,170 --> 00:31:24,960
exploring in the future so we do we got

762
00:31:24,960 --> 00:31:26,490
a numeric benchmark that just generates

763
00:31:26,490 --> 00:31:28,800
a mantel bro we're running it with 750

764
00:31:28,800 --> 00:31:32,250
here yeah you should should mention the

765
00:31:32,250 --> 00:31:34,200
the problem with Ruby fixed ones versus

766
00:31:34,200 --> 00:31:36,960
yes so we mentioned a couple times about

767
00:31:36,960 --> 00:31:39,270
numeric specialization the reason that

768
00:31:39,270 --> 00:31:40,350
we want to be able to do our own

769
00:31:40,350 --> 00:31:41,610
specialization

770
00:31:41,610 --> 00:31:44,460
turn it into Java math is because we

771
00:31:44,460 --> 00:31:45,929
need to pass objects all over it's a

772
00:31:45,929 --> 00:31:47,370
dynamic language everything is treated

773
00:31:47,370 --> 00:31:49,440
like an object on the JVM that means

774
00:31:49,440 --> 00:31:51,360
everything has to be an object so every

775
00:31:51,360 --> 00:31:53,340
time you do one plus one we will

776
00:31:53,340 --> 00:31:55,110
construct a new object for fixed num

777
00:31:55,110 --> 00:31:58,020
number two basically and that becomes a

778
00:31:58,020 --> 00:31:59,790
huge overhead for numerical reason to

779
00:31:59,790 --> 00:32:02,520
the unit as you'd imagine we're heating

780
00:32:02,520 --> 00:32:04,440
up the heap too much we're making the GC

781
00:32:04,440 --> 00:32:06,480
do a lot of work and just allocating all

782
00:32:06,480 --> 00:32:08,790
those objects takes a lot of time so

783
00:32:08,790 --> 00:32:10,679
this is a good example of what we can do

784
00:32:10,679 --> 00:32:13,380
when we've got a a JVM JIT that can

785
00:32:13,380 --> 00:32:15,030
actually see that we don't need these

786
00:32:15,030 --> 00:32:17,280
objects and optimize around it get rid

787
00:32:17,280 --> 00:32:19,590
of the allocation so let's take a look

788
00:32:19,590 --> 00:32:22,580
with that with JRuby just with the JIT

789
00:32:22,580 --> 00:32:26,040
we get about 1.5 times faster than C

790
00:32:26,040 --> 00:32:28,110
Ruby here they don't have the object

791
00:32:28,110 --> 00:32:30,450
overhead we do but the fact that the JIT

792
00:32:30,450 --> 00:32:32,850
does such a good job makes up for a lot

793
00:32:32,850 --> 00:32:34,320
of the overhead of these fictional

794
00:32:34,320 --> 00:32:35,790
objects that we have floating around in

795
00:32:35,790 --> 00:32:38,280
the system and in this case if we throw

796
00:32:38,280 --> 00:32:40,770
in both dynamic at it much better again

797
00:32:40,770 --> 00:32:44,160
it doubles it over the over the non in

798
00:32:44,160 --> 00:32:46,440
diversion the plain jet and this is

799
00:32:46,440 --> 00:32:48,960
fairly typical for we for numeric heavy

800
00:32:48,960 --> 00:32:51,210
algorithms we think the JVM is getting a

801
00:32:51,210 --> 00:32:52,799
little bit better visibility into these

802
00:32:52,799 --> 00:32:56,429
numbers now the real payoff is when we

803
00:32:56,429 --> 00:33:00,030
use growth to do this so this is JRuby +

804
00:33:00,030 --> 00:33:02,910
 + invokedynamic + the growl tweaks

805
00:33:02,910 --> 00:33:04,620
that I've been playing with which is

806
00:33:04,620 --> 00:33:07,500
literally a two line patch - Grall to

807
00:33:07,500 --> 00:33:09,059
make it a little bit more aware of our

808
00:33:09,059 --> 00:33:11,910
numeric types and this is now getting

809
00:33:11,910 --> 00:33:15,419
much more interesting so now we're

810
00:33:15,419 --> 00:33:17,970
talking about JRuby being 23 times

811
00:33:17,970 --> 00:33:20,299
faster than C Ruby at this point

812
00:33:20,299 --> 00:33:23,340
competitive with projects like truffle

813
00:33:23,340 --> 00:33:25,530
Ruby and some of the other optimizing

814
00:33:25,530 --> 00:33:27,390
kits that are out there we're finally

815
00:33:27,390 --> 00:33:28,919
able to get some time to work on this

816
00:33:28,919 --> 00:33:31,080
and it's looking very promising so we're

817
00:33:31,080 --> 00:33:32,429
gonna see more on this over the next

818
00:33:32,429 --> 00:33:33,990
year and if you want to help but

819
00:33:33,990 --> 00:33:35,669
spearmint and play with this stuff it

820
00:33:35,669 --> 00:33:38,929
wasn't hard to do this so we welcome

821
00:33:38,929 --> 00:33:40,730
contributions

822
00:33:40,730 --> 00:33:43,440
alright so wrapping things up here

823
00:33:43,440 --> 00:33:45,210
compatibility we're really happy with

824
00:33:45,210 --> 00:33:47,160
we've managed to catch up with C Ruby

825
00:33:47,160 --> 00:33:51,360
hope to have Ruby 2.4 out only a month

826
00:33:51,360 --> 00:33:53,370
or two or three after the actual

827
00:33:53,370 --> 00:33:54,990
official release

828
00:33:54,990 --> 00:33:57,390
performance is solid right now you can

829
00:33:57,390 --> 00:33:59,070
go online and see you can take your

830
00:33:59,070 --> 00:34:01,230
JRuby application and throw it on to or

831
00:34:01,230 --> 00:34:02,640
you take your Ruby application throw it

832
00:34:02,640 --> 00:34:05,370
on to JRuby and get two three five ten

833
00:34:05,370 --> 00:34:06,690
times performance depending on what

834
00:34:06,690 --> 00:34:07,710
you're doing

835
00:34:07,710 --> 00:34:09,480
invokedynamic has given us a lot more

836
00:34:09,480 --> 00:34:12,230
runway for just plain JVM optimizations

837
00:34:12,230 --> 00:34:14,639
but there's a lot more cool stuff we

838
00:34:14,639 --> 00:34:16,110
could do obviously we're doing our own

839
00:34:16,110 --> 00:34:18,119
Len inline are doing our own profiling

840
00:34:18,119 --> 00:34:21,840
and advising the JIT directly show huge

841
00:34:21,840 --> 00:34:24,000
promise for making JRuby that much

842
00:34:24,000 --> 00:34:27,179
faster than it was even a year ago so

843
00:34:27,179 --> 00:34:29,340
try it out let us know if your

844
00:34:29,340 --> 00:34:30,750
applications don't work and if there's

845
00:34:30,750 --> 00:34:32,820
some problems that we can look into let

846
00:34:32,820 --> 00:34:34,770
us know if it goes well we we usually

847
00:34:34,770 --> 00:34:36,418
only hear from people when things are

848
00:34:36,418 --> 00:34:38,730
broken so it'd be really nice if people

849
00:34:38,730 --> 00:34:40,800
would say it worked the first time and

850
00:34:40,800 --> 00:34:42,810
you don't that's all you have to do like

851
00:34:42,810 --> 00:34:44,790
tweet to us or something just so we know

852
00:34:44,790 --> 00:34:46,139
that you're out there and we're not just

853
00:34:46,139 --> 00:34:49,440
all problems and let us know let us know

854
00:34:49,440 --> 00:34:50,760
how things are going and what you think

855
00:34:50,760 --> 00:34:52,730
you might be able to do with JRuby

856
00:34:52,730 --> 00:34:55,409
that's all we've got and there's some

857
00:34:55,409 --> 00:35:06,330
contact information for us Thanks plenty

858
00:35:06,330 --> 00:35:07,530
of time for questions all right

859
00:35:07,530 --> 00:35:11,330
who's first right there in the middle

860
00:35:22,980 --> 00:35:25,750
so are other things other things that

861
00:35:25,750 --> 00:35:28,630
are coming in Java 9 yes other things

862
00:35:28,630 --> 00:35:30,970
that are coming in Java 9 along with the

863
00:35:30,970 --> 00:35:33,579
the growl and JVM CI stuff

864
00:35:33,579 --> 00:35:37,599
so first clarifying growl I'm pretty

865
00:35:37,599 --> 00:35:40,089
sure it's not going to be in Java 9 but

866
00:35:40,089 --> 00:35:42,160
the API that allows you to just swap it

867
00:35:42,160 --> 00:35:44,140
in and replace the existing JIT that

868
00:35:44,140 --> 00:35:47,710
will be there so in theory once Java 9

869
00:35:47,710 --> 00:35:50,560
is out in six months a year I'm not sure

870
00:35:50,560 --> 00:35:51,760
what they pushed it back to you now but

871
00:35:51,760 --> 00:35:54,160
once job in nine is out you could be

872
00:35:54,160 --> 00:35:57,700
running job in JRuby on Java 9 maybe gem

873
00:35:57,700 --> 00:36:00,760
install JRuby growl and then we'll just

874
00:36:00,760 --> 00:36:02,650
install that as the JIT and you get that

875
00:36:02,650 --> 00:36:04,839
23 per 4 times performance ideally

876
00:36:04,839 --> 00:36:06,750
that's what we'd like to be able to do

877
00:36:06,750 --> 00:36:09,880
other than that ability to swap the JIT

878
00:36:09,880 --> 00:36:13,480
in we're interested in how jigsaw might

879
00:36:13,480 --> 00:36:15,040
make things work better for us if

880
00:36:15,040 --> 00:36:17,109
there's ways that we can reduce some of

881
00:36:17,109 --> 00:36:19,810
our dependency loading issues job and I

882
00:36:19,810 --> 00:36:21,369
honest supposed to also come with a

883
00:36:21,369 --> 00:36:23,650
closed source ahead of time compiler

884
00:36:23,650 --> 00:36:25,660
that we're interested in playing with to

885
00:36:25,660 --> 00:36:27,190
see if we can get our startup time a

886
00:36:27,190 --> 00:36:29,980
little bit closer to C Ruby and then

887
00:36:29,980 --> 00:36:31,420
there's various language features that

888
00:36:31,420 --> 00:36:33,790
come along wewe don't get to use a lot

889
00:36:33,790 --> 00:36:37,030
of that stuff in JRuby proper because we

890
00:36:37,030 --> 00:36:38,619
are always supporting at least one Java

891
00:36:38,619 --> 00:36:40,690
version back so right now we support

892
00:36:40,690 --> 00:36:42,550
Java 7 which means we can't use Java 8

893
00:36:42,550 --> 00:36:45,099
lambdas when Java 9 comes out we'll

894
00:36:45,099 --> 00:36:48,280
reevaluate that maybe JRuby 9.3 will be

895
00:36:48,280 --> 00:36:50,530
only Java 8 plus then we can start

896
00:36:50,530 --> 00:36:52,089
getting more of those cool features but

897
00:36:52,089 --> 00:36:54,460
the JVM CI thing is really the biggest

898
00:36:54,460 --> 00:36:57,190
promising item for us do you recall if

899
00:36:57,190 --> 00:37:00,190
there's any file system related

900
00:37:00,190 --> 00:37:04,150
improvements not that I know of it seems

901
00:37:04,150 --> 00:37:05,500
like there's always one or two things

902
00:37:05,500 --> 00:37:06,700
yeah there's a lot of those

903
00:37:06,700 --> 00:37:08,470
little-little system level things I

904
00:37:08,470 --> 00:37:09,609
think they've done some improvements to

905
00:37:09,609 --> 00:37:12,700
the process API is maybe Java Nigel

906
00:37:12,700 --> 00:37:14,740
suppose to have some early versions of a

907
00:37:14,740 --> 00:37:19,030
Java built-in FFI for calling C code not

908
00:37:19,030 --> 00:37:21,099
exposed as a public API yet but we're

909
00:37:21,099 --> 00:37:22,300
interested in playing with that and

910
00:37:22,300 --> 00:37:24,130
trying to hook into it

911
00:37:24,130 --> 00:37:41,259
other questions yes memory wise yes so

912
00:37:41,259 --> 00:37:43,930
quick so comparisons of C Ruby and J

913
00:37:43,930 --> 00:37:47,289
Ruby memory wise so in general if you're

914
00:37:47,289 --> 00:37:49,619
doing just a single process application

915
00:37:49,619 --> 00:37:53,289
we use quite a bit more memory at least

916
00:37:53,289 --> 00:37:55,660
twice as much memory as C Ruby for a

917
00:37:55,660 --> 00:37:58,569
typical rails application and most of

918
00:37:58,569 --> 00:38:01,630
that is because the JVM GC is very

919
00:38:01,630 --> 00:38:03,130
advanced than it needs lots of room to

920
00:38:03,130 --> 00:38:05,079
breathe the JIT takes up a lot of space

921
00:38:05,079 --> 00:38:07,150
the just the the inner workings of the

922
00:38:07,150 --> 00:38:09,160
JVM itself take up more space than an

923
00:38:09,160 --> 00:38:12,910
MRI does but what we've found is people

924
00:38:12,910 --> 00:38:15,339
don't typically run just one C Ruby

925
00:38:15,339 --> 00:38:18,039
rails instance they usually run five or

926
00:38:18,039 --> 00:38:20,559
ten or 500 depending on how big your

927
00:38:20,559 --> 00:38:23,109
application is and in those cases we

928
00:38:23,109 --> 00:38:25,479
very quickly will do better on memory

929
00:38:25,479 --> 00:38:27,609
use you can take a single JRuby instance

930
00:38:27,609 --> 00:38:30,009
run 500 threads through it rather than

931
00:38:30,009 --> 00:38:33,569
500 processes and that that 500 mega

932
00:38:33,569 --> 00:38:36,819
application is now your entire site and

933
00:38:36,819 --> 00:38:37,809
don't have to worry about all those

934
00:38:37,809 --> 00:38:39,969
processes anymore so that's that's kind

935
00:38:39,969 --> 00:38:42,400
of a rough breakdown we try every

936
00:38:42,400 --> 00:38:46,180
release to to look for egregious overuse

937
00:38:46,180 --> 00:38:48,940
of memory and reduce that down but

938
00:38:48,940 --> 00:38:50,199
there's only only so much we can do

939
00:38:50,199 --> 00:38:51,819
being on top of the JVM just the way

940
00:38:51,819 --> 00:38:54,849
that it works internally so yeah if

941
00:38:54,849 --> 00:38:56,529
you're running a big application and can

942
00:38:56,529 --> 00:38:58,509
get rid of a bunch of MRI instances it

943
00:38:58,509 --> 00:39:01,059
will do great you have 300 MRI instances

944
00:39:01,059 --> 00:39:02,589
you should probably look at making your

945
00:39:02,589 --> 00:39:05,170
app thread safe and you'll save a lot of

946
00:39:05,170 --> 00:39:07,299
money try JRuby have we've had stories

947
00:39:07,299 --> 00:39:09,309
before people have told us they went

948
00:39:09,309 --> 00:39:14,920
from running 40 or 50 extra large don't

949
00:39:14,920 --> 00:39:18,489
don't was like it was like 35 extra

950
00:39:18,489 --> 00:39:21,459
large instances on ec2 and anybody who's

951
00:39:21,459 --> 00:39:23,049
ever done an ec2 knows that that's a

952
00:39:23,049 --> 00:39:25,269
bank load of money right there every

953
00:39:25,269 --> 00:39:28,180
month like $35,000 or something and they

954
00:39:28,180 --> 00:39:30,670
took that those 35 extra large instances

955
00:39:30,670 --> 00:39:31,539
with C Ruby

956
00:39:31,539 --> 00:39:35,319
moved to J Ruby on like 15 mediums or

957
00:39:35,319 --> 00:39:36,320
something

958
00:39:36,320 --> 00:39:39,320
like $30,000 savings every month just by

959
00:39:39,320 --> 00:39:41,480
making the effort to move to Jeremy and

960
00:39:41,480 --> 00:39:43,070
that was reduction in memory and better

961
00:39:43,070 --> 00:39:46,730
use of the resources all right anything

962
00:39:46,730 --> 00:40:10,670
else yeah right right so the question is

963
00:40:10,670 --> 00:40:12,410
why don't we just follow the same

964
00:40:12,410 --> 00:40:15,500
versioning scheme that C Ruby does well

965
00:40:15,500 --> 00:40:16,850
the biggest the biggest answer is that

966
00:40:16,850 --> 00:40:18,290
we we need the freedom to do our own

967
00:40:18,290 --> 00:40:21,350
patch releases for various fixes and so

968
00:40:21,350 --> 00:40:23,300
if it was a two three one and we use

969
00:40:23,300 --> 00:40:25,520
that as our version number do we do 2 3

970
00:40:25,520 --> 00:40:30,560
1 1 or 2 3 1 - JRuby 1 1 or something it

971
00:40:30,560 --> 00:40:33,500
just starts to get confusing and we also

972
00:40:33,500 --> 00:40:35,210
have our we will have completely

973
00:40:35,210 --> 00:40:36,830
different issues like we'll have our own

974
00:40:36,830 --> 00:40:38,480
security releases that we need to have

975
00:40:38,480 --> 00:40:40,820
the freedom to Rev our version number

976
00:40:40,820 --> 00:40:43,700
for that well and in major releases if

977
00:40:43,700 --> 00:40:47,210
we want to break our API is we we have

978
00:40:47,210 --> 00:40:49,100
to pick a major number right right we

979
00:40:49,100 --> 00:40:50,840
don't we wouldn't want to be bound to a

980
00:40:50,840 --> 00:40:52,580
C Ruby's release schedule for major

981
00:40:52,580 --> 00:40:55,010
releases if we need to do a breaking

982
00:40:55,010 --> 00:40:56,240
change in the middle of a year or

983
00:40:56,240 --> 00:40:58,569
something

984
00:41:03,569 --> 00:41:07,269
hmm right right so what do you mean by

985
00:41:07,269 --> 00:41:21,039
not tracking that then okay okay so if

986
00:41:21,039 --> 00:41:22,930
you start up JRuby right now with JRE

987
00:41:22,930 --> 00:41:24,460
one nine one seven the most current

988
00:41:24,460 --> 00:41:26,859
version it's a couple minor versions of

989
00:41:26,859 --> 00:41:29,049
see Ruby support back so it's two three

990
00:41:29,049 --> 00:41:31,210
one versus two three three so the number

991
00:41:31,210 --> 00:41:34,599
that we report is very roughly what the

992
00:41:34,599 --> 00:41:37,059
feature levels are for for Ruby itself

993
00:41:37,059 --> 00:41:39,759
but more than that they represent which

994
00:41:39,759 --> 00:41:41,650
version of the standard library we ship

995
00:41:41,650 --> 00:41:43,930
along with it we always try to be

996
00:41:43,930 --> 00:41:46,390
current with features and with bugs and

997
00:41:46,390 --> 00:41:49,359
whatnot but Ruby's minor versions

998
00:41:49,359 --> 00:41:51,069
generally don't make feature changes so

999
00:41:51,069 --> 00:41:53,200
much standard library stuff may change

1000
00:41:53,200 --> 00:41:55,569
so really all you'd be missing out on is

1001
00:41:55,569 --> 00:41:58,240
any any of the patches that happen in

1002
00:41:58,240 --> 00:42:00,369
the standard library and if there's any

1003
00:42:00,369 --> 00:42:02,140
bugs that we might have ported over or

1004
00:42:02,140 --> 00:42:04,960
something we need to catch up on those

1005
00:42:04,960 --> 00:42:07,960
patches so it's not it's not much that

1006
00:42:07,960 --> 00:42:10,509
you would miss out and we should

1007
00:42:10,509 --> 00:42:13,089
probably update that yeah for nine money

1008
00:42:13,089 --> 00:42:14,890
well yeah for nine one eight if we do

1009
00:42:14,890 --> 00:42:16,749
that then we'll have updated to four

1010
00:42:16,749 --> 00:42:19,359
standard library in 92 of course it just

1011
00:42:19,359 --> 00:42:21,210
already at branch you can try it out

1012
00:42:21,210 --> 00:42:24,359
anything else

1013
00:42:25,390 --> 00:42:37,700
all right bundle that's the bet bundle

1014
00:42:37,700 --> 00:42:39,350
install and that would pretty much tell

1015
00:42:39,350 --> 00:42:42,950
you the first steps you need to take by

1016
00:42:42,950 --> 00:42:45,050
far the first problem people run into is

1017
00:42:45,050 --> 00:42:46,730
they've got C extensions that they may

1018
00:42:46,730 --> 00:42:48,860
not even have known that they depended

1019
00:42:48,860 --> 00:42:51,260
on that will not have a JRE version

1020
00:42:51,260 --> 00:42:54,140
potentially most of the key ones do like

1021
00:42:54,140 --> 00:42:57,980
Jason nokogiri most of the parser api's

1022
00:42:57,980 --> 00:43:00,260
that are out there usually have a JRuby

1023
00:43:00,260 --> 00:43:02,000
version that works fine sometimes

1024
00:43:02,000 --> 00:43:03,590
there's a ruby version that you can fall

1025
00:43:03,590 --> 00:43:06,590
back on and sometimes you need to go and

1026
00:43:06,590 --> 00:43:07,940
see if there's a Java library you can

1027
00:43:07,940 --> 00:43:09,380
replace that with if it's something that

1028
00:43:09,380 --> 00:43:11,450
you have a direct dependency on but we

1029
00:43:11,450 --> 00:43:12,950
do like to know what those C extensions

1030
00:43:12,950 --> 00:43:14,420
are it's hard to tell which ones people

1031
00:43:14,420 --> 00:43:16,970
are using so yeah bundle install look

1032
00:43:16,970 --> 00:43:18,980
for libraries that that have C

1033
00:43:18,980 --> 00:43:20,690
extensions or don't install on JRuby and

1034
00:43:20,690 --> 00:43:23,450
that's your first step the second step

1035
00:43:23,450 --> 00:43:25,850
is try starting it up and you know run

1036
00:43:25,850 --> 00:43:27,410
your test suite and see what what the

1037
00:43:27,410 --> 00:43:29,960
fails and what doesn't ideally if you

1038
00:43:29,960 --> 00:43:31,970
get all the libraries to install we

1039
00:43:31,970 --> 00:43:33,500
should pass all the tests exactly the

1040
00:43:33,500 --> 00:43:36,350
same as MRI if we don't it's probably

1041
00:43:36,350 --> 00:43:38,180
our problem and you should come to us

1042
00:43:38,180 --> 00:43:40,520
with a bug report at that point or if we

1043
00:43:40,520 --> 00:43:42,200
know it's a known issue that there's a

1044
00:43:42,200 --> 00:43:43,520
workaround for we can provide that

1045
00:43:43,520 --> 00:43:46,070
information back to you and then you go

1046
00:43:46,070 --> 00:43:47,720
from there if once you get past the C

1047
00:43:47,720 --> 00:43:49,400
extension thing and you're using mostly

1048
00:43:49,400 --> 00:43:52,430
pure Ruby stuff for JRuby versions it's

1049
00:43:52,430 --> 00:43:55,190
the this the last 10 percent is what

1050
00:43:55,190 --> 00:43:56,390
what are you working on at that point

1051
00:43:56,390 --> 00:43:58,190
that that's the biggest hurdle for folks

1052
00:43:58,190 --> 00:44:00,640
to get across

1053
00:44:01,520 --> 00:44:04,480
anything else

1054
00:44:05,720 --> 00:44:07,880
all right thanks again thank you very

1055
00:44:07,880 --> 00:44:08,980
much

1056
00:44:08,980 --> 00:44:16,710
[Applause]

