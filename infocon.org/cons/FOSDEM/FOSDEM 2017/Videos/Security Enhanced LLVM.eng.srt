1
00:00:11,059 --> 00:00:17,520
well security you may recognize those

2
00:00:17,520 --> 00:00:20,220
buildings those organizations are very

3
00:00:20,220 --> 00:00:21,990
concerned about some of their operations

4
00:00:21,990 --> 00:00:52,699
security okay thank you

5
00:00:57,329 --> 00:00:59,469
I'd hate suggest the first two

6
00:00:59,469 --> 00:01:01,180
organizations were responsible for those

7
00:01:01,180 --> 00:01:09,420
words not making it onto the tape so

8
00:01:09,420 --> 00:01:11,979
databases data centers we want the code

9
00:01:11,979 --> 00:01:18,070
in there to be secure and then of course

10
00:01:18,070 --> 00:01:20,950
the ubiquitous smart card whether it's

11
00:01:20,950 --> 00:01:23,500
your bank details in this example here

12
00:01:23,500 --> 00:01:26,229
your medical details or your transport

13
00:01:26,229 --> 00:01:29,679
details you don't want your bank account

14
00:01:29,679 --> 00:01:32,080
being broken into the train company

15
00:01:32,080 --> 00:01:33,580
doesn't want you taking free rides on

16
00:01:33,580 --> 00:01:35,560
the train so at the very smallest level

17
00:01:35,560 --> 00:01:37,390
as well as the great big data centers

18
00:01:37,390 --> 00:01:42,479
security matters and when it goes wrong

19
00:01:42,479 --> 00:01:44,979
first of all when someone hacks an

20
00:01:44,979 --> 00:01:50,009
Internet toilet it's quite funny when

21
00:01:50,820 --> 00:01:53,530
you discover that AHS Rams latest

22
00:01:53,530 --> 00:01:55,929
lightbulb has about a textbook

23
00:01:55,929 --> 00:01:58,300
description of how to get security wrong

24
00:01:58,300 --> 00:02:00,009
in that every hole in the books there

25
00:02:00,009 --> 00:02:03,009
and it happens to give a nice open hole

26
00:02:03,009 --> 00:02:07,200
into your home network we start worrying

27
00:02:07,200 --> 00:02:11,410
but then we get this you'll recognize

28
00:02:11,410 --> 00:02:16,799
the Chinese webcam and the my robot net

29
00:02:16,799 --> 00:02:20,560
which took over which management issue

30
00:02:20,560 --> 00:02:23,200
some very important security attacks by

31
00:02:23,200 --> 00:02:26,560
taking over Internet connected webcams

32
00:02:26,560 --> 00:02:29,200
and at that point security stopped being

33
00:02:29,200 --> 00:02:32,380
fun or a bit of oh my god - this really

34
00:02:32,380 --> 00:02:33,549
does actually matter

35
00:02:33,549 --> 00:02:38,459
and it matters particularly because of

36
00:02:38,459 --> 00:02:40,630
what is known as the Internet of Things

37
00:02:40,630 --> 00:02:43,060
perhaps more important correction the

38
00:02:43,060 --> 00:02:45,810
internet of sensors but the fact that

39
00:02:45,810 --> 00:02:48,459
increasing amount of sensed information

40
00:02:48,459 --> 00:02:51,700
about your environment is connected to

41
00:02:51,700 --> 00:02:55,030
the Internet and can leak out there so

42
00:02:55,030 --> 00:02:59,799
security becomes more and more impending

43
00:02:59,799 --> 00:03:03,040
on our everyday lives and some of the

44
00:03:03,040 --> 00:03:05,829
attacks will affect us the ability to

45
00:03:05,829 --> 00:03:07,870
power cycle

46
00:03:07,870 --> 00:03:09,370
all the heating systems in the country

47
00:03:09,370 --> 00:03:12,220
and then take out the National Grid so

48
00:03:12,220 --> 00:03:14,260
that no one has any power means people

49
00:03:14,260 --> 00:03:19,540
die on operating tables so why the

50
00:03:19,540 --> 00:03:22,780
compiler this is although it's the LLVM

51
00:03:22,780 --> 00:03:24,700
dev room the techniques I'm talking

52
00:03:24,700 --> 00:03:27,430
about are entirely generic so I've put

53
00:03:27,430 --> 00:03:29,920
two well-known free and open-source

54
00:03:29,920 --> 00:03:33,610
compilers there LLVM and GCC compiling

55
00:03:33,610 --> 00:03:36,640
to run on a computer and increasingly

56
00:03:36,640 --> 00:03:37,870
friends and how things that may be a

57
00:03:37,870 --> 00:03:41,260
very very small computer but why the

58
00:03:41,260 --> 00:03:44,920
compiler well your c or c++ embedded

59
00:03:44,920 --> 00:03:47,620
code will go through the compiler even

60
00:03:47,620 --> 00:03:49,959
if you have something like Java which

61
00:03:49,959 --> 00:03:51,519
you think of as sort being interpreted

62
00:03:51,519 --> 00:03:53,590
it's interpreted via bit code and

63
00:03:53,590 --> 00:03:55,390
something like a compiler is going to

64
00:03:55,390 --> 00:03:59,650
generate that bytecode and even your

65
00:03:59,650 --> 00:04:01,480
assembler goes through the compiler

66
00:04:01,480 --> 00:04:03,400
almost all code goes through the

67
00:04:03,400 --> 00:04:05,200
compiler the exception probably being

68
00:04:05,200 --> 00:04:07,060
the sort of scripting language that is

69
00:04:07,060 --> 00:04:11,799
source interpreted and for those in the

70
00:04:11,799 --> 00:04:13,450
legacy place people who actually write

71
00:04:13,450 --> 00:04:15,310
hexadecimal machine code and just put

72
00:04:15,310 --> 00:04:18,668
the numbers in their machine but the

73
00:04:18,668 --> 00:04:21,728
point of using the compiler is security

74
00:04:21,728 --> 00:04:24,760
is a whole system problem and on the

75
00:04:24,760 --> 00:04:27,190
whole the compiler gets to look at

76
00:04:27,190 --> 00:04:30,160
almost all the code so it's a very good

77
00:04:30,160 --> 00:04:32,380
tool if you want to see is my code

78
00:04:32,380 --> 00:04:34,270
secure the compiler is quite a good

79
00:04:34,270 --> 00:04:39,039
place to put that functionality so let's

80
00:04:39,039 --> 00:04:43,539
have a look at some of that there's two

81
00:04:43,539 --> 00:04:47,610
ways the compiler can help first of all

82
00:04:47,610 --> 00:04:51,639
it can tell you if your code looks like

83
00:04:51,639 --> 00:04:54,370
it's doing bad things it's a helpful

84
00:04:54,370 --> 00:04:56,349
assistant it's warning you this looks

85
00:04:56,349 --> 00:04:56,860
bad

86
00:04:56,860 --> 00:04:59,320
just as the compiler will today warn you

87
00:04:59,320 --> 00:05:01,030
you appear to have an argument your

88
00:05:01,030 --> 00:05:03,099
function you're not actually using did

89
00:05:03,099 --> 00:05:05,320
you mean this so there's that warning

90
00:05:05,320 --> 00:05:08,380
roll where we can help and secondly

91
00:05:08,380 --> 00:05:10,690
there's the heavy lifting role but there

92
00:05:10,690 --> 00:05:12,580
are some very well-known and established

93
00:05:12,580 --> 00:05:15,370
secure programming techniques that don't

94
00:05:15,370 --> 00:05:17,770
get widely used because they're a right

95
00:05:17,770 --> 00:05:21,050
royal pain to actually code up and

96
00:05:21,050 --> 00:05:23,270
compiler can help by hiding some of that

97
00:05:23,270 --> 00:05:30,199
for you so we've talked about this

98
00:05:30,199 --> 00:05:32,360
before my colleague Simon Cook who's in

99
00:05:32,360 --> 00:05:35,409
the back of the room over there spoke in

100
00:05:35,409 --> 00:05:38,659
the elevator Ellis meeting about using

101
00:05:38,659 --> 00:05:40,970
LLVM to guarantee program integrity and

102
00:05:40,970 --> 00:05:42,620
that's all part of the security thing

103
00:05:42,620 --> 00:05:44,840
you can only retorque about the security

104
00:05:44,840 --> 00:05:46,069
of your program if you have some

105
00:05:46,069 --> 00:05:48,860
confidence about its integrity and that

106
00:05:48,860 --> 00:05:52,060
was really dressing how to deal with

107
00:05:52,060 --> 00:05:54,139
specialist hardware hardware that

108
00:05:54,139 --> 00:05:55,460
provides some sort of sort for

109
00:05:55,460 --> 00:05:57,169
instruction and support for instruction

110
00:05:57,169 --> 00:05:59,539
integrity and control flow integrity and

111
00:05:59,539 --> 00:06:01,129
in order to do that the compiler needs

112
00:06:01,129 --> 00:06:02,930
to understand that and write code that

113
00:06:02,930 --> 00:06:06,020
matches that and he talked about the

114
00:06:06,020 --> 00:06:07,759
attribute protected that we've added for

115
00:06:07,759 --> 00:06:09,259
a production compiler for one customer

116
00:06:09,259 --> 00:06:12,560
that does exactly that I'm not going to

117
00:06:12,560 --> 00:06:14,090
repeat that because you can watch that

118
00:06:14,090 --> 00:06:19,940
on the LLVM dev meeting videos some of

119
00:06:19,940 --> 00:06:22,340
the things that we've already done are

120
00:06:22,340 --> 00:06:28,069
very simple here is my security program

121
00:06:28,069 --> 00:06:29,539
at which it becomes clear I'm not

122
00:06:29,539 --> 00:06:32,240
actually a security programmer I've got

123
00:06:32,240 --> 00:06:33,919
a pro I've got a function called Mangal

124
00:06:33,919 --> 00:06:36,590
which obfuscates my secure key by

125
00:06:36,590 --> 00:06:38,029
reversing all its bytes

126
00:06:38,029 --> 00:06:41,990
all its nibbles so there it is I give it

127
00:06:41,990 --> 00:06:45,080
an argument kay and it returns a value

128
00:06:45,080 --> 00:06:47,120
with all the nibbles swapped around and

129
00:06:47,120 --> 00:06:48,319
that's great because then I can throw

130
00:06:48,319 --> 00:06:50,120
away Kay and no one will guess what my

131
00:06:50,120 --> 00:06:53,389
original key was so let's have a look at

132
00:06:53,389 --> 00:06:56,990
how that behaves well there we are in

133
00:06:56,990 --> 00:06:59,120
the main program I've given it a string

134
00:06:59,120 --> 00:07:01,190
as an argument which it will convert

135
00:07:01,190 --> 00:07:04,099
into a value using a 2i and pass it to

136
00:07:04,099 --> 00:07:06,110
my argument and I've got some arguments

137
00:07:06,110 --> 00:07:07,460
so let's have a look what happens next

138
00:07:07,460 --> 00:07:10,819
so we go in and we call our function and

139
00:07:10,819 --> 00:07:12,740
there's our key because that happens to

140
00:07:12,740 --> 00:07:15,620
be dead beef in decimal and initial

141
00:07:15,620 --> 00:07:19,069
value of res is 0 and then let's go

142
00:07:19,069 --> 00:07:20,419
round the loop and get to the end of

143
00:07:20,419 --> 00:07:22,940
that function and return and so we've

144
00:07:22,940 --> 00:07:24,440
inverted all the values and we've

145
00:07:24,440 --> 00:07:26,569
returned it and so Kay an our output

146
00:07:26,569 --> 00:07:28,580
there from the mangle function has is

147
00:07:28,580 --> 00:07:31,280
dead beef spelt backwards

148
00:07:31,280 --> 00:07:34,070
and that's it we're back in Maine we've

149
00:07:34,070 --> 00:07:35,570
finished our program and we've thrown

150
00:07:35,570 --> 00:07:39,620
away our key except we haven't because

151
00:07:39,620 --> 00:07:41,330
we've left it lying on a bit of dead

152
00:07:41,330 --> 00:07:43,100
stack now when we next call a function

153
00:07:43,100 --> 00:07:45,169
it'll get possibly wiped out but it's

154
00:07:45,169 --> 00:07:47,360
sitting there lying in memory and if I

155
00:07:47,360 --> 00:07:48,860
do something evil which on this

156
00:07:48,860 --> 00:07:50,870
particular architecture is taking the

157
00:07:50,870 --> 00:07:52,550
address of my local variable and looking

158
00:07:52,550 --> 00:07:54,980
a couple of words further on lo and

159
00:07:54,980 --> 00:07:58,150
behold I can suck out my original key

160
00:07:58,150 --> 00:08:05,290
now the simple thing we can do is

161
00:08:05,290 --> 00:08:07,400
something like this let's have a new

162
00:08:07,400 --> 00:08:10,580
attribute called arrays stack an arrays

163
00:08:10,580 --> 00:08:12,650
stack adds to the epilogue of any

164
00:08:12,650 --> 00:08:15,440
function a small piece of code which

165
00:08:15,440 --> 00:08:17,540
just write zero over the entire stack

166
00:08:17,540 --> 00:08:20,480
frame so now when I return I can help

167
00:08:20,480 --> 00:08:22,010
myself the next time it's just gone been

168
00:08:22,010 --> 00:08:25,610
zeroed and of course you can then

169
00:08:25,610 --> 00:08:28,180
generalize that doesn't have to be 0

170
00:08:28,180 --> 00:08:30,979
let's give it an attribute with argument

171
00:08:30,979 --> 00:08:32,599
and we can turn it all into alternating

172
00:08:32,599 --> 00:08:37,940
bits a a a and indeed all of those are

173
00:08:37,940 --> 00:08:38,539
fine

174
00:08:38,539 --> 00:08:40,339
you're just fine various things going on

175
00:08:40,339 --> 00:08:43,570
you can even go one further and have a

176
00:08:43,570 --> 00:08:47,450
randomized stack thing which just writes

177
00:08:47,450 --> 00:08:50,780
random values on the stack that has what

178
00:08:50,780 --> 00:08:52,940
may be a benefit in that if you've got

179
00:08:52,940 --> 00:08:54,500
the sort of code that's roaming around

180
00:08:54,500 --> 00:08:56,420
off the end of the stack it's probably

181
00:08:56,420 --> 00:08:57,920
going to behave erratically because it's

182
00:08:57,920 --> 00:08:59,150
going to be picking out random variables

183
00:08:59,150 --> 00:09:01,850
that may be a good thing or you may be

184
00:09:01,850 --> 00:09:04,250
in the category that says I don't like

185
00:09:04,250 --> 00:09:05,720
debugging programs where they

186
00:09:05,720 --> 00:09:07,040
deliberately behave differently every

187
00:09:07,040 --> 00:09:11,630
time I try and look at them you take you

188
00:09:11,630 --> 00:09:13,430
take your choice there that's a

189
00:09:13,430 --> 00:09:15,050
straightforward thing that comes in the

190
00:09:15,050 --> 00:09:16,850
category of something we've done it's

191
00:09:16,850 --> 00:09:19,790
not currently in a public compiler one

192
00:09:19,790 --> 00:09:22,160
of the things that we do is we work for

193
00:09:22,160 --> 00:09:24,530
a lot of customers writing them LLVM and

194
00:09:24,530 --> 00:09:27,380
GCC compilers for chips that are not yet

195
00:09:27,380 --> 00:09:29,120
out there and therefore they don't want

196
00:09:29,120 --> 00:09:30,589
us to talk about them or go public

197
00:09:30,589 --> 00:09:31,820
because they don't want to spoil their

198
00:09:31,820 --> 00:09:34,430
big hit when it all comes out so this

199
00:09:34,430 --> 00:09:38,150
exists for a processor that if I told

200
00:09:38,150 --> 00:09:41,350
you about it I'd have to shoot you'll

201
00:09:42,410 --> 00:09:47,689
that's now that's being recorded as well

202
00:09:47,780 --> 00:09:50,220
so let's go bit further so that was

203
00:09:50,220 --> 00:09:51,990
about solving one particular function

204
00:09:51,990 --> 00:09:54,660
what about set jump and long jump so

205
00:09:54,660 --> 00:09:56,550
here we are I have my top function and

206
00:09:56,550 --> 00:09:58,230
it calls a load of functions and he goes

207
00:09:58,230 --> 00:09:59,700
through something called middle function

208
00:09:59,700 --> 00:10:02,460
and the but which takes a which happens

209
00:10:02,460 --> 00:10:04,110
to have a key in it because all my key

210
00:10:04,110 --> 00:10:08,100
is called K 32-bit key and then she gets

211
00:10:08,100 --> 00:10:09,240
the bottom where it's got its jump

212
00:10:09,240 --> 00:10:10,680
buffer and it does a long jump back up

213
00:10:10,680 --> 00:10:15,360
to the top so here we are we're in far

214
00:10:15,360 --> 00:10:18,690
funk all's going well and there's my

215
00:10:18,690 --> 00:10:20,400
cryptographic key sitting in my middle

216
00:10:20,400 --> 00:10:25,110
function and then I return and now I've

217
00:10:25,110 --> 00:10:28,110
still left my function in the middle now

218
00:10:28,110 --> 00:10:30,300
unless all my functions have been

219
00:10:30,300 --> 00:10:33,780
labeled with the attribute clear stack

220
00:10:33,780 --> 00:10:35,880
or randomized stack erase tackle

221
00:10:35,880 --> 00:10:39,060
randomized stack I'm not going to get

222
00:10:39,060 --> 00:10:43,080
rid of that and indeed the way set jump

223
00:10:43,080 --> 00:10:45,360
works it does typically work by just

224
00:10:45,360 --> 00:10:46,860
going back to where you started from

225
00:10:46,860 --> 00:10:48,600
it's not going to unwind the stack

226
00:10:48,600 --> 00:10:50,700
anyway so none of that's gonna work very

227
00:10:50,700 --> 00:10:54,300
cleanly however since we know where we

228
00:10:54,300 --> 00:10:55,740
came from and where we're going to in

229
00:10:55,740 --> 00:10:57,840
long jump there's no reason in principle

230
00:10:57,840 --> 00:10:59,940
why long jump couldn't wipe out its

231
00:10:59,940 --> 00:11:01,590
entire stack now we could do it by

232
00:11:01,590 --> 00:11:03,330
having a special long jump function long

233
00:11:03,330 --> 00:11:07,290
I'm secure but added that code or we

234
00:11:07,290 --> 00:11:09,660
could have minus F arrays stack which

235
00:11:09,660 --> 00:11:12,120
just says whatever the function or even

236
00:11:12,120 --> 00:11:14,220
if it's a long jump function arrays the

237
00:11:14,220 --> 00:11:16,320
stack as you return so you never leave

238
00:11:16,320 --> 00:11:18,390
stuff lying around on the stack or you

239
00:11:18,390 --> 00:11:21,030
could erase it to a particular value or

240
00:11:21,030 --> 00:11:22,590
you could raise it raise it to a random

241
00:11:22,590 --> 00:11:28,290
value and that is all fairly

242
00:11:28,290 --> 00:11:30,510
straightforward we've done most of that

243
00:11:30,510 --> 00:11:31,740
we haven't actually done the last bit

244
00:11:31,740 --> 00:11:33,210
because the customer working form wasn't

245
00:11:33,210 --> 00:11:36,840
terribly concerned about long jump but

246
00:11:36,840 --> 00:11:38,460
because they're coding standard means

247
00:11:38,460 --> 00:11:39,810
they don't use long jump no not because

248
00:11:39,810 --> 00:11:41,400
they don't care about leaving stuff on

249
00:11:41,400 --> 00:11:46,350
the stack with them so in summary we've

250
00:11:46,350 --> 00:11:49,560
got two attributes one in two variations

251
00:11:49,560 --> 00:11:51,660
two arrays or randomized the stack on

252
00:11:51,660 --> 00:11:53,970
return or we can do it the whole program

253
00:11:53,970 --> 00:11:54,690
level which

254
00:11:54,690 --> 00:11:56,670
sorts long-jump with arrays stack array

255
00:11:56,670 --> 00:11:58,200
stack equals n or randomized stack

256
00:11:58,200 --> 00:12:01,290
that's all simple and not difficult to

257
00:12:01,290 --> 00:12:11,790
do here's a harder problem right we have

258
00:12:11,790 --> 00:12:13,860
a customer who is really worried about

259
00:12:13,860 --> 00:12:16,170
security one of the ways that you can

260
00:12:16,170 --> 00:12:20,370
attack a chip is you can take its top

261
00:12:20,370 --> 00:12:22,080
off and you can shine laser light on it

262
00:12:22,080 --> 00:12:24,240
very high laser light and it every soft

263
00:12:24,240 --> 00:12:25,680
when you're lucky and it changes a value

264
00:12:25,680 --> 00:12:27,810
in memory and you can observe how the

265
00:12:27,810 --> 00:12:29,370
chip behaves and that tells you stuff

266
00:12:29,370 --> 00:12:30,180
about the chip

267
00:12:30,180 --> 00:12:32,160
and indeed allows you to break its

268
00:12:32,160 --> 00:12:34,620
security so you see strange things like

269
00:12:34,620 --> 00:12:36,840
this where I set a global variable to a

270
00:12:36,840 --> 00:12:39,000
value I go and do some computation and

271
00:12:39,000 --> 00:12:40,890
then go and test that the global value

272
00:12:40,890 --> 00:12:45,270
hasn't changed even though patently it

273
00:12:45,270 --> 00:12:47,490
wouldn't have normally and of course the

274
00:12:47,490 --> 00:12:48,690
compiler understands that now if I

275
00:12:48,690 --> 00:12:50,460
compile with o 0 you can see the test

276
00:12:50,460 --> 00:12:51,630
there's a little branch in there

277
00:12:51,630 --> 00:12:53,250
afterwards where it checks that the

278
00:12:53,250 --> 00:12:55,200
thing it set before hasn't changed from

279
00:12:55,200 --> 00:12:57,420
what it set it but of course as soon as

280
00:12:57,420 --> 00:13:00,210
I turn on optimization the compiler says

281
00:13:00,210 --> 00:13:02,490
this is a stupid test I know it's that

282
00:13:02,490 --> 00:13:04,700
value I don't have to do it again and

283
00:13:04,700 --> 00:13:07,530
the optimizer has carefully taken away

284
00:13:07,530 --> 00:13:10,920
my clever bit of secure code now I can

285
00:13:10,920 --> 00:13:12,930
sort of fix that by saying well glob

286
00:13:12,930 --> 00:13:15,060
bars actually a volatile some sort of

287
00:13:15,060 --> 00:13:16,590
dynamic register so makes sense to read

288
00:13:16,590 --> 00:13:19,350
it again and then if I compile I will

289
00:13:19,350 --> 00:13:21,420
get my branch back the problem is I've

290
00:13:21,420 --> 00:13:23,220
now made my glob valve volatile if

291
00:13:23,220 --> 00:13:25,020
that's the one place I care about I've

292
00:13:25,020 --> 00:13:26,520
gone on hammered performance of course

293
00:13:26,520 --> 00:13:28,380
the whole program for the sake of

294
00:13:28,380 --> 00:13:31,350
getting that one right the question is

295
00:13:31,350 --> 00:13:33,570
and this is where this becomes not what

296
00:13:33,570 --> 00:13:34,680
we've done but what we'd like to do

297
00:13:34,680 --> 00:13:36,570
actually how do we do that do we have to

298
00:13:36,570 --> 00:13:39,150
go down the route of pragmas around code

299
00:13:39,150 --> 00:13:41,520
to say this particular fragment of code

300
00:13:41,520 --> 00:13:44,280
mustn't be optimized away I hate pragmas

301
00:13:44,280 --> 00:13:46,740
they're not syntactically particularly

302
00:13:46,740 --> 00:13:48,810
rich but I don't know a better way of

303
00:13:48,810 --> 00:13:51,320
doing it if anyone's got a better idea

304
00:13:51,320 --> 00:13:56,300
ok yes I've got three better ideas

305
00:14:09,690 --> 00:14:12,910
excellent okay so that's that for the

306
00:14:12,910 --> 00:14:16,120
count for the audio that's the point

307
00:14:16,120 --> 00:14:19,750
that Linux has macros which hide a cart

308
00:14:19,750 --> 00:14:21,399
to a volatile and back again so it's

309
00:14:21,399 --> 00:14:23,170
just on the local stuff so that's a good

310
00:14:23,170 --> 00:14:26,259
approach we could access once okay

311
00:14:26,259 --> 00:14:27,790
that's that I wasn't familiar with that

312
00:14:27,790 --> 00:14:30,009
so that's the sort of thing that we

313
00:14:30,009 --> 00:14:32,829
contentiously do there okay we're

314
00:14:32,829 --> 00:14:34,120
already getting value out in this week

315
00:14:34,120 --> 00:14:35,319
this is intended to be a two-way

316
00:14:35,319 --> 00:14:37,149
discussion this because it's the start

317
00:14:37,149 --> 00:14:38,680
of the project if you come and tell me

318
00:14:38,680 --> 00:14:40,000
that when we finish the project will be

319
00:14:40,000 --> 00:14:44,199
disappointing so let me tell you about

320
00:14:44,199 --> 00:14:48,490
this project this is an academic project

321
00:14:48,490 --> 00:14:51,480
it's funded by the British engine

322
00:14:51,480 --> 00:14:53,350
engineering and Physical Sciences

323
00:14:53,350 --> 00:14:55,630
Research Council it's a four year

324
00:14:55,630 --> 00:14:57,579
project it's led by Professor Elizabeth

325
00:14:57,579 --> 00:15:00,160
Oswald and dr. Dan page at the

326
00:15:00,160 --> 00:15:01,660
University of Bristol who for a long

327
00:15:01,660 --> 00:15:06,190
time have run there the computer science

328
00:15:06,190 --> 00:15:07,569
departments unit looking at information

329
00:15:07,569 --> 00:15:12,130
leakage for year it's got a team of Ras

330
00:15:12,130 --> 00:15:14,290
and PhD students and Paolo wave your

331
00:15:14,290 --> 00:15:16,959
hand Paola is going to be one of them so

332
00:15:16,959 --> 00:15:18,940
he'll be able to tell you about it in

333
00:15:18,940 --> 00:15:20,350
the future

334
00:15:20,350 --> 00:15:22,420
there are still vacancies inside this is

335
00:15:22,420 --> 00:15:23,620
field to interest you there are still

336
00:15:23,620 --> 00:15:25,660
academic vacancies going at all levels I

337
00:15:25,660 --> 00:15:29,170
understand em but Kazem is what's called

338
00:15:29,170 --> 00:15:31,449
an industrial supporter it doesn't mean

339
00:15:31,449 --> 00:15:34,029
we get any of the money but it means

340
00:15:34,029 --> 00:15:35,529
we've written to the government and said

341
00:15:35,529 --> 00:15:36,730
you really ought to fund this research

342
00:15:36,730 --> 00:15:39,910
project because it matters to industry

343
00:15:39,910 --> 00:15:41,649
and furthermore we're going to be

344
00:15:41,649 --> 00:15:43,810
employing people to do this and so forth

345
00:15:43,810 --> 00:15:46,000
and we really care about it and one of

346
00:15:46,000 --> 00:15:48,130
the ways we're supporting it ourselves

347
00:15:48,130 --> 00:15:50,139
is we're taking the PhD students who

348
00:15:50,139 --> 00:15:51,759
work on that project some of them will

349
00:15:51,759 --> 00:15:53,980
come in to us for PhD internships in the

350
00:15:53,980 --> 00:15:55,990
summer to do the information transfer

351
00:15:55,990 --> 00:15:58,420
thing expose them to real compilers and

352
00:15:58,420 --> 00:16:02,050
so forth and we have a role beyond that

353
00:16:02,050 --> 00:16:04,899
where some of the time spent not so much

354
00:16:04,899 --> 00:16:07,560
by me but people like Simon and Ed and

355
00:16:07,560 --> 00:16:09,370
Andrew Burgess and

356
00:16:09,370 --> 00:16:12,220
and grande Markel is on actually

357
00:16:12,220 --> 00:16:13,660
implementing some of the things I'm

358
00:16:13,660 --> 00:16:15,610
talking about and implementing them in a

359
00:16:15,610 --> 00:16:16,810
general way to get them into the

360
00:16:16,810 --> 00:16:18,430
open-source community for mainstream

361
00:16:18,430 --> 00:16:20,560
processes not for top-secret customer

362
00:16:20,560 --> 00:16:26,140
ones how many people here would think

363
00:16:26,140 --> 00:16:28,650
they know what information leakage is

364
00:16:28,650 --> 00:16:30,700
right good thing I haven't wasted these

365
00:16:30,700 --> 00:16:33,790
sites then so Wikipedia is quite a good

366
00:16:33,790 --> 00:16:36,100
definite and definition which is what

367
00:16:36,100 --> 00:16:37,330
happens when you have something that's

368
00:16:37,330 --> 00:16:39,100
supposed to be a closed or secure system

369
00:16:39,100 --> 00:16:40,540
and an eavesdropper can learn stuff

370
00:16:40,540 --> 00:16:44,380
about it and an example from the Second

371
00:16:44,380 --> 00:16:48,420
World War is the Japanese used secure

372
00:16:48,420 --> 00:16:51,070
radio transmissions which the Americans

373
00:16:51,070 --> 00:16:54,840
hadn't cracked to talk to their warships

374
00:16:54,840 --> 00:16:59,010
however they'd always transmitted from a

375
00:16:59,010 --> 00:17:01,150
different station depending on what they

376
00:17:01,150 --> 00:17:02,290
were doing and the Americans were able

377
00:17:02,290 --> 00:17:04,119
to learn what was going to happen from

378
00:17:04,119 --> 00:17:05,380
which station it was that was

379
00:17:05,380 --> 00:17:07,060
transmitting the information and that's

380
00:17:07,060 --> 00:17:11,700
an example of information leakage a

381
00:17:11,700 --> 00:17:15,670
technique that's very popular as may pop

382
00:17:15,670 --> 00:17:17,380
they're about ten years ago by Simon

383
00:17:17,380 --> 00:17:18,400
Moore and his team at Cambridge

384
00:17:18,400 --> 00:17:21,160
University is differential pair analysis

385
00:17:21,160 --> 00:17:22,720
so power analysis is about looking at

386
00:17:22,720 --> 00:17:26,079
how much energy a computer uses

387
00:17:26,079 --> 00:17:27,849
differential pair analogy analysis is

388
00:17:27,849 --> 00:17:29,260
about looking at how that changes in two

389
00:17:29,260 --> 00:17:31,570
different circumstances and one of the

390
00:17:31,570 --> 00:17:34,770
things you can do is to look at how

391
00:17:34,770 --> 00:17:37,330
power changes as I tried different ways

392
00:17:37,330 --> 00:17:39,400
of encrypting or decrease your

393
00:17:39,400 --> 00:17:40,900
encryption decryption and learn stuff

394
00:17:40,900 --> 00:17:43,060
about the encryption algorithm and so

395
00:17:43,060 --> 00:17:46,150
forth so here is a very simple algorithm

396
00:17:46,150 --> 00:17:48,610
I've got which takes my key and if it's

397
00:17:48,610 --> 00:17:52,300
an odd key it subtracts one from it and

398
00:17:52,300 --> 00:17:55,270
if it's an even key it takes the square

399
00:17:55,270 --> 00:17:57,580
root of the key and clearly one of those

400
00:17:57,580 --> 00:17:59,680
is an easy operation and the others an

401
00:17:59,680 --> 00:18:02,800
expensive operation and if we run that

402
00:18:02,800 --> 00:18:06,160
we can see that if I do my program and

403
00:18:06,160 --> 00:18:09,720
apply it to seven I use about 25

404
00:18:09,720 --> 00:18:12,820
microseconds of time on my laptop and if

405
00:18:12,820 --> 00:18:15,580
I do it with an even number I do it it

406
00:18:15,580 --> 00:18:17,290
takes 86 seconds and I could explore a

407
00:18:17,290 --> 00:18:18,400
lot of numbers and I'd come to a

408
00:18:18,400 --> 00:18:19,780
conclusion that this algorithm did

409
00:18:19,780 --> 00:18:21,550
something different for even numbers

410
00:18:21,550 --> 00:18:23,700
than for odd numbers

411
00:18:23,700 --> 00:18:26,940
so that's a very simple example of

412
00:18:26,940 --> 00:18:29,710
differential power analysis and what is

413
00:18:29,710 --> 00:18:33,429
it that was the mistake it was

414
00:18:33,429 --> 00:18:35,410
fundamentally this we took our critical

415
00:18:35,410 --> 00:18:38,110
variable our key and we let it control

416
00:18:38,110 --> 00:18:40,330
where the flow went it's in an if

417
00:18:40,330 --> 00:18:43,690
statement and now any anyone who write

418
00:18:43,690 --> 00:18:45,520
secure code knows that if you're worried

419
00:18:45,520 --> 00:18:46,900
about security you don't have your

420
00:18:46,900 --> 00:18:48,490
critical variables controlling branches

421
00:18:48,490 --> 00:18:51,309
or loops and that's easy to do but if

422
00:18:51,309 --> 00:18:53,890
it's a big program and it's tired and

423
00:18:53,890 --> 00:18:55,330
you're tired or it was someone's

424
00:18:55,330 --> 00:18:56,590
birthday and you had a couple of pints

425
00:18:56,590 --> 00:19:01,620
at lunchtime you might have got it wrong

426
00:19:01,620 --> 00:19:05,530
so how can we help and we don't need to

427
00:19:05,530 --> 00:19:07,870
just worry about data dependent control

428
00:19:07,870 --> 00:19:09,309
flow we need to worry about data

429
00:19:09,309 --> 00:19:10,870
dependent instruction timing you may

430
00:19:10,870 --> 00:19:11,950
think there's no changing the in stroke

431
00:19:11,950 --> 00:19:13,870
control flow but if the value affects

432
00:19:13,870 --> 00:19:15,850
how the instruction times that'll

433
00:19:15,850 --> 00:19:18,130
that'll affect it or even data dependent

434
00:19:18,130 --> 00:19:20,020
memory access well if it's this value I

435
00:19:20,020 --> 00:19:22,210
go to RAM and if it's this value I go to

436
00:19:22,210 --> 00:19:25,000
flash and flash and RAM do not have same

437
00:19:25,000 --> 00:19:31,690
energy profiles so here's my function of

438
00:19:31,690 --> 00:19:35,470
concern one option is this which is to

439
00:19:35,470 --> 00:19:37,420
say my argument K has an attribute which

440
00:19:37,420 --> 00:19:39,280
I've called quick var remember where now

441
00:19:39,280 --> 00:19:40,420
I should have said we're now in the

442
00:19:40,420 --> 00:19:42,520
territory of stuff we want to do not

443
00:19:42,520 --> 00:19:43,450
that we have done

444
00:19:43,450 --> 00:19:47,820
so this is where feedback is welcome

445
00:19:47,820 --> 00:19:50,080
well now hopefully I'll be able to get a

446
00:19:50,080 --> 00:19:52,210
warning that says hold on you've got a

447
00:19:52,210 --> 00:19:53,950
critical variable controlling a flow

448
00:19:53,950 --> 00:19:55,240
because I can see it's part of the

449
00:19:55,240 --> 00:19:56,670
expression controlling this if statement

450
00:19:56,670 --> 00:20:01,179
so that seems to be okay and even if I

451
00:20:01,179 --> 00:20:02,710
put my critical variable in a header

452
00:20:02,710 --> 00:20:04,120
because I'm including that header I

453
00:20:04,120 --> 00:20:05,830
still got all the information I can

454
00:20:05,830 --> 00:20:08,530
still make that work the critical

455
00:20:08,530 --> 00:20:10,540
variable usage is pretty obvious in

456
00:20:10,540 --> 00:20:13,540
those circumstances but it's not quite

457
00:20:13,540 --> 00:20:15,820
so simple what about this not so simple

458
00:20:15,820 --> 00:20:18,309
case because I actually assign the

459
00:20:18,309 --> 00:20:21,760
bottom byte of K to B and then I look at

460
00:20:21,760 --> 00:20:26,440
B well yes I probably ought to be able

461
00:20:26,440 --> 00:20:27,970
to get that right and spot that B

462
00:20:27,970 --> 00:20:29,290
although it's not the actual critical

463
00:20:29,290 --> 00:20:31,480
variable he's directly connected to the

464
00:20:31,480 --> 00:20:33,040
critical variable and it's still a bad

465
00:20:33,040 --> 00:20:34,780
thing to do

466
00:20:34,780 --> 00:20:37,390
but to do that I need to understand the

467
00:20:37,390 --> 00:20:41,650
local dataflow okay so this is not

468
00:20:41,650 --> 00:20:42,820
something we're going to solve by a

469
00:20:42,820 --> 00:20:44,260
simple look at the program we've got to

470
00:20:44,260 --> 00:20:45,760
understand the proper data flow through

471
00:20:45,760 --> 00:20:49,210
the program now what about this case

472
00:20:49,210 --> 00:20:51,160
here I've got two funds I've got two

473
00:20:51,160 --> 00:20:54,820
source files one is func one which has

474
00:20:54,820 --> 00:20:56,530
an arguments of critical variable and it

475
00:20:56,530 --> 00:20:58,570
calls funk tune passing in K

476
00:20:58,570 --> 00:21:01,360
but funk two has nothing to say that

477
00:21:01,360 --> 00:21:02,890
it's argument is critical it might be

478
00:21:02,890 --> 00:21:04,480
used in lots of places some of which are

479
00:21:04,480 --> 00:21:08,440
not critical variables so I go and

480
00:21:08,440 --> 00:21:11,350
compile it I compile each and then I

481
00:21:11,350 --> 00:21:12,730
link them together and I don't get any

482
00:21:12,730 --> 00:21:14,650
warnings because individually neither of

483
00:21:14,650 --> 00:21:16,720
those compilations can see our critical

484
00:21:16,720 --> 00:21:19,420
variables being used to control flow and

485
00:21:19,420 --> 00:21:22,630
so the only solution I have is to go and

486
00:21:22,630 --> 00:21:24,490
use link time optimization so this is

487
00:21:24,490 --> 00:21:26,320
something that has to go in an LTO world

488
00:21:26,320 --> 00:21:39,250
and indeed yes so this is using runtime

489
00:21:39,250 --> 00:21:41,290
dataflow tagging I think that's a very

490
00:21:41,290 --> 00:21:43,570
good idea and we haven't explored that

491
00:21:43,570 --> 00:21:50,110
so it's on the tape takeaway over there

492
00:21:50,110 --> 00:22:23,590
so yes yes yeah so exactly so the point

493
00:22:23,590 --> 00:22:25,680
being the point being made from tape was

494
00:22:25,680 --> 00:22:29,410
func two might be used multiple times so

495
00:22:29,410 --> 00:22:31,360
just making it a critical variable all

496
00:22:31,360 --> 00:22:33,040
the time may be inefficient if it's used

497
00:22:33,040 --> 00:22:37,900
widely in a non critical context so the

498
00:22:37,900 --> 00:22:39,730
point is that critical variable usage

499
00:22:39,730 --> 00:22:41,500
needs to understand global data flow and

500
00:22:41,500 --> 00:22:43,330
that's generally true of security and

501
00:22:43,330 --> 00:22:45,970
its sister discipline of safety which is

502
00:22:45,970 --> 00:22:48,539
two sides of the same coin

503
00:22:48,539 --> 00:22:50,950
that generally their whole system

504
00:22:50,950 --> 00:22:52,330
problems and you need to look at the

505
00:22:52,330 --> 00:22:56,669
whole system so data flow or runtime

506
00:22:56,669 --> 00:22:58,750
instrumentation those sort of techniques

507
00:22:58,750 --> 00:23:00,690
are going to be what we need

508
00:23:00,690 --> 00:23:04,510
so in summary on this one approach of

509
00:23:04,510 --> 00:23:08,460
critical variables simple cases are easy

510
00:23:08,460 --> 00:23:11,409
most cases need data flow analysis and

511
00:23:11,409 --> 00:23:13,450
that probably means LTO or as we've

512
00:23:13,450 --> 00:23:15,789
heard runtime analysis for programs of

513
00:23:15,789 --> 00:23:19,059
any size now I have this question what

514
00:23:19,059 --> 00:23:23,230
if we get it wrong if I tell you this is

515
00:23:23,230 --> 00:23:24,789
a controlling a critical variable and it

516
00:23:24,789 --> 00:23:26,590
turns out actually I've made a mess of

517
00:23:26,590 --> 00:23:28,419
the data flow and I've been too cautious

518
00:23:28,419 --> 00:23:31,179
I'm gonna spend ages tearing my hair out

519
00:23:31,179 --> 00:23:32,950
where the hell is this on it's not wrong

520
00:23:32,950 --> 00:23:35,020
the compiler has actually not understood

521
00:23:35,020 --> 00:23:37,929
what the program's doing false-negatives

522
00:23:37,929 --> 00:23:39,820
means some bad code may be getting

523
00:23:39,820 --> 00:23:41,350
through but if I didn't do this at all

524
00:23:41,350 --> 00:23:42,669
all the bad code would be getting

525
00:23:42,669 --> 00:23:44,890
through so I think we need to aim on the

526
00:23:44,890 --> 00:23:47,380
air of false negatives are less of a

527
00:23:47,380 --> 00:23:48,820
problem on false positives false

528
00:23:48,820 --> 00:23:50,740
positives could waste an awful lot of

529
00:23:50,740 --> 00:23:59,590
time for positives yes I agree this is

530
00:23:59,590 --> 00:24:06,250
my - true yeah well I think that's a

531
00:24:06,250 --> 00:24:09,309
good point to make and but certainly for

532
00:24:09,309 --> 00:24:10,809
the immediate time I think we're going

533
00:24:10,809 --> 00:24:12,760
to follow Tryg err on the sector of

534
00:24:12,760 --> 00:24:14,590
course the idea is never to get it wrong

535
00:24:14,590 --> 00:24:16,990
but we might not get there first time

536
00:24:16,990 --> 00:24:19,929
and it's worth playing around as I said

537
00:24:19,929 --> 00:24:21,640
before it's not just a control flow that

538
00:24:21,640 --> 00:24:23,980
leaks variation and memory access

539
00:24:23,980 --> 00:24:25,570
variation instruction time we mentioned

540
00:24:25,570 --> 00:24:28,299
and don't forget energy now some of you

541
00:24:28,299 --> 00:24:29,679
know from previous talks we've done a

542
00:24:29,679 --> 00:24:31,870
tremendous lot of energy work on the

543
00:24:31,870 --> 00:24:33,730
compilers impact on energy consumption

544
00:24:33,730 --> 00:24:36,010
here's a graph from James Pallister who

545
00:24:36,010 --> 00:24:38,770
spoke here a couple of years ago this is

546
00:24:38,770 --> 00:24:41,950
a well-known 8-bit processor where we

547
00:24:41,950 --> 00:24:45,820
multiplied every pair of 8-bit numbers

548
00:24:45,820 --> 00:24:47,409
using their multiply instruction and

549
00:24:47,409 --> 00:24:49,929
measured how much energy at use from

550
00:24:49,929 --> 00:24:51,370
this you can see they've implemented a

551
00:24:51,370 --> 00:24:53,890
4-bit booth multiplier I'm sure they

552
00:24:53,890 --> 00:24:55,600
didn't realize that there very long was

553
00:24:55,600 --> 00:24:59,530
quite so available to everyone if I'm

554
00:24:59,530 --> 00:25:01,900
writing secure code using multiply

555
00:25:01,900 --> 00:25:04,420
even just using the multiply instruction

556
00:25:04,420 --> 00:25:07,030
the values going in aren't going to leak

557
00:25:07,030 --> 00:25:09,190
information if anyone knows why one

558
00:25:09,190 --> 00:25:11,170
times 19 is the most energy efficient

559
00:25:11,170 --> 00:25:18,850
multiplier be interested so that was

560
00:25:18,850 --> 00:25:22,120
about the first category warning you

561
00:25:22,120 --> 00:25:24,760
about things that look bad this is about

562
00:25:24,760 --> 00:25:30,240
the heavy lifting and the heavy lifting

563
00:25:32,400 --> 00:25:35,590
the heavy lifting is about making life

564
00:25:35,590 --> 00:25:36,040
easier

565
00:25:36,040 --> 00:25:39,130
so here is a technique called bit

566
00:25:39,130 --> 00:25:41,620
splitting and the idea of bits one way

567
00:25:41,620 --> 00:25:43,570
you can find out what someone's

568
00:25:43,570 --> 00:25:45,160
cryptographic key is if they put it in a

569
00:25:45,160 --> 00:25:47,470
nice 32 bit block in memory you slice

570
00:25:47,470 --> 00:25:49,480
the top off the memory chip you run your

571
00:25:49,480 --> 00:25:50,590
thing under a scanning electron

572
00:25:50,590 --> 00:25:53,230
microscope and you read out the memory

573
00:25:53,230 --> 00:25:55,390
values and you look for all 32 bit

574
00:25:55,390 --> 00:25:57,190
sequences and look for anything that

575
00:25:57,190 --> 00:26:00,520
might be a key one way to solve that is

576
00:26:00,520 --> 00:26:02,020
to put little bits here they're

577
00:26:02,020 --> 00:26:05,440
everywhere all over the place and then

578
00:26:05,440 --> 00:26:07,059
it's much harder and that's called bit

579
00:26:07,059 --> 00:26:08,650
splitting now here I've just done bytes

580
00:26:08,650 --> 00:26:11,350
but I've taken my 32 bit key I've put it

581
00:26:11,350 --> 00:26:13,840
in four variables and I'll make sure my

582
00:26:13,840 --> 00:26:15,340
linker scripts put those four local

583
00:26:15,340 --> 00:26:17,620
global variables in completely different

584
00:26:17,620 --> 00:26:20,950
places and then of course I now need a

585
00:26:20,950 --> 00:26:23,920
function to add one to that where I add

586
00:26:23,920 --> 00:26:26,530
it to the least significant byte and in

587
00:26:26,530 --> 00:26:27,760
fact overflows I add it to the next

588
00:26:27,760 --> 00:26:29,320
significant byte and you can see just

589
00:26:29,320 --> 00:26:31,110
that it's tedious and that's just byte

590
00:26:31,110 --> 00:26:33,910
so the idea is you spread the key

591
00:26:33,910 --> 00:26:35,230
through memory so it can't be scanned

592
00:26:35,230 --> 00:26:40,929
for that ought to work but it is hard

593
00:26:40,929 --> 00:26:43,390
work I'm just you know adding one look

594
00:26:43,390 --> 00:26:44,380
at the code I need it

595
00:26:44,380 --> 00:26:47,559
and the problem is optimizing compilers

596
00:26:47,559 --> 00:26:48,970
are very good at spotting those patterns

597
00:26:48,970 --> 00:26:50,770
and they say gosh this is really clever

598
00:26:50,770 --> 00:26:53,380
I could combine this into one 32-bit

599
00:26:53,380 --> 00:26:55,000
variable I'll save it somewhere so you

600
00:26:55,000 --> 00:26:56,200
may have got your four bits and then

601
00:26:56,200 --> 00:26:57,940
there's another bit of memory but has

602
00:26:57,940 --> 00:27:01,720
your 32 bits join together so the

603
00:27:01,720 --> 00:27:04,270
brilliance of the compiler completely

604
00:27:04,270 --> 00:27:07,710
scuppers us again so one of the

605
00:27:07,710 --> 00:27:10,840
suggested approaches is this is we give

606
00:27:10,840 --> 00:27:12,880
yourself an attribute bit split and then

607
00:27:12,880 --> 00:27:14,830
you can just write k plus plus

608
00:27:14,830 --> 00:27:16,390
and the compiler will worry about that

609
00:27:16,390 --> 00:27:18,250
and the compiler can do that 9 thumbing

610
00:27:18,250 --> 00:27:20,620
Li tedious one if you want of putting

611
00:27:20,620 --> 00:27:22,240
every single bit in a different location

612
00:27:22,240 --> 00:27:25,750
and these techniques don't do anything

613
00:27:25,750 --> 00:27:27,250
for performance but that's not the point

614
00:27:27,250 --> 00:27:29,110
I don't mind spending some performance

615
00:27:29,110 --> 00:27:32,320
if I'm gonna get and it's trivial for

616
00:27:32,320 --> 00:27:35,080
the programmer the compiler can actually

617
00:27:35,080 --> 00:27:36,789
do a really good job it's all too easy

618
00:27:36,789 --> 00:27:38,380
when you write those complicated things

619
00:27:38,380 --> 00:27:40,360
to either make a mistake or more

620
00:27:40,360 --> 00:27:42,279
importantly accidentally to still leak

621
00:27:42,279 --> 00:27:43,659
information because you actually kept

622
00:27:43,659 --> 00:27:45,159
intermediate values around the rabbit

623
00:27:45,159 --> 00:27:49,630
Leakey because it's inside the compiler

624
00:27:49,630 --> 00:27:51,279
we can make sure the compiler knows if

625
00:27:51,279 --> 00:27:53,139
it's labeled bit split don't go and

626
00:27:53,139 --> 00:27:56,769
stick it together and it's a still a

627
00:27:56,769 --> 00:27:58,480
whole system problem so we've got to do

628
00:27:58,480 --> 00:28:03,010
it on a global basis and oh I thought

629
00:28:03,010 --> 00:28:05,730
one more side there so that is

630
00:28:05,730 --> 00:28:08,590
definitely on our radar as an early one

631
00:28:08,590 --> 00:28:10,419
to do is to implement automatic bit

632
00:28:10,419 --> 00:28:12,370
splitting so you can write secure code

633
00:28:12,370 --> 00:28:16,630
and have it come out it has the same

634
00:28:16,630 --> 00:28:18,639
issues of course of is it always

635
00:28:18,639 --> 00:28:19,360
possible

636
00:28:19,360 --> 00:28:20,679
does it get hard and so forth I think

637
00:28:20,679 --> 00:28:23,850
that one probably we can solve

638
00:28:23,850 --> 00:28:26,110
big-endian little-endian you name it

639
00:28:26,110 --> 00:28:28,000
yeah I mean he's got a whole camp we are

640
00:28:28,000 --> 00:28:30,789
planning to try and do this for a range

641
00:28:30,789 --> 00:28:32,529
of architectures not everything for

642
00:28:32,529 --> 00:28:33,880
every architecture but to prove it

643
00:28:33,880 --> 00:28:36,070
across architects I'm indeed given the

644
00:28:36,070 --> 00:28:38,679
audit be a bit careful to do it for GCC

645
00:28:38,679 --> 00:28:40,840
as well as for LOV n because that's a

646
00:28:40,840 --> 00:28:42,399
good test of have you really got a

647
00:28:42,399 --> 00:28:45,000
general approach

648
00:28:49,370 --> 00:28:51,990
well it is until you pass the argument

649
00:28:51,990 --> 00:28:54,330
to the librarians a 32-bit value and the

650
00:28:54,330 --> 00:28:55,770
answer is yes there's balance and the

651
00:28:55,770 --> 00:28:57,320
way it is often done is as a library

652
00:28:57,320 --> 00:29:00,090
there is a balance all the way through

653
00:29:00,090 --> 00:29:03,120
and in some sense you're putting the

654
00:29:03,120 --> 00:29:04,860
library like an intrinsic inside the

655
00:29:04,860 --> 00:29:12,000
compiler so yeah I think these are good

656
00:29:12,000 --> 00:29:13,920
things so the for the record that's the

657
00:29:13,920 --> 00:29:15,510
saying can you not do this as libraries

658
00:29:15,510 --> 00:29:18,120
and or as a some sort of intrinsic which

659
00:29:18,120 --> 00:29:19,770
part of the brain brings the thing into

660
00:29:19,770 --> 00:29:20,760
lie but I think those are all good

661
00:29:20,760 --> 00:29:22,770
approaches and it may end up that this

662
00:29:22,770 --> 00:29:25,110
maps down into a library calling critic

663
00:29:25,110 --> 00:29:27,210
just as when I copy a struct it Maps

664
00:29:27,210 --> 00:29:30,210
down into the intrinsic bit bit a mem

665
00:29:30,210 --> 00:29:41,190
copy and we start to see why this is a

666
00:29:41,190 --> 00:29:45,150
four year project so yeah so these are

667
00:29:45,150 --> 00:29:47,940
all good comments you know LTO inlining

668
00:29:47,940 --> 00:29:51,390
stuff and so forth this is not the only

669
00:29:51,390 --> 00:29:54,630
stuff I've touched on too because I want

670
00:29:54,630 --> 00:29:55,740
to give you a flavor of what we're

671
00:29:55,740 --> 00:29:57,480
trying to achieve but we have some

672
00:29:57,480 --> 00:30:00,990
others on our list and the idea is that

673
00:30:00,990 --> 00:30:04,230
these will be the ones that we explore

674
00:30:04,230 --> 00:30:06,240
we want to take the best academic

675
00:30:06,240 --> 00:30:08,910
research the stuff I've talked about so

676
00:30:08,910 --> 00:30:10,920
far has been known about for years but

677
00:30:10,920 --> 00:30:12,840
there's a lot of newer stuff and we want

678
00:30:12,840 --> 00:30:14,400
to not have that big gap between the

679
00:30:14,400 --> 00:30:17,030
academics knew it two decades ago and

680
00:30:17,030 --> 00:30:20,400
people got to actually use it now we

681
00:30:20,400 --> 00:30:21,990
want to move shorten that time scale

682
00:30:21,990 --> 00:30:23,700
that's the point of the link between the

683
00:30:23,700 --> 00:30:27,800
research and an industry atomicity I

684
00:30:27,800 --> 00:30:30,000
never quite understand why it's given

685
00:30:30,000 --> 00:30:31,320
that name this is about balancing

686
00:30:31,320 --> 00:30:34,350
control paths if I've got to go down two

687
00:30:34,350 --> 00:30:36,270
hours of an if-then-else can i balance

688
00:30:36,270 --> 00:30:38,190
the path so they take exactly the same

689
00:30:38,190 --> 00:30:40,890
time hard for a modern out of order

690
00:30:40,890 --> 00:30:43,110
processor possible though for smaller

691
00:30:43,110 --> 00:30:44,520
embedded processors that you might get

692
00:30:44,520 --> 00:30:48,390
on a smartcard soup optimization for

693
00:30:48,390 --> 00:30:49,980
minimal leakage that's because we're

694
00:30:49,980 --> 00:30:52,860
very big into super optimization and all

695
00:30:52,860 --> 00:30:55,290
problems should be given to super

696
00:30:55,290 --> 00:30:57,950
optimization to see if it can solve it

697
00:30:57,950 --> 00:31:00,390
super optimization can optimize for any

698
00:31:00,390 --> 00:31:01,230
criterion

699
00:31:01,230 --> 00:31:04,070
information leakage could be one of them

700
00:31:04,070 --> 00:31:08,910
algorithmic choice one way to hide what

701
00:31:08,910 --> 00:31:09,960
you're doing is to use different

702
00:31:09,960 --> 00:31:12,480
algorithms for the same job at different

703
00:31:12,480 --> 00:31:14,790
times and certainly for things where

704
00:31:14,790 --> 00:31:16,049
there are multiple algorithms that's a

705
00:31:16,049 --> 00:31:18,480
way to confuse data flow analysis if I

706
00:31:18,480 --> 00:31:20,130
had there's lots of ways of taking a

707
00:31:20,130 --> 00:31:22,140
square root if that program taking a

708
00:31:22,140 --> 00:31:23,820
square root use one of different five

709
00:31:23,820 --> 00:31:26,100
algorithm five different algorithms at

710
00:31:26,100 --> 00:31:30,330
random then that would spoil my energy

711
00:31:30,330 --> 00:31:34,640
profile a bit this is where this is

712
00:31:34,640 --> 00:31:36,960
verging towards our architectural side

713
00:31:36,960 --> 00:31:38,940
of thing instruction set extensions can

714
00:31:38,940 --> 00:31:40,830
we actually improve the instruction set

715
00:31:40,830 --> 00:31:43,290
to make minimizing leakage easier now we

716
00:31:43,290 --> 00:31:45,710
already have one customer case where

717
00:31:45,710 --> 00:31:49,320
actually the instruction set has been

718
00:31:49,320 --> 00:31:51,210
changed because of a realization of one

719
00:31:51,210 --> 00:31:53,400
particular part the architecture was

720
00:31:53,400 --> 00:31:54,660
leaking more information that was

721
00:31:54,660 --> 00:31:58,290
desirable so there is a feedback to the

722
00:31:58,290 --> 00:31:59,910
development room and that's why it's

723
00:31:59,910 --> 00:32:01,380
always good to develop your compiler

724
00:32:01,380 --> 00:32:03,270
before you spin your first silicon

725
00:32:03,270 --> 00:32:04,860
develop the two in parallel because you

726
00:32:04,860 --> 00:32:08,120
can feed off each other and the last one

727
00:32:08,120 --> 00:32:12,450
instruction shuffling I have a whole

728
00:32:12,450 --> 00:32:13,830
sequence of things to do very

729
00:32:13,830 --> 00:32:16,740
predictable but there's always a degree

730
00:32:16,740 --> 00:32:19,740
of scheduling flexibility let chef

731
00:32:19,740 --> 00:32:21,210
shuffle them around and give you several

732
00:32:21,210 --> 00:32:23,580
different scheduled flavors to allow you

733
00:32:23,580 --> 00:32:26,210
to get different profiles coming out and

734
00:32:26,210 --> 00:32:28,530
that's it

735
00:32:28,530 --> 00:32:30,570
so it's an early stage project I welcome

736
00:32:30,570 --> 00:32:34,879
any feedback questions and so forth

737
00:32:34,910 --> 00:32:44,749
[Applause]

738
00:33:22,480 --> 00:33:25,070
so this is the session that we don't

739
00:33:25,070 --> 00:33:26,570
need the full LTO level we can use

740
00:33:26,570 --> 00:33:28,640
things like the arm build attributes to

741
00:33:28,640 --> 00:33:30,110
annotate binaries to give enough

742
00:33:30,110 --> 00:33:32,090
information that we can get that sort of

743
00:33:32,090 --> 00:34:05,630
thing code balancing is almost

744
00:34:05,630 --> 00:34:07,520
impossible as soon as you go cached or

745
00:34:07,520 --> 00:34:10,040
out of order or any of those a lot of

746
00:34:10,040 --> 00:34:12,230
the very smallest things when you're

747
00:34:12,230 --> 00:34:13,668
looking at the Internet of Things the

748
00:34:13,668 --> 00:34:16,399
smallest those processors have no caches

749
00:34:16,399 --> 00:34:18,739
or they're there in order uncashed

750
00:34:18,739 --> 00:34:21,590
machines right Bevans but I agree with

751
00:34:21,590 --> 00:34:23,210
you once you go into that with you're

752
00:34:23,210 --> 00:34:24,530
sort of losing information all over the

753
00:34:24,530 --> 00:34:27,620
place there so you're sore so solving is

754
00:34:27,620 --> 00:34:30,440
a problem yes decide for the record the

755
00:34:30,440 --> 00:34:33,399
question was about how cached

756
00:34:33,399 --> 00:34:35,630
architectures shuffling is not going to

757
00:34:35,630 --> 00:34:38,290
balancing is not going to work so

758
00:34:38,290 --> 00:34:41,168
Irish perspectives often the technology

759
00:34:41,168 --> 00:34:46,469
to improve our jittering or masking

760
00:34:51,090 --> 00:34:54,100
because we are areas we tend to work in

761
00:34:54,100 --> 00:34:55,600
which are deeply embedded and we're

762
00:34:55,600 --> 00:34:57,670
often pre Silicon we're very interested

763
00:34:57,670 --> 00:35:00,280
in that it's not a primary goal for us

764
00:35:00,280 --> 00:35:03,340
to look at architectures directly from

765
00:35:03,340 --> 00:35:05,350
this project but the potential of the

766
00:35:05,350 --> 00:35:07,570
compiler to inform architectural

767
00:35:07,570 --> 00:35:09,370
decisions and engage with the hardware

768
00:35:09,370 --> 00:35:38,470
engineer is absolutely yeah so so so

769
00:35:38,470 --> 00:35:40,390
this is a comment about once you have

770
00:35:40,390 --> 00:35:41,440
caches and you have to worry about

771
00:35:41,440 --> 00:35:43,420
caches then bit splitting splitting ends

772
00:35:43,420 --> 00:35:45,520
up with having other directories you're

773
00:35:45,520 --> 00:35:47,190
right it's aimed at the very smallest

774
00:35:47,190 --> 00:35:49,570
processors I think there's a very open

775
00:35:49,570 --> 00:35:51,370
research question how do you make bit

776
00:35:51,370 --> 00:35:54,880
splitting work in the context of cache

777
00:35:54,880 --> 00:35:56,680
lines and so forth without leaking more

778
00:35:56,680 --> 00:35:59,819
information than you're trying to hide

779
00:36:13,690 --> 00:36:16,849
[Music]

780
00:36:26,220 --> 00:36:29,080
that's so the question is why don't we

781
00:36:29,080 --> 00:36:30,670
just do a raised stack on the individual

782
00:36:30,670 --> 00:36:31,900
variable rather than worrying about

783
00:36:31,900 --> 00:36:33,640
flattening the whole stack the answer is

784
00:36:33,640 --> 00:36:34,720
because we haven't thought to do that

785
00:36:34,720 --> 00:36:35,890
when we had the conversation with the

786
00:36:35,890 --> 00:36:37,780
customer flattening the whole stack was

787
00:36:37,780 --> 00:36:40,390
once a an interesting the feedback

788
00:36:40,390 --> 00:36:41,680
afterwards is all we're not sure going

789
00:36:41,680 --> 00:36:43,060
to use it because now we have to get our

790
00:36:43,060 --> 00:36:45,640
compiler revalidated because you're

791
00:36:45,640 --> 00:36:46,900
affecting the security of the code

792
00:36:46,900 --> 00:36:51,120
generated so it cuts both ways yes

793
00:36:53,910 --> 00:36:56,500
so the comment is on a raised stack you

794
00:36:56,500 --> 00:36:57,670
probably want to erase the registers and

795
00:36:57,670 --> 00:36:59,140
that fact I believe the implementation

796
00:36:59,140 --> 00:37:00,190
we have actually does erase the

797
00:37:00,190 --> 00:37:16,510
registers yeah and comment about it

798
00:37:16,510 --> 00:37:18,040
might get bit harder about clearing

799
00:37:18,040 --> 00:37:19,690
halfs of registers if you have variable

800
00:37:19,690 --> 00:37:24,220
size registers more questions no thank

801
00:37:24,220 --> 00:37:25,590
you all very much

802
00:37:25,590 --> 00:37:33,349
[Applause]

