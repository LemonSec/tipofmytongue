1
00:00:05,049 --> 00:00:07,790
so I'm going to be talking about simple

2
00:00:07,790 --> 00:00:12,769
number theory in Perl 6 number theory

3
00:00:12,769 --> 00:00:15,790
the fundamental branch of mathematics

4
00:00:15,790 --> 00:00:18,200
studying the properties of integers it

5
00:00:18,200 --> 00:00:20,599
is certainly fundamental in modern

6
00:00:20,599 --> 00:00:23,869
cryptography Perl 6 I don't really need

7
00:00:23,869 --> 00:00:25,910
to talk a lot about what Perl 6 is here

8
00:00:25,910 --> 00:00:29,119
such your language about 5 a lot of this

9
00:00:29,119 --> 00:00:31,609
is conference driven development that is

10
00:00:31,609 --> 00:00:33,769
I've done a little bit of work with Perl

11
00:00:33,769 --> 00:00:36,410
6 and wanted to do some more so this is

12
00:00:36,410 --> 00:00:39,650
a way to force myself to do that so I am

13
00:00:39,650 --> 00:00:42,589
Dana Jacobson I'm coming from Portland

14
00:00:42,589 --> 00:00:44,330
Oregon in the United States come to

15
00:00:44,330 --> 00:00:46,839
foster him a couple times love it here

16
00:00:46,839 --> 00:00:50,210
number theory for me is a hobby that got

17
00:00:50,210 --> 00:00:51,019
out of hand

18
00:00:51,019 --> 00:00:53,089
I imagine lots of you guys have had

19
00:00:53,089 --> 00:00:58,610
something similar so nice things about

20
00:00:58,610 --> 00:01:00,010
Perl 6

21
00:01:00,010 --> 00:01:02,659
we've all heard there's lots of ways to

22
00:01:02,659 --> 00:01:04,610
do something in Perl 5 there's more than

23
00:01:04,610 --> 00:01:05,330
one way to do it

24
00:01:05,330 --> 00:01:09,679
Perl 6 here's this sess laughs hold my

25
00:01:09,679 --> 00:01:13,280
drink I'll tell you Perl 6 has so many

26
00:01:13,280 --> 00:01:16,310
ways to do things a lot of them are

27
00:01:16,310 --> 00:01:19,250
really nice for me everyone's gonna have

28
00:01:19,250 --> 00:01:20,600
a different set of features they like

29
00:01:20,600 --> 00:01:23,630
damien Conway talked about how he just

30
00:01:23,630 --> 00:01:26,659
loves using Unicode characters in his

31
00:01:26,659 --> 00:01:28,579
program so I'm from the United States I

32
00:01:28,579 --> 00:01:30,909
don't know what he's talking about so

33
00:01:30,909 --> 00:01:33,950
Jeff and some other people a Brian are

34
00:01:33,950 --> 00:01:35,569
looking at grammars I haven't looked at

35
00:01:35,569 --> 00:01:37,429
grammars but it has something for

36
00:01:37,429 --> 00:01:41,179
everybody I love big it's native to Perl

37
00:01:41,179 --> 00:01:44,479
6 in C code and in Perl code you're

38
00:01:44,479 --> 00:01:46,280
constantly fighting with this issue of

39
00:01:46,280 --> 00:01:49,729
my numbers start getting large weird

40
00:01:49,729 --> 00:01:51,799
things start happening

41
00:01:51,799 --> 00:01:54,289
we have rationals I don't actually care

42
00:01:54,289 --> 00:01:55,999
so much about them I know a lot of

43
00:01:55,999 --> 00:01:57,889
people love having the idea of rationals

44
00:01:57,889 --> 00:02:00,439
where I can just maintain this idea of

45
00:02:00,439 --> 00:02:03,020
its 1 over 3 not immediately turn that

46
00:02:03,020 --> 00:02:04,219
into point three three three

47
00:02:04,219 --> 00:02:07,130
something not three junctions are pretty

48
00:02:07,130 --> 00:02:11,450
cool exp mod is a wonderful feature it's

49
00:02:11,450 --> 00:02:13,370
a function I end up writing in every

50
00:02:13,370 --> 00:02:15,590
other language because when you want to

51
00:02:15,590 --> 00:02:18,280
raise a to the K power mod

52
00:02:18,280 --> 00:02:20,719
that's a terrible way to do it if you

53
00:02:20,719 --> 00:02:23,299
actually raise a to the K power and then

54
00:02:23,299 --> 00:02:25,099
mod n because you end up this humongous

55
00:02:25,099 --> 00:02:26,900
number and there are much faster ways to

56
00:02:26,900 --> 00:02:27,290
do it

57
00:02:27,290 --> 00:02:29,439
pearl six has it completely built-in

58
00:02:29,439 --> 00:02:32,239
critics also decided that hey this idea

59
00:02:32,239 --> 00:02:34,489
of is a number Prime is pretty

60
00:02:34,489 --> 00:02:36,049
fundamental and people keep writing it

61
00:02:36,049 --> 00:02:37,519
in every language so we're just going to

62
00:02:37,519 --> 00:02:40,609
toss it in that's nice we get a bunch of

63
00:02:40,609 --> 00:02:42,469
other little functions pick is

64
00:02:42,469 --> 00:02:44,450
surprisingly useful to take a list and

65
00:02:44,450 --> 00:02:45,889
just say give me a random element from

66
00:02:45,889 --> 00:02:48,829
it it has lots of variations it is used

67
00:02:48,829 --> 00:02:52,040
all over the place so let me start with

68
00:02:52,040 --> 00:02:56,540
this very simple RSA example we're gonna

69
00:02:56,540 --> 00:02:59,060
generate a key so we want to generate a

70
00:02:59,060 --> 00:03:01,639
couple random Prime's and it's the

71
00:03:01,639 --> 00:03:07,219
product of the two I think yeah so we

72
00:03:07,219 --> 00:03:11,930
choose take the LCM of the totient which

73
00:03:11,930 --> 00:03:13,969
because they're prime is very easy we

74
00:03:13,969 --> 00:03:18,349
choose an e we get our D let me go

75
00:03:18,349 --> 00:03:19,689
through the Pearl six code for this

76
00:03:19,689 --> 00:03:21,409
generating random primes

77
00:03:21,409 --> 00:03:24,229
it's really really simple except my is

78
00:03:24,229 --> 00:03:27,319
prime ran off the screen there so we

79
00:03:27,319 --> 00:03:29,840
just take we have a number of bits we

80
00:03:29,840 --> 00:03:31,430
just keep taking random numbers until

81
00:03:31,430 --> 00:03:34,939
its prime and there we go now we can

82
00:03:34,939 --> 00:03:39,379
fill up V and Q very easily these are

83
00:03:39,379 --> 00:03:42,799
very simple oh wait but pearl 6s LCM

84
00:03:42,799 --> 00:03:47,359
built in the at least common multiple so

85
00:03:47,359 --> 00:03:48,739
I want to choose an e there's a

86
00:03:48,739 --> 00:03:50,359
different way to do this if you want you

87
00:03:50,359 --> 00:03:52,299
could just pick an e that's co-prime

88
00:03:52,299 --> 00:03:54,979
this is a different way to do it you go

89
00:03:54,979 --> 00:03:57,259
ahead and pick a random one and we get

90
00:03:57,259 --> 00:04:00,650
to use our GCD function and again our

91
00:04:00,650 --> 00:04:03,229
pick just says just give me a random

92
00:04:03,229 --> 00:04:05,180
value from that we do it until it's

93
00:04:05,180 --> 00:04:10,609
co-prime so now we want D which is going

94
00:04:10,609 --> 00:04:13,189
to be our private key we want the

95
00:04:13,189 --> 00:04:17,019
inverse of that the idea is D times e

96
00:04:17,019 --> 00:04:23,000
ends up being one mod fee so how do we

97
00:04:23,000 --> 00:04:24,530
do that in other languages well we get

98
00:04:24,530 --> 00:04:26,510
to write a routine to do it but in Perl

99
00:04:26,510 --> 00:04:30,889
6 well we have this it exp mod

100
00:04:30,889 --> 00:04:32,749
just give it -1 it'll give you the

101
00:04:32,749 --> 00:04:36,110
inverse it's surprisingly handy this is

102
00:04:36,110 --> 00:04:37,669
really short code compared to what we

103
00:04:37,669 --> 00:04:39,469
end up with writing in other languages

104
00:04:39,469 --> 00:04:42,289
and we decided to use a hundred thousand

105
00:04:42,289 --> 00:04:45,199
24 bits Perl 6 has no problem with this

106
00:04:45,199 --> 00:04:47,689
whatsoever my talk is not going to be

107
00:04:47,689 --> 00:04:50,330
about cryptography so I'm going to leave

108
00:04:50,330 --> 00:04:54,259
aside all of the math reasons why and

109
00:04:54,259 --> 00:04:55,999
the boilerplate code you would normally

110
00:04:55,999 --> 00:04:57,139
add to actually make this a useful

111
00:04:57,139 --> 00:05:01,430
routine you can look that up so binomial

112
00:05:01,430 --> 00:05:04,460
is very common we want to find the

113
00:05:04,460 --> 00:05:08,210
number of combinations taking 50 items

114
00:05:08,210 --> 00:05:11,360
for instance I wanted 50 items I want to

115
00:05:11,360 --> 00:05:13,460
choose combinations of 10 of those how

116
00:05:13,460 --> 00:05:17,120
many do I have I add Elam's and I get

117
00:05:17,120 --> 00:05:18,860
this humongous number well I'm sure I'm

118
00:05:18,860 --> 00:05:21,439
glad I didn't iterate over that Perl 6

119
00:05:21,439 --> 00:05:24,409
it was very clever and knows that in

120
00:05:24,409 --> 00:05:26,689
fact you're just asking for the number

121
00:05:26,689 --> 00:05:28,099
of elements you didn't want me to create

122
00:05:28,099 --> 00:05:30,710
this huge list with this many items in

123
00:05:30,710 --> 00:05:32,599
it you didn't want to iterator you just

124
00:05:32,599 --> 00:05:34,550
wanted the number of elements so Perl 6

125
00:05:34,550 --> 00:05:37,610
gives that to me this is a formula for

126
00:05:37,610 --> 00:05:40,580
how you calculate that if you dig

127
00:05:40,580 --> 00:05:43,939
through the Perl 6 internals this is the

128
00:05:43,939 --> 00:05:46,550
product of n times n minus 1 and minus 2

129
00:05:46,550 --> 00:05:49,789
and so on we divide by factorial K if

130
00:05:49,789 --> 00:05:51,560
you dig through the Perl 6 code you find

131
00:05:51,560 --> 00:05:57,710
basically this in Perl 6 first we have n

132
00:05:57,710 --> 00:06:02,449
down to 0 this is zip operator so we're

133
00:06:02,449 --> 00:06:04,550
gonna take this second list which has a

134
00:06:04,550 --> 00:06:06,500
lot a shoe in it for the minimum and we

135
00:06:06,500 --> 00:06:11,000
do the divides and finally we get to

136
00:06:11,000 --> 00:06:14,779
reduce it we just say star here it is

137
00:06:14,779 --> 00:06:17,710
this multiplied everything together now

138
00:06:17,710 --> 00:06:20,830
in these these ended up being rationals

139
00:06:20,830 --> 00:06:23,360
so in most languages you end up having

140
00:06:23,360 --> 00:06:24,949
to write a whole lot of code to deal

141
00:06:24,949 --> 00:06:27,349
with this it's not complicated code but

142
00:06:27,349 --> 00:06:30,439
you have to keep keep in mind oh wait I

143
00:06:30,439 --> 00:06:33,069
have to make sure those divides are all

144
00:06:33,069 --> 00:06:36,259
integers in Perl 6 we don't really care

145
00:06:36,259 --> 00:06:38,599
we just write the routine just like we

146
00:06:38,599 --> 00:06:40,600
would like to

147
00:06:40,600 --> 00:06:44,240
here's binomial and see it's a pretty

148
00:06:44,240 --> 00:06:46,190
standard way to do it mark Jason Dominus

149
00:06:46,190 --> 00:06:48,710
had this on his blog in 2007 without

150
00:06:48,710 --> 00:06:51,889
this but something like it and said this

151
00:06:51,889 --> 00:06:53,510
is how you should do binomial it has no

152
00:06:53,510 --> 00:06:55,570
overflow problems it's great

153
00:06:55,570 --> 00:06:58,610
chap that does overflow someone found

154
00:06:58,610 --> 00:07:00,710
out he posted this on reddit and someone

155
00:07:00,710 --> 00:07:03,979
said well actually it does overflow now

156
00:07:03,979 --> 00:07:07,669
probably most of you will see the

157
00:07:07,669 --> 00:07:11,210
obvious way to fix it so this is how you

158
00:07:11,210 --> 00:07:15,520
fix it in in C it's actually very fast

159
00:07:15,520 --> 00:07:18,590
it's clear everybody would do this and

160
00:07:18,590 --> 00:07:20,500
you completely understand why this works

161
00:07:20,500 --> 00:07:22,910
until you realize there's still only

162
00:07:22,910 --> 00:07:25,010
four sixty four-bit if I go past sixty

163
00:07:25,010 --> 00:07:26,300
four-bit I have to start getting to the

164
00:07:26,300 --> 00:07:28,820
big libraries and portability issues and

165
00:07:28,820 --> 00:07:30,050
so on

166
00:07:30,050 --> 00:07:35,870
Perl 6 there solves it all so now I'm

167
00:07:35,870 --> 00:07:37,039
gonna talk about a little bit about

168
00:07:37,039 --> 00:07:40,400
primes why primes well okay some of you

169
00:07:40,400 --> 00:07:42,320
who know me are wondering have you ever

170
00:07:42,320 --> 00:07:43,850
given a talk where you did not say the

171
00:07:43,850 --> 00:07:46,580
word prime and yes but it was about a

172
00:07:46,580 --> 00:07:49,160
decade ago Prime's are really important

173
00:07:49,160 --> 00:07:50,960
in number theory they are the atoms for

174
00:07:50,960 --> 00:07:54,080
the integers if you will there are a lot

175
00:07:54,080 --> 00:07:55,820
of algorithms in fact that binomial

176
00:07:55,820 --> 00:07:58,880
algorithm you can do faster if you say

177
00:07:58,880 --> 00:08:00,860
well I don't actually have to do all the

178
00:08:00,860 --> 00:08:03,380
numbers up to n I can just go over the

179
00:08:03,380 --> 00:08:06,050
primes so I can speed things up there

180
00:08:06,050 --> 00:08:07,580
are a lot of algorithms in number theory

181
00:08:07,580 --> 00:08:10,250
where it turns out you don't actually

182
00:08:10,250 --> 00:08:13,639
have to go up for instance solve 2n you

183
00:08:13,639 --> 00:08:16,639
can factor in perform your operations on

184
00:08:16,639 --> 00:08:18,800
the prime factors and then combine them

185
00:08:18,800 --> 00:08:21,710
and you come up with much faster ways so

186
00:08:21,710 --> 00:08:22,910
there are three things we generally want

187
00:08:22,910 --> 00:08:26,150
to do generate Prime's recognize primes

188
00:08:26,150 --> 00:08:28,550
and factor integers we don't factor

189
00:08:28,550 --> 00:08:30,450
primes

190
00:08:30,450 --> 00:08:34,500
so the usual way of generating crimes is

191
00:08:34,500 --> 00:08:37,559
the sieve of eratosthenes who wrote

192
00:08:37,559 --> 00:08:41,370
about this in about 250 BC he was the

193
00:08:41,370 --> 00:08:44,760
chief librarian of Alexandria was he

194
00:08:44,760 --> 00:08:47,780
wrote in all sorts of different areas he

195
00:08:47,780 --> 00:08:51,020
contributed to many many many fields

196
00:08:51,020 --> 00:08:53,460
unfortunately all his works were lost

197
00:08:53,460 --> 00:08:57,900
when the library burned but lots of

198
00:08:57,900 --> 00:08:59,490
people wrote about the things he did

199
00:08:59,490 --> 00:09:01,230
including this algorithm and

200
00:09:01,230 --> 00:09:03,240
interestingly there are some new sieves

201
00:09:03,240 --> 00:09:05,720
that have come out in the 20th century

202
00:09:05,720 --> 00:09:08,970
they're all slower than this they have

203
00:09:08,970 --> 00:09:10,350
some interesting properties the sieve of

204
00:09:10,350 --> 00:09:12,690
Atkin actually is slower than the soup

205
00:09:12,690 --> 00:09:14,220
of Eratosthenes I'm going to talk about

206
00:09:14,220 --> 00:09:17,120
just the very basic monolithic

207
00:09:17,120 --> 00:09:20,280
non-segmented sieve you can get

208
00:09:20,280 --> 00:09:22,530
complicated start adding optimizations

209
00:09:22,530 --> 00:09:24,330
like everything you can spend a year

210
00:09:24,330 --> 00:09:28,010
adding optimizations so very simply we

211
00:09:28,010 --> 00:09:30,150
enumerate all our numbers from 2 to n

212
00:09:30,150 --> 00:09:33,960
I've chosen 120 we pick the first one

213
00:09:33,960 --> 00:09:36,720
and say yes that one's prime just they

214
00:09:36,720 --> 00:09:39,900
all kind of look prime right now and we

215
00:09:39,900 --> 00:09:41,910
actually we know that 3 is as well

216
00:09:41,910 --> 00:09:44,010
because we know everything up to 2

217
00:09:44,010 --> 00:09:46,980
squared its prime and we just mark all

218
00:09:46,980 --> 00:09:49,620
the evens because we know they're all

219
00:09:49,620 --> 00:09:52,860
multiples of 2 so then we can move on to

220
00:09:52,860 --> 00:09:54,390
the next one which is 3 and we're gonna

221
00:09:54,390 --> 00:09:56,490
mark all the multiples of 3 because I've

222
00:09:56,490 --> 00:10:00,710
chosen 15 here they're all gonna line up

223
00:10:00,710 --> 00:10:03,390
we can do the same thing for fives

224
00:10:03,390 --> 00:10:06,510
notice that I don't I start at 5 squared

225
00:10:06,510 --> 00:10:08,250
because everything up to that it's

226
00:10:08,250 --> 00:10:13,470
already been marked we go 7 it turns out

227
00:10:13,470 --> 00:10:16,170
at that point we're done because 11

228
00:10:16,170 --> 00:10:18,960
squared is 121 there wasn't a whole lot

229
00:10:18,960 --> 00:10:20,880
of operation going on to generate these

230
00:10:20,880 --> 00:10:25,020
Prime's on Wikipedia you'll find the

231
00:10:25,020 --> 00:10:28,230
pseudocode which it turns out seems to

232
00:10:28,230 --> 00:10:29,490
be remarkably hard for people to

233
00:10:29,490 --> 00:10:33,480
implement it's four lines we go up to

234
00:10:33,480 --> 00:10:36,150
the square root of n we ask if it's

235
00:10:36,150 --> 00:10:38,490
prime if this number is prime so far we

236
00:10:38,490 --> 00:10:42,150
go from I squared up counting by n

237
00:10:42,150 --> 00:10:46,470
so there's an operation that is not done

238
00:10:46,470 --> 00:10:48,630
in here which is remainder or divided

239
00:10:48,630 --> 00:10:50,970
it's a very efficient algorithm because

240
00:10:50,970 --> 00:10:54,080
the only thing going on is marking and

241
00:10:54,080 --> 00:11:00,600
adding so in C we're not going to go

242
00:11:00,600 --> 00:11:02,279
over this very long but basically it's

243
00:11:02,279 --> 00:11:05,040
exactly the same thing as the C here's

244
00:11:05,040 --> 00:11:06,660
our four lines we can argue about I

245
00:11:06,660 --> 00:11:08,670
times I versus taking the integer square

246
00:11:08,670 --> 00:11:13,200
root but there's your four lines and

247
00:11:13,200 --> 00:11:15,230
then we go through when we can do that

248
00:11:15,230 --> 00:11:18,060
Perl five in this case I've done an

249
00:11:18,060 --> 00:11:19,920
additional optimization of only going

250
00:11:19,920 --> 00:11:22,740
through the odds that is we saw most of

251
00:11:22,740 --> 00:11:24,240
that work was it to be very beginning

252
00:11:24,240 --> 00:11:25,770
where we had to mark all the odds well

253
00:11:25,770 --> 00:11:27,330
after two we know we don't have to do it

254
00:11:27,330 --> 00:11:28,470
deal with them at all

255
00:11:28,470 --> 00:11:31,140
sorry just going to ignore them so

256
00:11:31,140 --> 00:11:34,380
here's this is not very pearly code but

257
00:11:34,380 --> 00:11:37,970
it is exactly the same as that C code or

258
00:11:37,970 --> 00:11:41,190
the Wikipedia but in this case we get to

259
00:11:41,190 --> 00:11:44,960
go we skip the odds there is a bit of

260
00:11:44,960 --> 00:11:47,250
wonkiness at the end where we're doing a

261
00:11:47,250 --> 00:11:50,490
map and grep to turn those odds back

262
00:11:50,490 --> 00:11:54,420
into the numbers we care about so we use

263
00:11:54,420 --> 00:11:57,330
half the memory by doing this so on

264
00:11:57,330 --> 00:12:00,959
rosetta code I looked last year and it

265
00:12:00,959 --> 00:12:02,730
was kind of partly the reason for this

266
00:12:02,730 --> 00:12:05,010
so there are three examples of the sieve

267
00:12:05,010 --> 00:12:07,080
of Eratosthenes on rosetta code and all

268
00:12:07,080 --> 00:12:10,500
of them are wrong so they start out okay

269
00:12:10,500 --> 00:12:12,300
they say 0 & 1

270
00:12:12,300 --> 00:12:16,560
not prime everything else looks prime so

271
00:12:16,560 --> 00:12:18,230
far

272
00:12:18,230 --> 00:12:20,540
we do a gather this is this is a cool

273
00:12:20,540 --> 00:12:22,820
feature where we take the key value we

274
00:12:22,820 --> 00:12:24,529
just say I want the actual number and

275
00:12:24,529 --> 00:12:26,389
then I want the value that's in that

276
00:12:26,389 --> 00:12:27,860
array so I can get them both at the same

277
00:12:27,860 --> 00:12:32,000
time and then we do oh well if it looks

278
00:12:32,000 --> 00:12:35,779
prime then take the number but wait what

279
00:12:35,779 --> 00:12:40,010
is this doing that's a mod operator so

280
00:12:40,010 --> 00:12:43,269
for every number from N squared up to n

281
00:12:43,269 --> 00:12:45,769
I'm going and checking the divisibility

282
00:12:45,769 --> 00:12:47,540
I'm basically doing trial division on

283
00:12:47,540 --> 00:12:51,260
every number repeatedly so there's a

284
00:12:51,260 --> 00:12:54,680
simple solution now we have this even

285
00:12:54,680 --> 00:12:59,029
fair toss Denise in Perl 6 looks exactly

286
00:12:59,029 --> 00:13:01,550
like the C code or like the Perl 5 code

287
00:13:01,550 --> 00:13:04,699
or the Wikipedia pseudo code and it runs

288
00:13:04,699 --> 00:13:07,459
significantly faster so Perl 6 has a lot

289
00:13:07,459 --> 00:13:09,470
of different ways to do these things we

290
00:13:09,470 --> 00:13:11,089
can try doing it using a set this is

291
00:13:11,089 --> 00:13:14,089
something someone put on on rosetta code

292
00:13:14,089 --> 00:13:16,639
as well doing with a set we have our

293
00:13:16,639 --> 00:13:21,370
multiples we're gonna gather unless

294
00:13:21,370 --> 00:13:24,470
multiples contains the number we take it

295
00:13:24,470 --> 00:13:27,890
and we do a set Union you can use fancy

296
00:13:27,890 --> 00:13:30,740
Unicode characters for the contains and

297
00:13:30,740 --> 00:13:33,079
Union basically we're making a new set

298
00:13:33,079 --> 00:13:37,579
with number squared that plus number and

299
00:13:37,579 --> 00:13:40,519
so on which is exactly what we wanted

300
00:13:40,519 --> 00:13:44,870
from that pseudocode you could change it

301
00:13:44,870 --> 00:13:47,800
to is the number an element of the set

302
00:13:47,800 --> 00:13:51,940
is the number intersected with the set

303
00:13:51,940 --> 00:13:56,089
we can go straight to exists key lots of

304
00:13:56,089 --> 00:13:58,010
ways to do it we also have this is prime

305
00:13:58,010 --> 00:14:00,860
operator so we could just do well I'm

306
00:14:00,860 --> 00:14:02,269
just gonna walk all the numbers and ask

307
00:14:02,269 --> 00:14:05,690
if it's is prime that's not a sieve but

308
00:14:05,690 --> 00:14:07,310
its prime is built-in so maybe that's

309
00:14:07,310 --> 00:14:10,519
fast and certainly easy it's so easy you

310
00:14:10,519 --> 00:14:13,130
could just do basically grep is prime

311
00:14:13,130 --> 00:14:15,520
through a list

312
00:14:15,520 --> 00:14:19,899
so the set operator so that code has

313
00:14:19,899 --> 00:14:21,700
some significant problems with it and

314
00:14:21,700 --> 00:14:24,130
also pearl six assets haven't been

315
00:14:24,130 --> 00:14:26,170
optimized entirely so we're gonna ignore

316
00:14:26,170 --> 00:14:29,380
that but here's our trial division

317
00:14:29,380 --> 00:14:32,770
it took 401 seconds to generate the

318
00:14:32,770 --> 00:14:34,660
primes to 1 million which is absurdly

319
00:14:34,660 --> 00:14:37,320
slow so we know doing trial division

320
00:14:37,320 --> 00:14:40,029
basically the incorrect sieve of

321
00:14:40,029 --> 00:14:42,810
eratosthenes is the wrong way to do it

322
00:14:42,810 --> 00:14:47,980
here's the is prime version ok so I

323
00:14:47,980 --> 00:14:50,050
wrote a new version of is prime I went

324
00:14:50,050 --> 00:14:52,750
to more VM and started writing C code

325
00:14:52,750 --> 00:14:54,279
and so there's a new version of this

326
00:14:54,279 --> 00:14:55,360
prime and I'll talk about that more

327
00:14:55,360 --> 00:14:58,330
later which is significantly faster and

328
00:14:58,330 --> 00:15:01,570
it's faster at all sizes so hopefully I

329
00:15:01,570 --> 00:15:03,779
will actually get that and pushed out

330
00:15:03,779 --> 00:15:07,959
soon so our sieve actually when you fix

331
00:15:07,959 --> 00:15:09,700
the sieve instead of doing this kind of

332
00:15:09,700 --> 00:15:12,010
broken sieve you do the real one

333
00:15:12,010 --> 00:15:15,580
it's looking pretty good you can do odds

334
00:15:15,580 --> 00:15:17,830
only I didn't show that example but you

335
00:15:17,830 --> 00:15:19,990
can speed that up some more that's

336
00:15:19,990 --> 00:15:22,390
looking good if you increase this who

337
00:15:22,390 --> 00:15:27,100
would start looking better Perl 5 have

338
00:15:27,100 --> 00:15:29,709
had what twenty-something years of

339
00:15:29,709 --> 00:15:33,940
additional optimization and we're

340
00:15:33,940 --> 00:15:37,660
marking and adding this is absolutely

341
00:15:37,660 --> 00:15:42,100
what C loves to do so this is this is a

342
00:15:42,100 --> 00:15:43,899
little bit of an unfair example here

343
00:15:43,899 --> 00:15:45,820
because this is so simple but we've

344
00:15:45,820 --> 00:15:48,190
chosen something very very simple to try

345
00:15:48,190 --> 00:15:49,660
out and seeing there are lots of ways to

346
00:15:49,660 --> 00:15:54,180
do it in Perl 6 and you can speed it up

347
00:15:54,180 --> 00:15:56,529
and in fact you could certainly call C

348
00:15:56,529 --> 00:15:59,290
code from Perl 6 if you wanted to so

349
00:15:59,290 --> 00:16:00,610
we're moving on to the next one how do

350
00:16:00,610 --> 00:16:02,860
we recognize a prime what we can do

351
00:16:02,860 --> 00:16:05,200
trial division which is actually really

352
00:16:05,200 --> 00:16:07,480
good for numbers up to you know a

353
00:16:07,480 --> 00:16:10,540
thousand or a million but if I give you

354
00:16:10,540 --> 00:16:13,720
a 64-bit number and say hey try dividing

355
00:16:13,720 --> 00:16:15,190
by all the numbers up to the square root

356
00:16:15,190 --> 00:16:17,980
of n or if I give you a thousand digit

357
00:16:17,980 --> 00:16:20,680
number you're never going to finish it's

358
00:16:20,680 --> 00:16:23,920
really slow Miller came up with this

359
00:16:23,920 --> 00:16:26,829
method in about 1975 which is very

360
00:16:26,829 --> 00:16:28,050
efficient

361
00:16:28,050 --> 00:16:32,190
and answers the question entirely of

362
00:16:32,190 --> 00:16:34,620
whether a number is prime there's a bit

363
00:16:34,620 --> 00:16:36,300
of a problem step 1

364
00:16:36,300 --> 00:16:38,910
prove the Riemann hypothesis so this has

365
00:16:38,910 --> 00:16:40,350
been giving us a bit of a bother for the

366
00:16:40,350 --> 00:16:43,980
last 150 years so that doesn't really

367
00:16:43,980 --> 00:16:46,890
work very well we can do special forms

368
00:16:46,890 --> 00:16:49,440
there same numbers or protein numbers

369
00:16:49,440 --> 00:16:51,660
that is numbers that are two to the N

370
00:16:51,660 --> 00:16:55,170
minus 1 or to the K times 2 to the n

371
00:16:55,170 --> 00:16:57,690
plus 1 we have some really efficient

372
00:16:57,690 --> 00:17:01,140
ways to do it but that only works for

373
00:17:01,140 --> 00:17:03,060
numbers of that sort if you like to

374
00:17:03,060 --> 00:17:04,949
finding large we're seeing Prime's then

375
00:17:04,949 --> 00:17:06,030
that's nice

376
00:17:06,030 --> 00:17:07,530
but that's not very useful for most

377
00:17:07,530 --> 00:17:10,410
people we can do partial factoring

378
00:17:10,410 --> 00:17:12,809
methods this is really what was used up

379
00:17:12,809 --> 00:17:18,319
to well in the 1800's 1900s up to 1980s

380
00:17:18,319 --> 00:17:22,170
where I take n minus 1 I want to find

381
00:17:22,170 --> 00:17:24,240
out if n is prime I take n minus 1 or n

382
00:17:24,240 --> 00:17:26,939
plus 1 and I perform some factoring on

383
00:17:26,939 --> 00:17:28,920
it I don't have to completely factor the

384
00:17:28,920 --> 00:17:31,710
number but I have to do some factoring

385
00:17:31,710 --> 00:17:34,800
it turns out we did primality fairly

386
00:17:34,800 --> 00:17:37,470
well that method works quite well up to

387
00:17:37,470 --> 00:17:40,020
about 40 digits starts getting slower

388
00:17:40,020 --> 00:17:41,970
and eventually you just can't find

389
00:17:41,970 --> 00:17:45,929
factors so in the 1990s through a couple

390
00:17:45,929 --> 00:17:48,929
methods they're quite efficient a PR CL

391
00:17:48,929 --> 00:17:53,220
+ e CPP AP RCL are the initials of the

392
00:17:53,220 --> 00:17:56,429
people who created the algorithm ECP PZ

393
00:17:56,429 --> 00:17:58,950
looked at curve finality proving I think

394
00:17:58,950 --> 00:18:00,480
there are two reasons people normally

395
00:18:00,480 --> 00:18:02,850
don't use these one is computer

396
00:18:02,850 --> 00:18:05,040
programmers don't usually know that they

397
00:18:05,040 --> 00:18:09,950
exist and two is they're too complicated

398
00:18:09,950 --> 00:18:12,929
Perl 5 has one of the own in the end

399
00:18:12,929 --> 00:18:15,179
theory module has one of the only

400
00:18:15,179 --> 00:18:17,460
implementations of e cpp out there this

401
00:18:17,460 --> 00:18:21,760
open source certainly the fastest

402
00:18:21,760 --> 00:18:24,840
and hopefully Perl six will get one soon

403
00:18:24,840 --> 00:18:28,630
so because these are hard we come up

404
00:18:28,630 --> 00:18:32,190
with this idea of a probable prime so

405
00:18:32,190 --> 00:18:34,660
what to do to find a probable prime you

406
00:18:34,660 --> 00:18:36,430
find some property that all primes have

407
00:18:36,430 --> 00:18:40,120
and that most composites don't have well

408
00:18:40,120 --> 00:18:41,770
if lots of composites have it then it's

409
00:18:41,770 --> 00:18:45,670
not a very useful test but if all

410
00:18:45,670 --> 00:18:47,440
Prime's have this property and very few

411
00:18:47,440 --> 00:18:49,240
composites have this is actually fairly

412
00:18:49,240 --> 00:18:52,380
useful and this is quite commonly used

413
00:18:52,380 --> 00:18:55,930
so the common return values are zero

414
00:18:55,930 --> 00:18:57,730
definitely composite one is probably

415
00:18:57,730 --> 00:19:00,580
prime sometimes we'll add something for

416
00:19:00,580 --> 00:19:05,050
definitely prime and minus one is the if

417
00:19:05,050 --> 00:19:06,970
these are your only responses and you

418
00:19:06,970 --> 00:19:09,220
have for instance you're doing a look ha

419
00:19:09,220 --> 00:19:11,910
lemur test and it's not a Mersin number

420
00:19:11,910 --> 00:19:14,800
well you can't return anything here it's

421
00:19:14,800 --> 00:19:18,810
the wrong form you don't know what it is

422
00:19:18,810 --> 00:19:21,490
no small divisors we're gonna give some

423
00:19:21,490 --> 00:19:24,040
little Perl 6 code here this is a

424
00:19:24,040 --> 00:19:26,380
particularly bad one this just says are

425
00:19:26,380 --> 00:19:29,230
you disabled by 2 or 3 if not you look

426
00:19:29,230 --> 00:19:32,410
kind of prime most humans go something

427
00:19:32,410 --> 00:19:33,960
like this they might go with 5 as well

428
00:19:33,960 --> 00:19:36,220
do something like this I don't know it

429
00:19:36,220 --> 00:19:38,740
looks kind of prime so this is kind of

430
00:19:38,740 --> 00:19:40,270
neat these junctions where we can

431
00:19:40,270 --> 00:19:42,040
basically just instead of saying N

432
00:19:42,040 --> 00:19:45,370
equals 2 or or N equals 3 or and so on

433
00:19:45,370 --> 00:19:49,590
we get to just say N equals 2 or 3

434
00:19:49,650 --> 00:19:53,710
here's the mod 30 version of it all

435
00:19:53,710 --> 00:19:55,780
Prime's passed 5 we're going to have

436
00:19:55,780 --> 00:19:59,410
this property this gets kind of messy in

437
00:19:59,410 --> 00:20:01,450
most languages junctions make this

438
00:20:01,450 --> 00:20:04,650
really simple and easy to read oh if the

439
00:20:04,650 --> 00:20:10,170
remainder after 30 is this great

440
00:20:10,560 --> 00:20:14,560
so for ma I was just in France and they

441
00:20:14,560 --> 00:20:17,470
were telling me yes it is for ma and

442
00:20:17,470 --> 00:20:20,650
Luka in the United States

443
00:20:20,650 --> 00:20:23,680
it's either tomorrow or Fermat if I say

444
00:20:23,680 --> 00:20:25,720
look ha in the United States no one

445
00:20:25,720 --> 00:20:26,980
would have a clue who I was talking

446
00:20:26,980 --> 00:20:31,660
about it's a Lucas there but so Verma

447
00:20:31,660 --> 00:20:34,780
came up with this little theorem which

448
00:20:34,780 --> 00:20:38,290
says if we take an a between 2 and P

449
00:20:38,290 --> 00:20:41,260
minus 1 and we raise to P minus 1 power

450
00:20:41,260 --> 00:20:46,330
and if P is prime it's 1 mod B all

451
00:20:46,330 --> 00:20:49,450
Prime's have this property some

452
00:20:49,450 --> 00:20:53,050
composites do most don't so here in Perl

453
00:20:53,050 --> 00:20:55,210
6 this is a bunch of boilerplates mainly

454
00:20:55,210 --> 00:20:58,090
having to do with small numbers and I'm

455
00:20:58,090 --> 00:21:00,220
gonna you could add restrictions for

456
00:21:00,220 --> 00:21:03,790
making sure your base doesn't succeed it

457
00:21:03,790 --> 00:21:05,320
doesn't go out of range I've decided to

458
00:21:05,320 --> 00:21:07,750
try to make that work it's kind of

459
00:21:07,750 --> 00:21:09,490
irrelevant

460
00:21:09,490 --> 00:21:14,950
wow that's easy the xB mod so there's a

461
00:21:14,950 --> 00:21:15,940
problem

462
00:21:15,940 --> 00:21:19,300
Carmichael came up we said hey there's

463
00:21:19,300 --> 00:21:23,020
this class of numbers where this is true

464
00:21:23,020 --> 00:21:25,720
for Kompas some composites this is true

465
00:21:25,720 --> 00:21:28,300
for every base so you will never be able

466
00:21:28,300 --> 00:21:30,790
to figure out those numbers are prime or

467
00:21:30,790 --> 00:21:32,980
composite because they look prime based

468
00:21:32,980 --> 00:21:37,570
on this test so i lured published a few

469
00:21:37,570 --> 00:21:40,030
papers and one of the things he came up

470
00:21:40,030 --> 00:21:43,170
with was well we can improve this test

471
00:21:43,170 --> 00:21:47,800
so we're gonna have now it is P minus 1

472
00:21:47,800 --> 00:21:52,360
divided by 2 is plus or minus one and

473
00:21:52,360 --> 00:21:55,660
same boilerplate but there we go

474
00:21:55,660 --> 00:21:58,870
note the shift operator is plus the

475
00:21:58,870 --> 00:22:01,890
bitwise shift operator plus greater than

476
00:22:01,890 --> 00:22:06,450
we can use our junction again very easy

477
00:22:06,450 --> 00:22:09,730
oiler also went and said if it's not

478
00:22:09,730 --> 00:22:13,150
just plus or minus 1 it's equal to the

479
00:22:13,150 --> 00:22:15,640
Jacobi symbol

480
00:22:15,640 --> 00:22:19,690
what's the Jacobi symbol so legendre

481
00:22:19,690 --> 00:22:22,150
came up with this idea even earlier and

482
00:22:22,150 --> 00:22:24,820
said well this symbol it's surprisingly

483
00:22:24,820 --> 00:22:28,030
useful in number theory is zero if it

484
00:22:28,030 --> 00:22:31,090
evenly divides P it is one if it is a

485
00:22:31,090 --> 00:22:33,640
quadratic residue that is if there is a

486
00:22:33,640 --> 00:22:35,710
number if that exists that it's a square

487
00:22:35,710 --> 00:22:40,120
mod P and minus one otherwise so here's

488
00:22:40,120 --> 00:22:44,020
a crazy version of Legendre symbol in

489
00:22:44,020 --> 00:22:46,270
Perl six we've used an infix operator

490
00:22:46,270 --> 00:22:50,559
with a special pipe we've made Damien

491
00:22:50,559 --> 00:22:53,860
happy by using italicized characters in

492
00:22:53,860 --> 00:22:59,010
their sigil lists and we're using a

493
00:22:59,010 --> 00:23:02,860
given way so unfortunately this

494
00:23:02,860 --> 00:23:04,330
particular form doesn't help us much

495
00:23:04,330 --> 00:23:05,890
because we're already going through the

496
00:23:05,890 --> 00:23:09,910
same operation the Jacobi symbol is

497
00:23:09,910 --> 00:23:12,130
basically the product of that four

498
00:23:12,130 --> 00:23:13,900
factors but you don't have to factor and

499
00:23:13,900 --> 00:23:16,650
you can do this this kind of ugly code

500
00:23:16,650 --> 00:23:19,090
but it exists you'll see the same code

501
00:23:19,090 --> 00:23:23,110
in lots of languages so now once we have

502
00:23:23,110 --> 00:23:28,440
that very simple Euler Jacobi in Perl 6

503
00:23:28,440 --> 00:23:30,850
we mod n because we're gonna get back a

504
00:23:30,850 --> 00:23:33,460
1 or minus 1 so this is a simple way to

505
00:23:33,460 --> 00:23:35,230
do it and all of a sudden our

506
00:23:35,230 --> 00:23:38,590
Charmichael both numbers go away this

507
00:23:38,590 --> 00:23:41,679
test if you run random a values it turns

508
00:23:41,679 --> 00:23:44,410
out that no more than half of the a

509
00:23:44,410 --> 00:23:46,270
values are going to work for any

510
00:23:46,270 --> 00:23:49,390
composite so Sullivan strossen made this

511
00:23:49,390 --> 00:23:51,880
a prime ala t-test you've probably heard

512
00:23:51,880 --> 00:23:53,950
of the Miller ravine grunt test this

513
00:23:53,950 --> 00:23:57,669
came first and now we'll go to Miller

514
00:23:57,669 --> 00:24:00,429
ravine you've may have seen this before

515
00:24:00,429 --> 00:24:03,580
we take n minus 1 basically take out the

516
00:24:03,580 --> 00:24:07,900
odd part and run this routine I'm not

517
00:24:07,900 --> 00:24:11,710
going to go over the math behind it but

518
00:24:11,710 --> 00:24:13,600
that one also has no Carmichael numbers

519
00:24:13,600 --> 00:24:15,610
is is classically used this looks

520
00:24:15,610 --> 00:24:17,860
exactly like she code you'll find

521
00:24:17,860 --> 00:24:23,169
everywhere for this so in purl 6 with

522
00:24:23,169 --> 00:24:25,990
this idea that we'll the chance of being

523
00:24:25,990 --> 00:24:27,619
a composite

524
00:24:27,619 --> 00:24:30,690
passing this test is one-quarter if you

525
00:24:30,690 --> 00:24:34,019
use random basis then your chance is 4

526
00:24:34,019 --> 00:24:36,839
to the minus K which goes very small

527
00:24:36,839 --> 00:24:39,179
very quickly pearl success will use a

528
00:24:39,179 --> 00:24:41,190
hundred basis for this this is a great

529
00:24:41,190 --> 00:24:44,099
idea No

530
00:24:44,099 --> 00:24:46,889
so the reason why this is not a good

531
00:24:46,889 --> 00:24:49,109
idea is actually twofold the number one

532
00:24:49,109 --> 00:24:52,259
is in more VM he uses zlib Tom math and

533
00:24:52,259 --> 00:24:54,329
Lib dog math does not use random basis

534
00:24:54,329 --> 00:24:59,039
he's the first 100 prime basis which

535
00:24:59,039 --> 00:25:01,019
sounds great until you find out that in

536
00:25:01,019 --> 00:25:02,039
1994

537
00:25:02,039 --> 00:25:03,809
someone published a paper which showed

538
00:25:03,809 --> 00:25:05,489
you how to generate counter examples to

539
00:25:05,489 --> 00:25:08,459
this so this is a particular number that

540
00:25:08,459 --> 00:25:10,259
he published there's an algorithm to

541
00:25:10,259 --> 00:25:13,559
generate these and Perl 6 will tell you

542
00:25:13,559 --> 00:25:18,719
that this is prime it is not prime there

543
00:25:18,719 --> 00:25:20,639
are ways to fix this we'll talk about

544
00:25:20,639 --> 00:25:22,799
that in a minute the other thing is

545
00:25:22,799 --> 00:25:25,200
using a hundred of these tests is a

546
00:25:25,200 --> 00:25:26,969
significant overkill we don't need to do

547
00:25:26,969 --> 00:25:29,149
that ths so that's a performance issues

548
00:25:29,149 --> 00:25:31,889
and this was a common method in the

549
00:25:31,889 --> 00:25:35,729
1980s early 90s some people published

550
00:25:35,729 --> 00:25:37,649
papers and said you know this is really

551
00:25:37,649 --> 00:25:40,820
problematic for a number of reasons

552
00:25:40,820 --> 00:25:44,309
so Perl 6 used to have in the language

553
00:25:44,309 --> 00:25:46,950
specification that is prime took a

554
00:25:46,950 --> 00:25:49,649
parameter of the number of trials for

555
00:25:49,649 --> 00:25:53,279
Miller ravine which I particularly

556
00:25:53,279 --> 00:25:55,049
disliked because it put implementation

557
00:25:55,049 --> 00:25:57,379
details into the language itself

558
00:25:57,379 --> 00:25:59,759
fortunately that was all removed before

559
00:25:59,759 --> 00:26:01,950
the language came out so we can apply

560
00:26:01,950 --> 00:26:04,889
better methods without changing the API

561
00:26:04,889 --> 00:26:07,799
as long as we do the right thing so the

562
00:26:07,799 --> 00:26:10,529
BPS w test is the way that most people

563
00:26:10,529 --> 00:26:12,599
have standardized on you do a single

564
00:26:12,599 --> 00:26:14,549
Miller ravine test and you do an Luka

565
00:26:14,549 --> 00:26:18,269
test hopefully a strong test this is my

566
00:26:18,269 --> 00:26:21,109
wall of text that I should not do in

567
00:26:21,109 --> 00:26:24,959
talks it was published in 1980 it is

568
00:26:24,959 --> 00:26:27,739
deterministic for all 64 bit in numbers

569
00:26:27,739 --> 00:26:29,940
no counter examples have been found

570
00:26:29,940 --> 00:26:31,709
there are at least two theses where

571
00:26:31,709 --> 00:26:33,869
people worked hard on trying to find

572
00:26:33,869 --> 00:26:35,609
counter examples using very clever math

573
00:26:35,609 --> 00:26:38,039
to say well I'm sure that this set

574
00:26:38,039 --> 00:26:40,109
contains it the only problem is this set

575
00:26:40,109 --> 00:26:41,100
is a

576
00:26:41,100 --> 00:26:44,730
sighs to to the 1,000 something and so

577
00:26:44,730 --> 00:26:48,870
one of those numbers in that set might

578
00:26:48,870 --> 00:26:51,240
be a counterexample so we haven't found

579
00:26:51,240 --> 00:26:54,210
that yet almost all math programs use

580
00:26:54,210 --> 00:26:57,450
this and go Julia and Python modules

581
00:26:57,450 --> 00:26:59,400
have all started moving to this so I

582
00:26:59,400 --> 00:27:01,770
have an implementation in more VM for

583
00:27:01,770 --> 00:27:04,049
this and it should be pretty easy to put

584
00:27:04,049 --> 00:27:09,620
it in JVM as well and it's faster so

585
00:27:09,620 --> 00:27:11,490
getting a couple of methods for

586
00:27:11,490 --> 00:27:12,960
factoring I'm not gonna talk about all

587
00:27:12,960 --> 00:27:16,020
of these trial division very

588
00:27:16,020 --> 00:27:20,010
straightforward per ma busy guy also

589
00:27:20,010 --> 00:27:22,010
came up with the method for factoring

590
00:27:22,010 --> 00:27:26,159
Pollard has this ro method and P minus

591
00:27:26,159 --> 00:27:29,250
one very common square form

592
00:27:29,250 --> 00:27:32,309
factorization ECM quadratic sieve and

593
00:27:32,309 --> 00:27:34,440
NFS are all commonly used NFS is

594
00:27:34,440 --> 00:27:37,770
generally a PhD level prof I think there

595
00:27:37,770 --> 00:27:39,710
are two implementations out there

596
00:27:39,710 --> 00:27:41,580
certainly I'm not going to show you an

597
00:27:41,580 --> 00:27:44,250
implementation it would be tens of

598
00:27:44,250 --> 00:27:47,809
thousands of lines so trial division

599
00:27:47,809 --> 00:27:51,840
Damian showed an example in his talk the

600
00:27:51,840 --> 00:27:54,360
primary difference here is just that

601
00:27:54,360 --> 00:27:56,610
when you find a factor you need just

602
00:27:56,610 --> 00:28:00,299
your new composite you need to start

603
00:28:00,299 --> 00:28:06,150
looking less I guess I should say a lot

604
00:28:06,150 --> 00:28:08,400
of the examples do not do this just of

605
00:28:08,400 --> 00:28:10,650
redoing the limit and so they do a lot

606
00:28:10,650 --> 00:28:13,380
more work this is useful for small

607
00:28:13,380 --> 00:28:15,740
numbers

608
00:28:16,739 --> 00:28:21,389
for ma we do basically we're looking for

609
00:28:21,389 --> 00:28:23,249
differences of squares all odd numbers

610
00:28:23,249 --> 00:28:25,289
can be represented as differences of

611
00:28:25,289 --> 00:28:27,749
squares from ah said yeah if they're two

612
00:28:27,749 --> 00:28:29,940
factors are close to each other we can

613
00:28:29,940 --> 00:28:32,549
find this fairly quickly we have this is

614
00:28:32,549 --> 00:28:35,909
perfect square predicate so how do you

615
00:28:35,909 --> 00:28:39,080
find perfect squares that is a number

616
00:28:39,080 --> 00:28:43,499
that is s times s equals n is n a

617
00:28:43,499 --> 00:28:46,769
perfect square so you'd think oh well I

618
00:28:46,769 --> 00:28:48,929
can just write it like this I have big

619
00:28:48,929 --> 00:28:51,239
big numbers so big in it's great I just

620
00:28:51,239 --> 00:28:53,519
take the square root of n turn that into

621
00:28:53,519 --> 00:28:56,629
an integer and see if that returns that

622
00:28:56,629 --> 00:29:01,259
but we then realize Perl 6 does not have

623
00:29:01,259 --> 00:29:03,570
big floating-point numbers so that

624
00:29:03,570 --> 00:29:05,549
actually doesn't work so the right thing

625
00:29:05,549 --> 00:29:08,159
to do is write a integer square root

626
00:29:08,159 --> 00:29:11,119
routine I did not do that yet

627
00:29:11,119 --> 00:29:14,580
about 64 53 bits this starts failing

628
00:29:14,580 --> 00:29:17,909
it's just like see just like pro/5 this

629
00:29:17,909 --> 00:29:20,190
is a way to solve the problem it's not

630
00:29:20,190 --> 00:29:23,519
ever it's fine for 64 bit it gets very

631
00:29:23,519 --> 00:29:25,580
very slow this is the wrong way to do it

632
00:29:25,580 --> 00:29:28,940
or it's an inefficient way to do it so

633
00:29:28,940 --> 00:29:32,759
some other people have said you can

634
00:29:32,759 --> 00:29:33,989
actually do some tests so you can

635
00:29:33,989 --> 00:29:35,399
actually quickly look at a number and

636
00:29:35,399 --> 00:29:37,739
find out for some simple properties is

637
00:29:37,739 --> 00:29:40,499
this is it possible this is a perfect

638
00:29:40,499 --> 00:29:42,599
square so we can run that final test

639
00:29:42,599 --> 00:29:43,919
less often

640
00:29:43,919 --> 00:29:45,349
if square root is are really expensive

641
00:29:45,349 --> 00:29:47,909
you can do some very simple math to

642
00:29:47,909 --> 00:29:51,059
avoid it you can also be clever with

643
00:29:51,059 --> 00:29:52,649
bits and do it

644
00:29:52,649 --> 00:29:56,369
notice the shifting the bitwise and is a

645
00:29:56,369 --> 00:29:59,070
little different in Perl 6 you can go

646
00:29:59,070 --> 00:30:00,690
totally crazy

647
00:30:00,690 --> 00:30:02,879
if square roots are really expensive and

648
00:30:02,879 --> 00:30:04,409
you can continue this process these are

649
00:30:04,409 --> 00:30:07,440
using bloom filters which are basically

650
00:30:07,440 --> 00:30:09,210
a way of filtering out anything that

651
00:30:09,210 --> 00:30:12,210
isn't going to be possible using

652
00:30:12,210 --> 00:30:16,700
different simple divisors

653
00:30:17,370 --> 00:30:20,250
so Pollard row Damian showed this

654
00:30:20,250 --> 00:30:23,160
example this is with Brent's cycle

655
00:30:23,160 --> 00:30:26,970
optimization Damian said that this was

656
00:30:26,970 --> 00:30:29,430
called row algorithm because it uses a

657
00:30:29,430 --> 00:30:31,830
variable called row it doesn't use a

658
00:30:31,830 --> 00:30:33,270
variable called row and it's not at all

659
00:30:33,270 --> 00:30:36,090
the reason why that's named that it's a

660
00:30:36,090 --> 00:30:38,790
really fuzzy image the idea is we're

661
00:30:38,790 --> 00:30:41,430
trying to use the birthday paradox to

662
00:30:41,430 --> 00:30:43,500
find examples where we can find a

663
00:30:43,500 --> 00:30:46,260
collision so we have two processes

664
00:30:46,260 --> 00:30:48,480
running one going slow one going fast

665
00:30:48,480 --> 00:30:50,970
and the idea is when can we find an

666
00:30:50,970 --> 00:30:54,060
example where they correspond and if you

667
00:30:54,060 --> 00:30:56,670
graph this out somebody said well it

668
00:30:56,670 --> 00:31:00,000
looks kind of like a row simple and

669
00:31:00,000 --> 00:31:02,880
that's why it's called polar TRO and it

670
00:31:02,880 --> 00:31:05,820
is really really fast at finding small

671
00:31:05,820 --> 00:31:08,070
factors when I say small I mean say

672
00:31:08,070 --> 00:31:11,790
eight digit ten digits it doesn't matter

673
00:31:11,790 --> 00:31:14,670
how big your number is if it has a small

674
00:31:14,670 --> 00:31:18,270
factor you know under ten digits this is

675
00:31:18,270 --> 00:31:20,130
going to be extremely fast to finding it

676
00:31:20,130 --> 00:31:23,400
so it's not useful for solving RSA

677
00:31:23,400 --> 00:31:25,440
cryptography if your keys were generated

678
00:31:25,440 --> 00:31:27,480
correctly you have to very very large

679
00:31:27,480 --> 00:31:29,100
factors not gonna work at all

680
00:31:29,100 --> 00:31:32,790
but for small factors this is really

681
00:31:32,790 --> 00:31:37,260
common and this is polar it's P minus

682
00:31:37,260 --> 00:31:40,620
one algorithm was trivial to write

683
00:31:40,620 --> 00:31:45,240
straight from Wikipedia in Perl 6 it

684
00:31:45,240 --> 00:31:47,640
basically says well maybe I'm having a

685
00:31:47,640 --> 00:31:49,860
hard time factoring n but what if n

686
00:31:49,860 --> 00:31:53,370
minus 1 has a lot of small factors and

687
00:31:53,370 --> 00:31:58,560
if it does we can factor n very quickly

688
00:31:58,560 --> 00:32:01,860
and that pretty much concludes my talk

689
00:32:01,860 --> 00:32:06,390
on Pro six and number theory

690
00:32:06,390 --> 00:32:14,459
[Applause]

