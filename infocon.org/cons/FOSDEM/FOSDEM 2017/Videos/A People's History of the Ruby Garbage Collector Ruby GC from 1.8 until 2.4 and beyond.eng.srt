1
00:00:00,000 --> 00:00:04,730
[Applause]

2
00:00:04,730 --> 00:00:08,220
hi as you can probably rapidly tell from

3
00:00:08,220 --> 00:00:10,320
my accent I'm not actually from the UK

4
00:00:10,320 --> 00:00:12,690
what he means is I was in the UK before

5
00:00:12,690 --> 00:00:14,219
I came to foz then I went to the

6
00:00:14,219 --> 00:00:16,260
Manchester United game on Wednesday to

7
00:00:16,260 --> 00:00:18,449
watch our awful terrible draw against

8
00:00:18,449 --> 00:00:20,369
Hull but it was still fun I still

9
00:00:20,369 --> 00:00:22,740
enjoyed it okay so but let's talk about

10
00:00:22,740 --> 00:00:26,520
Ruby garbage collection so I have a

11
00:00:26,520 --> 00:00:29,160
performance consultancy called speed

12
00:00:29,160 --> 00:00:31,230
shop where I work with companies on

13
00:00:31,230 --> 00:00:33,570
their Ruby and rails applications to

14
00:00:33,570 --> 00:00:36,239
make them faster to make them more

15
00:00:36,239 --> 00:00:39,629
performant and one of I would say the

16
00:00:39,629 --> 00:00:43,399
number one issues that I tend to see is

17
00:00:43,399 --> 00:00:46,739
companies that don't understand memory

18
00:00:46,739 --> 00:00:49,079
usage in their ruby applications and one

19
00:00:49,079 --> 00:00:51,030
of the big reasons for that is because

20
00:00:51,030 --> 00:00:52,800
we have a garbage collecting language

21
00:00:52,800 --> 00:00:54,539
you're not supposed to think about

22
00:00:54,539 --> 00:00:56,069
memory you're supposed to just write the

23
00:00:56,069 --> 00:00:59,309
code you want to write and that is you

24
00:00:59,309 --> 00:01:00,899
know the garbage is collected afterward

25
00:01:00,899 --> 00:01:03,420
and everything's fine and that you you

26
00:01:03,420 --> 00:01:07,820
can't intentionally write leaks right

27
00:01:07,820 --> 00:01:10,770
but it's a little more complicated than

28
00:01:10,770 --> 00:01:12,420
that and so I thought we could all

29
00:01:12,420 --> 00:01:14,190
benefit if we understood a little bit

30
00:01:14,190 --> 00:01:16,830
more about how garbage collection

31
00:01:16,830 --> 00:01:19,320
actually works and how its evolved and

32
00:01:19,320 --> 00:01:21,330
gotten a lot more complicated since

33
00:01:21,330 --> 00:01:25,620
those long-ago days of ruby 1.8 this

34
00:01:25,620 --> 00:01:26,850
talk is beginner-friendly

35
00:01:26,850 --> 00:01:28,890
that's why it's a people's history it's

36
00:01:28,890 --> 00:01:31,710
by the people for the people if you're a

37
00:01:31,710 --> 00:01:33,150
really core team member you probably

38
00:01:33,150 --> 00:01:34,740
will not find anything interesting or

39
00:01:34,740 --> 00:01:38,990
novel in this talk and I've tried to

40
00:01:38,990 --> 00:01:43,050
structure all of this so that if you

41
00:01:43,050 --> 00:01:44,220
don't know anything about garbage

42
00:01:44,220 --> 00:01:45,690
collection or if you don't know anything

43
00:01:45,690 --> 00:01:49,080
about garbage collection algorithms this

44
00:01:49,080 --> 00:01:51,420
should not be too challenging for you to

45
00:01:51,420 --> 00:01:57,600
understand okay so I would say that the

46
00:01:57,600 --> 00:02:00,060
whole history of Ruby's garbage

47
00:02:00,060 --> 00:02:02,640
collector has mostly been about how do

48
00:02:02,640 --> 00:02:06,600
we reduce GC pause times how do we

49
00:02:06,600 --> 00:02:08,479
reduce the amount of time that we spend

50
00:02:08,479 --> 00:02:12,150
stopped to garbage collect because in

51
00:02:12,150 --> 00:02:15,870
Ruby we have to in MRI see Ruby which is

52
00:02:15,870 --> 00:02:17,010
what I'm talking about here today I'm

53
00:02:17,010 --> 00:02:17,240
not

54
00:02:17,240 --> 00:02:19,970
talking about JRuby or truffle Ruby

55
00:02:19,970 --> 00:02:21,590
those guys have their own garbage

56
00:02:21,590 --> 00:02:23,150
collectors that work in completely

57
00:02:23,150 --> 00:02:26,620
different much more complicated ways in

58
00:02:26,620 --> 00:02:31,220
C Ruby were mostly that this evolution

59
00:02:31,220 --> 00:02:33,380
over time we're trying to reduce the

60
00:02:33,380 --> 00:02:34,520
amount of time we have to spend stopped

61
00:02:34,520 --> 00:02:36,440
to garbage collect we have to stop

62
00:02:36,440 --> 00:02:39,380
during garbage collection because if we

63
00:02:39,380 --> 00:02:41,540
allow things to move along and execute

64
00:02:41,540 --> 00:02:42,830
Ruby during garbage collection we're

65
00:02:42,830 --> 00:02:44,930
gonna lose track of which objects we've

66
00:02:44,930 --> 00:02:47,330
already looked at to see if they're free

67
00:02:47,330 --> 00:02:51,800
or not which ones we we haven't and you

68
00:02:51,800 --> 00:02:53,150
know we're gonna end up with with memory

69
00:02:53,150 --> 00:02:54,470
bugs right so we have to stop for

70
00:02:54,470 --> 00:02:56,180
periods of time and say stop execution

71
00:02:56,180 --> 00:02:58,250
hold on which these objects are being

72
00:02:58,250 --> 00:03:01,640
used and which of them are not but if we

73
00:03:01,640 --> 00:03:03,500
pause for a very long time that would

74
00:03:03,500 --> 00:03:05,720
cause pretty bad behavior especially in

75
00:03:05,720 --> 00:03:08,930
a web application so if we need to spend

76
00:03:08,930 --> 00:03:11,780
a half a second garbage collecting which

77
00:03:11,780 --> 00:03:15,650
was not uncommon in ruby 1.8 days then

78
00:03:15,650 --> 00:03:18,680
what happens if we spent hat we have 50

79
00:03:18,680 --> 00:03:20,570
milliseconds of in our web response

80
00:03:20,570 --> 00:03:22,700
we're doing our normal work and then op

81
00:03:22,700 --> 00:03:26,120
crap we need a GC so the person getting

82
00:03:26,120 --> 00:03:27,530
this response has to wait a half a

83
00:03:27,530 --> 00:03:30,470
second for that to complete and then you

84
00:03:30,470 --> 00:03:31,700
do the rest of the work of the request

85
00:03:31,700 --> 00:03:34,100
50 milliseconds whatever so a 100

86
00:03:34,100 --> 00:03:35,780
millisecond request now takes 600

87
00:03:35,780 --> 00:03:37,580
milliseconds so that's not really

88
00:03:37,580 --> 00:03:40,100
acceptable so really this history is

89
00:03:40,100 --> 00:03:42,220
about how do we make these GC pauses

90
00:03:42,220 --> 00:03:45,790
shorter and more interleaved throughout

91
00:03:45,790 --> 00:03:50,380
at the application actually running

92
00:03:50,480 --> 00:03:55,250
so let's start with 1.8 this 1.8 employ

93
00:03:55,250 --> 00:03:57,739
and as far as I know from Ruby's

94
00:03:57,739 --> 00:04:00,830
inception employed a mark and sweep

95
00:04:00,830 --> 00:04:02,420
garbage collection algorithm this is

96
00:04:02,420 --> 00:04:04,519
really the simplest possible garbage

97
00:04:04,519 --> 00:04:08,440
collection algorithm that you can have

98
00:04:08,440 --> 00:04:11,000
so to talk about how mark-and-sweep

99
00:04:11,000 --> 00:04:12,800
works I need to explain to you how Ruby

100
00:04:12,800 --> 00:04:16,250
organizes this memory Ruby objects are

101
00:04:16,250 --> 00:04:17,810
organized in something called the object

102
00:04:17,810 --> 00:04:19,728
space sometimes this is called the heap

103
00:04:19,728 --> 00:04:21,139
but I find that slightly confusing

104
00:04:21,139 --> 00:04:23,090
object spaces the name of the module

105
00:04:23,090 --> 00:04:25,639
that you can use to inspect the object

106
00:04:25,639 --> 00:04:27,560
space so I'm just gonna call this part

107
00:04:27,560 --> 00:04:29,900
of the Ruby's heap the object space it's

108
00:04:29,900 --> 00:04:31,820
basically just a list of Ruby objects so

109
00:04:31,820 --> 00:04:34,490
every Ruby object has one R value which

110
00:04:34,490 --> 00:04:36,620
is the name of the C structure it you

111
00:04:36,620 --> 00:04:38,930
that we're hold these Ruby objects right

112
00:04:38,930 --> 00:04:41,990
our values are 40 bytes and they contain

113
00:04:41,990 --> 00:04:45,610
some information about the Ruby object

114
00:04:46,060 --> 00:04:49,280
it's just a list of values just a list

115
00:04:49,280 --> 00:04:52,910
of some flags like have we marker this

116
00:04:52,910 --> 00:04:55,940
object yet for garbage collection some

117
00:04:55,940 --> 00:04:57,830
other some other information and also

118
00:04:57,830 --> 00:04:59,870
some very basic information about the

119
00:04:59,870 --> 00:05:01,370
object this all depends on what type of

120
00:05:01,370 --> 00:05:03,350
object it is if it's a string and array

121
00:05:03,350 --> 00:05:07,490
etc etc etc if it's a string you know if

122
00:05:07,490 --> 00:05:09,470
it's a very small string we can contain

123
00:05:09,470 --> 00:05:12,560
that string right in the R value it's

124
00:05:12,560 --> 00:05:14,750
actually like 23 bytes or smaller is

125
00:05:14,750 --> 00:05:16,340
like a whole great blog post by Pat

126
00:05:16,340 --> 00:05:18,260
Shaughnessy about why Ruby can only

127
00:05:18,260 --> 00:05:21,260
store 23 byte strings inside the R value

128
00:05:21,260 --> 00:05:25,820
if the data is too large to store in the

129
00:05:25,820 --> 00:05:28,300
R value so strings longer than 24

130
00:05:28,300 --> 00:05:32,120
characters or arrays of 5 elements or

131
00:05:32,120 --> 00:05:34,310
more so if it's too big to fit in that R

132
00:05:34,310 --> 00:05:36,530
value we just store the pointer to space

133
00:05:36,530 --> 00:05:41,000
somewhere else on Ruby's heap the object

134
00:05:41,000 --> 00:05:44,510
space is a list of 16 kilobyte heap

135
00:05:44,510 --> 00:05:48,289
pages and of 400 R values each so it's

136
00:05:48,289 --> 00:05:49,880
just a long list of these these heat

137
00:05:49,880 --> 00:05:51,830
pages which each which contain all of

138
00:05:51,830 --> 00:05:56,210
our are our values so what triggers GC I

139
00:05:56,210 --> 00:05:58,250
think one common misconception is that

140
00:05:58,250 --> 00:06:00,890
GC just sort of well people don't really

141
00:06:00,890 --> 00:06:02,930
understand when it runs at all that kind

142
00:06:02,930 --> 00:06:03,370
of runs

143
00:06:03,370 --> 00:06:05,260
Loup more like it runs every five

144
00:06:05,260 --> 00:06:08,050
seconds or whatever really there are two

145
00:06:08,050 --> 00:06:10,000
main things that trigger GC although

146
00:06:10,000 --> 00:06:11,470
there's more conditions in this that I'm

147
00:06:11,470 --> 00:06:14,199
not gonna get into either we run out of

148
00:06:14,199 --> 00:06:17,229
open slots for new our values or we

149
00:06:17,229 --> 00:06:21,220
allocate enough memory on the heap that

150
00:06:21,220 --> 00:06:25,479
triggers that that passes a limit so if

151
00:06:25,479 --> 00:06:27,880
we just run out of object slots we have

152
00:06:27,880 --> 00:06:30,130
to we have to get new slots right so our

153
00:06:30,130 --> 00:06:32,560
Ruby will garbage collect to try to

154
00:06:32,560 --> 00:06:35,080
reuse the slots that it has already

155
00:06:35,080 --> 00:06:39,400
allocated for itself the other malloc

156
00:06:39,400 --> 00:06:43,770
limit is when so I like I said if in a

157
00:06:43,770 --> 00:06:46,000
string for examples a thousand

158
00:06:46,000 --> 00:06:48,430
characters long it's gonna have to

159
00:06:48,430 --> 00:06:50,440
allocate space on the heap for that

160
00:06:50,440 --> 00:06:51,610
thousand character string because it

161
00:06:51,610 --> 00:06:54,100
doesn't fit in the R value right so

162
00:06:54,100 --> 00:06:55,630
that's a thousand characters which would

163
00:06:55,630 --> 00:07:00,270
be a 8000 bytes or whatever or bits so

164
00:07:00,270 --> 00:07:03,160
once that the amount of space that we

165
00:07:03,160 --> 00:07:05,530
allocate in that way crosses a certain

166
00:07:05,530 --> 00:07:09,490
threshold we garbage collect okay that's

167
00:07:09,490 --> 00:07:11,050
called the malloc limit there's also

168
00:07:11,050 --> 00:07:12,729
some other limits which I'm not going to

169
00:07:12,729 --> 00:07:13,599
talk about but those are kind of the

170
00:07:13,599 --> 00:07:15,099
main things that end up triggering GC

171
00:07:15,099 --> 00:07:19,240
and Ruby so we trigger a GC we're gonna

172
00:07:19,240 --> 00:07:21,639
start with the root objects and root

173
00:07:21,639 --> 00:07:23,260
objects are things like classes

174
00:07:23,260 --> 00:07:27,070
constants things that don't get garbage

175
00:07:27,070 --> 00:07:29,800
collected ever so we start with like you

176
00:07:29,800 --> 00:07:31,780
know the rails that application object

177
00:07:31,780 --> 00:07:33,430
and then we're gonna look for all the

178
00:07:33,430 --> 00:07:35,860
references of that object and traversed

179
00:07:35,860 --> 00:07:38,560
out in the object graph so each object

180
00:07:38,560 --> 00:07:40,270
that references rails dot application

181
00:07:40,270 --> 00:07:42,550
for example which I don't know if is

182
00:07:42,550 --> 00:07:44,380
really a route object or not maybe rails

183
00:07:44,380 --> 00:07:47,530
dot is but anyway we started our route

184
00:07:47,530 --> 00:07:48,160
object

185
00:07:48,160 --> 00:07:51,430
Traverse down the object graph until

186
00:07:51,430 --> 00:07:53,800
we've marked everything that references

187
00:07:53,800 --> 00:07:56,139
each other and then any object at the

188
00:07:56,139 --> 00:07:58,300
end of that which hasn't been marked is

189
00:07:58,300 --> 00:08:00,760
free because it's nothing's referencing

190
00:08:00,760 --> 00:08:04,120
it right pretty simple and then all the

191
00:08:04,120 --> 00:08:08,289
three are value slots get added to the

192
00:08:08,289 --> 00:08:13,150
free list simple as that and then in the

193
00:08:13,150 --> 00:08:15,700
future and then so that's that's the

194
00:08:15,700 --> 00:08:17,110
marking phase and then

195
00:08:17,110 --> 00:08:18,880
I just say marking phase and then sweep

196
00:08:18,880 --> 00:08:21,460
puts objects into the free list okay so

197
00:08:21,460 --> 00:08:24,490
setting the mark bits marking objects is

198
00:08:24,490 --> 00:08:26,320
one phase sweeping them into the free

199
00:08:26,320 --> 00:08:28,090
list is the next and then the next time

200
00:08:28,090 --> 00:08:32,140
we need an R value slot for an object we

201
00:08:32,140 --> 00:08:34,390
just grab one off the free list if we

202
00:08:34,390 --> 00:08:37,179
run out of even if after garbage

203
00:08:37,179 --> 00:08:38,740
collection if we still don't have any

204
00:08:38,740 --> 00:08:42,970
any free slots then we allocate more

205
00:08:42,970 --> 00:08:46,210
slots using malloc to put more slot to

206
00:08:46,210 --> 00:08:47,890
create more heat pages and get more

207
00:08:47,890 --> 00:08:50,160
slots

208
00:08:50,530 --> 00:08:52,900
we're in 1.8 this is done with the FL

209
00:08:52,900 --> 00:08:55,300
mark flag this is one of the flags in

210
00:08:55,300 --> 00:08:59,110
our value at the time and you just set

211
00:08:59,110 --> 00:09:01,240
that to 1 or 0 after you mark an object

212
00:09:01,240 --> 00:09:03,640
if it was 0 when you were all done

213
00:09:03,640 --> 00:09:06,550
marking that was a free object of course

214
00:09:06,550 --> 00:09:08,080
sorry I should say an object that could

215
00:09:08,080 --> 00:09:11,680
be freed during sweeping so garbage

216
00:09:11,680 --> 00:09:12,940
collection looked like this you had a

217
00:09:12,940 --> 00:09:14,890
whole long mark phase a whole long

218
00:09:14,890 --> 00:09:16,840
Sweetface then you were done with GC you

219
00:09:16,840 --> 00:09:18,040
could go do whatever you wanted to do

220
00:09:18,040 --> 00:09:20,050
and then you have two GC again

221
00:09:20,050 --> 00:09:22,150
eventually in a long Mark phase a long

222
00:09:22,150 --> 00:09:25,710
sweep phase sweeping always immediately

223
00:09:25,710 --> 00:09:28,900
came after marking there's no pause in

224
00:09:28,900 --> 00:09:32,020
between and so in a large rails

225
00:09:32,020 --> 00:09:35,050
application that had 400,000 objects you

226
00:09:35,050 --> 00:09:37,300
know even a million active objects this

227
00:09:37,300 --> 00:09:39,580
could take a very long time you know

228
00:09:39,580 --> 00:09:42,250
could take a million million objects

229
00:09:42,250 --> 00:09:44,500
could take a second to to mark all the

230
00:09:44,500 --> 00:09:46,000
way through right because we have to

231
00:09:46,000 --> 00:09:49,030
mark through the entire object graph so

232
00:09:49,030 --> 00:09:50,850
that takes a long time

233
00:09:50,850 --> 00:09:53,530
no Ruby can be executed during that time

234
00:09:53,530 --> 00:09:55,660
and like I said that's not really

235
00:09:55,660 --> 00:09:57,190
convenient for a web application where

236
00:09:57,190 --> 00:09:59,290
if normally your responses only take ten

237
00:09:59,290 --> 00:10:01,750
milliseconds to process if someone gets

238
00:10:01,750 --> 00:10:03,970
10 milliseconds plus one second of GC

239
00:10:03,970 --> 00:10:07,120
pause that that's kind of annoying and

240
00:10:07,120 --> 00:10:13,600
not really performant so next came 1.8

241
00:10:13,600 --> 00:10:14,860
Ruby Enterprise Edition this is a

242
00:10:14,860 --> 00:10:16,840
project of fusion with the guys that

243
00:10:16,840 --> 00:10:20,830
write the passenger web server this was

244
00:10:20,830 --> 00:10:23,530
kind of like the big I don't know if

245
00:10:23,530 --> 00:10:25,000
anyone's anyone here use Ruby Enterprise

246
00:10:25,000 --> 00:10:26,860
Edition that's kind of like old-school

247
00:10:26,860 --> 00:10:27,370
now yeah

248
00:10:27,370 --> 00:10:29,830
so like it had a couple things going for

249
00:10:29,830 --> 00:10:30,450
it one of it

250
00:10:30,450 --> 00:10:32,820
was its support for copy-on-write memory

251
00:10:32,820 --> 00:10:36,480
so let's talk about copy-on-write we

252
00:10:36,480 --> 00:10:37,770
have these things called forking web

253
00:10:37,770 --> 00:10:39,030
servers in Ruby because we don't have

254
00:10:39,030 --> 00:10:41,670
real concur real parallelism I should

255
00:10:41,670 --> 00:10:44,250
say you can't execute two bits of Ruby

256
00:10:44,250 --> 00:10:45,600
code at the same time so what we do

257
00:10:45,600 --> 00:10:46,950
instead is we have two different

258
00:10:46,950 --> 00:10:49,470
processes two different web server

259
00:10:49,470 --> 00:10:51,150
processes that are the same right and

260
00:10:51,150 --> 00:10:53,760
can just execute different responses at

261
00:10:53,760 --> 00:10:56,930
the same time so Puma which I am on the

262
00:10:56,930 --> 00:10:59,910
committee team for is an example of a

263
00:10:59,910 --> 00:11:02,040
forking web server also passenger and

264
00:11:02,040 --> 00:11:05,460
Unicorn do that and when you fork a

265
00:11:05,460 --> 00:11:09,150
process the child process shares its

266
00:11:09,150 --> 00:11:12,090
memory with the parent to the extent

267
00:11:12,090 --> 00:11:13,890
that it can and it does that through

268
00:11:13,890 --> 00:11:16,620
copy-on-write memory so we have to talk

269
00:11:16,620 --> 00:11:18,210
about shared versus private memory so

270
00:11:18,210 --> 00:11:20,610
the child process when it gets fork from

271
00:11:20,610 --> 00:11:24,930
the parent gets a not a copy but it gets

272
00:11:24,930 --> 00:11:27,660
some addresses that looks like a copy of

273
00:11:27,660 --> 00:11:30,840
the parents memory and that's shared

274
00:11:30,840 --> 00:11:33,030
memory and it's just the exact copy of

275
00:11:33,030 --> 00:11:35,030
the parents processes memory but

276
00:11:35,030 --> 00:11:38,070
whenever it tries to modify one of the

277
00:11:38,070 --> 00:11:39,840
child process tries to modify one of

278
00:11:39,840 --> 00:11:43,230
those those memory pages the operating

279
00:11:43,230 --> 00:11:45,870
system in the background will copy it so

280
00:11:45,870 --> 00:11:48,360
it it's kind of like a copy on-demand

281
00:11:48,360 --> 00:11:50,160
thing right so it's very important when

282
00:11:50,160 --> 00:11:53,160
when are you writing to memory locations

283
00:11:53,160 --> 00:11:55,440
in a in a child process because that'll

284
00:11:55,440 --> 00:11:56,760
create a copy which will increase your

285
00:11:56,760 --> 00:11:58,650
memory usage so this copy and write is

286
00:11:58,650 --> 00:12:00,180
the whole reason that when you have a

287
00:12:00,180 --> 00:12:02,910
puma process with three workers you

288
00:12:02,910 --> 00:12:05,520
don't see exactly three times the memory

289
00:12:05,520 --> 00:12:07,290
usage that you do when you have when you

290
00:12:07,290 --> 00:12:09,120
have one process because we're sharing

291
00:12:09,120 --> 00:12:11,880
some small portion you know ten to

292
00:12:11,880 --> 00:12:14,760
thirty percent of that memory between

293
00:12:14,760 --> 00:12:17,160
the child and the process this is the

294
00:12:17,160 --> 00:12:19,290
whole reason why you why you pre-boot or

295
00:12:19,290 --> 00:12:22,170
preload depending on what your your web

296
00:12:22,170 --> 00:12:25,320
server is so we the idea is that you

297
00:12:25,320 --> 00:12:28,740
load the entire application first before

298
00:12:28,740 --> 00:12:30,840
forking so you can share the maximum

299
00:12:30,840 --> 00:12:34,920
amount of memory possible right the

300
00:12:34,920 --> 00:12:37,380
problem with this right

301
00:12:37,380 --> 00:12:39,870
you remember my description of how 1.8

302
00:12:39,870 --> 00:12:42,810
worked we touched the FL mark flag every

303
00:12:42,810 --> 00:12:43,470
time we

304
00:12:43,470 --> 00:12:46,170
mark so you set the mark from 0 to 1 and

305
00:12:46,170 --> 00:12:49,080
1 to 0 and that touches that memory

306
00:12:49,080 --> 00:12:52,230
location which ends up copying the

307
00:12:52,230 --> 00:12:55,320
memory page so we couldn't garbage

308
00:12:55,320 --> 00:12:57,540
collect without breaking copy-on-write

309
00:12:57,540 --> 00:12:59,730
by we every time you garbage collected

310
00:12:59,730 --> 00:13:02,340
it would create copies of all the memory

311
00:13:02,340 --> 00:13:04,110
in the child process and now you're back

312
00:13:04,110 --> 00:13:06,230
to where you started with memory usage

313
00:13:06,230 --> 00:13:09,690
so that was kind of inconvenient and was

314
00:13:09,690 --> 00:13:11,880
kind of wasteful use of memory Ruby

315
00:13:11,880 --> 00:13:13,680
Enterprise Edition fix that with a

316
00:13:13,680 --> 00:13:15,030
method I'm going to talk about later

317
00:13:15,030 --> 00:13:18,050
because we got it for in corn - I know

318
00:13:18,050 --> 00:13:20,490
and brooby enterprise edition ended up

319
00:13:20,490 --> 00:13:22,170
using the exact same method that that to

320
00:13:22,170 --> 00:13:24,660
dotto used so we'll talk about that in a

321
00:13:24,660 --> 00:13:25,410
minute

322
00:13:25,410 --> 00:13:28,110
in the meantime 1.9 which I think

323
00:13:28,110 --> 00:13:30,900
actually came in dot 3 now here on

324
00:13:30,900 --> 00:13:35,250
nakamura gave us lazy sweeping so the

325
00:13:35,250 --> 00:13:38,040
whole idea is you don't sweep until you

326
00:13:38,040 --> 00:13:40,290
need it it's we're about where we're

327
00:13:40,290 --> 00:13:43,050
trying to break the sweep phase into

328
00:13:43,050 --> 00:13:45,030
multiple smaller phases we're still

329
00:13:45,030 --> 00:13:46,980
gonna have one big long stop the world

330
00:13:46,980 --> 00:13:49,290
mark but we're gonna sweep only in

331
00:13:49,290 --> 00:13:51,750
smaller increments when we actually need

332
00:13:51,750 --> 00:13:54,020
it which is when we you know need new

333
00:13:54,020 --> 00:13:59,790
slots so we just sweep until we have

334
00:13:59,790 --> 00:14:03,720
some enough free objects to have to deal

335
00:14:03,720 --> 00:14:06,480
with whatever we're alloc where whatever

336
00:14:06,480 --> 00:14:08,580
objects we're creating and then we go

337
00:14:08,580 --> 00:14:11,010
back to program execution until we need

338
00:14:11,010 --> 00:14:13,770
more slots and then sweep again so we're

339
00:14:13,770 --> 00:14:15,690
doing the mark phase just like we did in

340
00:14:15,690 --> 00:14:18,900
1.8 but then we'll sweep a little bit

341
00:14:18,900 --> 00:14:20,970
immediately for whatever we needed but

342
00:14:20,970 --> 00:14:22,680
then we'll we'll go back to program

343
00:14:22,680 --> 00:14:25,830
execution and then sweep objects into

344
00:14:25,830 --> 00:14:28,980
the free list only as necessary so this

345
00:14:28,980 --> 00:14:30,570
decrease is the worst case times right

346
00:14:30,570 --> 00:14:32,310
because rather than having one long mark

347
00:14:32,310 --> 00:14:34,050
followed by one very long sweep you have

348
00:14:34,050 --> 00:14:36,090
one mark followed by several smaller

349
00:14:36,090 --> 00:14:39,660
sweeps so the worst case that you could

350
00:14:39,660 --> 00:14:42,330
have for a GC pause time was greatly

351
00:14:42,330 --> 00:14:42,900
reduced

352
00:14:42,900 --> 00:14:45,270
so mark sweep sweep sweep and then mark

353
00:14:45,270 --> 00:14:47,029
again

354
00:14:47,029 --> 00:14:51,730
into dotto we got official copy-on-write

355
00:14:51,730 --> 00:14:53,870
support I mean technically you're always

356
00:14:53,870 --> 00:14:55,610
supporting copy-on-write just either

357
00:14:55,610 --> 00:14:57,889
works well or it doesn't work at all

358
00:14:57,889 --> 00:15:00,290
like consol copy-on-write only happens

359
00:15:00,290 --> 00:15:02,629
at the operating system level so

360
00:15:02,629 --> 00:15:04,759
technically like you already supported

361
00:15:04,759 --> 00:15:06,829
it you just didn't take advantage of it

362
00:15:06,829 --> 00:15:08,930
really and we got that through something

363
00:15:08,930 --> 00:15:11,600
called bitmap marking which is another

364
00:15:11,600 --> 00:15:15,439
node nakamura commits the whole idea

365
00:15:15,439 --> 00:15:18,069
with with bitmap marking is okay well if

366
00:15:18,069 --> 00:15:21,370
touching the FL mark bit on the R value

367
00:15:21,370 --> 00:15:24,290
triggers that that copy let's just keep

368
00:15:24,290 --> 00:15:27,079
the mark but somewhere else we're in in

369
00:15:27,079 --> 00:15:29,000
different memory locations so that when

370
00:15:29,000 --> 00:15:30,740
we cop when we when we touch it

371
00:15:30,740 --> 00:15:33,290
we're only copying mark bits and we're

372
00:15:33,290 --> 00:15:35,660
not copying this forty byte or value

373
00:15:35,660 --> 00:15:40,129
object and that's done through bit

374
00:15:40,129 --> 00:15:42,740
mapping so instead of keeping the FL

375
00:15:42,740 --> 00:15:44,689
mark bit in our value we keep it in two

376
00:15:44,689 --> 00:15:51,290
separate array of bits and we can get

377
00:15:51,290 --> 00:15:53,990
that it's it's not like a point or

378
00:15:53,990 --> 00:15:55,970
anything it's just a dress

379
00:15:55,970 --> 00:16:00,949
so if our our value is that you know

380
00:16:00,949 --> 00:16:03,949
memory address 0 X whatever we just do

381
00:16:03,949 --> 00:16:07,660
some arithmetic to calculate where the

382
00:16:07,660 --> 00:16:10,339
mark bit is that's done to do something

383
00:16:10,339 --> 00:16:11,930
called memory address aligning so you

384
00:16:11,930 --> 00:16:13,309
can just do some arithmetic to figure

385
00:16:13,309 --> 00:16:17,120
that out to figure out where the the bit

386
00:16:17,120 --> 00:16:20,839
for marking is so that makes Ruby

387
00:16:20,839 --> 00:16:25,639
copy-on-write friendly yay and just saw

388
00:16:25,639 --> 00:16:27,680
a pretty big memory reduction usage for

389
00:16:27,680 --> 00:16:31,850
for people using forking web servers and

390
00:16:31,850 --> 00:16:34,279
it's still marking with lazy sweeping so

391
00:16:34,279 --> 00:16:35,809
we're still marked with sweeps usefully

392
00:16:35,809 --> 00:16:38,029
we just kind of changed where the mark

393
00:16:38,029 --> 00:16:39,920
bit actually resides right it now

394
00:16:39,920 --> 00:16:42,529
resides in a separate area not in the

395
00:16:42,529 --> 00:16:45,800
are value there are a couple more bits

396
00:16:45,800 --> 00:16:49,160
now that our bitmap marked in this way

397
00:16:49,160 --> 00:16:52,490
that aren't stored in our value I will

398
00:16:52,490 --> 00:16:54,680
probably get to those in a bit

399
00:16:54,680 --> 00:16:57,619
in 2.1 we got generational garbage

400
00:16:57,619 --> 00:16:59,720
collection this is what we start to

401
00:16:59,720 --> 00:17:01,009
don't want anybody start seeing some

402
00:17:01,009 --> 00:17:02,869
some actually like big changes and how

403
00:17:02,869 --> 00:17:05,809
GC is actually done this was written by

404
00:17:05,809 --> 00:17:07,849
Koo Chi sasada who's a rails core Ruby

405
00:17:07,849 --> 00:17:09,619
core team member works for Heroku now

406
00:17:09,619 --> 00:17:11,480
actually doesn't work for Heroku anymore

407
00:17:11,480 --> 00:17:13,819
works for Cooke pad did work for Heroku

408
00:17:13,819 --> 00:17:15,109
for a while but one of the few people

409
00:17:15,109 --> 00:17:21,230
paid to work on MRI and the whole idea

410
00:17:21,230 --> 00:17:23,089
with generational garbage collection is

411
00:17:23,089 --> 00:17:25,220
that certain objects are going to be

412
00:17:25,220 --> 00:17:27,709
marked as the old generation and certain

413
00:17:27,709 --> 00:17:30,020
objects are gonna be marked and certain

414
00:17:30,020 --> 00:17:31,610
the other objects are just gonna be new

415
00:17:31,610 --> 00:17:35,299
objects new objects become old when they

416
00:17:35,299 --> 00:17:36,950
survive a certain amount of garbage

417
00:17:36,950 --> 00:17:38,390
collections I don't think this is

418
00:17:38,390 --> 00:17:39,770
actually the correct number for what it

419
00:17:39,770 --> 00:17:42,350
wasn't in 2.1 now it's if you survive

420
00:17:42,350 --> 00:17:45,110
three collections you are promoted three

421
00:17:45,110 --> 00:17:47,000
if you survive three marking phases i

422
00:17:47,000 --> 00:17:48,440
should say you're now promoted to an old

423
00:17:48,440 --> 00:17:50,630
object back then I think it might have

424
00:17:50,630 --> 00:17:56,779
been less now we have minor and major

425
00:17:56,779 --> 00:17:59,990
GCS so the whole reason you have

426
00:17:59,990 --> 00:18:01,700
generational garbage collection is is

427
00:18:01,700 --> 00:18:03,470
this based on this thesis that most

428
00:18:03,470 --> 00:18:05,960
objects die young most objects are just

429
00:18:05,960 --> 00:18:08,539
around for the duration of a web request

430
00:18:08,539 --> 00:18:11,960
or whatever and then they can be garbage

431
00:18:11,960 --> 00:18:15,890
collected after that and traversing old

432
00:18:15,890 --> 00:18:18,620
objects looking for stuff to garbage

433
00:18:18,620 --> 00:18:20,390
collect they're like if you're going

434
00:18:20,390 --> 00:18:25,070
through the Ruby code if you're go if

435
00:18:25,070 --> 00:18:27,590
you're going through you know all the

436
00:18:27,590 --> 00:18:28,880
objects that get created when Rails

437
00:18:28,880 --> 00:18:30,409
starts up it's kind of inefficient to

438
00:18:30,409 --> 00:18:32,240
traverse those objects every time we

439
00:18:32,240 --> 00:18:33,409
mark right because they're not going

440
00:18:33,409 --> 00:18:35,870
anywhere the only objects that we're

441
00:18:35,870 --> 00:18:37,610
probably gonna go somewhere are the ones

442
00:18:37,610 --> 00:18:39,350
that we just created

443
00:18:39,350 --> 00:18:41,480
like you know request headers or

444
00:18:41,480 --> 00:18:46,340
whatever so during a minor GC we're only

445
00:18:46,340 --> 00:18:49,100
going to look at new objects to mark and

446
00:18:49,100 --> 00:18:51,350
during a major GC we're gonna look at

447
00:18:51,350 --> 00:18:53,360
all objects for a look at new and old

448
00:18:53,360 --> 00:18:56,600
objects in the marking phase so all

449
00:18:56,600 --> 00:18:58,370
we've done is just created two different

450
00:18:58,370 --> 00:19:02,299
kinds of marking phases the problem is

451
00:19:02,299 --> 00:19:06,320
now you have to keep track of

452
00:19:06,320 --> 00:19:11,090
these different kinds of objects so the

453
00:19:11,090 --> 00:19:13,159
way that this gets explained and I'm

454
00:19:13,159 --> 00:19:15,019
pretty sure this is how it works in GC

455
00:19:15,019 --> 00:19:16,909
Otzi's we have three different colors we

456
00:19:16,909 --> 00:19:20,059
have black gray and white all objects

457
00:19:20,059 --> 00:19:24,289
start is white then all root objects

458
00:19:24,289 --> 00:19:26,240
which I explained did 1.8 root objects

459
00:19:26,240 --> 00:19:29,899
get colored gray and then from each gray

460
00:19:29,899 --> 00:19:31,820
object we're gonna traverse the object

461
00:19:31,820 --> 00:19:33,970
graph and look at all the references and

462
00:19:33,970 --> 00:19:36,259
we're going to turn those objects gray

463
00:19:36,259 --> 00:19:38,360
then when we're done when we marked all

464
00:19:38,360 --> 00:19:40,490
the references to this object gray we

465
00:19:40,490 --> 00:19:43,399
turn the original object black then we

466
00:19:43,399 --> 00:19:45,320
keep going through the tree until all

467
00:19:45,320 --> 00:19:48,649
objects are black or white okay now the

468
00:19:48,649 --> 00:19:51,460
problem is when we have a black object

469
00:19:51,460 --> 00:19:54,049
that refers directly to a white objects

470
00:19:54,049 --> 00:19:56,389
that shouldn't happen right only gray

471
00:19:56,389 --> 00:20:01,220
objects should refer to white objects to

472
00:20:01,220 --> 00:20:02,840
solve this problem we have something

473
00:20:02,840 --> 00:20:04,610
called the right barrier the right

474
00:20:04,610 --> 00:20:08,720
barrier just is a barrier for realizing

475
00:20:08,720 --> 00:20:12,620
whenever the an object creates a

476
00:20:12,620 --> 00:20:14,899
reference to another object so we we put

477
00:20:14,899 --> 00:20:17,870
a barrier between you being able to

478
00:20:17,870 --> 00:20:23,090
reference an object directly the right

479
00:20:23,090 --> 00:20:25,190
barrier is used to implement what was

480
00:20:25,190 --> 00:20:26,690
originally called sunny and shady

481
00:20:26,690 --> 00:20:28,340
objects now it's called right barrier

482
00:20:28,340 --> 00:20:33,200
protected and unprotected sunny objects

483
00:20:33,200 --> 00:20:35,240
are protected by right barriers shady

484
00:20:35,240 --> 00:20:38,360
objects are not and the reason we do

485
00:20:38,360 --> 00:20:41,450
this is because with a sunny object we

486
00:20:41,450 --> 00:20:43,490
can track when new references get added

487
00:20:43,490 --> 00:20:46,340
to it shady objects we can't in the

488
00:20:46,340 --> 00:20:48,620
generational garbage collector we have

489
00:20:48,620 --> 00:20:51,950
to check shady objects every minor every

490
00:20:51,950 --> 00:20:53,539
garbage collection during minor and

491
00:20:53,539 --> 00:20:56,029
major because we can't know whether or

492
00:20:56,029 --> 00:20:58,429
not you added a new reference to that

493
00:20:58,429 --> 00:21:03,139
object or not and sunny objects we know

494
00:21:03,139 --> 00:21:04,549
whether or not you did so we can

495
00:21:04,549 --> 00:21:06,860
actually promote them to old generation

496
00:21:06,860 --> 00:21:08,629
and then not look at them for for new

497
00:21:08,629 --> 00:21:13,399
references all right explain that so

498
00:21:13,399 --> 00:21:16,039
sunny or unripe are your unprotected

499
00:21:16,039 --> 00:21:18,649
objects can never become old they can

500
00:21:18,649 --> 00:21:19,850
never be promoted to the

501
00:21:19,850 --> 00:21:21,980
generation we have to check them during

502
00:21:21,980 --> 00:21:23,900
every minor garbage collection now the

503
00:21:23,900 --> 00:21:26,570
one of the major sources of ripe berry

504
00:21:26,570 --> 00:21:28,460
or unprotected objects are see

505
00:21:28,460 --> 00:21:32,450
extensions if a see extension has direct

506
00:21:32,450 --> 00:21:35,060
access to the Ruby object if it knows

507
00:21:35,060 --> 00:21:38,600
where it is in memory we can't we can't

508
00:21:38,600 --> 00:21:40,550
be sure that that see extension hasn't

509
00:21:40,550 --> 00:21:43,700
added some references or that isn't

510
00:21:43,700 --> 00:21:47,330
using that object so we cannot promote

511
00:21:47,330 --> 00:21:52,340
those objects right barrier and

512
00:21:52,340 --> 00:21:56,420
protected objects the right barrier

513
00:21:56,420 --> 00:21:58,160
unprotected objects are added to

514
00:21:58,160 --> 00:22:01,880
something called the remembered set the

515
00:22:01,880 --> 00:22:03,380
remembered set just contains right

516
00:22:03,380 --> 00:22:05,630
barrier and protected objects and any

517
00:22:05,630 --> 00:22:09,500
old generation objects which have a new

518
00:22:09,500 --> 00:22:12,440
object added to them which we detect via

519
00:22:12,440 --> 00:22:13,880
the right barrier so if you have I got

520
00:22:13,880 --> 00:22:19,010
old a let's say it like a big array that

521
00:22:19,010 --> 00:22:21,200
you're adding and removing objects from

522
00:22:21,200 --> 00:22:24,530
and you it's like a stack or something

523
00:22:24,530 --> 00:22:25,700
that you use throughout the whole

524
00:22:25,700 --> 00:22:28,610
application so it it's it's becomes an

525
00:22:28,610 --> 00:22:32,330
old object okay when you add a new

526
00:22:32,330 --> 00:22:34,100
element to that array we want to make

527
00:22:34,100 --> 00:22:34,970
sure that doesn't get garbage collected

528
00:22:34,970 --> 00:22:38,420
right because if we if a minor GC

529
00:22:38,420 --> 00:22:41,330
marking phase happens we've added a new

530
00:22:41,330 --> 00:22:44,840
object to this old array that new object

531
00:22:44,840 --> 00:22:46,490
if we didn't have the right barrier

532
00:22:46,490 --> 00:22:48,110
would get garbage collected because an

533
00:22:48,110 --> 00:22:50,900
old object wouldn't we don't look at the

534
00:22:50,900 --> 00:22:52,940
old objects during this minor GC marking

535
00:22:52,940 --> 00:22:55,640
phase and so that may that means that

536
00:22:55,640 --> 00:22:58,340
our new object is white and so it'll get

537
00:22:58,340 --> 00:22:59,840
garbage collect is that we don't think

538
00:22:59,840 --> 00:23:01,430
that it has any references to it but the

539
00:23:01,430 --> 00:23:04,280
right barrier means that when we create

540
00:23:04,280 --> 00:23:06,530
that reference when we add the white new

541
00:23:06,530 --> 00:23:10,820
object to the old black array we will

542
00:23:10,820 --> 00:23:14,270
catch that and Ruby says ah okay I will

543
00:23:14,270 --> 00:23:16,190
add this old object to the remembered

544
00:23:16,190 --> 00:23:18,830
set so I will check it during the next

545
00:23:18,830 --> 00:23:21,520
line or GC

546
00:23:22,110 --> 00:23:24,429
okay so now garbage collection looks

547
00:23:24,429 --> 00:23:26,470
like this this is what we had in 2.0 and

548
00:23:26,470 --> 00:23:28,980
also 1.9 this this I should say this

549
00:23:28,980 --> 00:23:31,630
diagram and the previous diagram are

550
00:23:31,630 --> 00:23:36,940
from Kui cheese talk about ruby 2.2 GC

551
00:23:36,940 --> 00:23:41,230
so these are all koishi's diagrams this

552
00:23:41,230 --> 00:23:43,750
is what we had in 1.9 3 and 2.0 you had

553
00:23:43,750 --> 00:23:47,380
a long mark phase and a short lazy sweep

554
00:23:47,380 --> 00:23:49,390
and you just swept objects into the free

555
00:23:49,390 --> 00:23:53,710
list as you needed them then in

556
00:23:53,710 --> 00:23:55,960
generational GC we have 2 we introduced

557
00:23:55,960 --> 00:23:58,179
the two different types of GCS minor and

558
00:23:58,179 --> 00:24:00,880
major minor GCS are quicker because

559
00:24:00,880 --> 00:24:03,040
there are fewer new objects than there

560
00:24:03,040 --> 00:24:06,820
are total objects right so you have a

561
00:24:06,820 --> 00:24:08,530
short mark phase followed by short

562
00:24:08,530 --> 00:24:09,100
sweeps

563
00:24:09,100 --> 00:24:13,450
once you've done and then there's major

564
00:24:13,450 --> 00:24:15,280
GC which is the same as it was before

565
00:24:15,280 --> 00:24:19,179
major GC in Ruby 2.1 and up took exactly

566
00:24:19,179 --> 00:24:21,400
the same amount of time that a regular

567
00:24:21,400 --> 00:24:25,570
GC did in 2.0 and below just because

568
00:24:25,570 --> 00:24:26,980
it's not any different in fact it

569
00:24:26,980 --> 00:24:27,940
probably took a little bit longer

570
00:24:27,940 --> 00:24:30,130
because now you have to keep track of

571
00:24:30,130 --> 00:24:33,070
the object age slightly longer or not

572
00:24:33,070 --> 00:24:38,620
like anything crazy different so the

573
00:24:38,620 --> 00:24:40,360
whole advantage here is most of the time

574
00:24:40,360 --> 00:24:42,220
we're gonna be doing minor GCS and you

575
00:24:42,220 --> 00:24:44,410
can check this yourself if you look at g

576
00:24:44,410 --> 00:24:46,809
c dot statin any running ruby process

577
00:24:46,809 --> 00:24:49,570
you can see how many minor and major GCS

578
00:24:49,570 --> 00:24:52,929
it's it's done and usually you'll see

579
00:24:52,929 --> 00:24:56,590
minor GCS happen twice as often as major

580
00:24:56,590 --> 00:25:00,040
GCS and sometimes more depending on the

581
00:25:00,040 --> 00:25:01,660
age of the process and like what you're

582
00:25:01,660 --> 00:25:06,370
doing with it so that's great

583
00:25:06,370 --> 00:25:10,090
it means we have shorter pause times on

584
00:25:10,090 --> 00:25:12,550
average which means that we're less

585
00:25:12,550 --> 00:25:14,559
likely to have some big GC pause during

586
00:25:14,559 --> 00:25:15,940
the request we still have them though

587
00:25:15,940 --> 00:25:20,110
with major GCS because well this is just

588
00:25:20,110 --> 00:25:24,070
the same as it was in 2.0 is there

589
00:25:24,070 --> 00:25:26,679
anything else that I'm missing I don't

590
00:25:26,679 --> 00:25:28,059
think so

591
00:25:28,059 --> 00:25:31,029
okay so we still have this problem right

592
00:25:31,029 --> 00:25:35,349
a long major GC mark faces so we'll fix

593
00:25:35,349 --> 00:25:38,889
that with incremental GC in 2.2 again

594
00:25:38,889 --> 00:25:44,379
this is a KU Ichi project so the whole

595
00:25:44,379 --> 00:25:46,479
idea with incremental GC is well let's

596
00:25:46,479 --> 00:25:48,639
just break up the mark face let's just

597
00:25:48,639 --> 00:25:50,289
break the mark phase in this into

598
00:25:50,289 --> 00:25:55,859
shorter bits and so we can execute Ruby

599
00:25:55,859 --> 00:25:59,710
during the the pauses in marking now

600
00:25:59,710 --> 00:26:01,450
there's a lot of problems here because

601
00:26:01,450 --> 00:26:03,070
like I said the whole reason it's easier

602
00:26:03,070 --> 00:26:07,509
to just stop then and not execute Ruby

603
00:26:07,509 --> 00:26:09,399
during marking is because then you don't

604
00:26:09,399 --> 00:26:10,719
have to keep track of all the stuff that

605
00:26:10,719 --> 00:26:12,759
happens in between when you start adding

606
00:26:12,759 --> 00:26:14,619
stuff to arrays that you thought that

607
00:26:14,619 --> 00:26:17,190
you marked already but then you got to

608
00:26:17,190 --> 00:26:20,169
keep track of all the stuff that you

609
00:26:20,169 --> 00:26:22,269
added to stuff you already marked that's

610
00:26:22,269 --> 00:26:24,659
not good

611
00:26:27,080 --> 00:26:30,309
so total GC time will remain the same

612
00:26:30,309 --> 00:26:34,759
the idea wasn't to make GC time quicker

613
00:26:34,759 --> 00:26:36,919
it was just to reduce the amount of

614
00:26:36,919 --> 00:26:41,080
total time we spend in these long pauses

615
00:26:41,860 --> 00:26:44,570
and this is the point where out of ban

616
00:26:44,570 --> 00:26:46,909
GC becomes not a thing anymore in rubia

617
00:26:46,909 --> 00:26:49,220
people still somewhat do this although

618
00:26:49,220 --> 00:26:51,799
it's kind of dangerous out of ban GC was

619
00:26:51,799 --> 00:26:55,190
basically the idea that before a request

620
00:26:55,190 --> 00:26:58,759
in a web application you could disable

621
00:26:58,759 --> 00:27:01,999
the GC with GC disabled or whatever do

622
00:27:01,999 --> 00:27:03,769
your requests in response and then

623
00:27:03,769 --> 00:27:05,659
enable the GC again now that has a lot

624
00:27:05,659 --> 00:27:07,070
of problems and it's kind of dicey

625
00:27:07,070 --> 00:27:09,499
because you know what happens if GC

626
00:27:09,499 --> 00:27:12,499
doesn't get Rhian abled somehow what

627
00:27:12,499 --> 00:27:15,200
happens if during a request you allocate

628
00:27:15,200 --> 00:27:18,169
a bajillion objects and now GC is

629
00:27:18,169 --> 00:27:20,029
disabled so well you need a bajillion

630
00:27:20,029 --> 00:27:25,879
Meg's of RAM right so it was always kind

631
00:27:25,879 --> 00:27:28,190
of a dicey proposition and at this point

632
00:27:28,190 --> 00:27:32,450
if we can make mark phases shorter which

633
00:27:32,450 --> 00:27:34,940
means that our maximum pause time for GC

634
00:27:34,940 --> 00:27:38,179
ever is going to be 10 15 milliseconds

635
00:27:38,179 --> 00:27:40,039
well then what's the point about AB and

636
00:27:40,039 --> 00:27:41,809
GC right it's just kind of like adding

637
00:27:41,809 --> 00:27:44,509
this possible failure point when the

638
00:27:44,509 --> 00:27:47,059
maximum GC pause is only 15 seconds it's

639
00:27:47,059 --> 00:27:49,549
not like a huge benefit out of moving it

640
00:27:49,549 --> 00:27:50,989
out of the request depending on you know

641
00:27:50,989 --> 00:27:52,609
your application and what your goals are

642
00:27:52,609 --> 00:27:57,649
or whatever so but this is the problem I

643
00:27:57,649 --> 00:28:00,049
was talking about is is that we can get

644
00:28:00,049 --> 00:28:02,119
half we can we can do a mark phase and

645
00:28:02,119 --> 00:28:05,799
then execute some more Ruby but now

646
00:28:05,799 --> 00:28:08,840
objects which you've already marked can

647
00:28:08,840 --> 00:28:12,230
have new white objects directly

648
00:28:12,230 --> 00:28:15,529
referring to them which isn't which

649
00:28:15,529 --> 00:28:17,179
isn't good because we don't we don't go

650
00:28:17,179 --> 00:28:18,950
back and look at black objects again

651
00:28:18,950 --> 00:28:20,720
usually right so this just goes back to

652
00:28:20,720 --> 00:28:22,609
the right barrier now the right barrier

653
00:28:22,609 --> 00:28:26,720
in addition to tracking old generation

654
00:28:26,720 --> 00:28:29,539
objects which get new references to new

655
00:28:29,539 --> 00:28:33,590
objects written which sorry old objects

656
00:28:33,590 --> 00:28:37,490
which track references to new objects

657
00:28:37,490 --> 00:28:39,409
now we just have to do that basically

658
00:28:39,409 --> 00:28:41,059
all the time during

659
00:28:41,059 --> 00:28:44,990
after a mark phase is over we check the

660
00:28:44,990 --> 00:28:51,140
right barrier for objects which got new

661
00:28:51,140 --> 00:28:53,750
references to them so it just adds the

662
00:28:53,750 --> 00:28:57,260
other things to the remembered set you

663
00:28:57,260 --> 00:28:58,610
can check the route size of the

664
00:28:58,610 --> 00:29:00,980
remembered set in GC stat again I

665
00:29:00,980 --> 00:29:02,600
recommend just taking a look at this

666
00:29:02,600 --> 00:29:05,149
it's kind of opaque like the keys are a

667
00:29:05,149 --> 00:29:06,769
little bit hard to figure out what they

668
00:29:06,769 --> 00:29:09,320
mean and GC dots that changes a lot it

669
00:29:09,320 --> 00:29:11,179
changes in every ruby version pretty

670
00:29:11,179 --> 00:29:15,440
much so but you can get an idea the

671
00:29:15,440 --> 00:29:16,820
remembered objects just sort of like

672
00:29:16,820 --> 00:29:18,409
just right in there and it also tell you

673
00:29:18,409 --> 00:29:20,179
like how many objects are protected by

674
00:29:20,179 --> 00:29:22,539
the right barrier and how many are not

675
00:29:22,539 --> 00:29:27,950
from a practical perspective the white

676
00:29:27,950 --> 00:29:31,220
barrier now is so important after 2.24

677
00:29:31,220 --> 00:29:34,399
incremental and generational GC what you

678
00:29:34,399 --> 00:29:36,260
might have caught is that this means

679
00:29:36,260 --> 00:29:40,309
that C extensions which touch or make

680
00:29:40,309 --> 00:29:43,429
shady or you know basically remove the

681
00:29:43,429 --> 00:29:46,580
right barrier from large numbers of

682
00:29:46,580 --> 00:29:48,500
objects that could be really bad right

683
00:29:48,500 --> 00:29:51,559
because the more objects which are not

684
00:29:51,559 --> 00:29:53,659
protected by the right barrier the more

685
00:29:53,659 --> 00:29:57,010
objects we have to check every minor GC

686
00:29:57,010 --> 00:29:59,330
which isn't the right which isn't the

687
00:29:59,330 --> 00:30:01,309
idea we're trying to make minor GCS as

688
00:30:01,309 --> 00:30:04,340
short as possible so I've never seen

689
00:30:04,340 --> 00:30:05,960
this happen in production because I

690
00:30:05,960 --> 00:30:08,120
don't know of any C accession that has

691
00:30:08,120 --> 00:30:11,779
that does it but it would be interesting

692
00:30:11,779 --> 00:30:13,789
because that bug is kind of possible

693
00:30:13,789 --> 00:30:17,029
where a a C extension touches tons of

694
00:30:17,029 --> 00:30:19,970
Ruby objects makes them shady slash

695
00:30:19,970 --> 00:30:22,610
right barrier and protected and suddenly

696
00:30:22,610 --> 00:30:24,649
your minor GC pauses are just as long as

697
00:30:24,649 --> 00:30:26,809
your majors and and you've lost the

698
00:30:26,809 --> 00:30:29,720
benefit of of generational and

699
00:30:29,720 --> 00:30:33,470
incremental GC kind of interesting

700
00:30:33,470 --> 00:30:35,929
symbol GC we also got that at 2.2 it's

701
00:30:35,929 --> 00:30:37,309
not really that complicated now I've got

702
00:30:37,309 --> 00:30:42,380
symbols or garbage-collected 22.3 not

703
00:30:42,380 --> 00:30:45,860
much changed that was 2.2 was kind of

704
00:30:45,860 --> 00:30:47,299
like the last major change to the

705
00:30:47,299 --> 00:30:49,039
garbage collector that we've gotten

706
00:30:49,039 --> 00:30:51,169
koishi introduced a new experimental

707
00:30:51,169 --> 00:30:54,020
write barrier in 2.3

708
00:30:54,020 --> 00:30:57,049
which his assumption was that we can

709
00:30:57,049 --> 00:30:59,630
assume new objects referred to from old

710
00:30:59,630 --> 00:31:02,000
objects are probably also long-lived

711
00:31:02,000 --> 00:31:05,720
objects so if we add a new object to an

712
00:31:05,720 --> 00:31:07,820
old generation object we're gonna assume

713
00:31:07,820 --> 00:31:09,890
that this new object will probably

714
00:31:09,890 --> 00:31:12,289
become an old object it's probably gonna

715
00:31:12,289 --> 00:31:16,010
stick around for a while so for example

716
00:31:16,010 --> 00:31:20,539
adding a item to an array and a config

717
00:31:20,539 --> 00:31:24,440
file right so if you I can only give

718
00:31:24,440 --> 00:31:26,360
like really specific century examples

719
00:31:26,360 --> 00:31:28,520
but changing a setting that can fake

720
00:31:28,520 --> 00:31:29,840
right you're adding a new out you're

721
00:31:29,840 --> 00:31:31,370
creating a new object you add it to your

722
00:31:31,370 --> 00:31:33,559
your config object that object's gonna

723
00:31:33,559 --> 00:31:35,210
stick around for a while and it would be

724
00:31:35,210 --> 00:31:37,100
better if we just made it old right away

725
00:31:37,100 --> 00:31:39,409
because if we made it old right away it

726
00:31:39,409 --> 00:31:41,690
doesn't have to be marked for three

727
00:31:41,690 --> 00:31:44,750
minor GCS and we could just ignore it

728
00:31:44,750 --> 00:31:47,750
until the next major the problem with

729
00:31:47,750 --> 00:31:51,140
this is well what happens if that object

730
00:31:51,140 --> 00:31:56,690
isn't you know it is not going to become

731
00:31:56,690 --> 00:31:58,730
an old object so if you have like my

732
00:31:58,730 --> 00:32:01,159
stack example from from earlier if you

733
00:32:01,159 --> 00:32:03,500
have some stack object in your

734
00:32:03,500 --> 00:32:04,909
application that you're constantly

735
00:32:04,909 --> 00:32:07,809
taking items in and out of with this new

736
00:32:07,809 --> 00:32:11,510
algorithm that any object added to your

737
00:32:11,510 --> 00:32:13,850
long living stack would automatically

738
00:32:13,850 --> 00:32:17,570
get marked in the old generation so that

739
00:32:17,570 --> 00:32:19,549
wouldn't be great because you're taking

740
00:32:19,549 --> 00:32:20,720
stuff in and out of it all the time so

741
00:32:20,720 --> 00:32:23,630
that would greatly increase the memory

742
00:32:23,630 --> 00:32:27,799
usage of your of your stack I guess this

743
00:32:27,799 --> 00:32:29,600
is tournament didn't work or he didn't

744
00:32:29,600 --> 00:32:31,610
like the results because it still

745
00:32:31,610 --> 00:32:34,130
commented out in the Ruby GC dot C code

746
00:32:34,130 --> 00:32:36,529
it's still in there I don't know what

747
00:32:36,529 --> 00:32:38,750
what he ended up thinking about it but

748
00:32:38,750 --> 00:32:41,270
it's not been enabled yet you can mess

749
00:32:41,270 --> 00:32:43,010
with it if you know how to you know

750
00:32:43,010 --> 00:32:44,840
compile Ruby and want to comment it out

751
00:32:44,840 --> 00:32:49,130
or whatever but kind of interesting 2.4

752
00:32:49,130 --> 00:32:51,500
we got a couple more little changes you

753
00:32:51,500 --> 00:32:55,549
now can control somewhat the amount of

754
00:32:55,549 --> 00:32:58,820
three slots Ruby tries to keep open so

755
00:32:58,820 --> 00:33:02,120
the whole idea with GC and trigger when

756
00:33:02,120 --> 00:33:04,789
it triggers and and how many slots and

757
00:33:04,789 --> 00:33:06,800
how often we wanted to trigger

758
00:33:06,800 --> 00:33:10,400
is that GC is expensive takes time we

759
00:33:10,400 --> 00:33:12,620
don't want to do it that often so when

760
00:33:12,620 --> 00:33:16,610
we do do it we're going to try to make

761
00:33:16,610 --> 00:33:18,230
sure we don't have to do it very often

762
00:33:18,230 --> 00:33:21,980
again so what Ruby does is let's say you

763
00:33:21,980 --> 00:33:26,030
have a million free slots and you have

764
00:33:26,030 --> 00:33:28,640
to garbage collect okay nothing got

765
00:33:28,640 --> 00:33:30,290
garbage selected everything is being

766
00:33:30,290 --> 00:33:32,330
used up so we still have a million slots

767
00:33:32,330 --> 00:33:35,420
but we need more room Ruby will grow the

768
00:33:35,420 --> 00:33:38,660
amount of slots by a factor and that

769
00:33:38,660 --> 00:33:42,260
factor I think by default now is 1.4 so

770
00:33:42,260 --> 00:33:44,330
with a million free slots we need more

771
00:33:44,330 --> 00:33:46,910
slots we're gonna grow to a 1.4 million

772
00:33:46,910 --> 00:33:50,030
slot heap that factor is configurable by

773
00:33:50,030 --> 00:33:55,310
an environment variable but let's say we

774
00:33:55,310 --> 00:33:57,410
get to 1.4 million whatever and then

775
00:33:57,410 --> 00:33:58,970
five minutes later would you see again

776
00:33:58,970 --> 00:34:02,960
and now we're only using 500,000 about

777
00:34:02,960 --> 00:34:05,630
1.4 million slots well that's kind of

778
00:34:05,630 --> 00:34:06,950
inefficient right we should return some

779
00:34:06,950 --> 00:34:08,330
of that space back to the operating

780
00:34:08,330 --> 00:34:12,679
system if we can and that is what that

781
00:34:12,679 --> 00:34:15,260
control over that ratio of what ratio

782
00:34:15,260 --> 00:34:18,530
between used and empty slots is now

783
00:34:18,530 --> 00:34:20,900
control is now configurable I should say

784
00:34:20,900 --> 00:34:24,340
in Ruby 2.4 by an environment variable

785
00:34:24,340 --> 00:34:27,980
these environment variables I talked

786
00:34:27,980 --> 00:34:30,168
about them sometimes it talks but I tell

787
00:34:30,168 --> 00:34:33,500
people not to touch them usually if you

788
00:34:33,500 --> 00:34:35,900
can find them in GCC you're probably

789
00:34:35,900 --> 00:34:38,000
also smart enough to figure out what

790
00:34:38,000 --> 00:34:40,010
exactly they do it's very easy to

791
00:34:40,010 --> 00:34:41,929
 a Ruby process and you just copy

792
00:34:41,929 --> 00:34:43,668
and paste someone else's settings for

793
00:34:43,668 --> 00:34:45,830
these things so I don't I don't even

794
00:34:45,830 --> 00:34:48,139
tell people where to find them or or how

795
00:34:48,139 --> 00:34:50,239
to look at them but if you can find them

796
00:34:50,239 --> 00:34:51,739
in GCC that see your you can probably

797
00:34:51,739 --> 00:34:54,050
figure out how to use them but this is

798
00:34:54,050 --> 00:34:55,730
an interesting one because one thing

799
00:34:55,730 --> 00:34:57,620
that I see a lot in production with with

800
00:34:57,620 --> 00:35:01,300
Ruby processes is they get in their

801
00:35:01,300 --> 00:35:05,460
steady state where am I at

802
00:35:05,460 --> 00:35:08,490
okay in their long-term steady-state

803
00:35:08,490 --> 00:35:10,530
after six hours or whatever they have

804
00:35:10,530 --> 00:35:14,160
too many free slots and and they're not

805
00:35:14,160 --> 00:35:15,839
returning those free slots back if they

806
00:35:15,839 --> 00:35:19,220
can so this and that which means a

807
00:35:19,220 --> 00:35:22,829
long-term higher memory usage right so

808
00:35:22,829 --> 00:35:24,000
I'm I've been interested in this I

809
00:35:24,000 --> 00:35:25,380
haven't played with it yet to see if it

810
00:35:25,380 --> 00:35:26,940
reduces long-term memory usage for

811
00:35:26,940 --> 00:35:29,550
people's real applications part of the

812
00:35:29,550 --> 00:35:33,150
problem with returning free slots back

813
00:35:33,150 --> 00:35:34,859
to the operating system and I've talked

814
00:35:34,859 --> 00:35:38,730
about this in other talks is is memory

815
00:35:38,730 --> 00:35:42,109
fragmentation Ruby can only release a a

816
00:35:42,109 --> 00:35:45,900
slot back to the operating system if the

817
00:35:45,900 --> 00:35:50,670
entire heap page so 400 slots in the

818
00:35:50,670 --> 00:35:52,589
page have to all be free

819
00:35:52,589 --> 00:35:54,720
that's called a tomb page if you see

820
00:35:54,720 --> 00:35:57,470
that referred to anywhere in in Ruby a

821
00:35:57,470 --> 00:36:00,030
heap page with an object in it is an

822
00:36:00,030 --> 00:36:03,180
Eden page and a heap with no a page with

823
00:36:03,180 --> 00:36:06,390
no objects in it is a tomb page so page

824
00:36:06,390 --> 00:36:08,220
has to be a tomb page for us to release

825
00:36:08,220 --> 00:36:10,349
it back to the operating system because

826
00:36:10,349 --> 00:36:13,640
we can't move objects around the heap

827
00:36:13,640 --> 00:36:20,640
okay because we don't the see see right

828
00:36:20,640 --> 00:36:23,160
barrier unprotected objects right these

829
00:36:23,160 --> 00:36:25,109
are referred to by C extensions they

830
00:36:25,109 --> 00:36:26,700
have just the direct memory address

831
00:36:26,700 --> 00:36:27,869
there's no there's no indirection

832
00:36:27,869 --> 00:36:30,930
between that C API access and where that

833
00:36:30,930 --> 00:36:33,059
object resides in memory so we can't

834
00:36:33,059 --> 00:36:35,849
move the object otherwise we break the C

835
00:36:35,849 --> 00:36:39,630
extension so that means we can't move

836
00:36:39,630 --> 00:36:42,839
objects around and which in turn means

837
00:36:42,839 --> 00:36:44,970
we can't free pages back unless there's

838
00:36:44,970 --> 00:36:49,230
no slots being used in the page which

839
00:36:49,230 --> 00:36:53,180
happens about never it's very easy for

840
00:36:53,180 --> 00:36:56,309
the Ruby object space and heap to look

841
00:36:56,309 --> 00:36:58,280
like Swiss cheese with you know a new

842
00:36:58,280 --> 00:37:00,960
old object here and then a bunch of new

843
00:37:00,960 --> 00:37:02,819
objects and an old objects and when that

844
00:37:02,819 --> 00:37:04,109
gets garbage collected it just looks

845
00:37:04,109 --> 00:37:08,730
like this big Swiss cheese heap there's

846
00:37:08,730 --> 00:37:10,470
a couple of things which are being done

847
00:37:10,470 --> 00:37:14,069
to help with this so let's talk about

848
00:37:14,069 --> 00:37:15,270
those now we talked about the future

849
00:37:15,270 --> 00:37:17,609
about where we're we're where Ruby GCC

850
00:37:17,609 --> 00:37:20,240
seems to be going

851
00:37:20,240 --> 00:37:22,829
and that the main thing I think that

852
00:37:22,829 --> 00:37:24,119
most people are gonna be interested in

853
00:37:24,119 --> 00:37:26,369
is garbage compaction which is moving

854
00:37:26,369 --> 00:37:28,680
objects around the object space and

855
00:37:28,680 --> 00:37:30,750
moving them around the heap to make them

856
00:37:30,750 --> 00:37:34,589
less Swiss cheesy and more Gruyere I

857
00:37:34,589 --> 00:37:36,660
don't look like a not cheat about holes

858
00:37:36,660 --> 00:37:39,540
in it I don't know JRuby and truffle and

859
00:37:39,540 --> 00:37:42,030
truffle Ruby already do this cuz they're

860
00:37:42,030 --> 00:37:45,240
on the JVM or or growl or whatever and

861
00:37:45,240 --> 00:37:48,359
those garbage collectors are compacting

862
00:37:48,359 --> 00:37:50,760
or at least some of the JVM garbage

863
00:37:50,760 --> 00:37:52,920
collectors compact so they get to take

864
00:37:52,920 --> 00:37:54,329
advantage of all that for free and it

865
00:37:54,329 --> 00:37:57,119
just compact for them and that's great

866
00:37:57,119 --> 00:38:01,040
Aaron Patterson has been working on this

867
00:38:01,040 --> 00:38:03,540
after a hallway conversation in Ruby

868
00:38:03,540 --> 00:38:05,970
comp he realized that basically we might

869
00:38:05,970 --> 00:38:07,890
be able to move some objects around the

870
00:38:07,890 --> 00:38:10,410
heap so long as we don't have any we can

871
00:38:10,410 --> 00:38:11,280
make sure that they're not being

872
00:38:11,280 --> 00:38:15,030
referred to by C extensions and he's

873
00:38:15,030 --> 00:38:16,260
been working on that if you follow his

874
00:38:16,260 --> 00:38:18,059
twitter he's been posting about it every

875
00:38:18,059 --> 00:38:20,460
once in a while it's a very interesting

876
00:38:20,460 --> 00:38:22,829
project it will that we'll never be able

877
00:38:22,829 --> 00:38:26,549
to move all objects around the heap but

878
00:38:26,549 --> 00:38:28,049
we might be able to move some of them

879
00:38:28,049 --> 00:38:31,619
and improve fragmentation and and being

880
00:38:31,619 --> 00:38:33,059
able to return some memory back to the

881
00:38:33,059 --> 00:38:35,069
operating system somewhat so what this

882
00:38:35,069 --> 00:38:37,559
means in the long term is that your big

883
00:38:37,559 --> 00:38:39,869
long term Ruby processes will probably

884
00:38:39,869 --> 00:38:44,190
use somewhat less RSS or memory in the

885
00:38:44,190 --> 00:38:46,079
long term

886
00:38:46,079 --> 00:38:48,750
another approach here rather besides

887
00:38:48,750 --> 00:38:51,839
being able to move objects around is to

888
00:38:51,839 --> 00:38:54,839
just put them in separate areas to begin

889
00:38:54,839 --> 00:38:57,569
with so if we have an object and we need

890
00:38:57,569 --> 00:39:00,210
to put that object somewhere right if we

891
00:39:00,210 --> 00:39:02,130
think that this object is probably going

892
00:39:02,130 --> 00:39:03,569
to be old and it's probably gonna stick

893
00:39:03,569 --> 00:39:05,339
around we're gonna put that in one pile

894
00:39:05,339 --> 00:39:07,319
and then any object like an instance

895
00:39:07,319 --> 00:39:08,880
variable that we think is not going to

896
00:39:08,880 --> 00:39:10,349
be around for a long time will put that

897
00:39:10,349 --> 00:39:14,549
another pile and in theory what that

898
00:39:14,549 --> 00:39:17,190
means is our old object pile will be

899
00:39:17,190 --> 00:39:19,170
less fragmented than our new object pile

900
00:39:19,170 --> 00:39:21,869
right because old objects probably won't

901
00:39:21,869 --> 00:39:23,609
get garbage collected and all the new

902
00:39:23,609 --> 00:39:26,880
objects that'll get frequently freed up

903
00:39:26,880 --> 00:39:28,460
and whatever so that should reduce

904
00:39:28,460 --> 00:39:32,670
memory fragmentation and therefore

905
00:39:32,670 --> 00:39:39,210
less total RSS usage Guild's so everyone

906
00:39:39,210 --> 00:39:42,240
talks about guilds probably not coming

907
00:39:42,240 --> 00:39:46,710
for a while but I was told Ruby 2.6 a

908
00:39:46,710 --> 00:39:52,770
2.7 so guilds will have this it will be

909
00:39:52,770 --> 00:39:55,290
sharing the same object space in the

910
00:39:55,290 --> 00:39:56,880
plan right now I mean this is all super

911
00:39:56,880 --> 00:39:59,910
early whatever but guilds are Ruby's

912
00:39:59,910 --> 00:40:02,040
future planned concurrency model if

913
00:40:02,040 --> 00:40:05,520
you're not familiar with this but the

914
00:40:05,520 --> 00:40:07,770
idea is that these guilds are going to

915
00:40:07,770 --> 00:40:09,690
be sort of like lightweight processes

916
00:40:09,690 --> 00:40:12,900
almost and they will share the same heap

917
00:40:12,900 --> 00:40:14,460
so everything that I've talked about and

918
00:40:14,460 --> 00:40:15,990
all this garbage collection is not going

919
00:40:15,990 --> 00:40:18,030
to change when we get guilds I've but

920
00:40:18,030 --> 00:40:20,150
sort of an interesting side note for

921
00:40:20,150 --> 00:40:22,950
more reading I suggest these three

922
00:40:22,950 --> 00:40:24,630
authors Pat Shaughnessy wrote a great

923
00:40:24,630 --> 00:40:26,880
book called ruby under the microscope

924
00:40:26,880 --> 00:40:28,920
which is the starting point if you want

925
00:40:28,920 --> 00:40:30,240
to learn more about how ruby works

926
00:40:30,240 --> 00:40:31,380
internally

927
00:40:31,380 --> 00:40:33,299
coochi has written a couple things

928
00:40:33,299 --> 00:40:37,559
online in english about how ruby garbage

929
00:40:37,559 --> 00:40:39,720
collection works and sam saffron of

930
00:40:39,720 --> 00:40:44,819
discourse has as well if this was

931
00:40:44,819 --> 00:40:47,130
interesting to you i have a course

932
00:40:47,130 --> 00:40:49,079
called the complete guide to rails

933
00:40:49,079 --> 00:40:51,329
performance which is a bunch of

934
00:40:51,329 --> 00:40:53,280
screencasts in a very long book about

935
00:40:53,280 --> 00:40:55,260
optimizing rails applications it's all a

936
00:40:55,260 --> 00:40:57,240
trail speed comm you may have seen my

937
00:40:57,240 --> 00:40:59,280
blog it kind of looks like this I write

938
00:40:59,280 --> 00:41:01,309
about Ruby performance from time to time

939
00:41:01,309 --> 00:41:05,270
and that blog is at speed shop dot Co

940
00:41:05,270 --> 00:41:08,809
thank you very much

941
00:41:13,970 --> 00:41:17,670
we have more than five minutes for

942
00:41:17,670 --> 00:41:18,510
questions

943
00:41:18,510 --> 00:41:22,050
yeah container space containers

944
00:41:22,050 --> 00:41:23,670
containers containers it was talking

945
00:41:23,670 --> 00:41:27,839
about into yes where do you see Ruby

946
00:41:27,839 --> 00:41:29,760
not just in Jordan where else would be

947
00:41:29,760 --> 00:41:32,160
writing in within the container space

948
00:41:32,160 --> 00:41:35,180
because I just tend to say just pretty

949
00:41:35,180 --> 00:41:38,520
good last pretty much everyone does

950
00:41:38,520 --> 00:41:41,730
already because yeah sure sure so the

951
00:41:41,730 --> 00:41:43,349
question was like how do I see Ruby

952
00:41:43,349 --> 00:41:46,530
fitting into containers I think the fact

953
00:41:46,530 --> 00:41:48,839
is that most people run Ruby in a

954
00:41:48,839 --> 00:41:50,670
container already because most people

955
00:41:50,670 --> 00:41:54,450
run Ruby on Heroku which uses lxc where

956
00:41:54,450 --> 00:41:55,609
terence go

957
00:41:55,609 --> 00:41:58,260
yeah well Terence is even talk next

958
00:41:58,260 --> 00:41:59,700
could maybe even say a little bit more

959
00:41:59,700 --> 00:42:00,150
about it but

960
00:42:00,150 --> 00:42:02,540
Viroqua uses lxc I think which is

961
00:42:02,540 --> 00:42:05,520
containers and so it's really not or

962
00:42:05,520 --> 00:42:09,210
hypervisor or whatever so I don't see a

963
00:42:09,210 --> 00:42:12,230
lot of people running Ruby on docker yet

964
00:42:12,230 --> 00:42:15,690
but most people are running Ruby already

965
00:42:15,690 --> 00:42:17,130
in a containerized environment whether

966
00:42:17,130 --> 00:42:19,530
they realize it or not or depending on

967
00:42:19,530 --> 00:42:22,559
your definition of container I think

968
00:42:22,559 --> 00:42:24,750
what's interesting and what kind of

969
00:42:24,750 --> 00:42:27,059
relates back to this talk is that most

970
00:42:27,059 --> 00:42:28,760
people running in these environments

971
00:42:28,760 --> 00:42:31,349
tend to run them in very resource

972
00:42:31,349 --> 00:42:35,640
constrained environments and memory is

973
00:42:35,640 --> 00:42:38,180
usually constraint in these environments

974
00:42:38,180 --> 00:42:40,680
you know like the default Heroku dynos

975
00:42:40,680 --> 00:42:42,780
size right is like 512 megabytes which

976
00:42:42,780 --> 00:42:46,609
is enough really half a rails process so

977
00:42:46,609 --> 00:42:50,099
I think people's memory knowledge is

978
00:42:50,099 --> 00:42:52,170
important for being able to shove big

979
00:42:52,170 --> 00:42:55,230
old legacy rails applications into small

980
00:42:55,230 --> 00:42:58,200
containers but increasingly I'm starting

981
00:42:58,200 --> 00:43:00,589
to think that CPU is also an extremely

982
00:43:00,589 --> 00:43:02,750
important thing in these environments

983
00:43:02,750 --> 00:43:07,740
like Amazon's V CPUs or just hyper

984
00:43:07,740 --> 00:43:10,290
threads so like you can have like 8

985
00:43:10,290 --> 00:43:12,210
gigabytes of RAM and then get like 2

986
00:43:12,210 --> 00:43:16,200
hyper threads so that's like nothing you

987
00:43:16,200 --> 00:43:19,109
know you can run like 1.5 Puma processes

988
00:43:19,109 --> 00:43:21,809
on that so I got to do some benchmarking

989
00:43:21,809 --> 00:43:22,920
and look at this

990
00:43:22,920 --> 00:43:25,230
more but like memory is a very important

991
00:43:25,230 --> 00:43:28,380
constraint and understanding how it

992
00:43:28,380 --> 00:43:31,020
works and and when GC occurs is going to

993
00:43:31,020 --> 00:43:32,549
help you with shoving stuff into these

994
00:43:32,549 --> 00:43:35,790
small containers but CPU is also

995
00:43:35,790 --> 00:43:38,880
increasingly scarce resource and that in

996
00:43:38,880 --> 00:44:15,450
the in the cloud yeah that's so the

997
00:44:15,450 --> 00:44:19,079
question is like we've also the the

998
00:44:19,079 --> 00:44:20,819
other side the flip side which I didn't

999
00:44:20,819 --> 00:44:24,210
talk about of trying to reduce GC memory

1000
00:44:24,210 --> 00:44:26,010
pressure is just don't allocate new

1001
00:44:26,010 --> 00:44:30,680
objects in the first place Joe so the

1002
00:44:30,680 --> 00:44:33,660
example was pushing frozen string

1003
00:44:33,660 --> 00:44:36,839
literals so I think was it - dot - we

1004
00:44:36,839 --> 00:44:38,400
got the magic comment at the top of the

1005
00:44:38,400 --> 00:44:39,960
file that was frozen string literal you

1006
00:44:39,960 --> 00:44:43,049
could just make the whole file sorry 2.3

1007
00:44:43,049 --> 00:44:49,619
okay okay so that frozen string literal

1008
00:44:49,619 --> 00:44:52,500
and the dot freeze or whatever right was

1009
00:44:52,500 --> 00:44:54,450
intended so that we freeze an object so

1010
00:44:54,450 --> 00:44:58,650
it's just not garbage collected right so

1011
00:44:58,650 --> 00:44:59,970
you kind of like it's almost like

1012
00:44:59,970 --> 00:45:02,190
hinting for the garbage collector

1013
00:45:02,190 --> 00:45:03,480
because you're just saying hey don't

1014
00:45:03,480 --> 00:45:05,700
ever collect this the object is not ever

1015
00:45:05,700 --> 00:45:10,650
gonna get collected right so I I was

1016
00:45:10,650 --> 00:45:12,059
also interested in that I actually asked

1017
00:45:12,059 --> 00:45:14,940
koishi about frozen string literal the

1018
00:45:14,940 --> 00:45:19,980
magic comment at rubyconf and because I

1019
00:45:19,980 --> 00:45:21,930
think part of the original promise of

1020
00:45:21,930 --> 00:45:25,819
the magic comment was that you would

1021
00:45:25,819 --> 00:45:27,660
that they were they were thing about

1022
00:45:27,660 --> 00:45:29,099
making that core language feature that

1023
00:45:29,099 --> 00:45:31,619
just all strings would all be frozen and

1024
00:45:31,619 --> 00:45:33,119
so it was sort of an experiment to put

1025
00:45:33,119 --> 00:45:34,890
in the runtime to see like okay does

1026
00:45:34,890 --> 00:45:36,600
that actually make people's app

1027
00:45:36,600 --> 00:45:39,240
patience faster koishi feels and I also

1028
00:45:39,240 --> 00:45:41,160
sort of feel that that hasn't really

1029
00:45:41,160 --> 00:45:45,000
been a huge performance impact just

1030
00:45:45,000 --> 00:45:47,880
either not enough stuff can be frozen or

1031
00:45:47,880 --> 00:45:49,830
when you do free stuff you end up

1032
00:45:49,830 --> 00:45:52,350
creating new strings any wave to create

1033
00:45:52,350 --> 00:45:54,840
the copy or whatever and you sort of

1034
00:45:54,840 --> 00:45:56,190
lose whatever gains you thought you had

1035
00:45:56,190 --> 00:46:04,260
so I haven't seen any real world benefit

1036
00:46:04,260 --> 00:46:06,720
major real world benefit from that in it

1037
00:46:06,720 --> 00:46:08,730
it doesn't seem like it's gonna change

1038
00:46:08,730 --> 00:46:12,780
or become like a that bat path where

1039
00:46:12,780 --> 00:46:14,160
where we're at right now with freezing

1040
00:46:14,160 --> 00:46:16,410
objects doesn't seem like it's gonna

1041
00:46:16,410 --> 00:46:18,000
change to me so much in the future I

1042
00:46:18,000 --> 00:46:20,250
asked him that in the context of guilds

1043
00:46:20,250 --> 00:46:21,780
right because the whole thing with

1044
00:46:21,780 --> 00:46:24,480
guilds is we can share frozen objects

1045
00:46:24,480 --> 00:46:25,710
between gilts as we know they're not

1046
00:46:25,710 --> 00:46:27,540
going to be modified right so we can

1047
00:46:27,540 --> 00:46:29,610
share these these frozen objects between

1048
00:46:29,610 --> 00:46:31,050
the different processes without fear of

1049
00:46:31,050 --> 00:46:33,170
modification so I said well you know

1050
00:46:33,170 --> 00:46:35,790
isn't that when we want to create more

1051
00:46:35,790 --> 00:46:39,030
shared objects then and I guess koishi

1052
00:46:39,030 --> 00:46:41,490
feels that that's the way that it is

1053
00:46:41,490 --> 00:47:02,760
currently is adequate I guess for the

1054
00:47:02,760 --> 00:47:03,750
connection

1055
00:47:03,750 --> 00:47:06,450
are you considering I could listen which

1056
00:47:06,450 --> 00:47:10,170
we reserved locality or like like the

1057
00:47:10,170 --> 00:47:12,600
mobis algorithm which also this point

1058
00:47:12,600 --> 00:47:14,940
locality yeah so I am NOT a ruby core

1059
00:47:14,940 --> 00:47:17,370
developer I've never committed to Ruby

1060
00:47:17,370 --> 00:47:20,490
actually I don't think yeah so the

1061
00:47:20,490 --> 00:47:21,480
person you have to ask is Aaron

1062
00:47:21,480 --> 00:47:22,830
Patterson because he's the one doing all

1063
00:47:22,830 --> 00:47:25,050
the work and compaction in in see Ruby

1064
00:47:25,050 --> 00:47:26,670
right now so if you just google Aaron

1065
00:47:26,670 --> 00:47:29,280
Patterson Ruby and you'll find him he's

1066
00:47:29,280 --> 00:47:38,880
hard to miss yeah I I think that that's

1067
00:47:38,880 --> 00:47:41,430
kind of like what has been talked about

1068
00:47:41,430 --> 00:47:43,770
with putting objects in an old heap and

1069
00:47:43,770 --> 00:47:46,290
a new heap that the new heap you know

1070
00:47:46,290 --> 00:47:48,520
your your

1071
00:47:48,520 --> 00:47:51,190
preserving locality that way I guess but

1072
00:47:51,190 --> 00:47:52,480
that's that's kinda outside my area of

1073
00:47:52,480 --> 00:48:20,980
expertise to be honest yeah yeah the

1074
00:48:20,980 --> 00:48:22,869
question was how can we make the GC

1075
00:48:22,869 --> 00:48:27,070
learn how to perform based how to make

1076
00:48:27,070 --> 00:48:28,510
decisions based on the actual

1077
00:48:28,510 --> 00:48:30,760
application performance they're there

1078
00:48:30,760 --> 00:48:33,310
you think I don't really think there's

1079
00:48:33,310 --> 00:48:37,030
anything in GCC right now I think that

1080
00:48:37,030 --> 00:48:39,220
could be described as doing that I think

1081
00:48:39,220 --> 00:48:44,650
all the important knobs really are set

1082
00:48:44,650 --> 00:48:46,480
by environment trails beforehand what

1083
00:48:46,480 --> 00:48:51,880
one thing that Ruby GC does do is these

1084
00:48:51,880 --> 00:48:54,340
thresholds like for increasing the heap

1085
00:48:54,340 --> 00:48:57,070
size do change because it's like based

1086
00:48:57,070 --> 00:49:00,160
on a ratio right like 1.4 is as a ratio

1087
00:49:00,160 --> 00:49:02,350
of the current heap slots used there's

1088
00:49:02,350 --> 00:49:04,390
also ways to cap that like you can say

1089
00:49:04,390 --> 00:49:08,170
1.4 or 300,000 heap slots whichever is

1090
00:49:08,170 --> 00:49:13,359
less so there's some like changes in

1091
00:49:13,359 --> 00:49:15,220
these thresholds as the application

1092
00:49:15,220 --> 00:49:17,350
executes but I wouldn't describe it as

1093
00:49:17,350 --> 00:49:21,390
the the run time learning about itself I

1094
00:49:21,390 --> 00:49:23,859
think that's interesting because one of

1095
00:49:23,859 --> 00:49:25,930
the problems that that MRI core

1096
00:49:25,930 --> 00:49:29,590
maintainer z' have is you know rails

1097
00:49:29,590 --> 00:49:31,630
long running rails processes have like

1098
00:49:31,630 --> 00:49:34,090
one very specific set of behavior and

1099
00:49:34,090 --> 00:49:36,100
then there's people that you know still

1100
00:49:36,100 --> 00:49:39,490
use Ruby for ten line you know sysadmin

1101
00:49:39,490 --> 00:49:41,140
scripts and then someone comes in to

1102
00:49:41,140 --> 00:49:42,880
that sometimes in another discussion and

1103
00:49:42,880 --> 00:49:44,320
says hey wait a second you can't do that

1104
00:49:44,320 --> 00:49:46,630
because you're gonna break my 64

1105
00:49:46,630 --> 00:49:47,830
megabytes of RAM

1106
00:49:47,830 --> 00:49:51,430
you know Raspberry Pi whatever you know

1107
00:49:51,430 --> 00:49:53,109
like some crazy environment that they

1108
00:49:53,109 --> 00:49:56,380
were on Ruby on Ruby is is has to has to

1109
00:49:56,380 --> 00:49:58,480
cater to all these use cases

1110
00:49:58,480 --> 00:50:01,570
yeah and so there's just so many

1111
00:50:01,570 --> 00:50:02,770
different ways that you can run Ruby

1112
00:50:02,770 --> 00:50:05,859
that it's difficult for a core language

1113
00:50:05,859 --> 00:50:08,589
maintainer to to make aggressive

1114
00:50:08,589 --> 00:50:11,230
decisions for one workload or another

1115
00:50:11,230 --> 00:50:14,530
workload so that's an interesting path

1116
00:50:14,530 --> 00:50:16,000
forward as far as I know nothing has

1117
00:50:16,000 --> 00:50:19,480
really been done on that front yet thank

1118
00:50:19,480 --> 00:50:21,599
you

