1
00:03:08,870 --> 00:03:13,240
[Music]

2
00:06:20,970 --> 00:06:23,169
okay so we hope it's fine

3
00:06:23,169 --> 00:06:25,990
so we certainly hope not and so what we

4
00:06:25,990 --> 00:06:28,000
propose here to you today is actually

5
00:06:28,000 --> 00:06:29,980
with something which we called

6
00:06:29,980 --> 00:06:32,260
graphology because we had to find a name

7
00:06:32,260 --> 00:06:34,000
because then p.m. is a wild place and

8
00:06:34,000 --> 00:06:35,410
when someone takes a name you can't take

9
00:06:35,410 --> 00:06:39,280
it back so we just like use the lame pun

10
00:06:39,280 --> 00:06:41,440
and this is it graphology so Gruffalo G

11
00:06:41,440 --> 00:06:43,660
what is it it is a specification for a

12
00:06:43,660 --> 00:06:46,060
robust and multi-purpose graph object in

13
00:06:46,060 --> 00:06:49,290
JavaScript so what does it mean really

14
00:06:49,290 --> 00:06:51,639
so yeah this is it so this is a

15
00:06:51,639 --> 00:06:54,190
specification not a library but you have

16
00:06:54,190 --> 00:06:55,960
a reference library which is the

17
00:06:55,960 --> 00:06:57,460
reference implementation of this

18
00:06:57,460 --> 00:06:59,440
specification which you can download and

19
00:06:59,440 --> 00:07:01,960
use and you have also a standard library

20
00:07:01,960 --> 00:07:05,080
which come attached to it which is which

21
00:07:05,080 --> 00:07:07,479
contains a lot of classical algorithms

22
00:07:07,479 --> 00:07:08,860
so I've got layouts

23
00:07:08,860 --> 00:07:11,320
you've got generations you've got it etc

24
00:07:11,320 --> 00:07:15,760
etc so this specification is meant to be

25
00:07:15,760 --> 00:07:17,470
multi-purpose so we are not targeting

26
00:07:17,470 --> 00:07:20,140
one specific kind of graph we are

27
00:07:20,140 --> 00:07:22,330
targeting a lot of graphs so the graph

28
00:07:22,330 --> 00:07:25,270
can be directed it can be undirected it

29
00:07:25,270 --> 00:07:27,490
can be mixed which is probably some

30
00:07:27,490 --> 00:07:29,080
perverting when you want to have like

31
00:07:29,080 --> 00:07:32,350
directed and undirected edges and the

32
00:07:32,350 --> 00:07:35,260
graph can be simple so A to B is only

33
00:07:35,260 --> 00:07:37,479
once or you can have a multiple graph

34
00:07:37,479 --> 00:07:39,729
which is a to B plus a to b plus A to B

35
00:07:39,729 --> 00:07:42,610
we don't care and the graph will or not

36
00:07:42,610 --> 00:07:44,710
really or will not accept self loops we

37
00:07:44,710 --> 00:07:46,270
don't have an opinion on this we let the

38
00:07:46,270 --> 00:07:49,780
user decide so we have a lot of use

39
00:07:49,780 --> 00:07:51,850
cases for this kind of library we have

40
00:07:51,850 --> 00:07:53,410
like graph analysis if you want to

41
00:07:53,410 --> 00:07:56,139
compute metrics or a whole indices about

42
00:07:56,139 --> 00:07:58,479
your graph if you want to perform like

43
00:07:58,479 --> 00:08:00,160
graph on link test like you want to

44
00:08:00,160 --> 00:08:02,590
build specific graphs like Viper and

45
00:08:02,590 --> 00:08:04,930
bipartite drive from data or modify

46
00:08:04,930 --> 00:08:06,760
something which already exists etcetera

47
00:08:06,760 --> 00:08:07,150
etcetera

48
00:08:07,150 --> 00:08:09,910
or maybe interface with some databases

49
00:08:09,910 --> 00:08:14,350
like neo4j or titan or so on and like

50
00:08:14,350 --> 00:08:16,180
you have also a data model for rendering

51
00:08:16,180 --> 00:08:18,070
which means that graphology is actually

52
00:08:18,070 --> 00:08:20,950
suitable for rendering libraries as a

53
00:08:20,950 --> 00:08:23,800
graph model because it has like a lot of

54
00:08:23,800 --> 00:08:26,440
evens and you can listen to mutations on

55
00:08:26,440 --> 00:08:28,240
the graph and so on we will see that

56
00:08:28,240 --> 00:08:29,580
later

57
00:08:29,580 --> 00:08:33,159
so what we won't do is handle graphed

58
00:08:33,159 --> 00:08:35,769
data that does not fit in RAM we are

59
00:08:35,769 --> 00:08:38,828
doing like the week man thing so we just

60
00:08:38,828 --> 00:08:40,870
like take graphs hold them in RAM and

61
00:08:40,870 --> 00:08:43,599
that's all if your graph is like 14

62
00:08:43,599 --> 00:08:48,550
gigabytes it's not our work and so I

63
00:08:48,550 --> 00:08:50,230
want to stress that this is a

64
00:08:50,230 --> 00:08:52,120
specification here we are building it's

65
00:08:52,120 --> 00:08:56,589
not a library so this means actually the

66
00:08:56,589 --> 00:08:59,079
following things is that I'm sure you

67
00:08:59,079 --> 00:09:00,970
will agree here that there is not a

68
00:09:00,970 --> 00:09:03,870
perfect way to implement graphs data so

69
00:09:03,870 --> 00:09:06,190
you can't really do it so there are

70
00:09:06,190 --> 00:09:07,870
implementations that will cover most use

71
00:09:07,870 --> 00:09:10,449
K more use cases than others and you can

72
00:09:10,449 --> 00:09:12,279
aggressively optimize an implementation

73
00:09:12,279 --> 00:09:14,199
to work on some really specific use

74
00:09:14,199 --> 00:09:17,139
cases so with a specification what we

75
00:09:17,139 --> 00:09:19,480
have is that anybody can implement the

76
00:09:19,480 --> 00:09:21,459
specification however you see fit

77
00:09:21,459 --> 00:09:24,819
and you will use its or far their

78
00:09:24,819 --> 00:09:28,329
implementation but we they will still

79
00:09:28,329 --> 00:09:30,430
like have the benefit of the standard

80
00:09:30,430 --> 00:09:32,410
library and be able to use like all the

81
00:09:32,410 --> 00:09:34,569
ecosystem of libraries which use this

82
00:09:34,569 --> 00:09:36,940
specification without having to recode

83
00:09:36,940 --> 00:09:39,190
them and again and again and again so

84
00:09:39,190 --> 00:09:40,540
for instance here you've got an example

85
00:09:40,540 --> 00:09:43,089
you've got graph which is actually an

86
00:09:43,089 --> 00:09:45,279
implementation of Prafulla G which is my

87
00:09:45,279 --> 00:09:47,440
custom graph alergy implementation which

88
00:09:47,440 --> 00:09:51,310
is why not build upon C++ for nap Jas

89
00:09:51,310 --> 00:09:53,410
and here you've got something which is a

90
00:09:53,410 --> 00:09:55,300
library from graphology which is the the

91
00:09:55,300 --> 00:09:57,579
function which is able to extract the

92
00:09:57,579 --> 00:09:59,560
connected components and so these

93
00:09:59,560 --> 00:10:01,720
functions will still work on your

94
00:10:01,720 --> 00:10:03,519
particular implementation of the graph

95
00:10:03,519 --> 00:10:07,060
because yeah it's the same API so no

96
00:10:07,060 --> 00:10:11,050
biggie here so that's why we have a

97
00:10:11,050 --> 00:10:14,139
specification and not a library so what

98
00:10:14,139 --> 00:10:15,610
are the main concepts of this little

99
00:10:15,610 --> 00:10:17,649
specification it's really simple you've

100
00:10:17,649 --> 00:10:19,569
got nodes and those are represented by

101
00:10:19,569 --> 00:10:22,420
keys and those nodes may be described

102
00:10:22,420 --> 00:10:24,519
but by several attributes which are like

103
00:10:24,519 --> 00:10:26,230
key value key value and so on and so on

104
00:10:26,230 --> 00:10:29,230
and an edge is represented by a key that

105
00:10:29,230 --> 00:10:31,420
may be provided or not because the graph

106
00:10:31,420 --> 00:10:33,430
is able to generate the IDS and you'll

107
00:10:33,430 --> 00:10:35,920
see why later but can also be

108
00:10:35,920 --> 00:10:38,380
represented by attributes so you've got

109
00:10:38,380 --> 00:10:41,439
nodes key attributes edges key source

110
00:10:41,439 --> 00:10:43,080
target attributes

111
00:10:43,080 --> 00:10:48,870
so that's a graph I guess and that's all

112
00:10:48,870 --> 00:10:50,880
so for instance here you've got like an

113
00:10:50,880 --> 00:10:53,370
example of the code if you like to load

114
00:10:53,370 --> 00:10:55,050
the reference implementation of the

115
00:10:55,050 --> 00:10:57,240
specification so you are going to like

116
00:10:57,240 --> 00:10:59,370
build a graph and you add notes to it

117
00:10:59,370 --> 00:11:02,610
and then you add one really interesting

118
00:11:02,610 --> 00:11:04,649
edge and then you add a really

119
00:11:04,649 --> 00:11:06,540
interesting a tribute to the susi node

120
00:11:06,540 --> 00:11:09,000
and you've got a miscellaneous

121
00:11:09,000 --> 00:11:10,740
informations like the order of the

122
00:11:10,740 --> 00:11:14,220
graphs of two obviously and you can like

123
00:11:14,220 --> 00:11:16,230
iterate on the nodes you can generate on

124
00:11:16,230 --> 00:11:17,910
one node a neighbor and so on and so on

125
00:11:17,910 --> 00:11:19,829
it's pretty boring actually it's just a

126
00:11:19,829 --> 00:11:26,610
great fake API basically and so and so

127
00:11:26,610 --> 00:11:27,779
this is the current state of the

128
00:11:27,779 --> 00:11:29,850
standard library for instance so this

129
00:11:29,850 --> 00:11:30,529
will grow

130
00:11:30,529 --> 00:11:33,540
you've got like assertion centrality

131
00:11:33,540 --> 00:11:36,750
matrix components detection generators

132
00:11:36,750 --> 00:11:38,160
like if you want to generate a random

133
00:11:38,160 --> 00:11:41,610
graph around elders or any graph you've

134
00:11:41,610 --> 00:11:43,829
got hits you've got layouts we've got

135
00:11:43,829 --> 00:11:45,540
four eight let's do layouts you've got

136
00:11:45,540 --> 00:11:47,670
operators and utilities and so on and so

137
00:11:47,670 --> 00:11:51,209
on and so on so you see the thing so

138
00:11:51,209 --> 00:11:54,329
what we want to speak about about here

139
00:11:54,329 --> 00:11:56,970
is more about like API design so because

140
00:11:56,970 --> 00:11:59,250
when we intended to implement a

141
00:11:59,250 --> 00:12:02,459
specification we were like a bit a bit

142
00:12:02,459 --> 00:12:04,829
like befuddled by the the whole

143
00:12:04,829 --> 00:12:06,480
diversity of graph library that exists

144
00:12:06,480 --> 00:12:09,120
and how we were going to like implement

145
00:12:09,120 --> 00:12:10,950
it what would be the semantics of the

146
00:12:10,950 --> 00:12:12,630
library how are we going to like add a

147
00:12:12,630 --> 00:12:15,180
node at the net exit Rattus right and

148
00:12:15,180 --> 00:12:17,100
there are a lot of ways to do so so we

149
00:12:17,100 --> 00:12:18,990
want to share with you what the choice

150
00:12:18,990 --> 00:12:20,930
what were the choice we made and how we

151
00:12:20,930 --> 00:12:24,740
we came upon the API we've got today and

152
00:12:24,740 --> 00:12:27,600
what kind of issues we had also and how

153
00:12:27,600 --> 00:12:31,620
we solve them or I hope we solve them so

154
00:12:31,620 --> 00:12:34,260
first of all we have in JavaScript and

155
00:12:34,260 --> 00:12:36,779
so javascript is not Java I hope you all

156
00:12:36,779 --> 00:12:39,560
know that otherwise I have to kill you

157
00:12:39,560 --> 00:12:41,940
so obviously we don't have classes for

158
00:12:41,940 --> 00:12:44,399
nodes and edges so this means there is

159
00:12:44,399 --> 00:12:46,230
only the graph which is actually an

160
00:12:46,230 --> 00:12:49,589
instance of a class and so you don't

161
00:12:49,589 --> 00:12:51,029
have things like this like your accounts

162
00:12:51,029 --> 00:12:55,500
node is Gail equals new node yeah no you

163
00:12:55,500 --> 00:12:56,760
don't like

164
00:12:56,760 --> 00:12:58,769
get note instances from the graph by

165
00:12:58,769 --> 00:13:01,350
adding a node or something so basically

166
00:13:01,350 --> 00:13:03,420
this means that the node is just a key

167
00:13:03,420 --> 00:13:05,699
and some attributes and that's it so if

168
00:13:05,699 --> 00:13:07,529
you want to ask questions about the

169
00:13:07,529 --> 00:13:09,420
graph or about the structure you will

170
00:13:09,420 --> 00:13:11,699
use keys both for nodes in both for

171
00:13:11,699 --> 00:13:17,550
edges that's all so the other issues we

172
00:13:17,550 --> 00:13:20,220
add we're concerning like the default

173
00:13:20,220 --> 00:13:22,230
graph type so because a graph can be a

174
00:13:22,230 --> 00:13:24,029
lot of things can be mixed it can be

175
00:13:24,029 --> 00:13:25,920
direct it can we end erected simple

176
00:13:25,920 --> 00:13:27,899
Milty we have to make a choice and tell

177
00:13:27,899 --> 00:13:30,389
you like what is the default graph and

178
00:13:30,389 --> 00:13:32,490
so we make we made a choice and we

179
00:13:32,490 --> 00:13:34,980
decided like the graph is mixed by

180
00:13:34,980 --> 00:13:37,199
default because most of developers

181
00:13:37,199 --> 00:13:38,370
actually don't want to make their choice

182
00:13:38,370 --> 00:13:40,500
because this question doesn't interest

183
00:13:40,500 --> 00:13:43,079
them at all so by default the graph is

184
00:13:43,079 --> 00:13:45,959
mixed so you can add directed edges and

185
00:13:45,959 --> 00:13:48,480
directed edges oh and also and that's

186
00:13:48,480 --> 00:13:50,220
not a problem but by default the graph

187
00:13:50,220 --> 00:13:52,910
is simple so you can't add Milty edges

188
00:13:52,910 --> 00:13:55,260
so you would just like create a graph

189
00:13:55,260 --> 00:13:56,760
and this is actually the same thing as

190
00:13:56,760 --> 00:13:58,410
saying that my graph is mixed and my

191
00:13:58,410 --> 00:14:04,050
graph is not mutable okay so this means

192
00:14:04,050 --> 00:14:07,230
some things like this means that usually

193
00:14:07,230 --> 00:14:09,089
when you build a graph implementation

194
00:14:09,089 --> 00:14:11,490
it's kind of useful to know whether the

195
00:14:11,490 --> 00:14:12,959
graph is directed or not because you can

196
00:14:12,959 --> 00:14:14,730
like of you can optimize the

197
00:14:14,730 --> 00:14:16,079
implementation because you won't

198
00:14:16,079 --> 00:14:18,420
implement an undirected graph the same

199
00:14:18,420 --> 00:14:19,769
way you would with a multiple diet

200
00:14:19,769 --> 00:14:22,589
directed graph and so on so if you don't

201
00:14:22,589 --> 00:14:24,660
want to choose yeah don't choose the

202
00:14:24,660 --> 00:14:26,490
implementation will work but if you want

203
00:14:26,490 --> 00:14:28,319
to choose because you know it you can

204
00:14:28,319 --> 00:14:30,149
use like type constituents and

205
00:14:30,149 --> 00:14:32,459
constructors to do so and the

206
00:14:32,459 --> 00:14:33,899
implementation will be able to optimize

207
00:14:33,899 --> 00:14:35,790
itself because it has information

208
00:14:35,790 --> 00:14:37,829
basically so if you don't want to choose

209
00:14:37,829 --> 00:14:39,630
you don't choose but if you know just

210
00:14:39,630 --> 00:14:41,730
say it and the optimization will be

211
00:14:41,730 --> 00:14:44,459
possible to mirror up so here for

212
00:14:44,459 --> 00:14:45,959
instance we are going to instantiate a

213
00:14:45,959 --> 00:14:48,240
multi directed graph which has exactly

214
00:14:48,240 --> 00:14:50,550
the same API as any other graph of the

215
00:14:50,550 --> 00:14:53,819
library so there are no like difference

216
00:14:53,819 --> 00:14:55,470
in the semantics of the API for instance

217
00:14:55,470 --> 00:14:57,839
in network Ickx if you build a directed

218
00:14:57,839 --> 00:15:00,240
graph you won't have the exact same api

219
00:15:00,240 --> 00:15:02,790
as you would be with the undirected

220
00:15:02,790 --> 00:15:05,010
graph so here you have the exact same

221
00:15:05,010 --> 00:15:08,730
methods everywhere so this means that we

222
00:15:08,730 --> 00:15:10,720
have to rely on some useful error

223
00:15:10,720 --> 00:15:12,759
ages and hints so if the user is going

224
00:15:12,759 --> 00:15:14,470
to do something which is completely

225
00:15:14,470 --> 00:15:15,370
stupid

226
00:15:15,370 --> 00:15:17,920
for instance adding a second a B edge

227
00:15:17,920 --> 00:15:20,709
where there is already an a B edge the

228
00:15:20,709 --> 00:15:22,480
graph will tell him really politely that

229
00:15:22,480 --> 00:15:23,670
he is a

230
00:15:23,670 --> 00:15:27,100
so that here you have it so we added

231
00:15:27,100 --> 00:15:29,139
some note we had an edge we had the same

232
00:15:29,139 --> 00:15:31,750
edge the graph will tell you that you

233
00:15:31,750 --> 00:15:32,980
can't really do that you know it's a

234
00:15:32,980 --> 00:15:34,360
simple graph so if you want to have a

235
00:15:34,360 --> 00:15:36,550
multi graph maybe should like use a

236
00:15:36,550 --> 00:15:39,459
multi graph so this way we both have the

237
00:15:39,459 --> 00:15:41,410
benefits of having like a standardized

238
00:15:41,410 --> 00:15:45,279
API for all types and like being able to

239
00:15:45,279 --> 00:15:47,500
explain really gently to the user that

240
00:15:47,500 --> 00:15:52,959
is making some mistakes okay so the

241
00:15:52,959 --> 00:15:55,360
other problem we had was concerning like

242
00:15:55,360 --> 00:15:58,569
the edge keys so it might not seem a

243
00:15:58,569 --> 00:16:00,069
problem because usually you don't use

244
00:16:00,069 --> 00:16:01,720
keys because the keys is just like the

245
00:16:01,720 --> 00:16:04,360
source to the target but when you have

246
00:16:04,360 --> 00:16:06,579
multi edges or multigraphs

247
00:16:06,579 --> 00:16:08,379
you have the problem of being able to

248
00:16:08,379 --> 00:16:11,290
target a really specific edge and you

249
00:16:11,290 --> 00:16:13,060
can't do it if you just have the source

250
00:16:13,060 --> 00:16:14,439
in the target because you have to going

251
00:16:14,439 --> 00:16:17,050
you have to be able to like loop on the

252
00:16:17,050 --> 00:16:18,819
edges to find the one you want and this

253
00:16:18,819 --> 00:16:22,180
is a bit silly so here we told ourselves

254
00:16:22,180 --> 00:16:24,399
we are going to use keys for edges

255
00:16:24,399 --> 00:16:26,709
because this is quite useful and you can

256
00:16:26,709 --> 00:16:28,750
target really specific edges but the

257
00:16:28,750 --> 00:16:30,610
thing is and we learned this the hard

258
00:16:30,610 --> 00:16:32,860
way on Sigma is that it's really boring

259
00:16:32,860 --> 00:16:35,110
a to ask your review user to like

260
00:16:35,110 --> 00:16:37,870
invent keys for things which don't have

261
00:16:37,870 --> 00:16:40,059
keys specifically like in a simple graph

262
00:16:40,059 --> 00:16:42,069
you won't you won't you don't want to

263
00:16:42,069 --> 00:16:44,589
tell your user okay like take your

264
00:16:44,589 --> 00:16:46,360
counter and increment it each time you

265
00:16:46,360 --> 00:16:48,579
add an edge so you will have a unique ID

266
00:16:48,579 --> 00:16:52,209
this is really a pain so at the

267
00:16:52,209 --> 00:16:53,829
beginning which all okay we are going to

268
00:16:53,829 --> 00:16:56,319
like have a method which is add add a

269
00:16:56,319 --> 00:16:58,240
key a source and a target and some

270
00:16:58,240 --> 00:17:00,160
attributes and we are going to have like

271
00:17:00,160 --> 00:17:03,639
method which would be graph dot aid add

272
00:17:03,639 --> 00:17:06,280
edge without a key and we have toast and

273
00:17:06,280 --> 00:17:07,900
target and attributes but this was like

274
00:17:07,900 --> 00:17:10,839
yeah really boring so we went the other

275
00:17:10,839 --> 00:17:13,119
way until hotel so if you had an edge

276
00:17:13,119 --> 00:17:15,760
the graph will generate the idea for you

277
00:17:15,760 --> 00:17:17,829
and the key for you and if you want to

278
00:17:17,829 --> 00:17:19,599
explicitly provide a key for the edge

279
00:17:19,599 --> 00:17:22,510
just do it with the this one which is at

280
00:17:22,510 --> 00:17:24,400
edge with key

281
00:17:24,400 --> 00:17:27,130
so like the really common case is easy

282
00:17:27,130 --> 00:17:32,559
and the hard case is like swept away but

283
00:17:32,559 --> 00:17:34,180
this means that you have to generate a

284
00:17:34,180 --> 00:17:36,970
key and actually it's not a really easy

285
00:17:36,970 --> 00:17:39,010
task because like incremental ideas are

286
00:17:39,010 --> 00:17:40,660
really shitty because if you merge two

287
00:17:40,660 --> 00:17:42,730
graphs you will have like some issues

288
00:17:42,730 --> 00:17:45,640
like I already have the 1 edges and you

289
00:17:45,640 --> 00:17:47,440
have also the 1 edge but they are not

290
00:17:47,440 --> 00:17:49,330
the same how do you do so you have to

291
00:17:49,330 --> 00:17:50,980
find a clever way to do so so we did

292
00:17:50,980 --> 00:17:52,900
like we went with the easy way which is

293
00:17:52,900 --> 00:17:55,410
UID and in the current implementation

294
00:17:55,410 --> 00:17:58,570
actually the edges are process up the

295
00:17:58,570 --> 00:18:00,580
edge right keys are generated likewise

296
00:18:00,580 --> 00:18:03,700
so we generate a UID v4 and then we

297
00:18:03,700 --> 00:18:07,420
compressed it in base 62 to reduce the

298
00:18:07,420 --> 00:18:10,030
amount of RAM use them and they're

299
00:18:10,030 --> 00:18:12,429
really neat trick with base 62 is yet is

300
00:18:12,429 --> 00:18:13,809
that you can double click on the thing

301
00:18:13,809 --> 00:18:15,820
and copy it really easily whereas in

302
00:18:15,820 --> 00:18:18,340
base64 you have like hyphens and

303
00:18:18,340 --> 00:18:20,860
underscores and shitty things like that

304
00:18:20,860 --> 00:18:23,110
that yeah you can't double click and

305
00:18:23,110 --> 00:18:27,490
it's a pain so this is the most crucial

306
00:18:27,490 --> 00:18:33,040
point of the implementation so what

307
00:18:33,040 --> 00:18:34,780
about adding and merging nodes for

308
00:18:34,780 --> 00:18:36,490
instance it could be edges also but I'm

309
00:18:36,490 --> 00:18:37,870
going to speak about nodes in this

310
00:18:37,870 --> 00:18:40,410
example so what does it mean exactly so

311
00:18:40,410 --> 00:18:43,120
when you add a node which is John and

312
00:18:43,120 --> 00:18:45,880
you add this the same node again what

313
00:18:45,880 --> 00:18:48,040
should happen I for instance in network

314
00:18:48,040 --> 00:18:50,740
X if you do so it works like a set so if

315
00:18:50,740 --> 00:18:53,770
you do so the graph will just a loop app

316
00:18:53,770 --> 00:18:56,020
ok I won't do anything no biggie

317
00:18:56,020 --> 00:18:58,059
I already have the node but here we've

318
00:18:58,059 --> 00:18:59,710
got a little bit of a problem which is

319
00:18:59,710 --> 00:19:02,530
we have also have attributes so if you

320
00:19:02,530 --> 00:19:06,300
do this twice what the hell should we do

321
00:19:06,300 --> 00:19:09,340
so networking side really apply some

322
00:19:09,340 --> 00:19:11,470
agent magic on there and you will say ok

323
00:19:11,470 --> 00:19:13,090
I'm going to not add the node but I'm

324
00:19:13,090 --> 00:19:15,700
going to merge the attributes so this

325
00:19:15,700 --> 00:19:18,010
was a bit magical too magical for us so

326
00:19:18,010 --> 00:19:20,410
we decided upon something which is a bit

327
00:19:20,410 --> 00:19:22,360
different which is you are going to add

328
00:19:22,360 --> 00:19:24,040
the node if you add the node twice we

329
00:19:24,040 --> 00:19:25,750
are going to yell at you by saying you

330
00:19:25,750 --> 00:19:27,910
that you're doing something which is

331
00:19:27,910 --> 00:19:29,950
really silly and this is actually quite

332
00:19:29,950 --> 00:19:31,270
useful because for instance when you

333
00:19:31,270 --> 00:19:34,360
serialized in cellulite data and you

334
00:19:34,360 --> 00:19:37,560
process this data and you like

335
00:19:37,560 --> 00:19:39,060
notice that you have twice the same

336
00:19:39,060 --> 00:19:41,400
notes whereas you should not have it

337
00:19:41,400 --> 00:19:43,200
it's quite useful to have an error

338
00:19:43,200 --> 00:19:45,690
rather than just silently do nothing and

339
00:19:45,690 --> 00:19:48,360
so if you want to explicitly merge

340
00:19:48,360 --> 00:19:49,950
something you are going to use merging

341
00:19:49,950 --> 00:19:51,630
methods like the merge known methods

342
00:19:51,630 --> 00:19:55,080
which actually will not add a note will

343
00:19:55,080 --> 00:19:57,000
not yell if the node is already existent

344
00:19:57,000 --> 00:19:59,520
existing and will merge their attributes

345
00:19:59,520 --> 00:20:03,480
as you would expect the method to do so

346
00:20:03,480 --> 00:20:07,020
instead of like doing some magic we

347
00:20:07,020 --> 00:20:09,090
chose to yell at the user and tell him

348
00:20:09,090 --> 00:20:11,610
to do some things explicitly rather than

349
00:20:11,610 --> 00:20:18,150
implicitly so what is the key in the

350
00:20:18,150 --> 00:20:21,300
graph so this one was a bit long to

351
00:20:21,300 --> 00:20:23,730
solve but I'm going to like a bit faster

352
00:20:23,730 --> 00:20:26,670
because we are running out of time so

353
00:20:26,670 --> 00:20:28,110
what should be a key like foreign

354
00:20:28,110 --> 00:20:29,730
Network is for instance you can have

355
00:20:29,730 --> 00:20:31,710
anything as a key so he can be a

356
00:20:31,710 --> 00:20:33,300
reference a key can be a string it's a

357
00:20:33,300 --> 00:20:36,140
asset right so here we chose like to be

358
00:20:36,140 --> 00:20:38,970
more like the JavaScript wait for

359
00:20:38,970 --> 00:20:41,190
multiple reasons so only a string can be

360
00:20:41,190 --> 00:20:43,680
a key so if you pass like an integer it

361
00:20:43,680 --> 00:20:45,930
will be cursed and cast into a key like

362
00:20:45,930 --> 00:20:48,510
an object would do why do we do that

363
00:20:48,510 --> 00:20:51,060
because it's more Java scripting it's

364
00:20:51,060 --> 00:20:52,830
really easy to serialize because

365
00:20:52,830 --> 00:20:55,730
serializing an object is like a pain and

366
00:20:55,730 --> 00:21:03,390
that's mostly it and so - yeah that's it

367
00:21:03,390 --> 00:21:07,230
so the other problem we had was that was

368
00:21:07,230 --> 00:21:09,360
that we needed events because we might

369
00:21:09,360 --> 00:21:11,370
use this library in a rendering context

370
00:21:11,370 --> 00:21:13,110
and we might be interested by some

371
00:21:13,110 --> 00:21:15,810
really focused informations about for

372
00:21:15,810 --> 00:21:17,790
instance this node was updated and the

373
00:21:17,790 --> 00:21:19,890
color of this node was a dated this is

374
00:21:19,890 --> 00:21:21,030
important for two reasons

375
00:21:21,030 --> 00:21:23,730
rendering and like shipping indices

376
00:21:23,730 --> 00:21:28,830
synchronized so we have heavens and so

377
00:21:28,830 --> 00:21:31,530
because we have events we obviously need

378
00:21:31,530 --> 00:21:32,730
to have like some setters and getters

379
00:21:32,730 --> 00:21:34,800
because otherwise we are not able to

380
00:21:34,800 --> 00:21:38,370
know something was mutated so it's not

381
00:21:38,370 --> 00:21:41,450
Java but it's a little bit Java anyway

382
00:21:41,450 --> 00:21:43,770
so you want to do good get node

383
00:21:43,770 --> 00:21:46,560
attributes it has the notes key the name

384
00:21:46,560 --> 00:21:48,340
of the attribute you got it

385
00:21:48,340 --> 00:21:51,070
you want the attributes just do that you

386
00:21:51,070 --> 00:21:53,200
want to set an attribute the same thing

387
00:21:53,200 --> 00:21:55,539
it's a try to drive so basically quite

388
00:21:55,539 --> 00:21:58,330
simple but this doesn't mean that we

389
00:21:58,330 --> 00:22:01,350
have to be stupid about Java so

390
00:22:01,350 --> 00:22:04,299
basically nobody should have to write

391
00:22:04,299 --> 00:22:06,669
this kind of thing because to increment

392
00:22:06,669 --> 00:22:09,309
encounter be able to say like graphs set

393
00:22:09,309 --> 00:22:11,980
the node attribute for this key

394
00:22:11,980 --> 00:22:13,900
for this counter equals and grab that

395
00:22:13,900 --> 00:22:15,850
get the node attribute it's

396
00:22:15,850 --> 00:22:19,240
silly so we went with an o FB approach

397
00:22:19,240 --> 00:22:21,580
object orientated functional programming

398
00:22:21,580 --> 00:22:23,950
which is update the node attribute and

399
00:22:23,950 --> 00:22:25,360
just pass some functions to apply the

400
00:22:25,360 --> 00:22:30,760
change and this means actually as a cool

401
00:22:30,760 --> 00:22:33,340
side effects simpler iteration semantics

402
00:22:33,340 --> 00:22:35,679
because at the beginning we would we

403
00:22:35,679 --> 00:22:37,450
were questioning ourselves about like if

404
00:22:37,450 --> 00:22:38,799
you iterate on the node

405
00:22:38,799 --> 00:22:41,200
what should we provide to your users the

406
00:22:41,200 --> 00:22:43,090
notes key plus the attributes with some

407
00:22:43,090 --> 00:22:45,070
other informations so it was a bit

408
00:22:45,070 --> 00:22:48,250
strange and how to grasp so we just said

409
00:22:48,250 --> 00:22:51,039
ok you'll just have the keys and then

410
00:22:51,039 --> 00:22:52,090
you'll ask the graph of other

411
00:22:52,090 --> 00:22:54,399
information if you need it so you save

412
00:22:54,399 --> 00:22:55,570
up some memory you save up some

413
00:22:55,570 --> 00:22:58,600
semantics and that's a bit better I

414
00:22:58,600 --> 00:23:04,179
guess and so the last point we tackled

415
00:23:04,179 --> 00:23:05,890
during the design of the IP I was

416
00:23:05,890 --> 00:23:07,750
another information which is what should

417
00:23:07,750 --> 00:23:09,820
we do with labels weights and so on

418
00:23:09,820 --> 00:23:11,409
because the graph theory is full of

419
00:23:11,409 --> 00:23:16,470
those kind of special attributes and so

420
00:23:16,490 --> 00:23:19,140
because the graph theory like fosters an

421
00:23:19,140 --> 00:23:21,300
environment where you have like really

422
00:23:21,300 --> 00:23:24,480
variation about a common typology like

423
00:23:24,480 --> 00:23:26,160
you would say a node or add vertex or

424
00:23:26,160 --> 00:23:27,990
something we just told okay

425
00:23:27,990 --> 00:23:29,640
they are like attributes like any other

426
00:23:29,640 --> 00:23:32,340
and that's all you have and so oh the

427
00:23:32,340 --> 00:23:35,220
library is made while thinking about

428
00:23:35,220 --> 00:23:36,960
this and if you I've loved if you want

429
00:23:36,960 --> 00:23:38,940
to call your wait with the shitty name

430
00:23:38,940 --> 00:23:41,310
you can just provide the configuration

431
00:23:41,310 --> 00:23:47,070
and you should be okay okay so this

432
00:23:47,070 --> 00:23:49,440
little this leads us to you like how did

433
00:23:49,440 --> 00:23:53,220
we implement the reference library so

434
00:23:53,220 --> 00:23:54,780
how did we implement the specification

435
00:23:54,780 --> 00:23:57,240
so in JavaScript for anyone to use the

436
00:23:57,240 --> 00:23:58,650
reference implementation that you can

437
00:23:58,650 --> 00:24:00,620
download and use by doing npm install

438
00:24:00,620 --> 00:24:05,070
graphology and so the main issues we had

439
00:24:05,070 --> 00:24:07,560
was a concerning like constant time

440
00:24:07,560 --> 00:24:09,930
versus memory because we don't really

441
00:24:09,930 --> 00:24:12,330
know what the user is going are going to

442
00:24:12,330 --> 00:24:13,980
do with the graph we can't really

443
00:24:13,980 --> 00:24:15,750
aggressively optimize for some use case

444
00:24:15,750 --> 00:24:17,580
so we decided we are going to like

445
00:24:17,580 --> 00:24:18,990
support everything in constant time so

446
00:24:18,990 --> 00:24:20,820
this means if you had a node constant

447
00:24:20,820 --> 00:24:22,680
time delete a node constant time you

448
00:24:22,680 --> 00:24:25,170
want to like fine if an edge exists

449
00:24:25,170 --> 00:24:27,630
constant time so this means we have like

450
00:24:27,630 --> 00:24:29,550
some memory hover edge to be able to

451
00:24:29,550 --> 00:24:32,570
provide this kind of fast operations and

452
00:24:32,570 --> 00:24:34,950
so the actual that the scripture is

453
00:24:34,950 --> 00:24:37,830
likewise we have two maps which were

454
00:24:37,830 --> 00:24:41,100
introduced in a exist in es6 which are

455
00:24:41,100 --> 00:24:43,590
going to store like another index key

456
00:24:43,590 --> 00:24:47,160
value and an edge key value index and we

457
00:24:47,160 --> 00:24:49,260
have a lady lazy indexation of neighbors

458
00:24:49,260 --> 00:24:51,480
which means that we won't build like the

459
00:24:51,480 --> 00:24:53,790
information of the neighbors if we don't

460
00:24:53,790 --> 00:24:58,380
need it so the node maps will store

461
00:24:58,380 --> 00:24:59,510
these kind of things like degrees

462
00:24:59,510 --> 00:25:02,250
attribute data and lazy neighborhood

463
00:25:02,250 --> 00:25:03,960
indexation so this means that if you

464
00:25:03,960 --> 00:25:06,150
have to check like this is my neighbors

465
00:25:06,150 --> 00:25:07,800
it will compute the index and then

466
00:25:07,800 --> 00:25:09,810
you'll have it but not on the first time

467
00:25:09,810 --> 00:25:13,620
and so this the index of neighbors look

468
00:25:13,620 --> 00:25:16,310
like this so it's actually sparse matrix

469
00:25:16,310 --> 00:25:19,080
it's a really simple space match matrix

470
00:25:19,080 --> 00:25:21,330
so you've got like the node a has got

471
00:25:21,330 --> 00:25:24,090
like out neighbors which are b and c and

472
00:25:24,090 --> 00:25:27,090
so on and you've got a set of the edges

473
00:25:27,090 --> 00:25:29,179
which are related to the path each

474
00:25:29,179 --> 00:25:32,029
and a to be etc and the only

475
00:25:32,029 --> 00:25:33,769
optimization we run is that like this

476
00:25:33,769 --> 00:25:35,749
set is actually the same reference as

477
00:25:35,749 --> 00:25:38,509
this set so it means that I a I would be

478
00:25:38,509 --> 00:25:44,059
is actually the same as be in a and so

479
00:25:44,059 --> 00:25:45,649
the edge map is quite similar you've got

480
00:25:45,649 --> 00:25:47,269
like the source the target directedness

481
00:25:47,269 --> 00:25:50,869
and some a tribute data and so I'm sure

482
00:25:50,869 --> 00:25:52,669
that someone can find something better

483
00:25:52,669 --> 00:25:56,779
so please bash me and help me you'll

484
00:25:56,779 --> 00:26:00,190
find something a bit like interesting

485
00:26:00,190 --> 00:26:02,450
and so the last issue we will tackle is

486
00:26:02,450 --> 00:26:04,700
like the cases of undirected edges how

487
00:26:04,700 --> 00:26:07,489
do you store them so in memory we just

488
00:26:07,489 --> 00:26:10,070
like to keep an implicit direction so if

489
00:26:10,070 --> 00:26:12,259
you say add edge a B we will store like

490
00:26:12,259 --> 00:26:14,960
and I erected in a and directed out B

491
00:26:14,960 --> 00:26:17,839
and if you say like be a it will change

492
00:26:17,839 --> 00:26:19,759
the internal representation in memory of

493
00:26:19,759 --> 00:26:22,999
the edges so we to every equivalent

494
00:26:22,999 --> 00:26:24,169
graphs may have different memory

495
00:26:24,169 --> 00:26:26,210
representation and for some people it

496
00:26:26,210 --> 00:26:28,429
seems to be an issue so I want to have

497
00:26:28,429 --> 00:26:30,320
feedback on that and so should we solve

498
00:26:30,320 --> 00:26:31,849
the source and target keys should we ask

499
00:26:31,849 --> 00:26:34,269
them I don't know I read on no so please

500
00:26:34,269 --> 00:26:39,320
bash me again and if you want to have

501
00:26:39,320 --> 00:26:40,460
some precision on the invasive

502
00:26:40,460 --> 00:26:41,989
implementation please do read them

503
00:26:41,989 --> 00:26:43,429
didn't read the code everything is

504
00:26:43,429 --> 00:26:44,960
open-source and everything is accessible

505
00:26:44,960 --> 00:26:48,229
and you can contribute yeah so the

506
00:26:48,229 --> 00:26:59,799
future roadmap now really quickly yeah

507
00:26:59,799 --> 00:27:03,529
we we will give up a fully Sigma without

508
00:27:03,529 --> 00:27:05,210
the graph model which is kind of good

509
00:27:05,210 --> 00:27:08,359
news for us and with a really smaller

510
00:27:08,359 --> 00:27:11,059
specific functional scope which is just

511
00:27:11,059 --> 00:27:12,710
doing rendering management and

512
00:27:12,710 --> 00:27:15,499
interaction management just really nicer

513
00:27:15,499 --> 00:27:16,099
for me

514
00:27:16,099 --> 00:27:18,889
so no more no more yeah I need to

515
00:27:18,889 --> 00:27:20,479
implement the page rank to render grass

516
00:27:20,479 --> 00:27:24,619
which is kind of nonsense full we will

517
00:27:24,619 --> 00:27:26,210
have graphology too and all that and

518
00:27:26,210 --> 00:27:29,899
some just quick no community notes since

519
00:27:29,899 --> 00:27:31,429
Guillaume is actually more maintaining

520
00:27:31,429 --> 00:27:34,429
it than I do will try to adopt more

521
00:27:34,429 --> 00:27:38,149
community workflow with a an actual road

522
00:27:38,149 --> 00:27:40,279
map put this on a github organization

523
00:27:40,279 --> 00:27:42,679
and try to have

524
00:27:42,679 --> 00:27:48,899
more frequent dates actually and so for

525
00:27:48,899 --> 00:27:51,480
like future ideas so should we try to

526
00:27:51,480 --> 00:27:52,740
support hypergraphs

527
00:27:52,740 --> 00:27:56,850
that someone needs it that someone is an

528
00:27:56,850 --> 00:27:58,679
immutable immutable version like it's

529
00:27:58,679 --> 00:28:00,539
easy to write using immutable J's or

530
00:28:00,539 --> 00:28:03,630
Mori we would like to have like

531
00:28:03,630 --> 00:28:05,340
typescript definitions and so on because

532
00:28:05,340 --> 00:28:07,100
it's all the rage right now because like

533
00:28:07,100 --> 00:28:11,580
static types yeah and thank you so this

534
00:28:11,580 --> 00:28:14,190
is all a work in progress so please bash

535
00:28:14,190 --> 00:28:17,039
us and help us like achieve a more a

536
00:28:17,039 --> 00:28:35,190
more useful tool yep thank you sorry I

537
00:28:35,190 --> 00:28:43,289
consider you had a graph with like 1

538
00:28:43,289 --> 00:28:46,500
billion notes but not really represented

539
00:28:46,500 --> 00:28:47,940
a because they did not have a lot of

540
00:28:47,940 --> 00:28:51,000
attributes data so but it will like

541
00:28:51,000 --> 00:28:53,190
store a lot of data but not more than

542
00:28:53,190 --> 00:28:55,799
you can store in an app in node.js for

543
00:28:55,799 --> 00:28:57,570
instance so it will like random memory

544
00:28:57,570 --> 00:29:02,809
quite easily because of no and things

545
00:29:08,090 --> 00:29:10,529
actually it could be like the object of

546
00:29:10,529 --> 00:29:13,110
a custom implementation because it could

547
00:29:13,110 --> 00:29:14,940
be like quite easy to do but not for the

548
00:29:14,940 --> 00:29:18,000
reference implementation but if like you

549
00:29:18,000 --> 00:29:20,399
can't implement the specification

550
00:29:20,399 --> 00:29:22,830
without being able to like implement

551
00:29:22,830 --> 00:29:24,740
your own compression then we failed and

552
00:29:24,740 --> 00:29:28,019
so maybe we fail but I think you can do

553
00:29:28,019 --> 00:29:30,049
it

554
00:29:46,920 --> 00:29:51,670
yeah yeah so there is a stub of library

555
00:29:51,670 --> 00:29:54,310
which does this kind of layouts so the

556
00:29:54,310 --> 00:29:55,660
rendering is like a different question

557
00:29:55,660 --> 00:29:57,490
which will be under like with other

558
00:29:57,490 --> 00:29:59,620
libraries like Sigma J s and so on but

559
00:29:59,620 --> 00:30:02,020
for the layout like for now the

560
00:30:02,020 --> 00:30:05,070
implement in what I like

