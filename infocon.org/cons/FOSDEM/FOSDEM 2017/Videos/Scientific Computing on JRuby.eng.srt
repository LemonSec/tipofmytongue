1
00:00:26,970 --> 00:00:28,420
[Music]

2
00:00:28,420 --> 00:00:31,780
instead of students and he did do some

3
00:00:31,780 --> 00:00:34,660
of code for Google and at that time he

4
00:00:34,660 --> 00:00:36,100
has the opportunity to dig into

5
00:00:36,100 --> 00:00:58,479
scientific computing and so you see that

6
00:00:58,479 --> 00:01:00,909
he has a quite good understanding of

7
00:01:00,909 --> 00:01:08,969
scientific computing Thanks

8
00:01:08,969 --> 00:01:12,250
hi I am per soon and I'll be talking

9
00:01:12,250 --> 00:01:15,280
about scientific computing on JRuby so

10
00:01:15,280 --> 00:01:19,180
the main objective of this talk is to to

11
00:01:19,180 --> 00:01:21,729
tell you tell you how to create a great

12
00:01:21,729 --> 00:01:25,240
gem or two that uses JRuby and that can

13
00:01:25,240 --> 00:01:28,719
that's really highly efficient and has a

14
00:01:28,719 --> 00:01:31,810
very good speed and this is all because

15
00:01:31,810 --> 00:01:33,340
the scientific library that I worked on

16
00:01:33,340 --> 00:01:36,880
is memory intensive and speed counts so

17
00:01:36,880 --> 00:01:38,740
I'd like to share my experiences with

18
00:01:38,740 --> 00:01:41,649
that next I will be introducing

19
00:01:41,649 --> 00:01:43,450
introducing you to the general-purpose

20
00:01:43,450 --> 00:01:46,359
GPU liability that I worked on and this

21
00:01:46,359 --> 00:01:49,149
this was after my G sock and this

22
00:01:49,149 --> 00:01:51,869
library can be used for industry in

23
00:01:51,869 --> 00:01:54,549
production and academia for research and

24
00:01:54,549 --> 00:01:58,390
yes it can be integrated with rails so

25
00:01:58,390 --> 00:02:01,119
side Ruby is also called as Ruby Science

26
00:02:01,119 --> 00:02:03,819
Foundation and it has been trying to

27
00:02:03,819 --> 00:02:06,999
push Ruby for scientific computing some

28
00:02:06,999 --> 00:02:09,130
of the popular side Ruby gems that we

29
00:02:09,130 --> 00:02:12,970
have currently are n matrix taru mixed

30
00:02:12,970 --> 00:02:15,490
models may applaud ipython notebook and

31
00:02:15,490 --> 00:02:16,599
many more

32
00:02:16,599 --> 00:02:19,799
so these are the most commonly used ones

33
00:02:19,799 --> 00:02:24,459
so what n matrix is and matrix is a side

34
00:02:24,459 --> 00:02:27,579
obols numerical matrix code it helps you

35
00:02:27,579 --> 00:02:29,709
to perform linear algebra calculations

36
00:02:29,709 --> 00:02:34,349
on your CPU and it has support for both

37
00:02:34,349 --> 00:02:37,500
dense matrices and sparse matrices

38
00:02:37,500 --> 00:02:39,939
basically it helps you to analyze

39
00:02:39,939 --> 00:02:42,639
matrices which you might have studied in

40
00:02:42,639 --> 00:02:45,220
your high school where you used to solve

41
00:02:45,220 --> 00:02:48,639
linear equations using matrices and n

42
00:02:48,639 --> 00:02:52,900
matrix later for MRI relies on Atlas C

43
00:02:52,900 --> 00:02:55,150
plus C lapak and standard lapak

44
00:02:55,150 --> 00:02:57,730
libraries for its core linear algebra

45
00:02:57,730 --> 00:03:00,519
operations this libraries are

46
00:03:00,519 --> 00:03:02,739
state-of-the-art libraries because they

47
00:03:02,739 --> 00:03:04,599
are written in Fortran and are highly

48
00:03:04,599 --> 00:03:07,359
efficient and are used for number

49
00:03:07,359 --> 00:03:10,870
crunching so this is how you use an n

50
00:03:10,870 --> 00:03:14,169
matrix gem you just require it and in

51
00:03:14,169 --> 00:03:16,629
the first one second line of code I

52
00:03:16,629 --> 00:03:19,810
create an n matrix this you can see that

53
00:03:19,810 --> 00:03:22,989
it's a two dimensional matrix of three

54
00:03:22,989 --> 00:03:24,970
rows and three columns followed by the

55
00:03:24,970 --> 00:03:27,909
element it contents and the type of the

56
00:03:27,909 --> 00:03:30,549
matrix is float64 which is actually

57
00:03:30,549 --> 00:03:34,299
double so double is used for scientific

58
00:03:34,299 --> 00:03:36,129
computing because it has the high

59
00:03:36,129 --> 00:03:38,620
precision and you can't use simply float

60
00:03:38,620 --> 00:03:42,370
32 or float so I created a matrix of

61
00:03:42,370 --> 00:03:44,139
three by three you can see that it's a

62
00:03:44,139 --> 00:03:46,180
row major format one two three four five

63
00:03:46,180 --> 00:03:49,269
six and eight nine I and in the next

64
00:03:49,269 --> 00:03:50,919
line of code I just add these two

65
00:03:50,919 --> 00:03:54,780
matrices and in the third line of code I

66
00:03:54,780 --> 00:03:58,949
calculate the determinant of this matrix

67
00:03:58,949 --> 00:04:02,049
next daaru daaru is what pointer is for

68
00:04:02,049 --> 00:04:06,159
a scifi it helps you to load data into a

69
00:04:06,159 --> 00:04:11,229
data into a data frames from say X excel

70
00:04:11,229 --> 00:04:14,680
file or CSV files or PSD files and then

71
00:04:14,680 --> 00:04:18,298
you can analyze this data so in this

72
00:04:18,298 --> 00:04:20,500
code what I've done is that I simply

73
00:04:20,500 --> 00:04:22,590
require daaru in the second line I just

74
00:04:22,590 --> 00:04:26,500
load this data from alien space is dot

75
00:04:26,500 --> 00:04:29,889
CSV and next I do is that I create a

76
00:04:29,889 --> 00:04:33,999
vector and I just I just show this data

77
00:04:33,999 --> 00:04:38,560
frame now next is mixed models so after

78
00:04:38,560 --> 00:04:40,689
you have loaded that data maybe you want

79
00:04:40,689 --> 00:04:43,479
to perform some computations like model

80
00:04:43,479 --> 00:04:45,310
this data so this can be done by mixed

81
00:04:45,310 --> 00:04:51,189
models m and in this code i ice weekly

82
00:04:51,189 --> 00:04:54,490
we try to calculate the fixed effects

83
00:04:54,490 --> 00:04:56,080
and random effects of this model and

84
00:04:56,080 --> 00:04:59,680
this we can also use this to predict for

85
00:04:59,680 --> 00:05:04,689
some random data next is an a float any

86
00:05:04,689 --> 00:05:07,719
scientific library is not successful

87
00:05:07,719 --> 00:05:09,400
unless we have some great visualization

88
00:05:09,400 --> 00:05:14,020
tools nap plots fix this gap for side

89
00:05:14,020 --> 00:05:16,539
ooby it's used for 2d and 3d wave

90
00:05:16,539 --> 00:05:19,449
plotting and it's compared on the top of

91
00:05:19,449 --> 00:05:23,589
d3 next why you should use side would be

92
00:05:23,589 --> 00:05:26,169
instead of SCI pipe simply because we

93
00:05:26,169 --> 00:05:27,819
love Ruby we loved aids and

94
00:05:27,819 --> 00:05:31,930
expressiveness of Ruby you can use when

95
00:05:31,930 --> 00:05:33,789
you collect large amount of data from a

96
00:05:33,789 --> 00:05:35,800
rails app you can just feed this data

97
00:05:35,800 --> 00:05:39,189
into our into a guru data frame and then

98
00:05:39,189 --> 00:05:41,169
you can perform computations and you can

99
00:05:41,169 --> 00:05:45,669
use this that was an analytics tool next

100
00:05:45,669 --> 00:05:48,969
is JRuby my project was to offer jisuk

101
00:05:48,969 --> 00:05:51,479
was to put and matrix to JRuby and

102
00:05:51,479 --> 00:05:54,909
basically sigh ruby was trying to push

103
00:05:54,909 --> 00:05:57,279
push it's gem towards JRuby runtime

104
00:05:57,279 --> 00:06:00,819
because of the speed it's actually 10

105
00:06:00,819 --> 00:06:02,259
times faster than 0 beyond certain

106
00:06:02,259 --> 00:06:04,509
aspects and with truffled ruby it's

107
00:06:04,509 --> 00:06:06,610
around 40 times faster and right now we

108
00:06:06,610 --> 00:06:09,129
just heard that it's gonna be around 26

109
00:06:09,129 --> 00:06:13,560
times faster for just JRuby classic so

110
00:06:13,560 --> 00:06:17,050
this bird I like to call it as the

111
00:06:17,050 --> 00:06:19,000
roadrunner because I'm just dealing with

112
00:06:19,000 --> 00:06:22,240
speed and I want to make this road and I

113
00:06:22,240 --> 00:06:27,909
go beep beep so n matrix for JRuby so n

114
00:06:27,909 --> 00:06:30,789
matrix for y I will build the n matrix

115
00:06:30,789 --> 00:06:33,009
for JRuby because it has no global

116
00:06:33,009 --> 00:06:35,110
interpreter lock as in the case of MRI

117
00:06:35,110 --> 00:06:37,779
so it's a very good team player when you

118
00:06:37,779 --> 00:06:39,639
have a large processor with multi-core

119
00:06:39,639 --> 00:06:42,670
so you can utilize them you can

120
00:06:42,670 --> 00:06:44,710
can the probe the program you developed

121
00:06:44,710 --> 00:06:47,170
can be easily deployed you with the help

122
00:06:47,170 --> 00:06:50,410
of Warbler Jim so you can use you can

123
00:06:50,410 --> 00:06:53,170
develop any gem on JRuby or any program

124
00:06:53,170 --> 00:06:55,180
in JRuby and just deploy it to a

125
00:06:55,180 --> 00:06:57,460
supercomputers or cluster whatever you

126
00:06:57,460 --> 00:07:00,700
have and then JRuby has Auto garbage

127
00:07:00,700 --> 00:07:03,250
collection for whenever you develop a

128
00:07:03,250 --> 00:07:05,410
see extension for C Ruby you have to

129
00:07:05,410 --> 00:07:07,960
take care for garbage collection because

130
00:07:07,960 --> 00:07:10,630
you are dealing with large data and in C

131
00:07:10,630 --> 00:07:12,400
when C Ruby does the mark and sweep

132
00:07:12,400 --> 00:07:15,670
model as we have heard in the previous

133
00:07:15,670 --> 00:07:19,290
talk that this Markin sweep is not

134
00:07:19,290 --> 00:07:21,730
really good to handle and when you have

135
00:07:21,730 --> 00:07:25,150
a very large matrix say 2.5 million

136
00:07:25,150 --> 00:07:28,090
elements in a matrix you can't really

137
00:07:28,090 --> 00:07:33,280
mean speed is a had not good in such

138
00:07:33,280 --> 00:07:33,700
cases

139
00:07:33,700 --> 00:07:36,670
next is the n matrix for JRuby that I

140
00:07:36,670 --> 00:07:38,710
worked on it relies on Apache Commons

141
00:07:38,710 --> 00:07:41,920
map which is a Java library and it has

142
00:07:41,920 --> 00:07:44,110
very high good developer activity around

143
00:07:44,110 --> 00:07:48,330
this library so am da-rae

144
00:07:48,330 --> 00:07:51,130
before we I built and matrix for JRuby

145
00:07:51,130 --> 00:07:54,790
we had MD array that does the this is an

146
00:07:54,790 --> 00:07:57,550
MD array gem that was just like what n

147
00:07:57,550 --> 00:08:01,750
matrix was for C Ruby it was a the n

148
00:08:01,750 --> 00:08:06,370
matrix for a JRuby so when we try to

149
00:08:06,370 --> 00:08:09,250
create a unified interface for n matrix

150
00:08:09,250 --> 00:08:11,110
for Ruby as well as JRuby just like

151
00:08:11,110 --> 00:08:13,630
local nokogiri does it that you have a

152
00:08:13,630 --> 00:08:16,210
simple gem and you can run it on both

153
00:08:16,210 --> 00:08:19,180
instance tanks instances so we could

154
00:08:19,180 --> 00:08:21,550
have used MD array and just built a

155
00:08:21,550 --> 00:08:24,120
wrapper around it for n mate and matrix

156
00:08:24,120 --> 00:08:27,970
but indeed this was this was not going

157
00:08:27,970 --> 00:08:30,910
to be a good idea because it was a it

158
00:08:30,910 --> 00:08:33,460
used parallel called as a dependency

159
00:08:33,460 --> 00:08:35,770
just like I use Apache Commons map and

160
00:08:35,770 --> 00:08:38,500
it was depreciated at the moment and

161
00:08:38,500 --> 00:08:40,990
next is that every gem when you create

162
00:08:40,990 --> 00:08:44,140
with the n matrix you had to replay n--

163
00:08:44,140 --> 00:08:46,900
implement it using MD array if I didn't

164
00:08:46,900 --> 00:08:49,930
build that apparent on MD array so you

165
00:08:49,930 --> 00:08:51,160
have to put in more effort for

166
00:08:51,160 --> 00:08:53,140
optimization for example you have to

167
00:08:53,140 --> 00:08:55,060
check whether the data is not getting

168
00:08:55,060 --> 00:08:56,200
copied

169
00:08:56,200 --> 00:09:00,550
that so how n matrix works basically n

170
00:09:00,550 --> 00:09:03,430
matrix can be divided into categorize

171
00:09:03,430 --> 00:09:04,960
into two parts and dimensional and two

172
00:09:04,960 --> 00:09:10,450
dimensional two dimensional so this is

173
00:09:10,450 --> 00:09:13,150
how you an n matrix object looks like

174
00:09:13,150 --> 00:09:16,300
you have it's a shape that is for

175
00:09:16,300 --> 00:09:18,220
example I created a 3 by 3 matrix it

176
00:09:18,220 --> 00:09:21,550
since she shape is 3 comma 3 it's D type

177
00:09:21,550 --> 00:09:24,060
is float or it can be anything like int

178
00:09:24,060 --> 00:09:26,980
complex like that as type is like

179
00:09:26,980 --> 00:09:29,290
whether you want you want to store it as

180
00:09:29,290 --> 00:09:31,890
a dense made matrix or a sparse matrix

181
00:09:31,890 --> 00:09:35,260
at S is basically the storage the

182
00:09:35,260 --> 00:09:37,960
elements that go into a matrix now you

183
00:09:37,960 --> 00:09:41,980
have that demon atom this means that how

184
00:09:41,980 --> 00:09:44,110
many dimensions you have for example 3

185
00:09:44,110 --> 00:09:46,470
comma 3 is our two-dimensional matrix

186
00:09:46,470 --> 00:09:50,290
next is n matrix architecture basically

187
00:09:50,290 --> 00:09:53,800
we have a ruby front ender then we have

188
00:09:53,800 --> 00:09:55,450
for MRI we have a shared object

189
00:09:55,450 --> 00:09:59,020
extension dot s o which is built using C

190
00:09:59,020 --> 00:09:59,770
and C++

191
00:09:59,770 --> 00:10:03,190
now this integrates with n matrix C C

192
00:10:03,190 --> 00:10:05,050
library ok sorry

193
00:10:05,050 --> 00:10:07,390
native C library which are C blast OC

194
00:10:07,390 --> 00:10:11,380
lapak and this C this C legacy libraries

195
00:10:11,380 --> 00:10:14,410
could address connected to the Fortran

196
00:10:14,410 --> 00:10:19,150
library that's blasts and lapak so

197
00:10:19,150 --> 00:10:21,790
basically you have three layers and this

198
00:10:21,790 --> 00:10:24,670
one the Fortran library makes is what

199
00:10:24,670 --> 00:10:28,000
mixes computation go fast for JRuby we

200
00:10:28,000 --> 00:10:31,480
have just extends in Georgia it it's

201
00:10:31,480 --> 00:10:35,880
built upon the top of Apache Commons map

202
00:10:35,880 --> 00:10:41,710
so for n dimensional matrix the major

203
00:10:41,710 --> 00:10:44,200
thing operator we had to build on it was

204
00:10:44,200 --> 00:10:47,140
element wise operation for example add

205
00:10:47,140 --> 00:10:49,510
subtract sine or gamma and the first

206
00:10:49,510 --> 00:10:51,940
slide where we added two matrixes this

207
00:10:51,940 --> 00:10:53,800
was just going an element-wise operation

208
00:10:53,800 --> 00:10:56,140
we iterate through the elements we

209
00:10:56,140 --> 00:10:57,670
access the element do the operation and

210
00:10:57,670 --> 00:11:00,190
return it so the major thing that counts

211
00:11:00,190 --> 00:11:02,440
there is you have your loops should be

212
00:11:02,440 --> 00:11:04,450
efficient means you can iterate through

213
00:11:04,450 --> 00:11:07,360
throughout the array and whichever is

214
00:11:07,360 --> 00:11:11,220
the first means whether C Ruby

215
00:11:11,220 --> 00:11:14,379
so here in this slide I show you that

216
00:11:14,379 --> 00:11:17,649
when I created a matrix n1 and I just

217
00:11:17,649 --> 00:11:20,500
add them so n1 plus n1 you get this

218
00:11:20,500 --> 00:11:22,810
matrix for example one plus one gets 2 2

219
00:11:22,810 --> 00:11:26,019
plus 2 4 next what were the challenges

220
00:11:26,019 --> 00:11:26,980
that we faced

221
00:11:26,980 --> 00:11:29,800
first is autoboxing and multiple data

222
00:11:29,800 --> 00:11:31,540
and handling multiple data types

223
00:11:31,540 --> 00:11:34,889
second is minimizing the copying of data

224
00:11:34,889 --> 00:11:39,220
so in JRuby we had this that when when

225
00:11:39,220 --> 00:11:42,009
we tried no strict typing basically die

226
00:11:42,009 --> 00:11:46,209
to die locating a data using JRuby code

227
00:11:46,209 --> 00:11:48,490
we got this error for example in this

228
00:11:48,490 --> 00:11:51,129
case we have an error two arrays we just

229
00:11:51,129 --> 00:11:53,199
add it and if this array is smaller than

230
00:11:53,199 --> 00:11:56,790
one you start getting the values as 0 so

231
00:11:56,790 --> 00:11:59,889
I think Charles will answering can

232
00:11:59,889 --> 00:12:01,720
answer me this question after this talk

233
00:12:01,720 --> 00:12:06,579
and and if I just simply add this any

234
00:12:06,579 --> 00:12:09,579
number greater than 1 to both of them

235
00:12:09,579 --> 00:12:12,220
and I subtract minus 10 so I get the

236
00:12:12,220 --> 00:12:18,550
correct result a next is autoboxing

237
00:12:18,550 --> 00:12:24,430
so what we did was a weekly I in the as

238
00:12:24,430 --> 00:12:26,170
this project was in initial stage I just

239
00:12:26,170 --> 00:12:28,509
did with the float64 that is doubles

240
00:12:28,509 --> 00:12:30,600
only because we had to deal with

241
00:12:30,600 --> 00:12:34,720
reflection and and that's what then

242
00:12:34,720 --> 00:12:36,910
forced it there we created datatypes

243
00:12:36,910 --> 00:12:38,680
using Java and we couldn't rely on

244
00:12:38,680 --> 00:12:41,079
reflection for large data for example if

245
00:12:41,079 --> 00:12:43,420
you create storage as a de dot new and

246
00:12:43,420 --> 00:12:45,970
storage a Java double with rows and

247
00:12:45,970 --> 00:12:48,370
columns or new second one it will be

248
00:12:48,370 --> 00:12:50,519
definitely faster because you know the

249
00:12:50,519 --> 00:12:54,160
size of the array and you can move

250
00:12:54,160 --> 00:12:56,319
faster through through this the second

251
00:12:56,319 --> 00:12:58,439
area

252
00:12:58,790 --> 00:13:01,370
so now we have auto boxing and

253
00:13:01,370 --> 00:13:03,100
enumerators this is a classic case

254
00:13:03,100 --> 00:13:06,260
because when we tried using an matrix

255
00:13:06,260 --> 00:13:08,029
for JRuby for real data for example we

256
00:13:08,029 --> 00:13:12,019
have a 5 point 5 GB 5 GB of data which

257
00:13:12,019 --> 00:13:14,930
we get from a blob and when we try to

258
00:13:14,930 --> 00:13:17,690
run it we get an error here you can see

259
00:13:17,690 --> 00:13:19,579
this highlighted code I just created

260
00:13:19,579 --> 00:13:21,980
this array as array dot new so what

261
00:13:21,980 --> 00:13:23,510
happens is that you start losing

262
00:13:23,510 --> 00:13:26,630
precision so if you just implement this

263
00:13:26,630 --> 00:13:30,920
in using Java in Java code so here you

264
00:13:30,920 --> 00:13:34,190
don't lose precision next is minimizing

265
00:13:34,190 --> 00:13:37,310
the copying of data as we had heard in

266
00:13:37,310 --> 00:13:39,560
the previous charger previous talk some

267
00:13:39,560 --> 00:13:47,768
charge that JRuby takes more memory yeah

268
00:13:48,190 --> 00:13:51,199
so basically what we are trying to do is

269
00:13:51,199 --> 00:13:53,360
we take the storage we are trying to

270
00:13:53,360 --> 00:13:56,570
build an enumerated enumerated that each

271
00:13:56,570 --> 00:13:58,699
within deck we have to get elements by

272
00:13:58,699 --> 00:14:01,339
defined by indices and if there are

273
00:14:01,339 --> 00:14:03,649
blocks pass I just want to do some

274
00:14:03,649 --> 00:14:06,649
computation with it so I just convert

275
00:14:06,649 --> 00:14:08,779
this storage to an array and then I take

276
00:14:08,779 --> 00:14:11,389
the slice index and I try to push it in

277
00:14:11,389 --> 00:14:13,519
this array and here we start losing

278
00:14:13,519 --> 00:14:16,250
values for example if we had the we were

279
00:14:16,250 --> 00:14:19,639
trying to kill to factorize a matrix so

280
00:14:19,639 --> 00:14:21,949
every time you do it if the value is

281
00:14:21,949 --> 00:14:26,360
0.02 or 0.03 this gets to zero and when

282
00:14:26,360 --> 00:14:28,250
when this when you are trying to

283
00:14:28,250 --> 00:14:30,829
optimize something and you have to

284
00:14:30,829 --> 00:14:33,199
iterate through this matrix you have to

285
00:14:33,199 --> 00:14:34,819
perform the same computation through

286
00:14:34,819 --> 00:14:38,269
this matrix it won't get optimized ever

287
00:14:38,269 --> 00:14:42,319
because you can't just go to a silk a

288
00:14:42,319 --> 00:14:44,630
convex point where the data where this

289
00:14:44,630 --> 00:14:47,269
value converges so you can't reach a

290
00:14:47,269 --> 00:14:49,600
minima

291
00:14:49,930 --> 00:14:52,450
so next is minimizing the copying of

292
00:14:52,450 --> 00:14:56,589
data so whenever you build a JRuby

293
00:14:56,589 --> 00:14:58,120
application you make sure that you don't

294
00:14:58,120 --> 00:15:00,880
make copies of data because already it

295
00:15:00,880 --> 00:15:03,220
it consumes twice the memory than C Ruby

296
00:15:03,220 --> 00:15:07,210
so if you start the making more copies

297
00:15:07,210 --> 00:15:09,490
and you have a larger matrix It's Made

298
00:15:09,490 --> 00:15:13,779
totally make destroy your GGC for

299
00:15:13,779 --> 00:15:16,450
example there was a computation where

300
00:15:16,450 --> 00:15:19,270
see Ruby takes around 50 seconds and

301
00:15:19,270 --> 00:15:22,060
when I was just building n matrix for

302
00:15:22,060 --> 00:15:27,460
JRuby it took me around 1.5 hours so so

303
00:15:27,460 --> 00:15:29,680
after I made sure that I am not making

304
00:15:29,680 --> 00:15:32,260
copies of data I took down this time to

305
00:15:32,260 --> 00:15:34,589
40 seconds which was better than C Ruby

306
00:15:34,589 --> 00:15:37,390
so you just pass by your friends you

307
00:15:37,390 --> 00:15:39,610
just create a static method as helpers

308
00:15:39,610 --> 00:15:44,170
for happy to see this example example

309
00:15:44,170 --> 00:15:46,839
later so next is 2-dimensional matrix

310
00:15:46,839 --> 00:15:49,150
now you have an end M dimensional matrix

311
00:15:49,150 --> 00:15:51,330
and you want to perform certain

312
00:15:51,330 --> 00:15:53,890
computations like you need to multiply

313
00:15:53,890 --> 00:15:56,910
two matrices or you need to factorize it

314
00:15:56,910 --> 00:15:59,980
then we use two we need to just cast

315
00:15:59,980 --> 00:16:01,930
this one dimensional n dimensional

316
00:16:01,930 --> 00:16:05,770
matrix into a two dimension matrix so

317
00:16:05,770 --> 00:16:09,459
the basic operations here are dot which

318
00:16:09,459 --> 00:16:11,529
is matrix multiplication our date for

319
00:16:11,529 --> 00:16:12,640
the calculating determinant and

320
00:16:12,640 --> 00:16:14,830
factorize Lu means lower upper

321
00:16:14,830 --> 00:16:19,300
factorization so in n matrix MRI we have

322
00:16:19,300 --> 00:16:21,250
Blast 3 and lapak routines that are

323
00:16:21,250 --> 00:16:24,820
built in Fortran but n matrix JRuby was

324
00:16:24,820 --> 00:16:27,370
the means it depends on Java functions

325
00:16:27,370 --> 00:16:31,600
from Apache Commons Matz so the

326
00:16:31,600 --> 00:16:33,580
challenges were as follows

327
00:16:33,580 --> 00:16:36,070
you convert an N dimensional matrix into

328
00:16:36,070 --> 00:16:38,500
a two dimensional matrix so actually n

329
00:16:38,500 --> 00:16:40,150
dimensional matrix is stored as a 1d

330
00:16:40,150 --> 00:16:42,130
array because you can't just simply

331
00:16:42,130 --> 00:16:44,800
store create a multi-dimensional array

332
00:16:44,800 --> 00:16:47,170
because you can't just lay down them in

333
00:16:47,170 --> 00:16:50,260
the RAM properly now you have the array

334
00:16:50,260 --> 00:16:52,120
size matters and you have to access the

335
00:16:52,120 --> 00:16:55,180
elements with speed and you have to also

336
00:16:55,180 --> 00:16:59,350
take memory in consideration so we have

337
00:16:59,350 --> 00:17:02,860
an n matrix I have to I need to get a 2d

338
00:17:02,860 --> 00:17:03,750
matrix from

339
00:17:03,750 --> 00:17:06,390
so I used this helper functions these

340
00:17:06,390 --> 00:17:08,550
are static methods for from a matrix in

341
00:17:08,550 --> 00:17:10,800
little class called get matrix double

342
00:17:10,800 --> 00:17:12,900
and the original class has a get era

343
00:17:12,900 --> 00:17:18,000
double so in this code I'm trying to

344
00:17:18,000 --> 00:17:21,300
iterate over a matrix means basically a

345
00:17:21,300 --> 00:17:23,520
two-dimensional array so I just

346
00:17:23,520 --> 00:17:25,859
benchmark this Ruby code you can see

347
00:17:25,859 --> 00:17:29,300
that idea in the the first line of code

348
00:17:29,300 --> 00:17:30,510
sorry

349
00:17:30,510 --> 00:17:35,850
we have we created Java basically a two

350
00:17:35,850 --> 00:17:38,190
dimensional matrix of size 15,000 15,000

351
00:17:38,190 --> 00:17:41,640
so basically and I just benchmark this

352
00:17:41,640 --> 00:17:45,270
code where I place I initialize the

353
00:17:45,270 --> 00:17:48,450
value of this matrix as the index so

354
00:17:48,450 --> 00:17:52,440
this takes me around 39 seconds and then

355
00:17:52,440 --> 00:17:54,300
next I get read over two arrays where I

356
00:17:54,300 --> 00:17:57,270
just copy the elements of one one array

357
00:17:57,270 --> 00:17:59,970
into another so this takes me around

358
00:17:59,970 --> 00:18:02,340
sixty five point one one two seconds and

359
00:18:02,340 --> 00:18:06,720
five point four GB of RAM so maybe so

360
00:18:06,720 --> 00:18:08,940
when you have such large matrix your Ram

361
00:18:08,940 --> 00:18:10,830
your CPA your Ram will be a basic

362
00:18:10,830 --> 00:18:12,870
quantity consumed by that time and you

363
00:18:12,870 --> 00:18:14,880
can't do it for any number crunching to

364
00:18:14,880 --> 00:18:21,510
sort program so yes so and I do this

365
00:18:21,510 --> 00:18:25,650
similar thing in Java and I get for this

366
00:18:25,650 --> 00:18:28,170
again that time requires 0.03 one

367
00:18:28,170 --> 00:18:30,600
seconds and for the when we have two

368
00:18:30,600 --> 00:18:32,190
arrays I it takes zero point zero zero

369
00:18:32,190 --> 00:18:34,710
three zero three three seconds and that

370
00:18:34,710 --> 00:18:38,880
I am consumed is 300 MB hence speed is

371
00:18:38,880 --> 00:18:40,350
include thousand times and memories

372
00:18:40,350 --> 00:18:43,500
improved ten times and this is actually

373
00:18:43,500 --> 00:18:46,830
speed y is better than C Ruby but memory

374
00:18:46,830 --> 00:18:50,340
Y is not as good as C Ruby its 0 C ruby

375
00:18:50,340 --> 00:18:53,160
has better takes less memory but speed

376
00:18:53,160 --> 00:18:58,190
is slower next

377
00:18:58,259 --> 00:19:01,389
yeah fifteen thousand into fifteen

378
00:19:01,389 --> 00:19:06,059
thousand which is 225 million elements

379
00:19:06,359 --> 00:19:10,059
so there's another gem mixed murders

380
00:19:10,059 --> 00:19:13,299
that relied on n matrix and simply by

381
00:19:13,299 --> 00:19:15,909
putting n matrix I just putted this

382
00:19:15,909 --> 00:19:21,219
library to JRuby to and so you can model

383
00:19:21,219 --> 00:19:25,899
your data in the JRuby now well now

384
00:19:25,899 --> 00:19:29,459
we've benchmark n matrix functionalities

385
00:19:29,459 --> 00:19:31,299
how these are the system is

386
00:19:31,299 --> 00:19:33,669
specifications we I I had an octa-core

387
00:19:33,669 --> 00:19:39,129
CPU and a 16gb ram next forum in this

388
00:19:39,129 --> 00:19:40,569
club you can see that the number of

389
00:19:40,569 --> 00:19:43,179
elements in a matrix this is for example

390
00:19:43,179 --> 00:19:45,009
fifty-five thousand by five thousand

391
00:19:45,009 --> 00:19:48,459
elements we have 25 million elements in

392
00:19:48,459 --> 00:19:51,609
a matrix and then the on the y-axis you

393
00:19:51,609 --> 00:19:53,859
can see the computation time so let's

394
00:19:53,859 --> 00:19:55,869
say the computer computation time the

395
00:19:55,869 --> 00:19:58,569
better the speed so this is a

396
00:19:58,569 --> 00:20:01,359
logarithmic scale so in this case n

397
00:20:01,359 --> 00:20:03,699
matrix JRuby is faster than n matrix MRI

398
00:20:03,699 --> 00:20:08,159
it is around sixteen forty times faster

399
00:20:08,159 --> 00:20:11,229
next for subtraction we have the same

400
00:20:11,229 --> 00:20:14,949
case it's a forty times faster next for

401
00:20:14,949 --> 00:20:17,499
gamma we have this we compare three n

402
00:20:17,499 --> 00:20:19,869
matrix MRI then n matrix JRuby and n

403
00:20:19,869 --> 00:20:22,899
matrix MRI lapack you can see that on n

404
00:20:22,899 --> 00:20:24,789
matrix J rube it's even faster than the

405
00:20:24,789 --> 00:20:29,079
Fortran code and it's a lot faster means

406
00:20:29,079 --> 00:20:32,199
it's ten times faster than n matrix MRI

407
00:20:32,199 --> 00:20:37,059
and MRI lapak and for four hundred times

408
00:20:37,059 --> 00:20:42,179
fast faster than this n matrix MRIs for

409
00:20:42,179 --> 00:20:45,939
n matrix for matrix multiplication n

410
00:20:45,939 --> 00:20:50,259
matrix JRuby losses to n matrix C Ruby

411
00:20:50,259 --> 00:20:53,669
or MRI because we definitely don't have

412
00:20:53,669 --> 00:20:57,189
Fortran libraries for this and so any

413
00:20:57,189 --> 00:20:59,499
code any Java code can never build a

414
00:20:59,499 --> 00:21:03,279
Fortran code even though we have jetting

415
00:21:03,279 --> 00:21:06,159
and this code will will get improved

416
00:21:06,159 --> 00:21:07,929
after running a lot of loops but still

417
00:21:07,929 --> 00:21:10,600
not get better than Fortran

418
00:21:10,600 --> 00:21:14,110
similarly for determinants it's again 20

419
00:21:14,110 --> 00:21:17,860
times fluid for factorization it's same

420
00:21:17,860 --> 00:21:20,710
20 times sewer so these are the

421
00:21:20,710 --> 00:21:23,650
benchmark conclusions and matrix JRuby

422
00:21:23,650 --> 00:21:25,270
is definitely faster for n dimensional

423
00:21:25,270 --> 00:21:27,760
matrices and 2 dimensional matrices when

424
00:21:27,760 --> 00:21:29,670
element wise operations are concerned

425
00:21:29,670 --> 00:21:33,880
but n matrix MRI is faster for 2

426
00:21:33,880 --> 00:21:36,400
dimensional matrices when you need to

427
00:21:36,400 --> 00:21:39,910
calculate the dot or determinant or you

428
00:21:39,910 --> 00:21:42,700
need to factorize it so how can we

429
00:21:42,700 --> 00:21:46,990
improve this so the solution is that we

430
00:21:46,990 --> 00:21:50,530
also implement the back end of n matrix

431
00:21:50,530 --> 00:21:54,070
jruby with Fortran and this time it will

432
00:21:54,070 --> 00:21:57,280
rely on rely on Java netic in native

433
00:21:57,280 --> 00:22:00,790
interfaces and there was an option to

434
00:22:00,790 --> 00:22:04,060
use another library called J blast which

435
00:22:04,060 --> 00:22:06,160
has which is a j'ni for blast libraries

436
00:22:06,160 --> 00:22:08,410
and lapak libraries but when I try to

437
00:22:08,410 --> 00:22:12,810
use them it was it had a lot of bugs and

438
00:22:12,810 --> 00:22:18,090
it was not it was not efficient enough

439
00:22:18,090 --> 00:22:20,680
so this would be the final arguing

440
00:22:20,680 --> 00:22:23,650
architecture of n matrix JRuby so we

441
00:22:23,650 --> 00:22:27,100
took this left side of this diagram to

442
00:22:27,100 --> 00:22:29,710
this right side and overall when we do

443
00:22:29,710 --> 00:22:34,090
this when I try to do a sample bench map

444
00:22:34,090 --> 00:22:36,820
for this it was actually faster than n

445
00:22:36,820 --> 00:22:40,630
matrix MRI so maybe in two months

446
00:22:40,630 --> 00:22:43,420
n matrix JRuby would be faster on all

447
00:22:43,420 --> 00:22:46,480
aspects than n matrix MRI when I

448
00:22:46,480 --> 00:22:50,190
implement this part of the code

449
00:22:50,190 --> 00:22:52,810
so also the future work includes

450
00:22:52,810 --> 00:22:54,850
implementing n matrix of complex data

451
00:22:54,850 --> 00:22:58,710
type and adding space support and

452
00:22:58,710 --> 00:23:01,450
convert n matrix J to be enumerators to

453
00:23:01,450 --> 00:23:06,400
Java code for better speed so over all

454
00:23:06,400 --> 00:23:10,270
whenever you try to do n make any n

455
00:23:10,270 --> 00:23:12,850
matrix any computation using n matrix

456
00:23:12,850 --> 00:23:16,360
JRuby it would be currently as far as n

457
00:23:16,360 --> 00:23:18,670
matrix a see Ruby or even some times

458
00:23:18,670 --> 00:23:22,090
faster because the overall calculations

459
00:23:22,090 --> 00:23:24,959
that rely on

460
00:23:25,170 --> 00:23:27,790
it's not a single dimension that would

461
00:23:27,790 --> 00:23:31,270
be faster in case of JRuby and obviously

462
00:23:31,270 --> 00:23:33,120
JIT so am I done

463
00:23:33,120 --> 00:23:42,250
nope inter GPU so the google Summer of

464
00:23:42,250 --> 00:23:45,640
Code I wanted to the to go even faster

465
00:23:45,640 --> 00:23:48,820
for number crunching and that's why I

466
00:23:48,820 --> 00:23:53,170
thought of implementing GPGPU library a

467
00:23:53,170 --> 00:23:55,150
general-purpose library for GP

468
00:23:55,150 --> 00:23:57,460
computations and the aim of this project

469
00:23:57,460 --> 00:23:59,620
was to combine the beauty of ruby with

470
00:23:59,620 --> 00:24:02,380
transparent GPU processing and yes this

471
00:24:02,380 --> 00:24:04,180
will be tested on both client computers

472
00:24:04,180 --> 00:24:06,040
and on servers that make use of tesla's

473
00:24:06,040 --> 00:24:10,000
and Intel Xeon Phi solutions before this

474
00:24:10,000 --> 00:24:14,590
and there was no Ruby project that used

475
00:24:14,590 --> 00:24:17,260
AG that was good for GPU computation

476
00:24:17,260 --> 00:24:21,220
maximum you could do was add two

477
00:24:21,220 --> 00:24:24,250
matrices using GPU and that also

478
00:24:24,250 --> 00:24:28,690
personal 4000-5000 matrix but yes the

479
00:24:28,690 --> 00:24:31,420
area fire liability that RB library that

480
00:24:31,420 --> 00:24:33,910
I develop can handle around fifteen

481
00:24:33,910 --> 00:24:36,670
thousand to fifteen thousand elements

482
00:24:36,670 --> 00:24:39,190
matrix easily and we are they get to

483
00:24:39,190 --> 00:24:45,220
test it on supercomputers so what is

484
00:24:45,220 --> 00:24:47,860
edified actually so era fire is an open

485
00:24:47,860 --> 00:24:49,900
source GPGPU library that is written in

486
00:24:49,900 --> 00:24:53,560
c++ and usage it so you using a jet

487
00:24:53,560 --> 00:24:55,180
makes it even faster than CUDA and

488
00:24:55,180 --> 00:24:58,480
OpenCL so yes the competitors PI CUDA

489
00:24:58,480 --> 00:25:00,850
and PI opencl would be slower than a

490
00:25:00,850 --> 00:25:05,130
defier RB era fire era fire has also

491
00:25:05,130 --> 00:25:08,650
bindings to Python but era fire fire

492
00:25:08,650 --> 00:25:12,450
python is built using sia siphon so

493
00:25:12,450 --> 00:25:15,490
whenever you try to do this this code is

494
00:25:15,490 --> 00:25:18,130
really not tested and try to do some

495
00:25:18,130 --> 00:25:20,140
computations using adapt fire Python on

496
00:25:20,140 --> 00:25:22,780
my system and actually most of the times

497
00:25:22,780 --> 00:25:25,930
the program hang so and when I did the

498
00:25:25,930 --> 00:25:27,490
same thing with era fire Ruby when I

499
00:25:27,490 --> 00:25:31,600
built it for MRI it was it was it was

500
00:25:31,600 --> 00:25:35,280
working properly and and the speed was

501
00:25:35,280 --> 00:25:37,870
awesome

502
00:25:37,870 --> 00:25:42,880
next is a defier Ruby can also help you

503
00:25:42,880 --> 00:25:47,740
to just go and go computing without

504
00:25:47,740 --> 00:25:50,650
writing kernels so whenever you try to

505
00:25:50,650 --> 00:25:52,420
do GPU computing most other times you

506
00:25:52,420 --> 00:25:54,970
end up writing kernels and this is a

507
00:25:54,970 --> 00:25:58,090
this is where most people just lay GPU

508
00:25:58,090 --> 00:26:01,300
computing but in era file you you just

509
00:26:01,300 --> 00:26:03,040
have a ready-made formulas and it can

510
00:26:03,040 --> 00:26:04,720
handle matrices of any size it

511
00:26:04,720 --> 00:26:08,620
automatically scales so how do you use a

512
00:26:08,620 --> 00:26:10,360
defier Ruby

513
00:26:10,360 --> 00:26:12,760
so you just in the first line of code I

514
00:26:12,760 --> 00:26:15,640
just created a and verified matrix it's

515
00:26:15,640 --> 00:26:18,340
a two dimensional and two rows and two

516
00:26:18,340 --> 00:26:21,910
columns I just add these two and in the

517
00:26:21,910 --> 00:26:23,590
next hash I show you the how Wade

518
00:26:23,590 --> 00:26:25,200
implemented Blas routine where I

519
00:26:25,200 --> 00:26:29,590
multiply two matrices and then the third

520
00:26:29,590 --> 00:26:31,620
the third part of the code shows how to

521
00:26:31,620 --> 00:26:36,910
get the determinant of a matrix for so

522
00:26:36,910 --> 00:26:40,450
let's see how the it's a fire Ruby's

523
00:26:40,450 --> 00:26:44,230
built for MRI it's a C extension and it

524
00:26:44,230 --> 00:26:46,090
on the architecture is inspired by n

525
00:26:46,090 --> 00:26:48,850
matrix in an array basically basically a

526
00:26:48,850 --> 00:26:51,580
defier is written in c plus fist so when

527
00:26:51,580 --> 00:26:54,390
we try to build this library we need to

528
00:26:54,390 --> 00:26:58,900
handle C++ code so for that the recent

529
00:26:58,900 --> 00:27:00,790
instructions help you out you can do it

530
00:27:00,790 --> 00:27:04,060
and the most point the important point

531
00:27:04,060 --> 00:27:05,860
to note here is that you just get rid of

532
00:27:05,860 --> 00:27:10,900
this mangling errors in C++ for example

533
00:27:10,900 --> 00:27:13,090
this is how I implemented matrix

534
00:27:13,090 --> 00:27:15,760
multiplication I just included Ruby dot

535
00:27:15,760 --> 00:27:18,420
H and I created that data structure for

536
00:27:18,420 --> 00:27:24,100
a verifier esterified object then I then

537
00:27:24,100 --> 00:27:26,860
I just bind it to Ruby fronting in Anita

538
00:27:26,860 --> 00:27:30,100
River I create a function called a RF

539
00:27:30,100 --> 00:27:33,070
madman so this is being casted here

540
00:27:33,070 --> 00:27:36,550
because this is being this code is in is

541
00:27:36,550 --> 00:27:38,890
in is actually in a CPP file and what

542
00:27:38,890 --> 00:27:41,620
Ruby front-end expects it is to be a

543
00:27:41,620 --> 00:27:46,690
nurse C 5 so and next I do do an ER of

544
00:27:46,690 --> 00:27:48,970
mad Mel so this this finally goes to

545
00:27:48,970 --> 00:27:50,480
this line of code

546
00:27:50,480 --> 00:27:55,460
I just multiply it here you can see that

547
00:27:55,460 --> 00:27:59,179
I this line this line is for when

548
00:27:59,179 --> 00:28:01,309
whenever a GP computation is done is

549
00:28:01,309 --> 00:28:03,799
done on a GPU Ram so you need to get

550
00:28:03,799 --> 00:28:08,149
this memory into the CPU Ram so the this

551
00:28:08,149 --> 00:28:10,730
line helps you to do this so when when

552
00:28:10,730 --> 00:28:13,039
we try to integrate arrow fire with rays

553
00:28:13,039 --> 00:28:15,619
this line would be very helpful and you

554
00:28:15,619 --> 00:28:18,080
may be wondering that why jeep the GPU

555
00:28:18,080 --> 00:28:20,629
computing on Rails because you have data

556
00:28:20,629 --> 00:28:22,519
means you collect data through active

557
00:28:22,519 --> 00:28:26,590
records and now you can just analyze it

558
00:28:26,590 --> 00:28:29,090
fudge it would be the app and that which

559
00:28:29,090 --> 00:28:32,389
is same as n matrix JRuby we had the a

560
00:28:32,389 --> 00:28:34,309
Java native interface for arif I'd

561
00:28:34,309 --> 00:28:37,700
already built and I'm even I implemented

562
00:28:37,700 --> 00:28:39,909
some of the blast and lapak routines

563
00:28:39,909 --> 00:28:45,169
these this works on a defier Java what

564
00:28:45,169 --> 00:28:47,840
your father for example the last example

565
00:28:47,840 --> 00:28:49,759
we saw we saw where they did matrix

566
00:28:49,759 --> 00:28:52,039
multiplication is C code this can be

567
00:28:52,039 --> 00:28:54,859
easily implemented in JRuby just using

568
00:28:54,859 --> 00:28:57,590
this part of code so here you can see

569
00:28:57,590 --> 00:29:00,070
that or some jail rubies

570
00:29:00,070 --> 00:29:05,299
now we benchmark array fire the system

571
00:29:05,299 --> 00:29:07,820
is specifications are as follows we have

572
00:29:07,820 --> 00:29:09,769
same octa-core processor with first 60

573
00:29:09,769 --> 00:29:13,609
GB of RAM and GPU was JT and VTR gtx

574
00:29:13,609 --> 00:29:14,269
750ti

575
00:29:14,269 --> 00:29:19,369
and ram is 4 gb dereference so for in

576
00:29:19,369 --> 00:29:21,350
this you can i think you can see it here

577
00:29:21,350 --> 00:29:24,919
and this is around 10 days to power five

578
00:29:24,919 --> 00:29:28,460
times faster than n matrix Ruby and ten

579
00:29:28,460 --> 00:29:29,960
use to power four times faster than n

580
00:29:29,960 --> 00:29:34,519
matrix JRuby and again Arif I this

581
00:29:34,519 --> 00:29:37,159
faster even here it's around 10 days to

582
00:29:37,159 --> 00:29:40,330
power 6 times faster

583
00:29:40,500 --> 00:29:44,590
one matrix determinant it's around 100

584
00:29:44,590 --> 00:29:48,160
times faster even for factorization its

585
00:29:48,160 --> 00:29:53,760
era 500 times faster so transparency

586
00:29:53,760 --> 00:29:57,730
after actually the current here when you

587
00:29:57,730 --> 00:30:00,370
find we try to find era fire on guitar

588
00:30:00,370 --> 00:30:02,380
you will care you can see the code for

589
00:30:02,380 --> 00:30:06,490
actual written only for MRI for JRuby I

590
00:30:06,490 --> 00:30:08,350
I have already done the groundwork it

591
00:30:08,350 --> 00:30:10,210
just needs to be in the wraparound upon

592
00:30:10,210 --> 00:30:24,790
oh okay maybe thousand times faster so

593
00:30:24,790 --> 00:30:28,000
transparency we need to integrate it

594
00:30:28,000 --> 00:30:29,920
with an array and n matrix and with

595
00:30:29,920 --> 00:30:32,800
rails so the where I showed you that

596
00:30:32,800 --> 00:30:36,910
just you just copied us ran from GPU to

597
00:30:36,910 --> 00:30:39,910
CPU you can just create some function

598
00:30:39,910 --> 00:30:43,240
methods for that and we and yes rails is

599
00:30:43,240 --> 00:30:47,110
now on GPGPU and similarly as any array

600
00:30:47,110 --> 00:30:49,660
and n matrix so what are the

601
00:30:49,660 --> 00:30:53,350
applications actually a defier has

602
00:30:53,350 --> 00:30:57,250
endless applications you can use it for

603
00:30:57,250 --> 00:30:59,710
bioinformatics you can integrate it with

604
00:30:59,710 --> 00:31:02,020
tensor flow when it's ready so you can

605
00:31:02,020 --> 00:31:04,120
just create a GPU cluster using air

606
00:31:04,120 --> 00:31:05,740
afire and integrate it with tensor flow

607
00:31:05,740 --> 00:31:08,080
you can use it for image processing you

608
00:31:08,080 --> 00:31:10,030
can use it for computational food than a

609
00:31:10,030 --> 00:31:16,150
few dynamics so hence baby these are the

610
00:31:16,150 --> 00:31:18,760
useful links you can go to for n matrix

611
00:31:18,760 --> 00:31:23,140
infinity and a defier RBZ and the latest

612
00:31:23,140 --> 00:31:28,210
code can be found on arafat temp temp

613
00:31:28,210 --> 00:31:32,530
ranch i would like to acknowledge my

614
00:31:32,530 --> 00:31:34,780
mentor George Evans and Charles Nutter

615
00:31:34,780 --> 00:31:37,180
and John woods for who have been very

616
00:31:37,180 --> 00:31:39,700
helpful to me in creating this these

617
00:31:39,700 --> 00:31:42,340
libraries both era fire and n matrix

618
00:31:42,340 --> 00:31:45,730
next is Alexson Gossman who's who

619
00:31:45,730 --> 00:31:48,400
developed the mixed model gen some Mead

620
00:31:48,400 --> 00:31:51,100
he's the developer he developed Darwin

621
00:31:51,100 --> 00:31:52,210
and

622
00:31:52,210 --> 00:31:55,300
we have got agita tea from the era

623
00:31:55,300 --> 00:31:55,930
fireteam

624
00:31:55,930 --> 00:31:58,650
he's also mentoring me with this project

625
00:31:58,650 --> 00:32:01,540
so also I'd like I would like to thank

626
00:32:01,540 --> 00:32:04,120
emerging technology trust that is the

627
00:32:04,120 --> 00:32:05,950
organized organizer of rubyconf india

628
00:32:05,950 --> 00:32:08,980
and currently they have sponsored my

629
00:32:08,980 --> 00:32:42,480
travel for what n matrix odd

630
00:32:51,420 --> 00:32:55,270
see your question is basically that I

631
00:32:55,270 --> 00:32:58,330
need to send the values to more than one

632
00:32:58,330 --> 00:33:01,290
course for processing right so basically

633
00:33:01,290 --> 00:33:05,590
this firm where for n matrix it is done

634
00:33:05,590 --> 00:33:08,560
by Fortran and Fortran is already

635
00:33:08,560 --> 00:33:10,480
optimized for this it lays down membrane

636
00:33:10,480 --> 00:33:12,790
certain way that it uses parallelism for

637
00:33:12,790 --> 00:33:16,900
that so yes it's done by that way and a

638
00:33:16,900 --> 00:33:24,310
Java code can't beat that qu processor

639
00:33:24,310 --> 00:33:27,500
instructions created by that after the

640
00:33:27,500 --> 00:33:30,380
was defined the first run by bizarre

641
00:33:30,380 --> 00:33:35,330
video for that usually you have no true

642
00:33:35,330 --> 00:33:37,580
libraries in C++ that are able to do

643
00:33:37,580 --> 00:33:39,770
them because the amount of the processor

644
00:33:39,770 --> 00:33:42,200
was built the name of those lighters are

645
00:33:42,200 --> 00:33:45,860
VC and most simply okay you should want

646
00:33:45,860 --> 00:33:47,810
to take a look on them later okay

647
00:33:47,810 --> 00:33:50,690
and there is also one library that I

648
00:33:50,690 --> 00:33:53,270
helped to write for matrix processing

649
00:33:53,270 --> 00:33:57,730
may be an eigen tree that's really fast

650
00:33:57,730 --> 00:34:01,040
you've seen this for hard I can reach

651
00:34:01,040 --> 00:34:04,370
for a higher rate sorry I can 3 is for

652
00:34:04,370 --> 00:34:09,020
our card language right okay but are

653
00:34:09,020 --> 00:34:14,449
using it mostly RC ppin are eigen so

654
00:34:14,449 --> 00:34:16,610
yeah I think that slower than Lopakhin

655
00:34:16,610 --> 00:34:22,330
blasts okay next question

656
00:34:26,980 --> 00:34:31,179
Oh so a great work on the stuff I just

657
00:34:31,179 --> 00:34:33,899
did for a quest

658
00:34:47,399 --> 00:34:50,050
okay so basically the problem is that

659
00:34:50,050 --> 00:34:51,699
even I don't understand whether the

660
00:34:51,699 --> 00:35:07,750
problem is with JRuby or a JVM no I

661
00:35:07,750 --> 00:35:10,390
didn't concatenate those I just add

662
00:35:10,390 --> 00:35:13,180
these two elements means to - for

663
00:35:13,180 --> 00:35:15,579
example there is 2 comma 2 another has 2

664
00:35:15,579 --> 00:35:18,130
comma 3 so we get the final areas for

665
00:35:18,130 --> 00:35:31,089
commas 5 means 1 and actually this can't

666
00:35:31,089 --> 00:35:32,500
be reproduced here sometimes you get

667
00:35:32,500 --> 00:35:34,510
annoyed foot four out of ten times you

668
00:35:34,510 --> 00:35:39,599
get a zero or else it works fine

669
00:35:41,630 --> 00:35:44,270
yeah what do you see is the the

670
00:35:44,270 --> 00:35:47,750
integration of this with rails yeah well

671
00:35:47,750 --> 00:35:49,790
like what what kind of integration do

672
00:35:49,790 --> 00:35:51,920
you

673
00:35:51,920 --> 00:35:56,250
so basically if you have some maybe you

674
00:35:56,250 --> 00:35:58,140
can try it with active record basically

675
00:35:58,140 --> 00:36:02,069
I'm not consulted as I consulted some

676
00:36:02,069 --> 00:36:04,470
double root race developers at rubyconf

677
00:36:04,470 --> 00:36:07,800
india and the ad inputs like we can do

678
00:36:07,800 --> 00:36:13,020
it with race and so it would be widely

679
00:36:13,020 --> 00:36:15,140
used

680
00:36:20,670 --> 00:36:22,820
Thank You person very

681
00:36:22,820 --> 00:36:30,099
[Applause]

