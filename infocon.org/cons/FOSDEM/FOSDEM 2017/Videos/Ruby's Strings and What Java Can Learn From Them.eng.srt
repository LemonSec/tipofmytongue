1
00:00:12,900 --> 00:00:14,850
brings in the future

2
00:00:14,850 --> 00:00:21,470
you dare handle just all this okay

3
00:00:21,470 --> 00:00:24,180
details for me sorry about the size

4
00:00:24,180 --> 00:00:27,480
default Google slides font so I didn't

5
00:00:27,480 --> 00:00:28,740
mess with it too much

6
00:00:28,740 --> 00:00:32,610
Charles Nutter I'm hideous hea di us on

7
00:00:32,610 --> 00:00:35,220
most services online based in

8
00:00:35,220 --> 00:00:36,870
Minneapolis Minnesota so this is a

9
00:00:36,870 --> 00:00:40,530
lovely warm day for me today I've been

10
00:00:40,530 --> 00:00:42,570
at Red Hat for about four years now

11
00:00:42,570 --> 00:00:45,120
working full time on JRuby and working

12
00:00:45,120 --> 00:00:47,940
full time on JRuby since 2006 so just

13
00:00:47,940 --> 00:00:50,790
quick thank you to Sun Microsystems rest

14
00:00:50,790 --> 00:00:53,460
in peace' Engine Yard and Red Hat for

15
00:00:53,460 --> 00:00:55,290
for keeping the JRuby dream alive all

16
00:00:55,290 --> 00:00:59,070
these years okay so here's the agenda I

17
00:00:59,070 --> 00:01:00,540
don't have a lot of time so we'll just

18
00:01:00,540 --> 00:01:03,360
jump right in so talking about strings

19
00:01:03,360 --> 00:01:05,129
in Java I've been doing Java since the

20
00:01:05,129 --> 00:01:07,680
beginning since one oh it's always been

21
00:01:07,680 --> 00:01:09,810
a character array and the length to go

22
00:01:09,810 --> 00:01:10,530
along with it

23
00:01:10,530 --> 00:01:12,810
other bits and bobs in there sometimes

24
00:01:12,810 --> 00:01:15,200
to like save cash hash codes and such

25
00:01:15,200 --> 00:01:18,450
and in the beginning ucs-2 was fine

26
00:01:18,450 --> 00:01:19,619
there was this that was a totally

27
00:01:19,619 --> 00:01:21,750
satisfactory representation because 16

28
00:01:21,750 --> 00:01:23,340
bits per character should be enough for

29
00:01:23,340 --> 00:01:24,479
all the characters in the world right

30
00:01:24,479 --> 00:01:27,259
well it turns out that's not quite true

31
00:01:27,259 --> 00:01:31,079
so later on it was moved to utf-16 we

32
00:01:31,079 --> 00:01:33,780
keep the 16-bit characters we have to

33
00:01:33,780 --> 00:01:37,469
sacrifice constant random access time

34
00:01:37,469 --> 00:01:39,600
for certain types of characters in the

35
00:01:39,600 --> 00:01:42,240
higher planes like emojis for example

36
00:01:42,240 --> 00:01:44,159
but generally we still have constant

37
00:01:44,159 --> 00:01:45,899
access time and it still fits in the

38
00:01:45,899 --> 00:01:49,530
typical character size now one of the

39
00:01:49,530 --> 00:01:51,450
biggest problems that that comes up for

40
00:01:51,450 --> 00:01:53,670
a language like JRuby that has a very

41
00:01:53,670 --> 00:01:56,310
different sort of string is that string

42
00:01:56,310 --> 00:01:58,320
itself is just pervasive throughout Java

43
00:01:58,320 --> 00:02:01,079
ap is we got char sequence too late it

44
00:02:01,079 --> 00:02:02,880
was an underpowered interface and just

45
00:02:02,880 --> 00:02:06,299
nobody really uses it so we have to be

46
00:02:06,299 --> 00:02:09,060
able to fit into a string api's or if we

47
00:02:09,060 --> 00:02:10,470
use our own string we've got to actually

48
00:02:10,470 --> 00:02:12,600
roll an entirely new version of it that

49
00:02:12,600 --> 00:02:15,480
doesn't require Java strings so that's

50
00:02:15,480 --> 00:02:16,800
that's kind of a difficult problem for

51
00:02:16,800 --> 00:02:20,250
us recently there's been work to improve

52
00:02:20,250 --> 00:02:25,350
the the packing of ASCII bytes so 7-bit

53
00:02:25,350 --> 00:02:27,980
ascii in open JDK 9 and job

54
00:02:27,980 --> 00:02:30,260
9 will actually be able to represent

55
00:02:30,260 --> 00:02:32,810
itself as a compact array of bytes under

56
00:02:32,810 --> 00:02:34,909
the covers so you don't have that waste

57
00:02:34,909 --> 00:02:37,129
of 8 or 9 bits for every single

58
00:02:37,129 --> 00:02:40,400
character and there's a possibility I've

59
00:02:40,400 --> 00:02:42,440
heard that maybe we could even get utf-8

60
00:02:42,440 --> 00:02:43,940
in there it'd be kind of an opt-in

61
00:02:43,940 --> 00:02:46,849
because of the expectations of constant

62
00:02:46,849 --> 00:02:49,069
random access time but I would turn it

63
00:02:49,069 --> 00:02:50,840
on because I would love just be able to

64
00:02:50,840 --> 00:02:52,730
pull utf-8 bytes off the wire and not

65
00:02:52,730 --> 00:02:54,319
not deal with anything not do any

66
00:02:54,319 --> 00:02:57,409
transcoding and this is pretty much it

67
00:02:57,409 --> 00:02:59,420
this is this is strings on Java they're

68
00:02:59,420 --> 00:03:01,250
gonna be utf-16 and if that doesn't work

69
00:03:01,250 --> 00:03:05,019
for you then you're just kind of stuck

70
00:03:05,019 --> 00:03:06,290
ok

71
00:03:06,290 --> 00:03:09,950
so problems here the constant encoding

72
00:03:09,950 --> 00:03:11,840
overhead anything that you do when you

73
00:03:11,840 --> 00:03:13,549
have to read from the wire read from the

74
00:03:13,549 --> 00:03:15,410
file system and deal with characters

75
00:03:15,410 --> 00:03:18,109
you've got at least the decoding cost of

76
00:03:18,109 --> 00:03:19,970
bringing it in from bytes into

77
00:03:19,970 --> 00:03:21,319
characters because it needs to turn into

78
00:03:21,319 --> 00:03:24,709
utf-16 vanishingly small amounts of i/o

79
00:03:24,709 --> 00:03:27,290
on the actual internet or on the real

80
00:03:27,290 --> 00:03:29,810
networks and actual files are in utf-16

81
00:03:29,810 --> 00:03:32,030
so you pretty much always have to suffer

82
00:03:32,030 --> 00:03:34,519
through this and that's not cheap that's

83
00:03:34,519 --> 00:03:36,049
a cost and then if you're going back out

84
00:03:36,049 --> 00:03:37,639
to the wire most of the time if you

85
00:03:37,639 --> 00:03:39,169
process these characters you're going to

86
00:03:39,169 --> 00:03:40,160
do something with them that sends them

87
00:03:40,160 --> 00:03:41,989
back out you've got the encoding cost

88
00:03:41,989 --> 00:03:44,660
all over again so it really does limit

89
00:03:44,660 --> 00:03:46,459
how we can do high-speed i/o any

90
00:03:46,459 --> 00:03:47,480
anything that you need to process

91
00:03:47,480 --> 00:03:49,790
characters for like I mentioned the

92
00:03:49,790 --> 00:03:51,950
ASCII waste so if you're just using the

93
00:03:51,950 --> 00:03:54,019
bottom 7 bits for ASCII characters then

94
00:03:54,019 --> 00:03:55,790
you're wasting at least a full byte for

95
00:03:55,790 --> 00:03:58,190
every character and early on that was

96
00:03:58,190 --> 00:04:00,079
one of the things that Java haters

97
00:04:00,079 --> 00:04:02,299
really got into like every string is now

98
00:04:02,299 --> 00:04:04,160
twice as large even though I don't need

99
00:04:04,160 --> 00:04:06,590
it to be twice as large it's kind of

100
00:04:06,590 --> 00:04:09,650
funny that we have a whole stack of like

101
00:04:09,650 --> 00:04:12,530
super compact byte codes to try and fit

102
00:04:12,530 --> 00:04:15,019
more byte code into our set-top box in

103
00:04:15,019 --> 00:04:18,380
1995 and yet utf-16 strings that waste

104
00:04:18,380 --> 00:04:20,329
way more than those byte codes ever

105
00:04:20,329 --> 00:04:24,889
would so interesting decisions there so

106
00:04:24,889 --> 00:04:26,449
we also have to deal with the fact that

107
00:04:26,449 --> 00:04:28,580
in Ruby binary data is also represented

108
00:04:28,580 --> 00:04:30,500
in the same structure the string is

109
00:04:30,500 --> 00:04:32,150
basically just a wrapper around bytes

110
00:04:32,150 --> 00:04:33,620
and it might be binary it might be

111
00:04:33,620 --> 00:04:36,229
characters really hard to do with Java

112
00:04:36,229 --> 00:04:38,479
it wants those characters to be valid if

113
00:04:38,479 --> 00:04:40,159
you start shoving bogus characters in

114
00:04:40,159 --> 00:04:41,490
there all sorts of weird things will

115
00:04:41,490 --> 00:04:44,099
Raik you might wonder why we want to do

116
00:04:44,099 --> 00:04:45,930
this well we've got various cases where

117
00:04:45,930 --> 00:04:48,030
we want to embed arbitrary binary data

118
00:04:48,030 --> 00:04:51,060
into a class file or into a constant

119
00:04:51,060 --> 00:04:53,340
pool there's no good way to do this

120
00:04:53,340 --> 00:04:55,530
other than forcing it into a string

121
00:04:55,530 --> 00:04:58,349
probably invalid string and then shoving

122
00:04:58,349 --> 00:05:01,860
it into the class file itself so that's

123
00:05:01,860 --> 00:05:02,970
another issue that we've had to deal

124
00:05:02,970 --> 00:05:05,130
with and then there's the CJK problem

125
00:05:05,130 --> 00:05:07,880
the the Chinese Japanese Korean problem

126
00:05:07,880 --> 00:05:10,139
but basically the issue here is that

127
00:05:10,139 --> 00:05:11,729
each of these languages have their own

128
00:05:11,729 --> 00:05:13,440
representations of certain characters

129
00:05:13,440 --> 00:05:17,759
like kanji and and Hansa and Chinese the

130
00:05:17,759 --> 00:05:21,419
Unicode folks decided that the character

131
00:05:21,419 --> 00:05:23,280
that looks like this in Japanese is the

132
00:05:23,280 --> 00:05:25,020
same as the one that looks pretty much

133
00:05:25,020 --> 00:05:27,449
like this in Chinese and so they get one

134
00:05:27,449 --> 00:05:29,400
code point when you can imagine they

135
00:05:29,400 --> 00:05:30,900
weren't very happy about this because

136
00:05:30,900 --> 00:05:32,699
now round-tripping through you TFS

137
00:05:32,699 --> 00:05:35,159
through through any Unicode encoding you

138
00:05:35,159 --> 00:05:37,349
will lose which of those two versions it

139
00:05:37,349 --> 00:05:39,449
actually was you can't take it back out

140
00:05:39,449 --> 00:05:42,060
and have the original character in their

141
00:05:42,060 --> 00:05:44,819
estimation that's a stone ax below fence

142
00:05:44,819 --> 00:05:46,830
and it's a real serious problem for for

143
00:05:46,830 --> 00:05:49,530
them so that's why in Japan they still

144
00:05:49,530 --> 00:05:51,659
use shift gist's and China they use Big

145
00:05:51,659 --> 00:05:53,250
Five and other Chinese and codings

146
00:05:53,250 --> 00:05:58,259
because of this problem so strings in

147
00:05:58,259 --> 00:06:00,330
Ruby strings and Ruby are basically just

148
00:06:00,330 --> 00:06:02,070
a byte array and links similar to the

149
00:06:02,070 --> 00:06:04,289
chart character array and a length in

150
00:06:04,289 --> 00:06:06,479
Java and the length in this case refers

151
00:06:06,479 --> 00:06:08,070
to the byte length not the character

152
00:06:08,070 --> 00:06:13,250
count up until Ruby up through Ruby 187

153
00:06:13,250 --> 00:06:16,229
there was a single global encoding that

154
00:06:16,229 --> 00:06:18,539
you could set at the command line I

155
00:06:18,539 --> 00:06:20,250
think would default to assuming its

156
00:06:20,250 --> 00:06:21,900
ASCII but you can do some unicode

157
00:06:21,900 --> 00:06:23,880
operations you could specify that all

158
00:06:23,880 --> 00:06:25,229
strings were unicode and then it would

159
00:06:25,229 --> 00:06:28,110
do some additional validation or specify

160
00:06:28,110 --> 00:06:31,860
some other encodings like churches and

161
00:06:31,860 --> 00:06:33,659
like I say some of some operations that

162
00:06:33,659 --> 00:06:35,370
were specific to Unicode were always

163
00:06:35,370 --> 00:06:37,050
available like regular expressions have

164
00:06:37,050 --> 00:06:39,180
a flag that says treat this as a Unicode

165
00:06:39,180 --> 00:06:40,740
regular expression rather than an ASCII

166
00:06:40,740 --> 00:06:43,590
one and that worked okay but in a world

167
00:06:43,590 --> 00:06:45,990
of encoding x' and dealing with the

168
00:06:45,990 --> 00:06:47,789
wider internet and lots of files and

169
00:06:47,789 --> 00:06:50,310
different formats they decided they

170
00:06:50,310 --> 00:06:51,900
needed something better to negotiate all

171
00:06:51,900 --> 00:06:53,310
these different encodings and strings

172
00:06:53,310 --> 00:06:55,169
and so in Ruby

173
00:06:55,169 --> 00:06:59,849
9:1 and from from then from then on in

174
00:06:59,849 --> 00:07:01,680
addition to having the byte array and

175
00:07:01,680 --> 00:07:04,889
the length of those bytes they had an

176
00:07:04,889 --> 00:07:06,539
arbitrary encoding and that might be

177
00:07:06,539 --> 00:07:09,060
utf-8 might be utf-16 it might be big

178
00:07:09,060 --> 00:07:12,210
five it might be epic there's a lot of

179
00:07:12,210 --> 00:07:14,189
different encodings so they opted to

180
00:07:14,189 --> 00:07:16,529
basically say let's let each string

181
00:07:16,529 --> 00:07:18,870
decide its own encoding so that when we

182
00:07:18,870 --> 00:07:20,610
do have to deal with disparate sources

183
00:07:20,610 --> 00:07:22,439
the data we don't have to transcode

184
00:07:22,439 --> 00:07:24,180
everything to some intermediate we can

185
00:07:24,180 --> 00:07:26,430
actually use mixed encoding strings

186
00:07:26,430 --> 00:07:29,039
throughout the system now this is

187
00:07:29,039 --> 00:07:31,289
obviously very complicated we had to

188
00:07:31,289 --> 00:07:33,180
also implement this to keep up with Ruby

189
00:07:33,180 --> 00:07:36,870
features and it's taken years for us to

190
00:07:36,870 --> 00:07:38,249
match up with the the level of

191
00:07:38,249 --> 00:07:41,039
compatibility we needed for C Ruby but

192
00:07:41,039 --> 00:07:44,310
it does work surprisingly well most of

193
00:07:44,310 --> 00:07:46,830
the time you don't have a lot of mixed

194
00:07:46,830 --> 00:07:48,689
encoding environments usually it's like

195
00:07:48,689 --> 00:07:51,150
a utf-8 that you're dealing with but if

196
00:07:51,150 --> 00:07:52,740
you do have mixed encoding environments

197
00:07:52,740 --> 00:07:54,870
it negotiates this stuff pretty well so

198
00:07:54,870 --> 00:07:57,270
it's it's a complex design some would

199
00:07:57,270 --> 00:07:58,710
say over complex but it works

200
00:07:58,710 --> 00:08:01,770
surprisingly well so problems with

201
00:08:01,770 --> 00:08:04,199
Ruby's multilingual ization is what they

202
00:08:04,199 --> 00:08:07,469
call it so by default it's utf-8 and so

203
00:08:07,469 --> 00:08:09,659
the standard utf-8 problem of not having

204
00:08:09,659 --> 00:08:11,669
constant random access time you can't

205
00:08:11,669 --> 00:08:13,710
just say give me the nth character and

206
00:08:13,710 --> 00:08:15,629
have it immediately it has to be a walk

207
00:08:15,629 --> 00:08:16,770
of all characters because they're

208
00:08:16,770 --> 00:08:19,529
variable widths if that's a problem for

209
00:08:19,529 --> 00:08:22,020
you however the it has support for

210
00:08:22,020 --> 00:08:24,899
utf-32 and so you could say internally I

211
00:08:24,899 --> 00:08:26,729
want to use all utf-32 so it's all

212
00:08:26,729 --> 00:08:28,770
constant access time and you can get

213
00:08:28,770 --> 00:08:30,539
around this and it works just fine that

214
00:08:30,539 --> 00:08:32,789
way too and then of course you have to

215
00:08:32,789 --> 00:08:36,360
pay the encoding and decoding costs like

216
00:08:36,360 --> 00:08:38,669
I say it's possible to have an arbitrary

217
00:08:38,669 --> 00:08:40,380
number of coding encoding floating

218
00:08:40,380 --> 00:08:41,789
around in the system but it's rarely

219
00:08:41,789 --> 00:08:43,860
done and it's almost never a problem

220
00:08:43,860 --> 00:08:45,779
usually you're dealing with one encoding

221
00:08:45,779 --> 00:08:47,459
or you're trying to convert you do

222
00:08:47,459 --> 00:08:49,050
actually convert things into utf-8 and

223
00:08:49,050 --> 00:08:51,120
use that internally so that doesn't come

224
00:08:51,120 --> 00:08:54,000
up too often if you've got lots of

225
00:08:54,000 --> 00:08:55,500
strings with different encodings every

226
00:08:55,500 --> 00:08:57,449
time you do a string operation with

227
00:08:57,449 --> 00:08:59,639
another string you've got to find some

228
00:08:59,639 --> 00:09:01,620
common ground there and there's various

229
00:09:01,620 --> 00:09:03,660
heuristics that Ruby uses to say if it's

230
00:09:03,660 --> 00:09:05,850
a utf-8 over here and it's shift just

231
00:09:05,850 --> 00:09:07,620
over there we'll negotiate it to

232
00:09:07,620 --> 00:09:08,579
whatever the the best

233
00:09:08,579 --> 00:09:10,290
common encoding for those two is and

234
00:09:10,290 --> 00:09:11,970
your resulting string will be one of

235
00:09:11,970 --> 00:09:14,100
those in coatings most of the time you

236
00:09:14,100 --> 00:09:15,899
never even look need to look at this the

237
00:09:15,899 --> 00:09:18,059
Ruby sub system hides the fact that it's

238
00:09:18,059 --> 00:09:20,129
a byte array in an encoding and you just

239
00:09:20,129 --> 00:09:21,449
deal with code points and characters

240
00:09:21,449 --> 00:09:25,860
most of the time the bigger one is that

241
00:09:25,860 --> 00:09:27,329
all of the support libraries have to be

242
00:09:27,329 --> 00:09:29,189
able to do this and as far as I know

243
00:09:29,189 --> 00:09:30,720
there's only one regular expression

244
00:09:30,720 --> 00:09:32,910
engine in the world that can basically

245
00:09:32,910 --> 00:09:35,730
work over arbitrarily encoded bytes and

246
00:09:35,730 --> 00:09:37,949
that's the one that that Ruby imported

247
00:09:37,949 --> 00:09:38,879
called ona guruma

248
00:09:38,879 --> 00:09:41,279
that we ported for JRuby and then of

249
00:09:41,279 --> 00:09:43,170
course IO needs to have a much much more

250
00:09:43,170 --> 00:09:45,660
complicated pipeline for reading and

251
00:09:45,660 --> 00:09:47,429
bytes turning them into well some

252
00:09:47,429 --> 00:09:49,019
internal coding and then going back out

253
00:09:49,019 --> 00:09:51,119
because we handle arbitrary number of

254
00:09:51,119 --> 00:09:53,850
encoding and like I said it's it's

255
00:09:53,850 --> 00:09:55,350
complex and the early implementations

256
00:09:55,350 --> 00:09:57,059
were fragile but it has matured pretty

257
00:09:57,059 --> 00:09:59,819
well and things generally just work how

258
00:09:59,819 --> 00:10:03,480
are we doing here okay so strings in

259
00:10:03,480 --> 00:10:06,239
JRuby prior to 2006 we did have this

260
00:10:06,239 --> 00:10:08,809
Java string based or character based or

261
00:10:08,809 --> 00:10:11,699
implementation but obviously all these

262
00:10:11,699 --> 00:10:12,779
different encodings were a problem

263
00:10:12,779 --> 00:10:14,610
representing binary data was a problem

264
00:10:14,610 --> 00:10:16,619
we realized we had to do had to follow

265
00:10:16,619 --> 00:10:17,939
the Ruby approach a little bit more

266
00:10:17,939 --> 00:10:20,730
closely unfortunately that meant we'll a

267
00:10:20,730 --> 00:10:23,399
lot more work and up until maybe even

268
00:10:23,399 --> 00:10:25,350
last year we were still working out the

269
00:10:25,350 --> 00:10:27,179
bugs in our implementation of

270
00:10:27,179 --> 00:10:31,079
multilingual ization character logic

271
00:10:31,079 --> 00:10:32,519
that had to be duplicated the regular

272
00:10:32,519 --> 00:10:34,110
expression we had to port that regular

273
00:10:34,110 --> 00:10:35,790
expression engine over all of the i/o

274
00:10:35,790 --> 00:10:37,769
encoding and transcoding logic had to be

275
00:10:37,769 --> 00:10:40,199
ported over so it's been years of work

276
00:10:40,199 --> 00:10:44,189
but it works now we have very few or no

277
00:10:44,189 --> 00:10:48,019
known bugs compared to C Ruby in our

278
00:10:48,019 --> 00:10:50,399
encoding library and our regular

279
00:10:50,399 --> 00:10:52,439
expression library and they're just Java

280
00:10:52,439 --> 00:10:54,540
libraries that you can use so that's

281
00:10:54,540 --> 00:10:56,329
what we're gonna show today a little bit

282
00:10:56,329 --> 00:10:58,799
so here's the libraries that we have I

283
00:10:58,799 --> 00:11:01,230
won't talk in depth about bite lists you

284
00:11:01,230 --> 00:11:02,699
can just imagine it's a string buffer

285
00:11:02,699 --> 00:11:04,799
for byte arrays pretty much all there is

286
00:11:04,799 --> 00:11:07,139
to it aggregates the same things that a

287
00:11:07,139 --> 00:11:10,589
string does array of bytes a byte length

288
00:11:10,589 --> 00:11:12,329
and an encoding and then provide some

289
00:11:12,329 --> 00:11:14,999
operations over those to add an insert

290
00:11:14,999 --> 00:11:18,959
and whatnot J codings is the encoding

291
00:11:18,959 --> 00:11:20,970
subsystem and so this has all of the

292
00:11:20,970 --> 00:11:22,140
metadata for all of the

293
00:11:22,140 --> 00:11:23,400
different encodings that are supported

294
00:11:23,400 --> 00:11:26,790
like if I see this byte how many

295
00:11:26,790 --> 00:11:28,740
additional bytes do I need for a multi

296
00:11:28,740 --> 00:11:31,650
byte character or given this code point

297
00:11:31,650 --> 00:11:33,270
what are the bytes that would that this

298
00:11:33,270 --> 00:11:36,030
encoding would represent those as so

299
00:11:36,030 --> 00:11:37,500
functional things like going back and

300
00:11:37,500 --> 00:11:39,060
forth between bytes and characters or

301
00:11:39,060 --> 00:11:42,150
code points it also has a rather

302
00:11:42,150 --> 00:11:45,780
complicated inner loop of a transcoder

303
00:11:45,780 --> 00:11:48,060
that can take a byte array on one side

304
00:11:48,060 --> 00:11:50,210
that is known to be an encoding a and

305
00:11:50,210 --> 00:11:52,710
output it to a byte array on the other

306
00:11:52,710 --> 00:11:55,590
side in another encoding without doing

307
00:11:55,590 --> 00:11:58,860
any sort of intermediate step in order

308
00:11:58,860 --> 00:12:00,330
to do this in Java you would need to

309
00:12:00,330 --> 00:12:03,540
decode everything to utf-16 re-encode it

310
00:12:03,540 --> 00:12:06,090
back into the other encoding and wasting

311
00:12:06,090 --> 00:12:08,400
all that time in between and so in

312
00:12:08,400 --> 00:12:10,080
general the the encoding logic that we

313
00:12:10,080 --> 00:12:12,030
have the transcoder here can do those

314
00:12:12,030 --> 00:12:13,920
sorts of those sorts of conversions

315
00:12:13,920 --> 00:12:17,520
significantly faster than Java can the

316
00:12:17,520 --> 00:12:20,010
regular expression engine is a port of

317
00:12:20,010 --> 00:12:22,590
the engine that the C ruby folks adopted

318
00:12:22,590 --> 00:12:23,660
called Oni guruma

319
00:12:23,660 --> 00:12:26,040
Oni guruma is basically a regular

320
00:12:26,040 --> 00:12:27,990
expression engine that has they can work

321
00:12:27,990 --> 00:12:29,520
on arbitrary encodings and it has

322
00:12:29,520 --> 00:12:31,320
pluggable syntax so there's multiple

323
00:12:31,320 --> 00:12:33,660
different versions of regular expression

324
00:12:33,660 --> 00:12:36,750
syntax as well as being able to use any

325
00:12:36,750 --> 00:12:38,070
encoding it's the most customizable

326
00:12:38,070 --> 00:12:39,510
regular expression engine that's out

327
00:12:39,510 --> 00:12:42,300
there for sure and our port of it

328
00:12:42,300 --> 00:12:44,160
actually has better performance than

329
00:12:44,160 --> 00:12:45,750
Java util regex

330
00:12:45,750 --> 00:12:48,060
for doing matches plus you don't have

331
00:12:48,060 --> 00:12:49,830
the cost of having to pull in bytes as

332
00:12:49,830 --> 00:12:51,870
characters before you start doing your

333
00:12:51,870 --> 00:12:54,540
matching you do a read do your matching

334
00:12:54,540 --> 00:12:56,460
send it back out no characters involved

335
00:12:56,460 --> 00:12:58,350
no transcoding involved it's pretty

336
00:12:58,350 --> 00:13:02,250
pretty cool ok so a little bit more

337
00:13:02,250 --> 00:13:04,560
detail about J codings like I said it's

338
00:13:04,560 --> 00:13:05,910
all the character data and the metadata

339
00:13:05,910 --> 00:13:07,650
for the different encoding slots are

340
00:13:07,650 --> 00:13:09,420
supported all the ones that you would

341
00:13:09,420 --> 00:13:11,100
typically use and a several that you

342
00:13:11,100 --> 00:13:13,560
will never want to use actually supports

343
00:13:13,560 --> 00:13:16,190
more encodings than the default set of

344
00:13:16,190 --> 00:13:19,380
encoding decoding logic that's in open

345
00:13:19,380 --> 00:13:21,870
JDK and at least one of the I think it

346
00:13:21,870 --> 00:13:26,100
is o 8859 11 I have a patch that I don't

347
00:13:26,100 --> 00:13:27,840
know if I've gotten in yet to add

348
00:13:27,840 --> 00:13:30,690
decoders and encoders for for Java but

349
00:13:30,690 --> 00:13:33,810
yeah very complete encoding support all

350
00:13:33,810 --> 00:13:34,680
the the weird

351
00:13:34,680 --> 00:13:35,360
Asian

352
00:13:35,360 --> 00:13:37,639
and other European encodings that you

353
00:13:37,639 --> 00:13:39,110
don't see if and except in those

354
00:13:39,110 --> 00:13:41,329
countries and then all the IBM and

355
00:13:41,329 --> 00:13:42,980
windows code pages are even in there so

356
00:13:42,980 --> 00:13:45,860
it supports all this stuff you can do

357
00:13:45,860 --> 00:13:47,449
this direct transcoding like I talked

358
00:13:47,449 --> 00:13:49,309
about basically take bytes to bytes

359
00:13:49,309 --> 00:13:51,499
without any intermediate step much

360
00:13:51,499 --> 00:13:54,610
faster than going through utf-16 and

361
00:13:54,610 --> 00:13:56,869
that was an epic piece of code if you

362
00:13:56,869 --> 00:13:58,339
ever want to see some interesting code

363
00:13:58,339 --> 00:14:01,309
the C code there had net nested switches

364
00:14:01,309 --> 00:14:03,949
and nested loops and then branches and

365
00:14:03,949 --> 00:14:05,749
go twos that would go out to other

366
00:14:05,749 --> 00:14:09,259
switches and cases and I that was a fun

367
00:14:09,259 --> 00:14:13,670
fun week porting that to Java so bonus

368
00:14:13,670 --> 00:14:15,470
features that are kind of cool you can

369
00:14:15,470 --> 00:14:17,209
have it replace anything that is not a

370
00:14:17,209 --> 00:14:19,910
valid XML character with its entity

371
00:14:19,910 --> 00:14:22,249
representation just along the way as

372
00:14:22,249 --> 00:14:24,799
it's doing encoding or decoding you can

373
00:14:24,799 --> 00:14:26,509
also have it negotiate can carriage

374
00:14:26,509 --> 00:14:28,549
return line feeds normalize them all to

375
00:14:28,549 --> 00:14:31,759
carriage return right - like crlf on the

376
00:14:31,759 --> 00:14:33,799
way out and carriage return on the way

377
00:14:33,799 --> 00:14:35,809
in various levels that you can configure

378
00:14:35,809 --> 00:14:38,119
that and lots of folks are actually

379
00:14:38,119 --> 00:14:38,959
using this in the wild

380
00:14:38,959 --> 00:14:40,730
obviously JRuby uses it the Facebook

381
00:14:40,730 --> 00:14:41,989
guys use it for some high-speed

382
00:14:41,989 --> 00:14:44,059
character i/o or they need to process

383
00:14:44,059 --> 00:14:45,889
stuff and send it out quickly they

384
00:14:45,889 --> 00:14:47,119
didn't want to pay the decoding and

385
00:14:47,119 --> 00:14:49,669
encoding cost every single time truffle

386
00:14:49,669 --> 00:14:51,199
Ruby obviously uses it because they they

387
00:14:51,199 --> 00:14:54,410
grew out of JRuby and JetBrains for any

388
00:14:54,410 --> 00:14:56,629
Ruby related stuff they use it as well

389
00:14:56,629 --> 00:15:01,040
internally so here's a quick simple

390
00:15:01,040 --> 00:15:02,839
example of just some of the metadata API

391
00:15:02,839 --> 00:15:06,699
s so we've got our utf-8 bytes here

392
00:15:06,699 --> 00:15:09,439
seven bytes long for a five character

393
00:15:09,439 --> 00:15:11,299
string we can see what the actual

394
00:15:11,299 --> 00:15:13,429
character count of it is by going to the

395
00:15:13,429 --> 00:15:15,919
utf-8 encoding and asking how it asking

396
00:15:15,919 --> 00:15:18,230
it to count it up we can see how wide an

397
00:15:18,230 --> 00:15:20,179
individual character is at a particular

398
00:15:20,179 --> 00:15:22,399
offset so we know how many more bytes to

399
00:15:22,399 --> 00:15:25,339
read and then we can go back and forth

400
00:15:25,339 --> 00:15:27,319
between code points bytes to code points

401
00:15:27,319 --> 00:15:30,079
and back again so simple stuff but all

402
00:15:30,079 --> 00:15:31,309
the things you would need to go back and

403
00:15:31,309 --> 00:15:34,369
forth with bytes and characters here's

404
00:15:34,369 --> 00:15:35,899
the transcoder so we open a new

405
00:15:35,899 --> 00:15:39,589
transcoder from utf-8 to utf-16 we've

406
00:15:39,589 --> 00:15:41,299
got our source and destination bytes

407
00:15:41,299 --> 00:15:43,999
here and this is actually a test that's

408
00:15:43,999 --> 00:15:46,369
in the J coding suite and then we do our

409
00:15:46,369 --> 00:15:49,100
R convert so we've got our source we

410
00:15:49,100 --> 00:15:52,700
to pass a essentially pass by pointer

411
00:15:52,700 --> 00:15:55,880
the start position for this and it's

412
00:15:55,880 --> 00:15:57,560
gonna let us know how far it was able to

413
00:15:57,560 --> 00:16:00,770
decode where we want to start the

414
00:16:00,770 --> 00:16:03,620
destination array the destinations start

415
00:16:03,620 --> 00:16:05,660
and again it's going to be different

416
00:16:05,660 --> 00:16:07,130
amounts of bytes depending on which

417
00:16:07,130 --> 00:16:08,750
encoding we're going to so we need to

418
00:16:08,750 --> 00:16:11,060
get that out again love to have multiple

419
00:16:11,060 --> 00:16:13,370
return values here and then the other

420
00:16:13,370 --> 00:16:15,200
details about the destination the 0

421
00:16:15,200 --> 00:16:17,180
there is flags for other things like

422
00:16:17,180 --> 00:16:19,550
changing slightly changing how it

423
00:16:19,550 --> 00:16:22,670
handles invalid characters whatever it

424
00:16:22,670 --> 00:16:24,290
reports it or raises exceptions and so

425
00:16:24,290 --> 00:16:26,420
on so similar to Java util reg X there

426
00:16:26,420 --> 00:16:29,090
and then we we actually can do our

427
00:16:29,090 --> 00:16:30,920
conversion and get the bytes out never

428
00:16:30,920 --> 00:16:32,090
have to pass it through characters in

429
00:16:32,090 --> 00:16:36,890
the middle so only guruma Joanie is our

430
00:16:36,890 --> 00:16:41,060
port of it and Java this has been pretty

431
00:16:41,060 --> 00:16:42,620
well functional for four years we have

432
00:16:42,620 --> 00:16:44,510
occasional updates and fixes but it's

433
00:16:44,510 --> 00:16:45,740
been working for quite a long time now

434
00:16:45,740 --> 00:16:48,380
so it's fairly stable it is a bytecode

435
00:16:48,380 --> 00:16:50,540
machine and it's stackless which is very

436
00:16:50,540 --> 00:16:52,550
important when we talk about some

437
00:16:52,550 --> 00:16:54,980
failings of Java util regex there's

438
00:16:54,980 --> 00:16:56,720
certain structures of regular expression

439
00:16:56,720 --> 00:16:58,820
that the existing implementation will

440
00:16:58,820 --> 00:17:00,740
deepen the stack for and then deepen the

441
00:17:00,740 --> 00:17:02,660
stack and then deepen the stack so there

442
00:17:02,660 --> 00:17:05,119
are cases that you cannot match with

443
00:17:05,119 --> 00:17:07,400
Java util regex over like very large

444
00:17:07,400 --> 00:17:09,230
input because it'll blow the stack out

445
00:17:09,230 --> 00:17:10,790
obviously this doesn't have that problem

446
00:17:10,790 --> 00:17:14,270
because it's stackless like I say highly

447
00:17:14,270 --> 00:17:15,950
configurable different grammars there's

448
00:17:15,950 --> 00:17:18,440
a there's a syntax for Java for Ruby for

449
00:17:18,440 --> 00:17:20,030
JavaScript for a couple different other

450
00:17:20,030 --> 00:17:21,770
languages you can pick which syntax

451
00:17:21,770 --> 00:17:22,819
you're using for your regular

452
00:17:22,819 --> 00:17:25,760
expressions and just plug it in and

453
00:17:25,760 --> 00:17:27,650
again lots of the users in the wild

454
00:17:27,650 --> 00:17:30,140
including JRuby Nazz horn did a version

455
00:17:30,140 --> 00:17:33,290
of a modified fork of this that is all

456
00:17:33,290 --> 00:17:35,180
character arrays so it doesn't have the

457
00:17:35,180 --> 00:17:37,430
advantage of different different

458
00:17:37,430 --> 00:17:39,580
encoding support but it's much faster

459
00:17:39,580 --> 00:17:44,050
matches Java scripts syntax and so on

460
00:17:44,050 --> 00:17:47,270
okay so here are just a couple quick

461
00:17:47,270 --> 00:17:49,430
Jony examples we have our regular

462
00:17:49,430 --> 00:17:50,930
expression we can create with just a

463
00:17:50,930 --> 00:17:53,300
simple string pattern or specify

464
00:17:53,300 --> 00:17:54,770
different syntax that we want to use

465
00:17:54,770 --> 00:17:57,200
with it here we got our matcher just

466
00:17:57,200 --> 00:18:01,159
like in Java util regex we do our search

467
00:18:01,159 --> 00:18:03,019
and the options here provide various

468
00:18:03,019 --> 00:18:04,989
ways of doing those matching and

469
00:18:04,989 --> 00:18:08,869
altering how it does the search and then

470
00:18:08,869 --> 00:18:10,700
one of the other nice features here

471
00:18:10,700 --> 00:18:12,320
that's not in Java util regex if you

472
00:18:12,320 --> 00:18:13,970
have a regular expression that's a weird

473
00:18:13,970 --> 00:18:17,149
case and runs forever you can do just a

474
00:18:17,149 --> 00:18:19,009
normal thread interrupt and kill that

475
00:18:19,009 --> 00:18:21,529
match so you don't get stuck in in some

476
00:18:21,529 --> 00:18:22,849
inner loop of a regular expression

477
00:18:22,849 --> 00:18:26,629
that's never going to return last part

478
00:18:26,629 --> 00:18:28,220
of the Jony examples here so here we

479
00:18:28,220 --> 00:18:30,049
want to get our regions out for for

480
00:18:30,049 --> 00:18:33,169
pulling groups off of this and we can

481
00:18:33,169 --> 00:18:35,359
get a start index and an end index and

482
00:18:35,359 --> 00:18:38,179
basically just go directly to the bytes

483
00:18:38,179 --> 00:18:39,559
we don't have to turn anything into

484
00:18:39,559 --> 00:18:41,090
characters we can go back to the same

485
00:18:41,090 --> 00:18:43,309
byte array do no copying and have

486
00:18:43,309 --> 00:18:46,509
regular expression matches with groups

487
00:18:46,509 --> 00:18:50,659
okay so just a quick note on performance

488
00:18:50,659 --> 00:18:53,049
like I said Jay codings definitely is

489
00:18:53,049 --> 00:18:56,720
faster than going through utf-16 hard to

490
00:18:56,720 --> 00:18:58,340
compare it other than that because it

491
00:18:58,340 --> 00:19:00,200
doesn't match the same way that char

492
00:19:00,200 --> 00:19:02,269
sets work but it'sit's pretty good

493
00:19:02,269 --> 00:19:03,320
performance

494
00:19:03,320 --> 00:19:05,179
Jony can be significantly faster than

495
00:19:05,179 --> 00:19:06,679
Java util regex I mean there's certain

496
00:19:06,679 --> 00:19:09,109
cases where Java util dragic just blows

497
00:19:09,109 --> 00:19:11,539
up but two to three faster for most of

498
00:19:11,539 --> 00:19:13,309
the things that i've tested so if you

499
00:19:13,309 --> 00:19:15,019
want to pull bytes off the wire really

500
00:19:15,019 --> 00:19:16,820
fast and do quick matches against him

501
00:19:16,820 --> 00:19:20,090
this is a great one to look at and being

502
00:19:20,090 --> 00:19:21,979
interrupted was great like I've had

503
00:19:21,979 --> 00:19:23,299
plenty of regular expressions it just

504
00:19:23,299 --> 00:19:24,710
went off into the weeds and never seemed

505
00:19:24,710 --> 00:19:26,779
to come back it's nice to be able to

506
00:19:26,779 --> 00:19:31,039
kill those off and re-examine it okay so

507
00:19:31,039 --> 00:19:34,519
wrapping up so Java string really

508
00:19:34,519 --> 00:19:36,679
unchanged for decades as far as the

509
00:19:36,679 --> 00:19:38,509
internal implementation is starting to

510
00:19:38,509 --> 00:19:40,429
evolve some of these features the

511
00:19:40,429 --> 00:19:42,679
support for ass compact ascii strings

512
00:19:42,679 --> 00:19:43,309
and so on

513
00:19:43,309 --> 00:19:45,320
hopefully that process will continue and

514
00:19:45,320 --> 00:19:48,139
we'll get a more robust string that cuts

515
00:19:48,139 --> 00:19:49,629
some of that overhead out for us and

516
00:19:49,629 --> 00:19:51,799
learning from what Ruby's done and what

517
00:19:51,799 --> 00:19:54,470
we've ported and implemented in JRuby

518
00:19:54,470 --> 00:19:56,749
may advise some of those features in the

519
00:19:56,749 --> 00:19:58,460
future so hopefully we'll be able to

520
00:19:58,460 --> 00:20:00,639
help improve Java string in the future

521
00:20:00,639 --> 00:20:02,899
but meanwhile these libraries are

522
00:20:02,899 --> 00:20:04,909
available if you take a look under the

523
00:20:04,909 --> 00:20:06,919
JRuby organization and github they're

524
00:20:06,919 --> 00:20:09,739
all right there white lists Joanie and J

525
00:20:09,739 --> 00:20:12,200
coatings and they're all in maven so you

526
00:20:12,200 --> 00:20:13,399
can pull them down and they're ready to

527
00:20:13,399 --> 00:20:15,230
go that's all I got

528
00:20:15,230 --> 00:20:23,149
thank you we have a little time for

529
00:20:23,149 --> 00:20:33,399
questions yeah hi so the Java string

530
00:20:33,399 --> 00:20:36,380
methods like string index or for string

531
00:20:36,380 --> 00:20:38,000
compare things like that they're heavily

532
00:20:38,000 --> 00:20:40,070
optimized with intrinsic sin taking this

533
00:20:40,070 --> 00:20:41,630
vector instruction and stuff like that

534
00:20:41,630 --> 00:20:45,250
so how do you compete with these

535
00:20:45,250 --> 00:20:48,649
operations on your class well it's a

536
00:20:48,649 --> 00:20:50,059
good question I'm not sure where we

537
00:20:50,059 --> 00:20:52,639
stand on that we have done some of the

538
00:20:52,639 --> 00:20:54,980
unsafe tricks that folks have used to do

539
00:20:54,980 --> 00:20:58,130
like you know 64 bits tried for 4 string

540
00:20:58,130 --> 00:21:01,190
searches and so on and those those help

541
00:21:01,190 --> 00:21:02,690
get us pretty close to where the Java

542
00:21:02,690 --> 00:21:05,630
performance is usually and we haven't

543
00:21:05,630 --> 00:21:06,889
done a whole lot of exploration because

544
00:21:06,889 --> 00:21:08,929
again it's it's that's a weird

545
00:21:08,929 --> 00:21:11,059
comparison we're working with bytes and

546
00:21:11,059 --> 00:21:13,730
generally non-constant access time utf-8

547
00:21:13,730 --> 00:21:17,299
handling along the way versus utf-16

548
00:21:17,299 --> 00:21:19,880
strings which are just read right out so

549
00:21:19,880 --> 00:21:22,190
but I would imagine we probably are

550
00:21:22,190 --> 00:21:24,320
reasonably competitive I'd like to run

551
00:21:24,320 --> 00:21:27,879
some more numbers though okay thank you

552
00:21:31,430 --> 00:21:34,350
all right well see you around

553
00:21:34,350 --> 00:21:35,250
Thanks

554
00:21:35,250 --> 00:21:42,509
[Applause]

