1
00:00:06,410 --> 00:00:09,330
welcome your next speaker Alex Davis

2
00:00:09,330 --> 00:00:11,910
telling us everything you ever wanted to

3
00:00:11,910 --> 00:00:14,940
know about hello world

4
00:00:14,940 --> 00:00:19,100
[Applause]

5
00:00:22,560 --> 00:00:28,960
okay is that better am I on there oh

6
00:00:28,960 --> 00:00:29,980
there we are

7
00:00:29,980 --> 00:00:34,650
okay welcome thanks for coming

8
00:00:37,860 --> 00:00:40,860
sorry

9
00:00:42,530 --> 00:00:46,200
so okay so I'm here today to talk to you

10
00:00:46,200 --> 00:00:49,200
about HelloWorld the simplest little C

11
00:00:49,200 --> 00:00:51,680
program the first example in knr and

12
00:00:51,680 --> 00:00:54,270
explain a bit how we got to the point

13
00:00:54,270 --> 00:00:56,670
where the basic hello world is over a

14
00:00:56,670 --> 00:00:59,760
megabyte stripped on miss there's

15
00:00:59,760 --> 00:01:02,070
actually good reasons for this but it's

16
00:01:02,070 --> 00:01:04,949
a little unobvious but before I could

17
00:01:04,949 --> 00:01:06,479
dive into that I'm gonna give you a

18
00:01:06,479 --> 00:01:08,760
little introduction as to how I dug in

19
00:01:08,760 --> 00:01:10,260
you started digging into all this stuff

20
00:01:10,260 --> 00:01:13,470
so turned out I wanted to understand the

21
00:01:13,470 --> 00:01:16,530
process avi how processes start and the

22
00:01:16,530 --> 00:01:19,259
basics of the C runtime because I want

23
00:01:19,259 --> 00:01:21,720
to change all of it so I'm not really

24
00:01:21,720 --> 00:01:23,250
gonna talk about how I'm going to change

25
00:01:23,250 --> 00:01:24,810
it today very much I'll allude to some

26
00:01:24,810 --> 00:01:27,570
bits but the reason that I want to

27
00:01:27,570 --> 00:01:29,399
change it is that I'm part of a research

28
00:01:29,399 --> 00:01:32,009
project at SR I international in the

29
00:01:32,009 --> 00:01:34,170
University of Cambridge where we're

30
00:01:34,170 --> 00:01:39,960
developing extensions to CPU ISAs which

31
00:01:39,960 --> 00:01:42,450
give us the ability to make C compatible

32
00:01:42,450 --> 00:01:45,110
memory safety and enforce it in hardware

33
00:01:45,110 --> 00:01:50,369
so we can recompile C code and eliminate

34
00:01:50,369 --> 00:01:52,259
most buffer overflows pretty much out of

35
00:01:52,259 --> 00:01:55,440
the box with only some minor changes to

36
00:01:55,440 --> 00:01:57,840
runtimes and I had to dig into all these

37
00:01:57,840 --> 00:02:00,060
bits of how a simple program like hello

38
00:02:00,060 --> 00:02:03,209
world works in order to change them in

39
00:02:03,209 --> 00:02:05,580
the right way to make this all work just

40
00:02:05,580 --> 00:02:07,979
a few more things about our architecture

41
00:02:07,979 --> 00:02:10,199
we replace integer pointers with

42
00:02:10,199 --> 00:02:12,840
unforgeable capabilities this means that

43
00:02:12,840 --> 00:02:14,940
you can't materialize pointers out of

44
00:02:14,940 --> 00:02:15,990
out of thin air

45
00:02:15,990 --> 00:02:19,650
you can't say you're the author of Lib

46
00:02:19,650 --> 00:02:21,209
Perl you can't download them off the

47
00:02:21,209 --> 00:02:23,880
internet by accident and run them you

48
00:02:23,880 --> 00:02:27,209
know things like that and as I said

49
00:02:27,209 --> 00:02:29,459
before we prevent buffer overflows and

50
00:02:29,459 --> 00:02:31,830
we also make compartmentalization

51
00:02:31,830 --> 00:02:34,620
extremely cheap we'd like to go be able

52
00:02:34,620 --> 00:02:36,989
to go from current compartmentalization

53
00:02:36,989 --> 00:02:38,069
where something like Chrome or Firefox

54
00:02:38,069 --> 00:02:40,980
has a process per tab we'd like to have

55
00:02:40,980 --> 00:02:43,140
a million compartments in your in your

56
00:02:43,140 --> 00:02:44,459
web browser

57
00:02:44,459 --> 00:02:47,640
so that's just an aside when I mentioned

58
00:02:47,640 --> 00:02:49,049
cherry throughout the talk that's the

59
00:02:49,049 --> 00:02:51,930
front that's what I'm talking about but

60
00:02:51,930 --> 00:02:53,670
now we'll dive into the way it works

61
00:02:53,670 --> 00:02:58,319
today on 64-bit MIPS so here's the first

62
00:02:58,319 --> 00:03:00,030
example

63
00:03:00,030 --> 00:03:02,939
from in Kerrigan and Richie's the C

64
00:03:02,939 --> 00:03:04,950
programming language it's quite simple

65
00:03:04,950 --> 00:03:06,989
all it does is print a string hello

66
00:03:06,989 --> 00:03:10,500
world course you'll notice that this

67
00:03:10,500 --> 00:03:13,230
particular code isn't actually valid C

68
00:03:13,230 --> 00:03:13,950
anymore

69
00:03:13,950 --> 00:03:15,629
so we need to make a few tweaks before

70
00:03:15,629 --> 00:03:18,680
we talk about it we need to declare the

71
00:03:18,680 --> 00:03:21,840
arguments to main or rather ignore them

72
00:03:21,840 --> 00:03:24,959
in this case and then that's a little

73
00:03:24,959 --> 00:03:27,480
boring so we're gonna take this one step

74
00:03:27,480 --> 00:03:29,519
further and make printf take a couple

75
00:03:29,519 --> 00:03:31,950
arguments one thing it's interesting

76
00:03:31,950 --> 00:03:37,769
here is that printf in C is pretty darn

77
00:03:37,769 --> 00:03:40,500
close to a complete test of the C

78
00:03:40,500 --> 00:03:43,650
programming language in runtime one

79
00:03:43,650 --> 00:03:45,150
person I talked to who wrote a different

80
00:03:45,150 --> 00:03:47,069
C like language said that they got to

81
00:03:47,069 --> 00:03:49,739
about 90% in their conformance suite

82
00:03:49,739 --> 00:03:52,019
before it was possible to run hello

83
00:03:52,019 --> 00:03:55,739
world so there's lots of complicated

84
00:03:55,739 --> 00:03:57,389
stuff behind the scenes and we'll start

85
00:03:57,389 --> 00:04:00,650
we'll start to dive into that a bit

86
00:04:00,650 --> 00:04:03,479
naively you might expect it this program

87
00:04:03,479 --> 00:04:05,430
it's actually something like this

88
00:04:05,430 --> 00:04:08,639
program where simply you have a string

89
00:04:08,639 --> 00:04:10,560
you smush the string bits together and

90
00:04:10,560 --> 00:04:13,379
you write them out you might further

91
00:04:13,379 --> 00:04:16,168
expect that it looks like this bit of

92
00:04:16,168 --> 00:04:20,639
MIPS assembly now this you know don't

93
00:04:20,639 --> 00:04:21,659
worry you don't really need to

94
00:04:21,659 --> 00:04:22,949
understand this to understand the talk

95
00:04:22,949 --> 00:04:25,500
but what happens here is we were putting

96
00:04:25,500 --> 00:04:28,169
the first argument this one here in the

97
00:04:28,169 --> 00:04:30,360
argue first argument register we're

98
00:04:30,360 --> 00:04:32,639
loading the address of the string down

99
00:04:32,639 --> 00:04:35,009
here into the second argument register

100
00:04:35,009 --> 00:04:37,740
the length here and then the system call

101
00:04:37,740 --> 00:04:39,570
number here and we're triggering a

102
00:04:39,570 --> 00:04:42,530
system call exception

103
00:04:44,890 --> 00:04:47,740
okay I will try to turn my body instead

104
00:04:47,740 --> 00:04:51,650
so we here at this point we call the

105
00:04:51,650 --> 00:04:54,980
system call and then we return from that

106
00:04:54,980 --> 00:04:59,090
system call and we exit you might think

107
00:04:59,090 --> 00:05:00,770
that's what's going on in the previous

108
00:05:00,770 --> 00:05:03,170
program here but it's actually quite a

109
00:05:03,170 --> 00:05:05,420
bit more complicated the assembly

110
00:05:05,420 --> 00:05:07,370
program previously compiles to nine

111
00:05:07,370 --> 00:05:10,760
instructions less than a kilobyte mostly

112
00:05:10,760 --> 00:05:17,060
random elf junk and it yeah

113
00:05:17,060 --> 00:05:20,210
however the minimal C program there and

114
00:05:20,210 --> 00:05:22,220
this is without printf or seemingly

115
00:05:22,220 --> 00:05:26,930
without printf so for 550 K so most of

116
00:05:26,930 --> 00:05:29,960
that it turns out is malloc and a bit of

117
00:05:29,960 --> 00:05:32,630
it is a localization and we'll get into

118
00:05:32,630 --> 00:05:34,610
that more so where does all this stuff

119
00:05:34,610 --> 00:05:38,540
come from this program didn't do

120
00:05:38,540 --> 00:05:41,120
anything requiring localization it did

121
00:05:41,120 --> 00:05:43,490
you know it has it has to basically make

122
00:05:43,490 --> 00:05:46,880
a simple system call so let's take a

123
00:05:46,880 --> 00:05:49,550
look at program linkage so you might be

124
00:05:49,550 --> 00:05:51,740
linking hello world here's a simple

125
00:05:51,740 --> 00:05:54,919
command line if you pass the rather

126
00:05:54,919 --> 00:05:58,070
strange argument to to your C compiler

127
00:05:58,070 --> 00:06:00,860
and this works on both GCC and clang of

128
00:06:00,860 --> 00:06:04,730
- hash hash hash you'll see what things

129
00:06:04,730 --> 00:06:07,430
it's invoking so here's the actual

130
00:06:07,430 --> 00:06:11,690
linkage command you notice it's a bit of

131
00:06:11,690 --> 00:06:14,930
a mess we have you know we have some

132
00:06:14,930 --> 00:06:16,820
simple stuff about the ABI that we're

133
00:06:16,820 --> 00:06:18,980
linking it statically that we're

134
00:06:18,980 --> 00:06:22,640
outputting it and then we have a bunch

135
00:06:22,640 --> 00:06:25,700
of extra files and so where did those

136
00:06:25,700 --> 00:06:27,230
come from and then we have some extra

137
00:06:27,230 --> 00:06:29,180
libraries and then we link in Lindsey

138
00:06:29,180 --> 00:06:32,120
implicitly and then finally some more

139
00:06:32,120 --> 00:06:36,050
files so what are those here's a quick

140
00:06:36,050 --> 00:06:40,340
table of the various bits so first of

141
00:06:40,340 --> 00:06:43,910
all CRT 1.0 this contains the actual

142
00:06:43,910 --> 00:06:46,070
function that gets started at the

143
00:06:46,070 --> 00:06:47,540
beginning of the program it's by

144
00:06:47,540 --> 00:06:49,640
convention on freebsd at least

145
00:06:49,640 --> 00:06:52,550
underscore underscore start and it's job

146
00:06:52,550 --> 00:06:54,729
is to call main

147
00:06:54,729 --> 00:06:59,509
next up is CRT I see RTI is a weird

148
00:06:59,509 --> 00:07:02,270
function is oh is a weird bit of code

149
00:07:02,270 --> 00:07:04,820
it contains the prologues - two

150
00:07:04,820 --> 00:07:06,320
functions underscore in it and

151
00:07:06,320 --> 00:07:10,100
underscore fee name all it does is set

152
00:07:10,100 --> 00:07:13,370
up a stack frame later code including

153
00:07:13,370 --> 00:07:15,530
any file in your program might conclude

154
00:07:15,530 --> 00:07:18,110
bits of that function as raw machine

155
00:07:18,110 --> 00:07:21,949
code it's a bit terrifying and it is

156
00:07:21,949 --> 00:07:23,479
deprecated but it's still nonetheless

157
00:07:23,479 --> 00:07:28,850
there next up some variant of CRT begin

158
00:07:28,850 --> 00:07:31,660
is included there's different ones for

159
00:07:31,660 --> 00:07:34,940
relocatable code shared code and for

160
00:07:34,940 --> 00:07:39,370
static code this includes the

161
00:07:39,370 --> 00:07:43,300
constructor and destructor sections and

162
00:07:43,300 --> 00:07:46,190
declares declares function calls to

163
00:07:46,190 --> 00:07:49,190
these finally there's CR TN which

164
00:07:49,190 --> 00:07:52,729
terminates those arrays and then there's

165
00:07:52,729 --> 00:07:56,840
their CRT end which contains the bits of

166
00:07:56,840 --> 00:07:58,280
the functions for an it and fini that

167
00:07:58,280 --> 00:08:01,729
actually return on FreeBSD the path is

168
00:08:01,729 --> 00:08:04,240
that they're included or there are here

169
00:08:04,240 --> 00:08:06,669
before I go on with the rest of the talk

170
00:08:06,669 --> 00:08:09,440
I'm gonna be showing you a lot of flame

171
00:08:09,440 --> 00:08:12,229
charts generated with traces that I've

172
00:08:12,229 --> 00:08:15,020
made with Q EMU with a customized QE mu

173
00:08:15,020 --> 00:08:18,169
and then generated and then the charts

174
00:08:18,169 --> 00:08:20,539
are generated with Brendan Greg's flame

175
00:08:20,539 --> 00:08:23,599
graph tool those charts are online is

176
00:08:23,599 --> 00:08:25,760
clickable SPG's so if you want to zoom

177
00:08:25,760 --> 00:08:28,699
in and out it's kind of neat otherwise

178
00:08:28,699 --> 00:08:32,958
you'll see them on the screen so we're

179
00:08:32,958 --> 00:08:36,708
gonna start before the program starts so

180
00:08:36,708 --> 00:08:38,620
if we're gonna look at the exact V

181
00:08:38,620 --> 00:08:42,020
system call exactly YZ job is to take a

182
00:08:42,020 --> 00:08:44,059
process and replace its entire contents

183
00:08:44,059 --> 00:08:48,290
with a new one so typically if say

184
00:08:48,290 --> 00:08:49,820
you're starting to starting hello world

185
00:08:49,820 --> 00:08:52,339
from a shell you will have forked the

186
00:08:52,339 --> 00:08:54,110
shell who made an extra process which is

187
00:08:54,110 --> 00:08:55,339
copy of the shell and then you're going

188
00:08:55,339 --> 00:08:56,990
to replace its contents with exactly

189
00:08:56,990 --> 00:09:00,290
using exec de on some operating systems

190
00:09:00,290 --> 00:09:01,580
you'll take a little more

191
00:09:01,580 --> 00:09:03,530
commonly used something like posix spawn

192
00:09:03,530 --> 00:09:04,990
which does both of these things at once

193
00:09:04,990 --> 00:09:07,220
which is convenient to that you don't

194
00:09:07,220 --> 00:09:08,690
have to set up a process that's a

195
00:09:08,690 --> 00:09:11,780
complicated copy of your batch or T sure

196
00:09:11,780 --> 00:09:15,440
whatever just to throw it all away but

197
00:09:15,440 --> 00:09:17,210
in this example we're going to look at

198
00:09:17,210 --> 00:09:21,530
exactly e so now we're gonna zoom in a

199
00:09:21,530 --> 00:09:25,550
bit the first bit of exact V is exact

200
00:09:25,550 --> 00:09:34,340
copy in Arms its job so it does a bit of

201
00:09:34,340 --> 00:09:38,060
memory allocation in the kernel and then

202
00:09:38,060 --> 00:09:41,780
it copies in the program path as well as

203
00:09:41,780 --> 00:09:43,910
all the command-line arguments for the

204
00:09:43,910 --> 00:09:46,340
program and all the environment that was

205
00:09:46,340 --> 00:09:48,770
passed to the program it has to get this

206
00:09:48,770 --> 00:09:51,140
out of the parent process and into the

207
00:09:51,140 --> 00:09:53,210
kernel so that can then be copied into

208
00:09:53,210 --> 00:09:59,780
the new process that's next up after

209
00:09:59,780 --> 00:10:01,820
that we move on to the next part which

210
00:10:01,820 --> 00:10:08,410
is the body of executives at ve function

211
00:10:08,830 --> 00:10:11,990
so inside their current exec fee is the

212
00:10:11,990 --> 00:10:14,270
general implementation in FreeBSD we

213
00:10:14,270 --> 00:10:16,340
have we separate the system call which

214
00:10:16,340 --> 00:10:19,100
is the sis underscore variant from the

215
00:10:19,100 --> 00:10:20,930
actual actual implementation in most

216
00:10:20,930 --> 00:10:23,240
cases the reason is for instance that we

217
00:10:23,240 --> 00:10:25,880
use the current version for both FreeBSD

218
00:10:25,880 --> 00:10:28,220
and Lennox emulation they have us they

219
00:10:28,220 --> 00:10:29,480
may have we may have to make some

220
00:10:29,480 --> 00:10:32,360
adjustments they say - to make make

221
00:10:32,360 --> 00:10:34,460
Linux work but the underlying bits of

222
00:10:34,460 --> 00:10:36,140
replacing the process are all the same

223
00:10:36,140 --> 00:10:39,740
similarly we use this so so we can run

224
00:10:39,740 --> 00:10:44,690
32-bit programs on 64-bit machines so

225
00:10:44,690 --> 00:10:47,000
the first bit of current exactly is a

226
00:10:47,000 --> 00:10:49,670
eases name I which is horrible and

227
00:10:49,670 --> 00:10:51,020
complicated and involved in the file

228
00:10:51,020 --> 00:10:52,340
system so we're not going to talk about

229
00:10:52,340 --> 00:10:54,230
it any further except to say that it's

230
00:10:54,230 --> 00:10:56,000
job is to resolve the path that was

231
00:10:56,000 --> 00:11:00,370
passed in and find it in the file system

232
00:11:00,370 --> 00:11:05,570
next up exact check permissions verifies

233
00:11:05,570 --> 00:11:06,920
that the file has the right permissions

234
00:11:06,920 --> 00:11:08,990
that were allowed to open it and execute

235
00:11:08,990 --> 00:11:11,300
it and then it opens it

236
00:11:11,300 --> 00:11:14,060
just a bit mashed together but that's

237
00:11:14,060 --> 00:11:19,940
how it is then exact map first page does

238
00:11:19,940 --> 00:11:21,740
is about what you'd expect it maps the

239
00:11:21,740 --> 00:11:23,209
first page worth of data from the

240
00:11:23,209 --> 00:11:25,580
program it does this so that it can

241
00:11:25,580 --> 00:11:27,320
examine the headers in the program and

242
00:11:27,320 --> 00:11:29,660
determine whether for instance it is at

243
00:11:29,660 --> 00:11:31,670
actual elf executable as we're talking

244
00:11:31,670 --> 00:11:34,160
about or perhaps a shell script where it

245
00:11:34,160 --> 00:11:39,370
needs to find a find a a program to run

246
00:11:39,670 --> 00:11:45,740
now the body the main part here is a is

247
00:11:45,740 --> 00:11:49,339
elf is this executive image act it's an

248
00:11:49,339 --> 00:11:50,870
image activator which is what we call

249
00:11:50,870 --> 00:11:52,490
the thing that takes a program and

250
00:11:52,490 --> 00:11:57,019
instantiates it into memory so if you

251
00:11:57,019 --> 00:11:59,180
were wanting to dig into this part a bit

252
00:11:59,180 --> 00:12:02,839
more one hint all the elf things in

253
00:12:02,839 --> 00:12:05,240
previous dr compiled in a very are named

254
00:12:05,240 --> 00:12:07,370
in a very strange way so that 32-bit and

255
00:12:07,370 --> 00:12:10,279
64-bit code can be shared this bit down

256
00:12:10,279 --> 00:12:11,810
here is what the function declaration

257
00:12:11,810 --> 00:12:13,940
looks like so if you're trying to find

258
00:12:13,940 --> 00:12:16,070
this particular one it's not a whole lot

259
00:12:16,070 --> 00:12:18,470
of fun unless you know where to look I

260
00:12:18,470 --> 00:12:20,510
include this largely because I was

261
00:12:20,510 --> 00:12:22,180
writing up a paper version of this talk

262
00:12:22,180 --> 00:12:24,649
recently and it took me about 10 minutes

263
00:12:24,649 --> 00:12:26,180
to figure out where the darn thing was

264
00:12:26,180 --> 00:12:28,790
so thought a little hint might be

265
00:12:28,790 --> 00:12:33,829
appropriate so the first bit of the

266
00:12:33,829 --> 00:12:37,910
image activator is a call to exact new

267
00:12:37,910 --> 00:12:40,520
namespace which does kind of what you

268
00:12:40,520 --> 00:12:42,440
might think just to say it takes the

269
00:12:42,440 --> 00:12:44,870
process or and it rips all the VM space

270
00:12:44,870 --> 00:12:46,670
out so it rips all the page mappings out

271
00:12:46,670 --> 00:12:48,500
and you end up now with an empty process

272
00:12:48,500 --> 00:12:51,490
which has no memory behind it

273
00:12:51,490 --> 00:12:57,500
next up so internally sorry it goes in

274
00:12:57,500 --> 00:13:01,120
rips out rips out all the pages and then

275
00:13:01,120 --> 00:13:04,970
it Maps a stack an initial stack into

276
00:13:04,970 --> 00:13:06,740
the process address space as you can see

277
00:13:06,740 --> 00:13:10,130
down here at the bottom from there we

278
00:13:10,130 --> 00:13:11,899
get back into the image activator code

279
00:13:11,899 --> 00:13:13,339
whose job it is to actually load the

280
00:13:13,339 --> 00:13:19,640
program first elf load section maps the

281
00:13:19,640 --> 00:13:22,130
text segment of memory into memory for

282
00:13:22,130 --> 00:13:23,570
those who aren't familiar with with the

283
00:13:23,570 --> 00:13:23,810
tech

284
00:13:23,810 --> 00:13:25,310
saying that the tech segment is the part

285
00:13:25,310 --> 00:13:26,360
of the program that contains the

286
00:13:26,360 --> 00:13:29,240
executable code as well as typically

287
00:13:29,240 --> 00:13:32,540
some constants related to execution for

288
00:13:32,540 --> 00:13:35,480
instance offsets for jump tables and the

289
00:13:35,480 --> 00:13:39,529
like next up another call to L flowed

290
00:13:39,529 --> 00:13:43,640
section Maps data and the BSS region

291
00:13:43,640 --> 00:13:45,710
which is the part of data which is

292
00:13:45,710 --> 00:13:48,740
initialized to zero so for instance some

293
00:13:48,740 --> 00:13:50,180
random global variable that you've

294
00:13:50,180 --> 00:13:52,460
declared it will default to being zero

295
00:13:52,460 --> 00:13:54,380
and that's part of the application

296
00:13:54,380 --> 00:13:56,510
binary interface for basic UNIX

297
00:13:56,510 --> 00:14:03,800
processes so back to current exec fee we

298
00:14:03,800 --> 00:14:06,050
now have much of the program Maps and

299
00:14:06,050 --> 00:14:09,230
now we're going to copy out the various

300
00:14:09,230 --> 00:14:12,260
arguments and environment bits and a few

301
00:14:12,260 --> 00:14:13,339
other things that we'll get to in a

302
00:14:13,339 --> 00:14:16,810
minute to the end of the stack

303
00:14:18,380 --> 00:14:22,220
finally this exact set regs function

304
00:14:22,220 --> 00:14:24,710
sets up the registers of the processor

305
00:14:24,710 --> 00:14:26,930
so that when the system called the exec

306
00:14:26,930 --> 00:14:30,380
the system call returns it returns into

307
00:14:30,380 --> 00:14:31,790
a call to the underscore underscore

308
00:14:31,790 --> 00:14:33,950
start function so we're actually about

309
00:14:33,950 --> 00:14:39,620
to get ready to actually run code so

310
00:14:39,620 --> 00:14:43,339
back dis exec fee we have set up all of

311
00:14:43,339 --> 00:14:45,050
our memory we have mapped all of our

312
00:14:45,050 --> 00:14:46,730
bits and now we're about to return to

313
00:14:46,730 --> 00:14:50,540
the address space so as a recap the

314
00:14:50,540 --> 00:14:52,220
staffing stack has been mapped into the

315
00:14:52,220 --> 00:14:53,720
address space the program has been

316
00:14:53,720 --> 00:14:56,650
mapped into the address space and

317
00:14:56,650 --> 00:14:59,990
various strings environment variables

318
00:14:59,990 --> 00:15:02,540
have been copied in as well as signal

319
00:15:02,540 --> 00:15:06,170
handler and some other bits so a bit of

320
00:15:06,170 --> 00:15:08,360
an aside on those various bits that are

321
00:15:08,360 --> 00:15:10,580
copied in despite the fact that we're on

322
00:15:10,580 --> 00:15:14,780
MIPS we're using the scope I 3 d6 ABI

323
00:15:14,780 --> 00:15:17,240
and in fact on basically every process

324
00:15:17,240 --> 00:15:20,810
we followed this ABI this is how memory

325
00:15:20,810 --> 00:15:23,510
is laid out so that when we enter the

326
00:15:23,510 --> 00:15:25,370
program we can call the we can find

327
00:15:25,370 --> 00:15:27,800
things we need to find so there's a

328
00:15:27,800 --> 00:15:29,630
bunch of bits here most of the bits to

329
00:15:29,630 --> 00:15:32,600
the far right are FreeBSD specific so PS

330
00:15:32,600 --> 00:15:34,880
strings cig code is the signal return

331
00:15:34,880 --> 00:15:35,480
trample

332
00:15:35,480 --> 00:15:37,790
when half a signal handler and it exit

333
00:15:37,790 --> 00:15:40,730
it returns the cig code is responsible

334
00:15:40,730 --> 00:15:42,110
for actually getting you back into the

335
00:15:42,110 --> 00:15:44,870
kernel this is in fact a terrible idea

336
00:15:44,870 --> 00:15:46,389
and we need to take it off the stack

337
00:15:46,389 --> 00:15:49,250
because currently requires the stack to

338
00:15:49,250 --> 00:15:52,970
be executable there's some other bits

339
00:15:52,970 --> 00:15:56,480
here and then currently sharing on the

340
00:15:56,480 --> 00:15:58,550
on the far left of that orange section

341
00:15:58,550 --> 00:16:01,430
is where all the strings for the

342
00:16:01,430 --> 00:16:03,170
environment and all your argument

343
00:16:03,170 --> 00:16:07,310
vectors are stored next up there is the

344
00:16:07,310 --> 00:16:09,260
elf axillary arguments array this

345
00:16:09,260 --> 00:16:11,829
contains a bunch of information about

346
00:16:11,829 --> 00:16:14,269
your process where it's about your

347
00:16:14,269 --> 00:16:15,740
program where it's mapped into memory

348
00:16:15,740 --> 00:16:19,100
where the start address is basically it

349
00:16:19,100 --> 00:16:20,870
allows the program and the runtime

350
00:16:20,870 --> 00:16:22,610
linker if you were doing right if you

351
00:16:22,610 --> 00:16:25,820
were using a dynamic program to find a

352
00:16:25,820 --> 00:16:27,320
bunch of things about the program

353
00:16:27,320 --> 00:16:28,970
without having to parse the entire

354
00:16:28,970 --> 00:16:31,959
executable which is rather expensive

355
00:16:31,959 --> 00:16:34,459
additionally it gets used for things

356
00:16:34,459 --> 00:16:36,800
like for instance a pointer to the stack

357
00:16:36,800 --> 00:16:38,389
canary value which is a randomly

358
00:16:38,389 --> 00:16:41,300
generated string and it's just

359
00:16:41,300 --> 00:16:42,949
convenient to use so it keeps getting

360
00:16:42,949 --> 00:16:45,019
extended and extended as people add new

361
00:16:45,019 --> 00:16:48,350
features next up is the environment

362
00:16:48,350 --> 00:16:51,260
array this is the array of pointers into

363
00:16:51,260 --> 00:16:54,079
this set of strings for the name value

364
00:16:54,079 --> 00:16:55,399
pairs for all the things in your

365
00:16:55,399 --> 00:16:58,730
environment likewise the Arg V array and

366
00:16:58,730 --> 00:17:03,560
then the argument count all of this

367
00:17:03,560 --> 00:17:05,990
looks a bit like how you would call a

368
00:17:05,990 --> 00:17:10,429
function in under an I 3 D 6 system and

369
00:17:10,429 --> 00:17:11,900
that's because that's where this

370
00:17:11,900 --> 00:17:15,140
convention came from one oddity here is

371
00:17:15,140 --> 00:17:17,660
that well art the Argosy argument of the

372
00:17:17,660 --> 00:17:20,480
main program is an integer here it's

373
00:17:20,480 --> 00:17:23,449
always a long because that allows the

374
00:17:23,449 --> 00:17:25,280
stack to remain properly aligned on

375
00:17:25,280 --> 00:17:28,910
64-bit machines so at this point the

376
00:17:28,910 --> 00:17:30,770
stack pointer on return is set to this

377
00:17:30,770 --> 00:17:34,820
is that to Arg C and it's also passed as

378
00:17:34,820 --> 00:17:36,610
the first argument to the start function

379
00:17:36,610 --> 00:17:40,429
and with that's used to derive values

380
00:17:40,429 --> 00:17:42,380
and sort of and get the arguments

381
00:17:42,380 --> 00:17:44,810
required for main ready to go

382
00:17:44,810 --> 00:17:47,340
so now we're ready to jump into user

383
00:17:47,340 --> 00:17:50,970
space so starting in underscore

384
00:17:50,970 --> 00:17:53,070
underscore start which is in execution

385
00:17:53,070 --> 00:17:56,880
for the entire life of the program one

386
00:17:56,880 --> 00:17:58,650
thing you wouldn't you'd notice here if

387
00:17:58,650 --> 00:18:01,350
you look at it carefully is that there's

388
00:18:01,350 --> 00:18:03,470
a lot of je underscore functions in here

389
00:18:03,470 --> 00:18:06,330
and in fact this program spends almost

390
00:18:06,330 --> 00:18:10,890
all of its time in malloc so J malloc is

391
00:18:10,890 --> 00:18:15,440
in fact about 880 thousand lines of code

392
00:18:15,440 --> 00:18:18,870
it's part of that portability but it is

393
00:18:18,870 --> 00:18:21,360
a beast and so for a program this

394
00:18:21,360 --> 00:18:23,310
trivial it's way overkill it's a super

395
00:18:23,310 --> 00:18:25,070
high-performance threaded allocator

396
00:18:25,070 --> 00:18:28,830
but in this case we pay a lot of

397
00:18:28,830 --> 00:18:30,600
overhead I'm not gonna dive a whole lot

398
00:18:30,600 --> 00:18:34,800
into how malloc works but just want to

399
00:18:34,800 --> 00:18:36,990
point out that there is a awful lot of

400
00:18:36,990 --> 00:18:40,320
the cycles are spent there so underscore

401
00:18:40,320 --> 00:18:42,060
start the first half of underscore start

402
00:18:42,060 --> 00:18:46,020
which is a very simple function sets up

403
00:18:46,020 --> 00:18:50,960
arrgh CRV and an environment pointer

404
00:18:50,960 --> 00:18:54,180
these are then passed to this to this

405
00:18:54,180 --> 00:18:57,060
function handle RV which takes them in

406
00:18:57,060 --> 00:19:01,020
sets and processes arc C&R to be a

407
00:19:01,020 --> 00:19:03,060
little bit and then sets up the

408
00:19:03,060 --> 00:19:06,270
environment pointer the environ array

409
00:19:06,270 --> 00:19:08,130
also sets the program name variable

410
00:19:08,130 --> 00:19:11,210
which is used to for programs to query

411
00:19:11,210 --> 00:19:16,110
how they were at how they were run next

412
00:19:16,110 --> 00:19:19,020
up an it TLS this is actually why this

413
00:19:19,020 --> 00:19:24,510
program is so big so an it TLS sets up

414
00:19:24,510 --> 00:19:26,430
thread-local storage so thread-local

415
00:19:26,430 --> 00:19:28,500
storage is much like global variables

416
00:19:28,500 --> 00:19:31,140
except that their per thread you might

417
00:19:31,140 --> 00:19:33,900
think it's a simple hello world why why

418
00:19:33,900 --> 00:19:36,000
do I have thread-local variables but

419
00:19:36,000 --> 00:19:40,230
turns out that printf is localized which

420
00:19:40,230 --> 00:19:42,150
means for instance that the decimal

421
00:19:42,150 --> 00:19:44,240
character could be different

422
00:19:44,240 --> 00:19:46,520
and therefore you need to have a a per

423
00:19:46,520 --> 00:19:49,460
thread locale available and there's a

424
00:19:49,460 --> 00:19:51,080
there's a number of other things related

425
00:19:51,080 --> 00:19:52,610
to Mal'akh but that's that's the main

426
00:19:52,610 --> 00:19:56,180
thing as with the rest of the program

427
00:19:56,180 --> 00:19:59,420
most of the time is spent in Mallik the

428
00:19:59,420 --> 00:20:01,700
first thing that a NIT TLS does is it

429
00:20:01,700 --> 00:20:03,650
has to find the elf axillary arguments

430
00:20:03,650 --> 00:20:06,590
vector as you might recall that vector

431
00:20:06,590 --> 00:20:10,460
lives after the art after the

432
00:20:10,460 --> 00:20:12,950
environment array so in fact this lovely

433
00:20:12,950 --> 00:20:14,840
bit of code finds the exhilarate

434
00:20:14,840 --> 00:20:17,390
arguments factor we take the environment

435
00:20:17,390 --> 00:20:19,310
the environment er that was previously

436
00:20:19,310 --> 00:20:22,550
set up we walked to the end of the array

437
00:20:22,550 --> 00:20:26,060
and then we walk off of it this is of

438
00:20:26,060 --> 00:20:28,010
course not defined behavior in C but

439
00:20:28,010 --> 00:20:33,680
nonetheless this is what we do and in

440
00:20:33,680 --> 00:20:36,800
fact on the Cherry processor where we

441
00:20:36,800 --> 00:20:38,660
have memory safety we have had to take a

442
00:20:38,660 --> 00:20:41,120
different approach here because if you

443
00:20:41,120 --> 00:20:42,680
have Buffalo buffalo protections

444
00:20:42,680 --> 00:20:44,420
defeating them just so that you can do

445
00:20:44,420 --> 00:20:45,950
silly things like walk off the end of

446
00:20:45,950 --> 00:20:48,200
one array to find the next one it's not

447
00:20:48,200 --> 00:20:52,160
a good idea so we find this elf axillary

448
00:20:52,160 --> 00:20:55,160
arguments array we use that to find the

449
00:20:55,160 --> 00:20:57,440
program headers there's a field in there

450
00:20:57,440 --> 00:20:59,300
that says the program headers are are in

451
00:20:59,300 --> 00:21:01,670
the right place we use the program

452
00:21:01,670 --> 00:21:03,470
headers to find the tls section this

453
00:21:03,470 --> 00:21:05,300
contains the initial values of all

454
00:21:05,300 --> 00:21:07,010
thread-local variables which aren't

455
00:21:07,010 --> 00:21:11,920
initialized to 0 we do a bit of

456
00:21:11,920 --> 00:21:14,870
allocation to allocate some space for

457
00:21:14,870 --> 00:21:17,180
TLS that results in that all those

458
00:21:17,180 --> 00:21:21,200
cycles spent on calling malloc and we

459
00:21:21,200 --> 00:21:23,060
copy over the initial values for the non

460
00:21:23,060 --> 00:21:25,659
0 bit

461
00:21:27,180 --> 00:21:30,430
yes yeah so the funny names here in part

462
00:21:30,430 --> 00:21:32,830
because J Malik uses TLS extensively but

463
00:21:32,830 --> 00:21:35,290
yet we need to use malloc to allocate

464
00:21:35,290 --> 00:21:38,170
our TLS storage because if we were a

465
00:21:38,170 --> 00:21:39,970
dynamic program we might later load a

466
00:21:39,970 --> 00:21:42,730
library but also needed to allocate TLS

467
00:21:42,730 --> 00:21:44,710
and at that point we might need to free

468
00:21:44,710 --> 00:21:46,930
the current allocation and so there are

469
00:21:46,930 --> 00:21:48,610
other ways around it but the current

470
00:21:48,610 --> 00:21:50,710
solution is in fact to just allocate

471
00:21:50,710 --> 00:21:53,500
some space finally we set the TLS

472
00:21:53,500 --> 00:21:56,590
pointer one interesting thing of here on

473
00:21:56,590 --> 00:21:59,410
myths is that historically that was done

474
00:21:59,410 --> 00:22:02,560
through a system call which was fine

475
00:22:02,560 --> 00:22:03,910
when no one was using thread local

476
00:22:03,910 --> 00:22:05,200
storage

477
00:22:05,200 --> 00:22:07,060
it was also retrieved through a system

478
00:22:07,060 --> 00:22:08,680
call it's probably okay to set it

479
00:22:08,680 --> 00:22:10,000
through the system call we don't do it

480
00:22:10,000 --> 00:22:10,600
very often

481
00:22:10,600 --> 00:22:12,520
but retrieving it through a system calm

482
00:22:12,520 --> 00:22:14,860
it but every call to malloc required a

483
00:22:14,860 --> 00:22:18,310
system call we fixed that recently is it

484
00:22:18,310 --> 00:22:19,420
apparent that people are not paying

485
00:22:19,420 --> 00:22:24,220
enough attention to our MIT platform so

486
00:22:24,220 --> 00:22:27,340
out of an it TLS we're gonna return to

487
00:22:27,340 --> 00:22:28,630
underscore star underscore underscore

488
00:22:28,630 --> 00:22:32,500
start and this handle static init

489
00:22:32,500 --> 00:22:34,720
function is responsible for calling all

490
00:22:34,720 --> 00:22:36,930
the initializers at program startup

491
00:22:36,930 --> 00:22:38,820
through a variety of historical

492
00:22:38,820 --> 00:22:41,230
accidents and inability to deprecate

493
00:22:41,230 --> 00:22:44,860
functionality there are four different

494
00:22:44,860 --> 00:22:47,380
ways to call it to call a bit of code to

495
00:22:47,380 --> 00:22:49,830
initialize something in your program

496
00:22:49,830 --> 00:22:52,540
there's a there's an array of function

497
00:22:52,540 --> 00:22:54,940
pointers called the pre anit array which

498
00:22:54,940 --> 00:22:56,860
presumably exists because of the anit

499
00:22:56,860 --> 00:22:58,720
array that you see at the bottom people

500
00:22:58,720 --> 00:23:00,660
realize they need to do things earlier

501
00:23:00,660 --> 00:23:03,100
there's the underscore init function I

502
00:23:03,100 --> 00:23:06,970
alluded to hope to before which is this

503
00:23:06,970 --> 00:23:08,950
terrifying thing where you smash a bunch

504
00:23:08,950 --> 00:23:10,600
of assembly code together and hope that

505
00:23:10,600 --> 00:23:11,890
it goes in the right order and doesn't

506
00:23:11,890 --> 00:23:13,600
have any side effects and then you call

507
00:23:13,600 --> 00:23:16,150
it as a function and then there's the

508
00:23:16,150 --> 00:23:19,900
see tors array in at least the variant

509
00:23:19,900 --> 00:23:23,170
of the canary startup code in freebsd

510
00:23:23,170 --> 00:23:25,540
that's actually called via in it there's

511
00:23:25,540 --> 00:23:27,310
not really a good reason why it couldn't

512
00:23:27,310 --> 00:23:29,180
be called by some other mechanism

513
00:23:29,180 --> 00:23:32,150
but it is currently the one thing that

514
00:23:32,150 --> 00:23:39,020
uses the net in the system so now we get

515
00:23:39,020 --> 00:23:40,790
to the point where start is about to

516
00:23:40,790 --> 00:23:42,260
call mein so we're actually going to run

517
00:23:42,260 --> 00:23:43,880
our program it's very exciting

518
00:23:43,880 --> 00:23:45,560
you know we're twenty two minutes into

519
00:23:45,560 --> 00:23:49,280
my talk and we can start to we can start

520
00:23:49,280 --> 00:23:52,070
to actually run some code or at least

521
00:23:52,070 --> 00:23:56,330
the code we thought we were running so

522
00:23:56,330 --> 00:23:59,150
what happens in main is it calls printf

523
00:23:59,150 --> 00:24:02,360
printf calls VF printf which is the

524
00:24:02,360 --> 00:24:05,240
underlying implementation in freebsd no

525
00:24:05,240 --> 00:24:07,280
matter what you're printing - you're

526
00:24:07,280 --> 00:24:10,400
always printing through a file a file

527
00:24:10,400 --> 00:24:13,910
struct and it's either one that's

528
00:24:13,910 --> 00:24:16,540
printing to standard output to an output

529
00:24:16,540 --> 00:24:19,370
file or it could be to us something that

530
00:24:19,370 --> 00:24:21,830
it's impending to a string in this case

531
00:24:21,830 --> 00:24:26,480
we're printing to standard out so as I

532
00:24:26,480 --> 00:24:28,670
said before here's why we need GLS we

533
00:24:28,670 --> 00:24:31,700
need to call get locale so that we have

534
00:24:31,700 --> 00:24:34,970
our current locale and we can pass it on

535
00:24:34,970 --> 00:24:36,790
to the localized version of printf

536
00:24:36,790 --> 00:24:42,320
inside it does a bit of work it's not

537
00:24:42,320 --> 00:24:44,210
very complicated it just but it is

538
00:24:44,210 --> 00:24:45,860
something that has to be done

539
00:24:45,860 --> 00:24:49,720
so back in VF printf PF printf calls

540
00:24:49,720 --> 00:24:52,640
underscore VF printf yeah abstraction

541
00:24:52,640 --> 00:24:54,470
here's the comment from the top of the

542
00:24:54,470 --> 00:24:56,990
file this code is large and complicated

543
00:24:56,990 --> 00:24:59,870
it's not that bad files only a thousand

544
00:24:59,870 --> 00:25:02,990
lines you know it could be worse it does

545
00:25:02,990 --> 00:25:04,820
make use of extensive use of macros

546
00:25:04,820 --> 00:25:06,650
though so the code is in fact a bit

547
00:25:06,650 --> 00:25:08,980
bigger than that

548
00:25:08,980 --> 00:25:14,270
so now you know as you as usual all this

549
00:25:14,270 --> 00:25:17,390
bit is allocating a buffer this is done

550
00:25:17,390 --> 00:25:19,310
the first time and not done again but

551
00:25:19,310 --> 00:25:22,250
nonetheless we spend a lot of time

552
00:25:22,250 --> 00:25:25,130
allocating memory so let's get into the

553
00:25:25,130 --> 00:25:28,040
part that's actually interesting so here

554
00:25:28,040 --> 00:25:29,810
we're getting ready to print our string

555
00:25:29,810 --> 00:25:33,110
and what we see happen is the first

556
00:25:33,110 --> 00:25:37,430
thing we do in printf is we for reasons

557
00:25:37,430 --> 00:25:39,970
of historical laziness

558
00:25:39,970 --> 00:25:41,990
always look up the decimal point

559
00:25:41,990 --> 00:25:44,600
separator and get into the function this

560
00:25:44,600 --> 00:25:46,790
involves taking that locale we were

561
00:25:46,790 --> 00:25:50,630
passed and querying it and asking so if

562
00:25:50,630 --> 00:25:52,700
I did happen to have to print a

563
00:25:52,700 --> 00:25:54,410
floating-point number

564
00:25:54,410 --> 00:25:56,510
how would I separate it the whole part

565
00:25:56,510 --> 00:26:01,340
from the fractional part after that

566
00:26:01,340 --> 00:26:04,820
after that the print the function

567
00:26:04,820 --> 00:26:09,800
allocates it a structure containing 8 up

568
00:26:09,800 --> 00:26:12,530
to 8 strings which are which will be

569
00:26:12,530 --> 00:26:15,020
concatenated together for each section

570
00:26:15,020 --> 00:26:18,110
of the of the string that's being

571
00:26:18,110 --> 00:26:21,110
printed the reason for 8 is due to the

572
00:26:21,110 --> 00:26:22,310
details of floating points and I

573
00:26:22,310 --> 00:26:23,480
probably should have put a slide in here

574
00:26:23,480 --> 00:26:26,600
on that but it's the various sections so

575
00:26:26,600 --> 00:26:29,810
the the bit preceding the first format

576
00:26:29,810 --> 00:26:32,270
you find whether or not it has a sign

577
00:26:32,270 --> 00:26:35,390
whether or not it's a hexadecimal thing

578
00:26:35,390 --> 00:26:39,740
a number a decimal point things after

579
00:26:39,740 --> 00:26:43,490
the decimal point and somehow that adds

580
00:26:43,490 --> 00:26:49,520
up to 8 so the way this code works is it

581
00:26:49,520 --> 00:26:52,040
loops through the string looking for

582
00:26:52,040 --> 00:26:55,100
formats so at the beginning we find out

583
00:26:55,100 --> 00:26:58,430
we have a percent s so it finds a finds

584
00:26:58,430 --> 00:27:01,220
a percent sign and then parses the

585
00:27:01,220 --> 00:27:03,260
format and says oh simple I got I got a

586
00:27:03,260 --> 00:27:07,970
type so I've got a string here so that's

587
00:27:07,970 --> 00:27:10,220
that's quite straightforward it takes

588
00:27:10,220 --> 00:27:13,310
that and it sends a sync this i/o buffer

589
00:27:13,310 --> 00:27:16,340
which just contains a pointer to this

590
00:27:16,340 --> 00:27:20,420
hello string that gets accumulated and

591
00:27:20,420 --> 00:27:23,330
doesn't get printed just yet because the

592
00:27:23,330 --> 00:27:25,820
standard behavior of printf is that IO

593
00:27:25,820 --> 00:27:28,610
is buffered otherwise we'd spend forever

594
00:27:28,610 --> 00:27:30,650
making write system calls to write out a

595
00:27:30,650 --> 00:27:32,860
simple string

596
00:27:32,860 --> 00:27:35,620
next up having parsed that one we get

597
00:27:35,620 --> 00:27:37,000
into the next stage where we repeat the

598
00:27:37,000 --> 00:27:39,130
process this time we parse a bit and

599
00:27:39,130 --> 00:27:41,430
find a space and then we find a percent

600
00:27:41,430 --> 00:27:44,500
so we have once a single character

601
00:27:44,500 --> 00:27:46,180
string that we've appended to our buffer

602
00:27:46,180 --> 00:27:51,120
or our vector then we have our number

603
00:27:51,120 --> 00:27:53,920
there's a internally allocated buffer

604
00:27:53,920 --> 00:27:56,590
that's used to render this integer into

605
00:27:56,590 --> 00:28:02,500
a string and that's buffered so that's

606
00:28:02,500 --> 00:28:05,380
that's added to the file structure next

607
00:28:05,380 --> 00:28:10,510
up we find the /n the /n because of the

608
00:28:10,510 --> 00:28:14,080
buffering behavior triggers will trigger

609
00:28:14,080 --> 00:28:16,810
or write so we'll get to that now we're

610
00:28:16,810 --> 00:28:18,220
going to look at the S print function a

611
00:28:18,220 --> 00:28:22,450
bit s print parses that parses the set

612
00:28:22,450 --> 00:28:25,840
of vectors and looks over each one of

613
00:28:25,840 --> 00:28:28,240
them looking to see if there's a newline

614
00:28:28,240 --> 00:28:31,810
character that newline character will

615
00:28:31,810 --> 00:28:33,520
only exist in the first buffer in normal

616
00:28:33,520 --> 00:28:35,860
circumstances so it does a stir char on

617
00:28:35,860 --> 00:28:38,230
every output buffer this is a bit

618
00:28:38,230 --> 00:28:40,270
suboptimal but it does does do it that

619
00:28:40,270 --> 00:28:43,230
way so it finds a newline character

620
00:28:43,230 --> 00:28:46,900
because of that we will later call F

621
00:28:46,900 --> 00:28:51,430
flush these responsibilities it is to to

622
00:28:51,430 --> 00:28:56,160
actually call write and at this point

623
00:28:56,160 --> 00:29:00,140
get our output

624
00:29:06,830 --> 00:29:10,080
now as you probably noticed nothing is

625
00:29:10,080 --> 00:29:14,100
ever simple so so now we're gonna return

626
00:29:14,100 --> 00:29:16,170
out of printf in domain main we'll

627
00:29:16,170 --> 00:29:20,220
return to start returning a value and

628
00:29:20,220 --> 00:29:22,650
start now has to exit it calls the exit

629
00:29:22,650 --> 00:29:24,270
function which is not in fact a system

630
00:29:24,270 --> 00:29:25,770
call it's a wrapper around the system

631
00:29:25,770 --> 00:29:31,710
call which does a bunch of stuff so the

632
00:29:31,710 --> 00:29:34,650
first thing it does is when I was

633
00:29:34,650 --> 00:29:37,020
talking about initialization earlier all

634
00:29:37,020 --> 00:29:38,940
of those initialization methods have a

635
00:29:38,940 --> 00:29:42,450
counterpart for destructors or finalizes

636
00:29:42,450 --> 00:29:43,940
so there's a for the init function

637
00:29:43,940 --> 00:29:48,540
there's a Fein a function for C tours

638
00:29:48,540 --> 00:29:50,280
there's detours there's destructors to

639
00:29:50,280 --> 00:29:52,760
go at the Constructors and there's also

640
00:29:52,760 --> 00:29:57,000
a femaie array of function pointers in

641
00:29:57,000 --> 00:29:59,280
this program none of them actually get

642
00:29:59,280 --> 00:30:02,340
called to speak of but one other one

643
00:30:02,340 --> 00:30:04,050
function does get called which is this

644
00:30:04,050 --> 00:30:06,330
underscore cleanup function it's job is

645
00:30:06,330 --> 00:30:08,070
to ensure that any buffered file

646
00:30:08,070 --> 00:30:10,230
descriptors which still have output get

647
00:30:10,230 --> 00:30:13,800
flushed in our case that there aren't

648
00:30:13,800 --> 00:30:15,300
there aren't any of those because we

649
00:30:15,300 --> 00:30:16,800
have actually we've successfully flushed

650
00:30:16,800 --> 00:30:21,480
the file descriptor but it it would take

651
00:30:21,480 --> 00:30:22,980
care of that if we had not included that

652
00:30:22,980 --> 00:30:29,180
/n finally it calls exit and the program

653
00:30:29,180 --> 00:30:34,110
exits so that was all a static binary

654
00:30:34,110 --> 00:30:35,820
i'm gonna give you a very brief view of

655
00:30:35,820 --> 00:30:38,310
what a dynamic by of how a dynamic

656
00:30:38,310 --> 00:30:43,470
binary differs so as you recall in our

657
00:30:43,470 --> 00:30:45,570
previous our previous program we had

658
00:30:45,570 --> 00:30:48,990
memory we had a program data text and

659
00:30:48,990 --> 00:30:52,890
and the stack in a dynamic binary the

660
00:30:52,890 --> 00:30:55,830
program needs to load libraries in order

661
00:30:55,830 --> 00:30:58,740
to do its work for that to happen the

662
00:30:58,740 --> 00:31:00,390
kernel in addition to loading to program

663
00:31:00,390 --> 00:31:04,050
loads the runs fine linker the runs and

664
00:31:04,050 --> 00:31:07,260
enters the runtime linker initially the

665
00:31:07,260 --> 00:31:10,530
runtime linker relocates itself because

666
00:31:10,530 --> 00:31:12,090
it might end up anywhere depending on

667
00:31:12,090 --> 00:31:14,309
how big the program is

668
00:31:14,309 --> 00:31:16,860
and then it loads and relocates lid see

669
00:31:16,860 --> 00:31:19,470
this is in fact almost all the work that

670
00:31:19,470 --> 00:31:23,610
this program does in fact so it loads

671
00:31:23,610 --> 00:31:25,409
Livesey here and it does a bit of

672
00:31:25,409 --> 00:31:28,650
blinking it hand it resolves global

673
00:31:28,650 --> 00:31:30,659
variables as required does a bit of

674
00:31:30,659 --> 00:31:33,960
setup and then it calls underscore start

675
00:31:33,960 --> 00:31:36,450
which is this tiny little box on the

676
00:31:36,450 --> 00:31:39,090
right and that was the whole previous

677
00:31:39,090 --> 00:31:40,830
talk except now it's more complicated

678
00:31:40,830 --> 00:31:46,200
and does more work so here we are in

679
00:31:46,200 --> 00:31:49,230
underscore start the first thing it does

680
00:31:49,230 --> 00:31:51,990
is called printf but printf is in Lib C

681
00:31:51,990 --> 00:31:55,860
so it has to resolve it has to look up

682
00:31:55,860 --> 00:31:58,380
the address in Lib C it does this at all

683
00:31:58,380 --> 00:32:00,750
it does this lazily because if we were

684
00:32:00,750 --> 00:32:03,090
if it were to look up every address all

685
00:32:03,090 --> 00:32:05,399
right every function in Lindsey and do

686
00:32:05,399 --> 00:32:06,390
something with it that would be

687
00:32:06,390 --> 00:32:08,669
tremendously wasteful even just the ones

688
00:32:08,669 --> 00:32:11,190
that were accessed that are potentially

689
00:32:11,190 --> 00:32:13,590
called by this program and are known to

690
00:32:13,590 --> 00:32:14,789
the linker would still be fairly

691
00:32:14,789 --> 00:32:17,520
wasteful because in fact most functions

692
00:32:17,520 --> 00:32:18,720
that are linked to Lindsey in a small

693
00:32:18,720 --> 00:32:20,880
program like this are probably things

694
00:32:20,880 --> 00:32:22,740
related to error handling of errors that

695
00:32:22,740 --> 00:32:29,520
aren't going to occur so what happens

696
00:32:29,520 --> 00:32:31,250
here is there is a table called the PLT

697
00:32:31,250 --> 00:32:33,929
which contains a little there's a little

698
00:32:33,929 --> 00:32:36,270
stub that we use to jump to the table

699
00:32:36,270 --> 00:32:39,120
and look up and and normally will jump

700
00:32:39,120 --> 00:32:42,120
to the the printf function initially

701
00:32:42,120 --> 00:32:43,710
though we jump to a magic function in

702
00:32:43,710 --> 00:32:45,390
the runtime linker whose job it is to

703
00:32:45,390 --> 00:32:47,220
find the printf function and then

704
00:32:47,220 --> 00:32:49,169
replace the stub with something that

705
00:32:49,169 --> 00:32:52,020
calls the right bit of code so that bit

706
00:32:52,020 --> 00:32:57,299
is a MIPS RTL D find I am short long

707
00:32:57,299 --> 00:33:00,059
time so that's that that so it's mostly

708
00:33:00,059 --> 00:33:04,320
the same except that every call into

709
00:33:04,320 --> 00:33:06,990
every call into a Lindsey function has

710
00:33:06,990 --> 00:33:09,390
this this extra step where it has to go

711
00:33:09,390 --> 00:33:13,670
off and find the function and call it

712
00:33:13,670 --> 00:33:18,990
so that is that is my talk I'm happy to

713
00:33:18,990 --> 00:33:23,310
take questions at this point and one

714
00:33:23,310 --> 00:33:25,560
request I would really like to get

715
00:33:25,560 --> 00:33:27,420
feedback so use the fosston feedback

716
00:33:27,420 --> 00:33:29,130
form send me an email talk to me later

717
00:33:29,130 --> 00:33:32,880
that you know what you what you liked

718
00:33:32,880 --> 00:33:35,910
about this and what you you know if I

719
00:33:35,910 --> 00:33:37,320
dwell too much on something boring tell

720
00:33:37,320 --> 00:33:39,560
me that

721
00:33:40,370 --> 00:33:50,679
[Applause]

722
00:33:51,680 --> 00:33:53,310
hi

723
00:33:53,310 --> 00:33:55,170
you showed us that underscore underscore

724
00:33:55,170 --> 00:33:57,870
start calls main with three arguments

725
00:33:57,870 --> 00:34:00,420
but we can declare main with zero

726
00:34:00,420 --> 00:34:02,610
arguments one are two arguments or three

727
00:34:02,610 --> 00:34:08,668
arguments how does it work so in

728
00:34:08,668 --> 00:34:10,530
practice if you so it calls it with

729
00:34:10,530 --> 00:34:13,110
three arguments in ordinary calling

730
00:34:13,110 --> 00:34:15,600
conventions if you don't if you don't

731
00:34:15,600 --> 00:34:16,710
acknowledge that you're being called

732
00:34:16,710 --> 00:34:17,850
with those arguments it makes no

733
00:34:17,850 --> 00:34:22,850
difference you just ignore them so

734
00:34:28,060 --> 00:34:31,170
[Music]

735
00:34:35,899 --> 00:34:39,270
so my question is knowing what you know

736
00:34:39,270 --> 00:34:42,780
now if we were gonna start again what

737
00:34:42,780 --> 00:34:45,750
would we do better or is this actually

738
00:34:45,750 --> 00:34:51,690
the best way there's a bunch of things

739
00:34:51,690 --> 00:34:54,540
that are coupled to the stack that

740
00:34:54,540 --> 00:34:55,889
probably would be better if they were

741
00:34:55,889 --> 00:34:57,210
stored somewhere else

742
00:34:57,210 --> 00:35:00,230
that's probably the most obvious thing

743
00:35:00,230 --> 00:35:04,200
yeah so I would say that the things that

744
00:35:04,200 --> 00:35:06,450
are coupled to the stack that's

745
00:35:06,450 --> 00:35:08,460
definitely a historical accident with no

746
00:35:08,460 --> 00:35:10,859
good reason I mean it's it's there

747
00:35:10,859 --> 00:35:12,510
because that's how you call functions on

748
00:35:12,510 --> 00:35:16,829
x86 but is and it is in some ways useful

749
00:35:16,829 --> 00:35:19,260
and it is lazy but I probably I wouldn't

750
00:35:19,260 --> 00:35:22,820
do that most of the rest of it is

751
00:35:22,820 --> 00:35:25,800
relatively sane I mean the MIPS bits are

752
00:35:25,800 --> 00:35:28,910
all insane because that's MIPS but

753
00:35:28,910 --> 00:35:35,210
otherwise it's relatively sane

754
00:35:49,020 --> 00:35:52,190
well thank you

