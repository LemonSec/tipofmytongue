1
00:00:04,710 --> 00:00:07,840
okay so hi my name is Chris I already

2
00:00:07,840 --> 00:00:08,889
mentioned I work as a production

3
00:00:08,889 --> 00:00:11,639
engineer at Fitz for London working as a

4
00:00:11,639 --> 00:00:14,469
member of Webb Foundation I'm gonna be

5
00:00:14,469 --> 00:00:16,000
giving a whistle-stop tour of the new

6
00:00:16,000 --> 00:00:18,099
version of control groups added in Linux

7
00:00:18,099 --> 00:00:20,290
4.5 don't worry if you haven't the

8
00:00:20,290 --> 00:00:22,210
faintest clue what control groups are

9
00:00:22,210 --> 00:00:23,980
yet I guess since we're in the

10
00:00:23,980 --> 00:00:25,090
containers dev room probably some of you

11
00:00:25,090 --> 00:00:27,340
have is some kind of idea but I'll go

12
00:00:27,340 --> 00:00:29,349
into kind of what they are where you may

13
00:00:29,349 --> 00:00:30,700
have used them and a comparison of the

14
00:00:30,700 --> 00:00:33,090
old and the new in the next few slides

15
00:00:33,090 --> 00:00:35,170
so like I said in this talk and it'll be

16
00:00:35,170 --> 00:00:36,190
giving kind of an introduction to

17
00:00:36,190 --> 00:00:39,100
control groups I'm going to go over what

18
00:00:39,100 --> 00:00:40,380
they are where you may have used them

19
00:00:40,380 --> 00:00:42,160
where you might have encountered them

20
00:00:42,160 --> 00:00:44,110
before if you already know something

21
00:00:44,110 --> 00:00:45,610
called control groups like you've you

22
00:00:45,610 --> 00:00:47,410
fished around previously or you've used

23
00:00:47,410 --> 00:00:47,740
them before

24
00:00:47,740 --> 00:00:49,060
you almost suddenly have been

25
00:00:49,060 --> 00:00:51,490
interacting with version 1 of control

26
00:00:51,490 --> 00:00:53,290
groups control groups as it has existed

27
00:00:53,290 --> 00:00:55,360
in the kernel since a long long time ago

28
00:00:55,360 --> 00:00:57,970
since around 2008 and it's been kind of

29
00:00:57,970 --> 00:01:00,160
building on our love of containers it's

30
00:01:00,160 --> 00:01:01,329
one of one of the building blocks of

31
00:01:01,329 --> 00:01:03,130
containers as we know them so it's

32
00:01:03,130 --> 00:01:04,390
definitely got a whole bunch of good

33
00:01:04,390 --> 00:01:06,340
things in it it's also got like a whole

34
00:01:06,340 --> 00:01:09,370
bunch of problems usability foibles

35
00:01:09,370 --> 00:01:11,200
other kinds of things which are not so

36
00:01:11,200 --> 00:01:14,080
great so I want to go into like what

37
00:01:14,080 --> 00:01:15,850
those are and when you might encounter

38
00:01:15,850 --> 00:01:17,650
them and how we try to improve that

39
00:01:17,650 --> 00:01:19,900
insecurity to cigarete one is currently

40
00:01:19,900 --> 00:01:22,020
now kind of in mostly a maintenance mode

41
00:01:22,020 --> 00:01:25,030
where it's secretly - is is more in

42
00:01:25,030 --> 00:01:26,530
active development they share the same

43
00:01:26,530 --> 00:01:28,840
core it's mostly the the user facing API

44
00:01:28,840 --> 00:01:31,479
which is kind of different and yeah I'm

45
00:01:31,479 --> 00:01:33,250
also going to go over kind of what's

46
00:01:33,250 --> 00:01:36,040
what's still to be done and what's

47
00:01:36,040 --> 00:01:37,570
what's already been done the core of

48
00:01:37,570 --> 00:01:39,400
secret v2 is already stable since kernel

49
00:01:39,400 --> 00:01:41,950
4.5 but we have a whole bunch of work we

50
00:01:41,950 --> 00:01:43,510
want to be done a lot of a lot of the

51
00:01:43,510 --> 00:01:45,909
core work has been to enable future work

52
00:01:45,909 --> 00:01:48,520
to enable new features in C groups which

53
00:01:48,520 --> 00:01:51,220
were already working on so that's a

54
00:01:51,220 --> 00:01:52,510
little bit about me I've been working at

55
00:01:52,510 --> 00:01:55,450
Facebook for about three years I like I

56
00:01:55,450 --> 00:01:56,530
said I work in this team called weapon

57
00:01:56,530 --> 00:01:58,240
addiction technically web foundation is

58
00:01:58,240 --> 00:01:59,710
the team responsible for the web servers

59
00:01:59,710 --> 00:02:01,869
a facebook but web servers are kind of

60
00:02:01,869 --> 00:02:03,759
not not usually extremely complicated

61
00:02:03,759 --> 00:02:05,590
like the stateless they serve you

62
00:02:05,590 --> 00:02:07,979
cabbages and that's about it

63
00:02:07,979 --> 00:02:10,598
so we actually ended up becoming kind of

64
00:02:10,598 --> 00:02:12,159
a team which deals with the general

65
00:02:12,159 --> 00:02:14,409
reliability at Facebook this means we

66
00:02:14,409 --> 00:02:16,130
get involved with production in

67
00:02:16,130 --> 00:02:17,600
discussions and all sorts of we

68
00:02:17,600 --> 00:02:20,000
generally act as kind of the guardians

69
00:02:20,000 --> 00:02:23,000
of reliability at Facebook yeah

70
00:02:23,000 --> 00:02:25,190
so I like I said I work at Facebook

71
00:02:25,190 --> 00:02:26,510
London we have a we have offers there we

72
00:02:26,510 --> 00:02:28,100
also have an office in Dublin in your

73
00:02:28,100 --> 00:02:30,800
opponent and Intel beef yeah and we have

74
00:02:30,800 --> 00:02:31,820
a whole bunch of different kinds of

75
00:02:31,820 --> 00:02:33,530
people in web foundation we have people

76
00:02:33,530 --> 00:02:35,270
who are experts at learning some

77
00:02:35,270 --> 00:02:36,680
pozzolanic stack which is basically my

78
00:02:36,680 --> 00:02:38,870
expertise we also have people who are

79
00:02:38,870 --> 00:02:41,300
experts in our cache architecture RPC

80
00:02:41,300 --> 00:02:44,720
and say like the web push and stuff like

81
00:02:44,720 --> 00:02:46,190
this especially a cross-functional group

82
00:02:46,190 --> 00:02:48,020
of experts which all come together to

83
00:02:48,020 --> 00:02:50,060
deal with when really hits the fan

84
00:02:50,060 --> 00:02:52,010
so that kind of brings up the question

85
00:02:52,010 --> 00:02:54,650
why why do we as a team like care about

86
00:02:54,650 --> 00:02:56,330
syrups and why don't why does Facebook

87
00:02:56,330 --> 00:02:58,220
as it come to care about C groups so we

88
00:02:58,220 --> 00:03:00,500
have many many hundreds of thousands of

89
00:03:00,500 --> 00:03:03,710
servers and we have a bunch of services

90
00:03:03,710 --> 00:03:05,270
which run on these servers some of them

91
00:03:05,270 --> 00:03:07,700
co-located on the same servers some of

92
00:03:07,700 --> 00:03:09,680
them spread throughout servers it's all

93
00:03:09,680 --> 00:03:12,440
kind of all over the place so most kind

94
00:03:12,440 --> 00:03:15,860
of outages at Facebook are a few there

95
00:03:15,860 --> 00:03:17,270
are a few kinds of outages but like one

96
00:03:17,270 --> 00:03:19,910
very common one is failure in multiple

97
00:03:19,910 --> 00:03:22,040
systems and there are a few things you

98
00:03:22,040 --> 00:03:24,140
need to do to mitigate that another one

99
00:03:24,140 --> 00:03:26,330
of course is actively mapping out your

100
00:03:26,330 --> 00:03:27,890
dependencies and making sure you have an

101
00:03:27,890 --> 00:03:29,540
understanding of your dependencies but

102
00:03:29,540 --> 00:03:31,550
another big one is making sure that when

103
00:03:31,550 --> 00:03:33,440
two services run on on a single machine

104
00:03:33,440 --> 00:03:35,990
you don't end up with a situation where

105
00:03:35,990 --> 00:03:37,910
one service completely overrides the

106
00:03:37,910 --> 00:03:39,350
other and results in it becoming

107
00:03:39,350 --> 00:03:41,480
completely useless so that's one of my

108
00:03:41,480 --> 00:03:44,000
main concerns about security to them one

109
00:03:44,000 --> 00:03:45,290
of the reasons why I'm super interested

110
00:03:45,290 --> 00:03:49,220
in it so a typical use case for this is

111
00:03:49,220 --> 00:03:53,030
like you say on a normal web server we

112
00:03:53,030 --> 00:03:54,410
have we have three types of running

113
00:03:54,410 --> 00:03:55,970
processes same goes for most other kinds

114
00:03:55,970 --> 00:03:57,620
of web servers other kinds of servers as

115
00:03:57,620 --> 00:03:59,780
well so you have your core workloads

116
00:03:59,780 --> 00:04:01,430
your core work load is the thing which

117
00:04:01,430 --> 00:04:03,200
if you were to describe to somebody else

118
00:04:03,200 --> 00:04:05,390
what your server was actually doing you

119
00:04:05,390 --> 00:04:07,550
would say it does this thing it serves

120
00:04:07,550 --> 00:04:10,610
web request it does load balancing but

121
00:04:10,610 --> 00:04:13,310
usually you don't end up only with this

122
00:04:13,310 --> 00:04:15,800
on your server you usually end up with a

123
00:04:15,800 --> 00:04:17,180
whole bunch of other stuff especially if

124
00:04:17,180 --> 00:04:18,380
your company has been around for a while

125
00:04:18,380 --> 00:04:19,970
or you have some ideas about how you

126
00:04:19,970 --> 00:04:21,589
should architect stuff you end up with a

127
00:04:21,589 --> 00:04:23,600
whole bunch of non core services which

128
00:04:23,600 --> 00:04:24,530
can probably be used interchangeably

129
00:04:24,530 --> 00:04:26,960
with kind of system services this might

130
00:04:26,960 --> 00:04:29,330
be stuff which just comes with

131
00:04:29,330 --> 00:04:31,490
like girls so the kernel workers or it

132
00:04:31,490 --> 00:04:33,949
could also be like say Kerberos demons

133
00:04:33,949 --> 00:04:35,060
or it could be like stuff which is

134
00:04:35,060 --> 00:04:36,500
related to your business needs say

135
00:04:36,500 --> 00:04:38,590
metric collections that we can work out

136
00:04:38,590 --> 00:04:41,060
what is going on with our server like

137
00:04:41,060 --> 00:04:42,470
whether we're managing to serve users

138
00:04:42,470 --> 00:04:45,229
correctly but it's it's really really

139
00:04:45,229 --> 00:04:46,940
bad if then this matter collection

140
00:04:46,940 --> 00:04:48,139
decides it's going to take of all the

141
00:04:48,139 --> 00:04:49,759
available memory in your server and then

142
00:04:49,759 --> 00:04:51,680
you can't actually serve users sure it

143
00:04:51,680 --> 00:04:53,330
can tell me it did that but I don't give

144
00:04:53,330 --> 00:04:55,129
a if it like completely up

145
00:04:55,129 --> 00:04:57,860
the whole web server right same goes for

146
00:04:57,860 --> 00:04:59,539
cron jobs and chef I care about my

147
00:04:59,539 --> 00:05:01,099
server being up to date but I would

148
00:05:01,099 --> 00:05:03,409
rather have some system which which

149
00:05:03,409 --> 00:05:04,969
actually acts in a reasonable manner if

150
00:05:04,969 --> 00:05:06,590
chef starts taking a bunch of memory I

151
00:05:06,590 --> 00:05:08,000
would rather it to got degraded service

152
00:05:08,000 --> 00:05:10,219
and still manage to run then it took all

153
00:05:10,219 --> 00:05:11,870
of the memory or took all of the CPU and

154
00:05:11,870 --> 00:05:13,729
then everything was like I would

155
00:05:13,729 --> 00:05:16,430
much rather have that bad outcome then

156
00:05:16,430 --> 00:05:17,900
we couldn't have this third class like

157
00:05:17,900 --> 00:05:21,080
ad-hoc queries and debugging these are

158
00:05:21,080 --> 00:05:22,639
typically things you don't know that you

159
00:05:22,639 --> 00:05:25,310
need and don't end up getting run on the

160
00:05:25,310 --> 00:05:26,449
majority of servers these are like

161
00:05:26,449 --> 00:05:28,039
things which you end up realizing you

162
00:05:28,039 --> 00:05:29,840
need only when an incident is already

163
00:05:29,840 --> 00:05:32,120
happening and we kind of want people to

164
00:05:32,120 --> 00:05:34,069
be able to dynamically be able to

165
00:05:34,069 --> 00:05:35,900
determine the importance of those things

166
00:05:35,900 --> 00:05:38,240
as the incident is going on whether they

167
00:05:38,240 --> 00:05:39,650
want it to take precedence over the core

168
00:05:39,650 --> 00:05:42,139
workload of the machine or not so

169
00:05:42,139 --> 00:05:45,259
cigarettes is a very good use case sorry

170
00:05:45,259 --> 00:05:46,490
this is a very good use case for seeing

171
00:05:46,490 --> 00:05:49,009
groups like I mentioned if you had some

172
00:05:49,009 --> 00:05:50,270
interaction with see groups you've

173
00:05:50,270 --> 00:05:51,650
almost certainly be interacting with

174
00:05:51,650 --> 00:05:53,300
version one version two has been in

175
00:05:53,300 --> 00:05:55,669
development for like five years now it

176
00:05:55,669 --> 00:05:57,830
only just got stable in a Linux kernel

177
00:05:57,830 --> 00:06:00,889
but even on recent kernels version one

178
00:06:00,889 --> 00:06:02,509
is typically what's mounted by default

179
00:06:02,509 --> 00:06:04,039
and the reason for that is as you'd

180
00:06:04,039 --> 00:06:05,719
imagine with a different version number

181
00:06:05,719 --> 00:06:07,550
the actual changes of backwards

182
00:06:07,550 --> 00:06:09,650
incompatible so I'm gonna be going over

183
00:06:09,650 --> 00:06:11,389
kind of why we've made them backwards

184
00:06:11,389 --> 00:06:14,539
incompatible in a moment so the fact

185
00:06:14,539 --> 00:06:16,789
that we typically boot with your init

186
00:06:16,789 --> 00:06:18,259
system only mounting the virtualmin

187
00:06:18,259 --> 00:06:20,960
hierarchy is is a testament to why I'm

188
00:06:20,960 --> 00:06:22,699
doing this talk like I know we have a

189
00:06:22,699 --> 00:06:25,279
whole whole group full of container

190
00:06:25,279 --> 00:06:26,599
experts in this room and this is also

191
00:06:26,599 --> 00:06:28,370
kind of a sell to you about why you

192
00:06:28,370 --> 00:06:30,229
should give a about secret v2 and

193
00:06:30,229 --> 00:06:32,300
why you should take the time to care

194
00:06:32,300 --> 00:06:33,590
about it and invest in it in your

195
00:06:33,590 --> 00:06:36,080
products so yeah so in the previous

196
00:06:36,080 --> 00:06:38,000
slide we talked about multiple processes

197
00:06:38,000 --> 00:06:39,770
fitting into each of these C groups as

198
00:06:39,770 --> 00:06:42,080
well so a C group can be set as tightly

199
00:06:42,080 --> 00:06:42,770
er it's flexible

200
00:06:42,770 --> 00:06:44,930
you like it can be all of the processes

201
00:06:44,930 --> 00:06:47,660
which related to one service or it can

202
00:06:47,660 --> 00:06:49,430
be a single process it can be however

203
00:06:49,430 --> 00:06:51,199
many processes you like from zero to

204
00:06:51,199 --> 00:06:53,750
however many you like and yeah the idea

205
00:06:53,750 --> 00:06:55,909
here is we don't impose a we don't

206
00:06:55,909 --> 00:06:58,280
impose a structure on you that one of

207
00:06:58,280 --> 00:07:00,050
the guiding principles behind v2 has

208
00:07:00,050 --> 00:07:01,610
been we want you to be able to choose

209
00:07:01,610 --> 00:07:02,900
how to use it we don't want to have a

210
00:07:02,900 --> 00:07:05,389
hierarchy which imposes how you should

211
00:07:05,389 --> 00:07:07,460
do things and we want the easy way to be

212
00:07:07,460 --> 00:07:11,360
the correct way so it's C group is a

213
00:07:11,360 --> 00:07:12,550
control group that went in the same

214
00:07:12,550 --> 00:07:14,750
there's there a system for resource

215
00:07:14,750 --> 00:07:16,880
management or links like I mentioned a

216
00:07:16,880 --> 00:07:18,620
resource here it means like CPU i/o

217
00:07:18,620 --> 00:07:21,110
memory and management here can mean for

218
00:07:21,110 --> 00:07:23,389
example accounting like we know how much

219
00:07:23,389 --> 00:07:25,340
memory is some particular some process

220
00:07:25,340 --> 00:07:26,900
in some particular super for using it

221
00:07:26,900 --> 00:07:28,490
can also be limiting like we hit a

222
00:07:28,490 --> 00:07:30,259
particular threshold and we we take some

223
00:07:30,259 --> 00:07:32,539
violin action to curve that it can also

224
00:07:32,539 --> 00:07:34,699
in v2 there's also been some work

225
00:07:34,699 --> 00:07:36,440
towards throttling which I'll go in as

226
00:07:36,440 --> 00:07:39,469
well generally boom killing or whatever

227
00:07:39,469 --> 00:07:41,629
is quite violent so we want to have some

228
00:07:41,629 --> 00:07:43,430
remediate of actions instead of just

229
00:07:43,430 --> 00:07:47,169
just straight-up killing stuff yeah so

230
00:07:47,169 --> 00:07:50,719
the way that cigrip v2 cigs v2 and v1

231
00:07:50,719 --> 00:07:52,490
work are essentially you have this

232
00:07:52,490 --> 00:07:55,009
hierarchy at CFS syrup it's a just a

233
00:07:55,009 --> 00:07:56,599
bunch of files and directories we don't

234
00:07:56,599 --> 00:07:58,940
have a system call interface there may

235
00:07:58,940 --> 00:08:00,469
well be one in future but we don't

236
00:08:00,469 --> 00:08:02,449
currently have one the reason the reason

237
00:08:02,449 --> 00:08:03,620
this is kind of a good thing is it's

238
00:08:03,620 --> 00:08:05,090
really easy from some user space

239
00:08:05,090 --> 00:08:06,680
application even if it's not written in

240
00:08:06,680 --> 00:08:09,440
C or C++ and you don't have access to C

241
00:08:09,440 --> 00:08:11,620
library function or system calls easily

242
00:08:11,620 --> 00:08:14,659
you can easily go and find out the state

243
00:08:14,659 --> 00:08:16,130
of your system when it comes to see

244
00:08:16,130 --> 00:08:17,779
groups you can just look at some file

245
00:08:17,779 --> 00:08:19,279
like I would hope that all of you are

246
00:08:19,279 --> 00:08:22,190
using languages which could like open a

247
00:08:22,190 --> 00:08:24,889
file make a directory remove a directory

248
00:08:24,889 --> 00:08:27,590
like yeah that's I would hope like

249
00:08:27,590 --> 00:08:29,180
whatever the new hep kids are using

250
00:08:29,180 --> 00:08:31,690
still supports those kind of things so

251
00:08:31,690 --> 00:08:34,279
yeah so each resource interfaces is

252
00:08:34,279 --> 00:08:35,719
provided by a controller you'll probably

253
00:08:35,719 --> 00:08:38,958
hear me use the word controller resource

254
00:08:38,958 --> 00:08:41,360
and domain kind of interchangeably

255
00:08:41,360 --> 00:08:44,120
the idea is you write files in like some

256
00:08:44,120 --> 00:08:45,709
particular that apply to some particular

257
00:08:45,709 --> 00:08:47,660
controller this controller takes the

258
00:08:47,660 --> 00:08:48,950
values which you provided and it

259
00:08:48,950 --> 00:08:50,120
provides them to the kernel and the

260
00:08:50,120 --> 00:08:51,560
kernel makes some kind of decisions

261
00:08:51,560 --> 00:08:54,529
based on what values you gave it so it's

262
00:08:54,529 --> 00:08:56,270
essentially the backing store for

263
00:08:56,270 --> 00:08:57,530
all of the stuff which you input the

264
00:08:57,530 --> 00:09:01,250
cigarettes so it's mentioned previously

265
00:09:01,250 --> 00:09:04,130
like workload isolation is a really big

266
00:09:04,130 --> 00:09:05,000
use case for cgroups

267
00:09:05,000 --> 00:09:06,830
so you might have many background jobs

268
00:09:06,830 --> 00:09:08,240
on a machine but you don't want them to

269
00:09:08,240 --> 00:09:09,620
override the main workload that's the

270
00:09:09,620 --> 00:09:11,330
case which we talked about first there

271
00:09:11,330 --> 00:09:12,770
are also some other kind of other cases

272
00:09:12,770 --> 00:09:15,800
like say you have a tier which runs

273
00:09:15,800 --> 00:09:18,320
which runs asynchronous strobes in the

274
00:09:18,320 --> 00:09:19,760
background we have we have that at

275
00:09:19,760 --> 00:09:21,920
Facebook and some jobs have higher

276
00:09:21,920 --> 00:09:24,050
priority than others priority is a very

277
00:09:24,050 --> 00:09:26,540
abstract concept but priority usually

278
00:09:26,540 --> 00:09:28,010
has something to do with resources it

279
00:09:28,010 --> 00:09:29,480
usually means either you expect it has a

280
00:09:29,480 --> 00:09:31,490
small memory or or less view or

281
00:09:31,490 --> 00:09:33,410
something like this it's very much up to

282
00:09:33,410 --> 00:09:34,910
you like what exactly that priority

283
00:09:34,910 --> 00:09:37,700
means you also have shared environments

284
00:09:37,700 --> 00:09:39,440
say you're a VPS provider or something

285
00:09:39,440 --> 00:09:42,050
like that and you don't want some

286
00:09:42,050 --> 00:09:44,420
particular user to be able to use that

287
00:09:44,420 --> 00:09:46,010
container and steal all the resources

288
00:09:46,010 --> 00:09:47,660
from all your other customers which are

289
00:09:47,660 --> 00:09:49,060
now gonna go and leave you a bad review

290
00:09:49,060 --> 00:09:51,500
so yeah so there are kind of a lot of

291
00:09:51,500 --> 00:09:54,260
use cases for super 2 and you might ask

292
00:09:54,260 --> 00:09:56,930
hey my my favorite my favorite

293
00:09:56,930 --> 00:09:59,240
application X like it already does this

294
00:09:59,240 --> 00:10:00,770
why should I give a single about C

295
00:10:00,770 --> 00:10:03,470
groups well the answer is if you have

296
00:10:03,470 --> 00:10:05,360
been using any kind of software in the

297
00:10:05,360 --> 00:10:06,860
last eight years I would really pray

298
00:10:06,860 --> 00:10:08,540
that it does it through C groups it

299
00:10:08,540 --> 00:10:10,160
probably does it transparently to you

300
00:10:10,160 --> 00:10:11,600
and you don't ever have to like talk to

301
00:10:11,600 --> 00:10:14,660
secrets directly but the the backing for

302
00:10:14,660 --> 00:10:16,460
all of these is C groups like that's how

303
00:10:16,460 --> 00:10:19,730
they do resource limiting so let's go

304
00:10:19,730 --> 00:10:21,890
concretely over how this works in in

305
00:10:21,890 --> 00:10:25,070
version one so in v1 sisyphus c group

306
00:10:25,070 --> 00:10:27,140
contains the names of all the resources

307
00:10:27,140 --> 00:10:29,600
which which have a controller so this

308
00:10:29,600 --> 00:10:31,940
might be CPU memory pins that kind of

309
00:10:31,940 --> 00:10:34,970
stuff and inside these inside these

310
00:10:34,970 --> 00:10:36,860
resource directories there's another set

311
00:10:36,860 --> 00:10:38,090
of directories which are the C groups

312
00:10:38,090 --> 00:10:38,600
themselves

313
00:10:38,600 --> 00:10:41,120
so these C groups exist in the context

314
00:10:41,120 --> 00:10:42,860
of this resource and you put processes

315
00:10:42,860 --> 00:10:46,490
into those C groups for example we have

316
00:10:46,490 --> 00:10:48,230
the pidz one at the bottom so because

317
00:10:48,230 --> 00:10:51,110
this is to do with pit pin do resources

318
00:10:51,110 --> 00:10:52,550
it contains falls in those directories

319
00:10:52,550 --> 00:10:54,290
and those files are related to how many

320
00:10:54,290 --> 00:10:56,740
pins you can have on us here for example

321
00:10:56,740 --> 00:11:00,970
and we also have the concept of like

322
00:11:00,970 --> 00:11:03,560
having its own hierarchy for resource

323
00:11:03,560 --> 00:11:05,690
distribution so in C group integral v1

324
00:11:05,690 --> 00:11:08,090
you have a resource and then you have a

325
00:11:08,090 --> 00:11:09,180
superb hierarchy

326
00:11:09,180 --> 00:11:11,700
each resource so even if see group three

327
00:11:11,700 --> 00:11:13,560
here was called the same at see group

328
00:11:13,560 --> 00:11:15,900
one say they were both called foo from

329
00:11:15,900 --> 00:11:17,250
the Connells perspective they have

330
00:11:17,250 --> 00:11:18,540
absolutely no relation to each other

331
00:11:18,540 --> 00:11:20,250
this is kind of important because if you

332
00:11:20,250 --> 00:11:21,990
look at how for example system D sets

333
00:11:21,990 --> 00:11:24,360
out C groups typically you often end up

334
00:11:24,360 --> 00:11:26,160
with quite similar looking hierarchies

335
00:11:26,160 --> 00:11:27,720
in different resources and you might

336
00:11:27,720 --> 00:11:29,130
even be inclined to believe they have

337
00:11:29,130 --> 00:11:30,690
some relation to each other well from

338
00:11:30,690 --> 00:11:32,070
system Diaz perspective I'm sure they do

339
00:11:32,070 --> 00:11:33,810
but from the kernels perspective they do

340
00:11:33,810 --> 00:11:36,690
not and that results in a whole slew of

341
00:11:36,690 --> 00:11:38,940
like subtle issues which cause problems

342
00:11:38,940 --> 00:11:41,360
at scale which I'll go into in a moment

343
00:11:41,360 --> 00:11:44,010
see groups see groups are nested inside

344
00:11:44,010 --> 00:11:45,720
each other in this example so when a see

345
00:11:45,720 --> 00:11:47,280
group is nested inside another typically

346
00:11:47,280 --> 00:11:49,020
what it means is it can control some

347
00:11:49,020 --> 00:11:52,440
limited amount up to the maximum amount

348
00:11:52,440 --> 00:11:54,150
of its parents so if you have if you

349
00:11:54,150 --> 00:11:56,730
have a memory C group and then you have

350
00:11:56,730 --> 00:11:58,710
a child of a C group which is also that

351
00:11:58,710 --> 00:12:00,450
which is also another C group then you

352
00:12:00,450 --> 00:12:03,900
can limit up to the maximum of its

353
00:12:03,900 --> 00:12:10,230
parent so the results that that controls

354
00:12:10,230 --> 00:12:12,120
the C groups or the secret hierarchy

355
00:12:12,120 --> 00:12:13,440
that they're in determines what kind of

356
00:12:13,440 --> 00:12:14,640
falls there are I already mentioned that

357
00:12:14,640 --> 00:12:15,840
if you're in the memory hierarchy you

358
00:12:15,840 --> 00:12:17,700
can only access files related to memory

359
00:12:17,700 --> 00:12:19,710
like for example that's as far memory

360
00:12:19,710 --> 00:12:21,240
dot limit and bytes you can read the

361
00:12:21,240 --> 00:12:22,890
limited bites from it or you can write

362
00:12:22,890 --> 00:12:24,950
to it and set a separate limited bytes

363
00:12:24,950 --> 00:12:28,220
and one pit isn't exactly one C group

364
00:12:28,220 --> 00:12:32,070
per resource in C Group E 1 so P 2 here

365
00:12:32,070 --> 00:12:36,000
is is explicitly assigned to suit two

366
00:12:36,000 --> 00:12:39,000
resources a and C in C group 1 and 5

367
00:12:39,000 --> 00:12:40,920
respectively but because we don't assign

368
00:12:40,920 --> 00:12:43,050
it to anything in resource B it's

369
00:12:43,050 --> 00:12:44,790
actually goes to this route C group the

370
00:12:44,790 --> 00:12:45,870
route C group is kind of a special

371
00:12:45,870 --> 00:12:48,030
concept in in in C groups it's

372
00:12:48,030 --> 00:12:50,550
essentially unmanaged territory how

373
00:12:50,550 --> 00:12:52,140
exactly it manages up to the controller

374
00:12:52,140 --> 00:12:54,840
but the idea is you don't really have

375
00:12:54,840 --> 00:12:56,610
the opportunity to set really any limits

376
00:12:56,610 --> 00:12:57,990
in the route C group because it's just

377
00:12:57,990 --> 00:13:00,090
the the starting point for a resource

378
00:13:00,090 --> 00:13:01,470
distribution of this resource across

379
00:13:01,470 --> 00:13:02,600
your whole machine

380
00:13:02,600 --> 00:13:04,530
so yeah you do get some kind of

381
00:13:04,530 --> 00:13:06,480
accounting but in terms of limiting it's

382
00:13:06,480 --> 00:13:10,320
basically useless so here is a concrete

383
00:13:10,320 --> 00:13:12,270
look at how this looks in security ones

384
00:13:12,270 --> 00:13:15,150
so you have set of SC group and then you

385
00:13:15,150 --> 00:13:16,830
have the resources which are like

386
00:13:16,830 --> 00:13:18,960
blocker mmm pits and then you have the C

387
00:13:18,960 --> 00:13:19,870
group names and

388
00:13:19,870 --> 00:13:22,210
have a nested cigrip team a inside BG

389
00:13:22,210 --> 00:13:24,130
for two resources and be inside out hook

390
00:13:24,130 --> 00:13:27,279
for two resources so once again just as

391
00:13:27,279 --> 00:13:28,450
a reiteration because this is really

392
00:13:28,450 --> 00:13:30,040
important that you get this from the

393
00:13:30,040 --> 00:13:31,660
Colonel's perspective naming has no

394
00:13:31,660 --> 00:13:33,550
meaning like if it's in a different

395
00:13:33,550 --> 00:13:35,320
resource even if it has the same name it

396
00:13:35,320 --> 00:13:36,580
has no meaning

397
00:13:36,580 --> 00:13:38,080
and that has all sorts of weird

398
00:13:38,080 --> 00:13:41,710
implications so here's how it looks in

399
00:13:41,710 --> 00:13:42,970
cigarette v2 by comparison

400
00:13:42,970 --> 00:13:45,250
so in super v2 we actually don't see the

401
00:13:45,250 --> 00:13:46,750
resources anymore if you remember how it

402
00:13:46,750 --> 00:13:49,990
looked in version 1 we have resources

403
00:13:49,990 --> 00:13:51,190
under sisyphus a group but now we

404
00:13:51,190 --> 00:13:52,650
actually have the C groups themselves

405
00:13:52,650 --> 00:13:55,839
under sisyphus C group so how do these

406
00:13:55,839 --> 00:13:58,089
see groups understand which resources

407
00:13:58,089 --> 00:13:59,620
they are supposed to apply to if they're

408
00:13:59,620 --> 00:14:01,870
not inside a resource hierarchy well the

409
00:14:01,870 --> 00:14:04,420
answer is kind of cigarettes a global

410
00:14:04,420 --> 00:14:07,089
now they're essentially a global a

411
00:14:07,089 --> 00:14:09,790
global set of C groups and you enable

412
00:14:09,790 --> 00:14:13,390
resources inside of the C groups this

413
00:14:13,390 --> 00:14:16,029
means that we have one hierarchy to rule

414
00:14:16,029 --> 00:14:16,779
them all

415
00:14:16,779 --> 00:14:19,390
and the idea is like you write to a

416
00:14:19,390 --> 00:14:21,310
special file you tell us what particular

417
00:14:21,310 --> 00:14:22,930
controllers you want to enable and we

418
00:14:22,930 --> 00:14:24,459
enable them for your C group we don't

419
00:14:24,459 --> 00:14:26,110
require you to create different

420
00:14:26,110 --> 00:14:28,360
hierarchies each time you instead create

421
00:14:28,360 --> 00:14:29,770
one hierarchy and enable C group

422
00:14:29,770 --> 00:14:32,890
controllers at will so this is how the

423
00:14:32,890 --> 00:14:35,050
previous example now look since iqra' -

424
00:14:35,050 --> 00:14:37,420
so integral v - like I mentioned we now

425
00:14:37,420 --> 00:14:38,770
have the C groups directly at the bottom

426
00:14:38,770 --> 00:14:40,570
but you write to this special file see

427
00:14:40,570 --> 00:14:42,459
group dot subtree control and that

428
00:14:42,459 --> 00:14:45,490
enables the in the truck in the children

429
00:14:45,490 --> 00:14:47,920
of that C group that those controllers

430
00:14:47,920 --> 00:14:50,620
are enabled essentially if you were not

431
00:14:50,620 --> 00:14:51,760
to enable them there but they were

432
00:14:51,760 --> 00:14:53,350
enabled the next level up it means they

433
00:14:53,350 --> 00:14:55,330
would compete freely for those resources

434
00:14:55,330 --> 00:14:58,570
that you didn't enable so yeah so here's

435
00:14:58,570 --> 00:15:00,580
the version one hierarchy again for

436
00:15:00,580 --> 00:15:02,770
comparison and as you can see here we

437
00:15:02,770 --> 00:15:06,880
have resources first and remember that

438
00:15:06,880 --> 00:15:09,279
in version one secrets with the same

439
00:15:09,279 --> 00:15:11,170
name again don't have any relation to

440
00:15:11,170 --> 00:15:14,380
each other in super V - we have this

441
00:15:14,380 --> 00:15:16,390
unified hierarchy and you enable

442
00:15:16,390 --> 00:15:18,339
resources for C groups children by

443
00:15:18,339 --> 00:15:21,370
writing + memory + pays per CPU + io

444
00:15:21,370 --> 00:15:22,240
that kind of stuff

445
00:15:22,240 --> 00:15:24,130
- secrets actually control and when you

446
00:15:24,130 --> 00:15:25,839
do this the files appear in that

447
00:15:25,839 --> 00:15:29,860
directory instantaneously oh and another

448
00:15:29,860 --> 00:15:31,780
thing to mention is in real life you

449
00:15:31,780 --> 00:15:33,490
also need to enable the

450
00:15:33,490 --> 00:15:34,990
memory pins and i/o controllers at the

451
00:15:34,990 --> 00:15:36,760
top level for this to work but for the

452
00:15:36,760 --> 00:15:38,529
sake of simplicity I'm not out of them

453
00:15:38,529 --> 00:15:42,130
here so the fundamental differences are

454
00:15:42,130 --> 00:15:43,690
obviously the unified hierarchy

455
00:15:43,690 --> 00:15:45,430
resources apply to see groups now

456
00:15:45,430 --> 00:15:47,080
instead of see groups applying to some

457
00:15:47,080 --> 00:15:49,690
some distance across the hierarchy for a

458
00:15:49,690 --> 00:15:52,149
resource this is very important for some

459
00:15:52,149 --> 00:15:54,010
kinds of common operations in Linux like

460
00:15:54,010 --> 00:15:55,930
for example you have page caps Rybak's

461
00:15:55,930 --> 00:15:58,690
and paved path right backs transcend one

462
00:15:58,690 --> 00:16:00,580
particular resource they they happen

463
00:16:00,580 --> 00:16:01,690
across a whole bunch of different

464
00:16:01,690 --> 00:16:03,700
resources and we need to be able to we

465
00:16:03,700 --> 00:16:05,140
need to be able to consider these

466
00:16:05,140 --> 00:16:07,899
actions together in unity to be able to

467
00:16:07,899 --> 00:16:10,089
form from reasonable limiting or other

468
00:16:10,089 --> 00:16:14,920
actions we also have granularity at the

469
00:16:14,920 --> 00:16:17,020
threat group ID not the thread ID level

470
00:16:17,020 --> 00:16:19,390
this is a contentious point but it's

471
00:16:19,390 --> 00:16:20,740
kind of important

472
00:16:20,740 --> 00:16:23,380
in sigrid one you could essentially put

473
00:16:23,380 --> 00:16:24,940
different threads from the same process

474
00:16:24,940 --> 00:16:26,770
in two separate C groups this has a

475
00:16:26,770 --> 00:16:28,870
whole bunch of weird implications like

476
00:16:28,870 --> 00:16:32,500
for example people would put say

477
00:16:32,500 --> 00:16:34,029
different threads from the same process

478
00:16:34,029 --> 00:16:35,920
into different memory C groups I don't

479
00:16:35,920 --> 00:16:36,790
know how the that's supposed to

480
00:16:36,790 --> 00:16:39,550
work like you have like basically the

481
00:16:39,550 --> 00:16:41,620
entire shared memory between these two

482
00:16:41,620 --> 00:16:43,300
 C groups I know people have done

483
00:16:43,300 --> 00:16:45,279
insane with C groups this is this

484
00:16:45,279 --> 00:16:47,680
is the main the main thing is like we

485
00:16:47,680 --> 00:16:49,089
want a guy towards a reasonable

486
00:16:49,089 --> 00:16:50,230
annotation because it's not that these

487
00:16:50,230 --> 00:16:52,149
people are stupid that's not the problem

488
00:16:52,149 --> 00:16:54,640
it's just the secrets everyone we're

489
00:16:54,640 --> 00:16:56,290
like quite over complicated so it made

490
00:16:56,290 --> 00:16:57,899
people do some insane

491
00:16:57,899 --> 00:17:00,790
so now limiting the paid level kind of

492
00:17:00,790 --> 00:17:02,620
gets us like a more reasonable

493
00:17:02,620 --> 00:17:03,790
approximation of what people generally

494
00:17:03,790 --> 00:17:07,569
want also without extensive cooperation

495
00:17:07,569 --> 00:17:09,880
even further resources where maybe it's

496
00:17:09,880 --> 00:17:12,220
would in theory make sense to to have

497
00:17:12,220 --> 00:17:14,109
different different threads from the

498
00:17:14,109 --> 00:17:15,849
same process in different resources it

499
00:17:15,849 --> 00:17:19,720
often ends up being like you you have to

500
00:17:19,720 --> 00:17:20,859
have some way to communicate which

501
00:17:20,859 --> 00:17:22,750
thread from your process is doing what

502
00:17:22,750 --> 00:17:24,520
and there's no standardized way to do

503
00:17:24,520 --> 00:17:26,500
that in Linux right like you can set the

504
00:17:26,500 --> 00:17:29,230
the comm of your thread to like some

505
00:17:29,230 --> 00:17:31,120
value and then and look at like the

506
00:17:31,120 --> 00:17:32,800
value somewhere but it's not

507
00:17:32,800 --> 00:17:34,240
standardized and it's like really really

508
00:17:34,240 --> 00:17:36,880
 hard to reason about so yeah it

509
00:17:36,880 --> 00:17:38,860
usually doesn't act in any reasonable

510
00:17:38,860 --> 00:17:41,230
way in general like there's been a focus

511
00:17:41,230 --> 00:17:44,200
on simplicity and clarity in nv2 over

512
00:17:44,200 --> 00:17:46,280
like ultimate flexibility v1

513
00:17:46,280 --> 00:17:48,260
invented at the kind of the dawn of

514
00:17:48,260 --> 00:17:50,090
containerization people didn't know what

515
00:17:50,090 --> 00:17:51,620
they wanted they just know that they

516
00:17:51,620 --> 00:17:53,680
wanted something and they wanted it now

517
00:17:53,680 --> 00:17:56,450
so v1 was kind of a solution to the

518
00:17:56,450 --> 00:17:57,740
problem and v2 is kind of more like a

519
00:17:57,740 --> 00:18:01,040
more a more developed approach to the

520
00:18:01,040 --> 00:18:02,630
problems we know we're having for sure

521
00:18:02,630 --> 00:18:07,970
now so another new feature in v2 is the

522
00:18:07,970 --> 00:18:09,590
addition of this no internal process

523
00:18:09,590 --> 00:18:11,600
constraint so this means that C groups

524
00:18:11,600 --> 00:18:14,240
with processes and controllers enabled

525
00:18:14,240 --> 00:18:17,300
cannot create child C groups essentially

526
00:18:17,300 --> 00:18:19,240
this means that in in simpler words

527
00:18:19,240 --> 00:18:22,010
these red C groups either have to have

528
00:18:22,010 --> 00:18:23,870
no processes or they have to have no

529
00:18:23,870 --> 00:18:25,430
controllers enabled in that part of the

530
00:18:25,430 --> 00:18:28,880
hierarchy this is for a few reasons

531
00:18:28,880 --> 00:18:31,370
it's kind of hard to reason about how

532
00:18:31,370 --> 00:18:33,710
that should act usually in in v1 this

533
00:18:33,710 --> 00:18:36,740
within v1 this was allowed and the

534
00:18:36,740 --> 00:18:38,000
problem is now you have two different

535
00:18:38,000 --> 00:18:40,010
types of objects kind of competing

536
00:18:40,010 --> 00:18:41,810
against each other so say you have

537
00:18:41,810 --> 00:18:44,240
processes in I and then you have some

538
00:18:44,240 --> 00:18:47,470
Charles C groups under underneath I here

539
00:18:47,470 --> 00:18:50,500
now you have processes which are in I

540
00:18:50,500 --> 00:18:52,820
competing against C groups which are its

541
00:18:52,820 --> 00:18:54,950
children and it's difficult you have to

542
00:18:54,950 --> 00:18:56,510
make some kind of you have to make some

543
00:18:56,510 --> 00:18:58,910
kind of judgment about how we will treat

544
00:18:58,910 --> 00:19:01,460
processes compared to C groups maybe we

545
00:19:01,460 --> 00:19:03,110
can consider each one its own secret

546
00:19:03,110 --> 00:19:05,090
maybe we can consider them like I prime

547
00:19:05,090 --> 00:19:07,250
like a separate C group but it's quite

548
00:19:07,250 --> 00:19:08,630
hard to reason about them for most cases

549
00:19:08,630 --> 00:19:10,190
the better solution is just create

550
00:19:10,190 --> 00:19:12,350
another soup and so this is another

551
00:19:12,350 --> 00:19:14,180
guide towards like helping people create

552
00:19:14,180 --> 00:19:17,150
a sane hierarchy and the route C group

553
00:19:17,150 --> 00:19:20,990
is a special case the the controller's

554
00:19:20,990 --> 00:19:22,580
themselves have to decide how they're

555
00:19:22,580 --> 00:19:26,840
gonna handle resources in the root so

556
00:19:26,840 --> 00:19:29,030
clearly breaking the API is kind of a

557
00:19:29,030 --> 00:19:31,130
big deal like Seagram the seizure break

558
00:19:31,130 --> 00:19:32,750
guys is a pretty big deal like

559
00:19:32,750 --> 00:19:34,790
the fact that we want to create v2

560
00:19:34,790 --> 00:19:36,350
instead of instead of just improving

561
00:19:36,350 --> 00:19:38,540
everyone obviously need some good some

562
00:19:38,540 --> 00:19:42,500
good reasoning there so v1 works ok for

563
00:19:42,500 --> 00:19:43,850
basic situations but it gets kind of

564
00:19:43,850 --> 00:19:46,100
exponentially complicated when you're

565
00:19:46,100 --> 00:19:48,500
getting more and more complex as I

566
00:19:48,500 --> 00:19:50,960
mentioned in v1 design kind of often

567
00:19:50,960 --> 00:19:54,140
followed implementation and trying to

568
00:19:54,140 --> 00:19:56,390
rework kernel api's after the fact is

569
00:19:56,390 --> 00:19:59,030
really really really hard like you can't

570
00:19:59,030 --> 00:19:59,549
change

571
00:19:59,549 --> 00:20:01,470
like the fundamental nature of the

572
00:20:01,470 --> 00:20:02,669
kernel a carts which people rely on

573
00:20:02,669 --> 00:20:04,049
day-to-day in production that's just not

574
00:20:04,049 --> 00:20:06,450
something you can do even for stuff

575
00:20:06,450 --> 00:20:07,739
which was designed upfront like I

576
00:20:07,739 --> 00:20:09,720
mentioned like generally the use cases

577
00:20:09,720 --> 00:20:11,369
for containers and see groups were not

578
00:20:11,369 --> 00:20:12,840
really that well fleshed out yet they

579
00:20:12,840 --> 00:20:14,700
originally started as as like only for

580
00:20:14,700 --> 00:20:16,169
CPU and then it grew and grew and grew

581
00:20:16,169 --> 00:20:19,230
kind of naturally it was generally hard

582
00:20:19,230 --> 00:20:21,269
to gauge at the time how C groups will

583
00:20:21,269 --> 00:20:24,179
be used so now this is an opportunity to

584
00:20:24,179 --> 00:20:25,710
redesign them and work them how we

585
00:20:25,710 --> 00:20:27,989
actually think they should be so to fix

586
00:20:27,989 --> 00:20:29,309
these kind of fundamental issues you

587
00:20:29,309 --> 00:20:30,869
need to have an API break and that's why

588
00:20:30,869 --> 00:20:34,019
the v2 was created so I'm going to go

589
00:20:34,019 --> 00:20:35,489
over some of the the actual practical

590
00:20:35,489 --> 00:20:36,570
improvements because I've talked a lot

591
00:20:36,570 --> 00:20:38,190
about like the theoretical how we design

592
00:20:38,190 --> 00:20:39,779
it but I also want to go over why we've

593
00:20:39,779 --> 00:20:41,009
designed it in that way and what that

594
00:20:41,009 --> 00:20:42,049
actually means

595
00:20:42,049 --> 00:20:45,779
so ok pop quiz

596
00:20:45,779 --> 00:20:47,759
when you write to a file in Linux what

597
00:20:47,759 --> 00:20:51,749
happens it's not a trick question that's

598
00:20:51,749 --> 00:20:55,200
where you're gonna follow this okay you

599
00:20:55,200 --> 00:20:57,119
get a file descriptor ok not that bad

600
00:20:57,119 --> 00:20:58,859
was that was possibly before what I

601
00:20:58,859 --> 00:21:00,720
wanted okay so does it write directly to

602
00:21:00,720 --> 00:21:04,049
the disk okay so where does your day to

603
00:21:04,049 --> 00:21:07,499
go I got about five different answers

604
00:21:07,499 --> 00:21:10,230
I'm not sure what note they were okay so

605
00:21:10,230 --> 00:21:12,509
it goes you write a dirty page into into

606
00:21:12,509 --> 00:21:14,190
the into the page cache you have like

607
00:21:14,190 --> 00:21:17,249
some some subset of dirty pages now and

608
00:21:17,249 --> 00:21:19,169
you're right Siskel came back and it

609
00:21:19,169 --> 00:21:21,259
said everything's everything's great

610
00:21:21,259 --> 00:21:23,580
from your applications perspective now

611
00:21:23,580 --> 00:21:25,710
you can go on pretending yes it was

612
00:21:25,710 --> 00:21:28,080
written to disk and my writes is for

613
00:21:28,080 --> 00:21:29,489
succeeded so it must be written to disk

614
00:21:29,489 --> 00:21:31,289
and you can have all this class of

615
00:21:31,289 --> 00:21:34,529
wonderful belief but ultimately it's not

616
00:21:34,529 --> 00:21:35,639
been written to this right it's it's

617
00:21:35,639 --> 00:21:37,080
still sitting in memory somewhere and if

618
00:21:37,080 --> 00:21:37,980
you shut down the machine right now

619
00:21:37,980 --> 00:21:39,619
shits gonna go hey Wow

620
00:21:39,619 --> 00:21:42,480
so yeah so there are multiple operations

621
00:21:42,480 --> 00:21:44,730
here to be considered first you have the

622
00:21:44,730 --> 00:21:47,159
your writes a spool which then goes and

623
00:21:47,159 --> 00:21:49,440
writes it at dirty pages returns to you

624
00:21:49,440 --> 00:21:52,470
and then later some kernel worker like

625
00:21:52,470 --> 00:21:54,539
beauty flash comes and it says okay now

626
00:21:54,539 --> 00:21:56,609
is the time by some magical standards

627
00:21:56,609 --> 00:21:59,340
like the inode dirty ratio I've decided

628
00:21:59,340 --> 00:22:01,259
I'm gonna flush out these two discs in

629
00:22:01,259 --> 00:22:03,269
v1 we don't have any account we don't

630
00:22:03,269 --> 00:22:05,429
have any tracking of this so if you if

631
00:22:05,429 --> 00:22:08,190
you've wrote dirty pages we don't know

632
00:22:08,190 --> 00:22:10,049
where they came from afterwards when we

633
00:22:10,049 --> 00:22:11,909
flush them to disk so that IO goes to

634
00:22:11,909 --> 00:22:13,170
the root C group and we can't

635
00:22:13,170 --> 00:22:14,720
countered to your process or Josi group

636
00:22:14,720 --> 00:22:16,740
simply because it wasn't tracked it

637
00:22:16,740 --> 00:22:18,240
wasn't track to where this page come

638
00:22:18,240 --> 00:22:21,030
from in v2 it is tracked and we can

639
00:22:21,030 --> 00:22:23,070
actually count these towards your your

640
00:22:23,070 --> 00:22:24,780
limits and we can also make kind of

641
00:22:24,780 --> 00:22:27,210
reasonable decisions about like oh you

642
00:22:27,210 --> 00:22:29,280
have I owe contention and this is what I

643
00:22:29,280 --> 00:22:30,540
should do based on that or you have

644
00:22:30,540 --> 00:22:31,710
memory contention as well as you do

645
00:22:31,710 --> 00:22:33,030
based on that when you're trying to do a

646
00:22:33,030 --> 00:22:35,870
page guess right back

647
00:22:36,810 --> 00:22:39,690
v2 is also generally like kind of better

648
00:22:39,690 --> 00:22:42,090
integrated with subsystems so most of

649
00:22:42,090 --> 00:22:43,350
the actions we could do based on

650
00:22:43,350 --> 00:22:45,630
thresholds in version 1 were kind of

651
00:22:45,630 --> 00:22:47,250
crude or or in the case of the memory

652
00:22:47,250 --> 00:22:49,740
subsystem like quite violent you said

653
00:22:49,740 --> 00:22:51,630
like a limit with memory don't limit in

654
00:22:51,630 --> 00:22:54,120
bytes and what happens is you you so

655
00:22:54,120 --> 00:22:55,770
your application has like a woman it

656
00:22:55,770 --> 00:22:57,120
spike in memory usage and then the

657
00:22:57,120 --> 00:22:58,530
killer goes along and it goes oh I'm

658
00:22:58,530 --> 00:23:00,750
gonna kill you and that's like the

659
00:23:00,750 --> 00:23:02,280
standard method of dealing with things

660
00:23:02,280 --> 00:23:05,220
like usually like processes don't

661
00:23:05,220 --> 00:23:10,740
particularly like being kill 9 I I don't

662
00:23:10,740 --> 00:23:13,200
know like maybe like there's some kind

663
00:23:13,200 --> 00:23:14,910
of sadistic processes which like that

664
00:23:14,910 --> 00:23:18,480
but I mean ultimately it's not not a

665
00:23:18,480 --> 00:23:21,690
very a very good way of limiting results

666
00:23:21,690 --> 00:23:23,100
users what you've really want to do is

667
00:23:23,100 --> 00:23:24,960
like tell it ok calm the down and

668
00:23:24,960 --> 00:23:27,390
like stop allocating memory or in in the

669
00:23:27,390 --> 00:23:29,130
Bedok in the better case where you can't

670
00:23:29,130 --> 00:23:30,690
tell to calm the down you want to

671
00:23:30,690 --> 00:23:31,920
tell the operating system hey that guy's

672
00:23:31,920 --> 00:23:34,350
gone not so I would like to now

673
00:23:34,350 --> 00:23:36,450
like take some action against this guy

674
00:23:36,450 --> 00:23:38,550
but that action doesn't have to be like

675
00:23:38,550 --> 00:23:42,510
slay him where he stands yeah I would

676
00:23:42,510 --> 00:23:43,950
like to think in human society we've

677
00:23:43,950 --> 00:23:45,720
gone past the point where like the

678
00:23:45,720 --> 00:23:47,730
penalty for any kind of failure is

679
00:23:47,730 --> 00:23:53,670
instantaneous death so yeah so now in

680
00:23:53,670 --> 00:23:56,160
super V 2 we have like generally kind of

681
00:23:56,160 --> 00:23:59,610
better thresholds here we have we have a

682
00:23:59,610 --> 00:24:01,860
new thing called memory dot high which

683
00:24:01,860 --> 00:24:03,480
instead of killing a process we still

684
00:24:03,480 --> 00:24:05,880
have memory access to memory not limited

685
00:24:05,880 --> 00:24:07,410
bytes which um killed your process but

686
00:24:07,410 --> 00:24:09,930
we also have memory dot high and what

687
00:24:09,930 --> 00:24:11,820
memory not high does is when you pass

688
00:24:11,820 --> 00:24:14,220
this threshold we start to do throttling

689
00:24:14,220 --> 00:24:16,290
and reclaim when for every single matter

690
00:24:16,290 --> 00:24:17,100
memory allocation

691
00:24:17,100 --> 00:24:18,780
so when you

692
00:24:18,780 --> 00:24:20,670
go over memory dot hi and you want to do

693
00:24:20,670 --> 00:24:21,900
another malloc or you want to get grab

694
00:24:21,900 --> 00:24:24,030
some more memory then what we do is we

695
00:24:24,030 --> 00:24:25,620
break into a separate path in the kernel

696
00:24:25,620 --> 00:24:27,780
and we say hey I would like to I would

697
00:24:27,780 --> 00:24:28,980
like to dial back this user so what I'm

698
00:24:28,980 --> 00:24:30,870
going to do is go to the tail of the

699
00:24:30,870 --> 00:24:32,580
inactive list and start reclaiming pages

700
00:24:32,580 --> 00:24:35,100
so if you fail to reclaim any pages it's

701
00:24:35,100 --> 00:24:36,420
still kind of good because you took

702
00:24:36,420 --> 00:24:38,490
awhile to scan the page cache it took

703
00:24:38,490 --> 00:24:39,900
you a while to scan the page guess which

704
00:24:39,900 --> 00:24:41,760
slowed down your application now and

705
00:24:41,760 --> 00:24:43,050
we've done it in a way which is kind of

706
00:24:43,050 --> 00:24:45,090
transparent to your application but if

707
00:24:45,090 --> 00:24:46,530
you do manage to reclaim pages then we

708
00:24:46,530 --> 00:24:48,360
also win because now you've retained

709
00:24:48,360 --> 00:24:49,860
some pages than you managed to get some

710
00:24:49,860 --> 00:24:51,810
memory free again in fact this is like a

711
00:24:51,810 --> 00:24:53,490
generally a much saner way of doing

712
00:24:53,490 --> 00:24:55,530
things and this is like using this on

713
00:24:55,530 --> 00:24:57,150
web servers was like a big win when you

714
00:24:57,150 --> 00:25:00,740
see like these spikes in results users

715
00:25:01,580 --> 00:25:04,560
so notifications I don't know like how

716
00:25:04,560 --> 00:25:06,120
notifications are like one of the more

717
00:25:06,120 --> 00:25:07,890
educators foresee group since it usually

718
00:25:07,890 --> 00:25:09,660
ends up being people that like system D

719
00:25:09,660 --> 00:25:11,820
which and abusing them but notifications

720
00:25:11,820 --> 00:25:13,680
are essentially a way to say hey it's

721
00:25:13,680 --> 00:25:17,010
something in my soup change state it

722
00:25:17,010 --> 00:25:18,300
could be like oh I have no more

723
00:25:18,300 --> 00:25:20,190
processes in my C group so all of them

724
00:25:20,190 --> 00:25:22,890
have finished it could be like oh one of

725
00:25:22,890 --> 00:25:24,750
my processes ran out of memory and I'm

726
00:25:24,750 --> 00:25:25,890
gonna take some action based on that

727
00:25:25,890 --> 00:25:28,320
ultimately it's a way to get information

728
00:25:28,320 --> 00:25:30,180
about what is happening in your secret

729
00:25:30,180 --> 00:25:32,460
system D uses this for example to track

730
00:25:32,460 --> 00:25:35,040
which processes are running and the

731
00:25:35,040 --> 00:25:36,720
state of the state of your system and

732
00:25:36,720 --> 00:25:37,710
the state of the services which you're

733
00:25:37,710 --> 00:25:41,400
running the problem is on v1 for for

734
00:25:41,400 --> 00:25:42,690
release notifications which is the

735
00:25:42,690 --> 00:25:44,370
notifications which are sent when your

736
00:25:44,370 --> 00:25:45,960
secret past normal processes which for

737
00:25:45,960 --> 00:25:49,620
example means like oh we exited you have

738
00:25:49,620 --> 00:25:51,330
to designate a what's called a release

739
00:25:51,330 --> 00:25:53,400
agent and this release agent you it's

740
00:25:53,400 --> 00:25:55,860
just like giving a cord of utility you

741
00:25:55,860 --> 00:25:57,450
you tell it like here's the path to my

742
00:25:57,450 --> 00:25:59,820
executable and when you have no normal

743
00:25:59,820 --> 00:26:01,740
processes go and execute this this this

744
00:26:01,740 --> 00:26:03,480
thing with these arguments the problem

745
00:26:03,480 --> 00:26:05,640
is now if you have if you're using C

746
00:26:05,640 --> 00:26:08,190
groups as utility where say you have C

747
00:26:08,190 --> 00:26:10,020
group's expiring like a thousand times a

748
00:26:10,020 --> 00:26:11,550
second you're not like forking a

749
00:26:11,550 --> 00:26:13,140
thousand times a second as well which is

750
00:26:13,140 --> 00:26:15,120
pretty bad like it's generally pretty

751
00:26:15,120 --> 00:26:16,380
expensive and it doesn't make a whole

752
00:26:16,380 --> 00:26:18,540
lot of sense since the rest of the the

753
00:26:18,540 --> 00:26:20,910
rest of the secret API used slightly

754
00:26:20,910 --> 00:26:24,120
more sane methods using a bent FD so now

755
00:26:24,120 --> 00:26:26,570
we have inotify support everywhere

756
00:26:26,570 --> 00:26:28,890
system etsu group looks like a possum it

757
00:26:28,890 --> 00:26:30,150
kind of makes sense that it's supports

758
00:26:30,150 --> 00:26:31,200
inotify

759
00:26:31,200 --> 00:26:33,059
we still have the vent empty support so

760
00:26:33,059 --> 00:26:34,769
you can like poll and find out what the

761
00:26:34,769 --> 00:26:38,100
answer is the idea now is you can have

762
00:26:38,100 --> 00:26:39,870
one process to monitor everything you

763
00:26:39,870 --> 00:26:40,860
like you don't have to fork a new

764
00:26:40,860 --> 00:26:42,299
process every time the vent is created

765
00:26:42,299 --> 00:26:43,799
this is just like a straight upgrade

766
00:26:43,799 --> 00:26:47,970
really so utility controllers are

767
00:26:47,970 --> 00:26:49,289
another thing utility controllers or

768
00:26:49,289 --> 00:26:51,330
controllers essentially most most

769
00:26:51,330 --> 00:26:54,419
controllers in NC group are related to

770
00:26:54,419 --> 00:26:56,100
some particular resource say you have

771
00:26:56,100 --> 00:26:58,140
memory CPU aisle there are other ones

772
00:26:58,140 --> 00:27:01,409
however like safe path or freezer which

773
00:27:01,409 --> 00:27:04,289
I'll also interest in a second which are

774
00:27:04,289 --> 00:27:06,990
not related to some results but you put

775
00:27:06,990 --> 00:27:09,210
the processes in that C group based on

776
00:27:09,210 --> 00:27:11,070
some actions you want to take to them as

777
00:27:11,070 --> 00:27:14,399
a group so the idea is like basically

778
00:27:14,399 --> 00:27:15,840
you want to group them together so some

779
00:27:15,840 --> 00:27:18,120
user space utility can take some action

780
00:27:18,120 --> 00:27:21,120
based on that group pup is a tool for

781
00:27:21,120 --> 00:27:23,370
performance monitoring and tracing in I

782
00:27:23,370 --> 00:27:24,750
guess quite a few people have probably

783
00:27:24,750 --> 00:27:26,309
probably heard of it and the way it

784
00:27:26,309 --> 00:27:28,200
works is when you say I want to have a

785
00:27:28,200 --> 00:27:30,029
certain set of sequences you give it a

786
00:27:30,029 --> 00:27:31,830
cigarette cigarette path and it says

787
00:27:31,830 --> 00:27:34,260
okay here is like some particular set of

788
00:27:34,260 --> 00:27:36,269
processes which I'm gonna map into my

789
00:27:36,269 --> 00:27:38,610
own superpower okey so now you have six

790
00:27:38,610 --> 00:27:41,700
FS C group path and inside there is a

791
00:27:41,700 --> 00:27:43,769
completely separate secret hierarchy

792
00:27:43,769 --> 00:27:46,679
which only relates to puff this usually

793
00:27:46,679 --> 00:27:47,580
doesn't make a whole lot of sense

794
00:27:47,580 --> 00:27:48,960
usually what people want to do is

795
00:27:48,960 --> 00:27:50,940
monitor an existing secret hierarchy not

796
00:27:50,940 --> 00:27:53,850
create a new one so people resort ended

797
00:27:53,850 --> 00:27:55,769
up resorting to like tons of hacks like

798
00:27:55,769 --> 00:27:58,049
oh I want to like copy over this

799
00:27:58,049 --> 00:27:59,340
hierarchy to the other one they would

800
00:27:59,340 --> 00:28:01,529
run like a tool to copy it from one one

801
00:28:01,529 --> 00:28:03,210
hierarchy to another and like you end up

802
00:28:03,210 --> 00:28:04,649
with all these race conditions and like

803
00:28:04,649 --> 00:28:06,720
horrible and it was like really really

804
00:28:06,720 --> 00:28:09,330
bad so now having a unified power key

805
00:28:09,330 --> 00:28:10,799
means we don't have to sync you only

806
00:28:10,799 --> 00:28:12,720
have one hierarchy so there's no way

807
00:28:12,720 --> 00:28:13,649
this could possibly go wrong

808
00:28:13,649 --> 00:28:17,519
touchwood so everyone there's also like

809
00:28:17,519 --> 00:28:18,840
a lot of inconsistency between

810
00:28:18,840 --> 00:28:20,429
controllers this usually comes in in

811
00:28:20,429 --> 00:28:22,740
kind of two forms when you have

812
00:28:22,740 --> 00:28:24,899
inconsistent api's between controllers

813
00:28:24,899 --> 00:28:27,480
which do exactly the same thing so you

814
00:28:27,480 --> 00:28:31,350
have like the cpu both CPU and IO are

815
00:28:31,350 --> 00:28:33,630
essentially weight based or share based

816
00:28:33,630 --> 00:28:35,039
you give a certain amount of some

817
00:28:35,039 --> 00:28:37,679
resource based on a relative amount to

818
00:28:37,679 --> 00:28:41,070
some some other particular C group but

819
00:28:41,070 --> 00:28:42,419
the apos were completely different

820
00:28:42,419 --> 00:28:43,660
the APR that you had to learn

821
00:28:43,660 --> 00:28:45,520
api's to do one thing which is really

822
00:28:45,520 --> 00:28:48,190
really not ideal so there's been a lot

823
00:28:48,190 --> 00:28:50,200
of focus on trying to unify the api's

824
00:28:50,200 --> 00:28:52,270
and also unify the naming like I

825
00:28:52,270 --> 00:28:54,220
generally like it was a bit of a

826
00:28:54,220 --> 00:28:55,780
crapshoot everyone and now we have the

827
00:28:55,780 --> 00:28:57,610
opportunity to to rethink those names

828
00:28:57,610 --> 00:28:59,290
and generally standardize them a bit

829
00:28:59,290 --> 00:29:01,120
more so v2 is generally more intuitive

830
00:29:01,120 --> 00:29:02,940
up front

831
00:29:02,940 --> 00:29:05,230
another one is kind of inconsistent

832
00:29:05,230 --> 00:29:08,650
secret semantics for example rootsy

833
00:29:08,650 --> 00:29:11,250
groups for example sorry most C groups

834
00:29:11,250 --> 00:29:13,510
inherit their parents limits so when you

835
00:29:13,510 --> 00:29:15,640
create a when you create a child C group

836
00:29:15,640 --> 00:29:17,620
of some particular group it usually and

837
00:29:17,620 --> 00:29:20,380
it usually can only use up to its parent

838
00:29:20,380 --> 00:29:22,750
limits but some some controls didn't do

839
00:29:22,750 --> 00:29:23,890
that some controls did their own thing

840
00:29:23,890 --> 00:29:26,200
for some controllers this whole idea of

841
00:29:26,200 --> 00:29:27,700
a hierarchy was like an imaginary thing

842
00:29:27,700 --> 00:29:29,560
and it just created a new C group and

843
00:29:29,560 --> 00:29:31,030
didn't care where it was it was all a

844
00:29:31,030 --> 00:29:33,340
bit of a crapshoot so now with one

845
00:29:33,340 --> 00:29:34,900
unified hierarchy it's it's it's more

846
00:29:34,900 --> 00:29:37,170
difficult to it up I guess

847
00:29:37,170 --> 00:29:40,540
so we ones everyone's over flexibility

848
00:29:40,540 --> 00:29:41,920
also contributors to like a whole bunch

849
00:29:41,920 --> 00:29:45,070
of API problems for example when memory

850
00:29:45,070 --> 00:29:48,010
limits were first created they only

851
00:29:48,010 --> 00:29:50,020
limited a few like a couple types of

852
00:29:50,020 --> 00:29:51,940
memory and they were they were in this

853
00:29:51,940 --> 00:29:55,000
file memory limited bytes then as more

854
00:29:55,000 --> 00:29:56,350
and more memory types were added they

855
00:29:56,350 --> 00:29:58,000
ended up getting like their own files

856
00:29:58,000 --> 00:30:00,310
one by one so you ended up with memory

857
00:30:00,310 --> 00:30:01,990
don't limit in bytes memory don't came

858
00:30:01,990 --> 00:30:04,000
in not limited by its member came MTC

859
00:30:04,000 --> 00:30:05,620
fear of limited bytes member mebiner

860
00:30:05,620 --> 00:30:08,200
bytes and the really bad thing about

861
00:30:08,200 --> 00:30:10,510
this is now yes I have very granular

862
00:30:10,510 --> 00:30:12,700
control but it's not very useful because

863
00:30:12,700 --> 00:30:14,890
now say I want to let set a limit on the

864
00:30:14,890 --> 00:30:16,780
maximum number of TCP buffers which is

865
00:30:16,780 --> 00:30:19,300
set with memory Dottie's memory document

866
00:30:19,300 --> 00:30:23,230
TCP dilemna bytes now say I have like 10

867
00:30:23,230 --> 00:30:24,760
gigabytes of page cache free and I set a

868
00:30:24,760 --> 00:30:27,220
limit on the number of TCP buffers if I

869
00:30:27,220 --> 00:30:29,350
said like oh you should only get say X

870
00:30:29,350 --> 00:30:31,300
amount of TCP pokers if you go one over

871
00:30:31,300 --> 00:30:33,220
we don't kill you even if you had 10

872
00:30:33,220 --> 00:30:34,450
gigabytes of page cut free or something

873
00:30:34,450 --> 00:30:37,150
like that it's not a reasonable way of

874
00:30:37,150 --> 00:30:37,660
operating

875
00:30:37,660 --> 00:30:39,640
usually like most people don't want but

876
00:30:39,640 --> 00:30:40,930
most people don't care like you

877
00:30:40,930 --> 00:30:43,360
allocated one TCP buffer too many they

878
00:30:43,360 --> 00:30:45,160
want to give some kind of idea about the

879
00:30:45,160 --> 00:30:46,960
overall memory use and like reasonable

880
00:30:46,960 --> 00:30:49,780
memories generally unified limits a only

881
00:30:49,780 --> 00:30:51,850
reasonable way to approach that so yeah

882
00:30:51,850 --> 00:30:53,770
again another trade-off kind of in favor

883
00:30:53,770 --> 00:30:55,660
of in favor of usability over over

884
00:30:55,660 --> 00:30:58,170
ultimate flexibility

885
00:30:58,170 --> 00:31:00,340
generally if you do want to limit these

886
00:31:00,340 --> 00:31:02,680
things say you wanted to limit some

887
00:31:02,680 --> 00:31:04,360
particular kind of results like the paid

888
00:31:04,360 --> 00:31:06,220
controller is a very good example the

889
00:31:06,220 --> 00:31:08,380
pit in the early days of C groups it was

890
00:31:08,380 --> 00:31:10,180
considered maybe we could limit the

891
00:31:10,180 --> 00:31:11,590
number of hits by like limiting certain

892
00:31:11,590 --> 00:31:13,120
cut types of kernel memory but that

893
00:31:13,120 --> 00:31:14,230
turns out to be really really

894
00:31:14,230 --> 00:31:18,040
hard like so the way that was fixed was

895
00:31:18,040 --> 00:31:19,570
we now have a pit controller and that

896
00:31:19,570 --> 00:31:21,940
specifically controls this resource so

897
00:31:21,940 --> 00:31:24,040
if you do want to do very specific kinds

898
00:31:24,040 --> 00:31:26,200
of limiting like something TCP buffer or

899
00:31:26,200 --> 00:31:27,820
something else then you should do that

900
00:31:27,820 --> 00:31:29,500
for a new controller that's that's the

901
00:31:29,500 --> 00:31:34,210
reasonable way to do that so if you go

902
00:31:34,210 --> 00:31:36,520
to facebook.com right now there is a one

903
00:31:36,520 --> 00:31:37,960
in ten chance you're going to hit a

904
00:31:37,960 --> 00:31:41,170
server with superbee two we are running

905
00:31:41,170 --> 00:31:43,240
a security to pull in like the tens of

906
00:31:43,240 --> 00:31:46,500
thousand machines now and we're in we're

907
00:31:46,500 --> 00:31:48,640
investing heavily in cigarette v2 for

908
00:31:48,640 --> 00:31:49,930
like a number of reasons

909
00:31:49,930 --> 00:31:51,430
my main concern like I mentioned at the

910
00:31:51,430 --> 00:31:53,200
beginning is limiting the failure

911
00:31:53,200 --> 00:31:54,820
domains between surfaces I really care a

912
00:31:54,820 --> 00:31:57,040
lot about making sure that we don't have

913
00:31:57,040 --> 00:31:58,360
cascading failures or anything like that

914
00:31:58,360 --> 00:32:00,880
on a machine and also being able to go

915
00:32:00,880 --> 00:32:02,740
to manage the resource allocation in

916
00:32:02,740 --> 00:32:04,300
your data center especially at Facebook

917
00:32:04,300 --> 00:32:05,830
sellers it's really important like if we

918
00:32:05,830 --> 00:32:07,120
can suck at this that a little bit more

919
00:32:07,120 --> 00:32:11,290
a resource efficiency at the data center

920
00:32:11,290 --> 00:32:13,690
and that's that's a really big win we

921
00:32:13,690 --> 00:32:16,390
won secretly to manage with system D one

922
00:32:16,390 --> 00:32:18,010
of my teammates dr. kavak I was sitting

923
00:32:18,010 --> 00:32:20,470
back there did a talk about this at

924
00:32:20,470 --> 00:32:23,410
system D don't Kampf last year called I

925
00:32:23,410 --> 00:32:25,360
believe it was called deploying system D

926
00:32:25,360 --> 00:32:27,130
at scale correct me if I'm wrong yes it

927
00:32:27,130 --> 00:32:29,800
was so yes we're a really big

928
00:32:29,800 --> 00:32:31,840
contributor to to the core of secret v2

929
00:32:31,840 --> 00:32:33,430
we have two of the core maintainer z'

930
00:32:33,430 --> 00:32:35,620
working at Facebook and we will continue

931
00:32:35,620 --> 00:32:37,150
to drive innovation here like this is a

932
00:32:37,150 --> 00:32:39,240
big a big thing we work on right now

933
00:32:39,240 --> 00:32:42,250
so I already mentioned that Sigrid B to

934
00:32:42,250 --> 00:32:43,420
is kind of new

935
00:32:43,420 --> 00:32:45,610
Sigrid two has been usable for a little

936
00:32:45,610 --> 00:32:46,780
while now and the core is all very

937
00:32:46,780 --> 00:32:48,790
stable but that doesn't mean that there

938
00:32:48,790 --> 00:32:50,260
isn't still work to be done here like a

939
00:32:50,260 --> 00:32:51,730
lot of this is kind of building the

940
00:32:51,730 --> 00:32:54,400
building blocks for future work so the

941
00:32:54,400 --> 00:32:55,990
core API was are stable but there's

942
00:32:55,990 --> 00:32:57,550
definitely functionality to be worked on

943
00:32:57,550 --> 00:32:59,770
when thinking about C groups like most

944
00:32:59,770 --> 00:33:01,840
people think of kind of three things I

945
00:33:01,840 --> 00:33:04,450
guess which is IO memory CPU those are

946
00:33:04,450 --> 00:33:05,800
like pretty much the biggest ones and

947
00:33:05,800 --> 00:33:07,600
two out of three of those are merge

948
00:33:07,600 --> 00:33:09,000
currently

949
00:33:09,000 --> 00:33:11,310
the pic controller is also much for the

950
00:33:11,310 --> 00:33:13,590
CPU controller like it's very important

951
00:33:13,590 --> 00:33:14,880
but there have been some disagreements

952
00:33:14,880 --> 00:33:16,530
with the CPU subsystem team about how to

953
00:33:16,530 --> 00:33:18,570
merge it they have some disagreements

954
00:33:18,570 --> 00:33:19,890
about the new internal process

955
00:33:19,890 --> 00:33:22,170
constraint and also like having process

956
00:33:22,170 --> 00:33:24,150
granularity instead of internal thread

957
00:33:24,150 --> 00:33:25,230
granularity and stuff like this

958
00:33:25,230 --> 00:33:27,720
yeah there's a very juicy drama-filled

959
00:33:27,720 --> 00:33:30,960
thread at that link as as old Linux

960
00:33:30,960 --> 00:33:32,820
kernel mailing lists threats are it's

961
00:33:32,820 --> 00:33:35,610
probably still better than usual we also

962
00:33:35,610 --> 00:33:38,460
may end up with some thread based API

963
00:33:38,460 --> 00:33:39,930
for some particular kinds of thread

964
00:33:39,930 --> 00:33:42,090
operations that make sense that would be

965
00:33:42,090 --> 00:33:45,720
like in in the works I'm not a kind of

966
00:33:45,720 --> 00:33:47,730
big bet that we're doing right now is

967
00:33:47,730 --> 00:33:49,800
one thing that the Linux has never

968
00:33:49,800 --> 00:33:52,140
really had is a good metric for memory

969
00:33:52,140 --> 00:33:55,320
pressure like we have many kind of

970
00:33:55,320 --> 00:33:57,210
related metrics like the amount of

971
00:33:57,210 --> 00:33:58,950
memory you have free or the amount of

972
00:33:58,950 --> 00:34:00,870
memory used you can also look at stuff

973
00:34:00,870 --> 00:34:03,780
like certain kinds of page scans or like

974
00:34:03,780 --> 00:34:05,730
yeah it's it but it's all very curious

975
00:34:05,730 --> 00:34:07,620
t'k and ultimately none of these metrics

976
00:34:07,620 --> 00:34:09,540
prove that you actually are encountering

977
00:34:09,540 --> 00:34:10,710
memory pressure because they can also

978
00:34:10,710 --> 00:34:13,770
happen in a bunch of normal scenarios so

979
00:34:13,770 --> 00:34:16,320
our proposed measure is to track page

980
00:34:16,320 --> 00:34:20,219
refolding so we the essential way this

981
00:34:20,219 --> 00:34:22,909
will work is we track pages which are

982
00:34:22,909 --> 00:34:25,260
consistently revolted back into the

983
00:34:25,260 --> 00:34:29,190
inactive queue and essentially the way

984
00:34:29,190 --> 00:34:31,440
to explain how this whole thing works so

985
00:34:31,440 --> 00:34:33,510
you have the inactive set those are

986
00:34:33,510 --> 00:34:35,790
pages which the kernel considers are

987
00:34:35,790 --> 00:34:38,100
probably not being actively used by any

988
00:34:38,100 --> 00:34:40,170
process then you have the active set

989
00:34:40,170 --> 00:34:41,699
which it considers are more likely to be

990
00:34:41,699 --> 00:34:43,830
used by some some process and it's

991
00:34:43,830 --> 00:34:45,389
essentially one big list and the way it

992
00:34:45,389 --> 00:34:47,670
works is when you have a page fault you

993
00:34:47,670 --> 00:34:49,830
go to the head of the inactive list if

994
00:34:49,830 --> 00:34:51,480
you've got if a page was accessed again

995
00:34:51,480 --> 00:34:53,310
then it gets moved to the head of the

996
00:34:53,310 --> 00:34:54,900
active list which means it's protected

997
00:34:54,900 --> 00:34:57,270
from from reclaim and when we do a

998
00:34:57,270 --> 00:34:59,850
reclaim we go from the tail of the

999
00:34:59,850 --> 00:35:02,790
inactive list so we take the pages which

1000
00:35:02,790 --> 00:35:05,010
we consider the least likely to be used

1001
00:35:05,010 --> 00:35:08,790
of a reclaim so what happens if we keep

1002
00:35:08,790 --> 00:35:11,520
on faulting pages in and they get so far

1003
00:35:11,520 --> 00:35:12,870
to the end that we keep on reclaiming

1004
00:35:12,870 --> 00:35:14,280
them and then they fall back in again

1005
00:35:14,280 --> 00:35:16,590
immediately that probably means that we

1006
00:35:16,590 --> 00:35:18,840
have too many pages like at once for our

1007
00:35:18,840 --> 00:35:19,770
system to handle

1008
00:35:19,770 --> 00:35:21,480
means that we can't we end up pushing

1009
00:35:21,480 --> 00:35:23,460
them so fast off the edge that we simply

1010
00:35:23,460 --> 00:35:25,140
don't have the resources to be able to

1011
00:35:25,140 --> 00:35:26,670
deal with this number of pages that is

1012
00:35:26,670 --> 00:35:29,880
probably not a bad metric for for for

1013
00:35:29,880 --> 00:35:31,500
memory pressure and it's one which is

1014
00:35:31,500 --> 00:35:32,970
currently being worked on as part of the

1015
00:35:32,970 --> 00:35:34,590
security to effort as well because we do

1016
00:35:34,590 --> 00:35:36,510
want to have those metrics around memory

1017
00:35:36,510 --> 00:35:39,000
pressure not just memory usage which is

1018
00:35:39,000 --> 00:35:40,650
kind of only tangential to the thing but

1019
00:35:40,650 --> 00:35:45,060
you really want to know so sorry

1020
00:35:45,060 --> 00:35:49,650
question I thought I had a question so

1021
00:35:49,650 --> 00:35:53,760
we we also have tracking now of page

1022
00:35:53,760 --> 00:35:55,350
caps right max well this first point

1023
00:35:55,350 --> 00:35:57,420
means is we have the tracking of memory

1024
00:35:57,420 --> 00:35:58,860
and i/o but we don't have tracking for

1025
00:35:58,860 --> 00:36:01,980
CPU yet like you spend some time on CPU

1026
00:36:01,980 --> 00:36:03,330
waiting for network packets to come in

1027
00:36:03,330 --> 00:36:05,490
on the network we and we don't know who

1028
00:36:05,490 --> 00:36:06,600
it's for yet because they didn't get

1029
00:36:06,600 --> 00:36:08,670
routed yet and we can't account for that

1030
00:36:08,670 --> 00:36:10,320
yet I mean also can't account for the

1031
00:36:10,320 --> 00:36:12,540
CPU we spend like doing doing a page

1032
00:36:12,540 --> 00:36:14,400
cache right back yet that's something

1033
00:36:14,400 --> 00:36:15,600
which is going to take quite a bit of

1034
00:36:15,600 --> 00:36:17,670
effort but it's something which would

1035
00:36:17,670 --> 00:36:19,400
definitely work on at this point

1036
00:36:19,400 --> 00:36:21,720
yeah and that's for the second point I

1037
00:36:21,720 --> 00:36:23,850
already mentioned like the the resulting

1038
00:36:23,850 --> 00:36:25,980
generally the idea here is that we want

1039
00:36:25,980 --> 00:36:28,230
better metrics for for memory pressure

1040
00:36:28,230 --> 00:36:29,670
because right now we only have something

1041
00:36:29,670 --> 00:36:33,450
tangential you who used v1 I'll probably

1042
00:36:33,450 --> 00:36:35,490
also know about freezer freezer is like

1043
00:36:35,490 --> 00:36:37,290
an alternative to killing for example

1044
00:36:37,290 --> 00:36:39,060
like you can freeze some set of

1045
00:36:39,060 --> 00:36:41,790
processes in their state and then go and

1046
00:36:41,790 --> 00:36:43,620
decide like oh I want to raise the

1047
00:36:43,620 --> 00:36:44,910
memory limit or I want to kill them or I

1048
00:36:44,910 --> 00:36:47,010
want to stop so some new processes it

1049
00:36:47,010 --> 00:36:48,150
was essentially a way of freezing them

1050
00:36:48,150 --> 00:36:49,830
in time and having some other process

1051
00:36:49,830 --> 00:36:51,840
come and decide what to do about it

1052
00:36:51,840 --> 00:36:54,300
in in sigrid one this didn't work at all

1053
00:36:54,300 --> 00:36:57,660
basically like if you if you used

1054
00:36:57,660 --> 00:36:59,430
freezer one of the most common things

1055
00:36:59,430 --> 00:37:00,870
you might want to do is go and like get

1056
00:37:00,870 --> 00:37:02,250
a stack trace and work out what they

1057
00:37:02,250 --> 00:37:03,540
were doing when like they kept on

1058
00:37:03,540 --> 00:37:05,190
allocating memory or whatever it was

1059
00:37:05,190 --> 00:37:08,010
that you froze them for but like it's a

1060
00:37:08,010 --> 00:37:09,360
very common situation that you would end

1061
00:37:09,360 --> 00:37:11,220
up with like say gdb if you were try to

1062
00:37:11,220 --> 00:37:12,780
attach ddb it would end up in D state

1063
00:37:12,780 --> 00:37:15,450
which is not really the ideal result if

1064
00:37:15,450 --> 00:37:18,300
you want to like find out the stack of

1065
00:37:18,300 --> 00:37:19,740
some process which froze like that's

1066
00:37:19,740 --> 00:37:21,090
generally the complete opposite of what

1067
00:37:21,090 --> 00:37:24,030
what I would like the reason is like the

1068
00:37:24,030 --> 00:37:25,500
freezer implementation in v1 doesn't

1069
00:37:25,500 --> 00:37:26,940
guarantee that we stop anywhere

1070
00:37:26,940 --> 00:37:28,860
reasonable we we often stop in a stack

1071
00:37:28,860 --> 00:37:30,300
which makes absolutely no sense in the

1072
00:37:30,300 --> 00:37:31,090
kernel

1073
00:37:31,090 --> 00:37:34,300
so envy - the idea is to have like a

1074
00:37:34,300 --> 00:37:36,550
more kind of six top style mechanism six

1075
00:37:36,550 --> 00:37:39,610
top is very well defined and where it

1076
00:37:39,610 --> 00:37:42,490
stops is very well-defined as well so

1077
00:37:42,490 --> 00:37:43,990
it's it's kind of a more reasonable

1078
00:37:43,990 --> 00:37:45,900
solution to use first stopping processes

1079
00:37:45,900 --> 00:37:48,850
so the the v2 implementation of freezer

1080
00:37:48,850 --> 00:37:50,440
will be more along those kind of

1081
00:37:50,440 --> 00:37:54,250
semantics so I tooked a lot here about

1082
00:37:54,250 --> 00:37:55,930
trying to sell you cigrip you - but I

1083
00:37:55,930 --> 00:37:57,400
should actually tell you how to get it

1084
00:37:57,400 --> 00:37:58,510
probably at some point during this talk

1085
00:37:58,510 --> 00:38:00,340
so hopefully you're interested in trying

1086
00:38:00,340 --> 00:38:02,530
it out yourself so here's what you need

1087
00:38:02,530 --> 00:38:04,630
to get started with version 2 first you

1088
00:38:04,630 --> 00:38:07,030
need a kernel about 4.5 before that we

1089
00:38:07,030 --> 00:38:09,160
do have a developer flag which you can

1090
00:38:09,160 --> 00:38:11,050
go find I won't tell you because it'll

1091
00:38:11,050 --> 00:38:13,000
like eat you if you try and use it and

1092
00:38:13,000 --> 00:38:14,830
you're done what you're doing but I

1093
00:38:14,830 --> 00:38:16,060
really wouldn't recommend using it

1094
00:38:16,060 --> 00:38:17,980
before 14 54.5 was the first point we

1095
00:38:17,980 --> 00:38:18,870
have a stable API

1096
00:38:18,870 --> 00:38:21,310
once that's done more or less two things

1097
00:38:21,310 --> 00:38:23,230
to do you need to turn off all of the

1098
00:38:23,230 --> 00:38:25,360
controllers for v1 and you need to turn

1099
00:38:25,360 --> 00:38:29,100
on unmount the the filesystem for v2

1100
00:38:29,100 --> 00:38:31,090
typically you want your init system to

1101
00:38:31,090 --> 00:38:32,620
do this for system do you use it with

1102
00:38:32,620 --> 00:38:33,940
this flag you basically put both of

1103
00:38:33,940 --> 00:38:36,010
these on the kernel command line but if

1104
00:38:36,010 --> 00:38:37,930
you're crazy or you want to try it

1105
00:38:37,930 --> 00:38:39,370
yourself you can also manually mount it

1106
00:38:39,370 --> 00:38:44,230
and cry when things break so if you're

1107
00:38:44,230 --> 00:38:45,700
interested in hearing more about cgroups

1108
00:38:45,700 --> 00:38:48,100
come talk to me i'm happy to go over any

1109
00:38:48,100 --> 00:38:49,870
of what i've been talking about on v1 or

1110
00:38:49,870 --> 00:38:52,960
v2 and yeah are we have to go over any

1111
00:38:52,960 --> 00:38:54,760
questions you might have and if you've

1112
00:38:54,760 --> 00:38:56,170
used me one in the past which I guess

1113
00:38:56,170 --> 00:38:58,270
many of you have and you found it lucky

1114
00:38:58,270 --> 00:39:00,190
in some areas please do try out v2 and

1115
00:39:00,190 --> 00:39:02,040
let us know what you think thanks

1116
00:39:02,040 --> 00:39:12,969
[Applause]

