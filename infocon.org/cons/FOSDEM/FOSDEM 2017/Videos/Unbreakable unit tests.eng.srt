1
00:00:08,280 --> 00:00:11,670
hi everyone

2
00:00:12,510 --> 00:00:16,510
so I'm Mike Simonson on Twitter I'm a

3
00:00:16,510 --> 00:00:21,400
web developer I am one of the maintainer

4
00:00:21,400 --> 00:00:24,269
of doctrine for those who know the tool

5
00:00:24,269 --> 00:00:27,519
I'm also the organizer of bristle PHP if

6
00:00:27,519 --> 00:00:29,560
there are people from Brussels that are

7
00:00:29,560 --> 00:00:33,210
interested or if there are people that

8
00:00:33,210 --> 00:00:36,460
know any company that is willing to host

9
00:00:36,460 --> 00:00:39,370
us I'd be very happy to talk with you

10
00:00:39,370 --> 00:00:44,620
after the talk and I also worked at cube

11
00:00:44,620 --> 00:00:47,710
solution whenever I'm not behind my

12
00:00:47,710 --> 00:00:50,559
computer you can probably find me hiking

13
00:00:50,559 --> 00:00:56,260
somewhere outdoor now that that part is

14
00:00:56,260 --> 00:00:58,349
done

15
00:01:00,600 --> 00:01:05,740
would you mean why screen no it's

16
00:01:05,740 --> 00:01:12,960
apparently wait sorry

17
00:01:23,880 --> 00:01:28,548
nope oh I can

18
00:01:44,329 --> 00:01:48,500
no it's apparently the best I can do

19
00:02:03,730 --> 00:02:07,520
so I suppose everyone here is a PHP

20
00:02:07,520 --> 00:02:14,000
developer but who here is used to doing

21
00:02:14,000 --> 00:02:20,480
TDD at work ok quite a few people who is

22
00:02:20,480 --> 00:02:23,210
doing TDD like for more than five years

23
00:02:23,210 --> 00:02:26,930
I mean that is quite experienced ok

24
00:02:26,930 --> 00:02:32,600
I hope I'm still gonna give you a few

25
00:02:32,600 --> 00:02:36,250
tricks but this talk is basically

26
00:02:36,250 --> 00:02:38,959
everything that I've learned along the

27
00:02:38,959 --> 00:02:43,090
way going to conferences and meeting

28
00:02:43,090 --> 00:02:45,850
people from very different backgrounds

29
00:02:45,850 --> 00:02:48,470
for instance maybe some of you know

30
00:02:48,470 --> 00:02:51,530
drawer helper I'm probably butchering

31
00:02:51,530 --> 00:02:55,250
his name but it's a c-sharp developer

32
00:02:55,250 --> 00:02:58,520
that gives a very similar talk in

33
00:02:58,520 --> 00:03:02,240
c-sharp but most of what he learned me

34
00:03:02,240 --> 00:03:05,600
is applicable in any language and if you

35
00:03:05,600 --> 00:03:07,940
want to learn stuff about unit testing

36
00:03:07,940 --> 00:03:11,239
he has definitely very interesting stuff

37
00:03:11,239 --> 00:03:21,019
to say who here works agile at work also

38
00:03:21,019 --> 00:03:24,590
pretty much everyone who here works I

39
00:03:24,590 --> 00:03:27,140
mean the boss their boss says that they

40
00:03:27,140 --> 00:03:28,910
work agile but in fact they just do

41
00:03:28,910 --> 00:03:32,150
waterfall ok

42
00:03:32,150 --> 00:03:38,510
so as I said that that talk is going to

43
00:03:38,510 --> 00:03:42,700
be mostly about my experience but I

44
00:03:42,700 --> 00:03:47,239
think it's a lot of you will based on

45
00:03:47,239 --> 00:03:49,730
your answer a lot of you can relate to

46
00:03:49,730 --> 00:03:53,239
that experience my first experience with

47
00:03:53,239 --> 00:03:55,340
unit testing whether at school

48
00:03:55,340 --> 00:03:58,910
we're basically we were more learn we

49
00:03:58,910 --> 00:04:00,830
were more teach how to delete the test

50
00:04:00,830 --> 00:04:02,900
that just failed because we changed some

51
00:04:02,900 --> 00:04:05,360
piece of code and just do something else

52
00:04:05,360 --> 00:04:08,269
like test another part of the code than

53
00:04:08,269 --> 00:04:12,800
anything else in a way I could see that

54
00:04:12,800 --> 00:04:16,279
it might be useful but it was

55
00:04:16,279 --> 00:04:21,200
very frustrating after school I went to

56
00:04:21,200 --> 00:04:25,580
British company for my internship and

57
00:04:25,580 --> 00:04:30,410
there they really practiced the right

58
00:04:30,410 --> 00:04:33,130
way I would say or at least the first

59
00:04:33,130 --> 00:04:38,090
useful way that I had seen it was a very

60
00:04:38,090 --> 00:04:40,130
interesting experience for me because

61
00:04:40,130 --> 00:04:42,669
that was the first time that I could see

62
00:04:42,669 --> 00:04:49,820
someone developing new code using TDD in

63
00:04:49,820 --> 00:04:53,510
a way that wasn't cumbersome and wasn't

64
00:04:53,510 --> 00:04:56,060
just making me waste tons of time not

65
00:04:56,060 --> 00:04:58,070
doing what uh not knowing what where I

66
00:04:58,070 --> 00:05:03,850
was gonna go then I I went to my first

67
00:05:03,850 --> 00:05:06,800
bake job

68
00:05:06,800 --> 00:05:10,340
it was a very big company with lots of

69
00:05:10,340 --> 00:05:13,880
that whopper and apparently no one was

70
00:05:13,880 --> 00:05:16,880
interested in to building code that

71
00:05:16,880 --> 00:05:22,130
actually worked so I was I was mostly

72
00:05:22,130 --> 00:05:25,880
trying to do tests myself but I was the

73
00:05:25,880 --> 00:05:28,430
only one to run them I was also the only

74
00:05:28,430 --> 00:05:30,770
one to write them and the only one to

75
00:05:30,770 --> 00:05:33,410
fix them because I was the only one to

76
00:05:33,410 --> 00:05:36,950
notice when they break that was also

77
00:05:36,950 --> 00:05:41,720
very frustrating but yeah life goes on

78
00:05:41,720 --> 00:05:45,800
and I changed job to go in a much

79
00:05:45,800 --> 00:05:49,039
smaller company where I was heavily

80
00:05:49,039 --> 00:05:51,979
encouraged going to conference like

81
00:05:51,979 --> 00:05:54,919
first M and it's basically at those

82
00:05:54,919 --> 00:05:58,430
conference that I learned most of what I

83
00:05:58,430 --> 00:06:00,850
know now

84
00:06:02,110 --> 00:06:04,120
I'm mostly going to speak here about

85
00:06:04,120 --> 00:06:06,729
unit testing but that's just one part of

86
00:06:06,729 --> 00:06:09,580
all the tests that you can do on your

87
00:06:09,580 --> 00:06:13,509
application but before to speak about

88
00:06:13,509 --> 00:06:17,169
the different kind of test to see where

89
00:06:17,169 --> 00:06:20,020
the unit test stands there is also the

90
00:06:20,020 --> 00:06:22,629
pretty obvious question like when should

91
00:06:22,629 --> 00:06:27,879
we test it's always a cost-benefit

92
00:06:27,879 --> 00:06:33,219
question at some point like the project

93
00:06:33,219 --> 00:06:38,289
has to shape and you have to get paid so

94
00:06:38,289 --> 00:06:43,060
you have to know when to test and when

95
00:06:43,060 --> 00:06:47,349
not to test most of the time I'd say

96
00:06:47,349 --> 00:06:51,159
that it's rather a question like is that

97
00:06:51,159 --> 00:06:54,069
project going to live on after I

98
00:06:54,069 --> 00:06:56,919
finished working on it like am I going

99
00:06:56,919 --> 00:06:59,259
to give that project who this project

100
00:06:59,259 --> 00:07:01,029
responsibility to someone else is

101
00:07:01,029 --> 00:07:02,740
someone going to maintain have to

102
00:07:02,740 --> 00:07:06,550
maintain it if the answer is yes then

103
00:07:06,550 --> 00:07:08,620
it's probably a bit I mean it would be

104
00:07:08,620 --> 00:07:11,729
nicer for him to test it it's gonna

105
00:07:11,729 --> 00:07:14,050
simplify the job of the person that

106
00:07:14,050 --> 00:07:18,610
comes after you a lot especially because

107
00:07:18,610 --> 00:07:20,589
we live in an industry where we are

108
00:07:20,589 --> 00:07:22,750
asked to build prototype and all those

109
00:07:22,750 --> 00:07:28,360
prototype end up in production so if you

110
00:07:28,360 --> 00:07:32,110
wanna know when to test basically ask

111
00:07:32,110 --> 00:07:33,490
yourself the question if you want your

112
00:07:33,490 --> 00:07:39,400
project to succeed or not the unit tests

113
00:07:39,400 --> 00:07:48,520
in the wall test scene is basically the

114
00:07:48,520 --> 00:07:52,440
one that is at the bottom it's the test

115
00:07:52,440 --> 00:07:56,349
that is the closest to the logic of the

116
00:07:56,349 --> 00:08:00,009
code the one that is the fastest to run

117
00:08:00,009 --> 00:08:02,229
because it has the least dependency if

118
00:08:02,229 --> 00:08:04,779
your unit tests as well of the balance

119
00:08:04,779 --> 00:08:06,550
it's not a unit test anymore it's

120
00:08:06,550 --> 00:08:08,229
basically a functional test or an

121
00:08:08,229 --> 00:08:13,959
integration test and the fact that it's

122
00:08:13,959 --> 00:08:15,210
fast to run because it

123
00:08:15,210 --> 00:08:18,150
no dependency make it cheap to run and

124
00:08:18,150 --> 00:08:21,449
make it interesting in the sense that if

125
00:08:21,449 --> 00:08:24,090
you run those tests a lot then they are

126
00:08:24,090 --> 00:08:26,250
gonna be useful the only good reason to

127
00:08:26,250 --> 00:08:28,080
write a test is for the test to fail if

128
00:08:28,080 --> 00:08:30,210
the test never failed this is just

129
00:08:30,210 --> 00:08:32,940
useless it's just wasting time and space

130
00:08:32,940 --> 00:08:40,070
I suppose everyone has seen a unit test

131
00:08:40,070 --> 00:08:43,049
here the example is in Java but it's

132
00:08:43,049 --> 00:08:47,760
pretty much the same in any language you

133
00:08:47,760 --> 00:08:50,610
just have a method in some random class

134
00:08:50,610 --> 00:08:53,610
that is marked one way or another either

135
00:08:53,610 --> 00:08:56,430
way with the annotation of whatever else

136
00:08:56,430 --> 00:08:58,770
exists in your language that is similar

137
00:08:58,770 --> 00:09:03,380
to annotation and that's the same job -

138
00:09:03,380 --> 00:09:07,880
to mark that that method is a test

139
00:09:07,880 --> 00:09:12,180
whether give you is effectively the fact

140
00:09:12,180 --> 00:09:14,070
that you can have a piece of code that

141
00:09:14,070 --> 00:09:16,020
can detect that automatically and you

142
00:09:16,020 --> 00:09:17,520
don't need to program that part of the

143
00:09:17,520 --> 00:09:19,890
work it's just gonna pick up whichever

144
00:09:19,890 --> 00:09:22,290
test you have anywhere in your in your

145
00:09:22,290 --> 00:09:25,290
code and run them automatically it's a

146
00:09:25,290 --> 00:09:27,440
contract between between you and your

147
00:09:27,440 --> 00:09:33,570
unit testing framework the first issue

148
00:09:33,570 --> 00:09:36,450
that I had when I was in that big

149
00:09:36,450 --> 00:09:40,740
company trying to implement or and run

150
00:09:40,740 --> 00:09:43,860
the test myself was that I didn't really

151
00:09:43,860 --> 00:09:47,070
knew a lot of tools that could help me

152
00:09:47,070 --> 00:09:53,459
and now it's really easy to use any one

153
00:09:53,459 --> 00:09:55,350
of them I mean they're all over the

154
00:09:55,350 --> 00:09:58,050
place any unit testing framework has its

155
00:09:58,050 --> 00:10:02,430
own test runner you also have a build

156
00:10:02,430 --> 00:10:04,410
server that you can install to run your

157
00:10:04,410 --> 00:10:08,040
tests on a separate machine and you can

158
00:10:08,040 --> 00:10:11,160
even implement in really simple fashion

159
00:10:11,160 --> 00:10:14,670
a script that picks up every time you

160
00:10:14,670 --> 00:10:18,149
change your code and run the test that

161
00:10:18,149 --> 00:10:21,750
way you don't even need to away go out

162
00:10:21,750 --> 00:10:24,150
of your IDE if you use one and run the

163
00:10:24,150 --> 00:10:25,199
test it's just going to happen

164
00:10:25,199 --> 00:10:27,000
automatically you can have on one screen

165
00:10:27,000 --> 00:10:28,750
your test

166
00:10:28,750 --> 00:10:32,940
instantly running and working the other

167
00:10:32,940 --> 00:10:37,690
without any issue the build server is

168
00:10:37,690 --> 00:10:42,400
also important because as opposed to

169
00:10:42,400 --> 00:10:47,170
what I was doing it gives a way to show

170
00:10:47,170 --> 00:10:49,390
the test result to the other person in

171
00:10:49,390 --> 00:10:51,790
the team I was the only one to run them

172
00:10:51,790 --> 00:10:54,220
so I was the only one to notice when

173
00:10:54,220 --> 00:10:58,540
they failed it's like if someone cannot

174
00:10:58,540 --> 00:11:01,900
see the result of the test in the team

175
00:11:01,900 --> 00:11:04,360
obviously it's not that person is going

176
00:11:04,360 --> 00:11:06,850
to forget to run them at some points and

177
00:11:06,850 --> 00:11:11,400
then forget to use them completely so

178
00:11:11,400 --> 00:11:14,950
installing a build server if you're more

179
00:11:14,950 --> 00:11:19,110
than one person in the team feels like a

180
00:11:19,110 --> 00:11:22,600
necessity to me it became really easy

181
00:11:22,600 --> 00:11:23,710
now

182
00:11:23,710 --> 00:11:26,770
there are templates for PHP projects in

183
00:11:26,770 --> 00:11:31,860
Jenkins I suppose everyone knows Jenkins

184
00:11:31,860 --> 00:11:34,960
it's really easy to set up now you

185
00:11:34,960 --> 00:11:35,950
should definitely do it

186
00:11:35,950 --> 00:11:39,850
there are also IDE runner for whichever

187
00:11:39,850 --> 00:11:43,360
IDE that you use there is probably a

188
00:11:43,360 --> 00:11:45,640
test runner that's already integrated in

189
00:11:45,640 --> 00:11:47,080
it and can provide additional

190
00:11:47,080 --> 00:11:50,110
functionality like just run the tests

191
00:11:50,110 --> 00:11:58,600
that cover that piece of code yeah now

192
00:11:58,600 --> 00:12:02,530
writing those tests you can basically be

193
00:12:02,530 --> 00:12:04,660
in two different situation you are

194
00:12:04,660 --> 00:12:06,700
either wave writing test for a brand new

195
00:12:06,700 --> 00:12:10,150
project or you're writing test for

196
00:12:10,150 --> 00:12:12,810
existing code that you have to maintain

197
00:12:12,810 --> 00:12:17,500
let's face it there is way more projects

198
00:12:17,500 --> 00:12:20,200
to maintain than new project to do even

199
00:12:20,200 --> 00:12:22,930
though there is a lot of new project to

200
00:12:22,930 --> 00:12:27,640
do but like I suppose every one of you

201
00:12:27,640 --> 00:12:29,410
has had to maintain a project at some

202
00:12:29,410 --> 00:12:34,570
point and it's the bulk of the work if

203
00:12:34,570 --> 00:12:37,040
you have

204
00:12:37,040 --> 00:12:39,829
new code it's obviously going to be

205
00:12:39,829 --> 00:12:44,620
easier to start - in TDD on that code

206
00:12:44,620 --> 00:12:49,760
and in that is I would encourage you to

207
00:12:49,760 --> 00:12:53,990
take a look at BDD tools behavior driven

208
00:12:53,990 --> 00:12:56,630
development tools there are basically a

209
00:12:56,630 --> 00:13:01,339
little bit the same the same kind of

210
00:13:01,339 --> 00:13:04,130
tool that we have for unit testing for

211
00:13:04,130 --> 00:13:07,430
the code they have the same behavior but

212
00:13:07,430 --> 00:13:10,279
for the person that actually asked you

213
00:13:10,279 --> 00:13:13,339
the feature of that code so by writing

214
00:13:13,339 --> 00:13:15,949
scenario and behavior different

215
00:13:15,949 --> 00:13:17,949
development it's gonna guide you on what

216
00:13:17,949 --> 00:13:20,480
unit tests you should write so that you

217
00:13:20,480 --> 00:13:22,279
can write the code that fulfills those

218
00:13:22,279 --> 00:13:26,269
unit tests and fulfill two scenario I'm

219
00:13:26,269 --> 00:13:28,220
not going to talk about those tools

220
00:13:28,220 --> 00:13:30,170
there is a lot of documentation

221
00:13:30,170 --> 00:13:32,060
available pretty much everywhere if

222
00:13:32,060 --> 00:13:35,360
you're looking for one in PHP there is B

223
00:13:35,360 --> 00:13:37,540
hats for instance but there are other

224
00:13:37,540 --> 00:13:42,199
it's just the most well-known Oh sadly

225
00:13:42,199 --> 00:13:47,449
if you are not in that case most

226
00:13:47,449 --> 00:13:49,370
probably your code will have

227
00:13:49,370 --> 00:13:52,160
dependencies like often when you look at

228
00:13:52,160 --> 00:13:54,890
blog posts that describe how to do TDD

229
00:13:54,890 --> 00:13:58,490
they use a calculator example it's

230
00:13:58,490 --> 00:14:00,230
really nice because it's really concise

231
00:14:00,230 --> 00:14:04,910
but none of the code that I wrote is

232
00:14:04,910 --> 00:14:08,089
actually so dependency less than a

233
00:14:08,089 --> 00:14:13,459
calculator and as I said previously if

234
00:14:13,459 --> 00:14:16,640
you have dependencies and you use them

235
00:14:16,640 --> 00:14:18,649
in your unit tests it's gonna make the

236
00:14:18,649 --> 00:14:21,980
tests slow it's also going to be really

237
00:14:21,980 --> 00:14:24,019
hard to set up across the machine of all

238
00:14:24,019 --> 00:14:28,430
I mean reliably set up across the

239
00:14:28,430 --> 00:14:30,019
machine of everyone that's on a team

240
00:14:30,019 --> 00:14:31,399
especially if you have people that are

241
00:14:31,399 --> 00:14:34,040
Windows others that are on Mac and Linux

242
00:14:34,040 --> 00:14:37,069
and it's also going to be a pain to set

243
00:14:37,069 --> 00:14:41,220
up on the CI server if you have one

244
00:14:41,220 --> 00:14:43,839
some of those dependencies are a little

245
00:14:43,839 --> 00:14:46,690
bit more subtle than others often people

246
00:14:46,690 --> 00:14:50,170
don't realize that the time is really

247
00:14:50,170 --> 00:14:55,240
annoying dependency and I remember that

248
00:14:55,240 --> 00:14:58,240
when I was in London one of the tests

249
00:14:58,240 --> 00:15:01,690
that I fixed was a test that failed six

250
00:15:01,690 --> 00:15:04,899
months on the year and it was basically

251
00:15:04,899 --> 00:15:10,420
just an issue in a data calculation that

252
00:15:10,420 --> 00:15:18,100
wasn't taking into account the yeah the

253
00:15:18,100 --> 00:15:22,240
daylight saving time it's really hard to

254
00:15:22,240 --> 00:15:24,670
figure out that is the issue if you

255
00:15:24,670 --> 00:15:27,700
don't see the time as a dependency of

256
00:15:27,700 --> 00:15:29,950
your code and try to extract the

257
00:15:29,950 --> 00:15:35,200
dependency in a very explicit way one of

258
00:15:35,200 --> 00:15:37,540
the way that I've seen people deal with

259
00:15:37,540 --> 00:15:41,350
those dependencies is creating what's

260
00:15:41,350 --> 00:15:46,420
called fake object it's really simple to

261
00:15:46,420 --> 00:15:48,459
do here you have an example with the

262
00:15:48,459 --> 00:15:51,370
migration class of doctrine migration it

263
00:15:51,370 --> 00:15:53,290
has a bunch of methods and if you need

264
00:15:53,290 --> 00:15:56,440
to create a fake object for that you

265
00:15:56,440 --> 00:16:01,180
just extend migration and override all

266
00:16:01,180 --> 00:16:02,949
the function that all the public

267
00:16:02,949 --> 00:16:06,870
function of that of that object without

268
00:16:06,870 --> 00:16:08,980
putting anything in the body of the

269
00:16:08,980 --> 00:16:11,920
function and you have just an object

270
00:16:11,920 --> 00:16:14,769
that is really similar but doesn't do

271
00:16:14,769 --> 00:16:18,940
anything it's really easy to do that

272
00:16:18,940 --> 00:16:23,410
like if you start testing but it's going

273
00:16:23,410 --> 00:16:25,470
to be obtained really really fast

274
00:16:25,470 --> 00:16:28,930
because every time you will change

275
00:16:28,930 --> 00:16:31,209
something in the object that you extend

276
00:16:31,209 --> 00:16:34,240
you're gonna have to change it also in

277
00:16:34,240 --> 00:16:36,040
the fake object that's a lot of code

278
00:16:36,040 --> 00:16:38,649
that you have to maintain yourself every

279
00:16:38,649 --> 00:16:40,269
code that you write yourself you have to

280
00:16:40,269 --> 00:16:47,680
maintain yourself and and that's it

281
00:16:47,680 --> 00:16:51,610
now there is also who heard already

282
00:16:51,610 --> 00:16:55,629
about mocking frameworks most of you so

283
00:16:55,629 --> 00:16:57,610
I can probably go a little bit faster

284
00:16:57,610 --> 00:17:00,879
there but it's basically a piece of code

285
00:17:00,879 --> 00:17:03,009
that will do that work for you

286
00:17:03,009 --> 00:17:05,648
automatically so every time that you

287
00:17:05,648 --> 00:17:07,630
change something in your object it can

288
00:17:07,630 --> 00:17:10,539
regenerate that fake object

289
00:17:10,539 --> 00:17:15,398
automatically it can also provide a lot

290
00:17:15,398 --> 00:17:17,740
of additional functionality on top of

291
00:17:17,740 --> 00:17:21,189
that for instance you can verify that

292
00:17:21,189 --> 00:17:23,439
certain methods of your object have been

293
00:17:23,439 --> 00:17:27,159
called or have not been called which is

294
00:17:27,159 --> 00:17:29,260
much harder to do if you implement the

295
00:17:29,260 --> 00:17:36,490
fake object yourself here you have an

296
00:17:36,490 --> 00:17:39,520
example of one of the mocking library

297
00:17:39,520 --> 00:17:44,610
that exists in PHP it's called mercury

298
00:17:44,970 --> 00:17:48,340
there is also a lot of father there is

299
00:17:48,340 --> 00:17:52,380
prophecy and even PHP unit has its own

300
00:17:52,380 --> 00:17:59,820
mocking library but mercury has very

301
00:17:59,820 --> 00:18:03,210
interesting feature like for instance

302
00:18:03,210 --> 00:18:05,559
one of the thing that's annoying when

303
00:18:05,559 --> 00:18:07,570
you have a lot of stuff to mark in your

304
00:18:07,570 --> 00:18:10,809
code is that sometimes you have to

305
00:18:10,809 --> 00:18:12,940
create a lot of mock object that's

306
00:18:12,940 --> 00:18:15,100
returned each other until you have

307
00:18:15,100 --> 00:18:16,899
actually marked the dependency that you

308
00:18:16,899 --> 00:18:19,330
want it to mark and you can do that at

309
00:18:19,330 --> 00:18:23,500
once with Mal free which is nice

310
00:18:23,500 --> 00:18:25,960
although it might mean in the first

311
00:18:25,960 --> 00:18:29,020
place that your code has a problem of

312
00:18:29,020 --> 00:18:31,059
structure if you have so much to mark

313
00:18:31,059 --> 00:18:34,990
but if it's just good that you have to

314
00:18:34,990 --> 00:18:39,010
maintain it's a really quick fix before

315
00:18:39,010 --> 00:18:42,549
you can refactor that piece of code any

316
00:18:42,549 --> 00:18:46,740
questions yet nope

317
00:18:47,170 --> 00:18:51,200
now I don't know if anyone heard about

318
00:18:51,200 --> 00:18:55,070
Oh - mocking container do okay I'm gonna

319
00:18:55,070 --> 00:18:57,680
do something sadly that's not something

320
00:18:57,680 --> 00:19:01,910
that exists in PHP yet at least III

321
00:19:01,910 --> 00:19:06,580
couldn't find any implementation but

322
00:19:06,580 --> 00:19:09,590
it's that idea that in most framework

323
00:19:09,590 --> 00:19:13,610
now they have a dependency injection

324
00:19:13,610 --> 00:19:16,970
container that you configure so they can

325
00:19:16,970 --> 00:19:18,590
create the object that you need in your

326
00:19:18,590 --> 00:19:21,290
application and they reuse that

327
00:19:21,290 --> 00:19:24,910
container to automatically generate

328
00:19:24,910 --> 00:19:26,140
mocks

329
00:19:26,140 --> 00:19:29,360
so because that dependency injection

330
00:19:29,360 --> 00:19:32,180
container already knows how to build the

331
00:19:32,180 --> 00:19:34,370
actual object it can really easily

332
00:19:34,370 --> 00:19:38,140
create that object only passing its

333
00:19:38,140 --> 00:19:39,520
mocks

334
00:19:39,520 --> 00:19:42,560
so you have actually the real object it

335
00:19:42,560 --> 00:19:52,760
just cannot do anything on its own now

336
00:19:52,760 --> 00:20:00,440
the the time dependency the solution to

337
00:20:00,440 --> 00:20:03,530
fix the time dependency is basically to

338
00:20:03,530 --> 00:20:05,240
pass the time every time you need to use

339
00:20:05,240 --> 00:20:08,590
it if you have the time now anywhere or

340
00:20:08,590 --> 00:20:11,360
date time without any parameter and you

341
00:20:11,360 --> 00:20:14,180
were in your code I just gonna make that

342
00:20:14,180 --> 00:20:17,660
piece of code really hard to test and

343
00:20:17,660 --> 00:20:21,820
you should probably buy that information

344
00:20:21,820 --> 00:20:31,450
at at at creation time so

345
00:20:31,560 --> 00:20:39,169
it looks like that piece of example is

346
00:20:39,860 --> 00:20:45,090
okay sorry this is actually showing how

347
00:20:45,090 --> 00:20:49,610
you can you can do that pass the time

348
00:20:49,760 --> 00:20:52,680
without having to change too much if you

349
00:20:52,680 --> 00:20:55,770
do it at first you can implement an

350
00:20:55,770 --> 00:20:57,480
interface a clock interface that just

351
00:20:57,480 --> 00:21:02,760
returned the current time and then you

352
00:21:02,760 --> 00:21:04,500
can implement to class a system clock

353
00:21:04,500 --> 00:21:08,340
that just do that returned a time now

354
00:21:08,340 --> 00:21:10,470
and a mock clock

355
00:21:10,470 --> 00:21:16,500
that's an about clock that is going to

356
00:21:16,500 --> 00:21:19,350
return the time that you decide in your

357
00:21:19,350 --> 00:21:22,560
test okay I'm sorry for the order of the

358
00:21:22,560 --> 00:21:27,240
slide here but yeah the first one was

359
00:21:27,240 --> 00:21:33,480
showing the problem but here bypassing

360
00:21:33,480 --> 00:21:35,520
the clock and asking the clock the

361
00:21:35,520 --> 00:21:38,010
current time we have actually fixed or

362
00:21:38,010 --> 00:21:40,590
dependency issue to the time if we have

363
00:21:40,590 --> 00:21:43,140
any test that needs it you we can just

364
00:21:43,140 --> 00:21:47,550
replace the system clock by the Mach one

365
00:21:47,550 --> 00:21:49,950
and passive the time that we want to use

366
00:21:49,950 --> 00:21:54,780
in our test it's mostly useful if you

367
00:21:54,780 --> 00:21:59,610
are making calculation but it doesn't

368
00:21:59,610 --> 00:22:01,500
take a lot of time to implement so I

369
00:22:01,500 --> 00:22:04,920
would recommend to take a look at that

370
00:22:04,920 --> 00:22:10,150
solution now

371
00:22:10,150 --> 00:22:13,960
it's all good but we also have a big

372
00:22:13,960 --> 00:22:16,029
problem in the documentation of this of

373
00:22:16,029 --> 00:22:19,179
the the unit testing framework in

374
00:22:19,179 --> 00:22:24,669
general because they never really

375
00:22:24,669 --> 00:22:27,070
explain you how you should structure

376
00:22:27,070 --> 00:22:29,409
your tests or how you should write them

377
00:22:29,409 --> 00:22:31,840
because you have that freedom in that

378
00:22:31,840 --> 00:22:35,140
method of your unit test where you can

379
00:22:35,140 --> 00:22:41,679
do anything you want yeah it's maybe a

380
00:22:41,679 --> 00:22:47,490
little bit hurtful in that sense and

381
00:22:47,490 --> 00:22:50,020
often the the the information that you

382
00:22:50,020 --> 00:22:54,820
can find at least in my opinion makes

383
00:22:54,820 --> 00:22:57,970
you end up in with tests that are really

384
00:22:57,970 --> 00:23:03,399
hard to maintain maybe we can come back

385
00:23:03,399 --> 00:23:07,140
to the definition of the of a unit test

386
00:23:07,140 --> 00:23:10,870
it's an automated piece of code that's a

387
00:23:10,870 --> 00:23:15,909
really important one because at the the

388
00:23:15,909 --> 00:23:18,399
company where my girlfriend worked

389
00:23:18,399 --> 00:23:21,510
they had unit testing that they told her

390
00:23:21,510 --> 00:23:25,870
while they hired hired her it was just

391
00:23:25,870 --> 00:23:28,029
some person with an excel sheet file

392
00:23:28,029 --> 00:23:29,950
that was just running the test by

393
00:23:29,950 --> 00:23:31,450
clicking on the button in the interface

394
00:23:31,450 --> 00:23:36,279
that's not a unit test it's a unit of

395
00:23:36,279 --> 00:23:41,500
work of the system that one is really

396
00:23:41,500 --> 00:23:45,039
hard to define I've not seen anyone yet

397
00:23:45,039 --> 00:23:48,130
that could give me a proper definition

398
00:23:48,130 --> 00:23:51,490
of that the only thing that I can tell

399
00:23:51,490 --> 00:23:57,789
you is that to me a unit test it's a

400
00:23:57,789 --> 00:23:59,890
test that tests the smallest possible

401
00:23:59,890 --> 00:24:03,159
blocks of code and you can check that if

402
00:24:03,159 --> 00:24:07,929
you use code coverage often you will see

403
00:24:07,929 --> 00:24:10,690
people that use code coverage as a sort

404
00:24:10,690 --> 00:24:16,240
of vanity vanity thing on their read me

405
00:24:16,240 --> 00:24:19,510
on github yeah yeah I have a hundred

406
00:24:19,510 --> 00:24:21,640
person code coverage but that doesn't

407
00:24:21,640 --> 00:24:23,330
give you an indication

408
00:24:23,330 --> 00:24:26,780
on the quality of those tests if they

409
00:24:26,780 --> 00:24:29,030
are easy to understand what they are

410
00:24:29,030 --> 00:24:32,480
actually testing and if you're if it's

411
00:24:32,480 --> 00:24:34,280
going to be possible to modify them or

412
00:24:34,280 --> 00:24:36,490
not

413
00:24:37,600 --> 00:24:41,330
that's test should check one and only

414
00:24:41,330 --> 00:24:43,970
one assumption about the code that one

415
00:24:43,970 --> 00:24:46,100
is a really important one as a doctrine

416
00:24:46,100 --> 00:24:48,830
maintainer I sometimes read pull

417
00:24:48,830 --> 00:24:52,070
requests where we have tests there are

418
00:24:52,070 --> 00:24:54,980
like 200 lines of code and you will see

419
00:24:54,980 --> 00:24:57,980
someone that do something then assert

420
00:24:57,980 --> 00:24:59,810
something then do something else then

421
00:24:59,810 --> 00:25:03,230
assert something else and it's actually

422
00:25:03,230 --> 00:25:06,050
impossible to understand what he's

423
00:25:06,050 --> 00:25:08,240
trying to test or what he's trying to do

424
00:25:08,240 --> 00:25:11,690
in that test test one thing put what

425
00:25:11,690 --> 00:25:13,190
you're testing in the name of the method

426
00:25:13,190 --> 00:25:15,590
and the person that comes after you is

427
00:25:15,590 --> 00:25:21,500
going to love you it doesn't actually

428
00:25:21,500 --> 00:25:24,730
still if you allowed an information of

429
00:25:24,730 --> 00:25:31,360
the structure of the test yeah

430
00:25:35,610 --> 00:25:40,150
as I said one of the important stuff to

431
00:25:40,150 --> 00:25:42,280
test the quality of a test is to make it

432
00:25:42,280 --> 00:25:45,250
fail first if the test didn't fail your

433
00:25:45,250 --> 00:25:47,200
can never be sure that it actually

434
00:25:47,200 --> 00:25:49,210
tested what you expected it to test

435
00:25:49,210 --> 00:25:51,000
that's something that happened to me

436
00:25:51,000 --> 00:25:54,550
countless time writing tests thinking

437
00:25:54,550 --> 00:25:56,260
that they work and never see them

438
00:25:56,260 --> 00:25:58,060
failing because they were actually not

439
00:25:58,060 --> 00:26:04,150
testing what I taught at all as I told

440
00:26:04,150 --> 00:26:07,350
you the code coverage which is the

441
00:26:07,350 --> 00:26:10,270
really way better use trying to

442
00:26:10,270 --> 00:26:12,160
determine what you are testing than

443
00:26:12,160 --> 00:26:15,090
trying to give you a good feeling by

444
00:26:15,090 --> 00:26:18,820
showing a high percentage that the best

445
00:26:18,820 --> 00:26:21,390
way you can use the code coverage is

446
00:26:21,390 --> 00:26:24,220
trying to cover only one test you run

447
00:26:24,220 --> 00:26:27,760
one test and you see how much code it's

448
00:26:27,760 --> 00:26:30,250
covering if it's covering hundreds of

449
00:26:30,250 --> 00:26:33,670
line it's not a unit test anymore it's

450
00:26:33,670 --> 00:26:36,100
probably going to be slow and it's going

451
00:26:36,100 --> 00:26:37,960
to be much harder to understand what

452
00:26:37,960 --> 00:26:40,950
it's trying to test

453
00:26:49,550 --> 00:26:57,240
okay what is that example I'm sorry yeah

454
00:26:57,240 --> 00:26:59,190
that's the test that he's trying to test

455
00:26:59,190 --> 00:27:03,270
no that's another problem of the code

456
00:27:03,270 --> 00:27:05,670
coverage often you can end up with a

457
00:27:05,670 --> 00:27:07,920
hundred person car coverage and you

458
00:27:07,920 --> 00:27:10,410
think you are safe except that in that

459
00:27:10,410 --> 00:27:13,080
case you can write three tests that will

460
00:27:13,080 --> 00:27:15,840
come will give you a hundred person code

461
00:27:15,840 --> 00:27:18,950
coverage but they are not giving you

462
00:27:18,950 --> 00:27:21,450
they are not testing all the possible

463
00:27:21,450 --> 00:27:24,410
scenario that that code can be in

464
00:27:24,410 --> 00:27:31,200
because actually maybe it's better ask

465
00:27:31,200 --> 00:27:33,090
like how many tests do you think you

466
00:27:33,090 --> 00:27:34,860
have to write to cover all the scenario

467
00:27:34,860 --> 00:27:43,530
of that example so who says free who

468
00:27:43,530 --> 00:27:52,350
says four five six twenty seven how do

469
00:27:52,350 --> 00:27:58,830
you reach that number three power three

470
00:27:58,830 --> 00:28:07,320
I think it's three factorial but I would

471
00:28:07,320 --> 00:28:09,150
say it's three factorial three to be

472
00:28:09,150 --> 00:28:10,860
sure that you pass in all the if and

473
00:28:10,860 --> 00:28:12,840
then one more because you could pass in

474
00:28:12,840 --> 00:28:18,510
none of them but anyway it's that that

475
00:28:18,510 --> 00:28:20,250
piece of code could give you the

476
00:28:20,250 --> 00:28:21,990
impression that your code is tested and

477
00:28:21,990 --> 00:28:24,330
can still end up in a situation that you

478
00:28:24,330 --> 00:28:28,380
did not expect how can you detect that

479
00:28:28,380 --> 00:28:32,310
it like it's really hard to know if your

480
00:28:32,310 --> 00:28:34,590
test is good and the only tool that can

481
00:28:34,590 --> 00:28:38,670
help you do that is mutation testing any

482
00:28:38,670 --> 00:28:41,970
any one of you heard about mutation

483
00:28:41,970 --> 00:28:47,070
testing ok quite a few people for those

484
00:28:47,070 --> 00:28:50,850
who don't know again it's the ID to try

485
00:28:50,850 --> 00:28:54,390
to use the code coverage in a slightly

486
00:28:54,390 --> 00:28:59,340
different way we have a PHP tool to do

487
00:28:59,340 --> 00:28:59,580
that

488
00:28:59,580 --> 00:29:01,200
it's called Hamburg

489
00:29:01,200 --> 00:29:03,540
it's actually going to run your test

490
00:29:03,540 --> 00:29:06,570
using code coverage so it can map each

491
00:29:06,570 --> 00:29:09,200
test with a piece of code that is

492
00:29:09,200 --> 00:29:13,560
covering and based on that it's going to

493
00:29:13,560 --> 00:29:17,100
change logic in your actual code it's

494
00:29:17,100 --> 00:29:21,390
going to randomly change greater than

495
00:29:21,390 --> 00:29:24,810
into lower or equal and that kind of

496
00:29:24,810 --> 00:29:29,010
change that are actually syntax lis

497
00:29:29,010 --> 00:29:31,350
correct but will change the behavior of

498
00:29:31,350 --> 00:29:33,930
your test and then it runs the test that

499
00:29:33,930 --> 00:29:36,540
covered that piece of code and there can

500
00:29:36,540 --> 00:29:38,310
be only three solution either way the

501
00:29:38,310 --> 00:29:41,550
code blow up the test catch the failure

502
00:29:41,550 --> 00:29:43,890
or the test doesn't see anything and

503
00:29:43,890 --> 00:29:46,020
it's actually that part that interests

504
00:29:46,020 --> 00:29:50,850
us if your tests did not catch a change

505
00:29:50,850 --> 00:29:53,310
of behavior of your code

506
00:29:53,310 --> 00:29:56,190
I mean it probably means that the test

507
00:29:56,190 --> 00:29:59,040
is not that good the the problem of that

508
00:29:59,040 --> 00:30:00,930
kind of tool is that because the change

509
00:30:00,930 --> 00:30:03,360
are randomly generated over your code

510
00:30:03,360 --> 00:30:06,780
you have to inspect the change that it

511
00:30:06,780 --> 00:30:11,760
did because it could have no actual

512
00:30:11,760 --> 00:30:14,310
change in behavior it's just the syntax

513
00:30:14,310 --> 00:30:17,040
that change in PHP but that's something

514
00:30:17,040 --> 00:30:19,740
that you have to go through manually so

515
00:30:19,740 --> 00:30:21,780
it's quite slow but it's still very

516
00:30:21,780 --> 00:30:28,470
useful to to determine if your tests are

517
00:30:28,470 --> 00:30:31,530
good as I said because it's going to try

518
00:30:31,530 --> 00:30:34,110
to map your code to the piece of code

519
00:30:34,110 --> 00:30:38,730
that is covered by that test if each of

520
00:30:38,730 --> 00:30:41,850
your tests cover hundreds of line it's

521
00:30:41,850 --> 00:30:44,520
gonna take forever to run that kind of

522
00:30:44,520 --> 00:30:48,650
tool and it's gonna be even harder to

523
00:30:48,650 --> 00:30:51,960
try to interpret the result of that tool

524
00:30:51,960 --> 00:30:54,330
so for instance on doctrine we cannot

525
00:30:54,330 --> 00:30:56,700
run it because it would actually take

526
00:30:56,700 --> 00:31:01,380
pretty much amount on my machine so we

527
00:31:01,380 --> 00:31:04,970
have a lot of work to improve the test

528
00:31:06,210 --> 00:31:09,090
now on the actual structure of the test

529
00:31:09,090 --> 00:31:14,440
the best advice I've got this discounts

530
00:31:14,440 --> 00:31:18,880
from drawer actually it's I don't know a

531
00:31:18,880 --> 00:31:20,860
bit weird that I've could never read

532
00:31:20,860 --> 00:31:23,710
about that anywhere but I hope that

533
00:31:23,710 --> 00:31:29,170
you're gonna find it interesting you can

534
00:31:29,170 --> 00:31:31,270
read about that everywhere

535
00:31:31,270 --> 00:31:35,050
what is AAA anyone does anyone know what

536
00:31:35,050 --> 00:31:43,110
a triple-a is sorry yeah also batteries

537
00:31:43,110 --> 00:31:48,550
in the field of unit testing a is that

538
00:31:48,550 --> 00:31:52,390
idea that you should have three part in

539
00:31:52,390 --> 00:31:56,110
your unit test the arrange act and a

540
00:31:56,110 --> 00:32:01,810
third part of your test I basically mean

541
00:32:01,810 --> 00:32:04,630
that in the arrange part you set up

542
00:32:04,630 --> 00:32:08,320
something then you act on it you call a

543
00:32:08,320 --> 00:32:11,350
method on that piece of code and then

544
00:32:11,350 --> 00:32:15,120
you assert a certain result on it so

545
00:32:15,120 --> 00:32:17,940
here we are building interest collection

546
00:32:17,940 --> 00:32:20,050
adding an element to it and then

547
00:32:20,050 --> 00:32:21,910
checking that the element is effectively

548
00:32:21,910 --> 00:32:29,440
in the collection object or not the

549
00:32:29,440 --> 00:32:31,050
problem is that there is no way to

550
00:32:31,050 --> 00:32:33,640
enforce that kind of stuff like you

551
00:32:33,640 --> 00:32:38,040
really have to read your test and see if

552
00:32:38,040 --> 00:32:40,360
they are actually following that

553
00:32:40,360 --> 00:32:43,900
guidance or not it's just the guidance

554
00:32:43,900 --> 00:32:47,730
so it might not work everywhere so far

555
00:32:47,730 --> 00:32:49,060
for me

556
00:32:49,060 --> 00:32:52,090
it has always worked but maybe someone

557
00:32:52,090 --> 00:32:56,290
has an example where it might be not so

558
00:32:56,290 --> 00:32:58,500
useful

559
00:32:59,360 --> 00:33:04,850
the arranged part of the test here you

560
00:33:04,850 --> 00:33:10,430
can see an example where in your range

561
00:33:10,430 --> 00:33:14,170
part someone is actually creating two

562
00:33:14,170 --> 00:33:18,110
automobiles then painting one of them

563
00:33:18,110 --> 00:33:22,220
and no sorry yeah

564
00:33:22,220 --> 00:33:32,450
and asserting weight so someone is

565
00:33:32,450 --> 00:33:34,820
creating two cars with two different

566
00:33:34,820 --> 00:33:37,460
colors then painting one window with the

567
00:33:37,460 --> 00:33:40,880
color or the other and checking that in

568
00:33:40,880 --> 00:33:45,610
the end that the color was effectively

569
00:33:45,610 --> 00:33:51,020
painted on that second car can anyone

570
00:33:51,020 --> 00:33:55,970
see any problem that could arise if you

571
00:33:55,970 --> 00:33:58,130
write the test like that like it's

572
00:33:58,130 --> 00:34:03,110
respecting the arranger act assert if

573
00:34:03,110 --> 00:34:08,870
you have that kind of test over time

574
00:34:08,870 --> 00:34:11,659
it's probably going to be an issue you

575
00:34:11,659 --> 00:34:21,520
can scan someone cy yeah sorry

576
00:34:25,570 --> 00:34:29,000
yeah so your object is probably going to

577
00:34:29,000 --> 00:34:32,780
evolve and you might decide at some

578
00:34:32,780 --> 00:34:35,150
point that having the color as a string

579
00:34:35,150 --> 00:34:37,639
might be not the best idea and you

580
00:34:37,639 --> 00:34:40,909
change your automobile to pass an object

581
00:34:40,909 --> 00:34:43,280
as we present the color for instance or

582
00:34:43,280 --> 00:34:45,230
change anything else in the constructor

583
00:34:45,230 --> 00:34:47,270
of the automobile and you need to change

584
00:34:47,270 --> 00:34:49,100
all your tests you need to adapt that

585
00:34:49,100 --> 00:34:54,350
everywhere in all your tests so fix that

586
00:34:54,350 --> 00:34:56,418
the advice that you will see everywhere

587
00:34:56,418 --> 00:34:58,760
is oh but it's easy just use the setup

588
00:34:58,760 --> 00:35:04,400
method every unit framework every unit

589
00:35:04,400 --> 00:35:06,710
testing framework provide that kind of

590
00:35:06,710 --> 00:35:10,180
facilities one method that will get cold

591
00:35:10,180 --> 00:35:13,100
every time just before running your

592
00:35:13,100 --> 00:35:18,410
tests it works

593
00:35:18,410 --> 00:35:22,670
but it has two issues first it means

594
00:35:22,670 --> 00:35:25,430
that now all your tests have a

595
00:35:25,430 --> 00:35:27,590
dependency on that setup method and if

596
00:35:27,590 --> 00:35:30,680
at some point one of the tests make a

597
00:35:30,680 --> 00:35:34,580
change to the object it's gonna its

598
00:35:34,580 --> 00:35:37,280
might affect the following tests that

599
00:35:37,280 --> 00:35:40,550
can run we have things for that now in

600
00:35:40,550 --> 00:35:44,600
PHP unit and most of the time it

601
00:35:44,600 --> 00:35:46,160
shouldn't be an issue because it's

602
00:35:46,160 --> 00:35:48,350
actually PHP unit that's gonna make a

603
00:35:48,350 --> 00:35:51,560
new instance of the unit testing class

604
00:35:51,560 --> 00:35:55,930
and call the setup and called the next

605
00:35:55,930 --> 00:35:59,960
test in a computer completely separate

606
00:35:59,960 --> 00:36:03,350
fashion but still you could end up in

607
00:36:03,350 --> 00:36:05,540
situation especially when you're trying

608
00:36:05,540 --> 00:36:08,510
to mark databases and stuff where one of

609
00:36:08,510 --> 00:36:10,550
the tests do a change that gets

610
00:36:10,550 --> 00:36:16,100
persisted and then the next tests are

611
00:36:16,100 --> 00:36:18,440
affected by it and now you're in

612
00:36:18,440 --> 00:36:20,570
situation where the order in which the

613
00:36:20,570 --> 00:36:23,930
test run is actually important so that

614
00:36:23,930 --> 00:36:26,180
they don't fail and when they fail you

615
00:36:26,180 --> 00:36:29,810
have to start like binary you testing

616
00:36:29,810 --> 00:36:32,630
all your tests to find which one is

617
00:36:32,630 --> 00:36:35,780
causing the issue in your test face I've

618
00:36:35,780 --> 00:36:36,829
had to do that

619
00:36:36,829 --> 00:36:43,190
in times it's really painful so I would

620
00:36:43,190 --> 00:36:48,170
advise against against using that the

621
00:36:48,170 --> 00:36:51,200
other issue is that although here it

622
00:36:51,200 --> 00:36:53,359
might seems like your code is dry

623
00:36:53,359 --> 00:36:55,099
because you are only creating the

624
00:36:55,099 --> 00:36:56,779
automobile at one place in the setup

625
00:36:56,779 --> 00:36:59,059
method and then it magically gets called

626
00:36:59,059 --> 00:37:02,029
everywhere if you have a few hundred

627
00:37:02,029 --> 00:37:05,329
tests and you just treat the test you

628
00:37:05,329 --> 00:37:07,880
just see object that you don't know

629
00:37:07,880 --> 00:37:10,009
where they come from that they get that

630
00:37:10,009 --> 00:37:11,930
get calls and then the natural version

631
00:37:11,930 --> 00:37:14,630
is made and it becomes that much more

632
00:37:14,630 --> 00:37:19,759
easy harder to reason about the test dry

633
00:37:19,759 --> 00:37:23,420
in so dry is a for those who don't know

634
00:37:23,420 --> 00:37:25,819
dry is a technique which means don't

635
00:37:25,819 --> 00:37:32,809
repeat yourself it tries to make sure

636
00:37:32,809 --> 00:37:34,849
that you refactor your tests in a way

637
00:37:34,849 --> 00:37:38,269
that you don't try twice the same piece

638
00:37:38,269 --> 00:37:39,859
of code in the same class for instance

639
00:37:39,859 --> 00:37:42,529
or at least that's the way a lot of

640
00:37:42,529 --> 00:37:45,529
people understand it that can be a whole

641
00:37:45,529 --> 00:37:48,049
other discussion but that's one of the

642
00:37:48,049 --> 00:37:49,900
reason people use the setup method

643
00:37:49,900 --> 00:37:52,400
because then they don't have to write

644
00:37:52,400 --> 00:37:53,900
new automobiles everywhere in their

645
00:37:53,900 --> 00:37:59,989
tests if you have that test in the

646
00:37:59,989 --> 00:38:01,640
middle of a file and you need to scroll

647
00:38:01,640 --> 00:38:03,829
at the top to find the setup method if

648
00:38:03,829 --> 00:38:05,660
it's at the top and not at the bottom or

649
00:38:05,660 --> 00:38:08,869
somewhere in the middle it's just a pain

650
00:38:08,869 --> 00:38:15,140
to understand how your tests behave so

651
00:38:15,140 --> 00:38:17,869
the next solution that I've also seen

652
00:38:17,869 --> 00:38:23,029
maybe I removed that example yeah

653
00:38:23,029 --> 00:38:26,109
extracting to a method to the extreme is

654
00:38:26,109 --> 00:38:32,599
also hurtful for your completion of the

655
00:38:32,599 --> 00:38:35,930
test because we've had client that ended

656
00:38:35,930 --> 00:38:38,329
up in situation where there are D all

657
00:38:38,329 --> 00:38:40,369
their unit tests basically looks like

658
00:38:40,369 --> 00:38:45,160
that initialize do and then assert again

659
00:38:45,160 --> 00:38:47,449
having that test or not having it is

660
00:38:47,449 --> 00:38:53,839
pretty much the same now the solution to

661
00:38:53,839 --> 00:38:57,199
that problem that you might maybe a know

662
00:38:57,199 --> 00:39:01,459
the Builder pattern who knows the who

663
00:39:01,459 --> 00:39:06,430
heard about the Builder pattern okay I

664
00:39:06,430 --> 00:39:08,959
don't know why I've never seen anyone

665
00:39:08,959 --> 00:39:12,559
use it in unit tests but it actually

666
00:39:12,559 --> 00:39:14,420
make the unit test that much more

667
00:39:14,420 --> 00:39:16,489
readable and you still get the benefit

668
00:39:16,489 --> 00:39:18,680
that if your code change you have to

669
00:39:18,680 --> 00:39:22,729
change it only in one place for those

670
00:39:22,729 --> 00:39:24,499
who don't know the Builder pattern is

671
00:39:24,499 --> 00:39:27,769
just an object that will create your

672
00:39:27,769 --> 00:39:31,880
object for you so here the automobile

673
00:39:31,880 --> 00:39:40,160
builder just has a build method that

674
00:39:40,160 --> 00:39:46,039
will return your zoom appeal on its own

675
00:39:46,039 --> 00:39:48,949
it might not seems very interesting but

676
00:39:48,949 --> 00:39:50,719
if you use that with a fluent interface

677
00:39:50,719 --> 00:39:53,359
so that you have methods everywhere in

678
00:39:53,359 --> 00:39:58,249
your builder to change how you can or

679
00:39:58,249 --> 00:40:00,229
change the parameter that you can build

680
00:40:00,229 --> 00:40:02,869
your automobile with then you end up

681
00:40:02,869 --> 00:40:05,390
with tests that are much more readable

682
00:40:05,390 --> 00:40:09,210
you actually have

683
00:40:09,210 --> 00:40:12,820
an arranged part of your test where you

684
00:40:12,820 --> 00:40:15,640
can limit yourself to only specify the

685
00:40:15,640 --> 00:40:19,470
stuff that are important for your test

686
00:40:19,470 --> 00:40:21,760
it's not done here but you could totally

687
00:40:21,760 --> 00:40:23,770
imagine that you have a create builder

688
00:40:23,770 --> 00:40:25,840
method but also a create builder with

689
00:40:25,840 --> 00:40:28,420
default values that I don't care about

690
00:40:28,420 --> 00:40:32,070
and then on top of that you just change

691
00:40:32,070 --> 00:40:34,570
the part that is important for your

692
00:40:34,570 --> 00:40:42,400
current test the third part of the test

693
00:40:42,400 --> 00:40:45,240
[Music]

694
00:40:45,240 --> 00:40:48,540
again can anyone see a problem in the

695
00:40:48,540 --> 00:40:57,470
third part of that test yeah

696
00:41:01,529 --> 00:41:02,709
exactly

697
00:41:02,709 --> 00:41:05,650
so maybe you might have heard that that

698
00:41:05,650 --> 00:41:11,009
your test should only have one assertion

699
00:41:11,099 --> 00:41:14,559
it might be not always the case in the

700
00:41:14,559 --> 00:41:16,479
sense that there's some good reason to

701
00:41:16,479 --> 00:41:18,459
break that rules but there are no good

702
00:41:18,459 --> 00:41:22,299
reason to put an assertion in a 4h if

703
00:41:22,299 --> 00:41:24,309
you start putting logic like that in

704
00:41:24,309 --> 00:41:26,709
your code at some point you're just

705
00:41:26,709 --> 00:41:29,289
going to need to unit test your unit

706
00:41:29,289 --> 00:41:31,089
test to understand to make sure that

707
00:41:31,089 --> 00:41:33,549
they're actually doing what you think

708
00:41:33,549 --> 00:41:39,390
they are doing so as as a Bayes rule

709
00:41:39,390 --> 00:41:42,429
it's recommended to only assert one

710
00:41:42,429 --> 00:41:44,709
thing the other reason to only assert

711
00:41:44,709 --> 00:41:47,799
one thing is that all the unit testing

712
00:41:47,799 --> 00:41:50,140
framework true exception when the

713
00:41:50,140 --> 00:41:54,009
assertion fails which means that all the

714
00:41:54,009 --> 00:41:56,650
following ones won't you run and you

715
00:41:56,650 --> 00:42:00,909
won't get a complete picture of what's

716
00:42:00,909 --> 00:42:03,779
wrong in your code

717
00:42:08,579 --> 00:42:10,739
now one of the good reason that I've

718
00:42:10,739 --> 00:42:13,469
seen to actually have more than one

719
00:42:13,469 --> 00:42:18,029
assertion is for instance testing an

720
00:42:18,029 --> 00:42:23,219
exception if you need to test the code

721
00:42:23,219 --> 00:42:25,920
of the exception but also the message it

722
00:42:25,920 --> 00:42:29,429
makes sense to do that in one test but

723
00:42:29,429 --> 00:42:33,539
if you write it like that again if it

724
00:42:33,539 --> 00:42:36,479
fails at the error code exception code

725
00:42:36,479 --> 00:42:39,689
you don't know if the the message is

726
00:42:39,689 --> 00:42:41,849
still the right one or if the message is

727
00:42:41,849 --> 00:42:45,449
also in a weird state it's just an

728
00:42:45,449 --> 00:42:50,640
example there might be better but it get

729
00:42:50,640 --> 00:42:54,569
the job done to fix that issue there is

730
00:42:54,569 --> 00:42:57,630
the concept of assert all it also exists

731
00:42:57,630 --> 00:42:59,910
in pretty much any unit testing

732
00:42:59,910 --> 00:43:02,729
framework and it's just that idea that

733
00:43:02,729 --> 00:43:05,130
you can write yourself an assertion that

734
00:43:05,130 --> 00:43:07,739
you pass assertion to it and it's gonna

735
00:43:07,739 --> 00:43:10,319
run all of them even if one of them

736
00:43:10,319 --> 00:43:13,949
throw an exception and just read through

737
00:43:13,949 --> 00:43:17,039
the exception that were that we're

738
00:43:17,039 --> 00:43:19,170
thrown in the first place

739
00:43:19,170 --> 00:43:24,439
at the end of your list of assertion

740
00:43:25,969 --> 00:43:28,969
yeah

741
00:43:30,040 --> 00:43:35,050
for some reason I see also a lot of

742
00:43:35,050 --> 00:43:38,110
people that want to religiously stick

743
00:43:38,110 --> 00:43:40,450
with one assertion type in all their

744
00:43:40,450 --> 00:43:44,310
tests and they have a sir - everywhere

745
00:43:44,310 --> 00:43:49,960
although that completely works it makes

746
00:43:49,960 --> 00:43:52,990
the default error message completely

747
00:43:52,990 --> 00:43:57,340
useless when you end up in test suite

748
00:43:57,340 --> 00:44:00,490
that breaks a few hundred tests and the

749
00:44:00,490 --> 00:44:03,970
only thing that you can find out of

750
00:44:03,970 --> 00:44:05,980
those tests is a serve true but what's

751
00:44:05,980 --> 00:44:11,590
false yeah I mean if the tests were in

752
00:44:11,590 --> 00:44:13,990
there it was to me it's pretty much the

753
00:44:13,990 --> 00:44:19,900
same so picking the right assertion for

754
00:44:19,900 --> 00:44:21,570
the thing that you are trying to test

755
00:44:21,570 --> 00:44:24,910
means a better error message and that's

756
00:44:24,910 --> 00:44:28,060
what is going to help you fixing here in

757
00:44:28,060 --> 00:44:31,360
the first place we are only writing

758
00:44:31,360 --> 00:44:34,180
tests so that they fail so when they

759
00:44:34,180 --> 00:44:37,300
fail it would be nice if we could get

760
00:44:37,300 --> 00:44:39,970
really fast a good idea of what's the

761
00:44:39,970 --> 00:44:44,770
actual problem in the test and also

762
00:44:44,770 --> 00:44:47,230
people get the parameter order often

763
00:44:47,230 --> 00:44:54,640
wrong so supposedly most of the unit

764
00:44:54,640 --> 00:44:57,010
test run testing framework I've seen the

765
00:44:57,010 --> 00:44:59,260
first parameter is what you expect and

766
00:44:59,260 --> 00:45:02,740
then you pass the actual value that you

767
00:45:02,740 --> 00:45:05,860
are testing if you get that in the wrong

768
00:45:05,860 --> 00:45:08,410
order it's also going to make the error

769
00:45:08,410 --> 00:45:11,759
message really confusing

770
00:45:11,900 --> 00:45:15,070
[Music]

771
00:45:17,640 --> 00:45:23,170
now another way to have better assertion

772
00:45:23,170 --> 00:45:25,960
I've it's also something that I've not

773
00:45:25,960 --> 00:45:28,270
seen implemented in PHP but there is no

774
00:45:28,270 --> 00:45:30,820
reason why it couldn't be done and maybe

775
00:45:30,820 --> 00:45:33,550
it exists and I've just not find it it's

776
00:45:33,550 --> 00:45:37,089
a library that exists in c-sharp and

777
00:45:37,089 --> 00:45:41,950
Java and it's called sugar and what

778
00:45:41,950 --> 00:45:45,880
should we allows you it basically will

779
00:45:45,880 --> 00:45:48,250
change your assertion from the one

780
00:45:48,250 --> 00:45:50,560
that's on the top assert same red and

781
00:45:50,560 --> 00:45:54,150
then get color to something like color

782
00:45:54,150 --> 00:45:58,390
should be red when you read the test all

783
00:45:58,390 --> 00:45:59,140
the time

784
00:45:59,140 --> 00:46:01,750
that you don't spend doing that whole

785
00:46:01,750 --> 00:46:03,910
gymnastic in your head like oh the first

786
00:46:03,910 --> 00:46:06,790
parameter is what I should have and then

787
00:46:06,790 --> 00:46:09,250
the second one is what I'm testing it's

788
00:46:09,250 --> 00:46:11,920
a lot of time that you are not wasting

789
00:46:11,920 --> 00:46:14,710
by just having it's spelling spelled out

790
00:46:14,710 --> 00:46:16,990
directly in front of you it's pretty

791
00:46:16,990 --> 00:46:21,819
much English yeah to me it makes the

792
00:46:21,819 --> 00:46:25,930
code to test much more readable they

793
00:46:25,930 --> 00:46:31,900
also they also have a very interesting

794
00:46:31,900 --> 00:46:37,839
concept of equivalence where you can say

795
00:46:37,839 --> 00:46:39,460
that two objects should be equivalent

796
00:46:39,460 --> 00:46:41,859
but you can exclude some of the property

797
00:46:41,859 --> 00:46:45,010
of the object so here in the example you

798
00:46:45,010 --> 00:46:47,380
for instance use a UUID in the

799
00:46:47,380 --> 00:46:51,220
constructor of your object if you try to

800
00:46:51,220 --> 00:46:52,930
assert that those object are the same in

801
00:46:52,930 --> 00:46:55,869
your unit test unless you have a setter

802
00:46:55,869 --> 00:46:59,260
to set that ID - no it's just never it's

803
00:46:59,260 --> 00:47:00,880
just going to fail all the time on the

804
00:47:00,880 --> 00:47:08,200
UUID in that case

805
00:47:08,200 --> 00:47:10,910
it also made the test to me super

806
00:47:10,910 --> 00:47:14,510
readable it's very clear that the

807
00:47:14,510 --> 00:47:18,880
customer should be equivalent but the ID

808
00:47:19,270 --> 00:47:28,270
does anyone has any question yes

809
00:47:45,480 --> 00:47:48,570
so what is your question exactly how to

810
00:47:48,570 --> 00:47:50,250
write code that use dependency injection

811
00:47:50,250 --> 00:47:52,820
or

812
00:47:59,820 --> 00:48:03,420
yeah so your question is where is

813
00:48:03,420 --> 00:48:06,560
dependency injection or

814
00:48:14,970 --> 00:48:18,760
no I I should probably have asked the

815
00:48:18,760 --> 00:48:24,250
question but yeah who doesn't know

816
00:48:24,250 --> 00:48:29,560
whether than the C injection is okay

817
00:48:29,560 --> 00:48:35,880
maybe people are high but dirt

818
00:48:41,420 --> 00:48:45,109
no it's okay the idea of dependency

819
00:48:45,109 --> 00:48:48,890
injection is just that ID that instead

820
00:48:48,890 --> 00:48:52,520
of doing stuff like that where the UUID

821
00:48:52,520 --> 00:48:54,980
for instance is just created using a

822
00:48:54,980 --> 00:48:59,599
static method which make it impossible

823
00:48:59,599 --> 00:49:01,549
for the person that looks at your code

824
00:49:01,549 --> 00:49:04,280
to know that it's actually past

825
00:49:04,280 --> 00:49:10,910
dependency on a UUID library instead of

826
00:49:10,910 --> 00:49:13,040
doing that you make sure that everything

827
00:49:13,040 --> 00:49:15,200
that is used in your code is either way

828
00:49:15,200 --> 00:49:16,970
passed to the constructor if it's

829
00:49:16,970 --> 00:49:19,369
necessary at construct time or it's

830
00:49:19,369 --> 00:49:24,380
passed to the method that using in any

831
00:49:24,380 --> 00:49:28,930
case using dependency injection in my

832
00:49:28,930 --> 00:49:31,460
opinion is going to make the code more

833
00:49:31,460 --> 00:49:36,290
readable because just by looking at the

834
00:49:36,290 --> 00:49:38,390
constructor you directly know what is

835
00:49:38,390 --> 00:49:40,250
necessary for that class were actually

836
00:49:40,250 --> 00:49:44,059
doing its job but it's also going to be

837
00:49:44,059 --> 00:49:46,190
easier to test because in your test you

838
00:49:46,190 --> 00:49:48,640
can override all those dependencies

839
00:49:48,640 --> 00:49:51,500
easily whereas it's much harder if it's

840
00:49:51,500 --> 00:49:57,559
a static call or impossible any other

841
00:49:57,559 --> 00:50:01,690
question yeah

842
00:50:41,990 --> 00:50:44,760
to be fair it's just an example maybe

843
00:50:44,760 --> 00:50:52,350
it's not the best but to answer a part

844
00:50:52,350 --> 00:50:54,810
of your question that is about the fact

845
00:50:54,810 --> 00:50:57,300
that it's testing at the same time the

846
00:50:57,300 --> 00:51:01,260
paint method in the get method I would

847
00:51:01,260 --> 00:51:03,420
not expect a get method to have any

848
00:51:03,420 --> 00:51:09,000
logic in it so it would be weird that it

849
00:51:09,000 --> 00:51:10,740
fails it's totally something that could

850
00:51:10,740 --> 00:51:13,560
happen especially if it's good that you

851
00:51:13,560 --> 00:51:15,750
didn't try it yourself and code that's

852
00:51:15,750 --> 00:51:17,700
existing and that you are trying to unit

853
00:51:17,700 --> 00:51:21,620
test but there it's just an example you

854
00:51:21,620 --> 00:51:27,500
know it's maybe not the best yeah

855
00:51:58,260 --> 00:52:00,789
maybe I did not insisted on the port

856
00:52:00,789 --> 00:52:08,559
enough but mark is a fix for a code that

857
00:52:08,559 --> 00:52:11,440
is already problematic if you have to

858
00:52:11,440 --> 00:52:15,130
use marks too much and everywhere

859
00:52:15,130 --> 00:52:17,380
it basically means that your code is

860
00:52:17,380 --> 00:52:20,770
structured in a way that everything is

861
00:52:20,770 --> 00:52:23,829
dependent on everything and that makes

862
00:52:23,829 --> 00:52:26,500
it super hard to test that's exactly

863
00:52:26,500 --> 00:52:27,849
what's going to happen something is

864
00:52:27,849 --> 00:52:29,440
going to change somewhere and all the

865
00:52:29,440 --> 00:52:32,440
tests are going to break mark is only

866
00:52:32,440 --> 00:52:34,480
there because you have already existing

867
00:52:34,480 --> 00:52:36,940
code and you're trying to test a small

868
00:52:36,940 --> 00:52:41,380
part of it it cannot fix all your code

869
00:52:41,380 --> 00:52:43,799
at once

870
00:53:19,340 --> 00:53:24,570
yeah maybe I should use an example where

871
00:53:24,570 --> 00:53:26,220
it's actually useful but in the case

872
00:53:26,220 --> 00:53:29,010
that you are showing it could actually

873
00:53:29,010 --> 00:53:34,980
be a problem I have a hard time finding

874
00:53:34,980 --> 00:53:38,400
a good reason to use verify just like on

875
00:53:38,400 --> 00:53:44,160
the spot now but I've seen example where

876
00:53:44,160 --> 00:53:49,590
it was partly justified I just cannot

877
00:53:49,590 --> 00:53:51,030
find a good one

878
00:53:51,030 --> 00:53:56,790
just now we're all the time sorry

879
00:53:56,790 --> 00:53:58,650
thank you very much

880
00:53:58,650 --> 00:54:03,399
[Applause]

