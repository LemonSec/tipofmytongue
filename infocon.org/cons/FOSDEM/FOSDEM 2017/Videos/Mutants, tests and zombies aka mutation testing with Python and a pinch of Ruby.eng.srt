1
00:00:04,710 --> 00:00:09,240
hello everyone so my name is Alex I have

2
00:00:09,240 --> 00:00:11,129
been testing open source software for

3
00:00:11,129 --> 00:00:14,250
the last 10 years this is how to reach

4
00:00:14,250 --> 00:00:14,459
me

5
00:00:14,459 --> 00:00:17,550
if you if you like and this is how I

6
00:00:17,550 --> 00:00:18,029
look

7
00:00:18,029 --> 00:00:23,310
know pretty close so today I'm going to

8
00:00:23,310 --> 00:00:26,130
talk about mutants and zombies but not

9
00:00:26,130 --> 00:00:28,530
the ones from the movie that's slightly

10
00:00:28,530 --> 00:00:31,320
different and I have some code examples

11
00:00:31,320 --> 00:00:33,690
so first let me get up and get an idea

12
00:00:33,690 --> 00:00:35,850
how many of you are familiar with Python

13
00:00:35,850 --> 00:00:37,399
at least to some degree

14
00:00:37,399 --> 00:00:40,290
ok good and how many of you are familiar

15
00:00:40,290 --> 00:00:45,930
with Ruby ok great so don't worry the

16
00:00:45,930 --> 00:00:49,040
examples are not very hard to understand

17
00:00:49,040 --> 00:00:54,600
so let's take this piece of code it's a

18
00:00:54,600 --> 00:00:58,050
simple class describing one model in the

19
00:00:58,050 --> 00:00:59,700
rails application there's only one field

20
00:00:59,700 --> 00:01:02,520
that goes into the database and this is

21
00:01:02,520 --> 00:01:04,500
the only one method which is actually

22
00:01:04,500 --> 00:01:06,090
you know really stupid metal just

23
00:01:06,090 --> 00:01:08,100
returns an uppercase string of that

24
00:01:08,100 --> 00:01:11,040
field and as you can see from the

25
00:01:11,040 --> 00:01:14,729
screenshot this class has 100% code

26
00:01:14,729 --> 00:01:18,390
coverage and the question that I'm

27
00:01:18,390 --> 00:01:21,390
asking myself as a tester and the

28
00:01:21,390 --> 00:01:23,460
question that I expect everybody should

29
00:01:23,460 --> 00:01:25,860
be asking themselves here is is my test

30
00:01:25,860 --> 00:01:28,560
suite good enough and good enough in

31
00:01:28,560 --> 00:01:29,210
terms

32
00:01:29,210 --> 00:01:31,799
whenever there's some change in the

33
00:01:31,799 --> 00:01:34,409
software under test is my test suite

34
00:01:34,409 --> 00:01:37,140
able to detect if this change will break

35
00:01:37,140 --> 00:01:39,240
something or the change goes undetected

36
00:01:39,240 --> 00:01:41,159
that and possibly goes into production

37
00:01:41,159 --> 00:01:44,720
and something bad really happens and

38
00:01:44,720 --> 00:01:46,860
mutation testing can help you answer

39
00:01:46,860 --> 00:01:49,590
this question but first I need to

40
00:01:49,590 --> 00:01:53,700
explain what a mutation is so a mutation

41
00:01:53,700 --> 00:01:56,729
is usually a very small change in the

42
00:01:56,729 --> 00:01:59,579
software which somehow changes the

43
00:01:59,579 --> 00:02:02,630
behavior of the software mutations can

44
00:02:02,630 --> 00:02:05,250
can come from comparison operator

45
00:02:05,250 --> 00:02:07,770
and if statements and if we take the

46
00:02:07,770 --> 00:02:10,258
example on the screen it's the mutation

47
00:02:10,258 --> 00:02:12,239
is replacing the great done operator

48
00:02:12,239 --> 00:02:14,909
with a less than operator and if you

49
00:02:14,909 --> 00:02:16,590
apply this mutation to your code and

50
00:02:16,590 --> 00:02:18,480
read it it becomes if H is

51
00:02:18,480 --> 00:02:21,180
than 18 then buy beer now imagine that

52
00:02:21,180 --> 00:02:24,000
you are an online store and suddenly you

53
00:02:24,000 --> 00:02:25,890
know you start doing this so weird small

54
00:02:25,890 --> 00:02:28,489
children and this is not good

55
00:02:28,489 --> 00:02:31,440
then another possible source of

56
00:02:31,440 --> 00:02:34,709
mutations is constant values you can

57
00:02:34,709 --> 00:02:37,019
replace these values with something else

58
00:02:37,019 --> 00:02:40,200
and in this example we'll replace true

59
00:02:40,200 --> 00:02:42,810
to false and because it's very early in

60
00:02:42,810 --> 00:02:44,879
the morning yet if we didn't have our

61
00:02:44,879 --> 00:02:48,890
coffees we would be looking like this

62
00:02:48,890 --> 00:02:52,040
another possible source of mutations is

63
00:02:52,040 --> 00:02:56,790
loops we may for example modified loop

64
00:02:56,790 --> 00:02:59,069
condition or in this example we may

65
00:02:59,069 --> 00:03:02,040
change break to continue and we get an

66
00:03:02,040 --> 00:03:04,470
endless loop and when you have a Landis

67
00:03:04,470 --> 00:03:07,500
loop this is what happens so this is

68
00:03:07,500 --> 00:03:09,209
again an example from prediction in all

69
00:03:09,209 --> 00:03:10,769
my examples are taken from production

70
00:03:10,769 --> 00:03:16,910
environments today not the big one but

71
00:03:16,910 --> 00:03:20,549
by definition mutation testing is a

72
00:03:20,549 --> 00:03:23,220
technique and also the tools from the

73
00:03:23,220 --> 00:03:25,410
edge testing they modify your software

74
00:03:25,410 --> 00:03:26,099
under test

75
00:03:26,099 --> 00:03:28,440
they don't modify your test suite you

76
00:03:28,440 --> 00:03:30,419
know you keep the test bit separate and

77
00:03:30,419 --> 00:03:33,810
you for each mutant that is produced in

78
00:03:33,810 --> 00:03:35,849
your software under test you execute the

79
00:03:35,849 --> 00:03:37,349
test suite again and again and again and

80
00:03:37,349 --> 00:03:39,989
this gives you a pretty good idea at the

81
00:03:39,989 --> 00:03:43,829
end how good your test suite is what it

82
00:03:43,829 --> 00:03:46,109
can tell you places where you have tests

83
00:03:46,109 --> 00:03:49,019
but they don't go they don't do a very

84
00:03:49,019 --> 00:03:52,530
good job of finding you know all

85
00:03:52,530 --> 00:03:54,959
possible things that may change or they

86
00:03:54,959 --> 00:03:58,169
can also tell you places where you have

87
00:03:58,169 --> 00:04:00,239
missing tests but you already know this

88
00:04:00,239 --> 00:04:03,000
you know because you we use coverage so

89
00:04:03,000 --> 00:04:04,950
mutation testing is really good for

90
00:04:04,950 --> 00:04:07,829
telling you where you need to to make

91
00:04:07,829 --> 00:04:11,069
better tests and the idea behind this is

92
00:04:11,069 --> 00:04:13,769
some of the mutations which you see and

93
00:04:13,769 --> 00:04:19,639
which the to support try to try to mimic

94
00:04:19,639 --> 00:04:23,669
errors which developers may may do our

95
00:04:23,669 --> 00:04:25,860
writing code for example you know plus

96
00:04:25,860 --> 00:04:28,710
one minus one errors delete something by

97
00:04:28,710 --> 00:04:30,930
accident and you know just commit this

98
00:04:30,930 --> 00:04:32,650
to source control

99
00:04:32,650 --> 00:04:36,120
stuff like that and other mutations

100
00:04:36,120 --> 00:04:39,699
which you might see you know they are

101
00:04:39,699 --> 00:04:42,520
purely artificial but somehow they they

102
00:04:42,520 --> 00:04:45,520
help us validate the the test conditions

103
00:04:45,520 --> 00:04:47,710
the test environment which we run our

104
00:04:47,710 --> 00:04:50,740
tests within and you know help us expose

105
00:04:50,740 --> 00:04:54,400
something that's missing the algorithm

106
00:04:54,400 --> 00:04:56,169
for mutation testing is actually very

107
00:04:56,169 --> 00:05:03,040
simple so we we run three loops one

108
00:05:03,040 --> 00:05:04,030
after the other

109
00:05:04,030 --> 00:05:06,160
first once we go through the rotation

110
00:05:06,160 --> 00:05:08,650
operators that our two in particular can

111
00:05:08,650 --> 00:05:11,050
support these are stuff which the two

112
00:05:11,050 --> 00:05:12,880
knows how to change with something else

113
00:05:12,880 --> 00:05:15,400
and regardless whatever that that is

114
00:05:15,400 --> 00:05:19,620
maybe then for each operator we find the

115
00:05:19,620 --> 00:05:22,419
lysis in the source code where that

116
00:05:22,419 --> 00:05:24,610
operator is used and replace it with

117
00:05:24,610 --> 00:05:26,190
something else

118
00:05:26,190 --> 00:05:29,710
most mutation operators and collisions

119
00:05:29,710 --> 00:05:32,080
can lead to only one another type of

120
00:05:32,080 --> 00:05:34,539
mutation but some sometimes you can

121
00:05:34,539 --> 00:05:37,270
produce different mutations for only one

122
00:05:37,270 --> 00:05:38,860
place in the code like with the

123
00:05:38,860 --> 00:05:40,960
comparison operators and then of course

124
00:05:40,960 --> 00:05:44,350
you execute the test wait there are

125
00:05:44,350 --> 00:05:47,530
three simple rules to kill mutants now

126
00:05:47,530 --> 00:05:50,460
which you which you must remember first

127
00:05:50,460 --> 00:05:53,500
when you execute the DES twit against

128
00:05:53,500 --> 00:05:55,710
the non modified version of the program

129
00:05:55,710 --> 00:05:58,090
everything should pass and this is a

130
00:05:58,090 --> 00:06:00,190
hard requirement you cannot go without

131
00:06:00,190 --> 00:06:02,710
it if something fails obviously your

132
00:06:02,710 --> 00:06:04,660
software doesn't work or your test suite

133
00:06:04,660 --> 00:06:06,930
is broken and you need to take measures

134
00:06:06,930 --> 00:06:10,180
and if you have flaky tests and

135
00:06:10,180 --> 00:06:11,880
sometimes they pass sometimes they fail

136
00:06:11,880 --> 00:06:14,430
and you have no idea why this is

137
00:06:14,430 --> 00:06:16,720
obviously mutation your mutation results

138
00:06:16,720 --> 00:06:20,860
will also be unreliable and you need to

139
00:06:20,860 --> 00:06:22,840
take take measures to fix your flaky

140
00:06:22,840 --> 00:06:26,380
tests the second true is when you run

141
00:06:26,380 --> 00:06:28,720
the test suite against a mutant that is

142
00:06:28,720 --> 00:06:31,210
a modified version of your program you

143
00:06:31,210 --> 00:06:33,460
expect the result to be fail and that's

144
00:06:33,460 --> 00:06:35,550
a good thing when the test suite fails

145
00:06:35,550 --> 00:06:38,320
that we say that the mutant was cute or

146
00:06:38,320 --> 00:06:42,610
the mutant died and this means we had at

147
00:06:42,610 --> 00:06:45,680
least one assertion or one condition

148
00:06:45,680 --> 00:06:48,560
in the test suite which wasn't met and

149
00:06:48,560 --> 00:06:51,410
the desk we felt so that means at least

150
00:06:51,410 --> 00:06:54,080
we have one test which is able to detect

151
00:06:54,080 --> 00:06:56,389
this change and there was you know the

152
00:06:56,389 --> 00:06:58,880
software was modified and the last thing

153
00:06:58,880 --> 00:07:01,280
is which you don't want to happen when

154
00:07:01,280 --> 00:07:03,050
you run your test suite against the

155
00:07:03,050 --> 00:07:06,710
mutant and the result is pass this is a

156
00:07:06,710 --> 00:07:10,340
bad thing then we say we have a zombie

157
00:07:10,340 --> 00:07:13,610
or that the mutant survived and as you

158
00:07:13,610 --> 00:07:15,080
know from the movie zombies are dating

159
00:07:15,080 --> 00:07:16,789
that go around and try to eat you

160
00:07:16,789 --> 00:07:19,220
and now imagine you make some change in

161
00:07:19,220 --> 00:07:22,070
the code run the test suite it passes

162
00:07:22,070 --> 00:07:24,710
but it doesn't really understand there's

163
00:07:24,710 --> 00:07:27,050
anything change and now this change goes

164
00:07:27,050 --> 00:07:29,240
into production and suddenly this

165
00:07:29,240 --> 00:07:32,270
becomes a box and tries to eat you so

166
00:07:32,270 --> 00:07:35,060
these are the three rules testing

167
00:07:35,060 --> 00:07:37,099
against the non modified version should

168
00:07:37,099 --> 00:07:39,530
pass always testing against the mutant

169
00:07:39,530 --> 00:07:42,380
should fail this is the way a mutation

170
00:07:42,380 --> 00:07:45,979
test to figure out when you cure the

171
00:07:45,979 --> 00:07:47,449
mutant when something fails in the desc

172
00:07:47,449 --> 00:07:50,289
sweet the two says you kill the mutant

173
00:07:50,289 --> 00:07:54,740
okay now let's play a little game I am

174
00:07:54,740 --> 00:07:57,789
going to show you possible mutations and

175
00:07:57,789 --> 00:07:59,870
because you all know about testing

176
00:07:59,870 --> 00:08:01,880
you're going to tell me what test cases

177
00:08:01,880 --> 00:08:06,340
I need to write to kill the mutants I am

178
00:08:06,340 --> 00:08:09,740
using the code from earlier the one with

179
00:08:09,740 --> 00:08:12,199
the 100% coverage and only take this

180
00:08:12,199 --> 00:08:15,530
method see this is a string variable and

181
00:08:15,530 --> 00:08:17,750
we return the upper case of the string

182
00:08:17,750 --> 00:08:21,470
Corrado that's what what it does so very

183
00:08:21,470 --> 00:08:25,090
simple first possible mutation is

184
00:08:25,090 --> 00:08:27,380
instead of returning the upper case

185
00:08:27,380 --> 00:08:29,990
drink my method under test returns new

186
00:08:29,990 --> 00:08:34,789
value so what test can you propose so I

187
00:08:34,789 --> 00:08:37,330
can cure this

188
00:08:39,630 --> 00:08:43,269
yeah Bob yes so obviously not new yes

189
00:08:43,269 --> 00:08:44,049
correct

190
00:08:44,049 --> 00:08:47,440
so we we execute the method under test

191
00:08:47,440 --> 00:08:50,170
and expect the result to obviously not

192
00:08:50,170 --> 00:08:54,519
be new if we go back if we apply the

193
00:08:54,519 --> 00:08:58,089
mutation and run the test the method

194
00:08:58,089 --> 00:08:59,920
will return new and expectation will

195
00:08:59,920 --> 00:09:02,079
fail everything to fail and we kill the

196
00:09:02,079 --> 00:09:07,570
mutant ok next possible mutation instead

197
00:09:07,570 --> 00:09:09,670
of returning the upper case string

198
00:09:09,670 --> 00:09:13,029
I'm returning self because this way to

199
00:09:13,029 --> 00:09:15,100
this part of the class and I have access

200
00:09:15,100 --> 00:09:17,950
to the self object so I can do this what

201
00:09:17,950 --> 00:09:21,570
test do I need here to curious mutation

202
00:09:21,570 --> 00:09:25,930
ok type string correct so I must be

203
00:09:25,930 --> 00:09:29,019
checking what the type of the return

204
00:09:29,019 --> 00:09:31,240
value is and if I expect only string

205
00:09:31,240 --> 00:09:33,010
then it must be only string and nothing

206
00:09:33,010 --> 00:09:38,610
else another possible mutation is

207
00:09:38,610 --> 00:09:41,110
instead of returning the upper case I

208
00:09:41,110 --> 00:09:43,690
just return the the value of this

209
00:09:43,690 --> 00:09:52,540
variable as is so how do we cure this ok

210
00:09:52,540 --> 00:09:58,720
so I start with a value which is in a

211
00:09:58,720 --> 00:10:01,120
lower case and then I execute the method

212
00:10:01,120 --> 00:10:02,800
under test and expect this to be in a

213
00:10:02,800 --> 00:10:06,700
whopper case and I use this with just a

214
00:10:06,700 --> 00:10:15,720
constant because it's easier for me know

215
00:10:15,959 --> 00:10:19,570
so this one for example will cue the the

216
00:10:19,570 --> 00:10:25,630
first and the second zombies and here if

217
00:10:25,630 --> 00:10:29,339
yeah and here if I start with with new

218
00:10:29,339 --> 00:10:34,240
organic pink with the new mutation yeah

219
00:10:34,240 --> 00:10:38,500
it make you also the first one so some

220
00:10:38,500 --> 00:10:40,540
sometimes yeah one of the tests is

221
00:10:40,540 --> 00:10:42,430
enough to kill more mutants what

222
00:10:42,430 --> 00:10:44,620
actually this is the way I discovered

223
00:10:44,620 --> 00:10:46,630
them and I developed the test for them

224
00:10:46,630 --> 00:10:48,550
and actually didn't go back to think

225
00:10:48,550 --> 00:10:50,980
whether or not I have some tests which

226
00:10:50,980 --> 00:10:53,370
is not needed

227
00:10:53,370 --> 00:10:57,250
and okay so in the last example from the

228
00:10:57,250 --> 00:11:01,840
game is replacing the this ampersand

229
00:11:01,840 --> 00:11:03,760
this is the new the new safety

230
00:11:03,760 --> 00:11:07,270
navigation operator in Ruby and I just

231
00:11:07,270 --> 00:11:09,700
replace it with a dot so for the folks

232
00:11:09,700 --> 00:11:13,330
who don't work with Ruby the new safety

233
00:11:13,330 --> 00:11:15,490
operator works this way if the object on

234
00:11:15,490 --> 00:11:17,890
the left is new then the result of this

235
00:11:17,890 --> 00:11:20,440
operator is new and nothing else is

236
00:11:20,440 --> 00:11:22,570
executed and if the object on the left

237
00:11:22,570 --> 00:11:25,000
of the operator is not new the execution

238
00:11:25,000 --> 00:11:27,580
continues to the right and when we

239
00:11:27,580 --> 00:11:31,780
replace this with a dot then if the

240
00:11:31,780 --> 00:11:33,340
language code is new we just get a

241
00:11:33,340 --> 00:11:34,960
runtime exception because a new object

242
00:11:34,960 --> 00:11:37,120
doesn't have another I might call up

243
00:11:37,120 --> 00:11:43,390
case that that's the difference so we do

244
00:11:43,390 --> 00:11:46,660
this mutation and what what tests do I

245
00:11:46,660 --> 00:11:51,790
need to cure this should what should not

246
00:11:51,790 --> 00:11:58,780
row okay how do you ascertain that okay

247
00:11:58,780 --> 00:12:01,510
well at least I don't know how can I

248
00:12:01,510 --> 00:12:03,730
assert that there was no exception

249
00:12:03,730 --> 00:12:08,140
but I can set this were able to new

250
00:12:08,140 --> 00:12:10,060
execute the match under test and if

251
00:12:10,060 --> 00:12:12,220
there is an exception the test will fail

252
00:12:12,220 --> 00:12:14,440
anyway so I don't have to assert there

253
00:12:14,440 --> 00:12:16,990
wasn't an exception but I can assert

254
00:12:16,990 --> 00:12:20,290
that the result was new so if the

255
00:12:20,290 --> 00:12:22,060
framework asserts whether an exception

256
00:12:22,060 --> 00:12:24,010
was not raised then of course that's a

257
00:12:24,010 --> 00:12:26,500
valid answer but I don't know how to do

258
00:12:26,500 --> 00:12:31,530
this with Ruby sorry

259
00:12:34,050 --> 00:12:44,999
OOP okay it collides if you read if yeah

260
00:12:44,999 --> 00:12:48,239
it collides if you read the examples as

261
00:12:48,239 --> 00:12:50,389
this on the street on the on the slides

262
00:12:50,389 --> 00:12:52,949
what I haven't shown is that this

263
00:12:52,949 --> 00:12:57,230
variable has a non new value by default

264
00:12:57,230 --> 00:12:58,679
sorry duh

265
00:12:58,679 --> 00:13:03,779
so that works then but yeah good good

266
00:13:03,779 --> 00:13:08,670
catch now let's try and find some bugs

267
00:13:08,670 --> 00:13:12,269
with mutation testing one book that I

268
00:13:12,269 --> 00:13:15,059
was able to discover just by using

269
00:13:15,059 --> 00:13:16,889
mutation testing in a project not

270
00:13:16,889 --> 00:13:18,809
actively looking for the burkas is this

271
00:13:18,809 --> 00:13:21,239
so we have a class called network which

272
00:13:21,239 --> 00:13:23,910
represents the networking settings on

273
00:13:23,910 --> 00:13:26,999
your Linux computer and there's an

274
00:13:26,999 --> 00:13:28,499
attribute called cell device which is

275
00:13:28,499 --> 00:13:31,639
the name of the network interface and

276
00:13:31,639 --> 00:13:34,920
this method for equality is obviously

277
00:13:34,920 --> 00:13:37,709
wrong you know as highlighted here and

278
00:13:37,709 --> 00:13:40,860
we see why so if cell device is not on

279
00:13:40,860 --> 00:13:43,049
an empty string that piece of the

280
00:13:43,049 --> 00:13:44,639
boolean expression is always evaluated

281
00:13:44,639 --> 00:13:47,970
to false and the entire return value is

282
00:13:47,970 --> 00:13:50,369
always false so it doesn't matter what

283
00:13:50,369 --> 00:13:52,499
you know what's the other object you're

284
00:13:52,499 --> 00:13:54,209
comparing to this method always returns

285
00:13:54,209 --> 00:13:58,110
false and if so device isn't known or

286
00:13:58,110 --> 00:14:00,119
it's not an empty string then which

287
00:14:00,119 --> 00:14:02,220
means it has some meaningful value in

288
00:14:02,220 --> 00:14:05,490
the software this is evaluated to true

289
00:14:05,490 --> 00:14:08,160
and the boolean expression always

290
00:14:08,160 --> 00:14:11,009
depends on the second part so and that's

291
00:14:11,009 --> 00:14:13,139
actually the fix just you know just just

292
00:14:13,139 --> 00:14:14,639
remove this first part of the boolean

293
00:14:14,639 --> 00:14:16,559
expression and and here we go

294
00:14:16,559 --> 00:14:19,559
the reason this stayed undetected for I

295
00:14:19,559 --> 00:14:21,799
guess about seven or eight years is

296
00:14:21,799 --> 00:14:24,509
there was there wasn't a single test in

297
00:14:24,509 --> 00:14:28,139
the test suite which tried to test this

298
00:14:28,139 --> 00:14:30,329
equality method when some of the

299
00:14:30,329 --> 00:14:31,799
attribute was an empty string core was

300
00:14:31,799 --> 00:14:34,649
none so they were always testing with

301
00:14:34,649 --> 00:14:37,139
some valid values and this went on

302
00:14:37,139 --> 00:14:39,529
undetected for many many years

303
00:14:39,529 --> 00:14:43,230
and also in the software under test when

304
00:14:43,230 --> 00:14:44,999
you see normal conditions this value is

305
00:14:44,999 --> 00:14:47,790
always it always has some value

306
00:14:47,790 --> 00:14:51,660
so it doesn't you know return a force or

307
00:14:51,660 --> 00:14:54,810
you know something bad happens another

308
00:14:54,810 --> 00:14:58,080
book which I was able to find his s

309
00:14:58,080 --> 00:15:01,110
shown I have two classes the second

310
00:15:01,110 --> 00:15:03,180
class inherits from the first one and

311
00:15:03,180 --> 00:15:06,270
you see both classes have a parameter

312
00:15:06,270 --> 00:15:07,980
called speed limit in the init method

313
00:15:07,980 --> 00:15:10,410
and both parameters have default values

314
00:15:10,410 --> 00:15:13,070
now this is perfectly valid Python code

315
00:15:13,070 --> 00:15:16,650
so there's nothing wrong with the way

316
00:15:16,650 --> 00:15:17,250
it's written

317
00:15:17,250 --> 00:15:21,390
I run the destroy mutation testing and I

318
00:15:21,390 --> 00:15:23,760
get a surviving mutant the reason here

319
00:15:23,760 --> 00:15:26,010
is this is a constant change the tool

320
00:15:26,010 --> 00:15:28,260
for Python adds a plus one to any

321
00:15:28,260 --> 00:15:31,530
integer constant and to see what happens

322
00:15:31,530 --> 00:15:33,750
and I immediately know the reason for

323
00:15:33,750 --> 00:15:35,310
this is that I don't have any test which

324
00:15:35,310 --> 00:15:37,230
creates an object from this class and

325
00:15:37,230 --> 00:15:39,930
asserts what the default value of this

326
00:15:39,930 --> 00:15:42,630
attribute should be so I create my test

327
00:15:42,630 --> 00:15:45,210
like this just you know create an object

328
00:15:45,210 --> 00:15:46,950
from the class under test and assert

329
00:15:46,950 --> 00:15:49,650
what the default value should be and the

330
00:15:49,650 --> 00:15:52,380
test immediately fails of course and the

331
00:15:52,380 --> 00:15:55,010
reason for this is if you look closely

332
00:15:55,010 --> 00:15:59,700
you see that this parameter I'm not

333
00:15:59,700 --> 00:16:01,560
sending that to the init method of the

334
00:16:01,560 --> 00:16:04,530
parent class so it must go here after

335
00:16:04,530 --> 00:16:08,220
self and when I'm not doing this the

336
00:16:08,220 --> 00:16:11,250
parent class casts its default value so

337
00:16:11,250 --> 00:16:13,470
it uses 50 instead of 90 and that's why

338
00:16:13,470 --> 00:16:16,140
I did my test first and this is also

339
00:16:16,140 --> 00:16:19,140
very subtle it state undetected for many

340
00:16:19,140 --> 00:16:22,530
many years and also the reason for not

341
00:16:22,530 --> 00:16:25,140
being detected is the attribute this

342
00:16:25,140 --> 00:16:27,870
value is assigned to is never used in

343
00:16:27,870 --> 00:16:30,030
the software under test it was meant to

344
00:16:30,030 --> 00:16:33,210
be used by external clients of the

345
00:16:33,210 --> 00:16:35,520
software the software under test in this

346
00:16:35,520 --> 00:16:37,320
case is a library so it's used by other

347
00:16:37,320 --> 00:16:40,350
tools and apparently you know nobody

348
00:16:40,350 --> 00:16:42,630
bother to check whether or not the

349
00:16:42,630 --> 00:16:46,470
default value is it should be another

350
00:16:46,470 --> 00:16:48,570
possible book very close to the previous

351
00:16:48,570 --> 00:16:52,380
one is again I have two classes the

352
00:16:52,380 --> 00:16:53,880
second course inherits from the first

353
00:16:53,880 --> 00:16:57,090
one again I have a parameter with the

354
00:16:57,090 --> 00:17:00,240
default value and this time notice I am

355
00:17:00,240 --> 00:17:01,060
actually

356
00:17:01,060 --> 00:17:03,430
sending this to the init method of the

357
00:17:03,430 --> 00:17:05,500
parent class and everything must be fine

358
00:17:05,500 --> 00:17:09,190
I run this through my mutation testing -

359
00:17:09,190 --> 00:17:12,010
I get the same surviving mutant so again

360
00:17:12,010 --> 00:17:14,890
I write the same type of tests created

361
00:17:14,890 --> 00:17:17,410
an object and assert what the default

362
00:17:17,410 --> 00:17:20,800
values of the attribute should be and

363
00:17:20,800 --> 00:17:22,510
again this time I get another type of

364
00:17:22,510 --> 00:17:24,520
exception it's an attribute error

365
00:17:24,520 --> 00:17:27,099
telling me object from the more awake

366
00:17:27,099 --> 00:17:28,600
class and does not have an attribute

367
00:17:28,600 --> 00:17:31,060
called speed limit and at this point I

368
00:17:31,060 --> 00:17:33,610
start wondering why this is so you know

369
00:17:33,610 --> 00:17:37,360
I look here everything looks cool I look

370
00:17:37,360 --> 00:17:40,600
here everything looks ok and I Traverse

371
00:17:40,600 --> 00:17:43,780
back to the parent class and immediately

372
00:17:43,780 --> 00:17:46,600
here I notice first there's no parameter

373
00:17:46,600 --> 00:17:48,700
called speed limit and then something

374
00:17:48,700 --> 00:17:50,680
starts no - look not right

375
00:17:50,680 --> 00:17:52,540
and then I look in the body of the

376
00:17:52,540 --> 00:17:56,380
parent init method and nobody cares

377
00:17:56,380 --> 00:17:58,180
about whether or not there's a parameter

378
00:17:58,180 --> 00:18:00,070
called speed limit nobody sets an

379
00:18:00,070 --> 00:18:04,300
attribute called speed limit so that's

380
00:18:04,300 --> 00:18:06,900
the problem you know I don't have this

381
00:18:06,900 --> 00:18:09,940
one possible fixes - if you really need

382
00:18:09,940 --> 00:18:11,980
this to just take care of it in the

383
00:18:11,980 --> 00:18:14,410
class under test and set the attribute

384
00:18:14,410 --> 00:18:16,900
or another possible fixes to delete

385
00:18:16,900 --> 00:18:19,030
everything related to this parameter I

386
00:18:19,030 --> 00:18:20,770
don't bother with it and that was

387
00:18:20,770 --> 00:18:26,230
actually the fix in production another

388
00:18:26,230 --> 00:18:27,820
thing which sure mutation testing is

389
00:18:27,820 --> 00:18:31,780
really good at is forcing you to look at

390
00:18:31,780 --> 00:18:36,150
your source code and refactor it and

391
00:18:36,150 --> 00:18:38,620
places where mutation testing really

392
00:18:38,620 --> 00:18:41,670
changes where you have if statements and

393
00:18:41,670 --> 00:18:44,650
comparisons and lots of boolean

394
00:18:44,650 --> 00:18:46,930
expression stuff like that the reason

395
00:18:46,930 --> 00:18:50,230
for this is we have many mutations in

396
00:18:50,230 --> 00:18:55,750
places like this so in this example on

397
00:18:55,750 --> 00:18:58,750
the screen we have around 1 100

398
00:18:58,750 --> 00:19:01,630
different mutations every comparison

399
00:19:01,630 --> 00:19:05,590
operator can lead to almost 10 different

400
00:19:05,590 --> 00:19:08,530
mutations so equals here can be replaced

401
00:19:08,530 --> 00:19:11,740
with non equals with less than or great

402
00:19:11,740 --> 00:19:13,620
down less than equals great

403
00:19:13,620 --> 00:19:17,250
equals in Python isn't is not and also

404
00:19:17,250 --> 00:19:19,610
in internal teen operators so that many

405
00:19:19,610 --> 00:19:22,590
boolean n can be replaced with boolean

406
00:19:22,590 --> 00:19:24,630
or we can negate the entire boolean

407
00:19:24,630 --> 00:19:29,220
expressions also in the two for Ruby you

408
00:19:29,220 --> 00:19:31,050
can replace the balloon expression with

409
00:19:31,050 --> 00:19:32,820
the true or false constant and I think

410
00:19:32,820 --> 00:19:35,370
also you can change only parts of it so

411
00:19:35,370 --> 00:19:37,110
you can replace this with true or false

412
00:19:37,110 --> 00:19:39,420
and then leave the rest of this and the

413
00:19:39,420 --> 00:19:41,490
Python to doesn't do this at the moment

414
00:19:41,490 --> 00:19:45,929
but it's fairly easy to what and so this

415
00:19:45,929 --> 00:19:48,360
goes through mutation testing any

416
00:19:48,360 --> 00:19:50,880
something you know you know there are

417
00:19:50,880 --> 00:19:54,120
surviving mutants and when you start

418
00:19:54,120 --> 00:19:56,340
looking at it you you notice the pattern

419
00:19:56,340 --> 00:19:59,010
highlighted in red so my thought is I

420
00:19:59,010 --> 00:20:01,350
can I can delete this and move the

421
00:20:01,350 --> 00:20:04,230
second block block of if statements to

422
00:20:04,230 --> 00:20:05,670
the right and it becomes a little bit

423
00:20:05,670 --> 00:20:07,950
more clear and then I notice another

424
00:20:07,950 --> 00:20:11,130
pattern that whatever value is I'm

425
00:20:11,130 --> 00:20:12,870
looking for an attribute under self

426
00:20:12,870 --> 00:20:15,240
handle with the same name and do

427
00:20:15,240 --> 00:20:17,610
something with it so I can refine this

428
00:20:17,610 --> 00:20:20,160
even further and use the get attribute

429
00:20:20,160 --> 00:20:23,880
function and this becomes like this in

430
00:20:23,880 --> 00:20:25,440
reality this fits only on four lines

431
00:20:25,440 --> 00:20:27,870
instead of ten lines and it's much more

432
00:20:27,870 --> 00:20:29,490
easier to test and much more

433
00:20:29,490 --> 00:20:31,530
you know easier to read actually and

434
00:20:31,530 --> 00:20:34,129
that's a good thing

435
00:20:34,940 --> 00:20:38,130
so we've seen you know what mutation

436
00:20:38,130 --> 00:20:40,890
testing can do it forces you to write

437
00:20:40,890 --> 00:20:44,190
better asserts and in my opinion when

438
00:20:44,190 --> 00:20:47,150
you have a complex software under test

439
00:20:47,150 --> 00:20:50,790
we not only should assert what the

440
00:20:50,790 --> 00:20:53,610
return values of our methods are but we

441
00:20:53,610 --> 00:20:55,950
also should assert what intermediate

442
00:20:55,950 --> 00:20:58,290
state or side effects are produced by

443
00:20:58,290 --> 00:21:00,570
the functions under test and you will

444
00:21:00,570 --> 00:21:03,420
all agree that it doesn't matter how

445
00:21:03,420 --> 00:21:05,910
much we try to write clean software we

446
00:21:05,910 --> 00:21:08,460
always have these methods which do more

447
00:21:08,460 --> 00:21:10,950
than one thing at a time so they they do

448
00:21:10,950 --> 00:21:12,690
something some calculations return some

449
00:21:12,690 --> 00:21:14,370
value and oh by the way I've just said

450
00:21:14,370 --> 00:21:16,080
this attribute on the side just so you

451
00:21:16,080 --> 00:21:18,990
know and that's what mutation testing is

452
00:21:18,990 --> 00:21:20,760
really helpful with it helps you

453
00:21:20,760 --> 00:21:22,679
discover these things which which you

454
00:21:22,679 --> 00:21:25,170
are not testing by mutating them so you

455
00:21:25,170 --> 00:21:27,060
can write your test better

456
00:21:27,060 --> 00:21:29,640
we saw we can find some interesting

457
00:21:29,640 --> 00:21:33,270
books and we saw that we can find places

458
00:21:33,270 --> 00:21:36,060
which we can refactor and the questions

459
00:21:36,060 --> 00:21:37,950
to stands is my test with good enough

460
00:21:37,950 --> 00:21:40,740
and another question another side of

461
00:21:40,740 --> 00:21:42,960
this question is how do I measure how

462
00:21:42,960 --> 00:21:45,840
good my test suite is which metric do I

463
00:21:45,840 --> 00:21:48,450
use to tell whether or not my test suite

464
00:21:48,450 --> 00:21:52,920
is good and no matrix is fairly

465
00:21:52,920 --> 00:21:55,050
controversial topic I just want to

466
00:21:55,050 --> 00:21:57,540
mention some research that's been going

467
00:21:57,540 --> 00:22:01,290
on in the last few years in 2015 at G

468
00:22:01,290 --> 00:22:03,270
tach there was one lighting talk which

469
00:22:03,270 --> 00:22:04,950
says you know coverage is not a good

470
00:22:04,950 --> 00:22:07,830
metric because it doesn't give you a lot

471
00:22:07,830 --> 00:22:10,340
of information so go for mutation score

472
00:22:10,340 --> 00:22:12,540
you know use mutation testing and

473
00:22:12,540 --> 00:22:14,280
measured how much of the mutants are

474
00:22:14,280 --> 00:22:16,710
cute if you kill 100% the mutants then

475
00:22:16,710 --> 00:22:20,220
then you're good and then last year at

476
00:22:20,220 --> 00:22:22,050
the g'tok there was another researcher

477
00:22:22,050 --> 00:22:23,580
who basically said well you know the

478
00:22:23,580 --> 00:22:25,830
guys from last year they didn't do

479
00:22:25,830 --> 00:22:27,210
really good research they didn't

480
00:22:27,210 --> 00:22:30,480
research from all many software so we

481
00:22:30,480 --> 00:22:32,460
did better research and we claimed that

482
00:22:32,460 --> 00:22:34,800
the coverage metric like line coverage

483
00:22:34,800 --> 00:22:36,150
and branch coverage is still the best

484
00:22:36,150 --> 00:22:40,200
metric in practice they say the problem

485
00:22:40,200 --> 00:22:42,060
with mutation testing is it is very

486
00:22:42,060 --> 00:22:44,820
expensive to compute and in their

487
00:22:44,820 --> 00:22:48,150
research it gave only additional 4% of

488
00:22:48,150 --> 00:22:50,730
information which the guys did not know

489
00:22:50,730 --> 00:22:53,340
already compared to coverage so they say

490
00:22:53,340 --> 00:22:55,200
you know use coverage don't use mutation

491
00:22:55,200 --> 00:22:58,950
testing and I decided to do a small

492
00:22:58,950 --> 00:23:01,710
experiment and see which one of these

493
00:23:01,710 --> 00:23:07,560
researchers is right so my software

494
00:23:07,560 --> 00:23:10,080
under test is called Pelican a/b and

495
00:23:10,080 --> 00:23:12,960
this is a very small library it's a

496
00:23:12,960 --> 00:23:16,080
plug-in for Pelican Pelican is a static

497
00:23:16,080 --> 00:23:18,900
HTML generator for Python which you can

498
00:23:18,900 --> 00:23:21,510
use to to run your block or your site on

499
00:23:21,510 --> 00:23:25,290
and a pelican IB gives you one

500
00:23:25,290 --> 00:23:28,320
additional tack for the templating

501
00:23:28,320 --> 00:23:31,100
markup which you can use to encode

502
00:23:31,100 --> 00:23:34,320
variety of for your website so for

503
00:23:34,320 --> 00:23:36,000
example you can change the cover of

504
00:23:36,000 --> 00:23:37,860
links or colors of buttons stuff like

505
00:23:37,860 --> 00:23:41,339
that the way to use this software is

506
00:23:41,339 --> 00:23:44,889
to define the a/b experiment variable in

507
00:23:44,889 --> 00:23:46,919
the shell and run D my command

508
00:23:46,919 --> 00:23:49,959
if you run make github then the site

509
00:23:49,959 --> 00:23:51,369
gets rendered everything's publish

510
00:23:51,369 --> 00:23:54,639
directly to github the way to render

511
00:23:54,639 --> 00:23:56,709
several versions of your website is for

512
00:23:56,709 --> 00:23:59,440
start with the control version and then

513
00:23:59,440 --> 00:24:03,699
name each experiment by name and run

514
00:24:03,699 --> 00:24:06,129
make in a sequence like shown on the

515
00:24:06,129 --> 00:24:08,469
screen and if you do this the three

516
00:24:08,469 --> 00:24:10,209
commands then you get the control

517
00:24:10,209 --> 00:24:12,099
version of your website on experiment

518
00:24:12,099 --> 00:24:13,209
which is called one two three and

519
00:24:13,209 --> 00:24:14,919
everything about this experiment goes

520
00:24:14,919 --> 00:24:17,409
into a directory with the same name the

521
00:24:17,409 --> 00:24:19,989
URL structure is updated and you know

522
00:24:19,989 --> 00:24:22,509
you can point your users to only to that

523
00:24:22,509 --> 00:24:24,339
experiment and see how they they respond

524
00:24:24,339 --> 00:24:27,309
and stuff like that and in the version

525
00:24:27,309 --> 00:24:30,940
under test we have 100% branch and live

526
00:24:30,940 --> 00:24:33,579
coverage of this software and we also

527
00:24:33,579 --> 00:24:36,129
have a book there is a setting called

528
00:24:36,129 --> 00:24:39,039
elite output directory which is set to

529
00:24:39,039 --> 00:24:41,199
true by default and this setting isn't

530
00:24:41,199 --> 00:24:42,369
something the software under test

531
00:24:42,369 --> 00:24:45,699
controls and this lifts into an external

532
00:24:45,699 --> 00:24:47,859
file were no your website configuration

533
00:24:47,859 --> 00:24:51,429
goes so like stuff like your website

534
00:24:51,429 --> 00:24:53,889
name your github handle goes into that

535
00:24:53,889 --> 00:24:56,979
file as well the bug is when that

536
00:24:56,979 --> 00:24:59,739
setting is set to true a pelican will go

537
00:24:59,739 --> 00:25:02,169
and delete the output directory and

538
00:25:02,169 --> 00:25:03,999
delete all the HTML files and then

539
00:25:03,999 --> 00:25:05,319
starts rendering them in a clean

540
00:25:05,319 --> 00:25:07,989
directory so the result of this command

541
00:25:07,989 --> 00:25:10,839
sequence with the setting set to true is

542
00:25:10,839 --> 00:25:12,940
that you have deleted your entire

543
00:25:12,940 --> 00:25:15,249
website and only left with the last one

544
00:25:15,249 --> 00:25:18,309
and imaginal you know you delete

545
00:25:18,309 --> 00:25:19,869
everything and type make it happen

546
00:25:19,869 --> 00:25:22,029
everything goes live so that's a pretty

547
00:25:22,029 --> 00:25:27,429
good way to destroy your website so you

548
00:25:27,429 --> 00:25:29,919
know I I didn't have a test which will

549
00:25:29,919 --> 00:25:32,949
fail if the setting is set to true so I

550
00:25:32,949 --> 00:25:34,719
decided to integrate mutation testing

551
00:25:34,719 --> 00:25:37,839
into the project and I wrote a few more

552
00:25:37,839 --> 00:25:40,809
tests to achieve 100% mutation coverage

553
00:25:40,809 --> 00:25:42,339
you know mind you this is very small

554
00:25:42,339 --> 00:25:44,649
library very small plugin and the book

555
00:25:44,649 --> 00:25:47,319
was still present so this means I don't

556
00:25:47,319 --> 00:25:49,509
have any test which fails when the

557
00:25:49,509 --> 00:25:52,899
setting is set through and I starting

558
00:25:52,899 --> 00:25:54,310
okay why why I have

559
00:25:54,310 --> 00:25:56,530
these many tests and this book is to

560
00:25:56,530 --> 00:26:00,250
present and the answer is you know you

561
00:26:00,250 --> 00:26:02,520
cannot discover this type of book

562
00:26:02,520 --> 00:26:05,050
without looking at the external

563
00:26:05,050 --> 00:26:06,520
environment and that's why we need

564
00:26:06,520 --> 00:26:09,490
integration tests so I added an

565
00:26:09,490 --> 00:26:11,650
integration test which simulates the

566
00:26:11,650 --> 00:26:13,180
external environment with the settings

567
00:26:13,180 --> 00:26:15,610
and simulates the make command then

568
00:26:15,610 --> 00:26:18,100
tries to verify what content has been

569
00:26:18,100 --> 00:26:20,410
rendered and whether or not it's correct

570
00:26:20,410 --> 00:26:25,150
and that immediately felt of course so

571
00:26:25,150 --> 00:26:27,970
then I said I fixed the book but in

572
00:26:27,970 --> 00:26:29,980
reality just you know change this

573
00:26:29,980 --> 00:26:33,850
setting to force and also add it to

574
00:26:33,850 --> 00:26:35,530
check whether or not this is set to true

575
00:26:35,530 --> 00:26:38,010
just raise an exception in my software

576
00:26:38,010 --> 00:26:41,350
and now we we have 100% mutation

577
00:26:41,350 --> 00:26:44,470
coverage 100% branch coverage and also

578
00:26:44,470 --> 00:26:46,060
we have been at least one integration

579
00:26:46,060 --> 00:26:49,300
test and I'm thinking okay I must be

580
00:26:49,300 --> 00:26:52,750
good then you know if I have so many

581
00:26:52,750 --> 00:26:54,130
tests and I'm using these techniques

582
00:26:54,130 --> 00:26:56,740
then possibly my software is bug free

583
00:26:56,740 --> 00:26:59,230
and of course this is not true I've

584
00:26:59,230 --> 00:27:03,160
added pilant to the project and pilant

585
00:27:03,160 --> 00:27:05,740
was immediately able to discover this

586
00:27:05,740 --> 00:27:09,990
book this is this is a problem with how

587
00:27:09,990 --> 00:27:12,940
we call the super method instead of

588
00:27:12,940 --> 00:27:16,480
passing the class name I was using a

589
00:27:16,480 --> 00:27:18,700
shortcut which is serve dot underscore

590
00:27:18,700 --> 00:27:22,090
class and this works perfectly fine when

591
00:27:22,090 --> 00:27:24,880
you use the software in its intended

592
00:27:24,880 --> 00:27:27,220
environment because we have only one

593
00:27:27,220 --> 00:27:29,140
class and self class is evaluated to

594
00:27:29,140 --> 00:27:31,180
that particular classes name and

595
00:27:31,180 --> 00:27:35,520
everything's fine this becomes a problem

596
00:27:35,520 --> 00:27:38,440
the moment you try to inherit from the

597
00:27:38,440 --> 00:27:40,600
class under test and create a new class

598
00:27:40,600 --> 00:27:43,360
and do something different with it and

599
00:27:43,360 --> 00:27:45,370
then when you call the class under test

600
00:27:45,370 --> 00:27:48,340
init method button goes into a loop

601
00:27:48,340 --> 00:27:52,630
between the deeper intent and inherited

602
00:27:52,630 --> 00:27:55,360
class init methods so if you want to you

603
00:27:55,360 --> 00:27:57,250
know if you want to learn more just head

604
00:27:57,250 --> 00:27:58,930
on to this soup I'll input request

605
00:27:58,930 --> 00:28:01,240
number and there's a very detailed

606
00:28:01,240 --> 00:28:04,200
description why this is a problem and I

607
00:28:04,200 --> 00:28:07,600
am guilty of using this

608
00:28:07,600 --> 00:28:10,750
this shortcut in Python but I've seen

609
00:28:10,750 --> 00:28:12,880
this in many many projects online at

610
00:28:12,880 --> 00:28:15,789
github and I've seen this in popular

611
00:28:15,789 --> 00:28:18,160
software which is used by many people so

612
00:28:18,160 --> 00:28:20,530
this tells me people don't have very

613
00:28:20,530 --> 00:28:22,630
good understanding of what self class

614
00:28:22,630 --> 00:28:24,640
actually means and how it works

615
00:28:24,640 --> 00:28:27,580
and that's why you know we keep using it

616
00:28:27,580 --> 00:28:33,460
in in the wrong way so to conclude the

617
00:28:33,460 --> 00:28:36,669
mutation versus coverage topic this is a

618
00:28:36,669 --> 00:28:39,070
link to my blog describing my experiment

619
00:28:39,070 --> 00:28:41,740
with more details and there are links to

620
00:28:41,740 --> 00:28:43,900
actual git commits so you can see what

621
00:28:43,900 --> 00:28:46,090
actually what code was changed and how

622
00:28:46,090 --> 00:28:49,299
it was change so I think when we first

623
00:28:49,299 --> 00:28:53,309
start doing testing what we look at is

624
00:28:53,309 --> 00:28:56,710
how much coverage we can do so we strive

625
00:28:56,710 --> 00:28:58,480
to write more tests to test as much as

626
00:28:58,480 --> 00:29:00,850
possible of the software under test and

627
00:29:00,850 --> 00:29:04,780
that's a good thing until some time when

628
00:29:04,780 --> 00:29:09,400
we go to 100% coverage we don't get any

629
00:29:09,400 --> 00:29:11,799
more information out of this matrix so

630
00:29:11,799 --> 00:29:15,309
it doesn't do me any good then we start

631
00:29:15,309 --> 00:29:17,260
looking at mutation testing and mutation

632
00:29:17,260 --> 00:29:19,120
testing tells us okay now you have some

633
00:29:19,120 --> 00:29:20,950
coverage and you're testing some stuff

634
00:29:20,950 --> 00:29:23,799
but then you know there's a lot more you

635
00:29:23,799 --> 00:29:25,780
can test and this is you know what you

636
00:29:25,780 --> 00:29:28,090
need to do and we start doing mutation

637
00:29:28,090 --> 00:29:30,220
testing and we get to 100% mutation

638
00:29:30,220 --> 00:29:33,280
coverage and when we get to 100% we

639
00:29:33,280 --> 00:29:34,600
don't get any more useful information

640
00:29:34,600 --> 00:29:38,260
out of that and we also need integration

641
00:29:38,260 --> 00:29:39,970
tests because of the external

642
00:29:39,970 --> 00:29:42,909
environment and as you see from the

643
00:29:42,909 --> 00:29:45,390
examples we have different types of

644
00:29:45,390 --> 00:29:48,780
environments one type of environment is

645
00:29:48,780 --> 00:29:51,730
the regular environment which our users

646
00:29:51,730 --> 00:29:54,220
will be using and another possible type

647
00:29:54,220 --> 00:29:57,039
of environment is a developer just

648
00:29:57,039 --> 00:29:59,200
taking our software and trying to do

649
00:29:59,200 --> 00:30:00,940
something else with it or you know build

650
00:30:00,940 --> 00:30:03,340
on top of it and we have no idea what

651
00:30:03,340 --> 00:30:04,870
these environments will be and how

652
00:30:04,870 --> 00:30:07,450
people will want to use our software so

653
00:30:07,450 --> 00:30:08,770
that's why we need different types of

654
00:30:08,770 --> 00:30:11,740
tests and you know possibly we also use

655
00:30:11,740 --> 00:30:13,539
different types of tools to detect the

656
00:30:13,539 --> 00:30:15,909
problems and and deal with it and I do

657
00:30:15,909 --> 00:30:17,860
need more examples on the topic I will

658
00:30:17,860 --> 00:30:19,360
be continue to explore this topic

659
00:30:19,360 --> 00:30:21,620
throughout the year but if you have

660
00:30:21,620 --> 00:30:23,750
examples which you can share with me or

661
00:30:23,750 --> 00:30:25,240
you know publish something to github

662
00:30:25,240 --> 00:30:30,380
please send me an email now I'll go to

663
00:30:30,380 --> 00:30:32,690
something more practical speed of

664
00:30:32,690 --> 00:30:38,840
execution so as you as you can imagine

665
00:30:38,840 --> 00:30:41,870
mutation testing is very slow and just

666
00:30:41,870 --> 00:30:44,450
to measure how slow and I've taken a

667
00:30:44,450 --> 00:30:47,030
real-world project from fedora it's

668
00:30:47,030 --> 00:30:50,840
called PI kick-start it is a text parser

669
00:30:50,840 --> 00:30:53,210
library used by the Fedora installation

670
00:30:53,210 --> 00:30:54,520
program

671
00:30:54,520 --> 00:30:57,980
it's a medium-sized project with a

672
00:30:57,980 --> 00:31:01,880
little over 100 files I think all of

673
00:31:01,880 --> 00:31:04,580
these files are Python modules they

674
00:31:04,580 --> 00:31:06,620
don't have many dependencies between

675
00:31:06,620 --> 00:31:09,620
each of them so that's good

676
00:31:09,620 --> 00:31:12,740
each module you know does some checking

677
00:31:12,740 --> 00:31:15,980
a few if statements there are hardly any

678
00:31:15,980 --> 00:31:18,860
loops in the code so you know very easy

679
00:31:18,860 --> 00:31:21,590
to understand actually there is some

680
00:31:21,590 --> 00:31:24,440
text then then they write some text as

681
00:31:24,440 --> 00:31:27,290
well as an output and this is a library

682
00:31:27,290 --> 00:31:28,820
which is meant to be used by other

683
00:31:28,820 --> 00:31:30,410
programs so it doesn't really do

684
00:31:30,410 --> 00:31:33,560
anything useful on its own the project

685
00:31:33,560 --> 00:31:35,930
has a fairly good test suite over 90%

686
00:31:35,930 --> 00:31:40,190
coverage with a lot of tests and the

687
00:31:40,190 --> 00:31:42,110
other good thing about is the files

688
00:31:42,110 --> 00:31:44,980
under the source directory a map almost

689
00:31:44,980 --> 00:31:47,660
one-to-one with the files under the test

690
00:31:47,660 --> 00:31:50,500
directory so they have the same names

691
00:31:50,500 --> 00:31:52,850
and first thing I did was take

692
00:31:52,850 --> 00:31:55,430
cosmic-ray the mutation testing 2 for

693
00:31:55,430 --> 00:31:57,320
python and told it okay so here's the

694
00:31:57,320 --> 00:31:59,960
source directory which means load

695
00:31:59,960 --> 00:32:02,210
everything into memory you can find

696
00:32:02,210 --> 00:32:04,210
under this directory in terms of modules

697
00:32:04,210 --> 00:32:06,500
produce all the possible mutations you

698
00:32:06,500 --> 00:32:09,380
can you can produce on these modules and

699
00:32:09,380 --> 00:32:12,230
then here is the test directory use the

700
00:32:12,230 --> 00:32:14,780
test Runner to discover all possible

701
00:32:14,780 --> 00:32:16,640
cases you can discover and just you know

702
00:32:16,640 --> 00:32:20,120
start running and let this run on my

703
00:32:20,120 --> 00:32:23,570
computer that took over 6 days then I

704
00:32:23,570 --> 00:32:26,780
became smarter and wrote a small script

705
00:32:26,780 --> 00:32:30,140
to go through the source directory take

706
00:32:30,140 --> 00:32:33,590
only one file load this into cosmic-ray

707
00:32:33,590 --> 00:32:35,330
which means you know produce

708
00:32:35,330 --> 00:32:37,130
but only for that module you know don't

709
00:32:37,130 --> 00:32:38,300
bother about the rest of the software

710
00:32:38,300 --> 00:32:40,790
only that module and oh by the way here

711
00:32:40,790 --> 00:32:42,680
is the only one filing in the test

712
00:32:42,680 --> 00:32:44,570
directory which contains your tests so

713
00:32:44,570 --> 00:32:45,920
use only that for testing and not

714
00:32:45,920 --> 00:32:49,190
everything else and that was faster

715
00:32:49,190 --> 00:32:52,580
I also added an option called fail fast

716
00:32:52,580 --> 00:32:55,280
which means whenever one of the tests

717
00:32:55,280 --> 00:32:57,830
fails we know that there was a failure

718
00:32:57,830 --> 00:32:59,390
and we will cure the mutant so don't

719
00:32:59,390 --> 00:33:01,220
bother to execute the rest of the cases

720
00:33:01,220 --> 00:33:03,320
this is an option for the test runner

721
00:33:03,320 --> 00:33:06,590
and I did some refactorings like stuff

722
00:33:06,590 --> 00:33:08,990
like app if the length of string is

723
00:33:08,990 --> 00:33:10,790
greater than zero I've replaced this

724
00:33:10,790 --> 00:33:13,550
with only if string and this helped me

725
00:33:13,550 --> 00:33:16,610
save about 1000 mutations which were no

726
00:33:16,610 --> 00:33:19,370
very obvious things and I let this run

727
00:33:19,370 --> 00:33:21,860
the execution time was now a little over

728
00:33:21,860 --> 00:33:25,700
six hours and this is 20 times more

729
00:33:25,700 --> 00:33:27,770
improvement in speed of execution was

730
00:33:27,770 --> 00:33:29,600
still quite slow for any practical

731
00:33:29,600 --> 00:33:34,370
purposes and we say so the way to use

732
00:33:34,370 --> 00:33:36,200
mutation testing at the moment in my

733
00:33:36,200 --> 00:33:40,700
opinion if you you're testing a very

734
00:33:40,700 --> 00:33:42,350
small library or a very small project

735
00:33:42,350 --> 00:33:46,400
then you can go you know foo 1 into CI

736
00:33:46,400 --> 00:33:49,070
and just okay this is my common line to

737
00:33:49,070 --> 00:33:51,320
schedule my mutation testing jobs and

738
00:33:51,320 --> 00:33:54,920
let this run for 10 15 20 minutes and

739
00:33:54,920 --> 00:33:58,310
that should be fine if your project is

740
00:33:58,310 --> 00:34:00,770
sending anything bigger than 200 lines

741
00:34:00,770 --> 00:34:03,680
this is not going to work very well but

742
00:34:03,680 --> 00:34:07,550
what you can do is create a commit hook

743
00:34:07,550 --> 00:34:10,310
or pull request hook which examines the

744
00:34:10,310 --> 00:34:12,920
payload and you can first think you can

745
00:34:12,920 --> 00:34:14,870
do it scheduled mutation testing only

746
00:34:14,870 --> 00:34:16,580
against the files which have been

747
00:34:16,580 --> 00:34:18,650
modified but by that particular commit

748
00:34:18,650 --> 00:34:21,260
or not to request and that should should

749
00:34:21,260 --> 00:34:23,360
be faster next thing you can do the

750
00:34:23,360 --> 00:34:27,320
panic on the tooling is going to go down

751
00:34:27,320 --> 00:34:29,420
from the module level to the class name

752
00:34:29,420 --> 00:34:30,949
and to the method name which has been

753
00:34:30,949 --> 00:34:34,070
modified the Python 2 doesn't know

754
00:34:34,070 --> 00:34:35,900
anything about classes and modules it

755
00:34:35,900 --> 00:34:37,940
only knows and doesn't know anything

756
00:34:37,940 --> 00:34:39,770
about classes and medaled sorry it only

757
00:34:39,770 --> 00:34:42,230
knows about modules so regardless see if

758
00:34:42,230 --> 00:34:44,719
you have one class or 1,000 classes in

759
00:34:44,719 --> 00:34:46,580
one module white unloads the entire

760
00:34:46,580 --> 00:34:48,110
module and starts doing mutations

761
00:34:48,110 --> 00:34:50,409
against everything

762
00:34:50,409 --> 00:34:52,909
on the other hand the Ruby 2 knows about

763
00:34:52,909 --> 00:34:55,879
classes and methods I think and you can

764
00:34:55,879 --> 00:34:57,260
you can tell you know that's only that

765
00:34:57,260 --> 00:35:01,520
particular stuff and you can try and go

766
00:35:01,520 --> 00:35:05,809
even further because this is a poor

767
00:35:05,809 --> 00:35:07,760
request or commit hook you have access

768
00:35:07,760 --> 00:35:10,670
to the actual diff and you can apply

769
00:35:10,670 --> 00:35:13,960
this to to the source under test and

770
00:35:13,960 --> 00:35:16,160
assuming you've tested everything before

771
00:35:16,160 --> 00:35:18,170
and it's fine then you can schedule

772
00:35:18,170 --> 00:35:20,030
mutations only against the lines which

773
00:35:20,030 --> 00:35:24,440
were changed so you can do this and it's

774
00:35:24,440 --> 00:35:25,960
not really impractical to do this

775
00:35:25,960 --> 00:35:29,630
another thing you can do is go into

776
00:35:29,630 --> 00:35:33,549
parallel again depending on the tools

777
00:35:33,549 --> 00:35:37,849
the Python 2 is built around salary so

778
00:35:37,849 --> 00:35:40,369
you can you can very easily hook this to

779
00:35:40,369 --> 00:35:42,500
some messaging back end like rabbitmq

780
00:35:42,500 --> 00:35:46,910
and schedule you know hundreds and

781
00:35:46,910 --> 00:35:49,720
thousands of messages and let your

782
00:35:49,720 --> 00:35:53,720
infrastructure deploy a doc resources or

783
00:35:53,720 --> 00:35:55,250
virtual machines in the cloud and just

784
00:35:55,250 --> 00:35:56,809
you know run your tests in parallel just

785
00:35:56,809 --> 00:35:59,660
get back the results and you can do this

786
00:35:59,660 --> 00:36:02,410
if you have a lot of money of course

787
00:36:02,410 --> 00:36:05,210
here is a list of some mutation testing

788
00:36:05,210 --> 00:36:07,760
tools I have been using only the first

789
00:36:07,760 --> 00:36:09,980
two I must use peyten

790
00:36:09,980 --> 00:36:12,079
and I contribute to cosmic ray for

791
00:36:12,079 --> 00:36:17,390
Python and I've used mutant for Ruby but

792
00:36:17,390 --> 00:36:21,859
not very actively at the moment the name

793
00:36:21,859 --> 00:36:23,480
to the names to the rights or github

794
00:36:23,480 --> 00:36:31,210
repositories okay so as far as I know

795
00:36:31,210 --> 00:36:34,520
the two's on the top are based on the

796
00:36:34,520 --> 00:36:36,650
abstract abstract syntax tree of the

797
00:36:36,650 --> 00:36:38,599
language and they are language specific

798
00:36:38,599 --> 00:36:41,089
so whatever you know you want to do in

799
00:36:41,089 --> 00:36:44,059
the two it works on is TS but modifies

800
00:36:44,059 --> 00:36:47,480
the nodes of the ast one thing I like to

801
00:36:47,480 --> 00:36:50,329
do is look at the other tools and see

802
00:36:50,329 --> 00:36:51,890
what they are doing especially in terms

803
00:36:51,890 --> 00:36:54,230
of mutation operators and try to bring

804
00:36:54,230 --> 00:36:58,220
this to Python so if you if you want to

805
00:36:58,220 --> 00:37:01,670
actively use mutation testing I really

806
00:37:01,670 --> 00:37:02,809
advise you to look at

807
00:37:02,809 --> 00:37:04,549
- for other languages and see how they

808
00:37:04,549 --> 00:37:06,799
work in how they are doing and because

809
00:37:06,799 --> 00:37:08,599
many of the - the tools are very new

810
00:37:08,599 --> 00:37:11,779
they're not very mature and on the

811
00:37:11,779 --> 00:37:15,109
bottom this is another tool for mutation

812
00:37:15,109 --> 00:37:17,599
testing called the mule project which

813
00:37:17,599 --> 00:37:19,849
Alex Denis of will be presenting later

814
00:37:19,849 --> 00:37:22,640
today so I'll definitely be checking out

815
00:37:22,640 --> 00:37:24,679
checking this out this is an LLVM based

816
00:37:24,679 --> 00:37:27,229
- so it should work for several

817
00:37:27,229 --> 00:37:29,689
different languages if you are into

818
00:37:29,689 --> 00:37:38,059
mutation testing also check this out and

819
00:37:38,059 --> 00:37:41,150
now before I can go further I can take

820
00:37:41,150 --> 00:37:42,979
some questions from the audience and if

821
00:37:42,979 --> 00:37:47,890
you like okay go

822
00:38:10,619 --> 00:38:13,270
okay so the question is if we have a

823
00:38:13,270 --> 00:38:17,349
zombie and but we have 100% code code

824
00:38:17,349 --> 00:38:19,150
coverage doesn't mean the coverage was

825
00:38:19,150 --> 00:38:20,130
wrong

826
00:38:20,130 --> 00:38:27,609
yep yeah okay so it doesn't mean

827
00:38:27,609 --> 00:38:30,069
coverage was wrong like I mean it

828
00:38:30,069 --> 00:38:31,780
doesn't mean the metric the measurement

829
00:38:31,780 --> 00:38:32,770
was wrong

830
00:38:32,770 --> 00:38:36,040
it was probably correct there are other

831
00:38:36,040 --> 00:38:38,079
problems with coverage like for example

832
00:38:38,079 --> 00:38:41,980
if you have one line with lots of with a

833
00:38:41,980 --> 00:38:44,319
longer boolean expression then it still

834
00:38:44,319 --> 00:38:46,329
gets covered regardless of how much of

835
00:38:46,329 --> 00:38:48,160
that expression is evaluated so you may

836
00:38:48,160 --> 00:38:50,170
be evaluating only the first part of the

837
00:38:50,170 --> 00:38:52,990
expression and still cover that line but

838
00:38:52,990 --> 00:38:54,970
you know the next 10 parts of the

839
00:38:54,970 --> 00:38:58,740
boardings pressure are not evaluated

840
00:39:04,380 --> 00:39:08,010
yeah well the way to count you know

841
00:39:08,010 --> 00:39:11,079
these cases is you should take this up

842
00:39:11,079 --> 00:39:13,630
to date the to to the authors of 2 who

843
00:39:13,630 --> 00:39:16,119
do coverage but there are many many

844
00:39:16,119 --> 00:39:20,109
publications online with respect to

845
00:39:20,109 --> 00:39:22,540
problem C coverage and why it's not

846
00:39:22,540 --> 00:39:24,130
really a good metric why you shouldn't

847
00:39:24,130 --> 00:39:26,500
use coverage and really for me the

848
00:39:26,500 --> 00:39:30,069
coverage is is a vanity metric it it

849
00:39:30,069 --> 00:39:31,630
really tells you how much of the you

850
00:39:31,630 --> 00:39:33,130
know of the lines you've covered but

851
00:39:33,130 --> 00:39:34,960
nothing more it doesn't take anything

852
00:39:34,960 --> 00:39:38,170
more and if you have a zombie on a line

853
00:39:38,170 --> 00:39:41,109
which was covered this simply means you

854
00:39:41,109 --> 00:39:43,420
might have executed this line but

855
00:39:43,420 --> 00:39:45,309
probably you didn't assert on some

856
00:39:45,309 --> 00:39:48,490
condition or you know you assert it on

857
00:39:48,490 --> 00:39:50,500
one condition and you needed to assert

858
00:39:50,500 --> 00:39:52,589
on two conditions

859
00:39:52,589 --> 00:39:55,589
okay

860
00:39:59,900 --> 00:40:46,190
yes yes okay we have question there okay

861
00:40:46,190 --> 00:40:48,799
so the quick yeah the question is what

862
00:40:48,799 --> 00:40:51,289
if we we don't use primitives we use

863
00:40:51,289 --> 00:40:53,480
some library for the business logic

864
00:40:53,480 --> 00:40:55,450
how does mutation testing come into play

865
00:40:55,450 --> 00:40:58,700
well this is very dependent on the tools

866
00:40:58,700 --> 00:41:01,520
that you use so for example the the

867
00:41:01,520 --> 00:41:03,819
Python tool out in risk until recently

868
00:41:03,819 --> 00:41:06,740
it was very poor on mutation operators

869
00:41:06,740 --> 00:41:09,140
because it's new too and not many people

870
00:41:09,140 --> 00:41:12,079
use it on the other hand the Ruby tool

871
00:41:12,079 --> 00:41:14,119
called mutant I think this is one of the

872
00:41:14,119 --> 00:41:17,539
best tools currently in existence and it

873
00:41:17,539 --> 00:41:20,240
has tons of mutation operators tons of

874
00:41:20,240 --> 00:41:23,000
conditions it understands because it's

875
00:41:23,000 --> 00:41:24,950
used by people who work on commercial

876
00:41:24,950 --> 00:41:27,410
software they get paid to actually write

877
00:41:27,410 --> 00:41:29,150
test Suites for commercial software and

878
00:41:29,150 --> 00:41:32,020
they support the tool for that reason

879
00:41:32,020 --> 00:41:34,460
about JavaScript I don't really have no

880
00:41:34,460 --> 00:41:36,829
no idea I don't use JavaScript but

881
00:41:36,829 --> 00:41:40,400
really the you know the take here is you

882
00:41:40,400 --> 00:41:42,440
need to know your tools very well and

883
00:41:42,440 --> 00:41:44,510
you need to know the software very well

884
00:41:44,510 --> 00:41:46,549
and that that's when you can decide

885
00:41:46,549 --> 00:41:47,630
whether or not that's going to be useful

886
00:41:47,630 --> 00:41:50,240
now maybe maybe in your case you might

887
00:41:50,240 --> 00:41:52,069
write a plug-in or you know an extension

888
00:41:52,069 --> 00:41:55,099
to the tool and produce the mutation

889
00:41:55,099 --> 00:41:56,569
based on the functions in that

890
00:41:56,569 --> 00:42:02,410
particular library okay question here

891
00:42:05,509 --> 00:42:08,209
it's equivalent in regions can you say

892
00:42:08,209 --> 00:42:10,009
something about them how often do you

893
00:42:10,009 --> 00:42:12,609
see them in production

894
00:42:13,809 --> 00:42:15,919
okay so the question was about

895
00:42:15,919 --> 00:42:18,859
equivalent mutants equivalent mutants

896
00:42:18,859 --> 00:42:22,339
are things like which you know change

897
00:42:22,339 --> 00:42:23,630
the code but don't really change

898
00:42:23,630 --> 00:42:26,089
behavior in any practical way so for

899
00:42:26,089 --> 00:42:28,819
example we may have less than operator

900
00:42:28,819 --> 00:42:32,119
which in practice is equivalent to less

901
00:42:32,119 --> 00:42:35,599
than or equal if we you know in

902
00:42:35,599 --> 00:42:37,099
depending on the values we accept in the

903
00:42:37,099 --> 00:42:40,309
application and I don't have any

904
00:42:40,309 --> 00:42:43,189
concrete measure about this in practice

905
00:42:43,189 --> 00:42:44,929
but I think about ten or fifteen percent

906
00:42:44,929 --> 00:42:46,929
of the time I see equivalent mutants

907
00:42:46,929 --> 00:42:49,489
equivalent mutants because because the

908
00:42:49,489 --> 00:42:51,529
behavior doesn't change but the syntax

909
00:42:51,529 --> 00:42:53,059
changes but the behavior doesn't change

910
00:42:53,059 --> 00:42:56,179
the test suite doesn't fail and we

911
00:42:56,179 --> 00:42:58,219
cannot kill them and they just stay as

912
00:42:58,219 --> 00:43:02,329
this in in the project I use petition

913
00:43:02,329 --> 00:43:05,479
testing for I don't I usually have some

914
00:43:05,479 --> 00:43:08,479
threshold like about ten to ten percent

915
00:43:08,479 --> 00:43:12,199
or something like that and if the mutant

916
00:43:12,199 --> 00:43:15,079
score is you know above a certain line

917
00:43:15,079 --> 00:43:17,689
then I say we're good and then the CI

918
00:43:17,689 --> 00:43:20,809
system goes green and if you drop under

919
00:43:20,809 --> 00:43:24,349
that line and we go red and inspect

920
00:43:24,349 --> 00:43:27,019
what's happening and that threshold is

921
00:43:27,019 --> 00:43:28,880
based on how many equivalent mutants I

922
00:43:28,880 --> 00:43:31,789
have so I try to you know get some idea

923
00:43:31,789 --> 00:43:34,839
about that and then go go from there

924
00:43:34,839 --> 00:43:37,099
I've talked to other people who do

925
00:43:37,099 --> 00:43:38,599
mutation testing and have been doing

926
00:43:38,599 --> 00:43:43,249
mutations for a long long time and this

927
00:43:43,249 --> 00:43:45,949
is a problem but still the benefits you

928
00:43:45,949 --> 00:43:48,649
get from asserting on all those

929
00:43:48,649 --> 00:43:50,539
different conditions and looking at your

930
00:43:50,539 --> 00:43:52,069
code base in understanding the software

931
00:43:52,069 --> 00:43:55,130
much more better which is the result of

932
00:43:55,130 --> 00:43:59,089
mutation testing it just you know is the

933
00:43:59,089 --> 00:44:01,159
benefit is greater than having to deal

934
00:44:01,159 --> 00:44:08,479
with equivalent mutants okay okay

935
00:44:08,479 --> 00:44:11,719
more questions or no questions we have

936
00:44:11,719 --> 00:44:14,059
two minutes so on there are if there are

937
00:44:14,059 --> 00:44:16,159
no more questions I'll just show you

938
00:44:16,159 --> 00:44:18,679
this very quickly I have started to

939
00:44:18,679 --> 00:44:19,279
document

940
00:44:19,279 --> 00:44:22,459
my findings about mutation testing so

941
00:44:22,459 --> 00:44:24,039
first of all I don't forget them and

942
00:44:24,039 --> 00:44:26,479
some of them make really good examples

943
00:44:26,479 --> 00:44:29,209
so this is available and read the docs

944
00:44:29,209 --> 00:44:31,519
and it's also available on github if

945
00:44:31,519 --> 00:44:35,779
you'd like to contribute and it since

946
00:44:35,779 --> 00:44:37,669
the last week we have also Chinese

947
00:44:37,669 --> 00:44:43,009
translation for this and I'll skip the

948
00:44:43,009 --> 00:44:45,259
trivial examples and show you the last

949
00:44:45,259 --> 00:44:52,279
one so we have we have this sound in

950
00:44:52,279 --> 00:44:54,159
Python it's fairly common to have

951
00:44:54,159 --> 00:44:57,199
methods for equality which compare two

952
00:44:57,199 --> 00:45:01,009
objects by comparing that all of the

953
00:45:01,009 --> 00:45:04,309
attributes are equal so in this example

954
00:45:04,309 --> 00:45:06,529
we have class code sandwich and you can

955
00:45:06,529 --> 00:45:08,509
modify the meat of your sandwich and the

956
00:45:08,509 --> 00:45:10,999
bread type of your sandwich and we say

957
00:45:10,999 --> 00:45:14,059
that two sandwiches are equal if meat

958
00:45:14,059 --> 00:45:16,789
and bread attributes are equal and

959
00:45:16,789 --> 00:45:17,509
that's about it

960
00:45:17,509 --> 00:45:20,179
no we have a safety check here if the

961
00:45:20,179 --> 00:45:22,519
other object is now the litter falls and

962
00:45:22,519 --> 00:45:23,929
you know Tico's method is just a

963
00:45:23,929 --> 00:45:26,630
negation of the equals and you way to

964
00:45:26,630 --> 00:45:29,599
test this with mutation testing is like

965
00:45:29,599 --> 00:45:33,109
so so we create two test objects and

966
00:45:33,109 --> 00:45:36,049
which one a sandwich two by default all

967
00:45:36,049 --> 00:45:37,909
of their attributes have a value of

968
00:45:37,909 --> 00:45:40,669
empty string which is not shown on the

969
00:45:40,669 --> 00:45:45,219
screen and first thing we do is test the

970
00:45:45,219 --> 00:45:47,419
test for equality they should be equal

971
00:45:47,419 --> 00:45:49,789
because everything is an empty string

972
00:45:49,789 --> 00:45:53,119
inside these objects and we also serve

973
00:45:53,119 --> 00:45:55,519
that the two objects are wrong you know

974
00:45:55,519 --> 00:45:57,019
when compares for non equality it

975
00:45:57,019 --> 00:46:00,219
returns false and that takes care of

976
00:46:00,219 --> 00:46:03,589
half of the testing then we test the

977
00:46:03,589 --> 00:46:06,799
safety check compare to none and expect

978
00:46:06,799 --> 00:46:09,409
to not be equal and then comes the fun

979
00:46:09,409 --> 00:46:14,599
part the way to so this starts changing

980
00:46:14,599 --> 00:46:17,569
into different comparison operators and

981
00:46:17,569 --> 00:46:20,719
the way to test is like this so we we

982
00:46:20,719 --> 00:46:22,609
need to modify only one of the

983
00:46:22,609 --> 00:46:25,880
attributes that one of the test object

984
00:46:25,880 --> 00:46:27,709
can leave the rest of the attributes and

985
00:46:27,709 --> 00:46:29,569
the other object unchanged and we need

986
00:46:29,569 --> 00:46:32,720
to do this for every single attribute so

987
00:46:32,720 --> 00:46:34,579
when all the attributes are of the same

988
00:46:34,579 --> 00:46:39,109
type you just do this and if they're not

989
00:46:39,109 --> 00:46:40,940
of the same type you can do Group Inc or

990
00:46:40,940 --> 00:46:42,160
something like that to you know to

991
00:46:42,160 --> 00:46:45,349
modify this block so when the time's up

992
00:46:45,349 --> 00:46:47,200
so thank you very much

993
00:46:47,200 --> 00:46:55,730
[Applause]

