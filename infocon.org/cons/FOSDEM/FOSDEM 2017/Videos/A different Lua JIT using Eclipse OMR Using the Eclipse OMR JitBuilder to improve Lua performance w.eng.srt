1
00:00:04,490 --> 00:00:07,670
okay today I'm here to talk about a

2
00:00:07,670 --> 00:00:10,100
project that one of my co-workers and I

3
00:00:10,100 --> 00:00:11,870
started a few months a few months ago

4
00:00:11,870 --> 00:00:15,160
it's had a couple of weeks of work so

5
00:00:15,160 --> 00:00:18,290
but bear with me as we go through some

6
00:00:18,290 --> 00:00:21,349
of the details so basically I'm the

7
00:00:21,349 --> 00:00:24,259
project lead on my name's Charlie Gracey

8
00:00:24,259 --> 00:00:27,140
I'm an employee at IBM but I'm also of

9
00:00:27,140 --> 00:00:29,180
the project lead our co-lead for the

10
00:00:29,180 --> 00:00:32,058
clips of our project so I'll give you a

11
00:00:32,058 --> 00:00:33,410
bit more details about that as we get

12
00:00:33,410 --> 00:00:38,629
going in the talk but sorry I work for a

13
00:00:38,629 --> 00:00:40,789
large company have to put this slide up

14
00:00:40,789 --> 00:00:42,199
saying you can't trust me or believe

15
00:00:42,199 --> 00:00:47,929
anything I say okay so this talk I'm

16
00:00:47,929 --> 00:00:51,379
gonna quickly introduce the Eclipse omr

17
00:00:51,379 --> 00:00:54,379
project and then I'm going to go into

18
00:00:54,379 --> 00:00:58,809
quick bit of details on one of the

19
00:00:58,809 --> 00:01:01,429
components of the project called a jib

20
00:01:01,429 --> 00:01:03,920
builder and then I'm going to talk about

21
00:01:03,920 --> 00:01:05,510
some of the experiments we've been doing

22
00:01:05,510 --> 00:01:09,500
using JIT builder in lieu of 5:3 VM to

23
00:01:09,500 --> 00:01:12,549
actually add a jet to the Lua VM and

24
00:01:12,549 --> 00:01:15,590
then some future work and open it up for

25
00:01:15,590 --> 00:01:20,180
some questions so the mission for the

26
00:01:20,180 --> 00:01:22,700
OLM our project is to basically create a

27
00:01:22,700 --> 00:01:26,030
reusable set of length runtime toolkits

28
00:01:26,030 --> 00:01:29,030
that any runtime any existing we're on

29
00:01:29,030 --> 00:01:30,860
time or any new runtime could use to

30
00:01:30,860 --> 00:01:33,289
actually get different components for

31
00:01:33,289 --> 00:01:35,600
their runtime so if you have a runtime

32
00:01:35,600 --> 00:01:37,219
that you've spent a lot of time working

33
00:01:37,219 --> 00:01:39,530
on but you didn't have anybody with deep

34
00:01:39,530 --> 00:01:41,689
compiler knowledge well you can go pick

35
00:01:41,689 --> 00:01:43,820
up the Omar project and plug it into

36
00:01:43,820 --> 00:01:46,909
your runtime and hopefully get a JIT JIT

37
00:01:46,909 --> 00:01:48,289
builder that I'll talk about later is

38
00:01:48,289 --> 00:01:50,270
making that easier than actually having

39
00:01:50,270 --> 00:01:52,670
to understand the 800 thousand lines of

40
00:01:52,670 --> 00:01:55,820
JIT code that are there so that's that

41
00:01:55,820 --> 00:01:59,509
and we want to accelerate this for a lot

42
00:01:59,509 --> 00:02:01,670
of the current runtimes or that's our

43
00:02:01,670 --> 00:02:05,210
hope so and lots of other examples if

44
00:02:05,210 --> 00:02:07,670
you look at some of the other

45
00:02:07,670 --> 00:02:10,870
communities they'll end up doing another

46
00:02:10,870 --> 00:02:14,150
VM or something and there's the Lua JIT

47
00:02:14,150 --> 00:02:16,970
VM as well and so we're kind of hoping

48
00:02:16,970 --> 00:02:17,670
with

49
00:02:17,670 --> 00:02:19,440
the Eclipse project that you can use

50
00:02:19,440 --> 00:02:21,150
these and keep your community the same

51
00:02:21,150 --> 00:02:22,470
way as it is so you can just plug it

52
00:02:22,470 --> 00:02:24,750
into your runtime and hopefully there's

53
00:02:24,750 --> 00:02:27,150
no really big differences or problems

54
00:02:27,150 --> 00:02:29,280
for using that runtime still but you get

55
00:02:29,280 --> 00:02:31,320
the benefits of a scalable GC if you

56
00:02:31,320 --> 00:02:36,230
wanted or some rasz tooling porridge it

57
00:02:36,590 --> 00:02:40,050
so the olam our project itself has no

58
00:02:40,050 --> 00:02:43,230
language semantics as far as on the GC

59
00:02:43,230 --> 00:02:44,940
architects far as I'm concerned at GCSE

60
00:02:44,940 --> 00:02:48,510
a GC is a GC you have objects as long as

61
00:02:48,510 --> 00:02:50,700
you can tell me what shape they are I

62
00:02:50,700 --> 00:02:54,240
can go collect your objects and watch

63
00:02:54,240 --> 00:02:56,310
the memory for you and we believe that

64
00:02:56,310 --> 00:02:58,080
most of the components in the and all

65
00:02:58,080 --> 00:03:01,770
the VMS are kind of similar so it was

66
00:03:01,770 --> 00:03:03,870
originally the first drop of the code

67
00:03:03,870 --> 00:03:08,010
was last March it's on github it's dual

68
00:03:08,010 --> 00:03:12,360
license under Apache and Eclipse we're

69
00:03:12,360 --> 00:03:16,290
always looking for contributors now so

70
00:03:16,290 --> 00:03:17,550
right now this is sort of a quick

71
00:03:17,550 --> 00:03:19,230
overview of the components that happen

72
00:03:19,230 --> 00:03:20,760
to be there so if you have a runtime

73
00:03:20,760 --> 00:03:23,519
that wanted something you can might be

74
00:03:23,519 --> 00:03:25,980
able to consume the one from Olimar the

75
00:03:25,980 --> 00:03:28,350
first two are sort of for platform

76
00:03:28,350 --> 00:03:31,560
support so it's important thread library

77
00:03:31,560 --> 00:03:34,260
if you used it it works on Windows z OS

78
00:03:34,260 --> 00:03:37,260
Linux OS X so you just sort of get the

79
00:03:37,260 --> 00:03:42,030
threading and porting of those GC a JIT

80
00:03:42,030 --> 00:03:44,420
and then some more sort of diagnostic

81
00:03:44,420 --> 00:03:47,190
stuff that you would see from runtimes

82
00:03:47,190 --> 00:03:48,510
like Java that you can hook up and

83
00:03:48,510 --> 00:03:51,120
monitor at runtime how your application

84
00:03:51,120 --> 00:03:53,400
is going to heat object allocation and

85
00:03:53,400 --> 00:03:58,320
all of those things so now I'm gonna

86
00:03:58,320 --> 00:04:00,900
move into JIT builder kind of quickly I

87
00:04:00,900 --> 00:04:02,790
apologize this is going to be some code

88
00:04:02,790 --> 00:04:04,410
start showing up on the screen hopefully

89
00:04:04,410 --> 00:04:08,700
doesn't put you guys to sleep so what is

90
00:04:08,700 --> 00:04:11,910
geo builder it is an interface to our

91
00:04:11,910 --> 00:04:15,150
compiler technology to hopefully make it

92
00:04:15,150 --> 00:04:17,100
easier for people to get up and going

93
00:04:17,100 --> 00:04:21,779
with a JIT in their runtime we don't

94
00:04:21,779 --> 00:04:23,610
believe that using this sort of

95
00:04:23,610 --> 00:04:26,010
front-end API into the JIT would ever

96
00:04:26,010 --> 00:04:28,140
give you our peak performance as you can

97
00:04:28,140 --> 00:04:30,450
get by actually going in and generating

98
00:04:30,450 --> 00:04:31,590
il yourself

99
00:04:31,590 --> 00:04:32,910
intermediate language yourself and all

100
00:04:32,910 --> 00:04:35,370
of these things if you really dug in and

101
00:04:35,370 --> 00:04:37,020
to the deep internals of the compiler

102
00:04:37,020 --> 00:04:39,270
itself but we believe you could get a

103
00:04:39,270 --> 00:04:41,280
significant performance improvement and

104
00:04:41,280 --> 00:04:43,110
it's very straightforward and easy to

105
00:04:43,110 --> 00:04:48,660
use using this API so the code was only

106
00:04:48,660 --> 00:04:51,960
contributed for September for this so

107
00:04:51,960 --> 00:04:53,400
it's still kind of work in progress

108
00:04:53,400 --> 00:04:56,640
we're still ironing out the API changing

109
00:04:56,640 --> 00:04:58,260
it modifying it and adding new features

110
00:04:58,260 --> 00:05:01,110
as we plug it into different runtimes so

111
00:05:01,110 --> 00:05:03,300
actually the last month we've been

112
00:05:03,300 --> 00:05:06,450
working on the Lua JIT probably has only

113
00:05:06,450 --> 00:05:08,100
been about a week of work of actually

114
00:05:08,100 --> 00:05:11,040
putting it in the jet into Lua we've

115
00:05:11,040 --> 00:05:12,540
been sidetracked on adding new features

116
00:05:12,540 --> 00:05:15,930
and fixing things in the or fixing the

117
00:05:15,930 --> 00:05:17,850
JIT builder stuff we're fixing is

118
00:05:17,850 --> 00:05:20,010
changing how things work so it could be

119
00:05:20,010 --> 00:05:24,630
more useful to other languages so it's

120
00:05:24,630 --> 00:05:26,730
very straightforward if you were using

121
00:05:26,730 --> 00:05:29,400
it there's a simple initialize and a

122
00:05:29,400 --> 00:05:31,230
shutdown API put those in your

123
00:05:31,230 --> 00:05:33,570
initialization for your runtime and

124
00:05:33,570 --> 00:05:36,320
you're set down and you're ready to go

125
00:05:36,320 --> 00:05:39,030
but then you actually have to start

126
00:05:39,030 --> 00:05:40,650
using it to compile your methods or

127
00:05:40,650 --> 00:05:44,900
functions or whatever your runtime has

128
00:05:47,270 --> 00:05:49,440
so that's the bit of the complicated

129
00:05:49,440 --> 00:05:52,500
part so to do this we've created a

130
00:05:52,500 --> 00:05:54,870
method builder if anyone is familiar

131
00:05:54,870 --> 00:05:58,950
with LLVM stuff some of the terminology

132
00:05:58,950 --> 00:06:00,300
is pretty similar i've noticed recently

133
00:06:00,300 --> 00:06:02,040
as we you're doing the same types of

134
00:06:02,040 --> 00:06:04,520
things so it kind of makes sense I guess

135
00:06:04,520 --> 00:06:07,590
so this method builder is basically what

136
00:06:07,590 --> 00:06:10,620
you would use to define what a method is

137
00:06:10,620 --> 00:06:13,980
in your runtime so any parameters that

138
00:06:13,980 --> 00:06:16,050
it would have what to type like if it

139
00:06:16,050 --> 00:06:19,560
what's the return you want back and and

140
00:06:19,560 --> 00:06:22,680
gives you and all of this stuff being

141
00:06:22,680 --> 00:06:24,330
generated as actually done using system

142
00:06:24,330 --> 00:06:25,920
linkage so basically you're it's like

143
00:06:25,920 --> 00:06:27,510
making a sea call when you want to call

144
00:06:27,510 --> 00:06:29,790
one of these jetted functions there's

145
00:06:29,790 --> 00:06:32,580
more tricky things when it's calling the

146
00:06:32,580 --> 00:06:35,160
JIT later on but for most part it's like

147
00:06:35,160 --> 00:06:42,480
a sea call so sorry the two main parts

148
00:06:42,480 --> 00:06:44,400
of the math builder are the constructor

149
00:06:44,400 --> 00:06:45,000
and in there

150
00:06:45,000 --> 00:06:46,860
this bill dial method and I'm gonna go

151
00:06:46,860 --> 00:06:48,780
into an example to sort of describe

152
00:06:48,780 --> 00:06:50,580
those quickly before I move on to the

153
00:06:50,580 --> 00:06:55,230
Lua versions of it so what can you do

154
00:06:55,230 --> 00:06:56,910
with chip builder so it basically has

155
00:06:56,910 --> 00:06:59,190
these types of operations so we have all

156
00:06:59,190 --> 00:07:03,450
your primitive data types of course you

157
00:07:03,450 --> 00:07:04,320
want to be able to do all of your

158
00:07:04,320 --> 00:07:06,630
arithmetic adds subtraction divide all

159
00:07:06,630 --> 00:07:09,510
of those types of things exist then

160
00:07:09,510 --> 00:07:12,900
there's conditionals and different

161
00:07:12,900 --> 00:07:14,910
systems for doing loopings and those

162
00:07:14,910 --> 00:07:17,130
types of things and then there's a

163
00:07:17,130 --> 00:07:18,930
generic call that you can call any other

164
00:07:18,930 --> 00:07:21,360
arbitrary see function just tell it the

165
00:07:21,360 --> 00:07:23,760
function name give it an address of

166
00:07:23,760 --> 00:07:25,770
where it will be and that passes the

167
00:07:25,770 --> 00:07:30,540
right parameters so most of the

168
00:07:30,540 --> 00:07:33,240
operations that used to say operations

169
00:07:33,240 --> 00:07:34,860
are type list now it's they're mostly

170
00:07:34,860 --> 00:07:36,930
type list a few of them actually need to

171
00:07:36,930 --> 00:07:38,940
know the type once you've been working

172
00:07:38,940 --> 00:07:41,900
with your builder if you have an N value

173
00:07:41,900 --> 00:07:44,280
that you're passing around doing stuff

174
00:07:44,280 --> 00:07:46,440
with it has a type so most of the time

175
00:07:46,440 --> 00:07:48,419
you don't actually have to say I don't

176
00:07:48,419 --> 00:07:50,190
want to do an add 32 if you're adding

177
00:07:50,190 --> 00:07:51,660
two things together you're setting out

178
00:07:51,660 --> 00:07:53,700
on them if they're both in so it's gonna

179
00:07:53,700 --> 00:07:56,460
do their proper one it'll if one's

180
00:07:56,460 --> 00:07:58,710
larger int it'll do the right extension

181
00:07:58,710 --> 00:08:00,090
or tell you you need to convert it

182
00:08:00,090 --> 00:08:03,479
yourself but there are a few things like

183
00:08:03,479 --> 00:08:06,930
load and store at which are for indexing

184
00:08:06,930 --> 00:08:09,750
things out of array type data on your

185
00:08:09,750 --> 00:08:15,900
memory so a simple method builder

186
00:08:15,900 --> 00:08:20,850
example so right away one of the first

187
00:08:20,850 --> 00:08:22,260
things in news you need to give a name

188
00:08:22,260 --> 00:08:24,600
because these are basically C functions

189
00:08:24,600 --> 00:08:27,120
they can be called by by basically by

190
00:08:27,120 --> 00:08:28,530
name and we're setting up a proper C

191
00:08:28,530 --> 00:08:29,970
stack for everything so you name them

192
00:08:29,970 --> 00:08:32,190
and that also allows the JIT builder

193
00:08:32,190 --> 00:08:34,049
itself to be able to call from one to

194
00:08:34,049 --> 00:08:37,740
the other parameters so this one is

195
00:08:37,740 --> 00:08:41,669
simply going to do an increment so it

196
00:08:41,669 --> 00:08:45,510
takes an int to return type is also in

197
00:08:45,510 --> 00:08:49,560
in 32 type Dictionary is a list of types

198
00:08:49,560 --> 00:08:51,000
so you can actually define your own type

199
00:08:51,000 --> 00:08:53,250
so when we get talking about the Lua one

200
00:08:53,250 --> 00:08:55,350
later if anyone's familiar with the Lua

201
00:08:55,350 --> 00:08:57,120
VM there's the Luas state there's call

202
00:08:57,120 --> 00:08:58,770
info all of these things

203
00:08:58,770 --> 00:09:01,020
we actually go and have a mapping of

204
00:09:01,020 --> 00:09:03,390
defined of all of those structures so

205
00:09:03,390 --> 00:09:05,580
that we can actually if we get the main

206
00:09:05,580 --> 00:09:06,870
parameter when we get to the lure one

207
00:09:06,870 --> 00:09:08,250
will actually be the Lewis state that's

208
00:09:08,250 --> 00:09:10,110
what's passed into the function so to be

209
00:09:10,110 --> 00:09:11,670
able to get everything off of it we can

210
00:09:11,670 --> 00:09:13,560
do a bunch of like load indirect

211
00:09:13,560 --> 00:09:15,510
instructions or things and we just pass

212
00:09:15,510 --> 00:09:17,130
it the field name that we want out of

213
00:09:17,130 --> 00:09:19,709
the particular one so these type

214
00:09:19,709 --> 00:09:22,020
Dictionary allows you to use the generic

215
00:09:22,020 --> 00:09:24,990
int boolean or double it's probably not

216
00:09:24,990 --> 00:09:28,380
a bool and but then also define your own

217
00:09:28,380 --> 00:09:31,440
complicated ones the Lua ones have

218
00:09:31,440 --> 00:09:32,940
actually driven a lot of change in

219
00:09:32,940 --> 00:09:34,500
because the structure is there are full

220
00:09:34,500 --> 00:09:37,830
of unions it's a union of all these

221
00:09:37,830 --> 00:09:39,060
different types so we didn't actually

222
00:09:39,060 --> 00:09:40,680
support that before so that's been most

223
00:09:40,680 --> 00:09:42,570
of our work and making sure we can alias

224
00:09:42,570 --> 00:09:46,230
the types properly on the JIT side so

225
00:09:46,230 --> 00:09:48,630
and then the other part I was the

226
00:09:48,630 --> 00:09:50,940
constructor the body of the function the

227
00:09:50,940 --> 00:09:53,430
build il would just be add this value

228
00:09:53,430 --> 00:09:55,740
that's passed in as a parameter to a

229
00:09:55,740 --> 00:09:59,640
constant one and return the value so in

230
00:09:59,640 --> 00:10:00,810
the end that would actually just

231
00:10:00,810 --> 00:10:02,730
generate some very simple C code for

232
00:10:02,730 --> 00:10:04,770
taking what was passed in in a register

233
00:10:04,770 --> 00:10:07,410
on x86 adding one to it and putting into

234
00:10:07,410 --> 00:10:11,940
the proper register to return that was

235
00:10:11,940 --> 00:10:15,930
the value that we were talking about so

236
00:10:15,930 --> 00:10:19,140
one other thing about the the Builder

237
00:10:19,140 --> 00:10:20,970
stuff is to actually build to do control

238
00:10:20,970 --> 00:10:23,640
flow so different code paths so if you

239
00:10:23,640 --> 00:10:26,670
were looking at a method in the

240
00:10:26,670 --> 00:10:28,890
interpreter for Lua something like add

241
00:10:28,890 --> 00:10:31,200
if your type is an int you do this type

242
00:10:31,200 --> 00:10:33,420
of add if it's a float or if it's just a

243
00:10:33,420 --> 00:10:35,040
number you do a different type so to be

244
00:10:35,040 --> 00:10:36,870
able to handle these control flows we

245
00:10:36,870 --> 00:10:38,970
have basically this stuff setup so you

246
00:10:38,970 --> 00:10:42,750
could actually do different builders so

247
00:10:42,750 --> 00:10:44,940
this one is you create a couple of

248
00:10:44,940 --> 00:10:48,450
builders so you could do the pass with

249
00:10:48,450 --> 00:10:51,240
them then you would do if then else so

250
00:10:51,240 --> 00:10:53,790
in this case the then an else paths are

251
00:10:53,790 --> 00:10:55,110
the builders that would be executed

252
00:10:55,110 --> 00:10:57,329
depending on the condition so the

253
00:10:57,329 --> 00:10:59,760
condition here is less than if a is less

254
00:10:59,760 --> 00:11:03,600
than B then you would do the if path the

255
00:11:03,600 --> 00:11:04,829
then path otherwise you would go down

256
00:11:04,829 --> 00:11:07,520
the else path

257
00:11:09,140 --> 00:11:11,310
and this is going through quickly

258
00:11:11,310 --> 00:11:13,080
talking about what the value would be in

259
00:11:13,080 --> 00:11:19,620
the end either one or zero so again type

260
00:11:19,620 --> 00:11:23,220
Dictionary to cover this quickly so when

261
00:11:23,220 --> 00:11:25,560
you want to define a struct and now you

262
00:11:25,560 --> 00:11:30,630
can define unions basically what you do

263
00:11:30,630 --> 00:11:35,940
is you give it a name for the struct and

264
00:11:35,940 --> 00:11:40,110
then everywhere inside you would

265
00:11:40,110 --> 00:11:41,460
actually just give it that same name and

266
00:11:41,460 --> 00:11:42,630
then you just give it the name of the

267
00:11:42,630 --> 00:11:44,550
field so usually you make these match up

268
00:11:44,550 --> 00:11:48,900
to the C struct or the C++ class we're

269
00:11:48,900 --> 00:11:50,400
looking at trying to find some way to

270
00:11:50,400 --> 00:11:52,470
actually have this automat automatically

271
00:11:52,470 --> 00:11:54,540
do it for you if you could give it a the

272
00:11:54,540 --> 00:11:56,130
header file that it's containing to say

273
00:11:56,130 --> 00:11:57,750
generate me one for this struct but

274
00:11:57,750 --> 00:11:59,580
that's just something we're looking into

275
00:11:59,580 --> 00:12:05,760
for the future and one last thing about

276
00:12:05,760 --> 00:12:08,820
this is most of the the JIT builders

277
00:12:08,820 --> 00:12:10,590
stuff is very generic so you could use

278
00:12:10,590 --> 00:12:12,540
it for anything you could go write your

279
00:12:12,540 --> 00:12:14,790
own little program to do whatever you

280
00:12:14,790 --> 00:12:17,250
want but to actually make it easier to

281
00:12:17,250 --> 00:12:19,140
do interpreters which is kind of the

282
00:12:19,140 --> 00:12:20,760
focus of what we're looking at we've

283
00:12:20,760 --> 00:12:22,380
gone a step further and created this

284
00:12:22,380 --> 00:12:24,840
bytecode builder or opcode builder

285
00:12:24,840 --> 00:12:26,940
depending on your run time which allows

286
00:12:26,940 --> 00:12:30,150
you to do it handles a lot more of the

287
00:12:30,150 --> 00:12:32,760
flow for you because if you look at some

288
00:12:32,760 --> 00:12:34,530
byte codes like jumps and go twos they

289
00:12:34,530 --> 00:12:37,110
actually can sometime fall through or go

290
00:12:37,110 --> 00:12:40,080
somewhere else so to actually keep the

291
00:12:40,080 --> 00:12:41,730
il that we're generating a lot cleaner

292
00:12:41,730 --> 00:12:43,170
and make it a lot easier for the JIT to

293
00:12:43,170 --> 00:12:44,970
optimize we've gone and added this so

294
00:12:44,970 --> 00:12:47,280
that we can give hints at least how the

295
00:12:47,280 --> 00:12:50,370
control flow is going to happen there's

296
00:12:50,370 --> 00:12:52,740
a great talk on this that I have the

297
00:12:52,740 --> 00:12:56,300
link to here one of my co-workers

298
00:13:02,790 --> 00:13:08,160
so Lua vermelha my coworker created it

299
00:13:08,160 --> 00:13:10,410
the name I don't actually know where he

300
00:13:10,410 --> 00:13:13,529
got it from that's what's on there so we

301
00:13:13,529 --> 00:13:17,990
started working on this in about January

302
00:13:17,990 --> 00:13:20,490
so it's there it's on github it's under

303
00:13:20,490 --> 00:13:22,260
his right now we're not sure if we would

304
00:13:22,260 --> 00:13:23,760
ever move it anywhere else if anybody

305
00:13:23,760 --> 00:13:26,279
cares but so that's the link for it and

306
00:13:26,279 --> 00:13:28,769
we're basically the main goal is to

307
00:13:28,769 --> 00:13:33,060
actually just integrate it into the Lua

308
00:13:33,060 --> 00:13:36,029
VM with as minimal changes as possible

309
00:13:36,029 --> 00:13:39,329
at this point we're at only about 30

310
00:13:39,329 --> 00:13:40,860
lines of code I believe it'll be on a

311
00:13:40,860 --> 00:13:43,589
slide later of changes to actually be

312
00:13:43,589 --> 00:13:54,389
able to use the JIT so the JIT builder

313
00:13:54,389 --> 00:13:57,570
design that we decided to do for Lua was

314
00:13:57,570 --> 00:13:59,339
we're going to do we do all of the

315
00:13:59,339 --> 00:14:01,560
compilation synchronously we could have

316
00:14:01,560 --> 00:14:02,970
another thread or something to go do

317
00:14:02,970 --> 00:14:04,980
some asynchronous but which is probably

318
00:14:04,980 --> 00:14:07,529
a future but for now we just do it

319
00:14:07,529 --> 00:14:10,110
synchronously after so many executions

320
00:14:10,110 --> 00:14:13,620
of the method I don't remember the

321
00:14:13,620 --> 00:14:15,060
number offhand but I believe it's 10 or

322
00:14:15,060 --> 00:14:16,019
something right now after you've

323
00:14:16,019 --> 00:14:17,730
executed something 10 times you will go

324
00:14:17,730 --> 00:14:20,250
and get it and then from then on you'll

325
00:14:20,250 --> 00:14:23,760
execute the JUnit version so the major

326
00:14:23,760 --> 00:14:27,029
change to the interpreter was in do call

327
00:14:27,029 --> 00:14:30,899
I in the interpreter so basically if you

328
00:14:30,899 --> 00:14:32,519
get to the point where you're going to

329
00:14:32,519 --> 00:14:35,100
call a function when you want to get the

330
00:14:35,100 --> 00:14:37,170
prototype if it has a compile code you

331
00:14:37,170 --> 00:14:39,660
just call that directly or you just let

332
00:14:39,660 --> 00:14:42,870
the interpreter continue going we keep

333
00:14:42,870 --> 00:14:45,500
the Luas state and call info up-to-date

334
00:14:45,500 --> 00:14:50,339
everywhere this allows us to fall back

335
00:14:50,339 --> 00:14:52,370
to the interpreter at any point we want

336
00:14:52,370 --> 00:14:57,660
it causes a bit of paralysis Li at times

337
00:14:57,660 --> 00:15:00,480
but for now right now the whole ideas

338
00:15:00,480 --> 00:15:01,889
will just keep the completely up-to-date

339
00:15:01,889 --> 00:15:04,139
and at any point we make a decision or

340
00:15:04,139 --> 00:15:07,199
we see something that goes against our

341
00:15:07,199 --> 00:15:08,370
decisions we made in the past we just

342
00:15:08,370 --> 00:15:11,250
fall back to the interpreter and that's

343
00:15:11,250 --> 00:15:13,170
we let the interpreter handle all the

344
00:15:13,170 --> 00:15:16,370
complicated cases right now

345
00:15:17,630 --> 00:15:25,800
so the Lua a function builder method

346
00:15:25,800 --> 00:15:28,050
will look pretty similar to the basic

347
00:15:28,050 --> 00:15:30,330
one I showed before but really the the

348
00:15:30,330 --> 00:15:32,100
main thing we take in for parameter is

349
00:15:32,100 --> 00:15:34,410
the prototype so in the lieu of VM

350
00:15:34,410 --> 00:15:36,180
anytime you have a function that you're

351
00:15:36,180 --> 00:15:38,940
going to call there is a prototype this

352
00:15:38,940 --> 00:15:40,710
proto struct and we use that to actually

353
00:15:40,710 --> 00:15:42,810
go and generate all of our code because

354
00:15:42,810 --> 00:15:44,400
that has a pointer to your op though

355
00:15:44,400 --> 00:15:47,520
your array of off codes and all of those

356
00:15:47,520 --> 00:15:52,230
things so build il for it the first

357
00:15:52,230 --> 00:15:56,010
thing I do is this code is not complete

358
00:15:56,010 --> 00:15:58,740
I would not fit on one page be multiple

359
00:15:58,740 --> 00:16:00,360
pages so I just have some quick examples

360
00:16:00,360 --> 00:16:02,940
of what the code looks like let's the

361
00:16:02,940 --> 00:16:04,260
create the bytecode builder so that we

362
00:16:04,260 --> 00:16:08,580
could go and generate all the code the

363
00:16:08,580 --> 00:16:10,230
first thing we need to do is so this

364
00:16:10,230 --> 00:16:12,210
kind of looked very similar to the top

365
00:16:12,210 --> 00:16:14,550
of the bytecode loop and the interpreter

366
00:16:14,550 --> 00:16:17,880
so you go fetch the call info off of the

367
00:16:17,880 --> 00:16:22,200
Luas state then you fetch base which is

368
00:16:22,200 --> 00:16:24,300
the base for where all the registers are

369
00:16:24,300 --> 00:16:28,110
that are going to be used and then you

370
00:16:28,110 --> 00:16:30,720
fetch the next install of the

371
00:16:30,720 --> 00:16:34,410
instructions for the code and then you

372
00:16:34,410 --> 00:16:36,660
switch on the code and handle the

373
00:16:36,660 --> 00:16:39,150
appropriate ones so this looks a lot

374
00:16:39,150 --> 00:16:42,270
like the the interpreter itself so if we

375
00:16:42,270 --> 00:16:43,620
really wanted to be crazy we could

376
00:16:43,620 --> 00:16:45,450
actually go and macro up the interpreter

377
00:16:45,450 --> 00:16:47,339
itself so that it could the code could

378
00:16:47,339 --> 00:16:49,320
actually be shared but that really

379
00:16:49,320 --> 00:16:50,850
complicates the code on the interpreter

380
00:16:50,850 --> 00:16:53,040
side for normal reason having this loop

381
00:16:53,040 --> 00:16:55,490
over here as well doesn't hurt anything

382
00:16:55,490 --> 00:17:00,180
so we've opted to do that so that was do

383
00:17:00,180 --> 00:17:02,580
move on the screen it's not gonna go so

384
00:17:02,580 --> 00:17:04,349
this is basically the code from the

385
00:17:04,349 --> 00:17:06,599
interpreter for it to move it copies the

386
00:17:06,599 --> 00:17:11,160
value from register RB into are a very

387
00:17:11,160 --> 00:17:14,640
straightforward so the JIT builder

388
00:17:14,640 --> 00:17:16,980
version of do move so the first thing

389
00:17:16,980 --> 00:17:19,709
I'm gonna do is get RA so I'm gonna go

390
00:17:19,709 --> 00:17:24,140
load that guy and then I'm going to get

391
00:17:24,140 --> 00:17:28,470
B so our a we know that basically every

392
00:17:28,470 --> 00:17:28,880
op

393
00:17:28,880 --> 00:17:32,360
uses the RA register so we load that all

394
00:17:32,360 --> 00:17:34,640
the time in the main loop it's always up

395
00:17:34,640 --> 00:17:36,620
to date so but here I'm gonna go we have

396
00:17:36,620 --> 00:17:38,180
another convenience helper just for

397
00:17:38,180 --> 00:17:39,890
going and fetching the instruction the

398
00:17:39,890 --> 00:17:44,270
RB for us so call that and then it's

399
00:17:44,270 --> 00:17:46,100
basically the same thing we have a

400
00:17:46,100 --> 00:17:49,400
helper for set object which is down

401
00:17:49,400 --> 00:17:51,410
below here where we just fetched value

402
00:17:51,410 --> 00:17:54,170
and type out of the source object and

403
00:17:54,170 --> 00:17:59,290
store them into the destination object

404
00:18:00,010 --> 00:18:04,040
so that would be generating complete il

405
00:18:04,040 --> 00:18:07,340
for that function but to start off and

406
00:18:07,340 --> 00:18:09,320
that's the very first thing we did is we

407
00:18:09,320 --> 00:18:11,390
actually didn't implement il for any of

408
00:18:11,390 --> 00:18:12,980
the methods to start out we actually

409
00:18:12,980 --> 00:18:14,720
just went and basically took the

410
00:18:14,720 --> 00:18:16,910
interpreter and created little C

411
00:18:16,910 --> 00:18:18,620
functions for every piece of code that

412
00:18:18,620 --> 00:18:21,290
was in there and that way and that

413
00:18:21,290 --> 00:18:24,110
actually kept us in very honest and

414
00:18:24,110 --> 00:18:25,580
making sure we do keep the state and

415
00:18:25,580 --> 00:18:26,510
everything up-to-date all the time

416
00:18:26,510 --> 00:18:27,950
because we were actually just relying on

417
00:18:27,950 --> 00:18:30,860
the helpers for everything but this is

418
00:18:30,860 --> 00:18:32,390
an example of one we haven't gone back

419
00:18:32,390 --> 00:18:34,940
and actually generated the il for it in

420
00:18:34,940 --> 00:18:39,740
particular so but of the and one so all

421
00:18:39,740 --> 00:18:42,170
basically we have is a function that we

422
00:18:42,170 --> 00:18:44,510
call for this one so you have a bunch of

423
00:18:44,510 --> 00:18:45,830
the code happening in line and then you

424
00:18:45,830 --> 00:18:47,780
see a call out to some C function and

425
00:18:47,780 --> 00:18:50,300
then continue exiting in the JIT it's

426
00:18:50,300 --> 00:18:51,950
not falling back the interpreter this is

427
00:18:51,950 --> 00:18:55,160
a helper that we've created so the VM

428
00:18:55,160 --> 00:19:01,250
band and if we make a call because we

429
00:19:01,250 --> 00:19:03,950
have base stored in a local for us we

430
00:19:03,950 --> 00:19:05,870
always make our helpers return base in

431
00:19:05,870 --> 00:19:07,280
case the stack happened to grow or

432
00:19:07,280 --> 00:19:10,220
something again too pessimistic at this

433
00:19:10,220 --> 00:19:11,720
point we could be more clever but we

434
00:19:11,720 --> 00:19:13,310
just always do it for now because we

435
00:19:13,310 --> 00:19:15,380
don't have the expectations we won't be

436
00:19:15,380 --> 00:19:17,060
call these helpers very often because

437
00:19:17,060 --> 00:19:18,740
we'll finish implementing the code for

438
00:19:18,740 --> 00:19:21,280
the rest of them

439
00:19:28,140 --> 00:19:30,899
the CI and stuff again but the code is

440
00:19:30,899 --> 00:19:34,500
basically identical and this is just for

441
00:19:34,500 --> 00:19:36,299
us to be able to do helpers quickly to

442
00:19:36,299 --> 00:19:38,909
make progress and be able to show some

443
00:19:38,909 --> 00:19:43,500
performance improvements later so this

444
00:19:43,500 --> 00:19:46,740
one is basically the meat of the entire

445
00:19:46,740 --> 00:19:49,470
change to the interpreter so basically

446
00:19:49,470 --> 00:19:52,049
this is exactly what we changed other

447
00:19:52,049 --> 00:19:53,669
than adding a few fields to the

448
00:19:53,669 --> 00:19:55,649
prototype structure itself and setting

449
00:19:55,649 --> 00:19:59,429
those up this is basically the code so

450
00:19:59,429 --> 00:20:01,080
once you're decided you're actually

451
00:20:01,080 --> 00:20:04,380
going to call a lua function we check to

452
00:20:04,380 --> 00:20:06,929
see if it's already been jetted or a

453
00:20:06,929 --> 00:20:09,450
block list is to say we can't hit it oh

454
00:20:09,450 --> 00:20:11,460
yeah one thing that I don't have on the

455
00:20:11,460 --> 00:20:12,570
slide just we've actually created a

456
00:20:12,570 --> 00:20:15,570
helper our own little extension for Lua

457
00:20:15,570 --> 00:20:17,340
to be able to actually completely direct

458
00:20:17,340 --> 00:20:18,870
if you want to go have a method a

459
00:20:18,870 --> 00:20:21,419
function compiled you can just stay as

460
00:20:21,419 --> 00:20:23,760
long as you import the right library you

461
00:20:23,760 --> 00:20:25,470
can just go say compile this method that

462
00:20:25,470 --> 00:20:27,690
that meant we then created this black

463
00:20:27,690 --> 00:20:29,429
and white list as well so that you could

464
00:20:29,429 --> 00:20:31,710
say never to compile something for our

465
00:20:31,710 --> 00:20:33,779
testing so that's the quick check if

466
00:20:33,779 --> 00:20:36,000
it's not blacklisted and the counter is

467
00:20:36,000 --> 00:20:38,220
at zero and you've never compiled it go

468
00:20:38,220 --> 00:20:39,870
compile and then blacklist it so it

469
00:20:39,870 --> 00:20:45,720
won't be compiled again then if if not

470
00:20:45,720 --> 00:20:48,630
if it is compiled go just execute that

471
00:20:48,630 --> 00:20:52,200
compile code and if not decrement the

472
00:20:52,200 --> 00:20:56,250
counter the good part is of the way that

473
00:20:56,250 --> 00:20:59,250
Lua VM actually works here is you would

474
00:20:59,250 --> 00:21:01,350
have just set up the state for the call

475
00:21:01,350 --> 00:21:03,450
so when we come back we actually don't

476
00:21:03,450 --> 00:21:05,250
have to do anything fancy because we'll

477
00:21:05,250 --> 00:21:06,990
have setup for the next call the

478
00:21:06,990 --> 00:21:08,370
interpreter loop will just jump back to

479
00:21:08,370 --> 00:21:09,899
the beginning load all of the right

480
00:21:09,899 --> 00:21:12,120
things and keep going or load the stuff

481
00:21:12,120 --> 00:21:18,360
for this current one so performance we

482
00:21:18,360 --> 00:21:20,010
added a JIT you would expect some

483
00:21:20,010 --> 00:21:23,279
performance if you've been familiar with

484
00:21:23,279 --> 00:21:26,340
the Lua JIT this performance numbers are

485
00:21:26,340 --> 00:21:27,960
not going to look anywhere as good yet

486
00:21:27,960 --> 00:21:32,360
but very quickly for some things like

487
00:21:32,360 --> 00:21:35,429
fib and Mandelbrot and very quickly like

488
00:21:35,429 --> 00:21:38,850
a two to two point something X

489
00:21:38,850 --> 00:21:42,060
performance improvement so basically we

490
00:21:42,060 --> 00:21:44,880
did very minimal changes the interpreter

491
00:21:44,880 --> 00:21:47,100
and very quickly you can see over 2x

492
00:21:47,100 --> 00:21:51,150
performance for a lot of these little

493
00:21:51,150 --> 00:21:55,980
simple workloads ad test is something I

494
00:21:55,980 --> 00:21:57,030
created myself it's a loop just

495
00:21:57,030 --> 00:21:59,010
basically adding a bunch of values

496
00:21:59,010 --> 00:22:01,260
together all from they would end up

497
00:22:01,260 --> 00:22:02,760
being registers I really want to test

498
00:22:02,760 --> 00:22:05,070
that through because it's mostly math

499
00:22:05,070 --> 00:22:07,110
and that we end up generating here and

500
00:22:07,110 --> 00:22:09,000
there's no calls or anything that one

501
00:22:09,000 --> 00:22:13,200
right away is 5x faster and factorial

502
00:22:13,200 --> 00:22:19,020
everyone knows what factorial is so the

503
00:22:19,020 --> 00:22:22,530
current state is there are a few opcodes

504
00:22:22,530 --> 00:22:23,730
we just haven't even create the helper

505
00:22:23,730 --> 00:22:26,040
for because we've never ran into any

506
00:22:26,040 --> 00:22:28,350
code that actually generates those so if

507
00:22:28,350 --> 00:22:31,230
you did have code that did it I think

508
00:22:31,230 --> 00:22:33,990
it's like load X K or something look

509
00:22:33,990 --> 00:22:35,550
some other one anyway that I've never

510
00:22:35,550 --> 00:22:37,200
seen it's a constant when you have more

511
00:22:37,200 --> 00:22:40,620
than 32,000 constants or something we

512
00:22:40,620 --> 00:22:42,240
haven't even bothered so if you did you

513
00:22:42,240 --> 00:22:43,980
would fail to compile and we wouldn't

514
00:22:43,980 --> 00:22:45,900
run JIT it for that one but well we'll

515
00:22:45,900 --> 00:22:49,650
do it eventually so in total we're at

516
00:22:49,650 --> 00:22:51,480
less than I guess 50 lines of code

517
00:22:51,480 --> 00:22:53,010
including the make file changes in

518
00:22:53,010 --> 00:22:57,180
everything and we only wrote less than

519
00:22:57,180 --> 00:22:59,970
2,000 lines of code to actually be able

520
00:22:59,970 --> 00:23:02,280
to do this on the JIT side so did our

521
00:23:02,280 --> 00:23:06,150
JIT flew a function builder where a ton

522
00:23:06,150 --> 00:23:08,430
of that is actually the loop the switch

523
00:23:08,430 --> 00:23:09,990
statement like that actually consumes a

524
00:23:09,990 --> 00:23:11,880
lot of the lines so it actually isn't

525
00:23:11,880 --> 00:23:17,820
very much code so some future work that

526
00:23:17,820 --> 00:23:19,890
we're going to plan and actually have a

527
00:23:19,890 --> 00:23:23,190
lot of it start it right now is we want

528
00:23:23,190 --> 00:23:25,020
to get rid of a hundred percent of our

529
00:23:25,020 --> 00:23:28,110
VM helpers for all the common paths we

530
00:23:28,110 --> 00:23:29,460
believe will still end up with some

531
00:23:29,460 --> 00:23:31,560
again because we want to let the JIT the

532
00:23:31,560 --> 00:23:33,690
interpreter handle the hard cases if

533
00:23:33,690 --> 00:23:36,810
you're trying to add a string to

534
00:23:36,810 --> 00:23:37,530
something else

535
00:23:37,530 --> 00:23:39,330
I'm not going to probably do it to begin

536
00:23:39,330 --> 00:23:40,530
with because I don't want to convert the

537
00:23:40,530 --> 00:23:42,240
string to an int or whatever to do the

538
00:23:42,240 --> 00:23:43,890
math fall back to the interpreter for

539
00:23:43,890 --> 00:23:48,840
that one whenever possible one of the

540
00:23:48,840 --> 00:23:51,060
things we've noticed in our JIT right

541
00:23:51,060 --> 00:23:53,220
now with this is I was expecting to see

542
00:23:53,220 --> 00:23:55,550
some way better perf

543
00:23:55,550 --> 00:23:57,830
on especially some of the math only like

544
00:23:57,830 --> 00:23:59,150
Mandelbrot and those things I was

545
00:23:59,150 --> 00:24:01,940
expecting way more than 2 X 4 the

546
00:24:01,940 --> 00:24:03,680
problem is is every time we go to do a

547
00:24:03,680 --> 00:24:06,200
math operation I have to check is our a

548
00:24:06,200 --> 00:24:09,860
an int or a double is our B an int or

549
00:24:09,860 --> 00:24:11,420
sorry it's B and C are they insert

550
00:24:11,420 --> 00:24:13,190
doubles or what are they doing so it

551
00:24:13,190 --> 00:24:14,540
creates all these diamonds in the code

552
00:24:14,540 --> 00:24:16,490
so the JIT has a hard job actually

553
00:24:16,490 --> 00:24:19,490
optimizing down through but very

554
00:24:19,490 --> 00:24:22,070
recently like when I was on the plane on

555
00:24:22,070 --> 00:24:24,230
the way over I was doing some work by

556
00:24:24,230 --> 00:24:26,000
actually keeping track and the

557
00:24:26,000 --> 00:24:27,740
interpreter of what the types were when

558
00:24:27,740 --> 00:24:30,470
they were called and if I do that then I

559
00:24:30,470 --> 00:24:32,090
can actually assume based on the

560
00:24:32,090 --> 00:24:33,440
instructions that are taking place like

561
00:24:33,440 --> 00:24:35,510
if you do an ad of 2 int it's always an

562
00:24:35,510 --> 00:24:37,760
int so I can always know the type if

563
00:24:37,760 --> 00:24:40,310
what the result would be if I start

564
00:24:40,310 --> 00:24:41,120
doing things like that

565
00:24:41,120 --> 00:24:43,550
I can see some very significant

566
00:24:43,550 --> 00:24:45,410
improvements like Mandelbrot's like 10

567
00:24:45,410 --> 00:24:48,500
to 15 X faster it was just where in the

568
00:24:48,500 --> 00:24:50,030
ballpark I really want it to be in a

569
00:24:50,030 --> 00:24:53,200
bunch of these things so that work is

570
00:24:53,200 --> 00:24:56,090
sort of in my laptop right now and not

571
00:24:56,090 --> 00:24:58,520
in any state to show anybody so I don't

572
00:24:58,520 --> 00:24:59,510
want to talk about those numbers but

573
00:24:59,510 --> 00:25:01,400
that's something that we want to do and

574
00:25:01,400 --> 00:25:03,650
keep going with that to actually be able

575
00:25:03,650 --> 00:25:06,230
to do it and the good part is is if we

576
00:25:06,230 --> 00:25:08,450
do it based on the input parameters at

577
00:25:08,450 --> 00:25:10,940
any point if they actually were not the

578
00:25:10,940 --> 00:25:12,110
right type we just fall back to the

579
00:25:12,110 --> 00:25:13,850
interpreter and keep going you would

580
00:25:13,850 --> 00:25:16,760
have a big PerR floss if you called them

581
00:25:16,760 --> 00:25:18,500
in opposite order all the time like if

582
00:25:18,500 --> 00:25:20,180
you pass it in in now then float then

583
00:25:20,180 --> 00:25:25,820
int but we also quickly hacked in that

584
00:25:25,820 --> 00:25:28,460
if you ever fall back more than n times

585
00:25:28,460 --> 00:25:29,720
from the interpreter we could actually

586
00:25:29,720 --> 00:25:32,480
go back and read it without the other

587
00:25:32,480 --> 00:25:34,160
information so that then you could

588
00:25:34,160 --> 00:25:36,410
handle the you would do the checks in

589
00:25:36,410 --> 00:25:38,210
the jet but you would do more because

590
00:25:38,210 --> 00:25:44,270
still get the two to three X perf so to

591
00:25:44,270 --> 00:25:47,990
quickly wrap up just to cover again our

592
00:25:47,990 --> 00:25:49,790
mission for ole Mars to kind of make

593
00:25:49,790 --> 00:25:51,290
this toolkit available for these other

594
00:25:51,290 --> 00:25:54,890
runtimes we really don't want to create

595
00:25:54,890 --> 00:25:57,440
a new community we don't want to do

596
00:25:57,440 --> 00:25:58,970
anything to harm any Cudas we actually

597
00:25:58,970 --> 00:26:00,110
are just trying to make these available

598
00:26:00,110 --> 00:26:01,640
so that they can work with the

599
00:26:01,640 --> 00:26:03,410
communities that are already there a lot

600
00:26:03,410 --> 00:26:04,850
of these languages have very large

601
00:26:04,850 --> 00:26:08,210
communities so we're hoping that we can

602
00:26:08,210 --> 00:26:09,410
work with them

603
00:26:09,410 --> 00:26:12,070
and not saying our texts the best

604
00:26:12,070 --> 00:26:14,030
actually the more people to use it we

605
00:26:14,030 --> 00:26:15,350
may actually get some improvements

606
00:26:15,350 --> 00:26:16,700
ourselves by having some of the other

607
00:26:16,700 --> 00:26:18,680
smart people working on these things

608
00:26:18,680 --> 00:26:22,220
provide stuff back to us

609
00:26:22,220 --> 00:26:25,730
check out the our lua vm at from the

610
00:26:25,730 --> 00:26:27,440
link if you want give it a compile use

611
00:26:27,440 --> 00:26:30,740
it it should be fairly stable we test a

612
00:26:30,740 --> 00:26:35,180
lot before we commit anything and again

613
00:26:35,180 --> 00:26:37,130
that's just my quick contact information

614
00:26:37,130 --> 00:26:41,260
and the link again here to the Lu of VM

615
00:26:41,260 --> 00:26:45,050
that's it any questions I don't have a

616
00:26:45,050 --> 00:26:49,040
question side start I'll go left to

617
00:26:49,040 --> 00:26:55,990
right back here yep

618
00:26:57,520 --> 00:27:00,950
so on disk footprint right now we've

619
00:27:00,950 --> 00:27:06,230
increased I want to say it's a couple of

620
00:27:06,230 --> 00:27:07,880
megabytes that we've increased I'd I can

621
00:27:07,880 --> 00:27:18,140
get the actual number it's not 200k yes

622
00:27:18,140 --> 00:27:39,140
and we're like yes it still works so we

623
00:27:39,140 --> 00:27:40,580
actually when we create the structures

624
00:27:40,580 --> 00:27:42,110
that we do all of those things based on

625
00:27:42,110 --> 00:27:44,090
we actually are doing it based on

626
00:27:44,090 --> 00:27:46,730
whatever the size of Lu and um lower

627
00:27:46,730 --> 00:27:48,500
integer and all of those things for the

628
00:27:48,500 --> 00:27:50,300
what we've tested it all seems to be

629
00:27:50,300 --> 00:27:59,810
working that way in going yep exactly

630
00:27:59,810 --> 00:28:01,580
and then we would never have to jump

631
00:28:01,580 --> 00:28:03,710
back exactly we're starting to put some

632
00:28:03,710 --> 00:28:05,360
of those checks in as well as we keep

633
00:28:05,360 --> 00:28:06,950
going but for now we just bail on

634
00:28:06,950 --> 00:28:11,860
everything we don't recognize here

635
00:28:34,179 --> 00:28:38,450
okay sorry so the first question was are

636
00:28:38,450 --> 00:28:39,529
we planning on using this for any other

637
00:28:39,529 --> 00:28:42,259
languages and the second question was do

638
00:28:42,259 --> 00:28:44,359
we believe we can get anywhere close to

639
00:28:44,359 --> 00:28:47,899
the Luigi it's performance I believe you

640
00:28:47,899 --> 00:28:52,070
said Mike Paul's the guy's name so the

641
00:28:52,070 --> 00:28:53,299
first one yes

642
00:28:53,299 --> 00:28:56,659
so we've I've got another small language

643
00:28:56,659 --> 00:28:59,320
that I've implemented this for that is

644
00:28:59,320 --> 00:29:01,339
not really use anywhere it's a small

645
00:29:01,339 --> 00:29:03,200
talk derivative again that was just our

646
00:29:03,200 --> 00:29:05,599
first prototype of it we are doing this

647
00:29:05,599 --> 00:29:09,200
for Ruby MRI as well not using chip

648
00:29:09,200 --> 00:29:11,539
builder but the G ed itself directly

649
00:29:11,539 --> 00:29:13,429
we've had people present at the last two

650
00:29:13,429 --> 00:29:16,940
Ruby cockys for that that's making slow

651
00:29:16,940 --> 00:29:17,419
progress

652
00:29:17,419 --> 00:29:19,339
Ruby's actually very difficult because

653
00:29:19,339 --> 00:29:22,129
all of their four MRI all of the class

654
00:29:22,129 --> 00:29:23,690
libraries are written in C so it's very

655
00:29:23,690 --> 00:29:25,399
hard for us to see through it you have

656
00:29:25,399 --> 00:29:26,869
to actually write a bunch of the code in

657
00:29:26,869 --> 00:29:31,190
Ruby to make it easier but it's used in

658
00:29:31,190 --> 00:29:34,429
our ji BM Java VM this is actually 100%

659
00:29:34,429 --> 00:29:36,499
consumed back into our builds every day

660
00:29:36,499 --> 00:29:39,440
for Java and we're looking at a few

661
00:29:39,440 --> 00:29:42,440
other things at this point but nothing

662
00:29:42,440 --> 00:29:44,889
concrete enough to bother talking about

663
00:29:44,889 --> 00:29:51,019
and the performance I don't know I'd not

664
00:29:51,019 --> 00:29:52,789
have to compute more comparisons I saw

665
00:29:52,789 --> 00:29:55,219
quickly his chart on the perf for a

666
00:29:55,219 --> 00:29:57,200
bunch of things lots of things were in

667
00:29:57,200 --> 00:30:01,059
the 10 to 40 X that's completely doable

668
00:30:01,059 --> 00:30:03,619
depending on what we can do here but

669
00:30:03,619 --> 00:30:05,659
then maybe I missed some maybe he's got

670
00:30:05,659 --> 00:30:12,169
300 X on some things I didn't see this

671
00:30:12,169 --> 00:30:14,809
yeah so for a lot of these things I'm 2

672
00:30:14,809 --> 00:30:17,389
to 5 X faster than the interpreter by

673
00:30:17,389 --> 00:30:18,859
itself but I haven't done any direct

674
00:30:18,859 --> 00:30:22,810
comparisons to the lua cheia itself

675
00:30:22,810 --> 00:30:27,669
yes Lulla Lulla interpreter

