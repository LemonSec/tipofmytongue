1
00:00:06,240 --> 00:00:09,370
okay so uh my name is Alan Jude and I'm

2
00:00:09,370 --> 00:00:11,340
going to speak about deli boot which is

3
00:00:11,340 --> 00:00:13,629
booting from a fully encrypted disk on

4
00:00:13,629 --> 00:00:16,200
FreeBSD

5
00:00:26,620 --> 00:00:30,080
yeah so I've been a FreeBSD server admin

6
00:00:30,080 --> 00:00:31,280
for about 13 years

7
00:00:31,280 --> 00:00:33,800
and over the last couple of years have

8
00:00:33,800 --> 00:00:35,570
become a FreeBSD document and then a

9
00:00:35,570 --> 00:00:36,950
source committer and then a member of

10
00:00:36,950 --> 00:00:38,260
the FreeBSD core team

11
00:00:38,260 --> 00:00:40,520
I've also co-authored two books

12
00:00:40,520 --> 00:00:43,640
previously masteries NFS and previously

13
00:00:43,640 --> 00:00:45,739
mastery advanced set of s with Michael W

14
00:00:45,739 --> 00:00:51,020
Lucas and my day job I run a video

15
00:00:51,020 --> 00:00:52,580
streaming company called scale engine

16
00:00:52,580 --> 00:00:56,360
and I host the BSD now podcast and until

17
00:00:56,360 --> 00:01:01,550
recently hosted the Texan a podcast so I

18
00:01:01,550 --> 00:01:05,360
do a lot of work with ZFS in particular

19
00:01:05,360 --> 00:01:07,400
of helped build those NFS bits in the

20
00:01:07,400 --> 00:01:09,440
freebsd installer so that you can more

21
00:01:09,440 --> 00:01:11,409
easily create a ZFS based system and

22
00:01:11,409 --> 00:01:14,150
then I did work to integrate boot

23
00:01:14,150 --> 00:01:16,159
environments the Solaris concept of

24
00:01:16,159 --> 00:01:19,820
having basically a clone of your root

25
00:01:19,820 --> 00:01:22,970
filesystem before you make an upgrade or

26
00:01:22,970 --> 00:01:25,670
a change so that if it doesn't work you

27
00:01:25,670 --> 00:01:28,340
can boot back to your base system how it

28
00:01:28,340 --> 00:01:30,590
was before but your other file systems

29
00:01:30,590 --> 00:01:32,630
like your home directory and bar logs

30
00:01:32,630 --> 00:01:35,900
that are not disturbed so you know when

31
00:01:35,900 --> 00:01:37,760
you roll back the system image you don't

32
00:01:37,760 --> 00:01:38,870
roll back what was in your home

33
00:01:38,870 --> 00:01:42,440
directory so once we had that I

34
00:01:42,440 --> 00:01:45,440
integrated into the boot loader so that

35
00:01:45,440 --> 00:01:47,090
at boot time you could select this

36
00:01:47,090 --> 00:01:49,490
alternate boot environment because the

37
00:01:49,490 --> 00:01:51,260
most likely case when you would want to

38
00:01:51,260 --> 00:01:53,420
use a different boot environment is when

39
00:01:53,420 --> 00:01:57,620
the current one doesn't work so that

40
00:01:57,620 --> 00:01:59,900
worked the problem was if you used

41
00:01:59,900 --> 00:02:01,640
previously x' disk encryption system

42
00:02:01,640 --> 00:02:04,010
called gely which is a block level disk

43
00:02:04,010 --> 00:02:07,280
encryption which you use so you used you

44
00:02:07,280 --> 00:02:10,190
take your raw disk you put jelly on top

45
00:02:10,190 --> 00:02:11,810
of it and anything you'd write to it

46
00:02:11,810 --> 00:02:13,519
that gets encrypted and then you can put

47
00:02:13,519 --> 00:02:16,069
a ZFS pool on top of that the problem

48
00:02:16,069 --> 00:02:18,860
with that is that instead of its boot

49
00:02:18,860 --> 00:02:22,819
environments depend on the kernel and

50
00:02:22,819 --> 00:02:24,709
the root filesystem being the same file

51
00:02:24,709 --> 00:02:26,989
system but if you want to boot from an

52
00:02:26,989 --> 00:02:28,849
encrypted disk traditionally what you've

53
00:02:28,849 --> 00:02:30,470
done has had a small slash boot

54
00:02:30,470 --> 00:02:32,599
partition somewhere that had your kernel

55
00:02:32,599 --> 00:02:36,019
the loader and your modules that was not

56
00:02:36,019 --> 00:02:36,860
encrypted

57
00:02:36,860 --> 00:02:38,150
and then the rest of your file systems

58
00:02:38,150 --> 00:02:41,090
are encrypted and that way the

59
00:02:41,090 --> 00:02:42,740
bootloader could load the kernel load

60
00:02:42,740 --> 00:02:44,180
the module that provides the disk

61
00:02:44,180 --> 00:02:46,160
encryption and then mount the root

62
00:02:46,160 --> 00:02:47,410
filesystem

63
00:02:47,410 --> 00:02:51,890
but having that two separate file system

64
00:02:51,890 --> 00:02:54,260
layout me makes boot environments not

65
00:02:54,260 --> 00:02:56,810
work because you can't have you need to

66
00:02:56,810 --> 00:02:58,040
have your kernel be in sync with your

67
00:02:58,040 --> 00:03:02,600
root filesystem so I devised what's

68
00:03:02,600 --> 00:03:04,520
called gely boot which is a system where

69
00:03:04,520 --> 00:03:07,130
the lower-level boot strap that loads

70
00:03:07,130 --> 00:03:09,530
before the bootloader could actually

71
00:03:09,530 --> 00:03:11,150
understand the disk encryption to be

72
00:03:11,150 --> 00:03:12,620
able to load the bootloader from the

73
00:03:12,620 --> 00:03:18,170
encrypted disk so especially when I

74
00:03:18,170 --> 00:03:20,420
started this I was very novice C

75
00:03:20,420 --> 00:03:24,080
programmer you know I had written one

76
00:03:24,080 --> 00:03:27,050
other tool before and that was I like to

77
00:03:27,050 --> 00:03:28,940
do shell script and I wanted to use this

78
00:03:28,940 --> 00:03:31,040
new library FreeBSD had called lib you

79
00:03:31,040 --> 00:03:34,940
see L which is a config file parser that

80
00:03:34,940 --> 00:03:37,700
also sports JSON and I wanted to use it

81
00:03:37,700 --> 00:03:39,290
for my shell script so I wrote a little

82
00:03:39,290 --> 00:03:42,560
C program that would allow me to use the

83
00:03:42,560 --> 00:03:44,060
functions of this library from my shell

84
00:03:44,060 --> 00:03:48,110
script and that was about all the

85
00:03:48,110 --> 00:03:50,930
experience that I really had so I

86
00:03:50,930 --> 00:03:54,620
attempted to build this thinking it

87
00:03:54,620 --> 00:03:57,260
can't be that hard right it's only the

88
00:03:57,260 --> 00:04:02,209
bootloader so I implemented a very

89
00:04:02,209 --> 00:04:04,549
minimalistic version of jelly which is

90
00:04:04,549 --> 00:04:09,430
the previous T disk encryption subsystem

91
00:04:09,430 --> 00:04:12,950
for the two different boot codes are so

92
00:04:12,950 --> 00:04:14,540
there's GPT boot which allows you to

93
00:04:14,540 --> 00:04:17,630
boot you FS and GPT set FS boot which

94
00:04:17,630 --> 00:04:21,680
can boot set if s so I spent a lot of

95
00:04:21,680 --> 00:04:23,840
time just understanding what was already

96
00:04:23,840 --> 00:04:25,280
happening in the existing boot code

97
00:04:25,280 --> 00:04:28,610
before I tried to modify it and working

98
00:04:28,610 --> 00:04:30,950
with that and I had to learn a lot about

99
00:04:30,950 --> 00:04:32,660
C because I really didn't know what I

100
00:04:32,660 --> 00:04:35,360
was doing and it didn't help that all

101
00:04:35,360 --> 00:04:38,510
the existing boot code is terrible it's

102
00:04:38,510 --> 00:04:40,970
all clutch that's built up over the

103
00:04:40,970 --> 00:04:42,500
years and as soon as it starts working

104
00:04:42,500 --> 00:04:44,110
everybody stops wanting to play with it

105
00:04:44,110 --> 00:04:48,289
it's like it works now nobody touch it

106
00:04:48,289 --> 00:04:50,030
and

107
00:04:50,030 --> 00:04:53,330
and you know support for GPT the more

108
00:04:53,330 --> 00:04:54,950
advanced partitioning layout was kind of

109
00:04:54,950 --> 00:04:57,770
grafted on and then it's like nope don't

110
00:04:57,770 --> 00:04:59,440
touch it

111
00:04:59,440 --> 00:05:02,030
but so I had to navigate through quite a

112
00:05:02,030 --> 00:05:04,940
few obstacles and just to figure out

113
00:05:04,940 --> 00:05:08,300
what was what because there are four

114
00:05:08,300 --> 00:05:10,550
different sets of boot code and most of

115
00:05:10,550 --> 00:05:11,990
the code is copy pasted but there are

116
00:05:11,990 --> 00:05:14,300
subtle differences there are enough

117
00:05:14,300 --> 00:05:15,770
differences that you can't just gift the

118
00:05:15,770 --> 00:05:18,800
files to see what's happening but you

119
00:05:18,800 --> 00:05:21,160
know not so few differences that you can

120
00:05:21,160 --> 00:05:23,540
you know a lot of the code looks the

121
00:05:23,540 --> 00:05:28,820
same so give a little background before

122
00:05:28,820 --> 00:05:32,000
we dig into what actually I wrote the

123
00:05:32,000 --> 00:05:34,160
code for I thought we'd cover a little

124
00:05:34,160 --> 00:05:36,710
bit on how a computer actually boots

125
00:05:36,710 --> 00:05:40,280
this is being like an AI 386 x86 type

126
00:05:40,280 --> 00:05:42,890
computer so when you power up your

127
00:05:42,890 --> 00:05:44,540
computer and after the BIOS does its

128
00:05:44,540 --> 00:05:46,640
post and Rob's all the drives and that

129
00:05:46,640 --> 00:05:50,270
type of thing it reads the BIOS reads

130
00:05:50,270 --> 00:05:52,310
the first 512 bytes of your hard drive

131
00:05:52,310 --> 00:05:55,370
which is your Master Boot Record and

132
00:05:55,370 --> 00:05:58,820
that consists of 446 byte bootstrap

133
00:05:58,820 --> 00:06:03,110
program written in assembly and then the

134
00:06:03,110 --> 00:06:06,380
remaining 64 bytes are so there give you

135
00:06:06,380 --> 00:06:09,800
a partition table where you can have up

136
00:06:09,800 --> 00:06:13,190
to four partitions that's MBR so that

137
00:06:13,190 --> 00:06:14,660
bootstrap is then executed and that

138
00:06:14,660 --> 00:06:17,030
bootstrap the sort in the source tree

139
00:06:17,030 --> 00:06:19,220
you'll find it as Boot zero that s so

140
00:06:19,220 --> 00:06:21,770
it's called boot zero and what that does

141
00:06:21,770 --> 00:06:24,950
is it examines that partition table and

142
00:06:24,950 --> 00:06:26,870
in the case of MBR finds which of those

143
00:06:26,870 --> 00:06:29,120
four partitions has the active flag set

144
00:06:29,120 --> 00:06:33,979
and then inside that partition you will

145
00:06:33,979 --> 00:06:37,370
find the volume boot record or VBR so it

146
00:06:37,370 --> 00:06:39,500
reads the first 512 bytes of whichever

147
00:06:39,500 --> 00:06:42,070
partition is selected as active and

148
00:06:42,070 --> 00:06:44,300
loads that into memory and executes that

149
00:06:44,300 --> 00:06:47,780
program that one is called boot one in

150
00:06:47,780 --> 00:06:51,620
the circuit that 512 byte of assembly

151
00:06:51,620 --> 00:06:55,490
program then reads boot 2 which in the

152
00:06:55,490 --> 00:06:58,070
case of ufs is the first 15 sectors of

153
00:06:58,070 --> 00:07:00,320
the ufs partition which the filesystem

154
00:07:00,320 --> 00:07:02,690
just purposely doesn't ever use so that

155
00:07:02,690 --> 00:07:03,560
you can write the boot code

156
00:07:03,560 --> 00:07:08,360
in there and what the boot to contains

157
00:07:08,360 --> 00:07:11,300
is just just a minimal enough bootstrap

158
00:07:11,300 --> 00:07:13,790
of a read-only or actually readwrite

159
00:07:13,790 --> 00:07:16,700
version of you FS so all code you need

160
00:07:16,700 --> 00:07:18,200
to be able to read and write files from

161
00:07:18,200 --> 00:07:22,910
you FS fits in 15 512-byte sectors now

162
00:07:22,910 --> 00:07:25,220
that's not the whole file system it

163
00:07:25,220 --> 00:07:26,930
doesn't have all the features and do

164
00:07:26,930 --> 00:07:28,700
snapshots or anything like that but it's

165
00:07:28,700 --> 00:07:32,150
enough that you can stay hey in /boot

166
00:07:32,150 --> 00:07:35,620
give me the inode number for kernel and

167
00:07:35,620 --> 00:07:38,389
then let me read the blocks from that I

168
00:07:38,389 --> 00:07:44,840
note so once you've loaded boot - and

169
00:07:44,840 --> 00:07:46,729
now have the ability to actually read a

170
00:07:46,729 --> 00:07:49,669
ufs filesystem it loads the file / boot

171
00:07:49,669 --> 00:07:52,130
/ loader which brings up the beastie

172
00:07:52,130 --> 00:07:55,520
menu which then after you you know you

173
00:07:55,520 --> 00:07:57,400
wait for the timeout or choose an option

174
00:07:57,400 --> 00:08:00,740
then the bootloader actually reads the

175
00:08:00,740 --> 00:08:02,540
kernel using its ufs driver which is

176
00:08:02,540 --> 00:08:07,180
more advanced and then the system boots

177
00:08:07,750 --> 00:08:11,450
so if you want to do that with ZFS it

178
00:08:11,450 --> 00:08:14,390
actually turns out to be a bit evil so

179
00:08:14,390 --> 00:08:17,300
to boot is NFS from an MBR formatted

180
00:08:17,300 --> 00:08:21,410
disk the problem is that the first 15

181
00:08:21,410 --> 00:08:23,720
sectors of a ZFS partition are used by

182
00:08:23,720 --> 00:08:25,070
the Zetas mislabel so you can't just

183
00:08:25,070 --> 00:08:27,169
stick the boot code there and the boot

184
00:08:27,169 --> 00:08:29,300
codes much bigger because ZFS is kind of

185
00:08:29,300 --> 00:08:34,010
more complicated than ufs so again when

186
00:08:34,010 --> 00:08:35,630
you're booting off MBR you have that

187
00:08:35,630 --> 00:08:38,690
boot 0 which is the first 446 bytes to

188
00:08:38,690 --> 00:08:42,229
the drive which reads boot one but boot

189
00:08:42,229 --> 00:08:44,600
one is different in ZFS what it does is

190
00:08:44,600 --> 00:08:47,209
seeks into an offset in the Zetas after

191
00:08:47,209 --> 00:08:50,300
the ZFS labels in the ZFS on disk format

192
00:08:50,300 --> 00:08:52,490
they purposely left this region of three

193
00:08:52,490 --> 00:08:55,130
and a half megabytes of unused space to

194
00:08:55,130 --> 00:08:58,850
hold things like boot loaders and so in

195
00:08:58,850 --> 00:09:04,850
there you have this code that can read

196
00:09:04,850 --> 00:09:09,589
ZFS and it's originally was 64 kilobytes

197
00:09:09,589 --> 00:09:13,040
it's bigger than that now but you know

198
00:09:13,040 --> 00:09:14,839
since this 3.5 megabytes of space is

199
00:09:14,839 --> 00:09:17,450
fine but in the code it's ax

200
00:09:17,450 --> 00:09:20,030
really Pat it out to a specific size so

201
00:09:20,030 --> 00:09:24,260
that the but--one assembly code can just

202
00:09:24,260 --> 00:09:27,020
say copy this 64 or 128 kilobytes of

203
00:09:27,020 --> 00:09:29,750
data off the disk put it in memory and

204
00:09:29,750 --> 00:09:33,830
run it so that's the ZFS boot which is

205
00:09:33,830 --> 00:09:37,820
basically a boot to MIT one is has

206
00:09:37,820 --> 00:09:39,890
enough understanding of said FS to read

207
00:09:39,890 --> 00:09:41,980
only so it can import the pool

208
00:09:41,980 --> 00:09:44,360
understand raid Zed and mirrors and

209
00:09:44,360 --> 00:09:47,480
compression and all that stuff to be

210
00:09:47,480 --> 00:09:51,050
able to at your boot set of s then what

211
00:09:51,050 --> 00:09:53,930
it does is it actually reads slash boot

212
00:09:53,930 --> 00:09:56,180
such loader and calls it with an

213
00:09:56,180 --> 00:09:58,280
argument of the globally unique ID for

214
00:09:58,280 --> 00:10:00,710
that Z pool so when the loader starts up

215
00:10:00,710 --> 00:10:03,550
with its more advanced understanding of

216
00:10:03,550 --> 00:10:06,260
ZFS it knows which pool you actually

217
00:10:06,260 --> 00:10:08,480
want to boot off of because when it runs

218
00:10:08,480 --> 00:10:11,420
it's going to find all these edifice

219
00:10:11,420 --> 00:10:13,100
pools maybe there's only one maybe

220
00:10:13,100 --> 00:10:14,600
there's a bunch and it needs to know

221
00:10:14,600 --> 00:10:18,100
which one you're actually booted off of

222
00:10:18,100 --> 00:10:20,990
once it reads the loader from ZFS the

223
00:10:20,990 --> 00:10:22,790
loader presents the menu and then can

224
00:10:22,790 --> 00:10:28,730
load the kernel and you can continue but

225
00:10:28,730 --> 00:10:31,340
most of us have switched over to GPT or

226
00:10:31,340 --> 00:10:34,340
grid partition tables that biggest

227
00:10:34,340 --> 00:10:36,290
advantage is that you can have 128 or

228
00:10:36,290 --> 00:10:38,510
more partitions instead of 4 which is

229
00:10:38,510 --> 00:10:40,820
handy and more importantly you can have

230
00:10:40,820 --> 00:10:42,110
disks that are larger than 2 terabytes

231
00:10:42,110 --> 00:10:44,960
which is kind of you know pretty

232
00:10:44,960 --> 00:10:48,950
run-of-the-mill nowadays but in order to

233
00:10:48,950 --> 00:10:50,930
make sure that you know windows 98 and

234
00:10:50,930 --> 00:10:53,090
Windows XP don't offer to reformat the

235
00:10:53,090 --> 00:10:54,950
drive when they don't see a Master Boot

236
00:10:54,950 --> 00:10:56,960
Record on the beginning of the drive a

237
00:10:56,960 --> 00:11:00,310
GPT actually has as the first sector a

238
00:11:00,310 --> 00:11:03,530
protective MBR so it's a fake MBR that

239
00:11:03,530 --> 00:11:05,060
looks like it's covers the whole disk

240
00:11:05,060 --> 00:11:08,240
and it just stops legacy operating

241
00:11:08,240 --> 00:11:09,950
systems from deciding that that disk is

242
00:11:09,950 --> 00:11:15,020
empty and I can just reformat it but

243
00:11:15,020 --> 00:11:18,800
again the first 446 bytes of that are a

244
00:11:18,800 --> 00:11:20,960
little assembly program that boots the

245
00:11:20,960 --> 00:11:23,480
operating system so in the case of

246
00:11:23,480 --> 00:11:27,230
FreeBSD that p mb are instead of looking

247
00:11:27,230 --> 00:11:30,550
for the active partition and and

248
00:11:30,550 --> 00:11:32,950
seeking to a certain location instead

249
00:11:32,950 --> 00:11:35,560
what it does is it actually understands

250
00:11:35,560 --> 00:11:37,780
GPT looks to the partition table and

251
00:11:37,780 --> 00:11:40,180
finds the first partition that has the

252
00:11:40,180 --> 00:11:43,330
type of FreeBSD - boot which is

253
00:11:43,330 --> 00:11:46,060
basically just one specific grid that

254
00:11:46,060 --> 00:11:49,360
was decided to go years ago and then it

255
00:11:49,360 --> 00:11:54,130
loads all that into memory either the

256
00:11:54,130 --> 00:11:57,160
full size of the partition or 545

257
00:11:57,160 --> 00:12:00,210
kilobytes whichever is less

258
00:12:00,210 --> 00:12:02,890
the main reason for that limitation is

259
00:12:02,890 --> 00:12:07,420
that you in in this 16-bit real mode you

260
00:12:07,420 --> 00:12:09,790
can only use the first 640 kilobytes of

261
00:12:09,790 --> 00:12:11,650
memory so we don't want to load more

262
00:12:11,650 --> 00:12:16,750
than that or we'll run of memory so on a

263
00:12:16,750 --> 00:12:19,000
ufs based system this will be the GPT

264
00:12:19,000 --> 00:12:22,240
boot code or in a ZFS case that

265
00:12:22,240 --> 00:12:23,800
previously boot partition will contain

266
00:12:23,800 --> 00:12:27,850
GPT ZFS boot ah that then contains

267
00:12:27,850 --> 00:12:30,070
what's called GPT loader which is

268
00:12:30,070 --> 00:12:32,080
actually a boot one again that's a

269
00:12:32,080 --> 00:12:34,570
little 512 byte assembly program that

270
00:12:34,570 --> 00:12:37,090
just loads the next part and then the

271
00:12:37,090 --> 00:12:40,870
boot 2 is GPT boot or DVD ZFS boot which

272
00:12:40,870 --> 00:12:43,810
is again a little program that

273
00:12:43,810 --> 00:12:47,020
understands ufs oars NFS and enough to

274
00:12:47,020 --> 00:12:49,360
actually read the loader order the

275
00:12:49,360 --> 00:12:51,940
kernel off that filesystem and start the

276
00:12:51,940 --> 00:12:55,540
operating system what's interesting here

277
00:12:55,540 --> 00:12:57,730
is the GPD loader has to relocate itself

278
00:12:57,730 --> 00:13:00,430
in memory to the location in memory

279
00:13:00,430 --> 00:13:02,710
where the BIOS is going to execute the

280
00:13:02,710 --> 00:13:06,130
operating system and so to do this it

281
00:13:06,130 --> 00:13:09,520
copies itself in memory but to make sure

282
00:13:09,520 --> 00:13:10,990
that it doesn't overwrite itself it

283
00:13:10,990 --> 00:13:14,350
copies it backwards which becomes

284
00:13:14,350 --> 00:13:21,280
important later on so I was I now

285
00:13:21,280 --> 00:13:23,020
understood how the computer started up

286
00:13:23,020 --> 00:13:24,670
and where all the different pieces were

287
00:13:24,670 --> 00:13:27,010
and I wanted to now be able to boot from

288
00:13:27,010 --> 00:13:29,230
a file system that was completely

289
00:13:29,230 --> 00:13:33,280
encrypted and so normally I couldn't

290
00:13:33,280 --> 00:13:36,730
lead the loader file at this point so

291
00:13:36,730 --> 00:13:39,010
the first thing I did was find GPT ZFS

292
00:13:39,010 --> 00:13:41,920
boot and just copy that whole directory

293
00:13:41,920 --> 00:13:44,680
of source code to GPT Kelly boot

294
00:13:44,680 --> 00:13:47,620
and my idea was instead of having you

295
00:13:47,620 --> 00:13:51,790
know GPT boot for ufs and GPT ZFS boot

296
00:13:51,790 --> 00:13:54,940
for set FS and then making encrypted

297
00:13:54,940 --> 00:13:56,680
version of each of those I'd make one

298
00:13:56,680 --> 00:13:58,680
big bootloader that I can boot anything

299
00:13:58,680 --> 00:14:00,240
ah

300
00:14:00,240 --> 00:14:02,590
that's still a good idea but that's not

301
00:14:02,590 --> 00:14:05,860
what I ended up doing the first question

302
00:14:05,860 --> 00:14:08,860
was if a system has both a UF SNS

303
00:14:08,860 --> 00:14:10,660
edifice partition and your bootloader

304
00:14:10,660 --> 00:14:12,790
supports both which one should it boot

305
00:14:12,790 --> 00:14:16,390
from there wasn't really an easy way to

306
00:14:16,390 --> 00:14:18,580
answer that question so I decided that's

307
00:14:18,580 --> 00:14:22,570
for somebody else to figure so instead I

308
00:14:22,570 --> 00:14:24,850
started by implementing gely in both of

309
00:14:24,850 --> 00:14:27,400
them separately but doing it in line

310
00:14:27,400 --> 00:14:30,160
rather than having you know doubling the

311
00:14:30,160 --> 00:14:31,150
number of boot loaders that were

312
00:14:31,150 --> 00:14:32,650
available because it was already too

313
00:14:32,650 --> 00:14:40,840
many yeah so the Zen offense boot is MBR

314
00:14:40,840 --> 00:14:43,060
only and it's a fixed size so I decided

315
00:14:43,060 --> 00:14:46,990
not to touch that because I wouldn't be

316
00:14:46,990 --> 00:14:48,460
able to fit all the code in that fixed

317
00:14:48,460 --> 00:14:50,260
size and I didn't know about what it

318
00:14:50,260 --> 00:14:53,560
would take to expand it at that time the

319
00:14:53,560 --> 00:14:54,970
first thing I learned is that working

320
00:14:54,970 --> 00:14:57,430
with the boot code is difficult because

321
00:14:57,430 --> 00:14:59,530
there are no debugging facilities if

322
00:14:59,530 --> 00:15:01,090
something goes wrong most likely the

323
00:15:01,090 --> 00:15:03,630
machine will just hang with no output

324
00:15:03,630 --> 00:15:07,510
and you can't really you know attach gdb

325
00:15:07,510 --> 00:15:10,000
to it or something your only option is

326
00:15:10,000 --> 00:15:12,430
lots of print FS and hoping you can read

327
00:15:12,430 --> 00:15:13,900
text that's scrolling by really really

328
00:15:13,900 --> 00:15:21,760
fast so in order to actually get

329
00:15:21,760 --> 00:15:22,990
somewhere the first thing I had to do

330
00:15:22,990 --> 00:15:25,750
was how to tell if this partition is

331
00:15:25,750 --> 00:15:31,780
encrypted or if it's not so the way free

332
00:15:31,780 --> 00:15:34,660
beasties GOM classes work is the very

333
00:15:34,660 --> 00:15:37,180
last sector of partition will contain

334
00:15:37,180 --> 00:15:39,940
some metadata that says what kind of

335
00:15:39,940 --> 00:15:42,670
class it is so in this case the first

336
00:15:42,670 --> 00:15:45,910
couple of bytes of the last sector will

337
00:15:45,910 --> 00:15:47,620
say GOM colon colon

338
00:15:47,620 --> 00:15:50,700
li and then that means I know that it's

339
00:15:50,700 --> 00:15:53,020
deadly encrypted partition and if it

340
00:15:53,020 --> 00:15:54,580
doesn't have that then it's not and I

341
00:15:54,580 --> 00:15:57,480
should treat it differently

342
00:15:58,320 --> 00:16:00,550
what was interesting was trying to

343
00:16:00,550 --> 00:16:02,410
actually find where a partition starts

344
00:16:02,410 --> 00:16:05,620
and stops so in the boot code there's a

345
00:16:05,620 --> 00:16:08,140
some code that understands GPT and MBR

346
00:16:08,140 --> 00:16:12,340
and it populates this struct disk but

347
00:16:12,340 --> 00:16:13,990
depending how it started

348
00:16:13,990 --> 00:16:16,210
it may or may not have a start offset

349
00:16:16,210 --> 00:16:19,720
set for where the partition starts and

350
00:16:19,720 --> 00:16:23,950
then so you have the partition table

351
00:16:23,950 --> 00:16:26,200
which has the start and a length for

352
00:16:26,200 --> 00:16:29,380
each partition but then the disk object

353
00:16:29,380 --> 00:16:30,820
you're working with may or may not have

354
00:16:30,820 --> 00:16:35,440
the start offset set and so you have to

355
00:16:35,440 --> 00:16:37,600
just make it relative to what it says

356
00:16:37,600 --> 00:16:40,710
but it's not always what you think it is

357
00:16:40,710 --> 00:16:45,010
it turns out depending which boot code

358
00:16:45,010 --> 00:16:46,240
you're working with the numbers will be

359
00:16:46,240 --> 00:16:46,750
different

360
00:16:46,750 --> 00:16:49,360
and that makes everything more

361
00:16:49,360 --> 00:16:53,590
complicated so it turns out that the

362
00:16:53,590 --> 00:16:55,810
zetas fest boot code actually made my

363
00:16:55,810 --> 00:16:59,530
job easier instead of so what the Zen FS

364
00:16:59,530 --> 00:17:01,180
boot code does is instead of reading the

365
00:17:01,180 --> 00:17:03,340
disk directly it actually uses a

366
00:17:03,340 --> 00:17:06,579
callback so it calls another function to

367
00:17:06,579 --> 00:17:13,780
do the reading and then so there's a

368
00:17:13,780 --> 00:17:15,490
function instead of s and it takes as a

369
00:17:15,490 --> 00:17:17,619
parameter the function it should call to

370
00:17:17,619 --> 00:17:20,410
read from the disk so what I was able to

371
00:17:20,410 --> 00:17:22,599
do was just replace the regular read

372
00:17:22,599 --> 00:17:25,270
function with my encrypted read function

373
00:17:25,270 --> 00:17:27,849
that would then call the regular read do

374
00:17:27,849 --> 00:17:29,380
the decryption and then return the

375
00:17:29,380 --> 00:17:34,750
result to ZFS so that's what I did to

376
00:17:34,750 --> 00:17:37,570
remove that and then I actually decided

377
00:17:37,570 --> 00:17:39,550
that I liked that approach a lot so I

378
00:17:39,550 --> 00:17:41,890
changed the ufs code to basically do the

379
00:17:41,890 --> 00:17:44,350
same thing so that I could implement it

380
00:17:44,350 --> 00:17:47,320
the same in both ufs and ZFS and try to

381
00:17:47,320 --> 00:17:52,780
make it easier to understand so after I

382
00:17:52,780 --> 00:17:54,400
figured out if a partition is encrypted

383
00:17:54,400 --> 00:17:56,620
or not the next thing I need to do is

384
00:17:56,620 --> 00:17:58,510
actually decrypt it so I can start

385
00:17:58,510 --> 00:18:01,570
reading from it so by looking at the

386
00:18:01,570 --> 00:18:03,580
deli metadata which is in the very last

387
00:18:03,580 --> 00:18:06,610
sector of the partition I get the basic

388
00:18:06,610 --> 00:18:08,440
information I need like what algorithm

389
00:18:08,440 --> 00:18:10,600
it's encrypted with how big of a

390
00:18:10,600 --> 00:18:13,030
he uses and an encrypted copy of the

391
00:18:13,030 --> 00:18:16,539
master key ah once I have that I can

392
00:18:16,539 --> 00:18:18,400
then try to decrypt the master key by

393
00:18:18,400 --> 00:18:20,890
asking the user for the passphrase and

394
00:18:20,890 --> 00:18:23,049
if the user provides the correct

395
00:18:23,049 --> 00:18:28,870
passphrase then an H Mac will match the

396
00:18:28,870 --> 00:18:30,820
signature in the galley MIDI data and I

397
00:18:30,820 --> 00:18:31,750
know that they entered the right

398
00:18:31,750 --> 00:18:34,120
password if not I can prompt them again

399
00:18:34,120 --> 00:18:36,100
in a VIN and then eventually just give

400
00:18:36,100 --> 00:18:39,160
up over them so at this point the

401
00:18:39,160 --> 00:18:41,950
problem was I needed to have some

402
00:18:41,950 --> 00:18:44,200
cryptic right I needed to be able to

403
00:18:44,200 --> 00:18:46,360
decrypt that master key and the

404
00:18:46,360 --> 00:18:48,909
bootloader doesn't have any crypto by

405
00:18:48,909 --> 00:18:51,970
default right it was for you FS the

406
00:18:51,970 --> 00:18:56,049
bootloader was 14 kilobytes wasn't any X

407
00:18:56,049 --> 00:18:58,929
code in it and when I started the ZFS

408
00:18:58,929 --> 00:19:02,350
one was 47 kilobytes and most of that

409
00:19:02,350 --> 00:19:04,870
was the checksum algorithms and the

410
00:19:04,870 --> 00:19:06,340
compression algorithms that said if s

411
00:19:06,340 --> 00:19:10,480
needed to be able to read the disk so I

412
00:19:10,480 --> 00:19:12,490
looked at how Kelly does it but it uses

413
00:19:12,490 --> 00:19:14,440
the kernels crypto API to support

414
00:19:14,440 --> 00:19:16,690
offloading to crypto acceleration cards

415
00:19:16,690 --> 00:19:17,860
and stuff like that

416
00:19:17,860 --> 00:19:19,750
and that was way too big and complicated

417
00:19:19,750 --> 00:19:24,309
to try to put in the bootloader so I

418
00:19:24,309 --> 00:19:26,679
used Google and I just looked for like

419
00:19:26,679 --> 00:19:30,130
tiny basic C a es implementation and I

420
00:19:30,130 --> 00:19:32,650
found this thing called tiny ASC on

421
00:19:32,650 --> 00:19:36,039
github and it was BSD licensed and it

422
00:19:36,039 --> 00:19:39,190
allowed me to get started but as I

423
00:19:39,190 --> 00:19:40,510
started working with it I realized it

424
00:19:40,510 --> 00:19:45,280
only does a es cbc 128 not 256 and it

425
00:19:45,280 --> 00:19:48,850
doesn't do a es XTS ah so while we get

426
00:19:48,850 --> 00:19:50,650
me started it wouldn't actually solve

427
00:19:50,650 --> 00:19:54,010
the problem so I purposely created some

428
00:19:54,010 --> 00:19:56,260
encrypted disks using the one algorithm

429
00:19:56,260 --> 00:19:58,770
I had support for at this point and

430
00:19:58,770 --> 00:20:00,880
fiddled with it enough until I got it to

431
00:20:00,880 --> 00:20:04,929
actually work so by stealing some

432
00:20:04,929 --> 00:20:06,909
functions from gely that read the

433
00:20:06,909 --> 00:20:09,460
metadata and do the decryption and just

434
00:20:09,460 --> 00:20:10,929
replacing the calls into the kernel

435
00:20:10,929 --> 00:20:13,299
crypto system with the basic C

436
00:20:13,299 --> 00:20:17,169
implementation I had here that I could

437
00:20:17,169 --> 00:20:19,960
decrypt and validate the master key and

438
00:20:19,960 --> 00:20:22,330
then using that I could calculate the H

439
00:20:22,330 --> 00:20:24,130
Mac and make sure that the master

440
00:20:24,130 --> 00:20:27,100
he was correct and then I could use H

441
00:20:27,100 --> 00:20:30,190
Mac that deli uses to calculate the

442
00:20:30,190 --> 00:20:31,960
sector key and the initialization vector

443
00:20:31,960 --> 00:20:33,880
for the actual encryption so I can

444
00:20:33,880 --> 00:20:42,000
decrypt random sectors then I looked at

445
00:20:42,060 --> 00:20:44,440
what other bits of code I was going to

446
00:20:44,440 --> 00:20:47,620
need and it turns out that gely uses md5

447
00:20:47,620 --> 00:20:51,160
for the signature on its metadata so

448
00:20:51,160 --> 00:20:53,800
this is something across all the GM

449
00:20:53,800 --> 00:20:56,020
stuff is that the the metadata that's

450
00:20:56,020 --> 00:20:58,600
written in that lasts 512 bytes on the

451
00:20:58,600 --> 00:21:02,440
disk is has an md5 hash just as a sanity

452
00:21:02,440 --> 00:21:04,150
check it's not really meant to be

453
00:21:04,150 --> 00:21:07,540
cryptographic or anything inside gely

454
00:21:07,540 --> 00:21:10,390
itself it uses sha-256

455
00:21:10,390 --> 00:21:13,150
for all generating all the unpredictable

456
00:21:13,150 --> 00:21:15,970
Ivy's for the disk encryption and then

457
00:21:15,970 --> 00:21:18,780
it uses shop 512 for all the H max for

458
00:21:18,780 --> 00:21:21,760
verifying that the master key is right

459
00:21:21,760 --> 00:21:24,460
and if you actually have the data

460
00:21:24,460 --> 00:21:27,160
authentication or not so now I needed

461
00:21:27,160 --> 00:21:29,350
all three of those hashing ovum's to fit

462
00:21:29,350 --> 00:21:32,920
in the bootloader so I first tried to

463
00:21:32,920 --> 00:21:35,080
just you know include them like like

464
00:21:35,080 --> 00:21:36,160
you're supposed to be able to do is just

465
00:21:36,160 --> 00:21:37,740
grab the headers for each of them and go

466
00:21:37,740 --> 00:21:40,470
but it turns out doesn't work like that

467
00:21:40,470 --> 00:21:44,380
so elsewhere in the boot code when they

468
00:21:44,380 --> 00:21:45,580
need some code they actually used

469
00:21:45,580 --> 00:21:48,040
include on the dot C files so just

470
00:21:48,040 --> 00:21:50,350
bringing that stuff kind of in line and

471
00:21:50,350 --> 00:21:52,450
try to make a small bootloader but the

472
00:21:52,450 --> 00:21:53,560
problem is that there is a bunch of

473
00:21:53,560 --> 00:21:56,770
conflicting defines in aes-256 and aes

474
00:21:56,770 --> 00:21:59,500
512 where yeah defining the same

475
00:21:59,500 --> 00:22:01,030
function name but they actually do

476
00:22:01,030 --> 00:22:02,650
different things or have different size

477
00:22:02,650 --> 00:22:07,900
values so then the approach I took was

478
00:22:07,900 --> 00:22:10,810
there's this Lib stand 3/2 which is a

479
00:22:10,810 --> 00:22:12,730
32-bit version of Lib stand that the

480
00:22:12,730 --> 00:22:16,660
boot code uses so I just hacked up the

481
00:22:16,660 --> 00:22:18,130
make file so it would pull in the

482
00:22:18,130 --> 00:22:22,750
existing library chunks of code into

483
00:22:22,750 --> 00:22:24,490
this library and expose all the symbols

484
00:22:24,490 --> 00:22:27,670
and then I could use them from the

485
00:22:27,670 --> 00:22:28,320
bootloader

486
00:22:28,320 --> 00:22:30,970
eventually I replace this by creating my

487
00:22:30,970 --> 00:22:33,190
own library live jelly boot that brought

488
00:22:33,190 --> 00:22:34,480
in all the dependencies I needed for

489
00:22:34,480 --> 00:22:36,550
that instead of bloating lips tan which

490
00:22:36,550 --> 00:22:37,929
is also used by other things

491
00:22:37,929 --> 00:22:40,480
and was causing all the binaries to grow

492
00:22:40,480 --> 00:22:46,330
instead of only mine so then I had to

493
00:22:46,330 --> 00:22:48,340
prompt the user for the password to be

494
00:22:48,340 --> 00:22:50,169
able to decrypt the disk you know when I

495
00:22:50,169 --> 00:22:52,360
was first writing this I just hard-coded

496
00:22:52,360 --> 00:22:54,820
test pass as the password in the boot

497
00:22:54,820 --> 00:22:56,860
code and created encrypted disks that

498
00:22:56,860 --> 00:22:59,049
were with that password and eventually

499
00:22:59,049 --> 00:23:01,090
got it to work but then I needed to

500
00:23:01,090 --> 00:23:03,669
support you know actual pass phrases so

501
00:23:03,669 --> 00:23:04,659
then I was like it shouldn't be that

502
00:23:04,659 --> 00:23:08,080
hard to ask for a password right so I

503
00:23:08,080 --> 00:23:11,049
went into the common console code and

504
00:23:11,049 --> 00:23:13,240
got the get stir function which allows

505
00:23:13,240 --> 00:23:16,119
you to get text from the console and I

506
00:23:16,119 --> 00:23:17,590
changed it so instead of echoing back

507
00:23:17,590 --> 00:23:18,999
the characters you type it would echo

508
00:23:18,999 --> 00:23:21,369
back a star and it should be just all

509
00:23:21,369 --> 00:23:24,730
well and good but it turns out the

510
00:23:24,730 --> 00:23:27,190
loader reuses some of that code but it

511
00:23:27,190 --> 00:23:28,690
actually uses completely different

512
00:23:28,690 --> 00:23:29,799
functions to read from the console

513
00:23:29,799 --> 00:23:33,220
because it has to support serial and so

514
00:23:33,220 --> 00:23:34,869
I had to write a completely different

515
00:23:34,869 --> 00:23:39,340
implementation of the same thing but

516
00:23:39,340 --> 00:23:41,529
then during code review later on we

517
00:23:41,529 --> 00:23:43,360
found that actually both of those

518
00:23:43,360 --> 00:23:46,960
functions the one in the console and the

519
00:23:46,960 --> 00:23:49,299
one in the bootloader containing the

520
00:23:49,299 --> 00:23:53,529
same bug that was found in net bsd like

521
00:23:53,529 --> 00:23:59,009
eight years ago and fixed one of the

522
00:23:59,009 --> 00:24:04,269
break or something they didn't use curly

523
00:24:04,269 --> 00:24:05,529
braces on one of the if statements and

524
00:24:05,529 --> 00:24:08,139
they had two things in the if and it

525
00:24:08,139 --> 00:24:09,970
looked like it was working because of

526
00:24:09,970 --> 00:24:12,879
the indentation but it wasn't uh and so

527
00:24:12,879 --> 00:24:15,610
this would cause it to not stop when you

528
00:24:15,610 --> 00:24:16,690
reach the maximum number of characters

529
00:24:16,690 --> 00:24:20,259
and you just keep overriding memory and

530
00:24:20,259 --> 00:24:22,809
doing crazy things which is not what you

531
00:24:22,809 --> 00:24:24,100
want to do especially with a password

532
00:24:24,100 --> 00:24:25,450
where you've assumed it's only going to

533
00:24:25,450 --> 00:24:26,259
be this long and you're going to

534
00:24:26,259 --> 00:24:28,960
overwrite that memory with zeros later

535
00:24:28,960 --> 00:24:31,210
and then not overwrite anything in

536
00:24:31,210 --> 00:24:37,240
excess so instead I actually found the

537
00:24:37,240 --> 00:24:40,960
version from net bsd and get s that was

538
00:24:40,960 --> 00:24:43,690
actually correct from our lip stand and

539
00:24:43,690 --> 00:24:48,220
wrote my own PW get s and put that in my

540
00:24:48,220 --> 00:24:51,399
little library future work for some days

541
00:24:51,399 --> 00:24:51,760
go

542
00:24:51,760 --> 00:24:56,500
I can fix all the other ones ah actually

543
00:24:56,500 --> 00:24:57,820
here's the code that's wrong

544
00:24:57,820 --> 00:25:02,110
ah so if you haven't overflowed the

545
00:25:02,110 --> 00:25:03,970
buffer then good and this should be

546
00:25:03,970 --> 00:25:07,210
inside this if instead of not so if

547
00:25:07,210 --> 00:25:08,920
you've overflowed the buffer or if you

548
00:25:08,920 --> 00:25:10,270
haven't overflowed the buffer keep

549
00:25:10,270 --> 00:25:12,550
counting but otherwise put the character

550
00:25:12,550 --> 00:25:15,550
there anyway so that's to do what it's

551
00:25:15,550 --> 00:25:21,910
supposed to do so at this point I

552
00:25:21,910 --> 00:25:24,370
thought I had enough working so I could

553
00:25:24,370 --> 00:25:27,280
actually take it for a test drive so my

554
00:25:27,280 --> 00:25:29,320
expectation was that Mbutu would start

555
00:25:29,320 --> 00:25:31,960
taste the partition determine that it

556
00:25:31,960 --> 00:25:35,050
was encrypted then read the master key

557
00:25:35,050 --> 00:25:37,270
which is encrypted in that last sector

558
00:25:37,270 --> 00:25:39,730
of the drive decrypt it with the

559
00:25:39,730 --> 00:25:41,590
passphrase I just provided and then

560
00:25:41,590 --> 00:25:43,480
stand ready to determine the sector key

561
00:25:43,480 --> 00:25:45,490
and decrypt individual sectors of the

562
00:25:45,490 --> 00:25:48,610
drive as I tried to read them so I

563
00:25:48,610 --> 00:25:51,250
booted up in VirtualBox and VirtualBox

564
00:25:51,250 --> 00:25:53,500
got some kind of triple fault and it is

565
00:25:53,500 --> 00:25:54,190
trashed

566
00:25:54,190 --> 00:26:01,360
like what's a triple fault so so I wrote

567
00:26:01,360 --> 00:26:03,010
it out to a USB stick and tried it on my

568
00:26:03,010 --> 00:26:03,520
laptop

569
00:26:03,520 --> 00:26:06,690
and it just rebooted in a loop like this

570
00:26:06,690 --> 00:26:13,810
is not going to work no idea why so it

571
00:26:13,810 --> 00:26:16,120
turns out by adding all this I'd

572
00:26:16,120 --> 00:26:18,400
actually caused the boot code to go

573
00:26:18,400 --> 00:26:21,610
beyond 64 kilobytes which at the time I

574
00:26:21,610 --> 00:26:25,420
didn't know was a magic number so now

575
00:26:25,420 --> 00:26:27,850
the boot code was like 70 something

576
00:26:27,850 --> 00:26:31,720
kilobytes and it turns out the GPT

577
00:26:31,720 --> 00:26:34,630
loader that little 512 byte assembly

578
00:26:34,630 --> 00:26:38,830
program that grabs gbg ZFS boot copies

579
00:26:38,830 --> 00:26:40,330
it to the right place of memory and lets

580
00:26:40,330 --> 00:26:43,450
the BIOS execute it only copies the

581
00:26:43,450 --> 00:26:45,790
first 64 kilobytes because that'll be

582
00:26:45,790 --> 00:26:48,880
enough for anyone right because when I

583
00:26:48,880 --> 00:26:52,150
started the project the ufs one was less

584
00:26:52,150 --> 00:26:54,340
than 16 kilobytes and even the ZFS one

585
00:26:54,340 --> 00:26:57,460
was 42 kilobytes so 64 was actually

586
00:26:57,460 --> 00:26:59,230
probably enough but once you started

587
00:26:59,230 --> 00:27:02,350
adding the encryption and hashing

588
00:27:02,350 --> 00:27:05,440
algorithms all sudden that was

589
00:27:05,440 --> 00:27:08,470
not gonna be enough but because this is

590
00:27:08,470 --> 00:27:12,519
16-bit real mode in the OS you can't

591
00:27:12,519 --> 00:27:15,460
actually copy more than 64 K at once so

592
00:27:15,460 --> 00:27:18,190
it wasn't just a matter of changing the

593
00:27:18,190 --> 00:27:20,559
assembly code to copy more data I tried

594
00:27:20,559 --> 00:27:23,919
that it didn't work yeah I tried that in

595
00:27:23,919 --> 00:27:25,899
the assembler actually laughed at me and

596
00:27:25,899 --> 00:27:31,750
then put it back to 64 kilobytes yeah so

597
00:27:31,750 --> 00:27:34,389
I was over 90 kilobytes and this wasn't

598
00:27:34,389 --> 00:27:40,330
gonna work so I was like okay put that

599
00:27:40,330 --> 00:27:42,309
aside let's try ufs it's small enough I

600
00:27:42,309 --> 00:27:45,639
think I can fit it all so I stuck with

601
00:27:45,639 --> 00:27:47,919
just you FS even though this whole

602
00:27:47,919 --> 00:27:50,559
project was only originally for ZFS and

603
00:27:50,559 --> 00:27:52,090
I didn't think I cared about you FS but

604
00:27:52,090 --> 00:27:56,470
I was like you FS can't be that hard so

605
00:27:56,470 --> 00:27:59,200
I decided to use you FS and then

606
00:27:59,200 --> 00:28:01,539
basically did all the same reused all

607
00:28:01,539 --> 00:28:04,299
the same code to you know decrypt the

608
00:28:04,299 --> 00:28:08,470
master key and everything and luckily

609
00:28:08,470 --> 00:28:11,860
when I compiled it it was under 64 K so

610
00:28:11,860 --> 00:28:15,159
I put it out and booted it up and the

611
00:28:15,159 --> 00:28:18,490
decryption actually worked I'm kind of

612
00:28:18,490 --> 00:28:20,649
glossing over like a month of it not

613
00:28:20,649 --> 00:28:22,269
actually decrypting correctly and

614
00:28:22,269 --> 00:28:24,070
printing out hex thumbs to the screen

615
00:28:24,070 --> 00:28:25,179
and trying to figure out what's not

616
00:28:25,179 --> 00:28:29,950
working but anyway so now GPT boot

617
00:28:29,950 --> 00:28:32,019
decrypts the filesystem and it was

618
00:28:32,019 --> 00:28:33,759
actually able to read slash boot slash

619
00:28:33,759 --> 00:28:36,850
loader and running so I had actually

620
00:28:36,850 --> 00:28:39,429
decrypted something and run it I was

621
00:28:39,429 --> 00:28:40,629
very happy

622
00:28:40,629 --> 00:28:42,580
so the loader starts and immediately

623
00:28:42,580 --> 00:28:45,629
failed because it tried to read the disk

624
00:28:45,629 --> 00:28:48,759
expecting you FS and got gibberish

625
00:28:48,759 --> 00:28:50,590
because it was encrypted and so I was

626
00:28:50,590 --> 00:28:55,629
like I can't do anything with that so it

627
00:28:55,629 --> 00:28:57,820
all worked except it didn't actually go

628
00:28:57,820 --> 00:29:00,730
anywhere now so I could load the loader

629
00:29:00,730 --> 00:29:02,230
but then the loader would just laugh at

630
00:29:02,230 --> 00:29:08,710
me and of course the boot loader isn't

631
00:29:08,710 --> 00:29:10,480
much better although slightly better

632
00:29:10,480 --> 00:29:12,580
than the boot code which is the thing

633
00:29:12,580 --> 00:29:14,320
that the bootstrap that loads the boot

634
00:29:14,320 --> 00:29:16,869
loader so there's no kernel

635
00:29:16,869 --> 00:29:18,700
there's no Lib C there's

636
00:29:18,700 --> 00:29:21,040
Malak and position there's no panic

637
00:29:21,040 --> 00:29:25,000
there's nothing you can do there's even

638
00:29:25,000 --> 00:29:26,170
complications with that when you're

639
00:29:26,170 --> 00:29:28,210
trying to use code that's meant for user

640
00:29:28,210 --> 00:29:31,390
land it wants to include string.h but

641
00:29:31,390 --> 00:29:32,830
when you're building the bootloader you

642
00:29:32,830 --> 00:29:35,920
have Lib stand which has its own string

643
00:29:35,920 --> 00:29:37,510
implementation and you can't have both

644
00:29:37,510 --> 00:29:43,150
at the same time so that complicated

645
00:29:43,150 --> 00:29:45,880
things so in the boot code the actual

646
00:29:45,880 --> 00:29:48,160
like ufs instead of s implementations

647
00:29:48,160 --> 00:29:52,630
there is a malloc function it just

648
00:29:52,630 --> 00:29:55,810
doesn't do what you used to it doing so

649
00:29:55,810 --> 00:29:57,970
in the case of the zetas FS 1

650
00:29:57,970 --> 00:30:01,090
there's a 3 megabyte stack variable set

651
00:30:01,090 --> 00:30:04,870
aside and when you call malloc it just

652
00:30:04,870 --> 00:30:07,390
increases the counter to wit what offset

653
00:30:07,390 --> 00:30:10,330
in that variable you are giving you back

654
00:30:10,330 --> 00:30:13,390
a pointer to some memory you can use but

655
00:30:13,390 --> 00:30:16,870
there's no free write so you have 3

656
00:30:16,870 --> 00:30:18,190
megabytes of memory and you can allocate

657
00:30:18,190 --> 00:30:20,650
but if you free you don't get anything

658
00:30:20,650 --> 00:30:24,610
back and so you can only have ever used

659
00:30:24,610 --> 00:30:26,890
3 megabytes not you can only use 3

660
00:30:26,890 --> 00:30:29,770
megabytes at once so this means you have

661
00:30:29,770 --> 00:30:31,660
to try to avoid doing a bunch of small

662
00:30:31,660 --> 00:30:35,070
allocations that are just temporary

663
00:30:36,960 --> 00:30:39,730
so the next step was to teach the loader

664
00:30:39,730 --> 00:30:42,220
how to actually speak Kelly so that it

665
00:30:42,220 --> 00:30:43,990
could load the kernel so that the

666
00:30:43,990 --> 00:30:48,340
operating system could start ah so I had

667
00:30:48,340 --> 00:30:50,320
to figure out where in the loader it

668
00:30:50,320 --> 00:30:52,390
actually reads from the disk so I could

669
00:30:52,390 --> 00:30:55,630
do this same hack of oh I see you read

670
00:30:55,630 --> 00:30:56,560
some data from the disk

671
00:30:56,560 --> 00:30:58,150
let me decrypt that for you before you

672
00:30:58,150 --> 00:31:03,340
try to use it so again I had to do taste

673
00:31:03,340 --> 00:31:05,680
the disk and determine if it's Kelly

674
00:31:05,680 --> 00:31:07,690
read the master key prompt for the

675
00:31:07,690 --> 00:31:10,300
password do all that stuff so in the

676
00:31:10,300 --> 00:31:13,000
loader it has this array called file

677
00:31:13,000 --> 00:31:15,370
systems and it has all these different

678
00:31:15,370 --> 00:31:20,140
file systems define ufs ZFS NFS etc so

679
00:31:20,140 --> 00:31:21,520
my first thought was well I could just

680
00:31:21,520 --> 00:31:24,160
add you know get Li underscore ufs as a

681
00:31:24,160 --> 00:31:26,470
new file system and wrap all those

682
00:31:26,470 --> 00:31:29,470
functions but when I looked a little bit

683
00:31:29,470 --> 00:31:31,540
further it turned out all the different

684
00:31:31,540 --> 00:31:32,590
file systems

685
00:31:32,590 --> 00:31:34,049
that actually expected read from disk

686
00:31:34,049 --> 00:31:38,350
used lib I 386 to actually do the BIOS

687
00:31:38,350 --> 00:31:40,899
calls that read from the disk so i

688
00:31:40,899 --> 00:31:42,879
intercepted the data there instead

689
00:31:42,879 --> 00:31:47,080
because it was less work probably not

690
00:31:47,080 --> 00:31:48,669
the best place to actually put it but it

691
00:31:48,669 --> 00:31:52,539
was less work so ideally we'd implement

692
00:31:52,539 --> 00:31:54,490
it as part of probably the read cache

693
00:31:54,490 --> 00:31:57,580
that Thomas zoom did for illumos and

694
00:31:57,580 --> 00:32:00,940
then poured it back to FreeBSD but

695
00:32:00,940 --> 00:32:06,389
that's future work so after I basically

696
00:32:06,389 --> 00:32:08,889
redid all the work I just did in the

697
00:32:08,889 --> 00:32:12,269
loader instead of the bootstrap which is

698
00:32:12,269 --> 00:32:15,369
relatively different code I was stuck

699
00:32:15,369 --> 00:32:17,980
here so I successfully actually booted a

700
00:32:17,980 --> 00:32:21,610
gely encrypted disk with a ufs

701
00:32:21,610 --> 00:32:24,580
filesystem but I only had support for

702
00:32:24,580 --> 00:32:27,720
AES CBC 128 which nobody wants to use

703
00:32:27,720 --> 00:32:30,309
there was no support for ZFS I had this

704
00:32:30,309 --> 00:32:33,519
64 kilobyte binary size limit which

705
00:32:33,519 --> 00:32:35,830
meant no Zetas fest and that if I added

706
00:32:35,830 --> 00:32:37,539
much more complexity to it I was going

707
00:32:37,539 --> 00:32:41,830
to have no ufs either so while I had

708
00:32:41,830 --> 00:32:42,820
done a lot of work and actually

709
00:32:42,820 --> 00:32:44,110
accomplished all these things

710
00:32:44,110 --> 00:32:48,549
I was actually nowhere so in order to go

711
00:32:48,549 --> 00:32:50,409
any further I needed to get rid of this

712
00:32:50,409 --> 00:32:56,679
64 kilobyte limit so I I tried some you

713
00:32:56,679 --> 00:32:58,899
know naive things I tried to compile

714
00:32:58,899 --> 00:33:01,899
with optimize for size but that didn't

715
00:33:01,899 --> 00:33:02,379
really help

716
00:33:02,379 --> 00:33:07,529
I tried optimizing it more or switching

717
00:33:07,529 --> 00:33:11,080
202 but that just made it bigger

718
00:33:11,080 --> 00:33:13,360
I tried increasing the number of blocks

719
00:33:13,360 --> 00:33:16,570
so in the GPT loader assembly it's like

720
00:33:16,570 --> 00:33:19,779
copy this many 512 byte blocks

721
00:33:19,779 --> 00:33:23,679
it's like 80 because that's 500 or 64

722
00:33:23,679 --> 00:33:24,610
kilobytes

723
00:33:24,610 --> 00:33:28,090
I tried increasing it but the assembler

724
00:33:28,090 --> 00:33:29,919
is like that numbers too big sorry I'm

725
00:33:29,919 --> 00:33:32,409
putting it back to the maximum the fact

726
00:33:32,409 --> 00:33:34,570
that it still compiled and put the

727
00:33:34,570 --> 00:33:36,159
number back to a small number instead of

728
00:33:36,159 --> 00:33:41,070
just failing kind of amused me so then I

729
00:33:41,070 --> 00:33:43,899
reached out to various other people at

730
00:33:43,899 --> 00:33:45,870
the FreeBSD project to see

731
00:33:45,870 --> 00:33:48,809
get their help first person I asked was

732
00:33:48,809 --> 00:33:50,280
my documentation mentor

733
00:33:50,280 --> 00:33:52,140
the person who was mentoring me for my

734
00:33:52,140 --> 00:33:55,140
documentation commitment he looked at it

735
00:33:55,140 --> 00:33:57,180
and thought well this shouldn't be too

736
00:33:57,180 --> 00:33:59,580
hard to convert to 64-bit but turns out

737
00:33:59,580 --> 00:34:01,250
that doesn't actually worked like that

738
00:34:01,250 --> 00:34:04,860
or to make a copy to blocks is 64k

739
00:34:04,860 --> 00:34:07,920
instead but he didn't really have time

740
00:34:07,920 --> 00:34:11,190
to to write the assembly for me so I

741
00:34:11,190 --> 00:34:14,370
tried someone else john mark gurney he

742
00:34:14,370 --> 00:34:17,159
seemed receptive to the idea first but

743
00:34:17,159 --> 00:34:18,750
once he understood that it was the boot

744
00:34:18,750 --> 00:34:20,820
code and that it was complicated and

745
00:34:20,820 --> 00:34:22,469
16-bit real-mode

746
00:34:22,469 --> 00:34:26,449
he quickly suggested i ask someone else

747
00:34:26,449 --> 00:34:29,250
so then I asked the original author of

748
00:34:29,250 --> 00:34:32,790
GPT LDR John Baldwin and he suggested

749
00:34:32,790 --> 00:34:34,649
that you shouldn't make the boot code

750
00:34:34,649 --> 00:34:36,210
bigger you should solve this some other

751
00:34:36,210 --> 00:34:41,940
way like having a partition that had

752
00:34:41,940 --> 00:34:44,040
only the loader on it rather than the

753
00:34:44,040 --> 00:34:46,649
entire slash boot and hacking around it

754
00:34:46,649 --> 00:34:48,139
that way

755
00:34:48,139 --> 00:34:51,929
well that's not too terrible it's just a

756
00:34:51,929 --> 00:34:54,090
lot messier than the way I was hoping to

757
00:34:54,090 --> 00:34:57,960
do it and then Peter greens like oh yeah

758
00:34:57,960 --> 00:34:59,250
sure I can help you with that and then

759
00:34:59,250 --> 00:35:01,500
he it's like actually here let me teach

760
00:35:01,500 --> 00:35:04,860
you how to use q mu and gdb to debug the

761
00:35:04,860 --> 00:35:06,930
assembly instructions as I go by I'm

762
00:35:06,930 --> 00:35:09,060
like if I knew how to do assembly I

763
00:35:09,060 --> 00:35:11,900
wouldn't have asked you

764
00:35:13,290 --> 00:35:17,280
and then at VBS deke on the Verisign

765
00:35:17,280 --> 00:35:21,720
conference would have been 2015 my

766
00:35:21,720 --> 00:35:23,160
friend Dylan was there so I asked him

767
00:35:23,160 --> 00:35:25,320
and he started trying to write new

768
00:35:25,320 --> 00:35:27,090
assembly and sent me a couple of bits of

769
00:35:27,090 --> 00:35:29,100
code but they didn't work and he spent

770
00:35:29,100 --> 00:35:30,270
the rest of the conference with a pad of

771
00:35:30,270 --> 00:35:32,400
paper drawing the memory stack trying to

772
00:35:32,400 --> 00:35:35,430
figure out how to do it but after the

773
00:35:35,430 --> 00:35:37,740
conference was over he had to go back to

774
00:35:37,740 --> 00:35:39,540
his day job and didn't have time to help

775
00:35:39,540 --> 00:35:41,300
me with it

776
00:35:41,300 --> 00:35:45,690
then at Euro BSD Con 2015 in Stockholm

777
00:35:45,690 --> 00:35:49,560
Sweden we were having the dev summit and

778
00:35:49,560 --> 00:35:51,720
at one point call him personal

779
00:35:51,720 --> 00:35:53,520
approached me he says I heard you're

780
00:35:53,520 --> 00:35:55,620
having trouble with some 16-bit assembly

781
00:35:55,620 --> 00:35:58,690
I'm like yes he's like that

782
00:35:58,690 --> 00:36:01,420
16-bit assembly I know it turns out that

783
00:36:01,420 --> 00:36:03,069
was the only assembly he had ever done

784
00:36:03,069 --> 00:36:05,020
but he what he had done when he was in

785
00:36:05,020 --> 00:36:07,800
school and still remember had to do it

786
00:36:07,800 --> 00:36:12,280
so that night he wrote up a draft patch

787
00:36:12,280 --> 00:36:14,290
for the assembly code and sent it to me

788
00:36:14,290 --> 00:36:17,500
but it just crashed the BT ex-client

789
00:36:17,500 --> 00:36:19,660
which is the one of the little pieces of

790
00:36:19,660 --> 00:36:23,500
the bootloader ah so his first patch

791
00:36:23,500 --> 00:36:24,790
didn't work and then he sent another one

792
00:36:24,790 --> 00:36:27,130
and that still didn't work and basically

793
00:36:27,130 --> 00:36:29,710
we had you sent me a new patch each

794
00:36:29,710 --> 00:36:31,660
night of the conference until it was

795
00:36:31,660 --> 00:36:33,670
over but none of them worked so we all

796
00:36:33,670 --> 00:36:35,530
went home and I kind of figured I was

797
00:36:35,530 --> 00:36:38,349
out of luck still but then a couple days

798
00:36:38,349 --> 00:36:40,930
later on IRC Colin poked me and sent me

799
00:36:40,930 --> 00:36:44,890
a new patch it's like this one still

800
00:36:44,890 --> 00:36:47,319
only copies 64 kilobytes but it does it

801
00:36:47,319 --> 00:36:51,310
by copying to 32 kilobyte chunks so try

802
00:36:51,310 --> 00:36:53,800
this on a regular sized bootloader that

803
00:36:53,800 --> 00:36:56,710
we know would work and see if it works

804
00:36:56,710 --> 00:36:59,829
so we tried that and it did work so we

805
00:36:59,829 --> 00:37:02,740
were moving somewhere so then a couple

806
00:37:02,740 --> 00:37:05,140
days later he sent me a later draft that

807
00:37:05,140 --> 00:37:09,250
copies for 32 kilobyte chunks and it

808
00:37:09,250 --> 00:37:13,599
actually worked and now if you ever need

809
00:37:13,599 --> 00:37:14,859
more you can just increase this number

810
00:37:14,859 --> 00:37:23,140
so it's future proof so now that I'd

811
00:37:23,140 --> 00:37:25,510
solve that and whacked all that together

812
00:37:25,510 --> 00:37:29,530
I could now boot zenefits from aes-128

813
00:37:29,530 --> 00:37:33,910
encrypted volume but that's not the disk

814
00:37:33,910 --> 00:37:35,440
encryption people want to use you want a

815
00:37:35,440 --> 00:37:38,079
AES xes is it's faster and designed for

816
00:37:38,079 --> 00:37:42,210
disk encryption or at least AES CBC 56

817
00:37:42,210 --> 00:37:45,190
so now that I didn't have the space

818
00:37:45,190 --> 00:37:47,319
constraint anymore I could ditch the

819
00:37:47,319 --> 00:37:49,540
tiny AES implementation and get a real

820
00:37:49,540 --> 00:37:52,180
one so I actually stole the canonical

821
00:37:52,180 --> 00:37:58,630
one from the kernel and started just

822
00:37:58,630 --> 00:38:03,670
including it into the by including the C

823
00:38:03,670 --> 00:38:09,510
files into the GPT ZFS boot C

824
00:38:15,150 --> 00:38:17,210
you

825
00:38:23,910 --> 00:38:28,450
and play with it some more and then I

826
00:38:28,450 --> 00:38:30,880
needed an Aes XTS implementation which

827
00:38:30,880 --> 00:38:34,660
uses this code but has all the the

828
00:38:34,660 --> 00:38:36,220
functions that dudes are tweaking for

829
00:38:36,220 --> 00:38:38,560
the initialization vector so I stole

830
00:38:38,560 --> 00:38:40,320
that from open crypto which is a

831
00:38:40,320 --> 00:38:43,360
framework originally created an open BSD

832
00:38:43,360 --> 00:38:48,850
I think that provides all the different

833
00:38:48,850 --> 00:38:51,130
crypto functions and offload versions of

834
00:38:51,130 --> 00:38:54,250
them for crypto cards and so on the

835
00:38:54,250 --> 00:38:56,350
problem with that was all that code it

836
00:38:56,350 --> 00:39:00,160
was in one giant file xform dot c-- has

837
00:39:00,160 --> 00:39:02,830
all the crypto transforms so it's got

838
00:39:02,830 --> 00:39:09,160
cast Blowfish des a es a s XD sa s CB c

839
00:39:09,160 --> 00:39:12,130
AE s G C F all the different ones and

840
00:39:12,130 --> 00:39:14,710
that was kind of a lot of code that I

841
00:39:14,710 --> 00:39:17,020
didn't need and the other problem was it

842
00:39:17,020 --> 00:39:21,040
used kernel matlock implementation which

843
00:39:21,040 --> 00:39:23,290
on FreeBSD has extra fields because you

844
00:39:23,290 --> 00:39:24,940
define what type of memory it is you're

845
00:39:24,940 --> 00:39:26,380
allocating and which bucket your outlet

846
00:39:26,380 --> 00:39:30,130
getting it from so I made some changes

847
00:39:30,130 --> 00:39:32,290
to the implementation which are

848
00:39:32,290 --> 00:39:34,990
basically I copy and pasted just a ESX

849
00:39:34,990 --> 00:39:35,440
es

850
00:39:35,440 --> 00:39:38,530
open crypto into a new file and use that

851
00:39:38,530 --> 00:39:40,600
and modify it so it wouldn't actually

852
00:39:40,600 --> 00:39:42,850
malloc any memory it would use sack

853
00:39:42,850 --> 00:39:46,720
variables so once I had that I had a

854
00:39:46,720 --> 00:39:49,720
working u FS and ZFS that actually did

855
00:39:49,720 --> 00:39:51,430
the disk encryption people might want to

856
00:39:51,430 --> 00:39:57,430
use but it worked now but it wasn't

857
00:39:57,430 --> 00:39:58,510
something anybody who's gonna let me

858
00:39:58,510 --> 00:40:01,750
commit to freebsd cuz if it's a mess a

859
00:40:01,750 --> 00:40:06,130
very ugly mess so at this point the code

860
00:40:06,130 --> 00:40:08,110
was all ugly it's full of debug print

861
00:40:08,110 --> 00:40:09,970
apps that are printing out bits of

862
00:40:09,970 --> 00:40:11,650
pieces of things so you can tell i'm

863
00:40:11,650 --> 00:40:15,580
just i pound including a bunch of c

864
00:40:15,580 --> 00:40:19,240
files out of the kernel it worked but it

865
00:40:19,240 --> 00:40:24,220
was ugly and I couldn't just include

866
00:40:24,220 --> 00:40:25,420
some of the stuff from open crypto

867
00:40:25,420 --> 00:40:28,450
because the file was too big and you

868
00:40:28,450 --> 00:40:31,150
know they had sorry x1 dot C had in

869
00:40:31,150 --> 00:40:33,280
addition to every crypto algorithm had

870
00:40:33,280 --> 00:40:35,050
hashing algorithm including all the Mac

871
00:40:35,050 --> 00:40:39,130
variants and the deflate algorithm it's

872
00:40:39,130 --> 00:40:43,030
a really big fight so I asked the

873
00:40:43,030 --> 00:40:45,940
FreeBSD security officer what I should

874
00:40:45,940 --> 00:40:49,150
do about this and they said it probably

875
00:40:49,150 --> 00:40:51,040
makes sense to actually break up open

876
00:40:51,040 --> 00:40:52,350
crypto into the individual components

877
00:40:52,350 --> 00:40:56,920
and I'm like they'll let me do that so

878
00:40:56,920 --> 00:41:00,130
they did so I actually used SVN copy to

879
00:41:00,130 --> 00:41:03,670
copy X form type C to X form underscore

880
00:41:03,670 --> 00:41:05,500
each of those different algorithms and

881
00:41:05,500 --> 00:41:09,070
then deleted the XS code I'm not sure if

882
00:41:09,070 --> 00:41:11,170
that was the best way to do it but in

883
00:41:11,170 --> 00:41:14,950
the reviews in the diff I created out of

884
00:41:14,950 --> 00:41:17,620
it it was clear that I didn't add any

885
00:41:17,620 --> 00:41:19,720
new code I just copied and pasted that

886
00:41:19,720 --> 00:41:21,760
same file and deleted everything except

887
00:41:21,760 --> 00:41:22,990
for the bit I wanted for each file

888
00:41:22,990 --> 00:41:27,790
so while it made a bigger different

889
00:41:27,790 --> 00:41:29,740
actually change even accidentally any of

890
00:41:29,740 --> 00:41:33,160
the implementations so I'm not sure if

891
00:41:33,160 --> 00:41:35,230
it was the best way to do it for the

892
00:41:35,230 --> 00:41:37,960
code review but it was for me the

893
00:41:37,960 --> 00:41:39,220
easiest way to show that he didn't

894
00:41:39,220 --> 00:41:42,120
accidentally break any of the crypto

895
00:41:42,120 --> 00:41:43,900
because that was what I was supposed to

896
00:41:43,900 --> 00:41:48,040
worried about so at this point most of

897
00:41:48,040 --> 00:41:50,950
the gely code had survived not being

898
00:41:50,950 --> 00:41:53,200
that modified I just copy and pasted it

899
00:41:53,200 --> 00:41:54,880
I hadn't had to go through and like

900
00:41:54,880 --> 00:41:58,600
remove Malick's or anything so I looked

901
00:41:58,600 --> 00:42:00,610
at just being able to use the code from

902
00:42:00,610 --> 00:42:03,610
the kernel by linking it into the Lib

903
00:42:03,610 --> 00:42:06,010
gely boot instead of copying and pasting

904
00:42:06,010 --> 00:42:09,060
it there were a couple of places

905
00:42:09,060 --> 00:42:13,810
destruct gely soft see I had switched to

906
00:42:13,810 --> 00:42:16,990
the simpler metadata struct so I had

907
00:42:16,990 --> 00:42:20,530
undo that so like the the soft C has I

908
00:42:20,530 --> 00:42:23,470
don't know a whole page of variable in

909
00:42:23,470 --> 00:42:26,200
the struct it's everything you need for

910
00:42:26,200 --> 00:42:29,860
running the disk encryption in the live

911
00:42:29,860 --> 00:42:32,500
kernel whereas the metadata is just what

912
00:42:32,500 --> 00:42:34,390
data is actually stored on the disk in

913
00:42:34,390 --> 00:42:35,860
my implementation I only needed the

914
00:42:35,860 --> 00:42:38,910
subset of field so I

915
00:42:41,480 --> 00:42:43,560
but I had to switch back to the other

916
00:42:43,560 --> 00:42:47,030
one in order to use the unmodified code

917
00:42:47,030 --> 00:42:50,610
the other thing was the crypto and the

918
00:42:50,610 --> 00:42:53,550
HVAC were all in one file so I split

919
00:42:53,550 --> 00:42:55,170
those into two separate files so that I

920
00:42:55,170 --> 00:42:56,490
could include only the bits that I

921
00:42:56,490 --> 00:42:59,700
needed in particular I didn't want the

922
00:42:59,700 --> 00:43:01,410
crypto bits from the kernel version of

923
00:43:01,410 --> 00:43:03,030
gely because it used the kernels crypto

924
00:43:03,030 --> 00:43:05,970
framework and I wanted to use just the

925
00:43:05,970 --> 00:43:08,490
straight stuff I had which doesn't

926
00:43:08,490 --> 00:43:10,170
support acceleration or multiple threads

927
00:43:10,170 --> 00:43:13,050
but in the case of the bootloader that's

928
00:43:13,050 --> 00:43:18,840
all I wanted to have and then the other

929
00:43:18,840 --> 00:43:21,650
problem was that a couple of places

930
00:43:21,650 --> 00:43:24,780
there was kernel only stuff so I had to

931
00:43:24,780 --> 00:43:27,810
add some if def kernels to gely so that

932
00:43:27,810 --> 00:43:29,520
I could the code would compile in usual

933
00:43:29,520 --> 00:43:32,070
and so then I had to move a couple of

934
00:43:32,070 --> 00:43:34,050
things around but it was only minor

935
00:43:34,050 --> 00:43:39,840
stuff so once all that was working

936
00:43:39,840 --> 00:43:43,350
I tried booting off as NFS Mir which

937
00:43:43,350 --> 00:43:44,670
resulted in me having to type in the

938
00:43:44,670 --> 00:43:48,990
password six times once for each disk in

939
00:43:48,990 --> 00:43:50,880
the bootstrap and then once for each

940
00:43:50,880 --> 00:43:53,160
disk in the bootloader and then once for

941
00:43:53,160 --> 00:43:55,260
each disk when the kernel actually

942
00:43:55,260 --> 00:43:58,200
starts it before metric I was like

943
00:43:58,200 --> 00:44:01,860
that's a lot it's like what if I have a

944
00:44:01,860 --> 00:44:05,670
raids ed of six disks that's gonna take

945
00:44:05,670 --> 00:44:09,960
it all day so previously Colin first of

946
00:44:09,960 --> 00:44:12,180
all had done some work with Devon Teske

947
00:44:12,180 --> 00:44:17,280
and Chris Moore to create a system for

948
00:44:17,280 --> 00:44:19,710
this so Colin originally created a

949
00:44:19,710 --> 00:44:22,140
password caching system in gely so that

950
00:44:22,140 --> 00:44:24,000
when you decrypt the first disk it

951
00:44:24,000 --> 00:44:26,310
caches the password until it's done

952
00:44:26,310 --> 00:44:29,130
mounting all disks and it attempts that

953
00:44:29,130 --> 00:44:31,530
password on the next disk if it's wrong

954
00:44:31,530 --> 00:44:32,880
it doesn't count against your three

955
00:44:32,880 --> 00:44:34,500
attempts didn't let Reap romped you but

956
00:44:34,500 --> 00:44:36,210
if it's the right pass phrase you only

957
00:44:36,210 --> 00:44:37,410
have to type it in once for all your

958
00:44:37,410 --> 00:44:40,590
disks so I was like I will shamelessly

959
00:44:40,590 --> 00:44:43,190
steal that concept and applied it to the

960
00:44:43,190 --> 00:44:46,230
boot strap and the bootloader so now

961
00:44:46,230 --> 00:44:48,180
when you boot with two disks or three

962
00:44:48,180 --> 00:44:49,170
days you only have to type the password

963
00:44:49,170 --> 00:44:54,150
in three times but : it also worked out

964
00:44:54,150 --> 00:44:55,290
a way to pass

965
00:44:55,290 --> 00:44:57,120
pass phrase from the bootloader to the

966
00:44:57,120 --> 00:45:00,270
kernel because Chris more one to replace

967
00:45:00,270 --> 00:45:03,660
grub in pc-bsd and evident s key had

968
00:45:03,660 --> 00:45:06,180
wanted to move the prompt for your

969
00:45:06,180 --> 00:45:08,790
password into the bootloader because

970
00:45:08,790 --> 00:45:10,800
when it's done by the kernel late

971
00:45:10,800 --> 00:45:13,020
arriving USB devices could overwrite the

972
00:45:13,020 --> 00:45:15,330
prompt with D message stuff and then you

973
00:45:15,330 --> 00:45:17,130
don't realize that the reason your

974
00:45:17,130 --> 00:45:17,970
machine is just sitting there not

975
00:45:17,970 --> 00:45:20,190
booting is because it's waiting for you

976
00:45:20,190 --> 00:45:23,970
to type in the password so I reused that

977
00:45:23,970 --> 00:45:26,700
mechanism to pass the password from the

978
00:45:26,700 --> 00:45:28,770
loader to the kernel so now you're down

979
00:45:28,770 --> 00:45:32,280
to two copies of the password being

980
00:45:32,280 --> 00:45:35,430
entered to boot so then I actually

981
00:45:35,430 --> 00:45:37,830
looked at how ZFS has the answer for

982
00:45:37,830 --> 00:45:39,870
this how do I pass data from the

983
00:45:39,870 --> 00:45:42,570
bootstrap to the bootloader so that if s

984
00:45:42,570 --> 00:45:44,900
have been doing this by passing the

985
00:45:44,900 --> 00:45:48,270
zpool ID number so that it knows which

986
00:45:48,270 --> 00:45:51,060
zpool you're trying to boot from the way

987
00:45:51,060 --> 00:45:52,620
it does this because it has to pass a

988
00:45:52,620 --> 00:45:54,690
couple of bits of data is it passed as a

989
00:45:54,690 --> 00:45:56,730
struct and the very first member of that

990
00:45:56,730 --> 00:45:59,430
struct is a size which is the size of

991
00:45:59,430 --> 00:46:03,630
that struct this way if the code is out

992
00:46:03,630 --> 00:46:06,120
of sync and you have say a newer boot

993
00:46:06,120 --> 00:46:07,650
code but an older loader or the other

994
00:46:07,650 --> 00:46:08,190
way around

995
00:46:08,190 --> 00:46:10,890
the loader in every time before it

996
00:46:10,890 --> 00:46:12,960
accesses any member of the struct it

997
00:46:12,960 --> 00:46:15,240
checks if the offset of that member of

998
00:46:15,240 --> 00:46:18,750
the struct is greater than the size if

999
00:46:18,750 --> 00:46:22,860
it is then it knows that its definition

1000
00:46:22,860 --> 00:46:26,820
of the struct is older and so that you

1001
00:46:26,820 --> 00:46:28,110
know anything that's going to be off the

1002
00:46:28,110 --> 00:46:31,710
end it won't try to read so this way we

1003
00:46:31,710 --> 00:46:33,420
have forwards and backwards

1004
00:46:33,420 --> 00:46:36,450
compatibility right the if it's if I add

1005
00:46:36,450 --> 00:46:38,490
a new field to the struct the loader is

1006
00:46:38,490 --> 00:46:40,890
going to make sure that its definition

1007
00:46:40,890 --> 00:46:43,350
of the struct is new enough or the

1008
00:46:43,350 --> 00:46:45,570
struct being passed by the bootstrap is

1009
00:46:45,570 --> 00:46:47,820
big enough right so if the bootstrap is

1010
00:46:47,820 --> 00:46:49,680
older and passes the strike that doesn't

1011
00:46:49,680 --> 00:46:53,010
have say our new password member then

1012
00:46:53,010 --> 00:46:55,080
the offset of that member is going to be

1013
00:46:55,080 --> 00:46:57,060
smaller than the size that the

1014
00:46:57,060 --> 00:46:59,000
bootloader passed and it won't go read

1015
00:46:59,000 --> 00:47:02,760
uninitiated Ischl eyes memory thinking

1016
00:47:02,760 --> 00:47:04,800
it's passphrase it'll know that

1017
00:47:04,800 --> 00:47:06,750
bootstrap is older and just didn't give

1018
00:47:06,750 --> 00:47:09,150
us a password

1019
00:47:09,150 --> 00:47:13,720
so I hacked onto that and basically

1020
00:47:13,720 --> 00:47:15,640
added a galley password field to the end

1021
00:47:15,640 --> 00:47:17,470
of the strike that gets passed and then

1022
00:47:17,470 --> 00:47:18,490
gets zeroed out

1023
00:47:18,490 --> 00:47:21,670
and so I implemented the exact same

1024
00:47:21,670 --> 00:47:24,520
thing for ufs so now we can pass

1025
00:47:24,520 --> 00:47:26,349
parameters and we can always grow the

1026
00:47:26,349 --> 00:47:27,609
list of parameters and it's backwards

1027
00:47:27,609 --> 00:47:31,839
and forwards compatible so now you only

1028
00:47:31,839 --> 00:47:32,950
have protecting your password in the

1029
00:47:32,950 --> 00:47:35,530
bootstrap and it passes it to the loader

1030
00:47:35,530 --> 00:47:37,150
and then the loader passes it to the

1031
00:47:37,150 --> 00:47:44,410
kernel and the system boots so that's

1032
00:47:44,410 --> 00:47:48,790
how it works so the things that aren't

1033
00:47:48,790 --> 00:47:52,000
finished are that currently only

1034
00:47:52,000 --> 00:47:54,280
supports passwords right you type in a

1035
00:47:54,280 --> 00:47:57,190
password gely has always supported keys

1036
00:47:57,190 --> 00:47:58,900
where you can have like a USB key or

1037
00:47:58,900 --> 00:48:00,910
like a four kilobyte file with

1038
00:48:00,910 --> 00:48:03,430
randomness that you can throw into the

1039
00:48:03,430 --> 00:48:07,750
mix for your encryption and the

1040
00:48:07,750 --> 00:48:08,859
bootloader currently doesn't support

1041
00:48:08,859 --> 00:48:09,460
that at all

1042
00:48:09,460 --> 00:48:12,069
I'd like to add that but it's gonna be a

1043
00:48:12,069 --> 00:48:14,770
little complicated because where do you

1044
00:48:14,770 --> 00:48:18,160
store those keys based on a bunch of

1045
00:48:18,160 --> 00:48:20,230
conversations if I had I think the

1046
00:48:20,230 --> 00:48:21,640
easiest way is actually to create a new

1047
00:48:21,640 --> 00:48:23,920
partition type like FreeBSD - jelly key

1048
00:48:23,920 --> 00:48:26,440
and we can just say have a USB stick

1049
00:48:26,440 --> 00:48:27,849
that'll have this specially defined

1050
00:48:27,849 --> 00:48:30,099
partition it'll be whatever size you

1051
00:48:30,099 --> 00:48:32,410
want and it'll just contained raw key

1052
00:48:32,410 --> 00:48:34,630
data rather than the filesystem or

1053
00:48:34,630 --> 00:48:38,500
something I don't know how well USB keys

1054
00:48:38,500 --> 00:48:40,480
show up in the bootloader in this case

1055
00:48:40,480 --> 00:48:42,220
and in particular what happens if you

1056
00:48:42,220 --> 00:48:45,130
try to attach one too late you know if

1057
00:48:45,130 --> 00:48:47,650
you have to reboot to attach your key

1058
00:48:47,650 --> 00:48:48,819
every time you want to decrypt your

1059
00:48:48,819 --> 00:48:53,290
drive it'll be kind of annoying jelly

1060
00:48:53,290 --> 00:48:55,569
itself supports blow phishing camellia

1061
00:48:55,569 --> 00:48:58,420
ciphers for disk encryption as well but

1062
00:48:58,420 --> 00:48:59,980
I don't think there's that much interest

1063
00:48:59,980 --> 00:49:02,920
in them because with AES and I using AES

1064
00:49:02,920 --> 00:49:05,589
XTS is the only way to get no

1065
00:49:05,589 --> 00:49:07,060
performance degradation from using

1066
00:49:07,060 --> 00:49:08,980
encryption so I think it's fine to not

1067
00:49:08,980 --> 00:49:13,260
bother implementing those algorithms

1068
00:49:13,260 --> 00:49:15,550
jelly also supports sector

1069
00:49:15,550 --> 00:49:16,780
authentication where it actually has an

1070
00:49:16,780 --> 00:49:18,970
H Mac of each sector so your sectors

1071
00:49:18,970 --> 00:49:21,700
have a little bit of extra data

1072
00:49:21,700 --> 00:49:23,920
turns out that's not used very much and

1073
00:49:23,920 --> 00:49:25,540
especially in our case if you're using

1074
00:49:25,540 --> 00:49:28,720
ZFS you already have a checksum so don't

1075
00:49:28,720 --> 00:49:30,040
bother with it

1076
00:49:30,040 --> 00:49:33,310
and then the big limitation currently is

1077
00:49:33,310 --> 00:49:36,100
it doesn't support the EU fi booting

1078
00:49:36,100 --> 00:49:38,490
although Eric McCorkle has a review out

1079
00:49:38,490 --> 00:49:41,280
for a version that implements it there

1080
00:49:41,280 --> 00:49:44,170
completely differently but hopefully

1081
00:49:44,170 --> 00:49:45,760
that will go through and then we can

1082
00:49:45,760 --> 00:49:50,260
have it for everything and then once

1083
00:49:50,260 --> 00:49:52,330
that's done can we actually improve my

1084
00:49:52,330 --> 00:49:59,920
code to make it closer to his code then

1085
00:49:59,920 --> 00:50:01,090
there's a couple other things I'd like

1086
00:50:01,090 --> 00:50:04,120
to do someday in Delhi I'd like to

1087
00:50:04,120 --> 00:50:06,310
consider replacing all the Shah 2z6 bits

1088
00:50:06,310 --> 00:50:09,480
with sha-512 truncated to 256 bits

1089
00:50:09,480 --> 00:50:13,150
because on 64-bit AMD 64 processors

1090
00:50:13,150 --> 00:50:15,760
anyway a shop 512 is about 50 percent

1091
00:50:15,760 --> 00:50:19,480
faster now I can't make the hash longer

1092
00:50:19,480 --> 00:50:22,210
because all the metadata only has room

1093
00:50:22,210 --> 00:50:25,540
for 256 bits of data but to steal the

1094
00:50:25,540 --> 00:50:27,700
trick from ZFS I could use the shop 512

1095
00:50:27,700 --> 00:50:30,850
and just truncate it then there's

1096
00:50:30,850 --> 00:50:33,160
various other cleanups that I'd like to

1097
00:50:33,160 --> 00:50:35,230
go you know fix all those get stir bugs

1098
00:50:35,230 --> 00:50:38,620
and so on and get back to creating just

1099
00:50:38,620 --> 00:50:40,180
one unified bootloader they can do you

1100
00:50:40,180 --> 00:50:43,000
FSM ZFS instead of having to have two

1101
00:50:43,000 --> 00:50:46,720
separate ones for that also after

1102
00:50:46,720 --> 00:50:48,220
playing with jelly so much I realized

1103
00:50:48,220 --> 00:50:50,890
how nice and elegant it is and I it

1104
00:50:50,890 --> 00:50:52,900
might be cool to create a fuse or other

1105
00:50:52,900 --> 00:50:54,700
kind of implementation for it

1106
00:50:54,700 --> 00:50:56,290
so that you could use jelly and other

1107
00:50:56,290 --> 00:50:58,720
operating systems especially you know

1108
00:50:58,720 --> 00:51:00,430
well half the point of Zetas fast is

1109
00:51:00,430 --> 00:51:03,160
that it's a file system that's portable

1110
00:51:03,160 --> 00:51:04,390
and you can take it to another computer

1111
00:51:04,390 --> 00:51:06,400
and just like it in and it works ah if

1112
00:51:06,400 --> 00:51:08,350
you can have a jelly encrypted USB stick

1113
00:51:08,350 --> 00:51:10,000
was that FS on it it'd be great to be

1114
00:51:10,000 --> 00:51:11,770
able to mount that under Linux or a

1115
00:51:11,770 --> 00:51:15,010
Lumos or something and you know I'd love

1116
00:51:15,010 --> 00:51:18,270
to hear your ideas of what else to do

1117
00:51:23,090 --> 00:51:26,610
I talked a little bit about that

1118
00:51:26,610 --> 00:51:28,350
yesterday at the previous D dev summit

1119
00:51:28,350 --> 00:51:31,080
with depth East it's like so then resume

1120
00:51:31,080 --> 00:51:32,880
hasn't been great on previously it works

1121
00:51:32,880 --> 00:51:35,010
on my laptop but not newer ones but

1122
00:51:35,010 --> 00:51:37,740
suspend to disk would be great and it

1123
00:51:37,740 --> 00:51:40,080
can't be that hard right so just just

1124
00:51:40,080 --> 00:51:43,470
force it crash dump force a crash dump

1125
00:51:43,470 --> 00:51:45,870
and then have the loader just load that

1126
00:51:45,870 --> 00:51:48,080
back into memory and turn on again right

1127
00:51:48,080 --> 00:51:58,050
it'll be easy ok does that be nice too

1128
00:51:58,050 --> 00:52:01,140
uh and yes here's the advanced set of s

1129
00:52:01,140 --> 00:52:04,230
book that Michael and I wrote you can

1130
00:52:04,230 --> 00:52:09,600
get that at Zetas facebook.com/ yes and

1131
00:52:09,600 --> 00:52:12,480
I do a podcast VST now that TV every

1132
00:52:12,480 --> 00:52:15,540
Wednesday we interview developers about

1133
00:52:15,540 --> 00:52:17,460
things and talk about what's changed in

1134
00:52:17,460 --> 00:52:21,210
FreeBSD and OpenBSD and so on that's

1135
00:52:21,210 --> 00:52:24,730
good that's it

1136
00:52:24,730 --> 00:52:35,460
[Applause]

