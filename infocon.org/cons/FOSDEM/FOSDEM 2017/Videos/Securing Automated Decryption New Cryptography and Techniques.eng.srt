1
00:00:00,000 --> 00:00:03,399
[Applause]

2
00:00:07,490 --> 00:00:10,830
so I will actually ask for a little bit

3
00:00:10,830 --> 00:00:13,679
of patience today my slides are actually

4
00:00:13,679 --> 00:00:17,220
being hosted in the cloud and the data

5
00:00:17,220 --> 00:00:18,750
center apparently has had a massive

6
00:00:18,750 --> 00:00:21,240
disaster the entire data center lost

7
00:00:21,240 --> 00:00:21,840
power

8
00:00:21,840 --> 00:00:25,470
all systems are down and but at least

9
00:00:25,470 --> 00:00:27,390
they're very good at transparency so

10
00:00:27,390 --> 00:00:29,880
they give us a live feed of them

11
00:00:29,880 --> 00:00:33,000
bringing up the system the and so we can

12
00:00:33,000 --> 00:00:37,079
actually see what we've apparently all

13
00:00:37,079 --> 00:00:38,790
the servers are requiring passwords to

14
00:00:38,790 --> 00:00:40,950
boot because they have encrypted drives

15
00:00:40,950 --> 00:00:44,640
and so we have guys Fleur

16
00:00:44,640 --> 00:00:47,160
you know quickly running around the data

17
00:00:47,160 --> 00:00:48,300
center trying to type in all these

18
00:00:48,300 --> 00:00:49,590
passwords to bring up these these

19
00:00:49,590 --> 00:00:54,059
thousands of systems and so this is

20
00:00:54,059 --> 00:00:56,039
obviously not scalable in the long term

21
00:00:56,039 --> 00:01:00,570
and so we actually have I want to give

22
00:01:00,570 --> 00:01:01,920
you a look of where we've sort of been

23
00:01:01,920 --> 00:01:04,050
in the past where we are today and where

24
00:01:04,050 --> 00:01:06,170
we're going in the future

25
00:01:06,170 --> 00:01:08,670
yesterday we were working on standards

26
00:01:08,670 --> 00:01:11,939
these are things like AES things like in

27
00:01:11,939 --> 00:01:14,790
the United States PCI DSS these make

28
00:01:14,790 --> 00:01:17,010
sure that everyone is using encryption

29
00:01:17,010 --> 00:01:18,540
at the right time and in the right way

30
00:01:18,540 --> 00:01:20,790
and making sure that with that when they

31
00:01:20,790 --> 00:01:22,590
do encryption that it's done in

32
00:01:22,590 --> 00:01:24,780
standards ways so yesterday was mostly

33
00:01:24,780 --> 00:01:27,840
about developing standards today however

34
00:01:27,840 --> 00:01:29,900
we are actually moving beyond

35
00:01:29,900 --> 00:01:31,740
standardization process of course

36
00:01:31,740 --> 00:01:34,200
standardization will continue but we are

37
00:01:34,200 --> 00:01:35,939
now starting to worry about the question

38
00:01:35,939 --> 00:01:38,549
of automation how do we actually make

39
00:01:38,549 --> 00:01:41,759
decryption happen automatically and then

40
00:01:41,759 --> 00:01:44,310
tomorrow we are going to be working on

41
00:01:44,310 --> 00:01:46,259
policy and the reason for this is that

42
00:01:46,259 --> 00:01:48,509
right now we're just trying to work on a

43
00:01:48,509 --> 00:01:51,720
simple binary so you can see the

44
00:01:51,720 --> 00:01:53,149
automation is just an on and off switch

45
00:01:53,149 --> 00:01:56,189
right can i unlock automatically yes or

46
00:01:56,189 --> 00:01:58,110
no and we're trying very desperately to

47
00:01:58,110 --> 00:02:00,659
make that a reality but in fact what's

48
00:02:00,659 --> 00:02:01,979
going to happen once we've achieved that

49
00:02:01,979 --> 00:02:04,020
goal we're also going to quickly realize

50
00:02:04,020 --> 00:02:06,600
that we want to be able to automatically

51
00:02:06,600 --> 00:02:07,860
decrypt in a variety of circumstances

52
00:02:07,860 --> 00:02:10,729
and we want a variety of different

53
00:02:10,729 --> 00:02:15,060
policies to to give us something that's

54
00:02:15,060 --> 00:02:17,340
a more a more structured scale so you

55
00:02:17,340 --> 00:02:18,480
see the slider

56
00:02:18,480 --> 00:02:21,840
for our policy so the first question is

57
00:02:21,840 --> 00:02:25,590
how do we automate well we all start out

58
00:02:25,590 --> 00:02:27,090
with a secret of course this is the

59
00:02:27,090 --> 00:02:28,320
thing that we're trying to encrypt and

60
00:02:28,320 --> 00:02:31,260
then later decrypt then we wrap it into

61
00:02:31,260 --> 00:02:33,510
something called an encryption key this

62
00:02:33,510 --> 00:02:35,940
is the symmetric key usually that that

63
00:02:35,940 --> 00:02:38,010
actually encrypts the secret itself and

64
00:02:38,010 --> 00:02:40,470
then the encryption key itself is ripped

65
00:02:40,470 --> 00:02:42,600
is encrypted in a key encryption key and

66
00:02:42,600 --> 00:02:44,820
so this is the pretty standard model you

67
00:02:44,820 --> 00:02:47,580
see everywhere if you are involved in

68
00:02:47,580 --> 00:02:49,830
decryption standards if you've ever

69
00:02:49,830 --> 00:02:51,930
evaluated how lux works for instance on

70
00:02:51,930 --> 00:02:54,420
Linux this is a pretty standard model of

71
00:02:54,420 --> 00:02:56,910
how things work and then what we do is

72
00:02:56,910 --> 00:02:58,800
we have this key encryption key beasts

73
00:02:58,800 --> 00:03:01,050
usually something like a password so we

74
00:03:01,050 --> 00:03:03,330
see here from xkcd correct battery or a

75
00:03:03,330 --> 00:03:05,610
staple wonderful password and then we

76
00:03:05,610 --> 00:03:07,260
share that password around with a bunch

77
00:03:07,260 --> 00:03:09,150
of people now obviously this is the

78
00:03:09,150 --> 00:03:10,350
system that we're trying to move away

79
00:03:10,350 --> 00:03:13,500
from and we don't like the fact that we

80
00:03:13,500 --> 00:03:15,600
have to share this key encryption key

81
00:03:15,600 --> 00:03:18,210
with with everyone because of course one

82
00:03:18,210 --> 00:03:20,520
of those people goes rogue then we've

83
00:03:20,520 --> 00:03:24,510
lost our data so what we do instead is

84
00:03:24,510 --> 00:03:27,990
we create a much stronger key something

85
00:03:27,990 --> 00:03:30,510
that is cryptographically strong and

86
00:03:30,510 --> 00:03:33,120
then we store it in an escrow remotely

87
00:03:33,120 --> 00:03:35,850
and when we want when we want to be able

88
00:03:35,850 --> 00:03:37,800
to unlock our data we just simply fetch

89
00:03:37,800 --> 00:03:39,540
the key back from the escrow has

90
00:03:39,540 --> 00:03:41,070
everybody seen something like this raise

91
00:03:41,070 --> 00:03:43,590
your hand if you've seen a system like

92
00:03:43,590 --> 00:03:45,440
this am I done

93
00:03:45,440 --> 00:03:48,420
describing the architecture because it

94
00:03:48,420 --> 00:03:52,260
seems pretty simple right well

95
00:03:52,260 --> 00:03:53,670
unfortunately we have to encrypt this

96
00:03:53,670 --> 00:03:56,520
channel right because we can't just ship

97
00:03:56,520 --> 00:03:58,290
keys back and forth and so now we're

98
00:03:58,290 --> 00:04:00,330
usually doing TLS most commonly or

99
00:04:00,330 --> 00:04:03,030
gssapi in order to create an encrypted

100
00:04:03,030 --> 00:04:05,130
channel to be able to send the keys with

101
00:04:05,130 --> 00:04:08,940
and then finally we're done no

102
00:04:08,940 --> 00:04:10,410
unfortunately we actually have to

103
00:04:10,410 --> 00:04:12,000
authenticate to the escrow server

104
00:04:12,000 --> 00:04:15,000
because we can't just you know ship off

105
00:04:15,000 --> 00:04:17,459
keys to some remote entity in hope that

106
00:04:17,459 --> 00:04:19,440
it's the right person so we have to

107
00:04:19,440 --> 00:04:21,720
authenticate the escrow and now we're

108
00:04:21,720 --> 00:04:26,070
done right No so we also have to

109
00:04:26,070 --> 00:04:27,510
authenticate client to the escrow

110
00:04:27,510 --> 00:04:30,270
because we have to guarantee that when

111
00:04:30,270 --> 00:04:31,800
they were fetch back a key

112
00:04:31,800 --> 00:04:32,970
that they can't just get any key that

113
00:04:32,970 --> 00:04:34,919
they want they can only get the keys for

114
00:04:34,919 --> 00:04:36,210
instance that they push do you know that

115
00:04:36,210 --> 00:04:39,240
the policy allows them to have so at

116
00:04:39,240 --> 00:04:42,419
least finally we're done well

117
00:04:42,419 --> 00:04:44,069
unfortunately we actually need a chain

118
00:04:44,069 --> 00:04:45,840
of trust in order to do all of these

119
00:04:45,840 --> 00:04:48,389
authentications and the encryption layer

120
00:04:48,389 --> 00:04:50,280
this is usually done through a

121
00:04:50,280 --> 00:04:53,009
certification Authority with the route

122
00:04:53,009 --> 00:04:55,349
of trust there perhaps many intermediary

123
00:04:55,349 --> 00:04:57,840
layers or this is done if you're using

124
00:04:57,840 --> 00:04:59,879
gssapi for instance this is done with a

125
00:04:59,879 --> 00:05:02,729
with a ktc well at least now we're done

126
00:05:02,729 --> 00:05:04,440
and we have a very simple architecture

127
00:05:04,440 --> 00:05:07,560
oh I forgot about backups so now we have

128
00:05:07,560 --> 00:05:09,270
to back up all of this state right

129
00:05:09,270 --> 00:05:10,680
because we've got all of these keys

130
00:05:10,680 --> 00:05:13,830
stored in the escrow and if we were to

131
00:05:13,830 --> 00:05:16,740
lose that data we are sunk right because

132
00:05:16,740 --> 00:05:18,870
all of our data is encrypted with with

133
00:05:18,870 --> 00:05:21,110
these keys so we've got to back up those

134
00:05:21,110 --> 00:05:23,280
back up all of those keys but we also

135
00:05:23,280 --> 00:05:25,979
have to back up the entire the entire

136
00:05:25,979 --> 00:05:28,770
route of trust on the left-hand side as

137
00:05:28,770 --> 00:05:30,360
well and then of course all of these

138
00:05:30,360 --> 00:05:35,190
backups have to be secured so at least

139
00:05:35,190 --> 00:05:37,469
finally we have arrived at the standard

140
00:05:37,469 --> 00:05:39,539
escrow model and this is pretty much

141
00:05:39,539 --> 00:05:41,520
what you see tons of vendors or shipping

142
00:05:41,520 --> 00:05:44,610
products like this and if you've ever

143
00:05:44,610 --> 00:05:46,050
hacked together some kind of an

144
00:05:46,050 --> 00:05:49,560
automation for early boot unlocking your

145
00:05:49,560 --> 00:05:51,960
system most likely looks something like

146
00:05:51,960 --> 00:05:52,560
this

147
00:05:52,560 --> 00:05:54,810
and it works really great we don't ever

148
00:05:54,810 --> 00:05:57,029
have any problems with this system at

149
00:05:57,029 --> 00:05:59,490
all oh wait

150
00:05:59,490 --> 00:06:02,190
so I guess heartbleed would kind of

151
00:06:02,190 --> 00:06:05,610
throw a kink in this we would be able to

152
00:06:05,610 --> 00:06:07,680
just read all of the keys off the wire

153
00:06:07,680 --> 00:06:11,849
as they were coming in so we decided we

154
00:06:11,849 --> 00:06:14,550
want to do something that that's better

155
00:06:14,550 --> 00:06:17,129
we've learned a few lessons from this

156
00:06:17,129 --> 00:06:19,440
architecture first we learned that

157
00:06:19,440 --> 00:06:21,300
presuming that TLS will protect the key

158
00:06:21,300 --> 00:06:23,849
transfer is dangerous because all it

159
00:06:23,849 --> 00:06:27,060
takes is a single a single flaw in the

160
00:06:27,060 --> 00:06:28,830
entirety of TLS which is a pretty large

161
00:06:28,830 --> 00:06:32,190
specification in order to and a pretty

162
00:06:32,190 --> 00:06:35,610
large implementation as well any mistake

163
00:06:35,610 --> 00:06:37,590
there any flaw there can leak our keys

164
00:06:37,590 --> 00:06:39,719
we also learned that the complexity

165
00:06:39,719 --> 00:06:41,909
increases our attack surface so when we

166
00:06:41,909 --> 00:06:42,839
had all of these different entities

167
00:06:42,839 --> 00:06:44,750
doing these different things

168
00:06:44,750 --> 00:06:47,030
you realize that of course there's a lot

169
00:06:47,030 --> 00:06:48,590
of places to attack we can attack the

170
00:06:48,590 --> 00:06:50,690
backup system we can have attacked the

171
00:06:50,690 --> 00:06:53,540
the route of trust we can attack the TLS

172
00:06:53,540 --> 00:06:55,570
channel we can attack the escrow itself

173
00:06:55,570 --> 00:06:58,160
and because of all of this we've also

174
00:06:58,160 --> 00:06:59,660
learned that escrows are difficult to

175
00:06:59,660 --> 00:07:02,150
deploy not only do you just deploy in

176
00:07:02,150 --> 00:07:04,250
escrow but you deploy everything that

177
00:07:04,250 --> 00:07:06,800
goes around it finally one of the things

178
00:07:06,800 --> 00:07:08,540
that we learned actually in user testing

179
00:07:08,540 --> 00:07:11,360
is that x.509 is really hard to get

180
00:07:11,360 --> 00:07:12,740
right

181
00:07:12,740 --> 00:07:14,810
so even if you've done everything

182
00:07:14,810 --> 00:07:16,310
correctly

183
00:07:16,310 --> 00:07:19,580
just the x.509 part of it we very often

184
00:07:19,580 --> 00:07:22,400
gotten a malformed certificates we got

185
00:07:22,400 --> 00:07:23,900
certificates that were signed in

186
00:07:23,900 --> 00:07:26,150
properly all sorts of stuff that we've

187
00:07:26,150 --> 00:07:28,220
seen in the wild and so it's just very

188
00:07:28,220 --> 00:07:30,680
hard to get right and our very simple

189
00:07:30,680 --> 00:07:32,780
system of just taking a keys during it

190
00:07:32,780 --> 00:07:34,130
remotely and fetching it back has

191
00:07:34,130 --> 00:07:37,669
suddenly become incredibly complex so

192
00:07:37,669 --> 00:07:39,410
the question that we wanted to ask was

193
00:07:39,410 --> 00:07:42,919
can asymmetric crypto help us with this

194
00:07:42,919 --> 00:07:46,520
problem so one of the things we realized

195
00:07:46,520 --> 00:07:50,180
in this process is that what we are

196
00:07:50,180 --> 00:07:52,370
actually doing is really a kind of a key

197
00:07:52,370 --> 00:07:54,590
exchange now I will ask you to brace

198
00:07:54,590 --> 00:07:56,990
yourself because math is coming on the

199
00:07:56,990 --> 00:07:59,750
next slide so if you're allergic to math

200
00:07:59,750 --> 00:08:02,180
please stand up and leave the auditorium

201
00:08:02,180 --> 00:08:06,050
so this is a standard diffie-hellman key

202
00:08:06,050 --> 00:08:08,330
exchange is this readable by the way can

203
00:08:08,330 --> 00:08:10,419
you read it no oh man I'm really sorry

204
00:08:10,419 --> 00:08:13,070
so this is a standard diffie-hellman key

205
00:08:13,070 --> 00:08:16,729
exchange which party generates a private

206
00:08:16,729 --> 00:08:18,860
key uses a private key to calculate a

207
00:08:18,860 --> 00:08:20,720
public key they exchange their public

208
00:08:20,720 --> 00:08:22,550
keys and then they can both calculate K

209
00:08:22,550 --> 00:08:25,400
so is everybody pretty familiar or at

210
00:08:25,400 --> 00:08:27,140
least has heard about diffie-hellman and

211
00:08:27,140 --> 00:08:32,570
how it sort of works okay so I don't

212
00:08:32,570 --> 00:08:34,849
want to go too far okay so we wanted to

213
00:08:34,849 --> 00:08:37,099
we wondered if we could take ECB H

214
00:08:37,099 --> 00:08:39,679
elliptic curve diffie-hellman and if we

215
00:08:39,679 --> 00:08:41,390
could just essentially make our

216
00:08:41,390 --> 00:08:44,300
unlocking process a key exchange and so

217
00:08:44,300 --> 00:08:47,450
on the left-hand side you see a diffi

218
00:08:47,450 --> 00:08:49,310
Hellman but it just sort of rearranged

219
00:08:49,310 --> 00:08:51,290
nothing on here is mathematically any

220
00:08:51,290 --> 00:08:53,690
different than diffie-hellman we're just

221
00:08:53,690 --> 00:08:55,400
doing the steps in a particular order

222
00:08:55,400 --> 00:08:57,890
okay so nothing on this analyte is

223
00:08:57,890 --> 00:08:58,499
different from

224
00:08:58,499 --> 00:09:02,549
phenomena on the left-hand side we have

225
00:09:02,549 --> 00:09:05,429
the provisioning step the first thing

226
00:09:05,429 --> 00:09:08,189
that happens is a server generates a

227
00:09:08,189 --> 00:09:10,709
private key uses the private key to

228
00:09:10,709 --> 00:09:12,659
calculate a public key and then shares

229
00:09:12,659 --> 00:09:16,019
that key to whomever would ask for it so

230
00:09:16,019 --> 00:09:17,519
now you can get as the client you can

231
00:09:17,519 --> 00:09:19,139
get the public key you can either get it

232
00:09:19,139 --> 00:09:20,909
by contacting the server you can get it

233
00:09:20,909 --> 00:09:23,699
by passing it offline somehow but the

234
00:09:23,699 --> 00:09:25,139
client is able to get the server's

235
00:09:25,139 --> 00:09:28,349
public key now the client does it it's a

236
00:09:28,349 --> 00:09:30,149
bit when it wants to encrypt the data so

237
00:09:30,149 --> 00:09:31,679
all the provisioning is the is the

238
00:09:31,679 --> 00:09:35,639
encryption side so the client then

239
00:09:35,639 --> 00:09:38,879
generates its own private key generates

240
00:09:38,879 --> 00:09:40,739
a public uses the private key to

241
00:09:40,739 --> 00:09:43,109
calculate a public key performs the

242
00:09:43,109 --> 00:09:47,009
diffie-hellman exchange and gets k.k is

243
00:09:47,009 --> 00:09:50,119
the key that's then used for encryption

244
00:09:50,119 --> 00:09:53,189
once encryption is done we then discard

245
00:09:53,189 --> 00:09:56,879
kay and we also discard the clients

246
00:09:56,879 --> 00:09:59,999
private key and what this means is that

247
00:09:59,999 --> 00:10:02,429
the client can no longer calculate K it

248
00:10:02,429 --> 00:10:05,209
doesn't have K and it can't calculate it

249
00:10:05,209 --> 00:10:08,429
we do have a retain the public keys s

250
00:10:08,429 --> 00:10:12,269
and C s is the server's public key and C

251
00:10:12,269 --> 00:10:16,169
is the clients club public key and then

252
00:10:16,169 --> 00:10:18,029
when we want to do our decryption we can

253
00:10:18,029 --> 00:10:20,609
take our public key and we can send it

254
00:10:20,609 --> 00:10:23,249
to the server the server does its half

255
00:10:23,249 --> 00:10:24,959
of the diffie-hellman and calculates K

256
00:10:24,959 --> 00:10:27,569
and sends K back to us now this is

257
00:10:27,569 --> 00:10:29,369
fantastic because this is a lot lighter

258
00:10:29,369 --> 00:10:31,769
than what we saw on the escrow model and

259
00:10:31,769 --> 00:10:34,259
in fact the server notice has no state

260
00:10:34,259 --> 00:10:35,159
whatsoever

261
00:10:35,159 --> 00:10:39,649
the server is just a key that's all

262
00:10:39,649 --> 00:10:41,759
unfortunately this mode is completely

263
00:10:41,759 --> 00:10:45,929
insecure because if you share key on the

264
00:10:45,929 --> 00:10:48,720
network if you share key C excuse me the

265
00:10:48,720 --> 00:10:51,779
clients public key on the network then

266
00:10:51,779 --> 00:10:54,149
anyone can take that key and can

267
00:10:54,149 --> 00:10:56,069
calculate K by asking the server to do

268
00:10:56,069 --> 00:11:00,419
it similarly the BK the key that we

269
00:11:00,419 --> 00:11:01,919
actually want to protect is now coming

270
00:11:01,919 --> 00:11:03,839
back over the network in plaintext and

271
00:11:03,839 --> 00:11:07,139
of course we don't like that either so

272
00:11:07,139 --> 00:11:09,419
we have some weaknesses K is revealed to

273
00:11:09,419 --> 00:11:11,339
any passive attackers

274
00:11:11,339 --> 00:11:13,740
with C so if they store sieve and they

275
00:11:13,740 --> 00:11:16,199
can later do a replay and they can get

276
00:11:16,199 --> 00:11:19,860
back K and third the server learns both

277
00:11:19,860 --> 00:11:24,240
C and therefore okay and what we want to

278
00:11:24,240 --> 00:11:25,649
do is we want to actually create a

279
00:11:25,649 --> 00:11:28,860
system now where see the clients public

280
00:11:28,860 --> 00:11:31,589
key is no longer a public key

281
00:11:31,589 --> 00:11:34,709
it is a private key and we can actually

282
00:11:34,709 --> 00:11:37,709
do this with an algorithm a very slight

283
00:11:37,709 --> 00:11:39,930
modification to this algorithm that was

284
00:11:39,930 --> 00:11:41,819
invented by myself and Bob Riley at Red

285
00:11:41,819 --> 00:11:45,329
Hat and the way that this works if I'm

286
00:11:45,329 --> 00:11:46,920
gonna flip back and forth so you can see

287
00:11:46,920 --> 00:11:48,870
on the left side provisioning notice

288
00:11:48,870 --> 00:11:52,410
that nothing changes okay so on the

289
00:11:52,410 --> 00:11:53,699
provisioning side we're just doing

290
00:11:53,699 --> 00:11:55,860
difficult in the only changes are on the

291
00:11:55,860 --> 00:12:00,209
right-hand side so it's exactly the same

292
00:12:00,209 --> 00:12:02,610
as it was before the client calculates

293
00:12:02,610 --> 00:12:04,170
kay with the diffie-hellman encrypts

294
00:12:04,170 --> 00:12:07,920
data with K and it throws away K and C

295
00:12:07,920 --> 00:12:10,259
so it can't calculate 2k anymore on its

296
00:12:10,259 --> 00:12:14,579
own but it retains essence C and then

297
00:12:14,579 --> 00:12:17,220
when we want to do a decryption the

298
00:12:17,220 --> 00:12:20,160
client generates a new key pair this is

299
00:12:20,160 --> 00:12:21,990
an ephemeral key pair and it's generated

300
00:12:21,990 --> 00:12:24,660
every single time the client wants to do

301
00:12:24,660 --> 00:12:26,879
decryption so it doesn't happen an

302
00:12:26,879 --> 00:12:28,829
encryption time it happens at decryption

303
00:12:28,829 --> 00:12:30,420
time the client generates a new key pair

304
00:12:30,420 --> 00:12:33,120
so we have a private key and a public

305
00:12:33,120 --> 00:12:38,129
key e we add these the key C and the key

306
00:12:38,129 --> 00:12:41,639
E together we send the results which

307
00:12:41,639 --> 00:12:44,220
we've called X here to the server the

308
00:12:44,220 --> 00:12:45,629
server performs its side of the

309
00:12:45,629 --> 00:12:48,350
diffie-hellman sends back the result and

310
00:12:48,350 --> 00:12:52,610
then we are able to subtract out the

311
00:12:52,610 --> 00:12:55,170
ephemeral key essentially from this

312
00:12:55,170 --> 00:12:57,209
calculation and there's very some very

313
00:12:57,209 --> 00:12:58,679
simple math down here you can go online

314
00:12:58,679 --> 00:13:00,600
by the way and see these slides later if

315
00:13:00,600 --> 00:13:02,449
you want to look at the math closely and

316
00:13:02,449 --> 00:13:05,879
the end results of course is that C is

317
00:13:05,879 --> 00:13:09,809
now private because E is private so the

318
00:13:09,809 --> 00:13:11,790
server gets something that just looks

319
00:13:11,790 --> 00:13:13,889
like a random public key every time it

320
00:13:13,889 --> 00:13:15,179
wants to perform its side of the

321
00:13:15,179 --> 00:13:17,279
diffie-hellman it has no identifying

322
00:13:17,279 --> 00:13:20,040
information about the client at all the

323
00:13:20,040 --> 00:13:21,569
server performs its very simple

324
00:13:21,569 --> 00:13:23,759
operation and returns the results and

325
00:13:23,759 --> 00:13:25,170
since the results

326
00:13:25,170 --> 00:13:27,260
as the ephemeral keys still mixed in

327
00:13:27,260 --> 00:13:30,779
nobody on the wire can replay this or

328
00:13:30,779 --> 00:13:32,310
rather they can replay it but they can't

329
00:13:32,310 --> 00:13:33,810
ever get K out because they don't have

330
00:13:33,810 --> 00:13:38,010
the ephemeral key so in order to work

331
00:13:38,010 --> 00:13:39,600
one thing that's important to note is

332
00:13:39,600 --> 00:13:41,639
that in order to keep C private then

333
00:13:41,639 --> 00:13:44,790
both the public and private ephemeral

334
00:13:44,790 --> 00:13:49,649
Keys must be private as well so the end

335
00:13:49,649 --> 00:13:51,750
result of this is a system where instead

336
00:13:51,750 --> 00:13:53,699
of having an escrow instead of storing

337
00:13:53,699 --> 00:13:57,029
data in a remote server we just simply

338
00:13:57,029 --> 00:14:00,000
generate a key during our encryption we

339
00:14:00,000 --> 00:14:01,949
generate a second a second key during

340
00:14:01,949 --> 00:14:04,290
our decryption step mix them together

341
00:14:04,290 --> 00:14:05,850
send them to the server and get back

342
00:14:05,850 --> 00:14:08,310
result and the result of this is

343
00:14:08,310 --> 00:14:11,279
remarkably fast so if you think about a

344
00:14:11,279 --> 00:14:13,050
TLS connection the very first thing that

345
00:14:13,050 --> 00:14:15,959
TLS does is it negotiates what group it

346
00:14:15,959 --> 00:14:17,490
wants to use then the very second thing

347
00:14:17,490 --> 00:14:19,709
it does is that it does a difficult and

348
00:14:19,709 --> 00:14:22,980
right this is as light as just the

349
00:14:22,980 --> 00:14:25,230
diffie-hellman exchange in TLS no

350
00:14:25,230 --> 00:14:26,550
encryption is needed over the wire

351
00:14:26,550 --> 00:14:28,230
because it's just simply a public key

352
00:14:28,230 --> 00:14:31,050
exchange and no state is required on the

353
00:14:31,050 --> 00:14:32,550
server so we don't have to do fancy

354
00:14:32,550 --> 00:14:34,769
backups and all kinds of stuff there is

355
00:14:34,769 --> 00:14:36,890
one other alternate way to deploy this

356
00:14:36,890 --> 00:14:39,810
which is that you can actually stick the

357
00:14:39,810 --> 00:14:42,810
server's key inside crypto hardware so

358
00:14:42,810 --> 00:14:45,269
you can burn it into a TPM you can put

359
00:14:45,269 --> 00:14:48,300
it in an HSM the server does not have to

360
00:14:48,300 --> 00:14:50,490
have any access to the material at all

361
00:14:50,490 --> 00:14:52,529
and and specifically if you're storing

362
00:14:52,529 --> 00:14:55,560
the key in crypto Hardware as a backing

363
00:14:55,560 --> 00:14:58,320
to the server then I compromise of the

364
00:14:58,320 --> 00:15:01,050
server only leads to temporary access of

365
00:15:01,050 --> 00:15:03,360
the keys but not permanent access of the

366
00:15:03,360 --> 00:15:04,920
keys right so they never learn what the

367
00:15:04,920 --> 00:15:06,899
private key is the private key is always

368
00:15:06,899 --> 00:15:09,029
stored in hardware an attacker who

369
00:15:09,029 --> 00:15:10,949
compromises the server can only just

370
00:15:10,949 --> 00:15:12,449
kind of use it temporarily for a little

371
00:15:12,449 --> 00:15:15,589
while and then you kick them out again

372
00:15:15,740 --> 00:15:18,390
so if we compared these two systems

373
00:15:18,390 --> 00:15:22,589
on the left-hand side we have our the

374
00:15:22,589 --> 00:15:24,389
property we're talking about then we

375
00:15:24,389 --> 00:15:26,310
have the escrow and then we have the

376
00:15:26,310 --> 00:15:28,560
McCullum value exchange so when using an

377
00:15:28,560 --> 00:15:30,209
escrow server presence during

378
00:15:30,209 --> 00:15:31,709
provisioning is required because you

379
00:15:31,709 --> 00:15:33,089
actually have to have network access to

380
00:15:33,089 --> 00:15:35,819
push the key into the server on the

381
00:15:35,819 --> 00:15:37,050
other hand with

382
00:15:37,050 --> 00:15:38,790
kaalia exchange it's actually optional

383
00:15:38,790 --> 00:15:41,010
as long as you have that public key

384
00:15:41,010 --> 00:15:44,040
offline somehow you can do the full

385
00:15:44,040 --> 00:15:45,720
provisioning full encryption entirely

386
00:15:45,720 --> 00:15:49,080
offline and then only the only the

387
00:15:49,080 --> 00:15:50,610
server is only required when you want to

388
00:15:50,610 --> 00:15:52,230
do decryption so during the recovery

389
00:15:52,230 --> 00:15:55,050
step so that's the same for both the

390
00:15:55,050 --> 00:15:57,089
escrow and for the Mon Calamari exchange

391
00:15:57,089 --> 00:15:59,279
which is exactly what we want we want

392
00:15:59,279 --> 00:16:01,200
the data to only be automatically

393
00:16:01,200 --> 00:16:05,149
decrypted when the server is available

394
00:16:05,149 --> 00:16:08,279
the escrow however also has to have

395
00:16:08,279 --> 00:16:10,260
knowledge of all of the keys and so it

396
00:16:10,260 --> 00:16:12,390
becomes a central point of attack in the

397
00:16:12,390 --> 00:16:13,800
Macomb raelia exchange the server

398
00:16:13,800 --> 00:16:16,740
doesn't know any keys and is not really

399
00:16:16,740 --> 00:16:19,320
a it's not really a desirable place to

400
00:16:19,320 --> 00:16:23,550
attack similar with key transfer that's

401
00:16:23,550 --> 00:16:25,110
required in an escrow because we have to

402
00:16:25,110 --> 00:16:27,000
actually send the key over the wire to

403
00:16:27,000 --> 00:16:29,130
the remote and then get it back but with

404
00:16:29,130 --> 00:16:30,600
the Macomb really exchange there's no

405
00:16:30,600 --> 00:16:33,390
transfer of keys other than public keys

406
00:16:33,390 --> 00:16:35,279
so the only thing that's on the network

407
00:16:35,279 --> 00:16:37,920
is public key data which a passive

408
00:16:37,920 --> 00:16:42,180
attacker cannot get when you have an

409
00:16:42,180 --> 00:16:44,070
escrow you also require client

410
00:16:44,070 --> 00:16:46,079
authentication which is not required in

411
00:16:46,079 --> 00:16:48,540
the McCullum relay exchange we require

412
00:16:48,540 --> 00:16:50,640
transport encryption for transport

413
00:16:50,640 --> 00:16:52,230
encryption for the escrow but not for

414
00:16:52,230 --> 00:16:54,270
the McCallum relay exchange and then

415
00:16:54,270 --> 00:16:56,670
finally end-to-end encryption which is

416
00:16:56,670 --> 00:16:58,380
another whole set of problems we didn't

417
00:16:58,380 --> 00:16:59,880
talk about earlier with in escrow as

418
00:16:59,880 --> 00:17:01,620
well it is very difficult to implement

419
00:17:01,620 --> 00:17:03,870
on the other hand for McCullough

420
00:17:03,870 --> 00:17:05,910
exchange it's just not needed at all you

421
00:17:05,910 --> 00:17:09,540
do not need end to end encryption so

422
00:17:09,540 --> 00:17:10,949
there's a there's a server that

423
00:17:10,949 --> 00:17:12,510
implements this the servers called Tang

424
00:17:12,510 --> 00:17:16,349
and it's available github.com / latch

425
00:17:16,349 --> 00:17:20,250
set / Tang it's a small server-side

426
00:17:20,250 --> 00:17:23,400
demon it's very simple just HTTP and

427
00:17:23,400 --> 00:17:25,260
Jose which we'll talk about in a minute

428
00:17:25,260 --> 00:17:28,230
and it's very very fast we can do about

429
00:17:28,230 --> 00:17:31,710
2,000 requests a second on medium

430
00:17:31,710 --> 00:17:34,470
hardware and that's without any attempts

431
00:17:34,470 --> 00:17:35,850
to scale it up that's just single

432
00:17:35,850 --> 00:17:39,630
threaded etc so it's extremely small

433
00:17:39,630 --> 00:17:42,540
minimal dependencies and it's available

434
00:17:42,540 --> 00:17:44,610
on Fedora 23 and later

435
00:17:44,610 --> 00:17:46,260
and of course it's open source so you

436
00:17:46,260 --> 00:17:47,049
know been done

437
00:17:47,049 --> 00:17:48,970
ever distro and we're happy to happy to

438
00:17:48,970 --> 00:17:52,239
help you so installing a tank server is

439
00:17:52,239 --> 00:17:54,309
relatively easy at least on Fedora for

440
00:17:54,309 --> 00:17:58,269
right now DNF install Tang that gets you

441
00:17:58,269 --> 00:18:01,360
the server and then use system D to

442
00:18:01,360 --> 00:18:04,720
enable two unit files and then generate

443
00:18:04,720 --> 00:18:07,600
two keys and you're off to the races now

444
00:18:07,600 --> 00:18:09,309
you may want to scale this up put it

445
00:18:09,309 --> 00:18:10,929
behind Apache you may want to think

446
00:18:10,929 --> 00:18:12,309
about your deployment models so there

447
00:18:12,309 --> 00:18:13,509
are definitely some more complex

448
00:18:13,509 --> 00:18:15,789
scenarios but if you want to get up and

449
00:18:15,789 --> 00:18:18,159
running very quickly for testing it's

450
00:18:18,159 --> 00:18:21,749
just simply these five commandments

451
00:18:22,769 --> 00:18:25,029
we've only been talking about the server

452
00:18:25,029 --> 00:18:27,730
up into this point and we have not been

453
00:18:27,730 --> 00:18:29,529
talking about the client but we need to

454
00:18:29,529 --> 00:18:32,350
talk about the client as well so we have

455
00:18:32,350 --> 00:18:33,970
an application called clevis on the

456
00:18:33,970 --> 00:18:36,970
client so it's also available github.com

457
00:18:36,970 --> 00:18:39,460
forward slash latch set forward slash

458
00:18:39,460 --> 00:18:42,580
clevis this is a decryption automation

459
00:18:42,580 --> 00:18:44,859
and policy framework it has minimal

460
00:18:44,859 --> 00:18:46,149
dependencies as well

461
00:18:46,149 --> 00:18:48,129
it has early boot integration and gnome

462
00:18:48,129 --> 00:18:50,259
integration and it's available in 24 or

463
00:18:50,259 --> 00:18:54,549
24 and later and here's an example of

464
00:18:54,549 --> 00:18:58,080
doing some encryption with cleveson tang

465
00:18:58,080 --> 00:19:00,970
so DNF installed clevis gets you the

466
00:19:00,970 --> 00:19:03,429
clevis application you can just echo

467
00:19:03,429 --> 00:19:05,499
some plaintext into the clevis encrypt

468
00:19:05,499 --> 00:19:07,480
command you specify you want tang as

469
00:19:07,480 --> 00:19:10,149
you're backing policy and then you give

470
00:19:10,149 --> 00:19:11,830
it a configuration which is just a

471
00:19:11,830 --> 00:19:13,509
little JSON object right now containing

472
00:19:13,509 --> 00:19:16,720
just the URL of the server and you get a

473
00:19:16,720 --> 00:19:19,090
in this case since we did not pass in if

474
00:19:19,090 --> 00:19:21,850
the public key if fetch is the public

475
00:19:21,850 --> 00:19:23,499
key from the server and asks you if you

476
00:19:23,499 --> 00:19:25,539
want to trust it similar to what ssh

477
00:19:25,539 --> 00:19:29,799
would do finally we can if we cat the

478
00:19:29,799 --> 00:19:31,779
output data we actually see that it's

479
00:19:31,779 --> 00:19:33,639
Jason web encryption so this is a

480
00:19:33,639 --> 00:19:37,269
standard data format and when we want to

481
00:19:37,269 --> 00:19:39,580
do decrypt we just simply pass that same

482
00:19:39,580 --> 00:19:42,249
blob back in to the decrypt command then

483
00:19:42,249 --> 00:19:44,470
out comes our plaintext notice that I

484
00:19:44,470 --> 00:19:46,179
did not actually type anything in

485
00:19:46,179 --> 00:19:48,940
because the decryption was automatic now

486
00:19:48,940 --> 00:19:51,549
if I stop Tang and trying to do the

487
00:19:51,549 --> 00:19:53,499
decryption step again then we actually

488
00:19:53,499 --> 00:19:57,809
get failure and no plaintext comes out

489
00:19:58,460 --> 00:20:02,070
however clevis does not use only just

490
00:20:02,070 --> 00:20:04,910
tang because as I said it is a pluggable

491
00:20:04,910 --> 00:20:07,590
automated policy framework for

492
00:20:07,590 --> 00:20:10,440
decryption so so we can actually do it

493
00:20:10,440 --> 00:20:12,870
with an escrow as well in this case we

494
00:20:12,870 --> 00:20:17,190
are using the custodial API so if you

495
00:20:17,190 --> 00:20:18,510
don't know about custodia that's also

496
00:20:18,510 --> 00:20:19,920
interesting you can google it

497
00:20:19,920 --> 00:20:22,860
it's a essentially a secrets as a

498
00:20:22,860 --> 00:20:26,370
service API so in this case we are

499
00:20:26,370 --> 00:20:28,920
encrypting the same data we are pushing

500
00:20:28,920 --> 00:20:31,560
a key into the escrow pulling a key back

501
00:20:31,560 --> 00:20:34,650
out of the escrow for decryption and if

502
00:20:34,650 --> 00:20:36,030
the server is not available then we

503
00:20:36,030 --> 00:20:37,740
can't decrypt but this does have the

504
00:20:37,740 --> 00:20:40,800
same downsides as the SQL model but a

505
00:20:40,800 --> 00:20:42,060
lot of people already have an existing

506
00:20:42,060 --> 00:20:43,830
escrow and they may want to migrate from

507
00:20:43,830 --> 00:20:47,430
it or they may have specific cases where

508
00:20:47,430 --> 00:20:50,160
they actually need to run in escrow so

509
00:20:50,160 --> 00:20:51,390
then there's actually just another

510
00:20:51,390 --> 00:20:54,570
simple command to bind delux disk so if

511
00:20:54,570 --> 00:20:55,860
you have a block device that's encrypted

512
00:20:55,860 --> 00:20:58,620
with Lux this basically should look

513
00:20:58,620 --> 00:21:00,090
exactly the same as what we saw in the

514
00:21:00,090 --> 00:21:02,190
previous slides the only difference is

515
00:21:02,190 --> 00:21:05,190
that now we're passing a device the

516
00:21:05,190 --> 00:21:08,070
block device itself to the clevis bind

517
00:21:08,070 --> 00:21:10,590
Lux command we fetch the public key from

518
00:21:10,590 --> 00:21:12,450
the server we say yes we want to trust

519
00:21:12,450 --> 00:21:14,730
it then we enter one of the Lux keys and

520
00:21:14,730 --> 00:21:16,740
then internally what happens is we

521
00:21:16,740 --> 00:21:17,960
generate a cryptographically strong

522
00:21:17,960 --> 00:21:20,460
random key that's the same size as the

523
00:21:20,460 --> 00:21:22,830
master key so we don't lose any any

524
00:21:22,830 --> 00:21:26,250
security properties and then and then we

525
00:21:26,250 --> 00:21:28,770
encrypted that key using clevis and then

526
00:21:28,770 --> 00:21:31,860
at boot time when we want to recover

527
00:21:31,860 --> 00:21:33,750
that they unlock that disk automatically

528
00:21:33,750 --> 00:21:35,430
we just simply decrypt the key pass it

529
00:21:35,430 --> 00:21:38,130
to Lux and we're off to the races so

530
00:21:38,130 --> 00:21:40,500
there's a middle command in here Lux

531
00:21:40,500 --> 00:21:43,020
meta show which actually will show us

532
00:21:43,020 --> 00:21:45,120
all of our luck slots and the metadata

533
00:21:45,120 --> 00:21:47,570
that we've stored in the Lux header

534
00:21:47,570 --> 00:21:50,010
related to this so this is a related

535
00:21:50,010 --> 00:21:52,950
project we'll talk about in a minute

536
00:21:52,950 --> 00:21:54,990
so for root volume unlocking you just

537
00:21:54,990 --> 00:21:57,960
install clevis - Drake it and then run

538
00:21:57,960 --> 00:21:59,670
and Drake it - F to rebuild your in a

539
00:21:59,670 --> 00:22:01,620
tram FS and then we boot you only have

540
00:22:01,620 --> 00:22:02,970
to do that once because we need to get

541
00:22:02,970 --> 00:22:06,300
our code inside the init Ram FS and we

542
00:22:06,300 --> 00:22:07,710
were actually talking about having that

543
00:22:07,710 --> 00:22:09,280
by default

544
00:22:09,280 --> 00:22:10,450
that you don't even have to do that step

545
00:22:10,450 --> 00:22:13,480
it'll be in the default in a ram FS and

546
00:22:13,480 --> 00:22:15,940
then for removable storage like USB keys

547
00:22:15,940 --> 00:22:18,040
where you would want to say have a gnome

548
00:22:18,040 --> 00:22:19,870
desktop and plug in your USB key and

549
00:22:19,870 --> 00:22:22,180
have it automatically unlocked we have

550
00:22:22,180 --> 00:22:25,510
the clevis - you discs - package which

551
00:22:25,510 --> 00:22:26,680
you can just install no other

552
00:22:26,680 --> 00:22:28,000
configuration is needed

553
00:22:28,000 --> 00:22:30,070
you just insert your drive and then it

554
00:22:30,070 --> 00:22:31,420
unlocks as long as the server's

555
00:22:31,420 --> 00:22:37,480
available however we've only covered up

556
00:22:37,480 --> 00:22:39,660
up into automation up until this point

557
00:22:39,660 --> 00:22:41,950
we still haven't actually talked about

558
00:22:41,950 --> 00:22:44,590
policy and policy is where things get

559
00:22:44,590 --> 00:22:47,410
very interesting with clevis so we

560
00:22:47,410 --> 00:22:50,590
actually have a plugin which we call a

561
00:22:50,590 --> 00:22:54,490
pin and this is the Shamir secret

562
00:22:54,490 --> 00:22:56,770
sharing pin and this actually allows us

563
00:22:56,770 --> 00:22:58,600
to take a key divide it up into a

564
00:22:58,600 --> 00:23:00,250
variety of keys and then have a

565
00:23:00,250 --> 00:23:02,080
threshold to recover it so in this case

566
00:23:02,080 --> 00:23:05,410
we take our master key we divided it up

567
00:23:05,410 --> 00:23:07,240
we divide it up into five keys and then

568
00:23:07,240 --> 00:23:09,850
we have a threshold maybe two and as

569
00:23:09,850 --> 00:23:11,410
long as we have two of those fragments

570
00:23:11,410 --> 00:23:15,640
we can unlock the data Shamir's can also

571
00:23:15,640 --> 00:23:18,580
be nested as well so you'll very quickly

572
00:23:18,580 --> 00:23:20,770
notice that we can actually use Shamir's

573
00:23:20,770 --> 00:23:23,290
to create a hierarchical unlocking

574
00:23:23,290 --> 00:23:26,140
policy so let's look at how this might

575
00:23:26,140 --> 00:23:29,380
work in practice on the case of a simple

576
00:23:29,380 --> 00:23:33,210
laptop you may want to encrypt your disk

577
00:23:33,210 --> 00:23:35,410
using extreme ears with two passwords

578
00:23:35,410 --> 00:23:37,720
one for the administrator of the laptop

579
00:23:37,720 --> 00:23:39,970
and one for the user of the laptop with

580
00:23:39,970 --> 00:23:42,010
a threshold of one and in this case

581
00:23:42,010 --> 00:23:49,570
either password will unlock the disk now

582
00:23:49,570 --> 00:23:51,280
we want to have an automated laptop so

583
00:23:51,280 --> 00:23:52,750
we've kept the threshold the same we've

584
00:23:52,750 --> 00:23:54,610
added an additional branch now we're

585
00:23:54,610 --> 00:23:56,200
talking to the tank server so as long as

586
00:23:56,200 --> 00:23:57,460
you can get to the tank server it'll

587
00:23:57,460 --> 00:23:59,380
unlock automatically but if you're out

588
00:23:59,380 --> 00:24:01,300
at the coffee shop and you can't get to

589
00:24:01,300 --> 00:24:03,580
the tank shirt server then you'll have

590
00:24:03,580 --> 00:24:05,140
to take your user password but the

591
00:24:05,140 --> 00:24:07,020
administrator still has a password that

592
00:24:07,020 --> 00:24:09,520
they can use to unlock the system and

593
00:24:09,520 --> 00:24:11,320
now everything we've talked about up

594
00:24:11,320 --> 00:24:13,870
into this point is doable today with lux

595
00:24:13,870 --> 00:24:16,870
but we're about to talk about stuff we

596
00:24:16,870 --> 00:24:20,050
can't deal with Lux so for example let's

597
00:24:20,050 --> 00:24:22,600
say we have a high-security system and

598
00:24:22,600 --> 00:24:23,380
in this high

599
00:24:23,380 --> 00:24:25,060
security system we want to create a

600
00:24:25,060 --> 00:24:26,380
bunch of passwords in this example

601
00:24:26,380 --> 00:24:29,260
there's three and we want to require two

602
00:24:29,260 --> 00:24:32,110
of them in order to unlock the volume so

603
00:24:32,110 --> 00:24:36,100
this would be the sort of you know case

604
00:24:36,100 --> 00:24:37,150
where you have something that would be

605
00:24:37,150 --> 00:24:38,680
very very dangerous and you want

606
00:24:38,680 --> 00:24:40,150
multiple people to authenticate before

607
00:24:40,150 --> 00:24:41,920
you can get to it you can't do this

608
00:24:41,920 --> 00:24:43,600
today with Lux but you can with Clavis

609
00:24:43,600 --> 00:24:45,520
well not today but very soon in the

610
00:24:45,520 --> 00:24:46,570
future you'll be able to do this with

611
00:24:46,570 --> 00:24:50,350
clevis so here's an example of a complex

612
00:24:50,350 --> 00:24:54,610
laptop policy this is we have the

613
00:24:54,610 --> 00:24:56,620
administrator who has created a master

614
00:24:56,620 --> 00:24:59,860
code and printed it on a QR code and

615
00:24:59,860 --> 00:25:02,260
they lock it in a safe and in the

616
00:25:02,260 --> 00:25:04,450
biggest disaster case that can extract

617
00:25:04,450 --> 00:25:06,130
the laptop out of the hard drive out of

618
00:25:06,130 --> 00:25:08,290
the laptop you can plug it into some

619
00:25:08,290 --> 00:25:10,390
tool that they have and they can use the

620
00:25:10,390 --> 00:25:12,790
QR codes get it back in to recover the

621
00:25:12,790 --> 00:25:15,040
data so that's the that's the master

622
00:25:15,040 --> 00:25:19,030
recovery scheme but now we go down to a

623
00:25:19,030 --> 00:25:22,270
second branch and this branch further

624
00:25:22,270 --> 00:25:25,720
does Shamir's with threshold of two in

625
00:25:25,720 --> 00:25:28,150
this case it means that both of our

626
00:25:28,150 --> 00:25:31,570
branches are required so we have two

627
00:25:31,570 --> 00:25:34,300
branches one is TPM and one is Shamir

628
00:25:34,300 --> 00:25:37,840
secret sharing so this means that if

629
00:25:37,840 --> 00:25:39,700
you're not using the QR code that's

630
00:25:39,700 --> 00:25:41,860
locked in the safe the only way to

631
00:25:41,860 --> 00:25:44,500
unlock this system is that it must be in

632
00:25:44,500 --> 00:25:46,900
the chassis to be able to talk to the

633
00:25:46,900 --> 00:25:50,290
TPM and then we if that's the case then

634
00:25:50,290 --> 00:25:53,890
we finally go to our last branch where

635
00:25:53,890 --> 00:25:56,200
we have a threshold of two and here we

636
00:25:56,200 --> 00:25:57,910
have for authentication methods we have

637
00:25:57,910 --> 00:26:00,070
password we have Yubikey we have Tang we

638
00:26:00,070 --> 00:26:02,290
have Bluetooth by the way Bluetooth here

639
00:26:02,290 --> 00:26:03,490
is actually would just be the Tang

640
00:26:03,490 --> 00:26:05,230
protocol the McCallum relay exchange

641
00:26:05,230 --> 00:26:07,960
over Bluetooth which we're working on so

642
00:26:07,960 --> 00:26:09,100
in this case you've got a Bluetooth

643
00:26:09,100 --> 00:26:11,830
beacon sitting by your desk and you're

644
00:26:11,830 --> 00:26:13,210
on the corporate network so you have

645
00:26:13,210 --> 00:26:15,040
Tang available to you you turn on your

646
00:26:15,040 --> 00:26:17,260
laptop it goes completely automatically

647
00:26:17,260 --> 00:26:19,600
without any user intervention at all on

648
00:26:19,600 --> 00:26:22,600
the other hand let's say you go to visit

649
00:26:22,600 --> 00:26:24,070
your friend at another floor of your

650
00:26:24,070 --> 00:26:26,230
building and you're still on the

651
00:26:26,230 --> 00:26:27,580
corporate network but you're not near

652
00:26:27,580 --> 00:26:30,490
your desk well in this case you'll still

653
00:26:30,490 --> 00:26:31,630
be able to get to the tank server but

654
00:26:31,630 --> 00:26:32,650
you won't be able to get to the

655
00:26:32,650 --> 00:26:35,050
Bluetooth so we'll have to do one of the

656
00:26:35,050 --> 00:26:36,610
other options either you can press the

657
00:26:36,610 --> 00:26:36,850
butt

658
00:26:36,850 --> 00:26:39,550
Yubikey or you can type in a password to

659
00:26:39,550 --> 00:26:42,160
get in now let's say that you actually

660
00:26:42,160 --> 00:26:43,810
take your laptop down to the coffee shop

661
00:26:43,810 --> 00:26:45,430
because you like coffee and you don't

662
00:26:45,430 --> 00:26:47,920
want to be in the office so you're down

663
00:26:47,920 --> 00:26:49,480
in the coffee shop you open up your

664
00:26:49,480 --> 00:26:51,520
laptop it turns on now you're not near

665
00:26:51,520 --> 00:26:52,480
your desk so you don't have the

666
00:26:52,480 --> 00:26:53,590
Bluetooth you're not on the corporate

667
00:26:53,590 --> 00:26:55,030
network so you don't have access to Tang

668
00:26:55,030 --> 00:26:58,840
in this case you have to enter both your

669
00:26:58,840 --> 00:27:01,210
password and press your EB key in order

670
00:27:01,210 --> 00:27:04,120
to get access to your desk right and the

671
00:27:04,120 --> 00:27:05,980
important thing here is that I as a

672
00:27:05,980 --> 00:27:07,750
software developer did not choose this

673
00:27:07,750 --> 00:27:10,600
policy for you you got to choose what

674
00:27:10,600 --> 00:27:16,330
the best policy was for your scenario so

675
00:27:16,330 --> 00:27:18,610
here's an example of just a basic

676
00:27:18,610 --> 00:27:20,740
Shamir's with tang in this case we're

677
00:27:20,740 --> 00:27:22,660
using it to provide high availability to

678
00:27:22,660 --> 00:27:26,080
two different Tang servers so we use

679
00:27:26,080 --> 00:27:28,060
Shamir's we say that two pins we want

680
00:27:28,060 --> 00:27:30,700
are both Tang and we specify their

681
00:27:30,700 --> 00:27:32,260
configurations there there's a threshold

682
00:27:32,260 --> 00:27:35,620
of one we in this case we trust two

683
00:27:35,620 --> 00:27:36,910
advertisements because we're actually

684
00:27:36,910 --> 00:27:38,680
talking to two different Tang servers

685
00:27:38,680 --> 00:27:41,950
with two different public keys and we

686
00:27:41,950 --> 00:27:45,040
can decrypt the data automatically we

687
00:27:45,040 --> 00:27:48,220
can stop one of those servers and still

688
00:27:48,220 --> 00:27:49,930
decrypt our data but as soon as we stop

689
00:27:49,930 --> 00:27:51,670
the second server we are unable to

690
00:27:51,670 --> 00:27:57,280
decrypt the data so let's explore the

691
00:27:57,280 --> 00:28:02,440
ecosystem a bit one of the dependencies

692
00:28:02,440 --> 00:28:04,110
that we have is a project called Jose

693
00:28:04,110 --> 00:28:08,740
I'm actually giving a talk at on Jose in

694
00:28:08,740 --> 00:28:12,070
the security track in like an hour or so

695
00:28:12,070 --> 00:28:13,450
so if you're interested in learning more

696
00:28:13,450 --> 00:28:15,760
about Jose come to that talk

697
00:28:15,760 --> 00:28:18,940
Jose stands for adjacent objects signing

698
00:28:18,940 --> 00:28:22,090
an encryption which is a set of rfcs so

699
00:28:22,090 --> 00:28:23,350
this is actually a standard data format

700
00:28:23,350 --> 00:28:25,960
and it's a sea library and a

701
00:28:25,960 --> 00:28:27,910
command-line utility for doing all of

702
00:28:27,910 --> 00:28:29,530
the encryption and signing and key

703
00:28:29,530 --> 00:28:33,490
generation for that data type and the

704
00:28:33,490 --> 00:28:34,660
bottom line is that it's just user

705
00:28:34,660 --> 00:28:36,580
friendly standards compliant crypto and

706
00:28:36,580 --> 00:28:38,740
in our case we wanted to use this

707
00:28:38,740 --> 00:28:40,990
because our protocol was over HTTP and

708
00:28:40,990 --> 00:28:46,150
what's better than Jason plus HTTP we

709
00:28:46,150 --> 00:28:47,710
also have another dependency called lux

710
00:28:47,710 --> 00:28:49,210
meta which is something we wrote as part

711
00:28:49,210 --> 00:28:50,280
of this

712
00:28:50,280 --> 00:28:54,690
Lux Mehta is a utility to store metadata

713
00:28:54,690 --> 00:28:57,720
in the lux version one header gap and so

714
00:28:57,720 --> 00:28:59,970
the background of the story is that we

715
00:28:59,970 --> 00:29:02,610
wanted to support automatic unlocking of

716
00:29:02,610 --> 00:29:05,370
Lux one but there was no place to store

717
00:29:05,370 --> 00:29:07,710
the metadata that we needed to actually

718
00:29:07,710 --> 00:29:11,040
do this to do this restoration and so

719
00:29:11,040 --> 00:29:13,530
there was actually a gap between the end

720
00:29:13,530 --> 00:29:15,870
of the Lux header and the start of the

721
00:29:15,870 --> 00:29:18,270
encrypted data and so we wrote this

722
00:29:18,270 --> 00:29:20,070
utility called Lux meta that commandeer

723
00:29:20,070 --> 00:29:23,010
is that area and is we stick metadata in

724
00:29:23,010 --> 00:29:26,070
there and this we don't do any parsing

725
00:29:26,070 --> 00:29:28,170
of the lux header ourselves everything

726
00:29:28,170 --> 00:29:30,420
is offloaded to the upstream Lib crypt

727
00:29:30,420 --> 00:29:33,480
setup utility so so there shouldn't be

728
00:29:33,480 --> 00:29:35,160
any problems with this and upstream is

729
00:29:35,160 --> 00:29:38,520
aware of this program and so you can

730
00:29:38,520 --> 00:29:40,440
actually see an example of use of using

731
00:29:40,440 --> 00:29:43,290
this here we want to store the metadata

732
00:29:43,290 --> 00:29:46,680
high in a slot with a given UUID

733
00:29:46,680 --> 00:29:49,440
and then we load it back and then if we

734
00:29:49,440 --> 00:29:51,390
try to load a different UUID from that

735
00:29:51,390 --> 00:29:52,800
slot we get an error because that's not

736
00:29:52,800 --> 00:29:55,530
the type of data in that slot so fairly

737
00:29:55,530 --> 00:29:58,350
straightforward fairly simple and this

738
00:29:58,350 --> 00:30:00,270
is where we actually store the encrypted

739
00:30:00,270 --> 00:30:05,370
data that comes out of clevis in the

740
00:30:05,370 --> 00:30:08,820
near future these are things that are

741
00:30:08,820 --> 00:30:12,060
pretty high on our to-do list so for the

742
00:30:12,060 --> 00:30:14,100
josè project we want to add pkcs 11

743
00:30:14,100 --> 00:30:16,800
support this will actually allow us to

744
00:30:16,800 --> 00:30:18,150
do all of the stuff that we've already

745
00:30:18,150 --> 00:30:20,040
talked about but using actual crypto

746
00:30:20,040 --> 00:30:21,870
hardware so you can store private keys

747
00:30:21,870 --> 00:30:23,700
burned in the hardware that can't be

748
00:30:23,700 --> 00:30:27,420
extracted and we'd like to add some

749
00:30:27,420 --> 00:30:29,730
Python bindings for Jose or any other

750
00:30:29,730 --> 00:30:31,740
language that you might want to use Jose

751
00:30:31,740 --> 00:30:33,720
in we would also like to support

752
00:30:33,720 --> 00:30:35,820
additional crypto backends and maybe

753
00:30:35,820 --> 00:30:37,290
some additional algorithms although we

754
00:30:37,290 --> 00:30:38,850
do support all of the algorithms that

755
00:30:38,850 --> 00:30:41,760
are specified by the RFC there are a few

756
00:30:41,760 --> 00:30:43,260
others that are not specified that are

757
00:30:43,260 --> 00:30:45,230
in common use that might be interested

758
00:30:45,230 --> 00:30:49,560
interesting to implement for clevis

759
00:30:49,560 --> 00:30:51,540
where I'm going to work right now adding

760
00:30:51,540 --> 00:30:53,130
a password pin which is actually much

761
00:30:53,130 --> 00:30:54,240
more complicated than you might expect

762
00:30:54,240 --> 00:30:57,810
and this will allow you to mix passwords

763
00:30:57,810 --> 00:31:00,570
in with your policy once we land pkcs 11

764
00:31:00,570 --> 00:31:02,480
support in Jose then we will have

765
00:31:02,480 --> 00:31:05,450
pkcs 11 pin and clevis so that you can

766
00:31:05,450 --> 00:31:08,990
actually bind your client-side data to

767
00:31:08,990 --> 00:31:11,180
hardware that's inserted like a TPM for

768
00:31:11,180 --> 00:31:15,050
instance support for we would like to

769
00:31:15,050 --> 00:31:16,880
have support for non root non removable

770
00:31:16,880 --> 00:31:19,760
volumes the reason we don't support this

771
00:31:19,760 --> 00:31:22,910
right now this is by the way volumes

772
00:31:22,910 --> 00:31:24,290
that are basically built in that are

773
00:31:24,290 --> 00:31:26,060
there at boot time but they are not your

774
00:31:26,060 --> 00:31:28,310
root volume we don't we don't support

775
00:31:28,310 --> 00:31:29,930
this right now because of a mismatch of

776
00:31:29,930 --> 00:31:32,450
expectations between us and system D but

777
00:31:32,450 --> 00:31:33,980
we're actively working with the system D

778
00:31:33,980 --> 00:31:36,320
people about so that will be coming in

779
00:31:36,320 --> 00:31:37,070
the near future

780
00:31:37,070 --> 00:31:39,200
we'd like to add X for encryption

781
00:31:39,200 --> 00:31:41,840
support so XT for also allows you to do

782
00:31:41,840 --> 00:31:44,060
per directory encryption and we would

783
00:31:44,060 --> 00:31:45,050
like to basically do the same thing

784
00:31:45,050 --> 00:31:48,380
there where we encrypt the key using

785
00:31:48,380 --> 00:31:51,170
clevis and then store the metadata in an

786
00:31:51,170 --> 00:31:53,900
extended attribute on the directory and

787
00:31:53,900 --> 00:31:56,720
for unlocking then we can just perform

788
00:31:56,720 --> 00:31:58,370
the same exact sort of steps that we do

789
00:31:58,370 --> 00:32:02,660
for lux and then finally for Tang we

790
00:32:02,660 --> 00:32:04,880
would like to modify our algorithm

791
00:32:04,880 --> 00:32:07,670
slightly to support binding IDs this

792
00:32:07,670 --> 00:32:09,830
would be optional but it will also

793
00:32:09,830 --> 00:32:12,590
sacrifice anonymity so it's a trade-off

794
00:32:12,590 --> 00:32:15,770
here which allows you to do revocation

795
00:32:15,770 --> 00:32:16,970
which is our second feature that we'd

796
00:32:16,970 --> 00:32:19,820
like to add so in other words if you

797
00:32:19,820 --> 00:32:21,140
want your clients just to be able to

798
00:32:21,140 --> 00:32:22,760
bind you don't care about revoking their

799
00:32:22,760 --> 00:32:25,460
keys then you can just use this protocol

800
00:32:25,460 --> 00:32:28,310
as is but if you want to be able to

801
00:32:28,310 --> 00:32:31,160
actually revoke a specific binding then

802
00:32:31,160 --> 00:32:32,150
we need to be able to have

803
00:32:32,150 --> 00:32:34,490
cryptographically seal binding IDs as

804
00:32:34,490 --> 00:32:37,340
part of this process I mean of course

805
00:32:37,340 --> 00:32:39,560
patches are welcome so if you'd like to

806
00:32:39,560 --> 00:32:43,700
contribute to our project please do and

807
00:32:43,700 --> 00:32:45,080
this is where we get the names from by

808
00:32:45,080 --> 00:32:48,830
the way we have clevis and tang it's

809
00:32:48,830 --> 00:32:51,950
just a traditional joint so the u-shaped

810
00:32:51,950 --> 00:32:54,080
bit is called a clevis and the block

811
00:32:54,080 --> 00:32:56,660
shaped bit is called tang and the thing

812
00:32:56,660 --> 00:32:58,010
that binds them together is called a

813
00:32:58,010 --> 00:33:01,970
clevis pin so that's all I have thank

814
00:33:01,970 --> 00:33:03,030
you very much

815
00:33:03,030 --> 00:33:12,910
[Applause]

816
00:33:17,830 --> 00:33:21,550
now there any questions

817
00:34:19,659 --> 00:34:21,250
are there any other questions while

818
00:34:21,250 --> 00:34:22,210
we're working out the microphone

819
00:34:22,210 --> 00:34:24,839
situation up there

820
00:34:38,070 --> 00:34:40,929
all right hello hello

821
00:34:40,929 --> 00:34:44,949
thanks very interesting just two small

822
00:34:44,949 --> 00:34:48,000
questions do you see any limitations

823
00:34:48,000 --> 00:34:50,350
situations where you wouldn't want to

824
00:34:50,350 --> 00:34:53,800
use this algorithm and the second

825
00:34:53,800 --> 00:34:56,620
question is do you see any other of

826
00:34:56,620 --> 00:34:59,650
applications that might be interesting

827
00:34:59,650 --> 00:35:03,670
like how unlocking your house for

828
00:35:03,670 --> 00:35:06,550
instance things like that so yeah those

829
00:35:06,550 --> 00:35:08,800
are two great questions the one is do we

830
00:35:08,800 --> 00:35:11,770
see any limitations with this and the

831
00:35:11,770 --> 00:35:13,570
second question was do we see any other

832
00:35:13,570 --> 00:35:17,140
applications of this and so the case

833
00:35:17,140 --> 00:35:19,480
where you may not want to use tang is if

834
00:35:19,480 --> 00:35:20,890
you're working in a heavily standardized

835
00:35:20,890 --> 00:35:22,540
environment and you're only allowed to

836
00:35:22,540 --> 00:35:24,970
use certain algorithms and and our

837
00:35:24,970 --> 00:35:27,310
algorithm isn't on the list the other

838
00:35:27,310 --> 00:35:29,050
case where you might not want to use

839
00:35:29,050 --> 00:35:31,390
tang is where you need revocation of

840
00:35:31,390 --> 00:35:34,000
some kind and that's because we don't

841
00:35:34,000 --> 00:35:35,770
implement it yet but we are going to be

842
00:35:35,770 --> 00:35:37,270
implementing it in the near future so

843
00:35:37,270 --> 00:35:39,580
that case will fall off of our list

844
00:35:39,580 --> 00:35:43,620
we've also started to open some

845
00:35:43,620 --> 00:35:45,340
conversations with some different

846
00:35:45,340 --> 00:35:47,740
standards bodies about actually

847
00:35:47,740 --> 00:35:49,330
standardizing the algorithm and making

848
00:35:49,330 --> 00:35:51,270
sure that it's available in those cases

849
00:35:51,270 --> 00:35:55,330
so no I think that once we sort of cross

850
00:35:55,330 --> 00:35:56,740
all of those hurdles I don't think

851
00:35:56,740 --> 00:35:58,600
there's any reason not to use the

852
00:35:58,600 --> 00:36:02,050
application the only other reason I can

853
00:36:02,050 --> 00:36:03,250
see that somebody would not want to use

854
00:36:03,250 --> 00:36:04,750
it is because it is new crypto and

855
00:36:04,750 --> 00:36:08,260
people are always rightly concerned

856
00:36:08,260 --> 00:36:10,540
about using new crypto and so this is

857
00:36:10,540 --> 00:36:13,740
precisely why we're also pursuing a

858
00:36:13,740 --> 00:36:16,480
paper that goes through the formal

859
00:36:16,480 --> 00:36:18,100
methods to prove the actual algorithm

860
00:36:18,100 --> 00:36:20,290
itself so once this is done and

861
00:36:20,290 --> 00:36:22,240
generally accepted in academia we

862
00:36:22,240 --> 00:36:24,490
shouldn't have any other limitations as

863
00:36:24,490 --> 00:36:27,040
far as other applications for I assume

864
00:36:27,040 --> 00:36:28,480
you're talking about the Macomb Rally

865
00:36:28,480 --> 00:36:31,480
exchange algorithm it's it's actually

866
00:36:31,480 --> 00:36:33,340
very very interesting because you can

867
00:36:33,340 --> 00:36:34,840
use it for any case where you want

868
00:36:34,840 --> 00:36:37,090
authentication in which the

869
00:36:37,090 --> 00:36:38,560
authenticating party gets a

870
00:36:38,560 --> 00:36:40,390
cryptographic key that they can decrypt

871
00:36:40,390 --> 00:36:42,850
data which I'm not aware of any other

872
00:36:42,850 --> 00:36:45,760
system that currently does this so a one

873
00:36:45,760 --> 00:36:46,900
area where this would

874
00:36:46,900 --> 00:36:50,220
very interesting imagine say you have

875
00:36:50,220 --> 00:36:53,079
your phone is doing the Macomb rally

876
00:36:53,079 --> 00:36:55,270
exchange over Bluetooth you walk up to

877
00:36:55,270 --> 00:36:58,029
your laptop and your laptop not only

878
00:36:58,029 --> 00:36:59,740
authenticate you but now is able to

879
00:36:59,740 --> 00:37:02,140
decrypt say your keyring with all of

880
00:37:02,140 --> 00:37:04,029
your other keys like your SSH key and

881
00:37:04,029 --> 00:37:06,039
all of that other kind of stuff so

882
00:37:06,039 --> 00:37:07,210
there's some really interesting

883
00:37:07,210 --> 00:37:10,089
applications of it more broadly but we

884
00:37:10,089 --> 00:37:11,650
haven't we're just trying to get this

885
00:37:11,650 --> 00:37:13,450
one out the door first and then we'll

886
00:37:13,450 --> 00:37:16,799
work on the other ones so thank you

887
00:37:16,799 --> 00:37:18,849
there's some questions down here in the

888
00:37:18,849 --> 00:37:22,029
front up here yeah go ahead No thank you

889
00:37:22,029 --> 00:37:24,460
very much very interesting concept those

890
00:37:24,460 --> 00:37:27,039
more complex policies that you talked

891
00:37:27,039 --> 00:37:28,750
about that you can now implement how do

892
00:37:28,750 --> 00:37:31,329
you configure them is there like a

893
00:37:31,329 --> 00:37:34,569
scripting language or the configuration

894
00:37:34,569 --> 00:37:36,339
file form that you configure them with

895
00:37:36,339 --> 00:37:38,890
yeah so the question was how do you

896
00:37:38,890 --> 00:37:41,079
configure the more complex policies and

897
00:37:41,079 --> 00:37:43,960
the answer is that what essentially

898
00:37:43,960 --> 00:37:45,609
happens is when you do your encryption

899
00:37:45,609 --> 00:37:48,490
you specify your root of the root of the

900
00:37:48,490 --> 00:37:50,730
tree and then in the configuration

901
00:37:50,730 --> 00:37:53,500
that's passed in the in the JSON blob

902
00:37:53,500 --> 00:37:56,289
will be the entire hierarchy so it's all

903
00:37:56,289 --> 00:37:58,480
defined in encryption time and the thing

904
00:37:58,480 --> 00:38:00,720
that's really interesting about this is

905
00:38:00,720 --> 00:38:03,369
currently people who are thinking ahead

906
00:38:03,369 --> 00:38:04,990
of the game and thinking about policy

907
00:38:04,990 --> 00:38:07,319
they're typically thinking about a

908
00:38:07,319 --> 00:38:11,109
secure process which has access to the

909
00:38:11,109 --> 00:38:13,450
symmetric encryption key and then which

910
00:38:13,450 --> 00:38:15,760
manages access to it based on some

911
00:38:15,760 --> 00:38:18,579
policy where clevis is really different

912
00:38:18,579 --> 00:38:20,680
from this use case is that we actually

913
00:38:20,680 --> 00:38:23,020
validate that policy cryptographically

914
00:38:23,020 --> 00:38:25,599
so there's no special privilege to

915
00:38:25,599 --> 00:38:27,279
process anywhere that can do the

916
00:38:27,279 --> 00:38:29,440
decryption as long as you can fulfill

917
00:38:29,440 --> 00:38:31,029
the policy you can get the plaintext

918
00:38:31,029 --> 00:38:34,059
back but if you can't you can't okay

919
00:38:34,059 --> 00:38:38,470
thank you very much Rob you spoke about

920
00:38:38,470 --> 00:38:41,680
the key exchange and that the ephemeral

921
00:38:41,680 --> 00:38:44,710
key is mixed in yes so my question is

922
00:38:44,710 --> 00:38:47,109
have you done any any research into how

923
00:38:47,109 --> 00:38:50,740
many times you can send the same key

924
00:38:50,740 --> 00:38:53,310
across and

925
00:38:53,310 --> 00:38:55,450
extremely low series of these

926
00:38:55,450 --> 00:38:57,310
transmissions be able to pick out which

927
00:38:57,310 --> 00:38:59,890
parts are rbr static across all of them

928
00:38:59,890 --> 00:39:01,390
so that you can basically discard all

929
00:39:01,390 --> 00:39:03,040
the ephemeral keys and get the non

930
00:39:03,040 --> 00:39:05,800
ephemeral part yes so there's nothing

931
00:39:05,800 --> 00:39:09,220
leaked as part of this operation the

932
00:39:09,220 --> 00:39:11,410
only thing that the server ever receives

933
00:39:11,410 --> 00:39:14,410
is random data it's not like we're doing

934
00:39:14,410 --> 00:39:18,910
this in the we're doing this actually

935
00:39:18,910 --> 00:39:21,970
inside of the elliptic curve realm so

936
00:39:21,970 --> 00:39:24,070
it's just another point on the curve so

937
00:39:24,070 --> 00:39:26,710
basically you have as many points as

938
00:39:26,710 --> 00:39:29,590
there are on the curve which is a lot so

939
00:39:29,590 --> 00:39:32,050
in the case of a 256-bit curve it's you

940
00:39:32,050 --> 00:39:34,660
know 2 to the 256 which is considered

941
00:39:34,660 --> 00:39:37,180
secure by all current standards to my

942
00:39:37,180 --> 00:39:41,619
knowledge yep somebody I don't know

943
00:39:41,619 --> 00:39:46,990
who's next I wanted to ask about those

944
00:39:46,990 --> 00:39:50,260
policies anyway it's a it's tremendous

945
00:39:50,260 --> 00:39:52,630
progress over key escrow mechanisms

946
00:39:52,630 --> 00:39:55,390
although one of the strengths of the key

947
00:39:55,390 --> 00:39:57,250
escrow mechanisms is that the policies

948
00:39:57,250 --> 00:40:00,430
are dynamic so you can actually modify

949
00:40:00,430 --> 00:40:05,770
them after after the the key is

950
00:40:05,770 --> 00:40:08,680
increasing is encrypted and so you can

951
00:40:08,680 --> 00:40:11,400
authorize for example more users than

952
00:40:11,400 --> 00:40:15,820
then than you anticipated yes when so

953
00:40:15,820 --> 00:40:19,570
how would you as far as I understand

954
00:40:19,570 --> 00:40:22,000
this tank level scheme doesn't currently

955
00:40:22,000 --> 00:40:24,190
support that and I was wondering if you

956
00:40:24,190 --> 00:40:28,180
see a way to extend it with support for

957
00:40:28,180 --> 00:40:29,349
something like you have to have access

958
00:40:29,349 --> 00:40:31,690
to the client and you have to

959
00:40:31,690 --> 00:40:34,510
essentially decrypt using the policy and

960
00:40:34,510 --> 00:40:38,070
then re encrypt using a new policy so

961
00:40:38,070 --> 00:40:40,210
it's not there's no there's no way to

962
00:40:40,210 --> 00:40:41,740
essentially manage it like there isn't

963
00:40:41,740 --> 00:40:43,390
an escrow but there's a lot of other

964
00:40:43,390 --> 00:40:44,950
security benefits so it is sort of a

965
00:40:44,950 --> 00:40:48,118
trade-off yeah thank you

966
00:40:49,800 --> 00:40:53,190
yeah yeah thanks for the talk it's a it

967
00:40:53,190 --> 00:40:55,740
was really interesting so one

968
00:40:55,740 --> 00:40:57,300
interesting news case would obviously be

969
00:40:57,300 --> 00:41:00,570
to try and use this as the route of

970
00:41:00,570 --> 00:41:03,930
trust for a machine as well I'm sorry do

971
00:41:03,930 --> 00:41:06,630
to use this authentication method as the

972
00:41:06,630 --> 00:41:11,100
root of trust you're a machine are you

973
00:41:11,100 --> 00:41:14,970
looking into building on to this this

974
00:41:14,970 --> 00:41:18,090
policy mechanism further policies to say

975
00:41:18,090 --> 00:41:20,490
well I've now decrypted the hard drive

976
00:41:20,490 --> 00:41:24,060
now I can authenticate this service or

977
00:41:24,060 --> 00:41:26,640
this device how are you are you planning

978
00:41:26,640 --> 00:41:28,530
to implement it and how do you foresee

979
00:41:28,530 --> 00:41:30,480
that working it's not currently on the

980
00:41:30,480 --> 00:41:32,370
roadmap it's something that's

981
00:41:32,370 --> 00:41:34,170
theoretically possible but I have a lot

982
00:41:34,170 --> 00:41:36,140
of other stuff on my plate right now so

983
00:41:36,140 --> 00:41:38,250
when I get all of that other stuff off

984
00:41:38,250 --> 00:41:39,510
my plate then I would like to think

985
00:41:39,510 --> 00:41:46,320
about that yes yeah I thought I have two

986
00:41:46,320 --> 00:41:49,830
questions one is it seems really easy to

987
00:41:49,830 --> 00:41:52,560
use is it just as easy I hope so if it's

988
00:41:52,560 --> 00:41:54,720
not file a bug or a patch we're glad to

989
00:41:54,720 --> 00:41:56,040
take either yeah

990
00:41:56,040 --> 00:41:57,570
and it's already used in production

991
00:41:57,570 --> 00:42:00,930
somewhere is it just because we just

992
00:42:00,930 --> 00:42:03,030
released this about two months ago in

993
00:42:03,030 --> 00:42:07,170
Fedora and we are currently we're

994
00:42:07,170 --> 00:42:08,970
currently attempting to stabilize it so

995
00:42:08,970 --> 00:42:10,500
I don't know anybody who's using it in

996
00:42:10,500 --> 00:42:12,330
production but I know lots of people who

997
00:42:12,330 --> 00:42:13,200
are using in a pre-production

998
00:42:13,200 --> 00:42:17,689
environments looks great Thanks

999
00:42:19,930 --> 00:42:24,790
up here somewhere I think any more

1000
00:42:24,790 --> 00:42:27,240
questions

1001
00:42:29,780 --> 00:42:32,780
hi another question from me

1002
00:42:32,780 --> 00:42:38,900
as did you how does this that relate to

1003
00:42:38,900 --> 00:42:42,310
attribute based encryption schemes and

1004
00:42:42,310 --> 00:42:44,830
attribute based encryption schemes and

1005
00:42:44,830 --> 00:42:48,590
do you think that like those like those

1006
00:42:48,590 --> 00:42:51,050
two approaches can be combined I would

1007
00:42:51,050 --> 00:42:53,360
really like to see them combined I don't

1008
00:42:53,360 --> 00:42:55,190
see any reason why they can't be

1009
00:42:55,190 --> 00:42:59,720
combined it should we don't really have

1010
00:42:59,720 --> 00:43:02,720
any to my knowledge we don't have any

1011
00:43:02,720 --> 00:43:05,030
usable implementations of attribute

1012
00:43:05,030 --> 00:43:06,920
based encryption it's all currently

1013
00:43:06,920 --> 00:43:08,900
theoretical so if somebody would have to

1014
00:43:08,900 --> 00:43:12,580
write it and then we can implement it so

1015
00:43:12,580 --> 00:43:16,840
so if you'd like to write it please do

1016
00:43:18,100 --> 00:43:21,850
any more questions

1017
00:43:26,920 --> 00:43:28,630
thank you very much

1018
00:43:28,630 --> 00:43:35,909
[Applause]

