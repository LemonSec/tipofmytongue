1
00:00:00,030 --> 00:00:02,480
hello

2
00:00:06,899 --> 00:00:10,059
so I'm very proud to announce the next

3
00:00:10,059 --> 00:00:17,670
one the team will talk about West and

4
00:00:17,670 --> 00:00:30,360
how to how to use it with Ruby yeah

5
00:00:37,590 --> 00:00:41,110
[Applause]

6
00:00:41,110 --> 00:00:42,940
yeah so I'm here to talk to you about

7
00:00:42,940 --> 00:00:45,100
ember be rust and Windows probably all

8
00:00:45,100 --> 00:00:46,990
very niche things to probably many of

9
00:00:46,990 --> 00:00:49,810
you in this audience I recently got a

10
00:00:49,810 --> 00:00:51,700
Windows laptop at work so I'm pretty on

11
00:00:51,700 --> 00:00:53,650
big on a Windows hi I did half these

12
00:00:53,650 --> 00:00:57,310
slides on Windows like Christophe said

13
00:00:57,310 --> 00:01:00,870
I'm Terrence I go by home 0-2 on Twitter

14
00:01:00,870 --> 00:01:04,180
I'm famously known for my blue hats I

15
00:01:04,180 --> 00:01:05,530
have blue hat stickers here if you would

16
00:01:05,530 --> 00:01:09,550
like some I work at Haku work on Ruby

17
00:01:09,550 --> 00:01:11,890
stuff there as well as some other things

18
00:01:11,890 --> 00:01:14,350
I brought some shirts and stickers and

19
00:01:14,350 --> 00:01:16,990
stuff so come say hi be happy to give

20
00:01:16,990 --> 00:01:20,200
you some swag if you would like come

21
00:01:20,200 --> 00:01:22,299
from Austin we have some amazing tacos

22
00:01:22,299 --> 00:01:25,360
if you ever in town definitely hit me up

23
00:01:25,360 --> 00:01:26,590
and I'd be happy to take you out for

24
00:01:26,590 --> 00:01:28,240
some tacos I think going like five

25
00:01:28,240 --> 00:01:31,360
people actually for all the talks I've

26
00:01:31,360 --> 00:01:36,130
given actually hit me up on this and I

27
00:01:36,130 --> 00:01:38,770
also run a conference in town call it

28
00:01:38,770 --> 00:01:42,460
cheaper be weird so please submit the

29
00:01:42,460 --> 00:01:45,400
next time we open our CFP for that and

30
00:01:45,400 --> 00:01:47,650
that's kind of it for the intro so let's

31
00:01:47,650 --> 00:01:51,640
actually get to the meat of the talk so

32
00:01:51,640 --> 00:01:54,430
today we're gonna cover a kind of the

33
00:01:54,430 --> 00:01:57,549
state of Windows and Ruby hint not a

34
00:01:57,549 --> 00:01:58,780
very good one

35
00:01:58,780 --> 00:02:01,119
go through a quick intro of em ravine

36
00:02:01,119 --> 00:02:03,310
rust because I think many people here

37
00:02:03,310 --> 00:02:05,619
probably not familiar with either or

38
00:02:05,619 --> 00:02:07,240
both of those technologies talk about

39
00:02:07,240 --> 00:02:09,788
how to use em review with rust and then

40
00:02:09,788 --> 00:02:12,310
kind of any future work and what we have

41
00:02:12,310 --> 00:02:15,459
going on with all that stuff going

42
00:02:15,459 --> 00:02:16,780
forward

43
00:02:16,780 --> 00:02:22,750
so with Ruby on Windows the Heroku CLI

44
00:02:22,750 --> 00:02:25,060
used to be actually written in Ruby and

45
00:02:25,060 --> 00:02:27,730
then we rewrote in and go and then we're

46
00:02:27,730 --> 00:02:30,360
looking at various plugin systems and

47
00:02:30,360 --> 00:02:32,920
Ruby was on the table at one point but

48
00:02:32,920 --> 00:02:35,110
it got quickly moved off because of the

49
00:02:35,110 --> 00:02:37,390
fact that we have I think like 50% of

50
00:02:37,390 --> 00:02:39,010
the people that hit dev Center which is

51
00:02:39,010 --> 00:02:40,060
our documentation so you're actually

52
00:02:40,060 --> 00:02:43,840
Windows users and so the fact that Ruby

53
00:02:43,840 --> 00:02:46,570
does not work very well in Windows made

54
00:02:46,570 --> 00:02:48,130
it where it wasn't actually a viable

55
00:02:48,130 --> 00:02:49,989
option anymore even though we had a ton

56
00:02:49,989 --> 00:02:53,320
of people in the house who didn't like

57
00:02:53,320 --> 00:02:54,850
JavaScript and that was kind of the

58
00:02:54,850 --> 00:02:56,620
technology that you went for there was

59
00:02:56,620 --> 00:02:57,850
actually this huge github issue

60
00:02:57,850 --> 00:03:00,430
internally that was talking about like

61
00:03:00,430 --> 00:03:02,440
why did we pick this thing because like

62
00:03:02,440 --> 00:03:04,060
a ton of people hated writing plugins

63
00:03:04,060 --> 00:03:06,130
with it but it was the technology we

64
00:03:06,130 --> 00:03:09,280
picked because JavaScript on Windows is

65
00:03:09,280 --> 00:03:10,840
actually really good so if you go to the

66
00:03:10,840 --> 00:03:12,670
node.js page they actually have binary

67
00:03:12,670 --> 00:03:15,280
installers for all the major operating

68
00:03:15,280 --> 00:03:16,930
systems you can download the source code

69
00:03:16,930 --> 00:03:19,840
tarball but like most importantly you

70
00:03:19,840 --> 00:03:21,100
can actually just download a Windows

71
00:03:21,100 --> 00:03:23,380
installer and install node and get it up

72
00:03:23,380 --> 00:03:25,030
and running through a wizard that like

73
00:03:25,030 --> 00:03:26,500
people on Windows or normally would

74
00:03:26,500 --> 00:03:28,930
expect in addition to that like

75
00:03:28,930 --> 00:03:31,269
Microsoft or lasts like a few years have

76
00:03:31,269 --> 00:03:33,880
been invested heavily with node and

77
00:03:33,880 --> 00:03:35,500
JavaScript on the Windows platform to

78
00:03:35,500 --> 00:03:37,060
get it up and running working well

79
00:03:37,060 --> 00:03:39,330
making sure all the libraries and things

80
00:03:39,330 --> 00:03:41,769
work out of the box as a great

81
00:03:41,769 --> 00:03:43,299
experience on Windows and if you have

82
00:03:43,299 --> 00:03:45,010
problems like they're definitely there

83
00:03:45,010 --> 00:03:47,769
to like try to fix that stuff so all

84
00:03:47,769 --> 00:03:49,810
those decisions help make it an obvious

85
00:03:49,810 --> 00:03:51,760
choice for us even if it wasn't the

86
00:03:51,760 --> 00:03:53,140
technology choice we would have liked to

87
00:03:53,140 --> 00:03:58,450
internally as a company and in addition

88
00:03:58,450 --> 00:03:59,920
to javascript like pipeline actually has

89
00:03:59,920 --> 00:04:01,030
pretty good Windows support it has a

90
00:04:01,030 --> 00:04:03,700
fairly decent sized Windows community

91
00:04:03,700 --> 00:04:06,040
and again like they have this pattern of

92
00:04:06,040 --> 00:04:07,900
having Windows installers right on the

93
00:04:07,900 --> 00:04:10,120
Python homepage and go and download it

94
00:04:10,120 --> 00:04:12,100
and just like install Python fairly

95
00:04:12,100 --> 00:04:13,959
easily and it's super popular in the

96
00:04:13,959 --> 00:04:15,790
academic community scifi and all that

97
00:04:15,790 --> 00:04:18,850
stuff of course if you go and look at

98
00:04:18,850 --> 00:04:20,500
action installing Ruby I think when most

99
00:04:20,500 --> 00:04:22,660
people get talked about like okay how do

100
00:04:22,660 --> 00:04:24,010
I step Ruby I'm gonna rip user I've

101
00:04:24,010 --> 00:04:25,630
never used room before you ought to get

102
00:04:25,630 --> 00:04:29,240
told to use one of these like Ruby

103
00:04:29,240 --> 00:04:32,639
see cheaper be RVM and rebuild

104
00:04:32,639 --> 00:04:34,620
you know I are p.m. myself and I know

105
00:04:34,620 --> 00:04:35,699
flying people that use all the other

106
00:04:35,699 --> 00:04:37,979
stuff but of course like all this stuff

107
00:04:37,979 --> 00:04:40,290
actually depends on Bosch so out of the

108
00:04:40,290 --> 00:04:41,669
box this doesn't even work on Windows

109
00:04:41,669 --> 00:04:43,260
and if you want to work on Windows you

110
00:04:43,260 --> 00:04:45,060
have to insult like cygwin and kind of

111
00:04:45,060 --> 00:04:46,440
go through all that stuff to get this

112
00:04:46,440 --> 00:04:50,820
canoe compatible shell system and then

113
00:04:50,820 --> 00:04:53,010
if you want to actually use something

114
00:04:53,010 --> 00:04:54,840
that is more similar to like a normal

115
00:04:54,840 --> 00:04:56,190
installer you can use Ruby installer

116
00:04:56,190 --> 00:04:59,010
which is this fantastic project but this

117
00:04:59,010 --> 00:05:00,810
is a post from December which wasn't

118
00:05:00,810 --> 00:05:02,600
even very long ago about how the current

119
00:05:02,600 --> 00:05:04,560
maintainer is looking for a new

120
00:05:04,560 --> 00:05:07,770
maintainer to help them out and they

121
00:05:07,770 --> 00:05:10,580
still don't even have like a Ruby to 4'o

122
00:05:10,580 --> 00:05:13,260
installed because it takes a bunch of

123
00:05:13,260 --> 00:05:14,550
time and effort and work to actually

124
00:05:14,550 --> 00:05:16,470
package up all this stuff to get it up

125
00:05:16,470 --> 00:05:18,320
and running and this isn't even like

126
00:05:18,320 --> 00:05:20,880
maintained or supported by the core team

127
00:05:20,880 --> 00:05:22,710
but it's not like the core teams

128
00:05:22,710 --> 00:05:23,880
actually against like any of this stuff

129
00:05:23,880 --> 00:05:25,560
it's just we don't package up any

130
00:05:25,560 --> 00:05:27,930
binaries for any operating systems we

131
00:05:27,930 --> 00:05:29,460
just provide source tarball and sure

132
00:05:29,460 --> 00:05:32,880
that action compiles and works so that's

133
00:05:32,880 --> 00:05:34,349
not great like the install experience

134
00:05:34,349 --> 00:05:36,539
not so good we're really pushing Windows

135
00:05:36,539 --> 00:05:39,210
people away whereas I feel like the

136
00:05:39,210 --> 00:05:40,680
noted Python examples like they're

137
00:05:40,680 --> 00:05:41,970
really embracing the fact that it's

138
00:05:41,970 --> 00:05:43,410
really easy yet up and started on

139
00:05:43,410 --> 00:05:45,570
Windows for that particular ecosystem

140
00:05:45,570 --> 00:05:47,580
and there's a lot of Windows users out

141
00:05:47,580 --> 00:05:50,099
there so even if you go through all

142
00:05:50,099 --> 00:05:51,090
these hurdles to get all that stuff

143
00:05:51,090 --> 00:05:53,220
running your experience of using Ruby on

144
00:05:53,220 --> 00:05:54,599
those platforms if you have ever tried

145
00:05:54,599 --> 00:05:56,340
it or worked at like a rails bridge or

146
00:05:56,340 --> 00:05:58,860
rails girls you well know that it's not

147
00:05:58,860 --> 00:06:01,740
great so Nate talked a little bit about

148
00:06:01,740 --> 00:06:03,870
forking stuff and in last talk but

149
00:06:03,870 --> 00:06:07,500
unicorn is was least one them is one of

150
00:06:07,500 --> 00:06:09,120
the more popular 14 web servers out

151
00:06:09,120 --> 00:06:10,979
there and it blatantly just does not

152
00:06:10,979 --> 00:06:13,349
support anything on Windows and that's

153
00:06:13,349 --> 00:06:15,599
because I think the Ruby source code

154
00:06:15,599 --> 00:06:18,570
does not actually work on Windows for

155
00:06:18,570 --> 00:06:19,680
being able to do for it so you can't

156
00:06:19,680 --> 00:06:23,010
even do it so that doesn't work and then

157
00:06:23,010 --> 00:06:26,630
we have this whole like cross-platform

158
00:06:26,630 --> 00:06:29,300
Ruby gen ecosystem with architectures

159
00:06:29,300 --> 00:06:31,889
but like older versions of nova Gary's

160
00:06:31,889 --> 00:06:35,699
so if you're using no Gary 141 it is a

161
00:06:35,699 --> 00:06:37,950
window specific version of the binary to

162
00:06:37,950 --> 00:06:40,500
fix bugs that were in 142 you can see

163
00:06:40,500 --> 00:06:42,180
that it was yanked

164
00:06:42,180 --> 00:06:43,740
but if you're Debian windows and use

165
00:06:43,740 --> 00:06:45,810
this version and then you tried to

166
00:06:45,810 --> 00:06:48,090
deploy it on any other UNIX system like

167
00:06:48,090 --> 00:06:50,310
that deployment would fail because this

168
00:06:50,310 --> 00:06:51,660
version doesn't actually exist on any

169
00:06:51,660 --> 00:06:53,699
other architecture so there's problems

170
00:06:53,699 --> 00:06:55,560
that has been mostly solved but they do

171
00:06:55,560 --> 00:06:57,780
exist of just like different version

172
00:06:57,780 --> 00:06:59,039
numbers don't match the different

173
00:06:59,039 --> 00:07:00,780
architectures so potentially there are

174
00:07:00,780 --> 00:07:02,580
other problems of just like trying to

175
00:07:02,580 --> 00:07:05,270
use Windows as a development platform

176
00:07:05,270 --> 00:07:08,400
and so kind of this short is that we

177
00:07:08,400 --> 00:07:10,350
don't really have a very healthy windows

178
00:07:10,350 --> 00:07:12,570
ecosystem if one at all it's kind of a

179
00:07:12,570 --> 00:07:14,910
best effort for like I think every gem

180
00:07:14,910 --> 00:07:16,500
author because most people just aren't

181
00:07:16,500 --> 00:07:18,300
using Windows as a primary development

182
00:07:18,300 --> 00:07:24,000
platform so now that we've kind of set

183
00:07:24,000 --> 00:07:25,860
the stage about like how Windows isn't

184
00:07:25,860 --> 00:07:27,960
great for Ruby let's talk a little about

185
00:07:27,960 --> 00:07:31,050
em Ruby so for those of you who don't

186
00:07:31,050 --> 00:07:33,180
know em Ruby's stands for embeddable

187
00:07:33,180 --> 00:07:35,669
Ruby and it's a implementation of the

188
00:07:35,669 --> 00:07:37,770
Ruby VM created by Matz mainly catered

189
00:07:37,770 --> 00:07:40,229
towards kind of embeddable devices where

190
00:07:40,229 --> 00:07:42,419
you can embed this language like Lua

191
00:07:42,419 --> 00:07:45,330
into other languages coming this was

192
00:07:45,330 --> 00:07:46,800
done with flame which is like C it's

193
00:07:46,800 --> 00:07:48,570
very easy to interrupt with C with ember

194
00:07:48,570 --> 00:07:51,180
B and it supports kind of the main

195
00:07:51,180 --> 00:07:53,099
syntax and ISO standard stuff that you

196
00:07:53,099 --> 00:07:54,659
would expect from Ruby

197
00:07:54,659 --> 00:07:57,030
but as big caveat since it has to

198
00:07:57,030 --> 00:07:58,860
actually work with a bunch of different

199
00:07:58,860 --> 00:08:00,659
architectures and work on embeddable

200
00:08:00,659 --> 00:08:03,539
devices like Arduino or Raspberry Pi and

201
00:08:03,539 --> 00:08:05,820
other things that don't have necessary a

202
00:08:05,820 --> 00:08:07,620
full like UNIX operating system behind

203
00:08:07,620 --> 00:08:08,280
it

204
00:08:08,280 --> 00:08:10,349
none of the like operating system level

205
00:08:10,349 --> 00:08:13,349
standard library things that you're used

206
00:08:13,349 --> 00:08:15,690
to having an MRI exist on em Ruby out of

207
00:08:15,690 --> 00:08:16,199
the box

208
00:08:16,199 --> 00:08:18,240
so you don't have stuff like file or

209
00:08:18,240 --> 00:08:20,690
socket or any i/o built in tamra be

210
00:08:20,690 --> 00:08:23,909
things like threads or forking is an

211
00:08:23,909 --> 00:08:25,229
either because those are operating

212
00:08:25,229 --> 00:08:29,130
system-level features but what you do

213
00:08:29,130 --> 00:08:31,229
get is you get the subset of the Ruby 2

214
00:08:31,229 --> 00:08:34,799
one syntax and language so it feels like

215
00:08:34,799 --> 00:08:36,779
Ruby because it is Ruby so you get procs

216
00:08:36,779 --> 00:08:39,208
blocks you can monkey patch you have

217
00:08:39,208 --> 00:08:42,690
hash literals like you can just write

218
00:08:42,690 --> 00:08:44,550
them in line or arrays which is not true

219
00:08:44,550 --> 00:08:47,520
and a lot of other languages like if you

220
00:08:47,520 --> 00:08:48,930
try to write a hash in Java you actually

221
00:08:48,930 --> 00:08:50,610
have to light can use the constructor

222
00:08:50,610 --> 00:08:52,020
and then actually like index into each

223
00:08:52,020 --> 00:08:54,560
one individually to do that

224
00:08:54,560 --> 00:08:56,450
as an emperor you can just do it like it

225
00:08:56,450 --> 00:09:01,340
was in Ruby and since we don't actually

226
00:09:01,340 --> 00:09:03,980
have all this stuff in center Lib you

227
00:09:03,980 --> 00:09:05,180
have to depend on some type of ecosystem

228
00:09:05,180 --> 00:09:07,450
to get a lot of these libraries right so

229
00:09:07,450 --> 00:09:12,680
the equivalent of ruby gems is called an

230
00:09:12,680 --> 00:09:16,550
M art B gem so inside of M Ruby you have

231
00:09:16,550 --> 00:09:19,310
an MB gem which is this rake file that

232
00:09:19,310 --> 00:09:21,650
is basically just like a ruby gem right

233
00:09:21,650 --> 00:09:24,680
file specification gem specification so

234
00:09:24,680 --> 00:09:26,480
you have a name some metadata you can

235
00:09:26,480 --> 00:09:28,100
add some dependencies should look pretty

236
00:09:28,100 --> 00:09:29,810
familiar for anyone who's written a ruby

237
00:09:29,810 --> 00:09:34,100
gem and actually out of the m ruby

238
00:09:34,100 --> 00:09:37,640
distribution there is in the core set of

239
00:09:37,640 --> 00:09:41,089
MRB gems so since M Ruby is meant to be

240
00:09:41,089 --> 00:09:44,839
embedded a lot of the stuff in standard

241
00:09:44,839 --> 00:09:46,400
Lib is stripped down so you have like a

242
00:09:46,400 --> 00:09:48,500
smaller version of array if you want to

243
00:09:48,500 --> 00:09:51,020
access a lot of like extra fancy

244
00:09:51,020 --> 00:09:52,820
features like slicing and other things

245
00:09:52,820 --> 00:09:53,930
you actually have to pull that in

246
00:09:53,930 --> 00:09:56,000
because you may not need that normally

247
00:09:56,000 --> 00:09:57,650
so you don't package the kitchen sink by

248
00:09:57,650 --> 00:09:59,570
default you actually slim it down to be

249
00:09:59,570 --> 00:10:01,460
as small as possible so people do need

250
00:10:01,460 --> 00:10:03,080
that feature can actually just bundle in

251
00:10:03,080 --> 00:10:05,390
ever be a ray extension or like the

252
00:10:05,390 --> 00:10:07,070
numerator thing for things they actually

253
00:10:07,070 --> 00:10:08,930
need so you can actually bundle in just

254
00:10:08,930 --> 00:10:10,790
the things that you need and not like

255
00:10:10,790 --> 00:10:12,860
everything that is in standard library

256
00:10:12,860 --> 00:10:17,570
unlike MRI and there's actually this

257
00:10:17,570 --> 00:10:19,850
thing called M gem list which is kind of

258
00:10:19,850 --> 00:10:22,040
the central repository on github that

259
00:10:22,040 --> 00:10:24,800
maintains a list of all the M gems that

260
00:10:24,800 --> 00:10:28,400
are kind of publicly accessible and

261
00:10:28,400 --> 00:10:30,830
there's over 400 last time I counted so

262
00:10:30,830 --> 00:10:32,750
not like a ginormous number but it's not

263
00:10:32,750 --> 00:10:34,339
a miniscule number either so you can get

264
00:10:34,339 --> 00:10:36,890
access to things like sake a XML parsing

265
00:10:36,890 --> 00:10:39,110
there's a Redis client there's a bunch

266
00:10:39,110 --> 00:10:43,070
of encryption stuff and so more often

267
00:10:43,070 --> 00:10:44,630
that like a lot of stuff I've actually

268
00:10:44,630 --> 00:10:46,459
be able to find for kind of day to day

269
00:10:46,459 --> 00:10:47,570
kind of things but there definitely

270
00:10:47,570 --> 00:10:50,000
other things that I've needed that kind

271
00:10:50,000 --> 00:10:53,870
of just aren't available but what is

272
00:10:53,870 --> 00:10:56,450
kind of the state of like we have this

273
00:10:56,450 --> 00:10:58,100
fresh ecosystem because you aren't just

274
00:10:58,100 --> 00:11:00,110
using ruby gems because you can't just

275
00:11:00,110 --> 00:11:02,089
use a ruby gem because most ruby gems

276
00:11:02,089 --> 00:11:04,730
expect standard Lib to exists so like

277
00:11:04,730 --> 00:11:06,920
just taking the pure

278
00:11:06,920 --> 00:11:09,320
code of rubygems and trying to run that

279
00:11:09,320 --> 00:11:10,700
em Ruby doesn't really work super well

280
00:11:10,700 --> 00:11:13,640
if that library doesn't exist in M Ruby

281
00:11:13,640 --> 00:11:16,160
so we kind of have this fresh start to

282
00:11:16,160 --> 00:11:17,840
be able to rebuild this ecosystem out

283
00:11:17,840 --> 00:11:21,950
there and so the support of Mr B gems

284
00:11:21,950 --> 00:11:23,570
and Windows today is not necessarily the

285
00:11:23,570 --> 00:11:25,520
best because most of you who are writing

286
00:11:25,520 --> 00:11:28,070
and review stuff come from Ruby and that

287
00:11:28,070 --> 00:11:29,960
means you're taking an existing Ruby

288
00:11:29,960 --> 00:11:32,150
code and trying to port it into a movie

289
00:11:32,150 --> 00:11:34,070
so you're taking stuff from standard Lib

290
00:11:34,070 --> 00:11:36,110
you're probably building an interface

291
00:11:36,110 --> 00:11:37,940
like there's MOV i/o which is actually

292
00:11:37,940 --> 00:11:41,150
just support of the i/o module from

293
00:11:41,150 --> 00:11:44,180
standard live as an MRP gem and of

294
00:11:44,180 --> 00:11:46,760
course that's all kind of this POSIX

295
00:11:46,760 --> 00:11:51,440
UNIX based format and so making similar

296
00:11:51,440 --> 00:11:56,780
mistakes today and ever be gems so as an

297
00:11:56,780 --> 00:11:59,680
example with ember beast m ruby socket

298
00:11:59,680 --> 00:12:03,020
zachary Scott last year basically added

299
00:12:03,020 --> 00:12:04,550
a patch so it could actually compile on

300
00:12:04,550 --> 00:12:07,280
Windows last year and when I was talking

301
00:12:07,280 --> 00:12:09,530
to him on the phone about this he told

302
00:12:09,530 --> 00:12:11,270
me he actually just copy and pasted this

303
00:12:11,270 --> 00:12:12,980
code from Stack Overflow and then

304
00:12:12,980 --> 00:12:14,510
submitted a pull request and it got

305
00:12:14,510 --> 00:12:16,940
merged in and like it's from some other

306
00:12:16,940 --> 00:12:19,730
library that made this a bunch of the

307
00:12:19,730 --> 00:12:22,760
socket stuff work and so you know that's

308
00:12:22,760 --> 00:12:24,320
if this is like the stable-yard of like

309
00:12:24,320 --> 00:12:25,790
Windows support it's probably not like

310
00:12:25,790 --> 00:12:29,540
super grade and like two years ago I was

311
00:12:29,540 --> 00:12:32,990
doing some stuff with M Ruby ml so I

312
00:12:32,990 --> 00:12:35,240
took someone else's ember BM all forked

313
00:12:35,240 --> 00:12:36,980
it and I was trying to get to cross

314
00:12:36,980 --> 00:12:40,070
compile on Windows and Libby ml by

315
00:12:40,070 --> 00:12:42,260
default like out-of-the-box we just take

316
00:12:42,260 --> 00:12:43,940
the seed library works on Windows fine

317
00:12:43,940 --> 00:12:46,910
you can pilot with on Visual Studio you

318
00:12:46,910 --> 00:12:48,320
can file it with you and all this stuff

319
00:12:48,320 --> 00:12:50,420
and it works great but actually cross

320
00:12:50,420 --> 00:12:52,280
compiling and it took like many many

321
00:12:52,280 --> 00:12:54,020
Friday nights which I'm sure could have

322
00:12:54,020 --> 00:12:55,280
been better spent doing other things but

323
00:12:55,280 --> 00:12:57,440
you have to figure out the this like

324
00:12:57,440 --> 00:12:59,810
yeah mal declare static C flag that I

325
00:12:59,810 --> 00:13:01,820
need to pass to actually like compile it

326
00:13:01,820 --> 00:13:05,510
statically because the - Jack static

327
00:13:05,510 --> 00:13:07,310
flag that worked on UNIX just didn't

328
00:13:07,310 --> 00:13:09,820
work properly when I was cross compiling

329
00:13:09,820 --> 00:13:11,960
because the way it does like operating

330
00:13:11,960 --> 00:13:14,060
system level detection so in order to

331
00:13:14,060 --> 00:13:15,650
kind of like make all this stuff work

332
00:13:15,650 --> 00:13:17,600
you have to for even C libraries that

333
00:13:17,600 --> 00:13:19,220
work on Windows you have to

334
00:13:19,220 --> 00:13:20,779
kind of dive in and figure all these

335
00:13:20,779 --> 00:13:23,449
pieces out and of course like building

336
00:13:23,449 --> 00:13:26,000
inside of sea is like a special place

337
00:13:26,000 --> 00:13:28,399
because like every seed project decides

338
00:13:28,399 --> 00:13:29,930
to like have their own different like

339
00:13:29,930 --> 00:13:31,639
bill tool so you're either using see

340
00:13:31,639 --> 00:13:34,160
make auto comm scons or something else

341
00:13:34,160 --> 00:13:35,629
and like you basically have to fight

342
00:13:35,629 --> 00:13:37,160
that system and learn this new other

343
00:13:37,160 --> 00:13:40,459
make system every time so that wasn't

344
00:13:40,459 --> 00:13:43,519
super awesome and kind of meth in the

345
00:13:43,519 --> 00:13:45,110
day like I was saying before where we're

346
00:13:45,110 --> 00:13:47,029
basically taking all these existing Ruby

347
00:13:47,029 --> 00:13:49,819
projects and we missed them because we

348
00:13:49,819 --> 00:13:51,410
want be able to do productive things and

349
00:13:51,410 --> 00:13:53,329
we're just pouring them over copying the

350
00:13:53,329 --> 00:13:55,069
same mistakes that we're making MRI for

351
00:13:55,069 --> 00:13:57,769
supporting Windows which is not super

352
00:13:57,769 --> 00:14:02,300
awesome so that's kind of the short

353
00:14:02,300 --> 00:14:07,819
intro to em Ruby and so I want to take a

354
00:14:07,819 --> 00:14:09,680
quick tour of rust I've been playing

355
00:14:09,680 --> 00:14:12,170
with rust a lot recently it's probably

356
00:14:12,170 --> 00:14:14,899
mostly you who does fault and for those

357
00:14:14,899 --> 00:14:16,129
of you who don't know it's a system

358
00:14:16,129 --> 00:14:18,889
scrubbing language so similar problem

359
00:14:18,889 --> 00:14:21,920
space as something like C or C++ so if

360
00:14:21,920 --> 00:14:23,300
you're writing native extensions in Ruby

361
00:14:23,300 --> 00:14:24,949
you know you're writing stuff and C Ruby

362
00:14:24,949 --> 00:14:27,589
the language itself is written and C and

363
00:14:27,589 --> 00:14:29,000
what makes it really compelling is that

364
00:14:29,000 --> 00:14:31,250
they make these safety guarantees about

365
00:14:31,250 --> 00:14:33,620
preventing seg faults and about threat

366
00:14:33,620 --> 00:14:35,360
safety and things that are really

367
00:14:35,360 --> 00:14:37,730
relevant I guess like in today's like

368
00:14:37,730 --> 00:14:43,459
multi CPU architecture stuff and one of

369
00:14:43,459 --> 00:14:45,259
the things that you to really harpes at

370
00:14:45,259 --> 00:14:47,089
me about with rust is that it's an

371
00:14:47,089 --> 00:14:50,269
enabler of a language and what I mean by

372
00:14:50,269 --> 00:14:52,370
that is that enables people a lot of

373
00:14:52,370 --> 00:14:54,529
people now to pick up something like

374
00:14:54,529 --> 00:14:57,079
rust who may not have been comfortable

375
00:14:57,079 --> 00:14:58,490
or familiar with picking up something

376
00:14:58,490 --> 00:14:59,959
like C and felt comfortable actually

377
00:14:59,959 --> 00:15:01,730
running it not that these particularly

378
00:15:01,730 --> 00:15:04,490
hard to pick up but it's not easy to

379
00:15:04,490 --> 00:15:07,600
become good at writing C

380
00:15:13,900 --> 00:15:15,959
you

381
00:15:17,900 --> 00:15:21,589
those rustle especially right

382
00:15:21,589 --> 00:15:25,010
system-level programming code that works

383
00:15:25,010 --> 00:15:27,260
and you can feel safe about not leaking

384
00:15:27,260 --> 00:15:31,580
memory and so kind of to hit this point

385
00:15:31,580 --> 00:15:33,350
even home even more so no kagiri

386
00:15:33,350 --> 00:15:34,970
I'm sure many of you used it if you're

387
00:15:34,970 --> 00:15:36,920
using any rails app the XML parser

388
00:15:36,920 --> 00:15:40,250
that's built on top of web XML - these

389
00:15:40,250 --> 00:15:42,380
are people who are pretty seasoned like

390
00:15:42,380 --> 00:15:43,970
C developers who are maintaining the C

391
00:15:43,970 --> 00:15:46,640
extension on top of XML - if you just

392
00:15:46,640 --> 00:15:48,890
search there are definitely like seg

393
00:15:48,890 --> 00:15:50,630
faults that happen so like even people

394
00:15:50,630 --> 00:15:53,930
who do see on a regular basis can still

395
00:15:53,930 --> 00:15:57,050
make mistakes I mean open SSL right like

396
00:15:57,050 --> 00:15:58,520
they're just tons of stuff out in the

397
00:15:58,520 --> 00:16:00,760
wild where this happens all the time

398
00:16:00,760 --> 00:16:03,320
and these are people who program and see

399
00:16:03,320 --> 00:16:07,250
like every day and so I think one of the

400
00:16:07,250 --> 00:16:09,290
really compelling things that Russ makes

401
00:16:09,290 --> 00:16:10,940
with regards to safety and what the

402
00:16:10,940 --> 00:16:12,320
naval man is that if you can

403
00:16:12,320 --> 00:16:15,230
successfully compiled a Russ program it

404
00:16:15,230 --> 00:16:17,270
will not sag fall at runtime you may run

405
00:16:17,270 --> 00:16:18,830
to other problems but it actually won't

406
00:16:18,830 --> 00:16:21,290
seg fault and that's a really amazing

407
00:16:21,290 --> 00:16:23,209
guarantee to make as a systems foreign

408
00:16:23,209 --> 00:16:25,730
language and the way it she it achieves

409
00:16:25,730 --> 00:16:27,260
that is through this ownership model the

410
00:16:27,260 --> 00:16:29,270
fact that through compiled time it can

411
00:16:29,270 --> 00:16:31,430
actually track how memory is being

412
00:16:31,430 --> 00:16:34,610
referenced and used so you have to write

413
00:16:34,610 --> 00:16:36,770
your programming in a different way but

414
00:16:36,770 --> 00:16:39,770
the guarantees you get or that the

415
00:16:39,770 --> 00:16:41,990
compiler is actually making sure that

416
00:16:41,990 --> 00:16:44,480
the way you write your code is making

417
00:16:44,480 --> 00:16:45,650
sure you're not leaving any dangling

418
00:16:45,650 --> 00:16:50,300
pointers around and the next point that

419
00:16:50,300 --> 00:16:51,560
is really interesting is since it's a

420
00:16:51,560 --> 00:16:52,730
system foreign language it has to be

421
00:16:52,730 --> 00:16:55,520
fast and so if you ever done any

422
00:16:55,520 --> 00:16:57,230
assistance learning language stuff

423
00:16:57,230 --> 00:16:58,670
you've probably written stuff that looks

424
00:16:58,670 --> 00:17:00,560
fairly similar this this is actual Russ

425
00:17:00,560 --> 00:17:03,470
code and what I'm trying to do here is

426
00:17:03,470 --> 00:17:05,240
fairly simple I have an array and I'm

427
00:17:05,240 --> 00:17:06,559
just trying to calculate this on a bit

428
00:17:06,559 --> 00:17:09,439
and so if you're doing this and like

429
00:17:09,439 --> 00:17:10,760
some interpreting class you're probably

430
00:17:10,760 --> 00:17:12,709
you have this array you're gonna iterate

431
00:17:12,709 --> 00:17:14,750
over through the thing using some for

432
00:17:14,750 --> 00:17:16,040
loop and then you're gonna hold the sum

433
00:17:16,040 --> 00:17:19,040
in some variable and then we'll just

434
00:17:19,040 --> 00:17:20,720
print the value at the end so this is a

435
00:17:20,720 --> 00:17:22,910
pretty easy example even if you don't

436
00:17:22,910 --> 00:17:24,800
know any Russ you can easily read what

437
00:17:24,800 --> 00:17:28,250
this is doing so but this is probably

438
00:17:28,250 --> 00:17:30,290
more what you're akin to in Ruby so you

439
00:17:30,290 --> 00:17:31,340
have these like high level abstractions

440
00:17:31,340 --> 00:17:32,090
this

441
00:17:32,090 --> 00:17:35,179
is valid rust and so you can make an

442
00:17:35,179 --> 00:17:37,340
iterator on this array and then you call

443
00:17:37,340 --> 00:17:40,309
fold which is like inject in Ruby and it

444
00:17:40,309 --> 00:17:42,440
even borrows thanks you to the pipe

445
00:17:42,440 --> 00:17:44,720
syntax for specifying the variables and

446
00:17:44,720 --> 00:17:47,150
so with here we have a starting value of

447
00:17:47,150 --> 00:17:49,520
zero and we're folding over the addition

448
00:17:49,520 --> 00:17:51,770
of the starting of the carry over

449
00:17:51,770 --> 00:17:54,230
accumulator sum and then each element

450
00:17:54,230 --> 00:17:56,240
value and then at the end of it we get

451
00:17:56,240 --> 00:17:58,120
the toll sum value so this one line

452
00:17:58,120 --> 00:18:01,610
looks much nicer and more Ruby like than

453
00:18:01,610 --> 00:18:05,330
this and this is valid rough syntax just

454
00:18:05,330 --> 00:18:07,010
built in the standard library and what's

455
00:18:07,010 --> 00:18:08,510
amazing about is you aren't actually

456
00:18:08,510 --> 00:18:10,010
making any trade-offs here on

457
00:18:10,010 --> 00:18:12,169
performance by using this better

458
00:18:12,169 --> 00:18:14,419
abstraction right what using fold is

459
00:18:14,419 --> 00:18:15,980
actually faster than writing the for

460
00:18:15,980 --> 00:18:19,880
loop because in rust the compiler now

461
00:18:19,880 --> 00:18:22,010
knows about the bounds of that array

462
00:18:22,010 --> 00:18:23,419
because you're using the iterator so you

463
00:18:23,419 --> 00:18:25,130
can actually unfold the entire thing and

464
00:18:25,130 --> 00:18:26,390
assembly and not actually loop through

465
00:18:26,390 --> 00:18:28,990
it so you don't have any jump calls and

466
00:18:28,990 --> 00:18:31,130
the more information you give the RUS

467
00:18:31,130 --> 00:18:32,659
Vampira the more optimizations that can

468
00:18:32,659 --> 00:18:35,840
make so that's what russ means by having

469
00:18:35,840 --> 00:18:37,760
a zero cost abstractions that by using

470
00:18:37,760 --> 00:18:39,470
these high-level abstractions you're not

471
00:18:39,470 --> 00:18:40,970
actually making a performance trade-off

472
00:18:40,970 --> 00:18:42,980
like you would oftentimes in Ruby by

473
00:18:42,980 --> 00:18:44,809
using some of these other nicer

474
00:18:44,809 --> 00:18:47,860
functions to make your syntax look nicer

475
00:18:47,860 --> 00:18:51,679
so that's really awesome the next thing

476
00:18:51,679 --> 00:18:53,210
that made it really compelling for me to

477
00:18:53,210 --> 00:18:55,000
start looking at it seriously was that

478
00:18:55,000 --> 00:18:59,720
they have this focus this over in 2016

479
00:18:59,720 --> 00:19:01,909
on cross compilation and they're betting

480
00:19:01,909 --> 00:19:05,120
even more on in 2017 and so as part of

481
00:19:05,120 --> 00:19:07,279
it there's this tool called rust up

482
00:19:07,279 --> 00:19:08,840
which is part of the rust tool chain

483
00:19:08,840 --> 00:19:11,299
that you can use to basically manage

484
00:19:11,299 --> 00:19:13,580
your different versions of rust as well

485
00:19:13,580 --> 00:19:15,049
as kind of the different targets and

486
00:19:15,049 --> 00:19:16,880
architectures you want to compile for so

487
00:19:16,880 --> 00:19:18,409
on a single host you can actually

488
00:19:18,409 --> 00:19:21,649
compile they provide 36 different

489
00:19:21,649 --> 00:19:23,210
architectures that you can compile to

490
00:19:23,210 --> 00:19:25,549
and for interest for me they provide a

491
00:19:25,549 --> 00:19:26,990
lot of the major ones that I care about

492
00:19:26,990 --> 00:19:31,580
so you have 32 and 64-bit OS X Windows

493
00:19:31,580 --> 00:19:35,690
on a new and V Visual Studio as well as

494
00:19:35,690 --> 00:19:38,210
muscle and good new versions of Linux so

495
00:19:38,210 --> 00:19:40,820
from my single Linux host OS I can cross

496
00:19:40,820 --> 00:19:42,020
compile to all these different versions

497
00:19:42,020 --> 00:19:45,770
of rust and make libraries and

498
00:19:45,770 --> 00:19:49,070
that are compatible and one of the other

499
00:19:49,070 --> 00:19:51,080
things that was really great for me was

500
00:19:51,080 --> 00:19:52,580
reading the rest of Ramin they have this

501
00:19:52,580 --> 00:19:55,280
line they have a section called rust up

502
00:19:55,280 --> 00:19:57,710
on windows and the first line is this

503
00:19:57,710 --> 00:19:59,600
thing right here where it says what's up

504
00:19:59,600 --> 00:20:01,070
works the same on windows as it does on

505
00:20:01,070 --> 00:20:01,940
Unix

506
00:20:01,940 --> 00:20:03,440
and so that means they're treating

507
00:20:03,440 --> 00:20:06,910
Windows as a first-class citizen and

508
00:20:06,910 --> 00:20:12,170
rust as a project actually works on

509
00:20:12,170 --> 00:20:15,020
Windows and has to because Mozilla is

510
00:20:15,020 --> 00:20:18,080
deploying rust as part of Firefox now so

511
00:20:18,080 --> 00:20:20,750
as of last year in Firefox 48 it was the

512
00:20:20,750 --> 00:20:22,160
first release of Firefox that actually

513
00:20:22,160 --> 00:20:24,650
ships with production rusts code and so

514
00:20:24,650 --> 00:20:26,090
the piece of code they extracted to

515
00:20:26,090 --> 00:20:29,120
rewrite and rust was the meteor media

516
00:20:29,120 --> 00:20:31,130
player so the media player is written

517
00:20:31,130 --> 00:20:32,390
using rusts and they're able to kind of

518
00:20:32,390 --> 00:20:34,940
sandbox it with these safety guarantees

519
00:20:34,940 --> 00:20:38,510
and they have to actually make Windows

520
00:20:38,510 --> 00:20:39,770
work because they're shipping it with

521
00:20:39,770 --> 00:20:43,070
the browser so so Mozilla who is the

522
00:20:43,070 --> 00:20:46,100
kind of main steward of rust is betting

523
00:20:46,100 --> 00:20:49,430
on rust working on Windows so I have a

524
00:20:49,430 --> 00:20:51,050
lot of confidence that using this as a

525
00:20:51,050 --> 00:20:53,000
base technology for getting all this

526
00:20:53,000 --> 00:20:55,370
stuff to work will guarantee pretty good

527
00:20:55,370 --> 00:20:56,930
Windows support because it means all the

528
00:20:56,930 --> 00:20:58,940
low-level IO stuff has to work pretty

529
00:20:58,940 --> 00:21:01,520
well in addition they have a bunch of

530
00:21:01,520 --> 00:21:02,810
art D work they're doing for browser

531
00:21:02,810 --> 00:21:05,210
stuff in servo that extends beyond just

532
00:21:05,210 --> 00:21:09,740
the Firefox stuff and of course as a

533
00:21:09,740 --> 00:21:11,090
person who's explored out the languages

534
00:21:11,090 --> 00:21:12,890
one of the things I miss the most when

535
00:21:12,890 --> 00:21:14,570
visiting on the Ricoh system is bundler

536
00:21:14,570 --> 00:21:16,760
like having a good package manager is

537
00:21:16,760 --> 00:21:18,380
actually really crucial to being

538
00:21:18,380 --> 00:21:20,960
productive being able to kind of have

539
00:21:20,960 --> 00:21:22,880
these guarantees of like does my code

540
00:21:22,880 --> 00:21:24,140
work and won't work on someone else's

541
00:21:24,140 --> 00:21:28,220
machine and having visited the C world

542
00:21:28,220 --> 00:21:30,140
of Auto comp and C make and all that

543
00:21:30,140 --> 00:21:32,240
stuff it was really nice to know that

544
00:21:32,240 --> 00:21:35,210
you who turn car all helped create cargo

545
00:21:35,210 --> 00:21:37,850
as well as bundler so you see a lot of

546
00:21:37,850 --> 00:21:40,730
analogies in both the way it works in

547
00:21:40,730 --> 00:21:43,220
workflow and as kind of the common

548
00:21:43,220 --> 00:21:45,500
paradigms were used in Ruby so in rust

549
00:21:45,500 --> 00:21:47,660
you have cargo tamil which is equivalent

550
00:21:47,660 --> 00:21:50,690
to your gem file but it isn't just done

551
00:21:50,690 --> 00:21:52,640
empty SL just uses the tamil markup and

552
00:21:52,640 --> 00:21:53,990
you can kind of just specify all your

553
00:21:53,990 --> 00:21:55,790
dependencies that you want like you

554
00:21:55,790 --> 00:21:58,340
would in your gem file and then you have

555
00:21:58,340 --> 00:21:58,940
cargo

556
00:21:58,940 --> 00:22:00,590
old witches command you can run on your

557
00:22:00,590 --> 00:22:02,690
machine locally and this goes like

558
00:22:02,690 --> 00:22:04,370
bundle install goes in fetches and

559
00:22:04,370 --> 00:22:06,200
resolves all the defenses you have so I

560
00:22:06,200 --> 00:22:07,970
only had two dependencies here but it

561
00:22:07,970 --> 00:22:09,260
went and fetched all the dependencies of

562
00:22:09,260 --> 00:22:11,060
those penalties and created a resolution

563
00:22:11,060 --> 00:22:15,080
graph for me and compiled the rust

564
00:22:15,080 --> 00:22:17,120
library for me so I don't have to do

565
00:22:17,120 --> 00:22:18,290
this thing and then figure out how to

566
00:22:18,290 --> 00:22:19,820
actually build my project cargo bill

567
00:22:19,820 --> 00:22:21,410
actually does all that in one step so

568
00:22:21,410 --> 00:22:23,450
like funneled salts like the only thing

569
00:22:23,450 --> 00:22:25,580
I really need to know to actually get my

570
00:22:25,580 --> 00:22:29,420
code to a running state so if I'm

571
00:22:29,420 --> 00:22:31,280
cloning out in another lust project it's

572
00:22:31,280 --> 00:22:32,870
very easy to get started once you have

573
00:22:32,870 --> 00:22:35,570
the tool chain and then beyond that you

574
00:22:35,570 --> 00:22:37,640
have cargo lock which is equivalent to

575
00:22:37,640 --> 00:22:39,620
your gem file that lock and so it has

576
00:22:39,620 --> 00:22:41,090
the complete depends your resolution

577
00:22:41,090 --> 00:22:43,880
graph built into the file so it can be

578
00:22:43,880 --> 00:22:47,650
reproduced on any other person's machine

579
00:22:47,890 --> 00:22:52,130
so with that knowledge like how do we

580
00:22:52,130 --> 00:22:55,160
combined this emery ecosystem and

581
00:22:55,160 --> 00:22:57,680
technology with kind of all these nice

582
00:22:57,680 --> 00:22:59,120
things that Russ brings to the table for

583
00:22:59,120 --> 00:23:02,620
writing systems level programming things

584
00:23:02,620 --> 00:23:06,260
so I think in order to kind of

585
00:23:06,260 --> 00:23:08,090
appreciate some of the stuff that's

586
00:23:08,090 --> 00:23:09,920
happening we have to take a look at how

587
00:23:09,920 --> 00:23:11,720
what it looks like to write an Emer be

588
00:23:11,720 --> 00:23:14,980
gem NC like just the default path and

589
00:23:14,980 --> 00:23:17,480
this is the typical directory structure

590
00:23:17,480 --> 00:23:22,160
of an MRP gem you have in this example

591
00:23:22,160 --> 00:23:23,810
just a very simple thing where I'm just

592
00:23:23,810 --> 00:23:27,080
trying to print hello to the screen so

593
00:23:27,080 --> 00:23:28,760
in my C source code I'm just going to

594
00:23:28,760 --> 00:23:29,990
return the hello string that's

595
00:23:29,990 --> 00:23:32,180
generating and C and convert it into a

596
00:23:32,180 --> 00:23:36,110
movie so we have the C file so inside

597
00:23:36,110 --> 00:23:37,520
the source directory you can put any

598
00:23:37,520 --> 00:23:39,140
number of C files and you call them

599
00:23:39,140 --> 00:23:41,180
whatever you want and the EM Ruby built

600
00:23:41,180 --> 00:23:42,530
to Lac qu eligio through and compiled

601
00:23:42,530 --> 00:23:46,970
all that stuff for you so here's the EM

602
00:23:46,970 --> 00:23:51,950
Ruby C file that I generated and you

603
00:23:51,950 --> 00:23:54,680
need these two classes a knit and final

604
00:23:54,680 --> 00:23:56,780
so geminate is basically where you kind

605
00:23:56,780 --> 00:23:59,360
of construct all the stuff at startup so

606
00:23:59,360 --> 00:24:00,920
you're gonna define your modules and

607
00:24:00,920 --> 00:24:02,720
classes that you want to be able to work

608
00:24:02,720 --> 00:24:05,990
with in C so in this case I am defining

609
00:24:05,990 --> 00:24:09,140
the Hello module calling this ever be

610
00:24:09,140 --> 00:24:10,640
defined module that's part of the EM

611
00:24:10,640 --> 00:24:12,169
Ruby C API and that

612
00:24:12,169 --> 00:24:14,210
define any number of class or instance

613
00:24:14,210 --> 00:24:16,669
level methods on top of it I can define

614
00:24:16,669 --> 00:24:19,009
any other classes as well and I'm making

615
00:24:19,009 --> 00:24:23,289
it called this other C function as the

616
00:24:23,289 --> 00:24:25,399
implementation and then you have to

617
00:24:25,399 --> 00:24:27,499
specify the number of arguments in this

618
00:24:27,499 --> 00:24:29,299
case I don't have any so I can use MRV

619
00:24:29,299 --> 00:24:31,850
arcs none in the final state since we're

620
00:24:31,850 --> 00:24:33,230
in C and we have to manage our own

621
00:24:33,230 --> 00:24:35,269
memory here you have to do any cleanup

622
00:24:35,269 --> 00:24:37,340
work that's not managed by the M Ruby VM

623
00:24:37,340 --> 00:24:39,139
because M Ruby's garbage collected

624
00:24:39,139 --> 00:24:40,999
inside of here so I don't really have

625
00:24:40,999 --> 00:24:42,799
any dangling pointers that are going to

626
00:24:42,799 --> 00:24:44,629
be managed by M Ruby here so I'm really

627
00:24:44,629 --> 00:24:47,720
have to do anything here then finally we

628
00:24:47,720 --> 00:24:49,580
just have the the C code that's actually

629
00:24:49,580 --> 00:24:52,039
being called when I call hello and this

630
00:24:52,039 --> 00:24:54,739
is just a very simple thing we're taking

631
00:24:54,739 --> 00:24:56,330
a C string and we're just converting

632
00:24:56,330 --> 00:24:58,820
into an ember B string and then that way

633
00:24:58,820 --> 00:25:02,450
it's accessible inside the M Ruby VM and

634
00:25:02,450 --> 00:25:04,879
with that we can actually just call a

635
00:25:04,879 --> 00:25:08,210
hello dot hello inside of Ruby like it

636
00:25:08,210 --> 00:25:11,629
was any other Ruby code so that's pretty

637
00:25:11,629 --> 00:25:13,489
nice and easy to do and that's kind of

638
00:25:13,489 --> 00:25:17,059
just how native extensions or native MRB

639
00:25:17,059 --> 00:25:19,809
gems of work in emery

640
00:25:19,809 --> 00:25:23,600
and so to make this work with Russ one

641
00:25:23,600 --> 00:25:24,799
of the nice things that Russ brings to

642
00:25:24,799 --> 00:25:28,629
tables it has a really nice fi system

643
00:25:28,629 --> 00:25:32,359
it's able to at no costs actually just

644
00:25:32,359 --> 00:25:35,749
generate C compatible code so when

645
00:25:35,749 --> 00:25:37,850
you're compiling rust you set the

646
00:25:37,850 --> 00:25:39,739
property no mangle above the method that

647
00:25:39,739 --> 00:25:42,139
you want so Russ doesn't try to make any

648
00:25:42,139 --> 00:25:43,879
optimizations and knows to leave this

649
00:25:43,879 --> 00:25:46,669
function in that address space and not

650
00:25:46,669 --> 00:25:48,049
mess with any of the names or anything

651
00:25:48,049 --> 00:25:50,720
and then you need to extern it to make

652
00:25:50,720 --> 00:25:55,129
it available as a public method so with

653
00:25:55,129 --> 00:25:58,730
this code inside of any C object so if I

654
00:25:58,730 --> 00:26:01,159
have this Russ library inside of any C

655
00:26:01,159 --> 00:26:02,330
code I can actually is called double

656
00:26:02,330 --> 00:26:05,330
input pass in a 32-bit integer and it

657
00:26:05,330 --> 00:26:07,549
will work like I wrote it and C but the

658
00:26:07,549 --> 00:26:08,720
nice thing is actually get all the

659
00:26:08,720 --> 00:26:10,580
safety and other guarantees of the Ross

660
00:26:10,580 --> 00:26:12,649
library from with inside of C because

661
00:26:12,649 --> 00:26:17,379
Russ makes those things at compile time

662
00:26:17,379 --> 00:26:19,669
so that's really nice

663
00:26:19,669 --> 00:26:21,499
and so if I were to take that same

664
00:26:21,499 --> 00:26:23,840
example and try to write it in rust I'm

665
00:26:23,840 --> 00:26:25,460
gonna create a rust folder

666
00:26:25,460 --> 00:26:28,100
and I'm gonna have a car Gautama but I

667
00:26:28,100 --> 00:26:30,830
don't have any other things there and I

668
00:26:30,830 --> 00:26:33,500
just have this lib dot RS for the source

669
00:26:33,500 --> 00:26:38,450
code for lust and so in here you see

670
00:26:38,450 --> 00:26:39,830
similar structures here so I have the

671
00:26:39,830 --> 00:26:42,800
know Mangal so these function names are

672
00:26:42,800 --> 00:26:43,970
just the same as they would be called

673
00:26:43,970 --> 00:26:47,090
and see and one of the reasons I have

674
00:26:47,090 --> 00:26:49,550
these unsafe blocks here is because in

675
00:26:49,550 --> 00:26:51,800
rust with the ownership model you have

676
00:26:51,800 --> 00:26:53,540
to be able to tell the compiler hey I'm

677
00:26:53,540 --> 00:26:56,630
not actually responsible for the life

678
00:26:56,630 --> 00:26:58,490
cycle of these objects called inside

679
00:26:58,490 --> 00:27:00,610
this block since this is a si call like

680
00:27:00,610 --> 00:27:03,080
you're actually responsible or someone's

681
00:27:03,080 --> 00:27:04,790
responsible for managing life cycle of

682
00:27:04,790 --> 00:27:07,250
these objects and the compiler is not so

683
00:27:07,250 --> 00:27:08,990
you're telling the compiler hey I know

684
00:27:08,990 --> 00:27:11,360
what I'm doing don't worry about it this

685
00:27:11,360 --> 00:27:13,310
stuff will get cleaned up and you don't

686
00:27:13,310 --> 00:27:14,870
have to worry about this at compile time

687
00:27:14,870 --> 00:27:18,680
so since I'm making basically these C

688
00:27:18,680 --> 00:27:22,310
API calls from ember B the C API I need

689
00:27:22,310 --> 00:27:24,860
to wrap them in these unsafe blocks so

690
00:27:24,860 --> 00:27:27,800
similar to the C code I'm just defining

691
00:27:27,800 --> 00:27:30,680
a module called rust I'm putting in this

692
00:27:30,680 --> 00:27:33,290
class and then I'm telling it to you use

693
00:27:33,290 --> 00:27:35,330
this function that is built in rust but

694
00:27:35,330 --> 00:27:37,700
will look like a c function when it's

695
00:27:37,700 --> 00:27:40,100
actually compiled so you have the knit

696
00:27:40,100 --> 00:27:42,080
the final in the actual recitation and

697
00:27:42,080 --> 00:27:44,810
that will get you to hello world with

698
00:27:44,810 --> 00:27:48,950
rust and M Ruby and nor do that actually

699
00:27:48,950 --> 00:27:51,350
had to create a wrapper library called M

700
00:27:51,350 --> 00:27:54,230
for Ruby to actually wrap parts of the

701
00:27:54,230 --> 00:27:56,390
Ember BC API to make them available in

702
00:27:56,390 --> 00:28:00,620
rust and so what Mpho ruby is is it's

703
00:28:00,620 --> 00:28:02,660
this rust binding around the Ember of C

704
00:28:02,660 --> 00:28:05,570
API and it's actually split up into two

705
00:28:05,570 --> 00:28:08,000
crates where crates are basically the

706
00:28:08,000 --> 00:28:10,970
package of the name of the packaging in

707
00:28:10,970 --> 00:28:14,930
rust and one ever be gem and so the

708
00:28:14,930 --> 00:28:16,340
reason I did this is because I want to

709
00:28:16,340 --> 00:28:17,750
split up kind of low-level

710
00:28:17,750 --> 00:28:19,640
implementation and like kind of higher

711
00:28:19,640 --> 00:28:22,340
level abstractions so there's Lib M Ruby

712
00:28:22,340 --> 00:28:23,720
cysts which is the low level

713
00:28:23,720 --> 00:28:28,970
implementation and this defines

714
00:28:28,970 --> 00:28:32,750
basically all of the kind of signatures

715
00:28:32,750 --> 00:28:34,910
that I want to be able to access inside

716
00:28:34,910 --> 00:28:37,460
of rust so if you notice in this libbed

717
00:28:37,460 --> 00:28:39,170
RS file

718
00:28:39,170 --> 00:28:42,200
there is no body like actual code

719
00:28:42,200 --> 00:28:43,610
implementation besides the function

720
00:28:43,610 --> 00:28:46,450
signatures so all the all the actual

721
00:28:46,450 --> 00:28:49,160
implementation is in C and I'm just

722
00:28:49,160 --> 00:28:51,020
defining it in Russ so Russ knows about

723
00:28:51,020 --> 00:28:54,920
it and so for instance this Emer be

724
00:28:54,920 --> 00:28:56,360
defined module is something that we

725
00:28:56,360 --> 00:28:59,420
called in that hello world example and

726
00:28:59,420 --> 00:29:02,140
it's the same signature as the C code

727
00:29:02,140 --> 00:29:04,610
because it's just calling the C code

728
00:29:04,610 --> 00:29:10,250
here so that's what Lib Emery sis's and

729
00:29:10,250 --> 00:29:12,260
then we have this other create called M

730
00:29:12,260 --> 00:29:14,270
for Ruby which is kind of the higher

731
00:29:14,270 --> 00:29:15,830
level abstraction that sits on top of

732
00:29:15,830 --> 00:29:19,340
this and so the reason to create this is

733
00:29:19,340 --> 00:29:20,480
because you don't want to actually make

734
00:29:20,480 --> 00:29:21,950
all these method calls every time you're

735
00:29:21,950 --> 00:29:24,890
doing a bunch of things and so you can

736
00:29:24,890 --> 00:29:26,930
create these higher-level function calls

737
00:29:26,930 --> 00:29:28,940
that actually wrap all the unsafe code

738
00:29:28,940 --> 00:29:31,010
and allow you to just call proper russ

739
00:29:31,010 --> 00:29:34,310
code so this function basically takes a

740
00:29:34,310 --> 00:29:36,710
Ember B string from the MOV VM and

741
00:29:36,710 --> 00:29:38,600
converts it into rust string so we can

742
00:29:38,600 --> 00:29:40,520
use it with other russ data structures

743
00:29:40,520 --> 00:29:42,320
methods and things like that

744
00:29:42,320 --> 00:29:44,330
and I didn't want to basically do all

745
00:29:44,330 --> 00:29:47,720
this slicing and kind of raw C pointer

746
00:29:47,720 --> 00:29:49,610
manipulation every time I want to

747
00:29:49,610 --> 00:29:51,920
manipulate a string because that happens

748
00:29:51,920 --> 00:29:54,980
basically all the time and so when the

749
00:29:54,980 --> 00:29:56,720
nice thing is is since all this stuff

750
00:29:56,720 --> 00:29:58,490
all the unsafe code is here in this

751
00:29:58,490 --> 00:30:00,950
method here inside of Russ I know I

752
00:30:00,950 --> 00:30:02,570
don't actually have to when I'm using

753
00:30:02,570 --> 00:30:05,480
this library wrap this function in an

754
00:30:05,480 --> 00:30:06,950
unsafe thing and because that's handled

755
00:30:06,950 --> 00:30:10,460
inside of this method so over time I'll

756
00:30:10,460 --> 00:30:12,560
be pulling more things into the high/low

757
00:30:12,560 --> 00:30:13,970
of abstraction as I figure out the API

758
00:30:13,970 --> 00:30:16,520
that I want there and slowly removing

759
00:30:16,520 --> 00:30:18,950
like the manual calls to the MVC API

760
00:30:18,950 --> 00:30:22,400
directly and then finally we need a

761
00:30:22,400 --> 00:30:25,700
never be gem for Denver be gem to link

762
00:30:25,700 --> 00:30:29,930
against and this allows us to basically

763
00:30:29,930 --> 00:30:33,980
use the right version of Emmer M Ruby

764
00:30:33,980 --> 00:30:35,360
that using locally so it's using the

765
00:30:35,360 --> 00:30:37,010
right version of the API and the right

766
00:30:37,010 --> 00:30:39,260
headers and things and not just some

767
00:30:39,260 --> 00:30:41,750
random so if you ever done in the Ruby

768
00:30:41,750 --> 00:30:43,550
debugger stuff like it actually bundles

769
00:30:43,550 --> 00:30:46,130
the entire like header stuff into the

770
00:30:46,130 --> 00:30:48,740
gem and every time a new version of Ruby

771
00:30:48,740 --> 00:30:50,060
comes out it like breaks of the bugger

772
00:30:50,060 --> 00:30:52,490
because like some api's and stuff change

773
00:30:52,490 --> 00:30:54,080
the nice thing about this is that I'm

774
00:30:54,080 --> 00:30:56,929
actually linking against the version of

775
00:30:56,929 --> 00:30:58,790
M Ruby that you have locally so I don't

776
00:30:58,790 --> 00:31:00,020
actually have to vendor any of that

777
00:31:00,020 --> 00:31:05,230
stuff into my MOV gem and so inside of

778
00:31:05,230 --> 00:31:08,780
and if you've ever dug into the M Ruby

779
00:31:08,780 --> 00:31:11,059
or the Ruby source code you've noticed

780
00:31:11,059 --> 00:31:13,929
that basically there's a ton of like C

781
00:31:13,929 --> 00:31:16,970
pound define like macros all over the

782
00:31:16,970 --> 00:31:19,130
place like math uses this like

783
00:31:19,130 --> 00:31:19,730
everywhere

784
00:31:19,730 --> 00:31:22,309
so M Ruby's not unique in this like it

785
00:31:22,309 --> 00:31:24,190
basically does the same thing but

786
00:31:24,190 --> 00:31:26,420
unfortunately all these pound defined

787
00:31:26,420 --> 00:31:27,950
pre-processors aren't actually available

788
00:31:27,950 --> 00:31:30,770
across FFI so it's not publicly

789
00:31:30,770 --> 00:31:32,990
available to me inside of rust or any

790
00:31:32,990 --> 00:31:35,740
other language that wants to use that by

791
00:31:35,740 --> 00:31:39,890
interface so we actually have to wrap

792
00:31:39,890 --> 00:31:44,240
all the macros that we want from C in

793
00:31:44,240 --> 00:31:46,490
actual C functions so they're publicly

794
00:31:46,490 --> 00:31:48,830
available to rust action map too

795
00:31:48,830 --> 00:31:52,790
so this M for Ruby runtime actually just

796
00:31:52,790 --> 00:31:54,620
takes all that stuff and wraps them in

797
00:31:54,620 --> 00:31:57,860
actual C code to be used so with that I

798
00:31:57,860 --> 00:31:59,809
can actually access this thing inside of

799
00:31:59,809 --> 00:32:03,290
the Lib MOV sis crates because now

800
00:32:03,290 --> 00:32:07,580
they're publicly available C methods and

801
00:32:07,580 --> 00:32:11,420
so I did that really simple hello world

802
00:32:11,420 --> 00:32:13,250
example but that's like really trivial

803
00:32:13,250 --> 00:32:15,770
to actually write and it doesn't do very

804
00:32:15,770 --> 00:32:18,980
much so one things I want to do was take

805
00:32:18,980 --> 00:32:22,360
a library that wasn't super complicated

806
00:32:22,360 --> 00:32:25,130
but was actually a real world practical

807
00:32:25,130 --> 00:32:28,190
thing to be done so if you're familiar

808
00:32:28,190 --> 00:32:29,840
with all the doc out project that came

809
00:32:29,840 --> 00:32:33,200
out from the Python community and it

810
00:32:33,200 --> 00:32:34,610
looks something like this like cargo

811
00:32:34,610 --> 00:32:38,120
uses it for its option parsing so it's

812
00:32:38,120 --> 00:32:39,980
not for parsing library and one of the

813
00:32:39,980 --> 00:32:41,210
neat things it does is it actually

814
00:32:41,210 --> 00:32:44,150
allows you to define as a string the

815
00:32:44,150 --> 00:32:46,220
usage that you're gonna do and then you

816
00:32:46,220 --> 00:32:49,730
pass in your array of arguments and then

817
00:32:49,730 --> 00:32:51,170
it'll actually then return an options

818
00:32:51,170 --> 00:32:53,960
hash or map up some sort for you based

819
00:32:53,960 --> 00:32:55,670
off of this huge thing that you can

820
00:32:55,670 --> 00:32:58,000
print as help and then the argument list

821
00:32:58,000 --> 00:32:59,960
so it's really neat so you don't have to

822
00:32:59,960 --> 00:33:03,290
kind of do all that stuff by hand and

823
00:33:03,290 --> 00:33:03,890
there's a bunch of different

824
00:33:03,890 --> 00:33:06,119
implementations of it across all

825
00:33:06,119 --> 00:33:08,579
languages the rust one is one of the

826
00:33:08,579 --> 00:33:10,979
most up-to-date ones and it's well

827
00:33:10,979 --> 00:33:13,349
maintained because cargo depends on it

828
00:33:13,349 --> 00:33:16,889
but when Christoph and I actually were

829
00:33:16,889 --> 00:33:18,479
starting to implement it and looking at

830
00:33:18,479 --> 00:33:19,049
it

831
00:33:19,049 --> 00:33:21,239
there was a see one that wasn't well

832
00:33:21,239 --> 00:33:22,679
maintained or up-to-date and there was a

833
00:33:22,679 --> 00:33:23,759
ruby one that we were thinking about

834
00:33:23,759 --> 00:33:25,529
porting from but that I think hasn't

835
00:33:25,529 --> 00:33:27,179
there hasn't been commit to in like

836
00:33:27,179 --> 00:33:27,809
three years

837
00:33:27,809 --> 00:33:29,569
so there's a bunch of changes and it

838
00:33:29,569 --> 00:33:32,009
wasn't actually didn't actually have a

839
00:33:32,009 --> 00:33:33,779
lot of the new features that were part

840
00:33:33,779 --> 00:33:35,789
of duck off so we actually chose to use

841
00:33:35,789 --> 00:33:38,939
C++ as the initial implementation so we

842
00:33:38,939 --> 00:33:42,499
wrote a C++ wrapper in amber B gems

843
00:33:42,499 --> 00:33:46,109
around it and Chris stuff at the time I

844
00:33:46,109 --> 00:33:48,419
think was doing still C++ as part of

845
00:33:48,419 --> 00:33:50,279
full-time and you can see like we

846
00:33:50,279 --> 00:33:52,139
actually just made a simple mistake we

847
00:33:52,139 --> 00:33:55,289
missed this break and it's like for

848
00:33:55,289 --> 00:33:57,359
people who do this stuff it's like still

849
00:33:57,359 --> 00:34:00,179
possible to make these mistakes in code

850
00:34:00,179 --> 00:34:02,219
and all we had to do was write a wrapper

851
00:34:02,219 --> 00:34:05,249
around the existing C++ library to make

852
00:34:05,249 --> 00:34:07,499
it available inside of Ruby and we were

853
00:34:07,499 --> 00:34:10,409
still able to in the like less than 100

854
00:34:10,409 --> 00:34:13,168
lines like a simple like forgot to put

855
00:34:13,168 --> 00:34:15,498
this break in and it caused seg faults

856
00:34:15,498 --> 00:34:18,389
so the Rivlin invitation of every dock

857
00:34:18,389 --> 00:34:23,129
op still today is in c++ and so knowing

858
00:34:23,129 --> 00:34:25,018
all that I want to take this thing and

859
00:34:25,018 --> 00:34:28,049
try to use the dock op rough library and

860
00:34:28,049 --> 00:34:29,909
see if I could build this and we read a

861
00:34:29,909 --> 00:34:32,099
cop thing based off the C++

862
00:34:32,099 --> 00:34:34,768
implementation so in M Ruby this is how

863
00:34:34,768 --> 00:34:36,599
you use it you have a usage thing you

864
00:34:36,599 --> 00:34:38,579
just have it here doc and then you just

865
00:34:38,579 --> 00:34:40,829
call it right like so for the C++

866
00:34:40,829 --> 00:34:42,779
implementation just call da cops as

867
00:34:42,779 --> 00:34:45,059
module it takes a class level it has

868
00:34:45,059 --> 00:34:46,859
class old method called parts passing

869
00:34:46,859 --> 00:34:48,119
the usage and then you pass in kind of

870
00:34:48,119 --> 00:34:49,589
all the art v arguments that you're

871
00:34:49,589 --> 00:34:52,018
gonna have on the command line and then

872
00:34:52,018 --> 00:34:54,239
once you do that you have access to kind

873
00:34:54,239 --> 00:34:56,489
of this options thing that you can index

874
00:34:56,489 --> 00:35:00,390
into yet see if it actually was used or

875
00:35:00,390 --> 00:35:03,210
not so if detect Ruby command was run

876
00:35:03,210 --> 00:35:04,859
this will return true if not will return

877
00:35:04,859 --> 00:35:06,660
false and will be once for all the other

878
00:35:06,660 --> 00:35:10,880
commands that I have so this is the

879
00:35:10,880 --> 00:35:14,339
parts implementation inside of with rust

880
00:35:14,339 --> 00:35:17,000
for that document

881
00:35:17,000 --> 00:35:19,579
and the way this works you don't have to

882
00:35:19,579 --> 00:35:22,700
necessary dit line my line is that you

883
00:35:22,700 --> 00:35:24,650
kind of have to be able to parse out so

884
00:35:24,650 --> 00:35:26,180
if you were to do this in C you would

885
00:35:26,180 --> 00:35:28,190
have to actually parse out the arguments

886
00:35:28,190 --> 00:35:29,720
so you have to get both the string in

887
00:35:29,720 --> 00:35:31,400
the array and then kind of assign them

888
00:35:31,400 --> 00:35:35,900
to these locations in memory and once

889
00:35:35,900 --> 00:35:39,680
you have that you can you have to

890
00:35:39,680 --> 00:35:41,900
basically convert this stuff into Russ

891
00:35:41,900 --> 00:35:43,790
objects to be able to pass into the doc

892
00:35:43,790 --> 00:35:46,760
op Russell library so the first thing

893
00:35:46,760 --> 00:35:47,630
we're doing we're calling that

894
00:35:47,630 --> 00:35:49,910
high-level Amber B string - Russ thing

895
00:35:49,910 --> 00:35:51,500
to convert the amber B string to rust

896
00:35:51,500 --> 00:35:54,410
and then we need to create a coolant

897
00:35:54,410 --> 00:35:57,890
array slash vector list object that will

898
00:35:57,890 --> 00:36:00,710
get passed to doc opt based off of the a

899
00:36:00,710 --> 00:36:02,710
memory array so we're calling a bunch of

900
00:36:02,710 --> 00:36:04,670
c-level methods to actually extract

901
00:36:04,670 --> 00:36:08,690
these values with that we can actually

902
00:36:08,690 --> 00:36:11,869
then call so this actually calls the doc

903
00:36:11,869 --> 00:36:17,240
ops library and with that we take the

904
00:36:17,240 --> 00:36:18,829
usage and we take that thing we just

905
00:36:18,829 --> 00:36:21,380
created and we get kind of the data

906
00:36:21,380 --> 00:36:22,790
structure that Russ gives back to

907
00:36:22,790 --> 00:36:26,319
actually see whether options are being

908
00:36:26,319 --> 00:36:28,760
correctly if what options have actually

909
00:36:28,760 --> 00:36:32,599
been passed properly and with that we

910
00:36:32,599 --> 00:36:35,540
can use the data object allocation so

911
00:36:35,540 --> 00:36:39,230
this is allows us to basically store the

912
00:36:39,230 --> 00:36:42,650
rust since it's just a allocation inside

913
00:36:42,650 --> 00:36:44,869
of memory it sorts it inside of Ruby and

914
00:36:44,869 --> 00:36:48,050
so it tells rust what does it tell us it

915
00:36:48,050 --> 00:36:50,510
tells M Ruby that hey we have this data

916
00:36:50,510 --> 00:36:53,390
structure you don't know how to access

917
00:36:53,390 --> 00:36:54,770
this thing but here keep this in memory

918
00:36:54,770 --> 00:36:57,680
and so the reason to do something like

919
00:36:57,680 --> 00:37:03,740
this is because you don't ask Anita rust

920
00:37:03,740 --> 00:37:06,020
and back from rust to M Ruby all the

921
00:37:06,020 --> 00:37:08,030
time because there's a performance cost

922
00:37:08,030 --> 00:37:10,640
from doing that typecasting construction

923
00:37:10,640 --> 00:37:15,230
basically so in MRI there's there's

924
00:37:15,230 --> 00:37:16,819
plenty of C extensions that do similar

925
00:37:16,819 --> 00:37:18,859
things probably the most common one that

926
00:37:18,859 --> 00:37:20,660
comes to my mind is No Fee Gary so when

927
00:37:20,660 --> 00:37:22,130
you're parsing XML documents it doesn't

928
00:37:22,130 --> 00:37:24,050
actually convert that whole thing back

929
00:37:24,050 --> 00:37:27,380
into a ruby data structure it actually

930
00:37:27,380 --> 00:37:29,700
just provides C

931
00:37:29,700 --> 00:37:32,220
functions that are accessible I repeat

932
00:37:32,220 --> 00:37:35,070
actually access that data structure from

933
00:37:35,070 --> 00:37:36,960
your Ruby code so that's what I'm doing

934
00:37:36,960 --> 00:37:37,290
here

935
00:37:37,290 --> 00:37:40,350
so I'm actually keeping this RV map a

936
00:37:40,350 --> 00:37:42,720
rusty in structure around and then I can

937
00:37:42,720 --> 00:37:45,180
access it as if it was a normal Ruby

938
00:37:45,180 --> 00:37:48,900
data structure so if we look back at the

939
00:37:48,900 --> 00:37:51,210
recode that was the implementation of

940
00:37:51,210 --> 00:37:53,400
parse and so this actually just looks

941
00:37:53,400 --> 00:37:55,650
like a hash but it actually isn't a ruby

942
00:37:55,650 --> 00:37:58,410
hash hall so that's all we had to do to

943
00:37:58,410 --> 00:38:01,320
actually get that to work and then as a

944
00:38:01,320 --> 00:38:03,180
user like you don't actually have to

945
00:38:03,180 --> 00:38:04,680
know that you were using rust at all

946
00:38:04,680 --> 00:38:06,540
right like this is the code you're using

947
00:38:06,540 --> 00:38:08,220
it just looks like any other standard

948
00:38:08,220 --> 00:38:09,780
Ruby library could've been written Ruby

949
00:38:09,780 --> 00:38:12,390
for all you know and then to pull then

950
00:38:12,390 --> 00:38:13,500
you just add it in like any other

951
00:38:13,500 --> 00:38:14,880
dependency and it will build into

952
00:38:14,880 --> 00:38:20,160
compile so it's kind of just like the

953
00:38:20,160 --> 00:38:22,320
whirlwind tour of like how to get all

954
00:38:22,320 --> 00:38:24,330
this stuff working and running and

955
00:38:24,330 --> 00:38:26,940
what's great is all this that stuff

956
00:38:26,940 --> 00:38:29,340
compiles and works on Linux OS X and

957
00:38:29,340 --> 00:38:31,830
Windows like out of the box like the CLI

958
00:38:31,830 --> 00:38:34,170
it's native extension I didn't have to

959
00:38:34,170 --> 00:38:36,930
write any Windows specific code to make

960
00:38:36,930 --> 00:38:38,940
it work like it just compiled and worked

961
00:38:38,940 --> 00:38:42,450
and so some of the stuff that I was

962
00:38:42,450 --> 00:38:43,110
talking about before

963
00:38:43,110 --> 00:38:45,060
so things that I still need to work on

964
00:38:45,060 --> 00:38:50,130
is the Russy ruby wrapper I need to add

965
00:38:50,130 --> 00:38:53,520
more of the MOV C API so currently I've

966
00:38:53,520 --> 00:38:55,140
only done stuff that I needed to

967
00:38:55,140 --> 00:38:56,670
actually get doc OP to work because that

968
00:38:56,670 --> 00:38:57,870
was the only way I could actually test

969
00:38:57,870 --> 00:39:01,230
whether the API is work properly and

970
00:39:01,230 --> 00:39:04,680
then I need to also go through and

971
00:39:04,680 --> 00:39:06,600
abstract more and more of the

972
00:39:06,600 --> 00:39:07,310
higher-level

973
00:39:07,310 --> 00:39:09,600
the low-level things into a higher level

974
00:39:09,600 --> 00:39:11,280
abstraction so you actually should be

975
00:39:11,280 --> 00:39:13,200
able to write an entire library without

976
00:39:13,200 --> 00:39:15,810
calling any unsafe blocks inside of your

977
00:39:15,810 --> 00:39:20,160
actual library beyond that I think that

978
00:39:20,160 --> 00:39:21,510
where it starts to get more and more

979
00:39:21,510 --> 00:39:23,910
exciting is the fact that with all this

980
00:39:23,910 --> 00:39:26,460
stuff done we can now actually start to

981
00:39:26,460 --> 00:39:29,480
write MRV gems around low-level rust

982
00:39:29,480 --> 00:39:32,550
libraries so there's a project called

983
00:39:32,550 --> 00:39:34,920
Tokyo in rust and it's actually a

984
00:39:34,920 --> 00:39:37,350
network low-level networking library

985
00:39:37,350 --> 00:39:39,660
written in rust and one of the nice

986
00:39:39,660 --> 00:39:41,850
things is like unlike MOV socket if we

987
00:39:41,850 --> 00:39:42,270
were to write

988
00:39:42,270 --> 00:39:44,370
wrapper around Tokyo it would actually

989
00:39:44,370 --> 00:39:45,930
just work on Windows we wouldn't have to

990
00:39:45,930 --> 00:39:48,300
light in that stuff we can actually kind

991
00:39:48,300 --> 00:39:49,890
of delegate all that work into the rust

992
00:39:49,890 --> 00:39:50,970
ecosystem and they have a bunch of

993
00:39:50,970 --> 00:39:53,370
low-level libraries out there that we

994
00:39:53,370 --> 00:39:55,980
can do that with and so this is where

995
00:39:55,980 --> 00:39:58,470
all this gets promising so same thing

996
00:39:58,470 --> 00:40:01,050
with file i/o right like I don't want to

997
00:40:01,050 --> 00:40:04,260
use ember bi oh if I can use another

998
00:40:04,260 --> 00:40:05,760
thing that actually just works super

999
00:40:05,760 --> 00:40:06,870
well in Windows and doesn't have any

1000
00:40:06,870 --> 00:40:09,990
caveats and so that's kind of the future

1001
00:40:09,990 --> 00:40:12,000
direction of where I want to take all

1002
00:40:12,000 --> 00:40:13,770
this stuff is like we can build an

1003
00:40:13,770 --> 00:40:16,620
entire ecosystem around using this

1004
00:40:16,620 --> 00:40:20,160
expansive existing low-level systems for

1005
00:40:20,160 --> 00:40:21,510
a minute you go system of experts you've

1006
00:40:21,510 --> 00:40:23,550
been doing this stuff because they have

1007
00:40:23,550 --> 00:40:25,290
to make it work for Firefox and other

1008
00:40:25,290 --> 00:40:30,510
things and if I don't know if any of you

1009
00:40:30,510 --> 00:40:33,900
have heard of the helix project but it's

1010
00:40:33,900 --> 00:40:35,100
a thing that you who didn't got for

1011
00:40:35,100 --> 00:40:37,080
you've been working on that basically is

1012
00:40:37,080 --> 00:40:39,510
a lot of the similar stuff but all for

1013
00:40:39,510 --> 00:40:41,820
MRIs so being able to write native

1014
00:40:41,820 --> 00:40:44,910
extensions for your MRI code inside of

1015
00:40:44,910 --> 00:40:48,990
rust is what helix is about and so some

1016
00:40:48,990 --> 00:40:50,940
great use cases would be you could take

1017
00:40:50,940 --> 00:40:52,620
parts of rails or slow parts of your

1018
00:40:52,620 --> 00:40:54,240
code base after you've profiled it we

1019
00:40:54,240 --> 00:40:55,680
write that in russ which is this

1020
00:40:55,680 --> 00:40:57,840
scissors forming language that is higher

1021
00:40:57,840 --> 00:40:59,940
level to work with and you're not seg

1022
00:40:59,940 --> 00:41:03,960
faulting and be able to do that add that

1023
00:41:03,960 --> 00:41:05,880
into your gem file and make that work

1024
00:41:05,880 --> 00:41:08,100
and so the reason that's important is

1025
00:41:08,100 --> 00:41:10,680
mostly that we're hoping to integrate

1026
00:41:10,680 --> 00:41:12,840
all my M for Ruby stuff into helix

1027
00:41:12,840 --> 00:41:14,250
eventually and have a single code base

1028
00:41:14,250 --> 00:41:16,560
and have this kind of like common Ruby

1029
00:41:16,560 --> 00:41:18,900
universal Ruby thing where no matter for

1030
00:41:18,900 --> 00:41:20,880
using Ruby or MRI you're able to kind of

1031
00:41:20,880 --> 00:41:22,470
do all this rust up with the same

1032
00:41:22,470 --> 00:41:26,850
abstractions with it so kind of in

1033
00:41:26,850 --> 00:41:29,760
conclusion I think we all know that Ruby

1034
00:41:29,760 --> 00:41:31,110
doesn't have a great history with

1035
00:41:31,110 --> 00:41:32,820
Windows we're pushing and tons of

1036
00:41:32,820 --> 00:41:34,530
Windows users away and there's a lot of

1037
00:41:34,530 --> 00:41:35,850
them out there and it's really just

1038
00:41:35,850 --> 00:41:39,090
unfortunate I think for us because it

1039
00:41:39,090 --> 00:41:40,610
makes it hard to grow the ecosystem

1040
00:41:40,610 --> 00:41:42,750
potential people who should be using

1041
00:41:42,750 --> 00:41:44,820
Ruby because it's a great language with

1042
00:41:44,820 --> 00:41:47,160
great people and a great set of

1043
00:41:47,160 --> 00:41:48,360
libraries and things to make you

1044
00:41:48,360 --> 00:41:51,720
productive and everybody has an

1045
00:41:51,720 --> 00:41:54,630
opportunity to have a fresh start it is

1046
00:41:54,630 --> 00:41:56,010
a new ecosystem it's only

1047
00:41:56,010 --> 00:41:57,630
five years old there aren't a ton of

1048
00:41:57,630 --> 00:42:00,510
people working on it and that means we

1049
00:42:00,510 --> 00:42:01,800
don't have to follow in the same

1050
00:42:01,800 --> 00:42:05,790
footsteps of MRI like at this point like

1051
00:42:05,790 --> 00:42:08,040
to change the entire rubygems ecosystem

1052
00:42:08,040 --> 00:42:09,570
would be really hard right like there's

1053
00:42:09,570 --> 00:42:14,040
just so much stuff out there today and I

1054
00:42:14,040 --> 00:42:17,460
think finally like with a lot of stuff

1055
00:42:17,460 --> 00:42:21,050
that Russ is cared about we can create a

1056
00:42:21,050 --> 00:42:24,510
ecosystem with this to make a windows

1057
00:42:24,510 --> 00:42:26,550
friendly ecosystem that is inclusive of

1058
00:42:26,550 --> 00:42:28,050
everyone and not just people who are

1059
00:42:28,050 --> 00:42:32,040
primarily users of Unix so if you're

1060
00:42:32,040 --> 00:42:33,840
interested I'd be happy to talk about

1061
00:42:33,840 --> 00:42:37,110
this more online or in person but I'm

1062
00:42:37,110 --> 00:42:39,810
very excited to hopefully make the Ruby

1063
00:42:39,810 --> 00:42:41,520
goes to some better for everyone

1064
00:42:41,520 --> 00:42:43,250
and not just people who are on UNIX

1065
00:42:43,250 --> 00:42:54,320
thank you questions I have some mints

1066
00:42:54,320 --> 00:43:04,350
yes it's a written from the ground up so

1067
00:43:04,350 --> 00:43:08,700
it doesn't one of the benefits of doing

1068
00:43:08,700 --> 00:43:12,390
that besides so you lose the tons of

1069
00:43:12,390 --> 00:43:15,810
backwards compatibility and but one of

1070
00:43:15,810 --> 00:43:18,720
the benefits was that the MOV C API is

1071
00:43:18,720 --> 00:43:21,630
significantly better cleaner and simpler

1072
00:43:21,630 --> 00:43:23,730
than the Ruby C API so you don't have

1073
00:43:23,730 --> 00:43:26,190
all the sacred cows that you do in Ruby

1074
00:43:26,190 --> 00:43:29,040
today and but and that also means my

1075
00:43:29,040 --> 00:43:30,840
work for the M for review stuff it's

1076
00:43:30,840 --> 00:43:32,550
nothing easier than you who didn't God

1077
00:43:32,550 --> 00:43:35,160
for his work for helix because the Ruby

1078
00:43:35,160 --> 00:43:39,440
C API is was built like 15 years ago and

1079
00:43:39,440 --> 00:43:42,870
M Ruby was given the chance like Matz

1080
00:43:42,870 --> 00:43:45,240
was like well if I could do it again how

1081
00:43:45,240 --> 00:43:47,280
would I do it and so there's some nice

1082
00:43:47,280 --> 00:43:49,260
things that you see in the C code if

1083
00:43:49,260 --> 00:43:50,850
you've looked at both of them where you

1084
00:43:50,850 --> 00:43:53,610
like yeah that kind of sucks that you

1085
00:43:53,610 --> 00:43:56,790
can't change that so yeah to answer your

1086
00:43:56,790 --> 00:43:59,060
question

1087
00:44:01,100 --> 00:44:11,660
yes so your question was could ever

1088
00:44:11,660 --> 00:44:15,860
become the the standard base for Ruby

1089
00:44:15,860 --> 00:44:19,610
instead of a subset of it I mean I feel

1090
00:44:19,610 --> 00:44:22,250
like if you were to do that you'd be

1091
00:44:22,250 --> 00:44:24,140
basically replacing the entire ecosystem

1092
00:44:24,140 --> 00:44:26,450
there and that doesn't mean it's

1093
00:44:26,450 --> 00:44:29,030
impossible but it like there's a lot of

1094
00:44:29,030 --> 00:44:30,850
stuff that has happened in Ruby and

1095
00:44:30,850 --> 00:44:33,260
you'd be throwing stuff like rails and

1096
00:44:33,260 --> 00:44:35,060
rack and all that stuff out the door but

1097
00:44:35,060 --> 00:44:36,890
I mean in theory like if you had condo

1098
00:44:36,890 --> 00:44:41,180
ruby stuff there is a potential I guess

1099
00:44:41,180 --> 00:44:44,360
like vision where you could write code

1100
00:44:44,360 --> 00:44:47,870
that works on both MRI and M Ruby and in

1101
00:44:47,870 --> 00:44:49,400
that state I think that would be simply

1102
00:44:49,400 --> 00:44:52,490
easier but I dad's nowhere near close to

1103
00:44:52,490 --> 00:45:04,490
where it is today yes there is no I

1104
00:45:04,490 --> 00:45:09,490
think so to repeat the question is there

1105
00:45:09,490 --> 00:45:13,250
incentive to put more core features of M

1106
00:45:13,250 --> 00:45:16,570
Reubens into rust or just libraries and

1107
00:45:16,570 --> 00:45:19,190
as far as I know today like there's no

1108
00:45:19,190 --> 00:45:21,260
incentive on the core team for well

1109
00:45:21,260 --> 00:45:22,700
there isn't really a core team and ever

1110
00:45:22,700 --> 00:45:24,230
it's really just Matz and people who are

1111
00:45:24,230 --> 00:45:26,300
helping him but there's no like

1112
00:45:26,300 --> 00:45:28,820
incentive because the whole team is like

1113
00:45:28,820 --> 00:45:30,800
everything's built around C like it is

1114
00:45:30,800 --> 00:45:33,680
for MRI like I think all the core level

1115
00:45:33,680 --> 00:45:36,920
stuff is going to maintain its C nature

1116
00:45:36,920 --> 00:45:38,570
and there aren't really plans to change

1117
00:45:38,570 --> 00:45:42,260
that I'm hoping with some of the stuff

1118
00:45:42,260 --> 00:45:45,050
before able to deliver on half the

1119
00:45:45,050 --> 00:45:47,330
things that I've talked about in that

1120
00:45:47,330 --> 00:45:50,090
last part of my talk that there will be

1121
00:45:50,090 --> 00:45:52,940
an interest in the ecosystem to embrace

1122
00:45:52,940 --> 00:45:56,750
stuff like rust and make it easier but

1123
00:45:56,750 --> 00:45:59,030
yeah there are really any incentives

1124
00:45:59,030 --> 00:46:00,710
internally to kind of change where

1125
00:46:00,710 --> 00:46:03,280
things are today

1126
00:46:05,619 --> 00:46:10,880
yeah yeah dr. emre with Candida Kennedy

1127
00:46:10,880 --> 00:46:15,170
couldn't be compared to the MRI like

1128
00:46:15,170 --> 00:46:19,849
speed wise are there so the question was

1129
00:46:19,849 --> 00:46:22,339
can the emirate vvm be compared to the

1130
00:46:22,339 --> 00:46:26,510
MRI vm speed wise and other differences

1131
00:46:26,510 --> 00:46:30,859
that okay so there are definitely a lot

1132
00:46:30,859 --> 00:46:32,180
less you were working on mov and since

1133
00:46:32,180 --> 00:46:33,849
it's written from the ground up

1134
00:46:33,849 --> 00:46:39,520
it's very different I think by

1135
00:46:39,520 --> 00:46:41,839
intentionally since it's embedded it has

1136
00:46:41,839 --> 00:46:44,720
different constraints innate touched on

1137
00:46:44,720 --> 00:46:47,180
this I think in the QA about just like

1138
00:46:47,180 --> 00:46:49,280
how Ruby is kind of this very general

1139
00:46:49,280 --> 00:46:51,950
purpose thing and you have very opposite

1140
00:46:51,950 --> 00:46:54,319
kind of use cases right let you have the

1141
00:46:54,319 --> 00:46:56,539
rails app which I think like apes and

1142
00:46:56,539 --> 00:46:59,329
the people that probably do Ruby are

1143
00:46:59,329 --> 00:47:01,280
using it for right like whether it's

1144
00:47:01,280 --> 00:47:02,780
rails or some other type of long running

1145
00:47:02,780 --> 00:47:04,609
daemon process that's very java like

1146
00:47:04,609 --> 00:47:07,880
right and those constraints and concerns

1147
00:47:07,880 --> 00:47:09,500
have very different defaults and you

1148
00:47:09,500 --> 00:47:12,920
want if you are a ima scripts like at

1149
00:47:12,920 --> 00:47:15,289
Heroku we use as part of the build pack

1150
00:47:15,289 --> 00:47:18,740
like Ruby and it's a very short-lived

1151
00:47:18,740 --> 00:47:21,170
process right like it runs maybe fifteen

1152
00:47:21,170 --> 00:47:22,819
minutes max and then we kill it if it

1153
00:47:22,819 --> 00:47:24,470
runs longer than that and so it

1154
00:47:24,470 --> 00:47:25,640
definitely doesn't run nearly as long

1155
00:47:25,640 --> 00:47:27,859
and it's not allocating as much memory

1156
00:47:27,859 --> 00:47:29,150
doesn't have kind of the same

1157
00:47:29,150 --> 00:47:31,789
constraints where things like in rails

1158
00:47:31,789 --> 00:47:33,890
fast boot up time is nice but it's not a

1159
00:47:33,890 --> 00:47:36,440
hard requirement whereas like fast boot

1160
00:47:36,440 --> 00:47:38,660
up time for scripting thing is actually

1161
00:47:38,660 --> 00:47:42,289
super important so I think M Ruby is not

1162
00:47:42,289 --> 00:47:45,980
design in nature to be run all like it

1163
00:47:45,980 --> 00:47:49,190
is for rails and so it makes a lot of

1164
00:47:49,190 --> 00:47:52,369
trade-offs with even the data structures

1165
00:47:52,369 --> 00:47:54,410
and stuff like Dave's structures like

1166
00:47:54,410 --> 00:47:55,940
when you allocate an array and I'm Ruby

1167
00:47:55,940 --> 00:47:57,589
it allocates sniffing less space and

1168
00:47:57,589 --> 00:47:59,630
then takes up less space because it has

1169
00:47:59,630 --> 00:48:01,460
to be able to be running Arduino right

1170
00:48:01,460 --> 00:48:02,720
like it has those kind of constraints

1171
00:48:02,720 --> 00:48:04,670
the benefits of that is if you're using

1172
00:48:04,670 --> 00:48:07,910
ember B for things like tooling or

1173
00:48:07,910 --> 00:48:09,680
scripting and things like that you get

1174
00:48:09,680 --> 00:48:12,440
massive speed ups because it takes an

1175
00:48:12,440 --> 00:48:14,510
order of magnitude less time to boot up

1176
00:48:14,510 --> 00:48:15,559
and n Ruby VM than

1177
00:48:15,559 --> 00:48:17,449
does an MRI VM even before he pull

1178
00:48:17,449 --> 00:48:20,719
rubygems in right and not to mention the

1179
00:48:20,719 --> 00:48:22,369
fact that since you can compile stuff

1180
00:48:22,369 --> 00:48:24,259
down you to actually don't have the

1181
00:48:24,259 --> 00:48:28,059
require load problem which you do on MRI

1182
00:48:28,059 --> 00:48:30,799
the flip side of that is the runtime

1183
00:48:30,799 --> 00:48:31,819
doesn't have nearly as many

1184
00:48:31,819 --> 00:48:34,069
optimizations in the garbage collector

1185
00:48:34,069 --> 00:48:38,959
or other things so the MRI garbage

1186
00:48:38,959 --> 00:48:41,449
collector is way more mature it's been

1187
00:48:41,449 --> 00:48:44,059
around longer time and it's it has to

1188
00:48:44,059 --> 00:48:46,640
have adapted and evolved for the rails

1189
00:48:46,640 --> 00:48:51,109
use case so there are I think things

1190
00:48:51,109 --> 00:48:52,969
where people are looking at like running

1191
00:48:52,969 --> 00:48:55,039
em Ruby as long running things but it's

1192
00:48:55,039 --> 00:48:56,930
for like IOT devices which definitely

1193
00:48:56,930 --> 00:48:58,670
have totally different performance

1194
00:48:58,670 --> 00:49:00,309
constraints than running them on like a

1195
00:49:00,309 --> 00:49:03,319
bunch of racks right like to power like

1196
00:49:03,319 --> 00:49:06,309
the next school or something right so

1197
00:49:06,309 --> 00:49:09,910
hope that answers your question

1198
00:49:12,480 --> 00:49:18,139
[Applause]

