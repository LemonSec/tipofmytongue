1
00:00:00,030 --> 00:00:02,869
it's a

2
00:00:04,610 --> 00:00:07,490
yes I'm going to be talking about well I

3
00:00:07,490 --> 00:00:10,190
think the talk originally says 16-bit

4
00:00:10,190 --> 00:00:13,550
child supporting playing an LVN but it's

5
00:00:13,550 --> 00:00:15,440
actually just more generic slightly

6
00:00:15,440 --> 00:00:20,750
slightly more generic just generally non

7
00:00:20,750 --> 00:00:24,310
8-bit byte support in claim elf iam now

8
00:00:24,310 --> 00:00:28,730
so first of all is just going to a bit

9
00:00:28,730 --> 00:00:32,210
of background so we have this thing a

10
00:00:32,210 --> 00:00:35,180
sequel char bit which tells you how many

11
00:00:35,180 --> 00:00:38,360
bits essentially your char has and the

12
00:00:38,360 --> 00:00:43,430
standard basically says that a byte

13
00:00:43,430 --> 00:00:47,680
contains char bit number of bits

14
00:00:49,540 --> 00:00:52,280
generally this is used to mean the

15
00:00:52,280 --> 00:00:53,930
number of bits in whatever your native

16
00:00:53,930 --> 00:00:56,809
machine type is what the and therefore

17
00:00:56,809 --> 00:00:59,150
it means the sort of size of the minimal

18
00:00:59,150 --> 00:01:02,299
addressable unit and it doesn't have to

19
00:01:02,299 --> 00:01:03,949
be though I mean you can target your

20
00:01:03,949 --> 00:01:06,860
your C can be for some sort of slightly

21
00:01:06,860 --> 00:01:11,480
more abstract machine and slightly more

22
00:01:11,480 --> 00:01:13,550
abstract machine where you don't have

23
00:01:13,550 --> 00:01:17,330
where it doesn't map directly down to it

24
00:01:17,330 --> 00:01:18,790
is mapped directly down to a machine

25
00:01:18,790 --> 00:01:23,360
sizes also according to the c99 standard

26
00:01:23,360 --> 00:01:25,270
I think the older standards as well and

27
00:01:25,270 --> 00:01:28,370
this is at least eight I think possibly

28
00:01:28,370 --> 00:01:31,130
the outset of seve beginning you could

29
00:01:31,130 --> 00:01:32,750
get away with seven I believe there's

30
00:01:32,750 --> 00:01:33,950
some really weird architectures with

31
00:01:33,950 --> 00:01:38,150
less but for the most part it's great

32
00:01:38,150 --> 00:01:41,570
negative 8 and positive says that it

33
00:01:41,570 --> 00:01:44,750
must be eight exactly and the general

34
00:01:44,750 --> 00:01:46,340
assumption among lots of people who

35
00:01:46,340 --> 00:01:49,070
aren't compiler developers or working

36
00:01:49,070 --> 00:01:52,130
deep in systems there's the assumption

37
00:01:52,130 --> 00:01:54,979
that bytes are eight bits and it kind of

38
00:01:54,979 --> 00:01:56,780
means that now and generally everyone

39
00:01:56,780 --> 00:01:59,030
assumes then and and therefore it's also

40
00:01:59,030 --> 00:02:00,799
assuming that you are bits equals eight

41
00:02:00,799 --> 00:02:03,350
and lots of people write code assuming

42
00:02:03,350 --> 00:02:09,979
as such so we have architectures which

43
00:02:09,979 --> 00:02:13,819
don't have this where we have a char and

44
00:02:13,819 --> 00:02:17,990
a byte which isn't the normal lovely

45
00:02:17,990 --> 00:02:21,860
8-bit byte so and it matters to us

46
00:02:21,860 --> 00:02:24,080
so it doesn't matter in general but you

47
00:02:24,080 --> 00:02:24,950
wouldn't thought it would matter because

48
00:02:24,950 --> 00:02:26,870
like all the machines that everyone uses

49
00:02:26,870 --> 00:02:28,880
on day to day your arm chips your x86

50
00:02:28,880 --> 00:02:31,070
chips all have 8-bit bytes and that's

51
00:02:31,070 --> 00:02:33,170
all lovely and nice however there's lots

52
00:02:33,170 --> 00:02:34,730
of places where you don't have 8-bit

53
00:02:34,730 --> 00:02:36,020
bytes where you're minimal addressable

54
00:02:36,020 --> 00:02:40,460
unit isn't 8 bits and our specific case

55
00:02:40,460 --> 00:02:42,440
that we've run into is DSPs but some

56
00:02:42,440 --> 00:02:46,060
other sort of more domain-specific

57
00:02:46,060 --> 00:02:47,960
processes might also have the same

58
00:02:47,960 --> 00:02:52,300
situation or they don't have a bit bytes

59
00:02:52,300 --> 00:02:55,640
quite common for DSPs to have 16-bit

60
00:02:55,640 --> 00:02:58,280
bytes that's very common sometimes it's

61
00:02:58,280 --> 00:03:00,140
a little bit where the 24-bit bytes is

62
00:03:00,140 --> 00:03:03,440
quite common in DSPs as well sometimes

63
00:03:03,440 --> 00:03:05,420
and I've heard of architectures where

64
00:03:05,420 --> 00:03:07,100
you've got 10 bit bytes which are in use

65
00:03:07,100 --> 00:03:13,190
now and I know of historical weirder

66
00:03:13,190 --> 00:03:16,190
architectures but so the odd-numbered

67
00:03:16,190 --> 00:03:20,080
bits per byte is I think less common now

68
00:03:20,080 --> 00:03:22,910
now obviously in order to support C

69
00:03:22,910 --> 00:03:24,320
standing you have to do something with

70
00:03:24,320 --> 00:03:28,010
your chars you can't just pretend they

71
00:03:28,010 --> 00:03:29,510
don't exist and tell everyone not to use

72
00:03:29,510 --> 00:03:31,490
them you have to support it in some way

73
00:03:31,490 --> 00:03:34,880
and it's very useful if you can use a

74
00:03:34,880 --> 00:03:36,530
native machine type for chance for

75
00:03:36,530 --> 00:03:41,090
efficiency reasons and for sort of it's

76
00:03:41,090 --> 00:03:42,620
a bit more of this what's going on and

77
00:03:42,620 --> 00:03:45,680
how it maps down to to assembly and

78
00:03:45,680 --> 00:03:49,160
machine code and it's also important for

79
00:03:49,160 --> 00:03:50,330
I mean if you want to do string

80
00:03:50,330 --> 00:03:51,890
manipulation if you want to use any

81
00:03:51,890 --> 00:03:54,440
legacy code some or any generic

82
00:03:54,440 --> 00:03:56,120
benchmarks and tests is quite useful to

83
00:03:56,120 --> 00:03:58,240
have like reasonably good performing

84
00:03:58,240 --> 00:04:01,130
chess board that's a native support of

85
00:04:01,130 --> 00:04:06,650
chars so sort of workarounds which may

86
00:04:06,650 --> 00:04:08,300
work and they may be functional they may

87
00:04:08,300 --> 00:04:11,120
obey the standard and may not be useful

88
00:04:11,120 --> 00:04:13,810
if you're benchmarking or if you want to

89
00:04:13,810 --> 00:04:17,029
if your program is using chars and then

90
00:04:17,029 --> 00:04:18,560
finding that or actually you put a

91
00:04:18,560 --> 00:04:20,720
workaround in and chars are three times

92
00:04:20,720 --> 00:04:23,090
less performant than just using integers

93
00:04:23,090 --> 00:04:26,060
in that place for memory accesses then

94
00:04:26,060 --> 00:04:30,970
that's not really helpful so

95
00:04:30,979 --> 00:04:34,770
LVM and clang in theory have support for

96
00:04:34,770 --> 00:04:36,889
this LVM ir is really really nice and

97
00:04:36,889 --> 00:04:40,290
everything is basically bit based so all

98
00:04:40,290 --> 00:04:41,760
of your integer types you define in

99
00:04:41,760 --> 00:04:43,290
terms of bits all of your memory access

100
00:04:43,290 --> 00:04:45,270
you define pointers to thickness of

101
00:04:45,270 --> 00:04:49,740
sizes sizes in bits all of the generic

102
00:04:49,740 --> 00:04:53,100
stuff generally just deals with bits and

103
00:04:53,100 --> 00:04:56,430
doesn't deal with sort of bytes in any

104
00:04:56,430 --> 00:05:00,180
capacity and therefore they don't really

105
00:05:00,180 --> 00:05:01,860
bake in many assumptions about the size

106
00:05:01,860 --> 00:05:04,830
of bytes the data layout string which is

107
00:05:04,830 --> 00:05:07,050
used to define the sizes of all your

108
00:05:07,050 --> 00:05:09,360
natively supported types specifies as it

109
00:05:09,360 --> 00:05:11,970
specifies everything in bits which is

110
00:05:11,970 --> 00:05:15,960
useful as well and in theory we have

111
00:05:15,960 --> 00:05:17,639
this thing in clang which is char width

112
00:05:17,639 --> 00:05:19,350
where you can just set the size of your

113
00:05:19,350 --> 00:05:19,770
chars

114
00:05:19,770 --> 00:05:23,460
and that will affect what char bit means

115
00:05:23,460 --> 00:05:25,620
and it will affect how Klan code genes

116
00:05:25,620 --> 00:05:28,979
for your target or what it doesn't I uh

117
00:05:28,979 --> 00:05:31,979
code generation and in theory you can

118
00:05:31,979 --> 00:05:36,419
set that to whatever size you want so

119
00:05:36,419 --> 00:05:39,450
this so LVM is generally very nice and

120
00:05:39,450 --> 00:05:41,610
it gives you a nice interface the IRS

121
00:05:41,610 --> 00:05:43,440
very nice but there's some places where

122
00:05:43,440 --> 00:05:45,599
this sort of assumption breaks down a

123
00:05:45,599 --> 00:05:48,539
bit one is that LVM ir doesn't have a

124
00:05:48,539 --> 00:05:51,870
void type so in lots of places you sort

125
00:05:51,870 --> 00:05:54,570
of you use an i8 star in place of your

126
00:05:54,570 --> 00:05:56,639
void type and you just materialize them

127
00:05:56,639 --> 00:05:59,370
all over the place that in itself isn't

128
00:05:59,370 --> 00:06:01,680
a problem I mean if you're using my 8

129
00:06:01,680 --> 00:06:06,090
star for a void type then you won't ever

130
00:06:06,090 --> 00:06:08,400
be able to dereference it without sort

131
00:06:08,400 --> 00:06:09,660
of casting it to some type you can

132
00:06:09,660 --> 00:06:11,729
dereference so in itself that shouldn't

133
00:06:11,729 --> 00:06:13,530
be a problem but it does mean we end up

134
00:06:13,530 --> 00:06:15,389
with I stars all over the place there's

135
00:06:15,389 --> 00:06:17,370
also a couple of cases for example

136
00:06:17,370 --> 00:06:21,510
sro a scalar placement that gets will

137
00:06:21,510 --> 00:06:24,690
sometimes introduce we will and bit cast

138
00:06:24,690 --> 00:06:28,800
208 pointers so in your bit cost to hire

139
00:06:28,800 --> 00:06:31,500
pointers and a few other optimizations

140
00:06:31,500 --> 00:06:33,030
will also occasionally do a bit cast

141
00:06:33,030 --> 00:06:35,580
when I ate pointer the really annoying

142
00:06:35,580 --> 00:06:40,400
one and there are a lot of cases where

143
00:06:40,400 --> 00:06:43,320
in LVM code where there's just a hard

144
00:06:43,320 --> 00:06:43,889
code into

145
00:06:43,889 --> 00:06:47,039
multiplied by eight of a bite size to

146
00:06:47,039 --> 00:06:51,689
convert it to a bit size or or back if

147
00:06:51,689 --> 00:06:54,090
you just so if you break the assumption

148
00:06:54,090 --> 00:06:56,360
and you set job it's to whatever and you

149
00:06:56,360 --> 00:06:59,550
sort of make it so you're you know bytes

150
00:06:59,550 --> 00:07:02,069
and on not eight bits then you tend to

151
00:07:02,069 --> 00:07:04,409
trigger assertions and crashes and which

152
00:07:04,409 --> 00:07:06,749
is more beneficial than generating this

153
00:07:06,749 --> 00:07:09,599
compilations but it doesn't mean that

154
00:07:09,599 --> 00:07:12,300
these these sort of cases of divide

155
00:07:12,300 --> 00:07:14,069
eight miles play by eight need to be

156
00:07:14,069 --> 00:07:16,560
fixed all of the intrinsics will soyuz

157
00:07:16,560 --> 00:07:19,139
fix with types or and sort of the key

158
00:07:19,139 --> 00:07:20,580
ones which you need support to do

159
00:07:20,580 --> 00:07:22,319
anything useful like men copying them

160
00:07:22,319 --> 00:07:24,090
setting them move they all take i 8

161
00:07:24,090 --> 00:07:30,389
pointers and obviously this this is also

162
00:07:30,389 --> 00:07:33,779
kind of this this maps quite cleanly to

163
00:07:33,779 --> 00:07:35,819
what the library's expecting you

164
00:07:35,819 --> 00:07:37,379
libraries expect chance and this is just

165
00:07:37,379 --> 00:07:39,539
an assumption that your charms i 8 and

166
00:07:39,539 --> 00:07:42,689
therefore whenever you call and copy mmm

167
00:07:42,689 --> 00:07:45,930
set and then move you'll end up with the

168
00:07:45,930 --> 00:07:52,710
assumption the points are rely 8 so it's

169
00:07:52,710 --> 00:07:56,069
it's not a horrendous problem and it's

170
00:07:56,069 --> 00:07:57,330
not like you need to rewrite the entire

171
00:07:57,330 --> 00:07:59,009
compiler but there's there's sort of

172
00:07:59,009 --> 00:08:01,219
bits and pieces in various places where

173
00:08:01,219 --> 00:08:04,050
it doesn't quite work and you run into a

174
00:08:04,050 --> 00:08:08,159
few crashes you run into a few errors so

175
00:08:08,159 --> 00:08:10,289
there's been quite a lot of previous

176
00:08:10,289 --> 00:08:13,469
discussion about this point you can see

177
00:08:13,469 --> 00:08:16,050
it sort of trends from back in 2009

178
00:08:16,050 --> 00:08:18,870
where I think first for a mention and

179
00:08:18,870 --> 00:08:20,879
then I mean there's some more active

180
00:08:20,879 --> 00:08:25,879
discussion this month about this and

181
00:08:25,879 --> 00:08:28,050
there's definitely people maintaining

182
00:08:28,050 --> 00:08:29,279
how to treat patches of these like these

183
00:08:29,279 --> 00:08:32,490
top two mailing list posts just this

184
00:08:32,490 --> 00:08:34,828
month where I think some someone from

185
00:08:34,828 --> 00:08:37,589
Ericsson and someone working on dcpu-16

186
00:08:37,589 --> 00:08:39,299
which I'm quite sure what the

187
00:08:39,299 --> 00:08:42,719
architecture is per where they're they

188
00:08:42,719 --> 00:08:44,699
have basically assessed patches which

189
00:08:44,699 --> 00:08:46,680
probably do basically what my patches

190
00:08:46,680 --> 00:08:51,240
and do at the moment but I when I starts

191
00:08:51,240 --> 00:08:52,800
making my changes I made it based on

192
00:08:52,800 --> 00:08:53,590
some Oh

193
00:08:53,590 --> 00:08:56,310
matches back here back in 2009 back in

194
00:08:56,310 --> 00:09:00,340
2014 or something so during all of these

195
00:09:00,340 --> 00:09:01,930
sort of mailing list posts they've been

196
00:09:01,930 --> 00:09:03,400
various solutions which should be

197
00:09:03,400 --> 00:09:06,040
mentioned we tried a few of them I'll go

198
00:09:06,040 --> 00:09:10,030
through a few of them now and then I'll

199
00:09:10,030 --> 00:09:14,820
go through what we settled on in the end

200
00:09:14,820 --> 00:09:17,560
so one of the solutions with the first

201
00:09:17,560 --> 00:09:19,060
naive one I mentioned earlier which is

202
00:09:19,060 --> 00:09:20,830
you just set char width I've just used

203
00:09:20,830 --> 00:09:25,720
16 as a value here and so one is just

204
00:09:25,720 --> 00:09:29,290
set your child with 16 and and in this

205
00:09:29,290 --> 00:09:30,730
case you would kind of hope that

206
00:09:30,730 --> 00:09:33,190
everything just works that clang will

207
00:09:33,190 --> 00:09:35,770
just give you the correct char bit it

208
00:09:35,770 --> 00:09:39,610
will generate IR that's appropriate LVM

209
00:09:39,610 --> 00:09:42,250
won't care LVM just works in bits so LVM

210
00:09:42,250 --> 00:09:44,080
will handle that's perfectly fine it

211
00:09:44,080 --> 00:09:45,100
will get all the way through the back

212
00:09:45,100 --> 00:09:48,840
end you'll end up with the right values

213
00:09:48,840 --> 00:09:54,820
that's what that doesn't work and it it

214
00:09:54,820 --> 00:09:57,220
gets you some of the way there in that

215
00:09:57,220 --> 00:09:59,980
it gets it it means that you find all

216
00:09:59,980 --> 00:10:01,920
the assertions which break when you and

217
00:10:01,920 --> 00:10:04,060
try and make this change which is quite

218
00:10:04,060 --> 00:10:05,410
useful because it points out what you

219
00:10:05,410 --> 00:10:09,910
need to fix and clang even with this I

220
00:10:09,910 --> 00:10:11,380
don't know I didn't look at the code

221
00:10:11,380 --> 00:10:12,880
more recently and there have been some

222
00:10:12,880 --> 00:10:14,140
improvements I'm playing in this front

223
00:10:14,140 --> 00:10:15,600
and clang doesn't make quite as many

224
00:10:15,600 --> 00:10:17,740
these assumptions but it still

225
00:10:17,740 --> 00:10:19,540
materializes I ate pointers in various

226
00:10:19,540 --> 00:10:23,140
places and it doesn't help with LVM side

227
00:10:23,140 --> 00:10:25,660
of things and where Alvin's made

228
00:10:25,660 --> 00:10:27,640
assumptions like an SRO a where it can

229
00:10:27,640 --> 00:10:30,640
just materialize I ate pointers so this

230
00:10:30,640 --> 00:10:31,900
doesn't work out of the box and it

231
00:10:31,900 --> 00:10:36,210
definitely needs some changes in LVM so

232
00:10:36,210 --> 00:10:38,530
and I'll essentially talk about this

233
00:10:38,530 --> 00:10:40,030
changes a bit later because if it

234
00:10:40,030 --> 00:10:41,710
becomes the correct solution or the

235
00:10:41,710 --> 00:10:42,970
better solution

236
00:10:42,970 --> 00:10:45,700
so the alternative solution which is

237
00:10:45,700 --> 00:10:49,180
basically a workaround is that you you

238
00:10:49,180 --> 00:10:52,330
keep your even if your target has 16-bit

239
00:10:52,330 --> 00:10:58,540
bytes and you lie and say it does you

240
00:10:58,540 --> 00:11:01,300
say it does have 8-bit bytes and however

241
00:11:01,300 --> 00:11:02,530
you then set the char

242
00:11:02,530 --> 00:11:04,330
alignment so you set it so that all of

243
00:11:04,330 --> 00:11:06,790
your charm valued things will have your

244
00:11:06,790 --> 00:11:07,209
memory

245
00:11:07,209 --> 00:11:09,699
assesses two chars are aligned on 16-bit

246
00:11:09,699 --> 00:11:11,259
boundaries or whatever were bit

247
00:11:11,259 --> 00:11:17,139
boundaries use this minimize has any

248
00:11:17,139 --> 00:11:19,839
change to LVM and it means you don't run

249
00:11:19,839 --> 00:11:22,899
into the issues that elves where LVM is

250
00:11:22,899 --> 00:11:25,689
assumed the wrong sized has assumed

251
00:11:25,689 --> 00:11:31,809
8-bit bytes and in theory should just

252
00:11:31,809 --> 00:11:34,480
work you just use you just align your

253
00:11:34,480 --> 00:11:37,089
bytes to 16 bits and then essentially

254
00:11:37,089 --> 00:11:38,559
that means that you end up with dead

255
00:11:38,559 --> 00:11:40,029
space where you have a byte and you've

256
00:11:40,029 --> 00:11:41,589
got some dead space where you've padded

257
00:11:41,589 --> 00:11:44,529
to fit it up to the 16-bit size or put

258
00:11:44,529 --> 00:11:49,959
in for native size and then what you

259
00:11:49,959 --> 00:11:52,449
would do is in your back end because all

260
00:11:52,449 --> 00:11:53,679
of your addresses would still be

261
00:11:53,679 --> 00:11:56,350
assuming 8-bit bytes if you wanted to

262
00:11:56,350 --> 00:11:58,360
get down to a word size of 16 bits you

263
00:11:58,360 --> 00:12:00,420
then have to have all of your addresses

264
00:12:00,420 --> 00:12:05,649
that's pretty easy it's pretty easy for

265
00:12:05,649 --> 00:12:07,179
global addresses you just have the

266
00:12:07,179 --> 00:12:08,769
constant value you have it's a slightly

267
00:12:08,769 --> 00:12:11,889
harder for sort of any general points or

268
00:12:11,889 --> 00:12:13,360
because you have to you might you might

269
00:12:13,360 --> 00:12:15,549
actually have to generate code to do a

270
00:12:15,549 --> 00:12:17,429
right shift by one or whatever to

271
00:12:17,429 --> 00:12:19,600
convert from a byte address to a word

272
00:12:19,600 --> 00:12:23,649
address and then when you do a low to

273
00:12:23,649 --> 00:12:27,129
restore you would actually with your

274
00:12:27,129 --> 00:12:29,170
with your bright points you've actually

275
00:12:29,170 --> 00:12:31,329
load a word and then you would mask off

276
00:12:31,329 --> 00:12:33,879
the top byte because you don't need it

277
00:12:33,879 --> 00:12:34,240
anymore

278
00:12:34,240 --> 00:12:36,759
and that would give you your 8-bit value

279
00:12:36,759 --> 00:12:41,709
in your memory there's some problems

280
00:12:41,709 --> 00:12:44,860
with this and one is obviously having to

281
00:12:44,860 --> 00:12:46,329
convert from byte addresses to word

282
00:12:46,329 --> 00:12:50,980
addresses is free in many cases but

283
00:12:50,980 --> 00:12:52,509
occasionally you do actually need to

284
00:12:52,509 --> 00:12:54,279
generate some code to do this you'll

285
00:12:54,279 --> 00:12:57,009
have to generate a shift and that hits

286
00:12:57,009 --> 00:12:59,980
your performance you have to do this

287
00:12:59,980 --> 00:13:02,069
change quite late in your back end

288
00:13:02,069 --> 00:13:04,449
because dag combiner and a few other

289
00:13:04,449 --> 00:13:08,559
optimizations will we do make

290
00:13:08,559 --> 00:13:10,269
assumptions about the size of your loads

291
00:13:10,269 --> 00:13:14,290
and we'll do optimizations based on your

292
00:13:14,290 --> 00:13:15,910
pointers based on what they're loading

293
00:13:15,910 --> 00:13:19,320
and and that can cause miss compilations

294
00:13:19,320 --> 00:13:22,090
you also have to generate some code and

295
00:13:22,090 --> 00:13:25,660
to mask off the unwanted parts you'll do

296
00:13:25,660 --> 00:13:28,480
a word load you'll do a 16-bit load but

297
00:13:28,480 --> 00:13:29,860
you only wants to Nate that value and

298
00:13:29,860 --> 00:13:31,360
you're only operating an 8-bit value so

299
00:13:31,360 --> 00:13:33,700
you have to mask off the unwanted part

300
00:13:33,700 --> 00:13:36,010
or sign extend it to the full 16 bits

301
00:13:36,010 --> 00:13:40,000
and then operate on it there's a minor

302
00:13:40,000 --> 00:13:42,340
issue with padding and this is solvable

303
00:13:42,340 --> 00:13:44,230
but it caused me quite a lot of

304
00:13:44,230 --> 00:13:46,210
confusion when I was trying to implement

305
00:13:46,210 --> 00:13:50,410
this which is an plain LVM they use I

306
00:13:50,410 --> 00:13:52,900
eight they insert I eight values for

307
00:13:52,900 --> 00:13:54,460
padding when they want to pad something

308
00:13:54,460 --> 00:13:58,090
and however the I eight also have the

309
00:13:58,090 --> 00:13:59,710
same alignment restrictions so if you

310
00:13:59,710 --> 00:14:01,930
insert an i8 you end up with a 16-bit

311
00:14:01,930 --> 00:14:03,340
value being inserted which doesn't

312
00:14:03,340 --> 00:14:04,240
actually help with you

313
00:14:04,240 --> 00:14:06,010
it doesn't pad anything and it just

314
00:14:06,010 --> 00:14:08,850
leaves everything still underlined and

315
00:14:08,850 --> 00:14:11,680
that caused me a few issues it basically

316
00:14:11,680 --> 00:14:13,660
meant that whenever you insert adding

317
00:14:13,660 --> 00:14:15,610
the sizes would be wrong and some

318
00:14:15,610 --> 00:14:17,230
special cases needs to be added to the

319
00:14:17,230 --> 00:14:20,830
compiler to handle this more elegantly

320
00:14:20,830 --> 00:14:24,340
and make the padding work and if you

321
00:14:24,340 --> 00:14:27,070
make these changes and you do somehow

322
00:14:27,070 --> 00:14:29,890
end up with a underlined address you'll

323
00:14:29,890 --> 00:14:32,860
get crashes if you're lucky and if

324
00:14:32,860 --> 00:14:34,390
you're not and you've gotten there's

325
00:14:34,390 --> 00:14:36,820
some case where you materialize a I

326
00:14:36,820 --> 00:14:41,050
eight pointer but you fail to actually

327
00:14:41,050 --> 00:14:42,850
have the address to get a word pointer

328
00:14:42,850 --> 00:14:44,650
you'll just miss compile and you won't

329
00:14:44,650 --> 00:14:49,120
notice and another solution this one's

330
00:14:49,120 --> 00:14:50,980
on the main list we didn't actually try

331
00:14:50,980 --> 00:14:54,010
this and but it's been suggested which

332
00:14:54,010 --> 00:14:57,720
is you use a fat pointer essentially so

333
00:14:57,720 --> 00:15:00,430
what this means is essentially your your

334
00:15:00,430 --> 00:15:03,250
pointer is not I'm not well-versed in

335
00:15:03,250 --> 00:15:04,930
how in fact pointers work but the

336
00:15:04,930 --> 00:15:06,610
impression I get is that you you make

337
00:15:06,610 --> 00:15:07,900
your point it completely opaque

338
00:15:07,900 --> 00:15:10,930
essentially and so it means you can't

339
00:15:10,930 --> 00:15:13,180
sort of look into the point room and use

340
00:15:13,180 --> 00:15:15,100
its underlying representation you have

341
00:15:15,100 --> 00:15:16,900
to treat it as sort of an opaque box

342
00:15:16,900 --> 00:15:18,610
where you can only do loads and stores

343
00:15:18,610 --> 00:15:23,100
and things through and if you make it a

344
00:15:23,100 --> 00:15:25,300
fat pointer so you make your eye eight

345
00:15:25,300 --> 00:15:27,580
points or a fat point you keep it so

346
00:15:27,580 --> 00:15:30,550
that you do actually use byte 8-bit

347
00:15:30,550 --> 00:15:32,800
bytes to load

348
00:15:32,800 --> 00:15:36,130
and however for every I ate every 8-bit

349
00:15:36,130 --> 00:15:39,070
bytes you're loading you you store the

350
00:15:39,070 --> 00:15:43,480
word address in the pointer and then you

351
00:15:43,480 --> 00:15:47,290
also store an extra bit which tells you

352
00:15:47,290 --> 00:15:49,360
when you load through that address which

353
00:15:49,360 --> 00:15:51,779
of the bits you need to mask off

354
00:15:51,779 --> 00:15:54,540
so essentially you'll end up doing a

355
00:15:54,540 --> 00:15:58,209
16-bit load assuming the 16-bit bytes

356
00:15:58,209 --> 00:16:00,640
you'll do a 16-bit load and then you

357
00:16:00,640 --> 00:16:03,339
will use an extra bit which your pointer

358
00:16:03,339 --> 00:16:06,010
holds to tell you which of those 16 bits

359
00:16:06,010 --> 00:16:09,670
you actually wanted and then you will

360
00:16:09,670 --> 00:16:12,130
add some extra code to mask that off to

361
00:16:12,130 --> 00:16:14,110
get back to your original byte that you

362
00:16:14,110 --> 00:16:18,220
wanted and David chisel has been working

363
00:16:18,220 --> 00:16:19,690
this and cherry back in for another

364
00:16:19,690 --> 00:16:21,970
purpose they have there they're actually

365
00:16:21,970 --> 00:16:23,440
using fat pointers this is just one

366
00:16:23,440 --> 00:16:28,180
potential uses of fat pointers and I

367
00:16:28,180 --> 00:16:29,920
believe that codes pretty stable it's

368
00:16:29,920 --> 00:16:31,839
he's maintaining patch set to do that

369
00:16:31,839 --> 00:16:34,959
out of tree there is a problem with

370
00:16:34,959 --> 00:16:38,470
performance and because your word

371
00:16:38,470 --> 00:16:40,810
address has to be 16 bits so you can

372
00:16:40,810 --> 00:16:44,190
address your full 64 Killer words and

373
00:16:44,190 --> 00:16:47,860
your full address space and however you

374
00:16:47,860 --> 00:16:49,870
also in that 16 bits you also need an

375
00:16:49,870 --> 00:16:51,579
extra bit to tell you once you've loaded

376
00:16:51,579 --> 00:16:53,230
that word which bit of the word you

377
00:16:53,230 --> 00:16:55,420
wanted so you essentially need 17 bits

378
00:16:55,420 --> 00:17:00,640
of pointer and the only way to do that

379
00:17:00,640 --> 00:17:03,579
is to either add a second word so it

380
00:17:03,579 --> 00:17:05,890
becomes word address and then an extra

381
00:17:05,890 --> 00:17:10,750
word which tells you which byte or and

382
00:17:10,750 --> 00:17:13,809
you need you can just alternatively you

383
00:17:13,809 --> 00:17:15,130
could cut down your address space and

384
00:17:15,130 --> 00:17:16,959
say actually I've only got 32 killer

385
00:17:16,959 --> 00:17:19,569
words and then use 16 bits and

386
00:17:19,569 --> 00:17:21,669
essentially just say this the top 15

387
00:17:21,669 --> 00:17:23,709
bits of this word address are the word

388
00:17:23,709 --> 00:17:26,020
address and the bottom bit is just the

389
00:17:26,020 --> 00:17:28,150
byte select or selecting of the crate

390
00:17:28,150 --> 00:17:30,370
byte and then it looks suspiciously like

391
00:17:30,370 --> 00:17:31,929
a normal pointer with some extra

392
00:17:31,929 --> 00:17:36,910
arithmetic and added to so the the

393
00:17:36,910 --> 00:17:40,399
actual solution which we sort of

394
00:17:40,399 --> 00:17:42,779
ended up doing and which basically

395
00:17:42,779 --> 00:17:43,919
everyone that's done on the main list

396
00:17:43,919 --> 00:17:45,869
nor the mailing list posts and have

397
00:17:45,869 --> 00:17:47,809
alluded to which is essentially you just

398
00:17:47,809 --> 00:17:50,879
you extend the data layout and you say

399
00:17:50,879 --> 00:17:56,489
in Elfie Eman you just fix your what you

400
00:17:56,489 --> 00:17:57,749
have an interface which tells you how

401
00:17:57,749 --> 00:18:05,039
wide your bytes are so every case yeah

402
00:18:05,039 --> 00:18:07,979
so in clang then you would set your your

403
00:18:07,979 --> 00:18:09,719
width of your chance your actual

404
00:18:09,719 --> 00:18:13,559
natively supported bite size you will

405
00:18:13,559 --> 00:18:17,369
add this bite bit width in LVM and then

406
00:18:17,369 --> 00:18:19,019
you will allow your target specify how

407
00:18:19,019 --> 00:18:22,169
big its bites are and then whenever you

408
00:18:22,169 --> 00:18:23,969
see these sort of cases in your code

409
00:18:23,969 --> 00:18:27,089
where you've got divided by 8 x 8 or

410
00:18:27,089 --> 00:18:28,469
otherwise where you see an assumption

411
00:18:28,469 --> 00:18:32,129
where the bytes are assumed to be 8 bits

412
00:18:32,129 --> 00:18:35,580
you make a call to this or you find your

413
00:18:35,580 --> 00:18:37,679
data layout you make a call to work out

414
00:18:37,679 --> 00:18:39,749
with a bite bit with bit with this and

415
00:18:39,749 --> 00:18:43,039
then you do the appropriate changes to

416
00:18:43,039 --> 00:18:47,749
take it take that into account otherwise

417
00:18:47,749 --> 00:18:50,940
and a more generic change that you can

418
00:18:50,940 --> 00:18:54,119
make rich doesn't which helps is and in

419
00:18:54,119 --> 00:18:58,139
many places in LVM you will get the get

420
00:18:58,139 --> 00:19:01,979
sizes in terms of bytes rather than in

421
00:19:01,979 --> 00:19:05,369
bits but you don't actually need to

422
00:19:05,369 --> 00:19:07,409
count sizes all the time in bytes it's

423
00:19:07,409 --> 00:19:09,989
just a convenience thing so the

424
00:19:09,989 --> 00:19:11,399
alternative is you'll so you just change

425
00:19:11,399 --> 00:19:15,269
it so that and where you say get get

426
00:19:15,269 --> 00:19:17,129
size of this in bytes you actually

427
00:19:17,129 --> 00:19:18,659
change it to get size of this in bits

428
00:19:18,659 --> 00:19:20,940
and then you alter the code around it

429
00:19:20,940 --> 00:19:23,429
too and make it work entirely in bits

430
00:19:23,429 --> 00:19:25,379
instead of bytes and then that that is

431
00:19:25,379 --> 00:19:27,690
generally more generic anyway and more

432
00:19:27,690 --> 00:19:29,909
generically useful but where you can't

433
00:19:29,909 --> 00:19:31,919
do that you'd have to make use of a

434
00:19:31,919 --> 00:19:35,549
extra call to bite them this is pretty

435
00:19:35,549 --> 00:19:36,929
tedious it requires lots of small

436
00:19:36,929 --> 00:19:40,039
changes all over the place and

437
00:19:40,039 --> 00:19:42,869
everywhere everywhere this assumptions

438
00:19:42,869 --> 00:19:44,219
made you have to break that assumption

439
00:19:44,219 --> 00:19:45,929
and you have to sort of feed in the data

440
00:19:45,929 --> 00:19:47,549
layout and get the call to this function

441
00:19:47,549 --> 00:19:50,370
in there so

442
00:19:50,370 --> 00:19:52,409
and few stumbling points I'll quickly go

443
00:19:52,409 --> 00:19:53,610
through which I found when trying to

444
00:19:53,610 --> 00:19:57,870
implement this so first of all whenever

445
00:19:57,870 --> 00:20:00,090
you generates I ate so you have this

446
00:20:00,090 --> 00:20:02,909
cool get into eight pointer type which

447
00:20:02,909 --> 00:20:06,450
is used a lot in LVM clang and you need

448
00:20:06,450 --> 00:20:08,909
to replace that with get int n pointer

449
00:20:08,909 --> 00:20:12,900
type and then make a call to the data

450
00:20:12,900 --> 00:20:15,809
layout to get the byte size use that

451
00:20:15,809 --> 00:20:18,690
correct byte size in bits to get the

452
00:20:18,690 --> 00:20:21,570
correct pointer type and basically

453
00:20:21,570 --> 00:20:23,340
replace all instances of into eight

454
00:20:23,340 --> 00:20:24,990
pointer type with into endpoints type

455
00:20:24,990 --> 00:20:26,730
this sometimes requires you to sort of

456
00:20:26,730 --> 00:20:28,950
find the data layout and wherever it

457
00:20:28,950 --> 00:20:33,210
happens to be the alternative and to

458
00:20:33,210 --> 00:20:35,820
this would be to just keep allowing into

459
00:20:35,820 --> 00:20:39,779
eight pointer type however in LVM

460
00:20:39,779 --> 00:20:42,690
somewhere maybe expand that in LVM

461
00:20:42,690 --> 00:20:44,850
itself to a wider load and the

462
00:20:44,850 --> 00:20:47,669
appropriate math tip and get the

463
00:20:47,669 --> 00:20:51,630
original I ate out and however this

464
00:20:51,630 --> 00:20:53,760
seemed actually mate just replacing all

465
00:20:53,760 --> 00:20:54,990
the cool seemed like the more elegant

466
00:20:54,990 --> 00:20:56,850
solutions that's what we settled on we

467
00:20:56,850 --> 00:21:00,529
didn't really investigate this and

468
00:21:00,529 --> 00:21:02,640
sorting out the intrinsic soul of your

469
00:21:02,640 --> 00:21:04,620
intrinsics have sort of by eight star

470
00:21:04,620 --> 00:21:09,360
and four pointer arguments we've seen a

471
00:21:09,360 --> 00:21:12,240
different solution so these these have

472
00:21:12,240 --> 00:21:14,039
hard-coded I eight star as their pointer

473
00:21:14,039 --> 00:21:16,350
types and the intrinsics could just be

474
00:21:16,350 --> 00:21:18,210
made essentially to use any pointer

475
00:21:18,210 --> 00:21:20,340
types which LVM has for its intrinsic

476
00:21:20,340 --> 00:21:23,159
switch say the type is defined at

477
00:21:23,159 --> 00:21:24,630
runtime when you create the intrinsic

478
00:21:24,630 --> 00:21:27,779
instead of hard-coded when the table of

479
00:21:27,779 --> 00:21:32,370
intrinsics is generated and but what we

480
00:21:32,370 --> 00:21:34,559
actually but what we did instead was we

481
00:21:34,559 --> 00:21:37,710
just added a new type which is the byte

482
00:21:37,710 --> 00:21:39,870
type which is actually a pseudo type

483
00:21:39,870 --> 00:21:42,000
which essentially got converted to

484
00:21:42,000 --> 00:21:44,279
whatever the correct type was when you

485
00:21:44,279 --> 00:21:46,559
created the intrinsic so either way

486
00:21:46,559 --> 00:21:48,600
basically whenever when the intrinsic

487
00:21:48,600 --> 00:21:50,250
actually gets created in all the sites

488
00:21:50,250 --> 00:21:51,600
where you can create a mem copy

489
00:21:51,600 --> 00:21:54,179
intrinsic and M set intrinsic and you

490
00:21:54,179 --> 00:21:56,429
would have to make another call to that

491
00:21:56,429 --> 00:21:58,649
function to get the bit with the byte

492
00:21:58,649 --> 00:22:00,659
size and bits and then you'd feed that

493
00:22:00,659 --> 00:22:02,370
in to give it the correct type when

494
00:22:02,370 --> 00:22:02,909
you're building

495
00:22:02,909 --> 00:22:04,679
intrinsic stew use the correct type for

496
00:22:04,679 --> 00:22:12,330
the arguments so as the other thing

497
00:22:12,330 --> 00:22:13,590
which is all of your hard coded

498
00:22:13,590 --> 00:22:16,039
multiplied by X and divided by eight

499
00:22:16,039 --> 00:22:18,509
this in theory is pretty simple you just

500
00:22:18,509 --> 00:22:20,759
make calls to your data layout to get

501
00:22:20,759 --> 00:22:22,440
the byte size in every case that you

502
00:22:22,440 --> 00:22:25,739
call these the trouble is there's lots

503
00:22:25,739 --> 00:22:27,989
of headers and for example the ones

504
00:22:27,989 --> 00:22:29,580
which contain these functions like your

505
00:22:29,580 --> 00:22:33,090
data layout to H your env tease your AV

506
00:22:33,090 --> 00:22:34,679
tease your value types that are used by

507
00:22:34,679 --> 00:22:36,840
your machines and all of the things

508
00:22:36,840 --> 00:22:39,320
which tell you how big the stores are

509
00:22:39,320 --> 00:22:43,440
they are all hard coding divided by 8 to

510
00:22:43,440 --> 00:22:45,090
get these size and bytes of things or

511
00:22:45,090 --> 00:22:48,419
the size and bits of things move and so

512
00:22:48,419 --> 00:22:51,299
all of those need to be updated and all

513
00:22:51,299 --> 00:22:54,049
of the cool sites need to be updated to

514
00:22:54,049 --> 00:22:56,429
quit either query the data now and in

515
00:22:56,429 --> 00:22:58,080
the past the data layout into here to

516
00:22:58,080 --> 00:22:59,879
use the correct sizes for the divisor

517
00:22:59,879 --> 00:23:05,220
multiplies or or they need to and

518
00:23:05,220 --> 00:23:07,349
basically all the calls need to be

519
00:23:07,349 --> 00:23:09,179
removed and it would replace with

520
00:23:09,179 --> 00:23:11,820
something more generic so this was the

521
00:23:11,820 --> 00:23:13,710
majority of the changes is just changing

522
00:23:13,710 --> 00:23:15,029
all of these cases feeding in the

523
00:23:15,029 --> 00:23:18,239
correct sizes of bytes into all of these

524
00:23:18,239 --> 00:23:21,299
functions and and updating all of the

525
00:23:21,299 --> 00:23:22,919
cool sites and updating the interfaces

526
00:23:22,919 --> 00:23:24,840
and this is pretty much a mechanical

527
00:23:24,840 --> 00:23:26,070
change it's just a mechanical change

528
00:23:26,070 --> 00:23:27,570
where you don't have any option but to

529
00:23:27,570 --> 00:23:30,029
sort of mccann manually go through each

530
00:23:30,029 --> 00:23:31,769
of the files look at all the cool sites

531
00:23:31,769 --> 00:23:33,389
feeding the correct information get the

532
00:23:33,389 --> 00:23:36,738
correct byte size and account for that

533
00:23:38,340 --> 00:23:40,650
so yes so there's lots like this very

534
00:23:40,650 --> 00:23:43,350
annoyingly I'm coming where this is it's

535
00:23:43,350 --> 00:23:45,270
probably data layout you if you get in

536
00:23:45,270 --> 00:23:47,310
the store size of the type Isis type 2h

537
00:23:47,310 --> 00:23:49,440
actually if you get the store size of

538
00:23:49,440 --> 00:23:50,970
your type you will have this very useful

539
00:23:50,970 --> 00:23:52,830
get the sizing bits which is lovely it's

540
00:23:52,830 --> 00:23:54,510
nice and generic it's only in bits

541
00:23:54,510 --> 00:23:55,950
however the you want your then just add

542
00:23:55,950 --> 00:23:59,100
7 to 1/8 to get it down to a byte size

543
00:23:59,100 --> 00:24:04,350
which is very annoying so and this is in

544
00:24:04,350 --> 00:24:06,780
some header which has very few outside

545
00:24:06,780 --> 00:24:09,600
dependencies and so this is just the

546
00:24:09,600 --> 00:24:12,060
generic type header which it's very sort

547
00:24:12,060 --> 00:24:14,130
of independent so you need to basically

548
00:24:14,130 --> 00:24:18,840
feed in something to make this not 8 and

549
00:24:18,840 --> 00:24:24,660
it's not 7 and a small complexity and

550
00:24:24,660 --> 00:24:26,670
even though your architecture may use

551
00:24:26,670 --> 00:24:29,850
non 8-bit bytes may use 16-bit bytes and

552
00:24:29,850 --> 00:24:32,070
it's kind of quite useful sometimes to

553
00:24:32,070 --> 00:24:34,220
keep your elf and your dwarf

554
00:24:34,220 --> 00:24:37,950
representation in 8-bit bytes in the

555
00:24:37,950 --> 00:24:40,020
8-bit byte world so you have to handle

556
00:24:40,020 --> 00:24:43,050
that and and at some point you then have

557
00:24:43,050 --> 00:24:45,900
to sort of convert from whatever your

558
00:24:45,900 --> 00:24:51,870
machine byte is down to whatever your to

559
00:24:51,870 --> 00:24:54,210
8-bit bytes that's partly for the on

560
00:24:54,210 --> 00:24:56,220
discrepant representation kind of

561
00:24:56,220 --> 00:24:57,870
assumes certainly for Torf it kind of

562
00:24:57,870 --> 00:24:59,940
assumes that you have 8-bit bytes if

563
00:24:59,940 --> 00:25:06,960
you're on disk representation so there's

564
00:25:06,960 --> 00:25:08,640
advantages the advantages to doing this

565
00:25:08,640 --> 00:25:13,200
this way is basically an char bit you're

566
00:25:13,200 --> 00:25:13,770
not lying

567
00:25:13,770 --> 00:25:16,230
when you in your C code you know you're

568
00:25:16,230 --> 00:25:18,450
not giving a arbitrary value of char bit

569
00:25:18,450 --> 00:25:20,820
which doesn't actually match your

570
00:25:20,820 --> 00:25:23,790
machine so it's a bit closer to and it's

571
00:25:23,790 --> 00:25:25,680
a bit more predictable and there's

572
00:25:25,680 --> 00:25:27,300
minimal performance penalty whereas the

573
00:25:27,300 --> 00:25:29,580
other methods like masking off of parts

574
00:25:29,580 --> 00:25:32,610
of words and doubling the size of your

575
00:25:32,610 --> 00:25:33,810
pointers just so you can address

576
00:25:33,810 --> 00:25:36,060
everything and it's quite costly in

577
00:25:36,060 --> 00:25:37,680
performance so but this doesn't really

578
00:25:37,680 --> 00:25:40,230
cost you anything and the disadvantages

579
00:25:40,230 --> 00:25:42,150
mainly is just that it's it requires

580
00:25:42,150 --> 00:25:45,420
changes all over the LLVM and and you

581
00:25:45,420 --> 00:25:46,980
have to maintain a lot of changes and

582
00:25:46,980 --> 00:25:50,220
keep hold of those changes and it's made

583
00:25:50,220 --> 00:25:51,820
sort of rolling forward to the

584
00:25:51,820 --> 00:25:55,000
of tree and humongous pain and because I

585
00:25:55,000 --> 00:25:56,470
have to maintain this and there's lots

586
00:25:56,470 --> 00:25:57,580
of changed they're encoded in the

587
00:25:57,580 --> 00:26:00,550
meantime and there's the anther minor

588
00:26:00,550 --> 00:26:02,140
disadvantage of which it kind of breaks

589
00:26:02,140 --> 00:26:03,610
that assumption that everyone holds that

590
00:26:03,610 --> 00:26:06,780
your bikes are always 8-bit and but

591
00:26:06,780 --> 00:26:09,370
that's that's not as troublesome I I

592
00:26:09,370 --> 00:26:11,110
think if you're for a lots of systems

593
00:26:11,110 --> 00:26:12,610
where your program for example DSP

594
00:26:12,610 --> 00:26:14,320
you're well aware that bytes not equal

595
00:26:14,320 --> 00:26:16,090
to seven to eight bit so there's not

596
00:26:16,090 --> 00:26:19,030
quite such a bad thing for those so the

597
00:26:19,030 --> 00:26:21,820
status of these we have implemented this

598
00:26:21,820 --> 00:26:23,920
in a production compiler for a customer

599
00:26:23,920 --> 00:26:28,110
that we have and we've got a DSP and

600
00:26:28,110 --> 00:26:30,640
there's no patches yet for the generic

601
00:26:30,640 --> 00:26:33,190
to make these changes generically and I

602
00:26:33,190 --> 00:26:34,660
know some of the people on the mailing

603
00:26:34,660 --> 00:26:36,660
list there was more recent talk about

604
00:26:36,660 --> 00:26:39,070
other people who have similar patches

605
00:26:39,070 --> 00:26:40,810
making them generic and submitting

606
00:26:40,810 --> 00:26:45,190
patches I guess we should probably post

607
00:26:45,190 --> 00:26:46,780
mailing lists and see what status that's

608
00:26:46,780 --> 00:26:52,180
in and I need to well this this

609
00:26:52,180 --> 00:26:54,430
production compiler is I think about six

610
00:26:54,430 --> 00:26:56,710
months or nine months behind top of tree

611
00:26:56,710 --> 00:26:59,410
so first of all I need to rebase against

612
00:26:59,410 --> 00:27:00,990
offer tree which is going to be a pain

613
00:27:00,990 --> 00:27:03,700
and I need to actually tidy it up and

614
00:27:03,700 --> 00:27:05,230
build it into a patch sets of is that's

615
00:27:05,230 --> 00:27:07,330
actually quite a large amount of work I

616
00:27:07,330 --> 00:27:09,880
think to do that the other thing is I've

617
00:27:09,880 --> 00:27:11,860
only looked at the case we cared about

618
00:27:11,860 --> 00:27:14,410
which is where our Java is 16 bits where

619
00:27:14,410 --> 00:27:15,520
our bytes are 16 bits

620
00:27:15,520 --> 00:27:18,700
I made no attempt to handle the other

621
00:27:18,700 --> 00:27:21,640
cases and so it probably won't work

622
00:27:21,640 --> 00:27:25,870
where what the and then at a minimum it

623
00:27:25,870 --> 00:27:27,970
won't work where your Charvet is not a

624
00:27:27,970 --> 00:27:32,470
multiple of eight because of assumptions

625
00:27:32,470 --> 00:27:33,790
in the compiler about alignments and

626
00:27:33,790 --> 00:27:37,390
things and the other really key one

627
00:27:37,390 --> 00:27:38,800
before this is ever going to be ready

628
00:27:38,800 --> 00:27:42,460
for prime and entry is to write some

629
00:27:42,460 --> 00:27:43,930
targeted tests we don't really have a

630
00:27:43,930 --> 00:27:46,120
way of testing this easily because all

631
00:27:46,120 --> 00:27:48,910
of the targets in tree are sane and and

632
00:27:48,910 --> 00:27:53,020
have sensibly sized bytes and I'm also

633
00:27:53,020 --> 00:27:54,730
not quite sure how to write target to

634
00:27:54,730 --> 00:27:56,470
test for this but that's an exercise

635
00:27:56,470 --> 00:27:58,690
that I'll go through when I've got this

636
00:27:58,690 --> 00:28:01,100
close to ready to get in tree

637
00:28:01,100 --> 00:28:04,620
so future work is to fix this all up and

638
00:28:04,620 --> 00:28:06,720
submit the patches for scrutiny and for

639
00:28:06,720 --> 00:28:07,920
people to pick them apart and tell me

640
00:28:07,920 --> 00:28:10,380
I've done everything wrong

641
00:28:10,380 --> 00:28:12,360
our plan is we have this experimental

642
00:28:12,360 --> 00:28:15,000
back-end we've been working on which

643
00:28:15,000 --> 00:28:16,290
we're trying to get upstream at the

644
00:28:16,290 --> 00:28:19,320
moment and one of the changes I want to

645
00:28:19,320 --> 00:28:21,780
make is we wanted target which has this

646
00:28:21,780 --> 00:28:23,970
kind of feature entry so I'm going to

647
00:28:23,970 --> 00:28:27,230
change our architecture to have 16-bit

648
00:28:27,230 --> 00:28:30,240
bytes that gives us something to test

649
00:28:30,240 --> 00:28:31,470
against one of the things I wasn't sure

650
00:28:31,470 --> 00:28:32,850
about is how we'll test this once it's

651
00:28:32,850 --> 00:28:36,180
in true when it's entry and and I'm

652
00:28:36,180 --> 00:28:37,920
hoping it might be an entry target for

653
00:28:37,920 --> 00:28:39,180
this feature if someone doesn't have a

654
00:28:39,180 --> 00:28:41,130
better alternative and I've not seen any

655
00:28:41,130 --> 00:28:42,990
suggestions for better alternative maybe

656
00:28:42,990 --> 00:28:47,100
dcpu-16 could be and then the future

657
00:28:47,100 --> 00:28:48,510
work is handled child it's when they're

658
00:28:48,510 --> 00:28:51,570
not multiple of eight when they're 12 or

659
00:28:51,570 --> 00:28:53,700
10 or whatever weirdness you have so

660
00:28:53,700 --> 00:28:57,240
that's everything for me now so are

661
00:28:57,240 --> 00:28:59,630
there any questions

662
00:29:12,840 --> 00:29:15,980
[Music]

663
00:29:16,550 --> 00:29:21,900
use your generic white stuff then it has

664
00:29:21,900 --> 00:29:26,490
to be addressed which is also standard I

665
00:29:26,490 --> 00:29:29,010
think the standard says it has to be a

666
00:29:29,010 --> 00:29:36,930
child shark yeah 33 champions - so you

667
00:29:36,930 --> 00:29:39,900
may end up with generating code that

668
00:29:39,900 --> 00:29:42,210
it's not standard compliant or doesn't

669
00:29:42,210 --> 00:29:45,060
even work yeah so my assumption would

670
00:29:45,060 --> 00:29:50,300
bei bit nude the base might size

671
00:29:50,550 --> 00:29:53,590
yes and I felt a bit and bad about

672
00:29:53,590 --> 00:29:56,620
introducing that because suddenly LVM

673
00:29:56,620 --> 00:29:58,330
doesn't care at all about Jars and then

674
00:29:58,330 --> 00:30:00,190
suddenly I've added something which is

675
00:30:00,190 --> 00:30:39,940
very dependent on see yes and I've not

676
00:30:39,940 --> 00:30:41,830
really looked at the opaque point of

677
00:30:41,830 --> 00:30:43,690
stuff to see how this would change

678
00:30:43,690 --> 00:30:44,230
everything

679
00:30:44,230 --> 00:30:47,470
and I have a feeling we'll make cos

680
00:30:47,470 --> 00:30:49,540
knock on effects which mean I have to

681
00:30:49,540 --> 00:30:52,270
rethink this and so that's an exercise

682
00:30:52,270 --> 00:30:55,570
for when I've had time to look at opaque

683
00:30:55,570 --> 00:31:01,360
pointers and what their gains change yes

684
00:31:01,360 --> 00:31:05,560
I I did a quick search because I've

685
00:31:05,560 --> 00:31:08,560
dated and the compiler in sort of

686
00:31:08,560 --> 00:31:11,200
updated most of the key interfaces and

687
00:31:11,200 --> 00:31:12,460
I've got this working and it definitely

688
00:31:12,460 --> 00:31:15,700
works but I I've still got a few cases

689
00:31:15,700 --> 00:31:17,650
where I know I've got hard-coded /

690
00:31:17,650 --> 00:31:18,790
eighths in there and I haven't yet

691
00:31:18,790 --> 00:31:21,430
figured out and fixed all of them so

692
00:31:21,430 --> 00:31:23,860
there's and I need to go back and review

693
00:31:23,860 --> 00:31:31,500
all the changes I made okay so yes

694
00:31:33,600 --> 00:31:46,230
I said so they the question is basically

695
00:31:46,230 --> 00:31:51,809
what happens if you have pointers to say

696
00:31:51,809 --> 00:31:54,299
you've got pointers to i8 indifference

697
00:31:54,299 --> 00:31:58,710
oh well yeah pointers to i8 or pointers

698
00:31:58,710 --> 00:32:00,210
to char right

699
00:32:00,210 --> 00:32:02,760
yeah pointers to chars in different

700
00:32:02,760 --> 00:32:07,799
address spaces which use different sizes

701
00:32:07,799 --> 00:32:20,370
I don't think I can handle as I've seen

702
00:32:20,370 --> 00:32:21,990
I did see that get mentioned in one of

703
00:32:21,990 --> 00:32:23,370
the main in this post as someone pointed

704
00:32:23,370 --> 00:32:26,490
out an architecture where they had to

705
00:32:26,490 --> 00:32:27,960
address spaces one of which is word

706
00:32:27,960 --> 00:32:29,490
addressed in one of which is byte

707
00:32:29,490 --> 00:32:31,100
addressed and they wanted to somehow

708
00:32:31,100 --> 00:32:34,110
magically have this be handled elegantly

709
00:32:34,110 --> 00:32:39,240
and I'm that seems so unbelievably

710
00:32:39,240 --> 00:32:41,480
painful

711
00:32:56,710 --> 00:33:00,800
yeah yeah so that that could be an

712
00:33:00,800 --> 00:33:03,970
exercise for when it becomes a problem

713
00:33:03,970 --> 00:33:36,770
okay yes no I don't really know it's it

714
00:33:36,770 --> 00:33:41,660
depends and it requires stepping on lots

715
00:33:41,660 --> 00:33:43,640
of bits of the compiler to make the

716
00:33:43,640 --> 00:33:46,610
changes and I have a feeling people

717
00:33:46,610 --> 00:33:48,470
won't necessarily be happy with the

718
00:33:48,470 --> 00:33:50,420
specific changes I've made so it's

719
00:33:50,420 --> 00:33:55,670
probably gonna be a bit of a slog to yes

720
00:33:55,670 --> 00:33:57,980
and I I'm not quite sure but I assume it

721
00:33:57,980 --> 00:33:59,330
would also slow things down a bit that

722
00:33:59,330 --> 00:34:00,860
we have to sort of pull in the data

723
00:34:00,860 --> 00:34:03,350
layout everywhere and and in query it to

724
00:34:03,350 --> 00:34:04,130
get this information

725
00:34:04,130 --> 00:34:07,730
probably negligible but and yeah because

726
00:34:07,730 --> 00:34:09,800
they'll be it's sort of like how I'll

727
00:34:09,800 --> 00:34:11,600
try and get some sort of incremental

728
00:34:11,600 --> 00:34:13,940
changes and I'm probably the first one

729
00:34:13,940 --> 00:34:15,739
is add this interface to your data

730
00:34:15,739 --> 00:34:18,129
layout and then try and gradually and

731
00:34:18,129 --> 00:34:20,510
make the changes to other bits of the

732
00:34:20,510 --> 00:34:22,760
compiled of that and that sort of on a

733
00:34:22,760 --> 00:34:24,860
step by step basis so one thing I

734
00:34:24,860 --> 00:34:29,030
haven't considered is and what happens

735
00:34:29,030 --> 00:34:31,969
if you've got if you've got a 32 as your

736
00:34:31,969 --> 00:34:36,139
bite size i I'm probably not able to

737
00:34:36,139 --> 00:34:38,719
handle up to that size because you can

738
00:34:38,719 --> 00:34:41,360
still create i-16 pointers and I assume

739
00:34:41,360 --> 00:34:43,969
I will still end up creating my 16

740
00:34:43,969 --> 00:34:46,580
pointers in some cases I haven't really

741
00:34:46,580 --> 00:34:48,320
thought about it but that might still be

742
00:34:48,320 --> 00:34:49,909
a problem you end up with a nice 16

743
00:34:49,909 --> 00:34:52,850
pointer but your char size is wider and

744
00:34:52,850 --> 00:34:55,730
then you still have a problem and say

745
00:34:55,730 --> 00:34:59,200
any more questions

746
00:35:05,849 --> 00:35:10,150
yes I will once I've written it so yes

747
00:35:10,150 --> 00:35:13,839
so I'm gonna put this in a ap and we're

748
00:35:13,839 --> 00:35:15,760
going to I don't know I assumed we might

749
00:35:15,760 --> 00:35:17,859
change a AP - and see this book

750
00:35:17,859 --> 00:35:19,330
otherwise it'll be a branch of a AP

751
00:35:19,330 --> 00:35:22,630
which is our architecture and and my

752
00:35:22,630 --> 00:35:24,940
plan is to put the patch in there so

753
00:35:24,940 --> 00:35:26,109
that everyone can look at it and see it

754
00:35:26,109 --> 00:35:29,320
in a working architecture and and then

755
00:35:29,320 --> 00:35:32,530
hopefully that will be a good example of

756
00:35:32,530 --> 00:35:34,570
it working that it works and it can work

757
00:35:34,570 --> 00:35:36,640
and that it doesn't affect everyone else

758
00:35:36,640 --> 00:35:38,320
too much because I mean obviously I

759
00:35:38,320 --> 00:35:39,609
don't want to make these changes but

760
00:35:39,609 --> 00:35:40,720
then the compiler and break everyone's

761
00:35:40,720 --> 00:35:43,180
code or slow everyone down or endlessly

762
00:35:43,180 --> 00:35:59,760
say yeah yep yeah so yeah so and

763
00:35:59,760 --> 00:36:02,520
actually in the code I've written I've

764
00:36:02,520 --> 00:36:04,839
rather than using bytes I've used char

765
00:36:04,839 --> 00:36:07,930
so I've just said char low the code that

766
00:36:07,930 --> 00:36:10,570
adds its own confusion so probably

767
00:36:10,570 --> 00:36:11,859
something like minimal addressable unit

768
00:36:11,859 --> 00:36:14,109
or something would be more would be

769
00:36:14,109 --> 00:36:14,470
better

770
00:36:14,470 --> 00:36:16,000
I used sharp and then I realized that

771
00:36:16,000 --> 00:36:18,430
char in the C standard means byte and

772
00:36:18,430 --> 00:36:20,830
then I've got this it doesn't really

773
00:36:20,830 --> 00:36:24,089
work so yeah so I

774
00:36:29,650 --> 00:36:35,060
yes honestly partly it was minimizing

775
00:36:35,060 --> 00:36:36,950
the I didn't want to have to write lines

776
00:36:36,950 --> 00:36:38,270
where I was get minimal addressable unit

777
00:36:38,270 --> 00:36:41,240
sizes every time so I just then I took

778
00:36:41,240 --> 00:36:43,550
the simple route and just used Charles

779
00:36:43,550 --> 00:36:45,560
pan yeah so that's that's probably gonna

780
00:36:45,560 --> 00:36:47,660
be a good idea as well because everyone

781
00:36:47,660 --> 00:36:52,070
does still assume does still assume that

782
00:36:52,070 --> 00:36:54,950
bike means 8-bit so I'd prefer not to

783
00:36:54,950 --> 00:36:58,000
break that underlying assumption now

784
00:36:58,000 --> 00:37:03,660
okay okay thank you very much

785
00:37:03,660 --> 00:37:13,529
[Applause]

