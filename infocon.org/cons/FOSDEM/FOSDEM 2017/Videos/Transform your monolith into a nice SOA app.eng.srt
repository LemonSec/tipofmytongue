1
00:00:43,400 --> 00:00:46,739
so yeah I think you know she just gives

2
00:00:46,739 --> 00:00:49,820
a right answer further

3
00:01:15,929 --> 00:01:18,929
this

4
00:01:21,730 --> 00:01:25,370
okay so let's start welcome everybody

5
00:01:25,370 --> 00:01:31,730
thank you for coming today we will talk

6
00:01:31,730 --> 00:01:34,460
about the migration of an or legacy

7
00:01:34,460 --> 00:01:37,820
application into some more modern

8
00:01:37,820 --> 00:01:39,890
architecture like service-oriented

9
00:01:39,890 --> 00:01:46,670
architecture so just some words so I'm

10
00:01:46,670 --> 00:01:49,160
actually oh I'm back in developer at

11
00:01:49,160 --> 00:01:52,160
Optima in Brazil so small startup in

12
00:01:52,160 --> 00:01:55,940
Amanda brew and growing fast I am open

13
00:01:55,940 --> 00:01:59,390
source enthusiasts and I enjoy walking I

14
00:01:59,390 --> 00:02:05,390
like my job I think we have we are very

15
00:02:05,390 --> 00:02:08,330
lucky to be software engineers that's a

16
00:02:08,330 --> 00:02:13,730
never-ending learning process I'm when

17
00:02:13,730 --> 00:02:16,459
I'm not working I like to travel and I

18
00:02:16,459 --> 00:02:17,840
like truck tours because tractors are

19
00:02:17,840 --> 00:02:23,709
cool so what will we talk about today

20
00:02:23,709 --> 00:02:27,260
this presentation is not about parallel

21
00:02:27,260 --> 00:02:31,550
migration it's not like build another

22
00:02:31,550 --> 00:02:33,320
application in parallel offshore

23
00:02:33,320 --> 00:02:35,269
application and when you reach a certain

24
00:02:35,269 --> 00:02:37,070
point just switch to the new one

25
00:02:37,070 --> 00:02:40,489
it's like refactoring a life application

26
00:02:40,489 --> 00:02:46,880
and the main purpose will be to make

27
00:02:46,880 --> 00:02:48,459
your application easy to work with

28
00:02:48,459 --> 00:02:54,380
moment a neighbor more testable it will

29
00:02:54,380 --> 00:02:56,780
be more easy to understand to when you

30
00:02:56,780 --> 00:02:58,970
on board renewals or new people to work

31
00:02:58,970 --> 00:03:02,570
on and it will scale in a better way and

32
00:03:02,570 --> 00:03:04,220
that's the most important point for

33
00:03:04,220 --> 00:03:07,760
today I think so let's have a look at

34
00:03:07,760 --> 00:03:10,330
the plan first I have some words about

35
00:03:10,330 --> 00:03:13,850
concepts of system mounted architecture

36
00:03:13,850 --> 00:03:17,090
then we will see some tools that will

37
00:03:17,090 --> 00:03:19,780
help you in the migration like some

38
00:03:19,780 --> 00:03:24,110
different refactoring workflow best

39
00:03:24,110 --> 00:03:26,180
practices that will help you to build a

40
00:03:26,180 --> 00:03:29,750
scalable micro service for your new

41
00:03:29,750 --> 00:03:33,049
brand-new application and then we will

42
00:03:33,049 --> 00:03:33,920
just

43
00:03:33,920 --> 00:03:38,720
have some quick examples about migration

44
00:03:38,720 --> 00:03:43,370
because I talk to my way in doing a

45
00:03:43,370 --> 00:03:45,140
migration know so I have plenty of

46
00:03:45,140 --> 00:03:46,599
examples

47
00:03:46,599 --> 00:03:49,660
okay so first let's start with

48
00:03:49,660 --> 00:03:51,610
service-oriented architecture so

49
00:03:51,610 --> 00:03:56,450
everyone here heard the world okay it's

50
00:03:56,450 --> 00:04:01,850
okay for everyone so the concept of SOA

51
00:04:01,850 --> 00:04:06,140
our business value has a priority of a

52
00:04:06,140 --> 00:04:10,519
technical strategy strategic goals has a

53
00:04:10,519 --> 00:04:13,930
priority over project specific benefits

54
00:04:13,930 --> 00:04:16,399
interoperability is better than custom

55
00:04:16,399 --> 00:04:19,579
integration shared service is better

56
00:04:19,579 --> 00:04:22,970
than specific development this one is

57
00:04:22,970 --> 00:04:24,740
very important flexibility has a

58
00:04:24,740 --> 00:04:29,120
priority of a optimization that's very

59
00:04:29,120 --> 00:04:32,270
hard to make non technical manager

60
00:04:32,270 --> 00:04:37,160
accepts this point because if you say ok

61
00:04:37,160 --> 00:04:39,130
I don't care anymore about optimization

62
00:04:39,130 --> 00:04:46,220
yeah you will just say no but yeah if

63
00:04:46,220 --> 00:04:49,640
you have single responsibilities small

64
00:04:49,640 --> 00:04:54,950
agnostic services doing some tasks you

65
00:04:54,950 --> 00:04:58,510
will not you will not need to hover over

66
00:04:58,510 --> 00:05:01,430
optimize your application anymore you

67
00:05:01,430 --> 00:05:04,400
will just have to make each service

68
00:05:04,400 --> 00:05:09,200
scale at his home rhythm and evolution

69
00:05:09,200 --> 00:05:11,240
refinement is better than initial

70
00:05:11,240 --> 00:05:14,120
perfection and so if you take all these

71
00:05:14,120 --> 00:05:18,130
concepts the same idea is behind its

72
00:05:18,130 --> 00:05:22,220
work for the long term if you want to

73
00:05:22,220 --> 00:05:24,770
maintain your code you have to work for

74
00:05:24,770 --> 00:05:28,400
the long term so respect these concepts

75
00:05:28,400 --> 00:05:32,360
and we have also principles so agnostic

76
00:05:32,360 --> 00:05:37,070
services it's single responsibility so

77
00:05:37,070 --> 00:05:40,270
abstraction service are black boxes for

78
00:05:40,270 --> 00:05:43,639
every other part of your application

79
00:05:43,639 --> 00:05:46,430
statelessness the service should be

80
00:05:46,430 --> 00:05:48,409
stateless composability

81
00:05:48,409 --> 00:05:52,400
very important it's yeah you can compose

82
00:05:52,400 --> 00:05:54,830
service with a set of other agnostic

83
00:05:54,830 --> 00:05:58,330
services it's like mainly using the

84
00:05:58,330 --> 00:06:01,780
dependency injection pattern and

85
00:06:01,780 --> 00:06:04,250
reusability so a service should be

86
00:06:04,250 --> 00:06:07,580
reused between every parts of your code

87
00:06:07,580 --> 00:06:10,550
and on capsulation encapsulation is a

88
00:06:10,550 --> 00:06:14,180
very practical thing for a migration

89
00:06:14,180 --> 00:06:16,699
it's okay you have legacy code and it's

90
00:06:16,699 --> 00:06:19,430
impossible to do a clean service with it

91
00:06:19,430 --> 00:06:22,550
but you want to be able to interact with

92
00:06:22,550 --> 00:06:24,740
it through your dependency injection

93
00:06:24,740 --> 00:06:27,199
container for instance so you just

94
00:06:27,199 --> 00:06:29,779
create a dummy service and make it a

95
00:06:29,779 --> 00:06:33,680
wrapper around your old code so I have

96
00:06:33,680 --> 00:06:37,789
an example for that so this class is a

97
00:06:37,789 --> 00:06:40,610
very old legacy code there is no

98
00:06:40,610 --> 00:06:45,500
namespace there is nothing modern

99
00:06:45,500 --> 00:06:48,949
it's a singleton so it can be called

100
00:06:48,949 --> 00:06:51,949
like thousands of times everywhere in

101
00:06:51,949 --> 00:06:54,860
your code base so if you want to update

102
00:06:54,860 --> 00:06:58,819
- move it - move it move the usage of

103
00:06:58,819 --> 00:07:02,210
this thing to another another one you're

104
00:07:02,210 --> 00:07:04,099
doomed because you will have to change

105
00:07:04,099 --> 00:07:09,229
everywhere so one when good practice to

106
00:07:09,229 --> 00:07:11,509
start a migration is to create a service

107
00:07:11,509 --> 00:07:14,750
just wrapping this whole thing so it

108
00:07:14,750 --> 00:07:17,240
will me it will be more easy to replace

109
00:07:17,240 --> 00:07:20,469
it's over the time and smoothly just

110
00:07:20,469 --> 00:07:23,150
yeah you don't have to replace off all

111
00:07:23,150 --> 00:07:25,950
cores in one time

112
00:07:25,950 --> 00:07:31,080
then for the concepts with the services

113
00:07:31,080 --> 00:07:33,930
so services are agnostic agnostic pieces

114
00:07:33,930 --> 00:07:37,170
of code one service should do only what

115
00:07:37,170 --> 00:07:39,030
he has to do and hundred only the

116
00:07:39,030 --> 00:07:43,160
concept the context he has to hunt to

117
00:07:43,160 --> 00:07:48,150
carry only to perform the action nothing

118
00:07:48,150 --> 00:07:48,900
more nothing less

119
00:07:48,900 --> 00:07:54,210
so all dependencies have to be injected

120
00:07:54,210 --> 00:07:56,400
in your service so it will be very easy

121
00:07:56,400 --> 00:07:59,820
to test because it's just an i/o input

122
00:07:59,820 --> 00:08:02,220
output so you can do a functional

123
00:08:02,220 --> 00:08:05,090
testing on a service very easily and

124
00:08:05,090 --> 00:08:07,470
composability play Lego in your

125
00:08:07,470 --> 00:08:10,050
application so here for instance I have

126
00:08:10,050 --> 00:08:13,500
a database service which is a database

127
00:08:13,500 --> 00:08:15,870
abstraction layer maybe and caching

128
00:08:15,870 --> 00:08:18,810
service and this one's authentication

129
00:08:18,810 --> 00:08:20,730
service I will inject the database and

130
00:08:20,730 --> 00:08:22,620
the caching and the logger service in it

131
00:08:22,620 --> 00:08:25,020
and just play with all the small pieces

132
00:08:25,020 --> 00:08:28,520
of code I have in my framework so that's

133
00:08:28,520 --> 00:08:33,479
how small agnostic services are

134
00:08:33,479 --> 00:08:35,729
implemented and dedicated to some

135
00:08:35,729 --> 00:08:41,510
specific tasks now to implement these

136
00:08:41,510 --> 00:08:44,850
new small services we will have a look

137
00:08:44,850 --> 00:08:48,210
at some workflow and some best practices

138
00:08:48,210 --> 00:08:51,830
you can put in place in your daily work

139
00:08:51,830 --> 00:08:56,670
so we'll have word about different types

140
00:08:56,670 --> 00:09:02,130
of refactoring refactoring I do we I

141
00:09:02,130 --> 00:09:08,250
think we all do it every day one one

142
00:09:08,250 --> 00:09:11,160
pattern that I like I enjoy a lot is TDD

143
00:09:11,160 --> 00:09:14,490
so we'll see how to do it and we will

144
00:09:14,490 --> 00:09:17,130
make a difference between some different

145
00:09:17,130 --> 00:09:19,050
refactoring tasks which are called

146
00:09:19,050 --> 00:09:21,110
optimistic refactoring and large-scale

147
00:09:21,110 --> 00:09:25,320
refactoring so what is refactoring so

148
00:09:25,320 --> 00:09:29,400
Martin for essays it's a change made to

149
00:09:29,400 --> 00:09:33,540
internal structure of your project it

150
00:09:33,540 --> 00:09:35,940
will make it easier to maintain and to

151
00:09:35,940 --> 00:09:38,160
understand but it will not change its

152
00:09:38,160 --> 00:09:39,390
behavior and that's

153
00:09:39,390 --> 00:09:41,100
what's very important in refactoring

154
00:09:41,100 --> 00:09:43,890
don't do two things at a time don't

155
00:09:43,890 --> 00:09:45,480
develop a feature and do a refactoring

156
00:09:45,480 --> 00:09:49,620
at the same time you will get into a big

157
00:09:49,620 --> 00:09:50,670
trouble if you do it

158
00:09:50,670 --> 00:09:56,420
that's why Martin for again says you can

159
00:09:56,420 --> 00:10:00,660
see it as two huts when you work on a

160
00:10:00,660 --> 00:10:04,380
refactoring task you have like helmet on

161
00:10:04,380 --> 00:10:09,450
your head and when you rock on feature

162
00:10:09,450 --> 00:10:11,640
implementation you will have like a

163
00:10:11,640 --> 00:10:15,930
sombrero for instance and principle is

164
00:10:15,930 --> 00:10:18,780
never wear two hats at the same time if

165
00:10:18,780 --> 00:10:21,150
you work on a refactoring task work only

166
00:10:21,150 --> 00:10:22,920
on the refactoring task and at the end

167
00:10:22,920 --> 00:10:27,360
you switch your hat and you just go back

168
00:10:27,360 --> 00:10:31,200
to implementation of features so that's

169
00:10:31,200 --> 00:10:35,940
how we do it using TDD for instance TDD

170
00:10:35,940 --> 00:10:41,070
is a very nice way to code and to

171
00:10:41,070 --> 00:10:42,900
produce something which will be

172
00:10:42,900 --> 00:10:46,920
maintainable and without regressions so

173
00:10:46,920 --> 00:10:49,740
first thing you write tests you write

174
00:10:49,740 --> 00:10:52,700
tests and you define what are the needs

175
00:10:52,700 --> 00:10:55,830
targets of implementation of your new

176
00:10:55,830 --> 00:10:59,070
service just using assertions failing

177
00:10:59,070 --> 00:11:00,660
assertions so all your tests will be

178
00:11:00,660 --> 00:11:03,600
read but you will foresee every possible

179
00:11:03,600 --> 00:11:06,260
scenario of usage of your new service

180
00:11:06,260 --> 00:11:10,140
then you make test pass you make test

181
00:11:10,140 --> 00:11:12,150
pass and you don't focus about the

182
00:11:12,150 --> 00:11:15,120
design of your code you just get the

183
00:11:15,120 --> 00:11:18,390
work done to the end that development of

184
00:11:18,390 --> 00:11:21,360
the feature so it's the sombrero and

185
00:11:21,360 --> 00:11:25,890
after that you can focus on the design

186
00:11:25,890 --> 00:11:26,970
of your code

187
00:11:26,970 --> 00:11:31,830
make it nice make it easy to read make

188
00:11:31,830 --> 00:11:36,270
it commented and yeah with every best

189
00:11:36,270 --> 00:11:39,360
practices but it would be very easy to

190
00:11:39,360 --> 00:11:41,130
do the refactoring as all your health

191
00:11:41,130 --> 00:11:42,990
will already be green so you will not

192
00:11:42,990 --> 00:11:45,900
break anything you're covered if you

193
00:11:45,900 --> 00:11:48,690
foresee all the possible scenario during

194
00:11:48,690 --> 00:11:50,940
the writing of the assertions the first

195
00:11:50,940 --> 00:11:52,220
step

196
00:11:52,220 --> 00:11:59,490
so that's a very good practice then we

197
00:11:59,490 --> 00:12:02,640
have what is called optimistic

198
00:12:02,640 --> 00:12:05,310
refactoring I don't like it I don't do

199
00:12:05,310 --> 00:12:09,780
it but it exists and maybe it will be a

200
00:12:09,780 --> 00:12:12,690
very good tool for you because yeah

201
00:12:12,690 --> 00:12:15,360
there is no silver bullet so we have a

202
00:12:15,360 --> 00:12:17,280
lot of different patterns of different

203
00:12:17,280 --> 00:12:21,420
tools every application is different for

204
00:12:21,420 --> 00:12:23,700
another so some tools are may be very

205
00:12:23,700 --> 00:12:26,760
good for you and not for me so it's

206
00:12:26,760 --> 00:12:28,760
based on the boys good rule which says

207
00:12:28,760 --> 00:12:31,350
always leave the code in a better stage

208
00:12:31,350 --> 00:12:32,880
that you find it when you start working

209
00:12:32,880 --> 00:12:37,950
on it and it's cleaning up code as we

210
00:12:37,950 --> 00:12:40,050
walk in it so you implement a new

211
00:12:40,050 --> 00:12:42,780
feature and at the same time you do

212
00:12:42,780 --> 00:12:45,330
small refactoring tasks that's why I

213
00:12:45,330 --> 00:12:48,050
don't like it I'm prefer to split but

214
00:12:48,050 --> 00:12:49,860
yeah if you have a lot of

215
00:12:49,860 --> 00:12:52,730
self-discipline you can do it

216
00:12:52,730 --> 00:12:55,080
comprehension refactoring is exactly the

217
00:12:55,080 --> 00:12:57,470
same thing but it's not the same trigger

218
00:12:57,470 --> 00:13:02,670
it's okay you see a big class of like

219
00:13:02,670 --> 00:13:05,190
method of hundreds of lines of code and

220
00:13:05,190 --> 00:13:09,060
you make you spend like two hours to

221
00:13:09,060 --> 00:13:11,100
just make the map in your head and

222
00:13:11,100 --> 00:13:12,690
understand how it works get the full

223
00:13:12,690 --> 00:13:15,900
picture of the thing and if you had to

224
00:13:15,900 --> 00:13:19,290
do this monitor work just put the result

225
00:13:19,290 --> 00:13:21,750
of this monitor work in the code so the

226
00:13:21,750 --> 00:13:24,690
next guy which will work on this thing

227
00:13:24,690 --> 00:13:27,660
will not have to spend two hours to make

228
00:13:27,660 --> 00:13:30,870
the same understanding process as you

229
00:13:30,870 --> 00:13:33,890
did he will just have to reread your

230
00:13:33,890 --> 00:13:35,910
comprehension that you put in the code

231
00:13:35,910 --> 00:13:37,980
using I don't know comments refactoring

232
00:13:37,980 --> 00:13:40,800
like split into small methods within a

233
00:13:40,800 --> 00:13:45,480
more logical way and yeah that here's

234
00:13:45,480 --> 00:13:48,600
the only refactoring task is move your

235
00:13:48,600 --> 00:13:50,760
comprehension into the code it can just

236
00:13:50,760 --> 00:13:53,430
be write comments it can be splitted can

237
00:13:53,430 --> 00:13:56,520
be I don't know use inject dependency

238
00:13:56,520 --> 00:13:57,750
ISM yeah

239
00:13:57,750 --> 00:14:00,120
every good practice

240
00:14:00,120 --> 00:14:02,939
we want so objective factor optimistic

241
00:14:02,939 --> 00:14:05,249
refactoring is these two kinds of

242
00:14:05,249 --> 00:14:06,569
refactoring

243
00:14:06,569 --> 00:14:09,540
yeah refactor why while you work on

244
00:14:09,540 --> 00:14:11,459
implementing new feature it's a good

245
00:14:11,459 --> 00:14:14,519
move if it's a very simple fix and it

246
00:14:14,519 --> 00:14:17,490
way and if it's will make easier to

247
00:14:17,490 --> 00:14:19,129
implement the feature you're working on

248
00:14:19,129 --> 00:14:22,410
but it's better to do it in a stable

249
00:14:22,410 --> 00:14:26,279
code base and if it requires less than

250
00:14:26,279 --> 00:14:29,660
values that sounds good to you a

251
00:14:29,660 --> 00:14:31,889
percentage of the time to develop the

252
00:14:31,889 --> 00:14:34,589
feature like if you spent less than 5%

253
00:14:34,589 --> 00:14:36,720
of your time on this more refactoring

254
00:14:36,720 --> 00:14:38,339
tasks may be for you which worth to do

255
00:14:38,339 --> 00:14:41,790
it if it's half of the time to refactor

256
00:14:41,790 --> 00:14:45,149
maybe you have to split and yeah never

257
00:14:45,149 --> 00:14:48,300
wear two hats at the same time and it's

258
00:14:48,300 --> 00:14:50,550
you know you must have a lot of

259
00:14:50,550 --> 00:14:53,309
self-discipline to do that and maybe I

260
00:14:53,309 --> 00:14:55,699
can recommend you if you want to try to

261
00:14:55,699 --> 00:15:00,209
buy some hats and yeah just do it with

262
00:15:00,209 --> 00:15:04,379
real hat then we have preparatory

263
00:15:04,379 --> 00:15:07,529
refactoring I prefer this one as

264
00:15:07,529 --> 00:15:10,889
optimistic refactoring so you refactor

265
00:15:10,889 --> 00:15:12,480
code based before adding a new

266
00:15:12,480 --> 00:15:15,959
functionality so you say okay I have a

267
00:15:15,959 --> 00:15:17,730
new feature to implement on this part of

268
00:15:17,730 --> 00:15:19,740
the code and I know it's really shitty I

269
00:15:19,740 --> 00:15:24,540
know it's so you have to force it to

270
00:15:24,540 --> 00:15:28,350
estimate how much time it will take to

271
00:15:28,350 --> 00:15:32,069
refactor just parts which will be useful

272
00:15:32,069 --> 00:15:34,529
to implement this feature plus the

273
00:15:34,529 --> 00:15:36,959
implementation on the refactoring we

274
00:15:36,959 --> 00:15:40,050
factor out codes and if it takes less

275
00:15:40,050 --> 00:15:43,050
than implementation of the feature on

276
00:15:43,050 --> 00:15:47,550
the shitty code yes it's a good move if

277
00:15:47,550 --> 00:15:50,670
it takes a lot of time maybe you have to

278
00:15:50,670 --> 00:15:55,949
split right compatibility tests I will

279
00:15:55,949 --> 00:15:58,589
explain after that compatibility tests

280
00:15:58,589 --> 00:16:03,750
and do the refactoring and dedicated

281
00:16:03,750 --> 00:16:07,410
branch put it in projection just check

282
00:16:07,410 --> 00:16:10,939
you don't have regression and starts the

283
00:16:10,939 --> 00:16:15,000
development of the new feature and then

284
00:16:15,000 --> 00:16:19,230
we have last refactoring our large-scale

285
00:16:19,230 --> 00:16:23,189
refactoring so you have to fix large

286
00:16:23,189 --> 00:16:26,490
area and problematic codes usually it

287
00:16:26,490 --> 00:16:30,680
happens in every companion every project

288
00:16:30,680 --> 00:16:34,740
it's a good practice to do it like twice

289
00:16:34,740 --> 00:16:37,379
a year once a year twice a year every

290
00:16:37,379 --> 00:16:39,420
three months it depends on your workflow

291
00:16:39,420 --> 00:16:42,930
and the more you will work with quality

292
00:16:42,930 --> 00:16:46,040
approach and what I mean by that is used

293
00:16:46,040 --> 00:16:49,259
in optical refactoring TDD or planned

294
00:16:49,259 --> 00:16:54,420
refactoring in your daily workflow then

295
00:16:54,420 --> 00:16:56,550
large-scale refactoring should happen

296
00:16:56,550 --> 00:17:02,310
less and less and if you have as many

297
00:17:02,310 --> 00:17:07,260
codes to refactor in each plans

298
00:17:07,260 --> 00:17:09,449
refactoring it means you will really

299
00:17:09,449 --> 00:17:12,240
have to put in place sum it up

300
00:17:12,240 --> 00:17:14,369
refactoring or plan refactoring in your

301
00:17:14,369 --> 00:17:19,230
workflow just because you don't do yeah

302
00:17:19,230 --> 00:17:22,369
it's you have to do more refactoring and

303
00:17:22,369 --> 00:17:28,309
you have also when you want to replace a

304
00:17:28,309 --> 00:17:32,190
big part of your legacy framework like

305
00:17:32,190 --> 00:17:34,860
okay I want to replace this old module

306
00:17:34,860 --> 00:17:41,159
by vandal I want to move this from an

307
00:17:41,159 --> 00:17:44,309
API to another one and that's a

308
00:17:44,309 --> 00:17:47,490
long-term task and I recommend for that

309
00:17:47,490 --> 00:17:49,860
to use a branch by abstraction to reduce

310
00:17:49,860 --> 00:17:54,780
the risk so do people know about branch

311
00:17:54,780 --> 00:17:59,220
by abstraction no can explain quickly

312
00:17:59,220 --> 00:18:01,450
you want

313
00:18:01,450 --> 00:18:07,390
okay so you start by implementing an

314
00:18:07,390 --> 00:18:08,770
abstraction layer on top of your

315
00:18:08,770 --> 00:18:12,910
functionality and usually you have one

316
00:18:12,910 --> 00:18:14,620
functionality and you have many clients

317
00:18:14,620 --> 00:18:17,380
which are modules of your codes using

318
00:18:17,380 --> 00:18:19,990
this functionality then you implement an

319
00:18:19,990 --> 00:18:22,540
abstraction layer on top of your module

320
00:18:22,540 --> 00:18:25,660
and then switch the course to you

321
00:18:25,660 --> 00:18:28,720
abstraction layer for all the clients in

322
00:18:28,720 --> 00:18:30,870
your other parts of your applications

323
00:18:30,870 --> 00:18:35,080
and then you develop the new system and

324
00:18:35,080 --> 00:18:37,510
you put it on the same abstraction layer

325
00:18:37,510 --> 00:18:40,600
using compatibility tests just to say

326
00:18:40,600 --> 00:18:43,540
okay we it will behave in the same way

327
00:18:43,540 --> 00:18:46,030
maybe you will need to put an adapter on

328
00:18:46,030 --> 00:18:48,220
top of your abstraction layer but it

329
00:18:48,220 --> 00:18:51,970
will work at the end and then you don't

330
00:18:51,970 --> 00:18:57,910
have to change all the wiring you just

331
00:18:57,910 --> 00:19:01,720
have to remove the old system and the

332
00:19:01,720 --> 00:19:04,210
clients will still use your abstraction

333
00:19:04,210 --> 00:19:06,940
layer and you can let it because maybe

334
00:19:06,940 --> 00:19:09,580
one day we will have to move again I

335
00:19:09,580 --> 00:19:10,210
don't know

336
00:19:10,210 --> 00:19:12,850
so abstraction is never too much

337
00:19:12,850 --> 00:19:17,220
obstruction and then best practices to

338
00:19:17,220 --> 00:19:20,010
implement shown you're agnostic services

339
00:19:20,010 --> 00:19:24,370
so we will have a word about decoupling

340
00:19:24,370 --> 00:19:26,980
about solid test automation and

341
00:19:26,980 --> 00:19:30,040
monitoring which are good patterns good

342
00:19:30,040 --> 00:19:35,470
practice good tools so decoupling yet

343
00:19:35,470 --> 00:19:38,560
try to apply the law of Demeter so law

344
00:19:38,560 --> 00:19:41,650
of Demeter is don't talk to strangers or

345
00:19:41,650 --> 00:19:43,830
just talk to your cross friends I will

346
00:19:43,830 --> 00:19:48,930
show an example solid principles let's

347
00:19:48,930 --> 00:19:53,490
you know solid it's five patterns just

348
00:19:53,490 --> 00:19:56,200
very useful to break break cooking in

349
00:19:56,200 --> 00:19:59,260
code it's a single responsibility open

350
00:19:59,260 --> 00:20:01,380
closed principle risk of substitution

351
00:20:01,380 --> 00:20:03,760
interface segregation and dependency

352
00:20:03,760 --> 00:20:06,130
inversion so Google reads have a look

353
00:20:06,130 --> 00:20:10,030
it's very yeah do it use it

354
00:20:10,030 --> 00:20:14,310
and use dependency injection too much

355
00:20:14,310 --> 00:20:17,170
mock easy video services and write unit

356
00:20:17,170 --> 00:20:21,150
tests so yeah use dependency injection

357
00:20:21,150 --> 00:20:25,320
you can also use events to the Cooper

358
00:20:25,320 --> 00:20:29,140
like Navin dispatcher I don't like it

359
00:20:29,140 --> 00:20:33,460
very much but it's a good tool or even

360
00:20:33,460 --> 00:20:37,330
an event bus which is like as introduced

361
00:20:37,330 --> 00:20:40,270
tasks centralized somewhere and that's a

362
00:20:40,270 --> 00:20:41,920
very good thing because you can plug a

363
00:20:41,920 --> 00:20:43,990
lot of things on your event bus like

364
00:20:43,990 --> 00:20:48,850
monitoring statistics I recommend if you

365
00:20:48,850 --> 00:20:52,770
have if you want to go to micro service

366
00:20:52,770 --> 00:20:55,570
environments and even bus is a very good

367
00:20:55,570 --> 00:21:01,360
tool so yeah for the law of Demeter here

368
00:21:01,360 --> 00:21:04,060
you break the law because you talk to

369
00:21:04,060 --> 00:21:07,800
stranger who don't talk only to your

370
00:21:07,800 --> 00:21:10,990
friends like direct friends like you

371
00:21:10,990 --> 00:21:14,410
have a change tire method on the car

372
00:21:14,410 --> 00:21:17,590
with a new tire so you make car get will

373
00:21:17,590 --> 00:21:19,690
delete tire this breaks the law of

374
00:21:19,690 --> 00:21:22,030
Demeter because you would take an object

375
00:21:22,030 --> 00:21:25,260
as a parameter and call a method on

376
00:21:25,260 --> 00:21:27,970
dependency of these objects so you can

377
00:21:27,970 --> 00:21:30,960
talk directly to these objects you can

378
00:21:30,960 --> 00:21:36,490
pass a winter park for instance wheel

379
00:21:36,490 --> 00:21:40,060
here and not a car so you will talk only

380
00:21:40,060 --> 00:21:46,210
to one level that's that's not mandatory

381
00:21:46,210 --> 00:21:50,800
but it had to reduce copy and that speak

382
00:21:50,800 --> 00:21:53,770
that's why I don't like even so much

383
00:21:53,770 --> 00:21:57,820
it's a few savants you have to be very

384
00:21:57,820 --> 00:22:00,880
strict about how you dispatch your

385
00:22:00,880 --> 00:22:04,180
events because if you're not you will

386
00:22:04,180 --> 00:22:06,550
lose visibility and it will end in that

387
00:22:06,550 --> 00:22:09,130
state and you will start to be in

388
00:22:09,130 --> 00:22:11,730
trouble for performance for

389
00:22:11,730 --> 00:22:13,110
comprehension

390
00:22:13,110 --> 00:22:16,000
you can obfuscate your code very easily

391
00:22:16,000 --> 00:22:20,170
with events if you don't have a very

392
00:22:20,170 --> 00:22:22,520
strict way to

393
00:22:22,520 --> 00:22:29,640
dispatch so no automatic testing all new

394
00:22:29,640 --> 00:22:31,679
analytic services must be covered by

395
00:22:31,679 --> 00:22:36,779
tests for me that's mandatory so unit

396
00:22:36,779 --> 00:22:37,679
testing

397
00:22:37,679 --> 00:22:43,110
it's just tests an algorithm its context

398
00:22:43,110 --> 00:22:45,299
agnostic so it should not interact with

399
00:22:45,299 --> 00:22:47,669
context no network no database no

400
00:22:47,669 --> 00:22:50,820
dependency so you that's why you have to

401
00:22:50,820 --> 00:22:55,669
use dependency injection to design your

402
00:22:55,669 --> 00:22:58,080
services because you can mock

403
00:22:58,080 --> 00:23:00,090
dependencies and write unit tests so

404
00:23:00,090 --> 00:23:02,340
that's a good practice you need test a

405
00:23:02,340 --> 00:23:05,340
real good unit test is very hard to

406
00:23:05,340 --> 00:23:07,980
write and you have to foresee all

407
00:23:07,980 --> 00:23:12,630
possible scenarios then you have

408
00:23:12,630 --> 00:23:15,510
integration and functional testing so ok

409
00:23:15,510 --> 00:23:17,700
unit testing you have a lot of small

410
00:23:17,700 --> 00:23:20,340
piece of codes you just test algorithm

411
00:23:20,340 --> 00:23:24,299
works integration testing you test that

412
00:23:24,299 --> 00:23:26,340
all these modules interacts well

413
00:23:26,340 --> 00:23:28,399
together

414
00:23:28,399 --> 00:23:32,340
and functional testing it's the same

415
00:23:32,340 --> 00:23:35,580
idea but from an end-to-end view like

416
00:23:35,580 --> 00:23:37,880
for instance you want to test the job

417
00:23:37,880 --> 00:23:41,370
you can you will not spawn text agnostic

418
00:23:41,370 --> 00:23:43,080
sure you can interact with database

419
00:23:43,080 --> 00:23:45,179
because it's a functional test so you

420
00:23:45,179 --> 00:23:47,100
can make a snapshot of your database for

421
00:23:47,100 --> 00:23:50,250
instance and in hydrates your database

422
00:23:50,250 --> 00:23:53,460
with fixtures then run your job and make

423
00:23:53,460 --> 00:23:55,710
some queries at the end just to say ok

424
00:23:55,710 --> 00:23:57,539
this action was done with that was done

425
00:23:57,539 --> 00:23:59,960
it was ER so you can interact with

426
00:23:59,960 --> 00:24:02,429
context in integration and functional

427
00:24:02,429 --> 00:24:06,210
testing so don't do only unit tests

428
00:24:06,210 --> 00:24:08,640
don't Lou only integration test you need

429
00:24:08,640 --> 00:24:12,870
both and that's a very nice example of

430
00:24:12,870 --> 00:24:15,659
unit testing okay but no integration

431
00:24:15,659 --> 00:24:18,809
tests because it opens and close so your

432
00:24:18,809 --> 00:24:21,539
basic algorithm is ok but interaction

433
00:24:21,539 --> 00:24:24,870
between some others doesn't work

434
00:24:24,870 --> 00:24:29,050
and you have also and user testing which

435
00:24:29,050 --> 00:24:32,740
is already called acceptance testing

436
00:24:32,740 --> 00:24:37,120
it's you access the application as you

437
00:24:37,120 --> 00:24:40,540
if you are end-user and then you test

438
00:24:40,540 --> 00:24:41,680
what's displayed

439
00:24:41,680 --> 00:24:44,410
that's typically in PHP you have tools

440
00:24:44,410 --> 00:24:50,160
like selenium to do that that's a very

441
00:24:50,160 --> 00:24:53,860
useful test and I recommend to use a

442
00:24:53,860 --> 00:24:56,590
description specification language like

443
00:24:56,590 --> 00:24:58,270
I don't know if you heard about bgg

444
00:24:58,270 --> 00:25:00,580
behavior driven development like use be

445
00:25:00,580 --> 00:25:02,680
hot or cookin bear or something so

446
00:25:02,680 --> 00:25:04,510
that's not the developer which we write

447
00:25:04,510 --> 00:25:06,460
the scenario of testing that the tester

448
00:25:06,460 --> 00:25:12,040
sexuai team and yeah that's so good

449
00:25:12,040 --> 00:25:17,620
practice for me and if we speak about

450
00:25:17,620 --> 00:25:19,540
test we have to speak about code

451
00:25:19,540 --> 00:25:22,120
coverage never make a target of code

452
00:25:22,120 --> 00:25:24,010
coverage it will only make your code

453
00:25:24,010 --> 00:25:27,640
base worse never do it because it has no

454
00:25:27,640 --> 00:25:30,600
correlation with code quality I

455
00:25:30,600 --> 00:25:33,310
recommend you to go on a matching photo

456
00:25:33,310 --> 00:25:36,760
blog and read an article about assertion

457
00:25:36,760 --> 00:25:40,450
free testing which is a very real story

458
00:25:40,450 --> 00:25:45,040
of company covering delivering code

459
00:25:45,040 --> 00:25:47,470
covering 100 percent worth with new

460
00:25:47,470 --> 00:25:53,260
assertions so very good idea so don't

461
00:25:53,260 --> 00:25:55,900
make it a target but it's it's a good

462
00:25:55,900 --> 00:26:00,580
tool it's yeah it must not be a target

463
00:26:00,580 --> 00:26:03,760
but it's still useful focus on the risky

464
00:26:03,760 --> 00:26:07,000
code you need to have 100% coverage on

465
00:26:07,000 --> 00:26:08,890
the risky code and for me risky code is

466
00:26:08,890 --> 00:26:11,410
something which can delete data from

467
00:26:11,410 --> 00:26:13,940
user and to

468
00:26:13,940 --> 00:26:17,330
next section and coat exception but

469
00:26:17,330 --> 00:26:19,370
that's another patented design program

470
00:26:19,370 --> 00:26:21,500
or tricky algorithm think you don't

471
00:26:21,500 --> 00:26:23,660
understand very well because maybe it's

472
00:26:23,660 --> 00:26:26,240
all maybe it was by the implemented I

473
00:26:26,240 --> 00:26:29,090
don't know that's was a risky code and

474
00:26:29,090 --> 00:26:32,840
yeah put your test here first and yet

475
00:26:32,840 --> 00:26:36,440
ten percent coverage so if you cover ten

476
00:26:36,440 --> 00:26:39,800
percent of your risky codes with one

477
00:26:39,800 --> 00:26:42,010
hundred percent of possible scenarios

478
00:26:42,010 --> 00:26:46,220
your test will be much way more

479
00:26:46,220 --> 00:26:48,530
efficient than if you have 100 percent

480
00:26:48,530 --> 00:26:51,080
coverage for 10 percent of scenarios so

481
00:26:51,080 --> 00:26:54,830
yeah don't focus on coverage never and

482
00:26:54,830 --> 00:26:59,690
monitoring which is also yeah thing to

483
00:26:59,690 --> 00:27:02,780
have in your new services profiling

484
00:27:02,780 --> 00:27:05,920
minute and monitor ever were all time to

485
00:27:05,920 --> 00:27:09,320
notify bottlenecks give you as part of

486
00:27:09,320 --> 00:27:11,150
your application and what's very

487
00:27:11,150 --> 00:27:13,130
important for me in monitoring needs to

488
00:27:13,130 --> 00:27:15,140
make a distinction between IO and

489
00:27:15,140 --> 00:27:18,470
processing you don't monitor IO and

490
00:27:18,470 --> 00:27:21,800
processing in the same metrics that's

491
00:27:21,800 --> 00:27:24,140
not the same thing I know for me is

492
00:27:24,140 --> 00:27:26,090
something which is blocking for the PHP

493
00:27:26,090 --> 00:27:29,690
thread PHP PHP thread cause yeah PHP is

494
00:27:29,690 --> 00:27:32,330
illustrated so like database code for

495
00:27:32,330 --> 00:27:35,090
instance it's an i/o for PHP you go out

496
00:27:35,090 --> 00:27:36,830
of the cage PBS turn machine you wait

497
00:27:36,830 --> 00:27:39,410
for something and then the script go

498
00:27:39,410 --> 00:27:43,880
back to his work so you can use a lot of

499
00:27:43,880 --> 00:27:46,850
tools to monitor profile now excess

500
00:27:46,850 --> 00:27:48,770
prefer grant for the memory check is

501
00:27:48,770 --> 00:27:52,010
very efficient kimba windows pin bar

502
00:27:52,010 --> 00:27:54,220
here

503
00:27:54,659 --> 00:27:58,229
I knew it okay pinbar is an amazing

504
00:27:58,229 --> 00:28:01,549
monitoring - it's really it's crazy

505
00:28:01,549 --> 00:28:04,499
really you can monitor your production

506
00:28:04,499 --> 00:28:08,059
in real time without losing performance

507
00:28:08,059 --> 00:28:12,840
so have a look at it I wrote an article

508
00:28:12,840 --> 00:28:14,669
about that and there is a link at the

509
00:28:14,669 --> 00:28:19,320
end of the thing of the speech so no we

510
00:28:19,320 --> 00:28:21,570
will have a look at tools that was about

511
00:28:21,570 --> 00:28:25,919
best practices for your new services no

512
00:28:25,919 --> 00:28:28,799
we'll have a look at tools to make the

513
00:28:28,799 --> 00:28:31,379
migration to move from your old system

514
00:28:31,379 --> 00:28:32,309
to the new one

515
00:28:32,309 --> 00:28:35,759
so compatibility test is a tool I like

516
00:28:35,759 --> 00:28:40,679
very much you have to get some

517
00:28:40,679 --> 00:28:43,649
indicators just to see how fast you go

518
00:28:43,649 --> 00:28:45,979
and it will make your manager happy and

519
00:28:45,979 --> 00:28:50,389
you have to use monitoring just to see

520
00:28:50,389 --> 00:28:55,580
if you yeah if you don't have any

521
00:28:55,580 --> 00:28:59,580
performance regression you will have

522
00:28:59,580 --> 00:29:01,409
some performance regression during a

523
00:29:01,409 --> 00:29:03,149
migration because it's normal you have

524
00:29:03,149 --> 00:29:07,559
two systems cohabiting and they don't

525
00:29:07,559 --> 00:29:09,899
work in the same way like usually legacy

526
00:29:09,899 --> 00:29:14,849
code it mainly works with IDs as new

527
00:29:14,849 --> 00:29:17,999
design works with objects so you have

528
00:29:17,999 --> 00:29:19,979
two things not working in the same way

529
00:29:19,979 --> 00:29:22,979
in the same context so you will have a

530
00:29:22,979 --> 00:29:26,789
bit of performance issues during the

531
00:29:26,789 --> 00:29:29,759
migration but monitor it and you just

532
00:29:29,759 --> 00:29:33,570
have to define your own levels okay for

533
00:29:33,570 --> 00:29:36,479
me 10% of Russ is acceptable no maybe

534
00:29:36,479 --> 00:29:39,989
not I don't know it depends you how you

535
00:29:39,989 --> 00:29:42,749
want to work so what's a compatibility

536
00:29:42,749 --> 00:29:45,419
test a compatibility test is just to

537
00:29:45,419 --> 00:29:46,889
ensure you don't break the compatibility

538
00:29:46,889 --> 00:29:50,279
from the old system to the new one so

539
00:29:50,279 --> 00:29:54,059
it's a short-lived test you just use the

540
00:29:54,059 --> 00:29:56,070
old system use a new system you assert

541
00:29:56,070 --> 00:29:57,840
it return the same thing from the same

542
00:29:57,840 --> 00:30:01,169
context and when you kill the old system

543
00:30:01,169 --> 00:30:02,940
you remove the compatibility test that's

544
00:30:02,940 --> 00:30:06,690
just for the switch so I have an example

545
00:30:06,690 --> 00:30:08,750
here

546
00:30:08,750 --> 00:30:11,429
that's an old legacy code at the same

547
00:30:11,429 --> 00:30:17,700
services before we use IDs here I have

548
00:30:17,700 --> 00:30:21,419
the new thing which use objects that's a

549
00:30:21,419 --> 00:30:24,660
very easy compatibility test to write

550
00:30:24,660 --> 00:30:27,090
because the two things do the same thing

551
00:30:27,090 --> 00:30:29,580
just loading objects so I can easily

552
00:30:29,580 --> 00:30:34,350
assert its object equals maybe you will

553
00:30:34,350 --> 00:30:38,100
have to use UID it's hard to ascertain

554
00:30:38,100 --> 00:30:40,559
true great I also will have to write L

555
00:30:40,559 --> 00:30:44,580
per new test but yeah compatibility test

556
00:30:44,580 --> 00:30:46,710
can be hard to write you don't have to

557
00:30:46,710 --> 00:30:51,030
make it nice like yeah for one time you

558
00:30:51,030 --> 00:30:53,160
can write dirty code to do it yeah

559
00:30:53,160 --> 00:30:57,929
that's enjoyable yeah that's that

560
00:30:57,929 --> 00:31:03,179
production server and crap index it's an

561
00:31:03,179 --> 00:31:05,460
indicator you can use crap index is

562
00:31:05,460 --> 00:31:08,100
trans risk analysis and prediction index

563
00:31:08,100 --> 00:31:11,340
it's based on coverage and complexity so

564
00:31:11,340 --> 00:31:17,220
it's yeah it's lame linear with complex

565
00:31:17,220 --> 00:31:21,720
cyclomatic complexity so if you take a

566
00:31:21,720 --> 00:31:25,470
method if it has a high crap index it

567
00:31:25,470 --> 00:31:27,900
means it's a really big risk for your

568
00:31:27,900 --> 00:31:30,179
projects so low coverage and high

569
00:31:30,179 --> 00:31:34,650
complexity and in PHP you need for

570
00:31:34,650 --> 00:31:38,070
instance if you run the coverage tool

571
00:31:38,070 --> 00:31:40,590
you have reports about crap index of

572
00:31:40,590 --> 00:31:43,350
every methods every class everything and

573
00:31:43,350 --> 00:31:48,510
you can just migrate and see at what

574
00:31:48,510 --> 00:31:52,049
speed it decrease and that's a pretty

575
00:31:52,049 --> 00:31:57,290
good tool to follow the migration and

576
00:31:57,290 --> 00:32:00,000
it's easy to indentify parts of your

577
00:32:00,000 --> 00:32:02,250
code with higher risk so the parts you

578
00:32:02,250 --> 00:32:06,240
have to migrate first may be and

579
00:32:06,240 --> 00:32:08,100
progression metrics keep it very simple

580
00:32:08,100 --> 00:32:10,290
it's useless it's just to make manager

581
00:32:10,290 --> 00:32:14,160
happy like non-technical manager so you

582
00:32:14,160 --> 00:32:17,960
say a percentage of your migration

583
00:32:17,960 --> 00:32:20,149
give them dummy data maybe we don't care

584
00:32:20,149 --> 00:32:24,799
it's it's really useless but you have I

585
00:32:24,799 --> 00:32:29,799
mean a migration is a companion decision

586
00:32:29,799 --> 00:32:33,499
so everyone has to be a super Guri about

587
00:32:33,499 --> 00:32:38,539
the process so you have to sell the idea

588
00:32:38,539 --> 00:32:41,090
of the migration because if you have

589
00:32:41,090 --> 00:32:43,220
some manager which is non-technical he

590
00:32:43,220 --> 00:32:45,559
will not see the benefit of the

591
00:32:45,559 --> 00:32:47,749
migration because for you your

592
00:32:47,749 --> 00:32:50,360
developers you know that performance is

593
00:32:50,360 --> 00:32:55,519
a feature and he don't so yeah

594
00:32:55,519 --> 00:33:00,350
sell your ID migration it's not easy to

595
00:33:00,350 --> 00:33:02,869
make it accepts pain and technical

596
00:33:02,869 --> 00:33:05,600
managers so yeah insist on it and maybe

597
00:33:05,600 --> 00:33:10,369
give some fake data and monitoring is

598
00:33:10,369 --> 00:33:13,190
very important just to track you don't

599
00:33:13,190 --> 00:33:17,509
make regressions in performance usually

600
00:33:17,509 --> 00:33:19,490
I use animal detection and reacting to

601
00:33:19,490 --> 00:33:21,619
spot regression so when I replace

602
00:33:21,619 --> 00:33:26,210
something I have some eyelids just in

603
00:33:26,210 --> 00:33:28,340
slack in mail you know what you mean

604
00:33:28,340 --> 00:33:29,990
what you use what you need HipChat I

605
00:33:29,990 --> 00:33:33,679
don't know that says oh it's 10% slower

606
00:33:33,679 --> 00:33:36,529
than before the release that's not

607
00:33:36,529 --> 00:33:41,690
normal and then put all this together

608
00:33:41,690 --> 00:33:46,509
and we will try to kill the monolith so

609
00:33:46,509 --> 00:33:49,009
how to spot bad code that it's very easy

610
00:33:49,009 --> 00:33:52,100
to migrate usually it's when

611
00:33:52,100 --> 00:33:53,960
compatibility test is very easy to write

612
00:33:53,960 --> 00:33:56,179
so it's like a note system in a new

613
00:33:56,179 --> 00:33:58,039
system doing almost the same thing so

614
00:33:58,039 --> 00:34:03,320
it's very easy to migrate and when it's

615
00:34:03,320 --> 00:34:06,289
not used in too many places because it

616
00:34:06,289 --> 00:34:09,319
will be very hard to deploy with

617
00:34:09,319 --> 00:34:11,599
conflicts if you have to change code

618
00:34:11,599 --> 00:34:13,940
everywhere so we will see something to

619
00:34:13,940 --> 00:34:17,000
avoid that and yeah

620
00:34:17,000 --> 00:34:18,559
when compatibility tests are fast to

621
00:34:18,559 --> 00:34:22,339
implement its it will be an easy task so

622
00:34:22,339 --> 00:34:24,409
write your new service with all

623
00:34:24,409 --> 00:34:26,690
dependency injected so you can unit test

624
00:34:26,690 --> 00:34:27,840
it and

625
00:34:27,840 --> 00:34:30,600
so on we write the compatibility test

626
00:34:30,600 --> 00:34:32,550
you replace all code you say about your

627
00:34:32,550 --> 00:34:36,960
brand-new service and for each method

628
00:34:36,960 --> 00:34:39,659
you migrate your global complexity will

629
00:34:39,659 --> 00:34:41,610
decrease because you use single reports

630
00:34:41,610 --> 00:34:44,429
responsibility no and you cover the

631
00:34:44,429 --> 00:34:46,020
coverage with increased so the crap

632
00:34:46,020 --> 00:34:48,989
index will naturally go down for after

633
00:34:48,989 --> 00:34:53,850
every method migrating know we have some

634
00:34:53,850 --> 00:34:57,300
tasks why it's more complicated so for

635
00:34:57,300 --> 00:34:59,730
instance you want to migrate something

636
00:34:59,730 --> 00:35:02,340
that it's called everywhere in static

637
00:35:02,340 --> 00:35:06,900
statically so it's coupled every with

638
00:35:06,900 --> 00:35:09,060
every path of your code like you have I

639
00:35:09,060 --> 00:35:12,240
don't know hundreds of files calling a

640
00:35:12,240 --> 00:35:14,760
static method that you want to remove

641
00:35:14,760 --> 00:35:18,620
you will have to change everywhere so

642
00:35:18,620 --> 00:35:23,970
what I do here to make deployment more

643
00:35:23,970 --> 00:35:27,060
easy I implement the agnostic service I

644
00:35:27,060 --> 00:35:29,430
wipe the compatibility test and then I

645
00:35:29,430 --> 00:35:32,280
inject the new service in the old method

646
00:35:32,280 --> 00:35:37,040
I want to kill so I have an example here

647
00:35:37,040 --> 00:35:41,280
what I do I have my method to kill so

648
00:35:41,280 --> 00:35:45,750
that's legacy code and in it I just use

649
00:35:45,750 --> 00:35:48,780
the new service and as I have a

650
00:35:48,780 --> 00:35:51,210
compatibility test and have force in all

651
00:35:51,210 --> 00:35:54,570
possible scenarios I know I will not

652
00:35:54,570 --> 00:35:57,600
break anything so I can just replace

653
00:35:57,600 --> 00:36:00,540
smoothly like I've put a release with

654
00:36:00,540 --> 00:36:03,210
this in the code maybe it will not be

655
00:36:03,210 --> 00:36:05,930
used a new anywhere and then I just

656
00:36:05,930 --> 00:36:10,230
making other releases just replace the

657
00:36:10,230 --> 00:36:14,310
the course of the thing so I have a

658
00:36:14,310 --> 00:36:16,590
client like a part of your code base and

659
00:36:16,590 --> 00:36:19,020
I don't call this anymore I call

660
00:36:19,020 --> 00:36:22,140
directly this but when you will be done

661
00:36:22,140 --> 00:36:25,080
you can just remove this method and I

662
00:36:25,080 --> 00:36:28,250
also put some logs so I'm able to track

663
00:36:28,250 --> 00:36:33,990
what's using the legacy code and I use a

664
00:36:33,990 --> 00:36:36,420
dedicated monologue channel for that so

665
00:36:36,420 --> 00:36:40,800
I can easily detect okay from this

666
00:36:40,800 --> 00:36:44,130
part of the code I still use the legacy

667
00:36:44,130 --> 00:36:47,690
thing and that's not normal for me and

668
00:36:47,690 --> 00:36:51,570
we can do it exactly in the opposite way

669
00:36:51,570 --> 00:36:54,420
you can inject your old manager in your

670
00:36:54,420 --> 00:36:57,210
new service why

671
00:36:57,210 --> 00:37:00,570
maybe the method you're trying to kill

672
00:37:00,570 --> 00:37:03,630
has dependencies with all the method in

673
00:37:03,630 --> 00:37:09,810
your current service so that's why what

674
00:37:09,810 --> 00:37:15,270
I do here is okay that's my new service

675
00:37:15,270 --> 00:37:18,150
that's a repository it does one thing

676
00:37:18,150 --> 00:37:21,240
interaction with database so signal

677
00:37:21,240 --> 00:37:23,940
responsibility we're okay I injected for

678
00:37:23,940 --> 00:37:26,760
manager which was a it was a big legacy

679
00:37:26,760 --> 00:37:31,710
file which does almost everything and so

680
00:37:31,710 --> 00:37:35,250
if I have some methods that I moved that

681
00:37:35,250 --> 00:37:38,550
have dependencies to on other methods of

682
00:37:38,550 --> 00:37:40,830
the form manager I don't have to replace

683
00:37:40,830 --> 00:37:46,410
all in one deployment I can just remove

684
00:37:46,410 --> 00:37:49,410
it smoothly and the dependencies will be

685
00:37:49,410 --> 00:37:52,950
your next targets and when you have no

686
00:37:52,950 --> 00:37:54,660
dependency anymore you can remove the

687
00:37:54,660 --> 00:37:56,340
four manager from your new service and

688
00:37:56,340 --> 00:37:58,070
you're good to go

689
00:37:58,070 --> 00:38:01,920
so keeping keep in mind small steps

690
00:38:01,920 --> 00:38:04,740
small steps because you will have a lot

691
00:38:04,740 --> 00:38:07,140
of release to do in a migration and will

692
00:38:07,140 --> 00:38:10,470
have a lot of conflicts so yeah make it

693
00:38:10,470 --> 00:38:17,490
small but every step of every step

694
00:38:17,490 --> 00:38:20,400
should finish in a stable state that's

695
00:38:20,400 --> 00:38:23,700
very important totally make sense and

696
00:38:23,700 --> 00:38:25,760
all your new service have to be tested

697
00:38:25,760 --> 00:38:28,560
your code coverage don't make it target

698
00:38:28,560 --> 00:38:31,020
it will increase naturally and start

699
00:38:31,020 --> 00:38:33,240
where it hurts and that's very important

700
00:38:33,240 --> 00:38:37,470
also you know when you work on a legacy

701
00:38:37,470 --> 00:38:40,440
application what's the worst part okay

702
00:38:40,440 --> 00:38:43,080
that will be very difficult to do do it

703
00:38:43,080 --> 00:38:47,360
first because it will just

704
00:38:47,360 --> 00:38:52,010
yeah it will make the team confident in

705
00:38:52,010 --> 00:38:54,920
the migration progress process they will

706
00:38:54,920 --> 00:38:59,780
say ok this guy has migrated this file

707
00:38:59,780 --> 00:39:01,850
this service which was the worst thing

708
00:39:01,850 --> 00:39:05,000
we had them with a lot of dependency

709
00:39:05,000 --> 00:39:07,160
everywhere so we can make return

710
00:39:07,160 --> 00:39:10,340
everything so start where it hurts maybe

711
00:39:10,340 --> 00:39:13,850
do some two of risks easy tasks first

712
00:39:13,850 --> 00:39:17,990
just to set up the process and just have

713
00:39:17,990 --> 00:39:20,900
a good plan and then start with a big

714
00:39:20,900 --> 00:39:24,530
one after that yeah it will be started

715
00:39:24,530 --> 00:39:26,240
and it will be clearing the mind of

716
00:39:26,240 --> 00:39:31,730
every developer of the team so no we can

717
00:39:31,730 --> 00:39:36,650
we have seen patterns of system oriented

718
00:39:36,650 --> 00:39:39,470
architecture applied to the architecture

719
00:39:39,470 --> 00:39:43,510
of your application but initially it was

720
00:39:43,510 --> 00:39:48,950
at an architectural level so it's not

721
00:39:48,950 --> 00:39:51,140
your service that is as a single

722
00:39:51,140 --> 00:39:52,730
responsibility but it's a micro

723
00:39:52,730 --> 00:39:54,530
application and that we have a lot of

724
00:39:54,530 --> 00:39:57,770
micro application talking together in an

725
00:39:57,770 --> 00:40:03,200
ecosystem it's small web services single

726
00:40:03,200 --> 00:40:05,750
responsibility easy to test so it will

727
00:40:05,750 --> 00:40:08,320
be end-user test through an API mostly

728
00:40:08,320 --> 00:40:10,730
you try to keep a consistent

729
00:40:10,730 --> 00:40:12,680
communication protocol in your question

730
00:40:12,680 --> 00:40:13,820
that's very important and that

731
00:40:13,820 --> 00:40:18,260
impossible to do so try as much as you

732
00:40:18,260 --> 00:40:21,950
can and you have to use API first

733
00:40:21,950 --> 00:40:23,900
architecture for every of your web

734
00:40:23,900 --> 00:40:28,060
services that's pretty straightforward

735
00:40:28,060 --> 00:40:30,700
and you can start within your framework

736
00:40:30,700 --> 00:40:36,050
so you you know have some agnostic

737
00:40:36,050 --> 00:40:39,590
services in your framework and this

738
00:40:39,590 --> 00:40:45,560
services you can just reimplemented into

739
00:40:45,560 --> 00:40:48,490
a small application which will be

740
00:40:48,490 --> 00:40:51,860
dedicated to perform the tasks and then

741
00:40:51,860 --> 00:40:53,540
your service will just become a wrapper

742
00:40:53,540 --> 00:40:56,570
that will call your new micro

743
00:40:56,570 --> 00:40:57,740
application

744
00:40:57,740 --> 00:41:00,140
maybe you don't need it but I will have

745
00:41:00,140 --> 00:41:04,430
examples just to explain it so that's a

746
00:41:04,430 --> 00:41:07,450
very good way to kill your fromage just

747
00:41:07,450 --> 00:41:11,060
thrashing some cold out in some agnostic

748
00:41:11,060 --> 00:41:14,030
services and yeah we will see how to

749
00:41:14,030 --> 00:41:14,720
KITT

750
00:41:14,720 --> 00:41:19,700
so that's your monolith that's a big

751
00:41:19,700 --> 00:41:23,060
monolithic application you have backends

752
00:41:23,060 --> 00:41:24,800
we don't care about the names that's

753
00:41:24,800 --> 00:41:28,280
just tools and you have a set of

754
00:41:28,280 --> 00:41:30,260
features implemented in your application

755
00:41:30,260 --> 00:41:33,470
and why is it bad it's you have copying

756
00:41:33,470 --> 00:41:37,250
everywhere and it's case at one rhythm

757
00:41:37,250 --> 00:41:39,619
which is the rhythm of your application

758
00:41:39,619 --> 00:41:44,900
in a global way and that's not that's

759
00:41:44,900 --> 00:41:46,670
not very optimized in the term of scale

760
00:41:46,670 --> 00:41:52,640
so intermediate states you take some of

761
00:41:52,640 --> 00:41:54,619
the services like for me the best

762
00:41:54,619 --> 00:41:57,650
example here will be the search because

763
00:41:57,650 --> 00:41:59,740
the search is resource consuming is

764
00:41:59,740 --> 00:42:04,700
usually some data consolidated from a

765
00:42:04,700 --> 00:42:07,580
storage to another one from different

766
00:42:07,580 --> 00:42:09,950
storage to a central elasticsearch or

767
00:42:09,950 --> 00:42:11,450
something you want to use for your

768
00:42:11,450 --> 00:42:15,140
search so you can very easily implement

769
00:42:15,140 --> 00:42:18,800
it into another application that will

770
00:42:18,800 --> 00:42:21,050
call through an API with your main

771
00:42:21,050 --> 00:42:25,420
application so your old search service

772
00:42:25,420 --> 00:42:30,589
you make an agnostic service in your

773
00:42:30,589 --> 00:42:32,990
application and then this service will

774
00:42:32,990 --> 00:42:36,320
become a wrapper to your new micro

775
00:42:36,320 --> 00:42:37,790
application here which released

776
00:42:37,790 --> 00:42:40,280
standalone and the only search and for

777
00:42:40,280 --> 00:42:43,849
search you can do it in go you can yeah

778
00:42:43,849 --> 00:42:46,550
use a multi-threaded language to do that

779
00:42:46,550 --> 00:42:50,240
use what you want to it in PHP if you

780
00:42:50,240 --> 00:42:55,010
want but the search never scales at the

781
00:42:55,010 --> 00:42:56,720
same reasons as the rest of the

782
00:42:56,720 --> 00:42:59,480
application it depends about your

783
00:42:59,480 --> 00:43:02,750
application but usually scaling about

784
00:43:02,750 --> 00:43:03,930
the search is

785
00:43:03,930 --> 00:43:07,620
yeah it has a big need but scaling SSO

786
00:43:07,620 --> 00:43:11,960
is also a very good example because SSO

787
00:43:11,960 --> 00:43:15,480
yeah you can authenticate users and

788
00:43:15,480 --> 00:43:18,390
share authentication between a lot of

789
00:43:18,390 --> 00:43:21,390
different units in your ecosystem like

790
00:43:21,390 --> 00:43:23,100
your main application can use the

791
00:43:23,100 --> 00:43:25,530
authentication but another application

792
00:43:25,530 --> 00:43:28,140
can use the same one because now it's a

793
00:43:28,140 --> 00:43:30,930
standalone application that just calls

794
00:43:30,930 --> 00:43:34,020
through an API and then you can just put

795
00:43:34,020 --> 00:43:36,350
out some parts of the code in some

796
00:43:36,350 --> 00:43:39,510
agnostic services with single

797
00:43:39,510 --> 00:43:41,790
responsibility and maybe you will have

798
00:43:41,790 --> 00:43:44,190
some services like jobs that we'll have

799
00:43:44,190 --> 00:43:46,830
to share some storage with your main

800
00:43:46,830 --> 00:43:48,980
applications that's not a problem

801
00:43:48,980 --> 00:43:52,440
after that when you're close to the end

802
00:43:52,440 --> 00:43:55,890
you will have this kind of thing with

803
00:43:55,890 --> 00:43:58,980
what we call system micro services

804
00:43:58,980 --> 00:44:02,250
system micro services usually interact

805
00:44:02,250 --> 00:44:06,630
with world with it interacts with

806
00:44:06,630 --> 00:44:09,330
backends so with database so with

807
00:44:09,330 --> 00:44:12,960
external api's with you gather data from

808
00:44:12,960 --> 00:44:16,620
Facebook API from a database from I

809
00:44:16,620 --> 00:44:20,460
don't know a lot of different sources so

810
00:44:20,460 --> 00:44:24,000
you can write micro services on top so

811
00:44:24,000 --> 00:44:27,420
it's dedicated small API so then what

812
00:44:27,420 --> 00:44:29,280
remains of your framework is here and

813
00:44:29,280 --> 00:44:31,680
you can also code what we call

814
00:44:31,680 --> 00:44:34,860
experience API is experience API is are

815
00:44:34,860 --> 00:44:38,220
just here to reformat outputs of your

816
00:44:38,220 --> 00:44:40,800
framework to for some dedicated clients

817
00:44:40,800 --> 00:44:44,370
like you can have an Android iOS

818
00:44:44,370 --> 00:44:47,820
application a website's brand new API

819
00:44:47,820 --> 00:44:52,410
graph API I don't know but experience

820
00:44:52,410 --> 00:44:54,960
API is a I think it's a very useful

821
00:44:54,960 --> 00:45:00,300
thing it's very useful thing so what's

822
00:45:00,300 --> 00:45:03,060
very important here is yeah try to keep

823
00:45:03,060 --> 00:45:05,630
something

824
00:45:06,630 --> 00:45:09,510
coherence in the communication between

825
00:45:09,510 --> 00:45:12,540
your services use a stone doubts whose

826
00:45:12,540 --> 00:45:17,100
rest use json-rpc or Rimmel I don't know

827
00:45:17,100 --> 00:45:19,590
something there m2 you can use what you

828
00:45:19,590 --> 00:45:22,110
want but use something coherent in your

829
00:45:22,110 --> 00:45:24,300
ecosystem and I told before that's

830
00:45:24,300 --> 00:45:28,610
impossible but start as much as you can

831
00:45:28,730 --> 00:45:32,220
and yes be careful with communication

832
00:45:32,220 --> 00:45:35,160
that the same thing that with events so

833
00:45:35,160 --> 00:45:38,160
usually what I do I put here and even

834
00:45:38,160 --> 00:45:42,000
bus which centralize all communication

835
00:45:42,000 --> 00:45:45,060
and just dispatch and after if you want

836
00:45:45,060 --> 00:45:47,610
to kill your framework at this layer you

837
00:45:47,610 --> 00:45:49,460
will just have what we call

838
00:45:49,460 --> 00:45:53,100
orchestration api's that's just make

839
00:45:53,100 --> 00:45:56,340
your all small services communication

840
00:45:56,340 --> 00:46:00,120
interact smoothly and you can use

841
00:46:00,120 --> 00:46:02,880
caching you can use a lot of things so

842
00:46:02,880 --> 00:46:07,640
yeah that's a design I like but yeah

843
00:46:07,640 --> 00:46:12,350
what you have to keep about this talk is

844
00:46:12,350 --> 00:46:17,340
there is no silver bullet maybe all the

845
00:46:17,340 --> 00:46:19,920
tools I present in here you don't need I

846
00:46:19,920 --> 00:46:21,990
don't know maybe you need or maybe you

847
00:46:21,990 --> 00:46:25,950
need just a part we have a lot of very

848
00:46:25,950 --> 00:46:28,290
good patterns and good best practices

849
00:46:28,290 --> 00:46:30,870
and tools that exist on the market but

850
00:46:30,870 --> 00:46:33,360
every application is different so yeah

851
00:46:33,360 --> 00:46:34,830
there is no silver bullet

852
00:46:34,830 --> 00:46:39,240
just take have a look at how everyone is

853
00:46:39,240 --> 00:46:44,610
working and take what's fits better with

854
00:46:44,610 --> 00:46:48,870
your application which only needs that I

855
00:46:48,870 --> 00:46:51,620
think if you we have one thing to

856
00:46:51,620 --> 00:46:54,450
remember of the storms exist there is no

857
00:46:54,450 --> 00:46:58,710
silver bullet and yeah I had to do the

858
00:46:58,710 --> 00:47:02,760
point and I don't remember so if you

859
00:47:02,760 --> 00:47:05,880
like to work on this kind of thing and

860
00:47:05,880 --> 00:47:09,930
you're in Brazil come join us we need

861
00:47:09,930 --> 00:47:10,620
help

862
00:47:10,620 --> 00:47:12,270
really

863
00:47:12,270 --> 00:47:16,860
and I know some resources here so that's

864
00:47:16,860 --> 00:47:20,130
a blog of Martin for go read everything

865
00:47:20,130 --> 00:47:22,740
it will take you one that is really

866
00:47:22,740 --> 00:47:25,140
crazy amount of stuff but that's very

867
00:47:25,140 --> 00:47:27,750
interesting you're soft

868
00:47:27,750 --> 00:47:31,800
it's about this kind of architecture I

869
00:47:31,800 --> 00:47:34,250
saw at the muse of tomato muir soft is a

870
00:47:34,250 --> 00:47:38,220
software company designing some micro

871
00:47:38,220 --> 00:47:42,030
service ecosystems and they're very good

872
00:47:42,030 --> 00:47:46,950
practices yeah thing about unit testing

873
00:47:46,950 --> 00:47:51,660
and that's blog article I wrote about

874
00:47:51,660 --> 00:47:56,070
pimba have a look at penguia I will try

875
00:47:56,070 --> 00:47:59,280
to do another presentation on this tool

876
00:47:59,280 --> 00:48:03,330
because I think it will be very good for

877
00:48:03,330 --> 00:48:06,720
people to know it so I don't know if you

878
00:48:06,720 --> 00:48:09,379
have questions

879
00:48:27,120 --> 00:48:28,829
[Music]

880
00:48:28,829 --> 00:48:34,749
yeah it wasn't purpose to just exactly

881
00:48:34,749 --> 00:48:37,420
rates it's a bit it's just don't focus

882
00:48:37,420 --> 00:48:41,140
on design no not do it in a bad way but

883
00:48:41,140 --> 00:48:42,880
don't focus on design you will focus on

884
00:48:42,880 --> 00:48:44,969
design when all your tests will be green

885
00:48:44,969 --> 00:48:48,579
the design of your code I mean focus on

886
00:48:48,579 --> 00:49:01,390
the functionality it's just like I don't

887
00:49:01,390 --> 00:49:04,809
know you know well yeah when you start

888
00:49:04,809 --> 00:49:07,209
to work on something don't try to make

889
00:49:07,209 --> 00:49:09,160
it nice in the first iteration because

890
00:49:09,160 --> 00:49:10,719
you will lost a lot of time maybe you

891
00:49:10,719 --> 00:49:13,059
will not have foreseen some one case and

892
00:49:13,059 --> 00:49:16,029
you will have to rewrite everything so

893
00:49:16,029 --> 00:49:18,699
that's a good practice to go straight to

894
00:49:18,699 --> 00:49:20,979
the point and then reflect I'll make it

895
00:49:20,979 --> 00:49:23,619
nice at the end it doesn't mean make it

896
00:49:23,619 --> 00:49:26,229
messy at first it just means don't focus

897
00:49:26,229 --> 00:49:29,279
on it too much

898
00:49:32,660 --> 00:49:35,410
anyone else

899
00:49:35,410 --> 00:50:11,500
okay usually for me micro application to

900
00:50:11,500 --> 00:50:15,480
access storage should be very very small

901
00:50:18,869 --> 00:50:22,779
yeah for me micro application for

902
00:50:22,779 --> 00:50:25,619
storage should be very very small

903
00:50:25,619 --> 00:50:28,750
doesn't have to handle a lot of business

904
00:50:28,750 --> 00:50:30,880
logic and maybe if you have business

905
00:50:30,880 --> 00:50:32,890
logic on top of your data and you have

906
00:50:32,890 --> 00:50:35,529
to write another micro service that will

907
00:50:35,529 --> 00:50:37,869
just handle this logic like for me

908
00:50:37,869 --> 00:50:42,579
Reggie's API for instance is a built in

909
00:50:42,579 --> 00:50:45,819
micro application you don't have to cut

910
00:50:45,819 --> 00:50:48,450
it just use it

911
00:50:49,760 --> 00:50:52,420
yep

912
00:51:03,339 --> 00:51:09,790
sorry I didn't yeah

913
00:51:17,540 --> 00:51:22,250
okay so the question is if database is a

914
00:51:22,250 --> 00:51:24,349
black box and other services are also

915
00:51:24,349 --> 00:51:27,440
black box how will the interaction be

916
00:51:27,440 --> 00:51:29,809
done so I think you have to centralize

917
00:51:29,809 --> 00:51:31,720
all your business logic in a dedicated

918
00:51:31,720 --> 00:51:38,980
Orchestrator which will just make the

919
00:51:38,980 --> 00:51:42,619
communication easy by with all other

920
00:51:42,619 --> 00:51:44,930
black boxes because it's just business

921
00:51:44,930 --> 00:51:47,720
logic of how you will use your data for

922
00:51:47,720 --> 00:51:49,910
specific clients so it's context

923
00:51:49,910 --> 00:51:53,660
switching I think so maybe you need just

924
00:51:53,660 --> 00:51:57,650
ask a castrato and if you like

925
00:51:57,650 --> 00:52:01,010
Orchestrator I recommend to have a look

926
00:52:01,010 --> 00:52:03,079
at along because it's a very efficient

927
00:52:03,079 --> 00:52:05,740
of which for that

928
00:52:13,670 --> 00:52:17,480
I don't really know I didn't find a very

929
00:52:17,480 --> 00:52:20,900
good solution so far I think if you are

930
00:52:20,900 --> 00:52:25,490
looking for best practices yes the

931
00:52:25,490 --> 00:52:27,250
question was about best practices for

932
00:52:27,250 --> 00:52:29,810
keeping a coherent communication between

933
00:52:29,810 --> 00:52:34,430
small services and what I would

934
00:52:34,430 --> 00:52:37,310
recommend is digging the mule soft

935
00:52:37,310 --> 00:52:40,819
engineering blog air Netflix engineering

936
00:52:40,819 --> 00:52:42,710
blogger so has very good practice for

937
00:52:42,710 --> 00:52:46,310
that but I did I never find something

938
00:52:46,310 --> 00:52:49,040
which is 100% satisfying from my use

939
00:52:49,040 --> 00:52:51,760
case so yeah

940
00:52:51,760 --> 00:52:56,450
combine best practices from other people

941
00:52:56,450 --> 00:52:58,460
and just make something which fits your

942
00:52:58,460 --> 00:52:58,839
needs

943
00:52:58,839 --> 00:53:02,210
yeah sorry I don't have real answer for

944
00:53:02,210 --> 00:53:04,390
that

945
00:53:07,680 --> 00:53:24,420
thank you just a quick note if you

946
00:53:24,420 --> 00:53:27,190
attended any talks here feel free to

947
00:53:27,190 --> 00:53:28,930
provide some feedback through joined in

948
00:53:28,930 --> 00:53:30,910
it's always nice to for the speakers to

949
00:53:30,910 --> 00:53:32,559
hear what you thought as well as for

950
00:53:32,559 --> 00:53:34,900
other conference organizers so they know

951
00:53:34,900 --> 00:53:37,359
whether they can invite that speaker or

952
00:53:37,359 --> 00:53:39,400
not and thank you for attending and see

953
00:53:39,400 --> 00:53:41,789
you next year

954
00:53:47,810 --> 00:53:50,889
[Music]

