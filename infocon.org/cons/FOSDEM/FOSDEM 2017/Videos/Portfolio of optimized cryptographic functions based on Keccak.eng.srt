1
00:00:00,030 --> 00:00:02,809
good morning everyone

2
00:00:05,080 --> 00:00:08,109
welcome to this security and encryption

3
00:00:08,109 --> 00:00:11,530
track so we will indeed talk about some

4
00:00:11,530 --> 00:00:13,750
cryptographic functions based on ket

5
00:00:13,750 --> 00:00:16,119
check and everything I will I will say

6
00:00:16,119 --> 00:00:17,470
is actually don't work with my

7
00:00:17,470 --> 00:00:26,410
colleagues Widow UN McCain and Hani so

8
00:00:26,410 --> 00:00:28,529
this is the outline of my presentation

9
00:00:28,529 --> 00:00:32,198
we start with some introduction then I

10
00:00:32,198 --> 00:00:34,960
will try to discuss the security

11
00:00:34,960 --> 00:00:38,039
properties of symmetric cryptography

12
00:00:38,039 --> 00:00:41,050
then the core of the presentation will

13
00:00:41,050 --> 00:00:43,300
be divided into two parts the key

14
00:00:43,300 --> 00:00:45,370
applications and unkilled applications

15
00:00:45,370 --> 00:00:47,739
depending whether or not we need a

16
00:00:47,739 --> 00:00:51,039
secret key then I talked about the

17
00:00:51,039 --> 00:00:54,579
Quecha code package and recap on on the

18
00:00:54,579 --> 00:00:59,530
under functions with some inventory so

19
00:00:59,530 --> 00:01:03,399
the the story somehow begins some years

20
00:01:03,399 --> 00:01:06,970
ago in the years 2004 2005 where the

21
00:01:06,970 --> 00:01:09,610
when the most popular hash functions md5

22
00:01:09,610 --> 00:01:14,380
and sha-1 got severely broken so at the

23
00:01:14,380 --> 00:01:16,420
time there was also the shot to hash

24
00:01:16,420 --> 00:01:17,110
function

25
00:01:17,110 --> 00:01:20,530
designed by NSA but it was also based on

26
00:01:20,530 --> 00:01:22,750
the same design principles as md5 and

27
00:01:22,750 --> 00:01:25,270
sha-1 so at the time there was fear that

28
00:01:25,270 --> 00:01:27,160
maybe these attacks would extend to

29
00:01:27,160 --> 00:01:31,090
Chateau and so nice decided to create a

30
00:01:31,090 --> 00:01:33,700
new hash function called sha tree but

31
00:01:33,700 --> 00:01:36,310
not on their own they would do that via

32
00:01:36,310 --> 00:01:41,740
an open competition so between 2008 and

33
00:01:41,740 --> 00:01:44,260
2012 there was indeed a free competition

34
00:01:44,260 --> 00:01:46,900
it was an open competition in the sense

35
00:01:46,900 --> 00:01:49,480
that every design was public everyone

36
00:01:49,480 --> 00:01:52,300
was forced to of course give the

37
00:01:52,300 --> 00:01:54,430
rationale of the design and give some

38
00:01:54,430 --> 00:01:57,150
open source implementation of it and

39
00:01:57,150 --> 00:02:00,460
every team was allowed to try to break

40
00:02:00,460 --> 00:02:04,900
and try to attack any competing design

41
00:02:04,900 --> 00:02:07,360
there was also some effort done to

42
00:02:07,360 --> 00:02:09,699
evaluate the performance of all these

43
00:02:09,699 --> 00:02:11,650
designs

44
00:02:11,650 --> 00:02:15,519
it yeah it took the energy of quite a

45
00:02:15,519 --> 00:02:18,159
lot of the cryptographic community a lot

46
00:02:18,159 --> 00:02:19,599
of teams from different different

47
00:02:19,599 --> 00:02:22,720
companies and different universities to

48
00:02:22,720 --> 00:02:25,000
part of this competition and you can see

49
00:02:25,000 --> 00:02:29,980
in this graph arrows going from the

50
00:02:29,980 --> 00:02:32,950
teams attacking the design of another

51
00:02:32,950 --> 00:02:38,040
team so that was the situation in 2009

52
00:02:38,040 --> 00:02:41,920
so our candidate was sketch Shaq okay

53
00:02:41,920 --> 00:02:45,159
Chuck is a sponge function which is

54
00:02:45,159 --> 00:02:47,019
somehow the generalization of a hash

55
00:02:47,019 --> 00:02:49,810
function and it works like in this

56
00:02:49,810 --> 00:02:52,150
drawing so there is a state which is

57
00:02:52,150 --> 00:02:54,370
initialized to zero and then the input

58
00:02:54,370 --> 00:02:56,829
is cut into blocks these blocks are

59
00:02:56,829 --> 00:02:59,129
processed one after the other and

60
00:02:59,129 --> 00:03:01,480
between this block there is this

61
00:03:01,480 --> 00:03:04,180
permutation F so this permutation F

62
00:03:04,180 --> 00:03:06,579
called kajak F is really the core of off

63
00:03:06,579 --> 00:03:08,230
gate check it's really where the the

64
00:03:08,230 --> 00:03:10,959
crypto is real happening well most of

65
00:03:10,959 --> 00:03:12,900
the time is spent

66
00:03:12,900 --> 00:03:18,250
so this cachaca permutation is really

67
00:03:18,250 --> 00:03:21,280
the yeah let's say the common the common

68
00:03:21,280 --> 00:03:25,049
part of this presentation

69
00:03:30,350 --> 00:03:33,840
okay so then in 2012 the the contest

70
00:03:33,840 --> 00:03:36,090
ended with the announcement from this

71
00:03:36,090 --> 00:03:37,800
that Kate Jack was actually chosen as

72
00:03:37,800 --> 00:03:39,960
the winner of the Kshatriya competition

73
00:03:39,960 --> 00:03:42,750
and three years later it took actually

74
00:03:42,750 --> 00:03:44,520
three years for the knees to publish the

75
00:03:44,520 --> 00:03:46,890
fifth - OH - Stan de with the sherry

76
00:03:46,890 --> 00:03:50,130
hash functions meant as a drop-in

77
00:03:50,130 --> 00:03:52,860
replacement for Chateau harmony of hash

78
00:03:52,860 --> 00:03:56,600
functions but they also standardized

79
00:03:56,600 --> 00:03:59,790
extendable output function jobs called

80
00:03:59,790 --> 00:04:04,110
shake 128 and shake 256 so generalizing

81
00:04:04,110 --> 00:04:07,350
the concept of hash functions to an

82
00:04:07,350 --> 00:04:11,220
arbitrary output size in the meantime

83
00:04:11,220 --> 00:04:13,080
before it was actually standardized by

84
00:04:13,080 --> 00:04:19,260
nist the 3gpp consortium published a new

85
00:04:19,260 --> 00:04:21,420
standard called to work making use of

86
00:04:21,420 --> 00:04:24,570
kajak internally for application in SIM

87
00:04:24,570 --> 00:04:26,760
cards and then more recently in December

88
00:04:26,760 --> 00:04:29,100
last year the NIST published some new

89
00:04:29,100 --> 00:04:31,710
functions standardized based on K check

90
00:04:31,710 --> 00:04:40,680
and special publications 801 85 and on

91
00:04:40,680 --> 00:04:43,880
the side of this standardization process

92
00:04:43,880 --> 00:04:47,970
we actually worked on other variants of

93
00:04:47,970 --> 00:04:52,560
ghachok so catcher and KIAC are

94
00:04:52,560 --> 00:04:54,840
authenticated encryption schemes based

95
00:04:54,840 --> 00:04:57,270
on Tkaczyk which we submitted to the

96
00:04:57,270 --> 00:04:58,650
seeds of competition so the Caesar

97
00:04:58,650 --> 00:05:00,330
competition is a currently ongoing

98
00:05:00,330 --> 00:05:03,180
competition for new authenticated

99
00:05:03,180 --> 00:05:05,520
encryption schemes

100
00:05:05,520 --> 00:05:08,100
last year we proposed a new hash

101
00:05:08,100 --> 00:05:11,070
function called kangaroo 12 and then

102
00:05:11,070 --> 00:05:13,980
recently we are working on a new set of

103
00:05:13,980 --> 00:05:16,730
functions called cavity I will discuss

104
00:05:16,730 --> 00:05:20,100
this in a moment so this presentation

105
00:05:20,100 --> 00:05:21,810
the focus on this presentation is really

106
00:05:21,810 --> 00:05:25,820
on these new functions

107
00:05:27,659 --> 00:05:30,969
so let me discuss the security

108
00:05:30,969 --> 00:05:34,030
properties and so I want to show you is

109
00:05:34,030 --> 00:05:38,199
that in symmetric crypto the security

110
00:05:38,199 --> 00:05:41,199
relies on on two different parts one

111
00:05:41,199 --> 00:05:43,210
part is the generic security so the

112
00:05:43,210 --> 00:05:45,400
security of the mode and the other is

113
00:05:45,400 --> 00:05:48,879
the security of the primitive so to take

114
00:05:48,879 --> 00:05:51,129
a check as an example the mode is the

115
00:05:51,129 --> 00:05:52,749
sponge construction it tells you to

116
00:05:52,749 --> 00:05:54,909
initialize the stage to zero it tells

117
00:05:54,909 --> 00:05:56,770
you to cut the input into blocks to sew

118
00:05:56,770 --> 00:05:58,960
them into the state it tells you to

119
00:05:58,960 --> 00:06:00,939
apply the function f and it tells you

120
00:06:00,939 --> 00:06:02,860
how to get the output that's that's the

121
00:06:02,860 --> 00:06:05,500
mode that's how it works on top of the

122
00:06:05,500 --> 00:06:07,300
permutation and then of course there is

123
00:06:07,300 --> 00:06:12,370
a permutation can we say something about

124
00:06:12,370 --> 00:06:15,400
this construction yes we can say

125
00:06:15,400 --> 00:06:17,740
something if we make abstraction of the

126
00:06:17,740 --> 00:06:20,379
permutations we replace this function f

127
00:06:20,379 --> 00:06:22,990
this concrete permutation that you can

128
00:06:22,990 --> 00:06:25,870
implement in C or any language you can

129
00:06:25,870 --> 00:06:28,629
replace it virtually by a random

130
00:06:28,629 --> 00:06:31,449
permutation and if you do that then you

131
00:06:31,449 --> 00:06:34,150
can start a proof you can you can prove

132
00:06:34,150 --> 00:06:36,099
theorems about the security of this

133
00:06:36,099 --> 00:06:38,589
scheme when the function is replaced by

134
00:06:38,589 --> 00:06:41,979
a randomly chosen permutation and you

135
00:06:41,979 --> 00:06:44,830
can even derive some theorems this is a

136
00:06:44,830 --> 00:06:46,949
theorem that we proved at your equipped

137
00:06:46,949 --> 00:06:52,419
2008 don't worry I'm going to explain

138
00:06:52,419 --> 00:06:56,529
what it means so first let me go back

139
00:06:56,529 --> 00:06:58,509
once right so one important parameter of

140
00:06:58,509 --> 00:07:00,370
the spawns construction is the capacity

141
00:07:00,370 --> 00:07:02,979
the value C that appears on on the left

142
00:07:02,979 --> 00:07:05,379
side of this presentation of this figure

143
00:07:05,379 --> 00:07:07,960
so it's the size of the part of the

144
00:07:07,960 --> 00:07:09,759
state that is not directly touched by

145
00:07:09,759 --> 00:07:13,539
the input or the output blocks and the

146
00:07:13,539 --> 00:07:17,349
security highly depends on this value so

147
00:07:17,349 --> 00:07:18,879
what this theorem says is that if I

148
00:07:18,879 --> 00:07:20,949
replace in cachaca replace the

149
00:07:20,949 --> 00:07:23,229
permutation by a random permutation then

150
00:07:23,229 --> 00:07:25,149
the probability of some of some attack

151
00:07:25,149 --> 00:07:27,939
to be successful is upper bounded by n

152
00:07:27,939 --> 00:07:31,419
square over 2 to C plus 1 where n is the

153
00:07:31,419 --> 00:07:34,180
time spent by the adversary and the time

154
00:07:34,180 --> 00:07:36,639
unit is the time needed to compute once

155
00:07:36,639 --> 00:07:38,490
the permutation F

156
00:07:38,490 --> 00:07:41,729
so as long as this time n is much

157
00:07:41,729 --> 00:07:44,370
smaller than 2 to the C over 2 then this

158
00:07:44,370 --> 00:07:46,289
probability is negligible and we have

159
00:07:46,289 --> 00:07:48,840
security of after of the mood of

160
00:07:48,840 --> 00:07:51,990
response construction so if we want to

161
00:07:51,990 --> 00:07:54,569
have for instance security at the level

162
00:07:54,569 --> 00:07:57,180
of 128 bits then we need to take a

163
00:07:57,180 --> 00:08:01,860
capacity of at least 256 bits but of

164
00:08:01,860 --> 00:08:04,139
course this does not tell us anything

165
00:08:04,139 --> 00:08:08,099
when we replace this black permutation

166
00:08:08,099 --> 00:08:13,470
here by the concrete kajak F so the nice

167
00:08:13,470 --> 00:08:15,599
thing about these generic security is

168
00:08:15,599 --> 00:08:17,250
that you can actually reduce the scope

169
00:08:17,250 --> 00:08:19,650
of cryptanalysis and focus only on the

170
00:08:19,650 --> 00:08:21,270
permutation because what it tells you is

171
00:08:21,270 --> 00:08:22,650
that if there is a problem in catch a

172
00:08:22,650 --> 00:08:24,570
key it should not come from from the

173
00:08:24,570 --> 00:08:26,009
Swanage construction it should only come

174
00:08:26,009 --> 00:08:30,150
from the permutation but the problem is

175
00:08:30,150 --> 00:08:32,039
that when you talk about the security of

176
00:08:32,039 --> 00:08:34,020
of the content of the permutation of the

177
00:08:34,020 --> 00:08:36,208
primitives then there is no mathematical

178
00:08:36,208 --> 00:08:38,490
proof that it's secure so the only way

179
00:08:38,490 --> 00:08:41,789
to to gain some confidence is first to

180
00:08:41,789 --> 00:08:45,540
have some open design rationale of of

181
00:08:45,540 --> 00:08:48,630
the permutation and then have some crypt

182
00:08:48,630 --> 00:08:52,350
analysis and preferably peer review

183
00:08:52,350 --> 00:08:55,160
meaning third party crypt analysis and

184
00:08:55,160 --> 00:08:58,500
what's even better a lot of route

185
00:08:58,500 --> 00:09:00,660
analysis is if you want to build

186
00:09:00,660 --> 00:09:02,550
confidence then you need to have some

187
00:09:02,550 --> 00:09:05,520
sustained cryptanalysis activity on the

188
00:09:05,520 --> 00:09:07,079
function and the function of course not

189
00:09:07,079 --> 00:09:10,800
broken that is the only way to actually

190
00:09:10,800 --> 00:09:14,149
have the security of most symmetric

191
00:09:14,149 --> 00:09:17,779
crypto primitives

192
00:09:19,049 --> 00:09:22,720
so now let's discuss further with the

193
00:09:22,720 --> 00:09:25,230
cachaca fermentation most cryptographic

194
00:09:25,230 --> 00:09:27,459
primitives and including the cachaça

195
00:09:27,459 --> 00:09:30,339
permutation is actually divided in two

196
00:09:30,339 --> 00:09:30,910
rounds

197
00:09:30,910 --> 00:09:33,939
so around by itself is a very simple set

198
00:09:33,939 --> 00:09:36,429
of operations and by itself it does not

199
00:09:36,429 --> 00:09:39,339
provide any security but if you repeat

200
00:09:39,339 --> 00:09:42,129
this round many times and enough times

201
00:09:42,129 --> 00:09:44,109
then the security starts to build up and

202
00:09:44,109 --> 00:09:46,989
there is a point where the there are

203
00:09:46,989 --> 00:09:49,179
enough rounds for that permutation to be

204
00:09:49,179 --> 00:09:52,119
to be strong and then in this case for

205
00:09:52,119 --> 00:09:58,899
character to be secure what people

206
00:09:58,899 --> 00:10:00,549
actually do when when doing crypt

207
00:10:00,549 --> 00:10:02,319
analysis is that they try to break one

208
00:10:02,319 --> 00:10:04,179
round to around and so on and then see

209
00:10:04,179 --> 00:10:05,799
how far they can go

210
00:10:05,799 --> 00:10:08,319
so the status for cachaca is the

211
00:10:08,319 --> 00:10:10,449
following catcha kev the largest

212
00:10:10,449 --> 00:10:14,169
permutation has 24 rounds catch a key

213
00:10:14,169 --> 00:10:16,359
has been practically broken up to five

214
00:10:16,359 --> 00:10:18,609
rounds the best attack on five rounds is

215
00:10:18,609 --> 00:10:21,549
a collision attack published last year

216
00:10:21,549 --> 00:10:24,999
if you allow complexities that are

217
00:10:24,999 --> 00:10:27,579
theoretical so not having an explicit

218
00:10:27,579 --> 00:10:31,419
example but an algorithm of complexity

219
00:10:31,419 --> 00:10:33,730
less than the expected complexity then

220
00:10:33,730 --> 00:10:35,709
you can have collision attacks up to six

221
00:10:35,709 --> 00:10:39,699
rounds and now if you allow any kind of

222
00:10:39,699 --> 00:10:42,160
attacks then the best theoretical

223
00:10:42,160 --> 00:10:47,079
attacks are up to nine rounds but nine

224
00:10:47,079 --> 00:10:49,449
rounds in that case it's a time two to

225
00:10:49,449 --> 00:10:52,540
the power 256 which is a huge number

226
00:10:52,540 --> 00:10:54,610
it's even higher than the number of

227
00:10:54,610 --> 00:10:56,769
particles in the universe so that's

228
00:10:56,769 --> 00:10:59,980
really theoretical so we can see from

229
00:10:59,980 --> 00:11:02,169
this figure that the 24 rounds of

230
00:11:02,169 --> 00:11:04,059
ketchup

231
00:11:04,059 --> 00:11:09,209
are actually rock solid safety margin

232
00:11:11,410 --> 00:11:15,590
okay so let me discuss some unsealed

233
00:11:15,590 --> 00:11:18,530
applications so the most obvious unclear

234
00:11:18,530 --> 00:11:21,580
application of chechik is simply hashing

235
00:11:21,580 --> 00:11:24,950
so a hash function if I need to recall

236
00:11:24,950 --> 00:11:26,870
what it is is simply a function that

237
00:11:26,870 --> 00:11:29,510
takes as input any string of bits of any

238
00:11:29,510 --> 00:11:31,970
size so it can be a small message or a

239
00:11:31,970 --> 00:11:36,200
picture complete DVD and then it

240
00:11:36,200 --> 00:11:38,870
processes it and you get as output a

241
00:11:38,870 --> 00:11:42,350
digest of fixed size 256 bits for

242
00:11:42,350 --> 00:11:45,020
instance which acts as kind of a

243
00:11:45,020 --> 00:11:48,740
fingerprint of the input obviously the

244
00:11:48,740 --> 00:11:50,090
response construction can be used for

245
00:11:50,090 --> 00:11:52,760
that the input is then your big file and

246
00:11:52,760 --> 00:11:58,630
the output is your digest now for the

247
00:11:58,630 --> 00:12:03,470
performance of the function you can see

248
00:12:03,470 --> 00:12:05,780
that within the permutation F there can

249
00:12:05,780 --> 00:12:07,310
be a lot of parallelism that you can

250
00:12:07,310 --> 00:12:09,890
exploit but beyond that you can see that

251
00:12:09,890 --> 00:12:11,330
the spawns construction by itself is

252
00:12:11,330 --> 00:12:17,540
quite serial if you implement the

253
00:12:17,540 --> 00:12:21,410
permutation catch a cave on skylake CPU

254
00:12:21,410 --> 00:12:26,270
you get about 1100 cycles for one

255
00:12:26,270 --> 00:12:28,940
application of the permutation if you

256
00:12:28,940 --> 00:12:31,580
now implement this permutation but using

257
00:12:31,580 --> 00:12:34,280
vector instructions by performing

258
00:12:34,280 --> 00:12:37,100
evaluating for different permutations in

259
00:12:37,100 --> 00:12:39,920
parallel then the time grows slightly to

260
00:12:39,920 --> 00:12:44,000
400 cycles so per input byte you can

261
00:12:44,000 --> 00:12:45,110
clearly see that it's more interesting

262
00:12:45,110 --> 00:12:48,650
to compute for permutations in parallel

263
00:12:48,650 --> 00:12:51,860
than just one so what can we do to

264
00:12:51,860 --> 00:12:54,950
exploit this kind of parallelism we can

265
00:12:54,950 --> 00:12:57,770
do some three rushing so triaging is

266
00:12:57,770 --> 00:13:00,500
just taking the input cutting it into

267
00:13:00,500 --> 00:13:03,020
pieces and then evaluating the hash as a

268
00:13:03,020 --> 00:13:05,480
tree where each there should be a slight

269
00:13:05,480 --> 00:13:09,320
coming in but my PC is a bit slow yes so

270
00:13:09,320 --> 00:13:11,900
the message is cut into some pieces and

271
00:13:11,900 --> 00:13:14,780
then each piece is hashed separately and

272
00:13:14,780 --> 00:13:17,720
then the digest are then concatenate it

273
00:13:17,720 --> 00:13:22,270
and hashed again to get the final harsh

274
00:13:22,430 --> 00:13:25,010
in the latest standard from this there

275
00:13:25,010 --> 00:13:27,740
is a spa Harlan ash function that

276
00:13:27,740 --> 00:13:29,900
exploits this kind of parallelism and

277
00:13:29,900 --> 00:13:31,700
you can see that the number of cycles

278
00:13:31,700 --> 00:13:34,930
per byte still on this skylake processor

279
00:13:34,930 --> 00:13:37,670
decreases significantly as soon as you

280
00:13:37,670 --> 00:13:39,470
can exploit this parallelism as soon as

281
00:13:39,470 --> 00:13:41,870
your input is big enough you can go down

282
00:13:41,870 --> 00:13:44,120
to two point three cycles per byte so

283
00:13:44,120 --> 00:13:46,310
which is quite fast too that's that's

284
00:13:46,310 --> 00:13:50,960
the existing standard we can actually go

285
00:13:50,960 --> 00:13:53,180
further than this and that's the purpose

286
00:13:53,180 --> 00:13:55,370
of this new kangaroo twelve hash

287
00:13:55,370 --> 00:13:58,280
function I've showed you that 24 rounds

288
00:13:58,280 --> 00:14:01,250
are rock-solid we can afford to decrease

289
00:14:01,250 --> 00:14:03,560
the safety margin a bit and actually

290
00:14:03,560 --> 00:14:05,840
more than a bit we can go down to twelve

291
00:14:05,840 --> 00:14:08,450
rounds and still have comfortable safety

292
00:14:08,450 --> 00:14:10,310
margin so that gives us a factor of two

293
00:14:10,310 --> 00:14:13,400
speed-up and then we can have a special

294
00:14:13,400 --> 00:14:17,540
mode at three harsh mode that has what

295
00:14:17,540 --> 00:14:20,450
is called embarassingly embarassingly

296
00:14:20,450 --> 00:14:24,920
parallel such that as soon as you have

297
00:14:24,920 --> 00:14:27,800
enough data as input there is as much

298
00:14:27,800 --> 00:14:30,950
parallelism as your platform allows you

299
00:14:30,950 --> 00:14:33,430
to exploit

300
00:14:33,490 --> 00:14:36,410
so concretely what it means is that the

301
00:14:36,410 --> 00:14:39,170
input message is cut into chunks and

302
00:14:39,170 --> 00:14:41,810
these chunks are can be potentially

303
00:14:41,810 --> 00:14:44,870
hashed in parallel so the more chunks

304
00:14:44,870 --> 00:14:46,940
you have the more parallelism you can

305
00:14:46,940 --> 00:14:49,580
exploit and the faster per byte it can

306
00:14:49,580 --> 00:14:55,280
go the first chunk has a special status

307
00:14:55,280 --> 00:14:57,290
in the sense that the chaining value so

308
00:14:57,290 --> 00:14:58,850
the intermediate digests that come from

309
00:14:58,850 --> 00:15:00,830
the other chunks are asked to gather

310
00:15:00,830 --> 00:15:03,530
with it and that's something a technique

311
00:15:03,530 --> 00:15:06,110
we called kangaroo hopping and that's

312
00:15:06,110 --> 00:15:08,140
where the name can go twelve comes from

313
00:15:08,140 --> 00:15:11,840
all these values 1 1 0 1 1 0 star and so

314
00:15:11,840 --> 00:15:14,720
on come from secure coding which we

315
00:15:14,720 --> 00:15:17,510
defined and the idea is that as soon as

316
00:15:17,510 --> 00:15:20,060
we use hexa core coding then generically

317
00:15:20,060 --> 00:15:22,370
we know that our mode is secure so that

318
00:15:22,370 --> 00:15:25,280
if there is no it's proven that there is

319
00:15:25,280 --> 00:15:27,600
no problem on the mode side

320
00:15:27,600 --> 00:15:29,820
if there is ammo it has to come from the

321
00:15:29,820 --> 00:15:32,640
permutation reduce to 12 rounds but the

322
00:15:32,640 --> 00:15:34,080
crypt analysis that has been done on

323
00:15:34,080 --> 00:15:36,870
kachuck sofa still applies to kangaroo

324
00:15:36,870 --> 00:15:40,020
12 so we we rely on this and we somehow

325
00:15:40,020 --> 00:15:42,300
inherit from from all the crypt analysis

326
00:15:42,300 --> 00:15:44,790
that has been done on ket Shack and to

327
00:15:44,790 --> 00:15:50,540
apply it on kangaroo 12 so concretely

328
00:15:50,540 --> 00:15:54,779
still on this skylake processor if you

329
00:15:54,779 --> 00:15:57,480
have a short input then the number of

330
00:15:57,480 --> 00:16:00,630
cycles per byte is 3.72 and as soon as

331
00:16:00,630 --> 00:16:03,180
you have enough input to exploit fully

332
00:16:03,180 --> 00:16:04,800
exploit the parallelism you can go down

333
00:16:04,800 --> 00:16:08,550
to one point 22 yes I forgot to mention

334
00:16:08,550 --> 00:16:11,610
that so this idea of kangaroo hopping

335
00:16:11,610 --> 00:16:16,200
with the first Chum they used with the

336
00:16:16,200 --> 00:16:18,330
same hash function as a digest the idea

337
00:16:18,330 --> 00:16:20,610
is that if your input is small then

338
00:16:20,610 --> 00:16:22,620
there is no overhead due to the three

339
00:16:22,620 --> 00:16:30,600
hush mode so this 3.72 it's really the

340
00:16:30,600 --> 00:16:33,510
speed for a short message as soon as

341
00:16:33,510 --> 00:16:37,230
there is one block for instance on the

342
00:16:37,230 --> 00:16:38,940
last line you can see some some figures

343
00:16:38,940 --> 00:16:40,800
for the knights landing architecture on

344
00:16:40,800 --> 00:16:43,020
that architecture they have bigger

345
00:16:43,020 --> 00:16:45,089
vector spaces with a bigger bigger

346
00:16:45,089 --> 00:16:49,200
vector registers up to 512 bits so you

347
00:16:49,200 --> 00:16:51,660
can compute actually eight permutations

348
00:16:51,660 --> 00:16:53,850
in parallel and this decreases the

349
00:16:53,850 --> 00:16:56,310
number of cycles per byte below one

350
00:16:56,310 --> 00:16:57,750
cycle per byte which is really really

351
00:16:57,750 --> 00:17:03,990
fast okay so now some some kid

352
00:17:03,990 --> 00:17:06,990
applications and what I would like to do

353
00:17:06,990 --> 00:17:08,880
is before I really speak about

354
00:17:08,880 --> 00:17:10,530
concurrent functions I would like to

355
00:17:10,530 --> 00:17:12,329
take a step back and talk more

356
00:17:12,329 --> 00:17:14,970
abstractly about pseudo-random functions

357
00:17:14,970 --> 00:17:17,730
and what we can do with them and yeah

358
00:17:17,730 --> 00:17:21,359
what they can bring to us so up to the

359
00:17:21,359 --> 00:17:23,099
random function is a function that takes

360
00:17:23,099 --> 00:17:25,709
as input a secret key and some some

361
00:17:25,709 --> 00:17:31,620
input string then it produces bits as

362
00:17:31,620 --> 00:17:35,429
many as requested from the point of view

363
00:17:35,429 --> 00:17:38,640
of the people who know the secret key

364
00:17:38,640 --> 00:17:40,980
it's a deterministic function meaning

365
00:17:40,980 --> 00:17:43,380
that anyone can compute it easily but

366
00:17:43,380 --> 00:17:45,120
from the point of view of an adversary

367
00:17:45,120 --> 00:17:47,340
who doesn't know the key then not

368
00:17:47,340 --> 00:17:49,020
knowing the key means that these bits

369
00:17:49,020 --> 00:17:50,580
these output bits they will look just

370
00:17:50,580 --> 00:17:55,830
like random bits 50/50 percent one or

371
00:17:55,830 --> 00:17:59,309
zero all independent that's what good

372
00:17:59,309 --> 00:18:03,570
PRF should look like so what can we do

373
00:18:03,570 --> 00:18:06,450
with such a PRF we can build a stream

374
00:18:06,450 --> 00:18:09,570
cipher to do some encryption so if you

375
00:18:09,570 --> 00:18:12,419
take the key and then give some input to

376
00:18:12,419 --> 00:18:16,380
your PRF you can use the output as a key

377
00:18:16,380 --> 00:18:18,480
string that you saw with your plaintext

378
00:18:18,480 --> 00:18:21,059
so if you do that the ciphertext

379
00:18:21,059 --> 00:18:23,760
will look like garbage and there is no

380
00:18:23,760 --> 00:18:27,480
way to recover the plaintext the nuns

381
00:18:27,480 --> 00:18:31,620
there is some identifier so that every

382
00:18:31,620 --> 00:18:33,540
time you use it you use a different nuns

383
00:18:33,540 --> 00:18:35,309
so that you get a different and

384
00:18:35,309 --> 00:18:37,140
independent key stream and you can reuse

385
00:18:37,140 --> 00:18:40,440
the same key the same long term key okay

386
00:18:40,440 --> 00:18:42,090
so that's for encryption for

387
00:18:42,090 --> 00:18:46,140
confidentiality a second application is

388
00:18:46,140 --> 00:18:49,049
authentication so what you want to have

389
00:18:49,049 --> 00:18:52,980
is transmit a message in the clear but

390
00:18:52,980 --> 00:18:55,260
have a way to make sure that this was

391
00:18:55,260 --> 00:18:58,169
not changed on on the way so yeah maybe

392
00:18:58,169 --> 00:19:00,660
a client sending a message to a server

393
00:19:00,660 --> 00:19:01,980
and the server wants to make sure that

394
00:19:01,980 --> 00:19:03,660
the message actually comes from the

395
00:19:03,660 --> 00:19:05,940
legitimate client what you can do is

396
00:19:05,940 --> 00:19:08,309
apply the PRF to the plaintext your

397
00:19:08,309 --> 00:19:10,919
message and you can use that output as

398
00:19:10,919 --> 00:19:13,740
kind of a tag that you attach to your

399
00:19:13,740 --> 00:19:15,570
message then you send the message in the

400
00:19:15,570 --> 00:19:18,299
clear plus the tag the server is then

401
00:19:18,299 --> 00:19:21,960
able to really compute this tag checks

402
00:19:21,960 --> 00:19:24,330
that it's correct that is much if it

403
00:19:24,330 --> 00:19:25,919
matches that means that the plaintext

404
00:19:25,919 --> 00:19:29,270
was actually not changed

405
00:19:30,799 --> 00:19:34,829
now you can combine the two you can use

406
00:19:34,829 --> 00:19:37,799
the PRF once to get some keystream means

407
00:19:37,799 --> 00:19:39,839
you can encrypt your plain text into

408
00:19:39,839 --> 00:19:42,719
ciphertext and then you use it a second

409
00:19:42,719 --> 00:19:45,059
time to have a tag over the ciphertext

410
00:19:45,059 --> 00:19:46,679
and in that case you achieve at the same

411
00:19:46,679 --> 00:19:48,269
time confidentiality and authentication

412
00:19:48,269 --> 00:19:50,429
you have your ciphertext and readable

413
00:19:50,429 --> 00:19:52,619
and the tag that protects against any

414
00:19:52,619 --> 00:19:55,199
changes that an adversary we try to do

415
00:19:55,199 --> 00:20:00,899
on the message on the way an I thing

416
00:20:00,899 --> 00:20:04,619
that we want to achieve with a PRF is

417
00:20:04,619 --> 00:20:07,559
called incrementality so it's let's

418
00:20:07,559 --> 00:20:09,269
assume that you want to authenticate

419
00:20:09,269 --> 00:20:12,179
some some packets flowing from a client

420
00:20:12,179 --> 00:20:14,909
to a server so first you have this first

421
00:20:14,909 --> 00:20:16,889
packet you compute a tag over this first

422
00:20:16,889 --> 00:20:19,829
packet and you send it then a second

423
00:20:19,829 --> 00:20:23,279
packet needs to be transmitted then what

424
00:20:23,279 --> 00:20:26,339
you want to have is a tag over the first

425
00:20:26,339 --> 00:20:28,949
two packets together but you don't need

426
00:20:28,949 --> 00:20:30,929
to compute everything again you just

427
00:20:30,929 --> 00:20:35,129
take the result of the computation with

428
00:20:35,129 --> 00:20:37,259
the first packet and you extend it you

429
00:20:37,259 --> 00:20:39,119
extend your computation with the second

430
00:20:39,119 --> 00:20:41,759
packet then the tag you get is a tag

431
00:20:41,759 --> 00:20:44,819
over the concatenation of packet one and

432
00:20:44,819 --> 00:20:47,209
packet two and you can go on like this

433
00:20:47,209 --> 00:20:50,189
in this case the final tag on packet

434
00:20:50,189 --> 00:20:51,899
three authenticates not only packet

435
00:20:51,899 --> 00:20:54,059
three but the actual sequence of packet

436
00:20:54,059 --> 00:20:55,979
one packet two packet three so there is

437
00:20:55,979 --> 00:20:57,959
no way that the adversary can can

438
00:20:57,959 --> 00:20:59,699
reshuffle the packets for instance the

439
00:20:59,699 --> 00:21:04,079
tag then will not match so there are at

440
00:21:04,079 --> 00:21:07,079
least two ways that we can instantiate

441
00:21:07,079 --> 00:21:10,699
this PRF to build schemes

442
00:21:10,699 --> 00:21:13,409
the first one is essentially based on

443
00:21:13,409 --> 00:21:15,839
the sponge construction and the second

444
00:21:15,839 --> 00:21:17,009
one is based on the new construction

445
00:21:17,009 --> 00:21:19,949
called farfalle so let me first start

446
00:21:19,949 --> 00:21:21,839
with sponge-like

447
00:21:21,839 --> 00:21:24,449
constructions and the first example is

448
00:21:24,449 --> 00:21:27,599
kkeok so kkeok is an authenticated

449
00:21:27,599 --> 00:21:29,369
encryption scheme that we submitted to

450
00:21:29,369 --> 00:21:31,559
the C's of competition it uses the

451
00:21:31,559 --> 00:21:33,479
kichaka's permutation but reduced to

452
00:21:33,479 --> 00:21:36,350
twelve rounds a lakh can go to

453
00:21:36,350 --> 00:21:39,270
it works in sessions so the idea is

454
00:21:39,270 --> 00:21:42,870
really it really extends what I said in

455
00:21:42,870 --> 00:21:45,780
the previous slide so the idea is to

456
00:21:45,780 --> 00:21:48,420
authenticate the full to encrypt and to

457
00:21:48,420 --> 00:21:49,680
enter netiquette the full the full

458
00:21:49,680 --> 00:21:53,310
session so let's say that you start the

459
00:21:53,310 --> 00:21:55,470
session with some some session key

460
00:21:55,470 --> 00:21:57,570
it's called SUV because it needs to be

461
00:21:57,570 --> 00:21:59,910
secret and unique so it can be a session

462
00:21:59,910 --> 00:22:01,950
key meaning that it's different every

463
00:22:01,950 --> 00:22:04,500
time you open a new connection it could

464
00:22:04,500 --> 00:22:08,310
also be a long term key but you are

465
00:22:08,310 --> 00:22:10,320
joined to it some some counter some

466
00:22:10,320 --> 00:22:12,330
connection identifier that changes every

467
00:22:12,330 --> 00:22:18,000
time so let's say you you have your

468
00:22:18,000 --> 00:22:20,550
first plaintext P that comes in and some

469
00:22:20,550 --> 00:22:22,410
metadata a that you don't need to

470
00:22:22,410 --> 00:22:24,270
encrypt but still you want to

471
00:22:24,270 --> 00:22:26,670
authenticate it then what you will get

472
00:22:26,670 --> 00:22:28,950
is some cipher text from your plaintext

473
00:22:28,950 --> 00:22:32,190
and attack covering both the plaintext

474
00:22:32,190 --> 00:22:35,250
and the metadata then you can go on with

475
00:22:35,250 --> 00:22:37,590
more plain text and more metadata every

476
00:22:37,590 --> 00:22:39,330
time you get some cipher text and attack

477
00:22:39,330 --> 00:22:42,270
that Tentacles all the session so far

478
00:22:42,270 --> 00:22:45,030
and then maybe here in this last example

479
00:22:45,030 --> 00:22:47,580
just some more metadata maybe just a

480
00:22:47,580 --> 00:22:49,050
confirmation that does not need to be

481
00:22:49,050 --> 00:22:51,540
encrypted but that just that is OK and

482
00:22:51,540 --> 00:22:53,880
then the tag on this okay actually is

483
00:22:53,880 --> 00:22:56,490
okay over the entire session so

484
00:22:56,490 --> 00:22:58,650
including the context on which this okay

485
00:22:58,650 --> 00:23:03,530
is is sent so that's really useful in in

486
00:23:03,530 --> 00:23:08,610
encrypting a network communication then

487
00:23:08,610 --> 00:23:11,610
we submit a second proposal to the

488
00:23:11,610 --> 00:23:13,350
Caesar competition called catcher it's

489
00:23:13,350 --> 00:23:15,000
again based on catch act but it's

490
00:23:15,000 --> 00:23:16,980
sufficiently different from kiuic to

491
00:23:16,980 --> 00:23:18,720
deserve a separate submission and

492
00:23:18,720 --> 00:23:22,440
separate name catcher has less features

493
00:23:22,440 --> 00:23:26,190
than kkeok but is also simpler and and

494
00:23:26,190 --> 00:23:28,740
targeted at lightweight applications

495
00:23:28,740 --> 00:23:30,840
like the Internet of Things and you can

496
00:23:30,840 --> 00:23:33,260
instantiate it with smaller permutations

497
00:23:33,260 --> 00:23:35,880
400 and 200 bits so that it can be

498
00:23:35,880 --> 00:23:37,980
really small in hardware or in embedded

499
00:23:37,980 --> 00:23:40,220
software

500
00:23:41,430 --> 00:23:44,800
then the second set of constructions I

501
00:23:44,800 --> 00:23:46,660
would like to talk about this is really

502
00:23:46,660 --> 00:23:48,790
new so it's really it's based on the

503
00:23:48,790 --> 00:23:50,560
phallic construction so the phallic

504
00:23:50,560 --> 00:23:52,930
construction is this figure it resembles

505
00:23:52,930 --> 00:23:56,260
somehow a farfalle pasta Jewish so the

506
00:23:56,260 --> 00:23:58,330
idea here is that we try to exploit

507
00:23:58,330 --> 00:24:01,570
parallelism as much as we can so on the

508
00:24:01,570 --> 00:24:04,570
left side you have the secret key that

509
00:24:04,570 --> 00:24:07,450
is used every time and then the input

510
00:24:07,450 --> 00:24:10,560
blocks so the input message is cut into

511
00:24:10,560 --> 00:24:12,880
input blocks and zero and one and so on

512
00:24:12,880 --> 00:24:15,910
and all these blocks are processed to

513
00:24:15,910 --> 00:24:18,610
the permutation F in parallel and the

514
00:24:18,610 --> 00:24:23,080
results are summed together so this

515
00:24:23,080 --> 00:24:25,720
gives us the parallelism and the

516
00:24:25,720 --> 00:24:28,150
incrementality because if you have more

517
00:24:28,150 --> 00:24:31,180
input blocks that come in you just need

518
00:24:31,180 --> 00:24:33,910
to add to the counter that you already

519
00:24:33,910 --> 00:24:37,450
have had this at this time then to get

520
00:24:37,450 --> 00:24:39,720
some output you apply F again and then

521
00:24:39,720 --> 00:24:43,780
some more F for each output blocks so

522
00:24:43,780 --> 00:24:47,200
you can get an output of any size and

523
00:24:47,200 --> 00:24:49,330
again if you have if you want to have a

524
00:24:49,330 --> 00:24:51,250
long output you want to do string

525
00:24:51,250 --> 00:24:53,080
encryption for instance then all these

526
00:24:53,080 --> 00:24:54,880
output blocks can be computed in

527
00:24:54,880 --> 00:24:57,130
parallel if you if your platform allows

528
00:24:57,130 --> 00:25:00,430
you so so this is the farfalle

529
00:25:00,430 --> 00:25:02,680
construction and cavity is an instance

530
00:25:02,680 --> 00:25:05,530
using the kichaka's permutation but with

531
00:25:05,530 --> 00:25:08,470
the number of rounds really reduced to

532
00:25:08,470 --> 00:25:11,920
not much so typically what we expect now

533
00:25:11,920 --> 00:25:14,320
is to have six rounds four rounds and

534
00:25:14,320 --> 00:25:17,410
four rounds so it means fourteen rounds

535
00:25:17,410 --> 00:25:22,320
in total if you remember the figure with

536
00:25:22,320 --> 00:25:25,600
2400 was really rock solid so fourteen

537
00:25:25,600 --> 00:25:28,270
rounds between input and output that's

538
00:25:28,270 --> 00:25:34,090
already quite quite safe so now that we

539
00:25:34,090 --> 00:25:36,610
have this PRF we can we can just apply

540
00:25:36,610 --> 00:25:38,680
them in a simple way just as I explained

541
00:25:38,680 --> 00:25:40,690
in the beginning of this this part of

542
00:25:40,690 --> 00:25:43,690
the presentation we can build some so

543
00:25:43,690 --> 00:25:46,360
concrete PRF to compute some some some

544
00:25:46,360 --> 00:25:49,210
knock some authentication code we can

545
00:25:49,210 --> 00:25:51,310
have different flavors of authenticated

546
00:25:51,310 --> 00:25:53,680
encryption schemes and I wish to point

547
00:25:53,680 --> 00:25:55,330
out the last one which is a wide block

548
00:25:55,330 --> 00:25:58,450
cipher so wide block cipher is simply

549
00:25:58,450 --> 00:26:00,460
another thing it authenticated

550
00:26:00,460 --> 00:26:02,470
encryption scheme that doesn't have any

551
00:26:02,470 --> 00:26:05,500
expansion so if you encrypt a blog of a

552
00:26:05,500 --> 00:26:07,510
given size then the output will be of

553
00:26:07,510 --> 00:26:09,610
the same size and if you want to check

554
00:26:09,610 --> 00:26:11,740
the authenticity then you need to rely

555
00:26:11,740 --> 00:26:14,890
either on the existing redundancy of

556
00:26:14,890 --> 00:26:18,580
your input or if you really don't have

557
00:26:18,580 --> 00:26:20,710
that you need to add some some

558
00:26:20,710 --> 00:26:23,140
redundancy yourself bhop beforehand but

559
00:26:23,140 --> 00:26:25,030
it can be really interesting if you

560
00:26:25,030 --> 00:26:27,100
don't want to have any expansion if you

561
00:26:27,100 --> 00:26:29,200
don't cannot afford to have a tag

562
00:26:29,200 --> 00:26:31,960
attached to your message so concretely

563
00:26:31,960 --> 00:26:34,300
if you encrypt with a wide block cipher

564
00:26:34,300 --> 00:26:37,750
a picture and then at the decryption you

565
00:26:37,750 --> 00:26:38,890
get something which is really garbage

566
00:26:38,890 --> 00:26:40,930
doesn't look like a picture then you're

567
00:26:40,930 --> 00:26:43,960
sure that your your message was tampered

568
00:26:43,960 --> 00:26:46,450
with so any changes will diffuse

569
00:26:46,450 --> 00:26:49,240
completely over the full plaintext and

570
00:26:49,240 --> 00:26:52,150
and your redundancy so the fact that it

571
00:26:52,150 --> 00:26:53,470
was actually a picture a meaningful

572
00:26:53,470 --> 00:26:55,630
picture is destroyed completely so it's

573
00:26:55,630 --> 00:26:57,280
all or nothing so that's quite

574
00:26:57,280 --> 00:27:03,310
interesting okay so that that's all for

575
00:27:03,310 --> 00:27:07,360
the applications now let me give you

576
00:27:07,360 --> 00:27:08,950
some words about the Quecha code package

577
00:27:08,950 --> 00:27:13,420
so the Quecha code package is simply set

578
00:27:13,420 --> 00:27:18,460
an open source set of of code

579
00:27:18,460 --> 00:27:20,980
implementing the key check function and

580
00:27:20,980 --> 00:27:23,220
all the variants that i've mentioned

581
00:27:23,220 --> 00:27:26,200
except cavity with which we are still

582
00:27:26,200 --> 00:27:30,340
tuning and we hope to release it soon

583
00:27:30,340 --> 00:27:34,510
this month hopefully so concretely what

584
00:27:34,510 --> 00:27:37,150
can you do first you can the simplest

585
00:27:37,150 --> 00:27:39,980
way is to make a library so we can just

586
00:27:39,980 --> 00:27:43,970
make lipcott check dot a and the prefix

587
00:27:43,970 --> 00:27:46,370
their generic 64 32 and so on that's

588
00:27:46,370 --> 00:27:48,679
really the flavor of the implementation

589
00:27:48,679 --> 00:27:52,039
we you wish to have so generic 64 is

590
00:27:52,039 --> 00:27:53,779
simply generically optimized

591
00:27:53,779 --> 00:27:56,230
implementation for 64-bit platforms

592
00:27:56,230 --> 00:27:58,970
generic 32 the same format for 32-bit

593
00:27:58,970 --> 00:28:01,460
platforms and then you can have some

594
00:28:01,460 --> 00:28:05,059
specific more specific set of of code

595
00:28:05,059 --> 00:28:09,230
for specific targets if you don't want

596
00:28:09,230 --> 00:28:12,590
to have a library just want to have the

597
00:28:12,590 --> 00:28:14,600
source files and to integrate them into

598
00:28:14,600 --> 00:28:17,029
your project you just do the same but

599
00:28:17,029 --> 00:28:18,830
with that back at the end and it will

600
00:28:18,830 --> 00:28:21,200
create an archive with all the files

601
00:28:21,200 --> 00:28:23,000
that you that you need for a given

602
00:28:23,000 --> 00:28:26,510
target then there are some more things

603
00:28:26,510 --> 00:28:29,720
you can do it it's a it comes with a

604
00:28:29,720 --> 00:28:31,580
complete set of unit tests and you can

605
00:28:31,580 --> 00:28:33,980
run this unit tests with ghachok tests

606
00:28:33,980 --> 00:28:36,350
you can say I want this or that test I

607
00:28:36,350 --> 00:28:38,419
want to have some speed measurements you

608
00:28:38,419 --> 00:28:41,269
can do that from the command line and of

609
00:28:41,269 --> 00:28:44,570
course you can extend that in any way

610
00:28:44,570 --> 00:28:49,490
you wish so let me give you some more

611
00:28:49,490 --> 00:28:53,149
details on how it's organized inside the

612
00:28:53,149 --> 00:28:55,789
sketchup could package so the idea is

613
00:28:55,789 --> 00:29:00,669
that we have one layer above that is

614
00:29:00,669 --> 00:29:02,779
implementing the modes and constructions

615
00:29:02,779 --> 00:29:05,570
in the more generic way so there is no

616
00:29:05,570 --> 00:29:08,289
optimization it's plain C code it's

617
00:29:08,289 --> 00:29:10,929
portable code and there is only one

618
00:29:10,929 --> 00:29:13,970
implementation the idea here is really

619
00:29:13,970 --> 00:29:18,470
to make the life of the user easy and

620
00:29:18,470 --> 00:29:20,809
there is nothing going on specifically

621
00:29:20,809 --> 00:29:25,610
for a specific target then there is this

622
00:29:25,610 --> 00:29:28,000
interface called state and permutation

623
00:29:28,000 --> 00:29:31,460
and below which you can hide the details

624
00:29:31,460 --> 00:29:34,700
of an implementation of a given of the

625
00:29:34,700 --> 00:29:36,980
permutation for a given platform and it

626
00:29:36,980 --> 00:29:39,230
will do all the state management so

627
00:29:39,230 --> 00:29:41,120
soaring bytes into it and applying of

628
00:29:41,120 --> 00:29:43,639
course the permutation you can then

629
00:29:43,639 --> 00:29:45,620
easily substitute one implementation

630
00:29:45,620 --> 00:29:48,379
below SNP with another that is more

631
00:29:48,379 --> 00:29:50,539
optimized for your given platform and

632
00:29:50,539 --> 00:29:52,650
everything above S&P will still

633
00:29:52,650 --> 00:29:58,830
which he'll work okay so I'm I will

634
00:29:58,830 --> 00:30:02,730
recap on what I mentioned before with

635
00:30:02,730 --> 00:30:06,720
some inventory so for hash functions and

636
00:30:06,720 --> 00:30:08,460
extendable output function so the

637
00:30:08,460 --> 00:30:10,860
generalization of hash functions to any

638
00:30:10,860 --> 00:30:12,600
output size we have some standard

639
00:30:12,600 --> 00:30:16,130
rock-solid instances so the Kshatriya

640
00:30:16,130 --> 00:30:18,840
instances the shake from 5202

641
00:30:18,840 --> 00:30:20,970
and then there's an ionization of shake

642
00:30:20,970 --> 00:30:24,750
with c shake in the latest standard

643
00:30:24,750 --> 00:30:26,460
sochi shake is like shake except that

644
00:30:26,460 --> 00:30:29,730
you can you have an extra input which is

645
00:30:29,730 --> 00:30:32,039
a customization string an advantage like

646
00:30:32,039 --> 00:30:34,409
you can have them in separation between

647
00:30:34,409 --> 00:30:36,990
different hash functions so if you put a

648
00:30:36,990 --> 00:30:38,789
different customization string you

649
00:30:38,789 --> 00:30:41,190
immediately get a new hash function with

650
00:30:41,190 --> 00:30:43,820
the output which that is independent of

651
00:30:43,820 --> 00:30:46,980
C shape with a different customization

652
00:30:46,980 --> 00:30:50,010
string double hash is also a

653
00:30:50,010 --> 00:30:52,980
generalization the idea here is that the

654
00:30:52,980 --> 00:30:55,380
input is just not one string of bits but

655
00:30:55,380 --> 00:30:58,559
it can be any number of of strings and

656
00:30:58,559 --> 00:31:01,110
of course then the result will not

657
00:31:01,110 --> 00:31:03,390
depend just on the concatenation of all

658
00:31:03,390 --> 00:31:05,309
the inputs but really on the exact

659
00:31:05,309 --> 00:31:09,179
sequence of inputs that you have you can

660
00:31:09,179 --> 00:31:12,000
have a set of string and then give you

661
00:31:12,000 --> 00:31:14,299
that as as input - 2 / -

662
00:31:14,299 --> 00:31:18,120
pahala as I mentioned is the 3 hushing

663
00:31:18,120 --> 00:31:20,250
mode that has been standardized by NIST

664
00:31:20,250 --> 00:31:24,000
and then can go 12 the more the faster

665
00:31:24,000 --> 00:31:28,289
version then something I didn't mention

666
00:31:28,289 --> 00:31:31,440
explicitly but another useful uncute

667
00:31:31,440 --> 00:31:33,899
application of hash functions is absurd

668
00:31:33,899 --> 00:31:36,120
Oh handle number generation so the

669
00:31:36,120 --> 00:31:37,890
purpose of PRNG

670
00:31:37,890 --> 00:31:41,399
is if you have some random bits at the

671
00:31:41,399 --> 00:31:43,919
input but these bits are not well

672
00:31:43,919 --> 00:31:46,559
balanced maybe in this case clearly

673
00:31:46,559 --> 00:31:50,279
there is a bias and you want to turn

674
00:31:50,279 --> 00:31:54,029
that into a sequence of bits that really

675
00:31:54,029 --> 00:31:56,490
look random uniformly distributed then

676
00:31:56,490 --> 00:31:59,429
the PRNG can can do that so in the

677
00:31:59,429 --> 00:32:00,929
Quecha code package we also implemented

678
00:32:00,929 --> 00:32:05,620
kajak PRG which is based on our sac 2011

679
00:32:05,620 --> 00:32:09,289
proposal and it has some some extra

680
00:32:09,289 --> 00:32:11,899
features if you have more seeds that

681
00:32:11,899 --> 00:32:14,570
come in you can at any time add them so

682
00:32:14,570 --> 00:32:16,940
that they get mixed to the state and

683
00:32:16,940 --> 00:32:20,210
then your output will depend on them and

684
00:32:20,210 --> 00:32:23,120
the second feature is forward secrecy so

685
00:32:23,120 --> 00:32:25,490
at any given time you can say okay

686
00:32:25,490 --> 00:32:29,360
forget the past and if you're stating is

687
00:32:29,360 --> 00:32:31,850
compromised if let's say the PC is

688
00:32:31,850 --> 00:32:34,130
generating secret keys and at some point

689
00:32:34,130 --> 00:32:36,049
the memory is recovered by by an attack

690
00:32:36,049 --> 00:32:38,269
then the attacker cannot go back this

691
00:32:38,269 --> 00:32:41,240
point so it's irreversible and cannot

692
00:32:41,240 --> 00:32:43,240
find the secret keys that have been

693
00:32:43,240 --> 00:32:47,769
derived using this function before this

694
00:32:47,769 --> 00:32:52,519
irreversible operation an authentication

695
00:32:52,519 --> 00:32:56,210
there is chemic part of the SP 800 185

696
00:32:56,210 --> 00:32:58,580
of course you could use H Mac with

697
00:32:58,580 --> 00:33:02,539
shatori but that's reserved optimal not

698
00:33:02,539 --> 00:33:05,679
a good idea you can use key XO chiaki's

699
00:33:05,679 --> 00:33:07,700
authenticate the encryption but you can

700
00:33:07,700 --> 00:33:11,299
use it also for simple Mac and then this

701
00:33:11,299 --> 00:33:13,820
cavity a new construction can be used

702
00:33:13,820 --> 00:33:17,539
also for authentication and then

703
00:33:17,539 --> 00:33:18,980
authenticate the encryption of course

704
00:33:18,980 --> 00:33:21,860
sketchy o'ciock and then all the flavors

705
00:33:21,860 --> 00:33:25,539
of cavity that I mentioned earlier and

706
00:33:25,539 --> 00:33:27,889
that's all I wanted to say so if you

707
00:33:27,889 --> 00:33:32,799
have any questions please feel free

708
00:33:33,100 --> 00:33:42,619
[Applause]

709
00:33:45,029 --> 00:33:52,419
and I thank you for this talk yep I had

710
00:33:52,419 --> 00:33:55,649
some new big questions about rehashing

711
00:33:55,649 --> 00:33:59,350
you mention here that parallel hash has

712
00:33:59,350 --> 00:34:03,239
been standardized during the competition

713
00:34:03,239 --> 00:34:06,580
the Kshatriya competition I was

714
00:34:06,580 --> 00:34:08,440
wondering if there is another word

715
00:34:08,440 --> 00:34:11,290
coming up because I remember some draft

716
00:34:11,290 --> 00:34:14,799
and an estimating list about the

717
00:34:14,799 --> 00:34:18,159
specific triaging mode and when you go

718
00:34:18,159 --> 00:34:20,079
to the to the website to the Tkaczyk

719
00:34:20,079 --> 00:34:22,780
website there is a link with a paper

720
00:34:22,780 --> 00:34:26,679
describing the generic trashing and and

721
00:34:26,679 --> 00:34:29,679
that new hashing word that you may be

722
00:34:29,679 --> 00:34:33,280
building so I was wondering where where

723
00:34:33,280 --> 00:34:40,000
this is at and also where kangaroo 12

724
00:34:40,000 --> 00:34:43,270
which is new to me where distance does

725
00:34:43,270 --> 00:34:45,790
this hole is this also relevant to the

726
00:34:45,790 --> 00:34:49,839
tree opened with the parallel things so

727
00:34:49,839 --> 00:34:53,409
in the slide if you could for meetings

728
00:34:53,409 --> 00:34:57,430
okay so as far as I know only pahala -

729
00:34:57,430 --> 00:35:00,010
has been and has been standardized it's

730
00:35:00,010 --> 00:35:01,960
true that we've we've worked on triaging

731
00:35:01,960 --> 00:35:04,480
for quite some time and we proposed many

732
00:35:04,480 --> 00:35:07,660
different flavors of triaging what has

733
00:35:07,660 --> 00:35:09,099
been standardized is just a subset of

734
00:35:09,099 --> 00:35:10,990
that we'll of course you can do any kind

735
00:35:10,990 --> 00:35:11,819
of triaging

736
00:35:11,819 --> 00:35:14,859
if you use Sakuraba coding then you can

737
00:35:14,859 --> 00:35:17,980
it's easy because then you can devise

738
00:35:17,980 --> 00:35:20,470
any tree topology that you that you like

739
00:35:20,470 --> 00:35:22,480
that fits well with your application and

740
00:35:22,480 --> 00:35:23,980
then you're sure that the resulting

741
00:35:23,980 --> 00:35:27,700
function is secure about kangaroo 12 a

742
00:35:27,700 --> 00:35:29,829
design decision that we made is to have

743
00:35:29,829 --> 00:35:32,440
just one instance so can go 12 there is

744
00:35:32,440 --> 00:35:34,780
no parameterization the the tree

745
00:35:34,780 --> 00:35:37,270
topology is fixed so that there is no

746
00:35:37,270 --> 00:35:39,190
choice that it's easier for the user

747
00:35:39,190 --> 00:35:41,339
there is just one one-size-fits-all

748
00:35:41,339 --> 00:35:43,660
choice for kangaroo 20

749
00:35:43,660 --> 00:35:48,720
I know if it answers your questions

750
00:36:00,710 --> 00:36:04,830
how does it work with the lost bits so

751
00:36:04,830 --> 00:36:07,260
the every next iteration of the

752
00:36:07,260 --> 00:36:10,440
encryption the depends on the previous

753
00:36:10,440 --> 00:36:13,590
ones so this is like well hash algorithm

754
00:36:13,590 --> 00:36:16,920
but if some bits are lost I've I've seen

755
00:36:16,920 --> 00:36:19,260
this this forward secrecy or you can

756
00:36:19,260 --> 00:36:21,330
reseed it at any any moment in time

757
00:36:21,330 --> 00:36:23,520
but if some bits are lost of the

758
00:36:23,520 --> 00:36:29,370
ciphertext does it magically heal itself

759
00:36:29,370 --> 00:36:32,550
like to decrypt the text I'm not sure I

760
00:36:32,550 --> 00:36:34,740
understood the question okay is there

761
00:36:34,740 --> 00:36:40,410
any okay you have the ciphertext which

762
00:36:40,410 --> 00:36:43,260
which is like well yes I for text

763
00:36:43,260 --> 00:36:45,480
basically but if some bits being lost

764
00:36:45,480 --> 00:36:50,340
with the on the decryption well

765
00:36:50,340 --> 00:36:52,710
basically if some some parts of the

766
00:36:52,710 --> 00:36:56,940
ciphertext are lost and then then you

767
00:36:56,940 --> 00:36:58,800
get this synchronized and yeah you

768
00:36:58,800 --> 00:37:01,950
cannot recover okay now there are ways

769
00:37:01,950 --> 00:37:04,230
to to have some synchronous stream

770
00:37:04,230 --> 00:37:08,030
ciphers but that's not the case of

771
00:37:11,240 --> 00:37:15,190
I believe a AES encryption has been

772
00:37:15,190 --> 00:37:18,260
implemented in modern CPU architectures

773
00:37:18,260 --> 00:37:23,180
is the folding function of Kecak is it

774
00:37:23,180 --> 00:37:24,950
possible to implement that and is there

775
00:37:24,950 --> 00:37:32,420
any work in in in that regard so your

776
00:37:32,420 --> 00:37:33,770
question was about hardware

777
00:37:33,770 --> 00:37:37,900
implementations of a check yes okay so

778
00:37:37,900 --> 00:37:41,119
yeah I did I didn't mention this but of

779
00:37:41,119 --> 00:37:43,700
course a check was actually designed in

780
00:37:43,700 --> 00:37:45,800
a way that it can be extremely efficient

781
00:37:45,800 --> 00:37:49,640
in Hardware either for a given size of

782
00:37:49,640 --> 00:37:53,720
circuit it can be really fast or it can

783
00:37:53,720 --> 00:37:55,040
consume less energy

784
00:37:55,040 --> 00:37:57,830
well bit then well let's say than the

785
00:37:57,830 --> 00:38:01,190
other shut refinanced I don't know if it

786
00:38:01,190 --> 00:38:04,240
answers your question

787
00:38:07,950 --> 00:38:12,720
for instance with the Bitcoin - Asics

788
00:38:12,720 --> 00:38:16,769
for sha-2 have been built is it is the

789
00:38:16,769 --> 00:38:19,369
same thing possible with ketchup

790
00:38:19,369 --> 00:38:23,430
yeah I suppose I think yeah we didn't

791
00:38:23,430 --> 00:38:26,329
Taylor get check for Bitcoin like

792
00:38:26,329 --> 00:38:31,039
applications of course in this case if

793
00:38:31,039 --> 00:38:34,710
there will be a cost to do some mining

794
00:38:34,710 --> 00:38:37,500
and I suppose that economically the

795
00:38:37,500 --> 00:38:39,930
threshold will automatically raise where

796
00:38:39,930 --> 00:38:43,559
the the cost of electricity is at a

797
00:38:43,559 --> 00:38:46,529
given point is not economically

798
00:38:46,529 --> 00:38:48,750
interesting anymore so that I think even

799
00:38:48,750 --> 00:38:54,750
if a check is more efficient in our way

800
00:38:54,750 --> 00:38:56,730
for Bitcoin like applications it will

801
00:38:56,730 --> 00:38:58,769
not matter because the bar will be

802
00:38:58,769 --> 00:39:00,440
raised in at some point it becomes

803
00:39:00,440 --> 00:39:03,119
economically not interesting to do more

804
00:39:03,119 --> 00:39:06,630
- but I'm not really familiar with bit

805
00:39:06,630 --> 00:39:13,980
going to be honest other plans to

806
00:39:13,980 --> 00:39:20,099
include cataract with TLS I haven't

807
00:39:20,099 --> 00:39:23,880
followed TLS closely I think TLS still

808
00:39:23,880 --> 00:39:28,950
uses not shut - I don't know exactly why

809
00:39:28,950 --> 00:39:34,019
but I hope that someday they switch to -

810
00:39:34,019 --> 00:39:35,849
Kshatriya and not something designed by

811
00:39:35,849 --> 00:39:38,450
the NSA

812
00:40:03,810 --> 00:40:05,740
thank you very much

813
00:40:05,740 --> 00:40:14,160
[Applause]

