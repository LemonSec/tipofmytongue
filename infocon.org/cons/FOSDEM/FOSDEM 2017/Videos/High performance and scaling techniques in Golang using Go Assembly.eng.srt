1
00:00:00,290 --> 00:00:03,710
[Applause]

2
00:00:05,430 --> 00:00:08,650
okay yeah I'd like to speak about you

3
00:00:08,650 --> 00:00:09,969
know some high-performance and scaling

4
00:00:09,969 --> 00:00:12,480
techniques that we've been doing in

5
00:00:12,480 --> 00:00:17,230
golang small breakdown of the

6
00:00:17,230 --> 00:00:19,240
presentation a few slides about myself

7
00:00:19,240 --> 00:00:22,590
and some work that we do with many oh

8
00:00:22,590 --> 00:01:00,340
and you understand you're not better

9
00:01:00,340 --> 00:01:02,649
like this okay great

10
00:01:02,649 --> 00:01:07,950
so a little intro about myself and Mineo

11
00:01:07,950 --> 00:01:10,390
then I'd like to speak sort of in

12
00:01:10,390 --> 00:01:13,090
general a little bit about the goal line

13
00:01:13,090 --> 00:01:14,979
or plane line assembly capabilities that

14
00:01:14,979 --> 00:01:18,220
go offers then discuss two sort of

15
00:01:18,220 --> 00:01:20,229
projects that we've done with this so

16
00:01:20,229 --> 00:01:22,240
Blake to be acceleration and sha-256

17
00:01:22,240 --> 00:01:24,369
acceleration and finally some slides

18
00:01:24,369 --> 00:01:26,650
about some yeah distributed syncing

19
00:01:26,650 --> 00:01:31,360
stuff that we've been doing one slide

20
00:01:31,360 --> 00:01:34,420
about myself I've been mostly doing

21
00:01:34,420 --> 00:01:35,799
server development in sort of what's

22
00:01:35,799 --> 00:01:37,510
called the medical imaging space so that

23
00:01:37,510 --> 00:01:40,720
relates you like CT NMR images from

24
00:01:40,720 --> 00:01:45,250
scanners both 2d 3d as well as using GPU

25
00:01:45,250 --> 00:01:48,040
techniques and the last few years been

26
00:01:48,040 --> 00:01:50,530
involved in cloud computing and I'm now

27
00:01:50,530 --> 00:01:55,509
with with Mineo Mineo as maybe some of

28
00:01:55,509 --> 00:01:59,770
you know is an Amazon s3 compatible yo

29
00:01:59,770 --> 00:02:03,400
piak storage server it is written in

30
00:02:03,400 --> 00:02:06,670
goaling and the Apache 2.0 license the

31
00:02:06,670 --> 00:02:08,348
company was actually founded by a nun

32
00:02:08,348 --> 00:02:10,929
Babu Parrish Yami who maybe some of you

33
00:02:10,929 --> 00:02:13,420
know as one of the guys behind the

34
00:02:13,420 --> 00:02:16,450
Gloucester fs system which is in itself

35
00:02:16,450 --> 00:02:18,430
a distributed

36
00:02:18,430 --> 00:02:21,400
file system which is now part of redhead

37
00:02:21,400 --> 00:02:26,109
actually if you look at Mineo itself

38
00:02:26,109 --> 00:02:28,989
there's actually sort of really yeah one

39
00:02:28,989 --> 00:02:31,840
one project one binary but you can run

40
00:02:31,840 --> 00:02:34,030
it in sort of three different flavors so

41
00:02:34,030 --> 00:02:37,540
the simplest version is simply run mini

42
00:02:37,540 --> 00:02:39,760
o server with a single directory and

43
00:02:39,760 --> 00:02:41,950
then you know all your objects will be

44
00:02:41,950 --> 00:02:44,049
stored underneath this directory

45
00:02:44,049 --> 00:02:48,879
structure and they're also two other

46
00:02:48,879 --> 00:02:51,250
versions that use a technique that is

47
00:02:51,250 --> 00:02:53,950
called erasure coding so what this

48
00:02:53,950 --> 00:02:56,169
essentially does is all the objects are

49
00:02:56,169 --> 00:02:58,989
split up into both like data chunks and

50
00:02:58,989 --> 00:03:03,370
parity chunks and split over yeah

51
00:03:03,370 --> 00:03:07,079
multiple discs or multiple servers and

52
00:03:07,079 --> 00:03:10,329
the Mineo server actually the Excel

53
00:03:10,329 --> 00:03:12,730
back-end which splits the data over

54
00:03:12,730 --> 00:03:16,450
multiple disks and goes from a minimum

55
00:03:16,450 --> 00:03:18,790
of four disks up to a maximum of 16

56
00:03:18,790 --> 00:03:22,629
disks and it also uses a technique that

57
00:03:22,629 --> 00:03:24,879
is called bit rot protection so this

58
00:03:24,879 --> 00:03:27,819
means that when the data is being read

59
00:03:27,819 --> 00:03:30,250
off the disk again which can be many

60
00:03:30,250 --> 00:03:33,220
years later than when it is stored a

61
00:03:33,220 --> 00:03:36,040
hash is computed to detect any yeah bit

62
00:03:36,040 --> 00:03:37,739
rot changes and if that happens then

63
00:03:37,739 --> 00:03:40,659
yeah we have other parity blocks to

64
00:03:40,659 --> 00:03:44,220
recommit reconstruct the original data

65
00:03:44,220 --> 00:03:46,629
but as you can imagine this bit rot

66
00:03:46,629 --> 00:03:48,340
protection is a very frequent operation

67
00:03:48,340 --> 00:03:50,739
so any data that's written to disk has

68
00:03:50,739 --> 00:03:52,810
just have to be computed and likewise

69
00:03:52,810 --> 00:03:54,939
when data is being read off the disk

70
00:03:54,939 --> 00:03:57,310
yeah the hash needs to be computed as

71
00:03:57,310 --> 00:04:00,970
well before we actually can return any

72
00:04:00,970 --> 00:04:04,060
any information to the client so that

73
00:04:04,060 --> 00:04:06,599
supreme

74
00:04:09,670 --> 00:04:11,569
operation for us and that's why we

75
00:04:11,569 --> 00:04:13,459
really looked at how can we get sort of

76
00:04:13,459 --> 00:04:15,170
the maximum performance in terms of

77
00:04:15,170 --> 00:04:17,630
hashing speeds while still you know

78
00:04:17,630 --> 00:04:20,120
having a solid proof and hashing

79
00:04:20,120 --> 00:04:24,350
technique so that's actually how we yeah

80
00:04:24,350 --> 00:04:29,720
there are like to be project but before

81
00:04:29,720 --> 00:04:32,990
I go into debt let me explain you a

82
00:04:32,990 --> 00:04:36,139
little bit about yeah sort of the the

83
00:04:36,139 --> 00:04:38,470
golang or plan nine assembly

84
00:04:38,470 --> 00:04:42,110
capabilities this is actually a an

85
00:04:42,110 --> 00:04:44,180
integrator or integral part of the whole

86
00:04:44,180 --> 00:04:50,810
go tool chain and it's actually it's

87
00:04:50,810 --> 00:04:52,940
kind of like a pseudo assembly language

88
00:04:52,940 --> 00:04:54,740
language in the sense that it's not a

89
00:04:54,740 --> 00:04:57,590
direct assembly that you would write for

90
00:04:57,590 --> 00:05:01,639
say an Intel platform an arm platform so

91
00:05:01,639 --> 00:05:04,280
there are some like generalized

92
00:05:04,280 --> 00:05:06,350
instructions for like a move and an ad

93
00:05:06,350 --> 00:05:09,919
and a compare and these instructions are

94
00:05:09,919 --> 00:05:12,020
then obviously translated to the actual

95
00:05:12,020 --> 00:05:13,280
instructions that will run on the

96
00:05:13,280 --> 00:05:16,820
underlying hardware platform most of the

97
00:05:16,820 --> 00:05:19,729
times it's kind of logical how like the

98
00:05:19,729 --> 00:05:21,289
pseudo a similar language translates

99
00:05:21,289 --> 00:05:23,660
into the underlying assembly running on

100
00:05:23,660 --> 00:05:27,680
the CPU itself sometimes yeah that is

101
00:05:27,680 --> 00:05:31,910
not the case so sometimes a little bit

102
00:05:31,910 --> 00:05:34,340
of trial and error there and also some

103
00:05:34,340 --> 00:05:36,430
architectural aspects of the underlying

104
00:05:36,430 --> 00:05:39,320
architecture they shine through so on

105
00:05:39,320 --> 00:05:40,789
the arm you have like conditional

106
00:05:40,789 --> 00:05:42,410
instructions and you can do that too and

107
00:05:42,410 --> 00:05:43,820
obviously on an Intel that will live

108
00:05:43,820 --> 00:05:47,630
that will not work also for instance

109
00:05:47,630 --> 00:05:50,840
data flows from left to right so if you

110
00:05:50,840 --> 00:05:54,260
do like a move you have a move r1 to r2

111
00:05:54,260 --> 00:05:58,220
it's actually r2 becomes our one and

112
00:05:58,220 --> 00:06:00,410
yeah like on the arm platform and the

113
00:06:00,410 --> 00:06:02,150
other way around so there are some

114
00:06:02,150 --> 00:06:05,539
things you have to be aware of there's

115
00:06:05,539 --> 00:06:08,000
also some yeah like pseudo registers so

116
00:06:08,000 --> 00:06:09,620
they're not actual registered but kind

117
00:06:09,620 --> 00:06:11,990
of like simulated registers for like

118
00:06:11,990 --> 00:06:13,849
frame pouring or stack pointer program

119
00:06:13,849 --> 00:06:15,790
counter

120
00:06:15,790 --> 00:06:19,090
and and also not all instructions that

121
00:06:19,090 --> 00:06:21,100
you would want to write are available

122
00:06:21,100 --> 00:06:24,430
however it is possible to also not use

123
00:06:24,430 --> 00:06:26,050
sort of the minimum expert used the

124
00:06:26,050 --> 00:06:28,330
actual op codes that will go into the

125
00:06:28,330 --> 00:06:30,610
assembly so if it's not available you

126
00:06:30,610 --> 00:06:37,780
can resort yeah to that if you talk

127
00:06:37,780 --> 00:06:39,010
about yeah what are sort of the

128
00:06:39,010 --> 00:06:41,200
advantages that you get with like

129
00:06:41,200 --> 00:06:43,810
assembly language and obviously yeah it

130
00:06:43,810 --> 00:06:45,580
sort of gives you the ability to get the

131
00:06:45,580 --> 00:06:47,530
maximum performance out of the the

132
00:06:47,530 --> 00:06:51,730
underlying hardware and also if you do

133
00:06:51,730 --> 00:06:54,400
this then yeah you still benefit from

134
00:06:54,400 --> 00:06:56,350
you know the nice quick and fast

135
00:06:56,350 --> 00:07:00,430
compilation that go offers you know to

136
00:07:00,430 --> 00:07:03,280
get like assembly into your code you can

137
00:07:03,280 --> 00:07:05,860
also use for instance the the Segoe

138
00:07:05,860 --> 00:07:09,330
route but yeah that has some

139
00:07:09,330 --> 00:07:13,090
disadvantages one is that yeah you need

140
00:07:13,090 --> 00:07:15,310
to have the C go yeah

141
00:07:15,310 --> 00:07:17,740
available it takes longer to compile

142
00:07:17,740 --> 00:07:19,530
because again it's more like a C style

143
00:07:19,530 --> 00:07:22,450
compile that that happens and also when

144
00:07:22,450 --> 00:07:25,360
you call in to that code then now there

145
00:07:25,360 --> 00:07:26,920
is some runtime overhead because all the

146
00:07:26,920 --> 00:07:28,420
stack needs to be saved and everything

147
00:07:28,420 --> 00:07:33,160
and if you ride your own assembly yeah

148
00:07:33,160 --> 00:07:36,820
you don't have that dead overhead and

149
00:07:36,820 --> 00:07:40,540
obviously if you use assembly you can

150
00:07:40,540 --> 00:07:43,600
take advantage of the SMI D instructions

151
00:07:43,600 --> 00:07:45,490
for Intel or the neon instructions that

152
00:07:45,490 --> 00:07:49,360
are available on on arm it's maybe a

153
00:07:49,360 --> 00:07:51,370
little bit kind of a word of caution is

154
00:07:51,370 --> 00:07:53,410
that you yeah you are a bit on your own

155
00:07:53,410 --> 00:07:54,880
if you do this kind of stuff the

156
00:07:54,880 --> 00:07:56,980
documentation is kind of limited and

157
00:07:56,980 --> 00:07:59,440
little bit sparse there is a

158
00:07:59,440 --> 00:08:01,720
considerable amount of kind of example

159
00:08:01,720 --> 00:08:03,820
code and in in in the go p-- repository

160
00:08:03,820 --> 00:08:06,160
itself as well for stuff like new texas

161
00:08:06,160 --> 00:08:08,110
and some lower level stuff so actually

162
00:08:08,110 --> 00:08:10,210
if you grab for start out as in the go

163
00:08:10,210 --> 00:08:12,760
code you will see yeah a lot of examples

164
00:08:12,760 --> 00:08:16,120
there and yeah likewise we now have a

165
00:08:16,120 --> 00:08:18,010
few repositories where there's also some

166
00:08:18,010 --> 00:08:21,070
some go code in there and as an example

167
00:08:21,070 --> 00:08:23,530
basically this is actually yeah also a

168
00:08:23,530 --> 00:08:25,030
file where you can sort of see the

169
00:08:25,030 --> 00:08:27,160
translation between this pseudo assembly

170
00:08:27,160 --> 00:08:27,599
Lang

171
00:08:27,599 --> 00:08:29,339
and the actual arm instructions as they

172
00:08:29,339 --> 00:08:35,509
are being being generated if you want to

173
00:08:35,509 --> 00:08:39,539
integrate yeah assembly into goaling

174
00:08:39,539 --> 00:08:45,089
then you have to use the dot s extension

175
00:08:45,089 --> 00:08:48,959
for yeah basically assembly and that is

176
00:08:48,959 --> 00:08:51,810
actually prepended by sort of an

177
00:08:51,810 --> 00:08:56,279
architecture yeah identifier so in this

178
00:08:56,279 --> 00:08:59,910
core RM 64 means that the assembly is

179
00:08:59,910 --> 00:09:03,319
for the arm 64 bit platform and likewise

180
00:09:03,319 --> 00:09:04,649
amd64

181
00:09:04,649 --> 00:09:07,920
will be for you know the intel or AMD 64

182
00:09:07,920 --> 00:09:11,790
bit platform and actually here is a

183
00:09:11,790 --> 00:09:13,920
snapshot of a repository it's a little

184
00:09:13,920 --> 00:09:17,459
bit hard to read but here actually you

185
00:09:17,459 --> 00:09:21,980
can see actually several versions for

186
00:09:21,980 --> 00:09:25,350
the amd64 platform because in this

187
00:09:25,350 --> 00:09:27,839
repository we actually have dedicated a

188
00:09:27,839 --> 00:09:30,600
px to AVX and an SSE version and then

189
00:09:30,600 --> 00:09:32,819
there is an ARM version I'll talk a

190
00:09:32,819 --> 00:09:35,220
little bit more about sort of avx2 and

191
00:09:35,220 --> 00:09:40,639
AVX later on in the presentation

192
00:09:40,639 --> 00:09:44,790
so kind of one approach that has worked

193
00:09:44,790 --> 00:09:46,620
nicely for us is if you do this kind of

194
00:09:46,620 --> 00:09:51,029
stuff is to actually start out with you

195
00:09:51,029 --> 00:09:53,100
know an algorithm at the gold level

196
00:09:53,100 --> 00:09:56,850
itself because even if you do this then

197
00:09:56,850 --> 00:09:59,130
you are not likely to do all the work

198
00:09:59,130 --> 00:10:01,079
for all the different architectures that

199
00:10:01,079 --> 00:10:02,699
are out there so it always makes sense

200
00:10:02,699 --> 00:10:05,790
to have as a baseline sort of the

201
00:10:05,790 --> 00:10:09,269
functionality in and go itself and then

202
00:10:09,269 --> 00:10:12,029
sort of has you start to yeah translate

203
00:10:12,029 --> 00:10:15,149
that functionality into assembly what we

204
00:10:15,149 --> 00:10:16,949
sort of did is we started out kind of

205
00:10:16,949 --> 00:10:21,149
like with small bits and pieces and so

206
00:10:21,149 --> 00:10:23,430
you comment out most of the go code in

207
00:10:23,430 --> 00:10:26,420
your routine or class or whatever and

208
00:10:26,420 --> 00:10:29,160
then you start to translate small bits

209
00:10:29,160 --> 00:10:32,189
and pieces into assembly maybe initially

210
00:10:32,189 --> 00:10:34,170
starting just with passing in the

211
00:10:34,170 --> 00:10:36,000
arguments and writing back some results

212
00:10:36,000 --> 00:10:38,880
making sure that all works and once you

213
00:10:38,880 --> 00:10:40,300
got it working then

214
00:10:40,300 --> 00:10:41,560
you know you gradually start to

215
00:10:41,560 --> 00:10:43,089
translate more and more if you go

216
00:10:43,089 --> 00:10:46,390
functionality into assembly and along

217
00:10:46,390 --> 00:10:50,290
the along the way yeah make tests

218
00:10:50,290 --> 00:10:52,990
whether the assembly functionality is

219
00:10:52,990 --> 00:10:57,370
equivalent to do the go assembly so

220
00:10:57,370 --> 00:10:58,660
actually if you look for instance at the

221
00:10:58,660 --> 00:11:00,870
commit history of the blade to be sm ID

222
00:11:00,870 --> 00:11:02,770
repository you may connect you can

223
00:11:02,770 --> 00:11:06,520
actually see how how we used this

224
00:11:06,520 --> 00:11:09,760
technique along the way we also

225
00:11:09,760 --> 00:11:12,459
developed a small utility called SM to

226
00:11:12,459 --> 00:11:17,380
plan 9s which actually generates byte

227
00:11:17,380 --> 00:11:20,440
sequence codes for op code or assembly

228
00:11:20,440 --> 00:11:21,910
instructions that are not natively

229
00:11:21,910 --> 00:11:25,690
supported yeah bye-bye go itself so

230
00:11:25,690 --> 00:11:29,950
actually it uses the new Yasim assembler

231
00:11:29,950 --> 00:11:31,899
sort of behind the scenes so what you do

232
00:11:31,899 --> 00:11:34,570
is you basically write your instruction

233
00:11:34,570 --> 00:11:38,050
as you would write it regularly in

234
00:11:38,050 --> 00:11:40,810
december or in assembly and then you run

235
00:11:40,810 --> 00:11:42,520
the tool on the file and then it will

236
00:11:42,520 --> 00:11:47,520
prepend that instruction with the actual

237
00:11:47,520 --> 00:11:51,100
yeah op codes that will go into the the

238
00:11:51,100 --> 00:11:54,150
byte stream that will be executed so

239
00:11:54,150 --> 00:12:00,130
that is yeah work nicely for us if you

240
00:12:00,130 --> 00:12:02,160
look at you know what we have done with

241
00:12:02,160 --> 00:12:05,970
yeah with assembly we've actually

242
00:12:05,970 --> 00:12:09,160
celebrated the Blake to be algorithm as

243
00:12:09,160 --> 00:12:13,330
well as sha-256 algorithm and we're

244
00:12:13,330 --> 00:12:17,550
planning to do one more piece work which

245
00:12:17,550 --> 00:12:20,350
has to do with this erasure coding which

246
00:12:20,350 --> 00:12:24,190
is actually called reed-solomon and this

247
00:12:24,190 --> 00:12:27,160
uses some what they call Galois field

248
00:12:27,160 --> 00:12:30,790
arithmetic polynomial multiplications

249
00:12:30,790 --> 00:12:34,000
and arm actually has a specific PML

250
00:12:34,000 --> 00:12:37,390
instruction so we want to use that

251
00:12:37,390 --> 00:12:40,000
instruction to accelerate the the

252
00:12:40,000 --> 00:12:41,160
reed-solomon

253
00:12:41,160 --> 00:12:44,290
computation of the de paraty blocks for

254
00:12:44,290 --> 00:12:47,680
arm for intel it is already yeah

255
00:12:47,680 --> 00:12:50,079
accelerated but we want to do the same

256
00:12:50,079 --> 00:12:52,820
for for the arm platform and

257
00:12:52,820 --> 00:12:56,470
maybe when there was a need in certain

258
00:12:56,470 --> 00:12:59,450
pieces of the code and yeah we'll likely

259
00:12:59,450 --> 00:13:04,130
do do more okay so the first technique

260
00:13:04,130 --> 00:13:06,320
that we celebrated is a hashing

261
00:13:06,320 --> 00:13:10,280
technique that is called Blake to be a

262
00:13:10,280 --> 00:13:13,520
Blake to be is a hashing technique it

263
00:13:13,520 --> 00:13:16,540
was actually there was like a sha-3

264
00:13:16,540 --> 00:13:19,730
competition a few years ago and they

265
00:13:19,730 --> 00:13:21,650
were one of the five I think final

266
00:13:21,650 --> 00:13:24,980
contenders in the end they were not

267
00:13:24,980 --> 00:13:30,170
selected but it is yeah a nice hashing

268
00:13:30,170 --> 00:13:32,330
technique with sort of the

269
00:13:32,330 --> 00:13:34,520
characteristics that it's yeah it's

270
00:13:34,520 --> 00:13:38,060
really focused on on speed as well as

271
00:13:38,060 --> 00:13:40,070
kind of like a relatively simple

272
00:13:40,070 --> 00:13:42,800
algorithm to implement while at the same

273
00:13:42,800 --> 00:13:45,560
time still offering sort of top of the

274
00:13:45,560 --> 00:13:48,620
top of the bill security and it's really

275
00:13:48,620 --> 00:13:53,270
optimized for 64-bit platforms so we

276
00:13:53,270 --> 00:13:56,960
developed a repository using the SMI D

277
00:13:56,960 --> 00:14:00,050
instructions to accelerate the new Blake

278
00:14:00,050 --> 00:14:04,250
to be algorithm and actually we did it

279
00:14:04,250 --> 00:14:06,260
in sort of three flavors so there's an

280
00:14:06,260 --> 00:14:09,530
ax - yeah implementation which is the

281
00:14:09,530 --> 00:14:12,110
fastest then there's an AV X and then

282
00:14:12,110 --> 00:14:13,790
there's an SSE implementation so

283
00:14:13,790 --> 00:14:17,150
depending on what your CPU support then

284
00:14:17,150 --> 00:14:19,550
obviously the highest level of SMI D

285
00:14:19,550 --> 00:14:21,500
instructions that are that is supported

286
00:14:21,500 --> 00:14:24,650
that one will be used but overall we

287
00:14:24,650 --> 00:14:26,920
were able to achieve close to like a 4x

288
00:14:26,920 --> 00:14:31,430
performance improvement over yeah go at

289
00:14:31,430 --> 00:14:35,440
the high level go functionality so yeah

290
00:14:35,440 --> 00:14:38,030
that helped us quite a bit because if

291
00:14:38,030 --> 00:14:40,220
you look at the table on the right you

292
00:14:40,220 --> 00:14:42,350
can it's a little bit too small but we

293
00:14:42,350 --> 00:14:45,500
can do about 850 megabytes per second

294
00:14:45,500 --> 00:14:48,290
with the Blake to be algorithm on an AV

295
00:14:48,290 --> 00:14:51,980
x 2 machine and this compares to

296
00:14:51,980 --> 00:14:55,329
if you look at sha-256 that is at like

297
00:14:55,329 --> 00:15:01,010
190 megabytes per second and sha-512 is

298
00:15:01,010 --> 00:15:04,339
at about 300 megabytes per second and as

299
00:15:04,339 --> 00:15:06,500
an object storage you can imagine if you

300
00:15:06,500 --> 00:15:10,010
have large blobs of data written on the

301
00:15:10,010 --> 00:15:13,089
disk then and again for us to be able to

302
00:15:13,089 --> 00:15:16,010
return like the first byte when people

303
00:15:16,010 --> 00:15:18,320
ask for for an object say if it's a one

304
00:15:18,320 --> 00:15:20,839
gigabyte object then having a factor of

305
00:15:20,839 --> 00:15:23,510
four there that means the difference

306
00:15:23,510 --> 00:15:26,209
between being able to return something

307
00:15:26,209 --> 00:15:28,430
within a second or within it taking four

308
00:15:28,430 --> 00:15:30,370
seconds so that's that's a pretty

309
00:15:30,370 --> 00:15:34,089
significant saving there and again so we

310
00:15:34,089 --> 00:15:36,680
developed this technique for the debate

311
00:15:36,680 --> 00:15:39,560
rot yeah detection mechanism that is

312
00:15:39,560 --> 00:15:44,149
part of of Mineo if you look a little

313
00:15:44,149 --> 00:15:46,870
bit closer at sort of how it works

314
00:15:46,870 --> 00:15:49,550
the top line those are actually there's

315
00:15:49,550 --> 00:15:51,680
a very small portion of all the kind of

316
00:15:51,680 --> 00:15:54,170
computations that are happening as part

317
00:15:54,170 --> 00:15:56,870
of the blake to be hashing so you know

318
00:15:56,870 --> 00:16:00,440
there's basically four yeah additions

319
00:16:00,440 --> 00:16:03,709
there and these are on 64-bit bit

320
00:16:03,709 --> 00:16:09,490
integers and if you look at the AVX

321
00:16:09,490 --> 00:16:12,740
ya capability for the Intel platform you

322
00:16:12,740 --> 00:16:16,130
can essentially work with 128-bit white

323
00:16:16,130 --> 00:16:18,440
registers so this allows you to do

324
00:16:18,440 --> 00:16:22,160
literally like two additions in parallel

325
00:16:22,160 --> 00:16:25,040
and this is kind of what you see here so

326
00:16:25,040 --> 00:16:28,640
with avx2 you use what I call the the

327
00:16:28,640 --> 00:16:32,029
xmm registers so again those are 28 bits

328
00:16:32,029 --> 00:16:34,640
white registers so essentially this

329
00:16:34,640 --> 00:16:36,620
means that where's here it's kind of

330
00:16:36,620 --> 00:16:39,709
like two lines you can do it here

331
00:16:39,709 --> 00:16:42,170
basically yeah in a single line and

332
00:16:42,170 --> 00:16:46,069
likewise at the second xmm instruction

333
00:16:46,069 --> 00:16:48,949
will also take care of two of these guys

334
00:16:48,949 --> 00:16:52,630
so you can sort of go from like for two

335
00:16:52,630 --> 00:16:55,040
instructions to like two instructions

336
00:16:55,040 --> 00:16:58,160
and if you go one step further

337
00:16:58,160 --> 00:17:02,840
AVX to extended the pipeline to

338
00:17:02,840 --> 00:17:08,089
yeah 256 bits wide which means that yeah

339
00:17:08,089 --> 00:17:11,390
you can use or do essentially for 64-bit

340
00:17:11,390 --> 00:17:13,579
editions with a single instruction so

341
00:17:13,579 --> 00:17:15,109
that's actually this guy and then here

342
00:17:15,109 --> 00:17:17,569
you use the ymm registers instead of the

343
00:17:17,569 --> 00:17:21,439
xmm registers and again those are 256

344
00:17:21,439 --> 00:17:23,780
bit instructions wide so in a way this

345
00:17:23,780 --> 00:17:25,099
kind of explains why there's kind of

346
00:17:25,099 --> 00:17:28,670
four times speed up between yeah like

347
00:17:28,670 --> 00:17:30,050
golang and avx2

348
00:17:30,050 --> 00:17:32,360
others there's a bit more there but I

349
00:17:32,360 --> 00:17:36,850
mean fundamentally this explains it

350
00:17:36,850 --> 00:17:40,990
quite a bit if you look at Blake to be

351
00:17:40,990 --> 00:17:43,640
the algorithm itself it actually has

352
00:17:43,640 --> 00:17:46,760
sort of twelve rounds of yeah working on

353
00:17:46,760 --> 00:17:50,060
the data this is kind of like the

354
00:17:50,060 --> 00:17:55,340
preamble where first the message is

355
00:17:55,340 --> 00:17:57,470
being read in then it's kind of shuffled

356
00:17:57,470 --> 00:18:00,140
around and then there are two sort of

357
00:18:00,140 --> 00:18:04,360
macros that actually do the actual like

358
00:18:04,360 --> 00:18:09,500
ignoring and adding and rotations of you

359
00:18:09,500 --> 00:18:13,910
know all the bits then there's like

360
00:18:13,910 --> 00:18:16,220
diagonalize macro there which kind of

361
00:18:16,220 --> 00:18:20,930
rotates values between the different

362
00:18:20,930 --> 00:18:22,030
[Music]

363
00:18:22,030 --> 00:18:24,650
values that you are working on then

364
00:18:24,650 --> 00:18:26,720
there is a second half where you load

365
00:18:26,720 --> 00:18:28,520
more from the message you shove a little

366
00:18:28,520 --> 00:18:31,460
again and you call the same macros again

367
00:18:31,460 --> 00:18:33,830
and finally you bend diagonal I so you

368
00:18:33,830 --> 00:18:40,150
sort of shift it back and if you look at

369
00:18:40,150 --> 00:18:43,250
yeah one of the macro so in this case

370
00:18:43,250 --> 00:18:46,360
this is the what's called the g1 macro

371
00:18:46,360 --> 00:18:48,920
it actually consists a little bit of

372
00:18:48,920 --> 00:18:51,920
like three columns so on the right side

373
00:18:51,920 --> 00:18:54,440
of the screen you kind of see the the

374
00:18:54,440 --> 00:18:57,590
high-level golang instruction then the

375
00:18:57,590 --> 00:19:00,500
the middle part of the screen you sort

376
00:19:00,500 --> 00:19:04,340
of see the the FEX instruction and then

377
00:19:04,340 --> 00:19:06,080
on the left side of the screen is the

378
00:19:06,080 --> 00:19:09,950
actual yeah up codes that are being

379
00:19:09,950 --> 00:19:14,390
written into the assembly stream and so

380
00:19:14,390 --> 00:19:16,190
actually what this guy does is here

381
00:19:16,190 --> 00:19:19,760
there's like no this is an addition this

382
00:19:19,760 --> 00:19:22,910
is like an XOR here you actually see a

383
00:19:22,910 --> 00:19:27,190
rotation but the Blake two algorithm has

384
00:19:27,190 --> 00:19:31,550
selected like shift values that nicely

385
00:19:31,550 --> 00:19:34,460
map on to ya the Intel Architecture so

386
00:19:34,460 --> 00:19:36,980
you can actually well it's shift over

387
00:19:36,980 --> 00:19:39,470
there it's actually a shuffle so you

388
00:19:39,470 --> 00:19:41,750
shuffle bytes around in between the

389
00:19:41,750 --> 00:19:43,700
registers so and then there's more

390
00:19:43,700 --> 00:19:46,490
additions more exhorting and then ya get

391
00:19:46,490 --> 00:19:48,920
another kind of rotation and this

392
00:19:48,920 --> 00:19:51,170
happens you know over and over again and

393
00:19:51,170 --> 00:19:53,000
then in a total of twelve rounds and

394
00:19:53,000 --> 00:19:57,110
that's you know how you get your your

395
00:19:57,110 --> 00:20:02,000
hash out there okay that was about the

396
00:20:02,000 --> 00:20:05,510
the Blake to be algorithm we've also

397
00:20:05,510 --> 00:20:11,290
done some work on ya sha-256 algorithm

398
00:20:11,290 --> 00:20:14,990
most notably also for the arm platform

399
00:20:14,990 --> 00:20:17,140
because the arm platform actually has

400
00:20:17,140 --> 00:20:20,440
specific instructions to cell rate

401
00:20:20,440 --> 00:20:25,850
sha-256 ya calculations and they make

402
00:20:25,850 --> 00:20:28,070
tremendous amount of difference because

403
00:20:28,070 --> 00:20:30,230
little literally is a hundred times

404
00:20:30,230 --> 00:20:32,960
faster than not using those instructions

405
00:20:32,960 --> 00:20:36,830
and actually intel also has instructions

406
00:20:36,830 --> 00:20:41,870
for sha-256 separations but they seem to

407
00:20:41,870 --> 00:20:43,940
be just defined in software and there

408
00:20:43,940 --> 00:20:45,710
seems to be no hardware implementations

409
00:20:45,710 --> 00:20:47,450
out there otherwise it would be nice to

410
00:20:47,450 --> 00:20:51,260
take advantage of of that as well but

411
00:20:51,260 --> 00:20:52,880
actually the table here at the bottom

412
00:20:52,880 --> 00:20:55,490
you can sort of see ya the speeds that

413
00:20:55,490 --> 00:20:58,130
we that we have an interest in speaking

414
00:20:58,130 --> 00:21:01,280
actually the arm just running at 1.2

415
00:21:01,280 --> 00:21:03,350
gigahertz is actually the quickest one

416
00:21:03,350 --> 00:21:05,720
out there so it does about 640 megabytes

417
00:21:05,720 --> 00:21:10,610
per second and then we ran some tests on

418
00:21:10,610 --> 00:21:13,910
online Intel Xeon a 2.4 gigahertz the

419
00:21:13,910 --> 00:21:14,510
avx2

420
00:21:14,510 --> 00:21:19,460
comes in at about 355 then a px is

421
00:21:19,460 --> 00:21:20,400
running

422
00:21:20,400 --> 00:21:24,090
300 SSE still a little bit lower than

423
00:21:24,090 --> 00:21:27,059
that and these are actually the the go

424
00:21:27,059 --> 00:21:31,790
versions so she do go on the Intel Xeon

425
00:21:31,790 --> 00:21:35,790
platform you get about 190 and the last

426
00:21:35,790 --> 00:21:43,470
one is the the ARM version if you look

427
00:21:43,470 --> 00:21:48,170
at you know how do you actually invoke

428
00:21:48,170 --> 00:21:52,950
assembly code from go you do you

429
00:21:52,950 --> 00:21:55,590
essentially define kind of a yeah the

430
00:21:55,590 --> 00:21:56,910
prototype of the function that you're

431
00:21:56,910 --> 00:22:01,460
going to call into so for most of this

432
00:22:01,460 --> 00:22:04,230
hashing technique you pass in like the

433
00:22:04,230 --> 00:22:06,929
digest that you start with and the

434
00:22:06,929 --> 00:22:08,970
message itself so the digest is

435
00:22:08,970 --> 00:22:13,020
basically just a slice of of 32-bit

436
00:22:13,020 --> 00:22:15,929
integers and the message is just a slice

437
00:22:15,929 --> 00:22:22,830
of bytes and here we actually yeah

438
00:22:22,830 --> 00:22:27,470
compute the eight yeah

439
00:22:27,470 --> 00:22:30,870
32-bit integers into the digest so

440
00:22:30,870 --> 00:22:34,580
that's this guy and then basically the

441
00:22:34,580 --> 00:22:36,809
actual message that you're going to hash

442
00:22:36,809 --> 00:22:39,929
is being passed in directly into what

443
00:22:39,929 --> 00:22:42,510
will be the the assembly code and then

444
00:22:42,510 --> 00:22:44,850
once you're done then actually the

445
00:22:44,850 --> 00:22:47,190
result is written in this guy so that is

446
00:22:47,190 --> 00:22:53,190
what you were what you returned and this

447
00:22:53,190 --> 00:22:57,150
is actually an arm example so the first

448
00:22:57,150 --> 00:23:00,270
line that's basically how you define the

449
00:23:00,270 --> 00:23:04,559
function in the assembly code and the

450
00:23:04,559 --> 00:23:07,470
first thing that you actually do is to

451
00:23:07,470 --> 00:23:09,630
read the parameters that were being

452
00:23:09,630 --> 00:23:13,890
passed in and this function takes two

453
00:23:13,890 --> 00:23:17,429
slices as as inputs and as maybe some of

454
00:23:17,429 --> 00:23:19,770
you know a slice is actually a structure

455
00:23:19,770 --> 00:23:23,520
with like three elements in it and the

456
00:23:23,520 --> 00:23:25,559
first element is a pointer to where the

457
00:23:25,559 --> 00:23:27,270
actual data is and the second is

458
00:23:27,270 --> 00:23:33,000
actually the length of the slice so what

459
00:23:33,000 --> 00:23:34,230
we're doing is

460
00:23:34,230 --> 00:23:36,390
the first few instructions were reading

461
00:23:36,390 --> 00:23:40,130
this here and because this is running on

462
00:23:40,130 --> 00:23:45,120
64-bit platform both slices in effect

463
00:23:45,120 --> 00:23:48,990
they take a total of 24 bytes so again

464
00:23:48,990 --> 00:23:51,630
it's three elements but each element is

465
00:23:51,630 --> 00:23:53,429
eight bytes long so the first

466
00:23:53,429 --> 00:23:57,120
instruction basically fetches a pointer

467
00:23:57,120 --> 00:24:00,090
to where the digest is and the second

468
00:24:00,090 --> 00:24:02,940
line fetch is a pointer to where the

469
00:24:02,940 --> 00:24:06,270
message is and then at the length of the

470
00:24:06,270 --> 00:24:09,360
message is being read at in the third

471
00:24:09,360 --> 00:24:12,480
statement so it's another eight bytes

472
00:24:12,480 --> 00:24:17,070
further then yeah the already 21 24

473
00:24:17,070 --> 00:24:21,000
bytes which point into the second slice

474
00:24:21,000 --> 00:24:25,320
that's being passed in and then further

475
00:24:25,320 --> 00:24:29,220
down here we do some initialization so

476
00:24:29,220 --> 00:24:32,970
here we load from x0 which corresponds

477
00:24:32,970 --> 00:24:39,870
to r0 the digest we also load obviously

478
00:24:39,870 --> 00:24:44,040
from the message itself and there's also

479
00:24:44,040 --> 00:24:47,400
a constant stable so we get a basically

480
00:24:47,400 --> 00:24:49,380
a reference to the constants table

481
00:24:49,380 --> 00:24:52,169
that's actually in r3 + r3 corresponds

482
00:24:52,169 --> 00:24:56,549
in neon to x3 so here we load values

483
00:24:56,549 --> 00:25:02,429
from the from a constant stable and this

484
00:25:02,429 --> 00:25:05,820
is actually sort of the main loop where

485
00:25:05,820 --> 00:25:11,540
the hashing is being done and again here

486
00:25:11,540 --> 00:25:18,150
r1 which is x1 is the pointer to yeah

487
00:25:18,150 --> 00:25:20,220
the message of here actually the values

488
00:25:20,220 --> 00:25:23,220
from the message are being read and well

489
00:25:23,220 --> 00:25:26,549
there's some some like positioning codes

490
00:25:26,549 --> 00:25:28,260
to make sure things are in kind of the

491
00:25:28,260 --> 00:25:30,960
right order and then these and these

492
00:25:30,960 --> 00:25:33,990
guys are actually the specialized arm

493
00:25:33,990 --> 00:25:35,429
instructions that give you know

494
00:25:35,429 --> 00:25:38,669
basically the hundred times speed up and

495
00:25:38,669 --> 00:25:39,840
then there's some more you know

496
00:25:39,840 --> 00:25:43,799
shuffling of data around but yeah all I

497
00:25:43,799 --> 00:25:45,150
have because these are specialized

498
00:25:45,150 --> 00:25:46,510
instructions the activist

499
00:25:46,510 --> 00:25:51,730
Lee is pretty pretty pretty short and

500
00:25:51,730 --> 00:25:57,000
then yeah this is like the end of the

501
00:25:57,000 --> 00:26:00,580
routine so again there's some yeah arm

502
00:26:00,580 --> 00:26:04,030
instructs or sha extensions instructions

503
00:26:04,030 --> 00:26:08,740
here and then here it's basically put

504
00:26:08,740 --> 00:26:13,960
into a V 1 and V V 0 and V 1 and here

505
00:26:13,960 --> 00:26:17,890
actually you write out the result in

506
00:26:17,890 --> 00:26:22,480
like register for 1 and V 1 into X 0

507
00:26:22,480 --> 00:26:24,760
which was the the pointer to the the

508
00:26:24,760 --> 00:26:27,190
digest and then you return out of there

509
00:26:27,190 --> 00:26:29,890
and obviously here well as long R 2 is

510
00:26:29,890 --> 00:26:31,960
the length of the message so you process

511
00:26:31,960 --> 00:26:34,570
64 bytes at a time and when when there's

512
00:26:34,570 --> 00:26:36,870
more work to go obviously you loop back

513
00:26:36,870 --> 00:26:42,160
so that's pretty much you know how ya a

514
00:26:42,160 --> 00:26:48,130
function like this looks a little bit if

515
00:26:48,130 --> 00:26:50,919
you look at some yeah some resources

516
00:26:50,919 --> 00:26:55,049
that we have that are out there actually

517
00:26:55,049 --> 00:26:58,630
as maybe some of you know some of the

518
00:26:58,630 --> 00:27:00,059
origins of the go

519
00:27:00,059 --> 00:27:03,429
yeah like architecture and work go back

520
00:27:03,429 --> 00:27:06,419
to the whole plan 9

521
00:27:06,419 --> 00:27:09,400
yeah worked that has been done and

522
00:27:09,400 --> 00:27:14,679
actually yeah some of the assembly yeah

523
00:27:14,679 --> 00:27:16,900
still originates back to that so some of

524
00:27:16,900 --> 00:27:20,860
the documentation out there is literally

525
00:27:20,860 --> 00:27:25,960
at the GPIO website so not everything in

526
00:27:25,960 --> 00:27:29,770
those URLs is kind of applicable most of

527
00:27:29,770 --> 00:27:31,809
it is but it's they're generally

528
00:27:31,809 --> 00:27:35,169
generally good resources to read through

529
00:27:35,169 --> 00:27:37,210
and get an understanding of how diesel

530
00:27:37,210 --> 00:27:39,850
works and Dyson together and then

531
00:27:39,850 --> 00:27:42,390
there's also like a high-level as some

532
00:27:42,390 --> 00:27:46,059
document and there's also some pointers

533
00:27:46,059 --> 00:27:48,460
forearms on pointers for Intel about you

534
00:27:48,460 --> 00:27:51,929
know how Neum instructions and you know

535
00:27:51,929 --> 00:27:57,270
AVX instructions work

536
00:27:58,070 --> 00:28:01,740
okay that was sort of the like the

537
00:28:01,740 --> 00:28:03,180
performance optimizations that we've

538
00:28:03,180 --> 00:28:09,620
done for ya hashing techniques we also

539
00:28:09,620 --> 00:28:12,360
did some work on something that we

540
00:28:12,360 --> 00:28:15,240
called a distributed syncing technique

541
00:28:15,240 --> 00:28:17,580
when I earlier talked about three

542
00:28:17,580 --> 00:28:21,090
flavors of Mineo that are there the the

543
00:28:21,090 --> 00:28:24,210
last one that was listed is called the

544
00:28:24,210 --> 00:28:27,480
distributed version and that's what we

545
00:28:27,480 --> 00:28:29,100
have two versions that can work with

546
00:28:29,100 --> 00:28:33,000
erasure coding and then distributing the

547
00:28:33,000 --> 00:28:36,240
data across multiple either discs for

548
00:28:36,240 --> 00:28:39,059
the Excel version or actually multiple

549
00:28:39,059 --> 00:28:42,230
servers for the distributed version and

550
00:28:42,230 --> 00:28:44,550
for the distributed version that can

551
00:28:44,550 --> 00:28:48,090
actually run from anywhere of a minimum

552
00:28:48,090 --> 00:28:50,700
of four servers up until a maximum of 16

553
00:28:50,700 --> 00:28:53,630
servers we needed to have a

554
00:28:53,630 --> 00:28:56,460
synchronization mechanism between the

555
00:28:56,460 --> 00:29:01,470
servers and yeah we also looked at some

556
00:29:01,470 --> 00:29:03,660
existing protocols and techniques out

557
00:29:03,660 --> 00:29:07,860
there but yeah we like in a technique

558
00:29:07,860 --> 00:29:11,460
like raft but we found that a little bit

559
00:29:11,460 --> 00:29:13,410
overkill for sort of what we were trying

560
00:29:13,410 --> 00:29:17,280
to do so we designed basically a pretty

561
00:29:17,280 --> 00:29:19,950
kind of minimalistic synchronization

562
00:29:19,950 --> 00:29:25,740
technique that works well for us the

563
00:29:25,740 --> 00:29:28,910
design goals that we wanted to have was

564
00:29:28,910 --> 00:29:33,630
basically keep the designs simple also

565
00:29:33,630 --> 00:29:35,550
meaning there's for instance no concept

566
00:29:35,550 --> 00:29:38,820
of like a master node because well if

567
00:29:38,820 --> 00:29:40,410
you have something with a master node

568
00:29:40,410 --> 00:29:42,540
and the master knows go down goes down

569
00:29:42,540 --> 00:29:44,820
then yeah you your whole system is down

570
00:29:44,820 --> 00:29:46,830
so you need to have backup master nodes

571
00:29:46,830 --> 00:29:48,720
and then you you already talked about

572
00:29:48,720 --> 00:29:51,570
two or three master nodes and it quickly

573
00:29:51,570 --> 00:29:53,309
starts to become you know more

574
00:29:53,309 --> 00:29:55,170
complicated and then what you initially

575
00:29:55,170 --> 00:29:57,929
think so in our system there's no

576
00:29:57,929 --> 00:30:00,030
concept of a master node so all the

577
00:30:00,030 --> 00:30:03,929
nodes are basically equal it's also

578
00:30:03,929 --> 00:30:06,539
resilient in the sense that

579
00:30:06,539 --> 00:30:10,529
if multiple servers go down yeah the

580
00:30:10,529 --> 00:30:13,169
system just continues to function so

581
00:30:13,169 --> 00:30:17,489
basically up to a total of yeah and over

582
00:30:17,489 --> 00:30:23,129
2-1 servers can be down so yeah you can

583
00:30:23,129 --> 00:30:28,679
continue to to function and yeah we also

584
00:30:28,679 --> 00:30:30,479
wanted it to be kind of like a drop-in

585
00:30:30,479 --> 00:30:33,809
replacement for the existing primitives

586
00:30:33,809 --> 00:30:35,669
that are there in the the goal language

587
00:30:35,669 --> 00:30:38,789
so the API or the interface is

588
00:30:38,789 --> 00:30:41,999
synonymous to the sync dot RW mutex and

589
00:30:41,999 --> 00:30:45,649
actually the sync dot locker interface

590
00:30:45,649 --> 00:30:50,119
as part of our requirements how we

591
00:30:50,119 --> 00:30:53,940
maximize sort of the maximum number of

592
00:30:53,940 --> 00:31:01,709
nodes to a total of 1516 you could

593
00:31:01,709 --> 00:31:03,539
actually if you wanted to push that

594
00:31:03,539 --> 00:31:06,499
number up a little bit but 16 is yeah

595
00:31:06,499 --> 00:31:12,209
good enough for us and how this works

596
00:31:12,209 --> 00:31:14,309
behind the scene is that all servers

597
00:31:14,309 --> 00:31:16,409
basically have a connection to all of

598
00:31:16,409 --> 00:31:18,989
the other servers and when one of the

599
00:31:18,989 --> 00:31:20,849
nodes asks for a lock it basically

600
00:31:20,849 --> 00:31:22,469
contacts all the other nodes

601
00:31:22,469 --> 00:31:26,309
and when a majority of the nodes yeah

602
00:31:26,309 --> 00:31:30,059
return back the lock then yeah the lock

603
00:31:30,059 --> 00:31:32,459
is grounded on that particular machine

604
00:31:32,459 --> 00:31:34,709
and when you release it again it sends

605
00:31:34,709 --> 00:31:38,059
out release messages and so it's

606
00:31:38,059 --> 00:31:42,869
relatively simple but yeah for us it it

607
00:31:42,869 --> 00:31:47,129
it works quite well here as an example

608
00:31:47,129 --> 00:31:49,609
maybe a little bit difficult to read but

609
00:31:49,609 --> 00:31:53,240
again the API is

610
00:31:53,240 --> 00:31:56,910
compatible with the regular RW vo-tech

611
00:31:56,910 --> 00:31:58,559
so basically this is an example where

612
00:31:58,559 --> 00:32:04,380
you just create a mutex and well then

613
00:32:04,380 --> 00:32:06,809
you lock it twice then there's some go

614
00:32:06,809 --> 00:32:09,090
routines that after one in two seconds

615
00:32:09,090 --> 00:32:13,410
unlock the read lock and then here you

616
00:32:13,410 --> 00:32:15,120
try to acquire a write lock and

617
00:32:15,120 --> 00:32:16,410
obviously the write lock and only be

618
00:32:16,410 --> 00:32:19,110
granted when both of the read locks that

619
00:32:19,110 --> 00:32:22,620
were earlier granted were released so

620
00:32:22,620 --> 00:32:25,110
you can sort of see here that so it's

621
00:32:25,110 --> 00:32:26,970
acquiring wheat loved one we'd like to

622
00:32:26,970 --> 00:32:29,130
and then it's trying to acquire the the

623
00:32:29,130 --> 00:32:31,880
right lock but it will block here until

624
00:32:31,880 --> 00:32:34,440
both first the first wheat lock and

625
00:32:34,440 --> 00:32:37,380
second read lock are released and only

626
00:32:37,380 --> 00:32:40,860
then will it require the right lock and

627
00:32:40,860 --> 00:32:42,299
obviously running this on a single

628
00:32:42,299 --> 00:32:44,039
machine it's not really the point but

629
00:32:44,039 --> 00:32:48,059
you can just as well create basically

630
00:32:48,059 --> 00:32:52,140
three of these names mutex on three

631
00:32:52,140 --> 00:32:54,570
machines and then when one read lock on

632
00:32:54,570 --> 00:32:55,980
one machine and under we'd look on

633
00:32:55,980 --> 00:32:57,870
another machine and the write on the

634
00:32:57,870 --> 00:32:59,510
third machine and then heard the whole

635
00:32:59,510 --> 00:33:02,340
sequence of events would be would be

636
00:33:02,340 --> 00:33:09,750
identical in terms of like performance

637
00:33:09,750 --> 00:33:13,440
on a 16 note configuration we were able

638
00:33:13,440 --> 00:33:16,049
to do like seven and a half thousand

639
00:33:16,049 --> 00:33:20,700
locks per seconds and then it takes

640
00:33:20,700 --> 00:33:23,549
about sort of ten ten percent CPU usage

641
00:33:23,549 --> 00:33:27,960
on like a you know a regular server and

642
00:33:27,960 --> 00:33:30,900
typically a lock is granted within like

643
00:33:30,900 --> 00:33:34,890
one millisecond so this quite nicely met

644
00:33:34,890 --> 00:33:37,169
basically our requirement in terms of

645
00:33:37,169 --> 00:33:40,289
you know an object storage and opx

646
00:33:40,289 --> 00:33:41,970
torrents does not have the requirement

647
00:33:41,970 --> 00:33:43,799
that you know you you're gonna write

648
00:33:43,799 --> 00:33:47,370
like a hundred thousand objects to it in

649
00:33:47,370 --> 00:33:49,200
like a second so maybe for something

650
00:33:49,200 --> 00:33:51,900
like a key value store this wouldn't

651
00:33:51,900 --> 00:33:54,690
work but in our case it quite nicely met

652
00:33:54,690 --> 00:33:58,650
our requirements and it's nicely bundled

653
00:33:58,650 --> 00:34:00,020
with

654
00:34:00,020 --> 00:34:04,340
distribution and actually here's a

655
00:34:04,340 --> 00:34:07,790
pointer to the the repository and we

656
00:34:07,790 --> 00:34:10,550
also on our block we have a blog post

657
00:34:10,550 --> 00:34:14,750
about this with some more details so

658
00:34:14,750 --> 00:34:17,690
that pretty much brings me to the end of

659
00:34:17,690 --> 00:34:19,429
my presentation thank you for your

660
00:34:19,429 --> 00:34:20,810
attention

661
00:34:20,810 --> 00:34:30,420
[Applause]

662
00:34:31,090 --> 00:34:34,880
so I have a question so you're using

663
00:34:34,880 --> 00:34:39,260
blake to detect big bead rot and then

664
00:34:39,260 --> 00:34:41,120
you have performance problems but Blake

665
00:34:41,120 --> 00:34:43,429
is a secure hush so why don't you use an

666
00:34:43,429 --> 00:34:45,409
error detecting code which is probably

667
00:34:45,409 --> 00:34:47,418
much much cheaper instead of using a

668
00:34:47,418 --> 00:34:50,929
secure hash and then what do you mean by

669
00:34:50,929 --> 00:34:55,250
an actually something like reed-solomon

670
00:34:55,250 --> 00:34:57,530
or probably humming or I don't know

671
00:34:57,530 --> 00:34:59,480
something which is cheaper

672
00:34:59,480 --> 00:35:01,820
wait Sullivan doesn't give you bit rod I

673
00:35:01,820 --> 00:35:06,680
mean it detects bit flips so well maybe

674
00:35:06,680 --> 00:35:09,440
maybe reed-solomon I can do more I have

675
00:35:09,440 --> 00:35:11,540
to look at that but Hamming codes for

676
00:35:11,540 --> 00:35:13,220
example detect errors and there are much

677
00:35:13,220 --> 00:35:17,320
better suited codes for detecting flip

678
00:35:17,320 --> 00:35:21,440
bit flips no the problem is there's

679
00:35:21,440 --> 00:35:26,600
there's 30 blocks computed in

680
00:35:26,600 --> 00:35:29,800
reed-solomon that imagine you have for

681
00:35:29,800 --> 00:35:33,200
two data blocks and to parity blocks and

682
00:35:33,200 --> 00:35:35,390
when you lose say two disks so you're

683
00:35:35,390 --> 00:35:38,720
down to two blocks then if you just have

684
00:35:38,720 --> 00:35:40,880
two blocks you have no way to determine

685
00:35:40,880 --> 00:35:42,710
anymore whether there's bit water or not

686
00:35:42,710 --> 00:35:44,630
so you're right if you still have all

687
00:35:44,630 --> 00:35:48,050
the data and parity blocks available you

688
00:35:48,050 --> 00:35:50,690
could work out whether a block that you

689
00:35:50,690 --> 00:35:52,970
read off the disk has not been unchanged

690
00:35:52,970 --> 00:35:55,370
but it would be not easy to do so and

691
00:35:55,370 --> 00:35:57,590
when you lose those discs so you're down

692
00:35:57,590 --> 00:35:59,960
to the absolute minimum that you need in

693
00:35:59,960 --> 00:36:02,200
order to be able to reconstruct then

694
00:36:02,200 --> 00:36:05,300
yeah then you have no way to detect bit

695
00:36:05,300 --> 00:36:08,000
what we we talk about this later I don't

696
00:36:08,000 --> 00:36:10,660
agree yet but

697
00:36:13,400 --> 00:36:17,069
hey you mentioned that this code doesn't

698
00:36:17,069 --> 00:36:20,160
rely on C go is there any complication

699
00:36:20,160 --> 00:36:24,049
at all comparing these kind of programs

700
00:36:27,140 --> 00:36:32,099
well is there any complication comparing

701
00:36:32,099 --> 00:36:34,140
this program or is it just a go build

702
00:36:34,140 --> 00:36:36,119
and that's all that's it if you do go

703
00:36:36,119 --> 00:36:38,400
get you will get all the repositories

704
00:36:38,400 --> 00:36:41,549
and it just builds normally and yes yeah

705
00:36:41,549 --> 00:36:43,770
you just need to have the go chain okay

706
00:36:43,770 --> 00:36:46,770
installed but no special other options

707
00:36:46,770 --> 00:36:49,440
or features of the go-to chain okay it

708
00:36:49,440 --> 00:36:51,240
will just adapt to the to the platform

709
00:36:51,240 --> 00:36:54,619
to the CPU yeah great

710
00:36:54,619 --> 00:37:00,510
any other questions no thank you Oh

711
00:37:00,510 --> 00:37:02,270
coming

712
00:37:02,270 --> 00:37:04,560
[Music]

713
00:37:04,560 --> 00:37:11,480
I was just wondering how did you ride

714
00:37:11,480 --> 00:37:13,380
the assembly

715
00:37:13,380 --> 00:37:15,480
I mean you showed us all these opcodes

716
00:37:15,480 --> 00:37:18,000
did you use some other assembler and

717
00:37:18,000 --> 00:37:23,100
then extract this or how did you that

718
00:37:23,100 --> 00:37:27,960
for that we developed basically this

719
00:37:27,960 --> 00:37:32,550
tool so we developed this SM to play 9s

720
00:37:32,550 --> 00:37:35,400
tool which is also here you see the

721
00:37:35,400 --> 00:37:38,490
repository so basically this is what you

722
00:37:38,490 --> 00:37:41,280
write in your assembly file and then you

723
00:37:41,280 --> 00:37:44,430
run SM to plan 9 F on this file and it

724
00:37:44,430 --> 00:37:47,790
will prepend like the byte sequence ok

725
00:37:47,790 --> 00:37:50,370
so I missed that okay thank you yeah

726
00:37:50,370 --> 00:37:53,600
otherwise it's a bit cumbersome

727
00:37:54,530 --> 00:38:07,620
any other questions no oh yes yes my

728
00:38:07,620 --> 00:38:11,340
question was regarding to you 2:56

729
00:38:11,340 --> 00:38:14,370
implementation have you thought about

730
00:38:14,370 --> 00:38:20,060
contributing it into the library yeah

731
00:38:22,610 --> 00:38:26,520
because a second question how come your

732
00:38:26,520 --> 00:38:28,860
implementation is faster than the ghosts

733
00:38:28,860 --> 00:38:34,020
on the library for amd64 since both are

734
00:38:34,020 --> 00:38:36,150
in assembly and have a Nevaeh's to

735
00:38:36,150 --> 00:38:39,060
implementation so what did you do

736
00:38:39,060 --> 00:38:42,030
something special well I mean there's

737
00:38:42,030 --> 00:38:43,860
different ways to do different things in

738
00:38:43,860 --> 00:38:47,070
assembly right so I mean it's not gonna

739
00:38:47,070 --> 00:38:48,750
be effect or 2x but I mean depending on

740
00:38:48,750 --> 00:38:51,000
how you exactly do it you may see like

741
00:38:51,000 --> 00:38:56,130
still minor yeah differences so just

742
00:38:56,130 --> 00:38:58,230
like in regular high-level go you can

743
00:38:58,230 --> 00:39:01,560
also one maybe way of doing things maybe

744
00:39:01,560 --> 00:39:03,360
slightly better than another way of

745
00:39:03,360 --> 00:39:07,520
doing it so thank you

746
00:39:08,330 --> 00:39:10,700
okay thank you

747
00:39:10,700 --> 00:39:19,140
[Applause]

