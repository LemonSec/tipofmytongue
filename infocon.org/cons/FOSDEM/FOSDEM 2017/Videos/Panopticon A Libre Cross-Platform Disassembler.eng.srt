1
00:00:06,980 --> 00:00:08,340
[Music]

2
00:00:08,340 --> 00:00:11,200
so hello welcome to the security dev

3
00:00:11,200 --> 00:00:14,170
room get a seat and we'll start by

4
00:00:14,170 --> 00:00:16,960
introducing Kai from Germany who is

5
00:00:16,960 --> 00:00:19,750
going to talk about panopticon either a

6
00:00:19,750 --> 00:00:29,280
deception disassembler welcome thank you

7
00:00:29,280 --> 00:00:33,280
I'm Kai from Bahama Mecca and I'm today

8
00:00:33,280 --> 00:00:35,260
here to tell about an observed project

9
00:00:35,260 --> 00:00:36,370
called panopticon which is a

10
00:00:36,370 --> 00:00:41,829
cross-platform Libre disassembler so I

11
00:00:41,829 --> 00:00:44,140
will first talk about about goals of the

12
00:00:44,140 --> 00:00:45,879
project and then we will come back to

13
00:00:45,879 --> 00:00:47,589
reality and see how the portrait

14
00:00:47,589 --> 00:00:51,129
actually is implemented now and if the

15
00:00:51,129 --> 00:00:53,019
time isn't up there yet I will tell what

16
00:00:53,019 --> 00:00:55,719
about architecture but first I want to

17
00:00:55,719 --> 00:00:57,879
make the case for why we need such a

18
00:00:57,879 --> 00:01:00,460
tool and well when you're in security

19
00:01:00,460 --> 00:01:02,979
especially we need to the assembler for

20
00:01:02,979 --> 00:01:04,870
analyzing proprietary software for

21
00:01:04,870 --> 00:01:07,590
example finding bucks in tools like

22
00:01:07,590 --> 00:01:10,659
Windows and analyze more where because

23
00:01:10,659 --> 00:01:11,770
most of the more that doesn't come with

24
00:01:11,770 --> 00:01:14,890
source code attached and often when we

25
00:01:14,890 --> 00:01:16,450
are just free software developers you

26
00:01:16,450 --> 00:01:19,390
have to want to implement free so for

27
00:01:19,390 --> 00:01:21,430
replacement for file systems or natural

28
00:01:21,430 --> 00:01:22,479
protocols that are implemented in

29
00:01:22,479 --> 00:01:24,460
proprietary - it's only so we have to

30
00:01:24,460 --> 00:01:28,060
rip those - as a part - that's what we

31
00:01:28,060 --> 00:01:30,520
need dissimilar to and most of the tools

32
00:01:30,520 --> 00:01:32,409
we even use now especially in security

33
00:01:32,409 --> 00:01:36,299
work all proprietary so the idea about

34
00:01:36,299 --> 00:01:39,609
the project or project is to build a

35
00:01:39,609 --> 00:01:42,039
replacement for these proprietary tools

36
00:01:42,039 --> 00:01:44,859
and so when I'm talking about reverse

37
00:01:44,859 --> 00:01:46,359
engineering I'm talking about binary

38
00:01:46,359 --> 00:01:48,009
rezonings are we only concerned about

39
00:01:48,009 --> 00:01:51,329
elf binaries or P binaries that

40
00:01:51,329 --> 00:01:54,969
implemented in machine code and what I'm

41
00:01:54,969 --> 00:01:56,530
also not talking about is automatic

42
00:01:56,530 --> 00:01:58,030
reverse engineering so what we are doing

43
00:01:58,030 --> 00:01:59,710
here is mostly about money reverse

44
00:01:59,710 --> 00:02:02,259
engineering so practical nest is kitchen

45
00:02:02,259 --> 00:02:03,999
sink approach where you have one tool

46
00:02:03,999 --> 00:02:06,759
that does everything and everything is

47
00:02:06,759 --> 00:02:09,038
integrated and at your fingertips and

48
00:02:09,038 --> 00:02:10,869
you have an integrated graphics user

49
00:02:10,869 --> 00:02:13,660
interface to allow you to surf the code

50
00:02:13,660 --> 00:02:17,480
and figure out how that application does

51
00:02:17,480 --> 00:02:20,000
so this assembly always starts with this

52
00:02:20,000 --> 00:02:23,060
assembly and this is where most of the

53
00:02:23,060 --> 00:02:25,160
herbs Aust will stop so we have a binary

54
00:02:25,160 --> 00:02:27,650
code we can reverse the last assembly

55
00:02:27,650 --> 00:02:29,120
the last step of the compilation the

56
00:02:29,120 --> 00:02:30,860
assembly because it's more or less the

57
00:02:30,860 --> 00:02:33,380
one-to-one mapping between bits and the

58
00:02:33,380 --> 00:02:35,690
assembly code listing and for example

59
00:02:35,690 --> 00:02:36,950
tools like object donc just dump the

60
00:02:36,950 --> 00:02:39,410
assembly code onto the console and get

61
00:02:39,410 --> 00:02:41,510
to read it but that's not something you

62
00:02:41,510 --> 00:02:43,400
can really use and in reality because

63
00:02:43,400 --> 00:02:45,530
most of these tools have millions of

64
00:02:45,530 --> 00:02:47,420
lines of assembly listing and we are not

65
00:02:47,420 --> 00:02:49,280
interesting in 99% of this code because

66
00:02:49,280 --> 00:02:51,110
if you know a bit about programming we

67
00:02:51,110 --> 00:02:52,849
already know how it's implemented what

68
00:02:52,849 --> 00:02:55,040
we're interested in is this little part

69
00:02:55,040 --> 00:02:56,540
in the application that implements the

70
00:02:56,540 --> 00:02:58,190
state machine for a network protocol on

71
00:02:58,190 --> 00:03:01,340
a check stat file system or that

72
00:03:01,340 --> 00:03:03,319
implements some kind of picked off

73
00:03:03,319 --> 00:03:06,110
so what invest was do is what's called

74
00:03:06,110 --> 00:03:07,700
static analysis so it takes that

75
00:03:07,700 --> 00:03:10,280
assembly code listing and tries it cuts

76
00:03:10,280 --> 00:03:12,140
it down into chunks so the concept of

77
00:03:12,140 --> 00:03:13,849
functions for example exits exists on

78
00:03:13,849 --> 00:03:16,400
the same level so we can separate a code

79
00:03:16,400 --> 00:03:18,200
into functions and then separate

80
00:03:18,200 --> 00:03:19,760
functions in something called basic

81
00:03:19,760 --> 00:03:22,250
blocks which are sequences of assembly

82
00:03:22,250 --> 00:03:24,190
code instructions that are executed

83
00:03:24,190 --> 00:03:26,329
without interruption so we know when the

84
00:03:26,329 --> 00:03:28,910
first instruction is executed execution

85
00:03:28,910 --> 00:03:30,139
will continue on to the end of the basic

86
00:03:30,139 --> 00:03:31,639
block and then we have a jump or a

87
00:03:31,639 --> 00:03:36,139
branch so our tools try to recover this

88
00:03:36,139 --> 00:03:38,299
information be there nice graph and then

89
00:03:38,299 --> 00:03:40,130
comes the last part which is often

90
00:03:40,130 --> 00:03:41,989
overlooked especially by open source

91
00:03:41,989 --> 00:03:44,630
tools and I think this problem is mostly

92
00:03:44,630 --> 00:03:47,180
cultural and we have to get the

93
00:03:47,180 --> 00:03:48,920
information that's in the computer into

94
00:03:48,920 --> 00:03:51,620
the brain of the user so we have you

95
00:03:51,620 --> 00:03:53,569
need a graphic user interface for an

96
00:03:53,569 --> 00:03:55,280
interface part is the important one and

97
00:03:55,280 --> 00:03:56,630
we what we essentially have to do is to

98
00:03:56,630 --> 00:03:57,650
transform the information in the

99
00:03:57,650 --> 00:04:01,030
computer in a way that our brains can

100
00:04:01,030 --> 00:04:05,780
understand it so with panopticon we take

101
00:04:05,780 --> 00:04:09,739
a step that's not often done by Muslims

102
00:04:09,739 --> 00:04:11,540
or to is that the graphic user interface

103
00:04:11,540 --> 00:04:13,700
is a integral part of the system so when

104
00:04:13,700 --> 00:04:15,500
you implement a feature or what you want

105
00:04:15,500 --> 00:04:17,060
me to implement a feature you have to

106
00:04:17,060 --> 00:04:18,798
tell me not only how it interacts which

107
00:04:18,798 --> 00:04:20,358
is a similar part in the static analysis

108
00:04:20,358 --> 00:04:22,460
part but also how do we represent

109
00:04:22,460 --> 00:04:24,770
information we gather to the user in a

110
00:04:24,770 --> 00:04:26,300
way the user can actually use so I'm not

111
00:04:26,300 --> 00:04:28,039
just dumping into a text file or

112
00:04:28,039 --> 00:04:30,349
something like that but I'm turning in

113
00:04:30,349 --> 00:04:30,710
the picture

114
00:04:30,710 --> 00:04:32,270
or something like that that we can

115
00:04:32,270 --> 00:04:35,449
actually help the user to understand the

116
00:04:35,449 --> 00:04:38,840
binary so that's really important

117
00:04:38,840 --> 00:04:41,270
another thing most of the even

118
00:04:41,270 --> 00:04:43,669
proprietary to a slack is Alice's best

119
00:04:43,669 --> 00:04:46,460
based on semantics so what most tools do

120
00:04:46,460 --> 00:04:48,350
is they know how assembly code looks

121
00:04:48,350 --> 00:04:50,479
like so they know this bit pattern turns

122
00:04:50,479 --> 00:04:52,100
to this monic and the morick is a string

123
00:04:52,100 --> 00:04:54,110
every know how the arguments look like

124
00:04:54,110 --> 00:04:56,360
and their arguments are also strings and

125
00:04:56,360 --> 00:04:58,430
that's pretty much it it just gives it a

126
00:04:58,430 --> 00:05:00,970
dead code to you for you to read but

127
00:05:00,970 --> 00:05:03,350
what's more interesting is when we have

128
00:05:03,350 --> 00:05:04,699
a tool that actually understands the

129
00:05:04,699 --> 00:05:07,130
semantics of the code at one time so

130
00:05:07,130 --> 00:05:08,960
what Polachek on does it implements an

131
00:05:08,960 --> 00:05:10,490
intermediate language is a bit like use

132
00:05:10,490 --> 00:05:14,090
and compilers there are so for every

133
00:05:14,090 --> 00:05:16,340
monic we recognize we as a generator a

134
00:05:16,340 --> 00:05:17,990
short sequence of intermediate language

135
00:05:17,990 --> 00:05:20,990
this is easy to analyze that implements

136
00:05:20,990 --> 00:05:23,090
the semantics of this of code at runtime

137
00:05:23,090 --> 00:05:25,849
and when we have the semantics we can do

138
00:05:25,849 --> 00:05:27,530
errors on the semantics instead of just

139
00:05:27,530 --> 00:05:30,110
at the syntax of what looks like and I

140
00:05:30,110 --> 00:05:31,849
will give you two examples what we could

141
00:05:31,849 --> 00:05:35,510
do when we have two semantics the first

142
00:05:35,510 --> 00:05:37,030
one is called abstract interpretation

143
00:05:37,030 --> 00:05:40,400
the basic idea here is that we have an

144
00:05:40,400 --> 00:05:42,800
analysis across all possible paths

145
00:05:42,800 --> 00:05:45,320
throughout the program and instead of

146
00:05:45,320 --> 00:05:47,690
just looking at one path and a one value

147
00:05:47,690 --> 00:05:50,300
at a time we just replace concrete

148
00:05:50,300 --> 00:05:51,919
barriers with sets of values or abstract

149
00:05:51,919 --> 00:05:55,070
of set of values so what I mean with

150
00:05:55,070 --> 00:05:59,330
that is here explained so we have

151
00:05:59,330 --> 00:06:01,250
to see code on the left and that

152
00:06:01,250 --> 00:06:03,650
implements the switch statement it's

153
00:06:03,650 --> 00:06:05,659
just a bunch of cases and when you have

154
00:06:05,659 --> 00:06:07,760
a certain set of cases for value we

155
00:06:07,760 --> 00:06:10,940
print Prime and if it isn't of course

156
00:06:10,940 --> 00:06:14,060
these all Prime's if there isn't the

157
00:06:14,060 --> 00:06:15,349
case so we return false

158
00:06:15,349 --> 00:06:17,599
and what GCC does from this code is it

159
00:06:17,599 --> 00:06:19,099
will permit some reassembling a binary

160
00:06:19,099 --> 00:06:21,830
search tree so if you first start with

161
00:06:21,830 --> 00:06:24,010
the middle case which is 11 I think and

162
00:06:24,010 --> 00:06:27,229
well look if value is equal to mara 11

163
00:06:27,229 --> 00:06:28,580
and if it's equal of course it jumps to

164
00:06:28,580 --> 00:06:29,750
the basic block that implements the

165
00:06:29,750 --> 00:06:31,550
print and if it doesn't it compares

166
00:06:31,550 --> 00:06:34,639
whenever value is larger or smaller than

167
00:06:34,639 --> 00:06:37,669
11 and then branches according to that

168
00:06:37,669 --> 00:06:40,029
and so you have some kind of tree that

169
00:06:40,029 --> 00:06:42,950
unfolds the bottom and at the bottom you

170
00:06:42,950 --> 00:06:44,360
have the fourth case where everything

171
00:06:44,360 --> 00:06:46,939
together so what we often are interested

172
00:06:46,939 --> 00:06:50,379
in is okay what are the values that

173
00:06:50,379 --> 00:06:53,870
causes the printf to fire and of course

174
00:06:53,870 --> 00:06:54,979
we're in via an experience reverse

175
00:06:54,979 --> 00:06:57,020
engineer we can always see that this is

176
00:06:57,020 --> 00:06:59,120
a binary search tree and the spurious

177
00:06:59,120 --> 00:07:00,969
which case statements of you decode and

178
00:07:00,969 --> 00:07:04,550
check for are equal for a comparisons

179
00:07:04,550 --> 00:07:07,099
and the equal jumps and then we see that

180
00:07:07,099 --> 00:07:09,189
all equal jumps flow to one basic blocks

181
00:07:09,189 --> 00:07:10,509
Facebook

182
00:07:10,509 --> 00:07:12,919
what extra interpretation can do is

183
00:07:12,919 --> 00:07:15,710
ultimate execute that so it can execute

184
00:07:15,710 --> 00:07:18,560
the code figure out okay

185
00:07:18,560 --> 00:07:21,500
when this jumps is taking a value must

186
00:07:21,500 --> 00:07:23,210
be 11 and this term taken where you must

187
00:07:23,210 --> 00:07:25,189
be 19 and it can take the superset of

188
00:07:25,189 --> 00:07:28,120
all the possible values and show us that

189
00:07:28,120 --> 00:07:31,039
they are limits for that of course doing

190
00:07:31,039 --> 00:07:32,419
abstract interpretation of course for

191
00:07:32,419 --> 00:07:34,250
across the COBOL program is hard

192
00:07:34,250 --> 00:07:38,150
especially any of things like IO but

193
00:07:38,150 --> 00:07:41,210
again you can do this manually but I'm

194
00:07:41,210 --> 00:07:42,979
having a machine to do it for you and

195
00:07:42,979 --> 00:07:45,469
presenting it to you and helps you to

196
00:07:45,469 --> 00:07:47,509
concentrate on the big picture and do

197
00:07:47,509 --> 00:07:48,889
that what the machine can't analyze

198
00:07:48,889 --> 00:07:51,770
which is inferring what this means or

199
00:07:51,770 --> 00:07:54,759
what means when well is 11 for example

200
00:07:54,759 --> 00:07:58,940
so just giving hints to the user well I

201
00:07:58,940 --> 00:08:01,940
believe make a resonating way more

202
00:08:01,940 --> 00:08:04,240
easier

203
00:08:04,310 --> 00:08:06,289
another thing is called bond model

204
00:08:06,289 --> 00:08:08,330
checking as opposed to absurd

205
00:08:08,330 --> 00:08:10,610
interpretation we are before marching we

206
00:08:10,610 --> 00:08:12,440
only care about one Pacific password

207
00:08:12,440 --> 00:08:15,500
program that is feasible under a set of

208
00:08:15,500 --> 00:08:20,419
constraints so one example where we

209
00:08:20,419 --> 00:08:22,279
could use this is okay this call is a

210
00:08:22,279 --> 00:08:24,439
bit artificial but it implements some

211
00:08:24,439 --> 00:08:26,629
kind of sanity check on a network

212
00:08:26,629 --> 00:08:30,830
protocol or a file system followed so we

213
00:08:30,830 --> 00:08:32,510
first we have two inputs a and B let's

214
00:08:32,510 --> 00:08:34,429
just answer integers and if we first

215
00:08:34,429 --> 00:08:36,979
check that a is smaller it B and then a

216
00:08:36,979 --> 00:08:40,070
must be 0 and then we multiply a by 3

217
00:08:40,070 --> 00:08:42,890
and invert me and then we add them both

218
00:08:42,890 --> 00:08:44,630
today together and we expect this to be

219
00:08:44,630 --> 00:08:45,529
X decimal

220
00:08:45,529 --> 00:08:50,089
42 so when we compile this we get

221
00:08:50,089 --> 00:08:52,339
something that looks like we have on the

222
00:08:52,339 --> 00:08:56,390
right so we have all checks and the true

223
00:08:56,390 --> 00:08:58,200
branches are a4 through here

224
00:08:58,200 --> 00:09:00,889
so we want to follow the red lines and

225
00:09:00,889 --> 00:09:03,480
the last basic block is the one we're

226
00:09:03,480 --> 00:09:05,040
interested in that well again prints

227
00:09:05,040 --> 00:09:07,320
there okay so of course we interested so

228
00:09:07,320 --> 00:09:10,290
what that's impetus look like in order

229
00:09:10,290 --> 00:09:13,260
to let printf being executed and of

230
00:09:13,260 --> 00:09:15,300
course what we do with as experience

231
00:09:15,300 --> 00:09:16,949
residue devices we execute it called

232
00:09:16,949 --> 00:09:19,199
backwards in our mind you gotta check

233
00:09:19,199 --> 00:09:20,970
your first positions okay the addition

234
00:09:20,970 --> 00:09:24,660
has to be Oh X 4 2 and then we trace the

235
00:09:24,660 --> 00:09:26,339
call backwards and what we do in reality

236
00:09:26,339 --> 00:09:28,920
is we write a short person a program

237
00:09:28,920 --> 00:09:30,600
that just in over 800 cases until we

238
00:09:30,600 --> 00:09:34,709
find one so at least this far what

239
00:09:34,709 --> 00:09:38,940
binary robot monkey can do is generate

240
00:09:38,940 --> 00:09:43,050
and well am more or less for me I found

241
00:09:43,050 --> 00:09:44,850
that we add a bunch of constraints and

242
00:09:44,850 --> 00:09:46,589
then we throw it into the magic binary

243
00:09:46,589 --> 00:09:48,029
model checking algorithm and we get will

244
00:09:48,029 --> 00:09:49,949
give me give us and possible trace

245
00:09:49,949 --> 00:09:52,860
throughout a program that will hit that

246
00:09:52,860 --> 00:09:54,870
basic block so what we do here is

247
00:09:54,870 --> 00:09:57,240
ambiente constraint that that last jump

248
00:09:57,240 --> 00:10:00,120
is taken which just means that zero flag

249
00:10:00,120 --> 00:10:03,630
has to be one and then the model

250
00:10:03,630 --> 00:10:05,550
checking algorithm will look for a

251
00:10:05,550 --> 00:10:08,370
possible set of various that fulfill

252
00:10:08,370 --> 00:10:11,250
this constraint and give us the ways and

253
00:10:11,250 --> 00:10:13,829
including the traces up there so we see

254
00:10:13,829 --> 00:10:16,920
on the top there we need a to be Oh X

255
00:10:16,920 --> 00:10:21,800
15.1 for a six and be something else and

256
00:10:21,800 --> 00:10:25,380
what's very nice about this is that you

257
00:10:25,380 --> 00:10:27,029
can add additional constraint so maybe

258
00:10:27,029 --> 00:10:29,100
you okay you can see a but you maybe

259
00:10:29,100 --> 00:10:31,110
there are some checks before that you

260
00:10:31,110 --> 00:10:34,529
already saw that check that a isn't this

261
00:10:34,529 --> 00:10:35,970
value so you can add another constraint

262
00:10:35,970 --> 00:10:38,610
that okay we want it chopped to be taken

263
00:10:38,610 --> 00:10:40,829
but as we don't want that eight to be

264
00:10:40,829 --> 00:10:43,199
that value we can start algorithm again

265
00:10:43,199 --> 00:10:45,390
and it will find another solution over

266
00:10:45,390 --> 00:10:47,250
tell us that there's no solution all we

267
00:10:47,250 --> 00:10:50,610
could try to compute forever and a good

268
00:10:50,610 --> 00:10:53,610
question but these are three Possible's

269
00:10:53,610 --> 00:10:57,000
so just as a reminder the difference

270
00:10:57,000 --> 00:10:58,350
between have certification and pawn

271
00:10:58,350 --> 00:11:00,449
watchings with us protection we are

272
00:11:00,449 --> 00:11:02,970
looking at all paths at the same time it

273
00:11:02,970 --> 00:11:04,410
was poor not showing which was taking it

274
00:11:04,410 --> 00:11:07,089
looking at one path

275
00:11:07,089 --> 00:11:11,720
so as I thought that some other features

276
00:11:11,720 --> 00:11:13,639
I would like to see and ascending order

277
00:11:13,639 --> 00:11:17,899
of outrageousness what we'd really

278
00:11:17,899 --> 00:11:19,639
really nice open optical is meant as a

279
00:11:19,639 --> 00:11:22,100
static analysis tool but having dynamic

280
00:11:22,100 --> 00:11:23,870
information is always very helpful when

281
00:11:23,870 --> 00:11:25,850
you have future applications so of

282
00:11:25,850 --> 00:11:27,110
course with the symmetric informations

283
00:11:27,110 --> 00:11:29,269
you could simulate the ball program but

284
00:11:29,269 --> 00:11:31,189
this is very expensive and especially

285
00:11:31,189 --> 00:11:32,870
with ball taking you came through this

286
00:11:32,870 --> 00:11:34,759
on real life application so it's pretty

287
00:11:34,759 --> 00:11:36,800
much impossible to do born worth

288
00:11:36,800 --> 00:11:38,810
checking on a wall chromium instance for

289
00:11:38,810 --> 00:11:42,649
example so having the ability to include

290
00:11:42,649 --> 00:11:45,560
traces from pin for example dynamic ro

291
00:11:45,560 --> 00:11:47,180
or just at gdb

292
00:11:47,180 --> 00:11:49,670
it says would be really helpful and Vera

293
00:11:49,670 --> 00:11:52,120
would like to see is that we can matched

294
00:11:52,120 --> 00:11:54,439
traces on to the control flow graphs and

295
00:11:54,439 --> 00:11:56,420
that can tell us ok when you have this

296
00:11:56,420 --> 00:11:58,970
input under this environment control

297
00:11:58,970 --> 00:12:00,230
flow flows like that and when I change

298
00:12:00,230 --> 00:12:01,790
that value or that part of the

299
00:12:01,790 --> 00:12:03,699
environment control flow flows or that

300
00:12:03,699 --> 00:12:06,439
we have fun I think and the last thing

301
00:12:06,439 --> 00:12:07,759
is we already have two traces we have

302
00:12:07,759 --> 00:12:09,949
four we have pin we of Diana our i/o we

303
00:12:09,949 --> 00:12:12,139
just have to implement the matching and

304
00:12:12,139 --> 00:12:16,100
the reading of these traces of course

305
00:12:16,100 --> 00:12:18,470
you always need scripting support when

306
00:12:18,470 --> 00:12:20,449
you have a powerful tool you want to

307
00:12:20,449 --> 00:12:23,660
automate things so I'm betting any type

308
00:12:23,660 --> 00:12:25,370
of coding language would really bear for

309
00:12:25,370 --> 00:12:29,569
I would prefer to have only one and I

310
00:12:29,569 --> 00:12:33,170
would like I don't want to start only

311
00:12:33,170 --> 00:12:37,009
any a long H bar so but we can do pretty

312
00:12:37,009 --> 00:12:38,329
much everything will be pricing the

313
00:12:38,329 --> 00:12:43,100
rates I'm not a fan of this so in if

314
00:12:43,100 --> 00:12:44,480
week in case you want Gaea

315
00:12:44,480 --> 00:12:46,880
that may be a longer discussion but I

316
00:12:46,880 --> 00:12:51,350
can live with everything and well when

317
00:12:51,350 --> 00:12:53,149
you want to replace I'll a pro you have

318
00:12:53,149 --> 00:12:55,160
to replace hex race so the compiler

319
00:12:55,160 --> 00:12:57,529
would be pretty nice even addy copilot

320
00:12:57,529 --> 00:13:00,980
doesn't really decompile the C code you

321
00:13:00,980 --> 00:13:02,509
get out there isn't really secure as was

322
00:13:02,509 --> 00:13:03,889
written especially when the program

323
00:13:03,889 --> 00:13:07,790
wasn't written in C and but you only get

324
00:13:07,790 --> 00:13:09,889
that code so there's this kind of porn

325
00:13:09,889 --> 00:13:13,449
well checking can can be done on C but

326
00:13:13,449 --> 00:13:16,250
there's no real use in doing and C

327
00:13:16,250 --> 00:13:19,200
instead of in assembly code but

328
00:13:19,200 --> 00:13:21,720
the control flow structures the FNC are

329
00:13:21,720 --> 00:13:23,160
easier to reach your control for graphs

330
00:13:23,160 --> 00:13:25,200
always planner we have high level type

331
00:13:25,200 --> 00:13:26,790
information makes it easier to read

332
00:13:26,790 --> 00:13:28,590
real-life applications so maybe some

333
00:13:28,590 --> 00:13:30,480
kind of giggle party would be nice this

334
00:13:30,480 --> 00:13:31,890
isn't as impossible as it looks like

335
00:13:31,890 --> 00:13:33,630
especially if when you have semantic

336
00:13:33,630 --> 00:13:35,370
informations you can use abstract

337
00:13:35,370 --> 00:13:36,930
interpretations for example to recover

338
00:13:36,930 --> 00:13:39,780
stack layouts and the use of sec frames

339
00:13:39,780 --> 00:13:41,730
throughout the program and then you only

340
00:13:41,730 --> 00:13:45,990
have to do a type reference I know

341
00:13:45,990 --> 00:13:49,380
back to reality this is all nice and

342
00:13:49,380 --> 00:13:51,120
part of this is implemented especially

343
00:13:51,120 --> 00:13:53,940
certain interpretation part but aside

344
00:13:53,940 --> 00:13:56,730
from that the program isn't as far far

345
00:13:56,730 --> 00:14:00,150
as I wanted to so how does look like bit

346
00:14:00,150 --> 00:14:02,640
like that so we have a graphic user

347
00:14:02,640 --> 00:14:05,820
interface it's in QT you can open the

348
00:14:05,820 --> 00:14:08,340
application you can open a file and then

349
00:14:08,340 --> 00:14:10,050
start this assembly at entry point and

350
00:14:10,050 --> 00:14:11,790
Vivian listen functions you can click

351
00:14:11,790 --> 00:14:13,050
the list of functions you'll get a

352
00:14:13,050 --> 00:14:14,580
control flow graph you can pan around

353
00:14:14,580 --> 00:14:16,950
consume click on one of the lines at

354
00:14:16,950 --> 00:14:19,230
comments safety or thing that's pretty

355
00:14:19,230 --> 00:14:22,770
much it we can disassemble into

356
00:14:22,770 --> 00:14:25,650
architectures as well as two of the

357
00:14:25,650 --> 00:14:28,530
smaller 8-bit microcontrollers we have

358
00:14:28,530 --> 00:14:30,480
somatic informations for the 8-bit

359
00:14:30,480 --> 00:14:31,800
microcontrollers pretty much complete

360
00:14:31,800 --> 00:14:34,710
and well into this another thing we have

361
00:14:34,710 --> 00:14:37,110
wallet 500 memoria Sinitta and so you

362
00:14:37,110 --> 00:14:39,030
have to write the somatic information

363
00:14:39,030 --> 00:14:43,620
for 500 or so of course but this isn't

364
00:14:43,620 --> 00:14:45,510
as big as it looks like because when you

365
00:14:45,510 --> 00:14:47,670
look at real-life applications when you

366
00:14:47,670 --> 00:14:50,640
implement around 100 120 of the most

367
00:14:50,640 --> 00:14:52,500
popular of course you already have 90%

368
00:14:52,500 --> 00:14:55,680
of everything that's in there and as I

369
00:14:55,680 --> 00:14:57,300
said before we are not really concerned

370
00:14:57,300 --> 00:14:59,370
about global program analysis we just

371
00:14:59,370 --> 00:15:01,170
want a local reasoning about that

372
00:15:01,170 --> 00:15:03,540
function or the set of basic blocks so

373
00:15:03,540 --> 00:15:04,950
what happens at runtime

374
00:15:04,950 --> 00:15:07,440
how do I get to the path there so it

375
00:15:07,440 --> 00:15:10,760
isn't as important that we have had 100%

376
00:15:10,760 --> 00:15:13,410
that we are one our percent precise

377
00:15:13,410 --> 00:15:15,810
we're not trying to do this simple

378
00:15:15,810 --> 00:15:17,910
execution or do automatic export

379
00:15:17,910 --> 00:15:22,440
generation we can open your efforts I

380
00:15:22,440 --> 00:15:25,730
actually have a pull requests open

381
00:15:25,730 --> 00:15:28,770
pretty much now I will merge when I come

382
00:15:28,770 --> 00:15:31,110
home and get a bit of sleep and so we

383
00:15:31,110 --> 00:15:31,950
will and

384
00:15:31,950 --> 00:15:35,910
support p-52 and aside from that we can

385
00:15:35,910 --> 00:15:37,320
roll the raw flesh NOS where we are

386
00:15:37,320 --> 00:15:41,250
which isn't that complicated either the

387
00:15:41,250 --> 00:15:44,010
project is hosted on github we have open

388
00:15:44,010 --> 00:15:45,420
development model we use the issue

389
00:15:45,420 --> 00:15:46,950
tracker there so in case you have a

390
00:15:46,950 --> 00:15:49,079
question you can open an issue and we

391
00:15:49,079 --> 00:15:51,300
try to answer it and if you have a pet

392
00:15:51,300 --> 00:15:56,639
you can set it as per request so I have

393
00:15:56,639 --> 00:15:58,860
a bit time left so I will talk a bit

394
00:15:58,860 --> 00:16:01,800
about the architecture the application

395
00:16:01,800 --> 00:16:04,320
is in one repository but it's two parts

396
00:16:04,320 --> 00:16:06,810
so we're for library that does all the

397
00:16:06,810 --> 00:16:09,589
disassembly the static analysis and

398
00:16:09,589 --> 00:16:12,899
representation of the code and it's

399
00:16:12,899 --> 00:16:15,360
written in rust in case you never used

400
00:16:15,360 --> 00:16:17,699
Trust it's not that much different from

401
00:16:17,699 --> 00:16:20,000
C++ for example

402
00:16:20,000 --> 00:16:23,910
so I started rust one and a half years

403
00:16:23,910 --> 00:16:26,540
ago and it took me three months or so to

404
00:16:26,540 --> 00:16:28,529
understand it in a way that I can

405
00:16:28,529 --> 00:16:30,389
program truth like that so just a

406
00:16:30,389 --> 00:16:32,449
complete cake that complicated we have

407
00:16:32,449 --> 00:16:35,310
the graphical front-end which is a bit

408
00:16:35,310 --> 00:16:37,829
rust to interact with library and of top

409
00:16:37,829 --> 00:16:39,810
of death SQL that's some kind of

410
00:16:39,810 --> 00:16:41,850
JavaScript derivative that's used by

411
00:16:41,850 --> 00:16:47,760
kids to implement Richards hmm so when

412
00:16:47,760 --> 00:16:49,500
you clone the repository you see stuff

413
00:16:49,500 --> 00:16:51,510
like that um the library consists of

414
00:16:51,510 --> 00:16:56,010
around 20 files that are more less named

415
00:16:56,010 --> 00:17:00,740
after the thing they do we have strict

416
00:17:00,740 --> 00:17:03,870
interpreter interpreter and then we have

417
00:17:03,870 --> 00:17:06,119
two assembler for amd64

418
00:17:06,119 --> 00:17:10,319
AVR and MOS and then we have some kind

419
00:17:10,319 --> 00:17:13,109
of tree of a representation of the

420
00:17:13,109 --> 00:17:15,540
program so at the lowest level we have

421
00:17:15,540 --> 00:17:18,540
two monix which of Malakar s memorials

422
00:17:18,540 --> 00:17:20,160
are grouped into basic blocks of ice

423
00:17:20,160 --> 00:17:21,240
blocks are grouped into functions

424
00:17:21,240 --> 00:17:22,799
functions are groups and programs and

425
00:17:22,799 --> 00:17:24,929
provides a route into a project and the

426
00:17:24,929 --> 00:17:26,549
project is at the top level note of what

427
00:17:26,549 --> 00:17:30,419
saved in the application and we have two

428
00:17:30,419 --> 00:17:34,650
data definitions in there here's a IL RS

429
00:17:34,650 --> 00:17:36,720
which is the definition of the

430
00:17:36,720 --> 00:17:38,790
intermediate language we use there in

431
00:17:38,790 --> 00:17:40,409
case you're more on the academic side

432
00:17:40,409 --> 00:17:45,030
view israel but it's um it's a director

433
00:17:45,030 --> 00:17:45,420
for a

434
00:17:45,420 --> 00:17:48,030
and we have some custom functions custom

435
00:17:48,030 --> 00:17:51,600
operations in there well the front end

436
00:17:51,600 --> 00:17:53,520
isn't that complicated we have a bunch

437
00:17:53,520 --> 00:17:57,030
of rust fights to communica free library

438
00:17:57,030 --> 00:17:59,430
and to the layouting for big colorful

439
00:17:59,430 --> 00:18:01,170
graphs and I'm aside from that their

440
00:18:01,170 --> 00:18:03,510
film folder called qml where all the cue

441
00:18:03,510 --> 00:18:05,850
mel fights live each five elements one

442
00:18:05,850 --> 00:18:08,250
richard there isn't that complicated so

443
00:18:08,250 --> 00:18:10,890
in case you never use javascript it

444
00:18:10,890 --> 00:18:14,370
isn't that far it isn't that javascript

445
00:18:14,370 --> 00:18:19,140
e as you would expect as a QT has really

446
00:18:19,140 --> 00:18:20,730
nice documentation so we could check

447
00:18:20,730 --> 00:18:24,840
that out it's pretty straightforward so

448
00:18:24,840 --> 00:18:26,910
in case you interested and may want to

449
00:18:26,910 --> 00:18:28,770
help me and or just want to check out

450
00:18:28,770 --> 00:18:31,590
the project we have website we do you

451
00:18:31,590 --> 00:18:33,690
can also we have on the website the link

452
00:18:33,690 --> 00:18:35,550
to the api documentation the user's

453
00:18:35,550 --> 00:18:38,310
documentation we are you can also jump

454
00:18:38,310 --> 00:18:41,100
to the git repository directly and also

455
00:18:41,100 --> 00:18:42,960
if you have a question you can reach us

456
00:18:42,960 --> 00:18:46,200
on the free notes channel and also we

457
00:18:46,200 --> 00:18:47,430
have a Twitter account where we mostly

458
00:18:47,430 --> 00:18:51,240
positive party was about a project Thank

459
00:18:51,240 --> 00:18:53,690
You Kerry

460
00:18:57,159 --> 00:19:00,859
so we have five minutes for questions we

461
00:19:00,859 --> 00:19:04,909
have the first i wondering why rust I

462
00:19:04,909 --> 00:19:08,179
mean I love rust but I wonder why the

463
00:19:08,179 --> 00:19:12,349
project started years ago and I used C++

464
00:19:12,349 --> 00:19:18,759
because why not and I'm sick of C++ and

465
00:19:18,759 --> 00:19:21,289
whenever when I saw rust rust solves the

466
00:19:21,289 --> 00:19:23,840
problems I have with real live C++

467
00:19:23,840 --> 00:19:26,330
applications and this is my hobby

468
00:19:26,330 --> 00:19:29,989
project so I just thought to myself why

469
00:19:29,989 --> 00:19:33,589
not use trust so one year ago I just

470
00:19:33,589 --> 00:19:35,419
rewrote the application it was at that

471
00:19:35,419 --> 00:19:37,369
time ten thousand lines of code into

472
00:19:37,369 --> 00:19:40,489
rust and turns out it was way easier

473
00:19:40,489 --> 00:19:45,049
than I thought I actually got the line

474
00:19:45,049 --> 00:19:46,999
count down to eight thousand I have less

475
00:19:46,999 --> 00:19:50,149
bugs and rust really helps me to avoid a

476
00:19:50,149 --> 00:19:53,299
kind of Park CFS C++ code bases like

477
00:19:53,299 --> 00:19:57,469
iterate and validation data races it's

478
00:19:57,469 --> 00:20:01,419
way less painful to program rust in C++

479
00:20:01,419 --> 00:20:04,089
I was wondering about

480
00:20:04,089 --> 00:20:06,289
obfuscated malware an in particular

481
00:20:06,289 --> 00:20:08,119
there are some TTP's that you can

482
00:20:08,119 --> 00:20:10,159
recognize so easily that you could

483
00:20:10,159 --> 00:20:11,839
potentially build semantic information

484
00:20:11,839 --> 00:20:16,909
for that yes of course alpha station is

485
00:20:16,909 --> 00:20:20,029
there to stop us there's only so much

486
00:20:20,029 --> 00:20:22,399
you can do that's why it's interesting

487
00:20:22,399 --> 00:20:24,739
to have a dynamic information so when

488
00:20:24,739 --> 00:20:25,999
you have something that unpacks itself

489
00:20:25,999 --> 00:20:27,950
at runtime you can do a snapshot and

490
00:20:27,950 --> 00:20:31,399
import it as when you have things like

491
00:20:31,399 --> 00:20:34,460
virtualized or wherever you have some is

492
00:20:34,460 --> 00:20:36,710
an interpreter in there what I can do is

493
00:20:36,710 --> 00:20:38,570
use the scripting engine to implement

494
00:20:38,570 --> 00:20:39,919
some kind of lifter for that

495
00:20:39,919 --> 00:20:41,269
intermediate language after you have

496
00:20:41,269 --> 00:20:44,719
disassembled it and then use because you

497
00:20:44,719 --> 00:20:46,669
only have to exit do to generate the

498
00:20:46,669 --> 00:20:48,349
intermediate language and then use all

499
00:20:48,349 --> 00:20:50,719
the code Alyce's features they're a bit

500
00:20:50,719 --> 00:20:52,729
in there to do coders and less directly

501
00:20:52,729 --> 00:20:55,460
on the obfuscated and virtualized small

502
00:20:55,460 --> 00:20:57,700
there but of course this is a problem

503
00:20:57,700 --> 00:21:01,190
it's there to stop us we can all do so

504
00:21:01,190 --> 00:21:04,129
much follow one question on that you

505
00:21:04,129 --> 00:21:06,169
have dick disassembly for all the

506
00:21:06,169 --> 00:21:09,650
language yet see but we're thinking to

507
00:21:09,650 --> 00:21:12,740
disassemblers to c++ or some other

508
00:21:12,740 --> 00:21:17,120
high-level language or compiled to c++

509
00:21:17,120 --> 00:21:20,559
to write as well with c++ you have the

510
00:21:20,559 --> 00:21:23,720
advantage that you can try to pattern

511
00:21:23,720 --> 00:21:26,289
match certain parts of the C++ compiler

512
00:21:26,289 --> 00:21:30,039
to figure out how for example class

513
00:21:30,039 --> 00:21:32,630
hierarchies look like but right now it's

514
00:21:32,630 --> 00:21:36,130
C but only for now you can you know like

515
00:21:36,130 --> 00:21:40,279
assembly code listings of course you can

516
00:21:40,279 --> 00:21:42,409
even analyze Hasker it just looks a bit

517
00:21:42,409 --> 00:21:44,870
crazy so we have two more questions

518
00:21:44,870 --> 00:21:46,490
planned raise your hand if you want to

519
00:21:46,490 --> 00:21:51,820
ask more it's a simple question but

520
00:21:51,820 --> 00:21:56,830
what's logic behind the decompiling it

521
00:21:56,830 --> 00:22:00,520
decides of the scope of this little part

522
00:22:00,520 --> 00:22:03,590
when you the compiler a list of the

523
00:22:03,590 --> 00:22:06,500
assembly you the compiling c or c like

524
00:22:06,500 --> 00:22:11,330
mmm what's the logic behind you you you

525
00:22:11,330 --> 00:22:16,039
peek and a coat of cheese shattered by a

526
00:22:16,039 --> 00:22:19,460
list of assembly besides another so what

527
00:22:19,460 --> 00:22:21,200
I can do is what for example I the

528
00:22:21,200 --> 00:22:23,960
Provost in does is parametric you can of

529
00:22:23,960 --> 00:22:26,270
course the compiler turn certain

530
00:22:26,270 --> 00:22:27,799
constructs into certain assembly code

531
00:22:27,799 --> 00:22:29,720
listings and we try to try to recognize

532
00:22:29,720 --> 00:22:33,710
that and try it back and other ways is

533
00:22:33,710 --> 00:22:36,049
to just turn the code into C's or you

534
00:22:36,049 --> 00:22:40,100
turn it into some kind of C expressions

535
00:22:40,100 --> 00:22:43,070
and then you can turn something called

536
00:22:43,070 --> 00:22:46,070
expressions into SC expression the D

537
00:22:46,070 --> 00:22:47,870
compilation is just three process you

538
00:22:47,870 --> 00:22:50,799
only have to recover the control floor

539
00:22:50,799 --> 00:22:52,309
architecture of the control flow

540
00:22:52,309 --> 00:22:54,890
constructions in C so you can do this

541
00:22:54,890 --> 00:22:56,029
with pattern matching you see okay

542
00:22:56,029 --> 00:22:58,309
whenever I have a block that just have

543
00:22:58,309 --> 00:23:01,730
loop okay doesn't through charger loop

544
00:23:01,730 --> 00:23:03,380
what's more complicated is to recover

545
00:23:03,380 --> 00:23:05,539
the type information and tend to recover

546
00:23:05,539 --> 00:23:09,260
how the stack is used that can be done

547
00:23:09,260 --> 00:23:11,899
with assembly sorry interpretation and

548
00:23:11,899 --> 00:23:14,000
the type of information where you can do

549
00:23:14,000 --> 00:23:16,370
a type inference algorithm here SK of

550
00:23:16,370 --> 00:23:19,190
thrust and to for this to work you

551
00:23:19,190 --> 00:23:21,159
hasn't need typing information so you

552
00:23:21,159 --> 00:23:23,090
need to encode in

553
00:23:23,090 --> 00:23:25,999
disassembler that certain API calls of a

554
00:23:25,999 --> 00:23:28,220
certain type set and so I can use this

555
00:23:28,220 --> 00:23:29,749
when when the assembly code costs the

556
00:23:29,749 --> 00:23:31,850
faction you know okay the arguments

557
00:23:31,850 --> 00:23:33,679
mafia must have test types and you can

558
00:23:33,679 --> 00:23:35,419
try to push the information down to the

559
00:23:35,419 --> 00:23:37,759
assembly code so that's pretty much how

560
00:23:37,759 --> 00:23:43,190
the compilation works thank you more

561
00:23:43,190 --> 00:23:53,090
questions one question there too first

562
00:23:53,090 --> 00:23:55,610
question what was the reason not to use

563
00:23:55,610 --> 00:23:58,490
any of the existing disassembly

564
00:23:58,490 --> 00:24:02,629
libraries which would give you access to

565
00:24:02,629 --> 00:24:05,899
more proposals of families and the

566
00:24:05,899 --> 00:24:09,110
second question would be is is there an

567
00:24:09,110 --> 00:24:11,990
option for for example another type of

568
00:24:11,990 --> 00:24:14,869
syntax like 8080 syntax and I notice you

569
00:24:14,869 --> 00:24:19,009
use in the syntax for the x86

570
00:24:19,009 --> 00:24:23,419
so currently we only let's start with a

571
00:24:23,419 --> 00:24:25,809
silly question the problem is that

572
00:24:25,809 --> 00:24:28,580
celebrates you have now totally on doggy

573
00:24:28,580 --> 00:24:31,190
feel really somatic information they

574
00:24:31,190 --> 00:24:32,720
asked capstone which can tell you at

575
00:24:32,720 --> 00:24:34,340
least which part with arguments are

576
00:24:34,340 --> 00:24:36,679
written it was read but I can't tell you

577
00:24:36,679 --> 00:24:38,029
what's the function between those two

578
00:24:38,029 --> 00:24:42,559
iron arguments and doing this is the

579
00:24:42,559 --> 00:24:44,389
most of the part of most of the work so

580
00:24:44,389 --> 00:24:47,960
I saw no much use in trying to wrap

581
00:24:47,960 --> 00:24:50,179
library because trying to lepsy wrap c

582
00:24:50,179 --> 00:24:52,639
libraries and having it compile all

583
00:24:52,639 --> 00:24:54,889
ously on most machines is very hard with

584
00:24:54,889 --> 00:24:58,610
rust so when you only have rust it's

585
00:24:58,610 --> 00:25:02,330
easier and okay we of course we can

586
00:25:02,330 --> 00:25:04,970
generate 18 te syntax there's we can put

587
00:25:04,970 --> 00:25:07,970
switch in the country we have inter hot

588
00:25:07,970 --> 00:25:11,169
code but that's not much of a problem

589
00:25:11,169 --> 00:25:16,720
what's up okay let's think okay

590
00:25:22,709 --> 00:25:25,330
and there is a five-minute break please

591
00:25:25,330 --> 00:25:27,099
open the door so we can get some air in

592
00:25:27,099 --> 00:25:29,700
thank you

593
00:25:39,100 --> 00:25:42,189
[Music]

