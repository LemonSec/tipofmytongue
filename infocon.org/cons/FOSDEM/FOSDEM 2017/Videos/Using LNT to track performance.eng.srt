1
00:00:04,649 --> 00:00:08,410
good afternoon my name is crystal bells

2
00:00:08,410 --> 00:00:11,170
I'm going to talk about using alum tea

3
00:00:11,170 --> 00:00:13,750
which is one of the earlier projects to

4
00:00:13,750 --> 00:00:18,810
track performance for

5
00:00:23,500 --> 00:00:25,330
that room I already talked about this

6
00:00:25,330 --> 00:00:29,460
topic a bit la Fiera talked about how to

7
00:00:29,460 --> 00:00:33,910
improve automatically tracking the

8
00:00:33,910 --> 00:00:35,920
performance of the LLVM generated code

9
00:00:35,920 --> 00:00:40,750
and there were what did I say it Asti

10
00:00:40,750 --> 00:00:43,720
RFC so I talked about improvement that

11
00:00:43,720 --> 00:00:46,000
were needed in to one of young projects

12
00:00:46,000 --> 00:00:48,790
one is LNT the other the tests we can

13
00:00:48,790 --> 00:00:50,379
test with conventional lots and lots of

14
00:00:50,379 --> 00:00:53,949
open source packages that get used tests

15
00:00:53,949 --> 00:00:58,149
on all VM with Allen T is I would say

16
00:00:58,149 --> 00:01:01,719
best infrastructure software lots of

17
00:01:01,719 --> 00:01:04,180
lots of scripts database analysis tools

18
00:01:04,180 --> 00:01:07,289
to look at tests and benchmark results

19
00:01:07,289 --> 00:01:09,820
so I present the range of ID's last year

20
00:01:09,820 --> 00:01:11,619
a few improvements were already

21
00:01:11,619 --> 00:01:13,210
implemented I also present the range of

22
00:01:13,210 --> 00:01:14,440
ideas that'll have to be implemented

23
00:01:14,440 --> 00:01:16,479
since then most of them have been

24
00:01:16,479 --> 00:01:20,009
implemented and I think that by now

25
00:01:20,009 --> 00:01:23,160
actually it's it's much nicer to track

26
00:01:23,160 --> 00:01:27,100
performance with less human effort on

27
00:01:27,100 --> 00:01:30,340
top of trunk and so I'll hope to give

28
00:01:30,340 --> 00:01:33,670
you a demo to hope to convince you that

29
00:01:33,670 --> 00:01:36,490
indeed we've made a big step forward so

30
00:01:36,490 --> 00:01:38,710
just another copy/paste of my conclusion

31
00:01:38,710 --> 00:01:41,080
slide from last year it's a little bit

32
00:01:41,080 --> 00:01:44,040
unreadable already that for you I'm glad

33
00:01:44,040 --> 00:01:46,119
there were a number of aspects that I

34
00:01:46,119 --> 00:01:47,470
thought in a continuous integration

35
00:01:47,470 --> 00:01:49,990
system we really would like to have this

36
00:01:49,990 --> 00:01:53,290
property to be the case and then one of

37
00:01:53,290 --> 00:01:55,570
the properties was when it flags up an

38
00:01:55,570 --> 00:01:57,310
issue it should flag up the issue so

39
00:01:57,310 --> 00:01:59,619
that it's actionable meaning as a

40
00:01:59,619 --> 00:02:03,070
developer you get the mail or any kind

41
00:02:03,070 --> 00:02:05,979
of notification and then you know what

42
00:02:05,979 --> 00:02:08,350
to do to go and fix the problem last

43
00:02:08,350 --> 00:02:10,209
year I thought it was improved but that

44
00:02:10,209 --> 00:02:12,730
the red color and the error means it's

45
00:02:12,730 --> 00:02:14,920
still very far from where we would like

46
00:02:14,920 --> 00:02:18,459
to be another property would be to

47
00:02:18,459 --> 00:02:20,620
require as little as possible human

48
00:02:20,620 --> 00:02:23,560
effort last year also my feeling my

49
00:02:23,560 --> 00:02:26,799
experience is still a bit of improvement

50
00:02:26,799 --> 00:02:28,480
but still not where we needed to be and

51
00:02:28,480 --> 00:02:30,400
then the last bullet point is read a

52
00:02:30,400 --> 00:02:33,910
continuous integration system should

53
00:02:33,910 --> 00:02:35,110
help

54
00:02:35,110 --> 00:02:38,110
to enable a culture of everyone working

55
00:02:38,110 --> 00:02:41,350
in this case on LLVM to actually act on

56
00:02:41,350 --> 00:02:44,740
a delta you committed something because

57
00:02:44,740 --> 00:02:46,690
of that some correctness or performance

58
00:02:46,690 --> 00:02:49,630
regressed it's natural for you to just

59
00:02:49,630 --> 00:02:51,940
go and act on it so that regression goes

60
00:02:51,940 --> 00:02:55,030
away and I think last year well myself

61
00:02:55,030 --> 00:02:57,490
my personal assessment then was last

62
00:02:57,490 --> 00:02:58,630
year we hadn't implemented any

63
00:02:58,630 --> 00:02:59,950
improvements hadn't seen any

64
00:02:59,950 --> 00:03:02,650
improvements on that just yet and still

65
00:03:02,650 --> 00:03:06,330
far from where we would like it to be

66
00:03:07,500 --> 00:03:10,240
spoiler alert I think for all three of

67
00:03:10,240 --> 00:03:12,550
these we've made some improvements I'll

68
00:03:12,550 --> 00:03:16,030
show you some details later on also and

69
00:03:16,030 --> 00:03:18,310
it was saying consider using Allen TSO

70
00:03:18,310 --> 00:03:21,250
performance tracking infrastructure I

71
00:03:21,250 --> 00:03:23,620
think since last year we made it a

72
00:03:23,620 --> 00:03:25,450
little bit easier to actually go and do

73
00:03:25,450 --> 00:03:29,590
so I'll give a few more details so first

74
00:03:29,590 --> 00:03:35,709
on making sure it continues integration

75
00:03:35,709 --> 00:03:38,380
system actually signals two things up

76
00:03:38,380 --> 00:03:40,269
that are actionable and require little

77
00:03:40,269 --> 00:03:44,440
human effort let me do a demo of what we

78
00:03:44,440 --> 00:03:48,780
definitely do I'll sit down for the demo

79
00:03:48,780 --> 00:03:52,030
please shout out questions as I go along

80
00:03:52,030 --> 00:03:55,810
if something isn't clear I've been doing

81
00:03:55,810 --> 00:03:58,720
this on and off almost day-by-day for

82
00:03:58,720 --> 00:04:00,459
quite a few months so I might jump over

83
00:04:00,459 --> 00:04:02,140
some issues that are not obvious if

84
00:04:02,140 --> 00:04:04,030
something is not not obvious please

85
00:04:04,030 --> 00:04:09,180
shout out so what I'm showing here is

86
00:04:09,180 --> 00:04:12,580
something that's called the LNT daily

87
00:04:12,580 --> 00:04:14,320
report page so this is an allen key web

88
00:04:14,320 --> 00:04:17,620
server running lots of performance

89
00:04:17,620 --> 00:04:20,738
measurement data has been pumped into

90
00:04:20,738 --> 00:04:24,370
that database and this report page

91
00:04:24,370 --> 00:04:27,910
summarizes issues that seem to be

92
00:04:27,910 --> 00:04:30,160
important on that particular day now

93
00:04:30,160 --> 00:04:32,650
this date is from April last year I

94
00:04:32,650 --> 00:04:34,479
picked this date because it has a few

95
00:04:34,479 --> 00:04:36,160
examples that are easy to explain in the

96
00:04:36,160 --> 00:04:41,020
demo so there's a the resolution on this

97
00:04:41,020 --> 00:04:43,060
monitor isn't great so things to click

98
00:04:43,060 --> 00:04:45,789
on normal resolutions things look a

99
00:04:45,789 --> 00:04:48,810
little bit nicer so there's a bunch

100
00:04:48,810 --> 00:04:52,440
machines that's do run tests and you can

101
00:04:52,440 --> 00:04:54,450
see from here the past seven days

102
00:04:54,450 --> 00:04:56,250
whether they did submit some test

103
00:04:56,250 --> 00:04:58,169
results or did not submit any test

104
00:04:58,169 --> 00:05:02,040
results in Alan t there's a number of

105
00:05:02,040 --> 00:05:04,460
metrics that can be tracked in this case

106
00:05:04,460 --> 00:05:08,430
nothing special was flagged up for a

107
00:05:08,430 --> 00:05:11,310
code size metric or score metric but for

108
00:05:11,310 --> 00:05:13,500
the execution time metric things that

109
00:05:13,500 --> 00:05:18,870
gets flagged up before jumping to the

110
00:05:18,870 --> 00:05:21,060
biggest regrets we see maybe I'll just

111
00:05:21,060 --> 00:05:25,910
want to show this one so this is a

112
00:05:25,910 --> 00:05:28,410
particular program in the LLVM test

113
00:05:28,410 --> 00:05:33,900
suite where the MMT system says oh today

114
00:05:33,900 --> 00:05:35,910
it seems this has regressed the

115
00:05:35,910 --> 00:05:36,930
performance of that program has

116
00:05:36,930 --> 00:05:40,080
regressed 6% compared to a lot of young

117
00:05:40,080 --> 00:05:42,570
top of trunk yesterday so one of the

118
00:05:42,570 --> 00:05:45,540
things that we added as part of that was

119
00:05:45,540 --> 00:05:49,560
also discussed last year is we have

120
00:05:49,560 --> 00:05:51,570
these little spark lines so what you see

121
00:05:51,570 --> 00:05:53,940
here is how the performance evolved over

122
00:05:53,940 --> 00:05:56,010
the past seven days so just on this

123
00:05:56,010 --> 00:05:58,380
overview page you get an immediate feel

124
00:05:58,380 --> 00:06:00,240
for how the performers evolved in the

125
00:06:00,240 --> 00:06:02,430
past seven days and we also do multiple

126
00:06:02,430 --> 00:06:05,160
runs per day I hope everyone can see

127
00:06:05,160 --> 00:06:06,870
this maybe I'll scroll up a little bit

128
00:06:06,870 --> 00:06:12,030
so we also do multiple runs per day let

129
00:06:12,030 --> 00:06:17,419
me try to zoom in it a little bit and

130
00:06:17,419 --> 00:06:19,740
one of the features that I don't know

131
00:06:19,740 --> 00:06:21,450
was already implemented last year is we

132
00:06:21,450 --> 00:06:22,770
also have this background column

133
00:06:22,770 --> 00:06:24,600
sparkline and actually the background

134
00:06:24,600 --> 00:06:28,850
color just represents the

135
00:06:28,850 --> 00:06:32,280
if the code that could generate my LLVM

136
00:06:32,280 --> 00:06:34,050
changed or didn't change all that

137
00:06:34,050 --> 00:06:35,520
particular day so it's computed from a

138
00:06:35,520 --> 00:06:38,669
hash of the the alpha and called

139
00:06:38,669 --> 00:06:40,590
produced which means that in this case

140
00:06:40,590 --> 00:06:42,900
you can interpret so this is a data

141
00:06:42,900 --> 00:06:44,789
point from today that's the data point

142
00:06:44,789 --> 00:06:47,250
from yesterday the day before they all

143
00:06:47,250 --> 00:06:50,400
have the same background color which

144
00:06:50,400 --> 00:06:52,110
means that the actual code produced by

145
00:06:52,110 --> 00:06:53,759
LVM didn't change on these days even

146
00:06:53,759 --> 00:06:55,800
though the system reports different

147
00:06:55,800 --> 00:06:58,889
performance points immediately here you

148
00:06:58,889 --> 00:07:01,830
can ignore that because you know it's my

149
00:07:01,830 --> 00:07:04,350
system that's a bit noisy the code

150
00:07:04,350 --> 00:07:06,810
didn't actually change there's there

151
00:07:06,810 --> 00:07:09,180
isn't and actually any regression here

152
00:07:09,180 --> 00:07:12,410
so already that helps save a lot of

153
00:07:12,410 --> 00:07:16,560
developer time because with just a

154
00:07:16,560 --> 00:07:19,889
glance we can decide ah we can ignore

155
00:07:19,889 --> 00:07:23,240
this one is just noise in the system

156
00:07:27,349 --> 00:07:30,979
it's a bit of a multi modal program I

157
00:07:30,979 --> 00:07:33,780
also had the presentations on that on

158
00:07:33,780 --> 00:07:36,240
the US and Europe I'm lost here do

159
00:07:36,240 --> 00:07:38,160
they'll go much deeper into what the

160
00:07:38,160 --> 00:07:40,050
cause may be of that and and how to

161
00:07:40,050 --> 00:07:44,250
handle that so if we now look at a real

162
00:07:44,250 --> 00:07:47,159
regression to the top regression here

163
00:07:47,159 --> 00:07:49,740
says on three three different course

164
00:07:49,740 --> 00:07:53,159
happens to be a cortex a53 a57 cortex a9

165
00:07:53,159 --> 00:07:55,680
and all these three course the

166
00:07:55,680 --> 00:07:58,289
performance regressed by one hundred and

167
00:07:58,289 --> 00:07:59,520
eighty eight percent

168
00:07:59,520 --> 00:08:02,099
clearly not goods here seventy five

169
00:08:02,099 --> 00:08:04,770
percent we can also see the the

170
00:08:04,770 --> 00:08:06,690
background colors here changed compared

171
00:08:06,690 --> 00:08:08,789
to yesterday so there was some actual

172
00:08:08,789 --> 00:08:11,970
change there let's go and investigate

173
00:08:11,970 --> 00:08:15,360
that so let's click on the link for

174
00:08:15,360 --> 00:08:17,940
that's the biggest regression a fifty

175
00:08:17,940 --> 00:08:21,539
three one where we jump to now is the

176
00:08:21,539 --> 00:08:24,810
long term plots for high performance of

177
00:08:24,810 --> 00:08:26,460
this particular program on that

178
00:08:26,460 --> 00:08:28,500
particular machine evolves over time

179
00:08:28,500 --> 00:08:31,199
if I would have clicked this on the 15th

180
00:08:31,199 --> 00:08:33,208
of February the chart would have stopped

181
00:08:33,208 --> 00:08:35,820
here so of course now we're already

182
00:08:35,820 --> 00:08:37,860
quite a few months later so there are

183
00:08:37,860 --> 00:08:40,440
some lot more data points but yeah you

184
00:08:40,440 --> 00:08:41,640
already see

185
00:08:41,640 --> 00:08:44,280
that this is a major outlier let's go

186
00:08:44,280 --> 00:08:49,980
and investigate here this well we are

187
00:08:49,980 --> 00:08:53,970
now jumping to this particular run on

188
00:08:53,970 --> 00:08:55,560
that particular machine so a whole bunch

189
00:08:55,560 --> 00:08:57,480
of programs for a test we could run as

190
00:08:57,480 --> 00:08:59,520
part of one run on that particular

191
00:08:59,520 --> 00:09:01,170
machine and we have an overview page

192
00:09:01,170 --> 00:09:04,800
here so yes once again this program pops

193
00:09:04,800 --> 00:09:06,810
up one hundred and eighty eight percent

194
00:09:06,810 --> 00:09:08,940
performance difference yeah we really

195
00:09:08,940 --> 00:09:11,280
need to go and investigate here this so

196
00:09:11,280 --> 00:09:12,510
with some of the improvements that we

197
00:09:12,510 --> 00:09:14,400
made since last year what you what we

198
00:09:14,400 --> 00:09:16,440
now also have is as part of the test

199
00:09:16,440 --> 00:09:22,230
suite runs you can collect Linux perf

200
00:09:22,230 --> 00:09:24,480
profile information so I Radhika's also

201
00:09:24,480 --> 00:09:27,120
bumped into the database and if you go

202
00:09:27,120 --> 00:09:30,810
here you will see an overview of that so

203
00:09:30,810 --> 00:09:32,850
already at the top we see indeed the

204
00:09:32,850 --> 00:09:35,220
number of cycles suspends has increased

205
00:09:35,220 --> 00:09:37,200
a lot you also get a summary of in this

206
00:09:37,200 --> 00:09:39,030
case branch misses cache misses so like

207
00:09:39,030 --> 00:09:41,870
the headline microarchitecture all

208
00:09:41,870 --> 00:09:44,490
events that might cause a performance

209
00:09:44,490 --> 00:09:47,700
difference and then you have the

210
00:09:47,700 --> 00:09:49,320
different functions the hottest function

211
00:09:49,320 --> 00:09:51,540
probably that's the one that where some

212
00:09:51,540 --> 00:09:53,730
cogeneration was different let's look at

213
00:09:53,730 --> 00:09:55,440
the hottest function there's the old

214
00:09:55,440 --> 00:09:59,490
version this is the new version and so

215
00:09:59,490 --> 00:10:03,360
here what you see is sites by sides the

216
00:10:03,360 --> 00:10:04,950
output that you would get if you would

217
00:10:04,950 --> 00:10:06,570
run this on your Linux

218
00:10:06,570 --> 00:10:09,660
perf so at this point this also helps

219
00:10:09,660 --> 00:10:12,960
the developer efficiency if before you

220
00:10:12,960 --> 00:10:14,460
just knew two hundred percent

221
00:10:14,460 --> 00:10:15,960
performance difference you would have to

222
00:10:15,960 --> 00:10:17,760
go and rerun the data under linux perth

223
00:10:17,760 --> 00:10:19,890
to get it if it gets sort in the

224
00:10:19,890 --> 00:10:23,580
database automatically that's just yeah

225
00:10:23,580 --> 00:10:24,270
exactly

226
00:10:24,270 --> 00:10:28,170
so this this just saves a lot of time i

227
00:10:28,170 --> 00:10:30,690
think before we want it typically goes

228
00:10:30,690 --> 00:10:33,570
for a few hours you end up spending a

229
00:10:33,570 --> 00:10:35,580
few hours unless you do this is the only

230
00:10:35,580 --> 00:10:38,130
job you do and nobody wants to do this

231
00:10:38,130 --> 00:10:40,940
job has the only job they're doing some

232
00:10:40,940 --> 00:10:43,500
we just crawl through it we see low

233
00:10:43,500 --> 00:10:46,650
percentages out and here we see some hot

234
00:10:46,650 --> 00:10:48,720
codes this is the hot code apparently

235
00:10:48,720 --> 00:10:51,960
and the old version and some hot codes

236
00:10:51,960 --> 00:10:54,460
and the new version

237
00:10:54,460 --> 00:10:57,580
so sometimes this view already you

238
00:10:57,580 --> 00:11:00,630
already see the instructions it can be a

239
00:11:00,630 --> 00:11:02,950
takes a bit of time to investigate

240
00:11:02,950 --> 00:11:05,140
so one extra improvement we've done on

241
00:11:05,140 --> 00:11:09,850
top of that is in the web interface we

242
00:11:09,850 --> 00:11:12,580
put a bit of JavaScript to reverse

243
00:11:12,580 --> 00:11:14,950
engineer the control flow graph so what

244
00:11:14,950 --> 00:11:16,780
you see now is the control flow graph

245
00:11:16,780 --> 00:11:21,640
structure of this whole program and let

246
00:11:21,640 --> 00:11:24,940
me so what you see here every great

247
00:11:24,940 --> 00:11:26,920
block is a basic block you see the

248
00:11:26,920 --> 00:11:30,100
arrows jumping between them you see oh

249
00:11:30,100 --> 00:11:32,350
yeah this that's that whole basic block

250
00:11:32,350 --> 00:11:34,630
before actually all the hop codes in a

251
00:11:34,630 --> 00:11:36,340
single basic block now we know that all

252
00:11:36,340 --> 00:11:38,590
the whole code also here is in a single

253
00:11:38,590 --> 00:11:40,240
basic block we have to compare those two

254
00:11:40,240 --> 00:11:42,940
there's a percentage here 98% of the

255
00:11:42,940 --> 00:11:45,180
time spending the single basic block

256
00:11:45,180 --> 00:11:48,490
now it's 99 percent actually that's

257
00:11:48,490 --> 00:11:50,800
change instead of relative numbers let's

258
00:11:50,800 --> 00:11:53,860
go look at absolute numbers so now it's

259
00:11:53,860 --> 00:11:55,390
much clearer that there is a performance

260
00:11:55,390 --> 00:11:57,700
difference before we spend about four

261
00:11:57,700 --> 00:11:59,170
hundred and thirty million cycles in an

262
00:11:59,170 --> 00:12:01,300
basic block now it's having heard

263
00:12:01,300 --> 00:12:06,910
million cycles yeah the resolution of

264
00:12:06,910 --> 00:12:08,770
this so you know that you have to look

265
00:12:08,770 --> 00:12:10,570
at these few instructions here that's

266
00:12:10,570 --> 00:12:12,430
where it happened the resolution of the

267
00:12:12,430 --> 00:12:15,160
screen isn't high enough but I hope

268
00:12:15,160 --> 00:12:17,440
you'll believe me that's here you see

269
00:12:17,440 --> 00:12:19,840
the vision instruction and in the old

270
00:12:19,840 --> 00:12:21,480
code there's no division instruction

271
00:12:21,480 --> 00:12:24,010
most developers no division instructions

272
00:12:24,010 --> 00:12:26,590
can be costly that's probably the thing

273
00:12:26,590 --> 00:12:32,740
that caused the difference know this you

274
00:12:32,740 --> 00:12:34,660
def so an integer division instruction

275
00:12:34,660 --> 00:12:38,800
that before probably gods yeah maybe

276
00:12:38,800 --> 00:12:43,540
it's division by a constant who knows so

277
00:12:43,540 --> 00:12:47,050
I think that's that might be the end of

278
00:12:47,050 --> 00:12:49,210
my demo if I remember correctly so I

279
00:12:49,210 --> 00:12:51,340
think in the in the course of maybe five

280
00:12:51,340 --> 00:12:55,150
to ten minutes we've jumped from let's

281
00:12:55,150 --> 00:12:56,950
see what's yesterday's run looked like

282
00:12:56,950 --> 00:13:00,160
we had a big performance Delta we

283
00:13:00,160 --> 00:13:02,500
ignored some pieces of noise and now we

284
00:13:02,500 --> 00:13:04,420
see this is the coach and code had

285
00:13:04,420 --> 00:13:05,620
changed and of course the performance

286
00:13:05,620 --> 00:13:07,160
difference

287
00:13:07,160 --> 00:13:11,740
and you've done something that doesn't

288
00:13:14,800 --> 00:13:18,680
yeah as far as I know someone might be

289
00:13:18,680 --> 00:13:24,920
work on that I don't know so for what

290
00:13:24,920 --> 00:13:27,320
it's worth this is a really really

291
00:13:27,320 --> 00:13:28,670
really simple reconstruction of the

292
00:13:28,670 --> 00:13:30,350
control flow graph it just has some

293
00:13:30,350 --> 00:13:31,670
regular expressions this looks like a

294
00:13:31,670 --> 00:13:36,950
branch so maybe it and so it's it's

295
00:13:36,950 --> 00:13:39,860
probably 99% accurate but for just

296
00:13:39,860 --> 00:13:45,620
looking at this it's good enough so what

297
00:13:45,620 --> 00:13:47,900
we've learned with going in there we

298
00:13:47,900 --> 00:13:49,490
understand what the codes differences

299
00:13:49,490 --> 00:13:51,200
from one day to the next

300
00:13:51,200 --> 00:13:53,480
however in LVM typically about 100

301
00:13:53,480 --> 00:13:55,960
commits per day I can sign up again ah

302
00:13:55,960 --> 00:13:58,370
typically about 100 commits per day so

303
00:13:58,370 --> 00:14:00,710
you don't yet have the specific commit

304
00:14:00,710 --> 00:14:02,330
if you look at the commits revisions you

305
00:14:02,330 --> 00:14:03,890
already know a division called change

306
00:14:03,890 --> 00:14:05,990
sometimes you can just guess which

307
00:14:05,990 --> 00:14:08,840
commit it was quite off one of the

308
00:14:08,840 --> 00:14:11,090
technique we use as we use a lot of VM

309
00:14:11,090 --> 00:14:13,910
lab bisect that's a tool that's in Zork

310
00:14:13,910 --> 00:14:20,090
now so what that tool can do is if from

311
00:14:20,090 --> 00:14:22,330
all of your build machines you store

312
00:14:22,330 --> 00:14:24,560
continuously it builds top of trunk line

313
00:14:24,560 --> 00:14:26,780
so you have a whole bunch of blank

314
00:14:26,780 --> 00:14:28,340
binaries available if you store them

315
00:14:28,340 --> 00:14:30,320
into a build cache on a separate server

316
00:14:30,320 --> 00:14:33,320
that particular script can fetch the

317
00:14:33,320 --> 00:14:36,800
different revisions from that server and

318
00:14:36,800 --> 00:14:39,220
then if you add a script to it saying

319
00:14:39,220 --> 00:14:42,500
this is a problem problematic generated

320
00:14:42,500 --> 00:14:44,660
code that's a good generated code it can

321
00:14:44,660 --> 00:14:48,770
bisect two specific comments you can

322
00:14:48,770 --> 00:14:50,780
follow the links for more documentation

323
00:14:50,780 --> 00:14:53,270
documentation is actually really nice so

324
00:14:53,270 --> 00:14:56,930
in combination with Allen T that we that

325
00:14:56,930 --> 00:14:59,210
I showed we understand what the code

326
00:14:59,210 --> 00:15:01,460
Chen differences with just a few minutes

327
00:15:01,460 --> 00:15:06,980
of looking around depending on the size

328
00:15:06,980 --> 00:15:08,420
of your benchmark is bisect will run

329
00:15:08,420 --> 00:15:11,360
quicker on or or slower but is bicycling

330
00:15:11,360 --> 00:15:12,950
point you to a specific commit so quite

331
00:15:12,950 --> 00:15:14,810
quickly you get to the point this commit

332
00:15:14,810 --> 00:15:16,850
cause that coaching difference and it

333
00:15:16,850 --> 00:15:20,710
costs a percentage of performance

334
00:15:53,200 --> 00:15:56,390
so for ya you could also allow the

335
00:15:56,390 --> 00:15:59,300
omelet you just put I think I believe

336
00:15:59,300 --> 00:16:01,700
it's you store the machine name it

337
00:16:01,700 --> 00:16:03,770
produced the clang binary so you could

338
00:16:03,770 --> 00:16:05,420
just sort all of them you could say

339
00:16:05,420 --> 00:16:07,490
these are stage 2 binaries if you have a

340
00:16:07,490 --> 00:16:09,140
fast machine that could do stage 2

341
00:16:09,140 --> 00:16:11,089
builds really fast you can have a really

342
00:16:11,089 --> 00:16:22,220
high nice resolution sorry question so

343
00:16:22,220 --> 00:16:23,960
in the for the specific problem we were

344
00:16:23,960 --> 00:16:27,410
looking at here so we ended up sharing

345
00:16:27,410 --> 00:16:29,150
that information

346
00:16:29,150 --> 00:16:31,400
within 24 hours of this culling

347
00:16:31,400 --> 00:16:33,710
committed this was detected we found out

348
00:16:33,710 --> 00:16:36,080
on it was how do we share that

349
00:16:36,080 --> 00:16:38,330
information well just send an email to

350
00:16:38,330 --> 00:16:40,400
the Indian album commits list every

351
00:16:40,400 --> 00:16:42,589
commit gets an email just reply to that

352
00:16:42,589 --> 00:16:44,390
one it guesses the original author

353
00:16:44,390 --> 00:16:47,270
saying we found something here luckily

354
00:16:47,270 --> 00:16:49,430
we also saw the problem on one of the

355
00:16:49,430 --> 00:16:53,060
public BOTS so then it's extra nice the

356
00:16:53,060 --> 00:16:55,700
the original developer if he works at

357
00:16:55,700 --> 00:16:59,450
another place they can also see that's a

358
00:16:59,450 --> 00:17:02,270
particular problem and yeah got fixed

359
00:17:02,270 --> 00:17:06,170
within 48 hours and regressions are

360
00:17:06,170 --> 00:17:08,060
cheap if they got fixed quickly realize

361
00:17:08,060 --> 00:17:15,199
after so I let me move back on my claims

362
00:17:15,199 --> 00:17:19,880
so I think with the demo I hope that we

363
00:17:19,880 --> 00:17:22,130
it the the improvement that I've shown

364
00:17:22,130 --> 00:17:24,920
here in L&T it does help to to signal

365
00:17:24,920 --> 00:17:26,660
issues in a way that is actionable we

366
00:17:26,660 --> 00:17:28,720
ended up sending an email quickly and

367
00:17:28,720 --> 00:17:31,250
require little effort well actually we

368
00:17:31,250 --> 00:17:34,900
all did the analysis together in a few

369
00:17:34,900 --> 00:17:37,790
so now I'm moving to enabling a culture

370
00:17:37,790 --> 00:17:43,160
of acting on Delta's I think where we're

371
00:17:43,160 --> 00:17:45,080
starting to see some more signs of

372
00:17:45,080 --> 00:17:48,110
there's an improvement there at least I

373
00:17:48,110 --> 00:17:49,580
think it was Arno actually sending the

374
00:17:49,580 --> 00:17:51,950
email last April that particular one you

375
00:17:51,950 --> 00:17:54,500
see it gets acted on so it's there

376
00:17:54,500 --> 00:17:55,760
there's an improvement compared to

377
00:17:55,760 --> 00:17:57,590
number of years ago it's probably a lot

378
00:17:57,590 --> 00:17:59,960
more likely be done to to just make it

379
00:17:59,960 --> 00:18:03,380
easier to act on Delta's my list of

380
00:18:03,380 --> 00:18:05,960
ideas is yeah it would be nice if more

381
00:18:05,960 --> 00:18:08,060
of these performance reporting bugs

382
00:18:08,060 --> 00:18:10,160
would be public so more people can look

383
00:18:10,160 --> 00:18:13,310
at the performance results at the moment

384
00:18:13,310 --> 00:18:15,500
our swamp public LNT server so what I

385
00:18:15,500 --> 00:18:17,960
show here was another top of truncal NT

386
00:18:17,960 --> 00:18:20,270
server running on my laptop the public

387
00:18:20,270 --> 00:18:22,640
one runs a version that's quite old so

388
00:18:22,640 --> 00:18:25,730
that we need to find a way to make sure

389
00:18:25,730 --> 00:18:27,830
that someone can maintain that the

390
00:18:27,830 --> 00:18:32,600
public an NT server instance after that

391
00:18:32,600 --> 00:18:35,690
works then some of the things people

392
00:18:35,690 --> 00:18:39,110
notices in test suite there's about 500

393
00:18:39,110 --> 00:18:42,440
programs then don't cover all possible

394
00:18:42,440 --> 00:18:47,000
use cases of LV M so more code needs to

395
00:18:47,000 --> 00:18:49,310
be added actually I see some

396
00:18:49,310 --> 00:18:51,800
improvements there bit code files got

397
00:18:51,800 --> 00:18:53,450
added from the highlights from dance

398
00:18:53,450 --> 00:18:55,970
which that must be someone in the room

399
00:18:55,970 --> 00:18:57,710
who knows much more about halide than I

400
00:18:57,710 --> 00:19:00,020
do but it's a front-end producing IR

401
00:19:00,020 --> 00:19:01,550
code directly not coming from clang so

402
00:19:01,550 --> 00:19:02,900
it's nice you might have some different

403
00:19:02,900 --> 00:19:06,830
idioms you also see the start of some

404
00:19:06,830 --> 00:19:09,470
benchmarks representing HPC specific use

405
00:19:09,470 --> 00:19:13,760
cases before then the end it's also

406
00:19:13,760 --> 00:19:16,040
important that when we add more tests

407
00:19:16,040 --> 00:19:18,350
the whole test suite doesn't run much

408
00:19:18,350 --> 00:19:20,600
longer since then we lose resolution

409
00:19:20,600 --> 00:19:22,550
it's really nice now that the test suite

410
00:19:22,550 --> 00:19:24,230
all in all doesn't run that long you

411
00:19:24,230 --> 00:19:27,110
even on very slow systems you get

412
00:19:27,110 --> 00:19:29,450
feedback relatively quickly so you can

413
00:19:29,450 --> 00:19:31,400
get multiple data points per day if you

414
00:19:31,400 --> 00:19:35,180
want to and I think the holy greatest

415
00:19:35,180 --> 00:19:38,570
for correctness issues we now have BOTS

416
00:19:38,570 --> 00:19:40,720
automatically emailing

417
00:19:40,720 --> 00:19:42,710
committers if they regress the

418
00:19:42,710 --> 00:19:44,810
correctness issue I think the holy grail

419
00:19:44,810 --> 00:19:47,059
is we want to get to automated emails of

420
00:19:47,059 --> 00:19:49,519
for most apples also but you have to

421
00:19:49,519 --> 00:19:52,490
have really high signal-to-noise ratio

422
00:19:52,490 --> 00:19:54,919
so they have to be very very few false

423
00:19:54,919 --> 00:19:56,749
positives otherwise developers will just

424
00:19:56,749 --> 00:20:07,759
ignore the bots yeah but then you saw

425
00:20:07,759 --> 00:20:10,549
how much human effort was involved here

426
00:20:10,549 --> 00:20:13,669
I think we're getting close to for some

427
00:20:13,669 --> 00:20:15,409
kinds of performance issues the one I

428
00:20:15,409 --> 00:20:18,379
demonstrated we probably could automate

429
00:20:18,379 --> 00:20:23,029
that one but yet there's always going to

430
00:20:23,029 --> 00:20:25,669
be lots of like Delta's were even

431
00:20:25,669 --> 00:20:27,980
between difficult party developers there

432
00:20:27,980 --> 00:20:29,779
will be a difference of interpretation

433
00:20:29,779 --> 00:20:31,460
saying no this is a regression no

434
00:20:31,460 --> 00:20:32,749
there's actually how it should be done

435
00:20:32,749 --> 00:20:55,970
and so the benchmarks we could paralyze

436
00:20:55,970 --> 00:21:00,830
the that's also possible there are ice

437
00:21:00,830 --> 00:21:03,950
well as part of another presentation I

438
00:21:03,950 --> 00:21:05,690
gave earlier I still believe that we

439
00:21:05,690 --> 00:21:07,490
could make the test suite run ten times

440
00:21:07,490 --> 00:21:09,529
faster and still find all of the

441
00:21:09,529 --> 00:21:12,080
problems we have right now and not have

442
00:21:12,080 --> 00:21:13,610
any more noise like there's a few

443
00:21:13,610 --> 00:21:15,019
programs in the test suite that take

444
00:21:15,019 --> 00:21:16,759
quite a long time if you just make those

445
00:21:16,759 --> 00:21:18,499
just say instead of thousand iterations

446
00:21:18,499 --> 00:21:20,600
when for ten iterations we'll still find

447
00:21:20,600 --> 00:21:23,330
the same problems we just have it at a

448
00:21:23,330 --> 00:21:27,369
higher resolution it's a bit of work

449
00:21:28,779 --> 00:21:31,759
using a lot of young projects so I think

450
00:21:31,759 --> 00:21:34,429
out of everything that I showed here

451
00:21:34,429 --> 00:21:37,009
there wasn't anything specifically for

452
00:21:37,009 --> 00:21:40,100
all of em it's for the code generator

453
00:21:40,100 --> 00:21:42,649
there's many code generators so how good

454
00:21:42,649 --> 00:21:46,369
is how easy is it to use L&T and all the

455
00:21:46,369 --> 00:21:47,299
code generators

456
00:21:47,299 --> 00:21:50,659
well the interface into the LNT servers

457
00:21:50,659 --> 00:21:53,929
so while I demonstrate it is a JSON file

458
00:21:53,929 --> 00:21:55,490
so all the informations in JSON file

459
00:21:55,490 --> 00:21:58,009
that has been documented since last year

460
00:21:58,009 --> 00:22:00,150
so if you have

461
00:22:00,150 --> 00:22:01,800
path says that you've invested lots of

462
00:22:01,800 --> 00:22:04,440
effort into as long as you can produce

463
00:22:04,440 --> 00:22:08,250
your your results into adjacent file you

464
00:22:08,250 --> 00:22:09,840
can input this and you have all of the

465
00:22:09,840 --> 00:22:13,560
analysis you have here so I can just say

466
00:22:13,560 --> 00:22:15,570
that's at least at the arm we have the

467
00:22:15,570 --> 00:22:18,120
LLVM team using this obviously we also

468
00:22:18,120 --> 00:22:20,520
have the GCC team we started using it

469
00:22:20,520 --> 00:22:23,940
and we have a team working on the

470
00:22:23,940 --> 00:22:26,070
product called cycle models who are

471
00:22:26,070 --> 00:22:27,360
developed as part of that they're

472
00:22:27,360 --> 00:22:29,280
developing a very low to C++ compiler

473
00:22:29,280 --> 00:22:31,250
they're all they also started using this

474
00:22:31,250 --> 00:22:34,920
just to show that there's if you have a

475
00:22:34,920 --> 00:22:37,590
code generator my feel is that you could

476
00:22:37,590 --> 00:22:39,810
use L&T if you think from what you saw

477
00:22:39,810 --> 00:22:45,330
from in the demo it's useful what else

478
00:22:45,330 --> 00:22:49,230
is there so the profile view that I've

479
00:22:49,230 --> 00:22:52,890
shown it means you have to run if you

480
00:22:52,890 --> 00:22:54,690
run your program multiple times to make

481
00:22:54,690 --> 00:22:55,950
sure that you've got statistical

482
00:22:55,950 --> 00:22:59,670
significant results one of these runs

483
00:22:59,670 --> 00:23:01,830
have to be done under linux perth to get

484
00:23:01,830 --> 00:23:05,610
a profile it has to be stored so what

485
00:23:05,610 --> 00:23:07,410
we've done in the test suite is that

486
00:23:07,410 --> 00:23:09,390
with the c make slash notification of

487
00:23:09,390 --> 00:23:12,000
test suite which means you compile the

488
00:23:12,000 --> 00:23:14,010
programs with c make and then let us use

489
00:23:14,010 --> 00:23:16,860
to run them it now becomes

490
00:23:16,860 --> 00:23:18,240
straightforward if you add extra

491
00:23:18,240 --> 00:23:19,650
benchmarks you just drop in its

492
00:23:19,650 --> 00:23:21,600
subdirectory which with also a c make

493
00:23:21,600 --> 00:23:24,990
file then out of the box it will it will

494
00:23:24,990 --> 00:23:27,330
run multiple times will invoke linux /

495
00:23:27,330 --> 00:23:28,650
for you collect all the data in the

496
00:23:28,650 --> 00:23:30,690
right way so if you add more benchmarks

497
00:23:30,690 --> 00:23:33,840
to the test suites figure for maybe your

498
00:23:33,840 --> 00:23:35,790
non-public needs you can do that without

499
00:23:35,790 --> 00:23:37,890
lots and lots of boilerplate as long as

500
00:23:37,890 --> 00:23:39,990
you have the c make file describes how

501
00:23:39,990 --> 00:23:43,190
to build with the benchmarks

502
00:23:43,250 --> 00:23:48,890
oh yeah yeah yeah so yeah so we've added

503
00:23:48,890 --> 00:23:51,680
quite a few Eva benchmarks beyond that

504
00:23:51,680 --> 00:23:56,780
to the the these kinds of runs so in

505
00:23:56,780 --> 00:24:01,030
summary I think there was a uh well

506
00:24:01,030 --> 00:24:04,430
without necessary that much work I think

507
00:24:04,430 --> 00:24:05,780
in using Allen T there was a big

508
00:24:05,780 --> 00:24:09,340
improvements compared to last year

509
00:24:09,340 --> 00:24:11,570
documentation has improved probably

510
00:24:11,570 --> 00:24:13,100
they're still quite a bit to be done

511
00:24:13,100 --> 00:24:15,260
because documentation gets written by

512
00:24:15,260 --> 00:24:16,940
the people who use it most actively and

513
00:24:16,940 --> 00:24:18,740
then you can you get blind spots for

514
00:24:18,740 --> 00:24:23,600
things that Michael be obvious so if so

515
00:24:23,600 --> 00:24:26,450
if you would like to try Allen T and you

516
00:24:26,450 --> 00:24:28,190
find some of the documentation isn't

517
00:24:28,190 --> 00:24:31,790
isn't perfect then yeah do please raise

518
00:24:31,790 --> 00:24:34,730
it either via email or in the LLVM bug

519
00:24:34,730 --> 00:24:37,280
tracker on your component L&T or if you

520
00:24:37,280 --> 00:24:38,960
do use it and you find some issues not

521
00:24:38,960 --> 00:24:41,920
there are some issues do please file

522
00:24:41,920 --> 00:24:45,530
tickets in there and that's all any

523
00:24:45,530 --> 00:24:47,800
questions

524
00:24:52,900 --> 00:24:59,070
great oh you know how does it scale up

525
00:24:59,070 --> 00:25:06,309
or how can I answer that's so we use it

526
00:25:06,309 --> 00:25:08,440
internally in an arm at with our

527
00:25:08,440 --> 00:25:10,680
performance data into a single database

528
00:25:10,680 --> 00:25:13,330
actually so you've that there's two

529
00:25:13,330 --> 00:25:15,100
underlying data bases that can be used

530
00:25:15,100 --> 00:25:17,500
Postgres or sequel lights so far we

531
00:25:17,500 --> 00:25:19,330
store everything in sequel light we

532
00:25:19,330 --> 00:25:21,400
don't have a huge issue with that's

533
00:25:21,400 --> 00:25:24,040
maybe the first person I could sing the

534
00:25:24,040 --> 00:25:27,040
weapon to face in the morning some of it

535
00:25:27,040 --> 00:25:28,210
needs to be cached and it takes a little

536
00:25:28,210 --> 00:25:33,330
while but once it's cached in it works

537
00:25:33,330 --> 00:25:39,130
well so all in all I think it doesn't

538
00:25:39,130 --> 00:25:41,110
have huge scaling problems some of the

539
00:25:41,110 --> 00:25:42,850
analysis that gets run for example in

540
00:25:42,850 --> 00:25:44,740
data report page they're quite involved

541
00:25:44,740 --> 00:25:46,090
they need to pull in quite a lot of

542
00:25:46,090 --> 00:25:48,190
information with a daily report page no

543
00:25:48,190 --> 00:25:52,590
you get it back in a matter of seconds

544
00:25:52,590 --> 00:25:56,110
so yeah we haven't seen too much

545
00:25:56,110 --> 00:25:59,140
problems there there's one just one

546
00:25:59,140 --> 00:26:01,150
issue in the in a database schema where

547
00:26:01,150 --> 00:26:02,950
it's a little bit inflexible to add

548
00:26:02,950 --> 00:26:04,660
extra metrics let's let's say for

549
00:26:04,660 --> 00:26:07,000
example next to the code size or the

550
00:26:07,000 --> 00:26:08,740
performance of the code you want to

551
00:26:08,740 --> 00:26:10,570
measure another aspect of the generated

552
00:26:10,570 --> 00:26:14,800
code if you want to sort it exactly in

553
00:26:14,800 --> 00:26:16,900
the database schema that's a bit

554
00:26:16,900 --> 00:26:19,030
inflexible now it's also a bit hard to

555
00:26:19,030 --> 00:26:21,429
change that's that whole schema because

556
00:26:21,429 --> 00:26:23,380
you have to make sure that you don't you

557
00:26:23,380 --> 00:26:25,150
make scaling at least as good as this

558
00:26:25,150 --> 00:26:27,540
right now

559
00:26:33,750 --> 00:26:36,370
so in a test suite you've got something

560
00:26:36,370 --> 00:26:39,580
like 500 tests per run and then you have

561
00:26:39,580 --> 00:26:41,620
a whole bunch of machines producing that

562
00:26:41,620 --> 00:26:48,880
and then so it probably you need to ask

563
00:26:48,880 --> 00:26:51,340
about how how does it scale for number

564
00:26:51,340 --> 00:26:53,650
of tests store the database or number

565
00:26:53,650 --> 00:26:55,600
for this daily report page number of

566
00:26:55,600 --> 00:26:57,640
tests run on that particular day because

567
00:26:57,640 --> 00:26:59,260
that's the amount available that will

568
00:26:59,260 --> 00:27:04,090
get analyzed yeah I'm not sure I've I

569
00:27:04,090 --> 00:27:06,310
think maybe we're we must be somewhere

570
00:27:06,310 --> 00:27:08,170
around ten thousand hundred thousand

571
00:27:08,170 --> 00:27:11,350
tests in a day probably just off the

572
00:27:11,350 --> 00:27:13,740
back of my head order of magnitude I'm

573
00:27:13,740 --> 00:27:16,990
assuming there must be people who go in

574
00:27:16,990 --> 00:27:20,290
order of magnitude higher at least so

575
00:27:20,290 --> 00:27:37,630
try it out and get feedback that's four

576
00:27:37,630 --> 00:27:42,840
points for a single program yeah so ya

577
00:27:44,610 --> 00:27:48,730
know well if someone would want to

578
00:27:48,730 --> 00:27:50,770
create another viewer vandalize all of

579
00:27:50,770 --> 00:27:53,440
the data for all of the time then yeah

580
00:27:53,440 --> 00:28:04,650
that will be half yeah yeah that's just

581
00:28:04,650 --> 00:28:09,120
so let me go back it's actually so

582
00:28:09,120 --> 00:28:12,760
there's so if you look at here in the

583
00:28:12,760 --> 00:28:16,840
URL it's parameter they're like very

584
00:28:16,840 --> 00:28:18,550
small tweaks like this to just make it

585
00:28:18,550 --> 00:28:20,380
an input box on the webpage that would

586
00:28:20,380 --> 00:28:22,480
be really nice it's not there so there's

587
00:28:22,480 --> 00:28:23,770
probably lots of tweaks that can be done

588
00:28:23,770 --> 00:28:27,610
but at least for myself I'm compiler

589
00:28:27,610 --> 00:28:28,930
developer and not an infrastructure

590
00:28:28,930 --> 00:28:31,000
developer like this so I added stuff

591
00:28:31,000 --> 00:28:34,890
until my job got a lot easier

592
00:28:52,620 --> 00:28:55,570
so you said you the question is can you

593
00:28:55,570 --> 00:28:58,980
use it with a jet

594
00:29:00,220 --> 00:29:02,799
so definitely what the page you see on

595
00:29:02,799 --> 00:29:05,110
the screen now any code generator you

596
00:29:05,110 --> 00:29:07,660
can use it with where it gets more

597
00:29:07,660 --> 00:29:09,070
interesting probably a sweat on the

598
00:29:09,070 --> 00:29:11,260
profile page where you see this assembly

599
00:29:11,260 --> 00:29:14,440
and then it depends right now LNT

600
00:29:14,440 --> 00:29:16,360
assumes that's in the JSON file with

601
00:29:16,360 --> 00:29:18,460
data you produce it has a format that

602
00:29:18,460 --> 00:29:20,260
looks like Linux perf so you have a

603
00:29:20,260 --> 00:29:22,299
percentage on the line and then some

604
00:29:22,299 --> 00:29:26,290
code next to it it does it doesn't have

605
00:29:26,290 --> 00:29:33,490
to be in assembly instruction so how you

606
00:29:33,490 --> 00:29:37,960
get how you get to the data from the jet

607
00:29:37,960 --> 00:29:40,929
that I don't know but if you have data

608
00:29:40,929 --> 00:29:42,880
that you can represent with a percentage

609
00:29:42,880 --> 00:29:44,799
of execution time with the line of code

610
00:29:44,799 --> 00:29:48,299
next to it it can go in

611
00:29:55,630 --> 00:29:58,660
okay that seems like that's it thank you

612
00:29:58,660 --> 00:29:59,820
very much

613
00:29:59,820 --> 00:30:05,859
[Applause]

