1
00:00:00,060 --> 00:00:03,140
so Mike

2
00:00:04,490 --> 00:00:07,629
phones turn on let me get rid of this

3
00:00:07,629 --> 00:00:11,119
yeah so now I'm going to talk about

4
00:00:11,119 --> 00:00:13,339
cloud API for FreeBSD how does it work

5
00:00:13,339 --> 00:00:15,559
I'll I'll briefly explain how this talk

6
00:00:15,559 --> 00:00:19,070
came to exist the deadline for the like

7
00:00:19,070 --> 00:00:21,439
the submissions for the BSD dev room was

8
00:00:21,439 --> 00:00:23,599
like before the submission deadline for

9
00:00:23,599 --> 00:00:26,300
the main track I think I wanted to get

10
00:00:26,300 --> 00:00:27,560
into the main track but I still wanted

11
00:00:27,560 --> 00:00:29,359
to sort of have a back-up plan so I made

12
00:00:29,359 --> 00:00:30,589
two submissions and both of them got

13
00:00:30,589 --> 00:00:33,620
accepted they all had like exactly the

14
00:00:33,620 --> 00:00:38,440
same abstract so I was playing

15
00:00:42,870 --> 00:00:45,150
but then what we go sort of poked me

16
00:00:45,150 --> 00:00:46,440
hard enough and he said no you have to

17
00:00:46,440 --> 00:00:49,440
give two talks so this is why I've sort

18
00:00:49,440 --> 00:00:51,360
of spun off a bit and this is about a

19
00:00:51,360 --> 00:00:53,160
different topic during the main track I

20
00:00:53,160 --> 00:00:55,140
gave a talk about cloud avi itself and

21
00:00:55,140 --> 00:00:57,059
I'm going to sort of explain how it

22
00:00:57,059 --> 00:01:00,720
works in FreeBSD well it's going to be

23
00:01:00,720 --> 00:01:01,860
interesting about this talk is that I

24
00:01:01,860 --> 00:01:04,650
don't have any slide and one of the

25
00:01:04,650 --> 00:01:06,060
reasons for that is while I was sort of

26
00:01:06,060 --> 00:01:08,130
preparing this talk and figuring out

27
00:01:08,130 --> 00:01:11,070
what to put in slides I noticed that I

28
00:01:11,070 --> 00:01:13,590
wanted to make so many demos and play

29
00:01:13,590 --> 00:01:16,380
around in the terminal so so often that

30
00:01:16,380 --> 00:01:19,440
I decided to sort of just stay stick to

31
00:01:19,440 --> 00:01:21,630
this so for the people have seen books

32
00:01:21,630 --> 00:01:24,300
talk earlier today today but like he's

33
00:01:24,300 --> 00:01:26,310
really nice flame charts they're not

34
00:01:26,310 --> 00:01:28,649
going to see any of those today it's not

35
00:01:28,649 --> 00:01:30,570
as fleshed out as his stuff so if you

36
00:01:30,570 --> 00:01:32,520
have seen Brooks's talk earlier today

37
00:01:32,520 --> 00:01:33,990
about hello world or has seen it before

38
00:01:33,990 --> 00:01:36,270
a couple of people who have you ever

39
00:01:36,270 --> 00:01:38,009
seen my talk about cloud ABI junior main

40
00:01:38,009 --> 00:01:42,240
track only a couple of hands so first

41
00:01:42,240 --> 00:01:45,210
I'm going to like if this really brief

42
00:01:45,210 --> 00:01:46,950
introduction about what cloud API is

43
00:01:46,950 --> 00:01:49,319
it's basically sort of a programming

44
00:01:49,319 --> 00:01:51,959
environment similar to like the C

45
00:01:51,959 --> 00:01:54,090
programming environment on like Linux

46
00:01:54,090 --> 00:01:56,610
FreeBSD etc but it's stripped down in

47
00:01:56,610 --> 00:01:58,590
such a way that you can use it to build

48
00:01:58,590 --> 00:01:59,819
programs that are really strongly

49
00:01:59,819 --> 00:02:02,190
sandboxed so if you just stick to the

50
00:02:02,190 --> 00:02:05,250
API set of provided by this runtime

51
00:02:05,250 --> 00:02:08,008
environment then in theory you should

52
00:02:08,008 --> 00:02:09,660
end up with a program that get is like

53
00:02:09,660 --> 00:02:12,300
really easy to sandbox so I'll sort of

54
00:02:12,300 --> 00:02:14,760
give a demo of how it works this is a

55
00:02:14,760 --> 00:02:16,500
demo demo that I want to show during my

56
00:02:16,500 --> 00:02:18,240
main talk but I unfortunately didn't

57
00:02:18,240 --> 00:02:20,640
manage to because of time constraints so

58
00:02:20,640 --> 00:02:22,470
what I've done is I've written this tiny

59
00:02:22,470 --> 00:02:24,510
web server and C cloud ABI - web server

60
00:02:24,510 --> 00:02:27,030
LT and and there's this configuration

61
00:02:27,030 --> 00:02:28,170
file and I'll first show the

62
00:02:28,170 --> 00:02:30,180
configuration file because this sort of

63
00:02:30,180 --> 00:02:31,980
shows how the program is going to be

64
00:02:31,980 --> 00:02:35,250
started up this is sort of you can think

65
00:02:35,250 --> 00:02:36,480
of it as like the replacement for

66
00:02:36,480 --> 00:02:38,310
command line arguments in a certain way

67
00:02:38,310 --> 00:02:40,560
where it describes like we want to start

68
00:02:40,560 --> 00:02:41,489
this web server and it needs to be

69
00:02:41,489 --> 00:02:43,920
starting to say so what I do is this is

70
00:02:43,920 --> 00:02:45,180
like the entire configuration where I

71
00:02:45,180 --> 00:02:47,489
say like this is a Yama file it has a

72
00:02:47,489 --> 00:02:49,739
couple of key values in there namely at

73
00:02:49,739 --> 00:02:51,510
first we're saying we need to have a

74
00:02:51,510 --> 00:02:53,939
socket and the socket needs to be this

75
00:02:53,939 --> 00:02:56,189
file descriptor of like a bound bound to

76
00:02:56,189 --> 00:02:56,760
TCP

77
00:02:56,760 --> 00:02:59,069
bored on which the webserver can receive

78
00:02:59,069 --> 00:03:01,409
its incoming TCP requests we have a file

79
00:03:01,409 --> 00:03:03,209
descriptor where we want to sort of

80
00:03:03,209 --> 00:03:05,250
write out log file entries and then

81
00:03:05,250 --> 00:03:06,390
there is a sort of fixed response

82
00:03:06,390 --> 00:03:08,220
message that this web server needs to

83
00:03:08,220 --> 00:03:10,739
print so this is the entire config file

84
00:03:10,739 --> 00:03:13,079
for a web server then there is the C

85
00:03:13,079 --> 00:03:15,060
file over here that implements this web

86
00:03:15,060 --> 00:03:16,709
server now sort of zoom out a bit

87
00:03:16,709 --> 00:03:19,470
because font size it should be good

88
00:03:19,470 --> 00:03:21,870
enough for you guys so at the top part

89
00:03:21,870 --> 00:03:24,269
there is this chunk of code and this is

90
00:03:24,269 --> 00:03:25,709
sort of all we need to put in a source

91
00:03:25,709 --> 00:03:27,209
file to parse this llamo follower

92
00:03:27,209 --> 00:03:29,519
extract the values out of the mo file so

93
00:03:29,519 --> 00:03:30,959
you see that we're extracting the socket

94
00:03:30,959 --> 00:03:32,400
log file a message actually attributes

95
00:03:32,400 --> 00:03:34,590
from the mo and then here at the bottom

96
00:03:34,590 --> 00:03:36,239
we have sort of this main loop of the

97
00:03:36,239 --> 00:03:39,060
web server where we're using the socket

98
00:03:39,060 --> 00:03:42,019
that was specified in the config file

99
00:03:42,019 --> 00:03:45,389
and for every request that we get we

100
00:03:45,389 --> 00:03:46,920
print a lock message and we write a

101
00:03:46,920 --> 00:03:49,560
response back to the browser so I can

102
00:03:49,560 --> 00:03:52,950
sort of show you what happens if I run

103
00:03:52,950 --> 00:03:54,389
it so there's this launcher utility

104
00:03:54,389 --> 00:03:56,579
called call ABI - run where we say we

105
00:03:56,579 --> 00:03:58,799
want to run this executable and specify

106
00:03:58,799 --> 00:04:00,120
this configuration flag

107
00:04:00,120 --> 00:04:02,250
the reason I'm passing in this - a flag

108
00:04:02,250 --> 00:04:03,810
over here is normally a freebies thing

109
00:04:03,810 --> 00:04:06,150
you don't need to do this but on Mac OS

110
00:04:06,150 --> 00:04:08,250
I'm using a stock operating system

111
00:04:08,250 --> 00:04:09,810
that's not capable of running cloud ABI

112
00:04:09,810 --> 00:04:11,699
software so I'm passing in like the

113
00:04:11,699 --> 00:04:14,250
deshi flag to turn on emulation so if I

114
00:04:14,250 --> 00:04:16,620
run this then I get this big warning

115
00:04:16,620 --> 00:04:18,510
message saying that you know emulation

116
00:04:18,510 --> 00:04:21,418
is not ideal and not secure but if I now

117
00:04:21,418 --> 00:04:24,720
open up the browser and go to localhost

118
00:04:24,720 --> 00:04:26,580
one-two-three-four-five you actually see

119
00:04:26,580 --> 00:04:28,490
that this web server serving requests so

120
00:04:28,490 --> 00:04:30,930
now I can just refresh this page and you

121
00:04:30,930 --> 00:04:33,210
see requests ending up at the web server

122
00:04:33,210 --> 00:04:35,250
and basically the idea behind cloud ABI

123
00:04:35,250 --> 00:04:37,650
is that because we sort of have this

124
00:04:37,650 --> 00:04:39,659
policy file or this configuration file

125
00:04:39,659 --> 00:04:40,860
that explains how this needs to be

126
00:04:40,860 --> 00:04:43,110
started up cloud API run can sort of

127
00:04:43,110 --> 00:04:44,699
make sure that only those resources are

128
00:04:44,699 --> 00:04:46,380
available to the program so only the

129
00:04:46,380 --> 00:04:48,419
socket and the file descriptor of the

130
00:04:48,419 --> 00:04:50,070
log file are available to the process

131
00:04:50,070 --> 00:04:52,349
nothing else so if an attacker would

132
00:04:52,349 --> 00:04:54,750
take over this application that person

133
00:04:54,750 --> 00:04:56,310
couldn't do anything else then interact

134
00:04:56,310 --> 00:04:59,070
with the socket and the the log file

135
00:04:59,070 --> 00:05:01,560
file descriptor so you can even run this

136
00:05:01,560 --> 00:05:02,940
web service route in theory doesn't

137
00:05:02,940 --> 00:05:04,680
matter the program's constrained dudes

138
00:05:04,680 --> 00:05:05,900
file descriptors at all times

139
00:05:05,900 --> 00:05:08,789
so that's sort of this five minute

140
00:05:08,789 --> 00:05:10,380
introduction of our cloud API is it's

141
00:05:10,380 --> 00:05:10,710
nothing

142
00:05:10,710 --> 00:05:12,060
more than this a constraint programming

143
00:05:12,060 --> 00:05:13,290
environment that allows you to build

144
00:05:13,290 --> 00:05:16,470
these sandbox programs so the goal of

145
00:05:16,470 --> 00:05:18,090
today's talk is to sort of show you how

146
00:05:18,090 --> 00:05:20,490
it works in the freebsd side or like if

147
00:05:20,490 --> 00:05:22,530
you're developing programs or freebie is

148
00:05:22,530 --> 00:05:23,910
the what are sort of like the

149
00:05:23,910 --> 00:05:25,620
modifications had to make you freebsd

150
00:05:25,620 --> 00:05:27,330
into some of the related components to

151
00:05:27,330 --> 00:05:31,260
actually get this to work this talk sort

152
00:05:31,260 --> 00:05:33,930
of has two target audiences so the first

153
00:05:33,930 --> 00:05:35,910
group of like people this is addressed

154
00:05:35,910 --> 00:05:38,850
those people who love cloud ABI I want

155
00:05:38,850 --> 00:05:40,470
to know more and the second group of

156
00:05:40,470 --> 00:05:42,990
people is people who hate cloud ABI and

157
00:05:42,990 --> 00:05:44,190
want to know how to design something

158
00:05:44,190 --> 00:05:46,800
like that themselves that sort of be the

159
00:05:46,800 --> 00:05:51,120
trade-off so the first thing we're going

160
00:05:51,120 --> 00:05:53,100
to take a look at this is a FreeBSD

161
00:05:53,100 --> 00:05:54,750
system on which we can also run cloud

162
00:05:54,750 --> 00:05:57,420
API programs is how does like

163
00:05:57,420 --> 00:05:59,340
development of cloud API programs works

164
00:05:59,340 --> 00:06:00,810
all clear this terminal because I don't

165
00:06:00,810 --> 00:06:03,330
want to spoil anything so on this system

166
00:06:03,330 --> 00:06:09,590
what I can do is I'm here is know a

167
00:06:09,680 --> 00:06:12,810
simple source or resizes virtual machine

168
00:06:12,810 --> 00:06:14,100
a bit because some of it is going

169
00:06:14,100 --> 00:06:17,460
off-screen there is this cross compiler

170
00:06:17,460 --> 00:06:20,430
that you can invoke like this so instead

171
00:06:20,430 --> 00:06:23,040
of calling CC 2 to build your programs

172
00:06:23,040 --> 00:06:24,570
you can use the cloudy ABI cross

173
00:06:24,570 --> 00:06:26,790
compiler this this can be used to build

174
00:06:26,790 --> 00:06:28,800
software and now we're sort of first

175
00:06:28,800 --> 00:06:31,560
going to reverse engineer this compiler

176
00:06:31,560 --> 00:06:33,300
how does this compiler work well what's

177
00:06:33,300 --> 00:06:34,140
so special about it

178
00:06:34,140 --> 00:06:36,870
so this compiler is actually provided by

179
00:06:36,870 --> 00:06:38,820
a package called cloudy ABI toolchain

180
00:06:38,820 --> 00:06:41,570
and if we take a look at its contents

181
00:06:41,570 --> 00:06:44,310
you actually see that this package

182
00:06:44,310 --> 00:06:46,110
installs this this punch of files and

183
00:06:46,110 --> 00:06:48,180
basically what it does for every

184
00:06:48,180 --> 00:06:49,800
architecture that cloud API supports

185
00:06:49,800 --> 00:06:53,970
namely arm v6 arm 64 and x86 go 32 64

186
00:06:53,970 --> 00:06:56,910
bits it installs the same files namely

187
00:06:56,910 --> 00:06:58,260
like a cross-product of all of the

188
00:06:58,260 --> 00:07:01,860
development tools so it's pretty nice

189
00:07:01,860 --> 00:07:03,630
you installed a single package and you

190
00:07:03,630 --> 00:07:05,310
end up with a compiler for all of the

191
00:07:05,310 --> 00:07:06,870
architectures in one go there's no need

192
00:07:06,870 --> 00:07:09,060
to install four copies of GCC and bin

193
00:07:09,060 --> 00:07:12,150
utils etc so now we're going to take a

194
00:07:12,150 --> 00:07:13,890
look up like those binaries where do

195
00:07:13,890 --> 00:07:18,480
they come from so when we run an LS on

196
00:07:18,480 --> 00:07:20,220
unlike one of the compiler executables

197
00:07:20,220 --> 00:07:21,570
we see that it's actually a symbolic

198
00:07:21,570 --> 00:07:24,100
link over to

199
00:07:24,100 --> 00:07:26,500
I am three point nine so this is

200
00:07:26,500 --> 00:07:27,850
actually the compiler binary that's

201
00:07:27,850 --> 00:07:29,770
provided by the stock freebies the LVM

202
00:07:29,770 --> 00:07:31,540
three point nine package that's actually

203
00:07:31,540 --> 00:07:33,280
maintained by Brooks right yeah you also

204
00:07:33,280 --> 00:07:35,740
maintain the stable versions of the the

205
00:07:35,740 --> 00:07:37,930
compiler packages so now what I'm going

206
00:07:37,930 --> 00:07:39,310
to do is I'm going to spend the next

207
00:07:39,310 --> 00:07:41,470
couple of minutes sort of browsing

208
00:07:41,470 --> 00:07:42,940
through the LLVM source tree and sort of

209
00:07:42,940 --> 00:07:47,050
show to you what kind of changes I've

210
00:07:47,050 --> 00:07:50,800
made so one of the first things you'll

211
00:07:50,800 --> 00:07:52,480
notice if you're sort of running some of

212
00:07:52,480 --> 00:07:54,460
the the development tools on the cloud

213
00:07:54,460 --> 00:07:57,010
EBR executables so now we're going to

214
00:07:57,010 --> 00:07:59,410
run read elf and sort of take a look at

215
00:07:59,410 --> 00:08:01,680
what a cloud a bi executable looks like

216
00:08:01,680 --> 00:08:04,420
it turns out a cloud a bi executables

217
00:08:04,420 --> 00:08:06,070
nothing more than like an Aleph program

218
00:08:06,070 --> 00:08:07,720
so it's the same executable format as

219
00:08:07,720 --> 00:08:08,970
what you see on linux and freebsd

220
00:08:08,970 --> 00:08:13,240
solaris etc but there are two things

221
00:08:13,240 --> 00:08:15,100
that are sort of different compared to

222
00:08:15,100 --> 00:08:17,050
freebsd or at least two things are

223
00:08:17,050 --> 00:08:18,850
different so first of all what you see

224
00:08:18,850 --> 00:08:23,370
over here this thing unknown oh x11 so

225
00:08:23,370 --> 00:08:25,870
what happens is when freebsd starts

226
00:08:25,870 --> 00:08:29,590
programs so we you know for the people

227
00:08:29,590 --> 00:08:31,420
who seem brooks talk is that there is

228
00:08:31,420 --> 00:08:33,130
sort of an image activator in the kernel

229
00:08:33,130 --> 00:08:35,530
that loads up executables and you know

230
00:08:35,530 --> 00:08:38,559
determines whether it can you know start

231
00:08:38,559 --> 00:08:40,719
those programs so it has a separate

232
00:08:40,719 --> 00:08:42,549
loader for e.l.f and one for a out etc

233
00:08:42,549 --> 00:08:44,890
and one of the things that freebie use

234
00:08:44,890 --> 00:08:46,900
these loader does is it checks this OS

235
00:08:46,900 --> 00:08:49,990
such a bi version to sort of see whether

236
00:08:49,990 --> 00:08:51,520
it's an actually actually an executable

237
00:08:51,520 --> 00:08:53,620
meant for the operating system itself so

238
00:08:53,620 --> 00:08:55,630
if you would run an open BSD executable

239
00:08:55,630 --> 00:08:57,880
FreeBSD on FreeBSD freebies it'll just

240
00:08:57,880 --> 00:08:59,350
say like sorry I don't understand this

241
00:08:59,350 --> 00:09:01,620
this is for the wrong operating system

242
00:09:01,620 --> 00:09:03,940
or you're running the wrong operating

243
00:09:03,940 --> 00:09:05,380
system that's what he opened be you see

244
00:09:05,380 --> 00:09:08,740
people would say also one of the things

245
00:09:08,740 --> 00:09:10,450
that sort of interesting about this is

246
00:09:10,450 --> 00:09:12,910
and we'll talk about is a bit more later

247
00:09:12,910 --> 00:09:15,370
on is over here it says - word in even

248
00:09:15,370 --> 00:09:17,020
though for freebies the executables this

249
00:09:17,020 --> 00:09:20,230
would say x''k cloudy API uses position

250
00:09:20,230 --> 00:09:22,450
independent executables exclusively so

251
00:09:22,450 --> 00:09:23,980
they are not loaded in and a fixed

252
00:09:23,980 --> 00:09:25,900
memory address the operating system can

253
00:09:25,900 --> 00:09:27,700
decide where to load them in memory and

254
00:09:27,700 --> 00:09:29,500
the reason for this is this is something

255
00:09:29,500 --> 00:09:30,610
that sort of needed to run those

256
00:09:30,610 --> 00:09:33,370
programs on Mac OS we're on a quest we

257
00:09:33,370 --> 00:09:35,560
don't have a choice like where we can

258
00:09:35,560 --> 00:09:36,940
load our program into the address space

259
00:09:36,940 --> 00:09:38,040
because that's something that's

260
00:09:38,040 --> 00:09:40,620
you know decided or forced upon us by

261
00:09:40,620 --> 00:09:43,260
Mac OS so that's the reason why I called

262
00:09:43,260 --> 00:09:44,430
AVI uses position independent

263
00:09:44,430 --> 00:09:46,530
executables so that the emulator can do

264
00:09:46,530 --> 00:09:49,680
with there properly so now we're going

265
00:09:49,680 --> 00:09:51,150
to take a look at the LVM source tree

266
00:09:51,150 --> 00:09:53,360
I'm going to switch over to a different

267
00:09:53,360 --> 00:09:55,860
window so this is on my Mac and I'm

268
00:09:55,860 --> 00:09:57,960
going into the LVM source tree and I'm

269
00:09:57,960 --> 00:09:59,520
going to show you a couple source files

270
00:09:59,520 --> 00:10:01,350
and which I had to make modifications so

271
00:10:01,350 --> 00:10:02,760
if you ever want to add your own

272
00:10:02,760 --> 00:10:04,500
operating system to LVM these are the

273
00:10:04,500 --> 00:10:06,270
files that you need to modify and you'll

274
00:10:06,270 --> 00:10:07,830
see that it's only a very small number

275
00:10:07,830 --> 00:10:10,050
of changes I mean if you sort of take a

276
00:10:10,050 --> 00:10:11,700
look at what you have to change in the

277
00:10:11,700 --> 00:10:14,190
GCC source tree to add one platform it's

278
00:10:14,190 --> 00:10:17,460
it's such nonsense it's really like if

279
00:10:17,460 --> 00:10:20,520
if my operating system then my operating

280
00:10:20,520 --> 00:10:21,870
system and then like you know in a

281
00:10:21,870 --> 00:10:23,340
hundred places scattered throughout the

282
00:10:23,340 --> 00:10:26,280
source tree it's just a mess so if TCC

283
00:10:26,280 --> 00:10:28,500
I'm sort of over LVM I want to show you

284
00:10:28,500 --> 00:10:31,440
that that's actually pretty easy so one

285
00:10:31,440 --> 00:10:35,430
of the first things that I that I made

286
00:10:35,430 --> 00:10:38,420
modifications to is this file over here

287
00:10:38,420 --> 00:10:41,490
set I see and if we sort of search run

288
00:10:41,490 --> 00:10:44,490
for cloud ABI is I added this piece of

289
00:10:44,490 --> 00:10:46,350
code to the compiler which is if cloud

290
00:10:46,350 --> 00:10:48,870
ABI done close Evi so again this is not

291
00:10:48,870 --> 00:10:50,670
that interesting but basically what this

292
00:10:50,670 --> 00:10:52,560
piece of code says is if we're

293
00:10:52,560 --> 00:10:54,240
generating executables for cloud ABI

294
00:10:54,240 --> 00:10:57,090
then put that Oh X 11 value in the

295
00:10:57,090 --> 00:10:59,760
executable header you know if you don't

296
00:10:59,760 --> 00:11:01,970
do this then eventually you know it

297
00:11:01,970 --> 00:11:04,290
clang still works but it generates these

298
00:11:04,290 --> 00:11:06,810
binaries that have the number 0 and the

299
00:11:06,810 --> 00:11:09,000
header setup so if you then started up

300
00:11:09,000 --> 00:11:10,590
on freebies even freebies these sort of

301
00:11:10,590 --> 00:11:11,850
things oh wait this is a Linux

302
00:11:11,850 --> 00:11:14,250
executable so then it sort of starts to

303
00:11:14,250 --> 00:11:15,780
interpret it completely incorrectly and

304
00:11:15,780 --> 00:11:18,830
crash so don't remove this piece of code

305
00:11:18,830 --> 00:11:21,540
so also worth mentioning they're sort of

306
00:11:21,540 --> 00:11:23,160
like a central registry where you can

307
00:11:23,160 --> 00:11:25,020
request your own number so if you're if

308
00:11:25,020 --> 00:11:26,490
you're building your own operating

309
00:11:26,490 --> 00:11:28,170
system then you have to contact the

310
00:11:28,170 --> 00:11:32,190
people at the SEO or send us their

311
00:11:32,190 --> 00:11:34,140
called nowadays yeah just have to send

312
00:11:34,140 --> 00:11:35,640
them an email and then hopefully within

313
00:11:35,640 --> 00:11:37,230
a couple of days or weeks they sent you

314
00:11:37,230 --> 00:11:39,360
a response saying like yeah your numbers

315
00:11:39,360 --> 00:11:44,640
18 20 whatever so that's the process I

316
00:11:44,640 --> 00:11:47,670
went through another change I had to

317
00:11:47,670 --> 00:11:49,890
make so these are like I had to make

318
00:11:49,890 --> 00:11:51,840
some other small change to LVM but L

319
00:11:51,840 --> 00:11:54,750
like that sort of all of it most of LVM

320
00:11:54,750 --> 00:11:58,050
could sort of remain as it is but the

321
00:11:58,050 --> 00:11:59,640
most interesting changes have to make

322
00:11:59,640 --> 00:12:01,350
section in clang so in the C C++

323
00:12:01,350 --> 00:12:04,980
compiler and I can sort of show you what

324
00:12:04,980 --> 00:12:06,720
this looks like so if you're ever adding

325
00:12:06,720 --> 00:12:08,930
an operating system to the compiler then

326
00:12:08,930 --> 00:12:11,400
you probably want to add a class through

327
00:12:11,400 --> 00:12:13,020
this one as well it's called a file

328
00:12:13,020 --> 00:12:15,300
called basic slash targets and this is

329
00:12:15,300 --> 00:12:16,710
where you sort of add your own tiny

330
00:12:16,710 --> 00:12:18,600
class doesn't need to be really big as a

331
00:12:18,600 --> 00:12:20,730
template where you sort of say like if

332
00:12:20,730 --> 00:12:22,950
we're targeting cloudy avi then these

333
00:12:22,950 --> 00:12:24,330
are all if the defines that need to be

334
00:12:24,330 --> 00:12:27,570
set so if you're building for FreeBSD

335
00:12:27,570 --> 00:12:28,830
and there's this underscores core

336
00:12:28,830 --> 00:12:30,750
FreeBSD definition this is actually the

337
00:12:30,750 --> 00:12:32,520
class where it's coming from so for

338
00:12:32,520 --> 00:12:36,030
every operating system this source file

339
00:12:36,030 --> 00:12:39,650
as a class that sort of defines

340
00:12:39,650 --> 00:12:42,420
constants like these also for open B you

341
00:12:42,420 --> 00:12:46,200
see probably C so just add a class over

342
00:12:46,200 --> 00:12:49,200
here and should be good then there is

343
00:12:49,200 --> 00:12:50,700
sort of two other source files that I

344
00:12:50,700 --> 00:12:56,340
needed to modify driver tool chains at

345
00:12:56,340 --> 00:13:02,220
CPP and this is basically that you sort

346
00:13:02,220 --> 00:13:05,250
of have to explain to clang where it can

347
00:13:05,250 --> 00:13:06,300
find its header files

348
00:13:06,300 --> 00:13:07,560
so what's fairly annoying about

349
00:13:07,560 --> 00:13:09,270
operating systems is that they have

350
00:13:09,270 --> 00:13:10,560
different conventions where to store

351
00:13:10,560 --> 00:13:12,810
their header files you know on freebies

352
00:13:12,810 --> 00:13:17,450
needs user include use the local include

353
00:13:17,450 --> 00:13:20,630
net bsd they tend to use user package

354
00:13:20,630 --> 00:13:24,060
include I think so this is just some

355
00:13:24,060 --> 00:13:25,710
logic here and there to sort of make all

356
00:13:25,710 --> 00:13:28,230
of that stuff work correctly also you

357
00:13:28,230 --> 00:13:29,810
know some compatibility things like

358
00:13:29,810 --> 00:13:31,950
operating systems use different names

359
00:13:31,950 --> 00:13:33,720
for their C++ libraries so you also need

360
00:13:33,720 --> 00:13:35,250
to add this function saying like on this

361
00:13:35,250 --> 00:13:37,650
operating system we're using these C++

362
00:13:37,650 --> 00:13:41,610
libraries and that's sort of that's

363
00:13:41,610 --> 00:13:44,730
almost it it's here some some stuff

364
00:13:44,730 --> 00:13:46,530
related to shoot position independent

365
00:13:46,530 --> 00:13:48,450
code be enabled by default in our case

366
00:13:48,450 --> 00:13:50,670
it should so there's also a function for

367
00:13:50,670 --> 00:13:55,230
that but that's about it that's what you

368
00:13:55,230 --> 00:13:56,760
need to modify over here and then like

369
00:13:56,760 --> 00:13:58,350
the final source file that I needed to

370
00:13:58,350 --> 00:14:02,750
modify was this one where I'm basically

371
00:14:02,750 --> 00:14:06,120
give ya here giving like a function

372
00:14:06,120 --> 00:14:07,680
sort of describes how the linker should

373
00:14:07,680 --> 00:14:10,110
be invoked so in the case of cloud avi

374
00:14:10,110 --> 00:14:12,300
making use of LVM Slinker nowadays lld

375
00:14:12,300 --> 00:14:14,370
and this sort of explains like you know

376
00:14:14,370 --> 00:14:16,020
if you're building you need to pass

377
00:14:16,020 --> 00:14:17,610
these command line flags to the linker

378
00:14:17,610 --> 00:14:19,950
if we need disabled position independent

379
00:14:19,950 --> 00:14:21,570
code and we need to pass in these flags

380
00:14:21,570 --> 00:14:24,210
as well and that's about it so a couple

381
00:14:24,210 --> 00:14:27,270
of classes one commit BAM put it in the

382
00:14:27,270 --> 00:14:31,290
LVM source tree and then any binary of

383
00:14:31,290 --> 00:14:32,670
clang from that moment on actually

384
00:14:32,670 --> 00:14:34,050
support your operating system there's no

385
00:14:34,050 --> 00:14:37,230
need to support any custom compiler for

386
00:14:37,230 --> 00:14:39,480
your target you know because this is

387
00:14:39,480 --> 00:14:41,460
built into all copies of LVM even the

388
00:14:41,460 --> 00:14:43,170
one shipped by Apple on my Mac by

389
00:14:43,170 --> 00:14:44,760
default sort of supports cloudy API out

390
00:14:44,760 --> 00:14:46,920
of the box nowadays so that's that's

391
00:14:46,920 --> 00:14:51,180
pretty cool not a lot of work so this

392
00:14:51,180 --> 00:14:52,890
sort of concludes sort of the changes I

393
00:14:52,890 --> 00:14:54,360
had to make to LVM and now we're

394
00:14:54,360 --> 00:14:56,220
actually going to take a look at what

395
00:14:56,220 --> 00:14:58,050
I've been doing to freebsd to sort of

396
00:14:58,050 --> 00:15:02,790
make this work so the freebsd source

397
00:15:02,790 --> 00:15:07,410
tree so for people who are not that

398
00:15:07,410 --> 00:15:08,700
familiar with the freebies in source

399
00:15:08,700 --> 00:15:10,230
tree all of the kernel source code is

400
00:15:10,230 --> 00:15:11,900
stored in a directory called sis and

401
00:15:11,900 --> 00:15:16,410
I'll run this Oh Sarah way to the yeah

402
00:15:16,410 --> 00:15:21,390
the colors are yeah I mean during the

403
00:15:21,390 --> 00:15:22,560
next couple of examples you won't be

404
00:15:22,560 --> 00:15:25,200
bothered by all of these callers so in

405
00:15:25,200 --> 00:15:27,270
the forestry I've created a couple of

406
00:15:27,270 --> 00:15:28,800
directories and at first it sort of

407
00:15:28,800 --> 00:15:31,320
looks a bit messy these are all of the

408
00:15:31,320 --> 00:15:32,670
directories were all if the cloudy bi

409
00:15:32,670 --> 00:15:34,740
source code is stored so at first it may

410
00:15:34,740 --> 00:15:37,200
look like complete chaos that like it

411
00:15:37,200 --> 00:15:39,540
was it like ten directories where cloudy

412
00:15:39,540 --> 00:15:40,770
a bi source code is stored this is

413
00:15:40,770 --> 00:15:43,890
what's needed to make 3bz support cloudy

414
00:15:43,890 --> 00:15:46,290
bi executables but I'll sort of drill it

415
00:15:46,290 --> 00:15:47,459
down a bit and then you'll see it's not

416
00:15:47,459 --> 00:15:50,010
as scary as it looks at first so these

417
00:15:50,010 --> 00:15:51,660
directories that contain make files for

418
00:15:51,660 --> 00:15:53,070
building kernel modules so if you're not

419
00:15:53,070 --> 00:15:54,600
building cloud API support into the

420
00:15:54,600 --> 00:15:56,670
kernel this is where it sort of ends up

421
00:15:56,670 --> 00:15:58,440
just a couple of make files in there

422
00:15:58,440 --> 00:16:01,890
then these three directories that you

423
00:16:01,890 --> 00:16:04,320
see over here compact cloudy API cloud

424
00:16:04,320 --> 00:16:05,790
API 32 64

425
00:16:05,790 --> 00:16:08,029
these contain actually like the C code

426
00:16:08,029 --> 00:16:11,610
like the kernel bits to make cloud API

427
00:16:11,610 --> 00:16:13,529
stuff work and this is architecture

428
00:16:13,529 --> 00:16:14,700
independent so this doesn't contain

429
00:16:14,700 --> 00:16:17,510
anything specific to x86 or if arm and

430
00:16:17,510 --> 00:16:20,040
it's divided in a couple of directories

431
00:16:20,040 --> 00:16:22,589
the generic code that doesn't depend on

432
00:16:22,589 --> 00:16:26,459
pointer sizes so there are both 32 64

433
00:16:26,459 --> 00:16:29,940
bit cloudy API executables and some code

434
00:16:29,940 --> 00:16:32,639
if it is separate per pointer size so we

435
00:16:32,639 --> 00:16:34,680
need to do like different tricks to get

436
00:16:34,680 --> 00:16:37,079
a 64 bit read or 32 bit right to work

437
00:16:37,079 --> 00:16:38,970
that's sort of where this distinction

438
00:16:38,970 --> 00:16:40,589
comes in but most of the source code is

439
00:16:40,589 --> 00:16:42,000
actually generic so that's being placed

440
00:16:42,000 --> 00:16:43,709
in there and then the other directories

441
00:16:43,709 --> 00:16:46,100
that you seen there is sort of

442
00:16:46,100 --> 00:16:48,959
architecture specific so on

443
00:16:48,959 --> 00:16:52,319
I 486 you can run 32-bit executables but

444
00:16:52,319 --> 00:16:54,750
on AV 64 you can actually run both 32

445
00:16:54,750 --> 00:16:56,880
and 64-bit executables so that's how

446
00:16:56,880 --> 00:16:58,699
this division is made of directories

447
00:16:58,699 --> 00:17:00,870
finally there's this directory contract

448
00:17:00,870 --> 00:17:03,810
cloud API and that is where code ends up

449
00:17:03,810 --> 00:17:05,819
that's actually not maintained by like

450
00:17:05,819 --> 00:17:09,240
the FreeBSD devs so to speak nice thing

451
00:17:09,240 --> 00:17:10,770
about Klaudia is that like a lot of the

452
00:17:10,770 --> 00:17:13,140
go that's needed to add support is sort

453
00:17:13,140 --> 00:17:15,329
of generated so we have this one

454
00:17:15,329 --> 00:17:16,919
repository where there's sort of like a

455
00:17:16,919 --> 00:17:19,380
master definition of these are all the

456
00:17:19,380 --> 00:17:20,609
system calls that are there these are

457
00:17:20,609 --> 00:17:22,500
all the data types you know

458
00:17:22,500 --> 00:17:25,290
for example Ian Val is to find this

459
00:17:25,290 --> 00:17:28,049
value one two three all that stuff is

460
00:17:28,049 --> 00:17:29,159
sort of written down in this sort of

461
00:17:29,159 --> 00:17:30,929
abstract definition and we have a whole

462
00:17:30,929 --> 00:17:32,549
bunch of scripts who turn it into header

463
00:17:32,549 --> 00:17:34,679
files that can be used by FreeBSD or by

464
00:17:34,679 --> 00:17:36,330
Linux and these are stored in this

465
00:17:36,330 --> 00:17:39,960
contract directory so now I'm sort of go

466
00:17:39,960 --> 00:17:47,520
to trace or like show you what happens

467
00:17:47,520 --> 00:17:49,080
when you run a cloud API program sort of

468
00:17:49,080 --> 00:17:52,409
what code is being executed so brooks

469
00:17:52,409 --> 00:17:54,570
already during this talk mentioned

470
00:17:54,570 --> 00:17:56,309
really nicely that like the layer inside

471
00:17:56,309 --> 00:17:59,640
of the freebsd kernel for loading elf

472
00:17:59,640 --> 00:18:05,040
files is called inject elf and there's

473
00:18:05,040 --> 00:18:06,450
some trickery in that source code to

474
00:18:06,450 --> 00:18:08,370
actually make it work for both 32 and

475
00:18:08,370 --> 00:18:11,610
64-bit binaries it's actually compiled

476
00:18:11,610 --> 00:18:13,590
twice with a bunch of macros that are

477
00:18:13,590 --> 00:18:15,780
being expanded what's actually really

478
00:18:15,780 --> 00:18:17,970
impressive about like the elf layer

479
00:18:17,970 --> 00:18:19,500
that's part of to be is the operating

480
00:18:19,500 --> 00:18:20,760
systems especially if you compare to

481
00:18:20,760 --> 00:18:23,610
like the crap that's provided by linux

482
00:18:23,610 --> 00:18:26,190
is that it's built in mind to actually

483
00:18:26,190 --> 00:18:29,760
support multiple like operating systems

484
00:18:29,760 --> 00:18:31,590
it's built with that binary emulation in

485
00:18:31,590 --> 00:18:33,090
mind so

486
00:18:33,090 --> 00:18:35,149
the Linux layer is so incredibly stupid

487
00:18:35,149 --> 00:18:37,440
what it does it it checks the first

488
00:18:37,440 --> 00:18:38,940
couple of bytes with the executable it

489
00:18:38,940 --> 00:18:41,639
says this is an elf file so this means

490
00:18:41,639 --> 00:18:43,200
that this is a Linux elf file and it

491
00:18:43,200 --> 00:18:44,519
sort of starts to run it like a Linux

492
00:18:44,519 --> 00:18:46,139
program so if you copy a freebie is the

493
00:18:46,139 --> 00:18:48,330
executable to Linux and you run it it

494
00:18:48,330 --> 00:18:50,309
actually loads it into memory and

495
00:18:50,309 --> 00:18:51,480
actually goes through the first

496
00:18:51,480 --> 00:18:53,129
instructions and starts running it and

497
00:18:53,129 --> 00:18:54,779
then it sort of explodes massively

498
00:18:54,779 --> 00:18:56,879
because you're starting this binary in

499
00:18:56,879 --> 00:18:58,200
this environment that it's you're

500
00:18:58,200 --> 00:18:59,669
completely wrong for what it was

501
00:18:59,669 --> 00:19:03,090
expecting but FreeBSD sort of doesn't do

502
00:19:03,090 --> 00:19:05,369
that it this way it sort of has this

503
00:19:05,369 --> 00:19:10,230
function in inject elf and it's called

504
00:19:10,230 --> 00:19:13,169
insert brand entry and it's over here

505
00:19:13,169 --> 00:19:15,210
and this function can be used to sort of

506
00:19:15,210 --> 00:19:17,970
explain to the elf layer like hey I want

507
00:19:17,970 --> 00:19:19,769
to register like an environment I want

508
00:19:19,769 --> 00:19:23,009
to register freebies the binaries I want

509
00:19:23,009 --> 00:19:24,869
to add support for Linux binaries and

510
00:19:24,869 --> 00:19:27,029
that's sort of the function you call to

511
00:19:27,029 --> 00:19:29,309
register your own brand so now I'm going

512
00:19:29,309 --> 00:19:30,840
to sort of show you how the cloud API

513
00:19:30,840 --> 00:19:34,559
layer calls this and you know puts an

514
00:19:34,559 --> 00:19:35,909
entry in there and what this brand

515
00:19:35,909 --> 00:19:37,470
specification looks like because that's

516
00:19:37,470 --> 00:19:38,759
actually sort of really interesting

517
00:19:38,759 --> 00:19:40,740
gives you like a really good insight so

518
00:19:40,740 --> 00:19:46,440
in an after peak compared a VI compact

519
00:19:46,440 --> 00:19:48,539
cloud ABI 64 cloudy

520
00:19:48,539 --> 00:19:53,970
ABI 64 mojo dot C at the very bottom of

521
00:19:53,970 --> 00:19:57,090
the C file there's this function called

522
00:19:57,090 --> 00:19:59,850
Cloud epi64 --mm mul event and this is

523
00:19:59,850 --> 00:20:01,230
sort of the standard function that gets

524
00:20:01,230 --> 00:20:02,909
called in freebsd when you're loading or

525
00:20:02,909 --> 00:20:05,730
unloading a kernel module so if you're

526
00:20:05,730 --> 00:20:08,549
running k LD load cloudy avi 64 to load

527
00:20:08,549 --> 00:20:10,860
up 64-bit support and put it into the

528
00:20:10,860 --> 00:20:12,450
kernel this is the piece of code that

529
00:20:12,450 --> 00:20:14,549
gets run and you actually see that over

530
00:20:14,549 --> 00:20:16,799
here on this line this is actually where

531
00:20:16,799 --> 00:20:18,480
we call this insert brand entry function

532
00:20:18,480 --> 00:20:20,460
and this is very register our brand and

533
00:20:20,460 --> 00:20:22,799
if it fails then well the kernel module

534
00:20:22,799 --> 00:20:27,720
can't be loaded properly so now what

535
00:20:27,720 --> 00:20:28,919
we're going to look at this like this

536
00:20:28,919 --> 00:20:30,119
thing because this is sort of the most

537
00:20:30,119 --> 00:20:32,009
interesting thing this specifies the

538
00:20:32,009 --> 00:20:34,440
brand and this thing is defined in

539
00:20:34,440 --> 00:20:39,480
another source file unfortunately yes

540
00:20:39,480 --> 00:20:41,759
it's over here this is where cloud API

541
00:20:41,759 --> 00:20:43,740
64 brand is so this is sort of the

542
00:20:43,740 --> 00:20:45,840
instruction to the elf layer like it

543
00:20:45,840 --> 00:20:46,830
explains what

544
00:20:46,830 --> 00:20:49,470
binary's we sort of expect and in the

545
00:20:49,470 --> 00:20:50,760
case of cloud avi it's actually pretty

546
00:20:50,760 --> 00:20:52,679
simple what we say is when you see an

547
00:20:52,679 --> 00:20:54,690
executable that said o X 11 in it so

548
00:20:54,690 --> 00:20:57,059
again it's elf OS a be a bi cloudy bi

549
00:20:57,059 --> 00:20:59,399
then this should be matched we should

550
00:20:59,399 --> 00:21:01,230
run this the same old sort of machine

551
00:21:01,230 --> 00:21:03,269
architecture if you're copying over a

552
00:21:03,269 --> 00:21:05,760
cloud API executable for spark or MIPS

553
00:21:05,760 --> 00:21:07,679
then you should be running it that

554
00:21:07,679 --> 00:21:09,720
doesn't work you don't want to load it

555
00:21:09,720 --> 00:21:11,100
into memory and then jump to the first

556
00:21:11,100 --> 00:21:12,630
instruction and sort of let it explode

557
00:21:12,630 --> 00:21:15,570
in your face so that's why this check or

558
00:21:15,570 --> 00:21:17,130
this you could set this field to sort of

559
00:21:17,130 --> 00:21:18,720
say like be picky about the architecture

560
00:21:18,720 --> 00:21:21,510
and we're only matching this C so for

561
00:21:21,510 --> 00:21:24,120
all of the machine specific files we use

562
00:21:24,120 --> 00:21:25,649
different constants there of course and

563
00:21:25,649 --> 00:21:29,159
that this sort of says like well firstly

564
00:21:29,159 --> 00:21:30,960
this one this sort of says like this is

565
00:21:30,960 --> 00:21:33,389
an environment that can run position

566
00:21:33,389 --> 00:21:35,880
independent executables this is I think

567
00:21:35,880 --> 00:21:38,269
not set on FreeBSD or is it I don't know

568
00:21:38,269 --> 00:21:41,190
but this this needs to be set to to run

569
00:21:41,190 --> 00:21:44,190
position independence cuticles and then

570
00:21:44,190 --> 00:21:45,960
finally this is the most important one

571
00:21:45,960 --> 00:21:48,690
what we sort of say is like whenever you

572
00:21:48,690 --> 00:21:50,760
decide to start this executable and go

573
00:21:50,760 --> 00:21:52,500
ahead deed the executable was like of

574
00:21:52,500 --> 00:21:55,440
the right format then this is sort of

575
00:21:55,440 --> 00:21:57,539
the structure describing how it should

576
00:21:57,539 --> 00:22:00,690
be run so this applies to like loading

577
00:22:00,690 --> 00:22:03,120
the executable in determining so like

578
00:22:03,120 --> 00:22:05,370
should we run this and this structure

579
00:22:05,370 --> 00:22:07,230
over here that is that's being pointed

580
00:22:07,230 --> 00:22:09,960
to add this describes like if we decide

581
00:22:09,960 --> 00:22:11,850
to run it how should we do it that's

582
00:22:11,850 --> 00:22:13,110
sort of the logic behind it

583
00:22:13,110 --> 00:22:16,919
oh how did how did the lecture go okay

584
00:22:16,919 --> 00:22:21,480
let me close off the browser yeah so now

585
00:22:21,480 --> 00:22:23,880
we scroll up where's this cloud ABI 64

586
00:22:23,880 --> 00:22:26,130
elf suspec well it's right above it so

587
00:22:26,130 --> 00:22:29,399
that's we're in luck and now we're sort

588
00:22:29,399 --> 00:22:32,639
of going to like roughly walk through

589
00:22:32,639 --> 00:22:33,870
the things that are described in the

590
00:22:33,870 --> 00:22:35,850
structure maybe in random order of it

591
00:22:35,850 --> 00:22:37,769
and later on we're going to dig through

592
00:22:37,769 --> 00:22:40,260
these a bit more so the ones that you

593
00:22:40,260 --> 00:22:42,090
have at the top over here these are

594
00:22:42,090 --> 00:22:46,049
actually quite important so the fun

595
00:22:46,049 --> 00:22:47,610
thing is they're also some net BSD

596
00:22:47,610 --> 00:22:49,440
people sitting in the audience and I

597
00:22:49,440 --> 00:22:51,149
have to confess that net Dec version of

598
00:22:51,149 --> 00:22:52,200
the structure is a lot more beautiful

599
00:22:52,200 --> 00:22:54,779
than ours so NetBeans if people don't

600
00:22:54,779 --> 00:22:56,490
laugh at us this is this is what I had

601
00:22:56,490 --> 00:23:00,540
to deal with so yeah

602
00:23:00,540 --> 00:23:01,890
these two fields here at the top is

603
00:23:01,890 --> 00:23:03,360
actually quite important they described

604
00:23:03,360 --> 00:23:06,480
a system called table so cloudy API

605
00:23:06,480 --> 00:23:08,130
doesn't have that many system calls

606
00:23:08,130 --> 00:23:10,110
compared to FreeBSD freebies they're

607
00:23:10,110 --> 00:23:14,160
something like 400 cloudy bi only has 57

608
00:23:14,160 --> 00:23:16,590
or 55 for throwing out even couple more

609
00:23:16,590 --> 00:23:18,090
it's just a really tiny environment and

610
00:23:18,090 --> 00:23:20,160
this is nothing more than you know a

611
00:23:20,160 --> 00:23:22,200
pointer to a table of system calls and

612
00:23:22,200 --> 00:23:24,120
like the number of system calls that are

613
00:23:24,120 --> 00:23:25,830
in there and this actually comes from

614
00:23:25,830 --> 00:23:28,110
sort of machine generated source code so

615
00:23:28,110 --> 00:23:29,580
we don't need to worry about how that's

616
00:23:29,580 --> 00:23:32,070
being defined then there's this function

617
00:23:32,070 --> 00:23:34,230
over here the fix-up line that sort of

618
00:23:34,230 --> 00:23:36,150
explains like if we're going to start

619
00:23:36,150 --> 00:23:38,190
this process how should this step be

620
00:23:38,190 --> 00:23:40,290
initialized so this is being executed

621
00:23:40,290 --> 00:23:43,380
before we actually run any machine code

622
00:23:43,380 --> 00:23:44,730
of the program but it sort of explains

623
00:23:44,730 --> 00:23:46,590
like at the very late stage right before

624
00:23:46,590 --> 00:23:47,130
starting it

625
00:23:47,130 --> 00:23:50,250
how should I fix up the stack a pretty

626
00:23:50,250 --> 00:23:54,090
bad name the SP name field this is I

627
00:23:54,090 --> 00:23:55,830
think mainly used for debugging so for

628
00:23:55,830 --> 00:23:58,650
example if you're using trusts that it

629
00:23:58,650 --> 00:24:00,810
actually like knows the kind of

630
00:24:00,810 --> 00:24:02,310
executable that you're running also when

631
00:24:02,310 --> 00:24:04,170
you get a kernel panic we sort of get

632
00:24:04,170 --> 00:24:05,640
the stack trace in freebsd

633
00:24:05,640 --> 00:24:07,320
and it also prints the kind of

634
00:24:07,320 --> 00:24:08,910
executable you're running so tests like

635
00:24:08,910 --> 00:24:10,410
this was a linux executable that was

636
00:24:10,410 --> 00:24:14,070
causing the crash don't do that then

637
00:24:14,070 --> 00:24:15,810
there's also like how to write out core

638
00:24:15,810 --> 00:24:17,760
dumps for now I'm just relying on the

639
00:24:17,760 --> 00:24:20,430
standard FreeBSD core dump function so

640
00:24:20,430 --> 00:24:22,610
it generates a FreeBSD styl core dump

641
00:24:22,610 --> 00:24:26,550
good enough these fields over here

642
00:24:26,550 --> 00:24:28,260
especially like the VM in address and VI

643
00:24:28,260 --> 00:24:30,330
max user address you specify like the

644
00:24:30,330 --> 00:24:32,010
maximum and minimum virtual address

645
00:24:32,010 --> 00:24:33,300
space that may be used by the process

646
00:24:33,300 --> 00:24:35,310
and you might wonder like why does it

647
00:24:35,310 --> 00:24:37,650
even matter so this actually matters for

648
00:24:37,650 --> 00:24:40,170
running 32-bit executable on a 64-bit

649
00:24:40,170 --> 00:24:42,930
kernel because you have two 64-bit

650
00:24:42,930 --> 00:24:44,250
address space well technically speaking

651
00:24:44,250 --> 00:24:47,400
it's 48 bits but you know 64 bits you

652
00:24:47,400 --> 00:24:49,740
don't want that the kernel decides to

653
00:24:49,740 --> 00:24:51,630
start up on 32-bit processor loaded all

654
00:24:51,630 --> 00:24:52,740
the way in the top of the address space

655
00:24:52,740 --> 00:24:55,170
in a location where the program can't

656
00:24:55,170 --> 00:24:57,060
reach it anymore because then then the

657
00:24:57,060 --> 00:24:58,410
program starts to run and the colonel

658
00:24:58,410 --> 00:25:00,270
says yeah good luck I've managed to map

659
00:25:00,270 --> 00:25:02,370
your executable at like 40 gigabytes in

660
00:25:02,370 --> 00:25:04,590
and then the program use phase like I

661
00:25:04,590 --> 00:25:07,530
can only address up to 4 gigabytes so he

662
00:25:07,530 --> 00:25:09,390
feels up there they sort of control but

663
00:25:09,390 --> 00:25:11,460
you can sort of constrain like don't go

664
00:25:11,460 --> 00:25:13,650
higher higher than 4 gigabytes but in

665
00:25:13,650 --> 00:25:14,970
our case we just say

666
00:25:14,970 --> 00:25:16,980
victim in Animax address that's good

667
00:25:16,980 --> 00:25:20,130
enough what's below here is standard

668
00:25:20,130 --> 00:25:24,360
stack permissions so freebie is the

669
00:25:24,360 --> 00:25:25,679
unfortunately we serve to add the

670
00:25:25,679 --> 00:25:27,840
executable permission to the stacks who

671
00:25:27,840 --> 00:25:30,419
cloudy API we don't need to this is

672
00:25:30,419 --> 00:25:32,820
meant to be used for copying out

673
00:25:32,820 --> 00:25:34,470
command-line arguments I'll talk about

674
00:25:34,470 --> 00:25:35,940
this a bit later because it's a bit

675
00:25:35,940 --> 00:25:38,700
interesting and this is how the initial

676
00:25:38,700 --> 00:25:40,470
registers of the process should be set

677
00:25:40,470 --> 00:25:43,470
on startup then there's a couple of

678
00:25:43,470 --> 00:25:46,770
flags over here this one is interesting

679
00:25:46,770 --> 00:25:48,960
SP capsicum that one is being used by

680
00:25:48,960 --> 00:25:51,299
the kernel to what you want to have of

681
00:25:51,299 --> 00:25:52,500
course is when you start a cloud API

682
00:25:52,500 --> 00:25:54,870
executable that when it starts running

683
00:25:54,870 --> 00:25:56,730
you want to have it is such a way that

684
00:25:56,730 --> 00:25:58,740
freebie is the also s capsicum enabled

685
00:25:58,740 --> 00:26:00,330
so that it's actually being run in a

686
00:26:00,330 --> 00:26:02,730
sandbox mode if this flag wouldn't be

687
00:26:02,730 --> 00:26:04,500
here then previously sort of starts it

688
00:26:04,500 --> 00:26:06,299
up on me immediately and then the

689
00:26:06,299 --> 00:26:08,669
program could just execute system calls

690
00:26:08,669 --> 00:26:10,140
in such a way that they just completely

691
00:26:10,140 --> 00:26:11,730
ignore the capsicum security model

692
00:26:11,730 --> 00:26:13,350
that's being used so that's what that's

693
00:26:13,350 --> 00:26:15,690
like does and these ones will also sort

694
00:26:15,690 --> 00:26:17,790
of look into those in a minute they

695
00:26:17,790 --> 00:26:21,179
describe how system Co arguments and

696
00:26:21,179 --> 00:26:23,309
return value should be extracted and

697
00:26:23,309 --> 00:26:26,580
said in the registers are there any

698
00:26:26,580 --> 00:26:29,760
questions at this point then I think

699
00:26:29,760 --> 00:26:34,799
I'll just go on yeah so the the the

700
00:26:34,799 --> 00:26:36,960
first one I think I'll be looking at is

701
00:26:36,960 --> 00:26:43,169
the the fix-up function and right now at

702
00:26:43,169 --> 00:26:45,210
first you think what why is this useful

703
00:26:45,210 --> 00:26:46,980
but later on you'll discover that this

704
00:26:46,980 --> 00:26:48,540
is actually a really important function

705
00:26:48,540 --> 00:26:55,020
in our case module fix-up yeah your

706
00:26:55,020 --> 00:26:57,990
cloud ABR 64 fix-up and what this does

707
00:26:57,990 --> 00:26:59,580
I'll make it a bit smaller otherwise it

708
00:26:59,580 --> 00:27:01,590
sort of wraps around a bit which I don't

709
00:27:01,590 --> 00:27:04,740
like this initializes the stack of the

710
00:27:04,740 --> 00:27:06,600
process and there's a couple of things

711
00:27:06,600 --> 00:27:07,980
that are being copied out on the stack

712
00:27:07,980 --> 00:27:11,190
so this one I'll start here what you see

713
00:27:11,190 --> 00:27:13,080
at the top of the screen right here this

714
00:27:13,080 --> 00:27:16,200
is whenever a cloudy API program starts

715
00:27:16,200 --> 00:27:18,059
up called a VI programs may make use of

716
00:27:18,059 --> 00:27:20,760
stack smashing protection so at startup

717
00:27:20,760 --> 00:27:22,410
it already needs to have like a random

718
00:27:22,410 --> 00:27:25,140
number or random seed so from that

719
00:27:25,140 --> 00:27:27,090
moment on it like all the stack frames

720
00:27:27,090 --> 00:27:28,200
can be sort of marked

721
00:27:28,200 --> 00:27:29,910
with those random numbers and they could

722
00:27:29,910 --> 00:27:31,080
be checked afterwards to see whether

723
00:27:31,080 --> 00:27:33,210
there was a buffer overflow so what we

724
00:27:33,210 --> 00:27:34,440
do is we first copy out some random

725
00:27:34,440 --> 00:27:37,320
garbage while garbage random numbers out

726
00:27:37,320 --> 00:27:40,049
of them to the stack and the program may

727
00:27:40,049 --> 00:27:42,929
use that anyway it likes and then what

728
00:27:42,929 --> 00:27:45,270
we're sort of doing over here is I'm

729
00:27:45,270 --> 00:27:47,370
going to skip this for now this is sort

730
00:27:47,370 --> 00:27:49,110
of the interesting part brooks also

731
00:27:49,110 --> 00:27:51,210
mention it during his talk

732
00:27:51,210 --> 00:27:54,570
auxiliary vectors so the program the

733
00:27:54,570 --> 00:27:57,059
kernel can sort of give a key value list

734
00:27:57,059 --> 00:27:58,710
of key value pairs over to the program

735
00:27:58,710 --> 00:28:00,450
of all sorts of interesting things that

736
00:28:00,450 --> 00:28:03,179
you know might be quite useful during

737
00:28:03,179 --> 00:28:05,280
the program's execution so a really good

738
00:28:05,280 --> 00:28:08,309
example of them is they're in cloud ABI

739
00:28:08,309 --> 00:28:09,780
there's no special system call for a

740
00:28:09,780 --> 00:28:12,210
thread to get its own phred ID it sort

741
00:28:12,210 --> 00:28:13,950
of has to remember that on its own you

742
00:28:13,950 --> 00:28:16,200
know why would I be a system call for

743
00:28:16,200 --> 00:28:18,120
that it's a it's a constant thing it

744
00:28:18,120 --> 00:28:20,280
it's a value that's picked at Fred

745
00:28:20,280 --> 00:28:21,950
startup and it doesn't need to be

746
00:28:21,950 --> 00:28:24,960
fetched every time so one of the values

747
00:28:24,960 --> 00:28:27,510
that's being sort of sent over to user

748
00:28:27,510 --> 00:28:28,830
space when the first threat of the

749
00:28:28,830 --> 00:28:30,809
program starts is the Fred ID which is

750
00:28:30,809 --> 00:28:33,240
placed in York City area vector also

751
00:28:33,240 --> 00:28:35,100
things like other constant things well I

752
00:28:35,100 --> 00:28:36,330
assume they're constant like the number

753
00:28:36,330 --> 00:28:38,130
of CPUs and the page size it's good

754
00:28:38,130 --> 00:28:39,570
enough for now to keep that as constants

755
00:28:39,570 --> 00:28:43,799
in there but also some things that are

756
00:28:43,799 --> 00:28:45,570
being passed on it's like the address

757
00:28:45,570 --> 00:28:48,600
and length of the argument data so like

758
00:28:48,600 --> 00:28:49,830
the command-line arguments that are

759
00:28:49,830 --> 00:28:52,080
being passed in and also like the

760
00:28:52,080 --> 00:28:55,080
location of that random stack smashing

761
00:28:55,080 --> 00:28:57,929
stack smashing data so one of the most

762
00:28:57,929 --> 00:28:59,460
interesting fields in there so there's

763
00:28:59,460 --> 00:29:01,049
really the most interesting one is this

764
00:29:01,049 --> 00:29:03,660
one but I want to explain that one yet

765
00:29:03,660 --> 00:29:08,970
I'll keep that as a secret stay tuned so

766
00:29:08,970 --> 00:29:11,070
now that we've sort of seen how this

767
00:29:11,070 --> 00:29:12,630
stack is being prepared you know this

768
00:29:12,630 --> 00:29:14,580
thing is being copied out eventually to

769
00:29:14,580 --> 00:29:16,679
user space and put on the stack now

770
00:29:16,679 --> 00:29:18,570
we're going to take a look at like how

771
00:29:18,570 --> 00:29:20,400
system call argument fetching works so

772
00:29:20,400 --> 00:29:23,280
go back to this file there were two

773
00:29:23,280 --> 00:29:25,559
functions namely set system call a fetch

774
00:29:25,559 --> 00:29:28,080
system call args and set cisco red ball

775
00:29:28,080 --> 00:29:29,940
so the one after this one that I'm going

776
00:29:29,940 --> 00:29:32,070
to show you now this is the function

777
00:29:32,070 --> 00:29:33,720
that's being invoked every time a cloud

778
00:29:33,720 --> 00:29:39,809
API process runs a system call so how it

779
00:29:39,809 --> 00:29:41,140
works is

780
00:29:41,140 --> 00:29:43,570
gets a so-called trap frame and a trap

781
00:29:43,570 --> 00:29:47,049
frame is a sort of copy of what the

782
00:29:47,049 --> 00:29:48,850
registers of the Fred look like by the

783
00:29:48,850 --> 00:29:53,200
time it jumped into the kernel all of

784
00:29:53,200 --> 00:29:54,730
the arguments of cloud Evi system calls

785
00:29:54,730 --> 00:29:56,830
are stored in registers the largest

786
00:29:56,830 --> 00:29:58,120
system called it we have only a six

787
00:29:58,120 --> 00:29:59,620
argument so you can fit all of that and

788
00:29:59,620 --> 00:30:02,890
registers on the 1964 so what you have

789
00:30:02,890 --> 00:30:05,350
over here is this sort of six lines in a

790
00:30:05,350 --> 00:30:07,600
row where we're fetching you know the

791
00:30:07,600 --> 00:30:09,610
arguments numbers from zero to two five

792
00:30:09,610 --> 00:30:12,160
from the respective registers a users

793
00:30:12,160 --> 00:30:14,230
face there are some madness going on

794
00:30:14,230 --> 00:30:17,770
that the the value of our ten actually

795
00:30:17,770 --> 00:30:19,900
sort of gets lost but a backup copies

796
00:30:19,900 --> 00:30:22,809
saving RCX so user space writes it in

797
00:30:22,809 --> 00:30:25,000
our ten but in this specific code we

798
00:30:25,000 --> 00:30:27,700
need to like grab it out of our CX it's

799
00:30:27,700 --> 00:30:30,490
not that awesome and then the second

800
00:30:30,490 --> 00:30:32,049
function is like how do we set the

801
00:30:32,049 --> 00:30:33,490
return values so the system calls

802
00:30:33,490 --> 00:30:35,290
running and after some time it completes

803
00:30:35,290 --> 00:30:37,960
it can either succeed or it can fail and

804
00:30:37,960 --> 00:30:39,790
this piece of code then determines how

805
00:30:39,790 --> 00:30:41,320
do we set the registers when turning

806
00:30:41,320 --> 00:30:43,419
back to user space so if the error

807
00:30:43,419 --> 00:30:45,490
number is zero says the system call

808
00:30:45,490 --> 00:30:49,809
succeeded we write the the return value

809
00:30:49,809 --> 00:30:52,210
so for example the number of bytes

810
00:30:52,210 --> 00:30:53,860
written in case with the right system

811
00:30:53,860 --> 00:30:57,280
call or yeah yeah that's like the best

812
00:30:57,280 --> 00:30:59,230
example or like if you call MF delegate

813
00:30:59,230 --> 00:31:00,880
memory the memory address of the pages

814
00:31:00,880 --> 00:31:02,590
that you managed to allocate that's

815
00:31:02,590 --> 00:31:04,870
being written into our CR ax and and

816
00:31:04,870 --> 00:31:06,370
some certain system goals have like

817
00:31:06,370 --> 00:31:08,110
longer return values it's also written

818
00:31:08,110 --> 00:31:11,260
in RDX and we cleared a carry bit so the

819
00:31:11,260 --> 00:31:12,850
carry bits used as an indicator to sort

820
00:31:12,850 --> 00:31:16,210
of keep track of whether system call

821
00:31:16,210 --> 00:31:19,090
succeeded or not and then if the system

822
00:31:19,090 --> 00:31:20,919
call failed so we have like a non zero

823
00:31:20,919 --> 00:31:23,110
value then what we do is in re X we

824
00:31:23,110 --> 00:31:25,330
write down the the error number and we

825
00:31:25,330 --> 00:31:26,860
do set the carry bit so that's basically

826
00:31:26,860 --> 00:31:28,750
how user space distinguishes between

827
00:31:28,750 --> 00:31:30,309
whether something succeeded or not

828
00:31:30,309 --> 00:31:33,190
evokes a system call and later on one

829
00:31:33,190 --> 00:31:34,690
when you get back to user space it

830
00:31:34,690 --> 00:31:36,549
checks a carry bit to see like did we

831
00:31:36,549 --> 00:31:38,559
succeed or did we fill that's that's the

832
00:31:38,559 --> 00:31:42,010
logic in there so now that I've shown

833
00:31:42,010 --> 00:31:43,990
you like how system calls are being like

834
00:31:43,990 --> 00:31:46,090
invoked in a certain way you know how do

835
00:31:46,090 --> 00:31:47,679
we fetch the arguments and how do we

836
00:31:47,679 --> 00:31:49,600
deal with return values it's also

837
00:31:49,600 --> 00:31:51,190
important to sort of show you like what

838
00:31:51,190 --> 00:31:52,720
does an implementation of a system call

839
00:31:52,720 --> 00:31:54,790
looks like because not showing that

840
00:31:54,790 --> 00:31:58,120
really out of context so in this

841
00:31:58,120 --> 00:32:01,740
specific file syscalls of master earth

842
00:32:01,740 --> 00:32:04,930
contrib cloudy api six yeah it's just

843
00:32:04,930 --> 00:32:06,850
called 64 top master this is the like

844
00:32:06,850 --> 00:32:09,250
the list of cloudy api system calls so

845
00:32:09,250 --> 00:32:11,050
if you go to the bottom there's well

846
00:32:11,050 --> 00:32:13,360
starts counting at zero so there's 57 in

847
00:32:13,360 --> 00:32:15,580
total and these are just see prototypes

848
00:32:15,580 --> 00:32:18,490
of all of the system calls and freebsd

849
00:32:18,490 --> 00:32:20,230
has a bunch of like these files not only

850
00:32:20,230 --> 00:32:22,000
for cloudy api but also for freebies in

851
00:32:22,000 --> 00:32:24,400
itself cisco and syscalls of master this

852
00:32:24,400 --> 00:32:26,740
is just a list automatically generated

853
00:32:26,740 --> 00:32:28,780
list of system goals but what makes

854
00:32:28,780 --> 00:32:30,910
cloud ABI sort of a bit unique compared

855
00:32:30,910 --> 00:32:33,400
to how freebie is the itself works is

856
00:32:33,400 --> 00:32:36,490
that the generator we used to for this

857
00:32:36,490 --> 00:32:39,490
file has logic built into it which

858
00:32:39,490 --> 00:32:44,170
Malley's wrote in the back to

859
00:32:44,170 --> 00:32:46,800
distinguish between system calls that

860
00:32:46,800 --> 00:32:49,810
have depend on machine dependent data

861
00:32:49,810 --> 00:32:51,940
structures and ones that don't so a

862
00:32:51,940 --> 00:32:54,610
really good example is for example the

863
00:32:54,610 --> 00:32:57,010
FD dub system call which is equivalent

864
00:32:57,010 --> 00:32:59,170
to like the top system calling unix it

865
00:32:59,170 --> 00:33:00,970
doesn't depend on any machine dependent

866
00:33:00,970 --> 00:33:04,240
types you know file descriptor gum goes

867
00:33:04,240 --> 00:33:06,250
in file script comes out there's nothing

868
00:33:06,250 --> 00:33:08,020
special about it so this one is called

869
00:33:08,020 --> 00:33:10,600
cloudy ABI underscore sis but then right

870
00:33:10,600 --> 00:33:12,070
underneath it there's this annoying

871
00:33:12,070 --> 00:33:14,620
system called p read and this one does

872
00:33:14,620 --> 00:33:16,840
depend on machine dependent structures

873
00:33:16,840 --> 00:33:19,720
namely you pass in this list of i of x

874
00:33:19,720 --> 00:33:22,810
and this one like the layout of the i of

875
00:33:22,810 --> 00:33:24,520
x structure depends on whether you're

876
00:33:24,520 --> 00:33:28,750
using a 32 or 64-bit system so the

877
00:33:28,750 --> 00:33:30,370
scripts at my release wrote make this

878
00:33:30,370 --> 00:33:31,900
really good distinction between them and

879
00:33:31,900 --> 00:33:33,550
it sort of tries to keep system calls

880
00:33:33,550 --> 00:33:35,620
generic as much as possible so in the

881
00:33:35,620 --> 00:33:37,780
case of cloud ABI it's the case that I

882
00:33:37,780 --> 00:33:41,590
think 48 of them are pointer size

883
00:33:41,590 --> 00:33:44,530
independent so to speak and nine or what

884
00:33:44,530 --> 00:33:46,810
10 or so our pointer size dependent so

885
00:33:46,810 --> 00:33:50,590
in case 128 bits EPS would ever appear

886
00:33:50,590 --> 00:33:52,900
or we want to port to those two 16 bit

887
00:33:52,900 --> 00:33:55,210
CPUs like runners on in 286s

888
00:33:55,210 --> 00:33:57,130
then we only need to implement like

889
00:33:57,130 --> 00:33:59,520
there's nine missing system calls for

890
00:33:59,520 --> 00:34:02,410
that are or ten or how many they are for

891
00:34:02,410 --> 00:34:04,090
like the pointer size dependent ones but

892
00:34:04,090 --> 00:34:05,590
all of the pointer size independent ones

893
00:34:05,590 --> 00:34:07,720
we can just reuse them again so that's

894
00:34:07,720 --> 00:34:08,679
pretty awesome

895
00:34:08,679 --> 00:34:10,869
that was if you sort of look at the

896
00:34:10,869 --> 00:34:12,699
compatibility layer for running 32-bit

897
00:34:12,699 --> 00:34:15,219
programs on FreeBSD it's sort of a bit

898
00:34:15,219 --> 00:34:15,940
clunky

899
00:34:15,940 --> 00:34:18,339
you know there's we we sort of had to

900
00:34:18,339 --> 00:34:21,609
make this you know handwritten system

901
00:34:21,609 --> 00:34:23,109
calls master file where were sort of

902
00:34:23,109 --> 00:34:25,270
manually determining whether stuff is

903
00:34:25,270 --> 00:34:27,790
pointer size dependent or not and in

904
00:34:27,790 --> 00:34:29,500
some cases I think we might even get it

905
00:34:29,500 --> 00:34:31,569
wrong in this case it's actually really

906
00:34:31,569 --> 00:34:33,129
structured because we'd use scripts to

907
00:34:33,129 --> 00:34:35,889
solve this problem for us so now I'm

908
00:34:35,889 --> 00:34:37,418
going to show you what an implementation

909
00:34:37,418 --> 00:34:38,980
of such a system call looks like so if

910
00:34:38,980 --> 00:34:41,349
I'm going to compare cloudy bi cloud ABI

911
00:34:41,349 --> 00:34:48,280
mem and yeah mam map this is sort of

912
00:34:48,280 --> 00:34:50,409
what the the implementation of M map

913
00:34:50,409 --> 00:34:52,149
looks like so the man map is sort of a

914
00:34:52,149 --> 00:34:54,550
cloudy B is equivalent of the BSD and

915
00:34:54,550 --> 00:34:56,800
map so what we do is we convert the

916
00:34:56,800 --> 00:34:58,630
flags that you pass in so if you use

917
00:34:58,630 --> 00:35:00,910
cloudy ice map and um flag then we

918
00:35:00,910 --> 00:35:03,069
translate to freebies these just goes on

919
00:35:03,069 --> 00:35:05,829
like this and then in the end we just

920
00:35:05,829 --> 00:35:07,900
call into freebies thesis and map and

921
00:35:07,900 --> 00:35:11,079
that sort of does the rest for us yes so

922
00:35:11,079 --> 00:35:12,400
these wrappers they sort of look a bit

923
00:35:12,400 --> 00:35:14,109
like this

924
00:35:14,109 --> 00:35:16,829
then I can also sort of show you that

925
00:35:16,829 --> 00:35:23,440
here in cloud a bi 64 cloud ABI FD f the

926
00:35:23,440 --> 00:35:25,030
right is a good example this is like a

927
00:35:25,030 --> 00:35:26,500
machine dependent system called because

928
00:35:26,500 --> 00:35:28,750
of the I of X structures so you see that

929
00:35:28,750 --> 00:35:31,450
this is actually at like a two two stage

930
00:35:31,450 --> 00:35:34,089
rocket in the in the first part what we

931
00:35:34,089 --> 00:35:38,140
do is we convert the 64 bit cloud ABI of

932
00:35:38,140 --> 00:35:42,069
X into like a like a native format to

933
00:35:42,069 --> 00:35:44,410
struct UI yo as you see over there we

934
00:35:44,410 --> 00:35:46,960
then invoke like the generic counterpart

935
00:35:46,960 --> 00:35:48,309
of that function then free it up

936
00:35:48,309 --> 00:35:50,770
so these wrappers are just like this so

937
00:35:50,770 --> 00:35:53,020
for like there's 50 system calls it's

938
00:35:53,020 --> 00:35:56,319
you know I think something like 4,000

939
00:35:56,319 --> 00:35:58,030
lines of code to get all of those system

940
00:35:58,030 --> 00:36:04,660
calls working this sort of summarizes

941
00:36:04,660 --> 00:36:06,640
what like the the kernel space code of

942
00:36:06,640 --> 00:36:08,829
cloud API looks like it's nothing more

943
00:36:08,829 --> 00:36:12,369
than this there's actually one thing

944
00:36:12,369 --> 00:36:15,700
where cloud ABI differs like like wildly

945
00:36:15,700 --> 00:36:17,290
from FreeBSD in a certain way and that

946
00:36:17,290 --> 00:36:20,530
is um you know when I was showing like

947
00:36:20,530 --> 00:36:22,089
what the fix-up function look like and I

948
00:36:22,089 --> 00:36:22,630
didn't want

949
00:36:22,630 --> 00:36:25,029
want to spoil like one tiny detail this

950
00:36:25,029 --> 00:36:26,230
is actually what we're getting at right

951
00:36:26,230 --> 00:36:30,130
now so cloudy API programs that don't

952
00:36:30,130 --> 00:36:32,380
invoke system calls by using hardware

953
00:36:32,380 --> 00:36:34,150
instructions so normally a freebies new

954
00:36:34,150 --> 00:36:37,029
what happens is you know it it does

955
00:36:37,029 --> 00:36:38,650
something along lines of you know in

956
00:36:38,650 --> 00:36:41,049
register e^x move to number 12

957
00:36:41,049 --> 00:36:42,309
I want to invoke system call number

958
00:36:42,309 --> 00:36:45,519
twelve and then you know invoke the

959
00:36:45,519 --> 00:36:47,049
system call and when we're done with

960
00:36:47,049 --> 00:36:49,690
that we do a jump on carry set Air

961
00:36:49,690 --> 00:36:53,589
number in Lipsy rat so some point this

962
00:36:53,589 --> 00:36:57,130
is what would a system call on freebsd

963
00:36:57,130 --> 00:36:59,109
normally looks like but for cloud maybe

964
00:36:59,109 --> 00:37:00,910
I didn't want to put this stuff in user

965
00:37:00,910 --> 00:37:02,829
space programs and the reason for that

966
00:37:02,829 --> 00:37:04,809
is I want to be able to run these

967
00:37:04,809 --> 00:37:07,180
programs on Mac OS as well and if

968
00:37:07,180 --> 00:37:09,220
programs and Klaudia VI programs would

969
00:37:09,220 --> 00:37:10,750
actually run this kind of stuff on Mac

970
00:37:10,750 --> 00:37:12,970
OS they wouldn't call into the emulator

971
00:37:12,970 --> 00:37:16,140
but I would call into Mac OS itself so

972
00:37:16,140 --> 00:37:18,910
that is pretty hard you can't like

973
00:37:18,910 --> 00:37:20,559
easily trap system call instructions

974
00:37:20,559 --> 00:37:25,180
from moving user space so what I've what

975
00:37:25,180 --> 00:37:27,160
I've done instead is I think it's

976
00:37:27,160 --> 00:37:29,039
actually pretty nice solution

977
00:37:29,039 --> 00:37:31,750
I've written a so called video so

978
00:37:31,750 --> 00:37:35,920
virtual dynamic shared object and I can

979
00:37:35,920 --> 00:37:39,700
show you what it looks like here it's

980
00:37:39,700 --> 00:37:42,849
this assembly file that's like 500 lines

981
00:37:42,849 --> 00:37:46,930
big but it sort of has that Cisco

982
00:37:46,930 --> 00:37:49,690
invocation in there so what happens is

983
00:37:49,690 --> 00:37:51,609
that the kernel sort of has this really

984
00:37:51,609 --> 00:37:53,289
tiny shared library included certainly

985
00:37:53,289 --> 00:37:56,170
like to a free kilobytes big and when

986
00:37:56,170 --> 00:37:58,569
the process starts it sort of gives that

987
00:37:58,569 --> 00:38:00,039
library to the program use the space and

988
00:38:00,039 --> 00:38:01,509
it says whenever you want to in focus is

989
00:38:01,509 --> 00:38:03,579
a system call do it through these

990
00:38:03,579 --> 00:38:07,240
functions so what's really nice about

991
00:38:07,240 --> 00:38:10,180
this approach is that we can actually

992
00:38:10,180 --> 00:38:12,009
also dynamically add and remove system

993
00:38:12,009 --> 00:38:14,799
calls you know if some system call we

994
00:38:14,799 --> 00:38:16,150
don't like anymore we can just remove it

995
00:38:16,150 --> 00:38:19,269
from the kernel entirely and the program

996
00:38:19,269 --> 00:38:21,549
a user space will start up and we'll

997
00:38:21,549 --> 00:38:23,289
notice that it's not part of the video

998
00:38:23,289 --> 00:38:25,599
that was being pushed and liked by the

999
00:38:25,599 --> 00:38:28,180
kernel and and it simply already knows

1000
00:38:28,180 --> 00:38:29,829
that that system calls absent from the

1001
00:38:29,829 --> 00:38:31,779
start you know it's not like we like

1002
00:38:31,779 --> 00:38:33,609
eternal II need to keep track of that

1003
00:38:33,609 --> 00:38:35,589
system calling kernel space to sort of

1004
00:38:35,589 --> 00:38:36,369
say like you

1005
00:38:36,369 --> 00:38:38,559
system call 48 that one was reserved for

1006
00:38:38,559 --> 00:38:39,940
this function we need to keep it there

1007
00:38:39,940 --> 00:38:42,400
forever so it really sort of makes the

1008
00:38:42,400 --> 00:38:43,839
coupling between use of space and kernel

1009
00:38:43,839 --> 00:38:45,700
space a lot more loose and allows us to

1010
00:38:45,700 --> 00:38:47,410
like dynamically add or remove things

1011
00:38:47,410 --> 00:38:49,359
also it's pretty awesome what's not

1012
00:38:49,359 --> 00:38:50,170
there right now

1013
00:38:50,170 --> 00:38:51,999
if we would ever add support for a

1014
00:38:51,999 --> 00:38:53,950
simple versioning in there you could

1015
00:38:53,950 --> 00:38:55,690
also change the prototypes of system

1016
00:38:55,690 --> 00:38:57,759
calls entirely and we could just have

1017
00:38:57,759 --> 00:38:59,740
like a video that exports two different

1018
00:38:59,740 --> 00:39:01,420
versions of the same system call under

1019
00:39:01,420 --> 00:39:05,470
the same name so programs the user space

1020
00:39:05,470 --> 00:39:08,230
in well in theory they have no

1021
00:39:08,230 --> 00:39:10,089
understanding of how to invoke system

1022
00:39:10,089 --> 00:39:11,410
calls how to switch over to the

1023
00:39:11,410 --> 00:39:13,269
operating system the only thing they do

1024
00:39:13,269 --> 00:39:14,680
is they get a library from kernel space

1025
00:39:14,680 --> 00:39:16,720
and they call in to it and they sort of

1026
00:39:16,720 --> 00:39:18,400
hope that the that library does the

1027
00:39:18,400 --> 00:39:20,619
right thing and that's the reason why

1028
00:39:20,619 --> 00:39:22,599
emulation is also so quickly if you're

1029
00:39:22,599 --> 00:39:24,609
on the Mac OS because there's no traps

1030
00:39:24,609 --> 00:39:26,680
or complex hardware instructions it's

1031
00:39:26,680 --> 00:39:27,999
really the program you know working

1032
00:39:27,999 --> 00:39:29,589
together with the emulator in a certain

1033
00:39:29,589 --> 00:39:31,660
way the emulator just says like here are

1034
00:39:31,660 --> 00:39:33,009
some stubs that you need to call into

1035
00:39:33,009 --> 00:39:34,660
and I'll translate it to Mac OS system

1036
00:39:34,660 --> 00:39:38,170
calls so this is really sort of yeah

1037
00:39:38,170 --> 00:39:39,910
what what's quite different between

1038
00:39:39,910 --> 00:39:41,769
freebie is the native programs and

1039
00:39:41,769 --> 00:39:46,089
cloudy API this sort of sort of

1040
00:39:46,089 --> 00:39:47,440
concludes what I wanted to tell about

1041
00:39:47,440 --> 00:39:51,309
the the kernel space side of FreeBSD and

1042
00:39:51,309 --> 00:39:53,339
now I sort of want to show you like how

1043
00:39:53,339 --> 00:39:56,410
how things work on user space side so if

1044
00:39:56,410 --> 00:39:58,869
a cloudy api program starts up inside of

1045
00:39:58,869 --> 00:40:00,579
the c library what's going on there so

1046
00:40:00,579 --> 00:40:02,739
brooks already mentioned during this all

1047
00:40:02,739 --> 00:40:04,210
its talked at on freebsd there's a

1048
00:40:04,210 --> 00:40:05,680
function called underscore start and

1049
00:40:05,680 --> 00:40:07,509
that's sort of the entry point that's

1050
00:40:07,509 --> 00:40:08,589
being called by the kernel when a

1051
00:40:08,589 --> 00:40:11,109
program starts up or Claude ABI also has

1052
00:40:11,109 --> 00:40:12,809
an underscore start function but it's

1053
00:40:12,809 --> 00:40:16,119
implemented in a different way so now

1054
00:40:16,119 --> 00:40:17,619
I'm going to the C library source here

1055
00:40:17,619 --> 00:40:21,430
TCO t0 and I'm going to show you what

1056
00:40:21,430 --> 00:40:24,819
our start function looks like so what

1057
00:40:24,819 --> 00:40:27,509
happens is that once the program starts

1058
00:40:27,509 --> 00:40:29,769
the kernel sort of invokes it with a

1059
00:40:29,769 --> 00:40:33,339
single argument it just make sure that

1060
00:40:33,339 --> 00:40:34,839
the registers are set up correctly you

1061
00:40:34,839 --> 00:40:36,400
know there was a separate function that

1062
00:40:36,400 --> 00:40:39,670
I briefly into that earlier on and the

1063
00:40:39,670 --> 00:40:42,369
kernel make sure that this um score

1064
00:40:42,369 --> 00:40:44,049
start function is revoking with a single

1065
00:40:44,049 --> 00:40:46,059
argument namely with that auxiliary

1066
00:40:46,059 --> 00:40:48,009
vector so the start function immediately

1067
00:40:48,009 --> 00:40:50,260
gets access to these key value pairs

1068
00:40:50,260 --> 00:40:52,030
you know of all of the interesting

1069
00:40:52,030 --> 00:40:54,850
attributes that we we want and then what

1070
00:40:54,850 --> 00:40:56,800
happens if you sort of scroll down you

1071
00:40:56,800 --> 00:40:58,390
see that there's this ugly loop in here

1072
00:40:58,390 --> 00:41:00,910
that extracts all of the things from the

1073
00:41:00,910 --> 00:41:02,440
the auxiliary vector that we're

1074
00:41:02,440 --> 00:41:06,040
interested in so it extracts its own

1075
00:41:06,040 --> 00:41:09,760
phred ID etc and this field that I

1076
00:41:09,760 --> 00:41:12,100
didn't want to spoil earlier on this is

1077
00:41:12,100 --> 00:41:13,450
actually the base address where the

1078
00:41:13,450 --> 00:41:15,400
Colonel's stored at feed ears oh so it

1079
00:41:15,400 --> 00:41:17,320
loaded the program into memory and next

1080
00:41:17,320 --> 00:41:18,730
to that someplace in the other space was

1081
00:41:18,730 --> 00:41:21,730
also loaded that tiny assembly written

1082
00:41:21,730 --> 00:41:23,710
library there and this is the base

1083
00:41:23,710 --> 00:41:25,450
address of that library so this is sort

1084
00:41:25,450 --> 00:41:28,660
of the the library contained this is

1085
00:41:28,660 --> 00:41:29,890
explaining like you know if you want to

1086
00:41:29,890 --> 00:41:31,180
invoke system calls at some point in

1087
00:41:31,180 --> 00:41:32,470
time you need to go through this library

1088
00:41:32,470 --> 00:41:36,160
over there so after going through this

1089
00:41:36,160 --> 00:41:37,990
loop this is also where so does the

1090
00:41:37,990 --> 00:41:42,460
madness starts so Chloe bi executables

1091
00:41:42,460 --> 00:41:45,610
are position independent at least on ami

1092
00:41:45,610 --> 00:41:47,350
64 and arm 64 because in other

1093
00:41:47,350 --> 00:41:49,120
architectures it's two feasible to do

1094
00:41:49,120 --> 00:41:51,730
but this is where like the the insane

1095
00:41:51,730 --> 00:41:56,230
thing happens so what happens is that

1096
00:41:56,230 --> 00:41:57,940
programs can't be made like fully

1097
00:41:57,940 --> 00:42:00,100
position independent there are some

1098
00:42:00,100 --> 00:42:02,440
things that can't actually sort of be

1099
00:42:02,440 --> 00:42:04,090
placed in the executable or stored in

1100
00:42:04,090 --> 00:42:05,290
the executor in such a way that they're

1101
00:42:05,290 --> 00:42:07,330
completely position independent so if

1102
00:42:07,330 --> 00:42:08,620
you have a global variable that's a

1103
00:42:08,620 --> 00:42:09,880
pointer that's pointing to some other

1104
00:42:09,880 --> 00:42:11,350
global variable that's point to smarter

1105
00:42:11,350 --> 00:42:13,420
global variable those kinds of things

1106
00:42:13,420 --> 00:42:15,490
can't be filled in at kampala link line

1107
00:42:15,490 --> 00:42:16,810
they really need to be filled in at

1108
00:42:16,810 --> 00:42:20,140
runtime when a program starts up so what

1109
00:42:20,140 --> 00:42:22,240
happens is that the CR T 0 files written

1110
00:42:22,240 --> 00:42:25,510
in such a way that it actually doesn't

1111
00:42:25,510 --> 00:42:27,880
use such constructs itself it can be run

1112
00:42:27,880 --> 00:42:29,440
in this sort of environment

1113
00:42:29,440 --> 00:42:31,510
where we've loaded the executable in the

1114
00:42:31,510 --> 00:42:33,640
wrong memory address so to speak you

1115
00:42:33,640 --> 00:42:35,680
know it's completely relocation free but

1116
00:42:35,680 --> 00:42:37,750
there is sort of a tiny relocator in

1117
00:42:37,750 --> 00:42:40,480
there so what happens is that in the

1118
00:42:40,480 --> 00:42:42,430
headers of the executable there's sort

1119
00:42:42,430 --> 00:42:43,960
of this huge list that sort of stores

1120
00:42:43,960 --> 00:42:46,390
like if this executables being moved

1121
00:42:46,390 --> 00:42:48,730
over to a different place in memory then

1122
00:42:48,730 --> 00:42:49,840
you need to make sure that you patch up

1123
00:42:49,840 --> 00:42:52,240
these memory addresses to point to these

1124
00:42:52,240 --> 00:42:54,490
other variables in the program and those

1125
00:42:54,490 --> 00:42:56,530
are called relocations so this is a

1126
00:42:56,530 --> 00:42:58,780
relocator relocator applies relocations

1127
00:42:58,780 --> 00:43:00,010
to make sure that the program can be

1128
00:43:00,010 --> 00:43:01,500
relocated

1129
00:43:01,500 --> 00:43:03,790
then this is sort of like the start of

1130
00:43:03,790 --> 00:43:04,120
it

1131
00:43:04,120 --> 00:43:05,830
we're seeing so what we're doing we're

1132
00:43:05,830 --> 00:43:07,450
sort of keeping track of the so called

1133
00:43:07,450 --> 00:43:09,160
dynamic section and in the dynamic

1134
00:43:09,160 --> 00:43:10,630
section that's also better where the

1135
00:43:10,630 --> 00:43:12,820
relocations are stored and what we're

1136
00:43:12,820 --> 00:43:14,050
also doing we're keeping track of this

1137
00:43:14,050 --> 00:43:15,640
railroad header and it's this is really

1138
00:43:15,640 --> 00:43:18,490
funny if once you're done relocating

1139
00:43:18,490 --> 00:43:20,050
there's actually certain pieces of

1140
00:43:20,050 --> 00:43:21,460
memory that needs to be writable to

1141
00:43:21,460 --> 00:43:23,350
apply to relocations but then once

1142
00:43:23,350 --> 00:43:24,310
you're done you can make the read-only

1143
00:43:24,310 --> 00:43:26,980
again so we sort of keep track of this

1144
00:43:26,980 --> 00:43:28,480
information so we can make it read-only

1145
00:43:28,480 --> 00:43:31,920
afterwards once we're done relocating so

1146
00:43:31,920 --> 00:43:34,480
also Fred local sort I won't explain too

1147
00:43:34,480 --> 00:43:36,700
much about that right now now that we

1148
00:43:36,700 --> 00:43:38,680
sort of saw we're going a bit further

1149
00:43:38,680 --> 00:43:40,450
we're going to like extract a list of

1150
00:43:40,450 --> 00:43:42,910
relocations and then over here is this

1151
00:43:42,910 --> 00:43:46,270
loop where we're applying them so only

1152
00:43:46,270 --> 00:43:49,000
on x86 64 and arm 64 we have support for

1153
00:43:49,000 --> 00:43:50,980
position in appendix Q doubles and these

1154
00:43:50,980 --> 00:43:52,750
are the only relocations that we need to

1155
00:43:52,750 --> 00:43:54,160
take out there's like a whole bunch of

1156
00:43:54,160 --> 00:43:55,570
different types of me locations but in

1157
00:43:55,570 --> 00:43:57,310
our case these are the ones we need to

1158
00:43:57,310 --> 00:44:00,400
apply so the only thing it does is for a

1159
00:44:00,400 --> 00:44:01,780
whole bunch of memory addresses in the

1160
00:44:01,780 --> 00:44:04,960
program we're changing the value to be

1161
00:44:04,960 --> 00:44:07,210
the base address of the program plus the

1162
00:44:07,210 --> 00:44:08,770
offset that was being requested so this

1163
00:44:08,770 --> 00:44:09,970
is like the batching up that's being

1164
00:44:09,970 --> 00:44:13,990
done of the program once that's sort of

1165
00:44:13,990 --> 00:44:16,780
done now the program is in the same

1166
00:44:16,780 --> 00:44:19,120
state so all of this code and everything

1167
00:44:19,120 --> 00:44:20,860
that comes above is ingredients for this

1168
00:44:20,860 --> 00:44:22,540
 state where the program's only

1169
00:44:22,540 --> 00:44:23,860
sort of half functioning because it's

1170
00:44:23,860 --> 00:44:26,440
loaded up in the wrong address but this

1171
00:44:26,440 --> 00:44:29,320
piece of code sort of deco seven now now

1172
00:44:29,320 --> 00:44:32,200
things are starting to become sane now

1173
00:44:32,200 --> 00:44:34,330
well early halfway there because we

1174
00:44:34,330 --> 00:44:35,800
still come to folk any system calls

1175
00:44:35,800 --> 00:44:37,990
that's still madness so all of this

1176
00:44:37,990 --> 00:44:40,060
piece of code is you saw above there it

1177
00:44:40,060 --> 00:44:41,830
can't allocate any memory it can't do

1178
00:44:41,830 --> 00:44:43,450
anything it's really running in this

1179
00:44:43,450 --> 00:44:45,700
really constrained environment so now

1180
00:44:45,700 --> 00:44:47,770
we're going to like make system calls

1181
00:44:47,770 --> 00:44:49,180
work so how does that work

1182
00:44:49,180 --> 00:44:51,430
cloud API programs sort of have a built

1183
00:44:51,430 --> 00:44:53,800
in system call table so it's like an

1184
00:44:53,800 --> 00:44:55,420
array of function pointers where like

1185
00:44:55,420 --> 00:44:57,370
the system calls are placed and by

1186
00:44:57,370 --> 00:44:59,350
default in it it initializes it with a

1187
00:44:59,350 --> 00:45:01,890
function then does nothing more than

1188
00:45:01,890 --> 00:45:03,550
which I could show you

1189
00:45:03,550 --> 00:45:06,130
you know sis so this is like a really

1190
00:45:06,130 --> 00:45:08,230
simple stub system call and whenever you

1191
00:45:08,230 --> 00:45:09,490
call a system call that the kernel

1192
00:45:09,490 --> 00:45:12,280
doesn't implement it it only does this

1193
00:45:12,280 --> 00:45:16,180
it only returns enosis and now what

1194
00:45:16,180 --> 00:45:17,950
we're going to do is while this is for

1195
00:45:17,950 --> 00:45:19,329
some legacy garbage that you should

1196
00:45:19,329 --> 00:45:21,910
ignore so let's remove this you didn't

1197
00:45:21,910 --> 00:45:23,980
see this also this to do entry can be

1198
00:45:23,980 --> 00:45:27,130
removed entirely yeah see this what I

1199
00:45:27,130 --> 00:45:30,579
want to show so it invokes this link

1200
00:45:30,579 --> 00:45:32,380
video so function and this is just a

1201
00:45:32,380 --> 00:45:36,880
tiny piece of code that get gets the

1202
00:45:36,880 --> 00:45:38,680
chair library that the colonel passed in

1203
00:45:38,680 --> 00:45:41,290
so it guesses from the ETCs info ietter

1204
00:45:41,290 --> 00:45:44,079
and it walks over here left headers

1205
00:45:44,079 --> 00:45:46,690
looking for the simple table let's head

1206
00:45:46,690 --> 00:45:48,490
over here and then eventually we're

1207
00:45:48,490 --> 00:45:50,349
looping over all of the symbols in that

1208
00:45:50,349 --> 00:45:51,670
library that the colonel sort of pushed

1209
00:45:51,670 --> 00:45:53,410
into the program and we're looking for

1210
00:45:53,410 --> 00:45:54,790
everything that started with cloudy the

1211
00:45:54,790 --> 00:45:56,650
isis and these are the system call

1212
00:45:56,650 --> 00:45:58,150
functions that library provided and

1213
00:45:58,150 --> 00:45:59,829
we're sort of patching them into that

1214
00:45:59,829 --> 00:46:01,960
that table with this this ugly loop over

1215
00:46:01,960 --> 00:46:02,319
here

1216
00:46:02,319 --> 00:46:06,790
so once link video is done now we can

1217
00:46:06,790 --> 00:46:08,260
sort of invoke system calls we have an

1218
00:46:08,260 --> 00:46:09,640
array in a program that contains

1219
00:46:09,640 --> 00:46:10,839
function pointers to the proper

1220
00:46:10,839 --> 00:46:12,790
implementations of the system calls so

1221
00:46:12,790 --> 00:46:14,680
now here's like a remnant of the

1222
00:46:14,680 --> 00:46:17,109
relegate relocator if relocation for

1223
00:46:17,109 --> 00:46:19,000
some reason failed only at this point in

1224
00:46:19,000 --> 00:46:21,130
time we can abort you know before we

1225
00:46:21,130 --> 00:46:22,359
couldn't abort because we didn't have an

1226
00:46:22,359 --> 00:46:27,309
abort system call yet so messy and again

1227
00:46:27,309 --> 00:46:29,710
that railroad stuff so relocation

1228
00:46:29,710 --> 00:46:31,180
because it's now finished we can mark

1229
00:46:31,180 --> 00:46:33,220
some stuff read-only so this is like the

1230
00:46:33,220 --> 00:46:34,780
first system call that a programmer

1231
00:46:34,780 --> 00:46:37,059
Klaudia VI program calls it calls a mem

1232
00:46:37,059 --> 00:46:39,160
protect to an m protective sort of make

1233
00:46:39,160 --> 00:46:41,890
that stuff read-only and now global

1234
00:46:41,890 --> 00:46:43,569
variables work as well because we

1235
00:46:43,569 --> 00:46:45,010
applied relocation so we're storing a

1236
00:46:45,010 --> 00:46:46,960
whole bunch of stuff we there was placed

1237
00:46:46,960 --> 00:46:50,470
in the auxiliary vector and global

1238
00:46:50,470 --> 00:46:51,880
variables so the c library can end up

1239
00:46:51,880 --> 00:46:53,170
using it

1240
00:46:53,170 --> 00:46:55,059
setting up stack smashing that's done

1241
00:46:55,059 --> 00:46:57,130
over here initializing thread-local

1242
00:46:57,130 --> 00:46:58,569
storage i won't explain anything about

1243
00:46:58,569 --> 00:47:00,970
that that's all volu initializing

1244
00:47:00,970 --> 00:47:01,540
pthreads

1245
00:47:01,540 --> 00:47:03,760
because we now know our own fret ID so

1246
00:47:03,760 --> 00:47:05,440
yeah that's something that sort of

1247
00:47:05,440 --> 00:47:06,880
needed to make threading work if you

1248
00:47:06,880 --> 00:47:08,260
don't know your fred ID you can't apply

1249
00:47:08,260 --> 00:47:11,410
you can't block acquire locks because

1250
00:47:11,410 --> 00:47:12,670
you have to write your own thread ID

1251
00:47:12,670 --> 00:47:14,349
into locks you say like i'm the fred

1252
00:47:14,349 --> 00:47:17,440
that owns this lock so this is like some

1253
00:47:17,440 --> 00:47:19,660
stuff needed to me make p fred join work

1254
00:47:19,660 --> 00:47:20,980
and this is some stuff that's needed to

1255
00:47:20,980 --> 00:47:23,589
make mutex locking work global

1256
00:47:23,589 --> 00:47:26,829
constructors Brooks also explain this

1257
00:47:26,829 --> 00:47:28,900
earnest talk some simple loop to call

1258
00:47:28,900 --> 00:47:31,790
constructors and then we're calling into

1259
00:47:31,790 --> 00:47:34,220
program main which was sort of that

1260
00:47:34,220 --> 00:47:35,920
alternative entry point that uses the

1261
00:47:35,920 --> 00:47:38,540
like that yeah mo data boss into the

1262
00:47:38,540 --> 00:47:45,380
program now there is still eight minutes

1263
00:47:45,380 --> 00:47:45,830
left

1264
00:47:45,830 --> 00:47:51,650
yeah what should I explain next I've got

1265
00:47:51,650 --> 00:47:54,080
something I can strip it down I've got

1266
00:47:54,080 --> 00:47:55,670
something that things like 9 minutes to

1267
00:47:55,670 --> 00:48:00,130
explain so sort of to think yeah yeah

1268
00:48:00,130 --> 00:48:03,410
shorten down a bit so now the question

1269
00:48:03,410 --> 00:48:06,200
was also like with which that web server

1270
00:48:06,200 --> 00:48:08,300
that I showed you

1271
00:48:08,300 --> 00:48:10,670
demo web server you know I showed you

1272
00:48:10,670 --> 00:48:12,020
the config file where you sort of both

1273
00:48:12,020 --> 00:48:13,670
has config attributes and file

1274
00:48:13,670 --> 00:48:15,380
descriptors in there so this is like

1275
00:48:15,380 --> 00:48:19,130
this magic tree of both strings integers

1276
00:48:19,130 --> 00:48:21,260
boolean's dictionaries etc but it also

1277
00:48:21,260 --> 00:48:23,360
contains file descriptors and the

1278
00:48:23,360 --> 00:48:25,580
question is how does this get passed on

1279
00:48:25,580 --> 00:48:28,100
to programs you know what how does it

1280
00:48:28,100 --> 00:48:29,540
look on the dude how can the kernel sort

1281
00:48:29,540 --> 00:48:31,250
of copy one tree of stuff over to the

1282
00:48:31,250 --> 00:48:34,100
other program well why you can sort of

1283
00:48:34,100 --> 00:48:35,750
sort of show you is that in the C

1284
00:48:35,750 --> 00:48:37,520
library first of all there is this API

1285
00:48:37,520 --> 00:48:40,360
called arc date adult age and this is

1286
00:48:40,360 --> 00:48:42,260
functions that can be used to sort of

1287
00:48:42,260 --> 00:48:44,480
create this tree structure so what you

1288
00:48:44,480 --> 00:48:47,180
can do is you can say like okay let's

1289
00:48:47,180 --> 00:48:50,510
create a string and let's create a

1290
00:48:50,510 --> 00:48:52,820
floating point number and let's create a

1291
00:48:52,820 --> 00:48:56,900
false krypter and then later on we place

1292
00:48:56,900 --> 00:48:59,990
them into an a list so this is like a

1293
00:48:59,990 --> 00:49:02,090
yeah most our list so you end up with

1294
00:49:02,090 --> 00:49:04,190
this arc data object our data team and

1295
00:49:04,190 --> 00:49:07,340
that we represents a list of like the

1296
00:49:07,340 --> 00:49:08,990
string the the floating-point number and

1297
00:49:08,990 --> 00:49:11,360
the false crypto in there and this is

1298
00:49:11,360 --> 00:49:13,190
sort of what like a program that wants

1299
00:49:13,190 --> 00:49:15,050
to start another cloud API program sort

1300
00:49:15,050 --> 00:49:17,420
of invokes it first constructs this tree

1301
00:49:17,420 --> 00:49:20,270
in memory of its arguments and what

1302
00:49:20,270 --> 00:49:22,210
happens then is there is just this

1303
00:49:22,210 --> 00:49:25,430
program X action and this is sort of the

1304
00:49:25,430 --> 00:49:26,930
function that you use a user space if

1305
00:49:26,930 --> 00:49:27,830
you want to call different

1306
00:49:27,830 --> 00:49:29,930
klaudia guy programs so what you say

1307
00:49:29,930 --> 00:49:31,760
like I've got a file descriptor of a

1308
00:49:31,760 --> 00:49:34,040
program like the new program I want to

1309
00:49:34,040 --> 00:49:35,600
start like the cloudy API web server and

1310
00:49:35,600 --> 00:49:37,460
I want to start it with these arguments

1311
00:49:37,460 --> 00:49:39,640
that's sort of what this call does and

1312
00:49:39,640 --> 00:49:42,410
how that works in practice is actually I

1313
00:49:42,410 --> 00:49:45,260
think it's pretty cool program xx so

1314
00:49:45,260 --> 00:49:45,770
let's say

1315
00:49:45,770 --> 00:49:51,560
the cloud EVIC library it actually this

1316
00:49:51,560 --> 00:49:53,240
is sort of where the magic comes in like

1317
00:49:53,240 --> 00:49:54,560
how can we get this tree transferred

1318
00:49:54,560 --> 00:49:57,070
over to the other side it's sort of

1319
00:49:57,070 --> 00:49:59,330
decomposes it into two things so first

1320
00:49:59,330 --> 00:50:01,310
of all it's serializes the entire tree

1321
00:50:01,310 --> 00:50:03,830
into like a binary blob so all of the

1322
00:50:03,830 --> 00:50:07,070
strings integers boolean's dictionaries

1323
00:50:07,070 --> 00:50:08,720
lists they're all turn into like a

1324
00:50:08,720 --> 00:50:11,210
binary animal in a certain way like a

1325
00:50:11,210 --> 00:50:13,120
really compact way of representing that

1326
00:50:13,120 --> 00:50:15,590
but then we also need to deal with the

1327
00:50:15,590 --> 00:50:16,910
follow scripters that need to be sent

1328
00:50:16,910 --> 00:50:18,860
over to the other side so what happens

1329
00:50:18,860 --> 00:50:22,220
is that this function our data get

1330
00:50:22,220 --> 00:50:24,230
buffer B composes the two things it

1331
00:50:24,230 --> 00:50:25,730
serializes all of the non file

1332
00:50:25,730 --> 00:50:27,410
descriptors and puts off the file

1333
00:50:27,410 --> 00:50:30,320
descriptors in an array and that that

1334
00:50:30,320 --> 00:50:32,090
serialized data so the one chunk of data

1335
00:50:32,090 --> 00:50:33,950
sort of has references over to like the

1336
00:50:33,950 --> 00:50:35,870
false crypto so it says like of those

1337
00:50:35,870 --> 00:50:37,370
follow the scripts that we extracted out

1338
00:50:37,370 --> 00:50:39,800
of the data the first file descriptor

1339
00:50:39,800 --> 00:50:41,480
corresponds with the sockets the second

1340
00:50:41,480 --> 00:50:42,740
file descriptor in there corresponds

1341
00:50:42,740 --> 00:50:43,970
with the log file the third file

1342
00:50:43,970 --> 00:50:45,710
descriptor corresponds with the left

1343
00:50:45,710 --> 00:50:47,990
service root and these two things are

1344
00:50:47,990 --> 00:50:50,480
then passed on to the kernel separately

1345
00:50:50,480 --> 00:50:52,550
so the fun thing about this model is

1346
00:50:52,550 --> 00:50:54,590
that cloud a bi program or like the

1347
00:50:54,590 --> 00:50:56,090
kernel has absolutely no understanding

1348
00:50:56,090 --> 00:50:58,940
of our data T the only thing it can deal

1349
00:50:58,940 --> 00:51:01,670
with is a binary blob that needs to be

1350
00:51:01,670 --> 00:51:03,290
possible to the processor in like years

1351
00:51:03,290 --> 00:51:05,210
all that junk that you know strains

1352
00:51:05,210 --> 00:51:06,800
boolean set the new program needs to

1353
00:51:06,800 --> 00:51:08,960
have and here's a bunch of file

1354
00:51:08,960 --> 00:51:10,490
descriptors that need to be preserved in

1355
00:51:10,490 --> 00:51:12,470
the other process and this sort of keeps

1356
00:51:12,470 --> 00:51:13,100
the kernel

1357
00:51:13,100 --> 00:51:15,380
you know lean and clean and also makes

1358
00:51:15,380 --> 00:51:17,030
it a lot more flexible because now in

1359
00:51:17,030 --> 00:51:18,590
user space we can introduce new data

1360
00:51:18,590 --> 00:51:21,170
types so say if we want to add a complex

1361
00:51:21,170 --> 00:51:24,110
number type or you know bi-directional

1362
00:51:24,110 --> 00:51:26,660
Maps or any other stuff all that stuff

1363
00:51:26,660 --> 00:51:28,100
can be implemented in the our data

1364
00:51:28,100 --> 00:51:30,530
library but the kernel only needs to be

1365
00:51:30,530 --> 00:51:32,000
implemented in such a way that it can

1366
00:51:32,000 --> 00:51:35,090
copy over like binary junk and a list of

1367
00:51:35,090 --> 00:51:36,980
file descriptors and then on the other

1368
00:51:36,980 --> 00:51:38,540
side in a new process that sort of

1369
00:51:38,540 --> 00:51:40,490
combined into like one unified tree

1370
00:51:40,490 --> 00:51:42,920
again so it's two separate things but as

1371
00:51:42,920 --> 00:51:44,270
a program you won't notice anything

1372
00:51:44,270 --> 00:51:44,870
about it

1373
00:51:44,870 --> 00:51:49,250
so this is sort of like all I think I'd

1374
00:51:49,250 --> 00:51:50,750
better sort of keep it at this this is

1375
00:51:50,750 --> 00:51:53,780
sort of like in bird's eye view or well

1376
00:51:53,780 --> 00:51:55,520
the really low-level view how cloudy API

1377
00:51:55,520 --> 00:51:57,410
works

1378
00:51:57,410 --> 00:52:00,350
it's a lot of code if you understood

1379
00:52:00,350 --> 00:52:01,910
half of it then I'm already pretty glad

1380
00:52:01,910 --> 00:52:06,440
about it are there any questions did you

1381
00:52:06,440 --> 00:52:07,340
find it informative

1382
00:52:07,340 --> 00:52:22,700
not at all yeah oh so that's a really

1383
00:52:22,700 --> 00:52:25,130
good question so the broader question is

1384
00:52:25,130 --> 00:52:28,210
is there any support for dynamic linking

1385
00:52:28,210 --> 00:52:31,310
can I use shared libraries in cloud EBI

1386
00:52:31,310 --> 00:52:36,610
programs and the answer to that is no so

1387
00:52:36,610 --> 00:52:40,610
one of the things that I am now I'm

1388
00:52:40,610 --> 00:52:41,930
going to make a statement and then now

1389
00:52:41,930 --> 00:52:43,820
like five people are going to correct me

1390
00:52:43,820 --> 00:52:48,080
which i think is really horrible having

1391
00:52:48,080 --> 00:52:50,050
shared library support or not is

1392
00:52:50,050 --> 00:52:53,060
actually you you you get two features or

1393
00:52:53,060 --> 00:52:56,000
you don't get both of them as in what's

1394
00:52:56,000 --> 00:52:57,530
really annoying about shared libraries

1395
00:52:57,530 --> 00:52:59,810
is that the entire API of dealing with

1396
00:52:59,810 --> 00:53:01,670
shared libraries is actually two things

1397
00:53:01,670 --> 00:53:03,440
so first of all there's like the linking

1398
00:53:03,440 --> 00:53:05,420
on startup where you create a program

1399
00:53:05,420 --> 00:53:07,760
and you link it with - shell whatever

1400
00:53:07,760 --> 00:53:11,300
and there's deal open and both of those

1401
00:53:11,300 --> 00:53:13,550
two are completely separate beasts that

1402
00:53:13,550 --> 00:53:15,410
need to be tackled separately from each

1403
00:53:15,410 --> 00:53:15,830
other

1404
00:53:15,830 --> 00:53:19,730
in the case of cloud ABI I wouldn't mind

1405
00:53:19,730 --> 00:53:22,070
having a deal open function uh you know

1406
00:53:22,070 --> 00:53:23,690
where you can just say I've got a file

1407
00:53:23,690 --> 00:53:25,640
descriptor library like an F DL open

1408
00:53:25,640 --> 00:53:27,920
like load is into the program I want to

1409
00:53:27,920 --> 00:53:29,150
call its function that's perfectly fine

1410
00:53:29,150 --> 00:53:29,540
to me

1411
00:53:29,540 --> 00:53:31,700
but what doesn't really work that well

1412
00:53:31,700 --> 00:53:34,940
for cloudy API is linking against like

1413
00:53:34,940 --> 00:53:36,950
we said compile time and the reason for

1414
00:53:36,950 --> 00:53:39,080
that is cloudy API programs don't have

1415
00:53:39,080 --> 00:53:40,370
like a global file system namespace

1416
00:53:40,370 --> 00:53:42,230
there's no user live from which you can

1417
00:53:42,230 --> 00:53:43,610
load libraries and that's also not

1418
00:53:43,610 --> 00:53:45,200
something I want to have I don't want to

1419
00:53:45,200 --> 00:53:47,960
have it a global namespace but as far as

1420
00:53:47,960 --> 00:53:50,300
I know like looking at sort of the way

1421
00:53:50,300 --> 00:53:53,030
II left works looking at the way the LV

1422
00:53:53,030 --> 00:53:55,970
m LD linker works looking into a clang

1423
00:53:55,970 --> 00:53:56,390
works

1424
00:53:56,390 --> 00:54:01,120
you only get both or not so

1425
00:54:15,280 --> 00:54:17,660
exactly but for cloud ABI they aren't

1426
00:54:17,660 --> 00:54:20,960
because you can't like in the header of

1427
00:54:20,960 --> 00:54:23,000
an e LF executables say I'm gonna load

1428
00:54:23,000 --> 00:54:25,430
in lip as a selves of s oh and I want

1429
00:54:25,430 --> 00:54:27,950
you to use file descriptor 5 I'm that

1430
00:54:27,950 --> 00:54:29,030
doesn't make any sense

1431
00:54:29,030 --> 00:54:32,390
so like this already doing this linking

1432
00:54:32,390 --> 00:54:34,940
at startup or like I'd looked when the

1433
00:54:34,940 --> 00:54:38,270
programs loaded and started up I I can't

1434
00:54:38,270 --> 00:54:40,070
really think of the same way in which I

1435
00:54:40,070 --> 00:54:41,450
could get that working with cloudy avi

1436
00:54:41,450 --> 00:54:43,460
because blue cloudy VI tree the case the

1437
00:54:43,460 --> 00:54:45,080
first instruction that the program

1438
00:54:45,080 --> 00:54:48,140
already calls and an underscore start is

1439
00:54:48,140 --> 00:54:50,030
already running in the sandbox mode

1440
00:54:50,030 --> 00:54:52,100
I can't just access user lip from there

1441
00:54:52,100 --> 00:54:55,340
and there's there's no easy way to

1442
00:54:55,340 --> 00:54:57,350
decouple these two for now so what I've

1443
00:54:57,350 --> 00:54:58,760
done is I've you know just focused on

1444
00:54:58,760 --> 00:55:00,980
only doing static linkage so no

1445
00:55:00,980 --> 00:55:04,610
dependency libraries and it does have

1446
00:55:04,610 --> 00:55:06,350
its disadvantages but it also makes

1447
00:55:06,350 --> 00:55:09,470
certain things a lot easier one of the

1448
00:55:09,470 --> 00:55:11,900
pretty cool things that I like about not

1449
00:55:11,900 --> 00:55:13,880
having dynamically dynamic linking

1450
00:55:13,880 --> 00:55:16,220
against libraries is that because you

1451
00:55:16,220 --> 00:55:18,350
already know which functions need to be

1452
00:55:18,350 --> 00:55:19,940
present during the entire lifetime of

1453
00:55:19,940 --> 00:55:21,800
the process you can also do some really

1454
00:55:21,800 --> 00:55:23,150
aggressive garbage collecting of

1455
00:55:23,150 --> 00:55:27,140
functions so with L LD what I really

1456
00:55:27,140 --> 00:55:28,520
skimmed over briefly if you looked at

1457
00:55:28,520 --> 00:55:29,960
the clang source code it always calls

1458
00:55:29,960 --> 00:55:31,670
the linker in such a way that it calls -

1459
00:55:31,670 --> 00:55:35,270
- GC sections so it really trims off any

1460
00:55:35,270 --> 00:55:36,980
code that's actually not being called so

1461
00:55:36,980 --> 00:55:38,450
if you link in a huge library but only

1462
00:55:38,450 --> 00:55:40,970
use a fraction of it it's not part of

1463
00:55:40,970 --> 00:55:44,270
the resulting executable so ya know

1464
00:55:44,270 --> 00:55:47,260
dynamic linking but yeah good enough

1465
00:55:47,260 --> 00:55:49,220
we'll tackle that later on if people

1466
00:55:49,220 --> 00:55:52,209
really need this

1467
00:55:56,540 --> 00:55:58,700
so like the you're talking about like

1468
00:55:58,700 --> 00:56:01,790
the interpreter header yeah yeah yeah so

1469
00:56:01,790 --> 00:56:05,780
so what happens is that in clang what we

1470
00:56:05,780 --> 00:56:07,790
skimmed over really briefly it calls the

1471
00:56:07,790 --> 00:56:10,600
linker with - - no default linker and

1472
00:56:10,600 --> 00:56:14,570
that makes LD not add like one of those

1473
00:56:14,570 --> 00:56:16,910
interpreter headers to it so then the

1474
00:56:16,910 --> 00:56:18,710
kernel starts it up directly

1475
00:56:18,710 --> 00:56:21,260
you know it's it it doesn't try to load

1476
00:56:21,260 --> 00:56:22,970
an interpreter there as well so that's

1477
00:56:22,970 --> 00:56:24,830
the reason why our CRT zero is a bit

1478
00:56:24,830 --> 00:56:26,720
fatter than it normally is

1479
00:56:26,720 --> 00:56:28,900
because it really needs to be sort of

1480
00:56:28,900 --> 00:56:30,859
freestanding in a certain way the

1481
00:56:30,859 --> 00:56:32,210
program starts up and it needs to fix

1482
00:56:32,210 --> 00:56:34,880
itself up so that makes a little bit

1483
00:56:34,880 --> 00:56:36,349
more complex that's also the reason why

1484
00:56:36,349 --> 00:56:37,220
there's no position independent

1485
00:56:37,220 --> 00:56:39,740
executable support for 32-bit Intel's

1486
00:56:39,740 --> 00:56:41,750
because that's pretty hard to accomplish

1487
00:56:41,750 --> 00:56:44,030
if you're sort of starting up in this

1488
00:56:44,030 --> 00:56:45,980
unreal okay today on a 32-bit system

1489
00:56:45,980 --> 00:56:48,910
there's no rip relative addressing so

1490
00:56:48,910 --> 00:56:51,740
yeah but it's a really good question

1491
00:56:51,740 --> 00:56:57,200
yeah are there any other questions none

1492
00:56:57,200 --> 00:57:00,470
at all all of you were sort of baffled

1493
00:57:00,470 --> 00:57:04,880
about all the technical stuff well it's

1494
00:57:04,880 --> 00:57:06,859
already late I guess I said I guess most

1495
00:57:06,859 --> 00:57:08,960
people want to head over to restaurant

1496
00:57:08,960 --> 00:57:12,890
grab some Belgian beers oh thanks for

1497
00:57:12,890 --> 00:57:15,310
attending anyway

1498
00:57:15,310 --> 00:57:22,739
[Applause]

