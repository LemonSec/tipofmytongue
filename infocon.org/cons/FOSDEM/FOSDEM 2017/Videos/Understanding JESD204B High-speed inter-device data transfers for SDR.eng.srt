1
00:00:04,560 --> 00:00:06,689
the topic of this presentation is

2
00:00:06,689 --> 00:00:09,959
understanding Jessie - Furby in less

3
00:00:09,959 --> 00:00:13,109
than 30 minutes so it definitely won't

4
00:00:13,109 --> 00:00:17,160
be a complete guide to Jessie - for be a

5
00:00:17,160 --> 00:00:19,350
but I will try to cover like the basics

6
00:00:19,350 --> 00:00:25,499
the most important subjects and if

7
00:00:25,499 --> 00:00:26,970
you're still interested into it there

8
00:00:26,970 --> 00:00:29,339
are some like links at the end of the

9
00:00:29,339 --> 00:00:31,710
slide that you can follow if you want to

10
00:00:31,710 --> 00:00:34,500
further dive into it my name is Lars

11
00:00:34,500 --> 00:00:36,060
Pierre Claussen I work for analog

12
00:00:36,060 --> 00:00:39,270
devices and so first introduction what

13
00:00:39,270 --> 00:00:42,810
is Jessie - Furby and it has been

14
00:00:42,810 --> 00:00:45,170
designed

15
00:00:51,090 --> 00:00:53,150
you

16
00:00:56,969 --> 00:01:01,149
and it supports up to 32 lanes per link

17
00:01:01,149 --> 00:01:05,619
and each lane can transport up to 12.5

18
00:01:05,619 --> 00:01:10,630
gigabits per second of raw data the

19
00:01:10,630 --> 00:01:13,090
actual useful payload is a little bit

20
00:01:13,090 --> 00:01:14,649
less curse a little bit of protocol

21
00:01:14,649 --> 00:01:18,130
overt but overall you can get like 40

22
00:01:18,130 --> 00:01:21,220
gigabits per second 400 gigabits per

23
00:01:21,220 --> 00:01:23,890
second over 1 link which is quite a bit

24
00:01:23,890 --> 00:01:28,000
and the standard the Jesse - for beast

25
00:01:28,000 --> 00:01:30,100
or Jesse - for standard not only

26
00:01:30,100 --> 00:01:33,520
describes how to get bits from A to B

27
00:01:33,520 --> 00:01:37,539
but it also signs meaning to the bits it

28
00:01:37,539 --> 00:01:42,340
describes how like how to map a sample

29
00:01:42,340 --> 00:01:44,740
onto those high speed lanes is all you

30
00:01:44,740 --> 00:01:47,289
find under standard itself unlike for

31
00:01:47,289 --> 00:01:50,259
example if you are using converters

32
00:01:50,259 --> 00:01:55,810
using parallel LVDS there's no common

33
00:01:55,810 --> 00:01:58,179
standard how to map the data onto onto

34
00:01:58,179 --> 00:02:01,780
the LVDS lines and other things that are

35
00:02:01,780 --> 00:02:04,119
just a 2 feet Jesse - for standard

36
00:02:04,119 --> 00:02:07,509
offers is moot uShip synchronization so

37
00:02:07,509 --> 00:02:10,600
if you have multiple chips multiple

38
00:02:10,600 --> 00:02:13,989
adc's multiple decks and want to capture

39
00:02:13,989 --> 00:02:17,320
synchronized data or transmit

40
00:02:17,320 --> 00:02:20,019
synchronize data the standard defines

41
00:02:20,019 --> 00:02:22,500
how to do this so there's no longer chip

42
00:02:22,500 --> 00:02:24,970
specific and the other very important

43
00:02:24,970 --> 00:02:26,859
thing is data monistic latency we will

44
00:02:26,859 --> 00:02:29,079
talk about this in more detail in a

45
00:02:29,079 --> 00:02:33,280
moment but it basically allows you to

46
00:02:33,280 --> 00:02:35,380
make assumptions about how much time

47
00:02:35,380 --> 00:02:37,989
will elapse between when the conversion

48
00:02:37,989 --> 00:02:41,200
was done and when the data arrives at

49
00:02:41,200 --> 00:02:44,530
your logic processing device quick

50
00:02:44,530 --> 00:02:47,470
timeline so Jessie - Furby but Jessie -

51
00:02:47,470 --> 00:02:51,040
for went through three revisions there

52
00:02:51,040 --> 00:02:52,840
was the first one in 2006 and it only

53
00:02:52,840 --> 00:02:56,049
had one lane and it was only running at

54
00:02:56,049 --> 00:02:57,819
three point one two five gigabits per

55
00:02:57,819 --> 00:03:00,250
second and people quickly figured out it

56
00:03:00,250 --> 00:03:04,989
is not enough so in 2008 there was the

57
00:03:04,989 --> 00:03:08,200
first revision Jesse - for a

58
00:03:08,200 --> 00:03:11,099
and they had support for multiple lanes

59
00:03:11,099 --> 00:03:15,940
but it became pretty apparent it's still

60
00:03:15,940 --> 00:03:18,010
not enough so there was a second

61
00:03:18,010 --> 00:03:20,620
division or third revision Jesse - 4b

62
00:03:20,620 --> 00:03:24,220
which introduced which raised the limit

63
00:03:24,220 --> 00:03:27,760
for each lane up to 12.5 gigabits per

64
00:03:27,760 --> 00:03:29,500
second and if you kind of follow this

65
00:03:29,500 --> 00:03:34,200
timeline right about now it should be

66
00:03:34,200 --> 00:03:38,260
time for the next standard and they're

67
00:03:38,260 --> 00:03:41,260
actually devices shipping that go beyond

68
00:03:41,260 --> 00:03:43,600
what the standard has to offer and run

69
00:03:43,600 --> 00:03:47,769
it 15 gigabits per second pilling and I

70
00:03:47,769 --> 00:03:49,510
think there will also be a ref see at

71
00:03:49,510 --> 00:03:51,730
some point on the future soon and the

72
00:03:51,730 --> 00:03:55,600
other important thing that Jesse - for

73
00:03:55,600 --> 00:03:57,130
be introduced was the deterministic

74
00:03:57,130 --> 00:03:59,350
latency they're two different three

75
00:03:59,350 --> 00:04:02,440
different subclasses which are so

76
00:04:02,440 --> 00:04:05,410
subclass zero doesn't over deterministic

77
00:04:05,410 --> 00:04:08,049
latency and one and two basically have

78
00:04:08,049 --> 00:04:09,420
different methods for achieving

79
00:04:09,420 --> 00:04:12,400
deterministic latency and it also

80
00:04:12,400 --> 00:04:14,079
introduced a more flexible clocking

81
00:04:14,079 --> 00:04:17,079
scheme in the previous iterations you

82
00:04:17,079 --> 00:04:20,738
had to supply the same clock at the same

83
00:04:20,738 --> 00:04:22,810
frequency to all the devices in the

84
00:04:22,810 --> 00:04:25,360
system and was Jesse - for B it's

85
00:04:25,360 --> 00:04:29,070
possible to run some of the clocks at

86
00:04:29,070 --> 00:04:31,660
harmonic or sub harmonic frequencies

87
00:04:31,660 --> 00:04:35,860
this means you can the clock going to

88
00:04:35,860 --> 00:04:38,650
your converter might be twice as fast or

89
00:04:38,650 --> 00:04:40,900
four times as fast as a clock going to

90
00:04:40,900 --> 00:04:44,140
FPGA because let's say you have a

91
00:04:44,140 --> 00:04:46,510
converter running at one Giga sample per

92
00:04:46,510 --> 00:04:51,400
second you won't be able to run the

93
00:04:51,400 --> 00:04:55,240
logic in you FPGA at 1 Giga Hertz so you

94
00:04:55,240 --> 00:04:57,610
maybe want to scale down run at a 250

95
00:04:57,610 --> 00:05:02,500
megahertz and this was introduced by the

96
00:05:02,500 --> 00:05:05,139
standard so motivation why do we

97
00:05:05,139 --> 00:05:07,690
actually need this especially for the

98
00:05:07,690 --> 00:05:09,610
software-defined radio stuff why do we

99
00:05:09,610 --> 00:05:12,940
care about Jesse - Ruby and what we're

100
00:05:12,940 --> 00:05:15,700
seeing is that the increasing data

101
00:05:15,700 --> 00:05:20,680
demands like a lot of lot of the new

102
00:05:20,680 --> 00:05:21,849
mobile communications

103
00:05:21,849 --> 00:05:25,679
standards have rather wide channels

104
00:05:25,679 --> 00:05:29,770
Wi-Fi the latest version AC has channels

105
00:05:29,770 --> 00:05:32,520
which can be up to 160 megahertz wide

106
00:05:32,520 --> 00:05:36,849
LTE supports channel bundling or channel

107
00:05:36,849 --> 00:05:41,349
aggregation up to 5 to 20 megahertz

108
00:05:41,349 --> 00:05:44,229
channels into one logical 100 megahertz

109
00:05:44,229 --> 00:05:47,800
channel and at the higher bands like

110
00:05:47,800 --> 00:05:50,409
what's in discussion for 5g and also

111
00:05:50,409 --> 00:05:55,119
Wi-Fi ad you go channels which are more

112
00:05:55,119 --> 00:05:58,899
than a Giga gigahertz white like for

113
00:05:58,899 --> 00:06:03,369
example for for Wi-Fi ad I believe it's

114
00:06:03,369 --> 00:06:07,629
like 2.6 Giga Hertz your channel so you

115
00:06:07,629 --> 00:06:09,219
have to kind of like capture all this

116
00:06:09,219 --> 00:06:13,059
data and get it somewhere and another

117
00:06:13,059 --> 00:06:17,110
trend we're seeing is did the adoption

118
00:06:17,110 --> 00:06:19,269
of diversity transmitters and receivers

119
00:06:19,269 --> 00:06:23,849
and the most simplistic way this is

120
00:06:23,849 --> 00:06:26,889
curved like MIMO where you're just using

121
00:06:26,889 --> 00:06:30,039
it to gain diversity gain which means

122
00:06:30,039 --> 00:06:32,889
you have multiple antennas which are

123
00:06:32,889 --> 00:06:35,829
placed in a certain specific pattern so

124
00:06:35,829 --> 00:06:37,659
you can receive the same signal multiple

125
00:06:37,659 --> 00:06:40,629
times and if one of the signals get some

126
00:06:40,629 --> 00:06:43,119
kind of distortion you set things up so

127
00:06:43,119 --> 00:06:44,919
that the other one doesn't say you send

128
00:06:44,919 --> 00:06:46,899
can still recover your signal that

129
00:06:46,899 --> 00:06:49,139
you're sending but more and more

130
00:06:49,139 --> 00:06:51,749
wireless standards are actually

131
00:06:51,749 --> 00:06:55,539
designing support for diversity into the

132
00:06:55,539 --> 00:07:00,759
standard itself like with Wi-Fi AC you

133
00:07:00,759 --> 00:07:02,979
there's kind of like provisions for

134
00:07:02,979 --> 00:07:06,329
measuring the channel and making

135
00:07:06,329 --> 00:07:12,209
actually using the different multipath

136
00:07:12,209 --> 00:07:15,369
propagation of your signal as separate

137
00:07:15,369 --> 00:07:17,860
channels and for this of course you need

138
00:07:17,860 --> 00:07:19,959
diversity transmitters and receivers and

139
00:07:19,959 --> 00:07:22,240
for each transmitter and receiver you

140
00:07:22,240 --> 00:07:23,829
add to your system you're going to

141
00:07:23,829 --> 00:07:26,979
double your data rate or increase your

142
00:07:26,979 --> 00:07:29,919
data rate and the last trend that's

143
00:07:29,919 --> 00:07:31,749
becoming very important at the moment is

144
00:07:31,749 --> 00:07:35,460
direct RF which means you are

145
00:07:35,460 --> 00:07:37,860
no longer having your analog mixers wear

146
00:07:37,860 --> 00:07:39,270
you down modulating your signal of

147
00:07:39,270 --> 00:07:41,100
interest but you're capturing the whole

148
00:07:41,100 --> 00:07:44,310
spectrum up to your signal of interest

149
00:07:44,310 --> 00:07:48,800
like you capture 2 gigahertz 4 gigahertz

150
00:07:48,800 --> 00:07:52,620
maybe even more like 10 gigahertz at the

151
00:07:52,620 --> 00:07:54,870
same time and then do digital processing

152
00:07:54,870 --> 00:07:57,509
on it to extract your signal of interest

153
00:07:57,509 --> 00:08:00,300
and for certain applications they're

154
00:08:00,300 --> 00:08:03,419
just like kids gets you better results

155
00:08:03,419 --> 00:08:05,580
than doing doing this in the analog part

156
00:08:05,580 --> 00:08:09,840
of your designer so by but why does it

157
00:08:09,840 --> 00:08:11,759
mean that we actually need something

158
00:08:11,759 --> 00:08:14,160
like Jessie - Furby why can't we just

159
00:08:14,160 --> 00:08:16,440
keep on and continue what we had before

160
00:08:16,440 --> 00:08:21,570
and - like parallel busses and the issue

161
00:08:21,570 --> 00:08:24,180
is parallel buses you can they're two

162
00:08:24,180 --> 00:08:25,650
ways to increase your data throughput

163
00:08:25,650 --> 00:08:27,539
either increase the number of pins or

164
00:08:27,539 --> 00:08:30,030
increase the clock rate if you increase

165
00:08:30,030 --> 00:08:31,620
the number of pins you can send twice as

166
00:08:31,620 --> 00:08:33,839
much data if you double the clock rate

167
00:08:33,839 --> 00:08:36,899
you can send twice as much data more

168
00:08:36,899 --> 00:08:42,179
pins has the issue of routing so if you

169
00:08:42,179 --> 00:08:45,959
like you have 40 pins or even 60 pins it

170
00:08:45,959 --> 00:08:47,820
gets really complicated routing this all

171
00:08:47,820 --> 00:08:49,860
and you really have to kind of like hope

172
00:08:49,860 --> 00:08:51,959
that your receiver device is the same

173
00:08:51,959 --> 00:08:54,870
mapping as your transmitting device

174
00:08:54,870 --> 00:08:59,010
otherwise you have to kind of like do a

175
00:08:59,010 --> 00:09:01,200
lot of you need a lot of layers to be

176
00:09:01,200 --> 00:09:03,600
able to route it and the other issue the

177
00:09:03,600 --> 00:09:06,570
more lanes you have is the more power

178
00:09:06,570 --> 00:09:10,350
you use so power becomes also an issue

179
00:09:10,350 --> 00:09:14,399
at some point and the other thing is if

180
00:09:14,399 --> 00:09:17,279
you increase the clock rate you are

181
00:09:17,279 --> 00:09:20,700
running into the issue that for power

182
00:09:20,700 --> 00:09:23,010
for parallel bus you need to capture all

183
00:09:23,010 --> 00:09:25,470
your data at the same time right

184
00:09:25,470 --> 00:09:27,810
you have your clock and any of your data

185
00:09:27,810 --> 00:09:31,800
and both the clock has jitter the data

186
00:09:31,800 --> 00:09:33,660
has jitter the skew between the clock

187
00:09:33,660 --> 00:09:37,829
and the data and all of these catholic

188
00:09:37,829 --> 00:09:42,300
dependence different operating

189
00:09:42,300 --> 00:09:43,920
parameters they will change with the

190
00:09:43,920 --> 00:09:45,420
process with the voltage with the

191
00:09:45,420 --> 00:09:47,100
temperature and voltage here doesn't

192
00:09:47,100 --> 00:09:48,960
mean kind of like yet

193
00:09:48,960 --> 00:09:51,060
1.8 and 3.3 you will get different

194
00:09:51,060 --> 00:09:53,220
propagation delays it actually means

195
00:09:53,220 --> 00:09:55,430
that your power supply which has a

196
00:09:55,430 --> 00:10:00,210
uncertainty of like plus minus 10% even

197
00:10:00,210 --> 00:10:02,040
though it's set up for the same nominal

198
00:10:02,040 --> 00:10:05,400
voltage will introduce different SKUs

199
00:10:05,400 --> 00:10:09,270
and delays here and the higher up you go

200
00:10:09,270 --> 00:10:11,190
was your clock frequency the smaller

201
00:10:11,190 --> 00:10:13,290
this window will get and eventually

202
00:10:13,290 --> 00:10:16,880
simply becomes impossible to to match it

203
00:10:16,880 --> 00:10:19,740
so and this is where Jessie to 4b or

204
00:10:19,740 --> 00:10:23,250
Jessie to 4 comes into play and our

205
00:10:23,250 --> 00:10:25,440
quick overview of how such the system

206
00:10:25,440 --> 00:10:27,050
looks like

207
00:10:27,050 --> 00:10:29,840
you basically have four components

208
00:10:29,840 --> 00:10:32,790
there's the clock chip and the clock

209
00:10:32,790 --> 00:10:34,470
chip is connected to some kind of

210
00:10:34,470 --> 00:10:36,660
reference clock and then the clock chip

211
00:10:36,660 --> 00:10:39,150
will typically contain a PLL and a

212
00:10:39,150 --> 00:10:41,250
couple of clock dividers and the clock

213
00:10:41,250 --> 00:10:43,260
trip is responsible for generating all

214
00:10:43,260 --> 00:10:46,050
the clocks that are used inside your

215
00:10:46,050 --> 00:10:48,750
system and it's also responsible for

216
00:10:48,750 --> 00:10:51,320
creating a so-called sis ref signal

217
00:10:51,320 --> 00:10:53,690
which is used for synchronization

218
00:10:53,690 --> 00:10:57,750
between multiple devices and then up

219
00:10:57,750 --> 00:11:02,580
here you have your transmitter and on

220
00:11:02,580 --> 00:11:04,020
the other side you have a receiver and

221
00:11:04,020 --> 00:11:05,610
in between there's a high-speed serial

222
00:11:05,610 --> 00:11:07,290
link and as we discussed already that

223
00:11:07,290 --> 00:11:10,980
can be up to 32 lanes and there's one

224
00:11:10,980 --> 00:11:13,020
additional signals the so called sync

225
00:11:13,020 --> 00:11:15,930
signal synchronization signal and to

226
00:11:15,930 --> 00:11:20,880
establish a link what the receiver dust

227
00:11:20,880 --> 00:11:22,740
in the beginning it it puts the sync

228
00:11:22,740 --> 00:11:24,840
signal down and then the transmitter

229
00:11:24,840 --> 00:11:27,030
will send some kind of synchronization

230
00:11:27,030 --> 00:11:30,530
sequence and once synchronization has

231
00:11:30,530 --> 00:11:33,150
completed the receiver has locked onto

232
00:11:33,150 --> 00:11:35,130
the signal that's being sent here it

233
00:11:35,130 --> 00:11:37,680
will dear serve the same signal and the

234
00:11:37,680 --> 00:11:39,120
transmitter will start sending their

235
00:11:39,120 --> 00:11:43,050
data but in addition to this the sync

236
00:11:43,050 --> 00:11:46,080
signal can also be used once the link

237
00:11:46,080 --> 00:11:47,850
has been established to do error

238
00:11:47,850 --> 00:11:50,250
reporting so if something goes wrong if

239
00:11:50,250 --> 00:11:52,830
the data is no longer good if there lots

240
00:11:52,830 --> 00:11:55,170
of errors the receiver can assert the

241
00:11:55,170 --> 00:11:58,140
same signal for one clock cycle to tell

242
00:11:58,140 --> 00:11:59,760
the receiver at a transmitter that

243
00:11:59,760 --> 00:12:01,800
something's wrong and maybe it's time

244
00:12:01,800 --> 00:12:02,790
for reinitialize

245
00:12:02,790 --> 00:12:06,690
not the link right and there are two

246
00:12:06,690 --> 00:12:08,460
different classes of transmitters and

247
00:12:08,460 --> 00:12:10,260
receivers there's the so-called

248
00:12:10,260 --> 00:12:12,720
converter devices and the logic devices

249
00:12:12,720 --> 00:12:14,460
and the converter devices are your ADC

250
00:12:14,460 --> 00:12:15,330
HDACs

251
00:12:15,330 --> 00:12:17,970
and so on and the logic device is the

252
00:12:17,970 --> 00:12:22,020
processing and in addition to this as I

253
00:12:22,020 --> 00:12:23,700
said Jessie not only defines the

254
00:12:23,700 --> 00:12:25,890
physical link layer but it also does a

255
00:12:25,890 --> 00:12:28,110
lot of other stuff and the standard

256
00:12:28,110 --> 00:12:29,850
defines four different layers first of

257
00:12:29,850 --> 00:12:31,710
all the application layer well the

258
00:12:31,710 --> 00:12:34,290
application specific processing happens

259
00:12:34,290 --> 00:12:37,410
and since this is application specific

260
00:12:37,410 --> 00:12:39,390
there's obviously nothing understand

261
00:12:39,390 --> 00:12:41,130
that it says what needs to be done here

262
00:12:41,130 --> 00:12:44,370
but what the standard defines is the

263
00:12:44,370 --> 00:12:46,350
interface between the application layer

264
00:12:46,350 --> 00:12:48,810
and the underlying layer which is a

265
00:12:48,810 --> 00:12:51,150
transport layer and what the transport

266
00:12:51,150 --> 00:12:53,580
layer does it's responsible for the so

267
00:12:53,580 --> 00:12:56,520
called sample framing and also Lane

268
00:12:56,520 --> 00:12:58,500
mapping this means it takes the raw

269
00:12:58,500 --> 00:13:03,390
sample data and packs it into in a

270
00:13:03,390 --> 00:13:06,150
certain way that everybody agrees on all

271
00:13:06,150 --> 00:13:09,630
jsd to 4b devices agree on and then

272
00:13:09,630 --> 00:13:13,560
distributes this data onto the different

273
00:13:13,560 --> 00:13:15,810
lanes and then the next layer is the

274
00:13:15,810 --> 00:13:18,540
link layer and the link layer is her

275
00:13:18,540 --> 00:13:22,440
lane so from the transport layer the

276
00:13:22,440 --> 00:13:24,210
transport layer will pass so-called

277
00:13:24,210 --> 00:13:27,390
octet which is 8 bytes of data or 8 bits

278
00:13:27,390 --> 00:13:29,490
of this or 8 bits of data to the link

279
00:13:29,490 --> 00:13:31,080
layer and the link layer will do some

280
00:13:31,080 --> 00:13:32,700
some processing like scrambling

281
00:13:32,700 --> 00:13:34,880
scrambler data it will do the so-called

282
00:13:34,880 --> 00:13:39,300
character replacement which we will talk

283
00:13:39,300 --> 00:13:42,270
about in a moment and it will also do 8

284
00:13:42,270 --> 00:13:45,150
B 10 B encoding and then at the physical

285
00:13:45,150 --> 00:13:47,420
layer we have really the high-speed

286
00:13:47,420 --> 00:13:52,170
serial interface and this typically

287
00:13:52,170 --> 00:13:54,510
involves the conversion from parallel

288
00:13:54,510 --> 00:13:56,340
data into serial data and on the

289
00:13:56,340 --> 00:13:57,930
receiving side you also do clock

290
00:13:57,930 --> 00:14:00,060
recovery and often you also include

291
00:14:00,060 --> 00:14:04,770
signal shaping because at 12.5 Giga bits

292
00:14:04,770 --> 00:14:05,580
per second

293
00:14:05,580 --> 00:14:07,070
your transmission line is really

294
00:14:07,070 --> 00:14:10,519
transmission line it's no longer

295
00:14:10,519 --> 00:14:13,709
normal data so you need to do some

296
00:14:13,709 --> 00:14:16,769
signal shaping and yeah so let's talk

297
00:14:16,769 --> 00:14:18,300
about the converter device the converter

298
00:14:18,300 --> 00:14:21,509
device the tube is different kinds

299
00:14:21,509 --> 00:14:22,829
there's the ADC device and the DAC

300
00:14:22,829 --> 00:14:26,430
device and so first of all the converter

301
00:14:26,430 --> 00:14:28,560
device can contain multiple converters

302
00:14:28,560 --> 00:14:33,540
and typically in modern converter

303
00:14:33,540 --> 00:14:35,610
devices in addition to just the data

304
00:14:35,610 --> 00:14:36,990
conversion there's some kind of

305
00:14:36,990 --> 00:14:40,860
processing and here is basically the

306
00:14:40,860 --> 00:14:44,060
split where the gst/hst layer starts

307
00:14:44,060 --> 00:14:47,100
first of all we got the framer which

308
00:14:47,100 --> 00:14:49,440
works over all data and then distributes

309
00:14:49,440 --> 00:14:51,360
the data on to each lane and typically

310
00:14:51,360 --> 00:14:53,490
you also have a PLL in there to generate

311
00:14:53,490 --> 00:14:58,350
the clock for for the high speed steel

312
00:14:58,350 --> 00:15:01,139
link and on the receiver side on the

313
00:15:01,139 --> 00:15:03,779
deck side it's basically the same you

314
00:15:03,779 --> 00:15:06,089
have one lane or you have your lane

315
00:15:06,089 --> 00:15:08,160
specific processing then it goes into

316
00:15:08,160 --> 00:15:10,740
the D frame and the D framer distributes

317
00:15:10,740 --> 00:15:12,449
it to all the converters to all the

318
00:15:12,449 --> 00:15:15,959
decks and what's important is that all

319
00:15:15,959 --> 00:15:19,350
those ADCs and DACs inside one device

320
00:15:19,350 --> 00:15:22,589
are all running synchronous and logic

321
00:15:22,589 --> 00:15:24,440
device looks basically the same like

322
00:15:24,440 --> 00:15:27,569
except that instead of having your

323
00:15:27,569 --> 00:15:30,959
converters here you have a huge block of

324
00:15:30,959 --> 00:15:35,430
custom processing and the one special

325
00:15:35,430 --> 00:15:37,290
thing about the logic device is that one

326
00:15:37,290 --> 00:15:39,089
logic device can actually interface the

327
00:15:39,089 --> 00:15:41,279
multiple converter devices the so-called

328
00:15:41,279 --> 00:15:43,889
multi-point link for example you need

329
00:15:43,889 --> 00:15:46,350
for a DC's but your converter device

330
00:15:46,350 --> 00:15:48,959
only has 286 so you can take two of

331
00:15:48,959 --> 00:15:51,990
those and combine them into one logical

332
00:15:51,990 --> 00:15:54,889
converter device which has four ATC's

333
00:15:54,889 --> 00:15:58,079
then the link so as already said the

334
00:15:58,079 --> 00:15:59,550
link consists of multiple independent

335
00:15:59,550 --> 00:16:04,290
lanes and on the on the physical level

336
00:16:04,290 --> 00:16:06,209
you use this differential current mode

337
00:16:06,209 --> 00:16:08,250
logic it's kind of like LVDS but a

338
00:16:08,250 --> 00:16:10,230
little bit more power to be able to

339
00:16:10,230 --> 00:16:12,990
handle the high speeds and it has an

340
00:16:12,990 --> 00:16:14,970
embedded clock rather than a separate

341
00:16:14,970 --> 00:16:17,339
clock this way you no longer have to

342
00:16:17,339 --> 00:16:19,290
deal with this clock and data meshing

343
00:16:19,290 --> 00:16:22,500
and as I said it does the data

344
00:16:22,500 --> 00:16:23,560
scrambling and the data

345
00:16:23,560 --> 00:16:25,630
Grambling is optional but it's highly

346
00:16:25,630 --> 00:16:29,080
recommended because if you turn off data

347
00:16:29,080 --> 00:16:31,750
scrambling you kind of like your data

348
00:16:31,750 --> 00:16:34,270
might contain certain patterns and this

349
00:16:34,270 --> 00:16:36,910
will result in certain Spurs which will

350
00:16:36,910 --> 00:16:39,190
then show up in your actual data so

351
00:16:39,190 --> 00:16:41,410
that's why the data scrambling should

352
00:16:41,410 --> 00:16:43,690
pretty much always be enabled and also

353
00:16:43,690 --> 00:16:46,510
the CDR kind of expects data scrambling

354
00:16:46,510 --> 00:16:52,060
to be neighbors yeah and a link or Lane

355
00:16:52,060 --> 00:16:53,890
has a couple of parameters there are

356
00:16:53,890 --> 00:16:54,580
lots of them

357
00:16:54,580 --> 00:16:56,140
even more than what's shown on the slide

358
00:16:56,140 --> 00:16:58,600
I don't want to go into detail of all of

359
00:16:58,600 --> 00:17:01,630
them but you can see there's a lot of

360
00:17:01,630 --> 00:17:03,580
lots of things which can be configured

361
00:17:03,580 --> 00:17:06,520
which tell the sender and the receiver

362
00:17:06,520 --> 00:17:09,790
how the data is sent over the link yeah

363
00:17:09,790 --> 00:17:11,380
let's talk about deterministic latency

364
00:17:11,380 --> 00:17:16,959
quickly so propagating data over link

365
00:17:16,959 --> 00:17:19,959
takes time like you might have pipeline

366
00:17:19,959 --> 00:17:23,199
delay and also propagating the signal

367
00:17:23,199 --> 00:17:25,839
from A to B over your transmission line

368
00:17:25,839 --> 00:17:30,310
takes time and this time or so part of

369
00:17:30,310 --> 00:17:31,740
this is fixed you know how many

370
00:17:31,740 --> 00:17:34,390
pipelines like UCF but part of this is

371
00:17:34,390 --> 00:17:37,960
also kind of like variable and depends

372
00:17:37,960 --> 00:17:39,520
on manufacturing differences and

373
00:17:39,520 --> 00:17:41,650
environmental conditions again process

374
00:17:41,650 --> 00:17:44,080
voltage temperature and there are

375
00:17:44,080 --> 00:17:46,510
certain systems and algorithms that are

376
00:17:46,510 --> 00:17:49,210
very latency sensitive for example

377
00:17:49,210 --> 00:17:51,270
closed loop control system where you

378
00:17:51,270 --> 00:17:53,650
transmit something then measure it and

379
00:17:53,650 --> 00:17:57,820
then adopt your transmit based on this

380
00:17:57,820 --> 00:18:00,940
like DPD and there are an oscillator

381
00:18:00,940 --> 00:18:03,130
where you want to measure the runtime

382
00:18:03,130 --> 00:18:05,770
difference between two signals a very is

383
00:18:05,770 --> 00:18:10,270
very yeah dependent on on on latency so

384
00:18:10,270 --> 00:18:11,800
ideally you always want to have the same

385
00:18:11,800 --> 00:18:16,450
latency and the way Jessie does this it

386
00:18:16,450 --> 00:18:18,760
does not remove the latency from the

387
00:18:18,760 --> 00:18:22,300
system but it compensates for it and the

388
00:18:22,300 --> 00:18:24,040
way this works just a so-called local

389
00:18:24,040 --> 00:18:26,110
multiframe clock which is kind of like a

390
00:18:26,110 --> 00:18:28,390
slower version of the frame clock can be

391
00:18:28,390 --> 00:18:31,570
yes kind of like a local clock so it

392
00:18:31,570 --> 00:18:33,790
slow clock generated inside the device

393
00:18:33,790 --> 00:18:36,830
and all events there

394
00:18:36,830 --> 00:18:41,270
our deal of is synchronizing things are

395
00:18:41,270 --> 00:18:42,650
synchronized to this local

396
00:18:42,650 --> 00:18:45,350
multi-frame clock and how it works is

397
00:18:45,350 --> 00:18:48,020
first the receiver serves to sing pin

398
00:18:48,020 --> 00:18:50,000
idea sources inkman which means it's

399
00:18:50,000 --> 00:18:52,190
ready to receive data then the on the

400
00:18:52,190 --> 00:18:54,440
next clock the TX starts sending data

401
00:18:54,440 --> 00:18:56,630
and it will take a little bit of time

402
00:18:56,630 --> 00:19:00,380
until the data reaches the receiver and

403
00:19:00,380 --> 00:19:04,060
there's also a certain amount of

404
00:19:04,060 --> 00:19:09,440
variants in how long it takes and the

405
00:19:09,440 --> 00:19:13,010
way Jesse makes sure that your latency

406
00:19:13,010 --> 00:19:15,140
is always the same it uses kind of like

407
00:19:15,140 --> 00:19:17,960
a FIFO and it delays the data until the

408
00:19:17,960 --> 00:19:20,240
release opportunity so it doesn't matter

409
00:19:20,240 --> 00:19:22,340
whether the data arrives here or here

410
00:19:22,340 --> 00:19:25,460
the first sample that will be released

411
00:19:25,460 --> 00:19:28,100
to the application layer will be at this

412
00:19:28,100 --> 00:19:32,630
release opportunity yeah and for this to

413
00:19:32,630 --> 00:19:35,000
work of course your variants needs to be

414
00:19:35,000 --> 00:19:39,100
less than one locomotive frame clock and

415
00:19:39,100 --> 00:19:42,260
let's quickly talk about data integrity

416
00:19:42,260 --> 00:19:48,140
so 8p 10b allows some detection of a few

417
00:19:48,140 --> 00:19:55,340
simple errors but not so many and what

418
00:19:55,340 --> 00:19:56,840
the standard defines is if an error is

419
00:19:56,840 --> 00:19:58,160
detected it should actually be placed

420
00:19:58,160 --> 00:20:00,140
with the data of the previous frame but

421
00:20:00,140 --> 00:20:04,130
what many implementations do is they

422
00:20:04,130 --> 00:20:06,560
just assert some kind of error signal

423
00:20:06,560 --> 00:20:10,520
error flag because from a processing

424
00:20:10,520 --> 00:20:12,470
point of view it's better to know that

425
00:20:12,470 --> 00:20:15,080
you got an error rather than replacing

426
00:20:15,080 --> 00:20:17,660
your data as random data but there's no

427
00:20:17,660 --> 00:20:20,030
additional data protection like no CRC

428
00:20:20,030 --> 00:20:21,350
or forward error correction on the link

429
00:20:21,350 --> 00:20:24,230
itself and if you look at what kind of

430
00:20:24,230 --> 00:20:28,310
data jesse is actually transporting so

431
00:20:28,310 --> 00:20:30,650
it's it's not very like kind of like

432
00:20:30,650 --> 00:20:33,140
high fidelity you have your DAC which

433
00:20:33,140 --> 00:20:35,840
will do digital to analog conversion

434
00:20:35,840 --> 00:20:39,440
which is a noisy process on the receiver

435
00:20:39,440 --> 00:20:41,810
side you have an ADC which does analog

436
00:20:41,810 --> 00:20:43,970
to digital conversion which has a noisy

437
00:20:43,970 --> 00:20:45,440
process there's always background noise

438
00:20:45,440 --> 00:20:48,470
which kind of like effects your data and

439
00:20:48,470 --> 00:20:50,630
then of course you all know the RF

440
00:20:50,630 --> 00:20:52,520
the RF channel is kind of like the worst

441
00:20:52,520 --> 00:20:54,920
thing you have lots of interference that

442
00:20:54,920 --> 00:20:59,600
will flip it destroy bits whatever and

443
00:20:59,600 --> 00:21:03,860
so what the Jessie Ling has to offer or

444
00:21:03,860 --> 00:21:06,110
needs to office just needs to be better

445
00:21:06,110 --> 00:21:10,310
than all of this the bits bit flips that

446
00:21:10,310 --> 00:21:11,870
are introduced at this level need to be

447
00:21:11,870 --> 00:21:14,510
the noise floor of of this part because

448
00:21:14,510 --> 00:21:17,150
the upper layers will already know how

449
00:21:17,150 --> 00:21:20,770
to deal with certain kinds of errors

450
00:21:20,770 --> 00:21:25,420
let's get this so you software support

451
00:21:25,420 --> 00:21:27,620
since Jessie it's kind of like a

452
00:21:27,620 --> 00:21:30,580
standard you might expect there's are

453
00:21:30,580 --> 00:21:32,830
really great software infrastructure

454
00:21:32,830 --> 00:21:35,630
based on top of this but the current

455
00:21:35,630 --> 00:21:38,330
situation is not so great there's no

456
00:21:38,330 --> 00:21:40,730
common infrastructure and typically the

457
00:21:40,730 --> 00:21:42,350
system integrator the guy who puts

458
00:21:42,350 --> 00:21:45,500
together the converters and puts them on

459
00:21:45,500 --> 00:21:48,020
to the PCB and maybe write some software

460
00:21:48,020 --> 00:21:51,230
needs to research all the constraints of

461
00:21:51,230 --> 00:21:53,560
all the different system components

462
00:21:53,560 --> 00:21:55,970
different converters different logic

463
00:21:55,970 --> 00:21:57,860
devices have different constraints for

464
00:21:57,860 --> 00:21:59,000
these parameters that I showed before

465
00:21:59,000 --> 00:22:02,390
and so you have to go into these data

466
00:22:02,390 --> 00:22:04,370
sheets and figure out how does all of

467
00:22:04,370 --> 00:22:07,040
this work and find a configuration that

468
00:22:07,040 --> 00:22:08,720
works for all of them and then you have

469
00:22:08,720 --> 00:22:10,310
to look up the magic register values

470
00:22:10,310 --> 00:22:13,430
that map to those settings and program

471
00:22:13,430 --> 00:22:17,180
them and typically the application

472
00:22:17,180 --> 00:22:19,250
developer the software-defined radio

473
00:22:19,250 --> 00:22:22,430
person has to work with what's provided

474
00:22:22,430 --> 00:22:25,690
from the system integrator because

475
00:22:25,690 --> 00:22:30,470
changing this is very it's a big hassle

476
00:22:30,470 --> 00:22:35,060
and we're trying to change this with the

477
00:22:35,060 --> 00:22:37,660
development of the little jest e24 and

478
00:22:37,660 --> 00:22:39,830
the way it works it has a built-in

479
00:22:39,830 --> 00:22:42,560
database of all the converter devices

480
00:22:42,560 --> 00:22:48,320
logic devices and so on and all the

481
00:22:48,320 --> 00:22:50,900
constraints that are imposed by those

482
00:22:50,900 --> 00:22:54,260
devices and those rules or this database

483
00:22:54,260 --> 00:22:56,210
is not kind of like a database with a B

484
00:22:56,210 --> 00:22:59,240
like this suppose one Lane two lanes and

485
00:22:59,240 --> 00:23:01,450
so on but this rather a database of

486
00:23:01,450 --> 00:23:04,429
programmatic rules where you specify

487
00:23:04,429 --> 00:23:10,009
relationships and and then the system

488
00:23:10,009 --> 00:23:11,869
integrator only needs to specify in

489
00:23:11,869 --> 00:23:13,820
addition to the constraints that are

490
00:23:13,820 --> 00:23:15,100
already found in this database

491
00:23:15,100 --> 00:23:19,369
constraints of his board like for

492
00:23:19,369 --> 00:23:20,990
example a converter might support eight

493
00:23:20,990 --> 00:23:22,789
lanes but only four lanes are wired up

494
00:23:22,789 --> 00:23:28,429
on a certain system and then the

495
00:23:28,429 --> 00:23:30,980
application developer can dynamically

496
00:23:30,980 --> 00:23:33,649
change the configuration at runtime for

497
00:23:33,649 --> 00:23:35,779
examples change December 8 and I think

498
00:23:35,779 --> 00:23:37,549
this Tizen was the talk we've seen

499
00:23:37,549 --> 00:23:41,090
before because people want to get stuff

500
00:23:41,090 --> 00:23:42,590
done they don't want to care about all

501
00:23:42,590 --> 00:23:44,389
this low-level stuff they want to build

502
00:23:44,389 --> 00:23:46,490
a software defined radio applications

503
00:23:46,490 --> 00:23:51,169
and hopefully what this lip test a true

504
00:23:51,169 --> 00:23:53,779
for will provides will be able to

505
00:23:53,779 --> 00:23:56,869
achieve this and the other part the lip

506
00:23:56,869 --> 00:23:58,639
will do it will automatically map a

507
00:23:58,639 --> 00:24:01,249
configuration to register settings and

508
00:24:01,249 --> 00:24:15,379
that's it questions or yeah yeah so

509
00:24:15,379 --> 00:24:20,240
there's the M labs open source

510
00:24:20,240 --> 00:24:22,009
implementation of the Jessie to offer B

511
00:24:22,009 --> 00:24:27,019
core it's written in in my again yeah

512
00:24:27,019 --> 00:24:29,029
it's kind of like a special language you

513
00:24:29,029 --> 00:24:31,249
it's like Python maybe a little bit like

514
00:24:31,249 --> 00:24:38,629
my HDL but different and they provide an

515
00:24:38,629 --> 00:24:43,909
open source core and let's see this one

516
00:24:43,909 --> 00:24:45,740
will also be available soon it's

517
00:24:45,740 --> 00:24:49,360
something we've been working on it's

518
00:24:49,360 --> 00:24:53,149
yeah the complete transmit and receive

519
00:24:53,149 --> 00:24:56,840
course implemented in the FPGA when the

520
00:24:56,840 --> 00:25:00,200
independent way and it will it's not

521
00:25:00,200 --> 00:25:01,879
quite ready yet but it will in the next

522
00:25:01,879 --> 00:25:03,710
two weeks appear on our github

523
00:25:03,710 --> 00:25:09,889
repository say yeah that's thing one

524
00:25:09,889 --> 00:25:16,240
personally what core

525
00:25:18,279 --> 00:25:21,929
I know that they're using our chips yes

526
00:25:21,929 --> 00:25:25,570
okay so the question is has DM lab core

527
00:25:25,570 --> 00:25:28,179
been tested with the ADI converters and

528
00:25:28,179 --> 00:25:30,279
yes it has been they're using a TI

529
00:25:30,279 --> 00:26:01,690
converters this one is open source so

530
00:26:01,690 --> 00:26:02,950
there's a so-called initial line

531
00:26:02,950 --> 00:26:06,159
alignment sequence and in this Lane

532
00:26:06,159 --> 00:26:08,589
alignment sequence you send the full

533
00:26:08,589 --> 00:26:11,849
configuration parameters over the link

534
00:26:11,849 --> 00:26:15,669
but typically you also program them on

535
00:26:15,669 --> 00:26:18,639
both sides but if you had hardware which

536
00:26:18,639 --> 00:26:20,529
supported this you could do it this way

537
00:26:20,529 --> 00:26:22,749
so typically there's a second channel

538
00:26:22,749 --> 00:26:24,639
for configuration using spy or y-square

539
00:26:24,639 --> 00:26:46,029
see any one question away sorry yes it

540
00:26:46,029 --> 00:26:48,820
could be but the standard explicitly

541
00:26:48,820 --> 00:26:51,369
forbids this sorry the question is can

542
00:26:51,369 --> 00:26:54,429
you use a recovered clock to run the

543
00:26:54,429 --> 00:26:56,229
device itself rather than distributing a

544
00:26:56,229 --> 00:26:58,179
separate clock to the device yes you can

545
00:26:58,179 --> 00:26:59,979
but then you don't get the domestic

546
00:26:59,979 --> 00:27:02,049
deterministic latency because your

547
00:27:02,049 --> 00:27:03,609
recover clock will have kind of like

548
00:27:03,609 --> 00:27:07,419
random phase depending because you have

549
00:27:07,419 --> 00:27:10,960
that because you recover the high high

550
00:27:10,960 --> 00:27:12,279
rate clock and then you create a Down

551
00:27:12,279 --> 00:27:15,460
divided clock for the parallel section

552
00:27:15,460 --> 00:27:17,289
of your processing and the parallels

553
00:27:17,289 --> 00:27:19,210
like the parallel clock will have random

554
00:27:19,210 --> 00:27:23,399
face to your transmitted parallel clock

555
00:27:31,570 --> 00:27:36,620
then we can talk about this later think

556
00:27:36,620 --> 00:27:39,850
that's one more question

557
00:27:39,940 --> 00:27:50,720
what's one over there so the question is

558
00:27:50,720 --> 00:27:54,470
if if the latency is mandatory in the

559
00:27:54,470 --> 00:27:57,380
Senate and the answer is no I mentioned

560
00:27:57,380 --> 00:27:58,790
this quickly in the beginning of three

561
00:27:58,790 --> 00:28:00,560
different subclasses to subclass zero

562
00:28:00,560 --> 00:28:03,280
and subclass zero basically just says

563
00:28:03,280 --> 00:28:06,620
instead of having this release

564
00:28:06,620 --> 00:28:11,870
opportunity just release the data when

565
00:28:11,870 --> 00:28:15,890
the last lane arrives okay that's it

566
00:28:15,890 --> 00:28:17,190
thank you very much

567
00:28:17,190 --> 00:28:22,369
[Applause]

