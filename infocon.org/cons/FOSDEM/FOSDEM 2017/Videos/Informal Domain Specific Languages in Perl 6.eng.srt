1
00:00:04,550 --> 00:00:06,800
all right so I'll go ahead and start my

2
00:00:06,800 --> 00:00:08,840
name is Brian Duggan and I'll be talking

3
00:00:08,840 --> 00:00:11,410
today about informal domain-specific

4
00:00:11,410 --> 00:00:14,180
languages in Perl six

5
00:00:14,180 --> 00:00:16,520
thank you all for coming and attending

6
00:00:16,520 --> 00:00:21,050
this talk I hope you like it a little

7
00:00:21,050 --> 00:00:22,640
bit about my company I'd like to thank

8
00:00:22,640 --> 00:00:24,470
prompt works for sending me here

9
00:00:24,470 --> 00:00:26,110
we're a consulting company in

10
00:00:26,110 --> 00:00:29,869
Philadelphia we do coding and a lot of

11
00:00:29,869 --> 00:00:32,479
different languages for large and small

12
00:00:32,479 --> 00:00:38,410
companies okay so this talk is about

13
00:00:38,410 --> 00:00:42,320
domain-specific languages or dsls but

14
00:00:42,320 --> 00:00:44,359
first I want to clarify the informal in

15
00:00:44,359 --> 00:00:46,969
the title of the talk so if you look for

16
00:00:46,969 --> 00:00:49,910
the definition of dsl on Wikipedia

17
00:00:49,910 --> 00:00:52,219
you'll see a lot of languages like HTML

18
00:00:52,219 --> 00:00:56,449
or SQL these are all dsls there are

19
00:00:56,449 --> 00:00:57,679
languages that are focused on a

20
00:00:57,679 --> 00:01:01,519
particular domain but there are not the

21
00:01:01,519 --> 00:01:03,679
DSL has also come to be used in a lot of

22
00:01:03,679 --> 00:01:07,280
other ways so when these days when

23
00:01:07,280 --> 00:01:08,540
you're writing an application that

24
00:01:08,540 --> 00:01:11,450
generates HTML you'll have your own

25
00:01:11,450 --> 00:01:15,550
language that generates this other

26
00:01:21,470 --> 00:01:23,530
you

27
00:01:25,159 --> 00:01:31,280
yes and the results there are often they

28
00:01:31,280 --> 00:01:33,680
don't have specifications even though

29
00:01:33,680 --> 00:01:35,810
they're languages there are restricted

30
00:01:35,810 --> 00:01:38,570
to small communities and they change a

31
00:01:38,570 --> 00:01:40,969
lot but they're very practical and there

32
00:01:40,969 --> 00:01:42,259
are the things that you type by hand

33
00:01:42,259 --> 00:01:46,939
when you're writing programs a few

34
00:01:46,939 --> 00:01:50,090
examples so templating languages if you

35
00:01:50,090 --> 00:01:52,509
look on

36
00:02:07,409 --> 00:02:11,340
up markdown there's you know Wikipedia's

37
00:02:11,340 --> 00:02:14,670
markdown for SQL generation we have ORM

38
00:02:14,670 --> 00:02:17,160
s there are also a lot in different

39
00:02:17,160 --> 00:02:20,370
languages in Brawl there's DB IX class

40
00:02:20,370 --> 00:02:23,970
or Rose then in Python SQL alchemy and

41
00:02:23,970 --> 00:02:26,910
Ruby there's air Erol and these are all

42
00:02:26,910 --> 00:02:30,209
ways of avoiding writing SQL but you

43
00:02:30,209 --> 00:02:32,010
still have their own little isolated

44
00:02:32,010 --> 00:02:36,209
informal DSL in these to generate these

45
00:02:36,209 --> 00:02:39,000
languages web micro frameworks are

46
00:02:39,000 --> 00:02:41,730
another example the acute syntax that

47
00:02:41,730 --> 00:02:43,470
you use to generate your routes where

48
00:02:43,470 --> 00:02:45,690
you say get this post that and it

49
00:02:45,690 --> 00:02:47,640
generates routes those are also informal

50
00:02:47,640 --> 00:02:55,769
dsls so in 2010 martin fowler wrote a

51
00:02:55,769 --> 00:02:56,879
book called done domain-specific

52
00:02:56,879 --> 00:02:59,450
languages and he brought me broken he

53
00:02:59,450 --> 00:03:01,019
divided them into two different

54
00:03:01,019 --> 00:03:03,500
categories internal and external

55
00:03:03,500 --> 00:03:07,319
internal dsls are languages that are a

56
00:03:07,319 --> 00:03:09,720
subset of a more general programming

57
00:03:09,720 --> 00:03:13,709
language and external ones are languages

58
00:03:13,709 --> 00:03:15,510
where you're actually parsing it so you

59
00:03:15,510 --> 00:03:17,430
have some sort of parser but it's not

60
00:03:17,430 --> 00:03:20,849
just a subset of a Python or subset of

61
00:03:20,849 --> 00:03:24,389
Ruby I'm adding a third category to this

62
00:03:24,389 --> 00:03:27,389
talk which I'm calling variant dsls and

63
00:03:27,389 --> 00:03:30,660
these are languages that start off as a

64
00:03:30,660 --> 00:03:33,120
more common language but you modify it a

65
00:03:33,120 --> 00:03:35,519
little bit and in perl 6 there's a

66
00:03:35,519 --> 00:03:37,889
notion of slangs which refers to this

67
00:03:37,889 --> 00:03:40,609
concept

68
00:03:41,340 --> 00:03:44,300
so for each of these categories

69
00:03:44,300 --> 00:03:46,530
internal/external invariant I'm going to

70
00:03:46,530 --> 00:03:50,550
talk about a Perl 6 technique that can

71
00:03:50,550 --> 00:03:56,340
be used to create informal dsls in this

72
00:03:56,340 --> 00:03:59,519
category will start with internal pick

73
00:03:59,519 --> 00:04:02,489
an example from each one and then an

74
00:04:02,489 --> 00:04:05,450
application of the technique to generate

75
00:04:05,450 --> 00:04:10,470
a language ok so we'll start with

76
00:04:10,470 --> 00:04:13,019
internal informal domain-specific

77
00:04:13,019 --> 00:04:17,160
languages so mouthful okay and what

78
00:04:17,160 --> 00:04:19,139
we're gonna talk about are the Perl 6

79
00:04:19,139 --> 00:04:24,930
custom operators facilities ok so a

80
00:04:24,930 --> 00:04:28,050
quick review and explanation of the

81
00:04:28,050 --> 00:04:29,850
different types of operators that you

82
00:04:29,850 --> 00:04:31,560
see these are the types of operators in

83
00:04:31,560 --> 00:04:34,229
Perl 6 you have infix operators which

84
00:04:34,229 --> 00:04:37,139
have their arguments on the side you

85
00:04:37,139 --> 00:04:39,570
have prefix operators like the - in this

86
00:04:39,570 --> 00:04:42,320
case goes before what it's operating on

87
00:04:42,320 --> 00:04:45,330
you also have postfix like a plus plus

88
00:04:45,330 --> 00:04:47,690
which operates on the thing before it

89
00:04:47,690 --> 00:04:50,910
circum fix R around something and post

90
00:04:50,910 --> 00:04:53,010
circum fix you know like taking in it

91
00:04:53,010 --> 00:04:55,200
taking something out of an array so

92
00:04:55,200 --> 00:04:57,360
these are all the different types of

93
00:04:57,360 --> 00:04:59,910
operators and you can see that some of

94
00:04:59,910 --> 00:05:01,530
them take one argument some of them take

95
00:05:01,530 --> 00:05:04,200
two arguments right so the in fix + or

96
00:05:04,200 --> 00:05:06,720
sorry the prefix of the postfix each

97
00:05:06,720 --> 00:05:09,690
take only one argument after all they're

98
00:05:09,690 --> 00:05:13,530
really just functions and circum fix

99
00:05:13,530 --> 00:05:16,289
takes one argument in fix and post

100
00:05:16,289 --> 00:05:19,039
circum fix take two arguments

101
00:05:19,039 --> 00:05:22,229
so already even though you can write a

102
00:05:22,229 --> 00:05:26,160
plus b you can also use operators in

103
00:05:26,160 --> 00:05:28,560
what's called a noun form so if you take

104
00:05:28,560 --> 00:05:29,880
the plus and you put some brackets

105
00:05:29,880 --> 00:05:32,070
around it and you put an ampersand in

106
00:05:32,070 --> 00:05:34,620
front of it then instantly you've turned

107
00:05:34,620 --> 00:05:36,000
your operator into a function that takes

108
00:05:36,000 --> 00:05:38,310
two arguments

109
00:05:38,310 --> 00:05:41,030
and conversely you can go the other way

110
00:05:41,030 --> 00:05:43,860
so if you have any subroutine that takes

111
00:05:43,860 --> 00:05:45,930
two arguments you will automatically

112
00:05:45,930 --> 00:05:48,750
have it in fix operator so here we have

113
00:05:48,750 --> 00:05:51,090
an example of saying we make a

114
00:05:51,090 --> 00:05:53,310
subroutine called plus twice which takes

115
00:05:53,310 --> 00:05:56,130
the first argument and adds two times

116
00:05:56,130 --> 00:05:59,040
the second argument and you can call it

117
00:05:59,040 --> 00:06:01,410
with the arguments afterwards but you

118
00:06:01,410 --> 00:06:04,080
can also put an ampersand in front of it

119
00:06:04,080 --> 00:06:05,760
put brackets around it and then you can

120
00:06:05,760 --> 00:06:10,560
say one plus twice two so out of the box

121
00:06:10,560 --> 00:06:12,480
without doing anything crazy you already

122
00:06:12,480 --> 00:06:16,290
have some interesting constructs for any

123
00:06:16,290 --> 00:06:19,790
subroutine that takes two arguments

124
00:06:22,020 --> 00:06:24,760
but of course what you really want to do

125
00:06:24,760 --> 00:06:27,790
is take symbols and use those as

126
00:06:27,790 --> 00:06:29,080
arguments you don't want to put brackets

127
00:06:29,080 --> 00:06:31,540
and ampersand everywhere and to do that

128
00:06:31,540 --> 00:06:34,990
you can define an operator using this

129
00:06:34,990 --> 00:06:38,890
syntax so we say sub in fix colon and

130
00:06:38,890 --> 00:06:40,450
then less than and then the operator

131
00:06:40,450 --> 00:06:42,310
goes in between the angle brackets and

132
00:06:42,310 --> 00:06:44,770
then you say the operators so if we want

133
00:06:44,770 --> 00:06:47,290
to say I'd like to use the word plus to

134
00:06:47,290 --> 00:06:49,870
add two things together we say sub in

135
00:06:49,870 --> 00:06:53,640
fix plus and it returns X plus y and

136
00:06:53,640 --> 00:07:01,380
then you can say 1 plus 2 and you get 3

137
00:07:01,380 --> 00:07:06,070
so you can do other things too let's say

138
00:07:06,070 --> 00:07:08,050
you want to make a prefix operator a TAS

139
00:07:08,050 --> 00:07:10,930
or plus or postfix operator plus plus

140
00:07:10,930 --> 00:07:14,020
plus okay which modifies the argument

141
00:07:14,020 --> 00:07:17,440
then adds 3 to it so here we have Z

142
00:07:17,440 --> 00:07:20,140
equals at at 10 and then we say Z plus

143
00:07:20,140 --> 00:07:22,150
plus plus so what's it going to come out

144
00:07:22,150 --> 00:07:24,179
to

145
00:07:31,060 --> 00:07:33,820
I heard somebody say 23 right so first

146
00:07:33,820 --> 00:07:36,490
it's multiplying by 10 multiplying by 2

147
00:07:36,490 --> 00:07:39,970
and then adding 3 okay so this is like

148
00:07:39,970 --> 00:07:41,740
this is not making things easier using

149
00:07:41,740 --> 00:07:43,720
operators like this and you're gonna

150
00:07:43,720 --> 00:07:45,280
quickly run out of things and you'll

151
00:07:45,280 --> 00:07:48,280
probably end up with obfuscated code but

152
00:07:48,280 --> 00:07:53,020
luckily we're not restricted to just

153
00:07:53,020 --> 00:07:55,330
these ascii operators we can use any

154
00:07:55,330 --> 00:07:58,540
operator from unicode so let's say we

155
00:07:58,540 --> 00:08:01,510
want to define the dot product as you

156
00:08:01,510 --> 00:08:03,880
may remember from math a dot product of

157
00:08:03,880 --> 00:08:06,130
two vectors or two arrays you multiply

158
00:08:06,130 --> 00:08:07,930
the corresponding elements together and

159
00:08:07,930 --> 00:08:11,500
then you take the sum okay sum from 1 to

160
00:08:11,500 --> 00:08:13,900
n of the corresponding elements from

161
00:08:13,900 --> 00:08:15,700
each array that's the dot product then

162
00:08:15,700 --> 00:08:19,270
there's an operator for it it's a dot we

163
00:08:19,270 --> 00:08:22,030
can define the dot product unifix sorry

164
00:08:22,030 --> 00:08:25,690
sub in fixed Col and dot is and this is

165
00:08:25,690 --> 00:08:28,300
I won't go into this too much but

166
00:08:28,300 --> 00:08:29,620
essentially we're multiplying the

167
00:08:29,620 --> 00:08:31,300
corresponding elements and adding them

168
00:08:31,300 --> 00:08:33,610
all together and then if we say 1 comma

169
00:08:33,610 --> 00:08:39,429
2 dot 3 comma 4 we get C people are

170
00:08:39,429 --> 00:08:41,049
paying attention since it's a lunchtime

171
00:08:41,049 --> 00:08:48,449
talk ok 11 all right

172
00:08:49,730 --> 00:08:52,380
what about this so here we can also use

173
00:08:52,380 --> 00:08:54,570
there are unicode floor characters you

174
00:08:54,570 --> 00:08:56,160
know don't you hate when you have you

175
00:08:56,160 --> 00:08:57,900
know decimals in your code you have to

176
00:08:57,900 --> 00:08:59,220
deal with like floating points or

177
00:08:59,220 --> 00:09:01,080
rational numbers so let's define a

178
00:09:01,080 --> 00:09:03,810
circumflex floor operator say floor of

179
00:09:03,810 --> 00:09:11,119
to put 2.4 this one is 2 okay come on

180
00:09:11,300 --> 00:09:13,830
okay so what happens if we have several

181
00:09:13,830 --> 00:09:15,300
operators and we start using them

182
00:09:15,300 --> 00:09:17,370
together so let's say we have a plus

183
00:09:17,370 --> 00:09:19,530
operator hear the word plus and a times

184
00:09:19,530 --> 00:09:21,630
operator which is there were times we

185
00:09:21,630 --> 00:09:37,530
say 1 plus 2 times 3 what do we get ok

186
00:09:37,530 --> 00:09:42,960
so I heard 1 9 and 1 6 so 1 plus 2 is 3

187
00:09:42,960 --> 00:09:49,770
3 times 3 is 9 so you know we wanted to

188
00:09:49,770 --> 00:09:53,390
get 7 but we didn't because what's wrong

189
00:09:53,390 --> 00:09:56,970
precedence right luckily you can specify

190
00:09:56,970 --> 00:10:00,030
the precedence of your operators so if

191
00:10:00,030 --> 00:10:03,210
you want to say that x is a tighter

192
00:10:03,210 --> 00:10:06,090
precedence than plus you add is tighter

193
00:10:06,090 --> 00:10:08,610
here afterwards is tighter takes an

194
00:10:08,610 --> 00:10:10,200
argument that's another operator so

195
00:10:10,200 --> 00:10:14,040
precedence is all relative now 1 plus 2

196
00:10:14,040 --> 00:10:19,110
times 3 is 2 times 3 is 6 plus 1 except

197
00:10:19,110 --> 00:10:21,570
you get 7 so in addition to is tighter

198
00:10:21,570 --> 00:10:22,860
you could have done it the other way

199
00:10:22,860 --> 00:10:24,630
around you could have defined is looser

200
00:10:24,630 --> 00:10:27,480
say plus is looser than x you can also

201
00:10:27,480 --> 00:10:29,460
say is a quiff two things have the same

202
00:10:29,460 --> 00:10:32,090
precedence

203
00:10:32,960 --> 00:10:35,940
if you have like a non-transitive

204
00:10:35,940 --> 00:10:40,220
precedence good question I don't know

205
00:10:43,340 --> 00:10:45,570
okay what about chaining operator so

206
00:10:45,570 --> 00:10:47,430
let's say we have this operator to the

207
00:10:47,430 --> 00:10:50,790
power which is I don't know COBOL but it

208
00:10:50,790 --> 00:10:53,010
seems like it could be a COBOL operator

209
00:10:53,010 --> 00:10:56,370
where we were where we want to raise we

210
00:10:56,370 --> 00:10:58,230
want to raise the first argument to an

211
00:10:58,230 --> 00:11:02,700
exponential value so 2 to the power 3 to

212
00:11:02,700 --> 00:11:06,510
the power 2 what are we going to get 64

213
00:11:06,510 --> 00:11:08,130
because it's going to be 2 to the 3 to

214
00:11:08,130 --> 00:11:13,080
the 2 so 8 squared but you know what's

215
00:11:13,080 --> 00:11:15,540
happening here is we have 2 to the 3 to

216
00:11:15,540 --> 00:11:19,740
the 2 and it's to the 3 to the 2 but you

217
00:11:19,740 --> 00:11:21,420
know really it should be this way if

218
00:11:21,420 --> 00:11:23,700
we're mathematicians it should be 2 to

219
00:11:23,700 --> 00:11:27,360
the 3 squared so in this case what is it

220
00:11:27,360 --> 00:11:31,320
that we want to change so stiphu t so

221
00:11:31,320 --> 00:11:32,940
luckily you can change the associativity

222
00:11:32,940 --> 00:11:35,880
of your operators to okay so if it's

223
00:11:35,880 --> 00:11:38,160
right associative then you say is Assos

224
00:11:38,160 --> 00:11:44,100
right and now 2 to the 3 to the 2 is 512

225
00:11:44,100 --> 00:11:48,510
yes ok other associativity is you have

226
00:11:48,510 --> 00:11:49,980
right associativity less to so left

227
00:11:49,980 --> 00:11:52,410
associativity non-associative which will

228
00:11:52,410 --> 00:11:53,460
throw an operator

229
00:11:53,460 --> 00:11:56,370
sorry throw an error you have this thing

230
00:11:56,370 --> 00:11:58,080
called chain associativity which is

231
00:11:58,080 --> 00:12:00,000
really cool because the less than

232
00:12:00,000 --> 00:12:02,280
operator has chain associativity so you

233
00:12:02,280 --> 00:12:04,380
can say 1 is less than 2 is less than 3

234
00:12:04,380 --> 00:12:07,200
which means 1 is less than 2 and 2 is

235
00:12:07,200 --> 00:12:10,710
less than 3 you also have list

236
00:12:10,710 --> 00:12:13,980
associativity which says take all these

237
00:12:13,980 --> 00:12:15,420
things and let me just make a

238
00:12:15,420 --> 00:12:17,700
multivalued function that I can I can

239
00:12:17,700 --> 00:12:20,460
operate on all of them at once the cross

240
00:12:20,460 --> 00:12:24,560
product is list associative

241
00:12:27,189 --> 00:12:29,559
okay so let's look back at something

242
00:12:29,559 --> 00:12:31,480
simple subtraction let's say we make up

243
00:12:31,480 --> 00:12:33,369
let's say okay we wanted to find what it

244
00:12:33,369 --> 00:12:34,989
means to subtract one string from

245
00:12:34,989 --> 00:12:37,589
another string so we say it's

246
00:12:37,589 --> 00:12:41,559
substituting all occurrences of the

247
00:12:41,559 --> 00:12:44,499
first string with the empty string okay

248
00:12:44,499 --> 00:12:45,910
so we're gonna say this is what it means

249
00:12:45,910 --> 00:12:48,730
you take a string and you subtract a

250
00:12:48,730 --> 00:12:49,059
letter

251
00:12:49,059 --> 00:12:50,920
it's like deleting all of those letters

252
00:12:50,920 --> 00:12:54,429
from the string so house minus U is hos

253
00:12:54,429 --> 00:12:58,869
all right so then what happens when we

254
00:12:58,869 --> 00:13:02,949
say 32 minus 2 oh not good

255
00:13:02,949 --> 00:13:05,290
right now we get three so that's

256
00:13:05,290 --> 00:13:08,019
unfortunate because we don't want 32

257
00:13:08,019 --> 00:13:09,699
minus two to be three

258
00:13:09,699 --> 00:13:13,480
luckily argh no good okay

259
00:13:13,480 --> 00:13:15,160
luckily we can fix that we can give

260
00:13:15,160 --> 00:13:17,619
types to our operators sorry to our

261
00:13:17,619 --> 00:13:22,449
arguments so we define the arguments we

262
00:13:22,449 --> 00:13:23,410
say they are strings

263
00:13:23,410 --> 00:13:25,540
stur dollar x and stir dal or Y and

264
00:13:25,540 --> 00:13:28,179
instead of a sub it's now a multi so we

265
00:13:28,179 --> 00:13:30,189
have multiple dispatch for functions and

266
00:13:30,189 --> 00:13:32,170
multiple dispatch for arguments so now

267
00:13:32,170 --> 00:13:34,600
when we have a house and a U which are

268
00:13:34,600 --> 00:13:37,629
both strings and we have 32 minus 3 we

269
00:13:37,629 --> 00:13:39,249
get the correct thing we got hos for the

270
00:13:39,249 --> 00:13:41,519
strings but we still get 29 for the

271
00:13:41,519 --> 00:13:44,519
numbers

272
00:13:51,269 --> 00:13:54,369
well luckily you it's optional so pearl

273
00:13:54,369 --> 00:13:57,639
six has they caught gradual typing or

274
00:13:57,639 --> 00:14:02,049
optional typing its right so it's up to

275
00:14:02,049 --> 00:14:04,029
you whether you want to put the

276
00:14:04,029 --> 00:14:24,879
restrictions on or not that's right so

277
00:14:24,879 --> 00:14:27,309
the signature of the function in this

278
00:14:27,309 --> 00:14:29,049
case it has types but you can have

279
00:14:29,049 --> 00:14:30,879
multiple dispatch without having types

280
00:14:30,879 --> 00:14:32,589
it will look at the number of arguments

281
00:14:32,589 --> 00:14:47,169
for instance or names named argument you

282
00:14:47,169 --> 00:14:50,979
can use you can use them with different

283
00:14:50,979 --> 00:14:52,929
different types of signatures mixing

284
00:14:52,929 --> 00:15:00,099
mixing types and non types let's say

285
00:15:00,099 --> 00:15:01,389
we'll get to that in a second I'm gonna

286
00:15:01,389 --> 00:15:04,899
get have a few more okay so what if we

287
00:15:04,899 --> 00:15:07,809
put in things like constants I think

288
00:15:07,809 --> 00:15:10,919
this is what you're saying right okay so

289
00:15:10,919 --> 00:15:14,019
we have strings here as two arguments we

290
00:15:14,019 --> 00:15:16,329
were and that works fine we subtracted

291
00:15:16,329 --> 00:15:18,220
what if we want to say we subtract an

292
00:15:18,220 --> 00:15:20,349
INT from a string meaning we take a few

293
00:15:20,349 --> 00:15:22,959
characters off the end and if we put a

294
00:15:22,959 --> 00:15:24,849
constant here that also takes precedence

295
00:15:24,849 --> 00:15:27,819
so here we can say an escalator or -

296
00:15:27,819 --> 00:15:30,609
electricity and we get stairs even

297
00:15:30,609 --> 00:15:33,429
though they're strings we have a more

298
00:15:33,429 --> 00:15:36,429
narrow type than the string type so we

299
00:15:36,429 --> 00:15:38,979
get you know we can take the A's that of

300
00:15:38,979 --> 00:15:41,229
catamaran we can subtract six letters

301
00:15:41,229 --> 00:15:44,499
from catamaran and then ten minus five

302
00:15:44,499 --> 00:15:46,979
still works

303
00:15:47,990 --> 00:15:50,760
okay here's an example so Python has

304
00:15:50,760 --> 00:15:52,410
this really nice operator actually it's

305
00:15:52,410 --> 00:15:56,070
called the percent operator and you can

306
00:15:56,070 --> 00:15:57,600
use it there are two different ways to

307
00:15:57,600 --> 00:15:59,490
format strings in Python

308
00:15:59,490 --> 00:16:01,440
one is with format and one is with

309
00:16:01,440 --> 00:16:04,170
percent percent one is very nice it

310
00:16:04,170 --> 00:16:07,610
takes a string and then it takes either

311
00:16:07,610 --> 00:16:10,740
either a number or a list and it kind of

312
00:16:10,740 --> 00:16:12,960
works like s printf so we can make

313
00:16:12,960 --> 00:16:15,870
percent work like that in Perl 6 if we

314
00:16:15,870 --> 00:16:19,140
want to so here we say when you have a

315
00:16:19,140 --> 00:16:20,790
string in a number we just do an S

316
00:16:20,790 --> 00:16:23,610
printf if you have a string in a list

317
00:16:23,610 --> 00:16:25,410
you do the same thing you flatten your

318
00:16:25,410 --> 00:16:27,150
list you pass it as arguments to s

319
00:16:27,150 --> 00:16:30,480
printf then we can say this is percent d

320
00:16:30,480 --> 00:16:32,820
and it'll put the 40 where the percent D

321
00:16:32,820 --> 00:16:35,820
is you can say pi is about point 2f e is

322
00:16:35,820 --> 00:16:38,400
about point 2f and that's the symbol pi

323
00:16:38,400 --> 00:16:41,250
and that's e and so this works just like

324
00:16:41,250 --> 00:16:43,830
that we've got this is 40 pi is about

325
00:16:43,830 --> 00:16:45,660
three point one four is about two point

326
00:16:45,660 --> 00:16:49,200
seven two so let's look at an

327
00:16:49,200 --> 00:16:52,140
application of this to some of the

328
00:16:52,140 --> 00:16:53,700
examples in the beginning for

329
00:16:53,700 --> 00:16:57,120
domain-specific languages so generating

330
00:16:57,120 --> 00:17:02,640
SQL so some of the techniques that you

331
00:17:02,640 --> 00:17:06,750
might see in various dsls in various ORM

332
00:17:06,750 --> 00:17:08,819
Zoar ways of generating SQL you'll see

333
00:17:08,819 --> 00:17:11,459
no method chaining where you'll have you

334
00:17:11,459 --> 00:17:14,010
know you'll keep calling like join or do

335
00:17:14,010 --> 00:17:15,209
something like this and at the end of

336
00:17:15,209 --> 00:17:17,579
the day you get you get your SQL you'll

337
00:17:17,579 --> 00:17:20,550
see operator overloading sometimes and

338
00:17:20,550 --> 00:17:22,230
then more common than not you see I'm

339
00:17:22,230 --> 00:17:24,480
calling it data structure abuse you know

340
00:17:24,480 --> 00:17:26,760
where you've got like okay all arrays

341
00:17:26,760 --> 00:17:29,970
arrays mean or and hashes mean and or

342
00:17:29,970 --> 00:17:32,700
you know you have nested data structures

343
00:17:32,700 --> 00:17:35,850
which somehow get turned into SQL how

344
00:17:35,850 --> 00:17:37,440
many people have worked with ORM S or

345
00:17:37,440 --> 00:17:39,990
use ORM sometimes okay so it's do you

346
00:17:39,990 --> 00:17:41,100
guys you know what I'm talking about

347
00:17:41,100 --> 00:17:46,920
with some of these constructs so we have

348
00:17:46,920 --> 00:17:48,510
new techniques with some of those things

349
00:17:48,510 --> 00:17:52,850
that we just talked about the operators

350
00:17:52,850 --> 00:17:57,390
can all those operators could be used to

351
00:17:57,390 --> 00:17:58,950
generate SQL so we could set write

352
00:17:58,950 --> 00:18:00,510
something like this user plus

353
00:18:00,510 --> 00:18:03,420
a dress name equals Edie and full name

354
00:18:03,420 --> 00:18:07,490
equals Edie Jones where we're using

355
00:18:07,490 --> 00:18:10,380
equals and equals and and and we're

356
00:18:10,380 --> 00:18:12,030
going to redefine those depending on the

357
00:18:12,030 --> 00:18:14,160
type of what's coming in we can use the

358
00:18:14,160 --> 00:18:17,580
circum fix poster can fix operator to

359
00:18:17,580 --> 00:18:21,630
filter things and the way we would do

360
00:18:21,630 --> 00:18:23,730
that is we would have for instance we

361
00:18:23,730 --> 00:18:26,460
would have a table class and then the in

362
00:18:26,460 --> 00:18:29,670
fix plus takes two tables so user an

363
00:18:29,670 --> 00:18:33,090
address then we'll take two tables and

364
00:18:33,090 --> 00:18:35,520
generate something else

365
00:18:35,520 --> 00:18:37,890
similarly we could do something with

366
00:18:37,890 --> 00:18:40,490
equals and and and we could say alright

367
00:18:40,490 --> 00:18:43,290
equals takes two columns or maybe takes

368
00:18:43,290 --> 00:18:46,230
a column and a value and returns a

369
00:18:46,230 --> 00:18:49,170
filter of some sort and then we could do

370
00:18:49,170 --> 00:18:51,990
something something else so you have a

371
00:18:51,990 --> 00:18:53,400
lot of flexibility if you're designing

372
00:18:53,400 --> 00:18:56,690
an ORM or something to generate SQL in

373
00:18:56,690 --> 00:19:01,890
pro six but what I think is interesting

374
00:19:01,890 --> 00:19:05,640
is that although operators can be used

375
00:19:05,640 --> 00:19:09,480
to generate SQL operators have already

376
00:19:09,480 --> 00:19:12,960
been used to express SQL namely before

377
00:19:12,960 --> 00:19:15,450
there was SQL there was relational

378
00:19:15,450 --> 00:19:21,510
algebra so in the 70s when EF Cod came

379
00:19:21,510 --> 00:19:23,760
up with SQL he first started talking

380
00:19:23,760 --> 00:19:25,320
about the mathematics behind it and how

381
00:19:25,320 --> 00:19:31,230
you would express queries in this with

382
00:19:31,230 --> 00:19:33,210
this in this algebra and he had

383
00:19:33,210 --> 00:19:35,190
definitions for things like projections

384
00:19:35,190 --> 00:19:38,070
selection rename natural join semi join

385
00:19:38,070 --> 00:19:41,460
all these things that we now use SQL to

386
00:19:41,460 --> 00:19:45,660
Express so what we could do in Perl 6 is

387
00:19:45,660 --> 00:19:48,960
instead of inventing something new we

388
00:19:48,960 --> 00:19:50,790
could reuse some of these operators that

389
00:19:50,790 --> 00:19:54,000
have already have well-defined semantics

390
00:19:54,000 --> 00:19:58,350
for querying data so for instance we

391
00:19:58,350 --> 00:20:00,900
could have the in fix bowtie operator

392
00:20:00,900 --> 00:20:03,720
make a natural join and then you could

393
00:20:03,720 --> 00:20:08,460
say users join addresses like that and

394
00:20:08,460 --> 00:20:09,750
in fact you wouldn't be making up

395
00:20:09,750 --> 00:20:11,460
something new because there's already

396
00:20:11,460 --> 00:20:13,680
precedent for the way these operators

397
00:20:13,680 --> 00:20:14,460
behave

398
00:20:14,460 --> 00:20:17,250
you could do the same thing with the

399
00:20:17,250 --> 00:20:19,260
projection operator turn it into a

400
00:20:19,260 --> 00:20:23,010
select so projects name and age would

401
00:20:23,010 --> 00:20:27,350
turn that into a select statement so

402
00:20:27,350 --> 00:20:29,310
conclusion of this section is that

403
00:20:29,310 --> 00:20:32,820
custom operators are very cool and when

404
00:20:32,820 --> 00:20:34,740
you're making a subset of a language

405
00:20:34,740 --> 00:20:38,760
into a DSL they are a good way to do

406
00:20:38,760 --> 00:20:46,190
that in pro 6 ok so part 2 is external

407
00:20:46,190 --> 00:20:50,640
informal domain-specific languages and

408
00:20:50,640 --> 00:20:54,240
for this Perl 6 has a feature of a lot

409
00:20:54,240 --> 00:20:55,680
of you probably heard about already call

410
00:20:55,680 --> 00:21:03,290
it grammars so some typical examples of

411
00:21:03,290 --> 00:21:08,010
external dsls include templating

412
00:21:08,010 --> 00:21:11,940
languages and wikis and so for the next

413
00:21:11,940 --> 00:21:13,980
section what I'm going to do is take an

414
00:21:13,980 --> 00:21:16,380
example of one of these languages and

415
00:21:16,380 --> 00:21:18,060
we're going to go through it and I'll

416
00:21:18,060 --> 00:21:20,400
show you what it's like to write a

417
00:21:20,400 --> 00:21:26,460
grammar to parse a language like that ok

418
00:21:26,460 --> 00:21:27,870
so the language we're gonna look at is

419
00:21:27,870 --> 00:21:29,370
called slim how many people have heard

420
00:21:29,370 --> 00:21:30,740
of slim

421
00:21:30,740 --> 00:21:35,040
nobody Wow yeah no Ruby programmers in

422
00:21:35,040 --> 00:21:38,610
the room I guess so slim is kind of a

423
00:21:38,610 --> 00:21:40,380
cool language it's popular among Ruby

424
00:21:40,380 --> 00:21:42,210
programmers and this is what it looks

425
00:21:42,210 --> 00:21:43,140
like

426
00:21:43,140 --> 00:21:48,030
it's indentation based and it sort of

427
00:21:48,030 --> 00:21:48,720
starts like this

428
00:21:48,720 --> 00:21:52,440
it has HTML over here and then you

429
00:21:52,440 --> 00:21:55,170
indent a little bit you get head indent

430
00:21:55,170 --> 00:21:57,360
a little bit more for title then you can

431
00:21:57,360 --> 00:22:00,960
go back for body and so it's very terse

432
00:22:00,960 --> 00:22:02,880
so it's actually kind of nice because

433
00:22:02,880 --> 00:22:04,860
you can type things out you just indent

434
00:22:04,860 --> 00:22:07,020
and then instantly you get this like

435
00:22:07,020 --> 00:22:10,890
nested this nested HTML comes out of it

436
00:22:10,890 --> 00:22:12,180
you don't have to type any angle

437
00:22:12,180 --> 00:22:15,870
brackets and so it's actually pretty

438
00:22:15,870 --> 00:22:18,139
cool

439
00:22:19,840 --> 00:22:23,150
okay so let's take a look first we're

440
00:22:23,150 --> 00:22:24,770
gonna look at how we could parse this

441
00:22:24,770 --> 00:22:28,340
language and then we're going to look at

442
00:22:28,340 --> 00:22:31,790
how given the structure that we just saw

443
00:22:31,790 --> 00:22:33,230
as an input we're going to generate a

444
00:22:33,230 --> 00:22:35,630
data structure that's the DOM and HTML

445
00:22:35,630 --> 00:22:40,070
DOM and it sounds hard but it's actually

446
00:22:40,070 --> 00:22:42,820
not too bad

447
00:22:43,900 --> 00:22:47,360
okay so parsing a language so I'm gonna

448
00:22:47,360 --> 00:22:48,950
go this is gonna be a little bit of an

449
00:22:48,950 --> 00:22:51,140
overview and you can refer the

450
00:22:51,140 --> 00:22:53,000
documentation for more details about how

451
00:22:53,000 --> 00:22:54,800
some of these things work

452
00:22:54,800 --> 00:22:58,430
so essentially Perl 6 has grammars there

453
00:22:58,430 --> 00:23:01,540
are first-class objects in Perl 6

454
00:23:01,540 --> 00:23:03,560
declaring a grammar is kind of like

455
00:23:03,560 --> 00:23:05,540
making a declaring a class except

456
00:23:05,540 --> 00:23:07,340
instead of declaring methods you have

457
00:23:07,340 --> 00:23:10,970
regular expressions which are associated

458
00:23:10,970 --> 00:23:13,070
with the grammar so we have a collection

459
00:23:13,070 --> 00:23:15,800
of regular expressions here certain

460
00:23:15,800 --> 00:23:18,410
types of regular expressions are called

461
00:23:18,410 --> 00:23:20,630
rules and some of them are called tokens

462
00:23:20,630 --> 00:23:23,420
so if a regular expression doesn't do

463
00:23:23,420 --> 00:23:26,110
any backtracking it's called a token and

464
00:23:26,110 --> 00:23:28,550
if the whitespace in your regular

465
00:23:28,550 --> 00:23:30,170
expression is significant then it's

466
00:23:30,170 --> 00:23:32,180
called a rule those are the only

467
00:23:32,180 --> 00:23:34,100
differences between rules tokens and

468
00:23:34,100 --> 00:23:35,450
regular expressions but they're really

469
00:23:35,450 --> 00:23:37,610
although they're they're all a type of

470
00:23:37,610 --> 00:23:39,110
regular expression with additional

471
00:23:39,110 --> 00:23:44,180
constraints so this HTML here we're

472
00:23:44,180 --> 00:23:46,220
sorry the slim code here where we have

473
00:23:46,220 --> 00:23:49,070
HTML head you can sort of see the

474
00:23:49,070 --> 00:23:52,130
pattern where you have you have some

475
00:23:52,130 --> 00:23:56,140
indentation and then you have a tag and

476
00:23:56,140 --> 00:23:59,750
then you may have some text after the

477
00:23:59,750 --> 00:24:03,950
tag so that's basically it for the

478
00:24:03,950 --> 00:24:07,990
language so the top-level rule here is

479
00:24:07,990 --> 00:24:12,740
one or more lines separated by an end of

480
00:24:12,740 --> 00:24:16,070
line character end of line is a series

481
00:24:16,070 --> 00:24:19,100
of character turns

482
00:24:19,100 --> 00:24:23,509
so if we parse this particular code if

483
00:24:23,509 --> 00:24:26,059
we parse this using this grammar we end

484
00:24:26,059 --> 00:24:29,630
up with a match object so this is a

485
00:24:29,630 --> 00:24:33,710
nested data structure and the structure

486
00:24:33,710 --> 00:24:37,490
looks like the rules that we just had in

487
00:24:37,490 --> 00:24:41,179
our grammar so we end up with a sequence

488
00:24:41,179 --> 00:24:45,320
of lines and each line has a tag and it

489
00:24:45,320 --> 00:24:55,610
has may have some indentation so these

490
00:24:55,610 --> 00:24:57,440
can be very cumbersome to work with

491
00:24:57,440 --> 00:25:00,320
so generally instead of parsing

492
00:25:00,320 --> 00:25:02,480
something in getting a big match object

493
00:25:02,480 --> 00:25:05,330
the way to do something interesting with

494
00:25:05,330 --> 00:25:08,450
a grammar is to set up things that

495
00:25:08,450 --> 00:25:16,399
happen during the parse so the way you

496
00:25:16,399 --> 00:25:19,610
do that is essentially so a grammar can

497
00:25:19,610 --> 00:25:21,769
basically have an object associated with

498
00:25:21,769 --> 00:25:25,399
it and then every time a particular rule

499
00:25:25,399 --> 00:25:28,580
is reached this the method of the same

500
00:25:28,580 --> 00:25:32,299
name on that object gets called so if

501
00:25:32,299 --> 00:25:34,070
you have a method called line if you

502
00:25:34,070 --> 00:25:35,539
have an object with a method called line

503
00:25:35,539 --> 00:25:37,309
then while it's parsing and hits a line

504
00:25:37,309 --> 00:25:39,470
it calls your method and it sends you

505
00:25:39,470 --> 00:25:42,159
the current line

506
00:25:42,490 --> 00:25:45,220
since you the Kermit it sends you the

507
00:25:45,220 --> 00:25:52,510
current line okay so here we have our

508
00:25:52,510 --> 00:25:55,570
grammar which had tokens tags text and

509
00:25:55,570 --> 00:25:58,300
indentation and we're going to make a

510
00:25:58,300 --> 00:26:01,840
class that has similar methods one

511
00:26:01,840 --> 00:26:03,790
called tag one called text one called

512
00:26:03,790 --> 00:26:06,280
indentation and basically what we have

513
00:26:06,280 --> 00:26:08,500
to do is say here's what you do when you

514
00:26:08,500 --> 00:26:10,270
see a tag or here's what you do when you

515
00:26:10,270 --> 00:26:13,690
see indentation and then creating a new

516
00:26:13,690 --> 00:26:16,030
object we say my dollar Dom equals Dom

517
00:26:16,030 --> 00:26:20,050
new we call Slim dot parse and then the

518
00:26:20,050 --> 00:26:25,480
actions parameter sends the sends the

519
00:26:25,480 --> 00:26:27,490
object whose methods are going to be

520
00:26:27,490 --> 00:26:29,700
called

521
00:26:30,910 --> 00:26:33,430
okay so here is our algorithm for

522
00:26:33,430 --> 00:26:36,880
parsing slim we're gonna go through this

523
00:26:36,880 --> 00:26:38,830
indentation paste in this indentation

524
00:26:38,830 --> 00:26:42,490
based format and we're gonna keep a

525
00:26:42,490 --> 00:26:44,350
stack with us and we're gonna have a

526
00:26:44,350 --> 00:26:46,840
little node class that's got parent

527
00:26:46,840 --> 00:26:48,820
nodes and child nodes so basic data

528
00:26:48,820 --> 00:26:51,940
structure that's a tree okay and when

529
00:26:51,940 --> 00:26:53,740
you see a tag you push a new node onto

530
00:26:53,740 --> 00:26:57,640
the stack and when you see text you're

531
00:26:57,640 --> 00:27:00,130
gonna add some text to your node then

532
00:27:00,130 --> 00:27:01,690
when you see a notation you pull it off

533
00:27:01,690 --> 00:27:08,170
the stack okay so this this sounds a

534
00:27:08,170 --> 00:27:10,030
little confusing so what we're gonna do

535
00:27:10,030 --> 00:27:13,000
now is walk through an example of seeing

536
00:27:13,000 --> 00:27:15,160
this algorithm at work before I show you

537
00:27:15,160 --> 00:27:16,990
the Perl 6 code to do it so that you

538
00:27:16,990 --> 00:27:21,960
believe that it works okay so here's our

539
00:27:21,960 --> 00:27:25,540
here's our text on the right that we're

540
00:27:25,540 --> 00:27:28,240
parsing the slim text has HTML head

541
00:27:28,240 --> 00:27:32,020
title body and on the Left we've got two

542
00:27:32,020 --> 00:27:33,340
things that are gonna sort of keep going

543
00:27:33,340 --> 00:27:36,160
we've got a stack that we're gonna push

544
00:27:36,160 --> 00:27:37,960
on pop from and we've got a tree that

545
00:27:37,960 --> 00:27:39,850
we're gonna connect to when we hit

546
00:27:39,850 --> 00:27:45,370
indentation in text on the right okay so

547
00:27:45,370 --> 00:27:49,990
let's go first line is HTML indentation

548
00:27:49,990 --> 00:27:52,390
is at level zero and there's nothing on

549
00:27:52,390 --> 00:27:55,960
the stack so we push an HTML tag onto

550
00:27:55,960 --> 00:27:59,650
our stack then we move on to the next

551
00:27:59,650 --> 00:28:03,460
line where we have indentation level one

552
00:28:03,460 --> 00:28:05,080
and stack one so a reminder of the

553
00:28:05,080 --> 00:28:07,330
algorithm you want the level of

554
00:28:07,330 --> 00:28:11,290
indentation to be the same as the stack

555
00:28:11,290 --> 00:28:13,840
so if it's the same the stack is one

556
00:28:13,840 --> 00:28:16,690
indentation is one you're good when

557
00:28:16,690 --> 00:28:18,550
indentation gets too small that's when

558
00:28:18,550 --> 00:28:21,480
you're going to change things

559
00:28:21,480 --> 00:28:24,179
okay so indent one stack one we push

560
00:28:24,179 --> 00:28:27,870
head on to the stack and we move to the

561
00:28:27,870 --> 00:28:30,149
next line okay

562
00:28:30,149 --> 00:28:32,490
indentation level to stack two it's the

563
00:28:32,490 --> 00:28:35,760
same so so far so good so we push title

564
00:28:35,760 --> 00:28:38,730
on to the stack and then we set the

565
00:28:38,730 --> 00:28:41,460
title we've set we run into text I'm

566
00:28:41,460 --> 00:28:45,059
gonna skip that for this demo and then

567
00:28:45,059 --> 00:28:47,370
we move on to the next one okay now

568
00:28:47,370 --> 00:28:49,710
something changed indented is now one

569
00:28:49,710 --> 00:28:51,960
which is less than the stack which is

570
00:28:51,960 --> 00:28:55,529
three so because the indentation is less

571
00:28:55,529 --> 00:28:57,299
than the stack we popped from the stack

572
00:28:57,299 --> 00:29:01,860
twice okay so we go pop pop and we put

573
00:29:01,860 --> 00:29:05,190
it down here with the tree and every

574
00:29:05,190 --> 00:29:07,470
time we popped from the stack we connect

575
00:29:07,470 --> 00:29:11,159
a node with the node before it so title

576
00:29:11,159 --> 00:29:14,190
is connected to h2 head and head is

577
00:29:14,190 --> 00:29:19,649
actually connected to HTML okay so we

578
00:29:19,649 --> 00:29:21,840
now our stack is down to one and our

579
00:29:21,840 --> 00:29:24,870
tree has sort of looks like a linked

580
00:29:24,870 --> 00:29:27,809
list at this point yeah we move on to

581
00:29:27,809 --> 00:29:30,779
the next one which is h1 oh sorry and we

582
00:29:30,779 --> 00:29:32,789
pushed the body on afterwards then we

583
00:29:32,789 --> 00:29:36,000
move on to the next tag which is h1 okay

584
00:29:36,000 --> 00:29:37,679
again now we're back where we have

585
00:29:37,679 --> 00:29:42,149
indent and stack are the same so all we

586
00:29:42,149 --> 00:29:47,340
have to do is push the h1 on and then we

587
00:29:47,340 --> 00:29:49,110
run into the text we set the text of the

588
00:29:49,110 --> 00:29:51,990
h1 and then finally we get back to level

589
00:29:51,990 --> 00:29:56,039
zero once again indent is below stack so

590
00:29:56,039 --> 00:29:58,860
we are going to pop from the stack three

591
00:29:58,860 --> 00:30:03,690
times and attach these so we pop once

592
00:30:03,690 --> 00:30:04,789
oops

593
00:30:04,789 --> 00:30:09,570
pop once pop twice and then so these are

594
00:30:09,570 --> 00:30:10,950
connected to each other and then when we

595
00:30:10,950 --> 00:30:13,590
pop the final time we're connecting to

596
00:30:13,590 --> 00:30:16,260
something we already have so we end up

597
00:30:16,260 --> 00:30:19,940
with the Dom okay so here's our Dom tree

598
00:30:19,940 --> 00:30:26,690
HTML head title and HTML body h1

599
00:30:26,800 --> 00:30:31,250
so it's a little tricky to walk through

600
00:30:31,250 --> 00:30:34,910
that but what's kind of cool is you can

601
00:30:34,910 --> 00:30:37,460
apply the same thing to making an

602
00:30:37,460 --> 00:30:39,800
abstract syntax tree when you're parsing

603
00:30:39,800 --> 00:30:44,900
a language I'm not gonna do that okay so

604
00:30:44,900 --> 00:30:47,690
what does this look like in Perl 6 so

605
00:30:47,690 --> 00:30:49,160
now that you know the algorithm it's

606
00:30:49,160 --> 00:30:51,860
it's actually really straightforward so

607
00:30:51,860 --> 00:30:55,340
here's our node class the node class has

608
00:30:55,340 --> 00:30:59,780
a tag which is a string so again these

609
00:30:59,780 --> 00:31:01,520
are optional but these are types that

610
00:31:01,520 --> 00:31:03,710
you can put there if you want to

611
00:31:03,710 --> 00:31:06,220
constrain the types of your attributes

612
00:31:06,220 --> 00:31:09,260
so we have a tag attribute we have a

613
00:31:09,260 --> 00:31:13,040
text attribute the is our W means that

614
00:31:13,040 --> 00:31:14,270
there's going to be a read/write access

615
00:31:14,270 --> 00:31:16,490
ur and we need that for text because

616
00:31:16,490 --> 00:31:19,670
we're setting a text after we put it on

617
00:31:19,670 --> 00:31:22,100
the stack and then we have a parent

618
00:31:22,100 --> 00:31:25,760
which is another node and we have an

619
00:31:25,760 --> 00:31:28,250
array of children so this is a this is a

620
00:31:28,250 --> 00:31:31,700
data structure which has it's a tree and

621
00:31:31,700 --> 00:31:33,410
you have sort of pointers in both

622
00:31:33,410 --> 00:31:35,240
directions right so you have a pointer

623
00:31:35,240 --> 00:31:36,770
to your parents and you have an array of

624
00:31:36,770 --> 00:31:42,770
children the Dom class we so we have

625
00:31:42,770 --> 00:31:47,090
this stack here which is which we're

626
00:31:47,090 --> 00:31:48,320
going to use we're going to keep track

627
00:31:48,320 --> 00:31:51,140
of this while we're parsing and then we

628
00:31:51,140 --> 00:31:53,150
have the top of the tree here which is a

629
00:31:53,150 --> 00:31:56,990
node so the my declares just a lexical

630
00:31:56,990 --> 00:32:00,530
variable and then has declares an

631
00:32:00,530 --> 00:32:03,860
attribute and so now okay just to

632
00:32:03,860 --> 00:32:06,380
refresh your memory the slim grammar has

633
00:32:06,380 --> 00:32:09,200
tagged text and indentation and so we

634
00:32:09,200 --> 00:32:11,420
need to make three methods one called

635
00:32:11,420 --> 00:32:13,970
tag one called text London called

636
00:32:13,970 --> 00:32:16,910
indentation which say what happens when

637
00:32:16,910 --> 00:32:20,810
you reach those particular those

638
00:32:20,810 --> 00:32:26,750
particular points in the grammar okay so

639
00:32:26,750 --> 00:32:29,000
back to the algorithm rule number one

640
00:32:29,000 --> 00:32:31,160
when you see a tag push a new note onto

641
00:32:31,160 --> 00:32:33,440
the stack so here we have a method tag

642
00:32:33,440 --> 00:32:37,060
the argument dollar slash is

643
00:32:37,060 --> 00:32:39,890
conventionally used to represent the

644
00:32:39,890 --> 00:32:42,290
match object so this is the what was

645
00:32:42,290 --> 00:32:44,900
captured it comes in it's not exactly a

646
00:32:44,900 --> 00:32:49,280
string it's a it's a match so if you

647
00:32:49,280 --> 00:32:51,920
want to set the tag to it you have to

648
00:32:51,920 --> 00:32:55,540
use this tilde which will stringify it

649
00:32:55,540 --> 00:32:59,330
the colons are another way of specifying

650
00:32:59,330 --> 00:33:01,790
parameters if you don't like parentheses

651
00:33:01,790 --> 00:33:03,290
to wrap your arguments you can use a

652
00:33:03,290 --> 00:33:06,380
colon instead so this makes a new node

653
00:33:06,380 --> 00:33:08,840
for a particular tag and just pushes it

654
00:33:08,840 --> 00:33:11,230
onto the stack

655
00:33:11,230 --> 00:33:13,990
okay when you see text set the text of

656
00:33:13,990 --> 00:33:16,870
the top node so here we have a method

657
00:33:16,870 --> 00:33:19,240
called text and we just say the top node

658
00:33:19,240 --> 00:33:22,120
you say star minus 1 to reference the

659
00:33:22,120 --> 00:33:25,899
top node dot text equals the incoming

660
00:33:25,899 --> 00:33:30,870
text okay so not not that much to it

661
00:33:31,820 --> 00:33:34,489
and then the trickiest part is what

662
00:33:34,489 --> 00:33:36,109
happens when you see indentation because

663
00:33:36,109 --> 00:33:37,879
now we have to pop until the size of the

664
00:33:37,879 --> 00:33:39,409
stack is the same as the level of

665
00:33:39,409 --> 00:33:44,899
indentation okay so basically you know

666
00:33:44,899 --> 00:33:46,789
once you sort of say it explicitly it's

667
00:33:46,789 --> 00:33:49,249
not that bad while at stack is greater

668
00:33:49,249 --> 00:33:52,609
than at dollar indent okay so there's a

669
00:33:52,609 --> 00:33:54,529
little bit of magic here because the

670
00:33:54,529 --> 00:33:58,330
dollar slash indent refers to the

671
00:33:58,330 --> 00:34:01,850
element of the match object that's named

672
00:34:01,850 --> 00:34:05,869
indent so before we started this you saw

673
00:34:05,869 --> 00:34:07,849
that there was an indent in some of the

674
00:34:07,849 --> 00:34:10,849
matches and that'll tell you how many

675
00:34:10,849 --> 00:34:16,520
levels of indentation you have so so

676
00:34:16,520 --> 00:34:18,770
that dollar node is popping off of the

677
00:34:18,770 --> 00:34:24,649
top of the stack and then this whiff

678
00:34:24,649 --> 00:34:26,299
essentially is just saying make sure

679
00:34:26,299 --> 00:34:28,369
it's defined so it's kind of like if and

680
00:34:28,369 --> 00:34:30,020
then do an assignment but only if it's

681
00:34:30,020 --> 00:34:32,359
defined so we take the top of the stack

682
00:34:32,359 --> 00:34:35,149
here and we assign the node the parent

683
00:34:35,149 --> 00:34:38,210
of the current node to be the top and we

684
00:34:38,210 --> 00:34:40,730
take our node and we push it on to the

685
00:34:40,730 --> 00:34:45,790
children of that node okay so that's

686
00:34:45,790 --> 00:34:48,049
about it there's also a way to dump

687
00:34:48,049 --> 00:34:51,379
which you can do recursively by printing

688
00:34:51,379 --> 00:34:53,418
out different levels of indentation I'll

689
00:34:53,418 --> 00:34:55,969
sort of skip through that but all in all

690
00:34:55,969 --> 00:34:59,480
the code is not too bad for doing all

691
00:34:59,480 --> 00:35:02,630
that parsing okay and here's what you

692
00:35:02,630 --> 00:35:05,329
get okay so for a couple of minutes here

693
00:35:05,329 --> 00:35:07,359
I'm gonna say a few words about slangs

694
00:35:07,359 --> 00:35:11,510
essentially slangs are a structured way

695
00:35:11,510 --> 00:35:16,640
to modify the grammar so Rikuo this

696
00:35:16,640 --> 00:35:19,250
implementation of Perl 6 uses nqp which

697
00:35:19,250 --> 00:35:21,859
has Perl 6 coal and corn grammar which

698
00:35:21,859 --> 00:35:24,230
is just like the grammar that you just

699
00:35:24,230 --> 00:35:26,930
saw except is actually parsing Perl 6

700
00:35:26,930 --> 00:35:31,090
and you can mess with it

701
00:35:31,090 --> 00:35:33,960
so this is what you can do right now

702
00:35:33,960 --> 00:35:41,080
with slangs so at the beginning then a

703
00:35:41,080 --> 00:35:43,000
begin block during compile time if you

704
00:35:43,000 --> 00:35:45,370
print out the keys of percent star lang

705
00:35:45,370 --> 00:35:47,740
you'll see Perl six grammar Perl six

706
00:35:47,740 --> 00:35:50,410
actions and all of the things that are

707
00:35:50,410 --> 00:35:54,990
being used to parse your current program

708
00:35:56,010 --> 00:35:58,720
they're also available in variables

709
00:35:58,720 --> 00:36:01,450
called dollar tilde named after the

710
00:36:01,450 --> 00:36:03,760
different languages so dollar till

711
00:36:03,760 --> 00:36:06,430
domain refers to the parser of the main

712
00:36:06,430 --> 00:36:09,490
program and you can get the grammar you

713
00:36:09,490 --> 00:36:11,080
can get the grammar and you can get the

714
00:36:11,080 --> 00:36:16,270
actions so if you want to see this by

715
00:36:16,270 --> 00:36:17,530
the way it's called the language braid

716
00:36:17,530 --> 00:36:20,290
so all these different languages are

717
00:36:20,290 --> 00:36:21,970
being used together to parse your Perl

718
00:36:21,970 --> 00:36:24,310
six program so if you want to change one

719
00:36:24,310 --> 00:36:26,050
of them well first if you want to see

720
00:36:26,050 --> 00:36:27,790
what they look like you can say - -

721
00:36:27,790 --> 00:36:30,130
target equals parse and you'll see the

722
00:36:30,130 --> 00:36:31,840
parse tree that's generated while your

723
00:36:31,840 --> 00:36:35,770
Perl six program is being parsed then if

724
00:36:35,770 --> 00:36:37,690
you look in the source for Perl six you

725
00:36:37,690 --> 00:36:39,580
can see the definitions of these and

726
00:36:39,580 --> 00:36:41,710
they'd look just like the grammar that

727
00:36:41,710 --> 00:36:47,650
we just made up so you might see so they

728
00:36:47,650 --> 00:36:49,090
have these things like statement

729
00:36:49,090 --> 00:36:52,660
statement list name identifier and if

730
00:36:52,660 --> 00:36:54,610
you want to modify it like let's say

731
00:36:54,610 --> 00:36:56,440
instead of sub we want to use the word

732
00:36:56,440 --> 00:37:01,990
lambda then essentially you can redefine

733
00:37:01,990 --> 00:37:04,210
the token and you can say this token now

734
00:37:04,210 --> 00:37:05,920
instead of matching the string lambda

735
00:37:05,920 --> 00:37:07,960
matches the string the set of sub

736
00:37:07,960 --> 00:37:11,580
matches the string lambda

737
00:37:12,880 --> 00:37:15,640
very quickly there's a handy operator

738
00:37:15,640 --> 00:37:17,950
for taking a grammar just like you can

739
00:37:17,950 --> 00:37:20,859
take a you can take a class and apply we

740
00:37:20,859 --> 00:37:21,970
just saw something called a partial

741
00:37:21,970 --> 00:37:24,759
class which is like a little piece of a

742
00:37:24,759 --> 00:37:27,729
role so Perl 6 has something called but

743
00:37:27,729 --> 00:37:29,769
which says make this little anonymous

744
00:37:29,769 --> 00:37:33,519
role that has these methods and and

745
00:37:33,519 --> 00:37:35,680
override those methods in this

746
00:37:35,680 --> 00:37:38,920
particular object and you could do the

747
00:37:38,920 --> 00:37:41,859
same thing with grammars where you can

748
00:37:41,859 --> 00:37:45,759
override a few tokens in a grammar so

749
00:37:45,759 --> 00:37:49,420
long story short you say lang mein

750
00:37:49,420 --> 00:37:53,349
equals the main grammar but this is what

751
00:37:53,349 --> 00:37:57,789
my subs look like they start with lambda

752
00:37:57,789 --> 00:38:01,349
instead of starting with sub

753
00:38:02,540 --> 00:38:04,910
so the sort of a long explanation for

754
00:38:04,910 --> 00:38:06,290
something that sort of makes sense at

755
00:38:06,290 --> 00:38:08,360
the end the but just kind of changes one

756
00:38:08,360 --> 00:38:09,950
little piece of it I'd been gonna finish

757
00:38:09,950 --> 00:38:11,390
real quick I'm almost at a time and then

758
00:38:11,390 --> 00:38:15,050
I'll see if I can take a question and

759
00:38:15,050 --> 00:38:16,790
then after that you could say lamda foo

760
00:38:16,790 --> 00:38:18,950
and instead of saying sub foo and it

761
00:38:18,950 --> 00:38:21,140
will declare a sub for you and by the

762
00:38:21,140 --> 00:38:23,030
way if you put it somewhere else these

763
00:38:23,030 --> 00:38:24,440
changes to the grammar are lexically

764
00:38:24,440 --> 00:38:27,500
scoped so inside a scope you can use the

765
00:38:27,500 --> 00:38:30,890
grammar you just made up there are a few

766
00:38:30,890 --> 00:38:33,410
examples of slangs in the ecosystem

767
00:38:33,410 --> 00:38:36,530
already I won't talk too much about

768
00:38:36,530 --> 00:38:39,770
those but you can look them up there's

769
00:38:39,770 --> 00:38:42,770
still some work to be done or syntax for

770
00:38:42,770 --> 00:38:46,970
using slangs but all in all they're

771
00:38:46,970 --> 00:38:50,420
there they exist and in conclusion we've

772
00:38:50,420 --> 00:38:54,560
seen some examples of creating informal

773
00:38:54,560 --> 00:38:58,490
dsls using changes to the syntax by

774
00:38:58,490 --> 00:39:00,440
parsing something externally or by

775
00:39:00,440 --> 00:39:03,470
modifying row six itself so thank you

776
00:39:03,470 --> 00:39:05,799
very much

777
00:39:10,480 --> 00:39:13,040
matter time come talk to me afterwards

778
00:39:13,040 --> 00:39:15,970
if you have questions

