1
00:00:03,240 --> 00:00:06,640
so this is on wire guard which is a new

2
00:00:06,640 --> 00:00:10,799
VPN which aims to be fast modern secure

3
00:00:10,799 --> 00:00:13,660
so first a little bit a background about

4
00:00:13,660 --> 00:00:18,400
myself my background is in exploitation

5
00:00:18,400 --> 00:00:22,210
and kernel vulnerabilities and offensive

6
00:00:22,210 --> 00:00:25,260
Security's finding bugs exploiting bugs

7
00:00:25,260 --> 00:00:27,760
but I've done a lot of development as

8
00:00:27,760 --> 00:00:33,340
well and in researching other projects I

9
00:00:33,340 --> 00:00:35,470
see the same types of bugs come up over

10
00:00:35,470 --> 00:00:36,879
and over same types of fundamental

11
00:00:36,879 --> 00:00:40,299
problems and seeing that secure tunnels

12
00:00:40,299 --> 00:00:41,920
are such an important element to have a

13
00:00:41,920 --> 00:00:44,860
networks I decided to take what I've

14
00:00:44,860 --> 00:00:47,290
learned from doing offensive security

15
00:00:47,290 --> 00:00:49,570
and try and make something really simple

16
00:00:49,570 --> 00:00:55,059
and nice that you can use so what is

17
00:00:55,059 --> 00:00:57,250
wire guard it's a layer 3 network tunnel

18
00:00:57,250 --> 00:01:02,199
so it's for only IP not for layer 2 not

19
00:01:02,199 --> 00:01:04,569
for Ethernet just a layer 3 network

20
00:01:04,569 --> 00:01:06,640
tunnel and as we'll see throughout this

21
00:01:06,640 --> 00:01:08,830
presentation it makes a lot of choices

22
00:01:08,830 --> 00:01:11,320
like that it's only for layer 3 it only

23
00:01:11,320 --> 00:01:13,180
does particular things because it's

24
00:01:13,180 --> 00:01:16,150
opinionated it's made with a series of

25
00:01:16,150 --> 00:01:18,340
design considerations where the choice

26
00:01:18,340 --> 00:01:20,140
has been made for you in a lot of ways

27
00:01:20,140 --> 00:01:23,920
but from these boiled down choices we

28
00:01:23,920 --> 00:01:25,930
make nice building blocks that then you

29
00:01:25,930 --> 00:01:28,980
can make big complicated systems out of

30
00:01:28,980 --> 00:01:32,140
it lives in the Linux kernel for

31
00:01:32,140 --> 00:01:35,020
performance and for good integration but

32
00:01:35,020 --> 00:01:36,360
we've got some cross-platform

33
00:01:36,360 --> 00:01:39,730
implementations and in the works in

34
00:01:39,730 --> 00:01:42,580
languages like rust and go but for at

35
00:01:42,580 --> 00:01:44,080
the moment lives in the Linux kernel run

36
00:01:44,080 --> 00:01:48,400
in see it's udp-based and so it it can

37
00:01:48,400 --> 00:01:50,320
live on the real internet punching

38
00:01:50,320 --> 00:01:52,080
through firewalls

39
00:01:52,080 --> 00:01:55,450
we use modern cryptography but we're

40
00:01:55,450 --> 00:01:58,140
very careful to use conservative

41
00:01:58,140 --> 00:02:02,290
cryptography proven principles nothing

42
00:02:02,290 --> 00:02:06,490
too newfangled and the project as a

43
00:02:06,490 --> 00:02:09,399
whole has a real emphasis on being very

44
00:02:09,399 --> 00:02:12,100
simple easy to understand concepts easy

45
00:02:12,100 --> 00:02:15,010
to understand code just trying to make a

46
00:02:15,010 --> 00:02:15,580
nice

47
00:02:15,580 --> 00:02:19,840
minimal nice minimal structure the

48
00:02:19,840 --> 00:02:23,020
authentication model aims to be like SSH

49
00:02:23,020 --> 00:02:26,920
and SSH you usually share keys by

50
00:02:26,920 --> 00:02:29,560
sending your public key through an

51
00:02:29,560 --> 00:02:31,870
encrypted email or through some other

52
00:02:31,870 --> 00:02:34,450
mechanism and you know you have simple

53
00:02:34,450 --> 00:02:35,830
public keys that you copy and paste

54
00:02:35,830 --> 00:02:38,680
around I'm sure all you guys use SSH so

55
00:02:38,680 --> 00:02:40,780
why are guard tries to be as easy as

56
00:02:40,780 --> 00:02:41,080
that

57
00:02:41,080 --> 00:02:45,520
but for VPN in general its aims to be a

58
00:02:45,520 --> 00:02:49,330
replacement for Open VPN and IPSec and

59
00:02:49,330 --> 00:02:52,600
the various other VPN technologies that

60
00:02:52,600 --> 00:02:55,330
are out there some that live in kernels

61
00:02:55,330 --> 00:02:57,820
some that live in in user space why our

62
00:02:57,820 --> 00:02:59,770
guard tries to replace most of that with

63
00:02:59,770 --> 00:03:04,750
something a lot simpler most of all wire

64
00:03:04,750 --> 00:03:07,090
guard is easily auditable when you look

65
00:03:07,090 --> 00:03:09,520
at Open VPN it's a hundred sixteen

66
00:03:09,520 --> 00:03:12,220
thousand lines of code plus all of open

67
00:03:12,220 --> 00:03:16,060
SSL and so maybe you could make that

68
00:03:16,060 --> 00:03:19,600
codebase secure eventually maybe you

69
00:03:19,600 --> 00:03:21,489
need to pay a lot of people a lot of

70
00:03:21,489 --> 00:03:23,769
money to read all that and audit a big

71
00:03:23,769 --> 00:03:27,820
project the Linux XFR M layer which does

72
00:03:27,820 --> 00:03:30,310
IPSec is thirteen thousand lines of code

73
00:03:30,310 --> 00:03:32,560
plus something like strongswan for the

74
00:03:32,560 --> 00:03:34,600
key exchange which itself is four

75
00:03:34,600 --> 00:03:37,470
hundred five thousand lines of code and

76
00:03:37,470 --> 00:03:39,730
I mean these are these are you know

77
00:03:39,730 --> 00:03:41,440
great projects with smart people who

78
00:03:41,440 --> 00:03:44,080
have worked on them but this is a lot of

79
00:03:44,080 --> 00:03:47,769
code to read and we're talking about C

80
00:03:47,769 --> 00:03:50,830
code and so this is hard to really be

81
00:03:50,830 --> 00:03:53,260
sure that you're using somebody secure

82
00:03:53,260 --> 00:03:54,580
soft ether is kind of a

83
00:03:54,580 --> 00:03:56,230
jack-of-all-trades solution that

84
00:03:56,230 --> 00:03:59,530
supports Open VPN supports IPSec

85
00:03:59,530 --> 00:04:02,019
supports all sorts of things carriage of

86
00:04:02,019 --> 00:04:04,030
29,000 dollars of code wire guard is

87
00:04:04,030 --> 00:04:07,000
under 4,000 lines of code which means

88
00:04:07,000 --> 00:04:09,070
everybody in this room can sit down to

89
00:04:09,070 --> 00:04:11,620
read the entire code base in one sitting

90
00:04:11,620 --> 00:04:14,350
in an afternoon understand it security

91
00:04:14,350 --> 00:04:16,690
experts can read it just for fun because

92
00:04:16,690 --> 00:04:20,320
it's short enough that it's still fun so

93
00:04:20,320 --> 00:04:21,970
that it actually gets some eyeballs so

94
00:04:21,970 --> 00:04:25,539
just to put this in perspective in the

95
00:04:25,539 --> 00:04:28,410
in the solar system of VPNs

96
00:04:28,410 --> 00:04:35,040
I guess we're Pluto okay it's also

97
00:04:35,040 --> 00:04:38,670
really simple to use rather than say

98
00:04:38,670 --> 00:04:43,280
that complicated IP SEC X frm system or

99
00:04:43,280 --> 00:04:46,650
openvpn Damons with y regard you just

100
00:04:46,650 --> 00:04:49,560
get a normal network interface that you

101
00:04:49,560 --> 00:04:51,360
can administer using all the tools you

102
00:04:51,360 --> 00:04:55,170
already know with the IP route etc so to

103
00:04:55,170 --> 00:04:57,420
add a wire guard interface see IP link

104
00:04:57,420 --> 00:04:59,850
add just like you would with any other

105
00:04:59,850 --> 00:05:01,770
kind of virtual interface to set the

106
00:05:01,770 --> 00:05:04,290
address IP address or I have come fig if

107
00:05:04,290 --> 00:05:05,360
you like that

108
00:05:05,360 --> 00:05:08,310
routing it's the same way and you can

109
00:05:08,310 --> 00:05:12,030
use IP tables if you're into old-style

110
00:05:12,030 --> 00:05:14,190
host based authentication you can even

111
00:05:14,190 --> 00:05:17,010
use Etsy hosts you can bind to the

112
00:05:17,010 --> 00:05:20,100
addresses of that interface because with

113
00:05:20,100 --> 00:05:21,960
wire guard you just have the interface

114
00:05:21,960 --> 00:05:26,880
it's a simple fundamental concept and it

115
00:05:26,880 --> 00:05:28,290
allows you to use all the things that

116
00:05:28,290 --> 00:05:29,510
you already know about

117
00:05:29,510 --> 00:05:32,250
so everything that ordinary ordinarily

118
00:05:32,250 --> 00:05:34,530
builds on top of a network interface

119
00:05:34,530 --> 00:05:38,250
like eth0 wlan0 you can build on top of

120
00:05:38,250 --> 00:05:41,430
WG zero for wire guard so you don't

121
00:05:41,430 --> 00:05:43,110
really have to learn that much that's

122
00:05:43,110 --> 00:05:45,660
new the other head

123
00:05:45,660 --> 00:05:50,460
wire guard is a bit blasphemous IPSec is

124
00:05:50,460 --> 00:05:53,520
is nice in a lot of ways it was made by

125
00:05:53,520 --> 00:05:57,330
a big committee it was engineered by a

126
00:05:57,330 --> 00:05:59,250
lot of people and it does all the nice

127
00:05:59,250 --> 00:06:02,220
layering in a very pristine way a lot of

128
00:06:02,220 --> 00:06:04,320
people looked into which component

129
00:06:04,320 --> 00:06:06,000
should have which responsibilities how

130
00:06:06,000 --> 00:06:08,820
to separate all this out and it's nice

131
00:06:08,820 --> 00:06:11,820
but it's also super complicated hard to

132
00:06:11,820 --> 00:06:14,010
implement prone to bugs if you ever

133
00:06:14,010 --> 00:06:15,930
tried to set it up you can't even wrap

134
00:06:15,930 --> 00:06:17,340
your mind around all the different

135
00:06:17,340 --> 00:06:20,640
layers and so why are guard actually

136
00:06:20,640 --> 00:06:23,190
breaks these these networking

137
00:06:23,190 --> 00:06:25,470
assumptions from the 90s where you have

138
00:06:25,470 --> 00:06:29,100
these nice layers and instead we do

139
00:06:29,100 --> 00:06:31,740
something that's on the surface wrong we

140
00:06:31,740 --> 00:06:34,590
smush everything together and then from

141
00:06:34,590 --> 00:06:35,850
there we try and come up with good

142
00:06:35,850 --> 00:06:38,789
engineering solutions to to regain the

143
00:06:38,789 --> 00:06:41,199
coherence

144
00:06:41,199 --> 00:06:43,810
and so that way it's it's remains simple

145
00:06:43,810 --> 00:06:46,210
but it still works and it still has a

146
00:06:46,210 --> 00:06:51,849
solid foundation so how do we do this

147
00:06:51,849 --> 00:06:54,090
the fundamental idea of wire guard is

148
00:06:54,090 --> 00:06:58,629
cryptokey routing so the idea here is

149
00:06:58,629 --> 00:07:02,409
you have a peer and you have a list of

150
00:07:02,409 --> 00:07:04,599
IP addresses that that peer is allowed

151
00:07:04,599 --> 00:07:07,990
to be and the peer is identified by a

152
00:07:07,990 --> 00:07:09,610
public key and so you have a mapping

153
00:07:09,610 --> 00:07:11,860
always between public keys that are used

154
00:07:11,860 --> 00:07:15,699
and IP addresses that are used so more

155
00:07:15,699 --> 00:07:18,159
generally the wire guard interface WG

156
00:07:18,159 --> 00:07:21,159
zero itself has its own private key it

157
00:07:21,159 --> 00:07:24,099
has a listening UDP port and it has a

158
00:07:24,099 --> 00:07:26,590
list of peers that it can talk to then

159
00:07:26,590 --> 00:07:28,840
each peer is identified by its public

160
00:07:28,840 --> 00:07:32,650
key this list of allowed IP is that that

161
00:07:32,650 --> 00:07:34,710
public key is allowed to be and

162
00:07:34,710 --> 00:07:37,569
optionally as we'll see you later the

163
00:07:37,569 --> 00:07:39,610
end point on the Internet of the other

164
00:07:39,610 --> 00:07:43,560
UDP port that you're talking to

165
00:07:43,590 --> 00:07:46,050
so just to drive this home the the

166
00:07:46,050 --> 00:07:48,669
fundamental idea here is relation

167
00:07:48,669 --> 00:07:50,379
between the public key and the IP

168
00:07:50,379 --> 00:07:54,400
address is super important so here's

169
00:07:54,400 --> 00:07:56,589
what a configuration might look at look

170
00:07:56,589 --> 00:08:00,339
like a server has the interface section

171
00:08:00,339 --> 00:08:02,680
with its private key and it's listen

172
00:08:02,680 --> 00:08:04,690
port and then this happens to have two

173
00:08:04,690 --> 00:08:09,009
peers and for the first peer it's

174
00:08:09,009 --> 00:08:11,560
allowed to be that 10.19 T to address

175
00:08:11,560 --> 00:08:14,740
and the other ten that 192 address bus

176
00:08:14,740 --> 00:08:18,219
last 24 so the whole subnet the next

177
00:08:18,219 --> 00:08:21,520
peer gets its slash 32 and a slash 16

178
00:08:21,520 --> 00:08:25,599
and so those public keys when talking to

179
00:08:25,599 --> 00:08:28,150
the server can only send IP addresses

180
00:08:28,150 --> 00:08:30,699
can only some packets as IP addresses in

181
00:08:30,699 --> 00:08:34,719
those range on the other side a client

182
00:08:34,719 --> 00:08:37,390
has a configuration with again interface

183
00:08:37,390 --> 00:08:38,919
that has a private key in the listen

184
00:08:38,919 --> 00:08:43,929
port and it has a block for a peer

185
00:08:43,929 --> 00:08:46,510
that's the server and so it has the

186
00:08:46,510 --> 00:08:48,970
server's public key it has the endpoint

187
00:08:48,970 --> 00:08:52,180
of the server and it trusts the server

188
00:08:52,180 --> 00:08:54,730
to send it any IP for

189
00:08:54,730 --> 00:08:58,089
example maybe the server is a gateway to

190
00:08:58,089 --> 00:09:01,120
the Internet and so it's forwarding

191
00:09:01,120 --> 00:09:03,040
packets from any IP address on the

192
00:09:03,040 --> 00:09:06,310
Internet in that case it wants to allow

193
00:09:06,310 --> 00:09:10,180
any IP from the server now you'll notice

194
00:09:10,180 --> 00:09:11,800
that the server doesn't list any

195
00:09:11,800 --> 00:09:14,290
endpoints of the peers because it

196
00:09:14,290 --> 00:09:15,550
doesn't know them it's the server it's

197
00:09:15,550 --> 00:09:19,470
waiting for the client to connect to it

198
00:09:19,470 --> 00:09:22,180
but what happens is whenever the server

199
00:09:22,180 --> 00:09:25,120
gets an authenticated message from a

200
00:09:25,120 --> 00:09:27,550
client then it'll learn the latest end

201
00:09:27,550 --> 00:09:30,010
point of that client for sending reply

202
00:09:30,010 --> 00:09:32,529
packets so in that way clients can roam

203
00:09:32,529 --> 00:09:34,959
freely from different source IP

204
00:09:34,959 --> 00:09:37,899
addresses if you've ever used mush it

205
00:09:37,899 --> 00:09:43,720
works exactly like that so how does this

206
00:09:43,720 --> 00:09:46,600
work at the API level user space sends a

207
00:09:46,600 --> 00:09:49,329
packet using the census call then it

208
00:09:49,329 --> 00:09:51,430
goes to the ordinary Linux networking

209
00:09:51,430 --> 00:09:53,829
layer that decides ok this packet should

210
00:09:53,829 --> 00:09:57,040
go to the W g0 interface so now it's an

211
00:09:57,040 --> 00:09:59,610
R code now it's in the wire Guard driver

212
00:09:59,610 --> 00:10:02,319
wire guard looks at the destination IP

213
00:10:02,319 --> 00:10:05,350
address of that packet and says that

214
00:10:05,350 --> 00:10:07,449
destination IP address corresponds to

215
00:10:07,449 --> 00:10:10,000
this public key then it looks up what

216
00:10:10,000 --> 00:10:12,160
current session is used with that public

217
00:10:12,160 --> 00:10:14,139
key and encrypts it for that and sends

218
00:10:14,139 --> 00:10:17,500
it off to the endpoint in the reverse

219
00:10:17,500 --> 00:10:20,920
direction when the UDP socket receives

220
00:10:20,920 --> 00:10:23,170
an encrypted packet it decrypts it and

221
00:10:23,170 --> 00:10:28,000
learns for which public key it should

222
00:10:28,000 --> 00:10:29,410
use a key session for it then it

223
00:10:29,410 --> 00:10:31,510
inspects the source IP of that decrypted

224
00:10:31,510 --> 00:10:33,490
packet and says is that public key

225
00:10:33,490 --> 00:10:35,319
allowed to be sending packets as that

226
00:10:35,319 --> 00:10:38,290
source IP and if it is then it goes on

227
00:10:38,290 --> 00:10:40,120
to the interface and if not then it's

228
00:10:40,120 --> 00:10:46,060
dropped so all of this can be configured

229
00:10:46,060 --> 00:10:49,810
with very easy command-line tools right

230
00:10:49,810 --> 00:10:52,089
now it's it's the WG utility at some

231
00:10:52,089 --> 00:10:53,800
point this will be folded into the IP

232
00:10:53,800 --> 00:10:57,040
route to IP utility for now just WG very

233
00:10:57,040 --> 00:11:01,420
simple WG set W t0 you give the listen

234
00:11:01,420 --> 00:11:04,839
port the private key the peer plus its

235
00:11:04,839 --> 00:11:06,819
public key it's the loud IP as the

236
00:11:06,819 --> 00:11:08,390
endpoint and so forth

237
00:11:08,390 --> 00:11:10,800
it has that very simple configuration

238
00:11:10,800 --> 00:11:13,110
syntax as we saw before kind of the any

239
00:11:13,110 --> 00:11:15,930
syntax and so you could set config and

240
00:11:15,930 --> 00:11:18,780
get config WG Show gives you the nice

241
00:11:18,780 --> 00:11:21,240
colorize acts ASCII output and there are

242
00:11:21,240 --> 00:11:24,030
also various sub commands of that to get

243
00:11:24,030 --> 00:11:26,250
output that's good for parsing and in

244
00:11:26,250 --> 00:11:31,350
scripts for generating keys just W dgeni

245
00:11:31,350 --> 00:11:33,930
key to make a public key from a private

246
00:11:33,930 --> 00:11:37,290
key you pipe the private key into WG pub

247
00:11:37,290 --> 00:11:40,490
key and you get out the public key so

248
00:11:40,490 --> 00:11:44,520
very simple basic interface but from

249
00:11:44,520 --> 00:11:46,620
that you can setup tunnels to all sorts

250
00:11:46,620 --> 00:11:48,300
of peers in a super easy straightforward

251
00:11:48,300 --> 00:11:51,900
way and all the issues of cryptography

252
00:11:51,900 --> 00:11:55,140
session management etc are just handled

253
00:11:55,140 --> 00:11:56,960
transparently under the surface for you

254
00:11:56,960 --> 00:11:59,940
so to the system admin the whole

255
00:11:59,940 --> 00:12:02,400
interface appears stateless you just set

256
00:12:02,400 --> 00:12:05,840
it up here the peers and then it works

257
00:12:05,840 --> 00:12:10,110
and so because we have this relation

258
00:12:10,110 --> 00:12:13,140
between the public keys and and the IP

259
00:12:13,140 --> 00:12:15,690
addresses we know that if it comes from

260
00:12:15,690 --> 00:12:19,380
the wgz our interface and it's from this

261
00:12:19,380 --> 00:12:21,390
particular IP address then a must be

262
00:12:21,390 --> 00:12:23,310
from Yoshii through the tunnel it must

263
00:12:23,310 --> 00:12:27,900
be because it's from his public key so

264
00:12:27,900 --> 00:12:29,610
then with IP tables you can already

265
00:12:29,610 --> 00:12:31,440
start to imagine what your firewall

266
00:12:31,440 --> 00:12:34,440
rules are like you match on the input

267
00:12:34,440 --> 00:12:38,190
device of w0 the source address and then

268
00:12:38,190 --> 00:12:40,530
that's all you need so all the things

269
00:12:40,530 --> 00:12:42,930
you already know just layer nicely on

270
00:12:42,930 --> 00:12:46,589
top of this so as i said it's totally

271
00:12:46,589 --> 00:12:48,870
stateless you set it up and it works you

272
00:12:48,870 --> 00:12:50,430
just add the interface you can add as

273
00:12:50,430 --> 00:12:51,960
many interfaces as you want you can

274
00:12:51,960 --> 00:12:53,990
configure multiple peers per interface

275
00:12:53,990 --> 00:12:57,750
as I mentioned the endpoints just a roam

276
00:12:57,750 --> 00:13:02,070
so on 3G this is especially nice when

277
00:13:02,070 --> 00:13:03,750
you're going between different IP

278
00:13:03,750 --> 00:13:05,550
addresses your connections keep working

279
00:13:05,550 --> 00:13:08,010
on a laptop it's nice if you put your

280
00:13:08,010 --> 00:13:09,900
laptop to sleep in one network and turn

281
00:13:09,900 --> 00:13:12,240
on on the other it just starts working

282
00:13:12,240 --> 00:13:13,770
again automatically and you have the

283
00:13:13,770 --> 00:13:15,839
same IP address this before inside the

284
00:13:15,839 --> 00:13:19,440
tunnel and the identity is these public

285
00:13:19,440 --> 00:13:21,810
keys are really short

286
00:13:21,810 --> 00:13:24,420
they're 32 bytes and we encode it as

287
00:13:24,420 --> 00:13:28,019
base64 so I think it's 44 characters and

288
00:13:28,019 --> 00:13:30,870
so you can paste them around for for

289
00:13:30,870 --> 00:13:32,120
doing key exchange through any

290
00:13:32,120 --> 00:13:34,709
out-of-band mechanism we're not trying

291
00:13:34,709 --> 00:13:37,079
to handle that problem here because

292
00:13:37,079 --> 00:13:39,089
people are already doing that with

293
00:13:39,089 --> 00:13:43,379
things like SSH and GPG and all sorts of

294
00:13:43,379 --> 00:13:47,519
other mechanisms for that okay so before

295
00:13:47,519 --> 00:13:49,709
we go deep in how all this works I just

296
00:13:49,709 --> 00:13:51,540
want to show a demo of what it looks

297
00:13:51,540 --> 00:13:54,389
like to set up a wire interface you get

298
00:13:54,389 --> 00:14:00,089
the idea so we have pure a left pure B

299
00:14:00,089 --> 00:14:03,529
on the right and they're connected using

300
00:14:03,529 --> 00:14:05,910
virtual Ethernet so you can pretend

301
00:14:05,910 --> 00:14:08,399
that's the Internet and we'll set up

302
00:14:08,399 --> 00:14:11,749
some tunnels so what's this look like

303
00:14:11,749 --> 00:14:14,970
okay so we generate a private key over

304
00:14:14,970 --> 00:14:16,680
there we generate a private key over

305
00:14:16,680 --> 00:14:18,480
there and when we cat it that's the

306
00:14:18,480 --> 00:14:20,970
private key super-short we derive the

307
00:14:20,970 --> 00:14:23,339
public key from the private key we do

308
00:14:23,339 --> 00:14:27,029
the same over there and now we add the

309
00:14:27,029 --> 00:14:30,600
wire grid interface we set an IP for the

310
00:14:30,600 --> 00:14:33,389
wire guard interface which again using

311
00:14:33,389 --> 00:14:37,230
the IP route to tool things every system

312
00:14:37,230 --> 00:14:40,290
admin already knows now we set up the

313
00:14:40,290 --> 00:14:42,839
peer so we give the private key of our

314
00:14:42,839 --> 00:14:46,110
interface as private and then we set the

315
00:14:46,110 --> 00:14:48,300
interface up now we'll do the exact same

316
00:14:48,300 --> 00:14:52,370
thing over here we add the wd0 interface

317
00:14:52,370 --> 00:14:58,470
we give it the IP address we give it the

318
00:14:58,470 --> 00:15:01,790
private key of its interface

319
00:15:02,150 --> 00:15:05,900
and we set it up okay so now we have to

320
00:15:05,900 --> 00:15:08,050
tell the two peers about each other so

321
00:15:08,050 --> 00:15:10,610
first when we type IP address we see

322
00:15:10,610 --> 00:15:12,770
that it's just WG zero there it's just a

323
00:15:12,770 --> 00:15:15,920
normal interface eth0 is our internet

324
00:15:15,920 --> 00:15:19,700
interface our external interface if you

325
00:15:19,700 --> 00:15:23,180
will and so it's it's all in there just

326
00:15:23,180 --> 00:15:24,740
like another interface that you've seen

327
00:15:24,740 --> 00:15:28,930
before nothing nothing too remarkable

328
00:15:29,140 --> 00:15:32,450
okay so we type WG and we get the

329
00:15:32,450 --> 00:15:32,990
information

330
00:15:32,990 --> 00:15:35,840
each currently has about itself but now

331
00:15:35,840 --> 00:15:37,970
we tell it about the other so first we

332
00:15:37,970 --> 00:15:40,520
copy the public key from one as a peer

333
00:15:40,520 --> 00:15:42,890
for the other and we say that that peer

334
00:15:42,890 --> 00:15:47,240
is allowed to be 10 - OH - OH - and it's

335
00:15:47,240 --> 00:15:51,830
Internet endpoint is 192 168 1.25 180 -

336
00:15:51,830 --> 00:15:55,610
oh we do the reverse thing on the other

337
00:15:55,610 --> 00:15:59,180
side we make up here we copy and paste

338
00:15:59,180 --> 00:16:03,260
the public key for that peer we give it

339
00:16:03,260 --> 00:16:05,390
the allowed IP address for inside the

340
00:16:05,390 --> 00:16:09,320
tunnel and we give it the Internet

341
00:16:09,320 --> 00:16:11,300
endpoint one and two and sixty-eight one

342
00:16:11,300 --> 00:16:14,060
one five one eight - will so now the

343
00:16:14,060 --> 00:16:15,470
peers are set up they know about each

344
00:16:15,470 --> 00:16:17,960
other and now we can simply ping within

345
00:16:17,960 --> 00:16:20,200
the interface and it works and that's it

346
00:16:20,200 --> 00:16:22,850
we didn't have to set a daemon we didn't

347
00:16:22,850 --> 00:16:24,950
have to set a state it just works and

348
00:16:24,950 --> 00:16:26,090
now they know about each other

349
00:16:26,090 --> 00:16:29,300
they've done the handshake so pretty

350
00:16:29,300 --> 00:16:32,570
pretty simple situation and that's about

351
00:16:32,570 --> 00:16:35,270
in - the interface of wire guard there's

352
00:16:35,270 --> 00:16:37,610
not a whole lot more than that but from

353
00:16:37,610 --> 00:16:39,560
a very basic building block you can

354
00:16:39,560 --> 00:16:41,510
start layering some really neat things

355
00:16:41,510 --> 00:16:48,050
so as I mentioned simple composable tool

356
00:16:48,050 --> 00:16:52,580
this w g WG utility it's already started

357
00:16:52,580 --> 00:16:54,410
to get integration to the various

358
00:16:54,410 --> 00:16:56,630
network management utilities there's an

359
00:16:56,630 --> 00:16:59,600
up/down plugin for it it's already in

360
00:16:59,600 --> 00:17:03,020
open wrt and lead it's there's a nice

361
00:17:03,020 --> 00:17:07,160
Lucci web interface for it they're open

362
00:17:07,160 --> 00:17:10,790
RC supports it with net IFR C it's part

363
00:17:10,790 --> 00:17:15,020
of the whole NIC so ask system there's a

364
00:17:15,020 --> 00:17:15,980
work-in-progress - in

365
00:17:15,980 --> 00:17:17,689
right into system D Network D and

366
00:17:17,689 --> 00:17:19,099
there's also another work-in-progress

367
00:17:19,099 --> 00:17:21,079
to integrate it into network manager if

368
00:17:21,079 --> 00:17:24,890
that's your thing and and so it's it's

369
00:17:24,890 --> 00:17:28,069
it's being integrated I wrote a very

370
00:17:28,069 --> 00:17:30,830
simple shell script called WG quick

371
00:17:30,830 --> 00:17:34,280
which is not a sophisticated tool it's

372
00:17:34,280 --> 00:17:37,010
just quick and dirty bash script that I

373
00:17:37,010 --> 00:17:39,080
use on a daily basis connecting to VPNs

374
00:17:39,080 --> 00:17:43,040
you just have WG quick up and WG quick

375
00:17:43,040 --> 00:17:45,919
down and then you define this config

376
00:17:45,919 --> 00:17:49,070
file which is the same for syntaxes WG

377
00:17:49,070 --> 00:17:52,760
but we add a couple keys like a we can

378
00:17:52,760 --> 00:17:55,130
run a post up in a post down script for

379
00:17:55,130 --> 00:17:58,850
DNS and it lives in su wire guard and

380
00:17:58,850 --> 00:18:01,299
then the name of your interface Kampf

381
00:18:01,299 --> 00:18:03,710
but again this is done a sophisticated

382
00:18:03,710 --> 00:18:05,360
utility a simple bash script that just

383
00:18:05,360 --> 00:18:08,240
uses all the other things and I like

384
00:18:08,240 --> 00:18:10,460
this and I distribute it and other

385
00:18:10,460 --> 00:18:12,650
people use it but because the building

386
00:18:12,650 --> 00:18:15,320
blocks are so basic you have more than

387
00:18:15,320 --> 00:18:17,419
enough license to make whatever other

388
00:18:17,419 --> 00:18:21,230
complex tool you want there also some

389
00:18:21,230 --> 00:18:24,169
nice network namespace tricks that you

390
00:18:24,169 --> 00:18:26,750
can do with wire guard the wire guard

391
00:18:26,750 --> 00:18:28,640
interface can live in one network

392
00:18:28,640 --> 00:18:31,010
namespace well the UDP socket that it

393
00:18:31,010 --> 00:18:32,840
uses to send the encrypted packets to

394
00:18:32,840 --> 00:18:35,120
the Internet lives in another namespace

395
00:18:35,120 --> 00:18:38,540
so a couple uses you could let a docker

396
00:18:38,540 --> 00:18:40,880
container connect via a wire guard you

397
00:18:40,880 --> 00:18:43,940
could you could only let your DHCP

398
00:18:43,940 --> 00:18:45,559
client touch to your physical interfaces

399
00:18:45,559 --> 00:18:47,990
but then your web browser can only see

400
00:18:47,990 --> 00:18:50,090
the wire guard interface and this is a

401
00:18:50,090 --> 00:18:51,799
nice alternative to the routing tricks

402
00:18:51,799 --> 00:18:54,140
which of course wire guard also supports

403
00:18:54,140 --> 00:18:56,000
but this is a nice alternative if you

404
00:18:56,000 --> 00:18:59,390
want some high security so for

405
00:18:59,390 --> 00:19:01,070
containers it would look like this you

406
00:19:01,070 --> 00:19:02,960
have your container namespace running

407
00:19:02,960 --> 00:19:06,350
whatever docker rocket and spawn stuff

408
00:19:06,350 --> 00:19:10,100
and you ping from that and then the WG

409
00:19:10,100 --> 00:19:11,540
zero interface and Cripps it and it

410
00:19:11,540 --> 00:19:14,360
sends the UDP ciphertext out of the

411
00:19:14,360 --> 00:19:16,730
namespace in the in a namespace through

412
00:19:16,730 --> 00:19:21,080
your actual Ethernet adapter and so to

413
00:19:21,080 --> 00:19:23,600
the container namespace itself all it

414
00:19:23,600 --> 00:19:26,510
sees is WG zero and local host of course

415
00:19:26,510 --> 00:19:29,150
but it doesn't see any other way of

416
00:19:29,150 --> 00:19:31,240
getting to the intern

417
00:19:31,240 --> 00:19:34,940
conversely if you just want a leak-free

418
00:19:34,940 --> 00:19:38,360
personal VPN for your web browser in the

419
00:19:38,360 --> 00:19:40,880
init namespace that you're doing all

420
00:19:40,880 --> 00:19:41,570
your working

421
00:19:41,570 --> 00:19:44,179
you only have WG zero and then you move

422
00:19:44,179 --> 00:19:47,570
your physical interfaces to some other

423
00:19:47,570 --> 00:19:51,289
name space where the socket lives and

424
00:19:51,289 --> 00:19:52,220
this is really nice because it

425
00:19:52,220 --> 00:19:56,080
guarantees that there won't be any leaks

426
00:19:56,080 --> 00:19:59,929
from your web browser outside of the

427
00:19:59,929 --> 00:20:01,520
wire interface because your web browser

428
00:20:01,520 --> 00:20:03,049
can't see any other interfaces in

429
00:20:03,049 --> 00:20:06,440
packets um all right so there are a lot

430
00:20:06,440 --> 00:20:08,809
of security principles that have gone

431
00:20:08,809 --> 00:20:11,059
into making la Garde to make it both

432
00:20:11,059 --> 00:20:12,710
small and simple as we've discussed but

433
00:20:12,710 --> 00:20:16,750
also I hope a well-written piece of code

434
00:20:16,750 --> 00:20:19,880
all the state that's required for wire

435
00:20:19,880 --> 00:20:22,700
guard to work is allocated when you add

436
00:20:22,700 --> 00:20:26,570
peers not when you're getting packets so

437
00:20:26,570 --> 00:20:29,059
this this eliminates a huge class of

438
00:20:29,059 --> 00:20:31,820
dynamic memory vulnerabilities why our

439
00:20:31,820 --> 00:20:33,169
guard simply just doesn't have them

440
00:20:33,169 --> 00:20:34,789
because we just don't use that

441
00:20:34,789 --> 00:20:36,320
programming technique that's prone to

442
00:20:36,320 --> 00:20:39,620
that vulnerabilities likewise all packet

443
00:20:39,620 --> 00:20:42,799
headers are fixed in length in each

444
00:20:42,799 --> 00:20:46,039
field has a fixed length and so we don't

445
00:20:46,039 --> 00:20:48,140
have to parse anything there's nothing

446
00:20:48,140 --> 00:20:50,120
to parse so there are no parser bugs

447
00:20:50,120 --> 00:20:53,840
because we have no parser there this is

448
00:20:53,840 --> 00:20:56,899
so ridiculously simple but in doing so

449
00:20:56,899 --> 00:20:59,059
we just eliminate a massive class of

450
00:20:59,059 --> 00:21:02,809
vulnerabilities and then the last one is

451
00:21:02,809 --> 00:21:05,240
a little bit more sophisticated to

452
00:21:05,240 --> 00:21:07,820
implement we don't want to modify any

453
00:21:07,820 --> 00:21:10,039
state of the program any type of state

454
00:21:10,039 --> 00:21:13,100
in a response to unauthenticated packets

455
00:21:13,100 --> 00:21:17,210
and this is important for preventing a

456
00:21:17,210 --> 00:21:20,360
lot of logic based former abilities if a

457
00:21:20,360 --> 00:21:22,070
packet is authenticated we just don't

458
00:21:22,070 --> 00:21:23,929
want to change any variables we want to

459
00:21:23,929 --> 00:21:25,669
reject it as soon as possible and move

460
00:21:25,669 --> 00:21:29,299
on so we'll go into how how we

461
00:21:29,299 --> 00:21:32,419
accomplish all this another principle is

462
00:21:32,419 --> 00:21:35,779
we want wire guard to be stealthy as as

463
00:21:35,779 --> 00:21:36,440
the

464
00:21:36,440 --> 00:21:39,890
as mentioned in the introduction I do a

465
00:21:39,890 --> 00:21:42,410
lot of offensive security and why regard

466
00:21:42,410 --> 00:21:44,270
actually grew out of an exfiltration

467
00:21:44,270 --> 00:21:47,930
method of a rootkit I was working on so

468
00:21:47,930 --> 00:21:52,660
needed to be super stealthy hide packets

469
00:21:52,660 --> 00:21:55,880
not be discoverable by scanners and so

470
00:21:55,880 --> 00:21:58,700
wire guard inherits all of this it turns

471
00:21:58,700 --> 00:22:00,260
out that a lot of those principles that

472
00:22:00,260 --> 00:22:02,150
are applied to offensive security are

473
00:22:02,150 --> 00:22:04,280
actually really good too in defending a

474
00:22:04,280 --> 00:22:07,910
network so wire guard doesn't reply to

475
00:22:07,910 --> 00:22:10,970
any unauthenticated packets so it's

476
00:22:10,970 --> 00:22:13,070
completely invisible to porch scanners

477
00:22:13,070 --> 00:22:14,870
on the network if you don't know it's

478
00:22:14,870 --> 00:22:17,320
there then you won't know what's there

479
00:22:17,320 --> 00:22:21,080
it's also not chatty so when two peers

480
00:22:21,080 --> 00:22:23,540
aren't sending data to each other it

481
00:22:23,540 --> 00:22:25,520
just goes to sleep and it doesn't send

482
00:22:25,520 --> 00:22:31,910
anything okay of course all of this

483
00:22:31,910 --> 00:22:34,280
wouldn't matter at all if the crypto was

484
00:22:34,280 --> 00:22:36,580
bad so we put a lot of effort into

485
00:22:36,580 --> 00:22:40,370
ensuring its solid crypto we use Trevor

486
00:22:40,370 --> 00:22:43,430
parens noise protocol framework which is

487
00:22:43,430 --> 00:22:45,470
now used by whatsapp and is starting to

488
00:22:45,470 --> 00:22:48,050
get some steam it has perfect forward

489
00:22:48,050 --> 00:22:50,000
secrecy so there's a new key every two

490
00:22:50,000 --> 00:22:54,680
minutes so if if the computers are

491
00:22:54,680 --> 00:22:57,110
compromised you can't get the static

492
00:22:57,110 --> 00:22:59,330
keys and then go back to see the

493
00:22:59,330 --> 00:23:01,100
information that was transferred because

494
00:23:01,100 --> 00:23:02,390
there's a new ephemeral key that's

495
00:23:02,390 --> 00:23:04,640
generated every two minutes it avoids

496
00:23:04,640 --> 00:23:07,570
key compromise impersonation which is

497
00:23:07,570 --> 00:23:09,890
important quality if someone steals your

498
00:23:09,890 --> 00:23:10,760
private key

499
00:23:10,760 --> 00:23:13,880
they can't impersonate anybody to you

500
00:23:13,880 --> 00:23:15,170
even though they have your private key

501
00:23:15,170 --> 00:23:16,850
so this is important if two principal

502
00:23:16,850 --> 00:23:19,400
there's identity hiding so when you

503
00:23:19,400 --> 00:23:21,080
identify yourself to another appear you

504
00:23:21,080 --> 00:23:22,990
don't actually send your public key in

505
00:23:22,990 --> 00:23:26,120
clear text it's actually encrypted so

506
00:23:26,120 --> 00:23:28,370
that only the recipient of your public

507
00:23:28,370 --> 00:23:30,410
key can read it so it's impossible to

508
00:23:30,410 --> 00:23:32,030
tell who is actually sending the message

509
00:23:32,030 --> 00:23:35,510
unless you're expecting the message of

510
00:23:35,510 --> 00:23:37,070
course we use authenticated encryption

511
00:23:37,070 --> 00:23:41,110
so not only is all the information

512
00:23:41,110 --> 00:23:43,730
private but we also ensure the integrity

513
00:23:43,730 --> 00:23:47,180
there's replay attack prevention while

514
00:23:47,180 --> 00:23:48,980
still allowing for

515
00:23:48,980 --> 00:23:50,720
the network to reorder packets as

516
00:23:50,720 --> 00:23:52,790
networks do but we prevent against

517
00:23:52,790 --> 00:23:56,000
replay and we use modern primitives we

518
00:23:56,000 --> 00:23:59,390
use curve 255 1/9 for elliptic curve

519
00:23:59,390 --> 00:24:01,880
diffie-hellman we use blake 2's for

520
00:24:01,880 --> 00:24:04,970
hashing chacha 20 poly 1 3 or 5 for

521
00:24:04,970 --> 00:24:06,080
authenticated encryption and when you

522
00:24:06,080 --> 00:24:08,930
sip hash for the hash tables now

523
00:24:08,930 --> 00:24:11,020
importantly there's no site fragility

524
00:24:11,020 --> 00:24:14,780
this is what we use and many of you who

525
00:24:14,780 --> 00:24:17,950
have set up I don't know TLS servers

526
00:24:17,950 --> 00:24:20,840
maybe some of you are happy to read this

527
00:24:20,840 --> 00:24:22,040
now that you don't have to set anything

528
00:24:22,040 --> 00:24:24,430
up maybe other of you think well maybe

529
00:24:24,430 --> 00:24:27,710
we want the choice of of using broken

530
00:24:27,710 --> 00:24:29,330
ciphers no you don't want the choice of

531
00:24:29,330 --> 00:24:31,310
using broken ciphers if a cipher is

532
00:24:31,310 --> 00:24:34,160
broken then you upgrade and you don't

533
00:24:34,160 --> 00:24:36,800
allow broken ciphers on your secure

534
00:24:36,800 --> 00:24:40,130
Network so I think this idea of cipher

535
00:24:40,130 --> 00:24:43,220
agility is and the cipher negotiation is

536
00:24:43,220 --> 00:24:45,710
really a concept from the 90s that has

537
00:24:45,710 --> 00:24:48,020
seen its course of course there'll be

538
00:24:48,020 --> 00:24:49,970
paths to upgrade to new versions if

539
00:24:49,970 --> 00:24:53,030
necessary but mixing primitives and

540
00:24:53,030 --> 00:24:54,950
allowing negotiation allowing insecure

541
00:24:54,950 --> 00:24:57,260
primitives is really not a good policy

542
00:24:57,260 --> 00:25:01,250
so these are the nicest ones for now and

543
00:25:01,250 --> 00:25:04,510
if they're ever not nice we'll change it

544
00:25:04,510 --> 00:25:06,740
ok so the key exchange we're running a

545
00:25:06,740 --> 00:25:09,440
little bit low on time so I'll go

546
00:25:09,440 --> 00:25:11,210
through this quickly here the key

547
00:25:11,210 --> 00:25:15,260
exchange is a one round-trip key

548
00:25:15,260 --> 00:25:17,750
exchange so the initiator sends a

549
00:25:17,750 --> 00:25:19,520
message to the responder your responder

550
00:25:19,520 --> 00:25:21,670
sends a message back to the initiator

551
00:25:21,670 --> 00:25:23,870
using these messages they do some

552
00:25:23,870 --> 00:25:26,270
calculation and they come up with a pair

553
00:25:26,270 --> 00:25:31,910
of symmetric keys for for ChaCha 21 for

554
00:25:31,910 --> 00:25:33,200
sending and one for receiving and then

555
00:25:33,200 --> 00:25:34,700
they can start to exchange transport

556
00:25:34,700 --> 00:25:36,530
data and because it's just one

557
00:25:36,530 --> 00:25:39,590
round-trip either side can initiate this

558
00:25:39,590 --> 00:25:43,220
at any point if if your laptop's just

559
00:25:43,220 --> 00:25:45,080
woken up from sleep it can just

560
00:25:45,080 --> 00:25:46,520
immediately fire it off and start again

561
00:25:46,520 --> 00:25:49,370
so there's no there's no session state

562
00:25:49,370 --> 00:25:51,080
that needs to be maintained long term

563
00:25:51,080 --> 00:25:52,820
because a new session can just be

564
00:25:52,820 --> 00:25:55,280
created super simply because it's one

565
00:25:55,280 --> 00:25:57,550
roundtrip

566
00:25:58,230 --> 00:26:01,960
okay so we have in this several sets of

567
00:26:01,960 --> 00:26:03,610
keys that are used there's the static

568
00:26:03,610 --> 00:26:06,190
public and private keys as we saw from

569
00:26:06,190 --> 00:26:09,040
the screencast but during the key

570
00:26:09,040 --> 00:26:10,690
exchange both sides generate an

571
00:26:10,690 --> 00:26:13,180
ephemeral key pair so this ensures the

572
00:26:13,180 --> 00:26:17,740
perfect forward secrecy the key exchange

573
00:26:17,740 --> 00:26:21,580
in general it's important that we keep

574
00:26:21,580 --> 00:26:24,010
this idea of not modifying anything if

575
00:26:24,010 --> 00:26:25,540
we don't get an encrypted pet if we

576
00:26:25,540 --> 00:26:27,670
don't get enough indicate a packet we

577
00:26:27,670 --> 00:26:30,700
want to keep fixed length headers and we

578
00:26:30,700 --> 00:26:32,200
want both sides to be able to change

579
00:26:32,200 --> 00:26:36,730
roles if necessary and we want to ignore

580
00:26:36,730 --> 00:26:42,250
all invalid handshake messages and so

581
00:26:42,250 --> 00:26:43,930
the way this is accomplished is by

582
00:26:43,930 --> 00:26:48,160
combining in some method the output of

583
00:26:48,160 --> 00:26:50,310
for elliptic curve diffie-hellman

584
00:26:50,310 --> 00:26:52,780
operations the first three make up was

585
00:26:52,780 --> 00:26:55,450
called the triple diffie-hellman some of

586
00:26:55,450 --> 00:26:56,680
you might be familiar with if you've

587
00:26:56,680 --> 00:26:58,890
ever read a spec for signal protocol and

588
00:26:58,890 --> 00:27:01,210
then we have a static static

589
00:27:01,210 --> 00:27:03,010
diffie-hellman in the first message so

590
00:27:03,010 --> 00:27:09,400
that it can be one round-trip and so

591
00:27:09,400 --> 00:27:11,500
without going into too much depth on

592
00:27:11,500 --> 00:27:13,540
this it might seem like it's really

593
00:27:13,540 --> 00:27:16,750
complicated but in fact it's super

594
00:27:16,750 --> 00:27:19,060
easily implemented the the key exchange

595
00:27:19,060 --> 00:27:23,260
itself is only 441 lines compared to

596
00:27:23,260 --> 00:27:26,040
strongswan which I think we said was

597
00:27:26,040 --> 00:27:30,480
40,000 lines 400,000 lines really big so

598
00:27:30,480 --> 00:27:35,410
441 lines for the key exchange very

599
00:27:35,410 --> 00:27:39,250
simple and as you might have noticed we

600
00:27:39,250 --> 00:27:42,780
don't have any x.509 we don't have

601
00:27:42,780 --> 00:27:47,200
certificates there's no asn.1 parsing we

602
00:27:47,200 --> 00:27:49,810
just have these very simple keys that we

603
00:27:49,810 --> 00:27:54,010
that we can paste around so how do we

604
00:27:54,010 --> 00:27:56,200
appear to be stateless to the

605
00:27:56,200 --> 00:28:00,190
administrator obviously the protocol

606
00:28:00,190 --> 00:28:02,140
itself can't be completely stateless you

607
00:28:02,140 --> 00:28:04,090
need state in order to have certain

608
00:28:04,090 --> 00:28:05,350
security properties but to the

609
00:28:05,350 --> 00:28:07,780
administrator it appears stateless so we

610
00:28:07,780 --> 00:28:10,000
have a series of timers to make things

611
00:28:10,000 --> 00:28:13,150
just work and so we have for this a very

612
00:28:13,150 --> 00:28:15,430
simple state machine that accounts for

613
00:28:15,430 --> 00:28:17,680
every possibility in state transitions

614
00:28:17,680 --> 00:28:20,470
simple enough that I was able to write

615
00:28:20,470 --> 00:28:22,390
down the entire matrix of state

616
00:28:22,390 --> 00:28:24,790
transitions so that we don't have any

617
00:28:24,790 --> 00:28:27,820
undefined situations so how does this

618
00:28:27,820 --> 00:28:31,410
work when user space sends a packet if

619
00:28:31,410 --> 00:28:34,390
we don't have a current session from a

620
00:28:34,390 --> 00:28:36,010
key exchange in the last two minutes

621
00:28:36,010 --> 00:28:40,630
then we send a handshake initiation if

622
00:28:40,630 --> 00:28:43,060
there's no handshake response after five

623
00:28:43,060 --> 00:28:46,690
seconds then we just send it again every

624
00:28:46,690 --> 00:28:49,840
time we get an authenticated incoming

625
00:28:49,840 --> 00:28:53,350
packet then we set a timer for 10

626
00:28:53,350 --> 00:28:55,750
seconds from that and every time we get

627
00:28:55,750 --> 00:28:57,610
a new authenticated packet we move that

628
00:28:57,610 --> 00:28:59,290
time or another 10 seconds into the

629
00:28:59,290 --> 00:29:02,050
future so that means if we never get an

630
00:29:02,050 --> 00:29:03,670
authenticated PAC if we stop receiving

631
00:29:03,670 --> 00:29:05,950
data then we suppose oh maybe the other

632
00:29:05,950 --> 00:29:08,820
side there's a problem and so we should

633
00:29:08,820 --> 00:29:14,050
reinitiate a handshake and so after 15

634
00:29:14,050 --> 00:29:17,650
seconds we reinitiate a handshake now if

635
00:29:17,650 --> 00:29:19,000
the other side just isn't responding at

636
00:29:19,000 --> 00:29:19,960
all then we go to sleep

637
00:29:19,960 --> 00:29:23,740
so we remain stealthy and not chatty but

638
00:29:23,740 --> 00:29:26,410
all of this amounts to an interface that

639
00:29:26,410 --> 00:29:28,060
you don't have to carry as it opt is it

640
00:29:28,060 --> 00:29:30,520
down is it running when was the last

641
00:29:30,520 --> 00:29:32,980
connection made now the the admin

642
00:29:32,980 --> 00:29:34,960
doesn't see that it's just you have an

643
00:29:34,960 --> 00:29:37,180
interface and you send packets and this

644
00:29:37,180 --> 00:29:40,210
very simple set of timers ensures that

645
00:29:40,210 --> 00:29:44,140
there's always a session there's also

646
00:29:44,140 --> 00:29:46,810
what's called the poor man's post

647
00:29:46,810 --> 00:29:50,440
quantum resistance now there's a lot of

648
00:29:50,440 --> 00:29:54,010
new crypto coming out for for quantum to

649
00:29:54,010 --> 00:29:55,780
protect against quantum computers but

650
00:29:55,780 --> 00:29:58,630
it's very new and wire guard is trying

651
00:29:58,630 --> 00:30:00,430
to be conservative with the primitives

652
00:30:00,430 --> 00:30:02,710
it chooses so it's not choosing one of

653
00:30:02,710 --> 00:30:06,220
these new heavily researched and debated

654
00:30:06,220 --> 00:30:10,510
post quantum primitives instead we allow

655
00:30:10,510 --> 00:30:15,640
for an optional pre shared key and pre

656
00:30:15,640 --> 00:30:17,800
shared key we can mix into the initial

657
00:30:17,800 --> 00:30:21,310
key exchange and because of Grover's

658
00:30:21,310 --> 00:30:22,509
algorithm

659
00:30:22,509 --> 00:30:25,089
quantum computer can do a brute-force

660
00:30:25,089 --> 00:30:30,699
search of a 256-bit symmetric key with

661
00:30:30,699 --> 00:30:32,409
the time it would take a classic

662
00:30:32,409 --> 00:30:36,759
algorithm to do this in - in 128-bit

663
00:30:36,759 --> 00:30:39,039
symmetric key and it was proved that

664
00:30:39,039 --> 00:30:42,309
this speed up is actually optimal there

665
00:30:42,309 --> 00:30:44,559
won't be a better algorithm than this

666
00:30:44,559 --> 00:30:46,419
for symmetric cryptography with the

667
00:30:46,419 --> 00:30:49,149
quantum computer so by mixing in a

668
00:30:49,149 --> 00:30:51,099
pre-shared key optionally if you want it

669
00:30:51,099 --> 00:30:53,829
if you're paranoid if an adversary is

670
00:30:53,829 --> 00:30:57,279
recording all of your traffic now in a

671
00:30:57,279 --> 00:30:58,839
hundred years when they finally make a

672
00:30:58,839 --> 00:31:01,739
quantum computer it won't be decrypted

673
00:31:01,739 --> 00:31:04,209
so that this is a feature put in there

674
00:31:04,209 --> 00:31:06,759
for the extremely paranoid most people

675
00:31:06,759 --> 00:31:10,299
won't really need this because depending

676
00:31:10,299 --> 00:31:12,299
on who you talk to a quantum computer

677
00:31:12,299 --> 00:31:17,229
capable of breaking elliptic curves are

678
00:31:17,229 --> 00:31:19,749
still far away off but it's in there if

679
00:31:19,749 --> 00:31:23,829
if you'd like it there's also a denial

680
00:31:23,829 --> 00:31:27,190
of service resistance so hashing in

681
00:31:27,190 --> 00:31:29,619
symmetric crypto are really fast but pop

682
00:31:29,619 --> 00:31:31,539
key crypto is slow even curved

683
00:31:31,539 --> 00:31:33,849
fifty-five one nine which has great

684
00:31:33,849 --> 00:31:35,799
speed records for for elliptic curve

685
00:31:35,799 --> 00:31:37,989
cryptography is a lot slower than

686
00:31:37,989 --> 00:31:39,909
symmetric key cryptography that's just

687
00:31:39,909 --> 00:31:43,899
how it is and in fact you can overwhelm

688
00:31:43,899 --> 00:31:45,969
a machine by just asking it to compute

689
00:31:45,969 --> 00:31:48,879
if you helmet over and over and a lot of

690
00:31:48,879 --> 00:31:53,289
protocols fail miserably - this UDP also

691
00:31:53,289 --> 00:31:54,339
makes the situation a little bit

692
00:31:54,339 --> 00:31:55,599
difficult because you can spoof your

693
00:31:55,599 --> 00:31:58,119
source address so wire guard uses a

694
00:31:58,119 --> 00:32:00,309
unique cookie solution to solve this so

695
00:32:00,309 --> 00:32:03,399
we're running a bit low on time but

696
00:32:03,399 --> 00:32:06,339
we'll try and get through this so brief

697
00:32:06,339 --> 00:32:10,419
history of cookies the tcp like cookies

698
00:32:10,419 --> 00:32:13,419
there's a dialogue where initiator says

699
00:32:13,419 --> 00:32:16,149
compute this diffie-hellman key your

700
00:32:16,149 --> 00:32:18,069
magic word is waffle now ask me again

701
00:32:18,069 --> 00:32:20,319
what the magic word initiator says okay

702
00:32:20,319 --> 00:32:22,599
my magic words waffle now will you do it

703
00:32:22,599 --> 00:32:24,759
and then it does it so this proves IP

704
00:32:24,759 --> 00:32:27,819
ownership but you still have the storage

705
00:32:27,819 --> 00:32:29,769
state that waffle is associated with a

706
00:32:29,769 --> 00:32:33,849
particular IP address and also this so

707
00:32:33,849 --> 00:32:35,900
this results in dynamic allocations

708
00:32:35,900 --> 00:32:38,570
also always responds to a message so we

709
00:32:38,570 --> 00:32:40,430
violate our stealth principle and of

710
00:32:40,430 --> 00:32:43,720
course the magic word can be intercepted

711
00:32:46,330 --> 00:32:50,300
okay DTLS and ikev2 style cookies are a

712
00:32:50,300 --> 00:32:52,220
little bit more sophisticated initiator

713
00:32:52,220 --> 00:32:53,170
says compute this diffie-hellman

714
00:32:53,170 --> 00:32:55,430
responder says okay your magic word is

715
00:32:55,430 --> 00:32:57,860
some big hash asking again with the

716
00:32:57,860 --> 00:33:00,020
magic word initiator says okay magic

717
00:33:00,020 --> 00:33:01,700
words the big hash now will you compute

718
00:33:01,700 --> 00:33:05,060
it and it turns out that this big hash

719
00:33:05,060 --> 00:33:08,390
is actually a Mac of the initiators IP

720
00:33:08,390 --> 00:33:11,120
address using some responder secrets so

721
00:33:11,120 --> 00:33:14,270
then no state needs to be stored and you

722
00:33:14,270 --> 00:33:16,400
can still prove IP ownership so this is

723
00:33:16,400 --> 00:33:20,840
this is clever but again it violates

724
00:33:20,840 --> 00:33:21,890
stealth because there's always a

725
00:33:21,890 --> 00:33:24,170
response to the message and of course

726
00:33:24,170 --> 00:33:25,970
the initiator himself can then be dossed

727
00:33:25,970 --> 00:33:28,400
by just sending a bunch of garbage magic

728
00:33:28,400 --> 00:33:34,330
words to the initiator so as an aside

729
00:33:34,330 --> 00:33:36,920
another solution to this is the Bitcoin

730
00:33:36,920 --> 00:33:38,630
like or host at the end of a protocol

731
00:33:38,630 --> 00:33:41,630
like where initiator says computers

732
00:33:41,630 --> 00:33:43,730
diffie-hellman responder says do some

733
00:33:43,730 --> 00:33:47,060
proof of work mine a Bitcoin and in this

734
00:33:47,060 --> 00:33:48,560
year says alright I found a Bitcoin now

735
00:33:48,560 --> 00:33:49,730
will you do it and this works great

736
00:33:49,730 --> 00:33:52,970
except because in my regard we want both

737
00:33:52,970 --> 00:33:54,980
roles to be symmetric its server and

738
00:33:54,980 --> 00:33:57,530
client can switch sides now there's a

739
00:33:57,530 --> 00:34:00,370
daus by just making the server compute

740
00:34:00,370 --> 00:34:02,900
tons of tons of this proof of work for

741
00:34:02,900 --> 00:34:05,090
many clients and so that doesn't fit us

742
00:34:05,090 --> 00:34:08,030
so why are guard variant is a little bit

743
00:34:08,030 --> 00:34:11,929
like the DTLS one except each message

744
00:34:11,929 --> 00:34:13,130
has two Macs

745
00:34:13,130 --> 00:34:17,270
the first is a hash of handshake and the

746
00:34:17,270 --> 00:34:22,149
responders public key so this means that

747
00:34:22,149 --> 00:34:26,960
in order to respond to a message the

748
00:34:26,960 --> 00:34:29,270
initiator needs to know who it's talking

749
00:34:29,270 --> 00:34:31,909
to and prove that with this hash so the

750
00:34:31,909 --> 00:34:35,418
responder won't respond just to any

751
00:34:35,418 --> 00:34:37,340
packet it will only respond to packets

752
00:34:37,340 --> 00:34:39,889
that have a proof that oh I know who you

753
00:34:39,889 --> 00:34:41,330
are I know that you're already on the

754
00:34:41,330 --> 00:34:43,070
network so we don't give up the stealth

755
00:34:43,070 --> 00:34:45,980
principle so if the responder isn't

756
00:34:45,980 --> 00:34:47,480
under a load then it just perceives

757
00:34:47,480 --> 00:34:48,250
normally

758
00:34:48,250 --> 00:34:49,750
and we don't need an engine Iowa's

759
00:34:49,750 --> 00:34:51,219
surface tack but if it is under a load

760
00:34:51,219 --> 00:34:52,960
that is if it is experiencing it that

761
00:34:52,960 --> 00:34:55,690
denial the services tank then it will

762
00:34:55,690 --> 00:34:59,440
respond with a cookie message and we

763
00:34:59,440 --> 00:35:02,710
compute this cookie doing the same DTLS

764
00:35:02,710 --> 00:35:05,020
trick where we take a hash of the

765
00:35:05,020 --> 00:35:06,640
initiators IP address and it's a keyed

766
00:35:06,640 --> 00:35:09,400
hash with some responder secret except

767
00:35:09,400 --> 00:35:11,140
this time we encrypt that cookie when we

768
00:35:11,140 --> 00:35:13,540
send it using as the key the responders

769
00:35:13,540 --> 00:35:16,270
public key and using as the additional

770
00:35:16,270 --> 00:35:17,740
data that's authenticated in it the

771
00:35:17,740 --> 00:35:20,650
original message so this now binds the

772
00:35:20,650 --> 00:35:23,500
original message to the cookie response

773
00:35:23,500 --> 00:35:25,690
while still encrypting it so now is

774
00:35:25,690 --> 00:35:28,870
harder to be intercepted and we can't

775
00:35:28,870 --> 00:35:32,140
das the initiator then the initiator

776
00:35:32,140 --> 00:35:33,820
receives this it can compute the second

777
00:35:33,820 --> 00:35:36,910
Mac using as its key the cookie that had

778
00:35:36,910 --> 00:35:41,440
just received okay so all of this

779
00:35:41,440 --> 00:35:43,450
essentially just gets us IP address

780
00:35:43,450 --> 00:35:45,340
attribution and then you open a

781
00:35:45,340 --> 00:35:46,930
networking book and you learn about

782
00:35:46,930 --> 00:35:49,270
token bucket rate-limiting this has been

783
00:35:49,270 --> 00:35:50,920
worked out extensively and so we just

784
00:35:50,920 --> 00:35:53,500
apply that to prevent the daus at that

785
00:35:53,500 --> 00:35:57,670
point performance wives wire guard is

786
00:35:57,670 --> 00:36:01,150
faster than anything else I found it's

787
00:36:01,150 --> 00:36:03,460
in kernel space so fast little latency

788
00:36:03,460 --> 00:36:06,520
we don't need to copy packets to and

789
00:36:06,520 --> 00:36:08,380
from user space like say Open VPN or

790
00:36:08,380 --> 00:36:11,590
other ton based solutions we use cha-cha

791
00:36:11,590 --> 00:36:14,770
20.1 305 which is really fast and it's

792
00:36:14,770 --> 00:36:16,990
fast on all hardware and this is a big

793
00:36:16,990 --> 00:36:19,930
deal on some hardware there is a TSN I

794
00:36:19,930 --> 00:36:23,440
which is very fast but it's not on all

795
00:36:23,440 --> 00:36:25,270
hardware and on the other hardware it's

796
00:36:25,270 --> 00:36:27,850
very hard to implement AES in a way that

797
00:36:27,850 --> 00:36:30,190
doesn't have side channel attacks well

798
00:36:30,190 --> 00:36:32,220
it's still fast and furthermore as

799
00:36:32,220 --> 00:36:35,080
vector instructions on on processors get

800
00:36:35,080 --> 00:36:38,140
faster and faster and wider and wider

801
00:36:38,140 --> 00:36:41,230
I think cha-cha 20 is going to be faster

802
00:36:41,230 --> 00:36:43,960
than a es eventually right now already

803
00:36:43,960 --> 00:36:46,300
wire guard for other reasons performs

804
00:36:46,300 --> 00:36:49,150
faster and I think on the latest skylake

805
00:36:49,150 --> 00:36:51,640
processors ChaCha 20 is already faster

806
00:36:51,640 --> 00:36:56,860
than AES in general the the simple

807
00:36:56,860 --> 00:36:59,860
design of wire guard means there's less

808
00:36:59,860 --> 00:37:01,520
code and

809
00:37:01,520 --> 00:37:03,960
as a friend here the audience once told

810
00:37:03,960 --> 00:37:07,050
me of well when you have less code you

811
00:37:07,050 --> 00:37:09,300
have a faster program not always true

812
00:37:09,300 --> 00:37:13,710
but here I think this basic principle

813
00:37:13,710 --> 00:37:16,470
actually works out so when you look at

814
00:37:16,470 --> 00:37:19,080
the performance measurements you can see

815
00:37:19,080 --> 00:37:22,350
we're ahead of IP ii both aes and IP 60

816
00:37:22,350 --> 00:37:26,310
top Holly we're way ahead of openvpn and

817
00:37:26,310 --> 00:37:28,170
in the ping time we have better latency

818
00:37:28,170 --> 00:37:30,930
than any of them

819
00:37:30,930 --> 00:37:34,140
so just to recap less than 4,000 lines

820
00:37:34,140 --> 00:37:36,810
of code which means all of you can read

821
00:37:36,810 --> 00:37:39,090
it and I would be very happy if you read

822
00:37:39,090 --> 00:37:43,170
it found feedback on it it can be easily

823
00:37:43,170 --> 00:37:46,070
implemented with basic data structures

824
00:37:46,070 --> 00:37:49,880
the design patterns that you need are

825
00:37:49,880 --> 00:37:52,290
simple and lead to secure programming

826
00:37:52,290 --> 00:37:55,860
it's stealthy either solid crypto we

827
00:37:55,860 --> 00:37:57,780
have the crypto key routing which is

828
00:37:57,780 --> 00:37:59,400
really a great simplification and we can

829
00:37:59,400 --> 00:38:00,710
get rid of a lot of the layering

830
00:38:00,710 --> 00:38:05,670
assumptions that we needed prior we have

831
00:38:05,670 --> 00:38:08,370
an ordinary network interface so you can

832
00:38:08,370 --> 00:38:09,750
use all the things you already know

833
00:38:09,750 --> 00:38:13,200
about it's very fast and a lot of

834
00:38:13,200 --> 00:38:14,700
choices have been made for you it's

835
00:38:14,700 --> 00:38:18,600
opinionated for more information you can

836
00:38:18,600 --> 00:38:22,500
go to wire guard io it's already in many

837
00:38:22,500 --> 00:38:24,240
of the distros there are packages in

838
00:38:24,240 --> 00:38:27,210
some debian gen - there's a fedora

839
00:38:27,210 --> 00:38:33,090
package etc and we have quite a few

840
00:38:33,090 --> 00:38:34,860
stickers so if you haven't gotten one

841
00:38:34,860 --> 00:38:36,690
should come up after and I'll open up

842
00:38:36,690 --> 00:38:40,010
the questions thanks

843
00:38:40,130 --> 00:38:45,939
[Music]

844
00:38:47,420 --> 00:38:49,480
you

