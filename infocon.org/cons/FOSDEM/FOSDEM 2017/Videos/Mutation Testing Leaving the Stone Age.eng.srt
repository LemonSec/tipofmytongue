1
00:00:04,750 --> 00:00:07,600
so hi everybody I'm a bit surprised that

2
00:00:07,600 --> 00:00:10,360
the film the the room is pretty packed

3
00:00:10,360 --> 00:00:12,040
so thank you for coming and thank you

4
00:00:12,040 --> 00:00:15,340
for having me here today I want to talk

5
00:00:15,340 --> 00:00:18,160
about the mutation testing and the way

6
00:00:18,160 --> 00:00:20,740
we should we should actually take to

7
00:00:20,740 --> 00:00:24,970
leave the Stone Age so few things about

8
00:00:24,970 --> 00:00:29,800
myself I'm a yes developer by day and in

9
00:00:29,800 --> 00:00:31,330
my spare time I'm actually hacking on

10
00:00:31,330 --> 00:00:33,039
compilers and this is like basically my

11
00:00:33,039 --> 00:00:35,590
hobby and this project actually might

12
00:00:35,590 --> 00:00:38,649
hobby itself so if you're curious you

13
00:00:38,649 --> 00:00:40,870
can find me on Twitter and I have two

14
00:00:40,870 --> 00:00:42,699
blocks where I write about some

15
00:00:42,699 --> 00:00:45,129
low-level stuff LLVM itself and mutation

16
00:00:45,129 --> 00:00:47,440
testing also and especially if you are

17
00:00:47,440 --> 00:00:50,050
into software testing and quality of

18
00:00:50,050 --> 00:00:53,829
software then I recommend you to look at

19
00:00:53,829 --> 00:00:56,589
the last link the system under test dot

20
00:00:56,589 --> 00:01:00,069
org there I and friends of mine we are

21
00:01:00,069 --> 00:01:02,109
writing about different software house

22
00:01:02,109 --> 00:01:05,049
tested and so on and so forth so it was

23
00:01:05,049 --> 00:01:09,700
shameless plug yeah this is the the

24
00:01:09,700 --> 00:01:12,150
outline for today's talk I will start

25
00:01:12,150 --> 00:01:15,550
with the quality of software then I will

26
00:01:15,550 --> 00:01:17,350
talk a bit about the unit testing then

27
00:01:17,350 --> 00:01:20,610
we will move towards mutation testing

28
00:01:20,610 --> 00:01:23,020
then I want to present the tool that I'm

29
00:01:23,020 --> 00:01:26,070
working on and at the very end I will

30
00:01:26,070 --> 00:01:30,100
try to present a showcase like real-life

31
00:01:30,100 --> 00:01:34,360
usage of this tool but I'm afraid that I

32
00:01:34,360 --> 00:01:36,640
will not be able to to give you like

33
00:01:36,640 --> 00:01:41,260
some stellar examples but that's gonna

34
00:01:41,260 --> 00:01:45,400
be interesting I hope yeah so I just

35
00:01:45,400 --> 00:01:48,040
have to wear for about like seven yeah

36
00:01:48,040 --> 00:01:50,740
seven years now I think and I enjoy it a

37
00:01:50,740 --> 00:01:53,200
lot but one thing that I'm concerned a

38
00:01:53,200 --> 00:01:55,750
bit is the fact that software is just

39
00:01:55,750 --> 00:01:57,730
like broken like essentially everything

40
00:01:57,730 --> 00:01:59,920
is broken like browsers compilers

41
00:01:59,920 --> 00:02:01,870
operating system games just anything

42
00:02:01,870 --> 00:02:04,210
it's full of bugs and it doesn't work

43
00:02:04,210 --> 00:02:05,880
and so and so forth

44
00:02:05,880 --> 00:02:08,500
so we as developers as computer

45
00:02:08,500 --> 00:02:10,389
scientists and engineers we are trying

46
00:02:10,389 --> 00:02:13,000
to put as much as possible efforts in

47
00:02:13,000 --> 00:02:14,560
for decades to improve the software

48
00:02:14,560 --> 00:02:18,400
somehow and there are some some ways to

49
00:02:18,400 --> 00:02:18,940
do it

50
00:02:18,940 --> 00:02:22,360
so for instance just yesterday we had a

51
00:02:22,360 --> 00:02:24,820
great talk about formal verification of

52
00:02:24,820 --> 00:02:27,400
programs but I don't know much about

53
00:02:27,400 --> 00:02:30,220
this topic but as far as I know we are

54
00:02:30,220 --> 00:02:31,120
not there yet

55
00:02:31,120 --> 00:02:33,820
the tuning is is great it it's improving

56
00:02:33,820 --> 00:02:37,270
but it's quite hard to to where Phi C or

57
00:02:37,270 --> 00:02:40,270
C++ because of this and find behavior

58
00:02:40,270 --> 00:02:43,150
and so on so not so great

59
00:02:43,150 --> 00:02:48,880
I prefer testing it yeah I think it it's

60
00:02:48,880 --> 00:02:51,460
like here like for a while and now since

61
00:02:51,460 --> 00:02:53,650
we have better computational power we

62
00:02:53,650 --> 00:02:58,120
can apply it more efficiently so but I

63
00:02:58,120 --> 00:03:00,520
think there is no job that unit testing

64
00:03:00,520 --> 00:03:04,210
is the most widespread technique that is

65
00:03:04,210 --> 00:03:07,300
used by software developers and yet

66
00:03:07,300 --> 00:03:10,840
comes with a nice metric as well it

67
00:03:10,840 --> 00:03:16,620
which is code coverage and yeah today I

68
00:03:16,620 --> 00:03:19,330
want to focus on just on this I'm not

69
00:03:19,330 --> 00:03:20,710
going to talk about like flows and

70
00:03:20,710 --> 00:03:22,240
advantages so fast testing or for

71
00:03:22,240 --> 00:03:24,010
modification but I definitely want to

72
00:03:24,010 --> 00:03:26,370
talk about unit testing and its problems

73
00:03:26,370 --> 00:03:29,350
so yeah how it works in generally in

74
00:03:29,350 --> 00:03:33,010
general we have some code and yeah this

75
00:03:33,010 --> 00:03:35,830
is like an official example just to to

76
00:03:35,830 --> 00:03:38,440
start so we have some function some that

77
00:03:38,440 --> 00:03:40,600
takes two integers and returns is some

78
00:03:40,600 --> 00:03:42,880
of them and for this function what

79
00:03:42,880 --> 00:03:46,560
developer does he writes a code like

80
00:03:47,959 --> 00:03:50,480
assertion is that the sum of five and 10

81
00:03:50,480 --> 00:03:54,200
is more greater than zero which is

82
00:03:54,200 --> 00:03:55,879
absolutely correct it's valid statement

83
00:03:55,879 --> 00:04:00,010
but it obviously it's not enough because

84
00:04:00,010 --> 00:04:03,650
five multiplied by ten also were greater

85
00:04:03,650 --> 00:04:08,180
than zero so if we round this test then

86
00:04:08,180 --> 00:04:11,329
we see that zero tests has failed one

87
00:04:11,329 --> 00:04:13,849
test passed and the cat coverage is 100%

88
00:04:13,849 --> 00:04:18,500
percent so it definitely has some it

89
00:04:18,500 --> 00:04:20,120
might be misleading the code coverage

90
00:04:20,120 --> 00:04:22,370
metric might be misleading and I see

91
00:04:22,370 --> 00:04:25,250
that sometimes people are striving for a

92
00:04:25,250 --> 00:04:27,349
number for this number but the court

93
00:04:27,349 --> 00:04:29,930
quality is not the code quality but the

94
00:04:29,930 --> 00:04:33,169
test quality is not as good and there is

95
00:04:33,169 --> 00:04:36,020
no way to measure it actually there is

96
00:04:36,020 --> 00:04:38,419
no just no way how to assert how good

97
00:04:38,419 --> 00:04:42,380
our tests so here comes the mutation

98
00:04:42,380 --> 00:04:46,820
testing so I will try to explain the

99
00:04:46,820 --> 00:04:50,150
algorithm behind it like very briefly if

100
00:04:50,150 --> 00:04:52,310
there is something like an completely

101
00:04:52,310 --> 00:04:54,199
unclear or like really confusing just

102
00:04:54,199 --> 00:04:56,659
feel free to like to interrupt me and

103
00:04:56,659 --> 00:05:00,560
ask I will elaborate so yeah what we do

104
00:05:00,560 --> 00:05:02,510
like normally with mutation testing we

105
00:05:02,510 --> 00:05:04,520
have a program and we have a test suit

106
00:05:04,520 --> 00:05:08,090
we then execute this test suit against

107
00:05:08,090 --> 00:05:11,210
that program and if everything is good

108
00:05:11,210 --> 00:05:14,060
if tests are passing then we do the

109
00:05:14,060 --> 00:05:17,659
following for the program we take a

110
00:05:17,659 --> 00:05:19,639
mutant we created mutant out of the

111
00:05:19,639 --> 00:05:21,770
program so we basically do some mutation

112
00:05:21,770 --> 00:05:25,699
on it and it must be some semantic

113
00:05:25,699 --> 00:05:27,729
change the program should be different

114
00:05:27,729 --> 00:05:32,810
then we take that mutated program and

115
00:05:32,810 --> 00:05:36,770
run test suit against it again and then

116
00:05:36,770 --> 00:05:39,139
we check the result if the result is

117
00:05:39,139 --> 00:05:43,310
failed then we claim that this mutant

118
00:05:43,310 --> 00:05:45,800
was killed this is essentially a good

119
00:05:45,800 --> 00:05:48,169
thing so if you introduced if you run a

120
00:05:48,169 --> 00:05:50,509
test against mutated program then the

121
00:05:50,509 --> 00:05:52,789
test should fail if that's not the case

122
00:05:52,789 --> 00:05:56,210
then we claim that mutant is arrived and

123
00:05:56,210 --> 00:05:59,210
this is kind of bad so it means that

124
00:05:59,210 --> 00:06:01,249
something is wrong either code or

125
00:06:01,249 --> 00:06:04,489
the test so here again our initial

126
00:06:04,489 --> 00:06:06,889
example was the test and the program so

127
00:06:06,889 --> 00:06:10,009
out of this program we can generate many

128
00:06:10,009 --> 00:06:12,349
mutants but I will just show like up of

129
00:06:12,349 --> 00:06:16,279
them so first one is we replace a plus B

130
00:06:16,279 --> 00:06:19,039
with a multiplied by B and the second

131
00:06:19,039 --> 00:06:21,639
one we replace a plus B with a minus B

132
00:06:21,639 --> 00:06:24,199
now if you run the test against the

133
00:06:24,199 --> 00:06:28,279
first mutant then it is still passes so

134
00:06:28,279 --> 00:06:29,119
it it

135
00:06:29,119 --> 00:06:32,059
yeah mutants arrives and it it gives us

136
00:06:32,059 --> 00:06:35,809
a hint that something is wrong however

137
00:06:35,809 --> 00:06:39,019
the second mutant is what was killed and

138
00:06:39,019 --> 00:06:44,959
we are good to go here so based on this

139
00:06:44,959 --> 00:06:47,869
example we can derive few numbers so the

140
00:06:47,869 --> 00:06:49,639
total amount of many chances to one

141
00:06:49,639 --> 00:06:52,059
mutant was killed one was survived and

142
00:06:52,059 --> 00:06:54,409
mutation testing also comes with the

143
00:06:54,409 --> 00:06:56,449
metric called mutation squirt and is

144
00:06:56,449 --> 00:06:58,819
calculated by the formula on the screen

145
00:06:58,819 --> 00:07:00,769
like kill mutants amount of killed

146
00:07:00,769 --> 00:07:03,019
mutants divided by amount or a total

147
00:07:03,019 --> 00:07:05,389
amount of mutants and multiply it by 100

148
00:07:05,389 --> 00:07:08,539
percent so in this specific case the

149
00:07:08,539 --> 00:07:11,479
mutation score is 50 percent and it's

150
00:07:11,479 --> 00:07:13,969
not good so again you should not strive

151
00:07:13,969 --> 00:07:16,519
for 100% because you probably will not

152
00:07:16,519 --> 00:07:20,119
reach it anyway but you can use it as

153
00:07:20,119 --> 00:07:23,329
just as a hint so higher mutation score

154
00:07:23,329 --> 00:07:28,519
is better yeah few effects few things

155
00:07:28,519 --> 00:07:30,589
about mutation testing Oh

156
00:07:30,589 --> 00:07:35,439
spoilers yeah sir

157
00:07:37,839 --> 00:07:42,259
so it was first proposed by Richard

158
00:07:42,259 --> 00:07:45,709
flips on in 1970 first I think it was

159
00:07:45,709 --> 00:07:47,929
called a mutation analysis so these are

160
00:07:47,929 --> 00:07:50,749
the same kind of the same terms so it

161
00:07:50,749 --> 00:07:53,229
was first implemented by Timothy but in

162
00:07:53,229 --> 00:07:57,499
1980s and I think it was for Fortran but

163
00:07:57,499 --> 00:08:00,249
I'm not sure so don't quote me on that

164
00:08:00,249 --> 00:08:02,329
there are several studies like quite

165
00:08:02,329 --> 00:08:05,209
recent studies that show that a certain

166
00:08:05,209 --> 00:08:07,579
with age mutation testing systems for

167
00:08:07,579 --> 00:08:10,219
certain programs they could help to find

168
00:08:10,219 --> 00:08:13,729
bugs like real faults like quite

169
00:08:13,729 --> 00:08:16,069
number of them ex M&T and ninety

170
00:08:16,069 --> 00:08:18,349
actually ninety ninety four ninety two

171
00:08:18,349 --> 00:08:22,659
percent like to be more precise but even

172
00:08:22,659 --> 00:08:25,460
despite this fact mutation analysis was

173
00:08:25,460 --> 00:08:28,249
not or it was not widely spread because

174
00:08:28,249 --> 00:08:30,800
it has several problems as well as just

175
00:08:30,800 --> 00:08:33,169
everything so the first problem it

176
00:08:33,169 --> 00:08:35,958
generates like lots of data for just ten

177
00:08:35,958 --> 00:08:38,240
tests for a small program you can end up

178
00:08:38,240 --> 00:08:43,190
with 100 mutants and if you execute this

179
00:08:43,190 --> 00:08:45,470
like those ten tests against those like

180
00:08:45,470 --> 00:08:47,750
hundreds of programs then you end up

181
00:08:47,750 --> 00:08:50,300
like to running the program like 1000

182
00:08:50,300 --> 00:08:53,870
times in the worst case second one yeah

183
00:08:53,870 --> 00:08:55,639
it's time-consuming because of this like

184
00:08:55,639 --> 00:08:57,440
the the data we have also data we need

185
00:08:57,440 --> 00:08:59,620
to process it which is acute it takes

186
00:08:59,620 --> 00:09:03,440
quite a lot of time languages they are

187
00:09:03,440 --> 00:09:05,570
not not all the languages I would say

188
00:09:05,570 --> 00:09:07,100
are friendly for mutation testing

189
00:09:07,100 --> 00:09:10,279
because it's I think it's kind of easier

190
00:09:10,279 --> 00:09:11,930
for languages like Ruby or JavaScript

191
00:09:11,930 --> 00:09:14,180
because you have just like a wall and

192
00:09:14,180 --> 00:09:15,230
well Yolo

193
00:09:15,230 --> 00:09:19,190
so but languages like C or C++ they are

194
00:09:19,190 --> 00:09:22,639
more they're not as friendly because you

195
00:09:22,639 --> 00:09:24,290
essentially need to to mutate the

196
00:09:24,290 --> 00:09:26,060
program I to change the source code like

197
00:09:26,060 --> 00:09:28,910
maybe ast I don't know then compile it

198
00:09:28,910 --> 00:09:30,769
then link it together with everything

199
00:09:30,769 --> 00:09:34,310
and run and then assert it just quite

200
00:09:34,310 --> 00:09:38,769
slow though I don't have real numbers

201
00:09:38,769 --> 00:09:41,329
yeah there is also a problem of a human

202
00:09:41,329 --> 00:09:44,060
test Oracle so let's say we generated

203
00:09:44,060 --> 00:09:47,389
lots of mutants and we cannot just say

204
00:09:47,389 --> 00:09:49,370
like whether are they are they good or

205
00:09:49,370 --> 00:09:51,829
not so we need somebody to actually look

206
00:09:51,829 --> 00:09:55,329
at those results and make the decision

207
00:09:55,329 --> 00:09:58,220
yeah it also comes with another problem

208
00:09:58,220 --> 00:10:02,300
but I will tell bit about it later it's

209
00:10:02,300 --> 00:10:04,459
actually and yeah another one problem I

210
00:10:04,459 --> 00:10:06,860
was surprised by that I heard this like

211
00:10:06,860 --> 00:10:08,750
almost exactly this phrase like excuse

212
00:10:08,750 --> 00:10:11,389
me but I write good tests i I don't

213
00:10:11,389 --> 00:10:13,160
believe it and it for me it sounds like

214
00:10:13,160 --> 00:10:15,019
excuse me but my code is like free which

215
00:10:15,019 --> 00:10:17,720
is well not the case Michael is back

216
00:10:17,720 --> 00:10:22,189
free but yeah not in general yeah yeah

217
00:10:22,189 --> 00:10:26,649
so the tool is called mouth now

218
00:10:26,649 --> 00:10:31,569
so it whether it's tool we are trying to

219
00:10:31,569 --> 00:10:33,939
solve some of those problems but not all

220
00:10:33,939 --> 00:10:36,069
of them and there are some things that

221
00:10:36,069 --> 00:10:38,410
we do to actually improve the

222
00:10:38,410 --> 00:10:40,149
performance and make it

223
00:10:40,149 --> 00:10:42,819
well better in general so we have kind

224
00:10:42,819 --> 00:10:45,939
of smart mutant selection it means that

225
00:10:45,939 --> 00:10:50,139
I mean it just helps us to decrease the

226
00:10:50,139 --> 00:10:52,329
amount of mutant scent amount of data we

227
00:10:52,329 --> 00:10:54,699
need to process and it's very similar to

228
00:10:54,699 --> 00:10:57,249
you know the second point so we provide

229
00:10:57,249 --> 00:10:59,859
a means to control the data generation

230
00:10:59,859 --> 00:11:03,339
so I will elaborate on it

231
00:11:03,339 --> 00:11:06,399
yes it's complicated as well bit so we

232
00:11:06,399 --> 00:11:08,470
also utilize the run time compilation

233
00:11:08,470 --> 00:11:11,439
and jet particularly we use a lot vm for

234
00:11:11,439 --> 00:11:15,519
that and it means that we will need to

235
00:11:15,519 --> 00:11:17,619
link something we don't need to

236
00:11:17,619 --> 00:11:20,259
recompile things that much and we

237
00:11:20,259 --> 00:11:23,589
completely eliminate io bottleneck of io

238
00:11:23,589 --> 00:11:28,479
in this case so because of that we are

239
00:11:28,479 --> 00:11:31,689
operating on the level of LLVM ir which

240
00:11:31,689 --> 00:11:34,269
gives some nice tool things a but also

241
00:11:34,269 --> 00:11:37,569
comes with problems like you can add

242
00:11:37,569 --> 00:11:42,429
sometimes you cannot like correspond the

243
00:11:42,429 --> 00:11:45,609
ir was the initial code so they well

244
00:11:45,609 --> 00:11:47,230
they might be different especially with

245
00:11:47,230 --> 00:11:49,269
c++ with all these templates inlining

246
00:11:49,269 --> 00:11:52,869
and so on so forth and the great thing

247
00:11:52,869 --> 00:11:55,629
that it is language agnostic given that

248
00:11:55,629 --> 00:11:58,059
all the languages are built on top of

249
00:11:58,059 --> 00:12:00,939
LLVM so if something is built on top of

250
00:12:00,939 --> 00:12:04,259
LLVM then it's likely that we can use it

251
00:12:04,259 --> 00:12:09,519
yeah so time to elaborate a bit on how

252
00:12:09,519 --> 00:12:12,159
the system works so this is the typical

253
00:12:12,159 --> 00:12:14,109
program we have like several source

254
00:12:14,109 --> 00:12:16,720
files bit code files modules whatnot

255
00:12:16,720 --> 00:12:18,519
they have some functions and

256
00:12:18,519 --> 00:12:22,319
instructions and if you just go and

257
00:12:22,319 --> 00:12:24,879
analyze the whole program as is then

258
00:12:24,879 --> 00:12:26,919
we'll find out like many many many

259
00:12:26,919 --> 00:12:28,839
mutants many many places where we can

260
00:12:28,839 --> 00:12:31,269
introduce the mutation but it's not very

261
00:12:31,269 --> 00:12:33,220
efficient because because most like

262
00:12:33,220 --> 00:12:35,859
maybe not most but big parts of this

263
00:12:35,859 --> 00:12:37,749
code is like just unreachable for

264
00:12:37,749 --> 00:12:39,670
whatever reason

265
00:12:39,670 --> 00:12:41,680
so the bet the better approach would be

266
00:12:41,680 --> 00:12:45,400
as what we actually do first we try to

267
00:12:45,400 --> 00:12:47,950
find the actual tests thing that are

268
00:12:47,950 --> 00:12:50,830
well tests essentially and based on this

269
00:12:50,830 --> 00:12:53,140
those tests we take the coal sites like

270
00:12:53,140 --> 00:12:56,050
coal functions we are trying to build so

271
00:12:56,050 --> 00:12:59,320
called poultry and based on this code

272
00:12:59,320 --> 00:13:01,180
tree it's like on this slide you can see

273
00:13:01,180 --> 00:13:04,270
some modules they are not needed so we

274
00:13:04,270 --> 00:13:05,980
can just eliminate them completely we

275
00:13:05,980 --> 00:13:07,330
don't need to compile them we don't need

276
00:13:07,330 --> 00:13:09,880
to analyze them just a no consumes less

277
00:13:09,880 --> 00:13:16,380
memory and so on so forth so yeah

278
00:13:16,380 --> 00:13:19,840
whereas with this optimization it is

279
00:13:19,840 --> 00:13:21,580
actually still experimental it's a bit

280
00:13:21,580 --> 00:13:24,250
more tricky than I told before and it

281
00:13:24,250 --> 00:13:25,510
has some problems but it is it is

282
00:13:25,510 --> 00:13:27,730
definitely the way to go so for example

283
00:13:27,730 --> 00:13:30,690
in this slide we took some subset of

284
00:13:30,690 --> 00:13:34,840
tests from LLVM itself the target called

285
00:13:34,840 --> 00:13:36,760
I artists and we just took like two and

286
00:13:36,760 --> 00:13:41,980
a half hundreds of tests and before to

287
00:13:41,980 --> 00:13:43,930
actually to run this the whole thesis

288
00:13:43,930 --> 00:13:47,440
and to process it we needed to look at

289
00:13:47,440 --> 00:13:50,110
like four hundred modules and it took

290
00:13:50,110 --> 00:13:54,640
roughly yeah eighty five minutes after

291
00:13:54,640 --> 00:13:56,680
this improvement like cutting those like

292
00:13:56,680 --> 00:14:00,130
unused modules we got like three times

293
00:14:00,130 --> 00:14:03,250
less modules and almost two it works

294
00:14:03,250 --> 00:14:05,620
like almost two times faster but again

295
00:14:05,620 --> 00:14:08,380
it is experimental it's not in masters

296
00:14:08,380 --> 00:14:13,600
run yet but we're working on it so here

297
00:14:13,600 --> 00:14:17,830
is the most complex program like closer

298
00:14:17,830 --> 00:14:22,000
to reality and here we can see that on

299
00:14:22,000 --> 00:14:25,930
the left the the functions on the left

300
00:14:25,930 --> 00:14:28,630
they are tests and they go some way -

301
00:14:28,630 --> 00:14:31,500
likewise

302
00:14:32,259 --> 00:14:35,669
as some distance

303
00:14:37,470 --> 00:14:40,879
and it has something

304
00:14:43,200 --> 00:14:45,260
you

305
00:14:47,210 --> 00:14:49,490
so for the same subset of tests which

306
00:14:49,490 --> 00:14:54,620
distance to it produces the 100 1000 and

307
00:14:54,620 --> 00:14:58,880
health mutants and the real execution

308
00:14:58,880 --> 00:15:00,470
time that I measured from my machine

309
00:15:00,470 --> 00:15:03,140
took like about one hour which is

310
00:15:03,140 --> 00:15:06,560
unacceptable but for on the other hand

311
00:15:06,560 --> 00:15:10,820
if we took the whole program then the

312
00:15:10,820 --> 00:15:12,950
distance is 29 for for this group of

313
00:15:12,950 --> 00:15:14,960
tests and number of mutants it's I think

314
00:15:14,960 --> 00:15:17,120
there is actually back it should be like

315
00:15:17,120 --> 00:15:20,450
orders of magnitude more like maybe 200

316
00:15:20,450 --> 00:15:23,720
thousands of mutants and approximated

317
00:15:23,720 --> 00:15:26,230
approximation of like execution time is

318
00:15:26,230 --> 00:15:28,610
roughly 11 days but it's very

319
00:15:28,610 --> 00:15:30,530
pessimistic so in reality it will take

320
00:15:30,530 --> 00:15:34,040
maybe seven days six so yeah that still

321
00:15:34,040 --> 00:15:37,190
doesn't help yeah and with this numbers

322
00:15:37,190 --> 00:15:39,740
actually will this mean to change the

323
00:15:39,740 --> 00:15:42,830
distance to control the distance even if

324
00:15:42,830 --> 00:15:44,390
it takes one hour you cannot probably

325
00:15:44,390 --> 00:15:46,370
use it on your machine like daily basis

326
00:15:46,370 --> 00:15:49,070
because well it's kind of waste of time

327
00:15:49,070 --> 00:15:51,620
but it's you can use it as like with a

328
00:15:51,620 --> 00:15:55,900
nightlight the bills for example and for

329
00:15:55,900 --> 00:16:00,800
yeah mutant control okay yeah there is

330
00:16:00,800 --> 00:16:03,590
another mean we can select some specific

331
00:16:03,590 --> 00:16:06,290
tests so let's say you have like 200

332
00:16:06,290 --> 00:16:07,910
tests but you're interested in like one

333
00:16:07,910 --> 00:16:12,350
or like some group of tests and yeah so

334
00:16:12,350 --> 00:16:13,790
basically you just like select one test

335
00:16:13,790 --> 00:16:16,430
and work with it was like even like you

336
00:16:16,430 --> 00:16:18,830
reduce the amount of tests even further

337
00:16:18,830 --> 00:16:22,760
and I didn't put numbers in slide but

338
00:16:22,760 --> 00:16:26,320
the the I think the best case was like

339
00:16:26,320 --> 00:16:29,660
3040 seconds maybe for one test and the

340
00:16:29,660 --> 00:16:32,260
worst case for a group of tests which is

341
00:16:32,260 --> 00:16:35,720
my 15 or 20 it took like and I went 15

342
00:16:35,720 --> 00:16:37,520
minutes 20 minutes which is like still

343
00:16:37,520 --> 00:16:40,040
reasonable and it enables like really

344
00:16:40,040 --> 00:16:42,920
really fast iterations so I I think this

345
00:16:42,920 --> 00:16:44,750
is like the the best improvement that we

346
00:16:44,750 --> 00:16:47,920
did so far the best kind of invention

347
00:16:47,920 --> 00:16:51,710
yeah so few words about the system

348
00:16:51,710 --> 00:16:53,000
design how it works

349
00:16:53,000 --> 00:16:57,400
in general so this is like in a nutshell

350
00:16:57,400 --> 00:17:00,290
the program consumes as an input a

351
00:17:00,290 --> 00:17:00,920
config file

352
00:17:00,920 --> 00:17:02,839
which is just the yellow which is

353
00:17:02,839 --> 00:17:06,260
doesn't matter what it contains is the

354
00:17:06,260 --> 00:17:09,199
list of bit code files basically shows

355
00:17:09,199 --> 00:17:11,449
which modules were to get modules to to

356
00:17:11,449 --> 00:17:14,869
process and it also like has this

357
00:17:14,869 --> 00:17:17,659
settings for distance and some cash and

358
00:17:17,659 --> 00:17:18,579
so on so forth

359
00:17:18,579 --> 00:17:21,529
so but what the program spits out is the

360
00:17:21,529 --> 00:17:23,809
another config file and the SQLite file

361
00:17:23,809 --> 00:17:28,250
so that another config file is reduce

362
00:17:28,250 --> 00:17:30,260
version of the first config file so

363
00:17:30,260 --> 00:17:31,789
let's say they initially you provide a

364
00:17:31,789 --> 00:17:35,360
config with 400 modules and you found

365
00:17:35,360 --> 00:17:37,580
out that you were like used only

366
00:17:37,580 --> 00:17:39,679
hundreds of them the next time you can

367
00:17:39,679 --> 00:17:42,769
run the program with that reduced config

368
00:17:42,769 --> 00:17:46,220
and you will not need to process like

369
00:17:46,220 --> 00:17:49,669
the 400 but rather 100 so it's gonna

370
00:17:49,669 --> 00:17:54,799
also improve the iterations yeah we also

371
00:17:54,799 --> 00:17:56,570
don't provide any so yeah I mentioned

372
00:17:56,570 --> 00:17:58,250
the immunization score but the program

373
00:17:58,250 --> 00:18:00,279
at this very moment regional provide any

374
00:18:00,279 --> 00:18:03,679
like short report like your mutation

375
00:18:03,679 --> 00:18:06,559
score is something percent because again

376
00:18:06,559 --> 00:18:08,149
as I said I believe that we should not

377
00:18:08,149 --> 00:18:10,070
strive for numbers we should just use

378
00:18:10,070 --> 00:18:12,529
them as a hint and what we provides

379
00:18:12,529 --> 00:18:14,630
instead of this is the SQLite file which

380
00:18:14,630 --> 00:18:16,279
contains information about just

381
00:18:16,279 --> 00:18:20,149
everything and it has the advantages so

382
00:18:20,149 --> 00:18:23,299
if I run something and I get results I

383
00:18:23,299 --> 00:18:25,610
can treat them in any way I want and I

384
00:18:25,610 --> 00:18:27,230
don't have to restart the program again

385
00:18:27,230 --> 00:18:30,049
weights like hour or a week and just

386
00:18:30,049 --> 00:18:33,590
again iterate faster so this is yeah the

387
00:18:33,590 --> 00:18:35,360
program from the like outside user

388
00:18:35,360 --> 00:18:38,860
perspective so internally and contains

389
00:18:38,860 --> 00:18:41,350
consistent from several several modules

390
00:18:41,350 --> 00:18:44,720
one is canna core it has just a driver

391
00:18:44,720 --> 00:18:48,049
that well controls the basic system it

392
00:18:48,049 --> 00:18:51,769
has a reporter and it will be likely

393
00:18:51,769 --> 00:18:53,720
extended or replaced in the future so

394
00:18:53,720 --> 00:18:55,610
instead of SQLite you can report to the

395
00:18:55,610 --> 00:18:58,120
as like outputs or whatnot

396
00:18:58,120 --> 00:19:00,559
one central part actually is mutation

397
00:19:00,559 --> 00:19:02,799
operators I didn't talk about them

398
00:19:02,799 --> 00:19:06,049
before so I will just briefly explain

399
00:19:06,049 --> 00:19:08,779
what's that so every mutation to

400
00:19:08,779 --> 00:19:11,480
mutation testing tool they have some

401
00:19:11,480 --> 00:19:14,570
mutation operators these are things that

402
00:19:14,570 --> 00:19:17,409
like Anna rules that describe how you

403
00:19:17,409 --> 00:19:20,470
change your program so it could be like

404
00:19:20,470 --> 00:19:23,450
replace plus with - like remove void

405
00:19:23,450 --> 00:19:26,450
function or replace like a negate

406
00:19:26,450 --> 00:19:28,850
condition for example or I don't know

407
00:19:28,850 --> 00:19:31,429
like skip the whole loop for example or

408
00:19:31,429 --> 00:19:33,409
like anything you can imagine there also

409
00:19:33,409 --> 00:19:35,210
some studies that do the imitation

410
00:19:35,210 --> 00:19:38,230
operators for for job I think and they

411
00:19:38,230 --> 00:19:41,210
go in further and they change the class

412
00:19:41,210 --> 00:19:43,070
hierarchies like they inject some pluses

413
00:19:43,070 --> 00:19:44,840
remove and so on just to screw the

414
00:19:44,840 --> 00:19:48,889
system up even more yeah the second part

415
00:19:48,889 --> 00:19:51,080
is also like straight forward it's a to

416
00:19:51,080 --> 00:19:53,750
chain maybe it's not the best name but

417
00:19:53,750 --> 00:19:56,299
it just like JIT compiler from LLVM and

418
00:19:56,299 --> 00:19:58,700
the object cache so when once we run the

419
00:19:58,700 --> 00:20:01,659
program once we usually don't recompile

420
00:20:01,659 --> 00:20:04,580
biggest part of it with the next run so

421
00:20:04,580 --> 00:20:08,149
it's also improved the speed yeah the

422
00:20:08,149 --> 00:20:10,340
most important in my opinion the most

423
00:20:10,340 --> 00:20:12,139
important piece the most important thing

424
00:20:12,139 --> 00:20:14,779
is the test framework basically this is

425
00:20:14,779 --> 00:20:18,250
the worst one thing now that is abstract

426
00:20:18,250 --> 00:20:23,299
because it can be like google chess for

427
00:20:23,299 --> 00:20:25,279
example if you want to run the tool

428
00:20:25,279 --> 00:20:27,860
against C++ then we have driver now and

429
00:20:27,860 --> 00:20:29,929
like all this infrastructure for Google

430
00:20:29,929 --> 00:20:32,899
test it could be also like XC test for

431
00:20:32,899 --> 00:20:34,990
example for Objective C and Swift

432
00:20:34,990 --> 00:20:39,049
potentially and just I think two or

433
00:20:39,049 --> 00:20:41,240
three days ago we merge the initial

434
00:20:41,240 --> 00:20:44,179
support for for rust it it's not

435
00:20:44,179 --> 00:20:46,009
production ready I mean the whole tools

436
00:20:46,009 --> 00:20:49,220
of production already but the rest you

437
00:20:49,220 --> 00:20:50,600
can just take it and apply on any

438
00:20:50,600 --> 00:20:54,370
project but we'll get there

439
00:20:54,370 --> 00:20:58,789
yeah so kind of showcase initially like

440
00:20:58,789 --> 00:21:00,889
month ago I wanted when I was planing

441
00:21:00,889 --> 00:21:02,899
the slides and so on I wanted to run the

442
00:21:02,899 --> 00:21:05,389
tool against the LLVM itself and gather

443
00:21:05,389 --> 00:21:07,220
some results dive into it and find

444
00:21:07,220 --> 00:21:09,139
something probably something interested

445
00:21:09,139 --> 00:21:11,629
interesting but the problem that I faced

446
00:21:11,629 --> 00:21:15,169
that to actually assert the direction to

447
00:21:15,169 --> 00:21:16,909
make sense out of those mutations I need

448
00:21:16,909 --> 00:21:19,009
to know the domain of the tool is where

449
00:21:19,009 --> 00:21:20,389
well which is not the case unfortunately

450
00:21:20,389 --> 00:21:23,179
I don't know that like the most part of

451
00:21:23,179 --> 00:21:27,320
the LLVM like AP float and some other

452
00:21:27,320 --> 00:21:28,040
stuff

453
00:21:28,040 --> 00:21:32,510
but the results are available online

454
00:21:32,510 --> 00:21:35,640
they might be cumbersome and unclear and

455
00:21:35,640 --> 00:21:37,860
maybe cryptic because I'm in this

456
00:21:37,860 --> 00:21:39,600
context and I do understand everything

457
00:21:39,600 --> 00:21:42,390
there but it's hard to know just like

458
00:21:42,390 --> 00:21:44,940
it's hard to know for me what people may

459
00:21:44,940 --> 00:21:48,330
need so if you're into it and if you are

460
00:21:48,330 --> 00:21:49,770
interested you may take a look and give

461
00:21:49,770 --> 00:21:50,790
some feedback I would really appreciate

462
00:21:50,790 --> 00:21:53,820
it yeah so again the some numbers for

463
00:21:53,820 --> 00:21:57,930
example that I our chests yeah you can

464
00:21:57,930 --> 00:21:59,550
see here the mutation score is 43

465
00:21:59,550 --> 00:22:01,740
percent which is quite low and I

466
00:22:01,740 --> 00:22:05,130
actually saw yeah quite a few places

467
00:22:05,130 --> 00:22:07,620
that can be improved but again I cannot

468
00:22:07,620 --> 00:22:09,960
just like do it easily and fast I need

469
00:22:09,960 --> 00:22:13,200
to dive into this matter which I didn't

470
00:22:13,200 --> 00:22:15,780
and the same goes for ADT tests the

471
00:22:15,780 --> 00:22:18,210
imitation score is a bit higher and 66%

472
00:22:18,210 --> 00:22:21,900
but it is still quite low I would say so

473
00:22:21,900 --> 00:22:24,330
what I did instead I took the one part

474
00:22:24,330 --> 00:22:27,300
that is quite small and the code there

475
00:22:27,300 --> 00:22:30,030
is quite straightforward so even I can

476
00:22:30,030 --> 00:22:34,110
understand it this the triple tests I

477
00:22:34,110 --> 00:22:35,280
don't know if you're aware what the

478
00:22:35,280 --> 00:22:37,230
triple is but it doesn't really matter

479
00:22:37,230 --> 00:22:40,620
so just just some group of tests and

480
00:22:40,620 --> 00:22:42,540
yeah the mutation score is quite high

481
00:22:42,540 --> 00:22:45,240
but I still wanted to see what's going

482
00:22:45,240 --> 00:22:48,720
on there and first thing I found is this

483
00:22:48,720 --> 00:22:51,930
kind of tests so we have triple we

484
00:22:51,930 --> 00:22:54,750
change the architecture and then we ask

485
00:22:54,750 --> 00:22:59,970
for well then we assert that some like

486
00:22:59,970 --> 00:23:01,830
in this case like other architecture

487
00:23:01,830 --> 00:23:03,750
like based on that initial architecture

488
00:23:03,750 --> 00:23:06,720
is like exactly as what we need so what

489
00:23:06,720 --> 00:23:08,430
happened what's happening behind the

490
00:23:08,430 --> 00:23:10,440
hood under the methods like the at

491
00:23:10,440 --> 00:23:13,710
little-endian arch variant there is just

492
00:23:13,710 --> 00:23:16,620
a huge switch statement and that just

493
00:23:16,620 --> 00:23:21,270
maps things together and what we did

494
00:23:21,270 --> 00:23:22,770
will basically start with like removing

495
00:23:22,770 --> 00:23:24,930
switch cases like one by one and we

496
00:23:24,930 --> 00:23:27,630
found that many things that it just can

497
00:23:27,630 --> 00:23:29,070
be removed and the tests are still

498
00:23:29,070 --> 00:23:31,080
passing so in this case it just means

499
00:23:31,080 --> 00:23:34,140
that we just need to it like to add more

500
00:23:34,140 --> 00:23:37,170
tests yeah

501
00:23:37,170 --> 00:23:40,100
slides I think switch but okay

502
00:23:40,100 --> 00:23:42,690
yeah so one could argue actually that

503
00:23:42,690 --> 00:23:45,300
this case can be found by code coverage

504
00:23:45,300 --> 00:23:47,610
and this is like absolutely true it will

505
00:23:47,610 --> 00:23:50,940
be there I'm pretty sure but the nice

506
00:23:50,940 --> 00:23:53,610
thing about the mutation testing in this

507
00:23:53,610 --> 00:23:56,760
case that you get a report like this one

508
00:23:56,760 --> 00:23:59,910
and you clearly see like what was

509
00:23:59,910 --> 00:24:01,320
removed like let's say you remove this

510
00:24:01,320 --> 00:24:04,050
like this case and you see like what

511
00:24:04,050 --> 00:24:05,880
what which tests were affected by this

512
00:24:05,880 --> 00:24:07,860
so basically what what tests you need to

513
00:24:07,860 --> 00:24:11,340
extend to improve to cover this case and

514
00:24:11,340 --> 00:24:15,090
it took me like just the the whole

515
00:24:15,090 --> 00:24:17,310
flight from Berlin to Brussels like one

516
00:24:17,310 --> 00:24:19,940
hour maybe to improve this a bit and

517
00:24:19,940 --> 00:24:22,830
yeah so I just like edits i coverage all

518
00:24:22,830 --> 00:24:24,780
the cases switch cases there's like in

519
00:24:24,780 --> 00:24:26,790
um cases that were not covered and yeah

520
00:24:26,790 --> 00:24:29,940
I committed this I think last night so

521
00:24:29,940 --> 00:24:33,450
it's in trunk now the second one is more

522
00:24:33,450 --> 00:24:36,270
interesting in my opinion so yeah the

523
00:24:36,270 --> 00:24:38,730
test is like straightforward we set some

524
00:24:38,730 --> 00:24:40,890
property of an object and then we assert

525
00:24:40,890 --> 00:24:44,070
that property is exactly like equals to

526
00:24:44,070 --> 00:24:46,560
what we just like used but this is

527
00:24:46,560 --> 00:24:48,030
actually we'll pass if we just comment

528
00:24:48,030 --> 00:24:50,880
out this line just just because the elf

529
00:24:50,880 --> 00:24:53,820
is default value so there is no I mean

530
00:24:53,820 --> 00:24:57,590
yeah so what mutation did in this case

531
00:24:57,590 --> 00:25:00,540
set object format the body of method was

532
00:25:00,540 --> 00:25:02,880
kind of removed like completely and the

533
00:25:02,880 --> 00:25:04,920
tests were still passing so also what I

534
00:25:04,920 --> 00:25:07,290
learned from this very specific examples

535
00:25:07,290 --> 00:25:09,630
so if you have situations like this then

536
00:25:09,630 --> 00:25:12,480
it may make sense as a developer to

537
00:25:12,480 --> 00:25:14,430
cover like two cases at least two cases

538
00:25:14,430 --> 00:25:16,350
and then it's very likely that you're

539
00:25:16,350 --> 00:25:17,940
good to go and you are not is searching

540
00:25:17,940 --> 00:25:20,400
develop default value so again I just

541
00:25:20,400 --> 00:25:22,080
like added like two lines and also

542
00:25:22,080 --> 00:25:24,649
committed it

543
00:25:29,600 --> 00:25:43,920
can you yes yeah this is how it should

544
00:25:43,920 --> 00:25:46,320
work but this is not how it works

545
00:25:46,320 --> 00:25:48,679
yeah

546
00:25:48,890 --> 00:25:51,530
have replaced the Mack owe us first and

547
00:25:51,530 --> 00:25:57,440
they yelled a second because so I think

548
00:25:57,440 --> 00:26:00,790
it's a bit trickier okay I cheated a bit

549
00:26:00,790 --> 00:26:04,220
okay so the elf is not like default like

550
00:26:04,220 --> 00:26:06,110
it's like completely default it based on

551
00:26:06,110 --> 00:26:09,650
so it's default for Linux yeah it

552
00:26:09,650 --> 00:26:11,750
defaults on Linux it but it's different

553
00:26:11,750 --> 00:26:16,370
on OS 6 and even I run it on OSX machine

554
00:26:16,370 --> 00:26:18,710
the triple initialize to the full value

555
00:26:18,710 --> 00:26:21,470
like it when you give the empty empty

556
00:26:21,470 --> 00:26:25,490
string it thinks that it's Linux machine

557
00:26:25,490 --> 00:26:29,440
no idea why but that's how it works

558
00:26:30,310 --> 00:26:33,020
didn't the I didn't have this goal at

559
00:26:33,020 --> 00:26:37,130
all yes so another example I it's not

560
00:26:37,130 --> 00:26:40,070
like the code exactly I think I found it

561
00:26:40,070 --> 00:26:43,280
in our chests but I might be wrong but

562
00:26:43,280 --> 00:26:46,010
the idea is that you have something like

563
00:26:46,010 --> 00:26:48,680
if something then we use slow version of

564
00:26:48,680 --> 00:26:49,420
an algorithm

565
00:26:49,420 --> 00:26:51,860
otherwise we use fast version of the

566
00:26:51,860 --> 00:26:54,200
algorithm and we have some tests and if

567
00:26:54,200 --> 00:26:56,240
we basically introduce some mutation and

568
00:26:56,240 --> 00:26:58,700
we flip those branches then the test

569
00:26:58,700 --> 00:27:01,700
still passes and again one could argue

570
00:27:01,700 --> 00:27:05,510
that this is like fine but I would say

571
00:27:05,510 --> 00:27:08,090
no because the only notion that

572
00:27:08,090 --> 00:27:10,550
something is slow and fast is like

573
00:27:10,550 --> 00:27:12,200
basically the name of a function which

574
00:27:12,200 --> 00:27:13,730
is like not always the case there might

575
00:27:13,730 --> 00:27:16,370
be just some comment and it might be

576
00:27:16,370 --> 00:27:18,710
that it might be true as soon as like

577
00:27:18,710 --> 00:27:20,480
the developer like wrote this code in

578
00:27:20,480 --> 00:27:22,940
the first place but like next year

579
00:27:22,940 --> 00:27:24,620
somebody fixes the back in the slow

580
00:27:24,620 --> 00:27:27,020
version and it becames not that slow

581
00:27:27,020 --> 00:27:29,810
maybe and somebody else fixes back in

582
00:27:29,810 --> 00:27:32,740
the first version and it became slow so

583
00:27:32,740 --> 00:27:35,690
it in this case there should be some

584
00:27:35,690 --> 00:27:37,430
tests like to measure like performance

585
00:27:37,430 --> 00:27:39,260
how slow how fast maybe they are like

586
00:27:39,260 --> 00:27:41,210
not maybe they are the same by

587
00:27:41,210 --> 00:27:42,740
performance and there is no need to

588
00:27:42,740 --> 00:27:50,210
write this code at all yeah I think

589
00:27:50,210 --> 00:27:52,550
that's pretty much this pretty much it

590
00:27:52,550 --> 00:27:56,080
about the showcase I wanted to show

591
00:27:56,350 --> 00:27:58,990
so as I said the tool is still in

592
00:27:58,990 --> 00:28:01,889
progress and we have some open questions

593
00:28:01,889 --> 00:28:04,269
the first one is the most important I

594
00:28:04,269 --> 00:28:06,100
think the most good can a cumbersome is

595
00:28:06,100 --> 00:28:09,159
the integration so since the tool is

596
00:28:09,159 --> 00:28:12,130
working on the level of LLVM bit code of

597
00:28:12,130 --> 00:28:14,649
ir we need to get it somehow sound like

598
00:28:14,649 --> 00:28:18,669
from where from somewhere and to get the

599
00:28:18,669 --> 00:28:21,880
bit code for for tests from LLVM I

600
00:28:21,880 --> 00:28:24,330
needed to use he make the ninja then

601
00:28:24,330 --> 00:28:27,250
like bloody shell scripts was said grep

602
00:28:27,250 --> 00:28:29,350
and so on so it just not straightforward

603
00:28:29,350 --> 00:28:31,870
if you want to use it on your project

604
00:28:31,870 --> 00:28:34,000
like plug and play it's not we're not

605
00:28:34,000 --> 00:28:35,679
there yet so this question is still

606
00:28:35,679 --> 00:28:38,799
opened and we are trying to to find the

607
00:28:38,799 --> 00:28:40,990
best way to do this to improve the thing

608
00:28:40,990 --> 00:28:46,620
so the another kind of problem is nu X

609
00:28:46,710 --> 00:28:49,629
it's still not clear again like how to

610
00:28:49,629 --> 00:28:52,629
do this like properly so was what we did

611
00:28:52,629 --> 00:28:54,759
initially this SQLite file and I wrote

612
00:28:54,759 --> 00:28:56,950
like bunch of Ruby code to generate this

613
00:28:56,950 --> 00:29:01,269
like pretty and nice HTML and it it

614
00:29:01,269 --> 00:29:03,909
really nice and it works for me but I

615
00:29:03,909 --> 00:29:05,259
don't know how it works for other people

616
00:29:05,259 --> 00:29:09,279
and again the question is still open we

617
00:29:09,279 --> 00:29:12,549
are trying to find a way to to make the

618
00:29:12,549 --> 00:29:15,970
system usable for for people so another

619
00:29:15,970 --> 00:29:19,000
one I think it's not not a question

620
00:29:19,000 --> 00:29:20,980
anymore since we merge support for rust

621
00:29:20,980 --> 00:29:22,899
we were talking about like which

622
00:29:22,899 --> 00:29:24,639
language we should try next because

623
00:29:24,639 --> 00:29:28,049
right now the system works fine with C++

624
00:29:28,049 --> 00:29:31,450
but I'm afraid that the system the

625
00:29:31,450 --> 00:29:33,399
current system design can be biased by

626
00:29:33,399 --> 00:29:35,769
C++ itself so we are wanted to take

627
00:29:35,769 --> 00:29:37,690
another language and to make the system

628
00:29:37,690 --> 00:29:41,909
you know now flexible and well good

629
00:29:41,909 --> 00:29:44,110
there are obviously many many many

630
00:29:44,110 --> 00:29:47,889
unknowns so we don't use this tool in

631
00:29:47,889 --> 00:29:50,860
production yet we don't have any users

632
00:29:50,860 --> 00:29:54,370
so far so if you think that you're

633
00:29:54,370 --> 00:29:55,870
interested enjoyed it and you want to

634
00:29:55,870 --> 00:29:58,990
try then I urge you to contact me and I

635
00:29:58,990 --> 00:30:01,779
would be more than happy to help like

636
00:30:01,779 --> 00:30:04,149
free and so on like just for for sake of

637
00:30:04,149 --> 00:30:07,659
the tool yeah so the project is

638
00:30:07,659 --> 00:30:10,210
available on github it's open source

639
00:30:10,210 --> 00:30:13,000
it's like we're developing it well in an

640
00:30:13,000 --> 00:30:16,150
open way so if you have some questions

641
00:30:16,150 --> 00:30:18,310
or you want to get it give it a try and

642
00:30:18,310 --> 00:30:20,230
I will gladly provide you support for

643
00:30:20,230 --> 00:30:23,590
this and just drop me a line at Alex at

644
00:30:23,590 --> 00:30:27,490
low level that's not work yeah and for

645
00:30:27,490 --> 00:30:30,400
some updates you can either follow the

646
00:30:30,400 --> 00:30:31,960
project on github or follow me on

647
00:30:31,960 --> 00:30:35,050
Twitter and I'm posting the updates on

648
00:30:35,050 --> 00:30:57,670
the process questions so I think yes so

649
00:30:57,670 --> 00:31:00,610
I found one one test it's quite lengthy

650
00:31:00,610 --> 00:31:03,040
and it says some quite like another

651
00:31:03,040 --> 00:31:06,220
lengthy function and there are may like

652
00:31:06,220 --> 00:31:09,040
ten assertions in this test and they all

653
00:31:09,040 --> 00:31:11,890
check whether the method returns true so

654
00:31:11,890 --> 00:31:14,890
it doesn't shake the like the it just

655
00:31:14,890 --> 00:31:17,110
checks like one basically one case was

656
00:31:17,110 --> 00:31:20,170
different inputs but one case so yeah

657
00:31:20,170 --> 00:31:24,030
doesn't answer the question okay thanks

658
00:31:24,030 --> 00:31:41,170
yeah I think it well it is compatible

659
00:31:41,170 --> 00:31:43,510
because we control this stuff so we try

660
00:31:43,510 --> 00:31:47,560
to make it compatible and we run all the

661
00:31:47,560 --> 00:31:49,060
tests and all the mutants they are

662
00:31:49,060 --> 00:31:52,060
running in the they run in child process

663
00:31:52,060 --> 00:31:53,410
and we control that process

664
00:31:53,410 --> 00:31:56,470
so if program doesn't work well it

665
00:31:56,470 --> 00:31:58,780
crashes then we know that afresh if it

666
00:31:58,780 --> 00:32:01,170
if it happens to have like some in

667
00:32:01,170 --> 00:32:03,970
infinite loop then we also like we have

668
00:32:03,970 --> 00:32:06,040
timeout and we just like catch this as

669
00:32:06,040 --> 00:32:09,659
well yeah

670
00:32:11,460 --> 00:32:13,480
there are some debates on this in my

671
00:32:13,480 --> 00:32:16,059
opinion which is good I mean the program

672
00:32:16,059 --> 00:32:18,129
is broken then so we broke the the

673
00:32:18,129 --> 00:32:20,460
program so I think it's a good thing but

674
00:32:20,460 --> 00:32:25,029
the opinions are where I yeah I don't

675
00:32:25,029 --> 00:32:26,100
know how

676
00:32:26,100 --> 00:32:46,269
let's go from it right so we we better

677
00:32:46,269 --> 00:32:49,899
control the this aspect we just again

678
00:32:49,899 --> 00:32:52,080
you know like make change in like Yolo

679
00:32:52,080 --> 00:32:58,499
that's that's it it's our approach yes

680
00:33:13,010 --> 00:33:16,099
[Music]

681
00:33:16,200 --> 00:33:22,570
so we we are trying okay so the question

682
00:33:22,570 --> 00:33:26,009
is whether we can

683
00:33:40,490 --> 00:33:43,559
[Music]

684
00:33:50,370 --> 00:33:54,540
yeah so the question is whether we

685
00:33:54,540 --> 00:33:57,430
introduce some mutations on IR level

686
00:33:57,430 --> 00:34:00,220
that are not possible in the source code

687
00:34:00,220 --> 00:34:01,660
level this is correct

688
00:34:01,660 --> 00:34:06,790
yeah more or less so we are trying to

689
00:34:06,790 --> 00:34:08,710
not do this obviously we don't have any

690
00:34:08,710 --> 00:34:11,500
guarantees on this but we are while we

691
00:34:11,500 --> 00:34:14,080
are trying to avoid some mutations we

692
00:34:14,080 --> 00:34:15,969
have some like filters and some

693
00:34:15,969 --> 00:34:18,520
heuristics to not do this so for example

694
00:34:18,520 --> 00:34:20,770
in case of C++ they are like lots of

695
00:34:20,770 --> 00:34:22,659
code is coming from the standard library

696
00:34:22,659 --> 00:34:25,360
for example it just was in line and it

697
00:34:25,360 --> 00:34:27,219
happened to be like the client code

698
00:34:27,219 --> 00:34:29,620
basically but if we mutate it then it

699
00:34:29,620 --> 00:34:31,870
doesn't make any sense because it's

700
00:34:31,870 --> 00:34:34,260
unlikely that you have a problem in well

701
00:34:34,260 --> 00:34:37,750
in standard library like that that's one

702
00:34:37,750 --> 00:34:38,980
where I wanted to say that you get it

703
00:34:38,980 --> 00:34:57,760
yeah so there was another question do

704
00:34:57,760 --> 00:35:01,780
you have any how much will you back to

705
00:35:01,780 --> 00:35:03,400
weaken every time you want to make a

706
00:35:03,400 --> 00:35:05,070
change then for every line of code

707
00:35:05,070 --> 00:35:19,030
change so then those tests that he add

708
00:35:19,030 --> 00:35:20,290
that should never be changed because

709
00:35:20,290 --> 00:35:29,740
they should be right yeah so I don't

710
00:35:29,740 --> 00:35:31,660
have any experience in practice that can

711
00:35:31,660 --> 00:35:34,660
contradict or approve your statement but

712
00:35:34,660 --> 00:35:40,049
it can be yeah it can be so yeah

713
00:35:41,930 --> 00:35:44,510
is this schedule kind of static up front

714
00:35:44,510 --> 00:35:46,580
will you generate them or do you do this

715
00:35:46,580 --> 00:35:49,340
as the testing progresses so you can

716
00:35:49,340 --> 00:35:51,230
bring this look at are we reaching a

717
00:35:51,230 --> 00:35:58,370
threshold in well actually no that's a

718
00:35:58,370 --> 00:36:00,680
good idea but no we do so

719
00:36:00,680 --> 00:36:02,360
the phases like the first phases

720
00:36:02,360 --> 00:36:04,130
analysis we gather all the information

721
00:36:04,130 --> 00:36:06,860
about the whole system all the mutation

722
00:36:06,860 --> 00:36:09,080
points mutants and so on and then we

723
00:36:09,080 --> 00:36:11,720
start generating them and executing so

724
00:36:11,720 --> 00:36:14,240
that might be actually yeah that might

725
00:36:14,240 --> 00:36:41,150
be a good idea yeah plus term any good

726
00:36:41,150 --> 00:36:42,800
changes at the end that you cut short

727
00:36:42,800 --> 00:36:49,790
because yeah but there was like always

728
00:36:49,790 --> 00:36:52,040
the trade-off yeah you can miss

729
00:36:52,040 --> 00:37:02,750
something and you should take a look and

730
00:37:02,750 --> 00:37:07,520
make decision them exactly yes yes yeah

731
00:37:07,520 --> 00:37:09,260
that's the problem why I didn't manage

732
00:37:09,260 --> 00:37:12,290
to give nice analysis based on LLVM

733
00:37:12,290 --> 00:37:14,210
itself because I don't know many parts

734
00:37:14,210 --> 00:37:17,000
of it so I could not understand what's

735
00:37:17,000 --> 00:37:27,640
wrong test or code sorry yeah

736
00:37:29,210 --> 00:37:33,840
so not not yet what we do have plans

737
00:37:33,840 --> 00:37:36,540
like obviously but I am there like long

738
00:37:36,540 --> 00:37:40,230
term not something that will do soon so

739
00:37:40,230 --> 00:37:41,680
thanks for questions

740
00:37:41,680 --> 00:37:46,819
[Applause]

