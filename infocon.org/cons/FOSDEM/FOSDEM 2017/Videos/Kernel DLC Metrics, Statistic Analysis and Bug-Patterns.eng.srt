1
00:00:00,030 --> 00:00:03,559
so after this

2
00:00:05,060 --> 00:00:11,480
the last talk I want to try take taken

3
00:00:11,480 --> 00:00:14,540
into our addressing qualification of the

4
00:00:14,540 --> 00:00:17,840
Knicks last year introduced our project

5
00:00:17,840 --> 00:00:19,280
that is still not completed on

6
00:00:19,280 --> 00:00:21,410
qualifying Linux - safety integrity

7
00:00:21,410 --> 00:00:28,390
level - and where the specific

8
00:00:28,390 --> 00:00:31,880
activities there is how to come up with

9
00:00:31,880 --> 00:00:36,260
a residual fault or expected fault rate

10
00:00:36,260 --> 00:00:38,329
in something as complex as a Linux

11
00:00:38,329 --> 00:00:43,460
kernel basically what I'm going to take

12
00:00:43,460 --> 00:00:45,980
you through is a short context of where

13
00:00:45,980 --> 00:00:47,480
this comes from I'm not going to go into

14
00:00:47,480 --> 00:00:49,219
too much detail there otherwise we run

15
00:00:49,219 --> 00:00:51,440
out of time there in some of the

16
00:00:51,440 --> 00:00:53,629
problems some of the issues that we have

17
00:00:53,629 --> 00:00:56,989
how we might mitigate these issues and

18
00:00:56,989 --> 00:00:59,479
how you can use this for prediction

19
00:00:59,479 --> 00:01:02,059
because really what we are trying to do

20
00:01:02,059 --> 00:01:05,300
is not say Linux is safe we're trying to

21
00:01:05,300 --> 00:01:10,009
say we assume Linux is safe and then we

22
00:01:10,009 --> 00:01:12,469
can do predictions and we can monitor

23
00:01:12,469 --> 00:01:14,840
these predictions so it's good start

24
00:01:14,840 --> 00:01:18,380
with that so that should be context so

25
00:01:18,380 --> 00:01:20,810
the context of this thing is what's

26
00:01:20,810 --> 00:01:25,630
called route 3s approach in 61508 and

27
00:01:25,630 --> 00:01:29,030
related standards what you are doing is

28
00:01:29,030 --> 00:01:31,759
you are taking a pre-existing piece of

29
00:01:31,759 --> 00:01:34,399
software that was not developed in

30
00:01:34,399 --> 00:01:37,909
compliance was a specific safety process

31
00:01:37,909 --> 00:01:43,130
and you are assessing the non-compliant

32
00:01:43,130 --> 00:01:46,909
development against the objectives and

33
00:01:46,909 --> 00:01:49,579
the intent of the safety standard so

34
00:01:49,579 --> 00:01:55,240
basically our primary claim here is

35
00:01:55,240 --> 00:01:59,509
Linux should be suitable or at Linux

36
00:01:59,509 --> 00:02:01,310
based system should be suitable for

37
00:02:01,310 --> 00:02:04,249
safety related systems at safety

38
00:02:04,249 --> 00:02:08,978
integrity level to the

39
00:02:09,520 --> 00:02:13,000
basic assumption that we are making here

40
00:02:13,000 --> 00:02:16,120
and the claim that we have to derive

41
00:02:16,120 --> 00:02:18,490
from that that we say there is a process

42
00:02:18,490 --> 00:02:20,080
we're not saying it's a compliant

43
00:02:20,080 --> 00:02:22,000
process we're just saying there is a

44
00:02:22,000 --> 00:02:25,000
process in place and now we have to look

45
00:02:25,000 --> 00:02:27,640
at how to develop this evidence now why

46
00:02:27,640 --> 00:02:30,810
do we need this is because we have a

47
00:02:30,810 --> 00:02:34,690
black box process basically the software

48
00:02:34,690 --> 00:02:36,370
that we're using the element that we're

49
00:02:36,370 --> 00:02:39,460
trying to use is done we cannot go back

50
00:02:39,460 --> 00:02:41,620
into the requirements phase of the Linux

51
00:02:41,620 --> 00:02:43,630
kernel and say hey well the scheduler

52
00:02:43,630 --> 00:02:46,480
has some systemic fault let's fix that

53
00:02:46,480 --> 00:02:49,750
we just can't do that we have it as is

54
00:02:49,750 --> 00:02:53,800
so basically requirements design up to

55
00:02:53,800 --> 00:02:56,860
the implementation is a black box

56
00:02:56,860 --> 00:03:00,550
product project for us and we have to

57
00:03:00,550 --> 00:03:04,930
say what properties does this unprocess

58
00:03:04,930 --> 00:03:09,370
have what failure rates or what level of

59
00:03:09,370 --> 00:03:12,360
systemic faults could be in there and

60
00:03:12,360 --> 00:03:15,880
then we contain an assessment of process

61
00:03:15,880 --> 00:03:18,580
and come up with sort of an estimated

62
00:03:18,580 --> 00:03:25,270
number of faults in this process as a

63
00:03:25,270 --> 00:03:28,390
result of problems in the process and

64
00:03:28,390 --> 00:03:30,070
let me just plug it into a relatively

65
00:03:30,070 --> 00:03:32,830
simple simplistic view point and say

66
00:03:32,830 --> 00:03:36,040
risk is just probability times severity

67
00:03:36,040 --> 00:03:40,500
now of course assessing the severity is

68
00:03:40,500 --> 00:03:43,600
not an easy thing because that depends

69
00:03:43,600 --> 00:03:45,640
heavily on the specific deployment case

70
00:03:45,640 --> 00:03:48,820
and it also depends on the lot of

71
00:03:48,820 --> 00:03:50,290
assumption that they actually can do

72
00:03:50,290 --> 00:03:52,810
statistic approaches here that means

73
00:03:52,810 --> 00:03:54,900
that we actually have a homogeneous

74
00:03:54,900 --> 00:03:58,750
population of bugs below that we are

75
00:03:58,750 --> 00:04:01,600
actually looking at if the bugs

76
00:04:01,600 --> 00:04:04,930
themselves or the faults in the kernel

77
00:04:04,930 --> 00:04:08,080
are not of our homogenous nature then of

78
00:04:08,080 --> 00:04:10,540
course this would be invalid so we have

79
00:04:10,540 --> 00:04:13,209
to look at that first so systematic

80
00:04:13,209 --> 00:04:17,048
faults so before we go to that I have to

81
00:04:17,048 --> 00:04:19,750
sort of try to clarify a little bit of a

82
00:04:19,750 --> 00:04:22,100
contradiction here because

83
00:04:22,100 --> 00:04:25,940
software is considered to be faulty at a

84
00:04:25,940 --> 00:04:28,280
systemic level software doesn't have

85
00:04:28,280 --> 00:04:31,490
random faults in the sense that if we

86
00:04:31,490 --> 00:04:36,680
identify a Fault in software it is

87
00:04:36,680 --> 00:04:39,050
associated with a state of the machine

88
00:04:39,050 --> 00:04:42,220
and a specific input vector and we

89
00:04:42,220 --> 00:04:46,310
regenerate this state and present the

90
00:04:46,310 --> 00:04:49,280
same input vector then the output will

91
00:04:49,280 --> 00:04:52,250
again be the same now if putting a

92
00:04:52,250 --> 00:04:54,170
machine into an identical state is

93
00:04:54,170 --> 00:04:56,270
technically possible is a different

94
00:04:56,270 --> 00:04:59,420
issue but basically that's our

95
00:04:59,420 --> 00:05:01,580
assumption that means a systemic fault

96
00:05:01,580 --> 00:05:04,370
does not have a rate if if your

97
00:05:04,370 --> 00:05:07,490
filesystem and co-ops as soon as you

98
00:05:07,490 --> 00:05:09,440
create a file that's larger than four

99
00:05:09,440 --> 00:05:11,720
gigabyte it will be rigged more or less

100
00:05:11,720 --> 00:05:14,660
every time maybe it's a locking problem

101
00:05:14,660 --> 00:05:18,200
than it's not so super reproducible that

102
00:05:18,200 --> 00:05:20,630
you can sort of create an environment

103
00:05:20,630 --> 00:05:23,150
where it has a very high probability and

104
00:05:23,150 --> 00:05:26,480
so we cannot just look at bugs and sort

105
00:05:26,480 --> 00:05:28,130
of look at their time development and

106
00:05:28,130 --> 00:05:30,410
the kernel and it deduce a simple rate

107
00:05:30,410 --> 00:05:33,410
from that but what you can do is we can

108
00:05:33,410 --> 00:05:36,050
look at what is the root cause of these

109
00:05:36,050 --> 00:05:38,830
faults and those are human actions and

110
00:05:38,830 --> 00:05:42,410
if we didn't say okay our problem is not

111
00:05:42,410 --> 00:05:46,340
the software fault itself are interested

112
00:05:46,340 --> 00:05:49,580
in is in the failure rate of the humans

113
00:05:49,580 --> 00:05:53,810
behind it then we can associate failure

114
00:05:53,810 --> 00:05:56,630
rate for each every phase B it

115
00:05:56,630 --> 00:05:58,580
requirements design all the way to the

116
00:05:58,580 --> 00:06:02,120
deployment its maintenance and with this

117
00:06:02,120 --> 00:06:06,160
approach we can indirectly evaluate the

118
00:06:06,160 --> 00:06:08,840
failure rate of software and that's what

119
00:06:08,840 --> 00:06:11,020
we're basically going to be trying to do

120
00:06:11,020 --> 00:06:14,930
now what's behind this is that we have a

121
00:06:14,930 --> 00:06:17,360
modified development life cycle for a

122
00:06:17,360 --> 00:06:19,400
safety-related system that is building

123
00:06:19,400 --> 00:06:24,170
on preexisting software now basically

124
00:06:24,170 --> 00:06:26,630
all of the functional safety standards

125
00:06:26,630 --> 00:06:29,120
do allow to do that in the one other way

126
00:06:29,120 --> 00:06:32,630
in including automotive standards like

127
00:06:32,630 --> 00:06:35,380
26262

128
00:06:35,629 --> 00:06:38,500
the idea behind it is that we know that

129
00:06:38,500 --> 00:06:42,650
software elements can be very reliable

130
00:06:42,650 --> 00:06:46,129
because they have experience or field

131
00:06:46,129 --> 00:06:49,219
data and if we look at evolution of open

132
00:06:49,219 --> 00:06:51,110
source components we also can see that

133
00:06:51,110 --> 00:06:53,240
there's a lot of code in the Linux

134
00:06:53,240 --> 00:06:56,840
kernel that has been in there for 12 14

135
00:06:56,840 --> 00:06:58,909
15 years and it's not being changed

136
00:06:58,909 --> 00:07:01,280
because it just showed that it's doing

137
00:07:01,280 --> 00:07:03,979
its job and it's working correctly so

138
00:07:03,979 --> 00:07:07,129
there is a certain merit to recycling a

139
00:07:07,129 --> 00:07:12,319
well proven or well tested code but of

140
00:07:12,319 --> 00:07:14,090
course it also is a dangerous thing

141
00:07:14,090 --> 00:07:16,520
because you are changing context when

142
00:07:16,520 --> 00:07:18,409
you build a new system so this can

143
00:07:18,409 --> 00:07:20,710
backfire if you're not careful with it

144
00:07:20,710 --> 00:07:23,419
but essentially it is possible to do

145
00:07:23,419 --> 00:07:28,129
this level of recycling now this is the

146
00:07:28,129 --> 00:07:30,889
intention of allowing this route in the

147
00:07:30,889 --> 00:07:33,319
safety standards to take what industry

148
00:07:33,319 --> 00:07:35,569
has developed in previous projects or

149
00:07:35,569 --> 00:07:38,449
maybe even predating standardization and

150
00:07:38,449 --> 00:07:41,300
then continue to use it we are kind of

151
00:07:41,300 --> 00:07:43,159
misusing this approach a little bit

152
00:07:43,159 --> 00:07:44,990
because we're applying it to basically

153
00:07:44,990 --> 00:07:47,690
the entire system components so

154
00:07:47,690 --> 00:07:49,039
basically we're applying it to the

155
00:07:49,039 --> 00:07:51,889
kernel gilepsy busy boxes our runtime

156
00:07:51,889 --> 00:07:54,409
environment for safety applications and

157
00:07:54,409 --> 00:07:59,270
the generic libraries of course we're

158
00:07:59,270 --> 00:08:00,789
not applying it to the safety

159
00:08:00,789 --> 00:08:04,310
applications themselves so if you are a

160
00:08:04,310 --> 00:08:06,919
blinker controller or a heart rate

161
00:08:06,919 --> 00:08:09,289
monitoring system for medical device

162
00:08:09,289 --> 00:08:11,449
that's not in scope of what we're doing

163
00:08:11,449 --> 00:08:13,629
because that's not a pre-existing

164
00:08:13,629 --> 00:08:17,210
component that's a new component but it

165
00:08:17,210 --> 00:08:21,020
has to be able to build on assured

166
00:08:21,020 --> 00:08:24,500
properties of the generic components so

167
00:08:24,500 --> 00:08:27,169
we handle that as we go into a regular

168
00:08:27,169 --> 00:08:30,650
system design taking the use case and

169
00:08:30,650 --> 00:08:32,860
design reference missions into account

170
00:08:32,860 --> 00:08:35,630
derive system requirements flow that

171
00:08:35,630 --> 00:08:36,979
down into the system software

172
00:08:36,979 --> 00:08:41,599
architecture which may be partitioning

173
00:08:41,599 --> 00:08:43,760
may be redundancies and high-level

174
00:08:43,760 --> 00:08:46,760
mitigations and then rather than going

175
00:08:46,760 --> 00:08:47,970
into the

176
00:08:47,970 --> 00:08:50,100
regular allocation to hardware and

177
00:08:50,100 --> 00:08:53,519
software we then go into a selection

178
00:08:53,519 --> 00:08:56,329
process and say let's select

179
00:08:56,329 --> 00:08:58,829
pre-existing elements that can do the

180
00:08:58,829 --> 00:09:04,560
job and from that we have to then derive

181
00:09:04,560 --> 00:09:06,389
the requirement that we're going to put

182
00:09:06,389 --> 00:09:09,089
on the safety applications that can be

183
00:09:09,089 --> 00:09:12,120
constraints that can be that they have

184
00:09:12,120 --> 00:09:15,540
to make certain assumptions or that we

185
00:09:15,540 --> 00:09:17,790
have to limit certain capabilities of

186
00:09:17,790 --> 00:09:20,459
the open source or the pre-existing

187
00:09:20,459 --> 00:09:25,199
element and from that we then the derive

188
00:09:25,199 --> 00:09:28,560
a limited configuration space so we

189
00:09:28,560 --> 00:09:32,639
cannot permit if we qualify the

190
00:09:32,639 --> 00:09:34,920
something like the Linux kernel then

191
00:09:34,920 --> 00:09:36,540
this is not going to mean that you can

192
00:09:36,540 --> 00:09:38,879
configure each and every driver in there

193
00:09:38,879 --> 00:09:40,769
it will be a subset there will be

194
00:09:40,769 --> 00:09:42,990
constraints and what you can do at least

195
00:09:42,990 --> 00:09:46,680
in the initial run and probably for any

196
00:09:46,680 --> 00:09:50,160
safety related systems built on on Linux

197
00:09:50,160 --> 00:09:53,670
so that's where we are plugging in the

198
00:09:53,670 --> 00:09:56,399
selection process and this selection

199
00:09:56,399 --> 00:09:59,430
process now has to basically find some

200
00:09:59,430 --> 00:10:02,089
way of selecting elements that have

201
00:10:02,089 --> 00:10:05,250
suitable properties of course we can do

202
00:10:05,250 --> 00:10:07,829
it in a very qualitative way you'd say

203
00:10:07,829 --> 00:10:10,800
well the development process is good so

204
00:10:10,800 --> 00:10:13,199
we'll just trust it but that's kind of a

205
00:10:13,199 --> 00:10:15,839
dangerous thing to do and the approach

206
00:10:15,839 --> 00:10:17,790
we're trying to take and I'm not saying

207
00:10:17,790 --> 00:10:20,819
that we can't do it actually we have

208
00:10:20,819 --> 00:10:22,800
good evidence up to now and our

209
00:10:22,800 --> 00:10:24,750
certification Authority is happy with

210
00:10:24,750 --> 00:10:27,329
what we're doing but we are not done so

211
00:10:27,329 --> 00:10:30,000
we want to quantify each and every

212
00:10:30,000 --> 00:10:31,649
attribute that we will put on this

213
00:10:31,649 --> 00:10:35,459
element and ideally of course then

214
00:10:35,459 --> 00:10:38,360
allowed to come up with a conclusion of

215
00:10:38,360 --> 00:10:41,939
the overall properties now we're looking

216
00:10:41,939 --> 00:10:43,500
at the high level there are of course

217
00:10:43,500 --> 00:10:48,209
Linux processes defined know the Linux

218
00:10:48,209 --> 00:10:50,759
process is of course not a compliant

219
00:10:50,759 --> 00:10:53,100
process and if we look at how it was

220
00:10:53,100 --> 00:10:55,829
developed over time initially there was

221
00:10:55,829 --> 00:10:58,259
no full process specification for the

222
00:10:58,259 --> 00:11:01,300
Linux kernel development there was added

223
00:11:01,300 --> 00:11:03,700
a little bit more than a year ago there

224
00:11:03,700 --> 00:11:06,220
were swords and ends processes like

225
00:11:06,220 --> 00:11:10,600
submitting patches checklists for four

226
00:11:10,600 --> 00:11:13,240
patches submitting drivers and of course

227
00:11:13,240 --> 00:11:15,880
it was kernel documentation more or less

228
00:11:15,880 --> 00:11:18,850
in sync with a development but if we

229
00:11:18,850 --> 00:11:22,209
look at a lot of the details like design

230
00:11:22,209 --> 00:11:24,190
level and requirements level there was

231
00:11:24,190 --> 00:11:27,430
really no systematic process there was a

232
00:11:27,430 --> 00:11:30,040
very evolutionary process on the other

233
00:11:30,040 --> 00:11:34,450
hand the development lifecycle had a lot

234
00:11:34,450 --> 00:11:38,709
of mechanisms in place to prevent real

235
00:11:38,709 --> 00:11:41,140
crap from going into the kernel and it

236
00:11:41,140 --> 00:11:45,339
does not happen that often now aside

237
00:11:45,339 --> 00:11:47,279
from these high level process

238
00:11:47,279 --> 00:11:50,380
specifications and specific I would say

239
00:11:50,380 --> 00:11:52,269
working instructions like submitting

240
00:11:52,269 --> 00:11:52,750
patches

241
00:11:52,750 --> 00:11:55,019
we of course have some very generic

242
00:11:55,019 --> 00:11:59,380
qualitative metrics in there like check

243
00:11:59,380 --> 00:12:03,220
that's checking usual brain-dead

244
00:12:03,220 --> 00:12:06,040
mistakes that developers make static

245
00:12:06,040 --> 00:12:09,910
code checking like Cottonelle sparse GCC

246
00:12:09,910 --> 00:12:12,760
plugins and some external to tools like

247
00:12:12,760 --> 00:12:15,100
stance or blast that were used for the

248
00:12:15,100 --> 00:12:17,620
linux kernel as well so we have a lot of

249
00:12:17,620 --> 00:12:19,990
these tools in place we have a

250
00:12:19,990 --> 00:12:22,750
relatively systematic development of but

251
00:12:22,750 --> 00:12:27,430
of course we do not have this yeah

252
00:12:27,430 --> 00:12:30,540
formal qualification driven approach at

253
00:12:30,540 --> 00:12:32,950
industries used to using now how good

254
00:12:32,950 --> 00:12:36,370
that formal approach is is a on a

255
00:12:36,370 --> 00:12:39,070
different page it's has its weaknesses

256
00:12:39,070 --> 00:12:41,829
as well and you can get our certified

257
00:12:41,829 --> 00:12:45,670
safety engineer in three days if you

258
00:12:45,670 --> 00:12:47,560
just go to the right organization and

259
00:12:47,560 --> 00:12:49,750
pay a few thousand dollars for that

260
00:12:49,750 --> 00:12:51,610
three-day training and then you go out

261
00:12:51,610 --> 00:12:53,640
with a certified safety engineer for

262
00:12:53,640 --> 00:12:56,410
automotive systems which is a frankly a

263
00:12:56,410 --> 00:13:02,350
joke but it's sort of one level of

264
00:13:02,350 --> 00:13:04,480
protection and what really is protecting

265
00:13:04,480 --> 00:13:07,779
us is not the individual measure but the

266
00:13:07,779 --> 00:13:11,970
overall set of measures from the

267
00:13:11,970 --> 00:13:13,889
qualification from the organs

268
00:13:13,889 --> 00:13:17,999
requirements down to the code and sort

269
00:13:17,999 --> 00:13:20,129
of rules how these systems are deployed

270
00:13:20,129 --> 00:13:23,879
so we have a subset of these required

271
00:13:23,879 --> 00:13:26,100
capabilities built into the Linux kernel

272
00:13:26,100 --> 00:13:28,439
process but of course it's not complete

273
00:13:28,439 --> 00:13:31,309
so how do how good do we actually do

274
00:13:31,309 --> 00:13:35,209
start where is a really trivial example

275
00:13:35,209 --> 00:13:39,029
if you submit a patch to the Linux

276
00:13:39,029 --> 00:13:40,709
kernel that fixes a problem you should

277
00:13:40,709 --> 00:13:43,769
have a fixes tag on it or you don't have

278
00:13:43,769 --> 00:13:47,129
to but it's it's recommended basically

279
00:13:47,129 --> 00:13:50,449
the processors if you find this problem

280
00:13:50,449 --> 00:13:54,179
the origin of the problem by bisecting

281
00:13:54,179 --> 00:13:57,569
then the patch should carry a fixes tag

282
00:13:57,569 --> 00:14:02,999
and the fixes tag should carry 12 the

283
00:14:02,999 --> 00:14:05,369
hash of the initializing bug

284
00:14:05,369 --> 00:14:07,829
initializing commit at a length of 12

285
00:14:07,829 --> 00:14:11,639
now this is a trivial requirement it's

286
00:14:11,639 --> 00:14:15,329
not enforced in any way although check

287
00:14:15,329 --> 00:14:17,369
patch in the meantime this does check it

288
00:14:17,369 --> 00:14:20,069
and flag it if it's not but if you look

289
00:14:20,069 --> 00:14:22,350
at the distribution here and this is 4.4

290
00:14:22,350 --> 00:14:25,639
to 4.4 13 kernels so it's a very short

291
00:14:25,639 --> 00:14:30,029
time frame you can see that while the

292
00:14:30,029 --> 00:14:33,419
intended 12 character hash is the most

293
00:14:33,419 --> 00:14:36,540
frequent we have quite a few others so

294
00:14:36,540 --> 00:14:40,759
the failure rate of this non enforced

295
00:14:40,759 --> 00:14:43,169
requirement is actually quite high with

296
00:14:43,169 --> 00:14:48,329
about 17 percent or so now you could say

297
00:14:48,329 --> 00:14:51,689
well that has no impact on safety well

298
00:14:51,689 --> 00:14:55,829
it doesn't but the problem that we are

299
00:14:55,829 --> 00:14:57,769
trying to address is we're trying to

300
00:14:57,769 --> 00:15:01,799
find out the safety properties of the

301
00:15:01,799 --> 00:15:04,559
system by looking at attributes of

302
00:15:04,559 --> 00:15:06,989
development and one attribute of

303
00:15:06,989 --> 00:15:09,059
development of course is how good do

304
00:15:09,059 --> 00:15:11,789
people follow rules that do make sense

305
00:15:11,789 --> 00:15:14,759
so for the case where the hash gets

306
00:15:14,759 --> 00:15:16,559
really very short we could have

307
00:15:16,559 --> 00:15:18,509
theoretical collisions in an act and

308
00:15:18,509 --> 00:15:20,459
actually end up in the wrong patch

309
00:15:20,459 --> 00:15:23,850
during failure and the losses but it's

310
00:15:23,850 --> 00:15:26,549
just one small indication so we can take

311
00:15:26,549 --> 00:15:27,120
very high

312
00:15:27,120 --> 00:15:29,670
attributes and then evaluate how good

313
00:15:29,670 --> 00:15:31,980
are these processes followed more

314
00:15:31,980 --> 00:15:34,589
interesting is to look at code so let's

315
00:15:34,589 --> 00:15:40,889
take one first example there's any

316
00:15:40,889 --> 00:15:42,749
coding standard we expected we have

317
00:15:42,749 --> 00:15:46,110
reasonable conditions where we look at

318
00:15:46,110 --> 00:15:47,220
this code it doesn't have very

319
00:15:47,220 --> 00:15:49,829
reasonable conditions if one unequals

320
00:15:49,829 --> 00:15:52,649
zero if one equals one if you look at

321
00:15:52,649 --> 00:15:54,360
the switch statement it's very funny

322
00:15:54,360 --> 00:15:56,939
because it has an or one equals equals

323
00:15:56,939 --> 00:16:01,730
one in there so that will always be true

324
00:16:01,730 --> 00:16:06,959
and sort of to make it really bad

325
00:16:06,959 --> 00:16:09,449
there's a comment in on top of this

326
00:16:09,449 --> 00:16:11,790
piece of code that lists a whole bunch

327
00:16:11,790 --> 00:16:14,999
of seemingly variable names that don't

328
00:16:14,999 --> 00:16:16,649
appear in the code and there's no

329
00:16:16,649 --> 00:16:20,939
documentation at all this is in mainline

330
00:16:20,939 --> 00:16:23,870
Linux I have no clue how it got in there

331
00:16:23,870 --> 00:16:28,910
how this got by a subsystem maintainer I

332
00:16:28,910 --> 00:16:31,350
contacted the author and asked him how

333
00:16:31,350 --> 00:16:35,309
did he get the idea to write such absurd

334
00:16:35,309 --> 00:16:37,740
code and the explanation does anybody

335
00:16:37,740 --> 00:16:47,100
have an idea how this happens current

336
00:16:47,100 --> 00:16:50,129
base would have been a guess yeah but

337
00:16:50,129 --> 00:16:51,809
it's not coming pasted it's actually a

338
00:16:51,809 --> 00:16:53,699
Windows driver where they tried to turn

339
00:16:53,699 --> 00:16:55,350
off a feature and they didn't want to do

340
00:16:55,350 --> 00:16:56,309
it with if Def's

341
00:16:56,309 --> 00:17:01,139
so they created a variable or defining

342
00:17:01,139 --> 00:17:03,839
here and depending on if this define is

343
00:17:03,839 --> 00:17:07,279
set to Windows or Linux it's 0-1 and

344
00:17:07,279 --> 00:17:10,919
then they have these conditional

345
00:17:10,919 --> 00:17:12,779
statements in here but after the

346
00:17:12,779 --> 00:17:17,010
preprocessor or code generator ran it

347
00:17:17,010 --> 00:17:21,390
replaced this by a zero so if the

348
00:17:21,390 --> 00:17:25,140
statement would be saying if is Linux

349
00:17:25,140 --> 00:17:27,720
equals equals zero do this it would be

350
00:17:27,720 --> 00:17:29,429
understandable but this way of course

351
00:17:29,429 --> 00:17:32,039
it's not understandable so there were

352
00:17:32,039 --> 00:17:35,940
just a code generator problem it's not a

353
00:17:35,940 --> 00:17:37,950
very frequent problem but it's an

354
00:17:37,950 --> 00:17:40,049
existing problem how was this discovered

355
00:17:40,049 --> 00:17:40,750
not by

356
00:17:40,750 --> 00:17:46,600
code review but by a set of static code

357
00:17:46,600 --> 00:17:48,640
checkers that I called my called my

358
00:17:48,640 --> 00:17:53,020
brain dead set it's actually code

359
00:17:53,020 --> 00:17:54,790
checkers that are started writing when

360
00:17:54,790 --> 00:17:57,490
it was checking code from students and

361
00:17:57,490 --> 00:17:59,860
so they just got infuriated by their

362
00:17:59,860 --> 00:18:01,780
really stupid mistakes sometimes I

363
00:18:01,780 --> 00:18:04,210
started putting them into static code

364
00:18:04,210 --> 00:18:06,310
checker and then one day I got the idea

365
00:18:06,310 --> 00:18:07,690
of running around the kernel and it was

366
00:18:07,690 --> 00:18:12,580
shocking what came out so next one

367
00:18:12,580 --> 00:18:16,720
reasonable control flow else if else if

368
00:18:16,720 --> 00:18:19,650
else always doing the same thing

369
00:18:19,650 --> 00:18:22,930
actually the whole sequence was 56 lines

370
00:18:22,930 --> 00:18:25,240
of code that condensed down to two lines

371
00:18:25,240 --> 00:18:28,270
of code so here the whole else--if

372
00:18:28,270 --> 00:18:31,960
else--if hierarchy always doing the same

373
00:18:31,960 --> 00:18:36,070
thing I did contact our author on this

374
00:18:36,070 --> 00:18:37,690
one as well and ask him how did that

375
00:18:37,690 --> 00:18:44,140
happen I never got an answer so I don't

376
00:18:44,140 --> 00:18:46,260
know what the root cause of it is but

377
00:18:46,260 --> 00:18:49,390
it's obviously not something that I

378
00:18:49,390 --> 00:18:51,430
would consider to be reasonable control

379
00:18:51,430 --> 00:18:53,170
flow and as we're here do the talk

380
00:18:53,170 --> 00:18:56,770
before you do expect some coding styles

381
00:18:56,770 --> 00:18:59,020
coding guidelines I'm not going to say

382
00:18:59,020 --> 00:19:01,540
the horrible word that started with MI

383
00:19:01,540 --> 00:19:06,670
and s is with SR ie it's a horrible

384
00:19:06,670 --> 00:19:08,530
standard but Linux kernel coding

385
00:19:08,530 --> 00:19:11,970
standard is quite reasonable

386
00:19:12,150 --> 00:19:15,250
obviously this is not very sound code I

387
00:19:15,250 --> 00:19:17,830
can I don't care about this driver

388
00:19:17,830 --> 00:19:20,740
because it's some multimedia driver that

389
00:19:20,740 --> 00:19:22,410
we will not have in our configuration

390
00:19:22,410 --> 00:19:24,880
but what I care about is it's an

391
00:19:24,880 --> 00:19:28,390
indication of the review process of the

392
00:19:28,390 --> 00:19:32,860
intended procedural requirements for

393
00:19:32,860 --> 00:19:35,410
getting code into the main line did not

394
00:19:35,410 --> 00:19:38,090
really work very good

395
00:19:38,090 --> 00:19:53,990
I heard that exploration a few times but

396
00:19:53,990 --> 00:19:55,730
actually statistically staging is doing

397
00:19:55,730 --> 00:20:00,440
quite good yeah if you if you count the

398
00:20:00,440 --> 00:20:01,970
number of spots worn and cuts and

399
00:20:01,970 --> 00:20:05,090
warnings you'll be sound warnings and

400
00:20:05,090 --> 00:20:07,370
drivers staging and compared with some

401
00:20:07,370 --> 00:20:09,919
other drivers then driver staging

402
00:20:09,919 --> 00:20:11,690
actually is doing quite good Gregg is

403
00:20:11,690 --> 00:20:14,000
doing very good at getting this review

404
00:20:14,000 --> 00:20:16,309
getting early reviews and fixing up this

405
00:20:16,309 --> 00:20:18,470
code I know a number of network and

406
00:20:18,470 --> 00:20:20,240
Wi-Fi drivers that do much worse in

407
00:20:20,240 --> 00:20:37,010
staging yeah but this had nothing today

408
00:20:37,010 --> 00:20:39,649
is technical expertise I mean he he had

409
00:20:39,649 --> 00:20:42,500
eight if deaths in a row always doing

410
00:20:42,500 --> 00:20:45,159
the same thing

411
00:21:02,429 --> 00:21:05,230
that's that's true in here right that

412
00:21:05,230 --> 00:21:07,330
the example here with staging might not

413
00:21:07,330 --> 00:21:09,279
be the best I could have taken one

414
00:21:09,279 --> 00:21:11,019
that's not in staging as well you can

415
00:21:11,019 --> 00:21:12,669
find some outside of staging I didn't

416
00:21:12,669 --> 00:21:14,740
really pay attention to that I just was

417
00:21:14,740 --> 00:21:16,809
taking one example from each category

418
00:21:16,809 --> 00:21:20,110
but I would agree that staging should be

419
00:21:20,110 --> 00:21:21,909
treated differently and statistically we

420
00:21:21,909 --> 00:21:24,009
do treat it differently for instance or

421
00:21:24,009 --> 00:21:26,110
look at commit logs and commit counts

422
00:21:26,110 --> 00:21:30,789
and and and this but fundamentally there

423
00:21:30,789 --> 00:21:33,480
are sort of a baseline where I think

424
00:21:33,480 --> 00:21:36,340
this either should be flagged quite fast

425
00:21:36,340 --> 00:21:39,960
or it should never have made it in and

426
00:21:39,960 --> 00:21:43,509
but I agree that we could discuss if

427
00:21:43,509 --> 00:21:47,230
staging is a valid case here the other

428
00:21:47,230 --> 00:21:49,210
driver was not in staging as far as I

429
00:21:49,210 --> 00:21:55,480
know yes well there's a side effect yeah

430
00:21:55,480 --> 00:21:58,600
okay next one was condition without side

431
00:21:58,600 --> 00:22:01,210
effects now this is not a stating driver

432
00:22:01,210 --> 00:22:03,009
this is actually an extremely old driver

433
00:22:03,009 --> 00:22:06,279
I tried to backtrack where this got in

434
00:22:06,279 --> 00:22:08,320
and it goes all the way back to the 2.0

435
00:22:08,320 --> 00:22:10,690
or 2.2 kernel I'm not sure but it's

436
00:22:10,690 --> 00:22:14,080
really very old code and basically what

437
00:22:14,080 --> 00:22:18,970
is this code doing it's just a simple

438
00:22:18,970 --> 00:22:22,210
way of encoding a retry or just say well

439
00:22:22,210 --> 00:22:24,009
the in bite might fail the first time

440
00:22:24,009 --> 00:22:25,869
because the device is not ready yet or

441
00:22:25,869 --> 00:22:29,110
whatever to just try it again and hope

442
00:22:29,110 --> 00:22:33,490
that the second time will work the

443
00:22:33,490 --> 00:22:37,960
problem with this is that in many cases

444
00:22:37,960 --> 00:22:41,909
such retry loops introduce sort of

445
00:22:41,909 --> 00:22:44,440
entropy into the system where you can no

446
00:22:44,440 --> 00:22:46,720
longer analytically now say in which

447
00:22:46,720 --> 00:22:49,320
state a driver is because you don't know

448
00:22:49,320 --> 00:22:51,820
how many best transaction actually

449
00:22:51,820 --> 00:22:54,490
happened now in this specific case that

450
00:22:54,490 --> 00:22:56,409
actually said it's fine because it's

451
00:22:56,409 --> 00:23:01,210
basically proven in use the CMD 640 ID

452
00:23:01,210 --> 00:23:05,549
drivers is really extremely old driver

453
00:23:05,549 --> 00:23:08,109
and there's probably no point in

454
00:23:08,109 --> 00:23:11,040
changing this because it's

455
00:23:11,040 --> 00:23:13,740
because it just showed that it's working

456
00:23:13,740 --> 00:23:17,140
but it's again it's not about saying

457
00:23:17,140 --> 00:23:19,510
this is wrong code at the technical

458
00:23:19,510 --> 00:23:21,070
level technically this might be an

459
00:23:21,070 --> 00:23:23,740
absolutely sound thing to do

460
00:23:23,740 --> 00:23:26,710
it's the problem that we have to come up

461
00:23:26,710 --> 00:23:31,050
with arguments why such behavior that is

462
00:23:31,050 --> 00:23:33,940
flagged as being unsound and a lot of

463
00:23:33,940 --> 00:23:36,820
other standards is actually permitted in

464
00:23:36,820 --> 00:23:38,230
the code so in this case it would

465
00:23:38,230 --> 00:23:40,240
perfectly find if this code would have

466
00:23:40,240 --> 00:23:45,700
carried a comment saying retry and don't

467
00:23:45,700 --> 00:23:47,620
fail just because the first invite

468
00:23:47,620 --> 00:23:50,110
didn't work or something just the tip

469
00:23:50,110 --> 00:23:51,310
would have had a comment saying

470
00:23:51,310 --> 00:23:54,280
retry then everything would have been

471
00:23:54,280 --> 00:23:56,380
clear so it's not just the technical

472
00:23:56,380 --> 00:24:00,430
issue of saying it's possibly a bug or

473
00:24:00,430 --> 00:24:03,880
possibly incorrect code it's we're

474
00:24:03,880 --> 00:24:05,860
looking at the process side and saying

475
00:24:05,860 --> 00:24:07,810
well if you do something like this it

476
00:24:07,810 --> 00:24:12,870
should have carried a documentation okay

477
00:24:12,870 --> 00:24:15,900
number of parameters in the function

478
00:24:15,900 --> 00:24:20,890
well this is from Tiff's file system

479
00:24:20,890 --> 00:24:22,740
where it's relatively new

480
00:24:22,740 --> 00:24:26,290
I had to shrink the font size as I was

481
00:24:26,290 --> 00:24:28,450
the parameter list would have not fit on

482
00:24:28,450 --> 00:24:32,620
the slide and I love it's readable but

483
00:24:32,620 --> 00:24:37,480
it's 21 parameters and about 1/3 of them

484
00:24:37,480 --> 00:24:40,150
are structs so I would say that's not a

485
00:24:40,150 --> 00:24:41,980
very reasonable interface at least by

486
00:24:41,980 --> 00:24:45,730
all coding standards it's basically not

487
00:24:45,730 --> 00:24:48,370
really possible to understand what code

488
00:24:48,370 --> 00:24:50,470
does if the interface complexity is that

489
00:24:50,470 --> 00:24:53,260
high now it might be justified in this

490
00:24:53,260 --> 00:24:55,180
case I'm not saying this is necessarily

491
00:24:55,180 --> 00:24:58,000
crappy code just by looking at the

492
00:24:58,000 --> 00:25:00,370
parameter count but it's definitely a

493
00:25:00,370 --> 00:25:02,470
piece of code where you say you would

494
00:25:02,470 --> 00:25:04,120
have to exclude that from a safety

495
00:25:04,120 --> 00:25:06,090
related system simply because it's

496
00:25:06,090 --> 00:25:09,700
analytically not tractable I also

497
00:25:09,700 --> 00:25:11,530
seriously doubt that it's there's a

498
00:25:11,530 --> 00:25:14,740
necessity to build such Fortran like

499
00:25:14,740 --> 00:25:18,880
interfaces if you look at the overall

500
00:25:18,880 --> 00:25:23,320
parameters of the Linux kernel left plot

501
00:25:23,320 --> 00:25:23,980
is a loon

502
00:25:23,980 --> 00:25:27,460
your plot quite what you would expect

503
00:25:27,460 --> 00:25:30,760
basically a power-law so most of the

504
00:25:30,760 --> 00:25:32,890
parent about the count of parameters in

505
00:25:32,890 --> 00:25:34,540
linux kernel code looks absolutely

506
00:25:34,540 --> 00:25:36,850
reasonable i don't know where the mean

507
00:25:36,850 --> 00:25:38,620
value is but it's somewhere around three

508
00:25:38,620 --> 00:25:42,160
or so so what you would expect for sound

509
00:25:42,160 --> 00:25:44,200
code design if you look at the log plot

510
00:25:44,200 --> 00:25:46,929
then you can see that this exception

511
00:25:46,929 --> 00:25:48,850
that i just showed you where sis is

512
00:25:48,850 --> 00:25:50,890
actually not so much an exception

513
00:25:50,890 --> 00:25:53,250
there's roughly about a thousand

514
00:25:53,250 --> 00:25:56,910
functions in the linux kernel that have

515
00:25:56,910 --> 00:26:01,270
10 plus parameters in their function

516
00:26:01,270 --> 00:26:05,309
interface and that's probably not really

517
00:26:05,309 --> 00:26:08,380
reasonable in very many cases it just

518
00:26:08,380 --> 00:26:10,660
makes code much harder to read much

519
00:26:10,660 --> 00:26:12,820
harder to understand and so it's

520
00:26:12,820 --> 00:26:14,020
something that you probably want to

521
00:26:14,020 --> 00:26:21,840
avoid okay bug study bugs

522
00:26:21,840 --> 00:26:26,140
okay so we look at this parameter is one

523
00:26:26,140 --> 00:26:26,830
of them

524
00:26:26,830 --> 00:26:29,470
on the requirement that we will place on

525
00:26:29,470 --> 00:26:31,210
the code that we would have in our

526
00:26:31,210 --> 00:26:35,770
minimum config so that we take a minimum

527
00:26:35,770 --> 00:26:39,280
or very restricted configuration for our

528
00:26:39,280 --> 00:26:41,799
safety-related system it's a multi-core

529
00:26:41,799 --> 00:26:45,610
platform supporting basic containers

530
00:26:45,610 --> 00:26:49,690
based on secret namespace seccomp and

531
00:26:49,690 --> 00:26:53,530
cpu shielding and then try to come up

532
00:26:53,530 --> 00:26:55,720
with a minimum configuration than we

533
00:26:55,720 --> 00:26:57,850
checked the parameter and other

534
00:26:57,850 --> 00:27:00,070
attributes on this minimum configuration

535
00:27:00,070 --> 00:27:03,210
and there the maximum was nine and ten

536
00:27:03,210 --> 00:27:06,610
both of those were in lockstep when our

537
00:27:06,610 --> 00:27:08,380
locked up is actually not really a tool

538
00:27:08,380 --> 00:27:09,850
that you would have turned on at runtime

539
00:27:09,850 --> 00:27:12,700
it's a verification tool so we have to

540
00:27:12,700 --> 00:27:14,650
look at verification tool properties as

541
00:27:14,650 --> 00:27:16,750
well but they're not that critical and

542
00:27:16,750 --> 00:27:19,200
since it is a tool and it's recording

543
00:27:19,200 --> 00:27:21,700
information about the function that was

544
00:27:21,700 --> 00:27:23,919
called from it's probably reasonable

545
00:27:23,919 --> 00:27:25,360
that it has a larger number of

546
00:27:25,360 --> 00:27:31,090
parameters so the key point here la put

547
00:27:31,090 --> 00:27:33,250
may not be that beautiful but that's bit

548
00:27:33,250 --> 00:27:35,980
just how I've gotten L scripts that I

549
00:27:35,980 --> 00:27:38,060
used to do this dump

550
00:27:38,060 --> 00:27:40,790
and we can get very precise information

551
00:27:40,790 --> 00:27:43,530
where such problems might be we can

552
00:27:43,530 --> 00:27:45,960
review them and basically sign them off

553
00:27:45,960 --> 00:27:48,720
that this is okay or not okay sometimes

554
00:27:48,720 --> 00:27:50,970
we might have to fix it others we just

555
00:27:50,970 --> 00:27:53,610
have to try to get around

556
00:27:53,610 --> 00:27:58,320
okay that's bug but can't type consist

557
00:27:58,320 --> 00:28:02,580
okay next issue of course or one of the

558
00:28:02,580 --> 00:28:05,210
common issues is type consistencies

559
00:28:05,210 --> 00:28:08,280
typing consistency is account for a lot

560
00:28:08,280 --> 00:28:14,820
of subtle problems time overflows there

561
00:28:14,820 --> 00:28:17,160
was one type inconsistency that we

562
00:28:17,160 --> 00:28:19,080
located in the scheduler that is fixed

563
00:28:19,080 --> 00:28:23,040
in the mean time and one of the kernel

564
00:28:23,040 --> 00:28:25,830
developers and actually confirmed that

565
00:28:25,830 --> 00:28:28,800
this would only trigger on 32-bit

566
00:28:28,800 --> 00:28:31,800
systems and probably only the rest

567
00:28:31,800 --> 00:28:34,650
theoretical rollover after I don't know

568
00:28:34,650 --> 00:28:37,860
how many years so something that's very

569
00:28:37,860 --> 00:28:41,730
hard or very unlikely to ever ever

570
00:28:41,730 --> 00:28:44,070
affect somebody but we could not exclude

571
00:28:44,070 --> 00:28:46,440
in safety related systems that might be

572
00:28:46,440 --> 00:28:49,710
in continuous operation so if you look

573
00:28:49,710 --> 00:28:51,990
at the elements that we are intending to

574
00:28:51,990 --> 00:28:56,160
use at the moment Linux : GFC and busy

575
00:28:56,160 --> 00:29:00,630
box versions are on the slide it's a for

576
00:29:00,630 --> 00:29:02,100
that one kernel I think that I looked at

577
00:29:02,100 --> 00:29:06,540
and 2.9 gilepsy and Boris random busy

578
00:29:06,540 --> 00:29:08,160
box version it just happened to have on

579
00:29:08,160 --> 00:29:12,270
my machine but it's just to get an

580
00:29:12,270 --> 00:29:14,160
overview of how bad are we doing with

581
00:29:14,160 --> 00:29:17,580
types the links kernel type system is

582
00:29:17,580 --> 00:29:22,350
actually really one of the biggest

583
00:29:22,350 --> 00:29:25,170
problems that we have found up to now

584
00:29:25,170 --> 00:29:27,960
it's very hard to actually weed out that

585
00:29:27,960 --> 00:29:31,470
type system but even though it is a very

586
00:29:31,470 --> 00:29:34,320
large system with three hundred seventy

587
00:29:34,320 --> 00:29:37,290
six thousand functions in there the

588
00:29:37,290 --> 00:29:39,180
typing consistencies are not that bad

589
00:29:39,180 --> 00:29:42,180
we're talking about two point yeah two

590
00:29:42,180 --> 00:29:44,390
point 85 percent if I have the correct

591
00:29:44,390 --> 00:29:47,100
where we add typing consistencies and

592
00:29:47,100 --> 00:29:49,440
functions what is a typing consistency

593
00:29:49,440 --> 00:29:51,330
basically you have a function that's a

594
00:29:51,330 --> 00:29:54,990
to return an INT and the actual return

595
00:29:54,990 --> 00:29:58,740
values of a different type or you have a

596
00:29:58,740 --> 00:30:02,010
function call and it's a sign the return

597
00:30:02,010 --> 00:30:06,090
value of a function call is assigned to

598
00:30:06,090 --> 00:30:08,970
a different type so both color on color

599
00:30:08,970 --> 00:30:14,400
side typing consistencies gin up see

600
00:30:14,400 --> 00:30:17,910
though it's significantly smaller about

601
00:30:17,910 --> 00:30:21,420
a factor 30 smaller that's about justice

602
00:30:21,420 --> 00:30:25,380
good or bad and busybox even those two

603
00:30:25,380 --> 00:30:27,150
orders of magnitude smaller than the

604
00:30:27,150 --> 00:30:30,480
linux kernel has about a factor to only

605
00:30:30,480 --> 00:30:34,230
on inconsistent types now

606
00:30:34,230 --> 00:30:36,390
that would imply that the little kernel

607
00:30:36,390 --> 00:30:39,330
is actually doing very well in general I

608
00:30:39,330 --> 00:30:41,730
would be really interested in comparing

609
00:30:41,730 --> 00:30:44,660
some of these metrics with commercial

610
00:30:44,660 --> 00:30:47,010
safety related operating systems

611
00:30:47,010 --> 00:30:48,980
unfortunately these companies are very

612
00:30:48,980 --> 00:30:54,810
unwilling to let us do that so let's

613
00:30:54,810 --> 00:30:56,870
look at the kernel a bit more in detail

614
00:30:56,870 --> 00:31:01,650
type inconsistencies this is only semi

615
00:31:01,650 --> 00:31:04,560
automated at the moment and it might

616
00:31:04,560 --> 00:31:07,470
contain some incorrect data it is for

617
00:31:07,470 --> 00:31:10,020
x86 64 only because of course when you

618
00:31:10,020 --> 00:31:12,390
look in your typing consistencies you

619
00:31:12,390 --> 00:31:15,060
are bound to a specific architecture or

620
00:31:15,060 --> 00:31:17,460
their natural lengths word length of the

621
00:31:17,460 --> 00:31:21,660
architecture in some cases it might be a

622
00:31:21,660 --> 00:31:24,810
typing consistency in one arc addiction

623
00:31:24,810 --> 00:31:26,850
not in another architecture but

624
00:31:26,850 --> 00:31:31,260
basically sine assigning or switching

625
00:31:31,260 --> 00:31:34,830
sign bits during during assignments or

626
00:31:34,830 --> 00:31:37,470
during a return is generally something

627
00:31:37,470 --> 00:31:39,360
that could be a problem or has a

628
00:31:39,360 --> 00:31:41,580
relatively higher probability of being a

629
00:31:41,580 --> 00:31:42,030
problem

630
00:31:42,030 --> 00:31:44,820
so that's flagged as being problematic

631
00:31:44,820 --> 00:31:46,860
and we can see that there's quite a bit

632
00:31:46,860 --> 00:31:50,130
in the kernel core and in the network

633
00:31:50,130 --> 00:31:53,430
core has also a quite significant amount

634
00:31:53,430 --> 00:31:56,220
now in the network core it's probably

635
00:31:56,220 --> 00:32:01,350
explainable because it's in a lot of

636
00:32:01,350 --> 00:32:02,320
cases

637
00:32:02,320 --> 00:32:05,710
you are converting Network to host

638
00:32:05,710 --> 00:32:08,590
typing vice versa and you don't care

639
00:32:08,590 --> 00:32:11,440
about sign because you know that it will

640
00:32:11,440 --> 00:32:13,960
fit or you know that it's not going to

641
00:32:13,960 --> 00:32:17,259
cause a problem but it's that's the

642
00:32:17,259 --> 00:32:19,149
disadvantage of static code checker

643
00:32:19,149 --> 00:32:19,840
metrics

644
00:32:19,840 --> 00:32:22,210
it doesn't necessarily give you a causal

645
00:32:22,210 --> 00:32:24,370
explanation what's going on but it's

646
00:32:24,370 --> 00:32:26,679
something that we need to review for the

647
00:32:26,679 --> 00:32:29,740
specific specific configuration this is

648
00:32:29,740 --> 00:32:31,630
now for the entire kernel at the moment

649
00:32:31,630 --> 00:32:33,970
basically what we do is we filter it out

650
00:32:33,970 --> 00:32:35,889
for the specific configuration that we

651
00:32:35,889 --> 00:32:39,940
can assess it and possibly fix it or in

652
00:32:39,940 --> 00:32:43,980
some case it just documented downsizing

653
00:32:43,980 --> 00:32:46,690
that's basically a truncation problem

654
00:32:46,690 --> 00:32:49,120
not that many in the kernel I think most

655
00:32:49,120 --> 00:32:53,529
of those are actually bugs we didn't yet

656
00:32:53,529 --> 00:32:55,269
go through all of them some of them were

657
00:32:55,269 --> 00:32:58,600
fixed but not all of them the one that's

658
00:32:58,600 --> 00:33:01,240
probably not so self-explaining is a

659
00:33:01,240 --> 00:33:04,870
false pulse on there false positives

660
00:33:04,870 --> 00:33:07,929
occur because the Linux kernel type

661
00:33:07,929 --> 00:33:12,700
system is really hard to get a complete

662
00:33:12,700 --> 00:33:16,629
grasp on we've found 12 different ways

663
00:33:16,629 --> 00:33:20,470
of how unsigned int are declared in the

664
00:33:20,470 --> 00:33:24,820
Linux kernel and for 64-bit types it

665
00:33:24,820 --> 00:33:29,019
even gets worse so we have these

666
00:33:29,019 --> 00:33:32,110
translation tables that are probably not

667
00:33:32,110 --> 00:33:34,120
completely consistent to actually

668
00:33:34,120 --> 00:33:37,690
evaluate if types are equivalent so what

669
00:33:37,690 --> 00:33:41,889
you see is that a type is assigned to a

670
00:33:41,889 --> 00:33:43,809
different type but you don't immediately

671
00:33:43,809 --> 00:33:47,009
know if it's of the same length or same

672
00:33:47,009 --> 00:33:50,799
sign so you have to sort of map it to

673
00:33:50,799 --> 00:33:53,860
the basic type and that's of course

674
00:33:53,860 --> 00:33:55,509
again architecture-specific

675
00:33:55,509 --> 00:33:57,940
and it's not always easy to do actually

676
00:33:57,940 --> 00:34:00,820
resolving some of the type in the Linux

677
00:34:00,820 --> 00:34:03,570
kernel turned out to be very hard now

678
00:34:03,570 --> 00:34:07,210
this is a problem a systematic problem

679
00:34:07,210 --> 00:34:08,800
with the kernel it doesn't mean that any

680
00:34:08,800 --> 00:34:11,530
line any piece of this code is wrong it

681
00:34:11,530 --> 00:34:13,719
might all be correct but it means it's

682
00:34:13,719 --> 00:34:15,699
harder to read it's harder to review

683
00:34:15,699 --> 00:34:16,190
it's hard

684
00:34:16,190 --> 00:34:19,460
to understand and we know that a

685
00:34:19,460 --> 00:34:22,879
significant portion of problems in the

686
00:34:22,879 --> 00:34:24,800
Lynx Colonel happens by cut and paste

687
00:34:24,800 --> 00:34:27,679
code a gentleman just mentioned that as

688
00:34:27,679 --> 00:34:29,989
a possible source before and of course

689
00:34:29,989 --> 00:34:32,599
if you have some implicit type

690
00:34:32,599 --> 00:34:34,969
conversion or downsizing at one end of

691
00:34:34,969 --> 00:34:36,409
the kernel it might be perfectly

692
00:34:36,409 --> 00:34:39,379
legitimate but you then copy this piece

693
00:34:39,379 --> 00:34:41,960
of code or this code fragment to a

694
00:34:41,960 --> 00:34:44,829
different context and it might well be

695
00:34:44,829 --> 00:34:48,879
incorrect in that specific context

696
00:34:48,879 --> 00:34:55,668
okay that's a great API oh okay yeah

697
00:34:55,668 --> 00:34:59,030
next word let's take as an example and

698
00:34:59,030 --> 00:35:02,390
at that time undocumented kernel API

699
00:35:02,390 --> 00:35:06,290
which was a completion API that's why we

700
00:35:06,290 --> 00:35:09,579
selected that then write up formal

701
00:35:09,579 --> 00:35:12,980
specifications for it or actually static

702
00:35:12,980 --> 00:35:16,220
code checkers checking certain parts of

703
00:35:16,220 --> 00:35:18,589
the formal specification we are using

704
00:35:18,589 --> 00:35:22,780
cuts in ELLs and in some cases blast and

705
00:35:22,780 --> 00:35:25,010
then run that over the kernel and you

706
00:35:25,010 --> 00:35:26,750
can see that there's quite a significant

707
00:35:26,750 --> 00:35:29,450
number of inconsistencies it can be

708
00:35:29,450 --> 00:35:31,869
found some very simple like double

709
00:35:31,869 --> 00:35:35,359
initialization some of them not so

710
00:35:35,359 --> 00:35:40,089
simple like being in the wrong context

711
00:35:40,089 --> 00:35:42,440
although in that case there were no

712
00:35:42,440 --> 00:35:46,069
findings again signed and unsigned

713
00:35:46,069 --> 00:35:49,069
checks this was everything from

714
00:35:49,069 --> 00:35:51,470
completion returning an unsigned value

715
00:35:51,470 --> 00:35:53,480
and then these being checked for being

716
00:35:53,480 --> 00:35:57,050
negative or being assigned to an

717
00:35:57,050 --> 00:35:59,690
unsigned value so there's a whole bunch

718
00:35:59,690 --> 00:36:01,339
of different problems that can be

719
00:36:01,339 --> 00:36:06,109
uncovered we attribute the quite large

720
00:36:06,109 --> 00:36:07,790
number of findings related to

721
00:36:07,790 --> 00:36:09,650
completions to the lack of the

722
00:36:09,650 --> 00:36:12,829
documentation so the mitigation here was

723
00:36:12,829 --> 00:36:14,150
actually to sit down the right to

724
00:36:14,150 --> 00:36:16,369
documentation that's in main line but by

725
00:36:16,369 --> 00:36:20,210
now and of course fix up a very large

726
00:36:20,210 --> 00:36:23,480
number of these problems it turns out

727
00:36:23,480 --> 00:36:25,880
that quite a few subsystem maintainers

728
00:36:25,880 --> 00:36:29,570
are not very happy with these things

729
00:36:29,570 --> 00:36:31,370
I can understand that because basically

730
00:36:31,370 --> 00:36:36,130
they're saying well you're removing

731
00:36:36,880 --> 00:36:40,850
useless tests or useless condition in

732
00:36:40,850 --> 00:36:43,160
the kernel that's not really hurting us

733
00:36:43,160 --> 00:36:44,990
and we don't want to change code that

734
00:36:44,990 --> 00:36:47,360
has been stable and running correctly so

735
00:36:47,360 --> 00:36:49,670
that's basically acceptable what we just

736
00:36:49,670 --> 00:36:51,470
have to get it off our list for a

737
00:36:51,470 --> 00:36:54,460
qualification and then just say okay

738
00:36:54,460 --> 00:36:56,630
based on feedback from developers

739
00:36:56,630 --> 00:36:58,280
they're not going to change it because

740
00:36:58,280 --> 00:37:01,040
they don't want to change it it's it's

741
00:37:01,040 --> 00:37:04,220
working properly or correctly so it's

742
00:37:04,220 --> 00:37:07,340
it's not saying again these metrics are

743
00:37:07,340 --> 00:37:10,640
not about saying code is crappy these

744
00:37:10,640 --> 00:37:13,400
metrics are saying how good how solid is

745
00:37:13,400 --> 00:37:16,400
the process and this is maybe one of the

746
00:37:16,400 --> 00:37:19,930
key issues with this review or

747
00:37:19,930 --> 00:37:21,980
pre-existing software and safety related

748
00:37:21,980 --> 00:37:24,260
systems why open source had such a

749
00:37:24,260 --> 00:37:26,720
fundamental advantage is because we're

750
00:37:26,720 --> 00:37:28,010
actually getting a lot of feedback from

751
00:37:28,010 --> 00:37:31,700
the people so we were sent out mails

752
00:37:31,700 --> 00:37:34,550
about the root cause of some of the bugs

753
00:37:34,550 --> 00:37:38,230
the return rate of email was about 80%

754
00:37:38,230 --> 00:37:41,480
anybody that ever that did studies in

755
00:37:41,480 --> 00:37:44,510
the Sociology those are the return rate

756
00:37:44,510 --> 00:37:47,510
of 5% - something to celebrate open

757
00:37:47,510 --> 00:37:51,590
source is a little bit better okay next

758
00:37:51,590 --> 00:37:54,770
one was you sleep ranges you sleep

759
00:37:54,770 --> 00:37:57,500
ranges is documented documentation

760
00:37:57,500 --> 00:38:02,420
timers timers txt has a recommendation

761
00:38:02,420 --> 00:38:04,100
for you sleep bridge it but it's a

762
00:38:04,100 --> 00:38:07,490
little bit quirky interface the court

763
00:38:07,490 --> 00:38:10,160
here is that you you pass you sleep

764
00:38:10,160 --> 00:38:11,620
brain min/max

765
00:38:11,620 --> 00:38:14,330
to tell it that you want to sleep at

766
00:38:14,330 --> 00:38:17,960
least minimum and at most maximum what's

767
00:38:17,960 --> 00:38:20,000
intention behind this you sleep brain

768
00:38:20,000 --> 00:38:22,880
just uses high resolution timers so you

769
00:38:22,880 --> 00:38:24,980
don't want to burden the high resolution

770
00:38:24,980 --> 00:38:29,320
timer subsystem with large numbers of

771
00:38:29,320 --> 00:38:32,390
timers notably that actually don't need

772
00:38:32,390 --> 00:38:36,410
to be that precise but the next level of

773
00:38:36,410 --> 00:38:38,720
timers using something like M sleep

774
00:38:38,720 --> 00:38:41,480
really Asst hats granularity which is

775
00:38:41,480 --> 00:38:43,099
very coarse grain

776
00:38:43,099 --> 00:38:45,589
so the compromise is to say you take a

777
00:38:45,589 --> 00:38:47,239
high-resolution timer but you're not

778
00:38:47,239 --> 00:38:48,739
going to be picky about when it should

779
00:38:48,739 --> 00:38:50,630
fire it should fire somewhere between

780
00:38:50,630 --> 00:38:53,989
min and Max and if there is a timer

781
00:38:53,989 --> 00:38:56,630
already allocated in this range and we

782
00:38:56,630 --> 00:38:59,269
just can hook it up there and let both

783
00:38:59,269 --> 00:39:02,119
of these callbacks fire at the same time

784
00:39:02,119 --> 00:39:04,729
we don't need to actually extend the

785
00:39:04,729 --> 00:39:07,759
arbitral higher resolution timers the

786
00:39:07,759 --> 00:39:09,529
problem is a conversion is though that

787
00:39:09,529 --> 00:39:12,170
the timer that is actually initialized

788
00:39:12,170 --> 00:39:13,759
it's not the minimum value but the

789
00:39:13,759 --> 00:39:16,549
maximum value and obviously if you look

790
00:39:16,549 --> 00:39:18,619
at the conversion most of the developers

791
00:39:18,619 --> 00:39:21,890
converted them to the initial value

792
00:39:21,890 --> 00:39:24,079
would be converted to the minimum value

793
00:39:24,079 --> 00:39:28,099
and then extend it to maximum and this

794
00:39:28,099 --> 00:39:30,559
is extremely close to the maximum so if

795
00:39:30,559 --> 00:39:33,829
you take a hybrid you sleep range timer

796
00:39:33,829 --> 00:39:37,519
and just test it you'll find that on an

797
00:39:37,519 --> 00:39:39,229
idle system more or less a hundred

798
00:39:39,229 --> 00:39:40,819
percent of them fire at the maximum

799
00:39:40,819 --> 00:39:42,920
value not the minimum value and then a

800
00:39:42,920 --> 00:39:46,880
loaded system they fire almost anytime

801
00:39:46,880 --> 00:39:49,339
because it's not non-atomic context so

802
00:39:49,339 --> 00:39:51,769
you can be scheduled out and your worst

803
00:39:51,769 --> 00:39:54,469
case will be is a range of hundreds of

804
00:39:54,469 --> 00:39:57,170
milliseconds even if you try to send set

805
00:39:57,170 --> 00:39:59,390
a you sleep range of 10 to 12

806
00:39:59,390 --> 00:40:03,109
microseconds so we just looked at that

807
00:40:03,109 --> 00:40:06,349
how the recommendation in the

808
00:40:06,349 --> 00:40:08,749
documentation sort of the use LaBranche

809
00:40:08,749 --> 00:40:11,150
minimal should not be smaller than 10

810
00:40:11,150 --> 00:40:14,089
and the maximum should not be more than

811
00:40:14,089 --> 00:40:16,729
10 milliseconds so we just did a simple

812
00:40:16,729 --> 00:40:18,920
check to how often that is correct or

813
00:40:18,920 --> 00:40:21,979
not and as you can see the for the

814
00:40:21,979 --> 00:40:24,309
hard-coded values over the constants

815
00:40:24,309 --> 00:40:27,469
it's about four and a half percent that

816
00:40:27,469 --> 00:40:31,069
are violating the specification if that

817
00:40:31,069 --> 00:40:33,349
really has an impact on the correctness

818
00:40:33,349 --> 00:40:35,900
of the code is again not really the key

819
00:40:35,900 --> 00:40:38,809
issue I would expect it in almost all of

820
00:40:38,809 --> 00:40:41,839
these cases it doesn't matter from with

821
00:40:41,839 --> 00:40:43,489
respect to the correctness but it does

822
00:40:43,489 --> 00:40:46,180
matter with respect to adherence to

823
00:40:46,180 --> 00:40:50,150
coding guidelines and the preprocessor

824
00:40:50,150 --> 00:40:55,290
was similar and for those that are on

825
00:40:55,290 --> 00:40:58,110
it's a little bit hard to evaluate so

826
00:40:58,110 --> 00:41:01,530
those counts are in parentheses because

827
00:41:01,530 --> 00:41:03,270
they're actually based on some

828
00:41:03,270 --> 00:41:05,610
heuristics and rough estimations I

829
00:41:05,610 --> 00:41:07,470
wouldn't sign them off as being correct

830
00:41:07,470 --> 00:41:10,830
but he can see again a rough roughly 5

831
00:41:10,830 --> 00:41:13,710
percent incorrect rate okay we're

832
00:41:13,710 --> 00:41:19,130
running out of time already okay okay so

833
00:41:19,130 --> 00:41:22,710
yeah that's the bugs yeah

834
00:41:22,710 --> 00:41:26,130
big bugs big BOTS all sort of big BOTS

835
00:41:26,130 --> 00:41:28,890
that's from what round the one and you

836
00:41:28,890 --> 00:41:30,810
can see look at the left plot which are

837
00:41:30,810 --> 00:41:34,230
the errors oh sorry the failures you can

838
00:41:34,230 --> 00:41:36,150
see that there's no real pattern for the

839
00:41:36,150 --> 00:41:37,920
warning there seems to be a pattern so

840
00:41:37,920 --> 00:41:40,410
we can use that as sort of a reliability

841
00:41:40,410 --> 00:41:41,610
growth approach

842
00:41:41,610 --> 00:41:45,720
so if to speed up a little bit yeah how

843
00:41:45,720 --> 00:41:49,110
do you intend to use this basically most

844
00:41:49,110 --> 00:41:51,420
of the code is clean that's the good

845
00:41:51,420 --> 00:41:54,930
message and actually if looking at the

846
00:41:54,930 --> 00:41:56,970
data that we have most of the problem

847
00:41:56,970 --> 00:42:03,150
cases were in drivers where some in FS

848
00:42:03,150 --> 00:42:05,000
FS turned out to be my favorite

849
00:42:05,000 --> 00:42:09,270
subsystem in the meantime but it's not

850
00:42:09,270 --> 00:42:11,010
as bad as it might seem from this

851
00:42:11,010 --> 00:42:13,500
presentation and there is a problem with

852
00:42:13,500 --> 00:42:16,020
type issues that needs to be addressed

853
00:42:16,020 --> 00:42:19,050
and that brings me to I'm just going to

854
00:42:19,050 --> 00:42:21,750
skip that far they were actual intent to

855
00:42:21,750 --> 00:42:25,140
treat bad code and basically our trick

856
00:42:25,140 --> 00:42:27,180
and that's trick that you only have

857
00:42:27,180 --> 00:42:29,040
available in the open source community

858
00:42:29,040 --> 00:42:32,040
is by selection we can actually just say

859
00:42:32,040 --> 00:42:34,860
okay let's look at the properties of the

860
00:42:34,860 --> 00:42:37,560
attributes will I bury the attributes of

861
00:42:37,560 --> 00:42:39,450
different file systems and take the best

862
00:42:39,450 --> 00:42:42,930
one that doesn't mean that other file

863
00:42:42,930 --> 00:42:45,120
systems are crappy but it just means

864
00:42:45,120 --> 00:42:51,180
that those other file systems other file

865
00:42:51,180 --> 00:42:53,310
systems are not suitable for safety

866
00:42:53,310 --> 00:42:56,610
related systems so you can do that by

867
00:42:56,610 --> 00:42:59,250
selection some tase's will I have to

868
00:42:59,250 --> 00:43:03,390
introduce constraints on on the usage or

869
00:43:03,390 --> 00:43:05,550
on the applications and of course we can

870
00:43:05,550 --> 00:43:07,410
sit down and fix some of them we

871
00:43:07,410 --> 00:43:08,940
actually have been doing that

872
00:43:08,940 --> 00:43:10,470
so it's about a little over two in the

873
00:43:10,470 --> 00:43:12,060
patches that are in the kernel in the

874
00:43:12,060 --> 00:43:14,990
mean time from the seal to Linux project

875
00:43:14,990 --> 00:43:22,490
but yeah that's basically it's it's

876
00:43:22,490 --> 00:43:26,069
eliminate the problem rather than trying

877
00:43:26,069 --> 00:43:28,890
to fix it by adjusting your

878
00:43:28,890 --> 00:43:31,619
configuration and one more time of

879
00:43:31,619 --> 00:43:33,329
course there's a stable base in the

880
00:43:33,329 --> 00:43:35,010
Linux kernel if we take something that

881
00:43:35,010 --> 00:43:36,869
got all no config we can see a

882
00:43:36,869 --> 00:43:38,490
significant difference in these

883
00:43:38,490 --> 00:43:42,869
attributes okay the sort of brings me to

884
00:43:42,869 --> 00:43:44,550
how stable is that actually so that

885
00:43:44,550 --> 00:43:50,310
should be the DLC okay yeah we're going

886
00:43:50,310 --> 00:43:52,589
to do a prediction we call this a

887
00:43:52,589 --> 00:43:54,660
top-down model the top-down model is

888
00:43:54,660 --> 00:43:57,180
based on saying we look at the kernel

889
00:43:57,180 --> 00:43:59,520
process as a whole we want to evaluate

890
00:43:59,520 --> 00:44:02,520
certain property development over time

891
00:44:02,520 --> 00:44:06,390
within sub levels between sub levels we

892
00:44:06,390 --> 00:44:08,880
want to understand how are these

893
00:44:08,880 --> 00:44:11,460
parameters developing we'll look at

894
00:44:11,460 --> 00:44:14,790
different trees I'm going to just be

895
00:44:14,790 --> 00:44:17,190
showing you the stable and a little bit

896
00:44:17,190 --> 00:44:20,190
from next just time issue the data

897
00:44:20,190 --> 00:44:22,230
amount that we ate to generate this way

898
00:44:22,230 --> 00:44:25,560
is quite large but basically we can look

899
00:44:25,560 --> 00:44:28,890
at these properties at a statistical

900
00:44:28,890 --> 00:44:32,880
basis because or assuming that it is a

901
00:44:32,880 --> 00:44:35,010
very constant process so the first thing

902
00:44:35,010 --> 00:44:36,869
is to look at how constant this process

903
00:44:36,869 --> 00:44:42,030
actually is well this is just a rough

904
00:44:42,030 --> 00:44:45,569
and probably not completely you could

905
00:44:45,569 --> 00:44:47,520
find a lot of things on this dlc picture

906
00:44:47,520 --> 00:44:48,839
that you could probably improve but it

907
00:44:48,839 --> 00:44:50,160
should just give you an impression of

908
00:44:50,160 --> 00:44:51,839
that there's a lot of checks and

909
00:44:51,839 --> 00:44:53,369
balances there's a systematic

910
00:44:53,369 --> 00:44:56,240
development and multiple branches

911
00:44:56,240 --> 00:44:59,369
integrating into Linux next those

912
00:44:59,369 --> 00:45:01,829
transitions of how patches coming from

913
00:45:01,829 --> 00:45:06,630
ok now we mark them as being rejected

914
00:45:06,630 --> 00:45:09,569
going back if they are discussed and

915
00:45:09,569 --> 00:45:14,819
they come in there v2 v3 v4 then they go

916
00:45:14,819 --> 00:45:18,270
into stable into through the commit

917
00:45:18,270 --> 00:45:21,140
window and then our c1 to RCA to

918
00:45:21,140 --> 00:45:22,200
civilization

919
00:45:22,200 --> 00:45:23,730
faith and we have the next stable this

920
00:45:23,730 --> 00:45:26,550
is a very time driven process so the top

921
00:45:26,550 --> 00:45:29,369
part is asynchronous basically feature

922
00:45:29,369 --> 00:45:31,200
driven and the bottom part is in time

923
00:45:31,200 --> 00:45:33,680
driven

924
00:45:33,680 --> 00:45:38,910
yeah that's 4.4 to 4.4 thirteen yeah so

925
00:45:38,910 --> 00:45:41,520
if you look at that process in practice

926
00:45:41,520 --> 00:45:44,130
with respect to some some of the metrics

927
00:45:44,130 --> 00:45:46,200
you can see that the first RC one has

928
00:45:46,200 --> 00:45:48,839
some like 12,000 commits coming in more

929
00:45:48,839 --> 00:45:52,380
than almost 10,000 files changed the

930
00:45:52,380 --> 00:45:54,690
number of lines per commit with around

931
00:45:54,690 --> 00:45:57,300
was 57 it's quite large and you can see

932
00:45:57,300 --> 00:45:59,760
that it systematically goes down the

933
00:45:59,760 --> 00:46:02,820
little hiccup at 4.4 that I think it's

934
00:46:02,820 --> 00:46:05,300
three with thirteen or two with 13 is

935
00:46:05,300 --> 00:46:08,010
it's a little bit of an outlier but of

936
00:46:08,010 --> 00:46:09,780
course it's not that consistent a

937
00:46:09,780 --> 00:46:11,369
process there might be a reason for that

938
00:46:11,369 --> 00:46:13,770
but you can very nicely see the number

939
00:46:13,770 --> 00:46:17,420
of files being changed number of commits

940
00:46:17,420 --> 00:46:20,010
systematically goes down how does it

941
00:46:20,010 --> 00:46:21,420
look in the long run that you've been

942
00:46:21,420 --> 00:46:25,589
oiling this is multiple Linux next

943
00:46:25,589 --> 00:46:27,630
versions you can see that the shape of

944
00:46:27,630 --> 00:46:31,200
these integration curves further I think

945
00:46:31,200 --> 00:46:33,390
it's for that oh for one and for two for

946
00:46:33,390 --> 00:46:35,520
three on this right but don't matter

947
00:46:35,520 --> 00:46:38,550
it's it doesn't change its its shape

948
00:46:38,550 --> 00:46:40,560
over time for you so we have a very

949
00:46:40,560 --> 00:46:43,619
consistent process in place and that's

950
00:46:43,619 --> 00:46:46,170
the reason why we say we actually can

951
00:46:46,170 --> 00:46:50,609
apply a statistic methods so that's a

952
00:46:50,609 --> 00:46:54,750
nick bin okay another way of looking at

953
00:46:54,750 --> 00:46:58,200
the consistency of the process is this

954
00:46:58,200 --> 00:47:00,210
is sort of just the timeline for every

955
00:47:00,210 --> 00:47:01,859
reasonable x axis because it's in

956
00:47:01,859 --> 00:47:04,020
seconds but it just was easier to plot

957
00:47:04,020 --> 00:47:07,560
it this way so we just take the starting

958
00:47:07,560 --> 00:47:09,750
commit plotted in in seconds and you can

959
00:47:09,750 --> 00:47:11,760
see that the sort of the starting point

960
00:47:11,760 --> 00:47:14,220
is really a close to perfect line if you

961
00:47:14,220 --> 00:47:15,750
do a linear regression on that you'll

962
00:47:15,750 --> 00:47:17,730
probably get something like a r-squared

963
00:47:17,730 --> 00:47:22,140
of 0.99 or so and you also can sort of

964
00:47:22,140 --> 00:47:26,400
see that there is some coupling vertical

965
00:47:26,400 --> 00:47:27,960
coupling if you look at where these

966
00:47:27,960 --> 00:47:32,670
placement isn't to that

967
00:47:32,670 --> 00:47:36,089
we will then use for to strengthen our

968
00:47:36,089 --> 00:47:37,799
prediction model so it is a prediction

969
00:47:37,799 --> 00:47:40,890
that will look like and basically if you

970
00:47:40,890 --> 00:47:42,960
look at literature most of literature

971
00:47:42,960 --> 00:47:45,809
will say well that processors are

972
00:47:45,809 --> 00:47:49,500
plausible processes but we have massive

973
00:47:49,500 --> 00:47:53,400
over dispersion in the Linux kernel due

974
00:47:53,400 --> 00:47:55,559
to a lot of the bug findings being from

975
00:47:55,559 --> 00:47:57,990
review and analysis and independence not

976
00:47:57,990 --> 00:48:00,569
be really being there because you find

977
00:48:00,569 --> 00:48:02,430
one bug and then you find three others

978
00:48:02,430 --> 00:48:05,279
that are related and fix them in one in

979
00:48:05,279 --> 00:48:09,349
a set of bug fixes so these stable fixes

980
00:48:09,349 --> 00:48:11,970
violate some of our basic assumptions

981
00:48:11,970 --> 00:48:14,309
where we can handle them by adjusting

982
00:48:14,309 --> 00:48:15,809
for over dispersion by moving to

983
00:48:15,809 --> 00:48:18,990
negative binomial model can see some

984
00:48:18,990 --> 00:48:21,269
other effects here like the last few

985
00:48:21,269 --> 00:48:23,279
data points that are still out there

986
00:48:23,279 --> 00:48:25,500
sort of go really down to almost zero

987
00:48:25,500 --> 00:48:28,200
because that's from Linux Carmen Berlin

988
00:48:28,200 --> 00:48:32,250
to early 2017 where everybody was on

989
00:48:32,250 --> 00:48:35,730
holiday so no bugs fixed the next data

990
00:48:35,730 --> 00:48:38,519
point was in 140 I didn't put that on

991
00:48:38,519 --> 00:48:41,190
the slide but it's still fit into my 95%

992
00:48:41,190 --> 00:48:43,710
confidence interval so I'm happy so

993
00:48:43,710 --> 00:48:45,359
that's basically what we're doing we're

994
00:48:45,359 --> 00:48:48,720
trying to predict predict stability of

995
00:48:48,720 --> 00:48:50,910
the system and we do this over many

996
00:48:50,910 --> 00:48:53,039
collaborations and we can actually see

997
00:48:53,039 --> 00:48:54,750
significant difference how are these

998
00:48:54,750 --> 00:48:57,299
kernel versions coupled this is a stable

999
00:48:57,299 --> 00:49:01,250
buck fix count over color versions that

1000
00:49:01,250 --> 00:49:04,410
line going through the 4.4 kernel on top

1001
00:49:04,410 --> 00:49:06,269
we put four five six seven eight in the

1002
00:49:06,269 --> 00:49:08,160
beginning of 49 which is also a

1003
00:49:08,160 --> 00:49:10,650
long-term stable I think that coupling

1004
00:49:10,650 --> 00:49:13,319
here is quite obviously visible doesn't

1005
00:49:13,319 --> 00:49:15,630
mean it's the same box but it's very

1006
00:49:15,630 --> 00:49:17,750
probable that this is primarily

1007
00:49:17,750 --> 00:49:20,279
backwards or parts that affect all

1008
00:49:20,279 --> 00:49:22,619
kernels so we have this strong coupling

1009
00:49:22,619 --> 00:49:24,900
of the process and this allows us to

1010
00:49:24,900 --> 00:49:27,900
then extract properties over kernel

1011
00:49:27,900 --> 00:49:31,559
versions and this one it looks like if

1012
00:49:31,559 --> 00:49:34,019
you look at the slope which is the most

1013
00:49:34,019 --> 00:49:35,640
interesting you can see that turns from

1014
00:49:35,640 --> 00:49:37,500
positive it systematically turns to

1015
00:49:37,500 --> 00:49:40,200
negative the third of nine value is of

1016
00:49:40,200 --> 00:49:42,390
course not sound because it's based on

1017
00:49:42,390 --> 00:49:45,059
five degrees of freedom or six data

1018
00:49:45,059 --> 00:49:46,410
points that's of course

1019
00:49:46,410 --> 00:49:49,020
not something that you can use for any

1020
00:49:49,020 --> 00:49:50,789
prediction but the others are quite

1021
00:49:50,789 --> 00:49:53,369
sound and confidence intervals on the

1022
00:49:53,369 --> 00:49:55,680
power meters look really good so we can

1023
00:49:55,680 --> 00:49:58,589
say that the world's Colonel development

1024
00:49:58,589 --> 00:50:01,079
process is systematically improving over

1025
00:50:01,079 --> 00:50:03,630
time and that is a critical statement

1026
00:50:03,630 --> 00:50:10,079
for a safety related system okay I can

1027
00:50:10,079 --> 00:50:11,490
do it in four five minute Tamar Tamar

1028
00:50:11,490 --> 00:50:12,930
slide okay

1029
00:50:12,930 --> 00:50:15,930
yeah same thing for subsystems note that

1030
00:50:15,930 --> 00:50:17,849
the confidence interval in subsistent of

1031
00:50:17,849 --> 00:50:19,500
course becomes much larger because we

1032
00:50:19,500 --> 00:50:21,690
don't have so much data points but we

1033
00:50:21,690 --> 00:50:23,760
can look at individual subsystems and

1034
00:50:23,760 --> 00:50:26,069
predict roughly two years in the future

1035
00:50:26,069 --> 00:50:28,710
what the buck trends would be and how

1036
00:50:28,710 --> 00:50:30,990
many residual bugs we have in this

1037
00:50:30,990 --> 00:50:33,839
system I show you in the night one it

1038
00:50:33,839 --> 00:50:34,920
will show you for our system you

1039
00:50:34,920 --> 00:50:38,069
wouldn't think that's so nice so what do

1040
00:50:38,069 --> 00:50:40,619
we do with this power subsystem data we

1041
00:50:40,619 --> 00:50:42,780
then actually look at how much of these

1042
00:50:42,780 --> 00:50:45,180
subsystems are we using in our specific

1043
00:50:45,180 --> 00:50:47,400
configuration for drivers you can see

1044
00:50:47,400 --> 00:50:50,250
it's around 1.5 percent only for our

1045
00:50:50,250 --> 00:50:54,630
kits 3.75 or so for other subsystems

1046
00:50:54,630 --> 00:50:56,880
like colonel itself it's really a large

1047
00:50:56,880 --> 00:50:59,970
portion like sixty percent and so we now

1048
00:50:59,970 --> 00:51:02,160
can take these predictions over the

1049
00:51:02,160 --> 00:51:05,819
entire colonel take our stratification

1050
00:51:05,819 --> 00:51:08,430
by what we're actually using an extract

1051
00:51:08,430 --> 00:51:12,440
our total residual bug rate or expected

1052
00:51:12,440 --> 00:51:15,990
cumulative residual bugs in our kernel

1053
00:51:15,990 --> 00:51:17,760
configuration which currently is around

1054
00:51:17,760 --> 00:51:21,390
23 plus minus 6 not bad actually

1055
00:51:21,390 --> 00:51:24,740
ok conclusions yeah

1056
00:51:24,740 --> 00:51:26,940
basically all the components that we

1057
00:51:26,940 --> 00:51:29,069
need are there and we think that the

1058
00:51:29,069 --> 00:51:32,010
code quality based on basic statistics

1059
00:51:32,010 --> 00:51:35,549
approach is suitable for safety

1060
00:51:35,549 --> 00:51:37,230
integrity up to safety integrity level

1061
00:51:37,230 --> 00:51:39,809
to don't try it we'll deal with this

1062
00:51:39,809 --> 00:51:43,470
please no cell 3 nor so for that's just

1063
00:51:43,470 --> 00:51:49,529
not reasonable the the processes that we

1064
00:51:49,529 --> 00:51:51,420
need to automate this are still being

1065
00:51:51,420 --> 00:51:53,930
worked on but it can be automated and

1066
00:51:53,930 --> 00:51:57,930
yeah from what we have seen up to now

1067
00:51:57,930 --> 00:52:00,210
and show it also to our certification or

1068
00:52:00,210 --> 00:52:02,550
which is to file and we are quite

1069
00:52:02,550 --> 00:52:06,109
convinced that we actually can qualify

1070
00:52:06,109 --> 00:52:09,950
constraint somewhat limited subset of

1071
00:52:09,950 --> 00:52:14,339
Linux to safety integrity level to don't

1072
00:52:14,339 --> 00:52:17,609
try and use a full-featured all-singing

1073
00:52:17,609 --> 00:52:20,400
all-dancing linux for safety please okay

1074
00:52:20,400 --> 00:52:21,089
that's it

1075
00:52:21,089 --> 00:52:33,990
thank you strategy talk too long then

1076
00:52:33,990 --> 00:52:35,369
there's no time for embarrassing

1077
00:52:35,369 --> 00:52:37,920
questions but I'm around if there are

1078
00:52:37,920 --> 00:52:42,140
questions please do come and ask I guess

