1
00:00:09,030 --> 00:00:14,529
can I just go so hi<font color="#CCCCCC"> everyone my name is</font>

2
00:00:12,699 --> 00:00:17,529
<font color="#CCCCCC">Bert I'm a software engineer working</font><font color="#E5E5E5"> for</font>

3
00:00:14,529 --> 00:00:19,509
<font color="#CCCCCC">Silla DB</font><font color="#E5E5E5"> I'll be talking about what</font>

4
00:00:17,529 --> 00:00:21,310
<font color="#CCCCCC">we're doing</font><font color="#E5E5E5"> to introduce stronger</font>

5
00:00:19,510 --> 00:00:26,320
constancy<font color="#E5E5E5"> guarantees into the database</font>

6
00:00:21,310 --> 00:00:28,538
by implementing raft so before we go

7
00:00:26,320 --> 00:00:34,899
into<font color="#E5E5E5"> raft</font><font color="#CCCCCC"> how many of you are familiar</font>

8
00:00:28,539 --> 00:00:36,520
<font color="#E5E5E5">with Scylla DB</font><font color="#CCCCCC"> alright</font><font color="#E5E5E5"> so not</font><font color="#CCCCCC"> that many</font>

9
00:00:34,899 --> 00:00:39,309
<font color="#E5E5E5">so</font><font color="#CCCCCC"> I'll start by</font><font color="#E5E5E5"> going over a brief</font>

10
00:00:36,520 --> 00:00:41,589
<font color="#E5E5E5">introduction Scylla is no sequel</font>

11
00:00:39,309 --> 00:00:43,510
database<font color="#E5E5E5"> compatible with</font><font color="#CCCCCC"> Patrick</font>

12
00:00:41,589 --> 00:00:47,350
<font color="#E5E5E5">Cassandra and we implement the same</font>

13
00:00:43,510 --> 00:00:50,858
api's and we use the same file formats

14
00:00:47,350 --> 00:00:53,409
<font color="#E5E5E5">we are</font><font color="#CCCCCC"> however much faster we have ten</font>

15
00:00:50,859 --> 00:00:55,089
<font color="#E5E5E5">times and the throughput at much lower</font>

16
00:00:53,409 --> 00:00:58,299
latencies<font color="#E5E5E5"> especially the higher</font>

17
00:00:55,089 --> 00:01:00,819
percentiles<font color="#CCCCCC"> and</font><font color="#E5E5E5"> the database is</font><font color="#CCCCCC"> also</font>

18
00:00:58,299 --> 00:01:03,280
<font color="#E5E5E5">self tuning we employ a lot</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> control</font>

19
00:01:00,819 --> 00:01:05,440
<font color="#CCCCCC">theory and to make sure we can schedule</font>

20
00:01:03,280 --> 00:01:07,120
<font color="#E5E5E5">all</font><font color="#CCCCCC"> the different user workloads in</font><font color="#E5E5E5"> it</font>

21
00:01:05,440 --> 00:01:10,500
that we can balance them<font color="#E5E5E5"> with the</font>

22
00:01:07,120 --> 00:01:13,420
internal processes<font color="#E5E5E5"> that the database has</font>

23
00:01:10,500 --> 00:01:16,329
we use of direct<font color="#E5E5E5"> and bypass the page</font>

24
00:01:13,420 --> 00:01:20,439
cache that<font color="#E5E5E5"> we do have seen correctly and</font>

25
00:01:16,329 --> 00:01:22,298
the<font color="#CCCCCC"> database is</font><font color="#E5E5E5"> written in C++</font><font color="#CCCCCC"> with a</font>

26
00:01:20,439 --> 00:01:24,398
lot of<font color="#E5E5E5"> attention</font><font color="#CCCCCC"> paid to the underlying</font>

27
00:01:22,299 --> 00:01:28,630
<font color="#E5E5E5">hardware which we want to feel fully</font>

28
00:01:24,399 --> 00:01:32,710
<font color="#CCCCCC">utilized so we are at Dynamo system</font><font color="#E5E5E5"> so</font>

29
00:01:28,630 --> 00:01:34,240
there is no special<font color="#E5E5E5"> nodes and data a</font>

30
00:01:32,710 --> 00:01:37,538
particular piece<font color="#CCCCCC"> of data is replicated</font>

31
00:01:34,240 --> 00:01:40,060
across<font color="#E5E5E5"> a set of replicas and the full</font>

32
00:01:37,539 --> 00:01:44,710
<font color="#E5E5E5">data set is partitioned across the whole</font>

33
00:01:40,060 --> 00:01:47,049
<font color="#E5E5E5">cluster</font><font color="#CCCCCC"> when a user performs the read or</font>

34
00:01:44,710 --> 00:01:49,780
<font color="#CCCCCC">write</font><font color="#E5E5E5"> he can specify the consistency</font>

35
00:01:47,049 --> 00:01:51,579
level which is how<font color="#CCCCCC"> many replicas should</font>

36
00:01:49,780 --> 00:01:55,140
acknowledge the operation<font color="#CCCCCC"> before it is</font>

37
00:01:51,579 --> 00:01:59,048
considered successful<font color="#E5E5E5"> to the client</font><font color="#CCCCCC"> the</font>

38
00:01:55,140 --> 00:02:03,700
<font color="#CCCCCC">data model is based on tables the tables</font>

39
00:01:59,049 --> 00:02:05,649
can have many columns<font color="#CCCCCC"> there's a</font><font color="#E5E5E5"> primary</font>

40
00:02:03,700 --> 00:02:09,069
key with two components<font color="#CCCCCC"> the</font><font color="#E5E5E5"> partition</font>

41
00:02:05,649 --> 00:02:11,290
key our set of columns<font color="#E5E5E5"> that specify how</font>

42
00:02:09,068 --> 00:02:13,209
<font color="#CCCCCC">the data</font><font color="#E5E5E5"> is distributed across the</font>

43
00:02:11,290 --> 00:02:16,209
cluster<font color="#E5E5E5"> so they determine which</font><font color="#CCCCCC"> nodes</font>

44
00:02:13,210 --> 00:02:18,140
<font color="#E5E5E5">get to handle which pieces of data and</font>

45
00:02:16,210 --> 00:02:20,030
<font color="#E5E5E5">then there is a clustering key</font>

46
00:02:18,140 --> 00:02:24,559
which defines the<font color="#CCCCCC"> order in which data</font><font color="#E5E5E5"> is</font>

47
00:02:20,030 --> 00:02:26,959
sorted<font color="#CCCCCC"> and stored on</font><font color="#E5E5E5"> disk in terms of</font>

48
00:02:24,560 --> 00:02:29,180
<font color="#E5E5E5">consistency when we are performing</font><font color="#CCCCCC"> a</font>

49
00:02:26,959 --> 00:02:30,950
<font color="#CCCCCC">write and the coordinator knows that</font>

50
00:02:29,180 --> 00:02:32,569
handles the user<font color="#CCCCCC"> requests is going to</font>

51
00:02:30,950 --> 00:02:36,679
replicate<font color="#CCCCCC"> that right to all of the</font>

52
00:02:32,569 --> 00:02:39,049
replicas we can as I said specify the

53
00:02:36,680 --> 00:02:41,000
consistent level so if we say we want a

54
00:02:39,050 --> 00:02:42,620
quorum a majority of replicas<font color="#CCCCCC"> to</font>

55
00:02:41,000 --> 00:02:44,540
acknowledge the<font color="#E5E5E5"> right for it to be</font>

56
00:02:42,620 --> 00:02:47,390
<font color="#E5E5E5">considered successful then</font><font color="#CCCCCC"> we can</font>

57
00:02:44,540 --> 00:02:51,709
tolerate one failure when<font color="#CCCCCC"> replicas not</font>

58
00:02:47,390 --> 00:02:57,079
<font color="#E5E5E5">receiving the right if we then do a</font>

59
00:02:51,709 --> 00:02:58,850
quorum<font color="#CCCCCC"> width and</font><font color="#E5E5E5"> let's say that we only</font>

60
00:02:57,080 --> 00:03:01,820
read<font color="#CCCCCC"> from one of the replicas that had</font>

61
00:02:58,850 --> 00:03:03,500
<font color="#E5E5E5">the data that we wrote previously then</font>

62
00:03:01,820 --> 00:03:05,450
we are going<font color="#E5E5E5"> to consider the operation</font>

63
00:03:03,500 --> 00:03:07,700
successfully and<font color="#CCCCCC"> successfully</font><font color="#E5E5E5"> and we</font><font color="#CCCCCC"> are</font>

64
00:03:05,450 --> 00:03:09,589
going to<font color="#E5E5E5"> return</font><font color="#CCCCCC"> that piece of data</font><font color="#E5E5E5"> this</font>

65
00:03:07,700 --> 00:03:11,780
provides<font color="#E5E5E5"> us with</font><font color="#CCCCCC"> some</font><font color="#E5E5E5"> consistency</font>

66
00:03:09,590 --> 00:03:18,110
<font color="#CCCCCC">guarantees</font><font color="#E5E5E5"> namely with your own wives</font>

67
00:03:11,780 --> 00:03:21,470
<font color="#CCCCCC">and monotonic</font><font color="#E5E5E5"> waves and during this this</font>

68
00:03:18,110 --> 00:03:23,209
<font color="#CCCCCC">width</font><font color="#E5E5E5"> we are going to notice</font><font color="#CCCCCC"> that a</font>

69
00:03:21,470 --> 00:03:24,799
replica was missing that particular

70
00:03:23,209 --> 00:03:28,310
piece of<font color="#E5E5E5"> data and we are going to</font>

71
00:03:24,799 --> 00:03:30,829
propagate it there we also do this in

72
00:03:28,310 --> 00:03:32,870
<font color="#E5E5E5">the absence</font><font color="#CCCCCC"> of reads</font><font color="#E5E5E5"> and by having a</font>

73
00:03:30,829 --> 00:03:34,910
background<font color="#E5E5E5"> anti entropy process called</font>

74
00:03:32,870 --> 00:03:37,489
repair which<font color="#E5E5E5"> periodically ensures that</font>

75
00:03:34,910 --> 00:03:43,549
all<font color="#E5E5E5"> the replicas converge on the same on</font>

76
00:03:37,489 --> 00:03:46,370
the same<font color="#E5E5E5"> values there is a peculiarities</font>

77
00:03:43,549 --> 00:03:49,430
<font color="#E5E5E5">which is</font><font color="#CCCCCC"> when let's</font><font color="#E5E5E5"> say</font><font color="#CCCCCC"> we were doing</font><font color="#E5E5E5"> a</font>

78
00:03:46,370 --> 00:03:51,110
quorum right and two replicas fail<font color="#E5E5E5"> so</font>

79
00:03:49,430 --> 00:03:54,310
only one replica acknowledges the right

80
00:03:51,110 --> 00:03:57,410
in<font color="#E5E5E5"> this case the user receives an error</font>

81
00:03:54,310 --> 00:04:00,980
<font color="#E5E5E5">but one of the replicas did start a new</font>

82
00:03:57,410 --> 00:04:02,630
value<font color="#E5E5E5"> so repair will in time propagate</font>

83
00:04:00,980 --> 00:04:06,320
that value over<font color="#CCCCCC"> to all</font><font color="#E5E5E5"> the other</font>

84
00:04:02,630 --> 00:04:08,480
replicas in the system so the user<font color="#CCCCCC"> write</font>

85
00:04:06,320 --> 00:04:10,310
failed<font color="#CCCCCC"> but the value made into the</font>

86
00:04:08,480 --> 00:04:14,720
<font color="#CCCCCC">system and is going to</font><font color="#E5E5E5"> be observable by</font>

87
00:04:10,310 --> 00:04:16,488
<font color="#E5E5E5">future reads another part of the</font>

88
00:04:14,720 --> 00:04:19,039
consistency model is how we deal with

89
00:04:16,488 --> 00:04:21,168
concurrent updates<font color="#CCCCCC"> so if you're</font><font color="#E5E5E5"> trying</font>

90
00:04:19,039 --> 00:04:25,030
to<font color="#CCCCCC"> update the same key and the same</font>

91
00:04:21,168 --> 00:04:28,810
column<font color="#E5E5E5"> two different</font><font color="#CCCCCC"> values how do we</font>

92
00:04:25,030 --> 00:04:31,520
how do we specify which one wins<font color="#CCCCCC"> and</font>

93
00:04:28,810 --> 00:04:32,630
more importantly how do we<font color="#E5E5E5"> make them</font>

94
00:04:31,520 --> 00:04:34,700
become

95
00:04:32,630 --> 00:04:37,520
so that all replicas eventually choose

96
00:04:34,700 --> 00:04:39,500
the same values and the technique we

97
00:04:37,520 --> 00:04:41,719
employ is the same as<font color="#CCCCCC"> Cassandra's so</font>

98
00:04:39,500 --> 00:04:43,520
<font color="#CCCCCC">less white wins</font><font color="#E5E5E5"> we look at the</font><font color="#CCCCCC"> timestamp</font>

99
00:04:41,720 --> 00:04:46,070
<font color="#CCCCCC">and we pick</font><font color="#E5E5E5"> the value</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> has the</font>

100
00:04:43,520 --> 00:04:47,780
highest time stamp<font color="#E5E5E5"> if the</font><font color="#CCCCCC"> time stamps</font>

101
00:04:46,070 --> 00:04:50,419
match then we pick what<font color="#E5E5E5"> which</font><font color="#CCCCCC"> R</font><font color="#E5E5E5"> is the</font>

102
00:04:47,780 --> 00:04:53,090
highest value<font color="#CCCCCC"> according to</font><font color="#E5E5E5"> the</font>

103
00:04:50,419 --> 00:04:55,430
<font color="#E5E5E5">underlying data type this is really not</font>

104
00:04:53,090 --> 00:04:58,820
<font color="#E5E5E5">a great solution because time stamps</font>

105
00:04:55,430 --> 00:05:00,919
<font color="#E5E5E5">don't capture intent</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> we are also</font>

106
00:04:58,820 --> 00:05:02,840
<font color="#CCCCCC">silently discarding one</font><font color="#E5E5E5"> of the values</font>

107
00:05:00,919 --> 00:05:05,060
that<font color="#E5E5E5"> the user was trying to write and</font>

108
00:05:02,840 --> 00:05:07,940
the solution<font color="#CCCCCC"> to this right now would be</font>

109
00:05:05,060 --> 00:05:11,540
<font color="#E5E5E5">to make changes to the</font><font color="#CCCCCC"> data model</font><font color="#E5E5E5"> so</font>

110
00:05:07,940 --> 00:05:13,210
model the data<font color="#E5E5E5"> is an appending log</font><font color="#CCCCCC"> may</font>

111
00:05:11,540 --> 00:05:17,889
<font color="#CCCCCC">call rise we</font><font color="#E5E5E5"> hadn't put in and</font>

112
00:05:13,210 --> 00:05:20,060
workarounds like that so another

113
00:05:17,889 --> 00:05:21,530
particularity<font color="#E5E5E5"> of</font><font color="#CCCCCC"> Scylla is that it is</font>

114
00:05:20,060 --> 00:05:23,960
implemented<font color="#E5E5E5"> on top of the sister</font>

115
00:05:21,530 --> 00:05:25,638
framework which<font color="#CCCCCC"> is a C++ framework we</font>

116
00:05:23,960 --> 00:05:29,239
wrote ourselves but it's used by a bunch

117
00:05:25,639 --> 00:05:31,370
of other<font color="#E5E5E5"> projects and</font><font color="#CCCCCC"> it is used</font><font color="#E5E5E5"> for</font>

118
00:05:29,240 --> 00:05:34,220
<font color="#E5E5E5">high</font><font color="#CCCCCC"> performance applications it imposes</font>

119
00:05:31,370 --> 00:05:38,150
a<font color="#E5E5E5"> thread per core design in which</font>

120
00:05:34,220 --> 00:05:41,270
there's one thread pins<font color="#E5E5E5"> two particular</font>

121
00:05:38,150 --> 00:05:43,520
CPU<font color="#E5E5E5"> and only one and that</font><font color="#CCCCCC"> means</font><font color="#E5E5E5"> that if</font>

122
00:05:41,270 --> 00:05:45,590
you want<font color="#CCCCCC"> to fully utilize your CPU then</font>

123
00:05:43,520 --> 00:05:49,340
there can be no blocking ever<font color="#E5E5E5"> otherwise</font>

124
00:05:45,590 --> 00:05:51,440
the CPU will just go idle because of

125
00:05:49,340 --> 00:05:53,030
that<font color="#CCCCCC"> sistar provides the set of</font>

126
00:05:51,440 --> 00:05:55,250
asynchronous<font color="#E5E5E5"> API is not only for</font>

127
00:05:53,030 --> 00:05:58,010
networking<font color="#E5E5E5"> but also for file i/o and</font>

128
00:05:55,250 --> 00:06:00,080
multi-core communication<font color="#CCCCCC"> since it's our</font>

129
00:05:58,010 --> 00:06:02,180
data is confined<font color="#CCCCCC"> to a particular</font><font color="#E5E5E5"> core</font>

130
00:06:00,080 --> 00:06:04,310
<font color="#E5E5E5">and we know other</font><font color="#CCCCCC"> core ones access to</font>

131
00:06:02,180 --> 00:06:07,580
another one is data it<font color="#E5E5E5"> uses message</font>

132
00:06:04,310 --> 00:06:12,310
passing<font color="#E5E5E5"> to fetch that data and we expose</font>

133
00:06:07,580 --> 00:06:14,719
<font color="#E5E5E5">these api's as in the future promise</font><font color="#CCCCCC"> api</font>

134
00:06:12,310 --> 00:06:17,270
so for<font color="#CCCCCC"> silla this has the consequence</font>

135
00:06:14,720 --> 00:06:20,360
<font color="#E5E5E5">that all of the components of the</font>

136
00:06:17,270 --> 00:06:23,210
request<font color="#E5E5E5"> path are replicated per</font><font color="#CCCCCC"> cpu and</font>

137
00:06:20,360 --> 00:06:25,220
also data is like it is partitioned

138
00:06:23,210 --> 00:06:27,950
<font color="#E5E5E5">across the cluster it is also partition</font>

139
00:06:25,220 --> 00:06:30,470
inside a<font color="#E5E5E5"> node we use the same partition</font>

140
00:06:27,950 --> 00:06:33,020
key to decide which cpus get to handle

141
00:06:30,470 --> 00:06:34,639
<font color="#E5E5E5">which subset of the data we use the</font>

142
00:06:33,020 --> 00:06:37,729
<font color="#E5E5E5">middle bits of the partition key just to</font>

143
00:06:34,639 --> 00:06:39,979
<font color="#E5E5E5">avoid</font><font color="#CCCCCC"> allowing situations when the shard</font>

144
00:06:37,729 --> 00:06:42,940
accounts for node approximates the node

145
00:06:39,979 --> 00:06:42,940
count in the in the cluster

146
00:06:43,400 --> 00:06:50,690
and so the<font color="#E5E5E5"> reason we want to introduce a</font>

147
00:06:48,590 --> 00:06:52,250
stronger consistency model in Silla is

148
00:06:50,690 --> 00:06:55,180
trivially because it just<font color="#CCCCCC"> enables in</font>

149
00:06:52,250 --> 00:06:57,050
<font color="#E5E5E5">more East cases if you want to have</font>

150
00:06:55,180 --> 00:06:58,870
uniqueness constraints if you want to

151
00:06:57,050 --> 00:07:01,130
specify<font color="#E5E5E5"> that</font><font color="#CCCCCC"> a particular email address</font>

152
00:06:58,870 --> 00:07:02,870
exists only<font color="#E5E5E5"> once in a database then it's</font>

153
00:07:01,130 --> 00:07:06,650
<font color="#E5E5E5">really cumbersome to do that with just</font>

154
00:07:02,870 --> 00:07:08,750
quorum<font color="#CCCCCC"> reason quorum</font><font color="#E5E5E5"> rights if you want</font>

155
00:07:06,650 --> 00:07:10,609
to have read modify write<font color="#CCCCCC"> accesses where</font>

156
00:07:08,750 --> 00:07:12,800
you read the<font color="#E5E5E5"> value make some decision</font>

157
00:07:10,610 --> 00:07:15,169
and modify<font color="#CCCCCC"> the value</font><font color="#E5E5E5"> and write it back</font>

158
00:07:12,800 --> 00:07:16,820
<font color="#E5E5E5">you can't really do</font><font color="#CCCCCC"> that safely</font><font color="#E5E5E5"> in the</font>

159
00:07:15,169 --> 00:07:20,210
presence of concurrent updates<font color="#E5E5E5"> with the</font>

160
00:07:16,820 --> 00:07:22,520
mechanisms we have<font color="#E5E5E5"> right now similarly</font>

161
00:07:20,210 --> 00:07:25,460
if<font color="#CCCCCC"> you want an update to be all or</font>

162
00:07:22,520 --> 00:07:27,799
<font color="#CCCCCC">nothing so if you want all the value to</font>

163
00:07:25,460 --> 00:07:30,530
be<font color="#CCCCCC"> written on all the wrap replicas or</font>

164
00:07:27,800 --> 00:07:32,930
<font color="#CCCCCC">at none</font><font color="#E5E5E5"> of them instead</font><font color="#CCCCCC"> of those partial</font>

165
00:07:30,530 --> 00:07:36,559
<font color="#E5E5E5">rights that we saw and we have no</font>

166
00:07:32,930 --> 00:07:41,240
<font color="#CCCCCC">mechanism to</font><font color="#E5E5E5"> prevent that when I was</font>

167
00:07:36,560 --> 00:07:44,810
more of<font color="#E5E5E5"> course we went and this stronger</font>

168
00:07:41,240 --> 00:07:46,550
<font color="#E5E5E5">consisting operations to be</font><font color="#CCCCCC"> opted</font><font color="#E5E5E5"> in and</font>

169
00:07:44,810 --> 00:07:50,330
<font color="#CCCCCC">we don't mind you</font><font color="#E5E5E5"> have</font><font color="#CCCCCC"> to pay for</font>

170
00:07:46,550 --> 00:07:53,139
fraudulent<font color="#CCCCCC"> views so</font><font color="#E5E5E5"> Cassandra exposes</font>

171
00:07:50,330 --> 00:07:56,719
this feature as lightweight transactions

172
00:07:53,139 --> 00:08:00,889
which provides<font color="#CCCCCC"> from consistency</font><font color="#E5E5E5"> per</font>

173
00:07:56,720 --> 00:08:02,960
partition so perky<font color="#CCCCCC"> it is essentially a</font>

174
00:08:00,889 --> 00:08:05,330
distributed compare and swap<font color="#E5E5E5"> so we</font>

175
00:08:02,960 --> 00:08:07,969
specify the new value and<font color="#CCCCCC"> we specify</font>

176
00:08:05,330 --> 00:08:12,260
what has to<font color="#E5E5E5"> be there for the new right</font>

177
00:08:07,970 --> 00:08:15,530
<font color="#E5E5E5">to apply it's not really</font><font color="#CCCCCC"> a fool</font>

178
00:08:12,260 --> 00:08:17,180
transactional API<font color="#E5E5E5"> and so you end up</font>

179
00:08:15,530 --> 00:08:20,448
<font color="#E5E5E5">having</font><font color="#CCCCCC"> to write your programs like you'd</font>

180
00:08:17,180 --> 00:08:22,400
write<font color="#CCCCCC"> lock free algorithms</font><font color="#E5E5E5"> so you make</font>

181
00:08:20,449 --> 00:08:24,080
some modifications to<font color="#E5E5E5"> some table and</font>

182
00:08:22,400 --> 00:08:29,150
then at the end you try to update<font color="#E5E5E5"> a</font>

183
00:08:24,080 --> 00:08:31,039
pointer to the new data<font color="#E5E5E5"> and by bike or</font>

184
00:08:29,150 --> 00:08:33,679
by<font color="#CCCCCC"> having clients</font><font color="#E5E5E5"> coordinates on this</font>

185
00:08:31,039 --> 00:08:37,549
pointer then you get the storm<font color="#CCCCCC"> forces</font>

186
00:08:33,679 --> 00:08:38,809
<font color="#CCCCCC">properties it is a data path</font><font color="#E5E5E5"> operation</font>

187
00:08:37,549 --> 00:08:41,799
<font color="#CCCCCC">so we want to make it as high</font>

188
00:08:38,809 --> 00:08:45,020
<font color="#CCCCCC">performance and as available as possible</font>

189
00:08:41,799 --> 00:08:46,880
and finally<font color="#CCCCCC"> because of</font><font color="#E5E5E5"> the the way the</font>

190
00:08:45,020 --> 00:08:48,860
<font color="#CCCCCC">feature</font><font color="#E5E5E5"> works</font><font color="#CCCCCC"> it does require an</font>

191
00:08:46,880 --> 00:08:51,200
internal read<font color="#CCCCCC"> before right so we fetch</font>

192
00:08:48,860 --> 00:08:53,240
the<font color="#CCCCCC"> current value and are able to match</font>

193
00:08:51,200 --> 00:08:55,390
<font color="#CCCCCC">it against the preconditions that the</font>

194
00:08:53,240 --> 00:08:58,730
user is specifying

195
00:08:55,390 --> 00:09:02,300
so to implement<font color="#E5E5E5"> strong consistency</font>

196
00:08:58,730 --> 00:09:06,440
<font color="#CCCCCC">typically we resort to consensus</font>

197
00:09:02,300 --> 00:09:08,750
algorithms<font color="#CCCCCC"> consensus is the the process</font>

198
00:09:06,440 --> 00:09:13,640
<font color="#E5E5E5">by which set of replicas which agreement</font>

199
00:09:08,750 --> 00:09:15,980
<font color="#CCCCCC">over a particular value they provide a</font>

200
00:09:13,640 --> 00:09:18,500
<font color="#CCCCCC">constant sparticles</font><font color="#E5E5E5"> provide consistency</font>

201
00:09:15,980 --> 00:09:21,170
guarantees about<font color="#E5E5E5"> and dinner</font><font color="#CCCCCC"> line data</font>

202
00:09:18,500 --> 00:09:22,670
and<font color="#CCCCCC"> they are leveraged to implement</font>

203
00:09:21,170 --> 00:09:25,760
what's called replicated state machines

204
00:09:22,670 --> 00:09:28,160
<font color="#E5E5E5">where a set of replicas apply the same</font>

205
00:09:25,760 --> 00:09:32,140
operations<font color="#E5E5E5"> and in the same order and</font>

206
00:09:28,160 --> 00:09:36,110
work together as a single<font color="#E5E5E5"> coherent unit</font>

207
00:09:32,140 --> 00:09:38,240
we can tolerate some<font color="#CCCCCC"> non bison fan</font>

208
00:09:36,110 --> 00:09:42,560
<font color="#CCCCCC">failure so for two two times</font><font color="#E5E5E5"> F plus</font>

209
00:09:38,240 --> 00:09:44,420
<font color="#CCCCCC">Munoz we tolerate</font><font color="#E5E5E5"> F failures and a run</font>

210
00:09:42,560 --> 00:09:46,489
<font color="#E5E5E5">of the consensus algorithm is typically</font>

211
00:09:44,420 --> 00:09:49,250
called<font color="#CCCCCC"> around</font><font color="#E5E5E5"> and it advances</font><font color="#CCCCCC"> the</font>

212
00:09:46,490 --> 00:09:51,190
underlying<font color="#CCCCCC"> states there are</font><font color="#E5E5E5"> set of</font>

213
00:09:49,250 --> 00:09:55,430
guarantees<font color="#CCCCCC"> that</font><font color="#E5E5E5"> make these</font><font color="#CCCCCC"> protocols</font>

214
00:09:51,190 --> 00:09:57,170
<font color="#E5E5E5">worthwhile so that of stability</font><font color="#CCCCCC"> if a</font>

215
00:09:55,430 --> 00:09:59,900
replica<font color="#E5E5E5"> ever decides a value then that</font>

216
00:09:57,170 --> 00:10:01,430
value<font color="#E5E5E5"> stays decided forever agreement</font>

217
00:09:59,900 --> 00:10:05,480
<font color="#E5E5E5">that no two replicas should be side a</font>

218
00:10:01,430 --> 00:10:08,239
value to different values<font color="#E5E5E5"> and</font><font color="#CCCCCC"> validity</font>

219
00:10:05,480 --> 00:10:10,430
that<font color="#E5E5E5"> if we decide on a value then it's</font>

220
00:10:08,240 --> 00:10:12,050
because a replica did propose that value

221
00:10:10,430 --> 00:10:15,229
didn't come<font color="#CCCCCC"> up out of</font><font color="#E5E5E5"> thin air</font>

222
00:10:12,050 --> 00:10:17,300
<font color="#E5E5E5">and also very importantly that of</font>

223
00:10:15,230 --> 00:10:21,170
termination<font color="#CCCCCC"> that eventually</font><font color="#E5E5E5"> all replicas</font>

224
00:10:17,300 --> 00:10:23,180
do reach a decision so how do we go

225
00:10:21,170 --> 00:10:25,550
about<font color="#E5E5E5"> choosing an algorithm and there</font>

226
00:10:23,180 --> 00:10:28,000
are two very popular ones taxes and and

227
00:10:25,550 --> 00:10:33,050
<font color="#CCCCCC">ref nowadays</font><font color="#E5E5E5"> but there are other there</font>

228
00:10:28,000 --> 00:10:35,180
<font color="#CCCCCC">are other ones so first of all we want</font>

229
00:10:33,050 --> 00:10:37,670
<font color="#E5E5E5">to look at an algorithm</font><font color="#CCCCCC"> that's</font>

230
00:10:35,180 --> 00:10:39,439
understandable<font color="#CCCCCC"> so there was a very</font>

231
00:10:37,670 --> 00:10:41,540
<font color="#E5E5E5">famous paper that came out of Google and</font>

232
00:10:39,440 --> 00:10:45,080
detailing their experiences implementing

233
00:10:41,540 --> 00:10:46,969
taxes for chubby<font color="#E5E5E5"> and basically the gist</font>

234
00:10:45,080 --> 00:10:49,790
of it was<font color="#E5E5E5"> that bestest was a very under</font>

235
00:10:46,970 --> 00:10:51,740
<font color="#CCCCCC">specifies algorithm and that</font><font color="#E5E5E5"> they had to</font>

236
00:10:49,790 --> 00:10:56,029
search all of<font color="#E5E5E5"> the</font><font color="#CCCCCC"> literature to come up</font>

237
00:10:51,740 --> 00:10:57,830
with<font color="#E5E5E5"> Frankenstein of</font><font color="#CCCCCC"> a solution so we</font>

238
00:10:56,029 --> 00:10:59,450
also want the algorithm not to be<font color="#E5E5E5"> too</font>

239
00:10:57,830 --> 00:11:01,459
<font color="#CCCCCC">cutting-edge when there are to</font><font color="#E5E5E5"> be some</font>

240
00:10:59,450 --> 00:11:04,910
<font color="#CCCCCC">real-world usage of it and some</font>

241
00:11:01,459 --> 00:11:07,260
<font color="#CCCCCC">experience and</font><font color="#E5E5E5"> and validity another</font>

242
00:11:04,910 --> 00:11:10,439
thing to<font color="#E5E5E5"> look at is how many</font>

243
00:11:07,260 --> 00:11:12,090
<font color="#CCCCCC">what's the overhead of having all those</font>

244
00:11:10,440 --> 00:11:14,070
replicas<font color="#CCCCCC"> coordinated to decide on a</font>

245
00:11:12,090 --> 00:11:19,040
value and that's<font color="#CCCCCC"> usually in</font><font color="#E5E5E5"> terms of</font>

246
00:11:14,070 --> 00:11:21,510
round trips<font color="#E5E5E5"> for for women to be reached</font>

247
00:11:19,040 --> 00:11:24,390
another thing is general performance<font color="#CCCCCC"> how</font>

248
00:11:21,510 --> 00:11:29,880
amenable is an algorithm<font color="#CCCCCC"> to typical</font>

249
00:11:24,390 --> 00:11:32,730
<font color="#CCCCCC">optimization</font><font color="#E5E5E5"> techniques and an important</font>

250
00:11:29,880 --> 00:11:35,610
trade-off is whether there is<font color="#CCCCCC"> a strong</font>

251
00:11:32,730 --> 00:11:38,940
leader<font color="#CCCCCC"> or whether</font><font color="#E5E5E5"> any replica can decide</font>

252
00:11:35,610 --> 00:11:40,470
a value so if the letter and then we

253
00:11:38,940 --> 00:11:43,170
<font color="#E5E5E5">require at least two</font><font color="#CCCCCC"> round trips to</font>

254
00:11:40,470 --> 00:11:46,440
design<font color="#CCCCCC"> a</font><font color="#E5E5E5"> value this is classical</font><font color="#CCCCCC"> paksas</font>

255
00:11:43,170 --> 00:11:47,880
or<font color="#CCCCCC"> the new algorithm gasp X's cassandra</font>

256
00:11:46,440 --> 00:11:51,810
does something<font color="#E5E5E5"> similar but they require</font>

257
00:11:47,880 --> 00:11:54,150
<font color="#CCCCCC">four round trips the other</font><font color="#E5E5E5"> approach is</font>

258
00:11:51,810 --> 00:11:55,770
<font color="#CCCCCC">to have strong</font><font color="#E5E5E5"> wheel so we</font><font color="#CCCCCC"> go through a</font>

259
00:11:54,150 --> 00:11:57,840
<font color="#CCCCCC">process called winter elections like one</font>

260
00:11:55,770 --> 00:12:00,360
of the replicas and<font color="#E5E5E5"> to be in charge and</font>

261
00:11:57,840 --> 00:12:01,770
then we can commit values with one<font color="#E5E5E5"> round</font>

262
00:12:00,360 --> 00:12:04,290
<font color="#CCCCCC">trip communication between the leader</font>

263
00:12:01,770 --> 00:12:08,510
and<font color="#E5E5E5"> and the followers this is what</font>

264
00:12:04,290 --> 00:12:08,510
<font color="#CCCCCC">multipacks says wrapped inside</font><font color="#E5E5E5"> of all do</font>

265
00:12:09,140 --> 00:12:12,900
aside from<font color="#E5E5E5"> disturbance of challenges</font>

266
00:12:11,490 --> 00:12:15,090
information is algorithms so they

267
00:12:12,900 --> 00:12:18,180
typically<font color="#E5E5E5"> rely on on a right ahead log</font>

268
00:12:15,090 --> 00:12:21,450
to order operations which takes space

269
00:12:18,180 --> 00:12:24,719
<font color="#E5E5E5">and we need to find ways</font><font color="#CCCCCC"> to compact</font><font color="#E5E5E5"> that</font>

270
00:12:21,450 --> 00:12:26,730
<font color="#CCCCCC">well</font><font color="#E5E5E5"> also read only</font><font color="#CCCCCC"> requests typically</font>

271
00:12:24,720 --> 00:12:29,220
require<font color="#E5E5E5"> a full run of the consensus</font>

272
00:12:26,730 --> 00:12:30,390
algorithm<font color="#E5E5E5"> but we just want to read the</font>

273
00:12:29,220 --> 00:12:31,380
<font color="#E5E5E5">latest value we shouldn't have to go</font>

274
00:12:30,390 --> 00:12:32,760
through<font color="#CCCCCC"> that so there are a bunch</font><font color="#E5E5E5"> of</font>

275
00:12:31,380 --> 00:12:36,480
optimizations that<font color="#E5E5E5"> apply</font><font color="#CCCCCC"> to some</font>

276
00:12:32,760 --> 00:12:38,220
algorithms dynamic membership having

277
00:12:36,480 --> 00:12:39,920
<font color="#E5E5E5">knows come and go from the cluster is</font>

278
00:12:38,220 --> 00:12:42,390
also a big issue

279
00:12:39,920 --> 00:12:44,520
the other one is<font color="#CCCCCC"> moody</font><font color="#E5E5E5"> key</font><font color="#CCCCCC"> transactions</font>

280
00:12:42,390 --> 00:12:46,080
<font color="#E5E5E5">support can we extend the algorithm or</font>

281
00:12:44,520 --> 00:12:48,680
can we compose the algorithm to<font color="#E5E5E5"> make</font>

282
00:12:46,080 --> 00:12:51,090
sure we can have multi key transactions

283
00:12:48,680 --> 00:12:53,609
another thing to<font color="#E5E5E5"> look at is performance</font>

284
00:12:51,090 --> 00:12:58,310
over<font color="#E5E5E5"> one and finally</font><font color="#CCCCCC"> whether there is</font>

285
00:12:53,610 --> 00:13:00,840
actually some formal proof of<font color="#CCCCCC"> its safety</font>

286
00:12:58,310 --> 00:13:04,589
or whether there's like a<font color="#CCCCCC"> Jepsen blog</font>

287
00:13:00,840 --> 00:13:07,130
<font color="#E5E5E5">post about so not surprising giving that</font>

288
00:13:04,590 --> 00:13:10,380
the title of<font color="#E5E5E5"> the talk which was wrapped</font>

289
00:13:07,130 --> 00:13:13,470
it is focused on understandability<font color="#CCCCCC"> is it</font>

290
00:13:10,380 --> 00:13:14,820
it's very descriptive algorithm it<font color="#E5E5E5"> is</font>

291
00:13:13,470 --> 00:13:16,440
very widely used there a lot of

292
00:13:14,820 --> 00:13:19,240
implementations and it's<font color="#E5E5E5"> running</font><font color="#CCCCCC"> in a</font>

293
00:13:16,440 --> 00:13:23,759
lot of databases

294
00:13:19,240 --> 00:13:27,850
it has<font color="#E5E5E5"> a strong leadership</font><font color="#CCCCCC"> there's a</font>

295
00:13:23,759 --> 00:13:29,649
leader election<font color="#CCCCCC"> and process and</font><font color="#E5E5E5"> for in</font>

296
00:13:27,850 --> 00:13:31,569
the context of<font color="#E5E5E5"> lightweight transactions</font>

297
00:13:29,649 --> 00:13:34,660
<font color="#E5E5E5">it is going to be the leader</font><font color="#CCCCCC"> at best</font>

298
00:13:31,569 --> 00:13:37,559
<font color="#E5E5E5">that read before right and validates</font>

299
00:13:34,660 --> 00:13:40,089
whether a transaction<font color="#E5E5E5"> can apply or not</font>

300
00:13:37,559 --> 00:13:42,699
<font color="#E5E5E5">and for us the fact that there is a log</font>

301
00:13:40,089 --> 00:13:45,149
of operations is no big deal because<font color="#E5E5E5"> we</font>

302
00:13:42,699 --> 00:13:48,248
can easily compact it as we shall see

303
00:13:45,149 --> 00:13:49,839
so in raft<font color="#CCCCCC"> and they'll can</font><font color="#E5E5E5"> be in one</font><font color="#CCCCCC"> or</font>

304
00:13:48,249 --> 00:13:52,329
three<font color="#E5E5E5"> states it can be</font><font color="#CCCCCC"> a follower a</font>

305
00:13:49,839 --> 00:13:54,399
candidate to become<font color="#CCCCCC"> a leader or the</font>

306
00:13:52,329 --> 00:13:56,319
leader itself<font color="#E5E5E5"> if it is the leader than</font>

307
00:13:54,399 --> 00:13:59,529
it is the one<font color="#E5E5E5"> that handles user requests</font>

308
00:13:56,319 --> 00:14:01,089
and carries out there will<font color="#E5E5E5"> be four right</font>

309
00:13:59,529 --> 00:14:02,889
in the context<font color="#CCCCCC"> of the blue team</font><font color="#E5E5E5"> and</font>

310
00:14:01,089 --> 00:14:06,699
applies a new value<font color="#CCCCCC"> and replicates it to</font>

311
00:14:02,889 --> 00:14:08,230
the followers<font color="#E5E5E5"> it is also in</font><font color="#CCCCCC"> charge of</font>

312
00:14:06,699 --> 00:14:12,550
sending periodic heartbeats to the

313
00:14:08,230 --> 00:14:14,649
followers<font color="#E5E5E5"> to keep them devout and if the</font>

314
00:14:12,550 --> 00:14:16,420
wielder becomes unavailable<font color="#CCCCCC"> and one</font><font color="#E5E5E5"> of</font>

315
00:14:14,649 --> 00:14:18,639
the<font color="#CCCCCC"> followers will notice will become a</font>

316
00:14:16,420 --> 00:14:20,920
candidate<font color="#E5E5E5"> and will propose itself for</font>

317
00:14:18,639 --> 00:14:22,540
leadership<font color="#E5E5E5"> a candidate will become a</font>

318
00:14:20,920 --> 00:14:27,490
leader<font color="#E5E5E5"> if it receives votes from a</font>

319
00:14:22,540 --> 00:14:29,529
majority<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the other replicas in raft</font>

320
00:14:27,490 --> 00:14:31,449
we have three<font color="#CCCCCC"> components we have the</font>

321
00:14:29,529 --> 00:14:33,910
main consensus module that drives all<font color="#CCCCCC"> of</font>

322
00:14:31,449 --> 00:14:37,029
the algorithm is logic we have<font color="#CCCCCC"> the log</font>

323
00:14:33,910 --> 00:14:39,999
which implements and<font color="#CCCCCC"> destroy</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> head</font>

324
00:14:37,029 --> 00:14:41,670
<font color="#CCCCCC">lock</font><font color="#E5E5E5"> where which</font><font color="#CCCCCC"> is the thing that</font>

325
00:14:39,999 --> 00:14:45,910
actually<font color="#E5E5E5"> provides most of</font><font color="#CCCCCC"> the guarantees</font>

326
00:14:41,670 --> 00:14:48,009
<font color="#E5E5E5">of the protocol</font><font color="#CCCCCC"> and when those entries</font>

327
00:14:45,910 --> 00:14:49,809
of the log are safely committed in a

328
00:14:48,009 --> 00:14:51,879
majority of the followers then they are

329
00:14:49,809 --> 00:14:53,469
play apply it to the state machine which

330
00:14:51,879 --> 00:14:56,199
in the case<font color="#E5E5E5"> of</font><font color="#CCCCCC"> sealer</font><font color="#E5E5E5"> the state machine</font>

331
00:14:53,470 --> 00:14:58,749
is the<font color="#E5E5E5"> database itself and of course</font>

332
00:14:56,199 --> 00:15:02,949
<font color="#E5E5E5">then the clients observes the data in</font>

333
00:14:58,749 --> 00:15:06,459
the state machine the algorithm<font color="#CCCCCC"> provides</font>

334
00:15:02,949 --> 00:15:09,639
a set of<font color="#CCCCCC"> guarantees</font><font color="#E5E5E5"> that makes it very</font>

335
00:15:06,459 --> 00:15:13,540
understandable<font color="#E5E5E5"> so it the election safety</font>

336
00:15:09,639 --> 00:15:15,749
guarantee means that at any<font color="#CCCCCC"> given time</font>

337
00:15:13,540 --> 00:15:19,480
there is only one leader<font color="#E5E5E5"> in the system</font>

338
00:15:15,749 --> 00:15:23,559
the leader is the only replica<font color="#CCCCCC"> that can</font>

339
00:15:19,480 --> 00:15:25,179
append entries to the<font color="#E5E5E5"> log the raft</font>

340
00:15:23,559 --> 00:15:28,600
enforces through the log matching

341
00:15:25,179 --> 00:15:30,459
<font color="#CCCCCC">property that if two logs</font><font color="#E5E5E5"> that of the</font>

342
00:15:28,600 --> 00:15:32,710
leader and<font color="#CCCCCC"> one of the</font><font color="#E5E5E5"> followers contain</font>

343
00:15:30,459 --> 00:15:34,839
the same entry<font color="#E5E5E5"> at a particular index</font>

344
00:15:32,710 --> 00:15:37,540
for a particular<font color="#CCCCCC"> term</font><font color="#E5E5E5"> then the logs are</font>

345
00:15:34,840 --> 00:15:39,100
identical<font color="#E5E5E5"> up until that point if that</font><font color="#CCCCCC"> is</font>

346
00:15:37,540 --> 00:15:43,810
<font color="#E5E5E5">not the case then the leader will</font>

347
00:15:39,100 --> 00:15:46,150
actually will send whatever entries the

348
00:15:43,810 --> 00:15:48,729
follower<font color="#CCCCCC"> may</font><font color="#E5E5E5"> be missing or will remove</font>

349
00:15:46,150 --> 00:15:54,610
<font color="#CCCCCC">from the follower whatever</font><font color="#E5E5E5"> extraneous</font>

350
00:15:48,730 --> 00:15:56,620
<font color="#E5E5E5">entries it might have in</font><font color="#CCCCCC"> Raph - for a</font>

351
00:15:54,610 --> 00:15:59,530
<font color="#CCCCCC">node to be elected leader it needs to be</font>

352
00:15:56,620 --> 00:16:06,400
at<font color="#E5E5E5"> least as up-to-date as the previous</font>

353
00:15:59,530 --> 00:16:09,100
leader and finally if a log<font color="#E5E5E5"> entry is</font>

354
00:16:06,400 --> 00:16:10,959
applied to the state machine in a

355
00:16:09,100 --> 00:16:13,900
particular replica<font color="#E5E5E5"> then it is guaranteed</font>

356
00:16:10,960 --> 00:16:16,210
<font color="#CCCCCC">that</font><font color="#E5E5E5"> the same entry is applied for the</font>

357
00:16:13,900 --> 00:16:18,100
same position of<font color="#E5E5E5"> the law across all the</font>

358
00:16:16,210 --> 00:16:19,480
other replicas<font color="#E5E5E5"> this is how we guarantee</font>

359
00:16:18,100 --> 00:16:23,020
<font color="#CCCCCC">that all the replicas are in fact</font>

360
00:16:19,480 --> 00:16:28,180
working<font color="#CCCCCC"> as a replicator state machine so</font>

361
00:16:23,020 --> 00:16:31,030
in raft<font color="#E5E5E5"> time is divided</font><font color="#CCCCCC"> in terms each</font>

362
00:16:28,180 --> 00:16:36,489
term is comprised of the<font color="#CCCCCC"> bidder election</font>

363
00:16:31,030 --> 00:16:38,829
process<font color="#E5E5E5"> and from this it can result that</font>

364
00:16:36,490 --> 00:16:41,260
we<font color="#E5E5E5"> were able</font><font color="#CCCCCC"> to elect to either</font><font color="#E5E5E5"> or maybe</font>

365
00:16:38,830 --> 00:16:43,180
we were no<font color="#CCCCCC"> node received the majority of</font>

366
00:16:41,260 --> 00:16:46,720
votes so the process needs<font color="#E5E5E5"> to be</font>

367
00:16:43,180 --> 00:16:51,370
repeated but time in raft is logically

368
00:16:46,720 --> 00:16:55,660
divided in in these terms<font color="#E5E5E5"> so</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> plan is</font>

369
00:16:51,370 --> 00:16:58,390
<font color="#E5E5E5">throughout to</font><font color="#CCCCCC"> seal them leads to a bunch</font>

370
00:16:55,660 --> 00:17:02,280
of<font color="#E5E5E5"> interesting</font><font color="#CCCCCC"> design choices</font><font color="#E5E5E5"> so first</font>

371
00:16:58,390 --> 00:17:05,020
of all because<font color="#CCCCCC"> Selah is partitioned</font>

372
00:17:02,280 --> 00:17:09,940
<font color="#E5E5E5">there is no single node that holds all</font>

373
00:17:05,020 --> 00:17:11,770
data so even if we wanted<font color="#CCCCCC"> to have a</font>

374
00:17:09,940 --> 00:17:14,110
single<font color="#E5E5E5"> leader for the whole cluster it</font>

375
00:17:11,770 --> 00:17:16,119
<font color="#E5E5E5">would be very cumbersome because it</font>

376
00:17:14,109 --> 00:17:18,159
would need<font color="#CCCCCC"> to</font><font color="#E5E5E5"> contact other nodes and</font>

377
00:17:16,119 --> 00:17:19,839
that<font color="#CCCCCC"> actually hold the data to do the</font>

378
00:17:18,160 --> 00:17:22,810
read before<font color="#E5E5E5"> right and</font><font color="#CCCCCC"> entry eventually</font>

379
00:17:19,839 --> 00:17:24,579
applied the read<font color="#E5E5E5"> the right all the while</font>

380
00:17:22,810 --> 00:17:27,760
<font color="#E5E5E5">holding some</font><font color="#CCCCCC"> Watts that would prevent</font>

381
00:17:24,579 --> 00:17:31,389
other concurrent<font color="#E5E5E5"> operations from from</font>

382
00:17:27,760 --> 00:17:33,670
continuing and it also mean obviously

383
00:17:31,390 --> 00:17:35,230
<font color="#CCCCCC">that if all the write operations have to</font>

384
00:17:33,670 --> 00:17:37,930
go through a single node it<font color="#CCCCCC"> will prove</font>

385
00:17:35,230 --> 00:17:40,510
to<font color="#E5E5E5"> be a huge bottleneck so what we do</font>

386
00:17:37,930 --> 00:17:43,290
<font color="#E5E5E5">instead is we</font><font color="#CCCCCC"> have as many ref groups as</font>

387
00:17:40,510 --> 00:17:47,190
there<font color="#CCCCCC"> are partitions of the token space</font>

388
00:17:43,290 --> 00:17:49,020
so for<font color="#CCCCCC"> each token range</font><font color="#E5E5E5"> there is</font><font color="#CCCCCC"> a set</font>

389
00:17:47,190 --> 00:17:51,510
<font color="#E5E5E5">of replicas</font><font color="#CCCCCC"> that handle that</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> subsets</font>

390
00:17:49,020 --> 00:17:54,660
of the data<font color="#E5E5E5"> and those replicas form a</font>

391
00:17:51,510 --> 00:18:01,980
raft group so there are many many

392
00:17:54,660 --> 00:18:05,160
leaders and many reps<font color="#CCCCCC"> a nice consequence</font>

393
00:18:01,980 --> 00:18:08,610
of this is<font color="#E5E5E5"> that we can have higher</font>

394
00:18:05,160 --> 00:18:10,650
concurrency so all<font color="#E5E5E5"> right goat can go to</font>

395
00:18:08,610 --> 00:18:15,000
two<font color="#CCCCCC"> different leaders two different raft</font>

396
00:18:10,650 --> 00:18:17,310
groups and if one<font color="#E5E5E5"> of those leader fails</font>

397
00:18:15,000 --> 00:18:19,260
<font color="#E5E5E5">and we have to elect a new leader</font>

398
00:18:17,310 --> 00:18:21,300
<font color="#E5E5E5">there's going to be a brief period of an</font>

399
00:18:19,260 --> 00:18:23,940
availability<font color="#E5E5E5"> however this will only</font>

400
00:18:21,300 --> 00:18:26,520
<font color="#E5E5E5">affect a subset of operations there's</font>

401
00:18:23,940 --> 00:18:32,640
some fine print next<font color="#E5E5E5"> to this because if</font>

402
00:18:26,520 --> 00:18:34,470
<font color="#E5E5E5">we have n nodes then if</font><font color="#CCCCCC"> one leader let's</font>

403
00:18:32,640 --> 00:18:37,140
say we have<font color="#CCCCCC"> 10 nodes</font><font color="#E5E5E5"> if a leader dies</font>

404
00:18:34,470 --> 00:18:39,990
<font color="#E5E5E5">then</font><font color="#CCCCCC"> we are going</font><font color="#E5E5E5"> to lose 10% of our</font>

405
00:18:37,140 --> 00:18:42,690
token<font color="#CCCCCC"> ranges so if a client is</font><font color="#E5E5E5"> making</font>

406
00:18:39,990 --> 00:18:47,250
random requests then there is a 1<font color="#E5E5E5"> over</font><font color="#CCCCCC"> N</font>

407
00:18:42,690 --> 00:18:49,890
probability<font color="#CCCCCC"> that it will</font><font color="#E5E5E5"> hit a key for</font>

408
00:18:47,250 --> 00:18:51,060
which the leader isn't<font color="#CCCCCC"> available so it</font>

409
00:18:49,890 --> 00:18:52,620
doesn't mean<font color="#CCCCCC"> that repeat the cap theorem</font>

410
00:18:51,060 --> 00:18:58,740
we were still<font color="#E5E5E5"> going to be</font><font color="#CCCCCC"> unavailable</font>

411
00:18:52,620 --> 00:19:00,570
<font color="#E5E5E5">under</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> process</font><font color="#CCCCCC"> of failures</font><font color="#E5E5E5"> because of</font>

412
00:18:58,740 --> 00:19:03,150
how silly is implemented on top<font color="#E5E5E5"> of</font>

413
00:19:00,570 --> 00:19:08,040
<font color="#E5E5E5">sistar each group itself is going to be</font>

414
00:19:03,150 --> 00:19:10,500
<font color="#CCCCCC">sharded on a particular node and so</font><font color="#E5E5E5"> a</font>

415
00:19:08,040 --> 00:19:12,510
shard or CPU is<font color="#CCCCCC"> going to handle a subset</font>

416
00:19:10,500 --> 00:19:15,330
of the operations<font color="#CCCCCC"> of that particular</font>

417
00:19:12,510 --> 00:19:19,620
raft group this<font color="#CCCCCC"> is going to impact how</font>

418
00:19:15,330 --> 00:19:21,389
<font color="#CCCCCC">we organize those Revlon's so inside a</font>

419
00:19:19,620 --> 00:19:24,899
<font color="#E5E5E5">particular node we are</font><font color="#CCCCCC"> going to have</font>

420
00:19:21,390 --> 00:19:28,020
many<font color="#E5E5E5"> of these ref groups and have here</font>

421
00:19:24,900 --> 00:19:30,540
the typical raft modules<font color="#E5E5E5"> the core the</font>

422
00:19:28,020 --> 00:19:33,720
<font color="#E5E5E5">core consensus module and the log</font>

423
00:19:30,540 --> 00:19:35,850
database the state is going to<font color="#E5E5E5"> be</font>

424
00:19:33,720 --> 00:19:38,580
whatever precision<font color="#E5E5E5"> state we are going to</font>

425
00:19:35,850 --> 00:19:40,500
need<font color="#E5E5E5"> to keep across and reboots and then</font>

426
00:19:38,580 --> 00:19:43,710
the RPC module is<font color="#CCCCCC"> just what we used for</font>

427
00:19:40,500 --> 00:19:46,020
messaging between<font color="#E5E5E5"> replicates so it's</font>

428
00:19:43,710 --> 00:19:49,980
shard<font color="#CCCCCC"> it</font><font color="#E5E5E5"> CPU is</font><font color="#CCCCCC"> going to have an</font>

429
00:19:46,020 --> 00:19:51,780
instance of all of these<font color="#E5E5E5"> groups however</font>

430
00:19:49,980 --> 00:19:54,570
shared between all<font color="#E5E5E5"> of these are going to</font>

431
00:19:51,780 --> 00:19:56,500
be the<font color="#E5E5E5"> hard bits module so if a nose is</font>

432
00:19:54,570 --> 00:20:00,070
a leader for<font color="#E5E5E5"> many</font>

433
00:19:56,500 --> 00:20:02,350
groups and there is a follower that's a

434
00:20:00,070 --> 00:20:04,179
follower for many of those groups and we

435
00:20:02,350 --> 00:20:05,439
don't want<font color="#E5E5E5"> to</font><font color="#CCCCCC"> send n heartbeats we want</font>

436
00:20:04,180 --> 00:20:08,020
to call as the heart<font color="#E5E5E5"> beats into</font>

437
00:20:05,440 --> 00:20:12,100
adjustment message<font color="#CCCCCC"> in centers that that</font>

438
00:20:08,020 --> 00:20:14,260
one<font color="#CCCCCC"> heart beat this</font><font color="#E5E5E5"> is how the simple</font>

439
00:20:12,100 --> 00:20:16,570
file right path<font color="#E5E5E5"> looks like inside I know</font>

440
00:20:14,260 --> 00:20:18,900
<font color="#E5E5E5">so we have</font><font color="#CCCCCC"> a mutation</font><font color="#E5E5E5"> which is how we</font>

441
00:20:16,570 --> 00:20:22,270
represent<font color="#E5E5E5"> right</font><font color="#CCCCCC"> requests</font><font color="#E5E5E5"> in Silla</font>

442
00:20:18,900 --> 00:20:24,460
<font color="#CCCCCC">mutation is item from idempotent</font><font color="#E5E5E5"> and</font>

443
00:20:22,270 --> 00:20:26,410
commutative<font color="#CCCCCC"> and a set of restrictions</font>

444
00:20:24,460 --> 00:20:29,470
<font color="#E5E5E5">against which we</font><font color="#CCCCCC"> are going to compare</font>

445
00:20:26,410 --> 00:20:31,180
whatever<font color="#CCCCCC"> is on</font><font color="#E5E5E5"> disk so first we</font><font color="#CCCCCC"> apply</font>

446
00:20:29,470 --> 00:20:34,840
some<font color="#CCCCCC"> watts to ensure that</font><font color="#E5E5E5"> concurrent</font>

447
00:20:31,180 --> 00:20:36,610
operations are blocked we query the

448
00:20:34,840 --> 00:20:38,679
<font color="#E5E5E5">database to</font><font color="#CCCCCC"> find out what's the current</font>

449
00:20:36,610 --> 00:20:41,139
<font color="#E5E5E5">value we compare that against</font><font color="#CCCCCC"> the set</font><font color="#E5E5E5"> of</font>

450
00:20:38,680 --> 00:20:43,720
restrictions<font color="#E5E5E5"> and if they match then we</font>

451
00:20:41,140 --> 00:20:46,120
applied the entry to<font color="#CCCCCC"> the log</font><font color="#E5E5E5"> from there</font>

452
00:20:43,720 --> 00:20:48,700
we communicate with the<font color="#E5E5E5"> followers to try</font>

453
00:20:46,120 --> 00:20:50,530
and replicate<font color="#E5E5E5"> that log entry and when we</font>

454
00:20:48,700 --> 00:20:52,510
finally replicate it to<font color="#CCCCCC"> a majority</font><font color="#E5E5E5"> of</font>

455
00:20:50,530 --> 00:20:55,000
followers<font color="#E5E5E5"> that entry</font><font color="#CCCCCC"> is committed and</font>

456
00:20:52,510 --> 00:21:02,730
committed entries can<font color="#E5E5E5"> be safely applied</font>

457
00:20:55,000 --> 00:21:06,400
to the database so<font color="#CCCCCC"> charting then</font><font color="#E5E5E5"> is</font>

458
00:21:02,730 --> 00:21:08,160
where all the differences between a

459
00:21:06,400 --> 00:21:11,980
typical<font color="#CCCCCC"> ref implementation and this</font><font color="#E5E5E5"> one</font>

460
00:21:08,160 --> 00:21:13,840
are<font color="#CCCCCC"> going</font><font color="#E5E5E5"> to rise</font><font color="#CCCCCC"> from so first of all</font>

461
00:21:11,980 --> 00:21:17,680
<font color="#E5E5E5">you know you notice how we are we</font>

462
00:21:13,840 --> 00:21:21,129
<font color="#E5E5E5">organized our raft groups per node but</font>

463
00:21:17,680 --> 00:21:24,280
inside the nose is chard is handles<font color="#E5E5E5"> a</font>

464
00:21:21,130 --> 00:21:26,440
<font color="#CCCCCC">non overlapping subset of the ranges so</font>

465
00:21:24,280 --> 00:21:28,270
why didn't we<font color="#E5E5E5"> organize the groups by by</font>

466
00:21:26,440 --> 00:21:30,430
Charlaine staff and the reason is that

467
00:21:28,270 --> 00:21:32,530
this would lead<font color="#CCCCCC"> to</font><font color="#E5E5E5"> communion Toria</font>

468
00:21:30,430 --> 00:21:34,570
laughs portion of<font color="#E5E5E5"> states so</font><font color="#CCCCCC"> the metadata</font>

469
00:21:32,530 --> 00:21:39,790
for all<font color="#E5E5E5"> those groups would overwhelm on</font>

470
00:21:34,570 --> 00:21:42,070
a database in raft<font color="#CCCCCC"> particular entry is</font>

471
00:21:39,790 --> 00:21:45,190
identified<font color="#CCCCCC"> by</font><font color="#E5E5E5"> the term that is written</font>

472
00:21:42,070 --> 00:21:48,850
in and by the<font color="#E5E5E5"> index in the</font><font color="#CCCCCC"> log file so</font>

473
00:21:45,190 --> 00:21:54,400
in<font color="#E5E5E5"> Silla</font><font color="#CCCCCC"> rafts</font><font color="#E5E5E5"> we add to that what was</font>

474
00:21:48,850 --> 00:21:55,929
the<font color="#E5E5E5"> leader</font><font color="#CCCCCC"> shard that</font><font color="#E5E5E5"> entry belong to we</font>

475
00:21:54,400 --> 00:21:58,120
are<font color="#E5E5E5"> going to have to be careful</font><font color="#CCCCCC"> with a</font>

476
00:21:55,930 --> 00:21:59,800
true genius clusters these are clusters

477
00:21:58,120 --> 00:22:02,350
where the short count is<font color="#E5E5E5"> different</font>

478
00:21:59,800 --> 00:22:04,360
between nodes<font color="#E5E5E5"> and this is not a typical</font>

479
00:22:02,350 --> 00:22:06,580
<font color="#CCCCCC">situation but it can happen during a</font>

480
00:22:04,360 --> 00:22:08,929
rolling restart where someone is

481
00:22:06,580 --> 00:22:10,970
provisioning more CPUs on their machines

482
00:22:08,930 --> 00:22:12,650
and for a<font color="#CCCCCC"> short while short camp is</font>

483
00:22:10,970 --> 00:22:15,410
going to be different<font color="#CCCCCC"> among the among</font>

484
00:22:12,650 --> 00:22:17,510
the<font color="#CCCCCC"> notes and</font><font color="#E5E5E5"> also regarding</font><font color="#CCCCCC"> which is</font>

485
00:22:15,410 --> 00:22:20,950
when one of<font color="#E5E5E5"> those notes reboots and</font>

486
00:22:17,510 --> 00:22:22,940
comes up<font color="#CCCCCC"> with</font><font color="#E5E5E5"> the different short count</font>

487
00:22:20,950 --> 00:22:24,860
so if<font color="#CCCCCC"> we were dealing</font><font color="#E5E5E5"> with the</font>

488
00:22:22,940 --> 00:22:28,250
<font color="#CCCCCC">homogenous</font><font color="#E5E5E5"> and cluster than everything</font>

489
00:22:24,860 --> 00:22:32,270
is fine<font color="#CCCCCC"> sharp 0 of 0 is</font><font color="#E5E5E5"> going to talk</font>

490
00:22:28,250 --> 00:22:33,980
with<font color="#CCCCCC"> char</font><font color="#E5E5E5"> 0 of similar note and</font><font color="#CCCCCC"> their</font>

491
00:22:32,270 --> 00:22:37,100
lobs are going to be exactly<font color="#E5E5E5"> the</font><font color="#CCCCCC"> same</font>

492
00:22:33,980 --> 00:22:40,090
<font color="#E5E5E5">and</font><font color="#CCCCCC"> organized the same way if</font><font color="#E5E5E5"> however we</font>

493
00:22:37,100 --> 00:22:42,678
have different short counts can<font color="#E5E5E5"> be that</font>

494
00:22:40,090 --> 00:22:45,500
different leader shards are talking to

495
00:22:42,679 --> 00:22:50,390
the same<font color="#CCCCCC"> foolish art this means that in</font>

496
00:22:45,500 --> 00:22:54,140
<font color="#CCCCCC">the followers log</font><font color="#E5E5E5"> these entries are not</font>

497
00:22:50,390 --> 00:22:57,800
going to match<font color="#E5E5E5"> how they are ordered in</font>

498
00:22:54,140 --> 00:23:01,610
the leader<font color="#CCCCCC"> lots in particular for the</font>

499
00:22:57,800 --> 00:23:04,399
log matching<font color="#CCCCCC"> property of raft we when we</font>

500
00:23:01,610 --> 00:23:07,309
send the new log entry<font color="#E5E5E5"> we also send and</font>

501
00:23:04,400 --> 00:23:09,740
what<font color="#E5E5E5"> we expect there to be before so the</font>

502
00:23:07,309 --> 00:23:11,780
log the follower can check if it does

503
00:23:09,740 --> 00:23:13,760
contain<font color="#CCCCCC"> if it's log is up-to-date</font><font color="#E5E5E5"> to the</font>

504
00:23:11,780 --> 00:23:16,070
expectations of the<font color="#E5E5E5"> leader and if it's</font>

505
00:23:13,760 --> 00:23:18,679
not then we trigger that process by

506
00:23:16,070 --> 00:23:22,370
which the follower<font color="#E5E5E5"> is brought up to</font>

507
00:23:18,679 --> 00:23:24,380
<font color="#CCCCCC">speed</font><font color="#E5E5E5"> in this case the follower can have</font>

508
00:23:22,370 --> 00:23:27,439
entries<font color="#E5E5E5"> that another leader</font><font color="#CCCCCC"> shard gave</font>

509
00:23:24,380 --> 00:23:30,590
it and they won't match<font color="#E5E5E5"> but this other</font>

510
00:23:27,440 --> 00:23:33,080
leader<font color="#CCCCCC"> Sharlee is expecting we could</font>

511
00:23:30,590 --> 00:23:35,360
like solve this by going<font color="#CCCCCC"> over and</font>

512
00:23:33,080 --> 00:23:38,629
<font color="#E5E5E5">filtering out</font><font color="#CCCCCC"> interesting log but it</font>

513
00:23:35,360 --> 00:23:41,899
<font color="#E5E5E5">will be cumbersome we can have a similar</font>

514
00:23:38,630 --> 00:23:44,929
<font color="#CCCCCC">scenario where the leader shard is</font>

515
00:23:41,900 --> 00:23:48,290
talking to different<font color="#CCCCCC"> follower</font><font color="#E5E5E5"> shards and</font>

516
00:23:44,929 --> 00:23:50,990
in<font color="#E5E5E5"> this case the logs in folder shards</font>

517
00:23:48,290 --> 00:23:52,190
are going to have gaps in them because

518
00:23:50,990 --> 00:23:55,160
some<font color="#E5E5E5"> of the entries went to another</font>

519
00:23:52,190 --> 00:23:56,600
<font color="#CCCCCC">source on that</font><font color="#E5E5E5"> machine</font><font color="#CCCCCC"> and here is the</font>

520
00:23:55,160 --> 00:23:58,790
same thing<font color="#CCCCCC"> when we were trying to append</font>

521
00:23:56,600 --> 00:24:01,879
an entry<font color="#CCCCCC"> in the log matching property we</font>

522
00:23:58,790 --> 00:24:03,649
<font color="#E5E5E5">will require that we</font><font color="#CCCCCC"> look at what's in</font>

523
00:24:01,880 --> 00:24:05,030
the<font color="#CCCCCC"> wall</font><font color="#E5E5E5"> and we're going to find gaps</font>

524
00:24:03,650 --> 00:24:09,650
there and the algorithm is<font color="#CCCCCC"> going to</font>

525
00:24:05,030 --> 00:24:12,350
assume that<font color="#CCCCCC"> is missing data so it won't</font>

526
00:24:09,650 --> 00:24:14,450
<font color="#E5E5E5">work</font><font color="#CCCCCC"> very well</font><font color="#E5E5E5"> so to solve this we</font>

527
00:24:12,350 --> 00:24:16,909
<font color="#E5E5E5">change how logs are organized we</font>

528
00:24:14,450 --> 00:24:19,370
organize them<font color="#CCCCCC"> by term because for a</font>

529
00:24:16,910 --> 00:24:20,840
particular term<font color="#E5E5E5"> and the leader</font><font color="#CCCCCC"> short</font>

530
00:24:19,370 --> 00:24:23,268
<font color="#CCCCCC">count is stable</font>

531
00:24:20,840 --> 00:24:27,889
and then we also<font color="#CCCCCC"> organized them by</font>

532
00:24:23,269 --> 00:24:30,519
litter shard when<font color="#E5E5E5"> literally stars then</font>

533
00:24:27,889 --> 00:24:33,729
each term<font color="#E5E5E5"> ends it has to go through</font>

534
00:24:30,519 --> 00:24:36,169
<font color="#E5E5E5">another leader election in other words</font>

535
00:24:33,730 --> 00:24:41,179
whether or not is a weed<font color="#CCCCCC"> or not it's not</font>

536
00:24:36,169 --> 00:24:43,429
preserved across<font color="#E5E5E5"> riblets this is why if</font>

537
00:24:41,179 --> 00:24:45,320
<font color="#E5E5E5">you</font><font color="#CCCCCC"> have if you're changing the the</font><font color="#E5E5E5"> CPU</font>

538
00:24:43,429 --> 00:24:47,090
pounds of a nose<font color="#E5E5E5"> you</font><font color="#CCCCCC"> have to go through</font>

539
00:24:45,320 --> 00:24:50,418
<font color="#CCCCCC">a restart so this means we don't have to</font>

540
00:24:47,090 --> 00:24:55,189
worry<font color="#E5E5E5"> about</font><font color="#CCCCCC"> a leader recharging in the</font>

541
00:24:50,419 --> 00:24:57,259
middle of this term<font color="#E5E5E5"> and because now</font><font color="#CCCCCC"> when</font>

542
00:24:55,190 --> 00:25:00,049
the followers logs are organized by

543
00:24:57,259 --> 00:25:02,450
leader shard<font color="#E5E5E5"> it can be that in some</font>

544
00:25:00,049 --> 00:25:04,908
<font color="#E5E5E5">cases different shards have to</font><font color="#CCCCCC"> access</font>

545
00:25:02,450 --> 00:25:07,340
<font color="#E5E5E5">the same log so they will require</font>

546
00:25:04,909 --> 00:25:09,980
synchronization<font color="#CCCCCC"> and this goes a little</font>

547
00:25:07,340 --> 00:25:13,519
bit against<font color="#CCCCCC"> the philosophy</font><font color="#E5E5E5"> or sister</font>

548
00:25:09,980 --> 00:25:18,559
where thing is<font color="#E5E5E5"> partitioned but this</font>

549
00:25:13,519 --> 00:25:21,860
situation<font color="#CCCCCC"> is</font><font color="#E5E5E5"> really not typical so we do</font>

550
00:25:18,559 --> 00:25:25,580
<font color="#CCCCCC">require some synchronization here so</font>

551
00:25:21,860 --> 00:25:27,469
finally a lot compaction<font color="#E5E5E5"> as I said when</font>

552
00:25:25,580 --> 00:25:30,019
entries are committed replicated to

553
00:25:27,470 --> 00:25:33,159
<font color="#E5E5E5">majority of followers they can be</font>

554
00:25:30,019 --> 00:25:36,169
written<font color="#CCCCCC"> into the database at this point</font>

555
00:25:33,159 --> 00:25:41,600
we can compact the<font color="#E5E5E5"> log and get rid</font><font color="#CCCCCC"> of</font>

556
00:25:36,169 --> 00:25:43,399
all<font color="#CCCCCC"> of</font><font color="#E5E5E5"> these committed entries in in</font>

557
00:25:41,600 --> 00:25:45,110
other words it<font color="#E5E5E5"> means that the database</font>

558
00:25:43,399 --> 00:25:48,918
itself is now going<font color="#CCCCCC"> to be responsible</font>

559
00:25:45,110 --> 00:25:51,289
<font color="#CCCCCC">for</font><font color="#E5E5E5"> that prefix of the</font><font color="#CCCCCC"> log this has</font>

560
00:25:48,919 --> 00:25:54,379
consequences when we<font color="#CCCCCC"> are</font><font color="#E5E5E5"> doing with a</font>

561
00:25:51,289 --> 00:25:56,210
follower<font color="#CCCCCC"> that has fallen behind</font><font color="#E5E5E5"> it needs</font>

562
00:25:54,379 --> 00:25:58,129
to be brought<font color="#E5E5E5"> up</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> date so whereas</font>

563
00:25:56,210 --> 00:26:01,940
before we could<font color="#E5E5E5"> just ship the log</font>

564
00:25:58,129 --> 00:26:04,039
entries<font color="#CCCCCC"> over to that node now we have to</font>

565
00:26:01,940 --> 00:26:06,759
<font color="#E5E5E5">look into the database States and figure</font>

566
00:26:04,039 --> 00:26:08,779
<font color="#CCCCCC">out what</font><font color="#E5E5E5"> that note is missing</font>

567
00:26:06,759 --> 00:26:10,820
fortunately we already solve that

568
00:26:08,779 --> 00:26:13,100
problem<font color="#CCCCCC"> we</font><font color="#E5E5E5"> have the same exactly the</font>

569
00:26:10,820 --> 00:26:15,049
<font color="#CCCCCC">same</font><font color="#E5E5E5"> problem with diverging replicas so</font>

570
00:26:13,100 --> 00:26:16,998
we can use<font color="#E5E5E5"> that anti entropy process</font>

571
00:26:15,049 --> 00:26:19,879
that we call repair to figure out

572
00:26:16,999 --> 00:26:23,179
exactly what<font color="#CCCCCC"> piece of data</font><font color="#E5E5E5"> follower is</font>

573
00:26:19,879 --> 00:26:29,350
missing and then transmit only those

574
00:26:23,179 --> 00:26:32,059
mutations<font color="#CCCCCC"> over to it there are some</font>

575
00:26:29,350 --> 00:26:34,459
interesting aspects<font color="#E5E5E5"> to this</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> do to</font>

576
00:26:32,059 --> 00:26:35,960
natural concurrency it can be that

577
00:26:34,460 --> 00:26:38,270
what we're transferring to<font color="#CCCCCC"> the note</font>

578
00:26:35,960 --> 00:26:39,590
<font color="#E5E5E5">actually overlaps with entries that</font><font color="#CCCCCC"> are</font>

579
00:26:38,270 --> 00:26:43,300
in the log<font color="#E5E5E5"> that we are also shipping</font>

580
00:26:39,590 --> 00:26:46,370
over but because our mutations are

581
00:26:43,300 --> 00:26:49,580
<font color="#E5E5E5">idempotence and commutative and no harm</font>

582
00:26:46,370 --> 00:26:51,679
comes of this<font color="#E5E5E5"> and it's also the</font><font color="#CCCCCC"> case</font>

583
00:26:49,580 --> 00:26:54,320
that repair is a heavyweight process to

584
00:26:51,680 --> 00:26:56,120
run so we'd<font color="#CCCCCC"> like</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> avoid it</font><font color="#E5E5E5"> so if we</font>

585
00:26:54,320 --> 00:26:57,850
<font color="#CCCCCC">notice that we have some followers</font><font color="#E5E5E5"> that</font>

586
00:26:56,120 --> 00:27:01,580
<font color="#E5E5E5">are falling behind we</font><font color="#CCCCCC"> can choose to keep</font>

587
00:26:57,850 --> 00:27:03,139
some committed<font color="#CCCCCC"> log segments around I say</font>

588
00:27:01,580 --> 00:27:06,320
when gigabyte worth of what<font color="#CCCCCC"> Simon's</font>

589
00:27:03,140 --> 00:27:08,270
<font color="#E5E5E5">around just to make</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> much faster to</font>

590
00:27:06,320 --> 00:27:11,720
bring those those<font color="#CCCCCC"> four is up to date</font>

591
00:27:08,270 --> 00:27:15,350
<font color="#E5E5E5">it's much faster to just send sequential</font>

592
00:27:11,720 --> 00:27:17,360
pieces of<font color="#CCCCCC"> data over now the most</font>

593
00:27:15,350 --> 00:27:22,000
<font color="#E5E5E5">difficult aspects of all of this is</font>

594
00:27:17,360 --> 00:27:24,800
membership changes so as we saw and

595
00:27:22,000 --> 00:27:26,960
there will be many ref groups in a

596
00:27:24,800 --> 00:27:31,490
<font color="#E5E5E5">silikal</font><font color="#CCCCCC"> ester it's going to be for</font><font color="#E5E5E5"> each</font>

597
00:27:26,960 --> 00:27:33,740
key space<font color="#E5E5E5"> is we are going to have</font>

598
00:27:31,490 --> 00:27:36,200
replication factor times the<font color="#E5E5E5"> number of</font>

599
00:27:33,740 --> 00:27:41,030
<font color="#E5E5E5">Reno's which is how many token ranges</font>

600
00:27:36,200 --> 00:27:44,930
<font color="#E5E5E5">the space is divided in ref groups many</font>

601
00:27:41,030 --> 00:27:48,470
refworks and raft has a restriction on

602
00:27:44,930 --> 00:27:50,930
<font color="#CCCCCC">the</font><font color="#E5E5E5"> configuration changes it specifies</font>

603
00:27:48,470 --> 00:27:52,460
that<font color="#CCCCCC"> only</font><font color="#E5E5E5"> one node can</font><font color="#CCCCCC"> be added or</font>

604
00:27:50,930 --> 00:27:54,950
<font color="#CCCCCC">removed from a group at a particular</font>

605
00:27:52,460 --> 00:27:56,390
time<font color="#CCCCCC"> so if we want to</font><font color="#E5E5E5"> have</font><font color="#CCCCCC"> more complex</font>

606
00:27:54,950 --> 00:27:58,280
<font color="#E5E5E5">changes these</font><font color="#CCCCCC"> are going</font><font color="#E5E5E5"> to have to be</font>

607
00:27:56,390 --> 00:28:02,750
implemented<font color="#E5E5E5"> as a series of this new step</font>

608
00:27:58,280 --> 00:28:04,310
and changes in<font color="#CCCCCC"> Scylla if unless</font><font color="#E5E5E5"> you are</font>

609
00:28:02,750 --> 00:28:07,370
changing<font color="#E5E5E5"> the replication factor of a key</font>

610
00:28:04,310 --> 00:28:10,159
<font color="#E5E5E5">space and the member count of a group is</font>

611
00:28:07,370 --> 00:28:12,409
going<font color="#E5E5E5"> to remain the same whenever you're</font>

612
00:28:10,160 --> 00:28:14,150
adding<font color="#E5E5E5"> or removing a note so this means</font>

613
00:28:12,410 --> 00:28:16,160
<font color="#E5E5E5">that if you</font><font color="#CCCCCC"> are adding an L</font><font color="#E5E5E5"> to a group</font>

614
00:28:14,150 --> 00:28:18,260
you'll have to wait to remove one<font color="#CCCCCC"> of</font>

615
00:28:16,160 --> 00:28:22,190
those from<font color="#CCCCCC"> that group and conversely</font><font color="#E5E5E5"> if</font>

616
00:28:18,260 --> 00:28:24,970
you<font color="#E5E5E5"> are</font><font color="#CCCCCC"> removing enough so we have here</font>

617
00:28:22,190 --> 00:28:28,760
a segment<font color="#E5E5E5"> of the key space in which a</font>

618
00:28:24,970 --> 00:28:31,550
node a is the primary replica for<font color="#E5E5E5"> a</font>

619
00:28:28,760 --> 00:28:34,970
particular token space so it's going<font color="#CCCCCC"> to</font>

620
00:28:31,550 --> 00:28:36,530
form a<font color="#E5E5E5"> rest group and</font><font color="#CCCCCC"> replicas knows B</font>

621
00:28:34,970 --> 00:28:40,100
and C I'm going to be the secondary

622
00:28:36,530 --> 00:28:41,570
replicas for that<font color="#CCCCCC"> so can range so</font><font color="#E5E5E5"> there</font>

623
00:28:40,100 --> 00:28:44,000
these three<font color="#E5E5E5"> nodes are</font><font color="#CCCCCC"> going to be in</font><font color="#E5E5E5"> a</font>

624
00:28:41,570 --> 00:28:46,020
<font color="#E5E5E5">ref group together and the same thing</font>

625
00:28:44,000 --> 00:28:48,150
for<font color="#CCCCCC"> B is going</font><font color="#E5E5E5"> to be the primary left</font>

626
00:28:46,020 --> 00:28:50,250
<font color="#CCCCCC">replicas of</font><font color="#E5E5E5"> that particular token range</font>

627
00:28:48,150 --> 00:28:52,730
<font color="#E5E5E5">and</font><font color="#CCCCCC"> C is going to be in a group</font><font color="#E5E5E5"> with</font><font color="#CCCCCC"> it</font>

628
00:28:50,250 --> 00:28:55,760
and<font color="#E5E5E5"> whatever</font><font color="#CCCCCC"> notes cannot comes next</font>

629
00:28:52,730 --> 00:29:00,360
now if I<font color="#E5E5E5"> went to bootstrap and</font><font color="#CCCCCC"> no D and</font>

630
00:28:55,760 --> 00:29:03,450
D claims<font color="#CCCCCC"> a token range</font><font color="#E5E5E5"> that falls</font>

631
00:29:00,360 --> 00:29:06,540
between a and B some things are<font color="#E5E5E5"> going to</font>

632
00:29:03,450 --> 00:29:09,810
happen<font color="#E5E5E5"> namely now D is going</font><font color="#CCCCCC"> to be</font><font color="#E5E5E5"> a</font>

633
00:29:06,540 --> 00:29:13,710
secondary replicas for<font color="#E5E5E5"> a and C is no</font>

634
00:29:09,810 --> 00:29:17,010
<font color="#E5E5E5">longer going to be in that</font><font color="#CCCCCC"> ref group</font><font color="#E5E5E5"> the</font>

635
00:29:13,710 --> 00:29:19,080
ranges<font color="#CCCCCC"> for which B was a primary replica</font>

636
00:29:17,010 --> 00:29:22,820
for now have<font color="#E5E5E5"> changed because some</font><font color="#CCCCCC"> other</font>

637
00:29:19,080 --> 00:29:26,129
<font color="#E5E5E5">those Rangers</font><font color="#CCCCCC"> never belong</font><font color="#E5E5E5"> to D and</font>

638
00:29:22,820 --> 00:29:28,950
because<font color="#E5E5E5"> of that now D is also</font><font color="#CCCCCC"> a primary</font>

639
00:29:26,130 --> 00:29:30,690
<font color="#E5E5E5">replica for a new token range and B and</font>

640
00:29:28,950 --> 00:29:34,860
C<font color="#E5E5E5"> are going to be in a raft group</font>

641
00:29:30,690 --> 00:29:38,760
together<font color="#E5E5E5"> with</font><font color="#CCCCCC"> it out of all of these</font>

642
00:29:34,860 --> 00:29:42,090
things<font color="#E5E5E5"> most important is having no D</font>

643
00:29:38,760 --> 00:29:45,480
<font color="#E5E5E5">during</font><font color="#CCCCCC"> the group of a and having no C</font>

644
00:29:42,090 --> 00:29:47,490
<font color="#CCCCCC">livet rafts forbids that</font><font color="#E5E5E5"> these two</font>

645
00:29:45,480 --> 00:29:50,850
<font color="#CCCCCC">operations happen concurrently so we</font>

646
00:29:47,490 --> 00:29:54,110
have to order them and this is actually

647
00:29:50,850 --> 00:29:57,270
going is requires changes to how our

648
00:29:54,110 --> 00:29:58,490
group membership algorithms work<font color="#E5E5E5"> our</font>

649
00:29:57,270 --> 00:30:01,650
existing ones

650
00:29:58,490 --> 00:30:03,480
so before we<font color="#CCCCCC"> bootstrap ANOVA we need to</font>

651
00:30:01,650 --> 00:30:07,620
wait until<font color="#E5E5E5"> the</font><font color="#CCCCCC"> middle has drawn all of</font>

652
00:30:03,480 --> 00:30:09,900
<font color="#E5E5E5">the groups and this is when</font><font color="#CCCCCC"> we know that</font>

653
00:30:07,620 --> 00:30:16,679
<font color="#CCCCCC">it's safe for now the other nodes</font><font color="#E5E5E5"> to</font>

654
00:30:09,900 --> 00:30:20,870
exit<font color="#E5E5E5"> and those groups doing single</font>

655
00:30:16,680 --> 00:30:23,670
operation<font color="#E5E5E5"> at a time like raft requires</font>

656
00:30:20,870 --> 00:30:26,610
has the nice<font color="#CCCCCC"> property of</font><font color="#E5E5E5"> ensuring that</font>

657
00:30:23,670 --> 00:30:29,010
the majorities<font color="#CCCCCC"> of the configuration</font>

658
00:30:26,610 --> 00:30:32,820
before overlap with the majority<font color="#CCCCCC"> of the</font>

659
00:30:29,010 --> 00:30:35,790
configuration after<font color="#E5E5E5"> the change also</font>

660
00:30:32,820 --> 00:30:37,590
<font color="#CCCCCC">these</font><font color="#E5E5E5"> these configurations what replicas</font>

661
00:30:35,790 --> 00:30:41,370
comprise the<font color="#CCCCCC"> raft group are written as</font>

662
00:30:37,590 --> 00:30:43,649
special entries to the raft log so this

663
00:30:41,370 --> 00:30:45,300
has the drawback<font color="#E5E5E5"> that now bootstrapping</font>

664
00:30:43,650 --> 00:30:46,800
nodes or removing a node is going<font color="#E5E5E5"> to be</font>

665
00:30:45,300 --> 00:30:50,399
a much<font color="#E5E5E5"> longer process because it</font>

666
00:30:46,800 --> 00:30:53,340
requires consensus rounds across<font color="#E5E5E5"> all the</font>

667
00:30:50,400 --> 00:30:56,190
groups many of<font color="#CCCCCC"> the groups in the</font>

668
00:30:53,340 --> 00:30:59,850
sir<font color="#E5E5E5"> so adding or removing nose becomes</font>

669
00:30:56,190 --> 00:31:03,560
much<font color="#E5E5E5"> more expensive</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> finally</font><font color="#CCCCCC"> new</font>

670
00:30:59,850 --> 00:31:07,199
<font color="#CCCCCC">knobs because they</font><font color="#E5E5E5"> don't hold the data</font>

671
00:31:03,560 --> 00:31:11,610
<font color="#E5E5E5">they are</font><font color="#CCCCCC"> enter the system</font><font color="#E5E5E5"> as non-voting</font>

672
00:31:07,200 --> 00:31:13,470
members so they can be sent<font color="#E5E5E5"> log entries</font>

673
00:31:11,610 --> 00:31:15,199
<font color="#E5E5E5">from the wither but they can't really</font>

674
00:31:13,470 --> 00:31:18,570
<font color="#E5E5E5">participate in the</font><font color="#CCCCCC"> reader</font><font color="#E5E5E5"> election</font>

675
00:31:15,200 --> 00:31:24,000
process<font color="#E5E5E5"> this can also</font><font color="#CCCCCC"> hurts</font><font color="#E5E5E5"> availability</font>

676
00:31:18,570 --> 00:31:27,120
in some cases so and this<font color="#CCCCCC"> is it</font><font color="#E5E5E5"> for raft</font>

677
00:31:24,000 --> 00:31:30,020
<font color="#CCCCCC">and for everything I've said was</font>

678
00:31:27,120 --> 00:31:33,459
applying to single key transactions<font color="#E5E5E5"> as</font>

679
00:31:30,020 --> 00:31:33,460
[Music]

680
00:31:34,100 --> 00:31:38,689
as a show to the user<font color="#CCCCCC"> as</font><font color="#E5E5E5"> in the form of</font>

681
00:31:37,950 --> 00:31:41,760
all the blue team

682
00:31:38,690 --> 00:31:44,280
however LWT has another important

683
00:31:41,760 --> 00:31:47,700
constraint which is<font color="#E5E5E5"> it has consistently</font>

684
00:31:44,280 --> 00:31:49,649
poll that says the transaction<font color="#CCCCCC"> should</font>

685
00:31:47,700 --> 00:31:52,850
<font color="#E5E5E5">only apply within a particular data</font>

686
00:31:49,650 --> 00:31:56,970
center this means that our ref groups

687
00:31:52,850 --> 00:31:59,340
cannot contain replicas<font color="#E5E5E5"> from multiple</font>

688
00:31:56,970 --> 00:32:02,040
data<font color="#E5E5E5"> centers</font><font color="#CCCCCC"> it means instead</font><font color="#E5E5E5"> that each</font>

689
00:31:59,340 --> 00:32:03,570
data<font color="#E5E5E5"> center has its own ref groups so</font>

690
00:32:02,040 --> 00:32:05,100
now we are left with the other problem

691
00:32:03,570 --> 00:32:06,480
because there's also<font color="#E5E5E5"> consistent level</font>

692
00:32:05,100 --> 00:32:09,510
that says the transaction<font color="#CCCCCC"> should apply</font>

693
00:32:06,480 --> 00:32:11,610
across all data centers<font color="#CCCCCC"> so now we</font><font color="#E5E5E5"> need</font>

694
00:32:09,510 --> 00:32:16,379
<font color="#E5E5E5">to have some sort of way to</font><font color="#CCCCCC"> coordinate</font>

695
00:32:11,610 --> 00:32:18,990
among<font color="#CCCCCC"> rest groups this is a more work</font>

696
00:32:16,380 --> 00:32:20,970
upfront to support<font color="#E5E5E5"> a</font><font color="#CCCCCC"> local team but it's</font>

697
00:32:18,990 --> 00:32:24,270
actually a subset of what is needed to

698
00:32:20,970 --> 00:32:26,880
support<font color="#E5E5E5"> multi key transactions so the</font>

699
00:32:24,270 --> 00:32:28,879
way we solve<font color="#E5E5E5"> this is by layering an</font>

700
00:32:26,880 --> 00:32:33,900
agreement protocol like two-phase commit

701
00:32:28,880 --> 00:32:36,930
on top of raft groups other databases

702
00:32:33,900 --> 00:32:40,910
like cockroach DB and it is so it's a

703
00:32:36,930 --> 00:32:45,480
typical<font color="#E5E5E5"> two-phase commit implementation</font>

704
00:32:40,910 --> 00:32:47,880
with the benefit<font color="#E5E5E5"> of all of the</font>

705
00:32:45,480 --> 00:32:51,030
participants like<font color="#CCCCCC"> resource</font><font color="#E5E5E5"> managers</font><font color="#CCCCCC"> or</font>

706
00:32:47,880 --> 00:32:53,280
<font color="#CCCCCC">the coordinator or</font><font color="#E5E5E5"> the notes that are</font>

707
00:32:51,030 --> 00:32:55,260
going<font color="#E5E5E5"> to hold a transaction status being</font>

708
00:32:53,280 --> 00:32:58,470
fully replicated and fault<font color="#CCCCCC"> tolerant</font>

709
00:32:55,260 --> 00:33:03,000
because they form<font color="#CCCCCC"> raft groups</font><font color="#E5E5E5"> I'm not</font>

710
00:32:58,470 --> 00:33:04,710
going to go into details it's typical

711
00:33:03,000 --> 00:33:06,720
two-phase commit with additional<font color="#CCCCCC"> or</font>

712
00:33:04,710 --> 00:33:12,279
fault<font color="#E5E5E5"> tolerance</font>

713
00:33:06,720 --> 00:33:14,620
so I've spoken<font color="#E5E5E5"> about how external users</font>

714
00:33:12,279 --> 00:33:16,750
can benefit<font color="#CCCCCC"> from strong</font><font color="#E5E5E5"> consistency but</font>

715
00:33:14,620 --> 00:33:19,029
the database itself<font color="#E5E5E5"> can also benefit</font>

716
00:33:16,750 --> 00:33:22,450
from<font color="#E5E5E5"> it one</font><font color="#CCCCCC"> example are concurrent</font>

717
00:33:19,029 --> 00:33:25,360
schema changes<font color="#CCCCCC"> so today schema change</font><font color="#E5E5E5"> is</font>

718
00:33:22,450 --> 00:33:27,640
carried out locally whatever<font color="#E5E5E5"> replica the</font>

719
00:33:25,360 --> 00:33:29,799
client contacted and then propagated

720
00:33:27,640 --> 00:33:32,140
<font color="#E5E5E5">throughout the cluster</font><font color="#CCCCCC"> this means</font><font color="#E5E5E5"> that</font>

721
00:33:29,799 --> 00:33:35,620
we don't<font color="#E5E5E5"> have any</font><font color="#CCCCCC"> protection against</font>

722
00:33:32,140 --> 00:33:39,220
<font color="#E5E5E5">current schema changes or changes that</font>

723
00:33:35,620 --> 00:33:41,729
<font color="#E5E5E5">are done in incompatible orders so for</font>

724
00:33:39,220 --> 00:33:43,929
example if I'm trying<font color="#E5E5E5"> to create</font><font color="#CCCCCC"> a table</font>

725
00:33:41,730 --> 00:33:47,169
on<font color="#E5E5E5"> one side on</font><font color="#CCCCCC"> the other</font><font color="#E5E5E5"> side I'm trying</font>

726
00:33:43,929 --> 00:33:49,870
<font color="#E5E5E5">to drop a user type that's used in that</font>

727
00:33:47,169 --> 00:33:52,360
<font color="#E5E5E5">table</font><font color="#CCCCCC"> and there's really no way to</font><font color="#E5E5E5"> order</font>

728
00:33:49,870 --> 00:33:53,860
<font color="#E5E5E5">these two operations</font><font color="#CCCCCC"> and because they</font>

729
00:33:52,360 --> 00:33:55,418
are concurrent<font color="#E5E5E5"> there's really no way to</font>

730
00:33:53,860 --> 00:33:59,469
provide<font color="#E5E5E5"> a good error message to</font><font color="#CCCCCC"> the user</font>

731
00:33:55,419 --> 00:34:03,840
<font color="#CCCCCC">so this is</font><font color="#E5E5E5"> just going</font><font color="#CCCCCC"> to be I mean</font>

732
00:33:59,470 --> 00:34:09,399
errors you know in the<font color="#E5E5E5"> logs later</font>

733
00:34:03,840 --> 00:34:11,619
however<font color="#E5E5E5"> if we say</font><font color="#CCCCCC"> that if we partition</font>

734
00:34:09,399 --> 00:34:13,899
our key spaces like the key space<font color="#E5E5E5"> name</font>

735
00:34:11,619 --> 00:34:15,909
if we<font color="#E5E5E5"> partition that into the cluster</font>

736
00:34:13,899 --> 00:34:18,580
<font color="#E5E5E5">then we're going</font><font color="#CCCCCC"> to find</font><font color="#E5E5E5"> we're going to</font>

737
00:34:15,909 --> 00:34:21,460
reach a ref<font color="#CCCCCC"> Rupe that can be responsible</font>

738
00:34:18,580 --> 00:34:24,730
<font color="#E5E5E5">for all operations for that</font><font color="#CCCCCC"> key space</font>

739
00:34:21,460 --> 00:34:26,740
<font color="#E5E5E5">and once we have that</font><font color="#CCCCCC"> then we</font><font color="#E5E5E5"> have you</font>

740
00:34:24,730 --> 00:34:28,839
can use LWT when you are when we are

741
00:34:26,739 --> 00:34:31,449
internally when we are applying schema

742
00:34:28,839 --> 00:34:34,060
changes so that<font color="#E5E5E5"> they all go</font><font color="#CCCCCC"> through the</font>

743
00:34:31,449 --> 00:34:36,368
same<font color="#CCCCCC"> leader and then they are orders and</font>

744
00:34:34,060 --> 00:34:40,389
we can provide nice error messages to

745
00:34:36,369 --> 00:34:46,750
the users<font color="#E5E5E5"> another thing our</font><font color="#CCCCCC"> arrange</font>

746
00:34:40,389 --> 00:34:48,550
movements so currently we can't really

747
00:34:46,750 --> 00:34:50,980
<font color="#E5E5E5">have concurrent strange movements we can</font>

748
00:34:48,550 --> 00:34:53,369
add more<font color="#E5E5E5"> than one</font><font color="#CCCCCC"> node at a time because</font>

749
00:34:50,980 --> 00:34:57,790
<font color="#E5E5E5">they can pick conflicting token ranges</font>

750
00:34:53,369 --> 00:34:59,290
and<font color="#E5E5E5"> when everyone knows and</font><font color="#CCCCCC"> joins the</font>

751
00:34:57,790 --> 00:35:01,029
closer and picks whatever token of

752
00:34:59,290 --> 00:35:05,980
interesting ones<font color="#CCCCCC"> it will do so</font><font color="#E5E5E5"> randomly</font>

753
00:35:01,030 --> 00:35:09,430
<font color="#CCCCCC">so it's not really optimal so what we</font>

754
00:35:05,980 --> 00:35:13,599
want to have is a strongly consistent

755
00:35:09,430 --> 00:35:15,430
<font color="#E5E5E5">way of ensuring that when you're reading</font>

756
00:35:13,599 --> 00:35:17,859
and you knows<font color="#E5E5E5"> that we</font><font color="#CCCCCC"> actually give it</font>

757
00:35:15,430 --> 00:35:18,440
<font color="#E5E5E5">whatever token Rangers will be best for</font>

758
00:35:17,859 --> 00:35:20,270
the system

759
00:35:18,440 --> 00:35:22,549
I can can see which notes are more

760
00:35:20,270 --> 00:35:29,030
overloaded and take<font color="#CCCCCC"> rangers away from</font>

761
00:35:22,549 --> 00:35:31,490
<font color="#CCCCCC">them</font><font color="#E5E5E5"> and give them</font><font color="#CCCCCC"> to the new note it</font>

762
00:35:29,030 --> 00:35:33,950
also means that we<font color="#CCCCCC"> can tell</font><font color="#E5E5E5"> the system</font>

763
00:35:31,490 --> 00:35:38,479
that<font color="#E5E5E5"> we want</font><font color="#CCCCCC"> to add many notes at the</font>

764
00:35:33,950 --> 00:35:41,180
same time and the<font color="#E5E5E5"> system can pick tokens</font>

765
00:35:38,480 --> 00:35:44,920
<font color="#E5E5E5">in a way that will</font><font color="#CCCCCC"> make those operations</font>

766
00:35:41,180 --> 00:35:48,259
<font color="#E5E5E5">actually</font><font color="#CCCCCC"> be able</font><font color="#E5E5E5"> to proceed concurrently</font>

767
00:35:44,920 --> 00:35:51,500
<font color="#E5E5E5">of course they wouldn't be</font><font color="#CCCCCC"> able</font><font color="#E5E5E5"> to it's</font>

768
00:35:48,260 --> 00:35:53,299
been the same ref groups<font color="#E5E5E5"> but you can</font>

769
00:35:51,500 --> 00:35:55,700
<font color="#CCCCCC">quit the</font><font color="#E5E5E5"> better than</font><font color="#CCCCCC"> then what we have</font>

770
00:35:53,299 --> 00:35:57,619
<font color="#E5E5E5">now and the</font><font color="#CCCCCC"> only</font><font color="#E5E5E5"> things that we can use</font>

771
00:35:55,700 --> 00:35:59,299
<font color="#CCCCCC">the same partitioning approach that we</font>

772
00:35:57,619 --> 00:36:02,150
could be is<font color="#E5E5E5"> for schema updates because</font>

773
00:35:59,299 --> 00:36:04,240
<font color="#CCCCCC">if picking a token is a centralized</font>

774
00:36:02,150 --> 00:36:06,859
decision<font color="#E5E5E5"> it applies to the whole cluster</font>

775
00:36:04,240 --> 00:36:09,410
so we could do one<font color="#CCCCCC"> of two things</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> can</font>

776
00:36:06,859 --> 00:36:11,240
have a<font color="#E5E5E5"> global group we can say all nodes</font>

777
00:36:09,410 --> 00:36:13,788
<font color="#E5E5E5">in the system belong to C</font><font color="#CCCCCC"> or</font><font color="#E5E5E5"> F group</font>

778
00:36:11,240 --> 00:36:17,089
which is simple that has many

779
00:36:13,789 --> 00:36:19,309
disadvantages<font color="#CCCCCC"> or we could say that the</font>

780
00:36:17,089 --> 00:36:22,460
ref loop that coordinates<font color="#CCCCCC"> Buster</font><font color="#E5E5E5"> range</font>

781
00:36:19,309 --> 00:36:25,609
movements is formed by very<font color="#E5E5E5"> specific</font>

782
00:36:22,460 --> 00:36:29,240
<font color="#CCCCCC">nodes so we can say</font><font color="#E5E5E5"> that the signals the</font>

783
00:36:25,609 --> 00:36:31,160
ones that everyone knows about<font color="#E5E5E5"> are the</font>

784
00:36:29,240 --> 00:36:35,479
<font color="#E5E5E5">ones that form this ref group that</font>

785
00:36:31,160 --> 00:36:42,129
controls<font color="#E5E5E5"> range movements and token</font>

786
00:36:35,480 --> 00:36:46,609
ownership finally materialized views

787
00:36:42,130 --> 00:36:49,670
this materialized view is derived table

788
00:36:46,609 --> 00:36:53,029
<font color="#E5E5E5">from some base table it is typically</font>

789
00:36:49,670 --> 00:36:54,980
used<font color="#CCCCCC"> to</font><font color="#E5E5E5"> index a column out of the base</font>

790
00:36:53,029 --> 00:36:58,180
table but it is<font color="#E5E5E5"> different than a</font>

791
00:36:54,980 --> 00:37:00,849
secondary index<font color="#E5E5E5"> because you can actually</font>

792
00:36:58,180 --> 00:37:02,499
do you normalize data in it so you<font color="#E5E5E5"> can</font>

793
00:37:00,849 --> 00:37:06,160
include in a materialized view<font color="#E5E5E5"> many</font>

794
00:37:02,499 --> 00:37:08,140
columns<font color="#E5E5E5"> from the base table</font><font color="#CCCCCC"> at</font>

795
00:37:06,160 --> 00:37:10,240
<font color="#E5E5E5">materialized view is handled by a</font>

796
00:37:08,140 --> 00:37:13,328
totally different set of nodes than the

797
00:37:10,240 --> 00:37:15,700
base table<font color="#E5E5E5"> and it cannot be written to</font>

798
00:37:13,329 --> 00:37:19,059
directly<font color="#E5E5E5"> so when a base table is updated</font>

799
00:37:15,700 --> 00:37:21,249
<font color="#CCCCCC">the database</font><font color="#E5E5E5"> will processes of this as</font>

800
00:37:19,059 --> 00:37:22,539
well will calculate the view updates

801
00:37:21,249 --> 00:37:23,980
<font color="#E5E5E5">that are needed</font><font color="#CCCCCC"> to update the</font>

802
00:37:22,539 --> 00:37:25,859
materialized views and are going<font color="#E5E5E5"> to send</font>

803
00:37:23,980 --> 00:37:29,349
<font color="#E5E5E5">it</font><font color="#CCCCCC"> to the view replicas</font>

804
00:37:25,859 --> 00:37:31,660
it does so in the<font color="#CCCCCC"> background and in an</font>

805
00:37:29,349 --> 00:37:33,940
eventually consistent<font color="#E5E5E5"> fashion</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> has</font>

806
00:37:31,660 --> 00:37:36,609
the advantage<font color="#E5E5E5"> of preserving base table</font>

807
00:37:33,940 --> 00:37:38,890
availability so if one<font color="#E5E5E5"> of the view</font>

808
00:37:36,609 --> 00:37:41,049
replicas is down or all of the view

809
00:37:38,890 --> 00:37:43,480
replicas<font color="#E5E5E5"> are down the base</font><font color="#CCCCCC"> ride is still</font>

810
00:37:41,049 --> 00:37:45,339
<font color="#E5E5E5">going to succeed and we're just going</font><font color="#CCCCCC"> to</font>

811
00:37:43,480 --> 00:37:50,200
accumulate<font color="#E5E5E5"> in memory depending view</font>

812
00:37:45,339 --> 00:37:52,299
<font color="#CCCCCC">updates this</font><font color="#E5E5E5"> can be a</font><font color="#CCCCCC"> problem because of</font>

813
00:37:50,200 --> 00:37:55,828
<font color="#E5E5E5">two reasons when we can have issues with</font>

814
00:37:52,299 --> 00:37:59,380
consistency<font color="#E5E5E5"> with keeping the views</font>

815
00:37:55,829 --> 00:38:01,809
<font color="#CCCCCC">up-to-date with</font><font color="#E5E5E5"> the base tables and it</font>

816
00:37:59,380 --> 00:38:03,430
also means<font color="#E5E5E5"> we can</font><font color="#CCCCCC"> have issues</font><font color="#E5E5E5"> with flow</font>

817
00:38:01,809 --> 00:38:06,160
control all of those pending view

818
00:38:03,430 --> 00:38:08,200
<font color="#CCCCCC">updates in the base notes can start to</font>

819
00:38:06,160 --> 00:38:10,359
take over<font color="#E5E5E5"> all the memory and then we</font>

820
00:38:08,200 --> 00:38:13,618
need a distributed flow control solution

821
00:38:10,359 --> 00:38:15,700
so we are<font color="#CCCCCC"> able to</font><font color="#E5E5E5"> communicate that</font>

822
00:38:13,619 --> 00:38:17,440
resource pressure over to the

823
00:38:15,700 --> 00:38:22,089
coordinator node which in turn is able

824
00:38:17,440 --> 00:38:26,019
to slow down the client it becomes very

825
00:38:22,089 --> 00:38:29,558
complex with multi key transaction<font color="#E5E5E5"> we</font>

826
00:38:26,019 --> 00:38:32,169
could instead specify that the base

827
00:38:29,559 --> 00:38:33,819
table be updated together with the<font color="#E5E5E5"> view</font>

828
00:38:32,170 --> 00:38:36,549
table<font color="#E5E5E5"> in the context of a single</font>

829
00:38:33,819 --> 00:38:39,069
<font color="#E5E5E5">transaction this will ensure that they</font>

830
00:38:36,549 --> 00:38:42,369
are<font color="#E5E5E5"> kept always consistent with each</font>

831
00:38:39,069 --> 00:38:45,910
other<font color="#CCCCCC"> and would provide natural</font><font color="#E5E5E5"> back</font>

832
00:38:42,369 --> 00:38:48,579
pressure from the view replicas and<font color="#E5E5E5"> base</font>

833
00:38:45,910 --> 00:38:53,710
<font color="#E5E5E5">replicas to</font><font color="#CCCCCC"> the client and this will of</font>

834
00:38:48,579 --> 00:38:56,519
course have to be<font color="#CCCCCC"> opted in and because</font>

835
00:38:53,710 --> 00:38:59,680
it will come as a<font color="#CCCCCC"> data performance</font><font color="#E5E5E5"> cost</font>

836
00:38:56,519 --> 00:39:01,118
and that's<font color="#E5E5E5"> it</font><font color="#CCCCCC"> and that's all</font><font color="#E5E5E5"> I have</font><font color="#CCCCCC"> on</font>

837
00:38:59,680 --> 00:39:03,390
the subject<font color="#CCCCCC"> so if you have any questions</font>

838
00:39:01,119 --> 00:39:11,410
I'll take them<font color="#E5E5E5"> out thank you</font>

839
00:39:03,390 --> 00:39:14,410
[Applause]

840
00:39:11,410 --> 00:39:14,410
<font color="#E5E5E5">okay</font>

841
00:39:27,300 --> 00:39:40,630
so the question is how we<font color="#E5E5E5"> support</font>

842
00:39:31,930 --> 00:39:42,129
multiple workloads<font color="#E5E5E5"> okay so how do we</font>

843
00:39:40,630 --> 00:39:45,910
apply<font color="#E5E5E5"> the help I'm walking by having a</font>

844
00:39:42,130 --> 00:39:48,340
slow<font color="#CCCCCC"> shower</font><font color="#E5E5E5"> so the question</font><font color="#CCCCCC"> to that or</font>

845
00:39:45,910 --> 00:39:49,930
the problem is similar<font color="#E5E5E5"> to how it is</font>

846
00:39:48,340 --> 00:39:51,550
handled by having different<font color="#CCCCCC"> notes</font><font color="#E5E5E5"> if you</font>

847
00:39:49,930 --> 00:39:54,220
have a slow<font color="#E5E5E5"> note</font>

848
00:39:51,550 --> 00:39:56,380
<font color="#CCCCCC">Ruben's have the same problem and the</font>

849
00:39:54,220 --> 00:39:59,439
way that it solves is by better data

850
00:39:56,380 --> 00:40:02,350
partitioning so if the way you<font color="#CCCCCC"> select</font>

851
00:39:59,440 --> 00:40:06,700
<font color="#E5E5E5">your partition key is</font><font color="#CCCCCC"> picking hot nodes</font>

852
00:40:02,350 --> 00:40:08,618
then you're going to<font color="#E5E5E5"> have to employ a</font>

853
00:40:06,700 --> 00:40:11,109
different<font color="#E5E5E5"> partition key the same thing</font>

854
00:40:08,619 --> 00:40:12,700
happens<font color="#E5E5E5"> with shards so with partition</font>

855
00:40:11,110 --> 00:40:15,220
<font color="#E5E5E5">key is going to</font><font color="#CCCCCC"> ensure that all shards</font>

856
00:40:12,700 --> 00:40:17,290
are balanced and then her roughly<font color="#E5E5E5"> the</font>

857
00:40:15,220 --> 00:40:18,850
same<font color="#CCCCCC"> amount of work</font><font color="#E5E5E5"> if you have a hot</font>

858
00:40:17,290 --> 00:40:20,259
chart then there's<font color="#E5E5E5"> not much we can do</font>

859
00:40:18,850 --> 00:40:23,410
about<font color="#CCCCCC"> it it's like having a hot node and</font>

860
00:40:20,260 --> 00:40:27,300
so<font color="#E5E5E5"> to the user to tweak the partition</font>

861
00:40:23,410 --> 00:40:27,299
<font color="#CCCCCC">okay make sense</font>

862
00:40:36,490 --> 00:40:41,890
No so I didn't<font color="#CCCCCC"> mention that</font><font color="#E5E5E5"> but when I</font>

863
00:40:40,359 --> 00:40:43,990
<font color="#E5E5E5">was showing the request path and we were</font>

864
00:40:41,890 --> 00:40:46,000
taking walks<font color="#E5E5E5"> so there's an opportunity</font>

865
00:40:43,990 --> 00:40:48,310
<font color="#E5E5E5">to allow</font><font color="#CCCCCC"> a lot</font><font color="#E5E5E5"> of concurrency there so</font>

866
00:40:46,000 --> 00:40:49,990
if we're<font color="#CCCCCC"> talking</font><font color="#E5E5E5"> about different</font><font color="#CCCCCC"> keys</font>

867
00:40:48,310 --> 00:40:50,740
<font color="#E5E5E5">and they will take different</font><font color="#CCCCCC"> walks and</font>

868
00:40:49,990 --> 00:40:57,160
they will be<font color="#E5E5E5"> able to progress</font>

869
00:40:50,740 --> 00:40:57,848
independently<font color="#E5E5E5"> we've seen you know any</font>

870
00:40:57,160 --> 00:41:05,230
other<font color="#E5E5E5"> questions</font>

871
00:40:57,849 --> 00:41:07,270
<font color="#CCCCCC">I don't</font><font color="#E5E5E5"> think so</font><font color="#CCCCCC"> okay thank you</font>

872
00:41:05,230 --> 00:41:08,010
[Applause]

873
00:41:07,270 --> 00:41:13,299
[Music]

874
00:41:08,010 --> 00:41:13,299
[Applause]

