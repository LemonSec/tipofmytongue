1
00:00:18,449 --> 00:00:40,829
<font color="#E5E5E5">Yanik</font><font color="#CCCCCC"> boys</font><font color="#E5E5E5"> of yes so I hope you'll agree</font>

2
00:00:38,670 --> 00:00:42,810
<font color="#E5E5E5">with</font><font color="#CCCCCC"> me that there's no</font><font color="#E5E5E5"> best way to end</font>

3
00:00:40,829 --> 00:00:47,220
up such a long day than with pointer

4
00:00:42,810 --> 00:00:49,260
analysis<font color="#CCCCCC"> at least</font><font color="#E5E5E5"> at</font><font color="#CCCCCC"> least I'm very</font>

5
00:00:47,220 --> 00:00:51,149
<font color="#CCCCCC">excited by this project</font><font color="#E5E5E5"> when I join a</font>

6
00:00:49,260 --> 00:00:53,760
decor ten years ago<font color="#E5E5E5"> to start working on</font>

7
00:00:51,149 --> 00:00:56,790
<font color="#E5E5E5">sparked</font><font color="#CCCCCC"> I had</font><font color="#E5E5E5"> previously been working on</font>

8
00:00:53,760 --> 00:00:58,649
the analysis of C++<font color="#E5E5E5"> C at say require</font>

9
00:00:56,790 --> 00:01:01,950
<font color="#E5E5E5">I've also</font><font color="#CCCCCC"> worked on</font><font color="#E5E5E5"> energies</font><font color="#CCCCCC"> fader and</font>

10
00:00:58,649 --> 00:01:03,480
in all these<font color="#CCCCCC"> languages pointers end up</font>

11
00:01:01,950 --> 00:01:06,750
being a nightmare

12
00:01:03,480 --> 00:01:10,408
and finally we spark<font color="#E5E5E5"> we add the language</font>

13
00:01:06,750 --> 00:01:12,569
<font color="#E5E5E5">which could be analyzed</font><font color="#CCCCCC"> but it was</font>

14
00:01:10,409 --> 00:01:16,049
always like<font color="#CCCCCC"> this small stone in your</font>

15
00:01:12,569 --> 00:01:19,259
shoe<font color="#CCCCCC"> that's you cannot use pointers in</font>

16
00:01:16,049 --> 00:01:21,299
<font color="#E5E5E5">Spock</font><font color="#CCCCCC"> and so we always had</font><font color="#E5E5E5"> to look for</font>

17
00:01:19,259 --> 00:01:24,029
that<font color="#CCCCCC"> and since the last two</font><font color="#E5E5E5"> years we've</font>

18
00:01:21,299 --> 00:01:26,219
been<font color="#CCCCCC"> working in adding some support for</font>

19
00:01:24,029 --> 00:01:29,850
pointers in spoken<font color="#E5E5E5"> I'm going to dig into</font>

20
00:01:26,219 --> 00:01:33,389
<font color="#E5E5E5">that so what is part first</font><font color="#CCCCCC"> it's a subset</font>

21
00:01:29,850 --> 00:01:35,699
<font color="#E5E5E5">of</font><font color="#CCCCCC"> Veda</font><font color="#E5E5E5"> but it's not like other subsets</font>

22
00:01:33,389 --> 00:01:38,579
just<font color="#CCCCCC"> opening standard</font><font color="#E5E5E5"> so it's a subset</font>

23
00:01:35,700 --> 00:01:40,380
get that provides you warranties<font color="#E5E5E5"> when</font>

24
00:01:38,579 --> 00:01:41,969
you use the associated tools<font color="#E5E5E5"> so the</font>

25
00:01:40,380 --> 00:01:44,848
<font color="#CCCCCC">formula analysis tools that</font><font color="#E5E5E5"> come with</font>

26
00:01:41,969 --> 00:01:47,339
spark which we call that<font color="#CCCCCC"> proof and you</font>

27
00:01:44,849 --> 00:01:50,130
can go up to<font color="#CCCCCC"> the full functional</font>

28
00:01:47,340 --> 00:01:53,579
correctness of usually small parts<font color="#E5E5E5"> of</font>

29
00:01:50,130 --> 00:01:55,708
the codes from something much simpler to

30
00:01:53,579 --> 00:01:57,779
<font color="#E5E5E5">achieve which is cementing cutting</font>

31
00:01:55,709 --> 00:01:59,999
<font color="#CCCCCC">stirrer</font><font color="#E5E5E5"> giving you good warranties</font><font color="#CCCCCC"> about</font>

32
00:01:57,779 --> 00:02:02,189
the code like no<font color="#CCCCCC"> side-effects</font><font color="#E5E5E5"> in</font>

33
00:01:59,999 --> 00:02:04,949
functions no use of pointers precisely

34
00:02:02,189 --> 00:02:06,898
and if you go up<font color="#E5E5E5"> between these two you</font>

35
00:02:04,950 --> 00:02:09,770
have here what<font color="#CCCCCC"> we call the bronze</font><font color="#E5E5E5"> level</font>

36
00:02:06,899 --> 00:02:11,670
which provides you warranties about

37
00:02:09,770 --> 00:02:15,290
initialization<font color="#E5E5E5"> of</font><font color="#CCCCCC"> the data that</font><font color="#E5E5E5"> you read</font>

38
00:02:11,670 --> 00:02:18,209
and correct<font color="#E5E5E5"> data flows and no aliasing</font>

39
00:02:15,290 --> 00:02:20,130
at civil level<font color="#E5E5E5"> that's about</font>

40
00:02:18,210 --> 00:02:22,470
<font color="#CCCCCC">absence of run timers so that's a big</font>

41
00:02:20,130 --> 00:02:24,630
<font color="#E5E5E5">deal that's where</font><font color="#CCCCCC"> you've</font><font color="#E5E5E5"> got the buffer</font>

42
00:02:22,470 --> 00:02:27,630
<font color="#CCCCCC">overflow</font><font color="#E5E5E5"> integer overflows all these</font>

43
00:02:24,630 --> 00:02:29,670
kind of<font color="#CCCCCC"> overflows and other</font><font color="#E5E5E5"> runtime</font>

44
00:02:27,630 --> 00:02:32,970
errors that are<font color="#E5E5E5"> at risk for safety and</font>

45
00:02:29,670 --> 00:02:34,739
<font color="#CCCCCC">security</font><font color="#E5E5E5"> and that gold it's where you</font>

46
00:02:32,970 --> 00:02:36,060
start<font color="#E5E5E5"> really proving property so when</font>

47
00:02:34,740 --> 00:02:37,709
you use<font color="#CCCCCC"> your contract</font><font color="#E5E5E5"> not only for</font>

48
00:02:36,060 --> 00:02:41,100
dynamic graph<font color="#CCCCCC"> occasion but you start</font>

49
00:02:37,709 --> 00:02:44,730
proving<font color="#E5E5E5"> in type invariants programming</font>

50
00:02:41,100 --> 00:02:46,650
contracts so the more you go up<font color="#E5E5E5"> the</font>

51
00:02:44,730 --> 00:02:49,890
harder it is for the tool and for the

52
00:02:46,650 --> 00:02:53,250
user<font color="#E5E5E5"> but hopefully the tool helps</font><font color="#CCCCCC"> you go</font>

53
00:02:49,890 --> 00:02:55,859
up this<font color="#CCCCCC"> gap</font><font color="#E5E5E5"> so why didn't we use</font>

54
00:02:53,250 --> 00:02:58,230
pointers<font color="#CCCCCC"> until now</font><font color="#E5E5E5"> because that's the</font>

55
00:02:55,860 --> 00:02:59,940
view<font color="#E5E5E5"> of</font><font color="#CCCCCC"> pointers for spark</font><font color="#E5E5E5"> that's the</font>

56
00:02:58,230 --> 00:03:02,040
view in<font color="#E5E5E5"> fact of pointers for analysis if</font>

57
00:02:59,940 --> 00:03:04,680
you want to do sound analysis where<font color="#CCCCCC"> you</font>

58
00:03:02,040 --> 00:03:07,140
don't miss any errors<font color="#CCCCCC"> that's the view of</font>

59
00:03:04,680 --> 00:03:09,090
<font color="#E5E5E5">the complexity of using pointers because</font>

60
00:03:07,140 --> 00:03:11,609
yeah<font color="#CCCCCC"> you can end up with this mesh</font><font color="#E5E5E5"> but</font>

61
00:03:09,090 --> 00:03:14,640
<font color="#E5E5E5">also of all the traps</font><font color="#CCCCCC"> that pointers</font><font color="#E5E5E5"> lead</font>

62
00:03:11,610 --> 00:03:16,350
to so you<font color="#CCCCCC"> Eneida that's as point full</font>

63
00:03:14,640 --> 00:03:18,630
point of support<font color="#E5E5E5"> you</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> end</font><font color="#CCCCCC"> up with</font>

64
00:03:16,350 --> 00:03:22,920
double<font color="#CCCCCC"> freak</font><font color="#E5E5E5"> and end up with memory</font>

65
00:03:18,630 --> 00:03:26,940
leaks you can end up with pointers that

66
00:03:22,920 --> 00:03:28,829
point<font color="#E5E5E5"> to the allocated memory and there</font>

67
00:03:26,940 --> 00:03:31,799
are a number of concepts in<font color="#CCCCCC"> ADA features</font>

68
00:03:28,830 --> 00:03:34,170
that help you avoid these<font color="#E5E5E5"> these problems</font>

69
00:03:31,799 --> 00:03:37,860
but still with uncheck the location so

70
00:03:34,170 --> 00:03:42,720
the ADA<font color="#CCCCCC"> name for free you have all of</font>

71
00:03:37,860 --> 00:03:45,870
<font color="#E5E5E5">these so there are uses for pointers in</font>

72
00:03:42,720 --> 00:03:47,700
<font color="#E5E5E5">spark in particular when you have some</font>

73
00:03:45,870 --> 00:03:50,400
data<font color="#E5E5E5"> structures that's need pointers</font>

74
00:03:47,700 --> 00:03:52,980
because<font color="#CCCCCC"> they need</font><font color="#E5E5E5"> to grow for example</font><font color="#CCCCCC"> so</font>

75
00:03:50,400 --> 00:03:55,470
that's typical<font color="#CCCCCC"> for containers that don't</font>

76
00:03:52,980 --> 00:03:58,590
have a fixed size because they have

77
00:03:55,470 --> 00:04:00,570
elements that can't have<font color="#E5E5E5"> define</font><font color="#CCCCCC"> compiled</font>

78
00:03:58,590 --> 00:04:03,890
size so first of all<font color="#E5E5E5"> strings or any</font>

79
00:04:00,570 --> 00:04:06,780
indefinite<font color="#E5E5E5"> type in</font><font color="#CCCCCC"> Ada that you must</font>

80
00:04:03,890 --> 00:04:09,600
point to that's the same for<font color="#E5E5E5"> class wide</font>

81
00:04:06,780 --> 00:04:12,120
types of the objects in<font color="#CCCCCC"> ADA</font><font color="#E5E5E5"> that we that</font>

82
00:04:09,600 --> 00:04:13,620
were mentioned<font color="#E5E5E5"> before all because you</font>

83
00:04:12,120 --> 00:04:16,140
have a regular data type so if you want

84
00:04:13,620 --> 00:04:18,000
to have your own<font color="#E5E5E5"> list or</font><font color="#CCCCCC"> tree or</font><font color="#E5E5E5"> similar</font>

85
00:04:16,140 --> 00:04:21,839
recursive<font color="#E5E5E5"> data type you need to use</font>

86
00:04:18,000 --> 00:04:24,840
parts<font color="#E5E5E5"> so what changes with the ownership</font>

87
00:04:21,839 --> 00:04:26,429
so this concept that has been<font color="#E5E5E5"> used in</font>

88
00:04:24,840 --> 00:04:26,880
other languages the most<font color="#CCCCCC"> famous being</font>

89
00:04:26,430 --> 00:04:28,800
<font color="#E5E5E5">rust</font>

90
00:04:26,880 --> 00:04:30,930
what changes with<font color="#E5E5E5"> ownership is that it</font>

91
00:04:28,800 --> 00:04:33,270
<font color="#E5E5E5">brings this</font><font color="#CCCCCC"> these greats</font>

92
00:04:30,930 --> 00:04:35,790
<font color="#CCCCCC">Kru solutions so concurrent read</font>

93
00:04:33,270 --> 00:04:37,979
exclusive rights which is<font color="#E5E5E5"> exactly what</font>

94
00:04:35,790 --> 00:04:40,080
you<font color="#CCCCCC"> need to analyze good</font><font color="#E5E5E5"> so that's what</font>

95
00:04:37,980 --> 00:04:41,419
already<font color="#CCCCCC"> we're using in spark for</font>

96
00:04:40,080 --> 00:04:45,180
analyzing code<font color="#E5E5E5"> with references</font>

97
00:04:41,419 --> 00:04:47,460
references are these<font color="#CCCCCC"> spatial pointers if</font>

98
00:04:45,180 --> 00:04:48,810
you like so pointers at the executable

99
00:04:47,460 --> 00:04:52,169
level but not at the source code<font color="#CCCCCC"> level</font>

100
00:04:48,810 --> 00:04:56,370
<font color="#E5E5E5">that can be manipulated when you pass</font>

101
00:04:52,169 --> 00:05:00,630
arguments<font color="#E5E5E5"> to a function in out input in</font>

102
00:04:56,370 --> 00:05:02,430
<font color="#E5E5E5">or outputs and in that case that's spark</font>

103
00:05:00,630 --> 00:05:04,440
already analyzes the<font color="#CCCCCC"> calls to</font><font color="#E5E5E5"> make sure</font>

104
00:05:02,430 --> 00:05:06,000
that there is no conflicting<font color="#E5E5E5"> aliasing</font>

105
00:05:04,440 --> 00:05:07,500
between things through which you<font color="#E5E5E5"> will</font>

106
00:05:06,000 --> 00:05:10,139
<font color="#E5E5E5">write so there will be only one writer</font>

107
00:05:07,500 --> 00:05:11,340
<font color="#E5E5E5">in the in the function and if there's</font>

108
00:05:10,139 --> 00:05:14,790
<font color="#CCCCCC">one monitor there won't be any reader</font>

109
00:05:11,340 --> 00:05:16,919
through another path so we<font color="#E5E5E5"> already do</font>

110
00:05:14,790 --> 00:05:18,900
that<font color="#E5E5E5"> in part for references so of course</font>

111
00:05:16,919 --> 00:05:21,450
<font color="#E5E5E5">for pointers we want to do the same same</font>

112
00:05:18,900 --> 00:05:23,789
kind<font color="#E5E5E5"> of non</font><font color="#CCCCCC"> al Azim check with some</font>

113
00:05:21,450 --> 00:05:25,409
addition<font color="#CCCCCC"> because we if</font><font color="#E5E5E5"> you have pointers</font>

114
00:05:23,789 --> 00:05:27,360
you<font color="#E5E5E5"> can assign the pointers all over the</font>

115
00:05:25,410 --> 00:05:29,550
place<font color="#E5E5E5"> so you can create your own local</font>

116
00:05:27,360 --> 00:05:30,990
<font color="#E5E5E5">addresses and this is the kind of thing</font>

117
00:05:29,550 --> 00:05:33,990
we<font color="#E5E5E5"> want to prevent and that's where of</font>

118
00:05:30,990 --> 00:05:36,930
Nashik kicks in so when you<font color="#CCCCCC"> are going to</font>

119
00:05:33,990 --> 00:05:39,770
assign a pointer to<font color="#CCCCCC"> another object</font>

120
00:05:36,930 --> 00:05:43,560
<font color="#CCCCCC">you're going to move the ownership</font><font color="#E5E5E5"> and</font>

121
00:05:39,770 --> 00:05:45,870
if you stop that<font color="#E5E5E5"> use you can do useful</font>

122
00:05:43,560 --> 00:05:47,729
things<font color="#E5E5E5"> but you still</font><font color="#CCCCCC"> stay for example if</font>

123
00:05:45,870 --> 00:05:49,320
you want<font color="#E5E5E5"> to traverse recursive data</font>

124
00:05:47,729 --> 00:05:52,860
structure without<font color="#E5E5E5"> destroying it because</font>

125
00:05:49,320 --> 00:05:56,550
each<font color="#CCCCCC"> time you're</font><font color="#E5E5E5"> going to move your your</font>

126
00:05:52,860 --> 00:05:58,410
current pointer<font color="#CCCCCC"> you're going to</font><font color="#E5E5E5"> destroy</font>

127
00:05:56,550 --> 00:06:00,180
it you need<font color="#CCCCCC"> to take the</font><font color="#E5E5E5"> ownership of the</font>

128
00:05:58,410 --> 00:06:02,340
things you had before<font color="#CCCCCC"> so what you need</font>

129
00:06:00,180 --> 00:06:04,470
<font color="#E5E5E5">for</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> you need some local handles</font>

130
00:06:02,340 --> 00:06:07,710
that will<font color="#E5E5E5"> restore the ownership when</font>

131
00:06:04,470 --> 00:06:10,470
when the scope is finished<font color="#E5E5E5"> so</font><font color="#CCCCCC"> where we</font>

132
00:06:07,710 --> 00:06:13,349
borrow observe the data<font color="#E5E5E5"> that maps to</font><font color="#CCCCCC"> the</font>

133
00:06:10,470 --> 00:06:17,669
rest concept of mutable<font color="#CCCCCC"> burrows or</font>

134
00:06:13,349 --> 00:06:19,349
simple<font color="#E5E5E5"> boards so what's probable with</font>

135
00:06:17,669 --> 00:06:21,450
this pointer on the<font color="#E5E5E5"> ship so we have a</font>

136
00:06:19,349 --> 00:06:23,610
prototype<font color="#E5E5E5"> right</font><font color="#CCCCCC"> now</font><font color="#E5E5E5"> and what you can do</font>

137
00:06:21,450 --> 00:06:27,240
is you<font color="#E5E5E5"> can write this kind of code with</font>

138
00:06:23,610 --> 00:06:29,780
a pointer type that<font color="#E5E5E5"> there is an</font><font color="#CCCCCC"> excess</font>

139
00:06:27,240 --> 00:06:32,940
<font color="#E5E5E5">so that's the way to do it in a</font><font color="#CCCCCC"> DES</font>

140
00:06:29,780 --> 00:06:35,760
pointer to T<font color="#E5E5E5"> and you</font><font color="#CCCCCC"> can implement these</font>

141
00:06:32,940 --> 00:06:38,310
swap contents or swap pointers and so I

142
00:06:35,760 --> 00:06:39,990
don't show the<font color="#E5E5E5"> code of the body but you</font>

143
00:06:38,310 --> 00:06:42,330
can imagine<font color="#CCCCCC"> it very easily swap contents</font>

144
00:06:39,990 --> 00:06:44,370
will swap<font color="#E5E5E5"> what's underneath these two</font>

145
00:06:42,330 --> 00:06:46,289
pointers by differencing<font color="#E5E5E5"> them</font>

146
00:06:44,370 --> 00:06:48,389
and using a temporary verbal and swap

147
00:06:46,290 --> 00:06:50,160
<font color="#E5E5E5">pointers</font><font color="#CCCCCC"> we'll simply swap the actual</font>

148
00:06:48,389 --> 00:06:52,410
values<font color="#CCCCCC"> of x and</font><font color="#E5E5E5"> y that's why swap</font>

149
00:06:50,160 --> 00:06:54,240
contents<font color="#E5E5E5"> takes just input parameters x</font>

150
00:06:52,410 --> 00:06:56,940
and y and swap<font color="#CCCCCC"> wearer's takes</font><font color="#E5E5E5"> in out</font>

151
00:06:54,240 --> 00:07:00,180
<font color="#E5E5E5">because it will</font><font color="#CCCCCC"> change the value of</font>

152
00:06:56,940 --> 00:07:01,830
these of these objects<font color="#E5E5E5"> and so if you put</font>

153
00:07:00,180 --> 00:07:05,310
the<font color="#E5E5E5"> right precondition post condition</font>

154
00:07:01,830 --> 00:07:07,289
here<font color="#E5E5E5"> not only can prove with with the</font>

155
00:07:05,310 --> 00:07:10,530
<font color="#CCCCCC">spark</font><font color="#E5E5E5"> tools and prove that all of these</font>

156
00:07:07,290 --> 00:07:12,810
<font color="#E5E5E5">differences</font><font color="#CCCCCC"> if</font><font color="#E5E5E5"> we need ice dot all to</font>

157
00:07:10,530 --> 00:07:14,638
the reference and object<font color="#E5E5E5"> are safe so the</font>

158
00:07:12,810 --> 00:07:16,950
pointer is not<font color="#CCCCCC"> no and then you can prove</font>

159
00:07:14,639 --> 00:07:19,970
what you usually prove we spark absence

160
00:07:16,950 --> 00:07:22,200
of<font color="#CCCCCC"> the runtime errors in general and</font>

161
00:07:19,970 --> 00:07:24,540
contract so here<font color="#E5E5E5"> that the post condition</font>

162
00:07:22,200 --> 00:07:26,190
holds<font color="#CCCCCC"> so I say they</font><font color="#E5E5E5"> are essentially</font><font color="#CCCCCC"> the</font>

163
00:07:24,540 --> 00:07:29,400
same except here you're repeating<font color="#CCCCCC"> the</font>

164
00:07:26,190 --> 00:07:33,270
non-duality of the arguments<font color="#E5E5E5"> and all</font>

165
00:07:29,400 --> 00:07:35,370
this<font color="#E5E5E5"> because</font><font color="#CCCCCC"> we can assume thanks to the</font>

166
00:07:33,270 --> 00:07:37,799
ownership system<font color="#E5E5E5"> put in place</font>

167
00:07:35,370 --> 00:07:39,900
that's when swap content see<font color="#CCCCCC"> and what</font>

168
00:07:37,800 --> 00:07:42,270
pointers are called<font color="#E5E5E5"> there are respective</font>

169
00:07:39,900 --> 00:07:43,320
arguments are<font color="#CCCCCC"> not honest</font><font color="#E5E5E5"> that's very</font>

170
00:07:42,270 --> 00:07:46,740
important<font color="#CCCCCC"> here otherwise</font><font color="#E5E5E5"> you cannot</font>

171
00:07:43,320 --> 00:07:50,849
verify this this implementation<font color="#E5E5E5"> so</font>

172
00:07:46,740 --> 00:07:52,440
that's what it<font color="#E5E5E5"> does now</font><font color="#CCCCCC"> let's look</font><font color="#E5E5E5"> now</font>

173
00:07:50,850 --> 00:07:54,600
at every<font color="#E5E5E5"> one of these</font><font color="#CCCCCC"> operation that I</font>

174
00:07:52,440 --> 00:07:58,110
mentioned<font color="#E5E5E5"> the move borrow and observe</font>

175
00:07:54,600 --> 00:08:00,349
operations<font color="#CCCCCC"> so the move is when you</font>

176
00:07:58,110 --> 00:08:02,639
assign a pointer<font color="#E5E5E5"> so that's either</font>

177
00:08:00,349 --> 00:08:05,909
assignment statement<font color="#CCCCCC"> or when you passing</font>

178
00:08:02,639 --> 00:08:08,190
<font color="#E5E5E5">and out or in a parameter in in the</font>

179
00:08:05,910 --> 00:08:10,620
procedure<font color="#E5E5E5"> and the thing</font><font color="#CCCCCC"> that you're</font>

180
00:08:08,190 --> 00:08:13,200
signing from<font color="#E5E5E5"> loses the ownership of the</font>

181
00:08:10,620 --> 00:08:14,580
data and becomes unreadable<font color="#CCCCCC"> and the</font>

182
00:08:13,200 --> 00:08:16,620
ownership<font color="#E5E5E5"> goes to the thing you're</font>

183
00:08:14,580 --> 00:08:18,750
signing to so for example the

184
00:08:16,620 --> 00:08:22,830
inflammation of<font color="#E5E5E5"> operators is can be this</font>

185
00:08:18,750 --> 00:08:25,410
<font color="#E5E5E5">one</font><font color="#CCCCCC"> I take a local variable temp here</font>

186
00:08:22,830 --> 00:08:28,919
that takes the ownership<font color="#E5E5E5"> from the value</font>

187
00:08:25,410 --> 00:08:31,020
<font color="#CCCCCC">panja</font><font color="#E5E5E5"> to by X then I can</font><font color="#CCCCCC"> write into X so</font>

188
00:08:28,919 --> 00:08:35,250
I cannot read X but I can write into X

189
00:08:31,020 --> 00:08:37,770
the the value of y and then I can write

190
00:08:35,250 --> 00:08:41,490
in Y the<font color="#CCCCCC"> value of temp</font><font color="#E5E5E5"> that's correct</font>

191
00:08:37,770 --> 00:08:43,740
<font color="#E5E5E5">so now if I make a mistake</font><font color="#CCCCCC"> so for Nepal</font>

192
00:08:41,490 --> 00:08:46,830
here instead<font color="#E5E5E5"> of writing Tampa</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> wire I</font>

193
00:08:43,740 --> 00:08:50,279
write<font color="#E5E5E5"> Y well why was moved already here</font>

194
00:08:46,830 --> 00:08:52,110
so I cannot move it again

195
00:08:50,279 --> 00:08:54,959
<font color="#E5E5E5">it was move into X so I cannot move it</font>

196
00:08:52,110 --> 00:08:56,630
<font color="#CCCCCC">again and and the our board checkers or</font>

197
00:08:54,959 --> 00:08:59,209
<font color="#E5E5E5">our implementation of the</font>

198
00:08:56,630 --> 00:09:01,820
<font color="#E5E5E5">rules in the compiler say that there's</font>

199
00:08:59,210 --> 00:09:04,210
no no sufficient permission for or<font color="#E5E5E5"> for</font>

200
00:09:01,820 --> 00:09:06,770
<font color="#E5E5E5">doing that the object was already moved</font>

201
00:09:04,210 --> 00:09:10,700
if we make<font color="#CCCCCC"> another mistake now so</font>

202
00:09:06,770 --> 00:09:15,290
instead<font color="#CCCCCC"> of</font><font color="#E5E5E5"> moving temp moving X so here</font>

203
00:09:10,700 --> 00:09:17,720
<font color="#E5E5E5">Y was movin X X was moving Y that's not</font>

204
00:09:15,290 --> 00:09:18,949
very<font color="#E5E5E5"> useful but at least for these two</font>

205
00:09:17,720 --> 00:09:21,410
lines that respects the ownership

206
00:09:18,950 --> 00:09:23,360
principles<font color="#E5E5E5"> but when you return from swap</font>

207
00:09:21,410 --> 00:09:25,189
pointers here it realizes so that's why

208
00:09:23,360 --> 00:09:27,890
<font color="#E5E5E5">the pointing</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> pointing</font><font color="#CCCCCC"> here to the</font>

209
00:09:25,190 --> 00:09:29,750
spec file<font color="#E5E5E5"> it realizes that there's not</font>

210
00:09:27,890 --> 00:09:32,090
enough the mission for<font color="#E5E5E5"> X so X you're</font>

211
00:09:29,750 --> 00:09:35,570
supposed<font color="#E5E5E5"> to return to the color with</font>

212
00:09:32,090 --> 00:09:37,640
this parameter<font color="#E5E5E5"> with full ownership of</font>

213
00:09:35,570 --> 00:09:39,770
<font color="#E5E5E5">the</font><font color="#CCCCCC"> underlying memory there's an</font>

214
00:09:37,640 --> 00:09:41,300
implicit assignment and here it realizes

215
00:09:39,770 --> 00:09:45,710
<font color="#CCCCCC">that's not possible</font><font color="#E5E5E5"> because it was moved</font>

216
00:09:41,300 --> 00:09:48,770
<font color="#CCCCCC">here now let's listen</font><font color="#E5E5E5"> to the borrow so</font>

217
00:09:45,710 --> 00:09:51,890
borrow occurs when you passing<font color="#E5E5E5"> an input</font>

218
00:09:48,770 --> 00:09:55,400
parameter of access type<font color="#E5E5E5"> pointer and</font>

219
00:09:51,890 --> 00:09:57,260
temporarily the actual parameter and the

220
00:09:55,400 --> 00:09:58,790
<font color="#E5E5E5">call will lose on the ship of the thing</font>

221
00:09:57,260 --> 00:10:00,470
it points to and it will regain it

222
00:09:58,790 --> 00:10:03,020
automatically<font color="#E5E5E5"> so it's an input</font><font color="#CCCCCC"> parameter</font>

223
00:10:00,470 --> 00:10:05,060
it doesn't change the<font color="#CCCCCC"> call the article</font>

224
00:10:03,020 --> 00:10:07,220
value of the pointer<font color="#E5E5E5"> and there will be</font>

225
00:10:05,060 --> 00:10:11,180
<font color="#CCCCCC">no new lazing checks like for references</font>

226
00:10:07,220 --> 00:10:13,040
before<font color="#E5E5E5"> that there's no possible</font>

227
00:10:11,180 --> 00:10:16,430
conflicting aliasing between the

228
00:10:13,040 --> 00:10:18,800
arguments<font color="#E5E5E5"> so for example if I call</font><font color="#CCCCCC"> this</font>

229
00:10:16,430 --> 00:10:22,430
<font color="#E5E5E5">web content so swap contents was taking</font>

230
00:10:18,800 --> 00:10:24,500
input parameters x and y<font color="#E5E5E5"> okay there are</font>

231
00:10:22,430 --> 00:10:26,089
<font color="#CCCCCC">two</font><font color="#E5E5E5"> different pointers here X and X is</font>

232
00:10:24,500 --> 00:10:30,350
<font color="#CCCCCC">nuts and it will be code by the</font>

233
00:10:26,090 --> 00:10:32,930
<font color="#CCCCCC">normalizing</font><font color="#E5E5E5"> check now let's look at the</font>

234
00:10:30,350 --> 00:10:36,500
more complex borrow the local borrow so

235
00:10:32,930 --> 00:10:39,319
we can define local<font color="#E5E5E5"> variable here of an</font>

236
00:10:36,500 --> 00:10:42,680
<font color="#E5E5E5">anonymous access type that's how we</font>

237
00:10:39,320 --> 00:10:46,760
<font color="#E5E5E5">distinguish this from the move and here</font>

238
00:10:42,680 --> 00:10:48,800
where the because<font color="#CCCCCC"> we're</font><font color="#E5E5E5"> writing that the</font>

239
00:10:46,760 --> 00:10:50,889
<font color="#E5E5E5">ownership system understands that we</font><font color="#CCCCCC"> are</font>

240
00:10:48,800 --> 00:10:53,269
borrowing<font color="#CCCCCC"> X into</font><font color="#E5E5E5"> this local variable</font>

241
00:10:50,889 --> 00:10:55,850
<font color="#E5E5E5">what it mean is</font><font color="#CCCCCC"> that for the scope of</font>

242
00:10:53,269 --> 00:10:58,579
the local variable X becomes<font color="#E5E5E5"> unrightable</font>

243
00:10:55,850 --> 00:11:01,399
<font color="#E5E5E5">and so here I can still write but</font>

244
00:10:58,579 --> 00:11:04,040
through the<font color="#CCCCCC"> borer to to the underlying</font>

245
00:11:01,399 --> 00:11:07,579
memory<font color="#E5E5E5"> point you to buy</font><font color="#CCCCCC"> buy X</font><font color="#E5E5E5"> steal but</font>

246
00:11:04,040 --> 00:11:09,709
that it doesn't<font color="#CCCCCC"> own so I can still I can</font>

247
00:11:07,579 --> 00:11:12,109
implement swap contents<font color="#E5E5E5"> like that let's</font>

248
00:11:09,709 --> 00:11:15,619
<font color="#E5E5E5">look at what happens if I make a mistake</font>

249
00:11:12,110 --> 00:11:19,730
so if here instead of local X the<font color="#CCCCCC"> borer</font>

250
00:11:15,620 --> 00:11:20,959
<font color="#CCCCCC">I mentioned the borrow week I get an</font>

251
00:11:19,730 --> 00:11:27,470
error that<font color="#E5E5E5"> says that the</font><font color="#CCCCCC"> object was</font>

252
00:11:20,959 --> 00:11:30,349
already borrowed before<font color="#E5E5E5"> and and that's</font>

253
00:11:27,470 --> 00:11:31,220
all for<font color="#CCCCCC"> Burroughs finally last operation</font>

254
00:11:30,350 --> 00:11:34,279
the observe

255
00:11:31,220 --> 00:11:36,199
so the borrow here was the mutable

256
00:11:34,279 --> 00:11:39,470
<font color="#E5E5E5">borough of</font><font color="#CCCCCC"> arrest</font><font color="#E5E5E5"> the observe is just</font>

257
00:11:36,199 --> 00:11:42,680
the regular borrow<font color="#E5E5E5"> that's for passing</font>

258
00:11:39,470 --> 00:11:44,810
parameters of a composite type so an

259
00:11:42,680 --> 00:11:48,079
array a<font color="#E5E5E5"> record or combination thereof</font>

260
00:11:44,810 --> 00:11:50,560
that<font color="#E5E5E5"> eyes pointers in in them</font><font color="#CCCCCC"> here we're</font>

261
00:11:48,079 --> 00:11:53,359
<font color="#E5E5E5">going to consider</font><font color="#CCCCCC"> that the parameter</font>

262
00:11:50,560 --> 00:11:55,880
only provides a real<font color="#E5E5E5"> only view to all</font>

263
00:11:53,360 --> 00:11:58,610
<font color="#E5E5E5">the memory underneath all the possible</font>

264
00:11:55,880 --> 00:12:01,670
<font color="#E5E5E5">tree of data and that's the same</font><font color="#CCCCCC"> for</font>

265
00:11:58,610 --> 00:12:04,490
defining a constant<font color="#E5E5E5"> of this type again</font>

266
00:12:01,670 --> 00:12:06,920
<font color="#E5E5E5">the top level objects</font><font color="#CCCCCC"> Eneida</font>

267
00:12:04,490 --> 00:12:09,230
is<font color="#CCCCCC"> immutable but inspark</font><font color="#E5E5E5"> for this</font>

268
00:12:06,920 --> 00:12:11,540
ownership<font color="#E5E5E5"> system we're going to consider</font>

269
00:12:09,230 --> 00:12:14,540
<font color="#CCCCCC">that all the tree of pointed to data is</font>

270
00:12:11,540 --> 00:12:19,699
also immutable that allows formal

271
00:12:14,540 --> 00:12:22,219
analysis and<font color="#E5E5E5"> after the scope of the call</font>

272
00:12:19,699 --> 00:12:25,339
or the scope of<font color="#E5E5E5"> these constants ends</font>

273
00:12:22,220 --> 00:12:27,860
<font color="#CCCCCC">then the original object</font><font color="#E5E5E5"> we recovers its</font>

274
00:12:25,339 --> 00:12:30,319
ownership<font color="#E5E5E5"> during this code both object</font>

275
00:12:27,860 --> 00:12:34,279
the<font color="#E5E5E5"> borrower and the borrower have read</font>

276
00:12:30,319 --> 00:12:37,610
<font color="#E5E5E5">on leash permission so let's look at an</font>

277
00:12:34,279 --> 00:12:40,310
example<font color="#CCCCCC"> so yeah so so</font><font color="#E5E5E5"> this was for</font>

278
00:12:37,610 --> 00:12:43,040
constant and parameter<font color="#E5E5E5"> the more complex</font>

279
00:12:40,310 --> 00:12:46,609
<font color="#E5E5E5">observer is the like be</font><font color="#CCCCCC"> like previously</font>

280
00:12:43,040 --> 00:12:49,969
the local observer<font color="#E5E5E5"> and here we recognize</font>

281
00:12:46,610 --> 00:12:52,279
it<font color="#CCCCCC"> that's</font><font color="#E5E5E5"> our choice of</font><font color="#CCCCCC"> design by seeing</font>

282
00:12:49,970 --> 00:12:55,160
<font color="#E5E5E5">that it's local variable of and animals</font>

283
00:12:52,279 --> 00:12:57,829
<font color="#CCCCCC">access</font><font color="#E5E5E5"> to constant so not a name type</font>

284
00:12:55,160 --> 00:12:58,600
like before and here instead<font color="#E5E5E5"> of a move</font>

285
00:12:57,829 --> 00:13:03,550
again

286
00:12:58,600 --> 00:13:05,110
we do<font color="#CCCCCC"> observe so why as</font><font color="#E5E5E5"> a read-only</font>

287
00:13:03,550 --> 00:13:07,540
access to the<font color="#E5E5E5"> underlying memory and</font>

288
00:13:05,110 --> 00:13:10,750
during its scope<font color="#CCCCCC"> why also</font><font color="#E5E5E5"> as read-only</font>

289
00:13:07,540 --> 00:13:12,670
access so I can read local<font color="#E5E5E5"> why here and</font>

290
00:13:10,750 --> 00:13:15,220
<font color="#E5E5E5">the memory pointed to and I could</font>

291
00:13:12,670 --> 00:13:19,719
<font color="#E5E5E5">replace replace this local Y by Y so</font>

292
00:13:15,220 --> 00:13:23,860
that<font color="#CCCCCC"> works</font><font color="#E5E5E5"> when I make a mistake</font><font color="#CCCCCC"> so here</font>

293
00:13:19,720 --> 00:13:25,839
<font color="#E5E5E5">so if I move the final assignments up in</font>

294
00:13:23,860 --> 00:13:28,660
<font color="#E5E5E5">Thai inside the scope so</font><font color="#CCCCCC"> here in the</font>

295
00:13:25,839 --> 00:13:30,490
scope where<font color="#E5E5E5"> Y is observed it's an error</font>

296
00:13:28,660 --> 00:13:32,139
to try to write through white so

297
00:13:30,490 --> 00:13:34,570
read-only access to the unlearning

298
00:13:32,139 --> 00:13:38,019
memory and and that's what the ball

299
00:13:34,570 --> 00:13:41,800
<font color="#CCCCCC">checker says so there are some</font>

300
00:13:38,019 --> 00:13:43,180
limitations<font color="#E5E5E5"> we are only focusing right</font>

301
00:13:41,800 --> 00:13:46,359
now on what we call in<font color="#CCCCCC"> NIDA pull</font>

302
00:13:43,180 --> 00:13:48,729
specific types so not the general<font color="#E5E5E5"> access</font>

303
00:13:46,360 --> 00:13:51,639
type that's when you define the the

304
00:13:48,730 --> 00:13:54,040
<font color="#E5E5E5">access type as all or constants because</font>

305
00:13:51,639 --> 00:13:55,839
<font color="#CCCCCC">these are much more liberal in Ada and</font>

306
00:13:54,040 --> 00:13:57,969
that would be much<font color="#E5E5E5"> more complex to</font>

307
00:13:55,839 --> 00:14:01,240
define the rules for having proper

308
00:13:57,970 --> 00:14:02,980
support in<font color="#CCCCCC"> part so it it will be either</font>

309
00:14:01,240 --> 00:14:04,810
limited or there<font color="#CCCCCC"> won't be any</font>

310
00:14:02,980 --> 00:14:06,399
possibility<font color="#E5E5E5"> to take the address</font><font color="#CCCCCC"> of a</font>

311
00:14:04,810 --> 00:14:08,349
ball in the stack<font color="#CCCCCC"> so that's the kind of</font>

312
00:14:06,399 --> 00:14:10,329
things were discussing<font color="#CCCCCC"> right now to</font>

313
00:14:08,350 --> 00:14:11,829
define<font color="#E5E5E5"> the exact rules of what we want</font>

314
00:14:10,329 --> 00:14:14,890
to allow and<font color="#CCCCCC"> what we can</font><font color="#E5E5E5"> implement in</font>

315
00:14:11,829 --> 00:14:16,959
the in the checker in any case it will

316
00:14:14,890 --> 00:14:19,720
<font color="#E5E5E5">be less powerful</font><font color="#CCCCCC"> than the</font><font color="#E5E5E5"> system of</font>

317
00:14:16,959 --> 00:14:22,510
<font color="#E5E5E5">rests there</font><font color="#CCCCCC"> are we</font><font color="#E5E5E5"> don't plan to have</font>

318
00:14:19,720 --> 00:14:24,070
<font color="#CCCCCC">any annotation impacts we</font><font color="#E5E5E5"> want to have</font>

319
00:14:22,510 --> 00:14:26,709
<font color="#E5E5E5">something that</font><font color="#CCCCCC"> integrates very well with</font>

320
00:14:24,070 --> 00:14:28,930
<font color="#E5E5E5">existing code or code</font><font color="#CCCCCC"> that is regular</font>

321
00:14:26,709 --> 00:14:31,359
<font color="#CCCCCC">ADA even if it's new and so we don't</font>

322
00:14:28,930 --> 00:14:32,469
<font color="#E5E5E5">plan to have annotations for lifetime</font><font color="#CCCCCC"> we</font>

323
00:14:31,360 --> 00:14:35,199
want the borrowing observing the

324
00:14:32,470 --> 00:14:37,420
relationship<font color="#E5E5E5"> to be statically known some</font>

325
00:14:35,199 --> 00:14:39,939
<font color="#E5E5E5">of these constraints come from the wish</font>

326
00:14:37,420 --> 00:14:41,800
to have no additional annotations and

327
00:14:39,940 --> 00:14:42,970
some other<font color="#E5E5E5"> come from the fact that we</font>

328
00:14:41,800 --> 00:14:44,680
want to<font color="#E5E5E5"> do something the goal is</font>

329
00:14:42,970 --> 00:14:46,420
different than from rest<font color="#CCCCCC"> we want to be</font>

330
00:14:44,680 --> 00:14:49,029
able<font color="#CCCCCC"> to do formal verification</font><font color="#E5E5E5"> and so</font>

331
00:14:46,420 --> 00:14:50,680
what about<font color="#CCCCCC"> this statically known</font>

332
00:14:49,029 --> 00:14:52,510
relationship is something<font color="#E5E5E5"> very important</font>

333
00:14:50,680 --> 00:14:54,939
<font color="#E5E5E5">otherwise you end up with things that</font>

334
00:14:52,510 --> 00:14:57,490
<font color="#E5E5E5">are much more complex like what</font>

335
00:14:54,940 --> 00:15:00,880
researchers do we exploring<font color="#E5E5E5"> formal</font>

336
00:14:57,490 --> 00:15:03,459
verification or first<font color="#CCCCCC"> end up with and</font>

337
00:15:00,880 --> 00:15:05,500
there are things that<font color="#CCCCCC"> are specific to</font>

338
00:15:03,459 --> 00:15:07,420
<font color="#CCCCCC">Veda so when we did these these ideas</font>

339
00:15:05,500 --> 00:15:10,779
together<font color="#CCCCCC"> there are different types and</font>

340
00:15:07,420 --> 00:15:12,930
<font color="#E5E5E5">first of all array types when you take</font>

341
00:15:10,779 --> 00:15:15,090
an element<font color="#E5E5E5"> of the array</font>

342
00:15:12,930 --> 00:15:16,829
when you move it<font color="#E5E5E5"> you're going</font><font color="#CCCCCC"> to</font>

343
00:15:15,090 --> 00:15:19,020
mentally move all the array because<font color="#CCCCCC"> you</font>

344
00:15:16,830 --> 00:15:21,000
don't know where which cell it is so if

345
00:15:19,020 --> 00:15:23,160
<font color="#E5E5E5">want to for example swap elements in an</font>

346
00:15:21,000 --> 00:15:27,750
array<font color="#E5E5E5"> you will have to do it through a</font>

347
00:15:23,160 --> 00:15:29,310
call<font color="#E5E5E5"> so that the</font><font color="#CCCCCC"> call up hides the fact</font>

348
00:15:27,750 --> 00:15:32,670
<font color="#E5E5E5">that two</font><font color="#CCCCCC"> different elements</font><font color="#E5E5E5"> of the array</font>

349
00:15:29,310 --> 00:15:33,270
are<font color="#E5E5E5"> are are moved you won't be able</font><font color="#CCCCCC"> to</font>

350
00:15:32,670 --> 00:15:37,949
do it

351
00:15:33,270 --> 00:15:40,380
just taking index<font color="#CCCCCC"> I in</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> verb all</font><font color="#E5E5E5"> and</font>

352
00:15:37,950 --> 00:15:42,440
then doing<font color="#E5E5E5"> the swap locally so there are</font>

353
00:15:40,380 --> 00:15:46,020
some<font color="#E5E5E5"> kind</font><font color="#CCCCCC"> of limitations that come</font><font color="#E5E5E5"> from</font>

354
00:15:42,440 --> 00:15:50,820
<font color="#E5E5E5">this the limitation of the aesthetic</font>

355
00:15:46,020 --> 00:15:54,960
<font color="#CCCCCC">arises</font><font color="#E5E5E5"> in terms of</font><font color="#CCCCCC"> Road map so what we</font>

356
00:15:50,820 --> 00:15:57,000
expect<font color="#CCCCCC"> to do by the</font><font color="#E5E5E5"> end of this spring</font>

357
00:15:54,960 --> 00:15:59,400
the spring so May June when we should

358
00:15:57,000 --> 00:16:03,150
<font color="#E5E5E5">netcommunity release which now includes</font>

359
00:15:59,400 --> 00:16:05,640
<font color="#CCCCCC">spark and GPS and</font><font color="#E5E5E5"> everything we hope to</font>

360
00:16:03,150 --> 00:16:07,439
stabilize the reference<font color="#E5E5E5"> many rules so we</font>

361
00:16:05,640 --> 00:16:09,120
still<font color="#E5E5E5"> working on</font><font color="#CCCCCC"> these so if you</font><font color="#E5E5E5"> want to</font>

362
00:16:07,440 --> 00:16:12,750
have a look you're curious that's there

363
00:16:09,120 --> 00:16:14,430
<font color="#E5E5E5">that's online and I still a bit</font><font color="#CCCCCC"> evolving</font>

364
00:16:12,750 --> 00:16:18,960
<font color="#CCCCCC">to to make</font><font color="#E5E5E5"> sure that we have something</font>

365
00:16:14,430 --> 00:16:20,099
<font color="#E5E5E5">sound that maps to</font><font color="#CCCCCC"> the implementation</font><font color="#E5E5E5"> to</font>

366
00:16:18,960 --> 00:16:21,750
complete the implementation<font color="#E5E5E5"> of the</font>

367
00:16:20,100 --> 00:16:23,730
ownership checking so what I showed was

368
00:16:21,750 --> 00:16:25,800
what's working right<font color="#E5E5E5"> now</font><font color="#CCCCCC"> but there's</font>

369
00:16:23,730 --> 00:16:29,880
still a lot of work<font color="#E5E5E5"> to make it work in</font>

370
00:16:25,800 --> 00:16:32,729
all conditions<font color="#E5E5E5"> and to implement all the</font>

371
00:16:29,880 --> 00:16:33,900
rules that<font color="#CCCCCC"> are already</font><font color="#E5E5E5"> defined and to</font>

372
00:16:32,730 --> 00:16:36,630
adapt the<font color="#CCCCCC"> floor analysis</font><font color="#E5E5E5"> and in</font><font color="#CCCCCC"> saw</font>

373
00:16:33,900 --> 00:16:38,459
spark goes in<font color="#CCCCCC"> two different stages for</font>

374
00:16:36,630 --> 00:16:40,860
analysis there's this<font color="#E5E5E5"> flow analysis that</font>

375
00:16:38,460 --> 00:16:43,440
those local<font color="#E5E5E5"> static analysis simple one</font>

376
00:16:40,860 --> 00:16:45,270
<font color="#CCCCCC">for all</font><font color="#E5E5E5"> the flows reaching essentially</font>

377
00:16:43,440 --> 00:16:47,670
the<font color="#CCCCCC"> Bronze level</font><font color="#E5E5E5"> and then</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> proof</font>

378
00:16:45,270 --> 00:16:49,650
where we use provers<font color="#CCCCCC"> and the hood and</font><font color="#E5E5E5"> to</font>

379
00:16:47,670 --> 00:16:52,949
reach the higher levels of<font color="#CCCCCC"> warranty</font><font color="#E5E5E5"> so</font>

380
00:16:49,650 --> 00:16:54,780
silver<font color="#CCCCCC"> etc we want to finish</font><font color="#E5E5E5"> that flow</font>

381
00:16:52,950 --> 00:16:59,190
analysis which we haven't<font color="#E5E5E5"> started and</font>

382
00:16:54,780 --> 00:17:00,689
for the next<font color="#CCCCCC"> years we want to support</font>

383
00:16:59,190 --> 00:17:02,580
local<font color="#CCCCCC"> bore</font><font color="#E5E5E5"> and observing proof which we</font>

384
00:17:00,690 --> 00:17:04,740
<font color="#CCCCCC">don't</font><font color="#E5E5E5"> do right now so</font><font color="#CCCCCC"> it's</font><font color="#E5E5E5"> more complex</font>

385
00:17:02,580 --> 00:17:06,780
to put proof of<font color="#E5E5E5"> our recursive data</font>

386
00:17:04,740 --> 00:17:08,490
structures and<font color="#E5E5E5"> here what you</font><font color="#CCCCCC"> want to be</font>

387
00:17:06,780 --> 00:17:10,440
able<font color="#CCCCCC"> to do is to quantify</font><font color="#E5E5E5"> over the</font>

388
00:17:08,490 --> 00:17:12,329
<font color="#E5E5E5">content of these things so for all</font>

389
00:17:10,440 --> 00:17:14,720
elements<font color="#E5E5E5"> of my list I have this property</font>

390
00:17:12,329 --> 00:17:17,250
<font color="#E5E5E5">so that's more complex we have</font>

391
00:17:14,720 --> 00:17:19,760
prototypes in the<font color="#E5E5E5"> underlying technology</font>

392
00:17:17,250 --> 00:17:22,829
<font color="#CCCCCC">y3 and we have to leave</font><font color="#E5E5E5"> that to spark</font>

393
00:17:19,760 --> 00:17:24,329
<font color="#E5E5E5">and to check absence of memories so the</font>

394
00:17:22,829 --> 00:17:26,438
rules are set up so that we<font color="#E5E5E5"> can check</font>

395
00:17:24,329 --> 00:17:39,869
that<font color="#E5E5E5"> by proof and we have</font>

396
00:17:26,439 --> 00:17:39,869
<font color="#CCCCCC">yes and I</font><font color="#E5E5E5"> think that's all thank you yes</font>

397
00:17:40,350 --> 00:18:15,850
okay I think<font color="#CCCCCC"> it's cool so for</font><font color="#E5E5E5"> yeah yeah</font>

398
00:18:13,149 --> 00:18:17,619
so<font color="#E5E5E5"> so it's it's planned but the proof</font>

399
00:18:15,850 --> 00:18:20,889
support right now<font color="#CCCCCC"> doesn't support</font>

400
00:18:17,619 --> 00:18:21,970
<font color="#E5E5E5">recursive types yet if you</font><font color="#CCCCCC"> were</font><font color="#E5E5E5"> it</font><font color="#CCCCCC"> well</font>

401
00:18:20,889 --> 00:18:23,320
<font color="#E5E5E5">it will</font>

402
00:18:21,970 --> 00:18:26,740
so the<font color="#CCCCCC"> three</font><font color="#E5E5E5"> use case that that I</font>

403
00:18:23,320 --> 00:18:28,779
<font color="#CCCCCC">mentioned it well</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> first ones the the</font>

404
00:18:26,740 --> 00:18:30,580
first two ones<font color="#E5E5E5"> were where are the easy</font>

405
00:18:28,779 --> 00:18:32,259
ones<font color="#CCCCCC"> that are supported already well</font>

406
00:18:30,580 --> 00:18:33,009
partially<font color="#CCCCCC"> because</font><font color="#E5E5E5"> flatness is not there</font>

407
00:18:32,259 --> 00:18:36,070
yet<font color="#CCCCCC"> its</font><font color="#E5E5E5"> Tara</font>

408
00:18:33,009 --> 00:18:38,159
but the just having a tree<font color="#E5E5E5"> which is</font><font color="#CCCCCC"> not</font>

409
00:18:36,070 --> 00:18:50,168
recursive<font color="#E5E5E5"> yes</font><font color="#CCCCCC"> it's already</font><font color="#E5E5E5"> supported</font>

410
00:18:38,159 --> 00:18:53,440
yeah<font color="#CCCCCC"> so that's cool yes yeah</font><font color="#E5E5E5"> so spark</font>

411
00:18:50,169 --> 00:18:56,259
works locally<font color="#E5E5E5"> so enable in order to be</font>

412
00:18:53,440 --> 00:18:58,619
<font color="#CCCCCC">able to do</font><font color="#E5E5E5"> this powerful analysis using</font>

413
00:18:56,259 --> 00:19:01,169
SMT solvers you have to be<font color="#CCCCCC"> modular</font>

414
00:18:58,619 --> 00:19:03,549
<font color="#CCCCCC">otherwise do something else</font><font color="#E5E5E5"> like</font>

415
00:19:01,169 --> 00:19:06,129
symbolic execution that<font color="#CCCCCC"> Traverse is the</font>

416
00:19:03,549 --> 00:19:07,570
thing and bounded simile execution so we

417
00:19:06,129 --> 00:19:10,990
are in the realm<font color="#E5E5E5"> of deductive</font>

418
00:19:07,570 --> 00:19:13,539
verification were we<font color="#E5E5E5"> really are looking</font>

419
00:19:10,990 --> 00:19:15,340
at the piece of codes<font color="#E5E5E5"> although we do</font>

420
00:19:13,539 --> 00:19:19,049
things like<font color="#CCCCCC"> inlining so there are ways</font>

421
00:19:15,340 --> 00:19:19,049
<font color="#CCCCCC">to</font><font color="#E5E5E5"> go around these</font><font color="#CCCCCC"> limitations</font>

422
00:19:31,530 --> 00:19:39,120
yeah so there's this<font color="#E5E5E5"> the same so I mean</font>

423
00:19:36,690 --> 00:19:42,120
what<font color="#CCCCCC"> I</font><font color="#E5E5E5"> just used the examples</font><font color="#CCCCCC"> that use</font>

424
00:19:39,120 --> 00:19:45,959
plain<font color="#CCCCCC"> verbal but</font><font color="#E5E5E5"> the same applies to</font>

425
00:19:42,120 --> 00:19:48,479
fields<font color="#CCCCCC"> I mean that that fields are</font>

426
00:19:45,960 --> 00:19:50,880
followed<font color="#E5E5E5"> individually so what we have in</font>

427
00:19:48,480 --> 00:19:54,390
<font color="#E5E5E5">terms of</font><font color="#CCCCCC"> implementation is that</font><font color="#E5E5E5"> we</font>

428
00:19:50,880 --> 00:19:57,840
unfold on demands the destruction of the

429
00:19:54,390 --> 00:20:01,320
tree of<font color="#CCCCCC"> the</font><font color="#E5E5E5"> type to</font><font color="#CCCCCC"> go deep in</font><font color="#E5E5E5"> inside</font>

430
00:19:57,840 --> 00:20:03,169
the the fields of given<font color="#CCCCCC"> barbel so you</font>

431
00:20:01,320 --> 00:20:07,010
can borrow<font color="#E5E5E5"> for example if you have</font>

432
00:20:03,170 --> 00:20:07,010
something<font color="#CCCCCC"> that</font><font color="#E5E5E5"> points to</font>

