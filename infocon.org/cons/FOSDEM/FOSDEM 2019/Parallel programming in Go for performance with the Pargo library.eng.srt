1
00:00:14,400 --> 00:00:21,810
okay<font color="#CCCCCC"> it's for so run applause for paska</font>

2
00:00:17,950 --> 00:00:21,810
<font color="#E5E5E5">he's gonna be talking</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> pepperoni</font>

3
00:00:25,280 --> 00:00:30,360
<font color="#E5E5E5">okay thank you very much so</font><font color="#CCCCCC"> thanks for</font>

4
00:00:29,130 --> 00:00:32,278
<font color="#CCCCCC">the</font><font color="#E5E5E5"> introduction so I'm going to talk</font>

5
00:00:30,360 --> 00:00:34,920
<font color="#CCCCCC">about the Pargo</font><font color="#E5E5E5"> library</font>

6
00:00:32,279 --> 00:00:37,860
what is<font color="#E5E5E5"> Pago Pago is a library that</font><font color="#CCCCCC"> we</font>

7
00:00:34,920 --> 00:00:40,140
developed at<font color="#CCCCCC"> mxx a science lab here</font><font color="#E5E5E5"> in</font>

8
00:00:37,860 --> 00:00:43,379
<font color="#E5E5E5">belgium and</font><font color="#CCCCCC"> it's a library</font><font color="#E5E5E5"> for parallel</font>

9
00:00:40,140 --> 00:00:44,910
programming<font color="#CCCCCC"> and goal it's based on</font><font color="#E5E5E5"> our</font>

10
00:00:43,380 --> 00:00:47,730
experiences with lots of<font color="#E5E5E5"> different other</font>

11
00:00:44,910 --> 00:00:50,849
parallel programming exercises and

12
00:00:47,730 --> 00:00:53,040
languages<font color="#CCCCCC"> in</font><font color="#E5E5E5"> C++ Common Lisp</font><font color="#CCCCCC"> and Java</font>

13
00:00:50,850 --> 00:00:55,559
<font color="#E5E5E5">and a few others and we release it under</font>

14
00:00:53,040 --> 00:00:57,989
<font color="#CCCCCC">a bsd-style open-source license at this</font>

15
00:00:55,559 --> 00:00:59,489
URL<font color="#CCCCCC"> that you can see right there and it</font>

16
00:00:57,989 --> 00:01:01,559
<font color="#E5E5E5">supports a lots of different features</font>

17
00:00:59,489 --> 00:01:03,360
<font color="#E5E5E5">for parallel programming</font><font color="#CCCCCC"> so it's based</font>

18
00:01:01,559 --> 00:01:04,830
on<font color="#E5E5E5"> the notion of divide and conquer task</font>

19
00:01:03,360 --> 00:01:07,320
based parallelism which I'm going<font color="#E5E5E5"> to</font>

20
00:01:04,830 --> 00:01:09,150
<font color="#E5E5E5">explain in a minute it supports lots of</font>

21
00:01:07,320 --> 00:01:11,750
features<font color="#CCCCCC"> like parallel ranges parallel</font>

22
00:01:09,150 --> 00:01:15,360
reduction<font color="#E5E5E5"> parallel boolean functions</font>

23
00:01:11,750 --> 00:01:18,030
speculative parallelism<font color="#CCCCCC"> some concrete</font>

24
00:01:15,360 --> 00:01:20,760
algorithms<font color="#E5E5E5"> primarily sorting so parallel</font>

25
00:01:18,030 --> 00:01:22,620
quicksort parallel merge sort<font color="#CCCCCC"> a parallel</font>

26
00:01:20,760 --> 00:01:25,229
hash table for performance and<font color="#E5E5E5"> some</font>

27
00:01:22,620 --> 00:01:27,330
parallel<font color="#E5E5E5"> pipelines functionality that is</font>

28
00:01:25,229 --> 00:01:29,880
inspired by<font color="#E5E5E5"> the Java parallel streams</font>

29
00:01:27,330 --> 00:01:32,030
that<font color="#E5E5E5"> was introduced in</font><font color="#CCCCCC"> JDK 8 but with a</font>

30
00:01:29,880 --> 00:01:35,009
distinct<font color="#E5E5E5"> go flavor so we support</font>

31
00:01:32,030 --> 00:01:36,930
contexts<font color="#E5E5E5"> we support cancellation and we</font>

32
00:01:35,009 --> 00:01:39,200
support go style<font color="#E5E5E5"> error handling of</font>

33
00:01:36,930 --> 00:01:39,200
course

34
00:01:40,520 --> 00:01:45,289
now some of you might<font color="#CCCCCC"> wonder why do we</font>

35
00:01:43,250 --> 00:01:48,320
even need<font color="#CCCCCC"> a parallel programming library</font>

36
00:01:45,290 --> 00:01:50,360
for go don't we<font color="#CCCCCC"> already have</font><font color="#E5E5E5"> concurrency</font>

37
00:01:48,320 --> 00:01:53,658
mechanisms in<font color="#E5E5E5"> the language that already</font>

38
00:01:50,360 --> 00:01:55,840
give us<font color="#E5E5E5"> everything that we need</font><font color="#CCCCCC"> and here</font>

39
00:01:53,659 --> 00:01:58,039
it's important to stress<font color="#CCCCCC"> again that</font>

40
00:01:55,840 --> 00:02:00,830
concurrency and parallelism<font color="#CCCCCC"> are two</font>

41
00:01:58,039 --> 00:02:02,240
completely different topics<font color="#E5E5E5"> so what's</font>

42
00:02:00,830 --> 00:02:05,960
the<font color="#CCCCCC"> difference</font><font color="#E5E5E5"> between concurrency and</font>

43
00:02:02,240 --> 00:02:08,239
parallelism<font color="#E5E5E5"> concurrency</font><font color="#CCCCCC"> you need</font>

44
00:02:05,960 --> 00:02:10,549
concurrency when it's part of the

45
00:02:08,239 --> 00:02:13,069
problem domain<font color="#CCCCCC"> that's</font><font color="#E5E5E5"> a really important</font>

46
00:02:10,550 --> 00:02:14,750
thing<font color="#E5E5E5"> to understand so when do you have</font>

47
00:02:13,069 --> 00:02:16,790
concurrency in a problem domain one

48
00:02:14,750 --> 00:02:19,130
typical example<font color="#CCCCCC"> is</font><font color="#E5E5E5"> when you have an</font>

49
00:02:16,790 --> 00:02:21,920
<font color="#E5E5E5">airplane reservation system it may</font>

50
00:02:19,130 --> 00:02:24,140
<font color="#E5E5E5">happen</font><font color="#CCCCCC"> that several different</font><font color="#E5E5E5"> people</font>

51
00:02:21,920 --> 00:02:26,149
<font color="#E5E5E5">want to book the</font><font color="#CCCCCC"> same</font><font color="#E5E5E5"> seat at more or</font>

52
00:02:24,140 --> 00:02:27,738
<font color="#E5E5E5">less</font><font color="#CCCCCC"> the same time</font><font color="#E5E5E5"> then you</font><font color="#CCCCCC"> have a</font>

53
00:02:26,150 --> 00:02:30,380
concurrent<font color="#E5E5E5"> problem that comes from the</font>

54
00:02:27,739 --> 00:02:33,980
problem<font color="#CCCCCC"> domain that</font><font color="#E5E5E5"> you need to solve</font>

55
00:02:30,380 --> 00:02:36,049
somehow and<font color="#E5E5E5"> go is really good at this</font><font color="#CCCCCC"> so</font>

56
00:02:33,980 --> 00:02:38,000
you have<font color="#CCCCCC"> go</font><font color="#E5E5E5"> channels go routines all</font>

57
00:02:36,049 --> 00:02:40,160
these<font color="#E5E5E5"> lovely features that allow you to</font>

58
00:02:38,000 --> 00:02:42,620
<font color="#CCCCCC">really solve these issues</font><font color="#E5E5E5"> from the</font>

59
00:02:40,160 --> 00:02:44,180
problem domain<font color="#E5E5E5"> you would have these</font>

60
00:02:42,620 --> 00:02:46,130
problems<font color="#CCCCCC"> even if you wouldn't have</font>

61
00:02:44,180 --> 00:02:47,810
multiple<font color="#E5E5E5"> nodes if you wouldn't have</font>

62
00:02:46,130 --> 00:02:50,450
multiple<font color="#CCCCCC"> cores if you would have a</font>

63
00:02:47,810 --> 00:02:52,190
single box with a<font color="#E5E5E5"> single CPU core you</font>

64
00:02:50,450 --> 00:02:54,018
would still<font color="#CCCCCC"> have to face these problems</font>

65
00:02:52,190 --> 00:02:56,840
and<font color="#E5E5E5"> express them somehow as a solution</font>

66
00:02:54,019 --> 00:02:58,579
<font color="#E5E5E5">and it's indeed</font><font color="#CCCCCC"> the case that there are</font>

67
00:02:56,840 --> 00:03:02,150
concurrent programming languages in the

68
00:02:58,579 --> 00:03:05,060
past that did that so there's nothing

69
00:03:02,150 --> 00:03:08,030
<font color="#E5E5E5">about</font><font color="#CCCCCC"> multi-core or multi nodes here</font>

70
00:03:05,060 --> 00:03:09,920
with regard to concurrency<font color="#E5E5E5"> on the other</font>

71
00:03:08,030 --> 00:03:12,140
side<font color="#CCCCCC"> when we talk about parallelism</font>

72
00:03:09,920 --> 00:03:14,690
<font color="#CCCCCC">we're only talking about</font><font color="#E5E5E5"> the solution</font>

73
00:03:12,140 --> 00:03:16,819
domain so<font color="#E5E5E5"> these are problems for which</font>

74
00:03:14,690 --> 00:03:19,069
we don't necessarily<font color="#CCCCCC"> need any form of</font>

75
00:03:16,819 --> 00:03:22,130
<font color="#E5E5E5">concurrency but we may want</font><font color="#CCCCCC"> to use</font>

76
00:03:19,069 --> 00:03:25,010
<font color="#CCCCCC">multiple cores or multiple nodes</font><font color="#E5E5E5"> to make</font>

77
00:03:22,130 --> 00:03:28,190
<font color="#CCCCCC">them</font><font color="#E5E5E5"> faster that's the only reason why</font>

78
00:03:25,010 --> 00:03:29,899
you would<font color="#CCCCCC"> want to use</font><font color="#E5E5E5"> parallelism and if</font>

79
00:03:28,190 --> 00:03:33,739
you don't care<font color="#E5E5E5"> about performance you can</font>

80
00:03:29,900 --> 00:03:35,420
go home<font color="#E5E5E5"> now</font><font color="#CCCCCC"> now sometimes it gets</font>

81
00:03:33,739 --> 00:03:37,579
confusing<font color="#E5E5E5"> because of course you also</font>

82
00:03:35,420 --> 00:03:40,730
want your concurrent programs to be fast

83
00:03:37,579 --> 00:03:42,440
<font color="#CCCCCC">so</font><font color="#E5E5E5"> bringing multicores and multi nodes</font>

84
00:03:40,730 --> 00:03:44,660
<font color="#E5E5E5">to concurrent programs actually</font><font color="#CCCCCC"> makes</font>

85
00:03:42,440 --> 00:03:48,260
sense<font color="#CCCCCC"> but</font><font color="#E5E5E5"> it's still important to keep</font>

86
00:03:44,660 --> 00:03:49,880
these concepts separate in your<font color="#CCCCCC"> head so</font>

87
00:03:48,260 --> 00:03:52,250
let's look at an<font color="#CCCCCC"> example for</font><font color="#E5E5E5"> a parallel</font>

88
00:03:49,880 --> 00:03:52,829
<font color="#CCCCCC">program</font><font color="#E5E5E5"> so this is a very simple non</font>

89
00:03:52,250 --> 00:03:54,960
<font color="#E5E5E5">parallel</font>

90
00:03:52,830 --> 00:03:58,830
program it's a purely sequential program

91
00:03:54,960 --> 00:04:02,580
it takes the slides of numbers<font color="#E5E5E5"> sums them</font>

92
00:03:58,830 --> 00:04:05,340
<font color="#CCCCCC">up and returns the</font><font color="#E5E5E5"> sum so</font><font color="#CCCCCC"> nothing in</font>

93
00:04:02,580 --> 00:04:07,110
here has<font color="#E5E5E5"> a new asks for parallelism or</font>

94
00:04:05,340 --> 00:04:09,720
concurrency<font color="#CCCCCC"> it's a purely sequential</font>

95
00:04:07,110 --> 00:04:12,210
program perfectly fine but<font color="#E5E5E5"> maybe your</font>

96
00:04:09,720 --> 00:04:14,040
slices are really big<font color="#E5E5E5"> and</font><font color="#CCCCCC"> you want to</font>

97
00:04:12,210 --> 00:04:17,220
use<font color="#CCCCCC"> multiple cores to make this go</font>

98
00:04:14,040 --> 00:04:21,089
<font color="#CCCCCC">faster</font><font color="#E5E5E5"> and then one way to express this</font>

99
00:04:17,220 --> 00:04:23,460
in pure<font color="#E5E5E5"> goal without</font><font color="#CCCCCC"> Pargo</font><font color="#E5E5E5"> is by</font>

100
00:04:21,089 --> 00:04:25,799
expressing it like this<font color="#E5E5E5"> so this uses</font><font color="#CCCCCC"> go</font>

101
00:04:23,460 --> 00:04:28,200
<font color="#E5E5E5">routines for speeding up this for some</font>

102
00:04:25,800 --> 00:04:30,720
function so the first thing is this we

103
00:04:28,200 --> 00:04:32,969
look at a particular<font color="#E5E5E5"> threshold we ask is</font>

104
00:04:30,720 --> 00:04:35,790
this the<font color="#E5E5E5"> length of the slice lower than</font>

105
00:04:32,970 --> 00:04:37,350
the particular<font color="#E5E5E5"> threshold</font><font color="#CCCCCC"> and we need to</font>

106
00:04:35,790 --> 00:04:39,630
experimentally determine that<font color="#E5E5E5"> threshold</font>

107
00:04:37,350 --> 00:04:41,250
<font color="#E5E5E5">and then we know if it's below</font><font color="#CCCCCC"> that</font>

108
00:04:39,630 --> 00:04:43,080
threshold<font color="#CCCCCC"> it doesn't actually make sense</font>

109
00:04:41,250 --> 00:04:46,790
to use multiple<font color="#E5E5E5"> cores because this will</font>

110
00:04:43,080 --> 00:04:49,800
be fast<font color="#E5E5E5"> enough as a sequential</font><font color="#CCCCCC"> program</font>

111
00:04:46,790 --> 00:04:52,910
if it's bigger than that<font color="#E5E5E5"> threshold then</font>

112
00:04:49,800 --> 00:04:58,830
<font color="#CCCCCC">we</font><font color="#E5E5E5"> divide the size of the slice by two</font>

113
00:04:52,910 --> 00:05:00,960
<font color="#E5E5E5">so we split it into two halves then we</font>

114
00:04:58,830 --> 00:05:04,020
use a weight group<font color="#E5E5E5"> which is a feature</font>

115
00:05:00,960 --> 00:05:05,640
that<font color="#E5E5E5"> comes with a go standard library we</font>

116
00:05:04,020 --> 00:05:08,849
tell the weight group<font color="#E5E5E5"> we're going to</font>

117
00:05:05,640 --> 00:05:10,590
spawn one go routine<font color="#CCCCCC"> and inside that</font><font color="#E5E5E5"> go</font>

118
00:05:08,850 --> 00:05:12,060
routine we're making sure<font color="#CCCCCC"> that we tell</font>

119
00:05:10,590 --> 00:05:14,549
<font color="#E5E5E5">the weight group that we're done</font><font color="#CCCCCC"> after</font>

120
00:05:12,060 --> 00:05:17,160
<font color="#CCCCCC">this goal routine has finished</font><font color="#E5E5E5"> and in</font>

121
00:05:14,550 --> 00:05:19,590
that<font color="#E5E5E5"> go routine we take building the sum</font>

122
00:05:17,160 --> 00:05:24,630
who is a<font color="#E5E5E5"> recursive call for the left</font>

123
00:05:19,590 --> 00:05:26,460
half of that slice then<font color="#E5E5E5"> we're also</font>

124
00:05:24,630 --> 00:05:29,280
building the sum for the right half of

125
00:05:26,460 --> 00:05:32,969
<font color="#E5E5E5">that slide slice which potentially runs</font>

126
00:05:29,280 --> 00:05:35,070
in parallel<font color="#E5E5E5"> with the left half then we</font>

127
00:05:32,970 --> 00:05:38,160
wait for the left half<font color="#E5E5E5"> and then we just</font>

128
00:05:35,070 --> 00:05:39,930
built<font color="#E5E5E5"> the sum from left and right that's</font>

129
00:05:38,160 --> 00:05:43,169
<font color="#CCCCCC">one way how to express</font><font color="#E5E5E5"> a parallel</font>

130
00:05:39,930 --> 00:05:45,300
<font color="#E5E5E5">program what's important to realize</font><font color="#CCCCCC"> here</font>

131
00:05:43,169 --> 00:05:47,520
<font color="#CCCCCC">realized here is is that we</font><font color="#E5E5E5"> have two</font>

132
00:05:45,300 --> 00:05:50,070
<font color="#E5E5E5">recursive call</font><font color="#CCCCCC"> to the sum function</font>

133
00:05:47,520 --> 00:05:52,289
itself so in every recursive<font color="#E5E5E5"> call we do</font>

134
00:05:50,070 --> 00:05:54,210
the<font color="#E5E5E5"> same thing again is this now below</font>

135
00:05:52,290 --> 00:05:56,729
the threshold<font color="#E5E5E5"> then we just do the</font>

136
00:05:54,210 --> 00:05:58,680
sequential<font color="#E5E5E5"> version if it's not below the</font>

137
00:05:56,729 --> 00:06:03,450
<font color="#CCCCCC">threshold we split it up</font><font color="#E5E5E5"> in two halves</font>

138
00:05:58,680 --> 00:06:05,430
again<font color="#E5E5E5"> this creates a task tree</font>

139
00:06:03,450 --> 00:06:08,039
this is what the<font color="#E5E5E5"> notion of</font><font color="#CCCCCC"> divide and</font>

140
00:06:05,430 --> 00:06:10,620
<font color="#CCCCCC">conquer</font><font color="#E5E5E5"> task parallelism means so we</font>

141
00:06:08,040 --> 00:06:13,650
<font color="#E5E5E5">displayed up our problem into smaller</font>

142
00:06:10,620 --> 00:06:16,770
and smaller<font color="#E5E5E5"> pieces</font><font color="#CCCCCC"> until we arrive at</font>

143
00:06:13,650 --> 00:06:18,239
<font color="#E5E5E5">Leafs that we can do sequentially now</font>

144
00:06:16,770 --> 00:06:20,159
this looks<font color="#E5E5E5"> like a little bit of too much</font>

145
00:06:18,240 --> 00:06:22,170
<font color="#E5E5E5">overhead why do we just create such a</font>

146
00:06:20,160 --> 00:06:23,730
task tree why don't we just<font color="#E5E5E5"> split it up</font>

147
00:06:22,170 --> 00:06:26,340
by<font color="#E5E5E5"> the number of course and be done with</font>

148
00:06:23,730 --> 00:06:28,650
<font color="#CCCCCC">it</font><font color="#E5E5E5"> well the beautiful thing</font><font color="#CCCCCC"> about these</font>

149
00:06:26,340 --> 00:06:32,580
kind<font color="#E5E5E5"> of task trees is that</font><font color="#CCCCCC"> they are very</font>

150
00:06:28,650 --> 00:06:34,530
very<font color="#E5E5E5"> flexible to schedule let's assume</font>

151
00:06:32,580 --> 00:06:36,240
you're on a system so we're looking at

152
00:06:34,530 --> 00:06:38,520
<font color="#E5E5E5">this</font><font color="#CCCCCC"> without the with the other calls</font>

153
00:06:36,240 --> 00:06:43,110
let's assume we<font color="#CCCCCC"> are in a system</font><font color="#E5E5E5"> with 16</font>

154
00:06:38,520 --> 00:06:44,969
cores<font color="#E5E5E5"> here we have 16 leaves so each</font>

155
00:06:43,110 --> 00:06:49,610
core<font color="#CCCCCC"> can take care</font><font color="#E5E5E5"> of one</font><font color="#CCCCCC"> of those</font>

156
00:06:44,970 --> 00:06:52,980
leaves now assume we have<font color="#CCCCCC"> four cores</font>

157
00:06:49,610 --> 00:06:55,710
<font color="#E5E5E5">then each core</font><font color="#CCCCCC"> can take care</font><font color="#E5E5E5"> of one of</font>

158
00:06:52,980 --> 00:06:57,600
<font color="#CCCCCC">the</font><font color="#E5E5E5"> sub trees of this tree so here we</font>

159
00:06:55,710 --> 00:07:00,180
already<font color="#E5E5E5"> see</font><font color="#CCCCCC"> that no</font><font color="#E5E5E5"> matter how many</font>

160
00:06:57,600 --> 00:07:03,180
<font color="#E5E5E5">course we have it can flexibly adapt to</font>

161
00:07:00,180 --> 00:07:04,590
how many<font color="#E5E5E5"> nodes that can</font><font color="#CCCCCC"> process and if</font>

162
00:07:03,180 --> 00:07:07,230
in the more course we have the finer

163
00:07:04,590 --> 00:07:09,750
<font color="#E5E5E5">grained it becomes but what's even more</font>

164
00:07:07,230 --> 00:07:12,660
important is we<font color="#E5E5E5"> assembly in simplicity</font>

165
00:07:09,750 --> 00:07:14,820
<font color="#E5E5E5">made the assumption that each of the</font>

166
00:07:12,660 --> 00:07:17,730
leaves<font color="#E5E5E5"> more or less takes the same</font>

167
00:07:14,820 --> 00:07:18,240
amount<font color="#CCCCCC"> of time but is</font><font color="#E5E5E5"> very</font><font color="#CCCCCC"> often</font><font color="#E5E5E5"> not the</font>

168
00:07:17,730 --> 00:07:19,980
case

169
00:07:18,240 --> 00:07:22,050
very often the leaves have different

170
00:07:19,980 --> 00:07:24,480
runtimes<font color="#E5E5E5"> this is when you talk</font><font color="#CCCCCC"> about</font>

171
00:07:22,050 --> 00:07:25,800
load imbalance in<font color="#E5E5E5"> parallel</font><font color="#CCCCCC"> programming</font>

172
00:07:24,480 --> 00:07:28,200
which is a big issue in<font color="#E5E5E5"> parallel</font>

173
00:07:25,800 --> 00:07:31,800
programming with this kind of task tree

174
00:07:28,200 --> 00:07:33,930
it's very easy<font color="#E5E5E5"> to solve some of the</font>

175
00:07:31,800 --> 00:07:36,000
course will just take care<font color="#CCCCCC"> of the</font>

176
00:07:33,930 --> 00:07:38,580
heavyweight<font color="#E5E5E5"> leaves which just takes</font>

177
00:07:36,000 --> 00:07:40,920
longer<font color="#CCCCCC"> and at the</font><font color="#E5E5E5"> same time some</font><font color="#CCCCCC"> of the</font>

178
00:07:38,580 --> 00:07:43,590
other course will just take care<font color="#CCCCCC"> of more</font>

179
00:07:40,920 --> 00:07:45,810
tasks<font color="#E5E5E5"> until</font><font color="#CCCCCC"> the whole program is done</font>

180
00:07:43,590 --> 00:07:47,640
<font color="#E5E5E5">and this is a very beautiful and elegant</font>

181
00:07:45,810 --> 00:07:49,830
<font color="#E5E5E5">solution</font><font color="#CCCCCC"> for dealing with load and</font>

182
00:07:47,640 --> 00:07:53,969
balance and as I said<font color="#CCCCCC"> this happens much</font>

183
00:07:49,830 --> 00:07:55,919
more often<font color="#E5E5E5"> than</font><font color="#CCCCCC"> you might think so task</font>

184
00:07:53,970 --> 00:07:58,980
based parallelism<font color="#CCCCCC"> allows</font><font color="#E5E5E5"> for flexible</font>

185
00:07:55,920 --> 00:08:01,410
distribution of work over CPU cores<font color="#E5E5E5"> if</font>

186
00:07:58,980 --> 00:08:02,910
the typical case<font color="#CCCCCC"> what-what lots of</font>

187
00:08:01,410 --> 00:08:04,770
newbies typically do when<font color="#E5E5E5"> they do</font>

188
00:08:02,910 --> 00:08:07,620
parallel<font color="#E5E5E5"> programming by just</font><font color="#CCCCCC"> dividing</font>

189
00:08:04,770 --> 00:08:10,020
the number<font color="#E5E5E5"> of the work over the CPU</font>

190
00:08:07,620 --> 00:08:13,650
cores statically typically leads<font color="#E5E5E5"> to bad</font>

191
00:08:10,020 --> 00:08:15,469
performance and it's not optimal but

192
00:08:13,650 --> 00:08:18,590
what I haven't<font color="#E5E5E5"> explained</font><font color="#CCCCCC"> it is how do we</font>

193
00:08:15,470 --> 00:08:20,390
actually<font color="#E5E5E5"> scheduled the tasks tree so I</font>

194
00:08:18,590 --> 00:08:22,460
just said we can schedule it over

195
00:08:20,390 --> 00:08:27,770
multiple<font color="#CCCCCC"> course flexibly but we</font><font color="#E5E5E5"> haven't</font>

196
00:08:22,460 --> 00:08:29,900
yet explained how so the elegant

197
00:08:27,770 --> 00:08:32,210
solution for that is<font color="#CCCCCC"> work-stealing</font>

198
00:08:29,900 --> 00:08:34,429
so work-stealing is a known concept<font color="#E5E5E5"> at</font>

199
00:08:32,210 --> 00:08:37,219
least since<font color="#E5E5E5"> the 80s formalized in the</font>

200
00:08:34,429 --> 00:08:39,260
90s<font color="#E5E5E5"> he has two really excellent papers</font>

201
00:08:37,219 --> 00:08:40,909
that explain what works dealing<font color="#E5E5E5"> thus and</font>

202
00:08:39,260 --> 00:08:42,950
the idea here<font color="#CCCCCC"> is</font><font color="#E5E5E5"> this that each core</font>

203
00:08:40,909 --> 00:08:45,110
basically<font color="#E5E5E5"> looks for work and steals</font>

204
00:08:42,950 --> 00:08:46,520
whatever it can do<font color="#E5E5E5"> this has been</font>

205
00:08:45,110 --> 00:08:48,920
successfully<font color="#E5E5E5"> implemented in many</font>

206
00:08:46,520 --> 00:08:51,050
programming languages<font color="#E5E5E5"> and libraries it</font>

207
00:08:48,920 --> 00:08:53,030
has been<font color="#E5E5E5"> implemented in silk for C this</font>

208
00:08:51,050 --> 00:08:54,439
is<font color="#E5E5E5"> the most famous one has been</font>

209
00:08:53,030 --> 00:08:57,050
implemented as threading building blocks

210
00:08:54,440 --> 00:08:58,820
<font color="#E5E5E5">for C++ it has been implemented as Java</font>

211
00:08:57,050 --> 00:09:01,459
<font color="#CCCCCC">fork/join library which comes</font><font color="#E5E5E5"> with a</font>

212
00:08:58,820 --> 00:09:04,100
<font color="#E5E5E5">Java default library and it has been</font>

213
00:09:01,460 --> 00:09:05,870
<font color="#CCCCCC">implemented in goal</font><font color="#E5E5E5"> the scheduler for</font>

214
00:09:04,100 --> 00:09:07,400
goal routines in<font color="#CCCCCC"> the standard</font>

215
00:09:05,870 --> 00:09:09,500
implementation of<font color="#CCCCCC"> code is actually a</font>

216
00:09:07,400 --> 00:09:11,420
work staining scheduler and this was the

217
00:09:09,500 --> 00:09:12,980
main reason<font color="#CCCCCC"> why we became so</font><font color="#E5E5E5"> excited</font>

218
00:09:11,420 --> 00:09:15,439
about<font color="#E5E5E5"> go to use it for our</font><font color="#CCCCCC"> purlins</font>

219
00:09:12,980 --> 00:09:19,100
programming tasks so what<font color="#E5E5E5"> does it look</font>

220
00:09:15,440 --> 00:09:21,590
<font color="#E5E5E5">like assume you have four cores and one</font>

221
00:09:19,100 --> 00:09:23,900
of the<font color="#CCCCCC"> core starts working on creating</font>

222
00:09:21,590 --> 00:09:25,880
such a task tree<font color="#E5E5E5"> so what it does is is</font>

223
00:09:23,900 --> 00:09:28,819
there is<font color="#CCCCCC"> one</font><font color="#E5E5E5"> task which then spawns</font>

224
00:09:25,880 --> 00:09:31,490
<font color="#CCCCCC">another task</font><font color="#E5E5E5"> and at</font><font color="#CCCCCC"> the same</font><font color="#E5E5E5"> time the</font>

225
00:09:28,820 --> 00:09:34,520
other<font color="#CCCCCC"> cores are just asking</font><font color="#E5E5E5"> each other</font>

226
00:09:31,490 --> 00:09:37,850
<font color="#CCCCCC">do you have any work for</font><font color="#E5E5E5"> me to do one</font><font color="#CCCCCC"> of</font>

227
00:09:34,520 --> 00:09:39,560
the<font color="#CCCCCC"> cores will by chance pick one of the</font>

228
00:09:37,850 --> 00:09:42,560
tasks<font color="#E5E5E5"> from one of the other</font><font color="#CCCCCC"> cores and</font>

229
00:09:39,560 --> 00:09:45,140
just continue working<font color="#E5E5E5"> on that in the</font>

230
00:09:42,560 --> 00:09:48,189
<font color="#E5E5E5">next step the original core creates</font>

231
00:09:45,140 --> 00:09:51,439
<font color="#E5E5E5">another task and some other core</font><font color="#CCCCCC"> a</font>

232
00:09:48,190 --> 00:09:55,010
randomly<font color="#E5E5E5"> gets that task by just steaming</font>

233
00:09:51,440 --> 00:09:57,140
<font color="#E5E5E5">it from the first core and so on once</font>

234
00:09:55,010 --> 00:10:00,580
every<font color="#E5E5E5"> core is busy they're just</font>

235
00:09:57,140 --> 00:10:03,140
continuing<font color="#CCCCCC"> to work on</font><font color="#E5E5E5"> their</font><font color="#CCCCCC"> own tasks</font>

236
00:10:00,580 --> 00:10:06,110
creating two new tasks<font color="#E5E5E5"> finishing other</font>

237
00:10:03,140 --> 00:10:08,089
tasks until<font color="#CCCCCC"> one core may be</font><font color="#E5E5E5"> empty and</font>

238
00:10:06,110 --> 00:10:10,370
then it just start looking<font color="#CCCCCC"> again does</font>

239
00:10:08,089 --> 00:10:15,200
anybody have work to do and<font color="#E5E5E5"> just steals</font>

240
00:10:10,370 --> 00:10:18,290
it randomly<font color="#CCCCCC"> and continues so this</font><font color="#E5E5E5"> is how</font>

241
00:10:15,200 --> 00:10:21,200
<font color="#CCCCCC">work ceiling very roughly works there's</font>

242
00:10:18,290 --> 00:10:23,180
lots of details<font color="#E5E5E5"> technical details to</font>

243
00:10:21,200 --> 00:10:24,470
make<font color="#E5E5E5"> sure it's</font><font color="#CCCCCC"> really efficient but</font>

244
00:10:23,180 --> 00:10:27,020
what's<font color="#E5E5E5"> really beautiful about</font><font color="#CCCCCC"> work</font>

245
00:10:24,470 --> 00:10:29,930
<font color="#CCCCCC">ceiling is you don't need to plan any</font>

246
00:10:27,020 --> 00:10:32,540
thing these kind of work distributions

247
00:10:29,930 --> 00:10:35,479
<font color="#CCCCCC">that deal with load imbalance basically</font>

248
00:10:32,540 --> 00:10:38,510
just emerge out of<font color="#E5E5E5"> course randomly</font>

249
00:10:35,480 --> 00:10:40,010
looking for work and it's known<font color="#E5E5E5"> based on</font>

250
00:10:38,510 --> 00:10:42,350
<font color="#E5E5E5">these papers</font><font color="#CCCCCC"> that have shown</font><font color="#E5E5E5"> that this</font>

251
00:10:40,010 --> 00:10:43,330
<font color="#CCCCCC">is actually optimal you can't do better</font>

252
00:10:42,350 --> 00:10:46,880
<font color="#CCCCCC">than that</font>

253
00:10:43,330 --> 00:10:49,910
that's what why I believe<font color="#E5E5E5"> go probably</font>

254
00:10:46,880 --> 00:10:53,180
<font color="#E5E5E5">uses this and why</font><font color="#CCCCCC"> we're</font><font color="#E5E5E5"> very happy that</font>

255
00:10:49,910 --> 00:10:54,920
<font color="#CCCCCC">this</font><font color="#E5E5E5"> is available in</font><font color="#CCCCCC"> goal</font><font color="#E5E5E5"> so now back</font><font color="#CCCCCC"> to</font>

256
00:10:53,180 --> 00:10:58,120
<font color="#CCCCCC">our original</font><font color="#E5E5E5"> example what</font><font color="#CCCCCC"> you see in</font>

257
00:10:54,920 --> 00:11:00,589
this<font color="#E5E5E5"> code is this</font><font color="#CCCCCC"> there's a lot</font><font color="#E5E5E5"> of a</font>

258
00:10:58,120 --> 00:11:03,730
management<font color="#E5E5E5"> code that just makes sure</font>

259
00:11:00,590 --> 00:11:06,620
<font color="#CCCCCC">that</font><font color="#E5E5E5"> we can this create work distributed</font>

260
00:11:03,730 --> 00:11:08,780
spawn it make sure<font color="#CCCCCC"> that it we wait for</font>

261
00:11:06,620 --> 00:11:11,120
<font color="#E5E5E5">it and so on so lots of code that we're</font>

262
00:11:08,780 --> 00:11:13,699
not<font color="#CCCCCC"> really interested</font><font color="#E5E5E5"> in and this is</font>

263
00:11:11,120 --> 00:11:15,560
<font color="#CCCCCC">what</font><font color="#E5E5E5"> Pargo comes in</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> Pargo uses this</font>

264
00:11:13,700 --> 00:11:18,140
notion of divide and conquer task

265
00:11:15,560 --> 00:11:21,140
parallelism<font color="#E5E5E5"> and then gives you a couple</font>

266
00:11:18,140 --> 00:11:24,170
of higher level functions<font color="#E5E5E5"> to easier to</font>

267
00:11:21,140 --> 00:11:26,870
make<font color="#E5E5E5"> it easier to</font><font color="#CCCCCC"> use this so in parvo</font>

268
00:11:24,170 --> 00:11:29,060
<font color="#E5E5E5">the same program looks like this and</font>

269
00:11:26,870 --> 00:11:31,790
under the hood essentially has<font color="#CCCCCC"> the same</font>

270
00:11:29,060 --> 00:11:33,680
implementation so here it is a

271
00:11:31,790 --> 00:11:36,589
particularly example is an example<font color="#CCCCCC"> for a</font>

272
00:11:33,680 --> 00:11:39,979
<font color="#E5E5E5">range reduction so we arranged over</font><font color="#CCCCCC"> a</font>

273
00:11:36,590 --> 00:11:41,330
slice and<font color="#E5E5E5"> we</font><font color="#CCCCCC"> reduced it so reduction is</font>

274
00:11:39,980 --> 00:11:44,270
a term that<font color="#E5E5E5"> is known in parallel</font>

275
00:11:41,330 --> 00:11:47,180
programming reduce we reduce many values

276
00:11:44,270 --> 00:11:48,890
to a single value<font color="#E5E5E5"> this doesn't have</font>

277
00:11:47,180 --> 00:11:51,160
<font color="#E5E5E5">anything to do with Hadoop MapReduce or</font>

278
00:11:48,890 --> 00:11:54,470
so this is a parallel programming term

279
00:11:51,160 --> 00:11:57,050
and then<font color="#E5E5E5"> we need the base case which is</font>

280
00:11:54,470 --> 00:12:00,620
a sequential base case<font color="#E5E5E5"> this gets called</font>

281
00:11:57,050 --> 00:12:02,660
by the brow by<font color="#E5E5E5"> peril and Pargo tells it</font>

282
00:12:00,620 --> 00:12:06,080
<font color="#E5E5E5">which part of the slice should I be</font>

283
00:12:02,660 --> 00:12:07,910
looking<font color="#CCCCCC"> at and then you</font><font color="#E5E5E5"> need a reduction</font>

284
00:12:06,080 --> 00:12:09,650
function which just<font color="#CCCCCC"> tells it</font><font color="#E5E5E5"> tells the</font>

285
00:12:07,910 --> 00:12:11,930
<font color="#CCCCCC">partner library okay if I have two</font>

286
00:12:09,650 --> 00:12:15,680
results<font color="#CCCCCC"> how do I combine them</font><font color="#E5E5E5"> well I</font>

287
00:12:11,930 --> 00:12:17,569
just add them so this does<font color="#CCCCCC"> exactly what</font>

288
00:12:15,680 --> 00:12:18,890
I described<font color="#E5E5E5"> before under the hood just</font>

289
00:12:17,570 --> 00:12:20,720
makes<font color="#E5E5E5"> it much easier and much</font><font color="#CCCCCC"> more</font>

290
00:12:18,890 --> 00:12:22,750
elegant<font color="#CCCCCC"> to be</font><font color="#E5E5E5"> described it at a higher</font>

291
00:12:20,720 --> 00:12:22,750
level

292
00:12:24,940 --> 00:12:28,270
so this is where all<font color="#CCCCCC"> these</font>

293
00:12:26,820 --> 00:12:31,420
<font color="#E5E5E5">functionalities that are already</font>

294
00:12:28,270 --> 00:12:33,910
<font color="#E5E5E5">sketched coming to play so</font><font color="#CCCCCC"> we have a</font>

295
00:12:31,420 --> 00:12:36,969
<font color="#E5E5E5">simple parallel do which responds a</font>

296
00:12:33,910 --> 00:12:39,790
couple of<font color="#CCCCCC"> guru's functions we have</font>

297
00:12:36,970 --> 00:12:42,400
<font color="#CCCCCC">ranges which don't produce</font><font color="#E5E5E5"> a result we</font>

298
00:12:39,790 --> 00:12:45,099
have reductions<font color="#E5E5E5"> over</font><font color="#CCCCCC"> int float strings</font>

299
00:12:42,400 --> 00:12:47,050
<font color="#E5E5E5">and generic interface we have range</font>

300
00:12:45,100 --> 00:12:49,450
reductions over<font color="#E5E5E5"> int float string and</font>

301
00:12:47,050 --> 00:12:53,020
generic interface<font color="#E5E5E5"> we have</font><font color="#CCCCCC"> the boolean</font>

302
00:12:49,450 --> 00:12:54,550
functions we have speculative versions

303
00:12:53,020 --> 00:12:56,590
which are<font color="#E5E5E5"> specially interesting with the</font>

304
00:12:54,550 --> 00:12:58,780
<font color="#E5E5E5">boolean functions because he can make</font>

305
00:12:56,590 --> 00:13:01,840
sure<font color="#CCCCCC"> that the tree stops executing as</font>

306
00:12:58,780 --> 00:13:04,510
soon as you already<font color="#CCCCCC"> know</font><font color="#E5E5E5"> the result we</font>

307
00:13:01,840 --> 00:13:06,070
have sequential<font color="#CCCCCC"> variance which is not</font>

308
00:13:04,510 --> 00:13:08,550
supposed to<font color="#E5E5E5"> be used in production code</font>

309
00:13:06,070 --> 00:13:11,320
but it can be used when<font color="#E5E5E5"> you want to</font>

310
00:13:08,550 --> 00:13:14,680
debug<font color="#CCCCCC"> your programs</font><font color="#E5E5E5"> especially when you</font>

311
00:13:11,320 --> 00:13:16,150
like want to do print<font color="#E5E5E5"> line debugging we</font>

312
00:13:14,680 --> 00:13:18,400
have the quicksort and mergesort which

313
00:13:16,150 --> 00:13:21,939
are actually quite<font color="#E5E5E5"> complex algorithms so</font>

314
00:13:18,400 --> 00:13:25,209
we hide this<font color="#CCCCCC"> away from</font><font color="#E5E5E5"> you and parallel</font>

315
00:13:21,940 --> 00:13:27,610
hash tables<font color="#E5E5E5"> and pipelines now here again</font>

316
00:13:25,210 --> 00:13:29,770
<font color="#E5E5E5">people</font><font color="#CCCCCC"> may</font><font color="#E5E5E5"> wonder why do we need</font>

317
00:13:27,610 --> 00:13:32,740
parallel pipelines<font color="#E5E5E5"> go is already really</font>

318
00:13:29,770 --> 00:13:34,860
good<font color="#CCCCCC"> at pipelines</font><font color="#E5E5E5"> and that's true so</font>

319
00:13:32,740 --> 00:13:37,660
<font color="#E5E5E5">here's an</font><font color="#CCCCCC"> example of</font><font color="#E5E5E5"> a pipeline</font><font color="#CCCCCC"> in go</font>

320
00:13:34,860 --> 00:13:40,030
which I<font color="#CCCCCC"> took from a tutorial</font><font color="#E5E5E5"> it's a</font>

321
00:13:37,660 --> 00:13:42,610
<font color="#E5E5E5">two-stage pipeline the first stage that</font>

322
00:13:40,030 --> 00:13:44,410
<font color="#CCCCCC">gets a slice of numbers</font><font color="#E5E5E5"> and just creates</font>

323
00:13:42,610 --> 00:13:47,500
a channel<font color="#E5E5E5"> over which these numbers are</font>

324
00:13:44,410 --> 00:13:50,140
sent one after<font color="#CCCCCC"> the other</font><font color="#E5E5E5"> the next stage</font>

325
00:13:47,500 --> 00:13:52,360
<font color="#E5E5E5">takes</font><font color="#CCCCCC"> this channel of numbers</font><font color="#E5E5E5"> squares</font>

326
00:13:50,140 --> 00:13:54,670
each element and then sends the squared

327
00:13:52,360 --> 00:13:57,130
numbers to the to the<font color="#E5E5E5"> next</font><font color="#CCCCCC"> channel and</font>

328
00:13:54,670 --> 00:13:59,170
then here is a main<font color="#E5E5E5"> proper program just</font>

329
00:13:57,130 --> 00:14:02,110
reads the squared numbers and<font color="#E5E5E5"> prints</font>

330
00:13:59,170 --> 00:14:04,390
<font color="#E5E5E5">them out for a concurrent</font><font color="#CCCCCC"> program</font><font color="#E5E5E5"> this</font>

331
00:14:02,110 --> 00:14:07,510
is really beautiful<font color="#E5E5E5"> really elegant</font><font color="#CCCCCC"> to</font>

332
00:14:04,390 --> 00:14:09,189
read very<font color="#E5E5E5"> easy to work with from a</font>

333
00:14:07,510 --> 00:14:11,710
parallel perspective this<font color="#CCCCCC"> is not so</font>

334
00:14:09,190 --> 00:14:15,730
<font color="#E5E5E5">great because</font><font color="#CCCCCC"> we just created three go</font>

335
00:14:11,710 --> 00:14:18,120
routines<font color="#CCCCCC"> now if you have 16 cores</font><font color="#E5E5E5"> there</font>

336
00:14:15,730 --> 00:14:20,710
is now 13 cores that don't do<font color="#CCCCCC"> anything</font>

337
00:14:18,120 --> 00:14:22,270
but you want<font color="#E5E5E5"> to</font><font color="#CCCCCC"> keep</font><font color="#E5E5E5"> them busy because</font>

338
00:14:20,710 --> 00:14:24,700
you're interested<font color="#CCCCCC"> in taking</font><font color="#E5E5E5"> advantage of</font>

339
00:14:22,270 --> 00:14:26,410
them for performance<font color="#E5E5E5"> so you would like</font>

340
00:14:24,700 --> 00:14:28,450
to<font color="#E5E5E5"> distribute the work a bit</font><font color="#CCCCCC"> differently</font>

341
00:14:26,410 --> 00:14:31,390
when you're thinking about a<font color="#E5E5E5"> parallel</font>

342
00:14:28,450 --> 00:14:33,280
program<font color="#E5E5E5"> so from a so I'm not saying this</font>

343
00:14:31,390 --> 00:14:34,780
<font color="#E5E5E5">is bad for concurrent programming this</font>

344
00:14:33,280 --> 00:14:36,569
<font color="#CCCCCC">is really elegant because you're</font>

345
00:14:34,780 --> 00:14:38,400
probably<font color="#E5E5E5"> also dealing with many of</font>

346
00:14:36,570 --> 00:14:39,720
these pipelines at the same time so

347
00:14:38,400 --> 00:14:42,120
<font color="#E5E5E5">you're already creating</font><font color="#CCCCCC"> a lot of work</font>

348
00:14:39,720 --> 00:14:43,380
but<font color="#E5E5E5"> for parallel perspective is this</font>

349
00:14:42,120 --> 00:14:45,270
quite likely<font color="#CCCCCC"> that this</font><font color="#E5E5E5"> is the only</font>

350
00:14:43,380 --> 00:14:48,390
pipeline and then you want<font color="#E5E5E5"> to distribute</font>

351
00:14:45,270 --> 00:14:54,600
<font color="#CCCCCC">to</font><font color="#E5E5E5"> work differently so here is a</font>

352
00:14:48,390 --> 00:14:55,439
<font color="#E5E5E5">pipeline in Pargo what we do here is is</font>

353
00:14:54,600 --> 00:14:58,580
this<font color="#E5E5E5"> week</font>

354
00:14:55,440 --> 00:15:01,800
<font color="#CCCCCC">Pargo a pipeline</font><font color="#E5E5E5"> as a data structure the</font>

355
00:14:58,580 --> 00:15:03,510
null value<font color="#CCCCCC"> it can already be used we</font>

356
00:15:01,800 --> 00:15:05,640
give<font color="#E5E5E5"> it a source in this case</font><font color="#CCCCCC"> as</font><font color="#E5E5E5"> the</font>

357
00:15:03,510 --> 00:15:07,290
silly source it's a slice of<font color="#CCCCCC"> two numbers</font>

358
00:15:05,640 --> 00:15:08,880
of course<font color="#E5E5E5"> you wouldn't use a parallel</font>

359
00:15:07,290 --> 00:15:11,520
pipeline for<font color="#E5E5E5"> a slice of two numbers is</font>

360
00:15:08,880 --> 00:15:13,620
<font color="#CCCCCC">just for an example then you can add</font>

361
00:15:11,520 --> 00:15:18,180
stages the first stage<font color="#E5E5E5"> is a parallel</font>

362
00:15:13,620 --> 00:15:21,180
stage it receives a batch<font color="#E5E5E5"> of numbers</font>

363
00:15:18,180 --> 00:15:24,000
<font color="#E5E5E5">it's hidden behind an interface because</font>

364
00:15:21,180 --> 00:15:27,030
it's the<font color="#CCCCCC"> only way in go</font><font color="#E5E5E5"> to declare</font>

365
00:15:24,000 --> 00:15:29,730
something<font color="#E5E5E5"> generic it unpacks that data</font>

366
00:15:27,030 --> 00:15:31,829
into a slice of numbers then<font color="#E5E5E5"> modifies</font>

367
00:15:29,730 --> 00:15:35,460
<font color="#E5E5E5">this in place to build a square for</font><font color="#CCCCCC"> each</font>

368
00:15:31,830 --> 00:15:38,040
<font color="#CCCCCC">number and then the next stage is an</font>

369
00:15:35,460 --> 00:15:40,350
ordered stage<font color="#E5E5E5"> or that stage means it's</font>

370
00:15:38,040 --> 00:15:43,290
sequential so this stage<font color="#E5E5E5"> doesn't run in</font>

371
00:15:40,350 --> 00:15:46,380
<font color="#CCCCCC">parallel and it is executed in exactly</font>

372
00:15:43,290 --> 00:15:49,020
the same<font color="#E5E5E5"> order as this source of the</font>

373
00:15:46,380 --> 00:15:51,720
pipeline<font color="#CCCCCC"> and here we can just print out</font>

374
00:15:49,020 --> 00:15:54,270
<font color="#E5E5E5">the result what's nice about this here</font>

375
00:15:51,720 --> 00:15:56,340
is now<font color="#CCCCCC"> that in the back we again use</font>

376
00:15:54,270 --> 00:16:00,150
<font color="#E5E5E5">this a principle of divide and conquer</font>

377
00:15:56,340 --> 00:16:03,810
<font color="#CCCCCC">past parallelism</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> split up</font><font color="#E5E5E5"> the inputs</font>

378
00:16:00,150 --> 00:16:06,030
into<font color="#CCCCCC"> batches and create more batches</font>

379
00:16:03,810 --> 00:16:07,500
than<font color="#E5E5E5"> a course available</font><font color="#CCCCCC"> so that the work</font>

380
00:16:06,030 --> 00:16:10,380
stealing scheduler can<font color="#E5E5E5"> actually</font>

381
00:16:07,500 --> 00:16:12,000
optimally schedule them<font color="#E5E5E5"> and this is how</font>

382
00:16:10,380 --> 00:16:15,240
you can take<font color="#E5E5E5"> advantage</font><font color="#CCCCCC"> of all your</font>

383
00:16:12,000 --> 00:16:19,410
course<font color="#E5E5E5"> I I forgot in</font><font color="#CCCCCC"> the end you just</font>

384
00:16:15,240 --> 00:16:21,000
run this so what you<font color="#E5E5E5"> have in the</font>

385
00:16:19,410 --> 00:16:23,130
parallel<font color="#E5E5E5"> pipe lines in Pargo you have</font>

386
00:16:21,000 --> 00:16:26,130
predefined<font color="#E5E5E5"> pipeline sources for</font><font color="#CCCCCC"> erase</font>

387
00:16:23,130 --> 00:16:30,330
slices strings<font color="#E5E5E5"> channels and</font><font color="#CCCCCC"> buffaio</font>

388
00:16:26,130 --> 00:16:32,220
scanner<font color="#CCCCCC"> so for scanning text files you</font>

389
00:16:30,330 --> 00:16:34,410
have<font color="#E5E5E5"> support for user-defined sources</font>

390
00:16:32,220 --> 00:16:36,270
through the source interface<font color="#E5E5E5"> you have</font>

391
00:16:34,410 --> 00:16:39,959
<font color="#E5E5E5">support for several kinds of</font><font color="#CCCCCC"> nodes or</font>

392
00:16:36,270 --> 00:16:42,660
stages so sequential ordered with a

393
00:16:39,960 --> 00:16:44,760
guaranteed order parallel<font color="#E5E5E5"> you also have</font>

394
00:16:42,660 --> 00:16:46,410
<font color="#E5E5E5">strictly ordered and limited parallel</font>

395
00:16:44,760 --> 00:16:47,700
which gives you a way to control how

396
00:16:46,410 --> 00:16:49,770
<font color="#E5E5E5">much memory is used</font>

397
00:16:47,700 --> 00:16:49,980
you have skip and limit nodes where you

398
00:16:49,770 --> 00:16:52,199
can

399
00:16:49,980 --> 00:16:53,550
skip elements or you<font color="#CCCCCC"> can limit</font><font color="#E5E5E5"> how</font><font color="#CCCCCC"> many</font>

400
00:16:52,200 --> 00:16:56,040
elements<font color="#E5E5E5"> you want to see over</font><font color="#CCCCCC"> the</font>

401
00:16:53,550 --> 00:16:58,349
<font color="#E5E5E5">lifetime you have support for</font><font color="#CCCCCC"> several</font>

402
00:16:56,040 --> 00:17:00,780
kinds of<font color="#E5E5E5"> filters so generic receive and</font>

403
00:16:58,350 --> 00:17:04,349
<font color="#CCCCCC">finalize boolean filters where you can</font>

404
00:17:00,780 --> 00:17:06,359
ask<font color="#E5E5E5"> only run as</font><font color="#CCCCCC"> long as every package</font>

405
00:17:04,349 --> 00:17:08,669
<font color="#E5E5E5">has her further fulfills a certain</font>

406
00:17:06,359 --> 00:17:10,500
condition<font color="#E5E5E5"> if counting filter is just</font>

407
00:17:08,670 --> 00:17:12,420
<font color="#E5E5E5">counting</font><font color="#CCCCCC"> how</font><font color="#E5E5E5"> many elements you see and</font>

408
00:17:10,500 --> 00:17:15,599
you have<font color="#E5E5E5"> slice filters</font><font color="#CCCCCC"> produced for</font>

409
00:17:12,420 --> 00:17:18,090
producing results slices<font color="#CCCCCC"> we also</font><font color="#E5E5E5"> support</font>

410
00:17:15,599 --> 00:17:20,899
contexts<font color="#E5E5E5"> with cancellation error</font>

411
00:17:18,089 --> 00:17:23,159
handling<font color="#CCCCCC"> go style</font><font color="#E5E5E5"> error handling and</font>

412
00:17:20,900 --> 00:17:26,100
<font color="#CCCCCC">fine-tuning of</font><font color="#E5E5E5"> batch sizes so we can</font>

413
00:17:23,160 --> 00:17:27,360
<font color="#E5E5E5">really tweak the performance all of</font>

414
00:17:26,099 --> 00:17:30,600
these features<font color="#E5E5E5"> are not just something</font>

415
00:17:27,359 --> 00:17:33,060
that<font color="#CCCCCC"> we just</font><font color="#E5E5E5"> made up and came up with we</font>

416
00:17:30,600 --> 00:17:35,070
actually<font color="#E5E5E5"> use this ourselves</font><font color="#CCCCCC"> so we have</font>

417
00:17:33,060 --> 00:17:36,210
one tool called<font color="#CCCCCC"> add prep which is a DNA</font>

418
00:17:35,070 --> 00:17:39,750
sequencing tool that we developed

419
00:17:36,210 --> 00:17:42,720
<font color="#CCCCCC">already</font><font color="#E5E5E5"> for a couple of years</font><font color="#CCCCCC"> it's a</font>

420
00:17:39,750 --> 00:17:44,760
high<font color="#CCCCCC"> performance tool for doing certain</font>

421
00:17:42,720 --> 00:17:45,300
steps and<font color="#E5E5E5"> there's DNA sequencing</font>

422
00:17:44,760 --> 00:17:47,610
pipeline

423
00:17:45,300 --> 00:17:50,879
<font color="#CCCCCC">it is a multi-threaded application that</font>

424
00:17:47,610 --> 00:17:53,159
runs typically something<font color="#CCCCCC"> like</font><font color="#E5E5E5"> 10 times</font>

425
00:17:50,880 --> 00:17:55,260
faster<font color="#E5E5E5"> than the standard tools and it</font>

426
00:17:53,160 --> 00:17:57,750
runs 10 times faster because we're using

427
00:17:55,260 --> 00:17:59,430
<font color="#E5E5E5">the Pargo pipelines and some of the</font>

428
00:17:57,750 --> 00:18:02,640
other<font color="#CCCCCC"> parameter</font><font color="#E5E5E5"> functionality that</font><font color="#CCCCCC"> I</font>

429
00:17:59,430 --> 00:18:04,920
just described<font color="#CCCCCC"> and it's implemented in</font>

430
00:18:02,640 --> 00:18:07,050
<font color="#CCCCCC">goes since version 3.0</font><font color="#E5E5E5"> and it's</font>

431
00:18:04,920 --> 00:18:10,080
<font color="#CCCCCC">available as an open source project here</font>

432
00:18:07,050 --> 00:18:11,879
at<font color="#E5E5E5"> this link</font><font color="#CCCCCC"> so we are really</font><font color="#E5E5E5"> we eating</font>

433
00:18:10,080 --> 00:18:13,830
our own dog<font color="#CCCCCC"> food and</font><font color="#E5E5E5"> we're making this</font>

434
00:18:11,880 --> 00:18:16,260
available<font color="#E5E5E5"> so you can also use</font><font color="#CCCCCC"> it in your</font>

435
00:18:13,830 --> 00:18:20,340
projects<font color="#CCCCCC"> so parva is available at this</font>

436
00:18:16,260 --> 00:18:23,100
URL<font color="#CCCCCC"> documentation is also</font><font color="#E5E5E5"> available so</font>

437
00:18:20,340 --> 00:18:25,080
the standard<font color="#CCCCCC"> API documentation and the</font>

438
00:18:23,100 --> 00:18:26,969
wiki which describes the concepts in a

439
00:18:25,080 --> 00:18:30,060
bit more detail<font color="#E5E5E5"> which can't easily be</font>

440
00:18:26,970 --> 00:18:34,230
<font color="#E5E5E5">described as API documentation</font><font color="#CCCCCC"> there's</font>

441
00:18:30,060 --> 00:18:37,490
also a link for<font color="#E5E5E5"> a prep and that's the</font>

442
00:18:34,230 --> 00:18:37,490
end<font color="#E5E5E5"> of my talk</font><font color="#CCCCCC"> thank you very</font><font color="#E5E5E5"> much</font>

443
00:18:38,020 --> 00:18:41,109
[Music]

444
00:18:43,419 --> 00:18:52,789
we have sure so my question is the code

445
00:18:50,240 --> 00:18:55,159
that<font color="#E5E5E5"> you showed</font><font color="#CCCCCC"> looked</font><font color="#E5E5E5"> like something</font>

446
00:18:52,789 --> 00:19:01,070
that<font color="#E5E5E5"> would benefit from generics what do</font>

447
00:18:55,159 --> 00:19:05,690
you think about contracts<font color="#CCCCCC"> I was hoping I</font>

448
00:19:01,070 --> 00:19:09,559
wouldn't get<font color="#E5E5E5"> that question</font><font color="#CCCCCC"> I'm not a big</font>

449
00:19:05,690 --> 00:19:11,419
fan<font color="#CCCCCC"> of generics and I think go would be</font>

450
00:19:09,559 --> 00:19:15,889
<font color="#E5E5E5">better off without generics because my</font>

451
00:19:11,419 --> 00:19:17,899
personal<font color="#CCCCCC"> conviction from a user</font>

452
00:19:15,889 --> 00:19:21,199
perspective from a user perspective

453
00:19:17,899 --> 00:19:23,600
generics look<font color="#CCCCCC"> elegant</font><font color="#E5E5E5"> but from a library</font>

454
00:19:21,200 --> 00:19:25,250
the provider<font color="#E5E5E5"> perspective it becomes</font>

455
00:19:23,600 --> 00:19:27,529
incredibly hard to write them correct

456
00:19:25,250 --> 00:19:29,179
<font color="#CCCCCC">and I'm not really happy about</font><font color="#E5E5E5"> the</font>

457
00:19:27,529 --> 00:19:32,809
current ideas around<font color="#E5E5E5"> the contracts</font>

458
00:19:29,179 --> 00:19:35,899
because<font color="#E5E5E5"> that was</font><font color="#CCCCCC"> just a hack in C++ the</font>

459
00:19:32,809 --> 00:19:38,418
kind of a<font color="#E5E5E5"> coincidental hack like many</font>

460
00:19:35,899 --> 00:19:40,668
<font color="#E5E5E5">things in C++ and I don't</font><font color="#CCCCCC"> think we</font>

461
00:19:38,419 --> 00:19:43,750
should imitate that in the<font color="#E5E5E5"> go</font><font color="#CCCCCC"> language</font>

462
00:19:40,669 --> 00:19:43,750
<font color="#E5E5E5">that's my personal opinion</font>

463
00:19:44,110 --> 00:19:52,879
<font color="#E5E5E5">okay I'm the microphone</font><font color="#CCCCCC"> runner myself do</font>

464
00:19:50,750 --> 00:19:57,549
you have any particular<font color="#E5E5E5"> performance</font>

465
00:19:52,880 --> 00:20:05,210
metrics<font color="#E5E5E5"> between some using Bargo</font>

466
00:19:57,549 --> 00:20:11,179
performance metrics between<font color="#CCCCCC"> four oh do</font>

467
00:20:05,210 --> 00:20:13,490
we<font color="#CCCCCC"> have numbers well yes so for the prep</font>

468
00:20:11,179 --> 00:20:16,580
for the<font color="#CCCCCC"> ED prep sequencing tool we</font>

469
00:20:13,490 --> 00:20:18,590
actually had a<font color="#E5E5E5"> paper for the previous</font>

470
00:20:16,580 --> 00:20:20,360
version<font color="#E5E5E5"> which was not</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> goal but we</font>

471
00:20:18,590 --> 00:20:22,370
just<font color="#E5E5E5"> got a notification that</font><font color="#CCCCCC"> it was now</font>

472
00:20:20,360 --> 00:20:24,320
accepted for the new version which<font color="#CCCCCC"> isn't</font>

473
00:20:22,370 --> 00:20:27,709
<font color="#CCCCCC">going</font><font color="#E5E5E5"> there we have performance numbers</font>

474
00:20:24,320 --> 00:20:31,370
<font color="#CCCCCC">I also we also did a study where</font><font color="#E5E5E5"> we</font>

475
00:20:27,710 --> 00:20:34,460
<font color="#E5E5E5">compared performance</font><font color="#CCCCCC"> between ghost C++</font>

476
00:20:31,370 --> 00:20:36,739
and Java<font color="#E5E5E5"> for exactly the tool which are</font>

477
00:20:34,460 --> 00:20:40,360
<font color="#E5E5E5">presented last year at first them</font><font color="#CCCCCC"> we're</font>

478
00:20:36,740 --> 00:20:45,610
go actually<font color="#E5E5E5"> came out as</font><font color="#CCCCCC"> the winner and</font>

479
00:20:40,360 --> 00:20:45,610
<font color="#E5E5E5">yeah so we</font><font color="#CCCCCC"> can find these numbers</font>

480
00:20:46,600 --> 00:20:49,649
other questions

481
00:20:52,210 --> 00:20:59,079
<font color="#E5E5E5">okay thank you very much</font>

482
00:20:53,650 --> 00:20:59,079
[Applause]

