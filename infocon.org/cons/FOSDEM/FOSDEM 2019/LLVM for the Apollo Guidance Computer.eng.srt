1
00:00:04,610 --> 00:00:09,879
<font color="#E5E5E5">okay thank you for coming I'm going to</font>

2
00:00:07,759 --> 00:00:12,320
speak about<font color="#E5E5E5"> the Apollo guidance computer</font>

3
00:00:09,879 --> 00:00:17,330
<font color="#CCCCCC">and my attempt to</font><font color="#E5E5E5"> write to nail him</font>

4
00:00:12,320 --> 00:00:20,600
<font color="#CCCCCC">back-end for</font><font color="#E5E5E5"> it so and can you introduce</font>

5
00:00:17,330 --> 00:00:23,240
myself a little<font color="#E5E5E5"> bit I'm studying at</font>

6
00:00:20,600 --> 00:00:26,380
University<font color="#CCCCCC"> of Bath</font><font color="#E5E5E5"> and I joined them</font>

7
00:00:23,240 --> 00:00:29,000
because<font color="#CCCCCC"> um last</font><font color="#E5E5E5"> year as a uksf scholar</font>

8
00:00:26,380 --> 00:00:31,549
<font color="#E5E5E5">I've been working primarily on</font><font color="#CCCCCC"> LLP</font><font color="#E5E5E5"> and</font>

9
00:00:29,000 --> 00:00:34,790
<font color="#CCCCCC">backends and I</font><font color="#E5E5E5"> started working</font><font color="#CCCCCC"> on this</font>

10
00:00:31,550 --> 00:00:37,729
<font color="#E5E5E5">AGC</font><font color="#CCCCCC"> backend in</font><font color="#E5E5E5"> October as a personal</font>

11
00:00:34,790 --> 00:00:39,860
project<font color="#CCCCCC"> um</font><font color="#E5E5E5"> so I'm gonna I'm gonna give a</font>

12
00:00:37,729 --> 00:00:47,210
bit<font color="#E5E5E5"> a little</font><font color="#CCCCCC"> bit</font><font color="#E5E5E5"> of a</font><font color="#CCCCCC"> background as to</font>

13
00:00:39,860 --> 00:00:50,229
<font color="#E5E5E5">what the AGC actually is I'll try yes</font>

14
00:00:47,210 --> 00:00:50,229
there's no speakers

15
00:00:54,180 --> 00:00:58,500
so the Apollo<font color="#E5E5E5"> guidance computer was</font>

16
00:00:56,579 --> 00:01:01,739
designed by the MIT instrumentation

17
00:00:58,500 --> 00:01:07,050
laboratory<font color="#CCCCCC"> for use by NASA</font><font color="#E5E5E5"> in their</font>

18
00:01:01,739 --> 00:01:09,210
<font color="#E5E5E5">Pollard program</font><font color="#CCCCCC"> they used it as a</font>

19
00:01:07,050 --> 00:01:10,920
<font color="#CCCCCC">general-purpose</font><font color="#E5E5E5"> controller in both the</font>

20
00:01:09,210 --> 00:01:14,339
command module in<font color="#E5E5E5"> lunar lander for all</font>

21
00:01:10,920 --> 00:01:16,490
the Apollo missions there were actually

22
00:01:14,340 --> 00:01:21,420
three versions of the agency developed

23
00:01:16,490 --> 00:01:25,169
<font color="#CCCCCC">two</font><font color="#E5E5E5"> for NASA and for actual</font><font color="#CCCCCC"> use one by</font>

24
00:01:21,420 --> 00:01:26,600
<font color="#CCCCCC">annex designer of the original AGC to</font>

25
00:01:25,170 --> 00:01:29,759
show what could<font color="#E5E5E5"> be done to overcome the</font>

26
00:01:26,600 --> 00:01:35,550
<font color="#E5E5E5">limitations of the second block team</font>

27
00:01:29,759 --> 00:01:38,520
<font color="#E5E5E5">model so firstly</font><font color="#CCCCCC"> the most important</font>

28
00:01:35,550 --> 00:01:39,990
thing to know<font color="#CCCCCC"> about the AGC AGC</font><font color="#E5E5E5"> is</font>

29
00:01:38,520 --> 00:01:43,890
<font color="#E5E5E5">registers there was no meaningful</font>

30
00:01:39,990 --> 00:01:48,270
<font color="#CCCCCC">concept of a register</font><font color="#E5E5E5"> all data was</font>

31
00:01:43,890 --> 00:01:49,920
mapped to memory locations and<font color="#E5E5E5"> in the</font>

32
00:01:48,270 --> 00:01:55,770
<font color="#E5E5E5">assembly registers were just defined as</font>

33
00:01:49,920 --> 00:01:57,390
aliases<font color="#CCCCCC"> to memory locations data</font><font color="#E5E5E5"> encode</font>

34
00:01:55,770 --> 00:01:58,908
shared the same<font color="#E5E5E5"> memory so</font><font color="#CCCCCC"> there's</font><font color="#E5E5E5"> a von</font>

35
00:01:57,390 --> 00:02:02,880
Neumann architecture

36
00:01:58,909 --> 00:02:06,060
however the memory was split into arrays

37
00:02:02,880 --> 00:02:13,500
Bullen fixed memory and code was

38
00:02:06,060 --> 00:02:15,450
generally<font color="#CCCCCC"> and fixed so the AGC has 15</font>

39
00:02:13,500 --> 00:02:18,600
bits<font color="#CCCCCC"> available to use for each 16-bit</font>

40
00:02:15,450 --> 00:02:20,250
word these were used<font color="#CCCCCC"> to represent</font><font color="#E5E5E5"> either</font>

41
00:02:18,600 --> 00:02:23,370
a<font color="#CCCCCC"> one's complement number or the</font>

42
00:02:20,250 --> 00:02:26,130
encoding of an instruction<font color="#E5E5E5"> the spare bit</font>

43
00:02:23,370 --> 00:02:28,650
was used as an odd parity bit which

44
00:02:26,130 --> 00:02:33,600
allowed the the<font color="#CCCCCC"> hardware to detect basic</font>

45
00:02:28,650 --> 00:02:36,930
bit errors adjacent words in memory

46
00:02:33,600 --> 00:02:39,239
<font color="#E5E5E5">could</font><font color="#CCCCCC"> be used as double words the sign</font>

47
00:02:36,930 --> 00:02:44,760
bit must match so this gave an effective

48
00:02:39,239 --> 00:02:46,380
<font color="#CCCCCC">29 bit</font><font color="#E5E5E5"> ones complement number some in</font>

49
00:02:44,760 --> 00:02:48,780
some instructions interpreted the data

50
00:02:46,380 --> 00:02:51,090
is<font color="#CCCCCC"> a fixed point and the most</font>

51
00:02:48,780 --> 00:02:53,489
significant<font color="#E5E5E5"> non sign bit represented a</font>

52
00:02:51,090 --> 00:02:58,620
half<font color="#E5E5E5"> this gives a range of plus</font><font color="#CCCCCC"> one to</font>

53
00:02:53,489 --> 00:03:01,049
minus<font color="#CCCCCC"> one so the instruction set</font>

54
00:02:58,620 --> 00:03:02,459
architecture of the AGC<font color="#CCCCCC"> is quite a</font>

55
00:03:01,049 --> 00:03:04,709
different<font color="#CCCCCC"> architecture to what we used</font>

56
00:03:02,459 --> 00:03:06,610
<font color="#E5E5E5">to do to the fact that there was a lack</font>

57
00:03:04,709 --> 00:03:08,710
<font color="#CCCCCC">of computing resources</font>

58
00:03:06,610 --> 00:03:11,710
and also the assembly was designed for

59
00:03:08,710 --> 00:03:15,180
programs and<font color="#CCCCCC"> not compilers so firstly</font>

60
00:03:11,710 --> 00:03:15,180
<font color="#E5E5E5">instructions are accumulator based</font>

61
00:03:15,390 --> 00:03:21,519
<font color="#E5E5E5">secondly many instructions have a very</font>

62
00:03:17,800 --> 00:03:23,410
complex operation<font color="#E5E5E5"> to squeeze in some</font>

63
00:03:21,520 --> 00:03:23,980
sort of higher level constructs<font color="#E5E5E5"> into</font>

64
00:03:23,410 --> 00:03:27,460
such a small

65
00:03:23,980 --> 00:03:30,850
<font color="#CCCCCC">icer</font><font color="#E5E5E5"> so for example can't compare and</font>

66
00:03:27,460 --> 00:03:33,190
skip has an operation where the first

67
00:03:30,850 --> 00:03:35,290
thing<font color="#E5E5E5"> it</font><font color="#CCCCCC"> does is load the diminished</font>

68
00:03:33,190 --> 00:03:37,810
absolute value of the<font color="#E5E5E5"> given memory</font>

69
00:03:35,290 --> 00:03:40,060
location into the accumulator<font color="#E5E5E5"> which</font>

70
00:03:37,810 --> 00:03:44,950
means basically<font color="#E5E5E5"> increment or decrement</font>

71
00:03:40,060 --> 00:03:47,790
towards<font color="#E5E5E5"> zero</font><font color="#CCCCCC"> then rewrite the original</font>

72
00:03:44,950 --> 00:03:50,500
value back to<font color="#E5E5E5"> the</font><font color="#CCCCCC"> memory location</font>

73
00:03:47,790 --> 00:03:53,640
because some memory locations<font color="#E5E5E5"> modify</font>

74
00:03:50,500 --> 00:03:56,050
their contents on<font color="#E5E5E5"> right back</font><font color="#CCCCCC"> and finally</font>

75
00:03:53,640 --> 00:03:59,170
adjust the program<font color="#CCCCCC"> counter according to</font>

76
00:03:56,050 --> 00:04:01,600
the contents of accumulator<font color="#E5E5E5"> so if it's</font>

77
00:03:59,170 --> 00:04:03,670
<font color="#E5E5E5">greater than zip plus</font><font color="#CCCCCC"> zero then you add</font>

78
00:04:01,600 --> 00:04:06,190
<font color="#E5E5E5">one if it's equal to plus zero you add</font>

79
00:04:03,670 --> 00:04:08,049
two if it's less<font color="#CCCCCC"> than minus zero you add</font>

80
00:04:06,190 --> 00:04:11,859
three if it's equal<font color="#CCCCCC"> to minus zero you</font>

81
00:04:08,050 --> 00:04:16,329
<font color="#CCCCCC">have four extending index</font><font color="#E5E5E5"> were basically</font>

82
00:04:11,860 --> 00:04:23,200
<font color="#E5E5E5">used to modify the the</font><font color="#CCCCCC"> next instruction</font>

83
00:04:16,329 --> 00:04:27,130
in some way<font color="#E5E5E5"> also the assembly syntax was</font>

84
00:04:23,200 --> 00:04:29,320
quite<font color="#E5E5E5"> different to what</font><font color="#CCCCCC"> we use now</font><font color="#E5E5E5"> is it</font>

85
00:04:27,130 --> 00:04:31,180
it seems simple<font color="#CCCCCC"> but it's not it's not</font>

86
00:04:29,320 --> 00:04:34,930
<font color="#CCCCCC">going to like so it's</font><font color="#E5E5E5"> difficult for</font>

87
00:04:31,180 --> 00:04:37,479
<font color="#E5E5E5">parsers one thing to note is every</font>

88
00:04:34,930 --> 00:04:44,140
single<font color="#CCCCCC"> thing on this</font><font color="#E5E5E5"> on this slide is a</font>

89
00:04:37,479 --> 00:04:47,830
valid identifier so why would I choose

90
00:04:44,140 --> 00:04:50,320
to write an<font color="#E5E5E5"> elevation for this so</font>

91
00:04:47,830 --> 00:04:52,450
firstly the the original<font color="#CCCCCC"> engineers that</font>

92
00:04:50,320 --> 00:04:54,150
<font color="#E5E5E5">wrote the programming code for the AGC</font>

93
00:04:52,450 --> 00:04:56,320
were amazingly talented

94
00:04:54,150 --> 00:04:58,690
<font color="#CCCCCC">they had no help from high-level</font>

95
00:04:56,320 --> 00:05:01,090
languages and they worked<font color="#E5E5E5"> with a huge</font>

96
00:04:58,690 --> 00:05:02,469
code base as<font color="#E5E5E5"> you can see and still</font>

97
00:05:01,090 --> 00:05:05,710
managed<font color="#E5E5E5"> to produce safety</font><font color="#CCCCCC"> critical</font>

98
00:05:02,470 --> 00:05:06,130
programs however in<font color="#E5E5E5"> order to make the</font>

99
00:05:05,710 --> 00:05:08,140
<font color="#E5E5E5">AGC</font>

100
00:05:06,130 --> 00:05:09,969
more accessible and<font color="#E5E5E5"> more understandable</font>

101
00:05:08,140 --> 00:05:14,950
<font color="#CCCCCC">for people</font><font color="#E5E5E5"> like me it would</font><font color="#CCCCCC"> be</font><font color="#E5E5E5"> good to</font>

102
00:05:09,970 --> 00:05:17,620
<font color="#E5E5E5">be able to program it and see</font><font color="#CCCCCC"> secondly I</font>

103
00:05:14,950 --> 00:05:19,169
<font color="#E5E5E5">wanted to see how</font><font color="#CCCCCC"> LLVM coped with</font>

104
00:05:17,620 --> 00:05:22,499
generating<font color="#E5E5E5"> code for this back</font>

105
00:05:19,169 --> 00:05:25,979
and<font color="#E5E5E5"> it's noticeably different from</font>

106
00:05:22,499 --> 00:05:27,840
<font color="#E5E5E5">modern architectures and</font><font color="#CCCCCC"> LLVM is a</font>

107
00:05:25,979 --> 00:05:29,460
powerful infrastructure<font color="#E5E5E5"> so I wondered</font>

108
00:05:27,840 --> 00:05:34,948
how much could still be utilized<font color="#CCCCCC"> for</font>

109
00:05:29,460 --> 00:05:37,438
such a strange<font color="#E5E5E5"> back-end</font><font color="#CCCCCC"> lastly I wants</font>

110
00:05:34,949 --> 00:05:39,029
<font color="#E5E5E5">to see how well I would cope because</font>

111
00:05:37,439 --> 00:05:41,210
<font color="#CCCCCC">it's a totally new experience</font><font color="#E5E5E5"> and me</font>

112
00:05:39,029 --> 00:05:43,560
implementing a back-end from scratch

113
00:05:41,210 --> 00:05:47,938
though I had<font color="#CCCCCC"> I'd been working on other</font>

114
00:05:43,560 --> 00:05:52,319
<font color="#CCCCCC">LLVM backends so I'm</font><font color="#E5E5E5"> gonna jump in right</font>

115
00:05:47,939 --> 00:05:55,229
<font color="#E5E5E5">into the implementation now</font><font color="#CCCCCC"> so firstly</font>

116
00:05:52,319 --> 00:06:00,330
<font color="#E5E5E5">some</font><font color="#CCCCCC"> register definitions I defined r0</font>

117
00:05:55,229 --> 00:06:01,740
to r7<font color="#E5E5E5"> explicitly because because these</font>

118
00:06:00,330 --> 00:06:04,889
<font color="#E5E5E5">are internal flip-flops which have</font>

119
00:06:01,740 --> 00:06:08,689
<font color="#E5E5E5">special meanings</font><font color="#CCCCCC"> double-word registers</font>

120
00:06:04,889 --> 00:06:11,159
can also be defined here<font color="#E5E5E5"> like our d0</font>

121
00:06:08,689 --> 00:06:13,439
<font color="#CCCCCC">they're simply pairs of registers</font><font color="#E5E5E5"> and</font>

122
00:06:11,159 --> 00:06:16,620
<font color="#CCCCCC">each double rode register will overlap</font>

123
00:06:13,439 --> 00:06:19,770
with<font color="#CCCCCC"> the ones before</font><font color="#E5E5E5"> and after it so</font>

124
00:06:16,620 --> 00:06:21,360
special<font color="#E5E5E5"> spleen will register classes are</font>

125
00:06:19,770 --> 00:06:23,430
used to specify<font color="#CCCCCC"> dag or friends for</font>

126
00:06:21,360 --> 00:06:26,210
instructions that use the accumulators

127
00:06:23,430 --> 00:06:28,020
or other special purpose registers

128
00:06:26,210 --> 00:06:30,479
<font color="#E5E5E5">notice there's a lot of effort in</font>

129
00:06:28,020 --> 00:06:31,830
documentation<font color="#E5E5E5"> here since this was early</font>

130
00:06:30,479 --> 00:06:33,919
in<font color="#E5E5E5"> the project it's all downhill from</font>

131
00:06:31,830 --> 00:06:33,919
<font color="#E5E5E5">here</font>

132
00:06:36,050 --> 00:06:41,370
so generating definitions so I tried

133
00:06:39,689 --> 00:06:43,649
several<font color="#E5E5E5"> approaches to modeling memory of</font>

134
00:06:41,370 --> 00:06:45,029
the ADC<font color="#E5E5E5"> but in the end a simple</font>

135
00:06:43,649 --> 00:06:45,419
<font color="#CCCCCC">brute-force approach seemed to work the</font>

136
00:06:45,029 --> 00:06:47,849
best

137
00:06:45,419 --> 00:06:51,299
so I've generated<font color="#CCCCCC"> registered definitions</font>

138
00:06:47,849 --> 00:06:55,409
for<font color="#E5E5E5"> every single memory location and</font>

139
00:06:51,300 --> 00:06:57,120
<font color="#E5E5E5">double word memory location</font><font color="#CCCCCC"> and such of</font>

140
00:06:55,409 --> 00:07:00,210
these registers<font color="#CCCCCC"> are classified as needed</font>

141
00:06:57,120 --> 00:07:01,710
by the different instruction formats the

142
00:07:00,210 --> 00:07:04,020
instruction definitions don't<font color="#CCCCCC"> actually</font>

143
00:07:01,710 --> 00:07:06,270
specify these register classes but

144
00:07:04,020 --> 00:07:07,948
<font color="#E5E5E5">instead use immediate s-- that actually</font>

145
00:07:06,270 --> 00:07:11,370
represent<font color="#E5E5E5"> the registers memory location</font>

146
00:07:07,949 --> 00:07:12,719
the reason this is<font color="#CCCCCC"> is because</font><font color="#E5E5E5"> in table</font>

147
00:07:11,370 --> 00:07:15,509
gen it's hard to define

148
00:07:12,719 --> 00:07:18,330
I want<font color="#E5E5E5"> this integer to be represented as</font>

149
00:07:15,509 --> 00:07:20,659
an octal number<font color="#E5E5E5"> and a G C requires octal</font>

150
00:07:18,330 --> 00:07:20,659
numbers

151
00:07:23,420 --> 00:07:27,740
instruction definitions<font color="#E5E5E5"> were relatively</font>

152
00:07:25,670 --> 00:07:30,530
simple to specify according to the

153
00:07:27,740 --> 00:07:32,780
specifications<font color="#CCCCCC"> but</font><font color="#E5E5E5"> it's worth noting the</font>

154
00:07:30,530 --> 00:07:34,280
addition<font color="#E5E5E5"> of extra</font><font color="#CCCCCC"> codes so the AGC</font>

155
00:07:32,780 --> 00:07:36,409
designers figured out a way<font color="#E5E5E5"> to double</font>

156
00:07:34,280 --> 00:07:38,150
<font color="#E5E5E5">the effective encoding space of their</font>

157
00:07:36,410 --> 00:07:39,560
architecture<font color="#E5E5E5"> by interpreting</font>

158
00:07:38,150 --> 00:07:40,880
instructions<font color="#CCCCCC"> completely differently if</font>

159
00:07:39,560 --> 00:07:44,600
there are prefixed with an<font color="#E5E5E5"> extend</font>

160
00:07:40,880 --> 00:07:46,280
instruction<font color="#CCCCCC"> I use the is extra code bit</font>

161
00:07:44,600 --> 00:07:48,950
to mark extract instructions which are

162
00:07:46,280 --> 00:07:51,140
extra codes<font color="#E5E5E5"> and another decoder</font>

163
00:07:48,950 --> 00:07:54,409
namespace was necessary due to this yet

164
00:07:51,140 --> 00:07:57,200
<font color="#E5E5E5">encoding another issue is decoding these</font>

165
00:07:54,410 --> 00:07:59,750
instructions<font color="#E5E5E5"> in general was accumulator</font>

166
00:07:57,200 --> 00:08:04,969
operands<font color="#CCCCCC"> were</font><font color="#E5E5E5"> specified as dag operands</font>

167
00:07:59,750 --> 00:08:07,730
<font color="#E5E5E5">I had no encoding related to</font><font color="#CCCCCC"> them so a</font>

168
00:08:04,970 --> 00:08:10,340
fix for<font color="#E5E5E5"> this</font><font color="#CCCCCC"> is this decode null ops</font>

169
00:08:07,730 --> 00:08:12,620
patch so it turns out<font color="#CCCCCC"> that fix len</font>

170
00:08:10,340 --> 00:08:14,539
decoder emitter<font color="#E5E5E5"> does not add fields that</font>

171
00:08:12,620 --> 00:08:16,700
don't<font color="#E5E5E5"> have bits related to them all</font><font color="#CCCCCC"> that</font>

172
00:08:14,540 --> 00:08:18,500
<font color="#CCCCCC">alter they're</font><font color="#E5E5E5"> tied operands and this</font>

173
00:08:16,700 --> 00:08:20,690
causes<font color="#CCCCCC"> problems later on</font><font color="#E5E5E5"> as other parts</font>

174
00:08:18,500 --> 00:08:24,080
of the MC layer<font color="#E5E5E5"> assume that all dagger</font>

175
00:08:20,690 --> 00:08:26,060
parens are present<font color="#E5E5E5"> so a fix was to add a</font>

176
00:08:24,080 --> 00:08:27,979
flag for instructions<font color="#CCCCCC"> where this</font><font color="#E5E5E5"> is the</font>

177
00:08:26,060 --> 00:08:29,840
case<font color="#CCCCCC"> and fourth excellent decoder</font>

178
00:08:27,980 --> 00:08:32,390
emitter to add a default<font color="#CCCCCC"> zero</font><font color="#E5E5E5"> width</font>

179
00:08:29,840 --> 00:08:39,289
field to the OP info for instructions

180
00:08:32,390 --> 00:08:41,360
with this field<font color="#E5E5E5"> with this annotation so</font>

181
00:08:39,289 --> 00:08:44,569
another area needed changes in generic

182
00:08:41,360 --> 00:08:46,700
<font color="#E5E5E5">code was passing of some of Ag C's</font>

183
00:08:44,570 --> 00:08:49,610
directives which tripped up the<font color="#CCCCCC"> awesome</font>

184
00:08:46,700 --> 00:08:51,950
parser so the AG C's dollar file

185
00:08:49,610 --> 00:08:53,570
directive operates the same<font color="#CCCCCC"> way as a dot</font>

186
00:08:51,950 --> 00:08:55,790
file directive in that it's<font color="#E5E5E5"> actually</font>

187
00:08:53,570 --> 00:08:58,190
includes a given file so<font color="#E5E5E5"> here I'm just</font>

188
00:08:55,790 --> 00:09:01,849
passing the rest of the<font color="#CCCCCC"> statement into</font><font color="#E5E5E5"> a</font>

189
00:08:58,190 --> 00:09:03,920
file name<font color="#CCCCCC"> and then using the same same</font>

190
00:09:01,850 --> 00:09:06,190
method to<font color="#E5E5E5"> include the filers dot file</font>

191
00:09:03,920 --> 00:09:06,189
does

192
00:09:09,060 --> 00:09:13,170
similarly<font color="#E5E5E5"> an equals operator works</font>

193
00:09:11,580 --> 00:09:15,510
exactly<font color="#E5E5E5"> the</font><font color="#CCCCCC"> same</font><font color="#E5E5E5"> as an equals character</font>

194
00:09:13,170 --> 00:09:22,229
<font color="#E5E5E5">so I've just duplicated the code with an</font>

195
00:09:15,510 --> 00:09:24,569
extra case so some directives<font color="#E5E5E5"> didn't</font>

196
00:09:22,230 --> 00:09:26,670
trip up the US<font color="#CCCCCC"> ambassador so I</font><font color="#E5E5E5"> implement</font>

197
00:09:24,570 --> 00:09:29,400
them instead by customer missing pseudo

198
00:09:26,670 --> 00:09:31,530
instructions<font color="#E5E5E5"> so here the bank and set</font>

199
00:09:29,400 --> 00:09:34,230
<font color="#E5E5E5">lock directives are handled by switching</font>

200
00:09:31,530 --> 00:09:35,760
elf sections so<font color="#E5E5E5"> Bank is used to switch</font>

201
00:09:34,230 --> 00:09:38,340
which memory bank the assembler is

202
00:09:35,760 --> 00:09:39,960
currently outputting to<font color="#E5E5E5"> and set lock is</font>

203
00:09:38,340 --> 00:09:46,770
<font color="#E5E5E5">used to switch</font><font color="#CCCCCC"> assembly output to an</font>

204
00:09:39,960 --> 00:09:49,200
explicit<font color="#E5E5E5"> address some other directives</font>

205
00:09:46,770 --> 00:09:50,430
were arrays<font color="#E5E5E5"> anak</font><font color="#CCCCCC"> two which are</font><font color="#E5E5E5"> used to</font>

206
00:09:49,200 --> 00:09:53,220
<font color="#CCCCCC">omit bits into</font><font color="#E5E5E5"> the current output</font>

207
00:09:50,430 --> 00:09:59,699
<font color="#E5E5E5">location so</font><font color="#CCCCCC"> only needed to be</font>

208
00:09:53,220 --> 00:10:01,890
<font color="#E5E5E5">implemented in MC code emitter just a</font>

209
00:09:59,700 --> 00:10:04,680
short note on<font color="#E5E5E5"> parity so instructions in</font>

210
00:10:01,890 --> 00:10:06,870
<font color="#CCCCCC">AGC needed a parity bit to be</font><font color="#E5E5E5"> emitted in</font>

211
00:10:04,680 --> 00:10:08,969
<font color="#CCCCCC">the</font><font color="#E5E5E5"> least significant bit so I</font>

212
00:10:06,870 --> 00:10:10,350
accumulate the parity bit here by<font color="#E5E5E5"> X or</font>

213
00:10:08,970 --> 00:10:12,780
in the current parity<font color="#E5E5E5"> of the next</font>

214
00:10:10,350 --> 00:10:15,810
incoming bit<font color="#E5E5E5"> so this is used when</font>

215
00:10:12,780 --> 00:10:22,829
incoming bit it went in missing bits in

216
00:10:15,810 --> 00:10:24,270
méxico<font color="#E5E5E5"> emitter so dealing with extra</font>

217
00:10:22,830 --> 00:10:27,060
code instructions throughout the<font color="#E5E5E5"> MC</font>

218
00:10:24,270 --> 00:10:29,329
layer was a tricky task<font color="#E5E5E5"> so in the</font><font color="#CCCCCC"> assam</font>

219
00:10:27,060 --> 00:10:32,069
parser passing an extended instruction

220
00:10:29,330 --> 00:10:35,940
causes a flag to<font color="#CCCCCC"> be set in this</font><font color="#E5E5E5"> check</font>

221
00:10:32,070 --> 00:10:37,560
early target match<font color="#E5E5E5"> predicate and the</font>

222
00:10:35,940 --> 00:10:40,560
instruction will not be<font color="#E5E5E5"> mitad as an MC</font>

223
00:10:37,560 --> 00:10:42,780
instruction so the next time around<font color="#E5E5E5"> when</font>

224
00:10:40,560 --> 00:10:47,239
<font color="#CCCCCC">pass instruction is called this flag is</font>

225
00:10:42,780 --> 00:10:49,170
cleared<font color="#CCCCCC"> and passing extra code is set</font>

226
00:10:47,240 --> 00:10:52,890
indicating that the current instruction

227
00:10:49,170 --> 00:10:54,719
<font color="#E5E5E5">should be an extra code so checking this</font>

228
00:10:52,890 --> 00:10:57,230
is that checking<font color="#E5E5E5"> the</font><font color="#CCCCCC"> years extra code</font>

229
00:10:54,720 --> 00:11:00,270
bit after passing the<font color="#E5E5E5"> next instruction</font>

230
00:10:57,230 --> 00:11:02,580
indicates whether the<font color="#CCCCCC"> extend plus extra</font>

231
00:11:00,270 --> 00:11:04,980
code sequence is<font color="#CCCCCC"> following correctly and</font>

232
00:11:02,580 --> 00:11:07,530
I error on both<font color="#E5E5E5"> an extend followed by a</font>

233
00:11:04,980 --> 00:11:10,670
<font color="#E5E5E5">non extra code and an extra code that's</font>

234
00:11:07,530 --> 00:11:10,670
not preceded by an extend

235
00:11:12,450 --> 00:11:16,720
to emit<font color="#E5E5E5"> an extra code instruction and</font>

236
00:11:15,100 --> 00:11:19,330
the solution was simply to<font color="#CCCCCC"> omit the raw</font>

237
00:11:16,720 --> 00:11:25,750
bytes<font color="#E5E5E5"> that extend followed by the bytes</font>

238
00:11:19,330 --> 00:11:27,730
<font color="#E5E5E5">of the instruction decoding an extra</font>

239
00:11:25,750 --> 00:11:30,730
code instruction required testing of the

240
00:11:27,730 --> 00:11:33,180
decoder instruction wasn't extend<font color="#E5E5E5"> then</font>

241
00:11:30,730 --> 00:11:35,470
if so taking the next<font color="#E5E5E5"> instruction and</font>

242
00:11:33,180 --> 00:11:39,819
decoding it using a separate extra code

243
00:11:35,470 --> 00:11:44,010
decoding table also<font color="#E5E5E5"> noticed masking</font>

244
00:11:39,820 --> 00:11:44,010
parity bit before decoding instructions

245
00:11:47,040 --> 00:11:54,189
<font color="#CCCCCC">so finally moving on to some lowering so</font>

246
00:11:51,720 --> 00:11:56,200
some simple<font color="#E5E5E5"> patterns were enough</font><font color="#CCCCCC"> for</font>

247
00:11:54,190 --> 00:11:57,760
some instructions to allow lowering to

248
00:11:56,200 --> 00:12:04,540
them because they had a<font color="#E5E5E5"> simple tag</font>

249
00:11:57,760 --> 00:12:08,319
representation<font color="#CCCCCC"> other instructions</font>

250
00:12:04,540 --> 00:12:10,060
required some more<font color="#E5E5E5"> convincing</font><font color="#CCCCCC"> the</font>

251
00:12:08,320 --> 00:12:11,590
multiply<font color="#CCCCCC"> and divide instructions don't</font>

252
00:12:10,060 --> 00:12:13,500
fit well with the corresponding tag

253
00:12:11,590 --> 00:12:16,300
notes

254
00:12:13,500 --> 00:12:18,190
so specifically<font color="#CCCCCC"> multiply takes</font><font color="#E5E5E5"> two</font>

255
00:12:16,300 --> 00:12:22,150
single words<font color="#E5E5E5"> and produces a double word</font>

256
00:12:18,190 --> 00:12:26,550
output so it only matches<font color="#E5E5E5"> an i-32</font>

257
00:12:22,150 --> 00:12:26,550
<font color="#E5E5E5">multiplied with sign extended inputs</font>

258
00:12:26,610 --> 00:12:32,680
<font color="#CCCCCC">divide which isn't</font><font color="#E5E5E5"> the implementation</font>

259
00:12:29,320 --> 00:12:35,350
isn't on the screen<font color="#CCCCCC"> it takes one double</font>

260
00:12:32,680 --> 00:12:38,109
<font color="#E5E5E5">word numerator</font><font color="#CCCCCC"> a single word denominator</font>

261
00:12:35,350 --> 00:12:40,620
and produces two single words<font color="#E5E5E5"> a result</font>

262
00:12:38,110 --> 00:12:43,270
in a<font color="#E5E5E5"> remainder so</font><font color="#CCCCCC"> it matches either a</font>

263
00:12:40,620 --> 00:12:45,400
<font color="#CCCCCC">divide or a</font><font color="#E5E5E5"> remainder with a sign</font>

264
00:12:43,270 --> 00:12:48,060
extended denominator<font color="#E5E5E5"> and the output is a</font>

265
00:12:45,400 --> 00:12:48,060
<font color="#E5E5E5">sign</font><font color="#CCCCCC"> extent</font>

266
00:12:51,790 --> 00:12:55,040
materializing<font color="#E5E5E5"> Constance was one of the</font>

267
00:12:53,689 --> 00:12:57,290
most<font color="#CCCCCC"> difficult</font><font color="#E5E5E5"> parts of the back end</font>

268
00:12:55,040 --> 00:13:00,769
because<font color="#E5E5E5"> there's no instructions that</font>

269
00:12:57,290 --> 00:13:02,449
<font color="#E5E5E5">take immediate operands so there is a</font>

270
00:13:00,769 --> 00:13:05,839
sequence of directives that<font color="#E5E5E5"> can be</font>

271
00:13:02,449 --> 00:13:07,429
<font color="#E5E5E5">omitted</font><font color="#CCCCCC"> to output a constant</font><font color="#E5E5E5"> but in</font>

272
00:13:05,839 --> 00:13:10,249
order<font color="#E5E5E5"> to expand that sequence I first</font>

273
00:13:07,429 --> 00:13:14,949
have to<font color="#E5E5E5"> select all instance of instances</font>

274
00:13:10,249 --> 00:13:14,949
<font color="#E5E5E5">of constants into</font><font color="#CCCCCC"> a pseudo instruction</font>

275
00:13:17,679 --> 00:13:22,220
so to expand<font color="#CCCCCC"> this pseudo instruction</font>

276
00:13:20,149 --> 00:13:24,889
into a sequence<font color="#CCCCCC"> how to</font><font color="#E5E5E5"> create a prima</font>

277
00:13:22,220 --> 00:13:27,019
pass to expand pseudo instructions but

278
00:13:24,889 --> 00:13:29,419
since I wanted<font color="#E5E5E5"> this sequence to not be</font>

279
00:13:27,019 --> 00:13:31,519
interrupted<font color="#CCCCCC"> this</font><font color="#E5E5E5"> has to be done with a</font>

280
00:13:29,419 --> 00:13:34,730
dream it<font color="#E5E5E5"> passed</font><font color="#CCCCCC"> too which is the latest</font>

281
00:13:31,519 --> 00:13:37,029
<font color="#CCCCCC">prima pass</font><font color="#E5E5E5"> so when expanding the</font>

282
00:13:34,730 --> 00:13:39,919
constant<font color="#E5E5E5"> I take the immediate operand</font>

283
00:13:37,029 --> 00:13:42,739
first ensure that<font color="#E5E5E5"> it's converted to a 15</font>

284
00:13:39,919 --> 00:13:45,709
bit<font color="#CCCCCC"> ones complement value next I create</font>

285
00:13:42,739 --> 00:13:47,359
<font color="#E5E5E5">a new</font><font color="#CCCCCC"> sequence of directives first to</font>

286
00:13:45,709 --> 00:13:51,529
switch the output location<font color="#CCCCCC"> of the</font><font color="#E5E5E5"> binary</font>

287
00:13:47,359 --> 00:13:53,709
to the destination register<font color="#E5E5E5"> then to</font>

288
00:13:51,529 --> 00:13:56,149
output raw bits at that location<font color="#E5E5E5"> and</font>

289
00:13:53,709 --> 00:14:02,868
then to switch<font color="#CCCCCC"> back to the original</font><font color="#E5E5E5"> Bank</font>

290
00:13:56,149 --> 00:14:04,809
for<font color="#E5E5E5"> the function notice that there is</font><font color="#CCCCCC"> a</font>

291
00:14:02,869 --> 00:14:07,519
bug with this<font color="#E5E5E5"> implementation which is</font>

292
00:14:04,809 --> 00:14:09,679
that this implies<font color="#CCCCCC"> that register</font>

293
00:14:07,519 --> 00:14:12,369
allocation for the given register can

294
00:14:09,679 --> 00:14:14,899
only be unique for<font color="#CCCCCC"> the entire program</font>

295
00:14:12,369 --> 00:14:18,230
<font color="#CCCCCC">and I</font><font color="#E5E5E5"> haven't implemented a fix for this</font>

296
00:14:14,899 --> 00:14:20,329
so if you use a constant<font color="#E5E5E5"> in a register</font>

297
00:14:18,230 --> 00:14:21,939
more<font color="#E5E5E5"> than once then you'll just end up</font>

298
00:14:20,329 --> 00:14:24,939
<font color="#CCCCCC">with the latest constant that was</font>

299
00:14:21,939 --> 00:14:24,939
lowered

300
00:14:26,819 --> 00:14:33,599
so there's quite<font color="#E5E5E5"> a bit of future work</font>

301
00:14:29,540 --> 00:14:37,500
<font color="#CCCCCC">I've basically done</font><font color="#E5E5E5"> most of the MC layer</font>

302
00:14:33,600 --> 00:14:40,050
<font color="#E5E5E5">and a little bit of lowering</font><font color="#CCCCCC"> but several</font>

303
00:14:37,500 --> 00:14:45,060
<font color="#E5E5E5">things in the</font><font color="#CCCCCC"> Klang front-end</font><font color="#E5E5E5"> and I our</font>

304
00:14:40,050 --> 00:14:46,649
transformations<font color="#E5E5E5"> produce</font><font color="#CCCCCC"> IR</font><font color="#E5E5E5"> would you say</font>

305
00:14:45,060 --> 00:14:48,959
all<font color="#E5E5E5"> that won't be loaded correctly in</font>

306
00:14:46,649 --> 00:14:51,389
the<font color="#E5E5E5"> ATC back-end</font>

307
00:14:48,959 --> 00:14:53,250
so first<font color="#E5E5E5"> bytes cannot be assumed to</font><font color="#CCCCCC"> be</font>

308
00:14:51,389 --> 00:14:55,350
<font color="#CCCCCC">8-bit</font>

309
00:14:53,250 --> 00:14:57,389
there are some mechanical changes to be

310
00:14:55,350 --> 00:15:01,399
made but<font color="#E5E5E5"> the particular problem is that</font>

311
00:14:57,389 --> 00:15:01,399
generic pointers<font color="#E5E5E5"> will default to ISTAR</font>

312
00:15:01,550 --> 00:15:06,060
<font color="#CCCCCC">secondly some transformations for</font>

313
00:15:03,990 --> 00:15:08,459
example evaluation of constant

314
00:15:06,060 --> 00:15:10,979
expressions<font color="#E5E5E5"> assume that two's complement</font>

315
00:15:08,459 --> 00:15:14,609
<font color="#E5E5E5">numbers are used so producing valid code</font>

316
00:15:10,980 --> 00:15:15,959
for the AGC<font color="#CCCCCC"> this is quite a likely</font>

317
00:15:14,610 --> 00:15:17,939
assumption that's going to be common

318
00:15:15,959 --> 00:15:19,170
<font color="#E5E5E5">throughout the code base so it might</font>

319
00:15:17,939 --> 00:15:22,709
take a while<font color="#E5E5E5"> turn down</font><font color="#CCCCCC"> all the</font>

320
00:15:19,170 --> 00:15:23,610
<font color="#CCCCCC">occurrences</font><font color="#E5E5E5"> and but for other and other</font>

321
00:15:22,709 --> 00:15:25,888
restrictions

322
00:15:23,610 --> 00:15:33,569
it might be worth defining a subset of C

323
00:15:25,889 --> 00:15:36,149
to compile for<font color="#E5E5E5"> AGC another thing I'd</font>

324
00:15:33,569 --> 00:15:38,099
<font color="#E5E5E5">like</font><font color="#CCCCCC"> to do is make sure that the</font>

325
00:15:36,149 --> 00:15:41,639
assembly output of the yellow of<font color="#CCCCCC"> LLVM</font>

326
00:15:38,100 --> 00:15:44,250
<font color="#E5E5E5">resent resembles actual AGC code so</font><font color="#CCCCCC"> to</font>

327
00:15:41,639 --> 00:15:47,370
do this I need<font color="#CCCCCC"> to</font><font color="#E5E5E5"> remove all new new elf</font>

328
00:15:44,250 --> 00:15:50,759
directives and<font color="#E5E5E5"> replace them with AGC</font>

329
00:15:47,370 --> 00:15:52,589
directives so there's already a<font color="#E5E5E5"> project</font>

330
00:15:50,759 --> 00:15:54,420
that has an assembler<font color="#E5E5E5"> and I'd like to</font>

331
00:15:52,589 --> 00:15:56,750
<font color="#E5E5E5">like the output files to be assembled</font>

332
00:15:54,420 --> 00:15:56,750
with<font color="#E5E5E5"> that</font>

333
00:16:00,360 --> 00:16:06,400
so the AGC back in can create valid

334
00:16:03,850 --> 00:16:09,370
<font color="#CCCCCC">object files</font><font color="#E5E5E5"> but a lot of the operation</font>

335
00:16:06,400 --> 00:16:11,290
relies<font color="#E5E5E5"> on link</font><font color="#CCCCCC"> of functionality and I</font>

336
00:16:09,370 --> 00:16:17,410
<font color="#E5E5E5">haven't implemented a linker yet so that</font>

337
00:16:11,290 --> 00:16:20,260
<font color="#CCCCCC">needs</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> be done AGC doesn't have</font><font color="#E5E5E5"> a</font>

338
00:16:17,410 --> 00:16:25,540
stack pointer so I need to<font color="#E5E5E5"> emulate a</font>

339
00:16:20,260 --> 00:16:27,580
stack to use to pass arguments<font color="#E5E5E5"> index</font>

340
00:16:25,540 --> 00:16:31,980
instruction<font color="#CCCCCC"> basically is what's used for</font>

341
00:16:27,580 --> 00:16:35,140
indexing in the<font color="#CCCCCC"> ads a constant value to</font>

342
00:16:31,980 --> 00:16:40,840
the memory<font color="#CCCCCC"> location that</font><font color="#E5E5E5"> you give it so</font>

343
00:16:35,140 --> 00:16:42,400
it can be used<font color="#E5E5E5"> to index a stack</font><font color="#CCCCCC"> I want</font>

344
00:16:40,840 --> 00:16:46,420
to try to lower control<font color="#E5E5E5"> flow statements</font>

345
00:16:42,400 --> 00:16:51,819
<font color="#CCCCCC">to that the ccs instruction which could</font>

346
00:16:46,420 --> 00:16:57,699
be quite difficult so some things<font color="#CCCCCC"> I</font>

347
00:16:51,820 --> 00:16:59,380
<font color="#E5E5E5">found in</font><font color="#CCCCCC"> LLVM so this might be obvious</font>

348
00:16:57,700 --> 00:17:04,209
but as<font color="#CCCCCC"> an parser is not flexible to</font>

349
00:16:59,380 --> 00:17:06,310
non-renew like assembly<font color="#E5E5E5"> fixed line</font>

350
00:17:04,209 --> 00:17:08,740
decoder emitter requires<font color="#CCCCCC"> decode no Lots</font>

351
00:17:06,310 --> 00:17:16,300
<font color="#E5E5E5">patch to function for MC instructions</font>

352
00:17:08,740 --> 00:17:17,740
with hidden<font color="#E5E5E5"> operands</font><font color="#CCCCCC"> the lexer converts</font>

353
00:17:16,300 --> 00:17:21,099
<font color="#E5E5E5">octal immediate itself without the</font>

354
00:17:17,740 --> 00:17:23,980
target knowing so the problem with the

355
00:17:21,099 --> 00:17:29,260
AGC<font color="#E5E5E5"> back-end is all all operands must be</font>

356
00:17:23,980 --> 00:17:31,420
in octal form so when the<font color="#CCCCCC"> lexer converts</font>

357
00:17:29,260 --> 00:17:33,490
something proceeded with a<font color="#CCCCCC"> zero to an</font>

358
00:17:31,420 --> 00:17:36,430
oxide integer<font color="#CCCCCC"> I don't know whether I</font>

359
00:17:33,490 --> 00:17:39,670
still need to convert the immediate back

360
00:17:36,430 --> 00:17:41,500
to an octal or<font color="#CCCCCC"> not so I have to get the</font>

361
00:17:39,670 --> 00:17:46,600
<font color="#E5E5E5">the raw string that was converted first</font>

362
00:17:41,500 --> 00:17:48,900
<font color="#E5E5E5">and do it myself</font><font color="#CCCCCC"> and that's</font><font color="#E5E5E5"> the end of</font>

363
00:17:46,600 --> 00:17:48,899
my<font color="#CCCCCC"> size</font>

364
00:17:56,240 --> 00:18:13,050
any questions yes so I can compile basic

365
00:18:08,100 --> 00:18:17,040
functions with a audio operations<font color="#E5E5E5"> I can</font>

366
00:18:13,050 --> 00:18:19,889
there<font color="#E5E5E5"> are a few</font><font color="#CCCCCC"> ir tests as well that's</font>

367
00:18:17,040 --> 00:18:21,510
but I still need to<font color="#E5E5E5"> implement</font><font color="#CCCCCC"> I think</font>

368
00:18:19,890 --> 00:18:22,920
function<font color="#E5E5E5"> calling is the next important</font>

369
00:18:21,510 --> 00:18:30,290
<font color="#CCCCCC">thing</font><font color="#E5E5E5"> to implement before</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> can</font><font color="#CCCCCC"> actually</font>

370
00:18:22,920 --> 00:18:30,290
<font color="#CCCCCC">get</font><font color="#E5E5E5"> the program running anything else</font>

371
00:18:32,360 --> 00:18:40,820
as you<font color="#E5E5E5"> imagine the</font><font color="#CCCCCC"> Laker because</font><font color="#E5E5E5"> I mean</font>

372
00:18:34,610 --> 00:18:43,158
<font color="#E5E5E5">there's a so the question was whether</font>

373
00:18:40,820 --> 00:18:47,289
<font color="#CCCCCC">it's defined object file format and</font><font color="#E5E5E5"> the</font>

374
00:18:43,159 --> 00:19:00,289
<font color="#E5E5E5">answer is no I'm just using elf and</font>

375
00:18:47,289 --> 00:19:02,390
using that<font color="#E5E5E5"> as a stand-in</font><font color="#CCCCCC"> so I guess the</font>

376
00:19:00,289 --> 00:19:06,490
idea<font color="#E5E5E5"> so the question was was</font><font color="#CCCCCC"> there a</font>

377
00:19:02,390 --> 00:19:09,409
linker at the time<font color="#CCCCCC"> and the idea was that</font>

378
00:19:06,490 --> 00:19:11,210
the way that you'd get<font color="#E5E5E5"> in a</font><font color="#CCCCCC"> program to</font>

379
00:19:09,409 --> 00:19:13,130
<font color="#E5E5E5">stick together was</font><font color="#CCCCCC"> just by textually</font>

380
00:19:11,210 --> 00:19:16,299
including all the other files<font color="#CCCCCC"> so a</font>

381
00:19:13,130 --> 00:19:16,299
linker wasn't really needed

382
00:19:22,540 --> 00:19:37,330
I guess the<font color="#CCCCCC"> equivalent yeah so the</font>

383
00:19:33,670 --> 00:19:38,920
assembler did the entire job because it

384
00:19:37,330 --> 00:19:41,800
controlled<font color="#E5E5E5"> the outfit location and</font>

385
00:19:38,920 --> 00:19:47,160
<font color="#CCCCCC">switched banks and did that as necessary</font>

386
00:19:41,800 --> 00:19:47,159
<font color="#E5E5E5">yeah anything else</font>

