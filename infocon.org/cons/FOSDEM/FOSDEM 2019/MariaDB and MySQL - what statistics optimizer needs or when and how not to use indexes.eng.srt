1
00:00:05,030 --> 00:00:10,500
so this is the talk<font color="#E5E5E5"> about my TV and my</font>

2
00:00:07,860 --> 00:00:13,650
<font color="#CCCCCC">spell</font><font color="#E5E5E5"> about</font><font color="#CCCCCC"> statistical</font><font color="#E5E5E5"> optimizer needs</font>

3
00:00:10,500 --> 00:00:19,290
to optimize<font color="#CCCCCC"> for</font><font color="#E5E5E5"> queries and when and how</font>

4
00:00:13,650 --> 00:00:21,600
<font color="#E5E5E5">not to use indexes I'll okay</font><font color="#CCCCCC"> so i work</font>

5
00:00:19,290 --> 00:00:23,310
in<font color="#E5E5E5"> my</font><font color="#CCCCCC"> a DB operation as chief architect</font>

6
00:00:21,600 --> 00:00:26,369
melody<font color="#E5E5E5"> B and I was working</font><font color="#CCCCCC"> on my spell</font>

7
00:00:23,310 --> 00:00:29,549
<font color="#CCCCCC">code base for like 20 years so I'm</font>

8
00:00:26,369 --> 00:00:34,530
pretty familiar<font color="#E5E5E5"> with it but let's start</font>

9
00:00:29,550 --> 00:00:37,320
the talk so what<font color="#CCCCCC"> but</font><font color="#E5E5E5"> is exactly</font><font color="#CCCCCC"> why</font><font color="#E5E5E5"> the</font>

10
00:00:34,530 --> 00:00:40,880
<font color="#E5E5E5">need</font><font color="#CCCCCC"> for an optimizer optimizes your</font>

11
00:00:37,320 --> 00:00:45,960
query it needs to know something about

12
00:00:40,880 --> 00:00:47,820
<font color="#CCCCCC">the data and usually</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> volt instant was</font>

13
00:00:45,960 --> 00:00:49,260
done by<font color="#CCCCCC"> optimizing was asking</font><font color="#E5E5E5"> engine</font>

14
00:00:47,820 --> 00:00:52,530
different questions like I don't<font color="#E5E5E5"> know</font>

15
00:00:49,260 --> 00:00:54,120
how many<font color="#CCCCCC"> arrows does astable</font><font color="#E5E5E5"> have or how</font>

16
00:00:52,530 --> 00:00:56,879
much would cost to do the full table

17
00:00:54,120 --> 00:00:59,489
<font color="#CCCCCC">scan and cost is in some arbitrary cost</font>

18
00:00:56,879 --> 00:01:02,190
units not in microseconds<font color="#E5E5E5"> or CPU cycles</font>

19
00:00:59,489 --> 00:01:04,530
or anything<font color="#CCCCCC"> so</font><font color="#E5E5E5"> for example how much will</font>

20
00:01:02,190 --> 00:01:06,060
it cost to read thousand<font color="#CCCCCC"> values from the</font>

21
00:01:04,530 --> 00:01:07,410
index number three and then you might

22
00:01:06,060 --> 00:01:08,580
even compare<font color="#E5E5E5"> this course with the cost</font>

23
00:01:07,410 --> 00:01:10,950
of<font color="#E5E5E5"> the full table scan and decide</font>

24
00:01:08,580 --> 00:01:12,780
<font color="#E5E5E5">whether</font><font color="#CCCCCC"> it's cheaper or how many</font>

25
00:01:10,950 --> 00:01:15,240
<font color="#E5E5E5">distinct values are in the index and</font>

26
00:01:12,780 --> 00:01:17,670
then if the index<font color="#CCCCCC"> face say</font><font color="#E5E5E5"> ten million</font>

27
00:01:15,240 --> 00:01:19,318
rows and there are 1 million<font color="#E5E5E5"> distinct</font>

28
00:01:17,670 --> 00:01:21,539
values then<font color="#CCCCCC"> optimizing</font><font color="#E5E5E5"> would assume</font><font color="#CCCCCC"> that</font>

29
00:01:19,319 --> 00:01:25,800
every<font color="#E5E5E5"> value is</font><font color="#CCCCCC"> present</font><font color="#E5E5E5"> about</font><font color="#CCCCCC"> ten times</font>

30
00:01:21,539 --> 00:01:28,200
in<font color="#E5E5E5"> the index or optimizer could ask how</font>

31
00:01:25,800 --> 00:01:31,170
many<font color="#CCCCCC"> rolls care how many index values</font>

32
00:01:28,200 --> 00:01:33,509
lie in the range<font color="#E5E5E5"> between say 10,000 and</font>

33
00:01:31,170 --> 00:01:35,310
11,000<font color="#E5E5E5"> and then this then it would ask</font>

34
00:01:33,509 --> 00:01:37,819
<font color="#E5E5E5">the cost to read them and then it would</font>

35
00:01:35,310 --> 00:01:40,920
compare with it for table scan and so on

36
00:01:37,819 --> 00:01:46,229
that works reasonably well<font color="#CCCCCC"> well but</font>

37
00:01:40,920 --> 00:01:48,060
there are some issues<font color="#E5E5E5"> with that and one</font>

38
00:01:46,229 --> 00:01:50,069
<font color="#E5E5E5">of the problems is instability</font><font color="#CCCCCC"> not</font><font color="#E5E5E5"> all</font>

39
00:01:48,060 --> 00:01:51,929
<font color="#CCCCCC">engine has this values all the</font><font color="#E5E5E5"> time</font>

40
00:01:50,069 --> 00:01:53,989
already<font color="#E5E5E5"> they calculate them on the fly</font>

41
00:01:51,929 --> 00:01:56,789
and V for example<font color="#CCCCCC"> is</font><font color="#E5E5E5"> doing it using</font>

42
00:01:53,989 --> 00:01:59,250
<font color="#E5E5E5">random index dives and because they are</font>

43
00:01:56,789 --> 00:02:01,200
random<font color="#E5E5E5"> they supposedly don't have any</font>

44
00:01:59,250 --> 00:02:04,830
bias on<font color="#E5E5E5"> the other hand because</font><font color="#CCCCCC"> they're</font>

45
00:02:01,200 --> 00:02:07,739
<font color="#E5E5E5">random they do not give repeatable</font>

46
00:02:04,830 --> 00:02:11,068
results and<font color="#CCCCCC"> this is a</font><font color="#E5E5E5"> test I've done on</font>

47
00:02:07,739 --> 00:02:14,430
DBT<font color="#CCCCCC"> three</font><font color="#E5E5E5"> benchmarks on query from DVD</font>

48
00:02:11,068 --> 00:02:15,980
three number two eight eight individuals

49
00:02:14,430 --> 00:02:17,780
involved<font color="#CCCCCC"> in this query and</font>

50
00:02:15,980 --> 00:02:19,369
repeat by just by<font color="#CCCCCC"> the</font><font color="#E5E5E5"> repeated many</font>

51
00:02:17,780 --> 00:02:21,560
times<font color="#E5E5E5"> I have seen four different</font>

52
00:02:19,370 --> 00:02:23,510
execution plans and with a query

53
00:02:21,560 --> 00:02:27,319
execution time ranging from<font color="#CCCCCC"> 7 mins to</font>

54
00:02:23,510 --> 00:02:28,970
<font color="#CCCCCC">1.2 hours and</font><font color="#E5E5E5"> for q7 I seen I've seen</font>

55
00:02:27,319 --> 00:02:31,458
<font color="#E5E5E5">seven different plans</font>

56
00:02:28,970 --> 00:02:33,470
the fastest<font color="#CCCCCC"> one was</font><font color="#E5E5E5"> executing in 12</font>

57
00:02:31,459 --> 00:02:34,940
<font color="#CCCCCC">minutes and the longest</font><font color="#E5E5E5"> one I've</font><font color="#CCCCCC"> just</font>

58
00:02:33,470 --> 00:02:38,750
waited<font color="#CCCCCC"> for few</font><font color="#E5E5E5"> hours and killed a query</font>

59
00:02:34,940 --> 00:02:42,050
because yeah I got impatient so it's not

60
00:02:38,750 --> 00:02:43,670
what you'd prefer to<font color="#E5E5E5"> have some might ask</font>

61
00:02:42,050 --> 00:02:46,190
what<font color="#CCCCCC"> about energy</font><font color="#E5E5E5"> be persistent</font>

62
00:02:43,670 --> 00:02:48,470
statistics<font color="#E5E5E5"> and it does solve the</font>

63
00:02:46,190 --> 00:02:50,300
instability problem in a way<font color="#E5E5E5"> that</font><font color="#CCCCCC"> in DB</font>

64
00:02:48,470 --> 00:02:52,100
<font color="#CCCCCC">is still doing the</font><font color="#E5E5E5"> random dives</font><font color="#CCCCCC"> and then</font>

65
00:02:50,300 --> 00:02:54,440
it remembers the<font color="#E5E5E5"> result in an internal</font>

66
00:02:52,100 --> 00:02:56,150
<font color="#CCCCCC">table</font><font color="#E5E5E5"> and next time it'll just show</font><font color="#CCCCCC"> you</font>

67
00:02:54,440 --> 00:02:57,470
the same result<font color="#E5E5E5"> so there's no</font>

68
00:02:56,150 --> 00:03:00,799
instability always get the same result

69
00:02:57,470 --> 00:03:02,209
<font color="#CCCCCC">and the same execution</font><font color="#E5E5E5"> plan but because</font>

70
00:03:00,799 --> 00:03:04,130
it still<font color="#CCCCCC"> started from the random</font><font color="#E5E5E5"> drives</font>

71
00:03:02,209 --> 00:03:06,650
<font color="#E5E5E5">if you're lucky you'll get always the</font>

72
00:03:04,130 --> 00:03:08,420
same execution<font color="#E5E5E5"> plan and the query will</font>

73
00:03:06,650 --> 00:03:09,980
always<font color="#CCCCCC"> get</font><font color="#E5E5E5"> in 12 minutes</font><font color="#CCCCCC"> if</font><font color="#E5E5E5"> you're</font>

74
00:03:08,420 --> 00:03:12,140
unlike your guys<font color="#E5E5E5"> always</font><font color="#CCCCCC"> the same plan</font>

75
00:03:09,980 --> 00:03:12,679
and it'll always be many hours<font color="#E5E5E5"> and</font>

76
00:03:12,140 --> 00:03:16,279
<font color="#CCCCCC">timeout</font>

77
00:03:12,680 --> 00:03:17,989
that's and if you don't even<font color="#E5E5E5"> know how</font>

78
00:03:16,280 --> 00:03:19,880
many<font color="#CCCCCC"> plans</font><font color="#E5E5E5"> are less if you you might</font>

79
00:03:17,989 --> 00:03:22,280
just<font color="#E5E5E5"> think</font><font color="#CCCCCC"> that very slow if it always</font>

80
00:03:19,880 --> 00:03:24,739
<font color="#E5E5E5">time</font><font color="#CCCCCC"> us turns out after many hours</font><font color="#E5E5E5"> but</font>

81
00:03:22,280 --> 00:03:29,120
it may<font color="#E5E5E5"> be just that you go to bed random</font>

82
00:03:24,739 --> 00:03:33,470
<font color="#E5E5E5">there's another problem is</font><font color="#CCCCCC"> that all</font>

83
00:03:29,120 --> 00:03:35,750
engines they do report statistics in

84
00:03:33,470 --> 00:03:37,310
arbitrary cost units<font color="#E5E5E5"> but they are</font>

85
00:03:35,750 --> 00:03:40,700
<font color="#CCCCCC">different for students for different</font>

86
00:03:37,310 --> 00:03:43,010
engines and engines<font color="#E5E5E5"> lie about what data</font>

87
00:03:40,700 --> 00:03:44,929
<font color="#E5E5E5">are in</font><font color="#CCCCCC"> the table</font><font color="#E5E5E5"> this is the</font><font color="#CCCCCC"> example I</font>

88
00:03:43,010 --> 00:03:48,200
<font color="#CCCCCC">have a table with three integer columns</font>

89
00:03:44,930 --> 00:03:51,680
and<font color="#E5E5E5"> I pop you lated every column with a</font>

90
00:03:48,200 --> 00:03:55,429
random<font color="#E5E5E5"> number between 1 0 and 100,000</font>

91
00:03:51,680 --> 00:03:58,340
<font color="#E5E5E5">and</font><font color="#CCCCCC"> repeated</font><font color="#E5E5E5"> 400,000 times and now I do</font>

92
00:03:55,430 --> 00:04:01,340
select<font color="#E5E5E5"> how distinct which is honest</font>

93
00:03:58,340 --> 00:04:04,370
exact so a skill calculation to get<font color="#E5E5E5"> the</font>

94
00:04:01,340 --> 00:04:06,519
number<font color="#E5E5E5"> of distinct values and what do</font>

95
00:04:04,370 --> 00:04:13,060
<font color="#E5E5E5">you think what number I will get here</font>

96
00:04:06,519 --> 00:04:16,579
<font color="#E5E5E5">anybody could guess his own</font>

97
00:04:13,060 --> 00:04:19,850
<font color="#CCCCCC">ok if it was 400,000 roles and numbers</font>

98
00:04:16,579 --> 00:04:21,680
are between 100 0 and<font color="#E5E5E5"> 100,000 so it</font>

99
00:04:19,850 --> 00:04:24,650
should<font color="#CCCCCC"> be about</font><font color="#E5E5E5"> hundred thousand</font>

100
00:04:21,680 --> 00:04:27,320
<font color="#CCCCCC">distinct values and this</font><font color="#E5E5E5"> is exactly what</font>

101
00:04:24,650 --> 00:04:28,758
I've got but<font color="#E5E5E5"> this way it takes a lot of</font>

102
00:04:27,320 --> 00:04:31,159
time to calculate

103
00:04:28,759 --> 00:04:33,229
so usually<font color="#E5E5E5"> optimizer relies on some</font>

104
00:04:31,159 --> 00:04:35,089
imprecise estimations<font color="#E5E5E5"> that I've done by</font>

105
00:04:33,229 --> 00:04:37,729
the engine so the engine is my eyes on

106
00:04:35,089 --> 00:04:39,919
here<font color="#E5E5E5"> and here I asked the engine for the</font>

107
00:04:37,729 --> 00:04:44,029
estimation<font color="#E5E5E5"> how many distinct values are</font>

108
00:04:39,919 --> 00:04:46,248
in the index and my<font color="#E5E5E5"> eye some estimated</font>

109
00:04:44,029 --> 00:04:48,558
which it's not<font color="#E5E5E5"> exact number but</font><font color="#CCCCCC"> it's</font>

110
00:04:46,249 --> 00:04:51,529
within<font color="#E5E5E5"> one percent which is good</font><font color="#CCCCCC"> enough</font>

111
00:04:48,559 --> 00:04:54,860
for<font color="#CCCCCC"> the optimizer pulling plane in point</font>

112
00:04:51,529 --> 00:04:58,999
of<font color="#E5E5E5"> view now I change the table</font><font color="#CCCCCC"> for</font>

113
00:04:54,860 --> 00:05:01,490
<font color="#CCCCCC">InnoDB</font><font color="#E5E5E5"> and we look not was</font><font color="#CCCCCC"> I'm trying</font><font color="#E5E5E5"> to</font>

114
00:04:58,999 --> 00:05:03,529
guess in<font color="#E5E5E5"> a</font><font color="#CCCCCC"> DB reports two hundred</font>

115
00:05:01,490 --> 00:05:04,969
<font color="#CCCCCC">thousand disinter alias</font><font color="#E5E5E5"> and if you</font>

116
00:05:03,529 --> 00:05:07,699
<font color="#E5E5E5">remember that the table contains</font>

117
00:05:04,969 --> 00:05:09,469
integers between<font color="#CCCCCC"> zero and</font><font color="#E5E5E5"> 100 thousand</font>

118
00:05:07,699 --> 00:05:11,259
<font color="#E5E5E5">that cannot possibly</font><font color="#CCCCCC"> be two hundred</font>

119
00:05:09,469 --> 00:05:13,430
<font color="#E5E5E5">thousand distinct layers in there</font>

120
00:05:11,259 --> 00:05:15,469
but what does it<font color="#E5E5E5"> mean for the optimizer</font>

121
00:05:13,430 --> 00:05:16,249
<font color="#CCCCCC">so there</font><font color="#E5E5E5"> are four hundred optimizing</font>

122
00:05:15,469 --> 00:05:19,550
<font color="#E5E5E5">note that there are four hundred</font>

123
00:05:16,249 --> 00:05:22,009
<font color="#E5E5E5">thousand rows in the table and there are</font>

124
00:05:19,550 --> 00:05:23,779
100 distinct red it<font color="#E5E5E5"> means that optimizer</font>

125
00:05:22,009 --> 00:05:26,599
would expect every single<font color="#CCCCCC"> really</font><font color="#E5E5E5"> to be</font>

126
00:05:23,779 --> 00:05:29,029
present in<font color="#CCCCCC"> the table</font><font color="#E5E5E5"> four times if you</font>

127
00:05:26,599 --> 00:05:32,180
look for the specific<font color="#E5E5E5"> failure optimizer</font>

128
00:05:29,029 --> 00:05:36,649
would expect to find four rows but in a

129
00:05:32,180 --> 00:05:38,240
DB<font color="#E5E5E5"> light the twice as many distinct</font>

130
00:05:36,649 --> 00:05:39,860
values of the actual<font color="#E5E5E5"> arts optimizable</font>

131
00:05:38,240 --> 00:05:43,459
thing there are only two rows to be

132
00:05:39,860 --> 00:05:45,469
found the optimizer will be more likely

133
00:05:43,459 --> 00:05:46,729
to<font color="#E5E5E5"> prefer an index in an ADB case</font>

134
00:05:45,469 --> 00:05:49,430
because in a debate lies<font color="#E5E5E5"> about</font>

135
00:05:46,729 --> 00:05:52,580
statistics<font color="#CCCCCC"> and why did why energy B</font><font color="#E5E5E5"> is</font>

136
00:05:49,430 --> 00:05:55,490
doing that<font color="#E5E5E5"> well like 15 to 20 years ago</font>

137
00:05:52,580 --> 00:05:57,620
the original<font color="#CCCCCC"> InnoDB</font><font color="#E5E5E5"> author back then hey</font>

138
00:05:55,490 --> 00:05:59,209
<font color="#CCCCCC">Kotori he just noticed that</font><font color="#E5E5E5"> for some way</font>

139
00:05:57,620 --> 00:06:01,550
<font color="#CCCCCC">energy B doesn't</font><font color="#E5E5E5"> use the index and he</font>

140
00:05:59,209 --> 00:06:03,339
would like in a deep my skill to<font color="#CCCCCC"> the</font>

141
00:06:01,550 --> 00:06:05,749
index like<font color="#E5E5E5"> he just added times</font><font color="#CCCCCC"> two and</font>

142
00:06:03,339 --> 00:06:07,849
make the<font color="#CCCCCC"> inic twice as more attractive</font>

143
00:06:05,749 --> 00:06:10,159
to<font color="#E5E5E5"> the optimizer</font><font color="#CCCCCC"> and he was happy with</font>

144
00:06:07,849 --> 00:06:11,870
that<font color="#CCCCCC"> and since there since then</font><font color="#E5E5E5"> because</font>

145
00:06:10,159 --> 00:06:14,180
there are many years<font color="#CCCCCC"> past optimized</font><font color="#E5E5E5"> just</font>

146
00:06:11,870 --> 00:06:15,649
kind of<font color="#E5E5E5"> adopted and it's probably</font>

147
00:06:14,180 --> 00:06:17,180
<font color="#E5E5E5">embedded in many parts of that you might</font>

148
00:06:15,649 --> 00:06:20,809
the assumption that<font color="#E5E5E5"> enemies doing that</font>

149
00:06:17,180 --> 00:06:24,219
and as<font color="#E5E5E5"> far as I know they've removed</font>

150
00:06:20,809 --> 00:06:24,219
<font color="#E5E5E5">this time</font><font color="#CCCCCC"> to in my</font><font color="#E5E5E5"> spare age</font>

151
00:06:25,450 --> 00:06:30,920
so the other<font color="#CCCCCC"> problem of</font><font color="#E5E5E5"> course that if</font>

152
00:06:28,910 --> 00:06:33,230
you need all these<font color="#CCCCCC"> 36 you</font><font color="#E5E5E5"> need an index</font>

153
00:06:30,920 --> 00:06:34,730
in and<font color="#E5E5E5"> exists in you need to pay the</font>

154
00:06:33,230 --> 00:06:38,480
price<font color="#CCCCCC"> for an index index it takes place</font>

155
00:06:34,730 --> 00:06:41,030
they takes time to be maintained<font color="#E5E5E5"> and if</font>

156
00:06:38,480 --> 00:06:43,640
usually not user often if you<font color="#E5E5E5"> just need</font>

157
00:06:41,030 --> 00:06:47,450
statistics<font color="#E5E5E5"> and index it just too much</font>

158
00:06:43,640 --> 00:06:50,090
price to place<font color="#E5E5E5"> too expensive and a</font>

159
00:06:47,450 --> 00:06:52,219
<font color="#CCCCCC">solution</font><font color="#E5E5E5"> so from now on I'll be talking</font>

160
00:06:50,090 --> 00:06:54,500
<font color="#CCCCCC">about money a</font><font color="#E5E5E5"> DB for a while and then</font>

161
00:06:52,220 --> 00:06:57,500
later I'll describe<font color="#E5E5E5"> the differences with</font>

162
00:06:54,500 --> 00:06:59,930
my scale<font color="#E5E5E5"> and numeira new versions so</font><font color="#CCCCCC"> the</font>

163
00:06:57,500 --> 00:07:01,820
<font color="#E5E5E5">solution was in that was implemented</font><font color="#CCCCCC"> in</font>

164
00:06:59,930 --> 00:07:04,670
many<font color="#CCCCCC"> AD be called engine independent</font>

165
00:07:01,820 --> 00:07:07,570
table statistics<font color="#E5E5E5"> and it is provide</font>

166
00:07:04,670 --> 00:07:09,860
provides stable precise detailed and

167
00:07:07,570 --> 00:07:11,960
comparable<font color="#E5E5E5"> statistics so it's</font><font color="#CCCCCC"> stable</font>

168
00:07:09,860 --> 00:07:13,970
<font color="#E5E5E5">because the</font><font color="#CCCCCC"> T 6 is calculated once and</font>

169
00:07:11,960 --> 00:07:15,950
then stored in position tables<font color="#E5E5E5"> it's not</font>

170
00:07:13,970 --> 00:07:18,620
calculated and it<font color="#E5E5E5"> every time using</font><font color="#CCCCCC"> some</font>

171
00:07:15,950 --> 00:07:21,380
<font color="#E5E5E5">random drives</font><font color="#CCCCCC"> it's precise</font><font color="#E5E5E5"> because</font><font color="#CCCCCC"> maybe</font>

172
00:07:18,620 --> 00:07:23,420
<font color="#CCCCCC">analyze all</font><font color="#E5E5E5"> the data are</font><font color="#CCCCCC"> not</font><font color="#E5E5E5"> just very</font>

173
00:07:21,380 --> 00:07:25,850
<font color="#CCCCCC">very small percentage of the data so it</font>

174
00:07:23,420 --> 00:07:28,490
gets<font color="#CCCCCC"> very good representation of all the</font>

175
00:07:25,850 --> 00:07:32,020
data is<font color="#E5E5E5"> and statistics is actually close</font>

176
00:07:28,490 --> 00:07:34,100
to<font color="#E5E5E5"> actual data</font><font color="#CCCCCC"> it's detailed because</font>

177
00:07:32,020 --> 00:07:35,630
this engine independent statistic

178
00:07:34,100 --> 00:07:38,690
remembers a lot<font color="#E5E5E5"> more information than</font>

179
00:07:35,630 --> 00:07:40,880
<font color="#E5E5E5">just cardinality</font><font color="#CCCCCC"> with just one number so</font>

180
00:07:38,690 --> 00:07:42,560
it can it allows optimizer to know more

181
00:07:40,880 --> 00:07:44,510
<font color="#CCCCCC">about the</font><font color="#E5E5E5"> data and create</font><font color="#CCCCCC"> better</font>

182
00:07:42,560 --> 00:07:45,770
execution plans and it's calculated by

183
00:07:44,510 --> 00:07:48,110
the server<font color="#E5E5E5"> not by the engine so it</font>

184
00:07:45,770 --> 00:07:51,710
calculates identical for all engines<font color="#E5E5E5"> so</font>

185
00:07:48,110 --> 00:07:54,770
cost estimations are identical and<font color="#CCCCCC"> the</font>

186
00:07:51,710 --> 00:07:56,870
comparables optimizer can calculate the

187
00:07:54,770 --> 00:07:58,549
cost for<font color="#CCCCCC"> one table</font><font color="#E5E5E5"> on one engine</font><font color="#CCCCCC"> and for</font>

188
00:07:56,870 --> 00:08:01,580
another table<font color="#CCCCCC"> in different engine and</font>

189
00:07:58,550 --> 00:08:03,980
then compare them<font color="#E5E5E5"> and decide in what</font>

190
00:08:01,580 --> 00:08:09,789
<font color="#E5E5E5">order</font><font color="#CCCCCC"> it's better</font><font color="#E5E5E5"> to execute the query</font>

191
00:08:03,980 --> 00:08:12,320
<font color="#E5E5E5">for</font><font color="#CCCCCC"> example to join now I'm not going to</font>

192
00:08:09,790 --> 00:08:13,640
recite the manual so this is just I'm

193
00:08:12,320 --> 00:08:17,090
just<font color="#E5E5E5"> give you a few</font><font color="#CCCCCC"> pointers few</font>

194
00:08:13,640 --> 00:08:19,159
<font color="#CCCCCC">keywords</font><font color="#E5E5E5"> industry either download my</font>

195
00:08:17,090 --> 00:08:20,929
talk later<font color="#E5E5E5"> or</font><font color="#CCCCCC"> just make a picture</font><font color="#E5E5E5"> of the</font>

196
00:08:19,160 --> 00:08:23,240
slide and<font color="#CCCCCC"> this other words you can</font><font color="#E5E5E5"> later</font>

197
00:08:20,930 --> 00:08:24,980
look up in the<font color="#CCCCCC"> manual</font><font color="#E5E5E5"> so very</font><font color="#CCCCCC"> briefly it</font>

198
00:08:23,240 --> 00:08:26,600
is<font color="#E5E5E5"> implemented</font><font color="#CCCCCC"> by having new tables in</font>

199
00:08:24,980 --> 00:08:28,850
the my SQL schema where all the

200
00:08:26,600 --> 00:08:32,090
<font color="#E5E5E5">information of a statistic is stored as</font>

201
00:08:28,850 --> 00:08:34,870
a new system<font color="#CCCCCC"> variables used type tables</font>

202
00:08:32,090 --> 00:08:36,320
or the<font color="#CCCCCC"> tells the optimizer</font><font color="#E5E5E5"> when to use</font>

203
00:08:34,870 --> 00:08:38,870
information

204
00:08:36,320 --> 00:08:40,580
this engine independent statistics<font color="#E5E5E5"> it</font>

205
00:08:38,870 --> 00:08:42,560
could be never used or preferable and<font color="#E5E5E5"> so</font>

206
00:08:40,580 --> 00:08:43,790
on and this optimize the use<font color="#E5E5E5"> condition</font>

207
00:08:42,559 --> 00:08:47,030
selectivity we shall be talking<font color="#E5E5E5"> about</font>

208
00:08:43,789 --> 00:08:48,949
<font color="#E5E5E5">for the rest of my talk which tells the</font>

209
00:08:47,030 --> 00:08:50,780
optimizer which exactly parts of the

210
00:08:48,950 --> 00:08:52,790
engine<font color="#E5E5E5"> dependent statistics optimizes</font>

211
00:08:50,780 --> 00:08:55,510
allowed to use and there are optional

212
00:08:52,790 --> 00:08:59,150
clauses in the analyze table that can

213
00:08:55,510 --> 00:09:00,700
where you<font color="#E5E5E5"> can specify what parts</font><font color="#CCCCCC"> of the</font>

214
00:08:59,150 --> 00:09:03,079
table<font color="#E5E5E5"> should be</font>

215
00:09:00,700 --> 00:09:04,610
<font color="#E5E5E5">statistic what for what part of the</font>

216
00:09:03,080 --> 00:09:06,590
table<font color="#E5E5E5"> the</font><font color="#CCCCCC"> statistic should be</font><font color="#E5E5E5"> calculated</font>

217
00:09:04,610 --> 00:09:10,810
it could be run for all table of only

218
00:09:06,590 --> 00:09:13,250
<font color="#E5E5E5">some indexes of run some columns but</font>

219
00:09:10,810 --> 00:09:15,560
enough<font color="#E5E5E5"> this theory now let's get to</font><font color="#CCCCCC"> the</font>

220
00:09:13,250 --> 00:09:17,390
<font color="#E5E5E5">examples and for the examples I use the</font>

221
00:09:15,560 --> 00:09:19,910
employees database which can<font color="#E5E5E5"> be</font>

222
00:09:17,390 --> 00:09:21,620
<font color="#CCCCCC">downloaded from the Jabez github and jet</font>

223
00:09:19,910 --> 00:09:25,430
<font color="#CCCCCC">purpose the guy who's</font><font color="#E5E5E5"> giving</font><font color="#CCCCCC"> talks</font><font color="#E5E5E5"> at</font>

224
00:09:21,620 --> 00:09:27,530
<font color="#E5E5E5">the</font><font color="#CCCCCC"> forum it's not a</font><font color="#E5E5E5"> very big data set</font>

225
00:09:25,430 --> 00:09:29,900
but it's not exactly<font color="#E5E5E5"> small either one</font>

226
00:09:27,530 --> 00:09:31,430
had 67 megabytes of data in the

227
00:09:29,900 --> 00:09:34,040
employees<font color="#E5E5E5"> table has</font><font color="#CCCCCC"> three hundred</font>

228
00:09:31,430 --> 00:09:37,310
<font color="#E5E5E5">thousand records and sorry table head</font>

229
00:09:34,040 --> 00:09:40,390
like 2.8 million records so let's<font color="#E5E5E5"> lower</font>

230
00:09:37,310 --> 00:09:42,709
it<font color="#E5E5E5"> it's you download it from the</font>

231
00:09:40,390 --> 00:09:44,930
<font color="#E5E5E5">Jeopardy table then you sort those</font>

232
00:09:42,710 --> 00:09:46,580
source<font color="#E5E5E5"> in place the despair which</font>

233
00:09:44,930 --> 00:09:49,670
creates on the table<font color="#E5E5E5"> and performs all</font>

234
00:09:46,580 --> 00:09:52,760
<font color="#E5E5E5">the load data to load all the data and</font>

235
00:09:49,670 --> 00:09:54,589
then<font color="#E5E5E5"> I enable engine independent table</font>

236
00:09:52,760 --> 00:09:56,480
<font color="#CCCCCC">statistics by setting</font><font color="#E5E5E5"> you start tables</font>

237
00:09:54,590 --> 00:09:58,280
preferably<font color="#E5E5E5"> and then I analyze all the</font>

238
00:09:56,480 --> 00:10:00,140
table to collect the statistics there's

239
00:09:58,280 --> 00:10:02,079
no need<font color="#E5E5E5"> to specify any optional courses</font>

240
00:10:00,140 --> 00:10:04,280
for<font color="#E5E5E5"> the</font><font color="#CCCCCC"> analyzed here because if</font>

241
00:10:02,080 --> 00:10:06,710
<font color="#E5E5E5">statistics is enabled preferably then</font>

242
00:10:04,280 --> 00:10:08,660
<font color="#CCCCCC">analyze will automatically do</font><font color="#E5E5E5"> collect</font>

243
00:10:06,710 --> 00:10:10,070
all the<font color="#CCCCCC"> engineerin statistics</font><font color="#E5E5E5"> so you</font>

244
00:10:08,660 --> 00:10:11,480
don't need to modify<font color="#E5E5E5"> your application</font>

245
00:10:10,070 --> 00:10:14,200
and you write all the<font color="#CCCCCC"> analyzed table</font>

246
00:10:11,480 --> 00:10:16,670
statements<font color="#E5E5E5"> you just need to enable</font>

247
00:10:14,200 --> 00:10:18,950
<font color="#E5E5E5">engineering</font><font color="#CCCCCC"> 36</font><font color="#E5E5E5"> ones and then it'll</font>

248
00:10:16,670 --> 00:10:20,959
automatically work for<font color="#CCCCCC"> all of your</font>

249
00:10:18,950 --> 00:10:22,850
application<font color="#E5E5E5"> and you</font><font color="#CCCCCC"> can see that it's</font>

250
00:10:20,960 --> 00:10:27,680
not<font color="#E5E5E5"> a very</font><font color="#CCCCCC"> big data set because</font><font color="#E5E5E5"> this one</font>

251
00:10:22,850 --> 00:10:29,870
took only<font color="#E5E5E5"> less than</font><font color="#CCCCCC"> 10 seconds so how</font>

252
00:10:27,680 --> 00:10:32,989
does this one help to optimize your

253
00:10:29,870 --> 00:10:35,480
<font color="#E5E5E5">choirs</font><font color="#CCCCCC"> so I said optimize use condition</font>

254
00:10:32,990 --> 00:10:36,670
selectivity<font color="#CCCCCC"> 1 which tells optimizer not</font>

255
00:10:35,480 --> 00:10:38,710
to use any

256
00:10:36,670 --> 00:10:40,329
and<font color="#E5E5E5"> in engineering statistics basically</font>

257
00:10:38,710 --> 00:10:42,490
<font color="#CCCCCC">it only</font><font color="#E5E5E5"> uses the</font><font color="#CCCCCC"> data</font><font color="#E5E5E5"> that were</font>

258
00:10:40,330 --> 00:10:45,340
available before<font color="#CCCCCC"> engineer</font><font color="#E5E5E5"> apprentice was</font>

259
00:10:42,490 --> 00:10:47,320
introduced and I want to find<font color="#E5E5E5"> all the</font>

260
00:10:45,340 --> 00:10:49,390
<font color="#E5E5E5">managers from all departments in this</font>

261
00:10:47,320 --> 00:10:51,280
example in place database<font color="#CCCCCC"> I joined</font>

262
00:10:49,390 --> 00:10:53,680
departments with employees with manager

263
00:10:51,280 --> 00:10:55,449
with titles where title equals manager

264
00:10:53,680 --> 00:10:57,489
and for the purpose of<font color="#E5E5E5"> the examples</font>

265
00:10:55,450 --> 00:11:02,140
important to remember that title poem is

266
00:10:57,490 --> 00:11:03,580
not<font color="#E5E5E5"> indexed then money</font><font color="#CCCCCC"> DB</font><font color="#E5E5E5"> does something</font>

267
00:11:02,140 --> 00:11:04,840
with<font color="#E5E5E5"> the data and returns the result set</font>

268
00:11:03,580 --> 00:11:08,170
in<font color="#E5E5E5"> 15 seconds</font>

269
00:11:04,840 --> 00:11:10,390
now I enable<font color="#CCCCCC"> optimize use</font><font color="#E5E5E5"> conditions</font>

270
00:11:08,170 --> 00:11:12,610
<font color="#CCCCCC">rule 53</font><font color="#E5E5E5"> which allows optimized to use</font>

271
00:11:10,390 --> 00:11:14,890
Pro column<font color="#E5E5E5"> statistics that</font><font color="#CCCCCC"> is for</font><font color="#E5E5E5"> non</font>

272
00:11:12,610 --> 00:11:17,320
index columns and the same query is

273
00:11:14,890 --> 00:11:19,780
executed under<font color="#CCCCCC"> a second this</font><font color="#E5E5E5"> is 16 times</font>

274
00:11:17,320 --> 00:11:22,870
improvement<font color="#CCCCCC"> it's not 16% it's</font><font color="#E5E5E5"> not 1.6</font>

275
00:11:19,780 --> 00:11:26,199
times<font color="#E5E5E5"> it's 16 times improvement and so</font>

276
00:11:22,870 --> 00:11:29,290
it's pretty remarkable<font color="#CCCCCC"> to me</font><font color="#E5E5E5"> and let's</font>

277
00:11:26,200 --> 00:11:31,180
see why<font color="#E5E5E5"> that is</font><font color="#CCCCCC"> happen this is a result</font>

278
00:11:29,290 --> 00:11:33,790
of<font color="#CCCCCC"> explained extended for the first</font>

279
00:11:31,180 --> 00:11:36,670
query when the optimizer cannot use

280
00:11:33,790 --> 00:11:38,920
perform statistics<font color="#E5E5E5"> it is explained</font>

281
00:11:36,670 --> 00:11:42,520
extended<font color="#E5E5E5"> so that's column filtered which</font>

282
00:11:38,920 --> 00:11:45,280
tells how<font color="#CCCCCC"> many what percentage of the</font>

283
00:11:42,520 --> 00:11:47,949
table optimizer things will pass the

284
00:11:45,280 --> 00:11:50,670
where clause<font color="#CCCCCC"> and because there's no</font><font color="#E5E5E5"> data</font>

285
00:11:47,950 --> 00:11:53,020
available<font color="#E5E5E5"> for non index columns</font>

286
00:11:50,670 --> 00:11:55,329
<font color="#E5E5E5">automatic doesn't know so he just says</font>

287
00:11:53,020 --> 00:11:59,530
hundred percent<font color="#E5E5E5"> everything might pass</font>

288
00:11:55,330 --> 00:12:01,930
the where<font color="#E5E5E5"> clause but if we enable if we</font>

289
00:11:59,530 --> 00:12:04,000
allow<font color="#E5E5E5"> optimized reuse Pro column</font>

290
00:12:01,930 --> 00:12:06,099
<font color="#E5E5E5">statistics statistics for not</font><font color="#CCCCCC"> indexed</font>

291
00:12:04,000 --> 00:12:07,990
columns then optimizer

292
00:12:06,100 --> 00:12:09,760
knows the<font color="#E5E5E5"> cardinality for</font><font color="#CCCCCC"> non in</font>

293
00:12:07,990 --> 00:12:11,800
exponent and minimal amounts<font color="#E5E5E5"> non value</font>

294
00:12:09,760 --> 00:12:14,350
phone on<font color="#E5E5E5"> index</font><font color="#CCCCCC"> poems and optimizer can</font>

295
00:12:11,800 --> 00:12:18,339
figure<font color="#CCCCCC"> out that not all employees</font><font color="#E5E5E5"> are in</font>

296
00:12:14,350 --> 00:12:20,350
fact managers and only about 14% of<font color="#CCCCCC"> the</font>

297
00:12:18,340 --> 00:12:23,590
titles will match the where clause and

298
00:12:20,350 --> 00:12:25,270
in<font color="#E5E5E5"> this Elizabeth in in this way case</font>

299
00:12:23,590 --> 00:12:27,280
<font color="#CCCCCC">optimize</font><font color="#E5E5E5"> decide to join</font><font color="#CCCCCC"> tables in</font>

300
00:12:25,270 --> 00:12:29,680
different order<font color="#CCCCCC"> from full table scan of</font>

301
00:12:27,280 --> 00:12:31,949
the titles table and this gives<font color="#E5E5E5"> 16 times</font>

302
00:12:29,680 --> 00:12:31,949
improvement

303
00:12:32,670 --> 00:12:36,550
now before<font color="#CCCCCC"> talking about histograms I</font>

304
00:12:35,110 --> 00:12:40,450
want to explain what<font color="#CCCCCC"> they aqua fide</font>

305
00:12:36,550 --> 00:12:43,689
histogram is this is not an<font color="#E5E5E5"> accurate</font>

306
00:12:40,450 --> 00:12:44,470
histogram<font color="#E5E5E5"> it's a usual</font><font color="#CCCCCC"> histogram that</font>

307
00:12:43,690 --> 00:12:45,700
you see everywhere

308
00:12:44,470 --> 00:12:49,790
<font color="#CCCCCC">exactly</font><font color="#E5E5E5"> with</font>

309
00:12:45,700 --> 00:12:53,420
the red line<font color="#E5E5E5"> this shows some imaginary</font>

310
00:12:49,790 --> 00:12:56,900
data<font color="#CCCCCC"> distribution</font><font color="#E5E5E5"> and this is histogram</font>

311
00:12:53,420 --> 00:12:59,900
for this data distribution<font color="#E5E5E5"> under</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> red</font>

312
00:12:56,900 --> 00:13:03,470
line<font color="#E5E5E5"> I've drawn with 5 bars 5</font><font color="#CCCCCC"> buckets</font>

313
00:12:59,900 --> 00:13:04,790
they all have same have the<font color="#E5E5E5"> same width</font>

314
00:13:03,470 --> 00:13:08,089
<font color="#CCCCCC">that's why it's</font><font color="#E5E5E5"> called equal width and</font>

315
00:13:04,790 --> 00:13:09,620
the height of the bar is equal is

316
00:13:08,089 --> 00:13:13,430
proportional to<font color="#E5E5E5"> the area under the curve</font>

317
00:13:09,620 --> 00:13:16,160
<font color="#CCCCCC">and</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> is the height histogram where</font>

318
00:13:13,430 --> 00:13:18,589
<font color="#E5E5E5">all the bars have</font><font color="#CCCCCC"> the same height but</font>

319
00:13:16,160 --> 00:13:21,949
<font color="#E5E5E5">different with that</font><font color="#CCCCCC"> were also five of</font>

320
00:13:18,589 --> 00:13:24,050
them<font color="#E5E5E5"> but in this case the area under the</font>

321
00:13:21,950 --> 00:13:27,080
<font color="#CCCCCC">curve is all might be obvious all the</font>

322
00:13:24,050 --> 00:13:28,550
same and why would we<font color="#E5E5E5"> want</font><font color="#CCCCCC"> to do this</font>

323
00:13:27,080 --> 00:13:32,089
strange<font color="#E5E5E5"> thing instead</font><font color="#CCCCCC"> of normal</font>

324
00:13:28,550 --> 00:13:34,279
histograms<font color="#E5E5E5"> because all we remember for a</font>

325
00:13:32,089 --> 00:13:36,170
<font color="#E5E5E5">recall is those five numbers</font><font color="#CCCCCC"> well more</font>

326
00:13:34,279 --> 00:13:38,660
than<font color="#E5E5E5"> five but still he said number</font><font color="#CCCCCC"> of</font>

327
00:13:36,170 --> 00:13:40,250
bars<font color="#E5E5E5"> to describe</font><font color="#CCCCCC"> a histogram</font><font color="#E5E5E5"> and then</font>

328
00:13:38,660 --> 00:13:43,160
later<font color="#E5E5E5"> optimizer needs to use this data</font>

329
00:13:40,250 --> 00:13:44,870
to<font color="#E5E5E5"> kind of restore</font><font color="#CCCCCC"> the original data</font>

330
00:13:43,160 --> 00:13:47,180
<font color="#CCCCCC">distribution to understand the original</font>

331
00:13:44,870 --> 00:13:49,100
data distribution and if<font color="#E5E5E5"> optimizer would</font>

332
00:13:47,180 --> 00:13:51,349
try<font color="#E5E5E5"> to restore</font><font color="#CCCCCC"> the original distribution</font>

333
00:13:49,100 --> 00:13:53,390
<font color="#E5E5E5">based</font><font color="#CCCCCC"> on the accuracy histogram this</font><font color="#E5E5E5"> is</font>

334
00:13:51,350 --> 00:13:57,080
what it<font color="#E5E5E5"> would get you see this huge</font>

335
00:13:53,390 --> 00:13:59,260
error in the most<font color="#E5E5E5"> interesting part of</font>

336
00:13:57,080 --> 00:14:01,700
the curve<font color="#CCCCCC"> where the values</font><font color="#E5E5E5"> are</font><font color="#CCCCCC"> high</font><font color="#E5E5E5"> and</font>

337
00:13:59,260 --> 00:14:04,670
if you try<font color="#E5E5E5"> to restore the girl from the</font>

338
00:14:01,700 --> 00:14:06,080
equivocally height histogram the

339
00:14:04,670 --> 00:14:07,640
<font color="#E5E5E5">interesting part of the curve is</font>

340
00:14:06,080 --> 00:14:10,339
described much more precise as errors

341
00:14:07,640 --> 00:14:12,350
much smaller basically<font color="#CCCCCC"> a</font><font color="#E5E5E5"> clear-eyed</font>

342
00:14:10,339 --> 00:14:14,180
histogram<font color="#E5E5E5"> allows you to describe the</font>

343
00:14:12,350 --> 00:14:16,640
<font color="#CCCCCC">data</font><font color="#E5E5E5"> distribution much more precisely</font>

344
00:14:14,180 --> 00:14:19,870
with a smaller number<font color="#CCCCCC"> of</font><font color="#E5E5E5"> winners this is</font>

345
00:14:16,640 --> 00:14:22,130
what my enemy is using for histograms

346
00:14:19,870 --> 00:14:24,350
now let's see if how histograms are

347
00:14:22,130 --> 00:14:26,720
helping to optimize the choirs and for

348
00:14:24,350 --> 00:14:29,570
this one we<font color="#CCCCCC"> need an</font><font color="#E5E5E5"> example of some data</font>

349
00:14:26,720 --> 00:14:31,959
with non-uniform<font color="#CCCCCC"> distribution one</font><font color="#E5E5E5"> state</font>

350
00:14:29,570 --> 00:14:35,510
let's look at the salary values from the

351
00:14:31,959 --> 00:14:38,239
employee database<font color="#CCCCCC"> and we calculate the</font>

352
00:14:35,510 --> 00:14:39,470
midpoint of mid<font color="#CCCCCC"> soliders exactly in the</font>

353
00:14:38,240 --> 00:14:42,560
<font color="#CCCCCC">middle between minimum and maximum</font>

354
00:14:39,470 --> 00:14:46,370
salary but the first query<font color="#E5E5E5"> it's about</font>

355
00:14:42,560 --> 00:14:49,459
<font color="#CCCCCC">100,000</font><font color="#E5E5E5"> and now let's see what select</font>

356
00:14:46,370 --> 00:14:51,920
all the employees and their titles from

357
00:14:49,459 --> 00:14:54,380
<font color="#E5E5E5">the salary table with where the salary</font>

358
00:14:51,920 --> 00:14:57,490
<font color="#E5E5E5">was above the midpoint above the 100,000</font>

359
00:14:54,380 --> 00:15:01,750
<font color="#E5E5E5">again in some time after churn some data</font>

360
00:14:57,490 --> 00:15:03,940
returns<font color="#CCCCCC"> a</font><font color="#E5E5E5"> result in 18 seconds 19</font>

361
00:15:01,750 --> 00:15:05,649
seconds and but if we enable<font color="#E5E5E5"> the use of</font>

362
00:15:03,940 --> 00:15:07,779
histograms by setting<font color="#CCCCCC"> optimize use</font>

363
00:15:05,649 --> 00:15:11,890
conditions<font color="#CCCCCC"> in PV</font><font color="#E5E5E5"> equals 4 you'll get the</font>

364
00:15:07,779 --> 00:15:15,279
same result<font color="#CCCCCC"> three times faster okay</font>

365
00:15:11,890 --> 00:15:18,240
<font color="#E5E5E5">again why is it happening</font><font color="#CCCCCC"> because</font><font color="#E5E5E5"> if you</font>

366
00:15:15,279 --> 00:15:21,640
<font color="#CCCCCC">don't use histograms</font><font color="#E5E5E5"> then oh</font><font color="#CCCCCC"> they're all</font>

367
00:15:18,240 --> 00:15:23,709
all the data that<font color="#CCCCCC"> optimising knows about</font>

368
00:15:21,640 --> 00:15:25,600
the table<font color="#E5E5E5"> is it not the minimum value</font>

369
00:15:23,709 --> 00:15:28,119
<font color="#CCCCCC">for</font><font color="#E5E5E5"> the sorry</font><font color="#CCCCCC"> no the maximum value for</font>

370
00:15:25,600 --> 00:15:29,680
<font color="#E5E5E5">the server and</font><font color="#CCCCCC"> because we are searching</font>

371
00:15:28,120 --> 00:15:33,310
<font color="#E5E5E5">for everything which</font><font color="#CCCCCC"> is above the</font>

372
00:15:29,680 --> 00:15:36,550
<font color="#E5E5E5">midpoint optimizer can figure</font><font color="#CCCCCC"> out okay</font>

373
00:15:33,310 --> 00:15:38,410
so this is midpoint so about half<font color="#E5E5E5"> of the</font>

374
00:15:36,550 --> 00:15:39,699
data<font color="#E5E5E5"> should</font><font color="#CCCCCC"> be above midpoint</font><font color="#E5E5E5"> about half</font>

375
00:15:38,410 --> 00:15:42,219
<font color="#E5E5E5">of the data</font><font color="#CCCCCC"> should</font><font color="#E5E5E5"> be below midpoint</font>

376
00:15:39,700 --> 00:15:44,790
<font color="#CCCCCC">namsom optimizer</font><font color="#E5E5E5"> things and indeed if</font>

377
00:15:42,220 --> 00:15:46,930
you<font color="#E5E5E5"> see the filtered column is about</font><font color="#CCCCCC"> 50%</font>

378
00:15:44,790 --> 00:15:49,560
<font color="#E5E5E5">let's optimize the thing that half of</font>

379
00:15:46,930 --> 00:15:52,719
the<font color="#E5E5E5"> crows will pass there we're close</font>

380
00:15:49,560 --> 00:15:54,189
<font color="#E5E5E5">but</font><font color="#CCCCCC"> that at least half of the rows would</font>

381
00:15:52,720 --> 00:15:55,690
<font color="#E5E5E5">have passed the where clause if the</font>

382
00:15:54,190 --> 00:15:58,600
salads would be distributed uniformly

383
00:15:55,690 --> 00:16:00,850
but in this<font color="#E5E5E5"> in place database just</font>

384
00:15:58,600 --> 00:16:02,860
<font color="#E5E5E5">wasn't</font><font color="#CCCCCC"> available you know</font><font color="#E5E5E5"> so it's</font><font color="#CCCCCC"> indeed</font>

385
00:16:00,850 --> 00:16:05,079
<font color="#E5E5E5">very unusual for</font><font color="#CCCCCC"> me</font><font color="#E5E5E5"> and if we enable</font>

386
00:16:02,860 --> 00:16:07,480
histograms optimizer can see that<font color="#E5E5E5"> indeed</font>

387
00:16:05,079 --> 00:16:09,849
only<font color="#E5E5E5"> less</font><font color="#CCCCCC"> than</font><font color="#E5E5E5"> 5% of salaries fly above</font>

388
00:16:07,480 --> 00:16:11,440
<font color="#CCCCCC">the midpoint</font><font color="#E5E5E5"> in this case optimizer</font>

389
00:16:09,850 --> 00:16:17,350
again<font color="#CCCCCC"> joins tables in different order</font>

390
00:16:11,440 --> 00:16:18,430
<font color="#CCCCCC">and give it if a</font><font color="#E5E5E5"> three</font><font color="#CCCCCC"> times feed on the</font>

391
00:16:17,350 --> 00:16:22,779
next interesting<font color="#CCCCCC"> feature that was</font>

392
00:16:18,430 --> 00:16:26,140
<font color="#E5E5E5">implemented its sampling so this is a</font>

393
00:16:22,779 --> 00:16:29,850
query which<font color="#E5E5E5"> could be realistically used</font>

394
00:16:26,140 --> 00:16:33,130
by I<font color="#E5E5E5"> don't know HR department by</font>

395
00:16:29,850 --> 00:16:36,250
analyzing whether there's<font color="#CCCCCC"> solid-solid</font><font color="#E5E5E5"> is</font>

396
00:16:33,130 --> 00:16:40,839
a distributed<font color="#CCCCCC"> fair or there</font><font color="#E5E5E5"> some people</font>

397
00:16:36,250 --> 00:16:43,510
<font color="#CCCCCC">are getting worse</font><font color="#E5E5E5"> are all stolid is</font>

398
00:16:40,839 --> 00:16:47,020
based on I<font color="#E5E5E5"> don't know sex</font><font color="#CCCCCC"> for origin or</font>

399
00:16:43,510 --> 00:16:49,180
whatever but<font color="#E5E5E5"> this credit it takes the</font>

400
00:16:47,020 --> 00:16:51,550
average salary per<font color="#E5E5E5"> department for all</font>

401
00:16:49,180 --> 00:16:53,500
the people whose last name ends<font color="#E5E5E5"> with of</font>

402
00:16:51,550 --> 00:16:56,979
<font color="#E5E5E5">which supposedly could mean people with</font>

403
00:16:53,500 --> 00:16:58,270
Slavic origin as you<font color="#CCCCCC"> know those those</font>

404
00:16:56,980 --> 00:16:59,860
kind of like where is you cannot

405
00:16:58,270 --> 00:17:00,399
optimize you can optimize from the

406
00:16:59,860 --> 00:17:01,150
<font color="#E5E5E5">indexical</font>

407
00:17:00,399 --> 00:17:02,950
<font color="#E5E5E5">any</font>

408
00:17:01,150 --> 00:17:05,020
it's a ground for that<font color="#E5E5E5"> you cannot get</font>

409
00:17:02,950 --> 00:17:06,100
any original statistics for<font color="#E5E5E5"> that some</font>

410
00:17:05,020 --> 00:17:09,250
<font color="#E5E5E5">Tomatoes</font><font color="#CCCCCC"> doesn't know anything about</font>

411
00:17:06,099 --> 00:17:11,319
this<font color="#E5E5E5"> and it finds fire fire rose because</font>

412
00:17:09,250 --> 00:17:13,869
<font color="#CCCCCC">grow by Department in</font><font color="#E5E5E5"> five seconds and</font>

413
00:17:11,319 --> 00:17:14,740
if you enable sampling<font color="#E5E5E5"> you get the same</font>

414
00:17:13,869 --> 00:17:18,369
result

415
00:17:14,740 --> 00:17:20,740
<font color="#CCCCCC">twelve times</font><font color="#E5E5E5"> faster yes so how does</font>

416
00:17:18,369 --> 00:17:22,599
simply<font color="#E5E5E5"> in grow because there's no other</font>

417
00:17:20,740 --> 00:17:23,859
<font color="#E5E5E5">way for optimized to get any reasonable</font>

418
00:17:22,599 --> 00:17:26,969
information about the data

419
00:17:23,859 --> 00:17:31,419
it reads<font color="#E5E5E5"> few rows from the table and</font>

420
00:17:26,970 --> 00:17:33,010
applies this like condition and then it

421
00:17:31,420 --> 00:17:38,650
except<font color="#CCCCCC"> elates</font><font color="#E5E5E5"> the result</font><font color="#CCCCCC"> to the rest of</font>

422
00:17:33,010 --> 00:17:41,290
<font color="#E5E5E5">the table and indeed without sampling</font>

423
00:17:38,650 --> 00:17:43,450
<font color="#E5E5E5">you can see that filtered poem is</font><font color="#CCCCCC"> one</font>

424
00:17:41,290 --> 00:17:46,720
<font color="#CCCCCC">hundred hundred percent because</font><font color="#E5E5E5"> there's</font>

425
00:17:43,450 --> 00:17:48,040
no histograms no indexes no nothing that

426
00:17:46,720 --> 00:17:49,830
could help optimizer to know anything

427
00:17:48,040 --> 00:17:52,360
<font color="#CCCCCC">about the data and</font><font color="#E5E5E5"> with sampling</font>

428
00:17:49,830 --> 00:17:54,550
optimizer can realize<font color="#CCCCCC"> that indeed very</font>

429
00:17:52,360 --> 00:17:57,250
little<font color="#E5E5E5"> there are very few rows that</font>

430
00:17:54,550 --> 00:17:58,990
matches<font color="#CCCCCC"> that we are</font><font color="#E5E5E5"> close and it</font>

431
00:17:57,250 --> 00:18:01,330
optimizes<font color="#E5E5E5"> joins tables in different</font>

432
00:17:58,990 --> 00:18:05,290
order<font color="#E5E5E5"> and this is</font><font color="#CCCCCC"> twelve twelve times</font>

433
00:18:01,330 --> 00:18:07,480
speed up everything that<font color="#CCCCCC"> I was talking</font>

434
00:18:05,290 --> 00:18:11,740
<font color="#CCCCCC">about</font><font color="#E5E5E5"> now it was implemented in my ad be</font>

435
00:18:07,480 --> 00:18:13,210
<font color="#CCCCCC">ten</font><font color="#E5E5E5"> point all which when</font><font color="#CCCCCC"> J in 2014 so it</font>

436
00:18:11,740 --> 00:18:16,900
was it's quite stable

437
00:18:13,210 --> 00:18:19,179
<font color="#E5E5E5">well in fact</font><font color="#CCCCCC"> ten all is already reach</font>

438
00:18:16,900 --> 00:18:22,300
<font color="#E5E5E5">its end of life so don't use that</font><font color="#CCCCCC"> use at</font>

439
00:18:19,179 --> 00:18:24,910
least<font color="#CCCCCC"> an</font><font color="#E5E5E5"> one and in this</font><font color="#CCCCCC"> married</font>

440
00:18:22,300 --> 00:18:26,800
<font color="#CCCCCC">emission or engine independent statistic</font>

441
00:18:24,910 --> 00:18:29,860
remembers the number of rows per table

442
00:18:26,800 --> 00:18:31,780
and<font color="#E5E5E5"> the cardinality index and for every</font>

443
00:18:29,860 --> 00:18:33,610
column it remembers number of<font color="#E5E5E5"> distinct</font>

444
00:18:31,780 --> 00:18:35,440
<font color="#CCCCCC">rayless minimum and maximum value amount</font>

445
00:18:33,610 --> 00:18:37,540
of nulls<font color="#E5E5E5"> average value length for</font>

446
00:18:35,440 --> 00:18:42,940
<font color="#E5E5E5">Strings and this equifax histogram and</font>

447
00:18:37,540 --> 00:18:46,889
<font color="#CCCCCC">sampling</font><font color="#E5E5E5"> also works last year</font><font color="#CCCCCC"> maria a</font>

448
00:18:42,940 --> 00:18:50,260
<font color="#CCCCCC">metal eight all went j they implemented</font>

449
00:18:46,890 --> 00:18:51,640
conceptually similar feature it's called

450
00:18:50,260 --> 00:18:54,910
different is called<font color="#E5E5E5"> optimized statistic</font>

451
00:18:51,640 --> 00:18:58,960
in<font color="#CCCCCC"> mice girl</font><font color="#E5E5E5"> and they remember amount of</font>

452
00:18:54,910 --> 00:19:00,400
<font color="#E5E5E5">nails your column and but they have to</font>

453
00:18:58,960 --> 00:19:01,150
<font color="#E5E5E5">live two different</font><font color="#CCCCCC"> kinds of</font><font color="#E5E5E5"> histogram</font>

454
00:19:00,400 --> 00:19:03,730
the<font color="#E5E5E5"> grave</font>

455
00:19:01,150 --> 00:19:05,950
have<font color="#E5E5E5"> Equifax histograms until singleton</font>

456
00:19:03,730 --> 00:19:07,780
histograms<font color="#CCCCCC"> and solute on watch rock much</font>

457
00:19:05,950 --> 00:19:08,780
<font color="#CCCCCC">better</font><font color="#E5E5E5"> than a graphite if you have data</font>

458
00:19:07,780 --> 00:19:11,330
with very few

459
00:19:08,780 --> 00:19:13,310
distinct<font color="#CCCCCC"> vendors</font><font color="#E5E5E5"> like if you have a sex</font>

460
00:19:11,330 --> 00:19:15,710
column or<font color="#CCCCCC"> a column with just</font><font color="#E5E5E5"> no venues</font>

461
00:19:13,310 --> 00:19:18,500
<font color="#E5E5E5">this this case by singleton histograms</font>

462
00:19:15,710 --> 00:19:21,050
broken<font color="#E5E5E5"> a graphite basically don't also</font>

463
00:19:18,500 --> 00:19:23,560
<font color="#E5E5E5">if you try to do try to collect</font>

464
00:19:21,050 --> 00:19:26,690
<font color="#E5E5E5">histogram for really really huge table</font>

465
00:19:23,560 --> 00:19:28,340
and my scale starts keeping values<font color="#E5E5E5"> to</font>

466
00:19:26,690 --> 00:19:30,380
keep all the data center memory and it

467
00:19:28,340 --> 00:19:32,629
gives significant speed up<font color="#E5E5E5"> as compared</font>

468
00:19:30,380 --> 00:19:37,250
<font color="#CCCCCC">to</font><font color="#E5E5E5"> how many debates and all collects mr.</font>

469
00:19:32,630 --> 00:19:39,020
Graham's<font color="#E5E5E5"> on the huge tables and in a few</font>

470
00:19:37,250 --> 00:19:41,990
months<font color="#E5E5E5"> Merida</font><font color="#CCCCCC"> bitchin for will</font><font color="#E5E5E5"> become J</font>

471
00:19:39,020 --> 00:19:43,580
where this engineer<font color="#CCCCCC"> Pence is enabled by</font>

472
00:19:41,990 --> 00:19:45,260
<font color="#E5E5E5">default</font><font color="#CCCCCC"> which is basically the main</font>

473
00:19:43,580 --> 00:19:47,210
reason why I'm giving<font color="#E5E5E5"> this talk</font><font color="#CCCCCC"> so if</font>

474
00:19:45,260 --> 00:19:48,500
you start upgrading you should know this

475
00:19:47,210 --> 00:19:50,120
<font color="#CCCCCC">enable</font><font color="#E5E5E5"> what default you don't need to do</font>

476
00:19:48,500 --> 00:19:51,710
anything anymore<font color="#CCCCCC"> everything will just</font>

477
00:19:50,120 --> 00:19:55,250
automatically and magically<font color="#E5E5E5"> be</font><font color="#CCCCCC"> it'll be</font>

478
00:19:51,710 --> 00:19:56,930
faster and<font color="#CCCCCC"> Marilla bitchin for also</font>

479
00:19:55,250 --> 00:19:59,150
collects histogram by sampling<font color="#E5E5E5"> by</font>

480
00:19:56,930 --> 00:20:02,870
skipping radius so that<font color="#CCCCCC"> analyze table</font>

481
00:19:59,150 --> 00:20:05,780
will<font color="#CCCCCC"> be fast</font><font color="#E5E5E5"> and mainly before 10 for</font>

482
00:20:02,870 --> 00:20:07,699
<font color="#CCCCCC">analyze for</font><font color="#E5E5E5"> engine Pacific</font><font color="#CCCCCC"> Statistics</font>

483
00:20:05,780 --> 00:20:09,830
was slow this was the reason<font color="#E5E5E5"> why it</font>

484
00:20:07,700 --> 00:20:13,760
wasn't lined<font color="#E5E5E5"> up by</font><font color="#CCCCCC"> default and this</font>

485
00:20:09,830 --> 00:20:16,360
feature was mostly implemented<font color="#E5E5E5"> as a</font>

486
00:20:13,760 --> 00:20:19,160
google Summer of Code project<font color="#E5E5E5"> last</font><font color="#CCCCCC"> year</font>

487
00:20:16,360 --> 00:20:20,100
that's all thank you

488
00:20:19,160 --> 00:20:25,100
have any questions

489
00:20:20,100 --> 00:20:25,100
[Applause]

490
00:20:25,179 --> 00:20:36,070
yes yeah

491
00:20:36,100 --> 00:20:39,100
yeah

492
00:20:42,810 --> 00:20:45,620
yeah

493
00:20:48,530 --> 00:20:56,090
<font color="#CCCCCC">I'm</font><font color="#E5E5E5"> talking about</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> one yes so the</font>

494
00:20:53,960 --> 00:20:59,900
question<font color="#CCCCCC"> is about how I compared the</font>

495
00:20:56,090 --> 00:21:03,379
results<font color="#E5E5E5"> and execution times for the same</font>

496
00:20:59,900 --> 00:21:04,700
<font color="#E5E5E5">query</font><font color="#CCCCCC"> I it was</font><font color="#E5E5E5"> the same system and I</font>

497
00:21:03,380 --> 00:21:06,670
<font color="#E5E5E5">would just repeated many times</font><font color="#CCCCCC"> I</font>

498
00:21:04,700 --> 00:21:09,830
<font color="#CCCCCC">repeated</font><font color="#E5E5E5"> explained many</font><font color="#CCCCCC"> times I repeated</font>

499
00:21:06,670 --> 00:21:13,190
<font color="#E5E5E5">just</font><font color="#CCCCCC"> select many times in different</font>

500
00:21:09,830 --> 00:21:14,929
<font color="#E5E5E5">order when I was collecting how many</font>

501
00:21:13,190 --> 00:21:17,120
<font color="#CCCCCC">different selects</font><font color="#E5E5E5"> I</font><font color="#CCCCCC"> have indifferent</font>

502
00:21:14,930 --> 00:21:18,380
<font color="#E5E5E5">explains output out I would see</font><font color="#CCCCCC"> in</font>

503
00:21:17,120 --> 00:21:21,620
question does<font color="#CCCCCC"> not</font><font color="#E5E5E5"> affect that explained</font>

504
00:21:18,380 --> 00:21:24,050
output and yeah execution time as well<font color="#CCCCCC"> I</font>

505
00:21:21,620 --> 00:21:25,939
think after the cache was warmed up so

506
00:21:24,050 --> 00:21:26,240
<font color="#E5E5E5">this shouldn't</font><font color="#CCCCCC"> be taking town after the</font>

507
00:21:25,940 --> 00:21:27,860
<font color="#CCCCCC">Risa</font>

508
00:21:26,240 --> 00:21:30,430
I was<font color="#CCCCCC"> already</font><font color="#E5E5E5"> collecting the</font><font color="#CCCCCC"> results</font>

509
00:21:27,860 --> 00:21:30,429
that were<font color="#CCCCCC"> stable</font>

510
00:21:44,180 --> 00:21:48,200
I'm sorry I didn't<font color="#E5E5E5"> you know</font>

511
00:21:53,710 --> 00:21:59,170
so the question is is that<font color="#E5E5E5"> if there any</font>

512
00:21:56,360 --> 00:22:01,760
plans to<font color="#E5E5E5"> collect</font><font color="#CCCCCC"> statistics on the fly</font>

513
00:21:59,170 --> 00:22:05,080
we are<font color="#E5E5E5"> thinking</font><font color="#CCCCCC"> about that</font><font color="#E5E5E5"> but</font><font color="#CCCCCC"> it will</font>

514
00:22:01,760 --> 00:22:05,080
<font color="#E5E5E5">not</font><font color="#CCCCCC"> be in Marina Beach</font><font color="#E5E5E5"> and form</font>

