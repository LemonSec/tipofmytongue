1
00:00:05,080 --> 00:00:10,190
<font color="#E5E5E5">okay so let's start</font><font color="#CCCCCC"> this presentation</font>

2
00:00:07,790 --> 00:00:13,040
<font color="#E5E5E5">and my name is</font><font color="#CCCCCC"> Thomas Bob wash and I'm</font>

3
00:00:10,190 --> 00:00:14,959
presenting to you<font color="#E5E5E5"> joint work which I did</font>

4
00:00:13,040 --> 00:00:17,000
first<font color="#CCCCCC"> with Maxine</font><font color="#E5E5E5"> will</font><font color="#CCCCCC"> ya</font>

5
00:00:14,960 --> 00:00:19,189
it's called<font color="#CCCCCC"> Kay</font><font color="#E5E5E5"> leak</font><font color="#CCCCCC"> it's a practical</font>

6
00:00:17,000 --> 00:00:22,070
kernel memory disclosure detection but

7
00:00:19,189 --> 00:00:23,390
<font color="#E5E5E5">before going into the details</font><font color="#CCCCCC"> and I may</font>

8
00:00:22,070 --> 00:00:26,090
warn you this is<font color="#CCCCCC"> a</font><font color="#E5E5E5"> little bit more</font>

9
00:00:23,390 --> 00:00:28,070
<font color="#CCCCCC">technical than the last talks</font><font color="#E5E5E5"> we have to</font>

10
00:00:26,090 --> 00:00:31,340
do a quick<font color="#CCCCCC"> recap on two or three things</font>

11
00:00:28,070 --> 00:00:34,370
<font color="#E5E5E5">so the</font><font color="#CCCCCC"> first thing is actually what is</font>

12
00:00:31,340 --> 00:00:36,140
the syscall and well you should<font color="#CCCCCC"> I</font>

13
00:00:34,370 --> 00:00:38,199
suppose everybody knows the<font color="#CCCCCC"> C's of space</font>

14
00:00:36,140 --> 00:00:41,269
kernel space and<font color="#E5E5E5"> user space we've got</font>

15
00:00:38,199 --> 00:00:43,190
potentially untrusted programs<font color="#E5E5E5"> and</font><font color="#CCCCCC"> that</font>

16
00:00:41,269 --> 00:00:44,659
kind<font color="#E5E5E5"> of isolated and then there's kernel</font>

17
00:00:43,190 --> 00:00:47,540
space<font color="#E5E5E5"> with the kernel is running and</font>

18
00:00:44,659 --> 00:00:49,970
this where the power lies<font color="#E5E5E5"> so the</font>

19
00:00:47,540 --> 00:00:52,309
<font color="#CCCCCC">program's are isolated and due to and to</font>

20
00:00:49,970 --> 00:00:55,220
do anything<font color="#E5E5E5"> meaningful they have to ask</font>

21
00:00:52,309 --> 00:00:57,619
<font color="#E5E5E5">the convolution so they use syscalls</font>

22
00:00:55,220 --> 00:01:00,739
like for<font color="#CCCCCC"> example is called</font><font color="#E5E5E5"> X which could</font>

23
00:00:57,619 --> 00:01:03,860
be<font color="#E5E5E5"> sent to packets or</font><font color="#CCCCCC"> write to file and</font>

24
00:01:00,739 --> 00:01:05,420
<font color="#CCCCCC">then you call it the kernel dance this</font>

25
00:01:03,860 --> 00:01:07,100
is called<font color="#CCCCCC"> dispatcher</font><font color="#E5E5E5"> which does the</font>

26
00:01:05,420 --> 00:01:10,310
additional preparation chooses the

27
00:01:07,100 --> 00:01:11,960
<font color="#CCCCCC">Weitz's call</font><font color="#E5E5E5"> to call and finally</font>

28
00:01:10,310 --> 00:01:13,790
returned to<font color="#E5E5E5"> the user program and the</font>

29
00:01:11,960 --> 00:01:16,130
interesting thing which<font color="#E5E5E5"> I'm talking</font>

30
00:01:13,790 --> 00:01:17,390
about<font color="#E5E5E5"> now or later will</font><font color="#CCCCCC"> be this boundary</font>

31
00:01:16,130 --> 00:01:19,399
<font color="#E5E5E5">between</font><font color="#CCCCCC"> user space and kernel space</font>

32
00:01:17,390 --> 00:01:22,400
there's a<font color="#E5E5E5"> transport program</font><font color="#CCCCCC"> should not</font>

33
00:01:19,400 --> 00:01:23,930
<font color="#CCCCCC">weed stuff from kernel which they're</font><font color="#E5E5E5"> not</font>

34
00:01:22,400 --> 00:01:27,380
<font color="#E5E5E5">allowed to eat and I shouldn't right</font>

35
00:01:23,930 --> 00:01:31,850
there so there's some there's<font color="#CCCCCC"> some data</font>

36
00:01:27,380 --> 00:01:34,640
exchange<font color="#E5E5E5"> usually going on so first some</font>

37
00:01:31,850 --> 00:01:37,490
data has<font color="#CCCCCC"> to</font><font color="#E5E5E5"> go into</font><font color="#CCCCCC"> the kernel this</font>

38
00:01:34,640 --> 00:01:40,150
means the user<font color="#CCCCCC"> program cannot</font><font color="#E5E5E5"> write</font>

39
00:01:37,490 --> 00:01:43,280
directly into the into the kernel space

40
00:01:40,150 --> 00:01:45,500
so what<font color="#E5E5E5"> it's</font><font color="#CCCCCC"> going to do is they provide</font>

41
00:01:43,280 --> 00:01:47,900
a user program provides<font color="#E5E5E5"> pointer to</font>

42
00:01:45,500 --> 00:01:50,570
buffer and then the kernel fetches this

43
00:01:47,900 --> 00:01:53,270
data and works actually<font color="#CCCCCC"> under</font><font color="#E5E5E5"> some on</font>

44
00:01:50,570 --> 00:01:56,029
this copy here in a slight you can see

45
00:01:53,270 --> 00:01:57,860
there's some buffer on a real space

46
00:01:56,030 --> 00:01:59,930
stack and it's get copied into<font color="#E5E5E5"> the</font>

47
00:01:57,860 --> 00:02:01,970
kernel stack and some work is<font color="#E5E5E5"> done and</font>

48
00:01:59,930 --> 00:02:03,670
again there's this trust boundary

49
00:02:01,970 --> 00:02:06,470
between a<font color="#E5E5E5"> user space and kernel space</font>

50
00:02:03,670 --> 00:02:08,658
and now the really<font color="#E5E5E5"> interesting thing</font>

51
00:02:06,470 --> 00:02:11,780
which<font color="#CCCCCC"> is this talk all about</font><font color="#E5E5E5"> it's about</font>

52
00:02:08,658 --> 00:02:14,109
copy out getting data out safely and

53
00:02:11,780 --> 00:02:16,700
securely<font color="#E5E5E5"> out of kernel space and</font>

54
00:02:14,110 --> 00:02:18,110
typically<font color="#E5E5E5"> there are also dedicated</font>

55
00:02:16,700 --> 00:02:21,799
<font color="#E5E5E5">functions like</font>

56
00:02:18,110 --> 00:02:24,760
copy out copy out string in order<font color="#CCCCCC"> to get</font>

57
00:02:21,800 --> 00:02:27,350
<font color="#E5E5E5">this data to</font><font color="#CCCCCC"> the user mode program and</font>

58
00:02:24,760 --> 00:02:29,870
the kernel<font color="#CCCCCC"> that does not</font><font color="#E5E5E5"> typically write</font>

59
00:02:27,350 --> 00:02:31,989
directly into user space<font color="#E5E5E5"> it uses these</font>

60
00:02:29,870 --> 00:02:36,410
<font color="#E5E5E5">API is also because stuff like</font>

61
00:02:31,990 --> 00:02:38,450
supervisor mode<font color="#E5E5E5"> access prevention so in</font>

62
00:02:36,410 --> 00:02:41,600
this kind of an exploit mitigation so

63
00:02:38,450 --> 00:02:43,670
and if you know what it's a<font color="#E5E5E5"> Cisco</font><font color="#CCCCCC"> land</font>

64
00:02:41,600 --> 00:02:45,109
you know about<font color="#CCCCCC"> this trust boundary then</font>

65
00:02:43,670 --> 00:02:46,489
you can follow this talk perfectly I

66
00:02:45,110 --> 00:02:48,800
suppose so

67
00:02:46,490 --> 00:02:51,620
it's about<font color="#CCCCCC"> kernel memory disclosures and</font>

68
00:02:48,800 --> 00:02:54,140
what are they well one could say they

69
00:02:51,620 --> 00:02:57,080
were inadvertently<font color="#E5E5E5"> writing data from</font>

70
00:02:54,140 --> 00:02:59,179
kernel to user space so data that

71
00:02:57,080 --> 00:03:02,000
actually<font color="#E5E5E5"> does not belong there but with</font>

72
00:02:59,180 --> 00:03:05,209
which was written there<font color="#E5E5E5"> by accident</font><font color="#CCCCCC"> and</font>

73
00:03:02,000 --> 00:03:07,160
there's a consequence<font color="#CCCCCC"> male first you may</font>

74
00:03:05,209 --> 00:03:09,500
<font color="#E5E5E5">leak random data but</font><font color="#CCCCCC"> for</font><font color="#E5E5E5"> an attacker</font>

75
00:03:07,160 --> 00:03:11,450
<font color="#CCCCCC">that's useless</font><font color="#E5E5E5"> but then the interesting</font>

76
00:03:09,500 --> 00:03:13,790
<font color="#E5E5E5">stuff can happen for</font><font color="#CCCCCC"> example you may</font>

77
00:03:11,450 --> 00:03:15,950
<font color="#CCCCCC">like leaker pointers or</font><font color="#E5E5E5"> pops of color</font>

78
00:03:13,790 --> 00:03:19,579
<font color="#CCCCCC">pointer and if you've</font><font color="#E5E5E5"> got like</font><font color="#CCCCCC"> kernel</font><font color="#E5E5E5"> a</font>

79
00:03:15,950 --> 00:03:23,299
<font color="#CCCCCC">salaah then this breaks basically your</font>

80
00:03:19,580 --> 00:03:25,100
you know exploit mitigation so and<font color="#E5E5E5"> also</font>

81
00:03:23,300 --> 00:03:26,900
it can happen that<font color="#CCCCCC"> you write more</font>

82
00:03:25,100 --> 00:03:29,660
sensitive stuff maybe<font color="#CCCCCC"> crypto material</font>

83
00:03:26,900 --> 00:03:31,880
and so on and so forth and<font color="#E5E5E5"> typically</font>

84
00:03:29,660 --> 00:03:34,640
those<font color="#E5E5E5"> parts do not</font><font color="#CCCCCC"> lead directly to an</font>

85
00:03:31,880 --> 00:03:37,430
exploitation<font color="#E5E5E5"> and</font><font color="#CCCCCC"> reproduce escalation</font>

86
00:03:34,640 --> 00:03:40,940
<font color="#E5E5E5">but there are</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> modern system that</font>

87
00:03:37,430 --> 00:03:42,950
they've got some curl<font color="#E5E5E5"> SLR they are</font><font color="#CCCCCC"> a</font>

88
00:03:40,940 --> 00:03:44,630
step towards this goal<font color="#CCCCCC"> so in order to do</font>

89
00:03:42,950 --> 00:03:46,790
some privilege escalation you know<font color="#CCCCCC"> have</font>

90
00:03:44,630 --> 00:03:49,040
to<font color="#CCCCCC"> know where the kernel</font><font color="#E5E5E5"> is in memory</font>

91
00:03:46,790 --> 00:03:52,790
<font color="#E5E5E5">and you need to get kernel pointers and</font>

92
00:03:49,040 --> 00:03:55,840
so on<font color="#E5E5E5"> and so forth so let's have a quick</font>

93
00:03:52,790 --> 00:03:58,910
<font color="#CCCCCC">look how such a kernel memory disclosure</font>

94
00:03:55,840 --> 00:04:01,820
<font color="#E5E5E5">looks in code I I hope everyone can</font><font color="#CCCCCC"> read</font>

95
00:03:58,910 --> 00:04:05,030
this<font color="#E5E5E5"> this is</font><font color="#CCCCCC"> a mem mem II</font><font color="#E5E5E5"> economy</font>

96
00:04:01,820 --> 00:04:08,750
<font color="#CCCCCC">disclosure that I found by auditing the</font>

97
00:04:05,030 --> 00:04:11,200
<font color="#E5E5E5">freebsd code and on the</font><font color="#CCCCCC"> left-hand side</font>

98
00:04:08,750 --> 00:04:13,910
<font color="#E5E5E5">we can see we can</font><font color="#CCCCCC"> see actually the code</font>

99
00:04:11,200 --> 00:04:16,310
of the<font color="#CCCCCC"> Cisco it's called</font><font color="#E5E5E5"> Cisco</font><font color="#CCCCCC"> I get</font>

100
00:04:13,910 --> 00:04:18,798
context which and provides the context

101
00:04:16,310 --> 00:04:21,890
<font color="#E5E5E5">to register States to user space program</font>

102
00:04:18,798 --> 00:04:23,539
and it's architecture dependent because

103
00:04:21,890 --> 00:04:25,310
<font color="#E5E5E5">on different architectures you've got</font>

104
00:04:23,540 --> 00:04:28,490
<font color="#E5E5E5">different registers and stuff like that</font>

105
00:04:25,310 --> 00:04:30,530
and then<font color="#CCCCCC"> right inside</font><font color="#E5E5E5"> that's just</font><font color="#CCCCCC"> the</font>

106
00:04:28,490 --> 00:04:31,960
kernel stack<font color="#E5E5E5"> we're going to call</font><font color="#CCCCCC"> into it</font>

107
00:04:30,530 --> 00:04:34,309
there's a<font color="#E5E5E5"> little</font>

108
00:04:31,960 --> 00:04:36,950
<font color="#E5E5E5">Poynter</font><font color="#CCCCCC"> and now</font><font color="#E5E5E5"> we at the beginning of</font>

109
00:04:34,310 --> 00:04:38,330
this<font color="#E5E5E5"> Cisco and what happens to pushing</font>

110
00:04:36,950 --> 00:04:40,280
<font color="#E5E5E5">the parameters are on the stack and</font>

111
00:04:38,330 --> 00:04:41,719
<font color="#CCCCCC">return</font><font color="#E5E5E5"> to us and still most of the stack</font>

112
00:04:40,280 --> 00:04:44,419
is initialized we don't know what's

113
00:04:41,720 --> 00:04:48,260
<font color="#CCCCCC">actually laying</font><font color="#E5E5E5"> there and</font><font color="#CCCCCC"> now there are</font>

114
00:04:44,420 --> 00:04:50,480
variables and<font color="#E5E5E5"> they're</font><font color="#CCCCCC"> only reserved at</font>

115
00:04:48,260 --> 00:04:54,500
this point in time<font color="#E5E5E5"> so the stack gets</font>

116
00:04:50,480 --> 00:04:56,810
opened for the you context and<font color="#E5E5E5"> also</font>

117
00:04:54,500 --> 00:04:59,240
<font color="#E5E5E5">somewhere logically there should be the</font>

118
00:04:56,810 --> 00:05:01,940
return<font color="#E5E5E5"> value and there's some sanity</font>

119
00:04:59,240 --> 00:05:04,340
checking on the<font color="#CCCCCC"> buffer</font><font color="#E5E5E5"> and then</font><font color="#CCCCCC"> you go</font>

120
00:05:01,940 --> 00:05:06,080
into<font color="#CCCCCC"> it's another function which</font><font color="#E5E5E5"> is</font>

121
00:05:04,340 --> 00:05:07,789
architecture<font color="#E5E5E5"> dependent in this case and</font>

122
00:05:06,080 --> 00:05:11,330
which is called<font color="#E5E5E5"> get em context which</font>

123
00:05:07,790 --> 00:05:14,270
fills this you<font color="#E5E5E5"> see struct with the</font>

124
00:05:11,330 --> 00:05:16,460
register<font color="#CCCCCC"> states</font><font color="#E5E5E5"> so how does this struct</font>

125
00:05:14,270 --> 00:05:18,590
actually look like<font color="#E5E5E5"> well it's a struct</font>

126
00:05:16,460 --> 00:05:20,479
which is nested with blocks I think on

127
00:05:18,590 --> 00:05:22,820
another layer layer it's also nice<font color="#CCCCCC"> too</font>

128
00:05:20,480 --> 00:05:25,250
<font color="#E5E5E5">so it's kind of complicated nobody</font>

129
00:05:22,820 --> 00:05:27,500
really knows how this will be laid out

130
00:05:25,250 --> 00:05:29,900
<font color="#E5E5E5">into the memory by the compiler because</font>

131
00:05:27,500 --> 00:05:32,170
of padding and stuff like that<font color="#E5E5E5"> so I</font>

132
00:05:29,900 --> 00:05:36,140
believe nobody here in the in the room

133
00:05:32,170 --> 00:05:39,200
<font color="#E5E5E5">will get it</font><font color="#CCCCCC"> right so so we</font><font color="#E5E5E5"> don't know</font>

134
00:05:36,140 --> 00:05:43,280
what happens<font color="#CCCCCC"> usually with this stuff</font><font color="#E5E5E5"> so</font>

135
00:05:39,200 --> 00:05:46,070
and as a consequence this function<font color="#E5E5E5"> M get</font>

136
00:05:43,280 --> 00:05:48,380
contact fills this this memory area

137
00:05:46,070 --> 00:05:51,349
where we<font color="#E5E5E5"> pester</font><font color="#CCCCCC"> the pointer</font><font color="#E5E5E5"> and then</font>

138
00:05:48,380 --> 00:05:54,170
<font color="#CCCCCC">there's some</font><font color="#E5E5E5"> hole there's some hole and</font>

139
00:05:51,350 --> 00:05:57,890
now we're copying<font color="#E5E5E5"> the whole the whole</font>

140
00:05:54,170 --> 00:06:01,340
struct to user space again<font color="#E5E5E5"> and this</font>

141
00:05:57,890 --> 00:06:04,280
<font color="#E5E5E5">whole by now is</font><font color="#CCCCCC"> released that memory</font><font color="#E5E5E5"> so</font>

142
00:06:01,340 --> 00:06:07,460
everything<font color="#CCCCCC"> that may there was before now</font>

143
00:06:04,280 --> 00:06:09,919
is the new space<font color="#E5E5E5"> and it in this case in</font>

144
00:06:07,460 --> 00:06:12,020
this<font color="#CCCCCC"> case that was some</font><font color="#E5E5E5"> two</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> a half</font>

145
00:06:09,920 --> 00:06:16,070
<font color="#CCCCCC">kernel pointers</font><font color="#E5E5E5"> that were passed like</font><font color="#CCCCCC"> 20</font>

146
00:06:12,020 --> 00:06:18,740
bytes<font color="#E5E5E5"> every time and that's the thing</font>

147
00:06:16,070 --> 00:06:21,890
with<font color="#E5E5E5"> their like you won't see that</font><font color="#CCCCCC"> the</font>

148
00:06:18,740 --> 00:06:24,170
first look maybe but then<font color="#E5E5E5"> if there was</font>

149
00:06:21,890 --> 00:06:28,250
<font color="#E5E5E5">in FreeBSD kernel</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> a lot it would have</font>

150
00:06:24,170 --> 00:06:32,570
been<font color="#E5E5E5"> poking so the fix here is quite</font>

151
00:06:28,250 --> 00:06:35,240
easy well you just you<font color="#E5E5E5"> zero out zero out</font>

152
00:06:32,570 --> 00:06:37,490
everything before<font color="#E5E5E5"> you</font><font color="#CCCCCC"> watch</font><font color="#E5E5E5"> it so why</font>

153
00:06:35,240 --> 00:06:39,500
are they hard to<font color="#E5E5E5"> detect those memories</font>

154
00:06:37,490 --> 00:06:40,880
<font color="#CCCCCC">closes well there</font><font color="#E5E5E5"> are silent parts so</font>

155
00:06:39,500 --> 00:06:43,100
they do not hear<font color="#E5E5E5"> questions without a</font>

156
00:06:40,880 --> 00:06:43,490
question<font color="#CCCCCC"> already usually we'll look into</font>

157
00:06:43,100 --> 00:06:44,599
it

158
00:06:43,490 --> 00:06:46,879
so maybe

159
00:06:44,599 --> 00:06:48,770
<font color="#CCCCCC">it's</font><font color="#E5E5E5"> also these are also hidden behind</font>

160
00:06:46,879 --> 00:06:51,800
your<font color="#CCCCCC"> syllabi we because</font><font color="#E5E5E5"> you usually</font>

161
00:06:48,770 --> 00:06:53,719
don't talk directly<font color="#CCCCCC"> with your</font><font color="#E5E5E5"> mr. Conroy</font>

162
00:06:51,800 --> 00:06:56,119
sister<font color="#CCCCCC"> Colin</font><font color="#E5E5E5"> you use a</font><font color="#CCCCCC"> LAN</font><font color="#E5E5E5"> program and</font>

163
00:06:53,719 --> 00:06:58,159
maybe you won't get the leech bites

164
00:06:56,119 --> 00:07:00,860
<font color="#E5E5E5">through your C library and nobody will</font>

165
00:06:58,159 --> 00:07:02,808
notice<font color="#E5E5E5"> the root of all evil here in the</font>

166
00:07:00,860 --> 00:07:05,529
end<font color="#E5E5E5"> of the C programming</font><font color="#CCCCCC"> language and</font>

167
00:07:02,809 --> 00:07:09,559
there's no let's say<font color="#E5E5E5"> a safe way to</font>

168
00:07:05,529 --> 00:07:11,719
transfer data<font color="#E5E5E5"> from</font><font color="#CCCCCC"> chrono to across</font>

169
00:07:09,559 --> 00:07:14,270
<font color="#CCCCCC">trust boundaries</font><font color="#E5E5E5"> also</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> current state</font>

170
00:07:11,719 --> 00:07:15,558
of compilers doesn't help<font color="#CCCCCC"> I mean</font><font color="#E5E5E5"> they</font>

171
00:07:14,270 --> 00:07:18,318
tell you if there's<font color="#E5E5E5"> an Amish</font><font color="#CCCCCC"> lock</font>

172
00:07:15,559 --> 00:07:20,569
variable<font color="#CCCCCC"> but then they fail if this is</font>

173
00:07:18,319 --> 00:07:24,139
nested<font color="#CCCCCC"> strikes</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> strikes and stuff like</font>

174
00:07:20,569 --> 00:07:26,830
that and they<font color="#CCCCCC"> don't give you a hint that</font>

175
00:07:24,139 --> 00:07:29,509
there may be<font color="#E5E5E5"> a</font><font color="#CCCCCC"> kind of</font><font color="#E5E5E5"> memory disclosure</font>

176
00:07:26,830 --> 00:07:32,330
<font color="#E5E5E5">system memory</font><font color="#CCCCCC"> or allocators</font><font color="#E5E5E5"> they've got</font>

177
00:07:29,509 --> 00:07:34,909
also<font color="#CCCCCC"> there also</font><font color="#E5E5E5"> a reason because usually</font>

178
00:07:32,330 --> 00:07:37,279
the<font color="#E5E5E5"> kernel stack is not zero out it's</font>

179
00:07:34,909 --> 00:07:39,619
initialized the heap returns in many

180
00:07:37,279 --> 00:07:42,979
cases initialized memory that could be

181
00:07:39,619 --> 00:07:45,349
leaked to to the<font color="#CCCCCC"> userland furthermore</font>

182
00:07:42,979 --> 00:07:47,539
architectures<font color="#E5E5E5"> are also a thing here</font>

183
00:07:45,349 --> 00:07:49,909
<font color="#E5E5E5">because on some architecture actually</font>

184
00:07:47,539 --> 00:07:52,669
<font color="#CCCCCC">the code will leak on the others not</font>

185
00:07:49,909 --> 00:07:55,039
this<font color="#E5E5E5"> is because coila's and compilers</font>

186
00:07:52,669 --> 00:07:57,198
may<font color="#E5E5E5"> add padding and so on and so forth</font>

187
00:07:55,039 --> 00:08:00,829
<font color="#E5E5E5">in the struts and you won't notice</font><font color="#CCCCCC"> if</font>

188
00:07:57,199 --> 00:08:04,809
you develop something<font color="#E5E5E5"> on x86 and it may</font>

189
00:08:00,829 --> 00:08:07,969
leak on<font color="#CCCCCC"> AMD</font><font color="#E5E5E5"> 64 so and maybe some</font>

190
00:08:04,809 --> 00:08:11,409
developers are<font color="#CCCCCC"> not that aware of this</font>

191
00:08:07,969 --> 00:08:13,849
issue<font color="#E5E5E5"> are not taking seriously but yeah</font>

192
00:08:11,409 --> 00:08:18,079
<font color="#E5E5E5">typical error sources</font><font color="#CCCCCC"> there's</font><font color="#E5E5E5"> a paper by</font>

193
00:08:13,849 --> 00:08:21,589
your project<font color="#CCCCCC"> Google project zero and</font>

194
00:08:18,079 --> 00:08:23,930
it's like 20 pages<font color="#E5E5E5"> just about typical</font>

195
00:08:21,589 --> 00:08:27,409
problems of kernel memory disclosures

196
00:08:23,930 --> 00:08:30,789
<font color="#E5E5E5">and</font><font color="#CCCCCC"> is paper and came out like</font><font color="#E5E5E5"> half year</font>

197
00:08:27,409 --> 00:08:32,929
<font color="#CCCCCC">ago</font><font color="#E5E5E5"> and summer 2018 so everybody who's</font>

198
00:08:30,789 --> 00:08:35,240
working<font color="#CCCCCC"> with</font><font color="#E5E5E5"> low-level stuff I can</font>

199
00:08:32,929 --> 00:08:37,370
<font color="#E5E5E5">definitely recommend and we it and</font><font color="#CCCCCC"> then</font>

200
00:08:35,240 --> 00:08:41,329
<font color="#E5E5E5">afterwards you</font><font color="#CCCCCC"> will know a lot about</font>

201
00:08:37,370 --> 00:08:42,740
this kind<font color="#CCCCCC"> of back class</font><font color="#E5E5E5"> but in general</font>

202
00:08:41,328 --> 00:08:44,810
the boils down to stuff in the<font color="#E5E5E5"> C</font>

203
00:08:42,740 --> 00:08:47,899
language<font color="#E5E5E5"> again so in initial</font><font color="#CCCCCC"> add</font>

204
00:08:44,810 --> 00:08:49,699
<font color="#E5E5E5">variables well the compiler will warn</font>

205
00:08:47,899 --> 00:08:52,450
you at<font color="#E5E5E5"> least here but then you've</font><font color="#CCCCCC"> got</font>

206
00:08:49,699 --> 00:08:55,689
struck<font color="#E5E5E5"> alignment stuff so</font>

207
00:08:52,450 --> 00:08:57,640
and stuff gets aligned so that<font color="#CCCCCC"> you can</font>

208
00:08:55,690 --> 00:08:59,800
fetch it<font color="#E5E5E5"> in one CPU cycle by the</font>

209
00:08:57,640 --> 00:09:02,800
<font color="#E5E5E5">compiler</font><font color="#CCCCCC"> and there may be paying</font><font color="#E5E5E5"> bytes</font>

210
00:08:59,800 --> 00:09:05,500
at the<font color="#E5E5E5"> ends and structures unions are</font>

211
00:09:02,800 --> 00:09:07,060
kind of evil as far as I know because<font color="#E5E5E5"> if</font>

212
00:09:05,500 --> 00:09:09,880
there are<font color="#E5E5E5"> two members</font><font color="#CCCCCC"> the smaller one</font>

213
00:09:07,060 --> 00:09:11,859
<font color="#CCCCCC">and the bigger one then the</font><font color="#E5E5E5"> Union will</font>

214
00:09:09,880 --> 00:09:13,420
be the size of the bigger one and<font color="#E5E5E5"> if you</font>

215
00:09:11,860 --> 00:09:15,840
could be out the smaller one<font color="#E5E5E5"> to userland</font>

216
00:09:13,420 --> 00:09:19,479
<font color="#CCCCCC">there will be a padding at the end</font><font color="#E5E5E5"> and</font>

217
00:09:15,840 --> 00:09:20,290
<font color="#E5E5E5">again this the allocator</font><font color="#CCCCCC"> and stack won't</font>

218
00:09:19,480 --> 00:09:23,770
help here

219
00:09:20,290 --> 00:09:27,069
<font color="#E5E5E5">so how to avoid it basically first if</font>

220
00:09:23,770 --> 00:09:29,260
you if you do a stuff general<font color="#E5E5E5"> passing</font>

221
00:09:27,070 --> 00:09:30,130
data across<font color="#CCCCCC"> trust boundary it doesn't</font>

222
00:09:29,260 --> 00:09:32,230
have to be<font color="#E5E5E5"> userland</font>

223
00:09:30,130 --> 00:09:35,260
<font color="#CCCCCC">kernel</font><font color="#E5E5E5"> and can be also network for</font>

224
00:09:32,230 --> 00:09:37,060
example<font color="#CCCCCC"> so local</font><font color="#E5E5E5"> values on the stack I</font>

225
00:09:35,260 --> 00:09:39,160
usually uninitialized we don't know

226
00:09:37,060 --> 00:09:41,290
what's<font color="#E5E5E5"> there and your heap</font>

227
00:09:39,160 --> 00:09:43,420
implementation if you don't pass<font color="#CCCCCC"> flex</font>

228
00:09:41,290 --> 00:09:46,240
for example it will<font color="#E5E5E5"> be uninitialized at</font>

229
00:09:43,420 --> 00:09:47,589
well so initialize it<font color="#E5E5E5"> don't trust a</font>

230
00:09:46,240 --> 00:09:49,420
compiler at the moment<font color="#E5E5E5"> I guess</font><font color="#CCCCCC"> in a</font>

231
00:09:47,590 --> 00:09:51,730
couple<font color="#CCCCCC"> of years</font><font color="#E5E5E5"> there will be some</font>

232
00:09:49,420 --> 00:09:54,910
advancement<font color="#E5E5E5"> and they will they will help</font>

233
00:09:51,730 --> 00:09:57,790
you<font color="#E5E5E5"> more on this and don't assume any</font>

234
00:09:54,910 --> 00:10:01,780
certain architecture padding when laying

235
00:09:57,790 --> 00:10:05,920
out stuff mentally in in<font color="#E5E5E5"> in memory so</font>

236
00:10:01,780 --> 00:10:08,110
this will break your<font color="#E5E5E5"> your neck and yeah</font>

237
00:10:05,920 --> 00:10:11,650
initialize your<font color="#E5E5E5"> data as soon as possible</font>

238
00:10:08,110 --> 00:10:14,200
in the<font color="#E5E5E5"> case example that I</font><font color="#CCCCCC"> showed you</font><font color="#E5E5E5"> if</font>

239
00:10:11,650 --> 00:10:17,530
you trust<font color="#E5E5E5"> and it will happen later most</font>

240
00:10:14,200 --> 00:10:19,030
<font color="#E5E5E5">likely won't happen so do it yourself</font><font color="#CCCCCC"> as</font>

241
00:10:17,530 --> 00:10:24,610
soon<font color="#E5E5E5"> as it possible and you won't forget</font>

242
00:10:19,030 --> 00:10:27,910
<font color="#CCCCCC">it again again if you if you if you</font>

243
00:10:24,610 --> 00:10:30,220
writing your own source code then well

244
00:10:27,910 --> 00:10:31,089
dump the<font color="#CCCCCC"> stuff you're exchanging in</font>

245
00:10:30,220 --> 00:10:33,730
<font color="#CCCCCC">userland</font>

246
00:10:31,090 --> 00:10:37,540
and look for some bytes<font color="#E5E5E5"> that would be</font>

247
00:10:33,730 --> 00:10:39,490
<font color="#CCCCCC">away to</font><font color="#E5E5E5"> another way to practice</font><font color="#CCCCCC"> Levite</font>

248
00:10:37,540 --> 00:10:41,800
and finally when in doubt<font color="#E5E5E5"> zero because</font>

249
00:10:39,490 --> 00:10:43,510
security efficiency<font color="#CCCCCC"> and when you go the</font>

250
00:10:41,800 --> 00:10:46,479
long way to implement kernel<font color="#CCCCCC"> is</font><font color="#E5E5E5"> Allah</font>

251
00:10:43,510 --> 00:10:50,020
then<font color="#E5E5E5"> well one</font><font color="#CCCCCC"> big bite may</font><font color="#E5E5E5"> be enough to</font>

252
00:10:46,480 --> 00:10:52,180
<font color="#E5E5E5">break it so this couple of a couple of</font>

253
00:10:50,020 --> 00:10:55,540
<font color="#CCCCCC">cycles for seeing our data structures</font>

254
00:10:52,180 --> 00:10:58,750
may help you a lot there<font color="#CCCCCC"> so what you</font>

255
00:10:55,540 --> 00:11:01,300
expect actually<font color="#E5E5E5"> if you if you look at</font>

256
00:10:58,750 --> 00:11:03,340
the history of kernel memory<font color="#E5E5E5"> discourses</font>

257
00:11:01,300 --> 00:11:05,319
and other operating systems<font color="#CCCCCC"> that's not</font>

258
00:11:03,340 --> 00:11:09,010
<font color="#E5E5E5">an</font><font color="#CCCCCC"> beastie problem that's</font>

259
00:11:05,320 --> 00:11:11,970
everybody's facing at the moment<font color="#E5E5E5"> like in</font>

260
00:11:09,010 --> 00:11:14,890
a publication of<font color="#CCCCCC"> Lou</font><font color="#E5E5E5"> and 2011 I think</font>

261
00:11:11,970 --> 00:11:16,750
<font color="#E5E5E5">they they stated</font><font color="#CCCCCC"> their</font><font color="#E5E5E5"> well upon 40</font>

262
00:11:14,890 --> 00:11:20,620
kernel memory disclosures<font color="#CCCCCC"> detected</font>

263
00:11:16,750 --> 00:11:23,530
mostly by many your<font color="#E5E5E5"> code</font><font color="#CCCCCC"> audits in the</font>

264
00:11:20,620 --> 00:11:26,410
Linux<font color="#E5E5E5"> kernel and they automated stuff</font>

265
00:11:23,530 --> 00:11:28,930
and found<font color="#E5E5E5"> like 20 more</font><font color="#CCCCCC"> in Android and</font>

266
00:11:26,410 --> 00:11:31,959
<font color="#E5E5E5">Linux</font><font color="#CCCCCC"> then there was this</font><font color="#E5E5E5"> paper of you</font>

267
00:11:28,930 --> 00:11:34,479
or last year who found alone<font color="#CCCCCC"> 70 alone in</font>

268
00:11:31,960 --> 00:11:37,750
<font color="#E5E5E5">Windows so everybody's fighting with</font>

269
00:11:34,480 --> 00:11:39,160
this thing and the list goes<font color="#E5E5E5"> on there</font>

270
00:11:37,750 --> 00:11:42,490
are many individual researchers<font color="#E5E5E5"> that</font>

271
00:11:39,160 --> 00:11:45,579
found anomalies<font color="#CCCCCC"> closed off by having a</font>

272
00:11:42,490 --> 00:11:48,250
<font color="#CCCCCC">look at</font><font color="#E5E5E5"> the code so far there hasn't</font>

273
00:11:45,580 --> 00:11:50,770
been any in a systematic<font color="#CCCCCC"> investigation</font>

274
00:11:48,250 --> 00:11:53,560
and the Beasties as far as<font color="#E5E5E5"> I know maybe</font>

275
00:11:50,770 --> 00:11:56,500
you can say an exception<font color="#E5E5E5"> would</font><font color="#CCCCCC"> be open</font>

276
00:11:53,560 --> 00:11:58,599
BSD many code reviews but<font color="#E5E5E5"> then again</font>

277
00:11:56,500 --> 00:12:00,400
<font color="#CCCCCC">correct me</font><font color="#E5E5E5"> if I'm wrong but I</font><font color="#CCCCCC"> think two</font>

278
00:11:58,600 --> 00:12:02,650
weeks<font color="#E5E5E5"> ago I wasn't out</font><font color="#CCCCCC"> an alert on</font>

279
00:12:00,400 --> 00:12:04,209
<font color="#E5E5E5">noticing</font><font color="#CCCCCC"> or OpenBSD about the pledge</font>

280
00:12:02,650 --> 00:12:06,900
<font color="#CCCCCC">syscall and there was a kernel memory</font>

281
00:12:04,210 --> 00:12:09,040
disclosure<font color="#E5E5E5"> so if this is true then</font>

282
00:12:06,900 --> 00:12:11,199
everybody's fighting with this<font color="#E5E5E5"> so the</font>

283
00:12:09,040 --> 00:12:13,060
assumption is<font color="#E5E5E5"> that there must be many</font>

284
00:12:11,200 --> 00:12:16,030
kernel memory disclosures<font color="#CCCCCC"> in the BSD and</font>

285
00:12:13,060 --> 00:12:19,359
<font color="#E5E5E5">while I was reviewing</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> cause of free</font>

286
00:12:16,030 --> 00:12:21,730
whistie<font color="#E5E5E5"> netbsd openbsd</font><font color="#CCCCCC"> I proved to try</font>

287
00:12:19,360 --> 00:12:23,710
farming some low-hanging<font color="#CCCCCC"> foods and then</font>

288
00:12:21,730 --> 00:12:26,200
I thought well we<font color="#CCCCCC"> could actually patch</font>

289
00:12:23,710 --> 00:12:29,380
the kernel and use some form of time

290
00:12:26,200 --> 00:12:31,630
tracking and do this automatically<font color="#CCCCCC"> and</font>

291
00:12:29,380 --> 00:12:34,360
<font color="#E5E5E5">this is basically where</font><font color="#CCCCCC"> I teamed up with</font>

292
00:12:31,630 --> 00:12:38,530
machine and we came up<font color="#CCCCCC"> with this idea</font>

293
00:12:34,360 --> 00:12:41,230
that's called<font color="#E5E5E5"> k-league</font><font color="#CCCCCC"> so k-league is an</font>

294
00:12:38,530 --> 00:12:43,750
automatic approach to<font color="#CCCCCC"> detectors and</font>

295
00:12:41,230 --> 00:12:47,470
<font color="#E5E5E5">kernel memory disclosures and it uses a</font>

296
00:12:43,750 --> 00:12:50,320
rudimentary form<font color="#E5E5E5"> of chain tracking so we</font>

297
00:12:47,470 --> 00:12:53,590
<font color="#E5E5E5">change our memory sources like the</font>

298
00:12:50,320 --> 00:12:56,200
<font color="#E5E5E5">kernel and the stack then we let the</font>

299
00:12:53,590 --> 00:12:59,590
bytes the tainted bytes<font color="#E5E5E5"> travel through</font>

300
00:12:56,200 --> 00:13:02,230
the kernel space and<font color="#E5E5E5"> at some data sinks</font>

301
00:12:59,590 --> 00:13:04,660
in our case<font color="#CCCCCC"> copy out copy out string we</font>

302
00:13:02,230 --> 00:13:06,910
look at the buffers and search for

303
00:13:04,660 --> 00:13:10,060
certain<font color="#E5E5E5"> marker bytes if they are there</font>

304
00:13:06,910 --> 00:13:13,150
and if they are there then<font color="#E5E5E5"> we detected</font>

305
00:13:10,060 --> 00:13:15,040
such a leak<font color="#E5E5E5"> so let's have a quick</font><font color="#CCCCCC"> look</font>

306
00:13:13,150 --> 00:13:16,930
how this actually works<font color="#CCCCCC"> so we've got our</font>

307
00:13:15,040 --> 00:13:19,030
<font color="#CCCCCC">program we've got our potentially</font>

308
00:13:16,930 --> 00:13:21,370
initialized<font color="#E5E5E5"> stack here</font>

309
00:13:19,030 --> 00:13:27,160
and we've got our<font color="#E5E5E5"> pet</font><font color="#CCCCCC"> cheap that already</font>

310
00:13:21,370 --> 00:13:30,970
returns tainted<font color="#E5E5E5"> change its pages and if</font>

311
00:13:27,160 --> 00:13:33,550
you use<font color="#CCCCCC"> a sis</font><font color="#E5E5E5"> call and call into into</font>

312
00:13:30,970 --> 00:13:36,340
the<font color="#E5E5E5"> kernel</font><font color="#CCCCCC"> at</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> syscall</font><font color="#E5E5E5"> dispatcher</font><font color="#CCCCCC"> we</font>

313
00:13:33,550 --> 00:13:38,920
take the whole stack<font color="#E5E5E5"> by calling a</font>

314
00:13:36,340 --> 00:13:42,130
function of our own<font color="#CCCCCC"> that as</font><font color="#E5E5E5"> that</font>

315
00:13:38,920 --> 00:13:45,010
allocates a huge huge<font color="#CCCCCC"> area and memset</font>

316
00:13:42,130 --> 00:13:48,490
sit with our<font color="#E5E5E5"> maka byte and then we call</font>

317
00:13:45,010 --> 00:13:53,080
it<font color="#CCCCCC"> the system call and the Sue's call</font>

318
00:13:48,490 --> 00:13:55,660
will actually do memory allocations and

319
00:13:53,080 --> 00:14:00,840
<font color="#E5E5E5">it will get stuff from the heap it will</font>

320
00:13:55,660 --> 00:14:04,900
get pay it will lie to the stack and

321
00:14:00,840 --> 00:14:08,830
then at some<font color="#CCCCCC"> point</font><font color="#E5E5E5"> there must be some</font>

322
00:14:04,900 --> 00:14:11,110
exchange<font color="#E5E5E5"> so data gets copied out to to</font>

323
00:14:08,830 --> 00:14:12,820
<font color="#E5E5E5">the user space so that would happen</font><font color="#CCCCCC"> here</font>

324
00:14:11,110 --> 00:14:16,900
copy out to<font color="#E5E5E5"> user space and this is all</font>

325
00:14:12,820 --> 00:14:20,860
<font color="#E5E5E5">basically our data sink where we have a</font>

326
00:14:16,900 --> 00:14:22,810
<font color="#CCCCCC">wraparound</font><font color="#E5E5E5"> copy out and we look at each</font>

327
00:14:20,860 --> 00:14:24,670
buffer<font color="#E5E5E5"> and check well let's tell</font><font color="#CCCCCC"> mark</font>

328
00:14:22,810 --> 00:14:27,189
<font color="#CCCCCC">abides it's like if there are four of</font>

329
00:14:24,670 --> 00:14:29,469
<font color="#E5E5E5">them in the wall then we</font><font color="#CCCCCC"> know</font><font color="#E5E5E5"> cool</font>

330
00:14:27,190 --> 00:14:31,810
there's a memory kind of memory

331
00:14:29,470 --> 00:14:35,530
disclosure<font color="#CCCCCC"> you may you may think well</font>

332
00:14:31,810 --> 00:14:39,609
one maka byte that's that's not<font color="#E5E5E5"> a good</font>

333
00:14:35,530 --> 00:14:44,230
idea because however uncommon a bite

334
00:14:39,610 --> 00:14:46,540
maybe you will see the<font color="#E5E5E5"> bytes</font><font color="#CCCCCC"> all all the</font>

335
00:14:44,230 --> 00:14:50,530
<font color="#E5E5E5">time</font><font color="#CCCCCC"> so if you think about system</font><font color="#E5E5E5"> costs</font>

336
00:14:46,540 --> 00:14:54,339
like at random all 255 values will<font color="#CCCCCC"> be</font>

337
00:14:50,530 --> 00:14:57,699
seen there so<font color="#CCCCCC"> therefore we we had this</font>

338
00:14:54,340 --> 00:14:59,530
<font color="#CCCCCC">idea</font><font color="#E5E5E5"> of a of a hit map and where we</font>

339
00:14:57,700 --> 00:15:00,370
introduced basically we introduced

340
00:14:59,530 --> 00:15:02,770
<font color="#CCCCCC">unwound</font>

341
00:15:00,370 --> 00:15:04,840
so we<font color="#CCCCCC"> we would take the maka bytes in</font>

342
00:15:02,770 --> 00:15:07,090
the<font color="#E5E5E5"> first world we've got</font><font color="#CCCCCC"> Mike</font><font color="#E5E5E5"> maka byte</font>

343
00:15:04,840 --> 00:15:09,370
<font color="#CCCCCC">one in the second clause we've got</font><font color="#E5E5E5"> make</font>

344
00:15:07,090 --> 00:15:12,940
a bit too<font color="#CCCCCC"> and every time we encounter</font>

345
00:15:09,370 --> 00:15:15,310
<font color="#E5E5E5">the smoker bytes in copy out we know</font>

346
00:15:12,940 --> 00:15:19,090
taters<font color="#CCCCCC"> we write this down into</font><font color="#E5E5E5"> our hip</font>

347
00:15:15,310 --> 00:15:21,699
map and for<font color="#E5E5E5"> example if we say we want to</font>

348
00:15:19,090 --> 00:15:25,390
<font color="#E5E5E5">check for</font><font color="#CCCCCC"> eight rounds for the league</font>

349
00:15:21,700 --> 00:15:28,150
then we we encode it in the hip map

350
00:15:25,390 --> 00:15:30,610
<font color="#E5E5E5">advance and this decreases the</font>

351
00:15:28,150 --> 00:15:32,329
possibility of<font color="#E5E5E5"> false positives to</font>

352
00:15:30,610 --> 00:15:35,329
<font color="#E5E5E5">remember</font><font color="#CCCCCC"> Slee because</font>

353
00:15:32,329 --> 00:15:37,579
it's very<font color="#E5E5E5"> unprofitable that our marker</font>

354
00:15:35,329 --> 00:15:40,429
bytes will be there at<font color="#E5E5E5"> the same offset</font>

355
00:15:37,579 --> 00:15:42,618
<font color="#CCCCCC">all the time in a random function so</font>

356
00:15:40,429 --> 00:15:45,309
<font color="#E5E5E5">that might still might be</font><font color="#CCCCCC"> fourth</font>

357
00:15:42,619 --> 00:15:49,249
positive but it should decrease it

358
00:15:45,309 --> 00:15:51,649
tremendously<font color="#E5E5E5"> so let's go into and then</font>

359
00:15:49,249 --> 00:15:54,709
again you return to user space<font color="#E5E5E5"> let's go</font>

360
00:15:51,649 --> 00:15:58,129
into the details so we we've<font color="#CCCCCC"> got our</font>

361
00:15:54,709 --> 00:16:00,410
data sources that's<font color="#E5E5E5"> and one source is</font>

362
00:15:58,129 --> 00:16:03,799
<font color="#CCCCCC">the heap and well we instrument</font>

363
00:16:00,410 --> 00:16:06,819
basically<font color="#E5E5E5"> the dynamic dynamic memory</font>

364
00:16:03,799 --> 00:16:10,639
allocator to return<font color="#E5E5E5"> our mark chunks</font><font color="#CCCCCC"> so</font>

365
00:16:06,819 --> 00:16:13,099
<font color="#CCCCCC">we mem set the</font><font color="#E5E5E5"> the chunks before</font><font color="#CCCCCC"> we</font>

366
00:16:10,639 --> 00:16:17,929
return them if you call malloc<font color="#E5E5E5"> for</font>

367
00:16:13,100 --> 00:16:19,999
example we return you<font color="#E5E5E5"> your pay</font><font color="#CCCCCC"> either</font>

368
00:16:17,929 --> 00:16:22,249
<font color="#E5E5E5">than the memory you requested but memset</font>

369
00:16:19,999 --> 00:16:26,360
with our naka byte and not like

370
00:16:22,249 --> 00:16:29,239
<font color="#CCCCCC">initialize so the exception is well</font><font color="#E5E5E5"> zero</font>

371
00:16:26,360 --> 00:16:31,459
chunks if you request huge<font color="#CCCCCC"> Co</font><font color="#E5E5E5"> chunks we</font>

372
00:16:29,239 --> 00:16:35,660
have to return<font color="#CCCCCC"> Sivir chunks because</font><font color="#E5E5E5"> if</font>

373
00:16:31,459 --> 00:16:40,669
we don't you get kernel panics then

374
00:16:35,660 --> 00:16:42,829
another another<font color="#E5E5E5"> source is</font><font color="#CCCCCC"> the stack</font><font color="#E5E5E5"> so</font>

375
00:16:40,669 --> 00:16:46,669
right<font color="#E5E5E5"> before entering the skull</font><font color="#CCCCCC"> actually</font>

376
00:16:42,829 --> 00:16:49,689
<font color="#CCCCCC">at the syscall dispatching we call our</font>

377
00:16:46,669 --> 00:16:52,639
<font color="#E5E5E5">old function that taints the whole stack</font>

378
00:16:49,689 --> 00:16:55,040
<font color="#E5E5E5">but then we've got a problem during</font>

379
00:16:52,639 --> 00:16:56,660
<font color="#CCCCCC">execution of the</font><font color="#E5E5E5"> cisco you you enter</font>

380
00:16:55,040 --> 00:16:59,509
into<font color="#CCCCCC"> another function and another</font>

381
00:16:56,660 --> 00:17:02,179
function<font color="#E5E5E5"> and those will open up a local</font>

382
00:16:59,509 --> 00:17:06,049
stack<font color="#E5E5E5"> will close it there will be some</font>

383
00:17:02,179 --> 00:17:08,839
data and maybe the leak will be a little

384
00:17:06,049 --> 00:17:11,539
<font color="#CCCCCC">bit</font><font color="#E5E5E5"> deeper in the in the in</font><font color="#CCCCCC"> the cisco</font><font color="#E5E5E5"> so</font>

385
00:17:08,839 --> 00:17:14,329
what we do is we continuously<font color="#CCCCCC"> we change</font>

386
00:17:11,539 --> 00:17:17,949
the stack so<font color="#CCCCCC"> we use some compiler</font>

387
00:17:14,329 --> 00:17:20,809
instrumentation<font color="#E5E5E5"> and every now and then</font>

388
00:17:17,949 --> 00:17:25,269
<font color="#CCCCCC">we retained a smaller part I think at</font>

389
00:17:20,809 --> 00:17:29,240
the<font color="#E5E5E5"> moment is 512 bytes</font><font color="#CCCCCC"> we change it</font><font color="#E5E5E5"> and</font>

390
00:17:25,269 --> 00:17:32,210
this increases<font color="#E5E5E5"> our probability to</font>

391
00:17:29,240 --> 00:17:35,840
encounter<font color="#E5E5E5"> those tainted bytes later in</font>

392
00:17:32,210 --> 00:17:37,940
the copy out and then detecting those

393
00:17:35,840 --> 00:17:40,070
leaks<font color="#CCCCCC"> it's like</font><font color="#E5E5E5"> a very rudimentary</font>

394
00:17:37,940 --> 00:17:42,020
change<font color="#E5E5E5"> tracking so we don't track it</font>

395
00:17:40,070 --> 00:17:43,789
<font color="#E5E5E5">track each and every bite through the</font>

396
00:17:42,020 --> 00:17:46,260
call<font color="#E5E5E5"> we let them travel and at the</font>

397
00:17:43,789 --> 00:17:48,510
source which define<font color="#E5E5E5"> the</font><font color="#CCCCCC"> scope</font>

398
00:17:46,260 --> 00:17:51,780
and copy<font color="#E5E5E5"> out strings and I just</font><font color="#CCCCCC"> thinks</font>

399
00:17:48,510 --> 00:17:55,440
excuse me<font color="#CCCCCC"> we we check on each invocation</font>

400
00:17:51,780 --> 00:17:58,200
<font color="#CCCCCC">if we see those microwaves naima may ask</font>

401
00:17:55,440 --> 00:18:02,520
<font color="#E5E5E5">what a good values for</font><font color="#CCCCCC"> microwave</font><font color="#E5E5E5"> for</font>

402
00:17:58,200 --> 00:18:05,490
<font color="#E5E5E5">Machiavelli's so if I would mark my my</font>

403
00:18:02,520 --> 00:18:09,299
tainted chunks<font color="#E5E5E5"> heap chunks for example I</font>

404
00:18:05,490 --> 00:18:12,510
was<font color="#CCCCCC"> 0 or 255</font><font color="#E5E5E5"> this is not a good</font><font color="#CCCCCC"> choice</font>

405
00:18:09,299 --> 00:18:15,418
<font color="#E5E5E5">because those values are probably are</font>

406
00:18:12,510 --> 00:18:18,540
<font color="#CCCCCC">more likely to occur and we had this</font>

407
00:18:15,419 --> 00:18:22,290
idea<font color="#CCCCCC"> well we at least try to estimate by</font>

408
00:18:18,540 --> 00:18:24,870
frequency<font color="#E5E5E5"> first and see which what</font>

409
00:18:22,290 --> 00:18:28,230
happens<font color="#CCCCCC"> like what</font><font color="#E5E5E5"> bites are more common</font>

410
00:18:24,870 --> 00:18:30,870
<font color="#E5E5E5">than other bites that's not super</font>

411
00:18:28,230 --> 00:18:33,540
scientific exact<font color="#E5E5E5"> but it for our case I</font>

412
00:18:30,870 --> 00:18:36,570
think<font color="#E5E5E5"> it was a cool approximation what</font>

413
00:18:33,540 --> 00:18:38,720
we did was we we patched<font color="#CCCCCC"> a copy out</font><font color="#E5E5E5"> and</font>

414
00:18:36,570 --> 00:18:41,220
<font color="#E5E5E5">copy out swing in that</font><font color="#CCCCCC"> piece t8</font><font color="#E5E5E5"> and</font>

415
00:18:38,720 --> 00:18:43,830
<font color="#CCCCCC">every time I'm copy out a copy out</font>

416
00:18:41,220 --> 00:18:46,290
<font color="#E5E5E5">string was called we had an internal</font>

417
00:18:43,830 --> 00:18:48,600
data structure and we counted<font color="#CCCCCC"> 2 bytes</font>

418
00:18:46,290 --> 00:18:51,149
<font color="#E5E5E5">that we saw in the buffer to be copied</font>

419
00:18:48,600 --> 00:18:53,639
into<font color="#CCCCCC"> your space so we counted in this</font>

420
00:18:51,150 --> 00:18:56,880
buffer there were three times the<font color="#E5E5E5"> byte 1</font>

421
00:18:53,640 --> 00:18:58,890
<font color="#E5E5E5">2</font><font color="#CCCCCC"> byte</font><font color="#E5E5E5"> 2 times 2 by 2 and so</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> and so</font>

422
00:18:56,880 --> 00:19:00,840
forth and then we<font color="#E5E5E5"> had</font><font color="#CCCCCC"> another system</font>

423
00:18:58,890 --> 00:19:03,990
call in order to fetch<font color="#E5E5E5"> this data from</font>

424
00:19:00,840 --> 00:19:06,659
kernel space<font color="#CCCCCC"> and</font><font color="#E5E5E5"> we did out in order to</font>

425
00:19:03,990 --> 00:19:09,450
get a lot of<font color="#E5E5E5"> interaction with the</font>

426
00:19:06,660 --> 00:19:12,960
<font color="#E5E5E5">operating</font><font color="#CCCCCC"> system kernel and we used on</font>

427
00:19:09,450 --> 00:19:16,049
<font color="#CCCCCC">the the</font><font color="#E5E5E5"> tests test suite of net 50 tests</font>

428
00:19:12,960 --> 00:19:18,299
<font color="#E5E5E5">ATF and just I think</font><font color="#CCCCCC"> it one</font><font color="#E5E5E5"> in my VM</font>

429
00:19:16,049 --> 00:19:21,600
half an hour hour something<font color="#CCCCCC"> like that</font>

430
00:19:18,299 --> 00:19:24,150
and we caught like it provoked many many

431
00:19:21,600 --> 00:19:26,490
many implications<font color="#CCCCCC"> of copy out and copy</font>

432
00:19:24,150 --> 00:19:28,950
out string and it's basically the result

433
00:19:26,490 --> 00:19:33,059
so the<font color="#CCCCCC"> left hand</font><font color="#E5E5E5"> side on</font><font color="#CCCCCC"> like a metric</font>

434
00:19:28,950 --> 00:19:36,120
<font color="#E5E5E5">scale you</font><font color="#CCCCCC"> see</font><font color="#E5E5E5"> you see the results of</font>

435
00:19:33,059 --> 00:19:39,928
copy out and on the<font color="#E5E5E5"> right side</font><font color="#CCCCCC"> you see</font>

436
00:19:36,120 --> 00:19:42,719
<font color="#CCCCCC">the results</font><font color="#E5E5E5"> of copy out string so first</font>

437
00:19:39,929 --> 00:19:45,750
you will<font color="#E5E5E5"> notice in the</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> the left hand</font>

438
00:19:42,720 --> 00:19:47,490
<font color="#E5E5E5">side there the bytes like 1 0</font><font color="#CCCCCC"> 1 that</font><font color="#E5E5E5"> a</font>

439
00:19:45,750 --> 00:19:49,410
little bit more common<font color="#E5E5E5"> then in the</font>

440
00:19:47,490 --> 00:19:52,790
middle that seems to be<font color="#CCCCCC"> the same as the</font>

441
00:19:49,410 --> 00:19:54,960
<font color="#CCCCCC">ESP spectrum</font><font color="#E5E5E5"> over there more or less</font><font color="#CCCCCC"> so</font>

442
00:19:52,790 --> 00:19:57,450
those seem to<font color="#CCCCCC"> be coming and then at the</font>

443
00:19:54,960 --> 00:19:59,970
end<font color="#CCCCCC"> they're also</font><font color="#E5E5E5"> black bytes like minus</font>

444
00:19:57,450 --> 00:20:03,600
1 which is 255 is quite a

445
00:19:59,970 --> 00:20:06,450
and<font color="#CCCCCC"> bytes but bytes at the end of the</font>

446
00:20:03,600 --> 00:20:10,770
spectrum like in a train<font color="#CCCCCC"> shove 202 and a</font>

447
00:20:06,450 --> 00:20:12,630
<font color="#CCCCCC">tranny</font><font color="#E5E5E5"> not that common so maybe choosing</font>

448
00:20:10,770 --> 00:20:15,170
them as<font color="#CCCCCC"> NACA might would be</font><font color="#E5E5E5"> a better</font>

449
00:20:12,630 --> 00:20:18,120
<font color="#E5E5E5">idea then on the right hand side we see</font>

450
00:20:15,170 --> 00:20:22,020
<font color="#E5E5E5">the</font><font color="#CCCCCC"> values for copy out</font><font color="#E5E5E5"> I'm string and</font>

451
00:20:18,120 --> 00:20:23,669
<font color="#CCCCCC">just copies</font><font color="#E5E5E5"> out only</font><font color="#CCCCCC"> s key strings so</font>

452
00:20:22,020 --> 00:20:26,220
the good news<font color="#CCCCCC"> is we did not</font><font color="#E5E5E5"> account like</font>

453
00:20:23,670 --> 00:20:27,720
a byte at 200 which would be something

454
00:20:26,220 --> 00:20:30,030
like current memory disclosures<font color="#E5E5E5"> the</font>

455
00:20:27,720 --> 00:20:33,300
<font color="#CCCCCC">bytes actually in it in the S key range</font>

456
00:20:30,030 --> 00:20:35,550
and there's<font color="#CCCCCC"> 10 and this</font><font color="#E5E5E5"> little spike the</font>

457
00:20:33,300 --> 00:20:40,680
left side that's like line feed and<font color="#CCCCCC"> its</font>

458
00:20:35,550 --> 00:20:43,050
value 10 10 or 11 so on the bottom<font color="#CCCCCC"> you</font>

459
00:20:40,680 --> 00:20:47,220
can<font color="#CCCCCC"> see on</font><font color="#E5E5E5"> left hand side the bytes that</font>

460
00:20:43,050 --> 00:20:51,240
<font color="#E5E5E5">are quite common like 0 to 255 I don't</font>

461
00:20:47,220 --> 00:20:52,890
know why it's 1797<font color="#E5E5E5"> but and on the right</font>

462
00:20:51,240 --> 00:20:55,110
hand<font color="#CCCCCC"> side dot</font><font color="#E5E5E5"> out the bytes that are not</font>

463
00:20:52,890 --> 00:21:00,570
so frequent and which we choose as our

464
00:20:55,110 --> 00:21:03,209
marker bytes<font color="#E5E5E5"> and it's like 154 218 bytes</font>

465
00:21:00,570 --> 00:21:10,439
vectors and I think of those 10 like for

466
00:21:03,210 --> 00:21:12,540
maybe<font color="#E5E5E5"> our prime</font><font color="#CCCCCC"> numbers so so our</font>

467
00:21:10,440 --> 00:21:16,230
solution as we told<font color="#E5E5E5"> you and I</font><font color="#CCCCCC"> told</font><font color="#E5E5E5"> you</font>

468
00:21:12,540 --> 00:21:17,790
using only one marker byte<font color="#E5E5E5"> it's not a</font>

469
00:21:16,230 --> 00:21:19,980
good<font color="#CCCCCC"> idea because</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> have a</font><font color="#E5E5E5"> consider</font>

470
00:21:17,790 --> 00:21:22,860
<font color="#E5E5E5">lot of positive and false</font><font color="#CCCCCC"> positives</font><font color="#E5E5E5"> and</font>

471
00:21:19,980 --> 00:21:24,540
the solution was basically to invoke

472
00:21:22,860 --> 00:21:27,209
<font color="#CCCCCC">take on</font><font color="#E5E5E5"> entry points over and over again</font>

473
00:21:24,540 --> 00:21:31,320
but changing<font color="#E5E5E5"> the marker points at the</font>

474
00:21:27,210 --> 00:21:34,770
<font color="#CCCCCC">maka bytes and using this hit map and</font>

475
00:21:31,320 --> 00:21:38,220
with a sip map each offset we had a we

476
00:21:34,770 --> 00:21:41,160
<font color="#CCCCCC">had a</font><font color="#E5E5E5"> byte and each byte contains</font><font color="#CCCCCC"> 8 bits</font>

477
00:21:38,220 --> 00:21:43,290
and if<font color="#E5E5E5"> you choose</font><font color="#CCCCCC"> 8 rounds we switch on</font>

478
00:21:41,160 --> 00:21:46,440
each<font color="#E5E5E5"> one if you a counter about we</font>

479
00:21:43,290 --> 00:21:50,070
switch a bit on<font color="#E5E5E5"> and in the end we jump</font>

480
00:21:46,440 --> 00:21:52,350
to results so this<font color="#E5E5E5"> can be done in the</font>

481
00:21:50,070 --> 00:21:53,189
<font color="#CCCCCC">implementation</font><font color="#E5E5E5"> and net</font><font color="#CCCCCC"> piece t-mister</font>

482
00:21:52,350 --> 00:21:58,770
<font color="#E5E5E5">userland</font>

483
00:21:53,190 --> 00:22:01,650
<font color="#E5E5E5">arm to</font><font color="#CCCCCC"> Cayley which interacts with</font><font color="#E5E5E5"> with</font>

484
00:21:58,770 --> 00:22:03,600
<font color="#E5E5E5">the kernel part in general it's</font><font color="#CCCCCC"> not</font>

485
00:22:01,650 --> 00:22:06,360
<font color="#CCCCCC">enabled by</font><font color="#E5E5E5"> default it's a developer</font>

486
00:22:03,600 --> 00:22:08,969
option but it's your system remains

487
00:22:06,360 --> 00:22:10,790
quite<font color="#CCCCCC"> useable so it's not</font><font color="#E5E5E5"> a tremendous</font>

488
00:22:08,970 --> 00:22:14,450
slowdown that's happening if<font color="#E5E5E5"> you</font>

489
00:22:10,790 --> 00:22:16,730
<font color="#CCCCCC">Helly and here we can see an example we</font>

490
00:22:14,450 --> 00:22:20,020
<font color="#CCCCCC">caulk a</font><font color="#E5E5E5"> leak with the number of rounds</font>

491
00:22:16,730 --> 00:22:22,550
in<font color="#E5E5E5"> this case</font><font color="#CCCCCC"> four and the command</font><font color="#E5E5E5"> PS and</font>

492
00:22:20,020 --> 00:22:24,530
what happens was that<font color="#CCCCCC"> they came the</font>

493
00:22:22,550 --> 00:22:28,790
output and<font color="#CCCCCC"> maxeen for this one which was</font>

494
00:22:24,530 --> 00:22:32,060
quite tremendous which<font color="#CCCCCC"> leaked 931</font><font color="#E5E5E5"> bytes</font>

495
00:22:28,790 --> 00:22:34,280
of memory from New Zealand<font color="#CCCCCC"> to kernel</font><font color="#E5E5E5"> and</font>

496
00:22:32,060 --> 00:22:39,649
<font color="#E5E5E5">if I think this was</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> biggest one that</font>

497
00:22:34,280 --> 00:22:41,750
<font color="#E5E5E5">we found</font><font color="#CCCCCC"> so that's quite a lot</font><font color="#E5E5E5"> so</font>

498
00:22:39,650 --> 00:22:44,780
<font color="#E5E5E5">quickly about the limitations</font>

499
00:22:41,750 --> 00:22:47,260
well<font color="#E5E5E5"> one</font><font color="#CCCCCC"> limitation is simplicity</font><font color="#E5E5E5"> and</font>

500
00:22:44,780 --> 00:22:50,690
speed<font color="#CCCCCC"> over positions so</font><font color="#E5E5E5"> we are not that</font>

501
00:22:47,260 --> 00:22:53,150
precise<font color="#E5E5E5"> because we don't have this super</font>

502
00:22:50,690 --> 00:22:56,780
sophisticated taint tracking where we

503
00:22:53,150 --> 00:22:58,850
track the bytes through every through

504
00:22:56,780 --> 00:23:01,820
every operation in the kernel<font color="#E5E5E5"> we was a</font>

505
00:22:58,850 --> 00:23:03,290
let them<font color="#E5E5E5"> travel to the kernel check at</font>

506
00:23:01,820 --> 00:23:05,270
the end<font color="#E5E5E5"> and that's it</font>

507
00:23:03,290 --> 00:23:08,300
so that's simple because the patch<font color="#CCCCCC"> of</font>

508
00:23:05,270 --> 00:23:09,830
<font color="#CCCCCC">colleague from NetBSD was definitely</font>

509
00:23:08,300 --> 00:23:13,100
less<font color="#CCCCCC"> than thousand lines I don't know</font>

510
00:23:09,830 --> 00:23:16,520
<font color="#E5E5E5">exactly how</font><font color="#CCCCCC"> many it was</font><font color="#E5E5E5"> and it's kind of</font>

511
00:23:13,100 --> 00:23:19,280
fast you don't have you don't<font color="#CCCCCC"> know to</font><font color="#E5E5E5"> a</font>

512
00:23:16,520 --> 00:23:21,080
<font color="#E5E5E5">man</font><font color="#CCCCCC"> is slowed down</font><font color="#E5E5E5"> and that's</font><font color="#CCCCCC"> that was</font>

513
00:23:19,280 --> 00:23:22,820
one of<font color="#E5E5E5"> our goals and</font><font color="#CCCCCC"> actually it worked</font>

514
00:23:21,080 --> 00:23:24,320
<font color="#CCCCCC">as you will see later on</font><font color="#E5E5E5"> so code</font>

515
00:23:22,820 --> 00:23:26,659
coverage<font color="#E5E5E5"> it's a dynamic analysis</font>

516
00:23:24,320 --> 00:23:29,570
approach that's<font color="#E5E5E5"> the problem</font><font color="#CCCCCC"> is dynamic</font>

517
00:23:26,660 --> 00:23:32,090
analysis so we<font color="#CCCCCC"> have to we have to cover</font>

518
00:23:29,570 --> 00:23:35,240
as much as possible<font color="#E5E5E5"> you can simulate</font>

519
00:23:32,090 --> 00:23:37,730
user<font color="#E5E5E5"> interaction you can use for</font><font color="#CCCCCC"> example</font>

520
00:23:35,240 --> 00:23:40,640
you can use testing frameworks like<font color="#E5E5E5"> ATF</font>

521
00:23:37,730 --> 00:23:42,730
tests you could use fuzzing<font color="#E5E5E5"> to to</font>

522
00:23:40,640 --> 00:23:46,280
improve on the coverage but<font color="#CCCCCC"> in the end</font>

523
00:23:42,730 --> 00:23:48,950
yeah close to<font color="#CCCCCC"> 100% coverage is difficult</font>

524
00:23:46,280 --> 00:23:52,220
and but<font color="#E5E5E5"> that's the problem of all the</font>

525
00:23:48,950 --> 00:23:53,990
dynamic analysis purchase another thing

526
00:23:52,220 --> 00:23:57,500
<font color="#CCCCCC">may be portability across the beast</font><font color="#E5E5E5"> it's</font>

527
00:23:53,990 --> 00:24:00,770
not a huge issue<font color="#CCCCCC"> I did a proof of</font>

528
00:23:57,500 --> 00:24:03,410
concept part to<font color="#E5E5E5"> FreeBSD which which gave</font>

529
00:24:00,770 --> 00:24:05,960
some<font color="#E5E5E5"> results and I think you can do it</font>

530
00:24:03,410 --> 00:24:09,260
to<font color="#CCCCCC"> Apple and</font><font color="#E5E5E5"> to Linux if you want and to</font>

531
00:24:05,960 --> 00:24:12,230
Windows I don't know<font color="#E5E5E5"> so those are the</font>

532
00:24:09,260 --> 00:24:15,320
direct results actually<font color="#E5E5E5"> of k-league and</font>

533
00:24:12,230 --> 00:24:17,920
I think it's not complete we found in

534
00:24:15,320 --> 00:24:21,649
three<font color="#E5E5E5"> weeks we I parted it to FreeBSD</font>

535
00:24:17,920 --> 00:24:24,260
11.2 as a proof of concept<font color="#CCCCCC"> and Maxime</font>

536
00:24:21,650 --> 00:24:26,420
implemented fully and netbsd current

537
00:24:24,260 --> 00:24:28,790
and this is like<font color="#E5E5E5"> those are more than</font>

538
00:24:26,420 --> 00:24:31,100
training<font color="#CCCCCC"> La Boheme</font><font color="#E5E5E5"> leaks</font>

539
00:24:28,790 --> 00:24:33,350
<font color="#CCCCCC">I'm familiar</font><font color="#E5E5E5"> from dynamic memory from</font>

540
00:24:31,100 --> 00:24:35,870
<font color="#E5E5E5">the kernel stack some of them are bigger</font>

541
00:24:33,350 --> 00:24:38,060
<font color="#CCCCCC">like nine hundred bytes</font><font color="#E5E5E5"> 22 some of them</font>

542
00:24:35,870 --> 00:24:41,060
are smaller<font color="#E5E5E5"> usually</font><font color="#CCCCCC"> those are half of</font>

543
00:24:38,060 --> 00:24:45,530
the<font color="#E5E5E5"> half of a pointer</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> MD 64 what we</font>

544
00:24:41,060 --> 00:24:47,240
<font color="#E5E5E5">found</font><font color="#CCCCCC"> so and the research basically goes</font>

545
00:24:45,530 --> 00:24:51,200
on those are the direct results that we

546
00:24:47,240 --> 00:24:55,550
<font color="#CCCCCC">found with you by using</font><font color="#E5E5E5"> k-league so</font><font color="#CCCCCC"> I</font>

547
00:24:51,200 --> 00:24:59,030
was told there will<font color="#E5E5E5"> be soon a security</font>

548
00:24:55,550 --> 00:25:02,480
advisory by a net<font color="#E5E5E5"> beastie about many</font>

549
00:24:59,030 --> 00:25:05,870
<font color="#E5E5E5">leaf more than 15 16 I don't know what</font>

550
00:25:02,480 --> 00:25:09,890
happened<font color="#CCCCCC"> to the free</font><font color="#E5E5E5"> beastie leaks they</font>

551
00:25:05,870 --> 00:25:12,709
were fixed all but there's no<font color="#E5E5E5"> security</font>

552
00:25:09,890 --> 00:25:14,450
advisory so far<font color="#E5E5E5"> I don't know</font><font color="#CCCCCC"> what</font>

553
00:25:12,710 --> 00:25:18,520
happened was this was<font color="#E5E5E5"> kind of a cool</font>

554
00:25:14,450 --> 00:25:21,950
like and<font color="#E5E5E5"> follow up by the</font><font color="#CCCCCC"> FreeBSD deaths</font>

555
00:25:18,520 --> 00:25:23,990
<font color="#CCCCCC">there the leaks</font><font color="#E5E5E5"> were thwarted and what</font>

556
00:25:21,950 --> 00:25:25,460
they did basically<font color="#E5E5E5"> they looked around in</font>

557
00:25:23,990 --> 00:25:27,200
<font color="#E5E5E5">the code where one leak is there may be</font>

558
00:25:25,460 --> 00:25:29,420
another so on the<font color="#E5E5E5"> left hand side there</font>

559
00:25:27,200 --> 00:25:31,490
was one leak and get<font color="#E5E5E5"> the entries and I</font>

560
00:25:29,420 --> 00:25:33,200
found out that were like<font color="#E5E5E5"> 20</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> 20</font>

561
00:25:31,490 --> 00:25:35,720
implementations<font color="#E5E5E5"> of five systems there</font>

562
00:25:33,200 --> 00:25:38,810
was a leak and they<font color="#E5E5E5"> fixed them all so as</font>

563
00:25:35,720 --> 00:25:41,120
an<font color="#CCCCCC"> follow-up they fixed like 50 or 60</font>

564
00:25:38,810 --> 00:25:48,139
more<font color="#E5E5E5"> kernel memory disclosures which was</font>

565
00:25:41,120 --> 00:25:50,330
quite work yes<font color="#E5E5E5"> so as a</font><font color="#CCCCCC"> conclusion so we</font>

566
00:25:48,140 --> 00:25:53,500
saw<font color="#E5E5E5"> what a kernel memory disclosures so</font>

567
00:25:50,330 --> 00:25:56,689
<font color="#CCCCCC">what they are</font><font color="#E5E5E5"> how to avoid them I</font>

568
00:25:53,500 --> 00:25:58,520
presented to you<font color="#CCCCCC"> our approach with</font>

569
00:25:56,690 --> 00:26:02,450
<font color="#E5E5E5">called K leak which is fully implemented</font>

570
00:25:58,520 --> 00:26:05,600
net<font color="#CCCCCC"> BSD and attracted more than</font><font color="#E5E5E5"> 20 of</font>

571
00:26:02,450 --> 00:26:07,850
those memory disclosures<font color="#E5E5E5"> and as</font>

572
00:26:05,600 --> 00:26:12,679
follow-up<font color="#E5E5E5"> thousands of those were fixed</font>

573
00:26:07,850 --> 00:26:14,840
by other<font color="#E5E5E5"> developers and so it's a thing</font>

574
00:26:12,680 --> 00:26:17,050
the the one one more thing is the

575
00:26:14,840 --> 00:26:19,459
<font color="#CCCCCC">beastie apart from being came if we</font>

576
00:26:17,050 --> 00:26:21,919
that's<font color="#CCCCCC"> true for</font><font color="#E5E5E5"> other operating systems</font>

577
00:26:19,460 --> 00:26:24,200
as<font color="#E5E5E5"> well so instead</font><font color="#CCCCCC"> today instead</font><font color="#E5E5E5"> of</font>

578
00:26:21,920 --> 00:26:26,750
<font color="#E5E5E5">planting a tree maybe we can fix a</font>

579
00:26:24,200 --> 00:26:30,710
<font color="#E5E5E5">memory disclosure and</font><font color="#CCCCCC"> we getting closer</font>

580
00:26:26,750 --> 00:26:32,390
<font color="#E5E5E5">to a full secure system so keep</font><font color="#CCCCCC"> looking</font>

581
00:26:30,710 --> 00:26:33,760
for them and thank you for your

582
00:26:32,390 --> 00:26:40,779
attention

583
00:26:33,760 --> 00:26:40,779
[Applause]

584
00:27:01,309 --> 00:27:06,928
actually there are<font color="#E5E5E5"> some projects and</font>

585
00:27:04,520 --> 00:27:08,280
like for example<font color="#CCCCCC"> on</font><font color="#E5E5E5"> linux there's</font>

586
00:27:06,929 --> 00:27:11,280
something like<font color="#E5E5E5"> that every</font><font color="#CCCCCC"> time you enter</font>

587
00:27:08,280 --> 00:27:14,039
into<font color="#CCCCCC"> a system call</font><font color="#E5E5E5"> it will see you out</font>

588
00:27:11,280 --> 00:27:18,149
<font color="#CCCCCC">your your stack so then there's the</font>

589
00:27:14,039 --> 00:27:19,950
issue performance so this<font color="#E5E5E5"> is also like I</font>

590
00:27:18,150 --> 00:27:21,929
don't<font color="#E5E5E5"> know how many CPU cycles</font><font color="#CCCCCC"> but if</font>

591
00:27:19,950 --> 00:27:24,090
<font color="#CCCCCC">it's performance critical</font><font color="#E5E5E5"> you don't</font><font color="#CCCCCC"> you</font>

592
00:27:21,929 --> 00:27:27,059
won't<font color="#E5E5E5"> need</font><font color="#CCCCCC"> it you</font><font color="#E5E5E5"> won't you don't want</font>

593
00:27:24,090 --> 00:27:29,549
to have it<font color="#E5E5E5"> but it's there it's not it's</font>

594
00:27:27,059 --> 00:27:31,379
not a standard thing it's one of those

595
00:27:29,549 --> 00:27:33,030
security patches I don't know how they

596
00:27:31,380 --> 00:27:37,049
call like the<font color="#E5E5E5"> Linux security</font><font color="#CCCCCC"> patches</font>

597
00:27:33,030 --> 00:27:38,760
maybe yeah but then again there's for

598
00:27:37,049 --> 00:27:42,840
<font color="#E5E5E5">example there's and there are leaks that</font>

599
00:27:38,760 --> 00:27:44,850
<font color="#CCCCCC">are from because you wrote it there and</font>

600
00:27:42,840 --> 00:27:46,620
then there<font color="#CCCCCC"> are leaks for extended</font>

601
00:27:44,850 --> 00:27:49,219
monthly then there are leaks from<font color="#CCCCCC"> the</font>

602
00:27:46,620 --> 00:27:51,570
heap<font color="#CCCCCC"> so then you have to</font><font color="#E5E5E5"> patch new heap</font>

603
00:27:49,220 --> 00:27:54,390
implementation as<font color="#E5E5E5"> well so there are many</font>

604
00:27:51,570 --> 00:28:02,389
places where<font color="#CCCCCC"> those leaks</font><font color="#E5E5E5"> can I could</font>

605
00:27:54,390 --> 00:28:02,390
occur<font color="#E5E5E5"> as a key</font>

606
00:28:03,150 --> 00:28:09,190
so this is<font color="#E5E5E5"> was actually I'm not the hit</font>

607
00:28:07,360 --> 00:28:13,600
<font color="#CCCCCC">map was the</font><font color="#E5E5E5"> greatest idea of Maxine who</font>

608
00:28:09,190 --> 00:28:15,370
implemented<font color="#E5E5E5"> so asked him that was so I</font>

609
00:28:13,600 --> 00:28:17,730
cannot give<font color="#CCCCCC"> you the</font><font color="#E5E5E5"> toilet details on</font>

610
00:28:15,370 --> 00:28:17,729
the headlamp

611
00:28:28,610 --> 00:28:35,830
[Applause]

