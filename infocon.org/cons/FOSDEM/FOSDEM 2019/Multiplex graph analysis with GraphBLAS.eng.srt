1
00:00:04,640 --> 00:00:09,379
my name is Gabbar Suresh<font color="#CCCCCC"> I'm a PhD</font>

2
00:00:07,250 --> 00:00:11,660
<font color="#E5E5E5">candidate from Budapest Hungary</font><font color="#CCCCCC"> and</font>

3
00:00:09,379 --> 00:00:14,660
<font color="#E5E5E5">today I'm here to talk about the topic</font>

4
00:00:11,660 --> 00:00:18,560
of<font color="#E5E5E5"> graph analytics and in the context of</font>

5
00:00:14,660 --> 00:00:20,900
<font color="#E5E5E5">using matrix operations and running</font>

6
00:00:18,560 --> 00:00:23,270
analytics<font color="#E5E5E5"> on investigative journalism</font>

7
00:00:20,900 --> 00:00:25,369
datasets<font color="#E5E5E5"> so if you're here you have</font>

8
00:00:23,270 --> 00:00:28,640
probably heard about the Paradise<font color="#E5E5E5"> Papers</font>

9
00:00:25,369 --> 00:00:31,580
<font color="#E5E5E5">this is a data set that was leaked to a</font>

10
00:00:28,640 --> 00:00:33,050
set of investigative journalists<font color="#E5E5E5"> this</font><font color="#CCCCCC"> is</font>

11
00:00:31,580 --> 00:00:35,690
somewhat<font color="#CCCCCC"> similar</font><font color="#E5E5E5"> to the Panama papers</font>

12
00:00:33,050 --> 00:00:38,510
but it's a bit<font color="#E5E5E5"> more complex and it's a</font>

13
00:00:35,690 --> 00:00:41,150
bit bigger<font color="#E5E5E5"> if you think in</font><font color="#CCCCCC"> terms of big</font>

14
00:00:38,510 --> 00:00:43,280
<font color="#E5E5E5">data it's not a huge data set it has</font><font color="#CCCCCC"> two</font>

15
00:00:41,150 --> 00:00:45,620
million<font color="#E5E5E5"> nodes and three million edges</font>

16
00:00:43,280 --> 00:00:48,860
<font color="#E5E5E5">but even so it has been used with</font>

17
00:00:45,620 --> 00:00:51,140
success<font color="#CCCCCC"> to uncover there is interesting</font>

18
00:00:48,860 --> 00:00:53,239
and shady<font color="#E5E5E5"> offshore deal so this is</font>

19
00:00:51,140 --> 00:00:55,339
actually one of those use cases where

20
00:00:53,239 --> 00:00:59,030
graphs are used for the greater good

21
00:00:55,339 --> 00:01:00,979
this is something that<font color="#E5E5E5"> can help us to</font>

22
00:00:59,030 --> 00:01:03,110
understand<font color="#E5E5E5"> how the world works</font><font color="#CCCCCC"> reduce</font>

23
00:01:00,979 --> 00:01:05,799
corruption<font color="#E5E5E5"> so this is really one of the</font>

24
00:01:03,110 --> 00:01:09,020
coolest<font color="#CCCCCC"> use cases</font><font color="#E5E5E5"> of graph technology</font>

25
00:01:05,799 --> 00:01:12,530
the schema of<font color="#CCCCCC"> the graph is rather simple</font>

26
00:01:09,020 --> 00:01:14,590
so you<font color="#E5E5E5"> have some of these entities they</font>

27
00:01:12,530 --> 00:01:16,940
are<font color="#CCCCCC"> connected to officers they have</font>

28
00:01:14,590 --> 00:01:20,000
intermediaries to<font color="#CCCCCC"> do their business</font>

29
00:01:16,940 --> 00:01:23,060
deals<font color="#CCCCCC"> with and many of these objects</font><font color="#E5E5E5"> can</font>

30
00:01:20,000 --> 00:01:25,850
be<font color="#CCCCCC"> registered to a certain address</font><font color="#E5E5E5"> so</font>

31
00:01:23,060 --> 00:01:28,580
this is graph schema<font color="#E5E5E5"> that you have</font>

32
00:01:25,850 --> 00:01:31,309
probably seen or you have probably seen

33
00:01:28,580 --> 00:01:34,759
something<font color="#E5E5E5"> similar to there are node</font>

34
00:01:31,310 --> 00:01:38,360
labels<font color="#E5E5E5"> and there are edge types in this</font>

35
00:01:34,760 --> 00:01:40,730
graph schema so when we talk about graph

36
00:01:38,360 --> 00:01:43,700
data models I think<font color="#CCCCCC"> it's important</font><font color="#E5E5E5"> to</font>

37
00:01:40,730 --> 00:01:47,210
<font color="#E5E5E5">get the terminology right if you open a</font>

38
00:01:43,700 --> 00:01:49,580
textbook<font color="#E5E5E5"> it's often a graph like this so</font>

39
00:01:47,210 --> 00:01:52,158
this is some social graph there are five

40
00:01:49,580 --> 00:01:54,259
<font color="#E5E5E5">people here from</font><font color="#CCCCCC"> Bob to</font><font color="#E5E5E5"> Fred and these</font>

41
00:01:52,159 --> 00:01:56,900
people have some<font color="#CCCCCC"> acquaintance</font>

42
00:01:54,260 --> 00:02:00,260
relationship<font color="#E5E5E5"> each node is a person and</font>

43
00:01:56,900 --> 00:02:03,530
each edge is relationship this<font color="#E5E5E5"> is called</font>

44
00:02:00,260 --> 00:02:05,840
<font color="#E5E5E5">a</font><font color="#CCCCCC"> single graph or sometimes it's</font><font color="#E5E5E5"> called</font>

45
00:02:03,530 --> 00:02:08,598
<font color="#E5E5E5">textbook graph which is bit derogatory</font>

46
00:02:05,840 --> 00:02:10,580
<font color="#CCCCCC">and it has many other names so if you</font>

47
00:02:08,598 --> 00:02:13,579
review<font color="#CCCCCC"> the literature</font><font color="#E5E5E5"> it's called an</font>

48
00:02:10,580 --> 00:02:15,950
untyped graph<font color="#E5E5E5"> homogeneous network or a</font>

49
00:02:13,580 --> 00:02:18,280
<font color="#CCCCCC">monoblocks graph so these are all the</font>

50
00:02:15,950 --> 00:02:20,500
same<font color="#E5E5E5"> term</font>

51
00:02:18,280 --> 00:02:22,930
of course reality<font color="#E5E5E5"> is a bit more</font>

52
00:02:20,500 --> 00:02:24,910
<font color="#E5E5E5">sophisticated than</font><font color="#CCCCCC"> that so if</font><font color="#E5E5E5"> we could</font>

53
00:02:22,930 --> 00:02:27,580
just<font color="#E5E5E5"> reduce the abstraction a bit</font><font color="#CCCCCC"> we</font>

54
00:02:24,910 --> 00:02:30,250
could<font color="#E5E5E5"> say</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> we only have persons in</font>

55
00:02:27,580 --> 00:02:33,610
the graph<font color="#E5E5E5"> but let's see whether they</font>

56
00:02:30,250 --> 00:02:36,220
have<font color="#E5E5E5"> different</font><font color="#CCCCCC"> relationships so in this</font>

57
00:02:33,610 --> 00:02:38,320
figure<font color="#E5E5E5"> the green lines correspond for</font>

58
00:02:36,220 --> 00:02:40,300
business relationships<font color="#E5E5E5"> and the blue</font>

59
00:02:38,320 --> 00:02:42,370
lines correspond for friendships<font color="#E5E5E5"> and</font>

60
00:02:40,300 --> 00:02:44,500
this makes it a lot<font color="#CCCCCC"> more interesting</font>

61
00:02:42,370 --> 00:02:47,170
<font color="#CCCCCC">because</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> can see</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> Carol is more</font>

62
00:02:44,500 --> 00:02:50,770
<font color="#E5E5E5">oriented towards the friendship side and</font>

63
00:02:47,170 --> 00:02:55,109
then<font color="#E5E5E5"> it's more like the business center</font>

64
00:02:50,770 --> 00:02:57,880
of this little<font color="#E5E5E5"> set of persons if you</font>

65
00:02:55,110 --> 00:03:00,610
read the<font color="#E5E5E5"> literature you will</font><font color="#CCCCCC"> find that</font>

66
00:02:57,880 --> 00:03:02,859
this<font color="#E5E5E5"> is called the multiplex graph or an</font>

67
00:03:00,610 --> 00:03:04,930
edge<font color="#CCCCCC"> labelled or an edge type graph and</font>

68
00:03:02,860 --> 00:03:07,150
there are other<font color="#E5E5E5"> names in network science</font>

69
00:03:04,930 --> 00:03:09,490
<font color="#E5E5E5">called heterogeneous network or</font>

70
00:03:07,150 --> 00:03:13,360
<font color="#E5E5E5">multi-dimensional</font><font color="#CCCCCC"> network interestingly</font>

71
00:03:09,490 --> 00:03:15,520
the expressive<font color="#CCCCCC"> power of</font><font color="#E5E5E5"> this graph is a</font>

72
00:03:13,360 --> 00:03:18,220
lot stronger than<font color="#E5E5E5"> that</font>

73
00:03:15,520 --> 00:03:20,320
<font color="#E5E5E5">of the Untied graph but it still miles</font>

74
00:03:18,220 --> 00:03:22,300
<font color="#E5E5E5">away from the property graph that is</font>

75
00:03:20,320 --> 00:03:24,910
served by graph<font color="#E5E5E5"> databases because</font><font color="#CCCCCC"> we</font>

76
00:03:22,300 --> 00:03:28,720
don't assign any properties<font color="#E5E5E5"> to any of</font>

77
00:03:24,910 --> 00:03:31,120
the nodes or<font color="#CCCCCC"> the edges so what do</font><font color="#E5E5E5"> we be</font>

78
00:03:28,720 --> 00:03:33,670
my graph analysis and multiplex graph

79
00:03:31,120 --> 00:03:35,440
analysis in particular<font color="#E5E5E5"> when</font><font color="#CCCCCC"> we do graph</font>

80
00:03:33,670 --> 00:03:38,320
analysis we often<font color="#CCCCCC"> define a set of</font>

81
00:03:35,440 --> 00:03:40,930
<font color="#CCCCCC">metrics like</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> so-called</font><font color="#E5E5E5"> local</font>

82
00:03:38,320 --> 00:03:43,209
<font color="#E5E5E5">clustering coefficient metric the idea</font>

83
00:03:40,930 --> 00:03:47,200
here<font color="#CCCCCC"> is that we study</font><font color="#E5E5E5"> the graph in each</font>

84
00:03:43,209 --> 00:03:50,410
load so<font color="#CCCCCC"> we start from</font><font color="#E5E5E5"> each node</font><font color="#CCCCCC"> V and we</font>

85
00:03:47,200 --> 00:03:53,049
look for the instances of<font color="#E5E5E5"> edges which</font><font color="#CCCCCC"> is</font>

86
00:03:50,410 --> 00:03:55,359
like this shape and this means<font color="#CCCCCC"> that</font>

87
00:03:53,050 --> 00:03:58,630
there<font color="#CCCCCC"> is a node and it has two neighbors</font>

88
00:03:55,360 --> 00:04:00,550
<font color="#E5E5E5">that might or might not</font><font color="#CCCCCC"> be connected</font><font color="#E5E5E5"> to</font>

89
00:03:58,630 --> 00:04:03,390
each other<font color="#CCCCCC"> if they</font><font color="#E5E5E5"> are connected to each</font>

90
00:04:00,550 --> 00:04:06,670
other<font color="#CCCCCC"> then they form a triangle which is</font>

91
00:04:03,390 --> 00:04:10,049
on the right side so<font color="#E5E5E5"> which can be closed</font>

92
00:04:06,670 --> 00:04:13,480
<font color="#CCCCCC">into a triangle</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> is an age-old idea</font>

93
00:04:10,050 --> 00:04:15,970
<font color="#CCCCCC">dating back I guess to</font><font color="#E5E5E5"> the 1960s and it</font>

94
00:04:13,480 --> 00:04:18,789
<font color="#E5E5E5">has been</font><font color="#CCCCCC"> published in</font><font color="#E5E5E5"> textbook textbooks</font>

95
00:04:15,970 --> 00:04:22,510
in the 1990s<font color="#E5E5E5"> this is a very popular tool</font>

96
00:04:18,790 --> 00:04:24,940
<font color="#E5E5E5">in social network analysis</font><font color="#CCCCCC"> to determine</font>

97
00:04:22,510 --> 00:04:27,849
this metric the clustering<font color="#E5E5E5"> coefficient</font>

98
00:04:24,940 --> 00:04:31,150
<font color="#CCCCCC">the idea is</font><font color="#E5E5E5"> only to calculate the ratio</font>

99
00:04:27,850 --> 00:04:33,310
<font color="#E5E5E5">of the triangles the</font><font color="#CCCCCC"> vegies that</font><font color="#E5E5E5"> close</font>

100
00:04:31,150 --> 00:04:35,650
<font color="#CCCCCC">the triangle</font><font color="#E5E5E5"> and the number of</font><font color="#CCCCCC"> Reggie's</font>

101
00:04:33,310 --> 00:04:37,150
<font color="#CCCCCC">in total and they have found that</font><font color="#E5E5E5"> this</font>

102
00:04:35,650 --> 00:04:40,900
<font color="#E5E5E5">is</font><font color="#CCCCCC"> a very efficient way to characterize</font>

103
00:04:37,150 --> 00:04:42,760
social networks<font color="#E5E5E5"> however there is more to</font>

104
00:04:40,900 --> 00:04:45,489
this story<font color="#E5E5E5"> than</font><font color="#CCCCCC"> that because</font><font color="#E5E5E5"> we can</font>

105
00:04:42,760 --> 00:04:48,400
actually<font color="#E5E5E5"> apply the ideas of multiplex</font>

106
00:04:45,490 --> 00:04:50,560
networks<font color="#E5E5E5"> to this clustering coefficient</font>

107
00:04:48,400 --> 00:04:52,479
metric we named<font color="#E5E5E5"> it the type clustering</font>

108
00:04:50,560 --> 00:04:55,000
coefficient metric we have taken this

109
00:04:52,480 --> 00:04:57,610
<font color="#CCCCCC">from a paper that was published five</font>

110
00:04:55,000 --> 00:05:02,260
years ago at the physics journal<font color="#E5E5E5"> and the</font>

111
00:04:57,610 --> 00:05:03,970
idea is actually<font color="#E5E5E5"> pretty simple so we say</font>

112
00:05:02,260 --> 00:05:07,390
that<font color="#E5E5E5"> we</font><font color="#CCCCCC"> are looking for wedgies that</font>

113
00:05:03,970 --> 00:05:10,330
have two<font color="#E5E5E5"> edges of</font><font color="#CCCCCC"> the same type and the</font>

114
00:05:07,390 --> 00:05:14,159
third edge<font color="#E5E5E5"> might be a different type and</font>

115
00:05:10,330 --> 00:05:18,099
if they close to a triangle that third

116
00:05:14,160 --> 00:05:20,140
edge must be<font color="#E5E5E5"> a different type so when we</font>

117
00:05:18,100 --> 00:05:22,480
<font color="#CCCCCC">calculate the TCC metric the type</font>

118
00:05:20,140 --> 00:05:24,760
<font color="#E5E5E5">clustering coefficient we do the ratio</font>

119
00:05:22,480 --> 00:05:29,440
of type triangles<font color="#E5E5E5"> to direct to the</font>

120
00:05:24,760 --> 00:05:32,590
number of type two edges so why is this

121
00:05:29,440 --> 00:05:35,950
<font color="#E5E5E5">useful if we take a look at the example</font>

122
00:05:32,590 --> 00:05:39,039
and we just calculate<font color="#E5E5E5"> the simple</font><font color="#CCCCCC"> SEC</font>

123
00:05:35,950 --> 00:05:42,039
metric<font color="#E5E5E5"> we can see that it's actually 2/3</font>

124
00:05:39,040 --> 00:05:45,220
for all of the<font color="#E5E5E5"> nodes so it doesn't</font>

125
00:05:42,040 --> 00:05:47,080
<font color="#E5E5E5">really tell any insight into</font><font color="#CCCCCC"> the story</font>

126
00:05:45,220 --> 00:05:50,320
<font color="#E5E5E5">or people are equal</font>

127
00:05:47,080 --> 00:05:52,450
according to<font color="#E5E5E5"> this metric however if we</font>

128
00:05:50,320 --> 00:05:55,599
<font color="#CCCCCC">take the type information</font><font color="#E5E5E5"> into account</font>

129
00:05:52,450 --> 00:05:57,880
<font color="#E5E5E5">we can see that some</font><font color="#CCCCCC"> people have more</font>

130
00:05:55,600 --> 00:06:00,190
influence or are more prominent<font color="#CCCCCC"> in</font>

131
00:05:57,880 --> 00:06:04,800
certain<font color="#E5E5E5"> aspects of</font><font color="#CCCCCC"> class turnes and you</font>

132
00:06:00,190 --> 00:06:07,270
can see that<font color="#E5E5E5"> D has you know 0.5 which is</font>

133
00:06:04,800 --> 00:06:09,430
reasonable<font color="#E5E5E5"> value for someone at</font><font color="#CCCCCC"> that</font>

134
00:06:07,270 --> 00:06:11,049
position<font color="#CCCCCC"> and interestingly</font><font color="#E5E5E5"> C has an even</font>

135
00:06:09,430 --> 00:06:15,160
higher value so this<font color="#E5E5E5"> is something</font><font color="#CCCCCC"> that</font>

136
00:06:11,050 --> 00:06:18,400
<font color="#E5E5E5">can help us start with our analysis so</font>

137
00:06:15,160 --> 00:06:21,340
previously back in 2016<font color="#CCCCCC"> I published a</font>

138
00:06:18,400 --> 00:06:24,130
paper with my<font color="#E5E5E5"> advisor and my peers about</font>

139
00:06:21,340 --> 00:06:25,960
the characterization<font color="#CCCCCC"> of engineering</font>

140
00:06:24,130 --> 00:06:28,719
models when I say engineering models

141
00:06:25,960 --> 00:06:31,210
issues really just think think<font color="#E5E5E5"> graphs</font>

142
00:06:28,720 --> 00:06:34,330
<font color="#CCCCCC">that describe</font><font color="#E5E5E5"> a software hardware</font>

143
00:06:31,210 --> 00:06:36,940
component or a building<font color="#E5E5E5"> or something</font>

144
00:06:34,330 --> 00:06:40,120
<font color="#E5E5E5">that has been designed by an engineer</font>

145
00:06:36,940 --> 00:06:42,430
<font color="#CCCCCC">these models are about</font><font color="#E5E5E5"> a hundred</font>

146
00:06:40,120 --> 00:06:45,190
thousand or at most<font color="#E5E5E5"> million nodes and</font>

147
00:06:42,430 --> 00:06:48,220
edges<font color="#E5E5E5"> and back then we implemented</font>

148
00:06:45,190 --> 00:06:50,830
java application that uses<font color="#E5E5E5"> edge sets to</font>

149
00:06:48,220 --> 00:06:53,050
calculate metrics<font color="#E5E5E5"> including the</font><font color="#CCCCCC"> tied</font>

150
00:06:50,830 --> 00:06:56,530
coefficient and the local custom

151
00:06:53,050 --> 00:06:58,660
coefficient and we<font color="#CCCCCC"> were very</font><font color="#E5E5E5"> confident</font>

152
00:06:56,530 --> 00:07:02,169
<font color="#CCCCCC">so</font><font color="#E5E5E5"> we thought we can just ran around</font>

153
00:06:58,660 --> 00:07:04,360
these analyzer components on the

154
00:07:02,170 --> 00:07:06,880
<font color="#E5E5E5">paradise</font><font color="#CCCCCC"> papers dataset and it will work</font>

155
00:07:04,360 --> 00:07:09,330
<font color="#E5E5E5">out</font><font color="#CCCCCC"> of the box</font><font color="#E5E5E5"> and then it turned out</font>

156
00:07:06,880 --> 00:07:11,950
that<font color="#E5E5E5"> it didn't so it actually</font><font color="#CCCCCC"> took</font>

157
00:07:09,330 --> 00:07:14,710
multiple days and<font color="#CCCCCC"> it still didn't finish</font>

158
00:07:11,950 --> 00:07:16,510
<font color="#E5E5E5">the calculations and this got us</font>

159
00:07:14,710 --> 00:07:20,260
<font color="#CCCCCC">thinking what's going</font><font color="#E5E5E5"> on why doesn't it</font>

160
00:07:16,510 --> 00:07:22,060
work<font color="#E5E5E5"> for a data set of the size of the</font>

161
00:07:20,260 --> 00:07:24,880
Paradise Papers data set which isn't

162
00:07:22,060 --> 00:07:27,100
really<font color="#E5E5E5"> big so it turned out that there</font>

163
00:07:24,880 --> 00:07:28,810
<font color="#CCCCCC">are</font><font color="#E5E5E5"> many implementation issues</font><font color="#CCCCCC"> systems</font>

164
00:07:27,100 --> 00:07:30,940
aspects that we<font color="#CCCCCC"> need to get right and</font>

165
00:07:28,810 --> 00:07:35,050
there are also algorithmic aspects that

166
00:07:30,940 --> 00:07:37,420
needs to<font color="#CCCCCC"> be studied so just to take one</font>

167
00:07:35,050 --> 00:07:40,420
<font color="#CCCCCC">step back which part of the graph</font>

168
00:07:37,420 --> 00:07:42,640
processing landscape are we at<font color="#CCCCCC"> I'm going</font>

169
00:07:40,420 --> 00:07:44,800
to use the<font color="#CCCCCC"> terminology of</font>

170
00:07:42,640 --> 00:07:47,530
the linked data<font color="#E5E5E5"> benchmark console</font>

171
00:07:44,800 --> 00:07:49,870
abbreviated as<font color="#E5E5E5"> LD BC which releases</font>

172
00:07:47,530 --> 00:07:52,320
benchmarks for all sorts of<font color="#CCCCCC"> graph</font>

173
00:07:49,870 --> 00:07:56,050
specific workloads<font color="#E5E5E5"> according</font><font color="#CCCCCC"> to them</font>

174
00:07:52,320 --> 00:07:58,990
there is<font color="#E5E5E5"> two axes the amount of data</font>

175
00:07:56,050 --> 00:08:02,140
accessed and the expected<font color="#E5E5E5"> execution time</font>

176
00:07:58,990 --> 00:08:03,790
of a given<font color="#E5E5E5"> query or a given analytical</font>

177
00:08:02,140 --> 00:08:07,780
workload and we start at the bottom

178
00:08:03,790 --> 00:08:10,240
<font color="#E5E5E5">right with OLTP simple reads and simple</font>

179
00:08:07,780 --> 00:08:12,609
lookups<font color="#E5E5E5"> then go up for OLAP queries</font>

180
00:08:10,240 --> 00:08:16,120
which are<font color="#E5E5E5"> more analytical use more</font>

181
00:08:12,610 --> 00:08:19,030
aggregation do global<font color="#E5E5E5"> filtering and</font>

182
00:08:16,120 --> 00:08:22,930
multiple joints<font color="#E5E5E5"> and we are at the</font><font color="#CCCCCC"> top</font>

183
00:08:19,030 --> 00:08:26,679
graph graph<font color="#CCCCCC"> philippics</font><font color="#E5E5E5"> which is a graph</font>

184
00:08:22,930 --> 00:08:28,990
analytical workload that<font color="#CCCCCC"> is sort</font><font color="#E5E5E5"> of the</font>

185
00:08:26,680 --> 00:08:31,320
classical<font color="#E5E5E5"> network science approach for</font>

186
00:08:28,990 --> 00:08:33,880
graph analysis<font color="#E5E5E5"> so if you have studied</font>

187
00:08:31,320 --> 00:08:36,968
<font color="#E5E5E5">graph algorithms you have probably heard</font>

188
00:08:33,880 --> 00:08:39,640
about<font color="#CCCCCC"> PageRank or connected components</font>

189
00:08:36,969 --> 00:08:41,729
or<font color="#CCCCCC"> fortis path algorithms</font><font color="#E5E5E5"> these graph</font>

190
00:08:39,640 --> 00:08:45,819
analytics<font color="#CCCCCC"> do just that</font><font color="#E5E5E5"> so this</font><font color="#CCCCCC"> is</font>

191
00:08:41,729 --> 00:08:47,950
<font color="#E5E5E5">basically a structure only analysis of a</font>

192
00:08:45,820 --> 00:08:50,470
<font color="#CCCCCC">given graph</font><font color="#E5E5E5"> and there are many tools to</font>

193
00:08:47,950 --> 00:08:53,640
do this so you have a<font color="#E5E5E5"> lot</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> bashing</font>

194
00:08:50,470 --> 00:08:56,320
<font color="#E5E5E5">tools like giraffe spark</font><font color="#CCCCCC"> flink jelly</font>

195
00:08:53,640 --> 00:08:59,170
<font color="#CCCCCC">denier for</font><font color="#E5E5E5"> geographic</font><font color="#CCCCCC"> audience library</font>

196
00:08:56,320 --> 00:09:02,150
and so on so this<font color="#E5E5E5"> is pretty well covered</font>

197
00:08:59,170 --> 00:09:04,910
the bottom half is also<font color="#E5E5E5"> pretty recovered</font>

198
00:09:02,150 --> 00:09:07,340
because<font color="#CCCCCC"> if you perform graph theories</font>

199
00:09:04,910 --> 00:09:09,290
<font color="#E5E5E5">that use the structure of the graph the</font>

200
00:09:07,340 --> 00:09:11,450
type of the graph nodes and the

201
00:09:09,290 --> 00:09:13,819
properties of<font color="#E5E5E5"> those nodes you can always</font>

202
00:09:11,450 --> 00:09:15,800
<font color="#E5E5E5">use languages like cipher and sparkle</font>

203
00:09:13,820 --> 00:09:17,110
<font color="#E5E5E5">and there are many tools</font><font color="#CCCCCC"> for these</font>

204
00:09:15,800 --> 00:09:21,079
including neo4j

205
00:09:17,110 --> 00:09:25,340
<font color="#E5E5E5">virtuoso star dog etc but interestingly</font>

206
00:09:21,080 --> 00:09:26,900
our<font color="#E5E5E5"> work fits somewhere in between so</font><font color="#CCCCCC"> it</font>

207
00:09:25,340 --> 00:09:29,180
<font color="#CCCCCC">uses</font><font color="#E5E5E5"> the structure of the graph and</font>

208
00:09:26,900 --> 00:09:31,480
<font color="#E5E5E5">sometimes</font><font color="#CCCCCC"> we type information but it</font>

209
00:09:29,180 --> 00:09:34,069
doesn't use any<font color="#E5E5E5"> of the properties and</font>

210
00:09:31,480 --> 00:09:35,780
it's sort of in between<font color="#E5E5E5"> all these</font>

211
00:09:34,070 --> 00:09:38,420
workloads<font color="#CCCCCC"> and it seems</font><font color="#E5E5E5"> to me that there</font>

212
00:09:35,780 --> 00:09:44,030
are no of the shaft solutions to tackle

213
00:09:38,420 --> 00:09:46,490
<font color="#E5E5E5">these sort of computations if you're</font>

214
00:09:44,030 --> 00:09:49,490
familiar<font color="#CCCCCC"> with the</font><font color="#E5E5E5"> Apache tools you might</font>

215
00:09:46,490 --> 00:09:52,010
think that some<font color="#CCCCCC"> of them might work for</font>

216
00:09:49,490 --> 00:09:55,370
this<font color="#E5E5E5"> and</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is indeed a good question</font>

217
00:09:52,010 --> 00:09:58,850
<font color="#E5E5E5">so there are four popular Apache</font>

218
00:09:55,370 --> 00:10:01,060
frameworks for graph analysis homograph

219
00:09:58,850 --> 00:10:04,510
<font color="#E5E5E5">zero after</font><font color="#CCCCCC"> trance on top of Hadoop</font>

220
00:10:01,060 --> 00:10:07,430
<font color="#CCCCCC">sparks graphics</font><font color="#E5E5E5"> and flings jelly</font>

221
00:10:04,510 --> 00:10:09,110
<font color="#E5E5E5">interestingly though</font><font color="#CCCCCC"> I found that these</font>

222
00:10:07,430 --> 00:10:10,699
libraries are<font color="#E5E5E5"> getting more and</font><font color="#CCCCCC"> more</font>

223
00:10:09,110 --> 00:10:14,120
<font color="#E5E5E5">abandoned so I did a little bit of</font>

224
00:10:10,700 --> 00:10:16,250
<font color="#E5E5E5">analysis and I counted the Comets for</font>

225
00:10:14,120 --> 00:10:19,040
the last two<font color="#E5E5E5"> years and for the two years</font>

226
00:10:16,250 --> 00:10:22,250
<font color="#E5E5E5">before</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> period it turned out that</font>

227
00:10:19,040 --> 00:10:22,910
<font color="#E5E5E5">it's pretty much downward strength so</font>

228
00:10:22,250 --> 00:10:27,050
<font color="#CCCCCC">Homma</font>

229
00:10:22,910 --> 00:10:30,110
essentially is that<font color="#E5E5E5"> technology giraffe</font>

230
00:10:27,050 --> 00:10:32,329
has been abandoned by<font color="#E5E5E5"> most of his</font>

231
00:10:30,110 --> 00:10:35,240
developers graphics is losing<font color="#E5E5E5"> momentum</font>

232
00:10:32,330 --> 00:10:38,270
<font color="#CCCCCC">and the only one that is more or less</font>

233
00:10:35,240 --> 00:10:39,590
active<font color="#E5E5E5"> its flings jelly but overall it's</font>

234
00:10:38,270 --> 00:10:42,410
pretty much downwards trend

235
00:10:39,590 --> 00:10:44,990
unfortunately a couple of<font color="#E5E5E5"> years</font><font color="#CCCCCC"> ago</font>

236
00:10:42,410 --> 00:10:47,300
there was<font color="#E5E5E5"> another technology here which</font>

237
00:10:44,990 --> 00:10:50,150
is<font color="#E5E5E5"> called the arabesque distributed</font>

238
00:10:47,300 --> 00:10:52,640
graph mining framework<font color="#CCCCCC"> according</font><font color="#E5E5E5"> to its</font>

239
00:10:50,150 --> 00:10:57,050
<font color="#CCCCCC">definition it does</font><font color="#E5E5E5"> open source graph</font>

240
00:10:52,640 --> 00:11:00,050
analytics<font color="#E5E5E5"> over</font><font color="#CCCCCC"> the hadoop system and its</font>

241
00:10:57,050 --> 00:11:02,569
frequent sub graph mining is essentially

242
00:11:00,050 --> 00:11:04,250
<font color="#CCCCCC">very similar to our workloads</font><font color="#E5E5E5"> so this</font>

243
00:11:02,570 --> 00:11:07,370
could<font color="#CCCCCC"> have been a</font><font color="#E5E5E5"> very good fit but</font>

244
00:11:04,250 --> 00:11:08,930
<font color="#E5E5E5">unfortunately this</font><font color="#CCCCCC"> is also</font><font color="#E5E5E5"> getting</font>

245
00:11:07,370 --> 00:11:10,940
abandoned so even though there are

246
00:11:08,930 --> 00:11:12,729
<font color="#CCCCCC">papers</font><font color="#E5E5E5"> and repositories and</font>

247
00:11:10,940 --> 00:11:16,510
presentations on<font color="#E5E5E5"> it it</font>

248
00:11:12,730 --> 00:11:18,610
<font color="#E5E5E5">seem to</font><font color="#CCCCCC"> be actively developed and at</font>

249
00:11:16,510 --> 00:11:20,560
this point<font color="#E5E5E5"> we were thinking what hang on</font>

250
00:11:18,610 --> 00:11:23,320
a minute what's so difficult about graph

251
00:11:20,560 --> 00:11:25,630
computations<font color="#E5E5E5"> and a bit of reading</font>

252
00:11:23,320 --> 00:11:27,730
reveals that graph<font color="#E5E5E5"> computation is</font>

253
00:11:25,630 --> 00:11:30,910
<font color="#E5E5E5">inherently a lot more difficult</font><font color="#CCCCCC"> than any</font>

254
00:11:27,730 --> 00:11:33,760
of the<font color="#E5E5E5"> relational queries and relational</font>

255
00:11:30,910 --> 00:11:36,579
analytics that<font color="#E5E5E5"> are performed by these</font>

256
00:11:33,760 --> 00:11:39,639
popular<font color="#E5E5E5"> data processing framework like</font>

257
00:11:36,579 --> 00:11:41,469
spark data frames because graphs suffer

258
00:11:39,639 --> 00:11:43,990
from what's<font color="#E5E5E5"> called the curse of</font>

259
00:11:41,470 --> 00:11:45,790
connectedness<font color="#E5E5E5"> this means that everything</font>

260
00:11:43,990 --> 00:11:47,620
<font color="#CCCCCC">is</font><font color="#E5E5E5"> so densely connected that it's very</font>

261
00:11:45,790 --> 00:11:49,480
<font color="#E5E5E5">difficult to</font><font color="#CCCCCC"> that otherwise</font><font color="#E5E5E5"> the</font>

262
00:11:47,620 --> 00:11:51,880
<font color="#CCCCCC">algorithms very</font><font color="#E5E5E5"> difficult to do</font>

263
00:11:49,480 --> 00:11:54,279
efficient caching and in general<font color="#E5E5E5"> very</font>

264
00:11:51,880 --> 00:11:56,680
difficult to extract a<font color="#CCCCCC"> high</font>

265
00:11:54,279 --> 00:11:58,810
computational value<font color="#E5E5E5"> from the computer</font>

266
00:11:56,680 --> 00:12:01,209
<font color="#CCCCCC">the reason behind might be that</font>

267
00:11:58,810 --> 00:12:03,160
contemporary computer architectures are

268
00:12:01,209 --> 00:12:08,260
more suited towards hierarchical data

269
00:12:03,160 --> 00:12:10,600
<font color="#E5E5E5">think trees lists stacks and this works</font>

270
00:12:08,260 --> 00:12:12,250
<font color="#E5E5E5">pretty well for relational databases but</font>

271
00:12:10,600 --> 00:12:15,279
it's not<font color="#E5E5E5"> very well</font><font color="#CCCCCC"> suited for graph</font>

272
00:12:12,250 --> 00:12:17,920
algorithms one approach<font color="#CCCCCC"> that</font><font color="#E5E5E5"> tries to</font>

273
00:12:15,279 --> 00:12:19,779
<font color="#E5E5E5">overcome this is to define programming</font>

274
00:12:17,920 --> 00:12:23,229
models the vertex centric programming

275
00:12:19,779 --> 00:12:25,300
model or also<font color="#E5E5E5"> known as the think like a</font>

276
00:12:23,230 --> 00:12:28,029
vertex programming model is a popular

277
00:12:25,300 --> 00:12:31,120
approach to try to describe graph

278
00:12:28,029 --> 00:12:33,490
algorithms<font color="#E5E5E5"> in a higher</font><font color="#CCCCCC"> level of</font>

279
00:12:31,120 --> 00:12:36,790
abstraction<font color="#E5E5E5"> and then translate them</font><font color="#CCCCCC"> to</font>

280
00:12:33,490 --> 00:12:38,889
an<font color="#E5E5E5"> underlying engine and the majority of</font>

281
00:12:36,790 --> 00:12:41,949
distributed engines use<font color="#E5E5E5"> this but we were</font>

282
00:12:38,889 --> 00:12:44,380
<font color="#CCCCCC">thinking that for such a small data set</font>

283
00:12:41,949 --> 00:12:47,109
we should be able to<font color="#E5E5E5"> do this on a single</font>

284
00:12:44,380 --> 00:12:51,220
machine with preferably a couple of

285
00:12:47,110 --> 00:12:54,220
lines of code<font color="#CCCCCC"> so we investigated a bit</font>

286
00:12:51,220 --> 00:12:57,100
further<font color="#E5E5E5"> and this is how we encountered</font>

287
00:12:54,220 --> 00:13:00,100
the linear<font color="#CCCCCC"> algebra based definition</font><font color="#E5E5E5"> of</font>

288
00:12:57,100 --> 00:13:04,420
graph computations<font color="#E5E5E5"> so the idea I think</font>

289
00:13:00,100 --> 00:13:08,380
is well known to<font color="#E5E5E5"> most of you here if you</font>

290
00:13:04,420 --> 00:13:11,439
have a graph you can<font color="#E5E5E5"> trivially transform</font>

291
00:13:08,380 --> 00:13:14,139
it<font color="#CCCCCC"> to an adjacency matrix between two</font>

292
00:13:11,440 --> 00:13:17,500
edges so you<font color="#E5E5E5"> take a</font><font color="#CCCCCC"> matrix that the</font>

293
00:13:14,139 --> 00:13:20,890
square matrix<font color="#E5E5E5"> of n where n is the</font><font color="#CCCCCC"> number</font>

294
00:13:17,500 --> 00:13:23,410
<font color="#CCCCCC">of nodes</font><font color="#E5E5E5"> and if there is an edge</font><font color="#CCCCCC"> between</font>

295
00:13:20,890 --> 00:13:26,140
two nodes<font color="#CCCCCC"> you put a 1 in that</font><font color="#E5E5E5"> cell and</font>

296
00:13:23,410 --> 00:13:26,380
<font color="#E5E5E5">if there isn't an edge you</font><font color="#CCCCCC"> put a</font><font color="#E5E5E5"> 0 so</font>

297
00:13:26,140 --> 00:13:29,050
this

298
00:13:26,380 --> 00:13:32,710
the trivial idea and it's also<font color="#E5E5E5"> very</font>

299
00:13:29,050 --> 00:13:34,660
simple<font color="#CCCCCC"> to adapt this to time</font><font color="#E5E5E5"> meters</font>

300
00:13:32,710 --> 00:13:37,840
typed graphs<font color="#E5E5E5"> because you only have to</font>

301
00:13:34,660 --> 00:13:41,589
slice the matrix and get sub matrices

302
00:13:37,840 --> 00:13:43,810
for each edge type the key idea here<font color="#CCCCCC"> is</font>

303
00:13:41,590 --> 00:13:47,110
<font color="#E5E5E5">that if you</font><font color="#CCCCCC"> take a matrix such as this</font>

304
00:13:43,810 --> 00:13:50,589
you can<font color="#CCCCCC"> do</font><font color="#E5E5E5"> matrix multiplications and</font>

305
00:13:47,110 --> 00:13:52,360
those will enumerate<font color="#E5E5E5"> the various length</font>

306
00:13:50,590 --> 00:13:53,980
<font color="#E5E5E5">paths so if you do one matrix</font>

307
00:13:52,360 --> 00:13:56,230
multiplication you will get the<font color="#E5E5E5"> two</font><font color="#CCCCCC"> hope</font>

308
00:13:53,980 --> 00:13:58,800
<font color="#CCCCCC">paths if you do two multiplications you</font>

309
00:13:56,230 --> 00:14:00,610
will get the<font color="#CCCCCC"> three hope paths and so on</font>

310
00:13:58,800 --> 00:14:01,540
so this<font color="#E5E5E5"> is one</font><font color="#CCCCCC"> of the first</font>

311
00:14:00,610 --> 00:14:05,200
optimizations

312
00:14:01,540 --> 00:14:07,750
<font color="#E5E5E5">that's realized we try to adapt this to</font>

313
00:14:05,200 --> 00:14:10,240
<font color="#E5E5E5">the untyped case which turned out</font><font color="#CCCCCC"> to be</font>

314
00:14:07,750 --> 00:14:13,590
fairly<font color="#E5E5E5"> simple we just took a times a</font>

315
00:14:10,240 --> 00:14:16,660
times a took the diagonal elements of

316
00:14:13,590 --> 00:14:19,930
the third matrix because essentially if

317
00:14:16,660 --> 00:14:21,850
you<font color="#CCCCCC"> have three hop paths</font><font color="#E5E5E5"> that close</font><font color="#CCCCCC"> into</font>

318
00:14:19,930 --> 00:14:24,699
their beginning node you<font color="#E5E5E5"> have a triangle</font>

319
00:14:21,850 --> 00:14:27,280
so this is how we enumerated the

320
00:14:24,700 --> 00:14:29,680
triangles<font color="#E5E5E5"> and it turned out to be fairly</font>

321
00:14:27,280 --> 00:14:31,750
<font color="#E5E5E5">straightforward</font><font color="#CCCCCC"> to adapt</font><font color="#E5E5E5"> this idea to</font>

322
00:14:29,680 --> 00:14:34,329
<font color="#E5E5E5">the</font><font color="#CCCCCC"> type case</font><font color="#E5E5E5"> so we just did</font><font color="#CCCCCC"> a</font>

323
00:14:31,750 --> 00:14:37,240
multiplication<font color="#E5E5E5"> between one</font><font color="#CCCCCC"> title and the</font>

324
00:14:34,330 --> 00:14:40,510
<font color="#E5E5E5">other and the first type again took the</font>

325
00:14:37,240 --> 00:14:43,000
diagonal elements and we got the number

326
00:14:40,510 --> 00:14:46,090
of<font color="#E5E5E5"> triangles</font><font color="#CCCCCC"> in each node the number of</font>

327
00:14:43,000 --> 00:14:50,140
edges part is easy<font color="#CCCCCC"> so this took</font><font color="#E5E5E5"> care of</font>

328
00:14:46,090 --> 00:14:52,990
the more<font color="#CCCCCC"> difficult part unfortunately it</font>

329
00:14:50,140 --> 00:14:55,060
isn't that<font color="#E5E5E5"> easy because it turns out</font>

330
00:14:52,990 --> 00:14:58,090
<font color="#E5E5E5">that matrices get very dense so if you</font>

331
00:14:55,060 --> 00:15:01,209
start listing<font color="#E5E5E5"> numerating all the paths</font>

332
00:14:58,090 --> 00:15:04,000
in<font color="#CCCCCC"> a matrix it gets</font><font color="#E5E5E5"> very dense very</font><font color="#CCCCCC"> soon</font>

333
00:15:01,210 --> 00:15:09,000
<font color="#E5E5E5">so one of the trivial optimizations that</font>

334
00:15:04,000 --> 00:15:12,340
we could apply is to<font color="#E5E5E5"> stop when at</font>

335
00:15:09,000 --> 00:15:14,470
enumerated<font color="#CCCCCC"> to</font><font color="#E5E5E5"> length cost and then try</font>

336
00:15:12,340 --> 00:15:17,350
to close them into a triangle<font color="#E5E5E5"> without</font>

337
00:15:14,470 --> 00:15:19,990
actually enumerated all of the three

338
00:15:17,350 --> 00:15:22,870
<font color="#E5E5E5">lengths pass in the matrix so the idea</font>

339
00:15:19,990 --> 00:15:26,890
here<font color="#CCCCCC"> is that</font><font color="#E5E5E5"> instead of just doing a</font>

340
00:15:22,870 --> 00:15:29,890
times a we used a times a<font color="#E5E5E5"> element wise</font>

341
00:15:26,890 --> 00:15:33,340
<font color="#E5E5E5">multiplication</font><font color="#CCCCCC"> a and then we summed the</font>

342
00:15:29,890 --> 00:15:35,939
rows<font color="#E5E5E5"> this can be actually adapted with a</font>

343
00:15:33,340 --> 00:15:39,880
bit<font color="#CCCCCC"> of tinkering</font><font color="#E5E5E5"> to the</font><font color="#CCCCCC"> typed case and</font>

344
00:15:35,940 --> 00:15:41,620
this turns out<font color="#E5E5E5"> to</font><font color="#CCCCCC"> be still</font><font color="#E5E5E5"> much</font>

345
00:15:39,880 --> 00:15:45,009
<font color="#E5E5E5">a challenge because for the typed case</font>

346
00:15:41,620 --> 00:15:49,540
we<font color="#CCCCCC"> had to calculate these expressions</font>

347
00:15:45,009 --> 00:15:52,089
<font color="#E5E5E5">for</font><font color="#CCCCCC"> all tied pairs I had master students</font>

348
00:15:49,540 --> 00:15:55,029
<font color="#E5E5E5">who worked on this</font><font color="#CCCCCC"> during</font><font color="#E5E5E5"> last year and</font>

349
00:15:52,089 --> 00:15:56,860
in her master's thesis<font color="#CCCCCC"> we have a</font>

350
00:15:55,029 --> 00:16:01,149
<font color="#E5E5E5">detailed description of</font><font color="#CCCCCC"> all the</font>

351
00:15:56,860 --> 00:16:03,759
derivation rules and we define these<font color="#E5E5E5"> two</font>

352
00:16:01,149 --> 00:16:05,589
optimization steps the first<font color="#E5E5E5"> is the</font>

353
00:16:03,759 --> 00:16:07,990
element wise<font color="#E5E5E5"> multiplication and the</font>

354
00:16:05,589 --> 00:16:10,300
second one is the notion that even

355
00:16:07,990 --> 00:16:13,240
<font color="#E5E5E5">though we have to do a quadratic number</font>

356
00:16:10,300 --> 00:16:15,310
<font color="#CCCCCC">of matrix multiplications</font><font color="#E5E5E5"> this is an</font>

357
00:16:13,240 --> 00:16:18,699
embarrassingly parallel<font color="#E5E5E5"> problem because</font>

358
00:16:15,310 --> 00:16:21,040
we<font color="#E5E5E5"> can</font><font color="#CCCCCC"> just run these</font><font color="#E5E5E5"> on a different CPU</font>

359
00:16:18,699 --> 00:16:23,859
<font color="#CCCCCC">course</font><font color="#E5E5E5"> and there is no need to</font><font color="#CCCCCC"> use</font><font color="#E5E5E5"> a</font>

360
00:16:21,040 --> 00:16:28,149
shared and mutable representation so

361
00:16:23,860 --> 00:16:31,630
this is pretty easy<font color="#CCCCCC"> to parallelize</font><font color="#E5E5E5"> in</font>

362
00:16:28,149 --> 00:16:35,019
practice it's quite straightforward<font color="#CCCCCC"> to</font>

363
00:16:31,630 --> 00:16:38,620
sort of represent<font color="#E5E5E5"> we do</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> times a</font>

364
00:16:35,019 --> 00:16:41,740
<font color="#E5E5E5">element wise multiplication by the</font><font color="#CCCCCC"> other</font>

365
00:16:38,620 --> 00:16:44,500
matrix and now<font color="#CCCCCC"> it's pretty</font><font color="#E5E5E5"> easy to see</font>

366
00:16:41,740 --> 00:16:47,139
<font color="#CCCCCC">that this is more sparse matrix there</font>

367
00:16:44,500 --> 00:16:49,509
are only a<font color="#E5E5E5"> few nonzero elements in this</font>

368
00:16:47,139 --> 00:16:52,209
matrix<font color="#E5E5E5"> and then</font><font color="#CCCCCC"> we multiply it with</font><font color="#E5E5E5"> a</font>

369
00:16:49,509 --> 00:16:54,790
vector of ones which is shorthand for

370
00:16:52,209 --> 00:16:57,219
doing the row wise summarization of<font color="#E5E5E5"> the</font>

371
00:16:54,790 --> 00:17:00,880
matrix<font color="#E5E5E5"> and then we're done</font><font color="#CCCCCC"> with it</font><font color="#E5E5E5"> so</font>

372
00:16:57,220 --> 00:17:02,589
this much for the<font color="#CCCCCC"> theory part we don't</font>

373
00:17:00,880 --> 00:17:05,020
thought that implementing this<font color="#CCCCCC"> in jail</font>

374
00:17:02,589 --> 00:17:08,949
will be trivial we just go online grab

375
00:17:05,020 --> 00:17:11,379
one of<font color="#E5E5E5"> the Java libraries and it will</font>

376
00:17:08,949 --> 00:17:13,809
implement it in a few hours<font color="#CCCCCC"> it turned</font>

377
00:17:11,380 --> 00:17:16,600
out that<font color="#E5E5E5"> it's not</font><font color="#CCCCCC"> that simple because</font>

378
00:17:13,809 --> 00:17:18,760
most Java libraries are geared towards

379
00:17:16,599 --> 00:17:21,549
dense matrices and dense linear algebra

380
00:17:18,760 --> 00:17:24,760
<font color="#E5E5E5">and very few actually support sparse</font>

381
00:17:21,549 --> 00:17:27,730
matrices so I went on the software

382
00:17:24,760 --> 00:17:29,679
recommendations<font color="#CCCCCC"> stack exchange</font><font color="#E5E5E5"> and this</font>

383
00:17:27,730 --> 00:17:32,080
<font color="#E5E5E5">is my question that started</font><font color="#CCCCCC"> its life in</font>

384
00:17:29,679 --> 00:17:34,539
early<font color="#E5E5E5"> August and then it got a number of</font>

385
00:17:32,080 --> 00:17:37,960
edits<font color="#E5E5E5"> some upvotes</font><font color="#CCCCCC"> and that I ended</font>

386
00:17:34,539 --> 00:17:40,539
answering it<font color="#CCCCCC"> for myself and basically</font>

387
00:17:37,960 --> 00:17:44,500
the<font color="#CCCCCC"> answer is that the only Java library</font>

388
00:17:40,539 --> 00:17:48,490
that can be used for sparse linear

389
00:17:44,500 --> 00:17:50,440
algebra<font color="#E5E5E5"> is called</font><font color="#CCCCCC"> EJ</font><font color="#E5E5E5"> ml which is an apt</font>

390
00:17:48,490 --> 00:17:53,140
name because it's the efficient<font color="#E5E5E5"> Jo</font>

391
00:17:50,440 --> 00:17:53,710
<font color="#E5E5E5">matrix library this is still actively</font>

392
00:17:53,140 --> 00:17:57,550
maintained

393
00:17:53,710 --> 00:18:00,580
and we found that this<font color="#CCCCCC"> is</font><font color="#E5E5E5"> the one that</font>

394
00:17:57,550 --> 00:18:04,470
can actually<font color="#E5E5E5"> do the computations for our</font>

395
00:18:00,580 --> 00:18:06,580
our relatively slow<font color="#CCCCCC"> 2 million node graph</font>

396
00:18:04,470 --> 00:18:09,850
these<font color="#E5E5E5"> are some of</font><font color="#CCCCCC"> the benchmark results</font>

397
00:18:06,580 --> 00:18:13,570
<font color="#CCCCCC">that we have obtained the red one is our</font>

398
00:18:09,850 --> 00:18:16,030
original<font color="#E5E5E5"> edge list representation</font><font color="#CCCCCC"> as you</font>

399
00:18:13,570 --> 00:18:19,270
can see it starts<font color="#E5E5E5"> promising for smaller</font>

400
00:18:16,030 --> 00:18:22,300
scale<font color="#CCCCCC"> these</font><font color="#E5E5E5"> are samples of the Paradise</font>

401
00:18:19,270 --> 00:18:25,270
Papers<font color="#CCCCCC"> data sets we scaled</font><font color="#E5E5E5"> it down to</font>

402
00:18:22,300 --> 00:18:28,270
<font color="#CCCCCC">five thousand ten thousand nodes and so</font>

403
00:18:25,270 --> 00:18:30,970
on and for<font color="#E5E5E5"> the small scale</font><font color="#CCCCCC"> it was all</font>

404
00:18:28,270 --> 00:18:34,300
fine<font color="#E5E5E5"> but if we started to go a bit</font>

405
00:18:30,970 --> 00:18:37,390
<font color="#E5E5E5">larger than</font><font color="#CCCCCC"> all those</font><font color="#E5E5E5"> kept breaking with</font>

406
00:18:34,300 --> 00:18:40,570
<font color="#CCCCCC">the exception of EJ</font><font color="#E5E5E5"> ml so this was the</font>

407
00:18:37,390 --> 00:18:43,330
<font color="#CCCCCC">only one that worked for the whole 2</font>

408
00:18:40,570 --> 00:18:46,000
million node<font color="#CCCCCC"> paradox papers data set</font><font color="#E5E5E5"> and</font>

409
00:18:43,330 --> 00:18:48,220
it<font color="#CCCCCC"> actually provided decent performance</font>

410
00:18:46,000 --> 00:18:51,130
so it was less<font color="#CCCCCC"> than a minute to load and</font>

411
00:18:48,220 --> 00:18:53,950
calculate these type clustering

412
00:18:51,130 --> 00:18:57,010
coefficients<font color="#E5E5E5"> now remember this</font><font color="#CCCCCC"> was a</font>

413
00:18:53,950 --> 00:18:59,230
calculation<font color="#E5E5E5"> that didn't complete in</font>

414
00:18:57,010 --> 00:19:02,470
multiple days<font color="#E5E5E5"> when we started this work</font>

415
00:18:59,230 --> 00:19:05,910
so this was<font color="#CCCCCC"> actually four or five</font><font color="#E5E5E5"> orders</font>

416
00:19:02,470 --> 00:19:08,770
of magnitudes<font color="#CCCCCC"> an important improvement</font>

417
00:19:05,910 --> 00:19:12,070
<font color="#CCCCCC">we have released the</font><font color="#E5E5E5"> so called graph</font>

418
00:19:08,770 --> 00:19:13,990
analyzer library which is our linear

419
00:19:12,070 --> 00:19:16,720
<font color="#CCCCCC">algebra based implementations of</font><font color="#E5E5E5"> a</font>

420
00:19:13,990 --> 00:19:18,790
number of<font color="#E5E5E5"> multiplexed graph metrics it</font>

421
00:19:16,720 --> 00:19:21,310
uses<font color="#E5E5E5"> EJ ml with a compressed</font>

422
00:19:18,790 --> 00:19:22,110
representation for storing<font color="#CCCCCC"> the sparse</font>

423
00:19:21,310 --> 00:19:24,639
matrices

424
00:19:22,110 --> 00:19:26,229
unfortunately<font color="#E5E5E5"> it's single threaded for</font>

425
00:19:24,640 --> 00:19:29,320
most metrics but it uses some

426
00:19:26,230 --> 00:19:32,800
parallelism<font color="#CCCCCC"> if there are multiple types</font>

427
00:19:29,320 --> 00:19:34,960
<font color="#E5E5E5">and you can just plug it in</font><font color="#CCCCCC"> and it can</font>

428
00:19:32,800 --> 00:19:37,240
work on top of an ear for<font color="#CCCCCC"> J instance or</font>

429
00:19:34,960 --> 00:19:38,740
it can work on top of the<font color="#E5E5E5"> Eclipse</font>

430
00:19:37,240 --> 00:19:41,470
<font color="#E5E5E5">modeling framework that defines</font>

431
00:19:38,740 --> 00:19:44,890
engineering models and it also works for

432
00:19:41,470 --> 00:19:47,080
regular CSV files<font color="#CCCCCC"> the unique</font><font color="#E5E5E5"> feature of</font>

433
00:19:44,890 --> 00:19:50,110
this library is<font color="#E5E5E5"> not its performance but</font>

434
00:19:47,080 --> 00:19:53,620
<font color="#E5E5E5">that it's that</font><font color="#CCCCCC"> it's support for a number</font>

435
00:19:50,110 --> 00:19:55,570
<font color="#CCCCCC">of</font><font color="#E5E5E5"> multiplex graph metrics</font><font color="#CCCCCC"> there are</font>

436
00:19:53,620 --> 00:19:58,389
metrics<font color="#E5E5E5"> that are defined for certain</font>

437
00:19:55,570 --> 00:20:01,060
nodes for certain types node pairs no

438
00:19:58,390 --> 00:20:05,590
diapers<font color="#E5E5E5"> type pairs and</font><font color="#CCCCCC"> so on so this is</font>

439
00:20:01,060 --> 00:20:07,149
quite<font color="#E5E5E5"> good coverage of metrics that we</font>

440
00:20:05,590 --> 00:20:10,478
could get<font color="#CCCCCC"> from the last</font>

441
00:20:07,149 --> 00:20:16,268
ten years of literature in network

442
00:20:10,479 --> 00:20:17,440
science<font color="#E5E5E5"> okay so obviously</font><font color="#CCCCCC"> we had</font>

443
00:20:16,269 --> 00:20:21,729
troubles<font color="#CCCCCC"> with the</font><font color="#E5E5E5"> Java implementation</font>

444
00:20:17,440 --> 00:20:24,639
<font color="#CCCCCC">and why</font><font color="#E5E5E5"> looking for the library that</font>

445
00:20:21,729 --> 00:20:27,759
could<font color="#E5E5E5"> work</font><font color="#CCCCCC"> in Java for sparse matrices</font>

446
00:20:24,639 --> 00:20:28,330
we stumbled upon a new language<font color="#E5E5E5"> called</font>

447
00:20:27,759 --> 00:20:31,059
<font color="#E5E5E5">Julia</font>

448
00:20:28,330 --> 00:20:35,349
so this is actually<font color="#E5E5E5"> a very recent</font>

449
00:20:31,059 --> 00:20:37,830
<font color="#E5E5E5">development</font><font color="#CCCCCC"> the sort of version</font><font color="#E5E5E5"> 1.0</font>

450
00:20:35,349 --> 00:20:42,609
stable was released<font color="#E5E5E5"> last August and</font>

451
00:20:37,830 --> 00:20:44,859
version 1.1 is just out this year the

452
00:20:42,609 --> 00:20:47,728
idea<font color="#CCCCCC"> of</font><font color="#E5E5E5"> Julia is to solve the two</font>

453
00:20:44,859 --> 00:20:49,599
language problems so traditionally in

454
00:20:47,729 --> 00:20:52,269
<font color="#CCCCCC">high-performance computing people</font>

455
00:20:49,599 --> 00:20:54,759
started implementing algorithms<font color="#E5E5E5"> in a</font>

456
00:20:52,269 --> 00:20:56,830
<font color="#CCCCCC">productivity language like Python or</font><font color="#E5E5E5"> R</font>

457
00:20:54,759 --> 00:21:00,249
and then once they get the algorithm

458
00:20:56,830 --> 00:21:03,279
<font color="#E5E5E5">right they rewrote it in C or</font><font color="#CCCCCC"> C++ or</font>

459
00:21:00,249 --> 00:21:06,759
some<font color="#E5E5E5"> low-level code and the promise of</font>

460
00:21:03,279 --> 00:21:09,070
<font color="#E5E5E5">Julia is to be a single language that</font>

461
00:21:06,759 --> 00:21:11,830
<font color="#E5E5E5">provides both high performance and</font><font color="#CCCCCC"> a</font>

462
00:21:09,070 --> 00:21:14,408
high<font color="#E5E5E5"> level of abstraction</font><font color="#CCCCCC"> and it's</font><font color="#E5E5E5"> also</font>

463
00:21:11,830 --> 00:21:17,499
dynamic language so it's sort<font color="#E5E5E5"> of similar</font>

464
00:21:14,409 --> 00:21:19,899
to<font color="#CCCCCC"> MATLAB or even Fortran ask if you if</font>

465
00:21:17,499 --> 00:21:23,739
you have used those sorts of languages

466
00:21:19,899 --> 00:21:26,799
<font color="#E5E5E5">and we managed to the</font><font color="#CCCCCC"> right</font>

467
00:21:23,739 --> 00:21:28,450
<font color="#CCCCCC">implementation for our CCC problem in a</font>

468
00:21:26,799 --> 00:21:31,869
few days which included learning the

469
00:21:28,450 --> 00:21:35,529
<font color="#CCCCCC">Julia language and all</font><font color="#E5E5E5"> its scaffoldings</font>

470
00:21:31,869 --> 00:21:38,769
<font color="#CCCCCC">and it was actually</font><font color="#E5E5E5"> 25 lines in total</font>

471
00:21:35,529 --> 00:21:40,989
<font color="#CCCCCC">and it's</font><font color="#E5E5E5"> pretty easy to comprehend and</font>

472
00:21:38,769 --> 00:21:43,719
easy to update<font color="#CCCCCC"> so this is</font><font color="#E5E5E5"> something</font><font color="#CCCCCC"> that</font>

473
00:21:40,989 --> 00:21:48,549
we<font color="#E5E5E5"> found really interesting we could</font>

474
00:21:43,719 --> 00:21:52,749
just rewrite in<font color="#E5E5E5"> MATLAB</font><font color="#CCCCCC"> slash octave</font>

475
00:21:48,549 --> 00:21:54,219
syntax the code and<font color="#CCCCCC"> its performance</font><font color="#E5E5E5"> was</font>

476
00:21:52,749 --> 00:21:56,739
comparable to<font color="#CCCCCC"> the best Java</font>

477
00:21:54,219 --> 00:21:59,889
implementations but it was easier to

478
00:21:56,739 --> 00:22:03,399
<font color="#E5E5E5">read</font><font color="#CCCCCC"> easier to write and probably easier</font>

479
00:21:59,889 --> 00:22:05,978
to<font color="#E5E5E5"> extend</font><font color="#CCCCCC"> okay and the third</font>

480
00:22:03,399 --> 00:22:08,080
implementation<font color="#E5E5E5"> is something called graph</font>

481
00:22:05,979 --> 00:22:10,779
<font color="#E5E5E5">class now graph less isn't actually an</font>

482
00:22:08,080 --> 00:22:12,728
implementation graph<font color="#CCCCCC"> Blas is an effort</font>

483
00:22:10,779 --> 00:22:14,679
to define standard building blocks for

484
00:22:12,729 --> 00:22:17,559
graph algorithms in the language of

485
00:22:14,679 --> 00:22:20,289
linear algebra<font color="#CCCCCC"> so the idea comes from</font>

486
00:22:17,559 --> 00:22:20,889
<font color="#E5E5E5">the blast system which is about 40 years</font>

487
00:22:20,289 --> 00:22:23,200
old

488
00:22:20,890 --> 00:22:25,840
and it's the abbreviation of basic

489
00:22:23,200 --> 00:22:28,050
linear<font color="#CCCCCC"> algebra subprograms the idea</font>

490
00:22:25,840 --> 00:22:30,850
there<font color="#E5E5E5"> was</font><font color="#CCCCCC"> that we have a lot of</font>

491
00:22:28,050 --> 00:22:34,419
different hardware<font color="#E5E5E5"> and</font><font color="#CCCCCC"> blast</font>

492
00:22:30,850 --> 00:22:36,370
<font color="#CCCCCC">ax bone</font><font color="#E5E5E5"> like an interface between those</font>

493
00:22:34,420 --> 00:22:41,230
<font color="#E5E5E5">Hardware components and the system</font>

494
00:22:36,370 --> 00:22:43,179
components<font color="#CCCCCC"> so it acts as a separation</font><font color="#E5E5E5"> of</font>

495
00:22:41,230 --> 00:22:45,520
concerns<font color="#E5E5E5"> between the numerical</font>

496
00:22:43,180 --> 00:22:47,680
<font color="#E5E5E5">applications that need to do some heavy</font>

497
00:22:45,520 --> 00:22:49,420
<font color="#CCCCCC">number crunching and the hardware that</font>

498
00:22:47,680 --> 00:22:52,410
will<font color="#E5E5E5"> perform the evaluation</font><font color="#CCCCCC"> and</font>

499
00:22:49,420 --> 00:22:55,240
basically graph<font color="#CCCCCC"> class is the same idea</font>

500
00:22:52,410 --> 00:22:57,940
<font color="#E5E5E5">rehashed for graphs so we have graph</font>

501
00:22:55,240 --> 00:23:00,340
analytical applications those implement

502
00:22:57,940 --> 00:23:03,160
graph algorithms that use this common

503
00:23:00,340 --> 00:23:05,919
API<font color="#E5E5E5"> and you</font><font color="#CCCCCC"> can have all the hardware</font>

504
00:23:03,160 --> 00:23:09,910
vendors<font color="#E5E5E5"> try to</font><font color="#CCCCCC"> optimize their stuff to</font>

505
00:23:05,920 --> 00:23:12,580
suit this API<font color="#E5E5E5"> as good as far as well as</font>

506
00:23:09,910 --> 00:23:17,350
well as possible<font color="#E5E5E5"> and you know think of</font>

507
00:23:12,580 --> 00:23:21,610
things have<font color="#CCCCCC"> changed since 1979</font><font color="#E5E5E5"> so now we</font>

508
00:23:17,350 --> 00:23:24,270
have various Xeon Phi's we have GPUs we

509
00:23:21,610 --> 00:23:27,729
have<font color="#E5E5E5"> FPGAs so this is a very interesting</font>

510
00:23:24,270 --> 00:23:30,070
<font color="#E5E5E5">initiative to try to reconcile old all</font>

511
00:23:27,730 --> 00:23:34,770
those heterogeneous<font color="#E5E5E5"> hardware components</font>

512
00:23:30,070 --> 00:23:39,300
under a single API<font color="#E5E5E5"> and then use those to</font>

513
00:23:34,770 --> 00:23:42,690
<font color="#E5E5E5">perform high-performance graph analytics</font>

514
00:23:39,300 --> 00:23:48,129
<font color="#E5E5E5">one of the key ideas of craft</font>

515
00:23:42,690 --> 00:23:50,650
<font color="#E5E5E5">to extend the notion of a semi ring so</font>

516
00:23:48,130 --> 00:23:54,550
it has been observed<font color="#CCCCCC"> that if you take a</font>

517
00:23:50,650 --> 00:23:57,100
semi ring with a multiplication<font color="#E5E5E5"> and an</font>

518
00:23:54,550 --> 00:24:00,280
addition operation<font color="#E5E5E5"> and you redefine</font>

519
00:23:57,100 --> 00:24:02,020
<font color="#E5E5E5">those operations it's very easy to</font>

520
00:24:00,280 --> 00:24:04,720
capture<font color="#E5E5E5"> a couple</font><font color="#CCCCCC"> of graph algorithms</font>

521
00:24:02,020 --> 00:24:07,170
<font color="#CCCCCC">this</font><font color="#E5E5E5"> is actually another old idea so it</font>

522
00:24:04,720 --> 00:24:10,720
has been<font color="#E5E5E5"> described by</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> a hope</font>

523
00:24:07,170 --> 00:24:13,210
hopcroft-ullman book from 1974 and it

524
00:24:10,720 --> 00:24:14,950
was<font color="#CCCCCC"> also described in the algorithm</font>

525
00:24:13,210 --> 00:24:17,640
<font color="#E5E5E5">books that most of you have</font><font color="#CCCCCC"> probably</font>

526
00:24:14,950 --> 00:24:20,380
read in the introduction to algorithms

527
00:24:17,640 --> 00:24:22,480
<font color="#CCCCCC">CLR book interestingly it's only in the</font>

528
00:24:20,380 --> 00:24:24,490
<font color="#E5E5E5">first edition because they decided</font><font color="#CCCCCC"> to</font>

529
00:24:22,480 --> 00:24:26,830
remove it but the<font color="#E5E5E5"> idea</font><font color="#CCCCCC"> is very</font><font color="#E5E5E5"> simple</font>

530
00:24:24,490 --> 00:24:31,960
<font color="#CCCCCC">the idea is that</font><font color="#E5E5E5"> we take adjacency</font>

531
00:24:26,830 --> 00:24:34,030
matrices and<font color="#E5E5E5"> we redefine these operators</font>

532
00:24:31,960 --> 00:24:34,330
over<font color="#E5E5E5"> the semi ring and it turns out that</font>

533
00:24:34,030 --> 00:24:38,918
<font color="#E5E5E5">it's</font>

534
00:24:34,330 --> 00:24:42,760
very easy<font color="#E5E5E5"> to translate one algorithm</font>

535
00:24:38,919 --> 00:24:44,590
<font color="#CCCCCC">from each family of algorithms to this</font>

536
00:24:42,760 --> 00:24:48,158
sort of<font color="#E5E5E5"> notion so if you think like</font>

537
00:24:44,590 --> 00:24:50,559
<font color="#CCCCCC">floyd-warshall algorithm</font><font color="#E5E5E5"> that some here</font>

538
00:24:48,159 --> 00:24:52,750
somewhere<font color="#E5E5E5"> here along these lines or if</font>

539
00:24:50,559 --> 00:24:56,139
you<font color="#E5E5E5"> think of single source shortest</font>

540
00:24:52,750 --> 00:24:58,480
paths or BFS<font color="#CCCCCC"> dolezal can be adapted to</font>

541
00:24:56,140 --> 00:25:00,549
<font color="#CCCCCC">this notion the problem is that even</font>

542
00:24:58,480 --> 00:25:04,360
<font color="#E5E5E5">though the idea is old</font><font color="#CCCCCC"> very few</font>

543
00:25:00,549 --> 00:25:06,879
libraries<font color="#CCCCCC"> support this</font><font color="#E5E5E5"> so there is no</font>

544
00:25:04,360 --> 00:25:09,370
<font color="#E5E5E5">library in Java</font><font color="#CCCCCC"> the time are very off</font>

545
00:25:06,880 --> 00:25:11,889
that actually allows the users to

546
00:25:09,370 --> 00:25:14,949
redefine these operators<font color="#E5E5E5"> and even in</font>

547
00:25:11,889 --> 00:25:17,678
<font color="#E5E5E5">other languages C or C++</font><font color="#CCCCCC"> if you just</font>

548
00:25:14,950 --> 00:25:20,350
take a blast<font color="#E5E5E5"> implementation it will not</font>

549
00:25:17,679 --> 00:25:24,039
<font color="#E5E5E5">support this idea and it will only work</font>

550
00:25:20,350 --> 00:25:27,250
<font color="#CCCCCC">for real numbers sort of classical</font>

551
00:25:24,039 --> 00:25:31,840
semi-ring that won't cut it

552
00:25:27,250 --> 00:25:33,309
for paths and traversals if you're

553
00:25:31,840 --> 00:25:35,980
looking for<font color="#CCCCCC"> implementer station that</font>

554
00:25:33,309 --> 00:25:40,149
does<font color="#E5E5E5"> work there is a suit called suit</font>

555
00:25:35,980 --> 00:25:43,120
sparse graph<font color="#CCCCCC"> blas this offers</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> C</font><font color="#E5E5E5"> API</font>

556
00:25:40,149 --> 00:25:46,239
<font color="#CCCCCC">and a single threaded implementation</font><font color="#E5E5E5"> it</font>

557
00:25:43,120 --> 00:25:49,330
was developed by<font color="#E5E5E5"> Timothy Davis in Texas</font>

558
00:25:46,240 --> 00:25:51,610
<font color="#E5E5E5">and it was used in the radius graph</font>

559
00:25:49,330 --> 00:25:54,699
<font color="#CCCCCC">system so this</font><font color="#E5E5E5"> is actually the</font>

560
00:25:51,610 --> 00:25:56,918
implementation<font color="#CCCCCC"> that</font><font color="#E5E5E5"> underlines the</font><font color="#CCCCCC"> Redis</font>

561
00:25:54,700 --> 00:25:59,350
graph system the trouble with this is is

562
00:25:56,919 --> 00:26:01,750
that<font color="#CCCCCC"> even though it's very</font><font color="#E5E5E5"> well designed</font>

563
00:25:59,350 --> 00:26:05,250
and<font color="#E5E5E5"> it has deep theoretical roots</font>

564
00:26:01,750 --> 00:26:08,380
it has a rather steep<font color="#E5E5E5"> learning curve so</font>

565
00:26:05,250 --> 00:26:12,539
as of today<font color="#E5E5E5"> I cannot show you any</font>

566
00:26:08,380 --> 00:26:15,549
benchmark results that are reasonably

567
00:26:12,539 --> 00:26:17,379
<font color="#E5E5E5">well written and reasonably well</font>

568
00:26:15,549 --> 00:26:20,408
benchmarked<font color="#E5E5E5"> we will</font><font color="#CCCCCC"> publish those</font>

569
00:26:17,380 --> 00:26:25,870
results<font color="#CCCCCC"> once we get the results correct</font>

570
00:26:20,409 --> 00:26:27,519
<font color="#CCCCCC">and get a</font><font color="#E5E5E5"> few runs</font><font color="#CCCCCC"> ok so even</font><font color="#E5E5E5"> though I</font>

571
00:26:25,870 --> 00:26:29,408
<font color="#E5E5E5">couldn't show you benchmark results for</font>

572
00:26:27,519 --> 00:26:33,309
graph<font color="#CCCCCC"> last week I can show you the</font>

573
00:26:29,409 --> 00:26:34,779
<font color="#E5E5E5">results on the paradise</font><font color="#CCCCCC"> path papers we</font>

574
00:26:33,309 --> 00:26:39,190
<font color="#E5E5E5">actually calculated multiple type</font>

575
00:26:34,779 --> 00:26:41,169
coefficient matrix this is<font color="#E5E5E5"> TCC</font><font color="#CCCCCC"> 1 and TCC</font>

576
00:26:39,190 --> 00:26:44,350
<font color="#E5E5E5">2 that look for different wedges and</font>

577
00:26:41,169 --> 00:26:45,970
different triangles and it shows<font color="#CCCCCC"> that</font>

578
00:26:44,350 --> 00:26:48,199
there<font color="#CCCCCC"> are some outliers so</font><font color="#E5E5E5"> there are</font>

579
00:26:45,970 --> 00:26:50,899
some nodes in this

580
00:26:48,200 --> 00:26:53,929
for<font color="#CCCCCC"> league data set that</font><font color="#E5E5E5"> actually are</font>

581
00:26:50,899 --> 00:26:56,139
very clustered according to some types

582
00:26:53,929 --> 00:26:58,669
and<font color="#E5E5E5"> this is something</font><font color="#CCCCCC"> that is worth</font>

583
00:26:56,139 --> 00:27:00,830
investigating<font color="#CCCCCC"> the trouble is that we</font>

584
00:26:58,669 --> 00:27:03,440
don't<font color="#E5E5E5"> have the domain specific expertise</font>

585
00:27:00,830 --> 00:27:05,510
so if you do<font color="#E5E5E5"> just please talk to us and</font>

586
00:27:03,440 --> 00:27:10,269
and reach out because<font color="#E5E5E5"> it would be really</font>

587
00:27:05,510 --> 00:27:12,440
<font color="#E5E5E5">cool</font><font color="#CCCCCC"> to discover these outliers further</font>

588
00:27:10,269 --> 00:27:14,990
<font color="#CCCCCC">okay and</font><font color="#E5E5E5"> I've said that there</font><font color="#CCCCCC"> isn't just</font>

589
00:27:12,440 --> 00:27:16,909
<font color="#E5E5E5">a systems problem here there</font><font color="#CCCCCC"> is an</font>

590
00:27:14,990 --> 00:27:20,840
<font color="#CCCCCC">algorithm</font><font color="#E5E5E5"> a core theoretical problem</font>

591
00:27:16,909 --> 00:27:23,779
when doing graph analytics<font color="#E5E5E5"> and one of</font>

592
00:27:20,840 --> 00:27:26,629
these problems<font color="#CCCCCC"> is</font><font color="#E5E5E5"> skew now this has been</font>

593
00:27:23,779 --> 00:27:30,649
<font color="#E5E5E5">recognized in relational databases</font><font color="#CCCCCC"> about</font>

594
00:27:26,630 --> 00:27:34,970
five years<font color="#E5E5E5"> ago in</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> Sigma Drucker 2013</font>

595
00:27:30,649 --> 00:27:38,918
paper that says that<font color="#CCCCCC"> if you use binary</font>

596
00:27:34,970 --> 00:27:43,549
<font color="#E5E5E5">joints for evaluating a number of</font>

597
00:27:38,919 --> 00:27:46,100
<font color="#E5E5E5">queries those queries can be inevitably</font>

598
00:27:43,549 --> 00:27:48,230
some of<font color="#E5E5E5"> suboptimal</font><font color="#CCCCCC"> this is true for</font>

599
00:27:46,100 --> 00:27:49,820
cyclic<font color="#CCCCCC"> theories and</font><font color="#E5E5E5"> unfortunately if</font>

600
00:27:48,230 --> 00:27:52,700
you're looking for<font color="#E5E5E5"> a triangle that's a</font>

601
00:27:49,820 --> 00:27:56,059
cyclic query<font color="#E5E5E5"> so here is an interesting</font>

602
00:27:52,700 --> 00:27:58,549
example<font color="#CCCCCC"> we have three</font><font color="#E5E5E5"> sets of nodes and</font>

603
00:27:56,059 --> 00:28:01,760
<font color="#E5E5E5">we have one designated node in each each</font>

604
00:27:58,549 --> 00:28:04,360
group the groups don't<font color="#E5E5E5"> have any edges</font>

605
00:28:01,760 --> 00:28:08,080
but the designated node is connected<font color="#E5E5E5"> to</font>

606
00:28:04,360 --> 00:28:11,479
<font color="#E5E5E5">all the nodes in</font><font color="#CCCCCC"> the other groups and</font>

607
00:28:08,080 --> 00:28:14,570
the other<font color="#CCCCCC"> nodes</font><font color="#E5E5E5"> so the black ones are</font>

608
00:28:11,480 --> 00:28:16,340
only<font color="#E5E5E5"> connected to the designated node so</font>

609
00:28:14,570 --> 00:28:20,539
this is like a weird graph and it turns

610
00:28:16,340 --> 00:28:23,779
out<font color="#E5E5E5"> that if you try to formulate or join</font>

611
00:28:20,539 --> 00:28:26,720
<font color="#CCCCCC">as join t so the join of these three</font>

612
00:28:23,779 --> 00:28:28,789
<font color="#CCCCCC">edges in any order it will always be</font>

613
00:28:26,720 --> 00:28:31,429
suboptimal and<font color="#CCCCCC"> it will always require a</font>

614
00:28:28,789 --> 00:28:35,059
<font color="#E5E5E5">quadratic time the reason for this is is</font>

615
00:28:31,429 --> 00:28:37,549
<font color="#CCCCCC">that you</font><font color="#E5E5E5"> have to</font><font color="#CCCCCC"> enumerate all of these</font>

616
00:28:35,059 --> 00:28:39,980
wedges<font color="#CCCCCC"> that we have talked about so you</font>

617
00:28:37,549 --> 00:28:43,429
<font color="#CCCCCC">enumerate a number of edges here that</font>

618
00:28:39,980 --> 00:28:47,720
<font color="#CCCCCC">will</font><font color="#E5E5E5"> not close into a triangle another</font>

619
00:28:43,429 --> 00:28:49,490
number of<font color="#CCCCCC"> edges there and the third</font>

620
00:28:47,720 --> 00:28:53,419
<font color="#CCCCCC">number of edges there and none of these</font>

621
00:28:49,490 --> 00:28:56,240
we<font color="#CCCCCC"> are closed</font><font color="#E5E5E5"> into a triangle so this is</font>

622
00:28:53,419 --> 00:28:59,330
<font color="#E5E5E5">actually a pretty deep</font><font color="#CCCCCC"> computer science</font>

623
00:28:56,240 --> 00:29:01,880
problem as it turns out<font color="#CCCCCC"> and initially I</font>

624
00:28:59,330 --> 00:29:03,139
thought that maybe matrices can

625
00:29:01,880 --> 00:29:05,690
<font color="#CCCCCC">resolve</font><font color="#E5E5E5"> this problem without much</font>

626
00:29:03,140 --> 00:29:07,970
thinking<font color="#CCCCCC"> but it doesn't turns out to be</font>

627
00:29:05,690 --> 00:29:11,330
<font color="#E5E5E5">the case the case is that if we map</font>

628
00:29:07,970 --> 00:29:13,910
these two matrices<font color="#E5E5E5"> and we</font><font color="#CCCCCC"> do a matrix</font>

629
00:29:11,330 --> 00:29:16,449
multiplication<font color="#CCCCCC"> what happens is that we</font>

630
00:29:13,910 --> 00:29:20,300
will get this very<font color="#E5E5E5"> dense sub matrix so</font>

631
00:29:16,450 --> 00:29:23,360
if we do<font color="#CCCCCC"> R times</font><font color="#E5E5E5"> s which is</font><font color="#CCCCCC"> the same as</font>

632
00:29:20,300 --> 00:29:26,030
a binary<font color="#CCCCCC"> join we will get a</font><font color="#E5E5E5"> quadratic</font>

633
00:29:23,360 --> 00:29:32,149
number<font color="#E5E5E5"> of edges and it will</font><font color="#CCCCCC"> obviously</font>

634
00:29:26,030 --> 00:29:33,889
take quadratic time<font color="#CCCCCC"> if we apply T so if</font>

635
00:29:32,150 --> 00:29:37,700
we<font color="#E5E5E5"> continue</font><font color="#CCCCCC"> with the multiplications</font>

636
00:29:33,890 --> 00:29:39,890
this will eventually cancel out<font color="#E5E5E5"> the</font>

637
00:29:37,700 --> 00:29:43,340
<font color="#E5E5E5">invalid veggies that do not close into a</font>

638
00:29:39,890 --> 00:29:45,500
triangle<font color="#E5E5E5"> but this is already too late</font>

639
00:29:43,340 --> 00:29:47,480
<font color="#CCCCCC">so we already</font><font color="#E5E5E5"> enumerated</font><font color="#CCCCCC"> a lot of</font>

640
00:29:45,500 --> 00:29:50,960
veggies<font color="#CCCCCC"> and we have</font><font color="#E5E5E5"> burnt a number of</font>

641
00:29:47,480 --> 00:29:54,770
CPU cycles<font color="#CCCCCC"> so one of the optimizations</font>

642
00:29:50,960 --> 00:29:57,830
that<font color="#E5E5E5"> could be used here is use T the</font>

643
00:29:54,770 --> 00:30:01,900
green matrix as a mask<font color="#CCCCCC"> for the</font>

644
00:29:57,830 --> 00:30:04,790
<font color="#CCCCCC">multiplication and it turns out</font><font color="#E5E5E5"> that</font>

645
00:30:01,900 --> 00:30:06,920
scientists<font color="#E5E5E5"> in database research have</font>

646
00:30:04,790 --> 00:30:09,440
<font color="#CCCCCC">found a solution</font><font color="#E5E5E5"> to this problem</font><font color="#CCCCCC"> as</font><font color="#E5E5E5"> well</font>

647
00:30:06,920 --> 00:30:11,750
it's called<font color="#CCCCCC"> the worst-case optimal joint</font>

648
00:30:09,440 --> 00:30:13,610
algorithm family<font color="#E5E5E5"> this can calculate</font>

649
00:30:11,750 --> 00:30:17,230
these<font color="#E5E5E5"> multi-way joints which are like</font>

650
00:30:13,610 --> 00:30:22,520
ternary<font color="#E5E5E5"> or even higher order joints in</font>

651
00:30:17,230 --> 00:30:24,200
and over 1.5 so there is hope and there

652
00:30:22,520 --> 00:30:27,320
<font color="#E5E5E5">are algorithms but they are very</font>

653
00:30:24,200 --> 00:30:29,660
difficult to adapt to practical

654
00:30:27,320 --> 00:30:31,100
applications<font color="#CCCCCC"> of course you might</font><font color="#E5E5E5"> be</font>

655
00:30:29,660 --> 00:30:33,680
wondering whether this occurs in

656
00:30:31,100 --> 00:30:36,199
practice<font color="#E5E5E5"> well not to this extreme</font><font color="#CCCCCC"> as in</font>

657
00:30:33,680 --> 00:30:39,740
the example but due to<font color="#E5E5E5"> the power load</font>

658
00:30:36,200 --> 00:30:42,350
distribution of scale-free<font color="#CCCCCC"> real networks</font>

659
00:30:39,740 --> 00:30:44,900
<font color="#E5E5E5">it's actually more common than one would</font>

660
00:30:42,350 --> 00:30:48,709
imagine<font color="#E5E5E5"> and graph</font><font color="#CCCCCC"> Blas offers mass</font>

661
00:30:44,900 --> 00:30:50,120
multiplication operators but I don't

662
00:30:48,710 --> 00:30:53,120
<font color="#E5E5E5">think there are</font><font color="#CCCCCC"> any other libraries that</font>

663
00:30:50,120 --> 00:30:56,209
<font color="#CCCCCC">do so</font><font color="#E5E5E5"> even in the more advanced</font>

664
00:30:53,120 --> 00:30:59,629
libraries like Julia<font color="#CCCCCC"> there is just no</font>

665
00:30:56,210 --> 00:31:02,510
way<font color="#CCCCCC"> to do</font><font color="#E5E5E5"> mass multiplication but you</font>

666
00:30:59,630 --> 00:31:07,070
have to write<font color="#CCCCCC"> your own</font><font color="#E5E5E5"> custom</font><font color="#CCCCCC"> matrix</font>

667
00:31:02,510 --> 00:31:11,420
multiplication operation<font color="#CCCCCC"> ok so a couple</font>

668
00:31:07,070 --> 00:31:14,929
<font color="#CCCCCC">of benchmark results</font><font color="#E5E5E5"> for the regular</font>

669
00:31:11,420 --> 00:31:15,730
graph analytics<font color="#E5E5E5"> this is LD</font><font color="#CCCCCC"> be C's</font>

670
00:31:14,930 --> 00:31:18,100
<font color="#E5E5E5">graphics</font>

671
00:31:15,730 --> 00:31:21,160
mark and it works on a synthetic social

672
00:31:18,100 --> 00:31:22,929
network graph which<font color="#E5E5E5"> is similar</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> what</font>

673
00:31:21,160 --> 00:31:25,930
Facebook have published about their

674
00:31:22,930 --> 00:31:28,060
distributions<font color="#E5E5E5"> it's sort of a large</font>

675
00:31:25,930 --> 00:31:30,100
<font color="#CCCCCC">mid-sized graph for million nodes and</font>

676
00:31:28,060 --> 00:31:33,360
<font color="#E5E5E5">it's pretty dense and the interesting</font>

677
00:31:30,100 --> 00:31:33,360
<font color="#CCCCCC">thing that we have found</font><font color="#E5E5E5"> is that</font>

678
00:31:33,570 --> 00:31:41,050
<font color="#E5E5E5">basically SCC is one of the more</font>

679
00:31:38,400 --> 00:31:43,450
difficult graph<font color="#CCCCCC"> metrics so this is a</font>

680
00:31:41,050 --> 00:31:46,030
paper that<font color="#E5E5E5"> was published before</font><font color="#CCCCCC"> the</font>

681
00:31:43,450 --> 00:31:47,890
<font color="#CCCCCC">graph list</font><font color="#E5E5E5"> it's working before</font><font color="#CCCCCC"> I joined</font>

682
00:31:46,030 --> 00:31:51,340
the graph lytx working group<font color="#E5E5E5"> and in this</font>

683
00:31:47,890 --> 00:31:54,700
<font color="#CCCCCC">paper</font><font color="#E5E5E5"> they realized that</font><font color="#CCCCCC"> SCC is actually</font>

684
00:31:51,340 --> 00:31:57,610
<font color="#CCCCCC">2 or 3 orders of magnitude slower than</font>

685
00:31:54,700 --> 00:31:59,410
metrics such as<font color="#E5E5E5"> PageRank or single</font>

686
00:31:57,610 --> 00:32:01,540
source shortest<font color="#CCCCCC"> path which is very</font>

687
00:31:59,410 --> 00:32:04,050
really interesting because those are the

688
00:32:01,540 --> 00:32:07,889
<font color="#E5E5E5">ones</font><font color="#CCCCCC"> that should be more difficult and</font>

689
00:32:04,050 --> 00:32:11,350
if you observe<font color="#CCCCCC"> for systems that</font><font color="#E5E5E5"> have a</font>

690
00:32:07,890 --> 00:32:13,390
higher baseline<font color="#E5E5E5"> so for giraffe and</font>

691
00:32:11,350 --> 00:32:16,240
graphics which<font color="#E5E5E5"> are already pretty slow</font>

692
00:32:13,390 --> 00:32:18,970
for PageRank<font color="#E5E5E5"> and single source shortest</font>

693
00:32:16,240 --> 00:32:22,720
<font color="#E5E5E5">paths they actually just fail</font><font color="#CCCCCC"> to finish</font>

694
00:32:18,970 --> 00:32:24,790
<font color="#E5E5E5">and</font><font color="#CCCCCC"> time out ok</font><font color="#E5E5E5"> so I wrap up soon</font>

695
00:32:22,720 --> 00:32:27,220
a couple of takeaways is that<font color="#E5E5E5"> graph</font>

696
00:32:24,790 --> 00:32:29,770
processing is hard so you need<font color="#E5E5E5"> two</font>

697
00:32:27,220 --> 00:32:33,490
sparse matrices<font color="#E5E5E5"> you need to use edge</font>

698
00:32:29,770 --> 00:32:36,340
types<font color="#E5E5E5"> it's desirable if you can override</font>

699
00:32:33,490 --> 00:32:38,710
the multiplication and addition

700
00:32:36,340 --> 00:32:41,290
operators of course we would<font color="#E5E5E5"> like to</font><font color="#CCCCCC"> run</font>

701
00:32:38,710 --> 00:32:44,170
it in parallel<font color="#E5E5E5"> and we would like if it</font>

702
00:32:41,290 --> 00:32:46,240
wouldn't crash on skewed distributions<font color="#CCCCCC"> I</font>

703
00:32:44,170 --> 00:32:48,550
don't<font color="#CCCCCC"> think there are of the shaft</font>

704
00:32:46,240 --> 00:32:51,100
solutions<font color="#E5E5E5"> but I've gathered a couple of</font>

705
00:32:48,550 --> 00:32:54,820
building blocks that<font color="#E5E5E5"> you could use for C</font>

706
00:32:51,100 --> 00:32:56,800
C++ Java<font color="#E5E5E5"> and</font><font color="#CCCCCC"> Julia</font><font color="#E5E5E5"> and it turns out that</font>

707
00:32:54,820 --> 00:33:00,070
for<font color="#E5E5E5"> Python there is already a wrapper</font>

708
00:32:56,800 --> 00:33:02,770
for<font color="#CCCCCC"> graph class so</font><font color="#E5E5E5"> this is all food for</font>

709
00:33:00,070 --> 00:33:05,379
<font color="#E5E5E5">thought and tools for experimentation</font>

710
00:33:02,770 --> 00:33:08,460
<font color="#E5E5E5">there are a</font><font color="#CCCCCC"> number of</font><font color="#E5E5E5"> papers</font><font color="#CCCCCC"> it turns</font>

711
00:33:05,380 --> 00:33:11,620
<font color="#E5E5E5">out that last year people</font><font color="#CCCCCC"> started to do</font>

712
00:33:08,460 --> 00:33:14,170
some distributed and linear<font color="#CCCCCC"> algebra</font>

713
00:33:11,620 --> 00:33:17,110
based graphical<font color="#CCCCCC"> frameworks so this is I</font>

714
00:33:14,170 --> 00:33:22,990
think<font color="#E5E5E5"> a good step</font><font color="#CCCCCC"> into creating scalable</font>

715
00:33:17,110 --> 00:33:26,110
graph analytics<font color="#E5E5E5"> and basically based on</font>

716
00:33:22,990 --> 00:33:28,990
our<font color="#CCCCCC"> experiments</font><font color="#E5E5E5"> if you use Java just use</font>

717
00:33:26,110 --> 00:33:32,919
eg ml if you have the time to learn

718
00:33:28,990 --> 00:33:35,620
<font color="#CCCCCC">f+</font><font color="#E5E5E5"> then that's a very good</font><font color="#CCCCCC"> investment of</font>

719
00:33:32,920 --> 00:33:40,059
<font color="#E5E5E5">your time and</font><font color="#CCCCCC"> julia</font><font color="#E5E5E5"> is promising but has</font>

720
00:33:35,620 --> 00:33:43,989
no<font color="#CCCCCC"> specific graph support yet and one</font>

721
00:33:40,059 --> 00:33:45,610
confession<font color="#CCCCCC"> today and is that</font><font color="#E5E5E5"> I believe</font>

722
00:33:43,990 --> 00:33:47,770
<font color="#CCCCCC">that some Java libraries could</font><font color="#E5E5E5"> have</font>

723
00:33:45,610 --> 00:33:49,540
actually<font color="#CCCCCC"> worked for</font><font color="#E5E5E5"> paralyzed papers but</font>

724
00:33:47,770 --> 00:33:52,270
we got too carried<font color="#CCCCCC"> away with the linear</font>

725
00:33:49,540 --> 00:33:55,000
algebraic wizardry I think the arabesque

726
00:33:52,270 --> 00:33:57,309
<font color="#E5E5E5">library and fling jelly and GPS the</font>

727
00:33:55,000 --> 00:34:00,610
graph processing system could work<font color="#E5E5E5"> for</font>

728
00:33:57,309 --> 00:34:03,428
<font color="#E5E5E5">data set with the scale of the paradise</font>

729
00:34:00,610 --> 00:34:06,580
papers<font color="#CCCCCC"> as you can see none of those were</font>

730
00:34:03,429 --> 00:34:10,240
included<font color="#CCCCCC"> in this benchmark so they could</font>

731
00:34:06,580 --> 00:34:12,489
probably work for something<font color="#E5E5E5"> like the</font>

732
00:34:10,239 --> 00:34:14,049
Paradise Papers data set<font color="#E5E5E5"> it would be</font>

733
00:34:12,489 --> 00:34:16,388
very<font color="#E5E5E5"> interesting to see</font><font color="#CCCCCC"> how they perform</font>

734
00:34:14,050 --> 00:34:18,730
<font color="#E5E5E5">in practice</font><font color="#CCCCCC"> thank you</font><font color="#E5E5E5"> for your attention</font>

735
00:34:16,389 --> 00:34:28,470
<font color="#CCCCCC">and if you have any questions we have</font>

736
00:34:18,730 --> 00:34:28,469
like four minutes<font color="#E5E5E5"> for that yes</font><font color="#CCCCCC"> okay</font>

737
00:34:29,909 --> 00:34:33,149
[Music]

738
00:35:21,910 --> 00:35:29,618
it's sort of<font color="#CCCCCC"> yeah so the question was</font>

739
00:35:25,810 --> 00:35:31,270
whether or<font color="#CCCCCC"> not matrices are a good idea</font>

740
00:35:29,619 --> 00:35:34,890
because<font color="#CCCCCC"> there are specialized algorithms</font>

741
00:35:31,270 --> 00:35:40,090
for problems such as triangle counting

742
00:35:34,890 --> 00:35:41,980
<font color="#CCCCCC">it's sort of like the common idea of an</font>

743
00:35:40,090 --> 00:35:44,050
intermediate<font color="#E5E5E5"> language in computer</font>

744
00:35:41,980 --> 00:35:46,420
<font color="#CCCCCC">science</font><font color="#E5E5E5"> so it's more optimal than</font>

745
00:35:44,050 --> 00:35:51,310
someone with writing<font color="#E5E5E5"> from scratch</font>

746
00:35:46,420 --> 00:35:52,780
so if you so let's take our use case<font color="#E5E5E5"> if</font>

747
00:35:51,310 --> 00:35:54,759
you only have a<font color="#CCCCCC"> couple</font><font color="#E5E5E5"> of days to</font>

748
00:35:52,780 --> 00:35:58,270
implement<font color="#E5E5E5"> the metric and</font><font color="#CCCCCC"> you don't want</font>

749
00:35:54,760 --> 00:36:00,010
<font color="#E5E5E5">to do detailed algorithm design just use</font>

750
00:35:58,270 --> 00:36:03,400
those building blocks<font color="#CCCCCC"> and invoke a</font>

751
00:36:00,010 --> 00:36:06,609
couple of graph<font color="#CCCCCC"> Blas</font><font color="#E5E5E5"> API calls or some</font>

752
00:36:03,400 --> 00:36:08,920
some matrix<font color="#E5E5E5"> multiplication creations in</font>

753
00:36:06,609 --> 00:36:12,009
say Julia<font color="#E5E5E5"> that I think this is a good</font>

754
00:36:08,920 --> 00:36:14,160
<font color="#CCCCCC">balance so</font><font color="#E5E5E5"> this tries to strike a</font>

755
00:36:12,010 --> 00:36:17,010
balance between<font color="#E5E5E5"> expressivity and</font>

756
00:36:14,160 --> 00:36:19,868
performance and I think it's a good step

757
00:36:17,010 --> 00:36:22,330
<font color="#E5E5E5">because of the hardware area is getting</font>

758
00:36:19,869 --> 00:36:23,710
so heterogeneous because if<font color="#E5E5E5"> even if you</font>

759
00:36:22,330 --> 00:36:25,450
have a very good<font color="#CCCCCC"> edge list</font>

760
00:36:23,710 --> 00:36:29,160
<font color="#CCCCCC">implementation you will don't</font><font color="#E5E5E5"> be</font><font color="#CCCCCC"> able to</font>

761
00:36:25,450 --> 00:36:31,720
<font color="#E5E5E5">deploy it to GPU or</font><font color="#CCCCCC"> an</font><font color="#E5E5E5"> FPGA or or</font>

762
00:36:29,160 --> 00:36:36,569
something that's<font color="#E5E5E5"> that's a specialized</font>

763
00:36:31,720 --> 00:36:36,569
piece<font color="#CCCCCC"> of harder okay one more</font><font color="#E5E5E5"> question</font>

764
00:36:39,390 --> 00:36:42,390
okay

765
00:36:48,200 --> 00:37:20,930
I have a quote from some<font color="#CCCCCC"> Holliday who</font>

766
00:37:17,869 --> 00:37:23,570
implemented one of the<font color="#E5E5E5"> sparse and dense</font>

767
00:37:20,930 --> 00:37:25,129
matrix libraries and some said there is

768
00:37:23,570 --> 00:37:30,320
actually no such<font color="#CCCCCC"> thing as</font><font color="#E5E5E5"> a sparse</font>

769
00:37:25,130 --> 00:37:33,349
matrix<font color="#E5E5E5"> because the number</font><font color="#CCCCCC"> of matrices</font>

770
00:37:30,320 --> 00:37:35,180
<font color="#CCCCCC">that you find in the</font><font color="#E5E5E5"> wide are so big</font><font color="#CCCCCC"> the</font>

771
00:37:33,349 --> 00:37:37,400
number of<font color="#E5E5E5"> different types that</font><font color="#CCCCCC"> it's</font>

772
00:37:35,180 --> 00:37:39,440
<font color="#E5E5E5">always going to be a custom solution</font><font color="#CCCCCC"> for</font>

773
00:37:37,400 --> 00:37:41,900
a<font color="#E5E5E5"> given sparse matrix so I have a quote</font>

774
00:37:39,440 --> 00:37:44,420
<font color="#E5E5E5">to say that you are right it's probably</font>

775
00:37:41,900 --> 00:37:45,680
<font color="#CCCCCC">if you have a power</font><font color="#E5E5E5"> low graph</font><font color="#CCCCCC"> or you</font>

776
00:37:44,420 --> 00:37:47,780
<font color="#E5E5E5">have a mesh graph you will need</font>

777
00:37:45,680 --> 00:37:50,210
<font color="#CCCCCC">different algorithms this</font><font color="#E5E5E5"> different</font>

778
00:37:47,780 --> 00:37:52,280
<font color="#E5E5E5">algorithm if you want to extract</font><font color="#CCCCCC"> you</font>

779
00:37:50,210 --> 00:37:55,910
know the last<font color="#E5E5E5"> ounce of performance from</font>

780
00:37:52,280 --> 00:37:58,040
<font color="#E5E5E5">your hardware and I think this is an</font>

781
00:37:55,910 --> 00:38:02,629
open problem so probably what we<font color="#CCCCCC"> should</font>

782
00:37:58,040 --> 00:38:05,420
do is create various sparse matrix

783
00:38:02,630 --> 00:38:07,700
representations and optimize<font color="#E5E5E5"> various</font>

784
00:38:05,420 --> 00:38:09,859
operators according to the distributions

785
00:38:07,700 --> 00:38:14,089
<font color="#E5E5E5">and that's probably closer to the</font>

786
00:38:09,859 --> 00:38:16,560
optimum than the current approach<font color="#E5E5E5"> okay</font>

787
00:38:14,089 --> 00:38:22,480
thank you<font color="#CCCCCC"> again</font>

788
00:38:16,560 --> 00:38:22,480
[Applause]

