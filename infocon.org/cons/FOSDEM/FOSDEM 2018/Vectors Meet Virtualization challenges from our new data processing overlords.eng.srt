1
00:00:05,840 --> 00:00:12,660
hello in this session<font color="#CCCCCC"> Alex will talk</font>

2
00:00:09,209 --> 00:00:17,779
about<font color="#E5E5E5"> relentless when</font><font color="#CCCCCC"> vectors need</font>

3
00:00:12,660 --> 00:00:20,040
visualization<font color="#E5E5E5"> okay thank you very much</font>

4
00:00:17,779 --> 00:00:23,730
<font color="#E5E5E5">okay well I'll just start</font><font color="#CCCCCC"> with a brief</font>

5
00:00:20,040 --> 00:00:26,399
<font color="#E5E5E5">introduction my name's Alex</font><font color="#CCCCCC"> Binet I work</font>

6
00:00:23,730 --> 00:00:28,099
for a company<font color="#E5E5E5"> called</font><font color="#CCCCCC"> Lennar oh so I'm a</font>

7
00:00:26,399 --> 00:00:30,630
member<font color="#E5E5E5"> of the virtualization team there</font>

8
00:00:28,099 --> 00:00:33,710
so as a result<font color="#E5E5E5"> I tend to work on</font>

9
00:00:30,630 --> 00:00:36,120
projects<font color="#E5E5E5"> like creme you and KVM and</font>

10
00:00:33,710 --> 00:00:38,579
because<font color="#CCCCCC"> Lennar o is interested in</font><font color="#E5E5E5"> the</font>

11
00:00:36,120 --> 00:00:42,839
army ecosystem<font color="#CCCCCC"> arm</font><font color="#E5E5E5"> is basically what I</font>

12
00:00:38,579 --> 00:00:44,999
do so let's quickly introduce creme you

13
00:00:42,839 --> 00:00:47,998
so what is<font color="#E5E5E5"> creme you according</font><font color="#CCCCCC"> to its</font>

14
00:00:44,999 --> 00:00:49,710
web page<font color="#E5E5E5"> it's a generic</font><font color="#CCCCCC"> open-source</font>

15
00:00:47,999 --> 00:00:52,019
<font color="#E5E5E5">machine emulator and virtualizer</font>

16
00:00:49,710 --> 00:00:53,550
<font color="#E5E5E5">I think the</font><font color="#CCCCCC"> cue originally stood for</font>

17
00:00:52,019 --> 00:00:55,280
quick but<font color="#E5E5E5"> we like to</font><font color="#CCCCCC"> think of it as</font>

18
00:00:53,550 --> 00:00:58,050
pretty<font color="#E5E5E5"> fast now</font>

19
00:00:55,280 --> 00:01:00,839
so<font color="#E5E5E5"> query supports two</font><font color="#CCCCCC"> types of</font>

20
00:00:58,050 --> 00:01:03,239
virtualization<font color="#CCCCCC"> the first is probably the</font>

21
00:01:00,839 --> 00:01:05,519
<font color="#E5E5E5">most familiar to most of</font><font color="#CCCCCC"> you and</font><font color="#E5E5E5"> that's</font>

22
00:01:03,239 --> 00:01:07,880
when it's used to launch<font color="#E5E5E5"> guests using</font>

23
00:01:05,519 --> 00:01:10,490
the Linux kernels kernel virtual machine

24
00:01:07,880 --> 00:01:13,320
this requires support from the<font color="#E5E5E5"> hardware</font>

25
00:01:10,490 --> 00:01:16,140
and uses hardware features to accelerate

26
00:01:13,320 --> 00:01:18,779
the virtualization<font color="#CCCCCC"> the second mode is</font>

27
00:01:16,140 --> 00:01:20,910
less well known uses<font color="#CCCCCC"> a just-in-time</font>

28
00:01:18,780 --> 00:01:23,700
recompilation engine called<font color="#E5E5E5"> the tiny</font>

29
00:01:20,910 --> 00:01:25,380
code generator or TCG and this allows

30
00:01:23,700 --> 00:01:27,840
you<font color="#E5E5E5"> to fully emulate a system of any</font>

31
00:01:25,380 --> 00:01:29,610
supported architecture<font color="#E5E5E5"> on any other</font>

32
00:01:27,840 --> 00:01:31,650
machine with potentially different

33
00:01:29,610 --> 00:01:34,680
supported architecture<font color="#CCCCCC"> so let's have a</font>

34
00:01:31,650 --> 00:01:36,090
closer look<font color="#E5E5E5"> at the two in detail so</font>

35
00:01:34,680 --> 00:01:37,920
let's say hardware-assisted

36
00:01:36,090 --> 00:01:40,260
virtualization is what most<font color="#E5E5E5"> people are</font>

37
00:01:37,920 --> 00:01:42,090
<font color="#E5E5E5">probably familiar</font><font color="#CCCCCC"> with</font><font color="#E5E5E5"> this is the sort</font>

38
00:01:40,260 --> 00:01:44,310
of high performance virtualization that

39
00:01:42,090 --> 00:01:45,810
<font color="#CCCCCC">you see in the cloud or if you're</font><font color="#E5E5E5"> doing</font>

40
00:01:44,310 --> 00:01:48,780
old-fashioned things like server

41
00:01:45,810 --> 00:01:50,280
consolidation<font color="#CCCCCC"> so here chrome</font><font color="#E5E5E5"> U is</font>

42
00:01:48,780 --> 00:01:52,110
responsible for<font color="#CCCCCC"> launching the virtual</font>

43
00:01:50,280 --> 00:01:56,190
machine<font color="#E5E5E5"> but it has most of the work off</font>

44
00:01:52,110 --> 00:01:57,840
to the<font color="#CCCCCC"> k vm subsystem inside</font><font color="#E5E5E5"> linux and</font>

45
00:01:56,190 --> 00:01:59,820
most of the work that<font color="#CCCCCC"> it does</font><font color="#E5E5E5"> is</font>

46
00:01:57,840 --> 00:02:01,730
supported by the hardware<font color="#E5E5E5"> so the</font>

47
00:01:59,820 --> 00:02:04,080
hypervisor only really gets involved

48
00:02:01,730 --> 00:02:05,880
<font color="#CCCCCC">when the guest access</font><font color="#E5E5E5"> is something</font>

49
00:02:04,080 --> 00:02:07,500
<font color="#CCCCCC">that's virtualized</font><font color="#E5E5E5"> and the hypervisor</font>

50
00:02:05,880 --> 00:02:09,989
needs to do<font color="#E5E5E5"> something about it</font>

51
00:02:07,500 --> 00:02:12,569
most of this is dealt<font color="#E5E5E5"> with by a VM</font>

52
00:02:09,989 --> 00:02:14,579
itself<font color="#E5E5E5"> but ultimately we can always go</font>

53
00:02:12,569 --> 00:02:16,230
all the way back to claim you for Queen

54
00:02:14,579 --> 00:02:18,660
you to deal<font color="#E5E5E5"> with the</font>

55
00:02:16,230 --> 00:02:20,899
the access so<font color="#CCCCCC"> creamy</font><font color="#E5E5E5"> usually gets</font>

56
00:02:18,660 --> 00:02:27,510
involved for older emulated hardware

57
00:02:20,900 --> 00:02:29,310
<font color="#E5E5E5">also in various</font><font color="#CCCCCC"> io</font><font color="#E5E5E5"> situations just a</font>

58
00:02:27,510 --> 00:02:31,349
quick note the e<font color="#CCCCCC"> L modes here are</font><font color="#E5E5E5"> armed</font>

59
00:02:29,310 --> 00:02:34,440
terminology so they stand<font color="#CCCCCC"> for execution</font>

60
00:02:31,349 --> 00:02:36,480
level<font color="#E5E5E5"> so L</font><font color="#CCCCCC"> 0 is user</font><font color="#E5E5E5"> space</font><font color="#CCCCCC"> er one is</font>

61
00:02:34,440 --> 00:02:38,670
kernel<font color="#CCCCCC"> space</font><font color="#E5E5E5"> and in arm we</font><font color="#CCCCCC"> have a</font>

62
00:02:36,480 --> 00:02:43,679
<font color="#E5E5E5">specific L 2 which is the hypervisor</font>

63
00:02:38,670 --> 00:02:45,390
<font color="#E5E5E5">layer so the second mode that we're</font>

64
00:02:43,680 --> 00:02:46,860
talking about is full system emulation

65
00:02:45,390 --> 00:02:50,119
so this is the sort of thing you'd see

66
00:02:46,860 --> 00:02:52,650
if you're<font color="#CCCCCC"> running the Android emulator</font>

67
00:02:50,120 --> 00:02:55,680
<font color="#CCCCCC">also it's</font><font color="#E5E5E5"> quite heavily used in embedded</font>

68
00:02:52,650 --> 00:02:57,630
<font color="#CCCCCC">development</font><font color="#E5E5E5"> because it's often easier to</font>

69
00:02:55,680 --> 00:03:00,420
<font color="#E5E5E5">debug stuff on an emulator than on the</font>

70
00:02:57,630 --> 00:03:02,220
real hardware<font color="#CCCCCC"> and another use case for a</font>

71
00:03:00,420 --> 00:03:04,950
full system emulation is when you're

72
00:03:02,220 --> 00:03:07,920
<font color="#CCCCCC">bringing up new architectures</font><font color="#E5E5E5"> I think in</font>

73
00:03:04,950 --> 00:03:09,450
fact<font color="#E5E5E5"> risk</font><font color="#CCCCCC"> v before the hardware came out</font>

74
00:03:07,920 --> 00:03:14,010
one of<font color="#E5E5E5"> the fastest ways of running risky</font>

75
00:03:09,450 --> 00:03:16,890
was under a<font color="#CCCCCC"> creme</font><font color="#E5E5E5"> you run so in a TCG</font>

76
00:03:14,010 --> 00:03:18,899
system the emulation<font color="#CCCCCC"> looks quite</font>

77
00:03:16,890 --> 00:03:21,899
different<font color="#CCCCCC"> from KVM everything is run in</font>

78
00:03:18,900 --> 00:03:23,850
a single user space process<font color="#E5E5E5"> chroming</font>

79
00:03:21,900 --> 00:03:27,269
allocates a block of memory to represent

80
00:03:23,850 --> 00:03:29,519
the guest system and then it dynamically

81
00:03:27,269 --> 00:03:32,030
recompiles the guest code to emulate the

82
00:03:29,519 --> 00:03:34,950
guests and guest system in<font color="#E5E5E5"> user space</font>

83
00:03:32,030 --> 00:03:36,510
it's quite slow because every guest

84
00:03:34,950 --> 00:03:38,730
instruction takes a<font color="#E5E5E5"> good number of host</font>

85
00:03:36,510 --> 00:03:40,920
instructions to emulate and there's also

86
00:03:38,730 --> 00:03:43,078
a bit<font color="#E5E5E5"> of a cost to emulating the memory</font>

87
00:03:40,920 --> 00:03:45,089
management unit<font color="#CCCCCC"> this in case you're</font>

88
00:03:43,079 --> 00:03:47,239
wondering is why the<font color="#CCCCCC"> chrome you binaries</font>

89
00:03:45,090 --> 00:03:49,560
are often<font color="#E5E5E5"> called the chrome</font><font color="#CCCCCC"> use soft MMU</font>

90
00:03:47,239 --> 00:03:52,769
but as far as the guest is concerned is

91
00:03:49,560 --> 00:03:54,620
running on real<font color="#CCCCCC"> hardware there is</font>

92
00:03:52,769 --> 00:03:56,910
actually a<font color="#E5E5E5"> third mode that we use</font>

93
00:03:54,620 --> 00:03:59,819
<font color="#E5E5E5">specifically for emulating</font><font color="#CCCCCC"> Linux user</font>

94
00:03:56,910 --> 00:04:01,819
space binaries you tend to<font color="#E5E5E5"> see this in</font>

95
00:03:59,819 --> 00:04:06,510
situations where people<font color="#E5E5E5"> are</font><font color="#CCCCCC"> doing</font>

96
00:04:01,819 --> 00:04:08,540
development<font color="#CCCCCC"> so cross tools or if they</font>

97
00:04:06,510 --> 00:04:10,649
want to run<font color="#E5E5E5"> stuff in a in a</font><font color="#CCCCCC"> root fs</font>

98
00:04:08,540 --> 00:04:13,290
another use<font color="#E5E5E5"> case is if you've got</font><font color="#CCCCCC"> a</font>

99
00:04:10,650 --> 00:04:15,690
legacy binary for a old architecture

100
00:04:13,290 --> 00:04:19,500
that<font color="#CCCCCC"> you can't rebuild for</font><font color="#E5E5E5"> whatever</font>

101
00:04:15,690 --> 00:04:21,750
reason and<font color="#E5E5E5"> the mechanics of the JIT are</font>

102
00:04:19,500 --> 00:04:23,250
mostly the<font color="#CCCCCC"> same but it does run quite a</font>

103
00:04:21,750 --> 00:04:26,099
bit faster<font color="#CCCCCC"> because we're not emulating</font>

104
00:04:23,250 --> 00:04:27,780
an MMU<font color="#E5E5E5"> it also</font><font color="#CCCCCC"> any works for Linux</font>

105
00:04:26,099 --> 00:04:28,830
binaries<font color="#E5E5E5"> because</font><font color="#CCCCCC"> chrome</font><font color="#E5E5E5"> use not</font>

106
00:04:27,780 --> 00:04:30,690
emulating the kernel

107
00:04:28,830 --> 00:04:33,539
itself it basically takes<font color="#E5E5E5"> a system call</font>

108
00:04:30,690 --> 00:04:35,910
from the<font color="#CCCCCC"> guest munge is it a bit so it</font>

109
00:04:33,540 --> 00:04:38,730
<font color="#E5E5E5">can be passed directly on to the host on</font>

110
00:04:35,910 --> 00:04:41,460
the<font color="#E5E5E5"> guest behalf so now</font><font color="#CCCCCC"> to talk</font><font color="#E5E5E5"> about</font>

111
00:04:38,730 --> 00:04:43,440
<font color="#E5E5E5">creme you let's talk a little bit</font><font color="#CCCCCC"> about</font>

112
00:04:41,460 --> 00:04:45,659
<font color="#E5E5E5">these vectors I'm discussing and</font><font color="#CCCCCC"> what</font>

113
00:04:43,440 --> 00:04:47,520
they're<font color="#CCCCCC"> all about so a lot of</font><font color="#E5E5E5"> the</font>

114
00:04:45,660 --> 00:04:49,530
activities that we take for granted in

115
00:04:47,520 --> 00:04:52,049
modern computing have been<font color="#E5E5E5"> enabled</font><font color="#CCCCCC"> by</font>

116
00:04:49,530 --> 00:04:54,659
vector processing<font color="#E5E5E5"> so things like video</font>

117
00:04:52,050 --> 00:04:56,610
playback audio<font color="#E5E5E5"> processing 3d modeling</font>

118
00:04:54,660 --> 00:04:59,100
all involve large amounts of data

119
00:04:56,610 --> 00:05:01,020
<font color="#CCCCCC">processing</font><font color="#E5E5E5"> and most of this data</font>

120
00:04:59,100 --> 00:05:03,330
processing involves a thing<font color="#E5E5E5"> called data</font>

121
00:05:01,020 --> 00:05:05,640
parallelism<font color="#E5E5E5"> and this is where vector</font>

122
00:05:03,330 --> 00:05:08,580
processing<font color="#CCCCCC"> is really shines</font><font color="#E5E5E5"> now here's a</font>

123
00:05:05,640 --> 00:05:13,620
quick quiz quiz question can anyone<font color="#E5E5E5"> name</font>

124
00:05:08,580 --> 00:05:16,200
this machine very<font color="#CCCCCC"> good yeah it's the</font>

125
00:05:13,620 --> 00:05:18,420
<font color="#E5E5E5">cray-1 one of the very early</font>

126
00:05:16,200 --> 00:05:21,930
supercomputers<font color="#E5E5E5"> of its time it was built</font>

127
00:05:18,420 --> 00:05:24,240
<font color="#E5E5E5">a few years</font><font color="#CCCCCC"> after I was</font><font color="#E5E5E5"> born</font><font color="#CCCCCC"> even though</font>

128
00:05:21,930 --> 00:05:26,040
it only<font color="#E5E5E5"> clocked in at 80 megahertz it</font>

129
00:05:24,240 --> 00:05:29,070
could do 250 million floating-point

130
00:05:26,040 --> 00:05:31,590
operations a second<font color="#E5E5E5"> and this is in part</font>

131
00:05:29,070 --> 00:05:33,900
due<font color="#E5E5E5"> to its vector base design it had</font>

132
00:05:31,590 --> 00:05:37,530
<font color="#CCCCCC">eight vector registers</font><font color="#E5E5E5"> each capable of</font>

133
00:05:33,900 --> 00:05:39,179
holding 64<font color="#CCCCCC"> 64 bit elements and this</font>

134
00:05:37,530 --> 00:05:40,919
allowed<font color="#CCCCCC"> it to execute the same</font>

135
00:05:39,180 --> 00:05:43,590
floating-point operation<font color="#E5E5E5"> across multiple</font>

136
00:05:40,920 --> 00:05:45,600
elements in the<font color="#E5E5E5"> vector register</font><font color="#CCCCCC"> I don't</font>

137
00:05:43,590 --> 00:05:49,080
know if anyone saw<font color="#E5E5E5"> Liam</font><font color="#CCCCCC"> circuit</font><font color="#E5E5E5"> less</font>

138
00:05:45,600 --> 00:05:52,280
<font color="#E5E5E5">travel talk yesterday</font><font color="#CCCCCC"> but as you can</font><font color="#E5E5E5"> see</font>

139
00:05:49,080 --> 00:05:55,109
<font color="#CCCCCC">they did it first quite a long time</font><font color="#E5E5E5"> ago</font>

140
00:05:52,280 --> 00:05:57,330
so<font color="#CCCCCC"> while supercomputers were only used</font>

141
00:05:55,110 --> 00:06:00,000
as the vectors eventually it<font color="#E5E5E5"> came to</font>

142
00:05:57,330 --> 00:06:02,430
workstations<font color="#E5E5E5"> they started to use them as</font>

143
00:06:00,000 --> 00:06:04,710
well<font color="#E5E5E5"> the spark was quite early on with</font>

144
00:06:02,430 --> 00:06:06,750
its visual<font color="#E5E5E5"> visual instruction set</font><font color="#CCCCCC"> but</font>

145
00:06:04,710 --> 00:06:09,840
most PC users will<font color="#CCCCCC"> probably come across</font>

146
00:06:06,750 --> 00:06:12,360
<font color="#E5E5E5">vectors the first time when</font><font color="#CCCCCC"> Intel's MMX</font>

147
00:06:09,840 --> 00:06:13,770
extensions were introduced these are

148
00:06:12,360 --> 00:06:16,530
sometimes<font color="#E5E5E5"> known as the multimedia</font>

149
00:06:13,770 --> 00:06:18,120
extensions<font color="#E5E5E5"> because media</font><font color="#CCCCCC"> processing was</font>

150
00:06:16,530 --> 00:06:20,280
one of the very<font color="#E5E5E5"> first workloads that</font>

151
00:06:18,120 --> 00:06:23,550
<font color="#CCCCCC">were which</font><font color="#E5E5E5"> these extensions was designed</font>

152
00:06:20,280 --> 00:06:26,580
<font color="#E5E5E5">to accelerate now</font><font color="#CCCCCC"> the early workstations</font>

153
00:06:23,550 --> 00:06:27,630
only supported integer operations but<font color="#E5E5E5"> it</font>

154
00:06:26,580 --> 00:06:30,270
didn't<font color="#E5E5E5"> take too</font><font color="#CCCCCC"> long before</font>

155
00:06:27,630 --> 00:06:31,980
floating-point became the<font color="#CCCCCC"> norman AMD's</font>

156
00:06:30,270 --> 00:06:36,359
3d now<font color="#E5E5E5"> I think</font><font color="#CCCCCC"> was the first one to</font>

157
00:06:31,980 --> 00:06:38,610
introduce<font color="#E5E5E5"> it</font><font color="#CCCCCC"> to the PC so let's have a</font>

158
00:06:36,360 --> 00:06:42,139
closer<font color="#CCCCCC"> look at what a vector</font><font color="#E5E5E5"> register</font>

159
00:06:38,610 --> 00:06:44,330
looks like so<font color="#E5E5E5"> this is a wide register</font>

160
00:06:42,139 --> 00:06:47,119
which contains multiple elements and

161
00:06:44,330 --> 00:06:49,639
these usually referred to as lanes<font color="#E5E5E5"> so in</font>

162
00:06:47,119 --> 00:06:53,419
this<font color="#E5E5E5"> example we</font><font color="#CCCCCC"> have 128 bit wide vector</font>

163
00:06:49,639 --> 00:06:55,579
and it<font color="#E5E5E5"> holds for 32</font><font color="#CCCCCC"> bit values</font><font color="#E5E5E5"> now why</font>

164
00:06:53,419 --> 00:06:59,479
is this useful<font color="#CCCCCC"> let's</font><font color="#E5E5E5"> look at an</font><font color="#CCCCCC"> example</font>

165
00:06:55,579 --> 00:07:02,569
vector operation so this is a vectorized

166
00:06:59,479 --> 00:07:04,729
<font color="#CCCCCC">ad</font><font color="#E5E5E5"> so with a single instruction</font><font color="#CCCCCC"> we're</font>

167
00:07:02,569 --> 00:07:07,339
adding the contents of<font color="#E5E5E5"> the VN and the</font><font color="#CCCCCC"> VM</font>

168
00:07:04,729 --> 00:07:09,159
registers together<font color="#CCCCCC"> but</font><font color="#E5E5E5"> importantly each</font>

169
00:07:07,339 --> 00:07:11,509
individual<font color="#CCCCCC"> Lane is processed separately</font>

170
00:07:09,159 --> 00:07:13,399
<font color="#CCCCCC">so this is why these instructions are</font>

171
00:07:11,509 --> 00:07:14,989
often<font color="#E5E5E5"> referred to as</font><font color="#CCCCCC"> Sindy instructions</font>

172
00:07:13,399 --> 00:07:18,169
which stands<font color="#CCCCCC"> for single instruction</font>

173
00:07:14,989 --> 00:07:19,578
multiple<font color="#E5E5E5"> data so by saving the cost of</font>

174
00:07:18,169 --> 00:07:21,498
having<font color="#E5E5E5"> to decode an instruction each</font>

175
00:07:19,579 --> 00:07:24,499
time and<font color="#E5E5E5"> also</font><font color="#CCCCCC"> by having multiple</font>

176
00:07:21,499 --> 00:07:27,939
arithmetic units in your<font color="#E5E5E5"> CPU you get a</font>

177
00:07:24,499 --> 00:07:29,959
simple parallelism in your processing

178
00:07:27,939 --> 00:07:31,969
now if you look at<font color="#CCCCCC"> the</font><font color="#E5E5E5"> history of these</font>

179
00:07:29,959 --> 00:07:33,739
<font color="#E5E5E5">instructions on the PC you</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> see</font>

180
00:07:31,969 --> 00:07:34,849
there's<font color="#CCCCCC"> been a steady</font><font color="#E5E5E5"> growth as they've</font>

181
00:07:33,739 --> 00:07:37,638
tried<font color="#CCCCCC"> to</font><font color="#E5E5E5"> catch up</font><font color="#CCCCCC"> with their</font>

182
00:07:34,849 --> 00:07:39,860
supercomputer counterparts<font color="#E5E5E5"> the first</font>

183
00:07:37,639 --> 00:07:43,129
expansion<font color="#CCCCCC"> from MMX doubled the size of</font>

184
00:07:39,860 --> 00:07:46,669
vector registers<font color="#CCCCCC"> to 128 bits their</font>

185
00:07:43,129 --> 00:07:50,360
current iteration<font color="#E5E5E5"> avx-512</font><font color="#CCCCCC"> as well</font>

186
00:07:46,669 --> 00:07:52,219
supplies no one is 512 bits<font color="#CCCCCC"> wide</font><font color="#E5E5E5"> so as</font>

187
00:07:50,360 --> 00:07:54,649
you can<font color="#E5E5E5"> see for that you can do</font><font color="#CCCCCC"> 8 double</font>

188
00:07:52,219 --> 00:07:56,599
precision operations at a time<font color="#E5E5E5"> or 16</font>

189
00:07:54,649 --> 00:08:00,860
single<font color="#E5E5E5"> precision operations all the way</font>

190
00:07:56,599 --> 00:08:02,329
down to 64 byte operations now I'm

191
00:08:00,860 --> 00:08:04,039
<font color="#E5E5E5">taking this to its</font><font color="#CCCCCC"> logical conclusion</font>

192
00:08:02,329 --> 00:08:07,039
<font color="#E5E5E5">and they've introduced a thing called</font>

193
00:08:04,039 --> 00:08:08,989
their scalable vector extensions<font color="#E5E5E5"> so this</font>

194
00:08:07,039 --> 00:08:11,539
<font color="#E5E5E5">introduces vectors which can be up</font><font color="#CCCCCC"> to</font>

195
00:08:08,989 --> 00:08:13,969
<font color="#CCCCCC">two</font><font color="#E5E5E5"> kilobits in length and also</font>

196
00:08:11,539 --> 00:08:15,639
introduces<font color="#E5E5E5"> a novel instructions that</font>

197
00:08:13,969 --> 00:08:18,349
<font color="#E5E5E5">allow you</font><font color="#CCCCCC"> to utilize</font><font color="#E5E5E5"> these vectors</font>

198
00:08:15,639 --> 00:08:19,550
<font color="#CCCCCC">without</font><font color="#E5E5E5"> having to</font><font color="#CCCCCC"> hard code assumptions</font>

199
00:08:18,349 --> 00:08:22,279
about<font color="#E5E5E5"> the number</font><font color="#CCCCCC"> of lanes you</font><font color="#E5E5E5"> have</font>

200
00:08:19,550 --> 00:08:24,499
<font color="#CCCCCC">available to</font><font color="#E5E5E5"> you so the idea is you</font><font color="#CCCCCC"> can</font>

201
00:08:22,279 --> 00:08:26,179
write code<font color="#E5E5E5"> that</font><font color="#CCCCCC"> will run on your</font><font color="#E5E5E5"> phone</font>

202
00:08:24,499 --> 00:08:28,610
which might have a small vector<font color="#E5E5E5"> length</font>

203
00:08:26,179 --> 00:08:30,258
<font color="#CCCCCC">and without having</font><font color="#E5E5E5"> to recompile it also</font>

204
00:08:28,610 --> 00:08:31,849
<font color="#E5E5E5">run it on a supercomputer with a wide</font>

205
00:08:30,259 --> 00:08:35,659
vector length and<font color="#E5E5E5"> just get an automatic</font>

206
00:08:31,849 --> 00:08:39,229
<font color="#E5E5E5">performance boost let's have a look at</font>

207
00:08:35,659 --> 00:08:42,558
an example<font color="#E5E5E5"> so this is a classic C string</font>

208
00:08:39,229 --> 00:08:44,029
copy<font color="#CCCCCC"> function I guess</font><font color="#E5E5E5"> quite a number</font><font color="#CCCCCC"> of</font>

209
00:08:42,558 --> 00:08:46,459
you could probably come up<font color="#CCCCCC"> with a simple</font>

210
00:08:44,029 --> 00:08:48,589
assembler<font color="#E5E5E5"> function to loop through</font>

211
00:08:46,459 --> 00:08:50,829
reading a byte at a time<font color="#E5E5E5"> and then</font>

212
00:08:48,589 --> 00:08:53,630
storing<font color="#E5E5E5"> the string of the destination</font>

213
00:08:50,829 --> 00:08:54,800
<font color="#E5E5E5">but how would we do this if we wanted</font><font color="#CCCCCC"> to</font>

214
00:08:53,630 --> 00:08:56,990
operate<font color="#E5E5E5"> it on</font>

215
00:08:54,800 --> 00:09:00,140
number<font color="#E5E5E5"> of bikes at a time in a vector</font>

216
00:08:56,990 --> 00:09:03,170
register so prepare yourself<font color="#E5E5E5"> here's some</font>

217
00:09:00,140 --> 00:09:04,279
assembly you don't have to look<font color="#E5E5E5"> at take</font>

218
00:09:03,170 --> 00:09:08,630
this all<font color="#E5E5E5"> in at once I'm going to go</font>

219
00:09:04,279 --> 00:09:11,810
through it<font color="#E5E5E5"> bit by</font><font color="#CCCCCC"> bit but that is the</font>

220
00:09:08,630 --> 00:09:13,880
complete string copy so one of the keys

221
00:09:11,810 --> 00:09:16,339
<font color="#CCCCCC">to</font><font color="#E5E5E5"> understanding</font><font color="#CCCCCC"> how sve works is the</font>

222
00:09:13,880 --> 00:09:18,439
idea of<font color="#E5E5E5"> the predicate register so a</font>

223
00:09:16,339 --> 00:09:20,750
<font color="#E5E5E5">number of operations either set the</font>

224
00:09:18,440 --> 00:09:22,820
register or use the register to control

225
00:09:20,750 --> 00:09:25,010
the vector operations themselves<font color="#CCCCCC"> so if</font>

226
00:09:22,820 --> 00:09:27,079
we look<font color="#E5E5E5"> at our vectorized ad from</font>

227
00:09:25,010 --> 00:09:29,660
earlier it's now<font color="#E5E5E5"> being controlled by</font>

228
00:09:27,079 --> 00:09:31,609
this<font color="#E5E5E5"> predicate register P so in this</font>

229
00:09:29,660 --> 00:09:34,370
example<font color="#E5E5E5"> the predicate register</font><font color="#CCCCCC"> only</font>

230
00:09:31,610 --> 00:09:36,350
allows two of the lanes<font color="#E5E5E5"> to be calculated</font>

231
00:09:34,370 --> 00:09:37,810
and leaving the<font color="#CCCCCC"> other values completely</font>

232
00:09:36,350 --> 00:09:40,850
<font color="#E5E5E5">untouched</font>

233
00:09:37,810 --> 00:09:42,949
so let's look<font color="#E5E5E5"> again at the assembler so</font>

234
00:09:40,850 --> 00:09:46,010
these first<font color="#E5E5E5"> two instructions are</font><font color="#CCCCCC"> setting</font>

235
00:09:42,950 --> 00:09:50,240
<font color="#E5E5E5">this up for</font><font color="#CCCCCC"> the copy so the first</font>

236
00:09:46,010 --> 00:09:52,399
instruction<font color="#CCCCCC"> P true so the</font><font color="#E5E5E5"> P true P 2</font>

237
00:09:50,240 --> 00:09:55,040
sets the predicate register PT<font color="#CCCCCC"> to all</font>

238
00:09:52,399 --> 00:09:57,200
truth so we don't actually know how wide

239
00:09:55,040 --> 00:09:59,959
the register is but it's<font color="#CCCCCC"> just</font><font color="#E5E5E5"> saying</font><font color="#CCCCCC"> use</font>

240
00:09:57,200 --> 00:10:03,500
all<font color="#E5E5E5"> the</font><font color="#CCCCCC"> available registers</font><font color="#E5E5E5"> when we're</font>

241
00:09:59,959 --> 00:10:06,500
<font color="#E5E5E5">using this predicate register so the</font>

242
00:10:03,500 --> 00:10:08,209
next step is to load as<font color="#CCCCCC"> much of our</font>

243
00:10:06,500 --> 00:10:10,610
source string as possible into<font color="#CCCCCC"> the Z</font>

244
00:10:08,209 --> 00:10:12,140
register but you can see there's

245
00:10:10,610 --> 00:10:14,959
actually<font color="#E5E5E5"> two additional instructions</font>

246
00:10:12,140 --> 00:10:16,939
around this<font color="#CCCCCC"> this set FFR and read FFR</font>

247
00:10:14,959 --> 00:10:19,489
and this these<font color="#E5E5E5"> are referring to</font><font color="#CCCCCC"> a thing</font>

248
00:10:16,940 --> 00:10:20,510
<font color="#E5E5E5">called the first fault register let's</font>

249
00:10:19,490 --> 00:10:23,300
<font color="#E5E5E5">just have a quick</font><font color="#CCCCCC"> look at that</font>

250
00:10:20,510 --> 00:10:24,649
so the first<font color="#CCCCCC"> fault register solves one</font>

251
00:10:23,300 --> 00:10:26,870
of<font color="#E5E5E5"> the problems you have when you're</font>

252
00:10:24,649 --> 00:10:28,579
dealing<font color="#E5E5E5"> with large chunks</font><font color="#CCCCCC"> of data</font><font color="#E5E5E5"> of</font>

253
00:10:26,870 --> 00:10:31,610
when you have to go over<font color="#E5E5E5"> things</font><font color="#CCCCCC"> like</font>

254
00:10:28,579 --> 00:10:34,160
page boundaries it might be<font color="#E5E5E5"> our string</font>

255
00:10:31,610 --> 00:10:35,959
finishes<font color="#CCCCCC"> just before a page boundary</font><font color="#E5E5E5"> but</font>

256
00:10:34,160 --> 00:10:38,420
if we're reading<font color="#E5E5E5"> things in big chunk at</font>

257
00:10:35,959 --> 00:10:41,119
a time<font color="#E5E5E5"> we'll run over the page boundary</font>

258
00:10:38,420 --> 00:10:42,560
and generate a fault<font color="#E5E5E5"> this is obviously</font>

259
00:10:41,120 --> 00:10:44,180
<font color="#E5E5E5">going to suck for performance so what</font>

260
00:10:42,560 --> 00:10:46,760
<font color="#E5E5E5">the first fault register allows us to do</font>

261
00:10:44,180 --> 00:10:49,189
is speculatively load as<font color="#CCCCCC"> much data that</font>

262
00:10:46,760 --> 00:10:52,510
<font color="#E5E5E5">is possible</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> then the</font><font color="#CCCCCC"> first Fault</font>

263
00:10:49,190 --> 00:10:55,040
register will report<font color="#E5E5E5"> how far we got</font>

264
00:10:52,510 --> 00:10:56,870
afterwards so here we go we've got<font color="#CCCCCC"> setup</font>

265
00:10:55,040 --> 00:10:59,360
<font color="#CCCCCC">if</font><font color="#E5E5E5"> our sets the first fault register and</font>

266
00:10:56,870 --> 00:11:02,690
says load as many bytes as we can based

267
00:10:59,360 --> 00:11:04,790
<font color="#E5E5E5">on our predicate register</font><font color="#CCCCCC"> then finally</font>

268
00:11:02,690 --> 00:11:05,920
we read the first fault register into p0

269
00:11:04,790 --> 00:11:07,660
p0

270
00:11:05,920 --> 00:11:11,229
<font color="#E5E5E5">is now set to the number of bytes</font><font color="#CCCCCC"> that</font>

271
00:11:07,660 --> 00:11:13,870
we actually<font color="#CCCCCC"> read so it's either</font><font color="#E5E5E5"> the full</font>

272
00:11:11,230 --> 00:11:16,959
<font color="#CCCCCC">vector length but if it faulted</font><font color="#E5E5E5"> it might</font>

273
00:11:13,870 --> 00:11:18,639
truncate to the end of the page so the

274
00:11:16,959 --> 00:11:21,160
next thing we<font color="#CCCCCC"> need to do is we need to</font>

275
00:11:18,639 --> 00:11:22,449
<font color="#E5E5E5">test</font><font color="#CCCCCC"> for a null termination</font><font color="#E5E5E5"> so again</font>

276
00:11:21,160 --> 00:11:24,399
we're doing<font color="#CCCCCC"> this across the whole vector</font>

277
00:11:22,449 --> 00:11:26,649
<font color="#E5E5E5">register at once and this compare</font>

278
00:11:24,399 --> 00:11:29,279
instruction basically<font color="#E5E5E5"> sets the predicate</font>

279
00:11:26,649 --> 00:11:33,339
register for every byte<font color="#E5E5E5"> that has a</font>

280
00:11:29,279 --> 00:11:36,310
terminating<font color="#CCCCCC"> zero in it the next</font>

281
00:11:33,339 --> 00:11:39,820
<font color="#CCCCCC">instruction the break</font><font color="#E5E5E5"> a simply sets</font>

282
00:11:36,310 --> 00:11:42,010
another<font color="#E5E5E5"> predicate register p0 to be at</font>

283
00:11:39,820 --> 00:11:43,839
the point<font color="#E5E5E5"> of the first</font><font color="#CCCCCC"> zero because we</font>

284
00:11:42,010 --> 00:11:46,510
don't want<font color="#E5E5E5"> to copy any zeros</font><font color="#CCCCCC"> after our</font>

285
00:11:43,839 --> 00:11:50,139
terminating<font color="#E5E5E5"> the termination of the</font>

286
00:11:46,510 --> 00:11:52,540
<font color="#E5E5E5">string finally we need to store the</font>

287
00:11:50,139 --> 00:11:55,029
result back so now we're using<font color="#E5E5E5"> the p0</font>

288
00:11:52,540 --> 00:11:56,649
predicate register<font color="#E5E5E5"> which is exactly the</font>

289
00:11:55,029 --> 00:11:59,459
number<font color="#CCCCCC"> of bytes that we need to do and</font>

290
00:11:56,649 --> 00:12:02,350
we store that<font color="#E5E5E5"> back</font><font color="#CCCCCC"> into our</font><font color="#E5E5E5"> destination</font>

291
00:11:59,459 --> 00:12:03,399
<font color="#E5E5E5">and finally we need</font><font color="#CCCCCC"> to know how many</font>

292
00:12:02,350 --> 00:12:06,490
bytes did we copy

293
00:12:03,399 --> 00:12:07,750
so we increment<font color="#E5E5E5"> x2 with the number of</font>

294
00:12:06,490 --> 00:12:09,910
bytes that<font color="#E5E5E5"> was</font><font color="#CCCCCC"> involved in the</font>

295
00:12:07,750 --> 00:12:11,800
operations<font color="#E5E5E5"> so all of this code doesn't</font>

296
00:12:09,910 --> 00:12:14,680
actually have any knowledge<font color="#E5E5E5"> of the size</font>

297
00:12:11,800 --> 00:12:17,380
of<font color="#E5E5E5"> the</font><font color="#CCCCCC"> vector</font><font color="#E5E5E5"> but it's still in copy as</font>

298
00:12:14,680 --> 00:12:20,140
met as many bytes as possible at once

299
00:12:17,380 --> 00:12:22,329
<font color="#E5E5E5">now if you want to compare this to some</font>

300
00:12:20,140 --> 00:12:25,120
other<font color="#E5E5E5"> code you can go and dive into</font><font color="#CCCCCC"> G</font>

301
00:12:22,329 --> 00:12:26,859
<font color="#CCCCCC">Lipsey's string copy functions there's a</font>

302
00:12:25,120 --> 00:12:29,440
directory called<font color="#CCCCCC"> systems</font><font color="#E5E5E5"> and you'll see</font>

303
00:12:26,860 --> 00:12:31,420
that with some<font color="#E5E5E5"> of the other vectorized</font>

304
00:12:29,440 --> 00:12:32,740
<font color="#E5E5E5">support there you have to go through</font>

305
00:12:31,420 --> 00:12:34,839
<font color="#E5E5E5">extraordinary lengths to make</font><font color="#CCCCCC"> sure</font>

306
00:12:32,740 --> 00:12:36,490
things<font color="#E5E5E5"> are aligned and you're not about</font>

307
00:12:34,839 --> 00:12:40,420
<font color="#CCCCCC">to run over there and</font><font color="#E5E5E5"> edge and stuff</font>

308
00:12:36,490 --> 00:12:42,880
like that<font color="#E5E5E5"> so before we move on to</font><font color="#CCCCCC"> the</font>

309
00:12:40,420 --> 00:12:44,979
<font color="#E5E5E5">next bit let's just recap we've talked</font>

310
00:12:42,880 --> 00:12:47,500
<font color="#E5E5E5">about virtual</font><font color="#CCCCCC"> age virtualization we've</font>

311
00:12:44,980 --> 00:12:50,680
got many<font color="#E5E5E5"> flavors software based and the</font>

312
00:12:47,500 --> 00:12:52,540
hardware based vectors have been around

313
00:12:50,680 --> 00:12:54,849
a long<font color="#E5E5E5"> time but their usage is growing</font>

314
00:12:52,540 --> 00:12:57,279
<font color="#E5E5E5">especially given all the</font><font color="#CCCCCC"> data intensive</font>

315
00:12:54,850 --> 00:12:59,470
processing we have<font color="#CCCCCC"> to do and that key</font>

316
00:12:57,279 --> 00:13:02,199
feature is their length<font color="#E5E5E5"> which makes them</font>

317
00:12:59,470 --> 00:13:07,000
<font color="#CCCCCC">very useful</font><font color="#E5E5E5"> when the task exhibits data</font>

318
00:13:02,199 --> 00:13:08,769
parallelism<font color="#E5E5E5"> so let's talk about the</font>

319
00:13:07,000 --> 00:13:11,079
challenges<font color="#E5E5E5"> that vectors present in a</font>

320
00:13:08,769 --> 00:13:15,190
pure software virtualization<font color="#CCCCCC"> if we're</font>

321
00:13:11,079 --> 00:13:16,780
<font color="#E5E5E5">using</font><font color="#CCCCCC"> chrome use tiny code generator now</font>

322
00:13:15,190 --> 00:13:18,820
we have a problem

323
00:13:16,780 --> 00:13:21,250
<font color="#E5E5E5">Chrome your aims to be a flexible system</font>

324
00:13:18,820 --> 00:13:23,590
<font color="#E5E5E5">so it operates</font><font color="#CCCCCC"> on a large</font><font color="#E5E5E5"> number of</font>

325
00:13:21,250 --> 00:13:25,420
<font color="#E5E5E5">guest architectures there's currently 20</font>

326
00:13:23,590 --> 00:13:28,210
but we're going<font color="#E5E5E5"> to be 21 soon when the</font>

327
00:13:25,420 --> 00:13:30,010
<font color="#CCCCCC">risky stuff gets merged</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> back end</font>

328
00:13:28,210 --> 00:13:31,990
also<font color="#E5E5E5"> supports most of the popular</font>

329
00:13:30,010 --> 00:13:34,960
architectures<font color="#CCCCCC"> so we have to have a</font>

330
00:13:31,990 --> 00:13:38,560
system<font color="#CCCCCC"> that makes</font><font color="#E5E5E5"> takes full advantage</font>

331
00:13:34,960 --> 00:13:40,300
of the architectures that<font color="#E5E5E5"> we're on but</font>

332
00:13:38,560 --> 00:13:42,699
<font color="#E5E5E5">without being</font><font color="#CCCCCC"> hard-coded for any</font>

333
00:13:40,300 --> 00:13:44,770
<font color="#E5E5E5">particular</font><font color="#CCCCCC"> x2y translation and this</font>

334
00:13:42,700 --> 00:13:48,630
means we we have to be more<font color="#CCCCCC"> flexible</font>

335
00:13:44,770 --> 00:13:51,240
than<font color="#E5E5E5"> a lot of single</font><font color="#CCCCCC"> purpose translators</font>

336
00:13:48,630 --> 00:13:54,520
now why do we do<font color="#CCCCCC"> cogeneration</font>

337
00:13:51,240 --> 00:13:57,880
well<font color="#CCCCCC"> interpreting instructions is going</font>

338
00:13:54,520 --> 00:13:59,350
to be slow<font color="#E5E5E5"> and all</font><font color="#CCCCCC"> processes have common</font>

339
00:13:57,880 --> 00:14:01,510
functionality<font color="#E5E5E5"> they all do logic</font>

340
00:13:59,350 --> 00:14:03,610
arithmetic flow control<font color="#E5E5E5"> we should take</font>

341
00:14:01,510 --> 00:14:05,830
advantage<font color="#E5E5E5"> of the features the</font><font color="#CCCCCC"> hosts that</font>

342
00:14:03,610 --> 00:14:08,320
<font color="#E5E5E5">we're</font><font color="#CCCCCC"> running on so you can think</font><font color="#E5E5E5"> of</font>

343
00:14:05,830 --> 00:14:09,610
cogeneration is simply a compiler<font color="#E5E5E5"> but</font>

344
00:14:08,320 --> 00:14:11,890
instead of<font color="#CCCCCC"> working with source code</font>

345
00:14:09,610 --> 00:14:15,850
we're working with the<font color="#E5E5E5"> machine code of</font>

346
00:14:11,890 --> 00:14:18,640
our<font color="#CCCCCC"> guest now the process is fairly</font>

347
00:14:15,850 --> 00:14:21,730
<font color="#E5E5E5">simple on demand we take a block of</font>

348
00:14:18,640 --> 00:14:23,650
<font color="#E5E5E5">machine code from the target we convert</font>

349
00:14:21,730 --> 00:14:26,080
it into an<font color="#CCCCCC"> intermediate form from</font><font color="#E5E5E5"> which</font>

350
00:14:23,650 --> 00:14:29,829
the final<font color="#CCCCCC"> gist of code is generated and</font>

351
00:14:26,080 --> 00:14:34,090
<font color="#E5E5E5">we call this TCG ups so let's have a</font>

352
00:14:29,830 --> 00:14:35,920
<font color="#E5E5E5">look at an example so this</font><font color="#CCCCCC"> is a fragment</font>

353
00:14:34,090 --> 00:14:38,470
from<font color="#E5E5E5"> a little benchmarking utility that</font>

354
00:14:35,920 --> 00:14:40,990
<font color="#E5E5E5">I wrote to test out vectorizable kernels</font>

355
00:14:38,470 --> 00:14:42,370
<font color="#E5E5E5">it's a very simple one it's simply going</font>

356
00:14:40,990 --> 00:14:45,990
through<font color="#E5E5E5"> an array of floating-point</font>

357
00:14:42,370 --> 00:14:45,990
numbers and multiplying<font color="#E5E5E5"> them together</font>

358
00:14:46,230 --> 00:14:52,330
<font color="#E5E5E5">let's look at the assembly just quickly</font>

359
00:14:48,580 --> 00:14:55,480
step by step load the two<font color="#E5E5E5"> values from</font>

360
00:14:52,330 --> 00:14:57,970
our two pointers we do multiplication

361
00:14:55,480 --> 00:14:59,680
you'll see here<font color="#CCCCCC"> that</font><font color="#E5E5E5"> the guest code that</font>

362
00:14:57,970 --> 00:15:01,240
we're running<font color="#E5E5E5"> is actually vectorized</font><font color="#CCCCCC"> so</font>

363
00:14:59,680 --> 00:15:05,040
it's actually<font color="#E5E5E5"> doing four multiplies at a</font>

364
00:15:01,240 --> 00:15:07,630
time and then finally<font color="#CCCCCC"> we save the result</font>

365
00:15:05,040 --> 00:15:09,189
so<font color="#E5E5E5"> let's have a look at how this is oh</font>

366
00:15:07,630 --> 00:15:10,990
sorry and then we do<font color="#CCCCCC"> our loop so let's</font>

367
00:15:09,190 --> 00:15:15,100
<font color="#CCCCCC">have a look at how this</font><font color="#E5E5E5"> is broken down</font>

368
00:15:10,990 --> 00:15:16,330
into TCG operations so the first

369
00:15:15,100 --> 00:15:20,200
instruction<font color="#E5E5E5"> this is just the first</font>

370
00:15:16,330 --> 00:15:23,260
<font color="#E5E5E5">instruction LDR</font><font color="#CCCCCC"> Q 0 X 0 X 21 so we're</font>

371
00:15:20,200 --> 00:15:27,130
loading 128 bits from<font color="#CCCCCC"> the thing that's</font>

372
00:15:23,260 --> 00:15:30,689
pointed<font color="#E5E5E5"> out X 21 indexed by a register X</font>

373
00:15:27,130 --> 00:15:33,460
0 so first of all

374
00:15:30,690 --> 00:15:37,270
we need to get the address<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the load</font>

375
00:15:33,460 --> 00:15:39,550
by adding X 0 to X 21 that's<font color="#E5E5E5"> 3</font>

376
00:15:37,270 --> 00:15:41,470
operations<font color="#E5E5E5"> the next thing we need to do</font>

377
00:15:39,550 --> 00:15:43,060
is we need<font color="#E5E5E5"> to do the load from memory</font>

378
00:15:41,470 --> 00:15:45,360
<font color="#E5E5E5">into one of the temporary registers</font>

379
00:15:43,060 --> 00:15:47,619
which will end up<font color="#E5E5E5"> being a host register</font>

380
00:15:45,360 --> 00:15:49,300
now as you can<font color="#E5E5E5"> actually see we're doing</font>

381
00:15:47,620 --> 00:15:50,740
two loads because we're doing<font color="#CCCCCC"> to</font><font color="#E5E5E5"> 64-bit</font>

382
00:15:49,300 --> 00:15:53,949
<font color="#E5E5E5">loads so we do</font><font color="#CCCCCC"> actually</font><font color="#E5E5E5"> need to</font>

383
00:15:50,740 --> 00:15:57,250
<font color="#E5E5E5">calculate the</font><font color="#CCCCCC"> offset for</font><font color="#E5E5E5"> the second part</font>

384
00:15:53,950 --> 00:15:59,110
of the load and then finally we store

385
00:15:57,250 --> 00:16:00,310
the results<font color="#E5E5E5"> into the register file</font><font color="#CCCCCC"> so</font>

386
00:15:59,110 --> 00:16:02,970
this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> créme use internal</font>

387
00:16:00,310 --> 00:16:06,339
representation of the guest CPU<font color="#E5E5E5"> state</font>

388
00:16:02,970 --> 00:16:09,250
well that's quite a lot of TCG ops<font color="#E5E5E5"> just</font>

389
00:16:06,340 --> 00:16:12,010
<font color="#CCCCCC">for our first instruction let's have a</font>

390
00:16:09,250 --> 00:16:13,570
quick<font color="#CCCCCC"> look at the calculation</font><font color="#E5E5E5"> so I'm not</font>

391
00:16:12,010 --> 00:16:18,939
<font color="#E5E5E5">going to go through this and too much</font>

392
00:16:13,570 --> 00:16:20,470
<font color="#E5E5E5">detail but the</font><font color="#CCCCCC"> firt</font><font color="#E5E5E5"> the key thing</font><font color="#CCCCCC"> to</font>

393
00:16:18,940 --> 00:16:22,390
take<font color="#E5E5E5"> away</font><font color="#CCCCCC"> from here is instead of</font>

394
00:16:20,470 --> 00:16:25,570
<font color="#CCCCCC">actually generating code we're calling a</font>

395
00:16:22,390 --> 00:16:27,819
<font color="#CCCCCC">helper function we're loading</font><font color="#E5E5E5"> two values</font>

396
00:16:25,570 --> 00:16:30,910
from registers this time that's what

397
00:16:27,820 --> 00:16:32,380
these<font color="#CCCCCC"> end offsets are call a helper</font>

398
00:16:30,910 --> 00:16:34,650
function and then we store<font color="#E5E5E5"> the result</font>

399
00:16:32,380 --> 00:16:37,300
but<font color="#E5E5E5"> this is only doing one 32-bit</font>

400
00:16:34,650 --> 00:16:40,569
operations so<font color="#CCCCCC"> we actually need</font><font color="#E5E5E5"> to repeat</font>

401
00:16:37,300 --> 00:16:42,550
<font color="#E5E5E5">that code</font><font color="#CCCCCC"> another three</font><font color="#E5E5E5"> times so this</font>

402
00:16:40,570 --> 00:16:44,380
<font color="#E5E5E5">isn't too bad</font><font color="#CCCCCC"> if we're doing four</font>

403
00:16:42,550 --> 00:16:46,689
multiplies but it seemed<font color="#E5E5E5"> going to add up</font>

404
00:16:44,380 --> 00:16:49,600
if we do<font color="#CCCCCC"> sixteen multiplies on an</font>

405
00:16:46,690 --> 00:16:52,600
avx-512 or 64 potential multipliers

406
00:16:49,600 --> 00:16:54,390
<font color="#CCCCCC">we've got a</font><font color="#E5E5E5"> full width SV register and</font>

407
00:16:52,600 --> 00:16:57,040
why are we<font color="#E5E5E5"> going through</font><font color="#CCCCCC"> all</font><font color="#E5E5E5"> this</font>

408
00:16:54,390 --> 00:16:59,710
<font color="#E5E5E5">marshalling process well TCG only really</font>

409
00:16:57,040 --> 00:17:02,400
understands two things<font color="#E5E5E5"> it understands</font>

410
00:16:59,710 --> 00:17:05,470
32-bit registers<font color="#E5E5E5"> and 64-bit registers</font>

411
00:17:02,400 --> 00:17:07,270
the other two types are<font color="#E5E5E5"> just aliases</font>

412
00:17:05,470 --> 00:17:10,180
depending on the size<font color="#E5E5E5"> of your</font><font color="#CCCCCC"> guest and</font>

413
00:17:07,270 --> 00:17:11,980
<font color="#E5E5E5">the size of your</font><font color="#CCCCCC"> host so clearly it's</font>

414
00:17:10,180 --> 00:17:13,570
time for the TCG to move with the times

415
00:17:11,980 --> 00:17:17,589
and<font color="#E5E5E5"> actually</font><font color="#CCCCCC"> have</font><font color="#E5E5E5"> first-class</font><font color="#CCCCCC"> support</font>

416
00:17:13,569 --> 00:17:19,480
for<font color="#E5E5E5"> these</font><font color="#CCCCCC"> factors but</font><font color="#E5E5E5"> there</font><font color="#CCCCCC"> are a</font><font color="#E5E5E5"> couple</font>

417
00:17:17,589 --> 00:17:21,490
of<font color="#E5E5E5"> problems</font><font color="#CCCCCC"> we need</font><font color="#E5E5E5"> to get over first so</font>

418
00:17:19,480 --> 00:17:24,430
<font color="#CCCCCC">the first</font><font color="#E5E5E5"> of all is there is an</font>

419
00:17:21,490 --> 00:17:25,150
<font color="#CCCCCC">intrinsic</font><font color="#E5E5E5"> link between TCG types and TCG</font>

420
00:17:24,430 --> 00:17:30,430
operations

421
00:17:25,150 --> 00:17:33,910
so this<font color="#CCCCCC"> add</font><font color="#E5E5E5"> I so add immediate we have a</font>

422
00:17:30,430 --> 00:17:36,490
<font color="#E5E5E5">32-bit version and a 64-bit version so</font>

423
00:17:33,910 --> 00:17:40,900
with that in mind<font color="#CCCCCC"> how are we going to</font>

424
00:17:36,490 --> 00:17:43,000
define<font color="#CCCCCC"> our</font><font color="#E5E5E5"> types of vectors so one naive</font>

425
00:17:40,900 --> 00:17:43,539
approach is we could<font color="#CCCCCC"> just introduce</font><font color="#E5E5E5"> the</font>

426
00:17:43,000 --> 00:17:45,369
TCG

427
00:17:43,539 --> 00:17:48,720
type for<font color="#E5E5E5"> each of exercise we've got so</font>

428
00:17:45,369 --> 00:17:51,309
we could add<font color="#E5E5E5"> 128-bit in a 256 bit and</font>

429
00:17:48,720 --> 00:17:54,820
512 bit and<font color="#CCCCCC"> actually it's gonna go on</font>

430
00:17:51,309 --> 00:17:58,299
<font color="#E5E5E5">quite a bit already</font><font color="#CCCCCC"> but that's not</font>

431
00:17:54,820 --> 00:18:00,460
<font color="#CCCCCC">actually enough</font><font color="#E5E5E5"> we actually doing</font>

432
00:17:58,299 --> 00:18:04,210
<font color="#CCCCCC">operations on smaller chunks of those</font>

433
00:18:00,460 --> 00:18:07,059
vectors<font color="#E5E5E5"> so for example we might be</font>

434
00:18:04,210 --> 00:18:10,059
<font color="#E5E5E5">operating on</font><font color="#CCCCCC"> 264 operations at a time of</font>

435
00:18:07,059 --> 00:18:11,979
four 32-bit operations at times so maybe

436
00:18:10,059 --> 00:18:15,100
we<font color="#CCCCCC"> need a type to represent each layout</font>

437
00:18:11,979 --> 00:18:17,619
of the vector but even that's<font color="#E5E5E5"> not enough</font>

438
00:18:15,100 --> 00:18:21,399
<font color="#CCCCCC">because most vector operations can also</font>

439
00:18:17,619 --> 00:18:22,779
run on smaller than<font color="#E5E5E5"> 32-bit size</font><font color="#CCCCCC"> one</font>

440
00:18:21,399 --> 00:18:25,090
thing<font color="#E5E5E5"> that's been introduced recently is</font>

441
00:18:22,779 --> 00:18:29,229
half precision<font color="#E5E5E5"> calculations 16-bit</font>

442
00:18:25,090 --> 00:18:32,379
values so you<font color="#CCCCCC"> end up with a an exploding</font>

443
00:18:29,229 --> 00:18:34,749
plethora of<font color="#E5E5E5"> TCG types and that's a</font>

444
00:18:32,379 --> 00:18:37,570
problem<font color="#CCCCCC"> because</font><font color="#E5E5E5"> for each TCG type we're</font>

445
00:18:34,749 --> 00:18:39,940
<font color="#E5E5E5">introduced we're introducing more TCG</font>

446
00:18:37,570 --> 00:18:43,928
operations so we<font color="#E5E5E5"> need to go with</font>

447
00:18:39,940 --> 00:18:46,929
something<font color="#CCCCCC"> that's a little</font><font color="#E5E5E5"> bit smarter so</font>

448
00:18:43,929 --> 00:18:49,149
we<font color="#CCCCCC"> introduced</font><font color="#E5E5E5"> a thing called TCG vet so</font>

449
00:18:46,929 --> 00:18:52,090
this is a special type that represents a

450
00:18:49,149 --> 00:18:54,478
<font color="#CCCCCC">vector and</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> knew from the start that</font>

451
00:18:52,090 --> 00:18:56,678
we<font color="#E5E5E5"> needed to support multiple exercises</font>

452
00:18:54,479 --> 00:18:58,570
<font color="#E5E5E5">as I've pointed out there's been</font><font color="#CCCCCC"> a</font>

453
00:18:56,679 --> 00:18:59,950
steady growth<font color="#E5E5E5"> in the size of vectors and</font>

454
00:18:58,570 --> 00:19:03,489
it's not a trend<font color="#E5E5E5"> that's likely to stop</font>

455
00:18:59,950 --> 00:19:05,080
even sve whether it's<font color="#E5E5E5"> two</font><font color="#CCCCCC"> kilobit</font><font color="#E5E5E5"> vector</font>

456
00:19:03,489 --> 00:19:08,080
support leaves plenty<font color="#E5E5E5"> of space in the</font>

457
00:19:05,080 --> 00:19:09,519
architecture to have<font color="#E5E5E5"> even bigger ones so</font>

458
00:19:08,080 --> 00:19:14,428
we need to do this in a way<font color="#CCCCCC"> that doesn't</font>

459
00:19:09,519 --> 00:19:16,419
<font color="#E5E5E5">explode the TCG up space</font><font color="#CCCCCC"> and secondly</font>

460
00:19:14,429 --> 00:19:18,190
<font color="#E5E5E5">helpers are still going to dominate</font>

461
00:19:16,419 --> 00:19:19,419
things like<font color="#CCCCCC"> floating-point and it's</font>

462
00:19:18,190 --> 00:19:21,879
likely<font color="#CCCCCC"> to</font><font color="#E5E5E5"> do so for the foreseeable</font>

463
00:19:19,419 --> 00:19:24,039
<font color="#CCCCCC">future so we need an interface that's</font>

464
00:19:21,879 --> 00:19:26,019
presented to<font color="#E5E5E5"> our helper functions that</font>

465
00:19:24,039 --> 00:19:27,429
doesn't there should be as efficient<font color="#CCCCCC"> as</font>

466
00:19:26,019 --> 00:19:29,019
possible<font color="#E5E5E5"> so we</font><font color="#CCCCCC"> don't want to</font><font color="#E5E5E5"> end up</font>

467
00:19:27,429 --> 00:19:32,019
<font color="#CCCCCC">doing lots of</font><font color="#E5E5E5"> marshaling back and forth</font>

468
00:19:29,019 --> 00:19:34,090
<font color="#E5E5E5">between registers so we avoid the</font>

469
00:19:32,019 --> 00:19:37,239
<font color="#CCCCCC">marshalling by</font><font color="#E5E5E5"> passing pointers directly</font>

470
00:19:34,090 --> 00:19:38,559
into<font color="#CCCCCC"> our</font><font color="#E5E5E5"> CPU environment this does</font>

471
00:19:37,239 --> 00:19:40,749
actually<font color="#CCCCCC"> help</font><font color="#E5E5E5"> the helpers as well it</font>

472
00:19:38,559 --> 00:19:42,039
means<font color="#E5E5E5"> the compiler can vectorize the</font>

473
00:19:40,749 --> 00:19:45,340
helper function which gives us a bit of

474
00:19:42,039 --> 00:19:47,049
performance<font color="#E5E5E5"> back and finally there are</font>

475
00:19:45,340 --> 00:19:49,418
<font color="#E5E5E5">enough operations that can still be</font>

476
00:19:47,049 --> 00:19:51,908
dealt with in generated<font color="#CCCCCC"> codes we need to</font>

477
00:19:49,419 --> 00:19:53,259
maintain the<font color="#CCCCCC"> ability to do that and we</font>

478
00:19:51,909 --> 00:19:56,259
<font color="#E5E5E5">need to</font><font color="#CCCCCC"> ensure that there's enough</font>

479
00:19:53,259 --> 00:19:56,570
<font color="#E5E5E5">information in each TCG operation that</font>

480
00:19:56,259 --> 00:19:58,700
the

481
00:19:56,570 --> 00:20:01,360
<font color="#CCCCCC">and can make the most efficient use of</font>

482
00:19:58,700 --> 00:20:03,800
the host processor that it's<font color="#E5E5E5"> running on</font>

483
00:20:01,360 --> 00:20:06,320
so let's just have<font color="#CCCCCC"> a quick</font><font color="#E5E5E5"> look at the</font>

484
00:20:03,800 --> 00:20:09,290
sort of<font color="#E5E5E5"> TC gir that</font><font color="#CCCCCC"> we get with a TCG</font>

485
00:20:06,320 --> 00:20:12,879
<font color="#CCCCCC">rep so here we go we have</font><font color="#E5E5E5"> the guest</font>

486
00:20:09,290 --> 00:20:14,930
instruction here as a<font color="#E5E5E5"> 128 bit</font><font color="#CCCCCC"> X or</font>

487
00:20:12,880 --> 00:20:16,730
working<font color="#E5E5E5"> byte wise but it doesn't really</font>

488
00:20:14,930 --> 00:20:19,550
<font color="#E5E5E5">matter because an</font><font color="#CCCCCC"> XOR</font><font color="#E5E5E5"> is an</font><font color="#CCCCCC"> XOR it's you</font>

489
00:20:16,730 --> 00:20:21,290
don't care<font color="#CCCCCC"> about each bit</font><font color="#E5E5E5"> but now you</font>

490
00:20:19,550 --> 00:20:22,909
can<font color="#E5E5E5"> see we've got</font><font color="#CCCCCC"> quite a nice compact</font>

491
00:20:21,290 --> 00:20:24,590
representation of<font color="#CCCCCC"> that instruction</font><font color="#E5E5E5"> we</font>

492
00:20:22,910 --> 00:20:26,240
still have to deal with<font color="#E5E5E5"> loading the</font>

493
00:20:24,590 --> 00:20:29,179
value from<font color="#E5E5E5"> the register and storing it</font>

494
00:20:26,240 --> 00:20:32,900
back but<font color="#CCCCCC"> you can</font><font color="#E5E5E5"> see that the generated</font>

495
00:20:29,180 --> 00:20:35,180
<font color="#CCCCCC">code now</font><font color="#E5E5E5"> is a lot more compact in fact</font>

496
00:20:32,900 --> 00:20:37,340
because we're<font color="#E5E5E5"> running on a x86 that's</font>

497
00:20:35,180 --> 00:20:40,000
got SSE we can take full advantage<font color="#CCCCCC"> of</font>

498
00:20:37,340 --> 00:20:43,580
the<font color="#E5E5E5"> SSE registers and do the operation</font>

499
00:20:40,000 --> 00:20:45,560
<font color="#E5E5E5">128 bits at a</font><font color="#CCCCCC"> time so we've got much</font>

500
00:20:43,580 --> 00:20:47,810
closer mapping<font color="#CCCCCC"> with between</font><font color="#E5E5E5"> the guest</font>

501
00:20:45,560 --> 00:20:52,040
vector operation<font color="#E5E5E5"> and the host vector</font>

502
00:20:47,810 --> 00:20:54,409
operation so this gives us<font color="#E5E5E5"> better</font>

503
00:20:52,040 --> 00:20:55,970
<font color="#CCCCCC">cogeneration</font><font color="#E5E5E5"> and it also gives us more</font>

504
00:20:54,410 --> 00:20:57,500
efficient helpers for<font color="#E5E5E5"> the times that we</font>

505
00:20:55,970 --> 00:20:59,920
need<font color="#E5E5E5"> it so let's have a look at the</font>

506
00:20:57,500 --> 00:21:03,950
blazing performance<font color="#E5E5E5"> that we now have</font>

507
00:20:59,920 --> 00:21:05,390
<font color="#CCCCCC">well that's a little</font><font color="#E5E5E5"> disappointing so in</font>

508
00:21:03,950 --> 00:21:07,940
most<font color="#E5E5E5"> of the test cases we've</font><font color="#CCCCCC"> got here</font>

509
00:21:05,390 --> 00:21:10,310
the TCG<font color="#E5E5E5"> Vic that code is running a lot</font>

510
00:21:07,940 --> 00:21:13,220
slower than<font color="#CCCCCC"> our existing TCG code that</font>

511
00:21:10,310 --> 00:21:14,870
does all the<font color="#CCCCCC"> marshaling there is one</font>

512
00:21:13,220 --> 00:21:16,460
case though this byte wise bit fiddle

513
00:21:14,870 --> 00:21:17,750
that's running<font color="#CCCCCC"> a bit faster so</font><font color="#E5E5E5"> let's</font>

514
00:21:16,460 --> 00:21:21,800
just<font color="#E5E5E5"> have a quick</font><font color="#CCCCCC"> look at what this</font>

515
00:21:17,750 --> 00:21:24,260
function is doing so the main<font color="#CCCCCC"> difference</font>

516
00:21:21,800 --> 00:21:27,320
here<font color="#E5E5E5"> is the bit fiddle is doing more</font>

517
00:21:24,260 --> 00:21:28,970
logic operations per loop in fact this

518
00:21:27,320 --> 00:21:31,669
is<font color="#CCCCCC"> exactly the reason Seymour Cray</font>

519
00:21:28,970 --> 00:21:33,680
introduced vectors back in the 70s<font color="#E5E5E5"> his</font>

520
00:21:31,670 --> 00:21:35,660
<font color="#CCCCCC">observation was although the process of</font>

521
00:21:33,680 --> 00:21:38,000
loading stuff into a vector<font color="#E5E5E5"> register was</font>

522
00:21:35,660 --> 00:21:40,250
pretty expensive<font color="#E5E5E5"> when you chain</font>

523
00:21:38,000 --> 00:21:41,750
operations<font color="#CCCCCC"> together staying in the</font>

524
00:21:40,250 --> 00:21:45,140
registers you could get that performance

525
00:21:41,750 --> 00:21:47,660
<font color="#E5E5E5">back</font><font color="#CCCCCC"> as</font><font color="#E5E5E5"> I say might</font><font color="#CCCCCC"> be clearer if</font><font color="#E5E5E5"> we</font>

526
00:21:45,140 --> 00:21:49,310
<font color="#E5E5E5">look at the guest assembly don't worry</font>

527
00:21:47,660 --> 00:21:51,590
about understanding all that<font color="#E5E5E5"> but the key</font>

528
00:21:49,310 --> 00:21:55,010
<font color="#CCCCCC">thing to</font><font color="#E5E5E5"> see is he's actually doing a</font>

529
00:21:51,590 --> 00:21:56,659
<font color="#E5E5E5">lot more calculations in each loop</font><font color="#CCCCCC"> so</font>

530
00:21:55,010 --> 00:21:58,240
there<font color="#CCCCCC"> are more operations needs</font>

531
00:21:56,660 --> 00:22:01,640
translation blocks so this makes sense

532
00:21:58,240 --> 00:22:04,040
<font color="#CCCCCC">because</font><font color="#E5E5E5"> the target workloads of Cindy</font>

533
00:22:01,640 --> 00:22:06,830
instructions are aimed at processing

534
00:22:04,040 --> 00:22:09,230
large streams of data so as a result<font color="#CCCCCC"> the</font>

535
00:22:06,830 --> 00:22:10,559
CPU<font color="#E5E5E5"> designers of sacrifice latency in</font>

536
00:22:09,230 --> 00:22:12,749
<font color="#E5E5E5">favor of throughput</font>

537
00:22:10,559 --> 00:22:14,789
they're<font color="#E5E5E5"> executing a single sim D</font>

538
00:22:12,749 --> 00:22:17,940
instruction per loop is really<font color="#CCCCCC"> the</font><font color="#E5E5E5"> worst</font>

539
00:22:14,789 --> 00:22:20,999
case<font color="#E5E5E5"> you can possibly have so is there a</font>

540
00:22:17,940 --> 00:22:23,789
way<font color="#CCCCCC"> we</font><font color="#E5E5E5"> can test this I should point out</font>

541
00:22:20,999 --> 00:22:25,499
now that I'm a gentle user so let's

542
00:22:23,789 --> 00:22:27,720
recompile all my benchmarks with fun

543
00:22:25,499 --> 00:22:29,970
roll loops<font color="#E5E5E5"> now for anyone who's</font><font color="#CCCCCC"> not</font>

544
00:22:27,720 --> 00:22:32,009
<font color="#E5E5E5">familiar with this compiler optimization</font>

545
00:22:29,970 --> 00:22:33,749
<font color="#E5E5E5">this basically tells the compiler</font><font color="#CCCCCC"> to</font>

546
00:22:32,009 --> 00:22:37,019
unroll<font color="#E5E5E5"> its loop as much as it possibly</font>

547
00:22:33,749 --> 00:22:39,809
can and use as many registers and do as

548
00:22:37,019 --> 00:22:41,850
<font color="#E5E5E5">many things at once</font><font color="#CCCCCC"> and now we can see</font>

549
00:22:39,809 --> 00:22:43,590
<font color="#E5E5E5">our performance is getting a lot better</font>

550
00:22:41,850 --> 00:22:46,379
<font color="#CCCCCC">so although</font><font color="#E5E5E5"> Chrome U has improved as</font>

551
00:22:43,590 --> 00:22:48,779
well<font color="#E5E5E5"> with this fun rolled code we can</font>

552
00:22:46,379 --> 00:22:52,789
<font color="#CCCCCC">see</font><font color="#E5E5E5"> now two of our test cases</font><font color="#CCCCCC"> beat it</font>

553
00:22:48,779 --> 00:22:56,909
using the TCG<font color="#CCCCCC"> Beck implementation so</font>

554
00:22:52,789 --> 00:22:58,679
importantly<font color="#E5E5E5"> so we're getting closer</font><font color="#CCCCCC"> and</font>

555
00:22:56,909 --> 00:23:00,990
but there's a few<font color="#E5E5E5"> more things that we</font>

556
00:22:58,679 --> 00:23:04,710
need<font color="#CCCCCC"> to</font><font color="#E5E5E5"> look at so there's some further</font>

557
00:23:00,990 --> 00:23:06,990
<font color="#E5E5E5">work</font><font color="#CCCCCC"> to do</font><font color="#E5E5E5"> to look at handling of loads</font>

558
00:23:04,710 --> 00:23:08,610
<font color="#E5E5E5">and stores so this</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> the act of loading</font>

559
00:23:06,990 --> 00:23:09,990
<font color="#E5E5E5">stuff into registers from memory and</font>

560
00:23:08,610 --> 00:23:13,678
storing stuff out<font color="#E5E5E5"> that's currently not</font>

561
00:23:09,990 --> 00:23:15,450
<font color="#CCCCCC">being converted to TCG but</font><font color="#E5E5E5"> the other</font>

562
00:23:13,679 --> 00:23:17,490
thing that we need<font color="#CCCCCC"> to look at is a thing</font>

563
00:23:15,450 --> 00:23:19,230
called register liveliness<font color="#CCCCCC"> so when</font>

564
00:23:17,490 --> 00:23:20,789
you're doing a compilation<font color="#E5E5E5"> you try and</font>

565
00:23:19,230 --> 00:23:21,269
keep values in registers as long as

566
00:23:20,789 --> 00:23:23,070
possible

567
00:23:21,269 --> 00:23:24,960
and although<font color="#CCCCCC"> claimed you has to make</font>

568
00:23:23,070 --> 00:23:27,779
<font color="#CCCCCC">sure</font><font color="#E5E5E5"> that it stores the values out to</font>

569
00:23:24,960 --> 00:23:30,330
memory<font color="#CCCCCC"> after each operation to make sure</font>

570
00:23:27,779 --> 00:23:32,129
<font color="#E5E5E5">that we're always correct it could</font><font color="#CCCCCC"> do a</font>

571
00:23:30,330 --> 00:23:34,110
<font color="#E5E5E5">better job at reusing values and</font>

572
00:23:32,129 --> 00:23:36,619
registers for<font color="#E5E5E5"> the</font><font color="#CCCCCC"> following operation</font>

573
00:23:34,110 --> 00:23:39,928
rather than loading<font color="#E5E5E5"> them all back again</font>

574
00:23:36,619 --> 00:23:41,279
<font color="#CCCCCC">alright now we've looked at TCG</font><font color="#E5E5E5"> it's</font>

575
00:23:39,929 --> 00:23:43,379
time to<font color="#E5E5E5"> look at what we can do with</font>

576
00:23:41,279 --> 00:23:45,450
<font color="#CCCCCC">hardware</font><font color="#E5E5E5"> surely hardware makes things a</font>

577
00:23:43,379 --> 00:23:46,439
<font color="#E5E5E5">lot simpler right it's doing all the</font>

578
00:23:45,450 --> 00:23:49,559
hard<font color="#E5E5E5"> work</font><font color="#CCCCCC"> for us</font>

579
00:23:46,440 --> 00:23:52,049
I should note when I'm talking about<font color="#CCCCCC"> KVM</font>

580
00:23:49,559 --> 00:23:53,730
here the same sort of considerations

581
00:23:52,049 --> 00:23:56,070
<font color="#E5E5E5">also need to be made for other hardware</font>

582
00:23:53,730 --> 00:24:00,019
<font color="#E5E5E5">assisted options so there's things like</font>

583
00:23:56,070 --> 00:24:01,950
<font color="#CCCCCC">Xen hacks</font><font color="#E5E5E5"> on</font><font color="#CCCCCC"> windows and</font><font color="#E5E5E5"> HTML macros</font><font color="#CCCCCC"> so</font>

584
00:24:00,019 --> 00:24:05,220
<font color="#CCCCCC">let's</font><font color="#E5E5E5"> have a look at the</font><font color="#CCCCCC"> typical</font>

585
00:24:01,950 --> 00:24:07,499
architecture<font color="#CCCCCC"> of a virtualized machine</font><font color="#E5E5E5"> so</font>

586
00:24:05,220 --> 00:24:10,320
here we have a single<font color="#E5E5E5"> execution Union at</font>

587
00:24:07,499 --> 00:24:13,619
<font color="#E5E5E5">the CPU well if the hypervisor is a</font>

588
00:24:10,320 --> 00:24:15,720
<font color="#E5E5E5">software layer and</font><font color="#CCCCCC"> it's job is to</font><font color="#E5E5E5"> deal</font>

589
00:24:13,619 --> 00:24:18,570
<font color="#CCCCCC">with making</font><font color="#E5E5E5"> sure the shared resource of</font>

590
00:24:15,720 --> 00:24:21,169
the CPU is shared<font color="#E5E5E5"> out between the host</font>

591
00:24:18,570 --> 00:24:21,168
and<font color="#E5E5E5"> the</font><font color="#CCCCCC"> guest</font>

592
00:24:21,370 --> 00:24:28,360
and and they<font color="#CCCCCC"> can do that a</font><font color="#E5E5E5"> number of</font>

593
00:24:23,710 --> 00:24:29,890
ways so<font color="#E5E5E5"> as I say it's a shared execution</font>

594
00:24:28,360 --> 00:24:31,750
environment but for<font color="#E5E5E5"> the virtualized</font>

595
00:24:29,890 --> 00:24:34,390
guest<font color="#CCCCCC"> there are two things</font><font color="#E5E5E5"> we can do we</font>

596
00:24:31,750 --> 00:24:36,520
<font color="#CCCCCC">can trap and emulate</font><font color="#E5E5E5"> so trapping and</font>

597
00:24:34,390 --> 00:24:40,930
emulate<font color="#E5E5E5"> means</font><font color="#CCCCCC"> anytime the</font><font color="#E5E5E5"> guest access</font>

598
00:24:36,520 --> 00:24:43,720
<font color="#CCCCCC">is a virtual resource</font><font color="#E5E5E5"> you trap into the</font>

599
00:24:40,930 --> 00:24:46,050
<font color="#E5E5E5">hypervisor and the hypervisor emulates</font>

600
00:24:43,720 --> 00:24:49,059
the behavior and returns to<font color="#E5E5E5"> the guest</font>

601
00:24:46,050 --> 00:24:51,309
<font color="#E5E5E5">now this is fine if all you're doing</font><font color="#CCCCCC"> is</font>

602
00:24:49,059 --> 00:24:52,990
updating<font color="#CCCCCC"> a</font><font color="#E5E5E5"> TLB entry it's</font><font color="#CCCCCC"> a bit</font>

603
00:24:51,309 --> 00:24:55,120
<font color="#E5E5E5">expensive but</font><font color="#CCCCCC"> you're soon going</font><font color="#E5E5E5"> to get</font>

604
00:24:52,990 --> 00:24:57,040
back to running code<font color="#E5E5E5"> if you have to trap</font>

605
00:24:55,120 --> 00:24:59,020
and emulate<font color="#E5E5E5"> every time you access</font><font color="#CCCCCC"> an SVU</font>

606
00:24:57,040 --> 00:25:01,840
register your performance is<font color="#E5E5E5"> going to</font>

607
00:24:59,020 --> 00:25:04,720
<font color="#E5E5E5">fall</font><font color="#CCCCCC"> through the</font><font color="#E5E5E5"> floor it's in the next</font>

608
00:25:01,840 --> 00:25:06,280
option is to<font color="#CCCCCC"> do a context switch so we</font>

609
00:25:04,720 --> 00:25:08,559
need to copy out<font color="#CCCCCC"> the state</font><font color="#E5E5E5"> of the guest</font>

610
00:25:06,280 --> 00:25:13,330
<font color="#E5E5E5">when we return back to the host and</font><font color="#CCCCCC"> then</font>

611
00:25:08,559 --> 00:25:15,190
copy<font color="#E5E5E5"> it back at the end now this is</font>

612
00:25:13,330 --> 00:25:19,120
<font color="#E5E5E5">nothing new</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is something</font><font color="#CCCCCC"> that your</font>

613
00:25:15,190 --> 00:25:21,280
<font color="#E5E5E5">host kernel does all the time kernel has</font>

614
00:25:19,120 --> 00:25:23,949
to switch between<font color="#E5E5E5"> different</font><font color="#CCCCCC"> applications</font>

615
00:25:21,280 --> 00:25:26,260
running<font color="#E5E5E5"> and as it does</font><font color="#CCCCCC"> that it</font><font color="#E5E5E5"> copies</font>

616
00:25:23,950 --> 00:25:27,880
their state<font color="#E5E5E5"> into</font><font color="#CCCCCC"> on to the stack</font>

617
00:25:26,260 --> 00:25:30,370
<font color="#E5E5E5">switches to another state and goes back</font>

618
00:25:27,880 --> 00:25:33,610
key thing is here<font color="#E5E5E5"> occupancy is actually</font>

619
00:25:30,370 --> 00:25:35,320
quite important<font color="#CCCCCC"> so what the current</font>

620
00:25:33,610 --> 00:25:37,780
tries to do is it<font color="#E5E5E5"> tries to keep busy</font>

621
00:25:35,320 --> 00:25:40,510
tasks on the same CPU for<font color="#E5E5E5"> as long as</font>

622
00:25:37,780 --> 00:25:42,610
<font color="#CCCCCC">possible</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> if</font><font color="#E5E5E5"> possible any other tasks</font>

623
00:25:40,510 --> 00:25:45,690
that<font color="#E5E5E5"> need to run run on another CPU</font>

624
00:25:42,610 --> 00:25:47,740
resource<font color="#E5E5E5"> so your occupancy is important</font>

625
00:25:45,690 --> 00:25:51,940
let's just have a<font color="#E5E5E5"> quick</font><font color="#CCCCCC"> look at the size</font>

626
00:25:47,740 --> 00:25:53,710
of<font color="#E5E5E5"> these contexts though so an arm for</font>

627
00:25:51,940 --> 00:25:56,110
<font color="#CCCCCC">example has 32-bit general-purpose</font>

628
00:25:53,710 --> 00:25:57,910
registers<font color="#CCCCCC"> so you need to save all that</font>

629
00:25:56,110 --> 00:26:00,219
state<font color="#E5E5E5"> into memory before you switch</font>

630
00:25:57,910 --> 00:26:03,309
<font color="#E5E5E5">States</font><font color="#CCCCCC"> that's 256 bytes of data it's</font>

631
00:26:00,220 --> 00:26:05,980
quite a lot<font color="#E5E5E5"> but it's not too bad however</font>

632
00:26:03,309 --> 00:26:09,070
the<font color="#CCCCCC"> sve registers we have could</font><font color="#E5E5E5"> be a lot</font>

633
00:26:05,980 --> 00:26:10,960
bigger as<font color="#CCCCCC"> 8k is worth of data</font><font color="#E5E5E5"> so if we</font>

634
00:26:09,070 --> 00:26:13,000
suddenly start copying the whole of the

635
00:26:10,960 --> 00:26:14,470
<font color="#E5E5E5">SV you stay every time we transition</font>

636
00:26:13,000 --> 00:26:16,450
from<font color="#E5E5E5"> the host of the kernel</font><font color="#CCCCCC"> or from the</font>

637
00:26:14,470 --> 00:26:19,140
kernel to the hypervisor<font color="#CCCCCC"> things are</font>

638
00:26:16,450 --> 00:26:21,490
going to get pretty<font color="#E5E5E5"> slow pretty quick I</font>

639
00:26:19,140 --> 00:26:23,530
mean do<font color="#E5E5E5"> we have to save this context</font>

640
00:26:21,490 --> 00:26:25,150
every time certainly if you're<font color="#E5E5E5"> going to</font>

641
00:26:23,530 --> 00:26:27,340
switch<font color="#CCCCCC"> to</font><font color="#E5E5E5"> another user space process</font>

642
00:26:25,150 --> 00:26:29,350
it's highly likely it's going<font color="#E5E5E5"> to access</font>

643
00:26:27,340 --> 00:26:32,399
the vector registers<font color="#E5E5E5"> even if the</font>

644
00:26:29,350 --> 00:26:36,510
<font color="#CCCCCC">application</font><font color="#E5E5E5"> itself hasn't been compiled</font>

645
00:26:32,400 --> 00:26:37,890
as a dedicated<font color="#E5E5E5"> vectorized workload the</font>

646
00:26:36,510 --> 00:26:39,480
chances<font color="#E5E5E5"> are it's calling library</font>

647
00:26:37,890 --> 00:26:41,400
functions that are likely to<font color="#CCCCCC"> use the VEX</font>

648
00:26:39,480 --> 00:26:43,020
registers<font color="#CCCCCC"> for things like</font><font color="#E5E5E5"> string copy</font>

649
00:26:41,400 --> 00:26:45,030
mem copy and whatever<font color="#E5E5E5"> will all have</font>

650
00:26:43,020 --> 00:26:49,170
accelerated versions that<font color="#E5E5E5"> will depend on</font>

651
00:26:45,030 --> 00:26:50,760
what<font color="#CCCCCC"> your library detects</font><font color="#E5E5E5"> and there's</font>

652
00:26:49,170 --> 00:26:51,750
also the kernel now it used to be said

653
00:26:50,760 --> 00:26:54,390
<font color="#E5E5E5">that the kernel doesn't do</font>

654
00:26:51,750 --> 00:26:57,900
floating-point<font color="#E5E5E5"> that's not actually</font>

655
00:26:54,390 --> 00:26:59,700
<font color="#E5E5E5">strictly true so when it comes to</font><font color="#CCCCCC"> sim D</font>

656
00:26:57,900 --> 00:27:01,350
registers usually there's an<font color="#CCCCCC"> aliasing</font>

657
00:26:59,700 --> 00:27:04,110
<font color="#E5E5E5">between the floating-point registers and</font>

658
00:27:01,350 --> 00:27:05,790
<font color="#CCCCCC">CMD registers and the kernel certainly</font>

659
00:27:04,110 --> 00:27:09,090
take advantage<font color="#CCCCCC"> of</font><font color="#E5E5E5"> Cindy registers when</font>

660
00:27:05,790 --> 00:27:10,409
they can things like in kernel crypto or

661
00:27:09,090 --> 00:27:12,929
doing raid checksumming

662
00:27:10,410 --> 00:27:16,380
or all the things<font color="#CCCCCC"> where they use these</font>

663
00:27:12,930 --> 00:27:17,850
registers hypervisors less so

664
00:27:16,380 --> 00:27:20,190
hypervisors tend to be written to<font color="#E5E5E5"> be</font>

665
00:27:17,850 --> 00:27:24,629
very small<font color="#E5E5E5"> and tight and minimal in what</font>

666
00:27:20,190 --> 00:27:26,130
they do<font color="#E5E5E5"> so you're okay there so how can</font>

667
00:27:24,630 --> 00:27:27,630
we<font color="#E5E5E5"> make this a little bit faster well</font>

668
00:27:26,130 --> 00:27:30,720
the first thing we need to do is we need

669
00:27:27,630 --> 00:27:34,200
<font color="#E5E5E5">to detect usage okay so what we do here</font>

670
00:27:30,720 --> 00:27:38,460
<font color="#CCCCCC">is we disable access to the</font><font color="#E5E5E5"> Cindy and</font>

671
00:27:34,200 --> 00:27:40,380
<font color="#CCCCCC">FPU every time we enter</font><font color="#E5E5E5"> the guest</font><font color="#CCCCCC"> well</font>

672
00:27:38,460 --> 00:27:43,110
not every<font color="#CCCCCC"> time</font><font color="#E5E5E5"> but</font><font color="#CCCCCC"> the first</font><font color="#E5E5E5"> time and</font>

673
00:27:40,380 --> 00:27:45,450
then<font color="#E5E5E5"> the first time they access a</font><font color="#CCCCCC"> Cindy</font>

674
00:27:43,110 --> 00:27:47,850
resource that<font color="#E5E5E5"> causes</font><font color="#CCCCCC"> a trap to the</font>

675
00:27:45,450 --> 00:27:50,370
kernel at that point the kernel can<font color="#CCCCCC"> then</font>

676
00:27:47,850 --> 00:27:54,419
swap the context<font color="#E5E5E5"> then it rien a Buhl's</font>

677
00:27:50,370 --> 00:27:55,949
the sim D or<font color="#E5E5E5"> FPU processor you return to</font>

678
00:27:54,420 --> 00:27:58,850
the<font color="#CCCCCC"> tracked instruction and</font><font color="#E5E5E5"> you use the</font>

679
00:27:55,950 --> 00:28:00,690
space<font color="#E5E5E5"> process can get on with its life</font>

680
00:27:58,850 --> 00:28:03,419
we need<font color="#E5E5E5"> to do a little bit of</font>

681
00:28:00,690 --> 00:28:07,530
bookkeeping for<font color="#E5E5E5"> this though so we need</font>

682
00:28:03,420 --> 00:28:09,510
to keep<font color="#E5E5E5"> track</font><font color="#CCCCCC"> of who's Cindy</font><font color="#E5E5E5"> state we</font>

683
00:28:07,530 --> 00:28:12,120
have on each<font color="#CCCCCC"> CPUs there's a per</font><font color="#E5E5E5"> CPU</font>

684
00:28:09,510 --> 00:28:14,280
variable<font color="#E5E5E5"> to</font><font color="#CCCCCC"> that for that</font><font color="#E5E5E5"> and we also</font>

685
00:28:12,120 --> 00:28:17,070
need a per toss variable where we can

686
00:28:14,280 --> 00:28:20,460
save the Cindy<font color="#E5E5E5"> state when it's not</font><font color="#CCCCCC"> being</font>

687
00:28:17,070 --> 00:28:21,990
actively used<font color="#E5E5E5"> and now I'm reintroduced</font>

688
00:28:20,460 --> 00:28:24,030
<font color="#E5E5E5">in the additional</font><font color="#CCCCCC"> flag here this TIF</font>

689
00:28:21,990 --> 00:28:26,520
foreign FB<font color="#E5E5E5"> state and this is just simply</font>

690
00:28:24,030 --> 00:28:28,139
<font color="#CCCCCC">a state on the flag so when the kernel</font>

691
00:28:26,520 --> 00:28:30,780
<font color="#E5E5E5">the colonel knows when it switches to</font>

692
00:28:28,140 --> 00:28:34,080
<font color="#E5E5E5">use a space it</font><font color="#CCCCCC"> needs to enable trapping</font>

693
00:28:30,780 --> 00:28:37,500
so it can pick up<font color="#E5E5E5"> if the</font><font color="#CCCCCC"> Cindy stuff is</font>

694
00:28:34,080 --> 00:28:38,310
accessed so that's what we do on<font color="#CCCCCC"> a house</font>

695
00:28:37,500 --> 00:28:41,310
<font color="#E5E5E5">kernel</font>

696
00:28:38,310 --> 00:28:43,230
luckily for<font color="#E5E5E5"> doing the AVO and this is</font>

697
00:28:41,310 --> 00:28:45,060
<font color="#E5E5E5">going to be pretty</font><font color="#CCCCCC"> much the</font><font color="#E5E5E5"> same thing</font>

698
00:28:43,230 --> 00:28:46,050
now<font color="#E5E5E5"> a hypervisor has a slightly</font>

699
00:28:45,060 --> 00:28:49,230
different mechanism

700
00:28:46,050 --> 00:28:50,669
for trapping its guests<font color="#E5E5E5"> access and of</font>

701
00:28:49,230 --> 00:28:52,770
course the<font color="#CCCCCC"> kernel insight the virtual</font>

702
00:28:50,670 --> 00:28:55,470
machine will also be<font color="#E5E5E5"> tracking its user</font>

703
00:28:52,770 --> 00:28:57,720
space<font color="#E5E5E5"> usage but the ideal case then</font>

704
00:28:55,470 --> 00:28:59,790
should be<font color="#E5E5E5"> that if a VM has to exit for</font>

705
00:28:57,720 --> 00:29:01,890
something<font color="#E5E5E5"> unrelated as long as the host</font>

706
00:28:59,790 --> 00:29:05,100
kernel doesn't schedule<font color="#CCCCCC"> anything on</font><font color="#E5E5E5"> else</font>

707
00:29:01,890 --> 00:29:07,020
<font color="#E5E5E5">on to the CPU and the VM</font><font color="#CCCCCC"> gets back to</font>

708
00:29:05,100 --> 00:29:10,909
running pretty quickly<font color="#E5E5E5"> we don't need to</font>

709
00:29:07,020 --> 00:29:10,910
save and restore<font color="#E5E5E5"> our sve</font><font color="#CCCCCC"> state at all</font>

710
00:29:11,240 --> 00:29:17,190
now this is an arm specific thing

711
00:29:14,760 --> 00:29:20,460
enabling<font color="#CCCCCC"> SVN arm</font><font color="#E5E5E5"> so the kernel already</font>

712
00:29:17,190 --> 00:29:22,320
has support for<font color="#CCCCCC"> sve</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> 4 15 and this</font>

713
00:29:20,460 --> 00:29:24,870
extended the deferred system which was

714
00:29:22,320 --> 00:29:26,429
already<font color="#E5E5E5"> being used for the</font><font color="#CCCCCC"> nyan</font><font color="#E5E5E5"> an</font>

715
00:29:24,870 --> 00:29:29,159
<font color="#CCCCCC">advanced indi which is like earlier</font>

716
00:29:26,430 --> 00:29:32,670
iterations of the<font color="#CCCCCC"> Sindhi instruction set</font>

717
00:29:29,160 --> 00:29:35,100
<font color="#E5E5E5">but</font><font color="#CCCCCC"> currently in KVM</font><font color="#E5E5E5"> you can't have any</font>

718
00:29:32,670 --> 00:29:37,380
guests<font color="#E5E5E5"> that access sve registers there's</font>

719
00:29:35,100 --> 00:29:38,820
currently work underway to do this but

720
00:29:37,380 --> 00:29:40,710
it's<font color="#E5E5E5"> certainly almost</font><font color="#CCCCCC"> going to</font><font color="#E5E5E5"> be ready</font>

721
00:29:38,820 --> 00:29:43,439
<font color="#CCCCCC">before you actually get your</font><font color="#E5E5E5"> hands</font><font color="#CCCCCC"> on</font>

722
00:29:40,710 --> 00:29:45,180
<font color="#CCCCCC">any hardware</font><font color="#E5E5E5"> with</font><font color="#CCCCCC"> sv 8</font><font color="#E5E5E5"> so I'm expecting</font>

723
00:29:43,440 --> 00:29:47,280
<font color="#E5E5E5">most open-source developers will get</font>

724
00:29:45,180 --> 00:29:49,730
their<font color="#E5E5E5"> first experience of</font><font color="#CCCCCC"> using these</font>

725
00:29:47,280 --> 00:29:53,570
SPE registers on<font color="#E5E5E5"> chromium</font>

726
00:29:49,730 --> 00:29:56,190
so with that let me<font color="#E5E5E5"> just summarize</font>

727
00:29:53,570 --> 00:29:59,939
<font color="#E5E5E5">vectors are great they</font><font color="#CCCCCC"> really help us</font>

728
00:29:56,190 --> 00:30:02,940
<font color="#E5E5E5">with heavy data processing workloads but</font>

729
00:29:59,940 --> 00:30:06,300
vectors are large and this does mean

730
00:30:02,940 --> 00:30:11,850
<font color="#E5E5E5">that we have to add special handling in</font>

731
00:30:06,300 --> 00:30:14,370
kernels in hypervisors<font color="#E5E5E5"> and emulators so</font>

732
00:30:11,850 --> 00:30:18,110
with that that's the<font color="#E5E5E5"> end</font><font color="#CCCCCC"> of my talk</font><font color="#E5E5E5"> I</font>

733
00:30:14,370 --> 00:30:18,110
shall open<font color="#E5E5E5"> the floor to any</font><font color="#CCCCCC"> questions</font>

734
00:30:31,690 --> 00:30:35,110
so the question was can<font color="#CCCCCC"> we use the</font><font color="#E5E5E5"> same</font>

735
00:30:33,310 --> 00:30:38,500
technique to<font color="#E5E5E5"> trap access to the vector</font>

736
00:30:35,110 --> 00:30:39,639
registers on x86<font color="#E5E5E5"> you're asking the wrong</font>

737
00:30:38,500 --> 00:30:45,730
person<font color="#E5E5E5"> because I'm not very familiar</font>

738
00:30:39,640 --> 00:30:47,620
with x86 so x86 does have it does<font color="#CCCCCC"> have</font>

739
00:30:45,730 --> 00:30:51,790
some code to<font color="#E5E5E5"> deal with this sort</font><font color="#CCCCCC"> of</font>

740
00:30:47,620 --> 00:30:53,320
<font color="#E5E5E5">thing so it</font><font color="#CCCCCC"> actually</font><font color="#E5E5E5"> actively tracks</font>

741
00:30:51,790 --> 00:30:55,090
when<font color="#E5E5E5"> the colonel wants to do something</font>

742
00:30:53,320 --> 00:30:58,300
in<font color="#CCCCCC"> userspace so</font><font color="#E5E5E5"> I think it always swaps</font>

743
00:30:55,090 --> 00:31:00,370
<font color="#E5E5E5">context if it swaps to a new task but if</font>

744
00:30:58,300 --> 00:31:02,320
it's then wants<font color="#E5E5E5"> to do something in the</font>

745
00:31:00,370 --> 00:31:04,840
<font color="#CCCCCC">kernels</font><font color="#E5E5E5"> for some crypto related function</font>

746
00:31:02,320 --> 00:31:07,120
it will then save the<font color="#E5E5E5"> state at</font><font color="#CCCCCC"> that</font>

747
00:31:04,840 --> 00:31:09,429
point<font color="#CCCCCC"> just</font><font color="#E5E5E5"> trashed over it in</font><font color="#CCCCCC"> the kernel</font>

748
00:31:07,120 --> 00:31:11,229
<font color="#CCCCCC">and</font><font color="#E5E5E5"> then</font><font color="#CCCCCC"> return but the details you'll</font>

749
00:31:09,430 --> 00:31:43,270
have to ask someone who understands x86

750
00:31:11,230 --> 00:31:50,410
sorry let me<font color="#E5E5E5"> just see if I</font><font color="#CCCCCC"> can find the</font>

751
00:31:43,270 --> 00:31:56,560
example sorry I'm looking<font color="#CCCCCC"> very</font><font color="#E5E5E5"> small</font><font color="#CCCCCC"> on</font>

752
00:31:50,410 --> 00:32:06,940
this right<font color="#CCCCCC"> there we go</font>

753
00:31:56,560 --> 00:32:10,000
no no no right yes<font color="#E5E5E5"> so the key is we've</font>

754
00:32:06,940 --> 00:32:12,370
now<font color="#E5E5E5"> the TCG vector operation it</font>

755
00:32:10,000 --> 00:32:14,410
explicitly has an encoding of<font color="#E5E5E5"> the site</font>

756
00:32:12,370 --> 00:32:19,090
<font color="#E5E5E5">so that one at the end is it's actually</font>

757
00:32:14,410 --> 00:32:22,320
<font color="#CCCCCC">a logarithmic</font><font color="#E5E5E5"> scale so we</font><font color="#CCCCCC"> can pass the</font>

758
00:32:19,090 --> 00:32:26,409
size as part of<font color="#E5E5E5"> the TCG operation yeah</font>

759
00:32:22,320 --> 00:32:27,850
<font color="#E5E5E5">but we do still have</font><font color="#CCCCCC"> to have it</font><font color="#E5E5E5"> doesn't</font>

760
00:32:26,410 --> 00:32:30,460
matter for things like<font color="#CCCCCC"> XOR but you still</font>

761
00:32:27,850 --> 00:32:32,620
have to have a TCG up for each<font color="#E5E5E5"> lane size</font>

762
00:32:30,460 --> 00:32:35,830
that you're<font color="#CCCCCC"> dealing with</font><font color="#E5E5E5"> so you end up</font>

763
00:32:32,620 --> 00:32:37,989
<font color="#CCCCCC">with a</font><font color="#E5E5E5"> sort of for</font><font color="#CCCCCC"> example here</font><font color="#E5E5E5"> a vector</font>

764
00:32:35,830 --> 00:32:40,980
multiply 32<font color="#E5E5E5"> and a vector multiply 64</font>

765
00:32:37,990 --> 00:32:50,310
<font color="#E5E5E5">what I feel that the society support</font>

766
00:32:40,980 --> 00:32:57,660
anymore<font color="#E5E5E5"> okay</font><font color="#CCCCCC"> well thank you very much</font>

767
00:32:50,310 --> 00:32:57,659
[Applause]

