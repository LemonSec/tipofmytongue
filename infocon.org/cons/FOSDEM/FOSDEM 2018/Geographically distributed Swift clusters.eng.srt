1
00:00:06,130 --> 00:00:11,809
thank you<font color="#E5E5E5"> a good morning yet my</font><font color="#CCCCCC"> name is</font>

2
00:00:08,960 --> 00:00:14,809
<font color="#CCCCCC">Alistair Coles</font><font color="#E5E5E5"> and I'm with their</font>

3
00:00:11,809 --> 00:00:18,140
swisstack and I've been working on<font color="#E5E5E5"> Swift</font>

4
00:00:14,809 --> 00:00:20,090
for about<font color="#E5E5E5"> five years and I</font><font color="#CCCCCC"> think</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> 30</font>

5
00:00:18,140 --> 00:00:23,150
<font color="#E5E5E5">years have been on the core developer</font>

6
00:00:20,090 --> 00:00:25,610
team<font color="#E5E5E5"> and this morning I'd like</font><font color="#CCCCCC"> to tell</font>

7
00:00:23,150 --> 00:00:28,090
<font color="#E5E5E5">you a little about</font><font color="#CCCCCC"> how Swift</font><font color="#E5E5E5"> can be used</font>

8
00:00:25,610 --> 00:00:32,780
to build geographically distributed

9
00:00:28,090 --> 00:00:35,840
<font color="#E5E5E5">clusters</font><font color="#CCCCCC"> I'm going to begin</font><font color="#E5E5E5"> by doing a</font>

10
00:00:32,780 --> 00:00:36,800
brief overview<font color="#E5E5E5"> of Swift</font><font color="#CCCCCC"> I apologize to</font>

11
00:00:35,840 --> 00:00:38,540
those<font color="#E5E5E5"> of you that may have been here</font>

12
00:00:36,800 --> 00:00:40,790
<font color="#E5E5E5">earlier</font><font color="#CCCCCC"> this morning</font><font color="#E5E5E5"> and heard</font><font color="#CCCCCC"> Iago's</font>

13
00:00:38,540 --> 00:00:43,220
talk and but I'll try<font color="#E5E5E5"> and get through</font>

14
00:00:40,790 --> 00:00:45,200
<font color="#CCCCCC">that reasonably</font><font color="#E5E5E5"> quickly before then</font>

15
00:00:43,220 --> 00:00:48,260
starting to<font color="#CCCCCC"> talk</font><font color="#E5E5E5"> about geographically</font>

16
00:00:45,200 --> 00:00:49,160
distributed clusters and hopefully

17
00:00:48,260 --> 00:00:52,790
answering the questions

18
00:00:49,160 --> 00:00:56,379
what<font color="#CCCCCC"> are they</font><font color="#E5E5E5"> why might you want to</font>

19
00:00:52,790 --> 00:00:59,530
build<font color="#E5E5E5"> one and how to Swift enable that</font>

20
00:00:56,380 --> 00:01:01,880
<font color="#CCCCCC">and then I'm</font><font color="#E5E5E5"> going to look at another</font>

21
00:00:59,530 --> 00:01:04,699
really nice feature<font color="#E5E5E5"> of Swift which is a</font>

22
00:01:01,880 --> 00:01:07,579
<font color="#CCCCCC">rager</font><font color="#E5E5E5"> coding and talk about how</font><font color="#CCCCCC"> erasure</font>

23
00:01:04,699 --> 00:01:11,179
coding<font color="#E5E5E5"> also works with distributed</font>

24
00:01:07,579 --> 00:01:13,190
clusters so<font color="#E5E5E5"> disruptive clusters has been</font>

25
00:01:11,180 --> 00:01:15,680
a feature of Swift for many years and a

26
00:01:13,190 --> 00:01:19,490
<font color="#CCCCCC">rager</font><font color="#E5E5E5"> coding</font><font color="#CCCCCC"> I think has</font><font color="#E5E5E5"> been available</font>

27
00:01:15,680 --> 00:01:20,720
<font color="#E5E5E5">for maybe three</font><font color="#CCCCCC"> years to three years</font><font color="#E5E5E5"> but</font>

28
00:01:19,490 --> 00:01:22,339
it's only in the<font color="#CCCCCC"> last year that we've</font>

29
00:01:20,720 --> 00:01:25,700
kind<font color="#CCCCCC"> of managed to get the two of</font><font color="#E5E5E5"> those</font>

30
00:01:22,340 --> 00:01:27,380
to<font color="#E5E5E5"> work together and better</font><font color="#CCCCCC"> so kind of</font>

31
00:01:25,700 --> 00:01:29,330
really excited<font color="#CCCCCC"> to</font><font color="#E5E5E5"> tell you about what</font>

32
00:01:27,380 --> 00:01:35,000
we've done to get get those two<font color="#E5E5E5"> working</font>

33
00:01:29,330 --> 00:01:39,380
<font color="#E5E5E5">together okay so what is Swift and Swift</font>

34
00:01:35,000 --> 00:01:41,960
<font color="#E5E5E5">is an object storage service so it's</font>

35
00:01:39,380 --> 00:01:45,740
great for<font color="#CCCCCC"> storing blobs</font><font color="#E5E5E5"> of unstructured</font>

36
00:01:41,960 --> 00:01:48,070
<font color="#E5E5E5">data pictures media files</font><font color="#CCCCCC"> virtual</font>

37
00:01:45,740 --> 00:01:51,140
machine images and whatever it might be

38
00:01:48,070 --> 00:01:53,570
<font color="#E5E5E5">it was</font><font color="#CCCCCC"> one of</font><font color="#E5E5E5"> the founding projects of</font>

39
00:01:51,140 --> 00:01:56,960
the OpenStack cloud<font color="#E5E5E5"> software suite and</font>

40
00:01:53,570 --> 00:02:00,889
<font color="#CCCCCC">it's been</font><font color="#E5E5E5"> around in production for seven</font>

41
00:01:56,960 --> 00:02:06,139
or eight<font color="#E5E5E5"> years</font><font color="#CCCCCC"> now Swift offers a REST</font>

42
00:02:00,890 --> 00:02:08,628
API<font color="#E5E5E5"> accessed over HTTP and this API</font>

43
00:02:06,140 --> 00:02:11,360
offers<font color="#E5E5E5"> standard set of operations to</font>

44
00:02:08,628 --> 00:02:15,799
<font color="#CCCCCC">create objects read them back update</font>

45
00:02:11,360 --> 00:02:17,710
them and delete them now it's important

46
00:02:15,800 --> 00:02:19,810
to understand<font color="#E5E5E5"> Swift is not a</font>

47
00:02:17,710 --> 00:02:23,500
<font color="#E5E5E5">our system and it's definitely not a</font>

48
00:02:19,810 --> 00:02:26,500
block<font color="#E5E5E5"> storage system it does have a very</font>

49
00:02:23,500 --> 00:02:29,230
simple<font color="#E5E5E5"> naming hierarchy</font><font color="#CCCCCC"> so objects</font>

50
00:02:26,500 --> 00:02:33,550
belong to containers<font color="#E5E5E5"> and containers</font>

51
00:02:29,230 --> 00:02:37,090
belong<font color="#E5E5E5"> to accounts okay so what are</font><font color="#CCCCCC"> some</font>

52
00:02:33,550 --> 00:02:39,300
<font color="#E5E5E5">of</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> properties</font><font color="#CCCCCC"> of Swift well first of</font>

53
00:02:37,090 --> 00:02:42,510
all data that's stored in<font color="#E5E5E5"> Swift is</font>

54
00:02:39,300 --> 00:02:46,030
extremely durable

55
00:02:42,510 --> 00:02:48,459
<font color="#CCCCCC">typically swift will store</font><font color="#E5E5E5"> three</font>

56
00:02:46,030 --> 00:02:52,450
replicas of every object<font color="#CCCCCC"> that is</font><font color="#E5E5E5"> written</font>

57
00:02:48,460 --> 00:02:53,970
into<font color="#CCCCCC"> the storage service so here</font><font color="#E5E5E5"> just</font><font color="#CCCCCC"> to</font>

58
00:02:52,450 --> 00:02:57,100
explain<font color="#E5E5E5"> this is a very simplified</font>

59
00:02:53,970 --> 00:03:00,400
<font color="#E5E5E5">architectural diagram of Swift we have</font>

60
00:02:57,100 --> 00:03:05,799
an HTTP put<font color="#CCCCCC"> request that's</font><font color="#E5E5E5"> putting an</font>

61
00:03:00,400 --> 00:03:08,610
object<font color="#CCCCCC"> to a</font><font color="#E5E5E5"> URL and a</font><font color="#CCCCCC"> see oh that's the</font>

62
00:03:05,800 --> 00:03:11,140
account container object<font color="#E5E5E5"> name structure</font>

63
00:03:08,610 --> 00:03:14,950
and that request is handled by<font color="#CCCCCC"> a proxy</font>

64
00:03:11,140 --> 00:03:19,209
service<font color="#E5E5E5"> which will write three replicas</font>

65
00:03:14,950 --> 00:03:23,109
of the objects<font color="#CCCCCC"> onto three disks in a</font>

66
00:03:19,210 --> 00:03:24,760
pool of<font color="#E5E5E5"> storage</font><font color="#CCCCCC"> service and at the heart</font>

67
00:03:23,110 --> 00:03:27,250
of<font color="#CCCCCC"> Swift is this component which we</font>

68
00:03:24,760 --> 00:03:28,780
called the ring<font color="#E5E5E5"> and unfortunate have</font>

69
00:03:27,250 --> 00:03:31,630
time to go into<font color="#CCCCCC"> a lot of detail about</font>

70
00:03:28,780 --> 00:03:34,150
<font color="#E5E5E5">the ring but it's a form of consistent</font>

71
00:03:31,630 --> 00:03:36,790
hashing<font color="#E5E5E5"> so there's a data structure</font>

72
00:03:34,150 --> 00:03:40,680
there and the ring is<font color="#E5E5E5"> always trying to</font>

73
00:03:36,790 --> 00:03:45,040
disperse<font color="#E5E5E5"> replicas</font><font color="#CCCCCC"> of our objects across</font>

74
00:03:40,680 --> 00:03:48,040
both<font color="#E5E5E5"> disk devices and servers</font><font color="#CCCCCC"> in the</font>

75
00:03:45,040 --> 00:03:49,989
<font color="#E5E5E5">storage pool so that's how Swift used</font>

76
00:03:48,040 --> 00:03:51,579
durability<font color="#E5E5E5"> we always have more</font><font color="#CCCCCC"> than one</font>

77
00:03:49,990 --> 00:03:55,840
copy<font color="#E5E5E5"> of an object and they're written</font><font color="#CCCCCC"> to</font>

78
00:03:51,580 --> 00:03:59,380
different<font color="#CCCCCC"> discs on different servers the</font>

79
00:03:55,840 --> 00:04:01,590
Swift is also very scalable and there's

80
00:03:59,380 --> 00:04:05,590
two<font color="#E5E5E5"> factors that contribute to this</font>

81
00:04:01,590 --> 00:04:08,110
<font color="#E5E5E5">again the ring has a role</font><font color="#CCCCCC"> to play</font><font color="#E5E5E5"> so as</font>

82
00:04:05,590 --> 00:04:10,480
well<font color="#CCCCCC"> as dispersing replicas of our</font>

83
00:04:08,110 --> 00:04:13,570
objects the ring is always<font color="#E5E5E5"> trying to</font>

84
00:04:10,480 --> 00:04:16,779
balance the load of objects across the

85
00:04:13,570 --> 00:04:18,190
storage pool so here we have two

86
00:04:16,779 --> 00:04:21,548
different<font color="#CCCCCC"> objects</font><font color="#E5E5E5"> being written to two</font>

87
00:04:18,190 --> 00:04:23,380
different<font color="#E5E5E5"> names and the ring has chosen</font>

88
00:04:21,548 --> 00:04:26,349
a different<font color="#CCCCCC"> set of devices to store</font>

89
00:04:23,380 --> 00:04:29,050
those objects<font color="#E5E5E5"> and I said it's a</font>

90
00:04:26,350 --> 00:04:31,900
consistent<font color="#E5E5E5"> hashing algorithm so the</font>

91
00:04:29,050 --> 00:04:33,940
hashing kind of naturally causes<font color="#CCCCCC"> objects</font>

92
00:04:31,900 --> 00:04:36,099
to be dispersed<font color="#E5E5E5"> somewhat randomly and</font>

93
00:04:33,940 --> 00:04:39,009
<font color="#E5E5E5">uniformly across the storage book so</font>

94
00:04:36,100 --> 00:04:41,590
this helps with<font color="#CCCCCC"> scalability but</font><font color="#E5E5E5"> also we</font>

95
00:04:39,009 --> 00:04:43,600
have no centralized services so for

96
00:04:41,590 --> 00:04:46,210
<font color="#CCCCCC">example we can have multiple</font><font color="#E5E5E5"> instances</font>

97
00:04:43,600 --> 00:04:48,820
<font color="#CCCCCC">of these</font><font color="#E5E5E5"> proxy servers and multiple</font>

98
00:04:46,210 --> 00:04:50,469
instances of<font color="#CCCCCC"> the</font><font color="#E5E5E5"> Ring and there's no</font>

99
00:04:48,820 --> 00:04:52,719
<font color="#E5E5E5">need for any communication between them</font>

100
00:04:50,470 --> 00:04:55,210
<font color="#E5E5E5">as objects are written there's no need</font>

101
00:04:52,720 --> 00:04:57,850
<font color="#CCCCCC">for any coherency protocol</font><font color="#E5E5E5"> they're</font>

102
00:04:55,210 --> 00:05:01,180
essentially stable independently

103
00:04:57,850 --> 00:05:02,590
operating services the only time the

104
00:05:01,180 --> 00:05:04,900
<font color="#E5E5E5">ring does need</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> be updated is when</font>

105
00:05:02,590 --> 00:05:10,330
changes are made<font color="#E5E5E5"> to the devices in</font>

106
00:05:04,900 --> 00:05:13,120
storage pool and then finally<font color="#CCCCCC"> Swift is</font>

107
00:05:10,330 --> 00:05:16,840
<font color="#CCCCCC">am highly available so</font><font color="#E5E5E5"> Swift will</font>

108
00:05:13,120 --> 00:05:19,930
continue to accept<font color="#E5E5E5"> writes and to serve</font>

109
00:05:16,840 --> 00:05:24,940
<font color="#E5E5E5">read requests even</font><font color="#CCCCCC"> when one or more</font><font color="#E5E5E5"> of</font>

110
00:05:19,930 --> 00:05:28,539
the storage pool devices has failed so

111
00:05:24,940 --> 00:05:31,840
in the example I'm using<font color="#E5E5E5"> here of a three</font>

112
00:05:28,539 --> 00:05:35,620
<font color="#CCCCCC">replicas</font><font color="#E5E5E5"> storage policy Swift will</font>

113
00:05:31,840 --> 00:05:38,049
consider a right to be successful if two

114
00:05:35,620 --> 00:05:41,050
<font color="#CCCCCC">of the three replicas if a quorum have</font>

115
00:05:38,050 --> 00:05:43,570
been<font color="#CCCCCC"> written to disk</font><font color="#E5E5E5"> and here you can</font>

116
00:05:41,050 --> 00:05:45,280
see for some reason the third replica

117
00:05:43,570 --> 00:05:47,020
has failed<font color="#E5E5E5"> to be written maybe there's</font>

118
00:05:45,280 --> 00:05:49,809
just<font color="#E5E5E5"> like a network failure</font><font color="#CCCCCC"> discus</font>

119
00:05:47,020 --> 00:05:52,990
<font color="#CCCCCC">failed congestion whatever reason but</font><font color="#E5E5E5"> we</font>

120
00:05:49,810 --> 00:05:54,699
have two replicas written and<font color="#CCCCCC"> Swift</font>

121
00:05:52,990 --> 00:05:58,300
considers had a quorum<font color="#E5E5E5"> and so the right</font>

122
00:05:54,699 --> 00:06:00,490
has been successful<font color="#E5E5E5"> and then we have</font>

123
00:05:58,300 --> 00:06:02,860
some background<font color="#E5E5E5"> asynchronous processes</font>

124
00:06:00,490 --> 00:06:05,949
that are continually working<font color="#CCCCCC"> to replace</font>

125
00:06:02,860 --> 00:06:11,229
<font color="#E5E5E5">missing replicates by copying data from</font>

126
00:06:05,949 --> 00:06:14,320
the existing<font color="#CCCCCC"> replicas</font><font color="#E5E5E5"> so not much long</font>

127
00:06:11,229 --> 00:06:16,090
after this right request<font color="#CCCCCC"> there's</font>

128
00:06:14,320 --> 00:06:20,139
background<font color="#E5E5E5"> processes will ensure that</font>

129
00:06:16,090 --> 00:06:22,000
that third<font color="#E5E5E5"> replica is in place now I</font>

130
00:06:20,139 --> 00:06:24,909
haven't<font color="#CCCCCC"> actually told you the whole</font>

131
00:06:22,000 --> 00:06:25,930
<font color="#E5E5E5">truth there Swift is actually doing a</font>

132
00:06:24,909 --> 00:06:28,780
<font color="#E5E5E5">little bit more but I'll get to</font><font color="#CCCCCC"> that</font>

133
00:06:25,930 --> 00:06:30,820
<font color="#E5E5E5">later in</font><font color="#CCCCCC"> my talk</font><font color="#E5E5E5"> but needless to say it</font>

134
00:06:28,780 --> 00:06:32,770
<font color="#CCCCCC">just gets</font><font color="#E5E5E5"> better</font><font color="#CCCCCC"> a little</font><font color="#E5E5E5"> better than</font>

135
00:06:30,820 --> 00:06:35,289
<font color="#CCCCCC">that</font><font color="#E5E5E5"> but that's</font><font color="#CCCCCC"> the basic principles</font>

136
00:06:32,770 --> 00:06:38,409
behind<font color="#E5E5E5"> a high availability now a</font>

137
00:06:35,289 --> 00:06:41,289
consequence<font color="#E5E5E5"> of this is that</font><font color="#CCCCCC"> we can end</font>

138
00:06:38,409 --> 00:06:43,000
<font color="#E5E5E5">up</font><font color="#CCCCCC"> with stale data in Swift so here's a</font>

139
00:06:41,289 --> 00:06:45,529
<font color="#E5E5E5">little bit</font><font color="#CCCCCC"> more complicated example</font>

140
00:06:43,000 --> 00:06:49,249
where the object that was

141
00:06:45,529 --> 00:06:55,699
written a time<font color="#E5E5E5"> t1 has now been</font>

142
00:06:49,249 --> 00:06:59,029
overwritten<font color="#E5E5E5"> at time t2 only the override</font>

143
00:06:55,699 --> 00:07:02,989
<font color="#E5E5E5">was only partially successful</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> I still</font>

144
00:06:59,029 --> 00:07:05,659
have one<font color="#CCCCCC"> of the the blue</font><font color="#E5E5E5"> replicas and on</font>

145
00:07:02,989 --> 00:07:08,839
<font color="#CCCCCC">disc that</font><font color="#E5E5E5"> was</font><font color="#CCCCCC"> written at time t1</font><font color="#E5E5E5"> and</font>

146
00:07:05,659 --> 00:07:11,569
only two of the three replicas at t2 at

147
00:07:08,839 --> 00:07:13,039
time t2 were successfully written so

148
00:07:11,569 --> 00:07:14,959
<font color="#E5E5E5">this means there's some stale data in</font>

149
00:07:13,039 --> 00:07:19,279
the cluster<font color="#E5E5E5"> and it's possible to read</font>

150
00:07:14,959 --> 00:07:22,519
<font color="#E5E5E5">that stale data because our ring will</font><font color="#CCCCCC"> be</font>

151
00:07:19,279 --> 00:07:27,769
choosing randomly one<font color="#E5E5E5"> of those replicas</font>

152
00:07:22,519 --> 00:07:29,599
<font color="#CCCCCC">to serve reads so this is kind of</font><font color="#E5E5E5"> like a</font>

153
00:07:27,769 --> 00:07:31,399
very<font color="#E5E5E5"> different property of Swift and</font>

154
00:07:29,599 --> 00:07:34,159
other<font color="#CCCCCC"> objects doors</font><font color="#E5E5E5"> and when compared to</font>

155
00:07:31,399 --> 00:07:36,979
<font color="#E5E5E5">a file system or a block storage service</font>

156
00:07:34,159 --> 00:07:38,748
you know the file system we expect<font color="#E5E5E5"> that</font>

157
00:07:36,979 --> 00:07:40,489
when we've written data when<font color="#CCCCCC"> we next</font>

158
00:07:38,749 --> 00:07:43,009
read it<font color="#CCCCCC"> we'll get back</font><font color="#E5E5E5"> the data</font><font color="#CCCCCC"> that we</font>

159
00:07:40,489 --> 00:07:46,789
last wrote and<font color="#CCCCCC"> that's a contract</font><font color="#E5E5E5"> that</font>

160
00:07:43,009 --> 00:07:48,919
we're very<font color="#CCCCCC"> used to</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> I emphasize</font><font color="#E5E5E5"> this</font>

161
00:07:46,789 --> 00:07:51,199
<font color="#CCCCCC">point because Swift does have a</font>

162
00:07:48,919 --> 00:07:53,419
different contract with regard<font color="#E5E5E5"> to data</font>

163
00:07:51,199 --> 00:07:56,360
consistency<font color="#E5E5E5"> and we've we've</font><font color="#CCCCCC"> heard two is</font>

164
00:07:53,419 --> 00:07:58,519
eventual consistency eventual because

165
00:07:56,360 --> 00:08:01,369
those background<font color="#E5E5E5"> asynchronous processes</font>

166
00:07:58,519 --> 00:08:03,079
are always working<font color="#CCCCCC"> to update</font><font color="#E5E5E5"> all</font><font color="#CCCCCC"> of the</font>

167
00:08:01,369 --> 00:08:06,199
replicas and ensure<font color="#E5E5E5"> that eventually your</font>

168
00:08:03,079 --> 00:08:08,059
data becomes consistent now if that

169
00:08:06,199 --> 00:08:09,679
<font color="#E5E5E5">sounds odd to you rest assured</font><font color="#CCCCCC"> there are</font>

170
00:08:08,059 --> 00:08:12,139
plenty<font color="#E5E5E5"> of applications where this</font>

171
00:08:09,679 --> 00:08:15,078
consistency contract<font color="#E5E5E5"> is totally</font>

172
00:08:12,139 --> 00:08:19,299
<font color="#E5E5E5">acceptable and this does enable Swift to</font>

173
00:08:15,079 --> 00:08:19,299
be very scalable<font color="#E5E5E5"> and highly available</font>

174
00:08:19,929 --> 00:08:24,649
<font color="#CCCCCC">okay that was my very brief overview of</font>

175
00:08:23,179 --> 00:08:26,539
Swift we're going to touch on<font color="#E5E5E5"> some</font><font color="#CCCCCC"> of</font>

176
00:08:24,649 --> 00:08:32,719
those concepts again as we talked<font color="#CCCCCC"> about</font>

177
00:08:26,539 --> 00:08:34,610
as I<font color="#E5E5E5"> talk</font><font color="#CCCCCC"> about distributed</font><font color="#E5E5E5"> clusters so</font>

178
00:08:32,719 --> 00:08:36,529
first what is a geographically

179
00:08:34,610 --> 00:08:39,379
distributed cluster well my definition

180
00:08:36,529 --> 00:08:43,729
for the purposes<font color="#CCCCCC"> of</font><font color="#E5E5E5"> this talk is this is</font>

181
00:08:39,379 --> 00:08:45,559
a cluster which is consists of data

182
00:08:43,729 --> 00:08:48,980
being stored<font color="#E5E5E5"> in multiple</font><font color="#CCCCCC"> physical</font>

183
00:08:45,559 --> 00:08:51,949
locations<font color="#E5E5E5"> and that those physical</font>

184
00:08:48,980 --> 00:08:55,189
locations would<font color="#E5E5E5"> typically be connected</font>

185
00:08:51,949 --> 00:08:56,889
by a wide area<font color="#CCCCCC"> network</font><font color="#E5E5E5"> and importantly</font>

186
00:08:55,189 --> 00:08:58,939
<font color="#E5E5E5">at least the</font><font color="#CCCCCC"> process is my definition</font>

187
00:08:56,889 --> 00:09:01,520
<font color="#CCCCCC">every object</font><font color="#E5E5E5"> that is</font>

188
00:08:58,940 --> 00:09:04,040
<font color="#CCCCCC">stored</font><font color="#E5E5E5"> in a distributed cluster will</font>

189
00:09:01,520 --> 00:09:07,640
have at<font color="#CCCCCC"> least</font><font color="#E5E5E5"> one copy of itself</font><font color="#CCCCCC"> in each</font>

190
00:09:04,040 --> 00:09:09,230
<font color="#E5E5E5">of those physical locations so we</font><font color="#CCCCCC"> might</font>

191
00:09:07,640 --> 00:09:12,680
<font color="#E5E5E5">be talking</font><font color="#CCCCCC"> about</font><font color="#E5E5E5"> multiple data</font><font color="#CCCCCC"> centers</font>

192
00:09:09,230 --> 00:09:15,110
<font color="#CCCCCC">and</font><font color="#E5E5E5"> here like I think approximately in</font>

193
00:09:12,680 --> 00:09:20,030
London and Geneva<font color="#E5E5E5"> connected by a wide</font>

194
00:09:15,110 --> 00:09:22,370
area<font color="#E5E5E5"> network and the entire cluster the</font>

195
00:09:20,030 --> 00:09:24,770
global cluster<font color="#E5E5E5"> operates under a single</font>

196
00:09:22,370 --> 00:09:27,080
<font color="#E5E5E5">namespace so objects are written and</font>

197
00:09:24,770 --> 00:09:31,520
read<font color="#E5E5E5"> in any region</font><font color="#CCCCCC"> within</font><font color="#E5E5E5"> the cluster</font>

198
00:09:27,080 --> 00:09:34,430
<font color="#CCCCCC">under the same names okay</font><font color="#E5E5E5"> why would you</font>

199
00:09:31,520 --> 00:09:37,220
want<font color="#E5E5E5"> to do this</font><font color="#CCCCCC"> um first</font><font color="#E5E5E5"> reason is for</font>

200
00:09:34,430 --> 00:09:40,760
increased data durability<font color="#E5E5E5"> and in</font>

201
00:09:37,220 --> 00:09:42,730
particular for disaster recovery<font color="#E5E5E5"> so if</font>

202
00:09:40,760 --> 00:09:45,110
in the<font color="#CCCCCC"> event of some catastrophic</font><font color="#E5E5E5"> event</font>

203
00:09:42,730 --> 00:09:46,970
<font color="#E5E5E5">you were to lose</font><font color="#CCCCCC"> the availability of</font><font color="#E5E5E5"> an</font>

204
00:09:45,110 --> 00:09:49,250
entire data center<font color="#CCCCCC"> you'd</font><font color="#E5E5E5"> still have</font>

205
00:09:46,970 --> 00:09:53,300
<font color="#E5E5E5">copies of your data</font><font color="#CCCCCC"> available in another</font>

206
00:09:49,250 --> 00:09:56,630
<font color="#E5E5E5">physical location but it's also useful</font>

207
00:09:53,300 --> 00:09:59,359
<font color="#CCCCCC">for achieving data locality</font><font color="#E5E5E5"> so if you</font>

208
00:09:56,630 --> 00:10:02,050
have users accessing the same data sets

209
00:09:59,360 --> 00:10:05,270
<font color="#E5E5E5">but in multiple geographic regions</font><font color="#CCCCCC"> a</font>

210
00:10:02,050 --> 00:10:06,949
distributed cluster can mean that<font color="#E5E5E5"> you</font>

211
00:10:05,270 --> 00:10:08,930
<font color="#E5E5E5">have copies of your data at located</font>

212
00:10:06,950 --> 00:10:10,550
close to each of those users<font color="#E5E5E5"> and</font><font color="#CCCCCC"> your</font>

213
00:10:08,930 --> 00:10:16,130
<font color="#CCCCCC">open observe</font><font color="#E5E5E5"> their read</font><font color="#CCCCCC"> request</font><font color="#E5E5E5"> with low</font>

214
00:10:10,550 --> 00:10:17,390
<font color="#CCCCCC">latency</font><font color="#E5E5E5"> oh and just</font><font color="#CCCCCC"> to mention if</font><font color="#E5E5E5"> you if</font>

215
00:10:16,130 --> 00:10:19,250
you look through<font color="#CCCCCC"> Swift documentation</font>

216
00:10:17,390 --> 00:10:20,900
literature you'll also see<font color="#E5E5E5"> these</font>

217
00:10:19,250 --> 00:10:23,270
distributed clusters referred to for

218
00:10:20,900 --> 00:10:28,520
obvious reasons as global clusters or as

219
00:10:23,270 --> 00:10:32,300
multi region Swift<font color="#CCCCCC"> okay so let's see how</font>

220
00:10:28,520 --> 00:10:35,240
that<font color="#E5E5E5"> actually</font><font color="#CCCCCC"> works out when you map it</font>

221
00:10:32,300 --> 00:10:38,589
<font color="#CCCCCC">onto a swift cluster and so what I've</font>

222
00:10:35,240 --> 00:10:41,150
done<font color="#E5E5E5"> here is I've added a</font><font color="#CCCCCC"> few more</font>

223
00:10:38,590 --> 00:10:46,030
storage servers to my storage pool and

224
00:10:41,150 --> 00:10:49,339
I've grouped them into<font color="#CCCCCC"> two</font><font color="#E5E5E5"> regions now</font>

225
00:10:46,030 --> 00:10:52,910
<font color="#E5E5E5">this is really easy to</font><font color="#CCCCCC"> achieve in</font><font color="#E5E5E5"> Swift</font>

226
00:10:49,339 --> 00:10:56,060
<font color="#E5E5E5">every device in the storage pool</font><font color="#CCCCCC"> is</font>

227
00:10:52,910 --> 00:10:58,300
annotated<font color="#E5E5E5"> with some metadata and the</font>

228
00:10:56,060 --> 00:11:01,819
metadata associates it<font color="#CCCCCC"> with a server and</font>

229
00:10:58,300 --> 00:11:04,579
also associated<font color="#E5E5E5"> with a region so in the</font>

230
00:11:01,820 --> 00:11:07,850
same<font color="#E5E5E5"> way that the ring was always trying</font>

231
00:11:04,580 --> 00:11:10,880
<font color="#CCCCCC">to disperse</font><font color="#E5E5E5"> replicas of an object across</font>

232
00:11:07,850 --> 00:11:13,310
<font color="#CCCCCC">disks</font><font color="#E5E5E5"> and across servers</font>

233
00:11:10,880 --> 00:11:15,110
the same principle is extended<font color="#CCCCCC"> to</font>

234
00:11:13,310 --> 00:11:18,768
include regions<font color="#E5E5E5"> and the ring just</font>

235
00:11:15,110 --> 00:11:23,079
inherently<font color="#E5E5E5"> works to disperse our object</font>

236
00:11:18,769 --> 00:11:23,079
replicas across these multiple regions

237
00:11:25,420 --> 00:11:31,459
and<font color="#E5E5E5"> that's great because it means now</font>

238
00:11:27,680 --> 00:11:32,029
that<font color="#CCCCCC"> if I lose an</font><font color="#E5E5E5"> entire region from my</font>

239
00:11:31,459 --> 00:11:35,060
<font color="#CCCCCC">cluster</font>

240
00:11:32,029 --> 00:11:37,220
I still have replicas<font color="#E5E5E5"> of the object in</font>

241
00:11:35,060 --> 00:11:41,359
the<font color="#E5E5E5"> other region and are still available</font>

242
00:11:37,220 --> 00:11:45,259
<font color="#CCCCCC">to me now you may have noticed if</font><font color="#E5E5E5"> you're</font>

243
00:11:41,360 --> 00:11:46,850
sharp that I've<font color="#E5E5E5"> changed the replica</font>

244
00:11:45,259 --> 00:11:48,980
count of the storage policy that<font color="#E5E5E5"> I'm</font>

245
00:11:46,850 --> 00:11:51,949
using in<font color="#CCCCCC"> my example</font><font color="#E5E5E5"> originally I said</font>

246
00:11:48,980 --> 00:11:56,089
<font color="#E5E5E5">that typically deployers might use</font><font color="#CCCCCC"> three</font>

247
00:11:51,949 --> 00:11:57,740
replicas<font color="#E5E5E5"> in a swift cluster the reason</font>

248
00:11:56,089 --> 00:11:59,899
<font color="#CCCCCC">I've increased</font><font color="#E5E5E5"> it to four it's not a</font>

249
00:11:57,740 --> 00:12:01,759
requirement<font color="#E5E5E5"> for</font><font color="#CCCCCC"> a distributed cluster</font>

250
00:11:59,899 --> 00:12:03,829
<font color="#E5E5E5">but it's a nice number because it gives</font>

251
00:12:01,759 --> 00:12:05,959
us symmetry between<font color="#CCCCCC"> the</font><font color="#E5E5E5"> region's means</font>

252
00:12:03,829 --> 00:12:07,910
we end up with two replicas<font color="#E5E5E5"> of every</font>

253
00:12:05,959 --> 00:12:10,790
<font color="#E5E5E5">object</font><font color="#CCCCCC"> in each of the two</font><font color="#E5E5E5"> regions in</font>

254
00:12:07,910 --> 00:12:12,920
<font color="#E5E5E5">this example and that also means</font><font color="#CCCCCC"> that</font>

255
00:12:10,790 --> 00:12:15,439
<font color="#E5E5E5">it's well as being able to survive the</font>

256
00:12:12,920 --> 00:12:17,709
loss of an entire region<font color="#E5E5E5"> each region can</font>

257
00:12:15,439 --> 00:12:21,439
also independently survive the loss of

258
00:12:17,709 --> 00:12:24,170
one device and still have at the object

259
00:12:21,439 --> 00:12:26,990
available to it so a four replicas

260
00:12:24,170 --> 00:12:28,959
policy is just<font color="#CCCCCC"> a nice choice</font><font color="#E5E5E5"> and twist</font>

261
00:12:26,990 --> 00:12:36,230
that many deploys use when they're

262
00:12:28,959 --> 00:12:38,000
operating<font color="#E5E5E5"> multi-region clusters so this</font>

263
00:12:36,230 --> 00:12:40,310
is great it looks like we haven't<font color="#E5E5E5"> really</font>

264
00:12:38,000 --> 00:12:42,050
<font color="#CCCCCC">had to do much with our swift cluster to</font>

265
00:12:40,310 --> 00:12:44,660
just<font color="#E5E5E5"> naturally achieve</font>

266
00:12:42,050 --> 00:12:47,540
data durability and disaster recovery

267
00:12:44,660 --> 00:12:51,170
<font color="#E5E5E5">and what about data locality well</font>

268
00:12:47,540 --> 00:12:54,380
obviously I now have copies of my object

269
00:12:51,170 --> 00:12:57,229
<font color="#E5E5E5">in both of these regions close to</font><font color="#CCCCCC"> any</font>

270
00:12:54,380 --> 00:12:58,670
users that might<font color="#E5E5E5"> be in those</font><font color="#CCCCCC"> regions but</font>

271
00:12:57,230 --> 00:13:01,339
<font color="#E5E5E5">we need to do a little bit more work to</font>

272
00:12:58,670 --> 00:13:05,060
<font color="#CCCCCC">actually achieve</font><font color="#E5E5E5"> data locality in this</font>

273
00:13:01,339 --> 00:13:07,759
<font color="#CCCCCC">cluster</font><font color="#E5E5E5"> and that's because the ring as I</font>

274
00:13:05,060 --> 00:13:10,399
said it's always<font color="#E5E5E5"> trying to load</font><font color="#CCCCCC"> balance</font>

275
00:13:07,759 --> 00:13:13,880
so by default when serving a read

276
00:13:10,399 --> 00:13:17,350
request<font color="#CCCCCC"> the ring is selecting a random</font>

277
00:13:13,880 --> 00:13:19,760
replica for each individual read request

278
00:13:17,350 --> 00:13:23,420
that means that a read<font color="#CCCCCC"> that's arriving</font>

279
00:13:19,760 --> 00:13:24,500
<font color="#E5E5E5">in region</font><font color="#CCCCCC"> one may by default</font><font color="#E5E5E5"> actually be</font>

280
00:13:23,420 --> 00:13:27,829
directed to a cop

281
00:13:24,500 --> 00:13:29,780
of our object that's in region<font color="#CCCCCC"> two now</font>

282
00:13:27,830 --> 00:13:33,290
that's not optimal but fortunately we

283
00:13:29,780 --> 00:13:36,620
have<font color="#CCCCCC"> an</font><font color="#E5E5E5"> option in Swift to override that</font>

284
00:13:33,290 --> 00:13:38,150
behavior<font color="#CCCCCC"> it's called read affinity so</font>

285
00:13:36,620 --> 00:13:41,420
this is<font color="#E5E5E5"> just an option</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> is set in</font>

286
00:13:38,150 --> 00:13:43,880
<font color="#E5E5E5">each of the proxy servers and all it</font>

287
00:13:41,420 --> 00:13:47,180
does<font color="#E5E5E5"> is</font><font color="#CCCCCC"> it puts a bias into the</font><font color="#E5E5E5"> Rings</font><font color="#CCCCCC"> a</font>

288
00:13:43,880 --> 00:13:49,670
selection algorithm<font color="#E5E5E5"> to prefer replicas</font>

289
00:13:47,180 --> 00:13:56,449
<font color="#CCCCCC">that are resident</font><font color="#E5E5E5"> in the local region</font>

290
00:13:49,670 --> 00:13:58,520
<font color="#E5E5E5">when serving reads so real</font><font color="#CCCCCC"> affinity is</font>

291
00:13:56,450 --> 00:14:01,820
basically is<font color="#E5E5E5"> giving us a means to</font>

292
00:13:58,520 --> 00:14:03,650
<font color="#CCCCCC">trade-off load balancing for read</font>

293
00:14:01,820 --> 00:14:07,940
<font color="#CCCCCC">performance in the case of a</font><font color="#E5E5E5"> distributed</font>

294
00:14:03,650 --> 00:14:13,550
cluster and it's typically recommended

295
00:14:07,940 --> 00:14:15,680
<font color="#E5E5E5">to use it's good idea okay so we've seen</font>

296
00:14:13,550 --> 00:14:19,250
<font color="#E5E5E5">that</font><font color="#CCCCCC"> relatively simply Swift has been</font>

297
00:14:15,680 --> 00:14:21,380
able<font color="#CCCCCC"> to cope</font><font color="#E5E5E5"> with my service being</font>

298
00:14:19,250 --> 00:14:23,660
distributed<font color="#E5E5E5"> we've annotated the devices</font>

299
00:14:21,380 --> 00:14:25,880
with some region information the<font color="#CCCCCC"> ring</font>

300
00:14:23,660 --> 00:14:28,490
pretty<font color="#E5E5E5"> much operates as it would</font><font color="#CCCCCC"> for a</font>

301
00:14:25,880 --> 00:14:30,560
single site cluster and<font color="#E5E5E5"> we have this</font>

302
00:14:28,490 --> 00:14:35,450
read affinity option just<font color="#E5E5E5"> to optimize</font>

303
00:14:30,560 --> 00:14:36,069
and and create data locality all sounds

304
00:14:35,450 --> 00:14:38,210
good

305
00:14:36,070 --> 00:14:41,120
just pause at<font color="#E5E5E5"> this moment though because</font>

306
00:14:38,210 --> 00:14:43,040
we should just consider the fundamental

307
00:14:41,120 --> 00:14:46,430
<font color="#E5E5E5">difference between</font><font color="#CCCCCC"> this distributed</font>

308
00:14:43,040 --> 00:14:48,349
cluster and a single<font color="#E5E5E5"> site cluster which</font>

309
00:14:46,430 --> 00:14:51,199
is<font color="#E5E5E5"> that we now have this wide area</font>

310
00:14:48,350 --> 00:14:55,490
network component that's sitting in the

311
00:14:51,200 --> 00:14:56,990
middle of<font color="#E5E5E5"> our storage pool with a single</font>

312
00:14:55,490 --> 00:14:59,030
site cluster it's reasonable<font color="#CCCCCC"> to assume</font>

313
00:14:56,990 --> 00:15:02,210
that<font color="#CCCCCC"> all of the nodes in storage pool</font>

314
00:14:59,030 --> 00:15:06,140
are connected by low latency high

315
00:15:02,210 --> 00:15:07,850
bandwidth reliable networking that

316
00:15:06,140 --> 00:15:10,760
assumption<font color="#E5E5E5"> may not hold when we have</font>

317
00:15:07,850 --> 00:15:15,230
wide area network connection between two

318
00:15:10,760 --> 00:15:17,450
<font color="#CCCCCC">regions in our</font><font color="#E5E5E5"> storage pool so going to</font>

319
00:15:15,230 --> 00:15:18,800
think a<font color="#CCCCCC"> bit about what consequences are</font>

320
00:15:17,450 --> 00:15:22,550
first of<font color="#E5E5E5"> all if that wide area</font>

321
00:15:18,800 --> 00:15:26,420
connection was to fail and in particular

322
00:15:22,550 --> 00:15:32,810
<font color="#E5E5E5">what</font><font color="#CCCCCC"> happened to our rights when the</font>

323
00:15:26,420 --> 00:15:34,579
wide area network has failed so this is

324
00:15:32,810 --> 00:15:37,010
where I said<font color="#CCCCCC"> to</font><font color="#E5E5E5"> earlier I wasn't telling</font>

325
00:15:34,580 --> 00:15:38,270
you the whole<font color="#CCCCCC"> truth about</font><font color="#E5E5E5"> the way Swift</font>

326
00:15:37,010 --> 00:15:44,150
<font color="#E5E5E5">writes replicas</font>

327
00:15:38,270 --> 00:15:47,000
read during<font color="#E5E5E5"> a write request so in this</font>

328
00:15:44,150 --> 00:15:50,709
case the ring is temporarily unavailable

329
00:15:47,000 --> 00:15:53,420
<font color="#CCCCCC">and</font><font color="#E5E5E5"> unable to</font><font color="#CCCCCC"> access the locations</font>

330
00:15:50,710 --> 00:15:58,040
intended for two of the four replicas

331
00:15:53,420 --> 00:16:00,020
<font color="#E5E5E5">but</font><font color="#CCCCCC"> it can write to successfully so it</font>

332
00:15:58,040 --> 00:16:03,079
can<font color="#CCCCCC"> achieve a quorum</font><font color="#E5E5E5"> in the case of a</font>

333
00:16:00,020 --> 00:16:08,210
<font color="#E5E5E5">four replica ring</font><font color="#CCCCCC"> two successful writes</font>

334
00:16:03,080 --> 00:16:10,340
constitutes a quorum<font color="#E5E5E5"> what I didn't tell</font>

335
00:16:08,210 --> 00:16:10,700
<font color="#E5E5E5">you is that actually</font><font color="#CCCCCC"> swift</font><font color="#E5E5E5"> works harder</font>

336
00:16:10,340 --> 00:16:12,800
than<font color="#CCCCCC"> that</font>

337
00:16:10,700 --> 00:16:15,340
<font color="#E5E5E5">to write data it down</font><font color="#CCCCCC"> onto this so it</font>

338
00:16:12,800 --> 00:16:19,459
<font color="#CCCCCC">doesn't just stop</font><font color="#E5E5E5"> when it reaches quorum</font>

339
00:16:15,340 --> 00:16:20,510
what it will do is it will<font color="#CCCCCC"> look for</font><font color="#E5E5E5"> two</font>

340
00:16:19,460 --> 00:16:22,520
temporary

341
00:16:20,510 --> 00:16:26,750
alternate locations for<font color="#E5E5E5"> the remaining</font>

342
00:16:22,520 --> 00:16:28,490
two replicas<font color="#E5E5E5"> and write them there and in</font>

343
00:16:26,750 --> 00:16:30,350
a game we<font color="#CCCCCC"> have these background</font>

344
00:16:28,490 --> 00:16:32,840
<font color="#E5E5E5">asynchronous processes that are always</font>

345
00:16:30,350 --> 00:16:35,540
working<font color="#CCCCCC"> to move</font><font color="#E5E5E5"> replicas</font><font color="#CCCCCC"> that are</font>

346
00:16:32,840 --> 00:16:37,310
<font color="#E5E5E5">misplaced to their correct</font><font color="#CCCCCC"> location in</font>

347
00:16:35,540 --> 00:16:42,890
this<font color="#CCCCCC"> case once</font><font color="#E5E5E5"> the wide area network</font>

348
00:16:37,310 --> 00:16:45,949
becomes<font color="#E5E5E5"> available again so despite the</font>

349
00:16:42,890 --> 00:16:48,500
<font color="#E5E5E5">fact</font><font color="#CCCCCC"> that we've lost the wide area</font>

350
00:16:45,950 --> 00:16:53,800
<font color="#E5E5E5">network we're still writing fully</font>

351
00:16:48,500 --> 00:16:53,800
<font color="#CCCCCC">durable data</font><font color="#E5E5E5"> all built into one region</font>

352
00:16:56,910 --> 00:17:01,480
this gets a little more<font color="#CCCCCC"> interesting</font>

353
00:16:59,170 --> 00:17:05,379
<font color="#CCCCCC">again</font><font color="#E5E5E5"> when we consider an overwrite</font>

354
00:17:01,480 --> 00:17:08,290
operation so here just<font color="#E5E5E5"> like my previous</font>

355
00:17:05,380 --> 00:17:12,910
override example some data has been

356
00:17:08,290 --> 00:17:16,899
written at<font color="#CCCCCC"> t1</font><font color="#E5E5E5"> and then at t2 the wide</font>

357
00:17:12,910 --> 00:17:20,710
area network fails so what happens to

358
00:17:16,900 --> 00:17:23,260
<font color="#E5E5E5">the overwrites</font><font color="#CCCCCC"> at t3</font><font color="#E5E5E5"> well as it just</font>

359
00:17:20,710 --> 00:17:25,750
<font color="#E5E5E5">said it's</font><font color="#CCCCCC"> what's really hard</font><font color="#E5E5E5"> and it's</font>

360
00:17:23,260 --> 00:17:27,970
<font color="#CCCCCC">gonna write down</font><font color="#E5E5E5"> four replicas two of</font>

361
00:17:25,750 --> 00:17:31,540
them will successfully overwrite the

362
00:17:27,970 --> 00:17:33,250
older replicas<font color="#E5E5E5"> in region</font><font color="#CCCCCC"> one two of them</font>

363
00:17:31,540 --> 00:17:36,940
are written<font color="#CCCCCC"> to a temporary location in</font>

364
00:17:33,250 --> 00:17:40,120
region one but we<font color="#E5E5E5"> still have our old</font>

365
00:17:36,940 --> 00:17:42,990
replicas down in region two so again<font color="#CCCCCC"> we</font>

366
00:17:40,120 --> 00:17:46,540
see this eventual consistency<font color="#E5E5E5"> effect</font>

367
00:17:42,990 --> 00:17:48,460
that there is a<font color="#E5E5E5"> window</font><font color="#CCCCCC"> of time</font><font color="#E5E5E5"> why the</font>

368
00:17:46,540 --> 00:17:51,280
wider while the wide area<font color="#E5E5E5"> network</font><font color="#CCCCCC"> is</font>

369
00:17:48,460 --> 00:17:53,740
unavailable when reads<font color="#E5E5E5"> in the second</font>

370
00:17:51,280 --> 00:17:56,649
<font color="#E5E5E5">region may be reading temporarily</font>

371
00:17:53,740 --> 00:17:58,990
inconsistent<font color="#E5E5E5"> data as soon as</font><font color="#CCCCCC"> Network</font>

372
00:17:56,650 --> 00:18:01,450
<font color="#E5E5E5">heals background process has fixed that</font>

373
00:17:58,990 --> 00:18:04,060
<font color="#E5E5E5">Swift is always working to heal and</font><font color="#CCCCCC"> to</font>

374
00:18:01,450 --> 00:18:10,030
put the most consistent set of data into

375
00:18:04,060 --> 00:18:12,179
the<font color="#E5E5E5"> cluster so hopefully I'll our wide</font>

376
00:18:10,030 --> 00:18:15,700
area network<font color="#E5E5E5"> doesn't fail too often</font><font color="#CCCCCC"> and</font>

377
00:18:12,180 --> 00:18:18,220
but it may<font color="#E5E5E5"> be that it has lower</font>

378
00:18:15,700 --> 00:18:21,510
bandwidth or<font color="#CCCCCC"> higher latency</font><font color="#E5E5E5"> than the</font>

379
00:18:18,220 --> 00:18:24,040
network<font color="#CCCCCC"> within our our single site and</font>

380
00:18:21,510 --> 00:18:25,270
it wouldn't be unreasonable to<font color="#CCCCCC"> ask the</font>

381
00:18:24,040 --> 00:18:26,550
question well it isn't<font color="#CCCCCC"> actually</font><font color="#E5E5E5"> this a</font>

382
00:18:25,270 --> 00:18:29,860
terrible idea

383
00:18:26,550 --> 00:18:32,320
<font color="#E5E5E5">that now every one of the</font><font color="#CCCCCC"> write requests</font>

384
00:18:29,860 --> 00:18:34,929
into<font color="#CCCCCC"> the cluster are actually</font><font color="#E5E5E5"> having to</font>

385
00:18:32,320 --> 00:18:38,649
write data into<font color="#E5E5E5"> the remote region isn't</font>

386
00:18:34,930 --> 00:18:41,170
<font color="#CCCCCC">this going to slow</font><font color="#E5E5E5"> down every every put</font>

387
00:18:38,650 --> 00:18:43,030
request<font color="#E5E5E5"> every write request and the</font>

388
00:18:41,170 --> 00:18:46,840
answer to<font color="#CCCCCC"> that is potentially yes it</font>

389
00:18:43,030 --> 00:18:49,660
will so here I've<font color="#CCCCCC"> just built</font><font color="#E5E5E5"> a kind</font><font color="#CCCCCC"> of</font>

390
00:18:46,840 --> 00:18:51,419
<font color="#E5E5E5">development cluster and I artificially I</font>

391
00:18:49,660 --> 00:18:54,790
have this cluster I have some some

392
00:18:51,420 --> 00:18:57,090
storage devices in two<font color="#E5E5E5"> regions and I've</font>

393
00:18:54,790 --> 00:18:59,740
artificially slowed down the right time

394
00:18:57,090 --> 00:19:02,290
to<font color="#E5E5E5"> the storage nodes in one of those</font>

395
00:18:59,740 --> 00:19:05,130
regions<font color="#E5E5E5"> and</font><font color="#CCCCCC"> you can see as you'd expect</font>

396
00:19:02,290 --> 00:19:08,800
that<font color="#E5E5E5"> starting from a baseline of the</font>

397
00:19:05,130 --> 00:19:10,510
<font color="#CCCCCC">fairly responsive</font><font color="#E5E5E5"> solid the y axis here</font>

398
00:19:08,800 --> 00:19:13,629
<font color="#E5E5E5">is the overall</font>

399
00:19:10,510 --> 00:19:15,370
completion<font color="#E5E5E5"> time for a put</font><font color="#CCCCCC"> request</font><font color="#E5E5E5"> it</font>

400
00:19:13,630 --> 00:19:17,940
starts pretty healthy but as I start to

401
00:19:15,370 --> 00:19:21,070
<font color="#E5E5E5">increase the time to write those</font>

402
00:19:17,940 --> 00:19:23,310
replicas to<font color="#CCCCCC"> the remote region</font><font color="#E5E5E5"> you can</font>

403
00:19:21,070 --> 00:19:27,100
<font color="#CCCCCC">see the</font><font color="#E5E5E5"> overall request completion time</font>

404
00:19:23,310 --> 00:19:29,560
increases it's actually bounded<font color="#E5E5E5"> add</font>

405
00:19:27,100 --> 00:19:31,659
enough upper limit<font color="#E5E5E5"> because there's a</font>

406
00:19:29,560 --> 00:19:35,710
final<font color="#E5E5E5"> part of the whole truth that I</font>

407
00:19:31,660 --> 00:19:38,950
need to tell you<font color="#E5E5E5"> so Swift will require a</font>

408
00:19:35,710 --> 00:19:41,920
quorum<font color="#E5E5E5"> of successful</font><font color="#CCCCCC"> rights</font><font color="#E5E5E5"> it will then</font>

409
00:19:38,950 --> 00:19:45,070
try really hard<font color="#E5E5E5"> to write the remaining</font>

410
00:19:41,920 --> 00:19:48,430
replicas<font color="#CCCCCC"> but after some time outs which</font>

411
00:19:45,070 --> 00:19:50,470
we call the post quorum<font color="#CCCCCC"> timeout it'll</font>

412
00:19:48,430 --> 00:19:52,660
give up and say I have a replica<font color="#CCCCCC"> I have</font>

413
00:19:50,470 --> 00:19:54,100
a quorum<font color="#E5E5E5"> of replicas and I'm going to</font>

414
00:19:52,660 --> 00:19:56,560
<font color="#E5E5E5">return</font><font color="#CCCCCC"> to the client</font><font color="#E5E5E5"> and say this</font><font color="#CCCCCC"> write</font>

415
00:19:54,100 --> 00:19:59,379
was successful<font color="#CCCCCC"> so that</font><font color="#E5E5E5"> puts an upper cap</font>

416
00:19:56,560 --> 00:20:01,990
on this<font color="#CCCCCC"> degradation of</font><font color="#E5E5E5"> right performance</font>

417
00:19:59,380 --> 00:20:05,140
that you would see as your remote region

418
00:20:01,990 --> 00:20:07,180
became slower and slower<font color="#E5E5E5"> but this may</font>

419
00:20:05,140 --> 00:20:10,780
<font color="#E5E5E5">not</font><font color="#CCCCCC"> be great</font><font color="#E5E5E5"> and I mean these</font><font color="#CCCCCC"> numbers</font>

420
00:20:07,180 --> 00:20:12,550
are quite<font color="#E5E5E5"> extreme the latency</font><font color="#CCCCCC"> that I put</font>

421
00:20:10,780 --> 00:20:15,070
<font color="#CCCCCC">into these remote</font><font color="#E5E5E5"> writes but this isn't</font>

422
00:20:12,550 --> 00:20:17,169
<font color="#CCCCCC">great</font><font color="#E5E5E5"> so is there anything that we could</font>

423
00:20:15,070 --> 00:20:21,370
do to<font color="#E5E5E5"> improve this write</font><font color="#CCCCCC"> performance</font>

424
00:20:17,170 --> 00:20:24,700
<font color="#E5E5E5">when we have distributed regions well if</font>

425
00:20:21,370 --> 00:20:30,489
we<font color="#E5E5E5"> think back</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> what happened and when</font>

426
00:20:24,700 --> 00:20:32,710
the<font color="#CCCCCC"> one failed then what I described was</font>

427
00:20:30,490 --> 00:20:35,860
that the ring<font color="#E5E5E5"> would just write all four</font>

428
00:20:32,710 --> 00:20:37,690
replicas into the local region so how

429
00:20:35,860 --> 00:20:41,830
<font color="#CCCCCC">about if</font><font color="#E5E5E5"> we just deliberately did that</font>

430
00:20:37,690 --> 00:20:45,520
all<font color="#CCCCCC"> the time</font><font color="#E5E5E5"> and that's</font><font color="#CCCCCC"> the mode</font><font color="#E5E5E5"> that</font>

431
00:20:41,830 --> 00:20:49,120
<font color="#CCCCCC">Swift has</font><font color="#E5E5E5"> this called</font><font color="#CCCCCC"> write affinity as</font>

432
00:20:45,520 --> 00:20:51,040
opposed to read affinity just as I<font color="#E5E5E5"> said</font>

433
00:20:49,120 --> 00:20:53,639
what this does is it overrides the

434
00:20:51,040 --> 00:20:57,250
behavior of the<font color="#CCCCCC"> Ring so rather</font><font color="#E5E5E5"> than</font>

435
00:20:53,640 --> 00:20:59,260
directing<font color="#E5E5E5"> all four copies of the objects</font>

436
00:20:57,250 --> 00:21:01,990
<font color="#E5E5E5">to their intended locations in both</font>

437
00:20:59,260 --> 00:21:03,670
regions<font color="#E5E5E5"> it</font><font color="#CCCCCC"> actually writes the remote</font>

438
00:21:01,990 --> 00:21:06,910
copies to temporary locations in the

439
00:21:03,670 --> 00:21:10,620
local region<font color="#CCCCCC"> and that means</font><font color="#E5E5E5"> that the put</font>

440
00:21:06,910 --> 00:21:13,900
requests<font color="#E5E5E5"> will complete much more quickly</font>

441
00:21:10,620 --> 00:21:16,169
but we still have<font color="#CCCCCC"> four copy to</font><font color="#E5E5E5"> a data we</font>

442
00:21:13,900 --> 00:21:20,410
have a fully durable write our data

443
00:21:16,170 --> 00:21:21,970
<font color="#CCCCCC">albeit in</font><font color="#E5E5E5"> one region so this write</font>

444
00:21:20,410 --> 00:21:24,100
affinity mode is another trade off and

445
00:21:21,970 --> 00:21:27,010
<font color="#CCCCCC">it's temporarily trading off</font>

446
00:21:24,100 --> 00:21:30,699
the dispersion of our objects for

447
00:21:27,010 --> 00:21:32,970
increased<font color="#CCCCCC"> write performance</font><font color="#E5E5E5"> clearly</font>

448
00:21:30,700 --> 00:21:36,160
there's a window of<font color="#CCCCCC"> time here where if</font>

449
00:21:32,970 --> 00:21:38,110
our second region<font color="#E5E5E5"> was</font><font color="#CCCCCC"> too sorry</font><font color="#E5E5E5"> if our</font>

450
00:21:36,160 --> 00:21:40,419
first region was to become unavailable

451
00:21:38,110 --> 00:21:43,000
<font color="#E5E5E5">we would have no copy of the</font><font color="#CCCCCC"> object in</font>

452
00:21:40,419 --> 00:21:44,320
the second region but it's a trade-off

453
00:21:43,000 --> 00:21:48,190
that<font color="#E5E5E5"> we can use to improve performance</font>

454
00:21:44,320 --> 00:21:49,570
<font color="#CCCCCC">and</font><font color="#E5E5E5"> as you'd expect and I wouldn't be</font>

455
00:21:48,190 --> 00:21:51,850
telling<font color="#CCCCCC"> you about</font><font color="#E5E5E5"> this if it didn't work</font>

456
00:21:49,570 --> 00:21:54,730
<font color="#CCCCCC">so at the</font><font color="#E5E5E5"> end of this graph you can</font><font color="#CCCCCC"> see</font>

457
00:21:51,850 --> 00:21:57,219
<font color="#E5E5E5">I enabled and</font><font color="#CCCCCC"> right affinity and my test</font>

458
00:21:54,730 --> 00:21:59,740
cluster<font color="#E5E5E5"> and immediately the overall put</font>

459
00:21:57,220 --> 00:22:02,799
<font color="#E5E5E5">request</font><font color="#CCCCCC"> completion time has dropped back</font>

460
00:21:59,740 --> 00:22:07,600
<font color="#CCCCCC">down towards our baseline so this is</font>

461
00:22:02,799 --> 00:22:10,150
great<font color="#CCCCCC"> I should point out</font><font color="#E5E5E5"> though of</font>

462
00:22:07,600 --> 00:22:11,980
course with<font color="#E5E5E5"> write affinity enabled</font>

463
00:22:10,150 --> 00:22:15,370
<font color="#E5E5E5">although we're writing all</font><font color="#CCCCCC"> of the</font>

464
00:22:11,980 --> 00:22:17,590
replicas to<font color="#CCCCCC"> one region</font><font color="#E5E5E5"> the data is still</font>

465
00:22:15,370 --> 00:22:20,020
available<font color="#CCCCCC"> in</font><font color="#E5E5E5"> the other region it just</font>

466
00:22:17,590 --> 00:22:22,539
means that any<font color="#E5E5E5"> read request that's made</font>

467
00:22:20,020 --> 00:22:24,418
during<font color="#E5E5E5"> the window</font><font color="#CCCCCC"> of time before</font><font color="#E5E5E5"> those</font>

468
00:22:22,539 --> 00:22:27,129
replicas<font color="#CCCCCC"> have been</font><font color="#E5E5E5"> asynchronously moved</font>

469
00:22:24,419 --> 00:22:29,110
<font color="#E5E5E5">will be served by propagating back</font>

470
00:22:27,130 --> 00:22:32,980
across<font color="#E5E5E5"> the wide area</font><font color="#CCCCCC"> network and reading</font>

471
00:22:29,110 --> 00:22:34,990
the data<font color="#E5E5E5"> from region</font><font color="#CCCCCC"> one once the eight</font>

472
00:22:32,980 --> 00:22:36,460
<font color="#CCCCCC">wants the async</font><font color="#E5E5E5"> process completes their</font>

473
00:22:34,990 --> 00:22:39,130
nose reads that we served from<font color="#E5E5E5"> the local</font>

474
00:22:36,460 --> 00:22:41,740
region so we have no loss<font color="#E5E5E5"> of</font>

475
00:22:39,130 --> 00:22:43,539
availability<font color="#E5E5E5"> we have a temporary loss of</font>

476
00:22:41,740 --> 00:22:46,419
dispersion<font color="#CCCCCC"> but we still</font><font color="#E5E5E5"> have full</font>

477
00:22:43,539 --> 00:22:51,549
durability in the first<font color="#E5E5E5"> region and our</font>

478
00:22:46,419 --> 00:22:53,799
<font color="#E5E5E5">write</font><font color="#CCCCCC"> performance</font><font color="#E5E5E5"> is hugely improved and</font>

479
00:22:51,549 --> 00:22:56,850
of course I probably<font color="#CCCCCC"> don't</font><font color="#E5E5E5"> need to</font>

480
00:22:53,799 --> 00:22:59,309
<font color="#E5E5E5">repeat this but we're also trading off</font>

481
00:22:56,850 --> 00:23:03,639
consistency before<font color="#CCCCCC"> write performance</font>

482
00:22:59,309 --> 00:23:07,178
<font color="#E5E5E5">again my example</font><font color="#CCCCCC"> of an overwrite the</font>

483
00:23:03,640 --> 00:23:10,929
first write of t1 in the background

484
00:23:07,179 --> 00:23:13,600
<font color="#CCCCCC">swift has relocated</font><font color="#E5E5E5"> all of the replicas</font>

485
00:23:10,929 --> 00:23:16,900
<font color="#E5E5E5">to their correct locations so we have</font>

486
00:23:13,600 --> 00:23:20,020
two replicas of the object at t1<font color="#E5E5E5"> in the</font>

487
00:23:16,900 --> 00:23:21,970
second region with<font color="#E5E5E5"> right affinity we're</font>

488
00:23:20,020 --> 00:23:25,200
now deliberately deferring<font color="#E5E5E5"> the update</font>

489
00:23:21,970 --> 00:23:27,100
<font color="#CCCCCC">update of those two replicas in region 2</font>

490
00:23:25,200 --> 00:23:30,909
we're leaving that to our asynchronous

491
00:23:27,100 --> 00:23:33,580
background processes which means there

492
00:23:30,909 --> 00:23:37,309
<font color="#E5E5E5">is this window of time when we may be</font>

493
00:23:33,580 --> 00:23:40,580
reading<font color="#E5E5E5"> stale data in the second region</font>

494
00:23:37,309 --> 00:23:42,889
but that's okay<font color="#E5E5E5"> as long</font><font color="#CCCCCC"> as</font><font color="#E5E5E5"> we clearly</font>

495
00:23:40,580 --> 00:23:48,230
understand<font color="#CCCCCC"> the contract</font><font color="#E5E5E5"> of eventual</font>

496
00:23:42,889 --> 00:23:50,209
consistency the Swift offers so right

497
00:23:48,230 --> 00:23:52,700
affinities is is a powerful tool<font color="#CCCCCC"> but</font><font color="#E5E5E5"> you</font>

498
00:23:50,210 --> 00:23:54,970
do<font color="#E5E5E5"> need</font><font color="#CCCCCC"> to use</font><font color="#E5E5E5"> it carefully</font><font color="#CCCCCC"> it's not</font>

499
00:23:52,700 --> 00:23:57,799
<font color="#CCCCCC">always</font><font color="#E5E5E5"> appropriate</font><font color="#CCCCCC"> I mean first of all</font>

500
00:23:54,970 --> 00:24:00,860
there<font color="#CCCCCC"> is as I say no free lunch here at</font>

501
00:23:57,799 --> 00:24:03,918
some<font color="#CCCCCC"> point</font><font color="#E5E5E5"> data has to</font><font color="#CCCCCC"> be</font><font color="#E5E5E5"> moved across</font>

502
00:24:00,860 --> 00:24:05,899
the<font color="#CCCCCC"> wide area</font><font color="#E5E5E5"> network</font><font color="#CCCCCC"> so those replicas</font>

503
00:24:03,919 --> 00:24:08,210
that<font color="#E5E5E5"> we've written into temporary</font>

504
00:24:05,899 --> 00:24:12,799
locations<font color="#E5E5E5"> do need to be moved at some</font>

505
00:24:08,210 --> 00:24:16,129
point so if you have a workload<font color="#CCCCCC"> that has</font>

506
00:24:12,799 --> 00:24:18,740
a continuously high<font color="#E5E5E5"> write rate you know</font>

507
00:24:16,129 --> 00:24:22,129
continuously<font color="#CCCCCC"> high ingress into</font><font color="#E5E5E5"> your</font>

508
00:24:18,740 --> 00:24:24,230
cluster then those<font color="#CCCCCC"> misplaced replicas</font>

509
00:24:22,129 --> 00:24:24,769
are likely to back up<font color="#E5E5E5"> in your</font><font color="#CCCCCC"> local</font>

510
00:24:24,230 --> 00:24:27,110
region

511
00:24:24,769 --> 00:24:31,360
if the asynchronous processes can't keep

512
00:24:27,110 --> 00:24:31,360
up with<font color="#E5E5E5"> the ingress rate of your rights</font>

513
00:24:31,480 --> 00:24:38,450
<font color="#E5E5E5">also if you have a use case where users</font>

514
00:24:34,929 --> 00:24:41,419
clients of the remote region are trying

515
00:24:38,450 --> 00:24:45,019
to read object data<font color="#E5E5E5"> immediately after is</font>

516
00:24:41,419 --> 00:24:46,610
written then well those reads are going

517
00:24:45,019 --> 00:24:48,649
to end up having<font color="#CCCCCC"> to</font><font color="#E5E5E5"> go and fetch data</font>

518
00:24:46,610 --> 00:24:50,570
back<font color="#CCCCCC"> from their remote region because it</font>

519
00:24:48,649 --> 00:24:53,149
hasn't<font color="#E5E5E5"> yet been moved</font><font color="#CCCCCC"> to low to their</font>

520
00:24:50,570 --> 00:24:54,769
local<font color="#CCCCCC"> region</font><font color="#E5E5E5"> and if that's happening</font>

521
00:24:53,149 --> 00:24:56,779
well you might as<font color="#CCCCCC"> well have written the</font>

522
00:24:54,769 --> 00:24:58,549
data<font color="#E5E5E5"> across the wider</font><font color="#CCCCCC"> network rather</font>

523
00:24:56,779 --> 00:25:00,999
<font color="#E5E5E5">than go and read it</font><font color="#CCCCCC"> immediately</font><font color="#E5E5E5"> after it</font>

524
00:24:58,549 --> 00:25:03,740
was<font color="#E5E5E5"> written into the local region</font><font color="#CCCCCC"> thanks</font>

525
00:25:00,999 --> 00:25:06,409
<font color="#CCCCCC">so there are some workloads</font><font color="#E5E5E5"> that</font>

526
00:25:03,740 --> 00:25:08,990
wouldn't be<font color="#CCCCCC"> suitable for</font><font color="#E5E5E5"> write affinity</font>

527
00:25:06,409 --> 00:25:11,499
and in<font color="#E5E5E5"> fact if you have a very high</font>

528
00:25:08,990 --> 00:25:14,690
ingress rate it's probably best to<font color="#CCCCCC"> just</font>

529
00:25:11,499 --> 00:25:17,330
take the hit<font color="#E5E5E5"> of whatever the latency is</font>

530
00:25:14,690 --> 00:25:20,710
of<font color="#E5E5E5"> doing those remote writes and that in</font>

531
00:25:17,330 --> 00:25:23,899
turn will<font color="#E5E5E5"> generate some</font><font color="#CCCCCC"> appropriate</font>

532
00:25:20,710 --> 00:25:26,710
feedback<font color="#E5E5E5"> to the clients and</font><font color="#CCCCCC"> just kind of</font>

533
00:25:23,899 --> 00:25:29,479
govern the ingress rate into a cluster

534
00:25:26,710 --> 00:25:32,450
but there are some workloads where<font color="#E5E5E5"> write</font>

535
00:25:29,480 --> 00:25:34,749
affinity is a really useful tool<font color="#E5E5E5"> so if</font>

536
00:25:32,450 --> 00:25:37,700
you have bursty traffic<font color="#E5E5E5"> for example</font><font color="#CCCCCC"> and</font>

537
00:25:34,749 --> 00:25:39,230
where you want to accept a lot<font color="#E5E5E5"> of</font><font color="#CCCCCC"> writes</font>

538
00:25:37,700 --> 00:25:41,409
into<font color="#CCCCCC"> the cluster but then you have a</font>

539
00:25:39,230 --> 00:25:44,019
quiet period<font color="#E5E5E5"> when you can be</font>

540
00:25:41,409 --> 00:25:46,580
asynchronously moving replicas<font color="#E5E5E5"> and</font>

541
00:25:44,019 --> 00:25:50,090
<font color="#E5E5E5">working towards the dispersion goal that</font>

542
00:25:46,580 --> 00:25:51,240
<font color="#E5E5E5">we have and in</font><font color="#CCCCCC"> particular if</font><font color="#E5E5E5"> your remote</font>

543
00:25:50,090 --> 00:25:52,800
clients don't<font color="#E5E5E5"> have</font>

544
00:25:51,240 --> 00:25:56,070
acquirement to be immediately reading

545
00:25:52,800 --> 00:25:59,940
data<font color="#E5E5E5"> them</font><font color="#CCCCCC"> write affinity is perhaps</font>

546
00:25:56,070 --> 00:26:02,399
suitable<font color="#E5E5E5"> to so for example if your</font><font color="#CCCCCC"> goal</font>

547
00:25:59,940 --> 00:26:07,550
is<font color="#E5E5E5"> to replicate archives for delayed</font>

548
00:26:02,400 --> 00:26:07,550
access by clients in multiple regions

549
00:26:10,790 --> 00:26:17,909
<font color="#E5E5E5">okay so</font><font color="#CCCCCC"> swift is very well able</font><font color="#E5E5E5"> to</font>

550
00:26:15,020 --> 00:26:20,639
<font color="#E5E5E5">support distributed geographically</font>

551
00:26:17,910 --> 00:26:23,010
distributed<font color="#E5E5E5"> clusters and shown you a</font>

552
00:26:20,640 --> 00:26:26,040
couple<font color="#CCCCCC"> of the tools</font><font color="#E5E5E5"> and tuning options</font>

553
00:26:23,010 --> 00:26:30,990
<font color="#E5E5E5">that we have to make some</font><font color="#CCCCCC"> trade-offs</font>

554
00:26:26,040 --> 00:26:32,309
<font color="#E5E5E5">when doing that and we also have this</font>

555
00:26:30,990 --> 00:26:33,840
other really<font color="#E5E5E5"> nice feature we</font><font color="#CCCCCC"> have many</font>

556
00:26:32,309 --> 00:26:37,410
nice features<font color="#CCCCCC"> but another one</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> rater</font>

557
00:26:33,840 --> 00:26:39,209
<font color="#E5E5E5">coding and I say here with an</font>

558
00:26:37,410 --> 00:26:40,770
<font color="#E5E5E5">exclamation mark</font><font color="#CCCCCC"> Swift</font><font color="#E5E5E5"> now supports</font>

559
00:26:39,210 --> 00:26:43,410
these now what I want<font color="#E5E5E5"> to</font><font color="#CCCCCC"> emphasize is</font>

560
00:26:40,770 --> 00:26:46,340
<font color="#E5E5E5">Swift now supports the combination of</font>

561
00:26:43,410 --> 00:26:48,870
<font color="#E5E5E5">erasure code with distributed clusters</font>

562
00:26:46,340 --> 00:26:50,610
<font color="#CCCCCC">and until</font><font color="#E5E5E5"> this last year that</font><font color="#CCCCCC"> was</font>

563
00:26:48,870 --> 00:26:54,449
something where the two<font color="#E5E5E5"> features didn't</font>

564
00:26:50,610 --> 00:26:56,729
work too<font color="#CCCCCC"> well together and and so I'm</font>

565
00:26:54,450 --> 00:26:59,700
<font color="#E5E5E5">just going</font><font color="#CCCCCC"> to kind of</font><font color="#E5E5E5"> explain why that</font>

566
00:26:56,730 --> 00:27:01,800
was and the steps we've taken to<font color="#E5E5E5"> fix</font>

567
00:26:59,700 --> 00:27:06,260
that because<font color="#E5E5E5"> there's some again</font><font color="#CCCCCC"> some</font>

568
00:27:01,800 --> 00:27:06,260
interesting choices that we had to make

569
00:27:09,080 --> 00:27:13,710
apologies<font color="#E5E5E5"> to those of you that have a</font>

570
00:27:11,970 --> 00:27:15,840
really great<font color="#CCCCCC"> understanding of erasure</font>

571
00:27:13,710 --> 00:27:19,980
coding<font color="#E5E5E5"> I felt I</font><font color="#CCCCCC"> should very briefly just</font>

572
00:27:15,840 --> 00:27:22,470
<font color="#CCCCCC">describe and what it is so</font><font color="#E5E5E5"> a rage coding</font>

573
00:27:19,980 --> 00:27:26,160
is a very<font color="#E5E5E5"> popular technique for storing</font>

574
00:27:22,470 --> 00:27:31,020
<font color="#CCCCCC">data and durably for using less</font><font color="#E5E5E5"> storage</font>

575
00:27:26,160 --> 00:27:33,660
<font color="#E5E5E5">space</font><font color="#CCCCCC"> than a replication policy</font><font color="#E5E5E5"> it's a</font>

576
00:27:31,020 --> 00:27:36,300
<font color="#E5E5E5">mathematical</font><font color="#CCCCCC"> algorithm</font><font color="#E5E5E5"> and in the</font>

577
00:27:33,660 --> 00:27:39,179
example<font color="#CCCCCC"> I'm showing here we would have a</font>

578
00:27:36,300 --> 00:27:43,169
coding<font color="#E5E5E5"> algorithm that accepts a blob of</font>

579
00:27:39,179 --> 00:27:44,850
data splits it into<font color="#E5E5E5"> a number of</font>

580
00:27:43,170 --> 00:27:48,090
<font color="#CCCCCC">fragments</font><font color="#E5E5E5"> so in this case</font><font color="#CCCCCC"> us the data</font>

581
00:27:44,850 --> 00:27:50,520
has been<font color="#E5E5E5"> split into four data</font><font color="#CCCCCC"> fragments</font>

582
00:27:48,090 --> 00:27:52,949
and<font color="#E5E5E5"> in the erasure code also calculates</font>

583
00:27:50,520 --> 00:27:54,840
<font color="#E5E5E5">a number of parity fragments and the</font>

584
00:27:52,950 --> 00:27:58,890
example I've chosen here we have<font color="#E5E5E5"> to</font>

585
00:27:54,840 --> 00:28:00,510
<font color="#E5E5E5">parity fragments and we at least in</font>

586
00:27:58,890 --> 00:28:04,150
<font color="#E5E5E5">Swift community we'd refer to this as a</font>

587
00:28:00,510 --> 00:28:05,890
<font color="#E5E5E5">four plus</font><font color="#CCCCCC"> two erasure coding scheme</font>

588
00:28:04,150 --> 00:28:09,340
now each of those<font color="#CCCCCC"> parity fragments is</font>

589
00:28:05,890 --> 00:28:12,580
the same size as a data fragment so in

590
00:28:09,340 --> 00:28:16,389
this example<font color="#E5E5E5"> we've added two more</font>

591
00:28:12,580 --> 00:28:20,320
fragments<font color="#E5E5E5"> so we have added 50% more to</font>

592
00:28:16,390 --> 00:28:22,120
the size of the original<font color="#E5E5E5"> data the really</font>

593
00:28:20,320 --> 00:28:23,500
nice interesting<font color="#E5E5E5"> feature of erasure</font>

594
00:28:22,120 --> 00:28:26,139
codes<font color="#E5E5E5"> and the reason they're</font><font color="#CCCCCC"> called</font>

595
00:28:23,500 --> 00:28:30,040
erasure codes<font color="#E5E5E5"> is that</font><font color="#CCCCCC"> we can lose we can</font>

596
00:28:26,140 --> 00:28:34,560
erase any<font color="#E5E5E5"> two of that fragment set and</font>

597
00:28:30,040 --> 00:28:37,389
still reconstruct at the original<font color="#CCCCCC"> data</font>

598
00:28:34,560 --> 00:28:40,540
now raising<font color="#E5E5E5"> to sounds familiar to</font><font color="#CCCCCC"> a</font>

599
00:28:37,390 --> 00:28:42,250
three<font color="#E5E5E5"> replicas storage policy we had</font>

600
00:28:40,540 --> 00:28:43,450
three replicas we could lose two of

601
00:28:42,250 --> 00:28:46,900
<font color="#CCCCCC">those replicas and we'd still have a</font>

602
00:28:43,450 --> 00:28:50,680
complete copy<font color="#E5E5E5"> of our object</font><font color="#CCCCCC"> and here we</font>

603
00:28:46,900 --> 00:28:53,380
can lose two<font color="#CCCCCC"> of our fragments</font><font color="#E5E5E5"> and still</font>

604
00:28:50,680 --> 00:28:54,550
reconstruct the original<font color="#E5E5E5"> objects but</font>

605
00:28:53,380 --> 00:28:56,890
we're actually only using one and<font color="#E5E5E5"> a half</font>

606
00:28:54,550 --> 00:29:00,580
times the<font color="#E5E5E5"> size</font><font color="#CCCCCC"> of the data</font><font color="#E5E5E5"> that's why</font>

607
00:28:56,890 --> 00:29:03,310
<font color="#E5E5E5">Rachel coding is very popular here's how</font>

608
00:29:00,580 --> 00:29:05,710
it works out<font color="#E5E5E5"> in Swift so erasure coding</font>

609
00:29:03,310 --> 00:29:09,909
is implemented in<font color="#E5E5E5"> the Swift proxy as</font>

610
00:29:05,710 --> 00:29:12,010
data<font color="#E5E5E5"> is inbound into the cluster I'm</font>

611
00:29:09,910 --> 00:29:15,130
sticking with<font color="#E5E5E5"> the same example for data</font>

612
00:29:12,010 --> 00:29:17,170
fragments<font color="#E5E5E5"> plus to parity fragments</font><font color="#CCCCCC"> I</font>

613
00:29:15,130 --> 00:29:19,180
just<font color="#E5E5E5"> mentioned we have a couple of open</font>

614
00:29:17,170 --> 00:29:23,080
source libraries that<font color="#E5E5E5"> we use to</font>

615
00:29:19,180 --> 00:29:25,480
implement<font color="#E5E5E5"> the algorithms and the ring</font>

616
00:29:23,080 --> 00:29:27,399
behaves exactly as it<font color="#E5E5E5"> behaves for</font>

617
00:29:25,480 --> 00:29:29,680
replicas in fact the ring is<font color="#CCCCCC"> completely</font>

618
00:29:27,400 --> 00:29:32,920
unaware<font color="#CCCCCC"> that is dealing with erasure</font>

619
00:29:29,680 --> 00:29:34,660
code fragments rather than replicas<font color="#CCCCCC"> so</font>

620
00:29:32,920 --> 00:29:37,690
as I said before<font color="#E5E5E5"> the ring is always</font>

621
00:29:34,660 --> 00:29:39,760
trying to disperse fragments across the

622
00:29:37,690 --> 00:29:42,000
storage pool and we end up<font color="#E5E5E5"> with one of</font>

623
00:29:39,760 --> 00:29:45,910
<font color="#E5E5E5">these fragments on each of our servers</font>

624
00:29:42,000 --> 00:29:49,810
<font color="#E5E5E5">on a disk which means that we can lose</font>

625
00:29:45,910 --> 00:29:51,910
<font color="#E5E5E5">two disks and still</font><font color="#CCCCCC"> reconstruct our</font>

626
00:29:49,810 --> 00:29:55,870
<font color="#CCCCCC">object data and we're using</font>

627
00:29:51,910 --> 00:29:57,430
approximately<font color="#E5E5E5"> 50% of storage compared to</font>

628
00:29:55,870 --> 00:30:01,750
a three replicas scheme which gives us

629
00:29:57,430 --> 00:30:03,160
similar durability so that's great<font color="#E5E5E5"> what</font>

630
00:30:01,750 --> 00:30:04,390
was the problem with distributed

631
00:30:03,160 --> 00:30:07,810
clusters isn't this just<font color="#E5E5E5"> going to work</font>

632
00:30:04,390 --> 00:30:11,320
<font color="#E5E5E5">well let me add back</font><font color="#CCCCCC"> in the regions</font><font color="#E5E5E5"> into</font>

633
00:30:07,810 --> 00:30:13,690
<font color="#CCCCCC">my storage</font><font color="#E5E5E5"> pool same array coding scheme</font>

634
00:30:11,320 --> 00:30:16,360
<font color="#E5E5E5">for data fragments</font><font color="#CCCCCC"> to parity fragments</font>

635
00:30:13,690 --> 00:30:18,179
<font color="#E5E5E5">the ring has done its job</font><font color="#CCCCCC"> the ring</font><font color="#E5E5E5"> has</font>

636
00:30:16,360 --> 00:30:21,949
dispersed the fragments

637
00:30:18,179 --> 00:30:21,950
at uniformly across the regions

638
00:30:22,820 --> 00:30:28,110
unfortunately though this<font color="#CCCCCC"> only</font><font color="#E5E5E5"> leaves us</font>

639
00:30:26,070 --> 00:30:32,309
with three fragments<font color="#CCCCCC"> in each of our</font>

640
00:30:28,110 --> 00:30:36,119
regions and we need<font color="#E5E5E5"> four fragments to go</font>

641
00:30:32,309 --> 00:30:39,330
to reconstruct the object<font color="#E5E5E5"> so now we</font>

642
00:30:36,119 --> 00:30:41,850
don't yet have<font color="#E5E5E5"> our disaster recover</font>

643
00:30:39,330 --> 00:30:44,249
recovery data durability property<font color="#E5E5E5"> if we</font>

644
00:30:41,850 --> 00:30:47,928
lose one of our<font color="#CCCCCC"> regions we don't have</font>

645
00:30:44,249 --> 00:30:50,519
sufficient fragments<font color="#E5E5E5"> in the</font><font color="#CCCCCC"> other region</font>

646
00:30:47,929 --> 00:30:51,480
so although<font color="#E5E5E5"> in the single site case this</font>

647
00:30:50,519 --> 00:30:53,700
<font color="#CCCCCC">4+2</font>

648
00:30:51,480 --> 00:30:56,129
<font color="#CCCCCC">rater</font><font color="#E5E5E5"> code policy gave us similar</font>

649
00:30:53,700 --> 00:30:59,249
<font color="#E5E5E5">durability to a triple</font><font color="#CCCCCC"> replica when we</font>

650
00:30:56,129 --> 00:31:01,918
move to a multi region case it's not

651
00:30:59,249 --> 00:31:04,259
actually quite enough<font color="#CCCCCC"> and which</font><font color="#E5E5E5"> is</font>

652
00:31:01,919 --> 00:31:06,330
reasonable because<font color="#E5E5E5"> we're storing nowhere</font>

653
00:31:04,259 --> 00:31:10,350
near as<font color="#E5E5E5"> much data as</font><font color="#CCCCCC"> we were in the case</font>

654
00:31:06,330 --> 00:31:13,199
of a replicator policy so what we need

655
00:31:10,350 --> 00:31:16,498
and we<font color="#CCCCCC"> need some more fragments</font><font color="#E5E5E5"> and so</font>

656
00:31:13,200 --> 00:31:18,899
how about<font color="#E5E5E5"> if I change the array to</font>

657
00:31:16,499 --> 00:31:20,610
coding scheme that we're using and now

658
00:31:18,899 --> 00:31:22,649
I'm still going to<font color="#E5E5E5"> have four data</font>

659
00:31:20,610 --> 00:31:24,869
<font color="#CCCCCC">fragments but</font><font color="#E5E5E5"> I'm going to have six</font>

660
00:31:22,649 --> 00:31:30,389
parity fragments<font color="#E5E5E5"> get to be a total of</font>

661
00:31:24,869 --> 00:31:32,249
<font color="#E5E5E5">ten fragments</font><font color="#CCCCCC"> why did I</font><font color="#E5E5E5"> choose that</font>

662
00:31:30,389 --> 00:31:34,519
scheme in particular well that it ends

663
00:31:32,249 --> 00:31:37,799
up with five fragments<font color="#CCCCCC"> in each region</font>

664
00:31:34,519 --> 00:31:39,659
<font color="#E5E5E5">for fragments is enough to reconstruct</font>

665
00:31:37,799 --> 00:31:42,059
my data so I can<font color="#E5E5E5"> lose an entire region</font>

666
00:31:39,659 --> 00:31:44,249
<font color="#CCCCCC">and still reconstruct my data</font><font color="#E5E5E5"> and in</font>

667
00:31:42,059 --> 00:31:47,908
fact I can<font color="#CCCCCC"> lose a device</font><font color="#E5E5E5"> within a region</font>

668
00:31:44,249 --> 00:31:50,249
<font color="#E5E5E5">and still reconstruct data so this</font>

669
00:31:47,909 --> 00:31:53,669
scheme is now equivalent<font color="#E5E5E5"> to four</font>

670
00:31:50,249 --> 00:31:55,529
replicas and it's<font color="#CCCCCC"> using about two and</font><font color="#E5E5E5"> a</font>

671
00:31:53,669 --> 00:31:57,710
<font color="#CCCCCC">half times</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> size of the data versus</font>

672
00:31:55,529 --> 00:32:00,240
four times the<font color="#CCCCCC"> size height of the data</font>

673
00:31:57,710 --> 00:32:01,830
so this<font color="#E5E5E5"> is looking looking good</font><font color="#CCCCCC"> okay</font>

674
00:32:00,240 --> 00:32:04,740
this this works this gives us our

675
00:32:01,830 --> 00:32:07,439
distributed cluster with<font color="#E5E5E5"> a</font><font color="#CCCCCC"> disaster</font>

676
00:32:04,740 --> 00:32:09,720
recovery<font color="#E5E5E5"> we have data locality we can</font>

677
00:32:07,440 --> 00:32:10,619
read and the data from either region

678
00:32:09,720 --> 00:32:13,409
<font color="#CCCCCC">without going across the wide area</font>

679
00:32:10,619 --> 00:32:16,649
<font color="#E5E5E5">network are we done</font>

680
00:32:13,409 --> 00:32:19,019
no unfortunately<font color="#CCCCCC"> we had another problem</font>

681
00:32:16,649 --> 00:32:20,580
<font color="#CCCCCC">because we realized that calculating</font><font color="#E5E5E5"> all</font>

682
00:32:19,019 --> 00:32:23,159
of those extra parity fragments

683
00:32:20,580 --> 00:32:25,320
introduces a compute burden<font color="#E5E5E5"> in the proxy</font>

684
00:32:23,159 --> 00:32:28,350
server<font color="#CCCCCC"> and I've</font><font color="#E5E5E5"> just calculated an</font>

685
00:32:25,320 --> 00:32:30,389
example here it's<font color="#E5E5E5"> like the the relative</font>

686
00:32:28,350 --> 00:32:32,100
<font color="#E5E5E5">compute time for a</font><font color="#CCCCCC"> fourteen megabyte to</font>

687
00:32:30,389 --> 00:32:34,110
encode<font color="#E5E5E5"> a fourteen megabyte object</font>

688
00:32:32,100 --> 00:32:37,919
using one of the<font color="#E5E5E5"> backends</font><font color="#CCCCCC"> that we have</font>

689
00:32:34,110 --> 00:32:40,409
available<font color="#CCCCCC"> the</font><font color="#E5E5E5"> x-axis is the number</font><font color="#CCCCCC"> of</font>

690
00:32:37,920 --> 00:32:43,080
parity fragments and I'm always using

691
00:32:40,410 --> 00:32:45,060
<font color="#E5E5E5">four data fragments so as we go from</font>

692
00:32:43,080 --> 00:32:47,669
<font color="#E5E5E5">four plus</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> where we started to four</font>

693
00:32:45,060 --> 00:32:51,300
plus<font color="#E5E5E5"> six we're roughly doubling the</font>

694
00:32:47,670 --> 00:32:52,950
compute time<font color="#CCCCCC"> - to encode this object</font><font color="#E5E5E5"> and</font>

695
00:32:51,300 --> 00:32:59,399
that turns into latency<font color="#E5E5E5"> in our right</font>

696
00:32:52,950 --> 00:33:02,460
path so<font color="#E5E5E5"> that wasn't</font><font color="#CCCCCC"> great so</font><font color="#E5E5E5"> we had</font>

697
00:32:59,400 --> 00:33:03,060
<font color="#E5E5E5">another thing and somebody very clever</font>

698
00:33:02,460 --> 00:33:05,220
<font color="#E5E5E5">not me</font>

699
00:33:03,060 --> 00:33:07,530
made the observation<font color="#CCCCCC"> that although we</font>

700
00:33:05,220 --> 00:33:10,620
<font color="#E5E5E5">want to have five fragments in each</font>

701
00:33:07,530 --> 00:33:12,660
<font color="#CCCCCC">region and the fragments</font><font color="#E5E5E5"> in each region</font>

702
00:33:10,620 --> 00:33:14,909
<font color="#CCCCCC">need to be unique with respect to each</font>

703
00:33:12,660 --> 00:33:17,460
other<font color="#E5E5E5"> they don't</font><font color="#CCCCCC"> need to be different</font>

704
00:33:14,910 --> 00:33:19,170
<font color="#CCCCCC">fragments in the</font><font color="#E5E5E5"> two regions so instead</font>

705
00:33:17,460 --> 00:33:21,480
<font color="#CCCCCC">of calculating more parity fragments how</font>

706
00:33:19,170 --> 00:33:23,940
about we just duplicate the set of

707
00:33:21,480 --> 00:33:26,790
<font color="#CCCCCC">fragments we have and spread them across</font>

708
00:33:23,940 --> 00:33:30,570
the two regions so this means I can<font color="#E5E5E5"> drop</font>

709
00:33:26,790 --> 00:33:33,810
back<font color="#E5E5E5"> to four data fragments and just one</font>

710
00:33:30,570 --> 00:33:37,590
parity fragment much less compute<font color="#E5E5E5"> burden</font>

711
00:33:33,810 --> 00:33:40,620
and and then I can to placate<font color="#E5E5E5"> the set of</font>

712
00:33:37,590 --> 00:33:43,620
fragments<font color="#E5E5E5"> distribute them</font><font color="#CCCCCC"> across my</font>

713
00:33:40,620 --> 00:33:45,929
<font color="#E5E5E5">cluster and I have the result nice</font>

714
00:33:43,620 --> 00:33:47,790
looking for<font color="#E5E5E5"> still using same amount of</font>

715
00:33:45,930 --> 00:33:49,020
data as storage data on<font color="#E5E5E5"> disk</font>

716
00:33:47,790 --> 00:33:51,690
<font color="#E5E5E5">two-and-a-half times the size the</font>

717
00:33:49,020 --> 00:33:53,670
original data<font color="#E5E5E5"> getting the durability and</font>

718
00:33:51,690 --> 00:33:57,390
<font color="#E5E5E5">the</font><font color="#CCCCCC"> data locality that I would have got</font>

719
00:33:53,670 --> 00:33:59,280
with a four<font color="#CCCCCC"> replicas policy</font><font color="#E5E5E5"> okay</font><font color="#CCCCCC"> great</font>

720
00:33:57,390 --> 00:34:01,560
looking good<font color="#CCCCCC"> again I'm I'm smiling again</font>

721
00:33:59,280 --> 00:34:04,500
<font color="#E5E5E5">with this but there's one last problem</font>

722
00:34:01,560 --> 00:34:07,200
that<font color="#CCCCCC"> we faced</font><font color="#E5E5E5"> which is unfortunately</font>

723
00:34:04,500 --> 00:34:09,210
although the ring does a great job<font color="#E5E5E5"> of</font>

724
00:34:07,200 --> 00:34:13,080
dispersing fragments throughout our

725
00:34:09,210 --> 00:34:15,750
cluster<font color="#E5E5E5"> it makes no guarantees as to</font>

726
00:34:13,080 --> 00:34:19,590
which fragment<font color="#E5E5E5"> goes to which device or</font>

727
00:34:15,750 --> 00:34:22,350
to which region<font color="#E5E5E5"> so we can end up in a</font>

728
00:34:19,590 --> 00:34:24,450
situation<font color="#E5E5E5"> like this</font><font color="#CCCCCC"> where we have five</font>

729
00:34:22,350 --> 00:34:27,179
fragments in each region<font color="#CCCCCC"> but we don't</font>

730
00:34:24,449 --> 00:34:27,870
actually have unique sets of fragments

731
00:34:27,179 --> 00:34:30,899
in each region

732
00:34:27,870 --> 00:34:32,730
so here I've ended up my example in the

733
00:34:30,900 --> 00:34:35,460
second<font color="#E5E5E5"> region I have</font><font color="#CCCCCC"> two copies of</font>

734
00:34:32,730 --> 00:34:37,560
fragment one two copies of fragment

735
00:34:35,460 --> 00:34:39,179
three and one copy fragment to which

736
00:34:37,560 --> 00:34:41,250
only<font color="#E5E5E5"> gives me three unique fragments and</font>

737
00:34:39,179 --> 00:34:44,739
<font color="#E5E5E5">again that's not enough</font><font color="#CCCCCC"> for</font><font color="#E5E5E5"> me to</font>

738
00:34:41,250 --> 00:34:47,330
<font color="#CCCCCC">reconstruct data from that region alone</font>

739
00:34:44,739 --> 00:34:50,569
so there's one final<font color="#CCCCCC"> piece in the</font><font color="#E5E5E5"> jigsaw</font>

740
00:34:47,330 --> 00:34:53,900
<font color="#CCCCCC">or the the journey if you</font><font color="#E5E5E5"> like towards</font>

741
00:34:50,570 --> 00:34:56,320
this getting a<font color="#CCCCCC"> rager</font><font color="#E5E5E5"> code and support up</font>

742
00:34:53,900 --> 00:35:00,020
<font color="#E5E5E5">together for just distributed clusters</font>

743
00:34:56,320 --> 00:35:02,930
and that was to add what we<font color="#E5E5E5"> call a</font>

744
00:35:00,020 --> 00:35:05,120
composite ring and it's actually<font color="#CCCCCC"> quite a</font>

745
00:35:02,930 --> 00:35:06,710
simple<font color="#CCCCCC"> idea</font><font color="#E5E5E5"> what we do here is</font><font color="#CCCCCC"> we just</font>

746
00:35:05,120 --> 00:35:09,500
<font color="#E5E5E5">take two of our record two of our</font>

747
00:35:06,710 --> 00:35:11,840
<font color="#E5E5E5">regular rings and allocate one ring to</font>

748
00:35:09,500 --> 00:35:13,280
<font color="#CCCCCC">each of the</font><font color="#E5E5E5"> regions so now we have a</font>

749
00:35:11,840 --> 00:35:15,620
ring<font color="#CCCCCC"> just behaving</font><font color="#E5E5E5"> exactly as it</font>

750
00:35:13,280 --> 00:35:17,360
normally would<font color="#E5E5E5"> but it's just responsible</font>

751
00:35:15,620 --> 00:35:20,060
<font color="#CCCCCC">for managing the</font><font color="#E5E5E5"> dispersion and the load</font>

752
00:35:17,360 --> 00:35:22,460
balancing in one region<font color="#CCCCCC"> and another</font><font color="#E5E5E5"> ring</font>

753
00:35:20,060 --> 00:35:24,560
for the other region and then this new

754
00:35:22,460 --> 00:35:27,530
composite ring<font color="#E5E5E5"> concept we have</font>

755
00:35:24,560 --> 00:35:30,290
guarantees that the duplicate sets of

756
00:35:27,530 --> 00:35:34,670
fragments are always spread between<font color="#E5E5E5"> the</font>

757
00:35:30,290 --> 00:35:35,870
<font color="#E5E5E5">two regions and that</font><font color="#CCCCCC"> was the end of our</font>

758
00:35:34,670 --> 00:35:37,310
<font color="#E5E5E5">that's the end of our solution that's</font>

759
00:35:35,870 --> 00:35:39,560
<font color="#E5E5E5">that's how it works</font>

760
00:35:37,310 --> 00:35:41,930
so now we're guaranteed to<font color="#E5E5E5"> always have a</font>

761
00:35:39,560 --> 00:35:44,529
set of unique array<font color="#CCCCCC"> two code fragments</font>

762
00:35:41,930 --> 00:35:49,040
in each region we have disaster recovery

763
00:35:44,530 --> 00:35:51,020
we have data locality<font color="#E5E5E5"> and we get all the</font>

764
00:35:49,040 --> 00:35:55,880
benefits of reduced storage requirements

765
00:35:51,020 --> 00:35:59,450
that<font color="#E5E5E5"> come from a range of coding</font><font color="#CCCCCC"> and</font>

766
00:35:55,880 --> 00:36:00,980
that's it<font color="#CCCCCC"> and</font><font color="#E5E5E5"> it's</font><font color="#CCCCCC"> in my talk thanks for</font>

767
00:35:59,450 --> 00:36:06,319
attention<font color="#CCCCCC"> and I</font><font color="#E5E5E5"> think we have some time</font>

768
00:36:00,980 --> 00:36:07,610
<font color="#E5E5E5">few minutes for some</font><font color="#CCCCCC"> questions why you</font>

769
00:36:06,320 --> 00:36:11,030
think<font color="#CCCCCC"> B questions I'm just</font><font color="#E5E5E5"> going to pop</font>

770
00:36:07,610 --> 00:36:15,440
this<font color="#CCCCCC"> up</font><font color="#E5E5E5"> and welcome anyone who'd like to</font>

771
00:36:11,030 --> 00:36:17,630
<font color="#CCCCCC">come and contribute</font><font color="#E5E5E5"> yeah great question</font>

772
00:36:15,440 --> 00:36:19,460
<font color="#CCCCCC">so the question was</font><font color="#E5E5E5"> how do we do</font>

773
00:36:17,630 --> 00:36:21,850
rebalancing<font color="#E5E5E5"> and I probably need</font><font color="#CCCCCC"> to add</font>

774
00:36:19,460 --> 00:36:26,020
some context of<font color="#E5E5E5"> the question</font><font color="#CCCCCC"> so</font>

775
00:36:21,850 --> 00:36:29,330
rebalancing is a process in Swift<font color="#E5E5E5"> when</font>

776
00:36:26,020 --> 00:36:30,590
devices are added or removed<font color="#E5E5E5"> to the</font>

777
00:36:29,330 --> 00:36:33,110
<font color="#E5E5E5">storage pool</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> assume that's what you're</font>

778
00:36:30,590 --> 00:36:35,660
<font color="#E5E5E5">referring to and and so when that</font>

779
00:36:33,110 --> 00:36:37,340
<font color="#CCCCCC">happens</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> need to move data that was</font>

780
00:36:35,660 --> 00:36:40,250
previously resident on<font color="#E5E5E5"> a device has</font><font color="#CCCCCC"> been</font>

781
00:36:37,340 --> 00:36:42,680
removed<font color="#E5E5E5"> and we might need to</font><font color="#CCCCCC"> move data</font>

782
00:36:40,250 --> 00:36:48,290
to populate<font color="#E5E5E5"> a device that's been added</font>

783
00:36:42,680 --> 00:36:51,080
<font color="#E5E5E5">and so actually rebalancing for an array</font>

784
00:36:48,290 --> 00:36:53,330
decoded scheme operates much the same

785
00:36:51,080 --> 00:36:55,970
way as it would<font color="#CCCCCC"> for a replica</font><font color="#E5E5E5"> scheme so</font>

786
00:36:53,330 --> 00:36:57,650
the ring at that point the ring is it

787
00:36:55,970 --> 00:36:59,959
recalculates<font color="#CCCCCC"> and</font>

788
00:36:57,650 --> 00:37:02,869
new<font color="#E5E5E5"> data</font><font color="#CCCCCC"> structure</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> captures the</font>

789
00:36:59,960 --> 00:37:06,170
mapping from and what<font color="#CCCCCC"> we call partitions</font>

790
00:37:02,869 --> 00:37:09,859
which of virtual subspaces<font color="#E5E5E5"> of the hash</font>

791
00:37:06,170 --> 00:37:12,380
space in the consistent ring and the

792
00:37:09,859 --> 00:37:16,339
ring<font color="#E5E5E5"> has an algorithm</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> try to move as</font>

793
00:37:12,380 --> 00:37:19,579
few replicas as possible<font color="#E5E5E5"> and when it's</font>

794
00:37:16,339 --> 00:37:20,930
going<font color="#E5E5E5"> through rebalancing and still</font>

795
00:37:19,579 --> 00:37:23,029
maintain<font color="#E5E5E5"> the properties of dispersion</font>

796
00:37:20,930 --> 00:37:24,558
<font color="#E5E5E5">and balance throughout the entire</font>

797
00:37:23,029 --> 00:37:26,990
<font color="#CCCCCC">cluster and it's the same with an</font>

798
00:37:24,559 --> 00:37:29,329
erasure coding scheme<font color="#E5E5E5"> which is partly</font>

799
00:37:26,990 --> 00:37:31,430
<font color="#E5E5E5">why the ring is sort of ignorant of the</font>

800
00:37:29,329 --> 00:37:32,900
significance of<font color="#E5E5E5"> the individual rate</font>

801
00:37:31,430 --> 00:37:35,618
<font color="#E5E5E5">coding fragments it's just treating them</font>

802
00:37:32,900 --> 00:37:42,950
like replicas<font color="#CCCCCC"> okay</font>

803
00:37:35,619 --> 00:37:45,559
any more questions<font color="#E5E5E5"> yes yes and and I am</font>

804
00:37:42,950 --> 00:37:48,618
aware of sorry<font color="#E5E5E5"> repeat the question can</font>

805
00:37:45,559 --> 00:37:51,650
<font color="#CCCCCC">we do more</font><font color="#E5E5E5"> than two regions yes and</font><font color="#CCCCCC"> I'm</font>

806
00:37:48,619 --> 00:37:53,329
<font color="#E5E5E5">aware</font><font color="#CCCCCC"> of production clusters that are</font>

807
00:37:51,650 --> 00:37:55,730
operating over<font color="#E5E5E5"> more than two regions I</font>

808
00:37:53,329 --> 00:37:59,180
can think<font color="#E5E5E5"> one example immediately that</font>

809
00:37:55,730 --> 00:38:01,039
is a three region cluster and for their

810
00:37:59,180 --> 00:38:02,299
use case they've chosen to deploy three

811
00:38:01,039 --> 00:38:04,250
replicas so<font color="#CCCCCC"> they end up</font><font color="#E5E5E5"> with one</font>

812
00:38:02,299 --> 00:38:06,349
<font color="#CCCCCC">replicas</font><font color="#E5E5E5"> in each region because that</font>

813
00:38:04,250 --> 00:38:12,140
gives them the durability<font color="#E5E5E5"> they require</font>

814
00:38:06,349 --> 00:38:15,140
and with a<font color="#CCCCCC"> rage of coding I would say</font>

815
00:38:12,140 --> 00:38:16,460
cautiously at this point in time - it

816
00:38:15,140 --> 00:38:18,259
might be good<font color="#CCCCCC"> to experiment with two</font>

817
00:38:16,460 --> 00:38:21,559
regions<font color="#CCCCCC"> before jumping</font><font color="#E5E5E5"> in with four or</font>

818
00:38:18,260 --> 00:38:23,420
<font color="#CCCCCC">five regions</font><font color="#E5E5E5"> and depending on your</font>

819
00:38:21,559 --> 00:38:24,680
choice of<font color="#E5E5E5"> a rate coding scheme you can</font>

820
00:38:23,420 --> 00:38:26,599
end up with<font color="#CCCCCC"> a lot of fragments being</font>

821
00:38:24,680 --> 00:38:29,328
<font color="#E5E5E5">written a lot of connections been open</font>

822
00:38:26,599 --> 00:38:31,250
<font color="#E5E5E5">to back-end storage</font><font color="#CCCCCC"> notes and so it's</font>

823
00:38:29,329 --> 00:38:34,069
probably<font color="#E5E5E5"> good</font><font color="#CCCCCC"> to experiment with a two</font>

824
00:38:31,250 --> 00:38:40,900
region cluster first<font color="#E5E5E5"> and but yet multi</font>

825
00:38:34,069 --> 00:38:40,900
regions<font color="#E5E5E5"> is definitely possible yes</font>

826
00:38:52,109 --> 00:38:56,049
let me repeat<font color="#CCCCCC"> the question</font><font color="#E5E5E5"> to make</font><font color="#CCCCCC"> sure</font>

827
00:38:54,490 --> 00:38:58,000
I understood I<font color="#E5E5E5"> think the question was if</font>

828
00:38:56,050 --> 00:39:00,579
<font color="#E5E5E5">I if you would like to</font><font color="#CCCCCC"> use a razor</font>

829
00:38:58,000 --> 00:39:03,910
<font color="#CCCCCC">coating</font><font color="#E5E5E5"> can you can you move to a razor</font>

830
00:39:00,579 --> 00:39:08,170
coating without losing you without

831
00:39:03,910 --> 00:39:13,299
downtime<font color="#CCCCCC"> and the answer is yes and no</font>

832
00:39:08,170 --> 00:39:16,420
sorry<font color="#CCCCCC"> so um I have glossed over a topic</font>

833
00:39:13,300 --> 00:39:18,310
that<font color="#CCCCCC"> Iago</font><font color="#E5E5E5"> covered earlier which</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> that</font>

834
00:39:16,420 --> 00:39:21,040
<font color="#E5E5E5">actually within a swift cluster we can</font>

835
00:39:18,310 --> 00:39:23,859
<font color="#E5E5E5">have multiple storage policies operating</font>

836
00:39:21,040 --> 00:39:26,040
at the same<font color="#E5E5E5"> time so in a</font><font color="#CCCCCC"> single cluster</font>

837
00:39:23,859 --> 00:39:29,680
<font color="#E5E5E5">we could have a replication policy</font>

838
00:39:26,040 --> 00:39:31,599
<font color="#E5E5E5">running alongside a storage policy and</font>

839
00:39:29,680 --> 00:39:35,310
the client<font color="#CCCCCC"> can actually</font><font color="#E5E5E5"> choose which</font>

840
00:39:31,599 --> 00:39:38,500
those policies to store data is

841
00:39:35,310 --> 00:39:40,509
absolutely<font color="#CCCCCC"> possible to introduce an</font>

842
00:39:38,500 --> 00:39:43,630
erasure coding policy alongside<font color="#E5E5E5"> a</font>

843
00:39:40,510 --> 00:39:45,099
replication<font color="#CCCCCC"> policy what we</font><font color="#E5E5E5"> don't have at</font>

844
00:39:43,630 --> 00:39:47,710
<font color="#E5E5E5">this</font><font color="#CCCCCC"> moment time is a</font><font color="#E5E5E5"> mechanism to</font>

845
00:39:45,099 --> 00:39:49,380
automatically migrate<font color="#E5E5E5"> data that was</font>

846
00:39:47,710 --> 00:39:52,690
previously in the replication<font color="#CCCCCC"> policy</font>

847
00:39:49,380 --> 00:39:54,160
<font color="#E5E5E5">into an erasure coding policy there is</font>

848
00:39:52,690 --> 00:39:55,690
some work in progress<font color="#E5E5E5"> on that but we</font>

849
00:39:54,160 --> 00:39:58,089
don't<font color="#E5E5E5"> have that</font><font color="#CCCCCC"> at this point</font><font color="#E5E5E5"> in time</font>

850
00:39:55,690 --> 00:40:02,619
but absolutely you<font color="#E5E5E5"> can add erasure</font>

851
00:39:58,089 --> 00:40:03,670
coding<font color="#E5E5E5"> to an existing cluster okay I've</font>

852
00:40:02,619 --> 00:40:05,910
<font color="#E5E5E5">been told</font><font color="#CCCCCC"> time's up</font>

853
00:40:03,670 --> 00:40:05,910
sorry

854
00:40:05,940 --> 00:40:13,210
[Applause]

