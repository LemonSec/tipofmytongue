1
00:00:04,720 --> 00:00:10,610
yeah<font color="#E5E5E5"> thank you again so I the second</font>

2
00:00:08,540 --> 00:00:14,059
time<font color="#CCCCCC"> you in this room</font><font color="#E5E5E5"> so in the morning</font>

3
00:00:10,610 --> 00:00:16,250
I replaced a friend of mine<font color="#E5E5E5"> max with</font>

4
00:00:14,059 --> 00:00:18,830
<font color="#E5E5E5">this talk so who has been in this room</font><font color="#CCCCCC"> I</font>

5
00:00:16,250 --> 00:00:21,020
recognize a couple<font color="#E5E5E5"> of faces my slides</font>

6
00:00:18,830 --> 00:00:24,110
look a bit differently<font color="#E5E5E5"> so</font><font color="#CCCCCC"> you see I have</font>

7
00:00:21,020 --> 00:00:25,670
<font color="#CCCCCC">a different style</font><font color="#E5E5E5"> of sliding so um let's</font>

8
00:00:24,110 --> 00:00:28,880
talk<font color="#E5E5E5"> a bit about handling</font><font color="#CCCCCC"> millions</font><font color="#E5E5E5"> of</font>

9
00:00:25,670 --> 00:00:30,970
edges<font color="#E5E5E5"> so about</font><font color="#CCCCCC"> myself</font><font color="#E5E5E5"> my name is Michael</font>

10
00:00:28,880 --> 00:00:35,870
can anyone hear me in the<font color="#E5E5E5"> back</font>

11
00:00:30,970 --> 00:00:39,950
good<font color="#E5E5E5"> so I'm working on</font><font color="#CCCCCC"> a Rango DB which</font>

12
00:00:35,870 --> 00:00:42,078
<font color="#CCCCCC">is the</font><font color="#E5E5E5"> database company I'm personally</font>

13
00:00:39,950 --> 00:00:44,329
<font color="#CCCCCC">leading the</font><font color="#E5E5E5"> graph development team there</font>

14
00:00:42,079 --> 00:00:47,360
so<font color="#E5E5E5"> everything that is graph related goes</font>

15
00:00:44,329 --> 00:00:48,800
over<font color="#E5E5E5"> my desk</font><font color="#CCCCCC"> started</font><font color="#E5E5E5"> off as a graph is</font>

16
00:00:47,360 --> 00:00:51,470
realization which I handed over to a

17
00:00:48,800 --> 00:00:53,629
colleague<font color="#CCCCCC"> but</font><font color="#E5E5E5"> all the graph features and</font>

18
00:00:51,470 --> 00:00:58,790
especially graph smart graphs are

19
00:00:53,630 --> 00:01:00,590
designed by me so the introductory talks

20
00:00:58,790 --> 00:01:03,019
so who has been in the last<font color="#E5E5E5"> talk I guess</font>

21
00:01:00,590 --> 00:01:05,570
this is<font color="#E5E5E5"> not new</font><font color="#CCCCCC"> for you what a graph</font>

22
00:01:03,020 --> 00:01:08,500
databases<font color="#E5E5E5"> so first of all graph</font>

23
00:01:05,570 --> 00:01:13,339
databases store schema free objects

24
00:01:08,500 --> 00:01:15,020
which<font color="#CCCCCC"> they call vertices</font><font color="#E5E5E5"> so it means</font>

25
00:01:13,340 --> 00:01:18,020
that<font color="#CCCCCC"> you can have arbitrary attributes</font>

26
00:01:15,020 --> 00:01:20,060
<font color="#E5E5E5">on your vertices and not every vertex</font>

27
00:01:18,020 --> 00:01:22,460
needs to have the same<font color="#CCCCCC"> attributes</font><font color="#E5E5E5"> so you</font>

28
00:01:20,060 --> 00:01:24,470
can switch back and<font color="#E5E5E5"> forth</font><font color="#CCCCCC"> switching the</font>

29
00:01:22,460 --> 00:01:28,009
logic of which attribute is<font color="#CCCCCC"> there</font>

30
00:01:24,470 --> 00:01:31,130
<font color="#E5E5E5">actually back to</font><font color="#CCCCCC"> the client</font><font color="#E5E5E5"> then they</font>

31
00:01:28,010 --> 00:01:34,939
store relations between them which they

32
00:01:31,130 --> 00:01:37,280
call edges so here one<font color="#E5E5E5"> vertex is for</font>

33
00:01:34,939 --> 00:01:40,460
example<font color="#CCCCCC"> Ellis which has the name and</font><font color="#E5E5E5"> an</font>

34
00:01:37,280 --> 00:01:42,710
<font color="#CCCCCC">age and alex has a hobby</font><font color="#E5E5E5"> which has the</font>

35
00:01:40,460 --> 00:01:45,740
name dancing and<font color="#E5E5E5"> hobby would then be</font><font color="#CCCCCC"> the</font>

36
00:01:42,710 --> 00:01:50,630
edge so connecting the<font color="#E5E5E5"> vertices</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> the</font>

37
00:01:45,740 --> 00:01:54,470
edges to one data row basically<font color="#E5E5E5"> edges</font>

38
00:01:50,630 --> 00:01:58,039
typically have a direction<font color="#CCCCCC"> so Ellis is</font>

39
00:01:54,470 --> 00:02:03,680
<font color="#E5E5E5">the starting point and this hobby is the</font>

40
00:01:58,040 --> 00:02:06,259
target all<font color="#E5E5E5"> of the above could be done in</font>

41
00:02:03,680 --> 00:02:09,979
a relational database<font color="#CCCCCC"> plainly</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> have</font>

42
00:02:06,259 --> 00:02:12,340
two tables<font color="#CCCCCC"> for</font><font color="#E5E5E5"> vertices for example and</font>

43
00:02:09,979 --> 00:02:16,190
a drawing<font color="#E5E5E5"> table</font><font color="#CCCCCC"> with two foreign keys</font>

44
00:02:12,340 --> 00:02:17,630
would work<font color="#E5E5E5"> the difference come in in the</font>

45
00:02:16,190 --> 00:02:21,120
query<font color="#CCCCCC"> language</font>

46
00:02:17,630 --> 00:02:23,040
so for graph database typically edges

47
00:02:21,120 --> 00:02:25,200
can be<font color="#E5E5E5"> queried in both directions</font><font color="#CCCCCC"> so I</font>

48
00:02:23,040 --> 00:02:27,810
can say please follow the direction<font color="#E5E5E5"> or</font>

49
00:02:25,200 --> 00:02:29,399
go against the direction<font color="#E5E5E5"> or I don't care</font>

50
00:02:27,810 --> 00:02:33,690
<font color="#CCCCCC">for the</font><font color="#E5E5E5"> direction if there is an edge</font>

51
00:02:29,400 --> 00:02:35,940
follow it<font color="#E5E5E5"> place that works and now the</font>

52
00:02:33,690 --> 00:02:39,720
difference<font color="#E5E5E5"> to</font><font color="#CCCCCC"> sequel comes you can</font>

53
00:02:35,940 --> 00:02:42,510
easily query<font color="#CCCCCC"> a range of edges so let's</font>

54
00:02:39,720 --> 00:02:44,220
say I have a starting<font color="#CCCCCC"> point Ellis and I</font>

55
00:02:42,510 --> 00:02:46,470
want to select everything<font color="#E5E5E5"> that is two</font>

56
00:02:44,220 --> 00:02:49,980
steps<font color="#CCCCCC"> away so I</font><font color="#E5E5E5"> can go over one</font><font color="#CCCCCC"> hug</font><font color="#E5E5E5"> and</font>

57
00:02:46,470 --> 00:02:53,190
go back to<font color="#E5E5E5"> another person Bob not using</font>

58
00:02:49,980 --> 00:02:55,799
the direct relation here and that is

59
00:02:53,190 --> 00:02:58,109
<font color="#E5E5E5">really a one-liner even if I do five</font>

60
00:02:55,800 --> 00:03:00,930
steps or<font color="#E5E5E5"> 200 steps that is a one-line</font>

61
00:02:58,110 --> 00:03:01,980
and a graph<font color="#CCCCCC"> database if you do 200</font><font color="#E5E5E5"> steps</font>

62
00:03:00,930 --> 00:03:04,710
in a relational database

63
00:03:01,980 --> 00:03:08,130
I think the<font color="#CCCCCC"> berry is like growing</font>

64
00:03:04,710 --> 00:03:10,010
growing growing 200 joints and so you

65
00:03:08,130 --> 00:03:12,030
<font color="#E5E5E5">don't want to write that most likely</font>

66
00:03:10,010 --> 00:03:13,620
unless<font color="#E5E5E5"> you have something</font><font color="#CCCCCC"> which allows</font>

67
00:03:12,030 --> 00:03:18,000
<font color="#CCCCCC">for a recursive pattern like</font><font color="#E5E5E5"> Postgres</font>

68
00:03:13,620 --> 00:03:19,830
<font color="#E5E5E5">does even more</font><font color="#CCCCCC"> in most</font><font color="#E5E5E5"> graph databases</font>

69
00:03:18,000 --> 00:03:21,840
you can<font color="#E5E5E5"> actually say I</font><font color="#CCCCCC"> don't know how</font>

70
00:03:19,830 --> 00:03:24,870
<font color="#CCCCCC">many edges</font><font color="#E5E5E5"> I need I have a starting</font>

71
00:03:21,840 --> 00:03:26,580
<font color="#CCCCCC">point and such as long until you find</font>

72
00:03:24,870 --> 00:03:28,470
really<font color="#E5E5E5"> the results that I'm</font><font color="#CCCCCC"> looking</font><font color="#E5E5E5"> for</font>

73
00:03:26,580 --> 00:03:31,860
no matter<font color="#E5E5E5"> how many</font><font color="#CCCCCC"> edges you have</font><font color="#E5E5E5"> to</font>

74
00:03:28,470 --> 00:03:35,430
follow that way or a shortest<font color="#E5E5E5"> path</font>

75
00:03:31,860 --> 00:03:37,050
<font color="#E5E5E5">between two vertices so say we start</font>

76
00:03:35,430 --> 00:03:39,180
here at<font color="#E5E5E5"> then saying what is the shortest</font>

77
00:03:37,050 --> 00:03:40,740
connection from<font color="#CCCCCC"> Dancing</font><font color="#E5E5E5"> to fishing and</font>

78
00:03:39,180 --> 00:03:43,110
the graph database will figure<font color="#E5E5E5"> out</font><font color="#CCCCCC"> I</font>

79
00:03:40,740 --> 00:03:45,030
started dancing go to Ellis shortest way

80
00:03:43,110 --> 00:03:51,030
would<font color="#CCCCCC"> be going</font><font color="#E5E5E5"> to Bob</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> then go back</font>

81
00:03:45,030 --> 00:03:54,240
<font color="#CCCCCC">to fishing what our typical graph</font>

82
00:03:51,030 --> 00:03:58,200
queries give me all the friends of<font color="#E5E5E5"> Ellis</font>

83
00:03:54,240 --> 00:04:01,890
which is like a<font color="#CCCCCC"> one-step search</font><font color="#E5E5E5"> so I'm</font>

84
00:03:58,200 --> 00:04:03,839
starting at Ellis<font color="#E5E5E5"> and I'm going one edge</font>

85
00:04:01,890 --> 00:04:08,250
the friend relation to all the<font color="#CCCCCC"> friends</font>

86
00:04:03,840 --> 00:04:09,570
of it off Ellis giving me this result or

87
00:04:08,250 --> 00:04:12,959
give me all the friends of<font color="#E5E5E5"> friends of</font>

88
00:04:09,570 --> 00:04:16,200
Ellis friend friends<font color="#CCCCCC"> of friends means</font><font color="#E5E5E5"> we</font>

89
00:04:12,959 --> 00:04:19,140
go<font color="#E5E5E5"> to edges but everything we found in</font>

90
00:04:16,200 --> 00:04:23,310
<font color="#E5E5E5">the first layer</font><font color="#CCCCCC"> so with one edge should</font>

91
00:04:19,140 --> 00:04:26,719
not be in the result so example Ellis<font color="#CCCCCC"> I</font>

92
00:04:23,310 --> 00:04:30,180
go one step<font color="#E5E5E5"> to Bob I go two steps to Eve</font>

93
00:04:26,720 --> 00:04:31,320
Eve could be in the result<font color="#CCCCCC"> LS I go one</font>

94
00:04:30,180 --> 00:04:34,290
<font color="#E5E5E5">step to Bob and one</font>

95
00:04:31,320 --> 00:04:35,790
<font color="#E5E5E5">step2</font><font color="#CCCCCC"> Charlie but</font><font color="#E5E5E5"> Ellis has a direct</font>

96
00:04:34,290 --> 00:04:38,850
connection<font color="#CCCCCC"> to Charlie so Charlie should</font>

97
00:04:35,790 --> 00:04:40,800
not be in the result<font color="#E5E5E5"> in the</font><font color="#CCCCCC"> RAF database</font>

98
00:04:38,850 --> 00:04:44,730
can actually find those things pretty

99
00:04:40,800 --> 00:04:46,590
easily or given any two random vertices

100
00:04:44,730 --> 00:04:51,570
<font color="#E5E5E5">what is the shortest connection between</font>

101
00:04:46,590 --> 00:04:54,179
them<font color="#CCCCCC"> and this</font><font color="#E5E5E5"> is not always a</font>

102
00:04:51,570 --> 00:04:56,190
deterministic result<font color="#CCCCCC"> cause in this</font><font color="#E5E5E5"> case</font>

103
00:04:54,180 --> 00:04:59,970
<font color="#E5E5E5">if I just started</font><font color="#CCCCCC"> edison I want to go to</font>

104
00:04:56,190 --> 00:05:02,940
Eve<font color="#CCCCCC"> I can either</font><font color="#E5E5E5"> go</font><font color="#CCCCCC"> via Bob</font><font color="#E5E5E5"> or I can go</font>

105
00:04:59,970 --> 00:05:04,980
via<font color="#CCCCCC"> charlie</font><font color="#E5E5E5"> both using two edges both</font>

106
00:05:02,940 --> 00:05:10,490
could<font color="#CCCCCC"> be a potential result for this</font>

107
00:05:04,980 --> 00:05:13,050
<font color="#E5E5E5">community</font><font color="#CCCCCC"> and now</font><font color="#E5E5E5"> comes the weird part</font>

108
00:05:10,490 --> 00:05:15,630
<font color="#E5E5E5">if I'm standing</font><font color="#CCCCCC"> at the</font><font color="#E5E5E5"> train station</font><font color="#CCCCCC"> and</font>

109
00:05:13,050 --> 00:05:18,120
I buy a<font color="#E5E5E5"> ticket and it says you can go up</font>

110
00:05:15,630 --> 00:05:21,960
<font color="#E5E5E5">to six stops you can change lines as</font>

111
00:05:18,120 --> 00:05:24,090
often as you like where can<font color="#E5E5E5"> I go so I'm</font>

112
00:05:21,960 --> 00:05:26,880
<font color="#E5E5E5">starting at this point</font><font color="#CCCCCC"> and I'm allowed</font>

113
00:05:24,090 --> 00:05:29,580
<font color="#CCCCCC">to go six</font><font color="#E5E5E5"> edges long so the graph</font>

114
00:05:26,880 --> 00:05:31,380
database actually<font color="#E5E5E5"> can do this in a</font>

115
00:05:29,580 --> 00:05:33,030
one-liner and can find all the stations

116
00:05:31,380 --> 00:05:38,460
where<font color="#CCCCCC"> I could go even with switching</font>

117
00:05:33,030 --> 00:05:41,070
lines but the most<font color="#E5E5E5"> typical one</font><font color="#CCCCCC"> is the</font>

118
00:05:38,460 --> 00:05:43,770
<font color="#E5E5E5">so-called pattern matching pattern</font>

119
00:05:41,070 --> 00:05:46,560
matching is you have<font color="#E5E5E5"> like a huge data</font>

120
00:05:43,770 --> 00:05:50,280
set which is your graph and you define a

121
00:05:46,560 --> 00:05:52,200
sub graph your pattern<font color="#E5E5E5"> say give me all</font>

122
00:05:50,280 --> 00:05:54,630
<font color="#E5E5E5">the</font><font color="#CCCCCC"> two all the</font><font color="#E5E5E5"> users that share two</font>

123
00:05:52,200 --> 00:05:57,060
hobbies<font color="#E5E5E5"> with Ellis pattern would be we</font>

124
00:05:54,630 --> 00:05:59,730
<font color="#E5E5E5">have Ellis we have a relation to one</font>

125
00:05:57,060 --> 00:06:02,300
hobby Ellis needs another relation to

126
00:05:59,730 --> 00:06:04,920
<font color="#E5E5E5">another hobby</font><font color="#CCCCCC"> which is not the</font><font color="#E5E5E5"> same and</font>

127
00:06:02,300 --> 00:06:07,560
then<font color="#CCCCCC"> we need another</font><font color="#E5E5E5"> vertex which is</font><font color="#CCCCCC"> a</font>

128
00:06:04,920 --> 00:06:10,050
friend having<font color="#CCCCCC"> a relation to</font><font color="#E5E5E5"> both of</font>

129
00:06:07,560 --> 00:06:12,690
these<font color="#E5E5E5"> hobbies that would be the pattern</font>

130
00:06:10,050 --> 00:06:15,990
<font color="#E5E5E5">and the database should then find all</font>

131
00:06:12,690 --> 00:06:18,560
the friends<font color="#E5E5E5"> of Ellis that have two</font>

132
00:06:15,990 --> 00:06:18,560
hobbies income

133
00:06:18,889 --> 00:06:26,120
<font color="#CCCCCC">oh and now we make</font><font color="#E5E5E5"> it a bit more</font>

134
00:06:22,969 --> 00:06:28,069
<font color="#CCCCCC">complicated give me all</font><font color="#E5E5E5"> the products</font>

135
00:06:26,120 --> 00:06:30,439
<font color="#E5E5E5">that</font><font color="#CCCCCC"> at least one</font><font color="#E5E5E5"> of my friends has</font>

136
00:06:28,069 --> 00:06:37,009
bought together with the products<font color="#E5E5E5"> that I</font>

137
00:06:30,439 --> 00:06:39,800
already<font color="#E5E5E5"> own</font><font color="#CCCCCC"> but only 20 of them</font><font color="#E5E5E5"> or limit</font>

138
00:06:37,009 --> 00:06:41,120
them by price or<font color="#CCCCCC"> whatever and you see</font>

139
00:06:39,800 --> 00:06:43,029
what<font color="#CCCCCC"> there</font><font color="#E5E5E5"> where is this</font><font color="#CCCCCC"> going</font><font color="#E5E5E5"> this is a</font>

140
00:06:41,120 --> 00:06:46,569
super simple<font color="#CCCCCC"> recommendation engine</font>

141
00:06:43,029 --> 00:06:48,469
because probably what my friends buy in

142
00:06:46,569 --> 00:06:50,060
<font color="#E5E5E5">together with the stuff</font><font color="#CCCCCC"> that I already</font>

143
00:06:48,469 --> 00:06:53,060
have is<font color="#E5E5E5"> probably interesting for me as</font>

144
00:06:50,060 --> 00:06:54,400
well<font color="#E5E5E5"> it's not the best one but getting</font>

145
00:06:53,060 --> 00:06:57,069
close

146
00:06:54,400 --> 00:06:59,659
what are non<font color="#CCCCCC"> typical graph Curie's and</font>

147
00:06:57,069 --> 00:07:02,270
those are<font color="#E5E5E5"> queries the graph</font><font color="#CCCCCC"> databases</font>

148
00:06:59,659 --> 00:07:03,949
typically don't perform well<font color="#E5E5E5"> because</font>

149
00:07:02,270 --> 00:07:05,870
they're<font color="#E5E5E5"> not optimized for them so graph</font>

150
00:07:03,949 --> 00:07:08,870
databases are really<font color="#E5E5E5"> optimized for those</font>

151
00:07:05,870 --> 00:07:10,849
queries that go<font color="#E5E5E5"> alongside the edges like</font>

152
00:07:08,870 --> 00:07:13,969
<font color="#E5E5E5">these friends</font><font color="#CCCCCC"> imagining or pattern</font>

153
00:07:10,849 --> 00:07:16,159
matching<font color="#E5E5E5"> and</font><font color="#CCCCCC"> so on graph databases</font>

154
00:07:13,969 --> 00:07:19,279
<font color="#CCCCCC">typically don't perform</font><font color="#E5E5E5"> so well if you</font>

155
00:07:16,159 --> 00:07:21,620
are only<font color="#CCCCCC"> clearing</font><font color="#E5E5E5"> across attributes so</font>

156
00:07:19,279 --> 00:07:23,960
not cross the relations<font color="#E5E5E5"> but for the</font>

157
00:07:21,620 --> 00:07:26,449
attributes so give me<font color="#E5E5E5"> all the users</font>

158
00:07:23,960 --> 00:07:29,568
which have an<font color="#CCCCCC"> age attribute between 21</font>

159
00:07:26,449 --> 00:07:31,430
and 33<font color="#CCCCCC"> document</font><font color="#E5E5E5"> store or relational</font>

160
00:07:29,569 --> 00:07:37,580
database would be much more suitable<font color="#E5E5E5"> for</font>

161
00:07:31,430 --> 00:07:39,939
<font color="#E5E5E5">this</font><font color="#CCCCCC"> type of query</font><font color="#E5E5E5"> only give me the HDH</font>

162
00:07:37,580 --> 00:07:42,529
distribution of all my<font color="#E5E5E5"> users that</font><font color="#CCCCCC"> I have</font>

163
00:07:39,939 --> 00:07:43,550
basically the same<font color="#CCCCCC"> or group all my users</font>

164
00:07:42,529 --> 00:07:53,979
<font color="#CCCCCC">by their name</font>

165
00:07:43,550 --> 00:07:57,439
I don't<font color="#CCCCCC"> yes</font><font color="#E5E5E5"> typically those are just the</font>

166
00:07:53,979 --> 00:07:59,360
<font color="#E5E5E5">theory</font><font color="#CCCCCC"> switch where</font><font color="#E5E5E5"> the graph database</font>

167
00:07:57,439 --> 00:08:01,339
are like not specifically optimized for

168
00:07:59,360 --> 00:08:03,500
so relational databases are more

169
00:08:01,339 --> 00:08:05,810
optimized for those queries<font color="#E5E5E5"> graph</font>

170
00:08:03,500 --> 00:08:07,789
databases<font color="#CCCCCC"> should focus more</font><font color="#E5E5E5"> on</font><font color="#CCCCCC"> D on the</font>

171
00:08:05,810 --> 00:08:09,830
traversal stuff I'm not<font color="#CCCCCC"> saying that it's</font>

172
00:08:07,789 --> 00:08:11,180
not<font color="#E5E5E5"> possible</font><font color="#CCCCCC"> it's</font><font color="#E5E5E5"> just the other ones</font>

173
00:08:09,830 --> 00:08:12,099
<font color="#E5E5E5">like put their focus more in that</font>

174
00:08:11,180 --> 00:08:17,120
<font color="#CCCCCC">direction</font>

175
00:08:12,099 --> 00:08:19,310
at<font color="#E5E5E5"> least from my</font><font color="#CCCCCC"> my experience because</font>

176
00:08:17,120 --> 00:08:21,860
<font color="#E5E5E5">the major thing</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> a graph</font><font color="#CCCCCC"> database</font>

177
00:08:19,310 --> 00:08:24,379
does is the<font color="#CCCCCC"> so called</font><font color="#E5E5E5"> traversal and how</font>

178
00:08:21,860 --> 00:08:29,659
that works<font color="#CCCCCC"> I'll actually like to explain</font>

179
00:08:24,379 --> 00:08:31,350
<font color="#E5E5E5">by example so first of all we pick a</font>

180
00:08:29,659 --> 00:08:34,710
starting<font color="#E5E5E5"> vertex</font>

181
00:08:31,350 --> 00:08:37,950
which we<font color="#E5E5E5"> find in a fast in a way that is</font>

182
00:08:34,710 --> 00:08:40,289
as fast<font color="#E5E5E5"> as possible then we have to</font>

183
00:08:37,950 --> 00:08:44,640
collect<font color="#E5E5E5"> all the</font><font color="#CCCCCC"> edges for this starting</font>

184
00:08:40,289 --> 00:08:47,069
vertex<font color="#E5E5E5"> and collect all the neighbors</font>

185
00:08:44,640 --> 00:08:48,660
<font color="#E5E5E5">that</font><font color="#CCCCCC"> are connected with</font><font color="#E5E5E5"> these edges then</font>

186
00:08:47,070 --> 00:08:51,600
we can apply<font color="#CCCCCC"> filters on the edges and</font>

187
00:08:48,660 --> 00:08:55,410
the vertices<font color="#E5E5E5"> and we end up with the</font>

188
00:08:51,600 --> 00:08:58,140
first<font color="#E5E5E5"> subset here so now a</font><font color="#CCCCCC"> traversal</font>

189
00:08:55,410 --> 00:09:01,199
started at s and it will go on<font color="#E5E5E5"> to either</font>

190
00:08:58,140 --> 00:09:04,350
A or B because we said<font color="#E5E5E5"> please go to</font>

191
00:09:01,200 --> 00:09:07,350
edges so it randomly picks let's say<font color="#E5E5E5"> a</font>

192
00:09:04,350 --> 00:09:11,730
then it does the<font color="#E5E5E5"> same step again checks</font>

193
00:09:07,350 --> 00:09:15,000
for<font color="#CCCCCC"> all the edges that</font><font color="#E5E5E5"> are connected to</font>

194
00:09:11,730 --> 00:09:17,190
a applies the filtering again and<font color="#CCCCCC"> we'll</font>

195
00:09:15,000 --> 00:09:19,860
figure<font color="#E5E5E5"> out oh D is probably connected</font>

196
00:09:17,190 --> 00:09:22,650
<font color="#E5E5E5">but</font><font color="#CCCCCC"> we filter it out then e is also</font>

197
00:09:19,860 --> 00:09:25,500
<font color="#E5E5E5">probably connected and then we have the</font>

198
00:09:22,650 --> 00:09:28,020
<font color="#E5E5E5">first result</font><font color="#CCCCCC"> s - A</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> E</font><font color="#E5E5E5"> it has two edges</font>

199
00:09:25,500 --> 00:09:31,650
<font color="#CCCCCC">and the filters matched and this would</font>

200
00:09:28,020 --> 00:09:33,660
be one part<font color="#E5E5E5"> of the result then the</font>

201
00:09:31,650 --> 00:09:35,069
<font color="#CCCCCC">traverse'</font><font color="#E5E5E5"> could continue here but we</font>

202
00:09:33,660 --> 00:09:39,240
said it<font color="#CCCCCC"> should stop at two edges so it</font>

203
00:09:35,070 --> 00:09:42,060
doesn't instead it goes<font color="#E5E5E5"> back to a tries</font>

204
00:09:39,240 --> 00:09:44,660
or checks if it<font color="#E5E5E5"> is another edge that it</font>

205
00:09:42,060 --> 00:09:47,849
has to process<font color="#CCCCCC"> in this case not because</font>

206
00:09:44,660 --> 00:09:51,270
<font color="#CCCCCC">we remove</font><font color="#E5E5E5"> D from the</font><font color="#CCCCCC"> results that an</font><font color="#E5E5E5"> is</font>

207
00:09:47,850 --> 00:09:53,960
visited so we go back<font color="#E5E5E5"> to s and check if</font>

208
00:09:51,270 --> 00:09:57,930
there<font color="#CCCCCC"> is another edge</font><font color="#E5E5E5"> and here we</font><font color="#CCCCCC"> find B</font>

209
00:09:53,960 --> 00:10:00,240
so we go<font color="#E5E5E5"> to the unfinished vertex B</font>

210
00:09:57,930 --> 00:10:02,310
which we<font color="#CCCCCC"> haven't visited yet and apply</font>

211
00:10:00,240 --> 00:10:05,100
the same pattern again<font color="#E5E5E5"> so we iterate</font>

212
00:10:02,310 --> 00:10:07,829
down to be apply filters on all the

213
00:10:05,100 --> 00:10:10,980
<font color="#CCCCCC">edges and go down to</font><font color="#E5E5E5"> everything we find</font>

214
00:10:07,830 --> 00:10:14,750
<font color="#E5E5E5">so in this case</font><font color="#CCCCCC"> s be F would be</font><font color="#E5E5E5"> another</font>

215
00:10:10,980 --> 00:10:14,750
result of this traversal theory

216
00:10:16,800 --> 00:10:24,189
let's talk a bit<font color="#CCCCCC"> about the complexity of</font>

217
00:10:19,570 --> 00:10:28,150
such a traversal algorithm first we have

218
00:10:24,190 --> 00:10:32,170
to find<font color="#E5E5E5"> the starting vertex how fast we</font>

219
00:10:28,150 --> 00:10:34,150
<font color="#E5E5E5">can do that depends on the index in best</font>

220
00:10:32,170 --> 00:10:37,630
<font color="#E5E5E5">case it is a hash index then it's</font>

221
00:10:34,150 --> 00:10:39,130
constant<font color="#CCCCCC"> time to find it if you only</font>

222
00:10:37,630 --> 00:10:41,230
have<font color="#E5E5E5"> a sorted index then it's</font>

223
00:10:39,130 --> 00:10:43,750
<font color="#E5E5E5">logarithmic time to find it if you</font><font color="#CCCCCC"> don't</font>

224
00:10:41,230 --> 00:10:45,910
<font color="#E5E5E5">have an index at all your database will</font>

225
00:10:43,750 --> 00:10:51,190
be rather slow<font color="#E5E5E5"> because it takes like</font><font color="#CCCCCC"> the</font>

226
00:10:45,910 --> 00:10:53,860
amount<font color="#CCCCCC"> of vertices you have so put an</font>

227
00:10:51,190 --> 00:10:56,830
index<font color="#E5E5E5"> on it and you can find it fast but</font>

228
00:10:53,860 --> 00:10:59,590
now comes the<font color="#E5E5E5"> important</font><font color="#CCCCCC"> part so for</font>

229
00:10:56,830 --> 00:11:02,490
every<font color="#CCCCCC"> depth</font><font color="#E5E5E5"> that we have that we want to</font>

230
00:10:59,590 --> 00:11:05,860
search we apply the following<font color="#E5E5E5"> four steps</font>

231
00:11:02,490 --> 00:11:08,980
first of all we find all the connected

232
00:11:05,860 --> 00:11:11,470
edges and this<font color="#E5E5E5"> is either done by</font><font color="#CCCCCC"> an edge</font>

233
00:11:08,980 --> 00:11:15,040
<font color="#E5E5E5">index or with so called index free</font>

234
00:11:11,470 --> 00:11:17,680
adjacency both of them are<font color="#E5E5E5"> basically</font>

235
00:11:15,040 --> 00:11:20,260
required<font color="#CCCCCC"> to be in</font><font color="#E5E5E5"> constant time because</font>

236
00:11:17,680 --> 00:11:22,719
<font color="#CCCCCC">this</font><font color="#E5E5E5"> is most likely the operation the</font>

237
00:11:20,260 --> 00:11:29,170
database will do most<font color="#E5E5E5"> of the time so</font>

238
00:11:22,720 --> 00:11:32,860
<font color="#E5E5E5">that should be as fast as possible then</font>

239
00:11:29,170 --> 00:11:35,349
we have a set<font color="#CCCCCC"> of edges now we have to</font>

240
00:11:32,860 --> 00:11:37,660
walk<font color="#E5E5E5"> through this set of</font><font color="#CCCCCC"> edges</font><font color="#E5E5E5"> and for</font>

241
00:11:35,350 --> 00:11:40,720
each check if the filter conditions that

242
00:11:37,660 --> 00:11:42,100
we apply match for this edge if the

243
00:11:40,720 --> 00:11:46,300
filter conditions match for the

244
00:11:42,100 --> 00:11:49,480
connected vertex and of course we have

245
00:11:46,300 --> 00:11:52,870
to find<font color="#CCCCCC"> the connected vertex</font><font color="#E5E5E5"> all of that</font>

246
00:11:49,480 --> 00:11:56,920
can be<font color="#E5E5E5"> done in</font><font color="#CCCCCC"> one go</font><font color="#E5E5E5"> so 3 times n is</font>

247
00:11:52,870 --> 00:12:02,020
required<font color="#E5E5E5"> only</font><font color="#CCCCCC"> for these things</font><font color="#E5E5E5"> linear</font>

248
00:11:56,920 --> 00:12:05,110
<font color="#E5E5E5">complexity but as we do this for every</font>

249
00:12:02,020 --> 00:12:09,819
<font color="#E5E5E5">depth that means</font><font color="#CCCCCC"> we start with one</font>

250
00:12:05,110 --> 00:12:11,980
<font color="#E5E5E5">vertex so</font><font color="#CCCCCC"> 1 times 3</font><font color="#E5E5E5"> times n but in the</font>

251
00:12:09,820 --> 00:12:15,580
<font color="#E5E5E5">next step we actually start with</font><font color="#CCCCCC"> three</font>

252
00:12:11,980 --> 00:12:18,640
times<font color="#E5E5E5"> and starting vertices so that</font>

253
00:12:15,580 --> 00:12:20,980
means 3<font color="#CCCCCC"> times n to the power of</font><font color="#E5E5E5"> the</font>

254
00:12:18,640 --> 00:12:23,910
search depth<font color="#E5E5E5"> that's the complexity</font><font color="#CCCCCC"> of</font>

255
00:12:20,980 --> 00:12:23,910
traversal algorithm

256
00:12:25,120 --> 00:12:32,230
however sounds evil<font color="#E5E5E5"> but it's not linear</font>

257
00:12:29,769 --> 00:12:33,279
<font color="#CCCCCC">and the total amount of edges</font><font color="#E5E5E5"> and that's</font>

258
00:12:32,230 --> 00:12:35,980
the great benefit

259
00:12:33,279 --> 00:12:39,120
it's just<font color="#E5E5E5"> linear in the amount of edges</font>

260
00:12:35,980 --> 00:12:41,829
<font color="#E5E5E5">attached to each vertex so if you have</font>

261
00:12:39,120 --> 00:12:44,800
trillions<font color="#E5E5E5"> of edges in your data storage</font>

262
00:12:41,829 --> 00:12:47,589
thought but every vertex<font color="#CCCCCC"> just has five</font>

263
00:12:44,800 --> 00:12:50,319
of<font color="#CCCCCC"> them all your traverses will still be</font>

264
00:12:47,589 --> 00:12:53,559
fast<font color="#E5E5E5"> unless you search for a depth</font><font color="#CCCCCC"> 5,000</font>

265
00:12:50,319 --> 00:12:57,279
<font color="#E5E5E5">or so because you only scale with all</font>

266
00:12:53,559 --> 00:12:58,779
the edges connected to one vertex there

267
00:12:57,279 --> 00:13:03,430
<font color="#E5E5E5">is a certain drawback that</font><font color="#CCCCCC"> I will come</font>

268
00:12:58,779 --> 00:13:05,410
to in a minute<font color="#E5E5E5"> and typically the number</font>

269
00:13:03,430 --> 00:13:07,089
<font color="#E5E5E5">of edges connected to one vertex is much</font>

270
00:13:05,410 --> 00:13:11,019
smaller than the<font color="#E5E5E5"> total amount</font><font color="#CCCCCC"> of edges</font>

271
00:13:07,089 --> 00:13:13,059
<font color="#E5E5E5">that you store so the benefit of</font>

272
00:13:11,019 --> 00:13:15,720
<font color="#CCCCCC">traversals is say only scale with the</font>

273
00:13:13,059 --> 00:13:18,370
result size so if you increase

274
00:13:15,720 --> 00:13:20,230
everything you store in the database<font color="#CCCCCC"> but</font>

275
00:13:18,370 --> 00:13:23,790
<font color="#E5E5E5">the result size stays constant for one</font>

276
00:13:20,230 --> 00:13:23,790
search will have the same performance

277
00:13:24,990 --> 00:13:32,350
and there is a rule that<font color="#CCCCCC"> I learned at</font>

278
00:13:29,769 --> 00:13:35,259
<font color="#CCCCCC">university which holds true for</font><font color="#E5E5E5"> all</font>

279
00:13:32,350 --> 00:13:38,410
<font color="#E5E5E5">social networks so everything</font><font color="#CCCCCC"> that is</font>

280
00:13:35,259 --> 00:13:38,829
grown<font color="#CCCCCC"> naturally and that's the call</font><font color="#E5E5E5"> so</font>

281
00:13:38,410 --> 00:13:42,249
<font color="#E5E5E5">called</font>

282
00:13:38,829 --> 00:13:44,050
<font color="#CCCCCC">seven degrees</font><font color="#E5E5E5"> of separation seven</font>

283
00:13:42,249 --> 00:13:46,870
degrees of<font color="#CCCCCC"> separation means</font><font color="#E5E5E5"> take any</font>

284
00:13:44,050 --> 00:13:51,870
social network so Twitter Facebook

285
00:13:46,870 --> 00:13:54,790
whatever<font color="#E5E5E5"> take any two random persons and</font>

286
00:13:51,870 --> 00:13:56,920
you have<font color="#E5E5E5"> a extremely</font><font color="#CCCCCC"> high chance that</font>

287
00:13:54,790 --> 00:14:01,929
the shortest path<font color="#E5E5E5"> between those any two</font>

288
00:13:56,920 --> 00:14:03,670
persons<font color="#CCCCCC"> is of length seven or</font><font color="#E5E5E5"> less so</font>

289
00:14:01,929 --> 00:14:07,660
that<font color="#E5E5E5"> means if you have like an</font>

290
00:14:03,670 --> 00:14:09,939
unfiltered traversal<font color="#E5E5E5"> of depth</font><font color="#CCCCCC"> seven that</font>

291
00:14:07,660 --> 00:14:12,429
<font color="#E5E5E5">means that you are most likely returning</font>

292
00:14:09,939 --> 00:14:15,099
like<font color="#E5E5E5"> 99</font><font color="#CCCCCC"> percent of</font><font color="#E5E5E5"> your graph database</font>

293
00:14:12,429 --> 00:14:17,290
as long as they have a naturally grown

294
00:14:15,100 --> 00:14:19,899
graph<font color="#E5E5E5"> if you have an artificially grown</font>

295
00:14:17,290 --> 00:14:22,569
graph may not be the case<font color="#E5E5E5"> naturally</font>

296
00:14:19,899 --> 00:14:24,399
grown so let the user create edges you

297
00:14:22,569 --> 00:14:28,809
are you have a high<font color="#CCCCCC"> probability that you</font>

298
00:14:24,399 --> 00:14:32,370
end<font color="#E5E5E5"> up in this case so expect this query</font>

299
00:14:28,809 --> 00:14:32,370
to<font color="#E5E5E5"> be slow on a large data set</font>

300
00:14:33,480 --> 00:14:39,010
so let me<font color="#CCCCCC"> drop</font><font color="#E5E5E5"> a couple of words about</font><font color="#CCCCCC"> a</font>

301
00:14:37,300 --> 00:14:41,709
<font color="#E5E5E5">rangoli beam because that will be</font><font color="#CCCCCC"> the</font>

302
00:14:39,010 --> 00:14:44,189
<font color="#E5E5E5">technology that</font><font color="#CCCCCC"> I'm going to</font><font color="#E5E5E5"> use to</font><font color="#CCCCCC"> show</font>

303
00:14:41,710 --> 00:14:47,110
you how<font color="#E5E5E5"> to execute those communities so</font>

304
00:14:44,190 --> 00:14:50,590
<font color="#CCCCCC">rank</font><font color="#E5E5E5"> DB is</font><font color="#CCCCCC"> the so-called multi module</font>

305
00:14:47,110 --> 00:14:54,880
database<font color="#E5E5E5"> that means it can store key</font>

306
00:14:50,590 --> 00:14:58,750
value pairs<font color="#E5E5E5"> documents and graphs with</font>

307
00:14:54,880 --> 00:15:00,910
<font color="#CCCCCC">only one core in the same database</font><font color="#E5E5E5"> so I</font>

308
00:14:58,750 --> 00:15:03,640
can use all<font color="#E5E5E5"> the three data models with</font>

309
00:15:00,910 --> 00:15:05,170
one query language<font color="#E5E5E5"> and one process</font>

310
00:15:03,640 --> 00:15:09,250
<font color="#CCCCCC">basically running</font><font color="#E5E5E5"> on top of that and</font>

311
00:15:05,170 --> 00:15:10,569
combine<font color="#E5E5E5"> them in any arbitrary</font><font color="#CCCCCC"> way we</font>

312
00:15:09,250 --> 00:15:14,260
have a query<font color="#E5E5E5"> language which is called</font>

313
00:15:10,570 --> 00:15:17,590
<font color="#CCCCCC">AQL which has document queries graph</font>

314
00:15:14,260 --> 00:15:19,240
<font color="#E5E5E5">queries joins all these things</font>

315
00:15:17,590 --> 00:15:23,320
<font color="#E5E5E5">implemented in the same</font><font color="#CCCCCC"> language and can</font>

316
00:15:19,240 --> 00:15:25,570
<font color="#E5E5E5">arbitrarily combine all of them and it</font>

317
00:15:23,320 --> 00:15:28,540
<font color="#E5E5E5">has</font><font color="#CCCCCC"> asset support for multi collection</font>

318
00:15:25,570 --> 00:15:32,970
transactions on a single server so not

319
00:15:28,540 --> 00:15:32,969
yet on<font color="#E5E5E5"> a distributed version of Arango</font>

320
00:15:33,390 --> 00:15:41,680
how does<font color="#CCCCCC"> actually</font><font color="#E5E5E5"> look like so the</font>

321
00:15:36,730 --> 00:15:45,700
syntax is not sequel because<font color="#E5E5E5"> we found it</font>

322
00:15:41,680 --> 00:15:48,550
<font color="#E5E5E5">rather confusing to like put</font><font color="#CCCCCC"> 90% self</font>

323
00:15:45,700 --> 00:15:51,010
implemented stuff into a sequel and yeah

324
00:15:48,550 --> 00:15:53,469
let the users like try to<font color="#E5E5E5"> use sequel</font>

325
00:15:51,010 --> 00:15:55,870
statements but<font color="#E5E5E5"> they kind of not work so</font>

326
00:15:53,470 --> 00:15:58,180
we decided we need a really

327
00:15:55,870 --> 00:16:00,070
<font color="#E5E5E5">distinguished</font><font color="#CCCCCC"> other language which</font><font color="#E5E5E5"> makes</font>

328
00:15:58,180 --> 00:16:02,469
it<font color="#E5E5E5"> clear that you</font><font color="#CCCCCC"> are not writing sequel</font>

329
00:16:00,070 --> 00:16:05,320
here<font color="#E5E5E5"> and of course super does not really</font>

330
00:16:02,470 --> 00:16:07,810
fit<font color="#E5E5E5"> to document stores and</font><font color="#CCCCCC"> even not</font>

331
00:16:05,320 --> 00:16:09,630
really to graph databases<font color="#E5E5E5"> that's why we</font>

332
00:16:07,810 --> 00:16:13,479
settled<font color="#CCCCCC"> for a new</font><font color="#E5E5E5"> one which is more</font>

333
00:16:09,630 --> 00:16:18,730
focused like xquery<font color="#E5E5E5"> so a query</font><font color="#CCCCCC"> that</font>

334
00:16:13,480 --> 00:16:21,940
allows you to<font color="#E5E5E5"> query</font><font color="#CCCCCC"> XML basically you</font>

335
00:16:18,730 --> 00:16:24,190
are always<font color="#E5E5E5"> writing for loops so for user</font>

336
00:16:21,940 --> 00:16:27,190
in<font color="#E5E5E5"> users means I'm iterating over a</font>

337
00:16:24,190 --> 00:16:30,250
collection<font color="#CCCCCC"> come</font><font color="#E5E5E5"> back comparable to a</font>

338
00:16:27,190 --> 00:16:32,080
relational table and every row I find

339
00:16:30,250 --> 00:16:34,540
will be stored<font color="#E5E5E5"> in the variable user and</font>

340
00:16:32,080 --> 00:16:39,550
will be processed later inside the query

341
00:16:34,540 --> 00:16:42,819
<font color="#E5E5E5">and could for example be returned of</font>

342
00:16:39,550 --> 00:16:45,520
course I can apply filters<font color="#CCCCCC"> so I can say</font>

343
00:16:42,820 --> 00:16:46,480
please<font color="#E5E5E5"> only return me those users with</font>

344
00:16:45,520 --> 00:16:49,990
the name<font color="#CCCCCC"> LS</font>

345
00:16:46,480 --> 00:16:51,670
and the query optimizer<font color="#CCCCCC"> can now</font><font color="#E5E5E5"> figure</font>

346
00:16:49,990 --> 00:16:54,310
out<font color="#E5E5E5"> oh there is actually</font><font color="#CCCCCC"> quite good</font>

347
00:16:51,670 --> 00:16:55,839
index on<font color="#E5E5E5"> this name so will automatically</font>

348
00:16:54,310 --> 00:16:57,849
use<font color="#E5E5E5"> the index in your query</font><font color="#CCCCCC"> you will</font>

349
00:16:55,840 --> 00:16:59,710
<font color="#E5E5E5">never say I want this or that index</font>

350
00:16:57,850 --> 00:17:01,290
inside my query<font color="#E5E5E5"> the optimizer handles</font>

351
00:16:59,710 --> 00:17:04,030
<font color="#CCCCCC">that for you</font>

352
00:17:01,290 --> 00:17:08,200
so with<font color="#E5E5E5"> this query we actually found</font>

353
00:17:04,030 --> 00:17:11,050
find everyone who is called<font color="#E5E5E5"> Ellis and as</font>

354
00:17:08,200 --> 00:17:15,760
promised<font color="#E5E5E5"> we can</font><font color="#CCCCCC"> combine</font><font color="#E5E5E5"> it with</font><font color="#CCCCCC"> graft</font>

355
00:17:11,050 --> 00:17:19,200
results<font color="#E5E5E5"> so we now have at this point</font><font color="#CCCCCC"> a</font>

356
00:17:15,760 --> 00:17:22,839
user in our<font color="#E5E5E5"> hand and we want to continue</font>

357
00:17:19,200 --> 00:17:25,000
starting at this user<font color="#E5E5E5"> so for a product</font>

358
00:17:22,839 --> 00:17:28,208
<font color="#E5E5E5">which is again the variable returned by</font>

359
00:17:25,000 --> 00:17:30,760
the following statement in one outbound

360
00:17:28,209 --> 00:17:33,940
step starting<font color="#E5E5E5"> at the user following the</font>

361
00:17:30,760 --> 00:17:36,040
relation has bought and returned this

362
00:17:33,940 --> 00:17:37,720
product then<font color="#E5E5E5"> we end up with</font><font color="#CCCCCC"> this</font>

363
00:17:36,040 --> 00:17:40,510
following<font color="#E5E5E5"> pattern we start as Ellis</font>

364
00:17:37,720 --> 00:17:46,990
which is pretty<font color="#E5E5E5"> much defined finds one</font>

365
00:17:40,510 --> 00:17:50,520
edge and connect to one product<font color="#CCCCCC"> can also</font>

366
00:17:46,990 --> 00:17:53,170
make it<font color="#E5E5E5"> a bit more</font><font color="#CCCCCC"> complicated so the</font>

367
00:17:50,520 --> 00:17:55,840
<font color="#CCCCCC">graph traversal statement can actually</font>

368
00:17:53,170 --> 00:17:58,560
return three<font color="#CCCCCC"> return attribute there are</font>

369
00:17:55,840 --> 00:18:02,260
<font color="#CCCCCC">sorcery return values first thing is the</font>

370
00:17:58,560 --> 00:18:04,179
last vertex<font color="#E5E5E5"> that is spending on the</font>

371
00:18:02,260 --> 00:18:08,760
second one<font color="#E5E5E5"> is the edge pointing to the</font>

372
00:18:04,180 --> 00:18:11,680
last<font color="#E5E5E5"> vertex and path is the entire path</font>

373
00:18:08,760 --> 00:18:12,910
<font color="#E5E5E5">so let's say in this</font><font color="#CCCCCC"> example if I'm</font>

374
00:18:11,680 --> 00:18:15,450
standing<font color="#E5E5E5"> at PlayStation PlayStation</font>

375
00:18:12,910 --> 00:18:18,730
would be my result for recommendation

376
00:18:15,450 --> 00:18:23,830
<font color="#E5E5E5">this relation would be the action and</font>

377
00:18:18,730 --> 00:18:26,500
the entire<font color="#E5E5E5"> thing would be</font><font color="#CCCCCC"> the past now</font>

378
00:18:23,830 --> 00:18:28,590
I'm<font color="#E5E5E5"> doing three steps</font><font color="#CCCCCC"> or I can</font><font color="#E5E5E5"> also put</font>

379
00:18:26,500 --> 00:18:32,110
in here one two three steps or whatever

380
00:18:28,590 --> 00:18:34,240
I'm<font color="#E5E5E5"> using any direction so</font><font color="#CCCCCC"> I don't care</font>

381
00:18:32,110 --> 00:18:38,280
<font color="#CCCCCC">for the</font><font color="#E5E5E5"> direction of the edge I can go</font>

382
00:18:34,240 --> 00:18:42,400
<font color="#E5E5E5">inbound or outbound</font><font color="#CCCCCC"> whichever I like and</font>

383
00:18:38,280 --> 00:18:45,730
of course<font color="#CCCCCC"> I can</font><font color="#E5E5E5"> apply futures so my</font>

384
00:18:42,400 --> 00:18:49,690
filter would be the second vertex on the

385
00:18:45,730 --> 00:18:52,630
<font color="#CCCCCC">edge which is</font><font color="#E5E5E5"> this guy here should have</font>

386
00:18:49,690 --> 00:18:55,000
an age which<font color="#CCCCCC"> is equal to the users age</font>

387
00:18:52,630 --> 00:18:59,080
plus or minus<font color="#E5E5E5"> five in this range so</font>

388
00:18:55,000 --> 00:19:01,210
someone who<font color="#E5E5E5"> is about my age</font>

389
00:18:59,080 --> 00:19:04,120
and for the recommendation the<font color="#E5E5E5"> price</font>

390
00:19:01,210 --> 00:19:08,169
should<font color="#CCCCCC"> be less than</font><font color="#E5E5E5"> 25 but only I want</font>

391
00:19:04,120 --> 00:19:11,018
<font color="#E5E5E5">the top</font><font color="#CCCCCC"> 10 simple</font><font color="#E5E5E5"> recommendation engine</font>

392
00:19:08,169 --> 00:19:13,990
again<font color="#E5E5E5"> not the best</font><font color="#CCCCCC"> choice but kinda</font>

393
00:19:11,019 --> 00:19:16,720
works<font color="#CCCCCC"> and of course the optimizer will</font>

394
00:19:13,990 --> 00:19:18,880
figure<font color="#E5E5E5"> out if the second vertex on the</font>

395
00:19:16,720 --> 00:19:21,429
path does not have this edge then it

396
00:19:18,880 --> 00:19:27,309
will not continue searching there so

397
00:19:21,429 --> 00:19:31,539
<font color="#CCCCCC">optimization is handled but</font><font color="#E5E5E5"> now let's</font>

398
00:19:27,309 --> 00:19:33,610
talk<font color="#CCCCCC"> about challenges</font><font color="#E5E5E5"> what is the first</font>

399
00:19:31,539 --> 00:19:36,010
<font color="#E5E5E5">challenge if</font><font color="#CCCCCC"> you want to scale a graph</font>

400
00:19:33,610 --> 00:19:39,699
database<font color="#CCCCCC"> and I think that is</font><font color="#E5E5E5"> the most</font>

401
00:19:36,010 --> 00:19:41,529
common<font color="#E5E5E5"> challenge super nodes so super</font>

402
00:19:39,700 --> 00:19:45,210
nodes<font color="#E5E5E5"> in many graphs you have</font><font color="#CCCCCC"> so-called</font>

403
00:19:41,529 --> 00:19:49,960
<font color="#CCCCCC">celebrities</font><font color="#E5E5E5"> super important people or</font>

404
00:19:45,210 --> 00:19:54,789
items<font color="#E5E5E5"> whatever which have many many many</font>

405
00:19:49,960 --> 00:19:57,549
inbound or outbound vertex edges so

406
00:19:54,789 --> 00:20:02,039
let's say if you go for Twitter and you

407
00:19:57,549 --> 00:20:04,539
pick let's say Donald Trump he has like

408
00:20:02,039 --> 00:20:07,450
super<font color="#E5E5E5"> large amount of followers</font><font color="#CCCCCC"> so</font>

409
00:20:04,539 --> 00:20:10,870
<font color="#CCCCCC">whenever your query</font><font color="#E5E5E5"> walks over him you</font>

410
00:20:07,450 --> 00:20:14,350
have to<font color="#CCCCCC"> check all the</font><font color="#E5E5E5"> followers of 12 of</font>

411
00:20:10,870 --> 00:20:18,489
Donald Trump which are a lot no

412
00:20:14,350 --> 00:20:22,209
political statement here please and<font color="#E5E5E5"> as</font>

413
00:20:18,490 --> 00:20:23,679
we said the traversal scales<font color="#CCCCCC"> only with</font>

414
00:20:22,210 --> 00:20:26,230
the amount of connected edges that we

415
00:20:23,679 --> 00:20:29,440
have so this guy will<font color="#CCCCCC"> be super</font><font color="#E5E5E5"> expensive</font>

416
00:20:26,230 --> 00:20:31,600
<font color="#CCCCCC">if your query instead</font><font color="#E5E5E5"> would go over my</font>

417
00:20:29,440 --> 00:20:34,389
<font color="#E5E5E5">account you</font><font color="#CCCCCC"> have</font><font color="#E5E5E5"> less followers</font>

418
00:20:31,600 --> 00:20:39,639
unfortunately so the query would be

419
00:20:34,389 --> 00:20:42,490
faster however often you<font color="#E5E5E5"> only need a</font>

420
00:20:39,639 --> 00:20:45,158
subset of those edges<font color="#E5E5E5"> so in most cases</font>

421
00:20:42,490 --> 00:20:48,669
you<font color="#CCCCCC"> only need like the top 10 newest</font><font color="#E5E5E5"> 10</font>

422
00:20:45,159 --> 00:20:52,690
or edges<font color="#E5E5E5"> that</font><font color="#CCCCCC"> have a</font><font color="#E5E5E5"> certain</font><font color="#CCCCCC"> attribute</font>

423
00:20:48,669 --> 00:20:55,299
<font color="#E5E5E5">on to them so what we can do as a first</font>

424
00:20:52,690 --> 00:20:59,789
boost<font color="#CCCCCC"> is the so called vertex centric</font>

425
00:20:55,299 --> 00:21:02,830
index a vertex centric index allows<font color="#E5E5E5"> to</font>

426
00:20:59,789 --> 00:21:06,639
index an edge based on the connected

427
00:21:02,830 --> 00:21:10,090
vertex plus<font color="#E5E5E5"> arbitrary attributes</font><font color="#CCCCCC"> on the</font>

428
00:21:06,639 --> 00:21:11,408
<font color="#CCCCCC">edge itself it can then be sorted or it</font>

429
00:21:10,090 --> 00:21:13,330
can be

430
00:21:11,409 --> 00:21:16,450
like<font color="#E5E5E5"> only for</font><font color="#CCCCCC"> equality like hash index</font>

431
00:21:13,330 --> 00:21:19,230
or whatever index type<font color="#E5E5E5"> important thing</font>

432
00:21:16,450 --> 00:21:23,919
it is connected to the<font color="#CCCCCC"> vertex plus</font>

433
00:21:19,230 --> 00:21:26,649
<font color="#E5E5E5">something stored on the edge the thing</font>

434
00:21:23,919 --> 00:21:28,090
is<font color="#E5E5E5"> the index so finding the result in</font>

435
00:21:26,649 --> 00:21:32,408
the index if it's not sorted<font color="#E5E5E5"> this</font>

436
00:21:28,090 --> 00:21:34,600
constant time at least<font color="#E5E5E5"> for a hash index</font>

437
00:21:32,409 --> 00:21:38,019
if it is sorted<font color="#E5E5E5"> it may be logarithmic</font>

438
00:21:34,600 --> 00:21:39,668
<font color="#E5E5E5">time but still faster then fetching all</font>

439
00:21:38,019 --> 00:21:41,529
the in the edges connected to that

440
00:21:39,669 --> 00:21:46,779
vertex<font color="#E5E5E5"> and then iterating</font><font color="#CCCCCC"> through the</font>

441
00:21:41,529 --> 00:21:49,090
entire<font color="#E5E5E5"> set so if you have this index in</font>

442
00:21:46,779 --> 00:21:52,240
place<font color="#E5E5E5"> you have</font><font color="#CCCCCC"> either less or no post</font>

443
00:21:49,090 --> 00:21:54,428
filtering required<font color="#E5E5E5"> and thereby this</font>

444
00:21:52,240 --> 00:21:58,330
<font color="#E5E5E5">decreases</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> N in this equation</font>

445
00:21:54,429 --> 00:22:04,090
drastically and you get kind<font color="#CCCCCC"> of fast</font>

446
00:21:58,330 --> 00:22:10,019
queries but now let's come<font color="#CCCCCC"> to challenge</font>

447
00:22:04,090 --> 00:22:12,490
<font color="#CCCCCC">to Big Data</font><font color="#E5E5E5"> so we have big data now a</font>

448
00:22:10,019 --> 00:22:14,230
lot of<font color="#CCCCCC"> companies out there just store</font>

449
00:22:12,490 --> 00:22:16,659
everything<font color="#CCCCCC"> you can</font><font color="#E5E5E5"> so whenever you click</font>

450
00:22:14,230 --> 00:22:19,690
with your mouse on<font color="#E5E5E5"> a website it stores</font>

451
00:22:16,659 --> 00:22:22,960
an event in the database at some pages

452
00:22:19,690 --> 00:22:28,000
at least and of course this also happens

453
00:22:22,960 --> 00:22:30,429
<font color="#CCCCCC">to graph data so from our opinion</font><font color="#E5E5E5"> on</font>

454
00:22:28,000 --> 00:22:33,539
from<font color="#E5E5E5"> our customers we see that the data</font>

455
00:22:30,429 --> 00:22:36,039
<font color="#E5E5E5">set easily grows beyond a single machine</font>

456
00:22:33,539 --> 00:22:40,720
<font color="#E5E5E5">even</font><font color="#CCCCCC"> these super large machines that you</font>

457
00:22:36,039 --> 00:22:43,990
can buy nowadays of course<font color="#CCCCCC"> also for</font>

458
00:22:40,720 --> 00:22:45,700
graph data so we need<font color="#E5E5E5"> challenge</font><font color="#CCCCCC"> or we</font>

459
00:22:43,990 --> 00:22:47,919
have the challenge to<font color="#CCCCCC"> actually allow</font>

460
00:22:45,700 --> 00:22:51,429
graph processing<font color="#E5E5E5"> for more than one</font>

461
00:22:47,919 --> 00:22:53,730
<font color="#CCCCCC">machine in all the graph algorithms</font><font color="#E5E5E5"> that</font>

462
00:22:51,429 --> 00:22:53,730
we want

463
00:22:54,790 --> 00:23:02,180
how can we do the scaling<font color="#E5E5E5"> so the general</font>

464
00:22:58,040 --> 00:23:04,670
scaling idea is<font color="#E5E5E5"> so called charting so</font>

465
00:23:02,180 --> 00:23:08,450
you distribute the graph or the data set

466
00:23:04,670 --> 00:23:11,600
in general<font color="#CCCCCC"> onto several</font><font color="#E5E5E5"> machines in so</font>

467
00:23:08,450 --> 00:23:13,910
called charts<font color="#CCCCCC"> chart</font><font color="#E5E5E5"> means you have your</font>

468
00:23:11,600 --> 00:23:18,379
huge data set<font color="#E5E5E5"> you just</font><font color="#CCCCCC"> chop it in parts</font>

469
00:23:13,910 --> 00:23:19,820
<font color="#E5E5E5">and each part belongs on one machine no</font>

470
00:23:18,380 --> 00:23:21,530
machine holds the entire<font color="#CCCCCC"> data set</font>

471
00:23:19,820 --> 00:23:25,100
<font color="#CCCCCC">because the assumption is the data set</font>

472
00:23:21,530 --> 00:23:26,960
<font color="#E5E5E5">is too large for this however every</font>

473
00:23:25,100 --> 00:23:32,959
machine could hold in theory<font color="#E5E5E5"> more than</font>

474
00:23:26,960 --> 00:23:37,640
one<font color="#E5E5E5"> chart so</font><font color="#CCCCCC"> sharing itself is kind of</font>

475
00:23:32,960 --> 00:23:40,070
solved<font color="#E5E5E5"> and kind of easy complexity comes</font>

476
00:23:37,640 --> 00:23:43,640
if you like to query<font color="#E5E5E5"> it especially in</font>

477
00:23:40,070 --> 00:23:47,450
the graph area<font color="#E5E5E5"> so how to query</font><font color="#CCCCCC"> it now</font>

478
00:23:43,640 --> 00:23:50,840
<font color="#E5E5E5">first of all we cannot get a global view</font>

479
00:23:47,450 --> 00:23:52,490
of the graph<font color="#E5E5E5"> cause the assumption is it</font>

480
00:23:50,840 --> 00:23:57,020
doesn't<font color="#E5E5E5"> fit on a single</font><font color="#CCCCCC"> machine</font><font color="#E5E5E5"> so how</font>

481
00:23:52,490 --> 00:23:58,820
<font color="#E5E5E5">should we compute it and at some point</font>

482
00:23:57,020 --> 00:24:02,230
we have<font color="#CCCCCC"> to chop the data set so</font><font color="#E5E5E5"> what</font>

483
00:23:58,820 --> 00:24:02,230
about the edges between<font color="#E5E5E5"> service</font>

484
00:24:03,760 --> 00:24:08,600
challenges<font color="#E5E5E5"> in addition in Charlotte</font>

485
00:24:06,080 --> 00:24:11,179
environments the network most of the

486
00:24:08,600 --> 00:24:13,100
time is<font color="#E5E5E5"> the bottleneck so if you have a</font>

487
00:24:11,180 --> 00:24:19,400
query<font color="#CCCCCC"> that just</font><font color="#E5E5E5"> constantly jumps</font><font color="#CCCCCC"> between</font>

488
00:24:13,100 --> 00:24:21,740
service it's most likely slow and so you

489
00:24:19,400 --> 00:24:24,110
want to reduce<font color="#E5E5E5"> the network as much as</font>

490
00:24:21,740 --> 00:24:27,020
possible<font color="#E5E5E5"> and</font><font color="#CCCCCC"> keep as much as possible</font><font color="#E5E5E5"> on</font>

491
00:24:24,110 --> 00:24:31,879
a local machine<font color="#E5E5E5"> so the target is reduce</font>

492
00:24:27,020 --> 00:24:35,150
<font color="#CCCCCC">network</font><font color="#E5E5E5"> ops again we could</font><font color="#CCCCCC"> use vertex</font>

493
00:24:31,880 --> 00:24:38,660
Centrex indexes for super nodes<font color="#E5E5E5"> however</font>

494
00:24:35,150 --> 00:24:40,040
they<font color="#CCCCCC"> only work on a single machine</font><font color="#E5E5E5"> at</font>

495
00:24:38,660 --> 00:24:41,570
least there<font color="#E5E5E5"> is no distributed</font>

496
00:24:40,040 --> 00:24:44,270
implementation<font color="#E5E5E5"> that I know of</font><font color="#CCCCCC"> right now</font>

497
00:24:41,570 --> 00:24:45,970
for vertex<font color="#CCCCCC"> entry index so if anyone</font>

498
00:24:44,270 --> 00:24:49,100
knows<font color="#CCCCCC"> please correct me</font>

499
00:24:45,970 --> 00:24:52,820
so what eccentric<font color="#E5E5E5"> index is only help</font>

500
00:24:49,100 --> 00:24:54,199
<font color="#E5E5E5">forcing a machine nevertheless so for</font>

501
00:24:52,820 --> 00:24:55,820
one chart you could<font color="#E5E5E5"> add a vertex and</font>

502
00:24:54,200 --> 00:25:01,130
rake index and it should be better than

503
00:24:55,820 --> 00:25:03,689
<font color="#E5E5E5">for local theory so now first let's</font>

504
00:25:01,130 --> 00:25:08,919
distribute the graph

505
00:25:03,690 --> 00:25:11,169
so what are the dangers<font color="#CCCCCC"> of</font><font color="#E5E5E5"> trotting so</font>

506
00:25:08,919 --> 00:25:13,960
first of all<font color="#E5E5E5"> only</font><font color="#CCCCCC"> part</font><font color="#E5E5E5"> of the graph on</font>

507
00:25:11,169 --> 00:25:16,749
every machine<font color="#E5E5E5"> neighboring vertices may</font>

508
00:25:13,960 --> 00:25:20,139
be on different<font color="#CCCCCC"> machines</font><font color="#E5E5E5"> and even edges</font>

509
00:25:16,749 --> 00:25:21,789
could be on<font color="#E5E5E5"> another machine at least</font><font color="#CCCCCC"> in</font>

510
00:25:20,139 --> 00:25:23,949
the<font color="#CCCCCC"> Arang</font><font color="#E5E5E5"> DB case I think for neo4j</font>

511
00:25:21,789 --> 00:25:25,629
that's probably not possible<font color="#CCCCCC"> I</font><font color="#E5E5E5"> think you</font>

512
00:25:23,950 --> 00:25:29,609
<font color="#CCCCCC">don't have this</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> sharting mechanism</font>

513
00:25:25,629 --> 00:25:32,109
<font color="#E5E5E5">at all right so so if you just</font>

514
00:25:29,609 --> 00:25:33,789
distribute the<font color="#E5E5E5"> data randomly</font><font color="#CCCCCC"> it could be</font>

515
00:25:32,109 --> 00:25:35,139
that one<font color="#E5E5E5"> vertex is here</font><font color="#CCCCCC"> the edge is</font>

516
00:25:33,789 --> 00:25:39,429
<font color="#E5E5E5">there and the third</font><font color="#CCCCCC"> vertex is over this</font>

517
00:25:35,139 --> 00:25:41,799
machine<font color="#E5E5E5"> potentially next queries need to</font>

518
00:25:39,429 --> 00:25:43,119
be<font color="#E5E5E5"> executed in a distributed way so you</font>

519
00:25:41,799 --> 00:25:44,559
need to select some part that

520
00:25:43,119 --> 00:25:46,178
<font color="#E5E5E5">coordinates or I have to fetch some data</font>

521
00:25:44,559 --> 00:25:49,840
<font color="#E5E5E5">here some data there</font><font color="#CCCCCC"> and some data over</font>

522
00:25:46,179 --> 00:25:51,909
<font color="#CCCCCC">here and then the reader the result</font>

523
00:25:49,840 --> 00:25:54,220
<font color="#E5E5E5">needs to be merged locally so make sure</font>

524
00:25:51,909 --> 00:25:56,409
if we have a distributed<font color="#E5E5E5"> graph engine</font>

525
00:25:54,220 --> 00:26:01,509
that your result<font color="#E5E5E5"> is not the entire graph</font>

526
00:25:56,409 --> 00:26:03,850
<font color="#E5E5E5">because that will kill your machine so</font>

527
00:26:01,509 --> 00:26:05,559
distribution techniques<font color="#E5E5E5"> easiest</font>

528
00:26:03,850 --> 00:26:09,369
distribution<font color="#E5E5E5"> to see what I like to call</font>

529
00:26:05,559 --> 00:26:11,918
<font color="#CCCCCC">random distribution</font><font color="#E5E5E5"> advantage of random</font>

530
00:26:09,369 --> 00:26:14,830
<font color="#CCCCCC">distribution is every server takes an</font>

531
00:26:11,919 --> 00:26:16,330
equal portion<font color="#E5E5E5"> of data because the idea</font>

532
00:26:14,830 --> 00:26:18,519
<font color="#E5E5E5">of random</font><font color="#CCCCCC"> distribution is that I take</font>

533
00:26:16,330 --> 00:26:21,279
every single<font color="#E5E5E5"> object</font><font color="#CCCCCC"> be</font><font color="#E5E5E5"> it a vertex or an</font>

534
00:26:18,519 --> 00:26:23,109
edge throw a dice and<font color="#E5E5E5"> depending on the</font>

535
00:26:21,279 --> 00:26:27,909
result<font color="#CCCCCC"> I put it</font><font color="#E5E5E5"> on one of these</font><font color="#CCCCCC"> machines</font>

536
00:26:23,109 --> 00:26:29,460
<font color="#E5E5E5">I don't care for the surrounding random</font>

537
00:26:27,909 --> 00:26:31,720
<font color="#CCCCCC">distribution is super easy to</font><font color="#E5E5E5"> realize</font>

538
00:26:29,460 --> 00:26:35,200
<font color="#E5E5E5">because</font><font color="#CCCCCC"> mustard random is like pretty</font>

539
00:26:31,720 --> 00:26:38,369
<font color="#E5E5E5">much implementable by everyone and</font><font color="#CCCCCC"> you</font>

540
00:26:35,200 --> 00:26:43,840
don't need any knowledge<font color="#E5E5E5"> about the</font><font color="#CCCCCC"> data</font>

541
00:26:38,369 --> 00:26:47,379
<font color="#E5E5E5">so it works on</font><font color="#CCCCCC"> any data set</font><font color="#E5E5E5"> disadvantage</font>

542
00:26:43,840 --> 00:26:50,699
and this will be<font color="#E5E5E5"> clear as soon</font><font color="#CCCCCC"> as we</font>

543
00:26:47,379 --> 00:26:53,189
distribute this graph on these machines

544
00:26:50,700 --> 00:26:55,960
<font color="#E5E5E5">the neighbor sound different machines</font>

545
00:26:53,190 --> 00:26:58,359
you<font color="#E5E5E5"> have totally lost the entire layout</font>

546
00:26:55,960 --> 00:27:01,119
of the graph<font color="#E5E5E5"> it's like not connected</font>

547
00:26:58,359 --> 00:27:04,408
anymore so reconstructing the original

548
00:27:01,119 --> 00:27:06,100
graph of this thing is quite hard

549
00:27:04,409 --> 00:27:08,350
probably the edges<font color="#E5E5E5"> are on different</font>

550
00:27:06,100 --> 00:27:10,480
machines than<font color="#E5E5E5"> their their vertices and a</font>

551
00:27:08,350 --> 00:27:15,010
lot of<font color="#E5E5E5"> network overhead is required for</font>

552
00:27:10,480 --> 00:27:20,610
curing nevertheless it works

553
00:27:15,010 --> 00:27:24,160
expect it to be slow so let's first

554
00:27:20,610 --> 00:27:26,280
switch<font color="#E5E5E5"> to the demonstration shortly so</font>

555
00:27:24,160 --> 00:27:30,010
this is a<font color="#CCCCCC"> Wrangler TBS web interface I</font>

556
00:27:26,280 --> 00:27:32,550
have imported a social network which is

557
00:27:30,010 --> 00:27:35,770
called<font color="#CCCCCC"> Phuket which is available from</font>

558
00:27:32,550 --> 00:27:39,040
Stanford University<font color="#CCCCCC"> for download and I</font>

559
00:27:35,770 --> 00:27:41,500
have imported it two times one time this

560
00:27:39,040 --> 00:27:43,210
<font color="#E5E5E5">is</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> random</font><font color="#CCCCCC"> distribution</font><font color="#E5E5E5"> one time with</font>

561
00:27:41,500 --> 00:27:46,870
the<font color="#CCCCCC"> smart distribution that</font><font color="#E5E5E5"> I'm going</font><font color="#CCCCCC"> to</font>

562
00:27:43,210 --> 00:27:51,580
cover in a minute<font color="#E5E5E5"> it has around 1.6</font>

563
00:27:46,870 --> 00:27:52,959
million profiles<font color="#E5E5E5"> if I'm not mistaken</font><font color="#CCCCCC"> and</font>

564
00:27:51,580 --> 00:27:57,550
<font color="#E5E5E5">that's not printed there in this</font>

565
00:27:52,960 --> 00:28:03,220
resolution<font color="#E5E5E5"> and it has 30 million edges</font>

566
00:27:57,550 --> 00:28:04,990
connecting those those vertices<font color="#E5E5E5"> and the</font>

567
00:28:03,220 --> 00:28:06,670
<font color="#E5E5E5">random</font><font color="#CCCCCC"> distribution actually</font><font color="#E5E5E5"> uses or</font>

568
00:28:04,990 --> 00:28:08,590
places the documents and the vertices

569
00:28:06,670 --> 00:28:10,840
<font color="#E5E5E5">like somewhere in my</font><font color="#CCCCCC"> cluster</font><font color="#E5E5E5"> so I'm</font>

570
00:28:08,590 --> 00:28:13,060
running<font color="#E5E5E5"> a</font><font color="#CCCCCC"> 3 instance</font><font color="#E5E5E5"> clusters through</font>

571
00:28:10,840 --> 00:28:17,199
physical service all<font color="#E5E5E5"> of them</font><font color="#CCCCCC"> running</font>

572
00:28:13,060 --> 00:28:21,190
<font color="#E5E5E5">each</font><font color="#CCCCCC"> and Arango dB now I have a clearing</font>

573
00:28:17,200 --> 00:28:23,980
<font color="#CCCCCC">a simple two-step traversal so I'm</font>

574
00:28:21,190 --> 00:28:25,300
starting at one<font color="#E5E5E5"> vertex I'm using the</font>

575
00:28:23,980 --> 00:28:28,570
<font color="#CCCCCC">bank parameters here because I'm</font><font color="#E5E5E5"> not</font>

576
00:28:25,300 --> 00:28:30,190
changing<font color="#E5E5E5"> the query later on so I say the</font>

577
00:28:28,570 --> 00:28:32,620
starting collection and a graph that<font color="#CCCCCC"> I</font>

578
00:28:30,190 --> 00:28:35,380
should<font color="#CCCCCC"> use the random distributed graph</font>

579
00:28:32,620 --> 00:28:37,739
I apply<font color="#CCCCCC"> some filter on the first level</font>

580
00:28:35,380 --> 00:28:40,080
<font color="#CCCCCC">and</font><font color="#E5E5E5"> I just</font><font color="#CCCCCC"> return</font><font color="#E5E5E5"> the key because it's</font>

581
00:28:37,740 --> 00:28:43,360
<font color="#E5E5E5">easy and</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> don't want the network</font>

582
00:28:40,080 --> 00:28:47,830
traffic<font color="#CCCCCC"> to slow</font><font color="#E5E5E5"> down the result so if I</font>

583
00:28:43,360 --> 00:28:50,709
<font color="#E5E5E5">execute this query and wait and</font><font color="#CCCCCC"> wait a</font>

584
00:28:47,830 --> 00:28:54,879
bit<font color="#CCCCCC"> longer so in 1.5 seconds I can</font>

585
00:28:50,710 --> 00:28:58,330
<font color="#CCCCCC">actually find 5700 vertices matching</font>

586
00:28:54,880 --> 00:29:02,140
<font color="#E5E5E5">this condition more importantly this</font>

587
00:28:58,330 --> 00:29:03,689
time<font color="#E5E5E5"> 1.5 seconds this is not what we aim</font>

588
00:29:02,140 --> 00:29:08,350
for

589
00:29:03,690 --> 00:29:12,070
so now let's go<font color="#E5E5E5"> on for scaling first of</font>

590
00:29:08,350 --> 00:29:14,199
all index<font color="#CCCCCC"> free</font><font color="#E5E5E5"> adjacency that is the</font>

591
00:29:12,070 --> 00:29:17,350
<font color="#E5E5E5">mechanism that is more used by most as a</font>

592
00:29:14,200 --> 00:29:19,450
graph databases<font color="#E5E5E5"> and that means that</font>

593
00:29:17,350 --> 00:29:22,959
every<font color="#CCCCCC"> vertex actually maintains two</font>

594
00:29:19,450 --> 00:29:24,970
lists<font color="#E5E5E5"> of its edges the in and the out</font>

595
00:29:22,960 --> 00:29:27,480
list<font color="#E5E5E5"> and they are physically attached to</font>

596
00:29:24,970 --> 00:29:27,480
<font color="#E5E5E5">the vertex</font>

597
00:29:27,650 --> 00:29:32,159
has the advantage that<font color="#E5E5E5"> we do not need</font><font color="#CCCCCC"> an</font>

598
00:29:30,120 --> 00:29:33,689
index<font color="#CCCCCC"> to find</font><font color="#E5E5E5"> those edges because</font>

599
00:29:32,159 --> 00:29:36,240
whenever we fetch a vertex<font color="#E5E5E5"> we have the</font>

600
00:29:33,690 --> 00:29:40,110
list of<font color="#CCCCCC"> edges we only need to fetch the</font>

601
00:29:36,240 --> 00:29:41,400
connected vertex again but if we have

602
00:29:40,110 --> 00:29:44,158
this condition<font color="#CCCCCC"> that it has to be</font>

603
00:29:41,400 --> 00:29:47,760
physically<font color="#E5E5E5"> attached</font><font color="#CCCCCC"> to the vertex</font><font color="#E5E5E5"> how</font>

604
00:29:44,159 --> 00:29:50,929
could we shot<font color="#E5E5E5"> this if we want to shot it</font>

605
00:29:47,760 --> 00:29:54,179
<font color="#E5E5E5">in a good</font><font color="#CCCCCC"> way so first part</font><font color="#E5E5E5"> is clear</font>

606
00:29:50,929 --> 00:29:58,020
<font color="#E5E5E5">second part is clear where to put the</font>

607
00:29:54,179 --> 00:30:01,049
edge because<font color="#CCCCCC"> if I put</font><font color="#E5E5E5"> it on the</font><font color="#CCCCCC"> left</font>

608
00:29:58,020 --> 00:30:03,299
machine only it would violate the

609
00:30:01,049 --> 00:30:03,840
condition on the right one<font color="#CCCCCC"> and</font><font color="#E5E5E5"> vice</font>

610
00:30:03,299 --> 00:30:07,080
<font color="#E5E5E5">versa</font>

611
00:30:03,840 --> 00:30:09,510
I could duplicate it but<font color="#E5E5E5"> then I need</font><font color="#CCCCCC"> to</font>

612
00:30:07,080 --> 00:30:11,879
<font color="#CCCCCC">have some logic that keeps both versions</font>

613
00:30:09,510 --> 00:30:18,149
in sync when<font color="#CCCCCC"> I write to the different</font>

614
00:30:11,880 --> 00:30:21,409
<font color="#E5E5E5">machines and</font><font color="#CCCCCC"> wrangly</font><font color="#E5E5E5"> B goes a different</font>

615
00:30:18,149 --> 00:30:24,360
path so we<font color="#CCCCCC"> have a hash based</font><font color="#E5E5E5"> edge index</font>

616
00:30:21,409 --> 00:30:28,169
which<font color="#CCCCCC"> is constant</font><font color="#E5E5E5"> time lookup</font><font color="#CCCCCC"> because</font>

617
00:30:24,360 --> 00:30:31,620
this<font color="#CCCCCC"> edge based but this makes the edges</font>

618
00:30:28,169 --> 00:30:33,240
independent from<font color="#E5E5E5"> the vertices so the</font>

619
00:30:31,620 --> 00:30:36,330
vertices just<font color="#E5E5E5"> know okay</font><font color="#CCCCCC"> I have to</font><font color="#E5E5E5"> ask</font>

620
00:30:33,240 --> 00:30:38,610
there and find my list of edges but this

621
00:30:36,330 --> 00:30:40,289
<font color="#E5E5E5">actually</font><font color="#CCCCCC"> allows us to like pick any of</font>

622
00:30:38,610 --> 00:30:43,590
these<font color="#E5E5E5"> two servers and saw the edge there</font>

623
00:30:40,289 --> 00:30:50,879
<font color="#E5E5E5">and are not</font><font color="#CCCCCC"> forcing us them on a on a</font>

624
00:30:43,590 --> 00:30:51,629
specific<font color="#CCCCCC"> machine but now comes</font><font color="#E5E5E5"> the</font>

625
00:30:50,880 --> 00:30:55,860
tricky<font color="#E5E5E5"> part</font>

626
00:30:51,630 --> 00:30:57,990
domain based<font color="#CCCCCC"> distribution</font><font color="#E5E5E5"> so what we</font>

627
00:30:55,860 --> 00:31:01,520
have found in our customers is<font color="#E5E5E5"> that many</font>

628
00:30:57,990 --> 00:31:04,470
graphs<font color="#E5E5E5"> have a natural distribution</font>

629
00:31:01,520 --> 00:31:07,889
<font color="#E5E5E5">natural</font><font color="#CCCCCC"> distribution means that most</font>

630
00:31:04,470 --> 00:31:10,399
part of the graph<font color="#E5E5E5"> actually on largely</font>

631
00:31:07,890 --> 00:31:13,169
<font color="#CCCCCC">connected they share a common property</font>

632
00:31:10,399 --> 00:31:17,010
<font color="#E5E5E5">so for example if you have a social</font>

633
00:31:13,169 --> 00:31:18,390
network<font color="#E5E5E5"> friend</font><font color="#CCCCCC"> network typically</font><font color="#E5E5E5"> most of</font>

634
00:31:17,010 --> 00:31:21,360
your<font color="#E5E5E5"> friends will be from the same</font>

635
00:31:18,390 --> 00:31:23,250
region or country<font color="#E5E5E5"> then you are you will</font>

636
00:31:21,360 --> 00:31:26,668
<font color="#E5E5E5">have some friends abroad</font><font color="#CCCCCC"> but</font><font color="#E5E5E5"> most of</font>

637
00:31:23,250 --> 00:31:29,130
them will be<font color="#E5E5E5"> local</font><font color="#CCCCCC"> or if you</font><font color="#E5E5E5"> are having</font>

638
00:31:26,669 --> 00:31:31,740
storing blocks in a in a graph for

639
00:31:29,130 --> 00:31:34,370
whatever reason probably blocks with<font color="#E5E5E5"> the</font>

640
00:31:31,740 --> 00:31:37,409
same tag<font color="#E5E5E5"> are related to one another</font>

641
00:31:34,370 --> 00:31:39,570
<font color="#E5E5E5">category</font><font color="#CCCCCC"> for products</font><font color="#E5E5E5"> and a couple of</font>

642
00:31:37,409 --> 00:31:42,119
more just some examples

643
00:31:39,570 --> 00:31:44,789
so for this<font color="#E5E5E5"> that this distribution means</font>

644
00:31:42,119 --> 00:31:48,629
most edges are<font color="#CCCCCC"> only inside the</font><font color="#E5E5E5"> same</font>

645
00:31:44,789 --> 00:31:52,019
group so connecting<font color="#E5E5E5"> people from Brussels</font>

646
00:31:48,629 --> 00:31:54,509
<font color="#E5E5E5">and you have rare edges between</font>

647
00:31:52,019 --> 00:31:58,529
<font color="#E5E5E5">different groups but though they are</font>

648
00:31:54,509 --> 00:32:02,759
loud<font color="#E5E5E5"> and if we are now apply the</font><font color="#CCCCCC"> no vein</font>

649
00:31:58,529 --> 00:32:05,639
<font color="#E5E5E5">based distribution on this graph we can</font>

650
00:32:02,759 --> 00:32:08,729
actually<font color="#E5E5E5"> chart it in a bit better way if</font>

651
00:32:05,639 --> 00:32:11,639
we use the domain<font color="#E5E5E5"> as charting attribute</font>

652
00:32:08,729 --> 00:32:13,470
<font color="#E5E5E5">and thereby</font><font color="#CCCCCC"> we put large paths</font><font color="#E5E5E5"> on one</font>

653
00:32:11,639 --> 00:32:16,549
machine<font color="#E5E5E5"> another large part on the second</font>

654
00:32:13,470 --> 00:32:18,690
and another<font color="#E5E5E5"> large part on the search and</font>

655
00:32:16,549 --> 00:32:22,879
<font color="#E5E5E5">we have</font><font color="#CCCCCC"> a choice where we put these</font>

656
00:32:18,690 --> 00:32:22,879
edges<font color="#E5E5E5"> so either this or there or there</font>

657
00:32:23,749 --> 00:32:28,950
if the database now knows that<font color="#CCCCCC"> this</font>

658
00:32:27,179 --> 00:32:31,409
condition<font color="#E5E5E5"> is</font><font color="#CCCCCC"> true</font><font color="#E5E5E5"> that most of the</font>

659
00:32:28,950 --> 00:32:34,369
dissection<font color="#E5E5E5"> on a physical</font><font color="#CCCCCC"> machine</font><font color="#E5E5E5"> it can</font>

660
00:32:31,409 --> 00:32:37,169
do much much<font color="#CCCCCC"> more operations locally</font>

661
00:32:34,369 --> 00:32:43,769
which are much<font color="#CCCCCC"> faster than</font><font color="#E5E5E5"> if you have</font>

662
00:32:37,169 --> 00:32:45,749
<font color="#E5E5E5">to do</font><font color="#CCCCCC"> Network</font><font color="#E5E5E5"> in between however this is</font>

663
00:32:43,769 --> 00:32:51,479
<font color="#E5E5E5">only available in a ranga DB Enterprise</font>

664
00:32:45,749 --> 00:32:56,389
Edition<font color="#E5E5E5"> and if we use this domain</font>

665
00:32:51,479 --> 00:33:01,559
knowledge for<font color="#E5E5E5"> shortcuts where's my demo</font>

666
00:32:56,389 --> 00:33:03,478
<font color="#E5E5E5">over here yeah</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> same data set and I'm</font>

667
00:33:01,559 --> 00:33:06,269
just<font color="#E5E5E5"> using the different distribution of</font>

668
00:33:03,479 --> 00:33:08,669
the<font color="#E5E5E5"> data across the service so only</font>

669
00:33:06,269 --> 00:33:12,590
<font color="#E5E5E5">thing I change is I am</font><font color="#CCCCCC"> not using</font><font color="#E5E5E5"> random</font>

670
00:33:08,669 --> 00:33:12,590
but I'm using smart

671
00:33:14,590 --> 00:33:27,189
and off we<font color="#CCCCCC"> go 1 2 3 300</font><font color="#E5E5E5"> milliseconds</font>

672
00:33:24,179 --> 00:33:31,149
exactly the<font color="#E5E5E5"> same result so if you want</font>

673
00:33:27,190 --> 00:33:32,919
<font color="#E5E5E5">to you can compare those things but we</font>

674
00:33:31,149 --> 00:33:35,590
could<font color="#E5E5E5"> make use of the</font><font color="#CCCCCC"> knowledge that we</font>

675
00:33:32,919 --> 00:33:38,080
<font color="#CCCCCC">have most</font><font color="#E5E5E5"> of the data local and just</font>

676
00:33:35,590 --> 00:33:40,178
<font color="#CCCCCC">somewhere we</font><font color="#E5E5E5"> needed to do a network hub</font>

677
00:33:38,080 --> 00:33:44,139
to get and collect the other<font color="#CCCCCC"> parts of</font>

678
00:33:40,179 --> 00:33:46,480
<font color="#E5E5E5">the data I have</font><font color="#CCCCCC"> seen</font><font color="#E5E5E5"> much</font><font color="#CCCCCC"> more</font>

679
00:33:44,139 --> 00:33:48,850
impressive numbers on some of our

680
00:33:46,480 --> 00:33:51,429
customer data<font color="#E5E5E5"> where they could invest</font>

681
00:33:48,850 --> 00:33:53,498
case like<font color="#CCCCCC"> with the entire graph or parts</font>

682
00:33:51,429 --> 00:33:55,480
<font color="#CCCCCC">of one customer graph on a single</font>

683
00:33:53,499 --> 00:33:57,730
machine and just<font color="#CCCCCC"> needed to short because</font>

684
00:33:55,480 --> 00:33:59,499
<font color="#E5E5E5">they have many customers</font><font color="#CCCCCC"> and then they</font>

685
00:33:57,730 --> 00:34:01,389
get<font color="#CCCCCC"> really down</font><font color="#E5E5E5"> to single server</font>

686
00:33:59,499 --> 00:34:05,879
performance although<font color="#CCCCCC"> they have an</font>

687
00:34:01,389 --> 00:34:05,879
arbitrary<font color="#E5E5E5"> scalable cluster at the hence</font>

688
00:34:09,030 --> 00:34:13,990
yeah<font color="#E5E5E5"> skip this animation good</font><font color="#CCCCCC"> how does</font>

689
00:34:13,389 --> 00:34:16,990
<font color="#E5E5E5">it work</font>

690
00:34:13,989 --> 00:34:19,689
so this is the<font color="#CCCCCC"> Arango DB's architecture</font>

691
00:34:16,989 --> 00:34:22,540
in<font color="#CCCCCC"> the cluster</font><font color="#E5E5E5"> we have database service</font>

692
00:34:19,690 --> 00:34:24,668
responsible<font color="#E5E5E5"> for the data and we have</font>

693
00:34:22,540 --> 00:34:27,520
coordinators which are the user facing

694
00:34:24,668 --> 00:34:29,799
servers so the user asks<font color="#CCCCCC"> a coordinator</font>

695
00:34:27,520 --> 00:34:32,009
with<font color="#CCCCCC"> a</font><font color="#E5E5E5"> query the coordinator will figure</font>

696
00:34:29,800 --> 00:34:34,149
<font color="#E5E5E5">out which database servers play a role</font>

697
00:34:32,010 --> 00:34:35,409
distributed down<font color="#E5E5E5"> to</font><font color="#CCCCCC"> the database</font><font color="#E5E5E5"> service</font>

698
00:34:34,149 --> 00:34:40,750
and they physically fetch the data

699
00:34:35,409 --> 00:34:45,909
reported<font color="#E5E5E5"> back so if I now create a long</font>

700
00:34:40,750 --> 00:34:47,760
path which is<font color="#E5E5E5"> actually quite sorted</font>

701
00:34:45,909 --> 00:34:50,409
already<font color="#E5E5E5"> just for the sake of</font>

702
00:34:47,760 --> 00:34:53,829
<font color="#E5E5E5">demonstration we see here that</font><font color="#CCCCCC"> we need</font>

703
00:34:50,409 --> 00:34:56,800
<font color="#CCCCCC">one two three four five six network</font><font color="#E5E5E5"> hops</font>

704
00:34:53,829 --> 00:35:00,579
to collect the entire<font color="#CCCCCC"> result</font><font color="#E5E5E5"> set if we</font>

705
00:34:56,800 --> 00:35:03,609
could shut it a bit better we can<font color="#E5E5E5"> get</font>

706
00:35:00,579 --> 00:35:07,359
away with<font color="#E5E5E5"> a single one much faster and</font>

707
00:35:03,609 --> 00:35:09,339
<font color="#E5E5E5">this is the whole</font><font color="#CCCCCC"> idea on how we</font>

708
00:35:07,359 --> 00:35:12,700
<font color="#E5E5E5">actually get a lot of speed</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> a scaled</font>

709
00:35:09,339 --> 00:35:14,819
<font color="#CCCCCC">Network for point queries question</font>

710
00:35:12,700 --> 00:35:14,819
please

711
00:35:15,059 --> 00:35:23,289
yeah so so the query<font color="#E5E5E5"> is how we like</font>

712
00:35:20,380 --> 00:35:26,140
remove these shots<font color="#E5E5E5"> these vertices around</font>

713
00:35:23,289 --> 00:35:28,450
<font color="#E5E5E5">if you do it adaptively or if the graph</font>

714
00:35:26,140 --> 00:35:30,609
<font color="#CCCCCC">is loaded so for the u version</font><font color="#E5E5E5"> released</font>

715
00:35:28,450 --> 00:35:34,269
<font color="#CCCCCC">you have to give the</font><font color="#E5E5E5"> sharding attribute</font>

716
00:35:30,609 --> 00:35:37,119
<font color="#CCCCCC">upfront and we put the vertices</font><font color="#E5E5E5"> by that</font>

717
00:35:34,269 --> 00:35:39,038
<font color="#CCCCCC">rotting attribute our plan is to</font><font color="#E5E5E5"> do this</font>

718
00:35:37,119 --> 00:35:52,809
more adaptively in the future but that's

719
00:35:39,039 --> 00:35:55,299
not implemented<font color="#CCCCCC"> yet yes please</font><font color="#E5E5E5"> yeah so</font>

720
00:35:52,809 --> 00:35:58,630
<font color="#E5E5E5">the</font><font color="#CCCCCC"> question is what happens if</font><font color="#E5E5E5"> the</font>

721
00:35:55,299 --> 00:35:59,950
graph<font color="#CCCCCC"> changes over time</font><font color="#E5E5E5"> the assumption</font>

722
00:35:58,630 --> 00:36:03,369
<font color="#E5E5E5">is that in most case the distribution</font>

723
00:35:59,950 --> 00:36:04,990
<font color="#CCCCCC">kind of stays the same of course you</font>

724
00:36:03,369 --> 00:36:05,859
<font color="#E5E5E5">will</font><font color="#CCCCCC"> have people</font><font color="#E5E5E5"> that move out into</font>

725
00:36:04,990 --> 00:36:08,410
<font color="#E5E5E5">other areas</font>

726
00:36:05,859 --> 00:36:12,400
so for these<font color="#E5E5E5"> actually the query will get</font>

727
00:36:08,410 --> 00:36:14,529
slower because then the condition first

728
00:36:12,400 --> 00:36:15,539
<font color="#E5E5E5">doesn't hold anymore because most</font>

729
00:36:14,529 --> 00:36:18,819
friends will be in a<font color="#CCCCCC"> different</font><font color="#E5E5E5"> location</font>

730
00:36:15,539 --> 00:36:21,430
<font color="#CCCCCC">but</font><font color="#E5E5E5"> over time probably</font><font color="#CCCCCC"> the friendship</font>

731
00:36:18,819 --> 00:36:24,519
changes<font color="#E5E5E5"> for this guy as well to the next</font>

732
00:36:21,430 --> 00:36:27,009
or a<font color="#E5E5E5"> local area so it may be possible</font>

733
00:36:24,519 --> 00:36:29,410
<font color="#CCCCCC">that if that changes some critters may</font>

734
00:36:27,009 --> 00:36:31,210
be slower than<font color="#CCCCCC"> before because the</font>

735
00:36:29,410 --> 00:36:33,460
distribution<font color="#E5E5E5"> changes for certain</font>

736
00:36:31,210 --> 00:36:35,680
vertices<font color="#E5E5E5"> but in general it works out</font>

737
00:36:33,460 --> 00:36:37,569
<font color="#E5E5E5">quite well because</font><font color="#CCCCCC"> the the core of</font>

738
00:36:35,680 --> 00:36:45,399
<font color="#E5E5E5">distribution doesn't change like</font>

739
00:36:37,569 --> 00:36:46,808
randomly around<font color="#CCCCCC"> in most cases</font><font color="#E5E5E5"> yeah so</font>

740
00:36:45,400 --> 00:36:48,549
the<font color="#E5E5E5"> question is if the shotty key has to</font>

741
00:36:46,809 --> 00:36:58,029
<font color="#CCCCCC">be defined</font><font color="#E5E5E5"> on every vertex and that's</font>

742
00:36:48,549 --> 00:37:25,209
true good time<font color="#E5E5E5"> for questions</font>

743
00:36:58,029 --> 00:37:26,529
<font color="#E5E5E5">Thanks yeah so the question</font><font color="#CCCCCC"> is if we</font>

744
00:37:25,209 --> 00:37:31,388
have<font color="#CCCCCC"> considered implementing different</font>

745
00:37:26,529 --> 00:37:35,499
<font color="#E5E5E5">fewer languages so we have thought of it</font>

746
00:37:31,389 --> 00:37:37,749
<font color="#E5E5E5">for sure but</font><font color="#CCCCCC"> the thing is we are a multi</font>

747
00:37:35,499 --> 00:37:39,218
<font color="#E5E5E5">modal database so our</font><font color="#CCCCCC"> query</font><font color="#E5E5E5"> language has</font>

748
00:37:37,749 --> 00:37:42,399
<font color="#CCCCCC">the requirement that</font><font color="#E5E5E5"> it can cover all</font>

749
00:37:39,219 --> 00:37:44,529
the data models that we have<font color="#CCCCCC"> and rough</font>

750
00:37:42,399 --> 00:37:47,969
<font color="#E5E5E5">few languages are typically designed</font>

751
00:37:44,529 --> 00:37:47,969
only<font color="#CCCCCC"> for the graph module</font>

752
00:37:56,880 --> 00:38:02,329
but<font color="#CCCCCC"> with product</font>

753
00:38:00,380 --> 00:38:04,490
for us it won't be able<font color="#E5E5E5"> to handle like</font>

754
00:38:02,329 --> 00:38:11,569
500<font color="#E5E5E5"> Korean languages which are out there</font>

755
00:38:04,490 --> 00:38:14,269
right now this<font color="#CCCCCC"> did title</font><font color="#E5E5E5"> channeling</font>

756
00:38:11,569 --> 00:38:23,329
billions just what were the largest

757
00:38:14,269 --> 00:38:25,689
deployments of a remedy that<font color="#CCCCCC"> you used so</font>

758
00:38:23,329 --> 00:38:31,700
the question is what was<font color="#CCCCCC"> the largest</font>

759
00:38:25,690 --> 00:38:34,009
<font color="#CCCCCC">setup</font><font color="#E5E5E5"> that we have seen so far</font><font color="#CCCCCC"> so it was</font>

760
00:38:31,700 --> 00:38:35,538
above 1 billion vertices<font color="#E5E5E5"> but I don't</font>

761
00:38:34,009 --> 00:38:38,240
have the numbers like in the back<font color="#CCCCCC"> of my</font>

762
00:38:35,539 --> 00:38:41,599
head above 1 billion<font color="#E5E5E5"> and 10 10 or 20</font>

763
00:38:38,240 --> 00:38:46,129
times<font color="#E5E5E5"> as many</font><font color="#CCCCCC"> edges so works out quite</font>

764
00:38:41,599 --> 00:38:49,990
<font color="#CCCCCC">well yes thank you</font><font color="#E5E5E5"> so much</font>

765
00:38:46,130 --> 00:38:54,690
<font color="#E5E5E5">I have t-shirts so we have our lights</font>

766
00:38:49,990 --> 00:38:54,689
[Applause]

