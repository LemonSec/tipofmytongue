1
00:00:05,109 --> 00:00:12,260
<font color="#E5E5E5">okay so thank you for coming</font><font color="#CCCCCC"> and to this</font>

2
00:00:09,469 --> 00:00:14,928
talk where I will talk about histogram

3
00:00:12,260 --> 00:00:17,570
support in the upcoming<font color="#CCCCCC"> -</font><font color="#E5E5E5"> great</font>

4
00:00:14,929 --> 00:00:20,810
<font color="#E5E5E5">let's</font><font color="#CCCCCC"> arrow</font><font color="#E5E5E5"> and my name is</font><font color="#CCCCCC"> a stan</font>

5
00:00:17,570 --> 00:00:26,259
gremlin<font color="#CCCCCC"> I work for the optimizer team at</font>

6
00:00:20,810 --> 00:00:28,909
Oracle<font color="#CCCCCC"> there my</font><font color="#E5E5E5"> skill</font><font color="#CCCCCC"> optimize</font><font color="#E5E5E5"> team so</font>

7
00:00:26,260 --> 00:00:30,710
the agenda<font color="#E5E5E5"> for my talk is that I will</font>

8
00:00:28,910 --> 00:00:34,690
start<font color="#E5E5E5"> with a motivating</font><font color="#CCCCCC"> example about</font>

9
00:00:30,710 --> 00:00:38,290
why you want to care about<font color="#E5E5E5"> histograms</font>

10
00:00:34,690 --> 00:00:43,010
<font color="#E5E5E5">also</font><font color="#CCCCCC"> QuickStart guide on how to</font><font color="#E5E5E5"> use</font><font color="#CCCCCC"> it</font>

11
00:00:38,290 --> 00:00:46,129
<font color="#E5E5E5">how it used internally in MySQL some</font>

12
00:00:43,010 --> 00:00:49,339
example of how you can<font color="#E5E5E5"> get better query</font>

13
00:00:46,129 --> 00:00:54,290
plans by using histograms<font color="#E5E5E5"> and end up</font>

14
00:00:49,339 --> 00:00:57,650
with some concluded some advice so for

15
00:00:54,290 --> 00:01:00,019
that<font color="#E5E5E5"> motivating</font><font color="#CCCCCC"> example on the need for</font>

16
00:00:57,650 --> 00:01:02,390
histograms<font color="#CCCCCC"> I have this simple joint</font>

17
00:01:00,019 --> 00:01:05,420
query here<font color="#E5E5E5"> you're joining two tables the</font>

18
00:01:02,390 --> 00:01:07,939
orders<font color="#E5E5E5"> and the customer tables and I</font>

19
00:01:05,420 --> 00:01:11,630
have some<font color="#E5E5E5"> very conditions on the date</font>

20
00:01:07,939 --> 00:01:15,889
<font color="#E5E5E5">and their account balance of the</font>

21
00:01:11,630 --> 00:01:20,479
customer and if I<font color="#E5E5E5"> learn explain on this</font>

22
00:01:15,890 --> 00:01:22,550
<font color="#E5E5E5">query you will get a query plan the plan</font>

23
00:01:20,480 --> 00:01:24,860
that the optimizer has chosen in<font color="#E5E5E5"> order</font>

24
00:01:22,550 --> 00:01:26,720
<font color="#E5E5E5">to execute this query and</font><font color="#CCCCCC"> what you can</font>

25
00:01:24,860 --> 00:01:28,910
see<font color="#CCCCCC"> from the output is that it will</font>

26
00:01:26,720 --> 00:01:33,289
start with<font color="#CCCCCC"> the oldest tables and then</font>

27
00:01:28,910 --> 00:01:35,450
for each go of the old tables it will do

28
00:01:33,290 --> 00:01:37,700
lookups<font color="#E5E5E5"> into the customer table to find</font>

29
00:01:35,450 --> 00:01:41,840
<font color="#E5E5E5">the</font><font color="#CCCCCC"> matching oh and you can see which</font>

30
00:01:37,700 --> 00:01:45,050
index is used<font color="#E5E5E5"> this one is</font><font color="#CCCCCC"> we'll</font><font color="#E5E5E5"> be using</font>

31
00:01:41,840 --> 00:01:48,140
<font color="#CCCCCC">a table scan</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> that is because when</font>

32
00:01:45,050 --> 00:01:52,729
you<font color="#CCCCCC"> are looking</font><font color="#E5E5E5"> for more than</font><font color="#CCCCCC"> 30%</font><font color="#E5E5E5"> of the</font>

33
00:01:48,140 --> 00:01:55,190
rows using<font color="#CCCCCC"> any index</font><font color="#E5E5E5"> is not optimal</font>

34
00:01:52,729 --> 00:01:58,158
anymore because<font color="#E5E5E5"> you will access so many</font>

35
00:01:55,190 --> 00:02:03,740
rows<font color="#E5E5E5"> that</font><font color="#CCCCCC"> is more efficient to just scan</font>

36
00:01:58,159 --> 00:02:06,140
<font color="#E5E5E5">through the entire table we have an</font>

37
00:02:03,740 --> 00:02:10,788
<font color="#E5E5E5">index on order date as we can see here</font>

38
00:02:06,140 --> 00:02:14,090
<font color="#E5E5E5">but we</font><font color="#CCCCCC"> are choosing</font><font color="#E5E5E5"> not to</font><font color="#CCCCCC"> use it this</font>

39
00:02:10,788 --> 00:02:16,339
<font color="#CCCCCC">estimate</font><font color="#E5E5E5"> you have hair on filtering is</font>

40
00:02:14,090 --> 00:02:18,590
pretty<font color="#E5E5E5"> accurate because</font><font color="#CCCCCC"> when you have an</font>

41
00:02:16,340 --> 00:02:20,989
index what the optimizer<font color="#CCCCCC"> does</font>

42
00:02:18,590 --> 00:02:25,069
<font color="#E5E5E5">is asked the</font><font color="#CCCCCC"> stoat engine in this case</font>

43
00:02:20,989 --> 00:02:29,180
<font color="#E5E5E5">in ODB how many rows are in this range</font>

44
00:02:25,069 --> 00:02:31,579
<font color="#E5E5E5">and what the</font><font color="#CCCCCC"> OSHA engine does or in</font>

45
00:02:29,180 --> 00:02:33,680
<font color="#E5E5E5">Odaiba does in that</font><font color="#CCCCCC"> case</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> its stuff</font>

46
00:02:31,580 --> 00:02:35,810
takes the<font color="#E5E5E5"> start of range and</font><font color="#CCCCCC"> the end of</font>

47
00:02:33,680 --> 00:02:38,239
the range<font color="#E5E5E5"> and navigate</font><font color="#CCCCCC"> through the</font><font color="#E5E5E5"> b3</font>

48
00:02:35,810 --> 00:02:42,230
<font color="#E5E5E5">and it then it estimates the distance</font>

49
00:02:38,239 --> 00:02:45,860
between the two pages that<font color="#CCCCCC"> it</font><font color="#E5E5E5"> founds the</font>

50
00:02:42,230 --> 00:02:48,798
<font color="#E5E5E5">start and</font><font color="#CCCCCC"> end low end</font><font color="#E5E5E5"> and that way it</font>

51
00:02:45,860 --> 00:02:53,019
has<font color="#E5E5E5"> a pretty good estimate on this size</font>

52
00:02:48,799 --> 00:02:56,660
of the range<font color="#E5E5E5"> however for the other table</font>

53
00:02:53,019 --> 00:02:59,780
the customer table<font color="#E5E5E5"> we don't have an</font>

54
00:02:56,660 --> 00:03:03,129
index on<font color="#E5E5E5"> this account balance column so</font>

55
00:02:59,780 --> 00:03:07,250
the optimizer<font color="#CCCCCC"> does not have any</font>

56
00:03:03,129 --> 00:03:11,780
information about the selectivity<font color="#E5E5E5"> of</font>

57
00:03:07,250 --> 00:03:15,250
this condition but what it does in<font color="#E5E5E5"> my</font>

58
00:03:11,780 --> 00:03:17,840
<font color="#E5E5E5">SQL five seven</font><font color="#CCCCCC"> eightt it makes a guess</font>

59
00:03:15,250 --> 00:03:20,420
and since this is a range it guesses

60
00:03:17,840 --> 00:03:22,340
that<font color="#E5E5E5"> probably one third could be in this</font>

61
00:03:20,420 --> 00:03:27,200
guess it's good and but this<font color="#E5E5E5"> is just</font><font color="#CCCCCC"> the</font>

62
00:03:22,340 --> 00:03:32,410
<font color="#E5E5E5">guess not something it has any any basis</font>

63
00:03:27,200 --> 00:03:32,410
for except the type of<font color="#E5E5E5"> expression here</font>

64
00:03:32,920 --> 00:03:39,078
<font color="#E5E5E5">so you might wonder is this really</font><font color="#CCCCCC"> the</font>

65
00:03:36,200 --> 00:03:42,078
best join order so one way<font color="#CCCCCC"> to try to</font>

66
00:03:39,079 --> 00:03:45,950
<font color="#E5E5E5">different is to use a hint</font><font color="#CCCCCC"> and if this</font>

67
00:03:42,079 --> 00:03:47,780
was<font color="#E5E5E5"> a</font><font color="#CCCCCC"> 2-0 I can actually force the join</font>

68
00:03:45,950 --> 00:03:50,238
order<font color="#E5E5E5"> with this hint I say customer</font>

69
00:03:47,780 --> 00:03:53,989
<font color="#E5E5E5">should be before orders in earlier</font>

70
00:03:50,239 --> 00:03:56,900
versions you have straight join that can

71
00:03:53,989 --> 00:03:58,970
do the<font color="#E5E5E5"> same but then I would have to</font>

72
00:03:56,900 --> 00:04:01,130
switch the<font color="#CCCCCC"> order here because then</font>

73
00:03:58,970 --> 00:04:03,349
customer actually<font color="#E5E5E5"> has to come before the</font>

74
00:04:01,130 --> 00:04:06,290
orders<font color="#CCCCCC"> in there and in the</font><font color="#E5E5E5"> joint query</font>

75
00:04:03,349 --> 00:04:08,119
so this new hints has the advantage that

76
00:04:06,290 --> 00:04:12,250
<font color="#E5E5E5">you don't have to edit your query in</font>

77
00:04:08,120 --> 00:04:12,250
order to specify<font color="#CCCCCC"> the join order</font>

78
00:04:15,090 --> 00:04:22,590
and what I see<font color="#E5E5E5"> when I execute this query</font>

79
00:04:20,139 --> 00:04:26,350
is is that if I switch<font color="#CCCCCC"> to join order</font>

80
00:04:22,590 --> 00:04:30,219
it's much faster<font color="#E5E5E5"> it goes from 15 seconds</font>

81
00:04:26,350 --> 00:04:33,479
to<font color="#CCCCCC"> 1 second</font><font color="#E5E5E5"> and the reason</font><font color="#CCCCCC"> for</font><font color="#E5E5E5"> that is</font>

82
00:04:30,220 --> 00:04:36,729
that there is no customer<font color="#E5E5E5"> that has</font>

83
00:04:33,479 --> 00:04:39,010
account<font color="#E5E5E5"> balance of less</font><font color="#CCCCCC"> than minus</font><font color="#E5E5E5"> 1000</font>

84
00:04:36,729 --> 00:04:40,240
<font color="#E5E5E5">so actually if you do this order</font><font color="#CCCCCC"> you</font>

85
00:04:39,010 --> 00:04:42,490
will scan<font color="#CCCCCC"> through the entire customer</font>

86
00:04:40,240 --> 00:04:44,440
<font color="#E5E5E5">table you can find nothing</font><font color="#CCCCCC"> and there</font>

87
00:04:42,490 --> 00:04:47,979
will be no luck<font color="#E5E5E5"> lookups into the orders</font>

88
00:04:44,440 --> 00:04:50,770
table but this<font color="#E5E5E5"> the optimizer is not able</font>

89
00:04:47,979 --> 00:04:53,229
to do<font color="#E5E5E5"> that don't know that because it</font>

90
00:04:50,770 --> 00:04:55,990
does not<font color="#E5E5E5"> have any information about the</font>

91
00:04:53,229 --> 00:04:59,260
selectivity<font color="#CCCCCC"> of this</font><font color="#E5E5E5"> condition and that</font>

92
00:04:55,990 --> 00:05:02,710
<font color="#CCCCCC">is where histograms</font><font color="#E5E5E5"> come in so what I</font>

93
00:04:59,260 --> 00:05:05,650
can<font color="#E5E5E5"> do</font><font color="#CCCCCC"> I can say create a histogram</font>

94
00:05:02,710 --> 00:05:09,820
<font color="#CCCCCC">using the syntax</font><font color="#E5E5E5"> coming back to more on</font>

95
00:05:05,650 --> 00:05:11,469
that on this column and after<font color="#E5E5E5"> that you</font>

96
00:05:09,820 --> 00:05:14,560
see that now it will<font color="#E5E5E5"> pick this join</font>

97
00:05:11,470 --> 00:05:17,169
order there's no join hint<font color="#E5E5E5"> that forcing</font>

98
00:05:14,560 --> 00:05:19,450
<font color="#E5E5E5">this join</font><font color="#CCCCCC"> ora it speaks it by itself</font>

99
00:05:17,169 --> 00:05:23,799
<font color="#CCCCCC">because now it knows that the filtering</font>

100
00:05:19,450 --> 00:05:28,090
<font color="#E5E5E5">here is say a percent so now you see why</font>

101
00:05:23,800 --> 00:05:31,150
the histogram is a useful<font color="#E5E5E5"> addition when</font>

102
00:05:28,090 --> 00:05:37,359
<font color="#CCCCCC">you don't</font><font color="#E5E5E5"> have any other in statistics</font>

103
00:05:31,150 --> 00:05:38,380
on your<font color="#E5E5E5"> columns so a quick start guide</font>

104
00:05:37,360 --> 00:05:40,960
on histograms

105
00:05:38,380 --> 00:05:43,090
or I could<font color="#E5E5E5"> also call it all you need to</font>

106
00:05:40,960 --> 00:05:47,948
know about histograms probably is not

107
00:05:43,090 --> 00:05:50,859
<font color="#E5E5E5">that much so histograms</font><font color="#CCCCCC"> as statistics on</font>

108
00:05:47,949 --> 00:05:54,070
columns<font color="#E5E5E5"> the distributions of the values</font>

109
00:05:50,860 --> 00:05:57,010
you<font color="#E5E5E5"> have for your columns you've grouped</font>

110
00:05:54,070 --> 00:05:59,409
the data values into buckets<font color="#CCCCCC"> I will get</font>

111
00:05:57,010 --> 00:06:02,099
back<font color="#E5E5E5"> to what</font><font color="#CCCCCC"> that means and</font><font color="#E5E5E5"> for each</font>

112
00:05:59,410 --> 00:06:06,400
packet you calculate the frequency of

113
00:06:02,099 --> 00:06:10,330
values in that<font color="#E5E5E5"> packet the the instagrams</font>

114
00:06:06,400 --> 00:06:14,590
<font color="#CCCCCC">you can have they have maximum of 1024</font>

115
00:06:10,330 --> 00:06:16,750
buckets<font color="#E5E5E5"> and then you build a MySQL</font>

116
00:06:14,590 --> 00:06:20,409
builds a histogram<font color="#E5E5E5"> and</font><font color="#CCCCCC"> could</font><font color="#E5E5E5"> either base</font>

117
00:06:16,750 --> 00:06:22,810
it on all the rows of a table<font color="#CCCCCC"> or on a</font>

118
00:06:20,410 --> 00:06:25,630
sample of the rows of<font color="#E5E5E5"> the table</font>

119
00:06:22,810 --> 00:06:28,030
it depends basically on the available

120
00:06:25,630 --> 00:06:31,480
amount of memory<font color="#E5E5E5"> use you</font>

121
00:06:28,030 --> 00:06:35,260
we serve folk<font color="#CCCCCC"> Trading the histogram</font><font color="#E5E5E5"> and</font>

122
00:06:31,480 --> 00:06:39,520
there are<font color="#E5E5E5"> two histogram types which are</font>

123
00:06:35,260 --> 00:06:41,500
automatically<font color="#CCCCCC"> chosen by the MySQL</font><font color="#E5E5E5"> it</font>

124
00:06:39,520 --> 00:06:43,930
could either be a single<font color="#E5E5E5"> tool which has</font>

125
00:06:41,500 --> 00:06:47,140
one<font color="#E5E5E5"> value per bucket or an acne height</font>

126
00:06:43,930 --> 00:06:50,230
which can have multiple values by bucket

127
00:06:47,140 --> 00:06:52,180
<font color="#E5E5E5">I will show now what</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> means if you</font>

128
00:06:50,230 --> 00:06:53,770
have a single turn histogram you have

129
00:06:52,180 --> 00:06:55,840
one<font color="#E5E5E5"> value per bucket</font>

130
00:06:53,770 --> 00:06:58,750
and for each package you store the value

131
00:06:55,840 --> 00:07:07,080
and the cumulative<font color="#CCCCCC"> frequency for that</font>

132
00:06:58,750 --> 00:07:10,720
bucket<font color="#CCCCCC"> and here's an example you have a</font>

133
00:07:07,080 --> 00:07:13,270
set<font color="#E5E5E5"> of values between a column has a set</font>

134
00:07:10,720 --> 00:07:16,360
<font color="#CCCCCC">of</font><font color="#E5E5E5"> value</font><font color="#CCCCCC"> a domain between seven and ten</font>

135
00:07:13,270 --> 00:07:20,400
and you have like<font color="#CCCCCC"> 14% zeroes</font><font color="#E5E5E5"> you have</font>

136
00:07:16,360 --> 00:07:24,100
<font color="#CCCCCC">twenty two</font><font color="#E5E5E5"> percent</font><font color="#CCCCCC"> once and so on</font><font color="#E5E5E5"> and</font>

137
00:07:20,400 --> 00:07:26,409
this<font color="#E5E5E5"> is very useful</font><font color="#CCCCCC"> because</font><font color="#E5E5E5"> your since</font>

138
00:07:24,100 --> 00:07:30,460
you have one<font color="#E5E5E5"> bucket for each value you</font>

139
00:07:26,410 --> 00:07:33,940
<font color="#E5E5E5">it's you can both estimate easily the</font>

140
00:07:30,460 --> 00:07:37,530
quality frequency or the<font color="#E5E5E5"> range</font>

141
00:07:33,940 --> 00:07:41,350
frequencies<font color="#E5E5E5"> because the quality will be</font>

142
00:07:37,530 --> 00:07:46,739
as I<font color="#E5E5E5"> said if you have the</font><font color="#CCCCCC"> call Youm</font>

143
00:07:41,350 --> 00:07:46,740
<font color="#CCCCCC">equals zero</font><font color="#E5E5E5"> if you know it's</font><font color="#CCCCCC"> 14% in that</font>

144
00:07:48,390 --> 00:07:54,520
that is the selectivity<font color="#E5E5E5"> and if it's like</font>

145
00:07:52,570 --> 00:07:56,349
less than<font color="#CCCCCC"> five you know that</font><font color="#E5E5E5"> this the</font>

146
00:07:54,520 --> 00:08:01,510
sum of<font color="#E5E5E5"> these four buckets gives you this</font>

147
00:07:56,350 --> 00:08:03,550
a selectivity<font color="#E5E5E5"> and you see if there's no</font>

148
00:08:01,510 --> 00:08:05,979
value like<font color="#E5E5E5"> four-four there's no value so</font>

149
00:08:03,550 --> 00:08:09,040
<font color="#CCCCCC">there's no bucket for four here</font><font color="#E5E5E5"> so you</font>

150
00:08:05,979 --> 00:08:11,409
can also<font color="#E5E5E5"> determine or</font><font color="#CCCCCC"> lock values larger</font>

151
00:08:09,040 --> 00:08:14,620
<font color="#E5E5E5">than</font><font color="#CCCCCC"> ten so</font><font color="#E5E5E5"> you can easily determine if</font>

152
00:08:11,410 --> 00:08:20,020
<font color="#CCCCCC">there's if a certain value is not</font><font color="#E5E5E5"> in</font>

153
00:08:14,620 --> 00:08:22,510
your database but often<font color="#E5E5E5"> you have columns</font>

154
00:08:20,020 --> 00:08:25,060
that can take very many values and then

155
00:08:22,510 --> 00:08:26,229
<font color="#E5E5E5">you</font><font color="#CCCCCC"> can tie one</font><font color="#E5E5E5"> bucket for each value so</font>

156
00:08:25,060 --> 00:08:30,430
then we have<font color="#E5E5E5"> something called</font>

157
00:08:26,229 --> 00:08:34,299
<font color="#CCCCCC">eques height histograms which can have</font>

158
00:08:30,430 --> 00:08:36,789
<font color="#CCCCCC">multiple values</font><font color="#E5E5E5"> per bucket and the</font><font color="#CCCCCC"> ones</font>

159
00:08:34,299 --> 00:08:40,169
we have implemented<font color="#CCCCCC"> it's not</font><font color="#E5E5E5"> true equal</font>

160
00:08:36,789 --> 00:08:44,590
height because unlike the

161
00:08:40,169 --> 00:08:47,890
<font color="#CCCCCC">basically right histograms we do not</font>

162
00:08:44,590 --> 00:08:50,230
split values across packet<font color="#E5E5E5"> so because in</font>

163
00:08:47,890 --> 00:08:52,000
this<font color="#E5E5E5"> case this is</font><font color="#CCCCCC"> the same values as we</font>

164
00:08:50,230 --> 00:08:54,310
had on the<font color="#CCCCCC"> previous slides but now we</font>

165
00:08:52,000 --> 00:08:58,390
have<font color="#E5E5E5"> only five buckets</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> you get more</font>

166
00:08:54,310 --> 00:09:03,689
<font color="#CCCCCC">than one in each potentially more than</font>

167
00:08:58,390 --> 00:09:06,970
one value<font color="#CCCCCC"> per bucket and you see that a</font>

168
00:09:03,690 --> 00:09:12,220
nice feature with<font color="#E5E5E5"> they're not the quite</font>

169
00:09:06,970 --> 00:09:14,350
equal height<font color="#E5E5E5"> approach is that for</font><font color="#CCCCCC"> high</font>

170
00:09:12,220 --> 00:09:18,070
<font color="#CCCCCC">frequency value you get</font><font color="#E5E5E5"> a separate</font>

171
00:09:14,350 --> 00:09:20,320
<font color="#CCCCCC">bucket</font><font color="#E5E5E5"> so for the most most the most</font>

172
00:09:18,070 --> 00:09:24,160
frequent value<font color="#E5E5E5"> here is one</font><font color="#CCCCCC"> and and in</font>

173
00:09:20,320 --> 00:09:25,720
this case you<font color="#CCCCCC"> actually get a separate</font>

174
00:09:24,160 --> 00:09:28,089
bucket<font color="#E5E5E5"> for one so if</font><font color="#CCCCCC"> you have something</font>

175
00:09:25,720 --> 00:09:32,470
<font color="#E5E5E5">like equals one</font><font color="#CCCCCC"> or</font><font color="#E5E5E5"> not equals one you</font>

176
00:09:28,089 --> 00:09:37,420
get a pretty good<font color="#E5E5E5"> estimates but in other</font>

177
00:09:32,470 --> 00:09:40,720
cases this<font color="#CCCCCC"> is equal height is</font><font color="#E5E5E5"> best for</font>

178
00:09:37,420 --> 00:09:42,819
range and not always<font color="#E5E5E5"> that good for</font>

179
00:09:40,720 --> 00:09:45,400
equality<font color="#CCCCCC"> take the</font><font color="#E5E5E5"> example of if you have</font>

180
00:09:42,820 --> 00:09:48,070
something<font color="#CCCCCC"> equals</font><font color="#E5E5E5"> six you have this</font>

181
00:09:45,400 --> 00:09:50,350
bucket with five and<font color="#CCCCCC"> six and you see</font>

182
00:09:48,070 --> 00:09:52,870
that the<font color="#CCCCCC"> frequency up for</font><font color="#E5E5E5"> this package</font>

183
00:09:50,350 --> 00:09:55,150
is<font color="#CCCCCC"> 13% so</font><font color="#E5E5E5"> you estimate</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> six and a</font>

184
00:09:52,870 --> 00:09:57,339
half percent<font color="#E5E5E5"> of each but in this case</font>

185
00:09:55,150 --> 00:10:00,459
there was actually<font color="#CCCCCC"> twelve</font><font color="#E5E5E5"> percent</font><font color="#CCCCCC"> with</font>

186
00:09:57,339 --> 00:10:02,650
five and<font color="#CCCCCC"> one percent with six so</font><font color="#E5E5E5"> you see</font>

187
00:10:00,460 --> 00:10:07,540
that<font color="#CCCCCC"> XP height</font><font color="#E5E5E5"> is two amps when you do</font>

188
00:10:02,650 --> 00:10:12,160
ranges<font color="#E5E5E5"> is not that accurate</font><font color="#CCCCCC"> as a</font>

189
00:10:07,540 --> 00:10:13,900
singleton histogram so for this extra

190
00:10:12,160 --> 00:10:15,250
height<font color="#E5E5E5"> less time we need to store that</font>

191
00:10:13,900 --> 00:10:19,390
we<font color="#E5E5E5"> store the</font><font color="#CCCCCC"> minimum value the maximum</font>

192
00:10:15,250 --> 00:10:26,770
<font color="#E5E5E5">value the frequency cumulative frequency</font>

193
00:10:19,390 --> 00:10:29,980
and the number of distinct values<font color="#E5E5E5"> so how</font>

194
00:10:26,770 --> 00:10:32,890
to create or refresh<font color="#E5E5E5"> a histogram for</font>

195
00:10:29,980 --> 00:10:35,529
<font color="#CCCCCC">column</font><font color="#E5E5E5"> you do an analyze table command</font>

196
00:10:32,890 --> 00:10:37,620
but it's a<font color="#E5E5E5"> special variant where you say</font>

197
00:10:35,529 --> 00:10:43,360
<font color="#E5E5E5">update histogram on called acetylcholine</font>

198
00:10:37,620 --> 00:10:45,550
<font color="#E5E5E5">with a set of buckets note that this</font>

199
00:10:43,360 --> 00:10:46,810
<font color="#CCCCCC">analyze table command it will</font><font color="#E5E5E5"> just do</font>

200
00:10:45,550 --> 00:10:48,640
the histogram<font color="#CCCCCC"> and then you say update</font>

201
00:10:46,810 --> 00:10:51,219
histogram<font color="#E5E5E5"> it will just do that it will</font>

202
00:10:48,640 --> 00:10:52,230
<font color="#E5E5E5">not do the other</font><font color="#CCCCCC"> analyze that the normal</font>

203
00:10:51,220 --> 00:10:55,890
thing you do with<font color="#E5E5E5"> an</font>

204
00:10:52,230 --> 00:11:04,080
stable<font color="#E5E5E5"> and you conduct</font><font color="#CCCCCC"> a histogram some</font>

205
00:10:55,890 --> 00:11:06,660
<font color="#CCCCCC">columns - as I said earlier whether to</font>

206
00:11:04,080 --> 00:11:11,810
do sampling<font color="#E5E5E5"> or</font><font color="#CCCCCC"> use</font><font color="#E5E5E5"> the entire table is</font>

207
00:11:06,660 --> 00:11:15,089
based on available memory<font color="#E5E5E5"> which you</font><font color="#CCCCCC"> can</font>

208
00:11:11,810 --> 00:11:16,560
set with this variable<font color="#CCCCCC"> and</font><font color="#E5E5E5"> the default</font>

209
00:11:15,090 --> 00:11:19,410
is<font color="#CCCCCC"> to</font><font color="#E5E5E5"> use 20 megabyte</font>

210
00:11:16,560 --> 00:11:21,510
while creating the histogram<font color="#CCCCCC"> this is</font>

211
00:11:19,410 --> 00:11:24,089
about the<font color="#E5E5E5"> amount of memory when creating</font>

212
00:11:21,510 --> 00:11:27,960
the history I'm not the final story

213
00:11:24,090 --> 00:11:30,000
shall<font color="#E5E5E5"> a histogram we have implemented a</font>

214
00:11:27,960 --> 00:11:35,130
new<font color="#CCCCCC"> store changing API for</font><font color="#E5E5E5"> the sampling</font>

215
00:11:30,000 --> 00:11:38,130
pot which but the<font color="#E5E5E5"> default implementation</font>

216
00:11:35,130 --> 00:11:41,390
<font color="#CCCCCC">will even in a sampling case</font><font color="#E5E5E5"> it will do</font>

217
00:11:38,130 --> 00:11:45,120
a<font color="#E5E5E5"> full table scan so if it has only</font>

218
00:11:41,390 --> 00:11:48,060
enough memory to<font color="#CCCCCC"> full 20%</font><font color="#E5E5E5"> of the</font><font color="#CCCCCC"> value</font>

219
00:11:45,120 --> 00:11:51,570
it will<font color="#CCCCCC"> read the entire table but just</font>

220
00:11:48,060 --> 00:11:53,219
pick every faith hello<font color="#E5E5E5"> but it's possible</font>

221
00:11:51,570 --> 00:11:56,130
for storage engine to implement a more

222
00:11:53,220 --> 00:11:58,950
efficient sampling so in for the case we

223
00:11:56,130 --> 00:12:01,080
want<font color="#CCCCCC"> InnoDB to implement this in a way</font>

224
00:11:58,950 --> 00:12:03,930
<font color="#CCCCCC">that it instead of reading</font><font color="#E5E5E5"> every</font><font color="#CCCCCC"> 5th</font>

225
00:12:01,080 --> 00:12:13,110
folded<font color="#CCCCCC"> with every 5th page because that</font>

226
00:12:03,930 --> 00:12:15,270
<font color="#CCCCCC">would be much</font><font color="#E5E5E5"> more efficient the</font><font color="#CCCCCC"> Jason</font>

227
00:12:13,110 --> 00:12:17,730
history the histogram is stored<font color="#E5E5E5"> in</font>

228
00:12:15,270 --> 00:12:19,560
adjacent<font color="#E5E5E5"> column in data dictionary and</font>

229
00:12:17,730 --> 00:12:24,600
<font color="#CCCCCC">you</font><font color="#E5E5E5"> can use an information schema table</font>

230
00:12:19,560 --> 00:12:28,829
of you to inspect the histogram so I

231
00:12:24,600 --> 00:12:30,840
just<font color="#CCCCCC"> specify</font><font color="#E5E5E5"> I select from the column</font>

232
00:12:28,830 --> 00:12:32,970
statistics<font color="#E5E5E5"> view of</font><font color="#CCCCCC"> the information</font>

233
00:12:30,840 --> 00:12:34,740
<font color="#CCCCCC">schema</font><font color="#E5E5E5"> and then I specify the schema</font>

234
00:12:32,970 --> 00:12:37,200
name<font color="#E5E5E5"> table name and call your name to</font>

235
00:12:34,740 --> 00:12:39,450
<font color="#E5E5E5">get the histogram for a</font><font color="#CCCCCC"> specific column</font>

236
00:12:37,200 --> 00:12:41,940
and then<font color="#CCCCCC"> you will see something like</font>

237
00:12:39,450 --> 00:12:44,520
this<font color="#E5E5E5"> you</font><font color="#CCCCCC"> will</font><font color="#E5E5E5"> see the buckets</font>

238
00:12:41,940 --> 00:12:46,350
this guy's<font color="#E5E5E5"> the histogram type is a</font>

239
00:12:44,520 --> 00:12:51,290
singleton<font color="#E5E5E5"> so there will be two values</font>

240
00:12:46,350 --> 00:12:54,630
<font color="#CCCCCC">the value of for the bucket</font><font color="#E5E5E5"> and the</font>

241
00:12:51,290 --> 00:12:56,069
cumulative<font color="#E5E5E5"> frequency for this bucket</font><font color="#CCCCCC"> you</font>

242
00:12:54,630 --> 00:12:58,560
see they are increasing all the<font color="#E5E5E5"> way to</font>

243
00:12:56,070 --> 00:13:02,280
the<font color="#CCCCCC"> to one since it's a cumulative LD</font>

244
00:12:58,560 --> 00:13:04,979
and you see the data<font color="#E5E5E5"> type</font><font color="#CCCCCC"> how many null</font>

245
00:13:02,280 --> 00:13:05,850
values<font color="#E5E5E5"> they are for this column the</font>

246
00:13:04,980 --> 00:13:07,560
collation idea

247
00:13:05,850 --> 00:13:09,510
there's not matter when it's integer<font color="#E5E5E5"> but</font>

248
00:13:07,560 --> 00:13:12,959
if the string it tells you how<font color="#CCCCCC"> it</font>

249
00:13:09,510 --> 00:13:15,960
compares values and<font color="#E5E5E5"> then</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> you last</font>

250
00:13:12,960 --> 00:13:17,910
updated histogram so there's no

251
00:13:15,960 --> 00:13:19,800
<font color="#CCCCCC">automatic update so</font><font color="#E5E5E5"> you know if you want</font>

252
00:13:17,910 --> 00:13:21,240
to<font color="#E5E5E5"> refresh because your values have</font>

253
00:13:19,800 --> 00:13:25,439
changed or<font color="#CCCCCC"> something you need to do</font>

254
00:13:21,240 --> 00:13:28,110
another<font color="#E5E5E5"> analyze table a command here you</font>

255
00:13:25,440 --> 00:13:29,510
can see the sampling rate<font color="#E5E5E5"> so what you</font>

256
00:13:28,110 --> 00:13:33,780
could<font color="#E5E5E5"> do if</font><font color="#CCCCCC"> you want</font><font color="#E5E5E5"> to have a full</font>

257
00:13:29,510 --> 00:13:35,250
table sample<font color="#E5E5E5"> a full histogram</font><font color="#CCCCCC"> over the</font>

258
00:13:33,780 --> 00:13:39,420
whole<font color="#E5E5E5"> table you can see</font><font color="#CCCCCC"> all</font><font color="#E5E5E5"> which used</font>

259
00:13:35,250 --> 00:13:42,420
<font color="#CCCCCC">only 20% let's increase my memory usage</font>

260
00:13:39,420 --> 00:13:44,849
to go to 100 megabyte and you can<font color="#E5E5E5"> sample</font>

261
00:13:42,420 --> 00:13:47,189
an entire<font color="#E5E5E5"> or you can base</font><font color="#CCCCCC"> it on</font><font color="#E5E5E5"> the</font>

262
00:13:44,850 --> 00:13:51,780
<font color="#E5E5E5">entire thing</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> the number of</font><font color="#CCCCCC"> Beck is</font>

263
00:13:47,190 --> 00:13:55,950
specified I didn't<font color="#E5E5E5"> forgot to mention</font>

264
00:13:51,780 --> 00:13:57,780
<font color="#E5E5E5">that and a syntax you</font><font color="#CCCCCC"> had this with</font><font color="#E5E5E5"> and</font>

265
00:13:55,950 --> 00:14:00,360
<font color="#CCCCCC">Backus where you can specify how many</font>

266
00:13:57,780 --> 00:14:03,329
buckets<font color="#CCCCCC"> use and this part is added</font>

267
00:14:00,360 --> 00:14:07,230
because<font color="#E5E5E5"> when you do a MySQL</font><font color="#CCCCCC"> pump or dump</font>

268
00:14:03,330 --> 00:14:10,770
<font color="#E5E5E5">it</font><font color="#CCCCCC"> will actually put the analyze table</font>

269
00:14:07,230 --> 00:14:13,500
commands<font color="#E5E5E5"> into the dump file so that</font><font color="#CCCCCC"> when</font>

270
00:14:10,770 --> 00:14:15,300
you run it I load it<font color="#CCCCCC"> again you</font><font color="#E5E5E5"> will</font>

271
00:14:13,500 --> 00:14:17,910
actually get<font color="#CCCCCC"> the recreated the</font>

272
00:14:15,300 --> 00:14:21,540
histograms<font color="#E5E5E5"> so that's why it's those</font>

273
00:14:17,910 --> 00:14:23,339
<font color="#E5E5E5">though the original specification</font>

274
00:14:21,540 --> 00:14:25,349
because<font color="#E5E5E5"> if this is a</font><font color="#CCCCCC"> single tone it's</font>

275
00:14:23,340 --> 00:14:27,930
<font color="#E5E5E5">like here it's how only have seven</font>

276
00:14:25,350 --> 00:14:30,000
buckets<font color="#E5E5E5"> but you if you specified it with</font>

277
00:14:27,930 --> 00:14:32,790
thousand and twenty four<font color="#E5E5E5"> and you the</font>

278
00:14:30,000 --> 00:14:35,190
data has later changed<font color="#E5E5E5"> you wanted to</font>

279
00:14:32,790 --> 00:14:40,530
have it<font color="#CCCCCC"> to it to still be a singing from</font>

280
00:14:35,190 --> 00:14:43,560
for<font color="#CCCCCC"> example and we can use this</font>

281
00:14:40,530 --> 00:14:46,860
information schema<font color="#CCCCCC"> Oh</font>

282
00:14:43,560 --> 00:14:48,750
now first four strings<font color="#E5E5E5"> you consider</font>

283
00:14:46,860 --> 00:14:50,910
maximum<font color="#E5E5E5"> for the two characters so if you</font>

284
00:14:48,750 --> 00:14:53,430
<font color="#CCCCCC">have very</font><font color="#E5E5E5"> long strings and they all have</font>

285
00:14:50,910 --> 00:14:57,290
the<font color="#E5E5E5"> first for the two cutters are the</font>

286
00:14:53,430 --> 00:15:01,010
same then this is<font color="#E5E5E5"> kind of not</font><font color="#CCCCCC"> the best</font>

287
00:14:57,290 --> 00:15:04,439
but<font color="#E5E5E5"> and they are basics before encoded</font>

288
00:15:01,010 --> 00:15:06,900
this is because what<font color="#E5E5E5"> is stored</font><font color="#CCCCCC"> in data</font>

289
00:15:04,440 --> 00:15:10,590
dictionary<font color="#CCCCCC"> injection</font><font color="#E5E5E5"> in general is do t</font>

290
00:15:06,900 --> 00:15:12,390
f8 but you can in theory have any

291
00:15:10,590 --> 00:15:16,380
character<font color="#E5E5E5"> set here</font><font color="#CCCCCC"> so it's not</font>

292
00:15:12,390 --> 00:15:19,900
necessarily valid<font color="#CCCCCC"> Jason valid duty of</font>

293
00:15:16,380 --> 00:15:22,330
<font color="#CCCCCC">eight character strings that</font><font color="#E5E5E5"> your store</font>

294
00:15:19,900 --> 00:15:25,480
so we have to decode<font color="#E5E5E5"> them in order to</font>

295
00:15:22,330 --> 00:15:28,060
<font color="#CCCCCC">see strings</font><font color="#E5E5E5"> and there's a what I would</font>

296
00:15:25,480 --> 00:15:31,060
<font color="#CCCCCC">think it's about</font><font color="#E5E5E5"> I think we will fix</font>

297
00:15:28,060 --> 00:15:32,800
<font color="#CCCCCC">before the G is</font><font color="#E5E5E5"> there's some prefix here</font>

298
00:15:31,060 --> 00:15:35,410
<font color="#E5E5E5">that should probably be hidden from you</font>

299
00:15:32,800 --> 00:15:39,250
so but the basic thing here is that<font color="#E5E5E5"> I</font>

300
00:15:35,410 --> 00:15:42,250
use<font color="#E5E5E5"> the JSON table function in a Tercero</font>

301
00:15:39,250 --> 00:15:45,600
<font color="#E5E5E5">to convert these histograms</font><font color="#CCCCCC"> or the</font>

302
00:15:42,250 --> 00:15:51,610
<font color="#CCCCCC">brackets array into a relational table</font>

303
00:15:45,600 --> 00:15:53,830
so this way you<font color="#CCCCCC"> can you can get the</font>

304
00:15:51,610 --> 00:15:56,410
table up with the values and<font color="#CCCCCC"> you can see</font>

305
00:15:53,830 --> 00:15:58,480
here the cumulative frequency but if you

306
00:15:56,410 --> 00:16:02,319
want to see the actual<font color="#CCCCCC"> frequency of each</font>

307
00:15:58,480 --> 00:16:06,130
packet you can<font color="#CCCCCC"> use a window function as</font>

308
00:16:02,320 --> 00:16:08,950
<font color="#CCCCCC">Sergey talked about earlier you take the</font>

309
00:16:06,130 --> 00:16:11,080
value<font color="#CCCCCC"> of this packet and then you</font>

310
00:16:08,950 --> 00:16:13,030
subtract the values of the<font color="#E5E5E5"> previous</font>

311
00:16:11,080 --> 00:16:16,210
<font color="#E5E5E5">bucket that was the lag function it</font>

312
00:16:13,030 --> 00:16:21,730
refers to the first previous in this

313
00:16:16,210 --> 00:16:23,980
case and since I know this array<font color="#CCCCCC"> is</font>

314
00:16:21,730 --> 00:16:26,500
already sorted<font color="#CCCCCC"> I don't need something</font><font color="#E5E5E5"> in</font>

315
00:16:23,980 --> 00:16:29,050
the<font color="#CCCCCC"> / closer and that way you can</font>

316
00:16:26,500 --> 00:16:32,910
actually<font color="#E5E5E5"> see that we have for this order</font>

317
00:16:29,050 --> 00:16:37,359
<font color="#E5E5E5">status column we have 48.6%</font><font color="#CCCCCC"> F's and</font>

318
00:16:32,910 --> 00:16:39,880
48.8%<font color="#CCCCCC"> o's and just 2.6 percent peace for</font>

319
00:16:37,360 --> 00:16:42,430
example<font color="#E5E5E5"> and that's a typical call Youm</font>

320
00:16:39,880 --> 00:16:49,840
where you want<font color="#E5E5E5"> a singleton histogram</font>

321
00:16:42,430 --> 00:16:52,870
<font color="#CCCCCC">because whether if they have something</font>

322
00:16:49,840 --> 00:16:54,370
equals<font color="#CCCCCC"> F here and you the optimizer</font>

323
00:16:52,870 --> 00:16:57,460
without a histogram and<font color="#CCCCCC"> I think this is</font>

324
00:16:54,370 --> 00:17:00,940
really<font color="#E5E5E5"> selective it's it's not because</font>

325
00:16:57,460 --> 00:17:10,209
it's like<font color="#E5E5E5"> 50%</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> the rows have this</font>

326
00:17:00,940 --> 00:17:15,459
<font color="#E5E5E5">value so how are histograms used and the</font>

327
00:17:10,209 --> 00:17:19,209
most most important use case is for when

328
00:17:15,459 --> 00:17:21,670
the<font color="#E5E5E5"> optimizer want to optimize joint</font>

329
00:17:19,209 --> 00:17:23,980
queries<font color="#E5E5E5"> because I say we do</font><font color="#CCCCCC"> something on</font>

330
00:17:21,670 --> 00:17:26,829
the first table<font color="#E5E5E5"> and then there's some</font>

331
00:17:23,980 --> 00:17:29,560
filtering here<font color="#CCCCCC"> and what's left</font><font color="#E5E5E5"> goes into</font>

332
00:17:26,829 --> 00:17:31,629
lookups into the next table and it's

333
00:17:29,560 --> 00:17:33,429
this pretty hair that's important to

334
00:17:31,630 --> 00:17:36,970
know<font color="#CCCCCC"> because then you would know</font>

335
00:17:33,430 --> 00:17:42,100
<font color="#E5E5E5">how costly is this next step so if this</font>

336
00:17:36,970 --> 00:17:44,800
fit this problem one<font color="#CCCCCC"> of the major issues</font>

337
00:17:42,100 --> 00:17:47,350
<font color="#E5E5E5">with money</font><font color="#CCCCCC"> query plans is that the</font>

338
00:17:44,800 --> 00:17:49,270
optimizer does<font color="#E5E5E5"> not get the cardinality</font>

339
00:17:47,350 --> 00:17:51,280
right there it does not<font color="#E5E5E5"> estimate the</font>

340
00:17:49,270 --> 00:17:56,800
effects of the intermediate steps of a

341
00:17:51,280 --> 00:17:59,920
joint and they are as I've already

342
00:17:56,800 --> 00:18:04,840
<font color="#E5E5E5">touched upon some ways the optimizer get</font>

343
00:17:59,920 --> 00:18:07,960
this estimate in<font color="#CCCCCC"> my SQL 5:7 it could</font>

344
00:18:04,840 --> 00:18:09,939
base it<font color="#CCCCCC"> on the range estimates that I</font>

345
00:18:07,960 --> 00:18:12,790
talked about earlier earlier the way you

346
00:18:09,940 --> 00:18:14,740
do DITA or dives into the<font color="#E5E5E5"> index and then</font>

347
00:18:12,790 --> 00:18:16,659
you compute<font color="#E5E5E5"> the distance there's also</font>

348
00:18:14,740 --> 00:18:19,560
index statistics what you get with the

349
00:18:16,660 --> 00:18:22,720
normal<font color="#CCCCCC"> analyze cran</font><font color="#E5E5E5"> a table command and</font>

350
00:18:19,560 --> 00:18:24,730
we added<font color="#CCCCCC"> the 5 Series on 5/7 some</font>

351
00:18:22,720 --> 00:18:27,660
estimates here that said that if it's<font color="#E5E5E5"> a</font>

352
00:18:24,730 --> 00:18:31,540
<font color="#CCCCCC">leek</font><font color="#E5E5E5"> equality it's</font><font color="#CCCCCC"> 10 percent</font><font color="#E5E5E5"> if it's</font>

353
00:18:27,660 --> 00:18:35,440
some less than<font color="#E5E5E5"> and</font><font color="#CCCCCC"> so it's</font><font color="#E5E5E5"> one third</font><font color="#CCCCCC"> and</font>

354
00:18:31,540 --> 00:18:37,899
so on<font color="#CCCCCC"> just</font><font color="#E5E5E5"> to have some estimates here</font>

355
00:18:35,440 --> 00:18:41,020
because some filtering is better than no

356
00:18:37,900 --> 00:18:42,730
filtering often if you<font color="#E5E5E5"> have one table</font>

357
00:18:41,020 --> 00:18:44,980
with some<font color="#E5E5E5"> filtering and</font><font color="#CCCCCC"> one table</font><font color="#E5E5E5"> about</font>

358
00:18:42,730 --> 00:18:48,820
<font color="#E5E5E5">any you</font><font color="#CCCCCC"> would prefer to</font><font color="#E5E5E5"> start with</font><font color="#CCCCCC"> one</font>

359
00:18:44,980 --> 00:18:51,370
with some filtering<font color="#E5E5E5"> what's different now</font>

360
00:18:48,820 --> 00:18:52,990
is<font color="#CCCCCC"> that you</font><font color="#E5E5E5"> have histograms here still</font>

361
00:18:51,370 --> 00:18:56,770
<font color="#E5E5E5">the range estimates are the most</font>

362
00:18:52,990 --> 00:19:00,010
accurate<font color="#E5E5E5"> but instance is much better</font>

363
00:18:56,770 --> 00:19:02,020
than estimates<font color="#E5E5E5"> and this is why histogram</font>

364
00:19:00,010 --> 00:19:04,360
is not that important in<font color="#E5E5E5"> MySQL as in</font>

365
00:19:02,020 --> 00:19:07,480
many other databases<font color="#E5E5E5"> but because most</font>

366
00:19:04,360 --> 00:19:12,639
<font color="#CCCCCC">databases</font><font color="#E5E5E5"> does not do this range has to</font>

367
00:19:07,480 --> 00:19:15,460
<font color="#CCCCCC">made using an index so the use of</font>

368
00:19:12,640 --> 00:19:17,590
histograms is<font color="#CCCCCC"> mostly in my scale</font><font color="#E5E5E5"> for</font>

369
00:19:15,460 --> 00:19:21,880
columns<font color="#CCCCCC"> value or is for columns but</font>

370
00:19:17,590 --> 00:19:24,399
where you don't<font color="#E5E5E5"> have an index and so you</font>

371
00:19:21,880 --> 00:19:27,130
can<font color="#E5E5E5"> then have different ways of getting</font>

372
00:19:24,400 --> 00:19:34,540
estimates<font color="#CCCCCC"> here you have the range</font>

373
00:19:27,130 --> 00:19:36,700
estimate for this<font color="#CCCCCC"> call Youm hair if you</font>

374
00:19:34,540 --> 00:19:38,950
<font color="#CCCCCC">have an index and this</font><font color="#E5E5E5"> equality you can</font>

375
00:19:36,700 --> 00:19:40,660
use<font color="#CCCCCC"> another</font><font color="#E5E5E5"> kind</font><font color="#CCCCCC"> of statistics</font><font color="#E5E5E5"> and then</font>

376
00:19:38,950 --> 00:19:44,080
<font color="#E5E5E5">you have this guesstimate if you don't</font>

377
00:19:40,660 --> 00:19:46,690
have histograms and<font color="#E5E5E5"> then you compute the</font>

378
00:19:44,080 --> 00:19:49,270
the total<font color="#E5E5E5"> hair is if we assuming that</font>

379
00:19:46,690 --> 00:19:51,340
<font color="#E5E5E5">they</font><font color="#CCCCCC"> are not correlated this</font><font color="#E5E5E5"> a collision</font>

380
00:19:49,270 --> 00:19:54,250
<font color="#E5E5E5">so you compute the selectivity by</font>

381
00:19:51,340 --> 00:19:56,250
multiplying the different and then<font color="#E5E5E5"> you</font>

382
00:19:54,250 --> 00:19:59,770
if you add histograms here you see that

383
00:19:56,250 --> 00:20:02,170
<font color="#E5E5E5">H if you look at this</font><font color="#CCCCCC"> one-third for</font><font color="#E5E5E5"> age</font>

384
00:19:59,770 --> 00:20:04,090
greater than 21 for<font color="#CCCCCC"> in place is</font><font color="#E5E5E5"> probably</font>

385
00:20:02,170 --> 00:20:05,740
not<font color="#E5E5E5"> a</font><font color="#CCCCCC"> very good estimates but since an</font>

386
00:20:04,090 --> 00:20:08,320
optimizer does<font color="#E5E5E5"> not know what the</font><font color="#CCCCCC"> world</font>

387
00:20:05,740 --> 00:20:10,870
employee<font color="#E5E5E5"> or</font><font color="#CCCCCC"> age mean it</font><font color="#E5E5E5"> needs something</font>

388
00:20:08,320 --> 00:20:16,120
<font color="#E5E5E5">to guide it and that's the histograms in</font>

389
00:20:10,870 --> 00:20:18,820
this case so it<font color="#CCCCCC"> actually happened that</font>

390
00:20:16,120 --> 00:20:21,250
<font color="#CCCCCC">95 percent</font><font color="#E5E5E5"> of the history of</font><font color="#CCCCCC"> the</font>

391
00:20:18,820 --> 00:20:23,830
employees are older<font color="#E5E5E5"> than 21 and that</font>

392
00:20:21,250 --> 00:20:30,610
means that the selectivity computed here

393
00:20:23,830 --> 00:20:32,610
goes up<font color="#E5E5E5"> from 0.01 to 0.03 and then here</font>

394
00:20:30,610 --> 00:20:35,320
<font color="#CCCCCC">here you</font><font color="#E5E5E5"> see we had still have a</font><font color="#CCCCCC"> one</font>

395
00:20:32,610 --> 00:20:38,020
less that is a guest man and<font color="#CCCCCC"> ten</font><font color="#E5E5E5"> percent</font>

396
00:20:35,320 --> 00:20:40,720
<font color="#E5E5E5">is probably too frequent even if</font><font color="#CCCCCC"> Joan</font><font color="#E5E5E5"> is</font>

397
00:20:38,020 --> 00:20:44,370
a freaking name and you could add a

398
00:20:40,720 --> 00:20:48,160
histogram<font color="#E5E5E5"> here too but it's not</font>

399
00:20:44,370 --> 00:20:50,350
necessarily<font color="#E5E5E5"> that good since you probably</font>

400
00:20:48,160 --> 00:20:51,940
have too many<font color="#E5E5E5"> names to make a singleton</font>

401
00:20:50,350 --> 00:20:56,889
histogram so they call it<font color="#E5E5E5"> it will</font>

402
00:20:51,940 --> 00:20:58,810
probably<font color="#E5E5E5"> not</font><font color="#CCCCCC"> be that accurate</font><font color="#E5E5E5"> computed</font>

403
00:20:56,890 --> 00:21:01,030
<font color="#E5E5E5">so in this case you probably should add</font>

404
00:20:58,810 --> 00:21:05,260
an index or name<font color="#E5E5E5"> because if you look at</font>

405
00:21:01,030 --> 00:21:07,060
these conditions there it's<font color="#E5E5E5"> actually the</font>

406
00:21:05,260 --> 00:21:09,190
<font color="#E5E5E5">name that is the</font><font color="#CCCCCC"> most</font><font color="#E5E5E5"> selective</font><font color="#CCCCCC"> on so</font>

407
00:21:07,060 --> 00:21:10,960
actually in this<font color="#CCCCCC"> case you probably</font><font color="#E5E5E5"> want</font>

408
00:21:09,190 --> 00:21:14,590
to<font color="#E5E5E5"> start with the employee table and</font>

409
00:21:10,960 --> 00:21:17,440
filter out on own name using<font color="#CCCCCC"> an index</font>

410
00:21:14,590 --> 00:21:20,770
the other ones here is more it's<font color="#E5E5E5"> not</font>

411
00:21:17,440 --> 00:21:22,780
that selective and<font color="#E5E5E5"> so an index might not</font>

412
00:21:20,770 --> 00:21:27,760
be useful<font color="#CCCCCC"> and then you could use a</font>

413
00:21:22,780 --> 00:21:35,639
histogram<font color="#E5E5E5"> instead here's an example</font>

414
00:21:27,760 --> 00:21:38,260
<font color="#E5E5E5">about we use histograms this is this is</font>

415
00:21:35,640 --> 00:21:40,120
still an<font color="#CCCCCC"> H column and in this case it's</font>

416
00:21:38,260 --> 00:21:41,920
not employees but the entire population

417
00:21:40,120 --> 00:21:44,350
so<font color="#CCCCCC"> you see this is a neck we</font><font color="#E5E5E5"> hide</font>

418
00:21:41,920 --> 00:21:46,060
<font color="#E5E5E5">because you have</font><font color="#CCCCCC"> ten</font><font color="#E5E5E5"> buckets and it's</font>

419
00:21:44,350 --> 00:21:50,469
<font color="#E5E5E5">around ten</font><font color="#CCCCCC"> percent in</font><font color="#E5E5E5"> each of the</font>

420
00:21:46,060 --> 00:21:52,870
<font color="#CCCCCC">buckets</font><font color="#E5E5E5"> and most of them are like about</font>

421
00:21:50,470 --> 00:21:55,450
seven or eight<font color="#CCCCCC"> years in each bucket</font>

422
00:21:52,870 --> 00:21:57,540
<font color="#E5E5E5">except the last</font><font color="#CCCCCC"> one that for natural</font>

423
00:21:55,450 --> 00:22:01,500
causes<font color="#E5E5E5"> is a bit wider</font>

424
00:21:57,540 --> 00:22:03,139
<font color="#CCCCCC">in range but</font><font color="#E5E5E5"> and we have stopped for</font>

425
00:22:01,500 --> 00:22:09,630
each<font color="#E5E5E5"> packet we have the cumulative</font>

426
00:22:03,140 --> 00:22:12,540
cumulative<font color="#CCCCCC"> the frequency stored and to</font>

427
00:22:09,630 --> 00:22:14,730
show you why<font color="#CCCCCC"> this issue's most useful</font>

428
00:22:12,540 --> 00:22:17,700
<font color="#E5E5E5">and I can go through</font><font color="#CCCCCC"> an example here</font>

429
00:22:14,730 --> 00:22:21,150
where<font color="#E5E5E5"> we we are looking for all that are</font>

430
00:22:17,700 --> 00:22:24,770
21 years<font color="#E5E5E5"> and below first we do is we</font>

431
00:22:21,150 --> 00:22:28,710
identify<font color="#E5E5E5"> the bucket for 21 is this one</font>

432
00:22:24,770 --> 00:22:32,010
then they to compute the selectivity<font color="#E5E5E5"> the</font>

433
00:22:28,710 --> 00:22:34,560
first check they act the<font color="#CCCCCC"> cumulative</font>

434
00:22:32,010 --> 00:22:39,180
frequency of the previous packet which

435
00:22:34,560 --> 00:22:43,700
<font color="#CCCCCC">is a twenty point three percent which is</font>

436
00:22:39,180 --> 00:22:47,580
<font color="#E5E5E5">and all these we know that these are</font>

437
00:22:43,700 --> 00:22:49,680
younger<font color="#E5E5E5"> than 21</font><font color="#CCCCCC"> and since we have the</font>

438
00:22:47,580 --> 00:22:51,689
cumulative<font color="#CCCCCC"> frequency we don't have to</font>

439
00:22:49,680 --> 00:22:54,450
check and<font color="#CCCCCC"> the frequency in</font><font color="#E5E5E5"> this book it</font>

440
00:22:51,690 --> 00:22:56,220
is<font color="#E5E5E5"> enough</font><font color="#CCCCCC"> to check the</font><font color="#E5E5E5"> previous one we</font>

441
00:22:54,450 --> 00:22:58,140
know that we have at<font color="#E5E5E5"> least</font><font color="#CCCCCC"> twenty</font>

442
00:22:56,220 --> 00:23:00,210
percent<font color="#CCCCCC"> but then we need to figure out</font>

443
00:22:58,140 --> 00:23:04,220
how large part<font color="#E5E5E5"> of this bucket should go</font>

444
00:23:00,210 --> 00:23:07,500
<font color="#CCCCCC">into this condition</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> let me check the</font>

445
00:23:04,220 --> 00:23:10,410
frequency<font color="#E5E5E5"> for that</font><font color="#CCCCCC"> packet</font><font color="#E5E5E5"> but then we</font>

446
00:23:07,500 --> 00:23:13,200
need to take into<font color="#CCCCCC"> account that 21 is</font>

447
00:23:10,410 --> 00:23:16,140
like<font color="#E5E5E5"> less</font><font color="#CCCCCC"> than equal to</font><font color="#E5E5E5"> 21 is</font><font color="#CCCCCC"> like five</font>

448
00:23:13,200 --> 00:23:21,600
<font color="#CCCCCC">oh eight</font><font color="#E5E5E5"> of eight values in</font><font color="#CCCCCC"> that packet</font>

449
00:23:16,140 --> 00:23:24,390
so you add that fraction to<font color="#E5E5E5"> the safety</font>

450
00:23:21,600 --> 00:23:28,379
<font color="#E5E5E5">and</font><font color="#CCCCCC"> you</font><font color="#E5E5E5"> ends up with point two six seven</font>

451
00:23:24,390 --> 00:23:30,540
as the<font color="#E5E5E5"> filtering effect of this</font>

452
00:23:28,380 --> 00:23:35,660
condition and<font color="#E5E5E5"> if you want the different</font>

453
00:23:30,540 --> 00:23:35,659
the opposite<font color="#E5E5E5"> you just do one minus the</font>

454
00:23:36,080 --> 00:23:41,699
the other the previous one so<font color="#CCCCCC"> we get</font>

455
00:23:38,820 --> 00:23:47,970
that<font color="#CCCCCC"> seven three percent is older than</font>

456
00:23:41,700 --> 00:23:50,940
21 another<font color="#CCCCCC"> example of a query this is a</font>

457
00:23:47,970 --> 00:23:55,200
grave of the<font color="#E5E5E5"> db2 three benchmark where</font>

458
00:23:50,940 --> 00:23:56,580
you have I don't want it you<font color="#CCCCCC"> don't need</font>

459
00:23:55,200 --> 00:23:58,110
<font color="#CCCCCC">to understand</font><font color="#E5E5E5"> attack</font><font color="#CCCCCC"> where it's called a</font>

460
00:23:56,580 --> 00:24:03,409
volume<font color="#CCCCCC"> shipping for here actually what</font>

461
00:23:58,110 --> 00:24:07,409
it does it it calculates the revenue<font color="#E5E5E5"> of</font>

462
00:24:03,410 --> 00:24:10,850
goods<font color="#E5E5E5"> going from suppliers in Russia to</font>

463
00:24:07,410 --> 00:24:13,410
customers and<font color="#E5E5E5"> France and vice versa</font>

464
00:24:10,850 --> 00:24:16,409
and we don't<font color="#E5E5E5"> have an index on the name</font>

465
00:24:13,410 --> 00:24:20,340
<font color="#E5E5E5">and as I said</font><font color="#CCCCCC"> earlier if you would be</font>

466
00:24:16,410 --> 00:24:22,710
guessing<font color="#E5E5E5"> it would say that</font><font color="#CCCCCC"> 10% would be</font>

467
00:24:20,340 --> 00:24:26,370
Russia and<font color="#CCCCCC"> 10% would be France which</font>

468
00:24:22,710 --> 00:24:28,890
probably is not accurate because<font color="#E5E5E5"> Nina</font>

469
00:24:26,370 --> 00:24:33,959
<font color="#CCCCCC">Russia there are</font><font color="#E5E5E5"> more than 10 countries</font>

470
00:24:28,890 --> 00:24:37,080
<font color="#CCCCCC">in the world</font><font color="#E5E5E5"> without his</font><font color="#CCCCCC"> gun</font><font color="#E5E5E5"> to get this</font>

471
00:24:33,960 --> 00:24:38,940
plan<font color="#E5E5E5"> we stopped with a full table scan I</font>

472
00:24:37,080 --> 00:24:41,280
want normal joint<font color="#CCCCCC"> planned</font><font color="#E5E5E5"> stuff</font><font color="#CCCCCC"> that a</font>

473
00:24:38,940 --> 00:24:44,280
full table scan or<font color="#CCCCCC"> a</font><font color="#E5E5E5"> range get scan and</font>

474
00:24:41,280 --> 00:24:46,980
then you do lookups into each<font color="#CCCCCC"> table</font><font color="#E5E5E5"> in a</font>

475
00:24:44,280 --> 00:24:49,230
secondary index<font color="#E5E5E5"> or a primary index</font><font color="#CCCCCC"> all</font>

476
00:24:46,980 --> 00:24:52,470
the way to<font color="#E5E5E5"> have chained together all the</font>

477
00:24:49,230 --> 00:24:55,590
tables<font color="#E5E5E5"> in this case that means that you</font>

478
00:24:52,470 --> 00:24:58,320
get like eight<font color="#E5E5E5"> hundred</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> fifty five</font>

479
00:24:55,590 --> 00:25:03,389
thousand primary key lookups<font color="#E5E5E5"> into the</font>

480
00:24:58,320 --> 00:25:05,700
other nation table but then you add his

481
00:25:03,390 --> 00:25:08,340
<font color="#E5E5E5">grant</font><font color="#CCCCCC"> to this you see that</font><font color="#E5E5E5"> there's a</font>

482
00:25:05,700 --> 00:25:11,940
very<font color="#E5E5E5"> few combination here so actually</font>

483
00:25:08,340 --> 00:25:15,090
it's better to just combine these you

484
00:25:11,940 --> 00:25:19,590
know<font color="#E5E5E5"> France and</font><font color="#CCCCCC"> Russia</font><font color="#E5E5E5"> early on and then</font>

485
00:25:15,090 --> 00:25:21,990
you<font color="#E5E5E5"> just do you avoid thousands of</font>

486
00:25:19,590 --> 00:25:24,540
primary key lookups in the final table

487
00:25:21,990 --> 00:25:26,400
<font color="#E5E5E5">that you will otherwise have and if you</font>

488
00:25:24,540 --> 00:25:29,970
look at the performance<font color="#CCCCCC"> here we see that</font>

489
00:25:26,400 --> 00:25:32,610
not<font color="#E5E5E5"> this bigger is in improvement as in</font>

490
00:25:29,970 --> 00:25:34,440
the first<font color="#CCCCCC"> example but</font><font color="#E5E5E5"> you see that you</font>

491
00:25:32,610 --> 00:25:36,810
go gone from one<font color="#E5E5E5"> point seven to one</font>

492
00:25:34,440 --> 00:25:41,880
point<font color="#E5E5E5"> three five seconds on something</font>

493
00:25:36,810 --> 00:25:45,720
like<font color="#CCCCCC"> that so to complete with some</font>

494
00:25:41,880 --> 00:25:51,960
advice<font color="#CCCCCC"> sir when should you create</font>

495
00:25:45,720 --> 00:25:54,750
histograms<font color="#E5E5E5"> and</font><font color="#CCCCCC"> it's</font><font color="#E5E5E5"> useful as I said</font><font color="#CCCCCC"> for</font>

496
00:25:51,960 --> 00:25:56,820
<font color="#CCCCCC">khorium</font><font color="#E5E5E5"> for columns</font><font color="#CCCCCC"> that are not indexed</font>

497
00:25:54,750 --> 00:26:00,600
of all columns<font color="#E5E5E5"> that not are</font><font color="#CCCCCC"> not the</font>

498
00:25:56,820 --> 00:26:03,179
first column<font color="#CCCCCC"> on any index because if you</font>

499
00:26:00,600 --> 00:26:05,480
have<font color="#E5E5E5"> like two</font><font color="#CCCCCC"> column index that there's</font>

500
00:26:03,180 --> 00:26:08,790
no way for<font color="#CCCCCC"> the optimizer to do this</font>

501
00:26:05,480 --> 00:26:13,230
index dives in order to find the values

502
00:26:08,790 --> 00:26:14,909
for<font color="#E5E5E5"> that column and it's used in</font>

503
00:26:13,230 --> 00:26:18,180
addition<font color="#E5E5E5"> to join queries which is the</font>

504
00:26:14,910 --> 00:26:19,950
most important it's also useful<font color="#E5E5E5"> for case</font>

505
00:26:18,180 --> 00:26:23,280
where you have in some<font color="#E5E5E5"> phrase because</font>

506
00:26:19,950 --> 00:26:25,980
<font color="#E5E5E5">there we try to estimate the size of the</font>

507
00:26:23,280 --> 00:26:27,830
<font color="#E5E5E5">and so on and also in for single table</font>

508
00:26:25,980 --> 00:26:32,870
queries if you have order by limit

509
00:26:27,830 --> 00:26:35,850
<font color="#E5E5E5">because then you have</font><font color="#CCCCCC"> the choice of</font>

510
00:26:32,870 --> 00:26:38,340
ordering the<font color="#CCCCCC"> entire</font><font color="#E5E5E5"> result and then do</font>

511
00:26:35,850 --> 00:26:40,830
limit<font color="#E5E5E5"> or use some index that are already</font>

512
00:26:38,340 --> 00:26:43,620
<font color="#E5E5E5">ordered but in order to understand</font>

513
00:26:40,830 --> 00:26:46,740
whether that is performant<font color="#CCCCCC"> or not you</font>

514
00:26:43,620 --> 00:26:48,389
need<font color="#E5E5E5"> to know how long how far into the</font>

515
00:26:46,740 --> 00:26:51,540
index do you need to<font color="#E5E5E5"> scan in</font><font color="#CCCCCC"> order to</font>

516
00:26:48,390 --> 00:26:54,600
find enough rose for your limit and<font color="#E5E5E5"> then</font>

517
00:26:51,540 --> 00:26:56,700
the filtering estimate is important the

518
00:26:54,600 --> 00:26:58,860
best<font color="#E5E5E5"> fit by far is if you have low</font>

519
00:26:56,700 --> 00:27:01,080
cardinality columns like<font color="#CCCCCC"> gender or other</font>

520
00:26:58,860 --> 00:27:07,500
<font color="#E5E5E5">stages</font><font color="#CCCCCC"> or day a week or so because</font><font color="#E5E5E5"> then</font>

521
00:27:01,080 --> 00:27:11,159
the and<font color="#E5E5E5"> okay I have to end</font><font color="#CCCCCC"> it says but I</font>

522
00:27:07,500 --> 00:27:13,290
only have this<font color="#CCCCCC"> one left</font><font color="#E5E5E5"> if you have an</font>

523
00:27:11,160 --> 00:27:15,750
index no use<font color="#CCCCCC"> if it's not</font><font color="#E5E5E5"> used in the</font>

524
00:27:13,290 --> 00:27:17,790
where clause<font color="#E5E5E5"> forget about histograms how</font>

525
00:27:15,750 --> 00:27:20,940
many buckets<font color="#E5E5E5"> if you can get a single</font>

526
00:27:17,790 --> 00:27:22,740
<font color="#CCCCCC">term use as many</font><font color="#E5E5E5"> as</font><font color="#CCCCCC"> you need if not our</font>

527
00:27:20,940 --> 00:27:24,900
<font color="#CCCCCC">guess 100 should</font><font color="#E5E5E5"> be enough because then</font>

528
00:27:22,740 --> 00:27:27,720
you have<font color="#E5E5E5"> like a</font><font color="#CCCCCC"> Garn out here 1% which</font>

529
00:27:24,900 --> 00:27:29,400
should be useful<font color="#E5E5E5"> more information</font>

530
00:27:27,720 --> 00:27:31,500
there's a nice blog<font color="#CCCCCC"> by by colleague</font>

531
00:27:29,400 --> 00:27:33,960
about<font color="#E5E5E5"> this that you can look up the</font>

532
00:27:31,500 --> 00:27:35,550
<font color="#E5E5E5">slides are</font><font color="#CCCCCC"> already on the forum page so</font>

533
00:27:33,960 --> 00:27:37,760
you can<font color="#E5E5E5"> get</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> all that</font><font color="#CCCCCC"> information from</font>

534
00:27:35,550 --> 00:27:37,760
<font color="#CCCCCC">there</font>

535
00:27:38,660 --> 00:27:41,759
[Applause]

536
00:27:42,060 --> 00:27:52,179
show me yes it's stored<font color="#E5E5E5"> in this thing in</font>

537
00:27:48,850 --> 00:27:55,090
data dictionary and it's it's it's what

538
00:27:52,180 --> 00:27:57,340
the new<font color="#E5E5E5"> a toad so data dictionary made</font>

539
00:27:55,090 --> 00:28:00,129
it's<font color="#CCCCCC"> very</font><font color="#E5E5E5"> import to make very easy</font><font color="#CCCCCC"> to</font>

540
00:27:57,340 --> 00:28:01,570
make<font color="#CCCCCC"> a view information scheme of you</font>

541
00:28:00,130 --> 00:28:07,470
over this and they got<font color="#E5E5E5"> a lot for free</font>

542
00:28:01,570 --> 00:28:07,470
<font color="#CCCCCC">and by using</font><font color="#E5E5E5"> that yeah</font>

543
00:28:23,750 --> 00:28:33,350
so who is using<font color="#CCCCCC"> historians help with</font>

544
00:28:27,210 --> 00:28:33,350
that if differ from partitioning<font color="#CCCCCC"> Oakes's</font>

545
00:28:36,920 --> 00:28:42,800
so you want<font color="#CCCCCC"> to equal</font><font color="#E5E5E5"> equal size</font>

546
00:28:39,510 --> 00:28:42,800
partitions in some way

547
00:28:58,649 --> 00:29:01,649
yeah

548
00:29:04,499 --> 00:29:12,730
I've even<font color="#CCCCCC"> thought</font><font color="#E5E5E5"> about that</font><font color="#CCCCCC"> but</font><font color="#E5E5E5"> one</font>

549
00:29:07,059 --> 00:29:14,590
thing<font color="#E5E5E5"> I forgot to say is that if you</font>

550
00:29:12,730 --> 00:29:16,240
have<font color="#CCCCCC"> instagrams</font><font color="#E5E5E5"> they are good estimates</font>

551
00:29:14,590 --> 00:29:18,999
of your data so you can<font color="#CCCCCC"> actually instead</font>

552
00:29:16,240 --> 00:29:21,340
<font color="#E5E5E5">of doing costly queries against your</font>

553
00:29:18,999 --> 00:29:23,499
data you could actually<font color="#E5E5E5"> just do a query</font>

554
00:29:21,340 --> 00:29:26,529
the histograms in order to to get the

555
00:29:23,499 --> 00:29:41,559
sum<font color="#E5E5E5"> and you can use that you</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> use the</font>

556
00:29:26,529 --> 00:29:48,850
<font color="#CCCCCC">information schema table for is no we</font>

557
00:29:41,559 --> 00:29:50,350
don't<font color="#E5E5E5"> currently have that in order to</font>

558
00:29:48,850 --> 00:29:52,360
detect whether to<font color="#E5E5E5"> update that a</font>

559
00:29:50,350 --> 00:29:55,090
histogram<font color="#CCCCCC"> I guess you need to to keep</font>

560
00:29:52,360 --> 00:29:58,719
have some awareness<font color="#CCCCCC"> about how frequently</font>

561
00:29:55,090 --> 00:30:00,580
<font color="#E5E5E5">your a distribution change because like</font>

562
00:29:58,720 --> 00:30:02,799
in this order<font color="#CCCCCC"> state whose example had</font>

563
00:30:00,580 --> 00:30:05,110
for<font color="#E5E5E5"> example</font><font color="#CCCCCC"> they are usually</font><font color="#E5E5E5"> pretty</font>

564
00:30:02,799 --> 00:30:08,259
<font color="#E5E5E5">fixed even if you add more orders it</font>

565
00:30:05,110 --> 00:30:10,119
will probably be like<font color="#CCCCCC"> if 47% of</font><font color="#E5E5E5"> each of</font>

566
00:30:08,259 --> 00:30:14,200
the two big ones and threes in last one

567
00:30:10,119 --> 00:30:16,360
<font color="#E5E5E5">so in that case you would not need to to</font>

568
00:30:14,200 --> 00:30:19,720
update your histograms even if you<font color="#E5E5E5"> had a</font>

569
00:30:16,360 --> 00:30:21,580
lot of<font color="#E5E5E5"> more data in other cases and that</font>

570
00:30:19,720 --> 00:30:24,240
might not<font color="#CCCCCC"> be the</font><font color="#E5E5E5"> case if you have more</font>

571
00:30:21,580 --> 00:30:28,178
<font color="#E5E5E5">question for</font><font color="#CCCCCC"> Austin go to the bar within</font>

572
00:30:24,240 --> 00:30:29,080
him<font color="#E5E5E5"> appear to be very happy and it will</font>

573
00:30:28,179 --> 00:30:33,740
answer<font color="#CCCCCC"> your questions</font>

574
00:30:29,080 --> 00:30:33,740
[Applause]

