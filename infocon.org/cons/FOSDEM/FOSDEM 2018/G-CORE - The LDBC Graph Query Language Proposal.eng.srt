1
00:00:04,910 --> 00:00:10,440
Thank You<font color="#E5E5E5"> Micah</font><font color="#CCCCCC"> thought of introductions</font>

2
00:00:08,029 --> 00:00:11,760
<font color="#CCCCCC">mm</font><font color="#E5E5E5"> their arms</font><font color="#CCCCCC"> now</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> room is not</font><font color="#E5E5E5"> so</font>

3
00:00:10,440 --> 00:00:18,660
crowded anymore all the blockchain

4
00:00:11,760 --> 00:00:21,600
people<font color="#E5E5E5"> left apparently yeah so I'm going</font>

5
00:00:18,660 --> 00:00:26,160
<font color="#CCCCCC">to</font><font color="#E5E5E5"> present a great graph query language</font>

6
00:00:21,600 --> 00:00:29,779
proposal called<font color="#CCCCCC"> G core to introduce a</font>

7
00:00:26,160 --> 00:00:36,750
little<font color="#CCCCCC"> bit myself I'm a graph database</font>

8
00:00:29,779 --> 00:00:38,850
<font color="#E5E5E5">systems researcher from</font><font color="#CCCCCC"> Childress and I</font>

9
00:00:36,750 --> 00:00:41,190
did research<font color="#CCCCCC"> on graph data management</font>

10
00:00:38,850 --> 00:00:44,420
schema evolution schema flexibility

11
00:00:41,190 --> 00:00:46,980
<font color="#E5E5E5">adaptive indexing</font><font color="#CCCCCC"> and other</font><font color="#E5E5E5"> topics and</font>

12
00:00:44,420 --> 00:00:51,690
next to that more industry related

13
00:00:46,980 --> 00:00:54,870
<font color="#E5E5E5">activities are together ASAP</font><font color="#CCCCCC"> HANA graph</font>

14
00:00:51,690 --> 00:01:00,989
and the open cycle<font color="#E5E5E5"> project Stefan told</font>

15
00:00:54,870 --> 00:01:04,879
<font color="#E5E5E5">us about earlier and also the LPC graph</font>

16
00:01:00,989 --> 00:01:11,039
query language<font color="#E5E5E5"> task force which is the</font>

17
00:01:04,879 --> 00:01:18,539
<font color="#E5E5E5">entity who came up</font><font color="#CCCCCC"> with</font><font color="#E5E5E5"> G core which is</font>

18
00:01:11,039 --> 00:01:21,899
<font color="#E5E5E5">to talk about the tork will be what does</font>

19
00:01:18,539 --> 00:01:25,130
Eddy be<font color="#CCCCCC"> seeing</font><font color="#E5E5E5"> some people</font><font color="#CCCCCC"> may know leb</font>

20
00:01:21,899 --> 00:01:29,789
<font color="#E5E5E5">sees the linked data benchmark</font><font color="#CCCCCC"> Council</font>

21
00:01:25,130 --> 00:01:31,679
which<font color="#E5E5E5"> was founded out of a new research</font>

22
00:01:29,789 --> 00:01:34,940
<font color="#CCCCCC">project</font><font color="#E5E5E5"> and it's a</font><font color="#CCCCCC"> nonprofit</font>

23
00:01:31,679 --> 00:01:38,700
organization<font color="#CCCCCC"> that is devoted to</font>

24
00:01:34,940 --> 00:01:41,880
specifying benchmarks for graph database

25
00:01:38,700 --> 00:01:45,479
systems to make systems<font color="#E5E5E5"> comparable in</font>

26
00:01:41,880 --> 00:01:48,800
terms<font color="#E5E5E5"> of their performance and all of</font>

27
00:01:45,479 --> 00:01:50,670
that<font color="#E5E5E5"> work</font><font color="#CCCCCC"> or when you</font><font color="#E5E5E5"> want to define</font>

28
00:01:48,800 --> 00:01:52,860
<font color="#E5E5E5">benchmarks you have the problem that you</font>

29
00:01:50,670 --> 00:01:57,090
have<font color="#CCCCCC"> to define queries which are</font><font color="#E5E5E5"> run</font><font color="#CCCCCC"> by</font>

30
00:01:52,860 --> 00:02:00,630
<font color="#E5E5E5">the benchmarks and then you run</font><font color="#CCCCCC"> into the</font>

31
00:01:57,090 --> 00:02:02,810
problem<font color="#E5E5E5"> that it's hard to do that for a</font>

32
00:02:00,630 --> 00:02:07,530
graph database<font color="#CCCCCC"> system</font><font color="#E5E5E5"> because there's no</font>

33
00:02:02,810 --> 00:02:11,130
standardization of craft query languages

34
00:02:07,530 --> 00:02:15,000
which was sort<font color="#E5E5E5"> of the motivation to have</font>

35
00:02:11,130 --> 00:02:17,100
<font color="#E5E5E5">a work</font><font color="#CCCCCC"> group on graph query language</font>

36
00:02:15,000 --> 00:02:24,810
and this<font color="#E5E5E5"> does working group or this task</font>

37
00:02:17,100 --> 00:02:28,140
force consists of a group of<font color="#E5E5E5"> people</font><font color="#CCCCCC"> one</font>

38
00:02:24,810 --> 00:02:32,370
<font color="#E5E5E5">half from academia like</font><font color="#CCCCCC"> myself and the</font>

39
00:02:28,140 --> 00:02:35,459
other are from<font color="#E5E5E5"> from industry and Marlatt</font>

40
00:02:32,370 --> 00:02:40,320
various from various<font color="#E5E5E5"> vendors of graph</font>

41
00:02:35,460 --> 00:02:47,280
database systems<font color="#E5E5E5"> like new of course</font><font color="#CCCCCC"> but</font>

42
00:02:40,320 --> 00:02:50,910
also<font color="#CCCCCC"> s</font><font color="#E5E5E5"> AP and</font><font color="#CCCCCC"> Oracle sparsity etc and</font>

43
00:02:47,280 --> 00:02:55,380
the nice feature of<font color="#CCCCCC"> that forum is that</font>

44
00:02:50,910 --> 00:02:58,470
it<font color="#E5E5E5"> combines practical experiences in how</font>

45
00:02:55,380 --> 00:03:00,840
people<font color="#E5E5E5"> use a graph query languages how</font>

46
00:02:58,470 --> 00:03:08,970
they<font color="#CCCCCC"> how we</font><font color="#E5E5E5"> can implement systems with</font>

47
00:03:00,840 --> 00:03:13,709
them this combines this with the more

48
00:03:08,970 --> 00:03:15,810
<font color="#CCCCCC">theoretical knowledge from academia</font><font color="#E5E5E5"> so</font>

49
00:03:13,709 --> 00:03:22,200
what are the complexities of certain

50
00:03:15,810 --> 00:03:24,209
query language features<font color="#E5E5E5"> etc so the</font>

51
00:03:22,200 --> 00:03:26,518
result of<font color="#E5E5E5"> that</font><font color="#CCCCCC"> works or do you need the</font>

52
00:03:24,209 --> 00:03:29,760
<font color="#CCCCCC">task force worked for roughly two years</font>

53
00:03:26,519 --> 00:03:31,709
<font color="#E5E5E5">and the result of that work is now this</font>

54
00:03:29,760 --> 00:03:38,519
query graph Korean language proposal

55
00:03:31,709 --> 00:03:42,360
called<font color="#E5E5E5"> G core and it is accepted as a</font>

56
00:03:38,519 --> 00:03:44,459
<font color="#CCCCCC">Sigma paper</font><font color="#E5E5E5"> and will appear on this year</font>

57
00:03:42,360 --> 00:03:47,810
<font color="#CCCCCC">sick March</font><font color="#E5E5E5"> and if</font><font color="#CCCCCC"> you're interested in</font>

58
00:03:44,459 --> 00:03:54,560
the details<font color="#E5E5E5"> already you can go to this</font>

59
00:03:47,810 --> 00:03:58,140
preprint<font color="#CCCCCC"> linked here</font><font color="#E5E5E5"> on the slide so to</font>

60
00:03:54,560 --> 00:04:01,019
explain<font color="#CCCCCC"> gqo a little bit more</font><font color="#E5E5E5"> let's</font>

61
00:03:58,140 --> 00:04:04,529
start with what is G core and<font color="#E5E5E5"> what is it</font>

62
00:04:01,019 --> 00:04:08,340
not so G<font color="#E5E5E5"> coy is not a graph database</font>

63
00:04:04,530 --> 00:04:10,650
<font color="#E5E5E5">system but it's a graph query language</font>

64
00:04:08,340 --> 00:04:16,440
so it's a<font color="#E5E5E5"> language specification which</font>

65
00:04:10,650 --> 00:04:18,450
specifies<font color="#E5E5E5"> syntax and semantics so</font>

66
00:04:16,440 --> 00:04:20,850
there's no system you can download

67
00:04:18,450 --> 00:04:25,349
install and<font color="#E5E5E5"> then run these queries that</font>

68
00:04:20,850 --> 00:04:27,560
<font color="#E5E5E5">is not was not the intention it's not</font>

69
00:04:25,350 --> 00:04:33,479
commercial<font color="#E5E5E5"> or proprietary</font>

70
00:04:27,560 --> 00:04:35,910
but it's a design of a query language of

71
00:04:33,479 --> 00:04:40,729
this<font color="#E5E5E5"> mixed group of people from industry</font>

72
00:04:35,910 --> 00:04:44,340
<font color="#E5E5E5">and academia which tries to blend these</font>

73
00:04:40,729 --> 00:04:47,909
different sets of<font color="#CCCCCC"> experiences together</font>

74
00:04:44,340 --> 00:04:51,210
in one language proposal which we<font color="#E5E5E5"> think</font>

75
00:04:47,910 --> 00:04:53,910
is a good<font color="#E5E5E5"> direction for graph query</font>

76
00:04:51,210 --> 00:04:58,138
languages<font color="#E5E5E5"> in that sense it's also not a</font>

77
00:04:53,910 --> 00:05:01,759
standard doing standards is really<font color="#E5E5E5"> hard</font>

78
00:04:58,139 --> 00:05:04,259
<font color="#E5E5E5">and involves a lot of politics etc and</font>

79
00:05:01,759 --> 00:05:07,620
the nice thing<font color="#E5E5E5"> about this EDP seek</font>

80
00:05:04,259 --> 00:05:09,570
reports that<font color="#CCCCCC"> we've mostly</font><font color="#E5E5E5"> able to keep</font>

81
00:05:07,620 --> 00:05:14,099
politics<font color="#E5E5E5"> out of it so really concentrate</font>

82
00:05:09,570 --> 00:05:16,560
<font color="#E5E5E5">on the matter</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> designing a good</font><font color="#CCCCCC"> query</font>

83
00:05:14,099 --> 00:05:20,190
language and we also didn't want it<font color="#CCCCCC"> to</font>

84
00:05:16,560 --> 00:05:22,740
have all<font color="#E5E5E5"> possible features but</font>

85
00:05:20,190 --> 00:05:27,660
concentrate on a on a core<font color="#CCCCCC"> of features</font>

86
00:05:22,740 --> 00:05:30,720
which we think are<font color="#E5E5E5"> crucial for a good</font>

87
00:05:27,660 --> 00:05:34,139
<font color="#CCCCCC">graph</font><font color="#E5E5E5"> pure language so the intention is</font>

88
00:05:30,720 --> 00:05:36,539
more to provide sort<font color="#E5E5E5"> of a vision where</font>

89
00:05:34,139 --> 00:05:38,039
we<font color="#E5E5E5"> think graph query languages that that</font>

90
00:05:36,539 --> 00:05:42,030
<font color="#E5E5E5">are actually implemented in systems</font>

91
00:05:38,039 --> 00:05:44,310
where those should evolve<font color="#CCCCCC"> too so what</font>

92
00:05:42,030 --> 00:05:47,719
the what we think the<font color="#E5E5E5"> field the future</font>

93
00:05:44,310 --> 00:05:47,720
of coiffure languages should look like

94
00:05:49,460 --> 00:05:55,739
<font color="#E5E5E5">mg core to get little bit more into the</font>

95
00:05:52,409 --> 00:05:59,430
<font color="#CCCCCC">details decoys based on the query and</font>

96
00:05:55,740 --> 00:06:01,320
sorry the property graph data model we

97
00:05:59,430 --> 00:06:03,870
<font color="#E5E5E5">already had a nice introduction by a by</font>

98
00:06:01,320 --> 00:06:06,090
<font color="#CCCCCC">Stephan</font><font color="#E5E5E5"> to the query model so I will</font>

99
00:06:03,870 --> 00:06:12,050
more<font color="#E5E5E5"> or less skip over that but</font>

100
00:06:06,090 --> 00:06:14,729
<font color="#E5E5E5">essentially a graph of rich object and</font>

101
00:06:12,050 --> 00:06:17,460
when we started<font color="#E5E5E5"> with the work on</font><font color="#CCCCCC"> decore</font>

102
00:06:14,729 --> 00:06:19,830
we sort<font color="#E5E5E5"> of tried</font><font color="#CCCCCC"> to formulate certain</font>

103
00:06:17,460 --> 00:06:27,448
challenges which graph query languages

104
00:06:19,830 --> 00:06:30,000
<font color="#CCCCCC">face or what we see from</font><font color="#E5E5E5"> existing query</font>

105
00:06:27,449 --> 00:06:33,360
languages and the first challenge is

106
00:06:30,000 --> 00:06:35,520
that<font color="#E5E5E5"> good query language is a general so</font>

107
00:06:33,360 --> 00:06:38,969
<font color="#CCCCCC">that does not only</font><font color="#E5E5E5"> apply to graph query</font>

108
00:06:35,520 --> 00:06:41,609
languages<font color="#E5E5E5"> is the query language should</font>

109
00:06:38,969 --> 00:06:43,380
be composable

110
00:06:41,610 --> 00:06:47,850
that means that<font color="#E5E5E5"> means that you can take</font>

111
00:06:43,380 --> 00:06:50,790
<font color="#CCCCCC">in</font><font color="#E5E5E5"> a one result of one query and use</font>

112
00:06:47,850 --> 00:06:55,560
that as an<font color="#CCCCCC"> input</font><font color="#E5E5E5"> to another query as you</font>

113
00:06:50,790 --> 00:06:57,510
can do in sequel<font color="#E5E5E5"> ever since</font><font color="#CCCCCC"> but with the</font>

114
00:06:55,560 --> 00:06:59,010
most existing graph query languages you

115
00:06:57,510 --> 00:07:04,080
cannot really do that or you can do<font color="#CCCCCC"> it</font>

116
00:06:59,010 --> 00:07:06,150
just<font color="#E5E5E5"> in very limited ways so what we</font>

117
00:07:04,080 --> 00:07:08,219
wanted to<font color="#E5E5E5"> achieve</font><font color="#CCCCCC"> is what we call a</font>

118
00:07:06,150 --> 00:07:09,870
closed query language<font color="#E5E5E5"> that means the</font>

119
00:07:08,220 --> 00:07:12,270
query language<font color="#CCCCCC"> versus in</font><font color="#E5E5E5"> the</font>

120
00:07:09,870 --> 00:07:16,020
mathematical<font color="#E5E5E5"> sense closed over its data</font>

121
00:07:12,270 --> 00:07:18,750
model so in input<font color="#E5E5E5"> and output follow the</font>

122
00:07:16,020 --> 00:07:21,510
same data model<font color="#E5E5E5"> and by that</font><font color="#CCCCCC"> you your</font>

123
00:07:18,750 --> 00:07:24,470
queries become composable<font color="#E5E5E5"> and then of</font>

124
00:07:21,510 --> 00:07:27,529
<font color="#CCCCCC">course you have to see that we have</font>

125
00:07:24,470 --> 00:07:27,529
[Music]

126
00:07:28,970 --> 00:07:35,000
certain extension points and sub queries

127
00:07:32,010 --> 00:07:38,490
etc<font color="#CCCCCC"> to to many</font><font color="#E5E5E5"> make make use of these</font>

128
00:07:35,000 --> 00:07:41,039
composability the second challenge<font color="#CCCCCC"> which</font>

129
00:07:38,490 --> 00:07:45,800
<font color="#E5E5E5">we</font><font color="#CCCCCC"> trip</font><font color="#E5E5E5"> which we try to address is our</font>

130
00:07:41,039 --> 00:07:45,800
paths paths are very<font color="#E5E5E5"> fundamental</font>

131
00:07:46,430 --> 00:07:54,180
abstraction<font color="#CCCCCC"> on upon graphs and</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> want</font>

132
00:07:52,289 --> 00:07:57,169
the query<font color="#E5E5E5"> language</font><font color="#CCCCCC"> to be able to to</font>

133
00:07:54,180 --> 00:07:59,880
reason about that and<font color="#E5E5E5"> process paths</font><font color="#CCCCCC"> and</font>

134
00:07:57,169 --> 00:08:04,849
what we see in existing query<font color="#E5E5E5"> language</font>

135
00:07:59,880 --> 00:08:07,950
<font color="#E5E5E5">is that that the you have group</font>

136
00:08:04,849 --> 00:08:11,669
possibilities but it's really<font color="#E5E5E5"> hard to</font>

137
00:08:07,950 --> 00:08:13,530
further process paths<font color="#E5E5E5"> and the best what</font>

138
00:08:11,669 --> 00:08:15,299
<font color="#E5E5E5">you</font><font color="#CCCCCC"> currently get us</font><font color="#E5E5E5"> that you can sort</font>

139
00:08:13,530 --> 00:08:17,750
<font color="#CCCCCC">of extract the path of the query</font>

140
00:08:15,300 --> 00:08:21,630
<font color="#E5E5E5">language and then further process it</font>

141
00:08:17,750 --> 00:08:25,199
down the line in<font color="#CCCCCC"> your application what</font>

142
00:08:21,630 --> 00:08:27,990
we want to have is<font color="#CCCCCC"> that paths should be</font>

143
00:08:25,199 --> 00:08:29,729
<font color="#CCCCCC">first-class</font><font color="#E5E5E5"> citizen in the query</font>

144
00:08:27,990 --> 00:08:33,060
<font color="#E5E5E5">language and in the data model and</font>

145
00:08:29,729 --> 00:08:37,229
that's with<font color="#CCCCCC"> g'kar we made a proposal</font><font color="#E5E5E5"> for</font>

146
00:08:33,059 --> 00:08:39,958
that<font color="#E5E5E5"> how that could look like and the</font>

147
00:08:37,229 --> 00:08:42,719
last challenge<font color="#E5E5E5"> is</font><font color="#CCCCCC"> that we wanted</font><font color="#E5E5E5"> to</font>

148
00:08:39,958 --> 00:08:44,849
concentrate<font color="#E5E5E5"> on a on a core for graph</font>

149
00:08:42,719 --> 00:08:49,440
query language so not don't take this<font color="#E5E5E5"> as</font>

150
00:08:44,850 --> 00:08:52,020
<font color="#CCCCCC">a</font><font color="#E5E5E5"> full-fledged example there are</font><font color="#CCCCCC"> our</font>

151
00:08:49,440 --> 00:08:54,209
full fledged proposal there are things

152
00:08:52,020 --> 00:08:57,379
<font color="#E5E5E5">which you deliberately not considered</font>

153
00:08:54,209 --> 00:09:00,899
because we concentrated on the core for

154
00:08:57,379 --> 00:09:03,439
<font color="#E5E5E5">careering so for instance one</font><font color="#CCCCCC"> thing</font>

155
00:09:00,899 --> 00:09:05,999
which we not<font color="#CCCCCC"> consider</font><font color="#E5E5E5"> deliberately is</font>

156
00:09:03,439 --> 00:09:08,069
manipulating the graph data<font color="#E5E5E5"> so which is</font>

157
00:09:05,999 --> 00:09:13,110
just really<font color="#CCCCCC"> a query language</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> of</font>

158
00:09:08,069 --> 00:09:16,079
<font color="#E5E5E5">course sense of query and what we wanted</font>

159
00:09:13,110 --> 00:09:19,800
to<font color="#E5E5E5"> achieve for that core</font><font color="#CCCCCC"> ng core is that</font>

160
00:09:16,079 --> 00:09:21,769
<font color="#CCCCCC">all the equiv makin isms that are</font>

161
00:09:19,800 --> 00:09:26,459
defined there are efficiently

162
00:09:21,769 --> 00:09:31,259
evaluatable<font color="#CCCCCC"> so that you can build a</font>

163
00:09:26,459 --> 00:09:33,689
system where<font color="#CCCCCC"> all the</font><font color="#E5E5E5"> that we are the</font>

164
00:09:31,259 --> 00:09:35,819
query<font color="#E5E5E5"> relation stays tractable no matter</font>

165
00:09:33,689 --> 00:09:38,429
what query you formulate in the language

166
00:09:35,819 --> 00:09:40,889
<font color="#E5E5E5">so the language</font><font color="#CCCCCC"> does not</font><font color="#E5E5E5"> allow you to</font>

167
00:09:38,429 --> 00:09:43,610
<font color="#E5E5E5">formulate</font><font color="#CCCCCC"> a query which is cannot be</font>

168
00:09:40,889 --> 00:09:50,579
evaluated<font color="#CCCCCC"> with attractable</font><font color="#E5E5E5"> algorithm</font>

169
00:09:43,610 --> 00:09:55,649
which<font color="#CCCCCC"> is a strong theoretical guarantee</font>

170
00:09:50,579 --> 00:09:58,739
which<font color="#E5E5E5"> this language gives</font><font color="#CCCCCC"> ok</font><font color="#E5E5E5"> so the main</font>

171
00:09:55,649 --> 00:10:02,279
time<font color="#CCCCCC"> I want to</font><font color="#E5E5E5"> spend on is talking about</font>

172
00:09:58,740 --> 00:10:03,869
the<font color="#E5E5E5"> the closeness of the language and</font>

173
00:10:02,279 --> 00:10:08,369
<font color="#E5E5E5">how you can use that</font><font color="#CCCCCC"> for query</font>

174
00:10:03,869 --> 00:10:13,129
composability<font color="#E5E5E5"> and the second main part</font>

175
00:10:08,369 --> 00:10:15,779
<font color="#E5E5E5">is on</font><font color="#CCCCCC"> tabs</font><font color="#E5E5E5"> serve ice-cream composition</font>

176
00:10:13,129 --> 00:10:19,410
<font color="#CCCCCC">very important for modern query</font>

177
00:10:15,779 --> 00:10:24,149
languages because what we see today is

178
00:10:19,410 --> 00:10:27,449
<font color="#CCCCCC">that a lot of</font><font color="#E5E5E5"> data is captured either</font>

179
00:10:24,149 --> 00:10:31,499
<font color="#E5E5E5">automatically or typically somewhere</font>

180
00:10:27,449 --> 00:10:33,599
<font color="#E5E5E5">else</font><font color="#CCCCCC"> so like back in the 80s</font><font color="#E5E5E5"> we designed</font>

181
00:10:31,499 --> 00:10:36,199
database systems<font color="#E5E5E5"> and usually the people</font>

182
00:10:33,600 --> 00:10:39,029
<font color="#CCCCCC">who consume the</font><font color="#E5E5E5"> data we</font><font color="#CCCCCC"> are the same who</font>

183
00:10:36,199 --> 00:10:41,160
set the data into<font color="#CCCCCC"> the system</font><font color="#E5E5E5"> but</font>

184
00:10:39,029 --> 00:10:42,600
nowadays it's that that's not the same

185
00:10:41,160 --> 00:10:48,059
anymore the data comes<font color="#CCCCCC"> from somewhere</font>

186
00:10:42,600 --> 00:10:49,889
<font color="#CCCCCC">else and the effect of</font><font color="#E5E5E5"> that is that your</font>

187
00:10:48,059 --> 00:10:54,179
base data or the<font color="#CCCCCC"> data which is stored in</font>

188
00:10:49,889 --> 00:10:58,949
<font color="#E5E5E5">a database system is typically very as a</font>

189
00:10:54,179 --> 00:11:02,549
very fine granularity<font color="#E5E5E5"> a low abstraction</font>

190
00:10:58,949 --> 00:11:05,519
<font color="#E5E5E5">so for instance in to give you an</font>

191
00:11:02,549 --> 00:11:07,860
example to<font color="#CCCCCC"> illustrate that</font><font color="#E5E5E5"> your database</font>

192
00:11:05,519 --> 00:11:09,660
<font color="#E5E5E5">would store individual Twitter messages</font>

193
00:11:07,860 --> 00:11:13,410
we treat relationships<font color="#CCCCCC"> something like</font>

194
00:11:09,660 --> 00:11:17,930
<font color="#E5E5E5">that</font><font color="#CCCCCC"> and on the other hand when when you</font>

195
00:11:13,410 --> 00:11:21,689
as a user go to these go to this data

196
00:11:17,930 --> 00:11:26,010
<font color="#E5E5E5">particular for analytical tasks you</font>

197
00:11:21,690 --> 00:11:29,430
usually talk not<font color="#CCCCCC"> about these</font><font color="#E5E5E5"> low-level</font>

198
00:11:26,010 --> 00:11:31,890
concepts but<font color="#E5E5E5"> about</font><font color="#CCCCCC"> high-level</font>

199
00:11:29,430 --> 00:11:33,839
<font color="#E5E5E5">abstractions of that like on such</font>

200
00:11:31,890 --> 00:11:37,949
<font color="#E5E5E5">Twitter data you would be interested</font><font color="#CCCCCC"> in</font>

201
00:11:33,839 --> 00:11:41,490
<font color="#E5E5E5">communities discussion topics discussion</font>

202
00:11:37,950 --> 00:11:43,769
<font color="#E5E5E5">threads etc and these are all concepts</font>

203
00:11:41,490 --> 00:11:47,279
which are not in the base data so you

204
00:11:43,769 --> 00:11:50,100
need to abstract from<font color="#E5E5E5"> the base data to</font>

205
00:11:47,279 --> 00:11:53,130
do actually things with these

206
00:11:50,100 --> 00:11:55,430
higher-level concepts and off key you

207
00:11:53,130 --> 00:11:58,709
have multiple<font color="#E5E5E5"> of these abstraction steps</font>

208
00:11:55,430 --> 00:12:01,290
<font color="#E5E5E5">for instance you might define so first</font>

209
00:11:58,709 --> 00:12:04,410
what is<font color="#CCCCCC"> a discussion a discussion</font><font color="#E5E5E5"> group</font>

210
00:12:01,290 --> 00:12:06,180
<font color="#CCCCCC">and then</font><font color="#E5E5E5"> you may define on the notion of</font>

211
00:12:04,410 --> 00:12:12,860
discussion group<font color="#E5E5E5"> what a community is and</font>

212
00:12:06,180 --> 00:12:17,430
so on and of<font color="#CCCCCC"> course</font><font color="#E5E5E5"> you to be</font><font color="#CCCCCC"> able to</font>

213
00:12:12,860 --> 00:12:20,519
sort of cross<font color="#E5E5E5"> this concept chasm I call</font>

214
00:12:17,430 --> 00:12:22,500
it so this division or this gap between

215
00:12:20,519 --> 00:12:26,300
the concepts<font color="#E5E5E5"> and the base data and the</font>

216
00:12:22,500 --> 00:12:29,970
concepts you want to use as a user you

217
00:12:26,300 --> 00:12:31,829
<font color="#CCCCCC">need mechanisms</font><font color="#E5E5E5"> that allow you to do</font>

218
00:12:29,970 --> 00:12:37,769
<font color="#E5E5E5">this abstraction and of course that</font>

219
00:12:31,829 --> 00:12:39,500
should<font color="#E5E5E5"> be your query language and to do</font>

220
00:12:37,769 --> 00:12:44,810
<font color="#E5E5E5">so the query language needs to be</font>

221
00:12:39,500 --> 00:12:47,899
composable so that you can construct or

222
00:12:44,810 --> 00:12:52,709
put multiple of these<font color="#CCCCCC"> obstruction steps</font>

223
00:12:47,899 --> 00:12:56,250
on top of each<font color="#E5E5E5"> other</font><font color="#CCCCCC"> and if these are</font>

224
00:12:52,709 --> 00:12:58,829
<font color="#E5E5E5">graphs down here and you want to talk</font>

225
00:12:56,250 --> 00:13:01,740
<font color="#E5E5E5">about higher-level concepts but also</font>

226
00:12:58,829 --> 00:13:03,989
with graphs<font color="#CCCCCC"> of course you must</font><font color="#E5E5E5"> be able</font>

227
00:13:01,740 --> 00:13:08,250
<font color="#CCCCCC">to</font><font color="#E5E5E5"> sort of create new graphs along the</font>

228
00:13:03,990 --> 00:13:11,630
way so define basically<font color="#E5E5E5"> higher abstract</font>

229
00:13:08,250 --> 00:13:14,220
graphs based on low abstract graphs and

230
00:13:11,630 --> 00:13:20,740
that should be all<font color="#CCCCCC"> be doable in your</font>

231
00:13:14,220 --> 00:13:23,410
career<font color="#CCCCCC"> okay how</font><font color="#E5E5E5"> can it be done</font><font color="#CCCCCC"> in G core</font>

232
00:13:20,740 --> 00:13:25,950
I will use this small<font color="#E5E5E5"> graph here as an</font>

233
00:13:23,410 --> 00:13:30,790
example<font color="#CCCCCC"> it's basically a social graph</font>

234
00:13:25,950 --> 00:13:33,010
<font color="#CCCCCC">inspired</font><font color="#E5E5E5"> by the</font><font color="#CCCCCC"> LG BC</font><font color="#E5E5E5"> benchmark data so</font>

235
00:13:30,790 --> 00:13:37,980
we<font color="#E5E5E5"> have people with names and employees</font>

236
00:13:33,010 --> 00:13:41,230
and messages they exchanged in a<font color="#CCCCCC"> forum</font>

237
00:13:37,980 --> 00:13:45,760
<font color="#E5E5E5">etc so the details are</font><font color="#CCCCCC"> not so important</font>

238
00:13:41,230 --> 00:13:48,250
<font color="#CCCCCC">okay as we have seen to be able</font><font color="#E5E5E5"> to</font>

239
00:13:45,760 --> 00:13:50,080
abstract a higher level graph some<font color="#CCCCCC"> lower</font>

240
00:13:48,250 --> 00:13:57,220
<font color="#CCCCCC">level graphs you must be able to create</font>

241
00:13:50,080 --> 00:14:00,930
graphs<font color="#E5E5E5"> in a query and for that</font><font color="#CCCCCC"> a gqo</font>

242
00:13:57,220 --> 00:14:04,570
every<font color="#CCCCCC"> gqo query has a construct clause</font>

243
00:14:00,930 --> 00:14:07,870
<font color="#CCCCCC">the</font><font color="#E5E5E5"> other part of the g-code query match</font>

244
00:14:04,570 --> 00:14:10,020
and where is pretty much like what you

245
00:14:07,870 --> 00:14:15,280
<font color="#E5E5E5">know from existing graph query languages</font>

246
00:14:10,020 --> 00:14:18,460
like<font color="#CCCCCC"> cypher or PG ql so it uses this</font>

247
00:14:15,280 --> 00:14:20,199
ASCII art syntax to define a<font color="#E5E5E5"> pattern you</font>

248
00:14:18,460 --> 00:14:22,090
can say on<font color="#E5E5E5"> which graph you want to match</font>

249
00:14:20,200 --> 00:14:26,740
and you have the where<font color="#E5E5E5"> clause to add</font>

250
00:14:22,090 --> 00:14:28,870
additional pretty<font color="#CCCCCC"> cuts as we have</font>

251
00:14:26,740 --> 00:14:32,020
already<font color="#E5E5E5"> learned from</font><font color="#CCCCCC"> Stefan's</font><font color="#E5E5E5"> talk</font>

252
00:14:28,870 --> 00:14:34,120
earlier so what what is<font color="#E5E5E5"> basically new</font>

253
00:14:32,020 --> 00:14:38,680
<font color="#CCCCCC">and recourse this construct</font><font color="#E5E5E5"> cross which</font>

254
00:14:34,120 --> 00:14:41,200
defines what your<font color="#CCCCCC"> output looks like</font><font color="#E5E5E5"> and</font>

255
00:14:38,680 --> 00:14:45,370
the output for Fujiko query is always a

256
00:14:41,200 --> 00:14:47,770
graph<font color="#E5E5E5"> and what we do is will recycle the</font>

257
00:14:45,370 --> 00:14:51,850
patterns<font color="#CCCCCC"> own tracks</font><font color="#E5E5E5"> to also specify a</font>

258
00:14:47,770 --> 00:14:56,980
pattern here which<font color="#E5E5E5"> is then instantiated</font>

259
00:14:51,850 --> 00:15:01,030
<font color="#E5E5E5">for every result of the match clause so</font>

260
00:14:56,980 --> 00:15:03,360
in that case the<font color="#CCCCCC"> output put B for</font><font color="#E5E5E5"> every</font>

261
00:15:01,030 --> 00:15:06,250
match we<font color="#CCCCCC"> will just output one note and</font>

262
00:15:03,360 --> 00:15:10,300
since this variable appears also<font color="#CCCCCC"> in the</font>

263
00:15:06,250 --> 00:15:11,620
match<font color="#E5E5E5"> clause it would be exactly the the</font>

264
00:15:10,300 --> 00:15:14,560
note which we have matched here the

265
00:15:11,620 --> 00:15:18,010
person<font color="#E5E5E5"> note so the output graph would</font>

266
00:15:14,560 --> 00:15:20,319
consist just of notes no<font color="#CCCCCC"> etches and they</font>

267
00:15:18,010 --> 00:15:22,960
would contain all<font color="#E5E5E5"> the person notes from</font>

268
00:15:20,320 --> 00:15:25,110
<font color="#E5E5E5">this social graph where</font><font color="#CCCCCC"> the employer</font><font color="#E5E5E5"> is</font>

269
00:15:22,960 --> 00:15:25,110
a

270
00:15:26,120 --> 00:15:30,260
of course you don't<font color="#CCCCCC"> you</font><font color="#E5E5E5"> do not only want</font>

271
00:15:28,250 --> 00:15:36,470
<font color="#CCCCCC">to create notes but</font><font color="#E5E5E5"> you also want to</font>

272
00:15:30,260 --> 00:15:40,069
create edges<font color="#CCCCCC"> you can do that by</font>

273
00:15:36,470 --> 00:15:43,990
<font color="#E5E5E5">specifying an edge in your construction</font>

274
00:15:40,070 --> 00:15:48,820
pattern<font color="#E5E5E5"> and what this</font><font color="#CCCCCC"> screen shows is</font>

275
00:15:43,990 --> 00:15:51,500
sort of an<font color="#CCCCCC"> data integration scenario so</font>

276
00:15:48,820 --> 00:15:53,930
the match<font color="#E5E5E5"> Clause matches on</font><font color="#CCCCCC"> two graphs</font>

277
00:15:51,500 --> 00:15:57,910
<font color="#E5E5E5">the the social</font><font color="#CCCCCC"> graph we saw in the</font>

278
00:15:53,930 --> 00:16:00,739
example and some imaginary company graph

279
00:15:57,910 --> 00:16:04,069
in the social graph image persons and in

280
00:16:00,740 --> 00:16:07,730
the company graph we match<font color="#CCCCCC"> companies</font><font color="#E5E5E5"> and</font>

281
00:16:04,070 --> 00:16:11,360
then<font color="#E5E5E5"> we</font><font color="#CCCCCC"> look</font><font color="#E5E5E5"> for sort of</font><font color="#CCCCCC"> oh we did we do</font>

282
00:16:07,730 --> 00:16:13,490
<font color="#CCCCCC">have sort</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> to a join</font><font color="#E5E5E5"> where the company</font>

283
00:16:11,360 --> 00:16:16,250
name is<font color="#CCCCCC"> mentioned</font><font color="#E5E5E5"> in the list of</font>

284
00:16:13,490 --> 00:16:21,170
<font color="#E5E5E5">employee names in the for the person and</font>

285
00:16:16,250 --> 00:16:26,330
<font color="#E5E5E5">for those pairs of companies and persons</font>

286
00:16:21,170 --> 00:16:28,040
we would<font color="#E5E5E5"> create an edge between those so</font>

287
00:16:26,330 --> 00:16:32,260
<font color="#CCCCCC">that we get</font><font color="#E5E5E5"> a graph of companies and</font>

288
00:16:28,040 --> 00:16:36,589
names and edges which so who works<font color="#E5E5E5"> where</font>

289
00:16:32,260 --> 00:16:38,990
and then what we could do we could join

290
00:16:36,589 --> 00:16:41,990
this with the original<font color="#E5E5E5"> as our</font><font color="#CCCCCC"> union</font><font color="#E5E5E5"> this</font>

291
00:16:38,990 --> 00:16:44,510
with the original<font color="#E5E5E5"> social graph so</font><font color="#CCCCCC"> that</font>

292
00:16:41,990 --> 00:16:48,800
<font color="#E5E5E5">the original social graph is sort of</font>

293
00:16:44,510 --> 00:16:50,900
 man<font color="#E5E5E5"> or that the output</font><font color="#CCCCCC"> is an</font>

294
00:16:48,800 --> 00:16:53,660
Augmented version of the social graph

295
00:16:50,900 --> 00:16:55,310
where we<font color="#E5E5E5"> also have the company name</font><font color="#CCCCCC"> the</font>

296
00:16:53,660 --> 00:17:01,579
<font color="#E5E5E5">company nodes and the</font><font color="#CCCCCC"> Burke's</font>

297
00:16:55,310 --> 00:17:04,790
<font color="#E5E5E5">attaches but note that</font><font color="#CCCCCC"> this query would</font>

298
00:17:01,580 --> 00:17:06,800
not modify<font color="#CCCCCC"> the social graph</font><font color="#E5E5E5"> so it's just</font>

299
00:17:04,790 --> 00:17:08,000
that<font color="#E5E5E5"> the output would also contain</font>

300
00:17:06,800 --> 00:17:14,178
everything<font color="#E5E5E5"> that the social graph</font>

301
00:17:08,000 --> 00:17:17,929
contains then in the graph<font color="#CCCCCC"> construction</font>

302
00:17:14,179 --> 00:17:21,980
we<font color="#CCCCCC"> can do more</font><font color="#E5E5E5"> so we can really create</font>

303
00:17:17,929 --> 00:17:24,439
new<font color="#E5E5E5"> things you know</font><font color="#CCCCCC"> it's new edges so</font>

304
00:17:21,980 --> 00:17:26,480
assume we only consider the social<font color="#E5E5E5"> graph</font>

305
00:17:24,439 --> 00:17:29,720
<font color="#E5E5E5">and match the</font><font color="#CCCCCC"> person's again</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> now</font>

306
00:17:26,480 --> 00:17:34,520
want to<font color="#E5E5E5"> turn the</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> employers mentioned</font>

307
00:17:29,720 --> 00:17:36,530
in this<font color="#E5E5E5"> property into notes huh like</font>

308
00:17:34,520 --> 00:17:39,230
like a normalization step for a graph

309
00:17:36,530 --> 00:17:42,860
<font color="#CCCCCC">data basis you could can think of</font>

310
00:17:39,230 --> 00:17:44,419
so then we<font color="#E5E5E5"> could introduce a new note by</font>

311
00:17:42,860 --> 00:17:46,969
giving it a<font color="#E5E5E5"> variable which is</font><font color="#CCCCCC"> not</font>

312
00:17:44,419 --> 00:17:49,249
mentioned<font color="#E5E5E5"> in the match pattern and say</font>

313
00:17:46,970 --> 00:17:51,740
okay we want<font color="#CCCCCC"> to</font><font color="#E5E5E5"> create a new note if the</font>

314
00:17:49,249 --> 00:17:54,279
<font color="#E5E5E5">label</font><font color="#CCCCCC"> company and the name should be</font><font color="#E5E5E5"> the</font>

315
00:17:51,740 --> 00:17:57,529
<font color="#E5E5E5">names we find here in the employee</font>

316
00:17:54,279 --> 00:18:02,139
<font color="#E5E5E5">property and then we</font><font color="#CCCCCC"> link</font><font color="#E5E5E5"> this new note</font>

317
00:17:57,529 --> 00:18:02,139
to the person who<font color="#CCCCCC"> books for that</font><font color="#E5E5E5"> company</font>

318
00:18:02,230 --> 00:18:07,700
<font color="#CCCCCC">this</font><font color="#E5E5E5"> would give us multiple or the</font>

319
00:18:05,929 --> 00:18:09,860
problem of<font color="#E5E5E5"> that query formalization a</font>

320
00:18:07,700 --> 00:18:13,669
query formulation is that<font color="#CCCCCC"> it would give</font>

321
00:18:09,860 --> 00:18:19,459
us for every mentioning of a company

322
00:18:13,669 --> 00:18:21,999
here a company note so if two people

323
00:18:19,460 --> 00:18:24,169
<font color="#E5E5E5">work for IBM we would do it to IBM notes</font>

324
00:18:21,999 --> 00:18:29,779
but of course we want<font color="#CCCCCC"> to</font><font color="#E5E5E5"> have just</font><font color="#CCCCCC"> one</font>

325
00:18:24,169 --> 00:18:33,080
IBM note right so this<font color="#CCCCCC"> you can</font><font color="#E5E5E5"> also do</font>

326
00:18:29,779 --> 00:18:36,019
<font color="#CCCCCC">IndyCar</font><font color="#E5E5E5"> because you can group the</font>

327
00:18:33,080 --> 00:18:38,059
creation of a graph<font color="#CCCCCC"> object like a note</font>

328
00:18:36,019 --> 00:18:42,889
so you<font color="#E5E5E5"> can say I want</font><font color="#CCCCCC"> to create new</font>

329
00:18:38,059 --> 00:18:45,740
notes<font color="#E5E5E5"> X group by E which is the employee</font>

330
00:18:42,889 --> 00:18:48,080
name<font color="#CCCCCC"> right and</font><font color="#E5E5E5"> then you would create a</font>

331
00:18:45,740 --> 00:18:51,139
<font color="#E5E5E5">new node X only for each distinct</font>

332
00:18:48,080 --> 00:18:52,749
employee<font color="#E5E5E5"> name so if you have two persons</font>

333
00:18:51,139 --> 00:18:55,850
working<font color="#E5E5E5"> for IBM you will just create one</font>

334
00:18:52,749 --> 00:18:57,499
note<font color="#E5E5E5"> for idea but still those two</font>

335
00:18:55,850 --> 00:19:04,519
persons<font color="#CCCCCC"> would be linked with this new</font>

336
00:18:57,499 --> 00:19:07,639
edge to the IBM<font color="#CCCCCC"> node so in that sense</font>

337
00:19:04,519 --> 00:19:13,340
it's a pretty intuitive of<font color="#E5E5E5"> what happens</font>

338
00:19:07,639 --> 00:19:17,539
<font color="#E5E5E5">here when you group then of course you</font>

339
00:19:13,340 --> 00:19:22,070
can<font color="#CCCCCC"> also aggregate</font><font color="#E5E5E5"> so it's very simple</font>

340
00:19:17,539 --> 00:19:23,779
<font color="#CCCCCC">to for</font><font color="#E5E5E5"> instance have augmentis a company</font>

341
00:19:22,070 --> 00:19:27,220
<font color="#E5E5E5">note for instance with the number of</font>

342
00:19:23,779 --> 00:19:29,659
<font color="#E5E5E5">employees</font><font color="#CCCCCC"> by adding a property here and</font>

343
00:19:27,220 --> 00:19:32,389
with an aggregation functions which

344
00:19:29,659 --> 00:19:36,740
counts all the<font color="#CCCCCC"> asari as a</font><font color="#E5E5E5"> mistake not</font>

345
00:19:32,389 --> 00:19:42,949
all the X but all the N and then he

346
00:19:36,740 --> 00:19:47,360
would count all the persons who have

347
00:19:42,950 --> 00:19:50,619
this<font color="#E5E5E5"> e like the company IBM mentioned</font>

348
00:19:47,360 --> 00:19:50,619
here as an employer

349
00:19:51,279 --> 00:19:58,009
<font color="#CCCCCC">and when you create multiple</font><font color="#E5E5E5"> new notes</font>

350
00:19:53,889 --> 00:20:00,908
<font color="#E5E5E5">they can</font><font color="#CCCCCC"> have</font><font color="#E5E5E5"> different groupings</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> so</font>

351
00:19:58,009 --> 00:20:05,269
you can also<font color="#E5E5E5"> involve a front query</font>

352
00:20:00,909 --> 00:20:12,169
compute different aggregations<font color="#CCCCCC"> over</font>

353
00:20:05,269 --> 00:20:14,029
<font color="#E5E5E5">different groupings</font><font color="#CCCCCC"> I said you</font><font color="#E5E5E5"> can with</font>

354
00:20:12,169 --> 00:20:16,850
the Union you can<font color="#E5E5E5"> sort of augment a</font>

355
00:20:14,029 --> 00:20:20,929
graph<font color="#CCCCCC"> I</font><font color="#E5E5E5"> have a computer of mended</font>

356
00:20:16,850 --> 00:20:22,309
versions of base graphs<font color="#CCCCCC"> with the</font><font color="#E5E5E5"> Union</font>

357
00:20:20,929 --> 00:20:24,729
you can<font color="#E5E5E5"> also do that in a construct</font>

358
00:20:22,309 --> 00:20:28,369
close by just<font color="#E5E5E5"> mentioning the graph here</font>

359
00:20:24,729 --> 00:20:30,649
as sort<font color="#E5E5E5"> of the simplest pattern you can</font>

360
00:20:28,369 --> 00:20:35,478
have so it would be the same thing<font color="#E5E5E5"> the</font>

361
00:20:30,649 --> 00:20:37,059
query<font color="#E5E5E5"> would compute</font><font color="#CCCCCC"> these</font><font color="#E5E5E5"> are the result</font>

362
00:20:35,479 --> 00:20:39,559
<font color="#E5E5E5">of the query would be the social graph</font>

363
00:20:37,059 --> 00:20:44,539
<font color="#CCCCCC">Union with everything which is</font><font color="#E5E5E5"> produced</font>

364
00:20:39,559 --> 00:20:48,379
for by this pattern and again<font color="#E5E5E5"> this is no</font>

365
00:20:44,539 --> 00:20:50,720
base data manipulation<font color="#CCCCCC"> so</font><font color="#E5E5E5"> the graph to</font>

366
00:20:48,379 --> 00:20:52,998
which we refer here stays the same it's

367
00:20:50,720 --> 00:20:55,369
<font color="#CCCCCC">just at the output of the</font><font color="#E5E5E5"> query contains</font>

368
00:20:52,999 --> 00:20:59,239
everything<font color="#E5E5E5"> which also the base data</font>

369
00:20:55,369 --> 00:21:04,639
contained<font color="#E5E5E5"> plus the additionally created</font>

370
00:20:59,239 --> 00:21:07,609
notes and edges then of course you can

371
00:21:04,639 --> 00:21:11,689
also<font color="#E5E5E5"> query for</font><font color="#CCCCCC"> each abilities as we know</font>

372
00:21:07,609 --> 00:21:15,678
from<font color="#E5E5E5"> other query languages so if we use</font>

373
00:21:11,690 --> 00:21:18,580
the syntax with double slashes<font color="#E5E5E5"> to</font>

374
00:21:15,679 --> 00:21:24,109
distinguish it the creation for<font color="#E5E5E5"> paths</font>

375
00:21:18,580 --> 00:21:27,199
clearly from<font color="#E5E5E5"> creating</font><font color="#CCCCCC"> for edges and then</font>

376
00:21:24,109 --> 00:21:31,249
<font color="#E5E5E5">you have syntax as you would</font><font color="#CCCCCC"> expect for</font>

377
00:21:27,200 --> 00:21:33,679
regular path queries<font color="#E5E5E5"> so you can have</font>

378
00:21:31,249 --> 00:21:38,109
regular<font color="#E5E5E5"> expression over labels here to</font>

379
00:21:33,679 --> 00:21:41,779
<font color="#E5E5E5">specify which paths you are looking for</font>

380
00:21:38,109 --> 00:21:47,570
<font color="#CCCCCC">also similar</font><font color="#E5E5E5"> to what</font><font color="#CCCCCC"> Stefan mentioned in</font>

381
00:21:41,779 --> 00:21:49,909
<font color="#E5E5E5">his talk earlier there is one additional</font>

382
00:21:47,570 --> 00:21:51,168
<font color="#E5E5E5">thing which</font><font color="#CCCCCC"> I want to mention is here we</font>

383
00:21:49,909 --> 00:21:52,849
here<font color="#E5E5E5"> we</font><font color="#CCCCCC"> in the back</font><font color="#E5E5E5"> loss we see a</font>

384
00:21:51,169 --> 00:21:56,980
predicate which<font color="#E5E5E5"> consists just of a</font>

385
00:21:52,849 --> 00:22:02,270
pattern and the semantics<font color="#E5E5E5"> of that is</font>

386
00:21:56,980 --> 00:22:04,370
that's an existential predicate

387
00:22:02,270 --> 00:22:08,600
so the predicate is<font color="#CCCCCC"> true if for the</font>

388
00:22:04,370 --> 00:22:11,090
bound variables<font color="#E5E5E5"> and an M this graph</font>

389
00:22:08,600 --> 00:22:14,090
pattern exists in the graph<font color="#CCCCCC"> and since</font>

390
00:22:11,090 --> 00:22:18,230
<font color="#CCCCCC">our query languages are composable we</font>

391
00:22:14,090 --> 00:22:20,179
can actually<font color="#E5E5E5"> define</font><font color="#CCCCCC"> that as soon as a</font>

392
00:22:18,230 --> 00:22:22,820
syntactical shortcut of really a

393
00:22:20,180 --> 00:22:26,330
<font color="#CCCCCC">sub-query existential sub query which</font><font color="#E5E5E5"> is</font>

394
00:22:22,820 --> 00:22:29,060
shown in<font color="#CCCCCC"> that on that slide so this is</font>

395
00:22:26,330 --> 00:22:30,830
the same query again and this predicate

396
00:22:29,060 --> 00:22:33,340
<font color="#E5E5E5">is just a certain technical chart and</font>

397
00:22:30,830 --> 00:22:39,490
for actually<font color="#CCCCCC"> having and exists with a</font>

398
00:22:33,340 --> 00:22:42,320
<font color="#E5E5E5">full-fledged</font><font color="#CCCCCC"> gqo query as a sub query</font>

399
00:22:39,490 --> 00:22:47,680
where the match pattern is<font color="#E5E5E5"> exactly what</font>

400
00:22:42,320 --> 00:22:51,560
we have<font color="#CCCCCC"> here</font><font color="#E5E5E5"> so here you can see that</font>

401
00:22:47,680 --> 00:22:54,140
the when when you define or design a

402
00:22:51,560 --> 00:22:57,649
query language and this composable

403
00:22:54,140 --> 00:23:02,380
<font color="#CCCCCC">enclosed way then you already get a</font>

404
00:22:57,650 --> 00:23:05,030
benefit out<font color="#E5E5E5"> of that so that you can have</font>

405
00:23:02,380 --> 00:23:08,000
special<font color="#E5E5E5"> student special syntax without</font>

406
00:23:05,030 --> 00:23:09,440
<font color="#E5E5E5">defining additional semantics which is</font>

407
00:23:08,000 --> 00:23:13,390
sort of rewriting<font color="#CCCCCC"> two of what you</font>

408
00:23:09,440 --> 00:23:15,230
already have<font color="#CCCCCC"> another benefit of</font><font color="#E5E5E5"> having a</font>

409
00:23:13,390 --> 00:23:20,780
<font color="#E5E5E5">composition or</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> query languages that</font>

410
00:23:15,230 --> 00:23:23,810
it's easy to define the use so you<font color="#E5E5E5"> can</font>

411
00:23:20,780 --> 00:23:26,510
think<font color="#E5E5E5"> of that that you can have a</font>

412
00:23:23,810 --> 00:23:29,450
statement<font color="#CCCCCC"> create a graph you give it</font><font color="#E5E5E5"> a</font>

413
00:23:26,510 --> 00:23:32,440
name<font color="#CCCCCC"> and then ask and then the G</font><font color="#E5E5E5"> chord</font>

414
00:23:29,450 --> 00:23:35,960
query and that<font color="#CCCCCC"> would define you a view</font>

415
00:23:32,440 --> 00:23:39,100
which exposes a graph and the graph

416
00:23:35,960 --> 00:23:43,430
<font color="#CCCCCC">would be exactly the graph</font><font color="#E5E5E5"> created by</font>

417
00:23:39,100 --> 00:23:47,120
this query<font color="#CCCCCC"> here other features we see</font><font color="#E5E5E5"> is</font>

418
00:23:43,430 --> 00:23:54,800
<font color="#CCCCCC">that you can have optional matching so</font>

419
00:23:47,120 --> 00:23:59,659
outer join semantics yeah so what this

420
00:23:54,800 --> 00:24:01,310
query<font color="#CCCCCC"> actually creates is</font><font color="#E5E5E5"> or</font><font color="#CCCCCC"> but when we</font>

421
00:23:59,660 --> 00:24:05,420
look at<font color="#E5E5E5"> the view the graph we</font><font color="#CCCCCC"> see from</font>

422
00:24:01,310 --> 00:24:07,550
from<font color="#E5E5E5"> this view what we the original</font>

423
00:24:05,420 --> 00:24:12,590
social<font color="#CCCCCC"> graph we have seen augmented by</font>

424
00:24:07,550 --> 00:24:14,480
additional edges which where each edge

425
00:24:12,590 --> 00:24:16,159
between<font color="#E5E5E5"> two persons have the</font><font color="#CCCCCC"> number of</font>

426
00:24:14,480 --> 00:24:19,820
messages<font color="#CCCCCC"> which</font>

427
00:24:16,160 --> 00:24:23,830
these persons exchanged like these two

428
00:24:19,820 --> 00:24:28,129
persons here have exchanged<font color="#E5E5E5"> two messages</font>

429
00:24:23,830 --> 00:24:33,580
<font color="#CCCCCC">so the number</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> two</font><font color="#E5E5E5"> and it's something</font>

430
00:24:28,130 --> 00:24:33,580
<font color="#E5E5E5">you can compute with</font><font color="#CCCCCC"> decoders</font>

431
00:24:34,840 --> 00:24:46,250
so let's now come to paths as

432
00:24:39,770 --> 00:24:48,560
<font color="#CCCCCC">first-class citizen so the idea</font><font color="#E5E5E5"> is</font>

433
00:24:46,250 --> 00:24:52,070
basically<font color="#E5E5E5"> to make</font><font color="#CCCCCC"> paths first-class</font>

434
00:24:48,560 --> 00:24:57,159
citizens is that paths<font color="#E5E5E5"> also can be</font>

435
00:24:52,070 --> 00:25:01,639
<font color="#CCCCCC">object</font><font color="#E5E5E5"> so you can clear them</font><font color="#CCCCCC"> and then</font>

436
00:24:57,160 --> 00:25:04,640
objectify them by sort<font color="#E5E5E5"> of creating a new</font>

437
00:25:01,640 --> 00:25:06,950
<font color="#E5E5E5">kind of object which represents that</font>

438
00:25:04,640 --> 00:25:08,300
that path<font color="#CCCCCC"> you have crew it</font><font color="#E5E5E5"> and when</font>

439
00:25:06,950 --> 00:25:10,640
they've been returned the path into an

440
00:25:08,300 --> 00:25:13,490
<font color="#CCCCCC">object you are also able of course to</font>

441
00:25:10,640 --> 00:25:15,110
attach labels to attach properties so

442
00:25:13,490 --> 00:25:21,320
all the nice things<font color="#CCCCCC"> you know from</font><font color="#E5E5E5"> edges</font>

443
00:25:15,110 --> 00:25:24,020
and<font color="#E5E5E5"> notes and</font><font color="#CCCCCC"> how would you</font><font color="#E5E5E5"> do that well</font>

444
00:25:21,320 --> 00:25:27,490
you<font color="#CCCCCC"> would</font><font color="#E5E5E5"> have a match query with a</font>

445
00:25:24,020 --> 00:25:32,440
regular expression again and if you

446
00:25:27,490 --> 00:25:35,480
assign<font color="#CCCCCC"> that path pattern a variable P</font>

447
00:25:32,440 --> 00:25:39,950
then that variable<font color="#E5E5E5"> is bound to that path</font>

448
00:25:35,480 --> 00:25:43,970
<font color="#E5E5E5">and when you construct a new graph you</font>

449
00:25:39,950 --> 00:25:46,520
can<font color="#CCCCCC"> include these this path and</font><font color="#E5E5E5"> what you</font>

450
00:25:43,970 --> 00:25:48,440
would get first is of course<font color="#E5E5E5"> all the</font>

451
00:25:46,520 --> 00:25:52,340
nodes and edges<font color="#CCCCCC"> which</font><font color="#E5E5E5"> path the</font><font color="#CCCCCC"> path</font>

452
00:25:48,440 --> 00:25:54,140
consists of and and then you can also

453
00:25:52,340 --> 00:25:56,510
say oh I also wanted to<font color="#E5E5E5"> have this path</font>

454
00:25:54,140 --> 00:25:59,270
<font color="#CCCCCC">object and you do</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> with the letter X</font>

455
00:25:56,510 --> 00:26:01,879
here and<font color="#CCCCCC"> then you</font><font color="#E5E5E5"> are able to give this</font>

456
00:25:59,270 --> 00:26:04,970
path object<font color="#CCCCCC"> a label you can</font><font color="#E5E5E5"> say okay all</font>

457
00:26:01,880 --> 00:26:08,360
this<font color="#CCCCCC"> this path</font><font color="#E5E5E5"> describes local people</font>

458
00:26:04,970 --> 00:26:12,110
and<font color="#E5E5E5"> it has a certain distance where do</font>

459
00:26:08,360 --> 00:26:16,840
you get the distance from this is doing

460
00:26:12,110 --> 00:26:19,729
the match<font color="#E5E5E5"> clause you can specify a</font>

461
00:26:16,840 --> 00:26:22,340
variable for all the<font color="#E5E5E5"> costs or</font><font color="#CCCCCC"> then the</font>

462
00:26:19,730 --> 00:26:25,790
path<font color="#E5E5E5"> is matched and this variable</font><font color="#CCCCCC"> see</font>

463
00:26:22,340 --> 00:26:28,220
here would be<font color="#E5E5E5"> bound to the to the costs</font>

464
00:26:25,790 --> 00:26:29,780
of<font color="#CCCCCC"> the</font><font color="#E5E5E5"> path what is the cost of the path</font>

465
00:26:28,220 --> 00:26:33,480
well that

466
00:26:29,780 --> 00:26:35,129
depends<font color="#E5E5E5"> if nothing</font><font color="#CCCCCC"> Spanish is specified</font>

467
00:26:33,480 --> 00:26:39,540
then it's<font color="#E5E5E5"> just</font><font color="#CCCCCC"> the hot distance</font><font color="#E5E5E5"> so</font>

468
00:26:35,130 --> 00:26:45,230
number of<font color="#CCCCCC"> batches</font><font color="#E5E5E5"> and as we will</font><font color="#CCCCCC"> see</font>

469
00:26:39,540 --> 00:26:49,170
later<font color="#E5E5E5"> we could also have a weighted cost</font>

470
00:26:45,230 --> 00:26:50,460
an additional<font color="#CCCCCC"> thing of decoys that when</font>

471
00:26:49,170 --> 00:26:52,890
you cream<font color="#CCCCCC"> for paths that's</font><font color="#E5E5E5"> always</font>

472
00:26:50,460 --> 00:26:55,290
shortest<font color="#CCCCCC"> paths semantics that is a</font>

473
00:26:52,890 --> 00:26:59,790
<font color="#E5E5E5">crucial property to make the query</font>

474
00:26:55,290 --> 00:27:01,500
language<font color="#E5E5E5"> detectable so with other</font><font color="#CCCCCC"> paths</font>

475
00:26:59,790 --> 00:27:03,120
semantics<font color="#CCCCCC"> you</font><font color="#E5E5E5"> easily get a query</font>

476
00:27:01,500 --> 00:27:05,030
languages<font color="#CCCCCC"> not which is not tractable</font>

477
00:27:03,120 --> 00:27:07,770
anymore

478
00:27:05,030 --> 00:27:09,809
but what is possible that you're not

479
00:27:07,770 --> 00:27:11,670
only<font color="#E5E5E5"> query for the very shortest the</font>

480
00:27:09,809 --> 00:27:16,230
shortest<font color="#E5E5E5"> path but for a number of</font>

481
00:27:11,670 --> 00:27:19,320
shortest paths<font color="#CCCCCC"> that</font><font color="#E5E5E5"> is also a possible</font>

482
00:27:16,230 --> 00:27:24,720
intractable way<font color="#E5E5E5"> so that you can say in</font><font color="#CCCCCC"> G</font>

483
00:27:19,320 --> 00:27:29,790
<font color="#CCCCCC">Co</font><font color="#E5E5E5"> or give me free shortest paths</font><font color="#CCCCCC"> of for</font>

484
00:27:24,720 --> 00:27:31,260
this<font color="#E5E5E5"> regular path pattern so what the</font>

485
00:27:29,790 --> 00:27:34,590
square basically what gives us is the

486
00:27:31,260 --> 00:27:39,360
<font color="#E5E5E5">free shortest paths</font><font color="#CCCCCC"> starting from a user</font>

487
00:27:34,590 --> 00:27:43,010
named John Doe to<font color="#E5E5E5"> our users</font><font color="#CCCCCC"> that John</font>

488
00:27:39,360 --> 00:27:46,590
Doe nose or reachable<font color="#CCCCCC"> over nose edges</font>

489
00:27:43,010 --> 00:27:50,510
and who live in the same city which we

490
00:27:46,590 --> 00:27:50,510
have here with<font color="#E5E5E5"> the extension subpubic</font>

491
00:27:51,620 --> 00:27:57,059
how now can we do weighted<font color="#CCCCCC"> shortest</font>

492
00:27:54,540 --> 00:27:59,389
paths so now top distance but it's very

493
00:27:57,059 --> 00:27:59,389
question

494
00:28:14,190 --> 00:28:18,300
<font color="#CCCCCC">now this doesn't</font><font color="#E5E5E5"> create here this</font>

495
00:28:16,260 --> 00:28:21,450
<font color="#E5E5E5">doesn't</font><font color="#CCCCCC"> create</font><font color="#E5E5E5"> though the question is if</font>

496
00:28:18,300 --> 00:28:24,690
I bound<font color="#CCCCCC"> free shortest paths</font><font color="#E5E5E5"> would I</font>

497
00:28:21,450 --> 00:28:26,910
create free edges up here<font color="#CCCCCC"> first</font><font color="#E5E5E5"> answer</font>

498
00:28:24,690 --> 00:28:31,620
<font color="#CCCCCC">is this</font><font color="#E5E5E5"> doesn't create an edge it's with</font>

499
00:28:26,910 --> 00:28:33,060
slashes<font color="#E5E5E5"> so it creates paths and then</font>

500
00:28:31,620 --> 00:28:36,060
they are<font color="#E5E5E5"> - I try to explain that there</font>

501
00:28:33,060 --> 00:28:38,790
are two ways how that can happen<font color="#E5E5E5"> the</font>

502
00:28:36,060 --> 00:28:40,710
first<font color="#CCCCCC"> place that you just get all the</font>

503
00:28:38,790 --> 00:28:44,070
<font color="#E5E5E5">nodes and edges along these paths in</font>

504
00:28:40,710 --> 00:28:45,720
your result graph but then so it then

505
00:28:44,070 --> 00:28:49,230
you basically<font color="#E5E5E5"> would have what makes the</font>

506
00:28:45,720 --> 00:28:52,370
path but<font color="#E5E5E5"> not a new path object to also</font>

507
00:28:49,230 --> 00:28:55,020
get the path<font color="#CCCCCC"> object to be able</font><font color="#E5E5E5"> to assign</font>

508
00:28:52,370 --> 00:29:00,090
labels and properties you<font color="#CCCCCC"> have to add</font>

509
00:28:55,020 --> 00:29:02,280
this<font color="#CCCCCC"> add sign here and when you have</font>

510
00:29:00,090 --> 00:29:07,110
<font color="#E5E5E5">free shortest paths and you can think of</font>

511
00:29:02,280 --> 00:29:09,780
<font color="#E5E5E5">your boot for one binding of N and M you</font>

512
00:29:07,110 --> 00:29:10,889
<font color="#E5E5E5">will get</font><font color="#CCCCCC"> three bindings</font><font color="#E5E5E5"> of P so when</font>

513
00:29:09,780 --> 00:29:17,639
<font color="#E5E5E5">you're binding</font><font color="#CCCCCC"> tailor have would</font><font color="#E5E5E5"> have</font>

514
00:29:10,890 --> 00:29:22,730
basically<font color="#CCCCCC"> free Taplin</font><font color="#E5E5E5"> okay um so from</font>

515
00:29:17,640 --> 00:29:22,730
hop distance<font color="#CCCCCC"> to weighted shortest paths</font>

516
00:29:23,930 --> 00:29:31,620
for that<font color="#CCCCCC"> jiko includes the possibility</font>

517
00:29:27,090 --> 00:29:35,760
<font color="#CCCCCC">to describe path macros so a way where</font>

518
00:29:31,620 --> 00:29:38,010
you specify what the path should look

519
00:29:35,760 --> 00:29:40,740
<font color="#CCCCCC">like</font><font color="#E5E5E5"> and this</font><font color="#CCCCCC"> is done with the</font><font color="#E5E5E5"> keyboard</font>

520
00:29:38,010 --> 00:29:42,300
<font color="#E5E5E5">path and then we give this macro a name</font>

521
00:29:40,740 --> 00:29:45,510
and say equals and<font color="#E5E5E5"> then come</font><font color="#CCCCCC"> the</font>

522
00:29:42,300 --> 00:29:47,550
specification of the<font color="#E5E5E5"> path macro</font><font color="#CCCCCC"> so the</font>

523
00:29:45,510 --> 00:29:52,470
first thing is I<font color="#CCCCCC"> and you to specify</font><font color="#E5E5E5"> the</font>

524
00:29:47,550 --> 00:29:55,710
path macro by specifying a path step<font color="#E5E5E5"> so</font>

525
00:29:52,470 --> 00:29:58,380
fixed length or not necessarily<font color="#E5E5E5"> fixed</font>

526
00:29:55,710 --> 00:30:02,970
length<font color="#E5E5E5"> but in the simplest case with a</font>

527
00:29:58,380 --> 00:30:06,090
fixed length path pattern<font color="#E5E5E5"> from X 2 by 2</font>

528
00:30:02,970 --> 00:30:10,920
up from some node to another node<font color="#E5E5E5"> like</font>

529
00:30:06,090 --> 00:30:12,840
in that<font color="#CCCCCC"> case it's just one nose edge</font><font color="#E5E5E5"> but</font>

530
00:30:10,920 --> 00:30:14,010
it could be multiple<font color="#E5E5E5"> of those and also</font>

531
00:30:12,840 --> 00:30:17,340
<font color="#CCCCCC">in</font>

532
00:30:14,010 --> 00:30:21,929
<font color="#CCCCCC">forward or backward direction</font><font color="#E5E5E5"> and then</font>

533
00:30:17,340 --> 00:30:26,899
you can have my<font color="#CCCCCC"> fervor constraints on</font>

534
00:30:21,929 --> 00:30:30,630
these variables<font color="#E5E5E5"> and you can also specify</font>

535
00:30:26,899 --> 00:30:32,309
a cost function<font color="#E5E5E5"> if the keyword costs</font>

536
00:30:30,630 --> 00:30:35,760
here so that is not to<font color="#E5E5E5"> be confused with</font>

537
00:30:32,309 --> 00:30:40,519
the cost keyword in the match pattern

538
00:30:35,760 --> 00:30:44,010
but in the path<font color="#E5E5E5"> clause the cost keyword</font>

539
00:30:40,519 --> 00:30:47,340
<font color="#CCCCCC">tells us what how to compute the cost</font>

540
00:30:44,010 --> 00:30:51,360
and in that case we'll<font color="#CCCCCC"> just say or the</font>

541
00:30:47,340 --> 00:30:54,990
cost of<font color="#E5E5E5"> one</font><font color="#CCCCCC"> of these</font><font color="#E5E5E5"> paths steps is more</font>

542
00:30:51,360 --> 00:30:57,750
or less<font color="#E5E5E5"> the reciprocal of the number of</font>

543
00:30:54,990 --> 00:31:00,539
edges<font color="#E5E5E5"> so the more edges the lower the</font>

544
00:30:57,750 --> 00:31:03,600
<font color="#CCCCCC">costs just and the shorter</font><font color="#E5E5E5"> the path so</font>

545
00:31:00,539 --> 00:31:05,639
just<font color="#CCCCCC"> it and when you have such a path</font>

546
00:31:03,600 --> 00:31:08,600
<font color="#E5E5E5">pattern and then of</font><font color="#CCCCCC"> course you can query</font>

547
00:31:05,639 --> 00:31:14,158
again for shortest paths<font color="#E5E5E5"> over that</font>

548
00:31:08,600 --> 00:31:16,350
pattern<font color="#CCCCCC"> and then you would get weighted</font>

549
00:31:14,159 --> 00:31:23,850
shortest path semantics<font color="#E5E5E5"> so it would</font>

550
00:31:16,350 --> 00:31:25,740
<font color="#E5E5E5">actually find in that case all people or</font>

551
00:31:23,850 --> 00:31:30,799
they sort of<font color="#CCCCCC"> City</font><font color="#E5E5E5"> they're socially</font>

552
00:31:25,740 --> 00:31:34,080
closest people to<font color="#E5E5E5"> who John Doe knows and</font>

553
00:31:30,799 --> 00:31:37,679
<font color="#CCCCCC">well</font><font color="#E5E5E5"> I've also share an interest in into</font>

554
00:31:34,080 --> 00:31:41,220
the composer of composer Wagner<font color="#E5E5E5"> in that</font>

555
00:31:37,679 --> 00:31:45,330
case so<font color="#E5E5E5"> we</font><font color="#CCCCCC"> can do with that you are</font>

556
00:31:41,220 --> 00:31:50,190
really able<font color="#E5E5E5"> to express analytical query</font>

557
00:31:45,330 --> 00:31:52,980
so to say and here in<font color="#CCCCCC"> the construct</font>

558
00:31:50,190 --> 00:31:55,730
<font color="#CCCCCC">clause what we do is we have</font><font color="#E5E5E5"> the hatch</font>

559
00:31:52,980 --> 00:31:59,450
again so these paths we find<font color="#E5E5E5"> I actually</font>

560
00:31:55,730 --> 00:32:02,639
<font color="#E5E5E5">added as objects to</font><font color="#CCCCCC"> the output graph</font><font color="#E5E5E5"> and</font>

561
00:31:59,450 --> 00:32:05,460
how that<font color="#E5E5E5"> low</font><font color="#CCCCCC"> cloud does that look like</font>

562
00:32:02,639 --> 00:32:08,639
<font color="#E5E5E5">is</font><font color="#CCCCCC"> that we have the</font><font color="#E5E5E5"> original graph from</font>

563
00:32:05,460 --> 00:32:12,120
the view and additionally objects<font color="#E5E5E5"> this</font>

564
00:32:08,639 --> 00:32:14,928
which specify us the<font color="#E5E5E5"> the</font><font color="#CCCCCC"> paths we</font><font color="#E5E5E5"> are</font>

565
00:32:12,120 --> 00:32:14,928
find with the query

566
00:32:16,710 --> 00:32:23,970
okay with that<font color="#CCCCCC"> I'm Marla's done so</font><font color="#E5E5E5"> there</font>

567
00:32:20,759 --> 00:32:27,240
<font color="#CCCCCC">are what what are things that</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> think</font>

568
00:32:23,970 --> 00:32:30,690
<font color="#E5E5E5">are missing for now</font><font color="#CCCCCC"> of course</font><font color="#E5E5E5"> to be</font>

569
00:32:27,240 --> 00:32:36,149
really useful<font color="#CCCCCC"> a query language must we</font>

570
00:32:30,690 --> 00:32:39,440
also<font color="#E5E5E5"> be able</font><font color="#CCCCCC"> to sort of go out to</font><font color="#E5E5E5"> to</font>

571
00:32:36,149 --> 00:32:44,129
existing data<font color="#E5E5E5"> pots which are usually</font>

572
00:32:39,440 --> 00:32:47,690
relational data so we want to have a way

573
00:32:44,129 --> 00:32:54,869
<font color="#CCCCCC">to also have relational database as</font>

574
00:32:47,690 --> 00:32:58,919
<font color="#E5E5E5">result to be able to feed tabular data</font>

575
00:32:54,869 --> 00:33:01,830
into the query<font color="#E5E5E5"> makin isms set out</font><font color="#CCCCCC"> over</font>

576
00:32:58,919 --> 00:33:05,789
<font color="#CCCCCC">this</font><font color="#E5E5E5"> these are things we have discussed</font>

577
00:33:01,830 --> 00:33:07,649
but not considered in detail yet<font color="#E5E5E5"> okay</font>

578
00:33:05,789 --> 00:33:11,669
what is the<font color="#CCCCCC"> takeaway</font><font color="#E5E5E5"> on the takeaways</font>

579
00:33:07,649 --> 00:33:16,918
that<font color="#CCCCCC"> g</font><font color="#E5E5E5"> core is a query language proposal</font>

580
00:33:11,669 --> 00:33:19,649
<font color="#E5E5E5">first of all that which tries to propose</font>

581
00:33:16,919 --> 00:33:22,889
<font color="#E5E5E5">mayer graph query languages</font>

582
00:33:19,649 --> 00:33:26,639
should develop - so what are desirable

583
00:33:22,889 --> 00:33:30,418
features<font color="#E5E5E5"> and it's designed in a way</font><font color="#CCCCCC"> that</font>

584
00:33:26,639 --> 00:33:32,549
is<font color="#CCCCCC"> close composable</font><font color="#E5E5E5"> intractable so and</font>

585
00:33:30,419 --> 00:33:37,379
that since you can argue<font color="#CCCCCC"> that is that</font>

586
00:33:32,549 --> 00:33:39,809
it's<font color="#CCCCCC"> well-designed it's it's and it's</font>

587
00:33:37,379 --> 00:33:44,100
the outcome<font color="#CCCCCC"> of two or</font><font color="#E5E5E5"> two-and-a-half</font>

588
00:33:39,809 --> 00:33:47,879
week years<font color="#E5E5E5"> of work by</font><font color="#CCCCCC"> a mixed group of</font>

589
00:33:44,100 --> 00:33:49,769
people from academia<font color="#CCCCCC"> in industry so it</font>

590
00:33:47,879 --> 00:33:51,748
really<font color="#CCCCCC"> combines and in that sense</font><font color="#E5E5E5"> it's</font>

591
00:33:49,769 --> 00:33:56,480
<font color="#CCCCCC">sort of the first proposal</font><font color="#E5E5E5"> doing that it</font>

592
00:33:51,749 --> 00:34:01,350
combines two domains of experiences into

593
00:33:56,480 --> 00:34:05,369
one<font color="#E5E5E5"> design so to say if</font><font color="#CCCCCC"> you are</font>

594
00:34:01,350 --> 00:34:08,489
interested in<font color="#E5E5E5"> a DBC work there will be a</font>

595
00:34:05,369 --> 00:34:12,179
<font color="#E5E5E5">technical user community meeting in</font>

596
00:34:08,489 --> 00:34:16,739
Austin and when when<font color="#E5E5E5"> Sigma takes place</font>

597
00:34:12,179 --> 00:34:20,460
there in June<font color="#CCCCCC"> and these two links guide</font>

598
00:34:16,739 --> 00:34:22,439
you to the Chico and to a partial

599
00:34:20,460 --> 00:34:25,440
implementation for<font color="#E5E5E5"> the query languages</font>

600
00:34:22,440 --> 00:34:28,270
and with that I'm done and<font color="#CCCCCC"> thank you for</font>

601
00:34:25,440 --> 00:34:35,420
listening<font color="#E5E5E5"> and I'm open to</font><font color="#CCCCCC"> your questions</font>

602
00:34:28,270 --> 00:34:35,420
[Applause]

603
00:34:54,168 --> 00:35:03,970
so<font color="#CCCCCC"> d</font><font color="#E5E5E5"> so the question was why is Noah</font>

604
00:34:58,670 --> 00:35:08,059
that you think about<font color="#E5E5E5"> people involved the</font>

605
00:35:03,970 --> 00:35:09,770
language task force is was an open

606
00:35:08,059 --> 00:35:14,630
community<font color="#E5E5E5"> so people who have free to</font>

607
00:35:09,770 --> 00:35:20,210
join and apparently<font color="#CCCCCC"> know think about</font>

608
00:35:14,630 --> 00:35:33,980
<font color="#E5E5E5">people</font><font color="#CCCCCC"> we're involved apparently they're</font>

609
00:35:20,210 --> 00:35:38,299
<font color="#E5E5E5">not interested in I don't</font><font color="#CCCCCC"> know I think</font>

610
00:35:33,980 --> 00:35:41,799
<font color="#E5E5E5">this this D so the question is is this</font>

611
00:35:38,299 --> 00:35:47,930
query language into a interoperable with

612
00:35:41,799 --> 00:35:53,000
<font color="#CCCCCC">gremlin from Apache tinker</font><font color="#E5E5E5"> pop and I</font>

613
00:35:47,930 --> 00:35:57,078
think<font color="#E5E5E5"> this the the this language like</font>

614
00:35:53,000 --> 00:35:58,940
also<font color="#CCCCCC"> cypher and P gql are sort of</font><font color="#E5E5E5"> on a</font>

615
00:35:57,079 --> 00:36:03,230
<font color="#E5E5E5">different abstraction level or have a</font>

616
00:35:58,940 --> 00:36:06,770
<font color="#E5E5E5">different target and gremlin gremlin</font>

617
00:36:03,230 --> 00:36:11,359
really comes from a more imperative

618
00:36:06,770 --> 00:36:14,960
approach of specifying traverses over

619
00:36:11,359 --> 00:36:18,290
<font color="#CCCCCC">pair over graphs while year these</font>

620
00:36:14,960 --> 00:36:20,150
languages comes strictly from have

621
00:36:18,290 --> 00:36:22,400
having a declarative language<font color="#E5E5E5"> which</font>

622
00:36:20,150 --> 00:36:29,030
which builds on graph patterns<font color="#E5E5E5"> so at</font>

623
00:36:22,400 --> 00:36:31,480
<font color="#CCCCCC">different angles</font><font color="#E5E5E5"> and a more general for</font>

624
00:36:29,030 --> 00:36:34,700
more general<font color="#E5E5E5"> answer I would refer</font><font color="#CCCCCC"> to a</font>

625
00:36:31,480 --> 00:36:37,250
project<font color="#CCCCCC"> Stephan mentioned that there is</font>

626
00:36:34,700 --> 00:36:39,410
<font color="#E5E5E5">work</font><font color="#CCCCCC"> that tries to sort</font><font color="#E5E5E5"> of reconsolidate</font>

627
00:36:37,250 --> 00:36:40,750
these things and tries to<font color="#CCCCCC"> implement</font>

628
00:36:39,410 --> 00:36:44,529
cipher

629
00:36:40,750 --> 00:36:47,710
on<font color="#E5E5E5"> gremlin and if that is doable then it</font>

630
00:36:44,530 --> 00:36:56,650
would be<font color="#E5E5E5"> also doable for Chico welcome</font>

631
00:36:47,710 --> 00:37:01,340
more questions thank<font color="#E5E5E5"> you very much yeah</font>

632
00:36:56,650 --> 00:37:01,340
[Applause]

