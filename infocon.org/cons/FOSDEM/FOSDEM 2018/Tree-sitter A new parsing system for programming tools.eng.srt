1
00:00:04,620 --> 00:00:09,600
<font color="#E5E5E5">hi everyone</font><font color="#CCCCCC"> I'm max I work at github on</font>

2
00:00:07,439 --> 00:00:12,090
the<font color="#CCCCCC"> Adam text editor and I'm</font><font color="#E5E5E5"> gonna talk</font>

3
00:00:09,600 --> 00:00:13,670
about<font color="#CCCCCC"> a parsing library that</font><font color="#E5E5E5"> I've been</font>

4
00:00:12,090 --> 00:00:16,110
working<font color="#CCCCCC"> on</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> about four years now</font>

5
00:00:13,670 --> 00:00:17,820
<font color="#E5E5E5">initially as a side project and now as</font>

6
00:00:16,110 --> 00:00:20,849
<font color="#E5E5E5">part of some production systems</font><font color="#CCCCCC"> that</font>

7
00:00:17,820 --> 00:00:23,340
github<font color="#CCCCCC"> it's called tree sitter so I'm</font>

8
00:00:20,849 --> 00:00:24,720
gonna explain what it is<font color="#CCCCCC"> and why I chose</font>

9
00:00:23,340 --> 00:00:25,919
<font color="#CCCCCC">to write</font><font color="#E5E5E5"> it and then I'll talk about</font>

10
00:00:24,720 --> 00:00:27,808
some<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the things we're</font><font color="#CCCCCC"> doing</font><font color="#E5E5E5"> with</font><font color="#CCCCCC"> it</font>

11
00:00:25,919 --> 00:00:31,680
<font color="#CCCCCC">today</font><font color="#E5E5E5"> at github</font><font color="#CCCCCC"> and then finally I'll</font>

12
00:00:27,809 --> 00:00:34,620
talk<font color="#CCCCCC"> about how it works</font><font color="#E5E5E5"> so first what is</font>

13
00:00:31,680 --> 00:00:36,510
tree sitter<font color="#CCCCCC"> so</font><font color="#E5E5E5"> tree sitter is a library</font>

14
00:00:34,620 --> 00:00:39,209
for parsing source code<font color="#E5E5E5"> it's written in</font>

15
00:00:36,510 --> 00:00:42,239
<font color="#CCCCCC">c and c++ and it's designed to be used</font>

16
00:00:39,210 --> 00:00:43,649
<font color="#CCCCCC">in applications like</font><font color="#E5E5E5"> github</font><font color="#CCCCCC"> or atom that</font>

17
00:00:42,239 --> 00:00:46,320
<font color="#E5E5E5">have to deal</font><font color="#CCCCCC"> with code</font><font color="#E5E5E5"> written in many</font>

18
00:00:43,649 --> 00:00:48,300
<font color="#E5E5E5">different</font><font color="#CCCCCC"> languages</font><font color="#E5E5E5"> so the idea is you</font>

19
00:00:46,320 --> 00:00:49,199
can<font color="#CCCCCC"> use tree sitter to parse files</font>

20
00:00:48,300 --> 00:00:52,319
<font color="#E5E5E5">written in a variety of different</font>

21
00:00:49,199 --> 00:00:53,940
<font color="#CCCCCC">languages and it'll produce syntax trees</font>

22
00:00:52,320 --> 00:00:57,390
that all have the same<font color="#CCCCCC"> api and</font><font color="#E5E5E5"> the same</font>

23
00:00:53,940 --> 00:00:58,829
format<font color="#CCCCCC"> the really unique</font><font color="#E5E5E5"> thing the tree</font>

24
00:00:57,390 --> 00:01:01,199
sitter does is what's called incremental

25
00:00:58,829 --> 00:01:03,239
<font color="#E5E5E5">parsing so that means that once you</font>

26
00:01:01,199 --> 00:01:04,709
parse the file with tree sitter<font color="#E5E5E5"> and you</font>

27
00:01:03,239 --> 00:01:07,380
have the syntax tree representing<font color="#E5E5E5"> that</font>

28
00:01:04,709 --> 00:01:09,030
file<font color="#E5E5E5"> you can then edit the file and tree</font>

29
00:01:07,380 --> 00:01:10,949
sitter can quickly update the syntax

30
00:01:09,030 --> 00:01:12,960
tree for you to reflect<font color="#CCCCCC"> that the change</font>

31
00:01:10,950 --> 00:01:14,640
that<font color="#CCCCCC"> you made without</font><font color="#E5E5E5"> having to reparse</font>

32
00:01:12,960 --> 00:01:17,580
the whole file<font color="#CCCCCC"> so</font><font color="#E5E5E5"> it'll take something</font>

33
00:01:14,640 --> 00:01:19,260
less than<font color="#E5E5E5"> a millisecond so that this is</font>

34
00:01:17,580 --> 00:01:20,850
<font color="#E5E5E5">the feature</font><font color="#CCCCCC"> that makes it possible to</font>

35
00:01:19,260 --> 00:01:23,460
use tree sitter<font color="#CCCCCC"> in a text</font><font color="#E5E5E5"> editor like</font>

36
00:01:20,850 --> 00:01:28,440
<font color="#CCCCCC">atom to parse in real time while the</font>

37
00:01:23,460 --> 00:01:32,309
user<font color="#E5E5E5"> is typing</font><font color="#CCCCCC"> so now I'll explain</font><font color="#E5E5E5"> why I</font>

38
00:01:28,440 --> 00:01:32,820
chose<font color="#E5E5E5"> to write this so there are</font><font color="#CCCCCC"> already</font>

39
00:01:32,310 --> 00:01:35,070
exists

40
00:01:32,820 --> 00:01:37,830
good parsing tools<font color="#E5E5E5"> today that are</font>

41
00:01:35,070 --> 00:01:39,779
specific<font color="#CCCCCC"> to any given language if you</font>

42
00:01:37,830 --> 00:01:42,179
just want<font color="#CCCCCC"> a Parsi you can use Lib clang</font>

43
00:01:39,780 --> 00:01:45,270
if you want to parse go you can use the

44
00:01:42,180 --> 00:01:47,220
go ast package and so on and<font color="#E5E5E5"> yet I would</font>

45
00:01:45,270 --> 00:01:49,289
<font color="#E5E5E5">argue that</font><font color="#CCCCCC"> most of the tools that that</font>

46
00:01:47,220 --> 00:01:51,539
we rely on the most<font color="#E5E5E5"> as software</font>

47
00:01:49,290 --> 00:01:56,010
developers<font color="#E5E5E5"> still don't have good source</font>

48
00:01:51,540 --> 00:01:57,720
code parsing capabilities<font color="#CCCCCC"> so for</font><font color="#E5E5E5"> example</font>

49
00:01:56,010 --> 00:01:59,580
let's take<font color="#E5E5E5"> a look at some syntax</font>

50
00:01:57,720 --> 00:02:02,220
highlighting<font color="#E5E5E5"> that you might see in</font><font color="#CCCCCC"> your</font>

51
00:01:59,580 --> 00:02:04,200
text editor today<font color="#E5E5E5"> so</font><font color="#CCCCCC"> you're some go code</font>

52
00:02:02,220 --> 00:02:06,600
<font color="#CCCCCC">it's kind of hard to read but</font><font color="#E5E5E5"> it</font><font color="#CCCCCC"> defines</font>

53
00:02:04,200 --> 00:02:08,940
a person<font color="#E5E5E5"> type the thing about this is</font>

54
00:02:06,600 --> 00:02:10,410
<font color="#CCCCCC">you</font><font color="#E5E5E5"> can see here</font><font color="#CCCCCC"> that the types appear</font>

55
00:02:08,940 --> 00:02:12,359
in three<font color="#E5E5E5"> different colors in this</font>

56
00:02:10,410 --> 00:02:14,370
example the person<font color="#E5E5E5"> appears first in</font>

57
00:02:12,360 --> 00:02:16,260
yellow and then in white and then this

58
00:02:14,370 --> 00:02:17,860
<font color="#E5E5E5">other type string appears in pink for</font>

59
00:02:16,260 --> 00:02:19,750
<font color="#E5E5E5">some reason</font>

60
00:02:17,860 --> 00:02:21,040
this is a screenshot from<font color="#E5E5E5"> Adam</font><font color="#CCCCCC"> but you</font>

61
00:02:19,750 --> 00:02:25,959
<font color="#CCCCCC">can see the same thing happens in</font>

62
00:02:21,040 --> 00:02:28,569
sublime<font color="#CCCCCC"> text or</font><font color="#E5E5E5"> a visual studio code and</font>

63
00:02:25,959 --> 00:02:29,560
so this isn't<font color="#E5E5E5"> a good behavior and syntax</font>

64
00:02:28,569 --> 00:02:31,988
highlighting is something that we all

65
00:02:29,560 --> 00:02:33,670
use<font color="#CCCCCC"> all day every day whether we're</font>

66
00:02:31,989 --> 00:02:35,379
looking<font color="#E5E5E5"> at code in our editor or on a</font>

67
00:02:33,670 --> 00:02:38,980
<font color="#CCCCCC">website like</font><font color="#E5E5E5"> github or Stack Overflow</font>

68
00:02:35,379 --> 00:02:42,069
<font color="#CCCCCC">and so my question is with all</font><font color="#E5E5E5"> the good</font>

69
00:02:38,980 --> 00:02:44,409
parsing tools that<font color="#E5E5E5"> exist</font><font color="#CCCCCC"> today</font><font color="#E5E5E5"> why isn't</font>

70
00:02:42,069 --> 00:02:46,929
this<font color="#E5E5E5"> super-important feature implemented</font>

71
00:02:44,409 --> 00:02:49,030
<font color="#E5E5E5">better</font><font color="#CCCCCC"> and so I think there's kind</font><font color="#E5E5E5"> of</font>

72
00:02:46,930 --> 00:02:50,709
three main reasons<font color="#E5E5E5"> why these</font>

73
00:02:49,030 --> 00:02:52,389
applications<font color="#E5E5E5"> that I mentioned don't use</font>

74
00:02:50,709 --> 00:02:54,489
all these standard<font color="#CCCCCC"> partials that</font><font color="#E5E5E5"> we know</font>

75
00:02:52,389 --> 00:02:58,299
<font color="#CCCCCC">of the first one that comes to my mind</font>

76
00:02:54,489 --> 00:03:00,310
<font color="#E5E5E5">is for performance so in a text editor</font>

77
00:02:58,299 --> 00:03:02,349
<font color="#CCCCCC">for the editor</font><font color="#E5E5E5"> to feel lightweight and</font>

78
00:03:00,310 --> 00:03:03,939
fast<font color="#E5E5E5"> syntax highlighting should update</font>

79
00:03:02,349 --> 00:03:05,619
on every keystroke<font color="#E5E5E5"> and it needs to take</font>

80
00:03:03,939 --> 00:03:08,168
as I said less<font color="#CCCCCC"> than a millisecond or so</font>

81
00:03:05,620 --> 00:03:09,579
and so<font color="#E5E5E5"> that rules out right out</font><font color="#CCCCCC"> of the</font>

82
00:03:08,169 --> 00:03:12,489
gate most partners that we would

83
00:03:09,579 --> 00:03:14,950
<font color="#CCCCCC">normally use otherwise aside from that</font>

84
00:03:12,489 --> 00:03:16,510
<font color="#E5E5E5">for a lot</font><font color="#CCCCCC"> of languages to use the</font>

85
00:03:14,950 --> 00:03:18,608
standard<font color="#E5E5E5"> parser</font><font color="#CCCCCC"> that comes with the</font>

86
00:03:16,510 --> 00:03:21,399
compiler<font color="#E5E5E5"> you need to know some other</font>

87
00:03:18,609 --> 00:03:22,959
information<font color="#E5E5E5"> about the file in order to</font>

88
00:03:21,400 --> 00:03:25,859
parse the<font color="#E5E5E5"> file</font><font color="#CCCCCC"> like for example if</font>

89
00:03:22,959 --> 00:03:28,000
<font color="#E5E5E5">you're parsing</font><font color="#CCCCCC"> C you would</font><font color="#E5E5E5"> need to know</font>

90
00:03:25,859 --> 00:03:30,010
all the<font color="#E5E5E5"> other source files that are</font>

91
00:03:28,000 --> 00:03:32,859
included via the preprocessor and the

92
00:03:30,010 --> 00:03:35,560
what macros are defined and so on and in

93
00:03:32,859 --> 00:03:37,329
an environment<font color="#CCCCCC"> like Adam or github</font><font color="#E5E5E5"> where</font>

94
00:03:35,560 --> 00:03:38,799
we're<font color="#CCCCCC"> trying</font><font color="#E5E5E5"> to work with the code of</font>

95
00:03:37,329 --> 00:03:42,579
strangers we don't always know<font color="#E5E5E5"> this</font>

96
00:03:38,799 --> 00:03:44,739
<font color="#CCCCCC">information and finally each languages</font>

97
00:03:42,579 --> 00:03:46,540
standard parsing tool chain has its own

98
00:03:44,739 --> 00:03:49,030
dependencies is often written in that

99
00:03:46,540 --> 00:03:50,168
<font color="#E5E5E5">language</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> so for apps that</font><font color="#CCCCCC"> need to</font>

100
00:03:49,030 --> 00:03:52,810
<font color="#E5E5E5">work with tons of languages</font>

101
00:03:50,169 --> 00:03:54,489
out-of-the-box<font color="#CCCCCC"> having to integrate with</font>

102
00:03:52,810 --> 00:03:57,340
all those tool chains would be very

103
00:03:54,489 --> 00:03:59,889
complicated<font color="#CCCCCC"> for our system and so what I</font>

104
00:03:57,340 --> 00:04:01,629
set out<font color="#CCCCCC"> to do with tree sitter was to</font>

105
00:03:59,889 --> 00:04:03,819
build a<font color="#E5E5E5"> one parsing system that could</font>

106
00:04:01,629 --> 00:04:06,548
not only<font color="#E5E5E5"> handle all major programming</font>

107
00:04:03,819 --> 00:04:08,319
languages<font color="#E5E5E5"> uniformly but could also do so</font>

108
00:04:06,549 --> 00:04:10,030
within these constraints<font color="#E5E5E5"> so it's it can</font>

109
00:04:08,319 --> 00:04:11,220
be fast<font color="#E5E5E5"> enough</font><font color="#CCCCCC"> to run</font><font color="#E5E5E5"> on every keystroke</font>

110
00:04:10,030 --> 00:04:13,449
in a text editor

111
00:04:11,220 --> 00:04:15,669
and it doesn't<font color="#CCCCCC"> require</font><font color="#E5E5E5"> any</font><font color="#CCCCCC"> additional</font>

112
00:04:13,449 --> 00:04:20,049
information<font color="#CCCCCC"> about</font><font color="#E5E5E5"> a source file in order</font>

113
00:04:15,669 --> 00:04:22,060
to parse it<font color="#CCCCCC"> and has no dependencies in</font>

114
00:04:20,048 --> 00:04:23,888
fact it's it's implemented<font color="#E5E5E5"> the runtime</font>

115
00:04:22,060 --> 00:04:25,930
is implemented as a pure C library so

116
00:04:23,889 --> 00:04:27,310
you<font color="#E5E5E5"> can really easily use</font><font color="#CCCCCC"> it no</font><font color="#E5E5E5"> matter</font>

117
00:04:25,930 --> 00:04:29,020
<font color="#E5E5E5">what language your application is</font>

118
00:04:27,310 --> 00:04:31,280
written<font color="#E5E5E5"> in</font>

119
00:04:29,020 --> 00:04:33,049
all right so that's<font color="#E5E5E5"> the pitch and I'll</font>

120
00:04:31,280 --> 00:04:39,008
show you<font color="#E5E5E5"> what we're currently doing with</font>

121
00:04:33,050 --> 00:04:41,569
<font color="#CCCCCC">Tree Center at github so this some the</font>

122
00:04:39,009 --> 00:04:44,389
latest beta release of<font color="#E5E5E5"> Adam this month</font>

123
00:04:41,569 --> 00:04:46,729
will include<font color="#E5E5E5"> some</font><font color="#CCCCCC"> new functionality</font><font color="#E5E5E5"> the</font>

124
00:04:44,389 --> 00:04:48,560
<font color="#CCCCCC">users tree sitter</font><font color="#E5E5E5"> it's still I'm still</font>

125
00:04:46,729 --> 00:04:49,909
<font color="#E5E5E5">developing</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> it's a bit unstable so</font>

126
00:04:48,560 --> 00:04:52,219
it's behind a feature<font color="#E5E5E5"> flag do you'll</font>

127
00:04:49,909 --> 00:04:54,710
have<font color="#CCCCCC"> to</font><font color="#E5E5E5"> check a box if you want to try</font>

128
00:04:52,219 --> 00:04:57,680
<font color="#E5E5E5">it but if</font><font color="#CCCCCC"> you do you'll</font><font color="#E5E5E5"> get this new</font>

129
00:04:54,710 --> 00:04:59,090
improved<font color="#E5E5E5"> syntax highlighting that that</font>

130
00:04:57,680 --> 00:05:01,430
I'm showing<font color="#E5E5E5"> here</font><font color="#CCCCCC"> so this is the same</font>

131
00:04:59,090 --> 00:05:03,378
piece of<font color="#CCCCCC"> go</font><font color="#E5E5E5"> code that I that I pointed</font>

132
00:05:01,430 --> 00:05:05,150
<font color="#CCCCCC">to earlier</font><font color="#E5E5E5"> but now you can see that the</font>

133
00:05:03,379 --> 00:05:07,580
problem<font color="#CCCCCC"> that I mentioned has been fixed</font>

134
00:05:05,150 --> 00:05:10,340
really<font color="#CCCCCC"> nicely all the types consistently</font>

135
00:05:07,580 --> 00:05:11,930
<font color="#E5E5E5">appear in this blue green color and on</font>

136
00:05:10,340 --> 00:05:14,000
top of<font color="#CCCCCC"> that</font><font color="#E5E5E5"> all the</font><font color="#CCCCCC"> strut field names</font>

137
00:05:11,930 --> 00:05:16,189
are<font color="#E5E5E5"> now differentiated</font><font color="#CCCCCC"> there they're red</font>

138
00:05:14,000 --> 00:05:17,830
<font color="#E5E5E5">whereas before the syntax highlighter</font>

139
00:05:16,189 --> 00:05:22,099
couldn't even tell<font color="#CCCCCC"> struct fields from</font>

140
00:05:17,830 --> 00:05:24,800
local variables so this<font color="#E5E5E5"> is go we also</font>

141
00:05:22,099 --> 00:05:29,300
can do the<font color="#E5E5E5"> same thing in other languages</font>

142
00:05:24,800 --> 00:05:34,580
<font color="#CCCCCC">like C C++</font><font color="#E5E5E5"> typescript as well as</font>

143
00:05:29,300 --> 00:05:36,620
JavaScript Python Ruby<font color="#E5E5E5"> and rust and</font>

144
00:05:34,580 --> 00:05:40,419
we're in the process<font color="#CCCCCC"> of developing</font>

145
00:05:36,620 --> 00:05:43,430
support for a bunch more<font color="#E5E5E5"> languages</font><font color="#CCCCCC"> too</font>

146
00:05:40,419 --> 00:05:46,190
so aside<font color="#CCCCCC"> from those improvements another</font>

147
00:05:43,430 --> 00:05:47,779
benefit<font color="#CCCCCC"> of doing syntax highlighting</font>

148
00:05:46,190 --> 00:05:50,659
with tree sitter is the handling of<font color="#E5E5E5"> long</font>

149
00:05:47,779 --> 00:05:52,909
lines so if any<font color="#E5E5E5"> of you've</font><font color="#CCCCCC"> ever opened</font><font color="#E5E5E5"> up</font>

150
00:05:50,659 --> 00:05:54,949
a minified javascript file<font color="#CCCCCC"> in a almost</font>

151
00:05:52,909 --> 00:05:56,900
any text editor<font color="#CCCCCC"> like vim or Atom</font><font color="#E5E5E5"> you'll</font>

152
00:05:54,949 --> 00:05:58,159
often see a<font color="#E5E5E5"> little tiny bit of syntax</font>

153
00:05:56,900 --> 00:06:00,378
highlighting at the very beginning of

154
00:05:58,159 --> 00:06:02,229
the file and then<font color="#CCCCCC"> mostly a black and</font>

155
00:06:00,379 --> 00:06:05,810
white file because of this<font color="#E5E5E5"> performance</font>

156
00:06:02,229 --> 00:06:06,860
limitation of conventional<font color="#E5E5E5"> regex based</font>

157
00:06:05,810 --> 00:06:09,589
syntax highlighters

158
00:06:06,860 --> 00:06:11,569
so by reimplemented syntax highlighting

159
00:06:09,589 --> 00:06:13,460
with tree sitter<font color="#E5E5E5"> the layout</font><font color="#CCCCCC"> of the file</font>

160
00:06:11,569 --> 00:06:17,180
no longer matters it's using a proper

161
00:06:13,460 --> 00:06:20,979
lexing and parsing<font color="#E5E5E5"> tool chain so</font><font color="#CCCCCC"> we can</font>

162
00:06:17,180 --> 00:06:20,979
<font color="#E5E5E5">weaken syntax highlight files like this</font>

163
00:06:21,750 --> 00:06:27,570
and then aside<font color="#E5E5E5"> from the handling of long</font>

164
00:06:24,720 --> 00:06:29,280
<font color="#E5E5E5">lines overall performance of syntax</font>

165
00:06:27,570 --> 00:06:30,900
highlighting is just<font color="#E5E5E5"> dramatically</font>

166
00:06:29,280 --> 00:06:34,289
improved as<font color="#CCCCCC"> well so on this</font><font color="#E5E5E5"> slide</font><font color="#CCCCCC"> I'm</font>

167
00:06:30,900 --> 00:06:35,130
just showing an<font color="#E5E5E5"> example of parsing at</font>

168
00:06:34,290 --> 00:06:37,860
the command line

169
00:06:35,130 --> 00:06:39,930
some<font color="#E5E5E5"> 20,000 line</font><font color="#CCCCCC"> JavaScript file like</font>

170
00:06:37,860 --> 00:06:42,590
the<font color="#E5E5E5"> development build of react</font><font color="#CCCCCC"> j/s and</font>

171
00:06:39,930 --> 00:06:45,840
it takes about 69 milliseconds which<font color="#CCCCCC"> is</font>

172
00:06:42,590 --> 00:06:47,609
I want to<font color="#E5E5E5"> say not</font><font color="#CCCCCC"> quite an order of</font>

173
00:06:45,840 --> 00:06:49,200
magnitude but much faster<font color="#CCCCCC"> than the</font>

174
00:06:47,610 --> 00:06:51,270
syntax highlighting systems used in

175
00:06:49,200 --> 00:06:53,719
normal<font color="#E5E5E5"> editors like</font><font color="#CCCCCC"> Adam Visual Studio</font>

176
00:06:51,270 --> 00:06:57,299
<font color="#E5E5E5">code yeah</font>

177
00:06:53,720 --> 00:06:59,760
so aside from syntax highlighting I've

178
00:06:57,300 --> 00:07:02,310
also reimplemented<font color="#E5E5E5"> Adams code folding</font>

179
00:06:59,760 --> 00:07:06,330
system<font color="#E5E5E5"> to use the syntax trees that's</font>

180
00:07:02,310 --> 00:07:09,570
provided by tree sitter<font color="#E5E5E5"> so as you might</font>

181
00:07:06,330 --> 00:07:11,580
be aware<font color="#E5E5E5"> in in most text editors code</font>

182
00:07:09,570 --> 00:07:14,669
folding was based on some combination of

183
00:07:11,580 --> 00:07:16,859
reg X's but often<font color="#E5E5E5"> indentation so if you</font>

184
00:07:14,669 --> 00:07:18,810
have a<font color="#CCCCCC"> C function like</font><font color="#E5E5E5"> this which is</font>

185
00:07:16,860 --> 00:07:21,510
<font color="#CCCCCC">very</font><font color="#E5E5E5"> common where the indentation of the</font>

186
00:07:18,810 --> 00:07:23,910
file<font color="#E5E5E5"> doesn't match the syntax of the</font>

187
00:07:21,510 --> 00:07:28,760
file<font color="#E5E5E5"> exactly</font><font color="#CCCCCC"> code folding doesn't work</font>

188
00:07:23,910 --> 00:07:30,990
as you would intend<font color="#E5E5E5"> but now by by</font>

189
00:07:28,760 --> 00:07:33,630
re-implementing code folding based on

190
00:07:30,990 --> 00:07:35,340
the<font color="#E5E5E5"> syntax tree it now works</font><font color="#CCCCCC"> regardless</font>

191
00:07:33,630 --> 00:07:37,440
of what you do<font color="#E5E5E5"> to the formatting</font><font color="#CCCCCC"> of your</font>

192
00:07:35,340 --> 00:07:39,270
file so if you copy<font color="#E5E5E5"> and</font><font color="#CCCCCC"> paste code and</font>

193
00:07:37,440 --> 00:07:40,830
this indentation gets messed up you can

194
00:07:39,270 --> 00:07:44,700
still use folding as a guide<font color="#CCCCCC"> to the</font>

195
00:07:40,830 --> 00:07:46,289
structure of<font color="#CCCCCC"> your</font><font color="#E5E5E5"> code</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> then finally</font>

196
00:07:44,700 --> 00:07:47,490
we have added a new<font color="#CCCCCC"> feature to</font><font color="#E5E5E5"> Adam in</font>

197
00:07:46,290 --> 00:07:49,830
this latest<font color="#E5E5E5"> beta</font>

198
00:07:47,490 --> 00:07:51,060
<font color="#E5E5E5">it's called extend selection you you</font>

199
00:07:49,830 --> 00:07:54,330
might<font color="#E5E5E5"> be familiar</font><font color="#CCCCCC"> with it if you've</font><font color="#E5E5E5"> ever</font>

200
00:07:51,060 --> 00:07:57,210
used<font color="#CCCCCC"> the jetbrains</font><font color="#E5E5E5"> IDE it's a it's a</font>

201
00:07:54,330 --> 00:07:58,890
command for expect<font color="#E5E5E5"> selecting larger and</font>

202
00:07:57,210 --> 00:08:02,700
larger<font color="#E5E5E5"> pieces</font><font color="#CCCCCC"> of your code based on the</font>

203
00:07:58,890 --> 00:08:04,620
<font color="#E5E5E5">syntax so it's</font><font color="#CCCCCC"> it's</font><font color="#E5E5E5"> really powerful for</font>

204
00:08:02,700 --> 00:08:06,770
editing efficiency it combines really

205
00:08:04,620 --> 00:08:09,930
<font color="#E5E5E5">well with multiple cursors in this</font>

206
00:08:06,770 --> 00:08:11,580
animated<font color="#E5E5E5"> gif here</font><font color="#CCCCCC"> I'm reformatting this</font>

207
00:08:09,930 --> 00:08:14,160
data<font color="#E5E5E5"> structure in this really powerful</font>

208
00:08:11,580 --> 00:08:16,440
<font color="#E5E5E5">way using a combination of extend</font>

209
00:08:14,160 --> 00:08:17,970
selection and multiple cursors<font color="#CCCCCC"> that</font>

210
00:08:16,440 --> 00:08:19,830
would be really<font color="#CCCCCC"> time-consuming</font><font color="#E5E5E5"> if you</font>

211
00:08:17,970 --> 00:08:22,160
had to individually move<font color="#E5E5E5"> each cursor</font>

212
00:08:19,830 --> 00:08:22,159
<font color="#CCCCCC">around</font>

213
00:08:22,500 --> 00:08:29,010
so aside from<font color="#E5E5E5"> Adam we're also using tree</font>

214
00:08:26,010 --> 00:08:31,200
sitter<font color="#E5E5E5"> on github.com</font><font color="#CCCCCC"> so some of</font><font color="#E5E5E5"> you may</font>

215
00:08:29,010 --> 00:08:32,849
<font color="#CCCCCC">have seen a feature come out a</font><font color="#E5E5E5"> few</font>

216
00:08:31,200 --> 00:08:34,770
<font color="#E5E5E5">months ago on github where when you're</font>

217
00:08:32,849 --> 00:08:35,219
looking at a pull<font color="#CCCCCC"> request and you open</font>

218
00:08:34,770 --> 00:08:37,728
up the

219
00:08:35,219 --> 00:08:40,500
<font color="#CCCCCC">of changed files for</font><font color="#E5E5E5"> that pull request</font>

220
00:08:37,729 --> 00:08:42,959
<font color="#CCCCCC">now you can see within</font><font color="#E5E5E5"> each file a list</font>

221
00:08:40,500 --> 00:08:46,829
of the functions that<font color="#CCCCCC"> have changed and</font>

222
00:08:42,958 --> 00:08:48,689
this<font color="#E5E5E5"> is done by a team in github data</font>

223
00:08:46,829 --> 00:08:51,569
science organization that is doing a<font color="#E5E5E5"> lot</font>

224
00:08:48,689 --> 00:08:53,730
of<font color="#E5E5E5"> cool research about algorithms for</font>

225
00:08:51,569 --> 00:08:56,639
analyzing<font color="#E5E5E5"> and comparing syntax trees to</font>

226
00:08:53,730 --> 00:08:58,800
each other<font color="#E5E5E5"> and they use tree sitter for</font>

227
00:08:56,639 --> 00:09:00,930
all of their code parsing because it

228
00:08:58,800 --> 00:09:02,819
gives them<font color="#E5E5E5"> this uniform way of parsing</font>

229
00:09:00,930 --> 00:09:05,638
<font color="#CCCCCC">many different programming</font><font color="#E5E5E5"> languages and</font>

230
00:09:02,819 --> 00:09:07,829
so between<font color="#CCCCCC"> the work that they're doing</font>

231
00:09:05,639 --> 00:09:09,839
on github.com<font color="#E5E5E5"> and the work that</font><font color="#CCCCCC"> I'm</font>

232
00:09:07,829 --> 00:09:12,149
doing<font color="#E5E5E5"> on</font><font color="#CCCCCC"> Adam we're developing this</font>

233
00:09:09,839 --> 00:09:14,339
larger and larger set of languages<font color="#CCCCCC"> that</font>

234
00:09:12,149 --> 00:09:16,230
tree sitter can parse<font color="#E5E5E5"> and I think that</font>

235
00:09:14,339 --> 00:09:19,800
once these<font color="#CCCCCC"> Adam features that</font><font color="#E5E5E5"> I showed</font>

236
00:09:16,230 --> 00:09:22,500
you<font color="#CCCCCC"> a moment ago</font><font color="#E5E5E5"> go</font><font color="#CCCCCC"> R go to the stable</font>

237
00:09:19,800 --> 00:09:24,839
release<font color="#CCCCCC"> of Adam</font><font color="#E5E5E5"> then that set of</font>

238
00:09:22,500 --> 00:09:27,300
partials will grow<font color="#CCCCCC"> even faster because</font>

239
00:09:24,839 --> 00:09:29,250
now all<font color="#E5E5E5"> this community of millions of</font>

240
00:09:27,300 --> 00:09:31,649
<font color="#CCCCCC">Adam users will be able to contribute</font>

241
00:09:29,250 --> 00:09:33,839
support for their favorite languages in

242
00:09:31,649 --> 00:09:35,819
<font color="#CCCCCC">adam and so the</font><font color="#E5E5E5"> the dream is</font><font color="#CCCCCC"> that you'll</font>

243
00:09:33,839 --> 00:09:37,949
<font color="#E5E5E5">be able to use this tool</font><font color="#CCCCCC"> to parse any</font>

244
00:09:35,819 --> 00:09:41,610
programming<font color="#E5E5E5"> language</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> you can think</font>

245
00:09:37,949 --> 00:09:45,059
of<font color="#E5E5E5"> so now let's talk about how tree</font>

246
00:09:41,610 --> 00:09:47,250
sitter works<font color="#E5E5E5"> so when you want to add</font>

247
00:09:45,059 --> 00:09:49,199
<font color="#E5E5E5">support for parsing a new</font><font color="#CCCCCC"> language with</font>

248
00:09:47,250 --> 00:09:52,050
tree sitter<font color="#E5E5E5"> as you might expect you have</font>

249
00:09:49,199 --> 00:09:54,120
<font color="#E5E5E5">to write a grammar for the language and</font>

250
00:09:52,050 --> 00:09:56,758
<font color="#CCCCCC">with tree sitter you</font><font color="#E5E5E5"> write the grammar</font>

251
00:09:54,120 --> 00:09:58,500
in a simple<font color="#CCCCCC"> JavaScript</font><font color="#E5E5E5"> DSL that I made</font>

252
00:09:56,759 --> 00:10:00,480
and the advantage of this is that

253
00:09:58,500 --> 00:10:02,670
<font color="#E5E5E5">grammars are represented as plain</font>

254
00:10:00,480 --> 00:10:04,649
<font color="#E5E5E5">JavaScript objects and so you can</font>

255
00:10:02,670 --> 00:10:07,349
manipulate<font color="#E5E5E5"> them programmatically and you</font>

256
00:10:04,649 --> 00:10:10,559
can you can<font color="#E5E5E5"> extend them so it makes it</font>

257
00:10:07,350 --> 00:10:13,259
really intuitive<font color="#E5E5E5"> to write a grammar that</font>

258
00:10:10,559 --> 00:10:16,319
<font color="#CCCCCC">is</font><font color="#E5E5E5"> based off</font><font color="#CCCCCC"> of another</font><font color="#E5E5E5"> grammar which I</font>

259
00:10:13,259 --> 00:10:18,300
do<font color="#CCCCCC"> in</font><font color="#E5E5E5"> order</font><font color="#CCCCCC"> to define the</font><font color="#E5E5E5"> C++ grammar in</font>

260
00:10:16,319 --> 00:10:19,529
terms<font color="#CCCCCC"> of the C grammar and the</font>

261
00:10:18,300 --> 00:10:22,258
typescript grammar in<font color="#CCCCCC"> terms</font><font color="#E5E5E5"> of the</font>

262
00:10:19,529 --> 00:10:23,490
JavaScript grammar and then once you've

263
00:10:22,259 --> 00:10:24,540
<font color="#E5E5E5">written your grammar tree</font><font color="#CCCCCC"> sitter will</font>

264
00:10:23,490 --> 00:10:27,389
generate for<font color="#CCCCCC"> you</font>

265
00:10:24,540 --> 00:10:30,360
the single C file that as I said has no

266
00:10:27,389 --> 00:10:33,089
dependencies<font color="#CCCCCC"> and has two main</font><font color="#E5E5E5"> pieces of</font>

267
00:10:30,360 --> 00:10:35,100
data in it<font color="#CCCCCC"> it's has what's called</font><font color="#E5E5E5"> the</font>

268
00:10:33,089 --> 00:10:38,370
the tokenizing function which reads the

269
00:10:35,100 --> 00:10:39,959
<font color="#CCCCCC">the</font><font color="#E5E5E5"> sequence of characters from</font>

270
00:10:38,370 --> 00:10:42,839
beginning to<font color="#CCCCCC"> end and groups</font><font color="#E5E5E5"> them into</font>

271
00:10:39,959 --> 00:10:45,239
tokens<font color="#CCCCCC"> as well as what's called</font><font color="#E5E5E5"> the</font>

272
00:10:42,839 --> 00:10:47,189
parse table which is<font color="#E5E5E5"> this data structure</font>

273
00:10:45,240 --> 00:10:48,720
that<font color="#E5E5E5"> tells the parser when it's in a</font>

274
00:10:47,189 --> 00:10:51,680
given<font color="#CCCCCC"> state what</font>

275
00:10:48,720 --> 00:10:55,170
<font color="#E5E5E5">to do when it sees a given token and</font>

276
00:10:51,680 --> 00:10:57,149
then you can use these parsers<font color="#CCCCCC"> in</font>

277
00:10:55,170 --> 00:10:59,040
<font color="#E5E5E5">combination with this small pure</font><font color="#CCCCCC"> C</font>

278
00:10:57,149 --> 00:11:01,529
library called<font color="#E5E5E5"> the tree sitter runtime</font>

279
00:10:59,040 --> 00:11:04,139
<font color="#E5E5E5">which defines a few types that you can</font>

280
00:11:01,529 --> 00:11:06,360
<font color="#CCCCCC">use to parse files and then it</font><font color="#E5E5E5"> gives you</font>

281
00:11:04,139 --> 00:11:08,879
the<font color="#E5E5E5"> simple API</font><font color="#CCCCCC"> for dealing</font><font color="#E5E5E5"> with</font><font color="#CCCCCC"> syntax</font>

282
00:11:06,360 --> 00:11:09,860
tree<font color="#E5E5E5"> that's it's kind of like the Dom in</font>

283
00:11:08,879 --> 00:11:12,420
JavaScript

284
00:11:09,860 --> 00:11:14,699
this is shows an example<font color="#E5E5E5"> of</font><font color="#CCCCCC"> using the</font>

285
00:11:12,420 --> 00:11:17,250
<font color="#E5E5E5">Rossi API but usually we use it through</font>

286
00:11:14,699 --> 00:11:21,000
<font color="#E5E5E5">bindings to either JavaScript or to</font>

287
00:11:17,250 --> 00:11:22,589
Haskell so that's what it<font color="#E5E5E5"> looks like to</font>

288
00:11:21,000 --> 00:11:23,970
use the system<font color="#CCCCCC"> I'll now talk</font><font color="#E5E5E5"> about some</font>

289
00:11:22,589 --> 00:11:26,579
<font color="#CCCCCC">of</font><font color="#E5E5E5"> the algorithms</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> it uses</font>

290
00:11:23,970 --> 00:11:28,110
<font color="#E5E5E5">internally so they're mostly based on</font>

291
00:11:26,579 --> 00:11:31,769
some research that<font color="#E5E5E5"> was</font><font color="#CCCCCC"> done</font><font color="#E5E5E5"> at UC</font>

292
00:11:28,110 --> 00:11:33,750
Berkeley in<font color="#CCCCCC"> the 1990s about IDE s in a</font>

293
00:11:31,769 --> 00:11:35,459
particular this one PhD thesis<font color="#E5E5E5"> called</font>

294
00:11:33,750 --> 00:11:37,470
practical algorithms for<font color="#E5E5E5"> incremental</font>

295
00:11:35,459 --> 00:11:40,439
software development environments that

296
00:11:37,470 --> 00:11:43,259
outlines if you're building an IDE

297
00:11:40,439 --> 00:11:44,759
<font color="#E5E5E5">what's the best sort of basic parsing</font>

298
00:11:43,259 --> 00:11:46,470
theory to rely on and then how<font color="#E5E5E5"> to</font>

299
00:11:44,759 --> 00:11:48,629
augment that<font color="#E5E5E5"> theory so that</font><font color="#CCCCCC"> it works</font>

300
00:11:46,470 --> 00:11:50,850
<font color="#CCCCCC">ingor incremental II</font><font color="#E5E5E5"> to handle these</font>

301
00:11:48,629 --> 00:11:53,189
fast<font color="#CCCCCC"> edits</font><font color="#E5E5E5"> and then</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> proves that these</font>

302
00:11:50,850 --> 00:11:55,769
this incremental<font color="#CCCCCC"> version has these good</font>

303
00:11:53,189 --> 00:11:58,170
performance properties<font color="#CCCCCC"> and so the basic</font>

304
00:11:55,769 --> 00:12:00,209
<font color="#E5E5E5">parsing theory that it uses is LR</font>

305
00:11:58,170 --> 00:12:02,160
parsing which many of you<font color="#E5E5E5"> are probably</font>

306
00:12:00,209 --> 00:12:03,899
<font color="#E5E5E5">familiar with but I'll just go over</font><font color="#CCCCCC"> it</font>

307
00:12:02,160 --> 00:12:06,209
quickly<font color="#CCCCCC"> here since some of</font><font color="#E5E5E5"> the more</font>

308
00:12:03,899 --> 00:12:09,029
unique<font color="#E5E5E5"> parts of trees</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> are build on</font>

309
00:12:06,209 --> 00:12:10,649
LR parsing so the idea is with an LR

310
00:12:09,029 --> 00:12:12,149
parser we we read the sequence<font color="#E5E5E5"> of</font>

311
00:12:10,649 --> 00:12:15,149
<font color="#CCCCCC">characters from beginning to end without</font>

312
00:12:12,149 --> 00:12:16,589
<font color="#E5E5E5">ever backtracking and as we go we</font><font color="#CCCCCC"> group</font>

313
00:12:15,149 --> 00:12:19,319
the characters together<font color="#E5E5E5"> into</font><font color="#CCCCCC"> tokens</font>

314
00:12:16,589 --> 00:12:21,680
<font color="#CCCCCC">using</font><font color="#E5E5E5"> the tokenizer function which</font><font color="#CCCCCC"> i</font>

315
00:12:19,319 --> 00:12:24,269
mentioned<font color="#E5E5E5"> earlier in the generated</font><font color="#CCCCCC"> code</font>

316
00:12:21,680 --> 00:12:27,239
<font color="#CCCCCC">and then we group those tokens together</font>

317
00:12:24,269 --> 00:12:29,879
into larger<font color="#CCCCCC"> and larger sub trees</font><font color="#E5E5E5"> which</font>

318
00:12:27,240 --> 00:12:31,680
we store<font color="#E5E5E5"> on a stack</font><font color="#CCCCCC"> and at every</font><font color="#E5E5E5"> step of</font>

319
00:12:29,879 --> 00:12:34,769
the<font color="#E5E5E5"> way we decide what to do</font><font color="#CCCCCC"> with the</font>

320
00:12:31,680 --> 00:12:36,149
stack by consulting that parse parse

321
00:12:34,769 --> 00:12:38,939
table which was the second piece of

322
00:12:36,149 --> 00:12:40,680
generated code<font color="#CCCCCC"> I showed and so when</font>

323
00:12:38,939 --> 00:12:43,110
parsing a simple math expression like x

324
00:12:40,680 --> 00:12:43,829
times y plus<font color="#E5E5E5"> Z it would sort</font><font color="#CCCCCC"> of progress</font>

325
00:12:43,110 --> 00:12:45,870
in this<font color="#E5E5E5"> way</font>

326
00:12:43,829 --> 00:12:48,420
we start out with<font color="#E5E5E5"> an empty stack and</font>

327
00:12:45,870 --> 00:12:50,759
then we'd push the first<font color="#E5E5E5"> three</font><font color="#CCCCCC"> tokens</font>

328
00:12:48,420 --> 00:12:52,889
<font color="#CCCCCC">onto the stack but when we</font><font color="#E5E5E5"> get to the</font>

329
00:12:50,759 --> 00:12:55,019
plus we would do a<font color="#E5E5E5"> different</font><font color="#CCCCCC"> type of</font>

330
00:12:52,889 --> 00:12:57,360
action called a reduction<font color="#E5E5E5"> where we pop</font>

331
00:12:55,019 --> 00:12:58,860
three nodes off of the stack and group

332
00:12:57,360 --> 00:13:00,660
them into<font color="#E5E5E5"> a new parent node called a</font>

333
00:12:58,860 --> 00:13:02,040
product<font color="#CCCCCC"> and push that back</font><font color="#E5E5E5"> onto the</font>

334
00:13:00,660 --> 00:13:04,110
stack in their place

335
00:13:02,040 --> 00:13:06,959
and then similarly we'd push the plus

336
00:13:04,110 --> 00:13:08,250
and the<font color="#E5E5E5"> Z on to the stack and at the end</font>

337
00:13:06,960 --> 00:13:10,920
of<font color="#CCCCCC"> the file we do another reduction</font>

338
00:13:08,250 --> 00:13:13,500
<font color="#E5E5E5">which so we'd pop off the</font><font color="#CCCCCC"> some are sorry</font>

339
00:13:10,920 --> 00:13:15,510
the<font color="#E5E5E5"> product the plus and the</font><font color="#CCCCCC"> Z and</font><font color="#E5E5E5"> group</font>

340
00:13:13,500 --> 00:13:20,430
them together into<font color="#E5E5E5"> a new parent node and</font>

341
00:13:15,510 --> 00:13:22,230
that<font color="#E5E5E5"> would be the final tree</font><font color="#CCCCCC"> so you</font>

342
00:13:20,430 --> 00:13:23,880
might ask like<font color="#CCCCCC"> okay one of</font><font color="#E5E5E5"> the stated</font>

343
00:13:22,230 --> 00:13:26,130
<font color="#E5E5E5">goals of tree sitter though is to parse</font>

344
00:13:23,880 --> 00:13:29,070
like every major programming language is

345
00:13:26,130 --> 00:13:31,470
this one this one parsing framework

346
00:13:29,070 --> 00:13:35,270
going<font color="#E5E5E5"> to work for all languages</font><font color="#CCCCCC"> and the</font>

347
00:13:31,470 --> 00:13:38,130
answer is no not<font color="#CCCCCC"> quite so while most</font>

348
00:13:35,270 --> 00:13:39,660
languages<font color="#E5E5E5"> are designed to be fairly</font><font color="#CCCCCC"> easy</font>

349
00:13:38,130 --> 00:13:41,640
to<font color="#E5E5E5"> parse using parsers that</font><font color="#CCCCCC"> were</font>

350
00:13:39,660 --> 00:13:44,760
available in you know ten years<font color="#CCCCCC"> ago or</font>

351
00:13:41,640 --> 00:13:46,530
longer<font color="#E5E5E5"> and LR parsing is actually a very</font>

352
00:13:44,760 --> 00:13:49,530
powerful technique and that can parse<font color="#E5E5E5"> up</font>

353
00:13:46,530 --> 00:13:51,420
a much bigger set of grammars grammar

354
00:13:49,530 --> 00:13:53,370
languages often<font color="#E5E5E5"> have some weird quirk</font>

355
00:13:51,420 --> 00:13:55,469
that needs to be<font color="#E5E5E5"> handled via ad hoc code</font>

356
00:13:53,370 --> 00:13:59,970
and so let<font color="#E5E5E5"> me give you an example of one</font>

357
00:13:55,470 --> 00:14:03,210
of<font color="#E5E5E5"> those works so here's</font><font color="#CCCCCC"> two JavaScript</font>

358
00:13:59,970 --> 00:14:06,030
statements<font color="#E5E5E5"> and the first one we have</font>

359
00:14:03,210 --> 00:14:07,800
assigning to<font color="#E5E5E5"> the variable X the value of</font>

360
00:14:06,030 --> 00:14:11,160
the variable Y which we have in

361
00:14:07,800 --> 00:14:13,050
<font color="#E5E5E5">parentheses just because we can</font><font color="#CCCCCC"> and the</font>

362
00:14:11,160 --> 00:14:14,910
second example<font color="#CCCCCC"> we're assigning to X this</font>

363
00:14:13,050 --> 00:14:18,750
<font color="#E5E5E5">arrow function that takes a parameter</font>

364
00:14:14,910 --> 00:14:20,490
<font color="#CCCCCC">called</font><font color="#E5E5E5"> Y and returns Z</font><font color="#CCCCCC"> and so the reason</font>

365
00:14:18,750 --> 00:14:23,370
that<font color="#E5E5E5"> this is a problem</font><font color="#CCCCCC"> for an LR parser</font>

366
00:14:20,490 --> 00:14:28,800
is that like I said<font color="#CCCCCC"> LR parser never</font>

367
00:14:23,370 --> 00:14:32,130
<font color="#CCCCCC">backtracks so before the parser can</font>

368
00:14:28,800 --> 00:14:34,260
process the the right parenthesis<font color="#E5E5E5"> it</font>

369
00:14:32,130 --> 00:14:36,090
needs to decide what it should push<font color="#CCCCCC"> onto</font>

370
00:14:34,260 --> 00:14:38,490
its stack in order<font color="#CCCCCC"> to represent the Y</font>

371
00:14:36,090 --> 00:14:40,470
but it can't know whether the<font color="#E5E5E5"> Y is an</font>

372
00:14:38,490 --> 00:14:43,350
<font color="#E5E5E5">expression or not meaning are we</font>

373
00:14:40,470 --> 00:14:44,910
evaluating<font color="#CCCCCC"> Y or not until it sees the</font>

374
00:14:43,350 --> 00:14:46,590
arrow token that<font color="#E5E5E5"> comes later</font>

375
00:14:44,910 --> 00:14:49,469
and so I'll show<font color="#CCCCCC"> you the basic technique</font>

376
00:14:46,590 --> 00:14:53,730
that tree sitter uses<font color="#E5E5E5"> to to deal with</font>

377
00:14:49,470 --> 00:14:57,000
this so it's called<font color="#CCCCCC"> G LR parsing an idea</font>

378
00:14:53,730 --> 00:14:58,620
is these<font color="#E5E5E5"> are some more diagrams with a</font>

379
00:14:57,000 --> 00:15:00,590
parser stack here but they're in a

380
00:14:58,620 --> 00:15:02,880
<font color="#E5E5E5">different format</font><font color="#CCCCCC"> now that that's</font>

381
00:15:00,590 --> 00:15:06,390
generated by tree sitter itself<font color="#E5E5E5"> in order</font>

382
00:15:02,880 --> 00:15:08,550
<font color="#CCCCCC">to</font><font color="#E5E5E5"> help you debug the parsing</font><font color="#CCCCCC"> the idea</font>

383
00:15:06,390 --> 00:15:10,710
is though<font color="#CCCCCC"> that the the stack can fork</font>

384
00:15:08,550 --> 00:15:12,870
into<font color="#E5E5E5"> multiple branches in order to</font>

385
00:15:10,710 --> 00:15:14,200
explore multiple<font color="#E5E5E5"> possibilities at the</font>

386
00:15:12,870 --> 00:15:16,540
same time without ever

387
00:15:14,200 --> 00:15:17,620
<font color="#CCCCCC">backtracking and so in this</font><font color="#E5E5E5"> example</font><font color="#CCCCCC"> at</font>

388
00:15:16,540 --> 00:15:20,469
when we get to the right parenthesis

389
00:15:17,620 --> 00:15:22,120
we'd have to fork<font color="#E5E5E5"> the par stack and read</font>

390
00:15:20,470 --> 00:15:24,910
in a few<font color="#E5E5E5"> more tokens until we see the</font>

391
00:15:22,120 --> 00:15:26,110
arrow<font color="#E5E5E5"> at which point</font><font color="#CCCCCC"> we can discard one</font>

392
00:15:24,910 --> 00:15:28,480
of<font color="#E5E5E5"> the</font><font color="#CCCCCC"> forks because we can tell that</font>

393
00:15:26,110 --> 00:15:30,550
<font color="#CCCCCC">which which one of</font><font color="#E5E5E5"> the two is valid and</font>

394
00:15:28,480 --> 00:15:32,260
<font color="#E5E5E5">so this is the technique that allows</font>

395
00:15:30,550 --> 00:15:37,949
trees to do to be so general to handle

396
00:15:32,260 --> 00:15:40,090
<font color="#E5E5E5">languages like C++ etc and then another</font>

397
00:15:37,950 --> 00:15:42,520
problem<font color="#CCCCCC"> that</font><font color="#E5E5E5"> I wanted</font><font color="#CCCCCC"> to show</font><font color="#E5E5E5"> to you</font><font color="#CCCCCC"> is</font>

398
00:15:40,090 --> 00:15:44,800
how tree sitter deals with errors so

399
00:15:42,520 --> 00:15:46,990
unlike most parsers that<font color="#E5E5E5"> are built for</font>

400
00:15:44,800 --> 00:15:49,229
<font color="#E5E5E5">compilers that simply halt when they see</font>

401
00:15:46,990 --> 00:15:51,400
an error<font color="#E5E5E5"> report an error message</font>

402
00:15:49,230 --> 00:15:53,290
<font color="#CCCCCC">consider can't do that because</font><font color="#E5E5E5"> it needs</font>

403
00:15:51,400 --> 00:15:55,120
to<font color="#E5E5E5"> provide</font><font color="#CCCCCC"> a tree no matter what</font><font color="#E5E5E5"> for use</font>

404
00:15:53,290 --> 00:15:57,910
<font color="#E5E5E5">in application like atom that needs to</font>

405
00:15:55,120 --> 00:15:59,080
be<font color="#CCCCCC"> able to provide functionality even if</font>

406
00:15:57,910 --> 00:16:03,569
the users in the middle of<font color="#CCCCCC"> typing</font>

407
00:15:59,080 --> 00:16:05,770
something<font color="#E5E5E5"> and so in this example code</font>

408
00:16:03,570 --> 00:16:07,780
<font color="#E5E5E5">there's an if statement and then you</font>

409
00:16:05,770 --> 00:16:10,480
started typing a for loop<font color="#E5E5E5"> before it and</font>

410
00:16:07,780 --> 00:16:12,400
so what<font color="#E5E5E5"> Teresa de would do is produce a</font>

411
00:16:10,480 --> 00:16:15,670
syntax tree in which the if statement is

412
00:16:12,400 --> 00:16:17,290
<font color="#E5E5E5">still fully parsed</font><font color="#CCCCCC"> but there's just</font><font color="#E5E5E5"> an</font>

413
00:16:15,670 --> 00:16:19,209
extra error node<font color="#E5E5E5"> that</font><font color="#CCCCCC"> represents the</font>

414
00:16:17,290 --> 00:16:22,120
fact<font color="#CCCCCC"> that the word for should not be</font>

415
00:16:19,210 --> 00:16:24,220
there<font color="#CCCCCC"> and then similarly</font><font color="#E5E5E5"> if you had a</font>

416
00:16:22,120 --> 00:16:25,240
for loop but<font color="#E5E5E5"> you started typing an if</font>

417
00:16:24,220 --> 00:16:27,550
statement in the middle of it

418
00:16:25,240 --> 00:16:29,680
accidentally<font color="#E5E5E5"> tree</font><font color="#CCCCCC"> sitter could still</font>

419
00:16:27,550 --> 00:16:31,959
parse the for loop completely and

420
00:16:29,680 --> 00:16:34,359
provide you this error node in the tree

421
00:16:31,960 --> 00:16:37,330
<font color="#E5E5E5">that tells you</font><font color="#CCCCCC"> that the word if</font>

422
00:16:34,360 --> 00:16:40,090
shouldn't be<font color="#E5E5E5"> there and the way that it</font>

423
00:16:37,330 --> 00:16:41,800
does<font color="#CCCCCC"> this is similar</font><font color="#E5E5E5"> to the way that</font><font color="#CCCCCC"> it</font>

424
00:16:40,090 --> 00:16:44,590
<font color="#E5E5E5">deals with the ambiguities that</font><font color="#CCCCCC"> I</font>

425
00:16:41,800 --> 00:16:47,109
mentioned a second ago so upon seeing an

426
00:16:44,590 --> 00:16:48,910
error tree sitter can can split the

427
00:16:47,110 --> 00:16:52,210
parse tack into multiple branches<font color="#E5E5E5"> in</font>

428
00:16:48,910 --> 00:16:54,370
order to simultaneously explore multiple

429
00:16:52,210 --> 00:16:58,680
<font color="#E5E5E5">ways of recovering from the error and</font>

430
00:16:54,370 --> 00:17:01,930
then decide which one<font color="#CCCCCC"> is</font><font color="#E5E5E5"> the best</font>

431
00:16:58,680 --> 00:17:03,849
<font color="#E5E5E5">according</font><font color="#CCCCCC"> to this cost metric and so you</font>

432
00:17:01,930 --> 00:17:06,159
can see here these two<font color="#CCCCCC"> sequences of</font><font color="#E5E5E5"> what</font>

433
00:17:03,850 --> 00:17:07,930
would happen<font color="#CCCCCC"> when parsing these two</font>

434
00:17:06,160 --> 00:17:13,780
erroneous pieces of code that started

435
00:17:07,930 --> 00:17:15,850
out the same oh and and as far<font color="#E5E5E5"> as I know</font>

436
00:17:13,780 --> 00:17:17,680
<font color="#E5E5E5">that technique is novel I haven't seen</font>

437
00:17:15,849 --> 00:17:20,198
that in<font color="#CCCCCC"> the literature</font><font color="#E5E5E5"> and commercial</font>

438
00:17:17,680 --> 00:17:22,150
parsers but it allows tree sitter<font color="#CCCCCC"> to to</font>

439
00:17:20,199 --> 00:17:24,670
produce<font color="#E5E5E5"> these very natural seeming</font>

440
00:17:22,150 --> 00:17:27,289
syntax trees even<font color="#CCCCCC"> in the case</font><font color="#E5E5E5"> of severe</font>

441
00:17:24,670 --> 00:17:29,480
errors<font color="#E5E5E5"> like the ones I showed</font>

442
00:17:27,289 --> 00:17:30,740
and then finally the last algorithm I

443
00:17:29,480 --> 00:17:32,419
wanted to show<font color="#E5E5E5"> you is how</font><font color="#CCCCCC"> tree sitter</font>

444
00:17:30,740 --> 00:17:34,039
does the incremental parsing that makes

445
00:17:32,419 --> 00:17:37,400
it performant enough to use in a text

446
00:17:34,039 --> 00:17:39,350
editor<font color="#E5E5E5"> so the idea here is say you had</font>

447
00:17:37,400 --> 00:17:42,140
these<font color="#CCCCCC"> three statements</font><font color="#E5E5E5"> in JavaScript and</font>

448
00:17:39,350 --> 00:17:43,908
then<font color="#E5E5E5"> you edited</font><font color="#CCCCCC"> right there so you</font>

449
00:17:42,140 --> 00:17:46,340
<font color="#E5E5E5">inserted</font><font color="#CCCCCC"> an argument to</font><font color="#E5E5E5"> this function</font>

450
00:17:43,909 --> 00:17:49,850
<font color="#E5E5E5">call the way tree sitter would process</font>

451
00:17:46,340 --> 00:17:53,029
<font color="#E5E5E5">that is it would walk the tree that</font><font color="#CCCCCC"> it</font>

452
00:17:49,850 --> 00:17:55,639
had and any syntax node that contained

453
00:17:53,029 --> 00:17:57,950
the site of<font color="#E5E5E5"> your edit it would mark</font><font color="#CCCCCC"> as</font>

454
00:17:55,640 --> 00:18:01,309
having had a character inserted into it

455
00:17:57,950 --> 00:18:02,899
and then it<font color="#E5E5E5"> would begin parsing as if it</font>

456
00:18:01,309 --> 00:18:04,668
was<font color="#E5E5E5"> going to parse the file from scratch</font>

457
00:18:02,899 --> 00:18:07,520
<font color="#E5E5E5">starting</font><font color="#CCCCCC"> at the beginning with an empty</font>

458
00:18:04,669 --> 00:18:10,490
parse<font color="#CCCCCC"> deck</font><font color="#E5E5E5"> but this time since</font><font color="#CCCCCC"> it has</font>

459
00:18:07,520 --> 00:18:12,260
the existing tree as a reference it can

460
00:18:10,490 --> 00:18:13,909
skip a<font color="#E5E5E5"> lot</font><font color="#CCCCCC"> of intermediate</font><font color="#E5E5E5"> steps in that</font>

461
00:18:12,260 --> 00:18:17,629
parsing<font color="#CCCCCC"> process</font>

462
00:18:13,909 --> 00:18:19,730
so after<font color="#E5E5E5"> upon starting it can</font>

463
00:18:17,630 --> 00:18:22,130
<font color="#CCCCCC">immediately push directly onto</font><font color="#E5E5E5"> its stack</font>

464
00:18:19,730 --> 00:18:24,710
<font color="#E5E5E5">the entire variable declaration that was</font>

465
00:18:22,130 --> 00:18:26,450
<font color="#E5E5E5">the first statement in the program</font><font color="#CCCCCC"> and</font>

466
00:18:24,710 --> 00:18:28,159
<font color="#E5E5E5">then it can reuse smaller pieces from</font>

467
00:18:26,450 --> 00:18:30,080
there like this member expression that

468
00:18:28,159 --> 00:18:31,789
<font color="#CCCCCC">proceeded to edit and</font><font color="#E5E5E5"> the left</font>

469
00:18:30,080 --> 00:18:33,889
parenthesis<font color="#E5E5E5"> right before the</font><font color="#CCCCCC"> Edit and</font>

470
00:18:31,789 --> 00:18:36,890
then it can parse<font color="#E5E5E5"> from scratch for a</font>

471
00:18:33,890 --> 00:18:39,260
tiny<font color="#E5E5E5"> little piece where you inserted but</font>

472
00:18:36,890 --> 00:18:42,320
<font color="#E5E5E5">then it can resume reusing more trees so</font>

473
00:18:39,260 --> 00:18:44,419
it can reuse the right<font color="#CCCCCC"> parenthesis and</font>

474
00:18:42,320 --> 00:18:46,908
<font color="#E5E5E5">do some more grouping here and then</font>

475
00:18:44,419 --> 00:18:48,950
reuse the whole the<font color="#E5E5E5"> whole final</font>

476
00:18:46,909 --> 00:18:52,520
statement<font color="#E5E5E5"> of the program and and group</font>

477
00:18:48,950 --> 00:18:55,070
that into a new root node that kind of

478
00:18:52,520 --> 00:18:57,320
shares<font color="#CCCCCC"> elements of the old root node</font><font color="#E5E5E5"> and</font>

479
00:18:55,070 --> 00:18:59,240
in that way the the time it<font color="#E5E5E5"> takes to do</font>

480
00:18:57,320 --> 00:19:01,580
this<font color="#E5E5E5"> is not proportional to the whole</font>

481
00:18:59,240 --> 00:19:03,080
size of the file<font color="#E5E5E5"> it's only proportional</font>

482
00:19:01,580 --> 00:19:06,220
to the amount<font color="#CCCCCC"> of text that</font><font color="#E5E5E5"> you inserted</font>

483
00:19:03,080 --> 00:19:09,678
and the number of changes<font color="#E5E5E5"> that</font><font color="#CCCCCC"> you made</font>

484
00:19:06,220 --> 00:19:12,020
so let's all show you next<font color="#E5E5E5"> steps</font><font color="#CCCCCC"> for me</font>

485
00:19:09,679 --> 00:19:14,960
is adding support for<font color="#E5E5E5"> more languages</font><font color="#CCCCCC"> so</font>

486
00:19:12,020 --> 00:19:18,649
there's<font color="#CCCCCC"> about</font><font color="#E5E5E5"> 10 supported right now out</font>

487
00:19:14,960 --> 00:19:20,299
of<font color="#E5E5E5"> the set that</font><font color="#CCCCCC"> Adam supports and I plan</font>

488
00:19:18,649 --> 00:19:22,279
to<font color="#CCCCCC"> basically</font><font color="#E5E5E5"> continue adding support for</font>

489
00:19:20,299 --> 00:19:24,350
<font color="#CCCCCC">these new</font><font color="#E5E5E5"> languages until all the</font>

490
00:19:22,279 --> 00:19:26,270
languages that Adam ships with can now

491
00:19:24,350 --> 00:19:28,100
be<font color="#E5E5E5"> parsed with tree sitter and at the</font>

492
00:19:26,270 --> 00:19:30,980
same time<font color="#E5E5E5"> the</font><font color="#CCCCCC"> github comm team</font><font color="#E5E5E5"> I talked</font>

493
00:19:28,100 --> 00:19:32,870
about<font color="#E5E5E5"> is busy developing support for</font>

494
00:19:30,980 --> 00:19:36,390
other<font color="#E5E5E5"> languages</font><font color="#CCCCCC"> that they want to</font>

495
00:19:32,870 --> 00:19:48,529
<font color="#E5E5E5">support</font><font color="#CCCCCC"> on github Thanks</font>

496
00:19:36,390 --> 00:19:48,529
[Applause]

