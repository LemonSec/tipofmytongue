1
00:00:05,150 --> 00:00:11,219
hi so can we start I'm<font color="#E5E5E5"> Julian</font>

2
00:00:08,970 --> 00:00:14,010
I've come to<font color="#CCCCCC"> talk about mem Czech versus</font>

3
00:00:11,219 --> 00:00:16,740
optimizing compilers<font color="#CCCCCC"> I'm kind of the de</font>

4
00:00:14,010 --> 00:00:19,619
facto maintainer<font color="#CCCCCC"> of MEMS</font><font color="#E5E5E5"> XO I spent a</font>

5
00:00:16,740 --> 00:00:23,939
<font color="#E5E5E5">lot of time dealing with problems caused</font>

6
00:00:19,619 --> 00:00:26,640
by optimizing compilers<font color="#CCCCCC"> which seem to</font>

7
00:00:23,940 --> 00:00:29,940
<font color="#CCCCCC">have got worse</font><font color="#E5E5E5"> over the years</font><font color="#CCCCCC"> or better</font>

8
00:00:26,640 --> 00:00:33,570
optimizing but more problematic<font color="#E5E5E5"> so this</font>

9
00:00:29,940 --> 00:00:36,239
is a something<font color="#E5E5E5"> of a bit mathematical</font>

10
00:00:33,570 --> 00:00:37,649
talk I'll show a bit about how mem<font color="#CCCCCC"> Tech</font>

11
00:00:36,239 --> 00:00:41,099
tracks<font color="#CCCCCC"> valve</font>

12
00:00:37,649 --> 00:00:45,260
tracks define<font color="#CCCCCC"> Earnest of stuff and then</font>

13
00:00:41,100 --> 00:00:45,260
I'll talk<font color="#E5E5E5"> a</font><font color="#CCCCCC"> bit about</font><font color="#E5E5E5"> some problems</font>

14
00:00:45,410 --> 00:00:50,968
<font color="#CCCCCC">coming coming</font>

15
00:00:46,649 --> 00:00:52,739
<font color="#E5E5E5">so basically mem Tech with which you may</font>

16
00:00:50,969 --> 00:00:55,200
<font color="#CCCCCC">have used it basically does two things</font>

17
00:00:52,739 --> 00:00:57,239
it it determines whether<font color="#E5E5E5"> you're reading</font>

18
00:00:55,200 --> 00:00:59,579
and writing in<font color="#E5E5E5"> the wrong place or checks</font>

19
00:00:57,239 --> 00:01:02,399
the location of all memory accesses and

20
00:00:59,579 --> 00:01:04,530
that's relatively<font color="#E5E5E5"> simple</font><font color="#CCCCCC"> because there's</font>

21
00:01:02,399 --> 00:01:06,810
not much<font color="#E5E5E5"> ambiguity about whether this</font>

22
00:01:04,530 --> 00:01:08,670
place is<font color="#CCCCCC"> okay place to read or write or</font>

23
00:01:06,810 --> 00:01:13,500
<font color="#E5E5E5">not you you know where the bands of the</font>

24
00:01:08,670 --> 00:01:16,619
heat blocks are but the other thing that

25
00:01:13,500 --> 00:01:18,479
it<font color="#CCCCCC"> does is</font><font color="#E5E5E5"> to check whether branches and</font>

26
00:01:16,619 --> 00:01:21,000
some other program constructions

27
00:01:18,479 --> 00:01:25,050
basically addresses depend on undefined

28
00:01:21,000 --> 00:01:26,970
data and<font color="#E5E5E5"> that that's considerably more</font>

29
00:01:25,050 --> 00:01:28,349
difficult<font color="#CCCCCC"> because you have to follow</font><font color="#E5E5E5"> on</font>

30
00:01:26,970 --> 00:01:31,940
<font color="#E5E5E5">defining</font><font color="#CCCCCC"> this through the whole program</font>

31
00:01:28,349 --> 00:01:37,190
<font color="#E5E5E5">to do this</font><font color="#CCCCCC"> go through</font><font color="#E5E5E5"> the whole process</font>

32
00:01:31,940 --> 00:01:37,190
<font color="#CCCCCC">should I pause please welcome</font>

33
00:01:38,480 --> 00:01:42,440
<font color="#E5E5E5">yeah yeah it's kind of crazy</font>

34
00:01:50,450 --> 00:01:53,590
[Music]

35
00:01:56,690 --> 00:02:05,490
can I can I<font color="#E5E5E5"> continue I continue so so</font>

36
00:02:03,810 --> 00:02:07,979
<font color="#E5E5E5">for a tool like mm check we put a lot of</font>

37
00:02:05,490 --> 00:02:10,530
effort<font color="#CCCCCC"> into making</font><font color="#E5E5E5"> sure that the false</font>

38
00:02:07,979 --> 00:02:12,870
positive rate is very<font color="#E5E5E5"> low and in</font>

39
00:02:10,530 --> 00:02:17,580
particular the false positive rate for

40
00:02:12,870 --> 00:02:19,380
undefined value errors<font color="#CCCCCC"> I think</font><font color="#E5E5E5"> it's sort</font>

41
00:02:17,580 --> 00:02:21,480
<font color="#E5E5E5">of somewhat known for that</font><font color="#CCCCCC"> so when it</font>

42
00:02:19,380 --> 00:02:23,160
comes along<font color="#E5E5E5"> and says this</font><font color="#CCCCCC"> is you know on</font>

43
00:02:21,480 --> 00:02:28,170
the<font color="#CCCCCC"> find values here it's likely to be</font>

44
00:02:23,160 --> 00:02:30,480
correct<font color="#CCCCCC"> this is important because</font><font color="#E5E5E5"> lots</font>

45
00:02:28,170 --> 00:02:33,600
of false positives make tools<font color="#E5E5E5"> less</font>

46
00:02:30,480 --> 00:02:35,730
useful<font color="#CCCCCC"> for developers</font><font color="#E5E5E5"> so back</font><font color="#CCCCCC"> in the</font>

47
00:02:33,600 --> 00:02:38,730
<font color="#E5E5E5">good</font><font color="#CCCCCC"> old days of 2005 that was all fine</font>

48
00:02:35,730 --> 00:02:40,679
we had most stuff under<font color="#CCCCCC"> control</font>

49
00:02:38,730 --> 00:02:42,209
you know the occasionally you got false

50
00:02:40,680 --> 00:02:45,540
positives but they we could get rid of

51
00:02:42,209 --> 00:02:48,390
<font color="#E5E5E5">them</font><font color="#CCCCCC"> ten years later we have clang three</font>

52
00:02:45,540 --> 00:02:52,799
and GCC five and their<font color="#CCCCCC"> successors</font>

53
00:02:48,390 --> 00:02:55,980
generating all sorts of<font color="#E5E5E5"> problems some</font><font color="#CCCCCC"> of</font>

54
00:02:52,800 --> 00:02:58,350
<font color="#E5E5E5">which are not easy to get rid of so what</font>

55
00:02:55,980 --> 00:03:00,030
I want to<font color="#E5E5E5"> show you is some basics about</font>

56
00:02:58,350 --> 00:03:02,670
defining<font color="#CCCCCC"> this tracking I'm sorry if it's</font>

57
00:03:00,030 --> 00:03:04,140
a bit mathematical some problems where

58
00:03:02,670 --> 00:03:06,809
we have<font color="#E5E5E5"> some solutions and some problems</font>

59
00:03:04,140 --> 00:03:09,119
where actually I have no idea<font color="#CCCCCC"> what to do</font>

60
00:03:06,810 --> 00:03:12,420
<font color="#E5E5E5">and it's actually I</font><font color="#CCCCCC"> think it's quite</font>

61
00:03:09,120 --> 00:03:14,540
serious so here's some<font color="#CCCCCC"> maths you</font><font color="#E5E5E5"> can</font>

62
00:03:12,420 --> 00:03:16,679
throw things<font color="#E5E5E5"> at me</font><font color="#CCCCCC"> if it's too boring</font><font color="#E5E5E5"> so</font>

63
00:03:14,540 --> 00:03:19,078
here's<font color="#CCCCCC"> some basic sorry</font>

64
00:03:16,680 --> 00:03:22,350
so what men<font color="#E5E5E5"> check does to cut out all</font>

65
00:03:19,079 --> 00:03:24,750
<font color="#E5E5E5">the intermediate stuff is literally</font>

66
00:03:22,350 --> 00:03:26,670
every bit of the state in your process

67
00:03:24,750 --> 00:03:29,370
that's all the memory and all the

68
00:03:26,670 --> 00:03:31,078
registers it has a second bit<font color="#CCCCCC"> of shadow</font>

69
00:03:29,370 --> 00:03:33,989
bit which follows it around everywhere

70
00:03:31,079 --> 00:03:38,940
<font color="#E5E5E5">and tells you whether that be that bit</font>

71
00:03:33,989 --> 00:03:43,079
is defined<font color="#E5E5E5"> or undefined</font><font color="#CCCCCC"> and we use the</font><font color="#E5E5E5"> I</font>

72
00:03:38,940 --> 00:03:45,239
could use<font color="#E5E5E5"> this</font><font color="#CCCCCC"> we use this we use one to</font>

73
00:03:43,079 --> 00:03:47,940
encode undefined and<font color="#E5E5E5"> zero to kinko</font>

74
00:03:45,239 --> 00:03:49,260
defined which sounds a bit<font color="#E5E5E5"> perhaps</font><font color="#CCCCCC"> not</font>

75
00:03:47,940 --> 00:03:53,700
<font color="#E5E5E5">what you'd expect but it makes the</font>

76
00:03:49,260 --> 00:03:56,040
cogeneration<font color="#E5E5E5"> more efficient so when when</font>

77
00:03:53,700 --> 00:03:59,810
we come to actually<font color="#E5E5E5"> calculate the value</font>

78
00:03:56,040 --> 00:04:03,030
from operands like<font color="#CCCCCC"> R equals x plus y I</font>

79
00:03:59,810 --> 00:04:07,290
mean when the program does that then mm

80
00:04:03,030 --> 00:04:09,250
check has these you<font color="#CCCCCC"> know</font><font color="#E5E5E5"> shadow values</font>

81
00:04:07,290 --> 00:04:14,019
of the<font color="#E5E5E5"> same size which I write as</font>

82
00:04:09,250 --> 00:04:16,180
- and<font color="#CCCCCC"> why - so literally if X is 16 bits</font>

83
00:04:14,020 --> 00:04:18,400
then X<font color="#CCCCCC"> hash is also going to be a 16-bit</font>

84
00:04:16,180 --> 00:04:21,250
thing with contending<font color="#E5E5E5"> shadow bits and</font>

85
00:04:18,399 --> 00:04:23,909
then we want<font color="#E5E5E5"> to compute somehow the</font>

86
00:04:21,250 --> 00:04:27,460
<font color="#E5E5E5">defined earnest of the result our hash</font>

87
00:04:23,910 --> 00:04:28,930
and so by<font color="#CCCCCC"> doing this it</font><font color="#E5E5E5"> follows tries to</font>

88
00:04:27,460 --> 00:04:31,930
follow dividing this through all the

89
00:04:28,930 --> 00:04:36,310
<font color="#CCCCCC">arithmetic in the program and when it</font>

90
00:04:31,930 --> 00:04:38,740
gets to<font color="#E5E5E5"> like an if or</font><font color="#CCCCCC"> the use of a value</font>

91
00:04:36,310 --> 00:04:41,050
in<font color="#CCCCCC"> an</font><font color="#E5E5E5"> for in a memory address or for a</font>

92
00:04:38,740 --> 00:04:43,060
couple<font color="#E5E5E5"> of other obscure things it</font>

93
00:04:41,050 --> 00:04:45,190
<font color="#CCCCCC">actually checks whether the value is</font>

94
00:04:43,060 --> 00:04:49,450
defined<font color="#E5E5E5"> and it generates an error at</font>

95
00:04:45,190 --> 00:04:50,950
that point<font color="#E5E5E5"> if</font><font color="#CCCCCC"> this dot so we wrote this</font>

96
00:04:49,450 --> 00:04:53,440
all<font color="#E5E5E5"> down quite nicely</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> this paper</font>

97
00:04:50,950 --> 00:04:58,240
which you<font color="#E5E5E5"> can look at if you like this</font>

98
00:04:53,440 --> 00:05:02,590
<font color="#E5E5E5">kind of stuff</font><font color="#CCCCCC"> so here is some some basic</font>

99
00:04:58,240 --> 00:05:07,090
building blocks which I'll talk about a

100
00:05:02,590 --> 00:05:09,640
bit sorry<font color="#E5E5E5"> it's all bit mathy so we are</font>

101
00:05:07,090 --> 00:05:11,830
most important building block is you if

102
00:05:09,640 --> 00:05:17,250
you which it means undefined<font color="#E5E5E5"> if either</font>

103
00:05:11,830 --> 00:05:17,250
argument is undefined<font color="#E5E5E5"> so</font><font color="#CCCCCC"> this takes -</font>

104
00:05:17,610 --> 00:05:25,479
<font color="#E5E5E5">how can</font><font color="#CCCCCC"> you</font><font color="#E5E5E5"> say</font><font color="#CCCCCC"> vectors of defining this</font>

105
00:05:22,270 --> 00:05:28,450
bits<font color="#E5E5E5"> is an example and produces another</font>

106
00:05:25,479 --> 00:05:31,060
vector so this I'm writing a<font color="#E5E5E5"> 4-bit</font>

107
00:05:28,450 --> 00:05:34,169
vector<font color="#CCCCCC"> D ddu meaning three bits saying</font>

108
00:05:31,060 --> 00:05:36,820
defined and<font color="#E5E5E5"> the fourth one undefined and</font>

109
00:05:34,169 --> 00:05:39,729
you know we<font color="#CCCCCC"> combine</font><font color="#E5E5E5"> it with this one</font>

110
00:05:36,820 --> 00:05:41,050
here<font color="#E5E5E5"> D D u D so we get two bits which</font>

111
00:05:39,729 --> 00:05:46,870
<font color="#E5E5E5">are</font><font color="#CCCCCC"> defined in two bits which are</font>

112
00:05:41,050 --> 00:05:48,820
undefined and<font color="#E5E5E5"> because defined it is</font><font color="#CCCCCC"> zero</font>

113
00:05:46,870 --> 00:05:51,160
<font color="#E5E5E5">and undefined is one that means you can</font>

114
00:05:48,820 --> 00:05:54,610
just<font color="#CCCCCC"> implement it using</font><font color="#E5E5E5"> an standard or</font>

115
00:05:51,160 --> 00:05:57,190
operation so then there's a dual

116
00:05:54,610 --> 00:05:59,440
operation D F D means defined if<font color="#E5E5E5"> I</font>

117
00:05:57,190 --> 00:06:04,960
defined if either argument is defined

118
00:05:59,440 --> 00:06:07,330
<font color="#E5E5E5">which</font><font color="#CCCCCC"> we'll use much more really here's</font>

119
00:06:04,960 --> 00:06:10,299
<font color="#E5E5E5">another one called left I called it left</font>

120
00:06:07,330 --> 00:06:12,159
<font color="#E5E5E5">which finds the rightmost undefined bit</font>

121
00:06:10,300 --> 00:06:15,580
in the word and<font color="#E5E5E5"> then propagates it left</font>

122
00:06:12,160 --> 00:06:18,610
<font color="#CCCCCC">words like that so it finds this bit</font>

123
00:06:15,580 --> 00:06:20,279
here and then you get<font color="#CCCCCC"> all the bits above</font>

124
00:06:18,610 --> 00:06:23,579
it are undefined<font color="#E5E5E5"> so we</font>

125
00:06:20,279 --> 00:06:25,919
we'll see how that<font color="#CCCCCC"> gets used</font><font color="#E5E5E5"> bizarrely</font>

126
00:06:23,579 --> 00:06:28,619
<font color="#CCCCCC">you can do</font><font color="#E5E5E5"> implement</font><font color="#CCCCCC"> that by negation</font>

127
00:06:25,919 --> 00:06:34,139
<font color="#E5E5E5">and</font><font color="#CCCCCC"> oaring there's a lot of bit</font>

128
00:06:28,619 --> 00:06:37,289
twiddling tricks<font color="#E5E5E5"> and the last building</font>

129
00:06:34,139 --> 00:06:39,689
block is this thing called a pessimistic

130
00:06:37,289 --> 00:06:42,539
<font color="#CCCCCC">caste which takes some</font><font color="#E5E5E5"> vector of</font>

131
00:06:39,689 --> 00:06:45,179
<font color="#CCCCCC">defining this bits and produces a</font><font color="#E5E5E5"> vector</font>

132
00:06:42,539 --> 00:06:48,959
of defining<font color="#E5E5E5"> the defining</font><font color="#CCCCCC"> this bits of</font>

133
00:06:45,179 --> 00:06:52,979
some different size<font color="#CCCCCC"> and the idea is that</font>

134
00:06:48,959 --> 00:06:54,779
if<font color="#E5E5E5"> all of the input bits are defined</font>

135
00:06:52,979 --> 00:06:57,419
<font color="#E5E5E5">then there is all of the output bits are</font>

136
00:06:54,779 --> 00:07:00,119
undefined<font color="#E5E5E5"> but if any of the input bits</font>

137
00:06:57,419 --> 00:07:01,919
are undefined<font color="#E5E5E5"> then the whole output is</font>

138
00:07:00,119 --> 00:07:03,479
undefined<font color="#CCCCCC"> so that's why it's sort</font><font color="#E5E5E5"> of</font>

139
00:07:01,919 --> 00:07:06,269
pessimistic<font color="#CCCCCC"> because anything</font><font color="#E5E5E5"> bad that</font>

140
00:07:03,479 --> 00:07:09,449
<font color="#CCCCCC">comes in produces to complete badness</font><font color="#E5E5E5"> of</font>

141
00:07:06,269 --> 00:07:12,539
the result so the most important case

142
00:07:09,449 --> 00:07:15,989
is when we want to take<font color="#CCCCCC"> a bunch</font><font color="#E5E5E5"> of bits</font>

143
00:07:12,539 --> 00:07:18,419
<font color="#E5E5E5">and check if any of them is undefined</font><font color="#CCCCCC"> so</font>

144
00:07:15,989 --> 00:07:23,039
<font color="#CCCCCC">that we would just</font><font color="#E5E5E5"> be</font><font color="#CCCCCC"> P casting down to</font>

145
00:07:18,419 --> 00:07:24,568
a single<font color="#E5E5E5"> bit there and there's even more</font>

146
00:07:23,039 --> 00:07:28,619
<font color="#E5E5E5">weird bit twiddling which</font>

147
00:07:24,569 --> 00:07:31,169
implements this so mm check spends half

148
00:07:28,619 --> 00:07:32,939
<font color="#E5E5E5">its time well a large amount if it's</font>

149
00:07:31,169 --> 00:07:35,399
time<font color="#E5E5E5"> running all these little weird</font>

150
00:07:32,939 --> 00:07:38,539
<font color="#E5E5E5">low-level arithmetic operations that's</font>

151
00:07:35,399 --> 00:07:38,539
<font color="#CCCCCC">what you're actually waiting for</font>

152
00:07:38,950 --> 00:07:46,210
so let's see some simple case

153
00:07:42,400 --> 00:07:49,929
so let's instrument or instrument

154
00:07:46,210 --> 00:07:51,489
<font color="#CCCCCC">addition so we're going to</font><font color="#E5E5E5"> take some</font>

155
00:07:49,930 --> 00:07:54,370
<font color="#E5E5E5">simple operation in the original program</font>

156
00:07:51,490 --> 00:08:00,940
<font color="#CCCCCC">some you know R is X</font><font color="#E5E5E5"> plus y</font><font color="#CCCCCC"> I mean</font>

157
00:07:54,370 --> 00:08:04,030
integer addition here as well and the

158
00:08:00,940 --> 00:08:06,100
simpler thing we could say<font color="#CCCCCC"> is if if we</font>

159
00:08:04,030 --> 00:08:08,049
find a bit in either input<font color="#E5E5E5"> operand which</font>

160
00:08:06,100 --> 00:08:11,440
is<font color="#E5E5E5"> undefined then the resulting output</font>

161
00:08:08,050 --> 00:08:15,700
<font color="#CCCCCC">bit is also going to be undefined</font><font color="#E5E5E5"> so we</font>

162
00:08:11,440 --> 00:08:19,030
can use you if you on the defined in

163
00:08:15,700 --> 00:08:20,680
this input to<font color="#E5E5E5"> produce the output but</font>

164
00:08:19,030 --> 00:08:24,190
that's<font color="#E5E5E5"> actually kind of too simplistic</font>

165
00:08:20,680 --> 00:08:26,020
<font color="#CCCCCC">right because when you add things</font><font color="#E5E5E5"> and</font>

166
00:08:24,190 --> 00:08:28,630
<font color="#E5E5E5">you get this carry which can go</font>

167
00:08:26,020 --> 00:08:32,020
arbitrarily<font color="#E5E5E5"> far up the word towards the</font>

168
00:08:28,630 --> 00:08:33,580
<font color="#E5E5E5">most significant bit so we need to</font>

169
00:08:32,020 --> 00:08:36,460
actually do something about carry

170
00:08:33,580 --> 00:08:38,800
propagation<font color="#E5E5E5"> and so the simple thing is</font>

171
00:08:36,460 --> 00:08:40,479
to assume<font color="#CCCCCC"> the worst case that the carry</font>

172
00:08:38,799 --> 00:08:43,900
is going to come all the way<font color="#E5E5E5"> along the</font>

173
00:08:40,479 --> 00:08:49,320
word upwards<font color="#CCCCCC"> this</font><font color="#E5E5E5"> is my most significant</font>

174
00:08:43,900 --> 00:08:49,319
bits here<font color="#E5E5E5"> and</font><font color="#CCCCCC"> they fit here for you</font><font color="#E5E5E5"> so</font>

175
00:08:50,490 --> 00:08:54,960
we're going to<font color="#E5E5E5"> assume in particular that</font>

176
00:08:52,740 --> 00:08:56,670
<font color="#E5E5E5">well you're going</font><font color="#CCCCCC"> to get the propagation</font>

177
00:08:54,960 --> 00:08:59,339
all the way along so we're going<font color="#E5E5E5"> to pull</font>

178
00:08:56,670 --> 00:08:59,939
in<font color="#E5E5E5"> our left</font><font color="#CCCCCC"> building block that we just</font>

179
00:08:59,339 --> 00:09:02,370
saw there

180
00:08:59,940 --> 00:09:04,470
so we first merged the<font color="#CCCCCC"> two arguments</font>

181
00:09:02,370 --> 00:09:08,130
<font color="#CCCCCC">getting in</font><font color="#E5E5E5"> a single word and then</font><font color="#CCCCCC"> we</font>

182
00:09:04,470 --> 00:09:09,300
propagate badness left<font color="#CCCCCC"> and that's</font>

183
00:09:08,130 --> 00:09:11,580
<font color="#CCCCCC">actually really cheap</font><font color="#E5E5E5"> tachogenerator</font>

184
00:09:09,300 --> 00:09:16,920
<font color="#CCCCCC">it's a couple</font><font color="#E5E5E5"> of moves a couple of</font><font color="#CCCCCC"> oars</font>

185
00:09:11,580 --> 00:09:23,010
<font color="#E5E5E5">and the negation</font><font color="#CCCCCC"> and that works like</font>

186
00:09:16,920 --> 00:09:26,699
pretty well but it's excessively

187
00:09:23,010 --> 00:09:28,439
conservative because this you know

188
00:09:26,700 --> 00:09:31,260
define<font color="#E5E5E5"> zeroes actually stop the</font>

189
00:09:28,440 --> 00:09:36,210
propagation<font color="#E5E5E5"> and unfortunately let</font><font color="#CCCCCC"> VM</font><font color="#E5E5E5"> has</font>

190
00:09:31,260 --> 00:09:38,850
come to<font color="#CCCCCC"> a no this fact</font><font color="#E5E5E5"> and so what</font><font color="#CCCCCC"> LLVM</font>

191
00:09:36,210 --> 00:09:43,230
does is sometimes when it wants<font color="#CCCCCC"> to set a</font>

192
00:09:38,850 --> 00:09:46,860
bit in a word it<font color="#E5E5E5"> doesn't do it by</font><font color="#CCCCCC"> oaring</font>

193
00:09:43,230 --> 00:09:52,670
it does it by addition<font color="#E5E5E5"> and this cause</font>

194
00:09:46,860 --> 00:09:56,130
causes you know false<font color="#E5E5E5"> errors because</font>

195
00:09:52,670 --> 00:09:57,540
<font color="#CCCCCC">LLVM knows that I'm</font><font color="#E5E5E5"> not exactly sure the</font>

196
00:09:56,130 --> 00:09:59,790
<font color="#CCCCCC">details but that</font><font color="#E5E5E5"> note that there's some</font>

197
00:09:57,540 --> 00:10:01,410
strategically<font color="#E5E5E5"> places zero bits in one of</font>

198
00:09:59,790 --> 00:10:04,800
the arguments<font color="#E5E5E5"> which will stop</font><font color="#CCCCCC"> the</font>

199
00:10:01,410 --> 00:10:08,819
<font color="#CCCCCC">carries propagating upwards</font><font color="#E5E5E5"> even</font><font color="#CCCCCC"> in the</font>

200
00:10:04,800 --> 00:10:11,040
presence of undefined values so that's a

201
00:10:08,820 --> 00:10:13,800
bummer<font color="#CCCCCC"> and we need to do something</font><font color="#E5E5E5"> more</font>

202
00:10:11,040 --> 00:10:19,170
expensive sometimes<font color="#CCCCCC"> just</font><font color="#E5E5E5"> like mmm thanks</font>

203
00:10:13,800 --> 00:10:20,849
<font color="#CCCCCC">Olivia yeah so enjoy the</font><font color="#E5E5E5"> improved</font>

204
00:10:19,170 --> 00:10:21,990
performance<font color="#E5E5E5"> of the code but</font><font color="#CCCCCC"> I don't like</font>

205
00:10:20,850 --> 00:10:24,290
<font color="#E5E5E5">to have having to deal with</font><font color="#CCCCCC"> these</font>

206
00:10:21,990 --> 00:10:24,290
<font color="#E5E5E5">problems</font>

207
00:10:26,720 --> 00:10:31,820
so let<font color="#E5E5E5"> me move on</font><font color="#CCCCCC"> to instrumenting</font>

208
00:10:29,840 --> 00:10:36,170
something which is actually<font color="#CCCCCC"> even simpler</font>

209
00:10:31,820 --> 00:10:39,410
sounding which is and<font color="#E5E5E5"> and/or so here we</font>

210
00:10:36,170 --> 00:10:42,349
go again<font color="#CCCCCC"> say same</font><font color="#E5E5E5"> kind of deal program</font>

211
00:10:39,410 --> 00:10:46,430
at<font color="#CCCCCC"> thes bitwise and of two operands</font><font color="#E5E5E5"> and</font>

212
00:10:42,350 --> 00:10:48,350
so we're<font color="#E5E5E5"> going</font><font color="#CCCCCC"> to say well obviously you</font>

213
00:10:46,430 --> 00:10:50,390
know<font color="#CCCCCC"> the result is undefined if either</font>

214
00:10:48,350 --> 00:10:52,160
<font color="#CCCCCC">input bit is undefined</font><font color="#E5E5E5"> for all input</font>

215
00:10:50,390 --> 00:10:58,460
bits<font color="#E5E5E5"> so we're going to use you if you</font>

216
00:10:52,160 --> 00:11:00,880
again but the problem is that<font color="#E5E5E5"> this</font><font color="#CCCCCC"> is</font>

217
00:10:58,460 --> 00:11:04,160
<font color="#CCCCCC">actually excessively simplistic</font><font color="#E5E5E5"> and</font>

218
00:11:00,880 --> 00:11:07,070
<font color="#E5E5E5">obviously if you take any bit which is</font>

219
00:11:04,160 --> 00:11:13,100
undefined and and it with a defined<font color="#CCCCCC"> zero</font>

220
00:11:07,070 --> 00:11:15,890
bit<font color="#E5E5E5"> then the result is zero so I say it</font>

221
00:11:13,100 --> 00:11:19,730
<font color="#E5E5E5">matters because compilers endlessly do</font>

222
00:11:15,890 --> 00:11:21,530
things like pull a big piece of<font color="#E5E5E5"> like 32</font>

223
00:11:19,730 --> 00:11:24,380
bits out<font color="#E5E5E5"> of</font><font color="#CCCCCC"> memory even</font><font color="#E5E5E5"> though some of</font>

224
00:11:21,530 --> 00:11:27,260
<font color="#E5E5E5">them were undefined and then use and to</font>

225
00:11:24,380 --> 00:11:30,590
mask out<font color="#CCCCCC"> the undefined bits and we need</font>

226
00:11:27,260 --> 00:11:37,040
you know and with a mask<font color="#CCCCCC"> and we need to</font>

227
00:11:30,590 --> 00:11:38,540
be able to track that<font color="#E5E5E5"> exactly so at this</font>

228
00:11:37,040 --> 00:11:40,599
point<font color="#E5E5E5"> I don't want</font><font color="#CCCCCC"> to get too</font><font color="#E5E5E5"> much into</font>

229
00:11:38,540 --> 00:11:44,390
<font color="#E5E5E5">the mass but what I want to show is</font><font color="#CCCCCC"> that</font>

230
00:11:40,600 --> 00:11:47,480
we're going<font color="#E5E5E5"> to take our initial naive</font>

231
00:11:44,390 --> 00:11:50,210
simplistic term<font color="#E5E5E5"> and then we're going to</font>

232
00:11:47,480 --> 00:11:53,300
improve<font color="#E5E5E5"> it by using defined if defined</font>

233
00:11:50,210 --> 00:11:56,180
<font color="#E5E5E5">and we're going to generate</font><font color="#CCCCCC"> two sort of</font>

234
00:11:53,300 --> 00:11:58,790
improvement terms from the operands

235
00:11:56,180 --> 00:12:02,050
which tell you where you have<font color="#E5E5E5"> defined</font>

236
00:11:58,790 --> 00:12:02,050
<font color="#CCCCCC">zeroes in the</font><font color="#E5E5E5"> input</font>

237
00:12:02,660 --> 00:12:07,640
so one one thing that you can take<font color="#E5E5E5"> from</font>

238
00:12:05,480 --> 00:12:10,760
this is<font color="#E5E5E5"> that to instrument</font><font color="#CCCCCC"> an and</font>

239
00:12:07,640 --> 00:12:13,550
<font color="#CCCCCC">operation you need to know not only the</font>

240
00:12:10,760 --> 00:12:15,819
defied illness of the inputs but<font color="#E5E5E5"> you</font>

241
00:12:13,550 --> 00:12:20,290
also need them<font color="#CCCCCC"> that to know the actual</font>

242
00:12:15,820 --> 00:12:24,710
<font color="#E5E5E5">input values now so you have four</font><font color="#CCCCCC"> inputs</font>

243
00:12:20,290 --> 00:12:26,719
and<font color="#E5E5E5"> it's turns beginning to turn into a</font>

244
00:12:24,710 --> 00:12:28,580
big<font color="#E5E5E5"> complicated piece of code you know</font>

245
00:12:26,720 --> 00:12:31,610
you have a bunch<font color="#E5E5E5"> of ands and ORS and</font>

246
00:12:28,580 --> 00:12:36,010
nots<font color="#E5E5E5"> and stuff so it's kind of</font>

247
00:12:31,610 --> 00:12:38,810
suboptimal but that you<font color="#E5E5E5"> have to do it</font>

248
00:12:36,010 --> 00:12:40,010
<font color="#CCCCCC">same deal for</font><font color="#E5E5E5"> all you know when you turn</font>

249
00:12:38,810 --> 00:12:44,300
everything upside down

250
00:12:40,010 --> 00:12:46,130
it's what the ones and<font color="#CCCCCC"> zeroes but</font><font color="#E5E5E5"> the</font>

251
00:12:44,300 --> 00:12:47,930
good news<font color="#E5E5E5"> is that this is an exact</font>

252
00:12:46,130 --> 00:12:50,180
interpretation<font color="#CCCCCC"> it gives you exactly the</font>

253
00:12:47,930 --> 00:12:54,010
<font color="#CCCCCC">route results and that's a fact</font>

254
00:12:50,180 --> 00:12:54,010
which we will come back to<font color="#E5E5E5"> shortly</font>

255
00:12:56,970 --> 00:13:01,800
so I want to show you one more example

256
00:12:59,310 --> 00:13:06,780
<font color="#CCCCCC">which has actually become big problem</font>

257
00:13:01,800 --> 00:13:09,870
<font color="#E5E5E5">recently which sounds</font><font color="#CCCCCC"> so harmless</font><font color="#E5E5E5"> and</font>

258
00:13:06,780 --> 00:13:13,770
it's in instrumenting integer equality

259
00:13:09,870 --> 00:13:15,690
on not not<font color="#CCCCCC"> equality so the program is</font>

260
00:13:13,770 --> 00:13:18,960
<font color="#CCCCCC">going</font><font color="#E5E5E5"> to compute a single bit result by</font>

261
00:13:15,690 --> 00:13:24,780
comparing two integers<font color="#E5E5E5"> like whatever</font>

262
00:13:18,960 --> 00:13:29,400
<font color="#E5E5E5">size</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> sounds harmless right so we're</font>

263
00:13:24,780 --> 00:13:31,470
gonna use<font color="#E5E5E5"> PCAST ufu again</font><font color="#CCCCCC"> to merge them</font>

264
00:13:29,400 --> 00:13:34,290
sort of in<font color="#CCCCCC"> parallel then we're going to</font>

265
00:13:31,470 --> 00:13:37,260
<font color="#E5E5E5">use PCAST to merge all the bits down to</font>

266
00:13:34,290 --> 00:13:40,230
a single<font color="#E5E5E5"> bit so the result of this is</font>

267
00:13:37,260 --> 00:13:43,189
that<font color="#E5E5E5"> we say the result is going to be</font>

268
00:13:40,230 --> 00:13:47,640
undefined<font color="#E5E5E5"> if any input bit is undefined</font>

269
00:13:43,190 --> 00:13:50,610
<font color="#E5E5E5">and it's like okay sounds reasonable</font>

270
00:13:47,640 --> 00:13:55,020
and actually this worked<font color="#E5E5E5"> pretty well for</font>

271
00:13:50,610 --> 00:13:58,920
<font color="#CCCCCC">about ten years until</font><font color="#E5E5E5"> in about 2015 but</font>

272
00:13:55,020 --> 00:14:01,650
<font color="#E5E5E5">actually you</font><font color="#CCCCCC"> don't work no more because</font>

273
00:13:58,920 --> 00:14:03,990
clang<font color="#E5E5E5"> three came along and then I think</font>

274
00:14:01,650 --> 00:14:07,250
<font color="#E5E5E5">GCC picks up</font><font color="#CCCCCC"> its bad habits from Planck</font>

275
00:14:03,990 --> 00:14:11,040
so that's my theory<font color="#CCCCCC"> anyway</font>

276
00:14:07,250 --> 00:14:13,260
<font color="#E5E5E5">so what clang will do nowadays</font><font color="#CCCCCC"> imagine</font>

277
00:14:11,040 --> 00:14:16,740
<font color="#E5E5E5">that we have this structure which</font>

278
00:14:13,260 --> 00:14:18,720
contains<font color="#CCCCCC"> two 16-bit</font><font color="#E5E5E5"> ins and we want to</font>

279
00:14:16,740 --> 00:14:25,050
compare you<font color="#CCCCCC"> know both of</font><font color="#E5E5E5"> them and then</font>

280
00:14:18,720 --> 00:14:27,390
do something so what plan will do and

281
00:14:25,050 --> 00:14:29,939
<font color="#E5E5E5">probably what GCC will do now as well is</font>

282
00:14:27,390 --> 00:14:31,920
<font color="#CCCCCC">just generate a</font><font color="#E5E5E5"> 32-bit load for both</font>

283
00:14:29,940 --> 00:14:35,580
fields<font color="#E5E5E5"> of the structure and then and</font>

284
00:14:31,920 --> 00:14:42,810
then compare<font color="#E5E5E5"> you know it</font><font color="#CCCCCC"> has a single</font>

285
00:14:35,580 --> 00:14:46,410
<font color="#E5E5E5">thing so if in the</font><font color="#CCCCCC"> original source code</font>

286
00:14:42,810 --> 00:14:47,969
if this<font color="#CCCCCC"> num if this</font><font color="#E5E5E5"> is not true then it</font>

287
00:14:46,410 --> 00:14:51,180
never looks<font color="#E5E5E5"> at that because of the C</font>

288
00:14:47,970 --> 00:14:55,410
semantics but here<font color="#E5E5E5"> it's going to look at</font>

289
00:14:51,180 --> 00:14:57,510
it anyway<font color="#CCCCCC"> so we wind up doing a</font>

290
00:14:55,410 --> 00:15:01,620
<font color="#E5E5E5">comparison on partially uninitialized</font>

291
00:14:57,510 --> 00:15:05,450
data and I'm thinking<font color="#E5E5E5"> I want</font><font color="#CCCCCC"> to kill</font>

292
00:15:01,620 --> 00:15:05,450
myself<font color="#E5E5E5"> no no it's not</font><font color="#CCCCCC"> never</font>

293
00:15:06,010 --> 00:15:12,680
so what can<font color="#E5E5E5"> we do about this so you</font>

294
00:15:10,010 --> 00:15:14,120
observe that the program<font color="#E5E5E5"> will</font><font color="#CCCCCC"> actually</font>

295
00:15:12,680 --> 00:15:16,069
still works right when the<font color="#E5E5E5"> compiler</font>

296
00:15:14,120 --> 00:15:18,440
compiles it like this<font color="#E5E5E5"> so</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> must</font>

297
00:15:16,070 --> 00:15:19,820
actually be correct the question<font color="#CCCCCC"> is to</font>

298
00:15:18,440 --> 00:15:25,160
make the instrumentation actually

299
00:15:19,820 --> 00:15:28,520
matched reality<font color="#CCCCCC"> now so what is the key</font>

300
00:15:25,160 --> 00:15:31,310
<font color="#CCCCCC">observation</font><font color="#E5E5E5"> the key</font><font color="#CCCCCC"> observation is that</font>

301
00:15:28,520 --> 00:15:33,199
<font color="#CCCCCC">if you you need to</font><font color="#E5E5E5"> find</font><font color="#CCCCCC"> two different</font>

302
00:15:31,310 --> 00:15:37,359
<font color="#CCCCCC">two corresponding bits in the input here</font>

303
00:15:33,200 --> 00:15:41,360
<font color="#E5E5E5">I write</font><font color="#CCCCCC"> X 0</font><font color="#E5E5E5"> and 1 and if they are</font>

304
00:15:37,360 --> 00:15:43,670
different<font color="#CCCCCC"> and they're both defined</font><font color="#E5E5E5"> then</font>

305
00:15:41,360 --> 00:15:47,300
we know<font color="#CCCCCC"> that the tube at</font><font color="#E5E5E5"> that the</font><font color="#CCCCCC"> hole</font>

306
00:15:43,670 --> 00:15:49,939
<font color="#CCCCCC">were two words here are</font><font color="#E5E5E5"> not the same</font>

307
00:15:47,300 --> 00:15:51,680
<font color="#E5E5E5">right so we don't we know that</font><font color="#CCCCCC"> these two</font>

308
00:15:49,940 --> 00:15:52,640
<font color="#CCCCCC">words are not the</font><font color="#E5E5E5"> same regardless of the</font>

309
00:15:51,680 --> 00:15:56,630
fact that we<font color="#CCCCCC"> don't</font><font color="#E5E5E5"> know what all these</font>

310
00:15:52,640 --> 00:15:59,510
X's are because<font color="#E5E5E5"> of 1 and 0 make it so in</font>

311
00:15:56,630 --> 00:16:01,340
this case the<font color="#CCCCCC"> two zeros</font><font color="#E5E5E5"> don't help us</font>

312
00:15:59,510 --> 00:16:04,400
because we<font color="#E5E5E5"> still</font><font color="#CCCCCC"> need to look</font><font color="#E5E5E5"> at the X's</font>

313
00:16:01,340 --> 00:16:07,090
to determine whether they're different

314
00:16:04,400 --> 00:16:07,090
<font color="#E5E5E5">yeah</font>

315
00:16:14,709 --> 00:16:20,209
you're right it's a bug<font color="#E5E5E5"> yes yes result</font>

316
00:16:19,399 --> 00:16:23,750
<font color="#E5E5E5">is defined</font>

317
00:16:20,209 --> 00:16:28,250
I checked it so carefully this morning<font color="#CCCCCC"> -</font>

318
00:16:23,750 --> 00:16:32,390
well thank<font color="#E5E5E5"> you so yes we can fix up the</font>

319
00:16:28,250 --> 00:16:35,660
scheme<font color="#CCCCCC"> like</font><font color="#E5E5E5"> we did</font><font color="#CCCCCC"> before so we're going</font>

320
00:16:32,390 --> 00:16:38,930
to take our<font color="#E5E5E5"> naive version which is you</font>

321
00:16:35,660 --> 00:16:41,750
if you again<font color="#E5E5E5"> but this time</font><font color="#CCCCCC"> we're going</font>

322
00:16:38,930 --> 00:16:43,880
<font color="#E5E5E5">to generate</font><font color="#CCCCCC"> some improving term which</font>

323
00:16:41,750 --> 00:16:46,550
kind of improves the result makes it

324
00:16:43,880 --> 00:16:48,950
more<font color="#CCCCCC"> defined</font><font color="#E5E5E5"> exactly</font><font color="#CCCCCC"> by looking</font><font color="#E5E5E5"> for bit</font>

325
00:16:46,550 --> 00:16:53,870
<font color="#E5E5E5">pairs like this which they're different</font>

326
00:16:48,950 --> 00:16:55,490
<font color="#E5E5E5">but the same so it gets come not</font>

327
00:16:53,870 --> 00:16:58,190
expecting you<font color="#CCCCCC"> to understand this</font><font color="#E5E5E5"> but the</font>

328
00:16:55,490 --> 00:17:00,680
<font color="#E5E5E5">point is it gets</font><font color="#CCCCCC"> complement it gets</font>

329
00:16:58,190 --> 00:17:04,459
complicated<font color="#CCCCCC"> fast and it gets</font><font color="#E5E5E5"> expensive</font>

330
00:17:00,680 --> 00:17:05,688
fast<font color="#E5E5E5"> so you know we haven't improve a</font>

331
00:17:04,459 --> 00:17:08,929
term and<font color="#E5E5E5"> then we have this weird</font>

332
00:17:05,689 --> 00:17:11,500
function which actually does a kind<font color="#CCCCCC"> of</font>

333
00:17:08,929 --> 00:17:14,390
optimistic cast it's a parallel to the

334
00:17:11,500 --> 00:17:17,480
<font color="#E5E5E5">pessimistic cast talked about earlier</font>

335
00:17:14,390 --> 00:17:20,000
you<font color="#CCCCCC"> can look at the gory details in the</font>

336
00:17:17,480 --> 00:17:23,990
<font color="#CCCCCC">codebase if you really want to want</font><font color="#E5E5E5"> to</font>

337
00:17:20,000 --> 00:17:28,820
see this<font color="#E5E5E5"> stuff but the real point about</font>

338
00:17:23,990 --> 00:17:31,190
<font color="#E5E5E5">it</font><font color="#CCCCCC"> is that this</font><font color="#E5E5E5"> is expensive</font><font color="#CCCCCC"> to do</font><font color="#E5E5E5"> it's</font>

339
00:17:28,820 --> 00:17:33,830
like going to be ten instructions<font color="#CCCCCC"> now in</font>

340
00:17:31,190 --> 00:17:36,980
the in the code in in the generated<font color="#CCCCCC"> code</font>

341
00:17:33,830 --> 00:17:40,939
instead of<font color="#E5E5E5"> three or</font><font color="#CCCCCC"> four it's actually</font>

342
00:17:36,980 --> 00:17:42,400
difficult<font color="#E5E5E5"> to prove</font><font color="#CCCCCC"> right so I had my</font>

343
00:17:40,940 --> 00:17:45,230
prop here somewhere

344
00:17:42,400 --> 00:17:47,030
so I have this whole<font color="#E5E5E5"> bundle of bits of</font>

345
00:17:45,230 --> 00:17:49,160
<font color="#E5E5E5">paper which</font><font color="#CCCCCC"> is my proof attempts</font><font color="#E5E5E5"> to</font>

346
00:17:47,030 --> 00:17:52,940
prove that<font color="#E5E5E5"> there's this several pages</font>

347
00:17:49,160 --> 00:17:55,450
<font color="#E5E5E5">not just one attempts to prove that this</font>

348
00:17:52,940 --> 00:17:59,540
transformation<font color="#CCCCCC"> actually is correct</font><font color="#E5E5E5"> and</font>

349
00:17:55,450 --> 00:18:02,390
it's<font color="#E5E5E5"> generally ungood also</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> function</font>

350
00:17:59,540 --> 00:18:04,850
<font color="#CCCCCC">o cast which is a kind of a shortcut</font><font color="#E5E5E5"> way</font>

351
00:18:02,390 --> 00:18:08,929
<font color="#CCCCCC">of saying if any input</font><font color="#E5E5E5"> is defined and</font>

352
00:18:04,850 --> 00:18:11,480
the whole result<font color="#E5E5E5"> is defined</font><font color="#CCCCCC"> i had a less</font>

353
00:18:08,929 --> 00:18:13,250
efficient version<font color="#E5E5E5"> before and this weird</font>

354
00:18:11,480 --> 00:18:15,350
version<font color="#E5E5E5"> is generated by the new super</font>

355
00:18:13,250 --> 00:18:17,330
optimizer<font color="#CCCCCC"> so</font><font color="#E5E5E5"> that actually improved the</font>

356
00:18:15,350 --> 00:18:20,659
<font color="#E5E5E5">poem performance a lot but it makes it</font>

357
00:18:17,330 --> 00:18:23,720
<font color="#E5E5E5">even more obscure</font>

358
00:18:20,660 --> 00:18:29,670
so the question is well that's kind<font color="#E5E5E5"> of</font>

359
00:18:23,720 --> 00:18:32,160
rubbish can we do anything better<font color="#CCCCCC"> so</font><font color="#E5E5E5"> we</font>

360
00:18:29,670 --> 00:18:35,040
can<font color="#CCCCCC"> kind of do it</font><font color="#E5E5E5"> something better so we</font>

361
00:18:32,160 --> 00:18:37,170
cannot necessarily<font color="#E5E5E5"> do it faster but at</font>

362
00:18:35,040 --> 00:18:41,280
least there's a look at least<font color="#E5E5E5"> that's a</font>

363
00:18:37,170 --> 00:18:44,810
way to to<font color="#E5E5E5"> prove whether the these</font>

364
00:18:41,280 --> 00:18:47,790
<font color="#E5E5E5">interpretations are correct or not and</font>

365
00:18:44,810 --> 00:18:49,980
<font color="#CCCCCC">what</font><font color="#E5E5E5"> you can see</font><font color="#CCCCCC"> from sort of</font><font color="#E5E5E5"> basic</font>

366
00:18:47,790 --> 00:18:52,800
<font color="#CCCCCC">boolean algebra is</font><font color="#E5E5E5"> that you can write</font>

367
00:18:49,980 --> 00:18:55,230
any function any common<font color="#E5E5E5"> Astoria logic</font>

368
00:18:52,800 --> 00:18:59,190
function<font color="#E5E5E5"> you know this is like billion</font>

369
00:18:55,230 --> 00:19:03,810
algebra 101<font color="#CCCCCC"> using just</font><font color="#E5E5E5"> and or a not on</font>

370
00:18:59,190 --> 00:19:05,550
individual<font color="#E5E5E5"> bits right you're also</font><font color="#CCCCCC"> XOR</font>

371
00:19:03,810 --> 00:19:07,710
because it's kind<font color="#CCCCCC"> of convenient</font><font color="#E5E5E5"> here so</font>

372
00:19:05,550 --> 00:19:11,460
we can we<font color="#CCCCCC"> can take some</font><font color="#E5E5E5"> subset of these</font>

373
00:19:07,710 --> 00:19:14,490
three<font color="#E5E5E5"> and like I said in</font><font color="#CCCCCC"> my previous</font>

374
00:19:11,460 --> 00:19:16,860
<font color="#E5E5E5">slide</font><font color="#CCCCCC"> for and and or we have an exact</font>

375
00:19:14,490 --> 00:19:21,960
interpretation<font color="#E5E5E5"> exact instrumentation and</font>

376
00:19:16,860 --> 00:19:24,689
<font color="#E5E5E5">the</font><font color="#CCCCCC"> same is true for not an XOR so that</font>

377
00:19:21,960 --> 00:19:26,280
means that if<font color="#CCCCCC"> we first take</font><font color="#E5E5E5"> any</font>

378
00:19:24,690 --> 00:19:28,410
operation we want<font color="#CCCCCC"> to instrument</font>

379
00:19:26,280 --> 00:19:31,230
write it in terms of single bits and

380
00:19:28,410 --> 00:19:33,600
then apply<font color="#CCCCCC"> our instrumentation scheme to</font>

381
00:19:31,230 --> 00:19:35,310
that then<font color="#E5E5E5"> we will have something which</font>

382
00:19:33,600 --> 00:19:37,230
is<font color="#CCCCCC"> actually correct even if</font><font color="#E5E5E5"> it's not</font>

383
00:19:35,310 --> 00:19:39,060
optimal<font color="#E5E5E5"> and then what you need to do is</font>

384
00:19:37,230 --> 00:19:46,170
prove<font color="#CCCCCC"> that that's the same</font><font color="#E5E5E5"> as what</font>

385
00:19:39,060 --> 00:19:51,470
<font color="#E5E5E5">you're generating code with so my my</font>

386
00:19:46,170 --> 00:19:51,470
prop here is<font color="#E5E5E5"> my proof that for equality</font>

387
00:19:54,790 --> 00:20:04,000
the optimizer no no<font color="#E5E5E5"> so I wanted to say</font>

388
00:20:01,960 --> 00:20:06,070
first<font color="#CCCCCC"> this is just what</font><font color="#E5E5E5"> you do for a</font>

389
00:20:04,000 --> 00:20:08,530
<font color="#CCCCCC">three</font><font color="#E5E5E5"> bit input three bit equality so</font>

390
00:20:06,070 --> 00:20:11,800
you expand it<font color="#CCCCCC"> like this and then you</font>

391
00:20:08,530 --> 00:20:17,410
expand it<font color="#E5E5E5"> with these not</font><font color="#CCCCCC"> an XOR</font><font color="#E5E5E5"> and then</font>

392
00:20:11,800 --> 00:20:19,570
you apply the interpretation<font color="#CCCCCC"> to this and</font>

393
00:20:17,410 --> 00:20:23,140
what you try<font color="#CCCCCC"> and do or what I try</font><font color="#E5E5E5"> to do</font>

394
00:20:19,570 --> 00:20:27,070
is prove that the<font color="#E5E5E5"> instrumentation of</font>

395
00:20:23,140 --> 00:20:30,490
this is the same as what I<font color="#E5E5E5"> actually</font>

396
00:20:27,070 --> 00:20:31,409
implemented which is no fun<font color="#CCCCCC"> but it's</font>

397
00:20:30,490 --> 00:20:35,440
doable

398
00:20:31,410 --> 00:20:38,050
wouldn't you be<font color="#CCCCCC"> sign have to do the same</font>

399
00:20:35,440 --> 00:20:39,820
well I think<font color="#CCCCCC"> ups and actually I don't</font>

400
00:20:38,050 --> 00:20:40,899
know<font color="#E5E5E5"> how</font><font color="#CCCCCC"> exactly how it works but I</font>

401
00:20:39,820 --> 00:20:43,120
think it<font color="#E5E5E5"> probably has a simple</font>

402
00:20:40,900 --> 00:20:45,130
instrumentation scheme that just

403
00:20:43,120 --> 00:20:47,530
determines observes when you're reading

404
00:20:45,130 --> 00:20:50,410
uninitialized memory but I don't know if

405
00:20:47,530 --> 00:20:53,590
<font color="#E5E5E5">they actually tracks in this much detail</font>

406
00:20:50,410 --> 00:20:58,810
<font color="#E5E5E5">but</font><font color="#CCCCCC"> I would say I do not</font><font color="#E5E5E5"> know how our</font>

407
00:20:53,590 --> 00:21:00,459
<font color="#E5E5E5">son works</font><font color="#CCCCCC"> I actually was talking about M</font>

408
00:20:58,810 --> 00:21:03,149
<font color="#CCCCCC">sensor option is something a</font><font color="#E5E5E5"> bit</font>

409
00:21:00,460 --> 00:21:03,150
<font color="#E5E5E5">different as well</font>

410
00:21:04,870 --> 00:21:16,229
anyways<font color="#E5E5E5"> please thank you for</font>

411
00:21:14,110 --> 00:21:16,229
<font color="#CCCCCC">volunteering</font>

412
00:21:16,350 --> 00:21:20,199
yes you<font color="#E5E5E5"> probably could</font><font color="#CCCCCC"> if I knew about</font>

413
00:21:18,700 --> 00:21:22,929
that<font color="#CCCCCC"> stuff and</font><font color="#E5E5E5"> I had enough time</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> do</font>

414
00:21:20,200 --> 00:21:24,700
it<font color="#CCCCCC"> I mean</font><font color="#E5E5E5"> yes it would be good</font><font color="#CCCCCC"> but</font>

415
00:21:22,929 --> 00:21:27,429
<font color="#CCCCCC">there's also a lot of</font><font color="#E5E5E5"> other things like</font>

416
00:21:24,700 --> 00:21:29,650
we have<font color="#CCCCCC"> an</font><font color="#E5E5E5"> expensive interpretation for</font>

417
00:21:27,429 --> 00:21:31,270
<font color="#CCCCCC">ADD and supply which</font><font color="#E5E5E5"> is exact and I</font>

418
00:21:29,650 --> 00:21:33,700
would like<font color="#E5E5E5"> to prove that that is correct</font>

419
00:21:31,270 --> 00:21:35,740
<font color="#E5E5E5">and not</font><font color="#CCCCCC"> only</font><font color="#E5E5E5"> prove is correct but maybe</font>

420
00:21:33,700 --> 00:21:39,399
find a faster way to do it<font color="#CCCCCC"> because it's</font>

421
00:21:35,740 --> 00:21:40,779
slow so anyway enough<font color="#CCCCCC"> about</font><font color="#E5E5E5"> bit</font>

422
00:21:39,399 --> 00:21:42,879
twiddling I<font color="#CCCCCC"> want to do</font><font color="#E5E5E5"> actually sort</font><font color="#CCCCCC"> of</font>

423
00:21:40,779 --> 00:21:46,690
show what<font color="#E5E5E5"> the current state is more or</font>

424
00:21:42,880 --> 00:21:49,149
less<font color="#E5E5E5"> is so in the</font><font color="#CCCCCC"> in the current trunk</font>

425
00:21:46,690 --> 00:21:49,570
which will be in 3.14<font color="#E5E5E5"> which is not</font>

426
00:21:49,149 --> 00:21:54,010
released

427
00:21:49,570 --> 00:21:56,889
we have exact<font color="#E5E5E5"> interpretation of add and</font>

428
00:21:54,010 --> 00:21:57,760
subtract<font color="#CCCCCC"> which is actually driven by an</font>

429
00:21:56,890 --> 00:22:01,779
analysis

430
00:21:57,760 --> 00:22:05,230
so when of the block being instrumented

431
00:22:01,779 --> 00:22:11,289
<font color="#E5E5E5">so when it knows that we don't</font><font color="#CCCCCC"> actually</font>

432
00:22:05,230 --> 00:22:13,240
care<font color="#E5E5E5"> about</font><font color="#CCCCCC"> all whether in certain</font>

433
00:22:11,289 --> 00:22:14,980
<font color="#E5E5E5">circumstances it can show that the cheap</font>

434
00:22:13,240 --> 00:22:17,169
<font color="#E5E5E5">and expensive interpretations are going</font>

435
00:22:14,980 --> 00:22:19,750
to produce the same<font color="#E5E5E5"> result and so it</font>

436
00:22:17,169 --> 00:22:22,779
<font color="#CCCCCC">uses a cheat when it when it</font><font color="#E5E5E5"> whenever it</font>

437
00:22:19,750 --> 00:22:25,260
<font color="#E5E5E5">can and we do an exact integer equality</font>

438
00:22:22,779 --> 00:22:27,429
<font color="#E5E5E5">by default now so that actually really</font>

439
00:22:25,260 --> 00:22:29,230
produced a performer's loss of about

440
00:22:27,429 --> 00:22:31,630
<font color="#E5E5E5">three to four percent in men check but</font>

441
00:22:29,230 --> 00:22:35,409
it's like well it's<font color="#E5E5E5"> either that or just</font>

442
00:22:31,630 --> 00:22:37,110
<font color="#E5E5E5">have all these false</font><font color="#CCCCCC"> positives occurring</font>

443
00:22:35,409 --> 00:22:40,059
to everybody who<font color="#E5E5E5"> uses you know clang</font>

444
00:22:37,110 --> 00:22:42,309
<font color="#E5E5E5">optimized code and GCC seven optimized</font>

445
00:22:40,059 --> 00:22:45,158
code and it's like no<font color="#E5E5E5"> they want to go</font>

446
00:22:42,309 --> 00:22:46,480
there because<font color="#E5E5E5"> having a low false</font>

447
00:22:45,159 --> 00:22:51,010
<font color="#CCCCCC">positive rate I think is</font><font color="#E5E5E5"> really</font>

448
00:22:46,480 --> 00:22:53,169
important<font color="#CCCCCC"> sort of</font><font color="#E5E5E5"> for the record we have</font>

449
00:22:51,010 --> 00:22:56,408
long since implemented and or and not

450
00:22:53,169 --> 00:22:58,659
<font color="#CCCCCC">and shifts and some other stuff widening</font>

451
00:22:56,409 --> 00:23:01,630
exactly<font color="#E5E5E5"> because but all the basic bit</font>

452
00:22:58,659 --> 00:23:03,250
twiddling stuff that<font color="#CCCCCC"> gets done most</font>

453
00:23:01,630 --> 00:23:05,679
other stuff including<font color="#E5E5E5"> floating point is</font>

454
00:23:03,250 --> 00:23:08,110
just approximated<font color="#E5E5E5"> on the basis that you</font>

455
00:23:05,679 --> 00:23:10,210
know any<font color="#E5E5E5"> input that's undefined</font><font color="#CCCCCC"> reduces</font>

456
00:23:08,110 --> 00:23:13,559
<font color="#E5E5E5">our causes</font><font color="#CCCCCC"> hole</font><font color="#E5E5E5"> output to be undefined</font>

457
00:23:10,210 --> 00:23:13,559
<font color="#E5E5E5">and that's sort of good enough</font>

458
00:23:13,750 --> 00:23:20,410
so result is<font color="#E5E5E5"> it's kind of works fairly</font>

459
00:23:17,200 --> 00:23:22,960
well for<font color="#CCCCCC"> DCC 17</font><font color="#E5E5E5"> clang</font><font color="#CCCCCC"> 5</font><font color="#E5E5E5"> it also works</font>

460
00:23:20,410 --> 00:23:25,300
for rust<font color="#CCCCCC"> see compiled</font><font color="#E5E5E5"> code because</font>

461
00:23:22,960 --> 00:23:27,670
<font color="#E5E5E5">that's for me a</font><font color="#CCCCCC"> priority because</font><font color="#E5E5E5"> that's</font>

462
00:23:25,300 --> 00:23:32,080
a<font color="#CCCCCC"> priority for Mozilla and rust is a big</font>

463
00:23:27,670 --> 00:23:35,710
deal in Mozilla now some somewhat open

464
00:23:32,080 --> 00:23:38,350
questions<font color="#E5E5E5"> I'm still dealing with 3-way</font>

465
00:23:35,710 --> 00:23:42,330
in comparisons<font color="#E5E5E5"> for the power instruction</font>

466
00:23:38,350 --> 00:23:45,639
set<font color="#E5E5E5"> how they do comparisons is</font><font color="#CCCCCC"> different</font>

467
00:23:42,330 --> 00:23:47,620
<font color="#CCCCCC">like I said I'd like adding subtract the</font>

468
00:23:45,640 --> 00:23:53,830
and equality<font color="#E5E5E5"> and not</font><font color="#CCCCCC"> equality to be</font>

469
00:23:47,620 --> 00:23:56,500
faster<font color="#E5E5E5"> and</font><font color="#CCCCCC"> so maybe some clever person</font>

470
00:23:53,830 --> 00:23:58,689
can figure<font color="#CCCCCC"> out how</font><font color="#E5E5E5"> to do this we can</font>

471
00:23:56,500 --> 00:24:01,720
also be somewhat clever about<font color="#E5E5E5"> the</font>

472
00:23:58,690 --> 00:24:05,950
instrumentation<font color="#E5E5E5"> because you can kind</font><font color="#CCCCCC"> of</font>

473
00:24:01,720 --> 00:24:09,760
see<font color="#E5E5E5"> optimize up opportunities for</font>

474
00:24:05,950 --> 00:24:12,340
<font color="#E5E5E5">optimization where you do all this exact</font>

475
00:24:09,760 --> 00:24:13,840
tracking of bits<font color="#E5E5E5"> but then at the end at</font>

476
00:24:12,340 --> 00:24:15,580
<font color="#E5E5E5">the end of this chain</font><font color="#CCCCCC"> of computation all</font>

477
00:24:13,840 --> 00:24:17,590
you care about is are any of them

478
00:24:15,580 --> 00:24:20,320
undefined or not and it might be

479
00:24:17,590 --> 00:24:23,830
<font color="#CCCCCC">possible in that case to actually do the</font>

480
00:24:20,320 --> 00:24:26,560
<font color="#E5E5E5">whole sequence more cheaply</font><font color="#CCCCCC"> so that sort</font>

481
00:24:23,830 --> 00:24:29,429
of<font color="#CCCCCC"> patatas old game called abstract</font>

482
00:24:26,560 --> 00:24:29,429
interpretation<font color="#CCCCCC"> yeah</font>

483
00:24:31,480 --> 00:24:36,220
<font color="#E5E5E5">like this for</font><font color="#CCCCCC"> example for</font><font color="#E5E5E5"> see holy</font>

484
00:24:33,760 --> 00:24:37,720
<font color="#CCCCCC">community I mean you can</font><font color="#E5E5E5"> have the</font>

485
00:24:36,220 --> 00:24:41,490
cheaper<font color="#CCCCCC"> equality test</font>

486
00:24:37,720 --> 00:24:41,490
<font color="#E5E5E5">yeah after taking the right</font>

487
00:24:41,990 --> 00:25:03,300
some kind of<font color="#E5E5E5"> speculative thing maybe so</font>

488
00:25:00,750 --> 00:25:05,160
I just wanted<font color="#E5E5E5"> to end by showing</font><font color="#CCCCCC"> two open</font>

489
00:25:03,300 --> 00:25:07,740
questions one of<font color="#E5E5E5"> which is not a big deal</font>

490
00:25:05,160 --> 00:25:09,420
and the other which is a big deal<font color="#E5E5E5"> so the</font>

491
00:25:07,740 --> 00:25:12,540
one that's<font color="#E5E5E5"> not</font><font color="#CCCCCC"> a big</font><font color="#E5E5E5"> deal is about</font>

492
00:25:09,420 --> 00:25:15,390
<font color="#E5E5E5">exclusive or so exclusive</font><font color="#CCCCCC"> or is kind</font><font color="#E5E5E5"> of</font>

493
00:25:12,540 --> 00:25:19,530
<font color="#E5E5E5">weird and it doesn't really fit in the</font>

494
00:25:15,390 --> 00:25:22,590
<font color="#E5E5E5">frame work properly because if you take</font>

495
00:25:19,530 --> 00:25:24,510
<font color="#E5E5E5">any value and put it in</font><font color="#CCCCCC"> to both</font>

496
00:25:22,590 --> 00:25:28,649
<font color="#E5E5E5">arguments of an exclusive or operation</font>

497
00:25:24,510 --> 00:25:30,740
and you get<font color="#CCCCCC"> a zero as a result and</font><font color="#E5E5E5"> it</font>

498
00:25:28,650 --> 00:25:33,450
doesn't<font color="#E5E5E5"> matter what those values were</font>

499
00:25:30,740 --> 00:25:36,000
what actually matters is the<font color="#E5E5E5"> identity of</font>

500
00:25:33,450 --> 00:25:38,760
the values so if I have a value here

501
00:25:36,000 --> 00:25:41,130
which I put in one side<font color="#E5E5E5"> of my exclusive</font>

502
00:25:38,760 --> 00:25:43,140
<font color="#E5E5E5">or now I send the other value sort of</font>

503
00:25:41,130 --> 00:25:44,730
all<font color="#E5E5E5"> around the place you know behind the</font>

504
00:25:43,140 --> 00:25:46,620
moon and back<font color="#E5E5E5"> into the</font><font color="#CCCCCC"> other side</font><font color="#E5E5E5"> of the</font>

505
00:25:44,730 --> 00:25:49,890
<font color="#CCCCCC">exclusive-or then</font><font color="#E5E5E5"> you get the same you</font>

506
00:25:46,620 --> 00:25:52,459
get<font color="#E5E5E5"> a defined value and so we do not</font>

507
00:25:49,890 --> 00:25:54,780
<font color="#E5E5E5">have</font><font color="#CCCCCC"> anything</font><font color="#E5E5E5"> that tracks identity of</font>

508
00:25:52,460 --> 00:25:59,010
the values I don't even<font color="#E5E5E5"> know how to do</font>

509
00:25:54,780 --> 00:26:01,379
it<font color="#E5E5E5"> for some</font><font color="#CCCCCC"> simple cases like X soaring</font>

510
00:25:59,010 --> 00:26:03,390
to register you know the same<font color="#E5E5E5"> register</font>

511
00:26:01,380 --> 00:26:06,750
together twice to<font color="#CCCCCC"> produce zero which is</font>

512
00:26:03,390 --> 00:26:10,050
a standard idiom<font color="#E5E5E5"> then it's fine but in</font>

513
00:26:06,750 --> 00:26:12,000
some more complicated cases like bit

514
00:26:10,050 --> 00:26:15,740
field assignments<font color="#CCCCCC"> from the visual studio</font>

515
00:26:12,000 --> 00:26:15,740
<font color="#E5E5E5">compiler then you get problems</font>

516
00:26:17,279 --> 00:26:24,519
so yes we<font color="#E5E5E5"> truly try and rewrite</font><font color="#CCCCCC"> it</font><font color="#E5E5E5"> on</font>

517
00:26:21,580 --> 00:26:28,299
the fly but it's sort<font color="#E5E5E5"> of difficult and</font>

518
00:26:24,519 --> 00:26:32,820
limited but that's not the big<font color="#CCCCCC"> deal</font><font color="#E5E5E5"> so a</font>

519
00:26:28,299 --> 00:26:37,330
much more<font color="#E5E5E5"> serious problem is that</font>

520
00:26:32,820 --> 00:26:39,220
<font color="#CCCCCC">playing for started violating a basic</font>

521
00:26:37,330 --> 00:26:40,720
assumption<font color="#CCCCCC"> about</font><font color="#E5E5E5"> mem check so mem Tech</font>

522
00:26:39,220 --> 00:26:43,139
has always assumed that every

523
00:26:40,720 --> 00:26:45,220
conditional branch you make has

524
00:26:43,139 --> 00:26:48,008
importance in the final result of<font color="#E5E5E5"> the</font>

525
00:26:45,220 --> 00:26:52,659
program<font color="#E5E5E5"> but that's not actually true</font>

526
00:26:48,009 --> 00:26:55,600
anymore<font color="#E5E5E5"> because what both compilers will</font>

527
00:26:52,659 --> 00:26:59,440
do is to in<font color="#E5E5E5"> certain</font><font color="#CCCCCC"> circumstances</font>

528
00:26:55,600 --> 00:27:04,840
compile<font color="#E5E5E5"> a and B in the</font><font color="#CCCCCC"> embassy</font><font color="#E5E5E5"> semantics</font>

529
00:26:59,440 --> 00:27:09,450
as if it was B and a so this<font color="#CCCCCC"> is they're</font>

530
00:27:04,840 --> 00:27:13,570
<font color="#E5E5E5">pretty hard to get your head around</font><font color="#CCCCCC"> but</font>

531
00:27:09,450 --> 00:27:16,389
if if it's always<font color="#CCCCCC"> the case that</font><font color="#E5E5E5"> a is</font>

532
00:27:13,570 --> 00:27:17,889
false whenever B is undefined<font color="#CCCCCC"> then you</font>

533
00:27:16,389 --> 00:27:20,918
can<font color="#E5E5E5"> switch these around and you still</font>

534
00:27:17,889 --> 00:27:24,100
<font color="#E5E5E5">get the same result because you're doing</font>

535
00:27:20,919 --> 00:27:26,379
<font color="#E5E5E5">either if false and undefined</font><font color="#CCCCCC"> which</font><font color="#E5E5E5"> is</font>

536
00:27:24,100 --> 00:27:28,928
false<font color="#E5E5E5"> and here you're doing if undefined</font>

537
00:27:26,379 --> 00:27:30,969
<font color="#E5E5E5">and false so it's either true and false</font>

538
00:27:28,929 --> 00:27:33,309
or false and false<font color="#E5E5E5"> but the problem is</font>

539
00:27:30,970 --> 00:27:37,269
this additional<font color="#E5E5E5"> branch is now on</font>

540
00:27:33,309 --> 00:27:40,029
undefined data<font color="#E5E5E5"> and I think that some</font>

541
00:27:37,269 --> 00:27:43,090
fancy<font color="#E5E5E5"> kind of interprocedural analysis</font>

542
00:27:40,029 --> 00:27:46,359
<font color="#E5E5E5">that</font><font color="#CCCCCC"> plank</font><font color="#E5E5E5"> does in this kind of</font>

543
00:27:43,090 --> 00:27:48,959
situation if<font color="#E5E5E5"> it analyzes the behavior</font>

544
00:27:46,359 --> 00:27:54,090
this but this function<font color="#CCCCCC"> we're calling</font>

545
00:27:48,960 --> 00:27:56,049
yeah it will do that transformation so I

546
00:27:54,090 --> 00:28:03,249
actually have no<font color="#CCCCCC"> idea what to do about</font>

547
00:27:56,049 --> 00:28:05,799
<font color="#E5E5E5">this</font><font color="#CCCCCC"> and it's like you</font><font color="#E5E5E5"> know it produces</font>

548
00:28:03,249 --> 00:28:07,869
false positives on<font color="#E5E5E5"> optimize clang code</font>

549
00:28:05,799 --> 00:28:13,230
and optimize rusts code<font color="#E5E5E5"> and to some</font>

550
00:28:07,869 --> 00:28:13,230
extent<font color="#E5E5E5"> optimized GCC code generated code</font>

551
00:28:14,190 --> 00:28:20,019
well you know maybe<font color="#E5E5E5"> this machine code</font>

552
00:28:17,799 --> 00:28:22,480
analysis game has its limitations<font color="#E5E5E5"> and</font>

553
00:28:20,019 --> 00:28:24,460
this is sort of the end<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the road or</font>

554
00:28:22,480 --> 00:28:28,739
maybe we need some new<font color="#E5E5E5"> framework to do</font>

555
00:28:24,460 --> 00:28:28,739
this but I do not know how to<font color="#E5E5E5"> fix this</font>

556
00:28:34,750 --> 00:28:40,580
yeah<font color="#CCCCCC"> that's</font><font color="#E5E5E5"> how I felt</font>

557
00:28:37,250 --> 00:28:43,770
[Laughter]

558
00:28:40,580 --> 00:28:43,770
[Applause]

559
00:28:47,230 --> 00:28:58,610
<font color="#E5E5E5">is it a accident or is there a reason</font>

560
00:28:53,570 --> 00:29:00,080
why<font color="#E5E5E5"> switching the convictions around</font><font color="#CCCCCC"> now</font>

561
00:28:58,610 --> 00:29:03,949
you mean<font color="#E5E5E5"> does it have</font><font color="#CCCCCC"> a plan does it</font>

562
00:29:00,080 --> 00:29:06,770
have a performance benefit you'd have<font color="#E5E5E5"> to</font>

563
00:29:03,950 --> 00:29:11,270
ask of<font color="#E5E5E5"> GCC or</font><font color="#CCCCCC"> flank person that I cannot</font>

564
00:29:06,770 --> 00:29:14,650
tell you<font color="#CCCCCC"> that I do</font><font color="#E5E5E5"> not know the reason</font>

565
00:29:11,270 --> 00:29:20,290
for<font color="#E5E5E5"> it I wish they wouldn't do</font><font color="#CCCCCC"> it but it</font>

566
00:29:14,650 --> 00:29:22,880
they succeeded maybe it's<font color="#CCCCCC"> just a</font>

567
00:29:20,290 --> 00:29:27,350
transformation<font color="#CCCCCC"> that</font><font color="#E5E5E5"> doesn't really</font>

568
00:29:22,880 --> 00:29:31,640
matter<font color="#E5E5E5"> but make something simpler</font><font color="#CCCCCC"> it</font>

569
00:29:27,350 --> 00:29:34,189
doesn't maybe we can<font color="#CCCCCC"> convince the pilot</font>

570
00:29:31,640 --> 00:29:36,560
yeah that would<font color="#CCCCCC"> be nice</font>

571
00:29:34,190 --> 00:29:38,270
the the<font color="#E5E5E5"> the I know almost nothing about</font>

572
00:29:36,560 --> 00:29:40,790
this<font color="#E5E5E5"> the</font><font color="#CCCCCC"> only</font><font color="#E5E5E5"> thing I know is that</font><font color="#CCCCCC"> I</font>

573
00:29:38,270 --> 00:29:42,379
have the<font color="#CCCCCC"> impression this was something</font>

574
00:29:40,790 --> 00:29:45,620
<font color="#E5E5E5">to do with some class</font><font color="#CCCCCC"> formation which</font>

575
00:29:42,380 --> 00:29:47,740
split basic blocks into<font color="#E5E5E5"> pieces</font><font color="#CCCCCC"> or</font>

576
00:29:45,620 --> 00:29:47,739
something

577
00:29:50,210 --> 00:30:21,690
yeah yeah well<font color="#CCCCCC"> sir I was considering</font>

578
00:30:18,630 --> 00:30:23,220
<font color="#CCCCCC">that and I thinking maybe I can fix it</font>

579
00:30:21,690 --> 00:30:26,190
<font color="#E5E5E5">up</font><font color="#CCCCCC"> but then I kind of got lost in the</font>

580
00:30:23,220 --> 00:30:28,429
details<font color="#CCCCCC"> so maybe it's fixable yeah I</font>

581
00:30:26,190 --> 00:30:31,260
mean<font color="#E5E5E5"> that</font><font color="#CCCCCC"> would be</font><font color="#E5E5E5"> great it was fixable</font>

582
00:30:28,429 --> 00:30:34,799
anyway anyway let me<font color="#E5E5E5"> just</font><font color="#CCCCCC"> say in</font>

583
00:30:31,260 --> 00:30:37,169
<font color="#E5E5E5">conclusion we saw some simple cases we</font>

584
00:30:34,799 --> 00:30:40,440
saw some cases where<font color="#E5E5E5"> we</font><font color="#CCCCCC"> needed to have a</font>

585
00:30:37,169 --> 00:30:41,880
<font color="#E5E5E5">better precision we</font><font color="#CCCCCC"> saw a</font><font color="#E5E5E5"> bunch of</font>

586
00:30:40,440 --> 00:30:44,220
complexity<font color="#E5E5E5"> and expense in the</font>

587
00:30:41,880 --> 00:30:47,400
<font color="#CCCCCC">implementation which I don't</font><font color="#E5E5E5"> like</font><font color="#CCCCCC"> but I</font>

588
00:30:44,220 --> 00:30:48,929
<font color="#CCCCCC">don't know how how to really</font><font color="#E5E5E5"> avoid it it</font>

589
00:30:47,400 --> 00:30:51,210
would be nice<font color="#CCCCCC"> to</font><font color="#E5E5E5"> have some some</font>

590
00:30:48,929 --> 00:30:53,549
mathematicians<font color="#E5E5E5"> to grind away these</font>

591
00:30:51,210 --> 00:30:55,770
problems<font color="#CCCCCC"> and produce the shorter</font>

592
00:30:53,549 --> 00:31:00,480
sequences for common stuff like addition

593
00:30:55,770 --> 00:31:03,629
and equality<font color="#E5E5E5"> because you know I don't</font>

594
00:31:00,480 --> 00:31:06,740
<font color="#E5E5E5">like the performance losses and thank</font>

595
00:31:03,630 --> 00:31:06,740
you any<font color="#E5E5E5"> questions</font>

596
00:31:14,559 --> 00:31:22,280
<font color="#CCCCCC">we're going to use the fast ones that</font>

597
00:31:19,790 --> 00:31:24,399
you we prefiere and fall back on just

598
00:31:22,280 --> 00:31:26,690
one<font color="#CCCCCC"> if it says it's undefined</font>

599
00:31:24,400 --> 00:31:30,860
<font color="#CCCCCC">yeah</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> cut some kind of speculative</font>

600
00:31:26,690 --> 00:31:35,330
instrumentation<font color="#E5E5E5"> yeah yes that would be</font>

601
00:31:30,860 --> 00:31:37,969
<font color="#E5E5E5">doable but that you know that's a</font><font color="#CCCCCC"> whole</font>

602
00:31:35,330 --> 00:31:40,939
framework<font color="#E5E5E5"> you know JIT framework JIT</font>

603
00:31:37,970 --> 00:31:42,410
runtime framework<font color="#E5E5E5"> decision to produce a</font>

604
00:31:40,940 --> 00:31:44,120
piece of code which<font color="#E5E5E5"> you can execute and</font>

605
00:31:42,410 --> 00:31:49,480
say then oh we don't like that we're

606
00:31:44,120 --> 00:31:51,469
going<font color="#E5E5E5"> to do this one instead yeah I</font>

607
00:31:49,480 --> 00:31:53,000
haven't considered<font color="#CCCCCC"> well I have thought</font>

608
00:31:51,470 --> 00:31:55,600
<font color="#CCCCCC">about</font><font color="#E5E5E5"> that but you know</font><font color="#CCCCCC"> that's a lot of</font>

609
00:31:53,000 --> 00:31:55,600
<font color="#CCCCCC">engineering</font>

610
00:32:04,400 --> 00:32:11,670
run your instrument areum<font color="#CCCCCC"> on your</font><font color="#E5E5E5"> own</font>

611
00:32:07,260 --> 00:32:14,220
intimate areum<font color="#CCCCCC"> well we feel</font><font color="#E5E5E5"> it runs</font>

612
00:32:11,670 --> 00:32:16,650
<font color="#E5E5E5">valgrind on valgrind before every</font>

613
00:32:14,220 --> 00:32:20,610
release to find any badness<font color="#E5E5E5"> yeah but</font>

614
00:32:16,650 --> 00:32:21,780
yeah we do<font color="#CCCCCC"> and you see regressions</font><font color="#E5E5E5"> well</font>

615
00:32:20,610 --> 00:32:23,580
I'm not really we're actually<font color="#CCCCCC"> very</font>

616
00:32:21,780 --> 00:32:27,740
careful to avoid<font color="#CCCCCC"> and</font><font color="#E5E5E5"> initialize valleys</font>

617
00:32:23,580 --> 00:32:30,419
<font color="#E5E5E5">but yeah we did we do do this sometimes</font>

618
00:32:27,740 --> 00:32:32,610
<font color="#E5E5E5">mainly the problem is that sort of two</font>

619
00:32:30,420 --> 00:32:35,730
<font color="#E5E5E5">levels of virtual machine you get is</font>

620
00:32:32,610 --> 00:32:37,709
<font color="#CCCCCC">that the real tricky part</font><font color="#E5E5E5"> especially</font><font color="#CCCCCC"> if</font>

621
00:32:35,730 --> 00:32:40,610
you<font color="#CCCCCC"> have like the old stuff and newer</font>

622
00:32:37,710 --> 00:32:40,610
<font color="#CCCCCC">stuff yeah</font>

623
00:32:40,800 --> 00:32:47,300
you say different<font color="#E5E5E5"> ways of doing that</font>

624
00:32:42,900 --> 00:32:47,300
<font color="#E5E5E5">because</font><font color="#CCCCCC"> mutation</font><font color="#E5E5E5"> is different yeah</font>

625
00:33:01,669 --> 00:33:09,210
yeah<font color="#CCCCCC"> what's the</font><font color="#E5E5E5"> real thing we find when</font>

626
00:33:04,260 --> 00:33:13,530
we do these<font color="#E5E5E5"> runs and stuff like fries</font>

627
00:33:09,210 --> 00:33:15,720
and stuff<font color="#E5E5E5"> like</font><font color="#CCCCCC"> this but usually</font><font color="#E5E5E5"> a penny</font>

628
00:33:13,530 --> 00:33:18,120
person basically<font color="#E5E5E5"> finds almost nothing</font>

629
00:33:15,720 --> 00:33:20,220
we're going<font color="#E5E5E5"> paranoid about realizing</font>

630
00:33:18,120 --> 00:33:22,860
everything<font color="#E5E5E5"> anyway I think our</font>

631
00:33:20,220 --> 00:33:24,570
heap-allocated<font color="#E5E5E5"> internal deep</font><font color="#CCCCCC"> allocates</font>

632
00:33:22,860 --> 00:33:28,830
<font color="#CCCCCC">at the</font><font color="#E5E5E5"> top these zeros and everybody</font>

633
00:33:24,570 --> 00:33:32,178
gets that only<font color="#E5E5E5"> really DS u is</font><font color="#CCCCCC"> our</font>

634
00:33:28,830 --> 00:33:32,178
<font color="#CCCCCC">initial staff</font>

