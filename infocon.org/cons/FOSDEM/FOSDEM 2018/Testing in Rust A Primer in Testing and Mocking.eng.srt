1
00:00:04,870 --> 00:00:09,070
hello<font color="#CCCCCC"> so here we're gonna talk about</font>

2
00:00:07,029 --> 00:00:11,200
<font color="#E5E5E5">testing</font><font color="#CCCCCC"> in rust but</font><font color="#E5E5E5"> specifically with a</font>

3
00:00:09,070 --> 00:00:12,850
focus on mocking so<font color="#CCCCCC"> it's a</font><font color="#E5E5E5"> little bit</font>

4
00:00:11,200 --> 00:00:14,079
about me I'm a software engineer that

5
00:00:12,850 --> 00:00:16,029
works for a quant hedge fund<font color="#E5E5E5"> called</font>

6
00:00:14,080 --> 00:00:17,800
<font color="#E5E5E5">engine is gate and my time is split</font>

7
00:00:16,029 --> 00:00:20,470
between building real time low latency

8
00:00:17,800 --> 00:00:22,660
trading systems<font color="#E5E5E5"> and also scalable data</font>

9
00:00:20,470 --> 00:00:24,910
infrastructure so I'm primarily a Python

10
00:00:22,660 --> 00:00:26,439
C++<font color="#CCCCCC"> in rust developer</font><font color="#E5E5E5"> although one day</font>

11
00:00:24,910 --> 00:00:28,419
I'm hoping to<font color="#E5E5E5"> kind of scratch out C++</font>

12
00:00:26,439 --> 00:00:31,029
and just<font color="#E5E5E5"> replace that with rust as I'm</font>

13
00:00:28,419 --> 00:00:32,259
sure many<font color="#E5E5E5"> people here</font><font color="#CCCCCC"> are so the</font>

14
00:00:31,029 --> 00:00:35,320
<font color="#E5E5E5">motivation for this talk is</font><font color="#CCCCCC"> that rust</font>

15
00:00:32,259 --> 00:00:36,579
focuses on safety<font color="#CCCCCC"> on memory safety</font><font color="#E5E5E5"> on</font>

16
00:00:35,320 --> 00:00:38,710
safety when running concurrent

17
00:00:36,579 --> 00:00:40,480
applications<font color="#CCCCCC"> and it does a</font><font color="#E5E5E5"> great job at</font>

18
00:00:38,710 --> 00:00:43,120
this without compromising<font color="#E5E5E5"> or an ease</font><font color="#CCCCCC"> of</font>

19
00:00:40,480 --> 00:00:44,650
use of<font color="#E5E5E5"> of</font><font color="#CCCCCC"> api's and whatnot but even if</font>

20
00:00:43,120 --> 00:00:45,820
our<font color="#E5E5E5"> code is safe we still need to make</font>

21
00:00:44,650 --> 00:00:48,519
sure<font color="#CCCCCC"> that it's doing</font><font color="#E5E5E5"> the logically</font>

22
00:00:45,820 --> 00:00:50,410
<font color="#CCCCCC">correct thing so what we're gonna</font><font color="#E5E5E5"> cover</font>

23
00:00:48,520 --> 00:00:52,600
here is of extremely brief introduction

24
00:00:50,410 --> 00:00:54,730
to<font color="#CCCCCC"> your running unit tests</font><font color="#E5E5E5"> in rust then</font>

25
00:00:52,600 --> 00:00:57,340
<font color="#E5E5E5">about running behavior verification</font>

26
00:00:54,730 --> 00:00:58,569
tests<font color="#E5E5E5"> in rust using crate called double</font>

27
00:00:57,340 --> 00:01:00,130
and then we're<font color="#E5E5E5"> gonna talk about some</font>

28
00:00:58,570 --> 00:01:02,290
design<font color="#E5E5E5"> considerations because actually</font>

29
00:01:00,130 --> 00:01:04,390
generating mock implementations in rust

30
00:01:02,290 --> 00:01:06,100
<font color="#E5E5E5">is particularly</font><font color="#CCCCCC"> challenging because</font><font color="#E5E5E5"> it's</font>

31
00:01:04,390 --> 00:01:07,659
a statically<font color="#E5E5E5"> typed compiled language and</font>

32
00:01:06,100 --> 00:01:11,469
the<font color="#E5E5E5"> borage I can make things even more</font>

33
00:01:07,659 --> 00:01:14,320
difficult<font color="#E5E5E5"> so unit tests</font><font color="#CCCCCC"> for those</font><font color="#E5E5E5"> of you</font>

34
00:01:11,469 --> 00:01:17,589
<font color="#E5E5E5">haven't actually wrote any kind of risk</font>

35
00:01:14,320 --> 00:01:19,678
<font color="#CCCCCC">before</font><font color="#E5E5E5"> you create</font><font color="#CCCCCC"> a library with Russ</font>

36
00:01:17,590 --> 00:01:21,429
package<font color="#E5E5E5"> management</font><font color="#CCCCCC"> all cargo cargo</font><font color="#E5E5E5"> new</font>

37
00:01:19,679 --> 00:01:24,280
when you<font color="#E5E5E5"> create in the library for</font>

38
00:01:21,429 --> 00:01:26,710
example<font color="#E5E5E5"> some Lib it generates a single</font>

39
00:01:24,280 --> 00:01:28,869
<font color="#E5E5E5">source file and</font><font color="#CCCCCC"> this contains this</font><font color="#E5E5E5"> bit</font>

40
00:01:26,710 --> 00:01:31,479
of code here<font color="#E5E5E5"> which is just an empty test</font>

41
00:01:28,869 --> 00:01:34,030
case so if we had some production code

42
00:01:31,479 --> 00:01:36,299
<font color="#CCCCCC">say in this Lib de RS file here we</font><font color="#E5E5E5"> have</font>

43
00:01:34,030 --> 00:01:39,009
say add<font color="#CCCCCC"> 2</font><font color="#E5E5E5"> it's just</font><font color="#CCCCCC"> adds 2 to an integer</font>

44
00:01:36,299 --> 00:01:41,289
<font color="#CCCCCC">we can write tests for</font><font color="#E5E5E5"> this function by</font>

45
00:01:39,009 --> 00:01:43,450
defining a private test module in the

46
00:01:41,289 --> 00:01:46,659
same source file and<font color="#CCCCCC"> an annotating it</font>

47
00:01:43,450 --> 00:01:48,729
with CFG tests<font color="#E5E5E5"> which tells cargo to only</font>

48
00:01:46,659 --> 00:01:51,939
<font color="#E5E5E5">build this code</font><font color="#CCCCCC"> within</font><font color="#E5E5E5"> the test build</font>

49
00:01:48,729 --> 00:01:53,619
<font color="#CCCCCC">not in a production binary then you</font>

50
00:01:51,939 --> 00:01:55,029
write various<font color="#E5E5E5"> test functions inside and</font>

51
00:01:53,619 --> 00:01:57,520
you annotate<font color="#E5E5E5"> in each individual test</font>

52
00:01:55,030 --> 00:01:59,499
with<font color="#E5E5E5"> tests and then when you run cargo</font>

53
00:01:57,520 --> 00:02:01,749
tests<font color="#E5E5E5"> it builds all the production code</font>

54
00:01:59,499 --> 00:02:04,359
builds the test code and actually runs

55
00:02:01,749 --> 00:02:06,458
all<font color="#CCCCCC"> of those test functions rust has a</font>

56
00:02:04,359 --> 00:02:08,799
native<font color="#E5E5E5"> support for documentation tests</font>

57
00:02:06,459 --> 00:02:10,179
so running tests in<font color="#E5E5E5"> that are actually</font>

58
00:02:08,800 --> 00:02:11,709
<font color="#E5E5E5">example code that are in your</font>

59
00:02:10,179 --> 00:02:14,290
<font color="#E5E5E5">documentation to make sure your example</font>

60
00:02:11,709 --> 00:02:16,629
code and your your library don't

61
00:02:14,290 --> 00:02:17,920
<font color="#CCCCCC">actually miss a line as well</font><font color="#E5E5E5"> as</font>

62
00:02:16,629 --> 00:02:18,700
<font color="#E5E5E5">integration tests but again the focus</font>

63
00:02:17,920 --> 00:02:20,859
<font color="#E5E5E5">here is</font>

64
00:02:18,700 --> 00:02:22,238
<font color="#CCCCCC">on</font><font color="#E5E5E5"> unit</font><font color="#CCCCCC"> tests I'm</font><font color="#E5E5E5"> walking so the</font>

65
00:02:20,860 --> 00:02:24,340
<font color="#E5E5E5">motivation behind mocking is that if you</font>

66
00:02:22,239 --> 00:02:26,500
imagine<font color="#E5E5E5"> any software system you know</font>

67
00:02:24,340 --> 00:02:28,660
it's basically<font color="#E5E5E5"> a dag of various</font>

68
00:02:26,500 --> 00:02:30,430
components<font color="#CCCCCC"> and if</font><font color="#E5E5E5"> we wanted to test one</font>

69
00:02:28,660 --> 00:02:32,560
of<font color="#E5E5E5"> these components</font><font color="#CCCCCC"> you know we have</font>

70
00:02:30,430 --> 00:02:34,930
many many dependencies or may<font color="#CCCCCC"> have many</font>

71
00:02:32,560 --> 00:02:36,459
dependencies<font color="#CCCCCC"> in this case if this top</font>

72
00:02:34,930 --> 00:02:38,590
level<font color="#E5E5E5"> component</font><font color="#CCCCCC"> is highlighted in red if</font>

73
00:02:36,459 --> 00:02:40,420
we were to test this<font color="#E5E5E5"> we have to actually</font>

74
00:02:38,590 --> 00:02:42,610
construct instantiate and configure all

75
00:02:40,420 --> 00:02:44,980
three of their dependencies<font color="#E5E5E5"> and then</font>

76
00:02:42,610 --> 00:02:46,209
their dependencies as well<font color="#E5E5E5"> so suddenly</font>

77
00:02:44,980 --> 00:02:47,079
<font color="#E5E5E5">if you just wanted</font><font color="#CCCCCC"> to test like five</font>

78
00:02:46,209 --> 00:02:48,340
<font color="#E5E5E5">lines of</font><font color="#CCCCCC"> code</font>

79
00:02:47,080 --> 00:02:50,709
suddenly you're writing dozens if not

80
00:02:48,340 --> 00:02:52,890
hundreds<font color="#E5E5E5"> of lines of setup code so the</font>

81
00:02:50,709 --> 00:02:55,420
solution to<font color="#CCCCCC"> this</font><font color="#E5E5E5"> is to simply mock out</font>

82
00:02:52,890 --> 00:02:57,700
or create fake implementations of the

83
00:02:55,420 --> 00:03:00,458
direct dependencies<font color="#E5E5E5"> to</font><font color="#CCCCCC"> simplify the</font>

84
00:02:57,700 --> 00:03:02,078
actual<font color="#E5E5E5"> overall test fixture itself</font>

85
00:03:00,459 --> 00:03:03,730
we typically eliminate<font color="#E5E5E5"> anything that's</font>

86
00:03:02,079 --> 00:03:05,980
non-deterministic that can't be reliably

87
00:03:03,730 --> 00:03:07,929
controlled in a unit test<font color="#CCCCCC"> datasources</font>

88
00:03:05,980 --> 00:03:09,880
network connections<font color="#CCCCCC"> potentially</font>

89
00:03:07,930 --> 00:03:11,110
libraries that<font color="#E5E5E5"> have global</font><font color="#CCCCCC"> state or</font>

90
00:03:09,880 --> 00:03:13,060
<font color="#E5E5E5">something some horrible</font><font color="#CCCCCC"> line at the</font><font color="#E5E5E5"> end</font>

91
00:03:11,110 --> 00:03:14,950
of using and you<font color="#E5E5E5"> can also eliminate</font>

92
00:03:13,060 --> 00:03:17,200
large internal dependencies as well

93
00:03:14,950 --> 00:03:18,339
<font color="#E5E5E5">there's advantages and disadvantages to</font>

94
00:03:17,200 --> 00:03:20,619
<font color="#E5E5E5">doing that but if you've got</font>

95
00:03:18,340 --> 00:03:21,910
particularly large complex<font color="#E5E5E5"> of</font>

96
00:03:20,620 --> 00:03:23,470
dependencies<font color="#CCCCCC"> that take a long</font><font color="#E5E5E5"> time to</font>

97
00:03:21,910 --> 00:03:25,180
set<font color="#CCCCCC"> up</font><font color="#E5E5E5"> you can eliminate those as well</font>

98
00:03:23,470 --> 00:03:26,920
<font color="#E5E5E5">so the solution</font><font color="#CCCCCC"> to this to use the test</font>

99
00:03:25,180 --> 00:03:29,049
double and that kind<font color="#CCCCCC"> of comes from</font><font color="#E5E5E5"> the</font>

100
00:03:26,920 --> 00:03:30,488
<font color="#CCCCCC">notion of</font><font color="#E5E5E5"> a stunt</font><font color="#CCCCCC"> double in films and</font>

101
00:03:29,049 --> 00:03:31,720
I'm surprised he actually managed<font color="#CCCCCC"> to get</font>

102
00:03:30,489 --> 00:03:35,079
away with being<font color="#E5E5E5"> a</font><font color="#CCCCCC"> son double of Brad</font>

103
00:03:31,720 --> 00:03:36,760
Pitt<font color="#CCCCCC"> so a testable is basically a</font>

104
00:03:35,079 --> 00:03:38,230
replacement for<font color="#E5E5E5"> any actual real</font>

105
00:03:36,760 --> 00:03:41,380
production<font color="#E5E5E5"> code that behaves the same</font>

106
00:03:38,230 --> 00:03:42,730
<font color="#E5E5E5">way but is easier to set up and there</font>

107
00:03:41,380 --> 00:03:44,880
are many types<font color="#E5E5E5"> but most people just</font>

108
00:03:42,730 --> 00:03:47,170
<font color="#E5E5E5">refer</font><font color="#CCCCCC"> to all of these doubles as mocks</font>

109
00:03:44,880 --> 00:03:49,269
<font color="#CCCCCC">in this case what we're actually</font>

110
00:03:47,170 --> 00:03:52,809
covering is<font color="#E5E5E5"> spies which is a specific</font>

111
00:03:49,269 --> 00:03:54,670
<font color="#CCCCCC">type</font><font color="#E5E5E5"> that you can configure to behave in</font>

112
00:03:52,810 --> 00:03:56,380
different<font color="#E5E5E5"> ways but it also records</font><font color="#CCCCCC"> all</font>

113
00:03:54,670 --> 00:03:57,819
the interaction<font color="#CCCCCC"> of the code and</font><font color="#E5E5E5"> the test</font>

114
00:03:56,380 --> 00:04:00,400
has with it all the times it was called

115
00:03:57,819 --> 00:04:02,018
<font color="#E5E5E5">and what it was called with and what</font>

116
00:04:00,400 --> 00:04:04,150
this is called is behavior verification

117
00:04:02,019 --> 00:04:06,190
which is a style of unit testing<font color="#CCCCCC"> it's a</font>

118
00:04:04,150 --> 00:04:08,170
style of writing<font color="#E5E5E5"> tests by testing the</font>

119
00:04:06,190 --> 00:04:09,430
code by searching<font color="#E5E5E5"> on its interaction</font>

120
00:04:08,170 --> 00:04:12,458
<font color="#CCCCCC">with his collaborators or its</font>

121
00:04:09,430 --> 00:04:15,220
dependencies<font color="#CCCCCC"> so I'm rust</font><font color="#E5E5E5"> we can generate</font>

122
00:04:12,459 --> 00:04:16,899
testable<font color="#CCCCCC"> x'</font><font color="#E5E5E5"> in a variety</font><font color="#CCCCCC"> of ways</font><font color="#E5E5E5"> two</font>

123
00:04:15,220 --> 00:04:18,760
ways of<font color="#E5E5E5"> doing this</font><font color="#CCCCCC"> with the double crate</font>

124
00:04:16,899 --> 00:04:20,918
for example is by generating<font color="#E5E5E5"> mock</font>

125
00:04:18,760 --> 00:04:22,659
implementations of traits and also

126
00:04:20,918 --> 00:04:25,389
generating mock functions as well and

127
00:04:22,660 --> 00:04:26,770
you can configure flexibly configure the

128
00:04:25,389 --> 00:04:28,510
the various behavior what it returns

129
00:04:26,770 --> 00:04:30,849
does it<font color="#CCCCCC"> run a</font><font color="#E5E5E5"> function does it error as</font>

130
00:04:28,510 --> 00:04:32,200
well as<font color="#E5E5E5"> simple but also quite nuanced</font>

131
00:04:30,849 --> 00:04:34,659
assertions about<font color="#E5E5E5"> how</font>

132
00:04:32,200 --> 00:04:36,880
was<font color="#E5E5E5"> called and how it was used so a</font>

133
00:04:34,660 --> 00:04:39,130
classic<font color="#CCCCCC"> example</font><font color="#E5E5E5"> in the kind of field I</font>

134
00:04:36,880 --> 00:04:40,810
work in is let's say we<font color="#CCCCCC"> were trying</font><font color="#E5E5E5"> to</font>

135
00:04:39,130 --> 00:04:43,810
predict the<font color="#E5E5E5"> profit of a stock portfolio</font>

136
00:04:40,810 --> 00:04:46,780
over<font color="#E5E5E5"> time now imagine we have some</font>

137
00:04:43,810 --> 00:04:48,970
traits called profit<font color="#E5E5E5"> model this has one</font>

138
00:04:46,780 --> 00:04:50,859
method<font color="#E5E5E5"> profit act which takes</font><font color="#CCCCCC"> some time</font>

139
00:04:48,970 --> 00:04:53,110
<font color="#CCCCCC">stamped and then we'll return</font><font color="#E5E5E5"> the profit</font>

140
00:04:50,860 --> 00:04:54,940
at that<font color="#CCCCCC"> given time</font><font color="#E5E5E5"> step we have a</font>

141
00:04:53,110 --> 00:04:57,700
function<font color="#E5E5E5"> called</font><font color="#CCCCCC"> predict profit over time</font>

142
00:04:54,940 --> 00:05:00,310
whose goal is to<font color="#CCCCCC"> generate a time series</font>

143
00:04:57,700 --> 00:05:03,219
of profits so we give<font color="#CCCCCC"> it a start and end</font>

144
00:05:00,310 --> 00:05:05,950
time series<font color="#E5E5E5"> the model itself which can</font>

145
00:05:03,220 --> 00:05:07,360
be any model<font color="#CCCCCC"> and then we simply</font><font color="#E5E5E5"> iterate</font>

146
00:05:05,950 --> 00:05:09,219
through that through all of<font color="#E5E5E5"> the</font>

147
00:05:07,360 --> 00:05:10,240
individual time stamps<font color="#E5E5E5"> generating the</font>

148
00:05:09,220 --> 00:05:12,670
profit<font color="#E5E5E5"> of that time stamp and then</font>

149
00:05:10,240 --> 00:05:14,140
returning<font color="#E5E5E5"> a vector of the profits and we</font>

150
00:05:12,670 --> 00:05:16,120
<font color="#E5E5E5">want to test this function simple</font>

151
00:05:14,140 --> 00:05:19,060
function but<font color="#E5E5E5"> illustration purposes let's</font>

152
00:05:16,120 --> 00:05:20,350
test it so<font color="#CCCCCC"> recall that</font><font color="#E5E5E5"> our</font><font color="#CCCCCC"> test should</font>

153
00:05:19,060 --> 00:05:22,390
be repeatable and not<font color="#E5E5E5"> rely in an</font>

154
00:05:20,350 --> 00:05:23,560
external<font color="#CCCCCC"> environment</font><font color="#E5E5E5"> however this is</font>

155
00:05:22,390 --> 00:05:26,010
very<font color="#CCCCCC"> challenging in</font><font color="#E5E5E5"> this case because</font>

156
00:05:23,560 --> 00:05:28,660
<font color="#CCCCCC">the profit model is a very</font><font color="#E5E5E5"> complex beast</font>

157
00:05:26,010 --> 00:05:30,280
<font color="#CCCCCC">predicting profit is really hard so real</font>

158
00:05:28,660 --> 00:05:32,440
implementations actually use a lot<font color="#CCCCCC"> of</font>

159
00:05:30,280 --> 00:05:34,570
<font color="#E5E5E5">different</font><font color="#CCCCCC"> data sources and a lot of</font><font color="#E5E5E5"> very</font>

160
00:05:32,440 --> 00:05:36,700
complex mathematical models<font color="#E5E5E5"> so if you</font>

161
00:05:34,570 --> 00:05:38,080
just want to<font color="#E5E5E5"> test this simple basic code</font>

162
00:05:36,700 --> 00:05:40,240
here<font color="#E5E5E5"> you probably don't want to have</font>

163
00:05:38,080 --> 00:05:42,190
<font color="#E5E5E5">this ginormous</font><font color="#CCCCCC"> setup of what is</font>

164
00:05:40,240 --> 00:05:45,040
extremely complex for<font color="#CCCCCC"> priori code</font>

165
00:05:42,190 --> 00:05:47,770
so we mock it and in<font color="#CCCCCC"> R us we do this</font>

166
00:05:45,040 --> 00:05:50,890
with<font color="#CCCCCC"> two macros the first is mocked rate</font>

167
00:05:47,770 --> 00:05:52,690
so much rate generates a struct<font color="#CCCCCC"> that has</font>

168
00:05:50,890 --> 00:05:55,000
a bunch<font color="#CCCCCC"> of</font><font color="#E5E5E5"> boilerplate and bookkeeping</font>

169
00:05:52,690 --> 00:05:56,350
inside it to keep<font color="#E5E5E5"> track of what how it's</font>

170
00:05:55,000 --> 00:05:58,630
been called and how it hasn't so in this

171
00:05:56,350 --> 00:06:00,310
case we have this trait<font color="#E5E5E5"> we call much</font>

172
00:05:58,630 --> 00:06:02,740
rate<font color="#E5E5E5"> this is the name of our mock struct</font>

173
00:06:00,310 --> 00:06:04,420
<font color="#E5E5E5">and</font><font color="#CCCCCC"> then we list the methods in</font><font color="#E5E5E5"> the</font>

174
00:06:02,740 --> 00:06:06,630
trait<font color="#CCCCCC"> that we're mocking</font><font color="#E5E5E5"> so he generates</font>

175
00:06:04,420 --> 00:06:09,220
the<font color="#E5E5E5"> right boilerplate code internally</font>

176
00:06:06,630 --> 00:06:11,530
then we have to explicitly<font color="#E5E5E5"> tell the</font><font color="#CCCCCC"> risk</font>

177
00:06:09,220 --> 00:06:13,630
compiler to<font color="#CCCCCC"> so that the mock model</font>

178
00:06:11,530 --> 00:06:15,669
implements the profit model trait so we

179
00:06:13,630 --> 00:06:17,620
have import profit model<font color="#E5E5E5"> for mock model</font>

180
00:06:15,670 --> 00:06:19,780
and then we<font color="#CCCCCC"> have the mock method macro</font>

181
00:06:17,620 --> 00:06:21,790
inside it which again<font color="#E5E5E5"> will generate the</font>

182
00:06:19,780 --> 00:06:24,369
actual<font color="#E5E5E5"> real profit</font><font color="#CCCCCC"> out function which</font>

183
00:06:21,790 --> 00:06:25,600
<font color="#CCCCCC">cause our internal struct</font><font color="#E5E5E5"> and so that's</font>

184
00:06:24,370 --> 00:06:27,400
the kind<font color="#CCCCCC"> of light that's</font><font color="#E5E5E5"> all the code</font>

185
00:06:25,600 --> 00:06:29,110
you need to<font color="#CCCCCC"> generate</font><font color="#E5E5E5"> in what that has</font>

186
00:06:27,400 --> 00:06:32,140
all the features<font color="#E5E5E5"> that I'm about to</font>

187
00:06:29,110 --> 00:06:33,850
<font color="#E5E5E5">explain so actually using this if you</font>

188
00:06:32,140 --> 00:06:36,310
imagine you wanted<font color="#E5E5E5"> to just say one</font>

189
00:06:33,850 --> 00:06:38,020
<font color="#E5E5E5">through three</font><font color="#CCCCCC"> timestamps and assert that</font>

190
00:06:36,310 --> 00:06:39,940
the profit over time the time series

191
00:06:38,020 --> 00:06:42,400
<font color="#E5E5E5">generated was correct and at the profit</font>

192
00:06:39,940 --> 00:06:44,080
model<font color="#E5E5E5"> was used in the correct manner we</font>

193
00:06:42,400 --> 00:06:45,409
instantiate the mock by doing mock model

194
00:06:44,080 --> 00:06:47,989
default<font color="#E5E5E5"> which just created</font>

195
00:06:45,409 --> 00:06:50,330
<font color="#CCCCCC">for initialized mock model</font><font color="#E5E5E5"> we say profit</font>

196
00:06:47,989 --> 00:06:52,429
<font color="#E5E5E5">out return value</font><font color="#CCCCCC"> ten and there this</font>

197
00:06:50,330 --> 00:06:54,229
thing<font color="#CCCCCC"> will the profit foot method will</font>

198
00:06:52,429 --> 00:06:55,969
just keep returning<font color="#CCCCCC"> Tet</font><font color="#E5E5E5"> so we see that</font>

199
00:06:54,229 --> 00:06:58,128
the actual time series it returns is ten

200
00:06:55,969 --> 00:06:59,899
ten ten<font color="#CCCCCC"> and we can make assertions at</font>

201
00:06:58,129 --> 00:07:02,360
the end of the test how the<font color="#E5E5E5"> mock was</font>

202
00:06:59,899 --> 00:07:05,389
caught<font color="#E5E5E5"> so in this case profit at non</font>

203
00:07:02,360 --> 00:07:07,039
<font color="#E5E5E5">cause is three and there's various ways</font>

204
00:07:05,389 --> 00:07:08,659
<font color="#CCCCCC">you can set mock behavior</font><font color="#E5E5E5"> if you don't</font>

205
00:07:07,039 --> 00:07:10,849
specify anything<font color="#CCCCCC"> he just uses a default</font>

206
00:07:08,659 --> 00:07:12,529
<font color="#CCCCCC">value of</font><font color="#E5E5E5"> the return type we can set a</font>

207
00:07:10,849 --> 00:07:14,659
single return<font color="#E5E5E5"> by if all calls like we</font>

208
00:07:12,529 --> 00:07:18,319
did before<font color="#E5E5E5"> we</font><font color="#CCCCCC"> can set sequence</font><font color="#E5E5E5"> of return</font>

209
00:07:14,659 --> 00:07:21,319
values<font color="#CCCCCC"> like 1</font><font color="#E5E5E5"> 5 10 we can set return by</font>

210
00:07:18,319 --> 00:07:24,709
use for specific<font color="#E5E5E5"> arguments so we can say</font>

211
00:07:21,319 --> 00:07:26,269
<font color="#E5E5E5">for</font><font color="#CCCCCC"> timestamp</font><font color="#E5E5E5"> 1 return this otherwise do</font>

212
00:07:24,709 --> 00:07:29,419
some other<font color="#E5E5E5"> default behavior in this case</font>

213
00:07:26,269 --> 00:07:31,129
return<font color="#E5E5E5"> 0 and we can even use arbitrary</font>

214
00:07:29,419 --> 00:07:32,719
functions as well<font color="#E5E5E5"> or closures and the</font>

215
00:07:31,129 --> 00:07:34,550
benefit<font color="#CCCCCC"> of doing it like this as opposed</font>

216
00:07:32,719 --> 00:07:36,679
<font color="#CCCCCC">to</font><font color="#E5E5E5"> just writing a mock implementation</font>

217
00:07:34,550 --> 00:07:37,579
that<font color="#CCCCCC"> has that code in there manually</font>

218
00:07:36,679 --> 00:07:39,679
confirm writing and<font color="#CCCCCC"> work</font><font color="#E5E5E5"> more</font>

219
00:07:37,579 --> 00:07:41,329
implementation is that in this way you

220
00:07:39,679 --> 00:07:43,369
get<font color="#CCCCCC"> all the boilerplate</font><font color="#E5E5E5"> and code</font>

221
00:07:41,329 --> 00:07:46,849
generated<font color="#E5E5E5"> so you can do these types of</font>

222
00:07:43,369 --> 00:07:48,619
assertions<font color="#CCCCCC"> that about to discuss</font><font color="#E5E5E5"> so once</font>

223
00:07:46,849 --> 00:07:50,058
you've configured the mock and<font color="#E5E5E5"> how it's</font>

224
00:07:48,619 --> 00:07:51,709
supposed<font color="#E5E5E5"> to behave you want to assert</font>

225
00:07:50,059 --> 00:07:53,449
<font color="#E5E5E5">that it was used as expected it was</font>

226
00:07:51,709 --> 00:07:55,969
called the right<font color="#CCCCCC"> number of times and had</font>

227
00:07:53,449 --> 00:07:57,829
the right arguments<font color="#E5E5E5"> now there's fairly</font>

228
00:07:55,969 --> 00:07:59,748
loose<font color="#CCCCCC"> assertions so you can say the mock</font>

229
00:07:57,829 --> 00:08:01,699
was called at<font color="#E5E5E5"> least once it was called</font>

230
00:07:59,749 --> 00:08:04,399
with<font color="#E5E5E5"> one and it all it was called with</font>

231
00:08:01,699 --> 00:08:05,929
time<font color="#E5E5E5"> someone and also</font><font color="#CCCCCC"> timestamp 0</font><font color="#E5E5E5"> but</font>

232
00:08:04,399 --> 00:08:07,669
often<font color="#E5E5E5"> you</font><font color="#CCCCCC"> actually want to tighten your</font>

233
00:08:05,929 --> 00:08:09,469
<font color="#E5E5E5">call assertion so you might want to say</font>

234
00:08:07,669 --> 00:08:12,109
not<font color="#CCCCCC"> only do you care that</font><font color="#E5E5E5"> it was called</font>

235
00:08:09,469 --> 00:08:13,639
with<font color="#E5E5E5"> 1</font><font color="#CCCCCC"> and 0 but you also care that it</font>

236
00:08:12,110 --> 00:08:16,699
<font color="#E5E5E5">never had</font><font color="#CCCCCC"> any more</font><font color="#E5E5E5"> calls than that</font>

237
00:08:13,639 --> 00:08:18,169
so has<font color="#CCCCCC"> cause exactly 1 0 2 which is well</font>

238
00:08:16,699 --> 00:08:21,439
perhaps because<font color="#CCCCCC"> in this case</font><font color="#E5E5E5"> we're</font>

239
00:08:18,169 --> 00:08:23,839
passing timestamp<font color="#E5E5E5"> 0 to 2 inclusive and</font>

240
00:08:21,439 --> 00:08:25,729
then you can even<font color="#E5E5E5"> say has cause exactly</font>

241
00:08:23,839 --> 00:08:27,139
in<font color="#E5E5E5"> order and it's kind of up to you how</font>

242
00:08:25,729 --> 00:08:29,089
tight you want<font color="#E5E5E5"> to make your assertions</font>

243
00:08:27,139 --> 00:08:31,459
or<font color="#E5E5E5"> loose and that's something</font><font color="#CCCCCC"> I'm</font><font color="#E5E5E5"> going</font>

244
00:08:29,089 --> 00:08:33,169
<font color="#E5E5E5">to discuss in a second we can also mock</font>

245
00:08:31,459 --> 00:08:35,389
free functions so for example if you're

246
00:08:33,169 --> 00:08:37,338
passing<font color="#E5E5E5"> in some function a box function</font>

247
00:08:35,389 --> 00:08:38,329
for<font color="#CCCCCC"> example for runtime polymorphism you</font>

248
00:08:37,339 --> 00:08:39,680
can pass<font color="#CCCCCC"> that in as well</font>

249
00:08:38,328 --> 00:08:42,228
you can generate something<font color="#E5E5E5"> for that as</font>

250
00:08:39,679 --> 00:08:43,818
well sorry<font color="#E5E5E5"> so here we have mock func we</font>

251
00:08:42,229 --> 00:08:45,860
specify the actual mock object that

252
00:08:43,818 --> 00:08:47,479
stores all the bookkeeping<font color="#CCCCCC"> the actual</font>

253
00:08:45,860 --> 00:08:49,610
function itself which is<font color="#CCCCCC"> just a closure</font>

254
00:08:47,480 --> 00:08:51,170
<font color="#E5E5E5">and then the return types and argument</font>

255
00:08:49,610 --> 00:08:52,550
types and<font color="#E5E5E5"> whatnot and then you can</font>

256
00:08:51,170 --> 00:08:55,490
specify<font color="#E5E5E5"> just</font><font color="#CCCCCC"> like you would with the</font>

257
00:08:52,550 --> 00:08:58,339
traits behavior<font color="#E5E5E5"> it will return 10 and</font>

258
00:08:55,490 --> 00:08:59,120
<font color="#E5E5E5">also specify how it was used so say we</font>

259
00:08:58,339 --> 00:09:01,700
had some<font color="#E5E5E5"> function</font>

260
00:08:59,120 --> 00:09:05,150
<font color="#E5E5E5">that we expected to call it the</font><font color="#CCCCCC"> function</font>

261
00:09:01,700 --> 00:09:08,810
<font color="#E5E5E5">we pass in twice then we say that it was</font>

262
00:09:05,150 --> 00:09:11,480
called<font color="#E5E5E5"> two times so that's all well and</font>

263
00:09:08,810 --> 00:09:13,069
<font color="#E5E5E5">good but there's some</font><font color="#CCCCCC"> series of that</font>

264
00:09:11,480 --> 00:09:15,500
disadvantages - mocking if you're not

265
00:09:13,070 --> 00:09:17,300
careful<font color="#CCCCCC"> so let's talk about another use</font>

266
00:09:15,500 --> 00:09:21,920
case<font color="#CCCCCC"> so</font><font color="#E5E5E5"> imagine we were trying to test</font>

267
00:09:17,300 --> 00:09:24,589
<font color="#E5E5E5">how a robot makes decisions so suppose</font>

268
00:09:21,920 --> 00:09:27,800
that we<font color="#E5E5E5"> have some robot logic and this</font>

269
00:09:24,589 --> 00:09:29,720
thing takes some world<font color="#CCCCCC"> states</font><font color="#E5E5E5"> so it has</font>

270
00:09:27,800 --> 00:09:32,060
some like perception of what the world

271
00:09:29,720 --> 00:09:34,250
looks like<font color="#E5E5E5"> and this</font><font color="#CCCCCC"> is a</font><font color="#E5E5E5"> value type just</font>

272
00:09:32,060 --> 00:09:36,770
<font color="#E5E5E5">a basic struct and then we have a robot</font>

273
00:09:34,250 --> 00:09:38,960
<font color="#E5E5E5">which takes some internal state and then</font>

274
00:09:36,770 --> 00:09:42,140
decides what to do and once it's decided

275
00:09:38,960 --> 00:09:44,720
<font color="#CCCCCC">it acts on</font><font color="#E5E5E5"> those decisions by call it by</font>

276
00:09:42,140 --> 00:09:47,420
actually<font color="#E5E5E5"> calling</font><font color="#CCCCCC"> this actuator</font><font color="#E5E5E5"> component</font>

277
00:09:44,720 --> 00:09:50,480
here so saying I want to move forward<font color="#CCCCCC"> or</font>

278
00:09:47,420 --> 00:09:52,520
I want to<font color="#E5E5E5"> speak in this case suppose</font>

279
00:09:50,480 --> 00:09:54,320
that we wanted<font color="#E5E5E5"> to test this robot logic</font>

280
00:09:52,520 --> 00:09:56,230
<font color="#CCCCCC">it's very</font><font color="#E5E5E5"> complex</font><font color="#CCCCCC"> logic and it's a kind</font>

281
00:09:54,320 --> 00:10:00,920
<font color="#CCCCCC">of</font><font color="#E5E5E5"> thing that we want to poke and prod</font>

282
00:09:56,230 --> 00:10:03,650
<font color="#E5E5E5">so we want to mock the actuator in this</font>

283
00:10:00,920 --> 00:10:05,360
case because if this world state is just

284
00:10:03,650 --> 00:10:07,279
a simple value type we can just

285
00:10:05,360 --> 00:10:08,630
construct<font color="#CCCCCC"> that</font><font color="#E5E5E5"> as a struct</font><font color="#CCCCCC"> and just in</font>

286
00:10:07,279 --> 00:10:10,700
and have various<font color="#E5E5E5"> different unit tests</font>

287
00:10:08,630 --> 00:10:14,480
with various different<font color="#CCCCCC"> world</font><font color="#E5E5E5"> states the</font>

288
00:10:10,700 --> 00:10:16,339
<font color="#E5E5E5">robot is the complex hard part and the</font>

289
00:10:14,480 --> 00:10:18,470
<font color="#E5E5E5">actuator</font><font color="#CCCCCC"> if you imagine that this robot</font>

290
00:10:16,339 --> 00:10:20,570
<font color="#CCCCCC">was say an entity in a video game or</font>

291
00:10:18,470 --> 00:10:22,310
like<font color="#E5E5E5"> a renderable entity or it was an</font>

292
00:10:20,570 --> 00:10:24,500
actual<font color="#CCCCCC"> physical set of hardware that</font><font color="#E5E5E5"> you</font>

293
00:10:22,310 --> 00:10:26,239
were sending orders<font color="#E5E5E5"> to obviously that's</font>

294
00:10:24,500 --> 00:10:29,089
not<font color="#CCCCCC"> very tractable to</font><font color="#E5E5E5"> mock it sorry to</font>

295
00:10:26,240 --> 00:10:33,140
test<font color="#CCCCCC"> in an automated fashion so we mock</font>

296
00:10:29,089 --> 00:10:35,630
this out<font color="#CCCCCC"> and again if this actuator was</font>

297
00:10:33,140 --> 00:10:37,550
say<font color="#E5E5E5"> a</font><font color="#CCCCCC"> trait so for example it could have</font>

298
00:10:35,630 --> 00:10:39,439
many actions<font color="#CCCCCC"> one of them being moved</font>

299
00:10:37,550 --> 00:10:41,000
forward this<font color="#CCCCCC"> prophecy would</font>

300
00:10:39,440 --> 00:10:42,080
<font color="#CCCCCC">realistically have lots more nuanced</font>

301
00:10:41,000 --> 00:10:44,029
actions but for the purposes<font color="#E5E5E5"> of</font>

302
00:10:42,080 --> 00:10:46,580
<font color="#E5E5E5">illustration it has moved forward</font><font color="#CCCCCC"> and it</font>

303
00:10:44,029 --> 00:10:48,920
moves by forward by some<font color="#E5E5E5"> amount we mock</font>

304
00:10:46,580 --> 00:10:51,410
this as we<font color="#E5E5E5"> did before</font><font color="#CCCCCC"> we use mock traits</font>

305
00:10:48,920 --> 00:10:54,229
and then we do<font color="#E5E5E5"> in</font><font color="#CCCCCC"> pull</font><font color="#E5E5E5"> actuator for mock</font>

306
00:10:51,410 --> 00:10:56,390
actuator<font color="#E5E5E5"> the</font><font color="#CCCCCC"> robot itself in this case</font>

307
00:10:54,230 --> 00:10:59,450
takes a reference to the<font color="#E5E5E5"> actuator and it</font>

308
00:10:56,390 --> 00:11:01,220
has this<font color="#E5E5E5"> take action function which</font>

309
00:10:59,450 --> 00:11:02,540
receives some<font color="#E5E5E5"> world</font><font color="#CCCCCC"> states</font><font color="#E5E5E5"> again we</font>

310
00:11:01,220 --> 00:11:04,040
don't<font color="#E5E5E5"> care about</font><font color="#CCCCCC"> the exact contents of</font>

311
00:11:02,540 --> 00:11:05,480
it at this<font color="#E5E5E5"> point</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> just receive some</font>

312
00:11:04,040 --> 00:11:08,480
world<font color="#CCCCCC"> states and then there's some</font>

313
00:11:05,480 --> 00:11:10,400
<font color="#E5E5E5">business logic on on how the robot</font>

314
00:11:08,480 --> 00:11:12,770
decides what actions it should take and

315
00:11:10,400 --> 00:11:15,110
this is<font color="#E5E5E5"> the thing we want</font><font color="#CCCCCC"> to test</font>

316
00:11:12,770 --> 00:11:17,090
after we've done<font color="#E5E5E5"> that we can test the</font>

317
00:11:15,110 --> 00:11:19,820
<font color="#CCCCCC">robot by again instantiating a mock</font>

318
00:11:17,090 --> 00:11:22,430
actuator<font color="#CCCCCC"> we run the code and the test</font>

319
00:11:19,820 --> 00:11:24,890
which is take action<font color="#CCCCCC"> and then</font><font color="#E5E5E5"> we assert</font>

320
00:11:22,430 --> 00:11:27,010
on what actions the robot<font color="#E5E5E5"> actually took</font>

321
00:11:24,890 --> 00:11:28,790
one<font color="#CCCCCC"> thing to note here is that</font>

322
00:11:27,010 --> 00:11:30,500
realistically<font color="#E5E5E5"> you would have many many</font>

323
00:11:28,790 --> 00:11:32,540
many different test functions or with

324
00:11:30,500 --> 00:11:35,060
different<font color="#CCCCCC"> world states or</font><font color="#E5E5E5"> to test and</font>

325
00:11:32,540 --> 00:11:38,839
poke and prod and and test how this

326
00:11:35,060 --> 00:11:41,540
<font color="#E5E5E5">robot works</font><font color="#CCCCCC"> now</font><font color="#E5E5E5"> the issue with this</font>

327
00:11:38,840 --> 00:11:43,540
<font color="#E5E5E5">specific</font><font color="#CCCCCC"> example is</font><font color="#E5E5E5"> robots in particular</font>

328
00:11:41,540 --> 00:11:47,390
<font color="#E5E5E5">on decision making</font><font color="#CCCCCC"> is quite complicated</font>

329
00:11:43,540 --> 00:11:48,949
and<font color="#E5E5E5"> it's quite nuanced</font><font color="#CCCCCC"> do we really care</font>

330
00:11:47,390 --> 00:11:51,319
that<font color="#E5E5E5"> the robot in this case we're</font>

331
00:11:48,950 --> 00:11:53,540
asserting<font color="#E5E5E5"> do that the robot moved</font>

332
00:11:51,320 --> 00:11:55,040
exactly 100 times<font color="#E5E5E5"> is that</font><font color="#CCCCCC"> something</font><font color="#E5E5E5"> we</font>

333
00:11:53,540 --> 00:11:56,689
actually care about<font color="#E5E5E5"> do we care that</font><font color="#CCCCCC"> it's</font>

334
00:11:55,040 --> 00:11:58,579
move forward a<font color="#E5E5E5"> little</font><font color="#CCCCCC"> bit</font><font color="#E5E5E5"> or within</font><font color="#CCCCCC"> a</font>

335
00:11:56,690 --> 00:12:01,070
range<font color="#E5E5E5"> we might not actually care</font><font color="#CCCCCC"> that</font>

336
00:11:58,580 --> 00:12:03,020
it's exactly<font color="#E5E5E5"> 100 units so if you</font><font color="#CCCCCC"> imagine</font>

337
00:12:01,070 --> 00:12:04,910
the space of<font color="#E5E5E5"> all possible behavior that</font>

338
00:12:03,020 --> 00:12:07,850
the robot can<font color="#E5E5E5"> take or the code of the</font>

339
00:12:04,910 --> 00:12:11,150
test<font color="#E5E5E5"> in a more generic fashion</font><font color="#CCCCCC"> and this</font>

340
00:12:07,850 --> 00:12:13,820
is the<font color="#E5E5E5"> expected behavior what we've</font><font color="#CCCCCC"> just</font>

341
00:12:11,150 --> 00:12:16,010
<font color="#E5E5E5">done is we've tightened the certian way</font>

342
00:12:13,820 --> 00:12:18,500
too much so now we've artificially

343
00:12:16,010 --> 00:12:19,670
constrained the<font color="#E5E5E5"> test so if someone</font>

344
00:12:18,500 --> 00:12:21,170
decides<font color="#CCCCCC"> to slightly change the</font>

345
00:12:19,670 --> 00:12:24,020
<font color="#CCCCCC">implementation of the robot and how it</font>

346
00:12:21,170 --> 00:12:27,500
makes decisions<font color="#E5E5E5"> so instead of moving 100</font>

347
00:12:24,020 --> 00:12:30,829
it moves<font color="#E5E5E5"> let's say 120 that might still</font>

348
00:12:27,500 --> 00:12:32,960
<font color="#E5E5E5">be within a realm of expected but it</font>

349
00:12:30,830 --> 00:12:35,570
will<font color="#E5E5E5"> break the test because it's moved</font>

350
00:12:32,960 --> 00:12:36,800
out<font color="#CCCCCC"> of</font><font color="#E5E5E5"> that tight</font><font color="#CCCCCC"> assertive space</font><font color="#E5E5E5"> so</font>

351
00:12:35,570 --> 00:12:39,170
what we really<font color="#CCCCCC"> want is that expectant</font>

352
00:12:36,800 --> 00:12:40,609
<font color="#E5E5E5">I'll set it</font><font color="#CCCCCC"> to be the</font><font color="#E5E5E5"> same so basically</font>

353
00:12:39,170 --> 00:12:42,500
behavior verification<font color="#E5E5E5"> can over fit the</font>

354
00:12:40,610 --> 00:12:44,210
implementation<font color="#E5E5E5"> and the lack of tooling</font>

355
00:12:42,500 --> 00:12:46,430
and good ways of<font color="#E5E5E5"> of matching and</font>

356
00:12:44,210 --> 00:12:48,050
argument values makes us more<font color="#E5E5E5"> likely so</font>

357
00:12:46,430 --> 00:12:50,390
let's talk about pattern matching

358
00:12:48,050 --> 00:12:52,670
so rather than match<font color="#E5E5E5"> arguments to values</font>

359
00:12:50,390 --> 00:12:56,330
you match them to actual more generic

360
00:12:52,670 --> 00:12:58,490
patterns so we<font color="#CCCCCC"> have called with pattern</font>

361
00:12:56,330 --> 00:13:00,650
so<font color="#E5E5E5"> you can say actuator don't move</font>

362
00:12:58,490 --> 00:13:03,620
forward<font color="#CCCCCC"> called with pattern and you pass</font>

363
00:13:00,650 --> 00:13:05,810
in some matching function so<font color="#E5E5E5"> here we had</font>

364
00:13:03,620 --> 00:13:07,340
is greater than<font color="#CCCCCC"> equal to</font><font color="#E5E5E5"> 100 this takes</font>

365
00:13:05,810 --> 00:13:09,650
the<font color="#CCCCCC"> argument being matched</font><font color="#E5E5E5"> and then it</font>

366
00:13:07,340 --> 00:13:11,750
<font color="#CCCCCC">runs some check say are greater equals</font>

367
00:13:09,650 --> 00:13:12,770
100 returning true if the value is

368
00:13:11,750 --> 00:13:15,380
matched and false otherwise

369
00:13:12,770 --> 00:13:17,420
<font color="#E5E5E5">now obviously</font><font color="#CCCCCC"> rotten handwriting a bunch</font>

370
00:13:15,380 --> 00:13:20,450
of<font color="#CCCCCC"> closures all the time is</font><font color="#E5E5E5"> probably not</font>

371
00:13:17,420 --> 00:13:22,729
ideal<font color="#CCCCCC"> it's very verbose and</font><font color="#E5E5E5"> it's quite</font>

372
00:13:20,450 --> 00:13:25,160
painful<font color="#E5E5E5"> so you get around this with</font>

373
00:13:22,730 --> 00:13:25,830
parameterised matcher functions<font color="#E5E5E5"> so for</font>

374
00:13:25,160 --> 00:13:27,390
<font color="#E5E5E5">example</font>

375
00:13:25,830 --> 00:13:30,540
would<font color="#E5E5E5"> have a greater</font><font color="#CCCCCC"> than our equal to</font>

376
00:13:27,390 --> 00:13:32,760
function<font color="#CCCCCC"> this is a generic function that</font>

377
00:13:30,540 --> 00:13:34,500
can take any type that<font color="#E5E5E5"> implements</font>

378
00:13:32,760 --> 00:13:36,600
partial<font color="#E5E5E5"> EQ and partial order in other</font>

379
00:13:34,500 --> 00:13:39,030
<font color="#E5E5E5">words any type that you can say greater</font>

380
00:13:36,600 --> 00:13:41,580
<font color="#E5E5E5">than equal on</font><font color="#CCCCCC"> it takes a single</font>

381
00:13:39,030 --> 00:13:43,020
parameter<font color="#CCCCCC"> the first argument is the the</font>

382
00:13:41,580 --> 00:13:44,850
value being matched<font color="#E5E5E5"> and it takes a</font>

383
00:13:43,020 --> 00:13:47,069
single parameter base though<font color="#E5E5E5"> which is</font>

384
00:13:44,850 --> 00:13:49,590
<font color="#CCCCCC">actually what it does here</font><font color="#E5E5E5"> like what the</font>

385
00:13:47,070 --> 00:13:52,020
base<font color="#CCCCCC"> value should</font><font color="#E5E5E5"> be and so now</font><font color="#CCCCCC"> instead</font>

386
00:13:49,590 --> 00:13:53,880
of<font color="#E5E5E5"> actually</font><font color="#CCCCCC"> generating so mainly</font><font color="#E5E5E5"> writing</font>

387
00:13:52,020 --> 00:13:56,670
all<font color="#CCCCCC"> of our</font><font color="#E5E5E5"> matches we can just use a</font>

388
00:13:53,880 --> 00:13:59,460
macro called<font color="#E5E5E5"> P which is defined</font><font color="#CCCCCC"> in</font>

389
00:13:56,670 --> 00:14:01,079
double<font color="#CCCCCC"> two to basically generate these</font>

390
00:13:59,460 --> 00:14:02,550
matching closures for us<font color="#E5E5E5"> so this</font>

391
00:14:01,080 --> 00:14:04,530
generates matching closures on<font color="#CCCCCC"> the fly</font>

392
00:14:02,550 --> 00:14:08,459
by you saying<font color="#E5E5E5"> take this parameter</font><font color="#CCCCCC"> arise</font>

393
00:14:04,530 --> 00:14:10,949
<font color="#E5E5E5">matric</font><font color="#CCCCCC"> GE</font><font color="#E5E5E5"> and then 100 and so what this</font>

394
00:14:08,460 --> 00:14:14,070
<font color="#E5E5E5">code</font><font color="#CCCCCC"> looks like</font><font color="#E5E5E5"> is pretty much the same</font>

395
00:14:10,950 --> 00:14:15,660
so<font color="#E5E5E5"> we have P GE 100 and then matter and</font>

396
00:14:14,070 --> 00:14:16,890
as loads of built in matches there's

397
00:14:15,660 --> 00:14:18,689
<font color="#E5E5E5">wild card matches if you don't care</font>

398
00:14:16,890 --> 00:14:21,900
about specific arguments comparisons

399
00:14:18,690 --> 00:14:24,300
<font color="#E5E5E5">floating points string matches container</font>

400
00:14:21,900 --> 00:14:26,040
matches<font color="#CCCCCC"> you can also compose matches</font>

401
00:14:24,300 --> 00:14:27,750
<font color="#E5E5E5">together so you can say maybe you don't</font>

402
00:14:26,040 --> 00:14:29,520
care that<font color="#CCCCCC"> the robot</font><font color="#E5E5E5"> moved just to point</font>

403
00:14:27,750 --> 00:14:31,200
<font color="#E5E5E5">more than 100 then it moved</font><font color="#CCCCCC"> it in some</font>

404
00:14:29,520 --> 00:14:33,300
<font color="#E5E5E5">range so</font><font color="#CCCCCC"> you can say max is all love</font>

405
00:14:31,200 --> 00:14:36,390
greater than or equal<font color="#CCCCCC"> to</font><font color="#E5E5E5"> 100</font><font color="#CCCCCC"> lower</font><font color="#E5E5E5"> than</font>

406
00:14:33,300 --> 00:14:37,770
equal to 200<font color="#CCCCCC"> you can also and this</font><font color="#E5E5E5"> is</font>

407
00:14:36,390 --> 00:14:40,140
particularly useful feature is do

408
00:14:37,770 --> 00:14:42,990
matching across individual elements<font color="#CCCCCC"> in</font>

409
00:14:40,140 --> 00:14:45,930
the collection<font color="#CCCCCC"> so any iterable an</font>

410
00:14:42,990 --> 00:14:48,120
iterable<font color="#CCCCCC"> object it you can use this</font><font color="#E5E5E5"> each</font>

411
00:14:45,930 --> 00:14:50,849
match so here we have some mock that

412
00:14:48,120 --> 00:14:53,190
<font color="#CCCCCC">record two numbers</font><font color="#E5E5E5"> or</font><font color="#CCCCCC"> something</font><font color="#E5E5E5"> it takes</font>

413
00:14:50,850 --> 00:14:56,610
a vector of integers<font color="#CCCCCC"> and you want to</font>

414
00:14:53,190 --> 00:14:59,940
assert that this<font color="#E5E5E5"> mock was called with a</font>

415
00:14:56,610 --> 00:15:02,490
vet where each element<font color="#CCCCCC"> matched to this</font>

416
00:14:59,940 --> 00:15:05,670
pattern<font color="#CCCCCC"> which is</font><font color="#E5E5E5"> not equal</font><font color="#CCCCCC"> zero and yeah</font>

417
00:15:02,490 --> 00:15:07,920
<font color="#E5E5E5">so you can also define custom matches so</font>

418
00:15:05,670 --> 00:15:10,770
design considerations<font color="#E5E5E5"> so there are two</font>

419
00:15:07,920 --> 00:15:15,630
design goals in double and this was rust

420
00:15:10,770 --> 00:15:17,040
stable so rust stable was a<font color="#E5E5E5"> requirement</font>

421
00:15:15,630 --> 00:15:18,689
<font color="#E5E5E5">particularly for me because</font><font color="#CCCCCC"> I was</font>

422
00:15:17,040 --> 00:15:21,270
<font color="#CCCCCC">working on software that required real</font>

423
00:15:18,690 --> 00:15:24,390
<font color="#E5E5E5">stable</font><font color="#CCCCCC"> and not nightly</font><font color="#E5E5E5"> and it's</font>

424
00:15:21,270 --> 00:15:26,160
surprising how many mocking mocking

425
00:15:24,390 --> 00:15:28,800
frameworks out there<font color="#E5E5E5"> always go with</font>

426
00:15:26,160 --> 00:15:30,990
<font color="#CCCCCC">nightly</font><font color="#E5E5E5"> and it's because mocking and</font>

427
00:15:28,800 --> 00:15:32,219
<font color="#CCCCCC">cogeneration</font><font color="#E5E5E5"> is often a lot more</font>

428
00:15:30,990 --> 00:15:33,990
convenient<font color="#E5E5E5"> when you're using various</font>

429
00:15:32,220 --> 00:15:36,210
nightly plugins and compiler plugins and

430
00:15:33,990 --> 00:15:38,860
whatnot for<font color="#E5E5E5"> me I didn't have</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> option</font>

431
00:15:36,210 --> 00:15:40,690
<font color="#E5E5E5">so</font><font color="#CCCCCC"> I needed to go with something</font><font color="#E5E5E5"> that</font>

432
00:15:38,860 --> 00:15:42,490
could only<font color="#E5E5E5"> use stable features and the</font>

433
00:15:40,690 --> 00:15:45,880
second one was no changes to<font color="#E5E5E5"> production</font>

434
00:15:42,490 --> 00:15:49,540
<font color="#E5E5E5">code now it's okay to refactor your code</font>

435
00:15:45,880 --> 00:15:51,280
<font color="#E5E5E5">to</font><font color="#CCCCCC"> make</font><font color="#E5E5E5"> it more testable but actually</font>

436
00:15:49,540 --> 00:15:53,199
adding extra awkward boilerplate to the

437
00:15:51,280 --> 00:15:55,780
code just<font color="#E5E5E5"> to make it testable always</font>

438
00:15:53,200 --> 00:15:57,700
this has been a bit icky to me<font color="#E5E5E5"> and also</font>

439
00:15:55,780 --> 00:16:00,130
<font color="#CCCCCC">at the</font><font color="#E5E5E5"> same</font><font color="#CCCCCC"> time</font><font color="#E5E5E5"> if you do that that</font>

440
00:15:57,700 --> 00:16:02,860
<font color="#CCCCCC">means you can't</font><font color="#E5E5E5"> just mock any arbitrary</font>

441
00:16:00,130 --> 00:16:04,689
traits<font color="#E5E5E5"> like you would have to rely</font><font color="#CCCCCC"> on</font>

442
00:16:02,860 --> 00:16:06,940
the library developer adding a<font color="#E5E5E5"> certain</font>

443
00:16:04,690 --> 00:16:09,190
annotation to a trait or a<font color="#CCCCCC"> structural or</font>

444
00:16:06,940 --> 00:16:12,130
<font color="#E5E5E5">function for you to be able to mock it</font>

445
00:16:09,190 --> 00:16:14,020
<font color="#E5E5E5">so with this you can actually mock any</font>

446
00:16:12,130 --> 00:16:16,300
arbitrary trait<font color="#E5E5E5"> from any library</font><font color="#CCCCCC"> and it</font>

447
00:16:14,020 --> 00:16:19,030
doesn't<font color="#E5E5E5"> matter and these are challenging</font>

448
00:16:16,300 --> 00:16:21,939
goals<font color="#E5E5E5"> again because that should the the</font>

449
00:16:19,030 --> 00:16:24,069
<font color="#E5E5E5">regional talk that I had was the second</font>

450
00:16:21,940 --> 00:16:26,830
part<font color="#E5E5E5"> of it was 20</font><font color="#CCCCCC"> minutes purely on why</font>

451
00:16:24,070 --> 00:16:27,970
this was so<font color="#CCCCCC"> challenging</font><font color="#E5E5E5"> but sadly we</font>

452
00:16:26,830 --> 00:16:30,190
<font color="#CCCCCC">don't have time but I would</font><font color="#E5E5E5"> love to</font>

453
00:16:27,970 --> 00:16:31,540
discuss<font color="#CCCCCC"> it but basically it's really</font>

454
00:16:30,190 --> 00:16:34,210
really difficult<font color="#E5E5E5"> and it's partly</font><font color="#CCCCCC"> and</font>

455
00:16:31,540 --> 00:16:36,069
because Russell's as a compiler<font color="#E5E5E5"> is so</font>

456
00:16:34,210 --> 00:16:38,080
strict<font color="#CCCCCC"> that it actually makes all this</font>

457
00:16:36,070 --> 00:16:40,720
automatic code generation<font color="#E5E5E5"> and generic</font>

458
00:16:38,080 --> 00:16:41,830
mock functionality quite difficult<font color="#CCCCCC"> one</font>

459
00:16:40,720 --> 00:16:43,690
thing this was quite<font color="#E5E5E5"> and this was</font>

460
00:16:41,830 --> 00:16:46,390
<font color="#CCCCCC">inspired</font><font color="#E5E5E5"> by was Google</font><font color="#CCCCCC"> Mach</font><font color="#E5E5E5"> so if any of</font>

461
00:16:43,690 --> 00:16:48,190
you view<font color="#E5E5E5"> C++ Google Mach is</font><font color="#CCCCCC"> an amazing</font>

462
00:16:46,390 --> 00:16:50,189
<font color="#CCCCCC">walking</font><font color="#E5E5E5"> framework but it cheats in some</font>

463
00:16:48,190 --> 00:16:52,780
ways that the<font color="#CCCCCC"> borage checker catches</font>

464
00:16:50,190 --> 00:16:56,230
which is<font color="#E5E5E5"> five frustrating but also a</font>

465
00:16:52,780 --> 00:16:57,699
good<font color="#E5E5E5"> thing</font><font color="#CCCCCC"> as well</font><font color="#E5E5E5"> so as eventually most</font>

466
00:16:56,230 --> 00:16:59,230
mocking libraries require nightly and

467
00:16:57,700 --> 00:17:00,640
pretty much<font color="#E5E5E5"> all I found require</font>

468
00:16:59,230 --> 00:17:02,380
<font color="#E5E5E5">production code change like you at least</font>

469
00:17:00,640 --> 00:17:04,720
<font color="#E5E5E5">have to annotate</font><font color="#CCCCCC"> the trace</font><font color="#E5E5E5"> that you want</font>

470
00:17:02,380 --> 00:17:06,640
to<font color="#E5E5E5"> mock but there is a cost to</font><font color="#CCCCCC"> actually</font>

471
00:17:04,720 --> 00:17:10,450
<font color="#E5E5E5">achieving those two goals and that</font><font color="#CCCCCC"> is</font>

472
00:17:06,640 --> 00:17:13,120
the slightly more verbose generation so

473
00:17:10,450 --> 00:17:16,300
as you saw earlier<font color="#E5E5E5"> there was two macros</font>

474
00:17:13,119 --> 00:17:19,149
there was more<font color="#E5E5E5"> trait and</font><font color="#CCCCCC"> lock</font><font color="#E5E5E5"> method and</font>

475
00:17:16,300 --> 00:17:20,859
so<font color="#E5E5E5"> basically repeat</font><font color="#CCCCCC"> yourself twice and</font>

476
00:17:19,150 --> 00:17:23,230
there's limitations in the current

477
00:17:20,859 --> 00:17:25,270
stable version that basically make<font color="#CCCCCC"> it</font>

478
00:17:23,230 --> 00:17:30,130
impossible if<font color="#E5E5E5"> you don't want any</font>

479
00:17:25,270 --> 00:17:31,780
production<font color="#E5E5E5"> code changes to</font><font color="#CCCCCC"> to to merge</font>

480
00:17:30,130 --> 00:17:33,250
those two macros together<font color="#E5E5E5"> there's a</font>

481
00:17:31,780 --> 00:17:36,700
specific feature I'm waiting for which

482
00:17:33,250 --> 00:17:39,820
is generic specialization<font color="#E5E5E5"> which will</font>

483
00:17:36,700 --> 00:17:41,110
make this problem go away<font color="#E5E5E5"> and once that</font>

484
00:17:39,820 --> 00:17:42,899
does they can be merged<font color="#E5E5E5"> but until that</font>

485
00:17:41,110 --> 00:17:46,000
<font color="#E5E5E5">point</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is slightly more</font><font color="#CCCCCC"> of a base</font>

486
00:17:42,900 --> 00:17:48,010
<font color="#CCCCCC">and</font><font color="#E5E5E5"> that's pretty</font><font color="#CCCCCC"> much the talk to</font>

487
00:17:46,000 --> 00:17:49,510
<font color="#E5E5E5">summarize mocking is often used to</font>

488
00:17:48,010 --> 00:17:51,910
isolate unit<font color="#E5E5E5"> tests from external</font>

489
00:17:49,510 --> 00:17:53,379
resources or live dependencies and

490
00:17:51,910 --> 00:17:55,270
you can exceed one way of achieving<font color="#CCCCCC"> this</font>

491
00:17:53,380 --> 00:17:56,920
in rust<font color="#E5E5E5"> is by</font><font color="#CCCCCC"> replacing traits and</font>

492
00:17:55,270 --> 00:18:00,520
functions

493
00:17:56,920 --> 00:18:01,720
however using mocking<font color="#E5E5E5"> can often</font><font color="#CCCCCC"> over fit</font>

494
00:18:00,520 --> 00:18:04,210
<font color="#CCCCCC">the implementation so you need to be</font>

495
00:18:01,720 --> 00:18:06,910
very very careful<font color="#CCCCCC"> and</font><font color="#E5E5E5"> you need to have</font>

496
00:18:04,210 --> 00:18:09,010
good<font color="#E5E5E5"> tools that enable you to make these</font>

497
00:18:06,910 --> 00:18:10,900
<font color="#CCCCCC">more nuanced assertions not just you</font>

498
00:18:09,010 --> 00:18:12,700
<font color="#CCCCCC">record</font><font color="#E5E5E5"> with exactly this you need to</font>

499
00:18:10,900 --> 00:18:14,110
have these more looser assertions<font color="#E5E5E5"> so</font>

500
00:18:12,700 --> 00:18:15,790
that your developers don't<font color="#E5E5E5"> hate their</font>

501
00:18:14,110 --> 00:18:17,350
<font color="#CCCCCC">lives a year in the project and</font><font color="#E5E5E5"> have to</font>

502
00:18:15,790 --> 00:18:18,220
constantly change test code all<font color="#CCCCCC"> the time</font>

503
00:18:17,350 --> 00:18:21,070
when they slightly change it

504
00:18:18,220 --> 00:18:22,480
implementation<font color="#CCCCCC"> double is a crate that</font>

505
00:18:21,070 --> 00:18:23,950
<font color="#E5E5E5">generates these these</font><font color="#CCCCCC"> traits and</font>

506
00:18:22,480 --> 00:18:25,690
functions<font color="#E5E5E5"> there's a wide array</font><font color="#CCCCCC"> of</font>

507
00:18:23,950 --> 00:18:27,070
behaviors<font color="#E5E5E5"> and setups</font><font color="#CCCCCC"> I only actually</font>

508
00:18:25,690 --> 00:18:29,590
<font color="#E5E5E5">covered a very small subset of the</font>

509
00:18:27,070 --> 00:18:31,030
overall set of features<font color="#E5E5E5"> and it has</font><font color="#CCCCCC"> first</font>

510
00:18:29,590 --> 00:18:32,740
<font color="#E5E5E5">class magic</font><font color="#CCCCCC"> plan mashing support that</font>

511
00:18:31,030 --> 00:18:35,170
was the<font color="#E5E5E5"> biggest reason</font><font color="#CCCCCC"> I actually made</font>

512
00:18:32,740 --> 00:18:37,230
this library was because<font color="#E5E5E5"> pattern</font>

513
00:18:35,170 --> 00:18:39,640
matching and<font color="#CCCCCC"> roster</font><font color="#E5E5E5"> staple pretty much</font>

514
00:18:37,230 --> 00:18:42,190
<font color="#E5E5E5">it requires no</font><font color="#CCCCCC"> change</font><font color="#E5E5E5"> to production code</font>

515
00:18:39,640 --> 00:18:43,510
but<font color="#CCCCCC"> that does come at a cost</font><font color="#E5E5E5"> these are</font>

516
00:18:42,190 --> 00:18:45,840
<font color="#CCCCCC">some alternative mocking libraries</font><font color="#E5E5E5"> that</font>

517
00:18:43,510 --> 00:18:47,560
I recommend checking<font color="#E5E5E5"> out after this talk</font>

518
00:18:45,840 --> 00:18:49,629
<font color="#E5E5E5">depending on your use case</font><font color="#CCCCCC"> you might</font>

519
00:18:47,560 --> 00:18:51,220
<font color="#E5E5E5">actually find these are a lot easier</font><font color="#CCCCCC"> to</font>

520
00:18:49,630 --> 00:18:53,740
<font color="#CCCCCC">use for you some mockers in</font><font color="#E5E5E5"> particular</font>

521
00:18:51,220 --> 00:18:55,540
is<font color="#E5E5E5"> quite a good one his winter</font><font color="#CCCCCC"> Lynx</font><font color="#E5E5E5"> and</font>

522
00:18:53,740 --> 00:18:57,340
that's it<font color="#E5E5E5"> get in touch if you're</font>

523
00:18:55,540 --> 00:18:59,960
interested or check out the double repo

524
00:18:57,340 --> 00:19:08,029
on github<font color="#CCCCCC"> if you want to quite</font>

525
00:18:59,960 --> 00:19:08,029
[Applause]

