1
00:00:07,020 --> 00:00:12,670
<font color="#E5E5E5">okay let's keep on going</font><font color="#CCCCCC"> so next we are</font>

2
00:00:11,139 --> 00:00:15,969
<font color="#E5E5E5">having here on the podium</font>

3
00:00:12,670 --> 00:00:24,730
<font color="#E5E5E5">Michael</font><font color="#CCCCCC"> pattern with</font><font color="#E5E5E5"> regular expression</font>

4
00:00:15,970 --> 00:00:26,890
derivatives<font color="#E5E5E5"> in Python hi everyone it's</font>

5
00:00:24,730 --> 00:00:29,290
great<font color="#E5E5E5"> to see everyone got up early to</font>

6
00:00:26,890 --> 00:00:31,989
<font color="#E5E5E5">hear a talk on derivatives that's weird</font>

7
00:00:29,290 --> 00:00:34,600
<font color="#CCCCCC">okay</font><font color="#E5E5E5"> thank you</font><font color="#CCCCCC"> very</font><font color="#E5E5E5"> much anyway</font><font color="#CCCCCC"> my name</font>

8
00:00:31,989 --> 00:00:37,150
is<font color="#E5E5E5"> Michael Patten I work and live in</font>

9
00:00:34,600 --> 00:00:40,090
Tokyo<font color="#CCCCCC"> even though I have an</font><font color="#E5E5E5"> Australian</font>

10
00:00:37,150 --> 00:00:42,820
accent<font color="#CCCCCC"> my day job is</font><font color="#E5E5E5"> at Google</font><font color="#CCCCCC"> I work on</font>

11
00:00:40,090 --> 00:00:44,530
Chrome<font color="#E5E5E5"> browser</font><font color="#CCCCCC"> we're always looking for</font>

12
00:00:42,820 --> 00:00:46,110
new<font color="#E5E5E5"> people</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> join the chromium open</font>

13
00:00:44,530 --> 00:00:48,430
source project<font color="#CCCCCC"> so if you're interested</font>

14
00:00:46,110 --> 00:00:50,680
<font color="#E5E5E5">you're very welcome and please reach out</font>

15
00:00:48,430 --> 00:00:52,990
to<font color="#CCCCCC"> me</font><font color="#E5E5E5"> but that's not what I'm talking</font>

16
00:00:50,680 --> 00:00:54,490
<font color="#CCCCCC">about today today I'm talking</font><font color="#E5E5E5"> about a</font>

17
00:00:52,990 --> 00:00:58,270
private<font color="#CCCCCC"> project this</font><font color="#E5E5E5"> is not a Google</font>

18
00:00:54,490 --> 00:01:00,220
<font color="#E5E5E5">project</font><font color="#CCCCCC"> it's a personal project and the</font>

19
00:00:58,270 --> 00:01:02,920
motivation for my project is<font color="#CCCCCC"> very simple</font>

20
00:01:00,220 --> 00:01:05,860
I just wanted to<font color="#E5E5E5"> generate scanners</font><font color="#CCCCCC"> you</font>

21
00:01:02,920 --> 00:01:07,450
know things that tokenize<font color="#CCCCCC"> text that have</font>

22
00:01:05,860 --> 00:01:10,060
guaranteed Lydia performance<font color="#E5E5E5"> and</font>

23
00:01:07,450 --> 00:01:11,350
understand you decode and as it turns

24
00:01:10,060 --> 00:01:14,319
<font color="#E5E5E5">out there's a lot of tools out there but</font>

25
00:01:11,350 --> 00:01:15,609
none<font color="#E5E5E5"> quite fit what I wanted so</font><font color="#CCCCCC"> I wanted</font>

26
00:01:14,319 --> 00:01:18,549
to<font color="#E5E5E5"> build my</font><font color="#CCCCCC"> own and I came across a</font>

27
00:01:15,609 --> 00:01:20,798
really<font color="#E5E5E5"> great paper by Owens rep Ian</font>

28
00:01:18,549 --> 00:01:23,789
<font color="#E5E5E5">Curran and they described how you can</font>

29
00:01:20,799 --> 00:01:26,950
use regular<font color="#E5E5E5"> expressions to build a</font>

30
00:01:23,789 --> 00:01:29,049
deterministic finite automaton a state

31
00:01:26,950 --> 00:01:30,850
machine<font color="#CCCCCC"> and that sounded</font><font color="#E5E5E5"> like exactly</font>

32
00:01:29,049 --> 00:01:32,889
<font color="#CCCCCC">what I wanted and they said in their</font>

33
00:01:30,850 --> 00:01:34,780
paper that these<font color="#CCCCCC"> are regular expression</font>

34
00:01:32,889 --> 00:01:37,149
derivatives have been lost in the sands

35
00:01:34,780 --> 00:01:38,259
of time<font color="#CCCCCC"> I mean few computer scientists</font>

36
00:01:37,149 --> 00:01:40,450
are<font color="#E5E5E5"> aware</font><font color="#CCCCCC"> of them so hopefully after</font>

37
00:01:38,259 --> 00:01:42,009
this talk a few more computer scientists

38
00:01:40,450 --> 00:01:44,499
will<font color="#E5E5E5"> be aware of this technique it's</font>

39
00:01:42,009 --> 00:01:46,929
pretty<font color="#E5E5E5"> cool you know it sounded exactly</font>

40
00:01:44,499 --> 00:01:49,359
<font color="#CCCCCC">what I wanted I'm so quick refresher</font>

41
00:01:46,929 --> 00:01:50,799
regular expressions<font color="#E5E5E5"> are really really</font>

42
00:01:49,359 --> 00:01:53,229
<font color="#E5E5E5">simple as it turns out so you've all</font>

43
00:01:50,799 --> 00:01:54,279
used<font color="#CCCCCC"> them in in real life probably</font><font color="#E5E5E5"> but</font>

44
00:01:53,229 --> 00:01:57,520
when you start<font color="#E5E5E5"> looking at them</font>

45
00:01:54,279 --> 00:01:59,380
theoretically<font color="#CCCCCC"> there's a very</font><font color="#E5E5E5"> small set</font>

46
00:01:57,520 --> 00:02:01,359
<font color="#CCCCCC">of</font><font color="#E5E5E5"> things they boil down to is there's a</font>

47
00:01:59,380 --> 00:02:04,079
<font color="#CCCCCC">one there's a null</font><font color="#E5E5E5"> string there's an</font>

48
00:02:01,359 --> 00:02:08,258
<font color="#E5E5E5">empty string there's a symbol you know</font>

49
00:02:04,079 --> 00:02:10,389
<font color="#E5E5E5">ABCD or whatever</font><font color="#CCCCCC"> in an alphabet but we</font>

50
00:02:08,258 --> 00:02:13,029
normally<font color="#CCCCCC"> you know use</font><font color="#E5E5E5"> the big Sigma sign</font>

51
00:02:10,389 --> 00:02:15,160
to represent<font color="#E5E5E5"> you got concatenation you</font>

52
00:02:13,030 --> 00:02:17,930
know two letters<font color="#CCCCCC"> together</font><font color="#E5E5E5"> you've got</font><font color="#CCCCCC"> the</font>

53
00:02:15,160 --> 00:02:20,930
star operator<font color="#CCCCCC"> you know zero or more</font>

54
00:02:17,930 --> 00:02:23,959
things<font color="#E5E5E5"> you've got logical</font><font color="#CCCCCC"> law which</font><font color="#E5E5E5"> is</font>

55
00:02:20,930 --> 00:02:25,250
often used<font color="#CCCCCC"> we use the pipe in positive</font>

56
00:02:23,959 --> 00:02:28,219
circular expressions but<font color="#CCCCCC"> here we'll</font><font color="#E5E5E5"> use</font>

57
00:02:25,250 --> 00:02:31,219
a plus and in this<font color="#E5E5E5"> particular setup we</font>

58
00:02:28,219 --> 00:02:33,620
also have<font color="#CCCCCC"> end and not as it turns out</font>

59
00:02:31,219 --> 00:02:35,510
<font color="#E5E5E5">they're kind of handy to have</font><font color="#CCCCCC"> I'm so</font>

60
00:02:33,620 --> 00:02:36,920
examples<font color="#E5E5E5"> down the bottom there you know</font>

61
00:02:35,510 --> 00:02:38,388
we can have you know<font color="#E5E5E5"> a bunch</font><font color="#CCCCCC"> of letters</font>

62
00:02:36,920 --> 00:02:41,149
in a row<font color="#E5E5E5"> that's a regular</font><font color="#CCCCCC"> expression</font>

63
00:02:38,389 --> 00:02:43,430
hello that matches the word hello

64
00:02:41,150 --> 00:02:45,769
the second<font color="#CCCCCC"> example</font><font color="#E5E5E5"> there matches either</font>

65
00:02:43,430 --> 00:02:49,310
<font color="#E5E5E5">you know the letters a B and C all</font><font color="#CCCCCC"> the</font>

66
00:02:45,769 --> 00:02:52,639
numbers<font color="#E5E5E5"> 1 2</font><font color="#CCCCCC"> &</font><font color="#E5E5E5"> 3 in sequence and the</font>

67
00:02:49,310 --> 00:02:56,180
third regular expression matches a any

68
00:02:52,639 --> 00:02:58,669
number of B's including<font color="#E5E5E5"> 0 and a</font><font color="#CCCCCC"> c and</font>

69
00:02:56,180 --> 00:02:59,959
again<font color="#CCCCCC"> if you've used POSIX regular</font>

70
00:02:58,669 --> 00:03:04,060
expressions you probably are very

71
00:02:59,959 --> 00:03:06,349
<font color="#CCCCCC">familiar with this ok another refresher</font>

72
00:03:04,060 --> 00:03:09,079
<font color="#E5E5E5">deterministic finite state automata and</font>

73
00:03:06,349 --> 00:03:11,030
<font color="#CCCCCC">these are state machines so basically we</font>

74
00:03:09,079 --> 00:03:13,159
want to<font color="#E5E5E5"> turn a regular expression into</font>

75
00:03:11,030 --> 00:03:15,560
one of these<font color="#E5E5E5"> the idea</font><font color="#CCCCCC"> is you have a</font>

76
00:03:13,159 --> 00:03:17,689
bunch<font color="#CCCCCC"> of states</font><font color="#E5E5E5"> there's a start state a</font>

77
00:03:15,560 --> 00:03:19,939
bunch of accepting<font color="#CCCCCC"> states which are the</font>

78
00:03:17,689 --> 00:03:22,459
ones<font color="#CCCCCC"> with the double circles</font><font color="#E5E5E5"> where</font>

79
00:03:19,939 --> 00:03:23,900
things match<font color="#E5E5E5"> then there's an</font><font color="#CCCCCC"> arrow</font><font color="#E5E5E5"> state</font>

80
00:03:22,459 --> 00:03:25,790
and of course there's the transitions

81
00:03:23,900 --> 00:03:27,590
where the arrows take you from state to

82
00:03:25,790 --> 00:03:28,879
state based<font color="#E5E5E5"> on what letters you get it's</font>

83
00:03:27,590 --> 00:03:31,430
a really simple<font color="#CCCCCC"> idea you've all seen</font>

84
00:03:28,879 --> 00:03:33,918
state machines<font color="#CCCCCC"> before now did you know</font>

85
00:03:31,430 --> 00:03:35,629
you can take the<font color="#CCCCCC"> derivative</font><font color="#E5E5E5"> of a regular</font>

86
00:03:33,919 --> 00:03:36,829
expression<font color="#E5E5E5"> what does this mean</font><font color="#CCCCCC"> this</font>

87
00:03:35,629 --> 00:03:41,328
sounds<font color="#CCCCCC"> very</font><font color="#E5E5E5"> complicated but it's really</font>

88
00:03:36,829 --> 00:03:43,099
<font color="#CCCCCC">a simple idea</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> idea is it's you take</font>

89
00:03:41,329 --> 00:03:45,829
a<font color="#E5E5E5"> regular expression and you feed a</font>

90
00:03:43,099 --> 00:03:48,078
letter<font color="#E5E5E5"> into it and what you have left is</font>

91
00:03:45,829 --> 00:03:50,810
the derivative<font color="#CCCCCC"> so if I have a</font><font color="#E5E5E5"> regular</font>

92
00:03:48,079 --> 00:03:53,720
<font color="#E5E5E5">expression a and I feed the later</font><font color="#CCCCCC"> a into</font>

93
00:03:50,810 --> 00:03:57,439
it<font color="#E5E5E5"> one left</font><font color="#CCCCCC"> weave is the null string</font>

94
00:03:53,720 --> 00:04:00,228
nothing's<font color="#E5E5E5"> left</font><font color="#CCCCCC"> I've matched</font><font color="#E5E5E5"> if I've got</font>

95
00:03:57,439 --> 00:04:01,310
a<font color="#E5E5E5"> B in</font><font color="#CCCCCC"> a feed an</font><font color="#E5E5E5"> a into it I get no</font>

96
00:04:00,229 --> 00:04:05,540
<font color="#E5E5E5">alert nothing matched</font>

97
00:04:01,310 --> 00:04:07,189
<font color="#CCCCCC">ok</font><font color="#E5E5E5"> if I have a e followed by B</font><font color="#CCCCCC"> and I</font>

98
00:04:05,540 --> 00:04:10,819
feed an A in to what's<font color="#E5E5E5"> left over is</font>

99
00:04:07,189 --> 00:04:12,530
<font color="#E5E5E5">bleah</font><font color="#CCCCCC"> it's a really simple</font><font color="#E5E5E5"> idea if I the</font>

100
00:04:10,819 --> 00:04:15,228
fourth example<font color="#CCCCCC"> there if I've got a a</font>

101
00:04:12,530 --> 00:04:18,440
star and a feed an<font color="#E5E5E5"> a into it</font><font color="#CCCCCC"> I still got</font>

102
00:04:15,229 --> 00:04:19,880
an<font color="#E5E5E5"> 8 star and that's regular expression</font>

103
00:04:18,440 --> 00:04:22,039
derivatives these things were<font color="#CCCCCC"> invented</font>

104
00:04:19,880 --> 00:04:25,310
by a mathematician<font color="#E5E5E5"> called</font><font color="#CCCCCC"> Janos brasov</font>

105
00:04:22,039 --> 00:04:28,930
ski<font color="#E5E5E5"> in 1964 this is not new stuff but</font>

106
00:04:25,310 --> 00:04:30,880
<font color="#E5E5E5">it's very cool so</font>

107
00:04:28,930 --> 00:04:32,320
<font color="#CCCCCC">there's a bunch of rules I'm not going</font>

108
00:04:30,880 --> 00:04:34,719
<font color="#CCCCCC">to go through</font><font color="#E5E5E5"> those but the real issue</font>

109
00:04:32,320 --> 00:04:37,840
here is<font color="#CCCCCC"> that you could</font><font color="#E5E5E5"> put you can write</font>

110
00:04:34,720 --> 00:04:41,380
you can<font color="#CCCCCC"> easily reduce</font><font color="#E5E5E5"> all these rules to</font>

111
00:04:37,840 --> 00:04:42,880
a simple program<font color="#CCCCCC"> and on the right</font><font color="#E5E5E5"> hand</font>

112
00:04:41,380 --> 00:04:45,639
<font color="#E5E5E5">side</font><font color="#CCCCCC"> over</font><font color="#E5E5E5"> there there's actually</font><font color="#CCCCCC"> a</font>

113
00:04:42,880 --> 00:04:48,550
helper function<font color="#E5E5E5"> and that is also used in</font>

114
00:04:45,639 --> 00:04:51,699
one<font color="#E5E5E5"> of these rules but</font><font color="#CCCCCC"> also it's used to</font>

115
00:04:48,550 --> 00:04:53,080
see if regular expression is nullable

116
00:04:51,699 --> 00:04:55,750
and this turns out to<font color="#CCCCCC"> be really useful</font>

117
00:04:53,080 --> 00:04:57,729
later on<font color="#E5E5E5"> so there's this idea that a</font>

118
00:04:55,750 --> 00:05:02,919
regular<font color="#CCCCCC"> expression is nullable</font><font color="#E5E5E5"> which</font>

119
00:04:57,729 --> 00:05:05,050
means that it matches<font color="#CCCCCC"> okay</font><font color="#E5E5E5"> so why is all</font>

120
00:05:02,919 --> 00:05:06,820
this stuff useful well here's some

121
00:05:05,050 --> 00:05:10,300
Python code this is almost<font color="#CCCCCC"> exactly</font><font color="#E5E5E5"> the</font>

122
00:05:06,820 --> 00:05:11,650
code in<font color="#CCCCCC"> my project</font><font color="#E5E5E5"> and it's very simple</font>

123
00:05:10,300 --> 00:05:13,240
walk you through it you start off<font color="#E5E5E5"> with a</font>

124
00:05:11,650 --> 00:05:16,750
regular<font color="#CCCCCC"> expression</font><font color="#E5E5E5"> and that's your start</font>

125
00:05:13,240 --> 00:05:19,270
state and then you sort<font color="#E5E5E5"> of add your</font>

126
00:05:16,750 --> 00:05:21,520
start state to<font color="#E5E5E5"> your set of states and</font>

127
00:05:19,270 --> 00:05:25,000
then you stick the state that the first

128
00:05:21,520 --> 00:05:27,280
state on<font color="#CCCCCC"> a</font><font color="#E5E5E5"> stack</font><font color="#CCCCCC"> and then you go into</font><font color="#E5E5E5"> a</font>

129
00:05:25,000 --> 00:05:29,740
loop so<font color="#E5E5E5"> you take a state off the stack</font>

130
00:05:27,280 --> 00:05:31,960
<font color="#E5E5E5">and you say okay for every symbol in my</font>

131
00:05:29,740 --> 00:05:35,620
alphabet let's take the<font color="#CCCCCC"> derivative of</font>

132
00:05:31,960 --> 00:05:38,650
<font color="#CCCCCC">that state</font><font color="#E5E5E5"> and that's a new state</font><font color="#CCCCCC"> now if</font>

133
00:05:35,620 --> 00:05:40,180
<font color="#CCCCCC">I'm a C in that state before</font><font color="#E5E5E5"> or I</font><font color="#CCCCCC"> have</font>

134
00:05:38,650 --> 00:05:42,580
<font color="#CCCCCC">it</font><font color="#E5E5E5"> if I haven't seen</font><font color="#CCCCCC"> the state before I</font>

135
00:05:40,180 --> 00:05:44,349
add it to<font color="#CCCCCC"> my set of states</font><font color="#E5E5E5"> and in any</font>

136
00:05:42,580 --> 00:05:47,020
case I add a<font color="#E5E5E5"> transition because I found</font>

137
00:05:44,349 --> 00:05:49,690
<font color="#E5E5E5">a new way to get</font><font color="#CCCCCC"> to that state and I run</font>

138
00:05:47,020 --> 00:05:50,530
<font color="#E5E5E5">that loop and at the end I've</font><font color="#CCCCCC"> got a</font>

139
00:05:49,690 --> 00:05:52,900
state machine

140
00:05:50,530 --> 00:05:54,039
<font color="#E5E5E5">I work out which states can</font><font color="#CCCCCC"> be accepted</font>

141
00:05:52,900 --> 00:05:56,440
<font color="#E5E5E5">because</font><font color="#CCCCCC"> they're those states that are</font>

142
00:05:54,039 --> 00:06:00,940
novel<font color="#CCCCCC"> and the error</font><font color="#E5E5E5"> state the one where</font>

143
00:05:56,440 --> 00:06:03,310
nothing is getting or is of a state<font color="#CCCCCC"> that</font>

144
00:06:00,940 --> 00:06:07,210
<font color="#E5E5E5">is</font><font color="#CCCCCC"> the null station and that is it</font>

145
00:06:03,310 --> 00:06:10,479
that's<font color="#E5E5E5"> really cool you</font><font color="#CCCCCC"> can produce a you</font>

146
00:06:07,210 --> 00:06:14,758
know<font color="#E5E5E5"> deterministic finite automata from</font>

147
00:06:10,479 --> 00:06:14,758
a regular expression<font color="#E5E5E5"> with that code</font>

148
00:06:14,849 --> 00:06:20,650
there's<font color="#E5E5E5"> only one problem</font><font color="#CCCCCC"> remember</font><font color="#E5E5E5"> that</font>

149
00:06:18,970 --> 00:06:23,530
bit in<font color="#CCCCCC"> my code that said for every</font>

150
00:06:20,650 --> 00:06:25,599
symbol<font color="#E5E5E5"> in the alphabet well únicos got a</font>

151
00:06:23,530 --> 00:06:28,750
lot<font color="#CCCCCC"> of symbols</font><font color="#E5E5E5"> so you'd be running</font>

152
00:06:25,599 --> 00:06:31,900
<font color="#E5E5E5">through some pretty big loops so that's</font>

153
00:06:28,750 --> 00:06:34,000
<font color="#E5E5E5">no good</font><font color="#CCCCCC"> so the second thing that kind of</font>

154
00:06:31,900 --> 00:06:36,690
makes his<font color="#E5E5E5"> soul approach cool is rather</font>

155
00:06:34,000 --> 00:06:39,690
than do<font color="#CCCCCC"> that you create derivative</font>

156
00:06:36,690 --> 00:06:41,889
classes and what these really<font color="#E5E5E5"> are is</font>

157
00:06:39,690 --> 00:06:44,409
rather than go through<font color="#CCCCCC"> every</font>

158
00:06:41,889 --> 00:06:46,270
in the<font color="#E5E5E5"> in the alphabet</font><font color="#CCCCCC"> you can work out</font>

159
00:06:44,409 --> 00:06:48,039
pretty<font color="#CCCCCC"> much which letters are important</font>

160
00:06:46,270 --> 00:06:50,318
<font color="#CCCCCC">which letters are not important we call</font>

161
00:06:48,039 --> 00:06:52,870
these classes so looking on<font color="#E5E5E5"> the right</font>

162
00:06:50,319 --> 00:06:55,539
<font color="#E5E5E5">there</font><font color="#CCCCCC"> if we've</font><font color="#E5E5E5"> got the regular</font>

163
00:06:52,870 --> 00:06:57,009
expression a there's only<font color="#E5E5E5"> two letters</font>

164
00:06:55,539 --> 00:06:58,840
<font color="#CCCCCC">that are really there's only</font><font color="#E5E5E5"> two sets of</font>

165
00:06:57,009 --> 00:07:01,270
letters<font color="#CCCCCC"> that are really important</font><font color="#E5E5E5"> there</font>

166
00:06:58,840 --> 00:07:03,669
one is a<font color="#E5E5E5"> letter</font><font color="#CCCCCC"> A which is</font><font color="#E5E5E5"> obviously</font>

167
00:07:01,270 --> 00:07:05,169
important about expression<font color="#E5E5E5"> and the other</font>

168
00:07:03,669 --> 00:07:09,400
thing<font color="#E5E5E5"> that's important is everything</font>

169
00:07:05,169 --> 00:07:12,039
<font color="#E5E5E5">that's not an A and so we only need to</font>

170
00:07:09,400 --> 00:07:14,349
really do two derivatives<font color="#CCCCCC"> if we're</font>

171
00:07:12,039 --> 00:07:18,400
<font color="#E5E5E5">trying to you know go for that</font><font color="#CCCCCC"> algorithm</font>

172
00:07:14,349 --> 00:07:21,370
for<font color="#CCCCCC"> for very regular expression a and</font>

173
00:07:18,400 --> 00:07:24,370
<font color="#E5E5E5">similarly if you've got the example</font>

174
00:07:21,370 --> 00:07:25,659
there where you've got well I've got a

175
00:07:24,370 --> 00:07:28,569
bunch of examples<font color="#CCCCCC"> here</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> don't</font><font color="#E5E5E5"> have</font>

176
00:07:25,659 --> 00:07:30,310
time<font color="#E5E5E5"> but there's a set</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> rules again</font>

177
00:07:28,569 --> 00:07:33,279
you can easily program<font color="#E5E5E5"> them that's</font>

178
00:07:30,310 --> 00:07:35,229
<font color="#E5E5E5">probably the important thing so now we</font>

179
00:07:33,279 --> 00:07:37,870
can handle<font color="#CCCCCC"> Unicode which is nice the</font><font color="#E5E5E5"> red</font>

180
00:07:35,229 --> 00:07:39,699
is the change in<font color="#E5E5E5"> the algorithm</font><font color="#CCCCCC"> rather</font>

181
00:07:37,870 --> 00:07:42,310
than go through<font color="#E5E5E5"> every symbol in the</font>

182
00:07:39,699 --> 00:07:45,490
alphabet<font color="#E5E5E5"> we just go</font><font color="#CCCCCC"> through every state</font>

183
00:07:42,310 --> 00:07:49,689
<font color="#E5E5E5">every class in our derivative classes</font>

184
00:07:45,490 --> 00:07:50,889
and we take the<font color="#CCCCCC"> derivative of it we can</font>

185
00:07:49,689 --> 00:07:53,770
take<font color="#E5E5E5"> any symbol out of</font><font color="#CCCCCC"> the derivative</font>

186
00:07:50,889 --> 00:07:57,069
<font color="#E5E5E5">class and use that to generate</font><font color="#CCCCCC"> the next</font>

187
00:07:53,770 --> 00:07:59,889
state<font color="#E5E5E5"> so it's really</font><font color="#CCCCCC"> that simple so now</font>

188
00:07:57,069 --> 00:08:04,210
we<font color="#E5E5E5"> can you know handle large alphabets</font>

189
00:07:59,889 --> 00:08:10,060
<font color="#E5E5E5">which is nice and this is the last and</font>

190
00:08:04,210 --> 00:08:13,000
perhaps coolest thing rather<font color="#E5E5E5"> than do</font>

191
00:08:10,060 --> 00:08:15,849
this for one regular expression we<font color="#CCCCCC"> can</font>

192
00:08:13,000 --> 00:08:18,039
run this algorithm<font color="#E5E5E5"> over</font><font color="#CCCCCC"> a victor</font><font color="#E5E5E5"> of</font>

193
00:08:15,849 --> 00:08:20,889
regular expressions over<font color="#E5E5E5"> a list of them</font>

194
00:08:18,039 --> 00:08:22,330
<font color="#E5E5E5">and that means and that's very simple we</font>

195
00:08:20,889 --> 00:08:25,180
just<font color="#E5E5E5"> if you want to take the derivative</font>

196
00:08:22,330 --> 00:08:27,188
of a vector of regular expressions<font color="#E5E5E5"> it's</font>

197
00:08:25,180 --> 00:08:28,719
just<font color="#CCCCCC"> at the riveted of each vector so</font>

198
00:08:27,189 --> 00:08:31,689
you know that that's another state for

199
00:08:28,719 --> 00:08:33,760
<font color="#CCCCCC">us and then the same thing with the</font>

200
00:08:31,689 --> 00:08:36,610
derivative classes we just intersect

201
00:08:33,760 --> 00:08:38,468
them all it's a<font color="#E5E5E5"> very simple</font><font color="#CCCCCC"> idea but</font><font color="#E5E5E5"> now</font>

202
00:08:36,610 --> 00:08:40,810
we could take a whole<font color="#E5E5E5"> bunch of regular</font>

203
00:08:38,469 --> 00:08:43,539
expressions<font color="#E5E5E5"> and we can turn them</font><font color="#CCCCCC"> into a</font>

204
00:08:40,809 --> 00:08:47,589
single DFA<font color="#E5E5E5"> and this is</font><font color="#CCCCCC"> exactly</font><font color="#E5E5E5"> what we</font>

205
00:08:43,539 --> 00:08:50,439
need if we want<font color="#CCCCCC"> to do tokenization so</font>

206
00:08:47,589 --> 00:08:53,170
let's go<font color="#E5E5E5"> and see what it</font><font color="#CCCCCC"> looks like</font><font color="#E5E5E5"> in</font>

207
00:08:50,440 --> 00:08:54,950
<font color="#E5E5E5">Python and so when you want to implement</font>

208
00:08:53,170 --> 00:08:56,719
this stuff in Python is a few<font color="#CCCCCC"> key</font>

209
00:08:54,950 --> 00:08:58,370
decisions you've got to make<font color="#CCCCCC"> um how do</font>

210
00:08:56,720 --> 00:09:00,770
you represent<font color="#CCCCCC"> these large sets of</font>

211
00:08:58,370 --> 00:09:02,390
symbols<font color="#E5E5E5"> so you know you've got</font><font color="#CCCCCC"> if you're</font>

212
00:09:00,770 --> 00:09:05,360
doing<font color="#E5E5E5"> in Unicode you've got lots of</font>

213
00:09:02,390 --> 00:09:07,610
symbols<font color="#CCCCCC"> how do</font><font color="#E5E5E5"> we represent regular</font>

214
00:09:05,360 --> 00:09:09,020
expressions how do we compare

215
00:09:07,610 --> 00:09:11,000
expressions<font color="#E5E5E5"> for equality because</font>

216
00:09:09,020 --> 00:09:14,000
<font color="#CCCCCC">remember we need to</font><font color="#E5E5E5"> see if we've</font><font color="#CCCCCC"> seen</font>

217
00:09:11,000 --> 00:09:17,570
the same state<font color="#CCCCCC"> before and how do we be</font>

218
00:09:14,000 --> 00:09:20,000
able<font color="#E5E5E5"> to scan it from all this so larger</font>

219
00:09:17,570 --> 00:09:21,500
symbols<font color="#CCCCCC"> it's pretty interesting this</font>

220
00:09:20,000 --> 00:09:23,450
this is important to get right because

221
00:09:21,500 --> 00:09:27,500
<font color="#E5E5E5">it's right in the guts of the code and</font>

222
00:09:23,450 --> 00:09:32,600
fix the efficiency<font color="#E5E5E5"> the easiest ways just</font>

223
00:09:27,500 --> 00:09:35,960
represent you know as a disjoint ordered

224
00:09:32,600 --> 00:09:37,880
intervals<font color="#E5E5E5"> so in the case here a to 0 a 2</font>

225
00:09:35,960 --> 00:09:42,080
0 0 9<font color="#E5E5E5"> you can just</font><font color="#CCCCCC"> represented their</font>

226
00:09:37,880 --> 00:09:46,820
code points as like a couple a couple<font color="#CCCCCC"> of</font>

227
00:09:42,080 --> 00:09:48,470
tuples<font color="#CCCCCC"> and this is kind of cool</font><font color="#E5E5E5"> because</font>

228
00:09:46,820 --> 00:09:50,480
now you can test the membership using

229
00:09:48,470 --> 00:09:53,470
bisect<font color="#CCCCCC"> which is in the standard Python</font>

230
00:09:50,480 --> 00:09:56,180
library<font color="#CCCCCC"> and that's law and login and</font>

231
00:09:53,470 --> 00:09:57,740
Union intersection and differences can

232
00:09:56,180 --> 00:10:00,859
<font color="#CCCCCC">be implemented</font><font color="#E5E5E5"> as order in algorithms</font>

233
00:09:57,740 --> 00:10:05,210
which is cool it's<font color="#E5E5E5"> really tempting</font><font color="#CCCCCC"> to</font>

234
00:10:00,860 --> 00:10:08,720
subclass<font color="#E5E5E5"> the collections ABC set which</font>

235
00:10:05,210 --> 00:10:10,160
is you know<font color="#E5E5E5"> standard Python 3 to pretend</font>

236
00:10:08,720 --> 00:10:12,410
you've got a set of<font color="#E5E5E5"> integers</font><font color="#CCCCCC"> but as it</font>

237
00:10:10,160 --> 00:10:15,410
turns<font color="#E5E5E5"> out that's a really</font><font color="#CCCCCC"> bad idea and</font>

238
00:10:12,410 --> 00:10:17,870
<font color="#E5E5E5">it all comes down to hash</font><font color="#CCCCCC"> we need to put</font>

239
00:10:15,410 --> 00:10:20,300
our sets<font color="#E5E5E5"> in two sets</font><font color="#CCCCCC"> of sets</font><font color="#E5E5E5"> which means</font>

240
00:10:17,870 --> 00:10:22,390
we need hash<font color="#E5E5E5"> if you remember</font><font color="#CCCCCC"> that in</font>

241
00:10:20,300 --> 00:10:27,170
that<font color="#E5E5E5"> previous algorithm we had sets of</font>

242
00:10:22,390 --> 00:10:29,120
<font color="#CCCCCC">States and</font><font color="#E5E5E5"> the standard hash requires</font>

243
00:10:27,170 --> 00:10:31,400
you the standard hash<font color="#E5E5E5"> argument requires</font>

244
00:10:29,120 --> 00:10:32,900
you to<font color="#E5E5E5"> iterate over every</font><font color="#CCCCCC"> element so</font>

245
00:10:31,400 --> 00:10:36,050
that's really slow if you've got lots

246
00:10:32,900 --> 00:10:38,660
<font color="#E5E5E5">and lots of</font><font color="#CCCCCC"> images in a set so so be</font>

247
00:10:36,050 --> 00:10:40,729
subclassed<font color="#CCCCCC"> couple instead and make it</font>

248
00:10:38,660 --> 00:10:43,610
<font color="#E5E5E5">look a bit set like</font><font color="#CCCCCC"> we could actually</font>

249
00:10:40,730 --> 00:10:45,140
ignore the requirement that<font color="#E5E5E5"> hatches</font><font color="#CCCCCC"> has</font>

250
00:10:43,610 --> 00:10:47,210
all sets with the<font color="#E5E5E5"> same members</font><font color="#CCCCCC"> is</font>

251
00:10:45,140 --> 00:10:49,430
<font color="#CCCCCC">supposed to hash to the same hash</font><font color="#E5E5E5"> but I</font>

252
00:10:47,210 --> 00:10:53,630
didn't want<font color="#E5E5E5"> to do</font><font color="#CCCCCC"> that so</font><font color="#E5E5E5"> that was a bit</font>

253
00:10:49,430 --> 00:10:55,520
tricky<font color="#CCCCCC"> and to represent the sets</font><font color="#E5E5E5"> so</font>

254
00:10:53,630 --> 00:10:57,350
<font color="#E5E5E5">sorry to represent the expressions we</font>

255
00:10:55,520 --> 00:11:00,350
just create a class hierarchy<font color="#E5E5E5"> so we</font>

256
00:10:57,350 --> 00:11:02,180
<font color="#CCCCCC">created a expression</font><font color="#E5E5E5"> class and then we</font>

257
00:11:00,350 --> 00:11:04,400
subclass it to have a lot of different

258
00:11:02,180 --> 00:11:07,130
types of<font color="#E5E5E5"> operations</font><font color="#CCCCCC"> and that means that</font>

259
00:11:04,400 --> 00:11:07,949
<font color="#E5E5E5">we can then easily build our expressions</font>

260
00:11:07,130 --> 00:11:11,040
as trees

261
00:11:07,950 --> 00:11:12,690
so here's a visit expression and you

262
00:11:11,040 --> 00:11:14,670
know here's<font color="#E5E5E5"> the tree that comes out of</font>

263
00:11:12,690 --> 00:11:15,960
<font color="#E5E5E5">it so we just you know</font><font color="#CCCCCC"> pars</font><font color="#E5E5E5"> the</font>

264
00:11:14,670 --> 00:11:21,510
expression and produce a tree it's

265
00:11:15,960 --> 00:11:22,920
pretty<font color="#E5E5E5"> standard</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> the last thing I</font>

266
00:11:21,510 --> 00:11:25,620
think<font color="#CCCCCC"> that</font><font color="#E5E5E5"> was tricky as I said</font><font color="#CCCCCC"> before</font>

267
00:11:22,920 --> 00:11:28,979
was how do<font color="#E5E5E5"> we compare these sets this is</font>

268
00:11:25,620 --> 00:11:30,420
actually interesting<font color="#CCCCCC"> and so what we do</font>

269
00:11:28,980 --> 00:11:32,610
is we try<font color="#CCCCCC"> to always</font><font color="#E5E5E5"> produce the</font>

270
00:11:30,420 --> 00:11:34,939
<font color="#E5E5E5">expression trees in a canonical form</font>

271
00:11:32,610 --> 00:11:37,980
<font color="#CCCCCC">okay this is</font><font color="#E5E5E5"> called a weak equivalence</font>

272
00:11:34,940 --> 00:11:41,100
<font color="#E5E5E5">so we always</font><font color="#CCCCCC"> try and</font><font color="#E5E5E5"> produce them in the</font>

273
00:11:37,980 --> 00:11:42,810
same canonical form<font color="#E5E5E5"> and by doing</font><font color="#CCCCCC"> that we</font>

274
00:11:41,100 --> 00:11:44,490
<font color="#E5E5E5">can just compare them by</font><font color="#CCCCCC"> comparing the</font>

275
00:11:42,810 --> 00:11:46,229
trees structurally and if the trees<font color="#CCCCCC"> are</font>

276
00:11:44,490 --> 00:11:49,740
<font color="#E5E5E5">the same structurally it's the same</font>

277
00:11:46,230 --> 00:11:51,030
regular expression<font color="#E5E5E5"> and answer there's a</font>

278
00:11:49,740 --> 00:11:53,490
bunch of<font color="#E5E5E5"> rules again that we can</font>

279
00:11:51,030 --> 00:11:55,470
implement pretty easily<font color="#CCCCCC"> but a real-life</font>

280
00:11:53,490 --> 00:11:59,490
example<font color="#CCCCCC"> of</font><font color="#E5E5E5"> this we use a smart</font>

281
00:11:55,470 --> 00:12:01,830
constructor<font color="#CCCCCC"> we used</font><font color="#E5E5E5"> in you instead</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> in</font>

282
00:11:59,490 --> 00:12:04,410
it<font color="#E5E5E5"> and we'll the reason we use</font><font color="#CCCCCC"> near</font>

283
00:12:01,830 --> 00:12:06,540
which most<font color="#CCCCCC"> people don't use in Python is</font>

284
00:12:04,410 --> 00:12:08,610
because we<font color="#E5E5E5"> don't always want</font><font color="#CCCCCC"> to create a</font>

285
00:12:06,540 --> 00:12:10,740
new object<font color="#CCCCCC"> sometimes when we're being a</font>

286
00:12:08,610 --> 00:12:13,160
smart constructor<font color="#E5E5E5"> we want to return an</font>

287
00:12:10,740 --> 00:12:15,750
already existing object or a different

288
00:12:13,160 --> 00:12:17,760
type of object what we thought we were

289
00:12:15,750 --> 00:12:21,890
constructing<font color="#CCCCCC"> and so that's what we're</font>

290
00:12:17,760 --> 00:12:24,840
<font color="#E5E5E5">doing here in the concatenation operator</font>

291
00:12:21,890 --> 00:12:27,150
<font color="#E5E5E5">where we're checking to see if the left</font>

292
00:12:24,840 --> 00:12:29,190
side is a<font color="#E5E5E5"> concatenation if so we just</font>

293
00:12:27,150 --> 00:12:31,829
reorder<font color="#E5E5E5"> things there's always</font><font color="#CCCCCC"> the same</font>

294
00:12:29,190 --> 00:12:33,510
structure and then we<font color="#E5E5E5"> have a bunch</font><font color="#CCCCCC"> of</font>

295
00:12:31,830 --> 00:12:35,820
checks<font color="#E5E5E5"> to see how is the left side</font><font color="#CCCCCC"> now</font>

296
00:12:33,510 --> 00:12:37,800
<font color="#CCCCCC">well then the answer's no is the left is</font>

297
00:12:35,820 --> 00:12:40,860
the right side<font color="#CCCCCC"> no the answer's no we</font>

298
00:12:37,800 --> 00:12:42,329
don't need to<font color="#CCCCCC"> actually create a</font><font color="#E5E5E5"> tree at</font>

299
00:12:40,860 --> 00:12:44,370
that point so we<font color="#E5E5E5"> go for a bunch of tests</font>

300
00:12:42,330 --> 00:12:45,900
like<font color="#CCCCCC"> that and then we actually construct</font>

301
00:12:44,370 --> 00:12:47,400
the object at the bottom so<font color="#CCCCCC"> you was</font>

302
00:12:45,900 --> 00:12:49,319
<font color="#E5E5E5">really kind of cool for things like this</font>

303
00:12:47,400 --> 00:12:50,730
and if you didn't<font color="#E5E5E5"> know it existed</font><font color="#CCCCCC"> it's</font>

304
00:12:49,320 --> 00:12:52,160
worth going<font color="#E5E5E5"> and looking and seeing</font><font color="#CCCCCC"> how</font>

305
00:12:50,730 --> 00:12:55,410
it<font color="#E5E5E5"> works</font>

306
00:12:52,160 --> 00:12:57,390
and finally we can build a scanner<font color="#E5E5E5"> I've</font>

307
00:12:55,410 --> 00:13:00,030
got two<font color="#CCCCCC"> minutes</font><font color="#E5E5E5"> now we can build a</font>

308
00:12:57,390 --> 00:13:02,580
scanner<font color="#CCCCCC"> and it's</font><font color="#E5E5E5"> really very very</font><font color="#CCCCCC"> simple</font>

309
00:13:00,030 --> 00:13:04,319
<font color="#E5E5E5">once you've got the DFA you basically</font>

310
00:13:02,580 --> 00:13:08,280
run through your symbols in your text

311
00:13:04,320 --> 00:13:09,840
<font color="#E5E5E5">and you run through until</font><font color="#CCCCCC"> you get to a</font>

312
00:13:08,280 --> 00:13:12,050
point where you can't match<font color="#CCCCCC"> anymore</font>

313
00:13:09,840 --> 00:13:14,370
<font color="#CCCCCC">where you get to the arrow state</font><font color="#E5E5E5"> and</font>

314
00:13:12,050 --> 00:13:16,920
then as you've run through you've

315
00:13:14,370 --> 00:13:19,260
remembered<font color="#E5E5E5"> if you've seen any accepting</font>

316
00:13:16,920 --> 00:13:21,000
<font color="#CCCCCC">states</font><font color="#E5E5E5"> and if you did</font><font color="#CCCCCC"> seeing</font><font color="#E5E5E5"> this if the</font>

317
00:13:19,260 --> 00:13:21,700
<font color="#CCCCCC">acceptance state what you do</font><font color="#E5E5E5"> say well I</font>

318
00:13:21,000 --> 00:13:24,880
found

319
00:13:21,700 --> 00:13:27,610
I'll return<font color="#E5E5E5"> it</font><font color="#CCCCCC"> and then I'll rewind back</font>

320
00:13:24,880 --> 00:13:30,640
to<font color="#CCCCCC"> where</font><font color="#E5E5E5"> that token was and I'll start</font>

321
00:13:27,610 --> 00:13:32,650
again<font color="#CCCCCC"> and so you don't</font><font color="#E5E5E5"> go through the</font>

322
00:13:30,640 --> 00:13:34,750
DFA just once to tokenize you have to go

323
00:13:32,650 --> 00:13:37,930
through you know<font color="#E5E5E5"> one time for</font><font color="#CCCCCC"> each</font><font color="#E5E5E5"> token</font>

324
00:13:34,750 --> 00:13:39,430
and<font color="#E5E5E5"> this is the basic approach and but</font>

325
00:13:37,930 --> 00:13:43,989
<font color="#E5E5E5">again it's not much code is very very</font>

326
00:13:39,430 --> 00:13:48,520
<font color="#E5E5E5">simple</font><font color="#CCCCCC"> so a simple</font><font color="#E5E5E5"> example of the code I</font>

327
00:13:43,990 --> 00:13:52,600
built<font color="#E5E5E5"> here's the input you can define</font>

328
00:13:48,520 --> 00:13:53,980
letters and digits here which start with

329
00:13:52,600 --> 00:13:55,780
<font color="#E5E5E5">an underscore because we don't actually</font>

330
00:13:53,980 --> 00:13:57,790
<font color="#E5E5E5">want tokens from those</font><font color="#CCCCCC"> they're fragments</font>

331
00:13:55,780 --> 00:14:00,120
<font color="#E5E5E5">but then we can put them together into</font>

332
00:13:57,790 --> 00:14:02,110
you know four<font color="#CCCCCC"> different types of tokens</font>

333
00:14:00,120 --> 00:14:04,690
<font color="#CCCCCC">and</font><font color="#E5E5E5"> all the things on the right of</font>

334
00:14:02,110 --> 00:14:06,370
<font color="#CCCCCC">course</font><font color="#E5E5E5"> our regular expressions so we</font>

335
00:14:04,690 --> 00:14:09,160
type<font color="#CCCCCC"> that in and then we put it through</font>

336
00:14:06,370 --> 00:14:10,360
<font color="#E5E5E5">the tool that</font><font color="#CCCCCC"> I built</font><font color="#E5E5E5"> and you get a DFA</font>

337
00:14:09,160 --> 00:14:11,469
which of course<font color="#E5E5E5"> you can't see but it</font>

338
00:14:10,360 --> 00:14:14,890
looks very<font color="#E5E5E5"> pretty from</font><font color="#CCCCCC"> a distance</font>

339
00:14:11,470 --> 00:14:17,020
<font color="#E5E5E5">there's a lot of detail there</font><font color="#CCCCCC"> and then</font>

340
00:14:14,890 --> 00:14:21,069
obviously<font color="#E5E5E5"> you can run that in linear</font>

341
00:14:17,020 --> 00:14:23,140
time<font color="#E5E5E5"> and it supports Unicode a slightly</font>

342
00:14:21,070 --> 00:14:26,380
larger<font color="#E5E5E5"> example I took</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> Pascal lecture</font>

343
00:14:23,140 --> 00:14:28,510
<font color="#E5E5E5">from the internet</font><font color="#CCCCCC"> and ran it</font><font color="#E5E5E5"> through</font>

344
00:14:26,380 --> 00:14:30,939
flex and<font color="#E5E5E5"> it came</font><font color="#CCCCCC"> up with a hundred</font><font color="#E5E5E5"> and</font>

345
00:14:28,510 --> 00:14:33,790
<font color="#E5E5E5">seventy four states and my tool which is</font>

346
00:14:30,940 --> 00:14:38,290
<font color="#CCCCCC">called</font><font color="#E5E5E5"> epsilon produced</font><font color="#CCCCCC"> 169 States so</font>

347
00:14:33,790 --> 00:14:40,449
roughly<font color="#E5E5E5"> the same so it seems to work</font><font color="#CCCCCC"> so</font>

348
00:14:38,290 --> 00:14:45,219
as I<font color="#E5E5E5"> said the tool is</font><font color="#CCCCCC"> called epsilon BAM</font>

349
00:14:40,450 --> 00:14:47,620
it's up on github<font color="#CCCCCC"> and</font><font color="#E5E5E5"> beta testers and</font>

350
00:14:45,220 --> 00:14:49,390
contributors are welcome there's a bunch

351
00:14:47,620 --> 00:14:52,240
of stuff not done yet<font color="#CCCCCC"> I need to do start</font>

352
00:14:49,390 --> 00:14:53,830
conditions which is something that flex

353
00:14:52,240 --> 00:14:57,310
supports<font color="#CCCCCC"> that</font><font color="#E5E5E5"> I don't support yet I'm</font>

354
00:14:53,830 --> 00:14:59,830
gonna this generates different<font color="#E5E5E5"> code you</font>

355
00:14:57,310 --> 00:15:01,449
can generate different<font color="#E5E5E5"> code targets so</font>

356
00:14:59,830 --> 00:15:03,700
I've got Python and dot<font color="#CCCCCC"> for</font>

357
00:15:01,450 --> 00:15:06,870
<font color="#E5E5E5">visualizations at the moment but I don't</font>

358
00:15:03,700 --> 00:15:09,070
have C so I need to<font color="#CCCCCC"> generate a</font><font color="#E5E5E5"> C target</font>

359
00:15:06,870 --> 00:15:12,760
the actual regular expressions are

360
00:15:09,070 --> 00:15:16,030
pretty close to<font color="#CCCCCC"> perl with a few extra</font>

361
00:15:12,760 --> 00:15:18,689
features<font color="#CCCCCC"> so that's kind of where it's at</font>

362
00:15:16,030 --> 00:15:21,930
<font color="#E5E5E5">and again I very much welcome any</font>

363
00:15:18,690 --> 00:15:25,300
contributions<font color="#E5E5E5"> I'm so ignore events</font>

364
00:15:21,930 --> 00:15:28,989
epsilon was directly inspired and based

365
00:15:25,300 --> 00:15:31,300
on the work of<font color="#E5E5E5"> Owens Rypien</font><font color="#CCCCCC"> Chiron who</font>

366
00:15:28,990 --> 00:15:33,910
are referenced and of course without<font color="#CCCCCC"> the</font>

367
00:15:31,300 --> 00:15:35,630
<font color="#E5E5E5">work of Brazil</font><font color="#CCCCCC"> ski</font><font color="#E5E5E5"> none of this would be</font>

368
00:15:33,910 --> 00:15:39,300
<font color="#CCCCCC">possible</font>

369
00:15:35,630 --> 00:15:41,400
thank you very<font color="#CCCCCC"> much and I think we've</font>

370
00:15:39,300 --> 00:15:43,780
exactly run out of time<font color="#E5E5E5"> so</font><font color="#CCCCCC"> any questions</font>

371
00:15:41,400 --> 00:15:51,010
I'll take later<font color="#E5E5E5"> thank you</font><font color="#CCCCCC"> very much</font>

372
00:15:43,780 --> 00:15:51,010
[Applause]

