1
00:00:04,630 --> 00:00:10,180
so next talk or<font color="#E5E5E5"> now I'm giving it it's</font>

2
00:00:08,650 --> 00:00:14,260
<font color="#E5E5E5">about the computer science behind the</font>

3
00:00:10,180 --> 00:00:16,779
modern distributed data store<font color="#E5E5E5"> and it</font><font color="#CCCCCC"> is</font>

4
00:00:14,260 --> 00:00:18,939
a hard problem<font color="#CCCCCC"> and what I would</font><font color="#E5E5E5"> like to</font>

5
00:00:16,779 --> 00:00:23,980
<font color="#CCCCCC">tell you today</font><font color="#E5E5E5"> it's like the four or</font>

6
00:00:18,940 --> 00:00:26,680
<font color="#E5E5E5">five major challenges that we face when</font>

7
00:00:23,980 --> 00:00:28,180
<font color="#CCCCCC">we create distributed database which we</font>

8
00:00:26,680 --> 00:00:30,430
at the<font color="#CCCCCC"> Wrangell DB</font><font color="#E5E5E5"> this the company I</font>

9
00:00:28,180 --> 00:00:32,890
work for<font color="#E5E5E5"> our building right now and</font>

10
00:00:30,430 --> 00:00:35,140
which is out there so<font color="#E5E5E5"> most of this is</font>

11
00:00:32,890 --> 00:00:37,239
<font color="#E5E5E5">already done and I would like to talk</font>

12
00:00:35,140 --> 00:00:39,850
about<font color="#E5E5E5"> it and how computer science helped</font>

13
00:00:37,239 --> 00:00:41,559
us<font color="#E5E5E5"> implementing all this stuff so the</font>

14
00:00:39,850 --> 00:00:45,190
toughest challenges that<font color="#E5E5E5"> I've selected</font>

15
00:00:41,559 --> 00:00:50,138
for<font color="#E5E5E5"> this talk is first of all resilience</font>

16
00:00:45,190 --> 00:00:53,050
and consensus sorting<font color="#CCCCCC"> block structured</font>

17
00:00:50,139 --> 00:00:55,780
merge trees which<font color="#CCCCCC"> is super</font><font color="#E5E5E5"> important</font>

18
00:00:53,050 --> 00:00:58,718
topic for<font color="#CCCCCC"> us then</font><font color="#E5E5E5"> we have hybrid logical</font>

19
00:00:55,780 --> 00:01:00,609
clocks<font color="#E5E5E5"> and finally how</font><font color="#CCCCCC"> can we do this</font>

20
00:00:58,719 --> 00:01:02,799
full<font color="#E5E5E5"> asset thing that you know from the</font>

21
00:01:00,609 --> 00:01:05,199
single server relational world<font color="#E5E5E5"> in a</font>

22
00:01:02,799 --> 00:01:08,920
distributed<font color="#CCCCCC"> environment</font><font color="#E5E5E5"> this muted</font><font color="#CCCCCC"> asset</font>

23
00:01:05,199 --> 00:01:12,130
transactions the bottom line<font color="#E5E5E5"> of this</font>

24
00:01:08,920 --> 00:01:15,460
talk is<font color="#CCCCCC"> you need computer science to</font>

25
00:01:12,130 --> 00:01:17,890
implement a modern data store<font color="#E5E5E5"> so you can</font>

26
00:01:15,460 --> 00:01:19,530
try with<font color="#CCCCCC"> giant error but most likely</font><font color="#E5E5E5"> you</font>

27
00:01:17,890 --> 00:01:23,100
<font color="#E5E5E5">won't succeed</font>

28
00:01:19,530 --> 00:01:26,829
so yes please

29
00:01:23,100 --> 00:01:28,780
<font color="#E5E5E5">hmm</font><font color="#CCCCCC"> okay I can</font><font color="#E5E5E5"> try</font><font color="#CCCCCC"> to speak a bit louder</font>

30
00:01:26,829 --> 00:01:31,119
<font color="#E5E5E5">so I thought it would be on the</font>

31
00:01:28,780 --> 00:01:33,159
microphone but I guess the microphone is

32
00:01:31,119 --> 00:01:35,229
only for recording right<font color="#E5E5E5"> okay then I</font>

33
00:01:33,159 --> 00:01:37,149
will<font color="#E5E5E5"> just speak louder okay thanks so</font>

34
00:01:35,229 --> 00:01:38,979
the format<font color="#E5E5E5"> will always be I have a</font>

35
00:01:37,149 --> 00:01:42,219
<font color="#E5E5E5">problem that I'm going to describe and</font>

36
00:01:38,979 --> 00:01:43,658
then I will show you how we can<font color="#E5E5E5"> use</font>

37
00:01:42,219 --> 00:01:46,178
computer science to solve<font color="#E5E5E5"> it</font>

38
00:01:43,659 --> 00:01:49,240
the first problem<font color="#CCCCCC"> resilient</font><font color="#E5E5E5"> resilience</font>

39
00:01:46,179 --> 00:01:52,299
and consensus so a modern<font color="#CCCCCC"> data store is</font>

40
00:01:49,240 --> 00:01:54,850
distributed so the data is<font color="#E5E5E5"> too large for</font>

41
00:01:52,299 --> 00:01:56,530
a single machine<font color="#E5E5E5"> we want to</font><font color="#CCCCCC"> add add more</font>

42
00:01:54,850 --> 00:01:57,939
machines<font color="#E5E5E5"> we want to have read scaling</font>

43
00:01:56,530 --> 00:02:02,679
write scaling and all this<font color="#CCCCCC"> weird stuff</font>

44
00:01:57,939 --> 00:02:05,199
<font color="#E5E5E5">so the data store is distributed because</font>

45
00:02:02,679 --> 00:02:07,869
<font color="#E5E5E5">it needs to scale out thing that I was</font>

46
00:02:05,200 --> 00:02:10,539
talking about<font color="#E5E5E5"> and it has to be resilient</font>

47
00:02:07,869 --> 00:02:13,360
<font color="#E5E5E5">so no matter what happens the system</font>

48
00:02:10,538 --> 00:02:15,790
should be<font color="#E5E5E5"> there if a</font><font color="#CCCCCC"> machine is on fire</font>

49
00:02:13,360 --> 00:02:16,849
the system should<font color="#CCCCCC"> be there has to be</font>

50
00:02:15,790 --> 00:02:20,179
resilient

51
00:02:16,849 --> 00:02:21,920
and this has the challenge<font color="#CCCCCC"> that</font>

52
00:02:20,180 --> 00:02:24,889
different parts<font color="#CCCCCC"> of the system</font><font color="#E5E5E5"> need</font><font color="#CCCCCC"> to</font>

53
00:02:21,920 --> 00:02:27,738
agree on certain<font color="#E5E5E5"> things so if you say</font>

54
00:02:24,889 --> 00:02:29,719
<font color="#E5E5E5">I'm storing a new document and the</font>

55
00:02:27,739 --> 00:02:31,579
database says yes I store it and you ask

56
00:02:29,719 --> 00:02:33,530
for<font color="#E5E5E5"> the same document again you don't</font>

57
00:02:31,579 --> 00:02:35,329
<font color="#CCCCCC">want the</font><font color="#E5E5E5"> database to say</font><font color="#CCCCCC"> which document</font>

58
00:02:33,530 --> 00:02:38,239
I don't know about it<font color="#E5E5E5"> it should</font><font color="#CCCCCC"> be there</font>

59
00:02:35,329 --> 00:02:43,430
so the service need to agree that<font color="#CCCCCC"> it is</font>

60
00:02:38,239 --> 00:02:47,780
there and consensus is<font color="#E5E5E5"> the art to really</font>

61
00:02:43,430 --> 00:02:51,829
<font color="#E5E5E5">achieve this as well as possible in</font>

62
00:02:47,780 --> 00:02:54,709
software only and consensus is

63
00:02:51,829 --> 00:02:56,719
relatively easy<font color="#E5E5E5"> as long as everything is</font>

64
00:02:54,709 --> 00:02:57,859
<font color="#E5E5E5">good so</font><font color="#CCCCCC"> you have networks you have</font><font color="#E5E5E5"> your</font>

65
00:02:56,719 --> 00:03:00,129
machines running and<font color="#E5E5E5"> they can</font>

66
00:02:57,859 --> 00:03:03,859
<font color="#E5E5E5">communicate to each other then it's</font>

67
00:03:00,129 --> 00:03:08,750
super<font color="#E5E5E5"> simple actually but it's super</font>

68
00:03:03,859 --> 00:03:12,169
<font color="#E5E5E5">hard</font><font color="#CCCCCC"> if no wrong</font><font color="#E5E5E5"> button the network has</font>

69
00:03:08,750 --> 00:03:14,769
outages or<font color="#E5E5E5"> the network has dropped</font>

70
00:03:12,169 --> 00:03:19,489
delayed or even<font color="#CCCCCC"> sent the</font><font color="#E5E5E5"> message twice</font>

71
00:03:14,769 --> 00:03:21,889
or<font color="#CCCCCC"> even more times if</font><font color="#E5E5E5"> discs fail and</font>

72
00:03:19,489 --> 00:03:25,220
come back with old or corrupted data<font color="#E5E5E5"> if</font>

73
00:03:21,889 --> 00:03:27,470
machines fail and come back with old<font color="#E5E5E5"> or</font>

74
00:03:25,220 --> 00:03:29,239
corrupted<font color="#E5E5E5"> data or even</font><font color="#CCCCCC"> if you enter a</font>

75
00:03:27,470 --> 00:03:32,799
data center or<font color="#CCCCCC"> a complete raggies is</font>

76
00:03:29,239 --> 00:03:38,000
down<font color="#E5E5E5"> and comes back with corrupted data</font>

77
00:03:32,799 --> 00:03:40,250
and yeah you might argue her<font color="#CCCCCC"> ok on</font><font color="#E5E5E5"> my</font>

78
00:03:38,000 --> 00:03:43,250
laptop<font color="#E5E5E5"> this never</font><font color="#CCCCCC"> really happens in my</font>

79
00:03:40,250 --> 00:03:46,639
lifetime<font color="#E5E5E5"> but if you are running</font><font color="#CCCCCC"> on a</font>

80
00:03:43,250 --> 00:03:49,370
large scale one of these events<font color="#E5E5E5"> most</font>

81
00:03:46,639 --> 00:03:50,959
<font color="#E5E5E5">likely will happen each night and I'm</font>

82
00:03:49,370 --> 00:03:52,400
<font color="#E5E5E5">pretty sure no</font><font color="#CCCCCC"> one of you wants to wake</font>

83
00:03:50,959 --> 00:03:56,049
up in the<font color="#CCCCCC"> middle of the night to fix</font>

84
00:03:52,400 --> 00:03:59,419
this<font color="#E5E5E5"> so you want the server to just work</font>

85
00:03:56,049 --> 00:04:02,979
<font color="#E5E5E5">and we even have not talked about</font>

86
00:03:59,419 --> 00:04:02,979
malicious attacks from enemies<font color="#CCCCCC"> a</font>

87
00:04:03,280 --> 00:04:10,040
solution to this<font color="#E5E5E5"> problem are several</font>

88
00:04:06,919 --> 00:04:13,189
consensus protocols traditionally<font color="#E5E5E5"> so the</font>

89
00:04:10,040 --> 00:04:16,060
first protocol is called<font color="#E5E5E5"> Texas written</font>

90
00:04:13,189 --> 00:04:20,539
in 1998

91
00:04:16,060 --> 00:04:23,150
Texas is super good but it's a challenge

92
00:04:20,539 --> 00:04:26,779
<font color="#CCCCCC">to understand and even more</font><font color="#E5E5E5"> of a</font>

93
00:04:23,150 --> 00:04:29,388
<font color="#E5E5E5">challenge to</font><font color="#CCCCCC"> implement it correctly</font><font color="#E5E5E5"> so I</font>

94
00:04:26,779 --> 00:04:30,680
personally<font color="#E5E5E5"> have read this paper like</font>

95
00:04:29,389 --> 00:04:32,449
five times<font color="#E5E5E5"> and</font>

96
00:04:30,680 --> 00:04:34,789
still not<font color="#E5E5E5"> sure</font><font color="#CCCCCC"> if I understood</font>

97
00:04:32,449 --> 00:04:38,180
everything<font color="#CCCCCC"> but the thing is</font><font color="#E5E5E5"> super</font>

98
00:04:34,789 --> 00:04:39,710
complicated<font color="#CCCCCC"> and for</font><font color="#E5E5E5"> our various variants</font>

99
00:04:38,180 --> 00:04:42,889
exist to<font color="#E5E5E5"> make it a bit simpler to</font>

100
00:04:39,710 --> 00:04:46,430
<font color="#CCCCCC">implement and</font><font color="#E5E5E5"> to follow and the most</font>

101
00:04:42,889 --> 00:04:49,100
<font color="#E5E5E5">well-known one is called raft from 2013</font>

102
00:04:46,430 --> 00:04:52,400
<font color="#E5E5E5">and this has been</font><font color="#CCCCCC"> designed to</font><font color="#E5E5E5"> be</font>

103
00:04:49,100 --> 00:04:56,330
understandable implementable<font color="#E5E5E5"> it is still</font>

104
00:04:52,400 --> 00:04:58,758
complicated<font color="#E5E5E5"> but it's doable so my advice</font>

105
00:04:56,330 --> 00:05:01,880
is<font color="#E5E5E5"> if you're interested in this topic</font>

106
00:04:58,759 --> 00:05:04,820
<font color="#CCCCCC">first try to understand Paxos read it a</font>

107
00:05:01,880 --> 00:05:07,880
couple<font color="#E5E5E5"> of times</font><font color="#CCCCCC"> so for some time try to</font>

108
00:05:04,820 --> 00:05:10,550
understand it<font color="#E5E5E5"> but do</font><font color="#CCCCCC"> not try to</font>

109
00:05:07,880 --> 00:05:13,969
implement it<font color="#E5E5E5"> that's most of the time</font><font color="#CCCCCC"> a</font>

110
00:05:10,550 --> 00:05:16,430
waste of time<font color="#CCCCCC"> and after you understood</font>

111
00:05:13,970 --> 00:05:18,320
<font color="#E5E5E5">parcels are kind of understood it and</font>

112
00:05:16,430 --> 00:05:21,080
draw the beauty of rough<font color="#E5E5E5"> and see how</font>

113
00:05:18,320 --> 00:05:23,050
simple<font color="#E5E5E5"> it gets if you start with rough</font>

114
00:05:21,080 --> 00:05:28,099
you still think oh it's too complicated

115
00:05:23,050 --> 00:05:29,449
but this way<font color="#E5E5E5"> actually works but my</font>

116
00:05:28,099 --> 00:05:31,840
<font color="#E5E5E5">advice do</font><font color="#CCCCCC"> not implement</font><font color="#E5E5E5"> it either</font>

117
00:05:29,449 --> 00:05:35,180
<font color="#E5E5E5">because it's still too</font><font color="#CCCCCC"> complicated</font>

118
00:05:31,840 --> 00:05:37,219
<font color="#E5E5E5">so you should use if possible by any</font>

119
00:05:35,180 --> 00:05:39,680
means<font color="#E5E5E5"> some of the best that better</font>

120
00:05:37,220 --> 00:05:41,930
tested implementations that<font color="#E5E5E5"> you trust so</font>

121
00:05:39,680 --> 00:05:46,550
there are a couple<font color="#E5E5E5"> out</font><font color="#CCCCCC"> there let's say</font>

122
00:05:41,930 --> 00:05:48,139
zookeeper<font color="#E5E5E5"> then we have etcd and in a</font>

123
00:05:46,550 --> 00:05:50,389
wrangle DB we have also a rough version

124
00:05:48,139 --> 00:05:51,949
which is called<font color="#CCCCCC"> the Ranga</font><font color="#E5E5E5"> DB agency and</font>

125
00:05:50,389 --> 00:05:54,580
I<font color="#E5E5E5"> think there</font><font color="#CCCCCC"> are a</font><font color="#E5E5E5"> couple of more I</font>

126
00:05:51,949 --> 00:05:59,150
think neo4j uses zookeeper right<font color="#CCCCCC"> Oh</font>

127
00:05:54,580 --> 00:06:01,250
<font color="#CCCCCC">rough implemented as well ok</font><font color="#E5E5E5"> nice but</font>

128
00:05:59,150 --> 00:06:04,880
most<font color="#E5E5E5"> importantly do</font><font color="#CCCCCC"> not try to implement</font>

129
00:06:01,250 --> 00:06:07,400
<font color="#E5E5E5">your own algorithm unless you like have</font>

130
00:06:04,880 --> 00:06:09,080
two years<font color="#E5E5E5"> where you can like freeze time</font>

131
00:06:07,400 --> 00:06:12,758
implement this algorithm and then

132
00:06:09,080 --> 00:06:15,198
continue where<font color="#CCCCCC"> you are but</font><font color="#E5E5E5"> otherwise</font>

133
00:06:12,759 --> 00:06:18,889
<font color="#E5E5E5">probably would use</font><font color="#CCCCCC"> a lot of time just</font>

134
00:06:15,199 --> 00:06:21,530
<font color="#E5E5E5">inventing the whole thing and now I</font><font color="#CCCCCC"> try</font>

135
00:06:18,889 --> 00:06:26,630
to<font color="#E5E5E5"> do a really hard thing try to explain</font>

136
00:06:21,530 --> 00:06:29,780
raft<font color="#E5E5E5"> in a single slide first of all we</font>

137
00:06:26,630 --> 00:06:32,509
need an odd number<font color="#CCCCCC"> of service why they</font>

138
00:06:29,780 --> 00:06:35,448
are odd<font color="#CCCCCC"> we'll come</font><font color="#E5E5E5"> to in a minute each</font>

139
00:06:32,509 --> 00:06:37,370
of<font color="#E5E5E5"> them keep a persisted</font><font color="#CCCCCC"> lock of events</font>

140
00:06:35,449 --> 00:06:41,680
so they just write<font color="#CCCCCC"> down this event</font>

141
00:06:37,370 --> 00:06:45,850
happens that event happens in one order

142
00:06:41,680 --> 00:06:48,610
everything is replicated to everybody so

143
00:06:45,850 --> 00:06:51,460
<font color="#E5E5E5">that means each</font><font color="#CCCCCC"> of the odd service</font><font color="#E5E5E5"> has</font>

144
00:06:48,610 --> 00:06:56,800
the<font color="#CCCCCC"> same lock</font><font color="#E5E5E5"> and has to have the same</font>

145
00:06:51,460 --> 00:07:01,030
lock then they democratically elect the

146
00:06:56,800 --> 00:07:03,030
leader with an absolute majority<font color="#E5E5E5"> that's</font>

147
00:07:01,030 --> 00:07:06,280
<font color="#E5E5E5">why we need an odd number of service</font>

148
00:07:03,030 --> 00:07:09,070
because<font color="#CCCCCC"> then one of them will have the</font>

149
00:07:06,280 --> 00:07:10,929
<font color="#CCCCCC">majority</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> a network split so we cut</font>

150
00:07:09,070 --> 00:07:12,400
<font color="#E5E5E5">the network into a half then one half</font>

151
00:07:10,930 --> 00:07:14,380
will have<font color="#E5E5E5"> the majority</font><font color="#CCCCCC"> of service the</font>

152
00:07:12,400 --> 00:07:18,840
<font color="#CCCCCC">other half will not have the majority of</font>

153
00:07:14,380 --> 00:07:22,650
service so they can elect the leader and

154
00:07:18,840 --> 00:07:25,419
only the leader<font color="#E5E5E5"> may append to this lock</font>

155
00:07:22,650 --> 00:07:27,010
so<font color="#E5E5E5"> you can only write on one leader and</font>

156
00:07:25,419 --> 00:07:31,750
<font color="#E5E5E5">this makes sure</font><font color="#CCCCCC"> it is persisted</font>

157
00:07:27,010 --> 00:07:35,260
everywhere and an append-only<font color="#CCCCCC"> council is</font>

158
00:07:31,750 --> 00:07:41,050
successful if a majority<font color="#CCCCCC"> of all others</font>

159
00:07:35,260 --> 00:07:43,690
have persisted and<font color="#E5E5E5"> confronted and these</font>

160
00:07:41,050 --> 00:07:45,849
two rules<font color="#CCCCCC"> actually allowed to shut down</font>

161
00:07:43,690 --> 00:07:48,729
any of<font color="#E5E5E5"> these machines at any time and</font>

162
00:07:45,849 --> 00:07:52,289
still have a correct<font color="#CCCCCC"> state and a</font>

163
00:07:48,729 --> 00:07:52,289
<font color="#E5E5E5">consistent state across all the others</font>

164
00:07:53,370 --> 00:07:59,070
then you need a very smart logic to

165
00:07:56,169 --> 00:08:03,789
ensure there's a unique leader<font color="#E5E5E5"> and</font>

166
00:07:59,070 --> 00:08:06,370
automatic<font color="#E5E5E5"> recovery from failure</font><font color="#CCCCCC"> I think</font>

167
00:08:03,789 --> 00:08:12,099
I could give like full<font color="#CCCCCC"> hour talk just</font>

168
00:08:06,370 --> 00:08:13,810
<font color="#E5E5E5">only</font><font color="#CCCCCC"> about the</font><font color="#E5E5E5"> smart logic so let's say</font>

169
00:08:12,099 --> 00:08:17,830
we need a smart logic to have these

170
00:08:13,810 --> 00:08:19,770
things guaranteed it's all a lot<font color="#CCCCCC"> of</font><font color="#E5E5E5"> fun</font>

171
00:08:17,830 --> 00:08:22,599
to get this right

172
00:08:19,770 --> 00:08:24,460
but it is proven to work<font color="#CCCCCC"> so we had a lot</font>

173
00:08:22,599 --> 00:08:27,250
<font color="#CCCCCC">of better stories where we had like tiny</font>

174
00:08:24,460 --> 00:08:28,810
<font color="#E5E5E5">little</font><font color="#CCCCCC"> bugs which didn't work out at the</font>

175
00:08:27,250 --> 00:08:32,830
beginning<font color="#CCCCCC"> and was hard to find that</font>

176
00:08:28,810 --> 00:08:35,110
eventually we succeeded the next thing

177
00:08:32,830 --> 00:08:38,589
is one<font color="#E5E5E5"> puts the key value store on top</font>

178
00:08:35,110 --> 00:08:40,930
of this rough protocol and the key value

179
00:08:38,589 --> 00:08:42,839
store will then basically<font color="#CCCCCC"> fill the</font>

180
00:08:40,929 --> 00:08:46,209
entries of the lock by events<font color="#CCCCCC"> and</font>

181
00:08:42,839 --> 00:08:47,709
thereby you<font color="#E5E5E5"> have a consistent data store</font>

182
00:08:46,209 --> 00:08:50,250
key value store which<font color="#CCCCCC"> is resilient</font>

183
00:08:47,709 --> 00:08:50,250
against failure

184
00:08:51,940 --> 00:08:57,530
let's try a short demonstration<font color="#E5E5E5"> so I</font>

185
00:08:55,520 --> 00:09:04,819
have uploaded<font color="#CCCCCC"> these slides so they</font>

186
00:08:57,530 --> 00:09:08,180
should be clickable and if that works<font color="#CCCCCC"> oh</font>

187
00:09:04,820 --> 00:09:10,880
I need internet connection<font color="#CCCCCC"> okay I</font>

188
00:09:08,180 --> 00:09:12,920
<font color="#E5E5E5">haven't set this up so</font><font color="#CCCCCC"> nevermind</font><font color="#E5E5E5"> so the</font>

189
00:09:10,880 --> 00:09:16,250
idea of<font color="#E5E5E5"> a raft is that we have like five</font>

190
00:09:12,920 --> 00:09:19,189
servers one server like first gets into

191
00:09:16,250 --> 00:09:20,660
a timeout<font color="#E5E5E5"> sends out the event that I</font>

192
00:09:19,190 --> 00:09:24,170
want to be leader to<font color="#CCCCCC"> all the other ones</font>

193
00:09:20,660 --> 00:09:26,510
<font color="#E5E5E5">and as soon as the majority says oh I</font>

194
00:09:24,170 --> 00:09:27,500
<font color="#CCCCCC">expect he</font><font color="#E5E5E5"> a I accept you</font><font color="#CCCCCC"> as a leader</font><font color="#E5E5E5"> he</font>

195
00:09:26,510 --> 00:09:28,880
will be the new<font color="#CCCCCC"> leader</font>

196
00:09:27,500 --> 00:09:30,800
otherwise the next<font color="#CCCCCC"> server will try to</font>

197
00:09:28,880 --> 00:09:33,740
get the leader<font color="#E5E5E5"> until we have one leader</font>

198
00:09:30,800 --> 00:09:36,680
<font color="#E5E5E5">and during this process</font><font color="#CCCCCC"> no events will</font>

199
00:09:33,740 --> 00:09:38,690
be able to be<font color="#E5E5E5"> written eventually we will</font>

200
00:09:36,680 --> 00:09:40,280
end up with<font color="#CCCCCC"> the leader if we shut</font><font color="#E5E5E5"> down</font>

201
00:09:38,690 --> 00:09:42,770
<font color="#E5E5E5">the leader one of the other ones will</font>

202
00:09:40,280 --> 00:09:46,579
figure<font color="#CCCCCC"> out oh the</font><font color="#E5E5E5"> leader is gone I will</font>

203
00:09:42,770 --> 00:09:48,829
<font color="#E5E5E5">have to take over and so on so we always</font>

204
00:09:46,580 --> 00:09:56,180
have one leader unless<font color="#CCCCCC"> all of the</font>

205
00:09:48,830 --> 00:10:01,640
servers are down and something<font color="#E5E5E5"> happened</font>

206
00:09:56,180 --> 00:10:04,969
was my slide sorry yeah but I<font color="#E5E5E5"> think it</font>

207
00:10:01,640 --> 00:10:12,910
<font color="#CCCCCC">downloaded stuff</font><font color="#E5E5E5"> from JavaScript</font>

208
00:10:04,970 --> 00:10:12,910
libraries the thing is I can't

209
00:10:13,630 --> 00:10:21,820
yeah<font color="#E5E5E5"> just give me</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> minute it will be</font>

210
00:10:25,750 --> 00:10:32,180
there we go

211
00:10:27,260 --> 00:10:34,270
<font color="#E5E5E5">Thanks and hopefully that works in a</font>

212
00:10:32,180 --> 00:10:34,270
minute

213
00:10:38,200 --> 00:10:42,130
doesn't seem to load this one

214
00:10:50,040 --> 00:10:54,360
somehow<font color="#E5E5E5"> doesn't work so</font><font color="#CCCCCC"> nevermind let's</font>

215
00:10:52,160 --> 00:11:00,270
<font color="#CCCCCC">continue</font><font color="#E5E5E5"> with our demonstration</font>

216
00:10:54,360 --> 00:11:02,190
so<font color="#E5E5E5"> let's sorting next problem</font><font color="#CCCCCC"> so first</font>

217
00:11:00,270 --> 00:11:06,540
of all<font color="#E5E5E5"> we now have solved that all</font>

218
00:11:02,190 --> 00:11:07,250
service can can agree<font color="#CCCCCC"> on things</font><font color="#E5E5E5"> next</font>

219
00:11:06,540 --> 00:11:12,480
problem

220
00:11:07,250 --> 00:11:16,770
sorting so the problem data stores<font color="#E5E5E5"> need</font>

221
00:11:12,480 --> 00:11:19,860
indexes indexes<font color="#E5E5E5"> typically are sorted</font>

222
00:11:16,770 --> 00:11:22,520
<font color="#E5E5E5">could you please close the door could</font>

223
00:11:19,860 --> 00:11:22,520
<font color="#E5E5E5">you please close the</font><font color="#CCCCCC"> door</font>

224
00:11:24,320 --> 00:11:31,050
so the problem data stores need indexes

225
00:11:28,130 --> 00:11:35,340
indexes are sorted<font color="#E5E5E5"> so in practice we</font>

226
00:11:31,050 --> 00:11:39,209
<font color="#CCCCCC">need to sort things not an unknown</font>

227
00:11:35,340 --> 00:11:41,130
problem<font color="#E5E5E5"> but everything you learned</font>

228
00:11:39,210 --> 00:11:44,250
<font color="#E5E5E5">probably at the university</font><font color="#CCCCCC"> or its</font><font color="#E5E5E5"> school</font>

229
00:11:41,130 --> 00:11:46,710
<font color="#E5E5E5">about sorting algorithms</font><font color="#CCCCCC"> are rubbish on</font>

230
00:11:44,250 --> 00:11:48,090
most of the saw<font color="#E5E5E5"> the published algorithms</font>

231
00:11:46,710 --> 00:11:50,430
that we have<font color="#E5E5E5"> are rubbish on modern</font>

232
00:11:48,090 --> 00:11:52,230
hardware<font color="#E5E5E5"> because they are optimized on</font>

233
00:11:50,430 --> 00:11:56,219
<font color="#E5E5E5">the number of comparisons you have to</font>

234
00:11:52,230 --> 00:11:58,980
take but none of them takes the modern

235
00:11:56,220 --> 00:12:00,930
<font color="#E5E5E5">hardware into account because</font><font color="#CCCCCC"> the</font>

236
00:11:58,980 --> 00:12:03,920
problem is<font color="#E5E5E5"> no</font><font color="#CCCCCC"> longer the comparison</font><font color="#E5E5E5"> in</font>

237
00:12:00,930 --> 00:12:07,140
computations but<font color="#CCCCCC"> the data movement</font>

238
00:12:03,920 --> 00:12:10,819
because it<font color="#CCCCCC"> is more expensive to load</font>

239
00:12:07,140 --> 00:12:12,840
data<font color="#E5E5E5"> from lower levels of memory caches</font>

240
00:12:10,820 --> 00:12:16,820
<font color="#E5E5E5">then it is to do a couple</font><font color="#CCCCCC"> of</font>

241
00:12:12,840 --> 00:12:19,950
computations on high level caches<font color="#CCCCCC"> so</font>

242
00:12:16,820 --> 00:12:22,170
<font color="#CCCCCC">since the time we're able to II was</font>

243
00:12:19,950 --> 00:12:25,200
<font color="#CCCCCC">blazing-fast</font><font color="#E5E5E5"> hardware which is a couple</font>

244
00:12:22,170 --> 00:12:28,380
<font color="#CCCCCC">of years ago</font><font color="#E5E5E5"> and the compute</font><font color="#CCCCCC"> power in</font>

245
00:12:25,200 --> 00:12:32,880
one core has increased by roughly<font color="#E5E5E5"> twenty</font>

246
00:12:28,380 --> 00:12:37,860
thousand percent<font color="#E5E5E5"> a single memory access</font>

247
00:12:32,880 --> 00:12:41,520
<font color="#E5E5E5">only</font><font color="#CCCCCC"> by a factor</font><font color="#E5E5E5"> of 40</font><font color="#CCCCCC"> and in</font><font color="#E5E5E5"> addition</font>

248
00:12:37,860 --> 00:12:44,370
we<font color="#E5E5E5"> have up</font><font color="#CCCCCC"> to 32</font><font color="#E5E5E5"> or even more course in</font>

249
00:12:41,520 --> 00:12:47,280
a single CPU so that means the

250
00:12:44,370 --> 00:12:50,850
computational power<font color="#E5E5E5"> has outpaced the</font>

251
00:12:47,280 --> 00:12:54,569
memory access by a factor of 1218

252
00:12:50,850 --> 00:12:59,610
roughly even more so<font color="#E5E5E5"> that means we can</font>

253
00:12:54,570 --> 00:13:02,430
like<font color="#E5E5E5"> do to</font><font color="#CCCCCC"> 1,200 operations</font><font color="#E5E5E5"> more in our</font>

254
00:12:59,610 --> 00:13:03,089
<font color="#E5E5E5">CPU for one day to excess in</font><font color="#CCCCCC"> the same</font>

255
00:13:02,430 --> 00:13:05,279
time

256
00:13:03,089 --> 00:13:06,899
then we could in the<font color="#E5E5E5"> time when most of</font>

257
00:13:05,279 --> 00:13:17,399
these algorithms<font color="#CCCCCC"> actually were invented</font>

258
00:13:06,899 --> 00:13:20,550
<font color="#CCCCCC">so we need an idea</font><font color="#E5E5E5"> algorithm that can do</font>

259
00:13:17,399 --> 00:13:23,399
parallel<font color="#E5E5E5"> sorting and makes use of the</font>

260
00:13:20,550 --> 00:13:25,469
amount of CPUs that<font color="#CCCCCC"> we have and</font><font color="#E5E5E5"> that</font>

261
00:13:23,399 --> 00:13:29,790
makes use<font color="#E5E5E5"> of all the cache layers that</font>

262
00:13:25,470 --> 00:13:32,999
we have in our main memory<font color="#E5E5E5"> and the only</font>

263
00:13:29,790 --> 00:13:36,420
<font color="#E5E5E5">algorithm</font><font color="#CCCCCC"> that really works there is a</font>

264
00:13:32,999 --> 00:13:40,019
merge sort<font color="#E5E5E5"> so idea for merge</font><font color="#CCCCCC"> sort is</font><font color="#E5E5E5"> I</font>

265
00:13:36,420 --> 00:13:41,459
have blocks which are sorted<font color="#E5E5E5"> from the</font>

266
00:13:40,019 --> 00:13:44,309
beginning this block is exactly one

267
00:13:41,459 --> 00:13:46,109
element large so sorted by definition

268
00:13:44,309 --> 00:13:51,300
<font color="#E5E5E5">and then I just merge two of them and</font>

269
00:13:46,110 --> 00:13:55,019
<font color="#E5E5E5">they are always sorted in addition I</font>

270
00:13:51,300 --> 00:13:59,128
will<font color="#E5E5E5"> take each sorted block each of them</font>

271
00:13:55,019 --> 00:14:02,879
and put them into<font color="#E5E5E5"> one min-heap a mini is</font>

272
00:13:59,129 --> 00:14:05,910
a structure<font color="#E5E5E5"> a</font><font color="#CCCCCC"> balanced tree so balanced</font>

273
00:14:02,879 --> 00:14:08,279
tree means all these parcels<font color="#E5E5E5"> have around</font>

274
00:14:05,910 --> 00:14:13,439
the same<font color="#E5E5E5"> lengths some of them may be a</font>

275
00:14:08,279 --> 00:14:16,079
bit shorter<font color="#CCCCCC"> so most of them</font><font color="#E5E5E5"> have the</font>

276
00:14:13,439 --> 00:14:18,139
<font color="#CCCCCC">same length and the only</font><font color="#E5E5E5"> rule is the</font>

277
00:14:16,079 --> 00:14:22,769
first elements of<font color="#E5E5E5"> the root element is</font>

278
00:14:18,139 --> 00:14:29,399
<font color="#E5E5E5">larger than all elements attached to it</font>

279
00:14:22,769 --> 00:14:32,069
<font color="#E5E5E5">so</font><font color="#CCCCCC"> all elements below are higher and it</font>

280
00:14:29,399 --> 00:14:36,449
is pretty easy<font color="#E5E5E5"> to remove this top</font>

281
00:14:32,069 --> 00:14:38,219
element<font color="#E5E5E5"> from the structure and put one</font>

282
00:14:36,449 --> 00:14:42,870
<font color="#E5E5E5">of the other guys on top because</font><font color="#CCCCCC"> then</font>

283
00:14:38,220 --> 00:14:46,019
still the<font color="#E5E5E5"> condition is true</font><font color="#CCCCCC"> and with</font>

284
00:14:42,870 --> 00:14:47,639
<font color="#E5E5E5">this thing</font><font color="#CCCCCC"> I can actually</font><font color="#E5E5E5"> put a couple</font>

285
00:14:46,019 --> 00:14:49,470
of<font color="#E5E5E5"> these</font><font color="#CCCCCC"> min heaps</font><font color="#E5E5E5"> for each of them</font>

286
00:14:47,639 --> 00:14:51,240
together and<font color="#E5E5E5"> just</font><font color="#CCCCCC"> look on the top</font>

287
00:14:49,470 --> 00:14:55,620
<font color="#CCCCCC">element to decide which one I have to</font>

288
00:14:51,240 --> 00:14:57,990
pick if I would do let's say a quicksort

289
00:14:55,620 --> 00:15:00,269
algorithm<font color="#CCCCCC"> instead I would pick one of</font>

290
00:14:57,990 --> 00:15:02,370
these<font color="#CCCCCC"> elements</font><font color="#E5E5E5"> and then search through</font>

291
00:15:00,269 --> 00:15:04,290
the entire block<font color="#E5E5E5"> which could be large</font>

292
00:15:02,370 --> 00:15:07,350
<font color="#CCCCCC">and put it on the left</font><font color="#E5E5E5"> or the right hand</font>

293
00:15:04,290 --> 00:15:11,509
side with this structure<font color="#CCCCCC"> I</font><font color="#E5E5E5"> always look</font>

294
00:15:07,350 --> 00:15:15,209
at<font color="#E5E5E5"> the top element and the upper part of</font>

295
00:15:11,509 --> 00:15:16,350
this tree is<font color="#E5E5E5"> actually fitting into level</font>

296
00:15:15,209 --> 00:15:19,609
<font color="#E5E5E5">one cache of a CPU</font>

297
00:15:16,350 --> 00:15:22,260
and a bit<font color="#CCCCCC"> more fits</font><font color="#E5E5E5"> into level</font><font color="#CCCCCC"> 2 cache</font>

298
00:15:19,610 --> 00:15:26,190
<font color="#E5E5E5">that means I have super fast data access</font>

299
00:15:22,260 --> 00:15:30,630
on the top of the tree<font color="#E5E5E5"> and there I can</font>

300
00:15:26,190 --> 00:15:33,150
do a good sorting on a large<font color="#E5E5E5"> data</font><font color="#CCCCCC"> set</font><font color="#E5E5E5"> so</font>

301
00:15:30,630 --> 00:15:37,189
with this algorithm<font color="#CCCCCC"> you can</font><font color="#E5E5E5"> actually get</font>

302
00:15:33,150 --> 00:15:40,819
all your 32 CPUs working on<font color="#CCCCCC"> 100%</font>

303
00:15:37,190 --> 00:15:43,260
utilization<font color="#E5E5E5"> on sorting a huge data set</font>

304
00:15:40,820 --> 00:15:47,180
which is the<font color="#E5E5E5"> desired</font><font color="#CCCCCC"> resolution to get</font>

305
00:15:43,260 --> 00:15:50,220
<font color="#CCCCCC">fast sorting because nearly all</font>

306
00:15:47,180 --> 00:15:58,680
comparisons hit level 1 all over 2

307
00:15:50,220 --> 00:16:02,360
caches next problem<font color="#E5E5E5"> log structured most</font>

308
00:15:58,680 --> 00:16:06,839
merge trees<font color="#CCCCCC"> so the problem is</font><font color="#E5E5E5"> people</font>

309
00:16:02,360 --> 00:16:11,580
rightfully<font color="#CCCCCC"> expect that a data store can</font>

310
00:16:06,840 --> 00:16:15,300
do fast writes<font color="#E5E5E5"> so why should my</font><font color="#CCCCCC"> register</font>

311
00:16:11,580 --> 00:16:17,220
<font color="#E5E5E5">be slower than writing to</font><font color="#CCCCCC"> ram but at the</font>

312
00:16:15,300 --> 00:16:20,760
same time should<font color="#CCCCCC"> be able</font><font color="#E5E5E5"> to hold more</font>

313
00:16:17,220 --> 00:16:22,770
data than<font color="#CCCCCC"> Ram it should work</font><font color="#E5E5E5"> well with</font>

314
00:16:20,760 --> 00:16:27,300
SSDs or spinning<font color="#E5E5E5"> disks or whatever</font>

315
00:16:22,770 --> 00:16:29,189
<font color="#E5E5E5">Hardware I have it should work should</font>

316
00:16:27,300 --> 00:16:30,959
have<font color="#CCCCCC"> these fast bug inserts so I have</font>

317
00:16:29,190 --> 00:16:34,890
large<font color="#E5E5E5"> data set and want to push it in as</font>

318
00:16:30,960 --> 00:16:39,570
fast as possible and of course<font color="#E5E5E5"> I want to</font>

319
00:16:34,890 --> 00:16:41,310
have super fast reads especially if<font color="#E5E5E5"> my</font>

320
00:16:39,570 --> 00:16:44,100
hot set so the majority<font color="#E5E5E5"> of the</font><font color="#CCCCCC"> data</font><font color="#E5E5E5"> that</font>

321
00:16:41,310 --> 00:16:47,069
<font color="#E5E5E5">I'm using in</font><font color="#CCCCCC"> my application</font><font color="#E5E5E5"> fits into</font>

322
00:16:44,100 --> 00:16:52,110
main memory<font color="#E5E5E5"> why should my application be</font>

323
00:16:47,070 --> 00:16:55,920
slower than<font color="#E5E5E5"> this speed well how can</font><font color="#CCCCCC"> we</font>

324
00:16:52,110 --> 00:16:58,140
do this<font color="#E5E5E5"> so traditional</font><font color="#CCCCCC"> b-tree based</font>

325
00:16:55,920 --> 00:17:01,709
structures<font color="#E5E5E5"> like we have in relational</font>

326
00:16:58,140 --> 00:17:06,270
<font color="#CCCCCC">databases often</font><font color="#E5E5E5"> fail to</font><font color="#CCCCCC"> deliver</font><font color="#E5E5E5"> the</font>

327
00:17:01,710 --> 00:17:08,640
latest<font color="#CCCCCC"> - so bug inserts</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> Beast v3</font>

328
00:17:06,270 --> 00:17:10,199
structure actually<font color="#E5E5E5"> has some drawbacks</font>

329
00:17:08,640 --> 00:17:13,709
there<font color="#CCCCCC"> when</font><font color="#E5E5E5"> we try to insert a lot of</font>

330
00:17:10,199 --> 00:17:16,020
data into<font color="#CCCCCC"> different layers</font><font color="#E5E5E5"> and they</font>

331
00:17:13,709 --> 00:17:18,240
don't provide super fast access if the

332
00:17:16,020 --> 00:17:21,560
main memory<font color="#E5E5E5"> doesn't if the main or the</font>

333
00:17:18,240 --> 00:17:21,560
<font color="#E5E5E5">hot set does</font><font color="#CCCCCC"> not fit into main memory</font>

334
00:17:22,619 --> 00:17:27,799
how could we do that<font color="#E5E5E5"> so the solution is</font>

335
00:17:25,140 --> 00:17:32,690
<font color="#E5E5E5">the</font><font color="#CCCCCC"> so called log</font><font color="#E5E5E5"> structure merge tree</font>

336
00:17:27,799 --> 00:17:35,520
it's a several<font color="#E5E5E5"> layered or level approach</font>

337
00:17:32,690 --> 00:17:40,620
<font color="#E5E5E5">so you can define how</font><font color="#CCCCCC"> many</font><font color="#E5E5E5"> levels</font><font color="#CCCCCC"> I want</font>

338
00:17:35,520 --> 00:17:44,070
to have in the first<font color="#E5E5E5"> level</font><font color="#CCCCCC"> we have like</font>

339
00:17:40,620 --> 00:17:47,789
short blocks of data<font color="#E5E5E5"> all of them are so</font>

340
00:17:44,070 --> 00:17:51,658
are sorted but these are short enough<font color="#E5E5E5"> to</font>

341
00:17:47,789 --> 00:17:55,679
<font color="#E5E5E5">fit into the level</font><font color="#CCCCCC"> two cache or</font><font color="#E5E5E5"> into</font>

342
00:17:51,659 --> 00:17:58,350
<font color="#CCCCCC">like level three cache</font><font color="#E5E5E5"> but not larger so</font>

343
00:17:55,679 --> 00:18:01,080
we<font color="#CCCCCC"> can easily or fastly write to those</font>

344
00:17:58,350 --> 00:18:03,029
things<font color="#E5E5E5"> and of course they have to</font><font color="#CCCCCC"> be</font>

345
00:18:01,080 --> 00:18:07,320
<font color="#E5E5E5">sorted with the algorithm</font><font color="#CCCCCC"> that I have</font>

346
00:18:03,029 --> 00:18:09,630
presented before as soon<font color="#E5E5E5"> as we run out</font>

347
00:18:07,320 --> 00:18:12,629
of<font color="#E5E5E5"> these things we need</font><font color="#CCCCCC"> to do a</font>

348
00:18:09,630 --> 00:18:14,940
compaction task<font color="#E5E5E5"> and a compaction task</font>

349
00:18:12,630 --> 00:18:15,830
will take<font color="#CCCCCC"> a couple</font><font color="#E5E5E5"> of these blocks in</font>

350
00:18:14,940 --> 00:18:20,059
level zero

351
00:18:15,830 --> 00:18:23,879
merge them together<font color="#E5E5E5"> into larger blocks</font>

352
00:18:20,059 --> 00:18:26,250
which are<font color="#E5E5E5"> still sorted and push them</font>

353
00:18:23,880 --> 00:18:28,500
<font color="#CCCCCC">down on level one so level one is larger</font>

354
00:18:26,250 --> 00:18:32,010
but we know<font color="#E5E5E5"> the large block is sorted</font>

355
00:18:28,500 --> 00:18:35,039
<font color="#E5E5E5">and as these fill up we pull it down to</font>

356
00:18:32,010 --> 00:18:37,429
level<font color="#E5E5E5"> two again much larger</font><font color="#CCCCCC"> still sorted</font>

357
00:18:35,039 --> 00:18:40,080
and so on and so on and<font color="#CCCCCC"> so on</font>

358
00:18:37,429 --> 00:18:42,090
however this push<font color="#E5E5E5"> that push down can</font>

359
00:18:40,080 --> 00:18:47,039
happen in a<font color="#E5E5E5"> background</font><font color="#CCCCCC"> thread so it</font>

360
00:18:42,090 --> 00:18:49,500
doesn't block any<font color="#E5E5E5"> ongoing work right can</font>

361
00:18:47,039 --> 00:18:52,230
be<font color="#CCCCCC"> done in level zero</font><font color="#E5E5E5"> so it's pretty</font>

362
00:18:49,500 --> 00:18:59,039
fast<font color="#E5E5E5"> because</font><font color="#CCCCCC"> that is main memory</font><font color="#E5E5E5"> mostly</font>

363
00:18:52,230 --> 00:19:01,380
a bit<font color="#CCCCCC"> backed up on disk of course and so</font>

364
00:18:59,039 --> 00:19:03,899
there<font color="#E5E5E5"> I we have fast write fast writes</font>

365
00:19:01,380 --> 00:19:06,210
we<font color="#E5E5E5"> have a good compaction going down</font>

366
00:19:03,899 --> 00:19:10,529
there<font color="#E5E5E5"> if you</font><font color="#CCCCCC"> want to</font><font color="#E5E5E5"> search something in</font>

367
00:19:06,210 --> 00:19:13,559
here logarithmic scale<font color="#E5E5E5"> however in</font>

368
00:19:10,529 --> 00:19:15,600
addition<font color="#E5E5E5"> to these sorted blocks we</font>

369
00:19:13,559 --> 00:19:18,450
<font color="#E5E5E5">insert something</font><font color="#CCCCCC"> which is called a bloom</font>

370
00:19:15,600 --> 00:19:22,168
filter<font color="#E5E5E5"> or the</font><font color="#CCCCCC"> more modern version a</font>

371
00:19:18,450 --> 00:19:25,559
cuckoo filter<font color="#E5E5E5"> a cuckoo filter is the</font>

372
00:19:22,169 --> 00:19:28,350
persistent data structure which you<font color="#E5E5E5"> can</font>

373
00:19:25,559 --> 00:19:31,428
<font color="#E5E5E5">ask I have</font><font color="#CCCCCC"> a key in my hand do you know</font>

374
00:19:28,350 --> 00:19:34,259
if this key is thought in<font color="#CCCCCC"> your block and</font>

375
00:19:31,429 --> 00:19:37,169
the thing

376
00:19:34,259 --> 00:19:42,179
should answer yes<font color="#E5E5E5"> or no but it is</font>

377
00:19:37,169 --> 00:19:46,289
allowed to<font color="#E5E5E5"> lie but only in one certain</font>

378
00:19:42,179 --> 00:19:49,259
case<font color="#E5E5E5"> so if the bloom filter says no I</font>

379
00:19:46,289 --> 00:19:51,480
<font color="#E5E5E5">don't know this data set then it is</font>

380
00:19:49,259 --> 00:19:57,720
guaranteed<font color="#CCCCCC"> that it</font><font color="#E5E5E5"> is not inside this</font>

381
00:19:51,480 --> 00:20:02,789
block<font color="#E5E5E5"> if it says yes then it may</font><font color="#CCCCCC"> not be</font>

382
00:19:57,720 --> 00:20:03,359
in there but this<font color="#E5E5E5"> is not as bad</font><font color="#CCCCCC"> as it</font>

383
00:20:02,789 --> 00:20:06,029
sounds

384
00:20:03,359 --> 00:20:08,039
because the thing<font color="#CCCCCC"> is if I need to find a</font>

385
00:20:06,029 --> 00:20:11,249
<font color="#E5E5E5">certain data set I would start at level</font>

386
00:20:08,039 --> 00:20:12,720
<font color="#CCCCCC">0</font><font color="#E5E5E5"> ask either search in here directly</font>

387
00:20:11,249 --> 00:20:16,529
because<font color="#CCCCCC"> we on main memory or asked the</font>

388
00:20:12,720 --> 00:20:17,970
bloom filter<font color="#CCCCCC"> and most likely only</font><font color="#E5E5E5"> one of</font>

389
00:20:16,529 --> 00:20:20,009
these things<font color="#E5E5E5"> would say yeah probably</font>

390
00:20:17,970 --> 00:20:23,730
<font color="#CCCCCC">need to scan my block because I may have</font>

391
00:20:20,009 --> 00:20:27,359
<font color="#E5E5E5">the data if you don't find it here you</font>

392
00:20:23,730 --> 00:20:29,609
just go down and most<font color="#E5E5E5"> of the time only</font>

393
00:20:27,359 --> 00:20:31,918
<font color="#CCCCCC">one</font><font color="#E5E5E5"> of them will</font><font color="#CCCCCC"> say probably I have it</font>

394
00:20:29,609 --> 00:20:33,269
and<font color="#E5E5E5"> then the further you go down the</font>

395
00:20:31,919 --> 00:20:36,239
lower the chances is because you

396
00:20:33,269 --> 00:20:39,119
increase<font color="#E5E5E5"> the bloom filter however is it</font>

397
00:20:36,239 --> 00:20:40,559
if a data set is not stored at all it's

398
00:20:39,119 --> 00:20:42,330
actually<font color="#E5E5E5"> quite fast to find that out</font>

399
00:20:40,559 --> 00:20:43,769
because<font color="#E5E5E5"> all the bloom filters which are</font>

400
00:20:42,330 --> 00:20:50,759
fast would say no I don't<font color="#E5E5E5"> know the data</font>

401
00:20:43,769 --> 00:20:53,070
set<font color="#E5E5E5"> I as far</font><font color="#CCCCCC"> as</font><font color="#E5E5E5"> I know is constant time</font>

402
00:20:50,759 --> 00:20:56,960
<font color="#E5E5E5">plus memory access so because it's</font><font color="#CCCCCC"> hash</font>

403
00:20:53,070 --> 00:20:59,879
<font color="#CCCCCC">based but it doesn't have this</font>

404
00:20:56,960 --> 00:21:01,679
logarithmic thought<font color="#E5E5E5"> search which you</font>

405
00:20:59,879 --> 00:21:04,799
would have<font color="#CCCCCC"> if you ask inside the data</font>

406
00:21:01,679 --> 00:21:06,450
<font color="#E5E5E5">and the next thing</font><font color="#CCCCCC"> is the bloom filter</font>

407
00:21:04,799 --> 00:21:09,418
<font color="#CCCCCC">is small enough</font><font color="#E5E5E5"> to put into main memory</font>

408
00:21:06,450 --> 00:21:17,960
although<font color="#E5E5E5"> this sorted list of documents</font>

409
00:21:09,419 --> 00:21:20,970
<font color="#CCCCCC">may be like</font><font color="#E5E5E5"> 2 terabytes long so summary</font>

410
00:21:17,960 --> 00:21:24,029
the first<font color="#CCCCCC"> writes</font><font color="#E5E5E5"> go into these mem</font>

411
00:21:20,970 --> 00:21:27,720
tables which<font color="#E5E5E5"> is</font><font color="#CCCCCC"> level 0 so in memory</font><font color="#E5E5E5"> map</font>

412
00:21:24,029 --> 00:21:30,119
memory<font color="#E5E5E5"> files most likely all files are</font>

413
00:21:27,720 --> 00:21:32,940
sorted<font color="#CCCCCC"> oh and I forgot all</font><font color="#E5E5E5"> of them are</font>

414
00:21:30,119 --> 00:21:35,220
you immutable so as<font color="#E5E5E5"> soon as I have</font>

415
00:21:32,940 --> 00:21:38,609
pushed something<font color="#E5E5E5"> down into level 1 it</font>

416
00:21:35,220 --> 00:21:41,399
stays immutable<font color="#E5E5E5"> thereby I can super</font>

417
00:21:38,609 --> 00:21:44,119
<font color="#CCCCCC">easily catch the bloom filters cause the</font>

418
00:21:41,399 --> 00:21:44,119
answer will never change

419
00:21:44,270 --> 00:21:50,330
mergesort can be used<font color="#E5E5E5"> if I push them</font>

420
00:21:46,490 --> 00:21:53,980
down<font color="#E5E5E5"> so we have a pretty fast algorithm</font>

421
00:21:50,330 --> 00:21:56,409
to create<font color="#CCCCCC"> sorted set of the lower layers</font>

422
00:21:53,980 --> 00:22:00,020
<font color="#CCCCCC">alrights</font><font color="#E5E5E5"> only have sequential i/o</font>

423
00:21:56,410 --> 00:22:02,809
because<font color="#E5E5E5"> on level</font><font color="#CCCCCC"> 1 or</font><font color="#E5E5E5"> level 0 the</font>

424
00:22:00,020 --> 00:22:07,300
members are just<font color="#E5E5E5"> depend maybe I have to</font>

425
00:22:02,809 --> 00:22:10,040
<font color="#E5E5E5">resort on pushing it down a level</font><font color="#CCCCCC"> 1 and</font>

426
00:22:07,300 --> 00:22:11,389
for the<font color="#E5E5E5"> other ones I always know I have</font>

427
00:22:10,040 --> 00:22:13,159
the first element the second element the

428
00:22:11,390 --> 00:22:14,960
<font color="#CCCCCC">third element and</font><font color="#E5E5E5"> I actually know how</font>

429
00:22:13,160 --> 00:22:17,920
large<font color="#E5E5E5"> the file will be because I know</font>

430
00:22:14,960 --> 00:22:20,210
both blocks<font color="#E5E5E5"> how large they are</font>

431
00:22:17,920 --> 00:22:23,690
then we have bloom filters or<font color="#E5E5E5"> cuckoo</font>

432
00:22:20,210 --> 00:22:25,880
filters for fast<font color="#E5E5E5"> reads so we get a good</font>

433
00:22:23,690 --> 00:22:28,550
write throughput because<font color="#CCCCCC"> we write</font><font color="#E5E5E5"> to</font>

434
00:22:25,880 --> 00:22:31,760
main<font color="#E5E5E5"> memory and reasonable read</font>

435
00:22:28,550 --> 00:22:34,580
performance<font color="#CCCCCC"> of course</font><font color="#E5E5E5"> these things will</font>

436
00:22:31,760 --> 00:22:35,990
be slower then<font color="#E5E5E5"> putting everything into</font>

437
00:22:34,580 --> 00:22:38,300
main memory and<font color="#E5E5E5"> have</font><font color="#CCCCCC"> n hash and eggs on</font>

438
00:22:35,990 --> 00:22:40,429
<font color="#E5E5E5">top of it but they are made for the</font>

439
00:22:38,300 --> 00:22:46,100
condition<font color="#CCCCCC"> that your data set is larger</font>

440
00:22:40,429 --> 00:22:48,350
<font color="#E5E5E5">than your main memory and as they are so</font>

441
00:22:46,100 --> 00:22:51,649
good they are<font color="#E5E5E5"> used in a very large</font>

442
00:22:48,350 --> 00:22:55,178
<font color="#E5E5E5">amount of databases so in BigTable</font>

443
00:22:51,650 --> 00:22:58,850
Cassandra HBase<font color="#CCCCCC"> in flux level DB Mongo</font>

444
00:22:55,179 --> 00:23:02,270
<font color="#E5E5E5">Arango DB rocks DB sequel</font><font color="#CCCCCC"> ID and memory</font>

445
00:22:58,850 --> 00:23:07,428
<font color="#E5E5E5">B uses them by</font><font color="#CCCCCC"> Avaya Tiger so a lot of</font>

446
00:23:02,270 --> 00:23:11,090
databases have this technique next

447
00:23:07,429 --> 00:23:13,580
problem so the last two we had sorting

448
00:23:11,090 --> 00:23:15,649
<font color="#CCCCCC">block structured merge trees were</font>

449
00:23:13,580 --> 00:23:19,490
important<font color="#CCCCCC"> for a single</font><font color="#E5E5E5"> node they were</font>

450
00:23:15,650 --> 00:23:23,570
not for distribution<font color="#E5E5E5"> now let's move back</font>

451
00:23:19,490 --> 00:23:26,840
to distribution distribution we have

452
00:23:23,570 --> 00:23:32,870
<font color="#E5E5E5">several machines each machine has its</font>

453
00:23:26,840 --> 00:23:38,379
own clock<font color="#E5E5E5"> and with the probability close</font>

454
00:23:32,870 --> 00:23:38,379
to<font color="#E5E5E5"> 100% those clocks are out of sync</font><font color="#CCCCCC"> so</font>

455
00:23:39,309 --> 00:23:44,899
<font color="#CCCCCC">that means whenever we put</font><font color="#E5E5E5"> a time stamp</font>

456
00:23:42,050 --> 00:23:46,940
<font color="#E5E5E5">into</font><font color="#CCCCCC"> our document and move it over</font><font color="#E5E5E5"> to a</font>

457
00:23:44,900 --> 00:23:48,830
different server this different server

458
00:23:46,940 --> 00:23:52,940
<font color="#CCCCCC">will say oh this thing is kind</font><font color="#E5E5E5"> of old or</font>

459
00:23:48,830 --> 00:23:55,669
it's in<font color="#E5E5E5"> the future which</font><font color="#CCCCCC"> is bad</font><font color="#E5E5E5"> so we</font>

460
00:23:52,940 --> 00:24:01,130
need a<font color="#E5E5E5"> solution for this</font>

461
00:23:55,670 --> 00:24:04,250
and general relativity poses that<font color="#CCCCCC"> we</font>

462
00:24:01,130 --> 00:24:05,810
have those things<font color="#E5E5E5"> so documents in the</font>

463
00:24:04,250 --> 00:24:08,260
future and we don't<font color="#E5E5E5"> know which</font><font color="#CCCCCC"> is the</font>

464
00:24:05,810 --> 00:24:11,149
exact order<font color="#E5E5E5"> of incoming</font><font color="#CCCCCC"> events</font><font color="#E5E5E5"> in</font>

465
00:24:08,260 --> 00:24:14,930
practice clock skew happens<font color="#E5E5E5"> so we have</font>

466
00:24:11,150 --> 00:24:17,270
off of a<font color="#E5E5E5"> couple of milliseconds</font><font color="#CCCCCC"> so in in</font>

467
00:24:14,930 --> 00:24:19,730
theory<font color="#E5E5E5"> this is</font><font color="#CCCCCC"> around 20 30 milliseconds</font>

468
00:24:17,270 --> 00:24:23,030
<font color="#E5E5E5">that we have in clock skew even if we do</font>

469
00:24:19,730 --> 00:24:27,320
<font color="#E5E5E5">all these networks clock synchronization</font>

470
00:24:23,030 --> 00:24:29,690
protocols if you are<font color="#E5E5E5"> Google or you have</font>

471
00:24:27,320 --> 00:24:31,370
the same amount<font color="#E5E5E5"> of money you can</font>

472
00:24:29,690 --> 00:24:33,320
actually buy atomic clocks<font color="#E5E5E5"> and put them</font>

473
00:24:31,370 --> 00:24:36,649
in<font color="#E5E5E5"> every of your machines so you get</font>

474
00:24:33,320 --> 00:24:38,810
that little<font color="#E5E5E5"> bit closer</font><font color="#CCCCCC"> this is the thing</font>

475
00:24:36,650 --> 00:24:40,370
they did with spanner so then you can

476
00:24:38,810 --> 00:24:43,669
<font color="#E5E5E5">actually rely on the clock of the</font>

477
00:24:40,370 --> 00:24:47,330
<font color="#CCCCCC">machine more</font><font color="#E5E5E5"> or less</font><font color="#CCCCCC"> and the network</font>

478
00:24:43,670 --> 00:24:49,580
time protocol helps to do like the

479
00:24:47,330 --> 00:24:52,460
<font color="#E5E5E5">arbitrary</font><font color="#CCCCCC"> man hardware to get it down to</font>

480
00:24:49,580 --> 00:25:01,220
<font color="#E5E5E5">20 milliseconds but still there's there</font>

481
00:24:52,460 --> 00:25:03,260
<font color="#E5E5E5">is a clock skew yes please yeah there is</font>

482
00:25:01,220 --> 00:25:05,870
still there's a network delay between

483
00:25:03,260 --> 00:25:07,910
<font color="#E5E5E5">all your</font><font color="#CCCCCC"> local</font><font color="#E5E5E5"> service so it may be a</font>

484
00:25:05,870 --> 00:25:13,820
bit smaller than but still you<font color="#E5E5E5"> will have</font>

485
00:25:07,910 --> 00:25:15,200
clocks keys you're welcome and of course

486
00:25:13,820 --> 00:25:17,300
<font color="#E5E5E5">this thing is also designed</font><font color="#CCCCCC"> for data</font>

487
00:25:15,200 --> 00:25:19,160
<font color="#E5E5E5">center</font><font color="#CCCCCC"> to data center</font><font color="#E5E5E5"> replication and</font>

488
00:25:17,300 --> 00:25:22,850
cross data center functionality<font color="#CCCCCC"> works</font>

489
00:25:19,160 --> 00:25:25,130
there as well<font color="#CCCCCC"> so</font><font color="#E5E5E5"> because of all the</font>

490
00:25:22,850 --> 00:25:26,929
above-mentioned problems we cannot

491
00:25:25,130 --> 00:25:29,000
compare<font color="#CCCCCC"> timestamp</font><font color="#E5E5E5"> from different notes</font>

492
00:25:26,930 --> 00:25:31,610
<font color="#E5E5E5">so you can compare the timestamp of the</font>

493
00:25:29,000 --> 00:25:33,380
<font color="#E5E5E5">same note</font><font color="#CCCCCC"> but as soon as you try</font><font color="#E5E5E5"> to</font>

494
00:25:31,610 --> 00:25:36,110
<font color="#E5E5E5">compare time</font><font color="#CCCCCC"> sim from different notes</font>

495
00:25:33,380 --> 00:25:41,600
<font color="#E5E5E5">you will end up with</font><font color="#CCCCCC"> a broken ordering</font>

496
00:25:36,110 --> 00:25:43,729
of things why<font color="#E5E5E5"> would this help because in</font>

497
00:25:41,600 --> 00:25:47,209
most<font color="#CCCCCC"> cases you actually want to have</font>

498
00:25:43,730 --> 00:25:49,670
this real order of events<font color="#E5E5E5"> what happens</font>

499
00:25:47,210 --> 00:25:52,510
one after the other<font color="#CCCCCC"> assume</font><font color="#E5E5E5"> to you the</font>

500
00:25:49,670 --> 00:25:54,680
two users updating the same document

501
00:25:52,510 --> 00:25:56,390
probably it's good to know who was<font color="#E5E5E5"> the</font>

502
00:25:54,680 --> 00:25:59,600
<font color="#CCCCCC">first one</font><font color="#E5E5E5"> and who should get a conflict</font>

503
00:25:56,390 --> 00:26:01,520
if you have like master master

504
00:25:59,600 --> 00:26:03,590
replication<font color="#CCCCCC"> writers here</font><font color="#E5E5E5"> writers there</font>

505
00:26:01,520 --> 00:26:08,679
it's unclear who was actually<font color="#CCCCCC"> the first</font>

506
00:26:03,590 --> 00:26:12,789
<font color="#E5E5E5">one so for conflict</font><font color="#CCCCCC"> resolution</font>

507
00:26:08,679 --> 00:26:14,799
<font color="#E5E5E5">or</font><font color="#CCCCCC"> lock sorting or even for detection</font><font color="#E5E5E5"> of</font>

508
00:26:12,789 --> 00:26:16,419
<font color="#E5E5E5">network delays</font><font color="#CCCCCC"> so whenever you see oh</font>

509
00:26:14,799 --> 00:26:18,580
there was a short network outage of<font color="#E5E5E5"> a</font>

510
00:26:16,419 --> 00:26:21,419
second<font color="#E5E5E5"> you could see that because the</font>

511
00:26:18,580 --> 00:26:24,158
message was<font color="#CCCCCC"> actually a bit delayed</font>

512
00:26:21,419 --> 00:26:26,639
next thing that you<font color="#CCCCCC"> often use in</font>

513
00:26:24,159 --> 00:26:29,950
databases<font color="#E5E5E5"> is</font><font color="#CCCCCC"> so-called</font><font color="#E5E5E5"> time to live</font>

514
00:26:26,639 --> 00:26:33,008
easiest example<font color="#E5E5E5"> as a session so user</font>

515
00:26:29,950 --> 00:26:34,779
locks in and he should stay locked in

516
00:26:33,009 --> 00:26:36,519
for the<font color="#CCCCCC"> next two hours and if he doesn't</font>

517
00:26:34,779 --> 00:26:40,360
do anything<font color="#E5E5E5"> in the two hours the data</font>

518
00:26:36,519 --> 00:26:45,249
<font color="#E5E5E5">set should go</font><font color="#CCCCCC"> away how to implement</font><font color="#E5E5E5"> in</font>

519
00:26:40,360 --> 00:26:48,789
the distributed<font color="#CCCCCC"> system so what is the</font>

520
00:26:45,249 --> 00:26:52,779
idea for a solution so every computer

521
00:26:48,789 --> 00:26:54,009
has<font color="#CCCCCC"> the</font><font color="#E5E5E5"> local clock so it may not be</font>

522
00:26:52,779 --> 00:26:56,080
<font color="#E5E5E5">accurate</font>

523
00:26:54,009 --> 00:26:59,769
they may be<font color="#CCCCCC"> clock skews but we have one</font>

524
00:26:56,080 --> 00:27:06,428
<font color="#E5E5E5">and we use NDP's to synchronize so we</font>

525
00:26:59,769 --> 00:27:09,840
have like an upper<font color="#E5E5E5"> bound of delay so if</font>

526
00:27:06,429 --> 00:27:13,179
two events<font color="#CCCCCC"> on different machines I</font>

527
00:27:09,840 --> 00:27:15,668
<font color="#E5E5E5">actually linked by causality</font><font color="#CCCCCC"> so that</font>

528
00:27:13,179 --> 00:27:17,320
means I get an event<font color="#E5E5E5"> in here and because</font>

529
00:27:15,669 --> 00:27:20,529
<font color="#CCCCCC">of this event I had to fire a</font><font color="#E5E5E5"> different</font>

530
00:27:17,320 --> 00:27:23,710
event<font color="#E5E5E5"> on the other machine then the</font>

531
00:27:20,529 --> 00:27:28,509
<font color="#E5E5E5">course should have a smaller</font><font color="#CCCCCC"> timestamp</font>

532
00:27:23,710 --> 00:27:31,629
then the effect basically<font color="#E5E5E5"> user request</font>

533
00:27:28,509 --> 00:27:33,850
comes<font color="#E5E5E5"> in first timestamp I've read the</font>

534
00:27:31,629 --> 00:27:35,408
document<font color="#E5E5E5"> second timestamp and I send it</font>

535
00:27:33,850 --> 00:27:40,678
<font color="#E5E5E5">out then the first time stem should</font><font color="#CCCCCC"> be</font>

536
00:27:35,409 --> 00:27:45,279
smaller than the second time step and

537
00:27:40,679 --> 00:27:48,850
the causality<font color="#E5E5E5"> is a message is sent so</font>

538
00:27:45,279 --> 00:27:52,570
thereby we<font color="#E5E5E5"> sent a timestamp with every</font>

539
00:27:48,850 --> 00:27:55,149
message and then we have a hybrid<font color="#CCCCCC"> logic</font>

540
00:27:52,570 --> 00:27:57,939
<font color="#CCCCCC">o'clock</font><font color="#E5E5E5"> because it's a hybrid</font><font color="#CCCCCC"> of a</font>

541
00:27:55,149 --> 00:28:00,879
physical clock the one<font color="#CCCCCC"> that is attached</font>

542
00:27:57,940 --> 00:28:03,460
<font color="#CCCCCC">to the computer</font><font color="#E5E5E5"> and a logical clock</font>

543
00:28:00,879 --> 00:28:07,230
<font color="#E5E5E5">which is just a number which adds on top</font>

544
00:28:03,460 --> 00:28:09,639
of the logic of<font color="#E5E5E5"> the physical clock and</font>

545
00:28:07,230 --> 00:28:14,320
the idea is that<font color="#E5E5E5"> the hybrid logical</font>

546
00:28:09,639 --> 00:28:18,519
clock can always<font color="#E5E5E5"> return a value which is</font>

547
00:28:14,320 --> 00:28:22,059
<font color="#E5E5E5">larger</font><font color="#CCCCCC"> than</font><font color="#E5E5E5"> the local clock and the</font>

548
00:28:18,519 --> 00:28:25,550
largest<font color="#E5E5E5"> timestamp you have ever seen</font>

549
00:28:22,059 --> 00:28:28,240
so that means if<font color="#E5E5E5"> the other machine says</font>

550
00:28:25,550 --> 00:28:30,860
I'm already<font color="#CCCCCC"> five minutes in the future</font>

551
00:28:28,240 --> 00:28:32,900
<font color="#E5E5E5">then the</font><font color="#CCCCCC"> timestamp</font><font color="#E5E5E5"> the logical clock</font>

552
00:28:30,860 --> 00:28:35,030
<font color="#E5E5E5">will send out will be five minutes</font><font color="#CCCCCC"> in</font>

553
00:28:32,900 --> 00:28:40,670
the<font color="#E5E5E5"> future in comparison to your local</font>

554
00:28:35,030 --> 00:28:42,350
clock and therefore I will<font color="#CCCCCC"> just take or</font>

555
00:28:40,670 --> 00:28:45,880
<font color="#CCCCCC">the clock will just take the real</font>

556
00:28:42,350 --> 00:28:50,209
<font color="#CCCCCC">timestamp of the messages hitch has seen</font>

557
00:28:45,880 --> 00:28:51,890
<font color="#E5E5E5">plus it's a small fraction so that</font><font color="#CCCCCC"> this</font>

558
00:28:50,210 --> 00:28:53,900
time stem is actually larger than<font color="#E5E5E5"> the</font>

559
00:28:51,890 --> 00:28:58,880
<font color="#CCCCCC">logical times up from the</font><font color="#E5E5E5"> other machine</font>

560
00:28:53,900 --> 00:29:02,150
<font color="#E5E5E5">and eventually</font><font color="#CCCCCC"> over time the clocks will</font>

561
00:28:58,880 --> 00:29:03,950
synchronize again<font color="#E5E5E5"> and</font><font color="#CCCCCC"> thereby the</font><font color="#E5E5E5"> law</font>

562
00:29:02,150 --> 00:29:05,809
local clock<font color="#E5E5E5"> can actually catch up with</font>

563
00:29:03,950 --> 00:29:07,940
the largest<font color="#CCCCCC"> timestamp that I have seen</font>

564
00:29:05,809 --> 00:29:10,700
<font color="#E5E5E5">so there will be a small portion where</font>

565
00:29:07,940 --> 00:29:13,400
<font color="#CCCCCC">it</font><font color="#E5E5E5"> is off but the hybrid logical clock</font>

566
00:29:10,700 --> 00:29:15,830
actually<font color="#E5E5E5"> fixes this and then we have to</font>

567
00:29:13,400 --> 00:29:18,770
guarantee<font color="#E5E5E5"> that whenever I have two</font>

568
00:29:15,830 --> 00:29:21,860
events<font color="#E5E5E5"> that</font><font color="#CCCCCC"> have a causal causal</font>

569
00:29:18,770 --> 00:29:26,629
relation then I have an ordering<font color="#CCCCCC"> based</font>

570
00:29:21,860 --> 00:29:28,790
<font color="#E5E5E5">to the hybrid logical clock approach so</font>

571
00:29:26,630 --> 00:29:31,910
causality is preserved<font color="#CCCCCC"> and we have time</font>

572
00:29:28,790 --> 00:29:36,050
to catch<font color="#E5E5E5"> up</font><font color="#CCCCCC"> with the law the real time</font>

573
00:29:31,910 --> 00:29:38,360
<font color="#E5E5E5">eventually if you</font><font color="#CCCCCC"> want to read</font><font color="#E5E5E5"> more</font>

574
00:29:36,050 --> 00:29:39,980
details<font color="#CCCCCC"> a blog post</font><font color="#E5E5E5"> about this is</font>

575
00:29:38,360 --> 00:29:43,090
<font color="#E5E5E5">written down below so I have shared the</font>

576
00:29:39,980 --> 00:29:43,090
slides all<font color="#CCCCCC"> the links will be available</font>

577
00:29:43,990 --> 00:29:50,360
next topic<font color="#CCCCCC"> now I think</font><font color="#E5E5E5"> I'm good in time</font>

578
00:29:48,080 --> 00:29:50,510
<font color="#E5E5E5">right five minutes</font><font color="#CCCCCC"> right yeah that will</font>

579
00:29:50,360 --> 00:29:52,928
work

580
00:29:50,510 --> 00:29:55,220
so distributed<font color="#CCCCCC"> asset transactions</font>

581
00:29:52,929 --> 00:29:58,670
<font color="#E5E5E5">database world asset</font>

582
00:29:55,220 --> 00:30:01,720
first of all atomic<font color="#CCCCCC"> anti transaction</font>

583
00:29:58,670 --> 00:30:05,929
either works entirely<font color="#E5E5E5"> or not at all</font>

584
00:30:01,720 --> 00:30:08,990
consistent<font color="#E5E5E5"> so I see a consistent</font><font color="#CCCCCC"> state</font>

585
00:30:05,929 --> 00:30:11,240
when I start my crack<font color="#CCCCCC"> okay my my</font>

586
00:30:08,990 --> 00:30:13,610
transaction and if something happens<font color="#CCCCCC"> in</font>

587
00:30:11,240 --> 00:30:17,780
between<font color="#E5E5E5"> by other users</font><font color="#CCCCCC"> I don't see this</font>

588
00:30:13,610 --> 00:30:19,959
state isolated so concurrent

589
00:30:17,780 --> 00:30:22,370
transactions<font color="#E5E5E5"> don't see each other and</font>

590
00:30:19,960 --> 00:30:29,390
durable is whenever<font color="#E5E5E5"> I crash it's still</font>

591
00:30:22,370 --> 00:30:31,090
there<font color="#E5E5E5"> so all of them are doable if the</font>

592
00:30:29,390 --> 00:30:33,320
transactions happen one after<font color="#CCCCCC"> the other</font>

593
00:30:31,090 --> 00:30:34,730
<font color="#CCCCCC">because then I can</font><font color="#E5E5E5"> have an ordering and</font>

594
00:30:33,320 --> 00:30:37,460
I can see

595
00:30:34,730 --> 00:30:39,499
what is ongoing<font color="#E5E5E5"> but</font><font color="#CCCCCC"> we have more</font>

596
00:30:37,460 --> 00:30:42,320
machines<font color="#CCCCCC"> so they are not one after the</font>

597
00:30:39,499 --> 00:30:45,230
other<font color="#E5E5E5"> in</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> a muted system we have to</font>

598
00:30:42,320 --> 00:30:48,289
make<font color="#E5E5E5"> sure that</font><font color="#CCCCCC"> all nodes</font><font color="#E5E5E5"> agree on</font>

599
00:30:45,230 --> 00:30:51,230
whether the transaction has<font color="#E5E5E5"> happens for</font>

600
00:30:48,289 --> 00:30:53,720
atomicity<font color="#E5E5E5"> because then I can ask is this</font>

601
00:30:51,230 --> 00:30:57,409
<font color="#E5E5E5">if this transaction</font><font color="#CCCCCC"> that I see here</font><font color="#E5E5E5"> done</font>

602
00:30:53,720 --> 00:31:01,220
or<font color="#CCCCCC"> not how</font><font color="#E5E5E5"> can I create a consistent</font>

603
00:30:57,409 --> 00:31:05,269
snapshot across nodes for<font color="#E5E5E5"> consistency</font>

604
00:31:01,220 --> 00:31:08,149
<font color="#E5E5E5">and how to hide ongoing activities until</font>

605
00:31:05,269 --> 00:31:10,609
<font color="#E5E5E5">a commit for isolation</font><font color="#CCCCCC"> and how to handle</font>

606
00:31:08,149 --> 00:31:15,049
<font color="#E5E5E5">if one of the nodes is lost for</font>

607
00:31:10,609 --> 00:31:16,699
durability we have to take replication

608
00:31:15,049 --> 00:31:21,830
resilience and<font color="#E5E5E5"> failover into account</font>

609
00:31:16,700 --> 00:31:23,929
especially<font color="#CCCCCC"> for the last point what</font>

610
00:31:21,830 --> 00:31:26,178
happens if<font color="#CCCCCC"> my machine crashes and it</font>

611
00:31:23,929 --> 00:31:27,619
said it has committed<font color="#CCCCCC"> something then the</font>

612
00:31:26,179 --> 00:31:33,529
<font color="#CCCCCC">failover</font><font color="#E5E5E5"> machine should have committed</font>

613
00:31:27,619 --> 00:31:36,678
as well this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> whole topic</font>

614
00:31:33,529 --> 00:31:39,409
for like a week<font color="#CCCCCC"> of talks how to</font>

615
00:31:36,679 --> 00:31:41,029
<font color="#E5E5E5">implement that right so but with all the</font>

616
00:31:39,409 --> 00:31:42,859
<font color="#E5E5E5">things that we have</font><font color="#CCCCCC"> before we can</font>

617
00:31:41,029 --> 00:31:45,139
actually get<font color="#E5E5E5"> pretty close to these</font>

618
00:31:42,859 --> 00:31:47,899
<font color="#CCCCCC">guarantees so we need something that</font>

619
00:31:45,139 --> 00:31:51,229
agrees<font color="#E5E5E5"> on</font><font color="#CCCCCC"> the status on transactions</font><font color="#E5E5E5"> we</font>

620
00:31:47,899 --> 00:31:53,119
use<font color="#CCCCCC"> draft we use hydrological clock</font><font color="#E5E5E5"> to</font>

621
00:31:51,230 --> 00:31:56,980
get a timing ordering on all the

622
00:31:53,119 --> 00:32:00,158
transactions then we need failover<font color="#E5E5E5"> of</font>

623
00:31:56,980 --> 00:32:04,489
course I<font color="#E5E5E5"> won't go into details there</font><font color="#CCCCCC"> and</font>

624
00:32:00,159 --> 00:32:08,119
the last thing I missed isolation this

625
00:32:04,489 --> 00:32:11,600
again<font color="#CCCCCC"> is done via</font><font color="#E5E5E5"> this agreement on the</font>

626
00:32:08,119 --> 00:32:15,699
transactions so we could either use<font color="#E5E5E5"> the</font>

627
00:32:11,600 --> 00:32:18,830
raft<font color="#CCCCCC"> for like</font><font color="#E5E5E5"> everything</font><font color="#CCCCCC"> that happens</font>

628
00:32:15,700 --> 00:32:19,759
works<font color="#E5E5E5"> but the thing</font><font color="#CCCCCC"> is the raft protocol</font>

629
00:32:18,830 --> 00:32:22,609
is super slow

630
00:32:19,759 --> 00:32:24,230
it is super consistent<font color="#E5E5E5"> but super slow so</font>

631
00:32:22,609 --> 00:32:27,230
that<font color="#E5E5E5"> means your database won't be</font>

632
00:32:24,230 --> 00:32:29,419
scalable anymore so we need to find some

633
00:32:27,230 --> 00:32:31,700
<font color="#E5E5E5">kind of hack around it and we</font><font color="#CCCCCC"> just need</font>

634
00:32:29,419 --> 00:32:33,769
<font color="#E5E5E5">to agree on certain like snapshots</font><font color="#CCCCCC"> or</font>

635
00:32:31,700 --> 00:32:35,840
points in time which should<font color="#E5E5E5"> be</font>

636
00:32:33,769 --> 00:32:38,480
consistent<font color="#E5E5E5"> and then need to</font><font color="#CCCCCC"> find</font>

637
00:32:35,840 --> 00:32:41,330
something<font color="#CCCCCC"> which gets away with all</font><font color="#E5E5E5"> these</font>

638
00:32:38,480 --> 00:32:44,330
stuff in between<font color="#E5E5E5"> and because this</font><font color="#CCCCCC"> is so</font>

639
00:32:41,330 --> 00:32:46,668
hard<font color="#CCCCCC"> I just created a</font><font color="#E5E5E5"> list of which</font>

640
00:32:44,330 --> 00:32:48,889
distributed databases do it and which

641
00:32:46,669 --> 00:32:53,000
don't<font color="#E5E5E5"> and</font>

642
00:32:48,890 --> 00:32:55,210
most don't so<font color="#CCCCCC"> a Ranga</font><font color="#E5E5E5"> DB doesn't have</font>

643
00:32:53,000 --> 00:32:58,190
distributed<font color="#E5E5E5"> asset transactions yet</font>

644
00:32:55,210 --> 00:33:00,650
BigTable<font color="#CCCCCC"> couchdb</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> air Couchbase data</font>

645
00:32:58,190 --> 00:33:03,250
stacks and so on<font color="#E5E5E5"> so actually most of the</font>

646
00:33:00,650 --> 00:33:07,160
well-known databases don't<font color="#E5E5E5"> have it</font>

647
00:33:03,250 --> 00:33:09,260
cockroach DB claims to<font color="#E5E5E5"> have it so I</font>

648
00:33:07,160 --> 00:33:10,990
think they pretty much are<font color="#E5E5E5"> there I</font>

649
00:33:09,260 --> 00:33:14,300
haven't used<font color="#E5E5E5"> them in production yet</font>

650
00:33:10,990 --> 00:33:16,700
<font color="#E5E5E5">Google spanner claims to have it because</font>

651
00:33:14,300 --> 00:33:19,899
they use like<font color="#E5E5E5"> Google's atomic clocks and</font>

652
00:33:16,700 --> 00:33:23,140
<font color="#E5E5E5">don't have the issue with timings and</font>

653
00:33:19,900 --> 00:33:26,120
<font color="#CCCCCC">Arang the DB has a plan on how to do it</font>

654
00:33:23,140 --> 00:33:29,390
<font color="#E5E5E5">which is</font><font color="#CCCCCC"> ongoing work right now</font><font color="#E5E5E5"> so</font>

655
00:33:26,120 --> 00:33:36,800
<font color="#E5E5E5">sooner or later we will remove Arango DB</font>

656
00:33:29,390 --> 00:33:39,110
from here and<font color="#CCCCCC"> moved over</font><font color="#E5E5E5"> there and very</font>

657
00:33:36,800 --> 00:33:41,960
few of the distributed<font color="#E5E5E5"> engines promise</font>

658
00:33:39,110 --> 00:33:44,060
asset because it's so hard and<font color="#E5E5E5"> so</font><font color="#CCCCCC"> many</font>

659
00:33:41,960 --> 00:33:48,560
things can<font color="#CCCCCC"> go wrong</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> you have to use</font>

660
00:33:44,060 --> 00:33:49,879
<font color="#CCCCCC">a doozie design for failure</font><font color="#E5E5E5"> so the basic</font>

661
00:33:48,560 --> 00:33:52,429
idea<font color="#CCCCCC"> noose multi-version concurrency</font>

662
00:33:49,880 --> 00:33:54,920
control so we<font color="#E5E5E5"> can have multiple</font>

663
00:33:52,430 --> 00:33:58,850
revisions<font color="#E5E5E5"> and we just have to make</font><font color="#CCCCCC"> sure</font>

664
00:33:54,920 --> 00:34:00,320
who sees which revision right and

665
00:33:58,850 --> 00:34:02,959
replication decentralized and

666
00:34:00,320 --> 00:34:04,460
distributed<font color="#E5E5E5"> so without them being</font>

667
00:34:02,960 --> 00:34:08,750
<font color="#E5E5E5">visible because we haven't agreed them</font>

668
00:34:04,460 --> 00:34:13,850
to be<font color="#E5E5E5"> visible then we need some place</font>

669
00:34:08,750 --> 00:34:17,260
where<font color="#CCCCCC"> we</font><font color="#E5E5E5"> can do the switching and this</font>

670
00:34:13,850 --> 00:34:20,929
place needs<font color="#CCCCCC"> to be persistent</font><font color="#E5E5E5"> scaled out</font>

671
00:34:17,260 --> 00:34:23,240
replicated and resilient<font color="#E5E5E5"> and here we</font><font color="#CCCCCC"> are</font>

672
00:34:20,929 --> 00:34:26,360
<font color="#E5E5E5">actually by starting</font><font color="#CCCCCC"> over</font><font color="#E5E5E5"> here again</font>

673
00:34:23,239 --> 00:34:29,199
right<font color="#CCCCCC"> so we need a system that actually</font>

674
00:34:26,360 --> 00:34:33,110
solves<font color="#E5E5E5"> this issues to solve</font><font color="#CCCCCC"> this issues</font>

675
00:34:29,199 --> 00:34:34,279
<font color="#CCCCCC">never mind</font><font color="#E5E5E5"> this is a bit easier of a</font>

676
00:34:33,110 --> 00:34:36,560
problem<font color="#E5E5E5"> because we</font><font color="#CCCCCC"> have more control</font>

677
00:34:34,280 --> 00:34:40,000
<font color="#CCCCCC">available and you</font><font color="#E5E5E5"> can</font><font color="#CCCCCC"> reduce the</font><font color="#E5E5E5"> amount</font>

678
00:34:36,560 --> 00:34:40,000
<font color="#CCCCCC">of data that actually flows in there</font>

679
00:34:42,750 --> 00:34:47,500
so transaction visibility needs to be

680
00:34:45,399 --> 00:34:50,379
implemented<font color="#CCCCCC"> with multi-agency</font>

681
00:34:47,500 --> 00:34:53,260
concurrency control and<font color="#CCCCCC"> timestamps play</font>

682
00:34:50,379 --> 00:34:58,808
a crucial role<font color="#CCCCCC"> therefore have a logical</font>

683
00:34:53,260 --> 00:35:01,599
<font color="#E5E5E5">class that's it all the</font><font color="#CCCCCC"> links</font><font color="#E5E5E5"> if you</font>

684
00:34:58,809 --> 00:35:07,269
<font color="#CCCCCC">want to get into deeper details I will</font>

685
00:35:01,599 --> 00:35:09,849
be<font color="#E5E5E5"> around for this day and we are an</font>

686
00:35:07,269 --> 00:35:12,368
<font color="#E5E5E5">open source project</font><font color="#CCCCCC"> so if you like the</font>

687
00:35:09,849 --> 00:35:13,900
talk and<font color="#E5E5E5"> would like to support us it's</font>

688
00:35:12,369 --> 00:35:16,319
super important<font color="#CCCCCC"> for us if you like go to</font>

689
00:35:13,900 --> 00:35:20,079
github and click on please at a star

690
00:35:16,319 --> 00:35:22,730
because that will help<font color="#CCCCCC"> otherwise</font><font color="#E5E5E5"> I'm</font>

691
00:35:20,079 --> 00:35:31,199
open for questions<font color="#CCCCCC"> thank you very</font><font color="#E5E5E5"> much</font>

692
00:35:22,730 --> 00:35:31,199
[Applause]

693
00:35:46,140 --> 00:35:52,480
yes there is a small risk<font color="#E5E5E5"> of it</font><font color="#CCCCCC"> getting</font>

694
00:35:49,089 --> 00:35:54,759
<font color="#E5E5E5">into</font><font color="#CCCCCC"> the future and</font><font color="#E5E5E5"> however in practice</font>

695
00:35:52,480 --> 00:35:58,839
they will catch up<font color="#E5E5E5"> because of the NTP</font>

696
00:35:54,759 --> 00:36:01,029
protocol and I think we can push into

697
00:35:58,839 --> 00:36:05,440
the<font color="#E5E5E5"> future</font><font color="#CCCCCC"> like with a couple</font><font color="#E5E5E5"> of digits</font>

698
00:36:01,029 --> 00:36:07,420
<font color="#CCCCCC">I think</font><font color="#E5E5E5"> eight or so it will push at some</font>

699
00:36:05,440 --> 00:36:09,430
point<font color="#CCCCCC"> because there's the real timestamp</font>

700
00:36:07,420 --> 00:36:10,869
and<font color="#E5E5E5"> then you have this offset and the</font>

701
00:36:09,430 --> 00:36:12,519
offset can never overflow into<font color="#E5E5E5"> the real</font>

702
00:36:10,869 --> 00:36:24,190
<font color="#E5E5E5">timestamp and then at some</font><font color="#CCCCCC"> point you</font>

703
00:36:12,519 --> 00:36:27,879
<font color="#CCCCCC">actually get the real timestamp this so</font>

704
00:36:24,190 --> 00:36:30,549
the the question<font color="#CCCCCC"> is if the dihybrid</font>

705
00:36:27,880 --> 00:36:32,049
logical clock<font color="#CCCCCC"> dips you has proof that it</font>

706
00:36:30,549 --> 00:36:34,210
<font color="#CCCCCC">actually</font><font color="#E5E5E5"> gives you the real clock which</font>

707
00:36:32,049 --> 00:36:37,210
surprises this<font color="#E5E5E5"> and yes it is proven</font>

708
00:36:34,210 --> 00:36:39,430
written in<font color="#E5E5E5"> that blog</font><font color="#CCCCCC"> post so I can't</font>

709
00:36:37,210 --> 00:36:42,569
sketch the the proof<font color="#E5E5E5"> right now but yes</font>

710
00:36:39,430 --> 00:36:42,569
it's fundamentally proven

711
00:36:48,370 --> 00:36:52,810
so the question is if the consensus

712
00:36:50,770 --> 00:36:54,190
algorithm<font color="#E5E5E5"> is resilient against malicious</font>

713
00:36:52,810 --> 00:36:58,330
attacks

714
00:36:54,190 --> 00:37:00,670
I think the algorithm itself<font color="#CCCCCC"> not so</font>

715
00:36:58,330 --> 00:37:06,100
really so if you get into one of<font color="#CCCCCC"> these</font>

716
00:37:00,670 --> 00:37:07,990
players<font color="#E5E5E5"> it I don't know yeah so but the</font>

717
00:37:06,100 --> 00:37:09,430
thing<font color="#CCCCCC"> is</font><font color="#E5E5E5"> that this algorithm is like not</font>

718
00:37:07,990 --> 00:37:11,410
open<font color="#E5E5E5"> to</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> public it will be inside</font>

719
00:37:09,430 --> 00:37:13,540
<font color="#E5E5E5">your own network behind the firewall</font><font color="#CCCCCC"> and</font>

720
00:37:11,410 --> 00:37:25,509
if you are in there then you<font color="#CCCCCC"> probably</font>

721
00:37:13,540 --> 00:37:26,950
<font color="#E5E5E5">have easier targets yes please okay yeah</font>

722
00:37:25,510 --> 00:37:29,530
I forgot<font color="#E5E5E5"> to talk about this so what's</font>

723
00:37:26,950 --> 00:37:31,960
the driver to actually get a distributed

724
00:37:29,530 --> 00:37:34,660
system<font color="#E5E5E5"> into asset and the thing is</font>

725
00:37:31,960 --> 00:37:37,440
development experience because if you

726
00:37:34,660 --> 00:37:40,480
have asset guarantees<font color="#E5E5E5"> on the database</font>

727
00:37:37,440 --> 00:37:42,550
<font color="#E5E5E5">it's super easy compared ibly to write</font>

728
00:37:40,480 --> 00:37:45,010
the<font color="#CCCCCC"> application if you</font><font color="#E5E5E5"> don't have this</font>

729
00:37:42,550 --> 00:37:48,070
asset guarantees that<font color="#CCCCCC"> means you can end</font>

730
00:37:45,010 --> 00:37:49,840
up<font color="#CCCCCC"> with like lost data you have to make</font>

731
00:37:48,070 --> 00:37:51,160
sure<font color="#CCCCCC"> you write something and maybe if</font>

732
00:37:49,840 --> 00:37:53,110
you read it it's not there

733
00:37:51,160 --> 00:37:56,170
all these failover stuff you have to

734
00:37:53,110 --> 00:37:59,980
<font color="#E5E5E5">handle in your application then</font><font color="#CCCCCC"> you may</font>

735
00:37:56,170 --> 00:38:03,300
see like non<font color="#E5E5E5"> isolated things so gets</font>

736
00:37:59,980 --> 00:38:10,450
kind<font color="#E5E5E5"> of hard in the application then</font>

737
00:38:03,300 --> 00:38:12,250
<font color="#E5E5E5">yeah so</font><font color="#CCCCCC"> the question is if it isn't</font>

738
00:38:10,450 --> 00:38:14,910
<font color="#E5E5E5">easier to live with</font><font color="#CCCCCC"> all that things in</font>

739
00:38:12,250 --> 00:38:18,310
the application than it is for<font color="#E5E5E5"> asset</font>

740
00:38:14,910 --> 00:38:19,990
probably yes<font color="#E5E5E5"> but it means</font><font color="#CCCCCC"> shifting the</font>

741
00:38:18,310 --> 00:38:22,540
work from your shoulders<font color="#E5E5E5"> on our</font>

742
00:38:19,990 --> 00:38:32,549
shoulders which is pretty<font color="#CCCCCC"> desirable for</font>

743
00:38:22,540 --> 00:38:32,550
you so it's all<font color="#E5E5E5"> good oh sorry yeah</font>

744
00:38:42,770 --> 00:38:47,270
and so the question<font color="#E5E5E5"> is if those are the</font>

745
00:38:45,740 --> 00:38:49,790
<font color="#E5E5E5">only two databases out there in the</font>

746
00:38:47,270 --> 00:38:51,170
<font color="#E5E5E5">world then the answer is I must admit I</font>

747
00:38:49,790 --> 00:38:53,930
don't know<font color="#E5E5E5"> because I haven't created</font>

748
00:38:51,170 --> 00:38:56,810
this<font color="#E5E5E5"> taught myself and I would</font><font color="#CCCCCC"> have to</font>

749
00:38:53,930 --> 00:38:59,899
ask max now if he only included<font color="#CCCCCC"> the open</font>

750
00:38:56,810 --> 00:39:07,930
source or also<font color="#E5E5E5"> commercial ones sorry I</font>

751
00:38:59,900 --> 00:39:07,930
<font color="#CCCCCC">don't know right I think cockroaches</font>

752
00:39:11,520 --> 00:39:18,469
[Applause]

