1
00:00:05,060 --> 00:00:09,950
welcome to this last talk of the<font color="#E5E5E5"> Arab um</font>

2
00:00:07,610 --> 00:00:13,270
<font color="#CCCCCC">tool to in that room</font><font color="#E5E5E5"> my name is David</font>

3
00:00:09,950 --> 00:00:15,200
Newhouse<font color="#CCCCCC"> I work with software at MCS and</font>

4
00:00:13,270 --> 00:00:19,360
in this talk<font color="#E5E5E5"> I will</font>

5
00:00:15,200 --> 00:00:22,279
about how we use<font color="#CCCCCC"> at IBM at</font><font color="#E5E5E5"> this company</font>

6
00:00:19,360 --> 00:00:25,279
<font color="#E5E5E5">let's first just warm up with some</font><font color="#CCCCCC"> very</font>

7
00:00:22,279 --> 00:00:27,770
basic<font color="#CCCCCC"> LLVM stuff</font><font color="#E5E5E5"> how do you use at IBM</font>

8
00:00:25,279 --> 00:00:30,380
<font color="#E5E5E5">so if you have your software application</font>

9
00:00:27,770 --> 00:00:32,119
in some<font color="#CCCCCC"> high-level</font><font color="#E5E5E5"> code and you have a</font>

10
00:00:30,380 --> 00:00:34,519
target<font color="#CCCCCC"> architecture where you want to</font>

11
00:00:32,119 --> 00:00:37,519
run<font color="#E5E5E5"> it</font><font color="#CCCCCC"> then</font><font color="#E5E5E5"> you need</font><font color="#CCCCCC"> to compile</font><font color="#E5E5E5"> you take</font>

12
00:00:34,520 --> 00:00:40,070
<font color="#CCCCCC">LLVM</font><font color="#E5E5E5"> and what's happening inside that</font>

13
00:00:37,520 --> 00:00:43,100
IBM<font color="#CCCCCC"> is first you take a front-end which</font>

14
00:00:40,070 --> 00:00:45,770
<font color="#CCCCCC">can turn your application from your</font>

15
00:00:43,100 --> 00:00:48,250
favorite language<font color="#E5E5E5"> into an IBM assembly</font>

16
00:00:45,770 --> 00:00:51,290
<font color="#E5E5E5">or ir the intermediate representation</font>

17
00:00:48,250 --> 00:00:53,360
then you can use the array<font color="#CCCCCC"> VM</font><font color="#E5E5E5"> Midland to</font>

18
00:00:51,290 --> 00:00:56,480
optimize this intermediate

19
00:00:53,360 --> 00:00:59,300
representation code and then finally you

20
00:00:56,480 --> 00:01:01,610
<font color="#CCCCCC">take a back-end which targets the device</font>

21
00:00:59,300 --> 00:01:04,640
<font color="#E5E5E5">in architecture where you want to run</font>

22
00:01:01,610 --> 00:01:08,030
your<font color="#E5E5E5"> code on and this back-end will turn</font>

23
00:01:04,640 --> 00:01:10,399
<font color="#E5E5E5">the LLVM assembly into your targeted</font>

24
00:01:08,030 --> 00:01:13,850
architecture assembly code or binary

25
00:01:10,399 --> 00:01:15,799
executable code what this talk is about

26
00:01:13,850 --> 00:01:19,850
that how we want<font color="#E5E5E5"> to improve the</font>

27
00:01:15,799 --> 00:01:22,219
<font color="#CCCCCC">efficiency and</font><font color="#E5E5E5"> I will tell you if</font><font color="#CCCCCC"> our</font>

28
00:01:19,850 --> 00:01:24,829
efficiency in what sense<font color="#E5E5E5"> if you consider</font>

29
00:01:22,219 --> 00:01:27,678
<font color="#CCCCCC">an IBM assembly and</font><font color="#E5E5E5"> a typical</font><font color="#CCCCCC"> target</font>

30
00:01:24,829 --> 00:01:30,139
architecture<font color="#E5E5E5"> then there is a big gap the</font>

31
00:01:27,679 --> 00:01:31,999
backends needs to do<font color="#E5E5E5"> typically complex</font>

32
00:01:30,139 --> 00:01:34,639
translations there<font color="#E5E5E5"> is a big semantical</font>

33
00:01:31,999 --> 00:01:37,639
gap instruction set architectures are

34
00:01:34,639 --> 00:01:39,229
<font color="#E5E5E5">typically not designed with respect to</font>

35
00:01:37,639 --> 00:01:42,560
the compilers intermediate

36
00:01:39,229 --> 00:01:45,499
representation what we want<font color="#E5E5E5"> to do at MCS</font>

37
00:01:42,560 --> 00:01:47,689
is<font color="#CCCCCC"> lifting the instruction set</font>

38
00:01:45,499 --> 00:01:52,100
architecture closer to the<font color="#E5E5E5"> LLVM assembly</font>

39
00:01:47,689 --> 00:01:54,708
level so reducing the<font color="#E5E5E5"> gap and then we</font>

40
00:01:52,100 --> 00:01:59,689
use<font color="#E5E5E5"> another</font><font color="#CCCCCC"> vm back-end</font><font color="#E5E5E5"> to target this</font>

41
00:01:54,709 --> 00:02:02,959
architecture<font color="#E5E5E5"> so that's what the main</font>

42
00:01:59,689 --> 00:02:05,329
topic of<font color="#E5E5E5"> this talk would</font><font color="#CCCCCC"> be but first I</font>

43
00:02:02,959 --> 00:02:07,159
would<font color="#CCCCCC"> like to</font><font color="#E5E5E5"> very</font><font color="#CCCCCC"> briefly just</font><font color="#E5E5E5"> talk a</font>

44
00:02:05,329 --> 00:02:10,160
few words about the company itself what

45
00:02:07,159 --> 00:02:11,810
we<font color="#CCCCCC"> are doing then the</font><font color="#E5E5E5"> industry in</font>

46
00:02:10,160 --> 00:02:13,849
processing technology our<font color="#E5E5E5"> core</font>

47
00:02:11,810 --> 00:02:16,490
technology which we utilize to be able

48
00:02:13,849 --> 00:02:18,619
<font color="#E5E5E5">to reduce</font><font color="#CCCCCC"> this gap and then last but</font><font color="#E5E5E5"> not</font>

49
00:02:16,490 --> 00:02:21,530
least I<font color="#CCCCCC"> will also say a few words about</font>

50
00:02:18,620 --> 00:02:26,000
our tailor-made<font color="#CCCCCC"> instruction set we're at</font>

51
00:02:21,530 --> 00:02:28,640
IBM so<font color="#E5E5E5"> MC SEBI is a</font><font color="#CCCCCC"> Swedish</font>

52
00:02:26,000 --> 00:02:33,470
semiconductor SME<font color="#CCCCCC"> it's located in</font><font color="#E5E5E5"> the</font>

53
00:02:28,640 --> 00:02:36,829
<font color="#CCCCCC">no</font><font color="#E5E5E5"> stock on area we are working with our</font>

54
00:02:33,470 --> 00:02:41,810
own<font color="#E5E5E5"> proprietary processor core we sell</font>

55
00:02:36,830 --> 00:02:44,569
devices<font color="#E5E5E5"> modules the processor</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> see and</font>

56
00:02:41,810 --> 00:02:48,260
in the<font color="#E5E5E5"> future we plan to go</font><font color="#CCCCCC"> to sell IP</font>

57
00:02:44,569 --> 00:02:51,760
as well<font color="#E5E5E5"> the company has a history as</font>

58
00:02:48,260 --> 00:02:54,140
supplier of<font color="#E5E5E5"> network embedded controllers</font>

59
00:02:51,760 --> 00:02:55,940
with some<font color="#E5E5E5"> special features</font><font color="#CCCCCC"> these</font>

60
00:02:54,140 --> 00:02:58,819
<font color="#CCCCCC">pictures</font><font color="#E5E5E5"> are some of the actual</font>

61
00:02:55,940 --> 00:03:03,109
applications devices where our processor

62
00:02:58,819 --> 00:03:05,030
was used but now we want to retarget<font color="#E5E5E5"> our</font>

63
00:03:03,110 --> 00:03:08,989
processor for the<font color="#CCCCCC"> intent</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> things as we</font>

64
00:03:05,030 --> 00:03:11,090
see some good match for our values and

65
00:03:08,989 --> 00:03:16,370
using<font color="#E5E5E5"> that IBM is part of this</font>

66
00:03:11,090 --> 00:03:18,290
retargeting<font color="#CCCCCC"> as a device we want</font><font color="#E5E5E5"> to</font>

67
00:03:16,370 --> 00:03:20,630
provide<font color="#CCCCCC"> a</font><font color="#E5E5E5"> single controller solution for</font>

68
00:03:18,290 --> 00:03:23,959
IOT applications<font color="#E5E5E5"> that's the</font><font color="#CCCCCC"> in this</font>

69
00:03:20,630 --> 00:03:29,480
<font color="#E5E5E5">emblem it's a small handful application</font>

70
00:03:23,959 --> 00:03:31,940
or<font color="#E5E5E5"> device with some IO capabilities it</font>

71
00:03:29,480 --> 00:03:35,000
can be connected<font color="#E5E5E5"> directly to a CD</font>

72
00:03:31,940 --> 00:03:36,950
display and<font color="#E5E5E5"> the touch panel and the</font>

73
00:03:35,000 --> 00:03:38,600
different<font color="#E5E5E5"> IO capabilities can be used</font>

74
00:03:36,950 --> 00:03:42,828
with an extension board for which we

75
00:03:38,600 --> 00:03:45,620
have a<font color="#CCCCCC"> reference design software bias</font>

76
00:03:42,829 --> 00:03:48,079
which might be<font color="#CCCCCC"> more interesting</font><font color="#E5E5E5"> in this</font>

77
00:03:45,620 --> 00:03:50,840
<font color="#E5E5E5">session I would like first just to give</font>

78
00:03:48,079 --> 00:03:54,200
a very<font color="#E5E5E5"> high-level overview so you can</font>

79
00:03:50,840 --> 00:03:56,750
have our development<font color="#E5E5E5"> device and then you</font>

80
00:03:54,200 --> 00:03:57,950
<font color="#CCCCCC">develop your application code</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> we</font>

81
00:03:56,750 --> 00:04:00,760
<font color="#E5E5E5">support you with an eclipse-based</font>

82
00:03:57,950 --> 00:04:03,109
<font color="#E5E5E5">integrated development environment</font><font color="#CCCCCC"> you</font>

83
00:04:00,760 --> 00:04:06,109
<font color="#CCCCCC">can develop</font><font color="#E5E5E5"> your application in C and</font>

84
00:04:03,110 --> 00:04:09,110
C++<font color="#E5E5E5"> in which case b12 with</font><font color="#CCCCCC"> LLVM to</font>

85
00:04:06,110 --> 00:04:13,730
generate executable code and also we

86
00:04:09,110 --> 00:04:16,880
support<font color="#CCCCCC"> Java execution</font><font color="#E5E5E5"> alright that's</font>

87
00:04:13,730 --> 00:04:20,079
about the company but<font color="#E5E5E5"> don't forget this</font>

88
00:04:16,880 --> 00:04:23,630
topic is about<font color="#E5E5E5"> how to reduce the gap and</font>

89
00:04:20,079 --> 00:04:27,020
have a tailor-made<font color="#CCCCCC"> instruction set</font>

90
00:04:23,630 --> 00:04:28,340
architecture for<font color="#CCCCCC"> IBM</font><font color="#E5E5E5"> so first</font><font color="#CCCCCC"> I tell you</font>

91
00:04:27,020 --> 00:04:34,099
about the<font color="#E5E5E5"> technology which we use to</font>

92
00:04:28,340 --> 00:04:37,520
<font color="#CCCCCC">reduce</font><font color="#E5E5E5"> the semantic gap let's revisit</font>

93
00:04:34,100 --> 00:04:40,030
the the software<font color="#E5E5E5"> the software layers the</font>

94
00:04:37,520 --> 00:04:42,700
abstraction layers so

95
00:04:40,030 --> 00:04:44,530
we have the<font color="#CCCCCC"> m6 processor core which</font>

96
00:04:42,700 --> 00:04:47,860
supports and instructions at

97
00:04:44,530 --> 00:04:50,739
architecture<font color="#E5E5E5"> then you have your</font>

98
00:04:47,860 --> 00:04:55,390
application<font color="#E5E5E5"> code again which can be Java</font>

99
00:04:50,740 --> 00:04:57,460
or assembly C C++ and our instruction

100
00:04:55,390 --> 00:05:00,520
set support provides basically<font color="#E5E5E5"> two</font>

101
00:04:57,460 --> 00:05:05,409
instruction set<font color="#E5E5E5"> one we call ICJ test for</font>

102
00:05:00,520 --> 00:05:07,630
<font color="#CCCCCC">nicer for</font><font color="#E5E5E5"> LLVM and</font><font color="#CCCCCC"> i said i said</font><font color="#E5E5E5"> is for</font>

103
00:05:05,410 --> 00:05:10,480
<font color="#CCCCCC">IBM and IC j is an instruction set</font>

104
00:05:07,630 --> 00:05:13,750
architecture for<font color="#CCCCCC"> Java now I won't talk</font>

105
00:05:10,480 --> 00:05:19,270
more about Java<font color="#E5E5E5"> let's focus on the IBM</font>

106
00:05:13,750 --> 00:05:22,450
stuff here if you want to think about

107
00:05:19,270 --> 00:05:24,310
<font color="#E5E5E5">what are the main levels of abstraction</font>

108
00:05:22,450 --> 00:05:26,229
then usually<font color="#CCCCCC"> you say that yes we</font><font color="#E5E5E5"> have a</font>

109
00:05:24,310 --> 00:05:28,420
<font color="#E5E5E5">hardware the hardware provides us the</font>

110
00:05:26,230 --> 00:05:31,030
instruction set architecture<font color="#CCCCCC"> and then we</font>

111
00:05:28,420 --> 00:05:33,310
have<font color="#E5E5E5"> our software which</font><font color="#CCCCCC"> runs on these</font>

112
00:05:31,030 --> 00:05:35,469
<font color="#E5E5E5">instructions architecture but actually</font>

113
00:05:33,310 --> 00:05:37,960
there<font color="#CCCCCC"> is a let's say a forgotten layer</font>

114
00:05:35,470 --> 00:05:41,620
of abstraction<font color="#E5E5E5"> historically it was there</font>

115
00:05:37,960 --> 00:05:43,620
<font color="#E5E5E5">but nowadays it's not it's</font><font color="#CCCCCC"> it's very</font>

116
00:05:41,620 --> 00:05:48,910
<font color="#E5E5E5">hidden and and typically</font><font color="#CCCCCC"> not used much</font>

117
00:05:43,620 --> 00:05:50,950
<font color="#E5E5E5">that's microcode and actually micro code</font>

118
00:05:48,910 --> 00:05:52,420
makes it possible to<font color="#CCCCCC"> have a really</font>

119
00:05:50,950 --> 00:05:57,280
<font color="#E5E5E5">really tight control over what the</font>

120
00:05:52,420 --> 00:06:02,110
processor does so<font color="#CCCCCC"> I would like</font><font color="#E5E5E5"> to give</font>

121
00:05:57,280 --> 00:06:05,200
you a brief idea what micro code is so

122
00:06:02,110 --> 00:06:07,330
the processor has<font color="#CCCCCC"> a micro program the</font>

123
00:06:05,200 --> 00:06:12,250
micro program is a list of micro

124
00:06:07,330 --> 00:06:16,539
instructions<font color="#E5E5E5"> and each micro instruction</font>

125
00:06:12,250 --> 00:06:19,240
<font color="#E5E5E5">cost consists of fields separate fields</font>

126
00:06:16,540 --> 00:06:22,330
and each control field has a control

127
00:06:19,240 --> 00:06:24,580
value which directly controls the

128
00:06:22,330 --> 00:06:28,419
different<font color="#E5E5E5"> the behavior of the different</font>

129
00:06:24,580 --> 00:06:30,250
functional units<font color="#E5E5E5"> of the processor one of</font>

130
00:06:28,420 --> 00:06:34,270
the function unit<font color="#E5E5E5"> is the sequence</font>

131
00:06:30,250 --> 00:06:38,130
control which then decides which micro

132
00:06:34,270 --> 00:06:41,229
instruction to execute next so this<font color="#E5E5E5"> is a</font>

133
00:06:38,130 --> 00:06:45,790
very direct<font color="#CCCCCC"> close control</font><font color="#E5E5E5"> over the</font>

134
00:06:41,230 --> 00:06:47,950
<font color="#E5E5E5">features</font><font color="#CCCCCC"> of the hardware</font><font color="#E5E5E5"> and an</font>

135
00:06:45,790 --> 00:06:49,870
architecture<font color="#CCCCCC"> which operated by micro</font>

136
00:06:47,950 --> 00:06:52,450
code is physical and operational

137
00:06:49,870 --> 00:06:56,050
<font color="#CCCCCC">reentered hardware architecture</font>

138
00:06:52,450 --> 00:06:58,479
everything every step<font color="#E5E5E5"> in inside the</font>

139
00:06:56,050 --> 00:07:02,800
processor is directly controlled<font color="#CCCCCC"> by the</font>

140
00:06:58,480 --> 00:07:04,930
<font color="#E5E5E5">micro code which we</font><font color="#CCCCCC"> develop all right so</font>

141
00:07:02,800 --> 00:07:07,300
that's how<font color="#E5E5E5"> micro code works you have</font>

142
00:07:04,930 --> 00:07:09,700
some idea now<font color="#CCCCCC"> but what is it good for</font>

143
00:07:07,300 --> 00:07:13,060
<font color="#CCCCCC">there are a few</font><font color="#E5E5E5"> things which which we</font>

144
00:07:09,700 --> 00:07:14,650
value<font color="#E5E5E5"> in in micro coding first as</font><font color="#CCCCCC"> I</font>

145
00:07:13,060 --> 00:07:16,540
<font color="#CCCCCC">already mentioned</font><font color="#E5E5E5"> we have complete and</font>

146
00:07:14,650 --> 00:07:20,650
actually deterministic<font color="#E5E5E5"> control over but</font>

147
00:07:16,540 --> 00:07:22,630
the processor is<font color="#E5E5E5"> doing then how Hardware</font>

148
00:07:20,650 --> 00:07:24,640
the processor core can be minimal<font color="#CCCCCC"> since</font>

149
00:07:22,630 --> 00:07:30,040
all the complex control<font color="#CCCCCC"> logic is</font>

150
00:07:24,640 --> 00:07:32,440
implemented in micro code<font color="#E5E5E5"> so we there is</font>

151
00:07:30,040 --> 00:07:35,020
<font color="#E5E5E5">no need</font><font color="#CCCCCC"> for the</font><font color="#E5E5E5"> pipelines we don't have</font>

152
00:07:32,440 --> 00:07:37,000
cache hierarchy<font color="#CCCCCC"> out of order</font><font color="#E5E5E5"> and</font>

153
00:07:35,020 --> 00:07:42,280
speculative<font color="#E5E5E5"> execution</font><font color="#CCCCCC"> we don't have a</font>

154
00:07:37,000 --> 00:07:46,690
complex<font color="#E5E5E5"> Hardware state to maintain also</font>

155
00:07:42,280 --> 00:07:50,919
since we implement<font color="#E5E5E5"> different features</font><font color="#CCCCCC"> in</font>

156
00:07:46,690 --> 00:07:53,080
the micro code with direct<font color="#E5E5E5"> write control</font>

157
00:07:50,920 --> 00:07:56,230
it means that the utilization<font color="#E5E5E5"> of the</font>

158
00:07:53,080 --> 00:07:58,990
actual<font color="#CCCCCC"> Hardware can be maximized</font><font color="#E5E5E5"> so we</font>

159
00:07:56,230 --> 00:08:01,900
provide<font color="#E5E5E5"> maximum efficiency with our</font>

160
00:07:58,990 --> 00:08:03,970
<font color="#CCCCCC">Hardware microcode also means</font>

161
00:08:01,900 --> 00:08:06,549
flexibility so we<font color="#CCCCCC"> can</font><font color="#E5E5E5"> basically</font>

162
00:08:03,970 --> 00:08:09,850
<font color="#E5E5E5">implement any kind of computation</font><font color="#CCCCCC"> in</font>

163
00:08:06,550 --> 00:08:12,310
micro code which makes<font color="#E5E5E5"> our processor</font>

164
00:08:09,850 --> 00:08:14,920
core<font color="#E5E5E5"> a multi-purpose device we can</font>

165
00:08:12,310 --> 00:08:16,470
develop a<font color="#E5E5E5"> general-purpose instruction</font>

166
00:08:14,920 --> 00:08:19,660
set architecture but we can also

167
00:08:16,470 --> 00:08:21,940
<font color="#E5E5E5">microcode special digital</font><font color="#CCCCCC"> signal</font>

168
00:08:19,660 --> 00:08:26,410
processing features like<font color="#E5E5E5"> FFT or</font>

169
00:08:21,940 --> 00:08:28,630
encryption and and so<font color="#CCCCCC"> on and</font><font color="#E5E5E5"> also since</font>

170
00:08:26,410 --> 00:08:30,130
micro code is a very special kind<font color="#E5E5E5"> of</font>

171
00:08:28,630 --> 00:08:33,220
software which is<font color="#CCCCCC"> stored</font><font color="#E5E5E5"> in a special</font>

172
00:08:30,130 --> 00:08:35,350
<font color="#E5E5E5">memory in our processor we can overwrite</font>

173
00:08:33,220 --> 00:08:38,170
<font color="#E5E5E5">the microcode we can reconfigure the</font>

174
00:08:35,350 --> 00:08:41,830
device<font color="#E5E5E5"> dynamically so that that's also</font>

175
00:08:38,169 --> 00:08:43,689
<font color="#E5E5E5">an important feature for the future so</font>

176
00:08:41,830 --> 00:08:46,720
if you think<font color="#E5E5E5"> about the abstraction</font>

177
00:08:43,690 --> 00:08:49,330
layers again<font color="#CCCCCC"> and we can match them to to</font>

178
00:08:46,720 --> 00:08:51,550
<font color="#E5E5E5">this Hardware</font><font color="#CCCCCC"> micro code software</font><font color="#E5E5E5"> layers</font>

179
00:08:49,330 --> 00:08:53,950
<font color="#E5E5E5">so the processor</font><font color="#CCCCCC"> code itself is of</font>

180
00:08:51,550 --> 00:08:55,540
<font color="#E5E5E5">course hardware and then the instruction</font>

181
00:08:53,950 --> 00:08:57,430
<font color="#E5E5E5">set support</font><font color="#CCCCCC"> the instruction set</font>

182
00:08:55,540 --> 00:09:00,280
architecture<font color="#CCCCCC"> is actually not hardwired</font>

183
00:08:57,430 --> 00:09:02,949
in the processor core is defined by

184
00:09:00,280 --> 00:09:05,470
micro code and then about<font color="#E5E5E5"> the micro code</font>

185
00:09:02,950 --> 00:09:07,209
we have a<font color="#E5E5E5"> wide thick layer of software</font>

186
00:09:05,470 --> 00:09:09,669
on the high level<font color="#CCCCCC"> is the application</font>

187
00:09:07,209 --> 00:09:11,949
<font color="#CCCCCC">code and the lowest level is the</font>

188
00:09:09,669 --> 00:09:14,589
instruction set which<font color="#E5E5E5"> is implemented in</font>

189
00:09:11,949 --> 00:09:19,139
micro code and the high level<font color="#CCCCCC"> and</font><font color="#E5E5E5"> the</font>

190
00:09:14,589 --> 00:09:19,139
low<font color="#CCCCCC"> level</font><font color="#E5E5E5"> software is connected by</font><font color="#CCCCCC"> LLVM</font>

191
00:09:19,259 --> 00:09:27,009
<font color="#E5E5E5">okay so what it</font><font color="#CCCCCC"> means I just would like</font>

192
00:09:24,970 --> 00:09:29,049
to<font color="#CCCCCC"> point out what it</font><font color="#E5E5E5"> means to have a</font>

193
00:09:27,009 --> 00:09:32,139
micro code defined<font color="#CCCCCC"> instruction set</font>

194
00:09:29,049 --> 00:09:34,239
architecture typically<font color="#CCCCCC"> you</font><font color="#E5E5E5"> have your</font>

195
00:09:32,139 --> 00:09:37,269
application<font color="#E5E5E5"> code and then you have a</font>

196
00:09:34,239 --> 00:09:39,970
compiler which turns it into your

197
00:09:37,269 --> 00:09:42,909
<font color="#CCCCCC">assembly code and binary executable</font><font color="#E5E5E5"> and</font>

198
00:09:39,970 --> 00:09:44,979
that's typically hardwired into the<font color="#E5E5E5"> into</font>

199
00:09:42,909 --> 00:09:46,689
the processor<font color="#E5E5E5"> but if you think about an</font>

200
00:09:44,979 --> 00:09:50,829
operation oriented hardware architecture

201
00:09:46,689 --> 00:09:53,858
but actually the microcode supports us

202
00:09:50,829 --> 00:09:55,569
to lift the instruction set architecture

203
00:09:53,859 --> 00:09:59,889
from<font color="#E5E5E5"> the hardware to a higher</font>

204
00:09:55,569 --> 00:10:02,769
abstraction level so what it<font color="#CCCCCC"> gives us</font>

205
00:09:59,889 --> 00:10:04,929
what<font color="#E5E5E5"> it gives us</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> abstraction</font>

206
00:10:02,769 --> 00:10:06,579
possibility is<font color="#CCCCCC"> that we can implement</font>

207
00:10:04,929 --> 00:10:09,098
domain-specific operations

208
00:10:06,579 --> 00:10:12,998
<font color="#E5E5E5">like I mentioned FFT encryption and</font>

209
00:10:09,099 --> 00:10:14,619
whatever and it also provides us<font color="#CCCCCC"> with</font>

210
00:10:12,999 --> 00:10:17,079
the<font color="#CCCCCC"> possibility to</font><font color="#E5E5E5"> have a rich and</font>

211
00:10:14,619 --> 00:10:23,319
balanced I say which the compiler can

212
00:10:17,079 --> 00:10:27,909
target<font color="#CCCCCC"> okay</font><font color="#E5E5E5"> so that's about our</font><font color="#CCCCCC"> code</font>

213
00:10:23,319 --> 00:10:30,939
technology<font color="#E5E5E5"> and then I try I will focus</font>

214
00:10:27,909 --> 00:10:32,949
on for a few slides on the actual

215
00:10:30,939 --> 00:10:38,858
instruction set architecture which we we

216
00:10:32,949 --> 00:10:40,988
are implementing for<font color="#CCCCCC"> LLVM so we have our</font>

217
00:10:38,859 --> 00:10:44,949
<font color="#CCCCCC">vm assembly everyone knows that very</font>

218
00:10:40,989 --> 00:10:46,859
<font color="#CCCCCC">well and</font><font color="#E5E5E5"> then we have overall ICL</font>

219
00:10:44,949 --> 00:10:50,439
instruction set architecture

220
00:10:46,859 --> 00:10:51,009
so first what do I mean<font color="#E5E5E5"> when I say</font><font color="#CCCCCC"> that</font>

221
00:10:50,439 --> 00:10:53,858
we<font color="#E5E5E5"> lift</font>

222
00:10:51,009 --> 00:10:56,289
<font color="#E5E5E5">I sell</font><font color="#CCCCCC"> too much</font><font color="#E5E5E5"> at IBM assembly it means</font>

223
00:10:53,859 --> 00:10:58,600
that we provide semantically matching

224
00:10:56,289 --> 00:11:03,069
instructions for basically<font color="#E5E5E5"> all other vm</font>

225
00:10:58,600 --> 00:11:05,439
assembly instructions so it means you

226
00:11:03,069 --> 00:11:07,598
have an addition in<font color="#E5E5E5"> our vm assembly then</font>

227
00:11:05,439 --> 00:11:09,848
you have an addition<font color="#E5E5E5"> in our instruction</font>

228
00:11:07,599 --> 00:11:12,399
set architecture of course this is not a

229
00:11:09,849 --> 00:11:15,100
big thing<font color="#CCCCCC"> for these basic operations</font>

230
00:11:12,399 --> 00:11:18,060
<font color="#CCCCCC">every processor has</font><font color="#E5E5E5"> an additional</font>

231
00:11:15,100 --> 00:11:20,730
instruction<font color="#E5E5E5"> but we have the same</font>

232
00:11:18,060 --> 00:11:22,810
matching semantically matching

233
00:11:20,730 --> 00:11:28,300
corresponding instruction for complex

234
00:11:22,810 --> 00:11:32,079
operations as well<font color="#CCCCCC"> for example</font><font color="#E5E5E5"> like bit</font>

235
00:11:28,300 --> 00:11:33,910
reverse operation count leading zeros<font color="#E5E5E5"> or</font>

236
00:11:32,080 --> 00:11:38,709
even intrinsics floating-point

237
00:11:33,910 --> 00:11:40,420
operations and things<font color="#E5E5E5"> like</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> so we</font>

238
00:11:38,709 --> 00:11:42,790
developed the one at IBM back-end which

239
00:11:40,420 --> 00:11:46,839
turns<font color="#CCCCCC"> other VM assembly into ICL and</font>

240
00:11:42,790 --> 00:11:49,599
this<font color="#E5E5E5"> back-end does not need to do very</font>

241
00:11:46,839 --> 00:11:53,620
<font color="#CCCCCC">complicated things actually</font><font color="#E5E5E5"> so it's very</font>

242
00:11:49,600 --> 00:11:57,040
simple<font color="#E5E5E5"> efficient and usual mostly it</font>

243
00:11:53,620 --> 00:11:59,230
uses<font color="#E5E5E5"> general Elaraby and facilities and</font>

244
00:11:57,040 --> 00:12:03,459
this is thanks<font color="#CCCCCC"> to the</font><font color="#E5E5E5"> the matching</font>

245
00:11:59,230 --> 00:12:06,190
<font color="#E5E5E5">semantics also of course</font><font color="#CCCCCC"> eleven assembly</font>

246
00:12:03,459 --> 00:12:09,279
code can<font color="#CCCCCC"> be optimized using</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> LLVM</font>

247
00:12:06,190 --> 00:12:12,250
<font color="#CCCCCC">meadowland and we are</font><font color="#E5E5E5"> very happy with</font>

248
00:12:09,279 --> 00:12:14,050
<font color="#CCCCCC">that because we have direct use of</font><font color="#E5E5E5"> those</font>

249
00:12:12,250 --> 00:12:17,589
general<font color="#CCCCCC"> and</font><font color="#E5E5E5"> a vm assembly level</font>

250
00:12:14,050 --> 00:12:20,079
<font color="#E5E5E5">optimizations because our back-end will</font>

251
00:12:17,589 --> 00:12:22,570
not modify much on the semantics of the

252
00:12:20,080 --> 00:12:25,690
<font color="#CCCCCC">of the code</font><font color="#E5E5E5"> so we we benefit directly</font>

253
00:12:22,570 --> 00:12:29,529
<font color="#E5E5E5">from the</font><font color="#CCCCCC"> tund optimizations</font><font color="#E5E5E5"> and also</font>

254
00:12:25,690 --> 00:12:32,200
since the ICL instructions are matching

255
00:12:29,529 --> 00:12:35,260
the the<font color="#CCCCCC"> 11 assembly instructions we</font>

256
00:12:32,200 --> 00:12:41,320
don't need<font color="#E5E5E5"> to do much more</font><font color="#CCCCCC"> target</font>

257
00:12:35,260 --> 00:12:44,350
specific magic in the<font color="#CCCCCC"> backend and so far</font>

258
00:12:41,320 --> 00:12:46,660
<font color="#CCCCCC">so good but our</font><font color="#E5E5E5"> VM is based on a</font>

259
00:12:44,350 --> 00:12:48,339
<font color="#CCCCCC">theoretical model</font><font color="#E5E5E5"> which has some</font>

260
00:12:46,660 --> 00:12:50,319
characteristics which makes it

261
00:12:48,339 --> 00:12:52,330
practically<font color="#CCCCCC"> impossible to directly</font>

262
00:12:50,320 --> 00:12:57,339
<font color="#E5E5E5">implement of course so we</font><font color="#CCCCCC"> need to think</font>

263
00:12:52,330 --> 00:12:59,950
<font color="#CCCCCC">about how to constrain ourselves to to</font>

264
00:12:57,339 --> 00:13:01,390
be<font color="#CCCCCC"> person to be to be able</font><font color="#E5E5E5"> to to</font>

265
00:12:59,950 --> 00:13:03,850
implement<font color="#E5E5E5"> an instruction set</font>

266
00:13:01,390 --> 00:13:06,040
architecture for<font color="#CCCCCC"> LLVM</font><font color="#E5E5E5"> first thing is</font>

267
00:13:03,850 --> 00:13:09,339
operations<font color="#E5E5E5"> so an IBM assembly has</font>

268
00:13:06,040 --> 00:13:11,890
instructions and intrinsic functions<font color="#E5E5E5"> as</font>

269
00:13:09,339 --> 00:13:14,290
I said we support<font color="#E5E5E5"> or we provide the</font>

270
00:13:11,890 --> 00:13:16,360
semantically matching operations in<font color="#CCCCCC"> il</font>

271
00:13:14,290 --> 00:13:18,430
and additionally<font color="#E5E5E5"> we needed to add some</font>

272
00:13:16,360 --> 00:13:22,810
<font color="#E5E5E5">kind of system operations management</font>

273
00:13:18,430 --> 00:13:27,279
operations like handing<font color="#E5E5E5"> i/o managing the</font>

274
00:13:22,810 --> 00:13:30,170
execution state and also<font color="#CCCCCC"> some special</font>

275
00:13:27,279 --> 00:13:33,529
<font color="#E5E5E5">data movement operations</font>

276
00:13:30,170 --> 00:13:35,990
<font color="#E5E5E5">then the next thing is the supported</font>

277
00:13:33,529 --> 00:13:38,120
value types so other VM Assembly has<font color="#CCCCCC"> a</font>

278
00:13:35,990 --> 00:13:40,250
virtually an unlimited number<font color="#E5E5E5"> of single</font>

279
00:13:38,120 --> 00:13:43,639
value types<font color="#E5E5E5"> if you think</font><font color="#CCCCCC"> about there are</font>

280
00:13:40,250 --> 00:13:47,089
a lot of<font color="#CCCCCC"> floating-point</font><font color="#E5E5E5"> types and much</font>

281
00:13:43,639 --> 00:13:49,519
much more<font color="#E5E5E5"> possible integer types okay</font>

282
00:13:47,089 --> 00:13:52,310
<font color="#CCCCCC">they are not</font><font color="#E5E5E5"> typically not</font><font color="#CCCCCC"> used but they</font>

283
00:13:49,519 --> 00:13:55,160
are there<font color="#E5E5E5"> in theory so of course we</font><font color="#CCCCCC"> need</font>

284
00:13:52,310 --> 00:13:56,989
<font color="#CCCCCC">to set define a set of integer</font>

285
00:13:55,160 --> 00:14:02,600
<font color="#E5E5E5">floating-point pointer and vector types</font>

286
00:13:56,990 --> 00:14:04,519
which we support then registers<font color="#CCCCCC"> LLVM</font>

287
00:14:02,600 --> 00:14:08,389
assembly has an unlimited number of

288
00:14:04,519 --> 00:14:13,490
registers which is again<font color="#E5E5E5"> impractical to</font>

289
00:14:08,389 --> 00:14:15,920
try implementing<font color="#E5E5E5"> so we defined a set of</font>

290
00:14:13,490 --> 00:14:18,560
register windows which we support and of

291
00:14:15,920 --> 00:14:20,660
<font color="#CCCCCC">course</font><font color="#E5E5E5"> when talking about registers it</font>

292
00:14:18,560 --> 00:14:22,069
might be worthwhile to<font color="#E5E5E5"> mention that of</font>

293
00:14:20,660 --> 00:14:24,800
course there is a big difference<font color="#E5E5E5"> between</font>

294
00:14:22,070 --> 00:14:28,010
<font color="#E5E5E5">a</font><font color="#CCCCCC"> VM assembly and and reality as</font><font color="#E5E5E5"> a VM</font>

295
00:14:24,800 --> 00:14:29,599
assembly is in SSA form<font color="#E5E5E5"> static single</font>

296
00:14:28,010 --> 00:14:32,240
assignment form which is again<font color="#E5E5E5"> not</font>

297
00:14:29,600 --> 00:14:36,589
<font color="#E5E5E5">practical to implement so of course we</font>

298
00:14:32,240 --> 00:14:40,730
<font color="#E5E5E5">don't support that that's</font><font color="#CCCCCC"> what the</font>

299
00:14:36,589 --> 00:14:42,529
argument<font color="#E5E5E5"> basically each instruction has</font>

300
00:14:40,730 --> 00:14:45,920
source and destination registers<font color="#CCCCCC"> as</font>

301
00:14:42,529 --> 00:14:50,019
argument<font color="#CCCCCC"> I will</font><font color="#E5E5E5"> tell you in</font><font color="#CCCCCC"> the in the</font>

302
00:14:45,920 --> 00:14:53,029
next<font color="#E5E5E5"> slide</font><font color="#CCCCCC"> why this is not always</font>

303
00:14:50,019 --> 00:14:55,730
<font color="#E5E5E5">efficient to to have or why it is not</font>

304
00:14:53,029 --> 00:14:59,300
<font color="#E5E5E5">always efficient to</font><font color="#CCCCCC"> have only</font><font color="#E5E5E5"> that so we</font>

305
00:14:55,730 --> 00:15:01,459
added<font color="#E5E5E5"> special instruction</font><font color="#CCCCCC"> value support</font>

306
00:14:59,300 --> 00:15:03,859
accumulating in source registers and

307
00:15:01,459 --> 00:15:07,069
also to work directly with<font color="#E5E5E5"> immediate</font>

308
00:15:03,860 --> 00:15:08,930
values and also<font color="#E5E5E5"> the</font><font color="#CCCCCC"> binary</font>

309
00:15:07,070 --> 00:15:11,660
representation is very<font color="#E5E5E5"> important for us</font>

310
00:15:08,930 --> 00:15:15,920
<font color="#E5E5E5">so an onion assembly has the bit code as</font>

311
00:15:11,660 --> 00:15:17,839
a binary form we developed<font color="#E5E5E5"> our custom</font>

312
00:15:15,920 --> 00:15:22,099
dense binary coding and I will tell you

313
00:15:17,839 --> 00:15:22,640
<font color="#E5E5E5">some</font><font color="#CCCCCC"> more details</font><font color="#E5E5E5"> about that tune all</font>

314
00:15:22,100 --> 00:15:27,560
<font color="#E5E5E5">right</font>

315
00:15:22,640 --> 00:15:30,199
so<font color="#E5E5E5"> optimizing operation sequences</font><font color="#CCCCCC"> first</font>

316
00:15:27,560 --> 00:15:32,719
let's have a<font color="#E5E5E5"> look</font><font color="#CCCCCC"> in accumulating in</font>

317
00:15:30,199 --> 00:15:37,609
source<font color="#E5E5E5"> registers if you consider this</font>

318
00:15:32,720 --> 00:15:40,069
simple<font color="#E5E5E5"> addition a equals a plus B in a</font>

319
00:15:37,610 --> 00:15:42,190
mess a regular form of an instruction

320
00:15:40,069 --> 00:15:47,370
<font color="#E5E5E5">you can say add a a B</font>

321
00:15:42,190 --> 00:15:47,370
so<font color="#CCCCCC"> add a and</font><font color="#E5E5E5"> B and store the</font><font color="#CCCCCC"> result in a</font>

322
00:15:47,670 --> 00:15:51,729
it means<font color="#E5E5E5"> you have an opcode</font><font color="#CCCCCC"> the</font>

323
00:15:50,050 --> 00:15:54,819
<font color="#E5E5E5">destination register</font><font color="#CCCCCC"> went to source</font>

324
00:15:51,730 --> 00:15:56,680
registers but it's quite<font color="#CCCCCC"> obvious that</font>

325
00:15:54,820 --> 00:15:58,660
the<font color="#E5E5E5"> destination and one of the source</font>

326
00:15:56,680 --> 00:16:00,400
registers are the same so why should we

327
00:15:58,660 --> 00:16:03,600
store it in the in the<font color="#CCCCCC"> program memory</font>

328
00:16:00,400 --> 00:16:05,590
twice<font color="#E5E5E5"> we can have a special variant and</font>

329
00:16:03,600 --> 00:16:09,280
accumulating or<font color="#CCCCCC"> or as we</font><font color="#E5E5E5"> called an</font>

330
00:16:05,590 --> 00:16:11,860
<font color="#CCCCCC">in-place update variant</font><font color="#E5E5E5"> add update a B</font>

331
00:16:09,280 --> 00:16:14,140
in which case the<font color="#CCCCCC"> first source register</font>

332
00:16:11,860 --> 00:16:18,420
is special as the result will be<font color="#CCCCCC"> stored</font>

333
00:16:14,140 --> 00:16:20,770
back to there<font color="#CCCCCC"> so here we saved one</font>

334
00:16:18,420 --> 00:16:24,880
argument<font color="#E5E5E5"> in the binary representation</font>

335
00:16:20,770 --> 00:16:28,420
<font color="#E5E5E5">and since this kind of possibility we're</font>

336
00:16:24,880 --> 00:16:31,150
updating<font color="#CCCCCC"> in place update is possible we</font>

337
00:16:28,420 --> 00:16:36,160
can save a quite considerable amount of

338
00:16:31,150 --> 00:16:38,380
program memory the other type of the

339
00:16:36,160 --> 00:16:41,829
other<font color="#E5E5E5"> special variant of instructions is</font>

340
00:16:38,380 --> 00:16:46,360
working with immediate values<font color="#CCCCCC"> so now if</font>

341
00:16:41,830 --> 00:16:49,390
you consider<font color="#E5E5E5"> a equals a plus 42 then if</font>

342
00:16:46,360 --> 00:16:51,310
we have<font color="#CCCCCC"> just a regular at the additional</font>

343
00:16:49,390 --> 00:16:54,670
instruction<font color="#E5E5E5"> like in the previous example</font>

344
00:16:51,310 --> 00:16:57,550
<font color="#CCCCCC">add a a B then it means that 42 should</font>

345
00:16:54,670 --> 00:17:01,420
be in a register so<font color="#CCCCCC"> you have a special</font>

346
00:16:57,550 --> 00:17:03,459
operation<font color="#E5E5E5"> move 42 into register B and</font>

347
00:17:01,420 --> 00:17:06,399
then<font color="#E5E5E5"> you can use the addition in this</font>

348
00:17:03,460 --> 00:17:10,569
case you<font color="#CCCCCC"> use actually two instructions</font>

349
00:17:06,400 --> 00:17:13,030
to implement this<font color="#E5E5E5"> this behavior if you</font>

350
00:17:10,569 --> 00:17:16,359
have a special variant<font color="#E5E5E5"> add immediate</font>

351
00:17:13,030 --> 00:17:18,459
value then<font color="#E5E5E5"> you can just use directly the</font>

352
00:17:16,359 --> 00:17:20,829
immediate value<font color="#E5E5E5"> instead</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> the second</font>

353
00:17:18,459 --> 00:17:23,260
source<font color="#CCCCCC"> register so</font><font color="#E5E5E5"> you saved binary</font>

354
00:17:20,829 --> 00:17:27,430
space<font color="#E5E5E5"> again and of course you can</font>

355
00:17:23,260 --> 00:17:30,640
<font color="#CCCCCC">combine these two</font><font color="#E5E5E5"> two way of handling</font>

356
00:17:27,430 --> 00:17:34,630
<font color="#E5E5E5">the argument so the combined special</font>

357
00:17:30,640 --> 00:17:38,200
<font color="#E5E5E5">variant is add in place</font><font color="#CCCCCC"> an</font><font color="#E5E5E5"> immediate</font>

358
00:17:34,630 --> 00:17:40,540
value<font color="#CCCCCC"> where you just define the source</font>

359
00:17:38,200 --> 00:17:44,350
and destination register<font color="#CCCCCC"> s1 register and</font>

360
00:17:40,540 --> 00:17:48,420
the immediate value<font color="#E5E5E5"> to add to it so here</font>

361
00:17:44,350 --> 00:17:51,969
we saved even more<font color="#CCCCCC"> problem memory space</font>

362
00:17:48,420 --> 00:17:53,920
in<font color="#CCCCCC"> Aisle we have this kind of special</font>

363
00:17:51,970 --> 00:17:57,400
variant<font color="#E5E5E5"> basically for</font>

364
00:17:53,920 --> 00:18:02,110
<font color="#CCCCCC">all</font><font color="#E5E5E5"> similar instructions where it's</font>

365
00:17:57,400 --> 00:18:04,390
possible<font color="#CCCCCC"> to have</font><font color="#E5E5E5"> okay and then</font>

366
00:18:02,110 --> 00:18:06,040
optimizing binary representation<font color="#E5E5E5"> so that</font>

367
00:18:04,390 --> 00:18:07,410
the the things on the previous<font color="#E5E5E5"> side</font>

368
00:18:06,040 --> 00:18:10,960
already

369
00:18:07,410 --> 00:18:14,320
<font color="#E5E5E5">contribute to having reduced binary size</font>

370
00:18:10,960 --> 00:18:17,230
<font color="#E5E5E5">in the in the program memory but also</font>

371
00:18:14,320 --> 00:18:19,179
it's important to to be clever when you

372
00:18:17,230 --> 00:18:23,320
design<font color="#E5E5E5"> the binary encoding of an</font>

373
00:18:19,180 --> 00:18:26,250
instruction set architecture<font color="#E5E5E5"> so we want</font>

374
00:18:23,320 --> 00:18:29,409
<font color="#E5E5E5">to have a high code density which means</font>

375
00:18:26,250 --> 00:18:32,200
that a particular<font color="#E5E5E5"> piece</font><font color="#CCCCCC"> of software</font>

376
00:18:29,410 --> 00:18:35,350
should consume as small program memory

377
00:18:32,200 --> 00:18:39,070
<font color="#E5E5E5">as possible but we have a lot of</font>

378
00:18:35,350 --> 00:18:41,020
<font color="#E5E5E5">instructions</font><font color="#CCCCCC"> in in ICL so to reach our</font>

379
00:18:39,070 --> 00:18:44,379
goal<font color="#CCCCCC"> we must</font><font color="#E5E5E5"> have variable length</font>

380
00:18:41,020 --> 00:18:45,850
<font color="#E5E5E5">instructions our instruction length of</font>

381
00:18:44,380 --> 00:18:47,920
our instructions varies between<font color="#CCCCCC"> one and</font>

382
00:18:45,850 --> 00:18:50,500
<font color="#CCCCCC">ten bytes and here you can see the</font>

383
00:18:47,920 --> 00:18:52,570
distribution<font color="#E5E5E5"> so most of them is three</font>

384
00:18:50,500 --> 00:18:55,750
<font color="#CCCCCC">bytes</font><font color="#E5E5E5"> long the average</font><font color="#CCCCCC"> is somewhere</font>

385
00:18:52,570 --> 00:19:00,040
<font color="#CCCCCC">around</font><font color="#E5E5E5"> 3.4 bytes</font>

386
00:18:55,750 --> 00:19:02,980
I don't want to go into<font color="#CCCCCC"> much details</font>

387
00:19:00,040 --> 00:19:04,960
<font color="#CCCCCC">about how the actual binary</font><font color="#E5E5E5"> encoding is</font>

388
00:19:02,980 --> 00:19:08,080
structured<font color="#E5E5E5"> but I would like to</font><font color="#CCCCCC"> give you</font>

389
00:19:04,960 --> 00:19:10,420
some idea<font color="#E5E5E5"> what kind of problems or what</font>

390
00:19:08,080 --> 00:19:13,120
what kind of characteristics you will

391
00:19:10,420 --> 00:19:14,710
need to think<font color="#CCCCCC"> about as I already</font>

392
00:19:13,120 --> 00:19:17,979
mentioned we<font color="#CCCCCC"> want</font><font color="#E5E5E5"> to maximize code</font>

393
00:19:14,710 --> 00:19:19,630
density so most typically the most

394
00:19:17,980 --> 00:19:22,900
frequent<font color="#E5E5E5"> more frequent instructions</font>

395
00:19:19,630 --> 00:19:25,840
<font color="#E5E5E5">should have shorter representation so</font>

396
00:19:22,900 --> 00:19:31,570
<font color="#CCCCCC">the repeating instructions will consume</font>

397
00:19:25,840 --> 00:19:34,090
less space then we also want<font color="#CCCCCC"> to optimize</font>

398
00:19:31,570 --> 00:19:37,570
<font color="#E5E5E5">the the footprint of the microcode</font>

399
00:19:34,090 --> 00:19:40,290
implementation<font color="#E5E5E5"> itself we should be able</font>

400
00:19:37,570 --> 00:19:43,629
we want to be able<font color="#CCCCCC"> to</font><font color="#E5E5E5"> reuse cows for</font>

401
00:19:40,290 --> 00:19:46,990
part of the decode logic so we of<font color="#E5E5E5"> course</font>

402
00:19:43,630 --> 00:19:50,830
want<font color="#E5E5E5"> to have some regularity</font><font color="#CCCCCC"> how we</font>

403
00:19:46,990 --> 00:19:53,670
encode the operations<font color="#E5E5E5"> and also we want</font>

404
00:19:50,830 --> 00:19:56,730
<font color="#CCCCCC">to</font><font color="#E5E5E5"> be able to read to</font><font color="#CCCCCC"> to optimize the</font>

405
00:19:53,670 --> 00:20:02,230
not just of the code but but the

406
00:19:56,730 --> 00:20:04,360
<font color="#E5E5E5">computation logic by sharing these parts</font>

407
00:20:02,230 --> 00:20:06,670
also<font color="#E5E5E5"> between similar instructions</font>

408
00:20:04,360 --> 00:20:08,919
grouping them together

409
00:20:06,670 --> 00:20:12,580
and that's partially<font color="#CCCCCC"> related to the</font>

410
00:20:08,920 --> 00:20:14,620
third consideration is of course at the

411
00:20:12,580 --> 00:20:16,210
end performance<font color="#E5E5E5"> matters</font><font color="#CCCCCC"> so we want</font><font color="#E5E5E5"> to</font>

412
00:20:14,620 --> 00:20:16,739
minimize<font color="#E5E5E5"> the actual execution time as</font>

413
00:20:16,210 --> 00:20:19,540
well

414
00:20:16,740 --> 00:20:23,110
here the binary<font color="#E5E5E5"> encoding</font><font color="#CCCCCC"> is relevant</font>

415
00:20:19,540 --> 00:20:27,870
because decoding is dependent on on the

416
00:20:23,110 --> 00:20:31,750
<font color="#E5E5E5">binary</font><font color="#CCCCCC"> encoding</font><font color="#E5E5E5"> so with with the clever</font>

417
00:20:27,870 --> 00:20:35,040
<font color="#E5E5E5">spacing and and formatting of the</font>

418
00:20:31,750 --> 00:20:38,440
encoding types or the encoding formats

419
00:20:35,040 --> 00:20:42,070
<font color="#CCCCCC">we can reduce the decode time and also</font>

420
00:20:38,440 --> 00:20:43,480
<font color="#E5E5E5">we can make possible that decoding an</font>

421
00:20:42,070 --> 00:20:46,810
instruction and actually starting to

422
00:20:43,480 --> 00:20:49,420
perform the operation can overlap so in

423
00:20:46,810 --> 00:20:55,659
this in<font color="#E5E5E5"> this way we can minimize the</font>

424
00:20:49,420 --> 00:20:59,050
execution time<font color="#E5E5E5"> okay and I talked a lot</font>

425
00:20:55,660 --> 00:21:02,710
about binary coding and code<font color="#E5E5E5"> enca</font><font color="#CCCCCC"> T so</font>

426
00:20:59,050 --> 00:21:06,280
we<font color="#E5E5E5"> have some preliminary results with</font>

427
00:21:02,710 --> 00:21:09,160
<font color="#CCCCCC">ICL about code density</font><font color="#E5E5E5"> or actually this</font>

428
00:21:06,280 --> 00:21:13,060
diagram will<font color="#CCCCCC"> show the binary size</font><font color="#E5E5E5"> so in</font>

429
00:21:09,160 --> 00:21:15,970
<font color="#E5E5E5">this case the smaller is better we</font>

430
00:21:13,060 --> 00:21:18,190
compiled the<font color="#CCCCCC"> Texas</font><font color="#E5E5E5"> Instruments</font><font color="#CCCCCC"> with</font>

431
00:21:15,970 --> 00:21:22,930
benchmarks with a lot VM and normalize

432
00:21:18,190 --> 00:21:27,100
the results to our<font color="#CCCCCC"> ICL</font><font color="#E5E5E5"> and as you can</font>

433
00:21:22,930 --> 00:21:29,680
<font color="#CCCCCC">see basically</font><font color="#E5E5E5"> ARM Cortex requires at</font>

434
00:21:27,100 --> 00:21:32,949
least<font color="#CCCCCC"> 35 percent more</font><font color="#E5E5E5"> program memory and</font>

435
00:21:29,680 --> 00:21:36,970
x86 requires<font color="#CCCCCC"> 80 percent more</font><font color="#E5E5E5"> program</font>

436
00:21:32,950 --> 00:21:38,590
memory<font color="#E5E5E5"> to store the to store the same</font><font color="#CCCCCC"> TI</font>

437
00:21:36,970 --> 00:21:42,430
<font color="#CCCCCC">suite benchmark applications</font>

438
00:21:38,590 --> 00:21:45,760
so our target one<font color="#E5E5E5"> of our target was to</font>

439
00:21:42,430 --> 00:21:50,380
have a<font color="#E5E5E5"> very dense code representation</font>

440
00:21:45,760 --> 00:21:52,690
<font color="#E5E5E5">which we think we reached and well with</font>

441
00:21:50,380 --> 00:21:55,690
<font color="#E5E5E5">this exciting results I would like also</font>

442
00:21:52,690 --> 00:21:57,610
to wrap up so I talked about<font color="#E5E5E5"> our</font><font color="#CCCCCC"> core</font>

443
00:21:55,690 --> 00:22:00,940
technology<font color="#E5E5E5"> the</font><font color="#CCCCCC"> incipient processing</font>

444
00:21:57,610 --> 00:22:02,830
technology our operation oriented

445
00:22:00,940 --> 00:22:05,650
hardware architecture the processor core

446
00:22:02,830 --> 00:22:07,000
then our founder which is based on micro

447
00:22:05,650 --> 00:22:09,160
code and implements the actual

448
00:22:07,000 --> 00:22:12,670
instruction set architecture which we

449
00:22:09,160 --> 00:22:16,020
<font color="#E5E5E5">tailor made for</font><font color="#CCCCCC"> add</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> vm assembly I also</font>

450
00:22:12,670 --> 00:22:19,480
talked about what is<font color="#E5E5E5"> the relation and</font>

451
00:22:16,020 --> 00:22:20,860
how we use another<font color="#CCCCCC"> VM back-end</font><font color="#E5E5E5"> to</font>

452
00:22:19,480 --> 00:22:24,730
efficiently

453
00:22:20,860 --> 00:22:26,620
and and I can say<font color="#E5E5E5"> simply target</font>

454
00:22:24,730 --> 00:22:29,440
efficient or generate efficient code for

455
00:22:26,620 --> 00:22:32,500
<font color="#E5E5E5">ICL and I also would like to mention</font>

456
00:22:29,440 --> 00:22:33,970
<font color="#E5E5E5">that</font><font color="#CCCCCC"> I CL the implementation of</font><font color="#E5E5E5"> the</font>

457
00:22:32,500 --> 00:22:36,370
instructions that architecture itself

458
00:22:33,970 --> 00:22:39,760
<font color="#E5E5E5">and the software ecosystem around it is</font>

459
00:22:36,370 --> 00:22:42,489
still<font color="#E5E5E5"> working progress so</font><font color="#CCCCCC"> it's not</font>

460
00:22:39,760 --> 00:22:45,760
available<font color="#E5E5E5"> yet</font><font color="#CCCCCC"> but we plan to release it</font>

461
00:22:42,490 --> 00:22:49,350
as as an upgrade<font color="#CCCCCC"> for our MCS Ambler</font>

462
00:22:45,760 --> 00:22:51,940
device<font color="#E5E5E5"> sometime in the next year</font><font color="#CCCCCC"> so</font>

463
00:22:49,350 --> 00:23:09,250
<font color="#CCCCCC">thanks</font><font color="#E5E5E5"> for your attention and I'm ready</font>

464
00:22:51,940 --> 00:23:13,690
for<font color="#CCCCCC"> questions</font><font color="#E5E5E5"> yes please sorry but you</font>

465
00:23:09,250 --> 00:23:15,159
want<font color="#E5E5E5"> to check the microcode well we can</font>

466
00:23:13,690 --> 00:23:17,440
<font color="#E5E5E5">discuss that</font><font color="#CCCCCC"> offline</font><font color="#E5E5E5"> if if you really</font>

467
00:23:15,159 --> 00:23:20,019
<font color="#E5E5E5">want to have a look into our microphone</font>

468
00:23:17,440 --> 00:23:21,909
so that<font color="#E5E5E5"> that's not open</font><font color="#CCCCCC"> right now so</font>

469
00:23:20,019 --> 00:23:24,460
it's really connected<font color="#CCCCCC"> to the</font><font color="#E5E5E5"> hardware</font>

470
00:23:21,909 --> 00:23:26,350
architecture<font color="#CCCCCC"> of course and that's a</font>

471
00:23:24,460 --> 00:23:29,970
<font color="#E5E5E5">proprietary thing but if you're</font>

472
00:23:26,350 --> 00:23:29,969
<font color="#E5E5E5">interested we can we can take it offline</font>

473
00:23:41,900 --> 00:24:00,430
I can I<font color="#E5E5E5"> can</font><font color="#CCCCCC"> maybe</font><font color="#E5E5E5"> I can answer this</font>

474
00:23:53,059 --> 00:24:00,430
<font color="#CCCCCC">question by showing</font><font color="#E5E5E5"> the mother slide so</font>

475
00:24:01,900 --> 00:24:08,900
right now we<font color="#E5E5E5"> develop the microcode my</font>

476
00:24:04,940 --> 00:24:12,080
hand<font color="#E5E5E5"> and right now with the knot I sell</font>

477
00:24:08,900 --> 00:24:15,020
I sell microcode is is<font color="#E5E5E5"> not in that</font><font color="#CCCCCC"> sense</font>

478
00:24:12,080 --> 00:24:20,059
<font color="#E5E5E5">it's</font><font color="#CCCCCC"> not released yet in any way</font><font color="#E5E5E5"> but as</font>

479
00:24:15,020 --> 00:24:23,030
binary not as source<font color="#CCCCCC"> code</font><font color="#E5E5E5"> but previously</font>

480
00:24:20,059 --> 00:24:25,220
the practice was<font color="#CCCCCC"> that we developed the</font>

481
00:24:23,030 --> 00:24:26,960
company<font color="#CCCCCC"> developed</font><font color="#E5E5E5"> the microcode</font><font color="#CCCCCC"> and yes</font>

482
00:24:25,220 --> 00:24:31,040
it was proprietary<font color="#E5E5E5"> and and closed</font>

483
00:24:26,960 --> 00:24:33,800
software or microcode firmware<font color="#E5E5E5"> will I</font>

484
00:24:31,040 --> 00:24:37,040
<font color="#E5E5E5">say</font><font color="#CCCCCC"> L I cannot</font><font color="#E5E5E5"> tell</font><font color="#CCCCCC"> you</font><font color="#E5E5E5"> how it will be</font>

485
00:24:33,800 --> 00:24:40,330
released<font color="#E5E5E5"> but we plan actually to use</font>

486
00:24:37,040 --> 00:24:43,010
<font color="#CCCCCC">LLVM also not just</font><font color="#E5E5E5"> to target our</font>

487
00:24:40,330 --> 00:24:45,320
instruction set architecture<font color="#E5E5E5"> but to</font>

488
00:24:43,010 --> 00:24:47,540
generate<font color="#E5E5E5"> microcode from high level</font>

489
00:24:45,320 --> 00:24:54,500
software<font color="#E5E5E5"> code and in that sense of</font>

490
00:24:47,540 --> 00:24:58,520
<font color="#CCCCCC">course if we will have yeah so in the in</font>

491
00:24:54,500 --> 00:25:01,240
that<font color="#CCCCCC"> case the micro code itself will be</font>

492
00:24:58,520 --> 00:25:05,270
generated by an open source<font color="#CCCCCC"> software and</font>

493
00:25:01,240 --> 00:25:19,480
so this problem<font color="#E5E5E5"> could</font><font color="#CCCCCC"> be resolved with</font>

494
00:25:05,270 --> 00:25:19,480
that<font color="#CCCCCC"> I mean was it ok yes yes</font>

495
00:25:22,280 --> 00:25:28,170
yes so so so<font color="#CCCCCC"> you</font><font color="#E5E5E5"> are thinking about that</font>

496
00:25:25,860 --> 00:25:30,030
the complexity<font color="#E5E5E5"> from the</font><font color="#CCCCCC"> backend was</font>

497
00:25:28,170 --> 00:25:32,250
actually moved down to<font color="#E5E5E5"> the micro code</font>

498
00:25:30,030 --> 00:25:36,810
implementation<font color="#CCCCCC"> right</font><font color="#E5E5E5"> well yes that's</font>

499
00:25:32,250 --> 00:25:39,480
<font color="#E5E5E5">true</font><font color="#CCCCCC"> and of course it means that yes the</font>

500
00:25:36,810 --> 00:25:43,050
<font color="#E5E5E5">mic microcode needs needs to implement</font>

501
00:25:39,480 --> 00:25:45,090
<font color="#E5E5E5">some complex features which is which</font>

502
00:25:43,050 --> 00:25:48,480
could be<font color="#CCCCCC"> error-prone</font><font color="#E5E5E5"> and it and and it</font>

503
00:25:45,090 --> 00:25:51,000
needs discipline to implement correctly

504
00:25:48,480 --> 00:25:55,320
<font color="#E5E5E5">so actually that's why we want to</font>

505
00:25:51,000 --> 00:25:56,760
replace this let's say<font color="#CCCCCC"> handcrafted</font>

506
00:25:55,320 --> 00:26:02,250
microcode development with actually

507
00:25:56,760 --> 00:26:03,540
generating micro code but also this

508
00:26:02,250 --> 00:26:06,660
slide might be related

509
00:26:03,540 --> 00:26:10,050
so<font color="#E5E5E5"> our such strategy is not implementing</font>

510
00:26:06,660 --> 00:26:13,770
<font color="#CCCCCC">ISIL at once</font><font color="#E5E5E5"> so because</font><font color="#CCCCCC"> that would be</font>

511
00:26:10,050 --> 00:26:16,830
quite big work<font color="#E5E5E5"> so in the</font><font color="#CCCCCC"> first phase</font>

512
00:26:13,770 --> 00:26:20,040
<font color="#E5E5E5">where we are now we identify the base</font>

513
00:26:16,830 --> 00:26:22,860
set<font color="#E5E5E5"> base subset of the instruction set</font>

514
00:26:20,040 --> 00:26:24,450
and we implement that<font color="#E5E5E5"> in micro code as a</font>

515
00:26:22,860 --> 00:26:26,610
proof of concept<font color="#CCCCCC"> and and it will be</font>

516
00:26:24,450 --> 00:26:28,470
fully functional<font color="#CCCCCC"> of course it will not</font>

517
00:26:26,610 --> 00:26:30,240
immediately<font color="#E5E5E5"> provide the same code</font>

518
00:26:28,470 --> 00:26:33,630
density<font color="#E5E5E5"> because we will not be able to</font>

519
00:26:30,240 --> 00:26:36,540
<font color="#E5E5E5">to utilize all the instructions after</font>

520
00:26:33,630 --> 00:26:39,300
<font color="#CCCCCC">that and we partly started this work</font>

521
00:26:36,540 --> 00:26:43,530
<font color="#CCCCCC">also we want</font><font color="#E5E5E5"> to implement an emulation</font>

522
00:26:39,300 --> 00:26:45,659
support<font color="#E5E5E5"> so complex</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> said instructions</font>

523
00:26:43,530 --> 00:26:48,510
<font color="#E5E5E5">as a first step and as a reference</font>

524
00:26:45,660 --> 00:26:52,350
<font color="#CCCCCC">implementation</font><font color="#E5E5E5"> could</font><font color="#CCCCCC"> be actually</font>

525
00:26:48,510 --> 00:26:54,270
<font color="#E5E5E5">implemented using ISIL itself using the</font>

526
00:26:52,350 --> 00:26:57,629
simpler already micro coded operations

527
00:26:54,270 --> 00:27:00,680
<font color="#E5E5E5">and then later</font><font color="#CCCCCC"> we plan</font><font color="#E5E5E5"> to do continuous</font>

528
00:26:57,630 --> 00:27:03,960
<font color="#E5E5E5">development to actually</font><font color="#CCCCCC"> on demand</font>

529
00:27:00,680 --> 00:27:06,740
support the the<font color="#CCCCCC"> features which actual</font>

530
00:27:03,960 --> 00:27:10,020
customers need<font color="#E5E5E5"> or the community needs</font>

531
00:27:06,740 --> 00:27:12,680
<font color="#CCCCCC">was</font><font color="#E5E5E5"> it answer to a question</font><font color="#CCCCCC"> okay thank</font>

532
00:27:10,020 --> 00:27:12,680
<font color="#E5E5E5">you yes</font>

533
00:27:15,340 --> 00:27:41,929
right so basically<font color="#E5E5E5"> you're constructing</font>

534
00:27:17,690 --> 00:27:45,740
your your is a okay okay<font color="#E5E5E5"> so I think your</font>

535
00:27:41,930 --> 00:27:48,140
question<font color="#CCCCCC"> I try to rephrase it so one</font>

536
00:27:45,740 --> 00:27:51,560
part<font color="#E5E5E5"> of your question was why why just</font>

537
00:27:48,140 --> 00:27:54,680
<font color="#CCCCCC">don't why do we</font><font color="#E5E5E5"> need to what okay sorry</font>

538
00:27:51,560 --> 00:27:57,440
so he was what are the<font color="#CCCCCC"> benefits of</font><font color="#E5E5E5"> using</font>

539
00:27:54,680 --> 00:27:59,350
micro code to implement<font color="#E5E5E5"> this I sell</font>

540
00:27:57,440 --> 00:28:05,420
special instructions to architecture<font color="#CCCCCC"> and</font>

541
00:27:59,350 --> 00:28:06,469
then you also asked about yeah<font color="#E5E5E5"> why using</font>

542
00:28:05,420 --> 00:28:08,990
this processor

543
00:28:06,470 --> 00:28:12,830
yeah it's somewhat related<font color="#E5E5E5"> but I would</font>

544
00:28:08,990 --> 00:28:16,640
like<font color="#E5E5E5"> to take</font><font color="#CCCCCC"> it as two</font><font color="#E5E5E5"> parts so the</font>

545
00:28:12,830 --> 00:28:22,300
first part would be<font color="#E5E5E5"> sorry</font><font color="#CCCCCC"> I just want to</font>

546
00:28:16,640 --> 00:28:24,470
find<font color="#E5E5E5"> the slide so of course having a</font>

547
00:28:22,300 --> 00:28:26,330
simple way to<font color="#CCCCCC"> implement the back end</font><font color="#E5E5E5"> it</font>

548
00:28:24,470 --> 00:28:30,610
is good<font color="#E5E5E5"> it's good for emphasis because</font>

549
00:28:26,330 --> 00:28:33,020
<font color="#E5E5E5">emphasis is a processor company and and</font>

550
00:28:30,610 --> 00:28:35,419
we have expertise with the processor and

551
00:28:33,020 --> 00:28:39,320
<font color="#E5E5E5">micro code development so implementing</font>

552
00:28:35,420 --> 00:28:41,570
complex<font color="#E5E5E5"> compilers is not really our</font>

553
00:28:39,320 --> 00:28:43,189
field<font color="#E5E5E5"> so if we can have a simple</font>

554
00:28:41,570 --> 00:28:47,149
<font color="#CCCCCC">back-end that's just good but actually</font>

555
00:28:43,190 --> 00:28:49,990
<font color="#CCCCCC">that's just a side product but</font><font color="#E5E5E5"> we wanted</font>

556
00:28:47,150 --> 00:28:52,910
to<font color="#CCCCCC"> utilize micro code for e are these</font>

557
00:28:49,990 --> 00:28:55,340
five characteristics

558
00:28:52,910 --> 00:28:58,820
so in general we<font color="#CCCCCC"> believe that by</font>

559
00:28:55,340 --> 00:29:01,610
matching<font color="#CCCCCC"> LLVM the RDM assembly level</font><font color="#E5E5E5"> we</font>

560
00:28:58,820 --> 00:29:04,879
can have a rich instruction set<font color="#CCCCCC"> which</font>

561
00:29:01,610 --> 00:29:08,929
provides complex instructions so the

562
00:29:04,880 --> 00:29:11,840
binary<font color="#E5E5E5"> code the code the size required</font>

563
00:29:08,930 --> 00:29:15,860
in the program<font color="#E5E5E5"> memory for the executable</font>

564
00:29:11,840 --> 00:29:19,159
code can be minimized<font color="#CCCCCC"> smaller than other</font>

565
00:29:15,860 --> 00:29:24,580
mainstream architectures so that's a

566
00:29:19,160 --> 00:29:28,170
benefit<font color="#E5E5E5"> and also we believe that</font><font color="#CCCCCC"> this</font>

567
00:29:24,580 --> 00:29:30,810
micro coding the complex operations

568
00:29:28,170 --> 00:29:33,090
<font color="#CCCCCC">this helps helps improving the</font>

569
00:29:30,810 --> 00:29:34,530
performance<font color="#E5E5E5"> so in this case everything</font>

570
00:29:33,090 --> 00:29:37,919
the whole complex operation is in

571
00:29:34,530 --> 00:29:41,010
<font color="#CCCCCC">microcode</font><font color="#E5E5E5"> and otherwise if we would have</font>

572
00:29:37,920 --> 00:29:43,290
<font color="#E5E5E5">only a simple</font><font color="#CCCCCC"> RISC instruction set then</font>

573
00:29:41,010 --> 00:29:45,300
the same operation would take I don't

574
00:29:43,290 --> 00:29:47,460
<font color="#CCCCCC">know a sequence of of assembly</font>

575
00:29:45,300 --> 00:29:49,230
instructions<font color="#E5E5E5"> which would take extra time</font>

576
00:29:47,460 --> 00:29:53,010
<font color="#E5E5E5">to decode</font><font color="#CCCCCC"> all of the instructions and</font><font color="#E5E5E5"> so</font>

577
00:29:49,230 --> 00:29:58,830
on and so forth yes

578
00:29:53,010 --> 00:30:01,010
and then<font color="#CCCCCC"> by not using</font><font color="#E5E5E5"> other processors</font>

579
00:29:58,830 --> 00:30:04,350
in general<font color="#E5E5E5"> well because we have our own</font>

580
00:30:01,010 --> 00:30:06,870
<font color="#E5E5E5">processor technology and yeah</font><font color="#CCCCCC"> of course</font>

581
00:30:04,350 --> 00:30:23,760
we<font color="#CCCCCC"> we want to</font><font color="#E5E5E5"> exploit the possibilities</font>

582
00:30:06,870 --> 00:30:29,580
in that<font color="#E5E5E5"> yes</font><font color="#CCCCCC"> and then so yeah</font><font color="#E5E5E5"> it's better</font>

583
00:30:23,760 --> 00:30:32,629
<font color="#E5E5E5">to select directly so this is a bit more</font>

584
00:30:29,580 --> 00:30:35,520
detailed overview of what we<font color="#E5E5E5"> support</font>

585
00:30:32,630 --> 00:30:38,130
<font color="#E5E5E5">what is interesting is these green</font>

586
00:30:35,520 --> 00:30:40,260
things<font color="#CCCCCC"> so we have</font><font color="#E5E5E5"> the Java support we</font>

587
00:30:38,130 --> 00:30:44,430
have<font color="#CCCCCC"> AI cells and we plan to</font><font color="#E5E5E5"> have a</font>

588
00:30:40,260 --> 00:30:47,100
special part<font color="#E5E5E5"> of the instructions that</font>

589
00:30:44,430 --> 00:30:49,950
support<font color="#CCCCCC"> the SIS</font><font color="#E5E5E5"> this is domain-specific</font>

590
00:30:47,100 --> 00:30:52,350
instruction extensions so as I said

591
00:30:49,950 --> 00:30:56,580
<font color="#CCCCCC">micro coding provides us flexibility</font><font color="#E5E5E5"> and</font>

592
00:30:52,350 --> 00:30:59,669
configurability also and and we plan<font color="#CCCCCC"> to</font>

593
00:30:56,580 --> 00:31:04,889
generate microcode<font color="#E5E5E5"> foam from</font><font color="#CCCCCC"> hotspots of</font>

594
00:30:59,670 --> 00:31:07,950
application code<font color="#CCCCCC"> also so it is it not</font>

595
00:31:04,890 --> 00:31:11,870
<font color="#CCCCCC">just</font><font color="#E5E5E5"> I said</font><font color="#CCCCCC"> the general</font><font color="#E5E5E5"> purpose I said</font>

596
00:31:07,950 --> 00:31:16,040
itself can be utilized and exploit the

597
00:31:11,870 --> 00:31:18,840
processor core but we can also implement

598
00:31:16,040 --> 00:31:24,090
complex application specific features in

599
00:31:18,840 --> 00:31:27,199
micro code to improve the performance so

600
00:31:24,090 --> 00:31:27,199
that<font color="#E5E5E5"> that's also a special feature</font>

601
00:31:32,270 --> 00:31:36,960
existing bonds<font color="#E5E5E5"> is quite</font><font color="#CCCCCC"> really similar</font>

602
00:31:34,980 --> 00:31:37,530
<font color="#CCCCCC">to the</font><font color="#E5E5E5"> claims made yesterday in the</font>

603
00:31:36,960 --> 00:31:41,850
<font color="#CCCCCC">spine</font>

604
00:31:37,530 --> 00:31:48,960
talk so how does<font color="#E5E5E5"> okay</font>

605
00:31:41,850 --> 00:31:50,809
yes that's a<font color="#CCCCCC"> difficult</font><font color="#E5E5E5"> question</font><font color="#CCCCCC"> so we</font>

606
00:31:48,960 --> 00:31:52,800
didn't compare with risk<font color="#CCCCCC"> five and</font>

607
00:31:50,809 --> 00:31:56,389
probably that that's a missing thing

608
00:31:52,800 --> 00:32:00,059
which we should<font color="#CCCCCC"> do but we</font><font color="#E5E5E5"> believe that</font>

609
00:31:56,390 --> 00:32:01,920
risk 5 is still risk architecture so we

610
00:32:00,059 --> 00:32:04,379
liver<font color="#E5E5E5"> of course realized back to the</font>

611
00:32:01,920 --> 00:32:06,420
previous<font color="#CCCCCC"> question</font><font color="#E5E5E5"> so why we decided</font><font color="#CCCCCC"> to</font>

612
00:32:04,380 --> 00:32:07,230
<font color="#CCCCCC">implement something</font><font color="#E5E5E5"> specific for other</font>

613
00:32:06,420 --> 00:32:10,410
vehement

614
00:32:07,230 --> 00:32:13,590
yeah<font color="#E5E5E5"> risk</font><font color="#CCCCCC"> five is</font><font color="#E5E5E5"> there what we believe</font>

615
00:32:10,410 --> 00:32:16,700
that our<font color="#E5E5E5"> binary coding matching the</font>

616
00:32:13,590 --> 00:32:19,709
<font color="#CCCCCC">erbium assembly instructions</font><font color="#E5E5E5"> that</font>

617
00:32:16,700 --> 00:32:23,190
provides better<font color="#E5E5E5"> code density</font><font color="#CCCCCC"> I cannot</font>

618
00:32:19,710 --> 00:32:29,070
tell you right now<font color="#E5E5E5"> actual figures but</font>

619
00:32:23,190 --> 00:32:33,679
but we will check<font color="#CCCCCC"> that out yes is that</font>

620
00:32:29,070 --> 00:32:33,678
answer<font color="#E5E5E5"> okay yes</font>

621
00:32:34,550 --> 00:33:36,770
yes yes

622
00:33:32,500 --> 00:33:39,950
so about<font color="#E5E5E5"> interpreting different things</font>

623
00:33:36,770 --> 00:33:41,450
<font color="#E5E5E5">of course microcode so this is this is a</font>

624
00:33:39,950 --> 00:33:43,400
hardware<font color="#CCCCCC"> implementation</font>

625
00:33:41,450 --> 00:33:44,780
yeah it's similar very<font color="#E5E5E5"> low level and</font>

626
00:33:43,400 --> 00:33:47,750
<font color="#E5E5E5">it's very close</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> the hardware but</font>

627
00:33:44,780 --> 00:33:50,120
<font color="#CCCCCC">micro code is rather software and</font>

628
00:33:47,750 --> 00:33:52,430
hardware if<font color="#CCCCCC"> we find it to compare</font><font color="#E5E5E5"> and of</font>

629
00:33:50,120 --> 00:33:54,889
course it's possible<font color="#E5E5E5"> to</font><font color="#CCCCCC"> implement other</font>

630
00:33:52,430 --> 00:33:57,440
instructions<font color="#E5E5E5"> that other kind of</font>

631
00:33:54,890 --> 00:34:01,970
operations in micro code right<font color="#E5E5E5"> now we</font>

632
00:33:57,440 --> 00:34:04,790
are<font color="#E5E5E5"> don't have any plans to do it but</font>

633
00:34:01,970 --> 00:34:06,350
but it<font color="#E5E5E5"> will be a</font><font color="#CCCCCC"> possibility if we see</font>

634
00:34:04,790 --> 00:34:09,820
<font color="#E5E5E5">that there is</font><font color="#CCCCCC"> a customer need or</font>

635
00:34:06,350 --> 00:34:09,819
something for<font color="#E5E5E5"> that</font>

636
00:34:20,020 --> 00:34:28,130
<font color="#E5E5E5">okay okay</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> see</font><font color="#CCCCCC"> so you are rather</font>

637
00:34:23,150 --> 00:34:29,740
<font color="#E5E5E5">thinking about directly executing some</font>

638
00:34:28,130 --> 00:34:35,500
<font color="#E5E5E5">specialty instruction set or just</font>

639
00:34:29,739 --> 00:34:40,629
<font color="#E5E5E5">compiling it into into some good</font>

640
00:34:35,500 --> 00:35:00,020
instruction set architecture or so

641
00:34:40,630 --> 00:35:01,940
<font color="#E5E5E5">that's okay so your ideas to have this</font>

642
00:35:00,020 --> 00:35:04,190
<font color="#E5E5E5">microphone implementation as a reference</font>

643
00:35:01,940 --> 00:35:07,040
and<font color="#E5E5E5"> then move everything into hardware</font>

644
00:35:04,190 --> 00:35:09,380
yeah<font color="#E5E5E5"> okay so no we are not planning to</font>

645
00:35:07,040 --> 00:35:12,500
<font color="#E5E5E5">do</font><font color="#CCCCCC"> that now</font><font color="#E5E5E5"> so we believe that micro</font>

646
00:35:09,380 --> 00:35:16,520
<font color="#E5E5E5">code itself is yeah it allows us</font><font color="#CCCCCC"> the</font>

647
00:35:12,500 --> 00:35:21,160
flexibility to<font color="#CCCCCC"> be able</font><font color="#E5E5E5"> to change</font><font color="#CCCCCC"> - to be</font>

648
00:35:16,520 --> 00:35:23,870
able<font color="#CCCCCC"> to maybe</font><font color="#E5E5E5"> I show another slide then</font>

649
00:35:21,160 --> 00:35:28,399
so as I mentioned our core

650
00:35:23,870 --> 00:35:33,200
oh yes the first<font color="#E5E5E5"> your first question</font>

651
00:35:28,400 --> 00:35:35,120
sorry yes the the<font color="#E5E5E5"> performance so as I</font>

652
00:35:33,200 --> 00:35:37,460
said the I said implementation is still

653
00:35:35,120 --> 00:35:41,960
working progress<font color="#E5E5E5"> so</font><font color="#CCCCCC"> we couldn't really</font>

654
00:35:37,460 --> 00:35:45,380
execute<font color="#E5E5E5"> anything yet but we are close</font><font color="#CCCCCC"> so</font>

655
00:35:41,960 --> 00:35:48,800
<font color="#CCCCCC">I cannot</font><font color="#E5E5E5"> tell you any actual execution</font>

656
00:35:45,380 --> 00:35:53,450
time figures<font color="#E5E5E5"> but we expect that we can</font>

657
00:35:48,800 --> 00:35:56,720
be<font color="#E5E5E5"> better than ARM Cortex and zero</font><font color="#CCCCCC"> for</font>

658
00:35:53,450 --> 00:35:59,330
example<font color="#E5E5E5"> but but I don't have any figures</font>

659
00:35:56,720 --> 00:36:03,560
<font color="#E5E5E5">yet so that that part is work in</font>

660
00:35:59,330 --> 00:36:06,920
<font color="#E5E5E5">progress so</font><font color="#CCCCCC"> I can yeah</font><font color="#E5E5E5"> I can I can tell</font>

661
00:36:03,560 --> 00:36:11,270
you about our estimates but yeah that's

662
00:36:06,920 --> 00:36:13,210
<font color="#E5E5E5">nothing</font><font color="#CCCCCC"> but about keeping</font><font color="#E5E5E5"> everything in</font>

663
00:36:11,270 --> 00:36:16,840
<font color="#E5E5E5">micro code and not moving into</font><font color="#CCCCCC"> hardware</font>

664
00:36:13,210 --> 00:36:19,280
as I mentioned our<font color="#E5E5E5"> processor core is</font>

665
00:36:16,840 --> 00:36:21,730
quite<font color="#E5E5E5"> small compared to the mainstream</font>

666
00:36:19,280 --> 00:36:21,730
<font color="#E5E5E5">ones</font>

667
00:36:21,900 --> 00:36:26,790
it's theoretically<font color="#CCCCCC"> possible</font><font color="#E5E5E5"> while we</font>

668
00:36:24,180 --> 00:36:29,180
have 60<font color="#E5E5E5"> kilometer</font><font color="#CCCCCC"> what we what we</font><font color="#E5E5E5"> use</font>

669
00:36:26,790 --> 00:36:31,710
<font color="#CCCCCC">now and and we don't</font><font color="#E5E5E5"> have this really</font>

670
00:36:29,180 --> 00:36:33,330
massively multi-core solution yet but

671
00:36:31,710 --> 00:36:36,050
<font color="#CCCCCC">it's theoretically possible</font><font color="#E5E5E5"> actually</font><font color="#CCCCCC"> to</font>

672
00:36:33,330 --> 00:36:40,049
have<font color="#E5E5E5"> several thousands of course on</font>

673
00:36:36,050 --> 00:36:43,230
<font color="#E5E5E5">state-of-the-art processing</font><font color="#CCCCCC"> nodes</font><font color="#E5E5E5"> and in</font>

674
00:36:40,050 --> 00:36:45,270
this case each processor core has its

675
00:36:43,230 --> 00:36:47,130
own micro program and it's<font color="#CCCCCC"> softly</font>

676
00:36:45,270 --> 00:36:50,550
<font color="#CCCCCC">configurable so depending on</font><font color="#E5E5E5"> the</font>

677
00:36:47,130 --> 00:36:54,120
application<font color="#CCCCCC"> the the</font><font color="#E5E5E5"> software itself</font>

678
00:36:50,550 --> 00:36:57,000
would be able<font color="#E5E5E5"> to let's say dynamically</font>

679
00:36:54,120 --> 00:36:59,700
reconfigure repurpose each one of the

680
00:36:57,000 --> 00:37:02,850
cores separately depending<font color="#CCCCCC"> on the actual</font>

681
00:36:59,700 --> 00:37:04,649
<font color="#E5E5E5">application requirements so if we would</font>

682
00:37:02,850 --> 00:37:05,430
<font color="#CCCCCC">put</font><font color="#E5E5E5"> something into</font><font color="#CCCCCC"> Hardware then of</font>

683
00:37:04,650 --> 00:37:07,710
course this wouldn't<font color="#E5E5E5"> be possible</font>

684
00:37:05,430 --> 00:37:09,330
<font color="#E5E5E5">everything would be</font><font color="#CCCCCC"> fixed</font><font color="#E5E5E5"> so this kind</font>

685
00:37:07,710 --> 00:37:10,980
of flexibility we believe that will<font color="#E5E5E5"> be</font>

686
00:37:09,330 --> 00:37:13,220
very important in the future<font color="#CCCCCC"> that's</font><font color="#E5E5E5"> why</font>

687
00:37:10,980 --> 00:37:15,690
we want to<font color="#E5E5E5"> keep everything in micro code</font>

688
00:37:13,220 --> 00:37:17,850
<font color="#E5E5E5">all right so I hope</font><font color="#CCCCCC"> that answered your</font>

689
00:37:15,690 --> 00:37:20,490
<font color="#E5E5E5">question</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> beacons we can</font><font color="#E5E5E5"> take</font>

690
00:37:17,850 --> 00:37:22,799
<font color="#CCCCCC">that offline ok</font><font color="#E5E5E5"> so thank you for your</font>

691
00:37:20,490 --> 00:37:27,769
attention<font color="#E5E5E5"> again</font>

692
00:37:22,800 --> 00:37:27,769
[Applause]

