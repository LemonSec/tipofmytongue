1
00:00:04,779 --> 00:00:11,120
yeah hi everyone<font color="#CCCCCC"> I'm Martin this is max</font>

2
00:00:07,880 --> 00:00:12,769
we<font color="#CCCCCC"> are both</font><font color="#E5E5E5"> engineers at new</font><font color="#CCCCCC"> 4j and in</font>

3
00:00:11,120 --> 00:00:15,079
the previous<font color="#E5E5E5"> talk Stefan talked about</font>

4
00:00:12,769 --> 00:00:16,700
<font color="#CCCCCC">features of open</font><font color="#E5E5E5"> cipher and in this talk</font>

5
00:00:15,080 --> 00:00:19,279
<font color="#E5E5E5">we will show you how some of those</font>

6
00:00:16,700 --> 00:00:22,880
features<font color="#E5E5E5"> are implemented in our cycle</font>

7
00:00:19,279 --> 00:00:25,009
for<font color="#CCCCCC"> Apache</font><font color="#E5E5E5"> spark implementation so this</font>

8
00:00:22,880 --> 00:00:27,169
is a team so it's max<font color="#CCCCCC"> and i and then</font>

9
00:00:25,010 --> 00:00:28,430
matches our team lead<font color="#CCCCCC"> Stefan for</font><font color="#E5E5E5"> my team</font>

10
00:00:27,170 --> 00:00:30,010
in it and also<font color="#CCCCCC"> Phillip is working</font><font color="#E5E5E5"> on</font>

11
00:00:28,430 --> 00:00:33,410
<font color="#E5E5E5">that project</font>

12
00:00:30,010 --> 00:00:35,030
so why<font color="#CCCCCC"> hyper</font><font color="#E5E5E5"> for big data</font><font color="#CCCCCC"> I mean if you</font>

13
00:00:33,410 --> 00:00:36,889
know<font color="#CCCCCC"> cypher then you</font><font color="#E5E5E5"> probably also know</font>

14
00:00:35,030 --> 00:00:41,030
neo4j<font color="#E5E5E5"> and you</font><font color="#CCCCCC"> voce is</font><font color="#E5E5E5"> a transactional</font>

15
00:00:36,890 --> 00:00:43,250
database for<font color="#CCCCCC"> all TP workloads</font><font color="#E5E5E5"> and that's</font>

16
00:00:41,030 --> 00:00:45,049
we are<font color="#E5E5E5"> you</font><font color="#CCCCCC"> QB</font><font color="#E5E5E5"> position this database</font>

17
00:00:43,250 --> 00:00:47,659
system however<font color="#E5E5E5"> many of our customers</font>

18
00:00:45,049 --> 00:00:50,600
<font color="#E5E5E5">also have data lakes and already use big</font>

19
00:00:47,659 --> 00:00:53,000
data<font color="#CCCCCC"> tools for data into creation</font><font color="#E5E5E5"> so ETL</font>

20
00:00:50,600 --> 00:00:54,949
<font color="#E5E5E5">as you probably know it and also large</font>

21
00:00:53,000 --> 00:00:58,100
scale and a liquid processing so more

22
00:00:54,949 --> 00:01:01,250
like all<font color="#E5E5E5"> ap and we were thinking</font><font color="#CCCCCC"> about</font>

23
00:00:58,100 --> 00:01:02,750
how can<font color="#CCCCCC"> we help those people with</font><font color="#E5E5E5"> cipher</font>

24
00:01:01,250 --> 00:01:04,699
which they are used to because<font color="#E5E5E5"> they are</font>

25
00:01:02,750 --> 00:01:09,050
<font color="#CCCCCC">already customers how can they use</font>

26
00:01:04,699 --> 00:01:10,730
cipher<font color="#E5E5E5"> within those two scenarios so and</font>

27
00:01:09,050 --> 00:01:14,060
the<font color="#E5E5E5"> typical big data applications that</font>

28
00:01:10,730 --> 00:01:15,680
we see is just<font color="#CCCCCC"> just a collection here</font>

29
00:01:14,060 --> 00:01:18,050
<font color="#E5E5E5">collect data from user interactions at</font>

30
00:01:15,680 --> 00:01:20,290
<font color="#CCCCCC">websites or typically</font><font color="#E5E5E5"> that they use</font>

31
00:01:18,050 --> 00:01:22,490
internal data from their companies and

32
00:01:20,290 --> 00:01:25,310
put them together to<font color="#E5E5E5"> do some analytics</font>

33
00:01:22,490 --> 00:01:26,929
<font color="#E5E5E5">like billing marketing ERP system data</font>

34
00:01:25,310 --> 00:01:28,940
<font color="#E5E5E5">and so</font><font color="#CCCCCC"> on or they combine</font><font color="#E5E5E5"> it with</font>

35
00:01:26,930 --> 00:01:31,240
external<font color="#E5E5E5"> data ontological data for</font>

36
00:01:28,940 --> 00:01:34,039
example<font color="#CCCCCC"> and of course the goal is to</font>

37
00:01:31,240 --> 00:01:35,899
<font color="#E5E5E5">improve customer targeting supply chain</font>

38
00:01:34,040 --> 00:01:38,659
optimization<font color="#CCCCCC"> fraud detection and so on</font>

39
00:01:35,900 --> 00:01:40,640
<font color="#E5E5E5">so</font><font color="#CCCCCC"> all these all the craft use cases</font><font color="#E5E5E5"> but</font>

40
00:01:38,659 --> 00:01:42,440
at large scale<font color="#E5E5E5"> so in a common framework</font>

41
00:01:40,640 --> 00:01:45,380
<font color="#CCCCCC">that you see in</font><font color="#E5E5E5"> this environment</font><font color="#CCCCCC"> this</font>

42
00:01:42,440 --> 00:01:48,620
<font color="#CCCCCC">apache spark yeah a distributed data</font>

43
00:01:45,380 --> 00:01:51,470
flow system and we fought about<font color="#CCCCCC"> ok</font><font color="#E5E5E5"> how</font>

44
00:01:48,620 --> 00:01:52,880
can<font color="#CCCCCC"> we help</font><font color="#E5E5E5"> with</font><font color="#CCCCCC"> cypher</font><font color="#E5E5E5"> how can we help</font>

45
00:01:51,470 --> 00:01:56,330
those big data and<font color="#CCCCCC"> the reticular</font>

46
00:01:52,880 --> 00:01:58,190
applications so one pillar is data<font color="#CCCCCC"> into</font>

47
00:01:56,330 --> 00:02:00,440
creation so here you want<font color="#CCCCCC"> to be able to</font>

48
00:01:58,190 --> 00:02:03,560
use multiple<font color="#E5E5E5"> large-scale data sets</font>

49
00:02:00,440 --> 00:02:05,360
within your analytical<font color="#CCCCCC"> program you want</font>

50
00:02:03,560 --> 00:02:07,490
<font color="#E5E5E5">to</font><font color="#CCCCCC"> retain and reuse intermediate results</font>

51
00:02:05,360 --> 00:02:09,348
between queries<font color="#E5E5E5"> you want to</font><font color="#CCCCCC"> integrate</font>

52
00:02:07,490 --> 00:02:11,930
data<font color="#CCCCCC"> from multiple</font><font color="#E5E5E5"> data sources so not</font>

53
00:02:09,348 --> 00:02:13,670
only HDFS or in our case<font color="#CCCCCC"> neo voce but</font>

54
00:02:11,930 --> 00:02:15,920
also<font color="#CCCCCC"> maybe a relational database</font><font color="#E5E5E5"> and</font>

55
00:02:13,670 --> 00:02:17,349
then just get<font color="#E5E5E5"> it into a single</font><font color="#CCCCCC"> program</font>

56
00:02:15,920 --> 00:02:19,268
and start your analytics

57
00:02:17,349 --> 00:02:21,340
and of course you want<font color="#CCCCCC"> to support</font><font color="#E5E5E5"> he</font>

58
00:02:19,269 --> 00:02:23,170
<font color="#CCCCCC">Georgina State town and the second</font>

59
00:02:21,340 --> 00:02:24,969
pillar is<font color="#E5E5E5"> of course complex analytical</font>

60
00:02:23,170 --> 00:02:26,888
processing which means<font color="#CCCCCC"> that you</font><font color="#E5E5E5"> have</font>

61
00:02:24,969 --> 00:02:28,299
building blocks that were which are

62
00:02:26,889 --> 00:02:30,099
<font color="#E5E5E5">cipher queries and then you want to</font>

63
00:02:28,299 --> 00:02:31,930
<font color="#E5E5E5">compose them to build up</font><font color="#CCCCCC"> your complex</font>

64
00:02:30,099 --> 00:02:33,638
<font color="#E5E5E5">block flows and what's also nice about</font>

65
00:02:31,930 --> 00:02:36,280
<font color="#E5E5E5">the system like sparks</font><font color="#CCCCCC"> that you can</font>

66
00:02:33,639 --> 00:02:37,659
integrate our library<font color="#E5E5E5"> with any other</font>

67
00:02:36,280 --> 00:02:39,069
<font color="#CCCCCC">library that all said is already</font>

68
00:02:37,659 --> 00:02:42,280
<font color="#E5E5E5">available so like for machine learning</font>

69
00:02:39,069 --> 00:02:45,518
<font color="#E5E5E5">graph processing graphics or your own</font>

70
00:02:42,280 --> 00:02:46,989
domain specific business logic<font color="#E5E5E5"> and of</font>

71
00:02:45,519 --> 00:02:49,139
course<font color="#E5E5E5"> bark itself gives you all the</font>

72
00:02:46,989 --> 00:02:53,620
nice features of distributed execution

73
00:02:49,139 --> 00:02:55,449
on a shard nothing cluster typically so

74
00:02:53,620 --> 00:02:58,599
here we<font color="#CCCCCC"> introduced caps caps as a</font><font color="#E5E5E5"> Scala</font>

75
00:02:55,449 --> 00:03:00,189
library<font color="#E5E5E5"> cipher on Apache spark and its</font>

76
00:02:58,599 --> 00:03:03,339
main use<font color="#E5E5E5"> case is of course to execute</font>

77
00:03:00,189 --> 00:03:04,989
cipher on<font color="#CCCCCC"> these distributed crafts</font><font color="#E5E5E5"> you</font>

78
00:03:03,340 --> 00:03:07,120
can<font color="#E5E5E5"> integrate it in your sparked</font><font color="#CCCCCC"> and</font>

79
00:03:04,989 --> 00:03:09,099
<font color="#CCCCCC">wiggly pipeline at the moment we support</font>

80
00:03:07,120 --> 00:03:10,629
<font color="#E5E5E5">different data sources so for example</font>

81
00:03:09,099 --> 00:03:12,939
you can pull in your data from<font color="#CCCCCC"> neo J</font>

82
00:03:10,629 --> 00:03:16,209
into the spark environment<font color="#CCCCCC"> or you have</font>

83
00:03:12,939 --> 00:03:19,328
your<font color="#E5E5E5"> graph stored in HDFS or your local</font>

84
00:03:16,209 --> 00:03:21,489
<font color="#E5E5E5">file</font><font color="#CCCCCC"> system in a CSV format which we</font>

85
00:03:19,329 --> 00:03:24,519
support and it can handle heat or change

86
00:03:21,489 --> 00:03:26,199
data<font color="#E5E5E5"> and it's already able to compose</font>

87
00:03:24,519 --> 00:03:29,949
<font color="#CCCCCC">cyber</font><font color="#E5E5E5"> queries which you will see</font><font color="#CCCCCC"> later</font>

88
00:03:26,199 --> 00:03:32,109
in an<font color="#E5E5E5"> example in our demo so caps is</font>

89
00:03:29,949 --> 00:03:33,879
<font color="#E5E5E5">built by new</font><font color="#CCCCCC"> food chain and we donated</font>

90
00:03:32,109 --> 00:03:35,319
<font color="#E5E5E5">this</font><font color="#CCCCCC"> to the open cypher community that</font>

91
00:03:33,879 --> 00:03:38,168
<font color="#E5E5E5">Stefan introduced in the previous talk</font>

92
00:03:35,319 --> 00:03:40,478
it's already released on github<font color="#E5E5E5"> Apache</font>

93
00:03:38,169 --> 00:03:43,540
2.0 license<font color="#E5E5E5"> and we are</font><font color="#CCCCCC"> planning a</font>

94
00:03:40,479 --> 00:03:45,310
release<font color="#CCCCCC"> G a release on mid May</font><font color="#E5E5E5"> where we</font>

95
00:03:43,540 --> 00:03:47,769
have this<font color="#CCCCCC"> reported data source</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> new</font>

96
00:03:45,310 --> 00:03:50,319
<font color="#CCCCCC">VJ HDFS and hive</font><font color="#E5E5E5"> so you can also use</font>

97
00:03:47,769 --> 00:03:53,650
<font color="#E5E5E5">sequel to get data out of hive into our</font>

98
00:03:50,319 --> 00:03:54,970
system and<font color="#CCCCCC"> for the rest of 2018 or</font>

99
00:03:53,650 --> 00:03:57,040
beginning<font color="#E5E5E5"> of 2019</font>

100
00:03:54,970 --> 00:03:59,049
<font color="#E5E5E5">we also want</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> add more data</font><font color="#CCCCCC"> sources so</font>

101
00:03:57,040 --> 00:04:01,929
for example relational DBMS<font color="#E5E5E5"> like</font><font color="#CCCCCC"> Oracle</font>

102
00:03:59,049 --> 00:04:03,819
<font color="#CCCCCC">Postgres and so on and</font><font color="#E5E5E5"> also support</font>

103
00:04:01,930 --> 00:04:05,949
systems<font color="#E5E5E5"> that are basically Kremlin</font>

104
00:04:03,819 --> 00:04:07,839
<font color="#E5E5E5">focused but we have a translator from</font>

105
00:04:05,949 --> 00:04:12,669
cipher for Kremlin which you can<font color="#E5E5E5"> use to</font>

106
00:04:07,840 --> 00:04:16,060
also use data out<font color="#E5E5E5"> of those systems</font><font color="#CCCCCC"> ok so</font>

107
00:04:12,669 --> 00:04:18,699
let's get a bit more<font color="#E5E5E5"> technical</font><font color="#CCCCCC"> so what's</font>

108
00:04:16,060 --> 00:04:21,130
the architecture<font color="#E5E5E5"> so as you see on the</font>

109
00:04:18,699 --> 00:04:23,139
top<font color="#E5E5E5"> this</font><font color="#CCCCCC"> is a regular-size very just</font>

110
00:04:21,130 --> 00:04:25,630
looking for a person which loves a

111
00:04:23,139 --> 00:04:27,639
specific system<font color="#E5E5E5"> in this case new</font><font color="#CCCCCC"> voce</font>

112
00:04:25,630 --> 00:04:29,949
and there's an option match though<font color="#E5E5E5"> this</font>

113
00:04:27,639 --> 00:04:31,009
person<font color="#CCCCCC"> might also</font><font color="#E5E5E5"> love a spark and we</font>

114
00:04:29,949 --> 00:04:35,300
<font color="#E5E5E5">want to return the pearl</font>

115
00:04:31,009 --> 00:04:38,569
and the two systems so we have a

116
00:04:35,300 --> 00:04:40,699
multi-layer architecture<font color="#E5E5E5"> with in caps</font><font color="#CCCCCC"> we</font>

117
00:04:38,569 --> 00:04:42,169
start of course<font color="#CCCCCC"> with parsing</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> query</font>

118
00:04:40,699 --> 00:04:43,879
<font color="#E5E5E5">for</font><font color="#CCCCCC"> that we use the open type of</font>

119
00:04:42,169 --> 00:04:46,188
<font color="#CCCCCC">front-end which</font><font color="#E5E5E5"> is a shared module which</font>

120
00:04:43,879 --> 00:04:48,110
is<font color="#CCCCCC"> also</font><font color="#E5E5E5"> used by neo voce</font><font color="#CCCCCC"> so that gives</font>

121
00:04:46,189 --> 00:04:50,899
you you take the string in and get the

122
00:04:48,110 --> 00:04:52,699
abstract syntax tree out and it does all

123
00:04:50,899 --> 00:04:55,610
the parsing rewriting of<font color="#E5E5E5"> the query and</font>

124
00:04:52,699 --> 00:04:59,930
some algebraic<font color="#E5E5E5"> optimization then they</font>

125
00:04:55,610 --> 00:05:01,610
are escapes<font color="#E5E5E5"> caps is mainly used to</font>

126
00:04:59,930 --> 00:05:03,770
translate<font color="#E5E5E5"> the ast the abstract syntax</font>

127
00:05:01,610 --> 00:05:05,839
tree<font color="#E5E5E5"> into something that can</font><font color="#CCCCCC"> be executed</font>

128
00:05:03,770 --> 00:05:07,909
<font color="#E5E5E5">on data frames which is</font><font color="#CCCCCC"> the abstraction</font>

129
00:05:05,839 --> 00:05:10,309
<font color="#CCCCCC">that spark gives you so it's basically a</font>

130
00:05:07,909 --> 00:05:12,139
translator between those two two things

131
00:05:10,309 --> 00:05:14,809
<font color="#E5E5E5">and it also gives you the ability to</font>

132
00:05:12,139 --> 00:05:16,520
<font color="#E5E5E5">import data of course export data and we</font>

133
00:05:14,809 --> 00:05:18,620
<font color="#E5E5E5">also have a schema</font><font color="#CCCCCC"> in type handling</font>

134
00:05:16,520 --> 00:05:21,229
because as you might know data frames

135
00:05:18,620 --> 00:05:22,939
have a fixed schema<font color="#E5E5E5"> and an Evo J or</font>

136
00:05:21,229 --> 00:05:25,159
property<font color="#E5E5E5"> graph in general doesn't have a</font>

137
00:05:22,939 --> 00:05:28,219
fixed schema<font color="#E5E5E5"> so there needs to be some</font>

138
00:05:25,159 --> 00:05:30,289
handling<font color="#E5E5E5"> between those two worlds which</font>

139
00:05:28,219 --> 00:05:32,509
I will<font color="#CCCCCC"> explain later of it and then</font>

140
00:05:30,289 --> 00:05:34,550
after keps when we have our<font color="#E5E5E5"> data frame</font>

141
00:05:32,509 --> 00:05:36,469
program we<font color="#CCCCCC"> just handed over to spark and</font>

142
00:05:34,550 --> 00:05:38,719
spark has this nice thing called

143
00:05:36,469 --> 00:05:41,300
catalyst optimizer which is a rule-based

144
00:05:38,719 --> 00:05:43,459
optimizer<font color="#CCCCCC"> for query optimization</font><font color="#E5E5E5"> which</font>

145
00:05:41,300 --> 00:05:46,550
gives you some<font color="#E5E5E5"> improvements on your on</font>

146
00:05:43,459 --> 00:05:48,199
<font color="#CCCCCC">your</font><font color="#E5E5E5"> run times probably and then at the</font>

147
00:05:46,550 --> 00:05:52,610
end<font color="#CCCCCC"> of course</font><font color="#E5E5E5"> the spark runtime which</font>

148
00:05:48,199 --> 00:05:54,680
<font color="#E5E5E5">executes the query on your cluster so</font>

149
00:05:52,610 --> 00:05:59,360
this is the high level view of the

150
00:05:54,680 --> 00:06:01,209
<font color="#E5E5E5">system okay so we had some you have some</font>

151
00:05:59,360 --> 00:06:04,399
as I already mentioned there are some

152
00:06:01,209 --> 00:06:06,499
different differences between<font color="#E5E5E5"> neo4j and</font>

153
00:06:04,399 --> 00:06:09,499
<font color="#CCCCCC">apache spark or in specific the data</font>

154
00:06:06,499 --> 00:06:11,389
frame<font color="#CCCCCC"> API</font><font color="#E5E5E5"> so at first let's talk</font><font color="#CCCCCC"> about</font>

155
00:06:09,499 --> 00:06:13,069
<font color="#E5E5E5">the craft format</font><font color="#CCCCCC"> Nouveau J as you might</font>

156
00:06:11,389 --> 00:06:15,349
know it's the<font color="#CCCCCC"> so called native craft</font>

157
00:06:13,069 --> 00:06:17,809
database which<font color="#CCCCCC"> means</font><font color="#E5E5E5"> it's build up from</font>

158
00:06:15,349 --> 00:06:19,069
top<font color="#E5E5E5"> to the from bottom to top optimized</font>

159
00:06:17,809 --> 00:06:21,949
for craft operations or the storage

160
00:06:19,069 --> 00:06:23,959
layout<font color="#CCCCCC"> up</font><font color="#E5E5E5"> to declare a language</font><font color="#CCCCCC"> it's all</font>

161
00:06:21,949 --> 00:06:25,969
optimized for crafts<font color="#CCCCCC"> whereas data frames</font>

162
00:06:23,959 --> 00:06:27,469
which is<font color="#E5E5E5"> the abstraction in Apache spark</font>

163
00:06:25,969 --> 00:06:29,689
<font color="#E5E5E5">it's more like a table in a relational</font>

164
00:06:27,469 --> 00:06:31,669
DBMS so it has a<font color="#E5E5E5"> fixed schema you have</font>

165
00:06:29,689 --> 00:06:34,580
two relational<font color="#E5E5E5"> operators like</font><font color="#CCCCCC"> join</font><font color="#E5E5E5"> Union</font>

166
00:06:31,669 --> 00:06:37,279
and so on<font color="#E5E5E5"> and let's of course a gap</font>

167
00:06:34,580 --> 00:06:38,779
there yeah as I mentioned the operators

168
00:06:37,279 --> 00:06:40,639
<font color="#E5E5E5">we have</font><font color="#CCCCCC"> relational operators on the</font>

169
00:06:38,779 --> 00:06:42,499
spark<font color="#CCCCCC"> side and we</font><font color="#E5E5E5"> have native craft</font>

170
00:06:40,639 --> 00:06:44,250
operators on the<font color="#CCCCCC"> Mia</font><font color="#E5E5E5"> voce side so for</font>

171
00:06:42,499 --> 00:06:45,810
example expand<font color="#E5E5E5"> is an operator</font>

172
00:06:44,250 --> 00:06:48,540
we are get all the relationships of<font color="#E5E5E5"> a</font>

173
00:06:45,810 --> 00:06:50,700
specific note or VAR<font color="#CCCCCC"> expand</font><font color="#E5E5E5"> to compute a</font>

174
00:06:48,540 --> 00:06:54,590
<font color="#E5E5E5">variable length path expression so like</font>

175
00:06:50,700 --> 00:06:57,030
someone knows someone over<font color="#E5E5E5"> 1 to 10 hops</font>

176
00:06:54,590 --> 00:06:59,340
then the schema<font color="#E5E5E5"> I already mentioned we</font>

177
00:06:57,030 --> 00:07:00,750
have schema optionality on neo4j<font color="#CCCCCC"> site so</font>

178
00:06:59,340 --> 00:07:04,140
we<font color="#E5E5E5"> have some constraints on the schema</font>

179
00:07:00,750 --> 00:07:06,270
but<font color="#E5E5E5"> you can also have even for the same</font>

180
00:07:04,140 --> 00:07:07,530
label<font color="#CCCCCC"> for node you can have a different</font>

181
00:07:06,270 --> 00:07:09,599
kind<font color="#E5E5E5"> of schema for that so different</font>

182
00:07:07,530 --> 00:07:12,179
<font color="#CCCCCC">kind of</font><font color="#E5E5E5"> properties on</font><font color="#CCCCCC"> inspark</font><font color="#E5E5E5"> side this</font>

183
00:07:09,600 --> 00:07:14,460
<font color="#E5E5E5">is all fixed</font><font color="#CCCCCC"> and then of course</font><font color="#E5E5E5"> there's</font>

184
00:07:12,180 --> 00:07:15,960
the type system<font color="#E5E5E5"> we have the</font><font color="#CCCCCC"> cipher</font><font color="#E5E5E5"> type</font>

185
00:07:14,460 --> 00:07:17,700
system<font color="#CCCCCC"> and on the</font><font color="#E5E5E5"> other hand this box</font>

186
00:07:15,960 --> 00:07:20,190
equal type system which are not

187
00:07:17,700 --> 00:07:24,570
compatible by default so those have<font color="#E5E5E5"> also</font>

188
00:07:20,190 --> 00:07:26,400
to be mapped so let's talk<font color="#CCCCCC"> about a few</font>

189
00:07:24,570 --> 00:07:28,860
of<font color="#E5E5E5"> those challenges at first about the</font>

190
00:07:26,400 --> 00:07:31,530
schema so as I said we require a schema

191
00:07:28,860 --> 00:07:34,470
<font color="#E5E5E5">for spark data frames and if you use for</font>

192
00:07:31,530 --> 00:07:36,539
<font color="#E5E5E5">example</font><font color="#CCCCCC"> our HDFS data source</font><font color="#E5E5E5"> which I</font>

193
00:07:34,470 --> 00:07:38,040
said is a CSV<font color="#E5E5E5"> then of course you have</font>

194
00:07:36,540 --> 00:07:40,590
already<font color="#E5E5E5"> a schema available which is</font>

195
00:07:38,040 --> 00:07:42,390
<font color="#E5E5E5">explicitly defined and we can just</font>

196
00:07:40,590 --> 00:07:44,640
<font color="#E5E5E5">derive from there if you for example</font>

197
00:07:42,390 --> 00:07:46,409
<font color="#E5E5E5">load your data out</font><font color="#CCCCCC"> of neo voce</font><font color="#E5E5E5"> we</font>

198
00:07:44,640 --> 00:07:48,210
implicitly infer the schema<font color="#E5E5E5"> while</font>

199
00:07:46,410 --> 00:07:52,380
<font color="#CCCCCC">loading</font><font color="#E5E5E5"> the data so we build it up</font><font color="#CCCCCC"> while</font>

200
00:07:48,210 --> 00:07:54,239
we see the data and for<font color="#E5E5E5"> example if you</font>

201
00:07:52,380 --> 00:07:56,190
look<font color="#E5E5E5"> at this graph here</font><font color="#CCCCCC"> I hope you can</font>

202
00:07:54,240 --> 00:07:58,110
see some of<font color="#E5E5E5"> it it's not that complicated</font>

203
00:07:56,190 --> 00:08:01,950
just<font color="#E5E5E5"> two persons that know each other</font>

204
00:07:58,110 --> 00:08:03,870
<font color="#E5E5E5">and they love different systems and for</font>

205
00:08:01,950 --> 00:08:04,289
<font color="#E5E5E5">that example a schema would look like</font>

206
00:08:03,870 --> 00:08:06,510
this

207
00:08:04,290 --> 00:08:09,360
you have the<font color="#E5E5E5"> node labels for example</font>

208
00:08:06,510 --> 00:08:12,390
person and<font color="#CCCCCC"> the person</font><font color="#E5E5E5"> has two properties</font>

209
00:08:09,360 --> 00:08:14,100
name which is of<font color="#E5E5E5"> type string</font><font color="#CCCCCC"> and year of</font>

210
00:08:12,390 --> 00:08:15,960
<font color="#CCCCCC">birth which is</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> type integer and it's</font>

211
00:08:14,100 --> 00:08:19,050
nullable because not all persons have

212
00:08:15,960 --> 00:08:21,299
the<font color="#E5E5E5"> year of birth property key and then</font>

213
00:08:19,050 --> 00:08:23,280
there's also the employee label and the

214
00:08:21,300 --> 00:08:25,800
<font color="#CCCCCC">Emory is an implied label so if someone</font>

215
00:08:23,280 --> 00:08:28,609
is an employee<font color="#CCCCCC"> your he also is a person</font>

216
00:08:25,800 --> 00:08:30,870
because those two<font color="#CCCCCC"> always appear together</font>

217
00:08:28,610 --> 00:08:33,539
<font color="#E5E5E5">so</font><font color="#CCCCCC"> person employee also</font><font color="#E5E5E5"> has the name</font>

218
00:08:30,870 --> 00:08:35,010
<font color="#E5E5E5">property in</font><font color="#CCCCCC"> that example here and then</font>

219
00:08:33,539 --> 00:08:37,380
the same for<font color="#E5E5E5"> relationship types you have</font>

220
00:08:35,010 --> 00:08:39,539
<font color="#E5E5E5">the knows relationship between those two</font>

221
00:08:37,380 --> 00:08:42,799
<font color="#E5E5E5">persons which has a specific property</font>

222
00:08:39,539 --> 00:08:42,799
<font color="#E5E5E5">key sins of type integer</font>

223
00:08:43,510 --> 00:08:47,529
the second challenge<font color="#E5E5E5"> is the craft</font>

224
00:08:45,550 --> 00:08:49,089
representation so from a logical point

225
00:08:47,529 --> 00:08:51,279
of<font color="#E5E5E5"> view you have</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> property craft so</font>

226
00:08:49,089 --> 00:08:53,860
how do you<font color="#CCCCCC"> represent that</font><font color="#E5E5E5"> in data frames</font>

227
00:08:51,279 --> 00:08:55,689
and data frames and set our tables<font color="#E5E5E5"> so we</font>

228
00:08:53,860 --> 00:08:57,940
chose the concept of<font color="#CCCCCC"> node and</font>

229
00:08:55,690 --> 00:09:00,670
relationship tables which<font color="#E5E5E5"> are</font>

230
00:08:57,940 --> 00:09:02,889
constructed<font color="#CCCCCC"> by label so in that example</font>

231
00:09:00,670 --> 00:09:04,959
we<font color="#E5E5E5"> have one table</font><font color="#CCCCCC"> for persons and one</font>

232
00:09:02,889 --> 00:09:07,180
table for<font color="#E5E5E5"> the systems that you see on</font>

233
00:09:04,959 --> 00:09:09,099
the bottom and the<font color="#CCCCCC"> emply for example</font>

234
00:09:07,180 --> 00:09:10,660
which<font color="#E5E5E5"> I said is an implied label so it</font>

235
00:09:09,100 --> 00:09:13,029
always<font color="#CCCCCC"> occurs together with the person</font>

236
00:09:10,660 --> 00:09:15,189
<font color="#CCCCCC">label</font><font color="#E5E5E5"> is just an additional column in</font>

237
00:09:13,029 --> 00:09:16,990
that<font color="#CCCCCC"> node table here it's a boolean</font>

238
00:09:15,190 --> 00:09:19,029
<font color="#E5E5E5">column so it's just true/false if that</font>

239
00:09:16,990 --> 00:09:20,589
person is also an employee and then you

240
00:09:19,029 --> 00:09:22,480
have all the properties<font color="#E5E5E5"> here so like you</font>

241
00:09:20,589 --> 00:09:24,519
would<font color="#E5E5E5"> also model it in a relational</font>

242
00:09:22,480 --> 00:09:26,740
database of course<font color="#E5E5E5"> so and then you have</font>

243
00:09:24,519 --> 00:09:30,070
<font color="#CCCCCC">no</font><font color="#E5E5E5"> properties for those optional</font>

244
00:09:26,740 --> 00:09:32,980
property keys here same<font color="#E5E5E5"> for relation</font>

245
00:09:30,070 --> 00:09:34,899
<font color="#E5E5E5">relationships relationship table as we</font>

246
00:09:32,980 --> 00:09:37,540
call it where<font color="#E5E5E5"> you're in addition also</font>

247
00:09:34,899 --> 00:09:40,029
have the source and the target<font color="#CCCCCC"> or start</font>

248
00:09:37,540 --> 00:09:41,529
and end node identifier<font color="#E5E5E5"> of this</font>

249
00:09:40,029 --> 00:09:43,360
<font color="#E5E5E5">relationship and then also the</font>

250
00:09:41,529 --> 00:09:47,560
properties<font color="#E5E5E5"> that this relationship might</font>

251
00:09:43,360 --> 00:09:50,290
<font color="#CCCCCC">have</font><font color="#E5E5E5"> okay the next challenge is</font><font color="#CCCCCC"> Larry</font>

252
00:09:47,560 --> 00:09:54,040
translation so again we have our psychic

253
00:09:50,290 --> 00:09:59,730
<font color="#CCCCCC">theory here and the physical view</font><font color="#E5E5E5"> is of</font>

254
00:09:54,040 --> 00:10:02,260
course very optimization or carry engine

255
00:09:59,730 --> 00:10:04,209
<font color="#CCCCCC">clary</font><font color="#E5E5E5"> engine handling in general so we</font>

256
00:10:02,260 --> 00:10:05,740
have on the left side<font color="#E5E5E5"> our input which</font>

257
00:10:04,209 --> 00:10:09,069
are the no tables<font color="#E5E5E5"> that I just showed you</font>

258
00:10:05,740 --> 00:10:10,870
<font color="#E5E5E5">and then we have</font><font color="#CCCCCC"> a series of operators</font>

259
00:10:09,069 --> 00:10:12,790
<font color="#E5E5E5">and in the end we have a result which is</font>

260
00:10:10,870 --> 00:10:15,160
<font color="#CCCCCC">the result</font><font color="#E5E5E5"> of our query so this is</font>

261
00:10:12,790 --> 00:10:18,490
basically where<font color="#E5E5E5"> the magic happens within</font>

262
00:10:15,160 --> 00:10:20,889
<font color="#E5E5E5">the system and today I want to explain</font>

263
00:10:18,490 --> 00:10:22,600
some of<font color="#E5E5E5"> this magic at least so on the</font>

264
00:10:20,889 --> 00:10:24,490
left<font color="#E5E5E5"> side you</font><font color="#CCCCCC"> see the same</font><font color="#E5E5E5"> architecture</font>

265
00:10:22,600 --> 00:10:27,670
as before<font color="#CCCCCC"> it's a high-level view of</font><font color="#E5E5E5"> the</font>

266
00:10:24,490 --> 00:10:31,420
<font color="#CCCCCC">system here is Capps and within</font><font color="#E5E5E5"> Capps we</font>

267
00:10:27,670 --> 00:10:33,569
have four phases of<font color="#CCCCCC"> clary planning so</font>

268
00:10:31,420 --> 00:10:36,459
the first phase is a so-called

269
00:10:33,569 --> 00:10:38,110
<font color="#E5E5E5">intermediate language phase</font><font color="#CCCCCC"> it's an</font>

270
00:10:36,459 --> 00:10:39,670
intimate representation of the<font color="#CCCCCC"> kaveri</font>

271
00:10:38,110 --> 00:10:41,980
which<font color="#E5E5E5"> is</font><font color="#CCCCCC"> back-end agnostic because</font>

272
00:10:39,670 --> 00:10:45,689
<font color="#CCCCCC">one-one our goal besides doing that on</font>

273
00:10:41,980 --> 00:10:49,209
SPARC is being able to port this this

274
00:10:45,690 --> 00:10:52,240
this project<font color="#CCCCCC"> to our</font><font color="#E5E5E5"> back-end</font><font color="#CCCCCC"> system so</font>

275
00:10:49,209 --> 00:10:54,550
maybe an in-memory system or<font color="#E5E5E5"> Apache</font>

276
00:10:52,240 --> 00:10:56,350
<font color="#CCCCCC">fling for example something</font><font color="#E5E5E5"> like that so</font>

277
00:10:54,550 --> 00:10:57,130
this<font color="#E5E5E5"> is an a back-end agnostic</font>

278
00:10:56,350 --> 00:10:59,170
<font color="#E5E5E5">everywhere person</font>

279
00:10:57,130 --> 00:11:01,210
at first<font color="#E5E5E5"> so we translate the ast into</font>

280
00:10:59,170 --> 00:11:03,040
that and then<font color="#E5E5E5"> we start with logical</font>

281
00:11:01,210 --> 00:11:05,230
planning so this is all this<font color="#E5E5E5"> is still</font>

282
00:11:03,040 --> 00:11:06,610
<font color="#E5E5E5">craft specific operator so on the</font>

283
00:11:05,230 --> 00:11:08,560
logical planning side you still have

284
00:11:06,610 --> 00:11:10,650
operators<font color="#E5E5E5"> like expand bar expand that I</font>

285
00:11:08,560 --> 00:11:13,479
mentioned<font color="#CCCCCC"> before</font><font color="#E5E5E5"> and we do some basic</font>

286
00:11:10,650 --> 00:11:15,720
additional optimization<font color="#E5E5E5"> to what the</font>

287
00:11:13,480 --> 00:11:17,950
front-end is<font color="#CCCCCC"> already doing</font><font color="#E5E5E5"> at this place</font>

288
00:11:15,720 --> 00:11:20,140
<font color="#CCCCCC">then we have two flat planning the flat</font>

289
00:11:17,950 --> 00:11:24,340
planning is the the the step where we

290
00:11:20,140 --> 00:11:27,160
translate or<font color="#E5E5E5"> where we compute the</font><font color="#CCCCCC"> column</font>

291
00:11:24,340 --> 00:11:30,160
layout of the resulting data frames<font color="#CCCCCC"> so</font>

292
00:11:27,160 --> 00:11:31,959
if you for example do an expand so go

293
00:11:30,160 --> 00:11:33,790
<font color="#E5E5E5">from a node to</font><font color="#CCCCCC"> their relationships</font>

294
00:11:31,960 --> 00:11:35,620
then you need to compute the column

295
00:11:33,790 --> 00:11:37,750
layout for the resulting data frame so

296
00:11:35,620 --> 00:11:39,820
the schema basically and this<font color="#CCCCCC"> is</font><font color="#E5E5E5"> what</font>

297
00:11:37,750 --> 00:11:41,380
the flat planning does and then in the

298
00:11:39,820 --> 00:11:43,930
physical planning this is<font color="#E5E5E5"> where we</font>

299
00:11:41,380 --> 00:11:45,939
<font color="#E5E5E5">actually translate</font><font color="#CCCCCC"> the graph native</font>

300
00:11:43,930 --> 00:11:48,729
operators like<font color="#E5E5E5"> expand bar expand and so</font>

301
00:11:45,940 --> 00:11:52,360
on into<font color="#E5E5E5"> data frame operations like joy</font>

302
00:11:48,730 --> 00:11:54,460
and select distinct and so on and then

303
00:11:52,360 --> 00:11:56,590
of course<font color="#CCCCCC"> like I</font><font color="#E5E5E5"> said</font><font color="#CCCCCC"> before this is</font>

304
00:11:54,460 --> 00:11:58,120
handed over to the<font color="#E5E5E5"> SPARC engine again</font><font color="#CCCCCC"> is</font>

305
00:11:56,590 --> 00:12:01,930
<font color="#E5E5E5">being optimized by the catalyst</font>

306
00:11:58,120 --> 00:12:03,610
optimizer and executed<font color="#CCCCCC"> by the runtime ok</font>

307
00:12:01,930 --> 00:12:05,290
and when you finish<font color="#E5E5E5"> a query you have of</font>

308
00:12:03,610 --> 00:12:07,000
<font color="#E5E5E5">course the result available which is</font>

309
00:12:05,290 --> 00:12:10,089
again a data frame which we call<font color="#E5E5E5"> a</font>

310
00:12:07,000 --> 00:12:12,190
<font color="#CCCCCC">cipher result</font><font color="#E5E5E5"> which contains a each row</font>

311
00:12:10,090 --> 00:12:15,220
represents one result so in that case we

312
00:12:12,190 --> 00:12:18,130
wanted<font color="#E5E5E5"> to return the the</font><font color="#CCCCCC"> user and the</font>

313
00:12:15,220 --> 00:12:20,260
two systems<font color="#E5E5E5"> so for</font><font color="#CCCCCC"> example</font><font color="#E5E5E5"> Ellis here as</font>

314
00:12:18,130 --> 00:12:23,530
you can<font color="#CCCCCC"> see it</font><font color="#E5E5E5"> loves</font><font color="#CCCCCC"> spark</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> near</font>

315
00:12:20,260 --> 00:12:26,830
<font color="#CCCCCC">Vijay and pop</font><font color="#E5E5E5"> only love's near</font><font color="#CCCCCC"> voce</font><font color="#E5E5E5"> so</font>

316
00:12:23,530 --> 00:12:31,000
the rest of<font color="#E5E5E5"> the row here is filled up</font>

317
00:12:26,830 --> 00:12:33,760
with<font color="#CCCCCC"> nada use ok so now that</font><font color="#E5E5E5"> we know</font>

318
00:12:31,000 --> 00:12:35,650
<font color="#CCCCCC">some internals at least</font><font color="#E5E5E5"> of keps we want</font>

319
00:12:33,760 --> 00:12:39,550
to talk<font color="#E5E5E5"> about the API before</font><font color="#CCCCCC"> we show</font><font color="#E5E5E5"> you</font>

320
00:12:35,650 --> 00:12:41,500
the demo<font color="#E5E5E5"> so we try to adapt our API to</font>

321
00:12:39,550 --> 00:12:43,780
or make it pretty similar to<font color="#E5E5E5"> what a</font>

322
00:12:41,500 --> 00:12:45,790
spark already provides to you or with

323
00:12:43,780 --> 00:12:47,740
the data frame API to make<font color="#E5E5E5"> it especially</font>

324
00:12:45,790 --> 00:12:51,459
easy for people<font color="#CCCCCC"> that are used</font><font color="#E5E5E5"> to spark</font>

325
00:12:47,740 --> 00:12:53,680
to also use<font color="#E5E5E5"> caps the central point is</font>

326
00:12:51,460 --> 00:12:56,470
the<font color="#E5E5E5"> so-called</font><font color="#CCCCCC"> cap session as analogous</font>

327
00:12:53,680 --> 00:12:59,109
<font color="#E5E5E5">to the spark session and this is the</font>

328
00:12:56,470 --> 00:13:01,270
minimal<font color="#E5E5E5"> program to run a psychic very on</font>

329
00:12:59,110 --> 00:13:02,830
<font color="#E5E5E5">Apache spark so in the first line for</font>

330
00:13:01,270 --> 00:13:04,840
example<font color="#CCCCCC"> just create a local session</font>

331
00:13:02,830 --> 00:13:07,780
which instantiate this bar cluster and

332
00:13:04,840 --> 00:13:10,089
so on<font color="#E5E5E5"> and then in the second line</font><font color="#CCCCCC"> we</font>

333
00:13:07,780 --> 00:13:10,660
specify a<font color="#E5E5E5"> data source by just saying</font>

334
00:13:10,089 --> 00:13:12,790
session

335
00:13:10,660 --> 00:13:14,620
read from<font color="#E5E5E5"> and then we give them an a URI</font>

336
00:13:12,790 --> 00:13:16,240
<font color="#E5E5E5">where the scheme defines which kind of</font>

337
00:13:14,620 --> 00:13:18,550
data so that<font color="#E5E5E5"> is so in that case you</font>

338
00:13:16,240 --> 00:13:21,250
might not read it<font color="#CCCCCC"> but it's HDFS</font><font color="#E5E5E5"> plus</font>

339
00:13:18,550 --> 00:13:23,709
<font color="#CCCCCC">here</font><font color="#E5E5E5"> is V which internally triggers the</font>

340
00:13:21,250 --> 00:13:26,410
right code<font color="#E5E5E5"> path to read to get the right</font>

341
00:13:23,709 --> 00:13:28,329
reader for this kind of graph<font color="#E5E5E5"> and then</font>

342
00:13:26,410 --> 00:13:29,769
the<font color="#CCCCCC"> address we are taught</font><font color="#E5E5E5"> with an HDFS</font>

343
00:13:28,329 --> 00:13:31,719
<font color="#E5E5E5">on line four</font>

344
00:13:29,769 --> 00:13:34,779
we actually<font color="#E5E5E5"> blindfolds</font><font color="#CCCCCC"> actually then</font>

345
00:13:31,720 --> 00:13:38,529
free but whatever<font color="#E5E5E5"> it actually triggers</font>

346
00:13:34,779 --> 00:13:40,629
<font color="#E5E5E5">to</font><font color="#CCCCCC"> Kaveri and on line five</font><font color="#E5E5E5"> four we</font>

347
00:13:38,529 --> 00:13:43,120
trigger the<font color="#CCCCCC"> reprinted result which of</font>

348
00:13:40,629 --> 00:13:46,329
<font color="#CCCCCC">what would lead to</font><font color="#E5E5E5"> that console output</font>

349
00:13:43,120 --> 00:13:50,050
that<font color="#E5E5E5"> you can see here as you are used to</font>

350
00:13:46,329 --> 00:13:51,790
<font color="#E5E5E5">from new</font><font color="#CCCCCC"> shapes then there's the second</font>

351
00:13:50,050 --> 00:13:54,878
example<font color="#E5E5E5"> which</font><font color="#CCCCCC"> of course is just</font>

352
00:13:51,790 --> 00:13:56,620
<font color="#CCCCCC">available for the first row to read so</font>

353
00:13:54,879 --> 00:13:59,529
on the left side<font color="#CCCCCC"> yeah sorry about</font><font color="#E5E5E5"> that</font>

354
00:13:56,620 --> 00:14:01,420
<font color="#CCCCCC">but on the left side</font><font color="#E5E5E5"> this is just</font>

355
00:13:59,529 --> 00:14:04,720
regular<font color="#E5E5E5"> spark code to create data frames</font>

356
00:14:01,420 --> 00:14:06,519
on top<font color="#E5E5E5"> just trust me this constructs a</font>

357
00:14:04,720 --> 00:14:09,339
<font color="#CCCCCC">no</font><font color="#E5E5E5"> data frame and this a relationship</font>

358
00:14:06,519 --> 00:14:12,370
<font color="#CCCCCC">data frame with some schema and then on</font>

359
00:14:09,339 --> 00:14:14,529
the right<font color="#CCCCCC"> side this is</font><font color="#E5E5E5"> the the program</font>

360
00:14:12,370 --> 00:14:16,600
that<font color="#CCCCCC"> actually uses</font><font color="#E5E5E5"> those data frames to</font>

361
00:14:14,529 --> 00:14:18,399
run a query on it and we use a<font color="#E5E5E5"> concept</font>

362
00:14:16,600 --> 00:14:20,560
called entity mapping which is basically

363
00:14:18,399 --> 00:14:22,870
just a mapping<font color="#E5E5E5"> between the column names</font>

364
00:14:20,560 --> 00:14:24,339
in the spark data frame and<font color="#E5E5E5"> the concepts</font>

365
00:14:22,870 --> 00:14:26,319
that we need to<font color="#E5E5E5"> construct notes and</font>

366
00:14:24,339 --> 00:14:28,959
relationships from that so<font color="#E5E5E5"> we you have</font>

367
00:14:26,319 --> 00:14:30,639
to tell us<font color="#CCCCCC"> we have</font><font color="#E5E5E5"> to find the node ID</font>

368
00:14:28,959 --> 00:14:33,369
for<font color="#CCCCCC"> example we have to</font><font color="#E5E5E5"> find a specific</font>

369
00:14:30,639 --> 00:14:35,470
<font color="#E5E5E5">property key in which column and same</font>

370
00:14:33,370 --> 00:14:37,660
<font color="#CCCCCC">for relationships with addition of of</font>

371
00:14:35,470 --> 00:14:40,060
course start<font color="#E5E5E5"> and end node key so it's</font>

372
00:14:37,660 --> 00:14:46,469
pretty<font color="#E5E5E5"> simple so and that's the goal of</font>

373
00:14:40,060 --> 00:14:50,619
<font color="#E5E5E5">an API</font><font color="#CCCCCC"> Stephan talked before about</font>

374
00:14:46,470 --> 00:14:53,170
multiple<font color="#CCCCCC"> graphs this</font><font color="#E5E5E5"> is an</font><font color="#CCCCCC"> example that</font>

375
00:14:50,620 --> 00:14:55,029
<font color="#E5E5E5">is also</font><font color="#CCCCCC"> currently available in caps that</font>

376
00:14:53,170 --> 00:14:57,339
<font color="#E5E5E5">you can run which involves multiple</font>

377
00:14:55,029 --> 00:14:59,319
graphs<font color="#E5E5E5"> max will give you a more advanced</font>

378
00:14:57,339 --> 00:15:01,600
example<font color="#CCCCCC"> later but it's just to</font><font color="#E5E5E5"> give you</font>

379
00:14:59,319 --> 00:15:04,689
the<font color="#CCCCCC"> idea so</font><font color="#E5E5E5"> what we do here is we</font><font color="#CCCCCC"> take</font>

380
00:15:01,600 --> 00:15:06,759
two crafts we mount the first one from

381
00:15:04,689 --> 00:15:09,040
HDFS<font color="#E5E5E5"> and the second one is coming from</font>

382
00:15:06,759 --> 00:15:11,379
<font color="#E5E5E5">new</font><font color="#CCCCCC"> voce' indicated by</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> bold scheme</font>

383
00:15:09,040 --> 00:15:13,480
in the URI and<font color="#E5E5E5"> to</font><font color="#CCCCCC"> queries to get the</font>

384
00:15:11,379 --> 00:15:16,569
data out of<font color="#E5E5E5"> me over J and we store them</font>

385
00:15:13,480 --> 00:15:19,449
<font color="#CCCCCC">at Tutor to pass my HDFS craft and mine</font>

386
00:15:16,569 --> 00:15:21,639
your craft<font color="#E5E5E5"> and then within the query we</font>

387
00:15:19,449 --> 00:15:23,500
<font color="#E5E5E5">can say from</font><font color="#CCCCCC"> my HDFS craft</font>

388
00:15:21,639 --> 00:15:24,550
give me all the employees and from my

389
00:15:23,500 --> 00:15:26,620
neva chakra

390
00:15:24,550 --> 00:15:29,319
give me all<font color="#E5E5E5"> the persons and then join</font>

391
00:15:26,620 --> 00:15:30,820
those two crafts<font color="#E5E5E5"> where the users are the</font>

392
00:15:29,320 --> 00:15:33,339
persons and<font color="#E5E5E5"> the employee have a matching</font>

393
00:15:30,820 --> 00:15:35,860
<font color="#E5E5E5">email address so we do data integration</font>

394
00:15:33,339 --> 00:15:37,839
basically we have to craft separate HDFS

395
00:15:35,860 --> 00:15:39,640
<font color="#E5E5E5">new</font><font color="#CCCCCC"> VJ and we join them</font><font color="#E5E5E5"> together based</font>

396
00:15:37,839 --> 00:15:42,250
on some knowledge that<font color="#CCCCCC"> we have about</font>

397
00:15:39,640 --> 00:15:44,680
<font color="#E5E5E5">those two crafts and then we return a</font>

398
00:15:42,250 --> 00:15:46,390
new graph which creates a new

399
00:15:44,680 --> 00:15:48,790
<font color="#E5E5E5">relationship between the employee and</font>

400
00:15:46,390 --> 00:15:50,890
<font color="#E5E5E5">the person set match and create a new</font>

401
00:15:48,790 --> 00:15:52,990
relationship called same s and then this

402
00:15:50,890 --> 00:15:54,850
graph is used with an additional<font color="#CCCCCC"> Kaveri</font>

403
00:15:52,990 --> 00:15:56,500
that you can see here<font color="#E5E5E5"> so it's also an</font>

404
00:15:54,850 --> 00:15:58,209
<font color="#CCCCCC">example for</font><font color="#E5E5E5"> composition because this is</font>

405
00:15:56,500 --> 00:16:00,459
the first<font color="#CCCCCC"> kaveri</font><font color="#E5E5E5"> this is the second</font>

406
00:15:58,209 --> 00:16:04,029
query that we trigger on the result of

407
00:16:00,459 --> 00:16:06,430
the first<font color="#E5E5E5"> one okay this is</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> concept</font>

408
00:16:04,029 --> 00:16:08,800
and<font color="#CCCCCC"> max now we'll show you a more</font>

409
00:16:06,430 --> 00:16:10,949
advanced example<font color="#E5E5E5"> running a sample of</font>

410
00:16:08,800 --> 00:16:10,949
that

411
00:16:24,860 --> 00:16:30,120
okay so before<font color="#E5E5E5"> we can start the example</font>

412
00:16:28,620 --> 00:16:34,829
I<font color="#E5E5E5"> just want to set you all up with the</font>

413
00:16:30,120 --> 00:16:36,779
<font color="#E5E5E5">scenario we</font><font color="#CCCCCC"> are talking</font><font color="#E5E5E5"> about so let's</font>

414
00:16:34,829 --> 00:16:43,109
assume<font color="#E5E5E5"> we're a company and we want to do</font>

415
00:16:36,779 --> 00:16:45,810
a marketing campaign<font color="#E5E5E5"> and specific</font>

416
00:16:43,110 --> 00:16:48,509
metropolitan areas and we<font color="#CCCCCC"> have access to</font>

417
00:16:45,810 --> 00:16:51,329
<font color="#CCCCCC">two data</font><font color="#E5E5E5"> sets one data set is a social</font>

418
00:16:48,509 --> 00:16:53,490
network it's an generated social network

419
00:16:51,329 --> 00:16:58,589
in<font color="#E5E5E5"> our case which we split</font><font color="#CCCCCC"> up</font><font color="#E5E5E5"> into two</font>

420
00:16:53,490 --> 00:17:02,040
regions<font color="#CCCCCC"> so we have</font><font color="#E5E5E5"> our social network is</font>

421
00:16:58,589 --> 00:17:04,829
once partitioned into the North America

422
00:17:02,040 --> 00:17:07,319
part in the Europe part and restore it

423
00:17:04,829 --> 00:17:10,470
in<font color="#CCCCCC"> two neo4j databases</font><font color="#E5E5E5"> just for</font>

424
00:17:07,319 --> 00:17:13,079
<font color="#E5E5E5">scalability and for performance</font>

425
00:17:10,470 --> 00:17:16,980
<font color="#E5E5E5">optimization and then on the other side</font>

426
00:17:13,079 --> 00:17:19,408
we<font color="#CCCCCC"> have a customer data set so it's</font>

427
00:17:16,980 --> 00:17:21,419
customers who have bought products<font color="#E5E5E5"> those</font>

428
00:17:19,409 --> 00:17:24,780
products are also categorized<font color="#E5E5E5"> into</font>

429
00:17:21,419 --> 00:17:26,429
product categories<font color="#CCCCCC"> and on the social</font>

430
00:17:24,780 --> 00:17:29,879
network side of course we have people

431
00:17:26,429 --> 00:17:32,750
<font color="#CCCCCC">who know one another who live in certain</font>

432
00:17:29,880 --> 00:17:36,659
<font color="#E5E5E5">cities and they're interested</font><font color="#CCCCCC"> in</font>

433
00:17:32,750 --> 00:17:39,360
<font color="#E5E5E5">different interests and</font><font color="#CCCCCC"> as you can</font>

434
00:17:36,659 --> 00:17:44,700
already see we have a shared attributes

435
00:17:39,360 --> 00:17:47,070
<font color="#E5E5E5">across those data sets</font><font color="#CCCCCC"> so people on the</font>

436
00:17:44,700 --> 00:17:49,500
social network site as well<font color="#E5E5E5"> as customers</font>

437
00:17:47,070 --> 00:17:51,270
on the product side<font color="#E5E5E5"> both have an email</font>

438
00:17:49,500 --> 00:17:53,640
<font color="#E5E5E5">address</font><font color="#CCCCCC"> and this is where we can connect</font>

439
00:17:51,270 --> 00:17:58,260
those<font color="#E5E5E5"> data sets so what we do is we</font>

440
00:17:53,640 --> 00:17:59,669
assume<font color="#E5E5E5"> that if a person on the social</font>

441
00:17:58,260 --> 00:18:01,919
network site and the customer on the

442
00:17:59,669 --> 00:18:04,559
product<font color="#CCCCCC"> side have</font><font color="#E5E5E5"> the same email</font><font color="#CCCCCC"> address</font>

443
00:18:01,919 --> 00:18:06,179
they are the same person<font color="#E5E5E5"> in</font><font color="#CCCCCC"> reality so</font>

444
00:18:04,559 --> 00:18:10,260
they are the same<font color="#CCCCCC"> they represent the</font>

445
00:18:06,179 --> 00:18:13,200
same entity and<font color="#E5E5E5"> yeah I forgot</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> mention</font>

446
00:18:10,260 --> 00:18:16,260
<font color="#CCCCCC">that the product data set is stored in</font>

447
00:18:13,200 --> 00:18:21,690
HDFS just to make this<font color="#CCCCCC"> example a bit</font>

448
00:18:16,260 --> 00:18:24,450
more complex<font color="#E5E5E5"> or like diverse so and what</font>

449
00:18:21,690 --> 00:18:26,940
we<font color="#E5E5E5"> want to do is we load the data from</font>

450
00:18:24,450 --> 00:18:30,809
<font color="#CCCCCC">their corresponding data source as I</font>

451
00:18:26,940 --> 00:18:33,620
said new for<font color="#CCCCCC"> J</font><font color="#E5E5E5"> in HDFS</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> extract sub</font>

452
00:18:30,809 --> 00:18:36,059
<font color="#E5E5E5">graphs</font><font color="#CCCCCC"> that only contain the data</font>

453
00:18:33,620 --> 00:18:37,979
<font color="#E5E5E5">concerning those metropolitan areas we</font>

454
00:18:36,059 --> 00:18:38,220
want<font color="#CCCCCC"> to target</font><font color="#E5E5E5"> in our case this is New</font>

455
00:18:37,980 --> 00:18:40,830
<font color="#CCCCCC">Year</font>

456
00:18:38,220 --> 00:18:46,010
city<font color="#E5E5E5"> San Francisco billion in Stockholm</font>

457
00:18:40,830 --> 00:18:48,629
<font color="#CCCCCC">and then we merge those two graphs</font><font color="#E5E5E5"> on</font>

458
00:18:46,010 --> 00:18:52,620
the a tree on the email attribute and

459
00:18:48,630 --> 00:18:55,440
then we compute recommendations so we

460
00:18:52,620 --> 00:18:58,320
want to recommend users products that

461
00:18:55,440 --> 00:19:01,320
their friends have<font color="#CCCCCC"> bored in which as</font>

462
00:18:58,320 --> 00:19:05,460
their friends and the user<font color="#E5E5E5"> both are</font>

463
00:19:01,320 --> 00:19:08,970
<font color="#CCCCCC">interested in yes that's basically all</font>

464
00:19:05,460 --> 00:19:10,770
set thing<font color="#E5E5E5"> for the demo and now let's</font>

465
00:19:08,970 --> 00:19:15,350
switch to sapling

466
00:19:10,770 --> 00:19:21,480
so<font color="#CCCCCC"> stepping in is a data science tool</font>

467
00:19:15,350 --> 00:19:24,539
which allows<font color="#E5E5E5"> you</font><font color="#CCCCCC"> to run</font><font color="#E5E5E5"> spark</font><font color="#CCCCCC"> Ravi's in</font>

468
00:19:21,480 --> 00:19:29,809
an interactive<font color="#CCCCCC"> session and we have</font>

469
00:19:24,539 --> 00:19:32,820
adopted caps<font color="#E5E5E5"> so that</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> somewhat support</font>

470
00:19:29,809 --> 00:19:35,789
Zeppelin and we can use<font color="#CCCCCC"> it for our demo</font>

471
00:19:32,820 --> 00:19:38,280
<font color="#CCCCCC">is</font><font color="#E5E5E5"> this is it big</font><font color="#CCCCCC"> enough is it</font><font color="#E5E5E5"> readable</font>

472
00:19:35,789 --> 00:19:40,200
from<font color="#E5E5E5"> like at least some places in this</font>

473
00:19:38,280 --> 00:19:43,649
room<font color="#CCCCCC"> or should</font><font color="#E5E5E5"> I increase the font size</font>

474
00:19:40,200 --> 00:19:45,419
<font color="#E5E5E5">even more okay I'll leave it as it is so</font>

475
00:19:43,650 --> 00:19:50,400
what<font color="#E5E5E5"> we've did what we were told we did</font>

476
00:19:45,419 --> 00:19:52,620
on this we've imported all<font color="#CCCCCC"> the</font><font color="#E5E5E5"> well the</font>

477
00:19:50,400 --> 00:19:55,130
kept sniper<font color="#CCCCCC"> Reis is like the kept</font>

478
00:19:52,620 --> 00:19:58,020
session and we have this special

479
00:19:55,130 --> 00:20:00,330
<font color="#E5E5E5">separate in support class here just for</font>

480
00:19:58,020 --> 00:20:03,960
<font color="#E5E5E5">discipline and before we created</font><font color="#CCCCCC"> their</font>

481
00:20:00,330 --> 00:20:05,850
kept session and what we start is we

482
00:20:03,960 --> 00:20:09,409
have to<font color="#CCCCCC"> what we start with</font><font color="#E5E5E5"> is loading</font>

483
00:20:05,850 --> 00:20:11,250
the data sets so<font color="#E5E5E5"> we first read our</font>

484
00:20:09,409 --> 00:20:14,179
graphs from neo4j

485
00:20:11,250 --> 00:20:17,370
this is done in<font color="#E5E5E5"> those first two lines I</font>

486
00:20:14,179 --> 00:20:20,880
just run it<font color="#E5E5E5"> here</font><font color="#CCCCCC"> because sometimes</font><font color="#E5E5E5"> it</font>

487
00:20:17,370 --> 00:20:23,879
takes a<font color="#E5E5E5"> while so we read the data</font><font color="#CCCCCC"> from</font>

488
00:20:20,880 --> 00:20:25,650
neo4j<font color="#E5E5E5"> from the two regions and we read</font>

489
00:20:23,880 --> 00:20:27,840
<font color="#E5E5E5">the data from our</font><font color="#CCCCCC"> products data set</font>

490
00:20:25,650 --> 00:20:32,039
which is done here so you see<font color="#E5E5E5"> this is</font>

491
00:20:27,840 --> 00:20:35,549
using<font color="#E5E5E5"> bold which is the</font><font color="#CCCCCC"> neo4j scheme and</font>

492
00:20:32,039 --> 00:20:38,580
then we have HDFS<font color="#CCCCCC"> and CSV</font><font color="#E5E5E5"> so we tell our</font>

493
00:20:35,549 --> 00:20:41,700
system this format<font color="#E5E5E5"> is stored in HDFS and</font>

494
00:20:38,580 --> 00:20:43,470
<font color="#E5E5E5">uses our custom CSV format</font><font color="#CCCCCC"> remember</font><font color="#E5E5E5"> what</font>

495
00:20:41,700 --> 00:20:45,690
we do here this is somewhat analogous to

496
00:20:43,470 --> 00:20:48,270
<font color="#E5E5E5">the mount called and Martin showed</font>

497
00:20:45,690 --> 00:20:50,190
previously<font color="#E5E5E5"> so we</font><font color="#CCCCCC"> have our graph and</font><font color="#E5E5E5"> now</font>

498
00:20:48,270 --> 00:20:52,250
we store it<font color="#E5E5E5"> in the session under</font><font color="#CCCCCC"> a</font>

499
00:20:50,190 --> 00:20:54,919
certain<font color="#E5E5E5"> name or in our case</font>

500
00:20:52,250 --> 00:20:56,480
this is<font color="#CCCCCC"> in a URI so we can later use it</font>

501
00:20:54,919 --> 00:20:58,010
from<font color="#E5E5E5"> within</font><font color="#CCCCCC"> the cypher curvy so we can</font>

502
00:20:56,480 --> 00:20:59,960
from within the cypher carrier you<font color="#E5E5E5"> can</font>

503
00:20:58,010 --> 00:21:01,960
reference<font color="#CCCCCC"> that graph change our input</font>

504
00:20:59,960 --> 00:21:03,340
graph and now read from<font color="#CCCCCC"> a different</font>

505
00:21:01,960 --> 00:21:07,970
source

506
00:21:03,340 --> 00:21:09,408
so this worked I<font color="#CCCCCC"> guess yes</font><font color="#E5E5E5"> and now let's</font>

507
00:21:07,970 --> 00:21:11,510
<font color="#E5E5E5">start with some simple queries to show</font>

508
00:21:09,409 --> 00:21:13,490
you just<font color="#E5E5E5"> a this</font><font color="#CCCCCC"> is like</font><font color="#E5E5E5"> the cypher</font><font color="#CCCCCC"> 9</font>

509
00:21:11,510 --> 00:21:15,770
cipher capabilities that we already

510
00:21:13,490 --> 00:21:19,039
<font color="#CCCCCC">support so let's take our social</font>

511
00:21:15,770 --> 00:21:21,440
networks and<font color="#E5E5E5"> have a look at the</font>

512
00:21:19,039 --> 00:21:24,620
distribution<font color="#CCCCCC"> of interest in</font><font color="#E5E5E5"> in our</font>

513
00:21:21,440 --> 00:21:26,330
cities<font color="#E5E5E5"> so both for for New York City and</font>

514
00:21:24,620 --> 00:21:29,719
San<font color="#CCCCCC"> Francisco as well as Stockholm and</font>

515
00:21:26,330 --> 00:21:31,610
Berlin<font color="#CCCCCC"> and what we do</font><font color="#E5E5E5"> here is we select</font>

516
00:21:29,720 --> 00:21:33,860
all people and their interests<font color="#CCCCCC"> and then</font>

517
00:21:31,610 --> 00:21:37,789
we group by city name and interest<font color="#E5E5E5"> and</font>

518
00:21:33,860 --> 00:21:39,949
let's<font color="#E5E5E5"> have a look how people</font><font color="#CCCCCC"> or what</font>

519
00:21:37,789 --> 00:21:42,770
<font color="#E5E5E5">people</font><font color="#CCCCCC"> in those</font><font color="#E5E5E5"> cities like so it's also</font>

520
00:21:39,950 --> 00:21:45,320
<font color="#E5E5E5">to kind of demonstrate how nicely this</font>

521
00:21:42,770 --> 00:21:47,059
integrates with Zeppelin so you can do

522
00:21:45,320 --> 00:21:49,658
your cipher<font color="#CCCCCC"> Treves which are quite</font>

523
00:21:47,059 --> 00:21:52,010
readable and<font color="#E5E5E5"> then you get a quite nice</font>

524
00:21:49,659 --> 00:21:54,260
visualization of<font color="#E5E5E5"> that</font><font color="#CCCCCC"> so what</font><font color="#E5E5E5"> we see is</font>

525
00:21:52,010 --> 00:21:56,240
here in<font color="#E5E5E5"> York City the interests are more</font>

526
00:21:54,260 --> 00:21:57,470
or less<font color="#E5E5E5"> evenly distributed and San</font>

527
00:21:56,240 --> 00:22:00,320
Francisco<font color="#CCCCCC"> is</font><font color="#E5E5E5"> somewhat more old-school</font>

528
00:21:57,470 --> 00:22:02,870
they seem to like videos more than DVD<font color="#E5E5E5"> I</font>

529
00:22:00,320 --> 00:22:06,500
guess this is<font color="#E5E5E5"> like real videos like VHS</font>

530
00:22:02,870 --> 00:22:09,789
and they don't read as many books<font color="#E5E5E5"> but I</font>

531
00:22:06,500 --> 00:22:13,700
mean it's artificial<font color="#E5E5E5"> data so it's just</font>

532
00:22:09,789 --> 00:22:18,200
<font color="#E5E5E5">just for this for the</font><font color="#CCCCCC"> film looks almost</font>

533
00:22:13,700 --> 00:22:21,020
the<font color="#E5E5E5"> same for</font><font color="#CCCCCC"> Brillion</font><font color="#E5E5E5"> in Stockholm</font><font color="#CCCCCC"> what</font>

534
00:22:18,200 --> 00:22:23,809
we do now is to<font color="#CCCCCC"> make our</font><font color="#E5E5E5"> lives a bit</font>

535
00:22:21,020 --> 00:22:25,400
<font color="#CCCCCC">more easier we extract those</font>

536
00:22:23,809 --> 00:22:27,168
metropolitan areas so we don't want to

537
00:22:25,400 --> 00:22:28,820
<font color="#E5E5E5">look at all the cities that are</font>

538
00:22:27,169 --> 00:22:30,320
available<font color="#E5E5E5"> in our data set but as I</font><font color="#CCCCCC"> said</font>

539
00:22:28,820 --> 00:22:36,168
we<font color="#CCCCCC"> just</font><font color="#E5E5E5"> want to target those four cities</font>

540
00:22:30,320 --> 00:22:39,889
<font color="#E5E5E5">so</font><font color="#CCCCCC"> we extract graphs of people who live</font>

541
00:22:36,169 --> 00:22:41,510
<font color="#E5E5E5">in one of</font><font color="#CCCCCC"> our target cities and</font><font color="#E5E5E5"> if two</font>

542
00:22:39,890 --> 00:22:43,130
<font color="#E5E5E5">people live in the same city and know</font>

543
00:22:41,510 --> 00:22:44,780
one another<font color="#E5E5E5"> about one or two</font><font color="#CCCCCC"> hopes that</font>

544
00:22:43,130 --> 00:22:49,280
<font color="#CCCCCC">is they are friends</font><font color="#E5E5E5"> or friends of</font>

545
00:22:44,780 --> 00:22:52,490
<font color="#E5E5E5">friends then we create</font><font color="#CCCCCC"> an new</font><font color="#E5E5E5"> graph with</font>

546
00:22:49,280 --> 00:22:53,570
a<font color="#E5E5E5"> NH between those people so they from</font>

547
00:22:52,490 --> 00:22:55,429
now on they live in<font color="#E5E5E5"> there</font>

548
00:22:53,570 --> 00:23:01,010
they live in the same like social circle

549
00:22:55,429 --> 00:23:03,400
<font color="#CCCCCC">and then</font><font color="#E5E5E5"> we return</font><font color="#CCCCCC"> that graph that's</font>

550
00:23:01,010 --> 00:23:06,730
wrong those queries

551
00:23:03,400 --> 00:23:08,440
<font color="#CCCCCC">and here we have not the table</font>

552
00:23:06,730 --> 00:23:10,330
representation<font color="#E5E5E5"> anymore because we we</font>

553
00:23:08,440 --> 00:23:12,070
don't we don't<font color="#CCCCCC"> really return a tabular</font>

554
00:23:10,330 --> 00:23:14,110
result but we<font color="#E5E5E5"> return the graph result we</font>

555
00:23:12,070 --> 00:23:16,240
return<font color="#CCCCCC"> a new</font><font color="#E5E5E5"> graph so what we get here</font>

556
00:23:14,110 --> 00:23:17,889
<font color="#CCCCCC">is</font><font color="#E5E5E5"> visualization of the new graph you</font>

557
00:23:16,240 --> 00:23:19,990
<font color="#CCCCCC">see those two communities I guess one of</font>

558
00:23:17,890 --> 00:23:22,450
<font color="#E5E5E5">them represents all the people living in</font>

559
00:23:19,990 --> 00:23:26,440
New<font color="#CCCCCC"> York</font><font color="#E5E5E5"> City</font><font color="#CCCCCC"> the other one all the</font>

560
00:23:22,450 --> 00:23:29,050
people living<font color="#E5E5E5"> in San Francisco and they</font>

561
00:23:26,440 --> 00:23:31,570
are all somewhat connected<font color="#E5E5E5"> if they know</font>

562
00:23:29,050 --> 00:23:38,200
one another or their friends know one

563
00:23:31,570 --> 00:23:39,879
another to run<font color="#E5E5E5"> this as well now what we</font>

564
00:23:38,200 --> 00:23:42,670
now do is<font color="#CCCCCC"> we combine</font><font color="#E5E5E5"> those two graphs so</font>

565
00:23:39,880 --> 00:23:44,200
so far we always worked with<font color="#E5E5E5"> the two</font>

566
00:23:42,670 --> 00:23:46,390
different data<font color="#E5E5E5"> and social network data</font>

567
00:23:44,200 --> 00:23:50,200
<font color="#CCCCCC">sets so we had the one for New York the</font>

568
00:23:46,390 --> 00:23:53,140
one for Europe and we now want to

569
00:23:50,200 --> 00:23:55,120
combine<font color="#E5E5E5"> them into a single graph just</font>

570
00:23:53,140 --> 00:23:58,800
because it makes<font color="#E5E5E5"> life easier</font><font color="#CCCCCC"> for us and</font>

571
00:23:55,120 --> 00:24:03,540
we again<font color="#CCCCCC"> stored</font><font color="#E5E5E5"> this combined graph in</font>

572
00:23:58,800 --> 00:24:06,129
in our session<font color="#E5E5E5"> using the friends</font><font color="#CCCCCC"> URI</font><font color="#E5E5E5"> and</font>

573
00:24:03,540 --> 00:24:08,170
now we do merge the two data sets<font color="#E5E5E5"> this</font>

574
00:24:06,130 --> 00:24:11,140
<font color="#E5E5E5">is where the multiple graph capabilities</font>

575
00:24:08,170 --> 00:24:13,870
<font color="#E5E5E5">come in handy now</font><font color="#CCCCCC"> so we start by reading</font>

576
00:24:11,140 --> 00:24:15,490
<font color="#E5E5E5">from</font><font color="#CCCCCC"> our</font><font color="#E5E5E5"> friends graph so this is what</font>

577
00:24:13,870 --> 00:24:19,000
we use now<font color="#E5E5E5"> we use this feature graph at</font>

578
00:24:15,490 --> 00:24:21,460
friends so we tell the system for now I

579
00:24:19,000 --> 00:24:24,670
want<font color="#E5E5E5"> to read from the friends graph</font><font color="#CCCCCC"> and</font>

580
00:24:21,460 --> 00:24:26,559
we find all people and access their

581
00:24:24,670 --> 00:24:28,720
email address and<font color="#E5E5E5"> then we switch our</font>

582
00:24:26,559 --> 00:24:31,149
input graph<font color="#CCCCCC"> from now on we keep the</font>

583
00:24:28,720 --> 00:24:33,429
results that we<font color="#E5E5E5"> have computed so far but</font>

584
00:24:31,150 --> 00:24:34,960
everything<font color="#E5E5E5"> about the app that</font><font color="#CCCCCC"> has going</font>

585
00:24:33,429 --> 00:24:36,730
<font color="#E5E5E5">to happen now all reads that are going</font>

586
00:24:34,960 --> 00:24:39,220
<font color="#E5E5E5">to happen now are it done using the</font>

587
00:24:36,730 --> 00:24:41,650
<font color="#CCCCCC">product</font><font color="#E5E5E5"> graph so again we find all users</font>

588
00:24:39,220 --> 00:24:44,950
and their email<font color="#E5E5E5"> addresses and now we do</font>

589
00:24:41,650 --> 00:24:47,590
a cross product<font color="#CCCCCC"> so or a value join so</font>

590
00:24:44,950 --> 00:24:49,900
you find<font color="#E5E5E5"> people and users that</font><font color="#CCCCCC"> have</font><font color="#E5E5E5"> the</font>

591
00:24:47,590 --> 00:24:52,990
same<font color="#E5E5E5"> email</font><font color="#CCCCCC"> address and for every</font><font color="#E5E5E5"> couple</font>

592
00:24:49,900 --> 00:24:57,580
<font color="#CCCCCC">that we create</font><font color="#E5E5E5"> we create a new graph</font>

593
00:24:52,990 --> 00:25:01,900
with an<font color="#E5E5E5"> H so user is</font><font color="#CCCCCC"> a person</font><font color="#E5E5E5"> it's the</font>

594
00:24:57,580 --> 00:25:08,280
<font color="#E5E5E5">same person so up until now we have done</font>

595
00:25:01,900 --> 00:25:08,280
our we have done our ETL so we had

596
00:25:11,180 --> 00:25:19,130
<font color="#CCCCCC">no they did</font><font color="#E5E5E5"> it already</font><font color="#CCCCCC"> so this</font><font color="#E5E5E5"> was all</font>

597
00:25:16,850 --> 00:25:21,020
ETL stuff so we had<font color="#CCCCCC"> our input data or</font>

598
00:25:19,130 --> 00:25:23,240
more or<font color="#E5E5E5"> less raw input data and we've</font>

599
00:25:21,020 --> 00:25:26,150
transformed it so that we can now do<font color="#E5E5E5"> our</font>

600
00:25:23,240 --> 00:25:28,820
analysis<font color="#CCCCCC"> first</font><font color="#E5E5E5"> we have to combine all</font>

601
00:25:26,150 --> 00:25:30,500
the data<font color="#E5E5E5"> into a single graph just makes</font>

602
00:25:28,820 --> 00:25:34,510
it<font color="#E5E5E5"> easier again because we also wanted</font>

603
00:25:30,500 --> 00:25:36,890
access<font color="#CCCCCC"> to</font><font color="#E5E5E5"> a person attributes and</font><font color="#CCCCCC"> D and</font>

604
00:25:34,510 --> 00:25:39,320
<font color="#E5E5E5">their interests and stuff like that so</font>

605
00:25:36,890 --> 00:25:42,110
<font color="#CCCCCC">we create one</font><font color="#E5E5E5"> large graph and use this</font>

606
00:25:39,320 --> 00:25:44,750
graph to<font color="#CCCCCC"> do our nan</font><font color="#E5E5E5"> our analysis so what</font>

607
00:25:42,110 --> 00:25:47,750
we do is we<font color="#E5E5E5"> find</font><font color="#CCCCCC"> people that</font><font color="#E5E5E5"> are in the</font>

608
00:25:44,750 --> 00:25:51,260
same social circle and<font color="#E5E5E5"> have and like a</font>

609
00:25:47,750 --> 00:25:54,470
certain interest<font color="#E5E5E5"> and then if the user is</font>

610
00:25:51,260 --> 00:25:55,850
<font color="#CCCCCC">the same as a user or if</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> person in</font>

611
00:25:54,470 --> 00:25:58,550
the social network is<font color="#E5E5E5"> the same as</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> user</font>

612
00:25:55,850 --> 00:26:00,320
in our products database<font color="#E5E5E5"> and has brought</font>

613
00:25:58,550 --> 00:26:02,780
a<font color="#E5E5E5"> certain product that belongs into a</font>

614
00:26:00,320 --> 00:26:04,909
<font color="#E5E5E5">category which he</font><font color="#CCCCCC"> which his friend likes</font>

615
00:26:02,780 --> 00:26:09,740
<font color="#E5E5E5">then we recommend his</font><font color="#CCCCCC"> friends this</font>

616
00:26:04,910 --> 00:26:13,730
product<font color="#E5E5E5"> and then we</font><font color="#CCCCCC"> also we also</font><font color="#E5E5E5"> rank</font>

617
00:26:09,740 --> 00:26:16,250
<font color="#E5E5E5">those recommendations by the number or</font>

618
00:26:13,730 --> 00:26:18,350
by<font color="#CCCCCC"> the by</font><font color="#E5E5E5"> day</font><font color="#CCCCCC"> by</font><font color="#E5E5E5"> the ranking or rating</font>

619
00:26:16,250 --> 00:26:20,720
of the product and how many or how

620
00:26:18,350 --> 00:26:25,490
helpful those votes actually<font color="#E5E5E5"> are or how</font>

621
00:26:20,720 --> 00:26:32,030
how<font color="#CCCCCC"> many votes a certain rating has</font>

622
00:26:25,490 --> 00:26:37,820
gotten yes and then we execute this and

623
00:26:32,030 --> 00:26:41,480
can<font color="#CCCCCC"> actually visualize it in</font><font color="#E5E5E5"> table this</font>

624
00:26:37,820 --> 00:26:43,610
takes a<font color="#CCCCCC"> while running it locally on my</font>

625
00:26:41,480 --> 00:26:46,850
laptop<font color="#CCCCCC"> right now</font><font color="#E5E5E5"> it's it's a graph with</font>

626
00:26:43,610 --> 00:26:53,149
a couple of thousand nodes<font color="#E5E5E5"> and a couple</font>

627
00:26:46,850 --> 00:26:55,580
of<font color="#CCCCCC"> ten or</font><font color="#E5E5E5"> 100,000 edges yeah</font><font color="#CCCCCC"> and as I</font>

628
00:26:53,150 --> 00:26:58,100
said we<font color="#CCCCCC"> started with a and we</font><font color="#E5E5E5"> started</font>

629
00:26:55,580 --> 00:27:00,530
<font color="#E5E5E5">with two like raw input datasets we</font>

630
00:26:58,100 --> 00:27:02,540
<font color="#E5E5E5">combined them using some ETL</font>

631
00:27:00,530 --> 00:27:04,970
capabilities and then using the same

632
00:27:02,540 --> 00:27:10,460
<font color="#E5E5E5">language the decipher we could also do a</font>

633
00:27:04,970 --> 00:27:12,860
<font color="#E5E5E5">an analysis of the data and do some</font>

634
00:27:10,460 --> 00:27:16,190
analytics<font color="#E5E5E5"> here we are</font><font color="#CCCCCC"> we now have a</font>

635
00:27:12,860 --> 00:27:17,689
table with recommendations<font color="#E5E5E5"> or</font><font color="#CCCCCC"> B C's</font><font color="#E5E5E5"> we</font>

636
00:27:16,190 --> 00:27:19,280
could that we could recommend Billy

637
00:27:17,690 --> 00:27:21,500
<font color="#E5E5E5">Anderson with a certain email address</font>

638
00:27:19,280 --> 00:27:23,810
<font color="#E5E5E5">and we should recommend him</font><font color="#CCCCCC"> to buy</font><font color="#E5E5E5"> the</font>

639
00:27:21,500 --> 00:27:26,270
book<font color="#E5E5E5"> The Life of Pi</font>

640
00:27:23,810 --> 00:27:31,340
yeah<font color="#E5E5E5"> that's so that's all for the demo</font>

641
00:27:26,270 --> 00:27:37,280
for so<font color="#E5E5E5"> far and also for our talk</font><font color="#CCCCCC"> as we</font>

642
00:27:31,340 --> 00:27:39,709
said<font color="#E5E5E5"> no it's this slide</font><font color="#CCCCCC"> we thank</font><font color="#E5E5E5"> you for</font>

643
00:27:37,280 --> 00:27:41,690
<font color="#CCCCCC">listening and we welcome you all to</font>

644
00:27:39,710 --> 00:27:44,420
check out our project<font color="#E5E5E5"> it's on github as</font>

645
00:27:41,690 --> 00:27:46,280
we said it's<font color="#CCCCCC"> open source license</font><font color="#E5E5E5"> you can</font>

646
00:27:44,420 --> 00:27:49,430
use it<font color="#E5E5E5"> it's still in alpha so we are</font>

647
00:27:46,280 --> 00:27:51,770
constantly<font color="#E5E5E5"> changing stuff so don't rely</font>

648
00:27:49,430 --> 00:27:54,020
too much on on certain details<font color="#CCCCCC"> we are</font>

649
00:27:51,770 --> 00:27:57,080
finalizing the API right now so this<font color="#E5E5E5"> is</font>

650
00:27:54,020 --> 00:27:58,730
somewhat stable already not<font color="#E5E5E5"> only if</font>

651
00:27:57,080 --> 00:27:59,990
you're<font color="#CCCCCC"> interested in Apache</font><font color="#E5E5E5"> for spark</font>

652
00:27:58,730 --> 00:28:02,690
but also if you're<font color="#E5E5E5"> interested in</font>

653
00:27:59,990 --> 00:28:06,500
implementing<font color="#E5E5E5"> cipher on another system</font>

654
00:28:02,690 --> 00:28:08,690
check out our project<font color="#CCCCCC"> we try to keep our</font>

655
00:28:06,500 --> 00:28:11,720
project in a way<font color="#E5E5E5"> that it's easy to</font><font color="#CCCCCC"> reuse</font>

656
00:28:08,690 --> 00:28:13,460
all parts like up to<font color="#CCCCCC"> the like</font><font color="#E5E5E5"> depending</font>

657
00:28:11,720 --> 00:28:14,540
<font color="#E5E5E5">on how your how your back-end is</font>

658
00:28:13,460 --> 00:28:16,760
structure you could ice if you're

659
00:28:14,540 --> 00:28:19,070
<font color="#CCCCCC">backing</font><font color="#E5E5E5"> is like relational also then you</font>

660
00:28:16,760 --> 00:28:22,420
can use quite a<font color="#E5E5E5"> lot of our project all</font>

661
00:28:19,070 --> 00:28:25,610
the<font color="#CCCCCC"> schema trans translations all the</font>

662
00:28:22,420 --> 00:28:27,020
header calculations or if you if you

663
00:28:25,610 --> 00:28:28,429
<font color="#CCCCCC">just</font><font color="#E5E5E5"> want to do you in memory</font><font color="#CCCCCC"> database</font>

664
00:28:27,020 --> 00:28:30,560
then you can just<font color="#E5E5E5"> use the front</font><font color="#CCCCCC"> end the</font>

665
00:28:28,430 --> 00:28:33,020
intermediate representation and then

666
00:28:30,560 --> 00:28:35,179
<font color="#E5E5E5">you're already quite a</font><font color="#CCCCCC"> forest</font><font color="#E5E5E5"> step from</font>

667
00:28:33,020 --> 00:28:37,760
<font color="#CCCCCC">just having</font><font color="#E5E5E5"> to do all</font><font color="#CCCCCC"> the implementation</font>

668
00:28:35,180 --> 00:28:39,680
<font color="#CCCCCC">on</font><font color="#E5E5E5"> your own so both of your interest in</font>

669
00:28:37,760 --> 00:28:42,110
spark or want<font color="#E5E5E5"> to implement</font><font color="#CCCCCC"> cipher check</font>

670
00:28:39,680 --> 00:29:05,150
out our project<font color="#E5E5E5"> and contact</font><font color="#CCCCCC"> us if you</font>

671
00:28:42,110 --> 00:29:06,790
have any questions thank<font color="#E5E5E5"> you what do you</font>

672
00:29:05,150 --> 00:29:09,800
see

673
00:29:06,790 --> 00:29:15,170
because ciphers written in<font color="#CCCCCC"> Scala</font><font color="#E5E5E5"> and I</font>

674
00:29:09,800 --> 00:29:17,930
the<font color="#CCCCCC"> question was why Scala</font><font color="#E5E5E5"> and yeah it's</font>

675
00:29:15,170 --> 00:29:20,990
<font color="#CCCCCC">SPARC</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> SPARC is easiest accessible</font>

676
00:29:17,930 --> 00:29:23,450
from Scala it's also a possible<font color="#E5E5E5"> Java but</font>

677
00:29:20,990 --> 00:29:26,420
it's just<font color="#E5E5E5"> nicer</font><font color="#CCCCCC"> with Scala and also the</font>

678
00:29:23,450 --> 00:29:28,400
<font color="#E5E5E5">rest of</font><font color="#CCCCCC"> cypher yeah on the need for</font><font color="#E5E5E5"> J</font>

679
00:29:26,420 --> 00:29:31,720
<font color="#E5E5E5">side is also written in</font><font color="#CCCCCC"> Scala so just</font>

680
00:29:28,400 --> 00:29:31,720
makes our<font color="#E5E5E5"> life whole</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> easier</font>

681
00:29:35,129 --> 00:29:39,850
yes this episode<font color="#E5E5E5"> is</font><font color="#CCCCCC"> happening yeah it's</font>

682
00:29:37,600 --> 00:29:42,399
a diversion of<font color="#E5E5E5"> Zeppelin is a preview</font>

683
00:29:39,850 --> 00:29:45,668
version so<font color="#CCCCCC"> ordered</font><font color="#E5E5E5"> 800</font><font color="#CCCCCC"> snapshot or</font>

684
00:29:42,399 --> 00:29:47,799
<font color="#CCCCCC">something like</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> just because it has</font>

685
00:29:45,669 --> 00:29:50,830
this nice<font color="#E5E5E5"> network</font><font color="#CCCCCC"> or like craft</font>

686
00:29:47,799 --> 00:29:52,450
representation on our website<font color="#E5E5E5"> or</font>

687
00:29:50,830 --> 00:29:58,139
<font color="#E5E5E5">negative project there's a wiki link on</font>

688
00:29:52,450 --> 00:30:39,999
how you can integrate<font color="#E5E5E5"> and we</font><font color="#CCCCCC"> explained</font>

689
00:29:58,139 --> 00:30:42,008
you<font color="#CCCCCC"> can build you can</font><font color="#E5E5E5"> also use</font><font color="#CCCCCC"> we</font>

690
00:30:39,999 --> 00:30:43,600
<font color="#E5E5E5">already looked into</font><font color="#CCCCCC"> I guess what you</font>

691
00:30:42,009 --> 00:30:46,169
mean is craft partitioning so how to

692
00:30:43,600 --> 00:30:48,369
smartly partition the graph over HDFS

693
00:30:46,169 --> 00:30:50,559
not yet

694
00:30:48,369 --> 00:30:52,090
but that's on our<font color="#CCCCCC"> roadmap for the next</font>

695
00:30:50,559 --> 00:30:53,678
<font color="#E5E5E5">time so it's part of our performance</font>

696
00:30:52,090 --> 00:30:55,059
tuning of course and this<font color="#E5E5E5"> is mostly</font>

697
00:30:53,679 --> 00:30:57,039
related<font color="#CCCCCC"> to performance to have a good</font>

698
00:30:55,059 --> 00:30:58,899
partitioning of<font color="#CCCCCC"> the input</font><font color="#E5E5E5"> craft and</font><font color="#CCCCCC"> also</font>

699
00:30:57,039 --> 00:31:01,149
we compute partitioning during very

700
00:30:58,899 --> 00:31:03,129
execution<font color="#E5E5E5"> so that's a yeah on the</font>

701
00:31:01,149 --> 00:31:05,110
roadmap<font color="#CCCCCC"> but</font><font color="#E5E5E5"> currently we</font><font color="#CCCCCC"> only rely on</font>

702
00:31:03,129 --> 00:31:07,678
what<font color="#CCCCCC"> spark gives us</font><font color="#E5E5E5"> by default which</font><font color="#CCCCCC"> is</font>

703
00:31:05,110 --> 00:31:07,678
I guess hash partitioning

704
00:31:16,360 --> 00:31:21,520
your own open<font color="#CCCCCC"> cypher</font><font color="#E5E5E5"> implementation to</font>

705
00:31:18,940 --> 00:31:24,160
interface<font color="#E5E5E5"> with</font><font color="#CCCCCC"> your own</font><font color="#E5E5E5"> sources</font><font color="#CCCCCC"> is there</font>

706
00:31:21,520 --> 00:31:26,820
<font color="#E5E5E5">only like libraries and tools available</font>

707
00:31:24,160 --> 00:31:41,710
for Scala<font color="#E5E5E5"> like the parser</font><font color="#CCCCCC"> or whatever</font>

708
00:31:26,820 --> 00:31:44,230
<font color="#CCCCCC">only for Scala or their other suggestion</font>

709
00:31:41,710 --> 00:31:45,520
was<font color="#E5E5E5"> of the tooling available for writing</font>

710
00:31:44,230 --> 00:31:47,440
your<font color="#E5E5E5"> own</font><font color="#CCCCCC"> site for</font><font color="#E5E5E5"> implementation is</font>

711
00:31:45,520 --> 00:31:48,070
<font color="#E5E5E5">that's only available</font><font color="#CCCCCC"> in Scala</font><font color="#E5E5E5"> that's</font>

712
00:31:47,440 --> 00:31:51,130
not<font color="#E5E5E5"> true</font>

713
00:31:48,070 --> 00:31:52,360
so the<font color="#CCCCCC"> TCK is language agnostic so</font><font color="#E5E5E5"> tests</font>

714
00:31:51,130 --> 00:31:54,340
<font color="#E5E5E5">a set of tests suit that the</font>

715
00:31:52,360 --> 00:31:55,928
<font color="#CCCCCC">implementation needs to kind of you</font>

716
00:31:54,340 --> 00:31:58,389
conform to to be a good<font color="#CCCCCC"> implementation</font>

717
00:31:55,929 --> 00:32:00,700
is completely language agnostic<font color="#CCCCCC"> also ze</font>

718
00:31:58,390 --> 00:32:02,440
<font color="#CCCCCC">BNF or all the grammar is available as</font>

719
00:32:00,700 --> 00:32:03,850
an e<font color="#E5E5E5"> BN f</font><font color="#CCCCCC"> common</font><font color="#E5E5E5"> as an anti grammar so</font>

720
00:32:02,440 --> 00:32:06,400
you could easily generate a<font color="#CCCCCC"> positive for</font>

721
00:32:03,850 --> 00:32:07,870
<font color="#E5E5E5">all kinds of languages</font><font color="#CCCCCC"> but the layer</font>

722
00:32:06,400 --> 00:32:09,490
beyond that is currently<font color="#E5E5E5"> only available</font>

723
00:32:07,870 --> 00:32:11,110
in<font color="#CCCCCC"> scala</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> an open source</font>

724
00:32:09,490 --> 00:32:12,460
<font color="#CCCCCC">implementation but i know</font><font color="#E5E5E5"> of one more</font>

725
00:32:11,110 --> 00:32:13,809
open<font color="#E5E5E5"> source implementation or</font>

726
00:32:12,460 --> 00:32:14,890
implementation<font color="#E5E5E5"> that's going to be open</font>

727
00:32:13,809 --> 00:32:17,980
<font color="#CCCCCC">source that's coming out it's actually</font>

728
00:32:14,890 --> 00:32:19,450
<font color="#CCCCCC">not</font><font color="#E5E5E5"> from naio and so you know watch the</font>

729
00:32:17,980 --> 00:32:21,130
space<font color="#E5E5E5"> I think</font><font color="#CCCCCC"> more</font><font color="#E5E5E5"> things are going to</font>

730
00:32:19,450 --> 00:32:22,809
happen<font color="#E5E5E5"> all right so that's the other</font>

731
00:32:21,130 --> 00:32:24,040
<font color="#CCCCCC">side</font><font color="#E5E5E5"> of it but you get some starting</font>

732
00:32:22,809 --> 00:32:26,340
tooling from us so you could do<font color="#E5E5E5"> it if</font>

733
00:32:24,040 --> 00:32:26,340
you want to

