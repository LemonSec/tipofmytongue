1
00:00:06,560 --> 00:00:12,239
right so it's me again

2
00:00:08,639 --> 00:00:12,719
um who to thunk it uh okay this talk is

3
00:00:12,240 --> 00:00:15,200
about

4
00:00:12,719 --> 00:00:16,640
security um security issues they're

5
00:00:15,200 --> 00:00:18,320
rising at open jdk

6
00:00:16,640 --> 00:00:20,400
i've called it security securing a

7
00:00:18,320 --> 00:00:22,160
moving target uh that's the aspect

8
00:00:20,400 --> 00:00:24,320
development jdk i think is interesting

9
00:00:22,160 --> 00:00:25,279
to talk about in terms of security the

10
00:00:24,320 --> 00:00:28,400
subtitle is

11
00:00:25,279 --> 00:00:30,320
what could possibly go wrong um actually

12
00:00:28,400 --> 00:00:31,279
i'd read that another way what are the

13
00:00:30,320 --> 00:00:33,920
things that might

14
00:00:31,279 --> 00:00:35,120
possibly cause problems that are

15
00:00:33,920 --> 00:00:38,160
specific to the

16
00:00:35,120 --> 00:00:38,879
way the nature of open jdk the the class

17
00:00:38,160 --> 00:00:40,959
libraries

18
00:00:38,879 --> 00:00:42,718
that run the the jvm that wouldn't

19
00:00:40,960 --> 00:00:44,239
happen in many other

20
00:00:42,719 --> 00:00:46,000
applications that's really the thing i'm

21
00:00:44,239 --> 00:00:47,440
interested in so

22
00:00:46,000 --> 00:00:49,520
uh i thought one i had to talk about

23
00:00:47,440 --> 00:00:51,120
security i've i've

24
00:00:49,520 --> 00:00:52,960
the motivation for this was actually a

25
00:00:51,120 --> 00:00:54,879
b-sides conference that a friend

26
00:00:52,960 --> 00:00:56,079
was involved in in newcastle so i gave a

27
00:00:54,879 --> 00:00:57,360
brief version of this talk

28
00:00:56,079 --> 00:00:59,280
but i thought was really interesting to

29
00:00:57,360 --> 00:01:00,800
talk about it's really motivated by

30
00:00:59,280 --> 00:01:02,559
things that happened before i got into

31
00:01:00,800 --> 00:01:03,839
the vulnerability group and that's only

32
00:01:02,559 --> 00:01:05,360
compounded since

33
00:01:03,840 --> 00:01:07,520
with the experiences of working with all

34
00:01:05,360 --> 00:01:08,640
the other uh people who are involved in

35
00:01:07,520 --> 00:01:10,479
in that group

36
00:01:08,640 --> 00:01:13,360
um up until we had the vulnerability

37
00:01:10,479 --> 00:01:15,439
group all they'd ever seen were exploits

38
00:01:13,360 --> 00:01:16,400
uh sorry were patches i had no idea what

39
00:01:15,439 --> 00:01:18,479
the exploits were

40
00:01:16,400 --> 00:01:19,600
and these weird changes that obviously

41
00:01:18,479 --> 00:01:22,240
fixed something

42
00:01:19,600 --> 00:01:24,320
but what the significance and importance

43
00:01:22,240 --> 00:01:27,439
of it was was really opaque

44
00:01:24,320 --> 00:01:30,320
um and then our security uh

45
00:01:27,439 --> 00:01:30,880
uh um expert who's martin blair who's

46
00:01:30,320 --> 00:01:33,119
just an

47
00:01:30,880 --> 00:01:35,199
amazing expert in security both in

48
00:01:33,119 --> 00:01:36,400
penetrative testing and and also in

49
00:01:35,200 --> 00:01:38,640
defensive security

50
00:01:36,400 --> 00:01:40,400
came along and with his help uh when

51
00:01:38,640 --> 00:01:41,759
we're trying to look at some back ports

52
00:01:40,400 --> 00:01:43,040
so we'd back put it to eight and we're

53
00:01:41,759 --> 00:01:43,600
wondering maybe this should go into

54
00:01:43,040 --> 00:01:44,720
seven

55
00:01:43,600 --> 00:01:46,960
we thought well we'd better try and

56
00:01:44,720 --> 00:01:47,520
create an exploit from this to use this

57
00:01:46,960 --> 00:01:49,119
patch

58
00:01:47,520 --> 00:01:51,520
and see if maybe that exploit would work

59
00:01:49,119 --> 00:01:51,920
in seven and we recreate an exploit he

60
00:01:51,520 --> 00:01:53,679
knew

61
00:01:51,920 --> 00:01:54,960
lots about how you could hack your way

62
00:01:53,680 --> 00:01:57,280
into things and i just knew a bit about

63
00:01:54,960 --> 00:02:00,559
jvm so it was mostly his work and it was

64
00:01:57,280 --> 00:02:02,799
absolutely mind-boggling to see how a

65
00:02:00,560 --> 00:02:03,840
a little glitch in something in the the

66
00:02:02,799 --> 00:02:06,880
the um the

67
00:02:03,840 --> 00:02:07,520
jdk code could give you an opportunity

68
00:02:06,880 --> 00:02:09,440
to

69
00:02:07,520 --> 00:02:10,560
make open up a big hole and then all

70
00:02:09,440 --> 00:02:12,480
sorts of havoc could

71
00:02:10,560 --> 00:02:14,080
could happen so that was just really

72
00:02:12,480 --> 00:02:17,040
interesting and made me think how

73
00:02:14,080 --> 00:02:18,239
how how uh what a weird mindset you have

74
00:02:17,040 --> 00:02:19,920
to have to be looking at

75
00:02:18,239 --> 00:02:21,280
a detail of the way something works and

76
00:02:19,920 --> 00:02:22,958
then to think about a way you might

77
00:02:21,280 --> 00:02:25,040
work your way around that and achieve

78
00:02:22,959 --> 00:02:27,920
some completely um uh

79
00:02:25,040 --> 00:02:29,040
unrelated uh goal that that gets you get

80
00:02:27,920 --> 00:02:31,920
that breaks things open

81
00:02:29,040 --> 00:02:33,040
and then then uh it's game over um so

82
00:02:31,920 --> 00:02:35,280
it's quite interesting to think about

83
00:02:33,040 --> 00:02:37,280
security and i think it's good for um

84
00:02:35,280 --> 00:02:38,720
people to understand about security when

85
00:02:37,280 --> 00:02:40,800
they're developing code

86
00:02:38,720 --> 00:02:42,319
um of course what there's lots of

87
00:02:40,800 --> 00:02:43,920
reasons why i should not talk about

88
00:02:42,319 --> 00:02:46,799
security i mean there's no

89
00:02:43,920 --> 00:02:47,280
benefit in obscurity and and not having

90
00:02:46,800 --> 00:02:49,519
it

91
00:02:47,280 --> 00:02:50,800
visible but um one of the things that

92
00:02:49,519 --> 00:02:52,800
the vulnerability group and

93
00:02:50,800 --> 00:02:54,160
and um this has gone historically before

94
00:02:52,800 --> 00:02:56,879
that what we don't do

95
00:02:54,160 --> 00:02:57,440
is ever publish exploits and in fact

96
00:02:56,879 --> 00:02:59,599
when we

97
00:02:57,440 --> 00:03:01,200
um test a patch and we create a

98
00:02:59,599 --> 00:03:02,959
reproducer to make sure

99
00:03:01,200 --> 00:03:05,359
a patch that's going into a security

100
00:03:02,959 --> 00:03:07,680
release is actually working we have a

101
00:03:05,360 --> 00:03:09,280
before and after reproducer and we don't

102
00:03:07,680 --> 00:03:10,879
actually publish those either so we're

103
00:03:09,280 --> 00:03:12,879
very careful about

104
00:03:10,879 --> 00:03:14,239
making uh making a fuss about the things

105
00:03:12,879 --> 00:03:14,799
that are going in that are security

106
00:03:14,239 --> 00:03:16,159
patches

107
00:03:14,800 --> 00:03:18,239
but you can go and look at the patches

108
00:03:16,159 --> 00:03:20,000
and you could do what uh

109
00:03:18,239 --> 00:03:21,680
martin and i did which is work backwards

110
00:03:20,000 --> 00:03:22,319
and think how could i do something with

111
00:03:21,680 --> 00:03:23,840
this

112
00:03:22,319 --> 00:03:24,879
and i'm not going to go into specific

113
00:03:23,840 --> 00:03:25,599
exploits i'm not even going to talk

114
00:03:24,879 --> 00:03:27,760
about the way

115
00:03:25,599 --> 00:03:29,518
you could design them um that'll support

116
00:03:27,760 --> 00:03:30,480
all your fun you can go and do that and

117
00:03:29,519 --> 00:03:32,720
i suggest you do

118
00:03:30,480 --> 00:03:33,679
and if you read up about security holes

119
00:03:32,720 --> 00:03:35,280
and the way they work

120
00:03:33,680 --> 00:03:36,720
there'll be lots of things you can find

121
00:03:35,280 --> 00:03:38,640
to go and do it what i really want to

122
00:03:36,720 --> 00:03:40,640
talk about is how open jdk

123
00:03:38,640 --> 00:03:42,640
gives some unusual opportunities for

124
00:03:40,640 --> 00:03:44,720
security holes to arise that are really

125
00:03:42,640 --> 00:03:46,000
germane to open jdk to the class

126
00:03:44,720 --> 00:03:49,680
libraries in the the

127
00:03:46,000 --> 00:03:51,280
jvm so what what what's the problems for

128
00:03:49,680 --> 00:03:52,400
security what's the security breach well

129
00:03:51,280 --> 00:03:53,040
there's lots of different types of

130
00:03:52,400 --> 00:03:55,200
things just

131
00:03:53,040 --> 00:03:57,040
here's a few lists of things that can go

132
00:03:55,200 --> 00:03:58,879
wrong you can have a design

133
00:03:57,040 --> 00:04:00,159
denial of service you something happens

134
00:03:58,879 --> 00:04:00,959
in the application if you feed it the

135
00:04:00,159 --> 00:04:02,480
right data

136
00:04:00,959 --> 00:04:04,080
it goes into a loop that's either

137
00:04:02,480 --> 00:04:05,119
infinite or potentially infinite because

138
00:04:04,080 --> 00:04:07,360
it's going to run for

139
00:04:05,120 --> 00:04:08,159
you know 64 bits worth of computation or

140
00:04:07,360 --> 00:04:10,400
something

141
00:04:08,159 --> 00:04:12,000
um you can have a you could you can

142
00:04:10,400 --> 00:04:13,439
drive a program into a program crash in

143
00:04:12,000 --> 00:04:15,280
some circumstances

144
00:04:13,439 --> 00:04:16,560
and that's the security hole there's

145
00:04:15,280 --> 00:04:18,399
also there's more interesting sort of

146
00:04:16,560 --> 00:04:20,399
malicious activity which is

147
00:04:18,399 --> 00:04:22,000
where it's possible for data to be

148
00:04:20,399 --> 00:04:23,679
observed you can have something that's

149
00:04:22,000 --> 00:04:26,800
actually

150
00:04:23,680 --> 00:04:28,479
a direct exposure of data because of

151
00:04:26,800 --> 00:04:29,600
just buggy code handing something out

152
00:04:28,479 --> 00:04:32,479
that shouldn't be seen

153
00:04:29,600 --> 00:04:33,919
but there's also indirect uh um exposure

154
00:04:32,479 --> 00:04:35,120
of data with what's called a covert

155
00:04:33,919 --> 00:04:38,080
channel

156
00:04:35,120 --> 00:04:39,919
you feed it feed some input into a

157
00:04:38,080 --> 00:04:41,520
program make it do certain things

158
00:04:39,919 --> 00:04:43,758
and then next time you invoke some other

159
00:04:41,520 --> 00:04:45,919
operation you get a result out that's

160
00:04:43,759 --> 00:04:49,199
conditioned by what you've done before

161
00:04:45,919 --> 00:04:50,799
so a certain certain actions can reveal

162
00:04:49,199 --> 00:04:51,840
other information about another action

163
00:04:50,800 --> 00:04:53,440
the program does

164
00:04:51,840 --> 00:04:54,880
and you can drive a program to reveal

165
00:04:53,440 --> 00:04:56,960
information wasn't really meant to be

166
00:04:54,880 --> 00:04:59,120
intended that's what a covert channel is

167
00:04:56,960 --> 00:05:00,000
it's where where some actions can side

168
00:04:59,120 --> 00:05:01,919
affect other ones

169
00:05:00,000 --> 00:05:03,039
and you can you can understand the

170
00:05:01,919 --> 00:05:03,680
information about what's going on with

171
00:05:03,039 --> 00:05:05,520
the program

172
00:05:03,680 --> 00:05:07,199
or data you can actually trigger

173
00:05:05,520 --> 00:05:09,280
operations in the same sort of way

174
00:05:07,199 --> 00:05:10,720
you can invoke some behavior by by

175
00:05:09,280 --> 00:05:12,559
pushing a program in a given direction

176
00:05:10,720 --> 00:05:14,000
and end about excluding something that

177
00:05:12,560 --> 00:05:14,720
wasn't meant to happen because the bug

178
00:05:14,000 --> 00:05:16,240
in the code

179
00:05:14,720 --> 00:05:17,919
but you can also have a covert channel

180
00:05:16,240 --> 00:05:18,320
where you set the conditions up by

181
00:05:17,919 --> 00:05:20,080
running

182
00:05:18,320 --> 00:05:21,360
by feeding the program making it run a

183
00:05:20,080 --> 00:05:23,440
certain way and then

184
00:05:21,360 --> 00:05:24,639
another operation actually will go down

185
00:05:23,440 --> 00:05:25,440
a different path to the one that's

186
00:05:24,639 --> 00:05:26,880
expected

187
00:05:25,440 --> 00:05:28,320
so that's another way where a covert

188
00:05:26,880 --> 00:05:29,600
channel can actually execute things you

189
00:05:28,320 --> 00:05:31,360
don't expect

190
00:05:29,600 --> 00:05:32,880
the amazing thing that i saw talking to

191
00:05:31,360 --> 00:05:34,800
martin was this thing called

192
00:05:32,880 --> 00:05:36,800
return oriented programming you can

193
00:05:34,800 --> 00:05:38,240
actually execute unforeseen operations

194
00:05:36,800 --> 00:05:38,800
in a program without even having to jit

195
00:05:38,240 --> 00:05:39,759
in there

196
00:05:38,800 --> 00:05:41,440
so one of the things that happens when

197
00:05:39,759 --> 00:05:42,400
you have a buffer overflow you used to

198
00:05:41,440 --> 00:05:44,080
inject code

199
00:05:42,400 --> 00:05:46,320
and return into it and start executing

200
00:05:44,080 --> 00:05:47,520
stuff and then the security that hole

201
00:05:46,320 --> 00:05:48,800
was plugged by making stacks

202
00:05:47,520 --> 00:05:50,719
non-executable

203
00:05:48,800 --> 00:05:52,400
but one thing you can do is inject stuff

204
00:05:50,720 --> 00:05:52,880
on the stack which has return addresses

205
00:05:52,400 --> 00:05:54,638
in it

206
00:05:52,880 --> 00:05:56,319
that returns somewhere to the end of a

207
00:05:54,639 --> 00:05:58,160
bit of method code

208
00:05:56,319 --> 00:06:00,000
um and that method code connects to your

209
00:05:58,160 --> 00:06:01,600
instruction and then it returns back to

210
00:06:00,000 --> 00:06:03,039
where you just jumped from

211
00:06:01,600 --> 00:06:04,479
and then you can do another return to

212
00:06:03,039 --> 00:06:06,479
another bit of code with the right

213
00:06:04,479 --> 00:06:08,479
address left below that on the stack

214
00:06:06,479 --> 00:06:10,159
and you you you returned your way down a

215
00:06:08,479 --> 00:06:12,000
load of return addresses on the

216
00:06:10,160 --> 00:06:13,520
stack that you've overflown and you end

217
00:06:12,000 --> 00:06:14,720
up executing instructions for like half

218
00:06:13,520 --> 00:06:16,639
a dozen different methods

219
00:06:14,720 --> 00:06:17,840
and you put together a recipe for doing

220
00:06:16,639 --> 00:06:19,520
something that gives you

221
00:06:17,840 --> 00:06:20,880
access to something that then opens up

222
00:06:19,520 --> 00:06:21,359
something else you can make a jump to

223
00:06:20,880 --> 00:06:22,719
somewhere

224
00:06:21,360 --> 00:06:24,400
you can drive the program down a path

225
00:06:22,720 --> 00:06:26,160
that wasn't expected so

226
00:06:24,400 --> 00:06:27,919
so even without a jit in there you can

227
00:06:26,160 --> 00:06:29,680
actually assemble a sequence

228
00:06:27,919 --> 00:06:31,758
instructions that do what you want

229
00:06:29,680 --> 00:06:33,280
um of course that's that's uh harder to

230
00:06:31,759 --> 00:06:35,759
do with jitted code but

231
00:06:33,280 --> 00:06:36,559
not all the code in the jv in opengdk is

232
00:06:35,759 --> 00:06:38,240
jitted this

233
00:06:36,560 --> 00:06:39,600
compiles c code in there now i'm not

234
00:06:38,240 --> 00:06:41,280
interested really in the obvious game

235
00:06:39,600 --> 00:06:42,400
over cases where you've got access to

236
00:06:41,280 --> 00:06:44,159
the command line

237
00:06:42,400 --> 00:06:45,599
or to the class path or you can load an

238
00:06:44,160 --> 00:06:46,240
agent they're just you know not very

239
00:06:45,600 --> 00:06:48,400
interesting

240
00:06:46,240 --> 00:06:50,240
the interesting attacks are things that

241
00:06:48,400 --> 00:06:52,318
rely on escalation this is where

242
00:06:50,240 --> 00:06:53,759
uh these little funny weird the

243
00:06:52,319 --> 00:06:54,720
behaviors in the program can actually

244
00:06:53,759 --> 00:06:56,800
end up giving you

245
00:06:54,720 --> 00:06:59,039
access to tiny little hole and then most

246
00:06:56,800 --> 00:07:00,400
of the things escalate that by get

247
00:06:59,039 --> 00:07:02,560
getting their hooks in getting a chance

248
00:07:00,400 --> 00:07:04,400
to execute something or do something

249
00:07:02,560 --> 00:07:07,280
and then you can you can actually

250
00:07:04,400 --> 00:07:08,799
download a a security exploit kit

251
00:07:07,280 --> 00:07:10,719
that base you hammer in and you open up

252
00:07:08,800 --> 00:07:12,560
the whole program so that's the sort of

253
00:07:10,720 --> 00:07:13,919
scenarios that are interesting and where

254
00:07:12,560 --> 00:07:15,680
are those sort of things possible to

255
00:07:13,919 --> 00:07:19,039
happen in open jdk

256
00:07:15,680 --> 00:07:20,240
now um um i'm not i'm not there if we're

257
00:07:19,039 --> 00:07:21,680
going to look at things like spectre

258
00:07:20,240 --> 00:07:24,080
meltdown these things can happen in any

259
00:07:21,680 --> 00:07:26,000
program buffer overflows

260
00:07:24,080 --> 00:07:27,440
gdcode makes it a bit hard to exploit

261
00:07:26,000 --> 00:07:28,720
things because the code isn't always the

262
00:07:27,440 --> 00:07:29,280
same and it's not always in the same

263
00:07:28,720 --> 00:07:31,919
place

264
00:07:29,280 --> 00:07:32,479
but the vm doesn't the vm compile code

265
00:07:31,919 --> 00:07:35,520
you can

266
00:07:32,479 --> 00:07:37,280
use all the usual tricks for that um

267
00:07:35,520 --> 00:07:38,400
i'm really interested in in the things

268
00:07:37,280 --> 00:07:40,080
that are specific to the design

269
00:07:38,400 --> 00:07:42,880
invitation and what sort of attack

270
00:07:40,080 --> 00:07:44,878
surface open jdk presents that's unusual

271
00:07:42,880 --> 00:07:46,479
um

272
00:07:44,879 --> 00:07:47,919
that's different from other programs so

273
00:07:46,479 --> 00:07:49,120
what do we got to secure what is open

274
00:07:47,919 --> 00:07:51,039
jdk well

275
00:07:49,120 --> 00:07:52,160
it's a language implementation so you

276
00:07:51,039 --> 00:07:52,960
start with something that's touring

277
00:07:52,160 --> 00:07:55,039
complete

278
00:07:52,960 --> 00:07:56,560
it's got it's uh file the network i okay

279
00:07:55,039 --> 00:07:58,960
but it's got a process api

280
00:07:56,560 --> 00:08:00,479
so yeah you can do anything with it so

281
00:07:58,960 --> 00:08:02,479
there is potentially a

282
00:08:00,479 --> 00:08:04,000
big security problem there this thing is

283
00:08:02,479 --> 00:08:05,440
this general purpose programming

284
00:08:04,000 --> 00:08:07,039
language at least it's got sterling

285
00:08:05,440 --> 00:08:08,639
typing um

286
00:08:07,039 --> 00:08:10,639
but actually it's a managed runtime it

287
00:08:08,639 --> 00:08:11,919
exposes and manages all those functions

288
00:08:10,639 --> 00:08:12,720
and although there are things that you

289
00:08:11,919 --> 00:08:14,400
would normally

290
00:08:12,720 --> 00:08:16,000
have an operating system do it sort of

291
00:08:14,400 --> 00:08:18,159
does for you it it

292
00:08:16,000 --> 00:08:19,440
presents them in a very controlled way

293
00:08:18,160 --> 00:08:20,319
thread management memory management and

294
00:08:19,440 --> 00:08:23,360
so on

295
00:08:20,319 --> 00:08:24,319
so um it's also a layered managed

296
00:08:23,360 --> 00:08:28,319
runtime

297
00:08:24,319 --> 00:08:30,960
in the application um uh uh

298
00:08:28,319 --> 00:08:32,000
can do certain things but only through

299
00:08:30,960 --> 00:08:33,360
the some of those things are only

300
00:08:32,000 --> 00:08:34,799
available through jdk

301
00:08:33,360 --> 00:08:37,120
apis the core language of the core

302
00:08:34,799 --> 00:08:38,319
libraries and that's all infamous java

303
00:08:37,120 --> 00:08:40,080
code and there are only certain things

304
00:08:38,320 --> 00:08:41,760
that java code can do you can't handle

305
00:08:40,080 --> 00:08:43,360
raw pointers or whatever

306
00:08:41,760 --> 00:08:45,519
that java code gets compiled to

307
00:08:43,360 --> 00:08:47,279
equivalent machine code

308
00:08:45,519 --> 00:08:49,040
and as long as it is equivalent well

309
00:08:47,279 --> 00:08:52,160
then that's also has the same

310
00:08:49,040 --> 00:08:54,000
safety guarantees and it bottoms out at

311
00:08:52,160 --> 00:08:57,120
a layer where you go into native

312
00:08:54,000 --> 00:08:59,519
code uh into the jvm uh library

313
00:08:57,120 --> 00:09:01,200
uh methods and implement jvm apis and so

314
00:08:59,519 --> 00:09:02,800
on so there's a nice clean boundary

315
00:09:01,200 --> 00:09:03,680
between the stuff that's in java and the

316
00:09:02,800 --> 00:09:05,279
java do

317
00:09:03,680 --> 00:09:06,959
and also this other code that's written

318
00:09:05,279 --> 00:09:08,959
in c in the jvm that

319
00:09:06,959 --> 00:09:10,959
has access to things like metadata the

320
00:09:08,959 --> 00:09:12,319
jit the gc the interpreter

321
00:09:10,959 --> 00:09:14,399
all this stuff that's doing the more

322
00:09:12,320 --> 00:09:16,320
hairy stuff with a nice clean

323
00:09:14,399 --> 00:09:17,920
um divide between them and they're

324
00:09:16,320 --> 00:09:19,600
really really living separate words with

325
00:09:17,920 --> 00:09:20,880
worlds with a fairly clear interface

326
00:09:19,600 --> 00:09:24,000
between them

327
00:09:20,880 --> 00:09:26,160
um and the um that's not true in other

328
00:09:24,000 --> 00:09:28,000
jvms a java and java

329
00:09:26,160 --> 00:09:29,199
virtual machine like jikes or maxine or

330
00:09:28,000 --> 00:09:30,720
substrate um

331
00:09:29,200 --> 00:09:32,720
the code that's in there that implements

332
00:09:30,720 --> 00:09:34,640
the vm stuff has been pre-compiled into

333
00:09:32,720 --> 00:09:36,160
an image from java code

334
00:09:34,640 --> 00:09:38,080
but it could just be overwritten and

335
00:09:36,160 --> 00:09:39,360
replaced because anything's up for grabs

336
00:09:38,080 --> 00:09:41,040
in being recompiled

337
00:09:39,360 --> 00:09:42,800
at runtime in a java java machine there

338
00:09:41,040 --> 00:09:44,480
isn't this division where the c code can

339
00:09:42,800 --> 00:09:45,040
never be replaced and it just does that

340
00:09:44,480 --> 00:09:47,040
job

341
00:09:45,040 --> 00:09:48,800
and the the java jitter code only only

342
00:09:47,040 --> 00:09:50,240
has certain access paths into it

343
00:09:48,800 --> 00:09:52,479
so that's that that's the sort of

344
00:09:50,240 --> 00:09:55,760
layering uh between application

345
00:09:52,480 --> 00:09:57,200
uh jdk runtime and jvm

346
00:09:55,760 --> 00:09:59,200
and there's a separation of powers that

347
00:09:57,200 --> 00:10:01,120
goes with that there's a trust

348
00:09:59,200 --> 00:10:03,600
sort of model the app code is the least

349
00:10:01,120 --> 00:10:05,920
trusted and in particular the um

350
00:10:03,600 --> 00:10:07,360
the the jdk core runtime modules are the

351
00:10:05,920 --> 00:10:08,079
most trusted the module system has

352
00:10:07,360 --> 00:10:10,480
really

353
00:10:08,079 --> 00:10:12,560
made a much more graded leveling of

354
00:10:10,480 --> 00:10:13,040
trust and access to behaviors that are

355
00:10:12,560 --> 00:10:14,800
more

356
00:10:13,040 --> 00:10:16,160
dangerous and more risky so the modules

357
00:10:14,800 --> 00:10:19,120
has to be very important in

358
00:10:16,160 --> 00:10:21,279
in firming up this sort of layered um

359
00:10:19,120 --> 00:10:22,720
security model and separation of powers

360
00:10:21,279 --> 00:10:24,160
they're very good in the very core

361
00:10:22,720 --> 00:10:25,600
classes the stuff that allows the

362
00:10:24,160 --> 00:10:26,800
modules to communicate via sort of

363
00:10:25,600 --> 00:10:28,320
shared sequence model but

364
00:10:26,800 --> 00:10:30,240
that's very constrained so that there's

365
00:10:28,320 --> 00:10:32,160
only certain certain accesses

366
00:10:30,240 --> 00:10:33,360
there's a bit of a sort of spanner in

367
00:10:32,160 --> 00:10:36,640
the works there that a jv

368
00:10:33,360 --> 00:10:37,440
jvmti java agent can can uh get in there

369
00:10:36,640 --> 00:10:39,920
and and um

370
00:10:37,440 --> 00:10:40,959
do things um it has a few super powers

371
00:10:39,920 --> 00:10:43,120
that can break this up but

372
00:10:40,959 --> 00:10:44,719
that's obviously you can tie down agents

373
00:10:43,120 --> 00:10:46,880
and make sure they're they're only

374
00:10:44,720 --> 00:10:49,120
accessible in certain ways and then the

375
00:10:46,880 --> 00:10:51,439
most trust is the jvm code it's got the

376
00:10:49,120 --> 00:10:52,399
ability to access the operating system

377
00:10:51,440 --> 00:10:53,760
um

378
00:10:52,399 --> 00:10:56,079
there's actually some native code

379
00:10:53,760 --> 00:10:58,319
outside of lib jvm that uses system

380
00:10:56,079 --> 00:10:59,760
calls but there's also all the stuff

381
00:10:58,320 --> 00:11:01,120
most of it is actually encapsulated in

382
00:10:59,760 --> 00:11:02,640
the jv and the stuff that's doing the

383
00:11:01,120 --> 00:11:04,240
more hairy things

384
00:11:02,640 --> 00:11:06,399
and then there's the actual runtime

385
00:11:04,240 --> 00:11:07,760
stubs that the legitimate code calls so

386
00:11:06,399 --> 00:11:10,320
there's also other ways into this

387
00:11:07,760 --> 00:11:12,240
underlying behaviors uh so it's not a

388
00:11:10,320 --> 00:11:14,320
completely clear defined

389
00:11:12,240 --> 00:11:15,760
um it is clear and defined but it's it's

390
00:11:14,320 --> 00:11:17,200
done in several places and some of it is

391
00:11:15,760 --> 00:11:17,920
vitated codes it's not immediately

392
00:11:17,200 --> 00:11:20,000
evident

393
00:11:17,920 --> 00:11:22,640
where all the access to this capability

394
00:11:20,000 --> 00:11:23,920
is and then there's jv mti native agents

395
00:11:22,640 --> 00:11:24,640
that also another spanner that works at

396
00:11:23,920 --> 00:11:26,399
that level

397
00:11:24,640 --> 00:11:28,000
where it's extensible and things can go

398
00:11:26,399 --> 00:11:31,600
wrong but you have to control

399
00:11:28,000 --> 00:11:33,120
that so um what are the exploit

400
00:11:31,600 --> 00:11:33,600
opportunities that this gives that are

401
00:11:33,120 --> 00:11:36,079
sort of

402
00:11:33,600 --> 00:11:37,680
germane to this setup so i've picked

403
00:11:36,079 --> 00:11:39,120
four things where there's

404
00:11:37,680 --> 00:11:41,359
things could go wrong and i'll just talk

405
00:11:39,120 --> 00:11:43,200
about them the type system

406
00:11:41,360 --> 00:11:44,959
perspectives compilation methanols and

407
00:11:43,200 --> 00:11:48,160
the old favorite serialization

408
00:11:44,959 --> 00:11:50,239
the security nightmare of choice um

409
00:11:48,160 --> 00:11:52,639
so type safety is really powerful i mean

410
00:11:50,240 --> 00:11:55,680
and the the structuring of of type

411
00:11:52,639 --> 00:11:58,000
modules packages and type access models

412
00:11:55,680 --> 00:11:58,880
is a good way of of organizing things

413
00:11:58,000 --> 00:12:00,880
but um

414
00:11:58,880 --> 00:12:02,560
type types have to be the type safety

415
00:12:00,880 --> 00:12:03,680
has to be done by verification some of

416
00:12:02,560 --> 00:12:06,880
it offline

417
00:12:03,680 --> 00:12:08,479
java c compiles programs into a byte

418
00:12:06,880 --> 00:12:10,000
code which is quite tightly constrained

419
00:12:08,480 --> 00:12:12,079
and that means you can only actually get

420
00:12:10,000 --> 00:12:13,760
certain types of things into the jvm

421
00:12:12,079 --> 00:12:14,800
that are limited in what they're able to

422
00:12:13,760 --> 00:12:16,160
express and that

423
00:12:14,800 --> 00:12:18,000
already starts you off from a base where

424
00:12:16,160 --> 00:12:18,880
you can then check things there's a

425
00:12:18,000 --> 00:12:21,760
quick online

426
00:12:18,880 --> 00:12:23,200
verification of bytecode at class load

427
00:12:21,760 --> 00:12:24,000
and then that's followed up by further

428
00:12:23,200 --> 00:12:26,000
type checking

429
00:12:24,000 --> 00:12:28,160
at link resolve time checking across

430
00:12:26,000 --> 00:12:30,720
from one method to a called method

431
00:12:28,160 --> 00:12:31,439
and also at jit compile time a method

432
00:12:30,720 --> 00:12:32,880
tree is

433
00:12:31,440 --> 00:12:35,040
is is type checked and this type

434
00:12:32,880 --> 00:12:36,240
consistency these all rely on each other

435
00:12:35,040 --> 00:12:37,120
in a hierarchy though and there are

436
00:12:36,240 --> 00:12:38,560
assumptions that

437
00:12:37,120 --> 00:12:40,959
things checked at one point don't need

438
00:12:38,560 --> 00:12:44,079
to be checked again later on

439
00:12:40,959 --> 00:12:45,599
um and this is this is

440
00:12:44,079 --> 00:12:46,800
this is why i call it a moving target

441
00:12:45,600 --> 00:12:48,320
this is actually difficult because the

442
00:12:46,800 --> 00:12:51,120
unit of program delivery is

443
00:12:48,320 --> 00:12:52,320
class by class so the jvm is reading in

444
00:12:51,120 --> 00:12:54,160
bytecode and building up its own

445
00:12:52,320 --> 00:12:55,760
internal model of the class base and the

446
00:12:54,160 --> 00:12:58,160
types

447
00:12:55,760 --> 00:13:00,160
the type security across that is is

448
00:12:58,160 --> 00:13:01,760
being patched as you go along

449
00:13:00,160 --> 00:13:04,000
so there's information you have about

450
00:13:01,760 --> 00:13:06,000
which types of uh

451
00:13:04,000 --> 00:13:07,600
are in the in the runtime and how what

452
00:13:06,000 --> 00:13:09,200
sort of accesses are valid

453
00:13:07,600 --> 00:13:10,639
and that's always subject to revision

454
00:13:09,200 --> 00:13:13,279
because classes can be

455
00:13:10,639 --> 00:13:14,000
overridden so assumptions you make about

456
00:13:13,279 --> 00:13:16,160
what's

457
00:13:14,000 --> 00:13:17,440
type safe at one point you may actually

458
00:13:16,160 --> 00:13:20,399
have to revise or

459
00:13:17,440 --> 00:13:21,519
or extend as you load more classes into

460
00:13:20,399 --> 00:13:24,240
into the code base so

461
00:13:21,519 --> 00:13:25,760
it's definitely a a moving target there

462
00:13:24,240 --> 00:13:26,560
it's also complicated by the class

463
00:13:25,760 --> 00:13:29,839
loader model

464
00:13:26,560 --> 00:13:32,160
um classes can be loaded from the file

465
00:13:29,839 --> 00:13:33,920
system the network from different places

466
00:13:32,160 --> 00:13:35,360
it's possible to generate classes

467
00:13:33,920 --> 00:13:37,920
actually internally using

468
00:13:35,360 --> 00:13:39,440
uh using code generators and class class

469
00:13:37,920 --> 00:13:42,319
loaders can do that

470
00:13:39,440 --> 00:13:43,680
um it's also possible for class loaders

471
00:13:42,320 --> 00:13:44,959
to delegate to each other

472
00:13:43,680 --> 00:13:46,719
one class loader loads from another

473
00:13:44,959 --> 00:13:48,000
class loader and that can be switched

474
00:13:46,720 --> 00:13:49,920
around at runtime it doesn't have to be

475
00:13:48,000 --> 00:13:51,519
a static delegation network

476
00:13:49,920 --> 00:13:52,880
so there's all sorts of room for code to

477
00:13:51,519 --> 00:13:53,600
come flying at the jvm for loads of

478
00:13:52,880 --> 00:13:54,880
different places

479
00:13:53,600 --> 00:13:56,720
it's got to make sure it has a

480
00:13:54,880 --> 00:13:59,600
consistent view of the type model while

481
00:13:56,720 --> 00:14:02,880
all this is going on

482
00:13:59,600 --> 00:14:04,480
could an application benefit from that

483
00:14:02,880 --> 00:14:06,800
could could you somewhere introduce a

484
00:14:04,480 --> 00:14:09,199
disparity between the checks that happen

485
00:14:06,800 --> 00:14:10,800
at verification time and then a check

486
00:14:09,199 --> 00:14:11,920
that happens when a call method is

487
00:14:10,800 --> 00:14:14,240
checked against an actually

488
00:14:11,920 --> 00:14:15,439
a loaded class and and the signatures

489
00:14:14,240 --> 00:14:17,360
are checked and so on

490
00:14:15,440 --> 00:14:18,959
um could that happen between link

491
00:14:17,360 --> 00:14:21,120
resolve time and then the types

492
00:14:18,959 --> 00:14:22,638
that are maintained at compile time you

493
00:14:21,120 --> 00:14:25,279
might try and fiddle this by

494
00:14:22,639 --> 00:14:26,880
say breaking class to class linkage by

495
00:14:25,279 --> 00:14:28,320
dropping a class loader and then trying

496
00:14:26,880 --> 00:14:29,040
to get classes loaded from somewhere

497
00:14:28,320 --> 00:14:30,240
else and see

498
00:14:29,040 --> 00:14:32,240
if you could sneak a different a

499
00:14:30,240 --> 00:14:34,079
different class in now the

500
00:14:32,240 --> 00:14:35,279
jv and the jdk should never let this

501
00:14:34,079 --> 00:14:37,760
happen and

502
00:14:35,279 --> 00:14:38,399
uh when types are loaded there's a lot

503
00:14:37,760 --> 00:14:40,720
of effort

504
00:14:38,399 --> 00:14:42,399
to go into to make sure that the classes

505
00:14:40,720 --> 00:14:42,800
that are used and verified against each

506
00:14:42,399 --> 00:14:44,320
other

507
00:14:42,800 --> 00:14:46,319
at verification time and by code

508
00:14:44,320 --> 00:14:47,440
verification time are the same suite of

509
00:14:46,320 --> 00:14:49,920
classes that are

510
00:14:47,440 --> 00:14:50,639
used when the interpreter is doing link

511
00:14:49,920 --> 00:14:52,079
resolution

512
00:14:50,639 --> 00:14:53,760
and the same classes that are used at

513
00:14:52,079 --> 00:14:55,839
compile time so that should never happen

514
00:14:53,760 --> 00:14:57,360
but that's an area where this moving

515
00:14:55,839 --> 00:14:58,800
class base and this ability for

516
00:14:57,360 --> 00:15:00,160
for classes to come and go is something

517
00:14:58,800 --> 00:15:02,479
that needs a lot of work to make that

518
00:15:00,160 --> 00:15:02,480
happen

519
00:15:03,120 --> 00:15:06,959
um speculative compilation there's an

520
00:15:05,360 --> 00:15:09,839
interesting uh

521
00:15:06,959 --> 00:15:10,800
uh feature um this is a point where the

522
00:15:09,839 --> 00:15:12,639
with the where the

523
00:15:10,800 --> 00:15:14,560
the jvm compiles code on the basis of

524
00:15:12,639 --> 00:15:16,560
the current knowledge of the type system

525
00:15:14,560 --> 00:15:17,599
and how that's influenced influencing

526
00:15:16,560 --> 00:15:20,479
execution

527
00:15:17,600 --> 00:15:21,839
so um for example um you may you can

528
00:15:20,480 --> 00:15:22,720
also have things which not just do with

529
00:15:21,839 --> 00:15:24,639
types like

530
00:15:22,720 --> 00:15:26,320
hot branches and coal branches the jvm

531
00:15:24,639 --> 00:15:28,240
will just cut out that code from a

532
00:15:26,320 --> 00:15:30,000
compile and compile code that assumes

533
00:15:28,240 --> 00:15:31,519
you're only going to take a certain path

534
00:15:30,000 --> 00:15:32,320
you have to make sure that if that

535
00:15:31,519 --> 00:15:34,399
changes

536
00:15:32,320 --> 00:15:35,680
you don't you detect it and you go down

537
00:15:34,399 --> 00:15:38,240
the right path

538
00:15:35,680 --> 00:15:40,079
or you recompile you don't just carry on

539
00:15:38,240 --> 00:15:40,560
using that code and end up having a case

540
00:15:40,079 --> 00:15:42,560
that

541
00:15:40,560 --> 00:15:44,560
that's the wrong case the same thing if

542
00:15:42,560 --> 00:15:47,119
you do use type profiling

543
00:15:44,560 --> 00:15:48,000
you can assume that a a call which has a

544
00:15:47,120 --> 00:15:49,680
foo argument

545
00:15:48,000 --> 00:15:51,199
is always going to get a foo bar so you

546
00:15:49,680 --> 00:15:53,040
throw away the case handling for class

547
00:15:51,199 --> 00:15:55,040
foo and you always assume a foo bar

548
00:15:53,040 --> 00:15:56,800
if you don't uh if you de-optimize that

549
00:15:55,040 --> 00:15:58,079
and don't recompile the code and don't

550
00:15:56,800 --> 00:15:59,920
patch the code and

551
00:15:58,079 --> 00:16:01,758
and make sure you get a new version you

552
00:15:59,920 --> 00:16:03,040
could end up proceeding processing one

553
00:16:01,759 --> 00:16:04,160
type as though it's another type and

554
00:16:03,040 --> 00:16:06,160
that's game over

555
00:16:04,160 --> 00:16:08,000
because then you can spoof types and do

556
00:16:06,160 --> 00:16:10,160
all sorts of terrible things

557
00:16:08,000 --> 00:16:11,759
um and similarly with invoke virtual

558
00:16:10,160 --> 00:16:13,199
versus vote direct there's a mechanism

559
00:16:11,759 --> 00:16:13,680
there to allow you to make a direct call

560
00:16:13,199 --> 00:16:15,439
when there's

561
00:16:13,680 --> 00:16:17,120
only one implementation of a virtual

562
00:16:15,440 --> 00:16:18,399
method call that

563
00:16:17,120 --> 00:16:20,079
should be bulletproof it shouldn't be

564
00:16:18,399 --> 00:16:20,720
possible if you have to go and invoke a

565
00:16:20,079 --> 00:16:22,239
method

566
00:16:20,720 --> 00:16:23,600
on a class of one type when it's really

567
00:16:22,240 --> 00:16:24,000
another type but you've got to make sure

568
00:16:23,600 --> 00:16:25,440
that

569
00:16:24,000 --> 00:16:27,440
so there's an area where something

570
00:16:25,440 --> 00:16:29,920
that's done in the in the jvm

571
00:16:27,440 --> 00:16:31,199
is is actually setting up an opportunity

572
00:16:29,920 --> 00:16:32,240
for something to go wrong and there has

573
00:16:31,199 --> 00:16:33,839
to be a lot of

574
00:16:32,240 --> 00:16:35,680
careful analysis to make sure that

575
00:16:33,839 --> 00:16:37,519
actually that doesn't doesn't go wrong

576
00:16:35,680 --> 00:16:38,479
and we don't think it does but obviously

577
00:16:37,519 --> 00:16:40,320
if you're looking for somewhere where

578
00:16:38,480 --> 00:16:42,000
you won't want to

579
00:16:40,320 --> 00:16:44,000
pry your screwdriver and open a hole up

580
00:16:42,000 --> 00:16:46,800
a hole that's an area that's interesting

581
00:16:44,000 --> 00:16:50,079
it comes from the nature of of open jdk

582
00:16:46,800 --> 00:16:52,399
method handles were um

583
00:16:50,079 --> 00:16:54,319
the most recent feature to introduce

584
00:16:52,399 --> 00:16:57,360
more bugs than anything else really

585
00:16:54,320 --> 00:16:58,160
um in in recent times um it's not

586
00:16:57,360 --> 00:16:59,279
surprising

587
00:16:58,160 --> 00:17:01,040
because if you think about what was

588
00:16:59,279 --> 00:17:02,959
being done to the language it was a

589
00:17:01,040 --> 00:17:05,119
mechanism to allow indirect invocation

590
00:17:02,959 --> 00:17:06,799
of a behavior so

591
00:17:05,119 --> 00:17:08,958
before this if you wanted to invoke a

592
00:17:06,799 --> 00:17:10,319
method it was an invoking certain byte

593
00:17:08,959 --> 00:17:12,079
code that named the method

594
00:17:10,319 --> 00:17:13,599
and the type that it was appropriate to

595
00:17:12,079 --> 00:17:14,240
and the event was either virtual or

596
00:17:13,599 --> 00:17:16,000
direct or

597
00:17:14,240 --> 00:17:18,400
special for a constructor or whatever

598
00:17:16,000 --> 00:17:19,839
but it was actually a known quantity

599
00:17:18,400 --> 00:17:21,679
here it's possible to invoke a method

600
00:17:19,839 --> 00:17:23,599
that's been handed to

601
00:17:21,679 --> 00:17:25,039
from somewhere else the method handles

602
00:17:23,599 --> 00:17:25,678
being constructed and the reference to

603
00:17:25,039 --> 00:17:27,679
the method

604
00:17:25,679 --> 00:17:28,880
is indirect now one of the differences

605
00:17:27,679 --> 00:17:31,360
about that is that uh

606
00:17:28,880 --> 00:17:32,080
access verification happens at method

607
00:17:31,360 --> 00:17:33,439
handle create

608
00:17:32,080 --> 00:17:35,360
time it doesn't happen at the point

609
00:17:33,440 --> 00:17:36,799
where the methanol is invoked

610
00:17:35,360 --> 00:17:38,959
so there's a different model for what

611
00:17:36,799 --> 00:17:40,240
how you secure accesses to methods with

612
00:17:38,960 --> 00:17:41,919
method handles

613
00:17:40,240 --> 00:17:44,000
um so it's quite easy to think to hand

614
00:17:41,919 --> 00:17:44,559
out a handle to some code that shouldn't

615
00:17:44,000 --> 00:17:45,919
actually

616
00:17:44,559 --> 00:17:47,600
be getting it there's a very obvious way

617
00:17:45,919 --> 00:17:49,200
for that to go wrong

618
00:17:47,600 --> 00:17:50,799
but there's also some of the details of

619
00:17:49,200 --> 00:17:51,679
how method header works they're able to

620
00:17:50,799 --> 00:17:53,360
be called

621
00:17:51,679 --> 00:17:54,799
either with an exact signature in which

622
00:17:53,360 --> 00:17:56,320
case you have to have exact matching

623
00:17:54,799 --> 00:17:59,679
types and argument types

624
00:17:56,320 --> 00:18:01,840
or or an inexact signature where

625
00:17:59,679 --> 00:18:03,520
certain operations can happen during the

626
00:18:01,840 --> 00:18:06,559
call that are in ins

627
00:18:03,520 --> 00:18:07,840
that are performed um by the runtime to

628
00:18:06,559 --> 00:18:09,280
massage arguments

629
00:18:07,840 --> 00:18:10,879
make sure to make sure the right type

630
00:18:09,280 --> 00:18:11,280
and so on and then eventually pass them

631
00:18:10,880 --> 00:18:13,520
through

632
00:18:11,280 --> 00:18:15,039
to the target method handle and you can

633
00:18:13,520 --> 00:18:17,120
do things like argument shuffles and so

634
00:18:15,039 --> 00:18:18,160
on this was all implemented in the jvm

635
00:18:17,120 --> 00:18:21,039
initially

636
00:18:18,160 --> 00:18:22,080
and it was a very very big perturbation

637
00:18:21,039 --> 00:18:23,600
to the jvm

638
00:18:22,080 --> 00:18:25,918
because it was such a lot of code was

639
00:18:23,600 --> 00:18:28,080
needed and it was later reimplemented

640
00:18:25,919 --> 00:18:29,200
using bytecode that was generated from

641
00:18:28,080 --> 00:18:31,520
jdk instances

642
00:18:29,200 --> 00:18:32,640
uh method handle classes in in the in

643
00:18:31,520 --> 00:18:34,879
the jdk

644
00:18:32,640 --> 00:18:36,480
um and that made it much more secure and

645
00:18:34,880 --> 00:18:39,840
it deduced a lot of bugs

646
00:18:36,480 --> 00:18:40,960
um and it certainly meant that ever

647
00:18:39,840 --> 00:18:42,959
since then

648
00:18:40,960 --> 00:18:44,480
really big changes to the jvm have been

649
00:18:42,960 --> 00:18:46,799
absolutely avoided we're trying to

650
00:18:44,480 --> 00:18:48,880
everything was as very conservative

651
00:18:46,799 --> 00:18:50,000
as possible approach to changing jvm

652
00:18:48,880 --> 00:18:51,840
functionality because

653
00:18:50,000 --> 00:18:53,120
the lesson from this this was that a

654
00:18:51,840 --> 00:18:54,720
really major structural change to the

655
00:18:53,120 --> 00:18:57,520
jvm was going to have problems for a

656
00:18:54,720 --> 00:18:59,600
long long time

657
00:18:57,520 --> 00:19:01,760
and then of course the serialization at

658
00:18:59,600 --> 00:19:03,600
the best saved the best to last it's the

659
00:19:01,760 --> 00:19:05,919
exploit trap that keeps on giving

660
00:19:03,600 --> 00:19:07,039
it's a very old feature it's always be

661
00:19:05,919 --> 00:19:09,360
been responsible for

662
00:19:07,039 --> 00:19:10,720
for bugs have been loads of exploits the

663
00:19:09,360 --> 00:19:11,918
fundamental problem is that when you

664
00:19:10,720 --> 00:19:13,919
serialize an object

665
00:19:11,919 --> 00:19:16,000
to to persistent storage and you

666
00:19:13,919 --> 00:19:17,840
deserialize it or you deserialize it

667
00:19:16,000 --> 00:19:19,440
serialize and deserialize through memory

668
00:19:17,840 --> 00:19:21,520
you're basically creating an object from

669
00:19:19,440 --> 00:19:23,600
scratch from a saved version of it

670
00:19:21,520 --> 00:19:25,200
and you're installing all the fields

671
00:19:23,600 --> 00:19:26,000
bypassing the normal construction

672
00:19:25,200 --> 00:19:27,600
process

673
00:19:26,000 --> 00:19:30,080
and you're taking whatever you get out

674
00:19:27,600 --> 00:19:32,000
of the the deserialization stream

675
00:19:30,080 --> 00:19:34,159
um so there's lots of opportunity to

676
00:19:32,000 --> 00:19:35,919
spoof things there and to give you data

677
00:19:34,160 --> 00:19:38,320
and to get things snuck into an object

678
00:19:35,919 --> 00:19:40,880
in a way where it's not validated

679
00:19:38,320 --> 00:19:42,559
and it's even worse because it's

680
00:19:40,880 --> 00:19:45,280
possible to provide

681
00:19:42,559 --> 00:19:46,799
custom serializers and deserializers so

682
00:19:45,280 --> 00:19:48,399
there's always room for new bugs by

683
00:19:46,799 --> 00:19:50,160
people building their own serialization

684
00:19:48,400 --> 00:19:52,480
and deserialization frameworks

685
00:19:50,160 --> 00:19:53,840
andrew will chase one of these for weeks

686
00:19:52,480 --> 00:19:57,200
and weeks and weeks

687
00:19:53,840 --> 00:20:00,240
a fast serialization uh library it was

688
00:19:57,200 --> 00:20:01,440
too fast so so this one's

689
00:20:00,240 --> 00:20:03,600
i guess i don't know this is everything

690
00:20:01,440 --> 00:20:07,840
can we deprecate serialization is it

691
00:20:03,600 --> 00:20:07,840
we're gonna go

692
00:20:08,159 --> 00:20:11,520
okay so there's just four different

693
00:20:10,640 --> 00:20:14,000
parts of the way

694
00:20:11,520 --> 00:20:14,799
open jdk works where you can um you can

695
00:20:14,000 --> 00:20:16,400
uh see

696
00:20:14,799 --> 00:20:18,559
there's all sorts of complexity it's

697
00:20:16,400 --> 00:20:19,679
really specific to the this type of

698
00:20:18,559 --> 00:20:22,480
managed runtime

699
00:20:19,679 --> 00:20:23,919
and if you can go away and find a nice

700
00:20:22,480 --> 00:20:25,440
little security hole there and get a

701
00:20:23,919 --> 00:20:26,640
reproducer send it to us and we'll try

702
00:20:25,440 --> 00:20:28,400
and fix it

703
00:20:26,640 --> 00:20:30,799
don't sell it to some some bad guy

704
00:20:28,400 --> 00:20:30,799
please

705
00:20:33,600 --> 00:20:48,719
right do we have time for questions very

706
00:20:36,400 --> 00:20:51,919
great okay

707
00:20:48,720 --> 00:20:54,159
is anybody going to be first

708
00:20:51,919 --> 00:20:54,159
hey

709
00:20:57,919 --> 00:21:01,280
i think in your list you have forgotten

710
00:21:00,799 --> 00:21:05,200
the

711
00:21:01,280 --> 00:21:09,039
the way that the security works

712
00:21:05,200 --> 00:21:10,960
by walking the stack yes which is a very

713
00:21:09,039 --> 00:21:12,799
very weird way

714
00:21:10,960 --> 00:21:14,480
yeah to do things yes when you're

715
00:21:12,799 --> 00:21:14,879
actually verifying something trying to

716
00:21:14,480 --> 00:21:16,799
create

717
00:21:14,880 --> 00:21:18,880
a method handle it involves looking up

718
00:21:16,799 --> 00:21:21,918
the stack to see who's trying to do it

719
00:21:18,880 --> 00:21:24,799
so honestly and that's that's well you

720
00:21:21,919 --> 00:21:28,840
know it was because it works

721
00:21:24,799 --> 00:21:31,840
so yeah that's an important detail thank

722
00:21:28,840 --> 00:21:31,840
you

723
00:21:31,890 --> 00:21:37,200
[Laughter]

724
00:21:34,960 --> 00:21:38,159
um intel have been uh proposing things

725
00:21:37,200 --> 00:21:40,799
like scads

726
00:21:38,159 --> 00:21:42,799
separate uh control and data stacks uh

727
00:21:40,799 --> 00:21:44,480
and cet to kind of like

728
00:21:42,799 --> 00:21:46,320
verify the returns are going to where

729
00:21:44,480 --> 00:21:48,720
they came from um

730
00:21:46,320 --> 00:21:51,039
and of course these are abi changes so

731
00:21:48,720 --> 00:21:53,760
they'll need support in the in the jdk

732
00:21:51,039 --> 00:21:54,400
uh is this anything you're looking at i

733
00:21:53,760 --> 00:21:56,080
just

734
00:21:54,400 --> 00:21:57,120
i just found out of this for martin i

735
00:21:56,080 --> 00:21:58,480
thought it'd be a really neat thing to

736
00:21:57,120 --> 00:21:59,840
talk about i have no idea what people

737
00:21:58,480 --> 00:22:01,760
are trying to do to fix

738
00:21:59,840 --> 00:22:03,360
that problem so it sounds interesting

739
00:22:01,760 --> 00:22:04,640
and i'd be interested to look at it i

740
00:22:03,360 --> 00:22:05,760
think martin would probably feel that

741
00:22:04,640 --> 00:22:08,400
better than me

742
00:22:05,760 --> 00:22:10,640
he's uh he's really good yeah i'm sure

743
00:22:08,400 --> 00:22:12,320
he'd love that stuff

744
00:22:10,640 --> 00:22:14,000
would be most interesting to see what

745
00:22:12,320 --> 00:22:16,639
you had to do to the jets to make that

746
00:22:14,000 --> 00:22:16,640
stuff work

747
00:22:22,159 --> 00:22:25,679
also heading to the list and now there

748
00:22:24,080 --> 00:22:27,439
is a certain

749
00:22:25,679 --> 00:22:29,280
a number of projects out there uh that

750
00:22:27,440 --> 00:22:31,679
are trying to exploit the

751
00:22:29,280 --> 00:22:33,678
trying to leverage from persisting

752
00:22:31,679 --> 00:22:36,159
compile code in various ways

753
00:22:33,679 --> 00:22:37,039
there's a one from ibm you know at this

754
00:22:36,159 --> 00:22:39,039
uh

755
00:22:37,039 --> 00:22:40,799
there's one that azul is doing and then

756
00:22:39,039 --> 00:22:43,600
and there's also

757
00:22:40,799 --> 00:22:45,840
um um there's this in the upstream in

758
00:22:43,600 --> 00:22:48,000
upstream there's also a

759
00:22:45,840 --> 00:22:49,199
native image so there are wherever you

760
00:22:48,000 --> 00:22:51,760
save a native image

761
00:22:49,200 --> 00:22:52,559
and it's being loaded later on um

762
00:22:51,760 --> 00:22:54,799
there's always

763
00:22:52,559 --> 00:22:56,240
at this point it passes there the

764
00:22:54,799 --> 00:22:58,639
verifier and

765
00:22:56,240 --> 00:22:59,440
and you just run native code where and

766
00:22:58,640 --> 00:23:01,440
so

767
00:22:59,440 --> 00:23:03,200
i guess the the premises there is that

768
00:23:01,440 --> 00:23:06,559
whoever provides this native

769
00:23:03,200 --> 00:23:08,480
image file network stream

770
00:23:06,559 --> 00:23:10,639
needs to ensure its authenticity but

771
00:23:08,480 --> 00:23:12,640
maybe it's often forgotten

772
00:23:10,640 --> 00:23:14,799
yeah that's a really good point i mean

773
00:23:12,640 --> 00:23:16,799
and so this is true for class data

774
00:23:14,799 --> 00:23:18,240
sharing as well that something could

775
00:23:16,799 --> 00:23:19,840
that could have errors in it could be

776
00:23:18,240 --> 00:23:20,720
tampered with there's room for things to

777
00:23:19,840 --> 00:23:23,039
go wrong there

778
00:23:20,720 --> 00:23:24,880
and the the the the growl native images

779
00:23:23,039 --> 00:23:26,960
there's nothing you can possibly check

780
00:23:24,880 --> 00:23:28,480
it's it's a binary that you just run but

781
00:23:26,960 --> 00:23:30,400
you build binaries and trust them and

782
00:23:28,480 --> 00:23:31,919
run them in other languages as well

783
00:23:30,400 --> 00:23:33,840
i guess there's the problem the question

784
00:23:31,919 --> 00:23:35,760
of is the nature of how that binary

785
00:23:33,840 --> 00:23:37,760
that binary is constructed or shared

786
00:23:35,760 --> 00:23:39,360
libraries constructed such that

787
00:23:37,760 --> 00:23:41,440
you have other trust issues that you

788
00:23:39,360 --> 00:23:42,799
wouldn't have with say a compiled c

789
00:23:41,440 --> 00:23:44,720
program i'm not sure what the answer to

790
00:23:42,799 --> 00:23:47,360
that is but it's an interesting question

791
00:23:44,720 --> 00:23:48,240
i think you do and this would be a good

792
00:23:47,360 --> 00:23:50,158
point

793
00:23:48,240 --> 00:23:52,240
for me to point out that back in the

794
00:23:50,159 --> 00:23:54,159
days of gcj we made a tree of

795
00:23:52,240 --> 00:23:56,400
cryptographic checksums

796
00:23:54,159 --> 00:23:58,480
uh that we used to match up the

797
00:23:56,400 --> 00:24:01,120
precompiled uh

798
00:23:58,480 --> 00:24:02,799
program with the bytecode file well that

799
00:24:01,120 --> 00:24:04,559
would work for class data sharing we've

800
00:24:02,799 --> 00:24:06,559
got separate method code

801
00:24:04,559 --> 00:24:08,960
with gral it's a great big munged

802
00:24:06,559 --> 00:24:11,678
optimized image

803
00:24:08,960 --> 00:24:13,039
heavily optimized so it's yeah there's

804
00:24:11,679 --> 00:24:13,840
that's not an approach that you could

805
00:24:13,039 --> 00:24:15,279
really use

806
00:24:13,840 --> 00:24:16,080
so i suppose you could you could check

807
00:24:15,279 --> 00:24:17,520
some of the things to make sure

808
00:24:16,080 --> 00:24:18,879
something hadn't tampered with it when

809
00:24:17,520 --> 00:24:21,840
you reloaded it

810
00:24:18,880 --> 00:24:23,120
but um you know knowing the integrity of

811
00:24:21,840 --> 00:24:26,720
all the parts is

812
00:24:23,120 --> 00:24:26,719
not really a it's a non-starter

813
00:24:27,919 --> 00:24:32,000
area yeah but that's true also of a

814
00:24:31,039 --> 00:24:33,840
compiled optimized

815
00:24:32,000 --> 00:24:36,240
c program it's not unusual in that

816
00:24:33,840 --> 00:24:38,799
regard um

817
00:24:36,240 --> 00:24:40,400
yeah you have to trust the producer yeah

818
00:24:38,799 --> 00:24:43,600
you have just the computer yeah you know

819
00:24:40,400 --> 00:24:47,200
he's computers i don't trust him

820
00:24:43,600 --> 00:24:50,709
i'm a luddite anyone else or

821
00:24:47,200 --> 00:24:58,589
are we done thank you all right thank

822
00:24:50,710 --> 00:24:58,589
[Applause]

823
00:24:58,840 --> 00:25:01,840
you

824
00:25:01,919 --> 00:25:04,000
you

