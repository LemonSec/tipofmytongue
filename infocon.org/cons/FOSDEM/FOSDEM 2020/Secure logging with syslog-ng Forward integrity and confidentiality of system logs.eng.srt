1
00:00:07,919 --> 00:00:12,079
so hello everyone welcome to our

2
00:00:09,519 --> 00:00:13,360
next talk in security the room and it's

3
00:00:12,080 --> 00:00:15,839
stefan and his

4
00:00:13,360 --> 00:00:18,640
talk about secure login with syslog ng

5
00:00:15,839 --> 00:00:18,640
so let's welcome

6
00:00:21,199 --> 00:00:25,519
thank you so yeah i'm going to talk

7
00:00:23,119 --> 00:00:27,039
about uh secure logging with syslock ng

8
00:00:25,519 --> 00:00:29,038
that's a project that we performed at

9
00:00:27,039 --> 00:00:31,679
our bus but of course we profited a lot

10
00:00:29,039 --> 00:00:34,000
from the open source community

11
00:00:31,679 --> 00:00:36,079
and i hope that you will also enjoy what

12
00:00:34,000 --> 00:00:37,840
we've enjoyed when using this

13
00:00:36,079 --> 00:00:39,280
development model so i'm going to talk

14
00:00:37,840 --> 00:00:42,399
about forward integrity

15
00:00:39,280 --> 00:00:44,559
and confidentiality and before

16
00:00:42,399 --> 00:00:46,160
actually coming to the topic i want to

17
00:00:44,559 --> 00:00:48,239
perform what we want to

18
00:00:46,160 --> 00:00:49,760
protect against so what is actually the

19
00:00:48,239 --> 00:00:51,199
threat model that we want to protect

20
00:00:49,760 --> 00:00:53,920
against

21
00:00:51,199 --> 00:00:54,719
so forward integrity and confidentiality

22
00:00:53,920 --> 00:00:57,520
is about

23
00:00:54,719 --> 00:00:58,079
securing the lock hose against attackers

24
00:00:57,520 --> 00:01:01,120
that gain

25
00:00:58,079 --> 00:01:03,120
full compromise so currently

26
00:01:01,120 --> 00:01:04,959
if an attacker is able to compromise

27
00:01:03,120 --> 00:01:06,880
your system fully he can mess up the

28
00:01:04,959 --> 00:01:09,759
locks and tries to hide his traces

29
00:01:06,880 --> 00:01:10,240
for example he can delete files he can

30
00:01:09,760 --> 00:01:12,080
delete

31
00:01:10,240 --> 00:01:14,240
individual lock entries from your file

32
00:01:12,080 --> 00:01:16,640
it can even alter

33
00:01:14,240 --> 00:01:18,320
individual log entries and you will not

34
00:01:16,640 --> 00:01:20,240
never notice it if you have

35
00:01:18,320 --> 00:01:22,158
any security mechanism attached to your

36
00:01:20,240 --> 00:01:23,839
log file the problem is typically you

37
00:01:22,159 --> 00:01:25,040
you open a log file you can delete one

38
00:01:23,840 --> 00:01:27,200
line you will never know that

39
00:01:25,040 --> 00:01:29,439
that was there originally so that's what

40
00:01:27,200 --> 00:01:31,200
we want to protect against in addition

41
00:01:29,439 --> 00:01:33,600
we at airbus you know we are producing

42
00:01:31,200 --> 00:01:35,439
aircraft and aircraft are not always

43
00:01:33,600 --> 00:01:37,839
connected to a network they are

44
00:01:35,439 --> 00:01:40,000
connected to a network sometimes

45
00:01:37,840 --> 00:01:42,240
those through specific protocols but

46
00:01:40,000 --> 00:01:43,759
they are also disconnected

47
00:01:42,240 --> 00:01:45,839
so when an attacker for example is

48
00:01:43,759 --> 00:01:48,079
compromising our system that's airborne

49
00:01:45,840 --> 00:01:48,880
which is about the airplane so there is

50
00:01:48,079 --> 00:01:50,960
no connection

51
00:01:48,880 --> 00:01:53,600
so we want to protect it also when it's

52
00:01:50,960 --> 00:01:56,079
airborne and typically in our

53
00:01:53,600 --> 00:01:57,679
in our operational model log files get

54
00:01:56,079 --> 00:01:58,398
offloaded off the airplane when it's at

55
00:01:57,680 --> 00:02:00,479
the airport

56
00:01:58,399 --> 00:02:02,719
through a series of mechanisms but

57
00:02:00,479 --> 00:02:04,320
typically we can assume that an attacker

58
00:02:02,719 --> 00:02:05,919
for example that is on board the

59
00:02:04,320 --> 00:02:08,799
airplane is trying to take our systems

60
00:02:05,920 --> 00:02:10,878
so we must also take that into account

61
00:02:08,800 --> 00:02:11,840
so how does log integrity now work in

62
00:02:10,878 --> 00:02:13,679
principle so

63
00:02:11,840 --> 00:02:16,480
we have a log host here you see a log

64
00:02:13,680 --> 00:02:18,720
host it's an airborne computer it is a

65
00:02:16,480 --> 00:02:20,079
standard uh form factor for airborne

66
00:02:18,720 --> 00:02:22,239
computers quite different than the ones

67
00:02:20,080 --> 00:02:24,080
you use that in a server act properly

68
00:02:22,239 --> 00:02:25,680
that's an airborne server rack what you

69
00:02:24,080 --> 00:02:28,319
see here so that's our unit

70
00:02:25,680 --> 00:02:30,160
and it is the log host so other systems

71
00:02:28,319 --> 00:02:32,238
are connected to it and other systems

72
00:02:30,160 --> 00:02:33,920
are providing lock records to that block

73
00:02:32,239 --> 00:02:37,360
host so at time t

74
00:02:33,920 --> 00:02:39,599
naught we have a lock entry lnord and so

75
00:02:37,360 --> 00:02:41,519
on so we have a series of time

76
00:02:39,599 --> 00:02:42,879
of lock entries so now what does lock

77
00:02:41,519 --> 00:02:45,360
integrity mean

78
00:02:42,879 --> 00:02:46,000
so let's assume that at this particular

79
00:02:45,360 --> 00:02:48,720
time

80
00:02:46,000 --> 00:02:50,319
somebody is trying to mess up with the

81
00:02:48,720 --> 00:02:52,239
locks after having successfully

82
00:02:50,319 --> 00:02:53,920
compromised our system

83
00:02:52,239 --> 00:02:55,920
what does that what does the attacker

84
00:02:53,920 --> 00:02:57,679
typically do he will probably delete

85
00:02:55,920 --> 00:03:00,159
that lock entry he will probably

86
00:02:57,680 --> 00:03:00,879
change log actually edit the lock entry

87
00:03:00,159 --> 00:03:03,359
and

88
00:03:00,879 --> 00:03:04,159
what does that mean for us so our log

89
00:03:03,360 --> 00:03:06,720
file will now

90
00:03:04,159 --> 00:03:08,560
have an altered entry in this example we

91
00:03:06,720 --> 00:03:11,920
changed the log file so you see this

92
00:03:08,560 --> 00:03:12,560
l three prime here so the l3 prime

93
00:03:11,920 --> 00:03:14,319
cannot

94
00:03:12,560 --> 00:03:17,120
pretty cannot be distinguished from what

95
00:03:14,319 --> 00:03:19,920
was originally stored under l3

96
00:03:17,120 --> 00:03:20,319
so let's assume that the attacker has

97
00:03:19,920 --> 00:03:22,720
gained

98
00:03:20,319 --> 00:03:24,159
root access so we'll probably have a

99
00:03:22,720 --> 00:03:26,080
root access on the lock

100
00:03:24,159 --> 00:03:27,599
so that rook access at that time will be

101
00:03:26,080 --> 00:03:30,239
deleted so how can we

102
00:03:27,599 --> 00:03:31,760
know that this was the case so with our

103
00:03:30,239 --> 00:03:32,560
principle now that we've added to this

104
00:03:31,760 --> 00:03:35,200
log in g

105
00:03:32,560 --> 00:03:36,799
we can use a very fire later on to

106
00:03:35,200 --> 00:03:39,280
actually verify that this

107
00:03:36,799 --> 00:03:40,319
changed log entry a3 nor was not the

108
00:03:39,280 --> 00:03:42,480
original one

109
00:03:40,319 --> 00:03:46,480
so the verifier would indicate that

110
00:03:42,480 --> 00:03:48,399
there was a tempering with our log file

111
00:03:46,480 --> 00:03:50,159
what does forward integrity actually

112
00:03:48,400 --> 00:03:54,400
mean you're probably

113
00:03:50,159 --> 00:03:56,319
aware of the forward integrity in

114
00:03:54,400 --> 00:03:58,000
network encryption so it's a very

115
00:03:56,319 --> 00:04:00,720
similar principles here so we

116
00:03:58,000 --> 00:04:01,120
write a series of entries and the time

117
00:04:00,720 --> 00:04:03,519
and

118
00:04:01,120 --> 00:04:04,640
as in the previous example we compromise

119
00:04:03,519 --> 00:04:07,920
at a particular

120
00:04:04,640 --> 00:04:09,599
instance of time we compromise an entry

121
00:04:07,920 --> 00:04:11,599
and then we know that because the

122
00:04:09,599 --> 00:04:13,119
attacker has already compromised it at

123
00:04:11,599 --> 00:04:15,280
that particular instance of time

124
00:04:13,120 --> 00:04:16,320
everything will be lost because we

125
00:04:15,280 --> 00:04:18,079
cannot rely

126
00:04:16,320 --> 00:04:20,399
on what has been written to the lock

127
00:04:18,079 --> 00:04:22,880
after the lock has been compromised

128
00:04:20,399 --> 00:04:25,198
forward integrity now means that we can

129
00:04:22,880 --> 00:04:27,280
still rely on what was there originally

130
00:04:25,199 --> 00:04:28,960
so if the attacker hasn't tampered with

131
00:04:27,280 --> 00:04:31,840
let's say all the lock entries

132
00:04:28,960 --> 00:04:33,840
before t3 in this example we can still

133
00:04:31,840 --> 00:04:34,560
use them for forensic purposes which is

134
00:04:33,840 --> 00:04:36,400
great

135
00:04:34,560 --> 00:04:38,160
because in an old model where we don't

136
00:04:36,400 --> 00:04:39,120
have forward integrity we can forget the

137
00:04:38,160 --> 00:04:41,040
whole log

138
00:04:39,120 --> 00:04:43,840
so the question is how can we achieve

139
00:04:41,040 --> 00:04:43,840
that

140
00:04:43,919 --> 00:04:48,080
i'm going to present you the algorithm

141
00:04:45,600 --> 00:04:48,560
so i will not go through all the details

142
00:04:48,080 --> 00:04:50,159
uh

143
00:04:48,560 --> 00:04:53,040
you can read our paper which is on the

144
00:04:50,160 --> 00:04:54,720
foster website how that actually works

145
00:04:53,040 --> 00:04:56,720
i will just explain briefly the

146
00:04:54,720 --> 00:04:57,280
principle about how this is supposed to

147
00:04:56,720 --> 00:04:58,880
work

148
00:04:57,280 --> 00:05:00,719
it's very similar so some colleagues

149
00:04:58,880 --> 00:05:03,199
that i talked to mentioned the word

150
00:05:00,720 --> 00:05:05,360
blockchain that is a very fancy topic

151
00:05:03,199 --> 00:05:07,280
i will not go into that any further but

152
00:05:05,360 --> 00:05:10,160
it's similar in principle

153
00:05:07,280 --> 00:05:12,320
so the basic idea is this so at each

154
00:05:10,160 --> 00:05:13,520
instance of time when you write a lock

155
00:05:12,320 --> 00:05:16,240
entry

156
00:05:13,520 --> 00:05:16,560
together with that lock entry you write

157
00:05:16,240 --> 00:05:19,759
an

158
00:05:16,560 --> 00:05:21,039
hmx so a hashed mac for that particular

159
00:05:19,759 --> 00:05:24,639
long entry that mac

160
00:05:21,039 --> 00:05:26,719
protects the lock entry so that means

161
00:05:24,639 --> 00:05:29,680
that you encrypt the lock entry and you

162
00:05:26,720 --> 00:05:31,120
hash it and you write both to the lock

163
00:05:29,680 --> 00:05:33,120
record

164
00:05:31,120 --> 00:05:35,440
now you can say okay if we do this for

165
00:05:33,120 --> 00:05:37,280
each and every lock entry

166
00:05:35,440 --> 00:05:38,880
then do we always use the same key

167
00:05:37,280 --> 00:05:40,400
because then we wouldn't have forward

168
00:05:38,880 --> 00:05:42,159
integrity

169
00:05:40,400 --> 00:05:44,159
and in our example and of course we

170
00:05:42,160 --> 00:05:46,560
don't do that what we do is we do

171
00:05:44,160 --> 00:05:48,720
key evolvement that means that each

172
00:05:46,560 --> 00:05:49,039
individual log entry is encrypted with

173
00:05:48,720 --> 00:05:52,400
its

174
00:05:49,039 --> 00:05:53,520
own key and the queen is then deleted

175
00:05:52,400 --> 00:05:55,120
from the system

176
00:05:53,520 --> 00:05:57,039
and this is what gives us the forward

177
00:05:55,120 --> 00:05:59,039
integrity because the

178
00:05:57,039 --> 00:06:01,440
the attacker that would compromise our

179
00:05:59,039 --> 00:06:03,120
system at a particular instance of time

180
00:06:01,440 --> 00:06:04,479
of course has access to a key which is

181
00:06:03,120 --> 00:06:05,759
stored in the system

182
00:06:04,479 --> 00:06:07,520
but that key doesn't give him any

183
00:06:05,759 --> 00:06:09,120
additional information about what was

184
00:06:07,520 --> 00:06:10,639
originally encrypted before that

185
00:06:09,120 --> 00:06:12,479
compromise

186
00:06:10,639 --> 00:06:14,080
so now you can say okay if i do that

187
00:06:12,479 --> 00:06:16,719
that's nice but what if i

188
00:06:14,080 --> 00:06:18,318
i delete let's say at time t2 a lock

189
00:06:16,720 --> 00:06:19,680
entry for my lock how will you notice

190
00:06:18,319 --> 00:06:21,759
that

191
00:06:19,680 --> 00:06:22,960
in order to guarantee the integrity of

192
00:06:21,759 --> 00:06:25,280
the whole log file

193
00:06:22,960 --> 00:06:27,039
for example we an attacker might either

194
00:06:25,280 --> 00:06:28,880
delete an individual lock entry or he

195
00:06:27,039 --> 00:06:31,039
might truncate the log

196
00:06:28,880 --> 00:06:32,240
we also have to protect the whole lock

197
00:06:31,039 --> 00:06:35,440
archive

198
00:06:32,240 --> 00:06:37,600
and this is we we do this by what is

199
00:06:35,440 --> 00:06:41,360
named here aggregated mac

200
00:06:37,600 --> 00:06:43,440
so we compute an aggregated hmac over

201
00:06:41,360 --> 00:06:46,080
the whole log file in addition

202
00:06:43,440 --> 00:06:47,360
to the map that we created for a single

203
00:06:46,080 --> 00:06:50,240
log entry

204
00:06:47,360 --> 00:06:52,240
so now if you delete an individual log

205
00:06:50,240 --> 00:06:53,039
entry from the file we will notice that

206
00:06:52,240 --> 00:06:56,960
when we check

207
00:06:53,039 --> 00:06:57,680
that mac so and in order to be efficient

208
00:06:56,960 --> 00:07:00,560
we do this

209
00:06:57,680 --> 00:07:01,120
iteratively like like you see here so we

210
00:07:00,560 --> 00:07:03,680
start

211
00:07:01,120 --> 00:07:05,520
with the keynote which is the individual

212
00:07:03,680 --> 00:07:08,000
initial key that is installed on our

213
00:07:05,520 --> 00:07:09,840
server when we put it into the airplane

214
00:07:08,000 --> 00:07:12,240
and once the first log entry gets

215
00:07:09,840 --> 00:07:14,318
written we create the key key one and

216
00:07:12,240 --> 00:07:15,280
here you see how the key evolvement is

217
00:07:14,319 --> 00:07:18,479
actually

218
00:07:15,280 --> 00:07:19,359
uh happening so you have the k key i so

219
00:07:18,479 --> 00:07:22,479
the

220
00:07:19,360 --> 00:07:23,120
k the the key at instance t3 is based on

221
00:07:22,479 --> 00:07:25,599
the key

222
00:07:23,120 --> 00:07:27,120
at instance d2 so we derive the key from

223
00:07:25,599 --> 00:07:29,120
the previous key

224
00:07:27,120 --> 00:07:30,639
so this is the what is similar to a

225
00:07:29,120 --> 00:07:33,520
blockchain so to say

226
00:07:30,639 --> 00:07:35,599
but we we also do the same for the

227
00:07:33,520 --> 00:07:37,039
aggregated mac so this gives us the

228
00:07:35,599 --> 00:07:41,280
protection of the whole

229
00:07:37,039 --> 00:07:41,680
lock archive now how did we implement

230
00:07:41,280 --> 00:07:44,080
that

231
00:07:41,680 --> 00:07:45,840
so this is essentially a theoretical

232
00:07:44,080 --> 00:07:47,599
example that was also presented at some

233
00:07:45,840 --> 00:07:48,960
cryptography conferences

234
00:07:47,599 --> 00:07:50,639
and what we actually did in our project

235
00:07:48,960 --> 00:07:51,758
was to answer the question okay this is

236
00:07:50,639 --> 00:07:53,680
a nice principle

237
00:07:51,759 --> 00:07:56,639
how can we apply it to the onboard

238
00:07:53,680 --> 00:07:58,800
logging system how can we implement it

239
00:07:56,639 --> 00:07:59,840
and then we came across the syslog and

240
00:07:58,800 --> 00:08:02,800
ghee architecture

241
00:07:59,840 --> 00:08:04,960
which you see here so we chose this lock

242
00:08:02,800 --> 00:08:07,520
ng because syslog ng has a very nice

243
00:08:04,960 --> 00:08:09,599
architecture which makes it extensible

244
00:08:07,520 --> 00:08:11,840
and you see here syslog ng essentially

245
00:08:09,599 --> 00:08:14,960
has these

246
00:08:11,840 --> 00:08:15,359
mechanisms to extend it so in the syslog

247
00:08:14,960 --> 00:08:17,440
ng

248
00:08:15,360 --> 00:08:19,440
terminology which you can look up also

249
00:08:17,440 --> 00:08:20,879
on their website i put it here so you

250
00:08:19,440 --> 00:08:22,080
if you in case you're interested you can

251
00:08:20,879 --> 00:08:23,840
pull it down from there it's very

252
00:08:22,080 --> 00:08:25,680
comprehensive

253
00:08:23,840 --> 00:08:27,198
they have a source driver which is a

254
00:08:25,680 --> 00:08:28,960
piece of software that actually

255
00:08:27,199 --> 00:08:31,120
acquires lock records maybe from a

256
00:08:28,960 --> 00:08:33,598
network socket login classic syslog

257
00:08:31,120 --> 00:08:35,120
it may be a file it may be a database

258
00:08:33,599 --> 00:08:38,399
wherever it comes from

259
00:08:35,120 --> 00:08:40,719
it can be fed into the syslog ng system

260
00:08:38,399 --> 00:08:41,679
then it has a filter mechanism so we can

261
00:08:40,719 --> 00:08:44,240
actually

262
00:08:41,679 --> 00:08:46,319
filter and route individual log entries

263
00:08:44,240 --> 00:08:48,720
inside syslog ng

264
00:08:46,320 --> 00:08:51,120
and you can also rewrite them this is

265
00:08:48,720 --> 00:08:53,279
the template mechanism so you get let's

266
00:08:51,120 --> 00:08:55,360
say you get a message in

267
00:08:53,279 --> 00:08:57,360
from a database and you want to reformat

268
00:08:55,360 --> 00:08:59,760
that message for the output

269
00:08:57,360 --> 00:09:01,519
let's say to website or whatever then

270
00:08:59,760 --> 00:09:03,839
you can use the template mechanism to

271
00:09:01,519 --> 00:09:05,440
rewrite that message

272
00:09:03,839 --> 00:09:06,959
and then you write it to the destination

273
00:09:05,440 --> 00:09:08,640
and the destination can also be

274
00:09:06,959 --> 00:09:10,399
everything that you can think of it may

275
00:09:08,640 --> 00:09:13,040
be a database maybe a flat file

276
00:09:10,399 --> 00:09:14,800
maybe another lock relay another syslog

277
00:09:13,040 --> 00:09:17,680
instance whatsoever

278
00:09:14,800 --> 00:09:19,199
so you can create cascades of syslog ng

279
00:09:17,680 --> 00:09:21,680
instances

280
00:09:19,200 --> 00:09:22,720
like this and this is what we actually

281
00:09:21,680 --> 00:09:24,959
used when we

282
00:09:22,720 --> 00:09:26,640
implemented our cryptographic extension

283
00:09:24,959 --> 00:09:29,839
to syslog in key

284
00:09:26,640 --> 00:09:32,319
we used the template mechanism

285
00:09:29,839 --> 00:09:34,160
and implemented a template into the

286
00:09:32,320 --> 00:09:36,160
syslog ng

287
00:09:34,160 --> 00:09:37,760
so the good thing is that we can benefit

288
00:09:36,160 --> 00:09:38,399
from everything that was already there

289
00:09:37,760 --> 00:09:40,240
so

290
00:09:38,399 --> 00:09:42,160
we have all the source drivers we have

291
00:09:40,240 --> 00:09:44,720
all the filters that we use

292
00:09:42,160 --> 00:09:45,760
we just insert a template there in form

293
00:09:44,720 --> 00:09:49,040
of a plug-in

294
00:09:45,760 --> 00:09:51,760
which is essentially a c api

295
00:09:49,040 --> 00:09:53,920
within syslog ng we write that we add

296
00:09:51,760 --> 00:09:56,880
the two files as you see here so we have

297
00:09:53,920 --> 00:09:58,640
the key file and the mac file

298
00:09:56,880 --> 00:10:00,320
and then we write it to the destination

299
00:09:58,640 --> 00:10:03,920
so in our case

300
00:10:00,320 --> 00:10:06,000
we already had a syslog ng log host on

301
00:10:03,920 --> 00:10:09,279
our airborne computer

302
00:10:06,000 --> 00:10:10,959
so this was a very very small change

303
00:10:09,279 --> 00:10:13,200
because we only needed to replace the

304
00:10:10,959 --> 00:10:16,160
binary essentially so to add our

305
00:10:13,200 --> 00:10:18,000
plugin there and then we had to change

306
00:10:16,160 --> 00:10:20,560
the configuration in such a way that it

307
00:10:18,000 --> 00:10:22,640
would include our template

308
00:10:20,560 --> 00:10:24,479
so how does this typically look like i

309
00:10:22,640 --> 00:10:26,160
just created a very small example for

310
00:10:24,480 --> 00:10:26,560
you to to have a glance about what that

311
00:10:26,160 --> 00:10:28,800
means

312
00:10:26,560 --> 00:10:29,599
so these are some random lock messages

313
00:10:28,800 --> 00:10:32,479
so to say

314
00:10:29,600 --> 00:10:32,800
they come in at the source and then you

315
00:10:32,480 --> 00:10:35,279
see

316
00:10:32,800 --> 00:10:37,040
the encrypted messages like these what

317
00:10:35,279 --> 00:10:39,360
we added here in addition but that's

318
00:10:37,040 --> 00:10:41,519
mostly for computational convenience is

319
00:10:39,360 --> 00:10:43,519
a counter so you see the column there

320
00:10:41,519 --> 00:10:45,360
and the code before the column we

321
00:10:43,519 --> 00:10:47,519
actually have a counter so when you now

322
00:10:45,360 --> 00:10:50,160
create the plain text at the very first

323
00:10:47,519 --> 00:10:50,880
end it will look like this so the

324
00:10:50,160 --> 00:10:52,880
counter is

325
00:10:50,880 --> 00:10:53,920
is convenient for us because of course

326
00:10:52,880 --> 00:10:55,760
you know because

327
00:10:53,920 --> 00:10:57,680
for each log entry we have our

328
00:10:55,760 --> 00:10:59,279
individual key and if we want to trace

329
00:10:57,680 --> 00:11:02,079
the key file we also put that counter

330
00:10:59,279 --> 00:11:02,079
into the key file

331
00:11:02,720 --> 00:11:06,720
so how would that look like if you

332
00:11:04,320 --> 00:11:07,760
configure it well this is very simple so

333
00:11:06,720 --> 00:11:10,240
you see here

334
00:11:07,760 --> 00:11:11,680
a minimal syslog ng configuration file

335
00:11:10,240 --> 00:11:13,279
it's not very fancy doesn't use any

336
00:11:11,680 --> 00:11:15,279
filters

337
00:11:13,279 --> 00:11:17,519
but you see here there is a network

338
00:11:15,279 --> 00:11:19,360
source so standard syslog

339
00:11:17,519 --> 00:11:20,959
and here you see our template that's

340
00:11:19,360 --> 00:11:23,600
everything what we added

341
00:11:20,959 --> 00:11:26,000
and we we didn't need to write any any

342
00:11:23,600 --> 00:11:27,760
configuration file code of configuration

343
00:11:26,000 --> 00:11:30,079
file parsing code everything was already

344
00:11:27,760 --> 00:11:31,279
there so we just used the interface of

345
00:11:30,079 --> 00:11:33,199
syslog ng

346
00:11:31,279 --> 00:11:35,120
so what you see here is the s-lock which

347
00:11:33,200 --> 00:11:36,000
is the secure logging template that we

348
00:11:35,120 --> 00:11:39,200
added

349
00:11:36,000 --> 00:11:41,519
we have two oh

350
00:11:39,200 --> 00:11:42,240
you don't see the mouse okay so you you

351
00:11:41,519 --> 00:11:44,800
look at the

352
00:11:42,240 --> 00:11:46,399
the template line there then you have

353
00:11:44,800 --> 00:11:48,640
the s lock minus k

354
00:11:46,399 --> 00:11:49,920
which is the location of your key file

355
00:11:48,640 --> 00:11:52,800
so where you store it

356
00:11:49,920 --> 00:11:54,639
the minus m is location for the mac file

357
00:11:52,800 --> 00:11:56,079
and that dollar rule message gives you

358
00:11:54,639 --> 00:11:57,680
actually access to the raw

359
00:11:56,079 --> 00:11:59,920
log message that was received at the

360
00:11:57,680 --> 00:12:01,680
source in order to get that

361
00:11:59,920 --> 00:12:03,360
macro fill you have to add this

362
00:12:01,680 --> 00:12:06,000
particular flag which is called

363
00:12:03,360 --> 00:12:07,279
flex store raw message because syslog g

364
00:12:06,000 --> 00:12:09,040
by default

365
00:12:07,279 --> 00:12:10,880
passes everything that it receives at

366
00:12:09,040 --> 00:12:12,079
the source into a sisler conformant

367
00:12:10,880 --> 00:12:14,240
message

368
00:12:12,079 --> 00:12:16,239
and for encryption we don't want that so

369
00:12:14,240 --> 00:12:18,399
we want the raw message to be also

370
00:12:16,240 --> 00:12:19,279
encrypted so that's why we added here as

371
00:12:18,399 --> 00:12:21,040
a war message

372
00:12:19,279 --> 00:12:22,720
and that's it and then we have a lock

373
00:12:21,040 --> 00:12:25,439
entry you see it here

374
00:12:22,720 --> 00:12:26,160
the source is just the network and the

375
00:12:25,440 --> 00:12:28,880
destination

376
00:12:26,160 --> 00:12:30,319
is our local lock file so this is

377
00:12:28,880 --> 00:12:33,279
everything what you need to do in order

378
00:12:30,320 --> 00:12:34,959
to work with our code

379
00:12:33,279 --> 00:12:36,800
so how did we implement it just to give

380
00:12:34,959 --> 00:12:38,638
you a small example about the

381
00:12:36,800 --> 00:12:40,479
amount of effort that we put into it so

382
00:12:38,639 --> 00:12:41,839
we i don't know if it's

383
00:12:40,480 --> 00:12:43,279
it may be hard to read so you can read

384
00:12:41,839 --> 00:12:44,079
it on the paper which is on the frosting

385
00:12:43,279 --> 00:12:46,240
website

386
00:12:44,079 --> 00:12:47,519
so this is the source tree of syslog g

387
00:12:46,240 --> 00:12:49,440
or part of it

388
00:12:47,519 --> 00:12:52,720
and this is where we edit our source

389
00:12:49,440 --> 00:12:54,399
files so in addition to the source

390
00:12:52,720 --> 00:12:57,839
existing so we had only six

391
00:12:54,399 --> 00:13:00,079
new source files to add why because most

392
00:12:57,839 --> 00:13:02,560
of the crypto code that we use

393
00:13:00,079 --> 00:13:04,399
relies on open ssl and open ssl is

394
00:13:02,560 --> 00:13:06,880
already present in syslog ng because

395
00:13:04,399 --> 00:13:09,600
it's also used for other plugins

396
00:13:06,880 --> 00:13:11,760
so we essentially all the crypto

397
00:13:09,600 --> 00:13:14,639
functions that we use are in the lib

398
00:13:11,760 --> 00:13:16,319
directory and the template code is in

399
00:13:14,639 --> 00:13:20,320
the modules directory

400
00:13:16,320 --> 00:13:22,800
so that's where we would look at

401
00:13:20,320 --> 00:13:23,440
we had no new dependencies so that means

402
00:13:22,800 --> 00:13:25,599
other than

403
00:13:23,440 --> 00:13:27,279
openssl we don't need any new

404
00:13:25,600 --> 00:13:29,600
dependencies so if you want to compile

405
00:13:27,279 --> 00:13:31,760
syslog g with our code then it's very

406
00:13:29,600 --> 00:13:34,000
easy to do

407
00:13:31,760 --> 00:13:35,519
this is already said and in addition to

408
00:13:34,000 --> 00:13:36,880
that we did a lot of performance tests

409
00:13:35,519 --> 00:13:39,040
because we didn't want to impair the

410
00:13:36,880 --> 00:13:40,639
performance of our airborne computer

411
00:13:39,040 --> 00:13:43,040
where we are resource constrained of

412
00:13:40,639 --> 00:13:45,680
course in terms of power

413
00:13:43,040 --> 00:13:47,599
and we relied on asni or we already

414
00:13:45,680 --> 00:13:49,839
talked about this uh

415
00:13:47,600 --> 00:13:50,959
in the intel cpu that we use we use a

416
00:13:49,839 --> 00:13:53,680
skylake cpu

417
00:13:50,959 --> 00:13:54,959
in our airborne server so there was no

418
00:13:53,680 --> 00:13:56,638
performance impact

419
00:13:54,959 --> 00:13:58,638
for for the lock entry the only impact

420
00:13:56,639 --> 00:14:00,720
that we had was the file io for the two

421
00:13:58,639 --> 00:14:02,480
small files

422
00:14:00,720 --> 00:14:04,399
so just to give you some numbers so on

423
00:14:02,480 --> 00:14:06,079
on a development machine

424
00:14:04,399 --> 00:14:08,000
with these parameters we were able to

425
00:14:06,079 --> 00:14:08,638
digest about 9000 lock entries per

426
00:14:08,000 --> 00:14:10,399
second

427
00:14:08,639 --> 00:14:12,320
which is much more than we normally have

428
00:14:10,399 --> 00:14:15,760
in normal operation

429
00:14:12,320 --> 00:14:19,199
typical lock entry per on our log host

430
00:14:15,760 --> 00:14:20,720
is about 200 000 log entries in 24 hours

431
00:14:19,199 --> 00:14:22,479
so that's what we have on a normal

432
00:14:20,720 --> 00:14:25,839
airplane

433
00:14:22,480 --> 00:14:27,279
if you say if you extrapolate this to

434
00:14:25,839 --> 00:14:30,399
one year you will have about

435
00:14:27,279 --> 00:14:32,240
73 million entries per year

436
00:14:30,399 --> 00:14:33,920
and still we will can can do the key

437
00:14:32,240 --> 00:14:37,440
derivation in less than a second so

438
00:14:33,920 --> 00:14:37,439
that's very very very efficient

439
00:14:37,839 --> 00:14:41,040
of course we also had to face some

440
00:14:39,680 --> 00:14:43,040
challenges

441
00:14:41,040 --> 00:14:44,639
the first is the lock system behavior

442
00:14:43,040 --> 00:14:46,319
under load you all know this so if you

443
00:14:44,639 --> 00:14:49,600
use a lock system that uses

444
00:14:46,320 --> 00:14:51,440
uh network sockets then you have the

445
00:14:49,600 --> 00:14:53,839
reliability problem so you

446
00:14:51,440 --> 00:14:55,680
if you have too many messages coming and

447
00:14:53,839 --> 00:14:56,720
you will either lose messages directly

448
00:14:55,680 --> 00:14:58,560
if you use udp

449
00:14:56,720 --> 00:15:00,800
but even if you use tcp you can use

450
00:14:58,560 --> 00:15:02,160
loose messages if you don't want to lose

451
00:15:00,800 --> 00:15:04,880
those you can

452
00:15:02,160 --> 00:15:07,680
resort to things like the the rail

453
00:15:04,880 --> 00:15:10,959
protocol by the rss lock guys

454
00:15:07,680 --> 00:15:12,079
which adds a layer 7 reliability on it

455
00:15:10,959 --> 00:15:14,079
but even then you

456
00:15:12,079 --> 00:15:15,920
you you have the challenge to face that

457
00:15:14,079 --> 00:15:18,959
you might lose messages

458
00:15:15,920 --> 00:15:21,040
for us it it showed in the test that yes

459
00:15:18,959 --> 00:15:22,719
but this is normal behavior even if if

460
00:15:21,040 --> 00:15:23,920
our module is not included so if you

461
00:15:22,720 --> 00:15:26,880
have plain sicilian g

462
00:15:23,920 --> 00:15:28,880
will have the same problems so it's not

463
00:15:26,880 --> 00:15:31,120
worse than we were before

464
00:15:28,880 --> 00:15:32,240
a major challenge was the system g api

465
00:15:31,120 --> 00:15:34,480
which is not very

466
00:15:32,240 --> 00:15:36,079
very well documented so we really had to

467
00:15:34,480 --> 00:15:37,839
read the source code

468
00:15:36,079 --> 00:15:39,519
debug through the source code in order

469
00:15:37,839 --> 00:15:41,199
to know actually how the plugin

470
00:15:39,519 --> 00:15:44,560
interface is supposed to work

471
00:15:41,199 --> 00:15:45,920
that was a bit tedious so no developer

472
00:15:44,560 --> 00:15:47,920
skype was available where you can just

473
00:15:45,920 --> 00:15:49,839
say okay this is the api if you want to

474
00:15:47,920 --> 00:15:52,079
extend it then you do this these steps

475
00:15:49,839 --> 00:15:54,240
this this was not there

476
00:15:52,079 --> 00:15:55,680
the build system also was quite complex

477
00:15:54,240 --> 00:15:57,759
so it was not so easy

478
00:15:55,680 --> 00:15:59,519
because system g is a very comprehensive

479
00:15:57,759 --> 00:16:02,399
system with a lot of plug-ins

480
00:15:59,519 --> 00:16:03,440
and you need to strip it down in such a

481
00:16:02,399 --> 00:16:06,639
way that you can easily

482
00:16:03,440 --> 00:16:07,360
build your own code and that was also

483
00:16:06,639 --> 00:16:09,120
not so very

484
00:16:07,360 --> 00:16:11,120
very easy to do because also the build

485
00:16:09,120 --> 00:16:12,399
system was not well documented it relied

486
00:16:11,120 --> 00:16:14,079
on the new tools of course

487
00:16:12,399 --> 00:16:15,680
and you know how those work but if you

488
00:16:14,079 --> 00:16:19,120
just want to for example compile your

489
00:16:15,680 --> 00:16:21,199
own plugin you had to do some handwork

490
00:16:19,120 --> 00:16:22,320
and the packaging of course had to be

491
00:16:21,199 --> 00:16:24,000
done manually the

492
00:16:22,320 --> 00:16:25,759
the syslog colleagues they supply a spec

493
00:16:24,000 --> 00:16:26,639
file for the rpm based linux

494
00:16:25,759 --> 00:16:27,839
distribution

495
00:16:26,639 --> 00:16:30,000
which is what we're using for the

496
00:16:27,839 --> 00:16:33,920
airplane but we had to tweak with this

497
00:16:30,000 --> 00:16:35,440
as well so that was hand work motors

498
00:16:33,920 --> 00:16:37,120
very important thing to notice also that

499
00:16:35,440 --> 00:16:38,480
we will have no lock rotation because

500
00:16:37,120 --> 00:16:42,079
you can think of

501
00:16:38,480 --> 00:16:43,600
having your cryptographic chain

502
00:16:42,079 --> 00:16:45,758
where you change your log entries

503
00:16:43,600 --> 00:16:47,839
together and you have the overall

504
00:16:45,759 --> 00:16:49,600
integrity tag on the whole log file so

505
00:16:47,839 --> 00:16:52,959
if you now rotate things

506
00:16:49,600 --> 00:16:53,839
then you will delete content from your

507
00:16:52,959 --> 00:16:55,758
lock archive

508
00:16:53,839 --> 00:16:57,600
you cannot verify the lock any longer

509
00:16:55,759 --> 00:16:59,279
yeah because it you delete something

510
00:16:57,600 --> 00:17:01,680
from the crypto hierarchy

511
00:16:59,279 --> 00:17:03,519
so you have to be careful about lock

512
00:17:01,680 --> 00:17:04,399
rotation not to do lock rotation anymore

513
00:17:03,519 --> 00:17:06,480
so if you

514
00:17:04,400 --> 00:17:08,319
use syslog ng with any lock rotate you

515
00:17:06,480 --> 00:17:09,919
have to get rid of lock rotate

516
00:17:08,319 --> 00:17:12,079
what we do on the airplane for example

517
00:17:09,919 --> 00:17:14,160
as we have limited storage anyway

518
00:17:12,079 --> 00:17:16,720
what we have to do is to offload the

519
00:17:14,160 --> 00:17:19,120
locks down to our analysis tool

520
00:17:16,720 --> 00:17:20,160
and then do the verification there and

521
00:17:19,119 --> 00:17:23,359
then continue

522
00:17:20,160 --> 00:17:23,360
logging with the crypto lock

523
00:17:24,000 --> 00:17:27,760
an example scenario how it would look

524
00:17:25,679 --> 00:17:30,080
like in our operations so we have an

525
00:17:27,760 --> 00:17:32,720
airplane which has an onboard block host

526
00:17:30,080 --> 00:17:34,960
like in this picture that's actually the

527
00:17:32,720 --> 00:17:37,440
rear box that flies on a320 so if you

528
00:17:34,960 --> 00:17:39,919
happen to fly an a320 from auto brussels

529
00:17:37,440 --> 00:17:41,440
you will probably have that box on board

530
00:17:39,919 --> 00:17:43,360
and on that box we do the keyword

531
00:17:41,440 --> 00:17:45,919
derivation and we do the

532
00:17:43,360 --> 00:17:46,639
the lock record creation so that box is

533
00:17:45,919 --> 00:17:50,080
actually running

534
00:17:46,640 --> 00:17:51,520
our crypto lock extension of syslog ng

535
00:17:50,080 --> 00:17:53,678
and when the airplane lands at the

536
00:17:51,520 --> 00:17:56,000
airport there are different facilities

537
00:17:53,679 --> 00:17:58,240
for transmitting data from the airplane

538
00:17:56,000 --> 00:18:00,720
to the infrastructure

539
00:17:58,240 --> 00:18:02,240
so in this example uh it may be an

540
00:18:00,720 --> 00:18:04,000
access point so we have a wireless

541
00:18:02,240 --> 00:18:05,919
connection between the airplane system

542
00:18:04,000 --> 00:18:07,760
and the other one infrastructure and

543
00:18:05,919 --> 00:18:08,720
from there we will transfer the locks

544
00:18:07,760 --> 00:18:10,640
into our

545
00:18:08,720 --> 00:18:12,400
security information and event

546
00:18:10,640 --> 00:18:14,000
management environment which in our case

547
00:18:12,400 --> 00:18:16,080
is a splunk and run where we then

548
00:18:14,000 --> 00:18:18,400
can integrate the verification in and

549
00:18:16,080 --> 00:18:21,039
then we can do the normal log analysis

550
00:18:18,400 --> 00:18:21,039
as we've used

551
00:18:21,520 --> 00:18:28,559
and that brings me to the summary so

552
00:18:25,280 --> 00:18:31,678
we achieved

553
00:18:28,559 --> 00:18:33,280
a system that is industrial ready

554
00:18:31,679 --> 00:18:34,640
because we have it on board the airplane

555
00:18:33,280 --> 00:18:35,760
it has passed a lot of tests we have

556
00:18:34,640 --> 00:18:37,760
colleagues who did

557
00:18:35,760 --> 00:18:38,799
some very interesting and deep tests on

558
00:18:37,760 --> 00:18:40,840
the system

559
00:18:38,799 --> 00:18:42,639
before we actually put it into

560
00:18:40,840 --> 00:18:44,720
production we have a

561
00:18:42,640 --> 00:18:46,400
minor change to syslog g so everybody

562
00:18:44,720 --> 00:18:49,440
who who is actually already

563
00:18:46,400 --> 00:18:50,320
using syslog ng will enjoy that it does

564
00:18:49,440 --> 00:18:52,320
not

565
00:18:50,320 --> 00:18:54,879
bring a great effort into to benefit

566
00:18:52,320 --> 00:18:57,360
from forward integrity and log files

567
00:18:54,880 --> 00:18:58,799
we can do the verification offline so

568
00:18:57,360 --> 00:19:00,479
even if we have a small resource

569
00:18:58,799 --> 00:19:01,918
constrained airborne system

570
00:19:00,480 --> 00:19:04,400
it's not needed to to do the

571
00:19:01,919 --> 00:19:06,720
verification on board so this is

572
00:19:04,400 --> 00:19:07,919
separate so we offline the logs offload

573
00:19:06,720 --> 00:19:09,520
the logs and then

574
00:19:07,919 --> 00:19:10,960
on in the ground infrastructure we can

575
00:19:09,520 --> 00:19:12,799
use more computing power to do that

576
00:19:10,960 --> 00:19:14,720
verification

577
00:19:12,799 --> 00:19:16,559
and in the future what we intend to do

578
00:19:14,720 --> 00:19:18,320
and we just started to work on that was

579
00:19:16,559 --> 00:19:19,280
also an exciting pro in an exciting

580
00:19:18,320 --> 00:19:23,120
project is to

581
00:19:19,280 --> 00:19:25,440
extend that uh into a system which can

582
00:19:23,120 --> 00:19:28,479
also recover from crashes

583
00:19:25,440 --> 00:19:30,880
so think about your lock hose crashing

584
00:19:28,480 --> 00:19:32,880
and because of buffering you might lose

585
00:19:30,880 --> 00:19:34,240
lock entries if you now have a cryptolog

586
00:19:32,880 --> 00:19:36,160
then of course the verification will

587
00:19:34,240 --> 00:19:38,400
complain because you you might have

588
00:19:36,160 --> 00:19:39,760
lost some data which is okay because you

589
00:19:38,400 --> 00:19:41,520
have lost them so your lock is not

590
00:19:39,760 --> 00:19:44,080
complete

591
00:19:41,520 --> 00:19:45,440
what we will now do is extend what we've

592
00:19:44,080 --> 00:19:46,480
already done for the tamper evident

593
00:19:45,440 --> 00:19:48,799
logging here

594
00:19:46,480 --> 00:19:50,640
we will do a crash recovery with a

595
00:19:48,799 --> 00:19:52,960
particular efficient algorithm that

596
00:19:50,640 --> 00:19:54,080
is storing the data in a redundant

597
00:19:52,960 --> 00:19:57,039
manner

598
00:19:54,080 --> 00:19:57,678
approximately about 11 increase in

599
00:19:57,039 --> 00:20:00,160
storage

600
00:19:57,679 --> 00:20:01,919
will give us crash recovery so that

601
00:20:00,160 --> 00:20:03,600
means that if somebody crests the lock

602
00:20:01,919 --> 00:20:05,520
even deliberately as an attacker in

603
00:20:03,600 --> 00:20:06,080
order to mess up logs we can recover

604
00:20:05,520 --> 00:20:07,679
those

605
00:20:06,080 --> 00:20:09,678
and still benefit from cryptographic

606
00:20:07,679 --> 00:20:21,520
integrity

607
00:20:09,679 --> 00:20:23,440
and that brings me to the end thank you

608
00:20:21,520 --> 00:20:26,000
so these are the languages i accept

609
00:20:23,440 --> 00:20:26,000
questions in

610
00:20:31,840 --> 00:20:35,840
how do you decrypt

611
00:20:43,840 --> 00:20:47,360
uh do you have a command line tool for

612
00:20:45,600 --> 00:20:48,719
this yeah so what we what we call

613
00:20:47,360 --> 00:20:50,158
what you call decryption we actually

614
00:20:48,720 --> 00:20:51,919
call verification because it's not

615
00:20:50,159 --> 00:20:53,679
simply decrypting it's also checking all

616
00:20:51,919 --> 00:20:55,760
the hashes

617
00:20:53,679 --> 00:20:57,840
and for that we provide you with a

618
00:20:55,760 --> 00:20:58,480
verifier tool which is a command line

619
00:20:57,840 --> 00:21:00,158
utility

620
00:20:58,480 --> 00:21:02,240
so that's part of our package so if you

621
00:21:00,159 --> 00:21:04,640
build it with syslog ng with our patch

622
00:21:02,240 --> 00:21:05,919
you will get that command line utility

623
00:21:04,640 --> 00:21:07,280
and you can use that command line

624
00:21:05,919 --> 00:21:08,799
utility in in your

625
00:21:07,280 --> 00:21:11,120
scripting environment wherever you want

626
00:21:08,799 --> 00:21:13,600
to verify the logs in our case it's of

627
00:21:11,120 --> 00:21:15,280
course always on ground in some

628
00:21:13,600 --> 00:21:17,600
analysis environment it's not about the

629
00:21:15,280 --> 00:21:19,120
airplane so it's detached

630
00:21:17,600 --> 00:21:20,719
so you have one on one hand you have the

631
00:21:19,120 --> 00:21:21,678
lock host on one and on

632
00:21:20,720 --> 00:21:25,200
on the other hand you have the

633
00:21:21,679 --> 00:21:27,679
verification tool the decryption tool

634
00:21:25,200 --> 00:21:29,760
just uh which linux distribution you're

635
00:21:27,679 --> 00:21:32,720
using on the locals

636
00:21:29,760 --> 00:21:33,760
so in our cases red hat enterprise linux

637
00:21:32,720 --> 00:21:35,440
7

638
00:21:33,760 --> 00:21:36,640
with our own custom built environment

639
00:21:35,440 --> 00:21:38,000
for the airborne environment of course

640
00:21:36,640 --> 00:21:39,520
you can think about is

641
00:21:38,000 --> 00:21:41,760
it's a resource constraint system where

642
00:21:39,520 --> 00:21:44,320
we need to strip down the distribution

643
00:21:41,760 --> 00:21:46,320
um i this is my development machine so i

644
00:21:44,320 --> 00:21:49,039
build it on the fedora

645
00:21:46,320 --> 00:21:51,280
um but um yeah it builds on every limit

646
00:21:49,039 --> 00:21:52,320
i also use it on a build it on open bsd

647
00:21:51,280 --> 00:21:53,918
successfully

648
00:21:52,320 --> 00:21:55,439
although you have to patch it there but

649
00:21:53,919 --> 00:21:58,480
that's not the

650
00:21:55,440 --> 00:22:00,080
because of our code that's because of

651
00:21:58,480 --> 00:22:02,960
syslog and g needs patches and for open

652
00:22:00,080 --> 00:22:05,439
bsd so it builds on a lot of open

653
00:22:02,960 --> 00:22:05,440
systems

654
00:22:08,559 --> 00:22:13,120
thanks for talking more question on so

655
00:22:11,200 --> 00:22:16,400
you said one of the key properties that

656
00:22:13,120 --> 00:22:19,678
allows this uh mechanism to work is to

657
00:22:16,400 --> 00:22:22,000
delete the old keys so

658
00:22:19,679 --> 00:22:24,000
but i wonder do you also do you just

659
00:22:22,000 --> 00:22:26,080
store them in memory and realize that

660
00:22:24,000 --> 00:22:27,440
it's just not going away or do you write

661
00:22:26,080 --> 00:22:29,439
them into files or

662
00:22:27,440 --> 00:22:30,480
yeah for for reliability reasons we

663
00:22:29,440 --> 00:22:33,039
write them to farms

664
00:22:30,480 --> 00:22:34,559
so i can probably check switch back to

665
00:22:33,039 --> 00:22:38,720
the picture here

666
00:22:34,559 --> 00:22:41,200
just to give you an idea where is it

667
00:22:38,720 --> 00:22:43,440
so here here you see the there are two

668
00:22:41,200 --> 00:22:45,200
small files that we write one is the key

669
00:22:43,440 --> 00:22:47,679
and the other one is the mac

670
00:22:45,200 --> 00:22:48,320
so the problem is that if the system for

671
00:22:47,679 --> 00:22:50,320
some

672
00:22:48,320 --> 00:22:51,360
somehow has a power interrupter so you

673
00:22:50,320 --> 00:22:53,439
will lose

674
00:22:51,360 --> 00:22:54,959
your key and then you cannot continue

675
00:22:53,440 --> 00:22:57,360
anymore in our case the

676
00:22:54,960 --> 00:22:59,360
we will resort to plain text logging in

677
00:22:57,360 --> 00:23:01,678
order not to lose any lock information

678
00:22:59,360 --> 00:23:03,840
but do you then write for e like each

679
00:23:01,679 --> 00:23:04,480
step like each log line you overwrite

680
00:23:03,840 --> 00:23:06,720
basically

681
00:23:04,480 --> 00:23:07,600
yes yes yeah and this is this is of

682
00:23:06,720 --> 00:23:09,200
course the main

683
00:23:07,600 --> 00:23:11,360
performance impact that we create

684
00:23:09,200 --> 00:23:14,880
reading and writing of small files

685
00:23:11,360 --> 00:23:18,399
it's a 56 byte file okay

686
00:23:14,880 --> 00:23:20,880
and another question um the template

687
00:23:18,400 --> 00:23:23,039
that you've shown it looks a bit like it

688
00:23:20,880 --> 00:23:25,120
it looked like a string with like

689
00:23:23,039 --> 00:23:28,240
bashing lining and then line ending so

690
00:23:25,120 --> 00:23:30,479
is it actually uh do you actually call a

691
00:23:28,240 --> 00:23:34,159
subprocess all the time or

692
00:23:30,480 --> 00:23:37,840
uh yeah so it look uh template and then

693
00:23:34,159 --> 00:23:39,520
braces and parentheses yeah so it's no

694
00:23:37,840 --> 00:23:40,320
this is not a sub process it's actually

695
00:23:39,520 --> 00:23:43,039
just a

696
00:23:40,320 --> 00:23:44,799
function call so in syslog ng if you if

697
00:23:43,039 --> 00:23:46,720
you program a template

698
00:23:44,799 --> 00:23:47,918
uh because it's not in c plus plus it's

699
00:23:46,720 --> 00:23:50,320
plane c

700
00:23:47,919 --> 00:23:51,039
so there is a magic macro which

701
00:23:50,320 --> 00:23:53,039
essentially

702
00:23:51,039 --> 00:23:54,559
extends this into a function call which

703
00:23:53,039 --> 00:23:56,080
is particular to the template and then

704
00:23:54,559 --> 00:23:57,918
calls your template

705
00:23:56,080 --> 00:23:59,439
whether it finds an entry in the

706
00:23:57,919 --> 00:24:00,000
configuration file your function is

707
00:23:59,440 --> 00:24:01,840
called

708
00:24:00,000 --> 00:24:03,760
okay that's very efficient this is in

709
00:24:01,840 --> 00:24:06,000
contrast to arsyslog they they actually

710
00:24:03,760 --> 00:24:08,879
do a fork accent

711
00:24:06,000 --> 00:24:08,880
yeah okay thanks

712
00:24:09,600 --> 00:24:13,918
you've got maybe one minute for last

713
00:24:11,600 --> 00:24:15,520
question okay

714
00:24:13,919 --> 00:24:16,880
it should be quick um during the

715
00:24:15,520 --> 00:24:18,879
presentation you mentioned that it

716
00:24:16,880 --> 00:24:21,200
doesn't support a local rotation

717
00:24:18,880 --> 00:24:22,880
is there any particular reason why or is

718
00:24:21,200 --> 00:24:24,720
there any feature that could be similar

719
00:24:22,880 --> 00:24:26,720
to that log rotation

720
00:24:24,720 --> 00:24:28,400
yes a log rotation will not work anymore

721
00:24:26,720 --> 00:24:30,640
because each lock entry is

722
00:24:28,400 --> 00:24:32,159
cryptographically linked to the next one

723
00:24:30,640 --> 00:24:34,480
so if you rotate the locks you actually

724
00:24:32,159 --> 00:24:35,600
delete them and if you now want to do

725
00:24:34,480 --> 00:24:37,120
the verification

726
00:24:35,600 --> 00:24:38,799
then you have to do the verification

727
00:24:37,120 --> 00:24:41,039
from the starting point so you start at

728
00:24:38,799 --> 00:24:43,120
k naught with you with the first key

729
00:24:41,039 --> 00:24:44,640
you you decrypt the first entry you

730
00:24:43,120 --> 00:24:45,918
evolve the key to the second one and so

731
00:24:44,640 --> 00:24:47,840
on if you now

732
00:24:45,919 --> 00:24:49,520
delete all the entries in between you

733
00:24:47,840 --> 00:24:51,520
cannot no longer verify the logs because

734
00:24:49,520 --> 00:24:53,600
there are no hashes to verify

735
00:24:51,520 --> 00:24:55,679
so you you can no longer use log

736
00:24:53,600 --> 00:24:57,918
rotation that's that's basically part of

737
00:24:55,679 --> 00:25:00,080
the principle if you need log rotation

738
00:24:57,919 --> 00:25:01,520
if you need to care about space as we do

739
00:25:00,080 --> 00:25:02,320
on the airplane for example you can

740
00:25:01,520 --> 00:25:03,840
imagine that

741
00:25:02,320 --> 00:25:06,240
board the airplane we don't have much

742
00:25:03,840 --> 00:25:07,279
storage space you need to offload the

743
00:25:06,240 --> 00:25:09,360
locks

744
00:25:07,279 --> 00:25:11,520
so the thing is that you you can

745
00:25:09,360 --> 00:25:13,918
generate a signal when let's say 80

746
00:25:11,520 --> 00:25:16,000
of your storage space is exhausted and

747
00:25:13,919 --> 00:25:18,400
then you will generally offload the logs

748
00:25:16,000 --> 00:25:19,679
and then verify them offline in another

749
00:25:18,400 --> 00:25:20,240
environment where you have more storage

750
00:25:19,679 --> 00:25:23,039
space

751
00:25:20,240 --> 00:25:24,720
so pull them off the lockouts thank you

752
00:25:23,039 --> 00:25:29,840
we are out of the time so thank you for

753
00:25:24,720 --> 00:25:29,840
our talk

754
00:25:34,080 --> 00:25:36,158
you

