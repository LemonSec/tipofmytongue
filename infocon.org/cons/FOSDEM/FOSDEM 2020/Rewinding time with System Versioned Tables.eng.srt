1
00:00:05,759 --> 00:00:09,840
i don't

2
00:00:06,319 --> 00:00:11,759
want to see that yeah

3
00:00:09,840 --> 00:00:14,160
so this is the talk rewinding the time

4
00:00:11,759 --> 00:00:16,880
with system version tables

5
00:00:14,160 --> 00:00:18,560
so quickly about me my name is on the

6
00:00:16,880 --> 00:00:20,720
slide i work in my new corporation as a

7
00:00:18,560 --> 00:00:23,439
picture of engineering and i was

8
00:00:20,720 --> 00:00:24,479
called my school developer since 1998

9
00:00:23,439 --> 00:00:28,840
till

10
00:00:24,480 --> 00:00:30,240
2009 and since 2010 i'm working on

11
00:00:28,840 --> 00:00:31,599
marietv

12
00:00:30,240 --> 00:00:33,680
what this talk is about it's about a

13
00:00:31,599 --> 00:00:35,360
feature called system version tables

14
00:00:33,680 --> 00:00:37,280
and before introducing it let me

15
00:00:35,360 --> 00:00:40,399
describe three

16
00:00:37,280 --> 00:00:42,320
rather different problems so one

17
00:00:40,399 --> 00:00:43,680
is the task of undoing erroneous

18
00:00:42,320 --> 00:00:45,360
statements you know we made a type and

19
00:00:43,680 --> 00:00:47,360
the very close new location deleted the

20
00:00:45,360 --> 00:00:49,039
whole table or updated everything to one

21
00:00:47,360 --> 00:00:50,559
stuff like that then you want your data

22
00:00:49,039 --> 00:00:52,480
back

23
00:00:50,559 --> 00:00:54,399
the other totally different problem is

24
00:00:52,480 --> 00:00:54,610
analytics on historical data you want to

25
00:00:54,399 --> 00:00:55,760
see

26
00:00:54,610 --> 00:00:57,920
[Music]

27
00:00:55,760 --> 00:00:59,280
your webshop or online game you want to

28
00:00:57,920 --> 00:01:01,440
compare your user base

29
00:00:59,280 --> 00:01:02,800
from the last year to the user base from

30
00:01:01,440 --> 00:01:05,360
this year to the user base from

31
00:01:02,800 --> 00:01:06,399
three years ago see how demographic has

32
00:01:05,360 --> 00:01:08,640
changed

33
00:01:06,400 --> 00:01:09,840
whether the user spent more time and

34
00:01:08,640 --> 00:01:12,640
derived probably some

35
00:01:09,840 --> 00:01:13,920
useful hints how to improve your

36
00:01:12,640 --> 00:01:15,840
business

37
00:01:13,920 --> 00:01:18,159
and the third problem is forensic data

38
00:01:15,840 --> 00:01:19,600
analysis it's when you suddenly realize

39
00:01:18,159 --> 00:01:21,759
that

40
00:01:19,600 --> 00:01:22,798
your site was hacked and it was half a

41
00:01:21,759 --> 00:01:25,200
year ago

42
00:01:22,799 --> 00:01:26,640
and you didn't notice that and you

43
00:01:25,200 --> 00:01:28,799
urgently need to know what the data

44
00:01:26,640 --> 00:01:31,840
intruder has seen what

45
00:01:28,799 --> 00:01:32,240
user data has leaked and what do you

46
00:01:31,840 --> 00:01:34,640
need

47
00:01:32,240 --> 00:01:36,560
what users need to be informed and what

48
00:01:34,640 --> 00:01:38,320
to do about that

49
00:01:36,560 --> 00:01:40,479
so what all these problems have in

50
00:01:38,320 --> 00:01:44,479
common is you need to access

51
00:01:40,479 --> 00:01:46,158
your data as it were some time ago

52
00:01:44,479 --> 00:01:48,079
some kind of a small time machine to

53
00:01:46,159 --> 00:01:50,320
look back and see at your data

54
00:01:48,079 --> 00:01:52,079
however this is exactly what system

55
00:01:50,320 --> 00:01:55,600
versioning is

56
00:01:52,079 --> 00:01:57,839
is so system system dash version tables

57
00:01:55,600 --> 00:02:00,000
it's a standard name for the feature

58
00:01:57,840 --> 00:02:01,840
it's it was introduced in sql 20

59
00:02:00,000 --> 00:02:05,280
standard 2011

60
00:02:01,840 --> 00:02:07,119
implemented in many adb 10.3

61
00:02:05,280 --> 00:02:08,878
system version tables is a new kind of

62
00:02:07,119 --> 00:02:10,399
table so it's there are like normal

63
00:02:08,878 --> 00:02:11,760
tables there are temporary tables and

64
00:02:10,399 --> 00:02:13,520
there are system version tables

65
00:02:11,760 --> 00:02:15,920
which are not temporary they are

66
00:02:13,520 --> 00:02:17,920
persistent more like normal tables

67
00:02:15,920 --> 00:02:20,399
and there's new syntax for creating

68
00:02:17,920 --> 00:02:22,238
those system version tables and

69
00:02:20,400 --> 00:02:24,720
the new syntax for covering this

70
00:02:22,239 --> 00:02:26,720
temporal data

71
00:02:24,720 --> 00:02:28,239
so first look let's see what the

72
00:02:26,720 --> 00:02:29,680
standard has to offer

73
00:02:28,239 --> 00:02:31,120
this is not a system version table

74
00:02:29,680 --> 00:02:31,760
there's a perfectly normal table which

75
00:02:31,120 --> 00:02:35,200
has

76
00:02:31,760 --> 00:02:37,359
some primary key and some data

77
00:02:35,200 --> 00:02:38,720
and we let's say we want to make a

78
00:02:37,360 --> 00:02:40,879
system version

79
00:02:38,720 --> 00:02:42,239
so so that's the standard says we need

80
00:02:40,879 --> 00:02:43,840
to add two columns

81
00:02:42,239 --> 00:02:45,440
two they're generated columns one is

82
00:02:43,840 --> 00:02:47,760
generated as row start and

83
00:02:45,440 --> 00:02:49,200
second is generated as our end and they

84
00:02:47,760 --> 00:02:51,280
have both the timestamp time

85
00:02:49,200 --> 00:02:53,760
type i use the maximum possible

86
00:02:51,280 --> 00:02:56,000
precision timestamp66 microseconds

87
00:02:53,760 --> 00:02:57,920
and the names could be arbitrary then

88
00:02:56,000 --> 00:03:00,159
this standard introduced a new

89
00:02:57,920 --> 00:03:01,200
object inside the table so the primary

90
00:03:00,159 --> 00:03:03,760
keys the

91
00:03:01,200 --> 00:03:05,440
check constraints foreign keys columns

92
00:03:03,760 --> 00:03:07,280
and since 2011

93
00:03:05,440 --> 00:03:08,959
there's there are periods which is also

94
00:03:07,280 --> 00:03:11,280
something inside the table

95
00:03:08,959 --> 00:03:12,879
and it has two columns and so for system

96
00:03:11,280 --> 00:03:13,840
version table tend to define period for

97
00:03:12,879 --> 00:03:16,799
system time

98
00:03:13,840 --> 00:03:16,800
with those two columns

99
00:03:17,200 --> 00:03:21,440
and then you need to write which is a

100
00:03:19,680 --> 00:03:24,560
version in and after that you have a

101
00:03:21,440 --> 00:03:26,079
system version tables congratulation but

102
00:03:24,560 --> 00:03:27,599
why would you want to know that what can

103
00:03:26,080 --> 00:03:30,799
you do with such a table

104
00:03:27,599 --> 00:03:32,560
so the new thing is

105
00:03:30,799 --> 00:03:33,920
instead of just using table name in the

106
00:03:32,560 --> 00:03:36,400
select query

107
00:03:33,920 --> 00:03:37,440
you can specify its table name for

108
00:03:36,400 --> 00:03:40,400
system time as

109
00:03:37,440 --> 00:03:42,000
of some arbitrary timestamp and this is

110
00:03:40,400 --> 00:03:44,159
where the magic happens because

111
00:03:42,000 --> 00:03:45,360
if you do that you'll see the content of

112
00:03:44,159 --> 00:03:47,679
the table as it was

113
00:03:45,360 --> 00:03:49,200
at this specific time stamp and not as

114
00:03:47,680 --> 00:03:50,560
it is now

115
00:03:49,200 --> 00:03:53,280
so this is your small personal time

116
00:03:50,560 --> 00:03:53,840
machine to rewind the time and see the

117
00:03:53,280 --> 00:03:56,080
table

118
00:03:53,840 --> 00:03:58,480
as it was at some arbitrary point and

119
00:03:56,080 --> 00:04:01,519
time in the past

120
00:03:58,480 --> 00:04:03,599
there are also two other versions

121
00:04:01,519 --> 00:04:05,280
of the syntax for system time you can

122
00:04:03,599 --> 00:04:06,079
specify for system time between to

123
00:04:05,280 --> 00:04:07,760
timestamp

124
00:04:06,080 --> 00:04:10,080
then you will see all the roles that

125
00:04:07,760 --> 00:04:11,599
existed at any point in time between

126
00:04:10,080 --> 00:04:13,519
those two timestamps

127
00:04:11,599 --> 00:04:15,359
it's getting a little bit weird because

128
00:04:13,519 --> 00:04:16,239
if the role was added say i don't know

129
00:04:15,360 --> 00:04:18,239
january 1st

130
00:04:16,238 --> 00:04:20,478
and deleted at january 2nd and then

131
00:04:18,238 --> 00:04:23,280
another row was added at january

132
00:04:20,478 --> 00:04:24,960
3rd and deleted at january 4th this

133
00:04:23,280 --> 00:04:26,400
between you saw both rows although there

134
00:04:24,960 --> 00:04:27,919
was no point in time

135
00:04:26,400 --> 00:04:30,239
where those two rows exist at the same

136
00:04:27,919 --> 00:04:30,960
time but this statement will show them

137
00:04:30,240 --> 00:04:33,199
both

138
00:04:30,960 --> 00:04:34,719
it has some usages but it will show

139
00:04:33,199 --> 00:04:37,759
inconsistent view of the table

140
00:04:34,720 --> 00:04:39,280
it might so do that and this is a very

141
00:04:37,759 --> 00:04:41,199
this is again the standard system it's a

142
00:04:39,280 --> 00:04:43,520
very slight variation of this one

143
00:04:41,199 --> 00:04:44,960
because between means that all and both

144
00:04:43,520 --> 00:04:47,840
ends are inclusive

145
00:04:44,960 --> 00:04:49,120
and this one includes the first end and

146
00:04:47,840 --> 00:04:51,919
exclude the other one

147
00:04:49,120 --> 00:04:53,840
so actually those two queries will

148
00:04:51,919 --> 00:04:56,719
return exactly the same thing

149
00:04:53,840 --> 00:04:57,280
but this one includes ends of this means

150
00:04:56,720 --> 00:04:59,360
everything

151
00:04:57,280 --> 00:05:01,198
after end of january including that one

152
00:04:59,360 --> 00:05:02,720
this means up to well first of february

153
00:05:01,199 --> 00:05:04,320
not including the first of february so

154
00:05:02,720 --> 00:05:08,160
same thing i don't know why they did

155
00:05:04,320 --> 00:05:10,240
this two same things in the center

156
00:05:08,160 --> 00:05:11,360
and how you can actually use this

157
00:05:10,240 --> 00:05:14,000
practically

158
00:05:11,360 --> 00:05:16,080
this is an example of this analytics on

159
00:05:14,000 --> 00:05:18,720
historical data that i used as a

160
00:05:16,080 --> 00:05:20,240
problem earlier so this is kind of

161
00:05:18,720 --> 00:05:21,120
online game and this is the table with

162
00:05:20,240 --> 00:05:23,840
users

163
00:05:21,120 --> 00:05:24,400
and now we join in the table of users as

164
00:05:23,840 --> 00:05:28,400
it was

165
00:05:24,400 --> 00:05:32,479
in the 2019 january 1st and with

166
00:05:28,400 --> 00:05:34,400
again same table as it was in 2020

167
00:05:32,479 --> 00:05:37,120
and the users who spent i don't know

168
00:05:34,400 --> 00:05:37,120
more than 100

169
00:05:37,360 --> 00:05:41,199
hours or some units of time online and

170
00:05:39,840 --> 00:05:42,960
probably we could derive some useful

171
00:05:41,199 --> 00:05:45,360
analytics of that

172
00:05:42,960 --> 00:05:47,758
so this one is joining two historical

173
00:05:45,360 --> 00:05:51,360
views of the table with itself

174
00:05:47,759 --> 00:05:52,800
and comparing them and example of the

175
00:05:51,360 --> 00:05:55,039
from two

176
00:05:52,800 --> 00:05:56,160
presumably this is a table of some kind

177
00:05:55,039 --> 00:05:58,318
of bank accounts

178
00:05:56,160 --> 00:05:59,600
you want this query will show all

179
00:05:58,319 --> 00:06:01,600
accounts that

180
00:05:59,600 --> 00:06:03,199
had a negative balance at any point in

181
00:06:01,600 --> 00:06:06,240
time in

182
00:06:03,199 --> 00:06:06,720
last year even if the balance is not

183
00:06:06,240 --> 00:06:08,800
zero

184
00:06:06,720 --> 00:06:10,560
it's not negative now this query will

185
00:06:08,800 --> 00:06:13,120
show all the guys that

186
00:06:10,560 --> 00:06:14,319
had balanced zero negative balance at

187
00:06:13,120 --> 00:06:18,160
any point in time between

188
00:06:14,319 --> 00:06:20,319
well january 1st 2019 to january 1st

189
00:06:18,160 --> 00:06:23,280
2020. this is again an example of

190
00:06:20,319 --> 00:06:25,120
analytics on historical data

191
00:06:23,280 --> 00:06:26,799
so we've seen that this is what standard

192
00:06:25,120 --> 00:06:29,280
allows us to do

193
00:06:26,800 --> 00:06:30,479
but we added some extensions in my adb

194
00:06:29,280 --> 00:06:33,280
to make it more

195
00:06:30,479 --> 00:06:34,719
user friendly more easier to use and

196
00:06:33,280 --> 00:06:36,638
faster to use

197
00:06:34,720 --> 00:06:37,759
more convenient to use this kind of

198
00:06:36,639 --> 00:06:40,000
things

199
00:06:37,759 --> 00:06:40,800
so first we simplify the syntax because

200
00:06:40,000 --> 00:06:43,440
if you do that

201
00:06:40,800 --> 00:06:45,039
perfectly exactly as understand you have

202
00:06:43,440 --> 00:06:46,639
need to do a lot of typing and

203
00:06:45,039 --> 00:06:48,400
if you do select star you will see those

204
00:06:46,639 --> 00:06:49,440
time stamps that you don't necessarily

205
00:06:48,400 --> 00:06:50,719
want to see just want

206
00:06:49,440 --> 00:06:54,000
to have your table system version

207
00:06:50,720 --> 00:06:55,680
without all this extra stuff

208
00:06:54,000 --> 00:06:57,039
it may be you can just write with system

209
00:06:55,680 --> 00:06:58,560
version without anything

210
00:06:57,039 --> 00:07:00,560
else and then you get system version

211
00:06:58,560 --> 00:07:02,160
tables the history will be tracked you

212
00:07:00,560 --> 00:07:03,599
can still create it as before

213
00:07:02,160 --> 00:07:07,280
but you don't need extra columns you

214
00:07:03,599 --> 00:07:07,280
don't need those period thing anything

215
00:07:07,919 --> 00:07:11,758
another thing we support many new

216
00:07:10,160 --> 00:07:13,599
supports it supports

217
00:07:11,759 --> 00:07:15,440
non-version columns inside system

218
00:07:13,599 --> 00:07:16,080
version tables again that's not a

219
00:07:15,440 --> 00:07:18,639
standard

220
00:07:16,080 --> 00:07:20,400
feature but this is a table of users and

221
00:07:18,639 --> 00:07:21,199
like every user has user id name and

222
00:07:20,400 --> 00:07:22,638
address

223
00:07:21,199 --> 00:07:24,800
and presumably every time they use the

224
00:07:22,639 --> 00:07:26,960
logins we increment the counter of

225
00:07:24,800 --> 00:07:28,800
how many times the user has logged in

226
00:07:26,960 --> 00:07:32,159
those data are very static this is

227
00:07:28,800 --> 00:07:34,240
changes like very often and

228
00:07:32,160 --> 00:07:35,919
it would populate the history of his

229
00:07:34,240 --> 00:07:38,400
unnecessary information

230
00:07:35,919 --> 00:07:39,680
we don't really intercept how much how

231
00:07:38,400 --> 00:07:40,638
many times user has logged in we only

232
00:07:39,680 --> 00:07:42,960
want to track

233
00:07:40,639 --> 00:07:43,759
how often when his address or name is

234
00:07:42,960 --> 00:07:45,280
changing

235
00:07:43,759 --> 00:07:46,960
and this one is not really part of the

236
00:07:45,280 --> 00:07:48,239
history that we're interested in

237
00:07:46,960 --> 00:07:51,039
it will just blow up the history

238
00:07:48,240 --> 00:07:52,560
unnecessary so in maybe you can specify

239
00:07:51,039 --> 00:07:53,520
that this column goes without system

240
00:07:52,560 --> 00:07:55,039
versioning and then

241
00:07:53,520 --> 00:07:57,599
it will not be versioned it will not

242
00:07:55,039 --> 00:08:00,560
create a historical version every time

243
00:07:57,599 --> 00:08:01,599
the user logs in it would allow to save

244
00:08:00,560 --> 00:08:04,800
a lot of

245
00:08:01,599 --> 00:08:04,800
storage space this way

246
00:08:04,960 --> 00:08:12,318
now maybe some of you is thinking and

247
00:08:08,319 --> 00:08:14,479
the first time my skull developers heard

248
00:08:12,319 --> 00:08:16,080
of this feature there's

249
00:08:14,479 --> 00:08:18,719
many bits and three so it's not the new

250
00:08:16,080 --> 00:08:22,318
feature i definitely got this question

251
00:08:18,720 --> 00:08:24,720
so for in the db as a

252
00:08:22,319 --> 00:08:26,800
transaction engine timestamp when the

253
00:08:24,720 --> 00:08:27,759
road was inserted or deleted it doesn't

254
00:08:26,800 --> 00:08:29,440
really

255
00:08:27,759 --> 00:08:30,960
define the time when the row becomes

256
00:08:29,440 --> 00:08:32,399
visible to other transactions

257
00:08:30,960 --> 00:08:34,000
because the row may be inserted at one

258
00:08:32,399 --> 00:08:35,039
point in time and transaction might be

259
00:08:34,000 --> 00:08:37,120
maybe committed like

260
00:08:35,039 --> 00:08:40,240
few hours later and until it's committed

261
00:08:37,120 --> 00:08:43,360
nobody can see the changes

262
00:08:40,240 --> 00:08:44,159
so using timestamps this way it will

263
00:08:43,360 --> 00:08:45,680
allow

264
00:08:44,159 --> 00:08:48,399
to see the data that when before they

265
00:08:45,680 --> 00:08:50,239
were committed one back in history

266
00:08:48,399 --> 00:08:52,000
and at some points in some for some

267
00:08:50,240 --> 00:08:54,240
applications it's fine

268
00:08:52,000 --> 00:08:55,360
like if you do this over the year

269
00:08:54,240 --> 00:08:57,600
analytics then

270
00:08:55,360 --> 00:08:59,440
a few seconds for a transaction it'll

271
00:08:57,600 --> 00:09:01,440
it'll give you slightly incorrect data

272
00:08:59,440 --> 00:09:03,920
but it doesn't really matter

273
00:09:01,440 --> 00:09:05,600
for the time spent over the year but if

274
00:09:03,920 --> 00:09:07,839
you want to do

275
00:09:05,600 --> 00:09:09,440
auditing or stuff like that then it

276
00:09:07,839 --> 00:09:13,600
might be very important

277
00:09:09,440 --> 00:09:14,959
and we allow to specify those

278
00:09:13,600 --> 00:09:16,560
genetic columns it's bigger than sign

279
00:09:14,959 --> 00:09:18,319
and then in adb we'll store transaction

280
00:09:16,560 --> 00:09:20,319
id is there instead of timestamps

281
00:09:18,320 --> 00:09:21,440
and then it'll be precisely transaction

282
00:09:20,320 --> 00:09:22,959
precise version and

283
00:09:21,440 --> 00:09:24,399
it'll show only the data that were

284
00:09:22,959 --> 00:09:25,279
actually committed and visible to other

285
00:09:24,399 --> 00:09:28,959
transactions

286
00:09:25,279 --> 00:09:28,959
at any given point in time

287
00:09:29,440 --> 00:09:35,040
and now that's another problem

288
00:09:32,640 --> 00:09:36,640
the table written that way it'll store

289
00:09:35,040 --> 00:09:37,519
its system version tables it will store

290
00:09:36,640 --> 00:09:39,920
all the data

291
00:09:37,519 --> 00:09:41,040
and historical data in the same table

292
00:09:39,920 --> 00:09:42,959
which means

293
00:09:41,040 --> 00:09:45,680
well any change on the table will the

294
00:09:42,959 --> 00:09:48,640
table will grow it will never shrink

295
00:09:45,680 --> 00:09:50,399
at mean it ended means if you do the

296
00:09:48,640 --> 00:09:51,839
indexes will grow and it'll

297
00:09:50,399 --> 00:09:53,920
grow so the question will get slower and

298
00:09:51,839 --> 00:09:55,920
slower and if you are

299
00:09:53,920 --> 00:09:57,599
unlucky enough to do a full table scan

300
00:09:55,920 --> 00:10:02,640
for some bad credit it'll be

301
00:09:57,600 --> 00:10:02,640
much much slower and

302
00:10:02,839 --> 00:10:06,560
also

303
00:10:04,079 --> 00:10:08,239
take it'll take a lot more storage but

304
00:10:06,560 --> 00:10:10,399
the fact is that

305
00:10:08,240 --> 00:10:11,600
historical data they are very rarely

306
00:10:10,399 --> 00:10:12,640
needed so most of the time you just want

307
00:10:11,600 --> 00:10:15,040
to use the current data

308
00:10:12,640 --> 00:10:16,800
and eventually really you want to look

309
00:10:15,040 --> 00:10:19,120
at what happened

310
00:10:16,800 --> 00:10:20,560
some time ago so it makes sense to store

311
00:10:19,120 --> 00:10:21,920
the key star separately so that it

312
00:10:20,560 --> 00:10:24,160
won't slow down the day-to-day

313
00:10:21,920 --> 00:10:25,920
operations and our solution leads to

314
00:10:24,160 --> 00:10:27,439
partition table by system time

315
00:10:25,920 --> 00:10:29,040
then you create a partition for current

316
00:10:27,440 --> 00:10:30,320
data and petition for historical data

317
00:10:29,040 --> 00:10:31,040
historical data will be stored

318
00:10:30,320 --> 00:10:33,519
separately

319
00:10:31,040 --> 00:10:35,040
and optimizer smart enough to realize

320
00:10:33,519 --> 00:10:36,800
that if you don't use any

321
00:10:35,040 --> 00:10:38,240
of things then you only need current

322
00:10:36,800 --> 00:10:39,839
data then it'll do partition pruning

323
00:10:38,240 --> 00:10:42,800
this will not never be opened or

324
00:10:39,839 --> 00:10:46,079
looked to it'll be basically as fast as

325
00:10:42,800 --> 00:10:49,120
not having any system version at all

326
00:10:46,079 --> 00:10:50,239
you can even do you can even rotate

327
00:10:49,120 --> 00:10:51,920
petitioning

328
00:10:50,240 --> 00:10:53,760
by having many parties many history

329
00:10:51,920 --> 00:10:56,399
petition and say like i don't know

330
00:10:53,760 --> 00:10:57,680
one week of history for every partition

331
00:10:56,399 --> 00:10:58,880
for this one you of course would need

332
00:10:57,680 --> 00:11:00,880
more than one petition

333
00:10:58,880 --> 00:11:02,399
one history partition and then you'll

334
00:11:00,880 --> 00:11:02,800
have one week of petition in here one

335
00:11:02,399 --> 00:11:04,240
week

336
00:11:02,800 --> 00:11:05,839
one week of history here one week of

337
00:11:04,240 --> 00:11:07,200
history here and so on

338
00:11:05,839 --> 00:11:08,959
new partitions will be not added

339
00:11:07,200 --> 00:11:10,160
automatically at least not in money db

340
00:11:08,959 --> 00:11:13,119
and three

341
00:11:10,160 --> 00:11:14,000
it's a new feature we are working on now

342
00:11:13,120 --> 00:11:15,839
so

343
00:11:14,000 --> 00:11:17,600
but every month or every few months you

344
00:11:15,839 --> 00:11:18,800
can add new partitions here and drop a

345
00:11:17,600 --> 00:11:21,600
few history partitions

346
00:11:18,800 --> 00:11:25,120
keeping history well reasonable and this

347
00:11:21,600 --> 00:11:25,120
could be of course any interval you want

348
00:11:27,120 --> 00:11:32,000
and a couple of new ways of creating the

349
00:11:30,160 --> 00:11:34,319
data one can specify in maybe

350
00:11:32,000 --> 00:11:37,120
for system time all and i think

351
00:11:34,320 --> 00:11:38,720
microsoft sql server also has the syntax

352
00:11:37,120 --> 00:11:40,560
which will be like having a very wide

353
00:11:38,720 --> 00:11:42,160
range it'll show all the history and all

354
00:11:40,560 --> 00:11:44,560
the current data

355
00:11:42,160 --> 00:11:46,079
and because in adb can stop transaction

356
00:11:44,560 --> 00:11:47,839
ids and not timestamps

357
00:11:46,079 --> 00:11:49,920
there's an optional way of querying

358
00:11:47,839 --> 00:11:51,360
exactly transaction by transaction id

359
00:11:49,920 --> 00:11:56,399
it'll show the data that this

360
00:11:51,360 --> 00:12:00,399
transaction has seen

361
00:11:56,399 --> 00:12:04,399
how much time do i have eight minutes

362
00:12:00,399 --> 00:12:04,399
okay so

363
00:12:04,880 --> 00:12:11,600
i okay i can talk about so the new

364
00:12:08,880 --> 00:12:13,760
configuration variables that are useful

365
00:12:11,600 --> 00:12:16,560
in configuring the system version thing

366
00:12:13,760 --> 00:12:17,839
first because most of the time system

367
00:12:16,560 --> 00:12:19,518
versioning it relies

368
00:12:17,839 --> 00:12:21,440
on current timestamp to know when

369
00:12:19,519 --> 00:12:22,480
something has happened when the row was

370
00:12:21,440 --> 00:12:26,240
changed

371
00:12:22,480 --> 00:12:27,839
and traditionally in mysql and in my adb

372
00:12:26,240 --> 00:12:29,760
current timestamp within session and

373
00:12:27,839 --> 00:12:32,079
user can identify it arbitrarily

374
00:12:29,760 --> 00:12:33,600
so a user can totally subvert the

375
00:12:32,079 --> 00:12:34,638
history and create non-existing

376
00:12:33,600 --> 00:12:36,880
histories

377
00:12:34,639 --> 00:12:37,680
and change timestamp to five years ago

378
00:12:36,880 --> 00:12:39,200
and then to

379
00:12:37,680 --> 00:12:41,199
10 years in the future and it wouldn't

380
00:12:39,200 --> 00:12:43,519
make any sense look

381
00:12:41,200 --> 00:12:46,160
if you look at the history later on so

382
00:12:43,519 --> 00:12:48,240
in my db now there's a way to restrict

383
00:12:46,160 --> 00:12:49,839
users who can modify the current

384
00:12:48,240 --> 00:12:52,240
timestamp within a session

385
00:12:49,839 --> 00:12:53,440
and the default value is for secure

386
00:12:52,240 --> 00:12:55,519
timestamp is no means

387
00:12:53,440 --> 00:12:57,519
timestamp is not secure and behavior is

388
00:12:55,519 --> 00:12:59,440
backward compatible anybody can modify

389
00:12:57,519 --> 00:13:01,680
the timestamp within a session but it

390
00:12:59,440 --> 00:13:03,360
can also be limited to super users

391
00:13:01,680 --> 00:13:05,680
only super user can modify the timestamp

392
00:13:03,360 --> 00:13:08,720
within a session

393
00:13:05,680 --> 00:13:09,680
alternatively there's an even more

394
00:13:08,720 --> 00:13:11,440
stricter

395
00:13:09,680 --> 00:13:13,040
configuration where security stamps

396
00:13:11,440 --> 00:13:15,360
intersect to replication meaning

397
00:13:13,040 --> 00:13:16,399
even the super user cannot mess the same

398
00:13:15,360 --> 00:13:18,000
timestamp

399
00:13:16,399 --> 00:13:20,320
but the slave will still follow the

400
00:13:18,000 --> 00:13:23,440
timestamp of the master and

401
00:13:20,320 --> 00:13:24,880
when the slave is replicating

402
00:13:23,440 --> 00:13:27,760
this timestamp on the slave will be

403
00:13:24,880 --> 00:13:31,760
exactly the same as it was on the master

404
00:13:27,760 --> 00:13:34,240
and the extreme configuration state in

405
00:13:31,760 --> 00:13:35,839
secure timestamp to yes means nothing

406
00:13:34,240 --> 00:13:36,480
ever can change the timestamp on the

407
00:13:35,839 --> 00:13:38,399
slave

408
00:13:36,480 --> 00:13:39,839
or on the server it will always be the

409
00:13:38,399 --> 00:13:42,320
system timestamp watching the

410
00:13:39,839 --> 00:13:43,680
well the clock of the operating system

411
00:13:42,320 --> 00:13:44,720
and then you can be sure that the

412
00:13:43,680 --> 00:13:48,000
history goes

413
00:13:44,720 --> 00:13:51,199
exactly as system clock say

414
00:13:48,000 --> 00:13:52,639
but the drawbacks are that times that

415
00:13:51,199 --> 00:13:54,880
the history and master and slave will be

416
00:13:52,639 --> 00:13:57,440
slightly different if the

417
00:13:54,880 --> 00:13:57,439
clock is not

418
00:14:01,199 --> 00:14:04,639
this is synchronized please yeah

419
00:14:03,760 --> 00:14:06,959
actually

420
00:14:04,639 --> 00:14:08,480
this is that's why i'm all thinking that

421
00:14:06,959 --> 00:14:11,359
podcast has a benefit

422
00:14:08,480 --> 00:14:12,000
over my adb on my square because i have

423
00:14:11,360 --> 00:14:13,680
really

424
00:14:12,000 --> 00:14:17,600
really difficult to imagine a dolphin

425
00:14:13,680 --> 00:14:20,319
walking in or

426
00:14:17,600 --> 00:14:20,320
anyway so

427
00:14:21,360 --> 00:14:24,480
and another related configuration

428
00:14:23,360 --> 00:14:27,680
variable is

429
00:14:24,480 --> 00:14:29,360
a system version alter history

430
00:14:27,680 --> 00:14:31,359
with the default value of error

431
00:14:29,360 --> 00:14:33,199
according to the standard you cannot do

432
00:14:31,360 --> 00:14:34,480
auto table for system version tables it

433
00:14:33,199 --> 00:14:36,479
should be an error

434
00:14:34,480 --> 00:14:38,480
so if you do alter table add column

435
00:14:36,480 --> 00:14:40,800
it'll fail

436
00:14:38,480 --> 00:14:42,720
we thought that's the default behavior

437
00:14:40,800 --> 00:14:44,560
of my adb as well but we thought it

438
00:14:42,720 --> 00:14:46,639
might be more user friendly and many

439
00:14:44,560 --> 00:14:47,279
users might still want to support alter

440
00:14:46,639 --> 00:14:50,399
table

441
00:14:47,279 --> 00:14:53,040
so there's a we and have a new

442
00:14:50,399 --> 00:14:54,720
other behavior with the system version

443
00:14:53,040 --> 00:14:56,480
alter equal skip which means you can add

444
00:14:54,720 --> 00:14:58,880
a column and then it'll work

445
00:14:56,480 --> 00:15:00,160
the history will be preserved but if you

446
00:14:58,880 --> 00:15:01,519
do

447
00:15:00,160 --> 00:15:03,360
if you'll try to look at the history of

448
00:15:01,519 --> 00:15:04,959
the table before you have added the

449
00:15:03,360 --> 00:15:05,360
column you will still see the new column

450
00:15:04,959 --> 00:15:06,800
that is

451
00:15:05,360 --> 00:15:08,639
metadata are not version you still see

452
00:15:06,800 --> 00:15:10,160
the new metadata but for existing

453
00:15:08,639 --> 00:15:13,839
columns you'll see the

454
00:15:10,160 --> 00:15:13,839
old values exactly it was supposed to be

455
00:15:14,639 --> 00:15:17,839
and how much would this feature cost in

456
00:15:17,199 --> 00:15:21,040
terms of

457
00:15:17,839 --> 00:15:23,920
performance this is a very simple

458
00:15:21,040 --> 00:15:24,959
benchmark percents are comparing their

459
00:15:23,920 --> 00:15:28,479
performance

460
00:15:24,959 --> 00:15:30,160
on system version tables as compared to

461
00:15:28,480 --> 00:15:32,079
the performance on non-system version

462
00:15:30,160 --> 00:15:33,680
tables

463
00:15:32,079 --> 00:15:35,680
and with petitions and unprediction and

464
00:15:33,680 --> 00:15:37,040
this is as you might guess this is this

465
00:15:35,680 --> 00:15:40,000
bench

466
00:15:37,040 --> 00:15:41,519
so as you can see the inserts are

467
00:15:40,000 --> 00:15:44,959
basically go with full speed there's no

468
00:15:41,519 --> 00:15:44,959
slowdown for inserts at all

469
00:15:45,199 --> 00:15:48,959
if you look at deletes deletes are

470
00:15:49,279 --> 00:15:53,360
20 30 percent slower and again those

471
00:15:51,519 --> 00:15:55,759
numbers are just ballpark

472
00:15:53,360 --> 00:15:57,040
they probably would highly depend on

473
00:15:55,759 --> 00:16:00,000
your application

474
00:15:57,040 --> 00:16:00,319
this probably won't this definitely will

475
00:16:00,000 --> 00:16:01,759
but

476
00:16:00,320 --> 00:16:03,600
i just want to show that it's not like

477
00:16:01,759 --> 00:16:05,600
10 times not two times

478
00:16:03,600 --> 00:16:06,720
and it's not zero percent it's sometimes

479
00:16:05,600 --> 00:16:08,560
it's

480
00:16:06,720 --> 00:16:10,240
five ten twenty percent it's something

481
00:16:08,560 --> 00:16:11,518
you might expect realistically expect in

482
00:16:10,240 --> 00:16:13,440
your application

483
00:16:11,519 --> 00:16:14,560
how did it get slow if you turn on

484
00:16:13,440 --> 00:16:16,880
system versioning

485
00:16:14,560 --> 00:16:18,479
so delete is always slower because you

486
00:16:16,880 --> 00:16:20,160
don't actually delete anything

487
00:16:18,480 --> 00:16:22,320
it's deleting the old row and inserting

488
00:16:20,160 --> 00:16:24,319
the history row and that that's extra

489
00:16:22,320 --> 00:16:26,079
work every time you delete something so

490
00:16:24,320 --> 00:16:28,399
delete will be always inevitably a

491
00:16:26,079 --> 00:16:32,319
little bit slower

492
00:16:28,399 --> 00:16:34,320
ulti read-only load is also slow simply

493
00:16:32,320 --> 00:16:36,720
because the primary key got longer

494
00:16:34,320 --> 00:16:39,440
in the system version tables and there's

495
00:16:36,720 --> 00:16:43,199
an asterisk meaning there's a

496
00:16:39,440 --> 00:16:44,639
an mdf a feature a plan to fix that in

497
00:16:43,199 --> 00:16:45,839
partition tables but it's not it's not

498
00:16:44,639 --> 00:16:48,000
possible to fix in

499
00:16:45,839 --> 00:16:50,000
non-partition system version tables

500
00:16:48,000 --> 00:16:51,360
although again this is very much depend

501
00:16:50,000 --> 00:16:53,360
on the your application depending on

502
00:16:51,360 --> 00:16:56,720
primary key length if it's

503
00:16:53,360 --> 00:17:00,079
you have a very short primary key then

504
00:16:56,720 --> 00:17:01,759
extending it will you might

505
00:17:00,079 --> 00:17:03,199
system version might extend it will

506
00:17:01,759 --> 00:17:04,000
happen at times time so it might extend

507
00:17:03,199 --> 00:17:07,039
like few times

508
00:17:04,000 --> 00:17:08,079
if you have a reasonably long primary

509
00:17:07,039 --> 00:17:11,520
key like uid

510
00:17:08,079 --> 00:17:13,280
then the slowdown will be much much less

511
00:17:11,520 --> 00:17:15,119
if you don't have primary get key at all

512
00:17:13,280 --> 00:17:16,639
and rely on in adb

513
00:17:15,119 --> 00:17:19,039
generator primary key there should be no

514
00:17:16,640 --> 00:17:22,160
slowdown whatsoever

515
00:17:19,039 --> 00:17:23,839
and ultipaded right

516
00:17:22,160 --> 00:17:25,439
this one is a little bit confusing so

517
00:17:23,839 --> 00:17:27,039
what i've done i've run the otp

518
00:17:25,439 --> 00:17:29,360
drive benchmark three times on the same

519
00:17:27,039 --> 00:17:31,200
data without regenerating the data

520
00:17:29,360 --> 00:17:32,719
and the first time i got this load i got

521
00:17:31,200 --> 00:17:35,360
a 60 speed

522
00:17:32,720 --> 00:17:36,640
like 40 slower down sixth time i got 50

523
00:17:35,360 --> 00:17:38,240
percent

524
00:17:36,640 --> 00:17:39,760
third time i got 40 percent if i would

525
00:17:38,240 --> 00:17:40,799
run it more and more it would be slower

526
00:17:39,760 --> 00:17:42,400
and slower because

527
00:17:40,799 --> 00:17:43,918
every time i run an otp in the right

528
00:17:42,400 --> 00:17:45,679
benchmark the his

529
00:17:43,919 --> 00:17:47,840
roles are deleted and updated so history

530
00:17:45,679 --> 00:17:51,200
is accumulated table goes

531
00:17:47,840 --> 00:17:53,360
longer and that's why the benchmark

532
00:17:51,200 --> 00:17:55,919
system version table is getting slower

533
00:17:53,360 --> 00:17:57,760
compared to non-system version tables

534
00:17:55,919 --> 00:17:59,120
and this is exactly the use case that

535
00:17:57,760 --> 00:18:01,039
partition table is supposed to fix

536
00:17:59,120 --> 00:18:02,639
because it keeps the history separately

537
00:18:01,039 --> 00:18:04,879
the table is not getting slow because

538
00:18:02,640 --> 00:18:07,360
the current data is not growing

539
00:18:04,880 --> 00:18:08,720
all the changes the historical data are

540
00:18:07,360 --> 00:18:10,719
growing but historical data are not

541
00:18:08,720 --> 00:18:12,480
getting queried in

542
00:18:10,720 --> 00:18:14,160
in since bench benchmarks so this is

543
00:18:12,480 --> 00:18:16,960
exactly the use case when

544
00:18:14,160 --> 00:18:18,160
partition table is fixing it removes the

545
00:18:16,960 --> 00:18:20,000
slowdown that

546
00:18:18,160 --> 00:18:22,880
one would observe in non-partition

547
00:18:20,000 --> 00:18:22,880
system version table

548
00:18:23,760 --> 00:18:29,840
this is it thank you

549
00:18:31,840 --> 00:18:34,480
any questions

550
00:18:36,640 --> 00:18:43,360
i'm not sure you had to ask the blue

551
00:18:40,840 --> 00:18:46,639
elephant

552
00:18:43,360 --> 00:18:50,000
yes will it be possible to enable the

553
00:18:46,640 --> 00:18:52,480
versioning table only on a slave

554
00:18:50,000 --> 00:18:53,600
yes those are one of the use cases we

555
00:18:52,480 --> 00:18:57,919
are

556
00:18:53,600 --> 00:18:59,760
thinking about but then the times

557
00:18:57,919 --> 00:19:01,360
will only be on the slave not

558
00:18:59,760 --> 00:19:03,840
necessarily so

559
00:19:01,360 --> 00:19:04,719
normally the master it's it includes the

560
00:19:03,840 --> 00:19:07,360
timestamp in

561
00:19:04,720 --> 00:19:08,480
every event so there's a problem when

562
00:19:07,360 --> 00:19:10,479
the master

563
00:19:08,480 --> 00:19:12,160
includes the timestamp without

564
00:19:10,480 --> 00:19:13,360
microseconds and slave needs it up to

565
00:19:12,160 --> 00:19:14,880
the microseconds

566
00:19:13,360 --> 00:19:16,240
then the slave could guess some

567
00:19:14,880 --> 00:19:16,720
arbitrary number of microseconds just a

568
00:19:16,240 --> 00:19:19,760
little bit

569
00:19:16,720 --> 00:19:21,200
you just use increasing number otherwise

570
00:19:19,760 --> 00:19:24,480
it'll use the timestamp from the master

571
00:19:21,200 --> 00:19:26,880
so it'll mostly follow the master

572
00:19:24,480 --> 00:19:28,720
yes you have shown an example where we

573
00:19:26,880 --> 00:19:31,440
can see the content

574
00:19:28,720 --> 00:19:31,919
in a period of time is it possible to

575
00:19:31,440 --> 00:19:35,280
see

576
00:19:31,919 --> 00:19:39,039
the content for example one row

577
00:19:35,280 --> 00:19:44,080
all the all the changes

578
00:19:39,039 --> 00:19:46,960
ye uh yes but then you just don't use uh

579
00:19:44,080 --> 00:19:48,480
oh there are actually two way to do that

580
00:19:46,960 --> 00:19:51,520
yeah so you you can do

581
00:19:48,480 --> 00:19:55,200
you can do all and just where id

582
00:19:51,520 --> 00:19:57,280
equals something ah okay yeah

583
00:19:55,200 --> 00:19:58,960
because this one is part of the table

584
00:19:57,280 --> 00:20:00,480
name so this is basically the table

585
00:19:58,960 --> 00:20:03,600
then you could anywhere close and

586
00:20:00,480 --> 00:20:05,200
everything yes please

587
00:20:03,600 --> 00:20:08,559
what happens if you try to join

588
00:20:05,200 --> 00:20:08,559
something with that data

589
00:20:10,880 --> 00:20:14,799
so this is the join and so i just said

590
00:20:13,760 --> 00:20:16,400
this thing

591
00:20:14,799 --> 00:20:18,320
is basically part of the table so this

592
00:20:16,400 --> 00:20:20,799
is the table users4

593
00:20:18,320 --> 00:20:21,520
this is another table uses and then this

594
00:20:20,799 --> 00:20:24,480
is a join

595
00:20:21,520 --> 00:20:25,360
using id and this is just the journal so

596
00:20:24,480 --> 00:20:27,520
you can use

597
00:20:25,360 --> 00:20:30,399
this thing any any anywhere where the

598
00:20:27,520 --> 00:20:34,000
table name is expected

599
00:20:30,400 --> 00:20:36,320
yes please so with the amount of changes

600
00:20:34,000 --> 00:20:37,919
the the volume is going to be very large

601
00:20:36,320 --> 00:20:40,399
is it possible to squash

602
00:20:37,919 --> 00:20:42,720
uh once in a while like if the same row

603
00:20:40,400 --> 00:20:46,880
has been updated five times just

604
00:20:42,720 --> 00:20:48,400
merge it no you no you cannot you can do

605
00:20:46,880 --> 00:20:50,640
you can you can

606
00:20:48,400 --> 00:20:52,159
team you can periodically remove old

607
00:20:50,640 --> 00:20:53,919
partitions and keep like i don't know

608
00:20:52,159 --> 00:20:55,039
three months of changes and delete and

609
00:20:53,919 --> 00:20:56,720
drop other partitions

610
00:20:55,039 --> 00:20:59,280
but general delete doesn't work because

611
00:20:56,720 --> 00:21:03,840
well that contradicts the idea of

612
00:20:59,280 --> 00:21:03,840
immutable history yes

613
00:21:07,120 --> 00:21:11,678
yes yes that's why that's why i said

614
00:21:09,919 --> 00:21:13,360
that delete is basically

615
00:21:11,679 --> 00:21:16,400
delete plus and sort you delete from

616
00:21:13,360 --> 00:21:19,439
here you can insert here

617
00:21:16,400 --> 00:21:20,559
yes update is just inserted because you

618
00:21:19,440 --> 00:21:22,240
update here and you

619
00:21:20,559 --> 00:21:31,840
insert historical arrow here updates are

620
00:21:22,240 --> 00:21:31,840
also slower inevitably

621
00:21:32,720 --> 00:21:37,520
no it's update of the car of this row in

622
00:21:35,360 --> 00:21:38,479
here and insert of the old version in

623
00:21:37,520 --> 00:21:44,240
here

624
00:21:38,480 --> 00:21:47,440
it's update plus and search yes

625
00:21:44,240 --> 00:21:47,440
because uh

626
00:21:48,240 --> 00:21:51,679
ltp that benchmark they're mostly doing

627
00:21:50,159 --> 00:21:52,880
inserts and these are generally much

628
00:21:51,679 --> 00:21:55,280
faster than updates

629
00:21:52,880 --> 00:21:57,200
so that you did you didn't lose anything

630
00:21:55,280 --> 00:22:00,240
on insert or sorry inserts

631
00:21:57,200 --> 00:22:02,320
reads it's doing mostly reads and you

632
00:22:00,240 --> 00:22:05,520
want so much on fast reads that

633
00:22:02,320 --> 00:22:08,080
everything else is very hidden

634
00:22:05,520 --> 00:22:10,639
exactly if you asked about exact data on

635
00:22:08,080 --> 00:22:12,720
three rounds i had 35 percent on one

636
00:22:10,640 --> 00:22:14,000
38 on the other and like hundred two

637
00:22:12,720 --> 00:22:16,000
percent of the third one

638
00:22:14,000 --> 00:22:19,200
so which is this look it's few percent

639
00:22:16,000 --> 00:22:19,200
and don't really matter much

640
00:22:24,840 --> 00:22:27,840
yes

641
00:22:33,520 --> 00:22:36,080
completely in the

642
00:22:39,440 --> 00:22:43,840
to servers the costs of maintaining

643
00:22:42,320 --> 00:22:46,480
diversion so basically

644
00:22:43,840 --> 00:22:50,000
in the purge of innodb populating the

645
00:22:46,480 --> 00:22:50,000
history as we purge

646
00:22:51,840 --> 00:22:56,639
this this is how oracle implements it as

647
00:22:55,200 --> 00:22:58,799
far as i know

648
00:22:56,640 --> 00:22:58,799
the

649
00:23:00,159 --> 00:23:07,440
they use the they use the undo log

650
00:23:04,080 --> 00:23:11,520
and versioning it might

651
00:23:07,440 --> 00:23:14,880
be it's probably can be done in

652
00:23:11,520 --> 00:23:17,200
inside an adb it'll be

653
00:23:14,880 --> 00:23:18,400
a lot of work to do it to leverage the

654
00:23:17,200 --> 00:23:20,960
underlog but

655
00:23:18,400 --> 00:23:23,840
pretend that this from the server point

656
00:23:20,960 --> 00:23:23,840
of view it's still a table

657
00:23:32,559 --> 00:23:39,760
yeah yeah idea is that yeah

658
00:23:36,720 --> 00:23:41,440
searching should be as fast

659
00:23:39,760 --> 00:23:44,640
even if you are history or not with this

660
00:23:41,440 --> 00:23:46,960
one we get same speed for search

661
00:23:44,640 --> 00:23:48,559
and you have millions of things there

662
00:23:46,960 --> 00:23:48,960
you have to go a long way well every

663
00:23:48,559 --> 00:23:50,399
time

664
00:23:48,960 --> 00:23:52,640
when you purge the under log you

665
00:23:50,400 --> 00:23:55,360
populate the table so then you

666
00:23:52,640 --> 00:23:56,400
it's well i think that's what oracle is

667
00:23:55,360 --> 00:23:58,000
doing with flashback

668
00:23:56,400 --> 00:23:59,440
minus populating the table just keep the

669
00:23:58,000 --> 00:24:05,520
data in the underlook and then it's

670
00:23:59,440 --> 00:24:08,799
purged then it's pushed forever

671
00:24:05,520 --> 00:24:10,639
yeah so it's it would totally make sense

672
00:24:08,799 --> 00:24:12,720
unless you want to see like exactly very

673
00:24:10,640 --> 00:24:19,840
fresh data

674
00:24:12,720 --> 00:24:19,840
okay thank you

675
00:24:23,279 --> 00:24:25,360
you

