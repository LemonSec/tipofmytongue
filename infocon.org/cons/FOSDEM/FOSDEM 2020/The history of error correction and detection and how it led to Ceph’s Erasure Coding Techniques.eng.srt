1
00:00:04,960 --> 00:00:09,440
about rage coding but the history

2
00:00:07,040 --> 00:00:11,360
of error detection correction and how

3
00:00:09,440 --> 00:00:17,119
that led to rage coding

4
00:00:11,360 --> 00:00:25,198
so thank you for coming um

5
00:00:17,119 --> 00:00:25,198
and it's not working anymore

6
00:00:28,840 --> 00:00:31,840
hmm

7
00:00:33,680 --> 00:00:45,840
one second

8
00:00:46,879 --> 00:00:53,199
okay there we go nice cool

9
00:00:50,000 --> 00:00:55,680
so who am i so my name is danny

10
00:00:53,199 --> 00:00:56,559
and i work for soft time in the uk where

11
00:00:55,680 --> 00:00:59,760
we're working

12
00:00:56,559 --> 00:01:01,120
on building a ceph appliance i've mainly

13
00:00:59,760 --> 00:01:02,719
worked for

14
00:01:01,120 --> 00:01:04,720
open source companies in the past so

15
00:01:02,719 --> 00:01:06,560
companies like linbit and codethink

16
00:01:04,720 --> 00:01:07,840
and i run a non-profit in the uk called

17
00:01:06,560 --> 00:01:10,479
open source events

18
00:01:07,840 --> 00:01:14,080
where we do tech meetups and conferences

19
00:01:10,479 --> 00:01:17,840
mainly around openstack and cloud native

20
00:01:14,080 --> 00:01:19,119
and yeah i like beer so i mainly got

21
00:01:17,840 --> 00:01:20,880
interested in this topic

22
00:01:19,119 --> 00:01:22,640
a few years ago after i saw a colleague

23
00:01:20,880 --> 00:01:25,679
called jim macarthur do a

24
00:01:22,640 --> 00:01:27,759
lightning talk on error correction

25
00:01:25,680 --> 00:01:29,920
and so i wondered how this relates to

26
00:01:27,759 --> 00:01:31,280
raid and other storage technologies

27
00:01:29,920 --> 00:01:32,960
and i did some digging and figured out

28
00:01:31,280 --> 00:01:34,799
there's lots of ways to do this

29
00:01:32,960 --> 00:01:37,679
and i thought i'd provide an overview of

30
00:01:34,799 --> 00:01:37,680
some of the ways that

31
00:01:37,840 --> 00:01:41,119
error correction and detection is done

32
00:01:39,920 --> 00:01:42,479
so the main idea

33
00:01:41,119 --> 00:01:45,040
is to have a set of techniques so that

34
00:01:42,479 --> 00:01:47,439
when we transmit data we can figure out

35
00:01:45,040 --> 00:01:48,240
if um once we've received the data on

36
00:01:47,439 --> 00:01:51,039
the other end

37
00:01:48,240 --> 00:01:52,640
it's inconsistent or even better if we

38
00:01:51,040 --> 00:01:54,560
can correct the data

39
00:01:52,640 --> 00:01:55,680
rather than just dropping it so these

40
00:01:54,560 --> 00:01:58,479
concepts have been around

41
00:01:55,680 --> 00:02:00,079
since before modern computers were born

42
00:01:58,479 --> 00:02:01,600
but they've come a long way so even the

43
00:02:00,079 --> 00:02:04,240
older ideas are still around

44
00:02:01,600 --> 00:02:07,119
in some of our modern technology so why

45
00:02:04,240 --> 00:02:08,878
do we have errors in the first place

46
00:02:07,119 --> 00:02:10,479
it could be human error it could be

47
00:02:08,878 --> 00:02:11,760
network glitches it could be something

48
00:02:10,479 --> 00:02:15,120
more random such as

49
00:02:11,760 --> 00:02:16,799
uh noise on a chip or cosmic rays

50
00:02:15,120 --> 00:02:19,440
interfering with the chip

51
00:02:16,800 --> 00:02:21,040
all these things can cause us to receive

52
00:02:19,440 --> 00:02:24,720
something different or the

53
00:02:21,040 --> 00:02:26,879
data to send something different

54
00:02:24,720 --> 00:02:29,120
so by show of hands how many people have

55
00:02:26,879 --> 00:02:31,599
heard of a parity bit

56
00:02:29,120 --> 00:02:32,400
pretty much the whole room cool so the

57
00:02:31,599 --> 00:02:34,560
parity bit

58
00:02:32,400 --> 00:02:36,319
is the earliest and most basic form of

59
00:02:34,560 --> 00:02:38,239
error text in computers

60
00:02:36,319 --> 00:02:40,000
and it's a very basic type of checksum

61
00:02:38,239 --> 00:02:41,440
and the idea is that you can add a bit

62
00:02:40,000 --> 00:02:43,440
to the end of a set of bits

63
00:02:41,440 --> 00:02:44,879
which let you detect an error when

64
00:02:43,440 --> 00:02:47,040
you're transmitting the data

65
00:02:44,879 --> 00:02:48,239
so we do this by adding up the number of

66
00:02:47,040 --> 00:02:51,840
one bits we have

67
00:02:48,239 --> 00:02:52,239
and um if it's an even parity bit then

68
00:02:51,840 --> 00:02:54,400
we

69
00:02:52,239 --> 00:02:56,160
make it true for an even number of one

70
00:02:54,400 --> 00:02:57,280
bits and if it's an odd parity bit

71
00:02:56,160 --> 00:02:59,280
we'd make it true for an odd number of

72
00:02:57,280 --> 00:03:02,400
bits so you can see here

73
00:02:59,280 --> 00:03:04,640
that in the first uh character we have

74
00:03:02,400 --> 00:03:06,159
two one bits that we're transmitting so

75
00:03:04,640 --> 00:03:06,799
because that's even we'll add a one on

76
00:03:06,159 --> 00:03:08,319
the end

77
00:03:06,800 --> 00:03:09,599
and we'll send that and if we receive

78
00:03:08,319 --> 00:03:12,000
the same thing on the other side we know

79
00:03:09,599 --> 00:03:14,560
that no error has transmitted

80
00:03:12,000 --> 00:03:15,040
um same again with k an even number of

81
00:03:14,560 --> 00:03:16,959
bits

82
00:03:15,040 --> 00:03:18,400
so we had a one on the end that's the

83
00:03:16,959 --> 00:03:19,920
one in bold and

84
00:03:18,400 --> 00:03:21,760
if we transmit it and there's an error

85
00:03:19,920 --> 00:03:23,119
or there's a different number

86
00:03:21,760 --> 00:03:24,959
we can do the calculation on the other

87
00:03:23,120 --> 00:03:25,680
side and see that actually we should

88
00:03:24,959 --> 00:03:27,920
have

89
00:03:25,680 --> 00:03:28,879
a zero there's obviously some sort of

90
00:03:27,920 --> 00:03:32,000
mistake so

91
00:03:28,879 --> 00:03:33,200
we just drop that frame and ask the

92
00:03:32,000 --> 00:03:35,440
whoever's whatever sent it to

93
00:03:33,200 --> 00:03:36,798
re-transmit it and same again on the on

94
00:03:35,440 --> 00:03:37,359
the third one there's another error

95
00:03:36,799 --> 00:03:38,879
there

96
00:03:37,360 --> 00:03:40,239
and that's an odd number of bits that's

97
00:03:38,879 --> 00:03:42,640
why the last the last bit that we're

98
00:03:40,239 --> 00:03:44,799
transmitting is a zero

99
00:03:42,640 --> 00:03:46,238
so this concept goes back as far as the

100
00:03:44,799 --> 00:03:48,080
50s and

101
00:03:46,239 --> 00:03:49,920
we had parity tracks appear on

102
00:03:48,080 --> 00:03:53,040
mechanical tape drives

103
00:03:49,920 --> 00:03:53,679
in the early 50s the major flaw with

104
00:03:53,040 --> 00:03:56,319
this

105
00:03:53,680 --> 00:03:57,840
is that if you have more than one error

106
00:03:56,319 --> 00:03:58,159
within a byte we're not going to detect

107
00:03:57,840 --> 00:04:01,680
it

108
00:03:58,159 --> 00:04:02,640
so it will only pick up um one bit error

109
00:04:01,680 --> 00:04:04,159
so if there's

110
00:04:02,640 --> 00:04:06,238
multiple bits within the same segment

111
00:04:04,159 --> 00:04:07,040
then obviously it's gonna be a false

112
00:04:06,239 --> 00:04:09,439
positive

113
00:04:07,040 --> 00:04:11,200
it's still very useful though um and we

114
00:04:09,439 --> 00:04:12,400
use it quite heavily in hardware

115
00:04:11,200 --> 00:04:15,200
applications such as micro

116
00:04:12,400 --> 00:04:16,478
processor caches uh the pci and scuzzy

117
00:04:15,200 --> 00:04:19,279
bus standards

118
00:04:16,478 --> 00:04:21,519
and rs232 serial and lots of other

119
00:04:19,279 --> 00:04:23,599
hardware applications use it

120
00:04:21,519 --> 00:04:25,120
so that's a very simple way to detect

121
00:04:23,600 --> 00:04:26,960
basic errors

122
00:04:25,120 --> 00:04:28,160
in transmission but we can't correct

123
00:04:26,960 --> 00:04:30,320
them

124
00:04:28,160 --> 00:04:31,360
um there's a decimal equivalent to this

125
00:04:30,320 --> 00:04:33,919
um

126
00:04:31,360 --> 00:04:35,199
and this is used in lots of different

127
00:04:33,919 --> 00:04:37,919
real world applications

128
00:04:35,199 --> 00:04:39,360
like social security cards id cards and

129
00:04:37,919 --> 00:04:42,479
all major credit cards so this is one of

130
00:04:39,360 --> 00:04:44,160
my old credit cards or debit cards and

131
00:04:42,479 --> 00:04:45,680
you'll see that the last digit is

132
00:04:44,160 --> 00:04:46,880
actually a check digit so how does this

133
00:04:45,680 --> 00:04:48,560
work

134
00:04:46,880 --> 00:04:49,840
uh i don't know if you've ever noticed

135
00:04:48,560 --> 00:04:51,360
that when you're putting your credit

136
00:04:49,840 --> 00:04:55,198
card or debit card number into

137
00:04:51,360 --> 00:04:56,639
a web form it might automatically know

138
00:04:55,199 --> 00:04:58,400
whether that's valid or not even if

139
00:04:56,639 --> 00:05:00,560
you're not connected to the wi-fi

140
00:04:58,400 --> 00:05:02,400
it's all happening locally and that's

141
00:05:00,560 --> 00:05:05,360
due to this loon algorithm

142
00:05:02,400 --> 00:05:06,880
and so the idea is this guy german

143
00:05:05,360 --> 00:05:08,880
american engineer worked for ibm

144
00:05:06,880 --> 00:05:10,159
in the 40s and 50s and he was the first

145
00:05:08,880 --> 00:05:12,080
guy that came up with the idea of

146
00:05:10,160 --> 00:05:14,800
information buckets to speed up

147
00:05:12,080 --> 00:05:15,520
data retrieval and storage and the idea

148
00:05:14,800 --> 00:05:17,199
here is that

149
00:05:15,520 --> 00:05:18,880
that he came up with this algorithm is

150
00:05:17,199 --> 00:05:20,160
that you double every digit

151
00:05:18,880 --> 00:05:22,639
every other digit starting from the

152
00:05:20,160 --> 00:05:25,039
right and then sum all the digits

153
00:05:22,639 --> 00:05:26,160
and they should be a multiple of 10 and

154
00:05:25,039 --> 00:05:27,280
if they're not then you know that

155
00:05:26,160 --> 00:05:28,400
something's wrong so the last

156
00:05:27,280 --> 00:05:31,440
the last digit will either make it a

157
00:05:28,400 --> 00:05:31,440
multiple 10 or it won't

158
00:05:34,639 --> 00:05:40,880
cool so then we get on to um

159
00:05:38,000 --> 00:05:42,320
trying to do some correction and um the

160
00:05:40,880 --> 00:05:44,080
mate one of the main pioneers

161
00:05:42,320 --> 00:05:46,240
here is a guy called richard hamming and

162
00:05:44,080 --> 00:05:46,880
he used to he was a mathematician and

163
00:05:46,240 --> 00:05:49,280
professor

164
00:05:46,880 --> 00:05:50,719
who worked at los alamos on the

165
00:05:49,280 --> 00:05:53,520
manhattan project

166
00:05:50,720 --> 00:05:55,280
in 1945 and he was on a team which was

167
00:05:53,520 --> 00:05:56,479
responsible for programming the ibm

168
00:05:55,280 --> 00:05:59,359
calculating machines

169
00:05:56,479 --> 00:06:00,960
which had the scientists formulas check

170
00:05:59,360 --> 00:06:03,280
that they were correct

171
00:06:00,960 --> 00:06:04,000
and a few years later he went on to join

172
00:06:03,280 --> 00:06:05,599
bell labs

173
00:06:04,000 --> 00:06:07,840
and he became known to be one of the

174
00:06:05,600 --> 00:06:09,199
young turks who was a group of people at

175
00:06:07,840 --> 00:06:12,080
bell labs that

176
00:06:09,199 --> 00:06:12,960
all had heavy contributions to computer

177
00:06:12,080 --> 00:06:15,120
science

178
00:06:12,960 --> 00:06:16,400
um they were all pretty well respected

179
00:06:15,120 --> 00:06:18,080
and they didn't have

180
00:06:16,400 --> 00:06:20,159
they weren't given the usual

181
00:06:18,080 --> 00:06:22,240
responsibilities and structure uh

182
00:06:20,160 --> 00:06:23,919
you know but measured by grants and

183
00:06:22,240 --> 00:06:25,840
teaching teaching and papers they were

184
00:06:23,919 --> 00:06:27,919
kind of just left to get on with it

185
00:06:25,840 --> 00:06:30,000
and um three of them ended up going on

186
00:06:27,919 --> 00:06:32,000
to win nobel prizes and a few of them

187
00:06:30,000 --> 00:06:33,919
went on to lead bell labs

188
00:06:32,000 --> 00:06:35,280
but all of them are highly respected

189
00:06:33,919 --> 00:06:37,280
scientists

190
00:06:35,280 --> 00:06:39,359
john tukey was one of the first guys to

191
00:06:37,280 --> 00:06:40,719
come up with the name the the term bit

192
00:06:39,360 --> 00:06:42,720
which is contracted from binary

193
00:06:40,720 --> 00:06:45,759
information digit

194
00:06:42,720 --> 00:06:45,759
so while he was a bell

195
00:06:46,160 --> 00:06:49,520
richard hamming set one of his

196
00:06:48,000 --> 00:06:51,440
calculating machines to work on a

197
00:06:49,520 --> 00:06:52,479
problem over the weekend he said he said

198
00:06:51,440 --> 00:06:53,759
it on friday

199
00:06:52,479 --> 00:06:55,520
and when he came back on monday he

200
00:06:53,759 --> 00:06:58,400
discovered that due to

201
00:06:55,520 --> 00:06:59,758
uh an error uh the whole calculation

202
00:06:58,400 --> 00:07:00,719
died early on saturday morning and so

203
00:06:59,759 --> 00:07:02,240
he'd have to restart the whole thing

204
00:07:00,720 --> 00:07:03,680
again waste two days of work or wait

205
00:07:02,240 --> 00:07:05,680
till the next weekend

206
00:07:03,680 --> 00:07:07,680
and this was quite common because you

207
00:07:05,680 --> 00:07:09,199
had uh punch cards and so if

208
00:07:07,680 --> 00:07:11,039
a card was bent or it didn't punch

209
00:07:09,199 --> 00:07:14,000
properly then you know

210
00:07:11,039 --> 00:07:15,680
you're gonna have an error so he then

211
00:07:14,000 --> 00:07:17,120
basically went on to perform probably

212
00:07:15,680 --> 00:07:18,479
the biggest yak shave in history and

213
00:07:17,120 --> 00:07:19,840
decided to stack off all that physics

214
00:07:18,479 --> 00:07:21,758
nonsense and figure out how to get

215
00:07:19,840 --> 00:07:24,000
calculating machines to detect errors

216
00:07:21,759 --> 00:07:26,160
and automatically re-transmit data

217
00:07:24,000 --> 00:07:28,240
identified as inconsistent

218
00:07:26,160 --> 00:07:29,440
so he published this key paper in 1950

219
00:07:28,240 --> 00:07:30,720
called error detecting and error

220
00:07:29,440 --> 00:07:33,039
correcting codes

221
00:07:30,720 --> 00:07:34,400
and he described a few concepts that are

222
00:07:33,039 --> 00:07:35,759
still core to error detection and

223
00:07:34,400 --> 00:07:39,198
correction today

224
00:07:35,759 --> 00:07:40,880
and these are number one is the

225
00:07:39,199 --> 00:07:42,720
the hamming distance which just

226
00:07:40,880 --> 00:07:44,000
describes how many single bit operations

227
00:07:42,720 --> 00:07:47,039
i have to do to correct

228
00:07:44,000 --> 00:07:48,879
a binary number or string so you know

229
00:07:47,039 --> 00:07:51,199
for faster 19 faster than 20 this

230
00:07:48,879 --> 00:07:53,440
two characters different that would be

231
00:07:51,199 --> 00:07:54,960
two but obviously on a binary level

232
00:07:53,440 --> 00:07:56,080
um this can also be represented

233
00:07:54,960 --> 00:07:59,039
geometrically and it's called the

234
00:07:56,080 --> 00:08:01,599
hamming cube

235
00:07:59,039 --> 00:08:02,479
so he went on to define a system called

236
00:08:01,599 --> 00:08:05,120
hamming codes

237
00:08:02,479 --> 00:08:07,280
which is far more robust at checking

238
00:08:05,120 --> 00:08:09,039
errors than standard parity

239
00:08:07,280 --> 00:08:10,799
and what he developed was the concept of

240
00:08:09,039 --> 00:08:13,199
having three parity bits for every four

241
00:08:10,800 --> 00:08:15,039
data bits which is quite expensive

242
00:08:13,199 --> 00:08:17,520
but it means that we can detect errors

243
00:08:15,039 --> 00:08:18,159
up to two bits and also correct one bit

244
00:08:17,520 --> 00:08:20,159
errors

245
00:08:18,160 --> 00:08:21,599
so how does this work let's have a look

246
00:08:20,160 --> 00:08:24,800
so if we have

247
00:08:21,599 --> 00:08:27,360
four bits here d1 to d4

248
00:08:24,800 --> 00:08:29,039
and we want to send them over some sort

249
00:08:27,360 --> 00:08:30,479
of transmission channel

250
00:08:29,039 --> 00:08:33,120
we can arrange them at the intersection

251
00:08:30,479 --> 00:08:33,120
of three circles

252
00:08:33,679 --> 00:08:39,679
so one zero one zero

253
00:08:36,799 --> 00:08:40,000
and then we can calculate the parity for

254
00:08:39,679 --> 00:08:43,439
each

255
00:08:40,000 --> 00:08:45,600
circle so for parity circle one

256
00:08:43,440 --> 00:08:48,000
we have one one bit so that's an odd

257
00:08:45,600 --> 00:08:51,120
number so the parity will be zero

258
00:08:48,000 --> 00:08:54,240
for parity um for the second circle

259
00:08:51,120 --> 00:08:56,720
we have two one bits so that's even so

260
00:08:54,240 --> 00:08:59,040
part is going to be one

261
00:08:56,720 --> 00:09:00,959
um for the third circle we have again

262
00:08:59,040 --> 00:09:04,480
one parity bit

263
00:09:00,959 --> 00:09:07,839
so that's odd so that's gonna be zero so

264
00:09:04,480 --> 00:09:10,000
we have three parity bits we add them to

265
00:09:07,839 --> 00:09:11,839
our data and we send that across the

266
00:09:10,000 --> 00:09:13,440
channel

267
00:09:11,839 --> 00:09:15,440
now on the other side we receive

268
00:09:13,440 --> 00:09:17,760
something different so we get a

269
00:09:15,440 --> 00:09:18,720
d3 is turned to a zero instead of a one

270
00:09:17,760 --> 00:09:22,080
so how do we

271
00:09:18,720 --> 00:09:23,519
detect this um in the new circle that

272
00:09:22,080 --> 00:09:26,000
we're arranging on the other side

273
00:09:23,519 --> 00:09:27,760
you'll see that d3 switches to zero and

274
00:09:26,000 --> 00:09:29,760
then we'll recalculate starting with the

275
00:09:27,760 --> 00:09:32,720
first parity circle

276
00:09:29,760 --> 00:09:34,080
nothing's changed there it's still an

277
00:09:32,720 --> 00:09:37,200
odd number

278
00:09:34,080 --> 00:09:38,720
something has changed there it's now

279
00:09:37,200 --> 00:09:40,800
supposed to be an even number of bits

280
00:09:38,720 --> 00:09:43,839
but it's not one bits but it's not

281
00:09:40,800 --> 00:09:45,680
and the same for particle three so

282
00:09:43,839 --> 00:09:47,440
we know that the offending bit is at the

283
00:09:45,680 --> 00:09:48,880
intersection of the second and third

284
00:09:47,440 --> 00:09:51,360
circle so therefore it's d3

285
00:09:48,880 --> 00:09:53,200
and so we can just switch flip that bit

286
00:09:51,360 --> 00:09:54,560
and correct the error

287
00:09:53,200 --> 00:09:57,120
so that's the basic way that hamming

288
00:09:54,560 --> 00:09:57,119
codes work

289
00:09:57,360 --> 00:10:02,160
so we use parity pretty heavily in rage

290
00:10:00,800 --> 00:10:04,399
some of you'll be familiar with raid

291
00:10:02,160 --> 00:10:05,439
levels you probably you probably haven't

292
00:10:04,399 --> 00:10:08,000
come across raid 2

293
00:10:05,440 --> 00:10:09,680
because nobody uses it and that's

294
00:10:08,000 --> 00:10:11,360
because it's really expensive

295
00:10:09,680 --> 00:10:13,279
but this is hamming codes and it happens

296
00:10:11,360 --> 00:10:15,360
at the bit level and so you can see that

297
00:10:13,279 --> 00:10:17,360
there's four data blocks and three

298
00:10:15,360 --> 00:10:18,480
parity date to bits sorry and three

299
00:10:17,360 --> 00:10:21,600
parity bits

300
00:10:18,480 --> 00:10:23,360
for um on uh there are stripes across

301
00:10:21,600 --> 00:10:25,440
these hard drives

302
00:10:23,360 --> 00:10:26,480
um so yeah i don't think anyone uses

303
00:10:25,440 --> 00:10:29,279
this

304
00:10:26,480 --> 00:10:30,480
um then you have obviously i'm sure all

305
00:10:29,279 --> 00:10:32,720
of you familiar with rate five

306
00:10:30,480 --> 00:10:34,160
raid four is similar to raid 5 there's

307
00:10:32,720 --> 00:10:35,760
the only difference is that rather than

308
00:10:34,160 --> 00:10:37,839
distributing the parity bits

309
00:10:35,760 --> 00:10:39,120
across the drives we put all the parity

310
00:10:37,839 --> 00:10:42,320
bits on one drive

311
00:10:39,120 --> 00:10:44,079
and that means that rights are slower

312
00:10:42,320 --> 00:10:45,680
with raid 4 since there's less data

313
00:10:44,079 --> 00:10:48,319
drives to write to you

314
00:10:45,680 --> 00:10:49,760
but since all the parity is written to

315
00:10:48,320 --> 00:10:53,920
the same disk

316
00:10:49,760 --> 00:10:54,880
um random reads are better so sorry so

317
00:10:53,920 --> 00:10:56,160
rights are slower

318
00:10:54,880 --> 00:10:57,519
because the parity has to be written to

319
00:10:56,160 --> 00:10:58,800
the same disk but random reads are

320
00:10:57,519 --> 00:10:59,519
better because there's less disk for you

321
00:10:58,800 --> 00:11:01,120
to look

322
00:10:59,519 --> 00:11:04,160
for because you have a dedicated parity

323
00:11:01,120 --> 00:11:08,160
disk so

324
00:11:04,160 --> 00:11:09,680
that's that's raid 4. this is raid 5 and

325
00:11:08,160 --> 00:11:11,439
you're all familiar with raid 5 i guess

326
00:11:09,680 --> 00:11:12,560
the way it works is it runs an exclusive

327
00:11:11,440 --> 00:11:16,079
ore on the block

328
00:11:12,560 --> 00:11:18,560
so for every two blocks that we write we

329
00:11:16,079 --> 00:11:21,760
want an exclusive or and then we write

330
00:11:18,560 --> 00:11:22,640
the result as a third block and so green

331
00:11:21,760 --> 00:11:25,279
here is the

332
00:11:22,640 --> 00:11:27,760
is the parity data so if i keep doing

333
00:11:25,279 --> 00:11:30,640
that and obviously on different drives

334
00:11:27,760 --> 00:11:32,399
i end up with a whole bunch of data now

335
00:11:30,640 --> 00:11:34,560
if i lose one of the drives

336
00:11:32,399 --> 00:11:36,079
i can recalculate it it's just it's

337
00:11:34,560 --> 00:11:36,800
really simple just run exclusive or

338
00:11:36,079 --> 00:11:40,800
again

339
00:11:36,800 --> 00:11:43,920
on the other two data blocks and i can

340
00:11:40,800 --> 00:11:46,479
regenerate that drive so that's how raid

341
00:11:43,920 --> 00:11:46,479
5 works

342
00:11:48,079 --> 00:11:51,199
so that's hamming codes that was in the

343
00:11:49,440 --> 00:11:53,440
50s then these gays

344
00:11:51,200 --> 00:11:55,120
guys came along in the 60s and they

345
00:11:53,440 --> 00:11:58,079
changed everything

346
00:11:55,120 --> 00:11:59,680
gustav solomon and irving reed and these

347
00:11:58,079 --> 00:12:01,120
guys were staff members at the mit

348
00:11:59,680 --> 00:12:02,880
laboratory and

349
00:12:01,120 --> 00:12:04,160
10 years after hamming's paper they

350
00:12:02,880 --> 00:12:06,880
published a paper called

351
00:12:04,160 --> 00:12:07,920
polynomial codes over certain finite

352
00:12:06,880 --> 00:12:09,040
fields

353
00:12:07,920 --> 00:12:10,719
so i was reading up on this and i

354
00:12:09,040 --> 00:12:12,639
suddenly realized that this was getting

355
00:12:10,720 --> 00:12:14,480
really mathematically complicated

356
00:12:12,639 --> 00:12:16,480
um i'm not a mathematician i was out of

357
00:12:14,480 --> 00:12:17,279
my depth so as i always do when i'm out

358
00:12:16,480 --> 00:12:20,639
of my depth

359
00:12:17,279 --> 00:12:22,240
i um go into irc and ask a question

360
00:12:20,639 --> 00:12:24,480
so i did that i went looking for the

361
00:12:22,240 --> 00:12:26,480
right irc channel to think to ask in

362
00:12:24,480 --> 00:12:27,360
thinking that this would be helpful

363
00:12:26,480 --> 00:12:30,000
i knew there was a bunch of

364
00:12:27,360 --> 00:12:31,760
mathematicians on this channel so i just

365
00:12:30,000 --> 00:12:35,040
um i just asked you know can someone

366
00:12:31,760 --> 00:12:39,839
explain polynomial interpolation to me

367
00:12:35,040 --> 00:12:39,839
um this is the response that i got

368
00:12:55,680 --> 00:13:00,880
i don't know maybe some of you

369
00:12:56,800 --> 00:13:00,880
understand what that i i have no idea

370
00:13:01,519 --> 00:13:08,399
but yeah yeah i um i need to

371
00:13:04,880 --> 00:13:10,399
stop going to irc for as a as a resource

372
00:13:08,399 --> 00:13:12,000
um the main idea behind reid solomon

373
00:13:10,399 --> 00:13:14,959
does however revolve around

374
00:13:12,000 --> 00:13:16,560
this concept of agawa field uh galwa

375
00:13:14,959 --> 00:13:17,920
field is named after

376
00:13:16,560 --> 00:13:20,319
everest galwa who is a french

377
00:13:17,920 --> 00:13:21,040
mathematician and unlike our previous

378
00:13:20,320 --> 00:13:23,200
heroes

379
00:13:21,040 --> 00:13:24,959
had a much more troubled and interesting

380
00:13:23,200 --> 00:13:26,399
life in the sense that

381
00:13:24,959 --> 00:13:28,399
he got interested in math at the age of

382
00:13:26,399 --> 00:13:29,760
14. he published a number of papers by

383
00:13:28,399 --> 00:13:31,600
the age of 17

384
00:13:29,760 --> 00:13:33,360
of which one of them was about galway

385
00:13:31,600 --> 00:13:34,959
fields in galway theory

386
00:13:33,360 --> 00:13:37,279
and this was a year after he was ejected

387
00:13:34,959 --> 00:13:38,560
from university because his examiner

388
00:13:37,279 --> 00:13:40,160
couldn't follow his train of thought and

389
00:13:38,560 --> 00:13:41,839
was very confused

390
00:13:40,160 --> 00:13:44,079
he was politically active ended up in

391
00:13:41,839 --> 00:13:46,160
prison a number of times before he

392
00:13:44,079 --> 00:13:47,519
engaged in a duel to the death with an

393
00:13:46,160 --> 00:13:50,959
officer at the age of 20

394
00:13:47,519 --> 00:13:54,000
and died so not the most

395
00:13:50,959 --> 00:13:55,119
glamorous stories but yeah he did define

396
00:13:54,000 --> 00:13:56,639
this concept called the calva field

397
00:13:55,120 --> 00:13:58,959
which is basically

398
00:13:56,639 --> 00:14:00,240
a mathematical field a set of numbers

399
00:13:58,959 --> 00:14:01,199
which you can conduct mathematical

400
00:14:00,240 --> 00:14:03,360
operations on

401
00:14:01,199 --> 00:14:05,040
and a finite field or gallon field is

402
00:14:03,360 --> 00:14:07,680
one that is finite and is always the

403
00:14:05,040 --> 00:14:09,120
size of a prime number or prime power

404
00:14:07,680 --> 00:14:11,040
and these fields wrap around so you can

405
00:14:09,120 --> 00:14:12,560
conduct any operation

406
00:14:11,040 --> 00:14:15,680
on the values within the field and

407
00:14:12,560 --> 00:14:17,279
always get another value in the field

408
00:14:15,680 --> 00:14:19,279
and you do this you can just modulate

409
00:14:17,279 --> 00:14:20,320
the size of the field once you get your

410
00:14:19,279 --> 00:14:21,920
results so

411
00:14:20,320 --> 00:14:23,360
this can contain numbers it can contain

412
00:14:21,920 --> 00:14:26,240
polynomials and it can contain

413
00:14:23,360 --> 00:14:27,360
roots of polynomials and how does this

414
00:14:26,240 --> 00:14:28,880
relate to

415
00:14:27,360 --> 00:14:30,560
arranged coding and error correction

416
00:14:28,880 --> 00:14:33,199
well

417
00:14:30,560 --> 00:14:34,000
the idea is that using a gala field you

418
00:14:33,199 --> 00:14:38,160
can

419
00:14:34,000 --> 00:14:41,760
essentially plot any sequence of data

420
00:14:38,160 --> 00:14:41,760
as points on a polynomial graph

421
00:14:42,639 --> 00:14:46,959
and that's because the graph itself is

422
00:14:45,600 --> 00:14:48,399
representative of the gallow field that

423
00:14:46,959 --> 00:14:50,239
you're using

424
00:14:48,399 --> 00:14:51,360
once you've done that you can then find

425
00:14:50,240 --> 00:14:53,199
other points on the graph which you can

426
00:14:51,360 --> 00:14:53,839
use as parity data so the purple ones

427
00:14:53,199 --> 00:14:55,760
are

428
00:14:53,839 --> 00:14:57,839
other points that we found on the same

429
00:14:55,760 --> 00:14:59,760
graph and that's what we will use as our

430
00:14:57,839 --> 00:15:01,600
code charts and the idea is that you

431
00:14:59,760 --> 00:15:02,240
define a code and you use that on both

432
00:15:01,600 --> 00:15:04,079
sides

433
00:15:02,240 --> 00:15:06,000
to recover data and it's highly

434
00:15:04,079 --> 00:15:09,760
efficient but

435
00:15:06,000 --> 00:15:13,839
much more computationally expensive

436
00:15:09,760 --> 00:15:16,240
so here's an example k is the number of

437
00:15:13,839 --> 00:15:17,279
data charts that we have m is the number

438
00:15:16,240 --> 00:15:19,440
of code charts

439
00:15:17,279 --> 00:15:21,040
on the left we have what's called a

440
00:15:19,440 --> 00:15:22,800
distribution or generator matrix

441
00:15:21,040 --> 00:15:24,079
which is made up of an identity matrix

442
00:15:22,800 --> 00:15:26,719
at the top

443
00:15:24,079 --> 00:15:27,439
which essentially is equivalent to one

444
00:15:26,720 --> 00:15:30,800
and then

445
00:15:27,440 --> 00:15:33,600
the bottom piece is the uh code charts

446
00:15:30,800 --> 00:15:34,000
which we we generate um so we add them

447
00:15:33,600 --> 00:15:36,160
together

448
00:15:34,000 --> 00:15:37,680
we multiply that by our data and we end

449
00:15:36,160 --> 00:15:41,360
up with a set of data

450
00:15:37,680 --> 00:15:45,599
and a set of parity

451
00:15:41,360 --> 00:15:48,560
blocks um so

452
00:15:45,600 --> 00:15:48,880
let's say we lose some of our data the

453
00:15:48,560 --> 00:15:52,560
bit

454
00:15:48,880 --> 00:15:53,439
in k we can replace those with c1 and c2

455
00:15:52,560 --> 00:15:56,079
which are

456
00:15:53,440 --> 00:15:58,079
what we end up calculating and we can

457
00:15:56,079 --> 00:15:59,519
multiply that by the inverse of the same

458
00:15:58,079 --> 00:16:01,359
generator matrix that we have

459
00:15:59,519 --> 00:16:03,120
and that will give us our data blocks

460
00:16:01,360 --> 00:16:05,440
back and obviously that's

461
00:16:03,120 --> 00:16:07,199
far more efficient than using something

462
00:16:05,440 --> 00:16:10,320
like

463
00:16:07,199 --> 00:16:10,319
uh the hamming codes

464
00:16:10,560 --> 00:16:14,399
so this is really really popular um it's

465
00:16:13,040 --> 00:16:15,360
one of the most popular error correction

466
00:16:14,399 --> 00:16:18,079
codes we use

467
00:16:15,360 --> 00:16:20,240
today and it's it's seen everywhere

468
00:16:18,079 --> 00:16:24,079
including cds dvds

469
00:16:20,240 --> 00:16:24,480
um you can it's using 2d barcodes as

470
00:16:24,079 --> 00:16:27,279
well

471
00:16:24,480 --> 00:16:28,959
so um any any 2d barcode that you

472
00:16:27,279 --> 00:16:30,800
scratch or is damaged

473
00:16:28,959 --> 00:16:33,758
can still scan because it's using read

474
00:16:30,800 --> 00:16:35,680
solomon to recover from

475
00:16:33,759 --> 00:16:37,279
that damage and it's also used for

476
00:16:35,680 --> 00:16:39,519
generating qr codes

477
00:16:37,279 --> 00:16:42,560
so most implementations of raid 6 also

478
00:16:39,519 --> 00:16:42,560
use resolument as well

479
00:16:45,279 --> 00:16:51,519
so this image is taken from the

480
00:16:48,880 --> 00:16:52,560
rage coding docs and ceph and it's

481
00:16:51,519 --> 00:16:54,560
specifically for k

482
00:16:52,560 --> 00:16:56,239
equals three and m equals two so two

483
00:16:54,560 --> 00:16:57,199
parity charts for every three data

484
00:16:56,240 --> 00:17:00,160
charts

485
00:16:57,199 --> 00:17:01,439
so in ceph when you create a new pool um

486
00:17:00,160 --> 00:17:02,399
you specify if you want it to be range

487
00:17:01,440 --> 00:17:04,319
coded or not

488
00:17:02,399 --> 00:17:06,880
and also which rage coding algorithm you

489
00:17:04,319 --> 00:17:08,639
want to use uh ceph has a plugable

490
00:17:06,880 --> 00:17:10,000
architecture for radio codes so you can

491
00:17:08,640 --> 00:17:11,120
specify which code you want to use on a

492
00:17:10,000 --> 00:17:14,079
pull by pull basis

493
00:17:11,119 --> 00:17:15,918
once you've chosen an erasure code you

494
00:17:14,079 --> 00:17:16,799
can't then change it for that pool

495
00:17:15,919 --> 00:17:18,079
because you'd have to obviously

496
00:17:16,799 --> 00:17:21,119
recalculate everything

497
00:17:18,079 --> 00:17:22,720
so um you need to make sure the only way

498
00:17:21,119 --> 00:17:23,438
to do the only way to get around that

499
00:17:22,720 --> 00:17:24,959
you'd have to

500
00:17:23,439 --> 00:17:26,160
create another pool and migrate so if

501
00:17:24,959 --> 00:17:27,039
you're going to use an erasure code to

502
00:17:26,160 --> 00:17:29,280
call and product

503
00:17:27,039 --> 00:17:31,039
pool in production you want to be sure

504
00:17:29,280 --> 00:17:33,520
that you've chosen the razor code that

505
00:17:31,039 --> 00:17:35,200
best suits your workload

506
00:17:33,520 --> 00:17:37,120
almost all of the razer coding plugins

507
00:17:35,200 --> 00:17:38,320
within ceph rely on some form of read

508
00:17:37,120 --> 00:17:39,760
solomon

509
00:17:38,320 --> 00:17:41,280
there's a number of different varieties

510
00:17:39,760 --> 00:17:42,559
though with different strengths and

511
00:17:41,280 --> 00:17:44,960
weaknesses

512
00:17:42,559 --> 00:17:46,160
the main plugin that's used in staff is

513
00:17:44,960 --> 00:17:48,799
called j-razer

514
00:17:46,160 --> 00:17:49,760
and that has both uh vandermonde and

515
00:17:48,799 --> 00:17:52,559
couchy versions

516
00:17:49,760 --> 00:17:53,120
those are both versions of um reid

517
00:17:52,559 --> 00:17:56,399
solomon

518
00:17:53,120 --> 00:18:00,479
and they they differ just in how you

519
00:17:56,400 --> 00:18:00,480
generate the matrix at the beginning

520
00:18:00,799 --> 00:18:04,559
there's also some more recent

521
00:18:02,160 --> 00:18:06,080
propositions there's one called the

522
00:18:04,559 --> 00:18:08,240
shingle the rage code

523
00:18:06,080 --> 00:18:09,600
and that aims to be more configurable

524
00:18:08,240 --> 00:18:11,200
and more efficient

525
00:18:09,600 --> 00:18:12,879
there's also an implementation called

526
00:18:11,200 --> 00:18:14,799
clay which focuses on reducing network

527
00:18:12,880 --> 00:18:16,240
bandwidth and there's one called locally

528
00:18:14,799 --> 00:18:19,360
repairable codes

529
00:18:16,240 --> 00:18:19,679
which specifies a another variable

530
00:18:19,360 --> 00:18:22,080
called

531
00:18:19,679 --> 00:18:25,039
l so you can say i want my parity blocks

532
00:18:22,080 --> 00:18:28,240
to be stored in a specific geo location

533
00:18:25,039 --> 00:18:31,120
which helps us recover

534
00:18:28,240 --> 00:18:32,000
from arranging rage coding damage but

535
00:18:31,120 --> 00:18:33,520
without

536
00:18:32,000 --> 00:18:36,080
straining the network too much if we

537
00:18:33,520 --> 00:18:38,400
have a geo-replicated multi-site staff

538
00:18:36,080 --> 00:18:38,399
cluster

539
00:18:39,440 --> 00:18:43,280
so yeah the key thing to remember is

540
00:18:42,080 --> 00:18:47,360
choose the right numbers for k

541
00:18:43,280 --> 00:18:49,440
m uh obviously depending on how much

542
00:18:47,360 --> 00:18:50,959
storage you want to uh use how much it's

543
00:18:49,440 --> 00:18:54,160
gonna cost you in storage

544
00:18:50,960 --> 00:18:55,280
and um also pick the right um arranged

545
00:18:54,160 --> 00:18:56,240
coding plugin once you've done some

546
00:18:55,280 --> 00:18:58,720
testing

547
00:18:56,240 --> 00:19:00,640
uh with your workload so you you you

548
00:18:58,720 --> 00:19:03,200
know that obviously it's a kind of more

549
00:19:00,640 --> 00:19:05,440
final choice

550
00:19:03,200 --> 00:19:06,240
so how does this relate to our work at

551
00:19:05,440 --> 00:19:08,080
soft iron

552
00:19:06,240 --> 00:19:09,440
well we're working on building staff

553
00:19:08,080 --> 00:19:10,639
appliances and there's lots of

554
00:19:09,440 --> 00:19:12,400
operations that we want to do in ceph

555
00:19:10,640 --> 00:19:14,799
which are computationally expensive

556
00:19:12,400 --> 00:19:16,559
compression rate coding and encryption

557
00:19:14,799 --> 00:19:18,000
are all examples of this

558
00:19:16,559 --> 00:19:19,600
so we're working on defining some of

559
00:19:18,000 --> 00:19:20,720
these algorithms in hardware so that we

560
00:19:19,600 --> 00:19:23,760
can use

561
00:19:20,720 --> 00:19:26,400
fpgas to do the heavy lifting for us and

562
00:19:23,760 --> 00:19:28,080
keep keep our cpu usage to just just

563
00:19:26,400 --> 00:19:31,120
seth

564
00:19:28,080 --> 00:19:39,840
so yeah that's that's my talk

565
00:19:31,120 --> 00:19:39,840
anyone have any questions

566
00:19:44,640 --> 00:19:48,160
no mathematicians in the room i guess

567
00:19:48,720 --> 00:19:55,679
i read that performance was

568
00:19:53,600 --> 00:19:59,199
their performance was really different

569
00:19:55,679 --> 00:20:02,320
between the k and m's you choose

570
00:19:59,200 --> 00:20:05,679
i read it should be multiple of two

571
00:20:02,320 --> 00:20:09,039
or maybe something can you explain

572
00:20:05,679 --> 00:20:11,360
why and which combinations

573
00:20:09,039 --> 00:20:12,400
um so i think the the most commonly uh

574
00:20:11,360 --> 00:20:15,039
so the question is

575
00:20:12,400 --> 00:20:16,720
what combinations of k m are best and

576
00:20:15,039 --> 00:20:19,760
how do they

577
00:20:16,720 --> 00:20:22,000
affect performance within ceph um so

578
00:20:19,760 --> 00:20:25,039
typically we see

579
00:20:22,000 --> 00:20:28,720
people using 6 k and

580
00:20:25,039 --> 00:20:31,280
3 for m or 9 and 4.

581
00:20:28,720 --> 00:20:32,960
those are the most commonly used ones

582
00:20:31,280 --> 00:20:35,360
we're only implementing

583
00:20:32,960 --> 00:20:36,400
a few different combinations on our

584
00:20:35,360 --> 00:20:39,120
fpgas

585
00:20:36,400 --> 00:20:40,240
for that exact reason because each one

586
00:20:39,120 --> 00:20:41,039
is going to be different how you define

587
00:20:40,240 --> 00:20:42,480
it in hardware

588
00:20:41,039 --> 00:20:44,320
so i think there's a standard set that

589
00:20:42,480 --> 00:20:47,600
are used and

590
00:20:44,320 --> 00:20:49,439
yes if you try and do it with less

591
00:20:47,600 --> 00:20:50,559
m then you're going to have to do it's

592
00:20:49,440 --> 00:20:51,440
going to be much more expensive to

593
00:20:50,559 --> 00:20:53,280
calculate

594
00:20:51,440 --> 00:20:54,799
than the number of m as a proportion so

595
00:20:53,280 --> 00:21:02,720
you want to use a ratio of about three

596
00:20:54,799 --> 00:21:04,799
to one i think

597
00:21:02,720 --> 00:21:06,320
how does the distributed nature of sap

598
00:21:04,799 --> 00:21:09,440
affect the acceleration

599
00:21:06,320 --> 00:21:12,879
well i i imagine there's network latency

600
00:21:09,440 --> 00:21:16,320
yes there is network latency um

601
00:21:12,880 --> 00:21:17,840
so there is heavy network latency in

602
00:21:16,320 --> 00:21:19,520
staff and that means that

603
00:21:17,840 --> 00:21:21,199
uh oh so the question is how does it

604
00:21:19,520 --> 00:21:24,000
affect um

605
00:21:21,200 --> 00:21:25,679
how does the distributed nature of ceph

606
00:21:24,000 --> 00:21:29,120
affect

607
00:21:25,679 --> 00:21:31,600
acceleration so there is network latency

608
00:21:29,120 --> 00:21:32,559
in ceph and that means that in some

609
00:21:31,600 --> 00:21:35,918
cases

610
00:21:32,559 --> 00:21:37,600
the the cost of going to recover the

611
00:21:35,919 --> 00:21:42,080
data

612
00:21:37,600 --> 00:21:44,480
in time might be still far less than

613
00:21:42,080 --> 00:21:45,600
the the expense of doing the replication

614
00:21:44,480 --> 00:21:47,760
of the network anyway

615
00:21:45,600 --> 00:21:49,520
so you kind of have to have a bit of a

616
00:21:47,760 --> 00:21:52,480
cost balance and figure out

617
00:21:49,520 --> 00:21:53,440
in which cases it might be worth not

618
00:21:52,480 --> 00:21:54,960
accelerating

619
00:21:53,440 --> 00:21:57,360
the process in which cases it might be

620
00:21:54,960 --> 00:21:58,960
worth accelerating so

621
00:21:57,360 --> 00:22:00,719
it's it's a trade-off and i think in

622
00:21:58,960 --> 00:22:02,320
some cases it is some cases it isn't

623
00:22:00,720 --> 00:22:05,760
and that's a very important factor in

624
00:22:02,320 --> 00:22:05,760
deciding whether or not to accelerate

625
00:22:06,159 --> 00:22:12,880
does that answer your question yes cool

626
00:22:11,919 --> 00:22:26,159
okay

627
00:22:12,880 --> 00:22:26,159
well thank you very much

