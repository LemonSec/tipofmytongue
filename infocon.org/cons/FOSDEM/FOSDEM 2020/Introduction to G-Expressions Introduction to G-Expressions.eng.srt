1
00:00:05,040 --> 00:00:08,559
thank you all for coming

2
00:00:06,799 --> 00:00:10,000
uh i know that it's a bit rainy so i

3
00:00:08,559 --> 00:00:11,440
appreciate you taking the time to come

4
00:00:10,000 --> 00:00:14,879
all the way out this building

5
00:00:11,440 --> 00:00:17,039
off to the side my name is chris marusic

6
00:00:14,880 --> 00:00:18,960
and i'm here to talk about g expressions

7
00:00:17,039 --> 00:00:19,279
i think some of you might be familiar

8
00:00:18,960 --> 00:00:20,800
with

9
00:00:19,279 --> 00:00:22,480
s expressions can i get a quick show of

10
00:00:20,800 --> 00:00:23,199
hands to see who knows what an s

11
00:00:22,480 --> 00:00:27,119
expression

12
00:00:23,199 --> 00:00:31,840
is okay so most of you most of you know

13
00:00:27,119 --> 00:00:31,840
um we'll talk about it in a moment

14
00:00:33,520 --> 00:00:36,160
first i want you to know that this

15
00:00:34,719 --> 00:00:38,559
presentation's free for you to take and

16
00:00:36,160 --> 00:00:39,919
modify and copy however you like

17
00:00:38,559 --> 00:00:41,440
i like to let people know that so they

18
00:00:39,920 --> 00:00:42,719
can remix it and use it elsewhere if

19
00:00:41,440 --> 00:00:45,360
they want

20
00:00:42,719 --> 00:00:46,239
so i am again chris marusich and i came

21
00:00:45,360 --> 00:00:47,680
from seattle

22
00:00:46,239 --> 00:00:50,000
where i do software development

23
00:00:47,680 --> 00:00:52,879
professionally um

24
00:00:50,000 --> 00:00:54,320
i support free software i uh try to

25
00:00:52,879 --> 00:00:56,399
contribute in my spare time

26
00:00:54,320 --> 00:00:58,320
participate in the new geeks project off

27
00:00:56,399 --> 00:01:00,480
and on over the last few years

28
00:00:58,320 --> 00:01:01,359
and everything that i say here is my own

29
00:01:00,480 --> 00:01:02,959
opinion so

30
00:01:01,359 --> 00:01:05,840
it doesn't necessarily represent the

31
00:01:02,960 --> 00:01:05,840
opinion of my employer

32
00:01:06,000 --> 00:01:09,600
to understand g expressions i think it's

33
00:01:08,240 --> 00:01:11,039
first necessary to talk a little bit

34
00:01:09,600 --> 00:01:12,000
about what geeks does so i'm going to

35
00:01:11,040 --> 00:01:13,680
give a very brief review

36
00:01:12,000 --> 00:01:15,520
but it won't be as in-depth as some of

37
00:01:13,680 --> 00:01:17,840
the other talks you might have seen

38
00:01:15,520 --> 00:01:19,840
elsewhere at fosdem geeks is about

39
00:01:17,840 --> 00:01:22,880
functional software deployment

40
00:01:19,840 --> 00:01:24,880
and the reason that code staging matters

41
00:01:22,880 --> 00:01:27,679
will become clear as we talk about it

42
00:01:24,880 --> 00:01:28,960
so in geeks it's about building software

43
00:01:27,680 --> 00:01:30,560
composing it together

44
00:01:28,960 --> 00:01:32,559
and deploying it from one machine to

45
00:01:30,560 --> 00:01:33,680
another that sort of thing it's also a

46
00:01:32,560 --> 00:01:36,000
distribution

47
00:01:33,680 --> 00:01:37,600
that's built from scratch you can

48
00:01:36,000 --> 00:01:39,920
install packages remove packages

49
00:01:37,600 --> 00:01:42,640
and reconfigure your entire system it's

50
00:01:39,920 --> 00:01:44,320
great it provides transactional

51
00:01:42,640 --> 00:01:45,759
installation of the software and you can

52
00:01:44,320 --> 00:01:47,679
roll back to previous versions of your

53
00:01:45,759 --> 00:01:49,840
system

54
00:01:47,680 --> 00:01:50,880
this is an example of what a package

55
00:01:49,840 --> 00:01:52,960
looks like

56
00:01:50,880 --> 00:01:54,240
in the scheme language specifically

57
00:01:52,960 --> 00:01:56,479
guile scheme

58
00:01:54,240 --> 00:01:57,679
a package is just a record and it has

59
00:01:56,479 --> 00:01:59,840
fields

60
00:01:57,680 --> 00:02:02,159
in particular one of those fields is the

61
00:01:59,840 --> 00:02:03,759
inputs which describes the other pieces

62
00:02:02,159 --> 00:02:06,399
of software that are required to build

63
00:02:03,759 --> 00:02:06,399
this package

64
00:02:07,600 --> 00:02:12,160
also an operating system is just a

65
00:02:09,598 --> 00:02:14,640
record it's a scheme object

66
00:02:12,160 --> 00:02:16,879
again it just has fields and this is

67
00:02:14,640 --> 00:02:19,200
manipulated by other mechanisms in geeks

68
00:02:16,879 --> 00:02:21,440
to instantiate the operating system

69
00:02:19,200 --> 00:02:22,879
we define everything including the users

70
00:02:21,440 --> 00:02:24,480
and the services like there's an open

71
00:02:22,879 --> 00:02:26,079
ssh service running here on port number

72
00:02:24,480 --> 00:02:28,160
222

73
00:02:26,080 --> 00:02:31,440
all of it is declaratively described in

74
00:02:28,160 --> 00:02:32,879
a single file which is quite nice

75
00:02:31,440 --> 00:02:35,519
so i mentioned that geeks follows this

76
00:02:32,879 --> 00:02:37,440
functional model but what is that

77
00:02:35,519 --> 00:02:38,800
the functional model is basically the

78
00:02:37,440 --> 00:02:40,720
idea that you can treat building

79
00:02:38,800 --> 00:02:42,560
software as a function

80
00:02:40,720 --> 00:02:44,640
there are many ways to define a function

81
00:02:42,560 --> 00:02:46,000
and this is one particular way that will

82
00:02:44,640 --> 00:02:47,760
work for us

83
00:02:46,000 --> 00:02:49,519
anything that takes some inputs and

84
00:02:47,760 --> 00:02:51,518
spits out an output

85
00:02:49,519 --> 00:02:53,440
can be thought of as a function right so

86
00:02:51,519 --> 00:02:54,959
in mathematics it might be a function of

87
00:02:53,440 --> 00:02:56,959
numbers

88
00:02:54,959 --> 00:02:59,280
you can go outside of mathematics and

89
00:02:56,959 --> 00:03:02,000
have a function consisting of words

90
00:02:59,280 --> 00:03:03,599
or you can think about software and

91
00:03:02,000 --> 00:03:05,040
think about the process of building for

92
00:03:03,599 --> 00:03:07,599
example gnu hello

93
00:03:05,040 --> 00:03:08,400
as a function where the inputs are the

94
00:03:07,599 --> 00:03:10,799
compiler

95
00:03:08,400 --> 00:03:12,720
the libraries the source code the

96
00:03:10,800 --> 00:03:14,959
function itself is the usual procedure

97
00:03:12,720 --> 00:03:17,200
of configure make make install

98
00:03:14,959 --> 00:03:19,519
and the output is the program that you

99
00:03:17,200 --> 00:03:21,518
can run you knew hello

100
00:03:19,519 --> 00:03:23,440
so thinking about software as building

101
00:03:21,519 --> 00:03:25,920
um executing a function

102
00:03:23,440 --> 00:03:27,040
turns out to be quite useful the output

103
00:03:25,920 --> 00:03:28,640
of this function

104
00:03:27,040 --> 00:03:30,079
is not just thrown randomly into the

105
00:03:28,640 --> 00:03:32,159
file system

106
00:03:30,080 --> 00:03:33,599
as it would be in some other build

107
00:03:32,159 --> 00:03:35,200
systems but

108
00:03:33,599 --> 00:03:36,879
we store it in a place called the store

109
00:03:35,200 --> 00:03:40,238
which is at slash new

110
00:03:36,879 --> 00:03:41,518
store and we address it by the hash of

111
00:03:40,239 --> 00:03:44,080
all of its inputs

112
00:03:41,519 --> 00:03:45,680
so what this means is that if i build

113
00:03:44,080 --> 00:03:48,879
the new hello with the same

114
00:03:45,680 --> 00:03:51,760
libraries that i used before i will get

115
00:03:48,879 --> 00:03:53,439
the same output path and if i build it

116
00:03:51,760 --> 00:03:55,920
with a different set of inputs

117
00:03:53,439 --> 00:03:57,519
like a different version of libsy then i

118
00:03:55,920 --> 00:03:59,679
would get a different output path

119
00:03:57,519 --> 00:04:00,959
and these two different versions of new

120
00:03:59,680 --> 00:04:04,319
hello will not conflict

121
00:04:00,959 --> 00:04:05,840
when i install them this enables a whole

122
00:04:04,319 --> 00:04:07,839
bunch of really neat features that i'm

123
00:04:05,840 --> 00:04:09,280
not going to go into detail

124
00:04:07,840 --> 00:04:10,879
but at the very least you can see how

125
00:04:09,280 --> 00:04:12,080
this allows multiple versions to exist

126
00:04:10,879 --> 00:04:14,159
on the system

127
00:04:12,080 --> 00:04:16,560
and their dependencies also follow this

128
00:04:14,159 --> 00:04:18,478
so libc itself is also addressed by its

129
00:04:16,560 --> 00:04:19,918
hash of all of its inputs in the store

130
00:04:18,478 --> 00:04:21,519
so if these two different versions of

131
00:04:19,918 --> 00:04:23,359
google hello happen to use label c

132
00:04:21,519 --> 00:04:25,120
they will share that exact same version

133
00:04:23,360 --> 00:04:25,840
you get deduplication of dependencies

134
00:04:25,120 --> 00:04:29,840
automatically

135
00:04:25,840 --> 00:04:32,320
it's very nice at a high level

136
00:04:29,840 --> 00:04:33,359
when geeks build software we start with

137
00:04:32,320 --> 00:04:35,360
guile scheme

138
00:04:33,360 --> 00:04:36,720
which is the package definition again

139
00:04:35,360 --> 00:04:39,919
this is just a

140
00:04:36,720 --> 00:04:42,800
dial scheme object right a variable

141
00:04:39,919 --> 00:04:43,440
called glutter clutter gst and it

142
00:04:42,800 --> 00:04:45,040
contains

143
00:04:43,440 --> 00:04:46,639
an object that you can manipulate using

144
00:04:45,040 --> 00:04:48,479
scheme code

145
00:04:46,639 --> 00:04:49,759
that gets converted into a lower level

146
00:04:48,479 --> 00:04:51,120
representation which we call a

147
00:04:49,759 --> 00:04:52,880
derivation

148
00:04:51,120 --> 00:04:54,320
and then we ask the demon the geeks

149
00:04:52,880 --> 00:04:56,719
demon to

150
00:04:54,320 --> 00:04:58,320
execute that derivation so derivation is

151
00:04:56,720 --> 00:05:01,199
like a package in that it has

152
00:04:58,320 --> 00:05:02,080
inputs which are required to build it as

153
00:05:01,199 --> 00:05:04,400
an output

154
00:05:02,080 --> 00:05:06,320
which is the built product and it

155
00:05:04,400 --> 00:05:07,359
exactly specifies the steps that need to

156
00:05:06,320 --> 00:05:09,360
be taken to build it

157
00:05:07,360 --> 00:05:10,880
like make and make install the

158
00:05:09,360 --> 00:05:12,240
difference between this and a package is

159
00:05:10,880 --> 00:05:13,600
mainly that

160
00:05:12,240 --> 00:05:14,960
there are other factors such as the

161
00:05:13,600 --> 00:05:15,600
platform for which you're building the

162
00:05:14,960 --> 00:05:19,039
package

163
00:05:15,600 --> 00:05:19,680
which go into determining the output

164
00:05:19,039 --> 00:05:21,199
hash

165
00:05:19,680 --> 00:05:22,880
so if i take that package and build it

166
00:05:21,199 --> 00:05:24,880
on an arm machine i'll get a different

167
00:05:22,880 --> 00:05:26,320
output path than if i build it on an x86

168
00:05:24,880 --> 00:05:27,440
machine

169
00:05:26,320 --> 00:05:28,960
so derivation is a low-level

170
00:05:27,440 --> 00:05:30,080
representation of a package we asked the

171
00:05:28,960 --> 00:05:33,039
dm to build it

172
00:05:30,080 --> 00:05:34,560
and this executes the build in a tightly

173
00:05:33,039 --> 00:05:36,719
isolated environment

174
00:05:34,560 --> 00:05:38,560
very much like a truth different name

175
00:05:36,720 --> 00:05:41,280
space unique uids

176
00:05:38,560 --> 00:05:42,080
and the code that drives the build is

177
00:05:41,280 --> 00:05:44,880
dial

178
00:05:42,080 --> 00:05:46,080
style scheme code i'm not showing the

179
00:05:44,880 --> 00:05:47,440
script here but

180
00:05:46,080 --> 00:05:49,199
this would be the build of one

181
00:05:47,440 --> 00:05:50,560
derivation this would be another

182
00:05:49,199 --> 00:05:51,199
derivation there are three derivations

183
00:05:50,560 --> 00:05:53,039
here right

184
00:05:51,199 --> 00:05:54,479
and they're all running make and some

185
00:05:53,039 --> 00:05:56,479
other things to build software

186
00:05:54,479 --> 00:05:57,758
and they're all being orchestrated by a

187
00:05:56,479 --> 00:06:01,280
guidel script

188
00:05:57,759 --> 00:06:04,479
and so the question is how you

189
00:06:01,280 --> 00:06:06,880
stage that code into the build side to

190
00:06:04,479 --> 00:06:08,479
run that code when they finish building

191
00:06:06,880 --> 00:06:11,199
they'll store their output in the store

192
00:06:08,479 --> 00:06:12,880
like i mentioned earlier

193
00:06:11,199 --> 00:06:14,880
and generally we speak of the host side

194
00:06:12,880 --> 00:06:17,759
code as being the code that lives

195
00:06:14,880 --> 00:06:19,680
up at the top outside the scope of the

196
00:06:17,759 --> 00:06:23,360
build container and the code that

197
00:06:19,680 --> 00:06:25,039
runs inside the build not container but

198
00:06:23,360 --> 00:06:27,840
the isolated build environment

199
00:06:25,039 --> 00:06:29,199
that we refer to as the build site code

200
00:06:27,840 --> 00:06:30,400
so now i want to talk about how you get

201
00:06:29,199 --> 00:06:32,479
the code from the host side to the build

202
00:06:30,400 --> 00:06:35,758
site how do you generate that script

203
00:06:32,479 --> 00:06:39,199
that drives the process of building

204
00:06:35,759 --> 00:06:41,199
clutter gst for example one way that you

205
00:06:39,199 --> 00:06:42,400
could do it is to use s expressions

206
00:06:41,199 --> 00:06:44,560
so a lot of you are familiar with s

207
00:06:42,400 --> 00:06:45,520
expressions um if there is anybody out

208
00:06:44,560 --> 00:06:46,800
there who is not

209
00:06:45,520 --> 00:06:48,560
perhaps the viewers perhaps somebody in

210
00:06:46,800 --> 00:06:52,319
the audience

211
00:06:48,560 --> 00:06:55,280
an s expression is essentially a list

212
00:06:52,319 --> 00:06:55,520
that can be evaluated by scheme or lisp

213
00:06:55,280 --> 00:06:57,758
or

214
00:06:55,520 --> 00:06:59,599
some similar language and the very

215
00:06:57,759 --> 00:07:03,039
wonderful thing about s-expressions

216
00:06:59,599 --> 00:07:05,120
is that they can represent data and code

217
00:07:03,039 --> 00:07:06,560
at the same time so a lot of people that

218
00:07:05,120 --> 00:07:07,919
like lisp like it because

219
00:07:06,560 --> 00:07:09,599
it has this property called homo

220
00:07:07,919 --> 00:07:10,080
iconicity and that is the fact that you

221
00:07:09,599 --> 00:07:12,800
can

222
00:07:10,080 --> 00:07:14,080
use code and data interchangeably so

223
00:07:12,800 --> 00:07:15,520
this allows you to create

224
00:07:14,080 --> 00:07:17,599
an expression like the one that you see

225
00:07:15,520 --> 00:07:19,039
here and bind it to a variable

226
00:07:17,599 --> 00:07:21,440
and then pass it around and evaluate it

227
00:07:19,039 --> 00:07:23,680
later also in scheme

228
00:07:21,440 --> 00:07:25,520
uh you have this you know quote mark

229
00:07:23,680 --> 00:07:26,639
right there at the top sorry didn't you

230
00:07:25,520 --> 00:07:28,960
do that

231
00:07:26,639 --> 00:07:30,000
right there and that is you know

232
00:07:28,960 --> 00:07:32,000
quotation it means i

233
00:07:30,000 --> 00:07:33,759
literally want this list this expression

234
00:07:32,000 --> 00:07:36,479
so that i can pass it around

235
00:07:33,759 --> 00:07:37,280
so once you've bound this expression to

236
00:07:36,479 --> 00:07:40,080
that variable

237
00:07:37,280 --> 00:07:41,840
you can pass it around and you want to

238
00:07:40,080 --> 00:07:44,400
get into the build side and basically

239
00:07:41,840 --> 00:07:44,960
create a sim link pointing to the output

240
00:07:44,400 --> 00:07:48,719
path

241
00:07:44,960 --> 00:07:50,159
for core utils but you can't just embed

242
00:07:48,720 --> 00:07:51,120
the output path from the beginning

243
00:07:50,160 --> 00:07:52,639
because

244
00:07:51,120 --> 00:07:54,160
that is not known until you build

245
00:07:52,639 --> 00:07:56,080
derivation

246
00:07:54,160 --> 00:07:57,199
in order to get that information on the

247
00:07:56,080 --> 00:07:58,878
build side

248
00:07:57,199 --> 00:08:00,720
with the translate the s expression in

249
00:07:58,879 --> 00:08:03,759
some fashion into a form that

250
00:08:00,720 --> 00:08:06,400
um evaluates it at build time so

251
00:08:03,759 --> 00:08:07,360
the way we do that here is instead of

252
00:08:06,400 --> 00:08:10,400
writing the strings

253
00:08:07,360 --> 00:08:12,400
we have essentially a

254
00:08:10,400 --> 00:08:14,080
dictionary right it's an a-list that

255
00:08:12,400 --> 00:08:16,400
contains uh the inputs

256
00:08:14,080 --> 00:08:18,159
and the associated value is the output

257
00:08:16,400 --> 00:08:20,960
path of core utils

258
00:08:18,160 --> 00:08:21,840
uh likewise the output variable here is

259
00:08:20,960 --> 00:08:24,080
just going to be

260
00:08:21,840 --> 00:08:25,679
a little it'll be arranged to be in a

261
00:08:24,080 --> 00:08:26,080
context where output refers to the

262
00:08:25,680 --> 00:08:28,960
output

263
00:08:26,080 --> 00:08:30,560
path so i take this build expression i

264
00:08:28,960 --> 00:08:31,520
pass it to a procedure that geeks

265
00:08:30,560 --> 00:08:34,880
provides

266
00:08:31,520 --> 00:08:36,799
and it promises that when i run this

267
00:08:34,880 --> 00:08:38,479
build expression on the build side

268
00:08:36,799 --> 00:08:40,799
it will be evaluated in an environment

269
00:08:38,479 --> 00:08:44,320
where this variable refers to

270
00:08:40,799 --> 00:08:46,000
something like that what goes into that

271
00:08:44,320 --> 00:08:46,880
right the build inputs is determined by

272
00:08:46,000 --> 00:08:48,640
a separate

273
00:08:46,880 --> 00:08:50,959
variable that i provide i have to

274
00:08:48,640 --> 00:08:54,000
specify that i want core utils

275
00:08:50,959 --> 00:08:55,760
in another a-list that i have to pass

276
00:08:54,000 --> 00:08:57,279
separately to the build expression to

277
00:08:55,760 --> 00:08:59,600
derivation procedure

278
00:08:57,279 --> 00:09:01,680
and geeks will then look at the inputs

279
00:08:59,600 --> 00:09:03,600
it will find a package called core utils

280
00:09:01,680 --> 00:09:06,479
it'll translate that into the output

281
00:09:03,600 --> 00:09:07,519
path and then it'll pass that value in

282
00:09:06,480 --> 00:09:09,120
the build inputs

283
00:09:07,519 --> 00:09:11,200
and that's how i can reference the

284
00:09:09,120 --> 00:09:14,320
output path here in

285
00:09:11,200 --> 00:09:17,519
my build side code so this works and

286
00:09:14,320 --> 00:09:19,040
it's pretty good but i have to manage

287
00:09:17,519 --> 00:09:20,959
the inputs manually

288
00:09:19,040 --> 00:09:22,560
and the build expression manually and

289
00:09:20,959 --> 00:09:23,839
they're separate and so it's possible

290
00:09:22,560 --> 00:09:25,920
that i might forget

291
00:09:23,839 --> 00:09:28,240
to specify some of my inputs and if i

292
00:09:25,920 --> 00:09:30,399
forget to update my build expression

293
00:09:28,240 --> 00:09:31,680
when i update my inputs the build

294
00:09:30,399 --> 00:09:32,800
expression will no longer work when i

295
00:09:31,680 --> 00:09:35,120
run it

296
00:09:32,800 --> 00:09:36,880
so it's a bit fragile in that i have to

297
00:09:35,120 --> 00:09:38,160
update the inputs and also the build

298
00:09:36,880 --> 00:09:39,439
expression i have to keep them in sync

299
00:09:38,160 --> 00:09:41,439
myself

300
00:09:39,440 --> 00:09:43,120
and if i have two build expressions that

301
00:09:41,440 --> 00:09:44,640
i want to compose somehow maybe i want

302
00:09:43,120 --> 00:09:46,240
to run one before the other

303
00:09:44,640 --> 00:09:48,000
there are two different lists of inputs

304
00:09:46,240 --> 00:09:49,920
that i have to manage and

305
00:09:48,000 --> 00:09:51,600
that increases the complexity it pushes

306
00:09:49,920 --> 00:09:53,120
this complexity onto the programmer

307
00:09:51,600 --> 00:09:55,200
it'd be nice if we didn't have to do

308
00:09:53,120 --> 00:09:57,040
that so a quick summary

309
00:09:55,200 --> 00:09:58,480
s expressions some benefits of using

310
00:09:57,040 --> 00:10:00,560
them is that they're familiar

311
00:09:58,480 --> 00:10:01,600
and also because the inputs are separate

312
00:10:00,560 --> 00:10:03,359
from the expression

313
00:10:01,600 --> 00:10:04,959
it's fairly easy to change the inputs

314
00:10:03,360 --> 00:10:06,560
without modifying the expression

315
00:10:04,959 --> 00:10:08,000
if i have a custom package that i want

316
00:10:06,560 --> 00:10:08,560
to use in place of the default core

317
00:10:08,000 --> 00:10:10,000
utils

318
00:10:08,560 --> 00:10:11,680
it's very straightforward you just

319
00:10:10,000 --> 00:10:12,640
update that value in the a list of

320
00:10:11,680 --> 00:10:14,959
inputs

321
00:10:12,640 --> 00:10:15,680
but the downsides of doing this is that

322
00:10:14,959 --> 00:10:18,079
because

323
00:10:15,680 --> 00:10:19,199
i have to manage the inputs manually on

324
00:10:18,079 --> 00:10:20,640
my own

325
00:10:19,200 --> 00:10:22,800
it pushes complexity onto me the

326
00:10:20,640 --> 00:10:23,600
programmer and it makes it more likely

327
00:10:22,800 --> 00:10:26,160
that i will

328
00:10:23,600 --> 00:10:27,519
forget to update both places and these

329
00:10:26,160 --> 00:10:30,719
these expressions become

330
00:10:27,519 --> 00:10:32,480
less composable g expressions are an

331
00:10:30,720 --> 00:10:35,200
attempt to make this better

332
00:10:32,480 --> 00:10:36,720
and the main intent of this is we want

333
00:10:35,200 --> 00:10:37,680
to get rid of those inputs so we don't

334
00:10:36,720 --> 00:10:41,040
have to keep track of them

335
00:10:37,680 --> 00:10:44,880
manually the way this is done is

336
00:10:41,040 --> 00:10:46,640
by introducing a gene expression

337
00:10:44,880 --> 00:10:48,959
and then introducing references to

338
00:10:46,640 --> 00:10:52,560
inputs that we would like via an un-gx

339
00:10:48,959 --> 00:10:53,920
form and so when i do this i un-gx core

340
00:10:52,560 --> 00:10:56,959
utils inside of

341
00:10:53,920 --> 00:10:59,920
the g expression geeks will remember

342
00:10:56,959 --> 00:11:00,959
that core utils is an input and this

343
00:10:59,920 --> 00:11:02,880
list of inputs

344
00:11:00,959 --> 00:11:04,319
for the build expression will be

345
00:11:02,880 --> 00:11:05,839
automatically associated with the g

346
00:11:04,320 --> 00:11:07,760
expression it will be carried along

347
00:11:05,839 --> 00:11:09,760
with the g expression and i don't have

348
00:11:07,760 --> 00:11:10,959
to keep a separate list up to date

349
00:11:09,760 --> 00:11:13,040
so i can just write this build

350
00:11:10,959 --> 00:11:14,239
expression pass it to g expression

351
00:11:13,040 --> 00:11:17,120
derivation

352
00:11:14,240 --> 00:11:18,160
and i will get the same basic effect

353
00:11:17,120 --> 00:11:19,920
that i wanted

354
00:11:18,160 --> 00:11:21,920
the core utils package will be

355
00:11:19,920 --> 00:11:24,479
translated into the output path

356
00:11:21,920 --> 00:11:26,240
and output is a special case that gets

357
00:11:24,480 --> 00:11:27,839
translated into code which

358
00:11:26,240 --> 00:11:29,360
accesses the output path via an

359
00:11:27,839 --> 00:11:31,760
environment variable which is

360
00:11:29,360 --> 00:11:33,600
always set in derivations that geeks

361
00:11:31,760 --> 00:11:35,680
builds

362
00:11:33,600 --> 00:11:37,040
it's a little tedious though to write dx

363
00:11:35,680 --> 00:11:40,000
and on gx so we

364
00:11:37,040 --> 00:11:41,599
like to shorthand that by introducing

365
00:11:40,000 --> 00:11:44,079
reader syntax

366
00:11:41,600 --> 00:11:45,440
hash tild for gx and hash dollar sign

367
00:11:44,079 --> 00:11:47,040
for ungx

368
00:11:45,440 --> 00:11:49,360
and you can see that when we do this it

369
00:11:47,040 --> 00:11:52,160
looks very much like quasi-quoted

370
00:11:49,360 --> 00:11:53,839
s-expressions um except that now the

371
00:11:52,160 --> 00:11:56,800
input core utils

372
00:11:53,839 --> 00:11:57,519
is automatically added to the list of

373
00:11:56,800 --> 00:11:59,760
inputs in the g

374
00:11:57,519 --> 00:12:00,880
expression and i don't have to manage it

375
00:11:59,760 --> 00:12:04,480
so this is quite nice

376
00:12:00,880 --> 00:12:06,240
because it makes g expressions harder to

377
00:12:04,480 --> 00:12:07,519
write incorrectly i can write a g

378
00:12:06,240 --> 00:12:08,000
expression and i don't have to maintain

379
00:12:07,519 --> 00:12:09,839
the list

380
00:12:08,000 --> 00:12:11,279
harder to make it fragile but they're

381
00:12:09,839 --> 00:12:13,760
also more composable

382
00:12:11,279 --> 00:12:16,079
um you can put not only packages into a

383
00:12:13,760 --> 00:12:18,720
g-expression via the on gx form

384
00:12:16,079 --> 00:12:19,199
you can also include other g expressions

385
00:12:18,720 --> 00:12:20,639
um

386
00:12:19,200 --> 00:12:22,959
or other high-level objects that we'll

387
00:12:20,639 --> 00:12:25,680
talk about in a little bit

388
00:12:22,959 --> 00:12:26,719
so g expressions also give you the

389
00:12:25,680 --> 00:12:30,079
ability to

390
00:12:26,720 --> 00:12:31,279
import modules like dial modules onto

391
00:12:30,079 --> 00:12:33,680
the build side

392
00:12:31,279 --> 00:12:34,639
by default um only the built-in modules

393
00:12:33,680 --> 00:12:36,880
are available

394
00:12:34,639 --> 00:12:37,760
and so if i run code like the one you

395
00:12:36,880 --> 00:12:40,000
see here

396
00:12:37,760 --> 00:12:41,200
it's not going to work geeks provides

397
00:12:40,000 --> 00:12:43,680
this helper

398
00:12:41,200 --> 00:12:44,560
module you know provides this procedure

399
00:12:43,680 --> 00:12:46,560
make their p

400
00:12:44,560 --> 00:12:47,920
and if i want to make my empty directory

401
00:12:46,560 --> 00:12:49,680
it's not going to work because that

402
00:12:47,920 --> 00:12:51,040
module is not available for importation

403
00:12:49,680 --> 00:12:53,839
on the build side

404
00:12:51,040 --> 00:12:55,920
but if i add a with imported modules

405
00:12:53,839 --> 00:12:58,079
form

406
00:12:55,920 --> 00:12:59,279
this will arrange to make that module

407
00:12:58,079 --> 00:13:03,120
available

408
00:12:59,279 --> 00:13:05,600
for importation on the build side so

409
00:13:03,120 --> 00:13:06,959
in this way modules that are not built

410
00:13:05,600 --> 00:13:08,880
into guile by default

411
00:13:06,959 --> 00:13:10,800
can be imported from the host side into

412
00:13:08,880 --> 00:13:11,920
the build side and geeks promises that

413
00:13:10,800 --> 00:13:15,519
it will

414
00:13:11,920 --> 00:13:17,120
set up the necessary arrangements to

415
00:13:15,519 --> 00:13:19,519
make that available for importation on

416
00:13:17,120 --> 00:13:21,279
the build side and this is how we end up

417
00:13:19,519 --> 00:13:24,160
using a lot of different libraries

418
00:13:21,279 --> 00:13:25,760
um in geeks on the build side so in

419
00:13:24,160 --> 00:13:26,639
summary some of the pros of using a g

420
00:13:25,760 --> 00:13:29,200
expression

421
00:13:26,639 --> 00:13:30,000
are that it manages your dependencies

422
00:13:29,200 --> 00:13:32,079
for you

423
00:13:30,000 --> 00:13:33,279
in your your build expression that

424
00:13:32,079 --> 00:13:35,839
you're passing around

425
00:13:33,279 --> 00:13:36,800
i no longer have to maintain a list of

426
00:13:35,839 --> 00:13:39,040
inputs

427
00:13:36,800 --> 00:13:40,479
that leads to less complex code and it

428
00:13:39,040 --> 00:13:41,760
makes the g expressions much more

429
00:13:40,480 --> 00:13:43,120
composable than

430
00:13:41,760 --> 00:13:45,199
it would be if you were using s

431
00:13:43,120 --> 00:13:47,680
expressions directly

432
00:13:45,199 --> 00:13:48,959
it does have some downsides for example

433
00:13:47,680 --> 00:13:51,519
the fact that the inputs

434
00:13:48,959 --> 00:13:52,239
are no longer separate it makes it much

435
00:13:51,519 --> 00:13:54,240
more difficult

436
00:13:52,240 --> 00:13:56,240
to dynamically modify those inputs once

437
00:13:54,240 --> 00:13:58,320
i've said i ungx core utils

438
00:13:56,240 --> 00:14:00,000
i get the output path for that exact

439
00:13:58,320 --> 00:14:01,360
version of core utils

440
00:14:00,000 --> 00:14:03,760
and if i want to change that to a custom

441
00:14:01,360 --> 00:14:06,000
version it's a bit more difficult

442
00:14:03,760 --> 00:14:07,839
in practice that can be a pro or a con

443
00:14:06,000 --> 00:14:09,680
depending on what situation you're in

444
00:14:07,839 --> 00:14:11,519
um the way that we use g expressions in

445
00:14:09,680 --> 00:14:13,040
the gnu project the new geeks project i

446
00:14:11,519 --> 00:14:16,800
should say

447
00:14:13,040 --> 00:14:18,240
it's generally a good thing

448
00:14:16,800 --> 00:14:19,839
so moving on i'd like to show you some

449
00:14:18,240 --> 00:14:21,199
examples of how we are actually using g

450
00:14:19,839 --> 00:14:23,839
expressions in our project

451
00:14:21,199 --> 00:14:24,240
um this is an example showing how we

452
00:14:23,839 --> 00:14:27,279
would

453
00:14:24,240 --> 00:14:29,440
manage a demon in gnu geeks

454
00:14:27,279 --> 00:14:30,959
we manage demons with the shepherd

455
00:14:29,440 --> 00:14:33,040
that's our init process

456
00:14:30,959 --> 00:14:34,719
and for any demon that you want to start

457
00:14:33,040 --> 00:14:35,279
and stop you have to create a shepherd

458
00:14:34,720 --> 00:14:37,760
service

459
00:14:35,279 --> 00:14:38,320
this again is just a record in scheme

460
00:14:37,760 --> 00:14:40,160
code

461
00:14:38,320 --> 00:14:42,160
that describes what to do there's a

462
00:14:40,160 --> 00:14:44,079
start procedure and a stop procedure

463
00:14:42,160 --> 00:14:45,920
actually these are fields and the value

464
00:14:44,079 --> 00:14:48,239
of the field is a g expression

465
00:14:45,920 --> 00:14:49,920
so here there's code which will invoke

466
00:14:48,240 --> 00:14:52,320
make fork exec constructor

467
00:14:49,920 --> 00:14:53,439
and it'll insert some command to start

468
00:14:52,320 --> 00:14:55,680
open ssh

469
00:14:53,440 --> 00:14:56,720
the open ssh command in turn is another

470
00:14:55,680 --> 00:14:59,599
g expression

471
00:14:56,720 --> 00:15:01,279
um which has some other un-gx forms and

472
00:14:59,600 --> 00:15:03,040
so on and so forth until eventually you

473
00:15:01,279 --> 00:15:04,240
get the openssh package

474
00:15:03,040 --> 00:15:05,920
and you get the output path for the

475
00:15:04,240 --> 00:15:07,519
package so in this way we're composing a

476
00:15:05,920 --> 00:15:09,199
lot of different expressions together

477
00:15:07,519 --> 00:15:10,800
and it would be very hard to do that if

478
00:15:09,199 --> 00:15:14,639
we were just using s expressions

479
00:15:10,800 --> 00:15:17,839
we had to manage the inputs separately

480
00:15:14,639 --> 00:15:20,880
another example is booting the system

481
00:15:17,839 --> 00:15:22,560
when we boot the system in geeks

482
00:15:20,880 --> 00:15:24,240
that's to say the distribution the new

483
00:15:22,560 --> 00:15:26,880
slash linux distribution that geeks

484
00:15:24,240 --> 00:15:28,240
provides we build the init ram disk also

485
00:15:26,880 --> 00:15:30,480
using guile

486
00:15:28,240 --> 00:15:33,120
and we use g expressions to stage the

487
00:15:30,480 --> 00:15:35,279
code that is necessary to build it

488
00:15:33,120 --> 00:15:36,800
sorry that is necessary to run it i'm

489
00:15:35,279 --> 00:15:38,720
not showing all the details right the

490
00:15:36,800 --> 00:15:39,359
file systems variable linux modules

491
00:15:38,720 --> 00:15:41,040
they're not

492
00:15:39,360 --> 00:15:42,959
the definitions are not shown but they

493
00:15:41,040 --> 00:15:44,160
are objects which can be un-gxed inside

494
00:15:42,959 --> 00:15:45,839
of a g-expression

495
00:15:44,160 --> 00:15:48,319
and an appropriate representation will

496
00:15:45,839 --> 00:15:51,120
be substituted in its place

497
00:15:48,320 --> 00:15:52,800
so for example the coder will expand to

498
00:15:51,120 --> 00:15:53,440
a directory that contains all of the

499
00:15:52,800 --> 00:15:55,839
modules

500
00:15:53,440 --> 00:15:55,839
right

501
00:15:56,800 --> 00:16:00,800
one more example when the system starts

502
00:15:59,440 --> 00:16:02,000
you generally have to do various

503
00:16:00,800 --> 00:16:05,519
bookkeeping tasks

504
00:16:02,000 --> 00:16:07,360
for example dhcp daemon likes to have

505
00:16:05,519 --> 00:16:09,440
its lease file exist before it will

506
00:16:07,360 --> 00:16:10,000
start so in order to create that lease

507
00:16:09,440 --> 00:16:11,519
file

508
00:16:10,000 --> 00:16:13,759
on a traditional system you might have a

509
00:16:11,519 --> 00:16:16,240
bash script that you know creates it

510
00:16:13,759 --> 00:16:18,160
but because we love google in the geeks

511
00:16:16,240 --> 00:16:21,600
project we do it with g expressions

512
00:16:18,160 --> 00:16:24,000
we stage the scheme code and

513
00:16:21,600 --> 00:16:24,880
again it's yeah okay five minutes and

514
00:16:24,000 --> 00:16:26,800
again you can see

515
00:16:24,880 --> 00:16:28,720
we're just using on gx all over the

516
00:16:26,800 --> 00:16:31,040
place getting package outputs

517
00:16:28,720 --> 00:16:32,320
appending that with uh the path to the

518
00:16:31,040 --> 00:16:35,199
actual program

519
00:16:32,320 --> 00:16:36,639
and this is how we run demons in new

520
00:16:35,199 --> 00:16:39,120
geeks it's how we make

521
00:16:36,639 --> 00:16:41,680
glue code to set up things like the

522
00:16:39,120 --> 00:16:42,959
leases file for dhcp daemon

523
00:16:41,680 --> 00:16:45,279
there are many other uses that i haven't

524
00:16:42,959 --> 00:16:48,319
talked about everything from

525
00:16:45,279 --> 00:16:49,279
running automated tests to deploying to

526
00:16:48,320 --> 00:16:50,880
other servers

527
00:16:49,279 --> 00:16:52,639
it's possible to remotely evaluate a

528
00:16:50,880 --> 00:16:54,000
g-expression and transfer all

529
00:16:52,639 --> 00:16:56,079
of the transitive closure of its

530
00:16:54,000 --> 00:16:57,839
dependencies again you don't have to

531
00:16:56,079 --> 00:17:01,120
manually manage that it just happens

532
00:16:57,839 --> 00:17:02,880
through the magic of g expressions

533
00:17:01,120 --> 00:17:04,880
i mentioned earlier that you can also

534
00:17:02,880 --> 00:17:09,119
insert other things besides packages

535
00:17:04,880 --> 00:17:10,640
in a g expression um one example of that

536
00:17:09,119 --> 00:17:12,879
i want to talk about but first i'm going

537
00:17:10,640 --> 00:17:16,400
to explain how we go from a package

538
00:17:12,880 --> 00:17:18,000
to an output oh ten minutes okay

539
00:17:16,400 --> 00:17:19,839
well we'll have more time for questions

540
00:17:18,000 --> 00:17:23,919
um so how do we go from

541
00:17:19,839 --> 00:17:23,918
core utils right to the output path

542
00:17:24,319 --> 00:17:27,839
generally speaking you start with a high

543
00:17:26,319 --> 00:17:29,520
level object like a package

544
00:17:27,839 --> 00:17:32,000
and we lowered it to some lower

545
00:17:29,520 --> 00:17:35,200
representation and then expand that into

546
00:17:32,000 --> 00:17:36,960
the output that gets replaced so

547
00:17:35,200 --> 00:17:38,720
concretely with the package there's a

548
00:17:36,960 --> 00:17:40,080
procedure um

549
00:17:38,720 --> 00:17:41,440
for the package compiler there's a

550
00:17:40,080 --> 00:17:43,120
package compiler that has a procedure

551
00:17:41,440 --> 00:17:45,440
called lower which will convert

552
00:17:43,120 --> 00:17:46,719
a package into a derivation which as i

553
00:17:45,440 --> 00:17:48,080
mentioned earlier is that lower level

554
00:17:46,720 --> 00:17:49,200
representation that describes exactly

555
00:17:48,080 --> 00:17:50,480
how to build it

556
00:17:49,200 --> 00:17:52,640
and then once you've got that lowered

557
00:17:50,480 --> 00:17:54,080
representation the derivation

558
00:17:52,640 --> 00:17:55,840
there's another procedure that is

559
00:17:54,080 --> 00:17:57,360
associated with the compiler which will

560
00:17:55,840 --> 00:17:59,120
expand that derivation

561
00:17:57,360 --> 00:18:00,479
in other words it'll just get the output

562
00:17:59,120 --> 00:18:02,320
path that has been calculated for the

563
00:18:00,480 --> 00:18:05,679
derivation

564
00:18:02,320 --> 00:18:08,480
so it's not just for packages but

565
00:18:05,679 --> 00:18:10,320
also if you want to for example get rid

566
00:18:08,480 --> 00:18:12,559
of this string append

567
00:18:10,320 --> 00:18:14,240
right we've got this code up here on the

568
00:18:12,559 --> 00:18:17,120
build side it expands to

569
00:18:14,240 --> 00:18:18,720
string append and then two strings um

570
00:18:17,120 --> 00:18:20,000
this works this is nice but if you want

571
00:18:18,720 --> 00:18:22,240
to avoid

572
00:18:20,000 --> 00:18:23,919
running string append on the build side

573
00:18:22,240 --> 00:18:24,480
it'd be kind of nice to just be able to

574
00:18:23,919 --> 00:18:26,840
say

575
00:18:24,480 --> 00:18:28,960
i just want to run you know bin hello

576
00:18:26,840 --> 00:18:31,360
right

577
00:18:28,960 --> 00:18:32,320
you can do that by using a so-called

578
00:18:31,360 --> 00:18:35,439
file append

579
00:18:32,320 --> 00:18:38,960
object and file append object

580
00:18:35,440 --> 00:18:41,679
is something that you give a base

581
00:18:38,960 --> 00:18:43,840
a package as a base and the string

582
00:18:41,679 --> 00:18:46,880
suffix that you'd like to append to it

583
00:18:43,840 --> 00:18:48,720
and it does the same thing that string

584
00:18:46,880 --> 00:18:51,760
append would do

585
00:18:48,720 --> 00:18:52,880
but when it's lowered to its replacement

586
00:18:51,760 --> 00:18:56,720
value

587
00:18:52,880 --> 00:18:58,480
um it will just result in this string

588
00:18:56,720 --> 00:19:00,000
so this is a very simple example but i

589
00:18:58,480 --> 00:19:02,080
hope it gives you the idea of

590
00:19:00,000 --> 00:19:03,039
how you can take anything that you want

591
00:19:02,080 --> 00:19:05,360
really and

592
00:19:03,039 --> 00:19:07,200
insert it into a g expression and get an

593
00:19:05,360 --> 00:19:08,799
appropriate replacement value

594
00:19:07,200 --> 00:19:11,200
another slightly more complicated

595
00:19:08,799 --> 00:19:12,799
example is if i want to run tor with a

596
00:19:11,200 --> 00:19:15,840
custom configuration

597
00:19:12,799 --> 00:19:18,320
maybe i'll use my file append object to

598
00:19:15,840 --> 00:19:19,918
get a replacement value that leads to

599
00:19:18,320 --> 00:19:21,600
tor and i'll also

600
00:19:19,919 --> 00:19:24,240
want to put a local file that i have

601
00:19:21,600 --> 00:19:27,520
containing my configuration

602
00:19:24,240 --> 00:19:29,200
as a file argument to tor i can do that

603
00:19:27,520 --> 00:19:31,200
with a local file object

604
00:19:29,200 --> 00:19:32,240
which is basically in the same spirit

605
00:19:31,200 --> 00:19:34,480
i'm just saying

606
00:19:32,240 --> 00:19:36,720
i want to take the contents of this file

607
00:19:34,480 --> 00:19:39,440
i'd like to put it in the store

608
00:19:36,720 --> 00:19:40,080
and then i'd like geeks to replace the

609
00:19:39,440 --> 00:19:42,400
uh

610
00:19:40,080 --> 00:19:43,439
reference with the path to that file in

611
00:19:42,400 --> 00:19:45,600
the store

612
00:19:43,440 --> 00:19:46,480
and you know since geeks is a functional

613
00:19:45,600 --> 00:19:47,918
package manager

614
00:19:46,480 --> 00:19:48,960
if i change the contents of this it

615
00:19:47,919 --> 00:19:50,799
would end up going to a different

616
00:19:48,960 --> 00:19:53,200
location with a different hash

617
00:19:50,799 --> 00:19:54,879
but the point that i'm trying to make is

618
00:19:53,200 --> 00:19:55,520
that you can put any kind of objects you

619
00:19:54,880 --> 00:19:58,080
want

620
00:19:55,520 --> 00:19:59,520
in an ungx form and as long as there is

621
00:19:58,080 --> 00:20:01,199
a gx compiler

622
00:19:59,520 --> 00:20:03,039
that knows how to convert that into a

623
00:20:01,200 --> 00:20:04,400
lower form you

624
00:20:03,039 --> 00:20:05,919
can put pretty much anything you want in

625
00:20:04,400 --> 00:20:06,320
and get any kind of appropriate value

626
00:20:05,919 --> 00:20:07,760
back

627
00:20:06,320 --> 00:20:10,320
it doesn't even really have to be

628
00:20:07,760 --> 00:20:13,360
associated with geeks's store

629
00:20:10,320 --> 00:20:16,080
you could imagine having something that

630
00:20:13,360 --> 00:20:17,039
i don't know gets a list of your

631
00:20:16,080 --> 00:20:18,559
favorite

632
00:20:17,039 --> 00:20:20,640
fruits and inserts them without

633
00:20:18,559 --> 00:20:24,080
consulting any kind of

634
00:20:20,640 --> 00:20:26,559
new geek specific stuff

635
00:20:24,080 --> 00:20:28,240
so g expressions are a way to tie this

636
00:20:26,559 --> 00:20:31,678
code staging mechanism

637
00:20:28,240 --> 00:20:34,080
together with deployment of software

638
00:20:31,679 --> 00:20:34,799
and in the geeks project we use it quite

639
00:20:34,080 --> 00:20:36,480
frequently

640
00:20:34,799 --> 00:20:38,480
to glue different pieces of the system

641
00:20:36,480 --> 00:20:41,520
together which involve

642
00:20:38,480 --> 00:20:43,200
using packages using configuration files

643
00:20:41,520 --> 00:20:44,799
and we want to compose lots of

644
00:20:43,200 --> 00:20:45,760
expressions together to create a larger

645
00:20:44,799 --> 00:20:47,520
program

646
00:20:45,760 --> 00:20:49,840
g expressions make it very easy for us

647
00:20:47,520 --> 00:20:49,840
to do that

648
00:20:49,919 --> 00:20:53,520
and in a lot of cases in that sort of

649
00:20:51,679 --> 00:20:54,080
problem domain it turns out that they

650
00:20:53,520 --> 00:20:56,000
are

651
00:20:54,080 --> 00:20:58,399
more ergonomic than using s expressions

652
00:20:56,000 --> 00:20:59,280
directly

653
00:20:58,400 --> 00:21:01,120
i don't want you get the wrong

654
00:20:59,280 --> 00:21:02,080
impression about g expressions i didn't

655
00:21:01,120 --> 00:21:04,320
invent them

656
00:21:02,080 --> 00:21:05,439
they were made by ludovic cortez who's

657
00:21:04,320 --> 00:21:08,000
also the guy that

658
00:21:05,440 --> 00:21:09,440
made new geeks basically and he has a

659
00:21:08,000 --> 00:21:10,880
great paper that describes in more

660
00:21:09,440 --> 00:21:12,240
detail some other wonderful features

661
00:21:10,880 --> 00:21:14,640
about g expressions

662
00:21:12,240 --> 00:21:16,240
for example they can be used in cross

663
00:21:14,640 --> 00:21:18,880
compilation contexts to

664
00:21:16,240 --> 00:21:20,240
access either natively compiled code or

665
00:21:18,880 --> 00:21:21,760
code that's compiled for the target

666
00:21:20,240 --> 00:21:24,799
architecture

667
00:21:21,760 --> 00:21:25,360
they can also be made to be hygienic so

668
00:21:24,799 --> 00:21:26,720
that

669
00:21:25,360 --> 00:21:28,479
in the same way you can have hygienic

670
00:21:26,720 --> 00:21:30,240
macros when you're manipulating this

671
00:21:28,480 --> 00:21:31,520
code with g expressions

672
00:21:30,240 --> 00:21:33,360
you can maintain a similar kind of

673
00:21:31,520 --> 00:21:34,720
hygiene unfortunately i don't have

674
00:21:33,360 --> 00:21:36,639
enough time to talk about that but

675
00:21:34,720 --> 00:21:38,559
if you are interested his paper has a

676
00:21:36,640 --> 00:21:40,400
lot of detail so i highly recommend that

677
00:21:38,559 --> 00:21:41,200
you read it if this sort of code staging

678
00:21:40,400 --> 00:21:43,440
mechanism

679
00:21:41,200 --> 00:21:44,559
is interesting to you the manual for

680
00:21:43,440 --> 00:21:45,360
geeks also has a lot of great

681
00:21:44,559 --> 00:21:46,799
information

682
00:21:45,360 --> 00:21:49,120
and the community in general is very

683
00:21:46,799 --> 00:21:50,720
welcoming so i invite you to

684
00:21:49,120 --> 00:21:52,639
get involved and learn a little more

685
00:21:50,720 --> 00:21:54,320
about it and talk with everybody

686
00:21:52,640 --> 00:21:56,000
so thank you for your time if you have

687
00:21:54,320 --> 00:22:00,879
any questions we have

688
00:21:56,000 --> 00:22:00,880
a few extra minutes so let's go ahead

689
00:22:00,960 --> 00:22:13,840
[Applause]

690
00:22:05,840 --> 00:22:13,840
yes in the back

691
00:22:24,840 --> 00:22:27,840
um

692
00:22:39,280 --> 00:22:42,559
declare which of these boundaries i want

693
00:22:41,440 --> 00:22:45,840
to record it and then

694
00:22:42,559 --> 00:22:45,840
use exactly the same models

695
00:22:49,440 --> 00:22:55,600
okay so i think the question is um

696
00:22:52,480 --> 00:22:57,440
back in maybe i can go back to the slide

697
00:22:55,600 --> 00:23:01,360
that we had perhaps

698
00:22:57,440 --> 00:23:06,000
where we were importing modules and

699
00:23:01,360 --> 00:23:06,000
it's this one right oh

700
00:23:07,200 --> 00:23:13,200
oh okay so forget about the screen then

701
00:23:11,440 --> 00:23:14,720
right you say i want to use these

702
00:23:13,200 --> 00:23:17,919
modules and then again i have to say

703
00:23:14,720 --> 00:23:19,760
with with that module do something right

704
00:23:17,919 --> 00:23:22,400
right so the question is why do i have

705
00:23:19,760 --> 00:23:24,480
to say with imported modules

706
00:23:22,400 --> 00:23:27,200
geeks build utils followed by code that

707
00:23:24,480 --> 00:23:27,520
then says use modules geeksbuild utils

708
00:23:27,200 --> 00:23:30,720
right

709
00:23:27,520 --> 00:23:33,679
yeah okay so the answer to that question

710
00:23:30,720 --> 00:23:35,520
is has mainly to do with the built-in

711
00:23:33,679 --> 00:23:40,000
modules for gnu guile

712
00:23:35,520 --> 00:23:42,080
because it's not necessary to

713
00:23:40,000 --> 00:23:44,720
make that available through any special

714
00:23:42,080 --> 00:23:47,360
means every derivation is run with guile

715
00:23:44,720 --> 00:23:49,440
an exact version of guile and if you're

716
00:23:47,360 --> 00:23:51,520
just using a built-in module

717
00:23:49,440 --> 00:23:53,840
you don't need to have any extra support

718
00:23:51,520 --> 00:23:55,760
for that you can just say use modules

719
00:23:53,840 --> 00:23:57,199
and then the built-in like ice9 rdlim or

720
00:23:55,760 --> 00:24:00,400
something and

721
00:23:57,200 --> 00:24:03,360
if you coupled use modules

722
00:24:00,400 --> 00:24:04,559
together with the with you with imported

723
00:24:03,360 --> 00:24:06,799
modules form

724
00:24:04,559 --> 00:24:07,918
then you would have to import that

725
00:24:06,799 --> 00:24:10,000
built-in module

726
00:24:07,919 --> 00:24:11,760
from the host side and that means that

727
00:24:10,000 --> 00:24:12,960
if i'm using one version of guile and

728
00:24:11,760 --> 00:24:13,600
you're using a different version of

729
00:24:12,960 --> 00:24:15,120
guile

730
00:24:13,600 --> 00:24:16,480
it starts to be possible that we would

731
00:24:15,120 --> 00:24:17,520
pull in different versions of the

732
00:24:16,480 --> 00:24:19,200
built-in modules

733
00:24:17,520 --> 00:24:21,520
which we're already there to begin with

734
00:24:19,200 --> 00:24:24,159
right so it's mainly to

735
00:24:21,520 --> 00:24:24,799
improve the reproducibility of the build

736
00:24:24,159 --> 00:24:26,640
and

737
00:24:24,799 --> 00:24:28,240
the fact that it's not necessary for

738
00:24:26,640 --> 00:24:30,799
built-in modules and we didn't want to

739
00:24:28,240 --> 00:24:30,799
couple those two

740
00:24:31,039 --> 00:24:35,520
i mean this together system with g

741
00:24:33,039 --> 00:24:37,279
expressions and the monadic subsystem it

742
00:24:35,520 --> 00:24:39,600
seems very powerful

743
00:24:37,279 --> 00:24:40,880
and yeah you said you can use it for in

744
00:24:39,600 --> 00:24:42,000
various different projects i mean

745
00:24:40,880 --> 00:24:44,080
something like this

746
00:24:42,000 --> 00:24:45,919
seemed like i needed that maybe two

747
00:24:44,080 --> 00:24:46,399
years ago and i started doing something

748
00:24:45,919 --> 00:24:48,400
kind of

749
00:24:46,400 --> 00:24:49,760
quite dynamic that depends on dynamic

750
00:24:48,400 --> 00:24:51,279
modules and then these models are

751
00:24:49,760 --> 00:24:53,919
getting expanded and

752
00:24:51,279 --> 00:24:55,120
they're also somehow well basically is

753
00:24:53,919 --> 00:24:58,240
it is there a

754
00:24:55,120 --> 00:24:58,239
way to maybe

755
00:24:58,400 --> 00:25:00,880
to take this

756
00:25:06,400 --> 00:25:11,440
right so right the question is um

757
00:25:09,760 --> 00:25:13,039
it seems like g expressions are kind of

758
00:25:11,440 --> 00:25:15,679
tightly coupled with geeks

759
00:25:13,039 --> 00:25:17,360
and is it possible to remove that from

760
00:25:15,679 --> 00:25:18,960
the context of geeks and use it in other

761
00:25:17,360 --> 00:25:20,320
situations where code staging might be

762
00:25:18,960 --> 00:25:22,320
useful

763
00:25:20,320 --> 00:25:24,158
right so i kind of mentioned this with

764
00:25:22,320 --> 00:25:26,240
that silly example earlier but

765
00:25:24,159 --> 00:25:27,520
but it is possible to do that it's just

766
00:25:26,240 --> 00:25:28,000
that right now there is a lot of geek

767
00:25:27,520 --> 00:25:29,120
specific

768
00:25:28,000 --> 00:25:31,200
stuff kind of polluting the

769
00:25:29,120 --> 00:25:33,520
implementation i guess and

770
00:25:31,200 --> 00:25:33,520
um

771
00:25:34,720 --> 00:25:38,080
right g expressions by themselves can be

772
00:25:36,720 --> 00:25:41,600
used without any

773
00:25:38,080 --> 00:25:43,600
geek specific stuff so you can write a g

774
00:25:41,600 --> 00:25:44,799
expression that is essentially just an s

775
00:25:43,600 --> 00:25:46,799
expression

776
00:25:44,799 --> 00:25:48,000
and doesn't reference any packages and

777
00:25:46,799 --> 00:25:49,039
you would be able to stage that

778
00:25:48,000 --> 00:25:52,240
expression

779
00:25:49,039 --> 00:25:55,840
um without using any geeks

780
00:25:52,240 --> 00:25:57,279
machinery to do so but and also if you

781
00:25:55,840 --> 00:25:58,158
have a high level object that's not a

782
00:25:57,279 --> 00:26:00,799
package

783
00:25:58,159 --> 00:26:01,360
and you don't need to let me rephrase

784
00:26:00,799 --> 00:26:03,120
this

785
00:26:01,360 --> 00:26:05,279
if there's a situation where you want to

786
00:26:03,120 --> 00:26:08,639
take high-level objects of some kind

787
00:26:05,279 --> 00:26:10,240
maybe a graph of objects not packages

788
00:26:08,640 --> 00:26:12,799
but something else

789
00:26:10,240 --> 00:26:14,480
and you want to insert a reference to

790
00:26:12,799 --> 00:26:15,918
some aspect of it right like you want to

791
00:26:14,480 --> 00:26:16,960
take some high level object and you want

792
00:26:15,919 --> 00:26:18,640
to replace you want it make

793
00:26:16,960 --> 00:26:20,480
code that's going to have a reference to

794
00:26:18,640 --> 00:26:22,240
that thing but you don't want the thing

795
00:26:20,480 --> 00:26:24,000
to be included directly you want to have

796
00:26:22,240 --> 00:26:26,480
some representation of it

797
00:26:24,000 --> 00:26:28,400
replaced in the code you can do that

798
00:26:26,480 --> 00:26:30,320
with g expression compilers

799
00:26:28,400 --> 00:26:31,760
and they don't have to be using the

800
00:26:30,320 --> 00:26:33,120
store it just happens to be the case

801
00:26:31,760 --> 00:26:36,080
that every problem in geeks

802
00:26:33,120 --> 00:26:37,279
involves the store so you could do this

803
00:26:36,080 --> 00:26:38,720
it would be

804
00:26:37,279 --> 00:26:40,640
it would not take too much work to take

805
00:26:38,720 --> 00:26:41,840
the code and move it out but as it's

806
00:26:40,640 --> 00:26:44,320
implemented right now

807
00:26:41,840 --> 00:26:45,199
um all of the apis that involve using g

808
00:26:44,320 --> 00:26:47,200
expressions like

809
00:26:45,200 --> 00:26:48,640
g expression to derivation assume that

810
00:26:47,200 --> 00:26:53,760
you're using the store

811
00:26:48,640 --> 00:26:55,360
yeah but did i kind of convey how

812
00:26:53,760 --> 00:26:57,120
there is also room for one other

813
00:26:55,360 --> 00:27:00,320
question yeah

814
00:26:57,120 --> 00:27:00,320
we can talk about it after yes

815
00:27:04,159 --> 00:27:08,159
how do they get combined so is there a

816
00:27:06,400 --> 00:27:09,840
specific way you can declare how they

817
00:27:08,159 --> 00:27:11,520
will be combined with each other

818
00:27:09,840 --> 00:27:12,959
so the question is how do the g

819
00:27:11,520 --> 00:27:14,960
expressions get combined

820
00:27:12,960 --> 00:27:16,720
and is there a way that you can specify

821
00:27:14,960 --> 00:27:19,760
how they are combined together

822
00:27:16,720 --> 00:27:20,320
um just like how you would un-gx a

823
00:27:19,760 --> 00:27:21,919
package

824
00:27:20,320 --> 00:27:24,158
in the middle of a g expression you

825
00:27:21,919 --> 00:27:26,159
would un-gx another g expression

826
00:27:24,159 --> 00:27:28,000
that's how you combine them together so

827
00:27:26,159 --> 00:27:29,679
if i have two g expressions and i want

828
00:27:28,000 --> 00:27:32,240
to run one before the other

829
00:27:29,679 --> 00:27:33,120
i would make a g expression a new one

830
00:27:32,240 --> 00:27:35,279
that says

831
00:27:33,120 --> 00:27:36,719
open parenthesis begin and then i would

832
00:27:35,279 --> 00:27:38,240
un-gx with the first one

833
00:27:36,720 --> 00:27:40,000
and then i would un-gx the second one

834
00:27:38,240 --> 00:27:43,279
right

835
00:27:40,000 --> 00:27:45,200
yeah you you'd you can just write

836
00:27:43,279 --> 00:27:46,559
code that looks like an s expression but

837
00:27:45,200 --> 00:27:48,799
you start it with the gx

838
00:27:46,559 --> 00:27:49,600
form and then whenever you want to put a

839
00:27:48,799 --> 00:27:52,320
gx

840
00:27:49,600 --> 00:27:54,158
in somewhere you un-gx with it and the

841
00:27:52,320 --> 00:27:55,678
idea is that it works basically the same

842
00:27:54,159 --> 00:27:57,120
as quasi quote and unquote

843
00:27:55,679 --> 00:27:59,200
if you're dealing with s expressions you

844
00:27:57,120 --> 00:28:00,399
could just insert a new s expression in

845
00:27:59,200 --> 00:28:00,960
the middle of a quasi quoted this

846
00:28:00,399 --> 00:28:03,120
expression

847
00:28:00,960 --> 00:28:06,480
using comma right and it's exactly the

848
00:28:03,120 --> 00:28:06,479
same with the g expression

849
00:28:06,640 --> 00:28:10,080
i think we're out of time is that right

850
00:28:08,240 --> 00:28:10,480
fielder yeah okay well thank you very

851
00:28:10,080 --> 00:28:17,840
much

852
00:28:10,480 --> 00:28:17,840
i appreciate your time

