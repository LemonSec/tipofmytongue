1
00:00:06,480 --> 00:00:09,040
okay

2
00:00:06,879 --> 00:00:10,399
uh hello everyone uh welcome to the

3
00:00:09,040 --> 00:00:12,319
decision

4
00:00:10,400 --> 00:00:14,160
uh my name is batwan i'm a high school

5
00:00:12,320 --> 00:00:16,480
student from turkey

6
00:00:14,160 --> 00:00:18,560
and in this session i'm going to talk

7
00:00:16,480 --> 00:00:21,359
about llvm and python

8
00:00:18,560 --> 00:00:21,680
uh this talk is specific to python and

9
00:00:21,359 --> 00:00:24,320
uh

10
00:00:21,680 --> 00:00:25,840
the approaches taken by uh python's jit

11
00:00:24,320 --> 00:00:27,599
compilers using elevm

12
00:00:25,840 --> 00:00:28,880
but there are some good points that can

13
00:00:27,599 --> 00:00:32,238
be used in

14
00:00:28,880 --> 00:00:35,360
compiling dynamic language style vmware

15
00:00:32,238 --> 00:00:38,399
uh so we are going to start with uh

16
00:00:35,360 --> 00:00:41,680
c python's workflow and pipeline uh

17
00:00:38,399 --> 00:00:44,079
you may see this irrelevant but uh most

18
00:00:41,680 --> 00:00:48,399
of the applications use

19
00:00:44,079 --> 00:00:51,520
this workflows pipes to

20
00:00:48,399 --> 00:00:53,760
generate ir ldmir and jit compile

21
00:00:51,520 --> 00:00:55,199
then we are going to see a dynamic

22
00:00:53,760 --> 00:00:58,640
nature of c python

23
00:00:55,199 --> 00:01:01,839
like why you shouldn't trust user code

24
00:00:58,640 --> 00:01:05,760
and why can't we can easily

25
00:01:01,840 --> 00:01:08,799
convert python to llvm or other

26
00:01:05,760 --> 00:01:09,200
representations then we are going to see

27
00:01:08,799 --> 00:01:12,400
some

28
00:01:09,200 --> 00:01:15,040
projects that are not currently

29
00:01:12,400 --> 00:01:16,080
under development and dead because of

30
00:01:15,040 --> 00:01:18,799
some reasons

31
00:01:16,080 --> 00:01:21,520
uh the first one is unladen swallow it's

32
00:01:18,799 --> 00:01:25,200
a google sponsored fork of c python

33
00:01:21,520 --> 00:01:25,200
uh which is

34
00:01:25,280 --> 00:01:29,360
which tried to bring llvm into python's

35
00:01:28,560 --> 00:01:31,520
core

36
00:01:29,360 --> 00:01:32,960
but then google lost its interest

37
00:01:31,520 --> 00:01:36,000
google's clients lost

38
00:01:32,960 --> 00:01:39,280
its interest so uh

39
00:01:36,000 --> 00:01:41,119
it's that then there is pipe to llvm and

40
00:01:39,280 --> 00:01:42,079
pile album pythagorean was an old

41
00:01:41,119 --> 00:01:44,640
project

42
00:01:42,079 --> 00:01:46,399
uh by indie developer and it is

43
00:01:44,640 --> 00:01:49,040
retrieved as pi alvian

44
00:01:46,399 --> 00:01:51,040
and the both are that right arm it's the

45
00:01:49,040 --> 00:01:53,920
edit compiler for python 2.

46
00:01:51,040 --> 00:01:55,360
and piston keystone is relatively new

47
00:01:53,920 --> 00:01:58,479
project

48
00:01:55,360 --> 00:01:59,840
it is sponsored by dropbox but then

49
00:01:58,479 --> 00:02:01,360
dropbox switched

50
00:01:59,840 --> 00:02:03,439
performance critical code to other

51
00:02:01,360 --> 00:02:06,640
languages such as go

52
00:02:03,439 --> 00:02:08,399
and it is also that there are some

53
00:02:06,640 --> 00:02:11,599
current projects like number

54
00:02:08,399 --> 00:02:15,360
uh number is a jit compiler for

55
00:02:11,599 --> 00:02:18,079
uh numpy python mathematical uh

56
00:02:15,360 --> 00:02:19,280
oriented code which uses llvm light at

57
00:02:18,080 --> 00:02:21,760
the back end

58
00:02:19,280 --> 00:02:22,800
and alvian knight is a python binding

59
00:02:21,760 --> 00:02:25,920
style lvm

60
00:02:22,800 --> 00:02:29,680
which offers a great api and

61
00:02:25,920 --> 00:02:32,160
it offers a way to access jit execution

62
00:02:29,680 --> 00:02:34,560
engine of llvm

63
00:02:32,160 --> 00:02:36,239
and in the future part we are going to

64
00:02:34,560 --> 00:02:38,800
see how we can uh

65
00:02:36,239 --> 00:02:39,519
implement and develop a jit compiler for

66
00:02:38,800 --> 00:02:42,239
python

67
00:02:39,519 --> 00:02:43,280
in two ways one is converting python's

68
00:02:42,239 --> 00:02:46,000
ast into the

69
00:02:43,280 --> 00:02:48,800
llvm wire and one is convert python's

70
00:02:46,000 --> 00:02:51,200
bad code to llvmr

71
00:02:48,800 --> 00:02:52,239
uh we are going to start to see python's

72
00:02:51,200 --> 00:02:55,920
workflow

73
00:02:52,239 --> 00:02:57,920
uh c python takes your source and uh

74
00:02:55,920 --> 00:02:59,599
generates tokens from it tokens are

75
00:02:57,920 --> 00:03:02,799
individual parts

76
00:02:59,599 --> 00:03:04,959
and they have no relations then

77
00:03:02,800 --> 00:03:07,840
the c python's partial takes the tokens

78
00:03:04,959 --> 00:03:10,560
and constructs a concrete syntax tree

79
00:03:07,840 --> 00:03:11,840
uh which has relationships but it is

80
00:03:10,560 --> 00:03:14,640
hard to work on

81
00:03:11,840 --> 00:03:16,159
and then uh it shifts uh all of the

82
00:03:14,640 --> 00:03:17,599
irrelevant information from that

83
00:03:16,159 --> 00:03:20,879
concrete syntax three

84
00:03:17,599 --> 00:03:23,599
and constructs an uh asd

85
00:03:20,879 --> 00:03:25,280
and then uh through the ac it constructs

86
00:03:23,599 --> 00:03:27,440
a control flow graph like structure

87
00:03:25,280 --> 00:03:30,560
there are no real control flow graphs

88
00:03:27,440 --> 00:03:32,879
in c python uh and uh

89
00:03:30,560 --> 00:03:34,560
but there's some structure that like

90
00:03:32,879 --> 00:03:35,440
control flow guard and it generates

91
00:03:34,560 --> 00:03:38,560
bytecode

92
00:03:35,440 --> 00:03:40,480
from the ast and that structure and then

93
00:03:38,560 --> 00:03:43,760
it executes that bytecode

94
00:03:40,480 --> 00:03:46,879
uh in python's virtual machine uh

95
00:03:43,760 --> 00:03:48,079
the code the astn bytecode is suitable

96
00:03:46,879 --> 00:03:51,120
for coordination

97
00:03:48,080 --> 00:03:51,519
but the other parts aren't uh and let's

98
00:03:51,120 --> 00:03:53,599
see

99
00:03:51,519 --> 00:03:55,920
them in details uh the tokenization

100
00:03:53,599 --> 00:03:56,480
starts with reading your python file

101
00:03:55,920 --> 00:03:59,679
like

102
00:03:56,480 --> 00:04:00,238
it should be a dot power that py file or

103
00:03:59,680 --> 00:04:02,080
the standard

104
00:04:00,239 --> 00:04:04,000
input that doesn't matter python reads

105
00:04:02,080 --> 00:04:06,720
the file decodes

106
00:04:04,000 --> 00:04:07,680
its contents in the encoding you have

107
00:04:06,720 --> 00:04:11,840
specified

108
00:04:07,680 --> 00:04:14,640
or utf-8 and it tokenizes it with

109
00:04:11,840 --> 00:04:16,560
certain patterns like that patterns uh

110
00:04:14,640 --> 00:04:18,959
depends on the context

111
00:04:16,560 --> 00:04:19,600
it knows how to split a dot b it has an

112
00:04:18,959 --> 00:04:21,759
individual

113
00:04:19,600 --> 00:04:23,280
meaning by its own it has an individual

114
00:04:21,759 --> 00:04:26,639
meaning by its own

115
00:04:23,280 --> 00:04:29,198
but it doesn't split 1.1 because 1.1 is

116
00:04:26,639 --> 00:04:32,160
a flawed

117
00:04:29,199 --> 00:04:33,680
but you can use tokens to generate a

118
00:04:32,160 --> 00:04:34,720
machine code because there are no

119
00:04:33,680 --> 00:04:37,280
relationships

120
00:04:34,720 --> 00:04:38,320
no blocks no nothing uh it's pretty rare

121
00:04:37,280 --> 00:04:41,039
format

122
00:04:38,320 --> 00:04:41,040
like this is a

123
00:04:41,520 --> 00:04:47,919
okay can i highlight this yeah uh

124
00:04:44,560 --> 00:04:50,800
this is some tokens like one is number

125
00:04:47,919 --> 00:04:52,000
operator is plus uh i know you can't see

126
00:04:50,800 --> 00:04:54,400
it

127
00:04:52,000 --> 00:04:56,080
because of highlight yeah uh the number

128
00:04:54,400 --> 00:04:57,679
uh this is oneplus one

129
00:04:56,080 --> 00:05:00,159
but you can generate code from this

130
00:04:57,680 --> 00:05:01,919
because there are no relationships

131
00:05:00,160 --> 00:05:05,759
then there is a parser parser is a

132
00:05:01,919 --> 00:05:10,080
program that takes that generates tokens

133
00:05:05,759 --> 00:05:12,320
and uses rules to construct a tree

134
00:05:10,080 --> 00:05:13,280
like structure concrete and congress

135
00:05:12,320 --> 00:05:16,560
next three

136
00:05:13,280 --> 00:05:19,359
spread complex uh because there's

137
00:05:16,560 --> 00:05:21,120
uh irrelevant information such as white

138
00:05:19,360 --> 00:05:24,400
space

139
00:05:21,120 --> 00:05:26,479
or parenthesis uh

140
00:05:24,400 --> 00:05:28,159
there are relationships but the blocks

141
00:05:26,479 --> 00:05:29,120
aren't suitable for direct code

142
00:05:28,160 --> 00:05:31,039
generation

143
00:05:29,120 --> 00:05:33,520
and python's parser interface is

144
00:05:31,039 --> 00:05:36,719
deprecated and will be removed

145
00:05:33,520 --> 00:05:38,960
so python advocates the work on in ast

146
00:05:36,720 --> 00:05:41,520
level

147
00:05:38,960 --> 00:05:44,400
ast is the abstract version of that

148
00:05:41,520 --> 00:05:47,280
concrete syntax tree

149
00:05:44,400 --> 00:05:48,159
there are nodes that are defined in a

150
00:05:47,280 --> 00:05:51,039
stl

151
00:05:48,160 --> 00:05:52,240
format the fierce asl format which are

152
00:05:51,039 --> 00:05:55,440
easy to work on

153
00:05:52,240 --> 00:05:56,560
like uh when you pass a function it says

154
00:05:55,440 --> 00:05:57,600
this is the return this is the

155
00:05:56,560 --> 00:05:59,520
function's name

156
00:05:57,600 --> 00:06:02,479
this is the annotations of the functions

157
00:05:59,520 --> 00:06:05,680
code uh etc etc

158
00:06:02,479 --> 00:06:08,318
python says uh you can manipulate this

159
00:06:05,680 --> 00:06:09,840
or generate your code from ast i give

160
00:06:08,319 --> 00:06:10,639
you some interfaces some helper

161
00:06:09,840 --> 00:06:12,638
functions

162
00:06:10,639 --> 00:06:13,680
but don't use the parser because it's so

163
00:06:12,639 --> 00:06:15,520
rough

164
00:06:13,680 --> 00:06:16,960
and it keeps only relevant information

165
00:06:15,520 --> 00:06:18,880
for generating code

166
00:06:16,960 --> 00:06:20,080
like it doesn't keep any white space or

167
00:06:18,880 --> 00:06:22,319
comments

168
00:06:20,080 --> 00:06:23,120
it keeps line no information for syntax

169
00:06:22,319 --> 00:06:26,080
errors

170
00:06:23,120 --> 00:06:28,319
uh for highlighting like where this

171
00:06:26,080 --> 00:06:31,440
syntax error happened

172
00:06:28,319 --> 00:06:34,560
uh this is an example of

173
00:06:31,440 --> 00:06:37,680
pythons not visiting interface

174
00:06:34,560 --> 00:06:38,479
like you can whenever python sees a

175
00:06:37,680 --> 00:06:40,639
constant note

176
00:06:38,479 --> 00:06:41,840
it will call the visit console handler

177
00:06:40,639 --> 00:06:43,759
whenever it sees a

178
00:06:41,840 --> 00:06:45,280
name node it will call the name handler

179
00:06:43,759 --> 00:06:49,520
so you can generate

180
00:06:45,280 --> 00:06:52,479
uh intermediate representation here

181
00:06:49,520 --> 00:06:53,359
then after that asc step python will

182
00:06:52,479 --> 00:06:56,240
construct

183
00:06:53,360 --> 00:06:57,199
code objects code objects that contains

184
00:06:56,240 --> 00:07:00,639
bytecode

185
00:06:57,199 --> 00:07:00,960
and some information uh scored objects

186
00:07:00,639 --> 00:07:02,720
uh

187
00:07:00,960 --> 00:07:04,318
is going to execute under c python's

188
00:07:02,720 --> 00:07:06,560
virtual machine uh

189
00:07:04,319 --> 00:07:07,919
which is a stack based virtual machine

190
00:07:06,560 --> 00:07:10,720
that works like

191
00:07:07,919 --> 00:07:12,159
uh you push something you pop something

192
00:07:10,720 --> 00:07:14,319
with the instructions

193
00:07:12,160 --> 00:07:15,360
the instructions are formats like uh

194
00:07:14,319 --> 00:07:18,800
there's opcode

195
00:07:15,360 --> 00:07:22,080
and apart operation arguments

196
00:07:18,800 --> 00:07:25,120
uh and there are some extra sequences

197
00:07:22,080 --> 00:07:25,758
like if you use a load const opcode you

198
00:07:25,120 --> 00:07:29,199
specify

199
00:07:25,759 --> 00:07:31,840
argument as an index of call cons

200
00:07:29,199 --> 00:07:33,599
data structure so it will make the

201
00:07:31,840 --> 00:07:35,758
python faster

202
00:07:33,599 --> 00:07:37,840
unfortunately there are no uh direct

203
00:07:35,759 --> 00:07:38,479
interface to assemble bytecode in python

204
00:07:37,840 --> 00:07:42,159
itself

205
00:07:38,479 --> 00:07:44,159
the interface assemble are ast in python

206
00:07:42,160 --> 00:07:45,919
but there are interfaces for

207
00:07:44,160 --> 00:07:48,400
disassembling bytecode objects

208
00:07:45,919 --> 00:07:50,159
which we can use in jit compiling the

209
00:07:48,400 --> 00:07:53,919
functions body

210
00:07:50,160 --> 00:07:56,400
uh just an example uh

211
00:07:53,919 --> 00:07:57,280
function that takes x as an input and

212
00:07:56,400 --> 00:08:00,239
compares if

213
00:07:57,280 --> 00:08:01,840
x is greater than four returns power of

214
00:08:00,240 --> 00:08:04,319
two etcetera etcetera

215
00:08:01,840 --> 00:08:06,000
and when we disassemble this we see

216
00:08:04,319 --> 00:08:07,280
instructions like this the first one is

217
00:08:06,000 --> 00:08:10,560
a loadfest

218
00:08:07,280 --> 00:08:11,280
uh it lost a local variable from the

219
00:08:10,560 --> 00:08:15,280
argument

220
00:08:11,280 --> 00:08:18,479
uh spec uh and they are format like this

221
00:08:15,280 --> 00:08:20,638
uh there's uh this is jump target change

222
00:08:18,479 --> 00:08:22,080
thing uh python stack base virtual

223
00:08:20,639 --> 00:08:25,599
machine operates like

224
00:08:22,080 --> 00:08:26,080
this it checks if x x is greater than

225
00:08:25,599 --> 00:08:29,520
four

226
00:08:26,080 --> 00:08:32,240
if not it pops directly here uh

227
00:08:29,520 --> 00:08:33,039
if it is a uh it is true it runs this

228
00:08:32,240 --> 00:08:36,560
place

229
00:08:33,039 --> 00:08:40,479
so this is a jump target from the

230
00:08:36,559 --> 00:08:45,518
from that return power of three line

231
00:08:40,479 --> 00:08:48,000
yeah this was the workflow of c python

232
00:08:45,519 --> 00:08:48,800
let's see why we can't directly trust

233
00:08:48,000 --> 00:08:51,839
the user code

234
00:08:48,800 --> 00:08:55,120
uh because we won't

235
00:08:51,839 --> 00:08:56,160
give the types of the arguments or any

236
00:08:55,120 --> 00:08:58,640
kind of name

237
00:08:56,160 --> 00:08:59,600
they are all dynamic and it will make

238
00:08:58,640 --> 00:09:03,920
our job

239
00:08:59,600 --> 00:09:04,240
harder user can even change buildings

240
00:09:03,920 --> 00:09:07,199
like

241
00:09:04,240 --> 00:09:09,200
user can change lamp function or they

242
00:09:07,200 --> 00:09:10,560
can even uh put handlers

243
00:09:09,200 --> 00:09:12,800
inside of class definitions like when

244
00:09:10,560 --> 00:09:14,160
you define a class python load something

245
00:09:12,800 --> 00:09:17,439
called build class

246
00:09:14,160 --> 00:09:18,319
which is a uh helper function and when

247
00:09:17,440 --> 00:09:20,959
you change

248
00:09:18,320 --> 00:09:21,600
build class from the built-ins module

249
00:09:20,959 --> 00:09:24,000
whenever

250
00:09:21,600 --> 00:09:25,279
someone defines a class in python your

251
00:09:24,000 --> 00:09:28,399
function gets called

252
00:09:25,279 --> 00:09:31,839
and this makes things even even more

253
00:09:28,399 --> 00:09:32,800
harder and uh compared to other

254
00:09:31,839 --> 00:09:34,959
languages

255
00:09:32,800 --> 00:09:36,800
in python everything is miserable unless

256
00:09:34,959 --> 00:09:39,518
you say otherwise

257
00:09:36,800 --> 00:09:41,040
yeah let's see some attempts from the

258
00:09:39,519 --> 00:09:44,959
past that tried to

259
00:09:41,040 --> 00:09:48,000
integrate llvm with the uh python itself

260
00:09:44,959 --> 00:09:50,560
online swallow uh it's a google

261
00:09:48,000 --> 00:09:52,399
sponsored fork of c python that

262
00:09:50,560 --> 00:09:53,680
tried to make a jit compiler for c

263
00:09:52,399 --> 00:09:56,959
python itself

264
00:09:53,680 --> 00:10:00,000
its name comes from monty python show uh

265
00:09:56,959 --> 00:10:02,880
it has to make python faster

266
00:10:00,000 --> 00:10:04,640
it's a fork of c python and they plan to

267
00:10:02,880 --> 00:10:05,439
eventually merge this into the python

268
00:10:04,640 --> 00:10:08,880
score

269
00:10:05,440 --> 00:10:09,279
but then uh there are some side effects

270
00:10:08,880 --> 00:10:12,000
which

271
00:10:09,279 --> 00:10:13,600
prevent this it was sponsored by google

272
00:10:12,000 --> 00:10:14,560
and then google lost its entirety

273
00:10:13,600 --> 00:10:17,200
because

274
00:10:14,560 --> 00:10:18,079
this was a fork and deployment was hard

275
00:10:17,200 --> 00:10:20,640
google

276
00:10:18,079 --> 00:10:21,439
hasn't any performance critical code in

277
00:10:20,640 --> 00:10:24,399
python

278
00:10:21,440 --> 00:10:25,360
and google's clients uh don't want to

279
00:10:24,399 --> 00:10:29,200
allocate

280
00:10:25,360 --> 00:10:32,480
money and time for this it's features

281
00:10:29,200 --> 00:10:35,839
it's made python 2.5 times faster

282
00:10:32,480 --> 00:10:36,560
on single thread python code it's single

283
00:10:35,839 --> 00:10:38,880
thread it

284
00:10:36,560 --> 00:10:39,920
they didn't solve the global interpreter

285
00:10:38,880 --> 00:10:42,959
log problem

286
00:10:39,920 --> 00:10:46,719
in python if you have a cpu bound code

287
00:10:42,959 --> 00:10:47,199
it can run it runs one thread at a one

288
00:10:46,720 --> 00:10:48,800
time

289
00:10:47,200 --> 00:10:50,720
it it doesn't matter if you have

290
00:10:48,800 --> 00:10:52,399
fortress it runs one thread

291
00:10:50,720 --> 00:10:54,079
because of some reference counting

292
00:10:52,399 --> 00:10:57,040
issues uh and

293
00:10:54,079 --> 00:10:57,359
uh on ladies follow didn't solve it uh

294
00:10:57,040 --> 00:11:00,800
but

295
00:10:57,360 --> 00:11:02,399
uh it's uh make pastor my python faster

296
00:11:00,800 --> 00:11:05,439
2.5 times

297
00:11:02,399 --> 00:11:06,240
in single thread code their aim was five

298
00:11:05,440 --> 00:11:08,240
times

299
00:11:06,240 --> 00:11:10,320
but there are some problems about

300
00:11:08,240 --> 00:11:11,920
reaching the name

301
00:11:10,320 --> 00:11:14,720
they didn't break any part of the code

302
00:11:11,920 --> 00:11:18,479
because they were already based on

303
00:11:14,720 --> 00:11:21,839
c pythons itself so every c extension

304
00:11:18,480 --> 00:11:21,839
run as usual

305
00:11:22,880 --> 00:11:26,079
they analyzed python code before running

306
00:11:25,120 --> 00:11:28,480
it

307
00:11:26,079 --> 00:11:30,000
so they know if you change the lamp

308
00:11:28,480 --> 00:11:33,600
function or not

309
00:11:30,000 --> 00:11:34,720
uh so that they make some assumptions

310
00:11:33,600 --> 00:11:36,800
performance on

311
00:11:34,720 --> 00:11:38,240
this and some data collectors run time

312
00:11:36,800 --> 00:11:42,479
like what fun

313
00:11:38,240 --> 00:11:43,760
x function gets if if x function gets

314
00:11:42,480 --> 00:11:46,640
always integers

315
00:11:43,760 --> 00:11:48,160
uh they said uh okay generate a uh

316
00:11:46,640 --> 00:11:50,800
intermediate representation

317
00:11:48,160 --> 00:11:51,519
based on that fact but if it gets a

318
00:11:50,800 --> 00:11:53,760
string

319
00:11:51,519 --> 00:11:57,040
there's a guard which prevents it uh

320
00:11:53,760 --> 00:11:59,200
these assumptions false

321
00:11:57,040 --> 00:12:00,240
it converts bytecode it operates in the

322
00:11:59,200 --> 00:12:04,959
bytecode level

323
00:12:00,240 --> 00:12:04,959
instead of ast which is their choice

324
00:12:05,680 --> 00:12:10,719
there is a hot threshold in unladen

325
00:12:08,959 --> 00:12:13,760
swallow uh

326
00:12:10,720 --> 00:12:16,160
so uh there's a cost of making one

327
00:12:13,760 --> 00:12:17,279
a function compared to llvm so if a

328
00:12:16,160 --> 00:12:19,199
function called

329
00:12:17,279 --> 00:12:20,480
uh so many times and they know so many

330
00:12:19,200 --> 00:12:23,519
about it uh

331
00:12:20,480 --> 00:12:26,399
they compile to llvm and

332
00:12:23,519 --> 00:12:28,720
before that compilation they collect uh

333
00:12:26,399 --> 00:12:32,079
data about that function

334
00:12:28,720 --> 00:12:35,360
uh help of the data

335
00:12:32,079 --> 00:12:36,079
they know uh this uh they know if there

336
00:12:35,360 --> 00:12:38,720
is a if

337
00:12:36,079 --> 00:12:39,599
a branch never executed they just cut

338
00:12:38,720 --> 00:12:41,839
out it

339
00:12:39,600 --> 00:12:42,720
or if they know all arguments are

340
00:12:41,839 --> 00:12:47,120
integer they

341
00:12:42,720 --> 00:12:49,839
optimize for that but

342
00:12:47,120 --> 00:12:50,639
ensuring that everything works as same

343
00:12:49,839 --> 00:12:53,839
even the

344
00:12:50,639 --> 00:12:57,200
arguments changed

345
00:12:53,839 --> 00:13:00,480
they put guards which has caused

346
00:12:57,200 --> 00:13:03,920
if mispredictions happen

347
00:13:00,480 --> 00:13:06,560
and they worked with linking llvm into

348
00:13:03,920 --> 00:13:10,560
the python binary

349
00:13:06,560 --> 00:13:13,040
there are some cons bad sides of this

350
00:13:10,560 --> 00:13:15,199
one is memory usage the memory usage

351
00:13:13,040 --> 00:13:18,839
increased up to eight times

352
00:13:15,200 --> 00:13:22,639
it's not always eight times but the

353
00:13:18,839 --> 00:13:24,800
most part of it eight times

354
00:13:22,639 --> 00:13:25,680
this is one of the cards of llvm and

355
00:13:24,800 --> 00:13:28,959
other libraries

356
00:13:25,680 --> 00:13:29,760
the increased network usage and if you

357
00:13:28,959 --> 00:13:31,439
keep

358
00:13:29,760 --> 00:13:33,360
different versions of same code in the

359
00:13:31,440 --> 00:13:36,800
memory it will increase

360
00:13:33,360 --> 00:13:39,519
by default so they keep the native code

361
00:13:36,800 --> 00:13:41,839
they keep the bytecode they hit the asd

362
00:13:39,519 --> 00:13:43,120
so memory is increased and there are

363
00:13:41,839 --> 00:13:47,519
some optimizer

364
00:13:43,120 --> 00:13:48,480
structures they try to optimize python

365
00:13:47,519 --> 00:13:50,800
bytecode

366
00:13:48,480 --> 00:13:52,240
before sending to llvm so they create

367
00:13:50,800 --> 00:13:55,439
some structure

368
00:13:52,240 --> 00:13:58,560
which gives pythons internal knowledge

369
00:13:55,440 --> 00:14:02,079
but they have they caused uh

370
00:13:58,560 --> 00:14:05,359
there are some console startup time

371
00:14:02,079 --> 00:14:08,638
uh static linking again uh

372
00:14:05,360 --> 00:14:10,399
and uh when you want to compile a python

373
00:14:08,639 --> 00:14:11,279
function to lvm you need to initialize

374
00:14:10,399 --> 00:14:13,519
llvm

375
00:14:11,279 --> 00:14:14,639
and c plus plus initialize take some

376
00:14:13,519 --> 00:14:16,399
time

377
00:14:14,639 --> 00:14:18,160
and there are some overtops here on time

378
00:14:16,399 --> 00:14:20,320
routines uh

379
00:14:18,160 --> 00:14:22,959
binary size increased as usual because

380
00:14:20,320 --> 00:14:28,639
you linked the llvm

381
00:14:22,959 --> 00:14:31,680
uh why don't they reach the 2.5 times

382
00:14:28,639 --> 00:14:34,399
they reach 2.5 times but not five times

383
00:14:31,680 --> 00:14:35,519
uh because when they was working this

384
00:14:34,399 --> 00:14:38,880
project was from

385
00:14:35,519 --> 00:14:41,120
2009 llvm isn't that good at

386
00:14:38,880 --> 00:14:42,240
just name compilation and they had some

387
00:14:41,120 --> 00:14:45,279
issues

388
00:14:42,240 --> 00:14:48,800
with that and llvms

389
00:14:45,279 --> 00:14:50,480
uh digital doesn't work well with gdb

390
00:14:48,800 --> 00:14:52,399
if you are developing a c extension in

391
00:14:50,480 --> 00:14:53,279
python you probably want to debug it

392
00:14:52,399 --> 00:14:57,040
with gdb

393
00:14:53,279 --> 00:15:00,079
on set files and use all profile

394
00:14:57,040 --> 00:15:03,599
and llvm's gt code didn't work well

395
00:15:00,079 --> 00:15:08,800
so they allocate some time to fix this

396
00:15:03,600 --> 00:15:11,839
but they lost some gain in performance

397
00:15:08,800 --> 00:15:12,479
this project lasted one year and then we

398
00:15:11,839 --> 00:15:15,760
will lose this

399
00:15:12,480 --> 00:15:17,440
interest if the project continues uh

400
00:15:15,760 --> 00:15:20,880
in my opinion they can reach the five

401
00:15:17,440 --> 00:15:23,519
times goal easily on some quotes

402
00:15:20,880 --> 00:15:25,279
uh some eleven points about this uh they

403
00:15:23,519 --> 00:15:27,760
initially selected llvm because they

404
00:15:25,279 --> 00:15:30,399
they don't want to generate assembly

405
00:15:27,760 --> 00:15:34,079
code on every machine target

406
00:15:30,399 --> 00:15:34,079
allowing was easy

407
00:15:34,240 --> 00:15:37,680
the optimizations of coordination was

408
00:15:35,680 --> 00:15:41,120
great but in 2009

409
00:15:37,680 --> 00:15:44,160
it isn't directly suitable for gt inc

410
00:15:41,120 --> 00:15:45,120
and cost of operations compiling was so

411
00:15:44,160 --> 00:15:49,040
heavy

412
00:15:45,120 --> 00:15:49,040
uh and

413
00:15:49,199 --> 00:15:53,199
without calling sub runtime data it is

414
00:15:52,160 --> 00:15:55,920
hard to optimize

415
00:15:53,199 --> 00:15:56,880
they was collecting and they was

416
00:15:55,920 --> 00:15:59,920
collecting after

417
00:15:56,880 --> 00:16:03,360
learning this so they spent some time to

418
00:15:59,920 --> 00:16:06,959
do this without collecting runtime data

419
00:16:03,360 --> 00:16:09,519
the next project is pi alavian

420
00:16:06,959 --> 00:16:10,880
which is a compiler for subset of python

421
00:16:09,519 --> 00:16:13,519
that specializes in

422
00:16:10,880 --> 00:16:14,880
machine learning uh algorithms and

423
00:16:13,519 --> 00:16:18,079
computations

424
00:16:14,880 --> 00:16:18,959
uh in python mathematical code gets

425
00:16:18,079 --> 00:16:21,199
executed

426
00:16:18,959 --> 00:16:22,000
slowly because of there's overlap of

427
00:16:21,199 --> 00:16:24,560
dynamic

428
00:16:22,000 --> 00:16:25,120
things if you compile this to llvm you

429
00:16:24,560 --> 00:16:28,959
get

430
00:16:25,120 --> 00:16:32,160
so much uh gain and they try to do this

431
00:16:28,959 --> 00:16:32,719
uh their features are they are as fast

432
00:16:32,160 --> 00:16:34,839
as

433
00:16:32,720 --> 00:16:37,839
c code in some cases that compile with

434
00:16:34,839 --> 00:16:37,839
clang

435
00:16:38,000 --> 00:16:42,959
they only work for a subset of python uh

436
00:16:41,199 --> 00:16:45,359
if your function doesn't fit that

437
00:16:42,959 --> 00:16:47,758
subject they directly return your

438
00:16:45,360 --> 00:16:51,120
python function if it fits they'll turn

439
00:16:47,759 --> 00:16:52,959
a wrapper around the digit codes

440
00:16:51,120 --> 00:16:55,199
they don't want they don't collect

441
00:16:52,959 --> 00:16:56,319
runtime data but they do static type

442
00:16:55,199 --> 00:16:59,120
inference and

443
00:16:56,320 --> 00:17:01,600
symbol table generation python is a

444
00:16:59,120 --> 00:17:03,120
symbol table which you can use

445
00:17:01,600 --> 00:17:05,679
that comes with standard library but it

446
00:17:03,120 --> 00:17:07,439
doesn't give you an anything about types

447
00:17:05,679 --> 00:17:10,160
so you need to create your own symbol

448
00:17:07,439 --> 00:17:14,000
table which records types and inverse

449
00:17:10,160 --> 00:17:16,640
types which could be uh cool

450
00:17:14,000 --> 00:17:18,640
uh they use something called lvmpi which

451
00:17:16,640 --> 00:17:22,640
is a library airport library

452
00:17:18,640 --> 00:17:24,640
around llvms api c plus plus api

453
00:17:22,640 --> 00:17:26,640
they use python asd model inst of

454
00:17:24,640 --> 00:17:30,480
bytecode which is

455
00:17:26,640 --> 00:17:32,880
more suitable in my opinions

456
00:17:30,480 --> 00:17:33,919
they try to convert the function body

457
00:17:32,880 --> 00:17:35,919
and if

458
00:17:33,919 --> 00:17:37,039
they see something that can become they

459
00:17:35,919 --> 00:17:40,160
raise an error

460
00:17:37,039 --> 00:17:42,000
and if they catch that error their they

461
00:17:40,160 --> 00:17:44,080
return normal function

462
00:17:42,000 --> 00:17:45,120
if they don't see that error they just

463
00:17:44,080 --> 00:17:49,439
return the

464
00:17:45,120 --> 00:17:52,959
function and they invert types

465
00:17:49,440 --> 00:17:54,000
let's see piston piston uh is a jit

466
00:17:52,960 --> 00:17:56,160
compiler

467
00:17:54,000 --> 00:17:59,440
and the runtime for python 2 it's

468
00:17:56,160 --> 00:18:03,360
runtime most based on c pythons

469
00:17:59,440 --> 00:18:06,720
so they have some gain on that

470
00:18:03,360 --> 00:18:10,240
they use something called tracing jits

471
00:18:06,720 --> 00:18:13,440
and they specialize on web applications

472
00:18:10,240 --> 00:18:15,679
especially dropbox they manage to run

473
00:18:13,440 --> 00:18:17,039
jungle food test suites as far as i

474
00:18:15,679 --> 00:18:19,760
remember

475
00:18:17,039 --> 00:18:21,440
their features as their 95 percent

476
00:18:19,760 --> 00:18:22,720
faster than c python in the latest

477
00:18:21,440 --> 00:18:26,240
release

478
00:18:22,720 --> 00:18:26,240
in 2017

479
00:18:26,960 --> 00:18:30,559
they have c api support because of c

480
00:18:29,360 --> 00:18:34,240
paths runtime

481
00:18:30,559 --> 00:18:37,440
and uh in a big codebase you can run

482
00:18:34,240 --> 00:18:40,160
piston with little changes

483
00:18:37,440 --> 00:18:41,760
over the general code base they have

484
00:18:40,160 --> 00:18:44,000
more than

485
00:18:41,760 --> 00:18:45,360
three executors llvm is the highest

486
00:18:44,000 --> 00:18:48,960
level and there's

487
00:18:45,360 --> 00:18:52,080
egypt and there is a ast interpreter

488
00:18:48,960 --> 00:18:55,679
so if your function

489
00:18:52,080 --> 00:18:58,080
gets called gets

490
00:18:55,679 --> 00:18:58,880
called less they interpret the functions

491
00:18:58,080 --> 00:19:01,439
ast

492
00:18:58,880 --> 00:19:02,799
if it is called more than 25 times they

493
00:19:01,440 --> 00:19:05,600
get with uh

494
00:19:02,799 --> 00:19:07,039
digits and if it's called more than one

495
00:19:05,600 --> 00:19:10,080
thousand times they

496
00:19:07,039 --> 00:19:12,799
they eat it with llvm

497
00:19:10,080 --> 00:19:13,280
they have a select control flow graphs

498
00:19:12,799 --> 00:19:16,320
and

499
00:19:13,280 --> 00:19:18,720
as the interpreter two jits tracing and

500
00:19:16,320 --> 00:19:21,918
they use something called inline caching

501
00:19:18,720 --> 00:19:24,320
and rewriting of functions body

502
00:19:21,919 --> 00:19:25,120
and c python based runtime so there are

503
00:19:24,320 --> 00:19:29,439
some projects

504
00:19:25,120 --> 00:19:32,479
uh from current dates uh

505
00:19:29,440 --> 00:19:35,919
number number is up to date project that

506
00:19:32,480 --> 00:19:35,919
uses llvm to jit

507
00:19:37,039 --> 00:19:40,640
it's a jit compiler it's specialized in

508
00:19:40,000 --> 00:19:42,960
uh

509
00:19:40,640 --> 00:19:44,559
numpy and python functions it knows how

510
00:19:42,960 --> 00:19:47,679
to boot sharpness to

511
00:19:44,559 --> 00:19:51,360
is assembly level and gets

512
00:19:47,679 --> 00:19:53,840
best performance such a subset

513
00:19:51,360 --> 00:19:55,199
and it works only for only with type

514
00:19:53,840 --> 00:19:58,399
inference if it knows

515
00:19:55,200 --> 00:20:01,520
what types it gets uh it directly jits

516
00:19:58,400 --> 00:20:04,880
if it does it doesn't know uh it

517
00:20:01,520 --> 00:20:06,240
records runtime data uh it's used with

518
00:20:04,880 --> 00:20:08,480
simple python decorative

519
00:20:06,240 --> 00:20:09,360
you just add something uh at top of the

520
00:20:08,480 --> 00:20:11,679
function

521
00:20:09,360 --> 00:20:12,399
called legit and number automatically

522
00:20:11,679 --> 00:20:15,600
handles

523
00:20:12,400 --> 00:20:19,440
everything else uh it supports nvidia

524
00:20:15,600 --> 00:20:22,240
kudo and amd rock experimentally

525
00:20:19,440 --> 00:20:23,360
it's almost as fast as c in some cases

526
00:20:22,240 --> 00:20:26,480
which is pretty good

527
00:20:23,360 --> 00:20:26,959
uh it works like this it takes python

528
00:20:26,480 --> 00:20:30,080
source

529
00:20:26,960 --> 00:20:32,000
uh it uses bytecode to generate ir

530
00:20:30,080 --> 00:20:33,678
and then it converts that by code to

531
00:20:32,000 --> 00:20:35,600
their own specialized

532
00:20:33,679 --> 00:20:38,240
intermediate representation they made

533
00:20:35,600 --> 00:20:40,879
some assumptions based on type inference

534
00:20:38,240 --> 00:20:43,520
and they generate llvm ir and jits

535
00:20:40,880 --> 00:20:43,520
afterwards

536
00:20:43,840 --> 00:20:50,000
there is some different modes in lvm

537
00:20:47,200 --> 00:20:52,080
and number one is no python mode no

538
00:20:50,000 --> 00:20:54,480
python mod means this object never gets

539
00:20:52,080 --> 00:20:55,439
python objects uh it always gets

540
00:20:54,480 --> 00:20:58,720
integers and

541
00:20:55,440 --> 00:21:01,760
other atomic types so

542
00:20:58,720 --> 00:21:02,320
if you use it you get more performance

543
00:21:01,760 --> 00:21:04,640
uh

544
00:21:02,320 --> 00:21:05,678
changes uh lmr and it optimizes the

545
00:21:04,640 --> 00:21:07,919
alarm light

546
00:21:05,679 --> 00:21:09,600
has an interface lvm and uh you can

547
00:21:07,919 --> 00:21:13,200
optimize the barcode

548
00:21:09,600 --> 00:21:14,799
it binds to it functions in the future

549
00:21:13,200 --> 00:21:18,159
we are going to see how we can

550
00:21:14,799 --> 00:21:21,760
write our llvm compiler

551
00:21:18,159 --> 00:21:25,200
this is the r target function uh

552
00:21:21,760 --> 00:21:28,080
it takes a and b and it uses python's

553
00:21:25,200 --> 00:21:29,440
annotation feature which we don't handle

554
00:21:28,080 --> 00:21:32,960
with type inference

555
00:21:29,440 --> 00:21:35,840
you need to specify the types

556
00:21:32,960 --> 00:21:38,080
we are going to use ast electron knight

557
00:21:35,840 --> 00:21:42,959
the same library that number uses

558
00:21:38,080 --> 00:21:42,960
and annotations this is the function

559
00:21:43,440 --> 00:21:47,280
we will have a compiler if we can

560
00:21:45,840 --> 00:21:47,918
convert the functions buddy we will

561
00:21:47,280 --> 00:21:49,840
convert

562
00:21:47,919 --> 00:21:51,440
if we can't we will return the normal

563
00:21:49,840 --> 00:21:54,559
function so it will work

564
00:21:51,440 --> 00:21:55,440
in a subset of python uh it's a basic

565
00:21:54,559 --> 00:21:57,440
compiler

566
00:21:55,440 --> 00:21:59,440
it will get it will try to get function

567
00:21:57,440 --> 00:22:00,880
source code if it can't it will return

568
00:21:59,440 --> 00:22:04,000
normal function

569
00:22:00,880 --> 00:22:05,919
uh and if it can it will pass the source

570
00:22:04,000 --> 00:22:10,000
code into the ast

571
00:22:05,919 --> 00:22:12,559
and it will try to

572
00:22:10,000 --> 00:22:13,360
traverse that ast using not visitor

573
00:22:12,559 --> 00:22:16,639
class

574
00:22:13,360 --> 00:22:18,399
python's asd returned if any error

575
00:22:16,640 --> 00:22:20,320
happens during that traversing

576
00:22:18,400 --> 00:22:21,679
it will return normal function so if

577
00:22:20,320 --> 00:22:24,720
something doesn't fit our

578
00:22:21,679 --> 00:22:27,440
subset we will raise the compiler and

579
00:22:24,720 --> 00:22:29,360
if this part catches that error it will

580
00:22:27,440 --> 00:22:32,000
return the function

581
00:22:29,360 --> 00:22:34,158
uh this is the ast of that function it

582
00:22:32,000 --> 00:22:37,280
starts with a function definition

583
00:22:34,159 --> 00:22:37,840
there is a argument part there is a body

584
00:22:37,280 --> 00:22:40,080
part

585
00:22:37,840 --> 00:22:42,240
uh the quarter part and return

586
00:22:40,080 --> 00:22:45,678
annotation

587
00:22:42,240 --> 00:22:49,280
uh the module is the highest level of

588
00:22:45,679 --> 00:22:52,720
any ast and we are going to generate an

589
00:22:49,280 --> 00:22:55,918
llvm module from the python's ast

590
00:22:52,720 --> 00:22:57,039
and set to uh soft mode and generic list

591
00:22:55,919 --> 00:22:59,760
is a function that

592
00:22:57,039 --> 00:23:01,520
traverses the body of given node so we

593
00:22:59,760 --> 00:23:05,200
will give the body a module

594
00:23:01,520 --> 00:23:08,320
and it will uh traverse every node

595
00:23:05,200 --> 00:23:09,200
that lives under the module this is the

596
00:23:08,320 --> 00:23:13,360
function

597
00:23:09,200 --> 00:23:15,679
if you want to recall the functions

598
00:23:13,360 --> 00:23:16,639
first of all we will remove the

599
00:23:15,679 --> 00:23:19,679
decorator

600
00:23:16,640 --> 00:23:23,200
that is used to jit our code so

601
00:23:19,679 --> 00:23:26,080
it won't be infinite loop

602
00:23:23,200 --> 00:23:27,919
then we are going to uh generate an

603
00:23:26,080 --> 00:23:31,120
argument spec from that

604
00:23:27,919 --> 00:23:34,960
uh there is a cast algorithm function

605
00:23:31,120 --> 00:23:38,320
which is just checks the annotation and

606
00:23:34,960 --> 00:23:40,400
converts and aladdin wire and then we

607
00:23:38,320 --> 00:23:43,678
are going to get the return type

608
00:23:40,400 --> 00:23:44,799
so we can convert an element function

609
00:23:43,679 --> 00:23:47,200
type from that

610
00:23:44,799 --> 00:23:48,840
it takes return type and the values of

611
00:23:47,200 --> 00:23:50,960
arguments

612
00:23:48,840 --> 00:23:52,480
uh then we are going to use that

613
00:23:50,960 --> 00:23:55,520
function type to generate an

614
00:23:52,480 --> 00:23:58,000
llvm function which will live under

615
00:23:55,520 --> 00:23:58,720
uh the module we have created it will

616
00:23:58,000 --> 00:24:01,200
take the

617
00:23:58,720 --> 00:24:03,200
function type and if it will have the

618
00:24:01,200 --> 00:24:04,799
name of the node

619
00:24:03,200 --> 00:24:06,880
then we are going to append the basic

620
00:24:04,799 --> 00:24:10,080
block uh

621
00:24:06,880 --> 00:24:10,960
which we can use that afterwards to get

622
00:24:10,080 --> 00:24:13,918
a builder

623
00:24:10,960 --> 00:24:14,799
in that basic block so we are going to

624
00:24:13,919 --> 00:24:17,919
traverse the

625
00:24:14,799 --> 00:24:18,960
node's body one by one and use that

626
00:24:17,919 --> 00:24:22,000
builder to build

627
00:24:18,960 --> 00:24:23,200
our expressions the first expression is

628
00:24:22,000 --> 00:24:25,039
constants

629
00:24:23,200 --> 00:24:26,640
element types doesn't directly fit to

630
00:24:25,039 --> 00:24:29,279
python mass

631
00:24:26,640 --> 00:24:30,880
so we need to convert it python's

632
00:24:29,279 --> 00:24:33,440
integer doesn't have

633
00:24:30,880 --> 00:24:34,880
a specific bit length so we are going to

634
00:24:33,440 --> 00:24:37,039
use 32

635
00:24:34,880 --> 00:24:39,679
for default and we are going to use

636
00:24:37,039 --> 00:24:42,720
float for our floor type not double

637
00:24:39,679 --> 00:24:44,240
uh this is the cast album function

638
00:24:42,720 --> 00:24:46,640
if the given type is integer we are

639
00:24:44,240 --> 00:24:48,159
going to return lrams in type

640
00:24:46,640 --> 00:24:50,000
if the float we are going to return

641
00:24:48,159 --> 00:24:52,159
floor type and if

642
00:24:50,000 --> 00:24:54,960
the type we don't is something we don't

643
00:24:52,159 --> 00:24:57,919
know we will raise the compiler

644
00:24:54,960 --> 00:25:00,000
uh this is the part that constructs uh

645
00:24:57,919 --> 00:25:04,960
intermediate representation

646
00:25:00,000 --> 00:25:08,880
llvm's constant with the type of the

647
00:25:04,960 --> 00:25:12,320
ir and the value of the nodes

648
00:25:08,880 --> 00:25:15,360
there's the argument access part we will

649
00:25:12,320 --> 00:25:17,039
visit the name nodes and if we can fetch

650
00:25:15,360 --> 00:25:20,399
the argument from the

651
00:25:17,039 --> 00:25:21,039
given functions type spec we will fetch

652
00:25:20,400 --> 00:25:24,159
it

653
00:25:21,039 --> 00:25:25,840
and return the value if we can't we will

654
00:25:24,159 --> 00:25:26,480
raise a compiler because it's something

655
00:25:25,840 --> 00:25:28,799
global

656
00:25:26,480 --> 00:25:29,840
or we don't know there is binary

657
00:25:28,799 --> 00:25:33,679
operations

658
00:25:29,840 --> 00:25:34,799
we will try to get the operator from the

659
00:25:33,679 --> 00:25:37,840
builder object

660
00:25:34,799 --> 00:25:38,240
if we can we will raise a compiler

661
00:25:37,840 --> 00:25:41,199
because

662
00:25:38,240 --> 00:25:43,279
some operator we don't know and then we

663
00:25:41,200 --> 00:25:45,120
will return the left side and right side

664
00:25:43,279 --> 00:25:47,679
under that operator

665
00:25:45,120 --> 00:25:48,479
uh the repair operation is pretty simple

666
00:25:47,679 --> 00:25:51,919
we will just

667
00:25:48,480 --> 00:25:52,480
call red method of builder and return

668
00:25:51,919 --> 00:25:55,600
the

669
00:25:52,480 --> 00:25:57,360
given value which is going to be binary

670
00:25:55,600 --> 00:25:59,199
operation

671
00:25:57,360 --> 00:26:01,520
so we wrote a basic compiler with a

672
00:25:59,200 --> 00:26:04,720
compile class method a compiler

673
00:26:01,520 --> 00:26:06,559
uh if it doesn't fit subset and visitors

674
00:26:04,720 --> 00:26:08,880
for module function return binary

675
00:26:06,559 --> 00:26:12,240
operation name and constant

676
00:26:08,880 --> 00:26:13,440
uh the funny part is creating an

677
00:26:12,240 --> 00:26:16,640
execution engine

678
00:26:13,440 --> 00:26:18,960
we will create a default ripple target

679
00:26:16,640 --> 00:26:20,080
that's configured llvm and create a

680
00:26:18,960 --> 00:26:22,559
target machine

681
00:26:20,080 --> 00:26:24,240
uh in the creating target machine you

682
00:26:22,559 --> 00:26:25,600
can specify the optimization level or

683
00:26:24,240 --> 00:26:28,080
anything you want

684
00:26:25,600 --> 00:26:28,719
then we will create the execution engine

685
00:26:28,080 --> 00:26:31,918
which

686
00:26:28,720 --> 00:26:33,440
takes a bootstrapping assembly we don't

687
00:26:31,919 --> 00:26:35,120
have anything to bootstrap

688
00:26:33,440 --> 00:26:37,760
and our machine and we will return the

689
00:26:35,120 --> 00:26:40,639
machine engine

690
00:26:37,760 --> 00:26:41,120
this is the exiting part we will create

691
00:26:40,640 --> 00:26:44,799
the engine

692
00:26:41,120 --> 00:26:47,678
with the with this method and then

693
00:26:44,799 --> 00:26:48,559
parse the our module and verify it if

694
00:26:47,679 --> 00:26:51,600
it's ability

695
00:26:48,559 --> 00:26:52,158
uh intimate representation or not then

696
00:26:51,600 --> 00:26:54,799
we will

697
00:26:52,159 --> 00:26:56,320
add that module to end our engine we'll

698
00:26:54,799 --> 00:26:58,720
finalize and

699
00:26:56,320 --> 00:27:00,960
run the static constructors and then we

700
00:26:58,720 --> 00:27:04,240
will get the function

701
00:27:00,960 --> 00:27:08,159
as a c types function

702
00:27:04,240 --> 00:27:10,799
uh pointer so

703
00:27:08,159 --> 00:27:12,000
at the end we will uh fetch that

704
00:27:10,799 --> 00:27:14,799
functions pointer

705
00:27:12,000 --> 00:27:17,200
and cast it to c type c function python

706
00:27:14,799 --> 00:27:20,720
offers a way to uh

707
00:27:17,200 --> 00:27:21,200
access uh c functions with c types so

708
00:27:20,720 --> 00:27:24,880
there's a

709
00:27:21,200 --> 00:27:27,919
c type c func type which takes a typeset

710
00:27:24,880 --> 00:27:30,159
and the type spec is

711
00:27:27,919 --> 00:27:32,880
given here and we will cast the function

712
00:27:30,159 --> 00:27:36,159
pointers to that

713
00:27:32,880 --> 00:27:39,279
we did this with asmr ast

714
00:27:36,159 --> 00:27:42,000
so we can we did this uh same thing

715
00:27:39,279 --> 00:27:43,760
with barcode yes uh we will have

716
00:27:42,000 --> 00:27:45,039
something like this to decorate our

717
00:27:43,760 --> 00:27:48,559
function

718
00:27:45,039 --> 00:27:51,120
uh and we will have that same part

719
00:27:48,559 --> 00:27:52,639
uh we will keep a stack of the functions

720
00:27:51,120 --> 00:27:53,678
barcode because python's visual machine

721
00:27:52,640 --> 00:27:56,480
is by

722
00:27:53,679 --> 00:27:58,640
stack based so we will uh with the

723
00:27:56,480 --> 00:28:01,600
obscures by one by one

724
00:27:58,640 --> 00:28:02,320
if the opcode is something we know uh we

725
00:28:01,600 --> 00:28:05,439
will add

726
00:28:02,320 --> 00:28:08,480
the stack if we don't know

727
00:28:05,440 --> 00:28:10,480
we will break the for loop understand

728
00:28:08,480 --> 00:28:13,600
the normal function

729
00:28:10,480 --> 00:28:14,720
uh loading names is simple uh if we see

730
00:28:13,600 --> 00:28:18,799
a

731
00:28:14,720 --> 00:28:22,159
lot uh bad code we will return the

732
00:28:18,799 --> 00:28:24,879
uh given arguments to stack

733
00:28:22,159 --> 00:28:25,600
if we see a load cost we will cast it to

734
00:28:24,880 --> 00:28:28,880
llvm

735
00:28:25,600 --> 00:28:31,279
and append the stack if we see a binary

736
00:28:28,880 --> 00:28:32,399
operation we will pop two things from

737
00:28:31,279 --> 00:28:35,200
the stack

738
00:28:32,399 --> 00:28:38,399
and create an operation from it and if

739
00:28:35,200 --> 00:28:41,600
we see a return value we will return

740
00:28:38,399 --> 00:28:45,039
this is the whole code to

741
00:28:41,600 --> 00:28:48,240
construct that ir yeah this is it

742
00:28:45,039 --> 00:28:48,960
thank you for listening is there any

743
00:28:48,240 --> 00:28:54,660
questions

744
00:28:48,960 --> 00:28:54,660
[Applause]

745
00:28:56,320 --> 00:28:59,840
no okay

746
00:29:00,159 --> 00:29:13,840
okay um

747
00:29:15,279 --> 00:29:20,000
can you make explicit what makes your

748
00:29:17,840 --> 00:29:22,799
opposition different

749
00:29:20,000 --> 00:29:23,360
uh what are the things that are

750
00:29:22,799 --> 00:29:26,960
different

751
00:29:23,360 --> 00:29:26,959
in your approach to the

752
00:29:27,919 --> 00:29:33,120
okay you are asking uh what are things

753
00:29:30,960 --> 00:29:35,120
different in my jit compilers

754
00:29:33,120 --> 00:29:37,678
other than the projects i saw i

755
00:29:35,120 --> 00:29:37,678
presented

756
00:29:38,240 --> 00:29:42,320
okay i need to go to the outline to uh

757
00:29:41,200 --> 00:29:47,039
list other function

758
00:29:42,320 --> 00:29:47,039
uh other projects okay this will

759
00:29:48,799 --> 00:29:54,399
okay uh there was four projects online

760
00:29:52,159 --> 00:29:57,120
swallow was using bytecode

761
00:29:54,399 --> 00:29:57,840
the bytecode i am using in the second

762
00:29:57,120 --> 00:30:00,879
approach

763
00:29:57,840 --> 00:30:01,918
so our latest values approach and my

764
00:30:00,880 --> 00:30:05,279
approach is

765
00:30:01,919 --> 00:30:09,200
almost same uh pi aladdin uses asd

766
00:30:05,279 --> 00:30:11,760
and in my first approach i used ast to

767
00:30:09,200 --> 00:30:12,640
use that same approach piston and number

768
00:30:11,760 --> 00:30:17,039
also uses

769
00:30:12,640 --> 00:30:20,720
bytecode so mine isn't different than

770
00:30:17,039 --> 00:30:24,399
others but i pre i try to simplify the

771
00:30:20,720 --> 00:30:29,600
process of there in my examples

772
00:30:24,399 --> 00:30:29,600
in both ways okay

773
00:30:30,080 --> 00:30:33,840
typing issue is a real issue and it

774
00:30:33,039 --> 00:30:37,039
seems to me that

775
00:30:33,840 --> 00:30:37,918
your approach you're delegating that to

776
00:30:37,039 --> 00:30:41,600
the user

777
00:30:37,919 --> 00:30:42,640
yeah so that's actually a very big

778
00:30:41,600 --> 00:30:45,678
difference compared to

779
00:30:42,640 --> 00:30:47,520
the other approach you are not taking

780
00:30:45,679 --> 00:30:48,000
care of type insurance which makes

781
00:30:47,520 --> 00:30:52,240
things

782
00:30:48,000 --> 00:30:54,960
much easier but

783
00:30:52,240 --> 00:30:55,360
when you annotate a variable with it it

784
00:30:54,960 --> 00:30:58,720
means

785
00:30:55,360 --> 00:31:03,600
python int which is actually begins yeah

786
00:30:58,720 --> 00:31:06,559
and you are casting them to 32 bits

787
00:31:03,600 --> 00:31:08,639
which is a totally different word yeah i

788
00:31:06,559 --> 00:31:10,960
mentioned that

789
00:31:08,640 --> 00:31:11,679
types doesn't directly fit the python

790
00:31:10,960 --> 00:31:15,760
type so

791
00:31:11,679 --> 00:31:19,039
for the sake of easily i

792
00:31:15,760 --> 00:31:22,399
casted it to 32-bit integer but

793
00:31:19,039 --> 00:31:26,000
in a real world application it would be

794
00:31:22,399 --> 00:31:28,879
nonsense to cast thirty two bit int

795
00:31:26,000 --> 00:31:29,640
or you could for instance using c types

796
00:31:28,880 --> 00:31:32,960
can

797
00:31:29,640 --> 00:31:32,960
exhibit two bits

798
00:31:38,720 --> 00:31:44,480
well python's typing doesn't uh allow to

799
00:31:41,279 --> 00:31:46,640
specify integers uh there's literals but

800
00:31:44,480 --> 00:31:48,320
there are nothing to specify the length

801
00:31:46,640 --> 00:31:50,559
of bit length of the integer

802
00:31:48,320 --> 00:31:51,519
in type annotations so it would be hard

803
00:31:50,559 --> 00:31:54,080
to use to

804
00:31:51,519 --> 00:31:54,080
define that

805
00:31:57,120 --> 00:32:01,840
how much

806
00:32:02,240 --> 00:32:08,960
my compilers get around to 20

807
00:32:06,640 --> 00:32:09,919
speed because i don't do any

808
00:32:08,960 --> 00:32:12,399
optimizations

809
00:32:09,919 --> 00:32:14,240
any extra thing i just convert the

810
00:32:12,399 --> 00:32:18,559
direct python to llvmr

811
00:32:14,240 --> 00:32:18,559
and it gets 20 persons speed up

812
00:32:19,760 --> 00:32:23,279
what stops you from doing optimization

813
00:32:22,240 --> 00:32:27,120
why are you not

814
00:32:23,279 --> 00:32:29,600
doing running the optimizer because

815
00:32:27,120 --> 00:32:31,760
for the sake of presentation i want to

816
00:32:29,600 --> 00:32:34,000
keep everything simple

817
00:32:31,760 --> 00:32:34,000
okay

818
00:32:35,760 --> 00:32:39,760
as you're using type annotations you

819
00:32:38,480 --> 00:32:41,519
don't need a jit at all

820
00:32:39,760 --> 00:32:43,360
you could do that statically you just

821
00:32:41,519 --> 00:32:46,480
take the function

822
00:32:43,360 --> 00:32:50,158
and perform your static compilation

823
00:32:46,480 --> 00:32:52,640
and then under the binary

824
00:32:50,159 --> 00:32:53,360
into your python barcode and that's okay

825
00:32:52,640 --> 00:32:56,399
so

826
00:32:53,360 --> 00:32:57,439
why would you use a jit in your

827
00:32:56,399 --> 00:33:00,479
situation where

828
00:32:57,440 --> 00:33:02,320
you only use static information you are

829
00:33:00,480 --> 00:33:04,320
asking why i am using cheats

830
00:33:02,320 --> 00:33:05,918
when there is already defined type

831
00:33:04,320 --> 00:33:07,120
annotations i can just convert to

832
00:33:05,919 --> 00:33:08,240
functions by the ahead of time

833
00:33:07,120 --> 00:33:11,518
population

834
00:33:08,240 --> 00:33:13,760
because in the approach taken by like

835
00:33:11,519 --> 00:33:14,880
unleaded swallow uh they recurred the

836
00:33:13,760 --> 00:33:17,440
runtime data

837
00:33:14,880 --> 00:33:18,240
i want to keep that in the my slides but

838
00:33:17,440 --> 00:33:21,120
it doesn't fit

839
00:33:18,240 --> 00:33:22,960
so i have a project called swinging head

840
00:33:21,120 --> 00:33:24,559
which takes the exact thing

841
00:33:22,960 --> 00:33:26,880
like online as well and of course

842
00:33:24,559 --> 00:33:29,918
runtime data so you are right

843
00:33:26,880 --> 00:33:32,559
in this way uh it would make sense to

844
00:33:29,919 --> 00:33:34,320
not running jit but uh if you are going

845
00:33:32,559 --> 00:33:39,840
to record the runtime data

846
00:33:34,320 --> 00:33:39,840
or do other things you need to use git

847
00:33:41,519 --> 00:33:46,399
any more questions um

848
00:33:44,799 --> 00:33:49,760
when are you using the bytecode one

849
00:33:46,399 --> 00:33:52,959
versus the ast based

850
00:33:49,760 --> 00:33:54,000
to me ast is much more simpler to work

851
00:33:52,960 --> 00:33:56,000
on

852
00:33:54,000 --> 00:33:57,600
because you don't need to extra boost

853
00:33:56,000 --> 00:33:59,120
dropping code python offers an interface

854
00:33:57,600 --> 00:34:02,399
to access it

855
00:33:59,120 --> 00:34:05,600
but i want to show how only the solo and

856
00:34:02,399 --> 00:34:08,719
piston worked so i an example to

857
00:34:05,600 --> 00:34:11,598
bite god you say it does

858
00:34:08,719 --> 00:34:14,480
the future you see using the ist by this

859
00:34:11,599 --> 00:34:14,480
one as the future

860
00:34:17,280 --> 00:34:20,480
one of the shortcomings presented by the

861
00:34:19,599 --> 00:34:24,240
piston

862
00:34:20,480 --> 00:34:24,240
piston broker was that

863
00:34:24,719 --> 00:34:27,759
most of the python code is actually just

864
00:34:26,879 --> 00:34:30,399
glue

865
00:34:27,760 --> 00:34:33,040
calling native functions that's true for

866
00:34:30,399 --> 00:34:36,480
sustana library but that's also true for

867
00:34:33,040 --> 00:34:40,879
party package like numpy and it presents

868
00:34:36,480 --> 00:34:44,879
a very strong barrier to the optimizer

869
00:34:40,879 --> 00:34:48,399
unless so did you take that into account

870
00:34:44,879 --> 00:34:50,719
or when you see the

871
00:34:48,399 --> 00:34:52,159
a native function you're just calling it

872
00:34:50,719 --> 00:34:54,239
the python way and

873
00:34:52,159 --> 00:34:55,919
getting back the results uh you are

874
00:34:54,239 --> 00:34:58,399
asking if i am optimizing

875
00:34:55,918 --> 00:34:59,680
native functions with bootstrappingsd

876
00:34:58,400 --> 00:35:04,160
number does that

877
00:34:59,680 --> 00:35:04,160
but my jit compiler doesn't do that

878
00:35:07,280 --> 00:35:17,839
okay thank you okay

879
00:35:19,599 --> 00:35:21,680
you

