1
00:00:14,000 --> 00:00:18,160
okay thank you

2
00:00:15,599 --> 00:00:19,680
all right um let's get started i'll be

3
00:00:18,160 --> 00:00:22,640
talking about virta fs

4
00:00:19,680 --> 00:00:23,279
today vertfast is a shared file system

5
00:00:22,640 --> 00:00:25,119
um

6
00:00:23,279 --> 00:00:26,320
it's something that i've been involved

7
00:00:25,119 --> 00:00:28,960
in for the past

8
00:00:26,320 --> 00:00:31,039
year and a half or so amongst other

9
00:00:28,960 --> 00:00:33,360
projects

10
00:00:31,039 --> 00:00:34,800
the basic thing that virtaifest does is

11
00:00:33,360 --> 00:00:37,040
it takes a directory

12
00:00:34,800 --> 00:00:38,399
on the host and it lets the guest access

13
00:00:37,040 --> 00:00:40,320
those files

14
00:00:38,399 --> 00:00:41,920
it allows them to access them directly

15
00:00:40,320 --> 00:00:43,520
without a disk image so you don't need

16
00:00:41,920 --> 00:00:44,239
to create a disk image and a file system

17
00:00:43,520 --> 00:00:46,480
in there

18
00:00:44,239 --> 00:00:47,360
instead a directory that you already

19
00:00:46,480 --> 00:00:49,599
have mounted

20
00:00:47,360 --> 00:00:51,440
on the host is available to the guest

21
00:00:49,600 --> 00:00:52,559
and any i o is done directly to those

22
00:00:51,440 --> 00:00:54,640
files

23
00:00:52,559 --> 00:00:55,839
there are a bunch of use cases for this

24
00:00:54,640 --> 00:00:58,960
including containers

25
00:00:55,840 --> 00:01:00,879
kata containers can use it i'm not going

26
00:00:58,960 --> 00:01:02,480
to go into the use cases in this talk

27
00:01:00,879 --> 00:01:04,640
if you're interested in a general

28
00:01:02,480 --> 00:01:05,280
overview of why is vertifs being

29
00:01:04,640 --> 00:01:06,720
developed

30
00:01:05,280 --> 00:01:09,040
what can it do and what are the use

31
00:01:06,720 --> 00:01:10,080
cases please check out the kvm forum

32
00:01:09,040 --> 00:01:12,479
talk that was given

33
00:01:10,080 --> 00:01:14,400
last year in this presentation i'm going

34
00:01:12,479 --> 00:01:18,400
to be a bit more technical

35
00:01:14,400 --> 00:01:18,400
give you a tour of how it works

36
00:01:18,880 --> 00:01:23,679
in case this kind of summary of what it

37
00:01:21,759 --> 00:01:26,240
does didn't make a lot of sense

38
00:01:23,680 --> 00:01:27,360
let's take an example say you have our

39
00:01:26,240 --> 00:01:30,000
www

40
00:01:27,360 --> 00:01:32,640
on the host a directory that has your

41
00:01:30,000 --> 00:01:34,720
html files your website

42
00:01:32,640 --> 00:01:36,079
and you want to run your web server

43
00:01:34,720 --> 00:01:38,560
inside a virtual machine

44
00:01:36,079 --> 00:01:39,600
not on the host so you've got the files

45
00:01:38,560 --> 00:01:41,200
on the host

46
00:01:39,600 --> 00:01:42,640
but you want to run the web server

47
00:01:41,200 --> 00:01:46,079
inside the virtual machine

48
00:01:42,640 --> 00:01:48,560
maybe in order to get extra isolation

49
00:01:46,079 --> 00:01:49,600
okay we can do this with virta fs so

50
00:01:48,560 --> 00:01:52,640
here's the libert

51
00:01:49,600 --> 00:01:55,199
xml that passes through var ww

52
00:01:52,640 --> 00:01:56,880
to the guest and we can name that

53
00:01:55,200 --> 00:01:58,079
vertfest device and here we name it

54
00:01:56,880 --> 00:02:00,158
website

55
00:01:58,079 --> 00:02:02,719
so that when we're inside the virtual

56
00:02:00,159 --> 00:02:05,600
machine all you have to do to set it up

57
00:02:02,719 --> 00:02:07,759
is say mount vertifs website and then

58
00:02:05,600 --> 00:02:10,079
the directory where you want to have it

59
00:02:07,759 --> 00:02:11,680
and now this virtual machine has that

60
00:02:10,080 --> 00:02:13,599
directory from the host

61
00:02:11,680 --> 00:02:14,879
mounted inside the guest applications

62
00:02:13,599 --> 00:02:17,040
run as normal

63
00:02:14,879 --> 00:02:19,679
there's really nothing special after

64
00:02:17,040 --> 00:02:22,239
that you just have access to the files

65
00:02:19,680 --> 00:02:24,959
obviously the point of virtufs is that

66
00:02:22,239 --> 00:02:27,040
you only have access to that subtree

67
00:02:24,959 --> 00:02:28,800
that directory subtree on host that

68
00:02:27,040 --> 00:02:30,079
you're isolated to it you cannot break

69
00:02:28,800 --> 00:02:30,959
out and access all the other files

70
00:02:30,080 --> 00:02:34,640
that's one of the

71
00:02:30,959 --> 00:02:34,640
key security requirements

72
00:02:34,800 --> 00:02:38,560
i will give you a brief um uh benchmark

73
00:02:38,080 --> 00:02:41,200
that i

74
00:02:38,560 --> 00:02:43,040
that i ran recently uh but keep in mind

75
00:02:41,200 --> 00:02:45,119
i'm comparing verdio 9p here

76
00:02:43,040 --> 00:02:46,079
which is a previous shared file system

77
00:02:45,120 --> 00:02:49,920
uh that's

78
00:02:46,080 --> 00:02:51,599
in qemu and has linux support

79
00:02:49,920 --> 00:02:53,280
i'm comparing vertfs and i'm also

80
00:02:51,599 --> 00:02:55,200
comparing verteo block but please keep

81
00:02:53,280 --> 00:02:56,959
in mind that these things are

82
00:02:55,200 --> 00:02:58,480
they have lots of configuration settings

83
00:02:56,959 --> 00:02:59,840
and to be honest if i wanted to i could

84
00:02:58,480 --> 00:03:00,238
make this graph do lots of different

85
00:02:59,840 --> 00:03:01,680
things

86
00:03:00,239 --> 00:03:03,519
they're completely different code paths

87
00:03:01,680 --> 00:03:04,000
and stacks so it's hard to do real apple

88
00:03:03,519 --> 00:03:07,440
samples

89
00:03:04,000 --> 00:03:11,840
comparison what you're seeing here is um

90
00:03:07,440 --> 00:03:13,440
just the default setup of all of these

91
00:03:11,840 --> 00:03:15,519
and this is how they compare but i think

92
00:03:13,440 --> 00:03:17,599
the main message to take away here

93
00:03:15,519 --> 00:03:18,800
is that if you're already using virtio

94
00:03:17,599 --> 00:03:20,560
9p

95
00:03:18,800 --> 00:03:23,920
take a look at vfs because it should

96
00:03:20,560 --> 00:03:23,920
perform at least as well

97
00:03:24,000 --> 00:03:29,760
and virtua 9fs virto9p

98
00:03:27,760 --> 00:03:31,120
has been available in qme for some time

99
00:03:29,760 --> 00:03:32,959
vertiofs

100
00:03:31,120 --> 00:03:36,239
is going to be available starting from

101
00:03:32,959 --> 00:03:39,519
qmu 5.0 so the upcoming qmi release

102
00:03:36,239 --> 00:03:39,519
will have vertifs

103
00:03:39,680 --> 00:03:42,720
yes and the only other thing i'll say

104
00:03:41,440 --> 00:03:44,799
about these

105
00:03:42,720 --> 00:03:46,640
performance results is that obviously

106
00:03:44,799 --> 00:03:49,280
there's still a gap in some areas where

107
00:03:46,640 --> 00:03:51,279
virto block can perform better

108
00:03:49,280 --> 00:03:53,599
that's the yellow the yellow bars radio

109
00:03:51,280 --> 00:03:55,760
block

110
00:03:53,599 --> 00:03:57,040
and i didn't enable the dax feature

111
00:03:55,760 --> 00:03:58,560
which i'm going to explain later on in

112
00:03:57,040 --> 00:03:59,679
this presentation because that's not

113
00:03:58,560 --> 00:04:02,799
upstream

114
00:03:59,680 --> 00:04:02,799
in linux yet

115
00:04:03,200 --> 00:04:06,958
okay so now let's start talking about

116
00:04:05,120 --> 00:04:09,439
how it all works

117
00:04:06,959 --> 00:04:11,120
the basic idea of remote file system the

118
00:04:09,439 --> 00:04:12,159
two main components that you have in a

119
00:04:11,120 --> 00:04:14,400
remote file system

120
00:04:12,159 --> 00:04:16,000
is you have a transport and you have the

121
00:04:14,400 --> 00:04:17,120
protocol the transport is the

122
00:04:16,000 --> 00:04:19,279
communications link

123
00:04:17,120 --> 00:04:20,880
it allows a client to mount a file

124
00:04:19,279 --> 00:04:22,479
system from a server

125
00:04:20,880 --> 00:04:24,000
so the files and the directories that

126
00:04:22,479 --> 00:04:25,440
live on the server and the client can

127
00:04:24,000 --> 00:04:28,000
access them

128
00:04:25,440 --> 00:04:29,919
and then the protocol is the vocabulary

129
00:04:28,000 --> 00:04:32,160
that the client has in order to express

130
00:04:29,919 --> 00:04:33,520
things it wants to do on the files

131
00:04:32,160 --> 00:04:35,759
and think of lots of examples for these

132
00:04:33,520 --> 00:04:38,560
transports for example tcp

133
00:04:35,759 --> 00:04:39,840
or maybe usb or rdma they have different

134
00:04:38,560 --> 00:04:41,440
properties

135
00:04:39,840 --> 00:04:44,479
some of them are message passing some of

136
00:04:41,440 --> 00:04:44,479
them have shared memory

137
00:04:44,639 --> 00:04:49,280
for the for the protocols the nfs is

138
00:04:48,000 --> 00:04:51,280
probably the most well-known one

139
00:04:49,280 --> 00:04:53,280
and sifs is also very very widely used

140
00:04:51,280 --> 00:04:54,479
for windows file sharing

141
00:04:53,280 --> 00:04:56,719
and then you have other families of

142
00:04:54,479 --> 00:04:59,840
protocols like the old ftp

143
00:04:56,720 --> 00:05:01,440
or mtp which you use to transfer files

144
00:04:59,840 --> 00:05:02,880
on your phone

145
00:05:01,440 --> 00:05:04,880
and the interesting thing the reason i

146
00:05:02,880 --> 00:05:06,639
bring them up is because remember the

147
00:05:04,880 --> 00:05:08,400
protocol is the vocabulary of what your

148
00:05:06,639 --> 00:05:11,120
file system can do

149
00:05:08,400 --> 00:05:12,479
and these ftp and mtp they're transfer

150
00:05:11,120 --> 00:05:13,440
protocols they're not file system

151
00:05:12,479 --> 00:05:15,599
protocols

152
00:05:13,440 --> 00:05:16,639
so they focus on getting and putting

153
00:05:15,600 --> 00:05:18,320
entire files

154
00:05:16,639 --> 00:05:21,199
kind of like object storage and kind of

155
00:05:18,320 --> 00:05:24,800
like amazon s3

156
00:05:21,199 --> 00:05:26,479
whereas nfs implements a full kind of

157
00:05:24,800 --> 00:05:28,639
file system posix file system semantics

158
00:05:26,479 --> 00:05:30,320
where you can open a file

159
00:05:28,639 --> 00:05:32,960
and then do reads and lots of other

160
00:05:30,320 --> 00:05:34,719
operations on a more fine-grained basis

161
00:05:32,960 --> 00:05:36,719
what your protocol allows you to do is

162
00:05:34,720 --> 00:05:38,720
critical when it comes to application

163
00:05:36,720 --> 00:05:40,320
compatibility and also for performance

164
00:05:38,720 --> 00:05:41,199
so you want we wanted to get that right

165
00:05:40,320 --> 00:05:44,400
we wanted to choose

166
00:05:41,199 --> 00:05:44,400
the right kind of protocol

167
00:05:44,639 --> 00:05:48,479
okay so now that we have this framework

168
00:05:46,320 --> 00:05:49,280
how does vert fs fit in here how does it

169
00:05:48,479 --> 00:05:52,240
work so

170
00:05:49,280 --> 00:05:53,520
the protocol inverter fs is based on

171
00:05:52,240 --> 00:05:55,440
linux fuse

172
00:05:53,520 --> 00:05:57,280
but it is not just linux views it's not

173
00:05:55,440 --> 00:05:58,719
taking an existing fuse file system and

174
00:05:57,280 --> 00:05:59,919
running it over virtio

175
00:05:58,720 --> 00:06:01,759
there are some changes there are some

176
00:05:59,919 --> 00:06:03,599
changes to the architecture and we've

177
00:06:01,759 --> 00:06:04,720
also extended the protocol added some

178
00:06:03,600 --> 00:06:08,319
features to fuse

179
00:06:04,720 --> 00:06:10,000
to make it work for vertical fast

180
00:06:08,319 --> 00:06:12,240
the transport is what i o the only

181
00:06:10,000 --> 00:06:14,960
interesting thing there is that

182
00:06:12,240 --> 00:06:16,880
we also extended virtio we added shared

183
00:06:14,960 --> 00:06:17,919
memory resources to varreo and i'm going

184
00:06:16,880 --> 00:06:20,719
to go into how

185
00:06:17,919 --> 00:06:22,318
vfs can take advantage of shared memory

186
00:06:20,720 --> 00:06:24,400
to do things that network file systems

187
00:06:22,319 --> 00:06:26,240
can't do

188
00:06:24,400 --> 00:06:28,080
and so here's the picture you get the

189
00:06:26,240 --> 00:06:29,840
basic idea that virto is the transport

190
00:06:28,080 --> 00:06:32,960
it allows the client and the server

191
00:06:29,840 --> 00:06:36,239
to communicate in the case of rfs

192
00:06:32,960 --> 00:06:38,239
the server is called vertex fsd it's a

193
00:06:36,240 --> 00:06:40,639
process that runs on the host

194
00:06:38,240 --> 00:06:43,039
in order to emulate this virteo fs

195
00:06:40,639 --> 00:06:43,039
device

196
00:06:43,680 --> 00:06:50,080
okay so to get into this a bit more

197
00:06:46,800 --> 00:06:52,319
i'll give you a short overview of fuse

198
00:06:50,080 --> 00:06:53,440
the the linux file system protocol which

199
00:06:52,319 --> 00:06:55,360
which we started

200
00:06:53,440 --> 00:06:57,280
and the guest drivers also reuse that

201
00:06:55,360 --> 00:06:58,560
code so there's a lot of shared code

202
00:06:57,280 --> 00:07:02,479
between vfs

203
00:06:58,560 --> 00:07:04,080
and linux fuse fuse is a user space file

204
00:07:02,479 --> 00:07:05,039
system interface so that's that's its

205
00:07:04,080 --> 00:07:06,560
purpose

206
00:07:05,039 --> 00:07:08,719
basically what it does is when you have

207
00:07:06,560 --> 00:07:11,199
a user space application that accesses a

208
00:07:08,720 --> 00:07:13,199
file say we want to open the file foo

209
00:07:11,199 --> 00:07:14,880
um that application will make a system

210
00:07:13,199 --> 00:07:16,880
call

211
00:07:14,880 --> 00:07:18,319
and the fuse kernel module can then

212
00:07:16,880 --> 00:07:19,759
handle that system call

213
00:07:18,319 --> 00:07:21,360
because it's responsible for that

214
00:07:19,759 --> 00:07:23,360
mounted file system

215
00:07:21,360 --> 00:07:25,759
um but it doesn't know what to do with

216
00:07:23,360 --> 00:07:26,960
it instead it sends a message a fuse

217
00:07:25,759 --> 00:07:28,560
open message

218
00:07:26,960 --> 00:07:30,880
to the file system server which is

219
00:07:28,560 --> 00:07:32,240
running as a user space process

220
00:07:30,880 --> 00:07:34,400
and that's basically the fuse kernel

221
00:07:32,240 --> 00:07:35,599
modules role it forwards basically what

222
00:07:34,400 --> 00:07:38,479
our system calls

223
00:07:35,599 --> 00:07:40,560
to a user space process that implements

224
00:07:38,479 --> 00:07:42,639
the file system

225
00:07:40,560 --> 00:07:44,560
it was merged in 2005 so it's very

226
00:07:42,639 --> 00:07:46,319
mature it's widely available

227
00:07:44,560 --> 00:07:47,919
even if you haven't used it directly

228
00:07:46,319 --> 00:07:48,960
you've probably still used it somehow

229
00:07:47,919 --> 00:07:51,280
for example

230
00:07:48,960 --> 00:07:52,318
when i connect my phone the mtp protocol

231
00:07:51,280 --> 00:07:54,719
implementation

232
00:07:52,319 --> 00:07:56,160
that gets used is a fuse file system so

233
00:07:54,720 --> 00:07:59,199
it's a user space file system it's not a

234
00:07:56,160 --> 00:08:00,560
kernel driver

235
00:07:59,199 --> 00:08:02,240
one of the nice things about fuse and

236
00:08:00,560 --> 00:08:05,199
one of the reasons why

237
00:08:02,240 --> 00:08:06,560
we chose it for vertifs is that it's

238
00:08:05,199 --> 00:08:09,120
very closely

239
00:08:06,560 --> 00:08:09,919
associated with what native linux file

240
00:08:09,120 --> 00:08:12,479
systems can do

241
00:08:09,919 --> 00:08:14,240
because it's a linux kernel module so

242
00:08:12,479 --> 00:08:16,080
it's not just a posix file system and it

243
00:08:14,240 --> 00:08:17,599
has that entire vocabulary that

244
00:08:16,080 --> 00:08:19,919
we need in order to be compatible with

245
00:08:17,599 --> 00:08:21,360
existing applications it also has linux

246
00:08:19,919 --> 00:08:23,120
extensions new features like

247
00:08:21,360 --> 00:08:26,400
copy offloading and stuff like that can

248
00:08:23,120 --> 00:08:28,479
be done by fuse which is great

249
00:08:26,400 --> 00:08:32,000
and it's also extensible it's a protocol

250
00:08:28,479 --> 00:08:32,000
that you can add new features to

251
00:08:32,240 --> 00:08:35,919
um let's look at the protocol a little

252
00:08:34,000 --> 00:08:38,080
bit

253
00:08:35,919 --> 00:08:39,199
the header file is the linuxfuse.h it's

254
00:08:38,080 --> 00:08:41,519
the kernel header so if you have it

255
00:08:39,200 --> 00:08:44,080
installed on your machine

256
00:08:41,519 --> 00:08:45,040
you can you can take a look that file

257
00:08:44,080 --> 00:08:47,120
has all the

258
00:08:45,040 --> 00:08:48,640
constants and the structs for the fuse

259
00:08:47,120 --> 00:08:51,040
protocol

260
00:08:48,640 --> 00:08:52,640
and one thing about this header file is

261
00:08:51,040 --> 00:08:54,399
that it's undocumented so you basically

262
00:08:52,640 --> 00:08:55,600
just have all the constants and the

263
00:08:54,399 --> 00:08:57,600
structs which is

264
00:08:55,600 --> 00:08:58,959
not great if you want to write a vert fs

265
00:08:57,600 --> 00:09:01,839
implementation

266
00:08:58,959 --> 00:09:03,199
or a low level fuse some kind of fuse

267
00:09:01,839 --> 00:09:04,640
application

268
00:09:03,200 --> 00:09:06,800
you do have to look at the fuse source

269
00:09:04,640 --> 00:09:09,920
code to understand it however

270
00:09:06,800 --> 00:09:12,160
this file is user space avi

271
00:09:09,920 --> 00:09:14,560
so it's a kernel api that's exported to

272
00:09:12,160 --> 00:09:16,560
user space which means it's stable

273
00:09:14,560 --> 00:09:17,839
the kernel is not allowed to change the

274
00:09:16,560 --> 00:09:18,800
definition of these structs in these

275
00:09:17,839 --> 00:09:20,640
protocols

276
00:09:18,800 --> 00:09:22,000
and if you upgrade software versions and

277
00:09:20,640 --> 00:09:23,760
so on they

278
00:09:22,000 --> 00:09:25,279
they will remain compatible so that's

279
00:09:23,760 --> 00:09:27,200
really really important

280
00:09:25,279 --> 00:09:29,360
it means that if you have a virtual

281
00:09:27,200 --> 00:09:32,480
machine running vertfs

282
00:09:29,360 --> 00:09:34,399
and you upgrade your host or vice versa

283
00:09:32,480 --> 00:09:35,519
let's say you have a new virtual machine

284
00:09:34,399 --> 00:09:37,040
and an old host

285
00:09:35,519 --> 00:09:38,640
they will still be able to communicate

286
00:09:37,040 --> 00:09:39,439
because this protocol is stable and it

287
00:09:38,640 --> 00:09:43,199
has

288
00:09:39,440 --> 00:09:43,200
feature negotiation and all these things

289
00:09:44,080 --> 00:09:47,040
and by the way if you're if you're

290
00:09:45,200 --> 00:09:48,160
wondering why do people even use fuse if

291
00:09:47,040 --> 00:09:49,680
it's undocumented

292
00:09:48,160 --> 00:09:51,839
that's because most people use fuse

293
00:09:49,680 --> 00:09:54,959
bindings like say the python bindings

294
00:09:51,839 --> 00:09:57,200
or the c library um for

295
00:09:54,959 --> 00:09:58,479
fuse and they do have documentation so

296
00:09:57,200 --> 00:10:00,000
even if this low-level stuff doesn't

297
00:09:58,480 --> 00:10:01,680
have documentation you can look there as

298
00:10:00,000 --> 00:10:04,640
well

299
00:10:01,680 --> 00:10:06,160
okay so let me tell you a little bit

300
00:10:04,640 --> 00:10:08,480
about traditional fuse

301
00:10:06,160 --> 00:10:09,279
which vertfest builds on and then we can

302
00:10:08,480 --> 00:10:12,480
look at how

303
00:10:09,279 --> 00:10:14,640
we mapped it all to verdejo

304
00:10:12,480 --> 00:10:18,959
so as i mentioned before the file system

305
00:10:14,640 --> 00:10:21,279
runs in a user space process

306
00:10:18,959 --> 00:10:22,800
and the way that this works is that the

307
00:10:21,279 --> 00:10:26,000
fuse kernel module has

308
00:10:22,800 --> 00:10:28,319
a dev fuse character device

309
00:10:26,000 --> 00:10:29,760
it has a character device that the file

310
00:10:28,320 --> 00:10:31,440
system server opens

311
00:10:29,760 --> 00:10:33,040
and it can read the protocol messages

312
00:10:31,440 --> 00:10:34,160
that it needs to process from that

313
00:10:33,040 --> 00:10:36,000
character device

314
00:10:34,160 --> 00:10:37,519
and it writes the responses back to that

315
00:10:36,000 --> 00:10:39,040
character device so that's usually what

316
00:10:37,519 --> 00:10:40,079
a fuse server is doing it's reading

317
00:10:39,040 --> 00:10:42,240
stuff from devviews

318
00:10:40,079 --> 00:10:43,920
and it's writing the responses back the

319
00:10:42,240 --> 00:10:46,240
only exception is that there are

320
00:10:43,920 --> 00:10:47,199
server initiated messages they're called

321
00:10:46,240 --> 00:10:48,480
notifications

322
00:10:47,200 --> 00:10:50,720
they're rarely used but there's some

323
00:10:48,480 --> 00:10:52,320
features in fuse where the server can

324
00:10:50,720 --> 00:10:54,959
actually go and send a request

325
00:10:52,320 --> 00:10:55,680
to the client and then get a response

326
00:10:54,959 --> 00:10:59,599
back

327
00:10:55,680 --> 00:11:02,000
it just inverts that relationship

328
00:10:59,600 --> 00:11:03,519
okay so what's the design of the virtio

329
00:11:02,000 --> 00:11:06,560
device um

330
00:11:03,519 --> 00:11:06,880
the virto device model which which is

331
00:11:06,560 --> 00:11:08,479
the

332
00:11:06,880 --> 00:11:10,720
the device that the virtual machine will

333
00:11:08,480 --> 00:11:13,120
see in order to access the file system

334
00:11:10,720 --> 00:11:14,000
the virtio device model the main concept

335
00:11:13,120 --> 00:11:15,440
in it is called avert

336
00:11:14,000 --> 00:11:17,440
queue and that's a message queue that

337
00:11:15,440 --> 00:11:20,240
allows a driver inside the guest

338
00:11:17,440 --> 00:11:23,120
to put to send messages to a device

339
00:11:20,240 --> 00:11:24,320
that's implemented on the host

340
00:11:23,120 --> 00:11:27,279
and so the main thing that we really

341
00:11:24,320 --> 00:11:29,519
need is a request spurt queue

342
00:11:27,279 --> 00:11:32,160
where you can place fuse messages so

343
00:11:29,519 --> 00:11:34,160
fuse requests are sent by a guest driver

344
00:11:32,160 --> 00:11:35,360
placed onto the vert queue and then the

345
00:11:34,160 --> 00:11:38,560
device

346
00:11:35,360 --> 00:11:39,600
verde of sd that process will see those

347
00:11:38,560 --> 00:11:41,279
requests

348
00:11:39,600 --> 00:11:43,040
will process them and send back a

349
00:11:41,279 --> 00:11:45,040
response

350
00:11:43,040 --> 00:11:46,800
there's one weird thing about fuse it

351
00:11:45,040 --> 00:11:49,760
supports request priorities

352
00:11:46,800 --> 00:11:50,479
because you can cancel requests so if

353
00:11:49,760 --> 00:11:52,800
you have say

354
00:11:50,480 --> 00:11:54,399
50 requests queued up and ready to do

355
00:11:52,800 --> 00:11:56,560
some i o on your file system

356
00:11:54,399 --> 00:11:58,079
but then you kill an application for

357
00:11:56,560 --> 00:11:59,760
example you might want to

358
00:11:58,079 --> 00:12:01,199
cancel those requests that that

359
00:11:59,760 --> 00:12:04,079
application has enqueued because that

360
00:12:01,200 --> 00:12:06,320
application is being terminated anyway

361
00:12:04,079 --> 00:12:08,000
so there's a fuse interrupt message but

362
00:12:06,320 --> 00:12:08,720
one problem we have when mapping this to

363
00:12:08,000 --> 00:12:11,600
virtio

364
00:12:08,720 --> 00:12:12,399
is that vert queues are append only you

365
00:12:11,600 --> 00:12:15,200
can't go

366
00:12:12,399 --> 00:12:16,079
and modify the vert queues the v-ring in

367
00:12:15,200 --> 00:12:18,880
memory

368
00:12:16,079 --> 00:12:20,319
once you've put stuff in there so we had

369
00:12:18,880 --> 00:12:22,720
this problem how do you

370
00:12:20,320 --> 00:12:24,079
then send that fuse interrupt message to

371
00:12:22,720 --> 00:12:26,000
the device

372
00:12:24,079 --> 00:12:27,519
if there's a bunch of traffic cued up in

373
00:12:26,000 --> 00:12:29,360
front of it and so we just added a high

374
00:12:27,519 --> 00:12:30,800
priority queue that that handles the

375
00:12:29,360 --> 00:12:32,000
fuse interrupt message

376
00:12:30,800 --> 00:12:34,800
and anything else that needs to be

377
00:12:32,000 --> 00:12:37,120
prioritized will go there

378
00:12:34,800 --> 00:12:39,120
the final vert queue that that has been

379
00:12:37,120 --> 00:12:41,519
added is a notifications queue

380
00:12:39,120 --> 00:12:43,279
and that handles that server-initiated

381
00:12:41,519 --> 00:12:44,480
communication that i mentioned before

382
00:12:43,279 --> 00:12:46,959
because that's going in the opposite

383
00:12:44,480 --> 00:12:49,040
direction

384
00:12:46,959 --> 00:12:50,638
um the only other thing to know about

385
00:12:49,040 --> 00:12:52,800
the vertfest device

386
00:12:50,639 --> 00:12:54,399
is that in the configuration space which

387
00:12:52,800 --> 00:12:56,479
is um

388
00:12:54,399 --> 00:12:58,240
an area of data that the device can

389
00:12:56,480 --> 00:12:59,839
expose to a guest driver

390
00:12:58,240 --> 00:13:01,600
there's a tag and that's the mount

391
00:12:59,839 --> 00:13:02,800
identifier or the file system label or

392
00:13:01,600 --> 00:13:04,079
whatever you want to call it we call it

393
00:13:02,800 --> 00:13:06,160
a tag

394
00:13:04,079 --> 00:13:07,279
and that's how you can name your device

395
00:13:06,160 --> 00:13:09,120
because you can have

396
00:13:07,279 --> 00:13:10,639
10 vert fs devices attached to one

397
00:13:09,120 --> 00:13:11,920
virtual machine how do you know which

398
00:13:10,639 --> 00:13:13,360
one is which file system you have to

399
00:13:11,920 --> 00:13:17,839
give them names so

400
00:13:13,360 --> 00:13:20,880
that that's how this works okay

401
00:13:17,839 --> 00:13:22,959
um now let me give you um a quick

402
00:13:20,880 --> 00:13:24,720
overview of how the protocol and the

403
00:13:22,959 --> 00:13:26,800
communication work say you want to read

404
00:13:24,720 --> 00:13:28,560
a file

405
00:13:26,800 --> 00:13:30,000
and you haven't started up yet the

406
00:13:28,560 --> 00:13:31,119
driver hasn't started up yet the first

407
00:13:30,000 --> 00:13:33,200
thing it will do

408
00:13:31,120 --> 00:13:34,720
is it will send a fuse in it message to

409
00:13:33,200 --> 00:13:36,639
create a new fuse session so this

410
00:13:34,720 --> 00:13:39,920
negotiates a few parameters and

411
00:13:36,639 --> 00:13:41,839
prepares you to send fuse commands once

412
00:13:39,920 --> 00:13:46,639
the fuse session has been started up

413
00:13:41,839 --> 00:13:49,519
you can issue normal fuse commands

414
00:13:46,639 --> 00:13:50,880
one thing that might be a bit unusual is

415
00:13:49,519 --> 00:13:52,160
that if you're used to user space

416
00:13:50,880 --> 00:13:54,480
programming

417
00:13:52,160 --> 00:13:55,519
you're used to using paths to open files

418
00:13:54,480 --> 00:13:57,519
and then you get it back a file

419
00:13:55,519 --> 00:13:59,199
descriptor and then you can

420
00:13:57,519 --> 00:14:00,880
use other syscalls to do things on those

421
00:13:59,199 --> 00:14:04,000
files

422
00:14:00,880 --> 00:14:05,519
but posix file systems actually have

423
00:14:04,000 --> 00:14:07,760
another concept they have another layer

424
00:14:05,519 --> 00:14:08,399
of indirection because when you look up

425
00:14:07,760 --> 00:14:11,279
a path

426
00:14:08,399 --> 00:14:11,920
a single file say etc password can

427
00:14:11,279 --> 00:14:14,240
actually have

428
00:14:11,920 --> 00:14:16,000
multiple file names pointing to that

429
00:14:14,240 --> 00:14:17,519
same one file

430
00:14:16,000 --> 00:14:19,600
that's what hard links are if you create

431
00:14:17,519 --> 00:14:21,360
hard links you're giving

432
00:14:19,600 --> 00:14:23,040
one file multiple names and that's why

433
00:14:21,360 --> 00:14:25,120
files posix file system

434
00:14:23,040 --> 00:14:27,279
systems distinguish between paths and

435
00:14:25,120 --> 00:14:28,639
inodes the inode is really what the file

436
00:14:27,279 --> 00:14:30,560
is and then you have multiple directory

437
00:14:28,639 --> 00:14:32,079
entries pointing to the same keynote

438
00:14:30,560 --> 00:14:33,920
and the even more fun thing is you can

439
00:14:32,079 --> 00:14:34,719
also have files you can have inodes that

440
00:14:33,920 --> 00:14:37,519
have no

441
00:14:34,720 --> 00:14:39,519
path name at all because you open a file

442
00:14:37,519 --> 00:14:42,399
you delete the file from the file system

443
00:14:39,519 --> 00:14:44,880
and yet you can still access that file

444
00:14:42,399 --> 00:14:46,560
some applications make use of this

445
00:14:44,880 --> 00:14:48,480
and it basically means that you need to

446
00:14:46,560 --> 00:14:49,760
separate the concept of an inode from a

447
00:14:48,480 --> 00:14:51,360
path

448
00:14:49,760 --> 00:14:53,279
so in user space programming you're

449
00:14:51,360 --> 00:14:55,600
often doing stuff with paths but

450
00:14:53,279 --> 00:14:56,399
the way fuse works is first we need to

451
00:14:55,600 --> 00:14:59,040
look up

452
00:14:56,399 --> 00:15:00,639
the path and resolve it to a node id

453
00:14:59,040 --> 00:15:02,240
once we have the node id we can do other

454
00:15:00,639 --> 00:15:03,199
stuff like opening the file and so on so

455
00:15:02,240 --> 00:15:04,800
that's what you're seeing here so you

456
00:15:03,199 --> 00:15:07,599
send a fuse lookup

457
00:15:04,800 --> 00:15:09,599
you look up that path you get the file

458
00:15:07,600 --> 00:15:11,440
and what you get is this node id this

459
00:15:09,600 --> 00:15:13,199
inode

460
00:15:11,440 --> 00:15:15,360
and then you can do things to it you can

461
00:15:13,199 --> 00:15:17,599
open it and then that gives you a file

462
00:15:15,360 --> 00:15:19,839
handle which is like a file descriptor

463
00:15:17,600 --> 00:15:20,800
and then you can read so that's the

464
00:15:19,839 --> 00:15:22,959
basic flow

465
00:15:20,800 --> 00:15:24,240
so say you wanted to implement a

466
00:15:22,959 --> 00:15:26,319
bootloader

467
00:15:24,240 --> 00:15:28,000
for vertifs that allows you to to go

468
00:15:26,320 --> 00:15:28,639
into a vertifast file system grab a

469
00:15:28,000 --> 00:15:30,639
kernel

470
00:15:28,639 --> 00:15:33,519
these four messages are basically what

471
00:15:30,639 --> 00:15:33,519
you would need to implement

472
00:15:33,839 --> 00:15:37,279
okay one of the things about this flow

473
00:15:35,839 --> 00:15:40,320
that i've showed you here though

474
00:15:37,279 --> 00:15:41,920
is that every single bit of io requires

475
00:15:40,320 --> 00:15:44,079
communication

476
00:15:41,920 --> 00:15:45,759
we need to talk to vertfesty the guest

477
00:15:44,079 --> 00:15:49,599
needs to talk to verdifsd

478
00:15:45,759 --> 00:15:52,399
in order to read any piece of a file

479
00:15:49,600 --> 00:15:54,320
isn't there a way to just give the

480
00:15:52,399 --> 00:15:55,920
contents of the file to the guests and

481
00:15:54,320 --> 00:15:57,440
let it directly access them

482
00:15:55,920 --> 00:15:58,959
without always having to communicate

483
00:15:57,440 --> 00:16:00,880
with vertf sd that would make things

484
00:15:58,959 --> 00:16:03,518
faster

485
00:16:00,880 --> 00:16:04,880
and even more so that fuse read or a

486
00:16:03,519 --> 00:16:06,480
fuse write command

487
00:16:04,880 --> 00:16:08,000
they involve guest memory so what you're

488
00:16:06,480 --> 00:16:11,519
doing is you're copying data

489
00:16:08,000 --> 00:16:13,279
either from the host into guest ram

490
00:16:11,519 --> 00:16:14,720
or from gastronomy you're writing data

491
00:16:13,279 --> 00:16:16,560
to the host

492
00:16:14,720 --> 00:16:18,560
is there a way to avoid these data

493
00:16:16,560 --> 00:16:19,439
copies these data copies are bad because

494
00:16:18,560 --> 00:16:20,800
say you have a

495
00:16:19,440 --> 00:16:23,120
read-only directory that you want to

496
00:16:20,800 --> 00:16:25,199
share with 10 guests or 100 guests

497
00:16:23,120 --> 00:16:27,759
do they all need to take copies of the

498
00:16:25,199 --> 00:16:28,160
data into guest ram in order to process

499
00:16:27,759 --> 00:16:29,440
it

500
00:16:28,160 --> 00:16:32,000
wouldn't it be good if there's a way to

501
00:16:29,440 --> 00:16:33,519
share this so vertfest has an

502
00:16:32,000 --> 00:16:35,360
experimental feature called

503
00:16:33,519 --> 00:16:36,560
dax it's not yet upstream but it's being

504
00:16:35,360 --> 00:16:38,560
worked on and

505
00:16:36,560 --> 00:16:40,160
it already runs but it needs some some

506
00:16:38,560 --> 00:16:42,239
additional performance optimization some

507
00:16:40,160 --> 00:16:45,040
more code review and so on

508
00:16:42,240 --> 00:16:46,079
what it does is instead of doing io

509
00:16:45,040 --> 00:16:48,880
where you copy

510
00:16:46,079 --> 00:16:50,239
data instead of sending commands for

511
00:16:48,880 --> 00:16:51,600
every single i o and constantly

512
00:16:50,240 --> 00:16:53,519
communicating

513
00:16:51,600 --> 00:16:54,880
it allows the guest driver to set up a

514
00:16:53,519 --> 00:16:58,079
mapping and

515
00:16:54,880 --> 00:16:58,560
map a region of the file into the memory

516
00:16:58,079 --> 00:17:01,359
space

517
00:16:58,560 --> 00:17:02,560
of the guest so now the guest can access

518
00:17:01,360 --> 00:17:05,839
the pages

519
00:17:02,560 --> 00:17:07,520
from the host directly

520
00:17:05,839 --> 00:17:09,280
and the way this works is that the

521
00:17:07,520 --> 00:17:11,599
device has the uh

522
00:17:09,280 --> 00:17:14,799
a memory region called the dax window

523
00:17:11,599 --> 00:17:16,958
it's a shared memory region

524
00:17:14,799 --> 00:17:20,000
so that's why we needed that virtio

525
00:17:16,959 --> 00:17:22,720
extension to add shared memory to vario

526
00:17:20,000 --> 00:17:23,839
that's what this enables so let me show

527
00:17:22,720 --> 00:17:25,120
you the the flow

528
00:17:23,839 --> 00:17:27,359
pretty similar say you want to read a

529
00:17:25,119 --> 00:17:29,199
file but now instead of doing fuse read

530
00:17:27,359 --> 00:17:31,199
you just set up a mapping once

531
00:17:29,200 --> 00:17:32,559
and once you set up that memory mapping

532
00:17:31,200 --> 00:17:34,640
you can just do

533
00:17:32,559 --> 00:17:35,840
load and store instructions cpu

534
00:17:34,640 --> 00:17:38,000
instructions you no longer have to

535
00:17:35,840 --> 00:17:40,959
communicate with the fuse

536
00:17:38,000 --> 00:17:42,160
with the vertfsd process anymore because

537
00:17:40,960 --> 00:17:43,600
you have those memory pages and you can

538
00:17:42,160 --> 00:17:44,640
just access them directly

539
00:17:43,600 --> 00:17:46,959
so that's great if you want to do

540
00:17:44,640 --> 00:17:48,640
frequent i o

541
00:17:46,960 --> 00:17:50,480
and it also reduces the memory footprint

542
00:17:48,640 --> 00:17:51,840
if many vms are sharing the same thing

543
00:17:50,480 --> 00:17:54,799
because they can share the same host

544
00:17:51,840 --> 00:17:54,799
page cache pages

545
00:17:55,840 --> 00:18:00,720
okay and the i think the final thing i

546
00:17:58,160 --> 00:18:02,160
want to say is that the virta fsd

547
00:18:00,720 --> 00:18:04,000
implementation that's available on the

548
00:18:02,160 --> 00:18:07,039
host what it does today

549
00:18:04,000 --> 00:18:07,360
is it takes the sub directory and shares

550
00:18:07,039 --> 00:18:11,200
it

551
00:18:07,360 --> 00:18:13,760
with the guest however vert fs is a

552
00:18:11,200 --> 00:18:15,520
standard specification you can implement

553
00:18:13,760 --> 00:18:17,280
your own vertfsd

554
00:18:15,520 --> 00:18:19,600
maybe you have a distributed storage

555
00:18:17,280 --> 00:18:22,240
system that you want to integrate

556
00:18:19,600 --> 00:18:23,840
or maybe you want to export a synthetic

557
00:18:22,240 --> 00:18:24,480
file system that has some data that's

558
00:18:23,840 --> 00:18:26,080
relevant

559
00:18:24,480 --> 00:18:28,000
to your guests that you'd like to make

560
00:18:26,080 --> 00:18:30,320
available to guests you can do that

561
00:18:28,000 --> 00:18:31,919
with virta fs similar to how you could

562
00:18:30,320 --> 00:18:34,080
write fuse file systems to have your own

563
00:18:31,919 --> 00:18:35,679
custom file system

564
00:18:34,080 --> 00:18:37,760
either you can use the vertices code

565
00:18:35,679 --> 00:18:39,280
base as your starting point if you want

566
00:18:37,760 --> 00:18:41,679
or if you want to go low level or write

567
00:18:39,280 --> 00:18:44,399
it in a different language

568
00:18:41,679 --> 00:18:46,160
just look at the verteo specification

569
00:18:44,400 --> 00:18:48,000
and that covers how the video device

570
00:18:46,160 --> 00:18:50,400
works and you can

571
00:18:48,000 --> 00:18:52,000
implement your own thing you're welcome

572
00:18:50,400 --> 00:18:54,320
to to come chat

573
00:18:52,000 --> 00:18:55,039
i'd love to talk about this if you have

574
00:18:54,320 --> 00:18:57,200
things that

575
00:18:55,039 --> 00:18:59,520
you think use cases that would be good

576
00:18:57,200 --> 00:18:59,520
for this

577
00:19:00,080 --> 00:19:11,840
that's it any questions

578
00:19:18,799 --> 00:19:23,360
yeah so the question was can your entire

579
00:19:21,360 --> 00:19:25,520
guest file system be vertfs

580
00:19:23,360 --> 00:19:27,199
yes it can you can boot directly from

581
00:19:25,520 --> 00:19:29,760
virta fs

582
00:19:27,200 --> 00:19:31,440
and that's really nice because it's kind

583
00:19:29,760 --> 00:19:32,960
of like setting up a ch root environment

584
00:19:31,440 --> 00:19:34,400
or a container environment

585
00:19:32,960 --> 00:19:36,640
if you have a path and you've got your

586
00:19:34,400 --> 00:19:38,559
full root file system in there

587
00:19:36,640 --> 00:19:39,919
you can just boot from it the only thing

588
00:19:38,559 --> 00:19:41,760
is that right now

589
00:19:39,919 --> 00:19:43,440
the syntax for doing it is a little bit

590
00:19:41,760 --> 00:19:46,320
awkward because linux

591
00:19:43,440 --> 00:19:48,320
does not have um does not have a nice

592
00:19:46,320 --> 00:19:51,600
syntax for it right now there's

593
00:19:48,320 --> 00:19:52,480
there's i have sent a patch and it needs

594
00:19:51,600 --> 00:19:53,918
more polishing

595
00:19:52,480 --> 00:19:56,000
in order to have a nice syntax for it

596
00:19:53,919 --> 00:20:07,840
but it can be done and it's convenient

597
00:19:56,000 --> 00:20:07,840
it's nice

598
00:20:08,480 --> 00:20:16,159
but when you mention shared memory

599
00:20:12,559 --> 00:20:21,840
this is strictly the hypervisor

600
00:20:16,159 --> 00:20:21,840
responsibility to set up

601
00:20:30,080 --> 00:20:34,639
okay yeah so the question is to use this

602
00:20:32,880 --> 00:20:37,919
shared memory feature and by the way

603
00:20:34,640 --> 00:20:39,039
it's optional um you can run vfs without

604
00:20:37,919 --> 00:20:43,360
dax and then you don't

605
00:20:39,039 --> 00:20:45,840
use the shared memory stuff so

606
00:20:43,360 --> 00:20:46,719
the the virtio device model itself

607
00:20:45,840 --> 00:20:48,399
doesn't assume

608
00:20:46,720 --> 00:20:50,400
shared memory so this is kind of a

609
00:20:48,400 --> 00:20:53,120
special thing and

610
00:20:50,400 --> 00:20:54,960
virdeo has several different transports

611
00:20:53,120 --> 00:20:57,360
there's a pci transport which is used

612
00:20:54,960 --> 00:20:58,159
mostly on x86 there's an mmio transport

613
00:20:57,360 --> 00:21:00,799
and then for

614
00:20:58,159 --> 00:21:02,080
s390 mainframe there's another one and

615
00:21:00,799 --> 00:21:04,400
it depends on your transport

616
00:21:02,080 --> 00:21:05,199
whether shared memory is a feature

617
00:21:04,400 --> 00:21:06,400
that's available

618
00:21:05,200 --> 00:21:08,400
so you might not be able to use this on

619
00:21:06,400 --> 00:21:10,320
all transports the actual

620
00:21:08,400 --> 00:21:12,320
if you are asking about whether the data

621
00:21:10,320 --> 00:21:14,080
layout in that shared memory region is

622
00:21:12,320 --> 00:21:17,120
standardized is that what you were

623
00:21:14,080 --> 00:21:17,120
wondering about

624
00:21:24,000 --> 00:21:31,840
okay yeah is it a generic concept

625
00:21:32,000 --> 00:21:35,919
yes okay so the question was this shared

626
00:21:34,559 --> 00:21:38,559
memory thing that verify you

627
00:21:35,919 --> 00:21:39,120
is using is it specific or is this a

628
00:21:38,559 --> 00:21:41,520
general

629
00:21:39,120 --> 00:21:42,959
virtio feature that other video devices

630
00:21:41,520 --> 00:21:45,360
could use and so on yes it is

631
00:21:42,960 --> 00:21:47,120
it's it's generic um and so the way it

632
00:21:45,360 --> 00:21:49,918
works is that in the vertio spec

633
00:21:47,120 --> 00:21:51,199
a device can say um it can have any

634
00:21:49,919 --> 00:21:52,640
device can have a number of shared

635
00:21:51,200 --> 00:21:53,520
memory regions that perform different

636
00:21:52,640 --> 00:21:54,880
functions

637
00:21:53,520 --> 00:21:56,480
and then how that's mapped whether

638
00:21:54,880 --> 00:21:57,760
that's done over pci and all those kind

639
00:21:56,480 --> 00:21:59,440
of things is

640
00:21:57,760 --> 00:22:01,679
any device can use it and others will i

641
00:21:59,440 --> 00:22:03,919
think virteo gpu already has a use case

642
00:22:01,679 --> 00:22:03,919
for it

643
00:22:08,480 --> 00:22:14,480
one more um

644
00:22:12,400 --> 00:22:15,760
problems with a uh permissions on the

645
00:22:14,480 --> 00:22:18,000
files so

646
00:22:15,760 --> 00:22:19,360
it was kind of a mess to match

647
00:22:18,000 --> 00:22:23,120
permission on the host and

648
00:22:19,360 --> 00:22:24,639
the guest um how is it working with ifs

649
00:22:23,120 --> 00:22:28,639
is different or

650
00:22:24,640 --> 00:22:30,400
can we okay so yeah the question is how

651
00:22:28,640 --> 00:22:32,799
how are how do permissions work maybe

652
00:22:30,400 --> 00:22:34,880
how are uids and gids mapped

653
00:22:32,799 --> 00:22:36,240
because you have your guest kernel and

654
00:22:34,880 --> 00:22:39,679
in there you have

655
00:22:36,240 --> 00:22:41,120
root and various users and on the host

656
00:22:39,679 --> 00:22:42,960
that's a different system it can have

657
00:22:41,120 --> 00:22:44,799
different set of users how do you map

658
00:22:42,960 --> 00:22:49,440
your ids and gids well

659
00:22:44,799 --> 00:22:51,918
at the moment what virta fsd does is

660
00:22:49,440 --> 00:22:54,400
at the moment what vertfusd does is you

661
00:22:51,919 --> 00:22:56,559
give it a subdirectory and

662
00:22:54,400 --> 00:22:57,919
you are allowing the guests to set the

663
00:22:56,559 --> 00:23:00,480
uids and the gids

664
00:22:57,919 --> 00:23:03,600
within that subdirectory so that

665
00:23:00,480 --> 00:23:05,120
application normal applications can run

666
00:23:03,600 --> 00:23:07,280
you know a full system can run with

667
00:23:05,120 --> 00:23:09,600
different uids and so on

668
00:23:07,280 --> 00:23:10,879
um and the uids are just going through

669
00:23:09,600 --> 00:23:12,399
one to one

670
00:23:10,880 --> 00:23:15,120
if you want to do some kind of mapping

671
00:23:12,400 --> 00:23:18,320
you would have to do something else like

672
00:23:15,120 --> 00:23:21,199
some kind of uid shifting and so on

673
00:23:18,320 --> 00:23:23,200
uh vertfest d itself does not implement

674
00:23:21,200 --> 00:23:25,360
that but there are other ways

675
00:23:23,200 --> 00:23:26,720
like using kernel modules and so on to

676
00:23:25,360 --> 00:23:30,000
stack it on top

677
00:23:26,720 --> 00:23:30,000
and map the uids

678
00:23:33,919 --> 00:23:36,960
yeah so so with se linux um i can't give

679
00:23:36,640 --> 00:23:38,880
you

680
00:23:36,960 --> 00:23:41,679
the exact so the question was does

681
00:23:38,880 --> 00:23:42,960
vertfest support sc linux and and how

682
00:23:41,679 --> 00:23:44,640
does this map through

683
00:23:42,960 --> 00:23:46,240
um i can't give you an exact answer i

684
00:23:44,640 --> 00:23:47,520
think i think if you enable extended

685
00:23:46,240 --> 00:23:50,400
attributes

686
00:23:47,520 --> 00:23:51,760
um that's the starting point which the

687
00:23:50,400 --> 00:23:54,880
feature is there

688
00:23:51,760 --> 00:23:56,640
um but i'm not sure um how the how well

689
00:23:54,880 --> 00:23:57,679
the pass-through works i have not tested

690
00:23:56,640 --> 00:23:59,360
it

691
00:23:57,679 --> 00:24:00,880
but i'm sure that that's a very that's a

692
00:23:59,360 --> 00:24:01,600
very important feature and so i'm sure

693
00:24:00,880 --> 00:24:05,840
it will come

694
00:24:01,600 --> 00:24:05,840
i'm sure it will be solved

695
00:24:06,159 --> 00:24:09,520
one more how do you deal with unlinked

696
00:24:08,880 --> 00:24:11,919
unused

697
00:24:09,520 --> 00:24:13,279
because you have highlanders so if you

698
00:24:11,919 --> 00:24:14,720
open file in slightly

699
00:24:13,279 --> 00:24:16,960
or something the latest and you try to

700
00:24:14,720 --> 00:24:19,279
reduce it it should work

701
00:24:16,960 --> 00:24:20,000
yeah that's right so well as as i

702
00:24:19,279 --> 00:24:23,120
mentioned the

703
00:24:20,000 --> 00:24:26,159
the fuse protocol is designed

704
00:24:23,120 --> 00:24:26,879
oh yeah sorry so the question was what

705
00:24:26,159 --> 00:24:29,520
happens

706
00:24:26,880 --> 00:24:30,720
when a file is opened and then unlinked

707
00:24:29,520 --> 00:24:33,360
and then that file

708
00:24:30,720 --> 00:24:34,640
file descriptor continues to be used um

709
00:24:33,360 --> 00:24:37,439
and as i mentioned

710
00:24:34,640 --> 00:24:38,080
the fuse protocol supports where did i

711
00:24:37,440 --> 00:24:40,640
mention this

712
00:24:38,080 --> 00:24:42,080
anyway the fuse protocol supports these

713
00:24:40,640 --> 00:24:45,279
posix semantics

714
00:24:42,080 --> 00:24:48,480
so what happens is that you can unlink

715
00:24:45,279 --> 00:24:50,159
directory entries and you still have the

716
00:24:48,480 --> 00:24:51,840
nodes the inodes and you still have the

717
00:24:50,159 --> 00:24:54,080
file handles and they continue to work

718
00:24:51,840 --> 00:24:54,080
yes

719
00:24:55,440 --> 00:25:01,840
thank you very much

720
00:25:03,600 --> 00:25:05,678
you

