1
00:00:06,160 --> 00:00:09,200
okay so

2
00:00:07,040 --> 00:00:10,400
we are ready for the restaurant we are

3
00:00:09,200 --> 00:00:13,040
ready for the next stop

4
00:00:10,400 --> 00:00:14,799
uh thank you for being here next speaker

5
00:00:13,040 --> 00:00:16,239
is stephen frost from crunchy data and

6
00:00:14,799 --> 00:00:18,400
he will

7
00:00:16,239 --> 00:00:19,520
he will talk to us about indexing and

8
00:00:18,400 --> 00:00:22,720
how to find

9
00:00:19,520 --> 00:00:22,720
slow queries and success

10
00:00:24,230 --> 00:00:30,880
[Applause]

11
00:00:28,960 --> 00:00:32,239
all right so i'm i'm stephen frost i'm

12
00:00:30,880 --> 00:00:33,920
the chief technology officer at

13
00:00:32,238 --> 00:00:35,919
crunchydata i'm one of the postgres

14
00:00:33,920 --> 00:00:37,360
committers also a major contributor

15
00:00:35,920 --> 00:00:39,200
i've hacked on a bunch of different

16
00:00:37,360 --> 00:00:41,440
stuff latest was uh

17
00:00:39,200 --> 00:00:43,120
doing uh working with gs api encryption

18
00:00:41,440 --> 00:00:45,120
in v12 which is pretty awesome

19
00:00:43,120 --> 00:00:46,879
but i also did real level security

20
00:00:45,120 --> 00:00:49,760
commonwealth privileges role system

21
00:00:46,879 --> 00:00:50,480
contributions to other stuff all right a

22
00:00:49,760 --> 00:00:52,160
couple things

23
00:00:50,480 --> 00:00:53,919
i like to say about community uh join

24
00:00:52,160 --> 00:00:55,680
postcode secure.eu

25
00:00:53,920 --> 00:00:58,239
it's based in france but they allow

26
00:00:55,680 --> 00:01:01,120
membership for anyone in the eu

27
00:00:58,239 --> 00:01:01,519
um i'm not sure what that means for that

28
00:01:01,120 --> 00:01:04,319
that

29
00:01:01,520 --> 00:01:05,400
funny island over on the upper left but

30
00:01:04,319 --> 00:01:08,960
whatever

31
00:01:05,400 --> 00:01:10,640
[Laughter]

32
00:01:08,960 --> 00:01:13,280
it's not limited sorry it's limited to

33
00:01:10,640 --> 00:01:14,080
europe technically but it's not eu so i

34
00:01:13,280 --> 00:01:15,880
don't know

35
00:01:14,080 --> 00:01:17,119
anyway also follow

36
00:01:15,880 --> 00:01:18,960
planet.postcodeskill.org

37
00:01:17,119 --> 00:01:20,560
if you don't want to join pgeu or you're

38
00:01:18,960 --> 00:01:22,119
in the u.s or if you even if you're not

39
00:01:20,560 --> 00:01:24,080
in the u.s you can join

40
00:01:22,119 --> 00:01:26,159
postcode.us we don't have these

41
00:01:24,080 --> 00:01:27,280
restrictions i don't know why they do

42
00:01:26,159 --> 00:01:29,200
all right so let's talk about finding

43
00:01:27,280 --> 00:01:30,720
slow queries um so

44
00:01:29,200 --> 00:01:32,079
first big thing that i like to talk

45
00:01:30,720 --> 00:01:34,158
about when i talk about finding new

46
00:01:32,079 --> 00:01:36,479
queries finding slow queries is

47
00:01:34,159 --> 00:01:37,840
logging logging is a really big deal and

48
00:01:36,479 --> 00:01:39,360
doing log analysis

49
00:01:37,840 --> 00:01:41,040
is really important when you're working

50
00:01:39,360 --> 00:01:42,880
with postgres um

51
00:01:41,040 --> 00:01:45,119
then we're also going to look at viewing

52
00:01:42,880 --> 00:01:47,600
active queries this is going to be

53
00:01:45,119 --> 00:01:48,799
pt stat statements uh which is a really

54
00:01:47,600 --> 00:01:50,640
really helpful

55
00:01:48,799 --> 00:01:52,240
helpful tool so we're going to talk

56
00:01:50,640 --> 00:01:53,600
first about finding those queries that

57
00:01:52,240 --> 00:01:54,000
are slow in your system and then we're

58
00:01:53,600 --> 00:01:56,158
going to talk

59
00:01:54,000 --> 00:01:58,880
about what you can do to possibly fix

60
00:01:56,159 --> 00:02:01,439
them and improve on that situation

61
00:01:58,880 --> 00:02:02,640
so inside of your postcodeskill.com you

62
00:02:01,439 --> 00:02:04,798
have a whole bunch of different

63
00:02:02,640 --> 00:02:06,479
configuration options

64
00:02:04,799 --> 00:02:08,800
and we're going to kind of work through

65
00:02:06,479 --> 00:02:09,199
each one of these and and talk about

66
00:02:08,800 --> 00:02:11,920
them

67
00:02:09,199 --> 00:02:13,440
i'm happy to take questions as we go if

68
00:02:11,920 --> 00:02:15,359
i feel like we're running out of time i

69
00:02:13,440 --> 00:02:17,680
may be short in my answers but

70
00:02:15,360 --> 00:02:19,920
please feel free to uh to ask questions

71
00:02:17,680 --> 00:02:22,959
as we go

72
00:02:19,920 --> 00:02:25,119
logmen duration statement so

73
00:02:22,959 --> 00:02:27,040
the first uh thing is like let's just

74
00:02:25,120 --> 00:02:27,680
get these queries into the log file

75
00:02:27,040 --> 00:02:29,840
right

76
00:02:27,680 --> 00:02:31,680
um and if you set log in duration

77
00:02:29,840 --> 00:02:33,599
statement to zero you're going to log

78
00:02:31,680 --> 00:02:36,239
every single query that comes into the

79
00:02:33,599 --> 00:02:37,280
system which is great for query logging

80
00:02:36,239 --> 00:02:39,760
however

81
00:02:37,280 --> 00:02:40,959
you run into this downside that if you

82
00:02:39,760 --> 00:02:44,239
have a highly

83
00:02:40,959 --> 00:02:47,599
um active system actually the

84
00:02:44,239 --> 00:02:49,840
the time taken to log the query

85
00:02:47,599 --> 00:02:51,119
can oftentimes be much much longer than

86
00:02:49,840 --> 00:02:52,319
the amount of time required for the

87
00:02:51,120 --> 00:02:54,800
query itself

88
00:02:52,319 --> 00:02:56,799
and that creates a backlog so if you're

89
00:02:54,800 --> 00:02:58,879
doing this on a really really really

90
00:02:56,800 --> 00:03:01,040
high rate system don't set it to zero

91
00:02:58,879 --> 00:03:02,399
set it to something above zero

92
00:03:01,040 --> 00:03:04,239
now i've gotten some different people

93
00:03:02,400 --> 00:03:06,480
who have commented on numbers i've

94
00:03:04,239 --> 00:03:08,800
thrown out in the past around this

95
00:03:06,480 --> 00:03:09,760
apparently one prior time i was talking

96
00:03:08,800 --> 00:03:12,400
about this i said

97
00:03:09,760 --> 00:03:13,120
you know 60 milliseconds is a good time

98
00:03:12,400 --> 00:03:15,040
right

99
00:03:13,120 --> 00:03:16,480
60 milliseconds in my opinion is going

100
00:03:15,040 --> 00:03:18,720
to give you like

101
00:03:16,480 --> 00:03:20,000
queries that are actually slow as

102
00:03:18,720 --> 00:03:22,879
opposed to

103
00:03:20,000 --> 00:03:24,000
um you know queries that that maybe if

104
00:03:22,879 --> 00:03:24,879
you set it to like one or two

105
00:03:24,000 --> 00:03:27,040
milliseconds

106
00:03:24,879 --> 00:03:28,798
that's way too much right usually on a

107
00:03:27,040 --> 00:03:30,319
high rate system

108
00:03:28,799 --> 00:03:31,440
that said i've been told that 60

109
00:03:30,319 --> 00:03:32,798
milliseconds is apparently too

110
00:03:31,440 --> 00:03:33,599
aggressive for some people in some

111
00:03:32,799 --> 00:03:34,879
environments

112
00:03:33,599 --> 00:03:36,959
because they have lots of queries that

113
00:03:34,879 --> 00:03:39,040
are 60 milliseconds or longer so

114
00:03:36,959 --> 00:03:40,720
it really depends on your environment

115
00:03:39,040 --> 00:03:42,159
right uh one of the big things about

116
00:03:40,720 --> 00:03:44,879
wagman duration statement

117
00:03:42,159 --> 00:03:46,159
is that it will give you the duration on

118
00:03:44,879 --> 00:03:48,159
the same line

119
00:03:46,159 --> 00:03:50,560
right which is going to make uh parsing

120
00:03:48,159 --> 00:03:52,239
a lot easier of the log file

121
00:03:50,560 --> 00:03:54,159
and analysis of the log file a lot

122
00:03:52,239 --> 00:03:56,000
easier so i say don't

123
00:03:54,159 --> 00:03:57,679
enable log statement or log duration

124
00:03:56,000 --> 00:03:59,360
because if you enable those

125
00:03:57,680 --> 00:04:02,159
they end up the time ends up on a

126
00:03:59,360 --> 00:04:04,239
different line from the actual query

127
00:04:02,159 --> 00:04:05,599
which makes it really obnoxious to try

128
00:04:04,239 --> 00:04:07,519
to figure things out

129
00:04:05,599 --> 00:04:09,839
so this is what you'll see from a result

130
00:04:07,519 --> 00:04:11,280
here right so this is a very simple pg

131
00:04:09,840 --> 00:04:12,879
sleep statement

132
00:04:11,280 --> 00:04:17,279
and you can see here we have a duration

133
00:04:12,879 --> 00:04:17,279
of about a thousand milliseconds

134
00:04:19,358 --> 00:04:23,359
the next thing is that every time we log

135
00:04:21,199 --> 00:04:24,880
a query in postgres or log any line in

136
00:04:23,360 --> 00:04:27,600
postgres we include what's called a

137
00:04:24,880 --> 00:04:28,080
logline prefix the default logline

138
00:04:27,600 --> 00:04:30,880
prefix

139
00:04:28,080 --> 00:04:32,320
and postgres is pretty terrible and so i

140
00:04:30,880 --> 00:04:36,159
encourage you to

141
00:04:32,320 --> 00:04:38,479
basically amp it up this is an example

142
00:04:36,160 --> 00:04:40,400
and this example actually comes as a

143
00:04:38,479 --> 00:04:42,639
recall from pg badger

144
00:04:40,400 --> 00:04:43,679
which is a tool we're going to look at

145
00:04:42,639 --> 00:04:46,639
in a little bit

146
00:04:43,680 --> 00:04:47,040
uh that generates reports based on what

147
00:04:46,639 --> 00:04:49,360
uh

148
00:04:47,040 --> 00:04:51,440
the goes into the log file into the

149
00:04:49,360 --> 00:04:52,880
postgres log file specifically

150
00:04:51,440 --> 00:04:54,880
but the whole point here is to give you

151
00:04:52,880 --> 00:04:55,520
things like a time stamp and a process

152
00:04:54,880 --> 00:04:57,680
id

153
00:04:55,520 --> 00:04:58,719
who the user was what the database was

154
00:04:57,680 --> 00:05:00,960
things like that

155
00:04:58,720 --> 00:05:02,160
so that you can actually parse this

156
00:05:00,960 --> 00:05:05,520
information out and do

157
00:05:02,160 --> 00:05:06,720
queries like per user or queries per

158
00:05:05,520 --> 00:05:08,000
client things like that kind of

159
00:05:06,720 --> 00:05:09,360
information

160
00:05:08,000 --> 00:05:11,360
and this is kind of like an example of

161
00:05:09,360 --> 00:05:13,360
what you'll see when you start adding in

162
00:05:11,360 --> 00:05:15,520
a logline prefix like that into your log

163
00:05:13,360 --> 00:05:16,960
files

164
00:05:15,520 --> 00:05:18,960
one of the other things that postgres

165
00:05:16,960 --> 00:05:19,919
does a lot of and is really important to

166
00:05:18,960 --> 00:05:22,479
postgres but

167
00:05:19,919 --> 00:05:23,440
can also impact query performance is

168
00:05:22,479 --> 00:05:25,758
checkpoints

169
00:05:23,440 --> 00:05:27,840
so you always want to be looking at why

170
00:05:25,759 --> 00:05:30,800
are your checkpoints happening

171
00:05:27,840 --> 00:05:31,440
right and when are they happening so you

172
00:05:30,800 --> 00:05:33,199
can

173
00:05:31,440 --> 00:05:34,560
do this by enabling what's called log

174
00:05:33,199 --> 00:05:37,759
checkpoints this will

175
00:05:34,560 --> 00:05:40,320
cause postgres to log into the log file

176
00:05:37,759 --> 00:05:42,000
a whole bunch of information about each

177
00:05:40,320 --> 00:05:44,800
checkpoint including

178
00:05:42,000 --> 00:05:46,560
when it started when it finished and a

179
00:05:44,800 --> 00:05:47,680
whole bunch of stats about it right how

180
00:05:46,560 --> 00:05:49,840
much it wrote

181
00:05:47,680 --> 00:05:51,600
how many transaction logs there were

182
00:05:49,840 --> 00:05:52,638
what how long it took us to do our

183
00:05:51,600 --> 00:05:54,320
fsyncs

184
00:05:52,639 --> 00:05:55,919
right one of the things that can be

185
00:05:54,320 --> 00:05:56,400
really interesting to look at is like

186
00:05:55,919 --> 00:05:58,240
okay

187
00:05:56,400 --> 00:06:00,479
are you getting a lot of slow queries

188
00:05:58,240 --> 00:06:02,319
around the time of a checkpoint

189
00:06:00,479 --> 00:06:03,599
right in which case maybe there's a

190
00:06:02,319 --> 00:06:05,919
correlation there

191
00:06:03,600 --> 00:06:07,919
or it does not seem to have any kind of

192
00:06:05,919 --> 00:06:08,960
correlation maybe it doesn't matter

193
00:06:07,919 --> 00:06:11,359
checkpoints are going to be more

194
00:06:08,960 --> 00:06:14,479
meaningful on a high right system

195
00:06:11,360 --> 00:06:18,400
than on a high read system right because

196
00:06:14,479 --> 00:06:18,400
checkpoints are all about writing out

197
00:06:18,840 --> 00:06:21,758
data

198
00:06:20,160 --> 00:06:23,680
connection logging is really useful to

199
00:06:21,759 --> 00:06:24,800
have so log your connections log your

200
00:06:23,680 --> 00:06:26,800
disk connections

201
00:06:24,800 --> 00:06:28,240
right that'll be useful information here

202
00:06:26,800 --> 00:06:30,160
you can see a connection received

203
00:06:28,240 --> 00:06:31,440
connection authorized and a disk

204
00:06:30,160 --> 00:06:33,199
connection so you can see

205
00:06:31,440 --> 00:06:34,479
how long a query or how long a

206
00:06:33,199 --> 00:06:35,759
connection has been happening

207
00:06:34,479 --> 00:06:37,680
one of the things i want to mention here

208
00:06:35,759 --> 00:06:41,120
is that when you're doing

209
00:06:37,680 --> 00:06:42,720
um connection logging if you start to

210
00:06:41,120 --> 00:06:44,400
see cases where you have like

211
00:06:42,720 --> 00:06:46,080
constant connection disconnection

212
00:06:44,400 --> 00:06:48,318
disconnection connection

213
00:06:46,080 --> 00:06:50,479
right that's not a good sign right the

214
00:06:48,319 --> 00:06:51,280
actual startup cost for postgres is

215
00:06:50,479 --> 00:06:52,880
pretty high

216
00:06:51,280 --> 00:06:54,318
so you really want to be using some kind

217
00:06:52,880 --> 00:06:56,080
of connection pooling

218
00:06:54,319 --> 00:06:58,000
to make sure that you're actually

219
00:06:56,080 --> 00:06:59,680
continuing to reutilize the same

220
00:06:58,000 --> 00:07:01,039
connection to postgres

221
00:06:59,680 --> 00:07:02,800
one of the connection poolers that i

222
00:07:01,039 --> 00:07:04,800
really really really like and encourage

223
00:07:02,800 --> 00:07:06,560
is something called pg bouncer

224
00:07:04,800 --> 00:07:08,319
so if you're not familiar with it i

225
00:07:06,560 --> 00:07:09,840
encourage you to look at pg bouncer as

226
00:07:08,319 --> 00:07:10,800
an option for doing your connection

227
00:07:09,840 --> 00:07:12,000
pooling

228
00:07:10,800 --> 00:07:13,759
it actually has something called

229
00:07:12,000 --> 00:07:17,520
transaction level connection pooling

230
00:07:13,759 --> 00:07:18,639
which is really fantastic

231
00:07:17,520 --> 00:07:20,639
one of the other things that can slow

232
00:07:18,639 --> 00:07:23,039
your queries down are lock weights

233
00:07:20,639 --> 00:07:24,800
right if you are blocking behind a lock

234
00:07:23,039 --> 00:07:26,318
because somebody else is holding a lock

235
00:07:24,800 --> 00:07:27,840
on something you need

236
00:07:26,319 --> 00:07:29,680
right that's going to make it look like

237
00:07:27,840 --> 00:07:31,599
your query is going slowly

238
00:07:29,680 --> 00:07:33,120
even when it's maybe not any problem

239
00:07:31,599 --> 00:07:34,719
with the query itself

240
00:07:33,120 --> 00:07:36,800
maybe it's just that you're you're

241
00:07:34,720 --> 00:07:38,880
blocked right waiting on a lock

242
00:07:36,800 --> 00:07:40,319
postgres has a really cool way of

243
00:07:38,880 --> 00:07:42,719
showing you this

244
00:07:40,319 --> 00:07:44,319
by having this uh option called log lock

245
00:07:42,720 --> 00:07:47,039
weights turned on now

246
00:07:44,319 --> 00:07:47,919
this will not log every lock that's

247
00:07:47,039 --> 00:07:50,400
taken

248
00:07:47,919 --> 00:07:52,479
right what this will do is after one

249
00:07:50,400 --> 00:07:55,840
second of waiting on a lock

250
00:07:52,479 --> 00:07:57,919
we will then put into the log file

251
00:07:55,840 --> 00:07:59,039
all of this really useful information

252
00:07:57,919 --> 00:08:01,280
about saying hey

253
00:07:59,039 --> 00:08:02,560
we're still waiting on this lock after a

254
00:08:01,280 --> 00:08:04,638
second right

255
00:08:02,560 --> 00:08:06,000
and this one second comes from deadlock

256
00:08:04,639 --> 00:08:07,919
timeout

257
00:08:06,000 --> 00:08:09,759
is the length of time we wait because

258
00:08:07,919 --> 00:08:11,120
after we wait for a second

259
00:08:09,759 --> 00:08:12,720
we have to run what's called our

260
00:08:11,120 --> 00:08:15,840
deadlock detector to make sure there

261
00:08:12,720 --> 00:08:18,160
aren't any deadlocks in the system

262
00:08:15,840 --> 00:08:19,599
so when we do that we also happen to say

263
00:08:18,160 --> 00:08:20,240
okay if you have log lock weights

264
00:08:19,599 --> 00:08:21,919
enabled

265
00:08:20,240 --> 00:08:23,919
we'll go log a bunch of information

266
00:08:21,919 --> 00:08:25,919
about that weight happening

267
00:08:23,919 --> 00:08:27,520
so this won't help with short-lived

268
00:08:25,919 --> 00:08:30,159
locking contention but this will help

269
00:08:27,520 --> 00:08:31,840
with anything that is more than a second

270
00:08:30,160 --> 00:08:34,479
and you could potentially reduce

271
00:08:31,840 --> 00:08:37,760
deadlock timeout to less than a second

272
00:08:34,479 --> 00:08:39,200
i don't encourage that simply because

273
00:08:37,760 --> 00:08:41,039
running of the deadlock detector is a

274
00:08:39,200 --> 00:08:44,480
little bit expensive right in

275
00:08:41,039 --> 00:08:45,439
its own right not super expensive once a

276
00:08:44,480 --> 00:08:48,320
second you know once

277
00:08:45,440 --> 00:08:50,160
a sec after a second is fine but just be

278
00:08:48,320 --> 00:08:52,480
aware of that

279
00:08:50,160 --> 00:08:54,079
don't increase deadlock timeout that

280
00:08:52,480 --> 00:08:56,160
won't make deadlock stop just

281
00:08:54,080 --> 00:08:57,360
point that out i have seen this right

282
00:08:56,160 --> 00:08:59,199
i've seen people who have

283
00:08:57,360 --> 00:09:00,880
had like 60 seconds for their deadlock

284
00:08:59,200 --> 00:09:02,480
timeout and i'm like that's not going to

285
00:09:00,880 --> 00:09:03,839
make them go away that's not how that

286
00:09:02,480 --> 00:09:05,360
works

287
00:09:03,839 --> 00:09:07,040
all right one of the other things that

288
00:09:05,360 --> 00:09:10,160
can happen when a query is running

289
00:09:07,040 --> 00:09:12,319
is temporary files get created

290
00:09:10,160 --> 00:09:14,000
while the query is running this can be

291
00:09:12,320 --> 00:09:15,279
really useful because guess what when

292
00:09:14,000 --> 00:09:15,920
we're starting to write out the temp

293
00:09:15,279 --> 00:09:18,640
files

294
00:09:15,920 --> 00:09:20,719
in many cases that's an indication that

295
00:09:18,640 --> 00:09:22,560
like work mem isn't set high enough or

296
00:09:20,720 --> 00:09:24,880
we aren't using as much memory as we'd

297
00:09:22,560 --> 00:09:26,079
like to so we're having to write out to

298
00:09:24,880 --> 00:09:28,399
disk instead

299
00:09:26,080 --> 00:09:30,320
and writing out the disk is expensive

300
00:09:28,399 --> 00:09:31,839
right so log temp file setting it to

301
00:09:30,320 --> 00:09:33,519
zero means you're going to log every

302
00:09:31,839 --> 00:09:36,480
time postgres

303
00:09:33,519 --> 00:09:37,440
logs or uses a temp file like this to do

304
00:09:36,480 --> 00:09:39,440
some kind of action

305
00:09:37,440 --> 00:09:40,560
right so in this case we were doing a

306
00:09:39,440 --> 00:09:42,320
sort uh

307
00:09:40,560 --> 00:09:44,719
that sort because this table was pretty

308
00:09:42,320 --> 00:09:48,480
big ended up spilling out to disk

309
00:09:44,720 --> 00:09:48,480
and here's where the information about

310
00:09:48,839 --> 00:09:53,519
that

311
00:09:50,640 --> 00:09:54,800
log auto vacuum induration this uh gives

312
00:09:53,519 --> 00:09:55,680
you lots of information about auto

313
00:09:54,800 --> 00:09:58,079
vacuum

314
00:09:55,680 --> 00:09:59,680
um this basically if you set it to zero

315
00:09:58,080 --> 00:10:01,920
it's gonna log every time

316
00:09:59,680 --> 00:10:03,920
that auto vacuum ran and how much work

317
00:10:01,920 --> 00:10:07,760
that it did

318
00:10:03,920 --> 00:10:08,719
in general running auto vacuum can have

319
00:10:07,760 --> 00:10:11,600
some

320
00:10:08,720 --> 00:10:12,079
impact but you need to run auto vacuum

321
00:10:11,600 --> 00:10:15,040
don't

322
00:10:12,079 --> 00:10:16,560
not run auto vacuum right people

323
00:10:15,040 --> 00:10:17,199
sometimes turn it off they're like well

324
00:10:16,560 --> 00:10:18,880
i don't

325
00:10:17,200 --> 00:10:21,360
need this right it's just like some

326
00:10:18,880 --> 00:10:22,800
background process no we need this

327
00:10:21,360 --> 00:10:24,240
right there's a number of things that

328
00:10:22,800 --> 00:10:25,920
auto vacuum does that actually helps

329
00:10:24,240 --> 00:10:28,079
with query performance

330
00:10:25,920 --> 00:10:29,279
right including dealing with dead tuples

331
00:10:28,079 --> 00:10:30,959
and and bloat

332
00:10:29,279 --> 00:10:32,399
but also things like updating what's

333
00:10:30,959 --> 00:10:34,079
called our visibility map which is

334
00:10:32,399 --> 00:10:36,000
really important to update

335
00:10:34,079 --> 00:10:37,439
if you want to have like index only

336
00:10:36,000 --> 00:10:40,480
scans for example

337
00:10:37,440 --> 00:10:42,079
so i don't recommend disabling auto

338
00:10:40,480 --> 00:10:43,760
vacuum instead

339
00:10:42,079 --> 00:10:45,760
set the duration to zero and go start

340
00:10:43,760 --> 00:10:47,360
looking and saying okay is this really

341
00:10:45,760 --> 00:10:48,240
actually what's causing a problem on my

342
00:10:47,360 --> 00:10:51,600
environment

343
00:10:48,240 --> 00:10:53,760
most of the time it isn't

344
00:10:51,600 --> 00:10:55,120
all right so that's a quick rundown now

345
00:10:53,760 --> 00:10:57,040
i'm going to do a little

346
00:10:55,120 --> 00:10:58,560
thing that i like to do that's fun and

347
00:10:57,040 --> 00:11:00,480
we'll see if it works and

348
00:10:58,560 --> 00:11:02,399
yes it depends on the internet and no

349
00:11:00,480 --> 00:11:05,120
one ever knows if that works well

350
00:11:02,399 --> 00:11:05,519
but here's an example of what you'll get

351
00:11:05,120 --> 00:11:08,880
from

352
00:11:05,519 --> 00:11:11,200
a uh pg badger report

353
00:11:08,880 --> 00:11:12,720
right so here you get things like number

354
00:11:11,200 --> 00:11:15,680
of unique queries

355
00:11:12,720 --> 00:11:17,920
right number of overall queries query

356
00:11:15,680 --> 00:11:20,640
duration first query last query

357
00:11:17,920 --> 00:11:23,040
query peak you get all these really cool

358
00:11:20,640 --> 00:11:25,040
graphs things like queries per second

359
00:11:23,040 --> 00:11:27,120
right and this allows you to do some

360
00:11:25,040 --> 00:11:29,279
amount of drill down in here

361
00:11:27,120 --> 00:11:32,320
right where you can start to look at

362
00:11:29,279 --> 00:11:32,320
specific queries

363
00:11:33,040 --> 00:11:37,839
you can also look at things like number

364
00:11:35,760 --> 00:11:39,760
of connections into the database

365
00:11:37,839 --> 00:11:42,079
right here's a yup look at that it

366
00:11:39,760 --> 00:11:45,040
worked all right the internet is not

367
00:11:42,079 --> 00:11:48,880
dead yet um so here you can see you know

368
00:11:45,040 --> 00:11:50,800
connections per second for example

369
00:11:48,880 --> 00:11:53,279
simultaneous sessions so checkpoint

370
00:11:50,800 --> 00:11:55,920
activity like i was saying before

371
00:11:53,279 --> 00:11:57,839
can be really interesting to look at and

372
00:11:55,920 --> 00:12:00,560
so i encourage you to look at

373
00:11:57,839 --> 00:12:01,920
checkpoint information as well all right

374
00:12:00,560 --> 00:12:04,800
i think it's not going to work so oh

375
00:12:01,920 --> 00:12:06,079
yeah okay it did take a look at that all

376
00:12:04,800 --> 00:12:07,839
right so here you can see how many

377
00:12:06,079 --> 00:12:09,199
buffers we wrote out from a checkpoint

378
00:12:07,839 --> 00:12:11,120
across these five different

379
00:12:09,200 --> 00:12:12,399
five-minute periods so the default

380
00:12:11,120 --> 00:12:12,880
checkpoint timeout is five minutes i'm

381
00:12:12,399 --> 00:12:16,480
going to talk

382
00:12:12,880 --> 00:12:16,480
a little bit more about that later on

383
00:12:16,800 --> 00:12:21,599
and here you can see wall file usage

384
00:12:20,160 --> 00:12:23,120
this kind of information is really

385
00:12:21,600 --> 00:12:24,639
really helpful when you want to look at

386
00:12:23,120 --> 00:12:26,160
queries

387
00:12:24,639 --> 00:12:27,200
and want to try to correlate between

388
00:12:26,160 --> 00:12:28,319
these things so then you can kind of

389
00:12:27,200 --> 00:12:30,320
come over here and

390
00:12:28,320 --> 00:12:32,560
look at different types of queries query

391
00:12:30,320 --> 00:12:36,000
per database query per user

392
00:12:32,560 --> 00:12:37,119
right query per application so lots of

393
00:12:36,000 --> 00:12:40,079
good information

394
00:12:37,120 --> 00:12:41,680
and here you can see your top histogram

395
00:12:40,079 --> 00:12:43,920
of queries

396
00:12:41,680 --> 00:12:45,120
you can give you get slow individual

397
00:12:43,920 --> 00:12:47,040
queries

398
00:12:45,120 --> 00:12:48,880
so here are some examples of some slow

399
00:12:47,040 --> 00:12:50,240
queries these aren't that interesting in

400
00:12:48,880 --> 00:12:51,200
my opinion because they're copy

401
00:12:50,240 --> 00:12:53,200
statements

402
00:12:51,200 --> 00:12:54,959
right copy statements are just ways of

403
00:12:53,200 --> 00:12:55,680
doing bulk loads into postgres which

404
00:12:54,959 --> 00:12:56,800
means that

405
00:12:55,680 --> 00:12:58,880
essentially what we're doing is we're

406
00:12:56,800 --> 00:13:00,399
just doing a whole lot of writes

407
00:12:58,880 --> 00:13:02,480
but you can get down into here and you

408
00:13:00,399 --> 00:13:05,200
can see okay now we're looking at

409
00:13:02,480 --> 00:13:06,079
time consuming queries where we can see

410
00:13:05,200 --> 00:13:08,399
okay

411
00:13:06,079 --> 00:13:09,680
this select count star from pg class is

412
00:13:08,399 --> 00:13:12,560
being run

413
00:13:09,680 --> 00:13:14,000
um 11 000 times that's that's quite a

414
00:13:12,560 --> 00:13:16,319
few times right

415
00:13:14,000 --> 00:13:17,920
and the shortest time it wrote it ran in

416
00:13:16,320 --> 00:13:20,959
was 300 milliseconds

417
00:13:17,920 --> 00:13:23,519
and the max was 23 seconds

418
00:13:20,959 --> 00:13:24,719
that is a long query right particularly

419
00:13:23,519 --> 00:13:27,519
for what this is doing

420
00:13:24,720 --> 00:13:29,440
now the average was only uh one second

421
00:13:27,519 --> 00:13:31,120
or so which is not too bad

422
00:13:29,440 --> 00:13:33,839
but this is one where you can go okay

423
00:13:31,120 --> 00:13:35,440
why is this running so often

424
00:13:33,839 --> 00:13:37,600
right and is there something i can do to

425
00:13:35,440 --> 00:13:39,519
fix it now in this particular case this

426
00:13:37,600 --> 00:13:40,800
is related to pg pool and

427
00:13:39,519 --> 00:13:43,199
if you're using that maybe there's not a

428
00:13:40,800 --> 00:13:44,560
whole lot you can do but it's a it's

429
00:13:43,199 --> 00:13:46,839
really useful to be able to go into the

430
00:13:44,560 --> 00:13:49,359
system and see this kind of

431
00:13:46,839 --> 00:13:50,720
information right so here are update

432
00:13:49,360 --> 00:13:52,880
statements now you'll note

433
00:13:50,720 --> 00:13:55,040
there's no uh values in here that's

434
00:13:52,880 --> 00:13:56,880
because we've normalized the query so

435
00:13:55,040 --> 00:13:57,599
we've taken out the literal values out

436
00:13:56,880 --> 00:13:59,519
of it

437
00:13:57,600 --> 00:14:01,120
right in order to be able to to smush

438
00:13:59,519 --> 00:14:03,680
them all together to see

439
00:14:01,120 --> 00:14:04,160
a consist you know see a consolidated

440
00:14:03,680 --> 00:14:06,880
view

441
00:14:04,160 --> 00:14:10,079
across all of the different uh statement

442
00:14:06,880 --> 00:14:10,079
individual statements that are run

443
00:14:13,120 --> 00:14:16,959
you can see here as another count star

444
00:14:15,600 --> 00:14:19,680
or account

445
00:14:16,959 --> 00:14:20,719
which ends up being pretty expensive so

446
00:14:19,680 --> 00:14:22,719
pg badger

447
00:14:20,720 --> 00:14:24,000
really really useful tool i encourage

448
00:14:22,720 --> 00:14:26,079
you to consider using it

449
00:14:24,000 --> 00:14:27,839
and and working with it i'm not going to

450
00:14:26,079 --> 00:14:30,079
do too much more with it we've got a lot

451
00:14:27,839 --> 00:14:33,519
of other things to chat about here

452
00:14:30,079 --> 00:14:33,519
but i wanted to show that off

453
00:14:37,760 --> 00:14:43,439
all right okay

454
00:14:41,920 --> 00:14:45,439
all right the other way that you can

455
00:14:43,440 --> 00:14:47,440
look at slow queries inside of postgres

456
00:14:45,440 --> 00:14:48,480
is by using a tool called pt stat

457
00:14:47,440 --> 00:14:50,639
statements

458
00:14:48,480 --> 00:14:52,399
right pg stat statements is an extension

459
00:14:50,639 --> 00:14:54,959
that you add into postgres

460
00:14:52,399 --> 00:14:56,000
that will allow you to then look at all

461
00:14:54,959 --> 00:14:57,920
of the queries

462
00:14:56,000 --> 00:14:59,040
in a normalized fashion similar to what

463
00:14:57,920 --> 00:15:01,760
pg badger does

464
00:14:59,040 --> 00:15:04,160
but through a view inside of postgres

465
00:15:01,760 --> 00:15:06,319
installing it requires that you update

466
00:15:04,160 --> 00:15:07,519
shared preload libraries to include pg

467
00:15:06,320 --> 00:15:09,360
stat statements

468
00:15:07,519 --> 00:15:10,720
and then you have to run this create

469
00:15:09,360 --> 00:15:13,199
extension command

470
00:15:10,720 --> 00:15:15,199
inside of each database that you want to

471
00:15:13,199 --> 00:15:18,240
have access to the view

472
00:15:15,199 --> 00:15:19,040
now the actual contents of the pg stat

473
00:15:18,240 --> 00:15:22,720
statements view

474
00:15:19,040 --> 00:15:24,000
are across the entire cluster

475
00:15:22,720 --> 00:15:25,760
but you can only see them if you've

476
00:15:24,000 --> 00:15:27,360
created the extension inside of a

477
00:15:25,760 --> 00:15:28,480
particular database

478
00:15:27,360 --> 00:15:31,600
note that you're going to need to do a

479
00:15:28,480 --> 00:15:33,519
restart not a reload of postgres because

480
00:15:31,600 --> 00:15:36,079
that's what's required when you update

481
00:15:33,519 --> 00:15:37,759
shared preload libraries

482
00:15:36,079 --> 00:15:40,800
so what do we have inside of pg stat

483
00:15:37,759 --> 00:15:43,519
statements so here we have a user id

484
00:15:40,800 --> 00:15:44,560
database id query id and the actual

485
00:15:43,519 --> 00:15:46,720
query text

486
00:15:44,560 --> 00:15:48,719
now that query text is also going to be

487
00:15:46,720 --> 00:15:50,160
normalized instead of having literals in

488
00:15:48,720 --> 00:15:52,480
there you'll have question marks

489
00:15:50,160 --> 00:15:54,319
right because we have to take out the

490
00:15:52,480 --> 00:15:56,560
actual literal values in order to be

491
00:15:54,320 --> 00:15:59,040
able to do the aggregation

492
00:15:56,560 --> 00:16:00,319
the query id is an interesting thing so

493
00:15:59,040 --> 00:16:02,480
the query id

494
00:16:00,320 --> 00:16:04,079
is reasonable it should be consistent

495
00:16:02,480 --> 00:16:07,360
for a given query

496
00:16:04,079 --> 00:16:08,319
inside of a postgres major version right

497
00:16:07,360 --> 00:16:10,240
and in fact i think it

498
00:16:08,320 --> 00:16:12,160
it hasn't changed much between major

499
00:16:10,240 --> 00:16:14,480
versions even so

500
00:16:12,160 --> 00:16:15,279
um and this can be your identifier to

501
00:16:14,480 --> 00:16:18,399
use to

502
00:16:15,279 --> 00:16:20,720
identify uh queries over time

503
00:16:18,399 --> 00:16:23,519
so you can like export this information

504
00:16:20,720 --> 00:16:25,920
pull it into an analysis tool

505
00:16:23,519 --> 00:16:27,759
right outside of postgres i've seen

506
00:16:25,920 --> 00:16:29,680
people have good success with like

507
00:16:27,759 --> 00:16:32,079
prometheus and grafana scraping this

508
00:16:29,680 --> 00:16:34,880
information and pulling it out

509
00:16:32,079 --> 00:16:36,880
and then visualizing it and that query

510
00:16:34,880 --> 00:16:38,880
id can be a useful tool for

511
00:16:36,880 --> 00:16:40,639
looking at a particular query across

512
00:16:38,880 --> 00:16:42,160
multiple of those snapshots in a simpler

513
00:16:40,639 --> 00:16:43,600
way than trying to compare the query

514
00:16:42,160 --> 00:16:45,759
text

515
00:16:43,600 --> 00:16:47,360
calls is the number of times that query

516
00:16:45,759 --> 00:16:49,199
has been run

517
00:16:47,360 --> 00:16:50,399
total time of course gives you the total

518
00:16:49,199 --> 00:16:51,920
amount of time

519
00:16:50,399 --> 00:16:54,880
all of this information is since the

520
00:16:51,920 --> 00:16:57,599
last reset of pg stats statements

521
00:16:54,880 --> 00:16:58,800
by default pt stat statements will save

522
00:16:57,600 --> 00:17:02,160
the information

523
00:16:58,800 --> 00:17:03,920
across shutdown and restarts in postgres

524
00:17:02,160 --> 00:17:05,280
and so when you shut down postgres it'll

525
00:17:03,920 --> 00:17:06,399
write out all that information and when

526
00:17:05,280 --> 00:17:08,799
you load both grabs up

527
00:17:06,400 --> 00:17:10,160
it'll read it all back in um you can

528
00:17:08,799 --> 00:17:11,359
change that there's an option for that

529
00:17:10,160 --> 00:17:13,039
if you want

530
00:17:11,359 --> 00:17:15,119
so this is going to be like total time

531
00:17:13,039 --> 00:17:17,599
since whenever you probably installed pg

532
00:17:15,119 --> 00:17:19,438
stat statements for example

533
00:17:17,599 --> 00:17:20,879
we then have min max mean standard

534
00:17:19,439 --> 00:17:23,839
deviation

535
00:17:20,880 --> 00:17:25,280
number of rows impacted or returned by

536
00:17:23,839 --> 00:17:26,720
this particular query

537
00:17:25,280 --> 00:17:28,319
so it depends on if it's like an update

538
00:17:26,720 --> 00:17:30,080
or an insert but you'll get a number of

539
00:17:28,319 --> 00:17:33,600
rows associated with the query

540
00:17:30,080 --> 00:17:36,559
which can be helpful as well

541
00:17:33,600 --> 00:17:38,240
you can then see uh block hits either

542
00:17:36,559 --> 00:17:40,960
shared or local or temp

543
00:17:38,240 --> 00:17:41,840
um and this is when it's either a hit a

544
00:17:40,960 --> 00:17:44,080
read

545
00:17:41,840 --> 00:17:46,559
dirtied or written so hit means it was

546
00:17:44,080 --> 00:17:48,159
inside of shared buffers right where we

547
00:17:46,559 --> 00:17:50,320
already we already had that page

548
00:17:48,160 --> 00:17:53,440
available to us which is great

549
00:17:50,320 --> 00:17:55,360
uh and that means it's cheap read means

550
00:17:53,440 --> 00:17:57,120
that we had to go read a page in

551
00:17:55,360 --> 00:18:00,240
dirtied means that we had to go actually

552
00:17:57,120 --> 00:18:02,000
dirty a page inside of our buffer cache

553
00:18:00,240 --> 00:18:03,840
right means we actually had to go right

554
00:18:02,000 --> 00:18:05,440
that page out

555
00:18:03,840 --> 00:18:06,959
now one of the things that i didn't

556
00:18:05,440 --> 00:18:09,280
mention on the other one is you should

557
00:18:06,960 --> 00:18:12,320
also enable track i o timing

558
00:18:09,280 --> 00:18:13,678
right this is not enabled by default

559
00:18:12,320 --> 00:18:16,000
because it basically means that we're

560
00:18:13,679 --> 00:18:18,559
going to be doing a a timing call

561
00:18:16,000 --> 00:18:20,000
before and after each read and write

562
00:18:18,559 --> 00:18:22,320
inside of postgres

563
00:18:20,000 --> 00:18:24,559
if your system has crappy timing calls

564
00:18:22,320 --> 00:18:26,840
and they're really really really slow

565
00:18:24,559 --> 00:18:29,280
that can actually have an impact on

566
00:18:26,840 --> 00:18:32,159
performance most systems these days

567
00:18:29,280 --> 00:18:33,760
don't have that problem there is a tool

568
00:18:32,160 --> 00:18:35,520
called pt test timing

569
00:18:33,760 --> 00:18:37,039
that you can run to check and make sure

570
00:18:35,520 --> 00:18:39,840
your system is okay

571
00:18:37,039 --> 00:18:41,600
but if you enable this then these block

572
00:18:39,840 --> 00:18:43,520
read time and block right time

573
00:18:41,600 --> 00:18:45,520
parameters inside of pt stat statements

574
00:18:43,520 --> 00:18:47,760
will actually be populated

575
00:18:45,520 --> 00:18:49,600
and you'll be able to go look at how

576
00:18:47,760 --> 00:18:52,320
much time did we spend

577
00:18:49,600 --> 00:18:54,000
on this particular query overall doing

578
00:18:52,320 --> 00:18:55,520
block reads and block rights which can

579
00:18:54,000 --> 00:18:56,720
be really really useful

580
00:18:55,520 --> 00:18:58,559
when you're thinking about query

581
00:18:56,720 --> 00:19:01,840
analysis and you want to understand why

582
00:18:58,559 --> 00:19:01,840
was this query slow

583
00:19:02,559 --> 00:19:06,559
so here's an example of what you might

584
00:19:04,480 --> 00:19:07,520
see inside of pg stat statements this is

585
00:19:06,559 --> 00:19:10,639
a simple

586
00:19:07,520 --> 00:19:12,400
update statement run using a utility

587
00:19:10,640 --> 00:19:15,039
called pg bench

588
00:19:12,400 --> 00:19:15,919
pg bench is a pretty useful utility for

589
00:19:15,039 --> 00:19:17,919
uh basically

590
00:19:15,919 --> 00:19:19,520
running running benchmarks against

591
00:19:17,919 --> 00:19:21,200
postgres that you then want to

592
00:19:19,520 --> 00:19:23,760
compare against different postgres

593
00:19:21,200 --> 00:19:27,200
instances for example

594
00:19:23,760 --> 00:19:27,600
here we had 40 000 calls with a a total

595
00:19:27,200 --> 00:19:31,200
time

596
00:19:27,600 --> 00:19:33,520
of uh 4.7 seconds right here you can see

597
00:19:31,200 --> 00:19:34,320
our min time was extremely good but we

598
00:19:33,520 --> 00:19:37,679
did have

599
00:19:34,320 --> 00:19:39,039
a pretty large max time of 142

600
00:19:37,679 --> 00:19:40,480
milliseconds

601
00:19:39,039 --> 00:19:42,480
right so if i was looking at this i'd be

602
00:19:40,480 --> 00:19:43,600
like wow that's that's a pretty large

603
00:19:42,480 --> 00:19:46,080
max time

604
00:19:43,600 --> 00:19:46,719
and if i have my log min duration

605
00:19:46,080 --> 00:19:50,240
statement

606
00:19:46,720 --> 00:19:51,360
set to 100 or 60 or something lower than

607
00:19:50,240 --> 00:19:54,240
this value

608
00:19:51,360 --> 00:19:55,520
that query exactly is gonna be in my log

609
00:19:54,240 --> 00:19:57,919
and i'm gonna be able to go look at that

610
00:19:55,520 --> 00:20:01,520
query and be like why are you slow

611
00:19:57,919 --> 00:20:02,960
right it's possible that uh at that time

612
00:20:01,520 --> 00:20:05,200
there was something else going on in the

613
00:20:02,960 --> 00:20:07,200
system maybe a checkpoint was happening

614
00:20:05,200 --> 00:20:08,240
maybe there was a lock involved right

615
00:20:07,200 --> 00:20:10,480
potentially

616
00:20:08,240 --> 00:20:12,080
it could be anything so you can go back

617
00:20:10,480 --> 00:20:15,120
and look at that and say okay

618
00:20:12,080 --> 00:20:18,399
why was this particular query slow and

619
00:20:15,120 --> 00:20:18,399
that can be really really helpful

620
00:20:18,480 --> 00:20:21,600
and here you can see that we have 40 000

621
00:20:20,400 --> 00:20:23,679
rows

622
00:20:21,600 --> 00:20:25,439
as a result of this because each one of

623
00:20:23,679 --> 00:20:28,240
these statements is actually updating an

624
00:20:25,440 --> 00:20:28,240
individual row

625
00:20:32,640 --> 00:20:36,320
all right here's another pg stat

626
00:20:34,000 --> 00:20:37,440
statement query this one is a select

627
00:20:36,320 --> 00:20:39,520
base query

628
00:20:37,440 --> 00:20:42,159
right and here you can see our total

629
00:20:39,520 --> 00:20:43,918
time from this is only 516 milliseconds

630
00:20:42,159 --> 00:20:46,000
across 40 000 calls

631
00:20:43,919 --> 00:20:47,600
which is pretty darn good right this is

632
00:20:46,000 --> 00:20:49,520
what you like to see

633
00:20:47,600 --> 00:20:51,039
right this is shows you your min time

634
00:20:49,520 --> 00:20:54,000
and your max time are

635
00:20:51,039 --> 00:20:55,440
well under a millisecond which is which

636
00:20:54,000 --> 00:20:57,120
is typically very good

637
00:20:55,440 --> 00:21:00,240
and your standard deviation is also

638
00:20:57,120 --> 00:21:01,600
quite low here which is awesome

639
00:21:00,240 --> 00:21:04,159
so that's the kind of query you'd like

640
00:21:01,600 --> 00:21:06,399
to see so now let's talk about

641
00:21:04,159 --> 00:21:07,760
why are query is slow right there's a

642
00:21:06,400 --> 00:21:08,880
lot of different potential things

643
00:21:07,760 --> 00:21:10,240
involved

644
00:21:08,880 --> 00:21:12,080
and i think it's really useful to go

645
00:21:10,240 --> 00:21:13,440
over them so we're going to talk about

646
00:21:12,080 --> 00:21:14,559
postgres configuration we're going to

647
00:21:13,440 --> 00:21:15,679
talk about

648
00:21:14,559 --> 00:21:17,760
tuples and bloat and we're going to talk

649
00:21:15,679 --> 00:21:19,600
a little bit about query plans

650
00:21:17,760 --> 00:21:20,799
so this these are a bunch of the

651
00:21:19,600 --> 00:21:23,199
different options that you want to think

652
00:21:20,799 --> 00:21:25,760
about configuring inside of postgres

653
00:21:23,200 --> 00:21:26,799
when you're looking at trying to improve

654
00:21:25,760 --> 00:21:29,200
performance so

655
00:21:26,799 --> 00:21:30,639
the first one is work mem one of the

656
00:21:29,200 --> 00:21:32,640
things to realize that workman can be

657
00:21:30,640 --> 00:21:35,760
allocated many times over

658
00:21:32,640 --> 00:21:39,039
um it's used for bitmaps hash

659
00:21:35,760 --> 00:21:41,360
builds um it's also used for sorting

660
00:21:39,039 --> 00:21:43,200
in memory right so these are all things

661
00:21:41,360 --> 00:21:44,639
that care that you wanna care about and

662
00:21:43,200 --> 00:21:45,360
think about one of the big things is

663
00:21:44,640 --> 00:21:47,520
that

664
00:21:45,360 --> 00:21:48,399
bitmaps if you're using a bitmap heap

665
00:21:47,520 --> 00:21:49,360
scan i'm going to talk about that a

666
00:21:48,400 --> 00:21:51,200
little bit later

667
00:21:49,360 --> 00:21:52,879
but if you're doing that and you

668
00:21:51,200 --> 00:21:54,480
overflow work mem

669
00:21:52,880 --> 00:21:55,919
bitmaps will start to reduce their

670
00:21:54,480 --> 00:21:58,559
accuracy

671
00:21:55,919 --> 00:22:00,960
which ends up being a potential issue

672
00:21:58,559 --> 00:22:02,879
for performance

673
00:22:00,960 --> 00:22:04,960
maintenance work mem this is allocated

674
00:22:02,880 --> 00:22:07,840
by auto vacuum worker processes

675
00:22:04,960 --> 00:22:08,240
and also uh by parallel create index

676
00:22:07,840 --> 00:22:11,439
right

677
00:22:08,240 --> 00:22:14,559
or any kind of create index or alter

678
00:22:11,440 --> 00:22:14,960
table right so for example if you have

679
00:22:14,559 --> 00:22:16,799
like

680
00:22:14,960 --> 00:22:18,400
five auto vacuum workers and you have a

681
00:22:16,799 --> 00:22:20,158
gigabyte used you can

682
00:22:18,400 --> 00:22:22,480
go up to a gigabyte for each one

683
00:22:20,159 --> 00:22:24,720
potentially

684
00:22:22,480 --> 00:22:26,640
effective cache size this is a parameter

685
00:22:24,720 --> 00:22:29,760
not everybody really thinks about

686
00:22:26,640 --> 00:22:32,080
it's never actually allocated right

687
00:22:29,760 --> 00:22:33,679
it's an estimate of the size of the disk

688
00:22:32,080 --> 00:22:36,158
cache and basically what postgres is

689
00:22:33,679 --> 00:22:38,320
trying to use this for is to decide

690
00:22:36,159 --> 00:22:39,679
is this page likely going to be in

691
00:22:38,320 --> 00:22:41,678
memory or not

692
00:22:39,679 --> 00:22:43,039
right maybe not maybe it's not in my

693
00:22:41,679 --> 00:22:44,320
shared buffers but it might be in the

694
00:22:43,039 --> 00:22:46,720
disk cache

695
00:22:44,320 --> 00:22:49,360
right so if it's in the disk cache then

696
00:22:46,720 --> 00:22:51,840
is a good chance that i can utilize it

697
00:22:49,360 --> 00:22:52,799
um more efficiently without having to go

698
00:22:51,840 --> 00:22:55,199
to disk right

699
00:22:52,799 --> 00:22:56,080
in which case i'll be able to pull it

700
00:22:55,200 --> 00:22:59,120
back quicker

701
00:22:56,080 --> 00:23:00,720
and so that can lead to say maybe it

702
00:22:59,120 --> 00:23:01,439
would be better to use an index scan

703
00:23:00,720 --> 00:23:04,799
rather than

704
00:23:01,440 --> 00:23:04,799
a a tuple scan

705
00:23:05,120 --> 00:23:08,158
shared buffers is allocated at server

706
00:23:07,600 --> 00:23:10,480
start

707
00:23:08,159 --> 00:23:12,080
this is our big shared buffer cache

708
00:23:10,480 --> 00:23:15,520
right usually about

709
00:23:12,080 --> 00:23:17,840
25 to 50 of the the system memory

710
00:23:15,520 --> 00:23:20,840
pg buffer cache is a really useful tool

711
00:23:17,840 --> 00:23:22,879
for analyzing the contents of shared

712
00:23:20,840 --> 00:23:24,720
buffers

713
00:23:22,880 --> 00:23:26,720
all right checkpoints and wall size so

714
00:23:24,720 --> 00:23:28,559
min wall size and maxwell size are also

715
00:23:26,720 --> 00:23:30,880
things to think about

716
00:23:28,559 --> 00:23:32,320
basically wall size is like how much

717
00:23:30,880 --> 00:23:34,080
wall can the system

718
00:23:32,320 --> 00:23:36,399
uh how much displace can the system use

719
00:23:34,080 --> 00:23:37,520
for the right ahead log right and if

720
00:23:36,400 --> 00:23:39,280
it's too low

721
00:23:37,520 --> 00:23:41,279
checkpoints will start happening before

722
00:23:39,280 --> 00:23:42,960
the actual checkpoint timeout

723
00:23:41,279 --> 00:23:44,799
right checkpoint timeout defaults to

724
00:23:42,960 --> 00:23:47,840
every five minutes and

725
00:23:44,799 --> 00:23:49,600
basically what that implies is that

726
00:23:47,840 --> 00:23:51,600
when the system crashes we have to go

727
00:23:49,600 --> 00:23:53,439
back five minutes in time potentially

728
00:23:51,600 --> 00:23:55,678
to replay through all of that right

729
00:23:53,440 --> 00:23:56,480
ahead log and that can take time so you

730
00:23:55,679 --> 00:23:57,919
don't necessarily want to have

731
00:23:56,480 --> 00:24:00,799
checkpoint timeout set like

732
00:23:57,919 --> 00:24:02,559
super high right but you probably also

733
00:24:00,799 --> 00:24:05,039
want to think about

734
00:24:02,559 --> 00:24:05,760
the fact that every time we have to

735
00:24:05,039 --> 00:24:07,360
write something

736
00:24:05,760 --> 00:24:10,640
after a checkpoint we have to do a full

737
00:24:07,360 --> 00:24:12,000
page write which can be expensive

738
00:24:10,640 --> 00:24:13,360
checkpoint completion target is

739
00:24:12,000 --> 00:24:14,080
basically how much of the checkpoint

740
00:24:13,360 --> 00:24:16,000
timeout

741
00:24:14,080 --> 00:24:17,840
to use to perform a timeout or a

742
00:24:16,000 --> 00:24:20,240
performance checkpoint rather

743
00:24:17,840 --> 00:24:22,000
which is defaults to 0.5 that seems kind

744
00:24:20,240 --> 00:24:23,120
of silly to me i usually up it to like

745
00:24:22,000 --> 00:24:24,400
0.9

746
00:24:23,120 --> 00:24:26,719
so that's something to think about as

747
00:24:24,400 --> 00:24:28,320
well but if you start in particular

748
00:24:26,720 --> 00:24:30,320
in your logging of checkpoints if you

749
00:24:28,320 --> 00:24:30,879
see that your checkpoints are happening

750
00:24:30,320 --> 00:24:33,360
due to

751
00:24:30,880 --> 00:24:35,360
x-log you really want to think about

752
00:24:33,360 --> 00:24:36,320
increasing your max wall size because

753
00:24:35,360 --> 00:24:39,918
that's going to

754
00:24:36,320 --> 00:24:40,480
be a you know basically slow down your

755
00:24:39,919 --> 00:24:41,919
rights

756
00:24:40,480 --> 00:24:43,440
right you're writing to the database

757
00:24:41,919 --> 00:24:46,559
because we're having the checkpoint more

758
00:24:43,440 --> 00:24:47,919
frequently than you'd like to

759
00:24:46,559 --> 00:24:50,240
all right let's talk about dead tuples

760
00:24:47,919 --> 00:24:51,919
and bloat right so

761
00:24:50,240 --> 00:24:53,520
vacuum goes through and marks these

762
00:24:51,919 --> 00:24:54,960
records as reusable that's one of the

763
00:24:53,520 --> 00:24:55,840
reasons why auto vacuum is really

764
00:24:54,960 --> 00:24:58,799
helpful

765
00:24:55,840 --> 00:24:59,439
right but if there are tuples out there

766
00:24:58,799 --> 00:25:01,679
that

767
00:24:59,440 --> 00:25:02,799
are dead right there or there's empty

768
00:25:01,679 --> 00:25:05,039
space on a page

769
00:25:02,799 --> 00:25:07,760
we still have to read that data right

770
00:25:05,039 --> 00:25:10,158
when we're doing like a sequential scan

771
00:25:07,760 --> 00:25:12,400
okay and therefore that can cause

772
00:25:10,159 --> 00:25:12,960
performance impacts on sequential scans

773
00:25:12,400 --> 00:25:15,679
now

774
00:25:12,960 --> 00:25:16,799
indexes can also have bloat right which

775
00:25:15,679 --> 00:25:19,679
can be

776
00:25:16,799 --> 00:25:21,760
impactful on the system running as well

777
00:25:19,679 --> 00:25:23,679
so you really want to be running vacuum

778
00:25:21,760 --> 00:25:25,120
check postgres is a really helpful tool

779
00:25:23,679 --> 00:25:28,240
for identifying

780
00:25:25,120 --> 00:25:31,039
tables to look for for for bloat pg

781
00:25:28,240 --> 00:25:32,799
monitor is also really helpful

782
00:25:31,039 --> 00:25:34,480
note that if you want to eliminate all

783
00:25:32,799 --> 00:25:37,440
bloat you have to do a full rewrite

784
00:25:34,480 --> 00:25:39,919
which is typically not a good idea

785
00:25:37,440 --> 00:25:41,440
basically some bloat is useful if

786
00:25:39,919 --> 00:25:43,200
there's bloat in the table

787
00:25:41,440 --> 00:25:45,120
or if there's empty space i should say

788
00:25:43,200 --> 00:25:46,799
in the table that means that if we have

789
00:25:45,120 --> 00:25:48,158
to add a new tuple that table we don't

790
00:25:46,799 --> 00:25:50,720
have to extend it

791
00:25:48,159 --> 00:25:51,360
right extending a table is expensive

792
00:25:50,720 --> 00:25:54,159
okay

793
00:25:51,360 --> 00:25:55,678
we've taken some steps to make things

794
00:25:54,159 --> 00:25:58,480
more performant around that but it's

795
00:25:55,679 --> 00:25:58,480
still not cheap

796
00:25:59,360 --> 00:26:02,559
all right so what are these different

797
00:26:00,799 --> 00:26:04,080
ways of getting data from postgres so

798
00:26:02,559 --> 00:26:06,000
the first one is that you can step

799
00:26:04,080 --> 00:26:08,639
through kind of every record

800
00:26:06,000 --> 00:26:10,320
using either a sequential scan or what's

801
00:26:08,640 --> 00:26:11,840
called a bitmap scan this is typically a

802
00:26:10,320 --> 00:26:14,320
pretty bulky operation

803
00:26:11,840 --> 00:26:14,879
right this works good for when you want

804
00:26:14,320 --> 00:26:17,039
to get like

805
00:26:14,880 --> 00:26:18,400
everything back from a table but it's

806
00:26:17,039 --> 00:26:20,240
not going to work very well when you

807
00:26:18,400 --> 00:26:22,000
only want specific records

808
00:26:20,240 --> 00:26:24,640
so in those cases what you'd prefer to

809
00:26:22,000 --> 00:26:26,880
use is a index right and you'll see that

810
00:26:24,640 --> 00:26:28,400
as an index scan node

811
00:26:26,880 --> 00:26:29,919
obviously you typically have to create

812
00:26:28,400 --> 00:26:30,640
these indexes in order to get them to be

813
00:26:29,919 --> 00:26:32,880
used

814
00:26:30,640 --> 00:26:35,200
but this will often require accessing

815
00:26:32,880 --> 00:26:37,679
both the index and the heap

816
00:26:35,200 --> 00:26:38,480
in some cases we'll be able to perform

817
00:26:37,679 --> 00:26:41,360
what's called an

818
00:26:38,480 --> 00:26:43,679
index only scan which is really nice so

819
00:26:41,360 --> 00:26:47,279
what this means is that every column

820
00:26:43,679 --> 00:26:48,400
you are returning exists inside of an

821
00:26:47,279 --> 00:26:51,520
index

822
00:26:48,400 --> 00:26:53,919
right or inside of a a specific index

823
00:26:51,520 --> 00:26:55,360
right and so what that allows us to do

824
00:26:53,919 --> 00:26:56,320
is that if all the columns are in the

825
00:26:55,360 --> 00:26:58,879
index

826
00:26:56,320 --> 00:27:00,799
and the visibility map is up to date

827
00:26:58,880 --> 00:27:01,360
okay this building map is what's updated

828
00:27:00,799 --> 00:27:04,639
by

829
00:27:01,360 --> 00:27:06,320
vacuum and auto vacuum then we can avoid

830
00:27:04,640 --> 00:27:07,360
going to the heap to check visibility

831
00:27:06,320 --> 00:27:10,639
information

832
00:27:07,360 --> 00:27:12,240
and that can be a huge win so

833
00:27:10,640 --> 00:27:13,840
think about these things where you're

834
00:27:12,240 --> 00:27:14,559
thinking about creating indexes like

835
00:27:13,840 --> 00:27:16,720
okay

836
00:27:14,559 --> 00:27:18,960
i'm creating this index so that i can

837
00:27:16,720 --> 00:27:21,760
find my rows really quickly but

838
00:27:18,960 --> 00:27:23,520
you know if i add this one other column

839
00:27:21,760 --> 00:27:25,520
then the entire query could potentially

840
00:27:23,520 --> 00:27:26,960
be answered from the index itself

841
00:27:25,520 --> 00:27:29,120
and i wouldn't have to go to the heap at

842
00:27:26,960 --> 00:27:29,120
all

843
00:27:30,320 --> 00:27:33,520
now what that's called typically is

844
00:27:31,840 --> 00:27:36,158
something called a covering index

845
00:27:33,520 --> 00:27:37,520
right postgres now has support for doing

846
00:27:36,159 --> 00:27:39,840
this even with

847
00:27:37,520 --> 00:27:41,360
unique indexes basically you can tell

848
00:27:39,840 --> 00:27:43,678
postgres okay

849
00:27:41,360 --> 00:27:44,799
for you know these three columns i want

850
00:27:43,679 --> 00:27:46,799
them to be unique

851
00:27:44,799 --> 00:27:48,480
but i want you to also include these

852
00:27:46,799 --> 00:27:50,799
other two columns

853
00:27:48,480 --> 00:27:51,840
inside of that index that's performing

854
00:27:50,799 --> 00:27:54,240
my uniqueness

855
00:27:51,840 --> 00:27:55,840
guarantees all these other two columns

856
00:27:54,240 --> 00:27:57,840
including the index though

857
00:27:55,840 --> 00:27:59,199
so that i can facilitate these index

858
00:27:57,840 --> 00:28:00,480
only scans

859
00:27:59,200 --> 00:28:02,399
right that can be a great way of

860
00:28:00,480 --> 00:28:05,520
speeding up your queries that are able

861
00:28:02,399 --> 00:28:07,439
to leverage index only scans

862
00:28:05,520 --> 00:28:08,879
when we're combining things in postgres

863
00:28:07,440 --> 00:28:11,520
we do a nested loop join

864
00:28:08,880 --> 00:28:13,279
a merge join or a hash join right so a

865
00:28:11,520 --> 00:28:14,399
nested loop join is basically stepping

866
00:28:13,279 --> 00:28:16,320
through

867
00:28:14,399 --> 00:28:17,520
one table and then hitting the other

868
00:28:16,320 --> 00:28:20,639
table every time

869
00:28:17,520 --> 00:28:22,559
right um which is good for small sets

870
00:28:20,640 --> 00:28:25,200
but it's not great for bulk

871
00:28:22,559 --> 00:28:26,960
data sets right much better for a bulk

872
00:28:25,200 --> 00:28:29,039
data set is like a merge join where

873
00:28:26,960 --> 00:28:31,919
we're basically walking two indexes

874
00:28:29,039 --> 00:28:33,760
ideally and interleaving them if the

875
00:28:31,919 --> 00:28:36,080
data isn't indexed though

876
00:28:33,760 --> 00:28:38,080
postgres if it does a merge join we're

877
00:28:36,080 --> 00:28:40,320
going to end up sorting it

878
00:28:38,080 --> 00:28:44,240
right on one side which can be very very

879
00:28:40,320 --> 00:28:46,320
expensive sorting is not cheap

880
00:28:44,240 --> 00:28:48,720
hash joins are the other way we can do

881
00:28:46,320 --> 00:28:50,799
it where we basically scan one table

882
00:28:48,720 --> 00:28:52,640
build up a hash table in memory and then

883
00:28:50,799 --> 00:28:54,399
bounce the other table against it

884
00:28:52,640 --> 00:28:56,320
obviously this has a slow start but it's

885
00:28:54,399 --> 00:29:00,639
extremely fast once we get

886
00:28:56,320 --> 00:29:00,639
that hash table built up into memory

887
00:29:01,520 --> 00:29:04,960
when we're talking about aggregates we

888
00:29:02,960 --> 00:29:07,919
have group bag and hashtag

889
00:29:04,960 --> 00:29:09,520
so for a group aggregation basically we

890
00:29:07,919 --> 00:29:12,000
need the input to be sorted

891
00:29:09,520 --> 00:29:13,120
sorting is expensive as i said but it's

892
00:29:12,000 --> 00:29:16,000
very very fast

893
00:29:13,120 --> 00:29:17,279
if it's say index based right if we can

894
00:29:16,000 --> 00:29:19,440
just reverse the table in

895
00:29:17,279 --> 00:29:20,399
index order and feed that into a group

896
00:29:19,440 --> 00:29:22,799
bag that's

897
00:29:20,399 --> 00:29:25,279
very very fast and it's not v it doesn't

898
00:29:22,799 --> 00:29:26,480
require very much memory or anything

899
00:29:25,279 --> 00:29:28,640
the other option is what's called a

900
00:29:26,480 --> 00:29:29,360
hashtag where we basically scan the

901
00:29:28,640 --> 00:29:31,760
table

902
00:29:29,360 --> 00:29:33,918
build a hash table and then as we find

903
00:29:31,760 --> 00:29:36,559
matching entries we combine the results

904
00:29:33,919 --> 00:29:38,320
this is clearly very memory intensive

905
00:29:36,559 --> 00:29:40,559
especially if you have a large grouping

906
00:29:38,320 --> 00:29:41,918
set that you're looking at

907
00:29:40,559 --> 00:29:44,080
now one thing i'll mention here is that

908
00:29:41,919 --> 00:29:45,360
there's a bunch of parallel options that

909
00:29:44,080 --> 00:29:47,279
are

910
00:29:45,360 --> 00:29:50,080
also parallel nodes that you may also

911
00:29:47,279 --> 00:29:51,919
see when you're looking at query plans

912
00:29:50,080 --> 00:29:53,360
and you're doing parallel operations

913
00:29:51,919 --> 00:29:54,799
inside of postgres but they kind of

914
00:29:53,360 --> 00:29:57,039
amount to the same kind of thing it's

915
00:29:54,799 --> 00:29:59,200
either a sequential scan an index scan

916
00:29:57,039 --> 00:30:00,640
or some kind of hash aggregate maybe a

917
00:29:59,200 --> 00:30:03,760
parallel hashtag

918
00:30:00,640 --> 00:30:03,760
right or group egg

919
00:30:03,919 --> 00:30:07,120
so what's the best plan right well it

920
00:30:05,440 --> 00:30:08,159
depends how does postgres figure out

921
00:30:07,120 --> 00:30:09,840
what the best plan is

922
00:30:08,159 --> 00:30:12,080
it gathers statistics it gathers

923
00:30:09,840 --> 00:30:12,799
statistics through analyze and vacuum

924
00:30:12,080 --> 00:30:14,720
analyze

925
00:30:12,799 --> 00:30:16,480
auto vacuum will do this for you

926
00:30:14,720 --> 00:30:17,279
automatically so it's another reason why

927
00:30:16,480 --> 00:30:19,919
you want to

928
00:30:17,279 --> 00:30:20,720
keep auto vacuum in play right because

929
00:30:19,919 --> 00:30:22,960
bad stats

930
00:30:20,720 --> 00:30:24,000
is going to give you bad plans so what

931
00:30:22,960 --> 00:30:25,679
do you want to do to figure out if

932
00:30:24,000 --> 00:30:26,559
you've got a bad plan or if you have bad

933
00:30:25,679 --> 00:30:29,279
stats well

934
00:30:26,559 --> 00:30:29,760
if you run explain analyze it's going to

935
00:30:29,279 --> 00:30:32,720
give you

936
00:30:29,760 --> 00:30:36,080
information about the actual results

937
00:30:32,720 --> 00:30:40,320
versus the estimates that we got back

938
00:30:36,080 --> 00:30:42,639
right so that's really really helpful

939
00:30:40,320 --> 00:30:44,320
for being able to say okay are my

940
00:30:42,640 --> 00:30:45,679
statistics any good and what you're

941
00:30:44,320 --> 00:30:48,320
looking for here is like

942
00:30:45,679 --> 00:30:48,720
order of magnitude type differences

943
00:30:48,320 --> 00:30:51,439
right

944
00:30:48,720 --> 00:30:52,000
you don't necessarily need to concern

945
00:30:51,440 --> 00:30:55,120
yourself

946
00:30:52,000 --> 00:30:58,159
if it's off by you know a percent or two

947
00:30:55,120 --> 00:31:00,719
right it's more like is it off by

948
00:30:58,159 --> 00:31:02,080
10x 100x that's when you start to say

949
00:31:00,720 --> 00:31:04,080
okay my stats

950
00:31:02,080 --> 00:31:05,918
maybe need some adjustment and one of

951
00:31:04,080 --> 00:31:07,199
the ways you can adjust your statistics

952
00:31:05,919 --> 00:31:09,279
is by adjusting what's called the

953
00:31:07,200 --> 00:31:11,120
statistics target

954
00:31:09,279 --> 00:31:13,279
in postgres you can set a statistics

955
00:31:11,120 --> 00:31:16,320
target that changes

956
00:31:13,279 --> 00:31:18,799
how much of the table we look at

957
00:31:16,320 --> 00:31:20,320
when we're doing an analyze to gather

958
00:31:18,799 --> 00:31:23,519
these statistics

959
00:31:20,320 --> 00:31:25,678
right by default it's it's not very high

960
00:31:23,519 --> 00:31:26,640
it's a hundred uh increasing it can be

961
00:31:25,679 --> 00:31:29,600
helpful

962
00:31:26,640 --> 00:31:30,960
at times what that also is going to do

963
00:31:29,600 --> 00:31:33,519
is going to increase the

964
00:31:30,960 --> 00:31:34,240
if you increase it it'll increase the

965
00:31:33,519 --> 00:31:36,640
histogram

966
00:31:34,240 --> 00:31:37,919
that postgres uses right and it's also

967
00:31:36,640 --> 00:31:40,240
going to increase

968
00:31:37,919 --> 00:31:41,679
um the collection of most common values

969
00:31:40,240 --> 00:31:43,760
that we store

970
00:31:41,679 --> 00:31:45,919
right i've also seen times when

971
00:31:43,760 --> 00:31:47,120
decreasing the statistics target has

972
00:31:45,919 --> 00:31:48,559
been helpful

973
00:31:47,120 --> 00:31:51,918
so think about playing with it

974
00:31:48,559 --> 00:31:53,678
potentially in both directions

975
00:31:51,919 --> 00:31:56,159
so you can automate the collection of

976
00:31:53,679 --> 00:31:58,640
plans for queries that are run

977
00:31:56,159 --> 00:32:01,440
using a tool called auto explain which

978
00:31:58,640 --> 00:32:03,519
logs explain for all the queries

979
00:32:01,440 --> 00:32:04,559
uh this is also based on on the length

980
00:32:03,519 --> 00:32:06,399
of time

981
00:32:04,559 --> 00:32:07,840
um but basically you put it into shared

982
00:32:06,399 --> 00:32:08,479
payload libraries and then you can set

983
00:32:07,840 --> 00:32:10,480
this log

984
00:32:08,480 --> 00:32:12,240
duration and you can say you want to log

985
00:32:10,480 --> 00:32:14,320
nested statements too it'll give you

986
00:32:12,240 --> 00:32:16,240
statements inside of plpg sql queries

987
00:32:14,320 --> 00:32:17,918
for example

988
00:32:16,240 --> 00:32:19,840
you can also have it log explain analyze

989
00:32:17,919 --> 00:32:21,840
but that's very expensive

990
00:32:19,840 --> 00:32:23,439
explain also gives you a few different

991
00:32:21,840 --> 00:32:23,918
options for how you can get the output

992
00:32:23,440 --> 00:32:26,880
out

993
00:32:23,919 --> 00:32:28,720
xml json and yaml and there's tools out

994
00:32:26,880 --> 00:32:30,960
there for analyzing this explain output

995
00:32:28,720 --> 00:32:32,720
pg admin three or four

996
00:32:30,960 --> 00:32:35,440
as well as a really really cool site

997
00:32:32,720 --> 00:32:38,159
called explain.topez.com

998
00:32:35,440 --> 00:32:39,440
this is a really really useful uh url to

999
00:32:38,159 --> 00:32:40,640
go to you can basically take your

1000
00:32:39,440 --> 00:32:42,799
explain plan

1001
00:32:40,640 --> 00:32:46,480
go here paste it in and it gives you a

1002
00:32:42,799 --> 00:32:48,559
really pretty visual representation

1003
00:32:46,480 --> 00:32:50,240
all right so let's talk about slow

1004
00:32:48,559 --> 00:32:52,080
queries right so

1005
00:32:50,240 --> 00:32:54,240
here are some examples of queries where

1006
00:32:52,080 --> 00:32:56,399
you might say okay

1007
00:32:54,240 --> 00:32:58,080
basically i've got a sequential scan

1008
00:32:56,399 --> 00:32:59,918
that's happening but i'm only returning

1009
00:32:58,080 --> 00:33:02,399
a single row without

1010
00:32:59,919 --> 00:33:04,080
any aggregation uh typically that means

1011
00:33:02,399 --> 00:33:05,840
you need to have an index

1012
00:33:04,080 --> 00:33:08,480
right you want to build an index that

1013
00:33:05,840 --> 00:33:10,000
can find whatever that one row is that

1014
00:33:08,480 --> 00:33:11,440
you're returning

1015
00:33:10,000 --> 00:33:13,760
because that's going to be a lot more

1016
00:33:11,440 --> 00:33:16,559
performant than sequentially scanning

1017
00:33:13,760 --> 00:33:18,240
the entire table

1018
00:33:16,559 --> 00:33:20,320
another one is that if you have like a

1019
00:33:18,240 --> 00:33:22,640
relatively small data set

1020
00:33:20,320 --> 00:33:25,039
and by small i mean you know not like

1021
00:33:22,640 --> 00:33:26,480
two rows but maybe a million rows or

1022
00:33:25,039 --> 00:33:27,279
something like that still relatively

1023
00:33:26,480 --> 00:33:28,640
small

1024
00:33:27,279 --> 00:33:31,039
and you're seeing a lot of sorting

1025
00:33:28,640 --> 00:33:33,600
happening or you're seeing a merge join

1026
00:33:31,039 --> 00:33:35,760
think about increasing work mem right

1027
00:33:33,600 --> 00:33:37,760
and why is this it's because

1028
00:33:35,760 --> 00:33:39,919
postgres will be like okay if work map

1029
00:33:37,760 --> 00:33:43,200
is only four megabytes

1030
00:33:39,919 --> 00:33:44,320
right then i'm not going to uh build a

1031
00:33:43,200 --> 00:33:46,399
hash table

1032
00:33:44,320 --> 00:33:48,080
inside of postgres it takes up more up

1033
00:33:46,399 --> 00:33:50,239
more than four megabytes

1034
00:33:48,080 --> 00:33:51,360
right and if i really want to do that

1035
00:33:50,240 --> 00:33:53,120
which can happen

1036
00:33:51,360 --> 00:33:55,120
when i hit that four megabyte boundary

1037
00:33:53,120 --> 00:33:58,320
i'm going to start using the disk

1038
00:33:55,120 --> 00:34:01,439
right and i'll do a i'll actually push

1039
00:33:58,320 --> 00:34:04,080
out things to disk and do uh batching

1040
00:34:01,440 --> 00:34:05,679
uh with the hash joint right so when you

1041
00:34:04,080 --> 00:34:06,879
start seeing a hash join that has

1042
00:34:05,679 --> 00:34:08,320
batching in it

1043
00:34:06,880 --> 00:34:09,919
that's going to be pretty expensive

1044
00:34:08,320 --> 00:34:12,879
because again it's going to be

1045
00:34:09,918 --> 00:34:14,399
writing out to temp files out on disk

1046
00:34:12,879 --> 00:34:17,679
and reading them back in

1047
00:34:14,399 --> 00:34:17,679
in order to perform the join

1048
00:34:17,760 --> 00:34:21,760
another area where work mem is actually

1049
00:34:20,399 --> 00:34:24,159
pretty important

1050
00:34:21,760 --> 00:34:26,320
is with bitmap heap scans i mentioned

1051
00:34:24,159 --> 00:34:28,159
this a little bit earlier but

1052
00:34:26,320 --> 00:34:29,839
when a bitmap heap scan is happening

1053
00:34:28,159 --> 00:34:30,399
what we're doing is we're scanning the

1054
00:34:29,839 --> 00:34:32,719
index

1055
00:34:30,399 --> 00:34:34,319
and building a bitmap in memory right

1056
00:34:32,719 --> 00:34:35,598
but where is that memory that memory is

1057
00:34:34,320 --> 00:34:38,960
work mem

1058
00:34:35,599 --> 00:34:40,879
right if we fill up work mem with

1059
00:34:38,960 --> 00:34:42,399
all of those pages that we want to go

1060
00:34:40,879 --> 00:34:43,279
visit and all those tuples we want to go

1061
00:34:42,399 --> 00:34:45,759
visit

1062
00:34:43,280 --> 00:34:47,040
inside of the heap as part of the bitmap

1063
00:34:45,760 --> 00:34:49,040
scan

1064
00:34:47,040 --> 00:34:50,480
we're going to start making that bitmap

1065
00:34:49,040 --> 00:34:52,480
be lossy

1066
00:34:50,480 --> 00:34:54,480
right what that means is that rather

1067
00:34:52,480 --> 00:34:56,719
than tracking an exact page

1068
00:34:54,480 --> 00:34:57,920
an exact tuple on that page that we want

1069
00:34:56,719 --> 00:34:59,598
to go visit

1070
00:34:57,920 --> 00:35:01,040
we're going to start rolling that up and

1071
00:34:59,599 --> 00:35:02,079
we're like okay well

1072
00:35:01,040 --> 00:35:04,320
you know we're gonna potentially roll it

1073
00:35:02,079 --> 00:35:05,680
up to like a page level we're gonna say

1074
00:35:04,320 --> 00:35:07,680
okay

1075
00:35:05,680 --> 00:35:09,200
with this bitmap index scan with this

1076
00:35:07,680 --> 00:35:11,040
bitmap heapscan we have to go

1077
00:35:09,200 --> 00:35:12,399
to a particular page and we know what

1078
00:35:11,040 --> 00:35:14,160
page that is

1079
00:35:12,400 --> 00:35:16,640
but now when we get to that page we have

1080
00:35:14,160 --> 00:35:19,680
to scan the entire page

1081
00:35:16,640 --> 00:35:21,680
and compare every tuple on that page to

1082
00:35:19,680 --> 00:35:23,839
see if it matches our requirement

1083
00:35:21,680 --> 00:35:26,240
right whatever our conditionals are and

1084
00:35:23,839 --> 00:35:27,359
if it doesn't match our conditionals

1085
00:35:26,240 --> 00:35:30,000
then we're going to throw it away and

1086
00:35:27,359 --> 00:35:32,319
we'll have wasted a bunch of time

1087
00:35:30,000 --> 00:35:33,280
so when you start to think about work

1088
00:35:32,320 --> 00:35:36,320
mem think about

1089
00:35:33,280 --> 00:35:37,359
bitmap heap scans bitmap index scans as

1090
00:35:36,320 --> 00:35:40,640
well as

1091
00:35:37,359 --> 00:35:40,640
sorts and hash joins

1092
00:35:42,640 --> 00:35:46,720
so an area where maybe your statistics

1093
00:35:45,040 --> 00:35:48,079
are looking a little bit off

1094
00:35:46,720 --> 00:35:49,359
right for example if you have like a

1095
00:35:48,079 --> 00:35:50,640
large data set and you're getting a

1096
00:35:49,359 --> 00:35:52,960
nested loop

1097
00:35:50,640 --> 00:35:54,160
right this happens from time to time

1098
00:35:52,960 --> 00:35:56,240
with postgres when you

1099
00:35:54,160 --> 00:35:57,680
have not done an analyze at all on a

1100
00:35:56,240 --> 00:35:59,598
table in particular

1101
00:35:57,680 --> 00:36:01,440
right because by default postgres if it

1102
00:35:59,599 --> 00:36:02,720
doesn't see any stats for a table

1103
00:36:01,440 --> 00:36:04,480
it's going to assume the table is pretty

1104
00:36:02,720 --> 00:36:06,560
small right

1105
00:36:04,480 --> 00:36:07,920
and it hasn't got a lot on it and it's

1106
00:36:06,560 --> 00:36:11,040
certainly not very interesting

1107
00:36:07,920 --> 00:36:12,560
so that can be a problem but other cases

1108
00:36:11,040 --> 00:36:14,320
can be we just don't

1109
00:36:12,560 --> 00:36:16,000
expect very much in the way of a result

1110
00:36:14,320 --> 00:36:16,560
set from this table for this particular

1111
00:36:16,000 --> 00:36:18,480
query

1112
00:36:16,560 --> 00:36:20,480
and you can help that by increasing your

1113
00:36:18,480 --> 00:36:23,520
statistics target

1114
00:36:20,480 --> 00:36:25,520
and making sure your stats are current

1115
00:36:23,520 --> 00:36:26,640
another one is that if you have indexes

1116
00:36:25,520 --> 00:36:29,040
um

1117
00:36:26,640 --> 00:36:31,200
sorry if you have foreign keys right

1118
00:36:29,040 --> 00:36:34,079
postgres when you do a delete

1119
00:36:31,200 --> 00:36:35,279
has to go verify that that uh key that

1120
00:36:34,079 --> 00:36:36,800
you're deleting

1121
00:36:35,280 --> 00:36:38,560
isn't in any of the tables that are

1122
00:36:36,800 --> 00:36:41,760
referencing that

1123
00:36:38,560 --> 00:36:44,560
uh that table right basically all of the

1124
00:36:41,760 --> 00:36:46,480
referring tables now postgres doesn't

1125
00:36:44,560 --> 00:36:49,440
require you to have an index

1126
00:36:46,480 --> 00:36:50,079
on that column in the referring table

1127
00:36:49,440 --> 00:36:52,079
okay

1128
00:36:50,079 --> 00:36:53,200
so if you do that delete and there's no

1129
00:36:52,079 --> 00:36:54,000
index there we're just going to

1130
00:36:53,200 --> 00:36:56,240
sequentially

1131
00:36:54,000 --> 00:36:58,000
scan it which is going to take forever

1132
00:36:56,240 --> 00:36:59,680
for a delete to run if you're deleting a

1133
00:36:58,000 --> 00:37:01,520
lot of keys

1134
00:36:59,680 --> 00:37:04,399
so what you can do instead is you can go

1135
00:37:01,520 --> 00:37:06,640
create an index on that referring table

1136
00:37:04,400 --> 00:37:10,720
for whatever column it is that is

1137
00:37:06,640 --> 00:37:10,720
pointing up to the referred to table

1138
00:37:11,760 --> 00:37:15,760
another one that's good is preparing

1139
00:37:13,440 --> 00:37:17,359
your queries right so if you prepare

1140
00:37:15,760 --> 00:37:19,200
your queries you can avoid repeating

1141
00:37:17,359 --> 00:37:21,279
your planning costs right

1142
00:37:19,200 --> 00:37:23,439
so the plan cache has both generic and

1143
00:37:21,280 --> 00:37:24,640
specific plans

1144
00:37:23,440 --> 00:37:26,400
and it's kind of an interesting thing

1145
00:37:24,640 --> 00:37:28,319
i'm not going to cover too much but

1146
00:37:26,400 --> 00:37:29,839
basically if you prepare your query

1147
00:37:28,320 --> 00:37:31,440
then you can explain it using this

1148
00:37:29,839 --> 00:37:34,160
explain execute and you can

1149
00:37:31,440 --> 00:37:36,000
explain analyze execute as well but this

1150
00:37:34,160 --> 00:37:37,520
will save you overall on planning

1151
00:37:36,000 --> 00:37:39,760
time by preparing your queries ahead of

1152
00:37:37,520 --> 00:37:39,759
time

1153
00:37:40,079 --> 00:37:42,960
so some of the other things that you

1154
00:37:41,760 --> 00:37:44,640
might want to look at right if you have

1155
00:37:42,960 --> 00:37:46,640
a big select count star

1156
00:37:44,640 --> 00:37:48,078
an index can help on this case right

1157
00:37:46,640 --> 00:37:50,560
because the select count star isn't

1158
00:37:48,079 --> 00:37:52,160
returning anything from the actual heap

1159
00:37:50,560 --> 00:37:54,720
as long as your visibility map is

1160
00:37:52,160 --> 00:37:55,359
accurate we can use an index only scan

1161
00:37:54,720 --> 00:37:56,640
here

1162
00:37:55,359 --> 00:37:57,680
right your visibility map should be

1163
00:37:56,640 --> 00:37:59,680
accurate as long as you're running

1164
00:37:57,680 --> 00:38:01,118
vacuum or auto vacuum

1165
00:37:59,680 --> 00:38:03,118
another one that people commonly do is

1166
00:38:01,119 --> 00:38:05,200
they do like a select star from a table

1167
00:38:03,119 --> 00:38:06,960
that returns all of the columns in all

1168
00:38:05,200 --> 00:38:09,439
of the rows right

1169
00:38:06,960 --> 00:38:10,079
is every row needed is every column

1170
00:38:09,440 --> 00:38:11,920
needed

1171
00:38:10,079 --> 00:38:14,079
right in particular if you have any

1172
00:38:11,920 --> 00:38:14,720
value that's over 2k in a particular

1173
00:38:14,079 --> 00:38:16,079
column

1174
00:38:14,720 --> 00:38:17,520
postgres is going to do something called

1175
00:38:16,079 --> 00:38:18,320
toasting which means we're going to

1176
00:38:17,520 --> 00:38:20,079
shove that

1177
00:38:18,320 --> 00:38:22,160
tuple or that value out into another

1178
00:38:20,079 --> 00:38:23,200
table right it's going to be expensive

1179
00:38:22,160 --> 00:38:25,040
for us to

1180
00:38:23,200 --> 00:38:26,640
pull that back from the other table

1181
00:38:25,040 --> 00:38:27,440
decompress it because we automatically

1182
00:38:26,640 --> 00:38:29,680
compress it

1183
00:38:27,440 --> 00:38:31,359
and return it to the client and if that

1184
00:38:29,680 --> 00:38:32,720
column isn't needed

1185
00:38:31,359 --> 00:38:34,640
it's going to be ridiculous right it's

1186
00:38:32,720 --> 00:38:36,240
just it's just a lot of wasted time and

1187
00:38:34,640 --> 00:38:37,759
energy

1188
00:38:36,240 --> 00:38:39,680
another thing to watch out for is select

1189
00:38:37,760 --> 00:38:41,440
the stink star right

1190
00:38:39,680 --> 00:38:43,359
often that is actually an indication

1191
00:38:41,440 --> 00:38:45,599
that you forgot a join

1192
00:38:43,359 --> 00:38:47,200
right some kind of joint condition so

1193
00:38:45,599 --> 00:38:48,560
for example here we don't have a joint

1194
00:38:47,200 --> 00:38:50,000
condition for c

1195
00:38:48,560 --> 00:38:51,440
so we're going to create a cartesian

1196
00:38:50,000 --> 00:38:53,359
product and then we're going to remove a

1197
00:38:51,440 --> 00:38:55,440
whole bunch of duplicates that

1198
00:38:53,359 --> 00:38:57,598
would have come out of it so it's a lot

1199
00:38:55,440 --> 00:39:01,680
better to use like join syntax like this

1200
00:38:57,599 --> 00:39:04,640
down here rather than doing a comma join

1201
00:39:01,680 --> 00:39:06,078
that can help you avoid those cases

1202
00:39:04,640 --> 00:39:07,440
typically the slight distinct is

1203
00:39:06,079 --> 00:39:08,240
something that should not be needed very

1204
00:39:07,440 --> 00:39:11,599
often

1205
00:39:08,240 --> 00:39:13,839
so definitely watch out for that

1206
00:39:11,599 --> 00:39:15,200
another case here is like a select star

1207
00:39:13,839 --> 00:39:17,680
with an in clause

1208
00:39:15,200 --> 00:39:19,359
right this can be turned into a join and

1209
00:39:17,680 --> 00:39:21,200
that typically allows us to have more

1210
00:39:19,359 --> 00:39:23,920
options for how to execute the query

1211
00:39:21,200 --> 00:39:24,720
it's even more important on a not in

1212
00:39:23,920 --> 00:39:26,320
right

1213
00:39:24,720 --> 00:39:28,000
in fact this actually what you want to

1214
00:39:26,320 --> 00:39:30,480
have here is turn this into a left

1215
00:39:28,000 --> 00:39:31,920
join um or what's also called an

1216
00:39:30,480 --> 00:39:34,240
anti-join

1217
00:39:31,920 --> 00:39:35,280
right what's a lot better usually is to

1218
00:39:34,240 --> 00:39:37,439
use exists

1219
00:39:35,280 --> 00:39:39,440
or to use it not exist when you're

1220
00:39:37,440 --> 00:39:40,720
thinking about these kinds of queries

1221
00:39:39,440 --> 00:39:42,640
so i for whatever reason that doesn't

1222
00:39:40,720 --> 00:39:44,319
seem to be very common but definitely

1223
00:39:42,640 --> 00:39:45,680
recommend using like a not exists

1224
00:39:44,320 --> 00:39:46,640
because postcards will recognize that

1225
00:39:45,680 --> 00:39:50,319
more easily

1226
00:39:46,640 --> 00:39:52,480
as an anti-join um

1227
00:39:50,320 --> 00:39:53,520
for older versions of postgres this is

1228
00:39:52,480 --> 00:39:55,200
actually something that changed very

1229
00:39:53,520 --> 00:39:57,040
recently in postgres

1230
00:39:55,200 --> 00:39:58,960
if you're using ctes that's a with

1231
00:39:57,040 --> 00:40:00,320
clause like this

1232
00:39:58,960 --> 00:40:02,160
what we're going to actually do is we're

1233
00:40:00,320 --> 00:40:04,960
going to run the entire cte

1234
00:40:02,160 --> 00:40:07,040
shove it into a temp table essentially

1235
00:40:04,960 --> 00:40:10,319
and then use that table afterwards

1236
00:40:07,040 --> 00:40:12,079
right it's called materializing the cte

1237
00:40:10,319 --> 00:40:13,599
so that can be very expensive so what

1238
00:40:12,079 --> 00:40:15,599
you really want to do is

1239
00:40:13,599 --> 00:40:17,440
put your expensive stuff inside of the

1240
00:40:15,599 --> 00:40:19,760
cte or in all your filtering

1241
00:40:17,440 --> 00:40:21,280
inside of the cte and then do things

1242
00:40:19,760 --> 00:40:21,599
outside of it later but you want to try

1243
00:40:21,280 --> 00:40:23,520
to

1244
00:40:21,599 --> 00:40:24,880
eliminate as much as possible in your

1245
00:40:23,520 --> 00:40:28,240
first cte

1246
00:40:24,880 --> 00:40:30,240
now this has changed with postgres 12.

1247
00:40:28,240 --> 00:40:31,359
postgres 12 allows you the option of

1248
00:40:30,240 --> 00:40:33,759
whether you want the

1249
00:40:31,359 --> 00:40:35,440
cte to be materialized or not and by

1250
00:40:33,760 --> 00:40:36,000
default we're not going to materialize

1251
00:40:35,440 --> 00:40:37,280
it

1252
00:40:36,000 --> 00:40:38,880
right what that means is that we're

1253
00:40:37,280 --> 00:40:39,200
going to take that cte and we're going

1254
00:40:38,880 --> 00:40:41,440
to

1255
00:40:39,200 --> 00:40:43,359
optimize it as if it was part of the

1256
00:40:41,440 --> 00:40:45,280
overall query

1257
00:40:43,359 --> 00:40:47,119
now that's a big change so definitely if

1258
00:40:45,280 --> 00:40:48,400
you're on earlier versions of postgres

1259
00:40:47,119 --> 00:40:50,480
and you're using ctes

1260
00:40:48,400 --> 00:40:51,680
test your applications out right make

1261
00:40:50,480 --> 00:40:54,640
sure that they work well

1262
00:40:51,680 --> 00:40:56,078
with 12 and that you're not seeing um

1263
00:40:54,640 --> 00:40:57,680
issues here

1264
00:40:56,079 --> 00:40:59,520
uh something else you can do if you want

1265
00:40:57,680 --> 00:41:01,759
like a really fast count star

1266
00:40:59,520 --> 00:41:03,359
is to use the database statistics so

1267
00:41:01,760 --> 00:41:05,520
there's this thing called well tuples in

1268
00:41:03,359 --> 00:41:06,078
pg class it only works for whole tables

1269
00:41:05,520 --> 00:41:07,359
though

1270
00:41:06,079 --> 00:41:09,040
and it's not very perfect if you want

1271
00:41:07,359 --> 00:41:10,880
something better use a trigger-based

1272
00:41:09,040 --> 00:41:13,200
approach

1273
00:41:10,880 --> 00:41:14,800
so when you want to do some kind of

1274
00:41:13,200 --> 00:41:16,240
tuning of postgres

1275
00:41:14,800 --> 00:41:17,839
definitely want to look at increasing

1276
00:41:16,240 --> 00:41:19,520
work mem if you're looking at

1277
00:41:17,839 --> 00:41:21,440
particularly for queries

1278
00:41:19,520 --> 00:41:22,640
if you want to improve your performance

1279
00:41:21,440 --> 00:41:25,200
when it comes to

1280
00:41:22,640 --> 00:41:27,359
creating indexes or doing vacuums

1281
00:41:25,200 --> 00:41:29,118
increase your maintenance work mem

1282
00:41:27,359 --> 00:41:30,400
and set effective cache size the other

1283
00:41:29,119 --> 00:41:33,119
thing you can look at is increasing

1284
00:41:30,400 --> 00:41:33,119
shared buffers

1285
00:41:33,200 --> 00:41:36,640
a couple of other things that are really

1286
00:41:34,400 --> 00:41:38,000
really good are partial indexes and

1287
00:41:36,640 --> 00:41:39,839
functional indexes

1288
00:41:38,000 --> 00:41:42,000
so you a partial index is an index that

1289
00:41:39,839 --> 00:41:44,640
you create with a where clause

1290
00:41:42,000 --> 00:41:45,920
right and so you can say well i only

1291
00:41:44,640 --> 00:41:49,118
want to index

1292
00:41:45,920 --> 00:41:52,000
um this column when or sorry

1293
00:41:49,119 --> 00:41:53,599
these rows when the state right maybe i

1294
00:41:52,000 --> 00:41:55,520
haven't got a state machine

1295
00:41:53,599 --> 00:41:56,720
right i want the state when the state is

1296
00:41:55,520 --> 00:41:59,040
open

1297
00:41:56,720 --> 00:42:00,799
okay what does that do that means i can

1298
00:41:59,040 --> 00:42:01,520
very quickly find all of the open

1299
00:42:00,800 --> 00:42:04,079
records

1300
00:42:01,520 --> 00:42:05,599
inside of that table and the force that

1301
00:42:04,079 --> 00:42:07,280
index can have some other columns to

1302
00:42:05,599 --> 00:42:08,880
allow you to further constrain it

1303
00:42:07,280 --> 00:42:11,520
but the index will be smaller to begin

1304
00:42:08,880 --> 00:42:13,520
with which is really really nice

1305
00:42:11,520 --> 00:42:16,079
functional indexes allow you to

1306
00:42:13,520 --> 00:42:19,119
basically say i want to index the result

1307
00:42:16,079 --> 00:42:20,800
of this function right so i can have

1308
00:42:19,119 --> 00:42:23,280
some kind of function that i want to run

1309
00:42:20,800 --> 00:42:24,800
and whenever i have like where you know

1310
00:42:23,280 --> 00:42:26,480
my function of whatever

1311
00:42:24,800 --> 00:42:29,040
on this particular column equals some

1312
00:42:26,480 --> 00:42:30,000
value if i create a functional index in

1313
00:42:29,040 --> 00:42:32,880
postgres on whatever

1314
00:42:30,000 --> 00:42:34,319
that function is we can use that instead

1315
00:42:32,880 --> 00:42:36,400
of having to scan the entire table and

1316
00:42:34,319 --> 00:42:39,040
run the function in every row

1317
00:42:36,400 --> 00:42:40,480
very very useful capability do make sure

1318
00:42:39,040 --> 00:42:42,160
you double check that the query plan

1319
00:42:40,480 --> 00:42:45,520
that's actually used

1320
00:42:42,160 --> 00:42:47,680
um is oh sorry the query plan used

1321
00:42:45,520 --> 00:42:49,359
is using your index sometimes with

1322
00:42:47,680 --> 00:42:50,078
functional indexes it can get a little

1323
00:42:49,359 --> 00:42:51,839
bit

1324
00:42:50,079 --> 00:42:53,280
uh confusing making sure that you have

1325
00:42:51,839 --> 00:42:56,560
the right data types uh

1326
00:42:53,280 --> 00:42:58,720
used also if you have

1327
00:42:56,560 --> 00:43:00,078
performance issues where queries and

1328
00:42:58,720 --> 00:43:03,118
whatnot are going

1329
00:43:00,079 --> 00:43:04,720
slowly or you know like inserts and

1330
00:43:03,119 --> 00:43:06,160
updates are going slowly

1331
00:43:04,720 --> 00:43:08,240
you may want to go look and see if you

1332
00:43:06,160 --> 00:43:10,000
have any unused indexes

1333
00:43:08,240 --> 00:43:11,680
right unused indexes still have to be

1334
00:43:10,000 --> 00:43:13,040
maintained we still have to update them

1335
00:43:11,680 --> 00:43:14,640
we have to write to them

1336
00:43:13,040 --> 00:43:16,960
and that can make a big difference in

1337
00:43:14,640 --> 00:43:20,160
terms of your query performance

1338
00:43:16,960 --> 00:43:21,680
when you're adding in new rows in some

1339
00:43:20,160 --> 00:43:22,480
way either through an insert or an

1340
00:43:21,680 --> 00:43:24,640
update

1341
00:43:22,480 --> 00:43:26,560
you can look inside of this table called

1342
00:43:24,640 --> 00:43:28,640
pg stat user indexes

1343
00:43:26,560 --> 00:43:29,839
that's going to tell you how often that

1344
00:43:28,640 --> 00:43:31,598
index is being used

1345
00:43:29,839 --> 00:43:33,520
and why it's being used if there's any

1346
00:43:31,599 --> 00:43:35,200
particular reason why

1347
00:43:33,520 --> 00:43:36,720
or sorry not why it's meaning but you

1348
00:43:35,200 --> 00:43:38,240
can then look at that query and say okay

1349
00:43:36,720 --> 00:43:40,240
is there some reason why

1350
00:43:38,240 --> 00:43:42,799
this index exists even though it's never

1351
00:43:40,240 --> 00:43:42,799
being used

1352
00:43:43,119 --> 00:43:48,400
one thing to note about that is indexes

1353
00:43:46,319 --> 00:43:50,640
are also used for backing constraints

1354
00:43:48,400 --> 00:43:52,800
things like uniqueness constraints

1355
00:43:50,640 --> 00:43:54,000
right are are backed by an index and

1356
00:43:52,800 --> 00:43:57,119
you'll see those indexes

1357
00:43:54,000 --> 00:43:59,520
in pg stat user indexes so even if you

1358
00:43:57,119 --> 00:44:01,760
don't see those indexes being used

1359
00:43:59,520 --> 00:44:04,160
don't go and remove them you really want

1360
00:44:01,760 --> 00:44:05,839
to have those constraints enforced

1361
00:44:04,160 --> 00:44:08,160
right there's a reason why you have them

1362
00:44:05,839 --> 00:44:10,160
and that's important

1363
00:44:08,160 --> 00:44:11,920
all right and that's what i've got but i

1364
00:44:10,160 --> 00:44:16,560
still have five minutes or so for

1365
00:44:11,920 --> 00:44:16,560
for a question so questions

1366
00:44:16,960 --> 00:44:23,839
yeah sure whatever

1367
00:44:27,359 --> 00:44:30,400
yes right if you set work mem very high

1368
00:44:29,760 --> 00:44:32,079
now

1369
00:44:30,400 --> 00:44:34,480
uh one thing to note here is that

1370
00:44:32,079 --> 00:44:36,400
postgres will only allocate

1371
00:44:34,480 --> 00:44:38,000
work mem as needed right we're not just

1372
00:44:36,400 --> 00:44:41,280
going to go like allocate at all

1373
00:44:38,000 --> 00:44:44,079
right so you can set workmen very high

1374
00:44:41,280 --> 00:44:45,680
and it'll work potentially pretty well

1375
00:44:44,079 --> 00:44:46,720
until you actually run the box out of

1376
00:44:45,680 --> 00:44:48,078
memory

1377
00:44:46,720 --> 00:44:49,598
right because that's going to

1378
00:44:48,079 --> 00:44:50,079
potentially happen if you set workmen

1379
00:44:49,599 --> 00:44:51,599
very high

1380
00:44:50,079 --> 00:44:53,280
and you have a lot of queries that all

1381
00:44:51,599 --> 00:44:54,800
come in that all want to do like big

1382
00:44:53,280 --> 00:44:56,400
sorts all at once

1383
00:44:54,800 --> 00:44:57,839
right postgres is going to end up

1384
00:44:56,400 --> 00:44:59,440
allocating memory

1385
00:44:57,839 --> 00:45:00,960
for all of that time you know for all of

1386
00:44:59,440 --> 00:45:02,560
those sorts and you could potentially

1387
00:45:00,960 --> 00:45:04,240
run the box out of memory

1388
00:45:02,560 --> 00:45:06,560
right now if the system's configured

1389
00:45:04,240 --> 00:45:08,720
properly you know that should mean that

1390
00:45:06,560 --> 00:45:11,440
just one of those processes gets a

1391
00:45:08,720 --> 00:45:13,279
a malik error and it gets you know

1392
00:45:11,440 --> 00:45:15,359
basically it'll give up on the query

1393
00:45:13,280 --> 00:45:17,599
shut the transaction down and free all

1394
00:45:15,359 --> 00:45:20,000
the memory right but that still can be

1395
00:45:17,599 --> 00:45:21,280
impactful on your system right

1396
00:45:20,000 --> 00:45:22,640
especially if you start thinking that

1397
00:45:21,280 --> 00:45:23,599
well maybe it's starting to swap or

1398
00:45:22,640 --> 00:45:25,839
something like that

1399
00:45:23,599 --> 00:45:27,839
that gets to be really bad right that

1400
00:45:25,839 --> 00:45:29,759
can really hurt performance a lot

1401
00:45:27,839 --> 00:45:31,920
so i don't recommend setting workmen

1402
00:45:29,760 --> 00:45:33,440
super high what i tend to find is that a

1403
00:45:31,920 --> 00:45:33,760
lot of your queries are either going to

1404
00:45:33,440 --> 00:45:36,000
be

1405
00:45:33,760 --> 00:45:37,359
like big analytical queries and you know

1406
00:45:36,000 --> 00:45:40,160
which ones those are

1407
00:45:37,359 --> 00:45:40,480
or they're going to be relatively short

1408
00:45:40,160 --> 00:45:43,920
uh

1409
00:45:40,480 --> 00:45:45,440
like oltp type of queries right and so

1410
00:45:43,920 --> 00:45:46,960
what i would say is that when you are

1411
00:45:45,440 --> 00:45:48,079
running those big analytical queries and

1412
00:45:46,960 --> 00:45:49,359
you know you're not going to have a lot

1413
00:45:48,079 --> 00:45:51,760
of them running in the system

1414
00:45:49,359 --> 00:45:53,200
you can set work mem on that session

1415
00:45:51,760 --> 00:45:56,160
right before you run your big

1416
00:45:53,200 --> 00:45:57,919
analytical query and reset it afterwards

1417
00:45:56,160 --> 00:45:58,960
right so i would recommend setting it

1418
00:45:57,920 --> 00:46:00,800
like that on a

1419
00:45:58,960 --> 00:46:03,040
kind of per query basis not just

1420
00:46:00,800 --> 00:46:06,960
globally really high

1421
00:46:03,040 --> 00:46:09,759
other questions yes

1422
00:46:06,960 --> 00:46:10,720
statistics target number like what does

1423
00:46:09,760 --> 00:46:13,680
it mean is it a

1424
00:46:10,720 --> 00:46:14,160
percentage or like what it represents

1425
00:46:13,680 --> 00:46:16,000
yes

1426
00:46:14,160 --> 00:46:17,200
it essentially represents a percent

1427
00:46:16,000 --> 00:46:18,800
right so

1428
00:46:17,200 --> 00:46:20,799
my recollection is i think a thousand is

1429
00:46:18,800 --> 00:46:22,880
one percent right

1430
00:46:20,800 --> 00:46:24,720
um of the table which is pretty high

1431
00:46:22,880 --> 00:46:27,200
actually you don't really want to set it

1432
00:46:24,720 --> 00:46:28,720
super high like that right i think in

1433
00:46:27,200 --> 00:46:30,399
general the default citizen started as

1434
00:46:28,720 --> 00:46:32,560
100 is is quite good

1435
00:46:30,400 --> 00:46:33,520
and you want your analyzes to be able to

1436
00:46:32,560 --> 00:46:35,759
continue to run

1437
00:46:33,520 --> 00:46:37,680
pretty efficiently right because if you

1438
00:46:35,760 --> 00:46:38,560
start amping the statistics circuit up

1439
00:46:37,680 --> 00:46:40,960
really high

1440
00:46:38,560 --> 00:46:42,000
you're collecting more statistics right

1441
00:46:40,960 --> 00:46:44,560
but that's also going to

1442
00:46:42,000 --> 00:46:45,680
mean that the analyze takes longer right

1443
00:46:44,560 --> 00:46:47,200
and you're going to have more data for

1444
00:46:45,680 --> 00:46:48,720
the planner to have to consider

1445
00:46:47,200 --> 00:46:50,799
so that can have an impact on planning

1446
00:46:48,720 --> 00:46:51,680
performance too so there's trade-offs to

1447
00:46:50,800 --> 00:46:53,520
setting it up

1448
00:46:51,680 --> 00:46:56,160
setting it which is why it's

1449
00:46:53,520 --> 00:46:56,160
configurable

1450
00:47:05,119 --> 00:47:08,319
a distribution key you're talking about

1451
00:47:06,480 --> 00:47:11,359
like off of

1452
00:47:08,319 --> 00:47:13,440
yeah talking about distribution keys so

1453
00:47:11,359 --> 00:47:16,319
you're asking about distributing across

1454
00:47:13,440 --> 00:47:18,079
multiple different nodes for example

1455
00:47:16,319 --> 00:47:19,759
so that's that's kind of outside of the

1456
00:47:18,079 --> 00:47:20,240
scope of postgres but at the end of the

1457
00:47:19,760 --> 00:47:22,079
day

1458
00:47:20,240 --> 00:47:24,959
it's hard right to figure out a good

1459
00:47:22,079 --> 00:47:24,960
distribution key

1460
00:47:25,040 --> 00:47:27,839
and you're going to end up with hot

1461
00:47:26,000 --> 00:47:28,559
spots no matter what you end up doing

1462
00:47:27,839 --> 00:47:32,160
ultimately

1463
00:47:28,559 --> 00:47:33,440
right so i would tend to say that

1464
00:47:32,160 --> 00:47:35,040
well i don't know there's a bunch of

1465
00:47:33,440 --> 00:47:37,119
different ways to look at it right if

1466
00:47:35,040 --> 00:47:39,359
you have a natural one that's great but

1467
00:47:37,119 --> 00:47:41,200
if you don't sometimes the hash works

1468
00:47:39,359 --> 00:47:42,880
right you can just hash some value

1469
00:47:41,200 --> 00:47:44,240
across it but you're going to end up

1470
00:47:42,880 --> 00:47:45,920
with hot spots because of that

1471
00:47:44,240 --> 00:47:47,520
right it's just not an easy problem to

1472
00:47:45,920 --> 00:47:50,000
solve so i don't think i have any

1473
00:47:47,520 --> 00:47:52,160
like generic recommendations for that

1474
00:47:50,000 --> 00:47:55,119
unfortunately it's just not trivial

1475
00:47:52,160 --> 00:47:55,839
other questions yeah um when you you

1476
00:47:55,119 --> 00:47:57,680
mentioned

1477
00:47:55,839 --> 00:47:59,520
analyzing vacuum one of the scenarios i

1478
00:47:57,680 --> 00:48:01,359
work for is i'm testing a new index

1479
00:47:59,520 --> 00:48:03,200
and i typically run an analyzer i get

1480
00:48:01,359 --> 00:48:04,558
stats should i be running a vacuum to

1481
00:48:03,200 --> 00:48:08,399
update the visibility map

1482
00:48:04,559 --> 00:48:10,319
as well so when you create an index

1483
00:48:08,400 --> 00:48:11,520
right that doesn't actually change

1484
00:48:10,319 --> 00:48:12,558
anything when it comes to either the

1485
00:48:11,520 --> 00:48:15,599
visibility map

1486
00:48:12,559 --> 00:48:17,760
or the analyze statistics right so

1487
00:48:15,599 --> 00:48:18,640
you don't actually need to rerun analyze

1488
00:48:17,760 --> 00:48:21,280
number one

1489
00:48:18,640 --> 00:48:22,879
and number two uh the visibility map is

1490
00:48:21,280 --> 00:48:25,440
either gonna be updated or it's not

1491
00:48:22,880 --> 00:48:27,280
right so whenever you know that's not

1492
00:48:25,440 --> 00:48:28,559
gonna be related to creating the index

1493
00:48:27,280 --> 00:48:30,400
so if you create an index and you see

1494
00:48:28,559 --> 00:48:32,319
that it's not being used for an index

1495
00:48:30,400 --> 00:48:33,760
only scan where you thought it would be

1496
00:48:32,319 --> 00:48:35,119
it might be that your visibility map is

1497
00:48:33,760 --> 00:48:35,920
out of date and you need to go update it

1498
00:48:35,119 --> 00:48:39,119
with a vacuum

1499
00:48:35,920 --> 00:48:40,640
so yes maybe that would be relevant but

1500
00:48:39,119 --> 00:48:42,160
if that's happening you should be

1501
00:48:40,640 --> 00:48:45,200
looking at how you

1502
00:48:42,160 --> 00:48:47,200
uh enable how you make sure

1503
00:48:45,200 --> 00:48:48,480
vacuum is running more frequently on

1504
00:48:47,200 --> 00:48:49,919
that table so that you

1505
00:48:48,480 --> 00:48:52,000
can consistently have an up-to-date

1506
00:48:49,920 --> 00:48:52,880
visibility map right so there's some

1507
00:48:52,000 --> 00:48:55,599
options to

1508
00:48:52,880 --> 00:48:57,520
auto vacuum where you can say reduce

1509
00:48:55,599 --> 00:49:00,800
some of the limits for when auto vacuum

1510
00:48:57,520 --> 00:49:00,800
is run on a table to make it run more

1511
00:49:00,839 --> 00:49:04,000
frequently

1512
00:49:02,880 --> 00:49:05,599
but you don't yeah if you test it

1513
00:49:04,000 --> 00:49:07,599
immediately afterwards i mean the

1514
00:49:05,599 --> 00:49:10,559
visibility map should be updated unless

1515
00:49:07,599 --> 00:49:10,960
vacuum hasn't run on that in a long time

1516
00:49:10,559 --> 00:49:13,440
right

1517
00:49:10,960 --> 00:49:14,160
it should be there and the analyze stats

1518
00:49:13,440 --> 00:49:15,359
again

1519
00:49:14,160 --> 00:49:16,960
creating index doesn't change the

1520
00:49:15,359 --> 00:49:18,160
analyzed stats with well i will craft

1521
00:49:16,960 --> 00:49:19,200
you at that there is one exception

1522
00:49:18,160 --> 00:49:22,160
that's if you use

1523
00:49:19,200 --> 00:49:23,919
functional indexes right so if you use a

1524
00:49:22,160 --> 00:49:25,118
functional index or you create a new

1525
00:49:23,920 --> 00:49:27,440
functional index

1526
00:49:25,119 --> 00:49:28,640
you will need to run analyze to get

1527
00:49:27,440 --> 00:49:30,720
postgres to

1528
00:49:28,640 --> 00:49:31,920
basically run that function against the

1529
00:49:30,720 --> 00:49:34,720
values in the table

1530
00:49:31,920 --> 00:49:36,240
so that we can get statistics based on

1531
00:49:34,720 --> 00:49:37,439
what the results of the function were

1532
00:49:36,240 --> 00:49:38,399
instead of just based on the column

1533
00:49:37,440 --> 00:49:40,480
itself

1534
00:49:38,400 --> 00:49:41,680
but but just creating a regular index on

1535
00:49:40,480 --> 00:49:43,280
a regular column

1536
00:49:41,680 --> 00:49:44,399
we don't need we don't update stats

1537
00:49:43,280 --> 00:49:46,880
there's nothing to update in the stats

1538
00:49:44,400 --> 00:49:46,880
based on that

1539
00:49:50,079 --> 00:49:54,800
i don't think that's true we didn't we

1540
00:49:52,319 --> 00:49:56,960
have histograms on all of the columns

1541
00:49:54,800 --> 00:49:58,079
this is my recollection maybe i'm wrong

1542
00:49:56,960 --> 00:50:00,150
i'd be happy to go look at the source

1543
00:49:58,079 --> 00:50:04,400
code if you want to go take a peek later

1544
00:50:00,150 --> 00:50:05,200
[Laughter]

1545
00:50:04,400 --> 00:50:07,680
i don't know anything about other

1546
00:50:05,200 --> 00:50:10,240
proprietary databases i can't help there

1547
00:50:07,680 --> 00:50:10,720
all right well i think uh that is it for

1548
00:50:10,240 --> 00:50:12,799
me

1549
00:50:10,720 --> 00:50:25,359
um thank you all very much and i'm happy

1550
00:50:12,800 --> 00:50:25,359
to answer questions later

