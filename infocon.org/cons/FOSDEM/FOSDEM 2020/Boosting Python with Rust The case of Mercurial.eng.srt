1
00:00:05,200 --> 00:00:09,040
thank you for coming my name is rafael

2
00:00:06,799 --> 00:00:10,880
gomez i work at octobus

3
00:00:09,040 --> 00:00:12,160
we're a small consulting company

4
00:00:10,880 --> 00:00:15,599
specialized on

5
00:00:12,160 --> 00:00:18,160
mercurial and i'm going to

6
00:00:15,599 --> 00:00:21,039
talk about how we interface python and

7
00:00:18,160 --> 00:00:23,840
rus within mercurial to

8
00:00:21,039 --> 00:00:25,279
well you'll see why and um what are the

9
00:00:23,840 --> 00:00:29,519
challenges that we faced

10
00:00:25,279 --> 00:00:32,800
and how we fixed them how we didn't yet

11
00:00:29,519 --> 00:00:35,760
for some and yeah so

12
00:00:32,800 --> 00:00:37,919
for those of you who don't know

13
00:00:35,760 --> 00:00:41,839
mercurial is a version control system

14
00:00:37,920 --> 00:00:45,760
um in the same generation as git it was

15
00:00:41,840 --> 00:00:49,280
made in the same month of april 2005

16
00:00:45,760 --> 00:00:50,718
it's written mostly in python it has c

17
00:00:49,280 --> 00:00:54,160
extensions

18
00:00:50,719 --> 00:00:56,160
for performance reasons mostly

19
00:00:54,160 --> 00:00:58,398
it handles huge repositories for

20
00:00:56,160 --> 00:01:00,640
companies like facebook and mozilla

21
00:00:58,399 --> 00:01:02,559
with millions of files and revisions and

22
00:01:00,640 --> 00:01:03,280
it has a very powerful extension system

23
00:01:02,559 --> 00:01:05,039
that is

24
00:01:03,280 --> 00:01:06,320
super interesting and i have no time to

25
00:01:05,040 --> 00:01:09,119
talk about it today

26
00:01:06,320 --> 00:01:10,320
um so maybe check that out for yourself

27
00:01:09,119 --> 00:01:13,280
um

28
00:01:10,320 --> 00:01:15,039
so why did we choose rust i just said

29
00:01:13,280 --> 00:01:18,560
that we had

30
00:01:15,040 --> 00:01:22,479
like 40 000 lines of c code so why

31
00:01:18,560 --> 00:01:25,040
move to rust why use rust in general um

32
00:01:22,479 --> 00:01:26,640
so as a recap rust is a low level

33
00:01:25,040 --> 00:01:29,840
language

34
00:01:26,640 --> 00:01:31,680
with a very powerful type system it has

35
00:01:29,840 --> 00:01:33,040
no garbage collector which is

36
00:01:31,680 --> 00:01:34,720
quite important when you're trying to

37
00:01:33,040 --> 00:01:37,200
interface two languages

38
00:01:34,720 --> 00:01:39,039
if both have garbage collectors you run

39
00:01:37,200 --> 00:01:41,360
into some very tricky problems

40
00:01:39,040 --> 00:01:44,399
so that's nice it has a lot of

41
00:01:41,360 --> 00:01:46,159
compile-time memory safety

42
00:01:44,399 --> 00:01:47,439
some people might argue that it's too

43
00:01:46,159 --> 00:01:50,880
much or too little

44
00:01:47,439 --> 00:01:53,520
but it has more than than c does

45
00:01:50,880 --> 00:01:54,079
and it allows for simpler parallelism

46
00:01:53,520 --> 00:01:56,079
than

47
00:01:54,079 --> 00:01:59,039
if you were to write the same code in c

48
00:01:56,079 --> 00:01:59,039
or python for example

49
00:01:59,200 --> 00:02:02,760
so compared to c maintainability is a

50
00:02:01,280 --> 00:02:04,000
lot better

51
00:02:02,760 --> 00:02:05,680
[Music]

52
00:02:04,000 --> 00:02:07,439
it has a better signal to noise ratio

53
00:02:05,680 --> 00:02:10,080
that means that the

54
00:02:07,439 --> 00:02:12,000
more of the code that you write actually

55
00:02:10,080 --> 00:02:12,319
is the algorithm that you're trying to

56
00:02:12,000 --> 00:02:14,879
do

57
00:02:12,319 --> 00:02:15,760
and is has less to do with just freeing

58
00:02:14,879 --> 00:02:18,799
up memory and

59
00:02:15,760 --> 00:02:20,239
and getting segmentation faults um you

60
00:02:18,800 --> 00:02:20,560
have better compile-time guarantees

61
00:02:20,239 --> 00:02:23,599
which

62
00:02:20,560 --> 00:02:25,520
boils down to the same thing you have a

63
00:02:23,599 --> 00:02:27,359
standardized and modern tooling

64
00:02:25,520 --> 00:02:30,239
in the form of cargo and other

65
00:02:27,360 --> 00:02:33,680
formatting and a test suite

66
00:02:30,239 --> 00:02:35,360
for example and it's saved by default by

67
00:02:33,680 --> 00:02:37,920
some definition of safe

68
00:02:35,360 --> 00:02:39,519
with a few escape escape hatches which

69
00:02:37,920 --> 00:02:42,238
are very easy to

70
00:02:39,519 --> 00:02:44,640
grip like the unsafe blocks and a few

71
00:02:42,239 --> 00:02:48,000
others

72
00:02:44,640 --> 00:02:49,359
there are many reasons to choose rust

73
00:02:48,000 --> 00:02:50,560
but one of the main reasons is for

74
00:02:49,360 --> 00:02:54,160
performance

75
00:02:50,560 --> 00:02:54,879
um it's comparable to c for sequential

76
00:02:54,160 --> 00:02:57,760
code

77
00:02:54,879 --> 00:02:59,120
kind of uh parallel code is much simpler

78
00:02:57,760 --> 00:03:01,760
to write and to maintain

79
00:02:59,120 --> 00:03:02,159
so for us in a version control system

80
00:03:01,760 --> 00:03:05,760
it's

81
00:03:02,159 --> 00:03:08,239
a very good asset and it allows for

82
00:03:05,760 --> 00:03:10,159
optimizations impossible for c compilers

83
00:03:08,239 --> 00:03:12,000
i'm not saying that russ is faster than

84
00:03:10,159 --> 00:03:15,040
c as it is sometimes it is

85
00:03:12,000 --> 00:03:16,319
most of the time it's not but it's it's

86
00:03:15,040 --> 00:03:20,480
pretty cool

87
00:03:16,319 --> 00:03:23,440
so there was an experiment made by

88
00:03:20,480 --> 00:03:24,879
valentine who's a software developer at

89
00:03:23,440 --> 00:03:27,920
jane street

90
00:03:24,879 --> 00:03:31,359
and he did a very small subset of the

91
00:03:27,920 --> 00:03:32,958
ag status command that was written in

92
00:03:31,360 --> 00:03:35,680
pure rust

93
00:03:32,959 --> 00:03:36,879
on a big big repository that they have

94
00:03:35,680 --> 00:03:39,760
and um

95
00:03:36,879 --> 00:03:41,599
as you can see the performance is is

96
00:03:39,760 --> 00:03:44,640
quite a lot better than what we have

97
00:03:41,599 --> 00:03:47,679
in the in the python nc version um

98
00:03:44,640 --> 00:03:50,000
it's orders of magnitude better so

99
00:03:47,680 --> 00:03:50,720
that sparked a lot of interest uh in the

100
00:03:50,000 --> 00:03:53,920
mailing list

101
00:03:50,720 --> 00:03:55,920
and in the community in general and

102
00:03:53,920 --> 00:03:58,000
the plan to put rust inside mercurial

103
00:03:55,920 --> 00:04:00,559
was already kind of in the works but

104
00:03:58,000 --> 00:04:04,480
this kickstarted a lot more work

105
00:04:00,560 --> 00:04:07,680
um work that i was a part of

106
00:04:04,480 --> 00:04:11,679
but just before i joined mercurial

107
00:04:07,680 --> 00:04:14,239
project choose to to use rusty python

108
00:04:11,680 --> 00:04:15,120
because there are many ways of bridging

109
00:04:14,239 --> 00:04:17,120
python

110
00:04:15,120 --> 00:04:18,239
and rust and rusty python is the one

111
00:04:17,120 --> 00:04:20,160
that they chose for

112
00:04:18,238 --> 00:04:21,358
many reasons i really don't want to get

113
00:04:20,160 --> 00:04:23,759
into them

114
00:04:21,358 --> 00:04:25,359
it compiles on rust stable so there you

115
00:04:23,759 --> 00:04:27,680
go

116
00:04:25,360 --> 00:04:29,360
it's composed of two packages you could

117
00:04:27,680 --> 00:04:32,080
say crates in in the rusty

118
00:04:29,360 --> 00:04:32,400
ecosystem it has a low level crate for

119
00:04:32,080 --> 00:04:35,440
uh

120
00:04:32,400 --> 00:04:38,479
binding to the sea python abi uh

121
00:04:35,440 --> 00:04:40,800
so basically you never you would never

122
00:04:38,479 --> 00:04:41,599
interact with that and a high level

123
00:04:40,800 --> 00:04:44,400
crate

124
00:04:41,600 --> 00:04:45,199
to interact with python so to expose a

125
00:04:44,400 --> 00:04:47,359
module

126
00:04:45,199 --> 00:04:48,400
that looks like a python module to to

127
00:04:47,360 --> 00:04:50,479
python create

128
00:04:48,400 --> 00:04:52,560
functions classes and execute python

129
00:04:50,479 --> 00:04:55,599
from rust which means that you get

130
00:04:52,560 --> 00:04:56,160
like an eval function you could just put

131
00:04:55,600 --> 00:04:58,000
python

132
00:04:56,160 --> 00:05:00,479
within rust and just execute within a

133
00:04:58,000 --> 00:05:00,479
context

134
00:05:00,720 --> 00:05:04,160
so we have the following structure

135
00:05:02,000 --> 00:05:06,560
within material um

136
00:05:04,160 --> 00:05:09,520
i'm only talking about c python now so

137
00:05:06,560 --> 00:05:12,560
for people using pi pi i'm sorry but

138
00:05:09,520 --> 00:05:14,799
we're so the pure python code of course

139
00:05:12,560 --> 00:05:16,400
talks to its backend see python the c

140
00:05:14,800 --> 00:05:19,680
extensions do the same thing

141
00:05:16,400 --> 00:05:22,799
and rust is split in two crates um

142
00:05:19,680 --> 00:05:26,720
the first one being hg core

143
00:05:22,800 --> 00:05:29,039
which is a standalone library that has

144
00:05:26,720 --> 00:05:30,479
no idea whatsoever that it's talking to

145
00:05:29,039 --> 00:05:33,919
python

146
00:05:30,479 --> 00:05:36,159
and uh hdc python which is

147
00:05:33,919 --> 00:05:37,919
one of the crates that can glue hd core

148
00:05:36,160 --> 00:05:39,680
to a python executor

149
00:05:37,919 --> 00:05:42,320
it's the main one that we're working on

150
00:05:39,680 --> 00:05:46,160
because see python is so common

151
00:05:42,320 --> 00:05:47,840
and yeah that's that's the structure

152
00:05:46,160 --> 00:05:49,520
so i was very excited to start working

153
00:05:47,840 --> 00:05:52,320
on rust at first

154
00:05:49,520 --> 00:05:52,960
and um and it was not it was not super

155
00:05:52,320 --> 00:05:55,280
fun

156
00:05:52,960 --> 00:05:56,880
um for many reasons the first

157
00:05:55,280 --> 00:05:59,359
non-trivial thing that i

158
00:05:56,880 --> 00:06:00,240
started writing was about twice as slow

159
00:05:59,360 --> 00:06:02,639
as the reference

160
00:06:00,240 --> 00:06:03,360
implementation so that was not super

161
00:06:02,639 --> 00:06:06,400
cool

162
00:06:03,360 --> 00:06:08,400
um and the reason why is is because of

163
00:06:06,400 --> 00:06:10,560
friction when you're trying to

164
00:06:08,400 --> 00:06:11,840
piece two languages together no matter

165
00:06:10,560 --> 00:06:15,199
the languages

166
00:06:11,840 --> 00:06:18,318
except if it's like c and rust um

167
00:06:15,199 --> 00:06:20,720
you basically always have issues with

168
00:06:18,319 --> 00:06:21,360
at two levels you have the developer

169
00:06:20,720 --> 00:06:23,199
level

170
00:06:21,360 --> 00:06:24,479
so with the complex interface code that

171
00:06:23,199 --> 00:06:25,919
you have to write that is basically

172
00:06:24,479 --> 00:06:27,359
completely orthogonal to what you're

173
00:06:25,919 --> 00:06:29,520
trying to solve you're trying to

174
00:06:27,360 --> 00:06:31,199
do a problem and then you have to take

175
00:06:29,520 --> 00:06:34,000
your data structures and move it

176
00:06:31,199 --> 00:06:35,520
to and from the other language which you

177
00:06:34,000 --> 00:06:36,960
really don't want to have to think about

178
00:06:35,520 --> 00:06:40,159
but you really do

179
00:06:36,960 --> 00:06:43,198
and exchanging data in general is costly

180
00:06:40,160 --> 00:06:46,720
because you have uh

181
00:06:43,199 --> 00:06:48,960
at most at the very least you're moving

182
00:06:46,720 --> 00:06:50,240
memory around at worst you're allocating

183
00:06:48,960 --> 00:06:52,159
a lot of it which

184
00:06:50,240 --> 00:06:54,240
is very expensive and then you have to

185
00:06:52,160 --> 00:06:57,280
loop over all your data

186
00:06:54,240 --> 00:06:58,400
so for example if i am stating a hundred

187
00:06:57,280 --> 00:07:01,039
thousand files

188
00:06:58,400 --> 00:07:03,120
on my laptop with hot kernel caches in

189
00:07:01,039 --> 00:07:05,759
parallel and rust it takes about

190
00:07:03,120 --> 00:07:07,440
30 milliseconds which is pretty cool and

191
00:07:05,759 --> 00:07:08,960
if i give the results back to python it

192
00:07:07,440 --> 00:07:11,039
takes about 300 milliseconds for

193
00:07:08,960 --> 00:07:13,840
anything useful so you just

194
00:07:11,039 --> 00:07:15,520
add up one order of magnitude more than

195
00:07:13,840 --> 00:07:16,000
on top of what you're actually trying to

196
00:07:15,520 --> 00:07:18,318
do

197
00:07:16,000 --> 00:07:20,319
negating the entire point of doing it in

198
00:07:18,319 --> 00:07:23,360
rust

199
00:07:20,319 --> 00:07:25,280
so we have a few possible solutions um

200
00:07:23,360 --> 00:07:27,199
you can just exchange less data so you

201
00:07:25,280 --> 00:07:30,479
move up one abstraction layer and

202
00:07:27,199 --> 00:07:32,479
and you you for example

203
00:07:30,479 --> 00:07:34,080
instead of giving the bytes of a file

204
00:07:32,479 --> 00:07:35,840
you give the file name and

205
00:07:34,080 --> 00:07:37,520
and make rust open the file that kind of

206
00:07:35,840 --> 00:07:38,880
stuff uh which is

207
00:07:37,520 --> 00:07:41,440
pretty much the same as doing more in

208
00:07:38,880 --> 00:07:43,440
rust and you can also communicate with c

209
00:07:41,440 --> 00:07:45,120
directly and not go through the python

210
00:07:43,440 --> 00:07:48,000
layer

211
00:07:45,120 --> 00:07:50,000
so if you go back to the structure that

212
00:07:48,000 --> 00:07:53,840
we had

213
00:07:50,000 --> 00:07:56,879
there's this arrow that we're trying to

214
00:07:53,840 --> 00:07:58,400
to use and it turns out that in the in

215
00:07:56,879 --> 00:08:01,440
the python standard library

216
00:07:58,400 --> 00:08:05,039
we have something called capsules um

217
00:08:01,440 --> 00:08:07,599
which are python objects that

218
00:08:05,039 --> 00:08:08,400
encapsulates that's a typo uh function

219
00:08:07,599 --> 00:08:12,000
pointers

220
00:08:08,400 --> 00:08:15,359
um so their main purpose is to allow

221
00:08:12,000 --> 00:08:18,160
for a shared c api between

222
00:08:15,360 --> 00:08:19,520
extension modules so that's that's what

223
00:08:18,160 --> 00:08:22,560
we're trying to do because rust

224
00:08:19,520 --> 00:08:24,799
targets the c api api

225
00:08:22,560 --> 00:08:26,080
um you can open your favorite python

226
00:08:24,800 --> 00:08:27,919
interpreter and

227
00:08:26,080 --> 00:08:29,680
look into the daytime module and see a

228
00:08:27,919 --> 00:08:32,879
capsule object so then

229
00:08:29,680 --> 00:08:32,879
there you go that's in python

230
00:08:33,039 --> 00:08:36,958
but moving up abstraction layers you

231
00:08:36,399 --> 00:08:38,719
need

232
00:08:36,958 --> 00:08:40,000
more powerful obstructions and there

233
00:08:38,719 --> 00:08:42,320
were some missing features

234
00:08:40,000 --> 00:08:44,159
in our abstraction layer which was uh

235
00:08:42,320 --> 00:08:46,399
which is rusty python

236
00:08:44,159 --> 00:08:47,519
uh for example there was no way of

237
00:08:46,399 --> 00:08:50,080
dealing and

238
00:08:47,519 --> 00:08:51,120
dealing with and creating sets um so

239
00:08:50,080 --> 00:08:54,160
python sets was

240
00:08:51,120 --> 00:08:58,640
a very useful collection to to use

241
00:08:54,160 --> 00:09:01,519
um there was no support for capsules

242
00:08:58,640 --> 00:09:03,120
so we kind of had to do that also there

243
00:09:01,519 --> 00:09:05,760
is

244
00:09:03,120 --> 00:09:07,519
then more hairy stuff inheritance for

245
00:09:05,760 --> 00:09:10,160
classes written in rust

246
00:09:07,519 --> 00:09:11,120
so what that means is if you write if

247
00:09:10,160 --> 00:09:14,640
you create a class

248
00:09:11,120 --> 00:09:16,480
a python class from rust so it has a

249
00:09:14,640 --> 00:09:18,240
rust back end if you will

250
00:09:16,480 --> 00:09:20,160
and you try to inherit from that in

251
00:09:18,240 --> 00:09:22,800
python code it will

252
00:09:20,160 --> 00:09:24,160
completely just crash uh at an

253
00:09:22,800 --> 00:09:25,680
interpreter time

254
00:09:24,160 --> 00:09:28,640
uh telling you that it's not a valid

255
00:09:25,680 --> 00:09:31,839
base type and it has to do with

256
00:09:28,640 --> 00:09:33,680
um the fact that if you try to

257
00:09:31,839 --> 00:09:35,920
inherit from this class and you forget

258
00:09:33,680 --> 00:09:36,880
to call in it then what happens to to

259
00:09:35,920 --> 00:09:39,120
the memory

260
00:09:36,880 --> 00:09:40,720
rust needs its memory to be initialized

261
00:09:39,120 --> 00:09:42,640
it doesn't just work like that so you

262
00:09:40,720 --> 00:09:46,800
can't really extend

263
00:09:42,640 --> 00:09:49,199
a rust backed python type so you have to

264
00:09:46,800 --> 00:09:50,800
use composition over inheritance

265
00:09:49,200 --> 00:09:53,120
which makes some people happy but it

266
00:09:50,800 --> 00:09:54,800
makes the performance really unhappy

267
00:09:53,120 --> 00:09:57,279
and it makes me unhappy because i have

268
00:09:54,800 --> 00:10:00,240
to do all of this manual

269
00:09:57,279 --> 00:10:01,680
encapsulation which is slow and

270
00:10:00,240 --> 00:10:05,279
cumbersome

271
00:10:01,680 --> 00:10:07,199
um properties don't have properties yet

272
00:10:05,279 --> 00:10:10,079
in rusty python

273
00:10:07,200 --> 00:10:10,800
um they're very useful and if you're

274
00:10:10,079 --> 00:10:13,279
trying and

275
00:10:10,800 --> 00:10:14,719
to to build a drop-in replacement of a

276
00:10:13,279 --> 00:10:15,439
class that you've written in python and

277
00:10:14,720 --> 00:10:17,200
just trying to

278
00:10:15,440 --> 00:10:18,880
you know rewrite it in rust and expose

279
00:10:17,200 --> 00:10:21,839
the same interface

280
00:10:18,880 --> 00:10:23,360
you have to or again do the same

281
00:10:21,839 --> 00:10:25,120
encapsulation mechanism to have

282
00:10:23,360 --> 00:10:25,839
properties that call your inner methods

283
00:10:25,120 --> 00:10:29,680
in rust and

284
00:10:25,839 --> 00:10:33,040
blah blah blah set adder

285
00:10:29,680 --> 00:10:34,239
is not in rusty python which means that

286
00:10:33,040 --> 00:10:37,279
you cannot have

287
00:10:34,240 --> 00:10:40,399
instance attributes which which

288
00:10:37,279 --> 00:10:43,839
is very limiting and the last one

289
00:10:40,399 --> 00:10:46,160
but not least is when you're trying to

290
00:10:43,839 --> 00:10:47,600
build an iterator on rust collections

291
00:10:46,160 --> 00:10:48,719
so i'm going to talk about this one a

292
00:10:47,600 --> 00:10:49,760
little bit more because it's more

293
00:10:48,720 --> 00:10:52,800
interesting and we've

294
00:10:49,760 --> 00:10:52,800
found a solution for it

295
00:10:54,079 --> 00:11:00,160
the main idea is that you want to have

296
00:10:57,519 --> 00:11:02,160
a rust collection let's say a vector or

297
00:11:00,160 --> 00:11:05,760
anything that you can iterate on

298
00:11:02,160 --> 00:11:07,760
and you want to pass one value at a time

299
00:11:05,760 --> 00:11:10,079
when it's being iterated instead

300
00:11:07,760 --> 00:11:10,800
of just taking the whole collection

301
00:11:10,079 --> 00:11:12,719
moving

302
00:11:10,800 --> 00:11:14,000
moving it through the ffr layer having

303
00:11:12,720 --> 00:11:15,440
two copies of the same stuff

304
00:11:14,000 --> 00:11:18,399
and trying to synchronize it and it's

305
00:11:15,440 --> 00:11:19,120
just there so you you want it to behave

306
00:11:18,399 --> 00:11:22,720
exactly as

307
00:11:19,120 --> 00:11:24,320
a python iterator would but to do that

308
00:11:22,720 --> 00:11:25,920
you have to tell the rust compiler that

309
00:11:24,320 --> 00:11:27,600
it really has to let go to the

310
00:11:25,920 --> 00:11:28,959
of the memory that it's trying to hold

311
00:11:27,600 --> 00:11:30,880
on to

312
00:11:28,959 --> 00:11:33,040
and it basically revolves around sharing

313
00:11:30,880 --> 00:11:34,160
the references to the same object

314
00:11:33,040 --> 00:11:37,599
between

315
00:11:34,160 --> 00:11:39,839
the two languages um

316
00:11:37,600 --> 00:11:39,839
so

317
00:11:41,040 --> 00:11:44,480
these are not my slides all right that's

318
00:11:42,720 --> 00:11:45,519
okay um there's supposed to be a slide

319
00:11:44,480 --> 00:11:47,760
here talking about

320
00:11:45,519 --> 00:11:48,560
the the work that that we've done but

321
00:11:47,760 --> 00:11:51,920
basically

322
00:11:48,560 --> 00:11:55,040
my uh my colleague did um

323
00:11:51,920 --> 00:11:55,599
uh a proof of concept in early june last

324
00:11:55,040 --> 00:11:58,480
year

325
00:11:55,600 --> 00:12:00,480
and then i upstreamed the first i would

326
00:11:58,480 --> 00:12:01,200
say non-trivial data structure version

327
00:12:00,480 --> 00:12:03,360
of it

328
00:12:01,200 --> 00:12:05,760
in mercurial about a month later and

329
00:12:03,360 --> 00:12:08,399
it's been upstreamed

330
00:12:05,760 --> 00:12:09,519
this week yeah this week in rusty python

331
00:12:08,399 --> 00:12:11,920
so that's pretty cool

332
00:12:09,519 --> 00:12:13,120
um so upstream work that's not up to

333
00:12:11,920 --> 00:12:15,920
date

334
00:12:13,120 --> 00:12:16,720
because pi set has been done by my same

335
00:12:15,920 --> 00:12:19,760
colleague

336
00:12:16,720 --> 00:12:20,720
thank you george pi capsule same stuff

337
00:12:19,760 --> 00:12:23,200
you have a useful

338
00:12:20,720 --> 00:12:24,880
macro to define capsules um properties

339
00:12:23,200 --> 00:12:27,519
are being worked on i believe

340
00:12:24,880 --> 00:12:28,560
by i don't remember who but someone is

341
00:12:27,519 --> 00:12:30,800
working on them

342
00:12:28,560 --> 00:12:33,839
and iterators and rust collections uh

343
00:12:30,800 --> 00:12:33,839
are also a thing

344
00:12:34,000 --> 00:12:41,600
so um this is our target this is

345
00:12:38,800 --> 00:12:43,199
basically the the the lower bound of

346
00:12:41,600 --> 00:12:43,920
what we're trying to achieve because we

347
00:12:43,200 --> 00:12:46,560
know that this

348
00:12:43,920 --> 00:12:48,079
is unrealistic it does not do everything

349
00:12:46,560 --> 00:12:50,800
that status does

350
00:12:48,079 --> 00:12:52,479
and it's very um focused on doing one

351
00:12:50,800 --> 00:12:54,639
thing exactly and it's still very tested

352
00:12:52,480 --> 00:12:56,240
etc but it's a lot faster and we know

353
00:12:54,639 --> 00:12:57,760
that we can do

354
00:12:56,240 --> 00:13:00,800
a lot better than what we are actually

355
00:12:57,760 --> 00:13:04,480
doing currently

356
00:13:00,800 --> 00:13:06,800
so where are we now um

357
00:13:04,480 --> 00:13:08,800
i'm i have two cases the first one being

358
00:13:06,800 --> 00:13:09,760
uh pathological cases in our favor

359
00:13:08,800 --> 00:13:13,279
something that

360
00:13:09,760 --> 00:13:15,680
favors the newer code um

361
00:13:13,279 --> 00:13:17,200
as you can see we the the new code using

362
00:13:15,680 --> 00:13:20,239
rust is faster

363
00:13:17,200 --> 00:13:23,600
by a good margin which is

364
00:13:20,240 --> 00:13:24,399
nice definitely but for a more realistic

365
00:13:23,600 --> 00:13:27,120
case

366
00:13:24,399 --> 00:13:27,839
we see about 50 improvement in

367
00:13:27,120 --> 00:13:30,320
performance

368
00:13:27,839 --> 00:13:31,040
which again it's very nice it's cool it

369
00:13:30,320 --> 00:13:32,880
compounds

370
00:13:31,040 --> 00:13:34,480
nicely if you have like a ci system or

371
00:13:32,880 --> 00:13:37,920
something but it's

372
00:13:34,480 --> 00:13:40,000
very far

373
00:13:37,920 --> 00:13:42,639
from the from the thing that we're

374
00:13:40,000 --> 00:13:45,199
trying to to achieve

375
00:13:42,639 --> 00:13:46,399
so there's a lot more stuff that we can

376
00:13:45,199 --> 00:13:50,240
do to

377
00:13:46,399 --> 00:13:53,040
to make this go faster um

378
00:13:50,240 --> 00:13:54,560
i talked about how rust makes writing

379
00:13:53,040 --> 00:13:57,439
parallel code

380
00:13:54,560 --> 00:13:59,518
a lot better um and a lot easier we

381
00:13:57,440 --> 00:14:02,639
could do more things in parallel

382
00:13:59,519 --> 00:14:04,320
um there are basically three main loops

383
00:14:02,639 --> 00:14:06,399
within status and

384
00:14:04,320 --> 00:14:08,079
i think only one of them is is run in

385
00:14:06,399 --> 00:14:09,920
parallel as of now and it's really the

386
00:14:08,079 --> 00:14:11,279
simpler one and it's not really the most

387
00:14:09,920 --> 00:14:13,599
expensive one

388
00:14:11,279 --> 00:14:14,959
so just running those things in parallel

389
00:14:13,600 --> 00:14:16,480
so say if you have a hundred thousand

390
00:14:14,959 --> 00:14:17,920
files you don't want to

391
00:14:16,480 --> 00:14:19,680
check the first file do all the thing

392
00:14:17,920 --> 00:14:21,360
then second one etc

393
00:14:19,680 --> 00:14:23,439
it's very easy to parallelize most of

394
00:14:21,360 --> 00:14:26,240
the stuff

395
00:14:23,440 --> 00:14:28,399
especially now that most computers have

396
00:14:26,240 --> 00:14:31,680
a lot of cpus

397
00:14:28,399 --> 00:14:34,160
it actually gets a lot faster

398
00:14:31,680 --> 00:14:35,920
um better conditional execution that has

399
00:14:34,160 --> 00:14:37,519
to do with the fact that mercurial is a

400
00:14:35,920 --> 00:14:40,079
15 year old code base with

401
00:14:37,519 --> 00:14:41,199
with a lot of features and a lot of bug

402
00:14:40,079 --> 00:14:42,959
reports that have

403
00:14:41,199 --> 00:14:44,719
you know added little lines here and

404
00:14:42,959 --> 00:14:46,560
there then you don't want to break the

405
00:14:44,720 --> 00:14:46,959
backwards compatibility that you've had

406
00:14:46,560 --> 00:14:49,439
for

407
00:14:46,959 --> 00:14:50,479
15 years with the huge test suite that

408
00:14:49,440 --> 00:14:54,320
we have

409
00:14:50,480 --> 00:14:55,440
um so you want to work incrementally

410
00:14:54,320 --> 00:14:58,880
when you're trying to

411
00:14:55,440 --> 00:15:01,519
put rust inside of python code and and

412
00:14:58,880 --> 00:15:02,399
one of the things that i've done um

413
00:15:01,519 --> 00:15:06,560
because

414
00:15:02,399 --> 00:15:09,760
i have mostly been working on on status

415
00:15:06,560 --> 00:15:11,439
is doing the naive thing just figuring

416
00:15:09,760 --> 00:15:12,000
out if it's any faster if it's any

417
00:15:11,440 --> 00:15:14,560
faster it's

418
00:15:12,000 --> 00:15:15,760
good enough and then work in a different

419
00:15:14,560 --> 00:15:19,119
iteration to

420
00:15:15,760 --> 00:15:21,920
get it to go faster again um

421
00:15:19,120 --> 00:15:23,839
so you can you can maybe think about the

422
00:15:21,920 --> 00:15:27,199
things that are not useful to do

423
00:15:23,839 --> 00:15:29,279
in any given situation maybe there

424
00:15:27,199 --> 00:15:31,199
we can optimize some paths and maybe

425
00:15:29,279 --> 00:15:35,839
some not we can see

426
00:15:31,199 --> 00:15:37,680
um we can rethink the order of execution

427
00:15:35,839 --> 00:15:39,279
that's something that rust allows us to

428
00:15:37,680 --> 00:15:41,279
do because it has

429
00:15:39,279 --> 00:15:42,639
such a strong type system that some

430
00:15:41,279 --> 00:15:44,320
invariants so some

431
00:15:42,639 --> 00:15:47,360
constraints of the problem we're trying

432
00:15:44,320 --> 00:15:50,639
to solve can be more easily

433
00:15:47,360 --> 00:15:54,240
fixable and and reasoned about than if

434
00:15:50,639 --> 00:15:57,040
we were trying to use python um

435
00:15:54,240 --> 00:15:58,480
for the very more complicated parallel

436
00:15:57,040 --> 00:15:59,040
stuff maybe we could do two loops at the

437
00:15:58,480 --> 00:16:02,959
same time

438
00:15:59,040 --> 00:16:05,199
and do the uh um do two things that

439
00:16:02,959 --> 00:16:07,040
weren't possible before because it was

440
00:16:05,199 --> 00:16:10,560
just too much to think about

441
00:16:07,040 --> 00:16:11,680
um doing of course fewer exchanges

442
00:16:10,560 --> 00:16:13,920
between python and rust

443
00:16:11,680 --> 00:16:14,959
that's that's pretty obvious if you're

444
00:16:13,920 --> 00:16:16,880
if you're moving

445
00:16:14,959 --> 00:16:19,439
fewer things and defining better

446
00:16:16,880 --> 00:16:22,480
interfaces um between python and rust

447
00:16:19,440 --> 00:16:24,399
maybe you you have less overhead

448
00:16:22,480 --> 00:16:26,240
for the foreign function interface that

449
00:16:24,399 --> 00:16:29,040
you're trying to define and it has a

450
00:16:26,240 --> 00:16:29,440
better approach for maintainability of

451
00:16:29,040 --> 00:16:33,519
your

452
00:16:29,440 --> 00:16:35,920
in your project it has a cost

453
00:16:33,519 --> 00:16:37,040
of defining strong interfaces that way

454
00:16:35,920 --> 00:16:39,360
python can do its

455
00:16:37,040 --> 00:16:40,240
job is good very good job of using

456
00:16:39,360 --> 00:16:43,440
extensions

457
00:16:40,240 --> 00:16:45,120
and and and being the the

458
00:16:43,440 --> 00:16:46,480
very productive language that we know

459
00:16:45,120 --> 00:16:48,079
and rust can have

460
00:16:46,480 --> 00:16:50,639
its own job of being the very fast

461
00:16:48,079 --> 00:16:52,319
language that we know

462
00:16:50,639 --> 00:16:54,880
of course the usual suspects of

463
00:16:52,320 --> 00:16:58,480
optimization so

464
00:16:54,880 --> 00:17:00,240
you basically allocate less in general

465
00:16:58,480 --> 00:17:01,839
make fewer allocations even if you have

466
00:17:00,240 --> 00:17:04,959
to allocate the same amount of memory

467
00:17:01,839 --> 00:17:06,079
you know using memory alignments all

468
00:17:04,959 --> 00:17:08,240
that kind of stuff

469
00:17:06,079 --> 00:17:10,159
and something maybe a bit more

470
00:17:08,240 --> 00:17:12,160
controversial in this room uh not start

471
00:17:10,160 --> 00:17:16,000
python at all

472
00:17:12,160 --> 00:17:19,199
so um

473
00:17:16,000 --> 00:17:23,359
yeah i'll get to the next slide um but

474
00:17:19,199 --> 00:17:26,559
python has a startup time that that is

475
00:17:23,359 --> 00:17:29,678
um that can take tens

476
00:17:26,559 --> 00:17:32,639
even a hundred milliseconds sometimes

477
00:17:29,679 --> 00:17:34,160
and if you remember the slider i showed

478
00:17:32,640 --> 00:17:34,799
you that's about the time that it takes

479
00:17:34,160 --> 00:17:36,240
you to

480
00:17:34,799 --> 00:17:39,120
you know to run status on a hundred

481
00:17:36,240 --> 00:17:43,280
thousand files um

482
00:17:39,120 --> 00:17:45,360
so maybe we can completely

483
00:17:43,280 --> 00:17:46,720
bypass python in some cases because

484
00:17:45,360 --> 00:17:48,959
python has

485
00:17:46,720 --> 00:17:50,720
a very good place inside maker and it

486
00:17:48,960 --> 00:17:53,679
made mercurial what it is

487
00:17:50,720 --> 00:17:56,160
now um with its extendability and meta

488
00:17:53,679 --> 00:17:58,880
programming capabilities

489
00:17:56,160 --> 00:17:59,440
but if you're trying to run a ci for

490
00:17:58,880 --> 00:18:02,799
example

491
00:17:59,440 --> 00:18:04,000
and you you're always asking for the

492
00:18:02,799 --> 00:18:06,320
status and the log

493
00:18:04,000 --> 00:18:07,360
and the the diff and whatever and this

494
00:18:06,320 --> 00:18:09,200
is not very

495
00:18:07,360 --> 00:18:11,439
you don't really need customizability

496
00:18:09,200 --> 00:18:13,600
you need something that is very

497
00:18:11,440 --> 00:18:15,600
fast and as fast as possible and the

498
00:18:13,600 --> 00:18:16,719
starter cost of python actually costs a

499
00:18:15,600 --> 00:18:19,600
lot

500
00:18:16,720 --> 00:18:20,000
just running python at all so maybe for

501
00:18:19,600 --> 00:18:22,000
some

502
00:18:20,000 --> 00:18:24,400
aspects we can completely counter it i

503
00:18:22,000 --> 00:18:26,480
don't have time in this

504
00:18:24,400 --> 00:18:28,000
uh in this talk to talk about that but

505
00:18:26,480 --> 00:18:31,919
maybe we can discuss

506
00:18:28,000 --> 00:18:34,240
it later working so much with rust has

507
00:18:31,919 --> 00:18:35,520
given me a renewed appreciation for

508
00:18:34,240 --> 00:18:38,480
python

509
00:18:35,520 --> 00:18:38,960
um code is very easy to understand if

510
00:18:38,480 --> 00:18:40,799
even

511
00:18:38,960 --> 00:18:42,640
even with a very weird python that we

512
00:18:40,799 --> 00:18:44,960
have to write in mercurial because we're

513
00:18:42,640 --> 00:18:46,080
really at the edge of of performance in

514
00:18:44,960 --> 00:18:49,120
python

515
00:18:46,080 --> 00:18:50,960
um it's basically writing pseudo code

516
00:18:49,120 --> 00:18:53,760
most of the time and it's it's

517
00:18:50,960 --> 00:18:54,960
such an achievement in in programming

518
00:18:53,760 --> 00:18:58,000
language theory to just

519
00:18:54,960 --> 00:19:00,559
have a language that most people can

520
00:18:58,000 --> 00:19:01,840
read without having to to you know

521
00:19:00,559 --> 00:19:03,280
bother themselves with

522
00:19:01,840 --> 00:19:05,600
a lot of details that they don't care

523
00:19:03,280 --> 00:19:06,240
about you get something that works very

524
00:19:05,600 --> 00:19:08,399
quickly

525
00:19:06,240 --> 00:19:09,760
there are some extensions in mercurial i

526
00:19:08,400 --> 00:19:10,880
said i wouldn't talk about them but not

527
00:19:09,760 --> 00:19:12,240
just a little bit um

528
00:19:10,880 --> 00:19:14,080
there are some extensions in mercurial

529
00:19:12,240 --> 00:19:17,200
that are about 100

530
00:19:14,080 --> 00:19:20,240
100 lines 150 lines that do

531
00:19:17,200 --> 00:19:22,240
a lot of work and that it doesn't do it

532
00:19:20,240 --> 00:19:24,240
super fast at first but it does it at

533
00:19:22,240 --> 00:19:25,280
all and it's it's

534
00:19:24,240 --> 00:19:27,520
so great so it allows for

535
00:19:25,280 --> 00:19:29,600
experimentation you can you can

536
00:19:27,520 --> 00:19:30,720
figure out your interfaces later you can

537
00:19:29,600 --> 00:19:34,080
just you know

538
00:19:30,720 --> 00:19:36,000
it's very rare to break your entire

539
00:19:34,080 --> 00:19:37,760
project by just changing something

540
00:19:36,000 --> 00:19:39,679
somewhere in python usually

541
00:19:37,760 --> 00:19:41,120
you can get away with it whether that's

542
00:19:39,679 --> 00:19:43,280
a good thing or a bad thing

543
00:19:41,120 --> 00:19:44,879
is up to you but uh it allows for

544
00:19:43,280 --> 00:19:47,039
experimentation

545
00:19:44,880 --> 00:19:48,400
and it is a lot faster faster than rust

546
00:19:47,039 --> 00:19:50,160
code that you are not done writing

547
00:19:48,400 --> 00:19:52,720
because you have

548
00:19:50,160 --> 00:19:54,080
the 15th error message that tells you

549
00:19:52,720 --> 00:19:57,280
the same thing

550
00:19:54,080 --> 00:19:59,620
all right um so thank you do you have

551
00:19:57,280 --> 00:20:02,720
any questions

552
00:19:59,620 --> 00:20:02,719
[Music]

553
00:20:04,880 --> 00:20:07,840
do we have time for questions

554
00:20:07,919 --> 00:20:12,400
do we have time for questions sorry oh

555
00:20:10,080 --> 00:20:12,399
sorry

556
00:20:12,559 --> 00:20:17,520
hi thanks for the talk uh i have two

557
00:20:15,280 --> 00:20:21,200
questions when is related to starting c

558
00:20:17,520 --> 00:20:23,840
python um i wondered is

559
00:20:21,200 --> 00:20:24,320
the code integration really worth it or

560
00:20:23,840 --> 00:20:27,600
would it

561
00:20:24,320 --> 00:20:30,399
be better to just have rest only

562
00:20:27,600 --> 00:20:32,480
comments and python only comments and

563
00:20:30,400 --> 00:20:32,960
just start one or the other depending on

564
00:20:32,480 --> 00:20:36,080
the

565
00:20:32,960 --> 00:20:36,799
mercurial comments so if i understand

566
00:20:36,080 --> 00:20:39,918
correctly the

567
00:20:36,799 --> 00:20:41,918
the question is uh do uh is the

568
00:20:39,919 --> 00:20:43,600
the interfacing of the two languages

569
00:20:41,919 --> 00:20:45,600
worth it or should we just

570
00:20:43,600 --> 00:20:49,039
bother with rust or python depending on

571
00:20:45,600 --> 00:20:50,480
the use case um i would be very happy if

572
00:20:49,039 --> 00:20:52,879
i didn't have to do any

573
00:20:50,480 --> 00:20:55,200
foreign function interface work um but

574
00:20:52,880 --> 00:20:56,720
it's the best case you have because

575
00:20:55,200 --> 00:20:58,640
having a complete rewrite of your

576
00:20:56,720 --> 00:21:00,159
software is usually very not a good idea

577
00:20:58,640 --> 00:21:03,440
at all so you want to

578
00:21:00,159 --> 00:21:04,000
to work incrementally and that starts

579
00:21:03,440 --> 00:21:05,760
with just

580
00:21:04,000 --> 00:21:07,280
you know taking a small bit of your code

581
00:21:05,760 --> 00:21:10,320
and putting it in

582
00:21:07,280 --> 00:21:10,879
in rust and and as i said both languages

583
00:21:10,320 --> 00:21:12,639
have

584
00:21:10,880 --> 00:21:13,919
a lot of advantages and you don't want

585
00:21:12,640 --> 00:21:17,280
to give one

586
00:21:13,919 --> 00:21:20,880
up i would say so i think i'd say

587
00:21:17,280 --> 00:21:24,080
it's worth it we still have time for

588
00:21:20,880 --> 00:21:24,080
a couple of questions yes

589
00:21:26,000 --> 00:21:28,960
how do you test

590
00:21:29,440 --> 00:21:33,760
okay uh how do you test and newer code

591
00:21:32,720 --> 00:21:36,880
doesn't break

592
00:21:33,760 --> 00:21:39,600
uh previews oh

593
00:21:36,880 --> 00:21:40,000
so so how do we test that the new code

594
00:21:39,600 --> 00:21:43,360
um

595
00:21:40,000 --> 00:21:47,039
behaves the same way new tests for rust

596
00:21:43,360 --> 00:21:48,879
oh yeah um how do i write tests for rust

597
00:21:47,039 --> 00:21:50,480
yeah and make sure it doesn't break

598
00:21:48,880 --> 00:21:53,039
anything yes uh we have

599
00:21:50,480 --> 00:21:53,919
um most of our test suites is

600
00:21:53,039 --> 00:21:57,760
integration

601
00:21:53,919 --> 00:22:00,400
tests so they talk to people please

602
00:21:57,760 --> 00:22:01,600
to the uh they talk to the command line

603
00:22:00,400 --> 00:22:03,520
and we see

604
00:22:01,600 --> 00:22:05,280
the the side effects of what happens so

605
00:22:03,520 --> 00:22:05,600
most of the test suite has no idea of

606
00:22:05,280 --> 00:22:07,840
what

607
00:22:05,600 --> 00:22:10,000
the the implementation is whether that's

608
00:22:07,840 --> 00:22:12,399
a good thing or a bad thing is sometimes

609
00:22:10,000 --> 00:22:14,559
you know kind of tricky but it allows us

610
00:22:12,400 --> 00:22:15,919
to change the implementation and just

611
00:22:14,559 --> 00:22:18,639
see if it broke anything

612
00:22:15,919 --> 00:22:19,840
we also have rust specific tests for you

613
00:22:18,640 --> 00:22:21,600
know smaller functions

614
00:22:19,840 --> 00:22:24,799
but most of the test suite has no idea

615
00:22:21,600 --> 00:22:24,799
of what's going on in mercurial

616
00:22:24,840 --> 00:22:27,840
yep

617
00:22:31,840 --> 00:22:34,879
actually related to the first question

618
00:22:33,520 --> 00:22:37,360
to avoid the api

619
00:22:34,880 --> 00:22:37,919
wouldn't it be an option to make a

620
00:22:37,360 --> 00:22:40,080
server

621
00:22:37,919 --> 00:22:42,240
in rust and then talk to that server

622
00:22:40,080 --> 00:22:44,399
over socket for instance

623
00:22:42,240 --> 00:22:46,000
so the the question was would it make

624
00:22:44,400 --> 00:22:48,720
sense to instead of ffi

625
00:22:46,000 --> 00:22:51,200
to use a server client with rust and

626
00:22:48,720 --> 00:22:51,200
python

627
00:22:52,640 --> 00:22:57,280
yes and uh in terms of performance it

628
00:22:56,240 --> 00:23:00,240
does not

629
00:22:57,280 --> 00:23:01,840
it does not hold hold up we're talking

630
00:23:00,240 --> 00:23:03,200
we're trying to shave off milliseconds

631
00:23:01,840 --> 00:23:05,678
of of runtime

632
00:23:03,200 --> 00:23:06,799
and going through like an http stack or

633
00:23:05,679 --> 00:23:09,360
or a socket

634
00:23:06,799 --> 00:23:10,879
usually does not make sense but maybe i

635
00:23:09,360 --> 00:23:15,439
don't know maybe in some cases it could

636
00:23:10,880 --> 00:23:15,440
it could work okay

637
00:23:17,200 --> 00:23:25,740
thank you

638
00:23:21,860 --> 00:23:25,740
[Applause]

639
00:23:28,320 --> 00:23:30,399
you

