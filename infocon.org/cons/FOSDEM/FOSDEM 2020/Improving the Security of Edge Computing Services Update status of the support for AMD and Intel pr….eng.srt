1
00:00:05,040 --> 00:00:07,919
um

2
00:00:06,240 --> 00:00:10,160
my presentation is about improving the

3
00:00:07,919 --> 00:00:11,120
security of computing services it's

4
00:00:10,160 --> 00:00:13,840
mostly

5
00:00:11,120 --> 00:00:15,360
uh trench boot so open source dynamic

6
00:00:13,840 --> 00:00:19,119
route of trust

7
00:00:15,360 --> 00:00:20,720
framework and it's a short update about

8
00:00:19,119 --> 00:00:23,600
status of the development

9
00:00:20,720 --> 00:00:24,640
for amd and after me uh daniel keeper

10
00:00:23,600 --> 00:00:27,599
will present about

11
00:00:24,640 --> 00:00:28,400
intel stuff so my name is patrol i'm

12
00:00:27,599 --> 00:00:30,720
founder and

13
00:00:28,400 --> 00:00:31,519
but the system consultant at 3mdep

14
00:00:30,720 --> 00:00:34,079
polish

15
00:00:31,519 --> 00:00:35,839
consulting company we're mostly doing

16
00:00:34,079 --> 00:00:38,719
open source firmware core boot

17
00:00:35,840 --> 00:00:39,280
um we're also doing we are ufi adopters

18
00:00:38,719 --> 00:00:42,239
we are

19
00:00:39,280 --> 00:00:44,079
uh yocto participants so we we are also

20
00:00:42,239 --> 00:00:48,000
engaging in those projects

21
00:00:44,079 --> 00:00:49,440
um so just to quickly uh start what's

22
00:00:48,000 --> 00:00:51,360
what's the problem

23
00:00:49,440 --> 00:00:53,199
um so i assume everyone knows what

24
00:00:51,360 --> 00:00:54,559
static route of trust for measurement is

25
00:00:53,199 --> 00:00:55,519
and what's dynamic rate of transfer

26
00:00:54,559 --> 00:00:59,358
measurement is

27
00:00:55,520 --> 00:01:00,800
uh but um just just to tell what what's

28
00:00:59,359 --> 00:01:02,559
what's the problem problem with static

29
00:01:00,800 --> 00:01:03,680
route of trust and why we need dynamic

30
00:01:02,559 --> 00:01:07,039
route of trust

31
00:01:03,680 --> 00:01:07,920
so first of all um static route of trust

32
00:01:07,040 --> 00:01:09,920
to

33
00:01:07,920 --> 00:01:11,920
establish trust state on the platform we

34
00:01:09,920 --> 00:01:15,280
need to boot the platform

35
00:01:11,920 --> 00:01:18,400
so when platforms running quite a time

36
00:01:15,280 --> 00:01:20,960
um we cannot say what really the the

37
00:01:18,400 --> 00:01:21,520
state of trust for this platform is and

38
00:01:20,960 --> 00:01:23,279
to us

39
00:01:21,520 --> 00:01:24,960
establish it we we should just reboot

40
00:01:23,280 --> 00:01:26,240
that of course this is not possible in

41
00:01:24,960 --> 00:01:28,640
various situation

42
00:01:26,240 --> 00:01:30,000
um we cannot expect from users that they

43
00:01:28,640 --> 00:01:31,680
will reboot the platform

44
00:01:30,000 --> 00:01:33,600
reboot the laptop every time they want

45
00:01:31,680 --> 00:01:35,840
to do something sensitive

46
00:01:33,600 --> 00:01:36,880
we cannot expect that amazon servers

47
00:01:35,840 --> 00:01:40,479
will reboot

48
00:01:36,880 --> 00:01:42,240
to establish establish trust uh so

49
00:01:40,479 --> 00:01:43,520
that's why we need uh dynamic rate of

50
00:01:42,240 --> 00:01:45,119
just also

51
00:01:43,520 --> 00:01:47,200
if we have like something like looks

52
00:01:45,119 --> 00:01:49,920
plus tpm so encrypted

53
00:01:47,200 --> 00:01:50,799
file system which relies on on some

54
00:01:49,920 --> 00:01:53,759
secrets

55
00:01:50,799 --> 00:01:54,640
it's on unsealing secret based on pcr

56
00:01:53,759 --> 00:01:57,119
values

57
00:01:54,640 --> 00:01:58,399
we have to have some behinds that after

58
00:01:57,119 --> 00:02:01,759
firmware update will

59
00:01:58,399 --> 00:02:04,560
provide new pcr values to tpm and

60
00:02:01,759 --> 00:02:05,920
doing that in a secure way is kind of

61
00:02:04,560 --> 00:02:08,560
hard and challenging

62
00:02:05,920 --> 00:02:09,598
and so the question is when we should do

63
00:02:08,560 --> 00:02:11,440
that

64
00:02:09,598 --> 00:02:13,119
if we don't have dynamic root of thrust

65
00:02:11,440 --> 00:02:16,239
for measurement also

66
00:02:13,120 --> 00:02:19,599
if anyone is familiar with um

67
00:02:16,239 --> 00:02:21,680
with vendor-specific um

68
00:02:19,599 --> 00:02:24,480
static crucial trust implementations

69
00:02:21,680 --> 00:02:27,440
like uh secure boot or boot guard

70
00:02:24,480 --> 00:02:28,480
or or md hardware validate validated

71
00:02:27,440 --> 00:02:31,760
boot or nxp

72
00:02:28,480 --> 00:02:33,920
equivalent uh they know that to to

73
00:02:31,760 --> 00:02:36,160
even provision platform with that

74
00:02:33,920 --> 00:02:38,079
feature you need special tools it's not

75
00:02:36,160 --> 00:02:40,799
like uh we have open tools to

76
00:02:38,080 --> 00:02:42,080
provision everything and have uh like

77
00:02:40,800 --> 00:02:44,959
woodguard working

78
00:02:42,080 --> 00:02:45,920
um without special agreements with intel

79
00:02:44,959 --> 00:02:48,720
or any other

80
00:02:45,920 --> 00:02:51,280
companies that that are named here so

81
00:02:48,720 --> 00:02:54,560
that's also kind of challenge of um

82
00:02:51,280 --> 00:02:56,080
static route of trust so we also try it

83
00:02:54,560 --> 00:02:58,560
many of these tools

84
00:02:56,080 --> 00:02:59,280
and have to say this is very hard um

85
00:02:58,560 --> 00:03:02,480
also

86
00:02:59,280 --> 00:03:04,400
like well-established bios vendors can

87
00:03:02,480 --> 00:03:06,560
have agreements with good agreements

88
00:03:04,400 --> 00:03:09,360
that can use that tools without problems

89
00:03:06,560 --> 00:03:11,120
so having dynamic route of trust um we

90
00:03:09,360 --> 00:03:13,680
don't need static route of trust

91
00:03:11,120 --> 00:03:14,879
and can't establish um trust in the

92
00:03:13,680 --> 00:03:17,440
platform

93
00:03:14,879 --> 00:03:18,000
um yeah and other thing is like let's

94
00:03:17,440 --> 00:03:20,319
say we

95
00:03:18,000 --> 00:03:21,200
some device coming to us from i don't

96
00:03:20,319 --> 00:03:23,920
know offshore

97
00:03:21,200 --> 00:03:25,839
offshore company and we just want to

98
00:03:23,920 --> 00:03:27,839
make sure that what we're flushing even

99
00:03:25,840 --> 00:03:31,040
if we're refreshing fully bios

100
00:03:27,840 --> 00:03:33,200
um it's really what we want yeah

101
00:03:31,040 --> 00:03:34,879
and with static route of trust uh we

102
00:03:33,200 --> 00:03:35,440
cannot do that because we don't trust

103
00:03:34,879 --> 00:03:39,120
what came

104
00:03:35,440 --> 00:03:41,920
to us from from offshore offshore um

105
00:03:39,120 --> 00:03:42,640
vendor and so we need some mechanics

106
00:03:41,920 --> 00:03:45,119
that can

107
00:03:42,640 --> 00:03:45,679
uh establish trust in the platform and

108
00:03:45,120 --> 00:03:48,239
this is

109
00:03:45,680 --> 00:03:49,360
what dynamic route of trust should solve

110
00:03:48,239 --> 00:03:52,080
of course there are some

111
00:03:49,360 --> 00:03:52,560
some mineral problems with that but

112
00:03:52,080 --> 00:03:54,560
maybe

113
00:03:52,560 --> 00:03:55,599
this is a discussion for for the beer

114
00:03:54,560 --> 00:03:58,640
tonight

115
00:03:55,599 --> 00:04:00,399
um okay so so as i said like we want to

116
00:03:58,640 --> 00:04:01,599
solve this problem of re-establishing

117
00:04:00,400 --> 00:04:04,640
root of trust

118
00:04:01,599 --> 00:04:08,560
in a dynamical way we want to do that

119
00:04:04,640 --> 00:04:11,359
at any point of time of platform life

120
00:04:08,560 --> 00:04:12,000
um this should be used also very very

121
00:04:11,360 --> 00:04:15,280
useful

122
00:04:12,000 --> 00:04:18,478
in cloud environment uh when when uptime

123
00:04:15,280 --> 00:04:20,720
is critical uh when we have bare uh

124
00:04:18,478 --> 00:04:22,240
bare metal cloud environment uh of

125
00:04:20,720 --> 00:04:24,800
course the vendor

126
00:04:22,240 --> 00:04:26,320
provides the service for someone then

127
00:04:24,800 --> 00:04:28,639
this customer use that

128
00:04:26,320 --> 00:04:30,479
then reveals that platform i want to we

129
00:04:28,639 --> 00:04:31,919
want to pass it to another customer

130
00:04:30,479 --> 00:04:33,599
but we want to make sure that the

131
00:04:31,919 --> 00:04:36,719
hardware was not compromised

132
00:04:33,600 --> 00:04:38,960
um so we want to uh we need some

133
00:04:36,720 --> 00:04:40,320
highness that can establish trust in

134
00:04:38,960 --> 00:04:42,880
that

135
00:04:40,320 --> 00:04:44,080
bar metal component that we pass to

136
00:04:42,880 --> 00:04:47,120
another customer

137
00:04:44,080 --> 00:04:49,198
we also want some remote at the station

138
00:04:47,120 --> 00:04:50,639
and and of course as i said like secure

139
00:04:49,199 --> 00:04:52,800
the flashing of the

140
00:04:50,639 --> 00:04:54,639
of the firmware would be also cool this

141
00:04:52,800 --> 00:04:55,199
is this this is also related with what

142
00:04:54,639 --> 00:04:58,800
tierra

143
00:04:55,199 --> 00:05:00,560
said on the previous lecture and that

144
00:04:58,800 --> 00:05:02,160
when the hardware coming to you they

145
00:05:00,560 --> 00:05:04,400
reown the platform

146
00:05:02,160 --> 00:05:05,199
so in some cases we would like to

147
00:05:04,400 --> 00:05:07,520
reflash

148
00:05:05,199 --> 00:05:08,320
firmware in secure way and make sure

149
00:05:07,520 --> 00:05:10,880
that

150
00:05:08,320 --> 00:05:13,840
let's say only firmware signed by us can

151
00:05:10,880 --> 00:05:16,000
be flashed in the future

152
00:05:13,840 --> 00:05:18,080
uh how many of you saw that's that

153
00:05:16,000 --> 00:05:21,520
picture

154
00:05:18,080 --> 00:05:25,758
or one two i had a couple that's good

155
00:05:21,520 --> 00:05:28,240
uh so this is uh this is screen from

156
00:05:25,759 --> 00:05:29,280
uh from the trust and computing group

157
00:05:28,240 --> 00:05:32,320
specification

158
00:05:29,280 --> 00:05:35,840
uh about denying root of test

159
00:05:32,320 --> 00:05:38,880
measurement it just showed the life

160
00:05:35,840 --> 00:05:40,239
of dynamic route of trust so let's say

161
00:05:38,880 --> 00:05:42,639
we have some platform

162
00:05:40,240 --> 00:05:43,440
uh we boot the platform we have to do

163
00:05:42,639 --> 00:05:45,199
for some

164
00:05:43,440 --> 00:05:46,960
implementation of implementations of

165
00:05:45,199 --> 00:05:50,000
dynamic route of trust we have to some

166
00:05:46,960 --> 00:05:50,960
do some configuration then we have so

167
00:05:50,000 --> 00:05:53,919
called gap

168
00:05:50,960 --> 00:05:55,599
this is to be honest our firmware uh we

169
00:05:53,919 --> 00:05:56,639
don't trust our firmware that came with

170
00:05:55,600 --> 00:05:59,840
the platform

171
00:05:56,639 --> 00:06:00,720
from somewhere um even if there is

172
00:05:59,840 --> 00:06:03,758
inside uh

173
00:06:00,720 --> 00:06:06,400
static rotor truss measurement we just

174
00:06:03,759 --> 00:06:08,000
expect it to prepare environment for

175
00:06:06,400 --> 00:06:11,198
running dynamic launch event

176
00:06:08,000 --> 00:06:15,199
which is which is our hardware

177
00:06:11,199 --> 00:06:18,160
feature um that gives us ability to

178
00:06:15,199 --> 00:06:19,440
establish the trust in the platform and

179
00:06:18,160 --> 00:06:22,240
so and then when we

180
00:06:19,440 --> 00:06:23,039
when we run this dynamic launch we

181
00:06:22,240 --> 00:06:25,280
should have

182
00:06:23,039 --> 00:06:27,120
measured environment and we should make

183
00:06:25,280 --> 00:06:27,599
sure that whatever we're running right

184
00:06:27,120 --> 00:06:29,840
now

185
00:06:27,600 --> 00:06:31,440
was correctly measured in the tpm or

186
00:06:29,840 --> 00:06:33,440
whatever module

187
00:06:31,440 --> 00:06:35,120
security module we have and from that

188
00:06:33,440 --> 00:06:35,680
point everything we're running we can

189
00:06:35,120 --> 00:06:38,400
build

190
00:06:35,680 --> 00:06:39,840
chain of trust uh despite what was what

191
00:06:38,400 --> 00:06:43,679
was before

192
00:06:39,840 --> 00:06:44,799
um yeah so so the goal of transport

193
00:06:43,680 --> 00:06:46,880
project

194
00:06:44,800 --> 00:06:48,000
is to implement implement open source

195
00:06:46,880 --> 00:06:49,759
implementation because so

196
00:06:48,000 --> 00:06:51,759
far i don't know if you are familiar

197
00:06:49,759 --> 00:06:55,039
with tboot tboot is

198
00:06:51,759 --> 00:06:58,240
implementation of uh of the rtm

199
00:06:55,039 --> 00:07:00,080
uh based for inter platforms uh but the

200
00:06:58,240 --> 00:07:00,479
problem is that tibu does not support

201
00:07:00,080 --> 00:07:03,520
for

202
00:07:00,479 --> 00:07:07,199
for example amd and probably other uh

203
00:07:03,520 --> 00:07:09,919
vendors this is not like the agenda

204
00:07:07,199 --> 00:07:12,080
so the plan is to create project or it's

205
00:07:09,919 --> 00:07:15,198
already existing and evolving

206
00:07:12,080 --> 00:07:17,120
um that will support the rtm just out of

207
00:07:15,199 --> 00:07:19,120
the box with any distribution

208
00:07:17,120 --> 00:07:20,560
across all components that that have to

209
00:07:19,120 --> 00:07:23,759
be supported which is

210
00:07:20,560 --> 00:07:25,840
bootloader linux kernel and

211
00:07:23,759 --> 00:07:27,520
and probably some maybe in some cases

212
00:07:25,840 --> 00:07:30,960
firmware um

213
00:07:27,520 --> 00:07:32,960
okay so i assume that all the basic of

214
00:07:30,960 --> 00:07:35,359
basics of transworld can be understood

215
00:07:32,960 --> 00:07:37,758
uh by the presentation that i gave

216
00:07:35,360 --> 00:07:39,440
in the past on open source firmware

217
00:07:37,759 --> 00:07:40,400
conference and on platform security

218
00:07:39,440 --> 00:07:42,639
summit so i

219
00:07:40,400 --> 00:07:45,440
uh if this is new for you it would be

220
00:07:42,639 --> 00:07:48,639
great to look into those presentations

221
00:07:45,440 --> 00:07:50,560
okay so how the state look uh today i'm

222
00:07:48,639 --> 00:07:52,560
right now i'm starting to speak mostly

223
00:07:50,560 --> 00:07:55,039
from amd point of view

224
00:07:52,560 --> 00:07:57,280
because um because like this

225
00:07:55,039 --> 00:08:00,000
implementation is divided oracle

226
00:07:57,280 --> 00:08:00,400
and daniel like kind of doing more intel

227
00:08:00,000 --> 00:08:03,680
stuff

228
00:08:00,400 --> 00:08:06,960
intel txt and i'm doing more amd stuff

229
00:08:03,680 --> 00:08:07,919
so sk init and in our case we're using

230
00:08:06,960 --> 00:08:11,039
pc engines

231
00:08:07,919 --> 00:08:14,080
platform which is a core boot

232
00:08:11,039 --> 00:08:17,280
based platform small router

233
00:08:14,080 --> 00:08:20,159
and we have srtm uh

234
00:08:17,280 --> 00:08:21,520
implemented with core boot in this case

235
00:08:20,160 --> 00:08:24,720
we're running

236
00:08:21,520 --> 00:08:27,840
some payload which is still in spy flash

237
00:08:24,720 --> 00:08:31,039
this payload is grub grub implements uh

238
00:08:27,840 --> 00:08:33,120
all the things that are necessary for

239
00:08:31,039 --> 00:08:36,080
preparing environment for running sk

240
00:08:33,120 --> 00:08:37,599
init which is a special hardware command

241
00:08:36,080 --> 00:08:39,919
that

242
00:08:37,599 --> 00:08:41,200
which is equivalent to this dynamic

243
00:08:39,919 --> 00:08:44,000
launch event that i

244
00:08:41,200 --> 00:08:45,519
showed on previous slide and then we

245
00:08:44,000 --> 00:08:49,200
execute special small

246
00:08:45,519 --> 00:08:50,880
binary which is called uh landing zone

247
00:08:49,200 --> 00:08:53,440
and this landing zone have all the

248
00:08:50,880 --> 00:08:55,839
primitives to

249
00:08:53,440 --> 00:08:56,720
established trust in the uh on this

250
00:08:55,839 --> 00:08:59,680
platform

251
00:08:56,720 --> 00:09:00,320
um then this this landing zone calls

252
00:08:59,680 --> 00:09:02,479
linux

253
00:09:00,320 --> 00:09:03,920
and some small initial mfs right now

254
00:09:02,480 --> 00:09:06,160
we're using europe

255
00:09:03,920 --> 00:09:08,240
and then from that point we can k exec

256
00:09:06,160 --> 00:09:10,079
everything what we want uh

257
00:09:08,240 --> 00:09:11,680
i don't know if you heard about k exec

258
00:09:10,080 --> 00:09:14,000
inc windows on last

259
00:09:11,680 --> 00:09:14,959
open source firmware conference i know

260
00:09:14,000 --> 00:09:17,200
that some people

261
00:09:14,959 --> 00:09:18,000
did that with vmware uh definitely

262
00:09:17,200 --> 00:09:21,040
kernel is

263
00:09:18,000 --> 00:09:23,600
possible we did that also with zen so

264
00:09:21,040 --> 00:09:24,240
this is how things look like um so in

265
00:09:23,600 --> 00:09:26,959
short

266
00:09:24,240 --> 00:09:28,320
just to on the bottom you see how this

267
00:09:26,959 --> 00:09:31,439
matched to the previous

268
00:09:28,320 --> 00:09:34,000
slide what components in the colors is

269
00:09:31,440 --> 00:09:34,480
is what from previous slide okay so

270
00:09:34,000 --> 00:09:37,200
what's

271
00:09:34,480 --> 00:09:39,200
involved to make it happen so definitely

272
00:09:37,200 --> 00:09:42,560
we need hardware

273
00:09:39,200 --> 00:09:44,800
and if we compare um

274
00:09:42,560 --> 00:09:46,319
so we have intel and and md hardware

275
00:09:44,800 --> 00:09:49,760
capable of doing that

276
00:09:46,320 --> 00:09:52,000
um we we need some firmware uh so we

277
00:09:49,760 --> 00:09:54,800
mostly on core booth we're doing most

278
00:09:52,000 --> 00:09:56,880
mostly on in in core boot but uh

279
00:09:54,800 --> 00:10:00,000
definitely this would be possible with

280
00:09:56,880 --> 00:10:03,120
ufi and i know that intel txt

281
00:10:00,000 --> 00:10:06,320
will probably start with ufi then of

282
00:10:03,120 --> 00:10:09,360
course bootloader right now uh only grub

283
00:10:06,320 --> 00:10:12,399
um and yeah so i have uh

284
00:10:09,360 --> 00:10:15,600
i have to move on um so i have

285
00:10:12,399 --> 00:10:17,440
more information here about platform um

286
00:10:15,600 --> 00:10:19,600
maybe this is not the most important

287
00:10:17,440 --> 00:10:20,079
thing what is it what is very important

288
00:10:19,600 --> 00:10:22,560
uh

289
00:10:20,079 --> 00:10:23,920
for amd is that amd implementation can

290
00:10:22,560 --> 00:10:26,160
be fully open source

291
00:10:23,920 --> 00:10:27,839
so landing zone is already on github you

292
00:10:26,160 --> 00:10:29,199
can look into the code how it looks like

293
00:10:27,839 --> 00:10:31,440
there is no dependency

294
00:10:29,200 --> 00:10:33,440
no closed source dependency in case of

295
00:10:31,440 --> 00:10:35,200
intel it would be very hard because acm

296
00:10:33,440 --> 00:10:38,000
bios and acm

297
00:10:35,200 --> 00:10:40,000
in it which which right now are closed

298
00:10:38,000 --> 00:10:43,600
and there are no plans to open that

299
00:10:40,000 --> 00:10:45,680
um and our plans

300
00:10:43,600 --> 00:10:47,680
what we have to do is like we definitely

301
00:10:45,680 --> 00:10:51,120
need some more protection

302
00:10:47,680 --> 00:10:54,160
like dma protection for landing zone

303
00:10:51,120 --> 00:10:54,160
we're working on that

304
00:10:54,240 --> 00:10:57,839
yeah so right now everything's working

305
00:10:56,320 --> 00:11:00,560
you can you can test that

306
00:10:57,839 --> 00:11:02,079
by simply building uh corporate

307
00:11:00,560 --> 00:11:04,479
corporate binary

308
00:11:02,079 --> 00:11:06,479
plus adding some root file system and

309
00:11:04,480 --> 00:11:10,320
you should be able to check that

310
00:11:06,480 --> 00:11:14,480
pcrs 17 and 18 were populated

311
00:11:10,320 --> 00:11:18,160
uh with um with correct values uh

312
00:11:14,480 --> 00:11:19,959
of measurement in case of bootloader

313
00:11:18,160 --> 00:11:22,800
it's like uh

314
00:11:19,959 --> 00:11:27,040
1700 lines change uh

315
00:11:22,800 --> 00:11:30,399
to grub we want to upstream that

316
00:11:27,040 --> 00:11:31,920
we're waiting for rfc for intel txt just

317
00:11:30,399 --> 00:11:33,040
to make sure that everything will be

318
00:11:31,920 --> 00:11:36,640
aligned and have

319
00:11:33,040 --> 00:11:37,199
common design uh but but fork of grub is

320
00:11:36,640 --> 00:11:39,680
on

321
00:11:37,200 --> 00:11:41,200
our github and you can also take it and

322
00:11:39,680 --> 00:11:44,560
and try to use that

323
00:11:41,200 --> 00:11:46,720
we change a bunch of things

324
00:11:44,560 --> 00:11:48,479
i will not dive into details because

325
00:11:46,720 --> 00:11:50,639
it's more about implementation

326
00:11:48,480 --> 00:11:52,880
but our goal is to merge everything into

327
00:11:50,639 --> 00:11:55,120
the upstream project

328
00:11:52,880 --> 00:11:57,519
landing zone it's like 2 000 lines of

329
00:11:55,120 --> 00:11:59,279
code

330
00:11:57,519 --> 00:12:00,560
right now it lives on trench boot

331
00:11:59,279 --> 00:12:03,040
repository

332
00:12:00,560 --> 00:12:04,880
uh we tried so this is definitely

333
00:12:03,040 --> 00:12:09,599
definitely related only with

334
00:12:04,880 --> 00:12:12,880
amd acm as it is the

335
00:12:09,600 --> 00:12:15,200
equivalent on intel side and so this is

336
00:12:12,880 --> 00:12:16,959
this is very small like for 32 bits it's

337
00:12:15,200 --> 00:12:21,120
like 12

338
00:12:16,959 --> 00:12:22,800
kilo and there were many improvements

339
00:12:21,120 --> 00:12:24,639
since last presentation

340
00:12:22,800 --> 00:12:26,000
and we would like to thank andrew cooper

341
00:12:24,639 --> 00:12:28,800
and zen project for

342
00:12:26,000 --> 00:12:30,720
supporting us in improving we added

343
00:12:28,800 --> 00:12:34,079
sha-256 measurements

344
00:12:30,720 --> 00:12:36,240
so everything looks uh correct right now

345
00:12:34,079 --> 00:12:38,000
and after implementing dma protection we

346
00:12:36,240 --> 00:12:41,120
should be good to go

347
00:12:38,000 --> 00:12:43,839
and provide that to distributions

348
00:12:41,120 --> 00:12:45,839
okay this is about dmi and there is also

349
00:12:43,839 --> 00:12:48,720
additional recently the material

350
00:12:45,839 --> 00:12:51,360
provided post that there may be other

351
00:12:48,720 --> 00:12:53,839
ways to mitigate dma attacks

352
00:12:51,360 --> 00:12:56,720
that may happen at the point of the

353
00:12:53,839 --> 00:12:59,839
dynamic launch event

354
00:12:56,720 --> 00:13:00,240
in case of linux i believe like daniel

355
00:12:59,839 --> 00:13:02,560
will

356
00:13:00,240 --> 00:13:04,399
we'll talk a little bit more about that

357
00:13:02,560 --> 00:13:08,399
but what we were able to do

358
00:13:04,399 --> 00:13:12,079
was to use linux and europe as a

359
00:13:08,399 --> 00:13:15,279
as a dlme which k exact uh

360
00:13:12,079 --> 00:13:18,399
zen in which we run virtual firewall

361
00:13:15,279 --> 00:13:20,560
which was pfsense in this case um and

362
00:13:18,399 --> 00:13:22,079
there are many patches that that coming

363
00:13:20,560 --> 00:13:24,638
to to kernel

364
00:13:22,079 --> 00:13:25,760
to support that uh what we want to do

365
00:13:24,639 --> 00:13:27,839
also is

366
00:13:25,760 --> 00:13:29,920
our reproducible builds interesting

367
00:13:27,839 --> 00:13:33,600
thing europe is written in go

368
00:13:29,920 --> 00:13:34,880
so it's support supposed to support

369
00:13:33,600 --> 00:13:36,800
reproducible builds

370
00:13:34,880 --> 00:13:38,320
by default but only in you build in the

371
00:13:36,800 --> 00:13:40,800
same path so

372
00:13:38,320 --> 00:13:42,160
so it's not exactly if anyone will build

373
00:13:40,800 --> 00:13:44,880
in different part it the the

374
00:13:42,160 --> 00:13:47,279
shasm will be different so this is not

375
00:13:44,880 --> 00:13:49,920
this is not what we want

376
00:13:47,279 --> 00:13:52,959
um okay so that's all it's like

377
00:13:49,920 --> 00:13:52,959
marketing stuff uh

378
00:14:00,839 --> 00:14:03,839
3mdap

379
00:14:10,480 --> 00:14:13,760
okay thank you peter for the

380
00:14:11,839 --> 00:14:16,000
introduction into the drtm my

381
00:14:13,760 --> 00:14:19,040
presentation will focus on

382
00:14:16,000 --> 00:14:22,320
uh intel txt implementation both for

383
00:14:19,040 --> 00:14:24,560
first for grub and for uh

384
00:14:22,320 --> 00:14:25,600
kernel my name is daniel keeper i work

385
00:14:24,560 --> 00:14:27,760
for rocco

386
00:14:25,600 --> 00:14:29,519
and i am also grab opposition maintainer

387
00:14:27,760 --> 00:14:31,600
i prepared this presentation together

388
00:14:29,519 --> 00:14:34,160
with my colleagues ross flipson

389
00:14:31,600 --> 00:14:35,120
who is working on the kernel side and

390
00:14:34,160 --> 00:14:37,519
daniel

391
00:14:35,120 --> 00:14:38,720
smith which coordinates the transport

392
00:14:37,519 --> 00:14:41,199
project in general

393
00:14:38,720 --> 00:14:42,320
so some legal stuff at the beginning and

394
00:14:41,199 --> 00:14:45,279
uh the grub

395
00:14:42,320 --> 00:14:47,120
thing it was decided to choose the grub

396
00:14:45,279 --> 00:14:48,959
because it is one of the most common

397
00:14:47,120 --> 00:14:50,880
bootloaders in currently existing

398
00:14:48,959 --> 00:14:53,518
systems so we are focusing on

399
00:14:50,880 --> 00:14:54,079
it now and immediately at the beginning

400
00:14:53,519 --> 00:14:57,279
of

401
00:14:54,079 --> 00:14:58,160
uh intel txt develop intel txt

402
00:14:57,279 --> 00:15:01,040
implementation

403
00:14:58,160 --> 00:15:01,439
we realized that we have to change the

404
00:15:01,040 --> 00:15:04,639
boot

405
00:15:01,440 --> 00:15:07,839
linux boot protocol and uh after

406
00:15:04,639 --> 00:15:10,160
quite long discussion with uh

407
00:15:07,839 --> 00:15:11,360
x86 maintenance we hammered out

408
00:15:10,160 --> 00:15:14,480
something which is called

409
00:15:11,360 --> 00:15:15,360
kernel infrastructure it is a an

410
00:15:14,480 --> 00:15:17,839
addition which

411
00:15:15,360 --> 00:15:18,560
uh allows you to convey some information

412
00:15:17,839 --> 00:15:21,839
from the

413
00:15:18,560 --> 00:15:24,638
uh from the kernel to the bootloader uh

414
00:15:21,839 --> 00:15:25,519
currently this infrastructure is a linux

415
00:15:24,639 --> 00:15:29,440
kernel for

416
00:15:25,519 --> 00:15:30,560
5.5 and we will build a old solution on

417
00:15:29,440 --> 00:15:33,519
top of that

418
00:15:30,560 --> 00:15:36,479
uh we also need uh to add some uh

419
00:15:33,519 --> 00:15:40,720
commands which are needed to initialize

420
00:15:36,480 --> 00:15:43,440
uh intel txt or a sk in it one

421
00:15:40,720 --> 00:15:45,519
is uh one command will tell the grub

422
00:15:43,440 --> 00:15:48,079
that we have to switch to the rtm

423
00:15:45,519 --> 00:15:49,600
i think more or less another thing is

424
00:15:48,079 --> 00:15:53,040
command which will load

425
00:15:49,600 --> 00:15:54,160
uh in case of the intel txt uh the the

426
00:15:53,040 --> 00:15:57,599
uh

427
00:15:54,160 --> 00:15:59,360
the acm uh module into into the ram and

428
00:15:57,600 --> 00:16:03,600
in case of amd's

429
00:15:59,360 --> 00:16:06,480
amd sk in it uh lz

430
00:16:03,600 --> 00:16:07,120
i think that this part can be automated

431
00:16:06,480 --> 00:16:10,720
and we

432
00:16:07,120 --> 00:16:13,360
at some point drop this uh this uh load

433
00:16:10,720 --> 00:16:15,279
module command also we need to add a

434
00:16:13,360 --> 00:16:17,360
something which is called relocator this

435
00:16:15,279 --> 00:16:21,120
is a small piece of code which

436
00:16:17,360 --> 00:16:22,079
uh move uh the os image in the final

437
00:16:21,120 --> 00:16:25,279
listing

438
00:16:22,079 --> 00:16:27,920
place in in the memory as uh piotr

439
00:16:25,279 --> 00:16:29,120
told uh currently both implementations

440
00:16:27,920 --> 00:16:32,639
for md and

441
00:16:29,120 --> 00:16:33,839
txta are done separately uh but we are

442
00:16:32,639 --> 00:16:37,759
going to merge them

443
00:16:33,839 --> 00:16:40,959
i'm going to post that intel txt rfc

444
00:16:37,759 --> 00:16:44,079
uh iphone i think that uh

445
00:16:40,959 --> 00:16:47,119
at the turn of february and march

446
00:16:44,079 --> 00:16:47,599
uh i have to admit that i was able to

447
00:16:47,120 --> 00:16:50,480
run

448
00:16:47,600 --> 00:16:52,079
acm just before the them so i hope that

449
00:16:50,480 --> 00:16:55,519
are pretty close to

450
00:16:52,079 --> 00:16:58,479
have uh intel txt environment

451
00:16:55,519 --> 00:16:58,880
running um at the beginning of february

452
00:16:58,480 --> 00:17:02,320
uh

453
00:16:58,880 --> 00:17:06,160
and um and amd's getting it

454
00:17:02,320 --> 00:17:09,760
will be revised on on my intel txt

455
00:17:06,160 --> 00:17:12,240
uh developments because we feel that

456
00:17:09,760 --> 00:17:14,480
much of code will be common for amd and

457
00:17:12,240 --> 00:17:17,199
intel txt

458
00:17:14,480 --> 00:17:18,559
so let's move on to intel um

459
00:17:17,199 --> 00:17:20,400
implementation

460
00:17:18,559 --> 00:17:21,678
at the beginning we have something which

461
00:17:20,400 --> 00:17:23,360
is called

462
00:17:21,679 --> 00:17:24,959
at the beginning of the kernel we have

463
00:17:23,359 --> 00:17:25,520
we have something which is called sl

464
00:17:24,959 --> 00:17:28,079
stop

465
00:17:25,520 --> 00:17:30,879
we can compare this piece of code to

466
00:17:28,079 --> 00:17:33,600
something which is called ufi stop

467
00:17:30,880 --> 00:17:35,919
and it this thing is uh split in uh

468
00:17:33,600 --> 00:17:36,719
something which is uh called slss stop

469
00:17:35,919 --> 00:17:39,760
entry at

470
00:17:36,720 --> 00:17:41,200
it leaves in head the text section uh

471
00:17:39,760 --> 00:17:42,160
because this section is tightly

472
00:17:41,200 --> 00:17:45,039
organized we

473
00:17:42,160 --> 00:17:45,760
have to do some minimal things and jump

474
00:17:45,039 --> 00:17:48,799
uh immediate

475
00:17:45,760 --> 00:17:49,760
almost immediately to sl stops function

476
00:17:48,799 --> 00:17:53,360
which leaves

477
00:17:49,760 --> 00:17:56,640
in the the text section and uh

478
00:17:53,360 --> 00:18:00,080
slstaff uh i think is responsible for

479
00:17:56,640 --> 00:18:03,440
all bsp uh cpu initialization

480
00:18:00,080 --> 00:18:04,240
so it means that it loads gdt checks and

481
00:18:03,440 --> 00:18:07,840
prepares

482
00:18:04,240 --> 00:18:10,400
txt heap or enables uh some

483
00:18:07,840 --> 00:18:12,240
interrupts wakes a piece and park them

484
00:18:10,400 --> 00:18:14,960
in special place

485
00:18:12,240 --> 00:18:15,760
in place i will discuss this thing a bit

486
00:18:14,960 --> 00:18:19,200
later

487
00:18:15,760 --> 00:18:21,760
and also uh this piece of code restores

488
00:18:19,200 --> 00:18:22,880
empty errors and msrs which were

489
00:18:21,760 --> 00:18:26,400
clobbered during

490
00:18:22,880 --> 00:18:28,799
uh intel txt startup phase

491
00:18:26,400 --> 00:18:30,480
also there is something which is sl mine

492
00:18:28,799 --> 00:18:33,280
this part of code

493
00:18:30,480 --> 00:18:35,200
before executing uh uh and before

494
00:18:33,280 --> 00:18:38,399
executing any code or

495
00:18:35,200 --> 00:18:39,760
accessing any data does all measurements

496
00:18:38,400 --> 00:18:42,080
uh on the data

497
00:18:39,760 --> 00:18:43,760
for it so this means for example that

498
00:18:42,080 --> 00:18:46,320
boot params all commands

499
00:18:43,760 --> 00:18:47,840
uh on all arguments which are passed to

500
00:18:46,320 --> 00:18:50,799
the kernel are measured

501
00:18:47,840 --> 00:18:51,600
also the if you have uh any trauma phase

502
00:18:50,799 --> 00:18:53,679
presence

503
00:18:51,600 --> 00:18:56,000
as a separate module this immunity

504
00:18:53,679 --> 00:18:58,799
transfers instruments

505
00:18:56,000 --> 00:18:59,520
image will be measured also this part of

506
00:18:58,799 --> 00:19:02,320
code

507
00:18:59,520 --> 00:19:04,160
validates and loads uh correct values to

508
00:19:02,320 --> 00:19:06,960
your empty errors

509
00:19:04,160 --> 00:19:07,760
and after that we jump to get the kernel

510
00:19:06,960 --> 00:19:11,440
proper

511
00:19:07,760 --> 00:19:13,360
and initialization of tx intel txt

512
00:19:11,440 --> 00:19:14,160
happens in something which is called a

513
00:19:13,360 --> 00:19:17,280
slant

514
00:19:14,160 --> 00:19:20,720
setup this part of code lives in uh

515
00:19:17,280 --> 00:19:24,480
setup c and is called uh from setup arch

516
00:19:20,720 --> 00:19:27,120
and a responsibility of of

517
00:19:24,480 --> 00:19:28,320
this this this part of code performs

518
00:19:27,120 --> 00:19:30,639
following tasks

519
00:19:28,320 --> 00:19:33,120
so it checks that we run in secure

520
00:19:30,640 --> 00:19:35,760
launch uh

521
00:19:33,120 --> 00:19:38,239
in in secure launch uh checks the

522
00:19:35,760 --> 00:19:42,240
platform is properly initialized

523
00:19:38,240 --> 00:19:45,440
verify uh vtdpr mars uh also

524
00:19:42,240 --> 00:19:46,880
reserves some regions uh like txt heap

525
00:19:45,440 --> 00:19:51,120
txt registers in

526
00:19:46,880 --> 00:19:54,160
e8 20 map validates uh yet when map

527
00:19:51,120 --> 00:19:57,760
against mdr

528
00:19:54,160 --> 00:20:03,120
pass from txt to the mle

529
00:19:57,760 --> 00:20:07,840
and also pass a cpi dmr prepared by txt

530
00:20:03,120 --> 00:20:07,840
to iomu driver

531
00:20:08,640 --> 00:20:13,360
also as i told earlier we have

532
00:20:11,600 --> 00:20:17,678
difficulties with starting a

533
00:20:13,360 --> 00:20:18,158
ap aps in smx mode because we cannot do

534
00:20:17,679 --> 00:20:21,440
that in

535
00:20:18,159 --> 00:20:24,320
a normal way so after a

536
00:20:21,440 --> 00:20:24,960
very long discussion with different

537
00:20:24,320 --> 00:20:27,918
people

538
00:20:24,960 --> 00:20:28,799
people ross who is working on that

539
00:20:27,919 --> 00:20:31,280
decided that

540
00:20:28,799 --> 00:20:32,960
the best method to start a piece is park

541
00:20:31,280 --> 00:20:36,559
them in special place

542
00:20:32,960 --> 00:20:39,360
they are simply stopped in hull state uh

543
00:20:36,559 --> 00:20:39,840
we also consider busy loop but i think

544
00:20:39,360 --> 00:20:42,000
that

545
00:20:39,840 --> 00:20:43,199
it is better to just stop them in a

546
00:20:42,000 --> 00:20:46,559
health state

547
00:20:43,200 --> 00:20:50,159
uh as i said and

548
00:20:46,559 --> 00:20:53,440
then if we go uh in this

549
00:20:50,159 --> 00:20:56,799
s p bring up code uh these ips

550
00:20:53,440 --> 00:21:00,720
uh get uh nmi api for

551
00:20:56,799 --> 00:21:04,158
from bsp and later

552
00:21:00,720 --> 00:21:08,240
installation happens as normal the

553
00:21:04,159 --> 00:21:11,440
incisalization happens as normal

554
00:21:08,240 --> 00:21:13,200
there is also k exact uh part this part

555
00:21:11,440 --> 00:21:16,320
is needed to

556
00:21:13,200 --> 00:21:19,360
switch from amelica mle

557
00:21:16,320 --> 00:21:21,678
to uh os kernel als it

558
00:21:19,360 --> 00:21:24,240
it this functionality also will be used

559
00:21:21,679 --> 00:21:25,120
if if we would like to re-initialize the

560
00:21:24,240 --> 00:21:28,159
rtm

561
00:21:25,120 --> 00:21:32,158
currently you are focusing on stopping

562
00:21:28,159 --> 00:21:35,520
smx mode so uh during the execution of k

563
00:21:32,159 --> 00:21:37,200
exec quite late uh when everything

564
00:21:35,520 --> 00:21:39,039
uh everything in the platform almost

565
00:21:37,200 --> 00:21:40,400
everything in the platform is disabled

566
00:21:39,039 --> 00:21:44,559
all ips are

567
00:21:40,400 --> 00:21:47,679
stopped uh

568
00:21:44,559 --> 00:21:51,600
this part of code just does some

569
00:21:47,679 --> 00:21:55,200
some play with txt register and

570
00:21:51,600 --> 00:21:59,280
call as exit and this uh

571
00:21:55,200 --> 00:22:02,320
this causes that bsp leaves smx mode

572
00:21:59,280 --> 00:22:05,360
uh and later os kernel is started

573
00:22:02,320 --> 00:22:05,840
if we uh would like to use the the new

574
00:22:05,360 --> 00:22:09,120
os

575
00:22:05,840 --> 00:22:11,280
in case of uh establishing new dr tm

576
00:22:09,120 --> 00:22:13,678
which we have to reinitialize pla

577
00:22:11,280 --> 00:22:17,200
platform and use a getsec

578
00:22:13,679 --> 00:22:20,559
center uh we also need some

579
00:22:17,200 --> 00:22:21,840
we also need in emily some access to the

580
00:22:20,559 --> 00:22:24,240
tpm log

581
00:22:21,840 --> 00:22:25,918
this is needed because the security

582
00:22:24,240 --> 00:22:28,480
framework which usually runs

583
00:22:25,919 --> 00:22:29,280
in user space have to get some

584
00:22:28,480 --> 00:22:32,480
information

585
00:22:29,280 --> 00:22:36,000
from the dpm event lock so

586
00:22:32,480 --> 00:22:39,760
this this is done by by exposing the log

587
00:22:36,000 --> 00:22:43,200
via node in the security fs currently

588
00:22:39,760 --> 00:22:45,520
we had a review for

589
00:22:43,200 --> 00:22:46,640
second version internally as far as i

590
00:22:45,520 --> 00:22:49,440
can tell

591
00:22:46,640 --> 00:22:49,840
uh ross and daniel currently are working

592
00:22:49,440 --> 00:22:53,360
on

593
00:22:49,840 --> 00:22:54,559
a new third version i hope that it will

594
00:22:53,360 --> 00:22:57,760
be published

595
00:22:54,559 --> 00:23:01,120
soon maybe together with uh the

596
00:22:57,760 --> 00:23:03,440
the grub code because both pieces has

597
00:23:01,120 --> 00:23:04,158
have to be synchronized because there is

598
00:23:03,440 --> 00:23:07,120
a boot

599
00:23:04,159 --> 00:23:09,200
there is a boot protocol and this

600
00:23:07,120 --> 00:23:12,399
protocol have to be properly

601
00:23:09,200 --> 00:23:15,200
defined that is why i think uh merging

602
00:23:12,400 --> 00:23:15,840
pro probably will happen uh in that way

603
00:23:15,200 --> 00:23:17,600
that uh

604
00:23:15,840 --> 00:23:18,879
first of all the kernel will be merged

605
00:23:17,600 --> 00:23:22,000
and then after that

606
00:23:18,880 --> 00:23:22,799
uh if we if the boot protocol is

607
00:23:22,000 --> 00:23:25,919
established

608
00:23:22,799 --> 00:23:29,360
then the gap code will be merged

609
00:23:25,919 --> 00:23:33,120
so that's it i think uh

610
00:23:29,360 --> 00:23:37,520
questions uh also for my part and for

611
00:23:33,120 --> 00:23:39,840
peter part

612
00:23:37,520 --> 00:23:40,960
yeah i know we we we run through that

613
00:23:39,840 --> 00:23:42,158
very very fast temperature

614
00:23:40,960 --> 00:23:44,640
yeah sorry about it you don't have

615
00:23:42,159 --> 00:23:47,440
background on on the trench boat

616
00:23:44,640 --> 00:23:48,000
but if you have like any concerns uh

617
00:23:47,440 --> 00:23:50,559
that

618
00:23:48,000 --> 00:23:53,600
jump up directly just let us know maybe

619
00:23:50,559 --> 00:23:53,600
we can clarify that now

620
00:23:53,919 --> 00:23:58,000
yeah so guys how are you plugging into

621
00:23:56,320 --> 00:23:59,200
any kind of remote at station

622
00:23:58,000 --> 00:24:01,919
infrastructure

623
00:23:59,200 --> 00:24:04,080
are you looking at that i believe this

624
00:24:01,919 --> 00:24:07,279
is like way in the future

625
00:24:04,080 --> 00:24:10,480
but but i believe this would be uh

626
00:24:07,279 --> 00:24:12,240
it's already used in some way by by some

627
00:24:10,480 --> 00:24:14,559
commercial companies i believe microsoft

628
00:24:12,240 --> 00:24:18,720
already doing that

629
00:24:14,559 --> 00:24:21,918
so i believe you will re-establish

630
00:24:18,720 --> 00:24:24,799
kind of secure environment on demand

631
00:24:21,919 --> 00:24:26,320
and from that you will start of course

632
00:24:24,799 --> 00:24:27,039
using tpm behind the score at the

633
00:24:26,320 --> 00:24:29,520
station

634
00:24:27,039 --> 00:24:30,640
send the information about the

635
00:24:29,520 --> 00:24:32,080
measurements and then

636
00:24:30,640 --> 00:24:34,159
if everything is fine then at the

637
00:24:32,080 --> 00:24:36,960
station

638
00:24:34,159 --> 00:24:38,240
this security environment can live in

639
00:24:36,960 --> 00:24:41,760
both places first

640
00:24:38,240 --> 00:24:44,720
in mle and second can live

641
00:24:41,760 --> 00:24:45,360
also in the os kernel which is started

642
00:24:44,720 --> 00:24:47,279
by

643
00:24:45,360 --> 00:24:48,479
our assembly we are internally we are

644
00:24:47,279 --> 00:24:50,720
looking at different

645
00:24:48,480 --> 00:24:52,320
solutions certainly i'm not able to tell

646
00:24:50,720 --> 00:24:55,200
much about that

647
00:24:52,320 --> 00:24:56,720
uh but um we are also considering uh

648
00:24:55,200 --> 00:24:59,840
open source solutions which are

649
00:24:56,720 --> 00:25:02,000
currently quite natural many remote

650
00:24:59,840 --> 00:25:05,840
attestation servers and

651
00:25:02,000 --> 00:25:07,440
um yeah yeah so

652
00:25:05,840 --> 00:25:09,439
i don't know what would we work with

653
00:25:07,440 --> 00:25:12,320
that but i know iatf works

654
00:25:09,440 --> 00:25:14,000
on some standardization uh and like

655
00:25:12,320 --> 00:25:17,039
probably we are closer

656
00:25:14,000 --> 00:25:17,039
to that approach

657
00:25:17,919 --> 00:25:21,279
i'm sorry i missed the point what is the

658
00:25:19,600 --> 00:25:24,480
reason of putting

659
00:25:21,279 --> 00:25:26,840
into the cpi um

660
00:25:24,480 --> 00:25:29,120
i'm not sure that i understand the

661
00:25:26,840 --> 00:25:30,959
questions

662
00:25:29,120 --> 00:25:32,399
it's like it just simplifies our

663
00:25:30,960 --> 00:25:34,000
development and

664
00:25:32,400 --> 00:25:36,799
it doesn't have to be like that it can

665
00:25:34,000 --> 00:25:39,279
be on storage it does not

666
00:25:36,799 --> 00:25:40,799
um what's the what's the purpose of

667
00:25:39,279 --> 00:25:43,679
placing grub in spy

668
00:25:40,799 --> 00:25:45,039
it's just in our case uh simplifies

669
00:25:43,679 --> 00:25:47,039
development but it

670
00:25:45,039 --> 00:25:48,799
doesn't matter where where it is because

671
00:25:47,039 --> 00:25:51,919
we we measure grab

672
00:25:48,799 --> 00:25:53,760
if you want srtn part uh then we measure

673
00:25:51,919 --> 00:25:55,440
grab before executing it

674
00:25:53,760 --> 00:25:57,919
so that's the first thing and second

675
00:25:55,440 --> 00:25:59,039
thing even even if we don't care about

676
00:25:57,919 --> 00:26:01,919
srtm

677
00:25:59,039 --> 00:26:05,360
grub executes the rtm flow and from that

678
00:26:01,919 --> 00:26:08,840
point we establish the trust so we

679
00:26:05,360 --> 00:26:11,840
yeah when you measure as a group is

680
00:26:08,840 --> 00:26:11,840
measured

681
00:26:17,840 --> 00:26:22,639
in our case in spy flash you you're not

682
00:26:20,880 --> 00:26:23,120
adding anything to a spy flash so you

683
00:26:22,640 --> 00:26:27,120
measure

684
00:26:23,120 --> 00:26:29,360
you measure the the whole payload

685
00:26:27,120 --> 00:26:30,719
so the whole graph and you cannot like

686
00:26:29,360 --> 00:26:33,520
inter intercept

687
00:26:30,720 --> 00:26:34,880
and add load modules at that point in

688
00:26:33,520 --> 00:26:37,120
case of

689
00:26:34,880 --> 00:26:38,640
in case of storing that on storage it's

690
00:26:37,120 --> 00:26:40,959
like different case and like

691
00:26:38,640 --> 00:26:41,919
we didn't kind of thought about how this

692
00:26:40,960 --> 00:26:45,360
would be

693
00:26:41,919 --> 00:26:47,600
uh this would be not like yeah uh i know

694
00:26:45,360 --> 00:26:49,439
uh it is much easier to measure whole

695
00:26:47,600 --> 00:26:51,360
image of of the grub

696
00:26:49,440 --> 00:26:53,360
usually if you if you would like to run

697
00:26:51,360 --> 00:26:54,158
the grub in secular environment usually

698
00:26:53,360 --> 00:26:57,600
it is done

699
00:26:54,159 --> 00:26:58,159
that you are have a whole image which

700
00:26:57,600 --> 00:27:00,000
contains

701
00:26:58,159 --> 00:27:01,360
all modules for example if you run

702
00:27:00,000 --> 00:27:04,799
secure boot

703
00:27:01,360 --> 00:27:08,399
whole image which is signed by uh

704
00:27:04,799 --> 00:27:11,600
x 409 uh certificate

705
00:27:08,400 --> 00:27:15,200
contains all modules currently if you

706
00:27:11,600 --> 00:27:18,000
use graph upstream it is possible to

707
00:27:15,200 --> 00:27:19,120
measure every module and every command

708
00:27:18,000 --> 00:27:21,200
which is executed

709
00:27:19,120 --> 00:27:23,120
by grub it is done by something which is

710
00:27:21,200 --> 00:27:26,679
called verifiers framework and this

711
00:27:23,120 --> 00:27:29,360
this framework went in into the grub uh

712
00:27:26,679 --> 00:27:32,480
2018 as i remember correctly

713
00:27:29,360 --> 00:27:32,719
uh so you have two choices but in case

714
00:27:32,480 --> 00:27:35,360
of

715
00:27:32,720 --> 00:27:36,080
uh peter peter's solution it was much

716
00:27:35,360 --> 00:27:38,158
easier to

717
00:27:36,080 --> 00:27:39,600
build a whole image which contains

718
00:27:38,159 --> 00:27:42,399
everything and this way

719
00:27:39,600 --> 00:27:48,158
you don't need to that to do additional

720
00:27:42,399 --> 00:27:52,080
measurement from the grub

721
00:27:48,159 --> 00:27:54,720
excuse me what happens where what

722
00:27:52,080 --> 00:27:56,158
oh yeah so in this case this was the

723
00:27:54,720 --> 00:27:57,919
just a router platform

724
00:27:56,159 --> 00:27:59,600
so it's everything is like always the

725
00:27:57,919 --> 00:28:01,919
same so you don't have to you don't

726
00:27:59,600 --> 00:28:04,240
change in configuration file if you need

727
00:28:01,919 --> 00:28:07,760
to upgrade the kernel for instance

728
00:28:04,240 --> 00:28:09,279
um yeah so what you upgrade in the

729
00:28:07,760 --> 00:28:12,879
kernel and you should like you just

730
00:28:09,279 --> 00:28:12,880
change you just replace the kernel

731
00:28:15,279 --> 00:28:19,279
yeah if the parameters change uh then

732
00:28:17,279 --> 00:28:22,159
yes so i assume in terms of

733
00:28:19,279 --> 00:28:23,039
if you have srtm uh then you should care

734
00:28:22,159 --> 00:28:25,120
about how

735
00:28:23,039 --> 00:28:27,039
you know i thought about the srtm

736
00:28:25,120 --> 00:28:27,760
problems here so you should care how to

737
00:28:27,039 --> 00:28:30,399
update

738
00:28:27,760 --> 00:28:32,080
your flash image with new configuration

739
00:28:30,399 --> 00:28:33,918
and which with new components but

740
00:28:32,080 --> 00:28:35,199
as i said this is a deeply embedded

741
00:28:33,919 --> 00:28:38,960
platform and

742
00:28:35,200 --> 00:28:38,960
we should not do that like often i

743
00:28:42,840 --> 00:28:45,840
believe

744
00:28:56,159 --> 00:29:00,080
yeah this is just the development kind

745
00:28:57,919 --> 00:29:02,559
of setup and just to prove that the

746
00:29:00,080 --> 00:29:03,199
dynamic route of trust part work we know

747
00:29:02,559 --> 00:29:06,000
that static

748
00:29:03,200 --> 00:29:07,840
of trust is problematic sorry about that

749
00:29:06,000 --> 00:29:13,840
we are out of time

750
00:29:07,840 --> 00:29:13,840
thank you thank you

