1
00:00:05,680 --> 00:00:08,160
okay

2
00:00:06,160 --> 00:00:09,280
next up for today please welcome aroma

3
00:00:08,160 --> 00:00:11,280
who's going to

4
00:00:09,280 --> 00:00:17,920
explain us what is reactive programming

5
00:00:11,280 --> 00:00:17,919
thank you

6
00:00:19,600 --> 00:00:25,599
hello everyone so my name is roman [ __ ]

7
00:00:23,359 --> 00:00:27,119
and i will talk about reactive

8
00:00:25,599 --> 00:00:30,640
programming

9
00:00:27,119 --> 00:00:33,440
so it's been a long day but please

10
00:00:30,640 --> 00:00:35,760
stay awake at least for the next 20

11
00:00:33,440 --> 00:00:35,760
minutes

12
00:00:36,800 --> 00:00:40,718
so the presentation will start with an

13
00:00:39,920 --> 00:00:42,960
introduction

14
00:00:40,719 --> 00:00:43,840
on reactive programming and more

15
00:00:42,960 --> 00:00:46,719
specifically

16
00:00:43,840 --> 00:00:50,000
reactivities then i will go through a

17
00:00:46,719 --> 00:00:52,160
simple example on how to use it

18
00:00:50,000 --> 00:00:54,879
and we'll see how to deal with errors

19
00:00:52,160 --> 00:00:56,640
and how to deal with concurrency

20
00:00:54,879 --> 00:00:58,239
and i will conclude with a more

21
00:00:56,640 --> 00:01:02,559
realistic example on

22
00:00:58,239 --> 00:01:02,559
how reactivix can be used

23
00:01:03,039 --> 00:01:06,720
in with something that we use to to

24
00:01:05,600 --> 00:01:09,919
deploy our

25
00:01:06,720 --> 00:01:12,080
machine learning models

26
00:01:09,920 --> 00:01:13,520
just before we start let me introduce

27
00:01:12,080 --> 00:01:16,240
myself so

28
00:01:13,520 --> 00:01:18,640
i'm a data scientist at soft at home on

29
00:01:16,240 --> 00:01:21,280
soft atom we're a medium-sized company

30
00:01:18,640 --> 00:01:22,799
where we develop firmwares for internet

31
00:01:21,280 --> 00:01:26,320
routers

32
00:01:22,799 --> 00:01:27,040
tv decoders and vocal assistants so most

33
00:01:26,320 --> 00:01:29,600
of

34
00:01:27,040 --> 00:01:30,560
our developers are embedded developers

35
00:01:29,600 --> 00:01:33,199
doing c and c

36
00:01:30,560 --> 00:01:36,159
plus plus but on my team we are doing

37
00:01:33,200 --> 00:01:38,560
almost exclusively python

38
00:01:36,159 --> 00:01:40,400
i'm also one of the developers of the

39
00:01:38,560 --> 00:01:43,520
eric spy library

40
00:01:40,400 --> 00:01:45,280
and i am also the author of a book on on

41
00:01:43,520 --> 00:01:48,240
this topic

42
00:01:45,280 --> 00:01:49,520
so let's go on the let's start with just

43
00:01:48,240 --> 00:01:51,360
a simple poll

44
00:01:49,520 --> 00:01:54,399
how many of you already used the

45
00:01:51,360 --> 00:01:55,439
reactive programming before raise your

46
00:01:54,399 --> 00:01:59,920
hand

47
00:01:55,439 --> 00:02:02,559
yeah five ten people okay that's great

48
00:01:59,920 --> 00:02:04,079
uh did you use reactivity for the few

49
00:02:02,560 --> 00:02:07,280
that used it

50
00:02:04,079 --> 00:02:09,758
no yes one maybe okay

51
00:02:07,280 --> 00:02:10,399
so you're the the correct audience for

52
00:02:09,758 --> 00:02:14,238
today

53
00:02:10,399 --> 00:02:17,599
for me that's fine so

54
00:02:14,239 --> 00:02:18,560
to to say it simply and maybe in a vague

55
00:02:17,599 --> 00:02:21,679
way

56
00:02:18,560 --> 00:02:25,120
reactive programming it's one way to

57
00:02:21,680 --> 00:02:27,120
write even driven code so it's a

58
00:02:25,120 --> 00:02:28,800
it's not really tied to a programming

59
00:02:27,120 --> 00:02:30,640
language or paradigm

60
00:02:28,800 --> 00:02:32,560
you can use it with imperative

61
00:02:30,640 --> 00:02:34,879
programming or object-oriented

62
00:02:32,560 --> 00:02:37,840
programming or functional programming

63
00:02:34,879 --> 00:02:40,319
you can use it with let's say almost any

64
00:02:37,840 --> 00:02:44,239
programming language

65
00:02:40,319 --> 00:02:47,359
it's really just a way to structure code

66
00:02:44,239 --> 00:02:48,959
and it's done in a way that you write a

67
00:02:47,360 --> 00:02:51,519
computation graph

68
00:02:48,959 --> 00:02:54,080
so on the right you have some some

69
00:02:51,519 --> 00:02:57,680
example of a graph that you can do

70
00:02:54,080 --> 00:02:58,400
and the nodes represent computations

71
00:02:57,680 --> 00:03:01,200
that are done

72
00:02:58,400 --> 00:03:03,200
transformations and the edges are

73
00:03:01,200 --> 00:03:06,480
represent a data flow

74
00:03:03,200 --> 00:03:09,200
so basically

75
00:03:06,480 --> 00:03:09,760
you just write a computation graph and

76
00:03:09,200 --> 00:03:12,238
the

77
00:03:09,760 --> 00:03:13,200
transformation will apply to each items

78
00:03:12,239 --> 00:03:16,480
that flow

79
00:03:13,200 --> 00:03:17,440
to uh to this stream of events so you

80
00:03:16,480 --> 00:03:20,319
can

81
00:03:17,440 --> 00:03:22,000
right acyclic graph like on the top but

82
00:03:20,319 --> 00:03:24,399
also cycle graph

83
00:03:22,000 --> 00:03:26,480
and in general when you have a real

84
00:03:24,400 --> 00:03:29,120
application you have buff in it

85
00:03:26,480 --> 00:03:30,238
you have it's mostly uh an acrylic graph

86
00:03:29,120 --> 00:03:33,360
but with some parts

87
00:03:30,239 --> 00:03:35,519
that contain some cycles reactivix is

88
00:03:33,360 --> 00:03:39,120
one of the most used libraries

89
00:03:35,519 --> 00:03:42,560
to uh well it's a very uh

90
00:03:39,120 --> 00:03:43,519
used one it was originally developed by

91
00:03:42,560 --> 00:03:46,959
microsoft

92
00:03:43,519 --> 00:03:49,200
and it's been open sourced in 2012

93
00:03:46,959 --> 00:03:52,080
and said since then it's been written in

94
00:03:49,200 --> 00:03:54,238
many different languages

95
00:03:52,080 --> 00:03:57,360
and the eric spy is the python

96
00:03:54,239 --> 00:04:00,319
implementation of reactivity

97
00:03:57,360 --> 00:04:01,760
last summer we released the version 3 of

98
00:04:00,319 --> 00:04:05,599
this library

99
00:04:01,760 --> 00:04:08,079
and it's a major release

100
00:04:05,599 --> 00:04:09,359
mainly due to the fact that we use the

101
00:04:08,080 --> 00:04:13,360
pipe operator

102
00:04:09,360 --> 00:04:16,000
you will see later what it means but

103
00:04:13,360 --> 00:04:17,680
the big thing is is that it makes it

104
00:04:16,000 --> 00:04:18,959
much more easy to write your own

105
00:04:17,680 --> 00:04:22,479
operators

106
00:04:18,959 --> 00:04:24,680
and to extend the library

107
00:04:22,479 --> 00:04:26,400
another great thing is that we have a

108
00:04:24,680 --> 00:04:28,560
documentation

109
00:04:26,400 --> 00:04:30,400
so that's fine that's really great

110
00:04:28,560 --> 00:04:31,840
because before you had to read the code

111
00:04:30,400 --> 00:04:34,159
to see how it works

112
00:04:31,840 --> 00:04:36,239
so now you can read the doc online so

113
00:04:34,160 --> 00:04:39,680
that's something that is really great

114
00:04:36,240 --> 00:04:40,800
i think and we dropped the support for

115
00:04:39,680 --> 00:04:43,840
python 2

116
00:04:40,800 --> 00:04:45,759
but anyway nobody's using it now i

117
00:04:43,840 --> 00:04:49,198
suppose

118
00:04:45,759 --> 00:04:49,199
so this shouldn't be an issue

119
00:04:49,919 --> 00:04:54,000
so if you want to understand what is

120
00:04:52,080 --> 00:04:57,120
reactivex you basically need to

121
00:04:54,000 --> 00:05:00,639
understand three things

122
00:04:57,120 --> 00:05:02,800
the first one is what is an observable

123
00:05:00,639 --> 00:05:04,720
an observable it's just another name for

124
00:05:02,800 --> 00:05:07,280
a stream of event

125
00:05:04,720 --> 00:05:09,840
and by the way we do not name events

126
00:05:07,280 --> 00:05:11,599
events but usually we name them items so

127
00:05:09,840 --> 00:05:15,280
an observable it's something that

128
00:05:11,600 --> 00:05:17,919
emits some items the second thing you

129
00:05:15,280 --> 00:05:21,758
have to know is what's an observer

130
00:05:17,919 --> 00:05:23,359
so if you use object-oriented

131
00:05:21,759 --> 00:05:26,000
programming you probably

132
00:05:23,360 --> 00:05:27,280
already heard this term and by the way

133
00:05:26,000 --> 00:05:30,160
it's

134
00:05:27,280 --> 00:05:32,559
the same meaning an observer it's an

135
00:05:30,160 --> 00:05:34,560
entity that will receive some items

136
00:05:32,560 --> 00:05:35,840
so it's some something that subscribes

137
00:05:34,560 --> 00:05:38,560
to an observable

138
00:05:35,840 --> 00:05:40,239
and will receive its time times by the

139
00:05:38,560 --> 00:05:43,120
way reactivates it's

140
00:05:40,240 --> 00:05:43,440
more or less the observer design pattern

141
00:05:43,120 --> 00:05:45,919
but

142
00:05:43,440 --> 00:05:48,479
implemented in a functional way instead

143
00:05:45,919 --> 00:05:51,440
of an object-oriented way

144
00:05:48,479 --> 00:05:52,639
and when you combine observables and

145
00:05:51,440 --> 00:05:56,160
observers

146
00:05:52,639 --> 00:05:56,960
you can write operators so an operator

147
00:05:56,160 --> 00:05:59,039
is

148
00:05:56,960 --> 00:06:00,799
a transformation that is done on the

149
00:05:59,039 --> 00:06:03,919
events that are

150
00:06:00,800 --> 00:06:07,520
emitted by the observables

151
00:06:03,919 --> 00:06:11,599
so let's see with an example

152
00:06:07,520 --> 00:06:14,400
so this is what we call a marble diagram

153
00:06:11,600 --> 00:06:14,800
it's similar to a uml sequence diagram

154
00:06:14,400 --> 00:06:17,919
but

155
00:06:14,800 --> 00:06:19,360
rotated so the arrows represent

156
00:06:17,919 --> 00:06:21,520
observables

157
00:06:19,360 --> 00:06:22,880
so here on the top there's an observable

158
00:06:21,520 --> 00:06:26,159
that emits items

159
00:06:22,880 --> 00:06:29,600
one two three and four

160
00:06:26,160 --> 00:06:32,720
the rectangles represent the operator

161
00:06:29,600 --> 00:06:34,880
so here it's the map operator and the

162
00:06:32,720 --> 00:06:36,080
map operator takes a function as a

163
00:06:34,880 --> 00:06:39,039
parameter

164
00:06:36,080 --> 00:06:39,520
and it applies this function to each

165
00:06:39,039 --> 00:06:43,360
item

166
00:06:39,520 --> 00:06:46,318
that is received so in this example

167
00:06:43,360 --> 00:06:46,720
the function just decrease the value so

168
00:06:46,319 --> 00:06:49,440
when

169
00:06:46,720 --> 00:06:50,639
item one is emitted it goes through the

170
00:06:49,440 --> 00:06:52,160
map operator

171
00:06:50,639 --> 00:06:54,639
the value is decreased on the map

172
00:06:52,160 --> 00:06:57,440
operator emits on a new observable

173
00:06:54,639 --> 00:06:58,479
the value zero and so we have this for

174
00:06:57,440 --> 00:07:01,440
all items

175
00:06:58,479 --> 00:07:03,199
that are emitted by the the observer

176
00:07:01,440 --> 00:07:05,520
sorry the observable

177
00:07:03,199 --> 00:07:06,720
and so on this example at vm the map

178
00:07:05,520 --> 00:07:10,560
operator emits

179
00:07:06,720 --> 00:07:11,599
zero one two three the nice thing here

180
00:07:10,560 --> 00:07:15,759
is that

181
00:07:11,599 --> 00:07:17,919
the type of the input it's an observable

182
00:07:15,759 --> 00:07:19,039
but the type of the output it's also an

183
00:07:17,919 --> 00:07:22,400
observable

184
00:07:19,039 --> 00:07:25,039
so operators take observables as

185
00:07:22,400 --> 00:07:26,638
inputs and also as output so this is

186
00:07:25,039 --> 00:07:29,759
what makes them

187
00:07:26,639 --> 00:07:30,560
easy to plug them together and basically

188
00:07:29,759 --> 00:07:33,680
when you write

189
00:07:30,560 --> 00:07:36,880
a reactivity application you just

190
00:07:33,680 --> 00:07:37,840
plug in many observe many operators

191
00:07:36,880 --> 00:07:39,599
together

192
00:07:37,840 --> 00:07:42,080
and that's how you write your

193
00:07:39,599 --> 00:07:45,520
computation graph

194
00:07:42,080 --> 00:07:48,080
so let's see with an example we'll write

195
00:07:45,520 --> 00:07:50,159
very simple graph where we will chain

196
00:07:48,080 --> 00:07:53,120
only two operators

197
00:07:50,160 --> 00:07:55,680
so this is another kind of diagram that

198
00:07:53,120 --> 00:07:59,680
i call a reactivity diagram

199
00:07:55,680 --> 00:08:01,759
it's inspired from uml activity diagrams

200
00:07:59,680 --> 00:08:03,039
but the meaning is different in an

201
00:08:01,759 --> 00:08:06,240
activity diagram

202
00:08:03,039 --> 00:08:09,840
you represent the code flow here

203
00:08:06,240 --> 00:08:12,080
the the diagram represents a data flow

204
00:08:09,840 --> 00:08:12,960
so on the top you have a source

205
00:08:12,080 --> 00:08:15,919
observable

206
00:08:12,960 --> 00:08:16,560
the the black dot represents a source

207
00:08:15,919 --> 00:08:19,840
and

208
00:08:16,560 --> 00:08:21,840
the items will flow through it

209
00:08:19,840 --> 00:08:23,758
it will we will first use the map

210
00:08:21,840 --> 00:08:25,919
operator to decrease the values

211
00:08:23,759 --> 00:08:27,840
of items that are emitted and then we

212
00:08:25,919 --> 00:08:30,960
will use the filter operator

213
00:08:27,840 --> 00:08:33,120
to keep only the even values and then

214
00:08:30,960 --> 00:08:34,399
the result will be an observable that

215
00:08:33,120 --> 00:08:38,000
emits the result of

216
00:08:34,399 --> 00:08:40,080
these two transformations so

217
00:08:38,000 --> 00:08:42,240
this program is something that does not

218
00:08:40,080 --> 00:08:45,440
really have a start on an end

219
00:08:42,240 --> 00:08:48,480
time wise it will uh start when the

220
00:08:45,440 --> 00:08:50,880
the observables is uh started

221
00:08:48,480 --> 00:08:51,839
and it will end only if the source

222
00:08:50,880 --> 00:08:54,640
observable

223
00:08:51,839 --> 00:08:55,839
finishes at some time which may not be

224
00:08:54,640 --> 00:08:58,880
the case

225
00:08:55,839 --> 00:09:02,080
depending on the source that we use so

226
00:08:58,880 --> 00:09:04,480
let's see this river some code

227
00:09:02,080 --> 00:09:07,360
so we start with a few imports to get

228
00:09:04,480 --> 00:09:07,360
the reactivity

229
00:09:07,519 --> 00:09:12,000
models loaded there's one for the all

230
00:09:10,000 --> 00:09:14,240
the base functions another

231
00:09:12,000 --> 00:09:17,120
another one dedicated for to get all the

232
00:09:14,240 --> 00:09:19,440
operators that are available

233
00:09:17,120 --> 00:09:20,880
we create an observable in this case

234
00:09:19,440 --> 00:09:23,920
from a list

235
00:09:20,880 --> 00:09:27,760
so in a real case usually the source is

236
00:09:23,920 --> 00:09:30,079
something that comes from an i o uh

237
00:09:27,760 --> 00:09:30,800
like a network connection or it could be

238
00:09:30,080 --> 00:09:33,760
uh some

239
00:09:30,800 --> 00:09:35,760
a timer that will tick every every

240
00:09:33,760 --> 00:09:37,839
second or things like that or it can be

241
00:09:35,760 --> 00:09:40,480
a user input from a ui

242
00:09:37,839 --> 00:09:41,440
but here for an example we create a

243
00:09:40,480 --> 00:09:44,320
hard-coded

244
00:09:41,440 --> 00:09:46,800
observable that will emit items one two

245
00:09:44,320 --> 00:09:46,800
three four

246
00:09:46,959 --> 00:09:51,920
then we will declare the computation

247
00:09:50,480 --> 00:09:54,800
graph that we want to do

248
00:09:51,920 --> 00:09:56,640
on this observable so this is where we

249
00:09:54,800 --> 00:09:59,439
use the pipe method

250
00:09:56,640 --> 00:10:00,080
on the source observable and we will

251
00:09:59,440 --> 00:10:03,279
just

252
00:10:00,080 --> 00:10:04,560
chain the map operator and the filter

253
00:10:03,279 --> 00:10:06,720
operator

254
00:10:04,560 --> 00:10:08,640
so on the map operator we tell it to

255
00:10:06,720 --> 00:10:11,360
decrease the value for each item

256
00:10:08,640 --> 00:10:12,640
that are emitted and then the filter

257
00:10:11,360 --> 00:10:15,519
operator

258
00:10:12,640 --> 00:10:20,000
we tell it to keep only the even values

259
00:10:15,519 --> 00:10:23,279
so the values whose modulus 2 is 0.

260
00:10:20,000 --> 00:10:26,240
the result of this column

261
00:10:23,279 --> 00:10:27,120
is also unobservable so what source.pipe

262
00:10:26,240 --> 00:10:30,480
returns

263
00:10:27,120 --> 00:10:31,519
it's also an observable so if i run it

264
00:10:30,480 --> 00:10:34,160
this way

265
00:10:31,519 --> 00:10:35,200
nothing happens because we just have

266
00:10:34,160 --> 00:10:37,360
something that

267
00:10:35,200 --> 00:10:38,880
created observables but nothing is

268
00:10:37,360 --> 00:10:41,360
executed yet

269
00:10:38,880 --> 00:10:44,079
we just declared the complete

270
00:10:41,360 --> 00:10:47,200
computation graph that we want to do

271
00:10:44,079 --> 00:10:48,719
so observables are lazy they only emit

272
00:10:47,200 --> 00:10:51,680
items when somebody

273
00:10:48,720 --> 00:10:53,200
subscribes to them so that we what we

274
00:10:51,680 --> 00:10:57,120
have to do next

275
00:10:53,200 --> 00:11:00,320
we subscribe to this observable

276
00:10:57,120 --> 00:11:03,440
and in our case we just print each value

277
00:11:00,320 --> 00:11:06,160
that that is emitted at the end so

278
00:11:03,440 --> 00:11:07,839
we used the on next callback to in our

279
00:11:06,160 --> 00:11:09,439
case print the value

280
00:11:07,839 --> 00:11:11,040
and there are two of the callbacks that

281
00:11:09,440 --> 00:11:14,000
are available to be notified

282
00:11:11,040 --> 00:11:15,680
when the observable completes or when an

283
00:11:14,000 --> 00:11:18,240
error occurs

284
00:11:15,680 --> 00:11:19,760
and this subscription function returns a

285
00:11:18,240 --> 00:11:22,320
disposable object

286
00:11:19,760 --> 00:11:24,560
that can be used to unsubscribe from the

287
00:11:22,320 --> 00:11:28,079
observable

288
00:11:24,560 --> 00:11:28,959
so that's all here we've got our first

289
00:11:28,079 --> 00:11:30,880
sample

290
00:11:28,959 --> 00:11:33,839
but with almost everything that you have

291
00:11:30,880 --> 00:11:37,120
to know to write a reactive code

292
00:11:33,839 --> 00:11:38,880
so if you execute this

293
00:11:37,120 --> 00:11:40,560
the source observable will start

294
00:11:38,880 --> 00:11:42,480
emitting item one

295
00:11:40,560 --> 00:11:44,239
it will go through the map operator that

296
00:11:42,480 --> 00:11:47,680
will decrease the value

297
00:11:44,240 --> 00:11:49,760
so the item becomes becomes zero

298
00:11:47,680 --> 00:11:51,839
then it goes for the filter operator

299
00:11:49,760 --> 00:11:54,240
zero is an even value so it will be

300
00:11:51,839 --> 00:11:56,639
printed on the subscription callback

301
00:11:54,240 --> 00:11:57,680
then item two is emitted two minus one

302
00:11:56,639 --> 00:12:00,079
it's one

303
00:11:57,680 --> 00:12:03,040
one is not an even value so it will be

304
00:12:00,079 --> 00:12:05,439
dropped and nothing will be printed

305
00:12:03,040 --> 00:12:08,000
then three is emitted three minus one is

306
00:12:05,440 --> 00:12:08,639
two two is an even value so two will be

307
00:12:08,000 --> 00:12:10,639
printed

308
00:12:08,639 --> 00:12:12,880
and four is emitted four minus one it's

309
00:12:10,639 --> 00:12:14,320
free three is not an even value so it

310
00:12:12,880 --> 00:12:17,839
will also be dropped

311
00:12:14,320 --> 00:12:17,839
so you've got this at the end

312
00:12:18,240 --> 00:12:23,120
pretty simple but the important thing

313
00:12:21,839 --> 00:12:25,920
here is that

314
00:12:23,120 --> 00:12:27,200
as you can see you have smaller

315
00:12:25,920 --> 00:12:29,360
computation blocks

316
00:12:27,200 --> 00:12:30,959
and the power comes from the combination

317
00:12:29,360 --> 00:12:33,920
of them you can

318
00:12:30,959 --> 00:12:35,518
combine they combine them in many ways

319
00:12:33,920 --> 00:12:38,560
and build really complex

320
00:12:35,519 --> 00:12:39,040
graphs with complex computations in a

321
00:12:38,560 --> 00:12:42,000
quite

322
00:12:39,040 --> 00:12:45,360
easy way with events that that are

323
00:12:42,000 --> 00:12:45,360
asynchronous by nature

324
00:12:45,519 --> 00:12:52,160
so what it what we did here

325
00:12:48,639 --> 00:12:56,240
was simple and it seems that

326
00:12:52,160 --> 00:12:59,360
it's uh too simple to be uh realistic

327
00:12:56,240 --> 00:13:02,720
realistic uh but in fact

328
00:12:59,360 --> 00:13:06,320
when we connected our two obser

329
00:13:02,720 --> 00:13:09,760
two operators together we did not

330
00:13:06,320 --> 00:13:10,959
made a single connection so that's one

331
00:13:09,760 --> 00:13:14,480
important thing

332
00:13:10,959 --> 00:13:18,079
to know and it's an interesting thing to

333
00:13:14,480 --> 00:13:20,399
handle errors with a reactive x

334
00:13:18,079 --> 00:13:21,680
so basically when we connect operators

335
00:13:20,399 --> 00:13:24,320
together

336
00:13:21,680 --> 00:13:25,760
there are two connections that are done

337
00:13:24,320 --> 00:13:28,480
there's one uh

338
00:13:25,760 --> 00:13:29,519
one happy path where the items are

339
00:13:28,480 --> 00:13:32,800
emitted

340
00:13:29,519 --> 00:13:35,760
so if everything goes well the items

341
00:13:32,800 --> 00:13:36,479
flow through the happy pass so the map

342
00:13:35,760 --> 00:13:39,360
operator

343
00:13:36,480 --> 00:13:41,040
takes items from the happy pass and i'll

344
00:13:39,360 --> 00:13:43,920
put them on it

345
00:13:41,040 --> 00:13:44,719
as well as the filter one but if

346
00:13:43,920 --> 00:13:47,360
anything

347
00:13:44,720 --> 00:13:48,320
wrong happens there's also a failure

348
00:13:47,360 --> 00:13:51,120
path

349
00:13:48,320 --> 00:13:53,360
that allows to propagate errors and stop

350
00:13:51,120 --> 00:13:56,399
all the data flow

351
00:13:53,360 --> 00:13:58,800
so typically if there's an error that

352
00:13:56,399 --> 00:14:00,959
occurs in the map operator

353
00:13:58,800 --> 00:14:02,000
this error will not propagate through

354
00:14:00,959 --> 00:14:04,560
the happy path but

355
00:14:02,000 --> 00:14:06,399
through the error path and then all

356
00:14:04,560 --> 00:14:09,199
operators that are after

357
00:14:06,399 --> 00:14:10,720
in the graph can handle this error in a

358
00:14:09,199 --> 00:14:14,839
graceful way

359
00:14:10,720 --> 00:14:17,839
and do more or less complex things on it

360
00:14:14,839 --> 00:14:20,160
so this means that with

361
00:14:17,839 --> 00:14:22,240
what we've just implemented with no

362
00:14:20,160 --> 00:14:25,600
special logic to handle errors

363
00:14:22,240 --> 00:14:28,839
it natively handles them so

364
00:14:25,600 --> 00:14:30,079
for example if we replace our source

365
00:14:28,839 --> 00:14:34,160
observable

366
00:14:30,079 --> 00:14:36,638
and the second item will replace

367
00:14:34,160 --> 00:14:37,760
the integer with a string something

368
00:14:36,639 --> 00:14:40,320
wrong will happen

369
00:14:37,760 --> 00:14:41,199
because on the map operator we will try

370
00:14:40,320 --> 00:14:43,040
to decrease

371
00:14:41,199 --> 00:14:44,399
a string and this is not allowed in

372
00:14:43,040 --> 00:14:48,160
python

373
00:14:44,399 --> 00:14:50,639
so what happens is just this

374
00:14:48,160 --> 00:14:52,160
we first get the item one that is

375
00:14:50,639 --> 00:14:55,360
emitted and decreased

376
00:14:52,160 --> 00:14:56,000
this works well but when the string is

377
00:14:55,360 --> 00:14:59,040
emitted

378
00:14:56,000 --> 00:15:00,160
the map operator raises an exception and

379
00:14:59,040 --> 00:15:01,839
this exception

380
00:15:00,160 --> 00:15:04,319
is propagated through the filter

381
00:15:01,839 --> 00:15:06,160
operator in this case

382
00:15:04,320 --> 00:15:07,600
the filter operator does nothing but

383
00:15:06,160 --> 00:15:10,560
just forwards it

384
00:15:07,600 --> 00:15:12,480
and it goes up until the subscription

385
00:15:10,560 --> 00:15:16,399
error callback

386
00:15:12,480 --> 00:15:20,240
and after that nothing happens because

387
00:15:16,399 --> 00:15:23,360
once an observable has completed

388
00:15:20,240 --> 00:15:26,560
either on success or unfailure there's

389
00:15:23,360 --> 00:15:29,199
no items that can flow after that

390
00:15:26,560 --> 00:15:30,160
so that's why we don't have the value

391
00:15:29,199 --> 00:15:33,680
two that is

392
00:15:30,160 --> 00:15:37,519
emitted after that so that's one

393
00:15:33,680 --> 00:15:40,079
simple case but it's one of the

394
00:15:37,519 --> 00:15:42,079
very usual way to handle errors there's

395
00:15:40,079 --> 00:15:43,199
something wrong we do something and we

396
00:15:42,079 --> 00:15:45,680
just sub the

397
00:15:43,199 --> 00:15:45,680
program

398
00:15:46,240 --> 00:15:50,639
there are some other operators that are

399
00:15:48,639 --> 00:15:51,759
available to do more complex things on

400
00:15:50,639 --> 00:15:54,240
errors

401
00:15:51,759 --> 00:15:55,360
but that's really the base way of how

402
00:15:54,240 --> 00:15:58,639
it's managed until

403
00:15:55,360 --> 00:16:02,000
it allows to handle many cases

404
00:15:58,639 --> 00:16:05,600
already and in an easy way

405
00:16:02,000 --> 00:16:08,480
another thing that can be done with

406
00:16:05,600 --> 00:16:09,040
with eric spy on reactivity is an easy

407
00:16:08,480 --> 00:16:12,000
way to

408
00:16:09,040 --> 00:16:12,719
deal with concurrency so this is done

409
00:16:12,000 --> 00:16:16,079
with what

410
00:16:12,720 --> 00:16:18,240
we call schedulers so you can handle

411
00:16:16,079 --> 00:16:21,680
different types of concurrency

412
00:16:18,240 --> 00:16:24,800
cpu concurrency with a thread pools or

413
00:16:21,680 --> 00:16:27,279
threads that are created on demand we

414
00:16:24,800 --> 00:16:29,758
can also deal with io concurrency

415
00:16:27,279 --> 00:16:30,480
we support several kinds of uh event

416
00:16:29,759 --> 00:16:33,279
loops

417
00:16:30,480 --> 00:16:33,759
such as that sync io but also some other

418
00:16:33,279 --> 00:16:36,560
ones

419
00:16:33,759 --> 00:16:38,720
like twisted g event and there's also

420
00:16:36,560 --> 00:16:41,359
some built-in support for

421
00:16:38,720 --> 00:16:42,320
several frameworks that have main loops

422
00:16:41,360 --> 00:16:46,079
such as qt

423
00:16:42,320 --> 00:16:46,079
and gtk so

424
00:16:46,160 --> 00:16:49,279
the thing that is interesting here also

425
00:16:48,480 --> 00:16:51,759
just like

426
00:16:49,279 --> 00:16:52,720
most of the things in reactivity

427
00:16:51,759 --> 00:16:55,759
reactivities

428
00:16:52,720 --> 00:16:57,199
is that it's extensible so you can write

429
00:16:55,759 --> 00:16:59,600
your own schedulers and

430
00:16:57,199 --> 00:17:01,120
do other kinds of scheduling if you if

431
00:16:59,600 --> 00:17:03,440
you need it

432
00:17:01,120 --> 00:17:05,679
i don't have an example here because it

433
00:17:03,440 --> 00:17:07,360
would use too much time

434
00:17:05,679 --> 00:17:08,959
but you can see on the documentation

435
00:17:07,359 --> 00:17:11,839
there are many examples on

436
00:17:08,959 --> 00:17:11,839
how to use it

437
00:17:12,799 --> 00:17:20,160
so how can we use it in real life

438
00:17:16,640 --> 00:17:22,640
that's a typical example on how my team

439
00:17:20,160 --> 00:17:27,199
deploy machine learning model on our

440
00:17:22,640 --> 00:17:30,480
back end so each model is deployed

441
00:17:27,199 --> 00:17:33,520
as a docker container and

442
00:17:30,480 --> 00:17:34,880
we use pi as the as an interpreter we

443
00:17:33,520 --> 00:17:37,760
use async io for

444
00:17:34,880 --> 00:17:38,400
all the input output management we use

445
00:17:37,760 --> 00:17:41,280
rx pi

446
00:17:38,400 --> 00:17:43,280
for all the feature engineering and the

447
00:17:41,280 --> 00:17:45,440
model execution

448
00:17:43,280 --> 00:17:47,678
and we use another small framework that

449
00:17:45,440 --> 00:17:51,679
is called cyclocyclotron that

450
00:17:47,679 --> 00:17:55,760
is used to separate the ios from the

451
00:17:51,679 --> 00:17:57,760
the data flow so this is the case where

452
00:17:55,760 --> 00:18:00,240
everything works really well together

453
00:17:57,760 --> 00:18:00,799
because we on our back end we use kafka

454
00:18:00,240 --> 00:18:05,919
as a

455
00:18:00,799 --> 00:18:07,760
as an event as a source on the

456
00:18:05,919 --> 00:18:09,919
destination on events so everything that

457
00:18:07,760 --> 00:18:12,080
we do we read events from kafka

458
00:18:09,919 --> 00:18:13,440
we do some computation and we write the

459
00:18:12,080 --> 00:18:16,879
result to kafka

460
00:18:13,440 --> 00:18:20,160
and we have many micro services that are

461
00:18:16,880 --> 00:18:23,600
chained together this way so

462
00:18:20,160 --> 00:18:27,520
on a typical deployment we have

463
00:18:23,600 --> 00:18:28,480
our service that runs with a rx pipe for

464
00:18:27,520 --> 00:18:30,879
the relied

465
00:18:28,480 --> 00:18:31,600
computation part it receives events from

466
00:18:30,880 --> 00:18:34,480
kefka

467
00:18:31,600 --> 00:18:37,280
with io kafka so we have a kafka

468
00:18:34,480 --> 00:18:40,840
consumer that is done with async iu

469
00:18:37,280 --> 00:18:43,120
it receives some configuration with a

470
00:18:40,840 --> 00:18:45,360
consular consul it's it's a tool that

471
00:18:43,120 --> 00:18:50,000
allows to deal with configuration

472
00:18:45,360 --> 00:18:52,159
and it's uh exposed via rest apis

473
00:18:50,000 --> 00:18:54,640
the result of the computation there is

474
00:18:52,160 --> 00:18:57,840
exposed on a kafka topic

475
00:18:54,640 --> 00:18:57,840
and we also exposed some

476
00:18:58,240 --> 00:19:06,400
operational metrics with promoters

477
00:19:01,600 --> 00:19:09,360
and so this is an example that

478
00:19:06,400 --> 00:19:11,280
is simple but it can deal with quite

479
00:19:09,360 --> 00:19:13,360
complex ways

480
00:19:11,280 --> 00:19:16,080
because the cast castles here there's a

481
00:19:13,360 --> 00:19:17,439
single arrow but it can be a combination

482
00:19:16,080 --> 00:19:19,760
of several topics

483
00:19:17,440 --> 00:19:21,360
so we can read many topics at the same

484
00:19:19,760 --> 00:19:26,720
time combine them together

485
00:19:21,360 --> 00:19:26,719
with rxpy and do all our computation

486
00:19:26,880 --> 00:19:31,280
and this is a case where all these

487
00:19:28,960 --> 00:19:34,480
elements fit very well together

488
00:19:31,280 --> 00:19:36,000
kafka with async io and eric spy it's

489
00:19:34,480 --> 00:19:38,240
really things that

490
00:19:36,000 --> 00:19:40,559
do a great thing with each part each

491
00:19:38,240 --> 00:19:40,559
other

492
00:19:40,880 --> 00:19:47,440
so that's all for me if you want more

493
00:19:44,320 --> 00:19:49,600
on this you can just play with it you

494
00:19:47,440 --> 00:19:52,000
just pimp install eric's and you've got

495
00:19:49,600 --> 00:19:54,159
it the documentation is available

496
00:19:52,000 --> 00:19:57,360
on red the duck you've got some more

497
00:19:54,160 --> 00:20:00,480
generic information on reactivity

498
00:19:57,360 --> 00:20:02,080
reactivities and i also added a link to

499
00:20:00,480 --> 00:20:05,120
a presentation by

500
00:20:02,080 --> 00:20:06,320
scott bleschling for the all the error

501
00:20:05,120 --> 00:20:09,678
management on the

502
00:20:06,320 --> 00:20:12,480
railway analogy this is really a great

503
00:20:09,679 --> 00:20:14,240
talk that he did a few years ago

504
00:20:12,480 --> 00:20:16,720
i suggest that you read it if you're

505
00:20:14,240 --> 00:20:20,820
interested in the topic

506
00:20:16,720 --> 00:20:26,559
thank you very much

507
00:20:20,820 --> 00:20:28,639
[Applause]

508
00:20:26,559 --> 00:20:30,799
don't be shy with the question the first

509
00:20:28,640 --> 00:20:31,600
three people asking questions we have a

510
00:20:30,799 --> 00:20:36,000
copy

511
00:20:31,600 --> 00:20:39,520
of my book does it

512
00:20:36,000 --> 00:20:39,520
does it support michael python

513
00:20:40,480 --> 00:20:45,840
i did not try it okay let's talk

514
00:20:43,440 --> 00:20:45,840
together

515
00:20:45,919 --> 00:20:51,440
i have done something with reactive

516
00:20:47,760 --> 00:20:53,440
programming but i had to use the rx lua

517
00:20:51,440 --> 00:20:54,960
and i wanted to switch to rx pi with my

518
00:20:53,440 --> 00:20:57,760
compiler so

519
00:20:54,960 --> 00:21:00,840
sorry i didn't hear the so the the first

520
00:20:57,760 --> 00:21:03,840
question was that does it support nitro

521
00:21:00,840 --> 00:21:03,840
python

522
00:21:06,240 --> 00:21:11,440
please so

523
00:21:09,280 --> 00:21:13,280
the question was does it support micro

524
00:21:11,440 --> 00:21:17,840
python

525
00:21:13,280 --> 00:21:17,840
that's that's it

526
00:21:20,159 --> 00:21:24,960
yeah his question was does it support

527
00:21:21,679 --> 00:21:28,000
micro python yes i didn't try it but

528
00:21:24,960 --> 00:21:28,559
from what i saw on micro python it may

529
00:21:28,000 --> 00:21:30,400
work

530
00:21:28,559 --> 00:21:32,480
i i'm not sure that there are things

531
00:21:30,400 --> 00:21:33,200
that are not supported by it that should

532
00:21:32,480 --> 00:21:36,720
not work

533
00:21:33,200 --> 00:21:36,720
but i didn't then test it

534
00:21:42,840 --> 00:21:48,639
yeah so um

535
00:21:45,520 --> 00:21:49,600
i have two questions please so what you

536
00:21:48,640 --> 00:21:52,080
showed us

537
00:21:49,600 --> 00:21:53,600
i think in slide 14 it was a contrived

538
00:21:52,080 --> 00:21:58,158
example that you have the

539
00:21:53,600 --> 00:22:00,879
premade data source

540
00:21:58,159 --> 00:22:02,000
uh you had pre-made data source which is

541
00:22:00,880 --> 00:22:04,720
a

542
00:22:02,000 --> 00:22:04,720
static list

543
00:22:05,890 --> 00:22:09,919
[Music]

544
00:22:07,280 --> 00:22:11,120
so my question is what is the main the

545
00:22:09,919 --> 00:22:14,080
default

546
00:22:11,120 --> 00:22:16,158
execution model is it async no the

547
00:22:14,080 --> 00:22:19,520
default model execution is

548
00:22:16,159 --> 00:22:22,880
everything is running on the on the

549
00:22:19,520 --> 00:22:25,840
interpreter main thread but then

550
00:22:22,880 --> 00:22:27,280
you can change it and use anything you

551
00:22:25,840 --> 00:22:31,120
even clue for a

552
00:22:27,280 --> 00:22:31,120
acuity event if you want

553
00:22:31,520 --> 00:22:41,840
so we can talk after

554
00:22:47,760 --> 00:22:51,360
so my question is what would you

555
00:22:49,039 --> 00:22:52,080
recommend to manage complexity of large

556
00:22:51,360 --> 00:22:53,520
pipelines

557
00:22:52,080 --> 00:22:55,199
it's all great when you write through

558
00:22:53,520 --> 00:22:57,120
two or three steps in a pipeline

559
00:22:55,200 --> 00:22:59,200
but it gets very large like 15 20

560
00:22:57,120 --> 00:23:01,678
elements and half a year passes you need

561
00:22:59,200 --> 00:23:04,799
to adjust something in seventh step

562
00:23:01,679 --> 00:23:07,280
how do you manage complexity yeah

563
00:23:04,799 --> 00:23:09,280
the way to manage complexity with this

564
00:23:07,280 --> 00:23:12,240
kind of code is the same one than

565
00:23:09,280 --> 00:23:12,879
a usual way so you split your code in

566
00:23:12,240 --> 00:23:16,720
many

567
00:23:12,880 --> 00:23:18,240
small functions that wrap smaller pieces

568
00:23:16,720 --> 00:23:21,360
of operations

569
00:23:18,240 --> 00:23:22,159
and so that you get some really you use

570
00:23:21,360 --> 00:23:24,080
composition

571
00:23:22,159 --> 00:23:25,360
to get some small elements that are

572
00:23:24,080 --> 00:23:28,080
combined together

573
00:23:25,360 --> 00:23:29,678
so at the end you you have one graph

574
00:23:28,080 --> 00:23:32,000
that should stay simple

575
00:23:29,679 --> 00:23:32,880
but each element in it is also another

576
00:23:32,000 --> 00:23:35,200
graph that has

577
00:23:32,880 --> 00:23:37,200
over computation and you can deal it

578
00:23:35,200 --> 00:23:39,440
with with it this way

579
00:23:37,200 --> 00:23:40,880
you have to compose all the operators

580
00:23:39,440 --> 00:23:44,480
together to do higher

581
00:23:40,880 --> 00:23:47,919
level computation otherwise yes you can

582
00:23:44,480 --> 00:23:51,840
quickly get a very big things on the

583
00:23:47,919 --> 00:23:51,840
hard to manage

584
00:23:52,559 --> 00:23:55,678
how do you deal with

585
00:23:56,559 --> 00:24:01,678
how do you deal with concurrency access

586
00:23:59,840 --> 00:24:02,840
to a data structure between the

587
00:24:01,679 --> 00:24:05,679
different

588
00:24:02,840 --> 00:24:08,799
pipelines conquered

589
00:24:05,679 --> 00:24:12,400
concurrency is not it's

590
00:24:08,799 --> 00:24:14,960
it's managed via schedulers so

591
00:24:12,400 --> 00:24:16,559
the each each operator does not handle

592
00:24:14,960 --> 00:24:19,679
concurrency in itself so

593
00:24:16,559 --> 00:24:21,440
it assumes that everything is executing

594
00:24:19,679 --> 00:24:25,279
on the same

595
00:24:21,440 --> 00:24:26,960
thread yes but if you need to combine

596
00:24:25,279 --> 00:24:29,440
things that can come from

597
00:24:26,960 --> 00:24:31,600
multiple threads there are some

598
00:24:29,440 --> 00:24:34,799
schedulers that are dedicated to it

599
00:24:31,600 --> 00:24:37,840
and that can serialize access

600
00:24:34,799 --> 00:24:41,039
to to then the the next step of

601
00:24:37,840 --> 00:24:44,840
the computation graph

602
00:24:41,039 --> 00:24:47,840
you have to combine the inputs in some

603
00:24:44,840 --> 00:24:47,840
ways

604
00:24:48,799 --> 00:24:50,879
you

