1
00:00:05,839 --> 00:00:08,880
yes

2
00:00:06,720 --> 00:00:10,800
hi everyone this is the first talk here

3
00:00:08,880 --> 00:00:13,280
at the kotlin dev room

4
00:00:10,800 --> 00:00:14,719
uh it's the first time for me at foster

5
00:00:13,280 --> 00:00:15,759
so a little bit excited about that as

6
00:00:14,719 --> 00:00:19,279
well

7
00:00:15,759 --> 00:00:20,640
my name is eric hellman i am

8
00:00:19,279 --> 00:00:23,920
working as a freelance software

9
00:00:20,640 --> 00:00:25,519
developer back home in stockholm sweden

10
00:00:23,920 --> 00:00:27,680
i've been using kotlin for quite some

11
00:00:25,519 --> 00:00:29,278
time but mostly i've been

12
00:00:27,680 --> 00:00:31,039
doing android development for the last

13
00:00:29,279 --> 00:00:33,840
couple of years

14
00:00:31,039 --> 00:00:34,239
so this talk is about co co routines

15
00:00:33,840 --> 00:00:37,760
with

16
00:00:34,239 --> 00:00:39,120
android i'm not going to go into the

17
00:00:37,760 --> 00:00:40,399
very deep

18
00:00:39,120 --> 00:00:42,320
the core routine parts they're going to

19
00:00:40,399 --> 00:00:44,320
be plenty of those talks here today

20
00:00:42,320 --> 00:00:46,320
this is about how do you use core

21
00:00:44,320 --> 00:00:49,520
routines on android

22
00:00:46,320 --> 00:00:51,360
efficiently and in a smart way

23
00:00:49,520 --> 00:00:54,399
so just quick raise of hands how many

24
00:00:51,360 --> 00:00:57,120
here do any android development

25
00:00:54,399 --> 00:00:57,680
almost everyone that's nice okay so that

26
00:00:57,120 --> 00:01:00,800
will be

27
00:00:57,680 --> 00:01:02,960
useful for hopefully um

28
00:01:00,800 --> 00:01:05,360
let's do one more how many here use co

29
00:01:02,960 --> 00:01:08,799
routines in their android applications

30
00:01:05,360 --> 00:01:10,880
a little bit less okay good i picked the

31
00:01:08,799 --> 00:01:13,680
right topic

32
00:01:10,880 --> 00:01:14,240
so you can find um more information

33
00:01:13,680 --> 00:01:16,080
about me

34
00:01:14,240 --> 00:01:18,798
the some of the source code i am showing

35
00:01:16,080 --> 00:01:20,400
today uh on my github account

36
00:01:18,799 --> 00:01:22,799
i have a blog post that covers part of

37
00:01:20,400 --> 00:01:24,880
what i'm going to talk about today

38
00:01:22,799 --> 00:01:26,000
but most of all on speaker deck slash

39
00:01:24,880 --> 00:01:29,119
eric hellman eric

40
00:01:26,000 --> 00:01:32,400
with a k you will find these slides

41
00:01:29,119 --> 00:01:35,520
already i've uploaded them there

42
00:01:32,400 --> 00:01:35,520
so yeah let's get started

43
00:01:37,840 --> 00:01:41,600
so you probably heard this one before uh

44
00:01:40,400 --> 00:01:44,399
kotlin co-routines

45
00:01:41,600 --> 00:01:46,079
are lightweight threads that's how jeff

46
00:01:44,399 --> 00:01:48,640
prince describes it themselves

47
00:01:46,079 --> 00:01:49,679
but what does it really mean for those

48
00:01:48,640 --> 00:01:51,920
of you who have

49
00:01:49,680 --> 00:01:52,799
been using it you know that it's very

50
00:01:51,920 --> 00:01:54,960
easy and

51
00:01:52,799 --> 00:01:56,640
cheap to start the core routine it

52
00:01:54,960 --> 00:01:58,158
doesn't cost very much compared to

53
00:01:56,640 --> 00:02:02,159
starting a thread

54
00:01:58,159 --> 00:02:04,079
so they have a very good example that is

55
00:02:02,159 --> 00:02:06,159
not very useful in real life but it

56
00:02:04,079 --> 00:02:08,318
looks something like this

57
00:02:06,159 --> 00:02:10,080
where you start a hundred thousand

58
00:02:08,318 --> 00:02:12,399
co-routines that just prints a little

59
00:02:10,080 --> 00:02:14,160
dot after waiting one second

60
00:02:12,400 --> 00:02:15,520
and if you would do this using threads

61
00:02:14,160 --> 00:02:18,160
your computer will

62
00:02:15,520 --> 00:02:19,920
grind to halt and probably have to

63
00:02:18,160 --> 00:02:21,920
reboot it or something

64
00:02:19,920 --> 00:02:23,359
but this will complete in a little bit

65
00:02:21,920 --> 00:02:26,399
more than one second

66
00:02:23,360 --> 00:02:26,720
because this will run in parallel uh in

67
00:02:26,400 --> 00:02:30,080
a

68
00:02:26,720 --> 00:02:31,599
smart way as core routines are uh

69
00:02:30,080 --> 00:02:34,400
hopefully there will be more information

70
00:02:31,599 --> 00:02:37,119
about how this coroutine stuff works

71
00:02:34,400 --> 00:02:39,760
during the day for those of you are more

72
00:02:37,120 --> 00:02:41,760
interested in the technical details

73
00:02:39,760 --> 00:02:43,679
but suffice to say core routines are

74
00:02:41,760 --> 00:02:45,518
cheap they're easy to use

75
00:02:43,680 --> 00:02:47,360
it doesn't cost very much to start once

76
00:02:45,519 --> 00:02:50,239
so

77
00:02:47,360 --> 00:02:51,599
um but the court the core routine

78
00:02:50,239 --> 00:02:52,720
concept is not new there are other

79
00:02:51,599 --> 00:02:55,760
languages that has that

80
00:02:52,720 --> 00:03:00,319
as well uh like go routines in go

81
00:02:55,760 --> 00:03:02,640
and uh well airline has it etc etc

82
00:03:00,319 --> 00:03:04,640
and it's a great way to to run stuff in

83
00:03:02,640 --> 00:03:06,958
parallel or asynchronous

84
00:03:04,640 --> 00:03:09,279
but kotlin also adds something called

85
00:03:06,959 --> 00:03:11,440
structured concurrency

86
00:03:09,280 --> 00:03:14,159
on top of this and that becomes very

87
00:03:11,440 --> 00:03:16,079
very useful especially in applications

88
00:03:14,159 --> 00:03:17,679
where you have life cycles that are

89
00:03:16,080 --> 00:03:18,720
shorter than the actual life cycle of

90
00:03:17,680 --> 00:03:21,280
the application

91
00:03:18,720 --> 00:03:22,319
like the life cycle of a view life cycle

92
00:03:21,280 --> 00:03:24,400
of a

93
00:03:22,319 --> 00:03:25,599
class that just is valid for a certain

94
00:03:24,400 --> 00:03:28,799
period of time during the

95
00:03:25,599 --> 00:03:29,679
use etc so structure concurrency builds

96
00:03:28,799 --> 00:03:31,920
upon the thing that

97
00:03:29,680 --> 00:03:33,760
any co-routine started needs to run

98
00:03:31,920 --> 00:03:35,440
within a scope

99
00:03:33,760 --> 00:03:38,000
and the scope can then be connected to

100
00:03:35,440 --> 00:03:41,120
the life cycle

101
00:03:38,000 --> 00:03:44,720
there is a great blog post by one of the

102
00:03:41,120 --> 00:03:47,360
kotlin developers at the

103
00:03:44,720 --> 00:03:49,599
head of cotton i think it is uh roman is

104
00:03:47,360 --> 00:03:51,920
elisato he works at jetbrains

105
00:03:49,599 --> 00:03:53,760
where he talks about and writes about uh

106
00:03:51,920 --> 00:03:55,679
what structured concurrency is this one

107
00:03:53,760 --> 00:03:57,359
is from 2018 and he wrote some

108
00:03:55,680 --> 00:03:58,319
follow-ups but i recommend you read this

109
00:03:57,360 --> 00:04:00,480
blog post

110
00:03:58,319 --> 00:04:01,920
so core routines are always related to

111
00:04:00,480 --> 00:04:04,159
some local scope

112
00:04:01,920 --> 00:04:05,920
in your application which is an entity

113
00:04:04,159 --> 00:04:07,280
with a limited lifetime like a ui

114
00:04:05,920 --> 00:04:09,920
element

115
00:04:07,280 --> 00:04:11,040
so the lifetime of a button or a

116
00:04:09,920 --> 00:04:13,359
fragment or

117
00:04:11,040 --> 00:04:16,399
activity is always shorter than the

118
00:04:13,360 --> 00:04:19,199
actual application life cycle

119
00:04:16,399 --> 00:04:20,159
but your co-routines will be started

120
00:04:19,199 --> 00:04:23,840
from those

121
00:04:20,160 --> 00:04:25,040
so the when they first started the core

122
00:04:23,840 --> 00:04:26,320
routines they didn't have the structure

123
00:04:25,040 --> 00:04:27,840
concurrencies they didn't have the

124
00:04:26,320 --> 00:04:29,599
consumer scope so you could do something

125
00:04:27,840 --> 00:04:32,880
like this and it would be probably

126
00:04:29,600 --> 00:04:35,840
valid this is deprecated

127
00:04:32,880 --> 00:04:37,919
do not use this today mostly because you

128
00:04:35,840 --> 00:04:40,400
can't use it today because it's

129
00:04:37,919 --> 00:04:42,240
it probably won't compile anymore but

130
00:04:40,400 --> 00:04:45,198
just launching a core routine out of

131
00:04:42,240 --> 00:04:45,759
nowhere is not the way to do it because

132
00:04:45,199 --> 00:04:48,880
then you

133
00:04:45,759 --> 00:04:50,080
might have things hanging and this

134
00:04:48,880 --> 00:04:51,440
the typical thing that you have in

135
00:04:50,080 --> 00:04:53,039
android applications where you actually

136
00:04:51,440 --> 00:04:55,680
try to update the ui

137
00:04:53,040 --> 00:04:58,080
and you're not in a valid state anymore

138
00:04:55,680 --> 00:05:00,560
so instead

139
00:04:58,080 --> 00:05:01,919
there is this extension function the

140
00:05:00,560 --> 00:05:04,000
first one you

141
00:05:01,919 --> 00:05:05,280
that's most useful when you write your

142
00:05:04,000 --> 00:05:06,960
own suspending function called

143
00:05:05,280 --> 00:05:10,799
co-routine scope

144
00:05:06,960 --> 00:05:13,758
which only can be used inside

145
00:05:10,800 --> 00:05:14,160
a co-routine scope the choroid scope is

146
00:05:13,759 --> 00:05:18,240
where

147
00:05:14,160 --> 00:05:18,240
the life cycle management will happen

148
00:05:18,479 --> 00:05:20,880
we don't really need to go into the

149
00:05:19,680 --> 00:05:22,240
details here i'm going to talk a little

150
00:05:20,880 --> 00:05:25,360
bit about async

151
00:05:22,240 --> 00:05:28,080
in a moment so

152
00:05:25,360 --> 00:05:29,759
coroutine scope what is it well it's

153
00:05:28,080 --> 00:05:32,880
just an interface

154
00:05:29,759 --> 00:05:35,199
which has one uh public

155
00:05:32,880 --> 00:05:37,360
property according context the

156
00:05:35,199 --> 00:05:39,440
corrupting context is what runs the

157
00:05:37,360 --> 00:05:41,120
thread oh sorry the core routine

158
00:05:39,440 --> 00:05:42,880
it's actually the thing that manage it

159
00:05:41,120 --> 00:05:44,160
tells you what dispatcher to run it on

160
00:05:42,880 --> 00:05:46,800
et cetera et cetera

161
00:05:44,160 --> 00:05:49,440
and you can cancel all the core routines

162
00:05:46,800 --> 00:05:53,280
that get launched by cancelling this

163
00:05:49,440 --> 00:05:55,919
this context so

164
00:05:53,280 --> 00:05:57,119
so that's nice and now there is another

165
00:05:55,919 --> 00:05:59,520
a bunch of co

166
00:05:57,120 --> 00:06:01,039
extension functions added on top of the

167
00:05:59,520 --> 00:06:03,840
corrupting scope interface

168
00:06:01,039 --> 00:06:06,159
for instance launch so launch says start

169
00:06:03,840 --> 00:06:09,359
a new core routine for me

170
00:06:06,160 --> 00:06:11,759
it has two optional parameters first

171
00:06:09,360 --> 00:06:13,440
you can give it a context if you want to

172
00:06:11,759 --> 00:06:16,080
and that will be appended to the one

173
00:06:13,440 --> 00:06:17,520
it's running inside and you can tell it

174
00:06:16,080 --> 00:06:18,880
how it should be started it should be

175
00:06:17,520 --> 00:06:22,560
started eagerly or

176
00:06:18,880 --> 00:06:24,880
lazily etc there will be more talk about

177
00:06:22,560 --> 00:06:26,400
what that means later today and finally

178
00:06:24,880 --> 00:06:27,520
you give it a function a suspending

179
00:06:26,400 --> 00:06:29,198
function

180
00:06:27,520 --> 00:06:31,680
which must be running inside the curtin

181
00:06:29,199 --> 00:06:34,720
scope and this one will basically

182
00:06:31,680 --> 00:06:35,840
be your code uh so

183
00:06:34,720 --> 00:06:37,919
yeah so this is nothing you have to

184
00:06:35,840 --> 00:06:38,560
write yourself it's already there but it

185
00:06:37,919 --> 00:06:41,599
lets you

186
00:06:38,560 --> 00:06:44,000
run co-routines inside

187
00:06:41,600 --> 00:06:45,440
activities fragments any life cycle

188
00:06:44,000 --> 00:06:47,280
component in android

189
00:06:45,440 --> 00:06:50,160
and they will be cancelled accordingly

190
00:06:47,280 --> 00:06:50,159
at the appropriate time

191
00:06:50,400 --> 00:06:54,080
so how does the council work let's go

192
00:06:52,800 --> 00:06:55,680
back to this let's start a hundred

193
00:06:54,080 --> 00:06:58,719
thousand core routines

194
00:06:55,680 --> 00:06:59,599
uh let them wait one second each and

195
00:06:58,720 --> 00:07:01,199
once we have

196
00:06:59,599 --> 00:07:03,360
started all these hundred thousand ones

197
00:07:01,199 --> 00:07:05,520
uh we sleep for 100 milliseconds and

198
00:07:03,360 --> 00:07:06,800
then we call cancel on the scope

199
00:07:05,520 --> 00:07:08,080
which will mean that all of these

200
00:07:06,800 --> 00:07:09,280
hundred thousand coroutines will be

201
00:07:08,080 --> 00:07:13,520
cancelled

202
00:07:09,280 --> 00:07:14,880
so very theoretical example but i hope

203
00:07:13,520 --> 00:07:18,639
you understand the

204
00:07:14,880 --> 00:07:20,159
concept there now android

205
00:07:18,639 --> 00:07:22,080
all of you who have developed android

206
00:07:20,160 --> 00:07:22,800
applications have probably seen one of

207
00:07:22,080 --> 00:07:25,120
these two

208
00:07:22,800 --> 00:07:26,639
images i'm sorry for not being able to

209
00:07:25,120 --> 00:07:29,280
blow them up but you know why

210
00:07:26,639 --> 00:07:30,960
because it's impossible these are

211
00:07:29,280 --> 00:07:33,758
horrible diagrams

212
00:07:30,960 --> 00:07:34,960
and i hope that you don't need to look

213
00:07:33,759 --> 00:07:37,039
at them anymore because

214
00:07:34,960 --> 00:07:38,318
thanks to the updates that google has

215
00:07:37,039 --> 00:07:41,759
provided with us over the

216
00:07:38,319 --> 00:07:43,520
last two years with a jetpack library

217
00:07:41,759 --> 00:07:44,960
they're not really that important

218
00:07:43,520 --> 00:07:47,120
anymore

219
00:07:44,960 --> 00:07:48,638
but we still have a life cycle so how

220
00:07:47,120 --> 00:07:50,400
does it work how do we take the life

221
00:07:48,639 --> 00:07:52,560
cycle in android and how do we combine

222
00:07:50,400 --> 00:07:56,159
it with a core routine scope

223
00:07:52,560 --> 00:07:57,840
well as i said oh sorry

224
00:07:56,160 --> 00:07:59,199
when to cancel is a question here

225
00:07:57,840 --> 00:08:00,799
because that's that's the thing

226
00:07:59,199 --> 00:08:02,560
you could write these coding scopes

227
00:08:00,800 --> 00:08:05,280
yourself add them to your activity

228
00:08:02,560 --> 00:08:06,479
your fragment and then call cancel at

229
00:08:05,280 --> 00:08:08,239
the appropriate time

230
00:08:06,479 --> 00:08:09,520
but that kind of like defeats the whole

231
00:08:08,240 --> 00:08:10,960
purpose you

232
00:08:09,520 --> 00:08:13,599
we would like to have something out of

233
00:08:10,960 --> 00:08:17,039
the box so

234
00:08:13,599 --> 00:08:18,080
uh android jetpack so if you don't know

235
00:08:17,039 --> 00:08:20,159
what android jetpack

236
00:08:18,080 --> 00:08:21,599
is i'm sorry i'm not going to go into

237
00:08:20,160 --> 00:08:23,520
the details there but these are

238
00:08:21,599 --> 00:08:26,479
the default libraries that you should

239
00:08:23,520 --> 00:08:28,400
use in any android application today

240
00:08:26,479 --> 00:08:30,560
there are a bunch of libraries that

241
00:08:28,400 --> 00:08:33,919
takes care of different things

242
00:08:30,560 --> 00:08:36,958
in this case we want the lifecycle

243
00:08:33,919 --> 00:08:40,718
libraries from the jetpack libraries

244
00:08:36,958 --> 00:08:43,518
so what we do we add these dependencies

245
00:08:40,719 --> 00:08:46,480
the lifecycle runtime runtime ktx

246
00:08:43,519 --> 00:08:48,640
viewmodel ktx and livedata kdx

247
00:08:46,480 --> 00:08:50,560
it's important that you add the ktx to

248
00:08:48,640 --> 00:08:51,600
them otherwise you're not getting the

249
00:08:50,560 --> 00:08:55,040
core routine

250
00:08:51,600 --> 00:08:56,240
stuff and you will just get the standard

251
00:08:55,040 --> 00:08:56,959
stuff that doesn't have to do with

252
00:08:56,240 --> 00:09:00,800
cutlass

253
00:08:56,959 --> 00:09:02,399
per se uh these

254
00:09:00,800 --> 00:09:05,359
things i'm going to show today were

255
00:09:02,399 --> 00:09:09,360
added in 2.1.0

256
00:09:05,360 --> 00:09:11,480
i think or maybe 2.2.0 for some parts of

257
00:09:09,360 --> 00:09:15,360
it but the latest stable version now is

258
00:09:11,480 --> 00:09:15,360
2.2.0 so use that one

259
00:09:16,080 --> 00:09:19,600
so the first extension function they

260
00:09:18,000 --> 00:09:22,320
added that is the interest of us

261
00:09:19,600 --> 00:09:24,800
is a extension property they basically

262
00:09:22,320 --> 00:09:28,240
just added a property

263
00:09:24,800 --> 00:09:31,279
property getter on the life cycle

264
00:09:28,240 --> 00:09:32,399
interface which is a co called core

265
00:09:31,279 --> 00:09:35,040
routine scope

266
00:09:32,399 --> 00:09:35,839
which combines the life cycle of a

267
00:09:35,040 --> 00:09:38,319
component an

268
00:09:35,839 --> 00:09:39,760
android component an activity a fragment

269
00:09:38,320 --> 00:09:42,240
etc

270
00:09:39,760 --> 00:09:45,200
with the co-routine scope that does that

271
00:09:42,240 --> 00:09:45,200
all that job for us

272
00:09:45,920 --> 00:09:48,399
you can read this code later it's

273
00:09:47,120 --> 00:09:49,360
actually very simple once you get once

274
00:09:48,399 --> 00:09:52,320
you have a look at it

275
00:09:49,360 --> 00:09:54,320
but it basically stores some stores of

276
00:09:52,320 --> 00:09:57,680
reference to this co-routine

277
00:09:54,320 --> 00:10:01,519
life cycle choroiding scope inside an

278
00:09:57,680 --> 00:10:04,880
atomic reference class

279
00:10:01,519 --> 00:10:06,079
um that's part of the the life cycle

280
00:10:04,880 --> 00:10:10,320
class

281
00:10:06,079 --> 00:10:12,160
so then it has another

282
00:10:10,320 --> 00:10:14,399
extension property on the life cycle

283
00:10:12,160 --> 00:10:16,839
owner interface

284
00:10:14,399 --> 00:10:18,320
which basically is your activity or your

285
00:10:16,839 --> 00:10:20,000
fragment

286
00:10:18,320 --> 00:10:21,839
and this is the life cycle scope and

287
00:10:20,000 --> 00:10:25,120
it's just the getter that gets the

288
00:10:21,839 --> 00:10:27,680
core routine scope from the our

289
00:10:25,120 --> 00:10:29,120
other previous life cycle corrupting

290
00:10:27,680 --> 00:10:32,560
scope

291
00:10:29,120 --> 00:10:34,079
so these are the two things that enable

292
00:10:32,560 --> 00:10:36,319
co-working lifecycle management

293
00:10:34,079 --> 00:10:38,239
automatically for us

294
00:10:36,320 --> 00:10:39,839
so how does it work well simple now you

295
00:10:38,240 --> 00:10:41,600
can just

296
00:10:39,839 --> 00:10:42,640
do something like this we have a button

297
00:10:41,600 --> 00:10:42,959
when you click the button you want to

298
00:10:42,640 --> 00:10:46,399
log

299
00:10:42,959 --> 00:10:48,319
in and then we call scope the extension

300
00:10:46,399 --> 00:10:49,600
property that is available on activity

301
00:10:48,320 --> 00:10:51,200
and fragments

302
00:10:49,600 --> 00:10:52,640
and you call launch there which will

303
00:10:51,200 --> 00:10:55,120
start the code routine

304
00:10:52,640 --> 00:10:56,399
and now asynchronously it will do this

305
00:10:55,120 --> 00:10:59,360
and you can call

306
00:10:56,399 --> 00:11:00,640
do login now this is not the perfect way

307
00:10:59,360 --> 00:11:03,040
to do this because

308
00:11:00,640 --> 00:11:04,880
well for various reasons probably dual

309
00:11:03,040 --> 00:11:08,000
login wants to run on a different

310
00:11:04,880 --> 00:11:10,800
dispatcher etc etc but besides the point

311
00:11:08,000 --> 00:11:10,800
in this example

312
00:11:12,399 --> 00:11:16,240
if you want to do coroutines in a view

313
00:11:14,480 --> 00:11:17,839
model and there are reasons why you want

314
00:11:16,240 --> 00:11:19,600
to do it there instead

315
00:11:17,839 --> 00:11:21,120
you can do that as well so they have a

316
00:11:19,600 --> 00:11:24,480
life cycle

317
00:11:21,120 --> 00:11:27,839
management for that the view model class

318
00:11:24,480 --> 00:11:29,839
has uncleared

319
00:11:27,839 --> 00:11:32,320
function which gets called once the

320
00:11:29,839 --> 00:11:33,920
viewmodel is no longer used or no longer

321
00:11:32,320 --> 00:11:35,760
necessary to keep around

322
00:11:33,920 --> 00:11:37,120
so what this extension property does is

323
00:11:35,760 --> 00:11:39,360
basically adding

324
00:11:37,120 --> 00:11:41,040
a co-written scope that is getting

325
00:11:39,360 --> 00:11:43,399
cancelled in the uncleared

326
00:11:41,040 --> 00:11:46,399
function for you so now you can do

327
00:11:43,399 --> 00:11:46,399
viewmodelscope.launch

328
00:11:46,959 --> 00:11:50,719
this will allow you to do like not

329
00:11:48,800 --> 00:11:51,839
exposed core routines up to your ui

330
00:11:50,720 --> 00:11:56,000
components which might

331
00:11:51,839 --> 00:12:00,079
or might not be a good idea it depends

332
00:11:56,000 --> 00:12:01,839
so first pattern or advice is to always

333
00:12:00,079 --> 00:12:02,719
use the lifecycle ktx libraries for

334
00:12:01,839 --> 00:12:05,200
android

335
00:12:02,720 --> 00:12:06,639
when you're doing code routines do not

336
00:12:05,200 --> 00:12:08,399
try to reinvent the wheel

337
00:12:06,639 --> 00:12:11,440
everything is there for you it's getting

338
00:12:08,399 --> 00:12:14,720
proper testing et cetera et cetera

339
00:12:11,440 --> 00:12:17,760
as with any concurrency or threading

340
00:12:14,720 --> 00:12:20,560
or things like that you don't wanna you

341
00:12:17,760 --> 00:12:23,120
don't wanna reinvent stuff yourself

342
00:12:20,560 --> 00:12:24,638
now where would you want to call launch

343
00:12:23,120 --> 00:12:26,399
for the stuff you're going to do well

344
00:12:24,639 --> 00:12:26,880
you can call it in your fragment in your

345
00:12:26,399 --> 00:12:29,680
ui

346
00:12:26,880 --> 00:12:31,279
the top level ui component you have like

347
00:12:29,680 --> 00:12:33,359
you have a login fragment that might be

348
00:12:31,279 --> 00:12:35,600
a valid thing to do

349
00:12:33,360 --> 00:12:37,760
but what happens if you would press back

350
00:12:35,600 --> 00:12:39,279
there or something so maybe you

351
00:12:37,760 --> 00:12:41,279
maybe you want to move it down and you

352
00:12:39,279 --> 00:12:42,560
want to do

353
00:12:41,279 --> 00:12:45,040
launch your core routines in your

354
00:12:42,560 --> 00:12:46,560
activity well that might also be a good

355
00:12:45,040 --> 00:12:48,639
idea but what happens if you press

356
00:12:46,560 --> 00:12:51,599
home or you leave the leave the activity

357
00:12:48,639 --> 00:12:53,440
so maybe a better choice is to do the

358
00:12:51,600 --> 00:12:54,880
add the suspending function in your view

359
00:12:53,440 --> 00:12:57,440
model

360
00:12:54,880 --> 00:12:59,040
so it survives when the user goes in and

361
00:12:57,440 --> 00:13:01,360
out of that scope

362
00:12:59,040 --> 00:13:03,680
well also the view model is also clear

363
00:13:01,360 --> 00:13:04,800
so maybe depending on what it is you

364
00:13:03,680 --> 00:13:06,719
want to do

365
00:13:04,800 --> 00:13:08,800
maybe you should put it in the singleton

366
00:13:06,720 --> 00:13:09,519
object you have that is the repository

367
00:13:08,800 --> 00:13:13,120
for

368
00:13:09,519 --> 00:13:15,200
talking to your backend api so

369
00:13:13,120 --> 00:13:17,440
it depends you need to make these

370
00:13:15,200 --> 00:13:20,560
choices yourself depending on the use

371
00:13:17,440 --> 00:13:22,320
use of the apis etc

372
00:13:20,560 --> 00:13:24,160
just remember that how things are

373
00:13:22,320 --> 00:13:26,880
cancelled is

374
00:13:24,160 --> 00:13:29,360
is what will affect the completion of

375
00:13:26,880 --> 00:13:29,360
your query

376
00:13:29,600 --> 00:13:34,399
so you already saw async before

377
00:13:32,720 --> 00:13:36,639
in the one of the first slides and there

378
00:13:34,399 --> 00:13:40,079
is also launch these are two of the

379
00:13:36,639 --> 00:13:43,040
basic ways of starting core routines

380
00:13:40,079 --> 00:13:45,920
so uh let's see the differences here

381
00:13:43,040 --> 00:13:45,920
what they mean

382
00:13:46,399 --> 00:13:49,920
so let's say we have our login api which

383
00:13:48,480 --> 00:13:53,760
has a suspending function

384
00:13:49,920 --> 00:13:55,519
named login um whatever we do there it's

385
00:13:53,760 --> 00:13:57,199
besides the point you might use retrofit

386
00:13:55,519 --> 00:13:59,680
or ktor or whatever

387
00:13:57,199 --> 00:14:03,839
firebase or what something but you get

388
00:13:59,680 --> 00:14:03,839
an auth result back so

389
00:14:03,920 --> 00:14:07,839
in our fragment we have a reference to

390
00:14:06,399 --> 00:14:10,399
our login api

391
00:14:07,839 --> 00:14:12,160
so we call lifecyclescope.launch we call

392
00:14:10,399 --> 00:14:13,839
login we get a result we check the

393
00:14:12,160 --> 00:14:16,959
result and we do something there

394
00:14:13,839 --> 00:14:18,720
this is perfectly valid and

395
00:14:16,959 --> 00:14:20,319
it's also you know it might be actually

396
00:14:18,720 --> 00:14:20,880
a good idea to use that one if you if

397
00:14:20,320 --> 00:14:22,399
you

398
00:14:20,880 --> 00:14:23,920
want to make sure that the user stays in

399
00:14:22,399 --> 00:14:25,519
the login fragment and if they leave

400
00:14:23,920 --> 00:14:28,560
then you would actually cancel whatever

401
00:14:25,519 --> 00:14:28,560
login operation you had

402
00:14:28,720 --> 00:14:34,399
now another way to do it is to use async

403
00:14:32,240 --> 00:14:36,000
so when you call async and you return

404
00:14:34,399 --> 00:14:37,680
something from an async function you're

405
00:14:36,000 --> 00:14:39,600
no longer getting a job you're getting

406
00:14:37,680 --> 00:14:41,519
it deferred

407
00:14:39,600 --> 00:14:45,199
so the deferred result it's like a

408
00:14:41,519 --> 00:14:46,880
future in java

409
00:14:45,199 --> 00:14:48,240
what that that means that you can take

410
00:14:46,880 --> 00:14:50,560
this deferred result

411
00:14:48,240 --> 00:14:52,800
and pass it into another core routine

412
00:14:50,560 --> 00:14:55,599
elsewhere in your application

413
00:14:52,800 --> 00:14:56,959
so in this case here we would just start

414
00:14:55,600 --> 00:14:58,800
two different core routines and the

415
00:14:56,959 --> 00:15:01,359
second one will wait

416
00:14:58,800 --> 00:15:02,479
uh a weight call there will will then

417
00:15:01,360 --> 00:15:04,480
suspend the function

418
00:15:02,480 --> 00:15:07,279
until the login operation is completed

419
00:15:04,480 --> 00:15:09,680
in the first quarter

420
00:15:07,279 --> 00:15:11,040
so again which one should use it depends

421
00:15:09,680 --> 00:15:13,439
i can't give you

422
00:15:11,040 --> 00:15:15,279
an answer that is 100 valid every time

423
00:15:13,440 --> 00:15:16,560
so you have to consider what is your use

424
00:15:15,279 --> 00:15:18,079
case here maybe you want to take the

425
00:15:16,560 --> 00:15:19,279
deferred result and pass it on to

426
00:15:18,079 --> 00:15:22,638
another fragment

427
00:15:19,279 --> 00:15:24,880
i don't know so

428
00:15:22,639 --> 00:15:27,040
that is launch and async returns like a

429
00:15:24,880 --> 00:15:28,000
single result or do a single thing here

430
00:15:27,040 --> 00:15:30,000
but what about

431
00:15:28,000 --> 00:15:31,040
streams of events that's usually what

432
00:15:30,000 --> 00:15:33,040
we're working with today

433
00:15:31,040 --> 00:15:34,880
whatever is where it's coming from it

434
00:15:33,040 --> 00:15:36,959
might be database

435
00:15:34,880 --> 00:15:38,240
uh it might be outgoing events might be

436
00:15:36,959 --> 00:15:41,119
incoming events might be

437
00:15:38,240 --> 00:15:43,600
data coming from an api etc etc it might

438
00:15:41,120 --> 00:15:44,240
be updates from your gps there are many

439
00:15:43,600 --> 00:15:46,320
types of

440
00:15:44,240 --> 00:15:47,519
events and we treat them like streams

441
00:15:46,320 --> 00:15:50,079
these days

442
00:15:47,519 --> 00:15:51,120
so if you know react rx java or

443
00:15:50,079 --> 00:15:53,040
something like that

444
00:15:51,120 --> 00:15:56,160
you probably worked with that before

445
00:15:53,040 --> 00:15:57,759
it's a nice pattern to work with

446
00:15:56,160 --> 00:15:59,920
and we've got that with core routines as

447
00:15:57,759 --> 00:16:02,639
well i'm not going to go into the

448
00:15:59,920 --> 00:16:04,639
details of reactive streams for kotlin

449
00:16:02,639 --> 00:16:06,320
i'm going to give you one example so you

450
00:16:04,639 --> 00:16:08,320
have a feeling of how to use it in an

451
00:16:06,320 --> 00:16:11,360
average application

452
00:16:08,320 --> 00:16:13,120
so instant search uh is

453
00:16:11,360 --> 00:16:14,880
probably familiar to most of you you

454
00:16:13,120 --> 00:16:17,040
start typing

455
00:16:14,880 --> 00:16:18,160
and for every letter you do you make a

456
00:16:17,040 --> 00:16:22,480
new search

457
00:16:18,160 --> 00:16:24,079
search query yeah so

458
00:16:22,480 --> 00:16:25,680
the challenge here for you as a

459
00:16:24,079 --> 00:16:27,199
developer is that you don't want to spam

460
00:16:25,680 --> 00:16:28,560
your apis you don't want to

461
00:16:27,199 --> 00:16:30,719
you don't actually want to call the

462
00:16:28,560 --> 00:16:31,518
search api on every single key press

463
00:16:30,720 --> 00:16:34,560
because

464
00:16:31,519 --> 00:16:36,000
it just be wasted resources so you want

465
00:16:34,560 --> 00:16:37,599
to have a certain threshold

466
00:16:36,000 --> 00:16:39,680
where you like when the user stops

467
00:16:37,600 --> 00:16:42,959
typing after a certain amount of

468
00:16:39,680 --> 00:16:45,519
period time then you send a request

469
00:16:42,959 --> 00:16:46,560
and if a new search happens while the

470
00:16:45,519 --> 00:16:49,279
old one is going on

471
00:16:46,560 --> 00:16:50,959
you want to cancel the old one and make

472
00:16:49,279 --> 00:16:54,000
a new one

473
00:16:50,959 --> 00:16:55,119
you get it so that's the challenge with

474
00:16:54,000 --> 00:16:56,560
instant search

475
00:16:55,120 --> 00:16:58,639
now this is an application that you can

476
00:16:56,560 --> 00:17:01,518
find on my github i'll show you a link

477
00:16:58,639 --> 00:17:04,480
to it later as well

478
00:17:01,519 --> 00:17:05,839
but conceptually it works like this you

479
00:17:04,480 --> 00:17:07,679
have a stream

480
00:17:05,839 --> 00:17:09,520
of search queries going down into your

481
00:17:07,679 --> 00:17:10,880
application from your fragment into your

482
00:17:09,520 --> 00:17:14,959
view model into your

483
00:17:10,880 --> 00:17:17,360
repository class and away to the the api

484
00:17:14,959 --> 00:17:18,400
and then you have a stream of results

485
00:17:17,359 --> 00:17:20,319
coming

486
00:17:18,400 --> 00:17:21,919
the search results coming back up to

487
00:17:20,319 --> 00:17:23,438
your application so here you have two

488
00:17:21,919 --> 00:17:26,319
streams going

489
00:17:23,439 --> 00:17:26,319
in both directions

490
00:17:27,599 --> 00:17:31,678
we start with our basic search

491
00:17:29,200 --> 00:17:34,000
repository just perform search we get a

492
00:17:31,679 --> 00:17:34,799
query pass in a query we get a list of

493
00:17:34,000 --> 00:17:37,120
strings

494
00:17:34,799 --> 00:17:37,120
back

495
00:17:38,160 --> 00:17:45,120
our view model has

496
00:17:41,600 --> 00:17:46,719
a query channel and

497
00:17:45,120 --> 00:17:48,479
the query channel is of a type called

498
00:17:46,720 --> 00:17:52,400
conflated broadcast channel which

499
00:17:48,480 --> 00:17:55,760
is a very strange word if you haven't

500
00:17:52,400 --> 00:17:56,640
worked with this before but i will show

501
00:17:55,760 --> 00:17:59,600
explain shortly what

502
00:17:56,640 --> 00:18:00,640
it means what we do then is we publish a

503
00:17:59,600 --> 00:18:03,678
search result

504
00:18:00,640 --> 00:18:05,760
property i see here that i didn't show

505
00:18:03,679 --> 00:18:08,080
the type of this search result but it is

506
00:18:05,760 --> 00:18:10,559
a live data in this case so

507
00:18:08,080 --> 00:18:12,399
bear with me here but how we get this

508
00:18:10,559 --> 00:18:15,600
search result property is that we call

509
00:18:12,400 --> 00:18:18,799
as flow so we convert our channel

510
00:18:15,600 --> 00:18:21,039
our conflated broken channel into a flow

511
00:18:18,799 --> 00:18:22,320
and then we call the debounce operator

512
00:18:21,039 --> 00:18:25,360
which is the key here to

513
00:18:22,320 --> 00:18:27,600
like keep down so we don't spam our api

514
00:18:25,360 --> 00:18:29,520
so the search delay milliseconds here i

515
00:18:27,600 --> 00:18:31,600
put 300 milliseconds

516
00:18:29,520 --> 00:18:33,200
so when the user haven't typed a new

517
00:18:31,600 --> 00:18:35,199
character for 300 milliseconds we

518
00:18:33,200 --> 00:18:37,440
perform a search

519
00:18:35,200 --> 00:18:39,360
and the way we do that is we take

520
00:18:37,440 --> 00:18:41,760
because now we're getting the string

521
00:18:39,360 --> 00:18:43,678
from the query into this flow here into

522
00:18:41,760 --> 00:18:46,000
the map latest function

523
00:18:43,679 --> 00:18:47,679
and then i call search api perform

524
00:18:46,000 --> 00:18:50,480
search

525
00:18:47,679 --> 00:18:51,280
now the the nice thing with this one is

526
00:18:50,480 --> 00:18:52,960
that if

527
00:18:51,280 --> 00:18:55,280
the user will type another character

528
00:18:52,960 --> 00:18:59,360
while the search search is

529
00:18:55,280 --> 00:19:01,918
sorry a search is going on uh

530
00:18:59,360 --> 00:19:03,360
this co-routine in the map latest

531
00:19:01,919 --> 00:19:04,320
function because it is another core

532
00:19:03,360 --> 00:19:06,399
routine

533
00:19:04,320 --> 00:19:10,240
that will be cancelled automatically for

534
00:19:06,400 --> 00:19:11,520
you so it will never return a result so

535
00:19:10,240 --> 00:19:13,360
then you will

536
00:19:11,520 --> 00:19:15,918
just pass on a new one so you will not

537
00:19:13,360 --> 00:19:17,600
get cancelled operations or

538
00:19:15,919 --> 00:19:19,760
circuits that have started what was

539
00:19:17,600 --> 00:19:22,799
never completed

540
00:19:19,760 --> 00:19:24,799
and the final one is a slave live data

541
00:19:22,799 --> 00:19:25,679
so we convert this into a regular

542
00:19:24,799 --> 00:19:28,000
android

543
00:19:25,679 --> 00:19:29,440
light data which is easy to use in the

544
00:19:28,000 --> 00:19:31,840
fragments

545
00:19:29,440 --> 00:19:34,240
so first thing conflated broadcast

546
00:19:31,840 --> 00:19:38,080
channel if you have used rx java this is

547
00:19:34,240 --> 00:19:40,960
basically the same as a behavior subject

548
00:19:38,080 --> 00:19:43,280
you can configure it a little bit more

549
00:19:40,960 --> 00:19:46,400
which means that it retains

550
00:19:43,280 --> 00:19:47,840
the latest value basically so a new

551
00:19:46,400 --> 00:19:49,679
subscription to this

552
00:19:47,840 --> 00:19:51,039
search result here will get the last

553
00:19:49,679 --> 00:19:54,960
value

554
00:19:51,039 --> 00:19:57,280
now the ass live data

555
00:19:54,960 --> 00:19:58,880
is an extension function in lifecycle

556
00:19:57,280 --> 00:20:00,799
kdx another reason why you want to use

557
00:19:58,880 --> 00:20:04,000
that library

558
00:20:00,799 --> 00:20:04,720
that basically wraps a collection of

559
00:20:04,000 --> 00:20:07,840
this flow

560
00:20:04,720 --> 00:20:10,080
into a live data object but not only

561
00:20:07,840 --> 00:20:11,918
that it also makes sure that it is kept

562
00:20:10,080 --> 00:20:14,080
around for a little bit longer than the

563
00:20:11,919 --> 00:20:15,039
life cycle of whoever is observing this

564
00:20:14,080 --> 00:20:17,120
live data

565
00:20:15,039 --> 00:20:18,158
so if your your fragment goes in and out

566
00:20:17,120 --> 00:20:21,120
of scope

567
00:20:18,159 --> 00:20:22,880
and back uh it will still be the same

568
00:20:21,120 --> 00:20:24,719
object

569
00:20:22,880 --> 00:20:26,159
so i recommend you checking up the

570
00:20:24,720 --> 00:20:30,080
documentation for the as

571
00:20:26,159 --> 00:20:34,320
live data function now

572
00:20:30,080 --> 00:20:37,760
in our activity we do the following we

573
00:20:34,320 --> 00:20:40,320
we we pass we use the

574
00:20:37,760 --> 00:20:40,799
extension function from the android kdx

575
00:20:40,320 --> 00:20:43,200
that

576
00:20:40,799 --> 00:20:44,400
is on the edit text that's called do

577
00:20:43,200 --> 00:20:48,080
after text change

578
00:20:44,400 --> 00:20:50,080
so whenever the text is uh changed i get

579
00:20:48,080 --> 00:20:52,320
the query channel from my view model

580
00:20:50,080 --> 00:20:54,158
and i call offer offer is not a

581
00:20:52,320 --> 00:20:57,678
suspending function so it's

582
00:20:54,159 --> 00:20:59,440
but it's it's inside it wraps uh

583
00:20:57,679 --> 00:21:01,360
it launches a new core routine inside

584
00:20:59,440 --> 00:21:02,400
there but this means that we don't need

585
00:21:01,360 --> 00:21:07,199
to call offer

586
00:21:02,400 --> 00:21:07,200
on our channel inside a co routine

587
00:21:07,520 --> 00:21:10,559
and that is one choice you can use there

588
00:21:09,760 --> 00:21:11,840
there is another

589
00:21:10,559 --> 00:21:14,399
option here as well as i'm going to talk

590
00:21:11,840 --> 00:21:16,639
about in a moment but basically we just

591
00:21:14,400 --> 00:21:17,760
give this channel here's the latest

592
00:21:16,640 --> 00:21:20,320
string

593
00:21:17,760 --> 00:21:21,760
offer will return boolean if this worked

594
00:21:20,320 --> 00:21:23,120
or not

595
00:21:21,760 --> 00:21:24,640
but in this case we're actually not

596
00:21:23,120 --> 00:21:26,239
interested whether it works or not if it

597
00:21:24,640 --> 00:21:26,720
doesn't work we're going out of scope

598
00:21:26,240 --> 00:21:29,760
anyway

599
00:21:26,720 --> 00:21:31,200
so we can just ignore that

600
00:21:29,760 --> 00:21:33,600
now when we want to listen for the

601
00:21:31,200 --> 00:21:36,960
results i have my regular

602
00:21:33,600 --> 00:21:38,879
recyclerview adapter and uh what i do

603
00:21:36,960 --> 00:21:41,600
there i take the research result

604
00:21:38,880 --> 00:21:43,200
which is live data i observe that one

605
00:21:41,600 --> 00:21:46,480
with the lifecycle

606
00:21:43,200 --> 00:21:48,880
of this activity and i call submit list

607
00:21:46,480 --> 00:21:51,280
on the adapter when whenever i get a new

608
00:21:48,880 --> 00:21:52,159
search result so that's all you need to

609
00:21:51,280 --> 00:21:56,639
do to

610
00:21:52,159 --> 00:21:56,640
basically implement this instant search

611
00:21:56,799 --> 00:22:00,960
now chorusing channels if you do offer

612
00:21:59,360 --> 00:22:02,158
you can do something like this

613
00:22:00,960 --> 00:22:05,760
let's say you want to pass in three

614
00:22:02,159 --> 00:22:09,360
strings or three inks into a channel

615
00:22:05,760 --> 00:22:10,400
uh if the last one was successful it

616
00:22:09,360 --> 00:22:12,240
will return a

617
00:22:10,400 --> 00:22:13,679
return true and then you can do the next

618
00:22:12,240 --> 00:22:14,480
one and you can do the next one this

619
00:22:13,679 --> 00:22:16,960
isn't the

620
00:22:14,480 --> 00:22:19,120
practical real world example but it just

621
00:22:16,960 --> 00:22:21,840
shows how offer works

622
00:22:19,120 --> 00:22:23,520
uh now if nobody is listening to our

623
00:22:21,840 --> 00:22:26,720
channel and collecting data

624
00:22:23,520 --> 00:22:26,960
it will return false so it will not pass

625
00:22:26,720 --> 00:22:30,000
and

626
00:22:26,960 --> 00:22:30,000
go on to the next one

627
00:22:30,400 --> 00:22:34,640
if you use a suspending function you can

628
00:22:32,799 --> 00:22:37,039
use send instead

629
00:22:34,640 --> 00:22:38,320
so then you can call these like just

630
00:22:37,039 --> 00:22:42,080
like this and

631
00:22:38,320 --> 00:22:45,520
when send is invoked it will suspend

632
00:22:42,080 --> 00:22:48,639
until someone is collecting

633
00:22:45,520 --> 00:22:51,600
those are the differences here so again

634
00:22:48,640 --> 00:22:52,480
uh depends on which one you want to use

635
00:22:51,600 --> 00:22:54,879
okay

636
00:22:52,480 --> 00:22:55,840
so let's see how this was solved uh we

637
00:22:54,880 --> 00:22:59,360
convert the

638
00:22:55,840 --> 00:23:00,080
the flow in our uh that comes up in our

639
00:22:59,360 --> 00:23:02,080
view model

640
00:23:00,080 --> 00:23:03,840
to live data for simplicity you don't

641
00:23:02,080 --> 00:23:05,600
need to expose coroutines up to your

642
00:23:03,840 --> 00:23:08,879
fragments or activities

643
00:23:05,600 --> 00:23:10,719
most of the time you can do it if you

644
00:23:08,880 --> 00:23:13,440
need to

645
00:23:10,720 --> 00:23:15,039
also we're passing down events using a

646
00:23:13,440 --> 00:23:16,880
channel so when you want to send

647
00:23:15,039 --> 00:23:18,799
generate events in your application code

648
00:23:16,880 --> 00:23:20,720
you usually use a channel

649
00:23:18,799 --> 00:23:22,000
and when you want to listen for events

650
00:23:20,720 --> 00:23:24,480
that coming in you

651
00:23:22,000 --> 00:23:27,520
use a flow you convert stuff to flow or

652
00:23:24,480 --> 00:23:27,520
you create your own flow

653
00:23:27,760 --> 00:23:35,200
so coroutine channel and flow for events

654
00:23:32,480 --> 00:23:36,240
error handling its importance in our

655
00:23:35,200 --> 00:23:39,280
example

656
00:23:36,240 --> 00:23:40,640
we uh we need to do something like that

657
00:23:39,280 --> 00:23:42,960
and the way to do that is nothing to do

658
00:23:40,640 --> 00:23:44,960
with core teams but more about kotlin

659
00:23:42,960 --> 00:23:46,080
use the sealed class something like this

660
00:23:44,960 --> 00:23:48,720
you create a type

661
00:23:46,080 --> 00:23:52,000
which is what your flow or your live

662
00:23:48,720 --> 00:23:53,440
data will always emit to the ui

663
00:23:52,000 --> 00:23:55,440
and then we have the we have the first

664
00:23:53,440 --> 00:23:57,520
class that extends search result the

665
00:23:55,440 --> 00:23:58,880
valid result which contains a list of

666
00:23:57,520 --> 00:24:00,320
the search results

667
00:23:58,880 --> 00:24:01,919
and then we have two objects that

668
00:24:00,320 --> 00:24:03,120
represents an empty result when we

669
00:24:01,919 --> 00:24:05,679
didn't get any hits

670
00:24:03,120 --> 00:24:07,520
or an empty query when we decided that

671
00:24:05,679 --> 00:24:08,880
this query is too short we don't want to

672
00:24:07,520 --> 00:24:10,639
return we don't want to make a search

673
00:24:08,880 --> 00:24:12,799
with this short query

674
00:24:10,640 --> 00:24:14,640
and then we have error and terminal

675
00:24:12,799 --> 00:24:17,200
error and the reason i have these two

676
00:24:14,640 --> 00:24:18,320
will be obvious in a second here so what

677
00:24:17,200 --> 00:24:20,159
we do

678
00:24:18,320 --> 00:24:23,039
in the map latest we just expand that

679
00:24:20,159 --> 00:24:26,080
one we wrap it in the try catch

680
00:24:23,039 --> 00:24:27,840
inside it we make a check if we if the

681
00:24:26,080 --> 00:24:29,199
the search string was long enough if it

682
00:24:27,840 --> 00:24:31,279
wasn't long enough

683
00:24:29,200 --> 00:24:33,039
then we return an empty query if we

684
00:24:31,279 --> 00:24:34,000
didn't get a search result we return

685
00:24:33,039 --> 00:24:36,000
empty results

686
00:24:34,000 --> 00:24:38,720
if we got a valid result we returned

687
00:24:36,000 --> 00:24:40,080
that if we got an io exception i mean a

688
00:24:38,720 --> 00:24:42,080
network error

689
00:24:40,080 --> 00:24:44,158
we return an error result with that

690
00:24:42,080 --> 00:24:46,480
exception

691
00:24:44,159 --> 00:24:48,400
and then finally after map latest we end

692
00:24:46,480 --> 00:24:50,480
another operator called catch

693
00:24:48,400 --> 00:24:52,480
this will be the terminal catching for

694
00:24:50,480 --> 00:24:54,240
any other exception that we didn't catch

695
00:24:52,480 --> 00:24:56,080
in the map latest

696
00:24:54,240 --> 00:24:57,520
and there we emit a terminal error

697
00:24:56,080 --> 00:24:59,199
because if we get

698
00:24:57,520 --> 00:25:00,879
another exception inside the map latest

699
00:24:59,200 --> 00:25:03,039
that we are not catching

700
00:25:00,880 --> 00:25:04,720
that means that the co-routine the whole

701
00:25:03,039 --> 00:25:06,400
flow will be cancelled so you need to

702
00:25:04,720 --> 00:25:08,000
like restart everything

703
00:25:06,400 --> 00:25:09,440
but this will be like a terminal error

704
00:25:08,000 --> 00:25:11,279
that it means that okay now i have to

705
00:25:09,440 --> 00:25:12,799
close this view and go back or show the

706
00:25:11,279 --> 00:25:15,360
user some error message that was

707
00:25:12,799 --> 00:25:18,960
completely unexpected

708
00:25:15,360 --> 00:25:18,959
so in our handle search result

709
00:25:20,960 --> 00:25:25,360
we we do the following i see i misnamed

710
00:25:23,840 --> 00:25:26,559
the functions there but i think you get

711
00:25:25,360 --> 00:25:29,039
the point

712
00:25:26,559 --> 00:25:29,760
so we check the type basically of these

713
00:25:29,039 --> 00:25:32,960
and then we

714
00:25:29,760 --> 00:25:35,200
call the appropriate function

715
00:25:32,960 --> 00:25:35,200
okay

716
00:25:36,320 --> 00:25:41,600
uh so for error handling we're actually

717
00:25:40,640 --> 00:25:43,919
dealing with

718
00:25:41,600 --> 00:25:45,199
the having a nicer way to deal with the

719
00:25:43,919 --> 00:25:47,200
results coming from your

720
00:25:45,200 --> 00:25:48,960
flow or your live data that you

721
00:25:47,200 --> 00:25:52,320
converted from a flow

722
00:25:48,960 --> 00:25:53,840
use seal classes for everything uh

723
00:25:52,320 --> 00:25:55,678
you should of course do exception

724
00:25:53,840 --> 00:25:57,840
handling properly as well

725
00:25:55,679 --> 00:26:00,559
but it makes the error handling much

726
00:25:57,840 --> 00:26:00,559
much easier

727
00:26:00,720 --> 00:26:06,000
now uh there is there is a blog post

728
00:26:04,559 --> 00:26:08,000
where i wrote about this you can read

729
00:26:06,000 --> 00:26:10,400
more about it i'm going to details there

730
00:26:08,000 --> 00:26:13,520
is a source code example here as well

731
00:26:10,400 --> 00:26:15,600
you can run this example is

732
00:26:13,520 --> 00:26:17,039
also contains some code showing how to

733
00:26:15,600 --> 00:26:20,158
test code routines

734
00:26:17,039 --> 00:26:22,400
which i haven't covered yet

735
00:26:20,159 --> 00:26:25,200
and with that i would like to thank you

736
00:26:22,400 --> 00:26:26,720
all for listening and

737
00:26:25,200 --> 00:26:29,440
hope that you find it interesting i

738
00:26:26,720 --> 00:26:38,320
think we have some time for questions

739
00:26:29,440 --> 00:26:41,039
so any questions oh yeah

740
00:26:38,320 --> 00:26:44,399
thank you um did we have a microphone

741
00:26:41,039 --> 00:26:44,400
for questions is there any questions

742
00:26:45,360 --> 00:26:50,879
no that's fine oh yeah one there

743
00:26:51,039 --> 00:26:53,840
a second

744
00:26:54,720 --> 00:26:57,840
given the maturity of the new

745
00:26:56,080 --> 00:26:59,360
infrastructure of the android linux and

746
00:26:57,840 --> 00:27:01,600
jetpack libraries

747
00:26:59,360 --> 00:27:03,279
uh do you often get conflicts between

748
00:27:01,600 --> 00:27:05,120
the third-party libraries you use which

749
00:27:03,279 --> 00:27:06,240
also depend on these components and your

750
00:27:05,120 --> 00:27:08,479
own application code

751
00:27:06,240 --> 00:27:09,919
sorry the last part i didn't get the

752
00:27:08,480 --> 00:27:12,159
dependency conflicts

753
00:27:09,919 --> 00:27:13,600
so given the maturity state of the

754
00:27:12,159 --> 00:27:15,440
android x and jet buckets

755
00:27:13,600 --> 00:27:17,039
yeah the recent thing do you often get

756
00:27:15,440 --> 00:27:18,720
conflicts between your code and

757
00:27:17,039 --> 00:27:20,559
dependencies and other dependencies

758
00:27:18,720 --> 00:27:22,880
which one a different version of that

759
00:27:20,559 --> 00:27:23,678
uh if i do get dependency conflicts with

760
00:27:22,880 --> 00:27:26,320
the android

761
00:27:23,679 --> 00:27:27,360
the jetpack libraries no actually this

762
00:27:26,320 --> 00:27:29,678
is

763
00:27:27,360 --> 00:27:30,879
i consider that being a solved issue

764
00:27:29,679 --> 00:27:34,399
with once they

765
00:27:30,880 --> 00:27:36,000
went to androidx i know they were

766
00:27:34,399 --> 00:27:37,760
expanding on this one and

767
00:27:36,000 --> 00:27:39,600
uh it's getting better every day as well

768
00:27:37,760 --> 00:27:40,399
so it's like easier to import like

769
00:27:39,600 --> 00:27:42,799
entire

770
00:27:40,399 --> 00:27:44,320
parts of the application it does give

771
00:27:42,799 --> 00:27:46,399
you warnings properly if i

772
00:27:44,320 --> 00:27:47,600
if you you imported one dependency which

773
00:27:46,399 --> 00:27:48,639
actually depends on something else where

774
00:27:47,600 --> 00:27:50,559
you have a lower

775
00:27:48,640 --> 00:27:51,679
version so yeah i would say that it's

776
00:27:50,559 --> 00:27:55,279
fairly

777
00:27:51,679 --> 00:27:58,640
good today yeah okay

778
00:27:55,279 --> 00:28:00,840
um yeah

779
00:27:58,640 --> 00:28:03,840
no more questions in that case oh

780
00:28:00,840 --> 00:28:03,840
everyone

781
00:28:04,240 --> 00:28:10,880
sorry i'm not already developer

782
00:28:07,360 --> 00:28:13,678
but for error handling

783
00:28:10,880 --> 00:28:14,880
why you use a dispatcher sending me to a

784
00:28:13,679 --> 00:28:17,039
sales class

785
00:28:14,880 --> 00:28:18,480
sorry one why why do you use this

786
00:28:17,039 --> 00:28:21,760
pattern because

787
00:28:18,480 --> 00:28:25,760
in my head i have i think

788
00:28:21,760 --> 00:28:28,799
like using a middleware interceptor

789
00:28:25,760 --> 00:28:30,480
that listen to for example to just those

790
00:28:28,799 --> 00:28:34,080
errors

791
00:28:30,480 --> 00:28:36,960
so you mean this one why i pass

792
00:28:34,080 --> 00:28:38,399
events down and why i pass them up so

793
00:28:36,960 --> 00:28:38,960
the middleware that you're mentioning

794
00:28:38,399 --> 00:28:41,039
here is

795
00:28:38,960 --> 00:28:42,159
the search view model here in this in

796
00:28:41,039 --> 00:28:43,760
this example that's

797
00:28:42,159 --> 00:28:46,399
the kind of the business logic that

798
00:28:43,760 --> 00:28:48,000
drives our instant search logic

799
00:28:46,399 --> 00:28:49,439
now do you you could place that on a

800
00:28:48,000 --> 00:28:52,159
back-end instead

801
00:28:49,440 --> 00:28:52,159
is that what you mean

802
00:28:54,630 --> 00:29:00,080
[Music]

803
00:28:56,960 --> 00:29:02,399
you have a ucl class where uh error sits

804
00:29:00,080 --> 00:29:03,600
and you send and it's intercepted by

805
00:29:02,399 --> 00:29:06,719
this search mode

806
00:29:03,600 --> 00:29:07,840
that's what you say uh so we have this

807
00:29:06,720 --> 00:29:12,000
one is that what you mean

808
00:29:07,840 --> 00:29:15,678
yeah or this one maybe yes maybe this

809
00:29:12,000 --> 00:29:17,520
so yeah the here's the channel where i

810
00:29:15,679 --> 00:29:20,640
this is string that the user types in it

811
00:29:17,520 --> 00:29:22,960
gets passed into this function here

812
00:29:20,640 --> 00:29:24,880
and then we basically pass it down into

813
00:29:22,960 --> 00:29:26,960
the lower part of the application

814
00:29:24,880 --> 00:29:28,880
which will be in our in our view model

815
00:29:26,960 --> 00:29:31,360
here so it goes into this channel

816
00:29:28,880 --> 00:29:33,039
and it goes through this flow here and

817
00:29:31,360 --> 00:29:34,240
here it gets them passed down to the api

818
00:29:33,039 --> 00:29:35,760
so this is basically just an

819
00:29:34,240 --> 00:29:37,360
implementation of the middleware that

820
00:29:35,760 --> 00:29:41,039
you're talking about

821
00:29:37,360 --> 00:29:42,479
okay uh well uh i think we're

822
00:29:41,039 --> 00:29:44,240
out of time we need to set up for the

823
00:29:42,480 --> 00:29:55,840
next speaker so thank you all very much

824
00:29:44,240 --> 00:29:55,840
for coming i hope you have a nice day

