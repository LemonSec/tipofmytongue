1
00:00:05,359 --> 00:00:09,200
yeah so

2
00:00:05,920 --> 00:00:10,800
um i'm always honored to be here uh last

3
00:00:09,200 --> 00:00:12,399
year i was standing pretty much in the

4
00:00:10,800 --> 00:00:14,160
same spot and i talked about what we'll

5
00:00:12,400 --> 00:00:16,560
finally do when we get around

6
00:00:14,160 --> 00:00:17,520
to releasing narrative38 so we got

7
00:00:16,560 --> 00:00:21,279
around to releasing

8
00:00:17,520 --> 00:00:22,880
radio 3 8. um turns out that's awesome

9
00:00:21,279 --> 00:00:24,640
also turns out that's definitely not the

10
00:00:22,880 --> 00:00:25,919
end of the journey um

11
00:00:24,640 --> 00:00:28,000
so what we're going to do in the next

12
00:00:25,920 --> 00:00:30,320
minutes um is going to

13
00:00:28,000 --> 00:00:31,359
like take a very very short look back at

14
00:00:30,320 --> 00:00:35,120
what we didn't touch

15
00:00:31,359 --> 00:00:38,000
in three eight um then see

16
00:00:35,120 --> 00:00:39,040
uh what the challenges for the current

17
00:00:38,000 --> 00:00:40,800
schedule are in the

18
00:00:39,040 --> 00:00:42,160
like very narrow sense the things that

19
00:00:40,800 --> 00:00:45,599
we see right now

20
00:00:42,160 --> 00:00:47,919
and then um i hope we can

21
00:00:45,600 --> 00:00:48,960
project a bit about what has to be

22
00:00:47,920 --> 00:00:52,399
solved in the

23
00:00:48,960 --> 00:00:55,520
uh you know larger scheme of things and

24
00:00:52,399 --> 00:00:58,559
how we started to actually tackle that

25
00:00:55,520 --> 00:01:01,199
because honestly um i've been at least

26
00:00:58,559 --> 00:01:02,800
at five panels where we discussed what

27
00:01:01,199 --> 00:01:04,720
awesome things should be done to the

28
00:01:02,800 --> 00:01:07,520
scheduler

29
00:01:04,720 --> 00:01:08,960
and um yeah it's time we actually do one

30
00:01:07,520 --> 00:01:12,320
a few of these

31
00:01:08,960 --> 00:01:15,439
so i wish my presenter was working

32
00:01:12,320 --> 00:01:17,758
so um who am i

33
00:01:15,439 --> 00:01:19,600
i'm gonna do this very quickly i'm still

34
00:01:17,759 --> 00:01:22,720
a research assistant at cal

35
00:01:19,600 --> 00:01:25,839
um we got a new logo um

36
00:01:22,720 --> 00:01:27,119
i teach a couple of the exercise classes

37
00:01:25,840 --> 00:01:29,200
um

38
00:01:27,119 --> 00:01:30,479
that might be the case because i'm kind

39
00:01:29,200 --> 00:01:33,600
of 25

40
00:01:30,479 --> 00:01:36,720
of an institute um

41
00:01:33,600 --> 00:01:38,479
and yeah we're like

42
00:01:36,720 --> 00:01:40,560
on one hand we're still looking for phd

43
00:01:38,479 --> 00:01:42,560
candidates so

44
00:01:40,560 --> 00:01:44,399
if you're looking for a job you know

45
00:01:42,560 --> 00:01:46,880
apply um

46
00:01:44,399 --> 00:01:48,640
a few of my other roles include um you

47
00:01:46,880 --> 00:01:50,798
know supporting

48
00:01:48,640 --> 00:01:51,759
actors and supporting their customers by

49
00:01:50,799 --> 00:01:55,200
supporting

50
00:01:51,759 --> 00:01:56,399
them with more grumpiness i'm also a

51
00:01:55,200 --> 00:01:58,399
freelance engineer

52
00:01:56,399 --> 00:02:00,560
but as you can imagine like with a

53
00:01:58,399 --> 00:02:04,159
full-time job here and a

54
00:02:00,560 --> 00:02:06,719
part-time job there and a

55
00:02:04,159 --> 00:02:08,879
happy fun time nighttime job as chief

56
00:02:06,719 --> 00:02:12,799
architect african radio project

57
00:02:08,878 --> 00:02:17,920
that might come a bit short here um

58
00:02:12,800 --> 00:02:20,720
so um what is the state of new radio

59
00:02:17,920 --> 00:02:21,119
i'm obviously not putting up a picture

60
00:02:20,720 --> 00:02:22,640
of

61
00:02:21,120 --> 00:02:25,440
you know radio which started as a

62
00:02:22,640 --> 00:02:27,040
project probably around 99

63
00:02:25,440 --> 00:02:28,560
we don't know quite for sure we know

64
00:02:27,040 --> 00:02:29,200
when the first code was published that

65
00:02:28,560 --> 00:02:31,760
was

66
00:02:29,200 --> 00:02:32,720
a year later i'm talking about three

67
00:02:31,760 --> 00:02:34,799
seven

68
00:02:32,720 --> 00:02:36,720
um because that's what a lot of people

69
00:02:34,800 --> 00:02:38,800
are still using so this is pretty much

70
00:02:36,720 --> 00:02:42,080
the same slide from just last year

71
00:02:38,800 --> 00:02:44,160
just that that slide ended here um

72
00:02:42,080 --> 00:02:46,160
and since then we've released 3.8 so

73
00:02:44,160 --> 00:02:50,400
that's six year

74
00:02:46,160 --> 00:02:52,319
years of trying to keep an api stable

75
00:02:50,400 --> 00:02:54,720
which means that actually there was a

76
00:02:52,319 --> 00:02:58,640
lot of useful development

77
00:02:54,720 --> 00:03:01,440
in the use space the application space

78
00:02:58,640 --> 00:03:03,200
this is awesome this is something that

79
00:03:01,440 --> 00:03:05,040
we definitely want to foster again in

80
00:03:03,200 --> 00:03:07,280
the future we don't want to break

81
00:03:05,040 --> 00:03:08,079
things whenever we can we want to you

82
00:03:07,280 --> 00:03:10,879
know

83
00:03:08,080 --> 00:03:12,319
move fast but don't break things that's

84
00:03:10,879 --> 00:03:15,518
a hard problem actually

85
00:03:12,319 --> 00:03:18,079
um so here i am telling you that way

86
00:03:15,519 --> 00:03:20,000
we're gonna do a lot of changes

87
00:03:18,080 --> 00:03:21,840
and not all going to be easy and we'll

88
00:03:20,000 --> 00:03:22,720
need to write some code and we'll break

89
00:03:21,840 --> 00:03:24,239
some code

90
00:03:22,720 --> 00:03:25,920
but in the end everything will be fine

91
00:03:24,239 --> 00:03:29,040
so please be on with me

92
00:03:25,920 --> 00:03:30,879
while i try to assure you um so

93
00:03:29,040 --> 00:03:32,239
because i couldn't stop myself from

94
00:03:30,879 --> 00:03:33,040
actually doing that that's exactly the

95
00:03:32,239 --> 00:03:35,670
same slide as

96
00:03:33,040 --> 00:03:36,798
last year um um

97
00:03:35,670 --> 00:03:40,559
[Music]

98
00:03:36,799 --> 00:03:41,280
i've just you know um clean it up a bit

99
00:03:40,560 --> 00:03:42,799
on

100
00:03:41,280 --> 00:03:44,560
you know showing that we've done all

101
00:03:42,799 --> 00:03:48,239
this um

102
00:03:44,560 --> 00:03:49,120
like from 370 to 380 that's only like

103
00:03:48,239 --> 00:03:52,319
380

104
00:03:49,120 --> 00:03:54,480
you know changed lines of code um

105
00:03:52,319 --> 00:03:56,399
that is okayish considering that

106
00:03:54,480 --> 00:03:59,040
includes code reformatting

107
00:03:56,400 --> 00:04:00,879
excludes all the white space that is

108
00:03:59,040 --> 00:04:03,679
actually a lot of work

109
00:04:00,879 --> 00:04:04,399
and it's pretty amazing that basically

110
00:04:03,680 --> 00:04:07,040
um

111
00:04:04,400 --> 00:04:08,000
all out of three modules will be

112
00:04:07,040 --> 00:04:10,798
compatible with

113
00:04:08,000 --> 00:04:13,280
generator three eight i can't think of

114
00:04:10,799 --> 00:04:16,798
many that have like architecturally

115
00:04:13,280 --> 00:04:18,160
problems with becoming 3a comparable

116
00:04:16,798 --> 00:04:19,679
it's mostly mechanical

117
00:04:18,160 --> 00:04:21,359
code changes and the fact that your

118
00:04:19,680 --> 00:04:21,918
python needs to be python 3 if you want

119
00:04:21,358 --> 00:04:23,440
to be

120
00:04:21,918 --> 00:04:25,680
you know future proof and not only work

121
00:04:23,440 --> 00:04:28,240
with 3.8 because

122
00:04:25,680 --> 00:04:29,600
as mentioned before by andrei we're

123
00:04:28,240 --> 00:04:32,800
dropping python 2

124
00:04:29,600 --> 00:04:34,000
for anything after 3.8 which

125
00:04:32,800 --> 00:04:37,360
kind of is the right thing because

126
00:04:34,000 --> 00:04:37,360
python just dropped python 2.

127
00:04:37,759 --> 00:04:41,040
so but what didn't we change we didn't

128
00:04:39,840 --> 00:04:45,039
change

129
00:04:41,040 --> 00:04:47,040
anything about how we modularize

130
00:04:45,040 --> 00:04:49,600
our code so that's still like no radio

131
00:04:47,040 --> 00:04:51,759
runtime we've got all the gr minus

132
00:04:49,600 --> 00:04:52,960
what f's modules in there and we're

133
00:04:51,759 --> 00:04:57,199
actually putting in more

134
00:04:52,960 --> 00:04:58,960
um as as for 49 so

135
00:04:57,199 --> 00:05:01,039
we also didn't change really like what

136
00:04:58,960 --> 00:05:04,239
the project is about it's about

137
00:05:01,039 --> 00:05:06,240
cpu bound or cpu based processing of

138
00:05:04,240 --> 00:05:09,919
software defined radio signals

139
00:05:06,240 --> 00:05:10,800
um if it works for audio if it works for

140
00:05:09,919 --> 00:05:12,719
sonar

141
00:05:10,800 --> 00:05:14,960
if it works for your favorite you know

142
00:05:12,720 --> 00:05:17,199
whatever 1d signal

143
00:05:14,960 --> 00:05:18,799
fine but you know the scope of the

144
00:05:17,199 --> 00:05:20,080
project really is software defined radio

145
00:05:18,800 --> 00:05:23,199
at this point

146
00:05:20,080 --> 00:05:25,198
um and another thing is

147
00:05:23,199 --> 00:05:26,560
that we really didn't change the way we

148
00:05:25,199 --> 00:05:29,440
think about contributions

149
00:05:26,560 --> 00:05:30,160
so um if you got a patch you send it

150
00:05:29,440 --> 00:05:32,080
upstream

151
00:05:30,160 --> 00:05:33,360
we do this by with github by now we

152
00:05:32,080 --> 00:05:34,719
didn't do that with github when we

153
00:05:33,360 --> 00:05:37,919
started 3.7

154
00:05:34,720 --> 00:05:39,919
but it's really like you know very

155
00:05:37,919 --> 00:05:41,120
mostly bug fix oriented code

156
00:05:39,919 --> 00:05:43,520
contributions

157
00:05:41,120 --> 00:05:44,880
and we're just now getting up to speed

158
00:05:43,520 --> 00:05:47,280
with how to

159
00:05:44,880 --> 00:05:48,400
encourage people to submit code upstream

160
00:05:47,280 --> 00:05:51,520
for for example

161
00:05:48,400 --> 00:05:52,960
josh code would be highly be a candidate

162
00:05:51,520 --> 00:05:55,840
for you know up streaming

163
00:05:52,960 --> 00:05:57,120
considering that it has a broader usage

164
00:05:55,840 --> 00:05:58,638
and a lot of people aren't

165
00:05:57,120 --> 00:06:00,639
really happy with the equalizer that

166
00:05:58,639 --> 00:06:02,800
aren't tree like if you

167
00:06:00,639 --> 00:06:04,560
i've just had a talk at either right

168
00:06:02,800 --> 00:06:07,360
about people trying to

169
00:06:04,560 --> 00:06:08,800
think on uart packages won't work with

170
00:06:07,360 --> 00:06:10,000
the current equalizers because they're

171
00:06:08,800 --> 00:06:11,840
simply too slow

172
00:06:10,000 --> 00:06:13,520
like your package is gone the moment

173
00:06:11,840 --> 00:06:17,039
your equalizer locks

174
00:06:13,520 --> 00:06:19,680
um and the main thing is we didn't

175
00:06:17,039 --> 00:06:20,800
change the scheduler so now i'm i'm

176
00:06:19,680 --> 00:06:23,520
doing

177
00:06:20,800 --> 00:06:24,960
this funky finger thing um the air

178
00:06:23,520 --> 00:06:28,159
quotation marks why i'm

179
00:06:24,960 --> 00:06:29,680
doing the air quotation marks um

180
00:06:28,160 --> 00:06:31,360
i think like everyone loves the gnu

181
00:06:29,680 --> 00:06:33,919
radio scheduler right

182
00:06:31,360 --> 00:06:35,520
i throw in my block it gets executed i

183
00:06:33,919 --> 00:06:37,680
don't have to worry about anything

184
00:06:35,520 --> 00:06:40,400
all i have to worry about as a developer

185
00:06:37,680 --> 00:06:42,720
of a signal processing

186
00:06:40,400 --> 00:06:44,400
transformative step is take my code put

187
00:06:42,720 --> 00:06:46,160
it into a work function which has an

188
00:06:44,400 --> 00:06:47,919
input buffer has output buffers

189
00:06:46,160 --> 00:06:50,800
and i just write stuff into the output

190
00:06:47,919 --> 00:06:54,960
buffer and tell the runtime how much

191
00:06:50,800 --> 00:06:58,720
that was right um

192
00:06:54,960 --> 00:07:01,359
so um to understand why

193
00:06:58,720 --> 00:07:02,000
that's not the perfect way to do it

194
00:07:01,360 --> 00:07:04,880
we'll need

195
00:07:02,000 --> 00:07:05,520
to you know go a bit into the history

196
00:07:04,880 --> 00:07:08,479
and do

197
00:07:05,520 --> 00:07:10,400
maybe a very very very short uh

198
00:07:08,479 --> 00:07:10,960
introduction to how greater scheduling

199
00:07:10,400 --> 00:07:12,719
works i

200
00:07:10,960 --> 00:07:14,080
try to actually put everything in in

201
00:07:12,720 --> 00:07:16,160
that presentation

202
00:07:14,080 --> 00:07:18,000
then i realized i you know held such a

203
00:07:16,160 --> 00:07:19,840
presentation last year took one of them

204
00:07:18,000 --> 00:07:22,240
half hours

205
00:07:19,840 --> 00:07:23,520
couldn't do that here so uh we're doing

206
00:07:22,240 --> 00:07:26,880
this this a bit

207
00:07:23,520 --> 00:07:29,359
easier like originally um the radio

208
00:07:26,880 --> 00:07:31,840
from the start was a single core

209
00:07:29,360 --> 00:07:31,840
oriented

210
00:07:32,400 --> 00:07:38,719
framework why because 1999 there was

211
00:07:35,520 --> 00:07:40,799
no easily available multi-core

212
00:07:38,720 --> 00:07:42,319
cpu machines that you'd usually have

213
00:07:40,800 --> 00:07:44,639
access to as a private person

214
00:07:42,319 --> 00:07:45,599
and that was what you know the

215
00:07:44,639 --> 00:07:49,360
developers were

216
00:07:45,599 --> 00:07:52,000
um ideologically aiming for so

217
00:07:49,360 --> 00:07:53,680
what it was it was take an abstract

218
00:07:52,000 --> 00:07:55,039
representation of a flow graph of a

219
00:07:53,680 --> 00:07:57,680
signal processing graph

220
00:07:55,039 --> 00:07:59,120
flatten that graph so that's a directive

221
00:07:57,680 --> 00:08:01,759
r cycle graph

222
00:07:59,120 --> 00:08:03,599
there was no message otherwise stuff in

223
00:08:01,759 --> 00:08:06,800
there there was just

224
00:08:03,599 --> 00:08:08,960
samples going around then

225
00:08:06,800 --> 00:08:10,560
analyze that graph find the sources in

226
00:08:08,960 --> 00:08:12,239
that graph that's rather simple you

227
00:08:10,560 --> 00:08:14,639
start at any node

228
00:08:12,240 --> 00:08:15,520
you do a backward search until you reach

229
00:08:14,639 --> 00:08:16,720
a root node

230
00:08:15,520 --> 00:08:19,440
and then you check whether you've you

231
00:08:16,720 --> 00:08:21,680
know colored all your three

232
00:08:19,440 --> 00:08:22,800
all your graph nodes and if that's the

233
00:08:21,680 --> 00:08:24,639
case you're done

234
00:08:22,800 --> 00:08:26,000
so you find all the sources you call

235
00:08:24,639 --> 00:08:27,840
their work functions

236
00:08:26,000 --> 00:08:30,240
they produce samples in their output

237
00:08:27,840 --> 00:08:32,079
buffers and then you basically

238
00:08:30,240 --> 00:08:34,479
take these samples call the down like

239
00:08:32,080 --> 00:08:36,959
take one of the sources outputs

240
00:08:34,479 --> 00:08:38,479
call the downstream block let that

241
00:08:36,958 --> 00:08:40,640
ripple through the graph and you repeat

242
00:08:38,479 --> 00:08:42,320
that until you're basically blocked by

243
00:08:40,640 --> 00:08:43,919
someone missing new input and then you

244
00:08:42,320 --> 00:08:46,560
go back one step

245
00:08:43,919 --> 00:08:47,839
back trace and run another iteration on

246
00:08:46,560 --> 00:08:50,319
that block

247
00:08:47,839 --> 00:08:51,519
so i hope that if i say something wrong

248
00:08:50,320 --> 00:08:55,279
like the elders of the

249
00:08:51,519 --> 00:08:59,040
project which aren't no tom's not here

250
00:08:55,279 --> 00:09:01,279
um so i'm not saying anything wrong um

251
00:08:59,040 --> 00:09:03,199
so we later renamed that i was around

252
00:09:01,279 --> 00:09:04,800
2009 we just had ready to rename that to

253
00:09:03,200 --> 00:09:06,959
a single threaded scheduler

254
00:09:04,800 --> 00:09:08,240
because we went in and you said we said

255
00:09:06,959 --> 00:09:10,719
oh now that

256
00:09:08,240 --> 00:09:13,279
dual core even quad-core machines are

257
00:09:10,720 --> 00:09:15,920
readily available cheaply available even

258
00:09:13,279 --> 00:09:17,760
um becoming the norm we want to like you

259
00:09:15,920 --> 00:09:20,719
know have multiple threats

260
00:09:17,760 --> 00:09:22,640
and what we did was um let's say we

261
00:09:20,720 --> 00:09:25,440
algorithmically simplified

262
00:09:22,640 --> 00:09:27,040
dummified even um we just took every

263
00:09:25,440 --> 00:09:30,000
block

264
00:09:27,040 --> 00:09:31,599
put them in their own thread still

265
00:09:30,000 --> 00:09:33,440
discovered the sources

266
00:09:31,600 --> 00:09:34,959
called the sources they produced some

267
00:09:33,440 --> 00:09:36,480
data and then we just had like this

268
00:09:34,959 --> 00:09:38,239
message passing

269
00:09:36,480 --> 00:09:39,760
thing where we notified all the

270
00:09:38,240 --> 00:09:40,640
neighbors of these blocks that hey

271
00:09:39,760 --> 00:09:42,399
something has

272
00:09:40,640 --> 00:09:44,319
changed and the individual block

273
00:09:42,399 --> 00:09:46,320
executors and their threats

274
00:09:44,320 --> 00:09:47,760
would then go in and analyze what that

275
00:09:46,320 --> 00:09:49,760
mean and that usually

276
00:09:47,760 --> 00:09:51,760
means that you start processing the

277
00:09:49,760 --> 00:09:53,920
samples which is fine

278
00:09:51,760 --> 00:09:55,680
you know i can write it down in like

279
00:09:53,920 --> 00:09:59,519
literally four lines of c

280
00:09:55,680 --> 00:10:02,880
like the algorithm pseudo c um

281
00:09:59,519 --> 00:10:06,480
and that's fine problem is um

282
00:10:02,880 --> 00:10:08,240
like the average flow graph has more

283
00:10:06,480 --> 00:10:10,320
blocks than i have cpu cores on my

284
00:10:08,240 --> 00:10:11,279
machine and unless i'm not working for

285
00:10:10,320 --> 00:10:14,240
amazon or

286
00:10:11,279 --> 00:10:15,439
google ads probably gonna stay that way

287
00:10:14,240 --> 00:10:16,839
so

288
00:10:15,440 --> 00:10:18,320
[Music]

289
00:10:16,839 --> 00:10:20,480
um uh

290
00:10:18,320 --> 00:10:22,880
with that in mind we can see that okay

291
00:10:20,480 --> 00:10:24,720
this is a very flexible extremely easy

292
00:10:22,880 --> 00:10:27,360
uh way of doing it and it leverages the

293
00:10:24,720 --> 00:10:29,040
fact that operating systems

294
00:10:27,360 --> 00:10:31,279
are getting pretty pretty good at

295
00:10:29,040 --> 00:10:32,240
scheduling tasks when they're ready when

296
00:10:31,279 --> 00:10:34,240
they know that

297
00:10:32,240 --> 00:10:35,600
um they have data available when they're

298
00:10:34,240 --> 00:10:39,600
not blocked on something

299
00:10:35,600 --> 00:10:41,519
and we can really see that the

300
00:10:39,600 --> 00:10:43,279
linux scheduler at very least does a

301
00:10:41,519 --> 00:10:45,200
decent job at you know

302
00:10:43,279 --> 00:10:46,640
finding heuristics of when to schedule

303
00:10:45,200 --> 00:10:50,160
what um

304
00:10:46,640 --> 00:10:52,959
but it's not you know it has simply no

305
00:10:50,160 --> 00:10:55,279
clue oops uh the linux scheduler has no

306
00:10:52,959 --> 00:10:56,959
clue about what the data flow is right

307
00:10:55,279 --> 00:10:59,600
there's only threads and some thread

308
00:10:56,959 --> 00:11:01,119
says oh i has a mute holds a mutex and

309
00:10:59,600 --> 00:11:03,120
we notified that mutex so

310
00:11:01,120 --> 00:11:04,320
some condition variable change some f

311
00:11:03,120 --> 00:11:06,560
mutex is calling

312
00:11:04,320 --> 00:11:07,360
suddenly you're you're in the wild you

313
00:11:06,560 --> 00:11:10,479
don't know who

314
00:11:07,360 --> 00:11:13,360
of these 15 threads to schedule next

315
00:11:10,480 --> 00:11:15,360
um so this is fine it works it's

316
00:11:13,360 --> 00:11:17,440
surprisingly performant

317
00:11:15,360 --> 00:11:18,959
but it's also a bit depressing right

318
00:11:17,440 --> 00:11:20,959
because that means that

319
00:11:18,959 --> 00:11:23,119
we had this you know someone thought

320
00:11:20,959 --> 00:11:24,160
about how to build that single thread

321
00:11:23,120 --> 00:11:26,480
scheduler

322
00:11:24,160 --> 00:11:27,600
and then someone else like this the same

323
00:11:26,480 --> 00:11:29,120
group of people thought about

324
00:11:27,600 --> 00:11:30,399
how to build a multi-threaded scale and

325
00:11:29,120 --> 00:11:31,680
they started with the simplest thing

326
00:11:30,399 --> 00:11:34,079
that comes to mind

327
00:11:31,680 --> 00:11:35,680
and it actually like you know bet the

328
00:11:34,079 --> 00:11:37,680
hell out of that because

329
00:11:35,680 --> 00:11:38,959
if you have four cores that's three

330
00:11:37,680 --> 00:11:40,560
course more than you used to

331
00:11:38,959 --> 00:11:43,839
have and you know you can have a lot of

332
00:11:40,560 --> 00:11:43,839
inefficiency there

333
00:11:44,959 --> 00:11:48,160
so let us you know take a step back and

334
00:11:47,440 --> 00:11:52,720
actually look

335
00:11:48,160 --> 00:11:56,480
at what um makes guna radio

336
00:11:52,720 --> 00:11:58,560
signal flow actually thick

337
00:11:56,480 --> 00:12:00,399
and i i like to call it a back pressure

338
00:11:58,560 --> 00:12:02,160
driven

339
00:12:00,399 --> 00:12:03,839
and with the threat for block schedule

340
00:12:02,160 --> 00:12:04,399
parallel signal processing architecture

341
00:12:03,839 --> 00:12:07,120
meaning

342
00:12:04,399 --> 00:12:08,720
that while for example the file sync

343
00:12:07,120 --> 00:12:11,200
might still be processing the samples

344
00:12:08,720 --> 00:12:13,519
writing them to a file

345
00:12:11,200 --> 00:12:14,399
the multiply cons block here in the

346
00:12:13,519 --> 00:12:16,639
middle might

347
00:12:14,399 --> 00:12:18,800
already be working on the next chunk of

348
00:12:16,639 --> 00:12:20,800
things because that's the way it is like

349
00:12:18,800 --> 00:12:21,839
the signal source just notified multiple

350
00:12:20,800 --> 00:12:23,680
cons multiply cons

351
00:12:21,839 --> 00:12:25,440
did some calculations wrote to the

352
00:12:23,680 --> 00:12:26,959
output buffer and notified the file sync

353
00:12:25,440 --> 00:12:29,040
and in the meantime the signal source

354
00:12:26,959 --> 00:12:29,599
might have already been notified by

355
00:12:29,040 --> 00:12:32,319
multiple

356
00:12:29,600 --> 00:12:34,160
cons that hey you've got some like i'm

357
00:12:32,320 --> 00:12:37,279
done you can do some more work for me

358
00:12:34,160 --> 00:12:39,120
could you please so these two can run in

359
00:12:37,279 --> 00:12:40,480
parallel and in the end like in a stable

360
00:12:39,120 --> 00:12:42,720
situation all three

361
00:12:40,480 --> 00:12:44,240
basically could run in parallel but i

362
00:12:42,720 --> 00:12:47,279
said like no flow graph is

363
00:12:44,240 --> 00:12:49,120
as simple as that most have way more uh

364
00:12:47,279 --> 00:12:52,720
blocks than cpu cores

365
00:12:49,120 --> 00:12:53,519
um so the the you the perceived

366
00:12:52,720 --> 00:12:55,920
parallelism

367
00:12:53,519 --> 00:12:57,279
isn't actually there it's just maxing

368
00:12:55,920 --> 00:13:01,040
out your cpu usage

369
00:12:57,279 --> 00:13:05,519
best case um

370
00:13:01,040 --> 00:13:09,199
so nope

371
00:13:05,519 --> 00:13:10,240
ah so um that's why i put the scheduler

372
00:13:09,200 --> 00:13:13,040
in quotation marks

373
00:13:10,240 --> 00:13:14,079
right there is no scheduling of things

374
00:13:13,040 --> 00:13:15,920
we just

375
00:13:14,079 --> 00:13:17,439
tell everyone at every point in time

376
00:13:15,920 --> 00:13:19,680
that hey i'm done or

377
00:13:17,440 --> 00:13:21,680
hey you've got so like i'm done you've

378
00:13:19,680 --> 00:13:24,239
got some more output to produce

379
00:13:21,680 --> 00:13:26,560
and as you can imagine like this has a

380
00:13:24,240 --> 00:13:30,320
bit of overhead in terms of messaging

381
00:13:26,560 --> 00:13:32,719
and it also doesn't really qualify as

382
00:13:30,320 --> 00:13:34,880
you know informing anyone of the intent

383
00:13:32,720 --> 00:13:35,600
of your data flow why is that important

384
00:13:34,880 --> 00:13:37,680
on

385
00:13:35,600 --> 00:13:38,800
normal machines well if you've got like

386
00:13:37,680 --> 00:13:42,239
think of

387
00:13:38,800 --> 00:13:44,160
an old style cpu you only have ram

388
00:13:42,240 --> 00:13:45,839
and registers and that's it right so

389
00:13:44,160 --> 00:13:47,680
whenever you exchange a big portion of

390
00:13:45,839 --> 00:13:51,680
data you always write that to ram

391
00:13:47,680 --> 00:13:53,839
and get it out in the next block so

392
00:13:51,680 --> 00:13:55,040
problem is that's not how modern cpus

393
00:13:53,839 --> 00:13:56,959
work modern cpus

394
00:13:55,040 --> 00:13:58,399
have caches and these caches are

395
00:13:56,959 --> 00:14:00,880
inherently local

396
00:13:58,399 --> 00:14:02,560
so it would be very desirable that for

397
00:14:00,880 --> 00:14:04,160
example if i had a lot of blocks and

398
00:14:02,560 --> 00:14:06,000
this is just a part of my flow graph

399
00:14:04,160 --> 00:14:07,839
that three these three blocks would run

400
00:14:06,000 --> 00:14:10,320
on the same cpu core why

401
00:14:07,839 --> 00:14:12,000
because then the output of that block

402
00:14:10,320 --> 00:14:14,639
would never leave the cache

403
00:14:12,000 --> 00:14:16,720
of that cpu core the multiply cons would

404
00:14:14,639 --> 00:14:19,839
then be called on data in cache

405
00:14:16,720 --> 00:14:20,560
and write to a cache data for the file

406
00:14:19,839 --> 00:14:22,160
sync

407
00:14:20,560 --> 00:14:24,239
another thing is it's obviously

408
00:14:22,160 --> 00:14:27,519
beneficial if we just try to

409
00:14:24,240 --> 00:14:28,160
execute these in sequence all over again

410
00:14:27,519 --> 00:14:31,120
why

411
00:14:28,160 --> 00:14:33,199
because then with lower cash usage i can

412
00:14:31,120 --> 00:14:36,480
keep the same locality

413
00:14:33,199 --> 00:14:38,000
so um we have no way of actually

414
00:14:36,480 --> 00:14:39,600
integrating that knowledge into the

415
00:14:38,000 --> 00:14:42,720
current scheduler

416
00:14:39,600 --> 00:14:44,560
um bad thing but

417
00:14:42,720 --> 00:14:46,399
um here's we're gonna how we're gonna

418
00:14:44,560 --> 00:14:50,800
solve it

419
00:14:46,399 --> 00:14:52,160
um i'm running out of time so i'm kind

420
00:14:50,800 --> 00:14:54,399
of speeding up here

421
00:14:52,160 --> 00:14:54,399
uh

422
00:14:56,720 --> 00:14:59,839
so um

423
00:15:00,959 --> 00:15:04,800
what we did in the past is we let the

424
00:15:03,040 --> 00:15:07,199
single thread scheduler die

425
00:15:04,800 --> 00:15:08,800
not because it was a bad schedule but

426
00:15:07,199 --> 00:15:10,479
because we concentrated on a different

427
00:15:08,800 --> 00:15:11,760
one and then we added features that only

428
00:15:10,480 --> 00:15:13,839
the newer scheduler

429
00:15:11,760 --> 00:15:15,839
supports so if you're using message

430
00:15:13,839 --> 00:15:17,199
passing in the other chronos case

431
00:15:15,839 --> 00:15:18,959
that's not a feature supported by the

432
00:15:17,199 --> 00:15:20,719
single threaded scheduler

433
00:15:18,959 --> 00:15:22,319
which is sad it's not technically

434
00:15:20,720 --> 00:15:23,839
impossible to do that

435
00:15:22,320 --> 00:15:25,600
it's just you know we never thought

436
00:15:23,839 --> 00:15:27,360
about how to do that and how to come up

437
00:15:25,600 --> 00:15:28,399
with an architecture so we let things

438
00:15:27,360 --> 00:15:32,000
die

439
00:15:28,399 --> 00:15:34,480
um and we also didn't

440
00:15:32,000 --> 00:15:35,920
come up with a way of measuring how well

441
00:15:34,480 --> 00:15:38,480
our scheduler works

442
00:15:35,920 --> 00:15:39,040
while we were still developing it you

443
00:15:38,480 --> 00:15:41,199
know

444
00:15:39,040 --> 00:15:43,199
it was all an afterthought we we added

445
00:15:41,199 --> 00:15:46,479
control part to figure out

446
00:15:43,199 --> 00:15:47,920
when how many uh milliseconds your block

447
00:15:46,480 --> 00:15:51,279
call took on average we

448
00:15:47,920 --> 00:15:52,160
measured uh we added metrics after the

449
00:15:51,279 --> 00:15:54,079
facts

450
00:15:52,160 --> 00:15:55,680
now the problem is if we're going to do

451
00:15:54,079 --> 00:15:57,519
better than that we should be starting

452
00:15:55,680 --> 00:15:58,319
with matrix up front right because other

453
00:15:57,519 --> 00:16:00,800
than that we

454
00:15:58,320 --> 00:16:01,839
might probably make things worse first

455
00:16:00,800 --> 00:16:05,279
um

456
00:16:01,839 --> 00:16:09,519
so uh this is

457
00:16:05,279 --> 00:16:12,399
a bit of a trouble here because

458
00:16:09,519 --> 00:16:15,199
measuring run time in a dynamically

459
00:16:12,399 --> 00:16:15,199
allocating

460
00:16:15,600 --> 00:16:19,279
signal flow is a hard problem you can't

461
00:16:17,920 --> 00:16:22,000
just go and say

462
00:16:19,279 --> 00:16:23,279
everyone halt i want to know how much

463
00:16:22,000 --> 00:16:24,880
time you spend and you spend and you

464
00:16:23,279 --> 00:16:26,639
spend on you spend because

465
00:16:24,880 --> 00:16:28,079
that might all have happened like in

466
00:16:26,639 --> 00:16:30,399
this instance

467
00:16:28,079 --> 00:16:32,479
you're just changing where data is

468
00:16:30,399 --> 00:16:33,839
flowing like dma transfers will happen

469
00:16:32,480 --> 00:16:35,600
in the back

470
00:16:33,839 --> 00:16:37,199
behind your back while you're holding

471
00:16:35,600 --> 00:16:39,199
everything and observing everything

472
00:16:37,199 --> 00:16:40,719
so the all you can do is either do

473
00:16:39,199 --> 00:16:43,839
statistics

474
00:16:40,720 --> 00:16:45,199
or hope for the best um and we're gonna

475
00:16:43,839 --> 00:16:46,399
change that and we see how that's

476
00:16:45,199 --> 00:16:51,599
possible

477
00:16:46,399 --> 00:16:54,880
so what

478
00:16:51,600 --> 00:16:59,040
we hope to do is

479
00:16:54,880 --> 00:17:00,399
um write a scheduler that's

480
00:16:59,040 --> 00:17:02,880
you know something we actually

481
00:17:00,399 --> 00:17:04,559
understand so we have the striper block

482
00:17:02,880 --> 00:17:06,079
scheduler and it's like fairly simple

483
00:17:04,559 --> 00:17:08,240
in principle like i've just explained i

484
00:17:06,079 --> 00:17:09,918
hope that their principle was kind of

485
00:17:08,240 --> 00:17:13,120
clear

486
00:17:09,919 --> 00:17:15,520
but it has like a lot of these states

487
00:17:13,119 --> 00:17:17,280
is that block done is it block on input

488
00:17:15,520 --> 00:17:19,918
is it document output

489
00:17:17,280 --> 00:17:20,799
is it you know currently processing

490
00:17:19,919 --> 00:17:22,799
something

491
00:17:20,799 --> 00:17:24,720
um what what we're going to do when we

492
00:17:22,799 --> 00:17:26,959
say okay this flow graph is done now how

493
00:17:24,720 --> 00:17:30,319
do we flush out the remaining data in

494
00:17:26,959 --> 00:17:30,319
the in the data flow graph

495
00:17:30,960 --> 00:17:35,120
we need something and that's pretty dear

496
00:17:33,679 --> 00:17:38,320
to a lot of people in this room

497
00:17:35,120 --> 00:17:40,719
that's actually extensible we don't want

498
00:17:38,320 --> 00:17:41,600
things to be the single schedule that

499
00:17:40,720 --> 00:17:44,240
you want to use in

500
00:17:41,600 --> 00:17:46,000
radio you need a scheduler for payload

501
00:17:44,240 --> 00:17:47,679
for workloads that look like a path i

502
00:17:46,000 --> 00:17:49,280
really like where i look at it and say

503
00:17:47,679 --> 00:17:50,240
okay the optimal solution to this is

504
00:17:49,280 --> 00:17:53,440
obviously

505
00:17:50,240 --> 00:17:54,559
you know doing it in in circles as fast

506
00:17:53,440 --> 00:17:56,960
as possible

507
00:17:54,559 --> 00:17:59,200
and situations where we have things that

508
00:17:56,960 --> 00:18:01,600
look more like a network of graphs where

509
00:17:59,200 --> 00:18:02,799
packets might be sent around even taking

510
00:18:01,600 --> 00:18:03,678
different routes through my signal

511
00:18:02,799 --> 00:18:05,440
processing

512
00:18:03,679 --> 00:18:06,880
flow graph depending on what that packet

513
00:18:05,440 --> 00:18:08,640
contains right so

514
00:18:06,880 --> 00:18:10,559
if i'm decoding wi-fi not all packets

515
00:18:08,640 --> 00:18:12,160
are data packets some packets

516
00:18:10,559 --> 00:18:14,240
might just be needed for equalization

517
00:18:12,160 --> 00:18:15,039
purposes or you know initialization

518
00:18:14,240 --> 00:18:17,200
purposes they

519
00:18:15,039 --> 00:18:18,160
need to go down different routes so

520
00:18:17,200 --> 00:18:19,760
that's something

521
00:18:18,160 --> 00:18:22,080
that the current scheduler architecture

522
00:18:19,760 --> 00:18:24,160
can't really do

523
00:18:22,080 --> 00:18:26,240
so we started to think about how to

524
00:18:24,160 --> 00:18:28,960
actually write a new schedule and the

525
00:18:26,240 --> 00:18:30,720
problem with that is um

526
00:18:28,960 --> 00:18:32,880
how do you start doing that if you've

527
00:18:30,720 --> 00:18:34,559
got a blog that does so much

528
00:18:32,880 --> 00:18:36,960
everyone who's like who's who's already

529
00:18:34,559 --> 00:18:39,440
written and radio block in this room

530
00:18:36,960 --> 00:18:40,799
can see hands so that's a little more

531
00:18:39,440 --> 00:18:42,799
than half of you

532
00:18:40,799 --> 00:18:44,320
so you really know that you know a new

533
00:18:42,799 --> 00:18:46,160
radio block has this work function that

534
00:18:44,320 --> 00:18:48,639
takes an input and an output buffer

535
00:18:46,160 --> 00:18:50,799
or multiples of these but also you can

536
00:18:48,640 --> 00:18:51,760
have something like a forecast which you

537
00:18:50,799 --> 00:18:53,679
need if you

538
00:18:51,760 --> 00:18:54,799
if you have don't have a fixed rate from

539
00:18:53,679 --> 00:18:56,720
input to output

540
00:18:54,799 --> 00:18:58,639
it also can have like things to check

541
00:18:56,720 --> 00:19:00,320
whether the in number of inputs

542
00:18:58,640 --> 00:19:02,559
works with the number of outputs you're

543
00:19:00,320 --> 00:19:03,360
offered it also has a lot of things that

544
00:19:02,559 --> 00:19:06,639
you don't really

545
00:19:03,360 --> 00:19:07,199
need to have like this purity of essence

546
00:19:06,640 --> 00:19:09,120
kind of

547
00:19:07,200 --> 00:19:12,160
i want to process samples that's a

548
00:19:09,120 --> 00:19:14,879
transformation between input to output

549
00:19:12,160 --> 00:19:17,039
a lot of things that encapsulate the

550
00:19:14,880 --> 00:19:18,640
state of your signal processing

551
00:19:17,039 --> 00:19:20,240
but not from a signal processing point

552
00:19:18,640 --> 00:19:22,240
of view but from the

553
00:19:20,240 --> 00:19:23,520
you know data mart shelling scheduling

554
00:19:22,240 --> 00:19:25,919
point of view so that

555
00:19:23,520 --> 00:19:27,360
is a really hard problem that we see

556
00:19:25,919 --> 00:19:32,000
there why

557
00:19:27,360 --> 00:19:34,320
um you know if i want to take that block

558
00:19:32,000 --> 00:19:35,919
and schedule it elsewhere be it like a

559
00:19:34,320 --> 00:19:37,600
different scheduler type because i

560
00:19:35,919 --> 00:19:39,440
realized like this scheduler is not

561
00:19:37,600 --> 00:19:40,959
working out for that subgraph

562
00:19:39,440 --> 00:19:43,200
or whether i want to say okay that block

563
00:19:40,960 --> 00:19:43,520
goes to aws now it doesn't run on myself

564
00:19:43,200 --> 00:19:45,760
a

565
00:19:43,520 --> 00:19:46,799
computer anymore receives low rate data

566
00:19:45,760 --> 00:19:48,559
and you know needs

567
00:19:46,799 --> 00:19:49,840
processing power that i can't offer

568
00:19:48,559 --> 00:19:51,440
locally

569
00:19:49,840 --> 00:19:53,199
i can do that with that it's not

570
00:19:51,440 --> 00:19:55,039
possible to you know actually

571
00:19:53,200 --> 00:19:57,520
transparently plug out

572
00:19:55,039 --> 00:19:58,640
um a block and move it elsewhere because

573
00:19:57,520 --> 00:20:01,760
the block is so

574
00:19:58,640 --> 00:20:05,039
intensely interfacing with the scheduler

575
00:20:01,760 --> 00:20:06,559
on a basic basis that actually

576
00:20:05,039 --> 00:20:08,640
fills with the internals of the

577
00:20:06,559 --> 00:20:10,240
scheduler that we know were documented

578
00:20:08,640 --> 00:20:11,919
as an api

579
00:20:10,240 --> 00:20:14,960
it's emergent behavior that everyone got

580
00:20:11,919 --> 00:20:18,320
used to like we're fixing a lot of bugs

581
00:20:14,960 --> 00:20:20,000
because oh that's how people are using

582
00:20:18,320 --> 00:20:22,000
the scheduler interesting

583
00:20:20,000 --> 00:20:23,600
that should be working we did something

584
00:20:22,000 --> 00:20:24,880
it broke that and now we have to figure

585
00:20:23,600 --> 00:20:28,000
out a way to

586
00:20:24,880 --> 00:20:28,400
actually make it work again because you

587
00:20:28,000 --> 00:20:32,000
know

588
00:20:28,400 --> 00:20:32,000
we try to not break userland

589
00:20:32,039 --> 00:20:36,640
so um

590
00:20:34,799 --> 00:20:38,879
we needed a cut we needed to say okay

591
00:20:36,640 --> 00:20:39,600
what's a block what is good about a new

592
00:20:38,880 --> 00:20:41,360
radio block

593
00:20:39,600 --> 00:20:44,240
and what's not necessary about the radio

594
00:20:41,360 --> 00:20:46,639
block and um

595
00:20:44,240 --> 00:20:48,720
so we implemented a new block.h that's

596
00:20:46,640 --> 00:20:49,360
what we were doing at the heck fests at

597
00:20:48,720 --> 00:20:52,559
either

598
00:20:49,360 --> 00:20:54,879
um and that was really like that is

599
00:20:52,559 --> 00:20:56,480
a block that's tremendously reduced

600
00:20:54,880 --> 00:20:58,559
compared to the original

601
00:20:56,480 --> 00:20:59,600
radio block it really only has a work

602
00:20:58,559 --> 00:21:02,799
function

603
00:20:59,600 --> 00:21:05,360
and instead of you know having input

604
00:21:02,799 --> 00:21:07,200
items and output items pointers

605
00:21:05,360 --> 00:21:08,559
and then also a parameter that tells you

606
00:21:07,200 --> 00:21:11,200
how much output

607
00:21:08,559 --> 00:21:12,720
items you can maximally produce but

608
00:21:11,200 --> 00:21:13,600
ignoring the fact that you have multiple

609
00:21:12,720 --> 00:21:16,240
outputs so that

610
00:21:13,600 --> 00:21:17,918
these might be multiple numbers and

611
00:21:16,240 --> 00:21:19,440
expecting you to actually

612
00:21:17,919 --> 00:21:21,039
you know tell the schedule how much you

613
00:21:19,440 --> 00:21:24,960
consumed we

614
00:21:21,039 --> 00:21:25,280
kind of try to put that into objects

615
00:21:24,960 --> 00:21:28,240
that

616
00:21:25,280 --> 00:21:30,320
the scheduler calls you with so that we

617
00:21:28,240 --> 00:21:33,919
are getting more like a functional

618
00:21:30,320 --> 00:21:35,678
interface why because basically computer

619
00:21:33,919 --> 00:21:38,400
science tells us that lambdas

620
00:21:35,679 --> 00:21:39,760
are better to reason about than things

621
00:21:38,400 --> 00:21:40,880
that change the state of the world

622
00:21:39,760 --> 00:21:44,080
around them

623
00:21:40,880 --> 00:21:45,600
right so especially if you're writing an

624
00:21:44,080 --> 00:21:47,280
fpga

625
00:21:45,600 --> 00:21:50,158
implementation of something you don't

626
00:21:47,280 --> 00:21:51,440
want that fpga implementation to have to

627
00:21:50,159 --> 00:21:54,159
go back and tell the

628
00:21:51,440 --> 00:21:56,240
cpu bound scheduler that hey i'm now

629
00:21:54,159 --> 00:21:58,320
producing 20 items

630
00:21:56,240 --> 00:22:00,080
that's nothing it should be caring about

631
00:21:58,320 --> 00:22:01,678
first of all and second of all you

632
00:22:00,080 --> 00:22:03,280
literally can't without incurring like

633
00:22:01,679 --> 00:22:04,880
an overhead that's probably way worse

634
00:22:03,280 --> 00:22:05,440
than doing the whole computation on the

635
00:22:04,880 --> 00:22:09,200
cpu

636
00:22:05,440 --> 00:22:11,280
itself so um

637
00:22:09,200 --> 00:22:13,520
that's why we're trying to you know move

638
00:22:11,280 --> 00:22:16,158
away from the classical work thing

639
00:22:13,520 --> 00:22:16,879
um another thing is right now people are

640
00:22:16,159 --> 00:22:18,080
writing

641
00:22:16,880 --> 00:22:19,280
two different kinds of blocks they're

642
00:22:18,080 --> 00:22:20,559
writing like the classical stream

643
00:22:19,280 --> 00:22:23,760
operation blocks like your

644
00:22:20,559 --> 00:22:24,320
fm demodulator or your mod demodulator

645
00:22:23,760 --> 00:22:28,400
for

646
00:22:24,320 --> 00:22:31,120
and stream of otm frames like say in dbt

647
00:22:28,400 --> 00:22:31,919
and they're writing really packet data

648
00:22:31,120 --> 00:22:33,360
things like

649
00:22:31,919 --> 00:22:36,159
what comes out of your stream

650
00:22:33,360 --> 00:22:38,080
demodulator what is an wi-fi packet and

651
00:22:36,159 --> 00:22:40,480
they put these

652
00:22:38,080 --> 00:22:41,678
into asynchronous messages because they

653
00:22:40,480 --> 00:22:44,559
don't really fit the

654
00:22:41,679 --> 00:22:45,919
i have a contiguous memory buffer where

655
00:22:44,559 --> 00:22:47,918
i could write in samples

656
00:22:45,919 --> 00:22:49,919
paradigm and it also really doesn't fit

657
00:22:47,919 --> 00:22:53,360
that you don't want to

658
00:22:49,919 --> 00:22:56,640
allocate these um so

659
00:22:53,360 --> 00:22:57,520
that hopefully allows us to have a

660
00:22:56,640 --> 00:22:59,919
single

661
00:22:57,520 --> 00:23:01,840
unified interface for both instead of

662
00:22:59,919 --> 00:23:05,039
having two different paradigms

663
00:23:01,840 --> 00:23:08,240
in the same uh idea of how we

664
00:23:05,039 --> 00:23:08,879
we do work so that's the block centric

665
00:23:08,240 --> 00:23:12,240
view this is

666
00:23:08,880 --> 00:23:15,120
what i would call the oot module

667
00:23:12,240 --> 00:23:16,559
implementers view of things and then

668
00:23:15,120 --> 00:23:19,760
i've got

669
00:23:16,559 --> 00:23:23,200
um new oops

670
00:23:19,760 --> 00:23:25,280
um the scheduling interface

671
00:23:23,200 --> 00:23:26,880
so the scalar interface obviously now

672
00:23:25,280 --> 00:23:29,200
gets a graph

673
00:23:26,880 --> 00:23:30,000
that's made of out of these connected

674
00:23:29,200 --> 00:23:32,640
blocks

675
00:23:30,000 --> 00:23:33,679
right and it's still i know uh it's

676
00:23:32,640 --> 00:23:35,760
still a graph

677
00:23:33,679 --> 00:23:37,120
um but instead of just you know

678
00:23:35,760 --> 00:23:39,760
distributing

679
00:23:37,120 --> 00:23:40,639
messages to all blocks that run in a

680
00:23:39,760 --> 00:23:43,440
trad each

681
00:23:40,640 --> 00:23:45,520
we introduce workers like i mean web

682
00:23:43,440 --> 00:23:51,279
servers have been doing that since

683
00:23:45,520 --> 00:23:52,480
around 1995. um we just have one worker

684
00:23:51,279 --> 00:23:55,279
per cpu core

685
00:23:52,480 --> 00:23:57,039
and that worker is the owner of a couple

686
00:23:55,279 --> 00:23:59,440
of blocks that

687
00:23:57,039 --> 00:24:00,480
it executes so instead of sending

688
00:23:59,440 --> 00:24:03,039
messages

689
00:24:00,480 --> 00:24:03,760
to a block executor we work send

690
00:24:03,039 --> 00:24:06,879
messages

691
00:24:03,760 --> 00:24:09,840
about hey i've just updated my output

692
00:24:06,880 --> 00:24:10,640
to a worker that worker will then

693
00:24:09,840 --> 00:24:12,879
aggrega

694
00:24:10,640 --> 00:24:14,720
aggregate all the messages that it got

695
00:24:12,880 --> 00:24:17,440
while the main

696
00:24:14,720 --> 00:24:18,240
work that it was currently executing was

697
00:24:17,440 --> 00:24:20,720
executing

698
00:24:18,240 --> 00:24:21,679
after that work is done reorder if

699
00:24:20,720 --> 00:24:24,960
necessary

700
00:24:21,679 --> 00:24:27,679
and execute that so kind of imagine that

701
00:24:24,960 --> 00:24:28,960
as a queue with knowledge of what's done

702
00:24:27,679 --> 00:24:32,720
inside

703
00:24:28,960 --> 00:24:33,279
right so this is for cpu scheduler

704
00:24:32,720 --> 00:24:34,960
should

705
00:24:33,279 --> 00:24:36,480
pretty easily work because that's

706
00:24:34,960 --> 00:24:38,000
basically i mean

707
00:24:36,480 --> 00:24:39,919
if you're implementing a simple os

708
00:24:38,000 --> 00:24:41,679
that's exactly how you implement

709
00:24:39,919 --> 00:24:43,279
scheduling threads you have a queue of

710
00:24:41,679 --> 00:24:44,240
that that should be doing stuff and then

711
00:24:43,279 --> 00:24:47,039
you check whether

712
00:24:44,240 --> 00:24:48,960
any of these had any updates so um

713
00:24:47,039 --> 00:24:51,919
that's easy

714
00:24:48,960 --> 00:24:54,000
but also that gives us a very clear

715
00:24:51,919 --> 00:24:55,520
interface of how to

716
00:24:54,000 --> 00:24:57,600
communicate with other scheduling

717
00:24:55,520 --> 00:24:57,918
domains so i'm introducing the concept

718
00:24:57,600 --> 00:25:00,320
of

719
00:24:57,919 --> 00:25:01,440
scheduling domain that's like hey i've

720
00:25:00,320 --> 00:25:03,600
got a cpu

721
00:25:01,440 --> 00:25:05,279
bound scheduler hey i've got a scheduler

722
00:25:03,600 --> 00:25:07,439
that actually runs

723
00:25:05,279 --> 00:25:08,799
on a gpu or hey i've got a schedule that

724
00:25:07,440 --> 00:25:12,159
actually runs on an fpga

725
00:25:08,799 --> 00:25:14,000
in on a data center somewhere else

726
00:25:12,159 --> 00:25:15,600
and all that it has to do is receive

727
00:25:14,000 --> 00:25:17,039
messages and the good thing about

728
00:25:15,600 --> 00:25:18,799
receiving messages is

729
00:25:17,039 --> 00:25:20,400
you're not really bound to having them

730
00:25:18,799 --> 00:25:24,080
in a shared memory space right

731
00:25:20,400 --> 00:25:25,760
you can do that over network

732
00:25:24,080 --> 00:25:28,559
meaning that this is going to be

733
00:25:25,760 --> 00:25:31,840
transparent we can simply zero mq that

734
00:25:28,559 --> 00:25:35,120
to you know your neighbor's pc

735
00:25:31,840 --> 00:25:37,918
and have that work so that's

736
00:25:35,120 --> 00:25:39,840
um what we're doing in in terms of

737
00:25:37,919 --> 00:25:44,320
scheduling architecture

738
00:25:39,840 --> 00:25:44,320
so could you press the next button

739
00:25:45,919 --> 00:25:49,840
um so what what are we expecting from

740
00:25:49,200 --> 00:25:51,520
this so

741
00:25:49,840 --> 00:25:53,678
um i said like we'll be able to

742
00:25:51,520 --> 00:25:55,840
transparently move blocks we'll be able

743
00:25:53,679 --> 00:25:56,880
to exchange schedulers and that's a big

744
00:25:55,840 --> 00:25:58,879
deal for us

745
00:25:56,880 --> 00:26:00,240
so that's actually where currently our

746
00:25:58,880 --> 00:26:02,799
main research is like

747
00:26:00,240 --> 00:26:04,000
we can do awesome things in block we can

748
00:26:02,799 --> 00:26:05,918
write the coolest

749
00:26:04,000 --> 00:26:07,600
equalizers but at end of the day we're

750
00:26:05,919 --> 00:26:09,279
limited by the computational resources

751
00:26:07,600 --> 00:26:10,879
that we can usually utilize

752
00:26:09,279 --> 00:26:12,799
yeah in a lot of places we could

753
00:26:10,880 --> 00:26:15,520
basically have infinite money

754
00:26:12,799 --> 00:26:16,559
but we don't have infinite bandwidth so

755
00:26:15,520 --> 00:26:19,600
uh

756
00:26:16,559 --> 00:26:21,360
yeah we need to solve that um

757
00:26:19,600 --> 00:26:22,959
and also we've been stuck for 20 years

758
00:26:21,360 --> 00:26:24,000
with basically the same scheduling

759
00:26:22,960 --> 00:26:26,000
paradigm

760
00:26:24,000 --> 00:26:27,360
and might just be the case that we need

761
00:26:26,000 --> 00:26:30,080
to just experiment

762
00:26:27,360 --> 00:26:30,639
get our fingers you know a bit muddy on

763
00:26:30,080 --> 00:26:34,799
how to

764
00:26:30,640 --> 00:26:34,799
you know work things um

765
00:26:35,039 --> 00:26:41,120
so i've got three minutes for questions

766
00:26:39,600 --> 00:26:42,959
and if anyone wants to leave if we could

767
00:26:41,120 --> 00:26:44,479
do that quickly

768
00:26:42,960 --> 00:26:46,000
so i don't know the order of things so

769
00:26:44,480 --> 00:26:46,640
but i let the gentleman in the front yes

770
00:26:46,000 --> 00:26:52,400
so

771
00:26:46,640 --> 00:26:52,400
obviously yeah sure go away

772
00:27:00,960 --> 00:27:04,799
so the like the question was how what

773
00:27:03,200 --> 00:27:06,400
what would the metrics interface look

774
00:27:04,799 --> 00:27:08,799
like what could people do with that

775
00:27:06,400 --> 00:27:10,559
and that's pretty easy like basically

776
00:27:08,799 --> 00:27:12,320
most of the metrics are simply

777
00:27:10,559 --> 00:27:14,080
emerging properties of the messages that

778
00:27:12,320 --> 00:27:16,000
we're exchanging right so i could just

779
00:27:14,080 --> 00:27:19,039
say okay splice that message to a

780
00:27:16,000 --> 00:27:22,320
observer and do that the hopes

781
00:27:19,039 --> 00:27:25,279
are that people who are into scheduling

782
00:27:22,320 --> 00:27:26,879
are optimizing based on what they can

783
00:27:25,279 --> 00:27:28,559
observe there

784
00:27:26,880 --> 00:27:30,559
another hope is that we can just throw

785
00:27:28,559 --> 00:27:32,480
you know phd students at that problem

786
00:27:30,559 --> 00:27:33,840
until it actually works and if that

787
00:27:32,480 --> 00:27:34,640
doesn't work we still have machine

788
00:27:33,840 --> 00:27:35,070
learning

789
00:27:34,640 --> 00:27:39,679
um

790
00:27:35,070 --> 00:27:42,799
[Laughter]

791
00:27:39,679 --> 00:27:45,679
so that's that's the one thing um

792
00:27:42,799 --> 00:27:46,480
yeah the other thing is that we already

793
00:27:45,679 --> 00:27:48,559
have

794
00:27:46,480 --> 00:27:49,840
like i mentioned contrapol we have ways

795
00:27:48,559 --> 00:27:51,440
of measuring performance

796
00:27:49,840 --> 00:27:52,879
they're just not utilized very well

797
00:27:51,440 --> 00:27:55,919
because they're you know

798
00:27:52,880 --> 00:28:03,840
ipi why it's very awkward i'm just gonna

799
00:27:55,919 --> 00:28:03,840
go ahead with you

800
00:28:06,559 --> 00:28:09,200
so the question is whether like

801
00:28:07,760 --> 00:28:09,919
real-time linux capabilities are

802
00:28:09,200 --> 00:28:12,799
beneficial

803
00:28:09,919 --> 00:28:16,240
so busty blossom wrote a paper on the

804
00:28:12,799 --> 00:28:18,399
influence of scattering um

805
00:28:16,240 --> 00:28:19,360
strategies of the eos kernel for radio

806
00:28:18,399 --> 00:28:21,279
and you can actually

807
00:28:19,360 --> 00:28:22,639
increase performance if you're doing a

808
00:28:21,279 --> 00:28:23,919
bit more you know preempting

809
00:28:22,640 --> 00:28:26,880
guaranteeing latencies

810
00:28:23,919 --> 00:28:27,679
but there's only so much you can do so

811
00:28:26,880 --> 00:28:29,520
like basically

812
00:28:27,679 --> 00:28:31,360
real-time linux always does a trade-off

813
00:28:29,520 --> 00:28:33,918
between latency

814
00:28:31,360 --> 00:28:34,559
and rate and we're not willing to go

815
00:28:33,919 --> 00:28:38,080
that

816
00:28:34,559 --> 00:28:40,158
way so i'm i'm sorry i'm out of time um

817
00:28:38,080 --> 00:28:42,840
i'll have to hand over like i gladly

818
00:28:40,159 --> 00:28:44,320
hand over my microphone to the next

819
00:28:42,840 --> 00:28:50,119
speaker

820
00:28:44,320 --> 00:28:50,119
[Applause]

