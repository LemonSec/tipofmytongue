1
00:00:05,279 --> 00:00:09,840
okay so i'm andreas rumf the

2
00:00:07,520 --> 00:00:11,759
original inventor and still lead

3
00:00:09,840 --> 00:00:14,480
developer of nymph

4
00:00:11,759 --> 00:00:15,519
and so this is my talking move semantics

5
00:00:14,480 --> 00:00:18,800
which is the new

6
00:00:15,519 --> 00:00:22,320
stuff coming to nim inspired by

7
00:00:18,800 --> 00:00:23,039
rust and c plus plus but we we tweaked

8
00:00:22,320 --> 00:00:26,480
it

9
00:00:23,039 --> 00:00:28,880
um so let's get started so the

10
00:00:26,480 --> 00:00:30,080
the unofficial motto of nim is actually

11
00:00:28,880 --> 00:00:33,600
copying

12
00:00:30,080 --> 00:00:36,559
bad design is not good design

13
00:00:33,600 --> 00:00:39,200
and so this is already a useful motto

14
00:00:36,559 --> 00:00:41,440
because it tells us what not to do so

15
00:00:39,200 --> 00:00:42,719
yeah we don't we should not copy bad

16
00:00:41,440 --> 00:00:45,839
designs

17
00:00:42,719 --> 00:00:46,160
and more useful than knowing what not to

18
00:00:45,840 --> 00:00:49,680
do

19
00:00:46,160 --> 00:00:50,160
is knowing what to do so paraphrasing

20
00:00:49,680 --> 00:00:53,199
this

21
00:00:50,160 --> 00:00:54,319
into recombine good pits from several

22
00:00:53,199 --> 00:00:56,559
sources

23
00:00:54,320 --> 00:00:57,360
and so that's what we did we looked at

24
00:00:56,559 --> 00:01:00,160
as i said

25
00:00:57,360 --> 00:01:01,920
rust and c plus plus and swift how they

26
00:01:00,160 --> 00:01:05,199
do memory management

27
00:01:01,920 --> 00:01:07,439
and if if these concepts also apply to

28
00:01:05,199 --> 00:01:07,439
nim

29
00:01:08,240 --> 00:01:11,679
and it turns out the answer answer is

30
00:01:10,000 --> 00:01:14,799
yes

31
00:01:11,680 --> 00:01:17,920
so here this is an example

32
00:01:14,799 --> 00:01:18,640
so i have a an array with two elements

33
00:01:17,920 --> 00:01:21,759
inside

34
00:01:18,640 --> 00:01:25,840
and then i append the number three to it

35
00:01:21,759 --> 00:01:27,520
and so this is a growable array i think

36
00:01:25,840 --> 00:01:31,040
in c plus plus it's a vector

37
00:01:27,520 --> 00:01:32,880
and uh in limits called a sequence

38
00:01:31,040 --> 00:01:34,640
so here is what happens in memory we

39
00:01:32,880 --> 00:01:36,560
have these this uh

40
00:01:34,640 --> 00:01:38,400
global array and it actually has a

41
00:01:36,560 --> 00:01:40,560
length and a capacity

42
00:01:38,400 --> 00:01:42,399
and a single pointer to a block of

43
00:01:40,560 --> 00:01:45,360
memory that can grow

44
00:01:42,399 --> 00:01:47,200
and when we append the number we need to

45
00:01:45,360 --> 00:01:49,040
and since the capacity is already

46
00:01:47,200 --> 00:01:50,640
full like we had capacity for two

47
00:01:49,040 --> 00:01:53,119
elements

48
00:01:50,640 --> 00:01:55,040
uh we need to create a new block of

49
00:01:53,119 --> 00:01:58,399
memory which is big enough to

50
00:01:55,040 --> 00:02:01,920
to contain all three numbers

51
00:01:58,399 --> 00:02:05,759
and um we need to do something with

52
00:02:01,920 --> 00:02:07,600
with the old memory block and

53
00:02:05,759 --> 00:02:09,759
usually you would say like it's a real

54
00:02:07,600 --> 00:02:11,038
log in c and it would free the old block

55
00:02:09,758 --> 00:02:13,760
immediately

56
00:02:11,038 --> 00:02:15,359
and now this this is the most effective

57
00:02:13,760 --> 00:02:18,399
way of doing things

58
00:02:15,360 --> 00:02:22,239
however it causes a problem and that is

59
00:02:18,400 --> 00:02:22,239
is that yeah okay

60
00:02:22,800 --> 00:02:27,840
and the problem is that if i have other

61
00:02:25,599 --> 00:02:30,319
aliases to this pointer

62
00:02:27,840 --> 00:02:31,760
i i must ensure that it doesn't cause a

63
00:02:30,319 --> 00:02:34,480
dangling pointer

64
00:02:31,760 --> 00:02:35,440
so here in line two i say i have this

65
00:02:34,480 --> 00:02:39,040
other variable

66
00:02:35,440 --> 00:02:40,879
and it should have the same contents as

67
00:02:39,040 --> 00:02:44,239
some numbers

68
00:02:40,879 --> 00:02:45,760
and if i do a shallow copy and just copy

69
00:02:44,239 --> 00:02:47,120
all the bits then i would copy the

70
00:02:45,760 --> 00:02:50,079
pointer which is

71
00:02:47,120 --> 00:02:50,720
invalidated in line three by the append

72
00:02:50,080 --> 00:02:52,319
causing

73
00:02:50,720 --> 00:02:54,160
this to contain a dangling pointer so

74
00:02:52,319 --> 00:02:56,799
that's would be very very unsafe and

75
00:02:54,160 --> 00:02:58,879
it's a very bad idea

76
00:02:56,800 --> 00:03:00,239
so to solve this problem there are a

77
00:02:58,879 --> 00:03:03,440
couple of solutions

78
00:03:00,239 --> 00:03:05,360
one is to deep copy the elements

79
00:03:03,440 --> 00:03:07,680
in the container which is what c plus

80
00:03:05,360 --> 00:03:09,040
plus does and also what nymph semantics

81
00:03:07,680 --> 00:03:11,440
do

82
00:03:09,040 --> 00:03:13,760
um you could also saying okay so let's

83
00:03:11,440 --> 00:03:17,120
have a pointer to a pointer so everybody

84
00:03:13,760 --> 00:03:21,200
gets the new update this is done in

85
00:03:17,120 --> 00:03:22,959
java and c-sharp i think um

86
00:03:21,200 --> 00:03:25,119
but it's a lot it's slightly less

87
00:03:22,959 --> 00:03:27,120
effective efficient because then you

88
00:03:25,120 --> 00:03:28,720
have another indirection

89
00:03:27,120 --> 00:03:31,040
you could also say well this is an

90
00:03:28,720 --> 00:03:31,440
assignment but it's a bad assignment so

91
00:03:31,040 --> 00:03:34,798
let's

92
00:03:31,440 --> 00:03:36,079
just forbid it um this would be a

93
00:03:34,799 --> 00:03:39,760
terrible solution but yeah

94
00:03:36,080 --> 00:03:40,319
you could um the first solution as i

95
00:03:39,760 --> 00:03:42,480
mentioned

96
00:03:40,319 --> 00:03:44,560
so you just have a garbage collector

97
00:03:42,480 --> 00:03:48,079
cleaning up this bad pointer for you

98
00:03:44,560 --> 00:03:51,280
or only if no other

99
00:03:48,080 --> 00:03:52,159
variable refers to it or finally we

100
00:03:51,280 --> 00:03:55,599
could move it

101
00:03:52,159 --> 00:03:59,040
and that is the fifth point here

102
00:03:55,599 --> 00:04:02,238
so we could steal the block of memory

103
00:03:59,040 --> 00:04:03,840
and uh perform a move and that's also

104
00:04:02,239 --> 00:04:05,920
available in c plus plus

105
00:04:03,840 --> 00:04:08,159
so this would be an explicit move here

106
00:04:05,920 --> 00:04:10,319
in them so you can do this

107
00:04:08,159 --> 00:04:12,319
you can say i'm gonna move these numbers

108
00:04:10,319 --> 00:04:12,879
over to other and then afterwards the

109
00:04:12,319 --> 00:04:16,560
source

110
00:04:12,879 --> 00:04:19,039
is invalidated so it becomes an empty

111
00:04:16,560 --> 00:04:20,959
sequence and so if you then append the

112
00:04:19,040 --> 00:04:22,160
three this is the only thing that's left

113
00:04:20,959 --> 00:04:24,320
inside there

114
00:04:22,160 --> 00:04:26,840
so and as you can see in line six after

115
00:04:24,320 --> 00:04:29,440
that some numbers only has the three

116
00:04:26,840 --> 00:04:32,320
inside

117
00:04:29,440 --> 00:04:32,719
so this is the explicit move i mean you

118
00:04:32,320 --> 00:04:36,880
can

119
00:04:32,720 --> 00:04:36,880
try to program in the style and

120
00:04:36,960 --> 00:04:43,039
it's not really pleasant

121
00:04:40,080 --> 00:04:44,880
so but if it's explicit it's it's okay

122
00:04:43,040 --> 00:04:46,639
like you are aware that some numbers is

123
00:04:44,880 --> 00:04:48,240
empty afterwards

124
00:04:46,639 --> 00:04:50,800
but there are plenty of cases where you

125
00:04:48,240 --> 00:04:53,840
can move implicitly

126
00:04:50,800 --> 00:04:56,560
the first example famous uh

127
00:04:53,840 --> 00:04:57,840
if you have a result of a function call

128
00:04:56,560 --> 00:04:59,040
you know it's not going to used

129
00:04:57,840 --> 00:05:03,919
afterwards so you can move

130
00:04:59,040 --> 00:05:07,600
the the directly into the variable a

131
00:05:03,919 --> 00:05:12,400
um yeah and then

132
00:05:07,600 --> 00:05:12,400
you could also say that um

133
00:05:12,880 --> 00:05:16,320
if you if you know that it's not used

134
00:05:15,759 --> 00:05:18,400
afterwards

135
00:05:16,320 --> 00:05:20,240
this is what you can do you can move it

136
00:05:18,400 --> 00:05:22,159
so and one design goal was

137
00:05:20,240 --> 00:05:23,360
to make this work like okay we know

138
00:05:22,160 --> 00:05:26,479
function calls

139
00:05:23,360 --> 00:05:27,440
can be moved but i want to be able to

140
00:05:26,479 --> 00:05:29,280
name my

141
00:05:27,440 --> 00:05:30,960
results for readability without

142
00:05:29,280 --> 00:05:34,880
performance in

143
00:05:30,960 --> 00:05:36,320
overhead so as long as named value is a

144
00:05:34,880 --> 00:05:38,479
local variable

145
00:05:36,320 --> 00:05:39,440
the the nim compiler can see that named

146
00:05:38,479 --> 00:05:41,359
value

147
00:05:39,440 --> 00:05:43,759
is like it's used for the f call and

148
00:05:41,360 --> 00:05:46,320
that not afterwards anymore

149
00:05:43,759 --> 00:05:47,360
so um it would move the value the named

150
00:05:46,320 --> 00:05:51,120
value into the f

151
00:05:47,360 --> 00:05:53,759
and then it would move f's result into a

152
00:05:51,120 --> 00:05:55,039
and here's another example so i have a

153
00:05:53,759 --> 00:05:58,639
list with three

154
00:05:55,039 --> 00:06:02,159
integers inside and if i if i say y is

155
00:05:58,639 --> 00:06:02,960
x then since x isn't used anymore we can

156
00:06:02,160 --> 00:06:06,880
move

157
00:06:02,960 --> 00:06:10,080
and likewise for the set equals y

158
00:06:06,880 --> 00:06:14,080
and so this works for local variables so

159
00:06:10,080 --> 00:06:18,159
um let's think about

160
00:06:14,080 --> 00:06:21,039
oh i'm not okay um

161
00:06:18,160 --> 00:06:22,960
parameters do cause problems because we

162
00:06:21,039 --> 00:06:25,919
don't know if the value that's

163
00:06:22,960 --> 00:06:27,120
been pushed to to our put is used

164
00:06:25,919 --> 00:06:29,758
afterwards

165
00:06:27,120 --> 00:06:33,120
so um in this example is about like it's

166
00:06:29,759 --> 00:06:33,120
pseudo code for a hash table

167
00:06:33,520 --> 00:06:36,560
i implementation usually it would be

168
00:06:35,199 --> 00:06:39,840
more than two lines but

169
00:06:36,560 --> 00:06:42,160
so we hash the value and

170
00:06:39,840 --> 00:06:43,039
we want to move this this key value pair

171
00:06:42,160 --> 00:06:46,639
into the

172
00:06:43,039 --> 00:06:48,400
the t and

173
00:06:46,639 --> 00:06:50,560
given given the current semantics this

174
00:06:48,400 --> 00:06:53,840
would mean to make this uh

175
00:06:50,560 --> 00:06:54,160
expensive copy operation here but you

176
00:06:53,840 --> 00:06:57,359
can

177
00:06:54,160 --> 00:07:01,360
annotate this parameter values to

178
00:06:57,360 --> 00:07:04,639
use the sync keyword and then

179
00:07:01,360 --> 00:07:06,720
it's like uh it's the the

180
00:07:04,639 --> 00:07:08,560
the constraint that afterwards it

181
00:07:06,720 --> 00:07:11,840
shouldn't be used anymore it bubbles up

182
00:07:08,560 --> 00:07:13,440
the call chain so now because it's a

183
00:07:11,840 --> 00:07:16,318
sync parameter we know

184
00:07:13,440 --> 00:07:17,599
we can it won't be used afterwards and

185
00:07:16,319 --> 00:07:22,880
we can perform the move

186
00:07:17,599 --> 00:07:22,880
inside the inside in line three

187
00:07:24,000 --> 00:07:27,280
so again if i have values like a list

188
00:07:26,720 --> 00:07:29,840
with

189
00:07:27,280 --> 00:07:32,159
three strings inside and i don't use

190
00:07:29,840 --> 00:07:34,799
them afterwards i can move

191
00:07:32,160 --> 00:07:36,400
now what happens if i use values

192
00:07:34,800 --> 00:07:40,160
afterwards

193
00:07:36,400 --> 00:07:40,719
then we since we want to take ownership

194
00:07:40,160 --> 00:07:44,000
of this

195
00:07:40,720 --> 00:07:46,160
of the guts of this object we the

196
00:07:44,000 --> 00:07:47,039
compiler produces a warning for us

197
00:07:46,160 --> 00:07:50,319
telling us like

198
00:07:47,039 --> 00:07:52,639
you are about to sync something that is

199
00:07:50,319 --> 00:07:54,240
used afterwards and i will make a copy

200
00:07:52,639 --> 00:07:58,879
for you so

201
00:07:54,240 --> 00:08:04,000
um to to ensure safety

202
00:07:58,879 --> 00:08:05,680
so this is also been a design criterion

203
00:08:04,000 --> 00:08:08,000
if you get it wrong the performance

204
00:08:05,680 --> 00:08:11,199
suffers but no weird crashes please

205
00:08:08,000 --> 00:08:13,520
so and that's true and

206
00:08:11,199 --> 00:08:14,639
the compiler warns about the performance

207
00:08:13,520 --> 00:08:16,878
aspect

208
00:08:14,639 --> 00:08:17,840
and currently this warning is is overly

209
00:08:16,879 --> 00:08:21,759
uh

210
00:08:17,840 --> 00:08:25,280
like it's it's uh it's uh a bit too

211
00:08:21,759 --> 00:08:26,319
aggressive so i need to make this a bit

212
00:08:25,280 --> 00:08:30,239
better

213
00:08:26,319 --> 00:08:31,919
um so if but um

214
00:08:30,240 --> 00:08:33,839
one solution here would be you move it

215
00:08:31,919 --> 00:08:36,640
around like

216
00:08:33,839 --> 00:08:38,159
if you echo the values before you embed

217
00:08:36,640 --> 00:08:41,360
it into this

218
00:08:38,159 --> 00:08:43,919
hash table then it would work because

219
00:08:41,360 --> 00:08:47,360
the compiler knows echo doesn't

220
00:08:43,919 --> 00:08:49,040
doesn't uh want to take over ownership

221
00:08:47,360 --> 00:08:51,279
of values

222
00:08:49,040 --> 00:08:52,480
but table put does because of this sync

223
00:08:51,279 --> 00:08:54,399
annotation

224
00:08:52,480 --> 00:08:55,920
so that's one solution of course like if

225
00:08:54,399 --> 00:08:58,399
you are

226
00:08:55,920 --> 00:09:00,079
just adding some code for debugging

227
00:08:58,399 --> 00:09:01,760
purposes you don't care if it causes

228
00:09:00,080 --> 00:09:03,360
more copies or not because this code

229
00:09:01,760 --> 00:09:07,200
will be removed

230
00:09:03,360 --> 00:09:09,760
soon again afterwards

231
00:09:07,200 --> 00:09:11,440
okay so as i said it's the sync

232
00:09:09,760 --> 00:09:13,680
parameter is an optimization

233
00:09:11,440 --> 00:09:14,560
you don't have to use it if you get it

234
00:09:13,680 --> 00:09:16,479
wrong

235
00:09:14,560 --> 00:09:18,800
performance is worse than before if you

236
00:09:16,480 --> 00:09:22,080
get it right you get better performance

237
00:09:18,800 --> 00:09:22,719
and um we are also working on this this

238
00:09:22,080 --> 00:09:24,560
property

239
00:09:22,720 --> 00:09:25,760
so that you don't have to annotate it at

240
00:09:24,560 --> 00:09:27,199
all

241
00:09:25,760 --> 00:09:28,800
because i actually i went through the

242
00:09:27,200 --> 00:09:30,560
standard library trying to

243
00:09:28,800 --> 00:09:32,160
add these sync annotations everywhere

244
00:09:30,560 --> 00:09:35,279
and i was like yeah no

245
00:09:32,160 --> 00:09:35,279
i'm not going to do that

246
00:09:35,440 --> 00:09:38,720
i let the compiler figure this out so

247
00:09:37,519 --> 00:09:40,800
anyway here are a couple of

248
00:09:38,720 --> 00:09:42,160
examples so we have a hash table and

249
00:09:40,800 --> 00:09:45,760
this is this

250
00:09:42,160 --> 00:09:47,439
uh put putter or whatever like insert or

251
00:09:45,760 --> 00:09:49,439
update

252
00:09:47,440 --> 00:09:50,640
then we have equality on some generic

253
00:09:49,440 --> 00:09:53,680
type t

254
00:09:50,640 --> 00:09:56,560
or plus on t on finally append or add

255
00:09:53,680 --> 00:09:56,959
on this global sequence and the question

256
00:09:56,560 --> 00:10:00,160
is

257
00:09:56,959 --> 00:10:03,199
where to put the sync annotation and

258
00:10:00,160 --> 00:10:08,079
you don't have to guess i'm telling you

259
00:10:03,200 --> 00:10:08,079
so i'm sorry it's not really

260
00:10:09,040 --> 00:10:16,079
yeah okay so uh embedding stuff into a

261
00:10:13,279 --> 00:10:17,120
hash table takes the sync annotation and

262
00:10:16,079 --> 00:10:18,719
the append

263
00:10:17,120 --> 00:10:20,320
for the sequences the existing

264
00:10:18,720 --> 00:10:23,519
annotation and now

265
00:10:20,320 --> 00:10:23,760
here is this is an so the first line is

266
00:10:23,519 --> 00:10:26,079
an

267
00:10:23,760 --> 00:10:27,200
insert or an update and if i insert into

268
00:10:26,079 --> 00:10:30,079
the hash table

269
00:10:27,200 --> 00:10:30,800
i also want to take ownership of the key

270
00:10:30,079 --> 00:10:32,560
but if it's

271
00:10:30,800 --> 00:10:34,560
just an update on the table i already

272
00:10:32,560 --> 00:10:36,239
have the key and then

273
00:10:34,560 --> 00:10:39,439
what happens should this be your sync or

274
00:10:36,240 --> 00:10:42,240
not well i don't know

275
00:10:39,440 --> 00:10:43,519
but um the thing is once one if you do

276
00:10:42,240 --> 00:10:45,360
this with the sync the

277
00:10:43,519 --> 00:10:47,920
the compiler will actually ensure that

278
00:10:45,360 --> 00:10:50,959
this value is consumed for all cases so

279
00:10:47,920 --> 00:10:50,959
you don't have to do that

280
00:10:52,480 --> 00:10:56,720
and there is some notion of what it

281
00:10:54,880 --> 00:10:57,600
means to consume something so we are

282
00:10:56,720 --> 00:11:01,200
going into

283
00:10:57,600 --> 00:11:02,000
destructors anyhow so there's a

284
00:11:01,200 --> 00:11:04,800
different

285
00:11:02,000 --> 00:11:06,800
problem okay so now i can put stuff into

286
00:11:04,800 --> 00:11:07,519
a hash table very effectively that's

287
00:11:06,800 --> 00:11:10,479
good

288
00:11:07,519 --> 00:11:11,120
how about how do i get values out of it

289
00:11:10,480 --> 00:11:14,160
and the game

290
00:11:11,120 --> 00:11:16,240
again the same problem like uh

291
00:11:14,160 --> 00:11:17,920
and this is a result equals is the same

292
00:11:16,240 --> 00:11:20,240
as return statement in

293
00:11:17,920 --> 00:11:21,760
in this case but i wrote it as an

294
00:11:20,240 --> 00:11:22,160
assignment so that it's more obvious

295
00:11:21,760 --> 00:11:25,439
that

296
00:11:22,160 --> 00:11:28,640
this again is an expensive copy so

297
00:11:25,440 --> 00:11:30,320
okay we can now try to move this

298
00:11:28,640 --> 00:11:33,120
and then you would the compiler will

299
00:11:30,320 --> 00:11:34,800
complain that t is actually not mutable

300
00:11:33,120 --> 00:11:39,200
like you you cannot move out of it

301
00:11:34,800 --> 00:11:42,399
because move mutates this the source

302
00:11:39,200 --> 00:11:43,040
okay so and then let's let's make it

303
00:11:42,399 --> 00:11:46,399
mutable

304
00:11:43,040 --> 00:11:48,640
okay this this works but now

305
00:11:46,399 --> 00:11:50,240
you need to think like what happens like

306
00:11:48,640 --> 00:11:52,720
you move the value out of

307
00:11:50,240 --> 00:11:54,480
this table so you can access it exactly

308
00:11:52,720 --> 00:11:57,040
once and then there's it's

309
00:11:54,480 --> 00:11:57,920
it's gone afterwards so that's pretty

310
00:11:57,040 --> 00:11:59,920
bad

311
00:11:57,920 --> 00:12:01,680
unless maybe i mean if you have a pop

312
00:11:59,920 --> 00:12:03,360
operation for your stack that's exactly

313
00:12:01,680 --> 00:12:05,120
what you want but for a hash table it's

314
00:12:03,360 --> 00:12:09,040
pretty shitty

315
00:12:05,120 --> 00:12:10,000
um so yeah we need another annotation

316
00:12:09,040 --> 00:12:13,599
which is landing

317
00:12:10,000 --> 00:12:15,519
a value or length v and this is then a

318
00:12:13,600 --> 00:12:16,800
borrowing operation so in rust this

319
00:12:15,519 --> 00:12:20,480
would be a borrowed cup

320
00:12:16,800 --> 00:12:23,040
pointer in c plus it's a ref

321
00:12:20,480 --> 00:12:24,240
so it's it's actually the same thing and

322
00:12:23,040 --> 00:12:27,519
yeah you need to

323
00:12:24,240 --> 00:12:29,600
ensure that once you borrow that this

324
00:12:27,519 --> 00:12:30,800
doesn't outlive the the collection's

325
00:12:29,600 --> 00:12:34,240
lifetime and stuff

326
00:12:30,800 --> 00:12:38,880
but um it's it's yeah

327
00:12:34,240 --> 00:12:38,880
it's like in

328
00:12:40,480 --> 00:12:43,440
yeah okay so the point is in rust it

329
00:12:41,839 --> 00:12:44,240
would be checked and c plus plus it

330
00:12:43,440 --> 00:12:47,360
wouldn't

331
00:12:44,240 --> 00:12:48,460
and in nim it is checked except that we

332
00:12:47,360 --> 00:12:51,279
need to be better

333
00:12:48,460 --> 00:12:55,120
[Laughter]

334
00:12:51,279 --> 00:12:57,839
so okay um so now that we have

335
00:12:55,120 --> 00:12:59,519
now that we understand how to optimize

336
00:12:57,839 --> 00:13:01,200
complex assignments like

337
00:12:59,519 --> 00:13:03,279
deep copies or whatever you want to call

338
00:13:01,200 --> 00:13:04,959
it we can apply this knowledge to

339
00:13:03,279 --> 00:13:07,279
something else like take reference

340
00:13:04,959 --> 00:13:10,079
counting reference counting is

341
00:13:07,279 --> 00:13:11,360
basically the pointer assignment simply

342
00:13:10,079 --> 00:13:13,599
got

343
00:13:11,360 --> 00:13:14,800
way more expensive than it used to be

344
00:13:13,600 --> 00:13:16,880
because

345
00:13:14,800 --> 00:13:18,399
if i copy a pointer around i need to

346
00:13:16,880 --> 00:13:18,880
increment the reference count of the

347
00:13:18,399 --> 00:13:20,639
source

348
00:13:18,880 --> 00:13:22,560
i need to decrement the reference count

349
00:13:20,639 --> 00:13:23,920
of the destination and then i can do the

350
00:13:22,560 --> 00:13:26,160
pointer copy

351
00:13:23,920 --> 00:13:28,560
but if i'm able to move the pointer then

352
00:13:26,160 --> 00:13:31,920
it could just be this bitwise copy

353
00:13:28,560 --> 00:13:34,160
and maybe nillify the source afterwards

354
00:13:31,920 --> 00:13:36,639
if required

355
00:13:34,160 --> 00:13:38,319
so this this this insight let's they led

356
00:13:36,639 --> 00:13:40,800
us to the development of a new

357
00:13:38,320 --> 00:13:42,320
garbage collector mode i mean it's

358
00:13:40,800 --> 00:13:45,439
called gc but

359
00:13:42,320 --> 00:13:47,199
gc is actually name nim's name for any

360
00:13:45,440 --> 00:13:48,720
kind of memory management that you want

361
00:13:47,199 --> 00:13:51,599
to

362
00:13:48,720 --> 00:13:52,560
um so and here i have a benchmark this

363
00:13:51,600 --> 00:13:56,399
is the binary

364
00:13:52,560 --> 00:14:00,160
like this is a standard benchmark for

365
00:13:56,399 --> 00:14:02,639
uh throughput of a garbage collector

366
00:14:00,160 --> 00:14:03,600
and so i'm i'm not ex i don't expect you

367
00:14:02,639 --> 00:14:07,120
to understand

368
00:14:03,600 --> 00:14:09,440
all of this but um the point is now here

369
00:14:07,120 --> 00:14:11,120
uh all the annotations like sinks and

370
00:14:09,440 --> 00:14:14,839
lens they are not there

371
00:14:11,120 --> 00:14:16,560
but even so they work under the hood for

372
00:14:14,839 --> 00:14:19,040
us and

373
00:14:16,560 --> 00:14:21,680
so we create binary trees and then

374
00:14:19,040 --> 00:14:24,800
trillions of these to some depth

375
00:14:21,680 --> 00:14:26,800
and this is the the main part um

376
00:14:24,800 --> 00:14:29,519
as i said it's a standard benchmark and

377
00:14:26,800 --> 00:14:31,439
the results are really really nice

378
00:14:29,519 --> 00:14:32,560
so we have a couple of garbage

379
00:14:31,440 --> 00:14:36,160
collectors so we can

380
00:14:32,560 --> 00:14:40,160
compare all them and the new one

381
00:14:36,160 --> 00:14:43,760
is fastest by by quite a lot

382
00:14:40,160 --> 00:14:46,160
like a factor of three of two or

383
00:14:43,760 --> 00:14:49,120
whatever you want to compare it with

384
00:14:46,160 --> 00:14:49,519
and uh memory consumption is about the

385
00:14:49,120 --> 00:14:52,000
same

386
00:14:49,519 --> 00:14:53,360
as before for burm gc i haven't been

387
00:14:52,000 --> 00:14:55,360
able to figure out the memory

388
00:14:53,360 --> 00:14:58,959
consumption precisely so that's

389
00:14:55,360 --> 00:15:03,199
that's not available um

390
00:14:58,959 --> 00:15:06,399
so this this um

391
00:15:03,199 --> 00:15:08,639
yeah so now the the question is okay

392
00:15:06,399 --> 00:15:10,880
this is very better than before

393
00:15:08,639 --> 00:15:12,720
how how does it compare to manual memory

394
00:15:10,880 --> 00:15:15,920
management

395
00:15:12,720 --> 00:15:17,199
and nim can do both so you can use your

396
00:15:15,920 --> 00:15:19,680
own ptrs

397
00:15:17,199 --> 00:15:22,240
so previously this was a ref in line

398
00:15:19,680 --> 00:15:25,199
four now it's a ptr

399
00:15:22,240 --> 00:15:25,760
and the to make a tree we have this

400
00:15:25,199 --> 00:15:29,839
nasty

401
00:15:25,760 --> 00:15:32,399
allocation with a cast in in line 12

402
00:15:29,839 --> 00:15:33,199
and of course we need to free the tree

403
00:15:32,399 --> 00:15:35,360
manually

404
00:15:33,199 --> 00:15:36,319
so this is the recursive free so first

405
00:15:35,360 --> 00:15:38,839
free the left

406
00:15:36,320 --> 00:15:40,399
then the right and then delocate this

407
00:15:38,839 --> 00:15:43,759
node

408
00:15:40,399 --> 00:15:45,040
and again this and now in the main part

409
00:15:43,759 --> 00:15:48,000
we have to

410
00:15:45,040 --> 00:15:50,399
free these trees uh manually which is

411
00:15:48,000 --> 00:15:52,639
very annoying so in line 18 for instance

412
00:15:50,399 --> 00:15:55,360
you can see this

413
00:15:52,639 --> 00:15:57,440
or in line 15 where you actually had to

414
00:15:55,360 --> 00:15:59,759
introduce a new temp variable just to be

415
00:15:57,440 --> 00:16:03,120
able to free it later on

416
00:15:59,759 --> 00:16:06,399
so um and the result is

417
00:16:03,120 --> 00:16:09,279
it's still it's still slower i'm sorry

418
00:16:06,399 --> 00:16:10,000
but um here is the thing what arc

419
00:16:09,279 --> 00:16:12,320
actually does

420
00:16:10,000 --> 00:16:13,360
it does it does optimize reference

421
00:16:12,320 --> 00:16:15,199
counting

422
00:16:13,360 --> 00:16:17,120
and what the manual version does is

423
00:16:15,199 --> 00:16:17,599
basically i don't have a reference count

424
00:16:17,120 --> 00:16:20,240
because

425
00:16:17,600 --> 00:16:21,040
i know these are unique pointers so if

426
00:16:20,240 --> 00:16:22,720
you add the

427
00:16:21,040 --> 00:16:24,399
just the the machine word for this

428
00:16:22,720 --> 00:16:25,440
reference count back to this manual

429
00:16:24,399 --> 00:16:28,920
version

430
00:16:25,440 --> 00:16:31,680
it's back to to almost the same to

431
00:16:28,920 --> 00:16:35,680
6.2 seconds uh

432
00:16:31,680 --> 00:16:38,000
whereas arc is at 6.7.7 seconds

433
00:16:35,680 --> 00:16:38,719
so there's still and and the memory

434
00:16:38,000 --> 00:16:41,759
consumption

435
00:16:38,720 --> 00:16:44,639
is identical uh under the

436
00:16:41,759 --> 00:16:47,279
assumption that i fixed this one bug

437
00:16:44,639 --> 00:16:47,279
that's left

438
00:16:47,680 --> 00:16:51,599
so we are getting close to manual memory

439
00:16:50,240 --> 00:16:53,920
management

440
00:16:51,600 --> 00:16:56,320
and for in this for this particular

441
00:16:53,920 --> 00:17:00,399
benchmark i think we can

442
00:16:56,320 --> 00:17:02,839
uh get to to get the difference into the

443
00:17:00,399 --> 00:17:05,839
noise level

444
00:17:02,839 --> 00:17:05,839
but

445
00:17:10,160 --> 00:17:17,839
no they are not we will get to there so

446
00:17:13,199 --> 00:17:19,679
um i'll yeah i'll get to that okay

447
00:17:17,839 --> 00:17:21,678
there's a different benchmark for

448
00:17:19,679 --> 00:17:22,480
latency i don't have the source code for

449
00:17:21,679 --> 00:17:25,199
this

450
00:17:22,480 --> 00:17:28,120
but previously we had a soft real-time

451
00:17:25,199 --> 00:17:31,760
garbage collector and the latency was

452
00:17:28,119 --> 00:17:34,639
0.0.3 milliseconds for this benchmark

453
00:17:31,760 --> 00:17:35,760
and now with arc the it's better by over

454
00:17:34,640 --> 00:17:39,200
a factor of three

455
00:17:35,760 --> 00:17:41,360
the total runtime has been reduced also

456
00:17:39,200 --> 00:17:42,400
and the the peak memory consumption is

457
00:17:41,360 --> 00:17:44,639
also better

458
00:17:42,400 --> 00:17:47,840
so not not just throughput is better but

459
00:17:44,640 --> 00:17:47,840
also late latency

460
00:17:49,039 --> 00:17:54,480
now i've already outlined it so what's

461
00:17:51,760 --> 00:17:57,120
going on under the hood is that we have

462
00:17:54,480 --> 00:17:58,400
destructors and move operators and

463
00:17:57,120 --> 00:18:00,320
assignments

464
00:17:58,400 --> 00:18:02,559
and you we can exploit them for other

465
00:18:00,320 --> 00:18:05,120
things like they are exposed to you

466
00:18:02,559 --> 00:18:06,160
uh we'll see in a minute so you can now

467
00:18:05,120 --> 00:18:08,399
make your files

468
00:18:06,160 --> 00:18:09,919
close automatically after you so that's

469
00:18:08,400 --> 00:18:12,320
very nice

470
00:18:09,919 --> 00:18:14,720
and this is there's better composition

471
00:18:12,320 --> 00:18:16,720
between this custom containers like

472
00:18:14,720 --> 00:18:19,600
previously we had like manual memory

473
00:18:16,720 --> 00:18:21,440
management ngc memory management and

474
00:18:19,600 --> 00:18:23,199
you must be careful to not to mix them

475
00:18:21,440 --> 00:18:24,000
very because it doesn't really work well

476
00:18:23,200 --> 00:18:26,559
but

477
00:18:24,000 --> 00:18:28,160
with these extension points the interop

478
00:18:26,559 --> 00:18:30,480
between these two worlds is much much

479
00:18:28,160 --> 00:18:33,280
better than before

480
00:18:30,480 --> 00:18:34,000
okay so here's another thing that we now

481
00:18:33,280 --> 00:18:36,720
can do

482
00:18:34,000 --> 00:18:38,160
again the same benchmark but now we want

483
00:18:36,720 --> 00:18:40,880
to have some object pool

484
00:18:38,160 --> 00:18:41,360
i think it's better called an arena so

485
00:18:40,880 --> 00:18:44,320
we have an

486
00:18:41,360 --> 00:18:45,280
arena allocator still dealing with these

487
00:18:44,320 --> 00:18:49,439
silly notes which

488
00:18:45,280 --> 00:18:52,160
only have two pointers inside um

489
00:18:49,440 --> 00:18:53,120
so to allocate the new node we basically

490
00:18:52,160 --> 00:18:55,120
check if there's

491
00:18:53,120 --> 00:18:56,320
a capacity left kind of like for a

492
00:18:55,120 --> 00:18:58,799
sequence

493
00:18:56,320 --> 00:18:59,439
and then we but the the note itself is a

494
00:18:58,799 --> 00:19:01,918
is an

495
00:18:59,440 --> 00:19:02,640
unchecked pointer so we take the address

496
00:19:01,919 --> 00:19:05,679
of the

497
00:19:02,640 --> 00:19:07,440
element in the array which is the the

498
00:19:05,679 --> 00:19:10,720
backup storage for our

499
00:19:07,440 --> 00:19:13,200
node and now

500
00:19:10,720 --> 00:19:13,919
here we can say look if you want to copy

501
00:19:13,200 --> 00:19:15,840
a pool

502
00:19:13,919 --> 00:19:17,280
it's not supported because i couldn't be

503
00:19:15,840 --> 00:19:19,840
bothered to implement it

504
00:19:17,280 --> 00:19:20,399
and so if you try to copy the full pool

505
00:19:19,840 --> 00:19:23,280
around

506
00:19:20,400 --> 00:19:26,000
accidentally the compiler will complain

507
00:19:23,280 --> 00:19:29,280
and tell you like no you you can't

508
00:19:26,000 --> 00:19:29,679
and if this go if the pool goes gets out

509
00:19:29,280 --> 00:19:31,360
of

510
00:19:29,679 --> 00:19:33,760
goes out of scope the destructor is

511
00:19:31,360 --> 00:19:35,439
called so this is in line three

512
00:19:33,760 --> 00:19:36,879
and of course what what do you do in a

513
00:19:35,440 --> 00:19:40,320
destructor well you free this

514
00:19:36,880 --> 00:19:42,880
the the blocks of memory that's been

515
00:19:40,320 --> 00:19:46,879
the them and they have been chained in a

516
00:19:42,880 --> 00:19:50,320
linked list via this this next pointer

517
00:19:46,880 --> 00:19:52,320
and yeah and then the you need to change

518
00:19:50,320 --> 00:19:53,678
the program unfortunately so if you want

519
00:19:52,320 --> 00:19:55,600
to make a tree

520
00:19:53,679 --> 00:19:57,280
you need to be aware of this pool where

521
00:19:55,600 --> 00:19:59,439
to get the new notes from and

522
00:19:57,280 --> 00:20:00,399
so this is becomes a parameter of this

523
00:19:59,440 --> 00:20:03,919
make tree and

524
00:20:00,400 --> 00:20:06,960
recursively you need to to pass it on

525
00:20:03,919 --> 00:20:10,480
as you can see in line 11 and 12

526
00:20:06,960 --> 00:20:14,159
and now uh the bench

527
00:20:10,480 --> 00:20:17,360
okay and now it's

528
00:20:14,159 --> 00:20:19,039
it's um a bit easier to use because

529
00:20:17,360 --> 00:20:22,240
these pools are free

530
00:20:19,039 --> 00:20:24,720
for us afterwards automatically

531
00:20:22,240 --> 00:20:25,520
and in this case i had to make two three

532
00:20:24,720 --> 00:20:27,840
uh

533
00:20:25,520 --> 00:20:29,120
two pools like a one for the long lift

534
00:20:27,840 --> 00:20:31,840
data

535
00:20:29,120 --> 00:20:34,239
and one for the short lift data so that

536
00:20:31,840 --> 00:20:37,840
you can see this in line

537
00:20:34,240 --> 00:20:41,600
5 and 14

538
00:20:37,840 --> 00:20:45,760
and the question is

539
00:20:41,600 --> 00:20:48,959
how does it perform so

540
00:20:45,760 --> 00:20:50,960
that's the result it's it's still much

541
00:20:48,960 --> 00:20:52,799
faster

542
00:20:50,960 --> 00:20:56,000
over a factor of two performance

543
00:20:52,799 --> 00:20:59,600
improvement and memory consumption is

544
00:20:56,000 --> 00:20:59,600
roughly the same i mean

545
00:21:01,360 --> 00:21:03,840
so yeah

546
00:21:05,440 --> 00:21:10,080
okay so in summary move semantics mostly

547
00:21:08,400 --> 00:21:12,960
work under the hood for us

548
00:21:10,080 --> 00:21:14,960
they give us really good uh

549
00:21:12,960 --> 00:21:17,679
optimizations

550
00:21:14,960 --> 00:21:18,720
five minutes left okay um yeah we have

551
00:21:17,679 --> 00:21:21,120
seen the speed ups

552
00:21:18,720 --> 00:21:22,320
and they make the memory management

553
00:21:21,120 --> 00:21:25,600
deterministic

554
00:21:22,320 --> 00:21:27,678
so what's actually the case here

555
00:21:25,600 --> 00:21:29,520
so if you use a reference counting

556
00:21:27,679 --> 00:21:32,320
scheme and optimize it

557
00:21:29,520 --> 00:21:34,559
what you can do is you can attach a cost

558
00:21:32,320 --> 00:21:36,480
model to your programming language

559
00:21:34,559 --> 00:21:38,559
and once you do that you you get into

560
00:21:36,480 --> 00:21:40,480
the realm of hard real-time systems so

561
00:21:38,559 --> 00:21:41,600
you can use nim for hard real-time

562
00:21:40,480 --> 00:21:44,720
system

563
00:21:41,600 --> 00:21:45,280
with this technology we have seen it

564
00:21:44,720 --> 00:21:48,400
improves

565
00:21:45,280 --> 00:21:50,879
throughput latency memory consumption

566
00:21:48,400 --> 00:21:52,799
and threading well i have no don't have

567
00:21:50,880 --> 00:21:55,360
an example but as you can imagine

568
00:21:52,799 --> 00:21:56,720
if you can move data from one thread to

569
00:21:55,360 --> 00:22:00,158
the other

570
00:21:56,720 --> 00:22:01,280
it's uh it's uh and because you are

571
00:22:00,159 --> 00:22:03,840
guaranteed that

572
00:22:01,280 --> 00:22:04,639
this is kind of the last user of this

573
00:22:03,840 --> 00:22:06,879
data

574
00:22:04,640 --> 00:22:08,159
then you you cannot have data races so

575
00:22:06,880 --> 00:22:11,200
it's a very nice

576
00:22:08,159 --> 00:22:12,880
uh feature of that um

577
00:22:11,200 --> 00:22:14,799
yeah it also improves the the ease of

578
00:22:12,880 --> 00:22:17,360
programming like just imagine

579
00:22:14,799 --> 00:22:19,039
your files clause automatically and your

580
00:22:17,360 --> 00:22:22,399
sockets

581
00:22:19,039 --> 00:22:23,280
and we get a better composition between

582
00:22:22,400 --> 00:22:27,520
these different

583
00:22:23,280 --> 00:22:31,760
uh container classes let's say

584
00:22:27,520 --> 00:22:33,360
okay yeah you can

585
00:22:31,760 --> 00:22:35,520
play with these benchmarks i have

586
00:22:33,360 --> 00:22:37,840
uploaded them to github

587
00:22:35,520 --> 00:22:39,679
and yeah if you don't know already this

588
00:22:37,840 --> 00:22:42,720
is our website and the forum

589
00:22:39,679 --> 00:22:47,360
and we are active on irc as well

590
00:22:42,720 --> 00:22:47,360
so that's my talk thank you for your

591
00:22:52,840 --> 00:22:56,799
attention

592
00:22:55,039 --> 00:22:59,440
also the next speaker should come up and

593
00:22:56,799 --> 00:22:59,440
start preparing

594
00:23:00,159 --> 00:23:06,720
okay questions yeah so is this

595
00:23:03,520 --> 00:23:09,840
available um right now or is this

596
00:23:06,720 --> 00:23:12,080
still a work in progress um well it's on

597
00:23:09,840 --> 00:23:13,199
github in the development oh sorry i

598
00:23:12,080 --> 00:23:15,520
need to repeat the question

599
00:23:13,200 --> 00:23:18,080
so the question is how to get it um it's

600
00:23:15,520 --> 00:23:20,480
not in the version one of the language

601
00:23:18,080 --> 00:23:22,158
it's be well it will be our next major

602
00:23:20,480 --> 00:23:24,320
release this year

603
00:23:22,159 --> 00:23:26,320
but you can already use it if you want

604
00:23:24,320 --> 00:23:29,918
to if you use the devil

605
00:23:26,320 --> 00:23:32,158
development version of them yeah

606
00:23:29,919 --> 00:23:32,159
yes

607
00:23:34,000 --> 00:23:44,240
the threading but no okay oh sorry sorry

608
00:23:38,880 --> 00:23:44,240
okay we'll come back okay next question

609
00:23:44,640 --> 00:23:46,880
yes

610
00:23:48,400 --> 00:23:55,120
for what ah own refs um

611
00:23:52,320 --> 00:23:56,399
so yeah we've been tinkering with owned

612
00:23:55,120 --> 00:24:00,399
refs which is kind of

613
00:23:56,400 --> 00:24:03,360
unique pointers um nymph style

614
00:24:00,400 --> 00:24:04,960
um but i did these benchmarks and i

615
00:24:03,360 --> 00:24:08,080
noticed that

616
00:24:04,960 --> 00:24:09,840
it doesn't pay off like it's it's um so

617
00:24:08,080 --> 00:24:12,080
for instance you can use this binary

618
00:24:09,840 --> 00:24:14,799
tree benchmark with owned annotations

619
00:24:12,080 --> 00:24:15,520
and use this new runtime and i got the

620
00:24:14,799 --> 00:24:17,679
same number

621
00:24:15,520 --> 00:24:18,639
so in this case we didn't see the

622
00:24:17,679 --> 00:24:22,559
benefit

623
00:24:18,640 --> 00:24:25,760
and so um currently we do not

624
00:24:22,559 --> 00:24:25,760
know what to do with owned

625
00:24:25,919 --> 00:24:29,360
yes so my question was uh how do you

626
00:24:28,480 --> 00:24:31,919
define

627
00:24:29,360 --> 00:24:32,879
visible after and in particular how

628
00:24:31,919 --> 00:24:34,320
subtle are you

629
00:24:32,880 --> 00:24:37,520
when there are if statements and stuff

630
00:24:34,320 --> 00:24:40,399
like that okay okay so the question is

631
00:24:37,520 --> 00:24:42,240
okay are you familiar with the void

632
00:24:40,400 --> 00:24:46,240
safety

633
00:24:42,240 --> 00:24:49,039
safety like from um

634
00:24:46,240 --> 00:24:50,480
so void in eiffel is equivalent yes yes

635
00:24:49,039 --> 00:24:52,960
safety

636
00:24:50,480 --> 00:24:52,960
okay okay

637
00:24:54,640 --> 00:24:58,159
okay okay so two two questions the first

638
00:24:57,360 --> 00:25:00,320
was uh

639
00:24:58,159 --> 00:25:01,679
how do we know that it's the last usage

640
00:25:00,320 --> 00:25:03,360
of a variable

641
00:25:01,679 --> 00:25:07,200
the answer is we have a control flow

642
00:25:03,360 --> 00:25:07,199
graph and we track these precisely

643
00:25:10,080 --> 00:25:16,720
um well it's in its conditional then

644
00:25:13,279 --> 00:25:20,159
it we know this like um

645
00:25:16,720 --> 00:25:23,679
say you you move it in every case

646
00:25:20,159 --> 00:25:26,400
then or you you um

647
00:25:23,679 --> 00:25:27,440
how to put it so let's say you move

648
00:25:26,400 --> 00:25:30,640
something

649
00:25:27,440 --> 00:25:32,240
in a loop yes and it's used you know

650
00:25:30,640 --> 00:25:33,360
it's moved every time except the last

651
00:25:32,240 --> 00:25:36,880
one

652
00:25:33,360 --> 00:25:38,639
um yeah we noticed that i mean

653
00:25:36,880 --> 00:25:40,840
the compiler will tell you i cannot move

654
00:25:38,640 --> 00:25:43,760
because you use it in the next loop

655
00:25:40,840 --> 00:25:47,600
iteration

656
00:25:43,760 --> 00:25:51,200
exactly too smart about that we are

657
00:25:47,600 --> 00:25:51,199
smart enough about it in practice

658
00:25:52,320 --> 00:25:55,439
the second question is void safety on

659
00:25:54,240 --> 00:25:59,039
the ability

660
00:25:55,440 --> 00:26:01,919
um it's uh

661
00:25:59,039 --> 00:26:02,240
it's also like work in progress like we

662
00:26:01,919 --> 00:26:04,320
we

663
00:26:02,240 --> 00:26:05,279
want this not nil annotation in the

664
00:26:04,320 --> 00:26:08,960
language to

665
00:26:05,279 --> 00:26:11,039
to guard us against this and

666
00:26:08,960 --> 00:26:13,279
you're right like if you use an explicit

667
00:26:11,039 --> 00:26:15,600
move you need a value to have

668
00:26:13,279 --> 00:26:16,880
afterwards to put inside your this the

669
00:26:15,600 --> 00:26:18,639
source and then

670
00:26:16,880 --> 00:26:20,159
you need to make the pointer nilible

671
00:26:18,640 --> 00:26:23,919
just for that

672
00:26:20,159 --> 00:26:25,200
right but if you use an implicit move we

673
00:26:23,919 --> 00:26:27,520
know it's not going to use

674
00:26:25,200 --> 00:26:28,400
afterwards so we can simply pretend that

675
00:26:27,520 --> 00:26:30,799
nil is not a

676
00:26:28,400 --> 00:26:32,880
really value for your for your pointer

677
00:26:30,799 --> 00:26:33,440
so the reason i was pointing to void

678
00:26:32,880 --> 00:26:35,679
safety

679
00:26:33,440 --> 00:26:37,520
is because in the case of iphone they

680
00:26:35,679 --> 00:26:40,559
decided to have things like

681
00:26:37,520 --> 00:26:42,720
if blah then as

682
00:26:40,559 --> 00:26:44,799
and they can say for instance if my test

683
00:26:42,720 --> 00:26:46,799
is specifically on that test

684
00:26:44,799 --> 00:26:49,039
then in the then part is considered to

685
00:26:46,799 --> 00:26:50,799
be void safe in the s part

686
00:26:49,039 --> 00:26:52,158
okay could do the same thing for moves

687
00:26:50,799 --> 00:26:55,039
but decide that

688
00:26:52,159 --> 00:26:55,760
if i have my roof semantics inside an if

689
00:26:55,039 --> 00:26:58,320
you know

690
00:26:55,760 --> 00:27:00,158
inside if i'm in the condition for the

691
00:26:58,320 --> 00:27:00,399
test then i can keep the move semantics

692
00:27:00,159 --> 00:27:02,240
and

693
00:27:00,400 --> 00:27:04,080
else i cannot okay that's what i was

694
00:27:02,240 --> 00:27:05,120
referring to for being smart about the

695
00:27:04,080 --> 00:27:08,080
next one

696
00:27:05,120 --> 00:27:09,760
i need to think about it you do have

697
00:27:08,080 --> 00:27:13,520
time for another question if you want oh

698
00:27:09,760 --> 00:27:13,520
really so yeah okay one question

699
00:27:15,760 --> 00:27:19,760
yeah we have to wait update okay it's

700
00:27:18,240 --> 00:27:23,200
not actually a question

701
00:27:19,760 --> 00:27:23,679
okay good i just want to say a big thank

702
00:27:23,200 --> 00:27:26,480
you

703
00:27:23,679 --> 00:27:27,440
because i learned that meme last year in

704
00:27:26,480 --> 00:27:31,039
boston

705
00:27:27,440 --> 00:27:34,799
in the presentation and i have to say

706
00:27:31,039 --> 00:27:36,158
you big thank you because you saved him

707
00:27:34,799 --> 00:27:38,810
from the dilemma

708
00:27:36,159 --> 00:27:41,919
if i had to use gold

709
00:27:38,810 --> 00:27:49,840
[Laughter]

710
00:27:41,919 --> 00:27:49,840
so you're welcome

711
00:27:51,520 --> 00:27:53,600
you

