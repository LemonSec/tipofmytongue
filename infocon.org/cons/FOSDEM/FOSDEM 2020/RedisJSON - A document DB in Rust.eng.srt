1
00:00:08,639 --> 00:00:11,120
great after these

2
00:00:09,679 --> 00:00:12,160
technical hiccups let's get started

3
00:00:11,120 --> 00:00:12,879
let's get started my name is chris

4
00:00:12,160 --> 00:00:14,880
simmerman

5
00:00:12,880 --> 00:00:16,880
i'm here to talk about what is json a

6
00:00:14,880 --> 00:00:19,680
document db in rust

7
00:00:16,880 --> 00:00:20,480
um i have about 40 40 45 minutes right

8
00:00:19,680 --> 00:00:21,920
so

9
00:00:20,480 --> 00:00:23,680
questions please at the end i'm

10
00:00:21,920 --> 00:00:25,680
available in the hallway afterwards so

11
00:00:23,680 --> 00:00:27,680
feel free to kind of grab me

12
00:00:25,680 --> 00:00:29,840
um if you have any kind of topics or

13
00:00:27,680 --> 00:00:31,439
this or discussion points first of all

14
00:00:29,840 --> 00:00:32,880
i'm going to dedicate this talk to my

15
00:00:31,439 --> 00:00:34,079
son luca who cannot be there

16
00:00:32,880 --> 00:00:36,640
if you're watching the stream look out

17
00:00:34,079 --> 00:00:38,559
this is for you second dedication is

18
00:00:36,640 --> 00:00:39,440
actually to something got the cto team

19
00:00:38,559 --> 00:00:42,239
at redis

20
00:00:39,440 --> 00:00:43,599
labs who are the people behind the code

21
00:00:42,239 --> 00:00:47,120
base

22
00:00:43,600 --> 00:00:48,320
who am i um i don't go through all of

23
00:00:47,120 --> 00:00:51,199
the details

24
00:00:48,320 --> 00:00:53,760
suffice it to say i help a lock in

25
00:00:51,199 --> 00:00:56,960
frankfurt

26
00:00:53,760 --> 00:00:59,358
i'm a large package maintainer blatant

27
00:00:56,960 --> 00:01:01,520
blatant pluck i'm going to run the linux

28
00:00:59,359 --> 00:01:03,760
biervandong this year in colenburg

29
00:01:01,520 --> 00:01:05,360
so if you have a week at the end of

30
00:01:03,760 --> 00:01:07,920
august early september

31
00:01:05,360 --> 00:01:09,600
to join about 20 30 people for

32
00:01:07,920 --> 00:01:12,880
discussions

33
00:01:09,600 --> 00:01:13,919
um hackathons presentations hiking and

34
00:01:12,880 --> 00:01:16,839
of course beer

35
00:01:13,920 --> 00:01:18,320
check out the website um it's actually

36
00:01:16,840 --> 00:01:21,520
linuxvillebynum.com

37
00:01:18,320 --> 00:01:25,839
or monochrome c forward slash lbw

38
00:01:21,520 --> 00:01:27,439
monochrome com forward slash lbw 2020.

39
00:01:25,840 --> 00:01:29,520
plug and then i'm gonna finish with the

40
00:01:27,439 --> 00:01:31,839
plugs i run a podcast

41
00:01:29,520 --> 00:01:34,479
i just we just posted the first episode

42
00:01:31,840 --> 00:01:36,960
it's called linux in-laws

43
00:01:34,479 --> 00:01:38,880
domain has la has gone live yesterday

44
00:01:36,960 --> 00:01:41,119
first episode will be aired

45
00:01:38,880 --> 00:01:42,079
on hakka public radio hpr is your go to

46
00:01:41,119 --> 00:01:45,680
source

47
00:01:42,079 --> 00:01:48,479
on the um 13th of

48
00:01:45,680 --> 00:01:48,880
february um it's open source with the

49
00:01:48,479 --> 00:01:52,399
dark

50
00:01:48,880 --> 00:01:55,600
side humor twisting plugs over

51
00:01:52,399 --> 00:01:57,280
um hobbies includes suffered a software

52
00:01:55,600 --> 00:01:58,960
development life cycle that's what i'm

53
00:01:57,280 --> 00:02:02,719
dealing with for the last what

54
00:01:58,960 --> 00:02:04,559
um 20 20 25 years i've been using open

55
00:02:02,719 --> 00:02:05,679
source for the last 30 years 30 plus

56
00:02:04,560 --> 00:02:08,800
years

57
00:02:05,680 --> 00:02:10,399
um i'm also dabbling in rt security and

58
00:02:08,800 --> 00:02:11,680
if i still have the time

59
00:02:10,399 --> 00:02:13,760
i work for a company called writer's

60
00:02:11,680 --> 00:02:17,040
labs full disclosure

61
00:02:13,760 --> 00:02:18,720
as a solution architect and liaison um

62
00:02:17,040 --> 00:02:20,720
a couple of things basically what this

63
00:02:18,720 --> 00:02:23,040
talk is all about first of all

64
00:02:20,720 --> 00:02:24,640
how many how many of you have used redis

65
00:02:23,040 --> 00:02:26,959
or know what radius is

66
00:02:24,640 --> 00:02:28,160
wow okay um there are a couple of in the

67
00:02:26,959 --> 00:02:29,760
intro slides i'm going to go

68
00:02:28,160 --> 00:02:31,599
through them fairly quickly because if

69
00:02:29,760 --> 00:02:33,359
the majority is already familiar with

70
00:02:31,599 --> 00:02:34,399
redis there's a point in repeating these

71
00:02:33,360 --> 00:02:36,160
details

72
00:02:34,400 --> 00:02:39,040
then i'm going to talk about a little

73
00:02:36,160 --> 00:02:41,680
bit about the architecture

74
00:02:39,040 --> 00:02:43,840
with a special focus on how applications

75
00:02:41,680 --> 00:02:47,120
perceive this document db

76
00:02:43,840 --> 00:02:50,879
written in rust and of course um summary

77
00:02:47,120 --> 00:02:52,800
and outlook will conclude this talk

78
00:02:50,879 --> 00:02:54,640
um as i said i'm going to go through

79
00:02:52,800 --> 00:02:57,120
this fairly quickly suffice it

80
00:02:54,640 --> 00:02:57,760
to redis is suffice it to say redis is

81
00:02:57,120 --> 00:03:00,000
one of the

82
00:02:57,760 --> 00:03:02,159
kind of leading in-memory databases it

83
00:03:00,000 --> 00:03:06,800
was about it was founded

84
00:03:02,159 --> 00:03:07,359
about 10 years ago we have more than 25

85
00:03:06,800 --> 00:03:11,000
000

86
00:03:07,360 --> 00:03:13,680
github stars there are more than

87
00:03:11,000 --> 00:03:15,200
162 clients written in more than 57

88
00:03:13,680 --> 00:03:17,040
programming language

89
00:03:15,200 --> 00:03:20,079
program languages i reckon that makes

90
00:03:17,040 --> 00:03:21,920
redis one of the most loved databases

91
00:03:20,080 --> 00:03:24,720
when it comes down to client

92
00:03:21,920 --> 00:03:24,720
connectivity

93
00:03:24,959 --> 00:03:32,239
um how many of you actually have

94
00:03:28,080 --> 00:03:34,879
programmed against redis

95
00:03:32,239 --> 00:03:36,959
and i reckon most of you did this any

96
00:03:34,879 --> 00:03:38,079
caching use case right or as part of a

97
00:03:36,959 --> 00:03:39,599
caching use case

98
00:03:38,080 --> 00:03:41,120
this is basically where redis comes from

99
00:03:39,599 --> 00:03:43,040
about 10 years ago

100
00:03:41,120 --> 00:03:44,959
the project initiator somebody called

101
00:03:43,040 --> 00:03:46,640
salvatores on philippo was looking for

102
00:03:44,959 --> 00:03:50,239
performant

103
00:03:46,640 --> 00:03:53,119
reporting database for one of his web

104
00:03:50,239 --> 00:03:54,560
um projects he checked out memcached he

105
00:03:53,120 --> 00:03:55,599
checked out other solutions they didn't

106
00:03:54,560 --> 00:03:58,239
check out

107
00:03:55,599 --> 00:04:00,159
so he came up he wrote his own database

108
00:03:58,239 --> 00:04:02,000
as a key value store initially this is

109
00:04:00,159 --> 00:04:05,280
basically where redis comes from

110
00:04:02,000 --> 00:04:07,040
does anybody know what reddit stands for

111
00:04:05,280 --> 00:04:08,640
remote dictionary server this is what

112
00:04:07,040 --> 00:04:10,720
this is what this is it

113
00:04:08,640 --> 00:04:12,559
but over the years redis have has

114
00:04:10,720 --> 00:04:16,079
evolved into much much more

115
00:04:12,560 --> 00:04:18,160
in about 2015 salvatore introduced

116
00:04:16,079 --> 00:04:19,199
something called the module sdk to the

117
00:04:18,160 --> 00:04:22,800
code base

118
00:04:19,199 --> 00:04:24,560
that allows um the initial

119
00:04:22,800 --> 00:04:26,240
redis server implementation to be

120
00:04:24,560 --> 00:04:28,560
extended with so-called modules and

121
00:04:26,240 --> 00:04:31,120
registration is one of them

122
00:04:28,560 --> 00:04:32,320
the idea is to take your native rudder's

123
00:04:31,120 --> 00:04:35,360
implementation

124
00:04:32,320 --> 00:04:36,880
and to provi and to plug any gaps

125
00:04:35,360 --> 00:04:38,800
that you may perceive from an

126
00:04:36,880 --> 00:04:41,919
application perspective

127
00:04:38,800 --> 00:04:43,040
with with with functionality implemented

128
00:04:41,919 --> 00:04:46,799
in the modules

129
00:04:43,040 --> 00:04:49,120
so over the years there have been

130
00:04:46,800 --> 00:04:51,199
modules in the era of graph redis graph

131
00:04:49,120 --> 00:04:54,400
turns redis into a very performant

132
00:04:51,199 --> 00:04:56,560
graph database full software compliant

133
00:04:54,400 --> 00:04:59,919
compliant interfaces

134
00:04:56,560 --> 00:05:01,440
similar to new 4j um there's something

135
00:04:59,919 --> 00:05:03,919
called time series

136
00:05:01,440 --> 00:05:06,400
that turn redis into a time series

137
00:05:03,919 --> 00:05:09,599
database comparable in functionality to

138
00:05:06,400 --> 00:05:12,080
something called influx db and so forth

139
00:05:09,600 --> 00:05:13,199
the beauty is that all these extensions

140
00:05:12,080 --> 00:05:15,120
are on github

141
00:05:13,199 --> 00:05:17,440
so if you're looking for performance um

142
00:05:15,120 --> 00:05:20,720
graph database simply clone the redis

143
00:05:17,440 --> 00:05:23,120
server size clone the graph module

144
00:05:20,720 --> 00:05:24,560
compile the whole thing load the module

145
00:05:23,120 --> 00:05:26,000
when you start up the server

146
00:05:24,560 --> 00:05:28,560
and then you have a full software

147
00:05:26,000 --> 00:05:33,199
compliant graph database in memory

148
00:05:28,560 --> 00:05:35,199
at your disposal the idea was

149
00:05:33,199 --> 00:05:37,039
to turn redis with these modules to turn

150
00:05:35,199 --> 00:05:39,759
redis into something very application

151
00:05:37,039 --> 00:05:41,919
specific while maintaining

152
00:05:39,759 --> 00:05:43,759
the advantages that native reddish

153
00:05:41,919 --> 00:05:45,599
brings with it namely low latency and

154
00:05:43,759 --> 00:05:48,479
high throughput

155
00:05:45,600 --> 00:05:50,320
this the online this is the kind of idea

156
00:05:48,479 --> 00:05:52,479
and the modules yet that you see on the

157
00:05:50,320 --> 00:05:53,919
screen are just the ones provided by

158
00:05:52,479 --> 00:05:56,080
redis labs

159
00:05:53,919 --> 00:05:57,919
there are many more modules out there in

160
00:05:56,080 --> 00:06:01,198
the world living on github

161
00:05:57,919 --> 00:06:02,960
um so if you if you

162
00:06:01,199 --> 00:06:04,560
think redis doesn't offer something that

163
00:06:02,960 --> 00:06:06,400
you need simply

164
00:06:04,560 --> 00:06:08,800
deploy your favorite search engine and

165
00:06:06,400 --> 00:06:10,560
google for a module extension

166
00:06:08,800 --> 00:06:13,039
chances are somebody has written

167
00:06:10,560 --> 00:06:15,039
something that you can either clone

168
00:06:13,039 --> 00:06:17,360
or deploy natively right as in right

169
00:06:15,039 --> 00:06:17,360
away

170
00:06:17,840 --> 00:06:23,359
okay again this is native redis i won't

171
00:06:21,600 --> 00:06:25,199
spend too much time on it but this is

172
00:06:23,360 --> 00:06:28,000
what native redis

173
00:06:25,199 --> 00:06:29,600
offers out of the box and the majority

174
00:06:28,000 --> 00:06:31,680
of the modules would fall back

175
00:06:29,600 --> 00:06:32,639
on these generic data types including

176
00:06:31,680 --> 00:06:35,440
strings

177
00:06:32,639 --> 00:06:37,120
sets sorted sets hyperlock lock which is

178
00:06:35,440 --> 00:06:37,919
a probabilistic data structure and so

179
00:06:37,120 --> 00:06:40,319
forth

180
00:06:37,919 --> 00:06:41,120
um as i said this comes with native

181
00:06:40,319 --> 00:06:43,759
redis

182
00:06:41,120 --> 00:06:45,440
this has been in the code base since

183
00:06:43,759 --> 00:06:47,360
pretty much day one

184
00:06:45,440 --> 00:06:49,120
most of the client-side implementations

185
00:06:47,360 --> 00:06:51,680
would reflect these data structures

186
00:06:49,120 --> 00:06:52,560
either as part of their local ecosystem

187
00:06:51,680 --> 00:06:55,680
as in larvae

188
00:06:52,560 --> 00:06:59,440
client library site or written in index

189
00:06:55,680 --> 00:07:02,080
by an extension and

190
00:06:59,440 --> 00:07:03,280
what is what is json all about you have

191
00:07:02,080 --> 00:07:05,359
your native reddish

192
00:07:03,280 --> 00:07:07,119
and then you have something called redis

193
00:07:05,360 --> 00:07:10,240
json which is essentially

194
00:07:07,120 --> 00:07:13,039
an ekma 404 compliant module

195
00:07:10,240 --> 00:07:16,240
that turns redis into document oriented

196
00:07:13,039 --> 00:07:20,719
db in functionality comparable to

197
00:07:16,240 --> 00:07:20,720
other document or oriented databases

198
00:07:20,800 --> 00:07:24,639
if you see this if you see this

199
00:07:22,400 --> 00:07:28,000
couchbase you know what i mean

200
00:07:24,639 --> 00:07:29,120
okay you have your typical json commands

201
00:07:28,000 --> 00:07:31,520
that allow you to

202
00:07:29,120 --> 00:07:32,720
in the documents that would be json set

203
00:07:31,520 --> 00:07:34,719
that allow you to

204
00:07:32,720 --> 00:07:36,639
retrieve documents from a database that

205
00:07:34,720 --> 00:07:38,639
would be json get but also

206
00:07:36,639 --> 00:07:41,520
because json offers ray and all the rest

207
00:07:38,639 --> 00:07:43,440
of it um you have json array append and

208
00:07:41,520 --> 00:07:44,080
json array insert which allow allows

209
00:07:43,440 --> 00:07:48,400
essentially

210
00:07:44,080 --> 00:07:52,080
to insert elements into a an array

211
00:07:48,400 --> 00:07:55,280
and basically append them at the end

212
00:07:52,080 --> 00:07:55,599
the navigation is done by json path who

213
00:07:55,280 --> 00:07:58,239
have

214
00:07:55,599 --> 00:07:59,039
you who of you have used jsonpath in the

215
00:07:58,240 --> 00:08:00,639
in the past

216
00:07:59,039 --> 00:08:02,400
okay not that many okay so i'm going to

217
00:08:00,639 --> 00:08:04,319
spend a little bit more time on this

218
00:08:02,400 --> 00:08:06,400
uh again just deploy your favorite

219
00:08:04,319 --> 00:08:09,280
search engine of choice

220
00:08:06,400 --> 00:08:10,799
um jsonpath is if you're looking for the

221
00:08:09,280 --> 00:08:14,318
specification json path

222
00:08:10,800 --> 00:08:16,240
essentially is in is a standardized way

223
00:08:14,319 --> 00:08:18,800
similar to a document object model if

224
00:08:16,240 --> 00:08:20,960
you know what that means as in dom

225
00:08:18,800 --> 00:08:22,319
that allow you to access data into that

226
00:08:20,960 --> 00:08:25,599
allow you to access data

227
00:08:22,319 --> 00:08:28,000
in a json document so essentially

228
00:08:25,599 --> 00:08:31,440
if you write and all of these kind of

229
00:08:28,000 --> 00:08:34,640
levels are separated by simple dots

230
00:08:31,440 --> 00:08:35,519
um or you can use array notation to

231
00:08:34,640 --> 00:08:38,838
access

232
00:08:35,519 --> 00:08:40,959
these uh levels so the following is

233
00:08:38,839 --> 00:08:42,000
equivalent.bar by the way an initial

234
00:08:40,958 --> 00:08:44,640
period also

235
00:08:42,000 --> 00:08:46,399
always reflects the root of the dom of

236
00:08:44,640 --> 00:08:47,600
the object of the document object model

237
00:08:46,399 --> 00:08:50,720
that's one that's something

238
00:08:47,600 --> 00:08:54,240
very important to keep in mind um so

239
00:08:50,720 --> 00:08:57,519
dot foo dot bar is um

240
00:08:54,240 --> 00:08:58,240
equivalent to um the first array in this

241
00:08:57,519 --> 00:09:00,560
in

242
00:08:58,240 --> 00:09:02,480
in this level which is with which comes

243
00:09:00,560 --> 00:09:05,199
after who which is essentially bar

244
00:09:02,480 --> 00:09:06,880
or you can write um all or you can write

245
00:09:05,200 --> 00:09:08,640
it all in array notation

246
00:09:06,880 --> 00:09:10,880
simple as that and something very

247
00:09:08,640 --> 00:09:11,600
important also you've also find this in

248
00:09:10,880 --> 00:09:14,160
in

249
00:09:11,600 --> 00:09:15,360
dom query languages is the support for

250
00:09:14,160 --> 00:09:18,240
wildcards

251
00:09:15,360 --> 00:09:20,480
so um if you are unsure about specific

252
00:09:18,240 --> 00:09:22,959
selector just insert a star for example

253
00:09:20,480 --> 00:09:24,560
and you will get back the corresponding

254
00:09:22,959 --> 00:09:27,680
array the corresponding document that

255
00:09:24,560 --> 00:09:27,680
reflects that path

256
00:09:28,800 --> 00:09:32,560
how does it look like from the server

257
00:09:30,640 --> 00:09:34,880
side um

258
00:09:32,560 --> 00:09:36,000
you have the native server and this is

259
00:09:34,880 --> 00:09:38,240
generic this is not

260
00:09:36,000 --> 00:09:39,120
registration specific you have

261
00:09:38,240 --> 00:09:41,120
essentially the

262
00:09:39,120 --> 00:09:44,440
reddit server that is running on by the

263
00:09:41,120 --> 00:09:47,760
way what port can anybody tell me

264
00:09:44,440 --> 00:09:47,760
6379 right

265
00:09:47,920 --> 00:09:51,279
very something very important if you

266
00:09:49,680 --> 00:09:53,040
want to if you want to access

267
00:09:51,279 --> 00:09:54,800
redis from the from the outside make

268
00:09:53,040 --> 00:09:55,439
sure that your firewall is open for that

269
00:09:54,800 --> 00:09:58,800
port or

270
00:09:55,440 --> 00:10:00,399
kind of fortified correctly so um all

271
00:09:58,800 --> 00:10:02,240
communication goes through a wire

272
00:10:00,399 --> 00:10:03,920
protocol called resp

273
00:10:02,240 --> 00:10:05,279
um between the server and the

274
00:10:03,920 --> 00:10:06,959
implementation on the client-side

275
00:10:05,279 --> 00:10:10,240
libraries and

276
00:10:06,959 --> 00:10:12,959
um the client side pretty much looks

277
00:10:10,240 --> 00:10:13,600
similar to what is on the screen now in

278
00:10:12,959 --> 00:10:15,518
pretty much

279
00:10:13,600 --> 00:10:17,519
any programming language for which there

280
00:10:15,519 --> 00:10:20,000
is a redis client

281
00:10:17,519 --> 00:10:21,519
essentially you have a small wrapper

282
00:10:20,000 --> 00:10:22,800
around a socket interface which is

283
00:10:21,519 --> 00:10:25,120
called high radius

284
00:10:22,800 --> 00:10:27,040
written in c highly performant does

285
00:10:25,120 --> 00:10:30,399
little more than just wrapping

286
00:10:27,040 --> 00:10:33,599
socket access on top of this you have

287
00:10:30,399 --> 00:10:34,880
language specific bindings as i referred

288
00:10:33,600 --> 00:10:37,120
to earlier

289
00:10:34,880 --> 00:10:38,640
red is supported by more than 57

290
00:10:37,120 --> 00:10:40,399
programming languages

291
00:10:38,640 --> 00:10:43,600
so each and every programming language

292
00:10:40,399 --> 00:10:45,920
has at least one if not more clients

293
00:10:43,600 --> 00:10:47,519
the problem or the issue the challenge

294
00:10:45,920 --> 00:10:48,479
with these programming language they're

295
00:10:47,519 --> 00:10:50,880
all different

296
00:10:48,480 --> 00:10:51,760
you have go which is compiler based you

297
00:10:50,880 --> 00:10:54,160
have python

298
00:10:51,760 --> 00:10:55,839
which is pi so you have python 3 very

299
00:10:54,160 --> 00:10:57,519
important these days

300
00:10:55,839 --> 00:11:00,160
you have python 3 which is interpreter

301
00:10:57,519 --> 00:11:02,240
based um you have native c

302
00:11:00,160 --> 00:11:03,279
or you have c plus plus for all of these

303
00:11:02,240 --> 00:11:05,200
programming languages

304
00:11:03,279 --> 00:11:06,320
for all of these programming languages

305
00:11:05,200 --> 00:11:07,279
their clients are library

306
00:11:06,320 --> 00:11:09,040
implementations but

307
00:11:07,279 --> 00:11:10,720
they're all different so there's an

308
00:11:09,040 --> 00:11:13,040
abstraction layer

309
00:11:10,720 --> 00:11:14,399
essentially implementing the interface

310
00:11:13,040 --> 00:11:17,120
layer to high redis

311
00:11:14,399 --> 00:11:18,720
but that can understand the semantic the

312
00:11:17,120 --> 00:11:19,680
specific semantics the specific

313
00:11:18,720 --> 00:11:21,360
interfaces

314
00:11:19,680 --> 00:11:24,880
towards the programming language of

315
00:11:21,360 --> 00:11:26,160
choice and including the runtime

316
00:11:24,880 --> 00:11:28,480
environment that this programming

317
00:11:26,160 --> 00:11:30,640
language uses

318
00:11:28,480 --> 00:11:32,160
on top of this you also have module

319
00:11:30,640 --> 00:11:37,040
specific bindings

320
00:11:32,160 --> 00:11:39,040
if you go to oss.redislabs.com you'll

321
00:11:37,040 --> 00:11:41,120
see a list of modules as i said that

322
00:11:39,040 --> 00:11:44,640
writer's labs put out there on github

323
00:11:41,120 --> 00:11:47,120
and most of them would have a python

324
00:11:44,640 --> 00:11:49,040
a go and maybe a javascript

325
00:11:47,120 --> 00:11:50,800
implementation right from day one

326
00:11:49,040 --> 00:11:52,480
so these are the kind of the basic

327
00:11:50,800 --> 00:11:53,439
interface libraries you find for the

328
00:11:52,480 --> 00:11:54,920
modules

329
00:11:53,440 --> 00:11:56,480
needless to say these module

330
00:11:54,920 --> 00:11:59,279
module-specific

331
00:11:56,480 --> 00:12:00,959
client-side implementations would use

332
00:11:59,279 --> 00:12:02,800
the language-specific bindings in order

333
00:12:00,959 --> 00:12:04,399
to talk to the server

334
00:12:02,800 --> 00:12:06,319
which of course then requires the module

335
00:12:04,399 --> 00:12:09,440
to be loaded if the inter

336
00:12:06,320 --> 00:12:11,839
if the client-specific bindings should

337
00:12:09,440 --> 00:12:11,839
work

338
00:12:12,240 --> 00:12:15,440
let's take a look at how this is done

339
00:12:14,880 --> 00:12:18,480
for

340
00:12:15,440 --> 00:12:19,760
redis json um essentially this

341
00:12:18,480 --> 00:12:21,920
architecture depicts

342
00:12:19,760 --> 00:12:23,200
a performance benchmark that i'm gonna

343
00:12:21,920 --> 00:12:25,599
go into as a

344
00:12:23,200 --> 00:12:26,880
as part of a later um as part of later

345
00:12:25,600 --> 00:12:28,480
part of the presentation

346
00:12:26,880 --> 00:12:30,399
so i'm going to just spend some time on

347
00:12:28,480 --> 00:12:32,800
describing the architecture

348
00:12:30,399 --> 00:12:33,440
um you have the module specific

349
00:12:32,800 --> 00:12:34,959
monitoring

350
00:12:33,440 --> 00:12:37,200
language specific bindings and then you

351
00:12:34,959 --> 00:12:38,959
have for high raters as explained before

352
00:12:37,200 --> 00:12:40,560
and on top of that you have a small

353
00:12:38,959 --> 00:12:44,160
layer called j redis

354
00:12:40,560 --> 00:12:47,680
json that and this is then used by

355
00:12:44,160 --> 00:12:51,040
a date by a database performance

356
00:12:47,680 --> 00:12:54,239
benchmark framework called ycsb

357
00:12:51,040 --> 00:12:57,279
probably known by most of you

358
00:12:54,240 --> 00:12:57,680
who are looking for performant database

359
00:12:57,279 --> 00:12:59,439
because

360
00:12:57,680 --> 00:13:01,199
it's essentially it stands for yahoo

361
00:12:59,440 --> 00:13:03,360
cloud serving benchmark

362
00:13:01,200 --> 00:13:04,720
it's a standard benchmarking framework

363
00:13:03,360 --> 00:13:08,000
for databases

364
00:13:04,720 --> 00:13:11,120
simply to tcp if that rings a bell only

365
00:13:08,000 --> 00:13:13,920
concentrating on nosql databases because

366
00:13:11,120 --> 00:13:14,480
where this is a nosql database right um

367
00:13:13,920 --> 00:13:17,599
so

368
00:13:14,480 --> 00:13:21,279
the um the idea is

369
00:13:17,600 --> 00:13:24,800
to extend ycsb

370
00:13:21,279 --> 00:13:27,279
with a thin driver um that talks to

371
00:13:24,800 --> 00:13:29,040
the doc the object orient the um the

372
00:13:27,279 --> 00:13:30,880
document oriented database

373
00:13:29,040 --> 00:13:32,639
and it does through through and it does

374
00:13:30,880 --> 00:13:34,959
so through the ordinary

375
00:13:32,639 --> 00:13:35,760
architecture specific stack on the

376
00:13:34,959 --> 00:13:38,800
server side

377
00:13:35,760 --> 00:13:41,439
this is reflected you have the um

378
00:13:38,800 --> 00:13:42,880
native redis server written in c as in

379
00:13:41,440 --> 00:13:44,480
you can pull it down from github it's

380
00:13:42,880 --> 00:13:47,199
all written in c it's

381
00:13:44,480 --> 00:13:48,560
um there i used version 505 for this but

382
00:13:47,199 --> 00:13:50,479
more on this later

383
00:13:48,560 --> 00:13:51,760
um then you have something called the

384
00:13:50,480 --> 00:13:55,199
module sdk

385
00:13:51,760 --> 00:13:56,720
which written in in in c

386
00:13:55,199 --> 00:13:58,319
has been has been there for the last

387
00:13:56,720 --> 00:14:00,399
couple of years as explained

388
00:13:58,320 --> 00:14:02,240
the trouble of that with cor the trouble

389
00:14:00,399 --> 00:14:04,399
with that of course is that you cannot

390
00:14:02,240 --> 00:14:05,199
use this really from from rust right

391
00:14:04,399 --> 00:14:08,639
away

392
00:14:05,199 --> 00:14:11,199
this is the reason why why writers labs

393
00:14:08,639 --> 00:14:14,959
created something called a module crate

394
00:14:11,199 --> 00:14:18,560
that essentially wraps the module sdk

395
00:14:14,959 --> 00:14:21,680
in the rust in rust bindings as you

396
00:14:18,560 --> 00:14:24,479
probably know um to call c

397
00:14:21,680 --> 00:14:25,920
from rust you have to tweak it a little

398
00:14:24,480 --> 00:14:28,000
bit a little bit essentially you have to

399
00:14:25,920 --> 00:14:32,560
say now look the eros compiler

400
00:14:28,000 --> 00:14:36,959
this api is not safe because the usual

401
00:14:32,560 --> 00:14:38,800
uh memory memory management techniques

402
00:14:36,959 --> 00:14:40,560
as in sole concept of ownership and all

403
00:14:38,800 --> 00:14:42,399
the rest and borrowing and

404
00:14:40,560 --> 00:14:44,000
your rust experts you know this do not

405
00:14:42,399 --> 00:14:47,120
apply to c code

406
00:14:44,000 --> 00:14:49,600
so the idea behind the module crate is

407
00:14:47,120 --> 00:14:52,399
essentially to wrap the module sdk

408
00:14:49,600 --> 00:14:53,680
in something that rust can understand

409
00:14:52,399 --> 00:14:56,079
and

410
00:14:53,680 --> 00:14:57,359
then you have the remaining codebase

411
00:14:56,079 --> 00:14:59,439
written in rust

412
00:14:57,360 --> 00:15:01,839
talking to this module crate which then

413
00:14:59,440 --> 00:15:03,600
in turn talks talks to the module sdk

414
00:15:01,839 --> 00:15:05,360
which in turn talks to the server

415
00:15:03,600 --> 00:15:08,079
internals by the way

416
00:15:05,360 --> 00:15:10,000
um this is redis json2 the first

417
00:15:08,079 --> 00:15:12,239
implementation called what is json

418
00:15:10,000 --> 00:15:13,279
was written in c as we can see in a

419
00:15:12,240 --> 00:15:14,639
couple of minutes

420
00:15:13,279 --> 00:15:16,480
when i'm going to when i'm going to go

421
00:15:14,639 --> 00:15:19,920
through the performance aspects

422
00:15:16,480 --> 00:15:19,920
between these two code bases

423
00:15:21,120 --> 00:15:25,440
okay um the original implementation some

424
00:15:23,680 --> 00:15:26,560
figures the original implementation had

425
00:15:25,440 --> 00:15:29,839
about

426
00:15:26,560 --> 00:15:31,680
5.2 kilo lines of code the new

427
00:15:29,839 --> 00:15:35,920
implementation

428
00:15:31,680 --> 00:15:37,920
is about 3.2 line kilograms of code

429
00:15:35,920 --> 00:15:40,399
um what were the main decision points

430
00:15:37,920 --> 00:15:43,839
for re-implementing the already existing

431
00:15:40,399 --> 00:15:44,959
registration extension in rust first of

432
00:15:43,839 --> 00:15:49,040
all

433
00:15:44,959 --> 00:15:50,319
yes the the native code base of writers

434
00:15:49,040 --> 00:15:53,599
is written in c

435
00:15:50,320 --> 00:15:57,199
but as probably most of you know

436
00:15:53,600 --> 00:15:59,120
aging c code is sometimes

437
00:15:57,199 --> 00:16:01,040
or somewhat hard to maintain especially

438
00:15:59,120 --> 00:16:04,000
if it's been around for a while

439
00:16:01,040 --> 00:16:05,439
so c code basis bring especially for new

440
00:16:04,000 --> 00:16:07,600
members of a team

441
00:16:05,440 --> 00:16:09,440
learning curve with them plus also do

442
00:16:07,600 --> 00:16:10,880
not necessarily help with the overall

443
00:16:09,440 --> 00:16:12,959
total cost of ownership or something

444
00:16:10,880 --> 00:16:15,279
called technical debt

445
00:16:12,959 --> 00:16:17,680
um so there was a decision being made to

446
00:16:15,279 --> 00:16:18,560
go forward that the new implementation

447
00:16:17,680 --> 00:16:21,519
language for

448
00:16:18,560 --> 00:16:22,000
any new modules or re-implementation of

449
00:16:21,519 --> 00:16:23,920
this

450
00:16:22,000 --> 00:16:26,399
of existing ones like what is json would

451
00:16:23,920 --> 00:16:28,800
be done in rust

452
00:16:26,399 --> 00:16:30,560
the idea was to have a more compact code

453
00:16:28,800 --> 00:16:32,079
base and i think this the the figures

454
00:16:30,560 --> 00:16:35,119
kind of reflect this

455
00:16:32,079 --> 00:16:37,519
with a with a lower technical depth and

456
00:16:35,120 --> 00:16:38,320
very important with lower qa effort

457
00:16:37,519 --> 00:16:40,639
because there

458
00:16:38,320 --> 00:16:41,759
are fewer lines of code that need to be

459
00:16:40,639 --> 00:16:43,920
tested

460
00:16:41,759 --> 00:16:45,680
um and of course that leads to a lower

461
00:16:43,920 --> 00:16:46,319
overall total cost of ownership when it

462
00:16:45,680 --> 00:16:48,079
comes to

463
00:16:46,320 --> 00:16:50,000
when it comes down to maintaining and

464
00:16:48,079 --> 00:16:53,359
extending the code base

465
00:16:50,000 --> 00:16:55,199
and of course something important

466
00:16:53,360 --> 00:16:57,040
when you're working for a company that

467
00:16:55,199 --> 00:16:59,040
sells support around this and other

468
00:16:57,040 --> 00:17:01,599
services

469
00:16:59,040 --> 00:17:03,279
time to market comes down to something

470
00:17:01,600 --> 00:17:04,559
that may be important for the business

471
00:17:03,279 --> 00:17:06,319
side of things

472
00:17:04,559 --> 00:17:07,918
this is the reason why it was a

473
00:17:06,319 --> 00:17:10,720
conscious decision about

474
00:17:07,919 --> 00:17:12,959
two years ago to go forward with rus

475
00:17:10,720 --> 00:17:16,799
rather nc when it comes down to

476
00:17:12,959 --> 00:17:16,799
native implementation of modules

477
00:17:17,280 --> 00:17:23,839
um a little bit of experience when um

478
00:17:20,959 --> 00:17:25,520
we had when we engaged with this

479
00:17:23,839 --> 00:17:28,240
re-implementation of

480
00:17:25,520 --> 00:17:29,600
the new code base the team had quite a

481
00:17:28,240 --> 00:17:30,080
diverse background some of them were

482
00:17:29,600 --> 00:17:32,959
coming

483
00:17:30,080 --> 00:17:35,199
many of them were coming from c some had

484
00:17:32,960 --> 00:17:37,919
some had some java backgrounds

485
00:17:35,200 --> 00:17:38,640
and and and also golang was was present

486
00:17:37,919 --> 00:17:40,799
but so

487
00:17:38,640 --> 00:17:43,360
the background was pretty diverse when

488
00:17:40,799 --> 00:17:46,799
it comes down to programming language

489
00:17:43,360 --> 00:17:48,559
and the reason why up to then

490
00:17:46,799 --> 00:17:51,039
the main implementation language of

491
00:17:48,559 --> 00:17:53,760
choice was c because a the module sdk

492
00:17:51,039 --> 00:17:56,160
being present already was written in c

493
00:17:53,760 --> 00:17:58,160
and of course the remaining server code

494
00:17:56,160 --> 00:18:01,760
base has been written in c

495
00:17:58,160 --> 00:18:03,200
that's the reason why natively um it was

496
00:18:01,760 --> 00:18:05,360
pretty much a no-brainer in the

497
00:18:03,200 --> 00:18:07,360
beginning to use c as the implementation

498
00:18:05,360 --> 00:18:09,439
language for any modules being developed

499
00:18:07,360 --> 00:18:12,879
inside writer's labs

500
00:18:09,440 --> 00:18:14,240
um but i'm going forward as i said for

501
00:18:12,880 --> 00:18:17,440
the reasons explained

502
00:18:14,240 --> 00:18:19,280
rust was chosen for as the new our

503
00:18:17,440 --> 00:18:22,240
technology to implement modules

504
00:18:19,280 --> 00:18:24,080
so some lessons learned from the team

505
00:18:22,240 --> 00:18:25,440
that engaged on re-implementing

506
00:18:24,080 --> 00:18:27,520
registration 2.

507
00:18:25,440 --> 00:18:29,919
yes ross does have a steep learning

508
00:18:27,520 --> 00:18:32,960
curve um

509
00:18:29,919 --> 00:18:33,600
just hands up how many have used rust um

510
00:18:32,960 --> 00:18:36,880
more than

511
00:18:33,600 --> 00:18:38,959
two or three years so you can probably

512
00:18:36,880 --> 00:18:40,559
reflect this especially if you haven't

513
00:18:38,960 --> 00:18:41,679
you if you if you haven't put up your

514
00:18:40,559 --> 00:18:42,879
hands

515
00:18:41,679 --> 00:18:44,720
that means you're kind of certainly

516
00:18:42,880 --> 00:18:46,720
learning first i reckon

517
00:18:44,720 --> 00:18:48,559
so you know what this is all about with

518
00:18:46,720 --> 00:18:51,200
regards to

519
00:18:48,559 --> 00:18:53,280
memory management can be tricky at times

520
00:18:51,200 --> 00:18:55,200
i'm talking about the board checker

521
00:18:53,280 --> 00:18:56,480
somebody about a year ago told me if you

522
00:18:55,200 --> 00:18:56,960
have convinced the borrower checkout or

523
00:18:56,480 --> 00:18:58,799
if you have

524
00:18:56,960 --> 00:19:00,799
if you have convinced the rust compiler

525
00:18:58,799 --> 00:19:02,320
to generate code you're halfway there

526
00:19:00,799 --> 00:19:04,240
in contrast to see where this is

527
00:19:02,320 --> 00:19:06,799
slightly different okay

528
00:19:04,240 --> 00:19:08,799
but now the plus sides a pretty

529
00:19:06,799 --> 00:19:10,960
comprehensive ecosystem

530
00:19:08,799 --> 00:19:12,320
if you take a look at what's out there

531
00:19:10,960 --> 00:19:16,080
on crates.i o

532
00:19:12,320 --> 00:19:18,559
that's a lot you have at least um

533
00:19:16,080 --> 00:19:19,678
five web frameworks to choose from you

534
00:19:18,559 --> 00:19:22,720
have

535
00:19:19,679 --> 00:19:24,640
crates for um socket access you have

536
00:19:22,720 --> 00:19:26,559
crates for par

537
00:19:24,640 --> 00:19:28,880
rust itself is self-hosted so you have

538
00:19:26,559 --> 00:19:30,480
actually crates for asts as an abstract

539
00:19:28,880 --> 00:19:33,760
industries and all the rest of it

540
00:19:30,480 --> 00:19:35,919
so chances are like python

541
00:19:33,760 --> 00:19:37,520
you take a look at what's out there if

542
00:19:35,919 --> 00:19:38,240
you are if you want to program a new

543
00:19:37,520 --> 00:19:40,240
code base

544
00:19:38,240 --> 00:19:41,679
and simply reuse the stuff that is all

545
00:19:40,240 --> 00:19:43,600
that has already been written

546
00:19:41,679 --> 00:19:45,760
so this is a major advantage when it

547
00:19:43,600 --> 00:19:46,480
comes down to implementing new systems

548
00:19:45,760 --> 00:19:48,080
because

549
00:19:46,480 --> 00:19:49,760
essentially as with other any open

550
00:19:48,080 --> 00:19:54,320
source projects you are

551
00:19:49,760 --> 00:19:56,559
resting on the shoulder of giants simple

552
00:19:54,320 --> 00:19:58,639
responsive community if you take a look

553
00:19:56,559 --> 00:20:01,200
at rasta at rustling.org especially at

554
00:19:58,640 --> 00:20:01,200
the forums

555
00:20:01,280 --> 00:20:05,200
it's amazing when i started to learn

556
00:20:02,880 --> 00:20:07,440
rust there was always somebody out there

557
00:20:05,200 --> 00:20:08,799
helping me never mind how stupid the

558
00:20:07,440 --> 00:20:09,840
question was if there are any stupid

559
00:20:08,799 --> 00:20:13,679
questions

560
00:20:09,840 --> 00:20:15,039
um you will get support so in contrast

561
00:20:13,679 --> 00:20:17,760
to other

562
00:20:15,039 --> 00:20:18,480
communities rust and i think this is one

563
00:20:17,760 --> 00:20:20,480
of the major

564
00:20:18,480 --> 00:20:21,919
of the big advantage of the of the

565
00:20:20,480 --> 00:20:23,360
community and the language

566
00:20:21,919 --> 00:20:26,000
has been pretty responsive and pretty

567
00:20:23,360 --> 00:20:30,000
supportive and this is reflected

568
00:20:26,000 --> 00:20:31,679
um by what the um um what the

569
00:20:30,000 --> 00:20:33,120
development team basically experienced

570
00:20:31,679 --> 00:20:35,280
when they first started to

571
00:20:33,120 --> 00:20:37,360
to this this enterprise of basically

572
00:20:35,280 --> 00:20:39,120
program something in rust

573
00:20:37,360 --> 00:20:40,879
and of course the 2 chain support is

574
00:20:39,120 --> 00:20:44,080
awesome

575
00:20:40,880 --> 00:20:45,760
not only you have different tool chains

576
00:20:44,080 --> 00:20:47,918
at your disposal

577
00:20:45,760 --> 00:20:49,360
better stable and of course nightly if

578
00:20:47,919 --> 00:20:51,120
you want to check out new features you

579
00:20:49,360 --> 00:20:55,039
simply switch

580
00:20:51,120 --> 00:20:57,360
um to a new uh stu tool chain

581
00:20:55,039 --> 00:20:59,039
2 chain version and off you go but

582
00:20:57,360 --> 00:21:01,360
something pretty important

583
00:20:59,039 --> 00:21:02,240
cargo best example right it's not only

584
00:21:01,360 --> 00:21:04,399
build system

585
00:21:02,240 --> 00:21:06,960
it's a package management management

586
00:21:04,400 --> 00:21:10,080
system all wrapped into one

587
00:21:06,960 --> 00:21:11,679
i've yet maybe apart from golang i've

588
00:21:10,080 --> 00:21:13,600
yet to find

589
00:21:11,679 --> 00:21:14,880
a programming language that does it all

590
00:21:13,600 --> 00:21:17,039
in one go

591
00:21:14,880 --> 00:21:19,600
maven for java came later and it took

592
00:21:17,039 --> 00:21:22,000
java people a long time to get it right

593
00:21:19,600 --> 00:21:24,399
my opinion before any java people killed

594
00:21:22,000 --> 00:21:30,080
me after this presentation

595
00:21:24,400 --> 00:21:32,480
no jokes aside um mozilla decided about

596
00:21:30,080 --> 00:21:34,320
13 years ago that they knew that they

597
00:21:32,480 --> 00:21:36,880
needed a new programming language

598
00:21:34,320 --> 00:21:37,520
because cnc plus plus as in the code

599
00:21:36,880 --> 00:21:39,679
base

600
00:21:37,520 --> 00:21:41,440
then in place for the rendering engine

601
00:21:39,679 --> 00:21:43,919
didn't cut it anymore

602
00:21:41,440 --> 00:21:45,440
um so rust was developed first commit i

603
00:21:43,919 --> 00:21:46,960
think about 11 years ago from a

604
00:21:45,440 --> 00:21:49,679
completely mistaken

605
00:21:46,960 --> 00:21:50,720
but they did it with intelligence this

606
00:21:49,679 --> 00:21:53,039
time around

607
00:21:50,720 --> 00:21:54,720
and you'll see this if you take a look

608
00:21:53,039 --> 00:21:56,400
at the tool chain support

609
00:21:54,720 --> 00:21:58,000
at the at the ecosystem and people

610
00:21:56,400 --> 00:22:01,120
picked up and picked up on it pretty

611
00:21:58,000 --> 00:22:02,400
quickly it took python about i reckon 15

612
00:22:01,120 --> 00:22:04,719
to 20 years

613
00:22:02,400 --> 00:22:05,919
to where rust is now within within the

614
00:22:04,720 --> 00:22:07,440
short amount of time

615
00:22:05,919 --> 00:22:10,559
of 10 years and that's pretty amazing i

616
00:22:07,440 --> 00:22:10,559
think for a program language

617
00:22:10,960 --> 00:22:15,280
um more info on our beloved yahoo cloud

618
00:22:14,640 --> 00:22:17,200
server

619
00:22:15,280 --> 00:22:18,480
serving benchmark as i already said it's

620
00:22:17,200 --> 00:22:20,880
written in java

621
00:22:18,480 --> 00:22:21,679
it's a standard framework so the idea is

622
00:22:20,880 --> 00:22:24,840
that you have

623
00:22:21,679 --> 00:22:28,000
quite a few um db

624
00:22:24,840 --> 00:22:29,439
integration layers as part of the native

625
00:22:28,000 --> 00:22:30,559
cope is when you clone it from github

626
00:22:29,440 --> 00:22:32,720
right away

627
00:22:30,559 --> 00:22:33,600
um redis is of course supported out of

628
00:22:32,720 --> 00:22:37,039
the box

629
00:22:33,600 --> 00:22:38,879
so is hadoop couch base

630
00:22:37,039 --> 00:22:40,240
um even some graph database and all the

631
00:22:38,880 --> 00:22:42,880
rest of it

632
00:22:40,240 --> 00:22:43,679
so the idea is basically if you want to

633
00:22:42,880 --> 00:22:46,240
take a look

634
00:22:43,679 --> 00:22:47,840
at um how how your how your

635
00:22:46,240 --> 00:22:49,840
implementation how your

636
00:22:47,840 --> 00:22:51,439
ecosystem when it comes down to nosql is

637
00:22:49,840 --> 00:22:53,360
performing you simply

638
00:22:51,440 --> 00:22:54,799
you simply clone the code base you

639
00:22:53,360 --> 00:22:56,240
compile it and then you can start

640
00:22:54,799 --> 00:22:58,879
testing

641
00:22:56,240 --> 00:23:00,400
if and that's what's the case when we

642
00:22:58,880 --> 00:23:01,919
started off on this performance

643
00:23:00,400 --> 00:23:05,760
benchmark exercise

644
00:23:01,919 --> 00:23:08,240
if there's no integration with your

645
00:23:05,760 --> 00:23:10,158
new nosql database yet it's it's it's

646
00:23:08,240 --> 00:23:13,520
not that difficult because

647
00:23:10,159 --> 00:23:16,240
you simply implement four actually five

648
00:23:13,520 --> 00:23:17,440
methods in java that talk to the

649
00:23:16,240 --> 00:23:19,360
respective clients

650
00:23:17,440 --> 00:23:20,559
library implementation and then you're

651
00:23:19,360 --> 00:23:22,719
good to go

652
00:23:20,559 --> 00:23:24,240
um so the idea is basically you have

653
00:23:22,720 --> 00:23:25,520
inserts you have updates you have

654
00:23:24,240 --> 00:23:27,120
deletes

655
00:23:25,520 --> 00:23:29,440
and then you have writes and you have

656
00:23:27,120 --> 00:23:30,399
scans plus maybe initialization and

657
00:23:29,440 --> 00:23:31,840
finalization

658
00:23:30,400 --> 00:23:35,039
of the database connection but that's

659
00:23:31,840 --> 00:23:38,080
about it so the implementation

660
00:23:35,039 --> 00:23:39,600
of the registration extension that talks

661
00:23:38,080 --> 00:23:44,080
through that is json

662
00:23:39,600 --> 00:23:47,520
is about 200 lines of java code

663
00:23:44,080 --> 00:23:50,480
it's as simple as that so not a big deal

664
00:23:47,520 --> 00:23:50,960
don't fret if you're if your database is

665
00:23:50,480 --> 00:23:52,400
not in

666
00:23:50,960 --> 00:23:54,320
on the list of all of the already

667
00:23:52,400 --> 00:23:56,240
supported nosql databases

668
00:23:54,320 --> 00:23:58,879
writing that interface layer is not that

669
00:23:56,240 --> 00:24:01,360
hard apart from using java of course but

670
00:23:58,880 --> 00:24:04,559
that's a different story

671
00:24:01,360 --> 00:24:06,639
okay um ycsb has

672
00:24:04,559 --> 00:24:08,320
the concept of workloads there are five

673
00:24:06,640 --> 00:24:12,000
workloads

674
00:24:08,320 --> 00:24:13,840
that all reflect different use cases um

675
00:24:12,000 --> 00:24:15,840
for the purpose of this benchmark i used

676
00:24:13,840 --> 00:24:18,480
about three of them

677
00:24:15,840 --> 00:24:19,279
so they range from a to f goes without

678
00:24:18,480 --> 00:24:21,919
saying

679
00:24:19,279 --> 00:24:22,500
so um they all reflect different kind of

680
00:24:21,919 --> 00:24:23,600
um

681
00:24:22,500 --> 00:24:26,000
[Music]

682
00:24:23,600 --> 00:24:27,039
axis patterns on the client side if you

683
00:24:26,000 --> 00:24:29,679
will as

684
00:24:27,039 --> 00:24:30,720
i said different use cases so workload a

685
00:24:29,679 --> 00:24:33,919
would reflect

686
00:24:30,720 --> 00:24:36,880
your vanilla

687
00:24:33,919 --> 00:24:37,840
kind of cycle in terms of your 50 of

688
00:24:36,880 --> 00:24:40,480
writes your 50

689
00:24:37,840 --> 00:24:42,559
of reads that hammer onto the database

690
00:24:40,480 --> 00:24:46,240
then you have workload b

691
00:24:42,559 --> 00:24:49,440
um that has a more caching oriented

692
00:24:46,240 --> 00:24:52,000
access pattern namely you have about

693
00:24:49,440 --> 00:24:52,480
95 of the database accesses would be

694
00:24:52,000 --> 00:24:54,400
read

695
00:24:52,480 --> 00:24:55,840
would be reads and only five percent

696
00:24:54,400 --> 00:24:57,600
would be rights

697
00:24:55,840 --> 00:24:59,120
and then you have your bread and butter

698
00:24:57,600 --> 00:25:02,158
workload which is f

699
00:24:59,120 --> 00:25:06,080
that typically that reflects a typical

700
00:25:02,159 --> 00:25:09,840
crop circle as in you read a data record

701
00:25:06,080 --> 00:25:09,840
you modify it and then you write it back

702
00:25:10,159 --> 00:25:13,200
um so for the for the purpose of this

703
00:25:11,919 --> 00:25:14,240
benchmark this is basically what i

704
00:25:13,200 --> 00:25:16,799
focused on

705
00:25:14,240 --> 00:25:18,159
especially interested in workload number

706
00:25:16,799 --> 00:25:20,320
b because this is

707
00:25:18,159 --> 00:25:22,960
where the where this caching thing comes

708
00:25:20,320 --> 00:25:26,879
from originally about 10 years ago

709
00:25:22,960 --> 00:25:29,360
um how much time do i have left

710
00:25:26,880 --> 00:25:30,960
20 minutes okay plenty of time okay cool

711
00:25:29,360 --> 00:25:33,918
so we can spend some time

712
00:25:30,960 --> 00:25:34,720
on the analysis of this first of all um

713
00:25:33,919 --> 00:25:38,240
some some

714
00:25:34,720 --> 00:25:41,600
some specs um i used a stock ewen

715
00:25:38,240 --> 00:25:43,520
as in the latest ubuntu release and

716
00:25:41,600 --> 00:25:45,760
the machine i rendered on is actually a

717
00:25:43,520 --> 00:25:49,520
dell x ps13

718
00:25:45,760 --> 00:25:52,799
that has a mobile i7 um with about

719
00:25:49,520 --> 00:25:54,799
16 gigabytes of ram and it's 512

720
00:25:52,799 --> 00:25:57,679
gigabytes of ssd

721
00:25:54,799 --> 00:26:00,960
and the number of records that i used um

722
00:25:57,679 --> 00:26:00,960
is actually around 1 million

723
00:26:01,360 --> 00:26:05,678
bear in mind that these figures

724
00:26:03,919 --> 00:26:08,080
expressed in seconds

725
00:26:05,679 --> 00:26:09,760
of course can be scaled if you move to a

726
00:26:08,080 --> 00:26:11,120
different server specification goes

727
00:26:09,760 --> 00:26:14,400
without saying

728
00:26:11,120 --> 00:26:17,199
i travel a lot so i use that machine

729
00:26:14,400 --> 00:26:19,039
that i'm presenting from as my go to

730
00:26:17,200 --> 00:26:23,600
server inverted commas

731
00:26:19,039 --> 00:26:25,279
i use redis 505 as a kind of reference

732
00:26:23,600 --> 00:26:26,639
architecture you see that in the first

733
00:26:25,279 --> 00:26:29,679
in the first line

734
00:26:26,640 --> 00:26:32,720
basically to see how red is json

735
00:26:29,679 --> 00:26:34,159
scales up against nate the native radius

736
00:26:32,720 --> 00:26:35,200
implementation and the native radius

737
00:26:34,159 --> 00:26:37,600
implementation

738
00:26:35,200 --> 00:26:40,080
is already as i said part of the ycsb

739
00:26:37,600 --> 00:26:42,879
code base

740
00:26:40,080 --> 00:26:43,439
and then i used reddish redis json as in

741
00:26:42,880 --> 00:26:45,679
the c

742
00:26:43,440 --> 00:26:47,840
implementation and i cloned this on the

743
00:26:45,679 --> 00:26:49,760
2nd of january 2020

744
00:26:47,840 --> 00:26:50,959
and one day later i cloned the rust

745
00:26:49,760 --> 00:26:54,960
version

746
00:26:50,960 --> 00:26:56,960
um the reason for the one day delay was

747
00:26:54,960 --> 00:26:59,440
that my internet essentially broke down

748
00:26:56,960 --> 00:27:00,640
on the second after i after i cloned the

749
00:26:59,440 --> 00:27:02,559
c code base

750
00:27:00,640 --> 00:27:04,320
and then i was traveling and then i had

751
00:27:02,559 --> 00:27:06,639
internet access back again

752
00:27:04,320 --> 00:27:08,480
next day so that's the reason um for

753
00:27:06,640 --> 00:27:09,679
that one day delay but

754
00:27:08,480 --> 00:27:11,120
i took a look at the commits and there

755
00:27:09,679 --> 00:27:12,320
were no commits in between so that's the

756
00:27:11,120 --> 00:27:16,239
reason why

757
00:27:12,320 --> 00:27:18,879
um pretty important because i'm

758
00:27:16,240 --> 00:27:20,000
measuring only raiders i'm not measuring

759
00:27:18,880 --> 00:27:21,679
or registration i'm not

760
00:27:20,000 --> 00:27:23,840
measuring combongo i'm not measuring

761
00:27:21,679 --> 00:27:24,960
code couchbase i'm not measuring any

762
00:27:23,840 --> 00:27:28,720
other nodes you could be

763
00:27:24,960 --> 00:27:31,600
no no sqldb as part of this benchmark so

764
00:27:28,720 --> 00:27:33,039
i left it that in memory in memory

765
00:27:31,600 --> 00:27:36,320
management only

766
00:27:33,039 --> 00:27:38,720
so there was no persistence configured

767
00:27:36,320 --> 00:27:40,320
if many of you have used redis you know

768
00:27:38,720 --> 00:27:42,000
that redless has two persistent

769
00:27:40,320 --> 00:27:44,320
two types of resistance namely append

770
00:27:42,000 --> 00:27:46,080
only files as well as snapshots

771
00:27:44,320 --> 00:27:47,360
i didn't use any of them because i want

772
00:27:46,080 --> 00:27:49,678
to keep it straight

773
00:27:47,360 --> 00:27:51,279
and i just want to confine it to redis

774
00:27:49,679 --> 00:27:53,679
so i simply said now look

775
00:27:51,279 --> 00:27:55,520
let us do your thing in memory as you

776
00:27:53,679 --> 00:27:57,679
have been doing for the last 10 years

777
00:27:55,520 --> 00:27:59,760
let's take a look at the native

778
00:27:57,679 --> 00:28:01,919
implementation first to get some sort

779
00:27:59,760 --> 00:28:03,679
some some feeling of how radius is

780
00:28:01,919 --> 00:28:05,760
measuring up

781
00:28:03,679 --> 00:28:08,880
the number of threads you can configure

782
00:28:05,760 --> 00:28:10,799
that when you run your ycsb invocation

783
00:28:08,880 --> 00:28:11,919
the number of threads essentially

784
00:28:10,799 --> 00:28:14,559
reflect or

785
00:28:11,919 --> 00:28:17,279
kind of model the number of applications

786
00:28:14,559 --> 00:28:19,520
hammering onto that database instance

787
00:28:17,279 --> 00:28:22,399
as you can see and this is implemented

788
00:28:19,520 --> 00:28:25,918
by pure java threats thank you

789
00:28:22,399 --> 00:28:27,760
pure java threads on the client-side

790
00:28:25,919 --> 00:28:28,640
implementation because this is what ycsb

791
00:28:27,760 --> 00:28:30,480
uses

792
00:28:28,640 --> 00:28:32,159
when it comes down to accessing or

793
00:28:30,480 --> 00:28:33,279
simulating access to the server side

794
00:28:32,159 --> 00:28:35,600
implementation

795
00:28:33,279 --> 00:28:36,320
so uh one thread four threads and eight

796
00:28:35,600 --> 00:28:38,959
threads

797
00:28:36,320 --> 00:28:40,399
bear in mind that this is only a mobile

798
00:28:38,960 --> 00:28:42,559
um

799
00:28:40,399 --> 00:28:44,000
quad core so um you're looking at

800
00:28:42,559 --> 00:28:45,520
essentially a dual core

801
00:28:44,000 --> 00:28:47,520
with hyper threading that's something

802
00:28:45,520 --> 00:28:50,559
important to keep in mind

803
00:28:47,520 --> 00:28:53,600
already at the kind of reddest level

804
00:28:50,559 --> 00:28:56,960
we'll see a spike in performance

805
00:28:53,600 --> 00:28:59,120
when you move from one to four threads

806
00:28:56,960 --> 00:29:00,880
this slightly goes up if you move to

807
00:28:59,120 --> 00:29:01,520
eight threads because that's what you

808
00:29:00,880 --> 00:29:05,200
see

809
00:29:01,520 --> 00:29:06,960
when you hammer with multiple databases

810
00:29:05,200 --> 00:29:10,399
so when you handle with multiple clients

811
00:29:06,960 --> 00:29:10,399
onto a single database instance

812
00:29:10,840 --> 00:29:16,879
um and that's actually workload a

813
00:29:14,399 --> 00:29:17,840
and what is also and this is reflected

814
00:29:16,880 --> 00:29:21,440
also in the

815
00:29:17,840 --> 00:29:22,959
in the remaining workloads um

816
00:29:21,440 --> 00:29:24,720
what i'm a little bit surprised about

817
00:29:22,960 --> 00:29:25,279
and i haven't done a quite thorough

818
00:29:24,720 --> 00:29:28,799
route

819
00:29:25,279 --> 00:29:29,200
and it is yet why the performance for

820
00:29:28,799 --> 00:29:32,799
eight

821
00:29:29,200 --> 00:29:33,919
threads is actually higher on the native

822
00:29:32,799 --> 00:29:36,000
reddish level

823
00:29:33,919 --> 00:29:38,159
rather than four threads so i reckon

824
00:29:36,000 --> 00:29:40,720
it's down to something called

825
00:29:38,159 --> 00:29:43,760
the jettis interface that is used when

826
00:29:40,720 --> 00:29:45,279
accessing native redis in in ycsb

827
00:29:43,760 --> 00:29:47,120
jettison is one of them is one of the

828
00:29:45,279 --> 00:29:49,200
standard java clients

829
00:29:47,120 --> 00:29:50,320
apart from letters and something called

830
00:29:49,200 --> 00:29:52,880
redison

831
00:29:50,320 --> 00:29:54,639
and as i said i'm suspecting that this

832
00:29:52,880 --> 00:29:57,520
is basically down to

833
00:29:54,640 --> 00:29:58,159
to to the jettison temptation i used 3.2

834
00:29:57,520 --> 00:30:00,158
um the

835
00:29:58,159 --> 00:30:01,440
the commit was fairly the the the

836
00:30:00,159 --> 00:30:03,279
attacking of the release was fairly

837
00:30:01,440 --> 00:30:05,440
recent so i reckon there's something

838
00:30:03,279 --> 00:30:08,080
there's something fishy maybe and maybe

839
00:30:05,440 --> 00:30:10,240
in that in the jedi's version

840
00:30:08,080 --> 00:30:11,840
switching over or comparing this to

841
00:30:10,240 --> 00:30:14,080
reddish json as in the native c

842
00:30:11,840 --> 00:30:17,039
implementation of the document db

843
00:30:14,080 --> 00:30:18,720
you will see the price you pay from when

844
00:30:17,039 --> 00:30:21,279
switching from native redis

845
00:30:18,720 --> 00:30:23,520
to register to registration i.e the

846
00:30:21,279 --> 00:30:25,120
overhead the performance penalty that

847
00:30:23,520 --> 00:30:28,000
you pay in inverter commas

848
00:30:25,120 --> 00:30:30,320
when you actually use that module uh

849
00:30:28,000 --> 00:30:33,760
giving you documents oriented

850
00:30:30,320 --> 00:30:36,080
functionality and as you can see

851
00:30:33,760 --> 00:30:38,000
um it's not that much at the end of the

852
00:30:36,080 --> 00:30:41,918
day because essentially you're looking

853
00:30:38,000 --> 00:30:44,240
at 30 multi-threaded

854
00:30:41,919 --> 00:30:47,039
um and even and even less when it comes

855
00:30:44,240 --> 00:30:50,320
down to a single thread

856
00:30:47,039 --> 00:30:51,760
um and now it gets really interesting

857
00:30:50,320 --> 00:30:54,080
because the comparison

858
00:30:51,760 --> 00:30:55,279
the comparison between what is json and

859
00:30:54,080 --> 00:30:57,600
registration two

860
00:30:55,279 --> 00:30:58,559
essentially tell you the performance

861
00:30:57,600 --> 00:31:01,279
penalty

862
00:30:58,559 --> 00:31:01,840
when using a rus code base in comparison

863
00:31:01,279 --> 00:31:05,440
to a c

864
00:31:01,840 --> 00:31:09,120
code base so this is the impact

865
00:31:05,440 --> 00:31:11,039
that you have when you go from c to rust

866
00:31:09,120 --> 00:31:14,080
i'm slightly simplifying but you get the

867
00:31:11,039 --> 00:31:17,200
drift let's take a look at the numbers

868
00:31:14,080 --> 00:31:20,158
um work um let's let's pick a

869
00:31:17,200 --> 00:31:22,480
random workload let's pick workload a

870
00:31:20,159 --> 00:31:24,640
the performance penalty that you pay

871
00:31:22,480 --> 00:31:26,399
is quite is is quite minimal because

872
00:31:24,640 --> 00:31:29,440
essentially you're looking at

873
00:31:26,399 --> 00:31:30,719
44 versus 49 seconds that's five seconds

874
00:31:29,440 --> 00:31:33,840
difference

875
00:31:30,720 --> 00:31:36,320
but at the on the other side you gain

876
00:31:33,840 --> 00:31:37,519
all the benefits that come with rust

877
00:31:36,320 --> 00:31:40,080
this is why

878
00:31:37,519 --> 00:31:40,720
this comparison for this particular use

879
00:31:40,080 --> 00:31:43,360
case

880
00:31:40,720 --> 00:31:44,480
is quite revealing i think uh when you

881
00:31:43,360 --> 00:31:46,479
are

882
00:31:44,480 --> 00:31:48,159
facing the decision what implementation

883
00:31:46,480 --> 00:31:49,840
language to use for your next product a

884
00:31:48,159 --> 00:31:50,399
project would that be rust would that be

885
00:31:49,840 --> 00:31:54,240
c or c

886
00:31:50,399 --> 00:31:55,600
plus plus um um

887
00:31:54,240 --> 00:31:57,120
i'm going to leave it here because we

888
00:31:55,600 --> 00:31:58,639
have we have about what 10 minutes left

889
00:31:57,120 --> 00:32:00,158
something like that so there's still

890
00:31:58,640 --> 00:32:02,799
more some more slides

891
00:32:00,159 --> 00:32:04,559
um the size of course will be um on the

892
00:32:02,799 --> 00:32:06,639
website so free free

893
00:32:04,559 --> 00:32:07,918
um to take a second look to do some

894
00:32:06,640 --> 00:32:10,559
further analysis

895
00:32:07,919 --> 00:32:11,679
um the code will be on github very soon

896
00:32:10,559 --> 00:32:13,120
more on that later

897
00:32:11,679 --> 00:32:14,640
and feel free to get in touch if you're

898
00:32:13,120 --> 00:32:16,799
for the if you have further questions on

899
00:32:14,640 --> 00:32:20,880
this

900
00:32:16,799 --> 00:32:22,559
okay um short recap

901
00:32:20,880 --> 00:32:25,440
regis json of course is the document

902
00:32:22,559 --> 00:32:26,639
origin db and is is an extension

903
00:32:25,440 --> 00:32:29,039
basically of redis

904
00:32:26,640 --> 00:32:31,840
and this is purely aimed at or the

905
00:32:29,039 --> 00:32:34,879
primary use case is in memory processing

906
00:32:31,840 --> 00:32:37,279
so the focus is on what redis comes with

907
00:32:34,880 --> 00:32:38,960
natively performance and low

908
00:32:37,279 --> 00:32:40,880
high performance and low latency as in

909
00:32:38,960 --> 00:32:43,679
maximum throughput

910
00:32:40,880 --> 00:32:44,799
um and of course because it's based on

911
00:32:43,679 --> 00:32:47,600
redis you have the

912
00:32:44,799 --> 00:32:49,039
full cap triangle at your disposal sorry

913
00:32:47,600 --> 00:32:49,519
a cap anybody doesn't know doesn't know

914
00:32:49,039 --> 00:32:53,120
what cap

915
00:32:49,519 --> 00:32:55,279
is okay great sorry yes um

916
00:32:53,120 --> 00:32:57,518
ruth's theorem it's the it's a triangle

917
00:32:55,279 --> 00:32:58,880
between consistency availability and

918
00:32:57,519 --> 00:33:02,960
partition tolerance

919
00:32:58,880 --> 00:33:06,000
essentially um from acid right up to

920
00:33:02,960 --> 00:33:07,039
um maybe maybe coherent something like

921
00:33:06,000 --> 00:33:09,760
this

922
00:33:07,039 --> 00:33:11,279
so essentially acid doesn't of course

923
00:33:09,760 --> 00:33:12,480
assets should ring a belt so this is

924
00:33:11,279 --> 00:33:14,720
asset is your typical

925
00:33:12,480 --> 00:33:15,760
sql based use case as then you have a

926
00:33:14,720 --> 00:33:17,919
transaction

927
00:33:15,760 --> 00:33:19,039
that either fails or succeeds nothing in

928
00:33:17,919 --> 00:33:20,720
between

929
00:33:19,039 --> 00:33:22,080
many as it turns out many applications

930
00:33:20,720 --> 00:33:24,159
don't do not

931
00:33:22,080 --> 00:33:26,080
do not have to use that strong

932
00:33:24,159 --> 00:33:26,799
consistency notion so that's the reason

933
00:33:26,080 --> 00:33:28,399
why

934
00:33:26,799 --> 00:33:29,918
you sp you especially see this in the

935
00:33:28,399 --> 00:33:30,639
nosql space that more and more

936
00:33:29,919 --> 00:33:32,559
applications

937
00:33:30,640 --> 00:33:33,679
move away from this strong acid

938
00:33:32,559 --> 00:33:36,480
compliance

939
00:33:33,679 --> 00:33:38,720
and redis with the with the different

940
00:33:36,480 --> 00:33:39,200
types of persistence within memory focus

941
00:33:38,720 --> 00:33:41,919
and some

942
00:33:39,200 --> 00:33:43,919
and thank you and and the other benefits

943
00:33:41,919 --> 00:33:46,559
of course allows you to move

944
00:33:43,919 --> 00:33:47,919
in that triangle based on your use case

945
00:33:46,559 --> 00:33:51,279
pretty freely

946
00:33:47,919 --> 00:33:55,120
so um this is basically the the

947
00:33:51,279 --> 00:33:55,120
of of this nosql approach

948
00:33:55,200 --> 00:34:00,240
the outlook is um we're going to

949
00:33:58,480 --> 00:34:01,279
integrate this and you'll see this when

950
00:34:00,240 --> 00:34:03,840
you take a look at the

951
00:34:01,279 --> 00:34:06,080
at the code base on on github already

952
00:34:03,840 --> 00:34:07,840
and there's a module called ready search

953
00:34:06,080 --> 00:34:08,319
which essentially is a full text search

954
00:34:07,840 --> 00:34:10,560
engine

955
00:34:08,320 --> 00:34:11,359
also based on redis of course that

956
00:34:10,560 --> 00:34:14,480
allows you

957
00:34:11,359 --> 00:34:17,598
to have the functionality

958
00:34:14,480 --> 00:34:19,359
of a real-time index in memory at your

959
00:34:17,599 --> 00:34:22,320
disposal

960
00:34:19,359 --> 00:34:23,918
many people use it as far as i've seen

961
00:34:22,320 --> 00:34:24,399
basically to implement something called

962
00:34:23,918 --> 00:34:26,239
like an

963
00:34:24,399 --> 00:34:27,918
in-memory search engine because that's

964
00:34:26,239 --> 00:34:29,439
what it what it is for so you take a

965
00:34:27,918 --> 00:34:31,199
document you let it in there you

966
00:34:29,440 --> 00:34:32,560
let registers index the whole thing and

967
00:34:31,199 --> 00:34:36,239
then you can basically

968
00:34:32,560 --> 00:34:38,560
search for your um for your index terms

969
00:34:36,239 --> 00:34:39,520
or for for your search terms on on that

970
00:34:38,560 --> 00:34:41,359
index

971
00:34:39,520 --> 00:34:42,560
so the idea is basically to combine

972
00:34:41,359 --> 00:34:44,719
ready search um

973
00:34:42,560 --> 00:34:46,799
with registration which up to the time

974
00:34:44,719 --> 00:34:48,000
only supported json as a query language

975
00:34:46,800 --> 00:34:50,879
or json path as a query

976
00:34:48,000 --> 00:34:52,239
language and of course other

977
00:34:50,879 --> 00:34:55,918
functionality improvements

978
00:34:52,239 --> 00:34:57,439
um regard extending the functionality

979
00:34:55,918 --> 00:34:58,560
currently implemented in registration

980
00:34:57,440 --> 00:35:02,000
two

981
00:34:58,560 --> 00:35:04,799
plus of course api extensions so

982
00:35:02,000 --> 00:35:05,920
yielding at the end of the day at a

983
00:35:04,800 --> 00:35:08,960
document db

984
00:35:05,920 --> 00:35:10,560
that is fully indexable in real time

985
00:35:08,960 --> 00:35:13,599
so that's the overall that's the overall

986
00:35:10,560 --> 00:35:13,599
idea moving forward

987
00:35:15,520 --> 00:35:18,640
before we come to the questions couple

988
00:35:17,040 --> 00:35:20,160
of links

989
00:35:18,640 --> 00:35:21,920
on register.io you'll find the full

990
00:35:20,160 --> 00:35:25,000
redis documentation no need to tell you

991
00:35:21,920 --> 00:35:28,839
that because you know this already

992
00:35:25,000 --> 00:35:30,720
registration.io reflects the reference

993
00:35:28,839 --> 00:35:32,560
documentation that is out there for

994
00:35:30,720 --> 00:35:36,560
registration and registration too

995
00:35:32,560 --> 00:35:38,640
by the way the api is not is is the same

996
00:35:36,560 --> 00:35:40,160
um so whether you are talking to race

997
00:35:38,640 --> 00:35:40,879
json or registration two it doesn't

998
00:35:40,160 --> 00:35:43,279
matter

999
00:35:40,880 --> 00:35:44,000
and it will always be the same so if we

1000
00:35:43,280 --> 00:35:46,480
if we

1001
00:35:44,000 --> 00:35:47,680
extend registration 2 these changes will

1002
00:35:46,480 --> 00:35:51,200
also be reflected

1003
00:35:47,680 --> 00:35:51,200
in registration for the time being

1004
00:35:51,520 --> 00:35:55,440
you will have the code base on github

1005
00:35:53,839 --> 00:35:58,720
there's of course

1006
00:35:55,440 --> 00:36:00,720
the code base for redis from salvatore

1007
00:35:58,720 --> 00:36:03,279
maintained by salvatore sanfilippo

1008
00:36:00,720 --> 00:36:05,520
on github on github as well at his at

1009
00:36:03,280 --> 00:36:08,880
his handle called anti-race

1010
00:36:05,520 --> 00:36:12,160
um you'll find the ycsb clots cloud

1011
00:36:08,880 --> 00:36:14,000
server benchmark also on github um

1012
00:36:12,160 --> 00:36:15,759
as soon as i get around to it i'm going

1013
00:36:14,000 --> 00:36:18,720
to issue a pull request for the

1014
00:36:15,760 --> 00:36:20,320
for the reddit json interface layer so

1015
00:36:18,720 --> 00:36:23,839
if brian accepts this

1016
00:36:20,320 --> 00:36:26,880
you'll have a native ycsb

1017
00:36:23,839 --> 00:36:28,400
integration out of the box on github and

1018
00:36:26,880 --> 00:36:30,800
of course there's also something called

1019
00:36:28,400 --> 00:36:32,640
the redis labs university

1020
00:36:30,800 --> 00:36:34,480
um just a sentence on that because this

1021
00:36:32,640 --> 00:36:36,720
is not a commercial presentation

1022
00:36:34,480 --> 00:36:38,640
it's essentially a university in online

1023
00:36:36,720 --> 00:36:41,520
university where you can

1024
00:36:38,640 --> 00:36:42,960
get to know more about redis um both

1025
00:36:41,520 --> 00:36:44,560
from a developer as well as

1026
00:36:42,960 --> 00:36:45,119
administrative perspective it's free of

1027
00:36:44,560 --> 00:36:48,160
charge

1028
00:36:45,119 --> 00:36:51,520
simply register create an account uh

1029
00:36:48,160 --> 00:36:53,759
enroll in a course pass the exams

1030
00:36:51,520 --> 00:36:56,320
pass the homework and you get a

1031
00:36:53,760 --> 00:36:56,320
certificate

1032
00:36:56,480 --> 00:37:02,720
any questions before we close it off yes

1033
00:36:59,920 --> 00:37:03,920
can you make a module that uses another

1034
00:37:02,720 --> 00:37:07,439
module so you can move

1035
00:37:03,920 --> 00:37:10,720
part of your application in the server

1036
00:37:07,440 --> 00:37:13,599
yes yes of course thank you um the

1037
00:37:10,720 --> 00:37:15,439
question was um can you

1038
00:37:13,599 --> 00:37:17,839
nest modules essentially as in can you

1039
00:37:15,440 --> 00:37:20,640
move business logic

1040
00:37:17,839 --> 00:37:22,078
onto the server side yes you can there's

1041
00:37:20,640 --> 00:37:23,118
something called lua which is a

1042
00:37:22,079 --> 00:37:26,160
scripting extension

1043
00:37:23,119 --> 00:37:27,760
for redis but there's also an upcoming

1044
00:37:26,160 --> 00:37:29,279
module it's in

1045
00:37:27,760 --> 00:37:31,520
it's in technical preview at the moment

1046
00:37:29,280 --> 00:37:33,599
it's called redis gears redis gears

1047
00:37:31,520 --> 00:37:35,119
allows you to take your at the moment

1048
00:37:33,599 --> 00:37:37,359
it's only python

1049
00:37:35,119 --> 00:37:39,200
allow you to take your business logic

1050
00:37:37,359 --> 00:37:41,279
code in python and move it off to the

1051
00:37:39,200 --> 00:37:43,839
server so your net your python

1052
00:37:41,280 --> 00:37:44,480
script is then executed as part of a

1053
00:37:43,839 --> 00:37:46,720
python

1054
00:37:44,480 --> 00:37:48,079
code as part of a python implementation

1055
00:37:46,720 --> 00:37:51,200
running on the server

1056
00:37:48,079 --> 00:37:52,880
um you can also do this with uh module

1057
00:37:51,200 --> 00:37:55,759
functionality although i haven't i

1058
00:37:52,880 --> 00:37:55,760
haven't seen this yet

1059
00:37:57,359 --> 00:38:00,480
russ um

1060
00:38:02,240 --> 00:38:06,000
question is it hasn't been done yet from

1061
00:38:04,480 --> 00:38:07,920
a from a function perspective i don't

1062
00:38:06,000 --> 00:38:09,599
see any reason why

1063
00:38:07,920 --> 00:38:11,359
as long as you stick to the to the

1064
00:38:09,599 --> 00:38:12,960
module crate goes without saying

1065
00:38:11,359 --> 00:38:14,480
because essentially this is what you use

1066
00:38:12,960 --> 00:38:16,160
when you access

1067
00:38:14,480 --> 00:38:18,240
the module sdk but i don't see any

1068
00:38:16,160 --> 00:38:20,240
reason why you couldn't do this

1069
00:38:18,240 --> 00:38:21,680
but as i said the poc still remains to

1070
00:38:20,240 --> 00:38:22,799
be done any other questions you had a

1071
00:38:21,680 --> 00:38:25,440
question right

1072
00:38:22,800 --> 00:38:26,560
how much prediction ready is the

1073
00:38:25,440 --> 00:38:30,800
registration two

1074
00:38:26,560 --> 00:38:33,839
is it just functionally complete is

1075
00:38:30,800 --> 00:38:33,839
already optimized

1076
00:38:34,480 --> 00:38:38,480
yes thank you the question was how ready

1077
00:38:37,040 --> 00:38:41,599
is ready's jason

1078
00:38:38,480 --> 00:38:44,000
ii um we uh

1079
00:38:41,599 --> 00:38:46,640
regis we as in writers labs released

1080
00:38:44,000 --> 00:38:50,160
this last year

1081
00:38:46,640 --> 00:38:53,920
the commits have been mostly bug fixes

1082
00:38:50,160 --> 00:38:55,680
so i know quite a few projects who use

1083
00:38:53,920 --> 00:38:57,040
this already in production

1084
00:38:55,680 --> 00:38:59,118
so the answer is it's ready for

1085
00:38:57,040 --> 00:39:00,800
primetime now

1086
00:38:59,119 --> 00:39:02,240
needless to say um pr's are still

1087
00:39:00,800 --> 00:39:04,880
accepted i think so

1088
00:39:02,240 --> 00:39:05,680
if you have further improvements let us

1089
00:39:04,880 --> 00:39:09,760
know

1090
00:39:05,680 --> 00:39:09,759
other questions before we close it off

1091
00:39:12,839 --> 00:39:16,880
yes

1092
00:39:14,240 --> 00:39:18,799
to the performance of creating a new

1093
00:39:16,880 --> 00:39:20,000
json document each time was it similar

1094
00:39:18,800 --> 00:39:23,599
to the performance

1095
00:39:20,000 --> 00:39:25,119
or is it faster the question was is the

1096
00:39:23,599 --> 00:39:28,880
performance

1097
00:39:25,119 --> 00:39:32,400
equal between creating a new um

1098
00:39:28,880 --> 00:39:35,920
json document or just updating one um

1099
00:39:32,400 --> 00:39:38,480
essentially the idea is if you

1100
00:39:35,920 --> 00:39:40,079
are updating one you basically have to

1101
00:39:38,480 --> 00:39:42,720
modify the contents that of course

1102
00:39:40,079 --> 00:39:43,680
includes a query in terms of where you

1103
00:39:42,720 --> 00:39:46,319
want to stick in the

1104
00:39:43,680 --> 00:39:48,720
second unit content so i don't have

1105
00:39:46,320 --> 00:39:50,960
exact performance benchmarks but i

1106
00:39:48,720 --> 00:39:52,959
based on the on the on the already kind

1107
00:39:50,960 --> 00:39:54,960
of native performance implementation i

1108
00:39:52,960 --> 00:39:58,400
wouldn't expect that overhead to be

1109
00:39:54,960 --> 00:40:00,880
really significant um but as i said

1110
00:39:58,400 --> 00:40:02,160
having haven't haven't

1111
00:40:00,880 --> 00:40:04,000
having not done the performance

1112
00:40:02,160 --> 00:40:06,319
benchmark for this particular use case

1113
00:40:04,000 --> 00:40:08,240
let's see another questions another

1114
00:40:06,319 --> 00:40:09,599
question

1115
00:40:08,240 --> 00:40:20,319
okay in that case i would like to thank

1116
00:40:09,599 --> 00:40:20,319
you for your time and enjoy the code

