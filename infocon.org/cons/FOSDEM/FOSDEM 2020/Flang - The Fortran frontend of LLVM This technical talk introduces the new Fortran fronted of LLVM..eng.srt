1
00:00:06,319 --> 00:00:10,480
uh hello everyone

2
00:00:07,839 --> 00:00:11,120
my name is kiran i'm a compiler engineer

3
00:00:10,480 --> 00:00:14,639
working

4
00:00:11,120 --> 00:00:16,400
at arm in the manchester office in uk

5
00:00:14,639 --> 00:00:18,480
basically working on the fortran front

6
00:00:16,400 --> 00:00:20,479
and for our compiler

7
00:00:18,480 --> 00:00:22,080
and the topic for my presentation today

8
00:00:20,480 --> 00:00:25,680
is flag

9
00:00:22,080 --> 00:00:25,680
the fortran front end of llvm

10
00:00:26,800 --> 00:00:30,240
this is basically a summary of the

11
00:00:28,080 --> 00:00:32,719
contents of this presentation

12
00:00:30,240 --> 00:00:33,680
first of all i mentioned a word about

13
00:00:32,719 --> 00:00:35,600
fortran

14
00:00:33,680 --> 00:00:37,280
i wasn't sure i know how many people

15
00:00:35,600 --> 00:00:40,399
here will be familiar with it

16
00:00:37,280 --> 00:00:43,280
why is it still important

17
00:00:40,399 --> 00:00:44,239
then there was a similarly named project

18
00:00:43,280 --> 00:00:47,280
you know

19
00:00:44,239 --> 00:00:48,800
that i call it old fly then i come to

20
00:00:47,280 --> 00:00:50,879
the new flying project which is the

21
00:00:48,800 --> 00:00:52,879
subject of this presentation

22
00:00:50,879 --> 00:00:54,160
i discuss the various compiler stages

23
00:00:52,879 --> 00:00:56,160
giving

24
00:00:54,160 --> 00:00:57,360
a bit of details about how things are

25
00:00:56,160 --> 00:01:00,959
implemented

26
00:00:57,360 --> 00:01:05,519
then i talk about how openmp is handled

27
00:01:00,960 --> 00:01:07,600
in this compiler then i talk about how

28
00:01:05,519 --> 00:01:08,640
very briefly about the driver the plans

29
00:01:07,600 --> 00:01:11,360
for the driver

30
00:01:08,640 --> 00:01:12,799
how the driver is interfaced with

31
00:01:11,360 --> 00:01:15,680
current llvm

32
00:01:12,799 --> 00:01:16,960
when i talk some of the details about

33
00:01:15,680 --> 00:01:18,720
what is the process and what is the

34
00:01:16,960 --> 00:01:21,280
status of the submission of this project

35
00:01:18,720 --> 00:01:24,720
to the llvm repository

36
00:01:21,280 --> 00:01:26,479
i then give a few

37
00:01:24,720 --> 00:01:28,240
information about how to contribute if

38
00:01:26,479 --> 00:01:29,840
someone is interested in contributing to

39
00:01:28,240 --> 00:01:32,798
this project

40
00:01:29,840 --> 00:01:34,320
i then give a brief status of where we

41
00:01:32,799 --> 00:01:35,920
are with the implementation

42
00:01:34,320 --> 00:01:41,679
what are the tentative timelines for

43
00:01:35,920 --> 00:01:44,399
this project and finally i conclude

44
00:01:41,680 --> 00:01:46,159
so whenever people say talk about

45
00:01:44,399 --> 00:01:48,720
fortran they think that it's a very

46
00:01:46,159 --> 00:01:51,600
old language and they don't tend to

47
00:01:48,720 --> 00:01:54,560
understand the importance of it

48
00:01:51,600 --> 00:01:55,039
it was one of the or it was probably the

49
00:01:54,560 --> 00:01:56,560
or

50
00:01:55,040 --> 00:01:58,880
the first high level programming

51
00:01:56,560 --> 00:02:00,640
language but it still continues to be

52
00:01:58,880 --> 00:02:02,079
popular particularly in the hpc

53
00:02:00,640 --> 00:02:04,320
community

54
00:02:02,079 --> 00:02:05,119
and i have a sentence here i have a few

55
00:02:04,320 --> 00:02:08,560
sentences

56
00:02:05,119 --> 00:02:10,639
i have a sentence here from steve lionel

57
00:02:08,560 --> 00:02:12,400
who is also the chair of the photon

58
00:02:10,639 --> 00:02:14,480
standards committee

59
00:02:12,400 --> 00:02:16,800
he gives a bit of reasons about why

60
00:02:14,480 --> 00:02:18,560
fortran continues to be popular

61
00:02:16,800 --> 00:02:20,319
mainly because there is actually a

62
00:02:18,560 --> 00:02:22,959
source of

63
00:02:20,319 --> 00:02:24,079
over 40 years old which still continues

64
00:02:22,959 --> 00:02:25,360
to compile because of the

65
00:02:24,080 --> 00:02:28,720
standardization of

66
00:02:25,360 --> 00:02:30,640
fortran then fortran has strengths in

67
00:02:28,720 --> 00:02:31,920
floating point computation array

68
00:02:30,640 --> 00:02:35,359
processing

69
00:02:31,920 --> 00:02:36,720
and all that it's actually now a modern

70
00:02:35,360 --> 00:02:38,480
language with support for

71
00:02:36,720 --> 00:02:41,040
object orientation modules and

72
00:02:38,480 --> 00:02:41,840
parallelism all fortran tended to have

73
00:02:41,040 --> 00:02:43,760
this you know

74
00:02:41,840 --> 00:02:45,040
that you have to write things in fixed

75
00:02:43,760 --> 00:02:47,280
columns and all that

76
00:02:45,040 --> 00:02:48,799
but new fortran is free source free form

77
00:02:47,280 --> 00:02:50,640
you can write it anywhere and it does

78
00:02:48,800 --> 00:02:52,480
not matter

79
00:02:50,640 --> 00:02:54,799
it continues to be used in the real

80
00:02:52,480 --> 00:02:57,440
world particularly in applications like

81
00:02:54,800 --> 00:02:58,400
weather forecasting numerical simulation

82
00:02:57,440 --> 00:03:00,239
modeling

83
00:02:58,400 --> 00:03:01,840
and also in very important libraries

84
00:03:00,239 --> 00:03:05,200
like la pac

85
00:03:01,840 --> 00:03:07,120
scipy and all that it also continues to

86
00:03:05,200 --> 00:03:08,879
be standardized on a regular basis

87
00:03:07,120 --> 00:03:11,920
the latest standard for the fortran

88
00:03:08,879 --> 00:03:13,840
language which came out was in 2018

89
00:03:11,920 --> 00:03:16,319
and the next standards are in the works

90
00:03:13,840 --> 00:03:21,040
22x and 22y

91
00:03:16,319 --> 00:03:21,040
expected to come in this decade

92
00:03:22,080 --> 00:03:27,920
so to give one more slide about the

93
00:03:25,440 --> 00:03:30,000
popularity of fortran in the uk there is

94
00:03:27,920 --> 00:03:31,839
a supercomputer called archer

95
00:03:30,000 --> 00:03:33,280
and they give some statistics of what

96
00:03:31,840 --> 00:03:36,879
are the kind of applications that

97
00:03:33,280 --> 00:03:39,760
generally run on this supercomputer

98
00:03:36,879 --> 00:03:41,760
so this graph on this right side is

99
00:03:39,760 --> 00:03:44,159
based on languages so you have c plus

100
00:03:41,760 --> 00:03:46,079
plus python c and fortran

101
00:03:44,159 --> 00:03:47,599
and there is one bubble for each

102
00:03:46,080 --> 00:03:49,040
application that is run on that

103
00:03:47,599 --> 00:03:51,518
supercomputer

104
00:03:49,040 --> 00:03:52,720
the size of the bubble represents the

105
00:03:51,519 --> 00:03:56,239
amount of time

106
00:03:52,720 --> 00:03:59,120
that is spent on the supercomputer

107
00:03:56,239 --> 00:04:00,959
the darkness refers to the number of

108
00:03:59,120 --> 00:04:02,000
users that use it

109
00:04:00,959 --> 00:04:04,159
so you can see that on that

110
00:04:02,000 --> 00:04:06,480
supercomputer a lot of the applications

111
00:04:04,159 --> 00:04:09,200
that are run continues to be fortran

112
00:04:06,480 --> 00:04:10,720
more than 60 of the application

113
00:04:09,200 --> 00:04:12,480
continues before trend

114
00:04:10,720 --> 00:04:14,720
so it's very important in the hpc

115
00:04:12,480 --> 00:04:16,079
community that you have fortran compiler

116
00:04:14,720 --> 00:04:19,440
and you are able to generate

117
00:04:16,079 --> 00:04:19,440
high performance code for that

118
00:04:20,720 --> 00:04:26,080
now we come to the old flying project

119
00:04:23,759 --> 00:04:27,600
so all final project was a project that

120
00:04:26,080 --> 00:04:30,000
was designed to generate

121
00:04:27,600 --> 00:04:31,199
llvm ir and to interface with llvm

122
00:04:30,000 --> 00:04:32,639
infrastructure

123
00:04:31,199 --> 00:04:34,400
it was a project that was sponsored by

124
00:04:32,639 --> 00:04:35,759
the us department of energy and its

125
00:04:34,400 --> 00:04:38,159
national labs

126
00:04:35,759 --> 00:04:39,600
so they signed a contract with pgi or

127
00:04:38,160 --> 00:04:42,240
nvidia

128
00:04:39,600 --> 00:04:43,600
and pga was to take out the front end of

129
00:04:42,240 --> 00:04:47,360
their compiler

130
00:04:43,600 --> 00:04:50,479
uh you know make it generate lvm ir

131
00:04:47,360 --> 00:04:52,880
uh and then open source it using some

132
00:04:50,479 --> 00:04:54,880
license so they they open source it to

133
00:04:52,880 --> 00:04:56,960
the apache 2 license and they recently

134
00:04:54,880 --> 00:04:59,600
switched to the llvm license

135
00:04:56,960 --> 00:05:00,960
this project was available since uh may

136
00:04:59,600 --> 00:05:05,280
of 2017

137
00:05:00,960 --> 00:05:08,239
it runs on various platforms arc64 x864

138
00:05:05,280 --> 00:05:09,359
and power pc and this with the

139
00:05:08,240 --> 00:05:11,520
availability of this

140
00:05:09,360 --> 00:05:14,000
compiler it filled the key gap in the

141
00:05:11,520 --> 00:05:16,080
llvm story for hpc previously

142
00:05:14,000 --> 00:05:17,199
uh llvm did not have a front pin for

143
00:05:16,080 --> 00:05:18,639
fortran so

144
00:05:17,199 --> 00:05:20,400
if you have to use it you would have to

145
00:05:18,639 --> 00:05:21,759
either use g fortran or some other

146
00:05:20,400 --> 00:05:24,239
compiler there's no

147
00:05:21,759 --> 00:05:26,639
free alternative that generated lvm ir

148
00:05:24,240 --> 00:05:30,000
for hpc so this was the first one

149
00:05:26,639 --> 00:05:31,600
which filled that key gap for hpc

150
00:05:30,000 --> 00:05:33,520
now this was not just a project which

151
00:05:31,600 --> 00:05:35,520
was to demonstrate that it's possible

152
00:05:33,520 --> 00:05:37,280
it was adopted by many companies and it

153
00:05:35,520 --> 00:05:38,719
became the fortran frontends of their

154
00:05:37,280 --> 00:05:40,719
compilers

155
00:05:38,720 --> 00:05:41,919
uh pgi compiler obviously because of

156
00:05:40,720 --> 00:05:44,080
their source

157
00:05:41,919 --> 00:05:45,120
it was adopted by arm compiler for their

158
00:05:44,080 --> 00:05:47,520
fortran front tent

159
00:05:45,120 --> 00:05:50,639
and also it was the frontend for the amd

160
00:05:47,520 --> 00:05:50,639
optimizing compiler

161
00:05:50,960 --> 00:05:55,359
it is not just a a compiler it's also a

162
00:05:53,680 --> 00:05:57,600
very performant compiler

163
00:05:55,360 --> 00:05:58,639
so i have two graphs here uh this is

164
00:05:57,600 --> 00:06:01,199
taken from

165
00:05:58,639 --> 00:06:03,360
uh steve's calcone of nvidia who is from

166
00:06:01,199 --> 00:06:04,800
his presentation in eurlvm

167
00:06:03,360 --> 00:06:07,120
so i have several benchmarks here

168
00:06:04,800 --> 00:06:08,479
probably various versions of spec

169
00:06:07,120 --> 00:06:10,560
and spec coin which are parallel

170
00:06:08,479 --> 00:06:12,960
benchmarks and the last one shows the

171
00:06:10,560 --> 00:06:15,440
geome of all these benchmarks

172
00:06:12,960 --> 00:06:16,799
the light blue color shows for flying

173
00:06:15,440 --> 00:06:19,680
the dark blue is for

174
00:06:16,800 --> 00:06:20,639
g4 tran and the yellow line is the pga

175
00:06:19,680 --> 00:06:22,479
compiler

176
00:06:20,639 --> 00:06:24,639
so as you can see from this jio main

177
00:06:22,479 --> 00:06:27,758
this flying is actually

178
00:06:24,639 --> 00:06:29,199
better in performance compared to g4 fan

179
00:06:27,759 --> 00:06:32,560
and approaching the performance of the

180
00:06:29,199 --> 00:06:32,560
pgi commercial compiler

181
00:06:32,720 --> 00:06:36,160
the one on the right side is basically a

182
00:06:34,240 --> 00:06:37,600
comparison of all the fortran benchmarks

183
00:06:36,160 --> 00:06:40,160
in spec 2017.

184
00:06:37,600 --> 00:06:42,080
again it's the same story here that uh

185
00:06:40,160 --> 00:06:43,840
flying is better than g for trend but

186
00:06:42,080 --> 00:06:45,039
it's a bit slower than the pga

187
00:06:43,840 --> 00:06:46,638
commercial compiler

188
00:06:45,039 --> 00:06:47,919
so i'm showing this slide basically so

189
00:06:46,639 --> 00:06:50,479
that it's actually a performance

190
00:06:47,919 --> 00:06:50,479
compiler

191
00:06:51,520 --> 00:06:57,758
so currently the latest standards in

192
00:06:53,520 --> 00:07:00,240
fortran are for from 2003 2008 and 2018.

193
00:06:57,759 --> 00:07:02,240
flank did support a good amount of these

194
00:07:00,240 --> 00:07:05,680
standards so when it came out

195
00:07:02,240 --> 00:07:08,479
it supported fortran 2003 mostly

196
00:07:05,680 --> 00:07:10,639
uh coming to fortran 2008 it was mostly

197
00:07:08,479 --> 00:07:11,758
partial but as years progress or in a

198
00:07:10,639 --> 00:07:13,680
couple of years

199
00:07:11,759 --> 00:07:15,120
more features were added the only

200
00:07:13,680 --> 00:07:17,680
important omission is that

201
00:07:15,120 --> 00:07:19,199
there is no plan for core race cores is

202
00:07:17,680 --> 00:07:21,280
a parallel feature that is

203
00:07:19,199 --> 00:07:22,880
embedded into the language but other

204
00:07:21,280 --> 00:07:26,159
than that most of the features were

205
00:07:22,880 --> 00:07:28,719
supported in the flying compiler

206
00:07:26,160 --> 00:07:29,199
but coming to fortran 2018 there is no

207
00:07:28,720 --> 00:07:30,880
plan

208
00:07:29,199 --> 00:07:33,039
in the old flank compiler to support

209
00:07:30,880 --> 00:07:33,039
that

210
00:07:33,520 --> 00:07:36,960
now although this flank compile is a

211
00:07:35,199 --> 00:07:38,960
performant compiler and

212
00:07:36,960 --> 00:07:40,239
it was adopted by many companies as

213
00:07:38,960 --> 00:07:43,440
their front end

214
00:07:40,240 --> 00:07:45,120
it still had a lot of issues and these

215
00:07:43,440 --> 00:07:47,919
are some of the issues that

216
00:07:45,120 --> 00:07:49,039
became you know uh the reasons why the

217
00:07:47,919 --> 00:07:51,840
new flying compiler

218
00:07:49,039 --> 00:07:53,840
is necessary so the first one was that

219
00:07:51,840 --> 00:07:55,758
it was not a pure open source project in

220
00:07:53,840 --> 00:07:58,799
the sense that it was actually

221
00:07:55,759 --> 00:08:00,400
ripped out of a commercial compiler and

222
00:07:58,800 --> 00:08:03,120
the way it was open sourced

223
00:08:00,400 --> 00:08:04,960
there is no way to actually make

224
00:08:03,120 --> 00:08:07,039
submissions to that project

225
00:08:04,960 --> 00:08:08,878
and then get it accepted only a handful

226
00:08:07,039 --> 00:08:10,479
of pull requests were up to accepted

227
00:08:08,879 --> 00:08:12,560
over a period of two years

228
00:08:10,479 --> 00:08:14,560
the reason was that any pull request

229
00:08:12,560 --> 00:08:17,520
that you submit had to go into their

230
00:08:14,560 --> 00:08:17,759
pgs or nvds commercial compiler and then

231
00:08:17,520 --> 00:08:19,840
it

232
00:08:17,759 --> 00:08:21,520
runs through all the cei and goes to the

233
00:08:19,840 --> 00:08:23,119
reviews there and then

234
00:08:21,520 --> 00:08:24,840
and then if it's all fine it has to come

235
00:08:23,120 --> 00:08:27,120
back to flank and then finally get

236
00:08:24,840 --> 00:08:28,479
approved and there are no developers

237
00:08:27,120 --> 00:08:30,000
assigned for this

238
00:08:28,479 --> 00:08:31,520
and it was the managers who were doing

239
00:08:30,000 --> 00:08:35,839
this and you know

240
00:08:31,520 --> 00:08:37,439
uh so that did not work out very fine

241
00:08:35,839 --> 00:08:39,680
the other reasons for that the code is

242
00:08:37,440 --> 00:08:42,560
very old the pgi

243
00:08:39,679 --> 00:08:45,359
or the flying project is open source it

244
00:08:42,559 --> 00:08:47,439
had a code history of almost 30 years

245
00:08:45,360 --> 00:08:49,680
so you can imagine that over 30 years

246
00:08:47,440 --> 00:08:51,680
you know a lot of routing has happened

247
00:08:49,680 --> 00:08:54,640
the original people who implemented that

248
00:08:51,680 --> 00:08:56,719
compiler are no more there

249
00:08:54,640 --> 00:08:58,080
and there are a lot of other things like

250
00:08:56,720 --> 00:09:01,200
you know they used

251
00:08:58,080 --> 00:09:03,680
uh flags which are new numbers

252
00:09:01,200 --> 00:09:04,640
uh there are a lot of global variables

253
00:09:03,680 --> 00:09:06,160
and things like that

254
00:09:04,640 --> 00:09:08,399
and typically when you try to fix

255
00:09:06,160 --> 00:09:11,279
something here then something like that

256
00:09:08,399 --> 00:09:12,720
so it had all these old issues so its

257
00:09:11,279 --> 00:09:14,399
code is all difficult to maintain and

258
00:09:12,720 --> 00:09:15,760
the entry battery is high

259
00:09:14,399 --> 00:09:17,680
the error message is provided with

260
00:09:15,760 --> 00:09:19,519
compiler it usually gives only the line

261
00:09:17,680 --> 00:09:22,079
number there is no column number so it

262
00:09:19,519 --> 00:09:24,160
is not high quality error messages it

263
00:09:22,080 --> 00:09:26,160
was also when they approached the llvm

264
00:09:24,160 --> 00:09:27,199
community it was mentioned that no no we

265
00:09:26,160 --> 00:09:29,279
cannot accept it as

266
00:09:27,200 --> 00:09:31,600
our front end due to some of these

267
00:09:29,279 --> 00:09:33,839
reasons and also that it's rnc

268
00:09:31,600 --> 00:09:35,040
it generates lvm ir but it does not use

269
00:09:33,839 --> 00:09:37,680
the ir builder

270
00:09:35,040 --> 00:09:39,519
it uses generates ir using printf

271
00:09:37,680 --> 00:09:41,359
statements and all that

272
00:09:39,519 --> 00:09:43,519
it cannot be used as a library which is

273
00:09:41,360 --> 00:09:45,360
one of the you know cornerstones of lvm

274
00:09:43,519 --> 00:09:45,920
that things could be used as libraries

275
00:09:45,360 --> 00:09:47,600
so

276
00:09:45,920 --> 00:09:49,839
because of all these issues it didn't it

277
00:09:47,600 --> 00:09:50,720
never became the fortran front end of

278
00:09:49,839 --> 00:09:52,800
llvm

279
00:09:50,720 --> 00:09:54,800
so now there are two options one you can

280
00:09:52,800 --> 00:09:58,079
try to improve the

281
00:09:54,800 --> 00:10:01,279
existing flag compiler or try to write

282
00:09:58,080 --> 00:10:02,640
something new so work started on trying

283
00:10:01,279 --> 00:10:06,000
to improve the old one

284
00:10:02,640 --> 00:10:08,480
but that did not go that well so

285
00:10:06,000 --> 00:10:09,760
you know people decide that okay let's

286
00:10:08,480 --> 00:10:12,240
try something new

287
00:10:09,760 --> 00:10:14,959
for the next 30 years and that's the new

288
00:10:12,240 --> 00:10:14,959
flying project

289
00:10:15,760 --> 00:10:18,880
so the new flying project or f-18 that

290
00:10:18,240 --> 00:10:20,880
was saying

291
00:10:18,880 --> 00:10:23,360
that was a name that was initially given

292
00:10:20,880 --> 00:10:25,040
but uh in the community when it was

293
00:10:23,360 --> 00:10:27,200
uh accepted as the fourth round front

294
00:10:25,040 --> 00:10:28,880
end of lvm people decided that

295
00:10:27,200 --> 00:10:30,320
flying is the right name for that

296
00:10:28,880 --> 00:10:34,240
project uh

297
00:10:30,320 --> 00:10:36,160
so that rhymes with clang also uh

298
00:10:34,240 --> 00:10:38,480
it was accepted as a fortran front end

299
00:10:36,160 --> 00:10:41,519
somewhere in the middle of last year

300
00:10:38,480 --> 00:10:43,360
uh it is it uses the llvm license apache

301
00:10:41,519 --> 00:10:46,800
with aluminium exceptions

302
00:10:43,360 --> 00:10:48,399
uh pgi or nvidia continues to be the

303
00:10:46,800 --> 00:10:50,319
lead developer of this project

304
00:10:48,399 --> 00:10:51,600
arm amd and people in the us national

305
00:10:50,320 --> 00:10:53,120
apps are contributing

306
00:10:51,600 --> 00:10:54,480
everyone else is also allowed to

307
00:10:53,120 --> 00:10:55,760
contribute the project is being

308
00:10:54,480 --> 00:10:59,279
developed in the open

309
00:10:55,760 --> 00:11:00,000
in github and the main initial features

310
00:10:59,279 --> 00:11:02,320
of this project

311
00:11:00,000 --> 00:11:03,360
was that it uses the fortran 2018

312
00:11:02,320 --> 00:11:06,160
standard as the

313
00:11:03,360 --> 00:11:08,160
primary reference for implementation it

314
00:11:06,160 --> 00:11:08,719
is very standardization friendly we will

315
00:11:08,160 --> 00:11:11,360
see that

316
00:11:08,720 --> 00:11:13,200
in the next few slides it is returned in

317
00:11:11,360 --> 00:11:16,640
modern c plus plus its accelerating c

318
00:11:13,200 --> 00:11:18,399
plus plus 17 uh existing lvm code base

319
00:11:16,640 --> 00:11:21,279
and c plus plus 14. so it's a

320
00:11:18,399 --> 00:11:23,519
step up from there and they got a a

321
00:11:21,279 --> 00:11:25,680
specific exception for this project

322
00:11:23,519 --> 00:11:27,279
yes it's gonna see plus plus classes

323
00:11:25,680 --> 00:11:28,160
it's only lowered after doing all the

324
00:11:27,279 --> 00:11:30,560
semantic checks

325
00:11:28,160 --> 00:11:32,399
all flying was lowered early it has high

326
00:11:30,560 --> 00:11:33,279
quality source equations can be used for

327
00:11:32,399 --> 00:11:35,279
tooling

328
00:11:33,279 --> 00:11:36,959
and somebody in nvidia has already

329
00:11:35,279 --> 00:11:41,200
written some portion of a flying d

330
00:11:36,959 --> 00:11:44,719
tool for that so now we come to the

331
00:11:41,200 --> 00:11:46,240
various stages of this compiler uh

332
00:11:44,720 --> 00:11:47,600
particularly i'll be in the next few

333
00:11:46,240 --> 00:11:49,120
slides i'll be looking at the

334
00:11:47,600 --> 00:11:53,519
pre-processing

335
00:11:49,120 --> 00:11:57,200
uh the parsing and the semantic analysis

336
00:11:53,519 --> 00:11:59,120
so there is a stage called the

337
00:11:57,200 --> 00:12:00,959
the pre-processing comp is composed of

338
00:11:59,120 --> 00:12:02,240
two things one is pre-scanning and

339
00:12:00,959 --> 00:12:05,199
pre-processing

340
00:12:02,240 --> 00:12:06,800
so the whole idea of this stage is that

341
00:12:05,200 --> 00:12:08,959
photon is actually a very difficult

342
00:12:06,800 --> 00:12:10,560
language to pass it does not

343
00:12:08,959 --> 00:12:12,079
it has a lot of contact sensitivity

344
00:12:10,560 --> 00:12:15,518
there white space are not

345
00:12:12,079 --> 00:12:16,560
important uh and a lot of things like

346
00:12:15,519 --> 00:12:18,399
that so

347
00:12:16,560 --> 00:12:19,680
so what the free scanner does is that it

348
00:12:18,399 --> 00:12:22,639
tries to remove as much of

349
00:12:19,680 --> 00:12:23,279
these issues as possible it normalizes

350
00:12:22,639 --> 00:12:27,279
the source

351
00:12:23,279 --> 00:12:30,560
expands the macros changes all the

352
00:12:27,279 --> 00:12:32,240
case to lower case and

353
00:12:30,560 --> 00:12:34,239
and then what you output is a cooked

354
00:12:32,240 --> 00:12:35,440
source and also a provenance is

355
00:12:34,240 --> 00:12:37,519
generated

356
00:12:35,440 --> 00:12:40,720
so all the next stages look at the coupe

357
00:12:37,519 --> 00:12:43,040
source rather than the original source

358
00:12:40,720 --> 00:12:44,880
and the provenance is basically that it

359
00:12:43,040 --> 00:12:47,279
maintains maps to the

360
00:12:44,880 --> 00:12:48,880
existing so the original source so that

361
00:12:47,279 --> 00:12:50,240
if a later stage comes up with an error

362
00:12:48,880 --> 00:12:53,839
message you can always map it to the

363
00:12:50,240 --> 00:12:53,839
original source

364
00:13:00,720 --> 00:13:05,360
the next stage is passing it is

365
00:13:03,279 --> 00:13:07,600
basically a recursive descent

366
00:13:05,360 --> 00:13:09,920
passing that is used there are no tables

367
00:13:07,600 --> 00:13:11,440
or anything that is there

368
00:13:09,920 --> 00:13:13,839
the password is returning a declarative

369
00:13:11,440 --> 00:13:15,920
fashion it's a bit of it's stone on the

370
00:13:13,839 --> 00:13:17,440
right side example which we come to

371
00:13:15,920 --> 00:13:19,360
the grammar is taken from the standard

372
00:13:17,440 --> 00:13:21,839
left recursion and all those things that

373
00:13:19,360 --> 00:13:23,440
hurts a uh you know recursive decent

374
00:13:21,839 --> 00:13:25,120
parcel are removed

375
00:13:23,440 --> 00:13:26,639
it basically uses the idea of parser

376
00:13:25,120 --> 00:13:29,839
combinators there are

377
00:13:26,639 --> 00:13:30,560
various uh you know token passes that

378
00:13:29,839 --> 00:13:32,560
are written

379
00:13:30,560 --> 00:13:34,638
and then there are functions and

380
00:13:32,560 --> 00:13:37,839
combinators to come combine these two

381
00:13:34,639 --> 00:13:39,680
form more complicated passes the pass

382
00:13:37,839 --> 00:13:40,240
three actually follows specification the

383
00:13:39,680 --> 00:13:41,839
standard

384
00:13:40,240 --> 00:13:43,360
so that's why one of the points that i

385
00:13:41,839 --> 00:13:46,560
mentioned earlier is that

386
00:13:43,360 --> 00:13:48,399
this is very standard friendly so i have

387
00:13:46,560 --> 00:13:50,399
different entries on the right hand side

388
00:13:48,399 --> 00:13:50,880
the first one is the original fortran

389
00:13:50,399 --> 00:13:53,600
source

390
00:13:50,880 --> 00:13:55,360
which says integer x is equal to 1. so

391
00:13:53,600 --> 00:13:56,720
i'm concentrating on that x is equal to

392
00:13:55,360 --> 00:13:58,399
1 part

393
00:13:56,720 --> 00:14:00,079
next when we come to the standards

394
00:13:58,399 --> 00:14:01,360
document what the standards document

395
00:14:00,079 --> 00:14:04,479
says is that

396
00:14:01,360 --> 00:14:05,279
an entity declaration com contains an

397
00:14:04,480 --> 00:14:08,560
object name

398
00:14:05,279 --> 00:14:10,240
that is x here it can be

399
00:14:08,560 --> 00:14:12,638
an array so that means it will have an

400
00:14:10,240 --> 00:14:14,639
array spec it can be a co array which is

401
00:14:12,639 --> 00:14:16,959
a parallel feature in fortran

402
00:14:14,639 --> 00:14:18,880
or it can be a character then that

403
00:14:16,959 --> 00:14:20,719
information has to be there

404
00:14:18,880 --> 00:14:22,480
or it can contain an initialization so

405
00:14:20,720 --> 00:14:24,000
this array spec the core aspect the

406
00:14:22,480 --> 00:14:24,320
character length and initialization are

407
00:14:24,000 --> 00:14:27,360
all

408
00:14:24,320 --> 00:14:27,920
optional so the password that's written

409
00:14:27,360 --> 00:14:30,320
also

410
00:14:27,920 --> 00:14:31,599
follows from that so the parser

411
00:14:30,320 --> 00:14:34,160
basically says that

412
00:14:31,600 --> 00:14:36,160
you generate an entity declaration and

413
00:14:34,160 --> 00:14:39,360
it should have an object name

414
00:14:36,160 --> 00:14:41,120
maybe an array spec maybe a core spec

415
00:14:39,360 --> 00:14:42,639
maybe a character length maybe an

416
00:14:41,120 --> 00:14:44,959
initialization

417
00:14:42,639 --> 00:14:45,760
so the way the password is written it

418
00:14:44,959 --> 00:14:48,000
follows

419
00:14:45,760 --> 00:14:49,360
what is written in the standard and when

420
00:14:48,000 --> 00:14:51,760
you come when you come to the

421
00:14:49,360 --> 00:14:54,160
pass-through node also you can see that

422
00:14:51,760 --> 00:14:55,519
it's basically a tuple which contains an

423
00:14:54,160 --> 00:14:57,199
object name

424
00:14:55,519 --> 00:14:58,560
followed by an optional array spec a

425
00:14:57,199 --> 00:15:00,079
core aspect

426
00:14:58,560 --> 00:15:01,839
a character length and an optional

427
00:15:00,079 --> 00:15:03,839
initialization so

428
00:15:01,839 --> 00:15:05,600
all these things follow the standards

429
00:15:03,839 --> 00:15:07,920
very closely so that

430
00:15:05,600 --> 00:15:12,320
someone wants to add a new feature it's

431
00:15:07,920 --> 00:15:13,199
probably easier to do that so once

432
00:15:12,320 --> 00:15:15,360
passing is com

433
00:15:13,199 --> 00:15:17,680
complete you go to the semantic analysis

434
00:15:15,360 --> 00:15:20,240
stage so the basic job of the semantic

435
00:15:17,680 --> 00:15:21,839
analysis is to do that whatever code

436
00:15:20,240 --> 00:15:23,360
that passes through this stage

437
00:15:21,839 --> 00:15:24,880
conforms to the standard so there are a

438
00:15:23,360 --> 00:15:26,320
lot of error checks and all that happens

439
00:15:24,880 --> 00:15:28,880
at this stage

440
00:15:26,320 --> 00:15:29,440
so it's composed of many things so first

441
00:15:28,880 --> 00:15:31,120
is that

442
00:15:29,440 --> 00:15:32,800
it does label resolution so there are a

443
00:15:31,120 --> 00:15:34,160
lot of jump statements and all that with

444
00:15:32,800 --> 00:15:35,599
labels and all that

445
00:15:34,160 --> 00:15:37,120
so it goes ahead and checks that all

446
00:15:35,600 --> 00:15:38,959
these labels are valid they are in the

447
00:15:37,120 --> 00:15:40,800
correct scope and all that

448
00:15:38,959 --> 00:15:43,199
then it does name a solution basically

449
00:15:40,800 --> 00:15:45,758
it constructs go to these declarations

450
00:15:43,199 --> 00:15:48,160
tries to fill in a symbol table and

451
00:15:45,759 --> 00:15:49,680
tries to assign scope for all these

452
00:15:48,160 --> 00:15:51,920
now the problem with fortran is that

453
00:15:49,680 --> 00:15:53,599
because as i said it's difficult to pass

454
00:15:51,920 --> 00:15:56,560
it can be the case that the past is

455
00:15:53,600 --> 00:15:58,720
ambiguous so you might actually have to

456
00:15:56,560 --> 00:16:01,199
modify the parse tree based on new

457
00:15:58,720 --> 00:16:03,120
information that became available

458
00:16:01,199 --> 00:16:05,599
as part of the name resolution so this

459
00:16:03,120 --> 00:16:09,199
stage does and goes and changes it so

460
00:16:05,600 --> 00:16:11,440
one of the things that is that the array

461
00:16:09,199 --> 00:16:13,120
the way you call the way an array is

462
00:16:11,440 --> 00:16:14,720
written and a function called they look

463
00:16:13,120 --> 00:16:18,079
very similar so

464
00:16:14,720 --> 00:16:21,120
there can be mispasses there

465
00:16:18,079 --> 00:16:23,439
and once the password is modified then a

466
00:16:21,120 --> 00:16:25,360
constant expression evaluation happens

467
00:16:23,440 --> 00:16:27,360
and then this checks for expression and

468
00:16:25,360 --> 00:16:30,480
statement semantics are done

469
00:16:27,360 --> 00:16:33,040
and then a module file is generated if

470
00:16:30,480 --> 00:16:36,959
it's a module

471
00:16:33,040 --> 00:16:39,120
so that is a

472
00:16:36,959 --> 00:16:40,880
matter of this slide so it basically

473
00:16:39,120 --> 00:16:43,920
describes the module format

474
00:16:40,880 --> 00:16:46,320
so i have some fortran source code here

475
00:16:43,920 --> 00:16:48,880
basically it has a module variable it

476
00:16:46,320 --> 00:16:51,120
has a module called module wars

477
00:16:48,880 --> 00:16:52,320
it has two declarations for an integer

478
00:16:51,120 --> 00:16:55,040
and a real

479
00:16:52,320 --> 00:16:56,800
it contains subroutine called add valley

480
00:16:55,040 --> 00:17:00,160
which basically takes in a parameter

481
00:16:56,800 --> 00:17:02,479
x and adds that to the variable a which

482
00:17:00,160 --> 00:17:04,879
is part of this module

483
00:17:02,480 --> 00:17:06,720
now there are various ways so the idea

484
00:17:04,880 --> 00:17:08,319
is that once you have this as a module

485
00:17:06,720 --> 00:17:10,240
other places in the code can use this

486
00:17:08,319 --> 00:17:12,240
module to access the variables here or

487
00:17:10,240 --> 00:17:14,079
the functionality here

488
00:17:12,240 --> 00:17:15,839
so once you have processed this file

489
00:17:14,079 --> 00:17:16,319
it's returned to as a module file and

490
00:17:15,839 --> 00:17:18,480
others

491
00:17:16,319 --> 00:17:20,399
passes other portions of the code can

492
00:17:18,480 --> 00:17:22,160
read it and do whatever they want

493
00:17:20,400 --> 00:17:24,880
so how do you represent this various

494
00:17:22,160 --> 00:17:26,799
compilers do this in different ways

495
00:17:24,880 --> 00:17:28,559
you can actually dump it as an internal

496
00:17:26,799 --> 00:17:30,879
format and then read it back

497
00:17:28,559 --> 00:17:32,639
but what if what the new flag does is

498
00:17:30,880 --> 00:17:34,240
that it actually dumps it as a fortran

499
00:17:32,640 --> 00:17:36,640
source itself

500
00:17:34,240 --> 00:17:38,400
and then you can read it back and then

501
00:17:36,640 --> 00:17:41,760
the parser pass it and

502
00:17:38,400 --> 00:17:44,000
constructs a tree and all that fast

503
00:17:41,760 --> 00:17:45,600
so the reason one of the reasons that it

504
00:17:44,000 --> 00:17:47,200
can do this fast is that you don't have

505
00:17:45,600 --> 00:17:49,840
to do pre-processing or anything

506
00:17:47,200 --> 00:17:51,520
all that has already been done and the

507
00:17:49,840 --> 00:17:53,360
password is very fast so that

508
00:17:51,520 --> 00:17:55,520
it can read this and then create the

509
00:17:53,360 --> 00:17:58,000
internal structures

510
00:17:55,520 --> 00:17:59,360
so the module file basically contains

511
00:17:58,000 --> 00:18:02,000
the name of the module

512
00:17:59,360 --> 00:18:04,959
the version of this module it contains a

513
00:18:02,000 --> 00:18:06,480
checksum and all the publicly visible

514
00:18:04,960 --> 00:18:15,520
variables and functions that are part of

515
00:18:06,480 --> 00:18:17,679
this module now we come to the optimizer

516
00:18:15,520 --> 00:18:17,679
so

517
00:18:19,600 --> 00:18:27,120
so once the semantic checks are all done

518
00:18:22,880 --> 00:18:28,880
then you can either generate llvm ir

519
00:18:27,120 --> 00:18:30,639
or you can have an intermediate high

520
00:18:28,880 --> 00:18:31,919
level ir to do some high level

521
00:18:30,640 --> 00:18:33,360
optimizations

522
00:18:31,919 --> 00:18:35,200
so that's the approach that the new

523
00:18:33,360 --> 00:18:38,399
flying compiler does

524
00:18:35,200 --> 00:18:41,440
and it uses the mlir framework to

525
00:18:38,400 --> 00:18:42,720
it defines a new ir called fir of ultron

526
00:18:41,440 --> 00:18:45,919
ir

527
00:18:42,720 --> 00:18:47,840
and the asd is lowered to that ir

528
00:18:45,919 --> 00:18:49,760
and then a lot of optimization passes

529
00:18:47,840 --> 00:18:52,559
are done there

530
00:18:49,760 --> 00:18:54,720
so the reason it does is that sometimes

531
00:18:52,559 --> 00:18:56,240
fortran requires a lot of

532
00:18:54,720 --> 00:18:58,160
information that requires knowledge of

533
00:18:56,240 --> 00:18:59,760
the fortran language and only

534
00:18:58,160 --> 00:19:02,400
with the presence of that you can

535
00:18:59,760 --> 00:19:04,879
actually do these optimizations

536
00:19:02,400 --> 00:19:06,160
so uh i'm not going to into the details

537
00:19:04,880 --> 00:19:09,520
of this there is a talk at

538
00:19:06,160 --> 00:19:12,160
lvm dev if you're interested you can

539
00:19:09,520 --> 00:19:12,160
go to that

540
00:19:17,600 --> 00:19:23,600
so i missed a point so so

541
00:19:20,960 --> 00:19:24,400
i said that you generate the mlir

542
00:19:23,600 --> 00:19:26,879
dialect of

543
00:19:24,400 --> 00:19:27,520
for fortran so there is also an llvm

544
00:19:26,880 --> 00:19:30,880
dialect

545
00:19:27,520 --> 00:19:34,000
in mlir so what finally happens is that

546
00:19:30,880 --> 00:19:35,520
the mli dialect of fortran fir is

547
00:19:34,000 --> 00:19:38,880
finally lowered when the

548
00:19:35,520 --> 00:19:39,760
lvm dialect in mlir and their excess

549
00:19:38,880 --> 00:19:42,000
code in

550
00:19:39,760 --> 00:19:43,919
in mlir which translates the llvm

551
00:19:42,000 --> 00:19:45,600
dialect down to llvmir

552
00:19:43,919 --> 00:19:47,120
so they will use that to generate the

553
00:19:45,600 --> 00:19:53,280
llvm ir

554
00:19:47,120 --> 00:19:55,840
so that's how the lvmir is generated

555
00:19:53,280 --> 00:19:56,559
so the next slide discuss how openmp is

556
00:19:55,840 --> 00:19:58,959
handled in

557
00:19:56,559 --> 00:20:00,960
this compiler now it should be noted

558
00:19:58,960 --> 00:20:03,919
that openmp is standardized for both

559
00:20:00,960 --> 00:20:05,360
c and c plus plus and fortran so there x

560
00:20:03,919 --> 00:20:08,240
is lot of code in

561
00:20:05,360 --> 00:20:10,559
in the llvm compiler which generates

562
00:20:08,240 --> 00:20:12,400
code or the generates llvmir for various

563
00:20:10,559 --> 00:20:15,280
openmp constructs

564
00:20:12,400 --> 00:20:16,640
so the design is such that you we should

565
00:20:15,280 --> 00:20:18,080
be able to reuse some of this

566
00:20:16,640 --> 00:20:20,080
information that's already there in the

567
00:20:18,080 --> 00:20:22,639
llm infrastructure

568
00:20:20,080 --> 00:20:24,080
so to do this we have two components one

569
00:20:22,640 --> 00:20:25,760
is mlir again

570
00:20:24,080 --> 00:20:29,918
and the second one is the openmp ir

571
00:20:25,760 --> 00:20:34,320
builder so we define a new dialect for

572
00:20:29,919 --> 00:20:37,760
for openmp called the openmp mli dialect

573
00:20:34,320 --> 00:20:39,918
uh and then so

574
00:20:37,760 --> 00:20:41,280
the reason is that because fortran

575
00:20:39,919 --> 00:20:43,120
although the photo fir

576
00:20:41,280 --> 00:20:44,639
dialect is there it only represents the

577
00:20:43,120 --> 00:20:47,039
forefront language constructs

578
00:20:44,640 --> 00:20:48,559
it does not represent anything in openmp

579
00:20:47,039 --> 00:20:51,200
and to uh so

580
00:20:48,559 --> 00:20:52,879
and just restrict the far dialect only

581
00:20:51,200 --> 00:20:53,600
to forefront language there is no openmp

582
00:20:52,880 --> 00:20:55,360
in that

583
00:20:53,600 --> 00:20:57,360
so we have this separate dialect for

584
00:20:55,360 --> 00:20:59,600
openmp

585
00:20:57,360 --> 00:21:00,639
the second component is the openmpir

586
00:20:59,600 --> 00:21:02,639
builder so

587
00:21:00,640 --> 00:21:04,240
openmpir builder is basically a project

588
00:21:02,640 --> 00:21:06,400
which is started by johannes

589
00:21:04,240 --> 00:21:08,159
so what this does is that it takes out

590
00:21:06,400 --> 00:21:11,440
all the code which generates

591
00:21:08,159 --> 00:21:14,799
llvm ir for openmp constructs in clang

592
00:21:11,440 --> 00:21:16,880
and moves it into the llvm directory

593
00:21:14,799 --> 00:21:18,158
so there will be functions like create

594
00:21:16,880 --> 00:21:20,880
barrier which will

595
00:21:18,159 --> 00:21:22,400
go and generate the code for the barrier

596
00:21:20,880 --> 00:21:25,039
construct

597
00:21:22,400 --> 00:21:27,200
so now in flank project also we can call

598
00:21:25,039 --> 00:21:28,720
create barrier using the openmpir

599
00:21:27,200 --> 00:21:31,840
builder to generate lvmi

600
00:21:28,720 --> 00:21:33,120
for that

601
00:21:31,840 --> 00:21:35,520
so that's what basically what is

602
00:21:33,120 --> 00:21:36,879
summarized here so

603
00:21:35,520 --> 00:21:38,639
you have the forefront language the

604
00:21:36,880 --> 00:21:41,200
password generates the ast

605
00:21:38,640 --> 00:21:43,760
and when it comes to law offering a mix

606
00:21:41,200 --> 00:21:46,640
of mfir and openmp mli r is

607
00:21:43,760 --> 00:21:48,320
generated and then it's finally

608
00:21:46,640 --> 00:21:51,799
transformed into a state where

609
00:21:48,320 --> 00:21:56,240
the openmpmlir will access together with

610
00:21:51,799 --> 00:21:58,480
llvmlir and when it's translated

611
00:21:56,240 --> 00:22:01,440
the translation library will call the

612
00:21:58,480 --> 00:22:02,559
openmp ir builder to generate lvmir for

613
00:22:01,440 --> 00:22:04,880
each of these

614
00:22:02,559 --> 00:22:06,720
openmp constructs it can be barrier for

615
00:22:04,880 --> 00:22:08,640
the parallel region and all that

616
00:22:06,720 --> 00:22:11,360
and the outlining and all those things

617
00:22:08,640 --> 00:22:12,880
will actually happen at this layer

618
00:22:11,360 --> 00:22:14,879
so i'll just look at a couple of

619
00:22:12,880 --> 00:22:18,400
examples

620
00:22:14,880 --> 00:22:21,280
the first one is the parallel construct

621
00:22:18,400 --> 00:22:22,799
so you have this fortran code here which

622
00:22:21,280 --> 00:22:25,520
has a parallel construct and

623
00:22:22,799 --> 00:22:26,158
has an assignment and an addition there

624
00:22:25,520 --> 00:22:28,158
so

625
00:22:26,159 --> 00:22:30,240
this complicated thing in the middle is

626
00:22:28,159 --> 00:22:31,919
basically a representation of the ast

627
00:22:30,240 --> 00:22:33,600
you can see that it's similar to clank

628
00:22:31,919 --> 00:22:36,480
but it's for trans specific and the one

629
00:22:33,600 --> 00:22:39,439
generated by the flank compiler

630
00:22:36,480 --> 00:22:41,440
and on the right here you can see that

631
00:22:39,440 --> 00:22:42,240
you have actually generated omp dot

632
00:22:41,440 --> 00:22:45,120
parallel

633
00:22:42,240 --> 00:22:46,480
which is an operation the openmp dialect

634
00:22:45,120 --> 00:22:48,158
and this add-up is actually something

635
00:22:46,480 --> 00:22:48,960
part of the standard dialect but there

636
00:22:48,159 --> 00:22:52,799
could be more

637
00:22:48,960 --> 00:22:52,799
fir dialect sitting around this

638
00:22:53,600 --> 00:22:56,799
and in the next step or in the final

639
00:22:55,600 --> 00:23:00,080
step you will have the

640
00:22:56,799 --> 00:23:01,600
openmp dialects sitting with the llvm

641
00:23:00,080 --> 00:23:04,480
dialect

642
00:23:01,600 --> 00:23:05,280
and then you will use the openmp ir

643
00:23:04,480 --> 00:23:07,840
builder

644
00:23:05,280 --> 00:23:11,678
to generate the outline function and the

645
00:23:07,840 --> 00:23:11,678
for call which calls it outline function

646
00:23:12,000 --> 00:23:15,440
so it's not necessary that we will

647
00:23:13,760 --> 00:23:18,158
always use the

648
00:23:15,440 --> 00:23:18,559
openmp ir builder it could be that you

649
00:23:18,159 --> 00:23:20,559
know

650
00:23:18,559 --> 00:23:21,600
things can be handled completely inside

651
00:23:20,559 --> 00:23:24,080
the

652
00:23:21,600 --> 00:23:24,879
mli layer itself so this is an example

653
00:23:24,080 --> 00:23:27,678
for that

654
00:23:24,880 --> 00:23:28,960
you have the openmp collapse claw

655
00:23:27,679 --> 00:23:30,559
collapse construct

656
00:23:28,960 --> 00:23:32,080
which basically says that you know

657
00:23:30,559 --> 00:23:32,960
collapse the two loops into a single

658
00:23:32,080 --> 00:23:34,879
loop

659
00:23:32,960 --> 00:23:36,000
so that's the example that we have here

660
00:23:34,880 --> 00:23:38,880
you have two loops two

661
00:23:36,000 --> 00:23:40,320
do loops inside an open mp panel region

662
00:23:38,880 --> 00:23:41,840
with collapse set to two which means

663
00:23:40,320 --> 00:23:43,039
that collapse and x2 loops in a single

664
00:23:41,840 --> 00:23:44,399
loop

665
00:23:43,039 --> 00:23:46,879
so in the first stage there will be an

666
00:23:44,400 --> 00:23:47,679
openmp operation sitting together with

667
00:23:46,880 --> 00:23:51,600
the fir

668
00:23:47,679 --> 00:23:53,760
do loops and

669
00:23:51,600 --> 00:23:55,600
it will be converted into another

670
00:23:53,760 --> 00:23:57,200
dialect called the loop dialect with

671
00:23:55,600 --> 00:23:58,959
loop dot four

672
00:23:57,200 --> 00:24:00,400
and the loop dialect has some coil

673
00:23:58,960 --> 00:24:02,400
issuing already implemented so you'll

674
00:24:00,400 --> 00:24:04,320
use that to

675
00:24:02,400 --> 00:24:06,159
convert those two loops into a single

676
00:24:04,320 --> 00:24:08,720
loop

677
00:24:06,159 --> 00:24:10,320
uh and in the so so now that collapse

678
00:24:08,720 --> 00:24:11,520
operation is actually fully handled

679
00:24:10,320 --> 00:24:15,279
inside the

680
00:24:11,520 --> 00:24:15,760
uh openmp in the mlr layer itself so

681
00:24:15,279 --> 00:24:18,320
that

682
00:24:15,760 --> 00:24:20,158
for that particular operation you don't

683
00:24:18,320 --> 00:24:22,399
have to use the openmpir builder for

684
00:24:20,159 --> 00:24:22,400
that

685
00:24:31,520 --> 00:24:36,400
so next we come to the driver so when we

686
00:24:34,720 --> 00:24:39,120
have a new front end that has to be

687
00:24:36,400 --> 00:24:40,880
integrated to the existing driver

688
00:24:39,120 --> 00:24:42,879
so the approach that is being taken is

689
00:24:40,880 --> 00:24:46,400
to create a new binary called

690
00:24:42,880 --> 00:24:48,559
bin slash flag it will reuse the lip

691
00:24:46,400 --> 00:24:50,159
clank driver and the options file that's

692
00:24:48,559 --> 00:24:51,918
options.td

693
00:24:50,159 --> 00:24:53,880
so a sample invocation would look like

694
00:24:51,919 --> 00:24:56,640
pin flying hyphen fubar

695
00:24:53,880 --> 00:24:59,360
fubar.f90 and it will call

696
00:24:56,640 --> 00:25:00,000
bin flank hyphen fc1 so just like clang

697
00:24:59,360 --> 00:25:01,600
if you call

698
00:25:00,000 --> 00:25:03,679
clang then it's actually internally

699
00:25:01,600 --> 00:25:05,279
calls clang hyphen cc one

700
00:25:03,679 --> 00:25:06,720
so just like that you'll call bin flying

701
00:25:05,279 --> 00:25:09,520
with fc1

702
00:25:06,720 --> 00:25:11,840
which will then call the real uh flying

703
00:25:09,520 --> 00:25:15,120
over f18 front end to do the

704
00:25:11,840 --> 00:25:17,120
compilation it has to be noted that

705
00:25:15,120 --> 00:25:19,120
most of the many hpc applications are

706
00:25:17,120 --> 00:25:21,678
mixed source programs it is a mix of

707
00:25:19,120 --> 00:25:23,360
cc plus plus as well as fortran so it's

708
00:25:21,679 --> 00:25:24,880
important that the compilers are aware

709
00:25:23,360 --> 00:25:28,320
of each other

710
00:25:24,880 --> 00:25:30,799
so this flank compiler can also be

711
00:25:28,320 --> 00:25:31,760
called with driver mode set to fortran

712
00:25:30,799 --> 00:25:34,240
with client

713
00:25:31,760 --> 00:25:35,520
and then it will call flying so the

714
00:25:34,240 --> 00:25:38,880
initial plan is to

715
00:25:35,520 --> 00:25:41,039
uh so currently uh

716
00:25:38,880 --> 00:25:42,880
clang has a feature to call g fortran if

717
00:25:41,039 --> 00:25:45,679
you call it with a fortran file

718
00:25:42,880 --> 00:25:47,360
so that will stay for now uh but if you

719
00:25:45,679 --> 00:25:49,279
call it the driver mod is kelly fortran

720
00:25:47,360 --> 00:25:52,399
then the flying compiler will be

721
00:25:49,279 --> 00:25:53,200
called uh i have put a pointer to the

722
00:25:52,400 --> 00:25:57,840
rfc if

723
00:25:53,200 --> 00:25:57,840
anyone is interested in the details

724
00:25:58,559 --> 00:26:01,918
so next we talk about the submission to

725
00:26:00,640 --> 00:26:04,080
llvm projects so as

726
00:26:01,919 --> 00:26:05,760
of now this project still exists as a

727
00:26:04,080 --> 00:26:07,760
github project somewhere

728
00:26:05,760 --> 00:26:09,120
it's not yet part of the lvm although it

729
00:26:07,760 --> 00:26:11,120
has been accepted

730
00:26:09,120 --> 00:26:13,039
as the front end of the of the llvm

731
00:26:11,120 --> 00:26:15,678
compiler of a fortran

732
00:26:13,039 --> 00:26:17,919
so any so we made an initial submit

733
00:26:15,679 --> 00:26:20,720
initial attempt to submit this to the

734
00:26:17,919 --> 00:26:22,880
uh lvm project and then we got some

735
00:26:20,720 --> 00:26:25,760
feedback

736
00:26:22,880 --> 00:26:29,120
so the initial attempt was to submit the

737
00:26:25,760 --> 00:26:31,840
faster and semantic analysis checker

738
00:26:29,120 --> 00:26:33,678
so it seems that at that stage there's

739
00:26:31,840 --> 00:26:36,320
not much of llvm that is used

740
00:26:33,679 --> 00:26:38,240
so that's still modern c plus plus using

741
00:26:36,320 --> 00:26:40,960
standard libraries it does not use

742
00:26:38,240 --> 00:26:42,880
lvm api it does not use some of the llm

743
00:26:40,960 --> 00:26:45,039
data data structures

744
00:26:42,880 --> 00:26:46,720
so the community came back with some

745
00:26:45,039 --> 00:26:51,039
suggestions saying that

746
00:26:46,720 --> 00:26:53,200
you have to use these llvm apis

747
00:26:51,039 --> 00:26:54,400
confirm more to llvm practices and all

748
00:26:53,200 --> 00:26:57,520
that

749
00:26:54,400 --> 00:27:00,640
so some of these are listed here

750
00:26:57,520 --> 00:27:02,720
so some of these are already done like

751
00:27:00,640 --> 00:27:04,159
moving the public headers to include

752
00:27:02,720 --> 00:27:07,440
folder

753
00:27:04,159 --> 00:27:10,159
renaming cc files as cpp files

754
00:27:07,440 --> 00:27:11,679
uh it although this project used client

755
00:27:10,159 --> 00:27:12,799
format it had a few more additional

756
00:27:11,679 --> 00:27:14,400
settings

757
00:27:12,799 --> 00:27:15,840
so we are seeing whether we can remove

758
00:27:14,400 --> 00:27:17,360
all those

759
00:27:15,840 --> 00:27:19,039
and also these other things like file

760
00:27:17,360 --> 00:27:22,399
system handling it uses

761
00:27:19,039 --> 00:27:25,440
used standard or stream and all that but

762
00:27:22,399 --> 00:27:28,239
llvm has its own stream handling

763
00:27:25,440 --> 00:27:28,720
it also used some scripts to do the

764
00:27:28,240 --> 00:27:30,399
testing

765
00:27:28,720 --> 00:27:32,799
it has to be ported to use lit for

766
00:27:30,399 --> 00:27:32,799
testing

767
00:27:32,960 --> 00:27:37,039
and also finally to use llvm data

768
00:27:35,039 --> 00:27:39,679
structures wherever applicable so

769
00:27:37,039 --> 00:27:41,120
you can use dense map or small vector

770
00:27:39,679 --> 00:27:44,720
and all that

771
00:27:41,120 --> 00:27:46,639
uh wherever it's possible to use so uh

772
00:27:44,720 --> 00:27:49,520
one of my colleagues david truby is

773
00:27:46,640 --> 00:27:52,640
actually working on all these things

774
00:27:49,520 --> 00:27:54,480
to try to get it so that you know it's

775
00:27:52,640 --> 00:27:56,880
more suitable or it looks more lv and

776
00:27:54,480 --> 00:27:56,880
friendly

777
00:27:57,440 --> 00:28:03,840
so in this slide i basically mentioned

778
00:27:59,279 --> 00:28:06,720
the status of this project

779
00:28:03,840 --> 00:28:08,879
the password is complete it this project

780
00:28:06,720 --> 00:28:11,840
passes for tran 2018 completely

781
00:28:08,880 --> 00:28:14,960
and also open mp4 plan for 4.5 the

782
00:28:11,840 --> 00:28:17,279
semantic checks are mostly complete

783
00:28:14,960 --> 00:28:18,880
work is in progress on the mli based of

784
00:28:17,279 --> 00:28:22,799
optimizer

785
00:28:18,880 --> 00:28:22,799
work is beginning on the runtime

786
00:28:23,039 --> 00:28:25,840
some portions are

787
00:28:26,559 --> 00:28:30,080
so basic the initial plan was to use the

788
00:28:28,880 --> 00:28:32,799
all flying projects

789
00:28:30,080 --> 00:28:34,559
run time for io but finally it was

790
00:28:32,799 --> 00:28:36,240
decided that we'll rewrite it rather

791
00:28:34,559 --> 00:28:37,918
than reuse it

792
00:28:36,240 --> 00:28:39,760
the math library will be continued to be

793
00:28:37,919 --> 00:28:41,039
pg math so there's a pg math library

794
00:28:39,760 --> 00:28:42,000
which is the math library for the whole

795
00:28:41,039 --> 00:28:44,080
flying project

796
00:28:42,000 --> 00:28:45,600
so this this project will also continue

797
00:28:44,080 --> 00:28:48,320
to use it

798
00:28:45,600 --> 00:28:50,158
and work has also begun on uh doing the

799
00:28:48,320 --> 00:28:51,840
openmp in the implementing the openmp

800
00:28:50,159 --> 00:28:54,159
portion

801
00:28:51,840 --> 00:28:56,080
so i've also given a tentative timeline

802
00:28:54,159 --> 00:28:58,000
for this project

803
00:28:56,080 --> 00:29:01,039
moving to the llvm project report should

804
00:28:58,000 --> 00:29:04,640
happen in one or two months

805
00:29:01,039 --> 00:29:07,760
serial codes and by middle of this year

806
00:29:04,640 --> 00:29:09,279
parallel codes and with openmp 4.5 early

807
00:29:07,760 --> 00:29:11,679
next year

808
00:29:09,279 --> 00:29:12,960
and open mp5 with core race which is the

809
00:29:11,679 --> 00:29:14,320
parallel feature embedded in the

810
00:29:12,960 --> 00:29:17,679
language

811
00:29:14,320 --> 00:29:17,678
by end of 2021

812
00:29:20,799 --> 00:29:25,120
i have a slide about contribution if

813
00:29:23,360 --> 00:29:26,879
someone is interested in contributing to

814
00:29:25,120 --> 00:29:28,559
this project this project welcomes

815
00:29:26,880 --> 00:29:31,919
contribution

816
00:29:28,559 --> 00:29:33,760
code is out there currently in github

817
00:29:31,919 --> 00:29:36,000
you know you can submit code or even bug

818
00:29:33,760 --> 00:29:38,799
reports

819
00:29:36,000 --> 00:29:39,520
there is a documentation directory which

820
00:29:38,799 --> 00:29:42,480
has

821
00:29:39,520 --> 00:29:43,279
a lot of documentation uh for people

822
00:29:42,480 --> 00:29:45,279
concerned with

823
00:29:43,279 --> 00:29:47,520
c c plus the style there's a sequel of

824
00:29:45,279 --> 00:29:49,600
style and if someone is not familiar

825
00:29:47,520 --> 00:29:52,240
with fortran there's actually a

826
00:29:49,600 --> 00:29:52,799
guide for fortran for c programmers it's

827
00:29:52,240 --> 00:29:55,919
basically

828
00:29:52,799 --> 00:29:58,240
list the differences in fortran compared

829
00:29:55,919 --> 00:30:00,799
to someone who is used to see

830
00:29:58,240 --> 00:30:03,919
or you can start with the overview

831
00:30:00,799 --> 00:30:06,240
documentation also

832
00:30:03,919 --> 00:30:07,760
there's a projects page which has a list

833
00:30:06,240 --> 00:30:09,360
of various items in progress

834
00:30:07,760 --> 00:30:12,080
things which are completed or things

835
00:30:09,360 --> 00:30:13,360
which are going to start

836
00:30:12,080 --> 00:30:16,000
or you can pick up issues from the

837
00:30:13,360 --> 00:30:17,600
github issue tracker

838
00:30:16,000 --> 00:30:19,120
basically if you want to contribute

839
00:30:17,600 --> 00:30:20,719
something it will be good to send a mail

840
00:30:19,120 --> 00:30:22,239
to flying dev so that

841
00:30:20,720 --> 00:30:23,840
you know you're not duplicating someone

842
00:30:22,240 --> 00:30:26,880
else's work

843
00:30:23,840 --> 00:30:28,879
code reviews happen in github itself

844
00:30:26,880 --> 00:30:30,799
there is a file called pull request

845
00:30:28,880 --> 00:30:32,240
checklist

846
00:30:30,799 --> 00:30:34,000
you can read that that's also in the

847
00:30:32,240 --> 00:30:35,440
documentation directory if you

848
00:30:34,000 --> 00:30:38,159
it's basically a checklist before you

849
00:30:35,440 --> 00:30:40,559
make a whole request

850
00:30:38,159 --> 00:30:42,080
but it should be noted that once this

851
00:30:40,559 --> 00:30:44,158
project makes it to llvm

852
00:30:42,080 --> 00:30:46,000
some of these things things will change

853
00:30:44,159 --> 00:30:48,720
basically it will not be

854
00:30:46,000 --> 00:30:49,039
pull requests will not be in github you

855
00:30:48,720 --> 00:30:50,559
know

856
00:30:49,039 --> 00:30:53,039
reviews will happen in fabricator

857
00:30:50,559 --> 00:30:53,039
basically

858
00:30:56,000 --> 00:31:01,279
so in conclusion all flank demonstrated

859
00:30:59,360 --> 00:31:03,678
that an industry strength

860
00:31:01,279 --> 00:31:05,760
high performance llvm based fortran

861
00:31:03,679 --> 00:31:08,399
compiler is possible

862
00:31:05,760 --> 00:31:10,080
uh the new flang on the f-18 project

863
00:31:08,399 --> 00:31:11,439
addresses the deficiencies of the old

864
00:31:10,080 --> 00:31:13,279
compiler

865
00:31:11,440 --> 00:31:15,679
the new flag is accepted as the front

866
00:31:13,279 --> 00:31:18,559
quarter and front end of llvm

867
00:31:15,679 --> 00:31:21,679
submission is expected to happen soon it

868
00:31:18,559 --> 00:31:24,799
fills a key gap in the hpc story for lvm

869
00:31:21,679 --> 00:31:27,039
it did not have an at front until now

870
00:31:24,799 --> 00:31:28,158
it's written in modern c plus plus uses

871
00:31:27,039 --> 00:31:30,080
mlir

872
00:31:28,159 --> 00:31:32,080
shares code with llvm wherever possible

873
00:31:30,080 --> 00:31:36,000
particularly in openmp driver

874
00:31:32,080 --> 00:31:37,519
etc as i mentioned it also is very

875
00:31:36,000 --> 00:31:39,679
friendly with standard so

876
00:31:37,519 --> 00:31:41,039
it aspires to be the platform where

877
00:31:39,679 --> 00:31:41,760
people will come and code and check

878
00:31:41,039 --> 00:31:43,360
whether

879
00:31:41,760 --> 00:31:46,080
you know this a new feature that can be

880
00:31:43,360 --> 00:31:48,399
taken up in the next standard

881
00:31:46,080 --> 00:31:50,240
exact under active development and you

882
00:31:48,399 --> 00:32:01,840
can contribute if you are interested

883
00:31:50,240 --> 00:32:04,559
thank you

884
00:32:01,840 --> 00:32:05,760
all right so um i saw the one of the

885
00:32:04,559 --> 00:32:08,799
applications that

886
00:32:05,760 --> 00:32:10,320
use fortran is wrf which is a weather

887
00:32:08,799 --> 00:32:14,240
forecasting

888
00:32:10,320 --> 00:32:14,240
application from the americans

889
00:32:14,559 --> 00:32:21,600
they state please compile with intel

890
00:32:17,840 --> 00:32:23,279
because it's 30 faster

891
00:32:21,600 --> 00:32:27,039
i didn't see in the intel compiler

892
00:32:23,279 --> 00:32:31,360
results in your benchmark comparisons

893
00:32:27,039 --> 00:32:34,879
uh i don't know whether wrf is

894
00:32:31,360 --> 00:32:38,799
is there and that it's part of spec also

895
00:32:34,880 --> 00:32:42,080
so i was wondering uh and i also didn't

896
00:32:38,799 --> 00:32:45,600
is one of them no none of them is intel

897
00:32:42,080 --> 00:32:48,720
uh it's uh flank it's pgi and

898
00:32:45,600 --> 00:32:50,959
gcc compiler so basically they say don't

899
00:32:48,720 --> 00:32:52,720
do all of that please use intel

900
00:32:50,960 --> 00:32:54,960
which i hate because they are only

901
00:32:52,720 --> 00:32:59,039
optimized for intel processors and amd

902
00:32:54,960 --> 00:33:02,720
just sucks at that which makes me buy

903
00:32:59,039 --> 00:33:05,840
my kids do not 800 euro cpus

904
00:33:02,720 --> 00:33:08,159
um but so i was wondering

905
00:33:05,840 --> 00:33:09,120
is there any future plans is there like

906
00:33:08,159 --> 00:33:12,640
a performance

907
00:33:09,120 --> 00:33:15,678
review of an optimization

908
00:33:12,640 --> 00:33:15,679
is that there or

909
00:33:15,840 --> 00:33:20,399
so basically the question is that for

910
00:33:18,640 --> 00:33:22,000
applications in weather forecasting like

911
00:33:20,399 --> 00:33:24,559
wrf

912
00:33:22,000 --> 00:33:25,519
the suggestion is used to is to use a

913
00:33:24,559 --> 00:33:27,918
proprietary

914
00:33:25,519 --> 00:33:29,360
proprietary platform dependent compiler

915
00:33:27,919 --> 00:33:32,799
like intel

916
00:33:29,360 --> 00:33:34,719
and is there a plan in uh the new flying

917
00:33:32,799 --> 00:33:38,000
project to do a performance review

918
00:33:34,720 --> 00:33:41,440
at some stage uh

919
00:33:38,000 --> 00:33:41,919
so as i have mentioned there is actually

920
00:33:41,440 --> 00:33:43,600
an

921
00:33:41,919 --> 00:33:45,039
high level optimizer as part of this

922
00:33:43,600 --> 00:33:48,240
project so

923
00:33:45,039 --> 00:33:51,519
uh when you even when it reaches

924
00:33:48,240 --> 00:33:53,679
maturity uh and when it generates llvm

925
00:33:51,519 --> 00:33:55,600
ir and you can actually run executables

926
00:33:53,679 --> 00:33:57,600
these things will be checked to see

927
00:33:55,600 --> 00:33:58,559
whether it's as good as the intel

928
00:33:57,600 --> 00:34:02,320
compiler or

929
00:33:58,559 --> 00:34:05,279
all the other compilers and

930
00:34:02,320 --> 00:34:07,279
and to be honest to so i'm working for

931
00:34:05,279 --> 00:34:10,159
arm if we finally decide to

932
00:34:07,279 --> 00:34:11,599
uh have this as our fortran front end it

933
00:34:10,159 --> 00:34:12,560
should be at least as good as the old

934
00:34:11,599 --> 00:34:14,639
one

935
00:34:12,560 --> 00:34:16,480
and preferably it should be as good as

936
00:34:14,639 --> 00:34:19,520
the intel compiler also

937
00:34:16,480 --> 00:34:20,719
same with pgi also so they are all you

938
00:34:19,520 --> 00:34:22,320
know

939
00:34:20,719 --> 00:34:24,399
performance is very important for all of

940
00:34:22,320 --> 00:34:24,960
us and that will definitely be a strong

941
00:34:24,399 --> 00:34:26,719
check

942
00:34:24,960 --> 00:34:28,399
that will be applied before this

943
00:34:26,719 --> 00:34:36,000
replaces the current flying compiler in

944
00:34:28,399 --> 00:34:37,918
the commercial products uh yeah

945
00:34:36,000 --> 00:34:40,079
uh you mentioned that a lot of hpc code

946
00:34:37,918 --> 00:34:40,560
is a mix of fortran c and c bus plus

947
00:34:40,079 --> 00:34:42,960
yeah

948
00:34:40,560 --> 00:34:44,480
uh i know like for rust the rust

949
00:34:42,960 --> 00:34:45,520
developers worked on being able to do

950
00:34:44,480 --> 00:34:47,918
like cross language

951
00:34:45,520 --> 00:34:49,839
lto between like rust and sea pulse plus

952
00:34:47,918 --> 00:34:52,078
and got that working

953
00:34:49,839 --> 00:34:54,159
is there any plans or like what's the

954
00:34:52,079 --> 00:34:55,440
state of interop between doing lto

955
00:34:54,159 --> 00:34:58,640
between sequels plus

956
00:34:55,440 --> 00:35:01,040
and fortran with flying uh

957
00:34:58,640 --> 00:35:02,000
so if my understanding is correct i'm

958
00:35:01,040 --> 00:35:05,440
not an expert in this

959
00:35:02,000 --> 00:35:08,480
area but once you generate llvm ir so

960
00:35:05,440 --> 00:35:10,400
every or once you generate object code

961
00:35:08,480 --> 00:35:12,160
it should not i don't know how much

962
00:35:10,400 --> 00:35:14,400
language specific is

963
00:35:12,160 --> 00:35:16,160
are things at that stage so i have

964
00:35:14,400 --> 00:35:17,119
actually seen examples where lto works

965
00:35:16,160 --> 00:35:19,279
fine

966
00:35:17,119 --> 00:35:20,720
with fl with fortran as well as in mixed

967
00:35:19,280 --> 00:35:24,079
fortran so

968
00:35:20,720 --> 00:35:25,439
uh so i think it should work fine

969
00:35:24,079 --> 00:35:27,119
so the basically the question was

970
00:35:25,440 --> 00:35:29,760
whether lto will work with

971
00:35:27,119 --> 00:35:32,320
uh flying with fortran and crc plus this

972
00:35:29,760 --> 00:35:32,320
applications

973
00:35:33,200 --> 00:35:39,839
uh we'll go with this

974
00:35:36,480 --> 00:35:40,880
okay sorry have you started testing it

975
00:35:39,839 --> 00:35:43,920
against the

976
00:35:40,880 --> 00:35:44,480
foreground reference test suites and how

977
00:35:43,920 --> 00:35:47,280
does

978
00:35:44,480 --> 00:35:47,280
how well does it do

979
00:35:47,599 --> 00:35:52,400
so the question is uh have we started

980
00:35:50,640 --> 00:35:54,960
testing this against water and reference

981
00:35:52,400 --> 00:35:54,960
test suits

982
00:35:56,640 --> 00:36:00,640
so do you have a particular reference

983
00:35:58,000 --> 00:36:00,640
here in mind

984
00:36:01,839 --> 00:36:09,839
so so

985
00:36:05,119 --> 00:36:13,359
so there are some test suits out there

986
00:36:09,839 --> 00:36:17,119
but the one which is popular with

987
00:36:13,359 --> 00:36:19,520
companies at least is the nag

988
00:36:17,119 --> 00:36:21,359
nag compilers for you know fortran

989
00:36:19,520 --> 00:36:25,839
reference test suit

990
00:36:21,359 --> 00:36:29,359
so that is something that people

991
00:36:25,839 --> 00:36:31,839
test it against but the problem is that

992
00:36:29,359 --> 00:36:33,839
when you if it's error messages and all

993
00:36:31,839 --> 00:36:36,078
its different compilers provide

994
00:36:33,839 --> 00:36:38,560
error messages in different ways right

995
00:36:36,079 --> 00:36:40,079
the text is not the same

996
00:36:38,560 --> 00:36:41,440
sometimes the line numbers are the same

997
00:36:40,079 --> 00:36:42,320
but it can also be actually would be a

998
00:36:41,440 --> 00:36:43,920
different

999
00:36:42,320 --> 00:36:46,480
so that comparison is actually a bit

1000
00:36:43,920 --> 00:36:49,200
hard to do but

1001
00:36:46,480 --> 00:36:50,640
we we will do that check you know and we

1002
00:36:49,200 --> 00:36:52,078
do actually run a lot of fortran

1003
00:36:50,640 --> 00:36:53,759
reference codes like

1004
00:36:52,079 --> 00:36:55,280
already we have run it as part of many

1005
00:36:53,760 --> 00:36:57,280
applications

1006
00:36:55,280 --> 00:36:58,720
uh and also some other tests that are

1007
00:36:57,280 --> 00:37:00,480
part of the old flying project

1008
00:36:58,720 --> 00:37:02,078
as well as internal tests that are part

1009
00:37:00,480 --> 00:37:04,240
of various companies

1010
00:37:02,079 --> 00:37:05,680
and it seems to be doing a good job and

1011
00:37:04,240 --> 00:37:08,160
that's why the semantic that's why i

1012
00:37:05,680 --> 00:37:10,399
mentioned that semantic analysis checks

1013
00:37:08,160 --> 00:37:12,560
is almost complete because you know it

1014
00:37:10,400 --> 00:37:15,599
actually finds a lot of issues

1015
00:37:12,560 --> 00:37:18,320
that are out there also

1016
00:37:15,599 --> 00:37:20,160
another thing that is being done is that

1017
00:37:18,320 --> 00:37:21,760
whenever there is a restriction that is

1018
00:37:20,160 --> 00:37:25,359
mentioned in the standard

1019
00:37:21,760 --> 00:37:26,960
that check is developers write tests for

1020
00:37:25,359 --> 00:37:28,319
each of those checks

1021
00:37:26,960 --> 00:37:30,079
and there is someone who is actually

1022
00:37:28,320 --> 00:37:32,160
always going and reviewing if anything

1023
00:37:30,079 --> 00:37:33,920
is missed so

1024
00:37:32,160 --> 00:37:37,598
so yeah a lot of emphasis is placed on

1025
00:37:33,920 --> 00:37:39,359
those things one more question

1026
00:37:37,599 --> 00:37:40,880
uh sorry someone in the back had raised

1027
00:37:39,359 --> 00:37:46,799
their hand of it

1028
00:37:40,880 --> 00:37:46,800
thank you um

1029
00:37:48,880 --> 00:37:51,200
which

1030
00:37:56,160 --> 00:37:59,200
so the question is that there are two

1031
00:37:57,599 --> 00:38:00,960
compilers called flang one is the old

1032
00:37:59,200 --> 00:38:03,040
one and the other is a new one

1033
00:38:00,960 --> 00:38:04,000
and which one is this performance

1034
00:38:03,040 --> 00:38:05,759
results

1035
00:38:04,000 --> 00:38:07,599
so this performance results is for the

1036
00:38:05,760 --> 00:38:10,320
old one reference c

1037
00:38:07,599 --> 00:38:12,240
uh it's not for the new one the new one

1038
00:38:10,320 --> 00:38:14,800
does not

1039
00:38:12,240 --> 00:38:16,078
might just be able to generate lvm ir in

1040
00:38:14,800 --> 00:38:17,839
some branches

1041
00:38:16,079 --> 00:38:20,240
but but even the mainstream master

1042
00:38:17,839 --> 00:38:21,920
branch does not generate llvm ir

1043
00:38:20,240 --> 00:38:23,839
so it's not in a state where you can

1044
00:38:21,920 --> 00:38:27,440
actually run code so we have not reached

1045
00:38:23,839 --> 00:38:27,440
that stage for the new fa new flank

1046
00:38:30,839 --> 00:38:34,960
compiler

1047
00:38:32,800 --> 00:38:36,400
yeah so it's being currently merged into

1048
00:38:34,960 --> 00:38:38,640
the master branch

1049
00:38:36,400 --> 00:38:39,760
so somebody has gone and done that on a

1050
00:38:38,640 --> 00:38:42,160
branch

1051
00:38:39,760 --> 00:38:43,280
uh so and it's still a work in progress

1052
00:38:42,160 --> 00:38:44,799
so we are not at so and

1053
00:38:43,280 --> 00:38:47,520
it's not just that also you have to have

1054
00:38:44,800 --> 00:38:49,280
the libraries fortran has a big library

1055
00:38:47,520 --> 00:38:51,280
runtime library so that has also to be

1056
00:38:49,280 --> 00:38:54,400
done so there's still a lot of portions

1057
00:38:51,280 --> 00:38:54,400
that are not yet complete

1058
00:38:54,960 --> 00:39:01,839
one minute

1059
00:39:05,280 --> 00:39:08,800
uh so these timelines are all tentative

1060
00:39:08,240 --> 00:39:11,279
and

1061
00:39:08,800 --> 00:39:12,960
i have seen that these are missed also

1062
00:39:11,280 --> 00:39:16,160
so

1063
00:39:12,960 --> 00:39:19,599
or for openmp 4.5 early next year or

1064
00:39:16,160 --> 00:39:19,598
middle of next year is the plan

1065
00:39:19,760 --> 00:39:24,960
that's the current plan yeah so the

1066
00:39:21,920 --> 00:39:29,839
question was when is openmp 4.5

1067
00:39:24,960 --> 00:39:29,839
uh what is the timeline for that

1068
00:39:30,220 --> 00:39:37,439
[Applause]

