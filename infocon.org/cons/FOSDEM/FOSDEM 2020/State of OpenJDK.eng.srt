1
00:00:06,720 --> 00:00:11,360
okay

2
00:00:07,120 --> 00:00:13,599
state of open jdk um

3
00:00:11,360 --> 00:00:15,200
the biggest change as as i think many of

4
00:00:13,599 --> 00:00:17,119
us in this room know

5
00:00:15,200 --> 00:00:18,560
by now but i'll just review it quickly

6
00:00:17,119 --> 00:00:20,800
anyway the biggest change in

7
00:00:18,560 --> 00:00:23,038
this community in the last two years has

8
00:00:20,800 --> 00:00:25,119
been the transition from this old

9
00:00:23,039 --> 00:00:26,720
and majestic and slow-moving and

10
00:00:25,119 --> 00:00:28,800
unpredictable release model

11
00:00:26,720 --> 00:00:30,640
where we ship to release every two or

12
00:00:28,800 --> 00:00:31,359
three or five or seven years or whatever

13
00:00:30,640 --> 00:00:33,520
it was

14
00:00:31,359 --> 00:00:35,440
uh to this rapid cadence model in which

15
00:00:33,520 --> 00:00:39,600
we ship a new feature release

16
00:00:35,440 --> 00:00:39,599
every six months no matter what

17
00:00:40,000 --> 00:00:47,760
the last big elephant was java 9 jdk 9

18
00:00:43,440 --> 00:00:49,039
shipped in in september of 2017 which

19
00:00:47,760 --> 00:00:50,800
seems like it was just yesterday but

20
00:00:49,039 --> 00:00:53,520
it's actually quite a while ago by now

21
00:00:50,800 --> 00:00:55,199
um the last big release there were 90

22
00:00:53,520 --> 00:00:56,399
jups in this release

23
00:00:55,199 --> 00:00:58,320
there were two major slips to the

24
00:00:56,399 --> 00:00:59,199
schedule it took three years and six

25
00:00:58,320 --> 00:01:00,719
months

26
00:00:59,199 --> 00:01:03,519
after after those flips were accounted

27
00:01:00,719 --> 00:01:05,360
for um

28
00:01:03,520 --> 00:01:07,360
and that's the last that's the last big

29
00:01:05,360 --> 00:01:10,320
one after we shipped nine

30
00:01:07,360 --> 00:01:11,040
we shipped jdk 10 in march 2018 six

31
00:01:10,320 --> 00:01:14,639
months later

32
00:01:11,040 --> 00:01:17,840
11 in september 2018 12 in march 2019

33
00:01:14,640 --> 00:01:19,040
13 in september 2019 will ship 14 next

34
00:01:17,840 --> 00:01:21,680
month

35
00:01:19,040 --> 00:01:22,720
middle of next month and we'll ship 15

36
00:01:21,680 --> 00:01:24,840
this september

37
00:01:22,720 --> 00:01:26,720
and so on every six months like

38
00:01:24,840 --> 00:01:28,640
clockwork

39
00:01:26,720 --> 00:01:30,079
a feature release can contain any kind

40
00:01:28,640 --> 00:01:32,079
of feature these are these are not just

41
00:01:30,079 --> 00:01:32,880
all the the old updates of the past

42
00:01:32,079 --> 00:01:36,079
right

43
00:01:32,880 --> 00:01:37,520
um a feature it can contain a language

44
00:01:36,079 --> 00:01:41,600
feature a vm feature

45
00:01:37,520 --> 00:01:44,720
a library feature

46
00:01:41,600 --> 00:01:47,119
uh and and and so forth somehow i have

47
00:01:44,720 --> 00:01:50,079
skipped ahead sorry

48
00:01:47,119 --> 00:01:51,280
um but the the important thing that

49
00:01:50,079 --> 00:01:52,798
makes this work

50
00:01:51,280 --> 00:01:54,880
the reason we've been been able to be

51
00:01:52,799 --> 00:01:57,280
this successful so far with this model

52
00:01:54,880 --> 00:01:58,479
is that we no longer put features in

53
00:01:57,280 --> 00:02:00,640
before they're finished the feature can

54
00:01:58,479 --> 00:02:02,159
only go in when it's nearly done

55
00:02:00,640 --> 00:02:04,719
because we can't afford to slip or

56
00:02:02,159 --> 00:02:06,799
release to fix some broken feature and

57
00:02:04,719 --> 00:02:08,160
so it's a new level of discipline but it

58
00:02:06,799 --> 00:02:09,920
has a lot of benefit and with another

59
00:02:08,160 --> 00:02:10,959
release just six months away well

60
00:02:09,919 --> 00:02:12,559
if you're working on a feature and it

61
00:02:10,959 --> 00:02:14,000
doesn't make this one that's okay you're

62
00:02:12,560 --> 00:02:15,599
not you're not rushing to get something

63
00:02:14,000 --> 00:02:17,440
in that's going to be broken

64
00:02:15,599 --> 00:02:18,640
because the next release is is three or

65
00:02:17,440 --> 00:02:21,120
five years out

66
00:02:18,640 --> 00:02:23,119
so that actually all works out fairly

67
00:02:21,120 --> 00:02:25,920
well

68
00:02:23,120 --> 00:02:27,840
in the the there is the question though

69
00:02:25,920 --> 00:02:29,920
of

70
00:02:27,840 --> 00:02:31,680
of how how long are these are these

71
00:02:29,920 --> 00:02:33,760
things supported

72
00:02:31,680 --> 00:02:35,920
in the open jdk community we update the

73
00:02:33,760 --> 00:02:37,120
current feature release for at least six

74
00:02:35,920 --> 00:02:38,640
months

75
00:02:37,120 --> 00:02:40,319
so that's two two quarterly update

76
00:02:38,640 --> 00:02:41,920
really really releases the

77
00:02:40,319 --> 00:02:43,280
three three months apart and then every

78
00:02:41,920 --> 00:02:44,799
three years we declare a long-term

79
00:02:43,280 --> 00:02:46,720
support release so eleven

80
00:02:44,800 --> 00:02:48,800
is the first long-term support release

81
00:02:46,720 --> 00:02:50,239
17 is the next one

82
00:02:48,800 --> 00:02:51,840
if you like you can think of eight up

83
00:02:50,239 --> 00:02:54,640
there as as the previous

84
00:02:51,840 --> 00:02:57,200
long-term support release each of these

85
00:02:54,640 --> 00:02:59,679
lts releases will be updated well past

86
00:02:57,200 --> 00:03:00,640
the beginning of the next lts release

87
00:02:59,680 --> 00:03:02,800
and possibly

88
00:03:00,640 --> 00:03:06,079
even longer you know depending upon what

89
00:03:02,800 --> 00:03:08,319
the maintainers in open jdk decide to do

90
00:03:06,080 --> 00:03:10,159
now you might think that the non-lts

91
00:03:08,319 --> 00:03:11,920
releases are in some way experimental

92
00:03:10,159 --> 00:03:13,359
they're just fancy beta releases

93
00:03:11,920 --> 00:03:14,958
it's you know it's really just early

94
00:03:13,360 --> 00:03:16,560
access but they're not

95
00:03:14,959 --> 00:03:18,000
every one of these releases is

96
00:03:16,560 --> 00:03:21,760
production ready what

97
00:03:18,000 --> 00:03:23,599
differs is only the support timeline

98
00:03:21,760 --> 00:03:25,280
speaking of updates where do you get

99
00:03:23,599 --> 00:03:28,399
them you can get updates from

100
00:03:25,280 --> 00:03:30,720
a variety of providers including oracle

101
00:03:28,400 --> 00:03:31,519
oracle ships open jdk builds under the

102
00:03:30,720 --> 00:03:34,159
gpl

103
00:03:31,519 --> 00:03:34,959
for the first six months of each feature

104
00:03:34,159 --> 00:03:37,040
release

105
00:03:34,959 --> 00:03:39,280
the ga release plus plus two updates

106
00:03:37,040 --> 00:03:40,959
whether it's lts or not

107
00:03:39,280 --> 00:03:42,879
after that oracle offers long-term

108
00:03:40,959 --> 00:03:45,200
support builds but

109
00:03:42,879 --> 00:03:46,879
unlike in the past they're not free

110
00:03:45,200 --> 00:03:47,599
they're available under a commercial

111
00:03:46,879 --> 00:03:49,040
license

112
00:03:47,599 --> 00:03:51,200
that allows free use in development and

113
00:03:49,040 --> 00:03:51,840
production but requires uh payment for

114
00:03:51,200 --> 00:03:54,000
use

115
00:03:51,840 --> 00:03:55,519
in production sorry free use for

116
00:03:54,000 --> 00:03:56,879
development and testing let me get this

117
00:03:55,519 --> 00:03:59,599
right

118
00:03:56,879 --> 00:04:00,159
however that doesn't mean you have to

119
00:03:59,599 --> 00:04:02,798
pay

120
00:04:00,159 --> 00:04:03,599
oracle for java update releases because

121
00:04:02,799 --> 00:04:06,799
java

122
00:04:03,599 --> 00:04:07,920
is still free all the code is still

123
00:04:06,799 --> 00:04:09,439
under the gpl

124
00:04:07,920 --> 00:04:11,359
and even though oracle engineers aren't

125
00:04:09,439 --> 00:04:13,599
contributing to the open jdk

126
00:04:11,360 --> 00:04:15,760
long-term support releases anymore other

127
00:04:13,599 --> 00:04:18,079
contributors under the leadership of

128
00:04:15,760 --> 00:04:20,959
andrew haley standing back there there

129
00:04:18,079 --> 00:04:23,280
um are continuing

130
00:04:20,959 --> 00:04:25,040
the the the fine lts work that they've

131
00:04:23,280 --> 00:04:26,719
been doing for many years in the open

132
00:04:25,040 --> 00:04:28,560
jdk community

133
00:04:26,720 --> 00:04:29,840
as a result you can get carefully built

134
00:04:28,560 --> 00:04:32,400
well tested

135
00:04:29,840 --> 00:04:34,320
jdk lts builds in almost any linux

136
00:04:32,400 --> 00:04:36,880
distro if you're not using linux

137
00:04:34,320 --> 00:04:39,440
you can get builds from a variety of

138
00:04:36,880 --> 00:04:39,440
providers

139
00:04:39,759 --> 00:04:43,440
so we've transitioned to this new

140
00:04:40,880 --> 00:04:45,040
release model big change

141
00:04:43,440 --> 00:04:46,639
but what have we actually delivered

142
00:04:45,040 --> 00:04:48,560
since java 9.

143
00:04:46,639 --> 00:04:50,720
well it turns out we've delivered quite

144
00:04:48,560 --> 00:04:53,919
a lot

145
00:04:50,720 --> 00:04:55,199
jdk 10 java 10 contained 12 jobs we're

146
00:04:53,919 --> 00:04:56,479
actually worried a little bit going into

147
00:04:55,199 --> 00:04:56,800
it okay it was only six months after

148
00:04:56,479 --> 00:04:58,400
nine

149
00:04:56,800 --> 00:05:00,800
you know what if the what if release has

150
00:04:58,400 --> 00:05:02,960
no has no significant features in it

151
00:05:00,800 --> 00:05:05,360
uh well it turned out it was actually

152
00:05:02,960 --> 00:05:07,520
pretty rich we had a new pc interface

153
00:05:05,360 --> 00:05:09,120
um we had uh an actual language feature

154
00:05:07,520 --> 00:05:10,719
local variable type inference var for

155
00:05:09,120 --> 00:05:12,960
java but it's not dynamic typing don't

156
00:05:10,720 --> 00:05:12,960
worry

157
00:05:13,039 --> 00:05:16,880
a massive refactoring of the source code

158
00:05:14,800 --> 00:05:18,960
into a single mercurial repository which

159
00:05:16,880 --> 00:05:20,400
uh which was a long-term play that's

160
00:05:18,960 --> 00:05:23,758
that's

161
00:05:20,400 --> 00:05:24,960
paying additional benefits now when i as

162
00:05:23,759 --> 00:05:27,120
i go through these lists the

163
00:05:24,960 --> 00:05:28,560
the items in orange just for reference

164
00:05:27,120 --> 00:05:31,199
are from non-oracle

165
00:05:28,560 --> 00:05:31,199
contributors

166
00:05:31,680 --> 00:05:35,919
okay that's 10 11 contained 17 jobs

167
00:05:34,880 --> 00:05:38,479
there's a new

168
00:05:35,919 --> 00:05:40,799
hdp client api the ability to launch

169
00:05:38,479 --> 00:05:42,800
single file source code programs tls13

170
00:05:40,800 --> 00:05:44,880
the epsilon garbage collector

171
00:05:42,800 --> 00:05:47,360
overhead heat profiling and a bunch of

172
00:05:44,880 --> 00:05:47,360
other stuff

173
00:05:47,440 --> 00:05:51,680
java 12 jdk 12 8 japs including the

174
00:05:50,000 --> 00:05:53,759
shenandoah garbage collector a micro

175
00:05:51,680 --> 00:05:55,280
benchmark suite for the jdk the first

176
00:05:53,759 --> 00:05:56,880
preview language feature switch

177
00:05:55,280 --> 00:05:58,638
expressions i'll talk a bit about

178
00:05:56,880 --> 00:06:01,120
about these later on and also what a

179
00:05:58,639 --> 00:06:04,000
preview feature is

180
00:06:01,120 --> 00:06:05,520
jdk 13 was a little thin only five japs

181
00:06:04,000 --> 00:06:06,319
but it did contain another preview

182
00:06:05,520 --> 00:06:09,359
language feature

183
00:06:06,319 --> 00:06:11,840
text blocks a little on the small side

184
00:06:09,360 --> 00:06:13,840
but 14 is going to make up for it

185
00:06:11,840 --> 00:06:14,960
with 16 jumps a whole bunch of good

186
00:06:13,840 --> 00:06:17,359
stuff in here

187
00:06:14,960 --> 00:06:18,638
um pattern matching another language

188
00:06:17,360 --> 00:06:21,759
feature in preview

189
00:06:18,639 --> 00:06:23,360
packaging tool jfr event streaming

190
00:06:21,759 --> 00:06:25,360
streaming non-volatile mapped byte

191
00:06:23,360 --> 00:06:26,880
buffers from andrew din helpful null

192
00:06:25,360 --> 00:06:29,360
pointer exceptions from

193
00:06:26,880 --> 00:06:30,080
goods lindenmeier records switch

194
00:06:29,360 --> 00:06:32,840
expressions

195
00:06:30,080 --> 00:06:35,840
again deprecate the solaris and spark

196
00:06:32,840 --> 00:06:37,758
ports bye bye

197
00:06:35,840 --> 00:06:40,159
remove the concrete mark sweep garbage

198
00:06:37,759 --> 00:06:42,960
collector bye bye

199
00:06:40,160 --> 00:06:44,000
zgc improvements remove the pack 200

200
00:06:42,960 --> 00:06:47,120
tools and api

201
00:06:44,000 --> 00:06:48,960
bye and foreign memory

202
00:06:47,120 --> 00:06:50,160
access api from from mauricio and

203
00:06:48,960 --> 00:06:52,400
company

204
00:06:50,160 --> 00:06:53,440
um so this is all this is still in

205
00:06:52,400 --> 00:06:54,880
development but we are

206
00:06:53,440 --> 00:06:56,960
really winding down we're in ramp down

207
00:06:54,880 --> 00:06:58,240
phase two uh we hope to have the first

208
00:06:56,960 --> 00:07:00,400
release candidate build

209
00:06:58,240 --> 00:07:02,639
next week if you'd like to help out you

210
00:07:00,400 --> 00:07:04,239
can get builds here please download them

211
00:07:02,639 --> 00:07:08,800
test them and if something

212
00:07:04,240 --> 00:07:12,720
is is really wrong let us know

213
00:07:08,800 --> 00:07:16,000
okay that's 14 well 15 15 repos open

214
00:07:12,720 --> 00:07:17,520
zero jabs so far

215
00:07:16,000 --> 00:07:19,199
there will be some you know so far it's

216
00:07:17,520 --> 00:07:20,318
you know routine bug fixes small

217
00:07:19,199 --> 00:07:22,479
enhancements that

218
00:07:20,319 --> 00:07:23,440
that don't deserve a and so forth uh

219
00:07:22,479 --> 00:07:25,280
but builds

220
00:07:23,440 --> 00:07:26,639
for this are available too we started

221
00:07:25,280 --> 00:07:28,080
shipping them in december if you really

222
00:07:26,639 --> 00:07:31,599
want to be on the bleeding edge

223
00:07:28,080 --> 00:07:34,000
this is the place to go

224
00:07:31,599 --> 00:07:36,800
so one of the main questions that people

225
00:07:34,000 --> 00:07:39,280
had about the new release model is

226
00:07:36,800 --> 00:07:41,199
will the non-lts releases be adopted are

227
00:07:39,280 --> 00:07:44,719
people just going to move from

228
00:07:41,199 --> 00:07:47,199
8 to 11. to 17

229
00:07:44,720 --> 00:07:49,039
and so forth and and just and just skip

230
00:07:47,199 --> 00:07:51,440
all these non-lts releases

231
00:07:49,039 --> 00:07:53,599
so in in the interest of gathering data

232
00:07:51,440 --> 00:07:55,759
i would like to do some polls

233
00:07:53,599 --> 00:07:58,479
this will also help you help you wake up

234
00:07:55,759 --> 00:08:01,599
if you're still jet lagged as i am

235
00:07:58,479 --> 00:08:02,800
okay i we i we we often see see people

236
00:08:01,599 --> 00:08:05,360
do polls on twitter

237
00:08:02,800 --> 00:08:06,879
you know elsewhere on on the web about

238
00:08:05,360 --> 00:08:08,560
usage and one of the things that

239
00:08:06,879 --> 00:08:11,440
i always find disappointing is they'll

240
00:08:08,560 --> 00:08:13,039
just ask well are you using version x

241
00:08:11,440 --> 00:08:14,800
but they don't distinguish between

242
00:08:13,039 --> 00:08:15,599
production and development which are

243
00:08:14,800 --> 00:08:16,879
very different things

244
00:08:15,599 --> 00:08:18,639
so i'm going to ask i'm going to ask

245
00:08:16,879 --> 00:08:20,879
pairs of questions

246
00:08:18,639 --> 00:08:22,400
how many people are using a release

247
00:08:20,879 --> 00:08:27,840
earlier than eight

248
00:08:22,400 --> 00:08:29,840
in production

249
00:08:27,840 --> 00:08:30,878
okay he's a proxy for a lot of people

250
00:08:29,840 --> 00:08:32,640
okay well i

251
00:08:30,879 --> 00:08:34,320
i guess it's nice that there aren't too

252
00:08:32,640 --> 00:08:35,838
many hands how many people are people

253
00:08:34,320 --> 00:08:38,479
are using a version earlier than eight

254
00:08:35,839 --> 00:08:38,479
in development

255
00:08:38,799 --> 00:08:43,120
oh that's just not you

256
00:08:42,000 --> 00:08:45,680
i mean not not because you're

257
00:08:43,120 --> 00:08:45,680
maintaining it

258
00:08:46,640 --> 00:08:52,720
okay how many people are people are

259
00:08:49,680 --> 00:08:56,319
using eight in production

260
00:08:52,720 --> 00:08:56,320
okay eight in development

261
00:08:56,560 --> 00:09:00,719
okay that's a a fair number of people

262
00:08:59,120 --> 00:09:01,839
but but fewer than are using it in

263
00:09:00,720 --> 00:09:03,600
production so that's

264
00:09:01,839 --> 00:09:06,959
take that as a positive sign how many

265
00:09:03,600 --> 00:09:10,080
people are using 11 in production

266
00:09:06,959 --> 00:09:11,518
nice that's maybe a third of the room

267
00:09:10,080 --> 00:09:13,600
how many people are using 11 in

268
00:09:11,519 --> 00:09:16,399
development for future stuff

269
00:09:13,600 --> 00:09:17,360
and that's maybe half of the room almost

270
00:09:16,399 --> 00:09:19,200
excellent

271
00:09:17,360 --> 00:09:21,040
how many people are using 13 in

272
00:09:19,200 --> 00:09:24,399
production

273
00:09:21,040 --> 00:09:27,519
okay uh i don't know six

274
00:09:24,399 --> 00:09:30,480
eight excellent good on you how many

275
00:09:27,519 --> 00:09:33,440
people are using 13 in development

276
00:09:30,480 --> 00:09:37,600
okay a few more maybe a couple dozen how

277
00:09:33,440 --> 00:09:40,800
many people are using 14 in production

278
00:09:37,600 --> 00:09:43,040
one two it's not ga yet

279
00:09:40,800 --> 00:09:45,359
using your own risk how many using 14 in

280
00:09:43,040 --> 00:09:48,319
development

281
00:09:45,360 --> 00:09:51,839
yeah well of course okay how many using

282
00:09:48,320 --> 00:09:51,839
15 in production

283
00:09:52,640 --> 00:09:56,000
the the this man has many scars on his

284
00:09:54,640 --> 00:09:58,480
back okay

285
00:09:56,000 --> 00:10:00,160
thank you um that's that's useful and

286
00:09:58,480 --> 00:10:00,399
and actually encouraging information and

287
00:10:00,160 --> 00:10:02,160
it

288
00:10:00,399 --> 00:10:04,160
and it's consistent with um some

289
00:10:02,160 --> 00:10:05,199
anecdata that we've seen at oracle uh

290
00:10:04,160 --> 00:10:07,120
another thing i'm always

291
00:10:05,200 --> 00:10:08,880
skeptical and a little bit disappointed

292
00:10:07,120 --> 00:10:09,360
about is when people quote download

293
00:10:08,880 --> 00:10:12,079
numbers

294
00:10:09,360 --> 00:10:13,120
as as a measure of popularity but here

295
00:10:12,079 --> 00:10:15,599
i'll go ahead and do it

296
00:10:13,120 --> 00:10:16,720
but understanding its anarch data take

297
00:10:15,600 --> 00:10:19,279
it take it for

298
00:10:16,720 --> 00:10:20,560
for take it as you will maybe it doesn't

299
00:10:19,279 --> 00:10:22,640
mean much but

300
00:10:20,560 --> 00:10:25,199
uh on the download statistics we've seen

301
00:10:22,640 --> 00:10:26,800
for the the builds that oracle publishes

302
00:10:25,200 --> 00:10:28,240
you know your gpl or otherwise we have

303
00:10:26,800 --> 00:10:32,719
seen an uptick

304
00:10:28,240 --> 00:10:35,279
in downloads for 12 and 13.

305
00:10:32,720 --> 00:10:36,079
so it could be a sign of you know

306
00:10:35,279 --> 00:10:37,519
there's there's

307
00:10:36,079 --> 00:10:39,920
a bit of a bit of a takeoff here people

308
00:10:37,519 --> 00:10:41,839
are realizing oh once you once you get

309
00:10:39,920 --> 00:10:43,599
get from eight to eleven once you get

310
00:10:41,839 --> 00:10:46,640
past nine basically

311
00:10:43,600 --> 00:10:50,079
it is easier to move forward on these

312
00:10:46,640 --> 00:10:51,839
six months six month feature releases

313
00:10:50,079 --> 00:10:54,160
all right let's shift gears a little bit

314
00:10:51,839 --> 00:10:55,920
and take a closer look at a few of the

315
00:10:54,160 --> 00:10:57,360
features delivered since 11

316
00:10:55,920 --> 00:10:59,519
um and some of the features still in the

317
00:10:57,360 --> 00:11:00,560
pipeline i i would like to try to tempt

318
00:10:59,519 --> 00:11:03,360
you here

319
00:11:00,560 --> 00:11:04,239
to move past eight you know at least get

320
00:11:03,360 --> 00:11:06,800
to 11

321
00:11:04,240 --> 00:11:07,360
and and after that move move forward

322
00:11:06,800 --> 00:11:09,120
from that

323
00:11:07,360 --> 00:11:10,880
but before we look at specific features

324
00:11:09,120 --> 00:11:13,200
let's first consider

325
00:11:10,880 --> 00:11:14,079
uh for a moment how is it that we decide

326
00:11:13,200 --> 00:11:16,800
what features

327
00:11:14,079 --> 00:11:17,760
to add to add to java um you know is

328
00:11:16,800 --> 00:11:21,599
this a popularity

329
00:11:17,760 --> 00:11:23,760
contest what what drives java forward

330
00:11:21,600 --> 00:11:25,040
and it really comes down to two things

331
00:11:23,760 --> 00:11:27,519
for almost

332
00:11:25,040 --> 00:11:29,439
25 years that that'll be 25 years this

333
00:11:27,519 --> 00:11:32,880
may by the way

334
00:11:29,440 --> 00:11:35,040
job has been driven by two big goals

335
00:11:32,880 --> 00:11:36,959
one is developer productivity making

336
00:11:35,040 --> 00:11:38,719
developers more productive helping

337
00:11:36,959 --> 00:11:41,199
developers build and maintain

338
00:11:38,720 --> 00:11:43,040
large and reliable programs java is not

339
00:11:41,200 --> 00:11:44,880
about one-off scripts

340
00:11:43,040 --> 00:11:46,959
it's really about building things for

341
00:11:44,880 --> 00:11:48,720
the long haul and being able to maintain

342
00:11:46,959 --> 00:11:51,119
them for the long haul

343
00:11:48,720 --> 00:11:53,279
the other big goal for 25 years has been

344
00:11:51,120 --> 00:11:54,720
program performance

345
00:11:53,279 --> 00:11:57,279
of course performance we measure in many

346
00:11:54,720 --> 00:11:58,480
ways you know startup time latency

347
00:11:57,279 --> 00:12:00,959
throughput etc

348
00:11:58,480 --> 00:12:02,959
we measure space both static and dynamic

349
00:12:00,959 --> 00:12:05,040
and we measure scalability

350
00:12:02,959 --> 00:12:06,800
from you know iphones iphones to big

351
00:12:05,040 --> 00:12:09,199
iron java is meant to span

352
00:12:06,800 --> 00:12:10,000
to span all of these we pursued these

353
00:12:09,200 --> 00:12:13,040
two goals in the

354
00:12:10,000 --> 00:12:15,120
face of constantly changing factors

355
00:12:13,040 --> 00:12:16,160
including new programming paradigms such

356
00:12:15,120 --> 00:12:19,040
as mixed functional

357
00:12:16,160 --> 00:12:20,480
and object-oriented programming evolving

358
00:12:19,040 --> 00:12:21,920
applications big data and machine

359
00:12:20,480 --> 00:12:22,639
learning you know who was thinking about

360
00:12:21,920 --> 00:12:24,639
this

361
00:12:22,639 --> 00:12:25,680
you know and certainly not in java 25

362
00:12:24,639 --> 00:12:28,079
years ago

363
00:12:25,680 --> 00:12:29,680
um evolving deployment styles to to

364
00:12:28,079 --> 00:12:32,399
clouds into app stores you know

365
00:12:29,680 --> 00:12:33,839
this is no longer there the era of of

366
00:12:32,399 --> 00:12:36,639
java web start really

367
00:12:33,839 --> 00:12:39,839
uh to say nothing of the java plug-in

368
00:12:36,639 --> 00:12:39,839
may rest in peace

369
00:12:40,639 --> 00:12:44,000
and of course there's also evolving

370
00:12:42,480 --> 00:12:44,480
hardware you know we have machines these

371
00:12:44,000 --> 00:12:46,079
days

372
00:12:44,480 --> 00:12:48,639
terabyte memories and deeper memory

373
00:12:46,079 --> 00:12:49,279
hierarchies vector and cindy instruction

374
00:12:48,639 --> 00:12:51,360
sets

375
00:12:49,279 --> 00:12:52,880
and deeper and more numerous processor

376
00:12:51,360 --> 00:12:56,399
pipelines

377
00:12:52,880 --> 00:12:58,880
so goals challenges

378
00:12:56,399 --> 00:13:00,560
in that context let's look at some of

379
00:12:58,880 --> 00:13:07,839
the major active projects in the open

380
00:13:00,560 --> 00:13:07,839
jdk community

381
00:13:09,200 --> 00:13:11,600
all right

382
00:13:12,720 --> 00:13:16,079
we start with amber right sizing

383
00:13:15,519 --> 00:13:18,240
language

384
00:13:16,079 --> 00:13:19,199
ceremonies project being led by brian

385
00:13:18,240 --> 00:13:22,639
getz has already

386
00:13:19,200 --> 00:13:24,399
delivered a number of features

387
00:13:22,639 --> 00:13:27,279
loom virtual threads and scalable

388
00:13:24,399 --> 00:13:29,519
concurrency being led by ron pressler

389
00:13:27,279 --> 00:13:31,920
we'll talk about talk about that a bit a

390
00:13:29,519 --> 00:13:34,160
bit more later on

391
00:13:31,920 --> 00:13:35,760
panama new foreign function and foreign

392
00:13:34,160 --> 00:13:37,600
data interface being led by murray

393
00:13:35,760 --> 00:13:41,199
teoche maramore who's

394
00:13:37,600 --> 00:13:43,440
here somewhere hi sorry uh

395
00:13:41,199 --> 00:13:45,359
and valhalla big project to bring value

396
00:13:43,440 --> 00:13:46,720
types and specialized generics to the

397
00:13:45,360 --> 00:13:50,079
platform being led

398
00:13:46,720 --> 00:13:51,839
by brian getz and john rose so let's

399
00:13:50,079 --> 00:13:53,599
start with amber

400
00:13:51,839 --> 00:13:56,160
amber is squarely aimed at the pain

401
00:13:53,600 --> 00:13:58,160
point of of jabba just requiring

402
00:13:56,160 --> 00:14:00,880
too much ceremony you have to write too

403
00:13:58,160 --> 00:14:03,439
much boilerplate to get things done

404
00:14:00,880 --> 00:14:04,399
the solution that amber proposes is is

405
00:14:03,440 --> 00:14:06,959
not just

406
00:14:04,399 --> 00:14:07,519
is not to reduce boilerplate exactly but

407
00:14:06,959 --> 00:14:09,119
rather

408
00:14:07,519 --> 00:14:10,959
to introduce a series of language

409
00:14:09,120 --> 00:14:12,560
features delivered over time that work

410
00:14:10,959 --> 00:14:14,160
synergistically with each other

411
00:14:12,560 --> 00:14:16,959
that let you express more clearly what

412
00:14:14,160 --> 00:14:19,439
you mean and that in

413
00:14:16,959 --> 00:14:21,839
in the end will wind up reducing the

414
00:14:19,440 --> 00:14:24,000
boilerplate

415
00:14:21,839 --> 00:14:25,519
okay let's go through it through a few

416
00:14:24,000 --> 00:14:26,720
of these um brian covered some of these

417
00:14:25,519 --> 00:14:28,800
last year i'm going to go

418
00:14:26,720 --> 00:14:30,560
go through them pretty quickly suppose

419
00:14:28,800 --> 00:14:33,760
you have an enum for days of the week

420
00:14:30,560 --> 00:14:35,279
monday tuesday wednesday etc

421
00:14:33,760 --> 00:14:37,120
and suppose you want to compute the

422
00:14:35,279 --> 00:14:38,959
length of the day of

423
00:14:37,120 --> 00:14:40,639
of each day now you could cheat and do

424
00:14:38,959 --> 00:14:41,760
that by invoking two string and

425
00:14:40,639 --> 00:14:43,519
string lengthening but we're not going

426
00:14:41,760 --> 00:14:45,680
to do that for the case of this example

427
00:14:43,519 --> 00:14:47,760
we're going to write a switch statement

428
00:14:45,680 --> 00:14:49,359
um you switch on the case you assign to

429
00:14:47,760 --> 00:14:52,000
this num letters variable

430
00:14:49,360 --> 00:14:55,120
uh you have a default um all kinds of

431
00:14:52,000 --> 00:14:55,120
stuff can go wrong here

432
00:14:55,199 --> 00:14:57,760
right you can forget a break statement

433
00:14:56,639 --> 00:14:59,120
fall through to the next one you can

434
00:14:57,760 --> 00:15:00,880
forget to assign you can

435
00:14:59,120 --> 00:15:02,000
you can you can forget the default in

436
00:15:00,880 --> 00:15:03,360
this case you don't actually need it

437
00:15:02,000 --> 00:15:06,079
because this is complete

438
00:15:03,360 --> 00:15:07,440
um as as as brian likes to say this

439
00:15:06,079 --> 00:15:09,040
isn't the language helping you out it's

440
00:15:07,440 --> 00:15:11,199
the language daring you to make a stupid

441
00:15:09,040 --> 00:15:13,120
mistake

442
00:15:11,199 --> 00:15:14,399
because well you think about this

443
00:15:13,120 --> 00:15:15,360
conceptually we're just computing an

444
00:15:14,399 --> 00:15:16,800
expression

445
00:15:15,360 --> 00:15:18,399
so let's write it that way for heaven's

446
00:15:16,800 --> 00:15:20,880
sake and with

447
00:15:18,399 --> 00:15:22,959
switch express expressions you can

448
00:15:20,880 --> 00:15:25,680
there's an additional benefit since

449
00:15:22,959 --> 00:15:26,079
in this case the compiler can deduce

450
00:15:25,680 --> 00:15:28,239
from

451
00:15:26,079 --> 00:15:29,839
the enum declaration that you've covered

452
00:15:28,240 --> 00:15:30,560
every case you don't have to put in a

453
00:15:29,839 --> 00:15:32,079
default

454
00:15:30,560 --> 00:15:33,758
now if it can't deduce that it will

455
00:15:32,079 --> 00:15:34,479
insist that you put in default in a in a

456
00:15:33,759 --> 00:15:37,920
default

457
00:15:34,480 --> 00:15:39,920
but in this case you don't

458
00:15:37,920 --> 00:15:41,920
so switch expressions were first

459
00:15:39,920 --> 00:15:44,639
introduced in java 12

460
00:15:41,920 --> 00:15:45,519
as what we call a preview feature so a

461
00:15:44,639 --> 00:15:49,759
preview feature

462
00:15:45,519 --> 00:15:53,360
is a feature that's 98 99

463
00:15:49,759 --> 00:15:55,440
done but we want to take one or possibly

464
00:15:53,360 --> 00:15:57,040
two two of the six month release cycles

465
00:15:55,440 --> 00:15:58,639
to make sure that it's really baked

466
00:15:57,040 --> 00:16:00,880
before we totally commit to it

467
00:15:58,639 --> 00:16:02,560
so to use a preview feature you have to

468
00:16:00,880 --> 00:16:05,279
specify enable preview

469
00:16:02,560 --> 00:16:06,880
on both the java c command line and the

470
00:16:05,279 --> 00:16:08,399
java launcher command line if you don't

471
00:16:06,880 --> 00:16:09,600
do that you will get a helpful error

472
00:16:08,399 --> 00:16:10,639
message explaining to you hey it's

473
00:16:09,600 --> 00:16:12,240
pretty featured

474
00:16:10,639 --> 00:16:13,680
you know sorry you need you need to be

475
00:16:12,240 --> 00:16:15,120
aware that you're using this because we

476
00:16:13,680 --> 00:16:16,560
don't want you to

477
00:16:15,120 --> 00:16:19,519
make a commitment to something that

478
00:16:16,560 --> 00:16:22,560
could change in the future

479
00:16:19,519 --> 00:16:23,519
so that first previewed in 12 uh it

480
00:16:22,560 --> 00:16:25,680
previewed again

481
00:16:23,519 --> 00:16:26,959
in 13. we got some feedback from the 12

482
00:16:25,680 --> 00:16:28,880
preview

483
00:16:26,959 --> 00:16:30,560
that suggested we should make one small

484
00:16:28,880 --> 00:16:32,320
change so we made that small change

485
00:16:30,560 --> 00:16:35,359
repreviewed it in 13

486
00:16:32,320 --> 00:16:36,240
in 14 it is now final and you know no

487
00:16:35,360 --> 00:16:38,320
longer need

488
00:16:36,240 --> 00:16:40,720
the enable preview option in order to

489
00:16:38,320 --> 00:16:40,720
use it

490
00:16:47,120 --> 00:16:51,600
all right if you want to see if you

491
00:16:50,560 --> 00:16:52,719
if you're if you're curious about the

492
00:16:51,600 --> 00:16:54,160
history of all this you can actually

493
00:16:52,720 --> 00:16:54,639
read the jets right here here's the

494
00:16:54,160 --> 00:16:56,880
first

495
00:16:54,639 --> 00:16:58,480
first preview jeff 325 the second

496
00:16:56,880 --> 00:17:03,360
preview jump 354

497
00:16:58,480 --> 00:17:05,919
and then the final um standard 361

498
00:17:03,360 --> 00:17:06,880
and 361 it has a section down here about

499
00:17:05,919 --> 00:17:08,799
the about the histories

500
00:17:06,880 --> 00:17:10,160
is it explains what what what has

501
00:17:08,799 --> 00:17:12,639
changed what hasn't changed

502
00:17:10,160 --> 00:17:14,400
and so forth okay let's look at another

503
00:17:12,640 --> 00:17:16,400
amber feature text blocks

504
00:17:14,400 --> 00:17:18,240
also known as multi-line string literals

505
00:17:16,400 --> 00:17:20,880
feature people have been asking for

506
00:17:18,240 --> 00:17:21,599
for many many years we've all had to

507
00:17:20,880 --> 00:17:22,720
write code

508
00:17:21,599 --> 00:17:24,159
you know like this maybe you weren't

509
00:17:22,720 --> 00:17:25,839
emitting html but you were you were

510
00:17:24,160 --> 00:17:28,480
doing something you needed a string that

511
00:17:25,839 --> 00:17:28,960
had multiple lines in it so you do the

512
00:17:28,480 --> 00:17:32,160
the

513
00:17:28,960 --> 00:17:34,080
double quote backslash n plus thing

514
00:17:32,160 --> 00:17:35,919
if you've got quotes in your in your

515
00:17:34,080 --> 00:17:37,678
string you need to remember to quote

516
00:17:35,919 --> 00:17:39,120
the quotes themselves and with

517
00:17:37,679 --> 00:17:40,880
backslashes uh

518
00:17:39,120 --> 00:17:42,559
and it and it's all kind of clunky so

519
00:17:40,880 --> 00:17:46,080
with text blocks you can just write

520
00:17:42,559 --> 00:17:48,320
that triple quotes borrowed from

521
00:17:46,080 --> 00:17:49,840
you know python and other languages uh

522
00:17:48,320 --> 00:17:51,439
the details of this are

523
00:17:49,840 --> 00:17:53,760
it actually turned out to be quite quite

524
00:17:51,440 --> 00:17:57,039
sophisticated um

525
00:17:53,760 --> 00:17:58,720
in order to make it intuitive to use

526
00:17:57,039 --> 00:18:00,720
the the sort of obvious interpretation

527
00:17:58,720 --> 00:18:02,160
of this would be okay this is a string

528
00:18:00,720 --> 00:18:03,840
it's got multiple lines in it there will

529
00:18:02,160 --> 00:18:05,280
be new line after each one

530
00:18:03,840 --> 00:18:06,639
and there will be all these spaces

531
00:18:05,280 --> 00:18:08,000
before each line of course that's

532
00:18:06,640 --> 00:18:09,360
probably not what you want you probably

533
00:18:08,000 --> 00:18:10,720
want this angle bracket to be in the

534
00:18:09,360 --> 00:18:13,760
first column

535
00:18:10,720 --> 00:18:14,799
so the this feature is specified very

536
00:18:13,760 --> 00:18:18,160
carefully

537
00:18:14,799 --> 00:18:19,200
to let you ignore that and it will find

538
00:18:18,160 --> 00:18:21,760
the common

539
00:18:19,200 --> 00:18:24,000
prefix of white space ahead of all of

540
00:18:21,760 --> 00:18:26,000
your lines and remove them

541
00:18:24,000 --> 00:18:27,679
so that you get you know what what it

542
00:18:26,000 --> 00:18:29,520
was that you almost certainly intended

543
00:18:27,679 --> 00:18:30,880
now if you really do need to indent

544
00:18:29,520 --> 00:18:32,559
there's a new convenience method on the

545
00:18:30,880 --> 00:18:34,400
string class that will that will let you

546
00:18:32,559 --> 00:18:37,840
indent

547
00:18:34,400 --> 00:18:39,600
a text blocks previewed uh first in 13.

548
00:18:37,840 --> 00:18:41,360
we got some feedback changed them a

549
00:18:39,600 --> 00:18:42,399
little bit in 14 they're still in

550
00:18:41,360 --> 00:18:45,439
preview mode

551
00:18:42,400 --> 00:18:47,760
they will almost certainly be final in

552
00:18:45,440 --> 00:18:48,640
15. so if you're curious about them

553
00:18:47,760 --> 00:18:50,960
check them out and

554
00:18:48,640 --> 00:18:53,520
let us know if we missed something else

555
00:18:50,960 --> 00:18:55,520
in this feature

556
00:18:53,520 --> 00:18:56,799
moving right along a feature that brian

557
00:18:55,520 --> 00:19:00,160
brian didn't mention

558
00:18:56,799 --> 00:19:02,639
last year we've all written

559
00:19:00,160 --> 00:19:04,559
plain old java objects you have some

560
00:19:02,640 --> 00:19:05,600
fields you have a constructor with the

561
00:19:04,559 --> 00:19:07,039
obvious

562
00:19:05,600 --> 00:19:08,799
obvious parameters does the assignment

563
00:19:07,039 --> 00:19:12,559
in the fields you have some accessors

564
00:19:08,799 --> 00:19:12,559
and what did i forget on this slide

565
00:19:15,120 --> 00:19:19,360
and two string yes oh right okay i gotta

566
00:19:18,799 --> 00:19:21,918
write those

567
00:19:19,360 --> 00:19:23,360
okay type type type type or tell your id

568
00:19:21,919 --> 00:19:24,640
to write them for you and hopefully the

569
00:19:23,360 --> 00:19:26,559
id gets them right

570
00:19:24,640 --> 00:19:28,240
um the id can make it easier to write

571
00:19:26,559 --> 00:19:29,280
but it can make it easier to read right

572
00:19:28,240 --> 00:19:31,520
if you go change

573
00:19:29,280 --> 00:19:32,799
some of the code your id generated and

574
00:19:31,520 --> 00:19:33,679
you come back a year later you have to

575
00:19:32,799 --> 00:19:35,600
go make sure that

576
00:19:33,679 --> 00:19:38,400
is that actually right because well you

577
00:19:35,600 --> 00:19:40,480
can change it whatever um

578
00:19:38,400 --> 00:19:41,840
it's it's easy to cut corners you know

579
00:19:40,480 --> 00:19:44,080
plenty plenty of people i

580
00:19:41,840 --> 00:19:45,280
i i will confess i i will occasionally

581
00:19:44,080 --> 00:19:46,879
write a pojo in some

582
00:19:45,280 --> 00:19:48,559
you know quickie code and i don't write

583
00:19:46,880 --> 00:19:51,600
equals hashcode into string because i'm

584
00:19:48,559 --> 00:19:53,918
i'm just lazy um

585
00:19:51,600 --> 00:19:54,959
and all the encapsulation of the class

586
00:19:53,919 --> 00:19:56,960
machinery here

587
00:19:54,960 --> 00:19:58,480
is just not necessary right this is just

588
00:19:56,960 --> 00:20:00,240
a whole different data

589
00:19:58,480 --> 00:20:01,760
we just need a way to say that and we

590
00:20:00,240 --> 00:20:05,440
can do that now with

591
00:20:01,760 --> 00:20:06,000
records so a record declaration replaces

592
00:20:05,440 --> 00:20:08,559
all that stuff

593
00:20:06,000 --> 00:20:10,320
that's now in gray with that you just

594
00:20:08,559 --> 00:20:11,520
just write record point double x double

595
00:20:10,320 --> 00:20:15,120
y

596
00:20:11,520 --> 00:20:15,679
curly's you're done because sometimes

597
00:20:15,120 --> 00:20:18,639
data

598
00:20:15,679 --> 00:20:20,880
is just data we don't need don't need a

599
00:20:18,640 --> 00:20:22,480
whole class now you can customize

600
00:20:20,880 --> 00:20:23,280
records maybe you want your own hash

601
00:20:22,480 --> 00:20:24,720
code

602
00:20:23,280 --> 00:20:26,158
because you you you have it you have a

603
00:20:24,720 --> 00:20:26,799
different favorite prime number okay

604
00:20:26,159 --> 00:20:28,559
fine

605
00:20:26,799 --> 00:20:30,158
maybe you want to to add additional

606
00:20:28,559 --> 00:20:31,600
methods so it's a point maybe

607
00:20:30,159 --> 00:20:33,600
we want to compute its norm so we can do

608
00:20:31,600 --> 00:20:35,520
that you can write you

609
00:20:33,600 --> 00:20:36,799
write a constructor if you want implicit

610
00:20:35,520 --> 00:20:38,400
field initialization

611
00:20:36,799 --> 00:20:40,158
initialization happens first and then

612
00:20:38,400 --> 00:20:42,000
you can check you know

613
00:20:40,159 --> 00:20:43,679
are are your invariant are your incoming

614
00:20:42,000 --> 00:20:46,159
invariants true or not

615
00:20:43,679 --> 00:20:47,840
and throw an exception what you can't do

616
00:20:46,159 --> 00:20:50,240
is add more state

617
00:20:47,840 --> 00:20:50,879
right if you try to add a new field you

618
00:20:50,240 --> 00:20:54,159
will get

619
00:20:50,880 --> 00:20:56,159
a a compile time error because

620
00:20:54,159 --> 00:20:57,520
that would buy you adding more state

621
00:20:56,159 --> 00:20:58,720
would violate the invariant

622
00:20:57,520 --> 00:21:01,120
that a record is meant to be a

623
00:20:58,720 --> 00:21:03,280
transparent holder for data

624
00:21:01,120 --> 00:21:04,799
records are immutable this is sort of a

625
00:21:03,280 --> 00:21:06,720
nudge towards

626
00:21:04,799 --> 00:21:08,400
functional programming which is

627
00:21:06,720 --> 00:21:09,440
generally a pretty good thing

628
00:21:08,400 --> 00:21:10,960
but you know if that doesn't work for

629
00:21:09,440 --> 00:21:12,640
you that's okay you can still write a

630
00:21:10,960 --> 00:21:15,280
pojo class those those still work

631
00:21:12,640 --> 00:21:16,960
we're never going to take those away

632
00:21:15,280 --> 00:21:20,559
records are

633
00:21:16,960 --> 00:21:22,640
in preview now in java 14 jdk 14

634
00:21:20,559 --> 00:21:24,720
so you can check them out and play with

635
00:21:22,640 --> 00:21:24,720
them

636
00:21:24,960 --> 00:21:30,640
all right last feature and this one

637
00:21:27,200 --> 00:21:32,320
brian brian did mention

638
00:21:30,640 --> 00:21:33,679
here's another another pile of code the

639
00:21:32,320 --> 00:21:34,080
sort of thing that many of us have

640
00:21:33,679 --> 00:21:37,120
written

641
00:21:34,080 --> 00:21:39,039
many times you've got some object of of

642
00:21:37,120 --> 00:21:40,479
of unknown type other than object you

643
00:21:39,039 --> 00:21:41,200
want to test whether it's an integer a

644
00:21:40,480 --> 00:21:44,240
double

645
00:21:41,200 --> 00:21:46,799
or a point and uh and and create a

646
00:21:44,240 --> 00:21:47,840
nice string string describing what what

647
00:21:46,799 --> 00:21:49,120
exactly it is

648
00:21:47,840 --> 00:21:51,360
and each one of these it's this really

649
00:21:49,120 --> 00:21:53,439
clunky thing you test whether ob is an

650
00:21:51,360 --> 00:21:55,520
instance of integer oh it is okay inside

651
00:21:53,440 --> 00:21:56,960
and you cast it to integer of and it's

652
00:21:55,520 --> 00:21:59,280
okay this is tedious

653
00:21:56,960 --> 00:22:01,440
um pat with pattern matching you can

654
00:21:59,280 --> 00:22:03,918
write this

655
00:22:01,440 --> 00:22:06,000
so a pattern match is this is this is an

656
00:22:03,919 --> 00:22:08,240
enhancement to instance of

657
00:22:06,000 --> 00:22:10,799
you ask whether i uh ob is an instance

658
00:22:08,240 --> 00:22:13,039
of integer so it does a type test

659
00:22:10,799 --> 00:22:14,240
or a pattern test if that's true then it

660
00:22:13,039 --> 00:22:17,039
binds i

661
00:22:14,240 --> 00:22:17,840
which is a type integer to object and

662
00:22:17,039 --> 00:22:20,720
does the cast

663
00:22:17,840 --> 00:22:22,320
implicitly so now i is an integer object

664
00:22:20,720 --> 00:22:24,720
you can pass it to string format

665
00:22:22,320 --> 00:22:25,678
and your code just got much more

666
00:22:24,720 --> 00:22:27,280
readable

667
00:22:25,679 --> 00:22:29,520
now another cool thing is is the

668
00:22:27,280 --> 00:22:31,840
destructuring for you you have a point

669
00:22:29,520 --> 00:22:33,200
it will actually destructure x and y you

670
00:22:31,840 --> 00:22:35,840
can type x and y here

671
00:22:33,200 --> 00:22:37,120
rather than um rather than having to

672
00:22:35,840 --> 00:22:40,399
dissect it as a point and

673
00:22:37,120 --> 00:22:45,120
and use its accessor methods

674
00:22:40,400 --> 00:22:48,320
so patterns are in preview in java 14.

675
00:22:45,120 --> 00:22:50,719
um unfortunately no no destructuring

676
00:22:48,320 --> 00:22:52,480
yet it's it's just simple simple type

677
00:22:50,720 --> 00:22:54,559
tests but there's a long-term plan

678
00:22:52,480 --> 00:22:56,400
to enhance this with destructuring and

679
00:22:54,559 --> 00:22:58,559
so forth all of the amber features are

680
00:22:56,400 --> 00:23:01,200
designed to synergize with each other

681
00:22:58,559 --> 00:23:02,960
eventually patterns will play well with

682
00:23:01,200 --> 00:23:03,679
switch expressions so you'll be able to

683
00:23:02,960 --> 00:23:06,000
write

684
00:23:03,679 --> 00:23:09,760
something like this which is actually

685
00:23:06,000 --> 00:23:11,760
quite nice

686
00:23:09,760 --> 00:23:12,879
okay that's a selection of features from

687
00:23:11,760 --> 00:23:15,760
amber let's

688
00:23:12,880 --> 00:23:17,200
move ahead so i could say i could say

689
00:23:15,760 --> 00:23:17,760
whatever whatever i wanted about amber

690
00:23:17,200 --> 00:23:20,080
because

691
00:23:17,760 --> 00:23:21,440
brian is in the room for the rest of the

692
00:23:20,080 --> 00:23:23,439
things i'm talking about there are

693
00:23:21,440 --> 00:23:24,799
experts in the room uh who will please

694
00:23:23,440 --> 00:23:27,120
correct me if i get something

695
00:23:24,799 --> 00:23:29,039
wrong or stupid so let's move on to loom

696
00:23:27,120 --> 00:23:32,479
uh virtual threads and structured

697
00:23:29,039 --> 00:23:32,480
concurrency being led by ron

698
00:23:34,960 --> 00:23:38,799
and i will actually at this point switch

699
00:23:36,640 --> 00:23:40,400
computers and hopefully the av system

700
00:23:38,799 --> 00:23:44,000
will keep up

701
00:23:40,400 --> 00:23:46,799
because i am going to do some demos

702
00:23:44,000 --> 00:23:46,799
always excited

703
00:23:47,440 --> 00:23:51,840
thank you for the sound effects george

704
00:23:53,039 --> 00:23:55,440
okay

705
00:24:02,840 --> 00:24:10,399
cool i love it when things work

706
00:24:07,279 --> 00:24:10,400
all too rare in this business

707
00:24:17,279 --> 00:24:24,320
okay and for this i'm going to sit down

708
00:24:21,840 --> 00:24:26,000
but i'm still in camera range i'm just

709
00:24:24,320 --> 00:24:29,520
holding the edge

710
00:24:26,000 --> 00:24:33,840
okay so let's

711
00:24:29,520 --> 00:24:33,840
look at loom whoops

712
00:24:35,679 --> 00:24:40,240
here i've got a very recent build of the

713
00:24:38,159 --> 00:24:44,000
loom

714
00:24:40,240 --> 00:24:47,120
repo in this case from github ooh fancy

715
00:24:44,000 --> 00:24:49,200
um let's let's go into j shell and poke

716
00:24:47,120 --> 00:24:52,639
around a bit

717
00:24:49,200 --> 00:24:52,640
so we've all written thread code

718
00:24:52,799 --> 00:25:01,840
equals new thread come on mark

719
00:24:57,360 --> 00:25:01,840
just use a little lambda here

720
00:25:07,039 --> 00:25:10,080
i've got a thread start it it prints

721
00:25:09,679 --> 00:25:11,760
high

722
00:25:10,080 --> 00:25:15,439
and i'm done and you know this thread is

723
00:25:11,760 --> 00:25:17,440
still still sitting around so

724
00:25:15,440 --> 00:25:18,640
threads and threads in java where there

725
00:25:17,440 --> 00:25:22,240
were kind of this

726
00:25:18,640 --> 00:25:23,440
this uh interesting feature feature at

727
00:25:22,240 --> 00:25:25,840
the time that not

728
00:25:23,440 --> 00:25:26,480
25 years ago not that many many popular

729
00:25:25,840 --> 00:25:28,000
platforms

730
00:25:26,480 --> 00:25:29,120
actually had threads but a lot of people

731
00:25:28,000 --> 00:25:29,760
needed threads and one of james

732
00:25:29,120 --> 00:25:31,760
gosling's

733
00:25:29,760 --> 00:25:34,080
observation was oh well we should give

734
00:25:31,760 --> 00:25:34,640
them threads but we'll do it in in a in

735
00:25:34,080 --> 00:25:38,559
a nicer

736
00:25:34,640 --> 00:25:41,600
nicer language than say c or something

737
00:25:38,559 --> 00:25:44,639
so a thread in java for

738
00:25:41,600 --> 00:25:46,240
maybe not 25 years maybe 23 years

739
00:25:44,640 --> 00:25:48,640
has corresponded to an operating system

740
00:25:46,240 --> 00:25:50,000
thread so that has benefits in that well

741
00:25:48,640 --> 00:25:51,360
it's a nice clean abstraction it's easy

742
00:25:50,000 --> 00:25:52,320
to understand it's easy to relate to

743
00:25:51,360 --> 00:25:55,039
what's going on in the

744
00:25:52,320 --> 00:25:56,080
underlying system but they're expensive

745
00:25:55,039 --> 00:25:58,240
to create

746
00:25:56,080 --> 00:25:59,918
uh they're they're they they take a lot

747
00:25:58,240 --> 00:26:01,039
of memory a thread by default comes with

748
00:25:59,919 --> 00:26:03,520
like a megabyte

749
00:26:01,039 --> 00:26:06,240
stack in outside of the java heap plus

750
00:26:03,520 --> 00:26:07,679
some significant space in the java heap

751
00:26:06,240 --> 00:26:09,360
they're it's expensive to switch

752
00:26:07,679 --> 00:26:10,799
contacts you can spend a couple of

753
00:26:09,360 --> 00:26:11,600
thousand instruction cycles you know on

754
00:26:10,799 --> 00:26:13,600
the order of a

755
00:26:11,600 --> 00:26:15,840
millisecond or two in a modern processor

756
00:26:13,600 --> 00:26:19,120
you know switching between threads

757
00:26:15,840 --> 00:26:19,678
um because they're expensive because

758
00:26:19,120 --> 00:26:22,799
they're so

759
00:26:19,679 --> 00:26:24,400
it's slow to switch across them for high

760
00:26:22,799 --> 00:26:26,158
performance people tend people who

761
00:26:24,400 --> 00:26:26,480
really want the best performance for

762
00:26:26,159 --> 00:26:29,520
some

763
00:26:26,480 --> 00:26:32,640
something like like a a web server will

764
00:26:29,520 --> 00:26:34,799
turn to non-blocking i o apis or async

765
00:26:32,640 --> 00:26:37,679
frameworks or reactive frameworks

766
00:26:34,799 --> 00:26:38,799
which can indeed get very high

767
00:26:37,679 --> 00:26:40,240
performance but

768
00:26:38,799 --> 00:26:41,840
they're difficult it's difficult to

769
00:26:40,240 --> 00:26:44,320
write programs that use such frameworks

770
00:26:41,840 --> 00:26:46,399
it's difficult to debug such programs

771
00:26:44,320 --> 00:26:47,439
and it's difficult to profile such

772
00:26:46,400 --> 00:26:48,960
programs

773
00:26:47,440 --> 00:26:50,840
as a result a lot of people don't bother

774
00:26:48,960 --> 00:26:53,520
with that and servers wind up being

775
00:26:50,840 --> 00:26:54,158
underutilized so one of the principal

776
00:26:53,520 --> 00:26:56,240
features of the

777
00:26:54,159 --> 00:26:57,360
the principal feature of loom i would

778
00:26:56,240 --> 00:27:00,000
say is uh

779
00:26:57,360 --> 00:27:00,639
is virtual threads so for a long time we

780
00:27:00,000 --> 00:27:04,000
called these

781
00:27:00,640 --> 00:27:05,520
fibers and you know we weren't sure

782
00:27:04,000 --> 00:27:06,720
where our fiber is going to be threads

783
00:27:05,520 --> 00:27:07,840
our thread is going to be fibers what's

784
00:27:06,720 --> 00:27:10,799
the relationship between

785
00:27:07,840 --> 00:27:11,360
these two and ron and alan and and other

786
00:27:10,799 --> 00:27:13,120
folks

787
00:27:11,360 --> 00:27:14,799
went through a long series of

788
00:27:13,120 --> 00:27:17,439
prototyping efforts uh

789
00:27:14,799 --> 00:27:19,440
long series design analyses to try to

790
00:27:17,440 --> 00:27:22,640
figure this out and

791
00:27:19,440 --> 00:27:24,320
finally decided last fall okay

792
00:27:22,640 --> 00:27:26,240
it it there's a certain attraction to

793
00:27:24,320 --> 00:27:27,678
making fibers be something new and shiny

794
00:27:26,240 --> 00:27:30,480
and clean and not saddled

795
00:27:27,679 --> 00:27:31,120
with all the baggage of thread but that

796
00:27:30,480 --> 00:27:33,039
would

797
00:27:31,120 --> 00:27:34,479
that would not accommodate all that

798
00:27:33,039 --> 00:27:37,360
existing code out there that uses thread

799
00:27:34,480 --> 00:27:39,360
so we decided okay

800
00:27:37,360 --> 00:27:40,399
fibers are no more i mean the mechanisms

801
00:27:39,360 --> 00:27:41,600
is still there but now they're called

802
00:27:40,399 --> 00:27:43,600
virtual threads

803
00:27:41,600 --> 00:27:45,120
they use the java length thread api but

804
00:27:43,600 --> 00:27:47,120
they don't have all the baggage baggage

805
00:27:45,120 --> 00:27:49,039
they don't take all the space

806
00:27:47,120 --> 00:27:51,199
so that that's where we are let's create

807
00:27:49,039 --> 00:27:54,640
a virtual thread and see

808
00:27:51,200 --> 00:27:56,880
how that works um

809
00:27:54,640 --> 00:27:59,360
thread the thread class uh in in in this

810
00:27:56,880 --> 00:28:01,919
build now has a builder you can

811
00:27:59,360 --> 00:28:03,760
request a a virtual thread i'm going to

812
00:28:01,919 --> 00:28:06,320
give it a task which is the same task i

813
00:28:03,760 --> 00:28:06,320
had before

814
00:28:11,840 --> 00:28:16,559
and let me just go ahead and start that

815
00:28:14,399 --> 00:28:20,158
and it does its thing it prints high

816
00:28:16,559 --> 00:28:22,639
and then i get back this this t now is a

817
00:28:20,159 --> 00:28:24,559
is a virtual thread um it's now

818
00:28:22,640 --> 00:28:27,360
terminated but before it actually ran

819
00:28:24,559 --> 00:28:29,279
it printed no carrier thread so a

820
00:28:27,360 --> 00:28:32,080
virtual thread is virtual

821
00:28:29,279 --> 00:28:33,279
because it's not always associated with

822
00:28:32,080 --> 00:28:35,520
an operating system thread

823
00:28:33,279 --> 00:28:36,399
it is scheduled by the runtime

824
00:28:35,520 --> 00:28:38,559
environment

825
00:28:36,399 --> 00:28:40,080
by by the java libraries you know in

826
00:28:38,559 --> 00:28:44,240
actual java code

827
00:28:40,080 --> 00:28:47,039
um and and and and switched in

828
00:28:44,240 --> 00:28:48,640
in that context as well so when a

829
00:28:47,039 --> 00:28:50,240
virtual thread thread needs to run it's

830
00:28:48,640 --> 00:28:51,919
assigned to an os thread

831
00:28:50,240 --> 00:28:54,320
and then when it when it's done or when

832
00:28:51,919 --> 00:28:56,559
it when it needs to block it's it's

833
00:28:54,320 --> 00:28:58,000
unassigned d mounted from that os thread

834
00:28:56,559 --> 00:28:59,918
and that os thread is used for

835
00:28:58,000 --> 00:29:01,279
some other virtual thread now the

836
00:28:59,919 --> 00:29:01,760
terminology is maybe a little weird

837
00:29:01,279 --> 00:29:03,600
because

838
00:29:01,760 --> 00:29:04,879
i mean all this stuff is virtual right i

839
00:29:03,600 --> 00:29:07,199
mean an os thread is

840
00:29:04,880 --> 00:29:08,000
it's not a real thing it's just bits and

841
00:29:07,200 --> 00:29:09,279
memory

842
00:29:08,000 --> 00:29:11,200
but anyway a virtual thread is more

843
00:29:09,279 --> 00:29:12,559
virtual than a chrome than a kernel

844
00:29:11,200 --> 00:29:15,840
thread

845
00:29:12,559 --> 00:29:17,600
there you go um

846
00:29:15,840 --> 00:29:19,439
you can switch amongst virtual threads

847
00:29:17,600 --> 00:29:21,039
in very quickly

848
00:29:19,440 --> 00:29:23,120
in nanoseconds rather rather than a

849
00:29:21,039 --> 00:29:25,440
microsecond or two they're smaller

850
00:29:23,120 --> 00:29:26,799
they're only a few hundred bytes their

851
00:29:25,440 --> 00:29:29,120
stacks grow and shrink

852
00:29:26,799 --> 00:29:29,918
as needed uh they don't uh they don't

853
00:29:29,120 --> 00:29:33,279
take up

854
00:29:29,919 --> 00:29:34,559
uh space unnecessarily uh as a result

855
00:29:33,279 --> 00:29:37,279
you can write simple

856
00:29:34,559 --> 00:29:38,080
simple synchronous code that is just as

857
00:29:37,279 --> 00:29:40,720
efficient

858
00:29:38,080 --> 00:29:41,760
as asynchronous code but of course since

859
00:29:40,720 --> 00:29:43,600
it's synchronous

860
00:29:41,760 --> 00:29:45,919
it's far easier to read you don't wind

861
00:29:43,600 --> 00:29:47,678
up in you know continuation hell or

862
00:29:45,919 --> 00:29:48,880
these interactive frameworks where

863
00:29:47,679 --> 00:29:50,159
one thing happens over here and

864
00:29:48,880 --> 00:29:50,880
eventually it happens over there and you

865
00:29:50,159 --> 00:29:54,000
can't tell

866
00:29:50,880 --> 00:29:57,840
what's going on at runtime all right

867
00:29:54,000 --> 00:29:57,840
a quickie demo here

868
00:29:58,080 --> 00:30:02,639
let's take a look using my favorite ide

869
00:30:03,039 --> 00:30:12,158
and java

870
00:30:09,279 --> 00:30:13,440
sleep service so there's a little little

871
00:30:12,159 --> 00:30:15,440
demo that allen wrote it's

872
00:30:13,440 --> 00:30:18,399
this is trivial little rest service

873
00:30:15,440 --> 00:30:20,559
using uh using jax rs it

874
00:30:18,399 --> 00:30:22,639
responds to this end point uh it's

875
00:30:20,559 --> 00:30:24,720
called sleep

876
00:30:22,640 --> 00:30:26,080
what does it do well you you go into hit

877
00:30:24,720 --> 00:30:27,919
into this if nothing specified it'll

878
00:30:26,080 --> 00:30:30,000
sleep for 100 milliseconds

879
00:30:27,919 --> 00:30:31,760
it just does its sleep and returns that

880
00:30:30,000 --> 00:30:34,840
you pretend that sleep is an actual

881
00:30:31,760 --> 00:30:36,320
you know blocking i o operation or

882
00:30:34,840 --> 00:30:41,439
something

883
00:30:36,320 --> 00:30:41,439
so let's run that with kernel threads

884
00:30:44,000 --> 00:30:47,440
using it using the this vegeta load

885
00:30:46,000 --> 00:30:51,279
generator to

886
00:30:47,440 --> 00:30:53,840
to pound it a little bit

887
00:30:51,279 --> 00:30:55,679
it's running for five seconds and then

888
00:30:53,840 --> 00:30:58,399
actually

889
00:30:55,679 --> 00:30:59,440
testing for ten we'll do that it's going

890
00:30:58,399 --> 00:31:01,840
to generate a graph

891
00:30:59,440 --> 00:31:01,840
for us

892
00:31:03,679 --> 00:31:10,000
here are the response times now that's

893
00:31:06,799 --> 00:31:10,960
that's pretty ugly so we we expect no

894
00:31:10,000 --> 00:31:12,399
response time under

895
00:31:10,960 --> 00:31:13,679
100 milliseconds right because it's

896
00:31:12,399 --> 00:31:14,158
sleep because it's kind of implementing

897
00:31:13,679 --> 00:31:16,080
it's

898
00:31:14,159 --> 00:31:18,320
simulating some blocking operation but

899
00:31:16,080 --> 00:31:20,480
then these response times are like all

900
00:31:18,320 --> 00:31:23,360
over the map we've got some that are

901
00:31:20,480 --> 00:31:24,159
over over a second long because these

902
00:31:23,360 --> 00:31:25,840
these threads are

903
00:31:24,159 --> 00:31:28,399
are expensive it's expensive to switch

904
00:31:25,840 --> 00:31:29,840
amongst them uh and so that's that's not

905
00:31:28,399 --> 00:31:34,879
very good performance

906
00:31:29,840 --> 00:31:38,158
let's run this again but this time

907
00:31:34,880 --> 00:31:39,760
we will use virtual threads

908
00:31:38,159 --> 00:31:43,039
which it turns out is really easy

909
00:31:39,760 --> 00:31:44,960
because the jetty web server

910
00:31:43,039 --> 00:31:46,480
is configured by actual java code rather

911
00:31:44,960 --> 00:31:48,720
than a pile of xml

912
00:31:46,480 --> 00:31:52,080
and all we had to do was go down to its

913
00:31:48,720 --> 00:31:54,640
definite definition of its thread pool

914
00:31:52,080 --> 00:31:56,240
and use it use a virtual thread factory

915
00:31:54,640 --> 00:32:00,159
to create the thing

916
00:31:56,240 --> 00:32:02,960
so make virtual

917
00:32:00,159 --> 00:32:02,960
we'll let that run

918
00:32:08,399 --> 00:32:19,120
dun dun dun dun dun dun dun dun dun

919
00:32:15,840 --> 00:32:20,559
okay let's reload the graph

920
00:32:19,120 --> 00:32:22,639
now it's actually kind of hard to see so

921
00:32:20,559 --> 00:32:25,440
i'll zoom in a bit

922
00:32:22,640 --> 00:32:26,320
the orange is the response time with

923
00:32:25,440 --> 00:32:27,840
virtual threads

924
00:32:26,320 --> 00:32:29,200
it starts a little high bring it

925
00:32:27,840 --> 00:32:30,080
probably because hot spots compiling

926
00:32:29,200 --> 00:32:32,080
stuff

927
00:32:30,080 --> 00:32:34,879
um there are a couple of blips probably

928
00:32:32,080 --> 00:32:37,279
for gcs but as you can see

929
00:32:34,880 --> 00:32:38,480
the response time is almost always just

930
00:32:37,279 --> 00:32:41,360
barely above

931
00:32:38,480 --> 00:32:43,840
100 milliseconds a huge a huge

932
00:32:41,360 --> 00:32:43,840
improvement

933
00:32:44,240 --> 00:32:48,000
so that's virtual threads in performance

934
00:32:47,039 --> 00:32:49,919
um

935
00:32:48,000 --> 00:32:51,519
i i i said that virtual thread threads

936
00:32:49,919 --> 00:32:53,200
are also easier i'm just just

937
00:32:51,519 --> 00:32:54,559
easier to deal with a good example of

938
00:32:53,200 --> 00:32:58,080
that is just

939
00:32:54,559 --> 00:32:59,519
a couple of days ago the team got

940
00:32:58,080 --> 00:33:03,519
working

941
00:32:59,519 --> 00:33:04,399
um some some java java flight recorder

942
00:33:03,519 --> 00:33:06,399
events

943
00:33:04,399 --> 00:33:07,760
you know showing the the activity you

944
00:33:06,399 --> 00:33:10,239
know going on in

945
00:33:07,760 --> 00:33:11,279
in a in a in a java with with loom

946
00:33:10,240 --> 00:33:14,480
inside it

947
00:33:11,279 --> 00:33:15,840
let me zoom in a bit the important thing

948
00:33:14,480 --> 00:33:18,880
to note here is

949
00:33:15,840 --> 00:33:21,840
you can actually see so here here is

950
00:33:18,880 --> 00:33:23,360
this this this code is code is running

951
00:33:21,840 --> 00:33:26,000
along in this test

952
00:33:23,360 --> 00:33:26,959
it gets to a read of a socket input

953
00:33:26,000 --> 00:33:29,360
stream

954
00:33:26,960 --> 00:33:31,600
and and it and it blocks right there's a

955
00:33:29,360 --> 00:33:33,519
virtu this is a virtual thread blocking

956
00:33:31,600 --> 00:33:35,678
if you had written there's a virtual

957
00:33:33,519 --> 00:33:37,600
thread blocking but in effect it's doing

958
00:33:35,679 --> 00:33:39,440
non-blocking io under the covers because

959
00:33:37,600 --> 00:33:41,039
that virtual thread gets parked the os

960
00:33:39,440 --> 00:33:43,039
thread is used for something else

961
00:33:41,039 --> 00:33:44,960
and and the scheduler will come back to

962
00:33:43,039 --> 00:33:47,279
it when this read completes

963
00:33:44,960 --> 00:33:48,799
but you get a nice stack trace because

964
00:33:47,279 --> 00:33:50,159
what you wrote was sequential code

965
00:33:48,799 --> 00:33:52,320
and now you can debug it and now you can

966
00:33:50,159 --> 00:33:54,720
get statistics you know such as the

967
00:33:52,320 --> 00:33:56,480
total amount of time spent on i o per

968
00:33:54,720 --> 00:33:58,960
port if you were using

969
00:33:56,480 --> 00:34:00,000
an async or reactive framework you would

970
00:33:58,960 --> 00:34:01,440
not be able to get any of this

971
00:34:00,000 --> 00:34:03,039
information because it doesn't really

972
00:34:01,440 --> 00:34:06,159
exist

973
00:34:03,039 --> 00:34:10,000
so that's a big improvement

974
00:34:06,159 --> 00:34:12,639
all right moving right along

975
00:34:10,000 --> 00:34:15,199
panama foreign function and foreign data

976
00:34:12,639 --> 00:34:15,200
interface

977
00:34:15,520 --> 00:34:19,520
we all we all know i i suspect the the

978
00:34:18,320 --> 00:34:22,399
the pain of jay and i

979
00:34:19,520 --> 00:34:23,759
um it's it's it's just painful you have

980
00:34:22,399 --> 00:34:25,598
to write c code you have to compile it

981
00:34:23,760 --> 00:34:26,639
into a shared object you have to tell

982
00:34:25,599 --> 00:34:28,879
that you have a runtime where that

983
00:34:26,639 --> 00:34:29,760
shared object wound up uh and so on and

984
00:34:28,879 --> 00:34:32,159
so forth

985
00:34:29,760 --> 00:34:35,839
uh it's just a pain so we're going to

986
00:34:32,159 --> 00:34:35,839
make it better

987
00:34:38,159 --> 00:34:43,679
okay so panama is is a new

988
00:34:42,079 --> 00:34:45,359
java foreign bridge there are

989
00:34:43,679 --> 00:34:47,760
essentially three parts to it there's

990
00:34:45,359 --> 00:34:49,119
a java api for low-level memory access

991
00:34:47,760 --> 00:34:50,720
which maurizio will cover

992
00:34:49,119 --> 00:34:52,240
later today in detail i'm not going to

993
00:34:50,719 --> 00:34:53,520
talk much about that

994
00:34:52,239 --> 00:34:55,520
there's an extraction tool called

995
00:34:53,520 --> 00:34:57,759
jxtract that transforms

996
00:34:55,520 --> 00:34:59,759
c and c plus plus header files into java

997
00:34:57,760 --> 00:35:01,680
interfaces that use that api

998
00:34:59,760 --> 00:35:03,359
and then there's a runtime binding

999
00:35:01,680 --> 00:35:04,399
mechanism that synthesizes

1000
00:35:03,359 --> 00:35:06,799
implementations

1001
00:35:04,400 --> 00:35:08,240
of those interfaces okay so let's look

1002
00:35:06,800 --> 00:35:10,960
at a quick example we

1003
00:35:08,240 --> 00:35:13,118
are probably all familiar with get pid

1004
00:35:10,960 --> 00:35:15,839
the simplest possible

1005
00:35:13,119 --> 00:35:17,680
unix system call you you invoke it it

1006
00:35:15,839 --> 00:35:21,040
returns your process identifier

1007
00:35:17,680 --> 00:35:24,480
uh as a as an ins

1008
00:35:21,040 --> 00:35:26,560
um you know suppose we want to read this

1009
00:35:24,480 --> 00:35:28,079
you know invoke this you know from java

1010
00:35:26,560 --> 00:35:29,920
okay yeah i know the api has

1011
00:35:28,079 --> 00:35:32,480
essentially get method but we're gonna

1012
00:35:29,920 --> 00:35:35,599
we're gonna do this anyway

1013
00:35:32,480 --> 00:35:38,720
what we can do is run jxtract

1014
00:35:35,599 --> 00:35:40,960
and i need to pass it no i don't need to

1015
00:35:38,720 --> 00:35:43,040
pass anything

1016
00:35:40,960 --> 00:35:44,880
unit standard.h contains the definition

1017
00:35:43,040 --> 00:35:46,960
of get pid

1018
00:35:44,880 --> 00:35:48,240
it's using incubator modules which are

1019
00:35:46,960 --> 00:35:49,599
kind of like preview feature but not

1020
00:35:48,240 --> 00:35:51,359
quite

1021
00:35:49,599 --> 00:35:54,160
we got some source files out of it and

1022
00:35:51,359 --> 00:35:54,160
if we look at

1023
00:35:54,400 --> 00:35:59,520
that file that actually looks kind of

1024
00:35:58,320 --> 00:36:01,040
familiar a bunch of the stuff that you

1025
00:35:59,520 --> 00:36:03,440
would find that you find in used unit

1026
00:36:01,040 --> 00:36:06,320
standard dot h including

1027
00:36:03,440 --> 00:36:08,160
get pid right here so forget pid we it

1028
00:36:06,320 --> 00:36:10,000
it defines a method handle

1029
00:36:08,160 --> 00:36:11,200
which can be useful more importantly it

1030
00:36:10,000 --> 00:36:13,920
defines

1031
00:36:11,200 --> 00:36:15,839
a static get bit method that goes and

1032
00:36:13,920 --> 00:36:19,040
invokes some runtime machinery

1033
00:36:15,839 --> 00:36:22,799
to actually cause this cause of this

1034
00:36:19,040 --> 00:36:22,800
call to take place

1035
00:36:23,280 --> 00:36:28,720
all right sure the other

1036
00:36:26,560 --> 00:36:31,520
build here yep built a couple of days

1037
00:36:28,720 --> 00:36:32,560
ago uh with a last-minute fix from ritio

1038
00:36:31,520 --> 00:36:37,280
thank you

1039
00:36:32,560 --> 00:36:37,279
uh let me run actually first i need to

1040
00:36:38,839 --> 00:36:41,839
compile

1041
00:36:43,119 --> 00:36:46,000
and since this is an incubator module i

1042
00:36:44,720 --> 00:36:48,879
have to add it explicitly it's not

1043
00:36:46,000 --> 00:36:48,880
included by default

1044
00:36:50,160 --> 00:36:53,920
so i compile that's the stuff in

1045
00:36:52,000 --> 00:36:54,960
gensource i get some classes out of it

1046
00:36:53,920 --> 00:36:56,880
and now

1047
00:36:54,960 --> 00:36:58,800
i will use the source file launcher one

1048
00:36:56,880 --> 00:37:01,680
of the undersung features of the

1049
00:36:58,800 --> 00:37:01,680
platform these days

1050
00:37:06,839 --> 00:37:09,839
foreign um

1051
00:37:14,640 --> 00:37:17,759
ah but first i should show you get

1052
00:37:16,320 --> 00:37:23,040
pid.java

1053
00:37:17,760 --> 00:37:26,000
that would be brilliant

1054
00:37:23,040 --> 00:37:27,040
it's really simple it invokes unit

1055
00:37:26,000 --> 00:37:29,839
standard dot h

1056
00:37:27,040 --> 00:37:30,320
get pid boom done and for reference

1057
00:37:29,839 --> 00:37:32,560
we'll

1058
00:37:30,320 --> 00:37:34,000
use the actual java api to print out the

1059
00:37:32,560 --> 00:37:37,119
process id we run this

1060
00:37:34,000 --> 00:37:38,400
and what happens boom it gets the

1061
00:37:37,119 --> 00:37:40,079
process id

1062
00:37:38,400 --> 00:37:42,079
that was so much easier than jay and i

1063
00:37:40,079 --> 00:37:44,400
yay

1064
00:37:42,079 --> 00:37:44,400
okay

1065
00:37:45,119 --> 00:37:50,560
so that's panama how much time do i have

1066
00:37:48,839 --> 00:37:53,599
left

1067
00:37:50,560 --> 00:37:57,680
about a minute saying thank you let's

1068
00:37:53,599 --> 00:38:00,160
move on finally to valhalla

1069
00:37:57,680 --> 00:38:01,200
value types and specialized generics

1070
00:38:00,160 --> 00:38:06,319
valhalla is

1071
00:38:01,200 --> 00:38:06,319
is motivated by this

1072
00:38:06,480 --> 00:38:11,200
25 years ago processors come coming at

1073
00:38:10,160 --> 00:38:13,759
the time

1074
00:38:11,200 --> 00:38:14,879
had maybe one level of cash and if you

1075
00:38:13,760 --> 00:38:17,040
missed in that cash

1076
00:38:14,880 --> 00:38:18,160
the penalty might be 100 a couple

1077
00:38:17,040 --> 00:38:20,640
hundred instructions

1078
00:38:18,160 --> 00:38:21,200
no big deal right modern processors

1079
00:38:20,640 --> 00:38:24,000
including

1080
00:38:21,200 --> 00:38:24,319
the processor in this laptop uh have

1081
00:38:24,000 --> 00:38:26,000
like

1082
00:38:24,320 --> 00:38:27,839
three levels of caches and if you miss

1083
00:38:26,000 --> 00:38:28,800
in the third level cache you're probably

1084
00:38:27,839 --> 00:38:31,200
gonna

1085
00:38:28,800 --> 00:38:32,079
your processors are gonna sit around for

1086
00:38:31,200 --> 00:38:34,720
a couple thousand

1087
00:38:32,079 --> 00:38:37,359
instruction cycles waiting for that cash

1088
00:38:34,720 --> 00:38:40,319
miss to be serviced

1089
00:38:37,359 --> 00:38:41,200
so the cost of a cash has has increased

1090
00:38:40,320 --> 00:38:43,280
significantly

1091
00:38:41,200 --> 00:38:44,960
why why does that matter to java well

1092
00:38:43,280 --> 00:38:46,079
java as we all know object-oriented

1093
00:38:44,960 --> 00:38:46,800
language right what do you get an

1094
00:38:46,079 --> 00:38:48,480
object-oriented

1095
00:38:46,800 --> 00:38:49,839
oriented language you get pointers you

1096
00:38:48,480 --> 00:38:51,280
get objects and

1097
00:38:49,839 --> 00:38:53,359
objects contain pointers to other

1098
00:38:51,280 --> 00:38:55,040
objects and you you follow

1099
00:38:53,359 --> 00:38:56,400
a pointer from one object to the next to

1100
00:38:55,040 --> 00:38:57,359
another and another pointer from to

1101
00:38:56,400 --> 00:38:59,200
another object

1102
00:38:57,359 --> 00:39:00,560
you do that enough times eventually you

1103
00:38:59,200 --> 00:39:02,640
will blow out your cash

1104
00:39:00,560 --> 00:39:03,599
uh and you know basically you know cash

1105
00:39:02,640 --> 00:39:04,960
misses

1106
00:39:03,599 --> 00:39:06,480
lead to slow performance and slow

1107
00:39:04,960 --> 00:39:07,119
performance leads to pain and pain leads

1108
00:39:06,480 --> 00:39:10,720
to suffering

1109
00:39:07,119 --> 00:39:12,320
and we know that um so

1110
00:39:10,720 --> 00:39:13,598
chasing all those pointers is costly

1111
00:39:12,320 --> 00:39:14,000
there are some one of the reason there

1112
00:39:13,599 --> 00:39:16,240
are so many

1113
00:39:14,000 --> 00:39:17,200
pointers in java is because every java

1114
00:39:16,240 --> 00:39:19,118
object has

1115
00:39:17,200 --> 00:39:21,680
identity right you can always

1116
00:39:19,119 --> 00:39:23,599
distinguish

1117
00:39:21,680 --> 00:39:25,359
one object from another which is

1118
00:39:23,599 --> 00:39:26,880
generally a good thing every object has

1119
00:39:25,359 --> 00:39:28,480
state every object has

1120
00:39:26,880 --> 00:39:30,640
potentially a synchronization monitor

1121
00:39:28,480 --> 00:39:33,920
you can synchronize on any object

1122
00:39:30,640 --> 00:39:36,319
why well because um

1123
00:39:33,920 --> 00:39:37,280
how useful is that far from clear but

1124
00:39:36,320 --> 00:39:39,680
you can

1125
00:39:37,280 --> 00:39:41,280
um so this this gets really painful

1126
00:39:39,680 --> 00:39:42,720
especially when you've got tons of data

1127
00:39:41,280 --> 00:39:43,440
like in like in a big data app or

1128
00:39:42,720 --> 00:39:45,279
something

1129
00:39:43,440 --> 00:39:47,520
so we think the missing abstraction here

1130
00:39:45,280 --> 00:39:48,640
is is is what we call value types or

1131
00:39:47,520 --> 00:39:51,759
inline types that's the

1132
00:39:48,640 --> 00:39:54,720
the ability to declare pure

1133
00:39:51,760 --> 00:39:56,560
data aggregators that don't need to have

1134
00:39:54,720 --> 00:39:59,040
identity but still consider them

1135
00:39:56,560 --> 00:39:59,920
as being defined by by a job class as

1136
00:39:59,040 --> 00:40:01,279
john rose likes to

1137
00:39:59,920 --> 00:40:03,839
like say if we get this right you'll be

1138
00:40:01,280 --> 00:40:06,079
able to code like a class but it'll work

1139
00:40:03,839 --> 00:40:07,520
like an int and that enables you know

1140
00:40:06,079 --> 00:40:09,680
cool stuff like allocation

1141
00:40:07,520 --> 00:40:10,960
you can allocate an object in in

1142
00:40:09,680 --> 00:40:12,399
processor registers and if it never

1143
00:40:10,960 --> 00:40:14,400
needs to hit the heap it'll never

1144
00:40:12,400 --> 00:40:15,760
hit the heap but it'll still work mostly

1145
00:40:14,400 --> 00:40:17,280
like an object and

1146
00:40:15,760 --> 00:40:18,800
furthermore data structures can be

1147
00:40:17,280 --> 00:40:21,920
flattened

1148
00:40:18,800 --> 00:40:22,480
and that reduces pointers so quick

1149
00:40:21,920 --> 00:40:25,200
example

1150
00:40:22,480 --> 00:40:27,440
let's multiply some matrices what one

1151
00:40:25,200 --> 00:40:27,439
does

1152
00:40:29,680 --> 00:40:32,240
all right

1153
00:40:33,440 --> 00:40:40,480
source main java valhalla we've got a

1154
00:40:37,200 --> 00:40:42,319
complex class woohoo someday

1155
00:40:40,480 --> 00:40:43,599
i i wanted to write this as a record

1156
00:40:42,319 --> 00:40:44,960
obvious thing right but records aren't

1157
00:40:43,599 --> 00:40:45,599
yet in the valhalla repo they'll be

1158
00:40:44,960 --> 00:40:48,720
merged

1159
00:40:45,599 --> 00:40:51,119
probably sometime soon complex class has

1160
00:40:48,720 --> 00:40:52,560
real and imaginary you can add them you

1161
00:40:51,119 --> 00:40:58,240
can multiply them

1162
00:40:52,560 --> 00:40:58,240
and so forth the actual benchmark here

1163
00:40:59,040 --> 00:41:02,800
whoops standard cubic algorithm for

1164
00:41:01,920 --> 00:41:04,240
multiplying

1165
00:41:02,800 --> 00:41:05,920
you know wrote you go down the root the

1166
00:41:04,240 --> 00:41:07,839
rows and the columns pointwise

1167
00:41:05,920 --> 00:41:10,240
multiplication addition you get to get

1168
00:41:07,839 --> 00:41:13,119
the result matrix

1169
00:41:10,240 --> 00:41:15,359
and this is structured as a java micro

1170
00:41:13,119 --> 00:41:16,640
benchmark harness using alexis shiplabs

1171
00:41:15,359 --> 00:41:19,598
very fine tools so there are some

1172
00:41:16,640 --> 00:41:23,040
annotations telling it what to do

1173
00:41:19,599 --> 00:41:23,040
let me run this now

1174
00:41:24,240 --> 00:41:30,240
with you know you're just using using

1175
00:41:27,839 --> 00:41:30,880
normal normal normal java code nothing

1176
00:41:30,240 --> 00:41:33,759
special

1177
00:41:30,880 --> 00:41:35,599
going on here i'm going to multiply some

1178
00:41:33,760 --> 00:41:38,560
matrices together

1179
00:41:35,599 --> 00:41:41,520
james will measure them we do some

1180
00:41:38,560 --> 00:41:41,520
warm-up iterations

1181
00:41:46,480 --> 00:41:49,680
yes i should have done that

1182
00:41:54,560 --> 00:41:57,680
so it's multiplying matrices here but uh

1183
00:41:57,119 --> 00:41:59,680
this

1184
00:41:57,680 --> 00:42:02,799
my laptop's not working very hard you

1185
00:41:59,680 --> 00:42:07,040
can't really hear a fan or anything

1186
00:42:02,800 --> 00:42:08,400
silence right so deathly silence

1187
00:42:07,040 --> 00:42:16,880
there's a reason for that which we'll

1188
00:42:08,400 --> 00:42:19,760
see in a moment

1189
00:42:16,880 --> 00:42:22,560
okay let's uh whoops go back into emacs

1190
00:42:19,760 --> 00:42:22,560
and look at that log

1191
00:42:22,800 --> 00:42:27,440
okay at the top of this log we have the

1192
00:42:24,640 --> 00:42:30,799
usual warning from from alexei

1193
00:42:27,440 --> 00:42:32,800
think hard about your numbers don't

1194
00:42:30,800 --> 00:42:35,760
don't want to make stupid conclusions so

1195
00:42:32,800 --> 00:42:38,640
multiplying we are

1196
00:42:35,760 --> 00:42:38,640
clocking in at

1197
00:42:41,160 --> 00:42:45,598
1133 milliseconds per

1198
00:42:43,760 --> 00:42:49,200
multiply each one of those

1199
00:42:45,599 --> 00:42:51,520
multiplication operations is allocating

1200
00:42:49,200 --> 00:42:51,520
whoops

1201
00:42:54,319 --> 00:42:58,319
almost two gigabytes because it's making

1202
00:42:56,960 --> 00:42:59,040
a lot of complex numbers and those are

1203
00:42:58,319 --> 00:43:02,319
read-only

1204
00:42:59,040 --> 00:43:02,960
objects and there are arrays and arrays

1205
00:43:02,319 --> 00:43:04,640
and

1206
00:43:02,960 --> 00:43:07,119
arrays pointing to arrays and and those

1207
00:43:04,640 --> 00:43:09,118
arrays are pointing to complex objects

1208
00:43:07,119 --> 00:43:10,400
and instructions per cycle very very

1209
00:43:09,119 --> 00:43:12,480
interesting metric

1210
00:43:10,400 --> 00:43:14,240
is is barely over one so the processor

1211
00:43:12,480 --> 00:43:16,000
in this machine is is is an intel

1212
00:43:14,240 --> 00:43:17,279
skylake it's it's capable theoretically

1213
00:43:16,000 --> 00:43:19,200
of retiring four

1214
00:43:17,280 --> 00:43:20,640
instructions per cycle but the processor

1215
00:43:19,200 --> 00:43:21,200
is spending most of its time waiting

1216
00:43:20,640 --> 00:43:22,799
around from

1217
00:43:21,200 --> 00:43:24,720
the memory subsystem so it's only

1218
00:43:22,800 --> 00:43:26,319
retiring a little over one instruction

1219
00:43:24,720 --> 00:43:28,078
per cycle

1220
00:43:26,319 --> 00:43:30,079
go back to the complex class and one and

1221
00:43:28,079 --> 00:43:30,880
make one very simple change public

1222
00:43:30,079 --> 00:43:33,760
inline

1223
00:43:30,880 --> 00:43:35,440
class complex so this is now an inline

1224
00:43:33,760 --> 00:43:36,480
class what formerly was called a value

1225
00:43:35,440 --> 00:43:38,319
type which means

1226
00:43:36,480 --> 00:43:39,440
when you have an array of them rather

1227
00:43:38,319 --> 00:43:41,040
than having an array of pointers to

1228
00:43:39,440 --> 00:43:44,560
complex objects you have an array

1229
00:43:41,040 --> 00:43:45,200
of complex numbers all represented in

1230
00:43:44,560 --> 00:43:46,960
that array

1231
00:43:45,200 --> 00:43:48,240
as any real and imaginary pairs right

1232
00:43:46,960 --> 00:43:52,000
there with no pointer

1233
00:43:48,240 --> 00:43:52,000
to chase we'll run this again

1234
00:43:52,640 --> 00:43:57,200
now remember the number from last time

1235
00:43:54,160 --> 00:44:00,000
was a bit over a thousand microseconds

1236
00:43:57,200 --> 00:44:00,000
per multiply

1237
00:44:01,760 --> 00:44:08,160
now we're down to about a tenth of that

1238
00:44:06,240 --> 00:44:09,919
i mean this is the warm-up iterations

1239
00:44:08,160 --> 00:44:13,200
but um

1240
00:44:09,920 --> 00:44:13,200
you can see it's quite a bit faster

1241
00:44:13,520 --> 00:44:17,839
and as this progresses the cpu is

1242
00:44:16,640 --> 00:44:20,560
working harder as we can tell by

1243
00:44:17,839 --> 00:44:23,839
listening to the fan

1244
00:44:20,560 --> 00:44:23,839
you hear that

1245
00:44:27,359 --> 00:44:32,240
so it's not wasting as much time in the

1246
00:44:29,520 --> 00:44:37,359
memory subsystem

1247
00:44:32,240 --> 00:44:42,160
and i am now out oh die one minute

1248
00:44:37,359 --> 00:44:42,160
let's just do the quickie log thing

1249
00:44:42,880 --> 00:44:50,400
we go to the end here's our time

1250
00:44:46,560 --> 00:44:52,480
132 instructions per cycle

1251
00:44:50,400 --> 00:44:53,839
we're getting two and a half quite a bit

1252
00:44:52,480 --> 00:44:55,800
better and if we do a quick division

1253
00:44:53,839 --> 00:44:58,799
here

1254
00:44:55,800 --> 00:44:58,800
132

1255
00:44:59,119 --> 00:45:02,160
eight eight and a half times faster not

1256
00:45:00,880 --> 00:45:05,680
bad

1257
00:45:02,160 --> 00:45:07,118
okay so that's features

1258
00:45:05,680 --> 00:45:10,560
you can get builds for mip for many of

1259
00:45:07,119 --> 00:45:12,880
these things uh at jdk.java.net

1260
00:45:10,560 --> 00:45:14,720
so please you know do test them out

1261
00:45:12,880 --> 00:45:19,839
don't believe we're a word i've said

1262
00:45:14,720 --> 00:45:19,839
and thank you very much

1263
00:45:24,800 --> 00:45:26,880
you

