1
00:00:05,359 --> 00:00:08,480
so our next speaker is josh moorman who

2
00:00:07,440 --> 00:00:10,240
is filling in for

3
00:00:08,480 --> 00:00:12,320
someone who couldn't make it or we had

4
00:00:10,240 --> 00:00:14,639
to swap around

5
00:00:12,320 --> 00:00:17,119
and he is going to talk to us about

6
00:00:14,639 --> 00:00:19,759
channel equalization using gnu radio

7
00:00:17,119 --> 00:00:22,720
all right good morning everyone my name

8
00:00:19,760 --> 00:00:24,800
is josh moorman i am

9
00:00:22,720 --> 00:00:26,880
from united states i work for a applied

10
00:00:24,800 --> 00:00:28,480
research organization prospecta labs

11
00:00:26,880 --> 00:00:30,240
i'm also one of the project officers

12
00:00:28,480 --> 00:00:32,480
canoe radio

13
00:00:30,240 --> 00:00:34,160
and motivation for this work found

14
00:00:32,479 --> 00:00:36,160
myself on a few projects where we needed

15
00:00:34,160 --> 00:00:39,360
equalizers

16
00:00:36,160 --> 00:00:40,800
gnu radio has some existing equalizers

17
00:00:39,360 --> 00:00:42,960
you know if you dig through you find

18
00:00:40,800 --> 00:00:44,160
them in the block tree

19
00:00:42,960 --> 00:00:46,239
but they're they're missing some

20
00:00:44,160 --> 00:00:49,360
features that i needed um

21
00:00:46,239 --> 00:00:50,320
so needed to go in and um add some

22
00:00:49,360 --> 00:00:52,480
functionality

23
00:00:50,320 --> 00:00:53,600
namely need to equalize on training

24
00:00:52,480 --> 00:00:55,360
sequences

25
00:00:53,600 --> 00:00:57,760
so these are all these are all blind

26
00:00:55,360 --> 00:01:00,079
equalizers

27
00:00:57,760 --> 00:01:01,280
and expand the available adaptive

28
00:01:00,079 --> 00:01:03,680
algorithms

29
00:01:01,280 --> 00:01:04,720
um and in restructure a bit so we'll

30
00:01:03,680 --> 00:01:07,360
talk through

31
00:01:04,720 --> 00:01:09,439
i think i swapped this slide so we're

32
00:01:07,360 --> 00:01:12,880
going to go through and talk through

33
00:01:09,439 --> 00:01:14,158
why do you need equalization um talk a

34
00:01:12,880 --> 00:01:15,360
little bit about the theory of

35
00:01:14,159 --> 00:01:17,200
equalization

36
00:01:15,360 --> 00:01:18,960
um and then different types of

37
00:01:17,200 --> 00:01:21,520
equalizers what are the structures

38
00:01:18,960 --> 00:01:22,960
why are they different um why would we

39
00:01:21,520 --> 00:01:24,080
need different structures and then

40
00:01:22,960 --> 00:01:27,839
we'll get into the new radio

41
00:01:24,080 --> 00:01:27,840
implementation of this

42
00:01:28,640 --> 00:01:33,759
all right so all the all the code is is

43
00:01:31,360 --> 00:01:37,039
posted up on github here

44
00:01:33,759 --> 00:01:39,040
there's one dependency so

45
00:01:37,040 --> 00:01:40,560
if you run cmake it'll find it doesn't

46
00:01:39,040 --> 00:01:43,600
work unless you have this

47
00:01:40,560 --> 00:01:45,040
but uh yeah so grab this and

48
00:01:43,600 --> 00:01:48,079
if you're interested in running these

49
00:01:45,040 --> 00:01:48,079
examples locally

50
00:01:48,720 --> 00:01:52,320
so why do we need equalization so the

51
00:01:51,119 --> 00:01:54,079
main reason

52
00:01:52,320 --> 00:01:55,919
the main reason that your signal gets

53
00:01:54,079 --> 00:01:57,600
messed up and you can

54
00:01:55,920 --> 00:01:59,439
you can recover it better with a good

55
00:01:57,600 --> 00:02:01,919
equalizer is because of

56
00:01:59,439 --> 00:02:02,880
the the wireless channel so if you think

57
00:02:01,920 --> 00:02:05,040
about

58
00:02:02,880 --> 00:02:06,880
your if you're trying to transmit a

59
00:02:05,040 --> 00:02:09,599
signal from point a

60
00:02:06,880 --> 00:02:10,318
to point b you get multiple copies of

61
00:02:09,598 --> 00:02:12,879
that signal

62
00:02:10,318 --> 00:02:14,560
bouncing off things all getting received

63
00:02:12,879 --> 00:02:17,280
so if these are my data symbols

64
00:02:14,560 --> 00:02:17,840
i'm transmitting i'm going to get a copy

65
00:02:17,280 --> 00:02:19,840
and then a

66
00:02:17,840 --> 00:02:22,160
time shifted copy another time shifted

67
00:02:19,840 --> 00:02:23,920
copy much more complex this is some

68
00:02:22,160 --> 00:02:27,200
notional example right

69
00:02:23,920 --> 00:02:28,480
um what that's going to lead to is inner

70
00:02:27,200 --> 00:02:31,440
symbol interference

71
00:02:28,480 --> 00:02:32,799
so you know our nice compact

72
00:02:31,440 --> 00:02:36,079
constellation here

73
00:02:32,800 --> 00:02:38,480
gets all smeared and mixed up with

74
00:02:36,080 --> 00:02:40,800
all the all the adjacent symbols and so

75
00:02:38,480 --> 00:02:42,000
we get this jumbled mess

76
00:02:40,800 --> 00:02:44,319
right so that's what we need an

77
00:02:42,000 --> 00:02:45,920
equalizer to get from here

78
00:02:44,319 --> 00:02:48,319
back to here you know even cleaner

79
00:02:45,920 --> 00:02:49,679
depending on our snr of our receiver at

80
00:02:48,319 --> 00:02:54,399
that point

81
00:02:49,680 --> 00:02:56,080
so all of this has some some time domain

82
00:02:54,400 --> 00:02:58,239
dispersion right this is the time domain

83
00:02:56,080 --> 00:03:00,000
representation of some notional channel

84
00:02:58,239 --> 00:03:02,560
that we've set up it also has a

85
00:03:00,000 --> 00:03:06,000
frequency domain representation

86
00:03:02,560 --> 00:03:09,360
so if your signal is wide band enough

87
00:03:06,000 --> 00:03:10,879
your uh you're going to get peaks and

88
00:03:09,360 --> 00:03:13,440
nulls at different frequencies you're

89
00:03:10,879 --> 00:03:15,200
going to have frequency selective fading

90
00:03:13,440 --> 00:03:17,200
and um you know this this is all just

91
00:03:15,200 --> 00:03:19,920
normalized frequency we don't see

92
00:03:17,200 --> 00:03:21,679
how this exactly relates to symbol rate

93
00:03:19,920 --> 00:03:23,440
and

94
00:03:21,680 --> 00:03:25,200
symbol rate and bandwidth and all that

95
00:03:23,440 --> 00:03:29,200
and then in the time domain you know we

96
00:03:25,200 --> 00:03:29,200
if we transmitted these perfectly square

97
00:03:29,840 --> 00:03:33,840
symbols on the other side across the

98
00:03:32,319 --> 00:03:35,518
channel you know we're going to get all

99
00:03:33,840 --> 00:03:37,200
time dispersed things which you know we

100
00:03:35,519 --> 00:03:39,920
would have some kind of symbol shaping

101
00:03:37,200 --> 00:03:40,958
to begin with here to help with isi so

102
00:03:39,920 --> 00:03:44,159
channel effects

103
00:03:40,959 --> 00:03:47,519
main reason that we need an equalizer

104
00:03:44,159 --> 00:03:50,079
another reason is the hardware filters

105
00:03:47,519 --> 00:03:51,840
um you know even just slight roll-off is

106
00:03:50,080 --> 00:03:52,799
going to cause smearing of one symbol

107
00:03:51,840 --> 00:03:54,319
into the next

108
00:03:52,799 --> 00:03:56,879
so you look at just something with you

109
00:03:54,319 --> 00:04:00,000
know a couple of db on the edge

110
00:03:56,879 --> 00:04:02,000
maybe you have some some received

111
00:04:00,000 --> 00:04:03,360
filter maybe you have some trans you

112
00:04:02,000 --> 00:04:05,920
have some amplifier maybe even some

113
00:04:03,360 --> 00:04:08,080
non-linear things amplifier distortion

114
00:04:05,920 --> 00:04:14,480
um you know it's going to cause smearing

115
00:04:08,080 --> 00:04:16,799
and spread out your constellation so one

116
00:04:14,480 --> 00:04:18,719
one concept we have to keep in mind here

117
00:04:16,798 --> 00:04:22,880
when we're talking about our need for

118
00:04:18,720 --> 00:04:25,360
an equalizer is coherence bandwidth

119
00:04:22,880 --> 00:04:27,199
so if we have so say this is the

120
00:04:25,360 --> 00:04:30,400
response of the channel

121
00:04:27,199 --> 00:04:32,560
over frequency it's only

122
00:04:30,400 --> 00:04:33,840
and we look at these are say these are

123
00:04:32,560 --> 00:04:35,040
two different channels

124
00:04:33,840 --> 00:04:37,679
this top one would be a highly

125
00:04:35,040 --> 00:04:40,800
dispersive channel a very long tail

126
00:04:37,680 --> 00:04:42,800
on the response of the of the taps

127
00:04:40,800 --> 00:04:44,800
on the bottom would be a less dispersive

128
00:04:42,800 --> 00:04:46,880
channel so this would have a wider

129
00:04:44,800 --> 00:04:48,800
coherence bandwidth we can operate

130
00:04:46,880 --> 00:04:51,199
in a wider band without the need for an

131
00:04:48,800 --> 00:04:53,280
equalizer up top

132
00:04:51,199 --> 00:04:54,639
we can't we can barely operate on a very

133
00:04:53,280 --> 00:04:57,440
narrow band signal

134
00:04:54,639 --> 00:04:58,880
without needing some equalization so

135
00:04:57,440 --> 00:04:59,360
this is really the problem we're looking

136
00:04:58,880 --> 00:05:02,639
at

137
00:04:59,360 --> 00:05:04,320
in this in this presentation is single

138
00:05:02,639 --> 00:05:05,680
carrier wide band signals

139
00:05:04,320 --> 00:05:07,759
and how are we going to equalize for

140
00:05:05,680 --> 00:05:09,600
those we want we want to be able to

141
00:05:07,759 --> 00:05:13,199
operate over this whole band and

142
00:05:09,600 --> 00:05:13,199
equalize for all this mess

143
00:05:17,039 --> 00:05:21,360
all right so the basic signal model

144
00:05:19,840 --> 00:05:25,198
we're going to be looking at

145
00:05:21,360 --> 00:05:27,039
is if we we've transmitted a signal

146
00:05:25,199 --> 00:05:29,280
our our channel model is going to be the

147
00:05:27,039 --> 00:05:31,039
combination of our filter effects and

148
00:05:29,280 --> 00:05:33,119
our channel effects

149
00:05:31,039 --> 00:05:35,759
there's going to be some additive white

150
00:05:33,120 --> 00:05:38,320
noise out of gaussian white noise at the

151
00:05:35,759 --> 00:05:40,080
receiver and then this u of n is what

152
00:05:38,320 --> 00:05:42,240
we're going to receive

153
00:05:40,080 --> 00:05:44,000
so just a simple convolutional channel

154
00:05:42,240 --> 00:05:46,960
model we're going to assume linear time

155
00:05:44,000 --> 00:05:49,039
and variance at this point as well

156
00:05:46,960 --> 00:05:50,560
just so we want to be able to observe it

157
00:05:49,039 --> 00:05:52,159
over a period of time

158
00:05:50,560 --> 00:05:54,560
and then counteract the effects of the

159
00:05:52,160 --> 00:05:56,560
channel and not not worry

160
00:05:54,560 --> 00:05:59,919
just yet about tracking it and time

161
00:05:56,560 --> 00:05:59,919
varying aspects of the channel

162
00:06:02,479 --> 00:06:05,840
so in theory what we should be able to

163
00:06:05,120 --> 00:06:07,919
do

164
00:06:05,840 --> 00:06:10,960
is we receive some signals that have

165
00:06:07,919 --> 00:06:12,960
been modified by the channel

166
00:06:10,960 --> 00:06:14,318
with some noise we should be able to

167
00:06:12,960 --> 00:06:16,799
just inverse that channel

168
00:06:14,319 --> 00:06:18,240
we're done not quite that easy this is

169
00:06:16,800 --> 00:06:19,440
what we would call a zero forcing

170
00:06:18,240 --> 00:06:22,800
equalizer

171
00:06:19,440 --> 00:06:25,360
and the problem is that first we have to

172
00:06:22,800 --> 00:06:27,680
come up with an estimate of this channel

173
00:06:25,360 --> 00:06:28,880
right and once we come up with an

174
00:06:27,680 --> 00:06:31,520
estimate of this channel

175
00:06:28,880 --> 00:06:32,560
it's a finite response estimate to

176
00:06:31,520 --> 00:06:36,639
really an infinite

177
00:06:32,560 --> 00:06:38,319
um an infinite channel response

178
00:06:36,639 --> 00:06:39,680
and then so we truncate it there and

179
00:06:38,319 --> 00:06:41,039
then we have to invert it so we're

180
00:06:39,680 --> 00:06:43,280
taking something finite

181
00:06:41,039 --> 00:06:44,560
inverting it and another estimation it's

182
00:06:43,280 --> 00:06:45,679
just not going to do a good

183
00:06:44,560 --> 00:06:47,199
approximation

184
00:06:45,680 --> 00:06:48,960
to minimize the error we're trying to

185
00:06:47,199 --> 00:06:50,720
minimize

186
00:06:48,960 --> 00:06:52,479
because this is also our problem too we

187
00:06:50,720 --> 00:06:56,319
have additive noise

188
00:06:52,479 --> 00:06:58,479
so once we do this we're not

189
00:06:56,319 --> 00:07:00,240
we're not inverting the channel in a way

190
00:06:58,479 --> 00:07:02,880
that's going to minimize the noise

191
00:07:00,240 --> 00:07:04,720
as well so zero forcing filters they

192
00:07:02,880 --> 00:07:08,080
don't work great in practice on

193
00:07:04,720 --> 00:07:11,520
on single carrier signals um

194
00:07:08,080 --> 00:07:14,719
so we need another criteria and

195
00:07:11,520 --> 00:07:17,599
you can you can the optimal way

196
00:07:14,720 --> 00:07:19,440
to back out of your channel response is

197
00:07:17,599 --> 00:07:21,759
through a maximum likelihood

198
00:07:19,440 --> 00:07:23,840
sequence estimation you know you do that

199
00:07:21,759 --> 00:07:26,400
by tracing what you receive

200
00:07:23,840 --> 00:07:27,280
through the trellis of possible states

201
00:07:26,400 --> 00:07:29,440
and then you

202
00:07:27,280 --> 00:07:31,679
use the viterbi algorithm to find that

203
00:07:29,440 --> 00:07:34,160
maximum likelihood sequence

204
00:07:31,680 --> 00:07:34,800
that's very computationally intensive

205
00:07:34,160 --> 00:07:37,599
you know not

206
00:07:34,800 --> 00:07:38,880
for um you know it's probably not

207
00:07:37,599 --> 00:07:41,120
something you would do in practice

208
00:07:38,880 --> 00:07:42,560
necessarily

209
00:07:41,120 --> 00:07:44,319
so what we want to do is we want to look

210
00:07:42,560 --> 00:07:47,919
at the minimum mean squared

211
00:07:44,319 --> 00:07:50,800
error criteria for this problem

212
00:07:47,919 --> 00:07:53,039
so what we want to do is if if we say we

213
00:07:50,800 --> 00:07:55,840
want to create this filter w

214
00:07:53,039 --> 00:07:58,560
so this this filter w is basically what

215
00:07:55,840 --> 00:07:58,560
we want to

216
00:07:59,360 --> 00:08:02,879
what we want to come up as the inverse

217
00:08:01,039 --> 00:08:03,680
of our channel right we want to come up

218
00:08:02,879 --> 00:08:05,440
with a w

219
00:08:03,680 --> 00:08:08,639
such that it does the best job of

220
00:08:05,440 --> 00:08:08,639
recovering these symbols

221
00:08:08,879 --> 00:08:12,319
so if w is the filter taps we're going

222
00:08:10,720 --> 00:08:15,919
after then the error

223
00:08:12,319 --> 00:08:18,000
is the original symbols we sent minus

224
00:08:15,919 --> 00:08:19,120
that filter convolved with our received

225
00:08:18,000 --> 00:08:20,720
signal

226
00:08:19,120 --> 00:08:22,639
so that's that's the error we're trying

227
00:08:20,720 --> 00:08:24,240
to minimize so if we set up a cost

228
00:08:22,639 --> 00:08:25,840
function here

229
00:08:24,240 --> 00:08:28,479
what we want to do is we want to find

230
00:08:25,840 --> 00:08:31,119
the minimum of that cost function

231
00:08:28,479 --> 00:08:32,399
and so dot dot dot we get down to the

232
00:08:31,120 --> 00:08:35,919
answer

233
00:08:32,399 --> 00:08:38,240
which is which is the covariance of our

234
00:08:35,919 --> 00:08:40,240
signal

235
00:08:38,240 --> 00:08:41,519
the cross correlation of our signal with

236
00:08:40,240 --> 00:08:44,640
our data symbols

237
00:08:41,519 --> 00:08:46,080
that's p and so the inverse of our our

238
00:08:44,640 --> 00:08:48,160
covariance matrix

239
00:08:46,080 --> 00:08:49,760
um multiplied by this this is our

240
00:08:48,160 --> 00:08:51,760
optimum mmsv filter

241
00:08:49,760 --> 00:08:53,839
and that's obtained by finding the

242
00:08:51,760 --> 00:08:55,920
gradient of our cost function

243
00:08:53,839 --> 00:08:57,120
figuring out where it's set to zero and

244
00:08:55,920 --> 00:08:59,839
finding the minimum

245
00:08:57,120 --> 00:09:00,480
so this is a this is a static solution

246
00:08:59,839 --> 00:09:03,120
to the min

247
00:09:00,480 --> 00:09:05,120
to the mmse equation um we'll get into

248
00:09:03,120 --> 00:09:06,399
adaptive algorithms that are going to be

249
00:09:05,120 --> 00:09:09,279
able to track

250
00:09:06,399 --> 00:09:10,720
track this as your channel moves you

251
00:09:09,279 --> 00:09:11,760
know as people move around in your

252
00:09:10,720 --> 00:09:13,600
environment your

253
00:09:11,760 --> 00:09:15,519
your transmitter your receiver move

254
00:09:13,600 --> 00:09:15,920
around you know we need to track that

255
00:09:15,519 --> 00:09:18,560
and keep

256
00:09:15,920 --> 00:09:19,519
up with the optimal filter at any point

257
00:09:18,560 --> 00:09:21,199
in time

258
00:09:19,519 --> 00:09:23,519
so but right now we're just look at one

259
00:09:21,200 --> 00:09:25,040
point in time we can find the best

260
00:09:23,519 --> 00:09:28,240
filter taps that are going to

261
00:09:25,040 --> 00:09:30,640
get rid of the channel effects

262
00:09:28,240 --> 00:09:31,680
so the structure so this is this is the

263
00:09:30,640 --> 00:09:33,519
structure that exists

264
00:09:31,680 --> 00:09:34,719
in the goody radio box currently and

265
00:09:33,519 --> 00:09:37,200
this is this um

266
00:09:34,720 --> 00:09:38,080
they're linear equalizers so linear

267
00:09:37,200 --> 00:09:39,920
equalizer

268
00:09:38,080 --> 00:09:41,440
it's going to be our received signal

269
00:09:39,920 --> 00:09:44,640
pass through some filter

270
00:09:41,440 --> 00:09:46,399
that gets updated in some way so just an

271
00:09:44,640 --> 00:09:49,040
fir filter

272
00:09:46,399 --> 00:09:50,640
we come up with some estimate of the

273
00:09:49,040 --> 00:09:51,040
receive signal after we've gone through

274
00:09:50,640 --> 00:09:54,080
this

275
00:09:51,040 --> 00:09:57,839
this filter and then we calculate error

276
00:09:54,080 --> 00:10:00,160
the error and the received signal are

277
00:09:57,839 --> 00:10:02,320
somehow used to update this

278
00:10:00,160 --> 00:10:05,199
filter so we'll talk about we'll talk

279
00:10:02,320 --> 00:10:05,600
about how this these adaptive algorithms

280
00:10:05,200 --> 00:10:07,920
more

281
00:10:05,600 --> 00:10:09,200
in a minute but for right now the

282
00:10:07,920 --> 00:10:11,680
general structure is just

283
00:10:09,200 --> 00:10:13,680
fir filter fir filter we're going to

284
00:10:11,680 --> 00:10:15,920
update the taps based on our calculated

285
00:10:13,680 --> 00:10:18,719
error

286
00:10:15,920 --> 00:10:20,880
so there's one more variation that we

287
00:10:18,720 --> 00:10:22,560
haven't talked about decision directed

288
00:10:20,880 --> 00:10:24,079
so all the current equalizers in gnu

289
00:10:22,560 --> 00:10:25,439
radio are decision directed

290
00:10:24,079 --> 00:10:27,760
they don't know anything about the

291
00:10:25,440 --> 00:10:29,200
training sequence um so they make some

292
00:10:27,760 --> 00:10:32,319
estimate they say

293
00:10:29,200 --> 00:10:34,480
okay you know i was i was expecting a

294
00:10:32,320 --> 00:10:37,920
qpsk constellation

295
00:10:34,480 --> 00:10:39,839
this um this symbol i just received was

296
00:10:37,920 --> 00:10:41,199
closest to this constellation point so

297
00:10:39,839 --> 00:10:43,760
i'm going to assume that

298
00:10:41,200 --> 00:10:45,200
so that's pretty good in high snr

299
00:10:43,760 --> 00:10:47,519
environments

300
00:10:45,200 --> 00:10:49,600
when you get into lower snr that's not

301
00:10:47,519 --> 00:10:51,600
good and your decision-directed

302
00:10:49,600 --> 00:10:53,120
equalizer is just adding tons of noise

303
00:10:51,600 --> 00:10:56,000
back into the error signal

304
00:10:53,120 --> 00:10:56,000
and it just won't work

305
00:10:58,720 --> 00:11:04,079
so another uh varying structure

306
00:11:02,160 --> 00:11:05,600
of of the equalizer is the decision

307
00:11:04,079 --> 00:11:08,079
feedback equalizer

308
00:11:05,600 --> 00:11:09,519
so if you if you notice the first part

309
00:11:08,079 --> 00:11:12,479
of this looks just like the

310
00:11:09,519 --> 00:11:13,680
the linear equalizer we have a feed

311
00:11:12,480 --> 00:11:16,399
forward

312
00:11:13,680 --> 00:11:18,239
fir filter we have an adaptive algorithm

313
00:11:16,399 --> 00:11:21,200
that's going to set these taps

314
00:11:18,240 --> 00:11:21,440
but there's this feedback step so what

315
00:11:21,200 --> 00:11:23,200
the

316
00:11:21,440 --> 00:11:24,560
what the decision feedback equalizer

317
00:11:23,200 --> 00:11:28,399
assumes is that

318
00:11:24,560 --> 00:11:30,640
not all of the inner symbol interference

319
00:11:28,399 --> 00:11:32,240
is going to be canceled by this filter

320
00:11:30,640 --> 00:11:35,519
some is going to

321
00:11:32,240 --> 00:11:38,880
bleed into the past

322
00:11:35,519 --> 00:11:39,760
past and future symbols and so what we

323
00:11:38,880 --> 00:11:42,959
do here

324
00:11:39,760 --> 00:11:44,399
is we go ahead and make simple decisions

325
00:11:42,959 --> 00:11:46,000
you know as you normally would in your

326
00:11:44,399 --> 00:11:48,800
receiver but then

327
00:11:46,000 --> 00:11:49,839
use those symbol decisions as another

328
00:11:48,800 --> 00:11:53,040
filter

329
00:11:49,839 --> 00:11:55,440
that's going to feed into the um

330
00:11:53,040 --> 00:11:58,240
the output of this is going to feed back

331
00:11:55,440 --> 00:12:00,560
into your symbol slicer

332
00:11:58,240 --> 00:12:01,600
so now what it what a feedback equalizer

333
00:12:00,560 --> 00:12:03,518
is able to do

334
00:12:01,600 --> 00:12:05,519
if you have a highly non-linear channel

335
00:12:03,519 --> 00:12:07,120
this is a non-linear structure

336
00:12:05,519 --> 00:12:09,040
so that's that's one situation where you

337
00:12:07,120 --> 00:12:13,279
need a dfe

338
00:12:09,040 --> 00:12:15,439
um another is that linear equalizers

339
00:12:13,279 --> 00:12:17,360
if you have very strong nulls in your

340
00:12:15,440 --> 00:12:20,720
frequency response

341
00:12:17,360 --> 00:12:23,279
the linear equalizer can

342
00:12:20,720 --> 00:12:24,800
enhance those those null the noise in

343
00:12:23,279 --> 00:12:28,079
those spots

344
00:12:24,800 --> 00:12:29,279
and and so you get very a very noisy

345
00:12:28,079 --> 00:12:31,040
equalized signal

346
00:12:29,279 --> 00:12:33,279
so we'll see some examples of that later

347
00:12:31,040 --> 00:12:33,279
on

348
00:12:34,079 --> 00:12:37,120
all right so the current the current gnu

349
00:12:36,079 --> 00:12:39,839
radio blocks

350
00:12:37,120 --> 00:12:40,560
they work they're they're um these were

351
00:12:39,839 --> 00:12:42,959
the basis

352
00:12:40,560 --> 00:12:44,880
of this development was you know the cma

353
00:12:42,959 --> 00:12:46,079
block in this lms block structurally

354
00:12:44,880 --> 00:12:49,360
very similar

355
00:12:46,079 --> 00:12:51,760
um they're each just an fir with an

356
00:12:49,360 --> 00:12:55,040
adaptive algorithm to update the

357
00:12:51,760 --> 00:12:56,639
um but you know there this one

358
00:12:55,040 --> 00:12:57,839
i just thought this was funny and can

359
00:12:56,639 --> 00:12:59,519
you read it there's actually a comment

360
00:12:57,839 --> 00:13:01,120
in the code that said

361
00:12:59,519 --> 00:13:02,800
if this doesn't work i don't know if it

362
00:13:01,120 --> 00:13:04,399
works so um

363
00:13:02,800 --> 00:13:07,839
it was obviously a part of the code that

364
00:13:04,399 --> 00:13:07,839
needed some love here

365
00:13:10,079 --> 00:13:13,680
so another another issue with the

366
00:13:11,760 --> 00:13:17,200
existing gnu radio blocks

367
00:13:13,680 --> 00:13:19,599
is that the adaptive algorithm

368
00:13:17,200 --> 00:13:20,560
is baked into the block itself so one of

369
00:13:19,600 --> 00:13:21,680
the themes

370
00:13:20,560 --> 00:13:23,040
that you know that we talked about at

371
00:13:21,680 --> 00:13:24,239
the hack fest that you probably hear

372
00:13:23,040 --> 00:13:26,959
marcus talk about

373
00:13:24,240 --> 00:13:29,600
is modularity in gnu radio and one of

374
00:13:26,959 --> 00:13:33,599
the things that we want to

375
00:13:29,600 --> 00:13:35,360
do here is have a more modular

376
00:13:33,600 --> 00:13:37,600
equalizer structure the adaptive

377
00:13:35,360 --> 00:13:39,279
algorithm is very separate from the

378
00:13:37,600 --> 00:13:41,920
actual equalizer structure

379
00:13:39,279 --> 00:13:43,519
so we want to pull those apart you know

380
00:13:41,920 --> 00:13:46,639
essentially if you look at this

381
00:13:43,519 --> 00:13:48,560
this block and this block they're 90 the

382
00:13:46,639 --> 00:13:49,760
same code so

383
00:13:48,560 --> 00:13:51,839
we want to we want to break out the

384
00:13:49,760 --> 00:13:54,959
parts that are the same and break out

385
00:13:51,839 --> 00:13:54,959
the parts that are different

386
00:13:56,240 --> 00:14:01,120
so what we have um up on the github

387
00:13:59,279 --> 00:14:03,760
is some new blocks so there's two new

388
00:14:01,120 --> 00:14:04,560
blocks there's this linear equalizer

389
00:14:03,760 --> 00:14:06,880
block

390
00:14:04,560 --> 00:14:07,680
um which we talked about you know which

391
00:14:06,880 --> 00:14:09,519
is

392
00:14:07,680 --> 00:14:11,279
you know it's the the basis for these

393
00:14:09,519 --> 00:14:12,160
blocks it's just these blocks stripped

394
00:14:11,279 --> 00:14:15,519
out

395
00:14:12,160 --> 00:14:16,880
stripped out the adaptive algorithm part

396
00:14:15,519 --> 00:14:20,079
and then there is now a decision

397
00:14:16,880 --> 00:14:23,120
feedback algorith equalizer

398
00:14:20,079 --> 00:14:24,560
and then so now these blocks take in an

399
00:14:23,120 --> 00:14:27,120
adaptive algorithm

400
00:14:24,560 --> 00:14:28,800
object so this is modeled on the digital

401
00:14:27,120 --> 00:14:31,279
constellation objects

402
00:14:28,800 --> 00:14:33,359
so it's just it holds a few methods and

403
00:14:31,279 --> 00:14:37,920
then you can use it in either of these

404
00:14:33,360 --> 00:14:40,560
um either of the equalizer structures

405
00:14:37,920 --> 00:14:42,479
and it also this algorithm object also

406
00:14:40,560 --> 00:14:44,560
takes in a constellation object

407
00:14:42,480 --> 00:14:47,360
if you want to do decision directed

408
00:14:44,560 --> 00:14:47,359
equalization

409
00:14:49,120 --> 00:14:54,880
all right so we just talked about this

410
00:14:53,120 --> 00:14:56,399
the linear and decision feedback it's

411
00:14:54,880 --> 00:14:58,079
just both a filter

412
00:14:56,399 --> 00:15:00,399
they're fractional spaced equalizers

413
00:14:58,079 --> 00:15:04,560
which means it's going to take in

414
00:15:00,399 --> 00:15:06,959
um an up-sampled signal

415
00:15:04,560 --> 00:15:08,479
by some samples per signal and then it's

416
00:15:06,959 --> 00:15:10,319
going to decimate the output down to

417
00:15:08,480 --> 00:15:13,680
your sample rate

418
00:15:10,320 --> 00:15:14,720
it's also so each each adaptive

419
00:15:13,680 --> 00:15:16,880
algorithm

420
00:15:14,720 --> 00:15:19,040
is going to initialize the weights some

421
00:15:16,880 --> 00:15:22,959
way update the taps

422
00:15:19,040 --> 00:15:22,959
and also provide some error estimation

423
00:15:24,000 --> 00:15:27,199
so now now we get into adaptive

424
00:15:26,079 --> 00:15:30,638
equalization

425
00:15:27,199 --> 00:15:32,240
um so how can we track this uh track our

426
00:15:30,639 --> 00:15:35,600
channel state

427
00:15:32,240 --> 00:15:37,120
as the channel is changing so there's a

428
00:15:35,600 --> 00:15:38,639
lot of different algorithms this is a

429
00:15:37,120 --> 00:15:41,199
very small list of

430
00:15:38,639 --> 00:15:42,480
of adaptive algorithms so you know one

431
00:15:41,199 --> 00:15:44,240
thing we could do we talked about the

432
00:15:42,480 --> 00:15:46,880
mmse direct solution

433
00:15:44,240 --> 00:15:49,199
we can directly invert the matrix and

434
00:15:46,880 --> 00:15:51,360
every time we get this training sequence

435
00:15:49,199 --> 00:15:53,439
okay um that doesn't track very well we

436
00:15:51,360 --> 00:15:56,320
have to just keep updating it

437
00:15:53,440 --> 00:15:58,079
lms it converges more slowly but

438
00:15:56,320 --> 00:16:01,759
computationally it's very simple

439
00:15:58,079 --> 00:16:04,959
it's just one dot product essentially

440
00:16:01,759 --> 00:16:05,519
normalize lms recursively squares this

441
00:16:04,959 --> 00:16:07,199
adapts

442
00:16:05,519 --> 00:16:09,519
very quickly and we'll see the

443
00:16:07,199 --> 00:16:11,758
difference between rls and lms

444
00:16:09,519 --> 00:16:13,920
and but it's more computationally

445
00:16:11,759 --> 00:16:17,839
intensive not crazy it's just doing some

446
00:16:13,920 --> 00:16:20,319
a little bit of matrix math and then cma

447
00:16:17,839 --> 00:16:21,040
constant modulus algorithm it's a blind

448
00:16:20,320 --> 00:16:25,120
method

449
00:16:21,040 --> 00:16:26,560
so rather than using a training sequence

450
00:16:25,120 --> 00:16:28,480
or decisions that we make

451
00:16:26,560 --> 00:16:30,239
we're just using the property that the

452
00:16:28,480 --> 00:16:32,079
signal has a constant modulus

453
00:16:30,240 --> 00:16:35,279
and we're going to get how far from the

454
00:16:32,079 --> 00:16:38,319
unit circle is our error

455
00:16:35,279 --> 00:16:39,839
so rather than doing a whole derivation

456
00:16:38,320 --> 00:16:40,800
of these we just get right down to the

457
00:16:39,839 --> 00:16:44,720
algorithm

458
00:16:40,800 --> 00:16:47,040
um so lms what we do we have

459
00:16:44,720 --> 00:16:48,480
some initial weights we assume something

460
00:16:47,040 --> 00:16:51,839
we have a starting point

461
00:16:48,480 --> 00:16:53,519
we don't know you know we we have the um

462
00:16:51,839 --> 00:16:55,519
the cost function the minimum air cost

463
00:16:53,519 --> 00:16:58,240
function that we're trying to find

464
00:16:55,519 --> 00:16:59,920
adaptively the minimum of so we start at

465
00:16:58,240 --> 00:17:00,880
some weights we're somewhere on this

466
00:16:59,920 --> 00:17:03,439
surface

467
00:17:00,880 --> 00:17:04,319
and we're going to descend in a way that

468
00:17:03,440 --> 00:17:06,720
gets us

469
00:17:04,319 --> 00:17:07,520
to the bottom and the way we do that you

470
00:17:06,720 --> 00:17:10,480
know we're going to

471
00:17:07,520 --> 00:17:12,160
push our weight estimate in the steepest

472
00:17:10,480 --> 00:17:13,919
direction toward the minimum of that

473
00:17:12,160 --> 00:17:16,319
cost function

474
00:17:13,919 --> 00:17:17,199
so the way we're going to do that is our

475
00:17:16,319 --> 00:17:19,678
next weights

476
00:17:17,199 --> 00:17:22,640
are going to be our previous weights

477
00:17:19,679 --> 00:17:25,839
plus some step size

478
00:17:22,640 --> 00:17:27,600
times the signal we received pushed

479
00:17:25,839 --> 00:17:28,879
away from the error we calculated we're

480
00:17:27,599 --> 00:17:32,240
going to push in a way that's

481
00:17:28,880 --> 00:17:34,000
orthogonal to the error and then in lms

482
00:17:32,240 --> 00:17:35,760
normalized lms is just a very slight

483
00:17:34,000 --> 00:17:37,840
modification we're just going to

484
00:17:35,760 --> 00:17:40,879
normalize that step size

485
00:17:37,840 --> 00:17:42,879
by the um by the

486
00:17:40,880 --> 00:17:47,840
amplitude of the signal we received by

487
00:17:42,880 --> 00:17:47,840
the magnitude of that signal

488
00:17:48,799 --> 00:17:55,360
so cma mentioned briefly it's

489
00:17:52,160 --> 00:17:56,640
it's the same weight update as lms we're

490
00:17:55,360 --> 00:17:59,199
going to you know push

491
00:17:56,640 --> 00:18:00,960
in the way away from how we calculated

492
00:17:59,200 --> 00:18:02,320
our error

493
00:18:00,960 --> 00:18:04,400
but what we're going to do is we're

494
00:18:02,320 --> 00:18:06,320
going to calculate our error differently

495
00:18:04,400 --> 00:18:09,600
assume we're receiving like a qpsk

496
00:18:06,320 --> 00:18:13,200
signal 8psk any kind of constant modulus

497
00:18:09,600 --> 00:18:14,639
signal what what we want to do is

498
00:18:13,200 --> 00:18:16,799
calculate the error

499
00:18:14,640 --> 00:18:18,080
how far from that circle we expect our

500
00:18:16,799 --> 00:18:21,120
symbols to be

501
00:18:18,080 --> 00:18:23,520
so that's all cma is

502
00:18:21,120 --> 00:18:24,959
so we don't have to be phase aligned at

503
00:18:23,520 --> 00:18:27,760
this point

504
00:18:24,960 --> 00:18:28,000
we just have to be agc'd we have to we

505
00:18:27,760 --> 00:18:30,640
have

506
00:18:28,000 --> 00:18:33,280
to um you know this has to be a known

507
00:18:30,640 --> 00:18:33,280
unit circle

508
00:18:34,240 --> 00:18:39,440
and then rls um is a it's a it's a

509
00:18:37,919 --> 00:18:41,840
recursive solution

510
00:18:39,440 --> 00:18:42,720
uh to the mmse problem you know we're

511
00:18:41,840 --> 00:18:45,600
assuming that

512
00:18:42,720 --> 00:18:46,240
recursively all of the decisions we made

513
00:18:45,600 --> 00:18:48,799
in our tap

514
00:18:46,240 --> 00:18:51,039
updates have built up and so there's a

515
00:18:48,799 --> 00:18:54,160
forgetting factor

516
00:18:51,039 --> 00:18:55,360
which says how much how much of the

517
00:18:54,160 --> 00:18:58,160
previous calculation

518
00:18:55,360 --> 00:18:58,639
am i going to include in the next step

519
00:18:58,160 --> 00:19:00,960
and then

520
00:18:58,640 --> 00:19:04,000
here's the math here um it's not it's

521
00:19:00,960 --> 00:19:06,160
not terrible if there's just a few

522
00:19:04,000 --> 00:19:08,080
matrix multiplies which makes it more

523
00:19:06,160 --> 00:19:11,200
computationally intensive than

524
00:19:08,080 --> 00:19:14,639
than the lms but

525
00:19:11,200 --> 00:19:14,640
it converges very quickly

526
00:19:15,919 --> 00:19:19,039
so and then look at looking forward with

527
00:19:17,840 --> 00:19:21,039
this stuff

528
00:19:19,039 --> 00:19:23,039
now that we've separated the algorithms

529
00:19:21,039 --> 00:19:26,640
from the equalizer structure

530
00:19:23,039 --> 00:19:28,240
we have um it's much easier to add more

531
00:19:26,640 --> 00:19:28,880
algorithms you know you want to try out

532
00:19:28,240 --> 00:19:30,400
some

533
00:19:28,880 --> 00:19:32,080
some equalizer structure it's very

534
00:19:30,400 --> 00:19:33,919
little bit of code that has to be added

535
00:19:32,080 --> 00:19:36,000
a little object you could even add

536
00:19:33,919 --> 00:19:38,960
neural network based equalizers

537
00:19:36,000 --> 00:19:41,039
if you wanted to that's a thing and then

538
00:19:38,960 --> 00:19:44,160
ofdm we haven't even touched

539
00:19:41,039 --> 00:19:44,480
ofdm um and there's there's folks that

540
00:19:44,160 --> 00:19:46,160
are

541
00:19:44,480 --> 00:19:49,360
you know much better experts on this

542
00:19:46,160 --> 00:19:52,799
than me but if you look at say lte

543
00:19:49,360 --> 00:19:55,280
um you have an lte you have

544
00:19:52,799 --> 00:19:56,639
training symbols that are spaced across

545
00:19:55,280 --> 00:19:58,879
frequency and time

546
00:19:56,640 --> 00:20:00,320
so that gives you a surface that you can

547
00:19:58,880 --> 00:20:02,000
backup you can actually do a zero

548
00:20:00,320 --> 00:20:05,360
forcing equalizer and lte

549
00:20:02,000 --> 00:20:07,120
and there's other things you can do but

550
00:20:05,360 --> 00:20:08,879
it's it's a different problem than the

551
00:20:07,120 --> 00:20:12,479
single carrier um

552
00:20:08,880 --> 00:20:12,480
example so

553
00:20:13,679 --> 00:20:17,120
so one one note i mentioned this briefly

554
00:20:16,240 --> 00:20:18,559
um

555
00:20:17,120 --> 00:20:20,239
one of the key drivers of this is we

556
00:20:18,559 --> 00:20:22,559
wanted to handle bursty data

557
00:20:20,240 --> 00:20:23,600
we need some equalizers so you know a

558
00:20:22,559 --> 00:20:25,760
lot a lot of the

559
00:20:23,600 --> 00:20:26,959
blocks in gnu radio including these

560
00:20:25,760 --> 00:20:30,320
equalizers

561
00:20:26,960 --> 00:20:31,760
have all the functionality baked into

562
00:20:30,320 --> 00:20:34,158
the work function

563
00:20:31,760 --> 00:20:36,400
so just an implementation note i really

564
00:20:34,159 --> 00:20:38,159
tried in this implementation to pull

565
00:20:36,400 --> 00:20:40,080
the signal processing into a function

566
00:20:38,159 --> 00:20:41,520
that could be called from outside of gnu

567
00:20:40,080 --> 00:20:43,120
radio that you could just use this as a

568
00:20:41,520 --> 00:20:46,000
signal processing library

569
00:20:43,120 --> 00:20:47,199
um so looking forward you know and work

570
00:20:46,000 --> 00:20:50,240
i'm doing i'm trying to do that

571
00:20:47,200 --> 00:20:52,559
more hopefully that's something we

572
00:20:50,240 --> 00:20:53,840
address in the future of gnu radio

573
00:20:52,559 --> 00:20:55,678
so let's look at some performance

574
00:20:53,840 --> 00:20:57,678
comparison um

575
00:20:55,679 --> 00:20:58,799
i think i have these as videos let's see

576
00:20:57,679 --> 00:21:02,559
if they work

577
00:20:58,799 --> 00:21:06,080
nope but there we go

578
00:21:02,559 --> 00:21:07,600
uh so this particular example we have

579
00:21:06,080 --> 00:21:09,120
actually you know what rather than doing

580
00:21:07,600 --> 00:21:12,320
this i'm just going to

581
00:21:09,120 --> 00:21:15,360
pull up um i

582
00:21:12,320 --> 00:21:18,559
should look a new radio so let's look up

583
00:21:15,360 --> 00:21:22,879
first rls versus lms

584
00:21:18,559 --> 00:21:25,520
so they both get you to the same point

585
00:21:22,880 --> 00:21:27,360
but if you look at the top um there's

586
00:21:25,520 --> 00:21:30,480
some rough measurement of evm

587
00:21:27,360 --> 00:21:33,840
of the signal you know how far

588
00:21:30,480 --> 00:21:36,720
how far are each of these clusters

589
00:21:33,840 --> 00:21:38,480
in magnitude uh from the entire

590
00:21:36,720 --> 00:21:42,000
constellation magnitude

591
00:21:38,480 --> 00:21:43,360
um so you if you look ros converge down

592
00:21:42,000 --> 00:21:45,360
towards zero

593
00:21:43,360 --> 00:21:46,879
a little bit quicker than the lms it's

594
00:21:45,360 --> 00:21:48,639
all relative who knows you know what the

595
00:21:46,880 --> 00:21:51,760
snr is set to in here

596
00:21:48,640 --> 00:21:55,039
um so you can see that

597
00:21:51,760 --> 00:21:59,840
that the rls converge more quickly um

598
00:21:55,039 --> 00:21:59,840
let's take a look at

599
00:22:01,360 --> 00:22:05,199
let's take a look at this one so this

600
00:22:06,480 --> 00:22:10,559
so you'll see this is a comparison of

601
00:22:11,200 --> 00:22:17,440
just an lms lms converged

602
00:22:15,200 --> 00:22:18,799
you know very quickly when it was given

603
00:22:17,440 --> 00:22:20,159
a trading sequence

604
00:22:18,799 --> 00:22:22,559
so that was one of the other drivers of

605
00:22:20,159 --> 00:22:24,080
this work was wanted to be able to

606
00:22:22,559 --> 00:22:26,720
equalize when you actually see a

607
00:22:24,080 --> 00:22:28,399
training sequence um

608
00:22:26,720 --> 00:22:30,720
and then but the decision directed

609
00:22:28,400 --> 00:22:33,200
version it took a while to converge

610
00:22:30,720 --> 00:22:33,919
it went it didn't know what to do and

611
00:22:33,200 --> 00:22:36,480
finally

612
00:22:33,919 --> 00:22:38,240
it latched on to what it should be doing

613
00:22:36,480 --> 00:22:40,240
and converge down towards zero

614
00:22:38,240 --> 00:22:41,760
it was good in the end the original

615
00:22:40,240 --> 00:22:44,960
going to radio block

616
00:22:41,760 --> 00:22:46,400
um never quite converged in this case

617
00:22:44,960 --> 00:22:48,480
under these scenarios so there were some

618
00:22:46,400 --> 00:22:52,080
slight implementation differences

619
00:22:48,480 --> 00:22:53,360
i won't get into okay and i think i'm

620
00:22:52,080 --> 00:22:55,840
starting to run out of

621
00:22:53,360 --> 00:22:55,840
time here

622
00:22:56,720 --> 00:22:59,919
just do a quick

623
00:23:00,000 --> 00:23:04,080
other resources there is another out of

624
00:23:02,480 --> 00:23:06,880
tree module

625
00:23:04,080 --> 00:23:07,360
gr adapt that someone i don't know this

626
00:23:06,880 --> 00:23:10,799
person

627
00:23:07,360 --> 00:23:11,760
i don't know if carell is here um but

628
00:23:10,799 --> 00:23:14,320
this this was an excellent

629
00:23:11,760 --> 00:23:15,919
implementation of other applications of

630
00:23:14,320 --> 00:23:17,120
adaptive algorithms so this is worth

631
00:23:15,919 --> 00:23:19,039
taking a look at

632
00:23:17,120 --> 00:23:20,399
and then there are some actually very

633
00:23:19,039 --> 00:23:24,480
good youtube videos

634
00:23:20,400 --> 00:23:26,320
um university lectures on mmsc lms rls

635
00:23:24,480 --> 00:23:28,159
all the derivations so highly recommend

636
00:23:26,320 --> 00:23:30,639
those they do much better than me

637
00:23:28,159 --> 00:23:32,080
job than me and then books and papers

638
00:23:30,640 --> 00:23:37,840
and things

639
00:23:32,080 --> 00:23:37,840
all right so questions anybody

640
00:23:39,440 --> 00:23:43,600
one bureaucratic note if we could do a

641
00:23:41,919 --> 00:23:46,000
little bit of defraggings we can get

642
00:23:43,600 --> 00:23:50,080
these people in and i can figure out the

643
00:23:46,000 --> 00:23:52,240
room changeover in people and questions

644
00:23:50,080 --> 00:23:54,559
yes uh so the question for the training

645
00:23:52,240 --> 00:23:56,480
sequences do your algorithms require

646
00:23:54,559 --> 00:23:57,200
very specific training sequence so can

647
00:23:56,480 --> 00:23:59,039
be

648
00:23:57,200 --> 00:24:00,640
defined because for example if i want to

649
00:23:59,039 --> 00:24:02,879
design my own customer

650
00:24:00,640 --> 00:24:05,760
customized protocol i must have one we

651
00:24:02,880 --> 00:24:08,400
have some treatment sequence of preamble

652
00:24:05,760 --> 00:24:09,039
signal right so yeah i use them also in

653
00:24:08,400 --> 00:24:12,320
the code

654
00:24:09,039 --> 00:24:14,720
yes so okay um so

655
00:24:12,320 --> 00:24:15,840
so for for this particular um

656
00:24:14,720 --> 00:24:16,880
implementation

657
00:24:15,840 --> 00:24:18,158
you can give it anything for the

658
00:24:16,880 --> 00:24:19,679
training sequence you just give it a

659
00:24:18,159 --> 00:24:22,400
series of symbols

660
00:24:19,679 --> 00:24:23,919
it's going to um kind of pop up real

661
00:24:22,400 --> 00:24:26,159
quick i'll just show you a really quick

662
00:24:23,919 --> 00:24:26,159
video

663
00:24:27,440 --> 00:24:34,159
okay um all right yeah

664
00:24:30,880 --> 00:24:36,880
so so what this this just threw in

665
00:24:34,159 --> 00:24:38,320
these are just based on the um the stock

666
00:24:36,880 --> 00:24:41,600
examples in gnu radio

667
00:24:38,320 --> 00:24:44,080
in in gr digital um and

668
00:24:41,600 --> 00:24:46,158
it just there's a preamble plus data

669
00:24:44,080 --> 00:24:49,279
data some random symbols

670
00:24:46,159 --> 00:24:50,960
preamble is just i think i think i made

671
00:24:49,279 --> 00:24:54,720
up some gold sequence here

672
00:24:50,960 --> 00:24:54,720
but you can give it anything you know

673
00:24:56,080 --> 00:25:00,399
you can't yeah as long as i mean the

674
00:24:58,159 --> 00:25:03,520
real thing here with your uh

675
00:25:00,400 --> 00:25:05,120
training sequence is you have to you

676
00:25:03,520 --> 00:25:06,480
have to be able to correlate against it

677
00:25:05,120 --> 00:25:08,320
so you see there

678
00:25:06,480 --> 00:25:09,600
so whatever the you know the

679
00:25:08,320 --> 00:25:10,320
autocorrelation properties of that

680
00:25:09,600 --> 00:25:13,120
sequence are

681
00:25:10,320 --> 00:25:14,559
is what's going to be a limiting factor

682
00:25:13,120 --> 00:25:17,918
yeah thank you

683
00:25:14,559 --> 00:25:20,158
cool yes one quick uh on that so if you

684
00:25:17,919 --> 00:25:22,320
like it uh training but it's it's it's

685
00:25:20,159 --> 00:25:23,760
fine when you have a peer to peer static

686
00:25:22,320 --> 00:25:26,639
but what if some

687
00:25:23,760 --> 00:25:27,360
one side or the other or board they like

688
00:25:26,640 --> 00:25:29,600
now move

689
00:25:27,360 --> 00:25:30,639
through the space how how can then you

690
00:25:29,600 --> 00:25:33,840
know you know

691
00:25:30,640 --> 00:25:36,640
train a thing yes uh good question

692
00:25:33,840 --> 00:25:38,559
the question was if if your uh

693
00:25:36,640 --> 00:25:39,679
transmitter receiver are moving how can

694
00:25:38,559 --> 00:25:41,440
how can it train

695
00:25:39,679 --> 00:25:42,960
so if you're constantly sending new

696
00:25:41,440 --> 00:25:45,600
training sequences

697
00:25:42,960 --> 00:25:47,200
um you know the the the time between

698
00:25:45,600 --> 00:25:49,279
those training sequences

699
00:25:47,200 --> 00:25:50,960
needs to be you know less than the

700
00:25:49,279 --> 00:25:53,919
coherence time of the channel

701
00:25:50,960 --> 00:25:54,960
right and your your lms tap updates rls

702
00:25:53,919 --> 00:25:57,039
whatever algorithm

703
00:25:54,960 --> 00:25:59,120
you're using you know needs to be able

704
00:25:57,039 --> 00:25:59,629
to update with the changes in your

705
00:25:59,120 --> 00:26:00,879
channel

706
00:25:59,630 --> 00:26:03,039
[Music]

707
00:26:00,880 --> 00:26:04,960
it constantly retrain that that's in and

708
00:26:03,039 --> 00:26:06,320
so the lms is going to track that and

709
00:26:04,960 --> 00:26:09,120
keep finding that minimum

710
00:26:06,320 --> 00:26:10,158
how quick is that it all depends on the

711
00:26:09,120 --> 00:26:12,239
channel

712
00:26:10,159 --> 00:26:13,279
yeah so in you know indoor channel might

713
00:26:12,240 --> 00:26:15,919
be um

714
00:26:13,279 --> 00:26:16,960
very long coherence time because things

715
00:26:15,919 --> 00:26:18,640
aren't moving around

716
00:26:16,960 --> 00:26:21,360
if you're on a high speed train it'll be

717
00:26:18,640 --> 00:26:23,679
a very short coherence time

718
00:26:21,360 --> 00:26:24,879
all right yeah second maybe a stupid

719
00:26:23,679 --> 00:26:28,159
question but

720
00:26:24,880 --> 00:26:31,520
how how much does this benefit if you um

721
00:26:28,159 --> 00:26:32,960
over sample by uh the far higher than

722
00:26:31,520 --> 00:26:34,799
the simple rate

723
00:26:32,960 --> 00:26:36,159
how much to um not a stupid question

724
00:26:34,799 --> 00:26:38,480
yeah so the question is how

725
00:26:36,159 --> 00:26:39,919
what's the benefit of over sampling um

726
00:26:38,480 --> 00:26:43,360
at a much higher rate

727
00:26:39,919 --> 00:26:44,480
um you know i i know equalizers

728
00:26:43,360 --> 00:26:45,918
generally work better if you're

729
00:26:44,480 --> 00:26:49,039
oversampled by

730
00:26:45,919 --> 00:26:50,240
at least two or four um if you go more

731
00:26:49,039 --> 00:26:51,760
than that

732
00:26:50,240 --> 00:26:54,720
i'm not sure because the you know the

733
00:26:51,760 --> 00:26:57,200
equalizer you know it's it's going to

734
00:26:54,720 --> 00:26:58,799
the taps i didn't show one here that

735
00:26:57,200 --> 00:27:01,039
outputs the taps

736
00:26:58,799 --> 00:27:02,960
um that's one one of the outputs in the

737
00:27:01,039 --> 00:27:06,080
equalizer block here

738
00:27:02,960 --> 00:27:09,200
is is the tabs um i thought i had

739
00:27:06,080 --> 00:27:12,080
one uh this one

740
00:27:09,200 --> 00:27:21,840
does this one output the taps well you

741
00:27:12,080 --> 00:27:21,840
know what play all the time

742
00:27:27,520 --> 00:27:31,760
limited by the signal bandwidth um but

743
00:27:29,520 --> 00:27:33,039
that you know the taps that it finds you

744
00:27:31,760 --> 00:27:36,879
know it's going to come up with some

745
00:27:33,039 --> 00:27:39,120
time domain shape that just needs to be

746
00:27:36,880 --> 00:27:40,159
within the you know the coherence

747
00:27:39,120 --> 00:27:42,959
bandwidth of

748
00:27:40,159 --> 00:27:42,960
what you're trying to do

749
00:27:46,840 --> 00:27:49,840
yes

750
00:27:55,630 --> 00:28:00,790
[Laughter]

751
00:28:01,039 --> 00:28:06,799
i i don't have those numbers no um

752
00:28:04,320 --> 00:28:07,840
it's that there were a couple of things

753
00:28:06,799 --> 00:28:12,480
i was able to

754
00:28:07,840 --> 00:28:13,760
um compared to the original guinea radio

755
00:28:12,480 --> 00:28:14,799
blocks there was a couple things i was

756
00:28:13,760 --> 00:28:17,840
able to vocify

757
00:28:14,799 --> 00:28:19,440
in here so that that definitely improved

758
00:28:17,840 --> 00:28:22,320
the performance but i don't have

759
00:28:19,440 --> 00:28:22,320
quantitative numbers

760
00:28:24,000 --> 00:28:33,520
all right thank you yes

761
00:28:31,440 --> 00:28:33,520
you

