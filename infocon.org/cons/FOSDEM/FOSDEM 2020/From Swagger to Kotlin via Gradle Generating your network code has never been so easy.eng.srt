1
00:00:07,040 --> 00:00:12,160
yes sir so hi everyone uh

2
00:00:10,240 --> 00:00:13,519
thank you for coming uh this session is

3
00:00:12,160 --> 00:00:14,639
an amendment because the previous

4
00:00:13,519 --> 00:00:17,759
speaker

5
00:00:14,639 --> 00:00:21,279
is unable to to come to attend fosdem

6
00:00:17,760 --> 00:00:22,800
she sent her uh yeah notice but

7
00:00:21,279 --> 00:00:24,240
unfortunately she won't be here the

8
00:00:22,800 --> 00:00:25,920
session would have been

9
00:00:24,240 --> 00:00:27,680
uh bridge the physical world currently

10
00:00:25,920 --> 00:00:30,640
native on raspberry pi

11
00:00:27,680 --> 00:00:33,200
uh but instead it will be from swagger

12
00:00:30,640 --> 00:00:36,559
to cutting via gradle

13
00:00:33,200 --> 00:00:38,160
uh if you leave the room please um

14
00:00:36,559 --> 00:00:40,160
pay attention to the chair because it's

15
00:00:38,160 --> 00:00:42,640
really noisy

16
00:00:40,160 --> 00:00:45,360
and and yeah let's get it started so my

17
00:00:42,640 --> 00:00:48,399
name is nicola corti

18
00:00:45,360 --> 00:00:50,079
i work as infrastructure engineer that

19
00:00:48,399 --> 00:00:52,000
means android infrastructure engineer

20
00:00:50,079 --> 00:00:54,480
that means that i basically

21
00:00:52,000 --> 00:00:56,399
work on libraries framework tools for an

22
00:00:54,480 --> 00:00:58,480
android engineer i mostly

23
00:00:56,399 --> 00:00:59,520
develop in kotlin when possible but i

24
00:00:58,480 --> 00:01:03,680
also

25
00:00:59,520 --> 00:01:05,199
have to deal a lot with java um

26
00:01:03,680 --> 00:01:06,960
yeah if you probably know me you know

27
00:01:05,199 --> 00:01:08,798
that i'm more like a dog person rather

28
00:01:06,960 --> 00:01:10,880
than a cat person

29
00:01:08,799 --> 00:01:11,920
and why this is important this is

30
00:01:10,880 --> 00:01:14,000
important because

31
00:01:11,920 --> 00:01:15,920
i don't have a dog at the moment i will

32
00:01:14,000 --> 00:01:17,680
actually would love to get one at a

33
00:01:15,920 --> 00:01:18,400
certain point i'm actually really in

34
00:01:17,680 --> 00:01:21,680
love with

35
00:01:18,400 --> 00:01:22,320
corgis so i thought that maybe you can

36
00:01:21,680 --> 00:01:25,520
help me

37
00:01:22,320 --> 00:01:28,080
get one pet actually

38
00:01:25,520 --> 00:01:29,360
a corgi so what happens next is that

39
00:01:28,080 --> 00:01:32,158
yeah i could actually go

40
00:01:29,360 --> 00:01:32,960
to to the pet store a pet store that's

41
00:01:32,159 --> 00:01:36,400
wagered

42
00:01:32,960 --> 00:01:39,839
and then they tell me that i can't

43
00:01:36,400 --> 00:01:44,159
just call get slash pets

44
00:01:39,840 --> 00:01:45,280
because that's not valid

45
00:01:44,159 --> 00:01:48,320
so today we're going to talk about

46
00:01:45,280 --> 00:01:51,280
swagger and open api

47
00:01:48,320 --> 00:01:52,398
uh so swagger and open apis are both

48
00:01:51,280 --> 00:01:55,520
tools to define

49
00:01:52,399 --> 00:01:58,640
in a machine and human readable way

50
00:01:55,520 --> 00:02:00,000
the apis for your backend services

51
00:01:58,640 --> 00:02:02,640
so there is a little bit of confusion

52
00:02:00,000 --> 00:02:04,399
between open api and swagger

53
00:02:02,640 --> 00:02:06,320
if you go on the website they will tell

54
00:02:04,399 --> 00:02:07,200
you that open api is actually the

55
00:02:06,320 --> 00:02:10,079
specification

56
00:02:07,200 --> 00:02:10,640
while swagger is all the tooling around

57
00:02:10,080 --> 00:02:13,680
it

58
00:02:10,639 --> 00:02:15,839
in the community it's more like

59
00:02:13,680 --> 00:02:18,640
connected to the fact that open api is

60
00:02:15,840 --> 00:02:21,120
related to the open api specification

61
00:02:18,640 --> 00:02:23,440
version 3 while swagger is whatever is

62
00:02:21,120 --> 00:02:24,400
is related to then to the specification

63
00:02:23,440 --> 00:02:26,319
version 2.

64
00:02:24,400 --> 00:02:29,520
so today we're going to mostly focus on

65
00:02:26,319 --> 00:02:31,280
swagger that means version 2.

66
00:02:29,520 --> 00:02:33,040
what's the cool part of this if you

67
00:02:31,280 --> 00:02:35,200
don't know swagger

68
00:02:33,040 --> 00:02:36,480
quick question how many here are

69
00:02:35,200 --> 00:02:40,238
actually working

70
00:02:36,480 --> 00:02:43,280
our projects that have swagger apis

71
00:02:40,239 --> 00:02:45,120
and not everyone so uh the cool part of

72
00:02:43,280 --> 00:02:46,879
this is that they're actually

73
00:02:45,120 --> 00:02:48,319
this is actually a tool to define your

74
00:02:46,879 --> 00:02:51,840
apis with just

75
00:02:48,319 --> 00:02:54,399
json or yaml file like one or more

76
00:02:51,840 --> 00:02:55,280
and the cool part is that is actually as

77
00:02:54,400 --> 00:02:57,519
i said before

78
00:02:55,280 --> 00:02:58,879
machine readable so you can build

79
00:02:57,519 --> 00:03:02,159
infrastructure around it

80
00:02:58,879 --> 00:03:03,518
and tools so let's make an example

81
00:03:02,159 --> 00:03:05,599
and the example i'm going to make is

82
00:03:03,519 --> 00:03:06,800
actually the pet store the pet store is

83
00:03:05,599 --> 00:03:09,518
the equivalent of

84
00:03:06,800 --> 00:03:11,040
hello world but for the api so it's like

85
00:03:09,519 --> 00:03:13,040
a minimal set

86
00:03:11,040 --> 00:03:14,560
of endpoints that represents the

87
00:03:13,040 --> 00:03:18,000
basically feature set

88
00:03:14,560 --> 00:03:20,959
of this api specification tool

89
00:03:18,000 --> 00:03:22,920
so we start with a yaml file we define a

90
00:03:20,959 --> 00:03:24,879
version as i said we're gonna work with

91
00:03:22,920 --> 00:03:26,798
swagger2

92
00:03:24,879 --> 00:03:28,319
and we have an info block so inside the

93
00:03:26,799 --> 00:03:30,319
infoblock there it's like a little

94
00:03:28,319 --> 00:03:32,159
preamble where you can like specify

95
00:03:30,319 --> 00:03:34,798
what this vlogger file is going to be

96
00:03:32,159 --> 00:03:38,000
about so in this case the description

97
00:03:34,799 --> 00:03:38,799
the version of this spec file so 100 in

98
00:03:38,000 --> 00:03:41,760
this case

99
00:03:38,799 --> 00:03:42,319
a title swagger pet store you can

100
00:03:41,760 --> 00:03:45,280
provide

101
00:03:42,319 --> 00:03:45,599
further information like a contact email

102
00:03:45,280 --> 00:03:48,959
or

103
00:03:45,599 --> 00:03:51,440
a license then

104
00:03:48,959 --> 00:03:52,959
uh you can define a host in this case we

105
00:03:51,440 --> 00:03:54,480
are going to be reachable a pet stores

106
00:03:52,959 --> 00:03:58,400
wager io

107
00:03:54,480 --> 00:04:00,798
a base path like equiliba slash v2 as a

108
00:03:58,400 --> 00:04:04,480
base path for all of your endpoints and

109
00:04:00,799 --> 00:04:06,959
the supported schemes like http or https

110
00:04:04,480 --> 00:04:08,640
that's all part of like the introductory

111
00:04:06,959 --> 00:04:11,040
part of this pack

112
00:04:08,640 --> 00:04:12,319
uh but let's let's go further and let's

113
00:04:11,040 --> 00:04:14,879
actually define

114
00:04:12,319 --> 00:04:16,159
like how our spec will look like so

115
00:04:14,879 --> 00:04:18,079
usually within this fact you will have

116
00:04:16,160 --> 00:04:22,639
to define two set of things

117
00:04:18,079 --> 00:04:24,320
endpoints and models like objects

118
00:04:22,639 --> 00:04:25,840
so let's start with the definitions here

119
00:04:24,320 --> 00:04:28,479
you define your models and

120
00:04:25,840 --> 00:04:30,960
we start by defining what is a pet we

121
00:04:28,479 --> 00:04:34,159
can say that a pet is actually an object

122
00:04:30,960 --> 00:04:35,440
and has a set of properties specifically

123
00:04:34,160 --> 00:04:37,440
an id

124
00:04:35,440 --> 00:04:39,280
and we can say the use of type integer

125
00:04:37,440 --> 00:04:41,840
format in 64

126
00:04:39,280 --> 00:04:42,320
and the name there is a string and

127
00:04:41,840 --> 00:04:44,638
define

128
00:04:42,320 --> 00:04:46,960
our reality obviously also complex types

129
00:04:44,639 --> 00:04:50,160
are supported for example i could have a

130
00:04:46,960 --> 00:04:52,479
photo urls there is actually an array

131
00:04:50,160 --> 00:04:54,840
and the items of their a are of type

132
00:04:52,479 --> 00:04:56,080
string so i will receive like a list of

133
00:04:54,840 --> 00:04:58,000
urls

134
00:04:56,080 --> 00:05:00,000
i can specify which properties are

135
00:04:58,000 --> 00:05:02,240
required to make these definitions

136
00:05:00,000 --> 00:05:04,160
meaningful in this case i could say that

137
00:05:02,240 --> 00:05:07,600
name and photo urls are actually

138
00:05:04,160 --> 00:05:07,600
required so they should be there

139
00:05:07,840 --> 00:05:11,599
i can have even more complex types for

140
00:05:10,240 --> 00:05:13,440
example status

141
00:05:11,600 --> 00:05:15,759
and if i don't want the status to just

142
00:05:13,440 --> 00:05:18,080
be a string i could

143
00:05:15,759 --> 00:05:19,919
say i could provide a description and i

144
00:05:18,080 --> 00:05:22,639
could say that this is actually an enum

145
00:05:19,919 --> 00:05:23,280
so i could restrict the set of possible

146
00:05:22,639 --> 00:05:26,080
values

147
00:05:23,280 --> 00:05:27,520
to available and sold only and the real

148
00:05:26,080 --> 00:05:28,000
power of swagger is that i could

149
00:05:27,520 --> 00:05:31,198
actually

150
00:05:28,000 --> 00:05:32,080
define more than one model so i could

151
00:05:31,199 --> 00:05:35,360
say that

152
00:05:32,080 --> 00:05:36,400
a pet has also a category but a category

153
00:05:35,360 --> 00:05:40,000
is a reference

154
00:05:36,400 --> 00:05:42,960
to another definition like in this case

155
00:05:40,000 --> 00:05:44,400
let's zoom back category is again an

156
00:05:42,960 --> 00:05:47,599
object

157
00:05:44,400 --> 00:05:50,880
as some properties again an id

158
00:05:47,600 --> 00:05:52,080
of type integer format in 64 and a name

159
00:05:50,880 --> 00:05:54,639
of type string

160
00:05:52,080 --> 00:05:55,359
so this is like a basic definition of

161
00:05:54,639 --> 00:05:57,520
two

162
00:05:55,360 --> 00:05:58,960
two models but let's go to the to the

163
00:05:57,520 --> 00:06:00,799
core part of the spec like

164
00:05:58,960 --> 00:06:02,880
we would love to have some some

165
00:06:00,800 --> 00:06:04,960
endpoints so we go back to our

166
00:06:02,880 --> 00:06:06,639
yaml file at the top level we define our

167
00:06:04,960 --> 00:06:09,599
paths property

168
00:06:06,639 --> 00:06:11,440
and we begin enumerating our endpoints

169
00:06:09,600 --> 00:06:15,199
so the first one is path pad id

170
00:06:11,440 --> 00:06:17,120
sorry pat pat id and we can say that on

171
00:06:15,199 --> 00:06:20,400
this endpoint we support the get

172
00:06:17,120 --> 00:06:21,520
operation and we need to provide summary

173
00:06:20,400 --> 00:06:24,080
and description like

174
00:06:21,520 --> 00:06:26,960
uh find a path by id and what it does it

175
00:06:24,080 --> 00:06:29,919
returns a single path

176
00:06:26,960 --> 00:06:31,599
uh this context is also really useful to

177
00:06:29,919 --> 00:06:33,599
provide an operation id

178
00:06:31,600 --> 00:06:34,960
an operation id is a string

179
00:06:33,600 --> 00:06:38,800
representation

180
00:06:34,960 --> 00:06:39,198
of this combination of endpoint and http

181
00:06:38,800 --> 00:06:42,000
verb

182
00:06:39,199 --> 00:06:43,120
so in this case we will write get pat by

183
00:06:42,000 --> 00:06:45,600
a d and it's also

184
00:06:43,120 --> 00:06:47,280
at full because it's just characters

185
00:06:45,600 --> 00:06:49,440
there are no crazy symbols

186
00:06:47,280 --> 00:06:50,719
and slashes in between we will see why

187
00:06:49,440 --> 00:06:53,120
we need it

188
00:06:50,720 --> 00:06:54,400
and here we define what our endpoint is

189
00:06:53,120 --> 00:06:57,440
doing so for example is

190
00:06:54,400 --> 00:06:58,799
returning an application json and has

191
00:06:57,440 --> 00:07:01,759
some parameters

192
00:06:58,800 --> 00:07:02,319
like one there is pad id and is inside

193
00:07:01,759 --> 00:07:04,000
the path

194
00:07:02,319 --> 00:07:05,680
is actually the one that is before

195
00:07:04,000 --> 00:07:07,919
between curly braces

196
00:07:05,680 --> 00:07:10,160
and we can provide description like all

197
00:07:07,919 --> 00:07:11,840
those descriptions are actually optional

198
00:07:10,160 --> 00:07:13,520
you don't need to provide all of them

199
00:07:11,840 --> 00:07:16,239
but obviously if you provide it you will

200
00:07:13,520 --> 00:07:18,159
have better space easier to maintain

201
00:07:16,240 --> 00:07:20,040
and we can say it is actually required

202
00:07:18,160 --> 00:07:21,199
like you need to provide that

203
00:07:20,040 --> 00:07:24,400
[Music]

204
00:07:21,199 --> 00:07:27,520
parameter and specify the type integer

205
00:07:24,400 --> 00:07:29,198
and the format in 64. so the last thing

206
00:07:27,520 --> 00:07:31,039
that we need to define here is actually

207
00:07:29,199 --> 00:07:33,919
what this endpoint will produce

208
00:07:31,039 --> 00:07:34,719
so we have the responses block so we can

209
00:07:33,919 --> 00:07:37,758
say that for

210
00:07:34,720 --> 00:07:39,759
200 so for the successful uh

211
00:07:37,759 --> 00:07:42,160
response we are going to produce so the

212
00:07:39,759 --> 00:07:45,039
description is successful operation

213
00:07:42,160 --> 00:07:47,280
and for 404 the description is but not

214
00:07:45,039 --> 00:07:50,080
found because there is no pad in the

215
00:07:47,280 --> 00:07:51,840
our database whatsoever uh we still

216
00:07:50,080 --> 00:07:54,240
haven't connected this endpoint with a

217
00:07:51,840 --> 00:07:56,878
definition that we provided before

218
00:07:54,240 --> 00:07:58,080
so inside the 200 we can also provide a

219
00:07:56,879 --> 00:08:00,160
schema

220
00:07:58,080 --> 00:08:02,639
and this will mean that the the body

221
00:08:00,160 --> 00:08:04,639
will uh

222
00:08:02,639 --> 00:08:06,319
will have this this schema that we

223
00:08:04,639 --> 00:08:08,720
provide now definitions

224
00:08:06,319 --> 00:08:11,039
path so this is basically how we connect

225
00:08:08,720 --> 00:08:14,800
this endpoint to the to the object with

226
00:08:11,039 --> 00:08:16,400
just defined so as i said before the the

227
00:08:14,800 --> 00:08:19,599
power of swag is that it comes with

228
00:08:16,400 --> 00:08:20,960
some tools uh that are really are really

229
00:08:19,599 --> 00:08:23,280
helpful

230
00:08:20,960 --> 00:08:24,719
first of all swagger ui it's it's

231
00:08:23,280 --> 00:08:27,840
basically um

232
00:08:24,720 --> 00:08:28,400
sort of like a web server that shows you

233
00:08:27,840 --> 00:08:31,198
a

234
00:08:28,400 --> 00:08:31,919
web representation of your spec and you

235
00:08:31,199 --> 00:08:34,000
can actually

236
00:08:31,919 --> 00:08:35,519
uh navigate through your endpoints and

237
00:08:34,000 --> 00:08:38,080
see the

238
00:08:35,519 --> 00:08:38,799
the description of every endpoint and

239
00:08:38,080 --> 00:08:40,959
also

240
00:08:38,799 --> 00:08:42,478
really useful the the swagger editor

241
00:08:40,958 --> 00:08:44,239
this is really similar to the

242
00:08:42,479 --> 00:08:45,600
uh to swagger eye there is the one on

243
00:08:44,240 --> 00:08:46,080
the right but on the left you can

244
00:08:45,600 --> 00:08:48,800
actually

245
00:08:46,080 --> 00:08:51,360
see the spec file and edit them and see

246
00:08:48,800 --> 00:08:54,319
in real time how things are changing

247
00:08:51,360 --> 00:08:56,240
so out of these we will uh we actually

248
00:08:54,320 --> 00:08:58,399
discovered that we can't call get

249
00:08:56,240 --> 00:08:59,600
pat corgi because that parameter should

250
00:08:58,399 --> 00:09:02,880
be of type m

251
00:08:59,600 --> 00:09:04,800
so we'd rather call get pat 42 or

252
00:09:02,880 --> 00:09:07,839
something like that

253
00:09:04,800 --> 00:09:09,040
so as i said swagger comes with a lot of

254
00:09:07,839 --> 00:09:11,680
tools

255
00:09:09,040 --> 00:09:13,360
and one tools that is also available is

256
00:09:11,680 --> 00:09:14,880
swagger cogen

257
00:09:13,360 --> 00:09:16,480
and that is the one we're going to talk

258
00:09:14,880 --> 00:09:18,240
about we're going to talk about today so

259
00:09:16,480 --> 00:09:21,279
swagger coding is

260
00:09:18,240 --> 00:09:23,120
yeah again open source is available on

261
00:09:21,279 --> 00:09:24,000
on github and it's basically a tool that

262
00:09:23,120 --> 00:09:27,360
allows to generate

263
00:09:24,000 --> 00:09:30,320
code out of your swagger spec files uh

264
00:09:27,360 --> 00:09:31,760
it's available on swagger dash api slash

265
00:09:30,320 --> 00:09:34,560
swagger cogen

266
00:09:31,760 --> 00:09:35,920
on github it's actually really active

267
00:09:34,560 --> 00:09:36,880
over there so i really invite you to

268
00:09:35,920 --> 00:09:39,360
take a look

269
00:09:36,880 --> 00:09:40,560
uh to give you like a super fast

270
00:09:39,360 --> 00:09:41,760
introduction to the project it's

271
00:09:40,560 --> 00:09:45,599
basically composed by

272
00:09:41,760 --> 00:09:47,760
two parts there is the generator code

273
00:09:45,600 --> 00:09:50,240
so the the code that is responsible of

274
00:09:47,760 --> 00:09:51,839
reading the spec file like analyzing

275
00:09:50,240 --> 00:09:54,320
it and then there are like a set of

276
00:09:51,839 --> 00:09:55,920
templates file that will be populated

277
00:09:54,320 --> 00:09:58,000
with the value that are parsed by the

278
00:09:55,920 --> 00:09:59,920
generator

279
00:09:58,000 --> 00:10:01,760
so there are actually a lot of templates

280
00:09:59,920 --> 00:10:03,519
that are already available online

281
00:10:01,760 --> 00:10:05,040
and you can use them as as an

282
00:10:03,519 --> 00:10:06,160
inspiration you can start from that but

283
00:10:05,040 --> 00:10:09,760
it might not fit

284
00:10:06,160 --> 00:10:10,480
your needs and also it swagger coding

285
00:10:09,760 --> 00:10:12,240
comes

286
00:10:10,480 --> 00:10:14,160
by default as a command line tool so

287
00:10:12,240 --> 00:10:16,480
ideally you should call it like

288
00:10:14,160 --> 00:10:17,519
java dash jar and the jar of zarger code

289
00:10:16,480 --> 00:10:20,880
and then pass everything

290
00:10:17,519 --> 00:10:24,000
in there are some plugins to to plug it

291
00:10:20,880 --> 00:10:24,720
in some build system but as an android

292
00:10:24,000 --> 00:10:28,000
developer

293
00:10:24,720 --> 00:10:31,040
uh i don't find it really um like

294
00:10:28,000 --> 00:10:32,160
it doesn't really fit my workflow and

295
00:10:31,040 --> 00:10:35,839
then this

296
00:10:32,160 --> 00:10:37,360
is like why we will like we end up

297
00:10:35,839 --> 00:10:39,360
i ended up developing something

298
00:10:37,360 --> 00:10:41,680
something different this is

299
00:10:39,360 --> 00:10:42,399
the list of templates that are already

300
00:10:41,680 --> 00:10:44,399
available

301
00:10:42,399 --> 00:10:46,320
there are templates for server like you

302
00:10:44,399 --> 00:10:48,000
can generate your server stops

303
00:10:46,320 --> 00:10:49,839
but there are also a lot of templates

304
00:10:48,000 --> 00:10:53,680
for clients so

305
00:10:49,839 --> 00:10:54,800
uh yeah gold java rust whatsoever there

306
00:10:53,680 --> 00:10:59,199
is actually

307
00:10:54,800 --> 00:11:01,519
kotlin also but the java one

308
00:10:59,200 --> 00:11:04,720
there are multiples specifically there

309
00:11:01,519 --> 00:11:07,680
is okay http retrofit 1x and retrofit

310
00:11:04,720 --> 00:11:08,560
2x but there is nothing for coupling

311
00:11:07,680 --> 00:11:10,880
like there's just

312
00:11:08,560 --> 00:11:13,439
plain cotton i don't know if that got

313
00:11:10,880 --> 00:11:15,760
updated recently but

314
00:11:13,440 --> 00:11:16,640
that might not fit what what is your

315
00:11:15,760 --> 00:11:18,319
actual stack

316
00:11:16,640 --> 00:11:20,480
and this is how like a template looks

317
00:11:18,320 --> 00:11:23,040
like it's actually a mustache file

318
00:11:20,480 --> 00:11:24,160
so if you're not used to that it's

319
00:11:23,040 --> 00:11:26,560
something like this

320
00:11:24,160 --> 00:11:28,399
so you have like a lot of tags and this

321
00:11:26,560 --> 00:11:29,040
text will be populated by property and

322
00:11:28,399 --> 00:11:32,560
you have

323
00:11:29,040 --> 00:11:36,480
some really limited

324
00:11:32,560 --> 00:11:40,000
computational logic so for example here

325
00:11:36,480 --> 00:11:42,560
we are saying like if like the tag

326
00:11:40,000 --> 00:11:43,600
with a hashtag means if there is a

327
00:11:42,560 --> 00:11:46,479
description

328
00:11:43,600 --> 00:11:47,600
print those characters like slash as

329
00:11:46,480 --> 00:11:50,160
there is casters because it's

330
00:11:47,600 --> 00:11:50,720
javadoc and then print the description

331
00:11:50,160 --> 00:11:53,920
and then

332
00:11:50,720 --> 00:11:56,560
close this context so it's like

333
00:11:53,920 --> 00:11:57,680
it's not really handy to work with those

334
00:11:56,560 --> 00:12:00,800
template files you

335
00:11:57,680 --> 00:12:02,239
might have to do some tricks and that's

336
00:12:00,800 --> 00:12:04,800
why

337
00:12:02,240 --> 00:12:07,360
uh i ended up developing this tool

338
00:12:04,800 --> 00:12:10,880
called swagger gradle cogen

339
00:12:07,360 --> 00:12:14,160
so it's it's open source is on apache 2

340
00:12:10,880 --> 00:12:16,480
license uh it's available on github

341
00:12:14,160 --> 00:12:18,480
so i developed this as part of uh like

342
00:12:16,480 --> 00:12:20,800
when i was in my former company so you

343
00:12:18,480 --> 00:12:23,120
will find it on the yelp org

344
00:12:20,800 --> 00:12:24,479
but i'm actually i'm not working there

345
00:12:23,120 --> 00:12:27,760
anymore but i'm still like

346
00:12:24,480 --> 00:12:29,760
uh heavily contributing over there

347
00:12:27,760 --> 00:12:31,680
and i find a project really interesting

348
00:12:29,760 --> 00:12:32,319
so yeah that's that's the reason why

349
00:12:31,680 --> 00:12:34,719
it's there

350
00:12:32,320 --> 00:12:38,720
and what is actually swagger gradle

351
00:12:34,720 --> 00:12:42,000
coding is actually a gradle plugin

352
00:12:38,720 --> 00:12:43,120
that fits a bit better inside a

353
00:12:42,000 --> 00:12:47,839
classical like

354
00:12:43,120 --> 00:12:49,680
android or kotlin library build system

355
00:12:47,839 --> 00:12:51,120
and as some feature is actually input

356
00:12:49,680 --> 00:12:53,599
output aware

357
00:12:51,120 --> 00:12:54,880
that means that um the gradle plugin is

358
00:12:53,600 --> 00:12:55,600
able to understand if you change your

359
00:12:54,880 --> 00:12:59,120
spec

360
00:12:55,600 --> 00:13:01,600
and will rebuild stuff if needed or not

361
00:12:59,120 --> 00:13:02,320
while a common line interface will just

362
00:13:01,600 --> 00:13:05,360
like you know

363
00:13:02,320 --> 00:13:07,120
redo all the the building every time as

364
00:13:05,360 --> 00:13:09,760
a simpler api for the developer

365
00:13:07,120 --> 00:13:10,560
so zwarkie kojon the the original

366
00:13:09,760 --> 00:13:12,319
swagger code

367
00:13:10,560 --> 00:13:14,719
is extremely powerful but has a lot of

368
00:13:12,320 --> 00:13:16,880
properties and the majority like

369
00:13:14,720 --> 00:13:18,480
a lot of them are actually not needed

370
00:13:16,880 --> 00:13:22,160
for android engineers

371
00:13:18,480 --> 00:13:25,120
so we like i sort of like uh hide

372
00:13:22,160 --> 00:13:27,120
a lot of them under like a simpler api

373
00:13:25,120 --> 00:13:27,680
to use so the idea is just like plug and

374
00:13:27,120 --> 00:13:29,519
play

375
00:13:27,680 --> 00:13:32,560
plug this plug-in and you will be ready

376
00:13:29,519 --> 00:13:34,240
with your code in a couple of minutes

377
00:13:32,560 --> 00:13:35,839
and the second important thing is that

378
00:13:34,240 --> 00:13:39,120
this tool is opinionated

379
00:13:35,839 --> 00:13:40,240
like this tool is built around uh the

380
00:13:39,120 --> 00:13:42,079
one that i consider

381
00:13:40,240 --> 00:13:43,440
probably the most common android

382
00:13:42,079 --> 00:13:46,959
developer stack

383
00:13:43,440 --> 00:13:50,480
there is cuddling rx java 2 or curtains

384
00:13:46,959 --> 00:13:52,880
retrofit moshi uh so retrofit for rest

385
00:13:50,480 --> 00:13:56,399
abstraction mashi for json parsing and

386
00:13:52,880 --> 00:13:57,600
treating abp for dates um this might not

387
00:13:56,399 --> 00:13:59,279
fit your needs like

388
00:13:57,600 --> 00:14:01,360
if if you don't use marshy this tool

389
00:13:59,279 --> 00:14:03,600
will not work for you

390
00:14:01,360 --> 00:14:05,760
but nowadays i think this is like the

391
00:14:03,600 --> 00:14:08,880
most popular android libraries out there

392
00:14:05,760 --> 00:14:09,680
so the templates inside the project will

393
00:14:08,880 --> 00:14:13,279
use

394
00:14:09,680 --> 00:14:16,479
this uh so let's let's go back to our

395
00:14:13,279 --> 00:14:18,399
vloggers pack this one pat and category

396
00:14:16,480 --> 00:14:20,480
and let's see what the generated code

397
00:14:18,399 --> 00:14:23,920
will look like more or less

398
00:14:20,480 --> 00:14:25,839
so uh category so yeah obviously this

399
00:14:23,920 --> 00:14:28,160
would be represented by a class

400
00:14:25,839 --> 00:14:30,160
uh we are in kotlin so why not using a

401
00:14:28,160 --> 00:14:31,920
data class it comes with a lot of nd

402
00:14:30,160 --> 00:14:34,639
functions out of the box

403
00:14:31,920 --> 00:14:35,360
and there would be two properties id and

404
00:14:34,639 --> 00:14:37,360
name

405
00:14:35,360 --> 00:14:38,720
from the format we can like infer the

406
00:14:37,360 --> 00:14:42,639
type so it will be

407
00:14:38,720 --> 00:14:44,800
a id of type long name of type string

408
00:14:42,639 --> 00:14:45,760
there are both optional they are not

409
00:14:44,800 --> 00:14:48,240
required so

410
00:14:45,760 --> 00:14:50,079
we can mark the type as optional and we

411
00:14:48,240 --> 00:14:53,120
can actually initialize them

412
00:14:50,079 --> 00:14:55,359
as null so

413
00:14:53,120 --> 00:14:56,160
obviously as i said um everything works

414
00:14:55,360 --> 00:14:59,839
with moshi

415
00:14:56,160 --> 00:15:02,000
so class classes will be annotated with

416
00:14:59,839 --> 00:15:03,440
json so that the parser is like more

417
00:15:02,000 --> 00:15:07,040
resilient and knows where to put

418
00:15:03,440 --> 00:15:10,320
everything and this is basically how um

419
00:15:07,040 --> 00:15:13,599
yeah how your class will look like

420
00:15:10,320 --> 00:15:16,160
if you are uh like a good developer

421
00:15:13,600 --> 00:15:17,360
and you like have uh descriptions in

422
00:15:16,160 --> 00:15:20,560
your swagger

423
00:15:17,360 --> 00:15:21,600
file as i suggested before you will also

424
00:15:20,560 --> 00:15:25,119
have it

425
00:15:21,600 --> 00:15:27,120
uh populated in your kdog annotations uh

426
00:15:25,120 --> 00:15:28,560
that is really really handy because when

427
00:15:27,120 --> 00:15:29,600
you check documentations and you have

428
00:15:28,560 --> 00:15:32,638
all those

429
00:15:29,600 --> 00:15:34,240
classes you immediately see what those

430
00:15:32,639 --> 00:15:35,680
properties are doing directly from your

431
00:15:34,240 --> 00:15:37,759
swagger specs

432
00:15:35,680 --> 00:15:38,719
let's go on the on the more complex one

433
00:15:37,759 --> 00:15:40,959
like pat

434
00:15:38,720 --> 00:15:42,399
again a data class everything already

435
00:15:40,959 --> 00:15:43,839
annotated there are a couple of things

436
00:15:42,399 --> 00:15:46,720
to notice here

437
00:15:43,839 --> 00:15:47,199
uh so for example the name was required

438
00:15:46,720 --> 00:15:49,600
so

439
00:15:47,199 --> 00:15:50,719
we can set the type as non-nullable

440
00:15:49,600 --> 00:15:52,959
string

441
00:15:50,720 --> 00:15:55,120
and we don't need to we can't initialize

442
00:15:52,959 --> 00:15:58,160
it to now so you need to provide a name

443
00:15:55,120 --> 00:16:01,199
you can't create this class otherwise uh

444
00:15:58,160 --> 00:16:02,880
the photo urls in the swaggers

445
00:16:01,199 --> 00:16:05,599
in the vargas pack we mentioned that is

446
00:16:02,880 --> 00:16:07,519
an array and on kotlin we convert it to

447
00:16:05,600 --> 00:16:10,639
a list because it's either easier to

448
00:16:07,519 --> 00:16:12,720
to to deal with and

449
00:16:10,639 --> 00:16:13,839
again we have a category so the

450
00:16:12,720 --> 00:16:16,880
generator is

451
00:16:13,839 --> 00:16:19,040
correctly linking this property called

452
00:16:16,880 --> 00:16:22,959
category to the class that we previously

453
00:16:19,040 --> 00:16:25,839
defined and again we have a enum

454
00:16:22,959 --> 00:16:27,279
this enum is generated as an inline

455
00:16:25,839 --> 00:16:30,399
sorry as a

456
00:16:27,279 --> 00:16:33,279
inner enum and yeah it's available there

457
00:16:30,399 --> 00:16:36,399
and again everything is annotated

458
00:16:33,279 --> 00:16:38,560
and again provide augmentation strings

459
00:16:36,399 --> 00:16:39,920
it would be helpful for you like you

460
00:16:38,560 --> 00:16:42,239
will have it there

461
00:16:39,920 --> 00:16:43,040
then let's go to the to the end point so

462
00:16:42,240 --> 00:16:46,240
get pat

463
00:16:43,040 --> 00:16:48,319
pat pat's id so

464
00:16:46,240 --> 00:16:49,440
as i said we generate retrofit

465
00:16:48,320 --> 00:16:51,920
interfaces

466
00:16:49,440 --> 00:16:52,720
so there will be a default api with a

467
00:16:51,920 --> 00:16:55,120
function

468
00:16:52,720 --> 00:16:57,199
called getpat by id this is where the

469
00:16:55,120 --> 00:17:00,639
operation id comes handy because

470
00:16:57,199 --> 00:17:01,599
we need a unique name to identify this

471
00:17:00,639 --> 00:17:05,199
operation

472
00:17:01,600 --> 00:17:08,400
and we we got it from the spec

473
00:17:05,199 --> 00:17:09,439
and then we uh provide all the

474
00:17:08,400 --> 00:17:11,280
parameters

475
00:17:09,439 --> 00:17:13,199
so in this case there is only one is

476
00:17:11,280 --> 00:17:15,359
called para id is long

477
00:17:13,199 --> 00:17:16,880
and is annotated with the retrofit to

478
00:17:15,359 --> 00:17:18,799
annotation at path

479
00:17:16,880 --> 00:17:20,480
so this will end up in the path and

480
00:17:18,799 --> 00:17:23,599
again also we have to annotate

481
00:17:20,480 --> 00:17:24,400
the function with our at get annotation

482
00:17:23,599 --> 00:17:27,119
and the proper

483
00:17:24,400 --> 00:17:27,520
url there is one thing that is missing

484
00:17:27,119 --> 00:17:30,799
here

485
00:17:27,520 --> 00:17:31,600
is the return type this is where the rx

486
00:17:30,799 --> 00:17:34,720
java

487
00:17:31,600 --> 00:17:36,399
2 wiring happens so in this case if you

488
00:17:34,720 --> 00:17:39,280
use the rx java 2

489
00:17:36,400 --> 00:17:39,919
template this will generate a normal

490
00:17:39,280 --> 00:17:42,160
function that

491
00:17:39,919 --> 00:17:42,960
returns a single of a path if you

492
00:17:42,160 --> 00:17:44,880
instead

493
00:17:42,960 --> 00:17:46,720
switch to use keratins this will

494
00:17:44,880 --> 00:17:50,160
generate a suspending function that

495
00:17:46,720 --> 00:17:53,280
returns just a bet and if you

496
00:17:50,160 --> 00:17:56,480
use retrofit 2.7 i think it will

497
00:17:53,280 --> 00:18:00,639
work correctly so you will have like the

498
00:17:56,480 --> 00:18:03,200
asynchronous pattern that you prefer

499
00:18:00,640 --> 00:18:05,679
there is a header called x operation id

500
00:18:03,200 --> 00:18:07,440
this is like a header that we wanted to

501
00:18:05,679 --> 00:18:09,600
add like on every request

502
00:18:07,440 --> 00:18:11,200
and is basically a way to pass over the

503
00:18:09,600 --> 00:18:12,959
operation id but you can change it if

504
00:18:11,200 --> 00:18:16,000
you want just like edit the

505
00:18:12,960 --> 00:18:18,080
template and then yeah again

506
00:18:16,000 --> 00:18:19,200
you will have the documentation of your

507
00:18:18,080 --> 00:18:21,360
endpoint over there

508
00:18:19,200 --> 00:18:23,200
if you provide it and this is basically

509
00:18:21,360 --> 00:18:23,760
how the final class will look like with

510
00:18:23,200 --> 00:18:27,039
all the

511
00:18:23,760 --> 00:18:28,720
imports the package and italy will

512
00:18:27,039 --> 00:18:31,039
compile

513
00:18:28,720 --> 00:18:33,280
so how you use this plugin there are

514
00:18:31,039 --> 00:18:34,960
some use cases like you can it's a

515
00:18:33,280 --> 00:18:36,480
greater plugin so you can plug it to

516
00:18:34,960 --> 00:18:39,360
whatever is a is a gradle

517
00:18:36,480 --> 00:18:40,000
module basically if you have like just

518
00:18:39,360 --> 00:18:41,439
just a

519
00:18:40,000 --> 00:18:43,200
app module like you don't do

520
00:18:41,440 --> 00:18:44,080
modularization at all you have a super

521
00:18:43,200 --> 00:18:46,880
small app

522
00:18:44,080 --> 00:18:48,639
you can just plug it there and specify

523
00:18:46,880 --> 00:18:51,440
where you want your generated code

524
00:18:48,640 --> 00:18:51,760
to end up and that will work but if you

525
00:18:51,440 --> 00:18:54,880
have

526
00:18:51,760 --> 00:18:57,440
modularization maybe you want to have a

527
00:18:54,880 --> 00:18:58,240
pure kotlin module that contains this

528
00:18:57,440 --> 00:19:01,679
code

529
00:18:58,240 --> 00:19:03,200
or a library an android library project

530
00:19:01,679 --> 00:19:06,559
that contains

531
00:19:03,200 --> 00:19:09,280
again the code all the modules and api

532
00:19:06,559 --> 00:19:11,039
and if you are in a bigger org or you

533
00:19:09,280 --> 00:19:13,360
want a more structured approach

534
00:19:11,039 --> 00:19:17,039
or what i really suggest is to integrate

535
00:19:13,360 --> 00:19:19,840
these within your ci system

536
00:19:17,039 --> 00:19:20,480
um so let's see how you can like

537
00:19:19,840 --> 00:19:22,320
configure

538
00:19:20,480 --> 00:19:24,960
the plugin and now you can integrate it

539
00:19:22,320 --> 00:19:28,240
in your in your ci so

540
00:19:24,960 --> 00:19:29,679
you define the class path dependency for

541
00:19:28,240 --> 00:19:31,520
the plugin

542
00:19:29,679 --> 00:19:33,039
uh communal code gen plugin the latest

543
00:19:31,520 --> 00:19:35,120
version is 130

544
00:19:33,039 --> 00:19:36,879
and then you need to you need to provide

545
00:19:35,120 --> 00:19:38,959
this generate swagger block

546
00:19:36,880 --> 00:19:40,720
and over there all the properties that

547
00:19:38,960 --> 00:19:43,360
are needed for the generation

548
00:19:40,720 --> 00:19:43,760
so specifically the the there is only

549
00:19:43,360 --> 00:19:45,439
one

550
00:19:43,760 --> 00:19:47,280
required property that you need to

551
00:19:45,440 --> 00:19:50,799
provide and is the swag

552
00:19:47,280 --> 00:19:52,480
the swagger spec file like this plugin

553
00:19:50,799 --> 00:19:54,240
is not a wizard like if you don't

554
00:19:52,480 --> 00:19:57,280
provide a spec file

555
00:19:54,240 --> 00:20:00,320
nothing will actually work so

556
00:19:57,280 --> 00:20:01,200
then the output directory and other

557
00:20:00,320 --> 00:20:03,918
properties like

558
00:20:01,200 --> 00:20:04,799
uh which platform you want to use the

559
00:20:03,919 --> 00:20:07,919
package name

560
00:20:04,799 --> 00:20:10,480
and other stuff so this this plugin

561
00:20:07,919 --> 00:20:11,600
will basically do just one thing to your

562
00:20:10,480 --> 00:20:14,880
build system will

563
00:20:11,600 --> 00:20:17,039
offer you one extra task

564
00:20:14,880 --> 00:20:19,360
that you need to call we not do auto

565
00:20:17,039 --> 00:20:20,559
magic this task is called generate

566
00:20:19,360 --> 00:20:23,120
swagger

567
00:20:20,559 --> 00:20:24,960
and the fact that we don't modify the

568
00:20:23,120 --> 00:20:25,360
build system is actually intentional we

569
00:20:24,960 --> 00:20:28,000
leave

570
00:20:25,360 --> 00:20:30,080
this like my idea was to leave this duty

571
00:20:28,000 --> 00:20:31,679
to the developer like it's up to you to

572
00:20:30,080 --> 00:20:33,199
decide if you want to hook

573
00:20:31,679 --> 00:20:35,120
everything within your normal build and

574
00:20:33,200 --> 00:20:36,480
rebuild every time or not

575
00:20:35,120 --> 00:20:38,879
so what you can do you can say for

576
00:20:36,480 --> 00:20:41,440
example pre-build depends on

577
00:20:38,880 --> 00:20:42,720
and you get this generate a swagger task

578
00:20:41,440 --> 00:20:46,080
in that case

579
00:20:42,720 --> 00:20:49,600
what will happen is that there is this

580
00:20:46,080 --> 00:20:53,039
this is like a random assemble build

581
00:20:49,600 --> 00:20:54,799
and you have this pre-built

582
00:20:53,039 --> 00:20:56,240
gradle task where you can hook

583
00:20:54,799 --> 00:20:59,600
everything there

584
00:20:56,240 --> 00:21:01,679
that needs to be executed before

585
00:20:59,600 --> 00:21:02,879
the build starts so you could say like

586
00:21:01,679 --> 00:21:05,039
hey before building

587
00:21:02,880 --> 00:21:06,559
just call this generate swagger generate

588
00:21:05,039 --> 00:21:10,000
all the code and then actually

589
00:21:06,559 --> 00:21:11,120
build my app and now let's see how you

590
00:21:10,000 --> 00:21:14,559
can actually

591
00:21:11,120 --> 00:21:16,959
generate your code inside a ci

592
00:21:14,559 --> 00:21:17,678
and i have like a sort of a small

593
00:21:16,960 --> 00:21:19,440
pipeline

594
00:21:17,679 --> 00:21:21,200
to generate your code and what are the

595
00:21:19,440 --> 00:21:23,280
benefits

596
00:21:21,200 --> 00:21:24,880
so i assume you have your swagger

597
00:21:23,280 --> 00:21:28,480
specified somewhere

598
00:21:24,880 --> 00:21:30,080
ideally in a git repo or somewhere else

599
00:21:28,480 --> 00:21:32,000
you'd need to have some sort of a

600
00:21:30,080 --> 00:21:36,080
webhook mechanism

601
00:21:32,000 --> 00:21:39,440
to trigger a ci build so you will invoke

602
00:21:36,080 --> 00:21:43,199
your jenkins travis gitlab ci

603
00:21:39,440 --> 00:21:45,360
whatsoever tool you want and

604
00:21:43,200 --> 00:21:46,720
ideally you you need to have like a

605
00:21:45,360 --> 00:21:48,719
skeleton project

606
00:21:46,720 --> 00:21:50,000
you can take one uh that is inside the

607
00:21:48,720 --> 00:21:53,039
apple in the samples

608
00:21:50,000 --> 00:21:55,039
folder or you can craft your own so

609
00:21:53,039 --> 00:21:56,400
what's what's the idea behind this this

610
00:21:55,039 --> 00:21:59,440
skeleton project

611
00:21:56,400 --> 00:22:01,039
this skeleton project will uh like erci

612
00:21:59,440 --> 00:22:04,320
will be responsible of fetching

613
00:22:01,039 --> 00:22:07,600
the sp the updated spec file inside

614
00:22:04,320 --> 00:22:08,399
this skeleton project calling generate

615
00:22:07,600 --> 00:22:10,158
swagger

616
00:22:08,400 --> 00:22:13,120
like calling gradle generates wagger so

617
00:22:10,159 --> 00:22:16,240
all the code will be generated

618
00:22:13,120 --> 00:22:18,320
then you can actually run tests like

619
00:22:16,240 --> 00:22:19,919
the power of these is that you can have

620
00:22:18,320 --> 00:22:23,678
integration tests

621
00:22:19,919 --> 00:22:25,840
that test your generated code against

622
00:22:23,679 --> 00:22:27,440
like a mocked environment or some

623
00:22:25,840 --> 00:22:30,639
environment that

624
00:22:27,440 --> 00:22:31,280
runs your swagger spec implementation so

625
00:22:30,640 --> 00:22:34,000
like

626
00:22:31,280 --> 00:22:35,520
you test that what what you generated is

627
00:22:34,000 --> 00:22:36,799
actually working

628
00:22:35,520 --> 00:22:40,559
once the tests are green you can

629
00:22:36,799 --> 00:22:43,679
assemble so you have like an archive and

630
00:22:40,559 --> 00:22:46,158
yeah so you have like a basically a aar

631
00:22:43,679 --> 00:22:46,799
or a jar based on what you want to to

632
00:22:46,159 --> 00:22:48,400
build

633
00:22:46,799 --> 00:22:50,960
and then once that is ready you just

634
00:22:48,400 --> 00:22:52,320
call publish and that it's on you if you

635
00:22:50,960 --> 00:22:55,520
want to put it like

636
00:22:52,320 --> 00:22:58,320
on a private maven repository

637
00:22:55,520 --> 00:22:59,760
or on something public uh like if you're

638
00:22:58,320 --> 00:23:03,200
maintaining

639
00:22:59,760 --> 00:23:03,919
public apis like i don't know apis for

640
00:23:03,200 --> 00:23:05,919
weather

641
00:23:03,919 --> 00:23:08,000
services whatever you could actually

642
00:23:05,919 --> 00:23:12,000
have a pipeline that generates

643
00:23:08,000 --> 00:23:12,480
like uh an android sdk implementation of

644
00:23:12,000 --> 00:23:15,039
that

645
00:23:12,480 --> 00:23:16,640
that it's rebuilt every time that you

646
00:23:15,039 --> 00:23:18,240
change the swagger spec

647
00:23:16,640 --> 00:23:20,799
so at the end of the day who is

648
00:23:18,240 --> 00:23:22,480
consuming those generated code will end

649
00:23:20,799 --> 00:23:23,520
up having something like this like

650
00:23:22,480 --> 00:23:26,159
implementation

651
00:23:23,520 --> 00:23:26,960
com corgi samples generated api and the

652
00:23:26,159 --> 00:23:29,440
version

653
00:23:26,960 --> 00:23:31,840
and the the power of this is first that

654
00:23:29,440 --> 00:23:34,159
you have versioning like you have a

655
00:23:31,840 --> 00:23:36,158
strict versioning system to go back in

656
00:23:34,159 --> 00:23:39,520
the history and knowing

657
00:23:36,159 --> 00:23:42,880
which version of the generated code

658
00:23:39,520 --> 00:23:45,840
is what like this is

659
00:23:42,880 --> 00:23:47,440
swagger spec file generated this r and

660
00:23:45,840 --> 00:23:48,720
those are the

661
00:23:47,440 --> 00:23:51,039
files that are inside so you can

662
00:23:48,720 --> 00:23:54,480
actually go back in time

663
00:23:51,039 --> 00:23:55,440
and yeah basically the power is that you

664
00:23:54,480 --> 00:23:59,120
have this

665
00:23:55,440 --> 00:24:03,440
bundle with all of your retrofit apis

666
00:23:59,120 --> 00:24:06,239
and the data classes

667
00:24:03,440 --> 00:24:09,039
so and again the fact that you consume

668
00:24:06,240 --> 00:24:11,760
this as a third-party library basically

669
00:24:09,039 --> 00:24:12,879
is that it's read-only so if you are in

670
00:24:11,760 --> 00:24:14,640
a bigger org or

671
00:24:12,880 --> 00:24:16,720
you're in a bigger project and you want

672
00:24:14,640 --> 00:24:19,200
to enforce that those

673
00:24:16,720 --> 00:24:20,000
files are like the same they don't

674
00:24:19,200 --> 00:24:22,559
change

675
00:24:20,000 --> 00:24:23,279
like people can't actually touch them

676
00:24:22,559 --> 00:24:25,760
this is like

677
00:24:23,279 --> 00:24:26,640
uh a great way to enforce that your

678
00:24:25,760 --> 00:24:29,039
network model

679
00:24:26,640 --> 00:24:30,159
and your network interfaces are actually

680
00:24:29,039 --> 00:24:33,520
one by one

681
00:24:30,159 --> 00:24:36,640
with the swagger spec file so

682
00:24:33,520 --> 00:24:37,918
uh yeah that's that's all i want to

683
00:24:36,640 --> 00:24:38,559
spend a couple of minutes actually

684
00:24:37,919 --> 00:24:41,440
talking about

685
00:24:38,559 --> 00:24:42,639
challenges and future like a little bit

686
00:24:41,440 --> 00:24:46,400
of road map like what's

687
00:24:42,640 --> 00:24:48,640
what's coming next so challenges

688
00:24:46,400 --> 00:24:50,559
when generating code you have to shift a

689
00:24:48,640 --> 00:24:52,720
little bit your perspective

690
00:24:50,559 --> 00:24:55,600
um i actually invite you to read one

691
00:24:52,720 --> 00:24:58,640
blog post from jay corton that is called

692
00:24:55,600 --> 00:25:00,000
changing the mindset

693
00:24:58,640 --> 00:25:01,679
when doing code generation but if you

694
00:25:00,000 --> 00:25:02,159
search j corten code generation you will

695
00:25:01,679 --> 00:25:04,559
find it

696
00:25:02,159 --> 00:25:06,000
is actually really interesting and there

697
00:25:04,559 --> 00:25:09,120
are some

698
00:25:06,000 --> 00:25:10,400
um some scenarios or problems that arise

699
00:25:09,120 --> 00:25:11,039
only when you're actually generating

700
00:25:10,400 --> 00:25:14,159
code

701
00:25:11,039 --> 00:25:17,760
not when you're writing it normally

702
00:25:14,159 --> 00:25:19,919
the first one this is actually not only

703
00:25:17,760 --> 00:25:21,200
for code generation but encoderation is

704
00:25:19,919 --> 00:25:24,320
it's really dangerous

705
00:25:21,200 --> 00:25:26,559
it's it's breaking changes like

706
00:25:24,320 --> 00:25:28,799
or changes they're actually breaking the

707
00:25:26,559 --> 00:25:30,960
implementation of your app

708
00:25:28,799 --> 00:25:32,879
let's see an example let's say you have

709
00:25:30,960 --> 00:25:35,520
a get pet by a d

710
00:25:32,880 --> 00:25:36,400
and point with two strings name and

711
00:25:35,520 --> 00:25:39,120
surname

712
00:25:36,400 --> 00:25:39,760
okay and then for some reason like you

713
00:25:39,120 --> 00:25:42,320
change

714
00:25:39,760 --> 00:25:43,679
something in i don't know israelis pac

715
00:25:42,320 --> 00:25:44,720
file or the implementation of the

716
00:25:43,679 --> 00:25:47,919
generator

717
00:25:44,720 --> 00:25:49,760
and you happen to invert the order of

718
00:25:47,919 --> 00:25:52,559
those two parameters

719
00:25:49,760 --> 00:25:53,120
what will happen is that uh this this

720
00:25:52,559 --> 00:25:56,399
code

721
00:25:53,120 --> 00:25:58,320
is both binary and source compatible

722
00:25:56,400 --> 00:26:00,080
on the user side so people will just

723
00:25:58,320 --> 00:26:03,200
bump the library will

724
00:26:00,080 --> 00:26:06,399
get other code and on on the on the call

725
00:26:03,200 --> 00:26:07,360
site is just get pet by the string comma

726
00:26:06,400 --> 00:26:09,919
string

727
00:26:07,360 --> 00:26:10,559
so nothing nothing will happen but

728
00:26:09,919 --> 00:26:12,480
actually

729
00:26:10,559 --> 00:26:13,678
you're passing the name as a surname and

730
00:26:12,480 --> 00:26:16,240
vice versa

731
00:26:13,679 --> 00:26:17,679
and this could be problematic if instead

732
00:26:16,240 --> 00:26:20,080
of having name and surname you actually

733
00:26:17,679 --> 00:26:23,360
have username and password

734
00:26:20,080 --> 00:26:25,360
so that is a problem and what i suggest

735
00:26:23,360 --> 00:26:26,158
for scenarios like these is actually

736
00:26:25,360 --> 00:26:29,600
having like

737
00:26:26,159 --> 00:26:31,679
um static analysis tools uh

738
00:26:29,600 --> 00:26:33,600
kotlin has a great feature called name

739
00:26:31,679 --> 00:26:35,919
parameters that prevents

740
00:26:33,600 --> 00:26:37,520
this kind of situation so you could say

741
00:26:35,919 --> 00:26:40,000
like get pet by d

742
00:26:37,520 --> 00:26:41,918
surname equal whatever expression

743
00:26:40,000 --> 00:26:44,960
variable that represents the surname

744
00:26:41,919 --> 00:26:45,679
and name equal and that will um like

745
00:26:44,960 --> 00:26:48,240
protect

746
00:26:45,679 --> 00:26:49,919
you against this kind of changes so just

747
00:26:48,240 --> 00:26:53,360
like a detect rule that detects

748
00:26:49,919 --> 00:26:56,080
whenever you use a generated call code

749
00:26:53,360 --> 00:26:58,158
and then like raise a warning if you're

750
00:26:56,080 --> 00:27:00,720
not using name parameters

751
00:26:58,159 --> 00:27:02,480
another problem is defining names so in

752
00:27:00,720 --> 00:27:03,120
swagger you can actually define models

753
00:27:02,480 --> 00:27:05,440
in line

754
00:27:03,120 --> 00:27:07,039
like you can have models inside models

755
00:27:05,440 --> 00:27:09,760
inside other models

756
00:27:07,039 --> 00:27:11,600
and those models don't have a name it's

757
00:27:09,760 --> 00:27:13,200
like an anonymous inner class in java

758
00:27:11,600 --> 00:27:15,678
it's like anonymous

759
00:27:13,200 --> 00:27:17,279
so but the generator needs to generate

760
00:27:15,679 --> 00:27:20,559
classes for that

761
00:27:17,279 --> 00:27:21,760
and needs a name and you might end up

762
00:27:20,559 --> 00:27:24,480
with classes that are like

763
00:27:21,760 --> 00:27:27,840
id to session info for customized result

764
00:27:24,480 --> 00:27:31,440
map to use their ui interaction map

765
00:27:27,840 --> 00:27:34,959
that's not cool like if you use

766
00:27:31,440 --> 00:27:36,720
import as like if you have big names you

767
00:27:34,960 --> 00:27:39,840
can save yourself using import

768
00:27:36,720 --> 00:27:41,279
name of the class as network model and

769
00:27:39,840 --> 00:27:43,520
you sort of save yourself

770
00:27:41,279 --> 00:27:44,799
but this is this is still a class and

771
00:27:43,520 --> 00:27:46,960
you will find it when you like

772
00:27:44,799 --> 00:27:48,000
type in your autocompletion so pay

773
00:27:46,960 --> 00:27:51,360
attention make sure that

774
00:27:48,000 --> 00:27:54,080
every model has a proper name

775
00:27:51,360 --> 00:27:54,399
uh and then accessing the raw response

776
00:27:54,080 --> 00:27:56,080
like

777
00:27:54,399 --> 00:27:58,639
what happens if you want to access a

778
00:27:56,080 --> 00:28:02,000
response header

779
00:27:58,640 --> 00:28:03,919
like i would do that like in retrofit

780
00:28:02,000 --> 00:28:05,120
what you need to do is wrap the response

781
00:28:03,919 --> 00:28:08,640
type inside our

782
00:28:05,120 --> 00:28:11,039
a result or a response object but

783
00:28:08,640 --> 00:28:12,000
this is coming from a template like if i

784
00:28:11,039 --> 00:28:14,158
change it for one

785
00:28:12,000 --> 00:28:16,000
endpoint i would change it for all the

786
00:28:14,159 --> 00:28:18,240
endpoints and if i have like i don't

787
00:28:16,000 --> 00:28:20,880
know 1 000 m points

788
00:28:18,240 --> 00:28:21,919
uh yeah that's going to be complicated

789
00:28:20,880 --> 00:28:24,480
so

790
00:28:21,919 --> 00:28:25,760
this is still an open challenge ideally

791
00:28:24,480 --> 00:28:29,520
one thing could be

792
00:28:25,760 --> 00:28:32,879
to uh like this is unsolved sort of

793
00:28:29,520 --> 00:28:34,799
uh ideally one idea could be to see if

794
00:28:32,880 --> 00:28:37,200
in the swaggers pack you have a response

795
00:28:34,799 --> 00:28:40,320
header and if it's defined there

796
00:28:37,200 --> 00:28:42,840
then change like offer to uh

797
00:28:40,320 --> 00:28:44,639
only for that end point access the raw

798
00:28:42,840 --> 00:28:47,039
response

799
00:28:44,640 --> 00:28:48,559
and yeah those are like some challenges

800
00:28:47,039 --> 00:28:50,879
that i faced

801
00:28:48,559 --> 00:28:52,960
and then like i have here the guy over

802
00:28:50,880 --> 00:28:55,279
there with the red t-shirt there is

803
00:28:52,960 --> 00:28:56,799
another top contributor of this project

804
00:28:55,279 --> 00:28:58,720
and i wanted to discuss a little bit

805
00:28:56,799 --> 00:28:59,918
like what's coming next like what are

806
00:28:58,720 --> 00:29:03,360
the challenges

807
00:28:59,919 --> 00:29:05,440
what are we working on um yeah so

808
00:29:03,360 --> 00:29:06,799
january 21st this year so like a couple

809
00:29:05,440 --> 00:29:10,000
of

810
00:29:06,799 --> 00:29:11,600
days ago we just released version 130

811
00:29:10,000 --> 00:29:13,840
and that offers support for cutting

812
00:29:11,600 --> 00:29:16,799
curtains that was actually

813
00:29:13,840 --> 00:29:17,760
requested a lot like very like i had a

814
00:29:16,799 --> 00:29:19,600
draft pr

815
00:29:17,760 --> 00:29:21,760
for curtins and a lot of people wrote

816
00:29:19,600 --> 00:29:24,639
like hey i need this now like please

817
00:29:21,760 --> 00:29:26,960
ship it and yeah we just didn't wanted

818
00:29:24,640 --> 00:29:28,880
to like mess up

819
00:29:26,960 --> 00:29:30,559
with the project so we had to like do a

820
00:29:28,880 --> 00:29:31,360
little bit of refactoring but now it's

821
00:29:30,559 --> 00:29:33,360
live

822
00:29:31,360 --> 00:29:34,479
so you can use it so there will be a

823
00:29:33,360 --> 00:29:37,760
version 1 4

824
00:29:34,480 --> 00:29:39,200
coming soon like months probably i don't

825
00:29:37,760 --> 00:29:40,720
know

826
00:29:39,200 --> 00:29:42,240
yeah there will be support for moshi

827
00:29:40,720 --> 00:29:45,600
cogen so

828
00:29:42,240 --> 00:29:49,039
right now this project is using uh mashi

829
00:29:45,600 --> 00:29:50,158
um kotlin that uses the kotlin json

830
00:29:49,039 --> 00:29:52,720
adapter factory

831
00:29:50,159 --> 00:29:53,760
they're inside uses cotton reflect so

832
00:29:52,720 --> 00:29:56,640
uses a reflection

833
00:29:53,760 --> 00:29:57,840
it's really heavy for the up size and

834
00:29:56,640 --> 00:30:01,039
it's really heavy at run

835
00:29:57,840 --> 00:30:02,720
time like creating like parsing stuff

836
00:30:01,039 --> 00:30:04,399
around so there would be mushy code and

837
00:30:02,720 --> 00:30:07,039
support

838
00:30:04,399 --> 00:30:08,639
uh it will be like it will not be a

839
00:30:07,039 --> 00:30:11,200
breaking change

840
00:30:08,640 --> 00:30:13,760
uh but at a certain point like there

841
00:30:11,200 --> 00:30:17,200
will be a truex version at

842
00:30:13,760 --> 00:30:19,600
some time this year ideally uh and

843
00:30:17,200 --> 00:30:21,360
we want to drop support from mashikalen

844
00:30:19,600 --> 00:30:24,799
like we want to have everything on

845
00:30:21,360 --> 00:30:27,600
on massive cogen because it's just

846
00:30:24,799 --> 00:30:29,200
it's just better like we prefer this

847
00:30:27,600 --> 00:30:32,000
approach

848
00:30:29,200 --> 00:30:34,000
then another important thing there is a

849
00:30:32,000 --> 00:30:36,720
hot topic is

850
00:30:34,000 --> 00:30:37,360
models inheritance so what happens if

851
00:30:36,720 --> 00:30:39,600
you have

852
00:30:37,360 --> 00:30:41,600
a model like swagger allows you to say

853
00:30:39,600 --> 00:30:45,600
that you have a pet

854
00:30:41,600 --> 00:30:48,399
as a model and you have a cat and a dog

855
00:30:45,600 --> 00:30:50,080
as a model so and you have like a

856
00:30:48,399 --> 00:30:51,678
discriminator field

857
00:30:50,080 --> 00:30:54,000
that comes through the wire so you will

858
00:30:51,679 --> 00:30:55,440
have like type and if it's a dog there

859
00:30:54,000 --> 00:30:56,000
will be the properties of a dog and if

860
00:30:55,440 --> 00:30:58,240
it's a cat

861
00:30:56,000 --> 00:30:59,200
they will be the properties of a cat

862
00:30:58,240 --> 00:31:01,600
yeah so

863
00:30:59,200 --> 00:31:02,720
in our case we decided to use data

864
00:31:01,600 --> 00:31:05,840
classes

865
00:31:02,720 --> 00:31:09,519
that don't play well with inheritance

866
00:31:05,840 --> 00:31:11,120
so um yeah we are working on a solution

867
00:31:09,519 --> 00:31:14,640
like specifically samuel is working on

868
00:31:11,120 --> 00:31:18,479
that it's working on a solution to

869
00:31:14,640 --> 00:31:21,279
have like a classier key with

870
00:31:18,480 --> 00:31:23,120
higher classes they are not data classes

871
00:31:21,279 --> 00:31:24,480
and lower classes there are actually

872
00:31:23,120 --> 00:31:26,239
like the the sun

873
00:31:24,480 --> 00:31:28,080
like the leaf of these three are

874
00:31:26,240 --> 00:31:29,919
actually data classes

875
00:31:28,080 --> 00:31:31,519
uh this will come we are still

876
00:31:29,919 --> 00:31:33,200
discussing on implementation

877
00:31:31,519 --> 00:31:35,200
you're actually more than welcome

878
00:31:33,200 --> 00:31:35,840
because a lot of the discussion happens

879
00:31:35,200 --> 00:31:39,360
online

880
00:31:35,840 --> 00:31:42,559
like on pull requests yeah and we're

881
00:31:39,360 --> 00:31:46,799
looking for contributors

882
00:31:42,559 --> 00:31:51,600
and that's all thank you very much

883
00:31:46,799 --> 00:31:51,600
and i'm happy to get questions

884
00:31:58,720 --> 00:32:02,720
if there are i know

885
00:32:05,840 --> 00:32:15,840
awesome thank you

886
00:32:16,640 --> 00:32:18,720
you

