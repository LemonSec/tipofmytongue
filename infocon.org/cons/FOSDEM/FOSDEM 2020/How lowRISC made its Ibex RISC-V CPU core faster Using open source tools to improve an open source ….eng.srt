1
00:00:05,520 --> 00:00:09,760
hi everyone uh my name is greg

2
00:00:07,040 --> 00:00:10,719
i am a i'm a hardware engineer from

3
00:00:09,760 --> 00:00:12,480
lowrisk

4
00:00:10,719 --> 00:00:14,480
uh previously i've worked at arm on

5
00:00:12,480 --> 00:00:16,160
a-class processors on memory systems and

6
00:00:14,480 --> 00:00:17,760
on broadcom and gpus and it's really

7
00:00:16,160 --> 00:00:18,640
great to finally be working on some open

8
00:00:17,760 --> 00:00:21,039
source hardware

9
00:00:18,640 --> 00:00:22,720
which is what we do at lowrisk so today

10
00:00:21,039 --> 00:00:25,199
i'm going to talk about ibex

11
00:00:22,720 --> 00:00:27,198
which is our our cpu core it's a

12
00:00:25,199 --> 00:00:29,359
microcontroller class cpu core

13
00:00:27,199 --> 00:00:30,560
uh two-stage pipeline very simple uh

14
00:00:29,359 --> 00:00:33,600
32-bit

15
00:00:30,560 --> 00:00:36,960
u-mode m-mode pnp um supports

16
00:00:33,600 --> 00:00:40,079
uh emc and imc um we've wrote this in

17
00:00:36,960 --> 00:00:42,399
system verilog and it came to us

18
00:00:40,079 --> 00:00:44,480
from the pulp team uh zurich which i'm

19
00:00:42,399 --> 00:00:46,079
sure many of you are familiar with um

20
00:00:44,480 --> 00:00:47,279
and where it was known as zero risky and

21
00:00:46,079 --> 00:00:48,239
we have picked it up and we've developed

22
00:00:47,280 --> 00:00:50,000
it from there and we've done a lot of

23
00:00:48,239 --> 00:00:51,760
work into improving the rtl

24
00:00:50,000 --> 00:00:53,760
uh and really um doing a lot of

25
00:00:51,760 --> 00:00:55,360
verification on it

26
00:00:53,760 --> 00:00:56,879
and so it's being developed by lowrisk

27
00:00:55,360 --> 00:00:59,920
which is the company i work for

28
00:00:56,879 --> 00:01:01,680
we are a not-for-profit company uh we

29
00:00:59,920 --> 00:01:03,199
work on open source silicon so we use

30
00:01:01,680 --> 00:01:04,640
collaborative engineering we work with

31
00:01:03,199 --> 00:01:07,439
various organizations

32
00:01:04,640 --> 00:01:09,600
to build open source hardware designs

33
00:01:07,439 --> 00:01:11,279
and a notable use of ibex is in our

34
00:01:09,600 --> 00:01:12,000
recently announced open title project

35
00:01:11,280 --> 00:01:13,920
that you may have heard

36
00:01:12,000 --> 00:01:15,920
of which is an open source silicon root

37
00:01:13,920 --> 00:01:16,400
of trust and we hope there's going to be

38
00:01:15,920 --> 00:01:18,000
many

39
00:01:16,400 --> 00:01:20,159
many more things it's going to be used

40
00:01:18,000 --> 00:01:20,159
in

41
00:01:20,320 --> 00:01:25,119
so today's talk is about improving the

42
00:01:23,520 --> 00:01:27,039
performance of ibex

43
00:01:25,119 --> 00:01:28,720
so here what i'm really talking about is

44
00:01:27,040 --> 00:01:30,799
i'm trying to reduce the total number of

45
00:01:28,720 --> 00:01:33,600
cycles i've spent executing

46
00:01:30,799 --> 00:01:33,920
um some benchmarks so in this particular

47
00:01:33,600 --> 00:01:35,600
uh

48
00:01:33,920 --> 00:01:37,759
talk i'm talking about core mark and

49
00:01:35,600 --> 00:01:39,600
then bench core mark because well

50
00:01:37,759 --> 00:01:41,040
everyone talks about call mark numbers

51
00:01:39,600 --> 00:01:43,039
and then bench because it's this nice

52
00:01:41,040 --> 00:01:43,759
new interesting open source benchmarking

53
00:01:43,040 --> 00:01:45,759
suite

54
00:01:43,759 --> 00:01:47,280
um and i felt it had a great range of

55
00:01:45,759 --> 00:01:49,119
stuff to run

56
00:01:47,280 --> 00:01:50,320
and i thought it was a useful thing to

57
00:01:49,119 --> 00:01:51,600
look at

58
00:01:50,320 --> 00:01:53,839
you do have to be careful when you're

59
00:01:51,600 --> 00:01:55,360
working with benchmarks um you've got to

60
00:01:53,840 --> 00:01:57,119
be careful you're not just optimizing

61
00:01:55,360 --> 00:01:59,280
for the benchmark only

62
00:01:57,119 --> 00:02:01,119
so you need to it's very useful to

63
00:01:59,280 --> 00:02:03,119
analyze what's going on with a benchmark

64
00:02:01,119 --> 00:02:04,399
and use that as a guide as to things

65
00:02:03,119 --> 00:02:06,159
that you can then do

66
00:02:04,399 --> 00:02:08,160
you then need to take a step back and

67
00:02:06,159 --> 00:02:09,360
think is this actually generally useful

68
00:02:08,160 --> 00:02:12,799
or am i just making

69
00:02:09,360 --> 00:02:12,800
specifically core mark quicker

70
00:02:13,120 --> 00:02:16,160
and i would say that the improvements

71
00:02:15,200 --> 00:02:18,560
i've mentioned here are going to be

72
00:02:16,160 --> 00:02:19,599
configurable options in ibex

73
00:02:18,560 --> 00:02:22,239
so you're going to be able to choose

74
00:02:19,599 --> 00:02:23,760
having between a smaller or simpler ibex

75
00:02:22,239 --> 00:02:24,080
core or you can have a faster core that

76
00:02:23,760 --> 00:02:25,599
will be a

77
00:02:24,080 --> 00:02:28,080
bit bit bigger and a little bit more

78
00:02:25,599 --> 00:02:28,079
complex

79
00:02:28,640 --> 00:02:32,640
so the trial system that we are running

80
00:02:30,480 --> 00:02:34,720
these simulations on is simulating ibex

81
00:02:32,640 --> 00:02:36,480
verilator we've just got a dual ported

82
00:02:34,720 --> 00:02:38,400
memory containing code and data with a

83
00:02:36,480 --> 00:02:40,160
single cycle access latency

84
00:02:38,400 --> 00:02:41,760
i feel this is a fair analog of a best

85
00:02:40,160 --> 00:02:43,680
case real system

86
00:02:41,760 --> 00:02:45,280
obviously you can get other systems that

87
00:02:43,680 --> 00:02:48,640
aren't going to have quite this setup

88
00:02:45,280 --> 00:02:50,640
and thus aren't going to perform as well

89
00:02:48,640 --> 00:02:53,440
so how do we go about working out what's

90
00:02:50,640 --> 00:02:55,279
going wrong with our performance

91
00:02:53,440 --> 00:02:56,480
you can uh you don't have to do all i

92
00:02:55,280 --> 00:02:58,400
didn't do anything complicated

93
00:02:56,480 --> 00:03:00,560
literally uh run some benchmarks trace

94
00:02:58,400 --> 00:03:02,480
the simulation open up the tracing gtk

95
00:03:00,560 --> 00:03:03,599
wave and just start having a look around

96
00:03:02,480 --> 00:03:05,440
what you're doing here is you're just

97
00:03:03,599 --> 00:03:06,879
trying to look at it identify

98
00:03:05,440 --> 00:03:08,720
interesting behaviors

99
00:03:06,879 --> 00:03:09,840
that you can then poke into more and

100
00:03:08,720 --> 00:03:11,680
then determine if they're actually

101
00:03:09,840 --> 00:03:13,840
causing you performance issues

102
00:03:11,680 --> 00:03:16,000
so it's not a quantitative analysis but

103
00:03:13,840 --> 00:03:20,080
it's just a quick and easy way to get an

104
00:03:16,000 --> 00:03:22,640
idea of what may be going wrong so

105
00:03:20,080 --> 00:03:23,360
i run cormark in uh on on our verilater

106
00:03:22,640 --> 00:03:25,200
simulation

107
00:03:23,360 --> 00:03:27,519
and i open it up in gtk wave and i have

108
00:03:25,200 --> 00:03:28,720
a poke around

109
00:03:27,519 --> 00:03:30,560
and here's a couple of things that i

110
00:03:28,720 --> 00:03:33,680
found so the first thing

111
00:03:30,560 --> 00:03:35,840
is having a look at how is this example

112
00:03:33,680 --> 00:03:37,920
here which is a conditional branch

113
00:03:35,840 --> 00:03:39,120
so you can see the instruction down in

114
00:03:37,920 --> 00:03:40,640
the bottom there

115
00:03:39,120 --> 00:03:42,879
it's a branch of not equal and this

116
00:03:40,640 --> 00:03:44,480
particular condition is passing

117
00:03:42,879 --> 00:03:46,480
so the thing i have in the red circle

118
00:03:44,480 --> 00:03:47,518
there is the first cycle of us executing

119
00:03:46,480 --> 00:03:49,440
this branch

120
00:03:47,519 --> 00:03:50,640
we've pulled the two operands out of the

121
00:03:49,440 --> 00:03:52,879
register file

122
00:03:50,640 --> 00:03:54,319
we're seeing and lo and behold they are

123
00:03:52,879 --> 00:03:57,359
not equal

124
00:03:54,319 --> 00:03:58,798
so our result there is a positive so we

125
00:03:57,360 --> 00:04:00,400
are going to branch

126
00:03:58,799 --> 00:04:01,760
but before we can branch we have to work

127
00:04:00,400 --> 00:04:02,400
out where we're going to so in the next

128
00:04:01,760 --> 00:04:04,480
cycle

129
00:04:02,400 --> 00:04:06,319
we use the alu again to calculate the

130
00:04:04,480 --> 00:04:07,200
branch target so we're reusing that

131
00:04:06,319 --> 00:04:09,280
resource

132
00:04:07,200 --> 00:04:10,958
first a computer condition and then to

133
00:04:09,280 --> 00:04:13,599
do an addition

134
00:04:10,959 --> 00:04:14,000
and then finally we branch so this has

135
00:04:13,599 --> 00:04:17,039
taken

136
00:04:14,000 --> 00:04:19,519
a total of three cycles and

137
00:04:17,040 --> 00:04:21,359
during this time in these in the sec in

138
00:04:19,519 --> 00:04:23,199
the second two cycles the processor is

139
00:04:21,358 --> 00:04:25,039
stored because we stay in the same

140
00:04:23,199 --> 00:04:27,040
pipeline stage while this is happening

141
00:04:25,040 --> 00:04:28,400
so if we could improve this somehow then

142
00:04:27,040 --> 00:04:31,280
we can speed up

143
00:04:28,400 --> 00:04:31,280
our execution

144
00:04:31,520 --> 00:04:34,639
next thing we can look at is uh here

145
00:04:33,680 --> 00:04:36,479
loads

146
00:04:34,639 --> 00:04:38,160
and again we end up stalling on every

147
00:04:36,479 --> 00:04:40,080
single load and the reason for this is

148
00:04:38,160 --> 00:04:43,280
again our two-stage pipeline

149
00:04:40,080 --> 00:04:44,960
in the first cycle we request the data

150
00:04:43,280 --> 00:04:46,719
we have one cycle access latency so in

151
00:04:44,960 --> 00:04:49,039
the next cycle we get it back

152
00:04:46,720 --> 00:04:51,680
but we need to wait a cycle for us to

153
00:04:49,040 --> 00:04:54,320
get to get that data back so we end up

154
00:04:51,680 --> 00:04:55,759
stalling the pipeline again

155
00:04:54,320 --> 00:04:57,919
and we actually have the same behavior

156
00:04:55,759 --> 00:04:59,520
on stores the reason for this is we wait

157
00:04:57,919 --> 00:05:00,320
for a response from the store to tell us

158
00:04:59,520 --> 00:05:02,240
if there's an error

159
00:05:00,320 --> 00:05:05,120
for example if we accessed a

160
00:05:02,240 --> 00:05:07,520
non-existent address

161
00:05:05,120 --> 00:05:09,440
uh so we end up stalling for at least

162
00:05:07,520 --> 00:05:11,120
one cycle on stores as well

163
00:05:09,440 --> 00:05:13,680
so we've got these stall cycles around

164
00:05:11,120 --> 00:05:15,280
branches loads and stores which

165
00:05:13,680 --> 00:05:16,880
you know clearly isn't particularly good

166
00:05:15,280 --> 00:05:18,638
for performance

167
00:05:16,880 --> 00:05:20,719
so we're going to actually do some

168
00:05:18,639 --> 00:05:23,520
quantitative analysis now we're going to

169
00:05:20,720 --> 00:05:24,080
use the performance counters to actually

170
00:05:23,520 --> 00:05:26,560
um

171
00:05:24,080 --> 00:05:28,240
see what's going on and dig in to some

172
00:05:26,560 --> 00:05:29,840
of the uh

173
00:05:28,240 --> 00:05:31,600
and try and determine how much this is

174
00:05:29,840 --> 00:05:34,239
actually impacting our performance

175
00:05:31,600 --> 00:05:35,520
so we've just identified um two three

176
00:05:34,240 --> 00:05:36,479
interesting behaviors that are probably

177
00:05:35,520 --> 00:05:39,280
slowing us down

178
00:05:36,479 --> 00:05:40,800
let's see what the actual effect is so

179
00:05:39,280 --> 00:05:43,440
run we run our simulation

180
00:05:40,800 --> 00:05:44,560
uh across a variety of benchmarks using

181
00:05:43,440 --> 00:05:46,160
these performance counters

182
00:05:44,560 --> 00:05:48,720
and we get some results that tell us how

183
00:05:46,160 --> 00:05:51,520
much time we're spending stored

184
00:05:48,720 --> 00:05:53,120
so this first graph here on the bottom

185
00:05:51,520 --> 00:05:54,880
uh axis on the x-axis

186
00:05:53,120 --> 00:05:56,720
you can see the various benchmarks on

187
00:05:54,880 --> 00:05:59,680
the far left is cormark

188
00:05:56,720 --> 00:06:01,120
on the far right is a geometric mean of

189
00:05:59,680 --> 00:06:02,880
all of these numbers

190
00:06:01,120 --> 00:06:05,360
and in the middle is the m bench

191
00:06:02,880 --> 00:06:07,199
benchmarking suite

192
00:06:05,360 --> 00:06:09,120
and what we have here is the percentage

193
00:06:07,199 --> 00:06:11,360
of total cycles spent

194
00:06:09,120 --> 00:06:12,319
calculating the branch target so if we

195
00:06:11,360 --> 00:06:14,880
go back

196
00:06:12,319 --> 00:06:16,800
here that second red circle there this

197
00:06:14,880 --> 00:06:18,400
is the total number of cycles percentage

198
00:06:16,800 --> 00:06:20,160
of total cycles we're basically spending

199
00:06:18,400 --> 00:06:24,080
doing that red circle

200
00:06:20,160 --> 00:06:24,080
uh sorry that red circle

201
00:06:25,600 --> 00:06:30,160
and you can see um on average around

202
00:06:28,240 --> 00:06:31,840
about four percent of our time is spent

203
00:06:30,160 --> 00:06:34,080
doing this so if we could remove this

204
00:06:31,840 --> 00:06:35,919
cycle we could um

205
00:06:34,080 --> 00:06:37,199
increase uh reduce the number of cycles

206
00:06:35,919 --> 00:06:38,400
that we spend doing these benchmarks by

207
00:06:37,199 --> 00:06:39,680
around about four percent

208
00:06:38,400 --> 00:06:41,919
and different benchmarks have different

209
00:06:39,680 --> 00:06:44,960
amounts of branching which is

210
00:06:41,919 --> 00:06:46,639
you know unsurprising we can do a

211
00:06:44,960 --> 00:06:50,000
similar thing for the memory

212
00:06:46,639 --> 00:06:53,680
um note that the uh the y-axis has

213
00:06:50,000 --> 00:06:55,440
changed in scale so we're at um

214
00:06:53,680 --> 00:06:57,039
but otherwise very similar graphs this

215
00:06:55,440 --> 00:06:58,719
is a percentage of cycles that we've

216
00:06:57,039 --> 00:07:00,240
spent waiting for a memory response

217
00:06:58,720 --> 00:07:02,319
whether that's the data coming back

218
00:07:00,240 --> 00:07:04,000
or the response from the uh on a store

219
00:07:02,319 --> 00:07:07,599
from the memory system

220
00:07:04,000 --> 00:07:08,400
um and this is a significantly bigger

221
00:07:07,599 --> 00:07:09,919
chunk of time

222
00:07:08,400 --> 00:07:11,679
you can see on average that's around

223
00:07:09,919 --> 00:07:13,039
about 15 percent

224
00:07:11,680 --> 00:07:15,599
and then different benchmarks have

225
00:07:13,039 --> 00:07:17,120
different amounts of memory activity so

226
00:07:15,599 --> 00:07:20,319
fairly uh spread about how much

227
00:07:17,120 --> 00:07:22,000
performance you can potentially save by

228
00:07:20,319 --> 00:07:25,039
reducing the number of cycles you spend

229
00:07:22,000 --> 00:07:25,039
hanging around for memory

230
00:07:27,599 --> 00:07:31,199
so we've identified these things it

231
00:07:30,080 --> 00:07:33,039
definitely seems to be slowing down

232
00:07:31,199 --> 00:07:34,560
these benchmarks we can go

233
00:07:33,039 --> 00:07:36,479
is this you know if we improve these

234
00:07:34,560 --> 00:07:37,599
things are we just improving benchmarks

235
00:07:36,479 --> 00:07:38,719
are we just are we improving other

236
00:07:37,599 --> 00:07:39,919
things but i think it's pretty safe to

237
00:07:38,720 --> 00:07:41,360
say

238
00:07:39,919 --> 00:07:44,000
everything is going to use branches and

239
00:07:41,360 --> 00:07:46,000
memory accesses so yes this is generally

240
00:07:44,000 --> 00:07:47,680
useful and yes this is a major thing

241
00:07:46,000 --> 00:07:48,400
that is slowing down the ibex core right

242
00:07:47,680 --> 00:07:51,919
now

243
00:07:48,400 --> 00:07:53,679
so we need to improve things

244
00:07:51,919 --> 00:07:55,359
so the first thing we're going to do to

245
00:07:53,680 --> 00:07:58,000
improve our branch performance

246
00:07:55,360 --> 00:07:59,360
is to introduce a new alu a branch

247
00:07:58,000 --> 00:08:01,360
target alu

248
00:07:59,360 --> 00:08:02,560
so on the right hand side here i have a

249
00:08:01,360 --> 00:08:04,960
diagram of the

250
00:08:02,560 --> 00:08:06,560
ibex pipeline very simplified we've got

251
00:08:04,960 --> 00:08:08,159
our two stages we have our instruction

252
00:08:06,560 --> 00:08:08,879
fetch so that grabs the instruction out

253
00:08:08,160 --> 00:08:10,560
of memory

254
00:08:08,879 --> 00:08:12,160
and then we have decode and execute

255
00:08:10,560 --> 00:08:12,800
introduction moves into there and it

256
00:08:12,160 --> 00:08:15,440
sits there

257
00:08:12,800 --> 00:08:16,560
and um until it is done until it is

258
00:08:15,440 --> 00:08:19,280
finished and written back to the

259
00:08:16,560 --> 00:08:19,280
register file

260
00:08:19,360 --> 00:08:22,720
so if we want to remove this stall cycle

261
00:08:21,199 --> 00:08:24,720
around computing branch targets all we

262
00:08:22,720 --> 00:08:27,039
need to do is just add in the second aou

263
00:08:24,720 --> 00:08:30,160
so rather than spending

264
00:08:27,039 --> 00:08:32,000
two cycles using this main lu twice

265
00:08:30,160 --> 00:08:33,599
we are going to use the main alu to

266
00:08:32,000 --> 00:08:36,159
compute the condition decide whether or

267
00:08:33,599 --> 00:08:37,519
not we're bouncing and at the same time

268
00:08:36,159 --> 00:08:40,399
perform the addition that's going to

269
00:08:37,519 --> 00:08:42,000
work out where we're branching to

270
00:08:40,399 --> 00:08:43,519
we increase the area of the core a

271
00:08:42,000 --> 00:08:45,040
little bit because we're adding in some

272
00:08:43,519 --> 00:08:46,160
extra logic but we're getting a four we

273
00:08:45,040 --> 00:08:47,519
reckon we're going to get around about a

274
00:08:46,160 --> 00:08:50,240
four percent performance going out of it

275
00:08:47,519 --> 00:08:54,480
so this is probably a good idea

276
00:08:50,240 --> 00:08:56,000
so we do this nice straightforward

277
00:08:54,480 --> 00:08:57,920
but there's other things we need to

278
00:08:56,000 --> 00:08:58,720
consider that's the implementation so

279
00:08:57,920 --> 00:09:00,000
the physical

280
00:08:58,720 --> 00:09:01,760
impact of these changes we're going to

281
00:09:00,000 --> 00:09:02,480
add some logic so it's going to add some

282
00:09:01,760 --> 00:09:05,439
area

283
00:09:02,480 --> 00:09:07,360
it's also going to alter the timing so

284
00:09:05,440 --> 00:09:08,959
what frequency we can run the processor

285
00:09:07,360 --> 00:09:10,640
core at

286
00:09:08,959 --> 00:09:12,479
so i built an experimental synthesis

287
00:09:10,640 --> 00:09:13,839
flow using uh yosis

288
00:09:12,480 --> 00:09:15,920
open source synthesis tool if you're not

289
00:09:13,839 --> 00:09:17,920
familiar with it um and i did timing

290
00:09:15,920 --> 00:09:20,880
analysis with opensta

291
00:09:17,920 --> 00:09:22,240
i pulled um the 45 nanometer nand gate

292
00:09:20,880 --> 00:09:23,920
library that you can get out of the open

293
00:09:22,240 --> 00:09:26,160
road repository

294
00:09:23,920 --> 00:09:27,519
and i use this to generate some uh

295
00:09:26,160 --> 00:09:29,439
implementation numbers

296
00:09:27,519 --> 00:09:31,760
i would caution that things like yosis

297
00:09:29,440 --> 00:09:35,040
and the nand gate 45 nanometer library

298
00:09:31,760 --> 00:09:36,959
um are you know aren't going to achieve

299
00:09:35,040 --> 00:09:38,079
the best numbers compared to what you

300
00:09:36,959 --> 00:09:39,439
could potentially do with commercial

301
00:09:38,080 --> 00:09:41,839
tools and libraries

302
00:09:39,440 --> 00:09:43,440
so this flow is not here to say here's

303
00:09:41,839 --> 00:09:45,760
the best numbers we can get out of ibex

304
00:09:43,440 --> 00:09:47,600
for frequency and area etc

305
00:09:45,760 --> 00:09:49,120
but it is very useful to see relative

306
00:09:47,600 --> 00:09:50,800
changes as we make these

307
00:09:49,120 --> 00:09:52,399
as we make these improvements and then

308
00:09:50,800 --> 00:09:52,880
see where our air as a timing pressure

309
00:09:52,399 --> 00:09:55,200
are

310
00:09:52,880 --> 00:09:56,240
see what chains of logic are slowing

311
00:09:55,200 --> 00:09:57,920
down our frequency

312
00:09:56,240 --> 00:10:00,240
and thus work out where we can improve

313
00:09:57,920 --> 00:10:00,240
things

314
00:10:00,320 --> 00:10:04,399
so here are the results of implementing

315
00:10:02,160 --> 00:10:06,399
the branch target aou i've just put the

316
00:10:04,399 --> 00:10:08,399
core mark results in but um

317
00:10:06,399 --> 00:10:10,000
you'll see some m bench results later

318
00:10:08,399 --> 00:10:11,440
and court mark per megahertz well that's

319
00:10:10,000 --> 00:10:12,959
gone up by about four and a half percent

320
00:10:11,440 --> 00:10:15,360
which is what we expected

321
00:10:12,959 --> 00:10:16,399
great area has increased a little bit

322
00:10:15,360 --> 00:10:19,120
but not too much

323
00:10:16,399 --> 00:10:21,279
great the problem here is we've just

324
00:10:19,120 --> 00:10:23,040
lost some frequency so our f max

325
00:10:21,279 --> 00:10:25,279
the maximum frequency that our core can

326
00:10:23,040 --> 00:10:26,880
run at have gone down by 13

327
00:10:25,279 --> 00:10:28,079
so actually this means overall we

328
00:10:26,880 --> 00:10:29,200
haven't necessarily increased

329
00:10:28,079 --> 00:10:30,560
performance because if we're running at

330
00:10:29,200 --> 00:10:32,480
maximum frequency

331
00:10:30,560 --> 00:10:34,640
our maximum frequency has just gone down

332
00:10:32,480 --> 00:10:36,160
so the our call mark per megahertz has

333
00:10:34,640 --> 00:10:37,839
gone up but overall we end up with a

334
00:10:36,160 --> 00:10:39,839
lower core mark result we end up with a

335
00:10:37,839 --> 00:10:41,519
slower core

336
00:10:39,839 --> 00:10:42,959
so can we do anything about this this is

337
00:10:41,519 --> 00:10:44,640
kind of disappointing we have this nice

338
00:10:42,959 --> 00:10:46,399
little simple change but

339
00:10:44,640 --> 00:10:48,640
which seemed obvious but actually we

340
00:10:46,399 --> 00:10:50,079
started going slower

341
00:10:48,640 --> 00:10:51,839
so we need to dig into the

342
00:10:50,079 --> 00:10:53,519
implementation and try and work out

343
00:10:51,839 --> 00:10:56,560
what's going wrong

344
00:10:53,519 --> 00:10:58,399
now yosis allows you to do this it's got

345
00:10:56,560 --> 00:11:00,479
some nice tools for selecting out logic

346
00:10:58,399 --> 00:11:02,959
and examining paths and things

347
00:11:00,480 --> 00:11:04,320
and it produces these wonderful diagrams

348
00:11:02,959 --> 00:11:05,119
which you can spend a very long time

349
00:11:04,320 --> 00:11:06,800
staring at

350
00:11:05,120 --> 00:11:08,240
obviously it's not particularly easy to

351
00:11:06,800 --> 00:11:09,839
just pick out of something like this so

352
00:11:08,240 --> 00:11:11,839
this is a graph of some of the

353
00:11:09,839 --> 00:11:15,040
uh logic inside the ibex core as

354
00:11:11,839 --> 00:11:17,200
produced by the yoast synthesis tool

355
00:11:15,040 --> 00:11:18,480
you can't immediately go aha it's this

356
00:11:17,200 --> 00:11:20,000
line here

357
00:11:18,480 --> 00:11:21,920
but you can with some knowledge of the

358
00:11:20,000 --> 00:11:23,600
design spend some time examining this

359
00:11:21,920 --> 00:11:25,199
have a bit of a think about it and work

360
00:11:23,600 --> 00:11:26,320
out what's going on which is what i've

361
00:11:25,200 --> 00:11:28,000
done

362
00:11:26,320 --> 00:11:31,920
so here's a far simpler diagram which

363
00:11:28,000 --> 00:11:31,920
actually explains what we've messed up

364
00:11:32,079 --> 00:11:35,199
so what's happening here for people who

365
00:11:33,920 --> 00:11:38,640
aren't familiar with

366
00:11:35,200 --> 00:11:40,880
uh synthesis and logic implementation

367
00:11:38,640 --> 00:11:42,560
the the thing that's slow that sets the

368
00:11:40,880 --> 00:11:44,079
maximum frequency in your design is

369
00:11:42,560 --> 00:11:45,680
based around the the length

370
00:11:44,079 --> 00:11:47,040
of the longest chain of logic in your

371
00:11:45,680 --> 00:11:48,160
designs you have a whole bunch of logic

372
00:11:47,040 --> 00:11:50,240
gates

373
00:11:48,160 --> 00:11:52,000
all connected together and the longer

374
00:11:50,240 --> 00:11:53,600
the longer those chains get the longer

375
00:11:52,000 --> 00:11:56,959
it takes for a signal to propagate down

376
00:11:53,600 --> 00:11:58,720
and the slower your clock can run

377
00:11:56,959 --> 00:12:00,719
and so what we have here i've got this

378
00:11:58,720 --> 00:12:01,600
grey line which is the longest path in

379
00:12:00,720 --> 00:12:03,760
our design

380
00:12:01,600 --> 00:12:05,279
so we start with the instructions and

381
00:12:03,760 --> 00:12:06,639
that's instruction we've just read out

382
00:12:05,279 --> 00:12:07,920
of the instruction fetch stage in the

383
00:12:06,639 --> 00:12:10,639
previous cycle

384
00:12:07,920 --> 00:12:12,160
which we are executing we have a decoder

385
00:12:10,639 --> 00:12:13,040
which is a blob of logic which is

386
00:12:12,160 --> 00:12:14,240
working out

387
00:12:13,040 --> 00:12:16,079
what we're going to do it's going to set

388
00:12:14,240 --> 00:12:17,600
up the controls for for this this

389
00:12:16,079 --> 00:12:19,599
instruction

390
00:12:17,600 --> 00:12:21,920
this then feeds into the main alu which

391
00:12:19,600 --> 00:12:23,200
is going to compute our results for us

392
00:12:21,920 --> 00:12:24,800
and then on the right hand side here

393
00:12:23,200 --> 00:12:25,920
i've got what i've labeled the pc mux

394
00:12:24,800 --> 00:12:27,839
selection logic

395
00:12:25,920 --> 00:12:29,519
so what this is doing is choosing where

396
00:12:27,839 --> 00:12:30,480
our next pc is going to be which then

397
00:12:29,519 --> 00:12:32,800
feeds into that

398
00:12:30,480 --> 00:12:33,760
insta adder o on the right hand side

399
00:12:32,800 --> 00:12:36,240
there

400
00:12:33,760 --> 00:12:38,480
that is the address we're next fetching

401
00:12:36,240 --> 00:12:39,839
from instruction memory

402
00:12:38,480 --> 00:12:40,959
and so it's actually quite complicated

403
00:12:39,839 --> 00:12:42,000
to decide this because there's quite a

404
00:12:40,959 --> 00:12:43,518
few things going on

405
00:12:42,000 --> 00:12:44,720
you might be branching you might just be

406
00:12:43,519 --> 00:12:46,079
going to the next instruction there

407
00:12:44,720 --> 00:12:46,800
might be an exception there might be an

408
00:12:46,079 --> 00:12:48,719
interrupt

409
00:12:46,800 --> 00:12:50,160
we actually have a prefetch buffer which

410
00:12:48,720 --> 00:12:51,760
is trying to fetch ahead

411
00:12:50,160 --> 00:12:53,680
which is also affecting the instruction

412
00:12:51,760 --> 00:12:54,800
address so this pc mux selection

413
00:12:53,680 --> 00:12:56,560
actually has quite a lot of things to

414
00:12:54,800 --> 00:12:57,760
decide so it's a reasonably complex blob

415
00:12:56,560 --> 00:12:59,518
of logic

416
00:12:57,760 --> 00:13:01,279
and what we've done here is previously

417
00:12:59,519 --> 00:13:03,040
if we were going to branch

418
00:13:01,279 --> 00:13:05,200
um we're going to spend two cycles over

419
00:13:03,040 --> 00:13:06,560
it and so the first cycle

420
00:13:05,200 --> 00:13:08,720
main lu is going to compute the

421
00:13:06,560 --> 00:13:11,199
condition it is then going to remember

422
00:13:08,720 --> 00:13:11,760
whether or not we passed the condition

423
00:13:11,200 --> 00:13:14,240
the next

424
00:13:11,760 --> 00:13:15,439
cycle the main ao is going to compute

425
00:13:14,240 --> 00:13:16,959
the branch target

426
00:13:15,440 --> 00:13:18,399
and what's going to happen is it's going

427
00:13:16,959 --> 00:13:20,160
to come out the alu it's going to come

428
00:13:18,399 --> 00:13:22,399
up this dotted line here

429
00:13:20,160 --> 00:13:24,240
and into this mux and then out to give

430
00:13:22,399 --> 00:13:25,920
us the next instruction fetch address

431
00:13:24,240 --> 00:13:27,120
we have just removed this dotted line

432
00:13:25,920 --> 00:13:27,839
because we now have this advanced target

433
00:13:27,120 --> 00:13:30,079
alu

434
00:13:27,839 --> 00:13:31,519
and we've introduced this new line here

435
00:13:30,079 --> 00:13:33,439
this is the condition

436
00:13:31,519 --> 00:13:35,680
coming out of the main alu and it feeds

437
00:13:33,440 --> 00:13:37,839
into the pc mux selection logic

438
00:13:35,680 --> 00:13:39,120
so what we've done is we've taken what

439
00:13:37,839 --> 00:13:40,560
was the longest path in the design

440
00:13:39,120 --> 00:13:42,079
namely this dotted line here

441
00:13:40,560 --> 00:13:43,439
and we've added just a little bit of

442
00:13:42,079 --> 00:13:45,199
extra stuff onto it because we've now

443
00:13:43,440 --> 00:13:46,000
put the pc much selection logic in there

444
00:13:45,199 --> 00:13:47,120
because of our

445
00:13:46,000 --> 00:13:49,199
because we're no longer saving the

446
00:13:47,120 --> 00:13:52,480
condition we're using it immediately

447
00:13:49,199 --> 00:13:55,599
and this has slowed us down

448
00:13:52,480 --> 00:13:56,800
so how do we make ourselves faster well

449
00:13:55,600 --> 00:13:58,240
we need to have a look at some of the

450
00:13:56,800 --> 00:13:59,760
blobs and try and work out what it is we

451
00:13:58,240 --> 00:14:01,040
can improve the main alu there's

452
00:13:59,760 --> 00:14:02,560
probably not much we can do about that

453
00:14:01,040 --> 00:14:04,399
you implement the best ad you can and

454
00:14:02,560 --> 00:14:06,638
there you go it's as fast as it's going

455
00:14:04,399 --> 00:14:06,639
to be

456
00:14:06,959 --> 00:14:10,638
what we can probably do though is look

457
00:14:09,040 --> 00:14:12,319
at how we're setting up the operands for

458
00:14:10,639 --> 00:14:13,360
the main alu so we've got these red

459
00:14:12,320 --> 00:14:15,040
lines coming in here these are the

460
00:14:13,360 --> 00:14:17,839
control lines which are selecting what

461
00:14:15,040 --> 00:14:17,839
operands we're doing

462
00:14:18,160 --> 00:14:21,439
so what we're going to try and do is

463
00:14:19,360 --> 00:14:24,399
make those main aou

464
00:14:21,440 --> 00:14:25,120
operands turn up earlier so the main alu

465
00:14:24,399 --> 00:14:27,360
result

466
00:14:25,120 --> 00:14:28,639
comes earlier and the problem here

467
00:14:27,360 --> 00:14:30,000
that's causing these things to be quite

468
00:14:28,639 --> 00:14:31,519
late is because of the decoder this

469
00:14:30,000 --> 00:14:33,199
is a big complicated blob of logic it

470
00:14:31,519 --> 00:14:34,480
basically controls the entire design

471
00:14:33,199 --> 00:14:36,479
it is trying to work out what the

472
00:14:34,480 --> 00:14:38,639
instruction is doing we need to make it

473
00:14:36,480 --> 00:14:41,600
go quicker

474
00:14:38,639 --> 00:14:42,959
so there's a few things i need to fix to

475
00:14:41,600 --> 00:14:44,240
do this sadly i've only got time to

476
00:14:42,959 --> 00:14:45,920
discuss one of them

477
00:14:44,240 --> 00:14:47,920
and this is this instruction flop fan

478
00:14:45,920 --> 00:14:52,160
out

479
00:14:47,920 --> 00:14:54,719
so this thing here which is what i just

480
00:14:52,160 --> 00:14:57,600
called the instruction flop

481
00:14:54,720 --> 00:14:58,800
connects to an awful lot of logic all

482
00:14:57,600 --> 00:15:00,480
kinds of gates

483
00:14:58,800 --> 00:15:01,920
and so in order for it to physically

484
00:15:00,480 --> 00:15:03,760
drive all these gates it needs a bunch

485
00:15:01,920 --> 00:15:04,479
of buffering to push that signal out

486
00:15:03,760 --> 00:15:06,800
everywhere

487
00:15:04,480 --> 00:15:08,320
and this slows it down quite a bit so if

488
00:15:06,800 --> 00:15:10,319
we could somehow reduce that if we could

489
00:15:08,320 --> 00:15:12,240
reduce that fan out we can speed up

490
00:15:10,320 --> 00:15:13,920
our design and so what we do is we just

491
00:15:12,240 --> 00:15:16,480
make a copy of our instruction flop we

492
00:15:13,920 --> 00:15:18,479
now have two of them

493
00:15:16,480 --> 00:15:20,240
and then we split out the decoder so it

494
00:15:18,480 --> 00:15:21,199
looks a replicated version of the

495
00:15:20,240 --> 00:15:23,519
instruction

496
00:15:21,199 --> 00:15:25,359
and then it uses that purely to decide

497
00:15:23,519 --> 00:15:26,480
the alu operand select and then the

498
00:15:25,360 --> 00:15:28,160
operation

499
00:15:26,480 --> 00:15:29,279
and then the d then d code for

500
00:15:28,160 --> 00:15:30,560
everything else comes from the other

501
00:15:29,279 --> 00:15:34,000
register

502
00:15:30,560 --> 00:15:36,560
and in doing this we um make these

503
00:15:34,000 --> 00:15:37,920
red lines appear earlier in our cycle so

504
00:15:36,560 --> 00:15:38,880
all of this returns earlier and we help

505
00:15:37,920 --> 00:15:40,160
fix the path

506
00:15:38,880 --> 00:15:41,519
and as i said there are some other

507
00:15:40,160 --> 00:15:43,199
things we need to do but i have not got

508
00:15:41,519 --> 00:15:44,720
the time to discuss

509
00:15:43,199 --> 00:15:46,319
so after doing this plus some extra

510
00:15:44,720 --> 00:15:47,440
improvements i've now got a better

511
00:15:46,320 --> 00:15:48,880
implementation

512
00:15:47,440 --> 00:15:50,079
area has actually gone down a bit i

513
00:15:48,880 --> 00:15:51,519
think that's because i've reduced the

514
00:15:50,079 --> 00:15:53,279
amount of buffering in the design due to

515
00:15:51,519 --> 00:15:55,120
duplicating that register

516
00:15:53,279 --> 00:15:56,639
sadly i still haven't recovered the

517
00:15:55,120 --> 00:15:58,560
frequency though

518
00:15:56,639 --> 00:16:00,399
now i'm not too worried about this um

519
00:15:58,560 --> 00:16:02,560
for a few reasons one the tools i'm

520
00:16:00,399 --> 00:16:03,199
using yosis and abc the optimizer it

521
00:16:02,560 --> 00:16:05,599
uses

522
00:16:03,199 --> 00:16:07,519
don't actually take timing oh sorry i

523
00:16:05,600 --> 00:16:09,120
owe timing constraints into account

524
00:16:07,519 --> 00:16:11,199
so what we're the path we've got here is

525
00:16:09,120 --> 00:16:12,480
an output um path

526
00:16:11,199 --> 00:16:14,399
and there's a constraint on it saying

527
00:16:12,480 --> 00:16:16,160
how early it needs to appear

528
00:16:14,399 --> 00:16:17,680
you can't actually feed this into yoast

529
00:16:16,160 --> 00:16:19,279
so it can't really really target the

530
00:16:17,680 --> 00:16:20,719
optimization at it so i think if i had

531
00:16:19,279 --> 00:16:21,360
some other tools that were capable of

532
00:16:20,720 --> 00:16:22,639
doing this

533
00:16:21,360 --> 00:16:24,399
i could probably optimize this path a

534
00:16:22,639 --> 00:16:25,839
lot better and i could hopefully

535
00:16:24,399 --> 00:16:26,959
make the rest of this problem go away

536
00:16:25,839 --> 00:16:28,560
and then the other thing is this is a

537
00:16:26,959 --> 00:16:30,160
microcontroller you're not necessarily

538
00:16:28,560 --> 00:16:31,359
wanting it to run it at the maximum

539
00:16:30,160 --> 00:16:34,000
possible frequency

540
00:16:31,360 --> 00:16:34,800
but it is important that we're trying to

541
00:16:34,000 --> 00:16:36,000
maintain

542
00:16:34,800 --> 00:16:38,240
we don't just keep adding things that

543
00:16:36,000 --> 00:16:40,079
keep slowing it down and slowing it down

544
00:16:38,240 --> 00:16:42,000
so overall probably a pretty good

545
00:16:40,079 --> 00:16:43,439
optimization for someone who really

546
00:16:42,000 --> 00:16:45,120
wants to run ibex at the maximum

547
00:16:43,440 --> 00:16:46,240
frequency they can maybe want to turn it

548
00:16:45,120 --> 00:16:49,040
off but they can do that because it's a

549
00:16:46,240 --> 00:16:49,040
configurable option

550
00:16:49,600 --> 00:16:53,600
second thing i've done um was add a

551
00:16:51,680 --> 00:16:54,800
third pipeline stage to ibex

552
00:16:53,600 --> 00:16:56,079
now this is actually quite i've made

553
00:16:54,800 --> 00:16:57,439
this look very simple this is actually

554
00:16:56,079 --> 00:16:58,719
quite a complex thing to do it's just

555
00:16:57,440 --> 00:17:00,160
one of those things don't really have

556
00:16:58,720 --> 00:17:00,959
time to dig into it but what we've done

557
00:17:00,160 --> 00:17:02,959
here

558
00:17:00,959 --> 00:17:04,000
is now an instruction goes into decode

559
00:17:02,959 --> 00:17:06,240
and execute

560
00:17:04,000 --> 00:17:08,319
it computes its result then the next

561
00:17:06,240 --> 00:17:09,679
cycle it sits into this right back stage

562
00:17:08,319 --> 00:17:10,959
here

563
00:17:09,679 --> 00:17:12,720
and then it writes itself back to the

564
00:17:10,959 --> 00:17:13,280
register file so this gives us an extra

565
00:17:12,720 --> 00:17:15,520
cycle

566
00:17:13,280 --> 00:17:17,760
to wait for the result to turn up for

567
00:17:15,520 --> 00:17:20,000
memory or for the response to the store

568
00:17:17,760 --> 00:17:21,280
so we lose a store cycle out of loads

569
00:17:20,000 --> 00:17:23,520
and stores

570
00:17:21,280 --> 00:17:25,760
and so this is going to help solve our

571
00:17:23,520 --> 00:17:27,760
uh our store problems around memory

572
00:17:25,760 --> 00:17:29,280
and as i've said this is quite a comp

573
00:17:27,760 --> 00:17:30,879
reasonably complicated thing to do i

574
00:17:29,280 --> 00:17:34,399
just don't have time to really talk into

575
00:17:30,880 --> 00:17:36,320
all the details about what is going on

576
00:17:34,400 --> 00:17:38,000
and then when i implement that um area

577
00:17:36,320 --> 00:17:39,600
goes up as you might expect but we've

578
00:17:38,000 --> 00:17:41,440
got about a again on core mark

579
00:17:39,600 --> 00:17:43,360
we've got about a 20 improvement in call

580
00:17:41,440 --> 00:17:45,039
mark per megahertz so

581
00:17:43,360 --> 00:17:46,719
notable area cost but it's outweighed by

582
00:17:45,039 --> 00:17:48,720
our performance gains

583
00:17:46,720 --> 00:17:50,320
f max has basically stood still so this

584
00:17:48,720 --> 00:17:51,760
is the right backstage along with that

585
00:17:50,320 --> 00:17:52,799
new branch target alu so it hasn't

586
00:17:51,760 --> 00:17:54,720
really affected it

587
00:17:52,799 --> 00:17:56,400
it's still those branch target aou

588
00:17:54,720 --> 00:17:58,840
changes that are dominating our timing

589
00:17:56,400 --> 00:18:01,120
and keeping us at that f max that we

590
00:17:58,840 --> 00:18:03,840
have

591
00:18:01,120 --> 00:18:04,799
so nice complicated graph same thing

592
00:18:03,840 --> 00:18:06,799
you've seen before

593
00:18:04,799 --> 00:18:07,918
benchmarks on the bottom car core mark

594
00:18:06,799 --> 00:18:10,240
on the far left

595
00:18:07,919 --> 00:18:11,679
geometric average on the far right m

596
00:18:10,240 --> 00:18:13,840
bench suite in the middle

597
00:18:11,679 --> 00:18:15,679
and you can see and then it shows you

598
00:18:13,840 --> 00:18:16,720
our total speed up and the combination

599
00:18:15,679 --> 00:18:18,320
of where

600
00:18:16,720 --> 00:18:19,600
what the branch target aou has done for

601
00:18:18,320 --> 00:18:20,799
us and what the right back has done for

602
00:18:19,600 --> 00:18:22,719
us on top of that

603
00:18:20,799 --> 00:18:23,840
and overall our geometric mean there is

604
00:18:22,720 --> 00:18:25,039
21.3

605
00:18:23,840 --> 00:18:26,959
so i think that's a really quite

606
00:18:25,039 --> 00:18:29,760
significant gain in performance

607
00:18:26,960 --> 00:18:32,080
for seven percent area which seems like

608
00:18:29,760 --> 00:18:33,440
a pretty good deal to me

609
00:18:32,080 --> 00:18:35,600
obviously it doesn't affect all

610
00:18:33,440 --> 00:18:36,320
benchmarks equally not all benchmarks

611
00:18:35,600 --> 00:18:38,559
are

612
00:18:36,320 --> 00:18:40,080
memory or branch bound i think some of

613
00:18:38,559 --> 00:18:41,120
these benchmarks in particular using say

614
00:18:40,080 --> 00:18:44,559
a lot of multiplies

615
00:18:41,120 --> 00:18:44,559
so that is what's slowing you down now

616
00:18:44,720 --> 00:18:47,919
and there we go um quick whistle stop

617
00:18:46,720 --> 00:18:48,880
tour for some of the performance

618
00:18:47,919 --> 00:18:50,640
improvements i did

619
00:18:48,880 --> 00:18:52,799
if you would like to find out more you

620
00:18:50,640 --> 00:18:53,280
can check out our ibex repository here

621
00:18:52,799 --> 00:18:56,320
on

622
00:18:53,280 --> 00:18:58,160
on our github uh the work i've just been

623
00:18:56,320 --> 00:18:59,439
discussing not all of it is yet in the

624
00:18:58,160 --> 00:19:02,240
main repository

625
00:18:59,440 --> 00:19:04,000
um so i put up a special uh ibex fosdem

626
00:19:02,240 --> 00:19:05,280
branch of my own ibex fork you can go

627
00:19:04,000 --> 00:19:06,799
take a look at if you want to uh

628
00:19:05,280 --> 00:19:08,720
recreate my results or play around with

629
00:19:06,799 --> 00:19:10,000
what i've done you can also check out

630
00:19:08,720 --> 00:19:11,520
lois on the lowest website

631
00:19:10,000 --> 00:19:12,720
we're now we're currently hiring so if

632
00:19:11,520 --> 00:19:13,520
you're interested in working open

633
00:19:12,720 --> 00:19:14,799
silicon uh

634
00:19:13,520 --> 00:19:16,639
powering both software and hardware

635
00:19:14,799 --> 00:19:17,918
positions do get in touch and if you

636
00:19:16,640 --> 00:19:19,280
have any questions about this work or

637
00:19:17,919 --> 00:19:21,520
anything else then feel free to

638
00:19:19,280 --> 00:19:25,840
get in touch and drop me an email okay

639
00:19:21,520 --> 00:19:25,840
well thank you very much

