1
00:00:05,040 --> 00:00:07,919
fun

2
00:00:06,000 --> 00:00:09,920
we are extremely excited to be here at

3
00:00:07,919 --> 00:00:11,360
fosdem and speak about the topic that we

4
00:00:09,920 --> 00:00:13,920
are truly passionate about

5
00:00:11,360 --> 00:00:15,599
which is observability promising use and

6
00:00:13,920 --> 00:00:17,119
a bit of going

7
00:00:15,599 --> 00:00:19,359
and we hope this talk is really

8
00:00:17,119 --> 00:00:20,960
actionable for you and insightful

9
00:00:19,359 --> 00:00:22,720
and this is because at the end of this

10
00:00:20,960 --> 00:00:24,400
talk i would like you to know

11
00:00:22,720 --> 00:00:26,479
three things first of all why

12
00:00:24,400 --> 00:00:28,560
instrumenting application

13
00:00:26,480 --> 00:00:30,080
with metrics is really essential

14
00:00:28,560 --> 00:00:32,320
secondly how to do it quickly

15
00:00:30,080 --> 00:00:33,680
with make sure that you have metrics for

16
00:00:32,320 --> 00:00:36,480
prompters to use

17
00:00:33,680 --> 00:00:38,320
and last but not the least what are the

18
00:00:36,480 --> 00:00:40,160
common mistakes that you should avoid

19
00:00:38,320 --> 00:00:42,559
and the mistakes that we've seen during

20
00:00:40,160 --> 00:00:46,000
our work with produce metrics

21
00:00:42,559 --> 00:00:46,399
going in amazing but sometimes wild open

22
00:00:46,000 --> 00:00:49,120
source

23
00:00:46,399 --> 00:00:50,079
world so before that short introduction

24
00:00:49,120 --> 00:00:52,239
my name is

25
00:00:50,079 --> 00:00:53,280
bartek podka i am engineer working at

26
00:00:52,239 --> 00:00:55,440
red hat team

27
00:00:53,280 --> 00:00:57,600
monitoring openshift team and i love

28
00:00:55,440 --> 00:00:59,680
open source i love solving problems

29
00:00:57,600 --> 00:01:02,160
usually using go and i'm part of the

30
00:00:59,680 --> 00:01:04,000
promuteus team and i also co-authored

31
00:01:02,160 --> 00:01:05,280
co-author of the thanos project which

32
00:01:04,000 --> 00:01:07,840
essentially

33
00:01:05,280 --> 00:01:08,960
is a durable system scaling that scales

34
00:01:07,840 --> 00:01:11,119
for me to use

35
00:01:08,960 --> 00:01:13,759
and with me there is a camel hello

36
00:01:11,119 --> 00:01:15,520
everyone my name is kami i also work for

37
00:01:13,760 --> 00:01:17,840
openshift monitoring team

38
00:01:15,520 --> 00:01:19,840
i love working with prometheus go and

39
00:01:17,840 --> 00:01:22,720
kubernetes as well and i'm also a

40
00:01:19,840 --> 00:01:26,240
contributor to thanos

41
00:01:22,720 --> 00:01:28,158
so let's have fun let's try well

42
00:01:26,240 --> 00:01:29,280
we'll talk about today about building a

43
00:01:28,159 --> 00:01:32,079
load balancer

44
00:01:29,280 --> 00:01:32,799
in go kind of for demo proposals let's

45
00:01:32,079 --> 00:01:34,798
imagine

46
00:01:32,799 --> 00:01:36,880
that we want to implement application

47
00:01:34,799 --> 00:01:39,200
level http load balancer

48
00:01:36,880 --> 00:01:40,000
and let's say we'll do it in go because

49
00:01:39,200 --> 00:01:41,520
why not

50
00:01:40,000 --> 00:01:43,119
but essentially programming language

51
00:01:41,520 --> 00:01:44,960
here doesn't matter we just

52
00:01:43,119 --> 00:01:47,360
choose go because most of infrastructure

53
00:01:44,960 --> 00:01:49,280
stuff we are doing are in this language

54
00:01:47,360 --> 00:01:51,439
so let's say we implemented uh yeah

55
00:01:49,280 --> 00:01:52,159
transport transparent load balancer like

56
00:01:51,439 --> 00:01:53,758
this

57
00:01:52,159 --> 00:01:55,280
and from high level view we have a

58
00:01:53,759 --> 00:01:57,759
couple of components

59
00:01:55,280 --> 00:01:59,520
in go so first of all we have like

60
00:01:57,759 --> 00:02:02,079
single http server

61
00:01:59,520 --> 00:02:03,439
that implements serv http method um so

62
00:02:02,079 --> 00:02:06,960
handler via

63
00:02:03,439 --> 00:02:10,399
a really nice reverse proxy um structure

64
00:02:06,960 --> 00:02:11,840
in available in hd http util standard

65
00:02:10,399 --> 00:02:14,400
library in go

66
00:02:11,840 --> 00:02:15,360
and then this reverse proxy allows us to

67
00:02:14,400 --> 00:02:19,200
inject and

68
00:02:15,360 --> 00:02:20,319
custom custom transport which is like

69
00:02:19,200 --> 00:02:23,119
run tripper

70
00:02:20,319 --> 00:02:24,720
and so we implemented our own transport

71
00:02:23,120 --> 00:02:28,000
called lb transport

72
00:02:24,720 --> 00:02:29,200
which um essentially i have few

73
00:02:28,000 --> 00:02:32,239
components first of all

74
00:02:29,200 --> 00:02:32,879
it has discover which is which gives us

75
00:02:32,239 --> 00:02:35,440
a target

76
00:02:32,879 --> 00:02:36,079
to proxy to and then based on those

77
00:02:35,440 --> 00:02:39,120
targets

78
00:02:36,080 --> 00:02:41,440
um uh round robin picker picks uh the

79
00:02:39,120 --> 00:02:43,440
one in roundtrope in fair manner so you

80
00:02:41,440 --> 00:02:45,040
know first repeat one then replica two

81
00:02:43,440 --> 00:02:48,640
three one two three

82
00:02:45,040 --> 00:02:50,319
um so um and then the load balancer

83
00:02:48,640 --> 00:02:52,480
uh forwards the request to the given

84
00:02:50,319 --> 00:02:52,799
replica and proxy the response back to

85
00:02:52,480 --> 00:02:55,920
the

86
00:02:52,800 --> 00:02:57,840
to the user um so this looks great

87
00:02:55,920 --> 00:02:59,679
this looks like well this implementation

88
00:02:57,840 --> 00:03:02,239
should work why not

89
00:02:59,680 --> 00:03:04,239
um so let's say we deploy this you know

90
00:03:02,239 --> 00:03:05,519
couple of replicas of this behind some

91
00:03:04,239 --> 00:03:07,280
uh micro services

92
00:03:05,519 --> 00:03:08,879
in front of some microphase micro

93
00:03:07,280 --> 00:03:11,680
services and

94
00:03:08,879 --> 00:03:12,239
uh we let it run for a longer time and

95
00:03:11,680 --> 00:03:15,920
you know

96
00:03:12,239 --> 00:03:17,200
as soon as uh it it runs i will hit the

97
00:03:15,920 --> 00:03:19,679
lb end point

98
00:03:17,200 --> 00:03:21,119
tried out it works so well we are done

99
00:03:19,680 --> 00:03:24,720
right like it works

100
00:03:21,120 --> 00:03:26,640
well maybe not necessarily like

101
00:03:24,720 --> 00:03:28,000
it works for me but does it work for

102
00:03:26,640 --> 00:03:29,920
other users

103
00:03:28,000 --> 00:03:32,080
like what about if i'm not checking does

104
00:03:29,920 --> 00:03:34,480
it work at that time as well like

105
00:03:32,080 --> 00:03:35,360
do we have an information about like how

106
00:03:34,480 --> 00:03:39,359
many errors

107
00:03:35,360 --> 00:03:42,000
it um how many requests error

108
00:03:39,360 --> 00:03:43,519
uh like failed essentially with like 502

109
00:03:42,000 --> 00:03:44,239
status code which means like the load

110
00:03:43,519 --> 00:03:46,640
balancer

111
00:03:44,239 --> 00:03:48,640
could not proxy the request like we

112
00:03:46,640 --> 00:03:50,798
don't really have this information right

113
00:03:48,640 --> 00:03:53,040
and what about other questions like is

114
00:03:50,799 --> 00:03:55,439
one robin picker actually working

115
00:03:53,040 --> 00:03:56,319
is it actually picking in a fair manner

116
00:03:55,439 --> 00:03:58,480
is this

117
00:03:56,319 --> 00:04:00,640
is the replica number two actually

118
00:03:58,480 --> 00:04:02,640
having one first of the requests

119
00:04:00,640 --> 00:04:04,319
and what was the distribution like

120
00:04:02,640 --> 00:04:06,879
yesterday like

121
00:04:04,319 --> 00:04:08,079
how to tell that um and you know other

122
00:04:06,879 --> 00:04:10,000
questions like what about

123
00:04:08,080 --> 00:04:11,680
latency like the loan balancer is like

124
00:04:10,000 --> 00:04:14,319
endpoint is very slow and like

125
00:04:11,680 --> 00:04:14,959
is it my target being slow or maybe load

126
00:04:14,319 --> 00:04:17,120
balancer

127
00:04:14,959 --> 00:04:18,320
introduce some latency to the request

128
00:04:17,120 --> 00:04:20,160
right

129
00:04:18,320 --> 00:04:21,839
and finally you know maybe you are

130
00:04:20,160 --> 00:04:23,840
having

131
00:04:21,839 --> 00:04:25,599
some incident and you want to look what

132
00:04:23,840 --> 00:04:27,039
was the version yesterday that was

133
00:04:25,600 --> 00:04:30,320
running at 2pm

134
00:04:27,040 --> 00:04:32,479
and yeah what was wrong back then and

135
00:04:30,320 --> 00:04:33,840
this insight like is missing in our

136
00:04:32,479 --> 00:04:36,159
implementation right

137
00:04:33,840 --> 00:04:36,960
so what's missing is essentially a

138
00:04:36,160 --> 00:04:38,720
monitoring

139
00:04:36,960 --> 00:04:40,960
so we can have lots of those questions

140
00:04:38,720 --> 00:04:42,880
and we need to know

141
00:04:40,960 --> 00:04:44,400
i will be nice to have answers for those

142
00:04:42,880 --> 00:04:46,960
even though we don't know the questions

143
00:04:44,400 --> 00:04:49,039
even beforehand right that's why inside

144
00:04:46,960 --> 00:04:51,599
reliability uh engineering book

145
00:04:49,040 --> 00:04:52,560
i made written by by google guys you

146
00:04:51,600 --> 00:04:55,680
will find that

147
00:04:52,560 --> 00:04:57,840
monitoring is the foundation of the

148
00:04:55,680 --> 00:04:59,520
of having a production system and

149
00:04:57,840 --> 00:05:02,320
running production system before

150
00:04:59,520 --> 00:05:04,560
implementing the system itself and uh

151
00:05:02,320 --> 00:05:06,719
you know as you might be familiar

152
00:05:04,560 --> 00:05:09,280
some wintering signals are you know

153
00:05:06,720 --> 00:05:11,360
metrics logs tracing

154
00:05:09,280 --> 00:05:13,440
but you know guess which signal will

155
00:05:11,360 --> 00:05:15,280
help us in this case and like

156
00:05:13,440 --> 00:05:16,560
will give us the quickest answer to

157
00:05:15,280 --> 00:05:19,359
those questions

158
00:05:16,560 --> 00:05:21,600
and yeah the answer is metrics um

159
00:05:19,360 --> 00:05:23,840
metrics most likely give us the answer

160
00:05:21,600 --> 00:05:25,919
the answer that in comparison to locks

161
00:05:23,840 --> 00:05:29,440
and traces and maybe profiling

162
00:05:25,919 --> 00:05:31,758
is cheaper um nearly

163
00:05:29,440 --> 00:05:33,440
real time and definitely actionable so

164
00:05:31,759 --> 00:05:36,080
we can alert and act

165
00:05:33,440 --> 00:05:37,520
either humans can act on it or maybe

166
00:05:36,080 --> 00:05:39,919
computers as well

167
00:05:37,520 --> 00:05:41,280
and in practice metrics probably should

168
00:05:39,919 --> 00:05:44,240
be your first

169
00:05:41,280 --> 00:05:45,119
item on the monitoring to-do list and as

170
00:05:44,240 --> 00:05:47,680
bjorn mentioned

171
00:05:45,120 --> 00:05:48,639
uh on the talk before before us um

172
00:05:47,680 --> 00:05:52,080
instrument first

173
00:05:48,639 --> 00:05:52,639
ask questions later so that's uh and you

174
00:05:52,080 --> 00:05:55,520
know

175
00:05:52,639 --> 00:05:56,960
why promote use secondly well i might be

176
00:05:55,520 --> 00:05:59,280
biased but promote use

177
00:05:56,960 --> 00:06:00,318
for me is the simplest and the cheapest

178
00:05:59,280 --> 00:06:02,239
option for

179
00:06:00,319 --> 00:06:03,520
um collecting storing and querying

180
00:06:02,240 --> 00:06:06,880
metrics right now

181
00:06:03,520 --> 00:06:09,758
it fits both is part of cncf and

182
00:06:06,880 --> 00:06:11,840
also fits um simple applications like

183
00:06:09,759 --> 00:06:14,160
small applications but also bigger one

184
00:06:11,840 --> 00:06:16,638
bigger ones with help of other projects

185
00:06:14,160 --> 00:06:19,759
like cortextanos and 3db

186
00:06:16,639 --> 00:06:21,919
in the cncf space so well

187
00:06:19,759 --> 00:06:23,759
let's try to instrument our load

188
00:06:21,919 --> 00:06:26,639
balancer with metrics

189
00:06:23,759 --> 00:06:28,240
and well like let's try to answer this

190
00:06:26,639 --> 00:06:29,600
exact question like how many what's the

191
00:06:28,240 --> 00:06:32,639
error rate of

192
00:06:29,600 --> 00:06:34,880
our requests that users are seeing

193
00:06:32,639 --> 00:06:36,080
to do so we could introduce a counter

194
00:06:34,880 --> 00:06:38,080
right

195
00:06:36,080 --> 00:06:39,840
and we can inc we can we essentially

196
00:06:38,080 --> 00:06:41,758
have this information by incrementing

197
00:06:39,840 --> 00:06:44,400
this counter every time we hit

198
00:06:41,759 --> 00:06:45,360
we have a request in our server and we

199
00:06:44,400 --> 00:06:47,359
can

200
00:06:45,360 --> 00:06:49,120
report the method that was used and the

201
00:06:47,360 --> 00:06:52,240
response status code that was

202
00:06:49,120 --> 00:06:54,880
returned by the by the server so

203
00:06:52,240 --> 00:06:55,520
let's try to introduce this metric in

204
00:06:54,880 --> 00:06:58,880
goldman

205
00:06:55,520 --> 00:07:00,400
and we start that by i hope like you are

206
00:06:58,880 --> 00:07:02,240
familiar with that but we'll go through

207
00:07:00,400 --> 00:07:03,840
this pretty quickly

208
00:07:02,240 --> 00:07:06,479
so first of all like we are talking

209
00:07:03,840 --> 00:07:10,159
again about golang however

210
00:07:06,479 --> 00:07:12,240
there are like 18 other language

211
00:07:10,160 --> 00:07:14,720
programming languages supported by you

212
00:07:12,240 --> 00:07:18,400
know other libraries in the in in

213
00:07:14,720 --> 00:07:19,840
the in that languages and um but here we

214
00:07:18,400 --> 00:07:23,679
need to first import

215
00:07:19,840 --> 00:07:26,080
the official client go link library

216
00:07:23,680 --> 00:07:27,520
and to add the metric we are trying we

217
00:07:26,080 --> 00:07:30,080
need to define

218
00:07:27,520 --> 00:07:31,280
a variable we have to choose some names

219
00:07:30,080 --> 00:07:34,800
some descriptions

220
00:07:31,280 --> 00:07:37,440
help and labels and

221
00:07:34,800 --> 00:07:38,080
labels are our dimension for the metric

222
00:07:37,440 --> 00:07:41,520
right

223
00:07:38,080 --> 00:07:43,680
so each unique value in on any of those

224
00:07:41,520 --> 00:07:45,039
labels will result in totally new series

225
00:07:43,680 --> 00:07:47,280
and that's really important

226
00:07:45,039 --> 00:07:48,159
information as well next step is to

227
00:07:47,280 --> 00:07:50,400
actually use this

228
00:07:48,160 --> 00:07:51,840
variable use this counter right so we

229
00:07:50,400 --> 00:07:55,919
have like a

230
00:07:51,840 --> 00:07:57,758
server http wrapper that will

231
00:07:55,919 --> 00:07:59,520
do the request and then record the

232
00:07:57,759 --> 00:08:02,879
status and

233
00:07:59,520 --> 00:08:06,318
increment our counter using add one

234
00:08:02,879 --> 00:08:11,039
or there is even ink method that

235
00:08:06,319 --> 00:08:12,400
adds one more to the value

236
00:08:11,039 --> 00:08:14,318
and something that is really easy to

237
00:08:12,400 --> 00:08:15,520
forget is that the fact that we need to

238
00:08:14,319 --> 00:08:18,160
register the metric

239
00:08:15,520 --> 00:08:19,120
and we do that via package level mass

240
00:08:18,160 --> 00:08:22,160
register

241
00:08:19,120 --> 00:08:24,879
function then thanks to that we

242
00:08:22,160 --> 00:08:25,759
have we can add another endpoint to our

243
00:08:24,879 --> 00:08:27,680
server

244
00:08:25,759 --> 00:08:30,240
slash matrix which is like the

245
00:08:27,680 --> 00:08:33,440
convention and this endpoint give

246
00:08:30,240 --> 00:08:36,000
returns a metric exposition format

247
00:08:33,440 --> 00:08:36,479
text metric expression format like this

248
00:08:36,000 --> 00:08:38,399
so

249
00:08:36,479 --> 00:08:40,080
it gives us the metrics that we

250
00:08:38,399 --> 00:08:44,240
registered via this

251
00:08:40,080 --> 00:08:45,680
register so once we add that to our loan

252
00:08:44,240 --> 00:08:47,839
balancer

253
00:08:45,680 --> 00:08:49,439
we can connect promoters so it's like a

254
00:08:47,839 --> 00:08:50,399
single binary that you run in the same

255
00:08:49,440 --> 00:08:53,279
cluster

256
00:08:50,399 --> 00:08:55,200
and point to the load balancer metric

257
00:08:53,279 --> 00:08:56,240
endpoint and it will periodically

258
00:08:55,200 --> 00:08:59,279
collect those

259
00:08:56,240 --> 00:09:01,760
metrics let's say every 15 seconds and

260
00:08:59,279 --> 00:09:02,320
this way you can then go to the ui after

261
00:09:01,760 --> 00:09:04,319
some time

262
00:09:02,320 --> 00:09:06,000
the problem to use ui or grafana and

263
00:09:04,320 --> 00:09:09,680
actually use those metrics so

264
00:09:06,000 --> 00:09:12,880
here we can see um the

265
00:09:09,680 --> 00:09:13,920
number of requests per minute by code

266
00:09:12,880 --> 00:09:16,320
and method

267
00:09:13,920 --> 00:09:17,040
and you can see that we have like 120

268
00:09:16,320 --> 00:09:18,959
total

269
00:09:17,040 --> 00:09:20,160
some of them are errors most of them are

270
00:09:18,959 --> 00:09:22,479
successes so

271
00:09:20,160 --> 00:09:23,920
this is great like our load balancer has

272
00:09:22,480 --> 00:09:27,279
some insights

273
00:09:23,920 --> 00:09:29,599
allow us to debug stuff and and know

274
00:09:27,279 --> 00:09:30,720
uh what is happening inside so this

275
00:09:29,600 --> 00:09:32,720
looks easy right we

276
00:09:30,720 --> 00:09:33,839
few steps few lines of code and we have

277
00:09:32,720 --> 00:09:36,880
metrics so

278
00:09:33,839 --> 00:09:39,120
everything is perfect well not really

279
00:09:36,880 --> 00:09:42,240
there are some edge cases right

280
00:09:39,120 --> 00:09:43,360
um it looked easy but in the you know in

281
00:09:42,240 --> 00:09:46,560
most cases well

282
00:09:43,360 --> 00:09:47,440
in some cases um during our work we've

283
00:09:46,560 --> 00:09:50,479
seen that

284
00:09:47,440 --> 00:09:52,080
it can cause some problems so um

285
00:09:50,480 --> 00:09:53,760
and this is what we learned during you

286
00:09:52,080 --> 00:09:56,160
know reviewing and developing

287
00:09:53,760 --> 00:09:57,760
and instrumentation code that is meant

288
00:09:56,160 --> 00:10:00,319
to be run on production

289
00:09:57,760 --> 00:10:02,000
uh in close but mainly on open source so

290
00:10:00,320 --> 00:10:04,399
we'll go with camel with few

291
00:10:02,000 --> 00:10:05,440
less and more advanced issues and how to

292
00:10:04,399 --> 00:10:07,279
resolve them

293
00:10:05,440 --> 00:10:08,959
first one pitfall number one global

294
00:10:07,279 --> 00:10:11,920
registry

295
00:10:08,959 --> 00:10:13,760
so there is a saying uh in very good

296
00:10:11,920 --> 00:10:15,040
peterborough blog post a theory of

297
00:10:13,760 --> 00:10:17,760
modern go

298
00:10:15,040 --> 00:10:19,360
a global global magic is by the global

299
00:10:17,760 --> 00:10:20,079
state this magic and that's certainly

300
00:10:19,360 --> 00:10:22,320
true

301
00:10:20,079 --> 00:10:25,120
um in in all of those cases especially

302
00:10:22,320 --> 00:10:27,839
if you use promotes client to instrument

303
00:10:25,120 --> 00:10:29,440
um your application with metrics and

304
00:10:27,839 --> 00:10:32,399
application i mean let's say you

305
00:10:29,440 --> 00:10:34,399
instrument a library right and you can

306
00:10:32,399 --> 00:10:34,880
imagine that this library will be used

307
00:10:34,399 --> 00:10:36,880
by

308
00:10:34,880 --> 00:10:37,920
your project but also for other users in

309
00:10:36,880 --> 00:10:40,880
open source

310
00:10:37,920 --> 00:10:42,719
and um and this can cause problems and

311
00:10:40,880 --> 00:10:44,480
you will see why in a second

312
00:10:42,720 --> 00:10:46,880
and especially this is important because

313
00:10:44,480 --> 00:10:48,800
somehow in promotion's ecosystem

314
00:10:46,880 --> 00:10:50,240
like this pattern of using global

315
00:10:48,800 --> 00:10:53,680
registry leaked

316
00:10:50,240 --> 00:10:55,920
as a good pattern it is not and we are

317
00:10:53,680 --> 00:10:57,359
really uh really trying to make don't

318
00:10:55,920 --> 00:11:00,319
laugh

319
00:10:57,360 --> 00:11:00,320
it's really wrong and

320
00:11:00,880 --> 00:11:03,920
essentially we want to make sure it's

321
00:11:02,399 --> 00:11:05,279
obsolete and we'll show you

322
00:11:03,920 --> 00:11:07,599
better way and essentially what are the

323
00:11:05,279 --> 00:11:08,720
consequences if you are using a global

324
00:11:07,600 --> 00:11:11,920
registry right

325
00:11:08,720 --> 00:11:13,360
so let's take our example again and as

326
00:11:11,920 --> 00:11:14,560
you might see there are two global

327
00:11:13,360 --> 00:11:16,959
states here

328
00:11:14,560 --> 00:11:19,199
first of all we have a global variable

329
00:11:16,959 --> 00:11:22,000
secondly we have a global registry

330
00:11:19,200 --> 00:11:23,120
so mass register heights underneath the

331
00:11:22,000 --> 00:11:25,600
default register

332
00:11:23,120 --> 00:11:26,880
struct that holds the global state per

333
00:11:25,600 --> 00:11:28,240
package

334
00:11:26,880 --> 00:11:30,399
now what's the issue what's the problem

335
00:11:28,240 --> 00:11:34,160
right so first of all

336
00:11:30,399 --> 00:11:36,959
um it's a magic so it means that

337
00:11:34,160 --> 00:11:37,680
if another package just uh you just

338
00:11:36,959 --> 00:11:39,839
imported

339
00:11:37,680 --> 00:11:42,160
or dependency of the packages you

340
00:11:39,839 --> 00:11:43,760
imported um

341
00:11:42,160 --> 00:11:45,360
registered a metric with exactly the

342
00:11:43,760 --> 00:11:46,079
same name that you want to register

343
00:11:45,360 --> 00:11:47,519
right now

344
00:11:46,079 --> 00:11:49,439
it will explode like everything will

345
00:11:47,519 --> 00:11:51,279
panic and the problem is it will panic

346
00:11:49,440 --> 00:11:52,639
with the stack trace on the of the

347
00:11:51,279 --> 00:11:54,240
second registration

348
00:11:52,639 --> 00:11:56,240
and you have no idea what was the first

349
00:11:54,240 --> 00:11:57,839
registration at all like you need to dig

350
00:11:56,240 --> 00:11:59,600
through code like um

351
00:11:57,839 --> 00:12:01,760
i don't know like reg apps or whatever

352
00:11:59,600 --> 00:12:03,680
just change your metric name like it's

353
00:12:01,760 --> 00:12:05,439
it's magic and like i had this problem

354
00:12:03,680 --> 00:12:08,479
so many times even on standard

355
00:12:05,440 --> 00:12:11,279
goal libraries when you uh

356
00:12:08,480 --> 00:12:12,240
kind of register like a goal like memory

357
00:12:11,279 --> 00:12:14,240
kind of

358
00:12:12,240 --> 00:12:16,000
matrix as well like this is very common

359
00:12:14,240 --> 00:12:18,959
thing this is why you should not use

360
00:12:16,000 --> 00:12:20,959
global registry the second problem is

361
00:12:18,959 --> 00:12:21,518
lack of flexibility so let's imagine we

362
00:12:20,959 --> 00:12:24,399
have

363
00:12:21,519 --> 00:12:24,880
not one endpoint but three one two three

364
00:12:24,399 --> 00:12:26,720
and

365
00:12:24,880 --> 00:12:29,040
we just increment metric on each of

366
00:12:26,720 --> 00:12:30,639
those now you can see we

367
00:12:29,040 --> 00:12:32,319
don't have really much of the

368
00:12:30,639 --> 00:12:34,079
information here like let's say

369
00:12:32,320 --> 00:12:35,440
if i want to know the what's the error

370
00:12:34,079 --> 00:12:37,359
rate of um

371
00:12:35,440 --> 00:12:39,120
of endpoint of the met of the request

372
00:12:37,360 --> 00:12:40,480
against at point number three

373
00:12:39,120 --> 00:12:42,959
we don't know because everything is

374
00:12:40,480 --> 00:12:43,920
grouped together now let's say i want to

375
00:12:42,959 --> 00:12:45,839
actually

376
00:12:43,920 --> 00:12:48,000
have that information right what should

377
00:12:45,839 --> 00:12:50,720
i what should i do in this case

378
00:12:48,000 --> 00:12:52,800
um well remove the global state right so

379
00:12:50,720 --> 00:12:55,279
so let's fix this problem

380
00:12:52,800 --> 00:12:56,399
first of all instead of our variable uh

381
00:12:55,279 --> 00:12:59,439
global variable we

382
00:12:56,399 --> 00:13:01,360
create a struct that wraps the

383
00:12:59,440 --> 00:13:03,920
the variable and you can instantiate

384
00:13:01,360 --> 00:13:06,639
finally those variables as you want

385
00:13:03,920 --> 00:13:07,839
so finally you can have many of those

386
00:13:06,639 --> 00:13:10,560
metrics

387
00:13:07,839 --> 00:13:11,120
however if you start to use this way in

388
00:13:10,560 --> 00:13:15,279
this way

389
00:13:11,120 --> 00:13:17,920
and um and use our new metric

390
00:13:15,279 --> 00:13:19,760
sorry um it's still registered in a

391
00:13:17,920 --> 00:13:22,880
global state so let's remove that

392
00:13:19,760 --> 00:13:26,399
default registry with custom registered

393
00:13:22,880 --> 00:13:29,519
that you can instantiate again and you

394
00:13:26,399 --> 00:13:32,079
can inject inside our new server metrics

395
00:13:29,519 --> 00:13:34,000
and in this way each you are in the

396
00:13:32,079 --> 00:13:36,719
control of your registry because i just

397
00:13:34,000 --> 00:13:38,639
created that i added some metrics i can

398
00:13:36,720 --> 00:13:39,600
add more metrics like default go like

399
00:13:38,639 --> 00:13:41,680
one as well

400
00:13:39,600 --> 00:13:43,360
and i'm in control i know explicitly

401
00:13:41,680 --> 00:13:46,479
what i added to that so

402
00:13:43,360 --> 00:13:48,560
i i can test it i can do whatever and

403
00:13:46,480 --> 00:13:49,680
it's super powerful so let's see if we

404
00:13:48,560 --> 00:13:52,399
can achieve our goal

405
00:13:49,680 --> 00:13:54,160
with flexibility as well this will panic

406
00:13:52,399 --> 00:13:56,959
obviously because we just use

407
00:13:54,160 --> 00:13:59,360
those we try to register three times

408
00:13:56,959 --> 00:14:01,920
metric with exactly the same name

409
00:13:59,360 --> 00:14:03,760
so that's a problem however we can

410
00:14:01,920 --> 00:14:06,240
resolve that very very easily

411
00:14:03,760 --> 00:14:07,680
with something called wrap with labels

412
00:14:06,240 --> 00:14:09,600
method

413
00:14:07,680 --> 00:14:11,199
function sorry which allows you to

414
00:14:09,600 --> 00:14:14,079
inject a certain

415
00:14:11,199 --> 00:14:15,519
static labels or prefix to the metrics

416
00:14:14,079 --> 00:14:16,560
and that's exactly what we need here

417
00:14:15,519 --> 00:14:19,440
right because we

418
00:14:16,560 --> 00:14:20,959
uh we want to group our metrics per per

419
00:14:19,440 --> 00:14:24,000
handler so suddenly

420
00:14:20,959 --> 00:14:25,518
thanks of that we have um yeah we can we

421
00:14:24,000 --> 00:14:28,560
know what's the error rate of the

422
00:14:25,519 --> 00:14:30,480
endpoint number three so this is the

423
00:14:28,560 --> 00:14:32,399
pattern i would suggest instead instead

424
00:14:30,480 --> 00:14:34,160
of doing default registry and this is

425
00:14:32,399 --> 00:14:36,639
what we already do for example in thanos

426
00:14:34,160 --> 00:14:38,560
project for every package we use

427
00:14:36,639 --> 00:14:41,199
it's somehow more code but trust me like

428
00:14:38,560 --> 00:14:41,199
it's worth it

429
00:14:41,519 --> 00:14:45,680
pitfall number two no tests and this is

430
00:14:44,160 --> 00:14:46,399
something i'm really passionate about

431
00:14:45,680 --> 00:14:48,319
because

432
00:14:46,399 --> 00:14:50,240
metrics and other observability signals

433
00:14:48,320 --> 00:14:50,720
like tracing the logs are never tested

434
00:14:50,240 --> 00:14:53,199
like

435
00:14:50,720 --> 00:14:54,320
like literally who test the lock line if

436
00:14:53,199 --> 00:14:56,399
it's um

437
00:14:54,320 --> 00:14:58,560
actually logged in a proper moment with

438
00:14:56,399 --> 00:14:59,519
the proper message like no one do that

439
00:14:58,560 --> 00:15:03,760
because usually

440
00:14:59,519 --> 00:15:05,839
log lines are um are for kind of

441
00:15:03,760 --> 00:15:07,360
um for humans right they just need to

442
00:15:05,839 --> 00:15:08,160
read so maybe exact message doesn't

443
00:15:07,360 --> 00:15:10,959
matter

444
00:15:08,160 --> 00:15:11,680
however i would argue that for metrics

445
00:15:10,959 --> 00:15:13,279
well

446
00:15:11,680 --> 00:15:15,279
it's really important to test it like

447
00:15:13,279 --> 00:15:16,880
the reliability of the metric and you

448
00:15:15,279 --> 00:15:18,399
depend on the metric so much that you

449
00:15:16,880 --> 00:15:20,560
should actually test it and

450
00:15:18,399 --> 00:15:22,079
i will tell you i mean let's see why we

451
00:15:20,560 --> 00:15:24,399
should do that first of all

452
00:15:22,079 --> 00:15:26,319
so let's take our example our load

453
00:15:24,399 --> 00:15:28,480
balancer with our metric

454
00:15:26,320 --> 00:15:29,839
and we are solid 10x developers

455
00:15:28,480 --> 00:15:32,880
obviously so we want to test

456
00:15:29,839 --> 00:15:35,920
our our load balancer properly

457
00:15:32,880 --> 00:15:38,320
so we created a unit test so what we did

458
00:15:35,920 --> 00:15:40,240
was essentially we have lb transport run

459
00:15:38,320 --> 00:15:42,079
trooper we mocked different things like

460
00:15:40,240 --> 00:15:44,720
discover and run through

461
00:15:42,079 --> 00:15:47,040
we mocked our targets to be unavailable

462
00:15:44,720 --> 00:15:49,680
just for simple test case

463
00:15:47,040 --> 00:15:50,560
and we mocked response as well and a

464
00:15:49,680 --> 00:15:53,680
request

465
00:15:50,560 --> 00:15:56,079
to test if and how the this looks like

466
00:15:53,680 --> 00:15:57,839
essentially we send free requests and

467
00:15:56,079 --> 00:15:58,560
because nothing is available we should

468
00:15:57,839 --> 00:16:00,959
expect

469
00:15:58,560 --> 00:16:03,439
have we should uh assert on three

470
00:16:00,959 --> 00:16:06,800
responses being from the 502.

471
00:16:03,440 --> 00:16:08,720
um really easy this test passed it

472
00:16:06,800 --> 00:16:11,040
looks in the code like this you have a

473
00:16:08,720 --> 00:16:14,160
unit test you start a load balancer

474
00:16:11,040 --> 00:16:17,599
and then you send free requests and you

475
00:16:14,160 --> 00:16:20,079
by using http tests very useful package

476
00:16:17,600 --> 00:16:20,800
standard package as well you record the

477
00:16:20,079 --> 00:16:23,519
response

478
00:16:20,800 --> 00:16:24,399
of this and assure that it's five or two

479
00:16:23,519 --> 00:16:28,160
three times

480
00:16:24,399 --> 00:16:28,639
easy so now we are kind of safe right

481
00:16:28,160 --> 00:16:30,800
like

482
00:16:28,639 --> 00:16:32,079
uh everything we tested everything like

483
00:16:30,800 --> 00:16:34,800
we can do different

484
00:16:32,079 --> 00:16:35,359
test cases as well but we are fine right

485
00:16:34,800 --> 00:16:37,758
well

486
00:16:35,360 --> 00:16:40,320
not really because imagine we made a bug

487
00:16:37,759 --> 00:16:41,920
in instrumenting the metric and suddenly

488
00:16:40,320 --> 00:16:44,560
we forgot to instrument properly the

489
00:16:41,920 --> 00:16:47,599
code and we always put 200.

490
00:16:44,560 --> 00:16:49,119
um so what happened well you send free

491
00:16:47,600 --> 00:16:51,759
requests you assert on

492
00:16:49,120 --> 00:16:53,199
free responses 502 but suddenly if you'd

493
00:16:51,759 --> 00:16:56,000
apply that on production

494
00:16:53,199 --> 00:16:56,959
if you have some errors the metric page

495
00:16:56,000 --> 00:16:59,040
would show you

496
00:16:56,959 --> 00:17:00,560
like success everything is fine and like

497
00:16:59,040 --> 00:17:02,319
it's super easy to make those bugs like

498
00:17:00,560 --> 00:17:05,520
it's a code like and others

499
00:17:02,320 --> 00:17:07,120
like any other so um this is pretty

500
00:17:05,520 --> 00:17:09,039
serious and why is serious like someone

501
00:17:07,119 --> 00:17:09,520
can say okay this is like analytic think

502
00:17:09,039 --> 00:17:11,280
like

503
00:17:09,520 --> 00:17:12,720
it's a small bag maybe mislead some

504
00:17:11,280 --> 00:17:14,959
people but who cares

505
00:17:12,720 --> 00:17:16,319
well not because like look at this like

506
00:17:14,959 --> 00:17:18,799
this is the alert that is

507
00:17:16,319 --> 00:17:20,879
very very popular nowadays like

508
00:17:18,799 --> 00:17:22,559
essentially is it allows on symptoms of

509
00:17:20,880 --> 00:17:23,679
the user not being able to use your

510
00:17:22,559 --> 00:17:26,720
service right

511
00:17:23,679 --> 00:17:27,439
so um and it actually um relies on the

512
00:17:26,720 --> 00:17:28,880
metric

513
00:17:27,439 --> 00:17:30,720
and suddenly if you have like all

514
00:17:28,880 --> 00:17:33,280
successes uh

515
00:17:30,720 --> 00:17:33,760
reported by this metric even though

516
00:17:33,280 --> 00:17:36,559
there were

517
00:17:33,760 --> 00:17:38,320
lots of errors this alert will not fire

518
00:17:36,559 --> 00:17:40,160
and you rely on this this file

519
00:17:38,320 --> 00:17:41,600
and this alert to be fired you know

520
00:17:40,160 --> 00:17:42,400
during night for example during

521
00:17:41,600 --> 00:17:46,080
incidents so

522
00:17:42,400 --> 00:17:47,840
it's really bad if you um if you don't

523
00:17:46,080 --> 00:17:50,159
test your metric

524
00:17:47,840 --> 00:17:51,360
so what we want to do is to extend this

525
00:17:50,160 --> 00:17:53,600
test a little bit and

526
00:17:51,360 --> 00:17:55,760
first of all because there are no no

527
00:17:53,600 --> 00:17:57,678
traffic no request we assert on

528
00:17:55,760 --> 00:17:59,919
zero cardinality so there is there

529
00:17:57,679 --> 00:18:02,799
should be no series

530
00:17:59,919 --> 00:18:04,240
given by this metric after the traffic

531
00:18:02,799 --> 00:18:06,879
after our free request

532
00:18:04,240 --> 00:18:09,039
we should still um or assert on kind of

533
00:18:06,880 --> 00:18:11,360
correctness of our application

534
00:18:09,039 --> 00:18:13,440
but then answered also about cardinality

535
00:18:11,360 --> 00:18:16,159
that hey we should have one metric

536
00:18:13,440 --> 00:18:17,919
and we also should answer that this one

537
00:18:16,160 --> 00:18:21,679
metric should have a value free

538
00:18:17,919 --> 00:18:22,960
for 502 code and let's see how we can do

539
00:18:21,679 --> 00:18:25,520
that in the go

540
00:18:22,960 --> 00:18:27,280
again we have nice server matrix

541
00:18:25,520 --> 00:18:31,360
structure

542
00:18:27,280 --> 00:18:33,918
we have our unit test we

543
00:18:31,360 --> 00:18:35,520
use a really handy promote use test util

544
00:18:33,919 --> 00:18:38,320
package

545
00:18:35,520 --> 00:18:40,080
and then if before any we do anything we

546
00:18:38,320 --> 00:18:41,918
assert that this metric is

547
00:18:40,080 --> 00:18:44,559
not incremented there is no metric

548
00:18:41,919 --> 00:18:46,000
return kind of there is no cardinality

549
00:18:44,559 --> 00:18:47,840
and we do that with the call it and

550
00:18:46,000 --> 00:18:50,960
count function

551
00:18:47,840 --> 00:18:51,760
then we do the request a search the

552
00:18:50,960 --> 00:18:52,960
correctness

553
00:18:51,760 --> 00:18:55,200
and then check if there is one

554
00:18:52,960 --> 00:18:58,480
cardinality at the end

555
00:18:55,200 --> 00:19:02,480
and then we check the value of 3 using

556
00:18:58,480 --> 00:19:05,600
2 float64 very explicit name

557
00:19:02,480 --> 00:19:06,640
and and check if the value is free now

558
00:19:05,600 --> 00:19:09,120
what is

559
00:19:06,640 --> 00:19:10,320
powerful here is that when i re i will

560
00:19:09,120 --> 00:19:13,039
run this test

561
00:19:10,320 --> 00:19:14,960
and i have the bug i mentioned it will

562
00:19:13,039 --> 00:19:16,480
fail like it is exactly what we wanted

563
00:19:14,960 --> 00:19:18,720
to achieve right so

564
00:19:16,480 --> 00:19:20,160
um this is really powerful like with few

565
00:19:18,720 --> 00:19:23,200
lines of code you can add

566
00:19:20,160 --> 00:19:23,919
on top of existing unit tests um you

567
00:19:23,200 --> 00:19:25,600
know

568
00:19:23,919 --> 00:19:27,280
some tests against your observability

569
00:19:25,600 --> 00:19:28,959
and i really encourage you to do so

570
00:19:27,280 --> 00:19:30,399
and we do that in the thanos code if you

571
00:19:28,960 --> 00:19:32,240
want to look on examples

572
00:19:30,400 --> 00:19:35,120
so now i will let camel to talk about

573
00:19:32,240 --> 00:19:35,120
other pitfalls

574
00:19:36,960 --> 00:19:41,840
yes all right uh yeah one of the other

575
00:19:40,080 --> 00:19:43,918
pitfalls pitfall number three is about

576
00:19:41,840 --> 00:19:46,879
lack of consistency

577
00:19:43,919 --> 00:19:48,480
uh there are some high level uh methods

578
00:19:46,880 --> 00:19:52,400
that we can use with the metrics

579
00:19:48,480 --> 00:19:55,120
to observe our applications uh which

580
00:19:52,400 --> 00:19:56,080
uh one of like the four golden signals

581
00:19:55,120 --> 00:19:59,199
from the

582
00:19:56,080 --> 00:19:59,840
google sre book uh use method and red

583
00:19:59,200 --> 00:20:02,640
method

584
00:19:59,840 --> 00:20:04,240
which is uh by tom milkey if it's over

585
00:20:02,640 --> 00:20:07,600
there

586
00:20:04,240 --> 00:20:11,200
and let's for that take red methods

587
00:20:07,600 --> 00:20:11,760
uh so these methods kind of help us uh

588
00:20:11,200 --> 00:20:14,080
because

589
00:20:11,760 --> 00:20:14,960
like with the details of these methods

590
00:20:14,080 --> 00:20:17,840
uh we define

591
00:20:14,960 --> 00:20:19,200
uh some predefined signals uh so that we

592
00:20:17,840 --> 00:20:22,959
can potentially debug

593
00:20:19,200 --> 00:20:25,280
and alert on our applications

594
00:20:22,960 --> 00:20:26,799
also with the help of these common

595
00:20:25,280 --> 00:20:29,918
methods we can build some

596
00:20:26,799 --> 00:20:32,080
we can reuse pre-built alerts and rules

597
00:20:29,919 --> 00:20:34,320
and dashboards as well

598
00:20:32,080 --> 00:20:35,439
so for the red method uh r stand for

599
00:20:34,320 --> 00:20:39,039
request per second

600
00:20:35,440 --> 00:20:41,360
uh e for errors and uh default duration

601
00:20:39,039 --> 00:20:43,360
so for our demo application uh let's

602
00:20:41,360 --> 00:20:44,320
again define an http request total

603
00:20:43,360 --> 00:20:46,320
method

604
00:20:44,320 --> 00:20:48,000
and in this method we can actually

605
00:20:46,320 --> 00:20:51,760
aggregate and track

606
00:20:48,000 --> 00:20:52,640
requests so for requests we already have

607
00:20:51,760 --> 00:20:54,960
code and

608
00:20:52,640 --> 00:20:56,480
method labels and so we can track them

609
00:20:54,960 --> 00:20:58,320
by calling method

610
00:20:56,480 --> 00:20:59,840
for the errors we can actually write

611
00:20:58,320 --> 00:21:03,439
some queries on

612
00:20:59,840 --> 00:21:06,720
status code but

613
00:21:03,440 --> 00:21:08,640
we don't have a duration just by using a

614
00:21:06,720 --> 00:21:10,720
counter so we need to introduce a

615
00:21:08,640 --> 00:21:13,120
histogram for that

616
00:21:10,720 --> 00:21:14,559
so by introducing a histogram we can

617
00:21:13,120 --> 00:21:17,039
track the duration so that we can

618
00:21:14,559 --> 00:21:20,960
calculate our latencies

619
00:21:17,039 --> 00:21:23,120
uh so reach like by just having

620
00:21:20,960 --> 00:21:25,679
uh by just like confirming a couple of

621
00:21:23,120 --> 00:21:27,760
conventions uh we will end up using

622
00:21:25,679 --> 00:21:31,360
uh really cool libraries like monitoring

623
00:21:27,760 --> 00:21:34,400
mixings and whatnot

624
00:21:31,360 --> 00:21:35,918
so uh of course another pitfall is about

625
00:21:34,400 --> 00:21:37,760
naming and

626
00:21:35,919 --> 00:21:38,960
it's of course one of the common

627
00:21:37,760 --> 00:21:42,320
pitfalls because

628
00:21:38,960 --> 00:21:45,520
uh you know naming is one of the hardest

629
00:21:42,320 --> 00:21:48,559
problems in computer science but

630
00:21:45,520 --> 00:21:50,000
it's supposed to be easy for prometheus

631
00:21:48,559 --> 00:21:52,080
because we have an official

632
00:21:50,000 --> 00:21:54,880
documentation so it's really

633
00:21:52,080 --> 00:21:56,080
a really good written and you just need

634
00:21:54,880 --> 00:22:00,320
to use it

635
00:21:56,080 --> 00:22:00,320
and yeah it's helpful just do it

636
00:22:00,720 --> 00:22:06,720
uh to like demonstrate or emphasize a

637
00:22:04,000 --> 00:22:10,320
couple of points from that documentation

638
00:22:06,720 --> 00:22:13,520
uh like you need to suffix your methods

639
00:22:10,320 --> 00:22:16,559
uh with base units the bayesian form is

640
00:22:13,520 --> 00:22:20,000
important so that you can transform uh

641
00:22:16,559 --> 00:22:23,039
your units between other units

642
00:22:20,000 --> 00:22:26,159
practically for accumulating counters

643
00:22:23,039 --> 00:22:27,200
you need to use total as a suffix this

644
00:22:26,159 --> 00:22:30,480
actually will be

645
00:22:27,200 --> 00:22:33,919
uh mandatory bit open metrics

646
00:22:30,480 --> 00:22:37,840
so maybe it's a good time to just try to

647
00:22:33,919 --> 00:22:41,039
convert your metrics and

648
00:22:37,840 --> 00:22:43,918
please use infosuffix for your meta

649
00:22:41,039 --> 00:22:47,760
information metrics

650
00:22:43,919 --> 00:22:49,200
all right uh again uh about naming

651
00:22:47,760 --> 00:22:52,879
there's another aspect of it

652
00:22:49,200 --> 00:22:55,039
it's stability so if you use a

653
00:22:52,880 --> 00:22:57,760
let's see an example for that again

654
00:22:55,039 --> 00:23:01,360
again same example http request total

655
00:22:57,760 --> 00:23:02,080
and if you define this and for whatever

656
00:23:01,360 --> 00:23:05,120
reason

657
00:23:02,080 --> 00:23:07,678
a reason at certain oh sorry

658
00:23:05,120 --> 00:23:09,199
and you decide to use that in an alert

659
00:23:07,679 --> 00:23:11,760
and for about every reason

660
00:23:09,200 --> 00:23:14,159
at some certain point you decide to

661
00:23:11,760 --> 00:23:17,280
change the name and put a protocol in it

662
00:23:14,159 --> 00:23:19,520
now you actually break your alert

663
00:23:17,280 --> 00:23:20,399
and this won't fire but it's it also

664
00:23:19,520 --> 00:23:23,200
won't fail

665
00:23:20,400 --> 00:23:23,919
so you can create these implicit errors

666
00:23:23,200 --> 00:23:26,240
for your

667
00:23:23,919 --> 00:23:29,039
system so just be consistent and be

668
00:23:26,240 --> 00:23:31,840
careful with your names

669
00:23:29,039 --> 00:23:33,600
all right pitfall number five uh

670
00:23:31,840 --> 00:23:35,360
cardinality so

671
00:23:33,600 --> 00:23:36,959
when we talk about prometheus and

672
00:23:35,360 --> 00:23:39,520
performance it always

673
00:23:36,960 --> 00:23:42,000
comes down to cardinality so what is

674
00:23:39,520 --> 00:23:44,158
cardinality actually in this case

675
00:23:42,000 --> 00:23:45,919
in prometus context the cardinality is

676
00:23:44,159 --> 00:23:46,400
the amount of unique time series that

677
00:23:45,919 --> 00:23:49,520
you have

678
00:23:46,400 --> 00:23:50,000
in your system and don't forget like

679
00:23:49,520 --> 00:23:52,240
whenever

680
00:23:50,000 --> 00:23:53,919
you use a unique label value with your

681
00:23:52,240 --> 00:23:54,960
metric name it creates another time

682
00:23:53,919 --> 00:23:58,159
series

683
00:23:54,960 --> 00:24:00,480
so labels are so powerful uh but however

684
00:23:58,159 --> 00:24:02,080
you should just be very careful very

685
00:24:00,480 --> 00:24:06,000
considerate when you use them

686
00:24:02,080 --> 00:24:07,760
so let's again see an example for this

687
00:24:06,000 --> 00:24:09,520
again we are using the same metric we

688
00:24:07,760 --> 00:24:11,919
are at this point very familiar with

689
00:24:09,520 --> 00:24:15,200
this one

690
00:24:11,919 --> 00:24:18,400
and we want now like we try to

691
00:24:15,200 --> 00:24:19,039
uh track the request total with just

692
00:24:18,400 --> 00:24:21,440
adding

693
00:24:19,039 --> 00:24:23,440
paths or we want to track our metrics

694
00:24:21,440 --> 00:24:26,400
per pad

695
00:24:23,440 --> 00:24:27,279
so it looks good now we have some pads

696
00:24:26,400 --> 00:24:30,799
and we can get

697
00:24:27,279 --> 00:24:31,760
our numbers however if we look closely

698
00:24:30,799 --> 00:24:34,799
we also see

699
00:24:31,760 --> 00:24:36,320
a lot of random stuff as well because

700
00:24:34,799 --> 00:24:39,039
like internet is not

701
00:24:36,320 --> 00:24:40,720
really a safe place if you just put

702
00:24:39,039 --> 00:24:44,559
something in your labels

703
00:24:40,720 --> 00:24:46,559
without any uh like preventing

704
00:24:44,559 --> 00:24:49,918
preventive measures

705
00:24:46,559 --> 00:24:52,320
you can end up with like a really

706
00:24:49,919 --> 00:24:53,679
bad situation if you want to track your

707
00:24:52,320 --> 00:24:55,678
discrete events

708
00:24:53,679 --> 00:24:58,720
please try to use a logging system

709
00:24:55,679 --> 00:25:02,000
instead of a metric system

710
00:24:58,720 --> 00:25:04,320
all right another uh like another

711
00:25:02,000 --> 00:25:06,159
expect aspect of cardinality is about

712
00:25:04,320 --> 00:25:08,399
histograms we already

713
00:25:06,159 --> 00:25:09,919
learned a lot uh about histograms from

714
00:25:08,400 --> 00:25:12,799
bjorn's talk

715
00:25:09,919 --> 00:25:13,200
uh but like what is actually the problem

716
00:25:12,799 --> 00:25:16,480
uh

717
00:25:13,200 --> 00:25:19,200
by default by default uh

718
00:25:16,480 --> 00:25:20,240
histograms uh underneath they use a

719
00:25:19,200 --> 00:25:23,440
couple of

720
00:25:20,240 --> 00:25:27,200
counters for a counter for each bucket

721
00:25:23,440 --> 00:25:29,520
and then some sum and count as well so

722
00:25:27,200 --> 00:25:30,799
if you use just uh default values for

723
00:25:29,520 --> 00:25:33,279
your buckets uh

724
00:25:30,799 --> 00:25:34,240
from client go library you will end up

725
00:25:33,279 --> 00:25:38,080
you will start with

726
00:25:34,240 --> 00:25:41,200
12 counters so if you just

727
00:25:38,080 --> 00:25:42,799
put some labels in it things could get

728
00:25:41,200 --> 00:25:45,919
out of control pretty quickly

729
00:25:42,799 --> 00:25:46,400
so again let's see an example now we

730
00:25:45,919 --> 00:25:48,799
will

731
00:25:46,400 --> 00:25:52,159
for this uh example we will use http

732
00:25:48,799 --> 00:25:55,440
request duration seconds metric

733
00:25:52,159 --> 00:25:56,480
and it's like we run our application we

734
00:25:55,440 --> 00:26:00,320
collected couple of

735
00:25:56,480 --> 00:26:02,799
uh observations it looks good but

736
00:26:00,320 --> 00:26:04,639
we have a problem actually here because

737
00:26:02,799 --> 00:26:07,918
these are cumulative metrics and

738
00:26:04,640 --> 00:26:08,480
like actually our latency is a bit

739
00:26:07,919 --> 00:26:11,200
higher

740
00:26:08,480 --> 00:26:12,240
but we have a like lesser bucket

741
00:26:11,200 --> 00:26:14,799
boundaries so

742
00:26:12,240 --> 00:26:15,279
these these are not not granular enough

743
00:26:14,799 --> 00:26:18,240
so

744
00:26:15,279 --> 00:26:18,640
we may not take actions on them so for

745
00:26:18,240 --> 00:26:21,200
that

746
00:26:18,640 --> 00:26:23,679
let's try to add more buckets into the

747
00:26:21,200 --> 00:26:26,240
equation

748
00:26:23,679 --> 00:26:29,200
now we have a more granular picture now

749
00:26:26,240 --> 00:26:32,400
we can actually use them

750
00:26:29,200 --> 00:26:35,279
it's fine right what could go wrong

751
00:26:32,400 --> 00:26:36,159
but probably at a certain point you will

752
00:26:35,279 --> 00:26:37,600
get alert

753
00:26:36,159 --> 00:26:39,760
and it will tell you that your

754
00:26:37,600 --> 00:26:41,199
prometheus has some increased memory

755
00:26:39,760 --> 00:26:43,440
consumption

756
00:26:41,200 --> 00:26:44,240
and when you check your metrics you will

757
00:26:43,440 --> 00:26:46,720
see this

758
00:26:44,240 --> 00:26:48,799
because now whatever label you got

759
00:26:46,720 --> 00:26:50,840
whatever label you put in there it's

760
00:26:48,799 --> 00:26:53,120
just multiplied by 12.

761
00:26:50,840 --> 00:26:54,559
so especially when you are using

762
00:26:53,120 --> 00:26:57,840
histograms please

763
00:26:54,559 --> 00:27:01,039
be careful be so considerate and just

764
00:26:57,840 --> 00:27:04,480
don't put random values in there so

765
00:27:01,039 --> 00:27:07,440
which actually gets me to my next point

766
00:27:04,480 --> 00:27:08,320
our last pitfall poorly chosen histogram

767
00:27:07,440 --> 00:27:11,360
buckets

768
00:27:08,320 --> 00:27:14,559
so underneath uh as beyond told us uh

769
00:27:11,360 --> 00:27:16,719
we have uh arbitrary we have

770
00:27:14,559 --> 00:27:17,918
buckets we why do we have buckets

771
00:27:16,720 --> 00:27:21,679
because we want to use

772
00:27:17,919 --> 00:27:23,919
less memory so by just aggregating all

773
00:27:21,679 --> 00:27:26,960
those observations in the client side

774
00:27:23,919 --> 00:27:28,000
uh we we actually gain a lot from the

775
00:27:26,960 --> 00:27:30,000
memory so this is

776
00:27:28,000 --> 00:27:31,200
this what makes promising histograms

777
00:27:30,000 --> 00:27:33,679
that is powerful

778
00:27:31,200 --> 00:27:34,720
so as a result you need to be very

779
00:27:33,679 --> 00:27:38,640
careful about your

780
00:27:34,720 --> 00:27:41,360
accuracy versus your performance

781
00:27:38,640 --> 00:27:43,279
so again let's see an example we will

782
00:27:41,360 --> 00:27:44,879
use the same metric

783
00:27:43,279 --> 00:27:46,880
but we will come up with an arbitrary

784
00:27:44,880 --> 00:27:49,840
number of buckets

785
00:27:46,880 --> 00:27:50,799
and when we observe again these are not

786
00:27:49,840 --> 00:27:54,480
balanced

787
00:27:50,799 --> 00:27:57,679
and this won't give us a lot of uh

788
00:27:54,480 --> 00:28:00,799
this won't give us any value so

789
00:27:57,679 --> 00:28:03,200
let's fix this uh by using some

790
00:28:00,799 --> 00:28:06,559
convenience method from prometheus

791
00:28:03,200 --> 00:28:10,240
and now we have

792
00:28:06,559 --> 00:28:10,240
better distribution so

793
00:28:11,039 --> 00:28:14,559
just coming up with the correct bucket

794
00:28:13,039 --> 00:28:17,120
layout is a

795
00:28:14,559 --> 00:28:18,399
art form so for that you need to know

796
00:28:17,120 --> 00:28:20,399
your insta

797
00:28:18,399 --> 00:28:21,760
you need to know your uh distribution

798
00:28:20,399 --> 00:28:23,600
very well and

799
00:28:21,760 --> 00:28:25,520
you always need to keep in mind that

800
00:28:23,600 --> 00:28:28,639
like there is a trade-off between

801
00:28:25,520 --> 00:28:30,480
accuracy and cardinality uh when you are

802
00:28:28,640 --> 00:28:35,200
choosing your

803
00:28:30,480 --> 00:28:39,279
label layout bucket layouts basically

804
00:28:35,200 --> 00:28:42,480
so in summary uh whatever you do

805
00:28:39,279 --> 00:28:42,720
observe your uh applications observation

806
00:28:42,480 --> 00:28:46,080
is

807
00:28:42,720 --> 00:28:49,200
essential it's not optional

808
00:28:46,080 --> 00:28:50,639
so determine your service level

809
00:28:49,200 --> 00:28:53,679
objectives

810
00:28:50,640 --> 00:28:57,679
write your alerts build your graphs and

811
00:28:53,679 --> 00:29:00,720
use them and now since you actually

812
00:28:57,679 --> 00:29:03,279
depend on your metrics you rely on them

813
00:29:00,720 --> 00:29:04,720
and they are now your real liability so

814
00:29:03,279 --> 00:29:08,240
test them

815
00:29:04,720 --> 00:29:09,760
as you test your business logic and last

816
00:29:08,240 --> 00:29:12,880
but not least

817
00:29:09,760 --> 00:29:15,120
ever global state make your life easier

818
00:29:12,880 --> 00:29:17,840
just for yourself

819
00:29:15,120 --> 00:29:19,439
all the codes that you see observe this

820
00:29:17,840 --> 00:29:21,760
load balancer it's actually

821
00:29:19,440 --> 00:29:22,640
we have a working example and we have

822
00:29:21,760 --> 00:29:24,158
more in there

823
00:29:22,640 --> 00:29:28,320
if you want to dig in if you want to

824
00:29:24,159 --> 00:29:28,320
check more just go in there

825
00:29:29,039 --> 00:29:32,399
and i think that's it from us thank you

826
00:29:31,120 --> 00:29:41,840
for listening

827
00:29:32,399 --> 00:29:50,080
also we are hiring so thank you

828
00:29:41,840 --> 00:29:50,080
so thank you

