1
00:00:05,040 --> 00:00:09,440
so uh our next speaker is luke him off

2
00:00:07,520 --> 00:00:11,519
luke is uh one of the creators of the

3
00:00:09,440 --> 00:00:12,320
lumen project which he will tell you all

4
00:00:11,519 --> 00:00:14,639
about

5
00:00:12,320 --> 00:00:15,679
is also the creator of the intellij

6
00:00:14,639 --> 00:00:17,919
elixir plugin

7
00:00:15,679 --> 00:00:19,279
which we he will talk about tomorrow in

8
00:00:17,920 --> 00:00:21,439
the free editors room

9
00:00:19,279 --> 00:00:22,720
if you want to to catch that that's also

10
00:00:21,439 --> 00:00:24,960
going to be super cool

11
00:00:22,720 --> 00:00:31,278
for sure and yes so let's give it up for

12
00:00:24,960 --> 00:00:33,680
luke with lumen

13
00:00:31,279 --> 00:00:34,399
as you said i'm luke kimoff i'm known

14
00:00:33,680 --> 00:00:36,239
pretty much

15
00:00:34,399 --> 00:00:37,600
everywhere online as chronic death

16
00:00:36,239 --> 00:00:40,078
because i'm filled with autoimmune

17
00:00:37,600 --> 00:00:40,079
diseases

18
00:00:40,399 --> 00:00:45,360
uh so let's start with an overview

19
00:00:42,559 --> 00:00:48,078
before diving into the details

20
00:00:45,360 --> 00:00:49,600
lumen is the new compiler in runtime for

21
00:00:48,079 --> 00:00:52,800
erlang elixir and

22
00:00:49,600 --> 00:00:55,840
anything else we can convert from erlang

23
00:00:52,800 --> 00:00:57,280
abstract form it targets things that are

24
00:00:55,840 --> 00:00:59,440
difficult or impossible to target with

25
00:00:57,280 --> 00:01:01,680
beams such as webassembly x86 single

26
00:00:59,440 --> 00:01:03,199
executable binaries so not e-scripts but

27
00:01:01,680 --> 00:01:05,199
just single executable like competing

28
00:01:03,199 --> 00:01:06,798
with rust or go that sort of thing

29
00:01:05,199 --> 00:01:09,920
or true embedded systems without an os

30
00:01:06,799 --> 00:01:09,920
such as microcontrollers

31
00:01:11,119 --> 00:01:14,320
which web apps represent a significant

32
00:01:13,200 --> 00:01:16,400
portion of the work we do

33
00:01:14,320 --> 00:01:17,839
and with client-side with the client's

34
00:01:16,400 --> 00:01:20,080
ecosystem and constant flux

35
00:01:17,840 --> 00:01:21,840
and long-term maintenance an extension

36
00:01:20,080 --> 00:01:23,280
is quite painful because you go away

37
00:01:21,840 --> 00:01:25,360
from a project for a while

38
00:01:23,280 --> 00:01:26,880
that's written with a js framework and

39
00:01:25,360 --> 00:01:29,360
it just will not build

40
00:01:26,880 --> 00:01:31,360
too many things have moved on meanwhile

41
00:01:29,360 --> 00:01:33,759
the server-side ecosystem is more stable

42
00:01:31,360 --> 00:01:35,280
like people have not really had upgrade

43
00:01:33,759 --> 00:01:38,720
problems with phoenix even though

44
00:01:35,280 --> 00:01:40,400
we've added new features

45
00:01:38,720 --> 00:01:41,759
so the one thing that's really missing

46
00:01:40,400 --> 00:01:43,840
is we can't take those server-side

47
00:01:41,759 --> 00:01:46,560
languages and put them on the web

48
00:01:43,840 --> 00:01:48,479
but webassembly changes that we can use

49
00:01:46,560 --> 00:01:51,360
previous back-end only languages

50
00:01:48,479 --> 00:01:52,880
for client-side apps and the reason why

51
00:01:51,360 --> 00:01:54,720
we're doing it now even though

52
00:01:52,880 --> 00:01:55,920
webassembly hasn't really been reached

53
00:01:54,720 --> 00:01:57,360
1-0 yet

54
00:01:55,920 --> 00:01:58,880
is because we don't want erlang and

55
00:01:57,360 --> 00:02:00,479
elixir to be passed over because they

56
00:01:58,880 --> 00:02:02,560
don't have a webassembly target

57
00:02:00,479 --> 00:02:04,560
there's already targets for c c plus and

58
00:02:02,560 --> 00:02:06,799
rust and people have done toy

59
00:02:04,560 --> 00:02:08,640
versions of python ruby and php but we

60
00:02:06,799 --> 00:02:09,840
want to make sure that elixir and erlang

61
00:02:08,639 --> 00:02:12,480
have a true client

62
00:02:09,840 --> 00:02:14,080
it's not just a huge you know 100

63
00:02:12,480 --> 00:02:17,359
megabyte download to get

64
00:02:14,080 --> 00:02:20,400
a python

65
00:02:17,360 --> 00:02:21,440
cli inter repl in the browser we want

66
00:02:20,400 --> 00:02:22,720
this to be something you can use in

67
00:02:21,440 --> 00:02:24,959
production so that

68
00:02:22,720 --> 00:02:26,640
once again people don't push aside

69
00:02:24,959 --> 00:02:28,000
functional languages so the webassembly

70
00:02:26,640 --> 00:02:29,279
spec even says

71
00:02:28,000 --> 00:02:31,040
we want to make sure that this doesn't

72
00:02:29,280 --> 00:02:33,920
just work comparative languages like

73
00:02:31,040 --> 00:02:35,359
but all the implementations are just c c

74
00:02:33,920 --> 00:02:37,040
plus plus and rust so if we get in there

75
00:02:35,360 --> 00:02:40,480
now we make sure that they stay

76
00:02:37,040 --> 00:02:40,480
compatible with functional languages

77
00:02:40,720 --> 00:02:44,400
not everyone in the audience may have

78
00:02:42,640 --> 00:02:46,319
seen lynn clark's excellent articles on

79
00:02:44,400 --> 00:02:47,599
webassembly on the mozilla web developer

80
00:02:46,319 --> 00:02:49,280
vlog so let me give you a quick

81
00:02:47,599 --> 00:02:51,920
introduction

82
00:02:49,280 --> 00:02:53,280
webassembly has a format specification a

83
00:02:51,920 --> 00:02:56,559
test suite and development

84
00:02:53,280 --> 00:02:58,480
happens as part of the w3c community

85
00:02:56,560 --> 00:02:59,760
group while formal centralization occurs

86
00:02:58,480 --> 00:03:00,480
under the purview of the webassembly

87
00:02:59,760 --> 00:03:03,359
working group

88
00:03:00,480 --> 00:03:04,079
so these are these working groups are

89
00:03:03,360 --> 00:03:06,959
the reasons why

90
00:03:04,080 --> 00:03:07,280
browsers remain compatible it is you

91
00:03:06,959 --> 00:03:10,319
know

92
00:03:07,280 --> 00:03:13,280
google and apple and

93
00:03:10,319 --> 00:03:14,879
mozilla fighting to get a standard that

94
00:03:13,280 --> 00:03:16,840
everyone can agree to so we don't go

95
00:03:14,879 --> 00:03:18,239
back to like it works on everything but

96
00:03:16,840 --> 00:03:21,599
ie or

97
00:03:18,239 --> 00:03:23,920
it works only in ie the lumen core team

98
00:03:21,599 --> 00:03:24,798
is part of that working group so that we

99
00:03:23,920 --> 00:03:27,760
can

100
00:03:24,799 --> 00:03:30,239
advocate for functional features being

101
00:03:27,760 --> 00:03:32,319
there now and not being an afterthought

102
00:03:30,239 --> 00:03:34,879
or it works but you have to ship way

103
00:03:32,319 --> 00:03:36,399
more code to make it work

104
00:03:34,879 --> 00:03:38,798
the overall goal of the designs are to

105
00:03:36,400 --> 00:03:40,000
make a safe fast send boxable language

106
00:03:38,799 --> 00:03:42,799
for the web

107
00:03:40,000 --> 00:03:44,000
separate code and data means you can't

108
00:03:42,799 --> 00:03:46,159
address code

109
00:03:44,000 --> 00:03:47,920
so you can't store code you can't do go

110
00:03:46,159 --> 00:03:51,120
to for exception handling but

111
00:03:47,920 --> 00:03:53,040
it also means um we can't get

112
00:03:51,120 --> 00:03:54,720
exploits that require rop gadgets where

113
00:03:53,040 --> 00:03:56,000
you jump to the very end of a function

114
00:03:54,720 --> 00:03:57,359
to set up registers

115
00:03:56,000 --> 00:03:59,439
to be in a certain state which is a big

116
00:03:57,360 --> 00:04:03,360
problem with x86

117
00:03:59,439 --> 00:04:05,280
um the caveat with jsffi right now

118
00:04:03,360 --> 00:04:06,560
is that we can only pass integers over

119
00:04:05,280 --> 00:04:08,640
the bridge but

120
00:04:06,560 --> 00:04:10,400
javascript can see the entire memory of

121
00:04:08,640 --> 00:04:12,640
a webassembly module if it's shared

122
00:04:10,400 --> 00:04:14,480
and so you can say i'm here and on this

123
00:04:12,640 --> 00:04:16,320
length and read the bytes out

124
00:04:14,480 --> 00:04:18,478
there is a proposal called interface

125
00:04:16,320 --> 00:04:20,719
types where this translation will happen

126
00:04:18,478 --> 00:04:22,639
automatically but for now we depend on

127
00:04:20,720 --> 00:04:25,840
the rust web assembly support to do this

128
00:04:22,639 --> 00:04:25,840
translation for us automatically

129
00:04:26,400 --> 00:04:30,000
in browsers webassembly is faster than

130
00:04:28,160 --> 00:04:30,880
js because as a binary format it can

131
00:04:30,000 --> 00:04:32,720
parse faster

132
00:04:30,880 --> 00:04:34,320
it's also set up to allow streaming uh

133
00:04:32,720 --> 00:04:34,880
compilation because there's a section

134
00:04:34,320 --> 00:04:36,240
that

135
00:04:34,880 --> 00:04:38,080
kind of implements like the equivalent

136
00:04:36,240 --> 00:04:39,199
of a header and c so we know all the

137
00:04:38,080 --> 00:04:40,560
types of functions and then each

138
00:04:39,199 --> 00:04:41,759
individual function can be stream

139
00:04:40,560 --> 00:04:42,479
compiled and you don't have to have the

140
00:04:41,759 --> 00:04:43,600
entire

141
00:04:42,479 --> 00:04:45,680
thing download before you start

142
00:04:43,600 --> 00:04:48,479
compiling which happens with even the

143
00:04:45,680 --> 00:04:50,240
most minified version of javascript

144
00:04:48,479 --> 00:04:51,599
but that being said a lot of people

145
00:04:50,240 --> 00:04:53,759
think this means that it's a completely

146
00:04:51,600 --> 00:04:55,680
different stack in the browsers it's not

147
00:04:53,759 --> 00:04:57,199
once you get down to the level of its

148
00:04:55,680 --> 00:04:58,160
parsed and it's in some sort of

149
00:04:57,199 --> 00:04:59,840
structure in memory

150
00:04:58,160 --> 00:05:01,680
both of those things can go through the

151
00:04:59,840 --> 00:05:03,119
jit so we still benefit from jet even

152
00:05:01,680 --> 00:05:04,960
though we get a binary format that's

153
00:05:03,120 --> 00:05:08,160
faster to parse and compile when it's

154
00:05:04,960 --> 00:05:08,159
for that first load effect

155
00:05:08,960 --> 00:05:12,638
now that you know what webassembly is

156
00:05:11,360 --> 00:05:15,440
and its benefits let's see how

157
00:05:12,639 --> 00:05:16,160
lumen targets it code size is critical

158
00:05:15,440 --> 00:05:18,320
it directly

159
00:05:16,160 --> 00:05:19,840
uh impacts time to load the page as well

160
00:05:18,320 --> 00:05:22,400
as compilation time on the client

161
00:05:19,840 --> 00:05:23,679
load time is a major portion of the time

162
00:05:22,400 --> 00:05:24,479
to the first paint and any delay there

163
00:05:23,680 --> 00:05:26,720
is noticeable

164
00:05:24,479 --> 00:05:28,240
to the users threading the web assembly

165
00:05:26,720 --> 00:05:29,520
is very different animal than pilots or

166
00:05:28,240 --> 00:05:31,039
windows threads

167
00:05:29,520 --> 00:05:32,960
right now the browsers take the

168
00:05:31,039 --> 00:05:34,240
requirement to have threading support in

169
00:05:32,960 --> 00:05:36,960
webassembly to mean

170
00:05:34,240 --> 00:05:37,680
we can use web workers and web workers

171
00:05:36,960 --> 00:05:39,280
and browsers

172
00:05:37,680 --> 00:05:41,360
for sandboxing reasons are known as

173
00:05:39,280 --> 00:05:44,000
processes not actual threads

174
00:05:41,360 --> 00:05:45,440
uh we and other people are pushing for

175
00:05:44,000 --> 00:05:47,520
them to get real threads

176
00:05:45,440 --> 00:05:49,360
but for now they are web workers and so

177
00:05:47,520 --> 00:05:52,000
it's not as nice

178
00:05:49,360 --> 00:05:53,600
going the other way browsers the main

179
00:05:52,000 --> 00:05:55,520
thread is very different

180
00:05:53,600 --> 00:05:57,199
than the main thread in normal os's

181
00:05:55,520 --> 00:05:58,560
because that is the one interacts with

182
00:05:57,199 --> 00:06:00,240
the dom and if you're

183
00:05:58,560 --> 00:06:02,639
doing work in the main thread you freeze

184
00:06:00,240 --> 00:06:04,400
the ui to the point that like you know

185
00:06:02,639 --> 00:06:06,160
uh firefox or chrome will pop up like do

186
00:06:04,400 --> 00:06:08,880
you want to kill the scripts in this

187
00:06:06,160 --> 00:06:10,000
page if you freeze it for too long so

188
00:06:08,880 --> 00:06:12,560
there's a lot of

189
00:06:10,000 --> 00:06:12,560
gotchas

190
00:06:13,520 --> 00:06:17,198
async apis require a callback which

191
00:06:15,360 --> 00:06:19,120
interact differently with dc than normal

192
00:06:17,199 --> 00:06:20,720
closures we are able to

193
00:06:19,120 --> 00:06:22,400
have async callbacks for the things that

194
00:06:20,720 --> 00:06:24,880
browsers support

195
00:06:22,400 --> 00:06:26,318
because the the rust uh wasm support

196
00:06:24,880 --> 00:06:28,319
allows us to do that thing

197
00:06:26,319 --> 00:06:29,759
sort of thing um so we can use futures

198
00:06:28,319 --> 00:06:31,520
there but not everything supports that

199
00:06:29,759 --> 00:06:33,919
so for actual events that have been

200
00:06:31,520 --> 00:06:36,080
concurrent we need special support in

201
00:06:33,919 --> 00:06:39,599
the runtime we ship to the browsers

202
00:06:36,080 --> 00:06:41,280
to allow the erlang code to be woken up

203
00:06:39,600 --> 00:06:42,479
from the scheduler and run immediately

204
00:06:41,280 --> 00:06:44,960
in a blocking manner which wouldn't be

205
00:06:42,479 --> 00:06:46,560
the normal way to run a process

206
00:06:44,960 --> 00:06:48,400
and once again for ffi we need to

207
00:06:46,560 --> 00:06:50,080
translate between the javascript values

208
00:06:48,400 --> 00:06:52,719
and the elixir values

209
00:06:50,080 --> 00:06:53,280
or the erlang terms um if you're

210
00:06:52,720 --> 00:06:54,720
wondering

211
00:06:53,280 --> 00:06:56,318
why we chose to build a new compiler one

212
00:06:54,720 --> 00:06:57,759
time rather than try to port the beam to

213
00:06:56,319 --> 00:06:59,440
webassembly so like

214
00:06:57,759 --> 00:07:02,720
the if you have something so like the

215
00:06:59,440 --> 00:07:04,719
toy examples for php uh

216
00:07:02,720 --> 00:07:06,160
python and ruby is they take a tool

217
00:07:04,720 --> 00:07:07,840
called scriptin which existed before

218
00:07:06,160 --> 00:07:09,440
javascript when they're just amgs

219
00:07:07,840 --> 00:07:12,239
it'll take any c code and just it's

220
00:07:09,440 --> 00:07:15,039
right up in the browser but it's huge

221
00:07:12,240 --> 00:07:16,479
and usually pretty slow there are some

222
00:07:15,039 --> 00:07:18,159
bits of caveats where people have like

223
00:07:16,479 --> 00:07:19,840
gotten unreal engine games to run under

224
00:07:18,160 --> 00:07:21,360
unscripted but it took a lot of work it

225
00:07:19,840 --> 00:07:22,880
doesn't just happen that

226
00:07:21,360 --> 00:07:25,120
it's in the browser and as fast as

227
00:07:22,880 --> 00:07:25,120
native

228
00:07:25,199 --> 00:07:28,880
uh much of the beam uh runtime support

229
00:07:27,360 --> 00:07:30,080
depends on apis are not available or

230
00:07:28,880 --> 00:07:31,120
entirely unsupported

231
00:07:30,080 --> 00:07:33,199
in webassembly because they would

232
00:07:31,120 --> 00:07:35,919
violate the security of the web so like

233
00:07:33,199 --> 00:07:36,800
init assumes your file system to read or

234
00:07:35,919 --> 00:07:39,120
the way the

235
00:07:36,800 --> 00:07:40,720
uh memory allocator works is it does the

236
00:07:39,120 --> 00:07:43,199
thing that makes total sense

237
00:07:40,720 --> 00:07:44,080
with virtual memory on an os where you

238
00:07:43,199 --> 00:07:45,840
ask for like

239
00:07:44,080 --> 00:07:47,039
two gigs of memory and you only write to

240
00:07:45,840 --> 00:07:48,159
the parts you need and the browser only

241
00:07:47,039 --> 00:07:50,560
gives you the parts you need and it's

242
00:07:48,160 --> 00:07:52,639
perfectly okay that you ask for two gigs

243
00:07:50,560 --> 00:07:54,639
but for safety on the web when you ask

244
00:07:52,639 --> 00:07:55,360
for memory in webassembly you get that

245
00:07:54,639 --> 00:07:57,759
back

246
00:07:55,360 --> 00:07:59,440
immediately and it is zeroed out um so

247
00:07:57,759 --> 00:08:01,520
you can't do that sort of you shouldn't

248
00:07:59,440 --> 00:08:05,680
even fake those sort of calls on the web

249
00:08:01,520 --> 00:08:08,000
uh in webassembly like i said the way

250
00:08:05,680 --> 00:08:09,199
uh the main thread works is it's

251
00:08:08,000 --> 00:08:11,120
blocking

252
00:08:09,199 --> 00:08:12,639
uh but also if we did ever have a

253
00:08:11,120 --> 00:08:14,400
scheduler on the

254
00:08:12,639 --> 00:08:16,319
web workers they couldn't do dom access

255
00:08:14,400 --> 00:08:18,239
so any we have to know which thread

256
00:08:16,319 --> 00:08:19,759
you're on to know if the api call is

257
00:08:18,240 --> 00:08:22,400
valid or like

258
00:08:19,759 --> 00:08:23,039
automatically go over to the other

259
00:08:22,400 --> 00:08:24,638
thread

260
00:08:23,039 --> 00:08:26,878
when we need transfer control for a dom

261
00:08:24,639 --> 00:08:29,759
call from web worker

262
00:08:26,879 --> 00:08:31,520
additionally js values are being need to

263
00:08:29,759 --> 00:08:32,000
be tracked by the runtime so we have to

264
00:08:31,520 --> 00:08:34,718
have

265
00:08:32,000 --> 00:08:36,159
sort of like almost a nif term type um

266
00:08:34,719 --> 00:08:37,599
to keep track of those js values so that

267
00:08:36,159 --> 00:08:37,919
the garbage collect correctly when

268
00:08:37,599 --> 00:08:40,479
they're

269
00:08:37,919 --> 00:08:43,439
on the other side of the js gem that

270
00:08:40,479 --> 00:08:43,440
russ generates for us

271
00:08:44,560 --> 00:08:48,319
using the beam in the browser means that

272
00:08:46,080 --> 00:08:51,279
we would need to ship all the

273
00:08:48,320 --> 00:08:52,000
beam by code files to the browser but as

274
00:08:51,279 --> 00:08:54,320
an example

275
00:08:52,000 --> 00:08:55,040
individual libraries like the the timex

276
00:08:54,320 --> 00:08:56,800
library that's

277
00:08:55,040 --> 00:08:58,959
that allows you to do human readable

278
00:08:56,800 --> 00:09:02,079
times and time zones

279
00:08:58,959 --> 00:09:05,199
takes a 1.1 megabytes and like

280
00:09:02,080 --> 00:09:05,760
1.1 megabytes is you should feel ashamed

281
00:09:05,200 --> 00:09:07,279
that your

282
00:09:05,760 --> 00:09:09,040
client-side web app is that big so if

283
00:09:07,279 --> 00:09:10,160
that's one library that's not shipping

284
00:09:09,040 --> 00:09:12,160
the center library that's

285
00:09:10,160 --> 00:09:14,319
one like extra support library on top

286
00:09:12,160 --> 00:09:15,439
that's not viable to be competitive

287
00:09:14,320 --> 00:09:17,440
because remember i said we want this to

288
00:09:15,440 --> 00:09:21,519
be a competitive thing not a toy

289
00:09:17,440 --> 00:09:23,440
set of tools so one way we could do this

290
00:09:21,519 --> 00:09:24,720
and what even js can do now is dead code

291
00:09:23,440 --> 00:09:28,880
elimination through what

292
00:09:24,720 --> 00:09:28,880
js people call tree shaking but

293
00:09:29,120 --> 00:09:32,240
beam files aren't really set up for tree

294
00:09:30,800 --> 00:09:34,160
shaking because we

295
00:09:32,240 --> 00:09:35,920
want to be able to do hot code reloading

296
00:09:34,160 --> 00:09:36,800
and so there's no real real way to set

297
00:09:35,920 --> 00:09:40,240
up to tree shake

298
00:09:36,800 --> 00:09:40,240
or to do dead coat elimination

299
00:09:40,720 --> 00:09:44,080
the other problem is we'd be running the

300
00:09:42,720 --> 00:09:47,200
beam vm

301
00:09:44,080 --> 00:09:50,640
interpreting we would be running

302
00:09:47,200 --> 00:09:52,640
by code in a vm and that vm itself

303
00:09:50,640 --> 00:09:54,399
acts as by code and web assembly to the

304
00:09:52,640 --> 00:09:56,160
webassembly vm in the browser

305
00:09:54,399 --> 00:09:57,360
so it's vm on vm and vm there's a lot of

306
00:09:56,160 --> 00:09:59,680
indirection that will just slow

307
00:09:57,360 --> 00:10:01,200
everything down

308
00:09:59,680 --> 00:10:03,760
and additionally because that beam by

309
00:10:01,200 --> 00:10:04,399
code is opaque it's not going to

310
00:10:03,760 --> 00:10:07,120
magically

311
00:10:04,399 --> 00:10:08,240
jet your code even if it's in hot loop

312
00:10:07,120 --> 00:10:10,079
and erlang

313
00:10:08,240 --> 00:10:11,519
into native code there's just too many

314
00:10:10,079 --> 00:10:12,959
levels of indirection

315
00:10:11,519 --> 00:10:14,880
so we won't get the benefit of the jet

316
00:10:12,959 --> 00:10:16,719
then

317
00:10:14,880 --> 00:10:18,480
so i've explained uh issues with the

318
00:10:16,720 --> 00:10:20,160
beam itself but i haven't

319
00:10:18,480 --> 00:10:23,120
really explained how the design of lumen

320
00:10:20,160 --> 00:10:23,120
would solve those issues

321
00:10:24,560 --> 00:10:28,000
first lumen drop support for hot code

322
00:10:26,320 --> 00:10:30,079
loading which gives us a benefit the

323
00:10:28,000 --> 00:10:32,240
reason why this is okay on the web is

324
00:10:30,079 --> 00:10:33,920
we can't really hot we can't really

325
00:10:32,240 --> 00:10:35,600
replace a webassembly module

326
00:10:33,920 --> 00:10:37,439
we can have a webassembly module of code

327
00:10:35,600 --> 00:10:38,560
to like download a new webassembly

328
00:10:37,440 --> 00:10:40,160
module and then

329
00:10:38,560 --> 00:10:41,518
do it again but it's not really the same

330
00:10:40,160 --> 00:10:43,120
as on the beam where all your code would

331
00:10:41,519 --> 00:10:45,200
just know to call this one

332
00:10:43,120 --> 00:10:46,560
it would have a different id there would

333
00:10:45,200 --> 00:10:47,839
be no replacement

334
00:10:46,560 --> 00:10:49,119
it's much more cooperative than it would

335
00:10:47,839 --> 00:10:51,200
be where it just works on the beam

336
00:10:49,120 --> 00:10:54,160
anyway

337
00:10:51,200 --> 00:10:55,920
um but because of this we can do full

338
00:10:54,160 --> 00:10:58,240
ahead of time compilation

339
00:10:55,920 --> 00:11:00,000
so we only pay for what you're actually

340
00:10:58,240 --> 00:11:01,440
using

341
00:11:00,000 --> 00:11:02,640
if you have an otp application but

342
00:11:01,440 --> 00:11:04,079
you're only using one function we only

343
00:11:02,640 --> 00:11:06,319
have to ship that function

344
00:11:04,079 --> 00:11:07,920
um this also matters a lot because we

345
00:11:06,320 --> 00:11:08,640
don't ship the entire sound library we

346
00:11:07,920 --> 00:11:11,040
only ship

347
00:11:08,640 --> 00:11:12,480
the ifs you're actually calling and like

348
00:11:11,040 --> 00:11:14,399
erlang is huge

349
00:11:12,480 --> 00:11:17,200
like the earlier module itself is huge

350
00:11:14,399 --> 00:11:18,959
and a mess and like a lot of

351
00:11:17,200 --> 00:11:20,560
unrelated functions to each other and

352
00:11:18,959 --> 00:11:21,839
additionally it ships a bunch of checks

353
00:11:20,560 --> 00:11:23,199
some functions that no one

354
00:11:21,839 --> 00:11:25,920
should use in a modern context because

355
00:11:23,200 --> 00:11:27,120
it's like md5 and adler 32 which are

356
00:11:25,920 --> 00:11:28,399
completely unsecure

357
00:11:27,120 --> 00:11:30,320
and so there's stuff we just don't want

358
00:11:28,399 --> 00:11:32,560
to ship

359
00:11:30,320 --> 00:11:34,240
but initially we get because we're ahead

360
00:11:32,560 --> 00:11:35,760
of time we get everything that russ and

361
00:11:34,240 --> 00:11:37,839
llvm can do

362
00:11:35,760 --> 00:11:39,279
so we get you know dead code elimination

363
00:11:37,839 --> 00:11:40,320
not just of any of our functions but

364
00:11:39,279 --> 00:11:42,959
individual instructions

365
00:11:40,320 --> 00:11:44,399
arguments stores and loads it can do

366
00:11:42,959 --> 00:11:46,640
instruction combining

367
00:11:44,399 --> 00:11:48,800
if a better fuse function exists and it

368
00:11:46,640 --> 00:11:50,639
can do loop proposition or vectorization

369
00:11:48,800 --> 00:11:53,519
sort of like how the pelham a team is

370
00:11:50,639 --> 00:11:53,519
doing in japan

371
00:11:54,800 --> 00:11:58,639
like i said we're built on top of lvm

372
00:11:56,720 --> 00:12:00,000
and rust and uh we use wes and bind gen

373
00:11:58,639 --> 00:12:01,200
which is the part that allows us to call

374
00:12:00,000 --> 00:12:04,639
dom apis

375
00:12:01,200 --> 00:12:06,480
in a more transparent manner uh

376
00:12:04,639 --> 00:12:08,639
being on top of llvm is kind of the

377
00:12:06,480 --> 00:12:10,639
default for new languages

378
00:12:08,639 --> 00:12:11,680
erlang just existed before it so it's

379
00:12:10,639 --> 00:12:14,160
not built on it

380
00:12:11,680 --> 00:12:15,599
but because of this things that like

381
00:12:14,160 --> 00:12:16,240
constant folding or dead code

382
00:12:15,600 --> 00:12:18,880
elimination

383
00:12:16,240 --> 00:12:20,160
just happen at the llvm level and we

384
00:12:18,880 --> 00:12:22,320
don't need to do that

385
00:12:20,160 --> 00:12:24,399
which means we're not in that case where

386
00:12:22,320 --> 00:12:25,040
like five years after the language is

387
00:12:24,399 --> 00:12:26,800
out

388
00:12:25,040 --> 00:12:28,079
then it becomes fast again because it

389
00:12:26,800 --> 00:12:28,560
finally gets all those optimizations

390
00:12:28,079 --> 00:12:30,239
that

391
00:12:28,560 --> 00:12:33,920
are in every language already so we're

392
00:12:30,240 --> 00:12:33,920
not falling behind that way

393
00:12:35,600 --> 00:12:38,720
on the looming core team i'm primarily

394
00:12:37,360 --> 00:12:40,880
responsible for the runtime and the

395
00:12:38,720 --> 00:12:42,399
biffs

396
00:12:40,880 --> 00:12:44,000
so the runtime is composed of five

397
00:12:42,399 --> 00:12:47,279
layers the memory management terms

398
00:12:44,000 --> 00:12:48,480
processes schedulers and bifs

399
00:12:47,279 --> 00:12:49,839
the first layer is memory management

400
00:12:48,480 --> 00:12:50,880
memory management is the layer the

401
00:12:49,839 --> 00:12:53,680
runtime

402
00:12:50,880 --> 00:12:55,519
was work between um paul schoenfelder

403
00:12:53,680 --> 00:12:55,920
and myself paul looked at how the code

404
00:12:55,519 --> 00:12:58,320
is

405
00:12:55,920 --> 00:13:00,319
written in beam and poured that so like

406
00:12:58,320 --> 00:13:00,880
chunk sizing super chunks super carriers

407
00:13:00,320 --> 00:13:03,519
all that stuff

408
00:13:00,880 --> 00:13:05,120
it's in us so you don't worry that will

409
00:13:03,519 --> 00:13:07,120
behave unexpectedly

410
00:13:05,120 --> 00:13:08,480
from how you're used to thinking about

411
00:13:07,120 --> 00:13:11,680
memory

412
00:13:08,480 --> 00:13:14,399
and gc in the beam

413
00:13:11,680 --> 00:13:16,638
and all that memory management and all

414
00:13:14,399 --> 00:13:20,079
like the biffs are property tested

415
00:13:16,639 --> 00:13:21,440
using rust prop tests so it's all we

416
00:13:20,079 --> 00:13:23,120
know it's sick fault safe because we

417
00:13:21,440 --> 00:13:23,920
have to use unsafe code to do memory

418
00:13:23,120 --> 00:13:26,560
management

419
00:13:23,920 --> 00:13:27,599
in russ it's not uh safe rust but i'm

420
00:13:26,560 --> 00:13:29,279
not just saying that like

421
00:13:27,600 --> 00:13:31,519
oh we proposed therefore it must be

422
00:13:29,279 --> 00:13:32,160
saved no no i'm saying it found some seg

423
00:13:31,519 --> 00:13:34,079
faults

424
00:13:32,160 --> 00:13:36,240
and so now that we run the prop test we

425
00:13:34,079 --> 00:13:38,560
can trust that we've eliminated the site

426
00:13:36,240 --> 00:13:38,560
faults

427
00:13:38,880 --> 00:13:43,360
um from perspective everyone here that's

428
00:13:41,839 --> 00:13:46,000
just writing erlang or elixir

429
00:13:43,360 --> 00:13:46,399
uh the memory for uh processes are the

430
00:13:46,000 --> 00:13:47,920
same

431
00:13:46,399 --> 00:13:49,680
processes have heaps they have our first

432
00:13:47,920 --> 00:13:50,800
count binaries when there are 64 bytes

433
00:13:49,680 --> 00:13:54,399
and each

434
00:13:50,800 --> 00:13:54,399
uh garbage question is per process

435
00:13:54,639 --> 00:13:57,839
uh the processes have similar features

436
00:13:56,000 --> 00:13:59,440
to those in the beam and from earlier

437
00:13:57,839 --> 00:14:00,560
elixir code

438
00:13:59,440 --> 00:14:03,760
it's going to behave identically so you

439
00:14:00,560 --> 00:14:05,359
don't really have to think about it

440
00:14:03,760 --> 00:14:06,880
uh lumen scheduler works similar to the

441
00:14:05,360 --> 00:14:07,440
beam scheduler in that there is one per

442
00:14:06,880 --> 00:14:09,360
thread

443
00:14:07,440 --> 00:14:10,480
each time the scheduler runs it checks

444
00:14:09,360 --> 00:14:12,160
if any uh

445
00:14:10,480 --> 00:14:13,199
timers to the timeout exactly one is

446
00:14:12,160 --> 00:14:14,959
processed right now we haven't

447
00:14:13,199 --> 00:14:16,319
implemented

448
00:14:14,959 --> 00:14:17,760
dirty schedulers because for the main

449
00:14:16,320 --> 00:14:18,880
web target there's not really a concept

450
00:14:17,760 --> 00:14:20,000
of what would that mean to have a dirty

451
00:14:18,880 --> 00:14:21,439
scheduler we don't

452
00:14:20,000 --> 00:14:23,360
really think that would be safe because

453
00:14:21,440 --> 00:14:26,639
you're going to try to freeze a thread

454
00:14:23,360 --> 00:14:28,079
so that'd be bad um

455
00:14:26,639 --> 00:14:30,240
how the sketchers work of course differs

456
00:14:28,079 --> 00:14:32,880
on webassembly versus native on

457
00:14:30,240 --> 00:14:33,440
um web we have to worry about the main

458
00:14:32,880 --> 00:14:35,360
thread

459
00:14:33,440 --> 00:14:36,959
is the one we get and everything else

460
00:14:35,360 --> 00:14:39,920
has to be a web worker

461
00:14:36,959 --> 00:14:41,040
and the russ uh uh wise ecosystem deals

462
00:14:39,920 --> 00:14:43,360
with that for us

463
00:14:41,040 --> 00:14:44,959
um on native there's no special threads

464
00:14:43,360 --> 00:14:46,880
and from the testing because we have

465
00:14:44,959 --> 00:14:50,638
thousands of tests

466
00:14:46,880 --> 00:14:52,000
we know that rust generates a new thread

467
00:14:50,639 --> 00:14:53,680
for every test to make it

468
00:14:52,000 --> 00:14:56,079
cleaner and let them run parallel so we

469
00:14:53,680 --> 00:14:59,680
know we can spin up

470
00:14:56,079 --> 00:15:02,239
like 10 000 schedulers

471
00:14:59,680 --> 00:15:03,680
in like 13 minutes and nothing bad

472
00:15:02,240 --> 00:15:06,320
happens so having lots of schedulers

473
00:15:03,680 --> 00:15:06,319
works just fine

474
00:15:06,399 --> 00:15:11,519
um so webassembly calls

475
00:15:09,920 --> 00:15:13,040
are blocking there's no built-in support

476
00:15:11,519 --> 00:15:14,079
for declaring a function as async the

477
00:15:13,040 --> 00:15:17,120
way there is

478
00:15:14,079 --> 00:15:18,319
in javascript um even if we could

479
00:15:17,120 --> 00:15:19,760
declare an async wrapper we want the

480
00:15:18,320 --> 00:15:21,360
timers to work without pulling and

481
00:15:19,760 --> 00:15:23,360
without hoping the event listener

482
00:15:21,360 --> 00:15:24,480
callbacks are called when enough

483
00:15:23,360 --> 00:15:26,639
schedules wake up so

484
00:15:24,480 --> 00:15:28,000
we want the scheduler to somehow to be

485
00:15:26,639 --> 00:15:30,079
be running in the background all the

486
00:15:28,000 --> 00:15:32,240
time

487
00:15:30,079 --> 00:15:33,920
uh for webassembly so that we don't like

488
00:15:32,240 --> 00:15:36,480
that you your third we use

489
00:15:33,920 --> 00:15:37,759
a request animation frame which is like

490
00:15:36,480 --> 00:15:38,880
people javascript used to use set

491
00:15:37,759 --> 00:15:40,079
interval and just keep calling their

492
00:15:38,880 --> 00:15:41,920
code over and over again but browser

493
00:15:40,079 --> 00:15:43,839
started to block that because it was bad

494
00:15:41,920 --> 00:15:46,079
and so now the the way to do it even if

495
00:15:43,839 --> 00:15:48,480
you're not doing animation

496
00:15:46,079 --> 00:15:50,239
is to call request animation frame and

497
00:15:48,480 --> 00:15:51,519
just keep rescheduling it over and over

498
00:15:50,240 --> 00:15:53,199
because then every time

499
00:15:51,519 --> 00:15:54,399
it does a paint which unfortunately

500
00:15:53,199 --> 00:15:56,319
browsers can do whatever they want but

501
00:15:54,399 --> 00:15:57,279
they say just assume 60 milliseconds

502
00:15:56,320 --> 00:15:58,480
but they don't allow you to actually

503
00:15:57,279 --> 00:15:59,839
detect the frame rate which is kind of

504
00:15:58,480 --> 00:16:02,240
annoying um

505
00:15:59,839 --> 00:16:03,759
so for us we just assume we have 16

506
00:16:02,240 --> 00:16:05,680
milliseconds to work with

507
00:16:03,759 --> 00:16:07,680
and so that leads to like a three to

508
00:16:05,680 --> 00:16:08,000
four percent cpu overhead at idle to

509
00:16:07,680 --> 00:16:09,839
just

510
00:16:08,000 --> 00:16:11,839
check if any process should be woken up

511
00:16:09,839 --> 00:16:14,959
or if any timers time out

512
00:16:11,839 --> 00:16:17,440
we can optimize it later though based on

513
00:16:14,959 --> 00:16:18,719
knowledge about the timers the runtime

514
00:16:17,440 --> 00:16:19,680
needs two ways to interact through the

515
00:16:18,720 --> 00:16:21,199
web through calls

516
00:16:19,680 --> 00:16:24,160
js calling into the lumen and lumen

517
00:16:21,199 --> 00:16:26,399
calling out to the jazz stuff

518
00:16:24,160 --> 00:16:27,680
as to described in the schedule section

519
00:16:26,399 --> 00:16:28,720
once the webassembly module was

520
00:16:27,680 --> 00:16:30,160
instantiated the scheduler

521
00:16:28,720 --> 00:16:32,320
started it and just went from the

522
00:16:30,160 --> 00:16:33,839
background it actually has no process it

523
00:16:32,320 --> 00:16:35,279
does not have a nip process it does not

524
00:16:33,839 --> 00:16:36,720
have an application tree

525
00:16:35,279 --> 00:16:38,959
for the demo i'm about to show you this

526
00:16:36,720 --> 00:16:39,360
is just like running one application by

527
00:16:38,959 --> 00:16:41,758
itself

528
00:16:39,360 --> 00:16:42,800
we will eventually support all that net

529
00:16:41,759 --> 00:16:43,920
application stuff but it didn't need it

530
00:16:42,800 --> 00:16:44,959
for this so we didn't go through the

531
00:16:43,920 --> 00:16:48,639
extra trouble

532
00:16:44,959 --> 00:16:51,518
um so we do these steps to

533
00:16:48,639 --> 00:16:53,279
happen asynchronously so to call

534
00:16:51,519 --> 00:16:55,759
asynchronously we use the wait keyword

535
00:16:53,279 --> 00:16:59,040
in javascript

536
00:16:55,759 --> 00:17:00,320
uh using the lumen web library uh we

537
00:16:59,040 --> 00:17:02,560
spawn a special process that is

538
00:17:00,320 --> 00:17:04,720
immediately executed this allows us to

539
00:17:02,560 --> 00:17:06,480
put all the to do the javascript to term

540
00:17:04,720 --> 00:17:07,520
conversion in that processes heap

541
00:17:06,480 --> 00:17:09,760
without having to

542
00:17:07,520 --> 00:17:11,359
like make a junk heap somewhere uh if we

543
00:17:09,760 --> 00:17:14,400
just did as an apply

544
00:17:11,359 --> 00:17:15,760
and then um we're going to we're going

545
00:17:14,400 --> 00:17:16,880
to put a special function call that

546
00:17:15,760 --> 00:17:19,679
we'll get a promise

547
00:17:16,880 --> 00:17:20,959
in the bottom and that and on top of

548
00:17:19,679 --> 00:17:22,720
that we'll do the apply

549
00:17:20,959 --> 00:17:24,319
because that way when the apply returns

550
00:17:22,720 --> 00:17:28,160
that special call to bottom will be able

551
00:17:24,319 --> 00:17:28,159
to shove that over the wall to js land

552
00:17:28,480 --> 00:17:32,000
to generate the promise we actually give

553
00:17:30,480 --> 00:17:33,760
promise new our executor and

554
00:17:32,000 --> 00:17:34,880
we only need to record the executor

555
00:17:33,760 --> 00:17:36,400
doesn't need to be anything special it

556
00:17:34,880 --> 00:17:38,880
is just a struct that holds

557
00:17:36,400 --> 00:17:39,760
the two callbacks uh that we get from a

558
00:17:38,880 --> 00:17:41,760
promise which is

559
00:17:39,760 --> 00:17:43,039
you can call resolve or reject resolve

560
00:17:41,760 --> 00:17:43,679
was that when everything went good

561
00:17:43,039 --> 00:17:45,840
rejected

562
00:17:43,679 --> 00:17:46,960
when everything went bad and rejected

563
00:17:45,840 --> 00:17:47,439
just happens automatically if your

564
00:17:46,960 --> 00:17:50,160
process

565
00:17:47,440 --> 00:17:50,160
dies on exit

566
00:17:51,200 --> 00:17:55,360
or abnormal exit i should say normal

567
00:17:52,720 --> 00:17:58,400
legs it's fine uh back in javascript uh

568
00:17:55,360 --> 00:17:59,120
chain run one returns but a promise so

569
00:17:58,400 --> 00:18:02,480
the weight curve

570
00:17:59,120 --> 00:18:04,080
just waits um in any given frame of the

571
00:18:02,480 --> 00:18:05,440
compiled code we're going to get the

572
00:18:04,080 --> 00:18:07,678
arguments from the stack

573
00:18:05,440 --> 00:18:09,679
uh replace the current frame and um

574
00:18:07,679 --> 00:18:12,720
pointer and next label and do that uh

575
00:18:09,679 --> 00:18:13,520
let me just got like yeah yeah i got two

576
00:18:12,720 --> 00:18:15,919
minutes okay

577
00:18:13,520 --> 00:18:17,918
so we're going to jump straight to the

578
00:18:15,919 --> 00:18:21,840
demo

579
00:18:17,919 --> 00:18:21,840
so this is oh

580
00:18:22,000 --> 00:18:25,039
wait was i not on that screen no oh no

581
00:18:24,240 --> 00:18:29,840
right because it's

582
00:18:25,039 --> 00:18:29,840
yeah sorry i forgot how this works

583
00:18:47,440 --> 00:18:54,080
okay so here is

584
00:18:51,760 --> 00:18:57,120
a working we have full dom interaction

585
00:18:54,080 --> 00:19:00,480
so i can do

586
00:18:57,120 --> 00:19:01,918
a form and it'll generate tables

587
00:19:00,480 --> 00:19:03,120
and aluminum web gives you all this so

588
00:19:01,919 --> 00:19:05,520
you can call these as normal erlang

589
00:19:03,120 --> 00:19:05,520
functions

590
00:19:05,760 --> 00:19:09,039
um what this is doing is as a sponging

591
00:19:07,919 --> 00:19:11,919
demo where we

592
00:19:09,039 --> 00:19:12,799
enum reduce over a list of processes

593
00:19:11,919 --> 00:19:15,360
process

594
00:19:12,799 --> 00:19:16,559
n gets process n minus ones pid and then

595
00:19:15,360 --> 00:19:18,000
i give it zero and it goes back the

596
00:19:16,559 --> 00:19:19,678
other way adding

597
00:19:18,000 --> 00:19:21,120
and so this shows both that we can spawn

598
00:19:19,679 --> 00:19:24,160
processes

599
00:19:21,120 --> 00:19:26,479
and um

600
00:19:24,160 --> 00:19:26,480
we can

601
00:19:27,440 --> 00:19:32,000
pass integers we can pass integers when

602
00:19:29,120 --> 00:19:34,239
they get too big we can print

603
00:19:32,000 --> 00:19:34,240
um

604
00:19:35,679 --> 00:19:43,200
and if you want to time

605
00:19:40,160 --> 00:19:46,320
okay uh we also have support for

606
00:19:43,200 --> 00:19:49,440
uh and so this shows that the

607
00:19:46,320 --> 00:19:51,918
the runtime works but the actual like

608
00:19:49,440 --> 00:19:52,720
uh elixir code was me translated by uh

609
00:19:51,919 --> 00:19:54,400
with russ

610
00:19:52,720 --> 00:19:56,480
we're still working on the compiler but

611
00:19:54,400 --> 00:20:00,080
there's an interpreter that works

612
00:19:56,480 --> 00:20:02,240
and so if i go here you can see it says

613
00:20:00,080 --> 00:20:07,840
elixir in your browser

614
00:20:02,240 --> 00:20:07,840
i go

615
00:20:15,360 --> 00:20:18,399
right so this like erlang file is just

616
00:20:17,280 --> 00:20:22,639
sitting

617
00:20:18,400 --> 00:20:22,640
on my desk and if i reload the page

618
00:20:22,720 --> 00:20:26,559
the interpreter can read that file using

619
00:20:24,880 --> 00:20:28,000
the um

620
00:20:26,559 --> 00:20:30,158
the normal javascript apis that get a

621
00:20:28,000 --> 00:20:30,880
file and we're able to read it into the

622
00:20:30,159 --> 00:20:33,919
interpreter

623
00:20:30,880 --> 00:20:35,039
the interpreter compiles the ast from

624
00:20:33,919 --> 00:20:37,200
this erlang source

625
00:20:35,039 --> 00:20:38,480
and is able to run the code and this is

626
00:20:37,200 --> 00:20:39,760
printing into a

627
00:20:38,480 --> 00:20:48,880
div element so it's doing dom

628
00:20:39,760 --> 00:20:50,320
interaction also

629
00:20:48,880 --> 00:20:52,240
yeah that that's the equivalent of what

630
00:20:50,320 --> 00:20:53,360
it's doing so this was um converted from

631
00:20:52,240 --> 00:20:54,799
elixir code

632
00:20:53,360 --> 00:20:56,559
and that i just did in the airline code

633
00:20:54,799 --> 00:20:58,639
because it's faster convert so there

634
00:20:56,559 --> 00:21:00,240
um one of the core team members of

635
00:20:58,640 --> 00:21:01,200
elixir has a thing that will decompile

636
00:21:00,240 --> 00:21:03,360
any beam file

637
00:21:01,200 --> 00:21:05,440
back to erlang and so we use that to

638
00:21:03,360 --> 00:21:07,678
convert the elixir to erlang

639
00:21:05,440 --> 00:21:09,600
for this it's uh just a mixed test

640
00:21:07,679 --> 00:21:12,000
called mix decompile

641
00:21:09,600 --> 00:21:16,080
and so it's um it's on his github i

642
00:21:12,000 --> 00:21:18,960
don't think it's a hex package yet

643
00:21:16,080 --> 00:21:18,960
uh questions i guess

644
00:21:22,080 --> 00:21:26,480
i have a question um so uh thanks for

645
00:21:25,120 --> 00:21:28,320
the talk it was great

646
00:21:26,480 --> 00:21:30,559
so you talked about the head of time

647
00:21:28,320 --> 00:21:32,240
compilation and how you can just compile

648
00:21:30,559 --> 00:21:34,000
what you use

649
00:21:32,240 --> 00:21:36,080
does that mean that for instance if i

650
00:21:34,000 --> 00:21:39,120
don't use a given

651
00:21:36,080 --> 00:21:39,918
beam module it won't get compiled and

652
00:21:39,120 --> 00:21:42,320
shipped to the

653
00:21:39,919 --> 00:21:44,080
right okay so my follow-up to that would

654
00:21:42,320 --> 00:21:47,520
be do you plan on having

655
00:21:44,080 --> 00:21:49,678
a sort of grapple um that's that

656
00:21:47,520 --> 00:21:50,720
that we can that we can have or would

657
00:21:49,679 --> 00:21:52,640
that be

658
00:21:50,720 --> 00:21:54,559
we we can easily do the rebel with the

659
00:21:52,640 --> 00:21:56,480
interpreter oh uh

660
00:21:54,559 --> 00:21:59,039
do we uh do we expect there to be a

661
00:21:56,480 --> 00:22:01,440
rebel um we can do the rebel

662
00:21:59,039 --> 00:22:03,679
easily with the interpreter because we

663
00:22:01,440 --> 00:22:05,840
can just ship you the interpreter

664
00:22:03,679 --> 00:22:07,280
but with the compile the compiled

665
00:22:05,840 --> 00:22:08,158
version it would be harder because we'd

666
00:22:07,280 --> 00:22:09,760
have to

667
00:22:08,159 --> 00:22:12,559
ship a repo loop that we normally

668
00:22:09,760 --> 00:22:13,840
wouldn't ship so i would say

669
00:22:12,559 --> 00:22:15,440
that you probably have to unfortunately

670
00:22:13,840 --> 00:22:17,520
use the interpreter for the rebel

671
00:22:15,440 --> 00:22:20,080
version

672
00:22:17,520 --> 00:22:21,039
we might because we want to we want to

673
00:22:20,080 --> 00:22:23,439
support

674
00:22:21,039 --> 00:22:24,720
you being able to give like a almost

675
00:22:23,440 --> 00:22:26,000
like a boot script so that you don't

676
00:22:24,720 --> 00:22:28,080
enable you know the same reason

677
00:22:26,000 --> 00:22:29,600
that the same reason why you sometimes

678
00:22:28,080 --> 00:22:30,879
uh you boot your app

679
00:22:29,600 --> 00:22:32,158
uh when you have a release with

680
00:22:30,880 --> 00:22:33,120
everything booted and sometimes you do a

681
00:22:32,159 --> 00:22:34,799
clean console with

682
00:22:33,120 --> 00:22:35,678
not everything booted we would probably

683
00:22:34,799 --> 00:22:36,960
be able to support that because it's not

684
00:22:35,679 --> 00:22:38,400
going to change what you ship it's just

685
00:22:36,960 --> 00:22:41,600
what you have running

686
00:22:38,400 --> 00:22:42,799
and so we potentially uh will need a

687
00:22:41,600 --> 00:22:46,240
term parser so that

688
00:22:42,799 --> 00:22:47,679
um you would be able to

689
00:22:46,240 --> 00:22:49,440
change the arguments to the applications

690
00:22:47,679 --> 00:22:50,559
when you boot them uh with the boot

691
00:22:49,440 --> 00:22:52,880
script

692
00:22:50,559 --> 00:22:54,639
but the boot script is usually in uh

693
00:22:52,880 --> 00:22:55,200
term to binary format already it's not

694
00:22:54,640 --> 00:22:58,640
like

695
00:22:55,200 --> 00:23:01,200
human readable uh erlang uh term format

696
00:22:58,640 --> 00:23:02,480
and so we will definitely support term

697
00:23:01,200 --> 00:23:03,600
to binary or bootscript

698
00:23:02,480 --> 00:23:05,039
but we don't know if we'll get to a

699
00:23:03,600 --> 00:23:06,158
point where you could just do a repel

700
00:23:05,039 --> 00:23:07,360
that a human could read

701
00:23:06,159 --> 00:23:09,360
for a stuff that's compiled with

702
00:23:07,360 --> 00:23:11,039
interpreter yeah like i'm

703
00:23:09,360 --> 00:23:12,399
loading the file here but it doesn't

704
00:23:11,039 --> 00:23:13,039
have to be loaded for a file i also

705
00:23:12,400 --> 00:23:14,480
could have just

706
00:23:13,039 --> 00:23:16,080
put in the text in the console and that

707
00:23:14,480 --> 00:23:17,520
would have also worked it just

708
00:23:16,080 --> 00:23:20,240
uh would have been more error prone copy

709
00:23:17,520 --> 00:23:20,240
and paste or a problem

710
00:23:21,760 --> 00:23:26,000
anything else oh uh we do have stickers

711
00:23:25,200 --> 00:23:37,840
for lumen

712
00:23:26,000 --> 00:23:37,840
if anyone wants stickers

713
00:23:38,400 --> 00:23:40,480
you

