1
00:00:06,240 --> 00:00:09,840
hi everyone

2
00:00:07,040 --> 00:00:12,240
welcome to this talk my name is john i'm

3
00:00:09,840 --> 00:00:14,559
an open source engineer at packages

4
00:00:12,240 --> 00:00:17,920
and during the next 25 minutes we are

5
00:00:14,559 --> 00:00:17,919
going to talk about the web

6
00:00:18,800 --> 00:00:22,160
in my opinion the web is an amazing

7
00:00:21,119 --> 00:00:25,119
platform

8
00:00:22,160 --> 00:00:26,320
and i think that we can all agree on one

9
00:00:25,119 --> 00:00:28,960
fact is that

10
00:00:26,320 --> 00:00:30,400
it the web has evolved a lot since its

11
00:00:28,960 --> 00:00:33,680
beginning

12
00:00:30,400 --> 00:00:34,239
we went from sending simple text over a

13
00:00:33,680 --> 00:00:36,480
wire

14
00:00:34,239 --> 00:00:37,519
to providing a full experience to the

15
00:00:36,480 --> 00:00:39,279
end user

16
00:00:37,520 --> 00:00:41,280
and i think one key component within the

17
00:00:39,280 --> 00:00:44,960
web that has brought this

18
00:00:41,280 --> 00:00:48,399
experience is javascript

19
00:00:44,960 --> 00:00:51,120
right but so

20
00:00:48,399 --> 00:00:52,960
javascript built in 1985 uh shipped

21
00:00:51,120 --> 00:00:54,718
within the netscape browser was aiming

22
00:00:52,960 --> 00:00:59,840
to provide some dynamism

23
00:00:54,719 --> 00:00:59,840
to the static content of the web but

24
00:01:00,399 --> 00:01:03,680
what we were trying to achieve with

25
00:01:01,760 --> 00:01:07,200
javascript that time it's

26
00:01:03,680 --> 00:01:08,080
a much more much smaller part of what we

27
00:01:07,200 --> 00:01:10,720
are doing with it

28
00:01:08,080 --> 00:01:12,720
now so the way that it was executed at

29
00:01:10,720 --> 00:01:14,560
that time is quite different from the

30
00:01:12,720 --> 00:01:16,640
way it is executed nowadays so

31
00:01:14,560 --> 00:01:17,600
at that time javascript was interpreted

32
00:01:16,640 --> 00:01:19,600
okay

33
00:01:17,600 --> 00:01:21,360
and to take a closer look at what

34
00:01:19,600 --> 00:01:23,119
interpretation is is

35
00:01:21,360 --> 00:01:24,479
for example here we have in the middle

36
00:01:23,119 --> 00:01:27,200
our interpreter

37
00:01:24,479 --> 00:01:28,479
javascript okay and on the right side we

38
00:01:27,200 --> 00:01:31,600
have kind of like the

39
00:01:28,479 --> 00:01:34,000
bare metal machine the cpu on the left

40
00:01:31,600 --> 00:01:36,479
we have a bunch of javascript code lines

41
00:01:34,000 --> 00:01:38,079
calling add functions passing numbers

42
00:01:36,479 --> 00:01:39,759
and when the execution hits the first

43
00:01:38,079 --> 00:01:42,000
line the line is sent

44
00:01:39,759 --> 00:01:43,280
to the interpreter the interpreter does

45
00:01:42,000 --> 00:01:45,360
his job okay

46
00:01:43,280 --> 00:01:46,880
evaluates both parameters their type

47
00:01:45,360 --> 00:01:48,640
what we are trying to achieve

48
00:01:46,880 --> 00:01:51,600
and then output some matching code that

49
00:01:48,640 --> 00:01:54,880
gets directly executed by the cpu

50
00:01:51,600 --> 00:01:55,919
next line sim process again evaluating

51
00:01:54,880 --> 00:01:57,839
both parameters

52
00:01:55,920 --> 00:01:59,280
saying what kind of types they are and

53
00:01:57,840 --> 00:02:01,600
then outputting

54
00:01:59,280 --> 00:02:03,040
some matching code and the thing here

55
00:02:01,600 --> 00:02:07,199
that this mechanism

56
00:02:03,040 --> 00:02:09,759
worked until kind of 2005 when big

57
00:02:07,200 --> 00:02:11,360
javascript apps started to come onto the

58
00:02:09,758 --> 00:02:14,480
scene and one example is

59
00:02:11,360 --> 00:02:17,360
uh google maps which which

60
00:02:14,480 --> 00:02:19,519
uh browser started to hit kind of like a

61
00:02:17,360 --> 00:02:22,800
performance issue with those javascript

62
00:02:19,520 --> 00:02:25,840
apps and why because at the end

63
00:02:22,800 --> 00:02:29,280
doing a simple addition in javascript

64
00:02:25,840 --> 00:02:33,680
is not trivial you have to check

65
00:02:29,280 --> 00:02:36,640
both operands types and regarding their

66
00:02:33,680 --> 00:02:38,000
their regarding the evaluation you you

67
00:02:36,640 --> 00:02:41,040
will output some different

68
00:02:38,000 --> 00:02:41,519
code so you cannot really count on the

69
00:02:41,040 --> 00:02:43,599
language

70
00:02:41,519 --> 00:02:45,840
by itself you have to wait until runtime

71
00:02:43,599 --> 00:02:48,238
so one of the mechanism that

72
00:02:45,840 --> 00:02:49,840
browsers applied to solve this issue

73
00:02:48,239 --> 00:02:50,480
it's a very well-known mechanism which

74
00:02:49,840 --> 00:02:52,560
is called

75
00:02:50,480 --> 00:02:54,799
just in time compilation and if we take

76
00:02:52,560 --> 00:02:58,239
back the same example

77
00:02:54,800 --> 00:03:00,480
we still have both uh items there but

78
00:02:58,239 --> 00:03:02,159
you have a third one a third component

79
00:03:00,480 --> 00:03:03,040
within the system which is the just in

80
00:03:02,159 --> 00:03:06,079
time compiler

81
00:03:03,040 --> 00:03:07,519
okay we take again the same lines first

82
00:03:06,080 --> 00:03:10,400
line is sent to the interpreter

83
00:03:07,519 --> 00:03:13,200
it does the same evaluates interpret it

84
00:03:10,400 --> 00:03:17,280
output some matching code and that's it

85
00:03:13,200 --> 00:03:19,839
second line same process evaluate it

86
00:03:17,280 --> 00:03:20,640
both parameters and then output some

87
00:03:19,840 --> 00:03:24,000
machine code

88
00:03:20,640 --> 00:03:26,958
but this time the interpreter

89
00:03:24,000 --> 00:03:28,400
has monitored the code and the execution

90
00:03:26,959 --> 00:03:29,760
and it has some feedback about the

91
00:03:28,400 --> 00:03:33,120
execution so it

92
00:03:29,760 --> 00:03:34,399
can see that okay we try to execute

93
00:03:33,120 --> 00:03:37,519
twice the same function

94
00:03:34,400 --> 00:03:41,920
passing twice numbers

95
00:03:37,519 --> 00:03:45,280
why don't so it marks that function

96
00:03:41,920 --> 00:03:46,720
as hot and then pass it to the just in

97
00:03:45,280 --> 00:03:49,840
time compiler

98
00:03:46,720 --> 00:03:51,680
to compile it and output some

99
00:03:49,840 --> 00:03:52,879
the same machine code that it was

100
00:03:51,680 --> 00:03:54,560
previously outputted

101
00:03:52,879 --> 00:03:56,079
store it somewhere else somewhere in

102
00:03:54,560 --> 00:03:58,000
memory and

103
00:03:56,080 --> 00:03:59,280
lock that memory region so we cannot

104
00:03:58,000 --> 00:04:01,760
override it

105
00:03:59,280 --> 00:04:03,599
third line comes to execute it and then

106
00:04:01,760 --> 00:04:05,120
there the interpreter say okay i know

107
00:04:03,599 --> 00:04:06,159
this add function it's not the first

108
00:04:05,120 --> 00:04:09,040
time

109
00:04:06,159 --> 00:04:10,079
i just ask the just in time compiler to

110
00:04:09,040 --> 00:04:11,519
com

111
00:04:10,080 --> 00:04:14,640
to compile it and put it somewhere in

112
00:04:11,519 --> 00:04:18,079
memory so

113
00:04:14,640 --> 00:04:20,959
all still are still both parameters

114
00:04:18,079 --> 00:04:22,560
numbers yes okay you can then take the

115
00:04:20,959 --> 00:04:26,000
one that i just compiled it

116
00:04:22,560 --> 00:04:26,639
and directly execute it and if you see

117
00:04:26,000 --> 00:04:28,720
this

118
00:04:26,639 --> 00:04:30,240
here what we have done what the the

119
00:04:28,720 --> 00:04:32,880
engine have done is just that

120
00:04:30,240 --> 00:04:33,919
he made a shortcut for the execution of

121
00:04:32,880 --> 00:04:37,199
a function

122
00:04:33,919 --> 00:04:40,639
and we call that the fast path okay

123
00:04:37,199 --> 00:04:43,840
and that's when javascript gave us his

124
00:04:40,639 --> 00:04:43,840
top speed

125
00:04:45,759 --> 00:04:49,040
and just to show you the difference

126
00:04:47,040 --> 00:04:51,040
between non-jittered code so

127
00:04:49,040 --> 00:04:52,639
non-gta javascript and gta javascript i

128
00:04:51,040 --> 00:04:55,759
just launched an

129
00:04:52,639 --> 00:04:57,280
instance of chrome disabling the

130
00:04:55,759 --> 00:04:59,919
optimization of javascript

131
00:04:57,280 --> 00:05:02,080
and you can see for eight robot denser

132
00:04:59,919 --> 00:05:04,080
it's kind of laggy on the left side

133
00:05:02,080 --> 00:05:06,000
but on the right side it's kind of going

134
00:05:04,080 --> 00:05:08,880
very well you can even i think

135
00:05:06,000 --> 00:05:10,560
i increased until 15 and it's still okay

136
00:05:08,880 --> 00:05:12,560
but then

137
00:05:10,560 --> 00:05:13,840
well we had the performance issue with

138
00:05:12,560 --> 00:05:16,320
javascript

139
00:05:13,840 --> 00:05:16,880
with interpretation we compile it and it

140
00:05:16,320 --> 00:05:18,719
works

141
00:05:16,880 --> 00:05:20,000
pretty well why don't we why do we want

142
00:05:18,720 --> 00:05:23,039
to go further

143
00:05:20,000 --> 00:05:24,800
well the thing is that i didn't tell you

144
00:05:23,039 --> 00:05:27,440
the whole story

145
00:05:24,800 --> 00:05:27,919
if we go back to example and this time

146
00:05:27,440 --> 00:05:29,919
i'm

147
00:05:27,919 --> 00:05:32,479
sending instead of two numbers one

148
00:05:29,919 --> 00:05:34,880
string and one number

149
00:05:32,479 --> 00:05:36,320
the interpreter will try again to say

150
00:05:34,880 --> 00:05:39,360
okay i know this function

151
00:05:36,320 --> 00:05:42,800
i just store it somewhere but

152
00:05:39,360 --> 00:05:45,600
although are still those two parameters

153
00:05:42,800 --> 00:05:46,000
numbers nope so what he's done he's

154
00:05:45,600 --> 00:05:47,520
doing

155
00:05:46,000 --> 00:05:49,440
is that he's going to fall back to

156
00:05:47,520 --> 00:05:54,000
interpretation and

157
00:05:49,440 --> 00:05:54,000
erase the compiled version that he had

158
00:05:55,039 --> 00:05:58,159
yeah super animation

159
00:05:58,479 --> 00:06:02,080
so at the end what's the problem with

160
00:06:00,479 --> 00:06:03,680
javascript well i mean

161
00:06:02,080 --> 00:06:05,199
not the problem i don't wanna offend it

162
00:06:03,680 --> 00:06:08,479
i'm sorry

163
00:06:05,199 --> 00:06:11,120
i'm sorry i didn't what's the thing

164
00:06:08,479 --> 00:06:12,960
what javascript is lacking to be

165
00:06:11,120 --> 00:06:16,000
optimized before execution

166
00:06:12,960 --> 00:06:19,039
well javascript is just lacking

167
00:06:16,000 --> 00:06:22,720
predictability if you take the same

168
00:06:19,039 --> 00:06:24,560
version the same i mean two versions of

169
00:06:22,720 --> 00:06:25,680
the same code one written in c and

170
00:06:24,560 --> 00:06:28,319
another in javascript

171
00:06:25,680 --> 00:06:29,919
you can clearly see that in c the

172
00:06:28,319 --> 00:06:30,720
language provides some hints to the

173
00:06:29,919 --> 00:06:35,440
compiler

174
00:06:30,720 --> 00:06:38,080
so he can optimize code before runtime

175
00:06:35,440 --> 00:06:40,319
when if you look at the javascript side

176
00:06:38,080 --> 00:06:43,280
there's not much going on there

177
00:06:40,319 --> 00:06:43,840
even the number of parameters are not

178
00:06:43,280 --> 00:06:46,159
really

179
00:06:43,840 --> 00:06:49,599
fixed so you can pass more than two if

180
00:06:46,160 --> 00:06:52,160
you want

181
00:06:49,599 --> 00:06:52,719
so if we quickly recap what we learned

182
00:06:52,160 --> 00:06:56,000
here or

183
00:06:52,720 --> 00:06:58,800
no maybe what we have to so we opt

184
00:06:56,000 --> 00:06:59,759
we can optimize javascript and it's cool

185
00:06:58,800 --> 00:07:01,360
and you can have

186
00:06:59,759 --> 00:07:03,280
really good performance with it's no

187
00:07:01,360 --> 00:07:04,720
problem but the thing is that javascript

188
00:07:03,280 --> 00:07:08,318
is not predictable

189
00:07:04,720 --> 00:07:11,360
so the industry browsers

190
00:07:08,319 --> 00:07:13,840
have tried to solve this problem uh

191
00:07:11,360 --> 00:07:15,199
i mean to solve that to fix this and

192
00:07:13,840 --> 00:07:17,280
they try to run

193
00:07:15,199 --> 00:07:19,599
some more predictable code within the

194
00:07:17,280 --> 00:07:20,318
browser and one of the initiatives is

195
00:07:19,599 --> 00:07:23,280
for example

196
00:07:20,319 --> 00:07:24,800
portable native client from google which

197
00:07:23,280 --> 00:07:28,719
was to

198
00:07:24,800 --> 00:07:31,599
to run some some c plus plus

199
00:07:28,720 --> 00:07:32,080
modules within the browsers send boxes

200
00:07:31,599 --> 00:07:35,759
so

201
00:07:32,080 --> 00:07:38,960
it's secured but it didn't really

202
00:07:35,759 --> 00:07:40,880
took off after that multi-lab

203
00:07:38,960 --> 00:07:42,880
came with an idea of just taking a

204
00:07:40,880 --> 00:07:46,080
subset of javascript which was

205
00:07:42,880 --> 00:07:46,400
more predictable um with and they call

206
00:07:46,080 --> 00:07:49,840
it

207
00:07:46,400 --> 00:07:52,318
they called they call it sn.s but

208
00:07:49,840 --> 00:07:54,719
it wasn't enough because it was still

209
00:07:52,319 --> 00:07:58,319
javascript at the end

210
00:07:54,720 --> 00:08:01,919
and in 2015

211
00:07:58,319 --> 00:08:03,360
browsers reunited and tried to come up

212
00:08:01,919 --> 00:08:06,400
with something that they

213
00:08:03,360 --> 00:08:07,840
could agree on to go a step further to

214
00:08:06,400 --> 00:08:09,758
push the limit of the webs

215
00:08:07,840 --> 00:08:11,679
and that's where web assembly came onto

216
00:08:09,759 --> 00:08:12,160
the scene and what is web assembly if we

217
00:08:11,680 --> 00:08:14,800
take

218
00:08:12,160 --> 00:08:16,800
quickly just the the text from the

219
00:08:14,800 --> 00:08:18,720
official page which is quite dense

220
00:08:16,800 --> 00:08:20,000
i'm going to read it so webassembly

221
00:08:18,720 --> 00:08:22,400
abbreviated wasm

222
00:08:20,000 --> 00:08:23,840
is a binary instruction format for stack

223
00:08:22,400 --> 00:08:25,919
based virtual machine

224
00:08:23,840 --> 00:08:27,840
was designed as a portable target for

225
00:08:25,919 --> 00:08:28,159
compilation of high level languages like

226
00:08:27,840 --> 00:08:30,719
c

227
00:08:28,160 --> 00:08:32,399
c plus plus rust enabling deployment on

228
00:08:30,720 --> 00:08:34,959
the web for client and server

229
00:08:32,399 --> 00:08:34,958
application

230
00:08:35,360 --> 00:08:38,479
a lot of things huh we are going to try

231
00:08:37,599 --> 00:08:41,039
to

232
00:08:38,479 --> 00:08:43,519
read it again but step by step so

233
00:08:41,039 --> 00:08:45,519
webassembly aggregate it wasn't

234
00:08:43,519 --> 00:08:46,800
is a binary instruction format so it

235
00:08:45,519 --> 00:08:48,000
just means that it's a set of

236
00:08:46,800 --> 00:08:50,319
instructions

237
00:08:48,000 --> 00:08:53,440
encoded in a binary way so it's quite

238
00:08:50,320 --> 00:08:55,279
efficient to load it

239
00:08:53,440 --> 00:08:57,120
designed as a portable target for

240
00:08:55,279 --> 00:08:59,600
compilation so two things here

241
00:08:57,120 --> 00:09:00,959
um portable it means that webassembly is

242
00:08:59,600 --> 00:09:02,640
not just designed for the web

243
00:09:00,959 --> 00:09:04,640
but it's also designed to run outside

244
00:09:02,640 --> 00:09:06,560
the web on other platforms

245
00:09:04,640 --> 00:09:08,080
and target full compilation means that

246
00:09:06,560 --> 00:09:10,479
you don't have necessary to write

247
00:09:08,080 --> 00:09:12,640
webassembly it's quite low level

248
00:09:10,480 --> 00:09:13,519
you are more kind to you're more likely

249
00:09:12,640 --> 00:09:16,800
to write in

250
00:09:13,519 --> 00:09:20,080
higher level languages like c c

251
00:09:16,800 --> 00:09:25,199
space rust go c sharp java

252
00:09:20,080 --> 00:09:28,240
whatever and you compile to webassembly

253
00:09:25,200 --> 00:09:30,240
so how the process goes simply you take

254
00:09:28,240 --> 00:09:31,120
a bunch of files cc prospects here i

255
00:09:30,240 --> 00:09:33,360
just

256
00:09:31,120 --> 00:09:35,200
okay i mentioned just c and c you

257
00:09:33,360 --> 00:09:38,320
compile it to intermediate

258
00:09:35,200 --> 00:09:40,880
intermediate a representation

259
00:09:38,320 --> 00:09:42,240
it's almost always llvm i will skip the

260
00:09:40,880 --> 00:09:43,920
details about llvm

261
00:09:42,240 --> 00:09:45,600
okay but normally this part is quite

262
00:09:43,920 --> 00:09:46,399
hidden from the developer perspective

263
00:09:45,600 --> 00:09:48,720
okay

264
00:09:46,399 --> 00:09:49,519
and then you compile as a backend

265
00:09:48,720 --> 00:09:52,640
compilation

266
00:09:49,519 --> 00:09:53,360
to a simple dot was in this case it's

267
00:09:52,640 --> 00:09:56,319
the name but

268
00:09:53,360 --> 00:09:58,320
it wasn't module okay and uh with uh

269
00:09:56,320 --> 00:10:00,480
which tool for example one of the

270
00:09:58,320 --> 00:10:01,600
main tools to compile to webassembly is

271
00:10:00,480 --> 00:10:03,279
same script which

272
00:10:01,600 --> 00:10:05,519
first mission mainly mission is to

273
00:10:03,279 --> 00:10:08,800
provide to bring other languages

274
00:10:05,519 --> 00:10:10,720
on the plat on the web so then how do

275
00:10:08,800 --> 00:10:14,160
you consume this simple that wasm

276
00:10:10,720 --> 00:10:15,200
well you fetch the resource i think you

277
00:10:14,160 --> 00:10:18,319
all know this

278
00:10:15,200 --> 00:10:21,120
you fetch the resource and then you just

279
00:10:18,320 --> 00:10:22,079
call the javascript api webassembly apis

280
00:10:21,120 --> 00:10:24,800
that are

281
00:10:22,079 --> 00:10:26,399
nowadays available in all all the

282
00:10:24,800 --> 00:10:29,680
browsers the major browsers

283
00:10:26,399 --> 00:10:30,240
and then you receive um uh you receive

284
00:10:29,680 --> 00:10:33,760
uh

285
00:10:30,240 --> 00:10:34,880
was a module which you can call function

286
00:10:33,760 --> 00:10:37,040
on it

287
00:10:34,880 --> 00:10:38,800
here exported thing and those functions

288
00:10:37,040 --> 00:10:41,279
were originally written in another

289
00:10:38,800 --> 00:10:43,920
language

290
00:10:41,279 --> 00:10:46,000
so what are the goal of webassembly

291
00:10:43,920 --> 00:10:49,680
webassembly wants to be performant

292
00:10:46,000 --> 00:10:52,640
run at nearly native speed after that

293
00:10:49,680 --> 00:10:54,880
webassembly wants to be portable okay so

294
00:10:52,640 --> 00:10:57,040
not only running on on the web but also

295
00:10:54,880 --> 00:11:00,000
running in other platforms

296
00:10:57,040 --> 00:11:01,439
and secure secure by default it's one of

297
00:11:00,000 --> 00:11:03,440
the main concerns

298
00:11:01,440 --> 00:11:06,000
of webassembly being more secure than

299
00:11:03,440 --> 00:11:06,000
javascript

300
00:11:06,480 --> 00:11:10,000
performance well

301
00:11:10,880 --> 00:11:16,399
i might disappoint you but javascript is

302
00:11:13,040 --> 00:11:19,360
not i mean sorry web assembly is not

303
00:11:16,399 --> 00:11:19,839
so much faster somewhere more faster

304
00:11:19,360 --> 00:11:23,040
than

305
00:11:19,839 --> 00:11:25,120
super optimized compiled javascript

306
00:11:23,040 --> 00:11:26,319
at the end they quite run early at

307
00:11:25,120 --> 00:11:29,360
native space

308
00:11:26,320 --> 00:11:32,640
space speed sorry but the thing is that

309
00:11:29,360 --> 00:11:34,959
um javascript

310
00:11:32,640 --> 00:11:36,560
i mean webassembly will more likely to

311
00:11:34,959 --> 00:11:39,040
stay on the fast path

312
00:11:36,560 --> 00:11:39,599
when you have an optimized version of it

313
00:11:39,040 --> 00:11:42,079
while

314
00:11:39,600 --> 00:11:45,360
javascript will kind of de-optimize

315
00:11:42,079 --> 00:11:47,680
easily and falls back to interpretation

316
00:11:45,360 --> 00:11:49,920
and for to illustrate my point here you

317
00:11:47,680 --> 00:11:52,160
have

318
00:11:49,920 --> 00:11:54,479
a multiple just diagram showing multiple

319
00:11:52,160 --> 00:11:56,079
execution of the same code in javascript

320
00:11:54,480 --> 00:11:58,399
and then the same code in webassembly in

321
00:11:56,079 --> 00:12:01,040
blue webassembly is faster okay

322
00:11:58,399 --> 00:12:02,880
but the point here is to show that for

323
00:12:01,040 --> 00:12:04,719
multiple execution of the same code in

324
00:12:02,880 --> 00:12:07,439
javascript you don't have

325
00:12:04,720 --> 00:12:08,959
you cannot predict the performance well

326
00:12:07,440 --> 00:12:11,839
in web assembly is quite

327
00:12:08,959 --> 00:12:11,839
almost the same

328
00:12:12,000 --> 00:12:16,560
also was can be decoded validated and

329
00:12:15,200 --> 00:12:19,120
compiled in a fast

330
00:12:16,560 --> 00:12:22,959
single pass equally with either just in

331
00:12:19,120 --> 00:12:25,680
time or ahead of time compilation

332
00:12:22,959 --> 00:12:27,439
if you check how um javascript is

333
00:12:25,680 --> 00:12:29,439
handled within a browser

334
00:12:27,440 --> 00:12:31,120
you first fetch the whole resource and

335
00:12:29,440 --> 00:12:34,480
then you parse it compile it

336
00:12:31,120 --> 00:12:34,959
and execute it all that in the main

337
00:12:34,480 --> 00:12:37,120
thread

338
00:12:34,959 --> 00:12:38,000
there are some exceptions okay not

339
00:12:37,120 --> 00:12:39,360
everything happens

340
00:12:38,000 --> 00:12:41,600
sometimes in the main thread but that's

341
00:12:39,360 --> 00:12:44,399
kind of the regular way of doing it

342
00:12:41,600 --> 00:12:45,440
but browsers handle webassembly in

343
00:12:44,399 --> 00:12:47,839
another way

344
00:12:45,440 --> 00:12:49,120
so while fetching the packets while

345
00:12:47,839 --> 00:12:52,160
fetching the resource

346
00:12:49,120 --> 00:12:54,639
wasn't modules the browser will

347
00:12:52,160 --> 00:12:55,360
directly compile the bytes dark on the

348
00:12:54,639 --> 00:12:57,839
fly

349
00:12:55,360 --> 00:12:59,279
and when it and when it when it's done

350
00:12:57,839 --> 00:13:01,040
it will execute

351
00:12:59,279 --> 00:13:02,320
on the main thread and the compilation

352
00:13:01,040 --> 00:13:04,839
doesn't happen on the main track so it

353
00:13:02,320 --> 00:13:07,360
does not block

354
00:13:04,839 --> 00:13:08,639
users

355
00:13:07,360 --> 00:13:10,560
just to show you the difference of

356
00:13:08,639 --> 00:13:13,760
performance you have 30

357
00:13:10,560 --> 00:13:15,760
robot dancer here and you can see that

358
00:13:13,760 --> 00:13:18,839
javascript is quite laggy

359
00:13:15,760 --> 00:13:20,959
when you switch the execution to

360
00:13:18,839 --> 00:13:23,200
webassembly

361
00:13:20,959 --> 00:13:25,040
it goes back to normal and you can even

362
00:13:23,200 --> 00:13:29,600
increase the number and i'm going

363
00:13:25,040 --> 00:13:29,599
i'll go there until i think 120

364
00:13:31,920 --> 00:13:36,560
but you will not see the difference

365
00:13:33,120 --> 00:13:40,079
because the screen is too short yeah

366
00:13:36,560 --> 00:13:43,040
okay so portable um at the beginning was

367
00:13:40,079 --> 00:13:45,120
was uh meant the first version of was it

368
00:13:43,040 --> 00:13:48,719
was meant to to to at least

369
00:13:45,120 --> 00:13:51,680
work work on the browser so

370
00:13:48,720 --> 00:13:52,240
the way of execute was was to uh provide

371
00:13:51,680 --> 00:13:55,199
some

372
00:13:52,240 --> 00:13:56,399
gs glue code that when a wasn't module

373
00:13:55,199 --> 00:13:57,680
was trying to do something that the

374
00:13:56,399 --> 00:14:00,720
browser couldn't handle

375
00:13:57,680 --> 00:14:02,160
at least the javascript will handle the

376
00:14:00,720 --> 00:14:04,079
code and

377
00:14:02,160 --> 00:14:05,920
simulate something emulate something for

378
00:14:04,079 --> 00:14:06,800
example calling a file system you cannot

379
00:14:05,920 --> 00:14:10,000
call file

380
00:14:06,800 --> 00:14:10,639
system within the browser so when folks

381
00:14:10,000 --> 00:14:14,079
try to

382
00:14:10,639 --> 00:14:16,079
run wasm outside of the of the browser

383
00:14:14,079 --> 00:14:17,760
what they tried to do is just to run the

384
00:14:16,079 --> 00:14:20,160
existing was a module

385
00:14:17,760 --> 00:14:21,279
outside the browser and um so they were

386
00:14:20,160 --> 00:14:24,399
kind of emulating

387
00:14:21,279 --> 00:14:25,920
gs gs glue code that was emulating a

388
00:14:24,399 --> 00:14:28,000
system interface so it's

389
00:14:25,920 --> 00:14:28,959
not really the well the most optimized

390
00:14:28,000 --> 00:14:32,000
way to do it

391
00:14:28,959 --> 00:14:35,199
so a need of as much as

392
00:14:32,000 --> 00:14:36,320
wasm is a language for a conceptual

393
00:14:35,199 --> 00:14:39,920
virtual machine

394
00:14:36,320 --> 00:14:42,000
it needed a system interface a standard

395
00:14:39,920 --> 00:14:44,800
and standardized system interface for

396
00:14:42,000 --> 00:14:46,880
conceptual operating system

397
00:14:44,800 --> 00:14:48,560
that's when webassembly system interface

398
00:14:46,880 --> 00:14:51,600
came onto the scene

399
00:14:48,560 --> 00:14:55,518
it's just a specification that runs

400
00:14:51,600 --> 00:14:58,160
that that webassembly modules can call

401
00:14:55,519 --> 00:15:00,399
to make some system api is called kind

402
00:14:58,160 --> 00:15:02,719
of it's just an operating system it's

403
00:15:00,399 --> 00:15:03,519
not it's let's say it's kind of like a

404
00:15:02,720 --> 00:15:07,040
posix

405
00:15:03,519 --> 00:15:09,440
way of doing okay so then

406
00:15:07,040 --> 00:15:12,240
the diagram becomes like that you have

407
00:15:09,440 --> 00:15:15,519
the non-browser or browser runtime

408
00:15:12,240 --> 00:15:18,959
that implements wazi and provide expose

409
00:15:15,519 --> 00:15:22,079
some sys system interface api that one

410
00:15:18,959 --> 00:15:25,599
modules can interact with

411
00:15:22,079 --> 00:15:28,560
i wanted to show you one tweet

412
00:15:25,600 --> 00:15:28,959
of uh solomon hacks which is the from

413
00:15:28,560 --> 00:15:32,079
the

414
00:15:28,959 --> 00:15:33,518
founder of uh docker that's that is

415
00:15:32,079 --> 00:15:35,758
saying that if wasn't

416
00:15:33,519 --> 00:15:37,199
was existing in 2008 we wouldn't have

417
00:15:35,759 --> 00:15:39,440
needed to create a docker

418
00:15:37,199 --> 00:15:40,399
that's how important it is it is

419
00:15:39,440 --> 00:15:42,800
webassembly

420
00:15:40,399 --> 00:15:44,000
on the server is the future of computing

421
00:15:42,800 --> 00:15:46,639
a standardized

422
00:15:44,000 --> 00:15:47,920
system interface was the missing link

423
00:15:46,639 --> 00:15:51,199
let's hope wazi

424
00:15:47,920 --> 00:15:53,439
is up to the task also folks from

425
00:15:51,199 --> 00:15:54,319
clever cloud a french company that is i

426
00:15:53,440 --> 00:15:57,600
think here

427
00:15:54,320 --> 00:16:00,079
maybe you have met them uh are running

428
00:15:57,600 --> 00:16:01,199
function as a service in web assembly

429
00:16:00,079 --> 00:16:03,920
directly

430
00:16:01,199 --> 00:16:04,959
on the hype advisor so no operating

431
00:16:03,920 --> 00:16:08,000
system between

432
00:16:04,959 --> 00:16:11,439
the the code and uh the

433
00:16:08,000 --> 00:16:13,040
the hardware okay

434
00:16:11,440 --> 00:16:14,560
webassembly wants to be secure by

435
00:16:13,040 --> 00:16:18,079
default

436
00:16:14,560 --> 00:16:21,758
nowadays when you code uh

437
00:16:18,079 --> 00:16:25,359
it's the the the result set of binaries

438
00:16:21,759 --> 00:16:30,480
is just 20 your that your code and 80

439
00:16:25,360 --> 00:16:32,720
dependencies that you haven't written um

440
00:16:30,480 --> 00:16:35,120
then what happened is that the way that

441
00:16:32,720 --> 00:16:36,000
we execute programs nowadays is just

442
00:16:35,120 --> 00:16:38,560
they execute

443
00:16:36,000 --> 00:16:39,680
within the ambient authority so me as an

444
00:16:38,560 --> 00:16:42,959
admin of my

445
00:16:39,680 --> 00:16:44,719
machine i'm going to uh ask my program

446
00:16:42,959 --> 00:16:48,160
to run and then i'm going to provide

447
00:16:44,720 --> 00:16:49,120
him my whole set of keys the permissions

448
00:16:48,160 --> 00:16:51,279
that he can

449
00:16:49,120 --> 00:16:52,959
so he can run maybe he doesn't need it

450
00:16:51,279 --> 00:16:54,480
but it's okay i just wrote the code so i

451
00:16:52,959 --> 00:16:56,800
know it does it will not

452
00:16:54,480 --> 00:16:57,759
do some malicious things the problem is

453
00:16:56,800 --> 00:17:01,120
that

454
00:16:57,759 --> 00:17:04,240
it also passed the whole set of keys to

455
00:17:01,120 --> 00:17:06,000
their its dependencies okay

456
00:17:04,240 --> 00:17:07,280
and sometimes you have a malicious

457
00:17:06,000 --> 00:17:09,760
dependency

458
00:17:07,280 --> 00:17:10,559
okay so that malicious dependency can

459
00:17:09,760 --> 00:17:12,640
then use

460
00:17:10,559 --> 00:17:13,760
all the rights that you provide to

461
00:17:12,640 --> 00:17:17,280
execute

462
00:17:13,760 --> 00:17:21,199
some malicious code webassembly wants to

463
00:17:17,280 --> 00:17:21,918
execute itself as uh uh capability-based

464
00:17:21,199 --> 00:17:24,480
systems

465
00:17:21,919 --> 00:17:26,240
so it means that i still have this whole

466
00:17:24,480 --> 00:17:28,960
set of keys but when i'm going to run

467
00:17:26,240 --> 00:17:30,320
the whole program i'm not going to pass

468
00:17:28,960 --> 00:17:31,919
all the permissions i'm just going to

469
00:17:30,320 --> 00:17:34,080
pass the permissions that i think my

470
00:17:31,919 --> 00:17:37,440
program needs to perform his task

471
00:17:34,080 --> 00:17:39,678
okay so uh i'm just passing here uh

472
00:17:37,440 --> 00:17:42,160
kind of one key and then this key is

473
00:17:39,679 --> 00:17:43,760
passed to all the other dependencies but

474
00:17:42,160 --> 00:17:45,440
this time the malicious code

475
00:17:43,760 --> 00:17:48,960
is quite blocked and cannot really

476
00:17:45,440 --> 00:17:48,960
perform the malicious task

477
00:17:49,200 --> 00:17:53,120
also one abstraction that the

478
00:17:51,200 --> 00:17:57,039
webassembly wants to provide

479
00:17:53,120 --> 00:18:00,000
is called nanoprocesses so the

480
00:17:57,039 --> 00:18:00,799
the idea here is to execute compelling

481
00:18:00,000 --> 00:18:04,000
modules

482
00:18:00,799 --> 00:18:07,120
wasn't modules in this in the same

483
00:18:04,000 --> 00:18:09,280
uh in the same process so

484
00:18:07,120 --> 00:18:11,039
kind of the result is kind of like that

485
00:18:09,280 --> 00:18:11,918
so you have the whole process which is

486
00:18:11,039 --> 00:18:14,320
like the big

487
00:18:11,919 --> 00:18:15,520
box blue box and then inside you will

488
00:18:14,320 --> 00:18:17,120
have like the first one is

489
00:18:15,520 --> 00:18:19,440
like your main module the one that you

490
00:18:17,120 --> 00:18:22,159
have written and uh

491
00:18:19,440 --> 00:18:24,240
uh it has dependencies to other models

492
00:18:22,160 --> 00:18:24,640
but they all run within kind of in the

493
00:18:24,240 --> 00:18:27,600
same

494
00:18:24,640 --> 00:18:28,799
box it way and they think that they are

495
00:18:27,600 --> 00:18:31,039
alone within the

496
00:18:28,799 --> 00:18:32,320
the memory space the process it's it's

497
00:18:31,039 --> 00:18:36,160
just a software

498
00:18:32,320 --> 00:18:36,159
fault implement uh the isolation

499
00:18:36,400 --> 00:18:41,679
so why uh was

500
00:18:39,760 --> 00:18:44,240
wants to be secure because first it

501
00:18:41,679 --> 00:18:47,280
provides capability-based systems

502
00:18:44,240 --> 00:18:47,919
also it's sandboxed by default okay so

503
00:18:47,280 --> 00:18:51,120
you can run

504
00:18:47,919 --> 00:18:56,160
low-level code in a secure way and also

505
00:18:51,120 --> 00:18:59,439
it nano processes provide a way to um

506
00:18:56,160 --> 00:19:00,480
to communicate between uh different

507
00:18:59,440 --> 00:19:03,919
modules

508
00:19:00,480 --> 00:19:07,120
a lot lot much faster than uh

509
00:19:03,919 --> 00:19:11,120
inter-process communication okay

510
00:19:07,120 --> 00:19:14,479
and the end result is kind of like that

511
00:19:11,120 --> 00:19:15,520
so you write your first uh you write

512
00:19:14,480 --> 00:19:18,320
your main module

513
00:19:15,520 --> 00:19:20,400
in for example russ and then you consume

514
00:19:18,320 --> 00:19:21,120
some dependencies that were originally

515
00:19:20,400 --> 00:19:24,320
written in

516
00:19:21,120 --> 00:19:26,559
other languages like c plus plus go

517
00:19:24,320 --> 00:19:28,799
and so on i mean there are a lot they're

518
00:19:26,559 --> 00:19:31,840
not only these languages huh

519
00:19:28,799 --> 00:19:35,280
um there are a lot of more but voila

520
00:19:31,840 --> 00:19:37,760
so projects

521
00:19:35,280 --> 00:19:39,678
i just took two examples there are a lot

522
00:19:37,760 --> 00:19:42,720
okay but you can check

523
00:19:39,679 --> 00:19:45,200
as you are all javascript developers uh

524
00:19:42,720 --> 00:19:46,160
i wanted to show you ascend script which

525
00:19:45,200 --> 00:19:48,799
is just

526
00:19:46,160 --> 00:19:50,880
it's a subset of typescript that does

527
00:19:48,799 --> 00:19:52,080
not compile to javascript or transpiled

528
00:19:50,880 --> 00:19:54,880
to javascript but

529
00:19:52,080 --> 00:19:55,520
compiles directly to was modules and web

530
00:19:54,880 --> 00:20:00,559
assemblies

531
00:19:55,520 --> 00:20:03,039
okay and because i'm a.net guy

532
00:20:00,559 --> 00:20:04,879
i wanted to show you i'm also the net

533
00:20:03,039 --> 00:20:08,158
guy

534
00:20:04,880 --> 00:20:08,640
i wanted to show you um that you can run

535
00:20:08,159 --> 00:20:11,760
now

536
00:20:08,640 --> 00:20:13,919
uh the clr so the

537
00:20:11,760 --> 00:20:15,200
dotnet with on the browser through

538
00:20:13,919 --> 00:20:17,600
webassembly

539
00:20:15,200 --> 00:20:18,799
and they provide now kind of a framework

540
00:20:17,600 --> 00:20:21,199
which is quite similar

541
00:20:18,799 --> 00:20:22,400
like angular to write front-end

542
00:20:21,200 --> 00:20:26,080
applications

543
00:20:22,400 --> 00:20:27,360
uh in seashore go check this link it's

544
00:20:26,080 --> 00:20:29,280
really interesting

545
00:20:27,360 --> 00:20:31,120
there are a lot of things and that guy

546
00:20:29,280 --> 00:20:34,960
ambasso

547
00:20:31,120 --> 00:20:38,399
i think he's italian and he's doing

548
00:20:34,960 --> 00:20:40,880
a c plus plus front-end library to write

549
00:20:38,400 --> 00:20:42,240
a front-end application that compiles

550
00:20:40,880 --> 00:20:45,280
two web assembly

551
00:20:42,240 --> 00:20:47,280
and it has also provide kind of like gs6

552
00:20:45,280 --> 00:20:50,240
syntax for c plus plus

553
00:20:47,280 --> 00:20:50,240
it's super interesting

554
00:20:50,559 --> 00:20:56,639
the bad code aliens

555
00:20:53,600 --> 00:20:59,678
so big companies reunited

556
00:20:56,640 --> 00:21:02,240
and try to push webassembly and secured

557
00:20:59,679 --> 00:21:04,400
by default web

558
00:21:02,240 --> 00:21:06,080
and they call themselves bad code aliens

559
00:21:04,400 --> 00:21:09,280
they are these are the four

560
00:21:06,080 --> 00:21:11,760
uh founders of the aliens and uh

561
00:21:09,280 --> 00:21:13,200
you see pretty big names and just to

562
00:21:11,760 --> 00:21:16,320
tell you fastly is running

563
00:21:13,200 --> 00:21:17,840
ten percent of the internet and i will

564
00:21:16,320 --> 00:21:20,559
end up my talk with

565
00:21:17,840 --> 00:21:21,280
uh one quote that i think it's can kind

566
00:21:20,559 --> 00:21:24,559
of

567
00:21:21,280 --> 00:21:26,639
resume what i feel about webassembly

568
00:21:24,559 --> 00:21:28,480
is that webassembly is the first fast

569
00:21:26,640 --> 00:21:30,880
multi-language retargetable

570
00:21:28,480 --> 00:21:32,159
and safe intermediate representation

571
00:21:30,880 --> 00:21:34,559
that we have

572
00:21:32,159 --> 00:21:36,159
that we have ever agreed upon as a

573
00:21:34,559 --> 00:21:45,840
community

574
00:21:36,159 --> 00:21:45,840
cto office voila thank you

575
00:21:47,200 --> 00:21:52,880
okay any questions

576
00:21:50,400 --> 00:21:53,600
uh i have a question about not just so

577
00:21:52,880 --> 00:21:56,000
in node.js

578
00:21:53,600 --> 00:21:58,399
you can run uh native sql sql yes of

579
00:21:56,000 --> 00:22:01,679
course and you can run

580
00:21:58,400 --> 00:22:04,240
what do you think is better uh

581
00:22:01,679 --> 00:22:06,559
to run a node.js vasim or simpleplus and

582
00:22:04,240 --> 00:22:08,640
why

583
00:22:06,559 --> 00:22:09,678
it's a question that a lot of folks are

584
00:22:08,640 --> 00:22:12,480
asking um

585
00:22:09,679 --> 00:22:13,520
to be honest i think that uh for now

586
00:22:12,480 --> 00:22:16,000
it's c plus plus

587
00:22:13,520 --> 00:22:17,200
that will continue to be like the major

588
00:22:16,000 --> 00:22:19,200
solution to uh

589
00:22:17,200 --> 00:22:20,720
to provide native performance within

590
00:22:19,200 --> 00:22:22,320
node modules but

591
00:22:20,720 --> 00:22:24,080
at the end it will switch to web

592
00:22:22,320 --> 00:22:25,520
assembly modules uh because

593
00:22:24,080 --> 00:22:27,678
i don't know in my humble opinion i

594
00:22:25,520 --> 00:22:32,000
think it's kind of like the future

595
00:22:27,679 --> 00:22:35,440
of the industry or in this perspective

596
00:22:32,000 --> 00:22:37,840
um but they all both fix

597
00:22:35,440 --> 00:22:38,960
solves your issues which is giving you

598
00:22:37,840 --> 00:22:42,000
performance

599
00:22:38,960 --> 00:22:44,080
and so on hi

600
00:22:42,000 --> 00:22:46,640
um webassembly is a fairly young

601
00:22:44,080 --> 00:22:46,639
language

602
00:22:46,720 --> 00:22:52,400
do you have an overview of the tools and

603
00:22:50,080 --> 00:22:54,240
debugging tools around it because as

604
00:22:52,400 --> 00:22:55,440
it's a binary format

605
00:22:54,240 --> 00:22:58,960
i guess it's a little bit harder to

606
00:22:55,440 --> 00:23:01,679
debug than let's say vanilla javascript

607
00:22:58,960 --> 00:23:02,400
yes okay so uh there are already i think

608
00:23:01,679 --> 00:23:05,679
some

609
00:23:02,400 --> 00:23:08,880
browsers that provide uh debugging tools

610
00:23:05,679 --> 00:23:12,000
uh to work with webassembly modules

611
00:23:08,880 --> 00:23:13,440
uh you have i think within mods uh

612
00:23:12,000 --> 00:23:15,679
mozilla firefox

613
00:23:13,440 --> 00:23:16,799
you can already kind of work with it and

614
00:23:15,679 --> 00:23:19,120
and

615
00:23:16,799 --> 00:23:20,080
the thing is that i didn't mention and

616
00:23:19,120 --> 00:23:22,799
you're right

617
00:23:20,080 --> 00:23:23,840
webassembly has two representation it

618
00:23:22,799 --> 00:23:26,720
has the one that

619
00:23:23,840 --> 00:23:28,720
uh browsers use to uh to execute it

620
00:23:26,720 --> 00:23:30,080
which is the binary format because it's

621
00:23:28,720 --> 00:23:32,320
load efficient and so on

622
00:23:30,080 --> 00:23:33,678
but for human readable it's it's not the

623
00:23:32,320 --> 00:23:36,399
most human readable

624
00:23:33,679 --> 00:23:37,600
format so they also have a text uh

625
00:23:36,400 --> 00:23:41,360
representation which is

626
00:23:37,600 --> 00:23:44,639
webassembly uh text i think what

627
00:23:41,360 --> 00:23:46,799
or something it's called what um

628
00:23:44,640 --> 00:23:47,679
and then you can really clearly see that

629
00:23:46,799 --> 00:23:51,440
it's low level

630
00:23:47,679 --> 00:23:54,320
kind of like an assembly code

631
00:23:51,440 --> 00:23:54,880
uh i have a question about the micro

632
00:23:54,320 --> 00:23:58,000
front end

633
00:23:54,880 --> 00:23:59,840
and how assembly will do in in this in

634
00:23:58,000 --> 00:24:02,080
this architecture

635
00:23:59,840 --> 00:24:04,000
assembly yeah web assembly what we're

636
00:24:02,080 --> 00:24:05,760
saying we're doing which architecture in

637
00:24:04,000 --> 00:24:09,200
the micro front end

638
00:24:05,760 --> 00:24:12,320
the micro front architecture okay

639
00:24:09,200 --> 00:24:15,600
um webassembly

640
00:24:12,320 --> 00:24:16,879
are quite i mean it's composed of

641
00:24:15,600 --> 00:24:20,639
several modules

642
00:24:16,880 --> 00:24:22,640
so if your concern is to say uh

643
00:24:20,640 --> 00:24:24,880
do i have to download the whole module

644
00:24:22,640 --> 00:24:27,039
big big big module to execute it

645
00:24:24,880 --> 00:24:28,880
no you can kind of split it and and in

646
00:24:27,039 --> 00:24:33,840
the in the future you will able to

647
00:24:28,880 --> 00:24:33,840
you will be able to lazy load it so

648
00:24:34,880 --> 00:24:38,320
yeah i think you can already do that now

649
00:24:36,960 --> 00:24:38,880
to be honest because at the end as you

650
00:24:38,320 --> 00:24:40,799
see

651
00:24:38,880 --> 00:24:42,720
as you saw i mean you're just fetching a

652
00:24:40,799 --> 00:24:44,840
resource on the internet and then

653
00:24:42,720 --> 00:24:47,840
you can fetch it whenever you want if

654
00:24:44,840 --> 00:24:47,840
it's

655
00:24:53,600 --> 00:24:57,600
yes i will say yes yes there is no

656
00:24:56,080 --> 00:24:59,120
really they're not competing i mean if

657
00:24:57,600 --> 00:25:00,480
they are loaded into your browser you

658
00:24:59,120 --> 00:25:02,479
can run it

659
00:25:00,480 --> 00:25:03,520
on both sides but maybe you will

660
00:25:02,480 --> 00:25:06,480
struggle a bit to

661
00:25:03,520 --> 00:25:07,200
make them work together but i think it's

662
00:25:06,480 --> 00:25:11,679
completely

663
00:25:07,200 --> 00:25:15,120
feasible of course okay is web assembly

664
00:25:11,679 --> 00:25:18,000
about to access to the gpu okay

665
00:25:15,120 --> 00:25:18,719
so uh this talk that i've done it's

666
00:25:18,000 --> 00:25:21,200
normally

667
00:25:18,720 --> 00:25:22,320
much much larger and i'm covered other

668
00:25:21,200 --> 00:25:25,039
topics

669
00:25:22,320 --> 00:25:26,879
uh one thing that so your question is uh

670
00:25:25,039 --> 00:25:30,240
is it possible to call

671
00:25:26,880 --> 00:25:32,400
some gpu apis from the webassembly

672
00:25:30,240 --> 00:25:33,520
uh right now no because the only thing

673
00:25:32,400 --> 00:25:36,400
that provides uh

674
00:25:33,520 --> 00:25:37,679
that uh that is standardized is wazi

675
00:25:36,400 --> 00:25:40,799
which is kind of like a

676
00:25:37,679 --> 00:25:44,000
system interface to call some uh

677
00:25:40,799 --> 00:25:45,039
the os apis the thing is that uh wazi

678
00:25:44,000 --> 00:25:48,000
wants to extend

679
00:25:45,039 --> 00:25:50,080
itself and so you in the future uh you

680
00:25:48,000 --> 00:25:53,279
would be able to call some specific

681
00:25:50,080 --> 00:25:56,480
domain specific uh low-level apis

682
00:25:53,279 --> 00:25:58,799
can for example gpus okay or you will

683
00:25:56,480 --> 00:26:01,440
be able to call i i don't know something

684
00:25:58,799 --> 00:26:03,440
related to blockchain or whatever so

685
00:26:01,440 --> 00:26:04,799
go check wazi go check out the internet

686
00:26:03,440 --> 00:26:06,400
what it's really they're

687
00:26:04,799 --> 00:26:08,879
they really want to extend themselves

688
00:26:06,400 --> 00:26:11,200
and and they're open to feedback from

689
00:26:08,880 --> 00:26:12,810
the community

690
00:26:11,200 --> 00:26:20,720
thank you so much thank you

691
00:26:12,810 --> 00:26:22,639
[Applause]

692
00:26:20,720 --> 00:26:24,880
he might be available just outside for

693
00:26:22,640 --> 00:26:32,799
questions yes

694
00:26:24,880 --> 00:26:32,799
the exit

