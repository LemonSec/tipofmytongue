1
00:00:10,880 --> 00:00:14,080
uh

2
00:00:11,280 --> 00:00:15,838
good morning everyone and i hope you

3
00:00:14,080 --> 00:00:18,400
have enough time to wake up during the

4
00:00:15,839 --> 00:00:21,760
previous talk

5
00:00:18,400 --> 00:00:25,598
and thank you fabian for waking you up

6
00:00:21,760 --> 00:00:28,800
i'm going oh well first who am i

7
00:00:25,599 --> 00:00:29,599
and i have to make two disclosures here

8
00:00:28,800 --> 00:00:32,160
first

9
00:00:29,599 --> 00:00:34,160
i am the wrong person in the wrong place

10
00:00:32,159 --> 00:00:36,000
i am not a software guy

11
00:00:34,160 --> 00:00:37,440
and the second one the initially this

12
00:00:36,000 --> 00:00:41,120
talk was submitted for

13
00:00:37,440 --> 00:00:43,199
the debugging tools uh devil def rooms

14
00:00:41,120 --> 00:00:44,399
but then for whatever reason relocated

15
00:00:43,200 --> 00:00:46,800
here so i am

16
00:00:44,399 --> 00:00:49,120
not really sure how relevant it will be

17
00:00:46,800 --> 00:00:49,120
for you

18
00:00:49,200 --> 00:00:52,719
and what i'm doing for living instead of

19
00:00:51,600 --> 00:00:54,480
software development

20
00:00:52,719 --> 00:00:55,760
i am designing hardware embedded

21
00:00:54,480 --> 00:00:58,000
hardware and

22
00:00:55,760 --> 00:00:59,519
using software to bring up this hardware

23
00:00:58,000 --> 00:01:02,640
to make it run

24
00:00:59,520 --> 00:01:06,080
but since for the last five ten years

25
00:01:02,640 --> 00:01:08,000
most of workers concentrated on the fpga

26
00:01:06,080 --> 00:01:09,920
systems

27
00:01:08,000 --> 00:01:12,560
the problem is not only how to bring

28
00:01:09,920 --> 00:01:14,240
this software running but how to bring

29
00:01:12,560 --> 00:01:15,920
all the hardware platform for this

30
00:01:14,240 --> 00:01:19,280
software up and running

31
00:01:15,920 --> 00:01:20,400
including the soft core or integrated

32
00:01:19,280 --> 00:01:24,240
hardcore

33
00:01:20,400 --> 00:01:27,360
cpu processors so

34
00:01:24,240 --> 00:01:29,919
today i'm going to talk uh just

35
00:01:27,360 --> 00:01:30,560
make a short overview how it's possible

36
00:01:29,920 --> 00:01:33,920
to debug

37
00:01:30,560 --> 00:01:34,720
not software but to do a hardware

38
00:01:33,920 --> 00:01:36,640
debugging

39
00:01:34,720 --> 00:01:37,840
but to do it with a free and open

40
00:01:36,640 --> 00:01:40,880
software and

41
00:01:37,840 --> 00:01:42,159
fortunately enough it's uh possible all

42
00:01:40,880 --> 00:01:45,039
the pieces are here

43
00:01:42,159 --> 00:01:45,040
and i can just

44
00:01:46,640 --> 00:01:50,799
say summarize the entire presentation in

45
00:01:50,000 --> 00:01:53,280
one word

46
00:01:50,799 --> 00:01:54,159
all the free software all the pieces are

47
00:01:53,280 --> 00:01:57,119
here but

48
00:01:54,159 --> 00:01:58,079
integration between them is really

49
00:01:57,119 --> 00:02:00,640
missing

50
00:01:58,079 --> 00:02:01,439
so you have to assemble puzzle from

51
00:02:00,640 --> 00:02:04,159
different

52
00:02:01,439 --> 00:02:05,279
pieces together just to make anything

53
00:02:04,159 --> 00:02:08,000
running

54
00:02:05,280 --> 00:02:08,318
and how many of you in this audience

55
00:02:08,000 --> 00:02:13,200
know

56
00:02:08,318 --> 00:02:13,200
what the fpga is or have used fpga

57
00:02:13,840 --> 00:02:19,599
wow okay then perhaps you know

58
00:02:17,680 --> 00:02:20,640
everything i'm going to tell next and

59
00:02:19,599 --> 00:02:22,640
even

60
00:02:20,640 --> 00:02:24,079
quite possible that you know it much

61
00:02:22,640 --> 00:02:26,319
more than i do

62
00:02:24,080 --> 00:02:27,680
nevertheless a few words why i think

63
00:02:26,319 --> 00:02:31,040
that software

64
00:02:27,680 --> 00:02:34,840
developers should care about the fpgas

65
00:02:31,040 --> 00:02:38,000
because and those are of course

66
00:02:34,840 --> 00:02:41,360
some pretty hard statements which

67
00:02:38,000 --> 00:02:43,360
are not true 100 percent true but

68
00:02:41,360 --> 00:02:45,360
all the for the last 10 years all the

69
00:02:43,360 --> 00:02:46,480
modern architecture cpu architectures

70
00:02:45,360 --> 00:02:49,280
are pretty much stuck

71
00:02:46,480 --> 00:02:50,000
in their development and to get any

72
00:02:49,280 --> 00:02:52,640
performance you

73
00:02:50,000 --> 00:02:53,440
have to go to non-standard architectures

74
00:02:52,640 --> 00:02:55,518
or to

75
00:02:53,440 --> 00:02:58,560
custom hardware accelerators or to

76
00:02:55,519 --> 00:03:03,120
reconfigurable hardware to accelerate it

77
00:02:58,560 --> 00:03:06,319
and uh for the last 30 years

78
00:03:03,120 --> 00:03:08,800
40 years already all the

79
00:03:06,319 --> 00:03:10,079
hardware development is based on two

80
00:03:08,800 --> 00:03:14,720
languages

81
00:03:10,080 --> 00:03:17,920
both of them are say niche languages

82
00:03:14,720 --> 00:03:19,920
vhdl and verilog and the preferable one

83
00:03:17,920 --> 00:03:20,159
depends on what side of atlantics you

84
00:03:19,920 --> 00:03:23,920
are

85
00:03:20,159 --> 00:03:25,679
at uh well there are some variations so

86
00:03:23,920 --> 00:03:27,200
there are people in the states who know

87
00:03:25,680 --> 00:03:29,680
with

88
00:03:27,200 --> 00:03:30,798
vhdl there are people in europe who

89
00:03:29,680 --> 00:03:32,720
write some verilog

90
00:03:30,799 --> 00:03:34,480
but generally yeah depending on what

91
00:03:32,720 --> 00:03:36,560
side of atlantic you are

92
00:03:34,480 --> 00:03:37,760
is you're choosing one or the other

93
00:03:36,560 --> 00:03:40,640
language but

94
00:03:37,760 --> 00:03:42,079
unfortunately compared to the software

95
00:03:40,640 --> 00:03:45,440
progress what we saw

96
00:03:42,080 --> 00:03:46,080
through the last 20 years those two

97
00:03:45,440 --> 00:03:49,200
languages

98
00:03:46,080 --> 00:03:51,120
are still very very old despite the new

99
00:03:49,200 --> 00:03:54,399
standards verilog 2008

100
00:03:51,120 --> 00:03:57,840
vhdl 2011

101
00:03:54,400 --> 00:04:00,480
and the common one 2020

102
00:03:57,840 --> 00:04:00,959
those technologies are pretty much

103
00:04:00,480 --> 00:04:04,159
lacking

104
00:04:00,959 --> 00:04:05,599
behind and the industry itself is very

105
00:04:04,159 --> 00:04:09,040
conservative about

106
00:04:05,599 --> 00:04:12,720
taking any new approaches

107
00:04:09,040 --> 00:04:13,519
so while why this is needed for software

108
00:04:12,720 --> 00:04:16,560
developers

109
00:04:13,519 --> 00:04:19,759
because you we have to make run

110
00:04:16,560 --> 00:04:21,120
our software on fl available changeable

111
00:04:19,759 --> 00:04:24,000
programmable

112
00:04:21,120 --> 00:04:24,800
and heterogeneous architectures and

113
00:04:24,000 --> 00:04:28,000
because the

114
00:04:24,800 --> 00:04:30,800
industry needs some kick from

115
00:04:28,000 --> 00:04:32,400
outside to move forward otherwise they

116
00:04:30,800 --> 00:04:35,840
will stay there with their

117
00:04:32,400 --> 00:04:35,840
absolute tools forever

118
00:04:36,080 --> 00:04:42,080
as i said their free software is

119
00:04:39,120 --> 00:04:42,560
available and very actively developed

120
00:04:42,080 --> 00:04:46,719
for

121
00:04:42,560 --> 00:04:50,080
the under active development for the uh

122
00:04:46,720 --> 00:04:53,759
uh so for the

123
00:04:50,080 --> 00:04:56,639
rtl designers and both uh vhdl

124
00:04:53,759 --> 00:04:57,360
and verilog are supported um i'm not

125
00:04:56,639 --> 00:04:59,759
that much

126
00:04:57,360 --> 00:05:00,560
in the verilog hdl so we'll talk

127
00:04:59,759 --> 00:05:04,160
afterwards

128
00:05:00,560 --> 00:05:06,400
on about their vhdl but nevertheless

129
00:05:04,160 --> 00:05:07,039
very later a carrots very logs are

130
00:05:06,400 --> 00:05:10,000
excellent

131
00:05:07,039 --> 00:05:11,280
fast simulators compiler to from verilog

132
00:05:10,000 --> 00:05:15,199
to cc plus plus

133
00:05:11,280 --> 00:05:18,719
or just an interpreting simulator

134
00:05:15,199 --> 00:05:20,000
and uses is an excellent system which

135
00:05:18,720 --> 00:05:23,039
provides the full

136
00:05:20,000 --> 00:05:23,919
path from the verilog description rtl

137
00:05:23,039 --> 00:05:26,560
description

138
00:05:23,919 --> 00:05:28,400
down to the hardware unfortunately only

139
00:05:26,560 --> 00:05:30,080
for the supported hardware architectures

140
00:05:28,400 --> 00:05:32,000
but it's going to be

141
00:05:30,080 --> 00:05:34,560
extended and it's under active

142
00:05:32,000 --> 00:05:37,199
development so everything is good here

143
00:05:34,560 --> 00:05:38,080
but and it's much more convenient for

144
00:05:37,199 --> 00:05:40,160
software people

145
00:05:38,080 --> 00:05:41,599
and for hardware people as well before

146
00:05:40,160 --> 00:05:44,400
you go to their

147
00:05:41,600 --> 00:05:44,800
hardware you have to simulate it first

148
00:05:44,400 --> 00:05:47,440
and

149
00:05:44,800 --> 00:05:48,320
if you can catch half of your errors in

150
00:05:47,440 --> 00:05:50,960
simulation

151
00:05:48,320 --> 00:05:52,479
that's good if you can catch 90 percent

152
00:05:50,960 --> 00:05:53,919
of your errors in simulation

153
00:05:52,479 --> 00:05:55,758
that's even better because you have

154
00:05:53,919 --> 00:05:58,479
another 90 percent related to the

155
00:05:55,759 --> 00:06:01,840
hardware platforms

156
00:05:58,479 --> 00:06:03,680
so better to separate them and for vhdl

157
00:06:01,840 --> 00:06:06,960
simulation there is a nice

158
00:06:03,680 --> 00:06:10,160
compiler it's a part of the

159
00:06:06,960 --> 00:06:12,080
new compiler suite it's an uh ghdl

160
00:06:10,160 --> 00:06:13,440
and it's written on the niche language

161
00:06:12,080 --> 00:06:15,199
on ada

162
00:06:13,440 --> 00:06:16,560
so there is actually not only embedded

163
00:06:15,199 --> 00:06:18,960
software but and

164
00:06:16,560 --> 00:06:20,000
quite conventional pc software written

165
00:06:18,960 --> 00:06:21,840
on other

166
00:06:20,000 --> 00:06:24,080
which is a bit surprising and making it

167
00:06:21,840 --> 00:06:26,400
a bit more difficult to read

168
00:06:24,080 --> 00:06:27,359
and there is a nice gui front-end to

169
00:06:26,400 --> 00:06:30,638
look because the

170
00:06:27,360 --> 00:06:32,319
hardware people are not

171
00:06:30,639 --> 00:06:34,720
speaking the same language as software

172
00:06:32,319 --> 00:06:37,759
so we do not compile anything we

173
00:06:34,720 --> 00:06:40,880
synthesize and place and wrote it

174
00:06:37,759 --> 00:06:44,000
and we are not running printf debugging

175
00:06:40,880 --> 00:06:46,319
we are looking to the blinking leds i

176
00:06:44,000 --> 00:06:48,400
hope they are still blinking

177
00:06:46,319 --> 00:06:49,840
yes i'm not sure how visible it is but

178
00:06:48,400 --> 00:06:51,599
we will come later to it

179
00:06:49,840 --> 00:06:54,799
that's a quite common way to debug

180
00:06:51,599 --> 00:06:57,599
hardware it's just blinking

181
00:06:54,800 --> 00:06:59,280
uh but uh of course there is a gui

182
00:06:57,599 --> 00:07:02,560
front-end to look on the traces

183
00:06:59,280 --> 00:07:04,638
and it's uh much

184
00:07:02,560 --> 00:07:07,599
more pleasant to the eyes than the

185
00:07:04,639 --> 00:07:09,520
blinking leds afterwards

186
00:07:07,599 --> 00:07:12,319
since we are going first to simulate

187
00:07:09,520 --> 00:07:15,680
this is a very small snippet of the code

188
00:07:12,319 --> 00:07:19,280
i'm going to debug and simulate it's a

189
00:07:15,680 --> 00:07:22,080
simple generator

190
00:07:19,280 --> 00:07:22,719
data pattern generator to run tests

191
00:07:22,080 --> 00:07:25,280
against

192
00:07:22,720 --> 00:07:26,479
and to test it and it supports two modes

193
00:07:25,280 --> 00:07:29,520
in one it's a

194
00:07:26,479 --> 00:07:30,080
simple binary counter and in the more

195
00:07:29,520 --> 00:07:32,000
advanced

196
00:07:30,080 --> 00:07:33,520
mode it's a linear feedback shift

197
00:07:32,000 --> 00:07:35,759
register

198
00:07:33,520 --> 00:07:36,719
and as you see the code itself is just

199
00:07:35,759 --> 00:07:40,479
uh eight

200
00:07:36,720 --> 00:07:43,759
ten lines uh with all the

201
00:07:40,479 --> 00:07:44,000
boilerplate code around it and vhdl is

202
00:07:43,759 --> 00:07:47,039
quite

203
00:07:44,000 --> 00:07:48,160
verbose language it's around 45-50 lines

204
00:07:47,039 --> 00:07:51,199
in the file

205
00:07:48,160 --> 00:07:55,840
but the same file can be simulated run

206
00:07:51,199 --> 00:07:58,479
on the ghd and traces can be viewed

207
00:07:55,840 --> 00:07:59,359
in gui and the physically the very same

208
00:07:58,479 --> 00:08:02,878
file can be

209
00:07:59,360 --> 00:08:05,520
later on combine compile synthesized

210
00:08:02,879 --> 00:08:06,960
and placed in the road for fpga and then

211
00:08:05,520 --> 00:08:11,120
we can debug it on the

212
00:08:06,960 --> 00:08:12,400
hardware that's a nice and not quite

213
00:08:11,120 --> 00:08:16,240
readable screenshot

214
00:08:12,400 --> 00:08:19,280
and now i will try to switch to the

215
00:08:16,240 --> 00:08:19,280
oh okay it's here

216
00:08:20,479 --> 00:08:27,840
so we are going to la demo

217
00:08:29,360 --> 00:08:31,759
oops

218
00:08:34,320 --> 00:08:40,719
as you see as they are straight oh yeah

219
00:08:36,399 --> 00:08:44,240
it's even better than a pdf just run

220
00:08:40,719 --> 00:08:44,800
ghdl several times to synthesize several

221
00:08:44,240 --> 00:08:47,040
blocks

222
00:08:44,800 --> 00:08:47,839
and run a simulation for a while and now

223
00:08:47,040 --> 00:08:52,399
if you start

224
00:08:47,839 --> 00:08:55,040
make without magic okay

225
00:08:52,399 --> 00:08:56,080
oh it's here exactly what you saw on

226
00:08:55,040 --> 00:09:00,319
this screenshot

227
00:08:56,080 --> 00:09:03,839
and we can see two separate oops

228
00:09:00,320 --> 00:09:07,440
if i can scroll it now

229
00:09:03,839 --> 00:09:10,399
uh-huh i can aha

230
00:09:07,440 --> 00:09:10,720
we see those two different running modes

231
00:09:10,399 --> 00:09:13,760
the

232
00:09:10,720 --> 00:09:16,080
binary count one and the

233
00:09:13,760 --> 00:09:16,800
linear feedback shift register you see

234
00:09:16,080 --> 00:09:19,839
the one

235
00:09:16,800 --> 00:09:22,880
is walking through the register here

236
00:09:19,839 --> 00:09:23,839
and zero all bit zeros is a possible

237
00:09:22,880 --> 00:09:26,399
state for the

238
00:09:23,839 --> 00:09:29,519
binary counter of course and it's a dead

239
00:09:26,399 --> 00:09:29,519
state for the

240
00:09:29,680 --> 00:09:34,839
linear feedback shift register so if you

241
00:09:32,080 --> 00:09:38,640
move to that one

242
00:09:34,839 --> 00:09:41,680
uh for the software developers i think

243
00:09:38,640 --> 00:09:42,399
all the work is done here we have a code

244
00:09:41,680 --> 00:09:44,319
we can

245
00:09:42,399 --> 00:09:45,600
compile it we can run the simulation we

246
00:09:44,320 --> 00:09:48,800
can get a picture

247
00:09:45,600 --> 00:09:51,839
it's working we are done not quite

248
00:09:48,800 --> 00:09:51,839
true for the hardware

249
00:09:53,279 --> 00:10:00,640
so oops sorry for that

250
00:09:57,200 --> 00:10:00,640
so we have to go

251
00:10:01,519 --> 00:10:07,839
for the uh down

252
00:10:04,560 --> 00:10:11,279
to the real hardware and at this place

253
00:10:07,839 --> 00:10:13,519
we are completely uh

254
00:10:11,279 --> 00:10:14,880
we have completely to surrender to the

255
00:10:13,519 --> 00:10:18,880
vendor tools

256
00:10:14,880 --> 00:10:22,640
because except for the uses and uh

257
00:10:18,880 --> 00:10:24,560
latest and some low-end xilinx platform

258
00:10:22,640 --> 00:10:25,920
there is no way to place and road and to

259
00:10:24,560 --> 00:10:30,399
generate a bit stream

260
00:10:25,920 --> 00:10:32,479
for the uh real hardware for the real

261
00:10:30,399 --> 00:10:34,880
fpga

262
00:10:32,480 --> 00:10:36,000
i really hope that sometime soon it will

263
00:10:34,880 --> 00:10:39,920
change for

264
00:10:36,000 --> 00:10:42,320
at least for some altera intel fpgas

265
00:10:39,920 --> 00:10:44,560
if someone of you will contribute to

266
00:10:42,320 --> 00:10:44,560
that

267
00:10:44,839 --> 00:10:49,760
uh and for the on-chip on

268
00:10:47,600 --> 00:10:51,440
hardware debugging there are tools uh

269
00:10:49,760 --> 00:10:54,000
from all the vendors

270
00:10:51,440 --> 00:10:54,800
ulterior has a signal tab xilinx chip

271
00:10:54,000 --> 00:10:57,600
scope

272
00:10:54,800 --> 00:10:57,920
synopsis has identity rtl debugger which

273
00:10:57,600 --> 00:11:01,279
is

274
00:10:57,920 --> 00:11:04,079
running on i think all the fpga families

275
00:11:01,279 --> 00:11:06,720
supported by synapses

276
00:11:04,079 --> 00:11:08,079
micro semi microchip have their own

277
00:11:06,720 --> 00:11:11,600
smart debug features

278
00:11:08,079 --> 00:11:15,040
so you actually can look inside the

279
00:11:11,600 --> 00:11:17,760
uh running hardware running fpga chip

280
00:11:15,040 --> 00:11:18,480
and get the same traces to look for the

281
00:11:17,760 --> 00:11:21,839
signals

282
00:11:18,480 --> 00:11:22,959
and in some advanced cases like the

283
00:11:21,839 --> 00:11:25,920
smart debuggies

284
00:11:22,959 --> 00:11:27,359
you can even try in to toggle some

285
00:11:25,920 --> 00:11:29,120
signals or to

286
00:11:27,360 --> 00:11:31,519
trickle some signals in the running

287
00:11:29,120 --> 00:11:32,800
system and see how your hardware reacts

288
00:11:31,519 --> 00:11:35,920
on this

289
00:11:32,800 --> 00:11:38,560
uh what is the problem with those tools

290
00:11:35,920 --> 00:11:41,279
i think that stated in their

291
00:11:38,560 --> 00:11:42,800
very first line their proprietary and

292
00:11:41,279 --> 00:11:46,480
their vendor specific

293
00:11:42,800 --> 00:11:48,640
so if by some crazy decision of hardware

294
00:11:46,480 --> 00:11:51,360
designer you have two different fpgas

295
00:11:48,640 --> 00:11:53,439
from different vendors on the same board

296
00:11:51,360 --> 00:11:55,760
you basically have to have two

297
00:11:53,440 --> 00:11:58,480
completely different parallel setups of

298
00:11:55,760 --> 00:12:00,480
all the development and debugging tools

299
00:11:58,480 --> 00:12:02,639
somehow magically if you're lucky enough

300
00:12:00,480 --> 00:12:07,360
connected to the same hardware

301
00:12:02,639 --> 00:12:09,360
and hopefully used in parallel

302
00:12:07,360 --> 00:12:10,480
haven't ever seen walking it in practice

303
00:12:09,360 --> 00:12:12,480
unfortunately

304
00:12:10,480 --> 00:12:13,680
even if you have to debug several two

305
00:12:12,480 --> 00:12:16,000
separate pieces in

306
00:12:13,680 --> 00:12:17,279
inside the same fpga it's already a

307
00:12:16,000 --> 00:12:19,680
challenge and with the

308
00:12:17,279 --> 00:12:21,040
vendor tools if you have two different

309
00:12:19,680 --> 00:12:23,040
vendors

310
00:12:21,040 --> 00:12:24,800
and of course support engineers and

311
00:12:23,040 --> 00:12:25,279
field application engineers will just

312
00:12:24,800 --> 00:12:28,240
ask you

313
00:12:25,279 --> 00:12:28,959
ah you are using the different fpga

314
00:12:28,240 --> 00:12:32,240
sorry

315
00:12:28,959 --> 00:12:32,560
we can't help you and that's a problem

316
00:12:32,240 --> 00:12:34,480
and

317
00:12:32,560 --> 00:12:35,599
of course especially if you are not

318
00:12:34,480 --> 00:12:38,399
working in the

319
00:12:35,600 --> 00:12:39,760
university or industrial environment

320
00:12:38,399 --> 00:12:42,959
there is a

321
00:12:39,760 --> 00:12:46,959
cost for the licenses and sometimes

322
00:12:42,959 --> 00:12:49,599
it's acceptable and quite reasonable

323
00:12:46,959 --> 00:12:50,239
sometimes they are charging a premium

324
00:12:49,600 --> 00:12:54,560
amount

325
00:12:50,240 --> 00:12:54,560
for basically non-working tools

326
00:12:54,639 --> 00:12:58,320
but fortunately but we can learn from

327
00:12:56,320 --> 00:13:02,480
them we can look at them

328
00:12:58,320 --> 00:13:04,639
and maybe do some somewhat better job

329
00:13:02,480 --> 00:13:06,079
and what we can learn from those tools

330
00:13:04,639 --> 00:13:09,040
is their

331
00:13:06,079 --> 00:13:10,160
less common denominator how to connect

332
00:13:09,040 --> 00:13:12,240
to the hardware

333
00:13:10,160 --> 00:13:14,000
all those tools are token to the

334
00:13:12,240 --> 00:13:17,200
hardware through the

335
00:13:14,000 --> 00:13:19,120
ieee 1149.1 it's

336
00:13:17,200 --> 00:13:20,320
also i think learned something over

337
00:13:19,120 --> 00:13:23,279
so-called jtech

338
00:13:20,320 --> 00:13:23,839
standard it's simple four-wire interface

339
00:13:23,279 --> 00:13:26,240
to

340
00:13:23,839 --> 00:13:27,920
talk to initially it's been intended for

341
00:13:26,240 --> 00:13:29,760
the hardware testing for the

342
00:13:27,920 --> 00:13:30,399
interconnectivity on the board testing

343
00:13:29,760 --> 00:13:33,680
but now

344
00:13:30,399 --> 00:13:36,000
it's overused for the cpu cores

345
00:13:33,680 --> 00:13:38,319
debugging for microcontroller debugging

346
00:13:36,000 --> 00:13:40,240
for flash and programmable logic

347
00:13:38,320 --> 00:13:41,279
interface and programming configuring

348
00:13:40,240 --> 00:13:43,680
debugging it

349
00:13:41,279 --> 00:13:44,959
so it's uh i would say that it's most

350
00:13:43,680 --> 00:13:47,680
widely used and

351
00:13:44,959 --> 00:13:48,959
the least common denominator for all the

352
00:13:47,680 --> 00:13:51,199
interfaces

353
00:13:48,959 --> 00:13:53,040
and there is a software support there

354
00:13:51,199 --> 00:13:54,959
are two

355
00:13:53,040 --> 00:13:57,519
somewhat different somewhat separate

356
00:13:54,959 --> 00:14:00,800
some would competing projects

357
00:13:57,519 --> 00:14:01,600
to talk to different interfaces hardware

358
00:14:00,800 --> 00:14:03,680
debuggers

359
00:14:01,600 --> 00:14:06,399
so besides the software running on the

360
00:14:03,680 --> 00:14:09,120
host system to

361
00:14:06,399 --> 00:14:11,279
talk to the hardware you need some

362
00:14:09,120 --> 00:14:13,440
converter from the

363
00:14:11,279 --> 00:14:15,760
whatever interface you have on your

364
00:14:13,440 --> 00:14:18,800
development station it's usually it's

365
00:14:15,760 --> 00:14:19,920
nowadays it's either usb or there are

366
00:14:18,800 --> 00:14:23,120
some converters of

367
00:14:19,920 --> 00:14:25,839
based on the networking uh

368
00:14:23,120 --> 00:14:27,839
ethernet connections uh but you need

369
00:14:25,839 --> 00:14:28,480
some converter to talk to the hardware

370
00:14:27,839 --> 00:14:31,920
so

371
00:14:28,480 --> 00:14:34,560
usb to jtech converter

372
00:14:31,920 --> 00:14:36,560
and some of them are integrated in the

373
00:14:34,560 --> 00:14:38,959
development board some of them are

374
00:14:36,560 --> 00:14:40,079
even integrated into the final products

375
00:14:38,959 --> 00:14:42,800
and the

376
00:14:40,079 --> 00:14:44,079
embedded systems or sometimes it's just

377
00:14:42,800 --> 00:14:47,279
a small external

378
00:14:44,079 --> 00:14:50,479
boxes and uh both you are jtech

379
00:14:47,279 --> 00:14:53,360
and openocd provide support for

380
00:14:50,480 --> 00:14:53,839
i don't know something like around 50

381
00:14:53,360 --> 00:14:56,160
100

382
00:14:53,839 --> 00:14:59,199
of different interfaces and they are

383
00:14:56,160 --> 00:15:02,000
pretty flexible provides a

384
00:14:59,199 --> 00:15:04,000
driver api where you can you can write

385
00:15:02,000 --> 00:15:07,199
the plugin for to support your

386
00:15:04,000 --> 00:15:09,120
own interface and then of course it's

387
00:15:07,199 --> 00:15:11,519
interesting to look what is available as

388
00:15:09,120 --> 00:15:14,480
a free software for the

389
00:15:11,519 --> 00:15:15,199
uh gui counterpart of those vendor tools

390
00:15:14,480 --> 00:15:19,199
and there is an

391
00:15:15,199 --> 00:15:22,319
excellent uh interesting project of uh

392
00:15:19,199 --> 00:15:24,160
sigrog its uh prime intention is to

393
00:15:22,320 --> 00:15:27,680
provide an

394
00:15:24,160 --> 00:15:30,639
free and open source interface for the

395
00:15:27,680 --> 00:15:32,000
real hardware uh so it means for the

396
00:15:30,639 --> 00:15:35,079
digital multimeters

397
00:15:32,000 --> 00:15:36,240
uh signal generators logic analyzers

398
00:15:35,079 --> 00:15:40,959
oscilloscopes

399
00:15:36,240 --> 00:15:45,040
and for that matter it supports a lot of

400
00:15:40,959 --> 00:15:48,160
vendor systems and big and expensive

401
00:15:45,040 --> 00:15:51,599
electronics agilent hp

402
00:15:48,160 --> 00:15:54,319
all all the all the stuffs but

403
00:15:51,600 --> 00:15:54,800
it's also reasonably easy to provide a

404
00:15:54,320 --> 00:15:57,440
plug-in

405
00:15:54,800 --> 00:15:59,439
driver for it so it can talk to the

406
00:15:57,440 --> 00:16:02,160
logic analyzer which is built in

407
00:15:59,440 --> 00:16:02,880
inside the fpga since fpga is very

408
00:16:02,160 --> 00:16:06,399
flexible

409
00:16:02,880 --> 00:16:09,439
you can just take some more

410
00:16:06,399 --> 00:16:12,160
vhdl code or some more verilog code and

411
00:16:09,440 --> 00:16:13,040
build a logic analyzer inside the fpga

412
00:16:12,160 --> 00:16:15,600
using its

413
00:16:13,040 --> 00:16:17,120
internal resources and connect it to

414
00:16:15,600 --> 00:16:19,759
different signals

415
00:16:17,120 --> 00:16:21,279
inside the fpga itself and vendor tools

416
00:16:19,759 --> 00:16:24,800
such as their

417
00:16:21,279 --> 00:16:29,279
signal tap chip scope

418
00:16:24,800 --> 00:16:30,959
are working and synopsis smart debug

419
00:16:29,279 --> 00:16:33,040
they are working exactly at this level

420
00:16:30,959 --> 00:16:34,560
they are instantiate a separate logic

421
00:16:33,040 --> 00:16:36,639
analyzer instances

422
00:16:34,560 --> 00:16:38,638
inside your system connected to the

423
00:16:36,639 --> 00:16:41,680
signals you are pointed it to

424
00:16:38,639 --> 00:16:42,560
you are interested to look at and then

425
00:16:41,680 --> 00:16:46,000
after

426
00:16:42,560 --> 00:16:48,638
that you is able to

427
00:16:46,000 --> 00:16:50,079
look inside your running system to

428
00:16:48,639 --> 00:16:52,320
figure out what's going on

429
00:16:50,079 --> 00:16:52,319
there

430
00:16:55,680 --> 00:17:00,479
and then of course you can use all those

431
00:16:59,120 --> 00:17:03,120
tools with

432
00:17:00,480 --> 00:17:05,199
pretty much any board you have or any

433
00:17:03,120 --> 00:17:08,319
fpga platforms you have

434
00:17:05,199 --> 00:17:11,600
because they're free

435
00:17:08,319 --> 00:17:14,399
and this one is just an example of

436
00:17:11,599 --> 00:17:15,039
one of the boards what is yeah and it's

437
00:17:14,400 --> 00:17:17,039
still

438
00:17:15,039 --> 00:17:18,240
blinking you see it's running a binary

439
00:17:17,039 --> 00:17:21,199
counter mode

440
00:17:18,240 --> 00:17:22,400
i hope and as we yes it's a binary

441
00:17:21,199 --> 00:17:26,319
counter still

442
00:17:22,400 --> 00:17:26,319
and as we saw on the

443
00:17:26,640 --> 00:17:32,559
vhdl snapshot it can run in second mode

444
00:17:29,679 --> 00:17:33,280
i'll try to switch it now so yep hope

445
00:17:32,559 --> 00:17:35,360
it's visible

446
00:17:33,280 --> 00:17:37,039
it's a linear feedback shift register so

447
00:17:35,360 --> 00:17:39,199
the beats are moving

448
00:17:37,039 --> 00:17:41,440
but in this mode of course you can debug

449
00:17:39,200 --> 00:17:43,919
and something with eight bits

450
00:17:41,440 --> 00:17:45,679
or debugging something with 32 bits with

451
00:17:43,919 --> 00:17:48,640
their

452
00:17:45,679 --> 00:17:50,000
leds would be possible and yesterday

453
00:17:48,640 --> 00:17:52,960
downstairs also

454
00:17:50,000 --> 00:17:53,919
an excellent replic replica of pdp-11

455
00:17:52,960 --> 00:17:56,320
console

456
00:17:53,919 --> 00:17:57,200
where you have 32 toggle switches 32

457
00:17:56,320 --> 00:18:00,159
leds

458
00:17:57,200 --> 00:18:00,880
and you can actually download code and

459
00:18:00,160 --> 00:18:04,080
debug it

460
00:18:00,880 --> 00:18:05,600
this way but with modern architectures

461
00:18:04,080 --> 00:18:08,879
with

462
00:18:05,600 --> 00:18:10,000
hundreds of registers that would be a

463
00:18:08,880 --> 00:18:13,600
little bit painful

464
00:18:10,000 --> 00:18:14,160
and too slow so all the tools all the

465
00:18:13,600 --> 00:18:15,918
pieces

466
00:18:14,160 --> 00:18:17,520
are actually available and there are

467
00:18:15,919 --> 00:18:18,400
different projects to connect them

468
00:18:17,520 --> 00:18:21,120
together

469
00:18:18,400 --> 00:18:21,760
but what you have to do uh to make it

470
00:18:21,120 --> 00:18:24,959
running

471
00:18:21,760 --> 00:18:26,240
is to assemble them and to make them

472
00:18:24,960 --> 00:18:30,559
talk to each other

473
00:18:26,240 --> 00:18:32,160
because uh eurgtec has its own interface

474
00:18:30,559 --> 00:18:35,360
library to talk to it

475
00:18:32,160 --> 00:18:38,640
uh openocd provides an

476
00:18:35,360 --> 00:18:39,760
rpc interface uh but to this interface

477
00:18:38,640 --> 00:18:42,799
you have to talk

478
00:18:39,760 --> 00:18:45,600
tico which is another example of

479
00:18:42,799 --> 00:18:47,120
40 years old language i think and it's

480
00:18:45,600 --> 00:18:50,959
very very favorable

481
00:18:47,120 --> 00:18:53,199
by the both vhdl and verilog designers

482
00:18:50,960 --> 00:18:54,559
so that they don't know much about the

483
00:18:53,200 --> 00:18:56,480
make files really

484
00:18:54,559 --> 00:18:58,080
what they have is they have a very low

485
00:18:56,480 --> 00:19:00,240
code or vhdl code

486
00:18:58,080 --> 00:19:01,918
and then tickle scripts to set up and

487
00:19:00,240 --> 00:19:05,440
compile it

488
00:19:01,919 --> 00:19:06,080
and for to follow this tradition openocd

489
00:19:05,440 --> 00:19:09,600
provides an

490
00:19:06,080 --> 00:19:10,159
rpc token tickle but which is nice and

491
00:19:09,600 --> 00:19:12,480
there is

492
00:19:10,160 --> 00:19:13,440
an example of how to talk to this

493
00:19:12,480 --> 00:19:15,600
interface from

494
00:19:13,440 --> 00:19:16,480
python and what i've done for this

495
00:19:15,600 --> 00:19:19,520
demonstration

496
00:19:16,480 --> 00:19:23,120
i wrote a simple uh driver for the

497
00:19:19,520 --> 00:19:26,320
openocd oh sorry for lipsegrock

498
00:19:23,120 --> 00:19:27,600
to talk to to the open ocd tico

499
00:19:26,320 --> 00:19:31,280
interface

500
00:19:27,600 --> 00:19:32,959
so there is a plugin for the gui for the

501
00:19:31,280 --> 00:19:35,120
pulse view for leap sig rock

502
00:19:32,960 --> 00:19:36,320
which talks through the tickle interface

503
00:19:35,120 --> 00:19:39,199
to the open ocd

504
00:19:36,320 --> 00:19:41,439
which in turn stalks to the through usb

505
00:19:39,200 --> 00:19:44,160
to the usb to jtag converter

506
00:19:41,440 --> 00:19:46,240
which in turns talks through the jtag to

507
00:19:44,160 --> 00:19:49,280
the logic analyzer inside the

508
00:19:46,240 --> 00:19:51,919
fpga and yes

509
00:19:49,280 --> 00:19:53,039
all this code is free and available on

510
00:19:51,919 --> 00:19:56,480
github page

511
00:19:53,039 --> 00:19:59,360
and it's even running

512
00:19:56,480 --> 00:19:59,840
and what we can get running this code is

513
00:19:59,360 --> 00:20:03,520
this

514
00:19:59,840 --> 00:20:06,480
nice snapshot a screenshot of the

515
00:20:03,520 --> 00:20:07,600
sigrog pulse view showing basically the

516
00:20:06,480 --> 00:20:09,679
same picture

517
00:20:07,600 --> 00:20:11,280
uh for whatever reason when i've made

518
00:20:09,679 --> 00:20:15,120
the screenshots they

519
00:20:11,280 --> 00:20:16,879
are mirrored compared to the one

520
00:20:15,120 --> 00:20:19,280
with the simulation results on the

521
00:20:16,880 --> 00:20:21,120
simulation screenshot we had a binary

522
00:20:19,280 --> 00:20:22,000
counter first and linear feedback shift

523
00:20:21,120 --> 00:20:25,520
register

524
00:20:22,000 --> 00:20:28,240
afterwards here we have an

525
00:20:25,520 --> 00:20:29,360
linear feedback shift register and

526
00:20:28,240 --> 00:20:31,919
binary counter

527
00:20:29,360 --> 00:20:32,559
and i also think that bits order is

528
00:20:31,919 --> 00:20:36,559
swapped

529
00:20:32,559 --> 00:20:40,480
but um what it happens

530
00:20:36,559 --> 00:20:43,840
and now let's see if i can make it

531
00:20:40,480 --> 00:20:48,000
run on live

532
00:20:43,840 --> 00:20:51,360
here in the fpga code demo and actual

533
00:20:48,000 --> 00:20:52,240
fpga file is also here it's a bit bigger

534
00:20:51,360 --> 00:20:55,360
than the

535
00:20:52,240 --> 00:20:57,200
small snapshot i've shown it's

536
00:20:55,360 --> 00:21:00,639
initialization logic but

537
00:20:57,200 --> 00:21:02,640
here is the actual code we are

538
00:21:00,640 --> 00:21:04,000
we've been simulating and now we are

539
00:21:02,640 --> 00:21:09,440
debugging on the

540
00:21:04,000 --> 00:21:09,440
real hardware and if we

541
00:21:10,960 --> 00:21:18,559
run s

542
00:21:14,080 --> 00:21:21,039
o v g tech server

543
00:21:18,559 --> 00:21:23,840
ocd are just the configuration files and

544
00:21:21,039 --> 00:21:26,559
typical for the

545
00:21:23,840 --> 00:21:29,039
open ocd and which describe how to

546
00:21:26,559 --> 00:21:32,158
interface to all the pieces which

547
00:21:29,039 --> 00:21:35,120
interface to use and how to talk to it

548
00:21:32,159 --> 00:21:35,440
yes it's running and it can it it sees

549
00:21:35,120 --> 00:21:38,000
the

550
00:21:35,440 --> 00:21:38,880
real hardware talking to it so now we

551
00:21:38,000 --> 00:21:45,840
can just

552
00:21:38,880 --> 00:21:45,840
take a separate window

553
00:21:50,440 --> 00:21:56,559
okay hope it's right

554
00:21:53,440 --> 00:21:58,880
so that's an uh magic to

555
00:21:56,559 --> 00:21:59,760
run the pulse view and substitute it

556
00:21:58,880 --> 00:22:03,039
with the freshly

557
00:21:59,760 --> 00:22:07,360
built patched uh sigrog library

558
00:22:03,039 --> 00:22:10,400
where we should be able to see the

559
00:22:07,360 --> 00:22:14,959
uh nice device let's

560
00:22:10,400 --> 00:22:14,960
see if it still working

561
00:22:15,400 --> 00:22:22,880
okay we

562
00:22:18,400 --> 00:22:22,880
have to find the device

563
00:22:24,840 --> 00:22:29,600
and

564
00:22:26,960 --> 00:22:29,600
it's here

565
00:22:30,080 --> 00:22:34,879
vj tech is just another piece of the

566
00:22:32,919 --> 00:22:37,600
vendor-specific code to

567
00:22:34,880 --> 00:22:39,360
make it possible to talk from the jtag

568
00:22:37,600 --> 00:22:42,719
interface of the fpga

569
00:22:39,360 --> 00:22:45,760
to their custom jtag

570
00:22:42,720 --> 00:22:48,240
connected logic inside the fpga but

571
00:22:45,760 --> 00:22:49,600
it's easy to be replaced and we have to

572
00:22:48,240 --> 00:22:52,840
talk over the network

573
00:22:49,600 --> 00:22:55,360
to their to our

574
00:22:52,840 --> 00:22:57,120
server and it's running on the same

575
00:22:55,360 --> 00:23:00,320
machine

576
00:22:57,120 --> 00:23:03,760
just different numbers

577
00:23:00,320 --> 00:23:07,520
we scan for it yes it's here

578
00:23:03,760 --> 00:23:10,720
that's nice now we can set

579
00:23:07,520 --> 00:23:14,080
up a trigger for something interesting

580
00:23:10,720 --> 00:23:16,640
as our dead state for the

581
00:23:14,080 --> 00:23:19,120
feedback shift register which is all

582
00:23:16,640 --> 00:23:19,120
zeros

583
00:23:21,120 --> 00:23:27,520
uh and it takes me some time

584
00:23:25,120 --> 00:23:27,520
oops

585
00:23:29,280 --> 00:23:34,960
okay probably it's not all zeroes but

586
00:23:32,320 --> 00:23:34,960
nevertheless

587
00:23:35,679 --> 00:23:40,960
and now we can switch it just to make it

588
00:23:38,720 --> 00:23:44,880
run faster

589
00:23:40,960 --> 00:23:44,880
and zoom in

590
00:23:47,200 --> 00:23:54,320
so it's a linear feedback shift register

591
00:23:51,039 --> 00:23:56,240
but running now not not blinking at

592
00:23:54,320 --> 00:23:57,840
two hertz which are suitable for

593
00:23:56,240 --> 00:23:59,679
debugging on the leds

594
00:23:57,840 --> 00:24:01,360
but running a full speed i think the

595
00:23:59,679 --> 00:24:03,520
system clock frequency

596
00:24:01,360 --> 00:24:06,639
is 25 megahertz at the moment so it's

597
00:24:03,520 --> 00:24:06,639
just an external clock

598
00:24:06,960 --> 00:24:10,240
so what we see is that it's possible

599
00:24:09,520 --> 00:24:13,279
with the

600
00:24:10,240 --> 00:24:16,559
free and open software tools to

601
00:24:13,279 --> 00:24:21,440
look inside the running fpga

602
00:24:16,559 --> 00:24:21,440
and i'm really pleased that the

603
00:24:22,159 --> 00:24:26,559
demo is working live

604
00:24:27,279 --> 00:24:30,960
it's nice to have a small dimmer but uh

605
00:24:29,520 --> 00:24:33,840
the real question is what

606
00:24:30,960 --> 00:24:35,200
we where we move next and what important

607
00:24:33,840 --> 00:24:38,399
things to be done

608
00:24:35,200 --> 00:24:38,799
i think the most important thing to be

609
00:24:38,400 --> 00:24:41,840
done

610
00:24:38,799 --> 00:24:44,720
is an integration between tools because

611
00:24:41,840 --> 00:24:45,360
i nobody would ever been able to

612
00:24:44,720 --> 00:24:48,000
convince

613
00:24:45,360 --> 00:24:50,320
any hardware developer or any fpga

614
00:24:48,000 --> 00:24:52,400
developer

615
00:24:50,320 --> 00:24:54,158
for the debugging to switch from the

616
00:24:52,400 --> 00:24:57,279
vendor tools you're using with

617
00:24:54,159 --> 00:24:58,799
one particular fpga to the open source

618
00:24:57,279 --> 00:25:01,600
tools if you have to tell

619
00:24:58,799 --> 00:25:02,480
tell you have to take this part uh it's

620
00:25:01,600 --> 00:25:03,918
written in c

621
00:25:02,480 --> 00:25:05,600
you have to compile it yourself with

622
00:25:03,919 --> 00:25:07,520
your own patched library

623
00:25:05,600 --> 00:25:09,918
then you have to take this part and

624
00:25:07,520 --> 00:25:12,960
write a configuration file on tickle

625
00:25:09,919 --> 00:25:14,000
then you have to take that part and uh

626
00:25:12,960 --> 00:25:16,480
oh yeah it's written

627
00:25:14,000 --> 00:25:17,679
on other you have to compile it for your

628
00:25:16,480 --> 00:25:20,400
system as well

629
00:25:17,679 --> 00:25:21,840
and then you probably if everything goes

630
00:25:20,400 --> 00:25:22,559
well you have to connect it to your

631
00:25:21,840 --> 00:25:24,959
hardware

632
00:25:22,559 --> 00:25:26,879
and then you can debug your hardware no

633
00:25:24,960 --> 00:25:29,760
it would take me weeks it takes months

634
00:25:26,880 --> 00:25:30,400
to debug only the debugging tool chain

635
00:25:29,760 --> 00:25:35,600
so some

636
00:25:30,400 --> 00:25:35,600
nice integration and that's

637
00:25:40,840 --> 00:25:43,840
something

638
00:26:22,400 --> 00:26:26,799
keep debugging standards and interfaces

639
00:26:24,799 --> 00:26:30,000
ieee standards take

640
00:26:26,799 --> 00:26:30,320
really long time to get accommodated and

641
00:26:30,000 --> 00:26:32,720
then

642
00:26:30,320 --> 00:26:34,158
of course an integration with the gdb in

643
00:26:32,720 --> 00:26:36,880
this sense it's pretty good because

644
00:26:34,159 --> 00:26:37,600
openocd supports a gdp remote debugging

645
00:26:36,880 --> 00:26:41,039
interface

646
00:26:37,600 --> 00:26:43,120
and many many different hardware cores

647
00:26:41,039 --> 00:26:44,240
but still missing the integration with

648
00:26:43,120 --> 00:26:47,520
software support

649
00:26:44,240 --> 00:26:49,440
and all this code all the examples are

650
00:26:47,520 --> 00:26:52,639
available on the github page

651
00:26:49,440 --> 00:26:54,880
you can link to it you can

652
00:26:52,640 --> 00:26:56,960
send pages you can download and start

653
00:26:54,880 --> 00:26:58,960
playing with it

654
00:26:56,960 --> 00:27:07,840
and any questions you might have thank

655
00:26:58,960 --> 00:27:07,840
you for your attention

656
00:27:09,300 --> 00:27:12,409
[Music]

657
00:27:12,480 --> 00:27:19,200
oh oh yes please so

658
00:27:15,840 --> 00:27:21,120
a great job the debugging and hardware

659
00:27:19,200 --> 00:27:22,720
you usually trade off you know

660
00:27:21,120 --> 00:27:25,279
visibility for speed

661
00:27:22,720 --> 00:27:27,360
do you see value and simulation for

662
00:27:25,279 --> 00:27:30,960
finding these kind of

663
00:27:27,360 --> 00:27:32,000
things so the question is the visibility

664
00:27:30,960 --> 00:27:35,600
versus speed

665
00:27:32,000 --> 00:27:39,360
during on hardware debugging

666
00:27:35,600 --> 00:27:42,240
yes with some sometimes it's a problem

667
00:27:39,360 --> 00:27:42,879
and simulation is good to cage the logic

668
00:27:42,240 --> 00:27:45,440
errors but

669
00:27:42,880 --> 00:27:46,559
it cannot cage all the hardware and

670
00:27:45,440 --> 00:27:48,720
racing conditions

671
00:27:46,559 --> 00:27:50,720
problems what is good with the

672
00:27:48,720 --> 00:27:52,559
instrumentation running on the fpga

673
00:27:50,720 --> 00:27:55,919
itself on hardware debugging

674
00:27:52,559 --> 00:27:56,639
you are let's say less restricted by the

675
00:27:55,919 --> 00:27:58,720
speed

676
00:27:56,640 --> 00:27:59,760
because jtech here is running it's

677
00:27:58,720 --> 00:28:02,399
something like

678
00:27:59,760 --> 00:28:04,879
uh one megahertz and the real signals we

679
00:28:02,399 --> 00:28:05,520
saw capture it are running full speed 25

680
00:28:04,880 --> 00:28:08,000
mega

681
00:28:05,520 --> 00:28:09,200
megahertz they could run 100 megahertz

682
00:28:08,000 --> 00:28:11,600
and actually this

683
00:28:09,200 --> 00:28:13,440
demonstration came from the actual

684
00:28:11,600 --> 00:28:15,840
project i've

685
00:28:13,440 --> 00:28:17,360
spent last year working on on the micro

686
00:28:15,840 --> 00:28:20,240
semi fpga

687
00:28:17,360 --> 00:28:20,959
where the actual signals were coming at

688
00:28:20,240 --> 00:28:23,760
an

689
00:28:20,960 --> 00:28:26,080
gigabit data rate but it still was

690
00:28:23,760 --> 00:28:26,480
possible to capture them at the gigabit

691
00:28:26,080 --> 00:28:29,439
rate

692
00:28:26,480 --> 00:28:30,480
on the part of the fpga then buffer it

693
00:28:29,440 --> 00:28:32,399
resynchronize

694
00:28:30,480 --> 00:28:34,159
and look through the slow available

695
00:28:32,399 --> 00:28:36,559
debugging interfaces

696
00:28:34,159 --> 00:28:37,919
so yes there are such problems no

697
00:28:36,559 --> 00:28:40,559
simulation can solve

698
00:28:37,919 --> 00:28:41,679
all of them on hardware debugging is

699
00:28:40,559 --> 00:28:44,879
needed for that

700
00:28:41,679 --> 00:28:47,360
and it makes it easier somewhat

701
00:28:44,880 --> 00:28:48,080
okay sorry we cannot have more questions

702
00:28:47,360 --> 00:28:49,840
i'm sorry but

703
00:28:48,080 --> 00:28:59,840
yeah you're welcome to drop a message or

704
00:28:49,840 --> 00:28:59,840
just stop by playthrough

705
00:29:02,720 --> 00:29:04,799
you

