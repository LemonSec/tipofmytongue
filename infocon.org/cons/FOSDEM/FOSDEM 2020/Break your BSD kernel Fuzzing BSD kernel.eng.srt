1
00:00:05,359 --> 00:00:08,400
welcome everyone

2
00:00:06,399 --> 00:00:09,599
uh my name is majin rochowski i was

3
00:00:08,400 --> 00:00:12,320
working for a couple

4
00:00:09,599 --> 00:00:13,599
last couple of months on housing net bsd

5
00:00:12,320 --> 00:00:15,839
kernel

6
00:00:13,599 --> 00:00:18,000
however this knowledge also applied to

7
00:00:15,839 --> 00:00:20,480
filing other kernels

8
00:00:18,000 --> 00:00:22,720
it shouldn't be hard to get this working

9
00:00:20,480 --> 00:00:24,560
also on freebsd i was also doing some

10
00:00:22,720 --> 00:00:28,160
work to get this on free psg so

11
00:00:24,560 --> 00:00:31,359
you can also apply this to fast your

12
00:00:28,160 --> 00:00:34,160
freebsd kernel

13
00:00:31,359 --> 00:00:34,880
so the outlet of the presentation first

14
00:00:34,160 --> 00:00:37,839
of all

15
00:00:34,880 --> 00:00:38,239
what we are trying to achieve and this

16
00:00:37,840 --> 00:00:41,520
talk

17
00:00:38,239 --> 00:00:42,959
also assume that you don't have a lot of

18
00:00:41,520 --> 00:00:46,399
knowledge about the fuzzing

19
00:00:42,960 --> 00:00:47,280
and breaking the kernel so this will

20
00:00:46,399 --> 00:00:50,640
give you a

21
00:00:47,280 --> 00:00:52,960
pretty good overview what you can do

22
00:00:50,640 --> 00:00:54,640
what techniques are available and some

23
00:00:52,960 --> 00:00:56,559
background knowledge

24
00:00:54,640 --> 00:00:57,760
like how these things works under the

25
00:00:56,559 --> 00:01:00,399
hood

26
00:00:57,760 --> 00:01:01,760
so we'll talk about the coverage as a

27
00:01:00,399 --> 00:01:03,680
kind of feedback

28
00:01:01,760 --> 00:01:06,320
for our father that is used for the

29
00:01:03,680 --> 00:01:06,880
fuzzing uh i will also mention a little

30
00:01:06,320 --> 00:01:10,559
bit

31
00:01:06,880 --> 00:01:12,960
sanitizers but i won't go too deeply to

32
00:01:10,560 --> 00:01:14,159
sanitizers because this is also one very

33
00:01:12,960 --> 00:01:16,000
wide topic

34
00:01:14,159 --> 00:01:17,200
however yesterday was a very good talk

35
00:01:16,000 --> 00:01:20,560
about sanitizers

36
00:01:17,200 --> 00:01:22,640
on vmware so if you missed it and you

37
00:01:20,560 --> 00:01:25,680
want to learn more you can also

38
00:01:22,640 --> 00:01:28,880
see the recording and we'll also

39
00:01:25,680 --> 00:01:30,159
show how to do the basic uh setup for

40
00:01:28,880 --> 00:01:33,360
the fuzzer

41
00:01:30,159 --> 00:01:36,400
and as a demo we'll try to run fuzzing

42
00:01:33,360 --> 00:01:40,479
on the ffs on

43
00:01:36,400 --> 00:01:42,320
net music kernel as a virtual machine

44
00:01:40,479 --> 00:01:44,000
so hopefully we may find something

45
00:01:42,320 --> 00:01:47,439
interesting

46
00:01:44,000 --> 00:01:50,640
uh sure uh

47
00:01:47,439 --> 00:01:53,520
okay so a first thing uh

48
00:01:50,640 --> 00:01:54,159
to justify why are we why are we trying

49
00:01:53,520 --> 00:01:58,719
to break

50
00:01:54,159 --> 00:02:02,320
things or why why i'm doing this

51
00:01:58,719 --> 00:02:05,919
is essentially a need for having

52
00:02:02,320 --> 00:02:07,279
multiple different ways to improve the

53
00:02:05,920 --> 00:02:10,000
quality of software

54
00:02:07,280 --> 00:02:11,680
and as we all know kernel is very

55
00:02:10,000 --> 00:02:14,319
critical part of the

56
00:02:11,680 --> 00:02:15,200
operating system if you break the kernel

57
00:02:14,319 --> 00:02:18,958
you have

58
00:02:15,200 --> 00:02:22,079
serious issue and there is no

59
00:02:18,959 --> 00:02:24,319
known silver bullet to solve

60
00:02:22,080 --> 00:02:25,440
all the issue and ensure software

61
00:02:24,319 --> 00:02:28,799
quality

62
00:02:25,440 --> 00:02:30,000
so usually what people does is multiple

63
00:02:28,800 --> 00:02:32,400
parallel actions

64
00:02:30,000 --> 00:02:33,680
to improve code quality and software

65
00:02:32,400 --> 00:02:35,440
quality in general

66
00:02:33,680 --> 00:02:36,720
because we know we always will have some

67
00:02:35,440 --> 00:02:39,280
bugs or some

68
00:02:36,720 --> 00:02:40,239
issues but from the other side we would

69
00:02:39,280 --> 00:02:42,959
like to have

70
00:02:40,239 --> 00:02:44,800
reasonable quality software and

71
00:02:42,959 --> 00:02:48,560
something that won't break

72
00:02:44,800 --> 00:02:50,160
very easily so we can have some list

73
00:02:48,560 --> 00:02:52,480
things that we can do to improve our

74
00:02:50,160 --> 00:02:54,480
software starting from stuff like

75
00:02:52,480 --> 00:02:55,518
getting code reviews applying best

76
00:02:54,480 --> 00:02:59,040
practices

77
00:02:55,519 --> 00:03:01,120
and so on and so forth this list is far

78
00:02:59,040 --> 00:03:03,280
from being complete and probably it can

79
00:03:01,120 --> 00:03:05,120
be couple of other slides

80
00:03:03,280 --> 00:03:07,040
to just list different techniques that

81
00:03:05,120 --> 00:03:09,840
we know but i think

82
00:03:07,040 --> 00:03:10,799
one of the most important and most

83
00:03:09,840 --> 00:03:12,720
interesting

84
00:03:10,800 --> 00:03:16,000
or some other people may say boring

85
00:03:12,720 --> 00:03:20,239
things is about testing the software

86
00:03:16,000 --> 00:03:23,840
so for me testing is like the

87
00:03:20,239 --> 00:03:27,120
time when software uh meet the truth

88
00:03:23,840 --> 00:03:28,400
so if you just do the reviews if you are

89
00:03:27,120 --> 00:03:32,239
just doing

90
00:03:28,400 --> 00:03:34,480
uh analysis of your code without

91
00:03:32,239 --> 00:03:35,280
testing without running the software of

92
00:03:34,480 --> 00:03:37,920
course

93
00:03:35,280 --> 00:03:39,840
it's not good from the other side

94
00:03:37,920 --> 00:03:42,079
technique is also very wide

95
00:03:39,840 --> 00:03:43,840
area there's a lot of resources how

96
00:03:42,080 --> 00:03:46,400
people do testing

97
00:03:43,840 --> 00:03:48,319
but i think in our context it's fair to

98
00:03:46,400 --> 00:03:52,720
say that fuzzing is also

99
00:03:48,319 --> 00:03:55,760
a kind of testing for our software

100
00:03:52,720 --> 00:03:59,200
so first of all what the fuzzing is

101
00:03:55,760 --> 00:04:02,319
usually we call fuzzing when we have

102
00:03:59,200 --> 00:04:06,720
some way to test the software which

103
00:04:02,319 --> 00:04:09,839
in which expect some input and as a

104
00:04:06,720 --> 00:04:12,319
as a as a testing technique

105
00:04:09,840 --> 00:04:13,519
we are trying to give our program some

106
00:04:12,319 --> 00:04:17,039
strange

107
00:04:13,519 --> 00:04:20,399
unexpected input and we are observing

108
00:04:17,040 --> 00:04:21,440
what is the behavior for this particular

109
00:04:20,399 --> 00:04:24,000
input

110
00:04:21,440 --> 00:04:24,880
so this simplest father that can be

111
00:04:24,000 --> 00:04:27,040
written

112
00:04:24,880 --> 00:04:29,600
is just for example let's say we have

113
00:04:27,040 --> 00:04:30,639
some binary that you like to fast which

114
00:04:29,600 --> 00:04:34,160
is called

115
00:04:30,639 --> 00:04:34,960
uh fuzz binary and this binary get us an

116
00:04:34,160 --> 00:04:38,080
input

117
00:04:34,960 --> 00:04:40,799
1000 kilobytes

118
00:04:38,080 --> 00:04:41,440
and some raw byte input and so what we

119
00:04:40,800 --> 00:04:43,600
can do

120
00:04:41,440 --> 00:04:46,000
you can just write some very dummy

121
00:04:43,600 --> 00:04:46,479
father in couple of bash lines or even

122
00:04:46,000 --> 00:04:49,919
in

123
00:04:46,479 --> 00:04:52,159
one if you like very long sentences and

124
00:04:49,919 --> 00:04:53,520
just get some random input save it

125
00:04:52,160 --> 00:04:56,320
somewhere or pipe it

126
00:04:53,520 --> 00:04:57,280
to the binary and then run binary and

127
00:04:56,320 --> 00:05:00,719
the funny thing is

128
00:04:57,280 --> 00:05:01,198
if this if the program is not written

129
00:05:00,720 --> 00:05:03,680
having

130
00:05:01,199 --> 00:05:04,800
validation in mind in that way you

131
00:05:03,680 --> 00:05:07,280
always you all

132
00:05:04,800 --> 00:05:08,160
you already can break some programs

133
00:05:07,280 --> 00:05:11,758
which is

134
00:05:08,160 --> 00:05:14,639
very funny uh but the good thing

135
00:05:11,759 --> 00:05:16,000
i would be to think how we can improve

136
00:05:14,639 --> 00:05:19,039
our dummy father

137
00:05:16,000 --> 00:05:22,320
so what we can what we can do uh

138
00:05:19,039 --> 00:05:26,240
to get the fuzzing smarter and

139
00:05:22,320 --> 00:05:30,719
one thing that came usually to head is

140
00:05:26,240 --> 00:05:34,000
how we can generate the input in more

141
00:05:30,720 --> 00:05:34,960
intelligent way more smarter way so one

142
00:05:34,000 --> 00:05:37,919
of the technique

143
00:05:34,960 --> 00:05:38,560
is mutation based fuzzing as a mutation

144
00:05:37,919 --> 00:05:41,919
based

145
00:05:38,560 --> 00:05:44,240
essentially i assume that we can came up

146
00:05:41,919 --> 00:05:48,479
with some strategies that will be

147
00:05:44,240 --> 00:05:51,199
smarter or have some logical sequence

148
00:05:48,479 --> 00:05:52,320
instead of just getting the random bits

149
00:05:51,199 --> 00:05:55,280
and we can

150
00:05:52,320 --> 00:05:56,080
based on those strategies we can mutate

151
00:05:55,280 --> 00:05:57,440
the input

152
00:05:56,080 --> 00:05:59,840
and provide this input to the

153
00:05:57,440 --> 00:06:01,919
application

154
00:05:59,840 --> 00:06:03,840
by definition mutation based fuzzing

155
00:06:01,919 --> 00:06:04,840
doesn't really care about the state of

156
00:06:03,840 --> 00:06:07,280
application

157
00:06:04,840 --> 00:06:08,880
because we are just caring about

158
00:06:07,280 --> 00:06:12,479
strategy so we have some

159
00:06:08,880 --> 00:06:14,319
strategy to flip certain bits or

160
00:06:12,479 --> 00:06:15,840
the strategy can also be aware about the

161
00:06:14,319 --> 00:06:17,440
grammatics so for example if you are

162
00:06:15,840 --> 00:06:21,198
fuzzing the

163
00:06:17,440 --> 00:06:24,479
http requests you can get some

164
00:06:21,199 --> 00:06:25,360
payload which is like in order with html

165
00:06:24,479 --> 00:06:27,840
standard

166
00:06:25,360 --> 00:06:29,360
and then play with different tags you

167
00:06:27,840 --> 00:06:32,560
don't have to have just

168
00:06:29,360 --> 00:06:34,639
raw bytes that you are modifying

169
00:06:32,560 --> 00:06:37,120
so in that way we are able to much

170
00:06:34,639 --> 00:06:40,560
easier find some interesting inputs

171
00:06:37,120 --> 00:06:42,080
uh than in just a random way and also if

172
00:06:40,560 --> 00:06:44,720
you get the random

173
00:06:42,080 --> 00:06:45,919
input usually if you your program

174
00:06:44,720 --> 00:06:48,080
expects some

175
00:06:45,919 --> 00:06:49,440
different tags some different header in

176
00:06:48,080 --> 00:06:51,919
the input format

177
00:06:49,440 --> 00:06:52,960
usually just stopping on some first

178
00:06:51,919 --> 00:06:56,240
couple of checks

179
00:06:52,960 --> 00:06:59,440
that are making sure that your input

180
00:06:56,240 --> 00:07:01,440
is have some for example certain

181
00:06:59,440 --> 00:07:03,840
header certain and pattern at the very

182
00:07:01,440 --> 00:07:06,319
beginning

183
00:07:03,840 --> 00:07:08,318
another way to improve the further is

184
00:07:06,319 --> 00:07:11,520
introducing the feedback loop

185
00:07:08,319 --> 00:07:14,720
so in the feedback loop essentially get

186
00:07:11,520 --> 00:07:15,520
some feedback from running application

187
00:07:14,720 --> 00:07:18,800
about

188
00:07:15,520 --> 00:07:20,479
application state and this state can be

189
00:07:18,800 --> 00:07:22,720
measured in different ways the most

190
00:07:20,479 --> 00:07:23,840
popular one is the coverage code

191
00:07:22,720 --> 00:07:26,560
coverage

192
00:07:23,840 --> 00:07:27,520
but we also can think about other things

193
00:07:26,560 --> 00:07:31,039
like

194
00:07:27,520 --> 00:07:34,159
timing cpu resources and

195
00:07:31,039 --> 00:07:36,400
stuff like how applications behave with

196
00:07:34,160 --> 00:07:37,680
uh how application behave with the

197
00:07:36,400 --> 00:07:39,039
environment

198
00:07:37,680 --> 00:07:41,199
and it's a funny thing when i was doing

199
00:07:39,039 --> 00:07:44,719
those slides i just put timing because

200
00:07:41,199 --> 00:07:46,400
first of all timing is known from

201
00:07:44,720 --> 00:07:47,919
cryptographic software so for example if

202
00:07:46,400 --> 00:07:48,799
you have some cryptographic software

203
00:07:47,919 --> 00:07:51,520
which

204
00:07:48,800 --> 00:07:53,680
uh have different timing for different

205
00:07:51,520 --> 00:07:55,359
requests based on the execution path you

206
00:07:53,680 --> 00:07:58,240
obviously have security

207
00:07:55,360 --> 00:07:59,840
issue but i was thinking yes i'm that's

208
00:07:58,240 --> 00:08:01,520
a good example but from the other side i

209
00:07:59,840 --> 00:08:03,758
didn't so many like um

210
00:08:01,520 --> 00:08:05,039
timing based fathers and yesterday when

211
00:08:03,759 --> 00:08:07,840
i was waiting for my

212
00:08:05,039 --> 00:08:09,360
uh fosdem t-shirt i met my colleague

213
00:08:07,840 --> 00:08:11,280
he's working for thor project

214
00:08:09,360 --> 00:08:13,840
and we started talking and i told him oh

215
00:08:11,280 --> 00:08:15,359
yeah i'm doing the talk on bsd dev room

216
00:08:13,840 --> 00:08:16,960
about the fuzzing and he was like oh

217
00:08:15,360 --> 00:08:18,720
really i have a friend

218
00:08:16,960 --> 00:08:20,878
who actually was doing a fuzzing based

219
00:08:18,720 --> 00:08:24,879
on mutation and

220
00:08:20,879 --> 00:08:26,879
he used a timing for execution of this

221
00:08:24,879 --> 00:08:28,400
program to the firmware and based on

222
00:08:26,879 --> 00:08:29,840
this execution time

223
00:08:28,400 --> 00:08:32,880
he was doing modification to the

224
00:08:29,840 --> 00:08:34,000
software and by this way he was able to

225
00:08:32,880 --> 00:08:36,719
break some

226
00:08:34,000 --> 00:08:37,599
popular electronic device maintenance

227
00:08:36,719 --> 00:08:39,839
different device

228
00:08:37,599 --> 00:08:41,440
so i was like oh really so that's mean

229
00:08:39,839 --> 00:08:44,320
this this really works

230
00:08:41,440 --> 00:08:44,959
uh so yeah i will also try to department

231
00:08:44,320 --> 00:08:48,160
here

232
00:08:44,959 --> 00:08:51,518
in this timing timing

233
00:08:48,160 --> 00:08:53,519
way to this way to measure

234
00:08:51,519 --> 00:08:54,560
the feedback from the application yeah

235
00:08:53,519 --> 00:08:57,440
so it was

236
00:08:54,560 --> 00:08:59,040
pretty funny uh also from the testing

237
00:08:57,440 --> 00:09:01,760
world we have stuff like

238
00:08:59,040 --> 00:09:03,839
we can think about our filing based on

239
00:09:01,760 --> 00:09:04,800
ad application that we fast so if for

240
00:09:03,839 --> 00:09:06,720
example

241
00:09:04,800 --> 00:09:07,839
as in similar way as we are doing

242
00:09:06,720 --> 00:09:10,160
testing so we have

243
00:09:07,839 --> 00:09:12,160
white box testing black box testing if

244
00:09:10,160 --> 00:09:13,839
we don't have for example

245
00:09:12,160 --> 00:09:16,079
all information but we have some

246
00:09:13,839 --> 00:09:20,000
information we can also say we have

247
00:09:16,080 --> 00:09:21,760
gray box testing and so this feedback

248
00:09:20,000 --> 00:09:23,440
loop also

249
00:09:21,760 --> 00:09:26,000
depends what kind of fuzzing are you

250
00:09:23,440 --> 00:09:27,920
doing in our example we'll be doing

251
00:09:26,000 --> 00:09:29,519
a white box testing because obviously we

252
00:09:27,920 --> 00:09:30,880
have a kernel that you can compile we

253
00:09:29,519 --> 00:09:32,560
can instrument the code

254
00:09:30,880 --> 00:09:34,320
and then you can monitor the state of

255
00:09:32,560 --> 00:09:37,760
the application based

256
00:09:34,320 --> 00:09:40,000
on those informations

257
00:09:37,760 --> 00:09:41,120
so coverage tracking as i said that's

258
00:09:40,000 --> 00:09:43,680
one of the main

259
00:09:41,120 --> 00:09:44,959
technique how you can get the feedback

260
00:09:43,680 --> 00:09:49,599
from the application

261
00:09:44,959 --> 00:09:53,040
and that is how many fuzzers works

262
00:09:49,600 --> 00:09:55,600
main coverage trace is pc trace

263
00:09:53,040 --> 00:09:56,880
program counter it tells us about the

264
00:09:55,600 --> 00:10:00,000
execution path

265
00:09:56,880 --> 00:10:03,680
and the good thing how we can

266
00:10:00,000 --> 00:10:04,399
start under our our understanding of

267
00:10:03,680 --> 00:10:06,800
this format

268
00:10:04,399 --> 00:10:08,160
is essentially the way how it's stored

269
00:10:06,800 --> 00:10:09,839
in our program

270
00:10:08,160 --> 00:10:11,680
so whenever we run the program or

271
00:10:09,839 --> 00:10:13,600
whenever we have a kernel because kernel

272
00:10:11,680 --> 00:10:16,399
is also kind of program

273
00:10:13,600 --> 00:10:18,000
we need some array we need some memory

274
00:10:16,399 --> 00:10:21,200
location where we will be putting

275
00:10:18,000 --> 00:10:22,399
the sequence of pc counters so in our

276
00:10:21,200 --> 00:10:26,480
example we have

277
00:10:22,399 --> 00:10:28,399
a array of size 100 with 100 entries but

278
00:10:26,480 --> 00:10:31,040
it can be much wider

279
00:10:28,399 --> 00:10:32,079
and when the program is executing this

280
00:10:31,040 --> 00:10:35,120
can be done for example

281
00:10:32,079 --> 00:10:37,359
per threat per process or if you are

282
00:10:35,120 --> 00:10:39,200
running the parallel it can be

283
00:10:37,360 --> 00:10:40,480
also something per kernel thread but

284
00:10:39,200 --> 00:10:44,240
also you can think about

285
00:10:40,480 --> 00:10:45,760
some global array for example if you

286
00:10:44,240 --> 00:10:48,800
don't care about the threads but

287
00:10:45,760 --> 00:10:50,319
you care about the execution path

288
00:10:48,800 --> 00:10:52,319
because what can happen if you are

289
00:10:50,320 --> 00:10:54,240
pausing the networking you can put the

290
00:10:52,320 --> 00:10:55,760
request to the networking queue

291
00:10:54,240 --> 00:10:57,680
and then another thread will be getting

292
00:10:55,760 --> 00:10:59,200
this request from the queue

293
00:10:57,680 --> 00:11:01,439
so if you are fuzzing based on the

294
00:10:59,200 --> 00:11:03,040
thread then you will be just seeing the

295
00:11:01,440 --> 00:11:05,440
path when you put the packet

296
00:11:03,040 --> 00:11:07,439
to the queue instead of seeing the

297
00:11:05,440 --> 00:11:11,120
another thread which can be different

298
00:11:07,440 --> 00:11:11,120
that will be processing your request

299
00:11:11,200 --> 00:11:17,440
and so how this exactly works as i said

300
00:11:14,720 --> 00:11:18,880
those are compile compile time uh

301
00:11:17,440 --> 00:11:21,760
instrumentations

302
00:11:18,880 --> 00:11:24,000
so they are put by compiler so on the

303
00:11:21,760 --> 00:11:26,640
right we have a program very simple

304
00:11:24,000 --> 00:11:28,480
which have main which called bar which

305
00:11:26,640 --> 00:11:29,600
goes for which core bar

306
00:11:28,480 --> 00:11:32,320
so what will happen during the

307
00:11:29,600 --> 00:11:32,880
compilation phase our compiler will put

308
00:11:32,320 --> 00:11:34,399
some

309
00:11:32,880 --> 00:11:36,480
magic instrumentation at the very

310
00:11:34,399 --> 00:11:38,399
beginning of all functions

311
00:11:36,480 --> 00:11:39,680
and those will execute when we are

312
00:11:38,399 --> 00:11:43,120
executing the program and

313
00:11:39,680 --> 00:11:46,000
won't interact with our program but what

314
00:11:43,120 --> 00:11:48,560
are those magic instrumentation so i get

315
00:11:46,000 --> 00:11:50,639
a code listing from netbsd kernel

316
00:11:48,560 --> 00:11:51,680
and it's a little bit modified just to

317
00:11:50,639 --> 00:11:55,040
give you some

318
00:11:51,680 --> 00:11:56,239
brief idea what is going on so

319
00:11:55,040 --> 00:11:58,240
every time when we hit the

320
00:11:56,240 --> 00:12:00,639
instrumentation uh we

321
00:11:58,240 --> 00:12:02,399
call this function instrument code and

322
00:12:00,639 --> 00:12:06,000
this function i need to get

323
00:12:02,399 --> 00:12:08,480
our uh our our

324
00:12:06,000 --> 00:12:09,360
memory that we reserve for present in

325
00:12:08,480 --> 00:12:13,120
the

326
00:12:09,360 --> 00:12:14,560
pc counters and we obviously we get the

327
00:12:13,120 --> 00:12:17,040
index because we need to write

328
00:12:14,560 --> 00:12:18,959
another entry we also need to do stuff

329
00:12:17,040 --> 00:12:22,160
like border checking because

330
00:12:18,959 --> 00:12:23,518
based on also your intention you

331
00:12:22,160 --> 00:12:25,439
sometimes may overflow

332
00:12:23,519 --> 00:12:27,279
and if you do the questions for you what

333
00:12:25,440 --> 00:12:28,560
you would like to do but

334
00:12:27,279 --> 00:12:30,399
the most important part we are just

335
00:12:28,560 --> 00:12:32,880
getting the

336
00:12:30,399 --> 00:12:33,760
pc from the function from which we were

337
00:12:32,880 --> 00:12:36,720
called

338
00:12:33,760 --> 00:12:38,160
by just compiler macro so if you run our

339
00:12:36,720 --> 00:12:40,560
very simple program

340
00:12:38,160 --> 00:12:41,439
i will end up with array of three

341
00:12:40,560 --> 00:12:43,920
entries

342
00:12:41,440 --> 00:12:46,000
main full bar so it's very

343
00:12:43,920 --> 00:12:49,040
straightforward

344
00:12:46,000 --> 00:12:50,720
and we don't have only pc trays we have

345
00:12:49,040 --> 00:12:54,240
also a couple other different trays

346
00:12:50,720 --> 00:12:58,320
we have cmp and gp what they are

347
00:12:54,240 --> 00:13:01,360
cmp trace uh is used for

348
00:12:58,320 --> 00:13:05,120
for application is used to

349
00:13:01,360 --> 00:13:07,680
instrument dash comparation instructions

350
00:13:05,120 --> 00:13:09,440
div is for every time when you're doing

351
00:13:07,680 --> 00:13:12,560
division between the arguments

352
00:13:09,440 --> 00:13:15,760
gep is for manipulating indexes

353
00:13:12,560 --> 00:13:17,920
of the arrays so compiler

354
00:13:15,760 --> 00:13:19,680
have some understanding about those and

355
00:13:17,920 --> 00:13:21,120
when it's compiled the code it will put

356
00:13:19,680 --> 00:13:23,680
the instrumentation

357
00:13:21,120 --> 00:13:24,880
before every instruction is performed so

358
00:13:23,680 --> 00:13:26,719
then you can have

359
00:13:24,880 --> 00:13:28,639
better understanding why you need to

360
00:13:26,720 --> 00:13:32,160
have different

361
00:13:28,639 --> 00:13:34,320
i have different types

362
00:13:32,160 --> 00:13:35,279
and so you can imagine like based on

363
00:13:34,320 --> 00:13:38,399
your program

364
00:13:35,279 --> 00:13:39,760
uh you may doing some mathematical

365
00:13:38,399 --> 00:13:42,480
operations like

366
00:13:39,760 --> 00:13:44,560
you can compare the argument you have

367
00:13:42,480 --> 00:13:45,920
some graph or some tree that you are

368
00:13:44,560 --> 00:13:47,920
traversing

369
00:13:45,920 --> 00:13:49,199
so only the pc counter doesn't give you

370
00:13:47,920 --> 00:13:52,000
full information because

371
00:13:49,199 --> 00:13:53,519
you may always see the same path however

372
00:13:52,000 --> 00:13:54,959
the path is not the same because

373
00:13:53,519 --> 00:13:56,560
you are just you know getting different

374
00:13:54,959 --> 00:13:59,119
arguments

375
00:13:56,560 --> 00:14:00,479
or if you are manipulating a lot of

376
00:13:59,120 --> 00:14:02,560
indexes of array

377
00:14:00,480 --> 00:14:04,320
you may also see the same function

378
00:14:02,560 --> 00:14:05,199
called over and over again but from the

379
00:14:04,320 --> 00:14:08,000
other side

380
00:14:05,199 --> 00:14:09,680
you use different arguments so right

381
00:14:08,000 --> 00:14:12,240
here present the cmp

382
00:14:09,680 --> 00:14:13,279
trace is a little bit different than pc

383
00:14:12,240 --> 00:14:14,880
trace

384
00:14:13,279 --> 00:14:17,199
but from the other side is something

385
00:14:14,880 --> 00:14:18,480
that also you have in all bsd kernels as

386
00:14:17,199 --> 00:14:21,279
far as i know

387
00:14:18,480 --> 00:14:22,720
and also other one are similar in terms

388
00:14:21,279 --> 00:14:24,880
of format

389
00:14:22,720 --> 00:14:26,240
so instead of for just one or just one

390
00:14:24,880 --> 00:14:30,000
information

391
00:14:26,240 --> 00:14:31,920
you have arguments of of the operations

392
00:14:30,000 --> 00:14:33,040
we have the numbers that we are

393
00:14:31,920 --> 00:14:36,639
comparing

394
00:14:33,040 --> 00:14:40,560
the types tells you about the size

395
00:14:36,639 --> 00:14:44,000
of the arguments so if it's 8-bit r16

396
00:14:40,560 --> 00:14:47,359
30 to 64 zone and also you have pc

397
00:14:44,000 --> 00:14:50,880
trays so you have a sequence of those

398
00:14:47,360 --> 00:14:53,440
sets of four um values

399
00:14:50,880 --> 00:14:55,199
inside your array and as i said

400
00:14:53,440 --> 00:14:57,680
everything depends on your kernel

401
00:14:55,199 --> 00:14:59,439
on your code that you are fuzzing so it

402
00:14:57,680 --> 00:15:01,120
depends which part for example

403
00:14:59,440 --> 00:15:03,440
the kernel are you trying to fast it's

404
00:15:01,120 --> 00:15:05,040
always good to think okay so if the pc

405
00:15:03,440 --> 00:15:06,480
trace is the only one that i would like

406
00:15:05,040 --> 00:15:09,519
to

407
00:15:06,480 --> 00:15:09,519
see in my father

408
00:15:09,760 --> 00:15:14,160
other important tools sanitizers as i

409
00:15:12,480 --> 00:15:16,480
said i won't be going how they

410
00:15:14,160 --> 00:15:18,800
actually works but i'm trying to

411
00:15:16,480 --> 00:15:20,720
convince you that they are very useful

412
00:15:18,800 --> 00:15:22,800
and the reason why they are very useful

413
00:15:20,720 --> 00:15:26,079
is when you meet any

414
00:15:22,800 --> 00:15:29,199
issue in your code the code may not

415
00:15:26,079 --> 00:15:30,319
exit after invalid operations perform

416
00:15:29,199 --> 00:15:32,240
for example you can

417
00:15:30,320 --> 00:15:33,920
have memory corruption but this memory

418
00:15:32,240 --> 00:15:37,040
corruption won't expose

419
00:15:33,920 --> 00:15:39,040
easily so in that case

420
00:15:37,040 --> 00:15:40,399
you can run the fuzzer and then don't

421
00:15:39,040 --> 00:15:43,759
have any crash even if you

422
00:15:40,399 --> 00:15:46,880
corrupted some data so

423
00:15:43,759 --> 00:15:49,120
if you get the sanitizers

424
00:15:46,880 --> 00:15:51,040
and here we have three kernel sanitizers

425
00:15:49,120 --> 00:15:53,519
other sanitizers

426
00:15:51,040 --> 00:15:54,240
leak sanitizer and memory synthesizer

427
00:15:53,519 --> 00:15:57,680
they are

428
00:15:54,240 --> 00:16:00,320
available in net bsd you can also have

429
00:15:57,680 --> 00:16:00,719
under undefined behavior sanitizer

430
00:16:00,320 --> 00:16:02,800
there's

431
00:16:00,720 --> 00:16:04,560
thread sanitizer i didn't know too much

432
00:16:02,800 --> 00:16:05,279
about trade sanitizers at this moment

433
00:16:04,560 --> 00:16:09,279
but

434
00:16:05,279 --> 00:16:12,720
i am also looking about them

435
00:16:09,279 --> 00:16:15,920
so the very simple one to start with is

436
00:16:12,720 --> 00:16:19,279
kasan because it's the texts things like

437
00:16:15,920 --> 00:16:22,639
out of bounds for cheap stack

438
00:16:19,279 --> 00:16:26,000
and other like a common mistakes

439
00:16:22,639 --> 00:16:28,560
from the software the downside is

440
00:16:26,000 --> 00:16:30,480
you cannot have all at once because some

441
00:16:28,560 --> 00:16:31,680
of them are mutually exclusive with

442
00:16:30,480 --> 00:16:33,360
other ones

443
00:16:31,680 --> 00:16:35,359
so for example you cannot by definition

444
00:16:33,360 --> 00:16:38,240
you cannot have a

445
00:16:35,360 --> 00:16:39,759
asan and and some other scientists and

446
00:16:38,240 --> 00:16:41,279
members in charge because they are

447
00:16:39,759 --> 00:16:42,720
relying on the same data so they are

448
00:16:41,279 --> 00:16:45,920
overlapping each other

449
00:16:42,720 --> 00:16:46,320
so in lldm is specified that you cannot

450
00:16:45,920 --> 00:16:49,360
use

451
00:16:46,320 --> 00:16:52,639
both and from the other side they also

452
00:16:49,360 --> 00:16:54,720
provide some slowdown because there are

453
00:16:52,639 --> 00:16:57,759
compile times and they also

454
00:16:54,720 --> 00:17:00,800
introduce another instructions

455
00:16:57,759 --> 00:17:02,959
but as i said they

456
00:17:00,800 --> 00:17:04,559
allows you to fastbacks easier and

457
00:17:02,959 --> 00:17:08,399
faster so i think

458
00:17:04,559 --> 00:17:12,000
uh is very very big leverage

459
00:17:08,400 --> 00:17:14,720
for the fuzzer to actually run your

460
00:17:12,000 --> 00:17:16,640
fuzzer uh with address sanitizer or any

461
00:17:14,720 --> 00:17:19,919
other sanitizer depends on so

462
00:17:16,640 --> 00:17:22,480
what kind of bugs are you expecting

463
00:17:19,919 --> 00:17:24,559
let's go to the bowser the one that i

464
00:17:22,480 --> 00:17:26,799
was using for a couple of months

465
00:17:24,559 --> 00:17:28,799
is american fuzzy loop i think everyone

466
00:17:26,799 --> 00:17:29,440
know american fuzzy loop is very popular

467
00:17:28,799 --> 00:17:32,400
you have

468
00:17:29,440 --> 00:17:33,919
very good record for found bugs some

469
00:17:32,400 --> 00:17:36,640
people also claim it's

470
00:17:33,919 --> 00:17:36,960
pretty old at this moment but i think

471
00:17:36,640 --> 00:17:39,120
like

472
00:17:36,960 --> 00:17:41,039
as a starting point is very good because

473
00:17:39,120 --> 00:17:44,840
first of all it's very easy to use

474
00:17:41,039 --> 00:17:46,879
as rock solid but from the other side it

475
00:17:44,840 --> 00:17:50,159
didn't

476
00:17:46,880 --> 00:17:51,280
have a goal to fuss the kernels but just

477
00:17:50,160 --> 00:17:54,320
the user space

478
00:17:51,280 --> 00:17:56,320
like but just the user space program so

479
00:17:54,320 --> 00:17:58,840
you cannot use it directly to pass your

480
00:17:56,320 --> 00:18:02,960
kernel you need some modification

481
00:17:58,840 --> 00:18:05,039
um so what that modifications are

482
00:18:02,960 --> 00:18:06,720
uh we can think first of all what we

483
00:18:05,039 --> 00:18:07,360
have from the kernel site what we have

484
00:18:06,720 --> 00:18:10,400
from

485
00:18:07,360 --> 00:18:14,799
uh afl site what format lfl

486
00:18:10,400 --> 00:18:18,480
require so unix's linux freebsd

487
00:18:14,799 --> 00:18:21,918
netbsd open bc and other

488
00:18:18,480 --> 00:18:22,880
expose the coverage using coverage

489
00:18:21,919 --> 00:18:26,000
device slash

490
00:18:22,880 --> 00:18:26,720
dev slash takeoff using this device you

491
00:18:26,000 --> 00:18:29,679
can get

492
00:18:26,720 --> 00:18:32,320
for example pc trace cmp trace the way

493
00:18:29,679 --> 00:18:34,559
how you access this data you

494
00:18:32,320 --> 00:18:35,520
configure the device using ioctos and

495
00:18:34,559 --> 00:18:38,160
then you then

496
00:18:35,520 --> 00:18:39,039
you do the memory map then you run your

497
00:18:38,160 --> 00:18:41,679
program

498
00:18:39,039 --> 00:18:42,080
and after you finish your memory your

499
00:18:41,679 --> 00:18:45,679
map

500
00:18:42,080 --> 00:18:46,480
memory i should contain uh those areas

501
00:18:45,679 --> 00:18:49,919
that i discussed

502
00:18:46,480 --> 00:18:51,520
previously from the other side afl use

503
00:18:49,919 --> 00:18:55,760
its own specific format

504
00:18:51,520 --> 00:18:58,799
where afl focus on par pairs of the

505
00:18:55,760 --> 00:19:02,960
pc counters so and

506
00:18:58,799 --> 00:19:05,679
it stores a unique it stores unique pc

507
00:19:02,960 --> 00:19:08,240
counter pairs which mean every time when

508
00:19:05,679 --> 00:19:10,080
we perform another

509
00:19:08,240 --> 00:19:12,480
when we perform another instrumentation

510
00:19:10,080 --> 00:19:15,600
which means we have another pc

511
00:19:12,480 --> 00:19:16,720
we remember the old pc counter or zero

512
00:19:15,600 --> 00:19:19,280
if we just started

513
00:19:16,720 --> 00:19:20,640
and then get the old pc counter and a

514
00:19:19,280 --> 00:19:23,280
current pc counter

515
00:19:20,640 --> 00:19:24,000
extor them together very easily make

516
00:19:23,280 --> 00:19:26,320
sure that we don't

517
00:19:24,000 --> 00:19:27,919
overflow and then increase one in our

518
00:19:26,320 --> 00:19:31,600
map which gives a

519
00:19:27,919 --> 00:19:35,840
compiler which means a faster hint

520
00:19:31,600 --> 00:19:39,039
this pair of those two pc counter

521
00:19:35,840 --> 00:19:39,918
just happened so then then the father

522
00:19:39,039 --> 00:19:42,799
can

523
00:19:39,919 --> 00:19:44,960
analyze this array and say okay so i got

524
00:19:42,799 --> 00:19:47,918
another pair that i didn't saw before or

525
00:19:44,960 --> 00:19:49,280
maybe i always get the same pairs of pc

526
00:19:47,919 --> 00:19:51,120
counters which mean i need to do

527
00:19:49,280 --> 00:19:54,000
something different

528
00:19:51,120 --> 00:19:54,559
so it's very easy to convert pc trays to

529
00:19:54,000 --> 00:19:57,600
afl

530
00:19:54,559 --> 00:19:59,360
trays because they look the same

531
00:19:57,600 --> 00:20:00,639
but from the other side we don't even

532
00:19:59,360 --> 00:20:03,360
have to do that

533
00:20:00,640 --> 00:20:05,120
we can just store because it's just

534
00:20:03,360 --> 00:20:07,600
storing redundant data

535
00:20:05,120 --> 00:20:08,879
we can just do this on fly so we can

536
00:20:07,600 --> 00:20:13,360
store two values

537
00:20:08,880 --> 00:20:16,960
and this map and this is everything that

538
00:20:13,360 --> 00:20:20,320
our afl needs to work

539
00:20:16,960 --> 00:20:23,760
in order to do that we did some work and

540
00:20:20,320 --> 00:20:27,200
modified a little bit and that bsdk cuff

541
00:20:23,760 --> 00:20:29,919
and essentially we allow

542
00:20:27,200 --> 00:20:31,280
you to plug in another kernel module

543
00:20:29,919 --> 00:20:33,600
which will hook to

544
00:20:31,280 --> 00:20:35,120
the coverage functions that are already

545
00:20:33,600 --> 00:20:37,678
there

546
00:20:35,120 --> 00:20:39,840
by doing that you don't have to manage

547
00:20:37,679 --> 00:20:40,320
the default resources but you still can

548
00:20:39,840 --> 00:20:42,720
use them

549
00:20:40,320 --> 00:20:44,399
if you like but from the other side you

550
00:20:42,720 --> 00:20:48,000
can do things like as i show

551
00:20:44,400 --> 00:20:50,640
like a converting one input from

552
00:20:48,000 --> 00:20:51,919
coverage to another one you can think

553
00:20:50,640 --> 00:20:54,559
about any other

554
00:20:51,919 --> 00:20:55,600
type of any other type of hazard that

555
00:20:54,559 --> 00:20:58,799
you can use

556
00:20:55,600 --> 00:21:00,240
and you don't have to copy all cake of

557
00:20:58,799 --> 00:21:02,559
code and then manage

558
00:21:00,240 --> 00:21:04,400
file descriptors make sure that threads

559
00:21:02,559 --> 00:21:06,158
are open closed all of those things that

560
00:21:04,400 --> 00:21:09,840
you need to copy from kickoff

561
00:21:06,159 --> 00:21:10,080
you can just focus on coverage functions

562
00:21:09,840 --> 00:21:13,199
and

563
00:21:10,080 --> 00:21:16,399
map that's what you really need and

564
00:21:13,200 --> 00:21:19,200
then you can leverage on what is

565
00:21:16,400 --> 00:21:19,200
written already

566
00:21:20,559 --> 00:21:24,720
okay so how this looks i first of all

567
00:21:23,760 --> 00:21:27,280
when i

568
00:21:24,720 --> 00:21:27,840
think about the fuzzing i first of all

569
00:21:27,280 --> 00:21:31,200
think

570
00:21:27,840 --> 00:21:34,320
what is the input what is the output

571
00:21:31,200 --> 00:21:35,120
and so here we have my setup for um for

572
00:21:34,320 --> 00:21:38,720
fuzzing the

573
00:21:35,120 --> 00:21:42,080
ffs mount so my input is my

574
00:21:38,720 --> 00:21:42,880
file image my output will be the result

575
00:21:42,080 --> 00:21:46,879
of

576
00:21:42,880 --> 00:21:49,919
mount or kernel clash and

577
00:21:46,880 --> 00:21:51,679
and this and this sequence

578
00:21:49,919 --> 00:21:53,440
i also require a couple other things

579
00:21:51,679 --> 00:21:56,240
like a wrapper

580
00:21:53,440 --> 00:21:57,280
and as i said earlier there's like a

581
00:21:56,240 --> 00:22:00,799
plug-in for

582
00:21:57,280 --> 00:22:03,918
a for takeoff and

583
00:22:00,799 --> 00:22:05,440
it's works like we have a browser the

584
00:22:03,919 --> 00:22:07,440
father create the

585
00:22:05,440 --> 00:22:09,120
file system image we need our wrapper

586
00:22:07,440 --> 00:22:11,360
that will prepare

587
00:22:09,120 --> 00:22:13,120
the file system image to be mounted but

588
00:22:11,360 --> 00:22:15,039
also will execute

589
00:22:13,120 --> 00:22:16,479
the code that we need so it will be

590
00:22:15,039 --> 00:22:19,360
executing the mount

591
00:22:16,480 --> 00:22:20,480
also we do not uh we do not trace the

592
00:22:19,360 --> 00:22:23,360
wrapper

593
00:22:20,480 --> 00:22:24,559
this is just a thing that help us to

594
00:22:23,360 --> 00:22:27,039
trigger the

595
00:22:24,559 --> 00:22:28,480
execution path in the kernel and then we

596
00:22:27,039 --> 00:22:31,919
do the man

597
00:22:28,480 --> 00:22:34,640
mom is calling skull vfs

598
00:22:31,919 --> 00:22:35,280
file system layer on all of those layers

599
00:22:34,640 --> 00:22:38,400
we

600
00:22:35,280 --> 00:22:40,320
call we get the coverage data

601
00:22:38,400 --> 00:22:42,080
discoverage data then is transformed by

602
00:22:40,320 --> 00:22:44,879
our afl

603
00:22:42,080 --> 00:22:46,080
plugin this plugin is exposed to the

604
00:22:44,880 --> 00:22:48,320
fuzzer as this

605
00:22:46,080 --> 00:22:50,080
map of the pairs that they showed before

606
00:22:48,320 --> 00:22:54,158
and then after every

607
00:22:50,080 --> 00:22:56,240
run the fuzzer will get the input

608
00:22:54,159 --> 00:22:58,080
around the input we'll get the output

609
00:22:56,240 --> 00:23:00,159
from the short memory

610
00:22:58,080 --> 00:23:01,600
we'll see okay so what different

611
00:23:00,159 --> 00:23:04,480
strategy as our

612
00:23:01,600 --> 00:23:06,559
feedback we should change or did we

613
00:23:04,480 --> 00:23:08,880
found any interesting things

614
00:23:06,559 --> 00:23:10,960
and after the feedback phase it's just

615
00:23:08,880 --> 00:23:11,679
perform another operation over and over

616
00:23:10,960 --> 00:23:15,120
again

617
00:23:11,679 --> 00:23:18,000
um until we hit something interesting

618
00:23:15,120 --> 00:23:19,678
um so what so i would like also to talk

619
00:23:18,000 --> 00:23:21,600
a little bit more about

620
00:23:19,679 --> 00:23:23,520
the wrapper it's all because also it's

621
00:23:21,600 --> 00:23:26,240
interesting uh

622
00:23:23,520 --> 00:23:26,799
so the way how you usually write those

623
00:23:26,240 --> 00:23:30,159
wrappers

624
00:23:26,799 --> 00:23:31,280
is i write them in shell i focus okay so

625
00:23:30,159 --> 00:23:34,880
what kind of operation

626
00:23:31,280 --> 00:23:37,200
i'm doing and then after i'm done with

627
00:23:34,880 --> 00:23:38,240
shelling i need to translate to some

628
00:23:37,200 --> 00:23:40,720
other

629
00:23:38,240 --> 00:23:42,000
better performing language i usually

630
00:23:40,720 --> 00:23:44,720
just use c but

631
00:23:42,000 --> 00:23:45,600
you can use c plus plus or anything else

632
00:23:44,720 --> 00:23:49,919
that can

633
00:23:45,600 --> 00:23:51,840
expose your interfaces like system calls

634
00:23:49,919 --> 00:23:53,840
because you don't want to

635
00:23:51,840 --> 00:23:55,520
run on top of live bar someone else

636
00:23:53,840 --> 00:23:57,840
libraries you just want to have

637
00:23:55,520 --> 00:23:59,600
the simple the simplest maybe not even

638
00:23:57,840 --> 00:24:03,039
the simplest but

639
00:23:59,600 --> 00:24:05,120
the shortest code that you can do

640
00:24:03,039 --> 00:24:07,279
and this is also well documented on

641
00:24:05,120 --> 00:24:09,520
every father that

642
00:24:07,279 --> 00:24:10,880
the performance is very key even if your

643
00:24:09,520 --> 00:24:13,360
father is very smart

644
00:24:10,880 --> 00:24:15,520
and doing very good guesses about

645
00:24:13,360 --> 00:24:18,320
different inputs and then

646
00:24:15,520 --> 00:24:19,360
analyzing the output very well it still

647
00:24:18,320 --> 00:24:21,360
can perform

648
00:24:19,360 --> 00:24:22,399
much worse than much simpler fuzzer

649
00:24:21,360 --> 00:24:25,199
which is just faster

650
00:24:22,400 --> 00:24:26,159
because uh in order to find some bugs

651
00:24:25,200 --> 00:24:29,360
you'll need to

652
00:24:26,159 --> 00:24:31,679
run this 10 000 times

653
00:24:29,360 --> 00:24:32,559
million times iteration maybe even

654
00:24:31,679 --> 00:24:34,960
billion times if

655
00:24:32,559 --> 00:24:36,480
iteration if you have some very well

656
00:24:34,960 --> 00:24:38,720
tested software

657
00:24:36,480 --> 00:24:40,320
so in that in that regard you need

658
00:24:38,720 --> 00:24:42,080
something that is performing operation

659
00:24:40,320 --> 00:24:44,320
very quickly

660
00:24:42,080 --> 00:24:48,240
as i would remember performance is the

661
00:24:44,320 --> 00:24:48,240
key to use raw interfaces

662
00:24:49,200 --> 00:24:53,039
other things also that are useful uh

663
00:24:51,600 --> 00:24:55,520
when we are doing the

664
00:24:53,039 --> 00:24:56,158
when we are doing the fuzzing is how i

665
00:24:55,520 --> 00:24:58,879
can see

666
00:24:56,159 --> 00:25:00,159
what is going on inside my fuzzer and

667
00:24:58,880 --> 00:25:03,200
for example

668
00:25:00,159 --> 00:25:05,440
what the problem that i had was um

669
00:25:03,200 --> 00:25:07,200
when i ran my first father into the

670
00:25:05,440 --> 00:25:09,760
first father i saw like

671
00:25:07,200 --> 00:25:10,960
it's very it's not very slow but from

672
00:25:09,760 --> 00:25:12,720
the other side

673
00:25:10,960 --> 00:25:14,480
is very uneffective so i was thinking

674
00:25:12,720 --> 00:25:16,240
okay so what's going on inside this

675
00:25:14,480 --> 00:25:19,919
father how i can debug that

676
00:25:16,240 --> 00:25:23,360
so then what i did i run the takeoff

677
00:25:19,919 --> 00:25:25,600
on my fuzzing wrapper and i

678
00:25:23,360 --> 00:25:26,399
monitor what kind of execution path is

679
00:25:25,600 --> 00:25:28,240
inside

680
00:25:26,400 --> 00:25:30,640
so by the fuzzer and i realized for

681
00:25:28,240 --> 00:25:34,159
example in net bsd

682
00:25:30,640 --> 00:25:36,640
we have much more verbose kernel and

683
00:25:34,159 --> 00:25:38,400
we got a lot of operations from a

684
00:25:36,640 --> 00:25:40,080
virtual memory even if you are doing

685
00:25:38,400 --> 00:25:42,480
mount you see more

686
00:25:40,080 --> 00:25:44,320
virtual memory operations which mean

687
00:25:42,480 --> 00:25:45,520
you're actually not forcing the amount

688
00:25:44,320 --> 00:25:47,279
you're fuzzing

689
00:25:45,520 --> 00:25:50,158
stuff related to the management of the

690
00:25:47,279 --> 00:25:52,159
pages um

691
00:25:50,159 --> 00:25:53,360
so this is also this is also a bit

692
00:25:52,159 --> 00:25:55,279
tricky and

693
00:25:53,360 --> 00:25:56,639
for example in this way in this way you

694
00:25:55,279 --> 00:25:59,360
can get the input

695
00:25:56,640 --> 00:26:01,440
you can understand what is actually

696
00:25:59,360 --> 00:26:04,080
going on under the hood

697
00:26:01,440 --> 00:26:05,919
uh other thing that you can also do

698
00:26:04,080 --> 00:26:07,760
before you start or

699
00:26:05,919 --> 00:26:10,000
if you would like to tune something it's

700
00:26:07,760 --> 00:26:12,960
also doing a coverage benchmark

701
00:26:10,000 --> 00:26:13,840
a father benchmark so you can see for

702
00:26:12,960 --> 00:26:15,279
example

703
00:26:13,840 --> 00:26:17,678
if you want to understand if your

704
00:26:15,279 --> 00:26:19,919
wrapper is

705
00:26:17,679 --> 00:26:22,720
fast or slow you can for example put

706
00:26:19,919 --> 00:26:26,640
some very dummy code inside the kernel

707
00:26:22,720 --> 00:26:29,360
what i've done was create some simple

708
00:26:26,640 --> 00:26:29,760
cover some simple character device we

709
00:26:29,360 --> 00:26:32,799
just

710
00:26:29,760 --> 00:26:35,679
get some input

711
00:26:32,799 --> 00:26:36,400
come like compare this with the pattern

712
00:26:35,679 --> 00:26:38,720
and then

713
00:26:36,400 --> 00:26:40,720
if the pattern match you want the

714
00:26:38,720 --> 00:26:43,360
lottery so your kernel crash

715
00:26:40,720 --> 00:26:44,400
if it doesn't you just run over and over

716
00:26:43,360 --> 00:26:48,000
again

717
00:26:44,400 --> 00:26:49,600
but then i can see how well my

718
00:26:48,000 --> 00:26:51,760
because this code is very simple i can

719
00:26:49,600 --> 00:26:54,959
see how well my operation

720
00:26:51,760 --> 00:26:57,679
in my wrapper perform and from the other

721
00:26:54,960 --> 00:27:00,400
side also you can compare this

722
00:26:57,679 --> 00:27:02,720
this kind of check with user space which

723
00:27:00,400 --> 00:27:07,039
also gives you some intuition

724
00:27:02,720 --> 00:27:09,919
how well are you doing

725
00:27:07,039 --> 00:27:10,480
uh so to do the local to do the local

726
00:27:09,919 --> 00:27:12,960
setup

727
00:27:10,480 --> 00:27:13,600
of the fuzzer uh we also need to have

728
00:27:12,960 --> 00:27:16,960
some

729
00:27:13,600 --> 00:27:20,000
initial corpus uh so this initial corpus

730
00:27:16,960 --> 00:27:20,640
you can create the corpus from for

731
00:27:20,000 --> 00:27:24,159
example

732
00:27:20,640 --> 00:27:27,760
just raw zeros as

733
00:27:24,159 --> 00:27:29,440
it's very well documented that uh the fl

734
00:27:27,760 --> 00:27:32,480
is able to reproduce

735
00:27:29,440 --> 00:27:35,919
some uh different formats so for example

736
00:27:32,480 --> 00:27:37,039
if you are fusing the jpeg or some other

737
00:27:35,919 --> 00:27:39,440
images

738
00:27:37,039 --> 00:27:40,960
afl is able to reproduce those images

739
00:27:39,440 --> 00:27:42,480
but from the other side

740
00:27:40,960 --> 00:27:44,480
if you are running a little bit slower

741
00:27:42,480 --> 00:27:48,720
because you are in the kernel space

742
00:27:44,480 --> 00:27:51,440
and also you don't want to spend like a

743
00:27:48,720 --> 00:27:52,640
initial cpu cycles just to figure out

744
00:27:51,440 --> 00:27:55,039
what is the header

745
00:27:52,640 --> 00:27:55,840
or what is the magic number for the file

746
00:27:55,039 --> 00:27:58,879
system

747
00:27:55,840 --> 00:27:59,918
inside the inside the image you can just

748
00:27:58,880 --> 00:28:02,960
create one

749
00:27:59,919 --> 00:28:07,840
and provide this as a raw

750
00:28:02,960 --> 00:28:10,480
initial sro initial data for the fuzzer

751
00:28:07,840 --> 00:28:11,520
so this also very helps with speeding up

752
00:28:10,480 --> 00:28:14,399
the fuzzing

753
00:28:11,520 --> 00:28:15,279
and once we have that we can run our

754
00:28:14,399 --> 00:28:18,879
fuzzer

755
00:28:15,279 --> 00:28:21,919
with option k which was added

756
00:28:18,880 --> 00:28:23,760
in it was added in afl by

757
00:28:21,919 --> 00:28:25,679
a guys from oracle when they also were

758
00:28:23,760 --> 00:28:29,120
doing their housing of

759
00:28:25,679 --> 00:28:31,120
file systems so essentially i reuse

760
00:28:29,120 --> 00:28:33,520
as they work and integrated this with

761
00:28:31,120 --> 00:28:36,719
net bsd and freebsd

762
00:28:33,520 --> 00:28:38,158
to make them work for both and then you

763
00:28:36,720 --> 00:28:41,039
also need to specify

764
00:28:38,159 --> 00:28:42,159
the wrapper so the important thing is in

765
00:28:41,039 --> 00:28:44,320
that case

766
00:28:42,159 --> 00:28:45,360
you're running on the same you're

767
00:28:44,320 --> 00:28:46,960
running on the same car

768
00:28:45,360 --> 00:28:48,719
you're trying the same binary that

769
00:28:46,960 --> 00:28:51,919
you're running on so do not

770
00:28:48,720 --> 00:28:55,600
shoot and yourself in foot because

771
00:28:51,919 --> 00:28:56,640
if your camera crash then your data may

772
00:28:55,600 --> 00:28:59,840
disappear you may

773
00:28:56,640 --> 00:29:03,200
even not see the latest output

774
00:28:59,840 --> 00:29:05,120
in the afl so you need to

775
00:29:03,200 --> 00:29:06,960
make sure that you know what you are

776
00:29:05,120 --> 00:29:09,840
doing so if for example

777
00:29:06,960 --> 00:29:10,960
you are fuzzing something what is

778
00:29:09,840 --> 00:29:13,520
unstable

779
00:29:10,960 --> 00:29:15,679
and you will be finding a lot of bugs

780
00:29:13,520 --> 00:29:19,120
maybe it's good to get

781
00:29:15,679 --> 00:29:20,960
this input and output somewhere outside

782
00:29:19,120 --> 00:29:22,158
of your kernel so you can mount this on

783
00:29:20,960 --> 00:29:23,760
nfs for example

784
00:29:22,159 --> 00:29:26,320
it will be slower but from the other

785
00:29:23,760 --> 00:29:29,760
side i will have less issues and then

786
00:29:26,320 --> 00:29:31,600
run this process remotely because if you

787
00:29:29,760 --> 00:29:34,158
don't then every time when you crash

788
00:29:31,600 --> 00:29:35,279
you can lose the data that you are

789
00:29:34,159 --> 00:29:37,039
looking for

790
00:29:35,279 --> 00:29:39,760
but from the other side if you have well

791
00:29:37,039 --> 00:29:41,840
tested software and

792
00:29:39,760 --> 00:29:44,080
you just will be happy if you will find

793
00:29:41,840 --> 00:29:45,600
couple of bucks or maybe one bug even

794
00:29:44,080 --> 00:29:48,000
you can just run this natively on your

795
00:29:45,600 --> 00:29:50,158
kernel uh what i've done for example was

796
00:29:48,000 --> 00:29:53,760
connecting the debugger to the kernel

797
00:29:50,159 --> 00:29:56,320
run afl if anything crash i can just get

798
00:29:53,760 --> 00:29:57,039
output from debugger and see what's

799
00:29:56,320 --> 00:30:00,480
going on

800
00:29:57,039 --> 00:30:03,600
i can also get crash somewhere

801
00:30:00,480 --> 00:30:04,320
sometimes i realize that depends on the

802
00:30:03,600 --> 00:30:08,000
path that

803
00:30:04,320 --> 00:30:10,639
crash you still may not get the

804
00:30:08,000 --> 00:30:12,320
actually may have some problems with

805
00:30:10,640 --> 00:30:15,840
getting the output

806
00:30:12,320 --> 00:30:17,120
so because the ideal scenario is you get

807
00:30:15,840 --> 00:30:19,520
the output

808
00:30:17,120 --> 00:30:20,158
which is the latest image that you were

809
00:30:19,520 --> 00:30:21,520
fusing

810
00:30:20,159 --> 00:30:23,279
and then you can get this image and

811
00:30:21,520 --> 00:30:25,520
check okay so if this image

812
00:30:23,279 --> 00:30:26,640
always break my kernel of this was

813
00:30:25,520 --> 00:30:30,960
something that

814
00:30:26,640 --> 00:30:33,200
was from some before testing so usually

815
00:30:30,960 --> 00:30:35,360
it's very nice if you have output that

816
00:30:33,200 --> 00:30:36,640
is a payload that you can just mount and

817
00:30:35,360 --> 00:30:39,520
then it every and

818
00:30:36,640 --> 00:30:39,520
break your kernel

819
00:30:40,320 --> 00:30:43,840
okay so how many iterations to find the

820
00:30:43,440 --> 00:30:46,960
bug

821
00:30:43,840 --> 00:30:48,720
in fuzzing ffs so what we'll be doing

822
00:30:46,960 --> 00:30:49,600
will just run on the same virtual

823
00:30:48,720 --> 00:30:53,360
machine

824
00:30:49,600 --> 00:30:54,480
the father and that's actually some

825
00:30:53,360 --> 00:30:56,639
other issue that i

826
00:30:54,480 --> 00:30:58,080
found at the very beginning but

827
00:30:56,640 --> 00:31:01,919
hopefully we can

828
00:30:58,080 --> 00:31:01,918
we can find something interesting

829
00:31:02,840 --> 00:31:05,840
okay

830
00:31:08,159 --> 00:31:12,000
okay so i need to get

831
00:31:12,640 --> 00:31:16,399
i don't know how big it can be because

832
00:31:14,559 --> 00:31:19,440
then the

833
00:31:16,399 --> 00:31:22,320
father need to also okay uh

834
00:31:19,440 --> 00:31:25,120
so we have here the father it's modified

835
00:31:22,320 --> 00:31:29,519
version we have inside

836
00:31:25,120 --> 00:31:32,000
in um a file which is our

837
00:31:29,519 --> 00:31:32,559
prepare it's not zero so the name is a

838
00:31:32,000 --> 00:31:35,919
little bit

839
00:31:32,559 --> 00:31:39,120
misleading but we can see

840
00:31:35,919 --> 00:31:42,240
that oh this is zero okay

841
00:31:39,120 --> 00:31:44,639
i was fuzzing this anyway

842
00:31:42,240 --> 00:31:46,320
and it's actually this is zero so i was

843
00:31:44,640 --> 00:31:48,720
fuzzing this before and

844
00:31:46,320 --> 00:31:48,720
i think

845
00:31:50,559 --> 00:31:58,399
yes thanks

846
00:31:54,559 --> 00:31:58,399
okay so it's not zero

847
00:32:00,000 --> 00:32:04,799
uh so you can see this is the legit file

848
00:32:03,039 --> 00:32:08,399
system image so we have the

849
00:32:04,799 --> 00:32:12,639
offset which is eight i think 8k

850
00:32:08,399 --> 00:32:15,840
and we have some some magic

851
00:32:12,640 --> 00:32:16,159
from the headers of ffs i won't go too

852
00:32:15,840 --> 00:32:18,559
much

853
00:32:16,159 --> 00:32:19,840
in depth details but we see the

854
00:32:18,559 --> 00:32:23,840
structure is

855
00:32:19,840 --> 00:32:27,279
it's not it's not just a zero file um

856
00:32:23,840 --> 00:32:31,279
so the way how we run it

857
00:32:27,279 --> 00:32:32,240
and we can have this okay so i won't run

858
00:32:31,279 --> 00:32:35,440
it yet

859
00:32:32,240 --> 00:32:35,440
because i usually also get

860
00:32:35,600 --> 00:32:40,000
uh proper absolute buff

861
00:32:40,840 --> 00:32:43,840
wrapper

862
00:32:48,240 --> 00:32:55,200
so we run afl fast minus k

863
00:32:52,000 --> 00:32:57,679
i from input out from output

864
00:32:55,200 --> 00:32:59,440
didn't remember exactly but i think this

865
00:32:57,679 --> 00:33:03,519
definitely will work

866
00:32:59,440 --> 00:33:03,519
if we will get the

867
00:33:03,600 --> 00:33:07,760
the wrapper itself okay uh from the

868
00:33:06,559 --> 00:33:10,960
other side

869
00:33:07,760 --> 00:33:11,760
this running on gdb so we have connected

870
00:33:10,960 --> 00:33:14,240
debugger

871
00:33:11,760 --> 00:33:15,679
because this is just a virtual machine

872
00:33:14,240 --> 00:33:17,760
and

873
00:33:15,679 --> 00:33:20,240
this is debugger that is debugging the

874
00:33:17,760 --> 00:33:23,519
kernel so we can stop in every time

875
00:33:20,240 --> 00:33:26,880
we can see the trace we can continue

876
00:33:23,519 --> 00:33:27,600
retrace we can also see that because we

877
00:33:26,880 --> 00:33:30,000
stopped

878
00:33:27,600 --> 00:33:32,158
virtual machine just froze we can just

879
00:33:30,000 --> 00:33:34,480
continue

880
00:33:32,159 --> 00:33:36,080
so then our virtual machine is still

881
00:33:34,480 --> 00:33:39,120
living

882
00:33:36,080 --> 00:33:41,760
okay let's let's

883
00:33:39,120 --> 00:33:41,760
run this thing

884
00:33:43,600 --> 00:33:47,519
oh we already got something so this

885
00:33:46,640 --> 00:33:50,799
around the

886
00:33:47,519 --> 00:33:53,919
dry uh so this

887
00:33:50,799 --> 00:33:56,240
this round so it was running the dry

888
00:33:53,919 --> 00:33:57,200
input at the dry run at the very

889
00:33:56,240 --> 00:33:59,039
beginning so

890
00:33:57,200 --> 00:34:00,720
dry run it's just do some simple

891
00:33:59,039 --> 00:34:06,000
modification

892
00:34:00,720 --> 00:34:08,879
and what you can see here

893
00:34:06,000 --> 00:34:09,359
as yeah usually it also should show you

894
00:34:08,879 --> 00:34:12,159
the

895
00:34:09,359 --> 00:34:13,759
afl console but because we hit something

896
00:34:12,159 --> 00:34:16,079
probably because i was

897
00:34:13,760 --> 00:34:17,200
uh testing this before so we have some

898
00:34:16,079 --> 00:34:19,119
old history

899
00:34:17,199 --> 00:34:21,199
so it was also running something that

900
00:34:19,119 --> 00:34:24,240
was found before

901
00:34:21,199 --> 00:34:26,319
but we can go here and

902
00:34:24,239 --> 00:34:29,839
this is already running in getting the

903
00:34:26,320 --> 00:34:29,839
core dump from the kernel

904
00:34:33,280 --> 00:34:40,480
okay but we have um operations that

905
00:34:36,800 --> 00:34:44,480
uh crash so we have vfs reclaim

906
00:34:40,480 --> 00:34:47,199
uh which uh was called uh on

907
00:34:44,480 --> 00:34:48,800
the on the we know that was reclaimed

908
00:34:47,199 --> 00:34:51,839
from the v cash

909
00:34:48,800 --> 00:34:52,240
so that's kind of a moment when you

910
00:34:51,839 --> 00:34:55,279
start

911
00:34:52,239 --> 00:34:56,719
debugging the kernel and i won't right

912
00:34:55,280 --> 00:35:01,119
now be doing this

913
00:34:56,719 --> 00:35:02,879
because it's required some time and also

914
00:35:01,119 --> 00:35:04,800
i'm not in right now great position as a

915
00:35:02,880 --> 00:35:07,680
presenter to start debugging that

916
00:35:04,800 --> 00:35:08,079
uh but this is some this is something

917
00:35:07,680 --> 00:35:11,359
that

918
00:35:08,079 --> 00:35:14,720
uh it break broke our kernel

919
00:35:11,359 --> 00:35:19,200
uh so this might be related to them

920
00:35:14,720 --> 00:35:21,279
to the data from the v-nodes and this

921
00:35:19,200 --> 00:35:23,439
we can get this as a car or we can start

922
00:35:21,280 --> 00:35:27,040
debugging this

923
00:35:23,440 --> 00:35:27,040
you can start debugging this in gdb

924
00:35:28,839 --> 00:35:32,960
okay and i think we can just

925
00:35:34,880 --> 00:35:42,000
okay uh okay so conclusion uh so fuzzing

926
00:35:38,880 --> 00:35:44,160
surfacing the kernel is another way as i

927
00:35:42,000 --> 00:35:45,119
said earlier we need a lot of different

928
00:35:44,160 --> 00:35:49,040
ways to

929
00:35:45,119 --> 00:35:50,880
test our kernel and that we can

930
00:35:49,040 --> 00:35:53,440
just we can just do to make sure that

931
00:35:50,880 --> 00:35:54,320
our quality of our drivers our file

932
00:35:53,440 --> 00:35:57,200
systems

933
00:35:54,320 --> 00:35:58,880
is better also if you like to you know

934
00:35:57,200 --> 00:36:00,480
start searching for some bugs this is

935
00:35:58,880 --> 00:36:03,520
also very

936
00:36:00,480 --> 00:36:06,240
easy way to start and

937
00:36:03,520 --> 00:36:07,200
we have recently a lot of good work for

938
00:36:06,240 --> 00:36:10,399
improving

939
00:36:07,200 --> 00:36:12,000
things that allows us to run the fuzzing

940
00:36:10,400 --> 00:36:14,560
so for example

941
00:36:12,000 --> 00:36:16,320
gathering the coverage in bsd and other

942
00:36:14,560 --> 00:36:19,759
bsd in general improved

943
00:36:16,320 --> 00:36:20,960
also sanitizers in particular in that

944
00:36:19,760 --> 00:36:23,920
bsd become

945
00:36:20,960 --> 00:36:25,280
much better over the time it's very easy

946
00:36:23,920 --> 00:36:27,760
to start as you see

947
00:36:25,280 --> 00:36:28,480
it doesn't require much knowledge so i

948
00:36:27,760 --> 00:36:31,599
think

949
00:36:28,480 --> 00:36:33,040
in this half hour i gives you almost

950
00:36:31,599 --> 00:36:34,720
everything that you need to start your

951
00:36:33,040 --> 00:36:37,920
adventure with the fuzzing

952
00:36:34,720 --> 00:36:40,480
and also you should run the sanitizers

953
00:36:37,920 --> 00:36:42,400
by the way this was not random sanitizer

954
00:36:40,480 --> 00:36:46,640
because we didn't have any scientists or

955
00:36:42,400 --> 00:36:48,240
output so future work

956
00:36:46,640 --> 00:36:49,759
i would like to have some also

957
00:36:48,240 --> 00:36:53,439
discussion with other

958
00:36:49,760 --> 00:36:55,680
people i saw a andrew presentation from

959
00:36:53,440 --> 00:36:56,800
that he's also doing something on afl so

960
00:36:55,680 --> 00:36:59,598
maybe we can

961
00:36:56,800 --> 00:37:01,680
came with some similar way that we fast

962
00:36:59,599 --> 00:37:03,920
bsds

963
00:37:01,680 --> 00:37:05,040
i saw previously on linux they

964
00:37:03,920 --> 00:37:08,480
introduced another

965
00:37:05,040 --> 00:37:11,359
device it was slash diff slash afl

966
00:37:08,480 --> 00:37:13,359
which community didn't like it and it

967
00:37:11,359 --> 00:37:16,960
was not upstream at the end

968
00:37:13,359 --> 00:37:18,720
so i think if we will try to get this on

969
00:37:16,960 --> 00:37:20,880
common interface that will be beneficial

970
00:37:18,720 --> 00:37:23,118
for everyone because then people from

971
00:37:20,880 --> 00:37:25,839
security projects can just you know fuss

972
00:37:23,119 --> 00:37:28,000
our kernel in the same way

973
00:37:25,839 --> 00:37:28,880
i also need to spend more time on

974
00:37:28,000 --> 00:37:32,079
improving the

975
00:37:28,880 --> 00:37:32,640
remote fuzzing because it didn't scale

976
00:37:32,079 --> 00:37:36,079
very well

977
00:37:32,640 --> 00:37:37,440
if you want to find many bugs and just

978
00:37:36,079 --> 00:37:40,960
continue with

979
00:37:37,440 --> 00:37:43,359
fuzzing and fixing the bugs

980
00:37:40,960 --> 00:37:45,680
the resources so our net bsd block

981
00:37:43,359 --> 00:37:50,640
there's also paper

982
00:37:45,680 --> 00:37:53,040
oracle paper yes from 2016

983
00:37:50,640 --> 00:37:54,720
my collection of mount wrapper clinic

984
00:37:53,040 --> 00:37:56,800
documentation was very

985
00:37:54,720 --> 00:38:05,839
useful source of information and i will

986
00:37:56,800 --> 00:38:05,839
be happy to get any questions

987
00:38:07,920 --> 00:38:10,560
some questions

988
00:38:11,280 --> 00:38:19,839
okay so thank you very much thank you

989
00:38:26,079 --> 00:38:30,240
on one group justin we can listen the

990
00:38:29,280 --> 00:38:33,839
questions

991
00:38:30,240 --> 00:38:33,839
and the answers

992
00:38:41,520 --> 00:38:46,000
okay so the question was can you use afl

993
00:38:44,000 --> 00:38:47,599
for remote fuzzing not for the fuzzing

994
00:38:46,000 --> 00:38:50,000
readers presented

995
00:38:47,599 --> 00:38:51,520
the answer is yes but you need to do

996
00:38:50,000 --> 00:38:56,160
additional setup because

997
00:38:51,520 --> 00:38:58,400
as i said afl used the same data on

998
00:38:56,160 --> 00:39:00,000
use input and output directory so you

999
00:38:58,400 --> 00:39:02,880
need to mount to have them

1000
00:39:00,000 --> 00:39:04,560
remotely you need to run this as a pro

1001
00:39:02,880 --> 00:39:05,440
you need to run this as a process and

1002
00:39:04,560 --> 00:39:09,440
then you need

1003
00:39:05,440 --> 00:39:10,640
also some way to send back them

1004
00:39:09,440 --> 00:39:12,880
send back the information to the fork

1005
00:39:10,640 --> 00:39:16,160
server that crash happen because

1006
00:39:12,880 --> 00:39:17,200
your process just stopped and the thing

1007
00:39:16,160 --> 00:39:20,399
that i'm currently

1008
00:39:17,200 --> 00:39:22,240
looking on is how to get efficiently

1009
00:39:20,400 --> 00:39:23,520
the kernel down because then you have

1010
00:39:22,240 --> 00:39:26,319
the dumping process

1011
00:39:23,520 --> 00:39:27,119
so this allocation for dump also need to

1012
00:39:26,320 --> 00:39:29,680
be mounted

1013
00:39:27,119 --> 00:39:31,520
for something like nfs again or some

1014
00:39:29,680 --> 00:39:32,799
other protocol i mean nfs is the

1015
00:39:31,520 --> 00:39:34,560
simplest one

1016
00:39:32,800 --> 00:39:36,560
but you can potentially came with some

1017
00:39:34,560 --> 00:39:39,759
other good ideas

1018
00:39:36,560 --> 00:39:40,160
and i don't know how hard it will be to

1019
00:39:39,760 --> 00:39:43,119
get

1020
00:39:40,160 --> 00:39:44,720
afl console to real life to analyze

1021
00:39:43,119 --> 00:39:46,480
those crashes to say

1022
00:39:44,720 --> 00:39:48,000
uh because when you're passing the user

1023
00:39:46,480 --> 00:39:50,400
space like

1024
00:39:48,000 --> 00:39:51,599
user space library or user space binary

1025
00:39:50,400 --> 00:39:53,760
you see those

1026
00:39:51,599 --> 00:39:55,359
unique crashes for example so afl is

1027
00:39:53,760 --> 00:39:57,119
going through the core dump

1028
00:39:55,359 --> 00:39:58,960
of the process and then saying okay so

1029
00:39:57,119 --> 00:40:01,599
this one occurred

1030
00:39:58,960 --> 00:40:02,640
before so then it's not unique it's like

1031
00:40:01,599 --> 00:40:04,560
something similar

1032
00:40:02,640 --> 00:40:06,160
or this one is not unique because it's

1033
00:40:04,560 --> 00:40:08,839
something different and then

1034
00:40:06,160 --> 00:40:10,319
i have also take strategies from those

1035
00:40:08,839 --> 00:40:13,279
crashes

1036
00:40:10,319 --> 00:40:13,680
to improve so that's so i think as i

1037
00:40:13,280 --> 00:40:16,800
said

1038
00:40:13,680 --> 00:40:20,480
that part about analyzing the

1039
00:40:16,800 --> 00:40:21,040
core dump from uh kernel is some unknown

1040
00:40:20,480 --> 00:40:25,680
for me

1041
00:40:21,040 --> 00:40:28,240
other things can be done go ahead

1042
00:40:25,680 --> 00:40:29,200
okay maybe someone wants to leave the

1043
00:40:28,240 --> 00:40:39,839
room

1044
00:40:29,200 --> 00:40:39,839
before the second question okay

