1
00:00:16,360 --> 00:00:19,530
[Music]

2
00:00:24,410 --> 00:00:32,509
[Music]

3
00:00:37,360 --> 00:00:41,280
all right i'm todd i am from lawrence

4
00:00:39,840 --> 00:00:43,280
livermore national laboratory for people

5
00:00:41,280 --> 00:00:44,879
who aren't familiar with that

6
00:00:43,280 --> 00:00:47,200
it's a national security laboratory it's

7
00:00:44,879 --> 00:00:48,718
about an hour from san francisco

8
00:00:47,200 --> 00:00:50,320
and we run a lot of super computers

9
00:00:48,719 --> 00:00:52,320
which is the sort of the motivation for

10
00:00:50,320 --> 00:00:53,199
spac

11
00:00:52,320 --> 00:00:56,239
i'm going to talk a little bit about

12
00:00:53,199 --> 00:00:58,160
dependency management in general first

13
00:00:56,239 --> 00:00:59,358
so so far we've heard from a lot of

14
00:00:58,160 --> 00:01:02,078
different dependency managers what's

15
00:00:59,359 --> 00:01:04,080
managed by dependency managers typically

16
00:01:02,079 --> 00:01:05,680
it's usually what projects is this or

17
00:01:04,080 --> 00:01:06,240
what packages does this project depend

18
00:01:05,680 --> 00:01:07,520
on

19
00:01:06,240 --> 00:01:09,199
and what version of each of the

20
00:01:07,520 --> 00:01:10,399
installed packages or what what version

21
00:01:09,200 --> 00:01:11,600
of each of the dependencies should i

22
00:01:10,400 --> 00:01:12,799
actually install

23
00:01:11,600 --> 00:01:15,039
and so if you think about you know what

24
00:01:12,799 --> 00:01:16,560
does that look like as a package model

25
00:01:15,040 --> 00:01:18,320
for for most package managers

26
00:01:16,560 --> 00:01:19,920
it's like this it's a little this is a

27
00:01:18,320 --> 00:01:21,360
node it has a name

28
00:01:19,920 --> 00:01:22,960
it's got a version it depends on some

29
00:01:21,360 --> 00:01:25,439
other things that some other versions

30
00:01:22,960 --> 00:01:26,000
and so it's fairly simple it gets to be

31
00:01:25,439 --> 00:01:27,039
complex

32
00:01:26,000 --> 00:01:28,799
when you start to do dependency

33
00:01:27,040 --> 00:01:32,240
resolution on this it's np hard even to

34
00:01:28,799 --> 00:01:34,079
select the versions for a dag

35
00:01:32,240 --> 00:01:36,640
but you know this is pretty much what

36
00:01:34,079 --> 00:01:38,559
most package managers are resolving

37
00:01:36,640 --> 00:01:40,640
um the concerns that people typically

38
00:01:38,560 --> 00:01:42,000
have with what versions are selected are

39
00:01:40,640 --> 00:01:43,280
you know what do i have correct or

40
00:01:42,000 --> 00:01:44,640
compatible versions

41
00:01:43,280 --> 00:01:46,479
do i have the latest version do i have

42
00:01:44,640 --> 00:01:47,680
the most tested version do i have a

43
00:01:46,479 --> 00:01:48,560
secure version

44
00:01:47,680 --> 00:01:50,720
those are the kinds of things we've

45
00:01:48,560 --> 00:01:52,159
heard about so far

46
00:01:50,720 --> 00:01:54,479
this is going to be a slightly different

47
00:01:52,159 --> 00:01:56,479
kind of talk

48
00:01:54,479 --> 00:01:58,079
we're going to talk about building for

49
00:01:56,479 --> 00:02:00,399
basically resolving dependencies for

50
00:01:58,079 --> 00:02:01,600
optimization and not necessarily

51
00:02:00,399 --> 00:02:03,759
for these concerns although we care

52
00:02:01,600 --> 00:02:05,119
about those too so

53
00:02:03,759 --> 00:02:06,240
some fairly common but maybe

54
00:02:05,119 --> 00:02:07,680
questionable assumptions that your

55
00:02:06,240 --> 00:02:08,318
package manager makes and we've talked

56
00:02:07,680 --> 00:02:10,800
about these

57
00:02:08,318 --> 00:02:12,160
today too are hey there's a one-to-one

58
00:02:10,800 --> 00:02:13,520
relationship between the source code and

59
00:02:12,160 --> 00:02:15,120
the binary

60
00:02:13,520 --> 00:02:16,640
this is an assumption that debian makes

61
00:02:15,120 --> 00:02:17,760
for the reproducible builds project

62
00:02:16,640 --> 00:02:19,920
it sort of assumes that you're only

63
00:02:17,760 --> 00:02:23,359
going to build source code one way

64
00:02:19,920 --> 00:02:24,559
and we don't really do that in hpc um

65
00:02:23,360 --> 00:02:26,640
binaries should be as portable as

66
00:02:24,560 --> 00:02:27,920
possible most distros it's it's bad for

67
00:02:26,640 --> 00:02:30,160
performance if you build

68
00:02:27,920 --> 00:02:31,280
o2-g binaries they're not going to run

69
00:02:30,160 --> 00:02:32,720
fast and so if you have something

70
00:02:31,280 --> 00:02:35,440
performance critical

71
00:02:32,720 --> 00:02:36,000
in your stack you need to be able to

72
00:02:35,440 --> 00:02:38,079
build it

73
00:02:36,000 --> 00:02:39,519
a fast way which is harder than building

74
00:02:38,080 --> 00:02:41,519
the portable binaries

75
00:02:39,519 --> 00:02:42,800
um the other assumption that typically

76
00:02:41,519 --> 00:02:44,239
has made is the tool chain's the same

77
00:02:42,800 --> 00:02:46,160
across the ecosystem i'm going to build

78
00:02:44,239 --> 00:02:47,599
this thing with the standard compiler or

79
00:02:46,160 --> 00:02:49,200
maybe i don't even have a compiler i'm

80
00:02:47,599 --> 00:02:52,238
using an interpreted language

81
00:02:49,200 --> 00:02:54,079
and so you know we we'd like to be able

82
00:02:52,239 --> 00:02:56,640
to actually resolve the compiler

83
00:02:54,080 --> 00:02:57,440
in the stack and then the assumption

84
00:02:56,640 --> 00:02:59,040
that users

85
00:02:57,440 --> 00:03:01,040
build and deploy configurations that

86
00:02:59,040 --> 00:03:02,400
were tested before most package managers

87
00:03:01,040 --> 00:03:03,200
are taking an artifact that someone

88
00:03:02,400 --> 00:03:06,159
generated

89
00:03:03,200 --> 00:03:07,760
that they tested they're deploying it um

90
00:03:06,159 --> 00:03:09,359
what we really like on this back project

91
00:03:07,760 --> 00:03:10,799
at least is that you know it would be

92
00:03:09,360 --> 00:03:12,400
really nice if building something for

93
00:03:10,800 --> 00:03:13,680
the first time were just as easy as

94
00:03:12,400 --> 00:03:14,319
building something that someone built

95
00:03:13,680 --> 00:03:17,200
before

96
00:03:14,319 --> 00:03:18,238
so that's what we're working towards and

97
00:03:17,200 --> 00:03:20,879
why are we doing that

98
00:03:18,239 --> 00:03:22,000
um we build for machines like this so um

99
00:03:20,879 --> 00:03:23,518
these are some of the department of

100
00:03:22,000 --> 00:03:25,519
energy's current and upcoming

101
00:03:23,519 --> 00:03:26,720
super computers and so if you look at

102
00:03:25,519 --> 00:03:28,239
these um

103
00:03:26,720 --> 00:03:30,239
the you know there's four plus different

104
00:03:28,239 --> 00:03:32,239
cpu architectures and four plus

105
00:03:30,239 --> 00:03:34,080
different gpus across these machines

106
00:03:32,239 --> 00:03:36,000
none of these looks the same and so

107
00:03:34,080 --> 00:03:37,760
typically when we're building something

108
00:03:36,000 --> 00:03:39,280
we're building in a pretty new probably

109
00:03:37,760 --> 00:03:40,959
bleeding edge environment and we want to

110
00:03:39,280 --> 00:03:43,599
tune for the machine

111
00:03:40,959 --> 00:03:45,200
right and so code is typically

112
00:03:43,599 --> 00:03:47,119
distributed as source

113
00:03:45,200 --> 00:03:49,760
which is pretty horrible it's a pain we

114
00:03:47,120 --> 00:03:51,200
have to build it all the time

115
00:03:49,760 --> 00:03:53,359
we build many variants of the same

116
00:03:51,200 --> 00:03:54,399
package the code's optimized for the

117
00:03:53,360 --> 00:03:56,319
processor model

118
00:03:54,400 --> 00:03:57,840
and so it's not an o2-g binary it might

119
00:03:56,319 --> 00:04:00,319
even be optimized for you know like

120
00:03:57,840 --> 00:04:01,360
skylake canon lake a particular model of

121
00:04:00,319 --> 00:04:04,879
the processor not just

122
00:04:01,360 --> 00:04:06,239
x86 64. there's no standard ecosystem

123
00:04:04,879 --> 00:04:07,599
most things are linux

124
00:04:06,239 --> 00:04:09,120
but the user environment and where the

125
00:04:07,599 --> 00:04:10,640
software on the machine is is very

126
00:04:09,120 --> 00:04:12,239
different from site to site

127
00:04:10,640 --> 00:04:14,000
and then it's multi-language so we're

128
00:04:12,239 --> 00:04:16,160
not dealing with one package ecosystem

129
00:04:14,000 --> 00:04:18,079
we're dealing with c c plus plus fortran

130
00:04:16,160 --> 00:04:21,840
python lots of other things

131
00:04:18,079 --> 00:04:22,960
it's pretty complicated um so

132
00:04:21,839 --> 00:04:24,880
these are the kind of things that we're

133
00:04:22,960 --> 00:04:26,840
building these are large simulations for

134
00:04:24,880 --> 00:04:28,479
things like compressible flow nuclear

135
00:04:26,840 --> 00:04:32,159
reactors

136
00:04:28,479 --> 00:04:36,080
urban disasters radiological problems

137
00:04:32,160 --> 00:04:38,400
things like that and so the model

138
00:04:36,080 --> 00:04:39,919
becomes a lot more complicated so this

139
00:04:38,400 --> 00:04:40,479
is the dag i showed before this is a

140
00:04:39,919 --> 00:04:41,919
node

141
00:04:40,479 --> 00:04:44,800
where you're just selecting for a name

142
00:04:41,919 --> 00:04:48,080
and a version what we're tuning in spac

143
00:04:44,800 --> 00:04:49,759
is this so this is build configuration

144
00:04:48,080 --> 00:04:51,199
options so particular parameters that

145
00:04:49,759 --> 00:04:53,040
you might pass to configure or different

146
00:04:51,199 --> 00:04:54,880
options on the package

147
00:04:53,040 --> 00:04:57,199
different library implementations so i

148
00:04:54,880 --> 00:04:59,919
may not depend on just one library

149
00:04:57,199 --> 00:05:01,360
i might depend on mpi of which there are

150
00:04:59,919 --> 00:05:02,719
three or four different implementations

151
00:05:01,360 --> 00:05:04,080
with different versions on each of them

152
00:05:02,720 --> 00:05:05,280
different configuration options

153
00:05:04,080 --> 00:05:07,039
different networks

154
00:05:05,280 --> 00:05:08,719
i'm tuning for different gpus different

155
00:05:07,039 --> 00:05:09,440
cuda versions i'm tuning for the

156
00:05:08,720 --> 00:05:10,960
compiler

157
00:05:09,440 --> 00:05:12,880
there may be more than one compiler for

158
00:05:10,960 --> 00:05:15,039
my language ecosystem all of this gets

159
00:05:12,880 --> 00:05:16,880
pretty complicated so what we want

160
00:05:15,039 --> 00:05:18,320
is a dependency resolver that can select

161
00:05:16,880 --> 00:05:23,199
all the parameters here

162
00:05:18,320 --> 00:05:24,560
not just this so spac enables that

163
00:05:23,199 --> 00:05:26,800
it's designed to enable software

164
00:05:24,560 --> 00:05:28,400
distribution for hpc we're automating

165
00:05:26,800 --> 00:05:29,440
the build and installation so we're not

166
00:05:28,400 --> 00:05:31,198
just selecting from

167
00:05:29,440 --> 00:05:32,880
existing versions we're actually

168
00:05:31,199 --> 00:05:33,919
generating a space of packages we're

169
00:05:32,880 --> 00:05:36,000
generating dags

170
00:05:33,919 --> 00:05:37,599
to build different versions of things

171
00:05:36,000 --> 00:05:38,320
the packages are templated so there's

172
00:05:37,600 --> 00:05:41,759
one

173
00:05:38,320 --> 00:05:44,000
packaged python file per package per

174
00:05:41,759 --> 00:05:45,440
project i guess and then it has a lot of

175
00:05:44,000 --> 00:05:48,400
different parameters so you can build

176
00:05:45,440 --> 00:05:50,080
this combinatorial explosion of packages

177
00:05:48,400 --> 00:05:52,000
and so we're pulling a lot of lower

178
00:05:50,080 --> 00:05:54,320
level aspects of the software ecosystem

179
00:05:52,000 --> 00:05:55,520
up to the package manager level that's

180
00:05:54,320 --> 00:05:57,039
the build parameters and things that i

181
00:05:55,520 --> 00:05:58,400
just talked about

182
00:05:57,039 --> 00:06:00,080
it's written in python but like i said

183
00:05:58,400 --> 00:06:02,000
we can package whatever

184
00:06:00,080 --> 00:06:03,919
and so what we really want is the ease

185
00:06:02,000 --> 00:06:04,639
of use of mainstream tools all the stuff

186
00:06:03,919 --> 00:06:07,039
that modern

187
00:06:04,639 --> 00:06:08,720
software developers are used to but for

188
00:06:07,039 --> 00:06:10,400
this somewhat antiquated software

189
00:06:08,720 --> 00:06:13,600
ecosystem that we have to deal with

190
00:06:10,400 --> 00:06:14,960
in hpc we're doing okay it's a pretty

191
00:06:13,600 --> 00:06:16,880
popular project

192
00:06:14,960 --> 00:06:18,239
it's not as popular as like many

193
00:06:16,880 --> 00:06:19,520
javascript projects

194
00:06:18,240 --> 00:06:21,039
but it is used all over the world at

195
00:06:19,520 --> 00:06:21,840
different hpc sites and so this is sort

196
00:06:21,039 --> 00:06:23,599
of proof

197
00:06:21,840 --> 00:06:25,440
that you know we are bringing the

198
00:06:23,600 --> 00:06:27,039
ecosystem together we're getting lots of

199
00:06:25,440 --> 00:06:28,400
contributions on the package side from

200
00:06:27,039 --> 00:06:30,318
lots of different organizations we have

201
00:06:28,400 --> 00:06:31,359
over 500 contributors now

202
00:06:30,319 --> 00:06:32,560
and even the core is getting

203
00:06:31,360 --> 00:06:33,759
contributions from lots of different

204
00:06:32,560 --> 00:06:35,280
folks

205
00:06:33,759 --> 00:06:36,960
and we're used on some of the biggest

206
00:06:35,280 --> 00:06:38,400
machines out there so we're used on the

207
00:06:36,960 --> 00:06:40,318
number one system at oak ridge

208
00:06:38,400 --> 00:06:41,679
summit the number two system at

209
00:06:40,319 --> 00:06:43,039
livermore which is a similar machine

210
00:06:41,680 --> 00:06:44,800
that's where i am

211
00:06:43,039 --> 00:06:46,400
and we're going to be used for the

212
00:06:44,800 --> 00:06:48,400
upcoming arm 64 fx

213
00:06:46,400 --> 00:06:49,440
system from fujitsu that's going to get

214
00:06:48,400 --> 00:06:50,638
deployed at weekends so we have a

215
00:06:49,440 --> 00:06:53,520
partnership with them

216
00:06:50,639 --> 00:06:55,120
so lots of interesting machines this is

217
00:06:53,520 --> 00:06:56,000
what it looks like from sort of a user

218
00:06:55,120 --> 00:06:58,479
level

219
00:06:56,000 --> 00:06:59,599
you can install a package just normally

220
00:06:58,479 --> 00:07:01,039
you can say i want this package

221
00:06:59,599 --> 00:07:02,639
just say the name of it and we'll give

222
00:07:01,039 --> 00:07:04,000
you something with sensible defaults

223
00:07:02,639 --> 00:07:05,360
you can get a lot more specific though

224
00:07:04,000 --> 00:07:06,880
you can say i want a particular version

225
00:07:05,360 --> 00:07:07,919
you can say i want a particular compiler

226
00:07:06,880 --> 00:07:09,280
and a particular version of that

227
00:07:07,919 --> 00:07:10,639
compiler

228
00:07:09,280 --> 00:07:12,719
you can say that you want to have

229
00:07:10,639 --> 00:07:14,560
threads enabled different build options

230
00:07:12,720 --> 00:07:15,759
you can inject flags into the build so

231
00:07:14,560 --> 00:07:17,280
you could basically build

232
00:07:15,759 --> 00:07:18,880
60 versions of the same package with

233
00:07:17,280 --> 00:07:20,400
different flags

234
00:07:18,880 --> 00:07:21,919
you can target specific micro

235
00:07:20,400 --> 00:07:23,359
architectures so you can say i want to

236
00:07:21,919 --> 00:07:25,440
build for skylake

237
00:07:23,360 --> 00:07:26,960
and you can also do that for all the

238
00:07:25,440 --> 00:07:29,360
dependencies so you can get specific

239
00:07:26,960 --> 00:07:30,638
about your dependencies and what they do

240
00:07:29,360 --> 00:07:32,240
and so this is what the command line

241
00:07:30,639 --> 00:07:34,240
configuration looks like so if you

242
00:07:32,240 --> 00:07:35,440
install one thing

243
00:07:34,240 --> 00:07:37,360
the packages like i said they're

244
00:07:35,440 --> 00:07:38,960
templated and so

245
00:07:37,360 --> 00:07:40,880
if people are familiar with homebrew the

246
00:07:38,960 --> 00:07:42,560
package recipes look a lot like homebrew

247
00:07:40,880 --> 00:07:43,919
they're just written in python

248
00:07:42,560 --> 00:07:45,280
but they're also templated so you can

249
00:07:43,919 --> 00:07:46,479
have lots of different versions lots of

250
00:07:45,280 --> 00:07:47,840
different options lots of different

251
00:07:46,479 --> 00:07:48,878
dependencies that are potentially

252
00:07:47,840 --> 00:07:50,239
optional

253
00:07:48,879 --> 00:07:52,639
and then there's build recipe stuff down

254
00:07:50,240 --> 00:07:55,039
here and so with that

255
00:07:52,639 --> 00:07:56,240
um what we're doing is is we're enabling

256
00:07:55,039 --> 00:07:58,240
you to build

257
00:07:56,240 --> 00:08:00,000
all of the things we want you to be able

258
00:07:58,240 --> 00:08:01,440
to build you know this dag

259
00:08:00,000 --> 00:08:03,120
but configured lots of different ways

260
00:08:01,440 --> 00:08:06,400
and so for each configuration

261
00:08:03,120 --> 00:08:07,759
of that graph um we generate a hash

262
00:08:06,400 --> 00:08:09,840
and we install everything in its own

263
00:08:07,759 --> 00:08:11,199
prefix and so as many

264
00:08:09,840 --> 00:08:13,359
versions as you want of all these

265
00:08:11,199 --> 00:08:14,720
different packages can coexist together

266
00:08:13,360 --> 00:08:16,879
and they're all our paths so you don't

267
00:08:14,720 --> 00:08:18,000
have to worry about finding dependencies

268
00:08:16,879 --> 00:08:19,599
you don't have to worry about setting up

269
00:08:18,000 --> 00:08:20,639
your ld library path these are all they

270
00:08:19,599 --> 00:08:22,878
all know where to find their

271
00:08:20,639 --> 00:08:26,479
dependencies when we build them

272
00:08:22,879 --> 00:08:28,960
so what does the dependency resolver

273
00:08:26,479 --> 00:08:29,758
do um this is we call it the concretizer

274
00:08:28,960 --> 00:08:31,520
in spec

275
00:08:29,759 --> 00:08:32,959
we take an abstract spec like that

276
00:08:31,520 --> 00:08:34,640
that's basically you know what does it

277
00:08:32,958 --> 00:08:36,958
look like on the command line

278
00:08:34,640 --> 00:08:39,120
um and then we we basically normalize it

279
00:08:36,958 --> 00:08:40,399
so we produce a dag that has some of the

280
00:08:39,120 --> 00:08:41,440
constraints filled in

281
00:08:40,399 --> 00:08:43,120
and then if you think about what the

282
00:08:41,440 --> 00:08:44,880
dependency resolver is doing it's

283
00:08:43,120 --> 00:08:46,480
solving this problem it's filling in all

284
00:08:44,880 --> 00:08:47,439
the blanks in a consistent way so we

285
00:08:46,480 --> 00:08:49,600
take that dag

286
00:08:47,440 --> 00:08:50,560
we turn it into the the giant json thing

287
00:08:49,600 --> 00:08:52,560
that i showed you

288
00:08:50,560 --> 00:08:54,800
and we store that in the file system

289
00:08:52,560 --> 00:08:57,279
with with all this provenance

290
00:08:54,800 --> 00:08:58,160
um for an environment we support virtual

291
00:08:57,279 --> 00:09:00,000
environments

292
00:08:58,160 --> 00:09:02,319
and with uh sort of the manifest log

293
00:09:00,000 --> 00:09:04,560
file model that bundler popularized

294
00:09:02,320 --> 00:09:06,480
so we can do spac.yaml which is sort of

295
00:09:04,560 --> 00:09:07,680
the input format it's like a bunch of

296
00:09:06,480 --> 00:09:09,279
different specs like the ones that i

297
00:09:07,680 --> 00:09:11,279
showed on the command line

298
00:09:09,279 --> 00:09:12,399
and we produce a lock file with all that

299
00:09:11,279 --> 00:09:15,439
information for all the different

300
00:09:12,399 --> 00:09:17,920
dependencies in your environment

301
00:09:15,440 --> 00:09:18,959
this has gotten to be pretty complicated

302
00:09:17,920 --> 00:09:22,240
and so this is where

303
00:09:18,959 --> 00:09:24,000
this talk sort of picks up we're taking

304
00:09:22,240 --> 00:09:25,680
you know lots of constraints from lots

305
00:09:24,000 --> 00:09:27,360
of different places and we're trying to

306
00:09:25,680 --> 00:09:28,959
integrate them into one gigantic sat

307
00:09:27,360 --> 00:09:30,640
solve

308
00:09:28,959 --> 00:09:31,920
and and that's pretty nasty so there's

309
00:09:30,640 --> 00:09:32,640
the stuff that i showed on the command

310
00:09:31,920 --> 00:09:34,079
line

311
00:09:32,640 --> 00:09:35,680
there's all the constraints that came

312
00:09:34,080 --> 00:09:38,160
from the package file that i showed for

313
00:09:35,680 --> 00:09:39,519
all the dependencies in the project tree

314
00:09:38,160 --> 00:09:40,800
there's constraints that can be in the

315
00:09:39,519 --> 00:09:42,160
environment so users can actually

316
00:09:40,800 --> 00:09:43,760
specify their preferences for how

317
00:09:42,160 --> 00:09:45,120
dependencies are resolved

318
00:09:43,760 --> 00:09:46,399
and then there's other configurations

319
00:09:45,120 --> 00:09:47,760
you can have local configuration for

320
00:09:46,399 --> 00:09:49,760
your user for your site

321
00:09:47,760 --> 00:09:51,040
and there's defaults from spac and so

322
00:09:49,760 --> 00:09:53,680
all of this stuff sort of gets

323
00:09:51,040 --> 00:09:55,279
mushed into one solve and we traverse

324
00:09:53,680 --> 00:09:57,040
the dag repeatedly we evaluate

325
00:09:55,279 --> 00:09:58,720
conditions add dependencies and we

326
00:09:57,040 --> 00:10:00,319
repeat this until the dag doesn't change

327
00:09:58,720 --> 00:10:00,880
so it's kind of a fixed point algorithm

328
00:10:00,320 --> 00:10:03,200
in the

329
00:10:00,880 --> 00:10:04,240
in the current version i mean the issue

330
00:10:03,200 --> 00:10:05,920
with this is that

331
00:10:04,240 --> 00:10:08,000
there's limited support for backtracking

332
00:10:05,920 --> 00:10:09,519
it's pretty greedy um you can sort of

333
00:10:08,000 --> 00:10:10,079
decide the version of something over

334
00:10:09,519 --> 00:10:11,760
here

335
00:10:10,079 --> 00:10:13,760
and then discover a conflict over here

336
00:10:11,760 --> 00:10:15,600
and not have them resolved properly

337
00:10:13,760 --> 00:10:17,040
and then um the constraints are yeah so

338
00:10:15,600 --> 00:10:20,640
the constraints are ordered

339
00:10:17,040 --> 00:10:22,880
so you may discover you know that

340
00:10:20,640 --> 00:10:24,399
you've selected a compiler but you

341
00:10:22,880 --> 00:10:25,839
wanted to build for an architecture

342
00:10:24,399 --> 00:10:27,440
that it turns out that compiler doesn't

343
00:10:25,839 --> 00:10:29,040
support and really you have to kind of

344
00:10:27,440 --> 00:10:31,920
solve those things together

345
00:10:29,040 --> 00:10:33,199
to get a consistent dag and so this

346
00:10:31,920 --> 00:10:34,959
results in a whole lot of con

347
00:10:33,200 --> 00:10:36,560
conditional complexity for a solver that

348
00:10:34,959 --> 00:10:38,479
you know isn't all that powerful

349
00:10:36,560 --> 00:10:41,279
compared to what some of these

350
00:10:38,480 --> 00:10:42,399
you know full back tracking solvers can

351
00:10:41,279 --> 00:10:44,000
do

352
00:10:42,399 --> 00:10:45,680
and so it's gotten to be hard to add new

353
00:10:44,000 --> 00:10:47,040
features in logic and it can be slow

354
00:10:45,680 --> 00:10:48,640
because we're basically

355
00:10:47,040 --> 00:10:51,199
building the dag over and over and over

356
00:10:48,640 --> 00:10:53,120
again in python

357
00:10:51,200 --> 00:10:55,120
so we started looking into what are the

358
00:10:53,120 --> 00:10:55,839
options stat solving looks pretty

359
00:10:55,120 --> 00:10:57,920
appealing

360
00:10:55,839 --> 00:11:00,320
there are lots of dependency managers

361
00:10:57,920 --> 00:11:02,000
that use sat solvers getting into the

362
00:11:00,320 --> 00:11:03,600
world of stat solving is not for the

363
00:11:02,000 --> 00:11:05,200
faint of heart there are lots and lots

364
00:11:03,600 --> 00:11:05,839
of different sub-communities there and

365
00:11:05,200 --> 00:11:07,839
they all do

366
00:11:05,839 --> 00:11:09,600
sort of variants on the same thing and

367
00:11:07,839 --> 00:11:10,560
so this took a lot of research to sort

368
00:11:09,600 --> 00:11:12,079
of figure out

369
00:11:10,560 --> 00:11:13,680
what's the best way to do this or what

370
00:11:12,079 --> 00:11:16,479
do existing tools do

371
00:11:13,680 --> 00:11:17,680
so picosat is probably your most simple

372
00:11:16,480 --> 00:11:20,079
portable c

373
00:11:17,680 --> 00:11:21,760
solver it uses advanced techniques for

374
00:11:20,079 --> 00:11:22,959
actually doing a set solve but it's pure

375
00:11:21,760 --> 00:11:25,760
boolean logic

376
00:11:22,959 --> 00:11:27,518
and so if you want to write your solver

377
00:11:25,760 --> 00:11:28,720
in pure boolean sat

378
00:11:27,519 --> 00:11:30,800
it turns out you have to do a lot of

379
00:11:28,720 --> 00:11:33,360
cumbersome things you have to implement

380
00:11:30,800 --> 00:11:34,880
arithmetic in boolean logic if you want

381
00:11:33,360 --> 00:11:36,640
to do anything like optimization so

382
00:11:34,880 --> 00:11:38,800
you're really like building an adder

383
00:11:36,640 --> 00:11:40,880
in in boolean logic which is which is

384
00:11:38,800 --> 00:11:42,560
nuts

385
00:11:40,880 --> 00:11:44,399
conda does this it ends up being kind of

386
00:11:42,560 --> 00:11:44,640
slow in conda and so people have looked

387
00:11:44,399 --> 00:11:46,959
at

388
00:11:44,640 --> 00:11:48,640
libsall as a potential solution for that

389
00:11:46,959 --> 00:11:49,760
lib solve is also a sat solver i think

390
00:11:48,640 --> 00:11:50,959
it does some of this

391
00:11:49,760 --> 00:11:52,800
but it's very targeted towards a

392
00:11:50,959 --> 00:11:54,160
traditional package model so it seems

393
00:11:52,800 --> 00:11:55,920
like libsall solves

394
00:11:54,160 --> 00:11:56,959
mostly the node model that i showed on

395
00:11:55,920 --> 00:11:58,800
the first slide where you're just

396
00:11:56,959 --> 00:12:00,000
thinking about packages and versions

397
00:11:58,800 --> 00:12:01,680
and so it didn't seem like we could get

398
00:12:00,000 --> 00:12:03,920
inside something like that and really

399
00:12:01,680 --> 00:12:06,000
customize it to our needs

400
00:12:03,920 --> 00:12:06,880
um pubgrub is awesome i think people

401
00:12:06,000 --> 00:12:08,560
have heard of that who's heard of

402
00:12:06,880 --> 00:12:10,639
pubgrub

403
00:12:08,560 --> 00:12:12,560
this is sort of next-gen version solving

404
00:12:10,639 --> 00:12:14,399
it's a cdcl solver which is it's

405
00:12:12,560 --> 00:12:15,599
it learns clauses and conflicts as it

406
00:12:14,399 --> 00:12:18,240
goes along

407
00:12:15,600 --> 00:12:19,760
so it's a powerful sat solver and it has

408
00:12:18,240 --> 00:12:21,600
some logic in it that basically

409
00:12:19,760 --> 00:12:22,480
maintains a list of conflicts as it does

410
00:12:21,600 --> 00:12:24,480
to solve

411
00:12:22,480 --> 00:12:26,079
and so if you get an error in pubgrub it

412
00:12:24,480 --> 00:12:28,399
comes back to you and says

413
00:12:26,079 --> 00:12:29,760
oh hey this depends on version another

414
00:12:28,399 --> 00:12:31,279
version of this this depends on another

415
00:12:29,760 --> 00:12:32,639
version of this and so you need to

416
00:12:31,279 --> 00:12:33,839
adjust the version of this package to

417
00:12:32,639 --> 00:12:35,120
fix your solve because it's not

418
00:12:33,839 --> 00:12:37,360
compatible right now

419
00:12:35,120 --> 00:12:39,040
so it essentially gives you a proof of

420
00:12:37,360 --> 00:12:42,800
what's unsatisfiable

421
00:12:39,040 --> 00:12:44,800
about your dag which is cool

422
00:12:42,800 --> 00:12:46,959
but the model again is kind of limited

423
00:12:44,800 --> 00:12:48,880
it's package inversion for pubgrub

424
00:12:46,959 --> 00:12:50,560
and we would have to use it we'd have to

425
00:12:48,880 --> 00:12:52,399
sort of integrate it into our own solver

426
00:12:50,560 --> 00:12:53,920
and do our own custom thing and we

427
00:12:52,399 --> 00:12:55,680
really didn't want to do that

428
00:12:53,920 --> 00:12:57,360
we needed multi-criteria optimization

429
00:12:55,680 --> 00:13:00,719
i'll get into that a little bit

430
00:12:57,360 --> 00:13:02,639
in a second and tons of people's life

431
00:13:00,720 --> 00:13:03,760
work has gone into basically taking sat

432
00:13:02,639 --> 00:13:05,120
solvers integrating them with

433
00:13:03,760 --> 00:13:07,200
optimization solvers

434
00:13:05,120 --> 00:13:08,639
and making that fast and so we really

435
00:13:07,200 --> 00:13:09,920
were worried about implementing a custom

436
00:13:08,639 --> 00:13:12,639
solver in python

437
00:13:09,920 --> 00:13:13,839
so we sort of stayed away from this the

438
00:13:12,639 --> 00:13:16,320
two things that

439
00:13:13,839 --> 00:13:17,040
we kind of boiled down to in the end

440
00:13:16,320 --> 00:13:18,480
were

441
00:13:17,040 --> 00:13:21,040
so there are these things called smt

442
00:13:18,480 --> 00:13:23,200
solvers this is like a sat solver

443
00:13:21,040 --> 00:13:25,120
but it actually has theories integrated

444
00:13:23,200 --> 00:13:27,440
into it and what that means is that

445
00:13:25,120 --> 00:13:28,720
for your boolean solve it's it's doing

446
00:13:27,440 --> 00:13:30,079
basically all your advanced stat

447
00:13:28,720 --> 00:13:34,079
algorithms

448
00:13:30,079 --> 00:13:34,959
for the actual clauses in the solve you

449
00:13:34,079 --> 00:13:36,880
can do things like

450
00:13:34,959 --> 00:13:38,560
math you don't need to implement you

451
00:13:36,880 --> 00:13:40,079
know math and boolean sat

452
00:13:38,560 --> 00:13:41,839
you can actually use other sort of

453
00:13:40,079 --> 00:13:43,599
theory solvers for the equations

454
00:13:41,839 --> 00:13:46,240
themselves that go into the sat solve

455
00:13:43,600 --> 00:13:46,720
so that's pretty cool you can call out

456
00:13:46,240 --> 00:13:48,240
to

457
00:13:46,720 --> 00:13:50,160
you know a theory solver from within

458
00:13:48,240 --> 00:13:52,160
your sat solver um

459
00:13:50,160 --> 00:13:53,839
it also does multi-criteria optimization

460
00:13:52,160 --> 00:13:55,680
and z3 is really popular in the formal

461
00:13:53,839 --> 00:13:57,440
verification community so this is for

462
00:13:55,680 --> 00:13:59,519
like security people who want to say

463
00:13:57,440 --> 00:14:01,760
this is a heap and it only does heap

464
00:13:59,519 --> 00:14:03,440
things it will not you know attack your

465
00:14:01,760 --> 00:14:06,000
computer in addition to that

466
00:14:03,440 --> 00:14:07,279
so this turned out to be pretty cool um

467
00:14:06,000 --> 00:14:09,199
and it also has some really advanced

468
00:14:07,279 --> 00:14:10,079
proof capabilities which we're looking

469
00:14:09,199 --> 00:14:11,839
into

470
00:14:10,079 --> 00:14:13,199
um answer set programming is is the

471
00:14:11,839 --> 00:14:14,880
other one that we looked into

472
00:14:13,199 --> 00:14:16,800
um there's a really capable answer set

473
00:14:14,880 --> 00:14:18,720
solver called patasco

474
00:14:16,800 --> 00:14:20,240
or i guess the solver is called clasp

475
00:14:18,720 --> 00:14:22,160
the package is called clingo

476
00:14:20,240 --> 00:14:23,760
and the project is called patasco so i

477
00:14:22,160 --> 00:14:26,480
don't know exactly what to call it

478
00:14:23,760 --> 00:14:28,240
but that's that's the project this seems

479
00:14:26,480 --> 00:14:28,639
like the most active asp project right

480
00:14:28,240 --> 00:14:30,639
now

481
00:14:28,639 --> 00:14:33,600
and no this is not active server pages

482
00:14:30,639 --> 00:14:35,600
this is this is answer set programming

483
00:14:33,600 --> 00:14:37,120
um and the cool thing about this is that

484
00:14:35,600 --> 00:14:39,120
it's a very high level language

485
00:14:37,120 --> 00:14:40,639
so you can write your constraints in

486
00:14:39,120 --> 00:14:43,920
something that looks like prologue who's

487
00:14:40,639 --> 00:14:44,240
who's programmed in prologue yeah um

488
00:14:43,920 --> 00:14:45,760
which

489
00:14:44,240 --> 00:14:47,440
which is kind of nice right it's nicer

490
00:14:45,760 --> 00:14:50,720
than boolean

491
00:14:47,440 --> 00:14:51,519
clauses um and it makes for very short

492
00:14:50,720 --> 00:14:53,440
programs

493
00:14:51,519 --> 00:14:54,639
um it boils down to sat and they do

494
00:14:53,440 --> 00:14:55,279
optimization and some of these other

495
00:14:54,639 --> 00:14:57,440
things

496
00:14:55,279 --> 00:14:58,560
so we we ended up deciding to implement

497
00:14:57,440 --> 00:15:02,480
our new solver

498
00:14:58,560 --> 00:15:02,479
in asp to see how that would do

499
00:15:02,639 --> 00:15:05,920
so this is what it looks like we use

500
00:15:05,440 --> 00:15:07,920
clingo

501
00:15:05,920 --> 00:15:10,079
that's the package i'm talking about the

502
00:15:07,920 --> 00:15:11,120
asp program basically has two parts

503
00:15:10,079 --> 00:15:12,880
instead of what i was talking about

504
00:15:11,120 --> 00:15:14,480
before where we would basically

505
00:15:12,880 --> 00:15:17,439
iteratively construct the dag

506
00:15:14,480 --> 00:15:19,040
um what we're doing is uh we we generate

507
00:15:17,440 --> 00:15:20,639
a big list of facts from all of our

508
00:15:19,040 --> 00:15:22,800
package files and all of the different

509
00:15:20,639 --> 00:15:25,680
uh preferences files that we have

510
00:15:22,800 --> 00:15:26,000
um for the solve and so that tends to be

511
00:15:25,680 --> 00:15:27,519
and

512
00:15:26,000 --> 00:15:29,040
you know these are surprising numbers if

513
00:15:27,519 --> 00:15:30,480
you if you but if you think about the

514
00:15:29,040 --> 00:15:31,199
size of the package ecosystem that makes

515
00:15:30,480 --> 00:15:32,880
sense

516
00:15:31,199 --> 00:15:35,199
um it's like six thousand to nine

517
00:15:32,880 --> 00:15:36,880
thousand facts for our typical solves

518
00:15:35,199 --> 00:15:38,319
um and and so these are these really

519
00:15:36,880 --> 00:15:39,839
long files they look like this

520
00:15:38,320 --> 00:15:41,360
it just says hey this package has this

521
00:15:39,839 --> 00:15:42,720
version declared this package has this

522
00:15:41,360 --> 00:15:44,160
option this package has

523
00:15:42,720 --> 00:15:46,320
you know these criteria or these

524
00:15:44,160 --> 00:15:48,000
conflicts all of that goes into just a

525
00:15:46,320 --> 00:15:48,959
pure list of statements that say this is

526
00:15:48,000 --> 00:15:50,800
true

527
00:15:48,959 --> 00:15:53,279
um and then there's a really small logic

528
00:15:50,800 --> 00:15:55,279
program like 130 lines

529
00:15:53,279 --> 00:15:56,639
that we concatenate with that and throw

530
00:15:55,279 --> 00:15:58,639
into the solver

531
00:15:56,639 --> 00:16:00,160
and um the new algorithm it's pretty

532
00:15:58,639 --> 00:16:01,279
it's conceptually much simpler you

533
00:16:00,160 --> 00:16:02,560
generate all the facts you

534
00:16:01,279 --> 00:16:04,480
you concatenate it you send it to the

535
00:16:02,560 --> 00:16:05,839
solver you take the result that it spits

536
00:16:04,480 --> 00:16:06,399
back at you and you build the dag out of

537
00:16:05,839 --> 00:16:09,120
that

538
00:16:06,399 --> 00:16:10,240
and so um that's pretty this is a pretty

539
00:16:09,120 --> 00:16:12,160
big win

540
00:16:10,240 --> 00:16:13,440
um the solve time itself is much faster

541
00:16:12,160 --> 00:16:14,639
than the existing concretizer just

542
00:16:13,440 --> 00:16:16,079
because we're calling out to a native

543
00:16:14,639 --> 00:16:16,880
package so it's like a fraction of the

544
00:16:16,079 --> 00:16:20,239
second

545
00:16:16,880 --> 00:16:22,560
for the actual solve um but for

546
00:16:20,240 --> 00:16:23,920
um for the actual generation of the

547
00:16:22,560 --> 00:16:25,040
program that's the bottleneck right now

548
00:16:23,920 --> 00:16:26,399
we're in python so

549
00:16:25,040 --> 00:16:28,079
actually generating all the strings to

550
00:16:26,399 --> 00:16:29,040
send to the solver takes the bulk of the

551
00:16:28,079 --> 00:16:31,199
time

552
00:16:29,040 --> 00:16:33,599
so we're working on you know making that

553
00:16:31,199 --> 00:16:33,599
faster

554
00:16:33,680 --> 00:16:36,880
and so just to give you sort of a flavor

555
00:16:35,279 --> 00:16:38,639
of what this looks like

556
00:16:36,880 --> 00:16:40,560
asp makes it pretty easy to put what was

557
00:16:38,639 --> 00:16:41,680
once very complicated logic in sort of

558
00:16:40,560 --> 00:16:44,560
our custom solver

559
00:16:41,680 --> 00:16:46,079
into one place so um the things that you

560
00:16:44,560 --> 00:16:47,119
do when you're writing an asp solver are

561
00:16:46,079 --> 00:16:48,880
you define the space

562
00:16:47,120 --> 00:16:50,560
this just says that there's you know for

563
00:16:48,880 --> 00:16:51,920
every node in the dag it has one

564
00:16:50,560 --> 00:16:53,518
possible version that's it these are

565
00:16:51,920 --> 00:16:54,639
cardinality rules they say i have one

566
00:16:53,519 --> 00:16:56,720
version per node

567
00:16:54,639 --> 00:16:57,920
that's what my space looks like at least

568
00:16:56,720 --> 00:17:00,079
for this part

569
00:16:57,920 --> 00:17:01,599
um this says don't allow conflicting

570
00:17:00,079 --> 00:17:03,120
versions and then this part down here

571
00:17:01,600 --> 00:17:04,480
just says hey if i declared a version

572
00:17:03,120 --> 00:17:05,919
with a particular weight if i had a

573
00:17:04,480 --> 00:17:08,720
particular preference on it

574
00:17:05,919 --> 00:17:10,480
then give it that weight in the dag and

575
00:17:08,720 --> 00:17:11,520
then this is a minimization statement it

576
00:17:10,480 --> 00:17:13,120
says minimize

577
00:17:11,520 --> 00:17:15,599
the total weight for all the versions in

578
00:17:13,119 --> 00:17:18,639
the dag and so this is really concise

579
00:17:15,599 --> 00:17:20,319
it's pretty cool it takes a

580
00:17:18,640 --> 00:17:21,600
bit of cognitive load to get into this

581
00:17:20,319 --> 00:17:23,039
mode of thinking and to start writing

582
00:17:21,599 --> 00:17:24,559
these things down so like

583
00:17:23,039 --> 00:17:26,720
despite the fact that this is like four

584
00:17:24,559 --> 00:17:28,240
lines of code it took me a lot longer to

585
00:17:26,720 --> 00:17:29,679
think about this than it did

586
00:17:28,240 --> 00:17:31,440
about other lines of code that i might

587
00:17:29,679 --> 00:17:34,960
write

588
00:17:31,440 --> 00:17:36,799
um other stuff became simple too um

589
00:17:34,960 --> 00:17:38,160
this is the compiler target optimization

590
00:17:36,799 --> 00:17:38,559
i was talking about we have stuff in

591
00:17:38,160 --> 00:17:41,280
spac

592
00:17:38,559 --> 00:17:42,399
that tells us which compiler versions

593
00:17:41,280 --> 00:17:43,360
can generate code for which

594
00:17:42,400 --> 00:17:44,799
architectures

595
00:17:43,360 --> 00:17:45,760
and so if you have a bunch of compilers

596
00:17:44,799 --> 00:17:47,120
available and you have a bunch of

597
00:17:45,760 --> 00:17:48,160
architectures that you could build for

598
00:17:47,120 --> 00:17:49,678
because you know that you're on like a

599
00:17:48,160 --> 00:17:50,799
haswell system

600
00:17:49,679 --> 00:17:52,320
and you know that the compilers can

601
00:17:50,799 --> 00:17:54,000
generate up to ice lake or something

602
00:17:52,320 --> 00:17:55,760
like that

603
00:17:54,000 --> 00:17:57,440
picking a compiler and picking a target

604
00:17:55,760 --> 00:17:58,640
is it's not 100 straightforward if the

605
00:17:57,440 --> 00:17:59,760
user said they want to build with a

606
00:17:58,640 --> 00:18:01,039
particular compiler

607
00:17:59,760 --> 00:18:02,960
you may have to downgrade the target

608
00:18:01,039 --> 00:18:04,080
that you build for and so this allows us

609
00:18:02,960 --> 00:18:06,400
to solve for that

610
00:18:04,080 --> 00:18:08,159
at the same time and it and it was

611
00:18:06,400 --> 00:18:08,960
previously like this sort of staged

612
00:18:08,160 --> 00:18:10,480
logic

613
00:18:08,960 --> 00:18:12,000
but now we're able to do something much

614
00:18:10,480 --> 00:18:13,280
simpler where

615
00:18:12,000 --> 00:18:15,600
essentially you know we say there's one

616
00:18:13,280 --> 00:18:17,360
target per node we say you can't

617
00:18:15,600 --> 00:18:19,280
have a node where the compiler doesn't

618
00:18:17,360 --> 00:18:20,639
support the target that's assigned to it

619
00:18:19,280 --> 00:18:22,559
and then the rest is just optimization

620
00:18:20,640 --> 00:18:24,240
like the other ones and so this works

621
00:18:22,559 --> 00:18:25,840
out to be very simple like this this was

622
00:18:24,240 --> 00:18:26,799
super exciting that all it took was like

623
00:18:25,840 --> 00:18:28,000
this line

624
00:18:26,799 --> 00:18:31,360
and all of a sudden the targets are

625
00:18:28,000 --> 00:18:31,360
right because we told it what was wrong

626
00:18:31,840 --> 00:18:35,918
so the dependency logic is also pretty

627
00:18:34,000 --> 00:18:37,760
concise we can easily take constraints

628
00:18:35,919 --> 00:18:39,360
from different places

629
00:18:37,760 --> 00:18:40,720
we can do virtual dependencies and so

630
00:18:39,360 --> 00:18:41,439
this is all the logic that it takes to

631
00:18:40,720 --> 00:18:44,559
say

632
00:18:41,440 --> 00:18:46,160
you know i if i depend on mpi i can act

633
00:18:44,559 --> 00:18:48,080
i actually depend on m pitch and that

634
00:18:46,160 --> 00:18:49,840
[ __ ] or open mpi the implementations of

635
00:18:48,080 --> 00:18:53,120
the mpi interface

636
00:18:49,840 --> 00:18:55,280
so all that's in there and

637
00:18:53,120 --> 00:18:56,159
constraints like i can only have one

638
00:18:55,280 --> 00:18:58,960
provider

639
00:18:56,160 --> 00:19:00,559
for mpi in my dag if i if i have both

640
00:18:58,960 --> 00:19:02,160
open mpi and in pitch

641
00:19:00,559 --> 00:19:04,080
in the same dag that's bad because the

642
00:19:02,160 --> 00:19:06,720
symbols will conflict and so i can put

643
00:19:04,080 --> 00:19:08,399
constraints like that in there

644
00:19:06,720 --> 00:19:10,799
not all of this was simple like i said

645
00:19:08,400 --> 00:19:12,000
the learning curve is pretty high

646
00:19:10,799 --> 00:19:14,000
and there's a lot of thought that goes

647
00:19:12,000 --> 00:19:15,360
into every line of code

648
00:19:14,000 --> 00:19:18,000
and structuring the optimization

649
00:19:15,360 --> 00:19:19,520
criteria can be a challenge so

650
00:19:18,000 --> 00:19:21,039
when i first started doing this i wrote

651
00:19:19,520 --> 00:19:24,240
my criteria as sort of

652
00:19:21,039 --> 00:19:26,320
maximize constraints and um

653
00:19:24,240 --> 00:19:27,760
instead of and so that led to some

654
00:19:26,320 --> 00:19:29,039
surprising behavior so like

655
00:19:27,760 --> 00:19:31,039
you know i would i would solve what i

656
00:19:29,039 --> 00:19:31,360
thought was a pretty small dag but i

657
00:19:31,039 --> 00:19:33,520
said

658
00:19:31,360 --> 00:19:34,799
maximize the number of build options set

659
00:19:33,520 --> 00:19:36,799
to their default value

660
00:19:34,799 --> 00:19:38,559
and it was like oh hey i can just add

661
00:19:36,799 --> 00:19:39,440
more packages to this tag to get more

662
00:19:38,559 --> 00:19:41,200
build options

663
00:19:39,440 --> 00:19:43,200
set to the default value and so i would

664
00:19:41,200 --> 00:19:45,600
get these giant dags out of the thing

665
00:19:43,200 --> 00:19:47,200
and and so you you have to think about

666
00:19:45,600 --> 00:19:48,159
how you formulate the constraints so

667
00:19:47,200 --> 00:19:49,520
most of the constraints are now

668
00:19:48,160 --> 00:19:53,039
minimizing

669
00:19:49,520 --> 00:19:54,639
so that the dag stays pretty small

670
00:19:53,039 --> 00:19:56,720
one interesting example that i think is

671
00:19:54,640 --> 00:19:58,160
kind of funny is the the previous

672
00:19:56,720 --> 00:19:58,679
version of the solver if you said spack

673
00:19:58,160 --> 00:20:01,280
install

674
00:19:58,679 --> 00:20:02,159
hdf5 within pitch users would get

675
00:20:01,280 --> 00:20:05,280
annoyed

676
00:20:02,159 --> 00:20:06,960
that says install the hdf5 library

677
00:20:05,280 --> 00:20:08,480
with the mpi implementation as inpitch

678
00:20:06,960 --> 00:20:10,000
usually we get annoyed because it

679
00:20:08,480 --> 00:20:11,760
doesn't it wasn't smart enough to say oh

680
00:20:10,000 --> 00:20:12,880
i have to turn on the mpi support to

681
00:20:11,760 --> 00:20:14,240
make that happen

682
00:20:12,880 --> 00:20:16,240
right and so users would have to write

683
00:20:14,240 --> 00:20:19,840
this instead and so that's fine that

684
00:20:16,240 --> 00:20:22,000
that gives you a pretty nice small dag

685
00:20:19,840 --> 00:20:23,678
the the new solver can be pretty smart

686
00:20:22,000 --> 00:20:25,440
and so if i i was like okay

687
00:20:23,679 --> 00:20:26,720
obviously this will fail if i say don't

688
00:20:25,440 --> 00:20:28,799
build it with mpi

689
00:20:26,720 --> 00:20:31,120
and build it with them pitch in the dag

690
00:20:28,799 --> 00:20:34,240
but no it actually was like oh i see

691
00:20:31,120 --> 00:20:35,439
that if i make the um if i depend on

692
00:20:34,240 --> 00:20:37,280
live aec

693
00:20:35,440 --> 00:20:38,799
and which depends on cmake which depends

694
00:20:37,280 --> 00:20:39,440
on live archive which depends on lz4

695
00:20:38,799 --> 00:20:41,840
valgrind

696
00:20:39,440 --> 00:20:43,919
and then valgrind has an option for mpi

697
00:20:41,840 --> 00:20:46,559
um i can get m pitch in your dag like

698
00:20:43,919 --> 00:20:48,559
right there so i'll make it happen for

699
00:20:46,559 --> 00:20:49,760
you

700
00:20:48,559 --> 00:20:51,918
there you have to put some other

701
00:20:49,760 --> 00:20:53,200
constraints in to make this same and so

702
00:20:51,919 --> 00:20:55,039
i think you know what we'll do

703
00:20:53,200 --> 00:20:56,640
is basically say don't search through

704
00:20:55,039 --> 00:20:57,520
build dependencies for things like this

705
00:20:56,640 --> 00:21:00,720
where you're saying

706
00:20:57,520 --> 00:21:02,480
definitely include this note in the tag

707
00:21:00,720 --> 00:21:03,919
but you know in general this is pretty

708
00:21:02,480 --> 00:21:05,360
exciting because it means you can solve

709
00:21:03,919 --> 00:21:08,000
for some pretty complicated things you

710
00:21:05,360 --> 00:21:08,479
can see up here it tried 338 different

711
00:21:08,000 --> 00:21:10,720
models

712
00:21:08,480 --> 00:21:12,159
and compared them all figured out this

713
00:21:10,720 --> 00:21:13,520
was the optimal one for that particular

714
00:21:12,159 --> 00:21:16,080
configuration

715
00:21:13,520 --> 00:21:17,280
and it was pretty cool getting errors is

716
00:21:16,080 --> 00:21:20,320
still a little tough

717
00:21:17,280 --> 00:21:22,559
the asp solvers don't have

718
00:21:20,320 --> 00:21:24,320
good mechanisms for getting what's

719
00:21:22,559 --> 00:21:25,600
called unsatisfiable cores out sort of

720
00:21:24,320 --> 00:21:27,280
the minimum set of constraints that

721
00:21:25,600 --> 00:21:29,840
aren't satisfiable

722
00:21:27,280 --> 00:21:30,639
they also don't have proof generation

723
00:21:29,840 --> 00:21:33,520
and so

724
00:21:30,640 --> 00:21:34,480
one interesting thing about z3 the smt

725
00:21:33,520 --> 00:21:36,240
solver

726
00:21:34,480 --> 00:21:38,240
is that it can actually generate you a

727
00:21:36,240 --> 00:21:40,640
pretty cool proof of you know

728
00:21:38,240 --> 00:21:42,159
why was this dag unsatisfiable and so i

729
00:21:40,640 --> 00:21:43,679
think we could take that and potentially

730
00:21:42,159 --> 00:21:45,200
parse it and do something with it to

731
00:21:43,679 --> 00:21:46,400
make it look like the good output from

732
00:21:45,200 --> 00:21:48,559
pubgrub

733
00:21:46,400 --> 00:21:50,559
but the z3 proofs are pretty involved if

734
00:21:48,559 --> 00:21:51,360
anyone's ever seen a z3 proof it is not

735
00:21:50,559 --> 00:21:53,760
like

736
00:21:51,360 --> 00:21:54,799
it's not in english it is in in some

737
00:21:53,760 --> 00:21:56,840
other language

738
00:21:54,799 --> 00:21:58,080
and so so parsing that it will be

739
00:21:56,840 --> 00:22:01,039
interesting

740
00:21:58,080 --> 00:22:01,360
um so anyway that's where we're at right

741
00:22:01,039 --> 00:22:03,840
now

742
00:22:01,360 --> 00:22:05,678
um we have a working prototype um it's

743
00:22:03,840 --> 00:22:06,799
pretty satisfying to see it solve cases

744
00:22:05,679 --> 00:22:09,360
where we couldn't solve

745
00:22:06,799 --> 00:22:10,639
things before and you know we've managed

746
00:22:09,360 --> 00:22:12,479
to pull a lot of stuff

747
00:22:10,640 --> 00:22:14,559
that is typically sort of assumed by the

748
00:22:12,480 --> 00:22:14,880
distro or assumed by the build system or

749
00:22:14,559 --> 00:22:16,960
just

750
00:22:14,880 --> 00:22:18,720
kind of has to be tweaked by humans in

751
00:22:16,960 --> 00:22:20,159
the package curation process

752
00:22:18,720 --> 00:22:22,000
up into the solver so that you can

753
00:22:20,159 --> 00:22:24,559
actually solve for configurations

754
00:22:22,000 --> 00:22:26,080
and so so the goal here like i said is

755
00:22:24,559 --> 00:22:28,080
to make it so that people can have nice

756
00:22:26,080 --> 00:22:29,120
things in hpc so that it's easy to build

757
00:22:28,080 --> 00:22:31,360
on a new system

758
00:22:29,120 --> 00:22:32,959
and to get a new dag working in a place

759
00:22:31,360 --> 00:22:35,360
you haven't built it before

760
00:22:32,960 --> 00:22:37,600
um it would be really cool to be able to

761
00:22:35,360 --> 00:22:40,240
use tools like fatsin for deeper salts

762
00:22:37,600 --> 00:22:42,080
and so you know it the cnc plus and

763
00:22:40,240 --> 00:22:43,679
4chan world are like absolutely horrible

764
00:22:42,080 --> 00:22:45,199
at sember because it didn't exist when

765
00:22:43,679 --> 00:22:47,760
they started existing

766
00:22:45,200 --> 00:22:48,960
um and and so we don't really know the

767
00:22:47,760 --> 00:22:51,760
compatibility between

768
00:22:48,960 --> 00:22:53,360
uh packages and people tend to write

769
00:22:51,760 --> 00:22:55,280
their package constraints

770
00:22:53,360 --> 00:22:56,559
humans generate those they generate them

771
00:22:55,280 --> 00:22:58,080
either based on you know what they know

772
00:22:56,559 --> 00:22:58,720
what was the first version that i tested

773
00:22:58,080 --> 00:23:00,639
with

774
00:22:58,720 --> 00:23:01,840
um or you know what what have they

775
00:23:00,640 --> 00:23:03,039
actually tested with

776
00:23:01,840 --> 00:23:04,720
and typically that's kind of over

777
00:23:03,039 --> 00:23:05,760
constrained right you could get a dag

778
00:23:04,720 --> 00:23:07,280
working

779
00:23:05,760 --> 00:23:08,879
with a different version of a library

780
00:23:07,280 --> 00:23:10,080
most likely if it was pretty close to

781
00:23:08,880 --> 00:23:12,240
what you had

782
00:23:10,080 --> 00:23:13,840
in the tested configuration and so we

783
00:23:12,240 --> 00:23:15,120
could use information like the call

784
00:23:13,840 --> 00:23:16,480
graph stuff to figure out you know are

785
00:23:15,120 --> 00:23:18,158
the entry points and exit points of

786
00:23:16,480 --> 00:23:20,400
libraries compatible

787
00:23:18,159 --> 00:23:21,760
could we plug this other package in you

788
00:23:20,400 --> 00:23:22,559
know at more versions than maybe the

789
00:23:21,760 --> 00:23:25,039
humans

790
00:23:22,559 --> 00:23:25,678
um specified but prefer the tested

791
00:23:25,039 --> 00:23:26,960
version

792
00:23:25,679 --> 00:23:29,039
um while allowing you know more

793
00:23:26,960 --> 00:23:30,559
divergence to get things working

794
00:23:29,039 --> 00:23:32,559
um other stuff that we'd like to be able

795
00:23:30,559 --> 00:23:33,520
to do that i think we can do with this

796
00:23:32,559 --> 00:23:35,440
new solver is

797
00:23:33,520 --> 00:23:37,039
solve for cross-compiled build dags so

798
00:23:35,440 --> 00:23:38,559
actually do things like

799
00:23:37,039 --> 00:23:40,240
if something has a build and a link

800
00:23:38,559 --> 00:23:41,440
dependency on a library

801
00:23:40,240 --> 00:23:42,720
build it once for the front end

802
00:23:41,440 --> 00:23:44,000
environment where we're compiling and

803
00:23:42,720 --> 00:23:45,200
build it again for the back end

804
00:23:44,000 --> 00:23:46,720
environment where we would be running

805
00:23:45,200 --> 00:23:47,679
and so figure out where to split nodes

806
00:23:46,720 --> 00:23:49,200
in the dag

807
00:23:47,679 --> 00:23:51,520
um i think i think we could definitely

808
00:23:49,200 --> 00:23:53,039
do that um do things like compiler

809
00:23:51,520 --> 00:23:54,000
runtime compatibility and make sure that

810
00:23:53,039 --> 00:23:55,600
your lib standard c

811
00:23:54,000 --> 00:23:57,440
plus library is consistent across your

812
00:23:55,600 --> 00:23:59,199
dag um that's a thing that bites our

813
00:23:57,440 --> 00:24:00,799
users very frequently if we

814
00:23:59,200 --> 00:24:02,559
get ahead of the system lib standard c

815
00:24:00,799 --> 00:24:03,840
plus plus um

816
00:24:02,559 --> 00:24:05,678
and then you know do things like

817
00:24:03,840 --> 00:24:08,080
integrate licenses into the solve

818
00:24:05,679 --> 00:24:09,520
um so that's where we're at um if you

819
00:24:08,080 --> 00:24:12,080
want stickers for spec they're up there

820
00:24:09,520 --> 00:24:19,840
on the front row so grab one

821
00:24:12,080 --> 00:24:19,840
and i'll take questions

822
00:24:24,880 --> 00:24:33,840
sorry i can't hear you oh 25

823
00:24:28,720 --> 00:24:33,840
okay right here

824
00:24:42,559 --> 00:24:49,520
this one right here so this just says

825
00:24:45,840 --> 00:24:52,000
install hdf5 where hdf5 has mpi disabled

826
00:24:49,520 --> 00:24:52,559
right so on this node up here it says

827
00:24:52,000 --> 00:24:55,600
turn off

828
00:24:52,559 --> 00:24:58,080
mpi support right um and this says

829
00:24:55,600 --> 00:24:59,439
m-pitch has to be a node in the graph

830
00:24:58,080 --> 00:25:00,559
right and m-pitch is an mpi

831
00:24:59,440 --> 00:25:02,400
implementation

832
00:25:00,559 --> 00:25:03,840
and so what it does is it says it

833
00:25:02,400 --> 00:25:06,000
searches all the configurations right

834
00:25:03,840 --> 00:25:08,639
this isn't like an np complete solve

835
00:25:06,000 --> 00:25:09,840
and and it says oh look valgrind can

836
00:25:08,640 --> 00:25:12,400
have an mpi option

837
00:25:09,840 --> 00:25:13,678
so i can disable mpi on hdf5 and not

838
00:25:12,400 --> 00:25:15,679
link mpi to it

839
00:25:13,679 --> 00:25:16,880
but i'll turn on val mpi support for

840
00:25:15,679 --> 00:25:19,600
valgrind

841
00:25:16,880 --> 00:25:21,679
get in pitch in the dag that way and oh

842
00:25:19,600 --> 00:25:22,480
that this is how i get to it right so it

843
00:25:21,679 --> 00:25:25,679
finds that

844
00:25:22,480 --> 00:25:26,720
um pretty quickly and yeah so at first i

845
00:25:25,679 --> 00:25:27,279
thought this was a bug and then i was

846
00:25:26,720 --> 00:25:30,080
like no

847
00:25:27,279 --> 00:25:30,640
no it's it's right for some definition

848
00:25:30,080 --> 00:25:32,879
of right

849
00:25:30,640 --> 00:25:32,880
yep

850
00:25:33,919 --> 00:25:36,159
sorry

851
00:25:37,440 --> 00:25:40,880
you can't i mean so there's it

852
00:25:39,039 --> 00:25:42,240
considered 338 right

853
00:25:40,880 --> 00:25:43,679
and and that's less than the total

854
00:25:42,240 --> 00:25:44,320
number of solutions that you could find

855
00:25:43,679 --> 00:25:46,480
for this

856
00:25:44,320 --> 00:25:48,158
um it's that's how many had to consider

857
00:25:46,480 --> 00:25:50,720
to find an optimal one

858
00:25:48,159 --> 00:25:52,000
by the criteria that we used so yes it

859
00:25:50,720 --> 00:25:53,600
considered a lot of solutions

860
00:25:52,000 --> 00:25:55,120
you can get this thing to spit out all

861
00:25:53,600 --> 00:25:56,959
the solutions but if you try that on a

862
00:25:55,120 --> 00:25:58,399
bag like this it's going to sit there

863
00:25:56,960 --> 00:26:00,240
for a long time generating

864
00:25:58,400 --> 00:26:01,600
you know different configurations so i

865
00:26:00,240 --> 00:26:03,360
guess if you consider that we have more

866
00:26:01,600 --> 00:26:07,918
packages than npm

867
00:26:03,360 --> 00:26:09,439
but sorry no this is the optimal one

868
00:26:07,919 --> 00:26:10,880
so it's doing it's doing both a sat

869
00:26:09,440 --> 00:26:12,400
solve to make sure that the constraints

870
00:26:10,880 --> 00:26:14,080
are correct and it's saying

871
00:26:12,400 --> 00:26:17,440
oh if i go down that path everything

872
00:26:14,080 --> 00:26:17,439
will get worse right and so

873
00:26:18,559 --> 00:26:22,240
no it doesn't because i know that if i

874
00:26:20,480 --> 00:26:23,840
go down a certain path it can eliminate

875
00:26:22,240 --> 00:26:24,640
options and say nothing down that path

876
00:26:23,840 --> 00:26:26,799
is good

877
00:26:24,640 --> 00:26:28,480
so i'll consider yeah so yes in the

878
00:26:26,799 --> 00:26:30,400
worst case it would require you to do

879
00:26:28,480 --> 00:26:33,039
that and so yes this is np complete

880
00:26:30,400 --> 00:26:34,480
it can get bad yeah how does it know

881
00:26:33,039 --> 00:26:38,080
something is bad

882
00:26:34,480 --> 00:26:39,760
because weights so yeah we have weights

883
00:26:38,080 --> 00:26:42,158
yeah like the minimization criteria that

884
00:26:39,760 --> 00:26:44,480
i showed back here like so see down here

885
00:26:42,159 --> 00:26:45,440
in in the the thing that we generate

886
00:26:44,480 --> 00:26:47,279
right we

887
00:26:45,440 --> 00:26:49,200
we have our preferences file and so we

888
00:26:47,279 --> 00:26:50,559
say like okay the user really likes this

889
00:26:49,200 --> 00:26:52,559
version so we'll put it at the top

890
00:26:50,559 --> 00:26:54,158
the next best version is the latest and

891
00:26:52,559 --> 00:26:55,760
the next latest and so on

892
00:26:54,159 --> 00:26:57,200
we weight them that way and then we take

893
00:26:55,760 --> 00:26:59,039
the weight and we put it in the salt

894
00:26:57,200 --> 00:27:00,640
and so that's what this is doing um and

895
00:26:59,039 --> 00:27:02,240
so like in the end we have like about

896
00:27:00,640 --> 00:27:03,679
seven different criteria for this

897
00:27:02,240 --> 00:27:05,120
and and you pick an order

898
00:27:03,679 --> 00:27:06,240
lexicographically that you want them

899
00:27:05,120 --> 00:27:07,840
optimized

900
00:27:06,240 --> 00:27:10,480
and it comes up with an optimal solution

901
00:27:07,840 --> 00:27:10,480
according to that

902
00:27:10,960 --> 00:27:13,600
other questions

903
00:27:15,919 --> 00:27:20,880
um it's doing like a cdcl solve so it's

904
00:27:18,960 --> 00:27:23,039
conflict-driven clause learning

905
00:27:20,880 --> 00:27:24,640
um so it's doing that at the same time

906
00:27:23,039 --> 00:27:26,240
as doing like a simplex or some other

907
00:27:24,640 --> 00:27:27,360
kind of optimization algorithm which

908
00:27:26,240 --> 00:27:29,360
which is why i didn't want to write this

909
00:27:27,360 --> 00:27:31,439
myself because i just like integrating

910
00:27:29,360 --> 00:27:33,600
those two things seems like a nightmare

911
00:27:31,440 --> 00:27:35,279
um there's papers about it but yeah it's

912
00:27:33,600 --> 00:27:39,120
doing it's doing a lot of

913
00:27:35,279 --> 00:27:39,120
smart stuff to find the right solution

914
00:27:39,440 --> 00:27:42,640
is doing the the technique itself or is

915
00:27:42,240 --> 00:27:45,679
it just

916
00:27:42,640 --> 00:27:48,880
uh something like an

917
00:27:45,679 --> 00:27:49,679
rpm oh no so it's back it's back builds

918
00:27:48,880 --> 00:27:51,919
packages too

919
00:27:49,679 --> 00:27:53,039
so it's end to end you're you you have a

920
00:27:51,919 --> 00:27:54,880
bunch of package

921
00:27:53,039 --> 00:27:56,158
files that are basically recipes plus

922
00:27:54,880 --> 00:27:58,480
these constraints

923
00:27:56,159 --> 00:27:59,919
um for basically they define the space

924
00:27:58,480 --> 00:28:01,840
of packages you can build

925
00:27:59,919 --> 00:28:03,279
and once you get a configuration like

926
00:28:01,840 --> 00:28:05,840
you know um

927
00:28:03,279 --> 00:28:06,960
like this we hand that to the build and

928
00:28:05,840 --> 00:28:08,879
we say that you know

929
00:28:06,960 --> 00:28:10,480
go build this right and the packages are

930
00:28:08,880 --> 00:28:12,399
written so that they query the dag for

931
00:28:10,480 --> 00:28:13,679
what to build

932
00:28:12,399 --> 00:28:15,760
and so like if you wanted to think about

933
00:28:13,679 --> 00:28:17,600
reproducible builds in this context

934
00:28:15,760 --> 00:28:19,679
it wouldn't be like there's one source

935
00:28:17,600 --> 00:28:21,199
and one binary that corresponds to it

936
00:28:19,679 --> 00:28:23,200
it would be more like there's one source

937
00:28:21,200 --> 00:28:26,480
there's this configuration in a binary

938
00:28:23,200 --> 00:28:26,480
and that should be reproducible

939
00:28:28,840 --> 00:28:31,840
yep

940
00:28:42,840 --> 00:28:47,840
because um i guess i don't i didn't

941
00:28:46,720 --> 00:28:48,720
fully understand the question have we

942
00:28:47,840 --> 00:28:52,240
considered

943
00:28:48,720 --> 00:28:59,840
what you have requirements yes

944
00:28:52,240 --> 00:28:59,840
you can make them all optional yes

945
00:29:01,120 --> 00:29:04,799
yeah you can so i mean the iterative way

946
00:29:03,120 --> 00:29:06,639
of debugging these programs is typically

947
00:29:04,799 --> 00:29:09,760
to sort of comment out constraints and

948
00:29:06,640 --> 00:29:09,760
see which ones make it work

949
00:29:10,840 --> 00:29:13,840
right

950
00:29:14,880 --> 00:29:18,880
yeah yeah that's that's sort of what the

951
00:29:17,120 --> 00:29:19,760
the proof generator that i talked about

952
00:29:18,880 --> 00:29:22,480
for z3

953
00:29:19,760 --> 00:29:24,000
and what the sort of unsat core um thing

954
00:29:22,480 --> 00:29:25,679
will do for you it'll say here's

955
00:29:24,000 --> 00:29:27,360
these are the cores i found for this

956
00:29:25,679 --> 00:29:28,799
problem that are completely

957
00:29:27,360 --> 00:29:30,719
unsatisfiable if these are in your

958
00:29:28,799 --> 00:29:32,080
problem it won't be satisfiable

959
00:29:30,720 --> 00:29:33,120
so i think we can do something based on

960
00:29:32,080 --> 00:29:34,720
that because that's essentially what

961
00:29:33,120 --> 00:29:36,158
pubgrub and other systems do

962
00:29:34,720 --> 00:29:40,320
they build proofs or they look at the

963
00:29:36,159 --> 00:29:41,919
unsat cores we just haven't done it yet

964
00:29:40,320 --> 00:29:43,600
how do you deal with the change of

965
00:29:41,919 --> 00:29:45,600
behavior in the spot

966
00:29:43,600 --> 00:29:47,360
so from the first line to the second

967
00:29:45,600 --> 00:29:50,639
line you because

968
00:29:47,360 --> 00:29:50,879
there is a change in behavior yes so if

969
00:29:50,640 --> 00:29:52,640
you

970
00:29:50,880 --> 00:29:54,159
so that this depends on all the stuff

971
00:29:52,640 --> 00:29:54,720
that i said went into the concretizer

972
00:29:54,159 --> 00:29:56,080
right

973
00:29:54,720 --> 00:29:58,240
so it's what you wrote on the command

974
00:29:56,080 --> 00:29:58,960
line it's all this stuff this goes into

975
00:29:58,240 --> 00:30:01,919
the solve

976
00:29:58,960 --> 00:30:02,640
right but we do spit out a lock file

977
00:30:01,919 --> 00:30:05,279
right

978
00:30:02,640 --> 00:30:06,240
so like if if you once you solve and you

979
00:30:05,279 --> 00:30:08,399
get a solution

980
00:30:06,240 --> 00:30:09,760
right we spit it out as json and you can

981
00:30:08,399 --> 00:30:11,279
go and reload that and

982
00:30:09,760 --> 00:30:13,039
rebuild the same thing again if you want

983
00:30:11,279 --> 00:30:15,200
to exactly right

984
00:30:13,039 --> 00:30:16,320
and then in in another sort of sense you

985
00:30:15,200 --> 00:30:17,760
can take this

986
00:30:16,320 --> 00:30:19,520
and use it as sort of a reproducible

987
00:30:17,760 --> 00:30:21,760
description but cross-platform

988
00:30:19,520 --> 00:30:23,120
you could take this and re-concretize it

989
00:30:21,760 --> 00:30:24,720
on a new machine and get something that

990
00:30:23,120 --> 00:30:26,320
meets these constraints

991
00:30:24,720 --> 00:30:29,440
um but you know it may be slightly

992
00:30:26,320 --> 00:30:29,439
different underneath to make it work

993
00:30:30,559 --> 00:30:34,320
it's reproducible on the same machine

994
00:30:32,399 --> 00:30:36,000
with the same inputs right like that and

995
00:30:34,320 --> 00:30:38,639
so you have the inputs you can reproduce

996
00:30:36,000 --> 00:30:40,320
what you what you did what's different

997
00:30:38,640 --> 00:30:41,840
is that you can tweak it more easily and

998
00:30:40,320 --> 00:30:44,240
you can produce different configurations

999
00:30:41,840 --> 00:30:44,240
faster

1000
00:30:44,799 --> 00:30:51,840
all right cool thanks

1001
00:30:56,960 --> 00:30:59,039
you

