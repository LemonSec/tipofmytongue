1
00:00:05,520 --> 00:00:08,639
hi

2
00:00:06,160 --> 00:00:09,679
um so initially another colleague of

3
00:00:08,639 --> 00:00:11,599
ours was planned to

4
00:00:09,679 --> 00:00:13,840
give this talk uh paul horn but he's

5
00:00:11,599 --> 00:00:16,800
unfortunately sick so i'm

6
00:00:13,840 --> 00:00:18,880
here instead my name is max what you

7
00:00:16,800 --> 00:00:22,000
already said we all work for neo4j

8
00:00:18,880 --> 00:00:25,439
specifically in the graph analytics team

9
00:00:22,000 --> 00:00:27,759
and today we want to present you one

10
00:00:25,439 --> 00:00:29,439
new or not so new project that we are

11
00:00:27,760 --> 00:00:30,640
working on supposedly we are working on

12
00:00:29,439 --> 00:00:33,680
this project and that is the

13
00:00:30,640 --> 00:00:35,440
neo4j graph data science library um some

14
00:00:33,680 --> 00:00:37,840
of you might already have used or not

15
00:00:35,440 --> 00:00:40,640
have used the graph algorithms library

16
00:00:37,840 --> 00:00:41,440
basically this is the successor of it um

17
00:00:40,640 --> 00:00:42,879
i'll

18
00:00:41,440 --> 00:00:44,718
go into the details about the history a

19
00:00:42,879 --> 00:00:46,800
bit later for those

20
00:00:44,719 --> 00:00:47,760
of you who don't or haven't used it so

21
00:00:46,800 --> 00:00:49,680
far

22
00:00:47,760 --> 00:00:51,920
what is the neo4j graph data science

23
00:00:49,680 --> 00:00:54,480
library it's

24
00:00:51,920 --> 00:00:56,160
basically a add-on for the neo4j

25
00:00:54,480 --> 00:00:58,160
database

26
00:00:56,160 --> 00:00:59,279
which is a graph database for those of

27
00:00:58,160 --> 00:01:03,199
you who don't know

28
00:00:59,280 --> 00:01:06,799
um and we are an add-on for that

29
00:01:03,199 --> 00:01:07,600
that allows you to run graph algorithms

30
00:01:06,799 --> 00:01:11,119
so

31
00:01:07,600 --> 00:01:13,520
the neo4j database itself is more than

32
00:01:11,119 --> 00:01:14,320
oltp database so it's um it's mainly

33
00:01:13,520 --> 00:01:18,080
used for

34
00:01:14,320 --> 00:01:21,279
um short queries uh that create only

35
00:01:18,080 --> 00:01:22,960
um smaller parts of a graph using mostly

36
00:01:21,280 --> 00:01:25,520
the cipher query language

37
00:01:22,960 --> 00:01:26,798
um there are in with insight for their

38
00:01:25,520 --> 00:01:27,839
support for some algorithms like

39
00:01:26,799 --> 00:01:31,200
shortest path

40
00:01:27,840 --> 00:01:32,720
um for example um but the neo4j graph

41
00:01:31,200 --> 00:01:33,920
data science library gives you a much

42
00:01:32,720 --> 00:01:36,960
broader

43
00:01:33,920 --> 00:01:40,320
access to yeah graph

44
00:01:36,960 --> 00:01:42,960
global graph algorithms

45
00:01:40,320 --> 00:01:44,479
and we have implemented a broad set of

46
00:01:42,960 --> 00:01:46,240
algorithms or

47
00:01:44,479 --> 00:01:48,159
there exists a broad set of algorithms

48
00:01:46,240 --> 00:01:49,439
we have items for community detection

49
00:01:48,159 --> 00:01:52,479
and clustering

50
00:01:49,439 --> 00:01:55,199
for example label propagation we have

51
00:01:52,479 --> 00:01:56,399
algorithms for similarity calculation so

52
00:01:55,200 --> 00:01:58,799
for example you can

53
00:01:56,399 --> 00:02:00,320
calculate how similar are two nodes

54
00:01:58,799 --> 00:02:02,399
given their neighborhood

55
00:02:00,320 --> 00:02:04,240
therefore we use node similarity using

56
00:02:02,399 --> 00:02:06,640
jakar similarity

57
00:02:04,240 --> 00:02:09,038
we have centrality algorithms such as

58
00:02:06,640 --> 00:02:10,560
page rank

59
00:02:09,038 --> 00:02:12,399
we have some link prediction and

60
00:02:10,560 --> 00:02:15,440
pathfinding algorithms pathfinding

61
00:02:12,400 --> 00:02:17,599
we have dijkstra a-star

62
00:02:15,440 --> 00:02:19,440
and then we have some auxiliary stuff

63
00:02:17,599 --> 00:02:22,319
like graph creation for

64
00:02:19,440 --> 00:02:23,120
the in-memory graph and another thing

65
00:02:22,319 --> 00:02:25,920
the

66
00:02:23,120 --> 00:02:26,319
library basically provides is is an api

67
00:02:25,920 --> 00:02:28,879
for

68
00:02:26,319 --> 00:02:30,319
implementing your own algorithms there

69
00:02:28,879 --> 00:02:32,000
are certain ways you can do this the

70
00:02:30,319 --> 00:02:33,119
easiest way is using the prager

71
00:02:32,000 --> 00:02:35,440
framework

72
00:02:33,120 --> 00:02:37,920
that was introduced by google it quite a

73
00:02:35,440 --> 00:02:39,599
while ago so we also support that

74
00:02:37,920 --> 00:02:41,280
and that allows you to easily write your

75
00:02:39,599 --> 00:02:43,200
own algorithms and then also

76
00:02:41,280 --> 00:02:44,400
make them available in neo4j through

77
00:02:43,200 --> 00:02:47,280
cipher through the

78
00:02:44,400 --> 00:02:47,280
procedure api

79
00:02:47,440 --> 00:02:51,200
so when would you use the graph data

80
00:02:50,239 --> 00:02:53,200
science library or

81
00:02:51,200 --> 00:02:55,200
gds as we call it because graph data

82
00:02:53,200 --> 00:02:57,760
science is pretty long

83
00:02:55,200 --> 00:03:01,119
oh no no that's otherwise first we start

84
00:02:57,760 --> 00:03:03,440
with some of the timeline information

85
00:03:01,120 --> 00:03:05,200
so as i already said initially this

86
00:03:03,440 --> 00:03:09,359
project started as the

87
00:03:05,200 --> 00:03:11,920
neo4j graph algorithms library which was

88
00:03:09,360 --> 00:03:13,120
a project that was bearheaded by the

89
00:03:11,920 --> 00:03:16,958
neo4j

90
00:03:13,120 --> 00:03:19,200
um deferral or labs organization led by

91
00:03:16,959 --> 00:03:20,800
michael so he initially initiated this

92
00:03:19,200 --> 00:03:23,518
project and it was uh

93
00:03:20,800 --> 00:03:26,080
spiked by an external con by external

94
00:03:23,519 --> 00:03:26,799
contractor avant-garde labs paul who was

95
00:03:26,080 --> 00:03:29,120
initially

96
00:03:26,799 --> 00:03:30,400
supposed to give this talk he um spiked

97
00:03:29,120 --> 00:03:32,080
this project he's been working on his

98
00:03:30,400 --> 00:03:33,519
project for quite a while and as you can

99
00:03:32,080 --> 00:03:38,080
see this was already in

100
00:03:33,519 --> 00:03:39,360
uh it started already in q1 2017

101
00:03:38,080 --> 00:03:41,680
and then they kept on working for this

102
00:03:39,360 --> 00:03:43,200
for a while yeah the library was already

103
00:03:41,680 --> 00:03:44,159
open source and public by then you could

104
00:03:43,200 --> 00:03:47,440
use it

105
00:03:44,159 --> 00:03:49,120
and at some point in time um the neo4j

106
00:03:47,440 --> 00:03:50,959
product engineering took actually over

107
00:03:49,120 --> 00:03:54,000
so we came into the picture

108
00:03:50,959 --> 00:03:57,360
um to actually make it a fully fledged

109
00:03:54,000 --> 00:04:00,879
neo4j product and that work started in

110
00:03:57,360 --> 00:04:01,760
q1 2019 so last year since then we've

111
00:04:00,879 --> 00:04:04,798
been working on

112
00:04:01,760 --> 00:04:07,040
mostly productizing library doing some

113
00:04:04,799 --> 00:04:09,280
code refactorings making

114
00:04:07,040 --> 00:04:11,359
sure that all the algorithms run in all

115
00:04:09,280 --> 00:04:14,080
the ways you would expect them to

116
00:04:11,360 --> 00:04:14,879
and also so that they have basically the

117
00:04:14,080 --> 00:04:17,840
features that

118
00:04:14,879 --> 00:04:18,320
users want them to have which is not to

119
00:04:17,839 --> 00:04:20,478
say that

120
00:04:18,320 --> 00:04:21,839
uh when when michael and paul and the

121
00:04:20,478 --> 00:04:23,440
other guys are diverged that this

122
00:04:21,839 --> 00:04:24,080
developed that they didn't focus on that

123
00:04:23,440 --> 00:04:26,880
but

124
00:04:24,080 --> 00:04:27,199
we talked to uh potential customers and

125
00:04:26,880 --> 00:04:28,560
then

126
00:04:27,199 --> 00:04:30,479
look what they actually wanted for

127
00:04:28,560 --> 00:04:31,919
algorithms and then took a smaller

128
00:04:30,479 --> 00:04:33,919
subset of the algorithms that already

129
00:04:31,919 --> 00:04:35,840
existed and made sure that they run

130
00:04:33,919 --> 00:04:37,440
in the best performance that we could

131
00:04:35,840 --> 00:04:40,479
like

132
00:04:37,440 --> 00:04:41,440
make them run and now we are at

133
00:04:40,479 --> 00:04:44,960
basically today

134
00:04:41,440 --> 00:04:47,759
um q1 2020 and we

135
00:04:44,960 --> 00:04:49,120
are or have uh basically reopen sourced

136
00:04:47,759 --> 00:04:51,040
the project so while

137
00:04:49,120 --> 00:04:52,800
uh we were initially developing it as

138
00:04:51,040 --> 00:04:54,800
neo4j product engineering

139
00:04:52,800 --> 00:04:56,320
we had closed towards the project for a

140
00:04:54,800 --> 00:04:58,000
while and we have now open source it

141
00:04:56,320 --> 00:04:58,960
again the link for it i'll show you

142
00:04:58,000 --> 00:05:02,479
later

143
00:04:58,960 --> 00:05:05,440
and we will make a first

144
00:05:02,479 --> 00:05:06,240
preview release i think next week and

145
00:05:05,440 --> 00:05:10,160
then

146
00:05:06,240 --> 00:05:12,800
in q2 2020 this will be

147
00:05:10,160 --> 00:05:13,520
globally available through the usual

148
00:05:12,800 --> 00:05:15,360
channels

149
00:05:13,520 --> 00:05:17,440
mostly the neo4j desktop if you want to

150
00:05:15,360 --> 00:05:19,199
try it out

151
00:05:17,440 --> 00:05:20,719
so now when would you actually like to

152
00:05:19,199 --> 00:05:22,320
use that

153
00:05:20,720 --> 00:05:24,000
so we basically make the decision

154
00:05:22,320 --> 00:05:26,400
between um

155
00:05:24,000 --> 00:05:27,440
as i already mentioned the more oltp

156
00:05:26,400 --> 00:05:30,159
focused so

157
00:05:27,440 --> 00:05:31,520
like online transaction focused uh

158
00:05:30,160 --> 00:05:34,960
workloads where you have small

159
00:05:31,520 --> 00:05:36,320
short lived queries that you basically

160
00:05:34,960 --> 00:05:38,080
run over and over again just with

161
00:05:36,320 --> 00:05:39,120
different parameters for example for

162
00:05:38,080 --> 00:05:40,320
example if you want to drive your

163
00:05:39,120 --> 00:05:42,800
website then you would

164
00:05:40,320 --> 00:05:44,320
um do more otp style queries where you

165
00:05:42,800 --> 00:05:44,880
only touch a very small subset of your

166
00:05:44,320 --> 00:05:47,280
graph

167
00:05:44,880 --> 00:05:47,919
and this is where actually neo4j with

168
00:05:47,280 --> 00:05:50,799
the cypher

169
00:05:47,919 --> 00:05:52,159
language like performs on its best

170
00:05:50,800 --> 00:05:54,479
that's not to say cypher

171
00:05:52,160 --> 00:05:55,360
and neo4j both support also queries that

172
00:05:54,479 --> 00:05:57,280
can do

173
00:05:55,360 --> 00:05:58,639
more analytical or can support more

174
00:05:57,280 --> 00:06:02,000
analytical work

175
00:05:58,639 --> 00:06:04,400
cases or workloads but

176
00:06:02,000 --> 00:06:06,720
from both the query language and mostly

177
00:06:04,400 --> 00:06:10,479
neo4j it performs at its best when it's

178
00:06:06,720 --> 00:06:13,280
oltp so short-lived graph

179
00:06:10,479 --> 00:06:14,159
localized queries and then we have the

180
00:06:13,280 --> 00:06:17,919
graph algorithm

181
00:06:14,160 --> 00:06:19,199
algorithms library which is more when

182
00:06:17,919 --> 00:06:22,560
you

183
00:06:19,199 --> 00:06:24,639
actually uh when you want to

184
00:06:22,560 --> 00:06:26,160
uh analyze the entire graph so you're

185
00:06:24,639 --> 00:06:28,000
not really

186
00:06:26,160 --> 00:06:29,759
not really knowing what you're actually

187
00:06:28,000 --> 00:06:32,319
looking for so it's more

188
00:06:29,759 --> 00:06:33,520
you have you have basically an idea um

189
00:06:32,319 --> 00:06:36,960
of what you want to

190
00:06:33,520 --> 00:06:38,639
analyze or maybe you have an idea of

191
00:06:36,960 --> 00:06:40,560
of a hypothesis and you want to prove

192
00:06:38,639 --> 00:06:42,160
that hypothesis then you can use the

193
00:06:40,560 --> 00:06:45,520
graph algorithms library

194
00:06:42,160 --> 00:06:48,479
and discover new insights in your graph

195
00:06:45,520 --> 00:06:51,520
by doing graph global aggregations

196
00:06:48,479 --> 00:06:53,919
so as i said when you run uh

197
00:06:51,520 --> 00:06:55,520
more cipher style queries then you then

198
00:06:53,919 --> 00:06:56,960
you only use a very localized part of

199
00:06:55,520 --> 00:06:58,799
your graph and you actually know what

200
00:06:56,960 --> 00:07:00,799
you're looking for you so you know that

201
00:06:58,800 --> 00:07:02,560
i'm looking for a person named this and

202
00:07:00,800 --> 00:07:05,039
that and i want to know its neighborhood

203
00:07:02,560 --> 00:07:06,800
but when i'm using the analytics library

204
00:07:05,039 --> 00:07:07,919
then i'm basically using all of my graph

205
00:07:06,800 --> 00:07:10,960
or a very big

206
00:07:07,919 --> 00:07:12,719
part of it and i'm basically digging

207
00:07:10,960 --> 00:07:14,080
into the graph finding new information

208
00:07:12,720 --> 00:07:15,360
finding new insight

209
00:07:14,080 --> 00:07:16,400
and then maybe feeding it back and

210
00:07:15,360 --> 00:07:17,919
that's where you call it graph data

211
00:07:16,400 --> 00:07:19,919
science library maybe

212
00:07:17,919 --> 00:07:21,198
feeding it back into my data data

213
00:07:19,919 --> 00:07:25,198
science workflow

214
00:07:21,199 --> 00:07:25,199
that is now aided by graph processing

215
00:07:25,360 --> 00:07:30,240
uh yeah uh so how

216
00:07:28,560 --> 00:07:31,599
does our library work how would you use

217
00:07:30,240 --> 00:07:32,880
that for those who haven't basically

218
00:07:31,599 --> 00:07:36,479
used the

219
00:07:32,880 --> 00:07:38,639
um graph algorithms library

220
00:07:36,479 --> 00:07:40,318
so we currently we always start off by a

221
00:07:38,639 --> 00:07:42,800
neo4j database so you have your

222
00:07:40,319 --> 00:07:44,479
graph loaded into your neo4j database

223
00:07:42,800 --> 00:07:45,919
and it's living there

224
00:07:44,479 --> 00:07:48,960
and here i'm using a graph which

225
00:07:45,919 --> 00:07:51,520
basically i used

226
00:07:48,960 --> 00:07:54,000
colors to the nodes and nodes with

227
00:07:51,520 --> 00:07:56,560
different labels for example

228
00:07:54,000 --> 00:07:57,199
and what you then do is because inside

229
00:07:56,560 --> 00:07:58,960
of the

230
00:07:57,199 --> 00:08:00,960
graph data science library we are using

231
00:07:58,960 --> 00:08:02,400
an in memory model of the graph to

232
00:08:00,960 --> 00:08:05,919
basically

233
00:08:02,400 --> 00:08:09,280
empower those very fast

234
00:08:05,919 --> 00:08:11,039
graph algorithm runs so we need we can't

235
00:08:09,280 --> 00:08:12,878
really rely on the

236
00:08:11,039 --> 00:08:14,159
layout and the store layout of neo4j so

237
00:08:12,879 --> 00:08:16,240
what we are doing is we are taking

238
00:08:14,160 --> 00:08:19,199
reloading the graph from neo4j into

239
00:08:16,240 --> 00:08:20,400
an in-memory model so and that's what

240
00:08:19,199 --> 00:08:22,720
you would always start with

241
00:08:20,400 --> 00:08:24,479
you load your graph you can project the

242
00:08:22,720 --> 00:08:27,280
graph so that means you can

243
00:08:24,479 --> 00:08:27,758
rename labels you can skip certain

244
00:08:27,280 --> 00:08:29,440
labels

245
00:08:27,759 --> 00:08:31,199
so you can skip nodes with a certain

246
00:08:29,440 --> 00:08:32,880
label you can skip relationships

247
00:08:31,199 --> 00:08:34,320
you can rename relationships and also

248
00:08:32,880 --> 00:08:35,919
you can

249
00:08:34,320 --> 00:08:37,200
load certain properties or not load

250
00:08:35,919 --> 00:08:39,679
certain properties and you can even

251
00:08:37,200 --> 00:08:42,880
reverse the direction of edges

252
00:08:39,679 --> 00:08:44,239
into you and memory graph so that i've

253
00:08:42,880 --> 00:08:46,640
visualized here so we've basically

254
00:08:44,240 --> 00:08:48,560
skipped the red notes in this

255
00:08:46,640 --> 00:08:50,640
visualization and now we have our

256
00:08:48,560 --> 00:08:52,319
subgraph in memory

257
00:08:50,640 --> 00:08:54,399
this graph now lives in a thing that we

258
00:08:52,320 --> 00:08:56,080
call the graph catalog

259
00:08:54,399 --> 00:08:57,920
um basically it's just what you would

260
00:08:56,080 --> 00:08:59,360
imagine it's uh

261
00:08:57,920 --> 00:09:00,800
the graph basically has a name and you

262
00:08:59,360 --> 00:09:03,040
can retrieve that graph by the name

263
00:09:00,800 --> 00:09:05,680
within as long as you stick into

264
00:09:03,040 --> 00:09:07,040
or stick in inside of the graph data

265
00:09:05,680 --> 00:09:08,399
science library

266
00:09:07,040 --> 00:09:10,640
so we've loaded this graph now into

267
00:09:08,399 --> 00:09:11,279
memory uh and now it's time to run an

268
00:09:10,640 --> 00:09:12,640
algorithm

269
00:09:11,279 --> 00:09:14,480
so here for example we do some

270
00:09:12,640 --> 00:09:16,399
clustering in my example

271
00:09:14,480 --> 00:09:18,399
so you specify now i want to use this in

272
00:09:16,399 --> 00:09:20,320
memory graph and i want to run

273
00:09:18,399 --> 00:09:21,760
for example a clustering algorithm and

274
00:09:20,320 --> 00:09:22,640
then what you get is you get another in

275
00:09:21,760 --> 00:09:25,680
memory graph or

276
00:09:22,640 --> 00:09:27,519
some information about that graph that

277
00:09:25,680 --> 00:09:28,959
says well i think those nodes belong to

278
00:09:27,519 --> 00:09:30,399
a cluster and the other nodes belong to

279
00:09:28,959 --> 00:09:32,560
a cluster

280
00:09:30,399 --> 00:09:34,080
and then as a next step you would

281
00:09:32,560 --> 00:09:35,920
consume this result you could run

282
00:09:34,080 --> 00:09:39,200
another algorithm on that graph maybe

283
00:09:35,920 --> 00:09:41,680
using the information from the first run

284
00:09:39,200 --> 00:09:42,320
or you consume the information that the

285
00:09:41,680 --> 00:09:43,920
algorithm

286
00:09:42,320 --> 00:09:46,399
returned to you and you can do this in

287
00:09:43,920 --> 00:09:48,560
two ways you can either

288
00:09:46,399 --> 00:09:49,760
write the results back into neo4j this

289
00:09:48,560 --> 00:09:52,079
mostly happens by

290
00:09:49,760 --> 00:09:53,279
writing a node property so for example

291
00:09:52,080 --> 00:09:55,360
if you do the clustering

292
00:09:53,279 --> 00:09:57,040
we would write a property on every node

293
00:09:55,360 --> 00:09:57,760
that says well this node i think belongs

294
00:09:57,040 --> 00:10:00,560
to cluster

295
00:09:57,760 --> 00:10:02,000
with the id1 or you can for some

296
00:10:00,560 --> 00:10:03,599
algorithms like the similarity

297
00:10:02,000 --> 00:10:06,560
algorithms you would write back

298
00:10:03,600 --> 00:10:08,880
a relationship to the graph and another

299
00:10:06,560 --> 00:10:10,160
option is you can stream back results

300
00:10:08,880 --> 00:10:11,680
so if you don't want to persist the

301
00:10:10,160 --> 00:10:13,040
result of the algorithm you can just

302
00:10:11,680 --> 00:10:14,719
stream back the result

303
00:10:13,040 --> 00:10:16,560
inside of your cipher query and then use

304
00:10:14,720 --> 00:10:18,640
it in your in the driver

305
00:10:16,560 --> 00:10:19,760
or your application program as you see

306
00:10:18,640 --> 00:10:21,279
fit

307
00:10:19,760 --> 00:10:22,959
so these are currently the two ways that

308
00:10:21,279 --> 00:10:25,839
we are supporting

309
00:10:22,959 --> 00:10:27,279
um and yeah the most important thing is

310
00:10:25,839 --> 00:10:29,440
the workflow always starts currently at

311
00:10:27,279 --> 00:10:31,120
neo4j then you load a graph you can load

312
00:10:29,440 --> 00:10:32,640
as many graphs as you like or as fit

313
00:10:31,120 --> 00:10:35,760
into your memory

314
00:10:32,640 --> 00:10:38,319
and then you can use them for

315
00:10:35,760 --> 00:10:41,200
for running algorithms and then you can

316
00:10:38,320 --> 00:10:41,200
consume the result

317
00:10:43,120 --> 00:10:46,880
so what kind of algorithms do we have

318
00:10:44,880 --> 00:10:49,439
are already hinted towards that we have

319
00:10:46,880 --> 00:10:50,880
community detection to find clusters of

320
00:10:49,440 --> 00:10:52,880
nodes that somehow belong together

321
00:10:50,880 --> 00:10:54,399
we have centrality or importance of

322
00:10:52,880 --> 00:10:56,959
certain nodes

323
00:10:54,399 --> 00:10:59,440
patrons probably the most well known

324
00:10:56,959 --> 00:11:01,920
there or between the centrality

325
00:10:59,440 --> 00:11:02,880
similarity algorithms uh link prediction

326
00:11:01,920 --> 00:11:05,120
and pathfinding

327
00:11:02,880 --> 00:11:06,640
and search those that are currently

328
00:11:05,120 --> 00:11:07,920
marked in bold font here

329
00:11:06,640 --> 00:11:10,480
are the ones that we have actually

330
00:11:07,920 --> 00:11:12,479
productized by productize we mean they

331
00:11:10,480 --> 00:11:14,000
here we guarantee some some form of

332
00:11:12,480 --> 00:11:17,040
matureness of the algorithm

333
00:11:14,000 --> 00:11:19,519
by our team and by neo4j

334
00:11:17,040 --> 00:11:20,959
basically that is if you use that if you

335
00:11:19,519 --> 00:11:23,839
use those parts we

336
00:11:20,959 --> 00:11:25,199
hope that those are bug free run as fast

337
00:11:23,839 --> 00:11:28,240
as they can

338
00:11:25,200 --> 00:11:28,640
all these things and i think it's time

339
00:11:28,240 --> 00:11:31,680
for

340
00:11:28,640 --> 00:11:34,240
a demo now so i

341
00:11:31,680 --> 00:11:34,239
actually

342
00:11:34,959 --> 00:11:38,160
where's my mouse

343
00:11:36,190 --> 00:11:42,399
[Music]

344
00:11:38,160 --> 00:11:45,360
um i have this neo4j browser here

345
00:11:42,399 --> 00:11:46,720
which is huge i'm sorry for that i can't

346
00:11:45,360 --> 00:11:49,839
really change that

347
00:11:46,720 --> 00:11:51,600
um i'm gonna zoom out no okay so

348
00:11:49,839 --> 00:11:54,160
um what i've loaded into this graph is

349
00:11:51,600 --> 00:11:54,480
basically the game of thrones data sets

350
00:11:54,160 --> 00:11:56,639
that

351
00:11:54,480 --> 00:11:57,519
we we're using for many examples so it's

352
00:11:56,639 --> 00:12:00,480
basically

353
00:11:57,519 --> 00:12:01,360
an extract of how people in the game of

354
00:12:00,480 --> 00:12:04,720
thrones

355
00:12:01,360 --> 00:12:05,279
books um when people appear together on

356
00:12:04,720 --> 00:12:07,279
a page

357
00:12:05,279 --> 00:12:09,760
then we basically create notes for those

358
00:12:07,279 --> 00:12:11,519
people and then we link them together

359
00:12:09,760 --> 00:12:13,519
with an edge and so we have edges

360
00:12:11,519 --> 00:12:15,040
interacted with so people interacted

361
00:12:13,519 --> 00:12:17,440
with another in a certain book and then

362
00:12:15,040 --> 00:12:18,959
we have those interactions also

363
00:12:17,440 --> 00:12:20,079
split up into these different books we

364
00:12:18,959 --> 00:12:21,599
have some more information that we're

365
00:12:20,079 --> 00:12:23,040
actually not going to use in this demo

366
00:12:21,600 --> 00:12:24,639
so this is actually the most

367
00:12:23,040 --> 00:12:28,160
important information we have persons

368
00:12:24,639 --> 00:12:29,760
and then they interact with one another

369
00:12:28,160 --> 00:12:31,600
this graph is loaded into this neo4j

370
00:12:29,760 --> 00:12:36,399
database

371
00:12:31,600 --> 00:12:38,480
we can run a simple query here to see

372
00:12:36,399 --> 00:12:40,079
to get a bit of an idea of how this

373
00:12:38,480 --> 00:12:43,600
graph looks like

374
00:12:40,079 --> 00:12:45,680
um this basically just uh counts the

375
00:12:43,600 --> 00:12:47,360
average number of

376
00:12:45,680 --> 00:12:49,279
interactions between the people so in

377
00:12:47,360 --> 00:12:52,560
average people interact with another

378
00:12:49,279 --> 00:12:53,680
or people interact with 6.7 other people

379
00:12:52,560 --> 00:12:55,439
in the book

380
00:12:53,680 --> 00:12:57,920
the person who interacts with most of

381
00:12:55,440 --> 00:13:00,000
people has 170 interactions that's just

382
00:12:57,920 --> 00:13:02,479
to get an idea i think it's about 5000

383
00:13:00,000 --> 00:13:02,480
notes and

384
00:13:03,040 --> 00:13:07,599
slightly more slightly more edges in the

385
00:13:06,079 --> 00:13:11,120
graph

386
00:13:07,600 --> 00:13:14,399
um yeah and now we can dive into the

387
00:13:11,120 --> 00:13:16,000
uh graph data science library

388
00:13:14,399 --> 00:13:18,639
as i said the first thing we always do

389
00:13:16,000 --> 00:13:22,079
is we have to load a graph

390
00:13:18,639 --> 00:13:22,560
that's horrible um so what we do is we

391
00:13:22,079 --> 00:13:24,239
use the

392
00:13:22,560 --> 00:13:26,000
cipher procedure language here because

393
00:13:24,240 --> 00:13:28,079
we are as i said we are a plugin so

394
00:13:26,000 --> 00:13:30,160
you can use the graph data science

395
00:13:28,079 --> 00:13:32,800
library wire the procedure calls

396
00:13:30,160 --> 00:13:33,760
um so the first procedure call is that

397
00:13:32,800 --> 00:13:35,599
we would do is we would

398
00:13:33,760 --> 00:13:37,200
say gds which every every of our

399
00:13:35,600 --> 00:13:38,800
commands are prefixed with

400
00:13:37,200 --> 00:13:40,560
then graph that's basically all the

401
00:13:38,800 --> 00:13:42,240
catalog commands and then creates

402
00:13:40,560 --> 00:13:44,319
because we want to create a new graph

403
00:13:42,240 --> 00:13:46,560
and what we say here additionally is we

404
00:13:44,320 --> 00:13:47,600
want to call this graph got into actions

405
00:13:46,560 --> 00:13:49,359
because we

406
00:13:47,600 --> 00:13:51,279
from the got graph or game of thrones

407
00:13:49,360 --> 00:13:54,399
graph we load all the interactions

408
00:13:51,279 --> 00:13:56,240
then we specify a node projection and

409
00:13:54,399 --> 00:13:57,440
that means what kind of nodes do we want

410
00:13:56,240 --> 00:14:00,000
to load so we have

411
00:13:57,440 --> 00:14:00,880
a very simple form you can specify

412
00:14:00,000 --> 00:14:02,399
specify

413
00:14:00,880 --> 00:14:04,000
many more things if you like but here

414
00:14:02,399 --> 00:14:05,519
you just want to load every person that

415
00:14:04,000 --> 00:14:07,680
is in the graph so every node that is

416
00:14:05,519 --> 00:14:11,519
labeled with the labeled person

417
00:14:07,680 --> 00:14:15,120
and for relationships we want to

418
00:14:11,519 --> 00:14:16,639
load all the interactions relationships

419
00:14:15,120 --> 00:14:18,480
and then we have a thing that we call

420
00:14:16,639 --> 00:14:19,920
projection that means

421
00:14:18,480 --> 00:14:21,519
because we need to know in which

422
00:14:19,920 --> 00:14:23,120
direction do we want to load

423
00:14:21,519 --> 00:14:24,800
uh the relationships because of how we

424
00:14:23,120 --> 00:14:26,959
store them internally we need to know

425
00:14:24,800 --> 00:14:27,839
do we want to have them in their natural

426
00:14:26,959 --> 00:14:29,760
direction that is

427
00:14:27,839 --> 00:14:31,519
how they are in the database from no

428
00:14:29,760 --> 00:14:32,959
from one node into another because neo4j

429
00:14:31,519 --> 00:14:34,800
every node is directed

430
00:14:32,959 --> 00:14:36,319
do we want to load them in reverse then

431
00:14:34,800 --> 00:14:37,199
we would say reverse or do we want them

432
00:14:36,320 --> 00:14:38,639
undirected

433
00:14:37,199 --> 00:14:40,959
and then undirected we basically store

434
00:14:38,639 --> 00:14:42,480
them twice in every direction

435
00:14:40,959 --> 00:14:44,319
and that's what we're doing here so we

436
00:14:42,480 --> 00:14:46,160
basically get if one person interacts

437
00:14:44,320 --> 00:14:47,680
with the other person then it also also

438
00:14:46,160 --> 00:14:49,279
the other person interacts with the one

439
00:14:47,680 --> 00:14:53,599
person

440
00:14:49,279 --> 00:14:55,199
so we load this graph um run the query

441
00:14:53,600 --> 00:14:56,800
and then we get and we get some

442
00:14:55,199 --> 00:14:58,000
information back about what we just

443
00:14:56,800 --> 00:14:59,839
loaded i mean that's basically

444
00:14:58,000 --> 00:15:01,920
the same thing we named the got into

445
00:14:59,839 --> 00:15:03,760
actions here's what i said we just

446
00:15:01,920 --> 00:15:04,560
specified in very simple form of a node

447
00:15:03,760 --> 00:15:06,800
protection

448
00:15:04,560 --> 00:15:08,719
uh here's the extended form and then it

449
00:15:06,800 --> 00:15:10,479
gives us some information so we have

450
00:15:08,720 --> 00:15:12,560
only two thousand nodes now seven

451
00:15:10,480 --> 00:15:12,959
thousand interactions or relationships

452
00:15:12,560 --> 00:15:17,680
and it

453
00:15:12,959 --> 00:15:17,680
took 767 milliseconds to load that

454
00:15:17,760 --> 00:15:24,240
um right so now it's time to run

455
00:15:21,839 --> 00:15:27,199
a first algorithm we're going to use

456
00:15:24,240 --> 00:15:27,199
pagerank for that

457
00:15:28,000 --> 00:15:32,560
where am i here i guess most of you do

458
00:15:30,959 --> 00:15:37,518
know

459
00:15:32,560 --> 00:15:37,518
i can't find my way back no

460
00:15:39,440 --> 00:15:46,079
ah there it is so we are running

461
00:15:43,279 --> 00:15:47,600
the patreon algorithm now uh page rank

462
00:15:46,079 --> 00:15:49,920
as i said is a centrality

463
00:15:47,600 --> 00:15:52,000
algorithm so it gives every node a score

464
00:15:49,920 --> 00:15:55,439
about how important is it to the network

465
00:15:52,000 --> 00:15:56,720
um and here again we can basically

466
00:15:55,440 --> 00:15:59,519
demonstrate how

467
00:15:56,720 --> 00:16:00,480
our um algorithm syntax looks like so we

468
00:15:59,519 --> 00:16:02,720
have

469
00:16:00,480 --> 00:16:04,240
again gds our general prefix then the

470
00:16:02,720 --> 00:16:05,680
algorithm we want to run and then the

471
00:16:04,240 --> 00:16:06,240
mode we want to run on as i said there

472
00:16:05,680 --> 00:16:08,160
are two

473
00:16:06,240 --> 00:16:09,759
different ways of how we can consume

474
00:16:08,160 --> 00:16:10,319
algorithms it's either by writing or by

475
00:16:09,759 --> 00:16:11,839
streaming

476
00:16:10,320 --> 00:16:13,680
here we stream the results back to the

477
00:16:11,839 --> 00:16:15,519
user we say

478
00:16:13,680 --> 00:16:17,839
we want to run this algorithm on this

479
00:16:15,519 --> 00:16:19,199
graph in our catalog got interactions

480
00:16:17,839 --> 00:16:21,360
and that's basically it because we don't

481
00:16:19,199 --> 00:16:22,399
want to specify any more or any more

482
00:16:21,360 --> 00:16:23,759
detailed

483
00:16:22,399 --> 00:16:25,600
things about the algorithm we just run

484
00:16:23,759 --> 00:16:28,800
it with the default settings

485
00:16:25,600 --> 00:16:30,480
and when we run it we almost immediately

486
00:16:28,800 --> 00:16:32,319
get some information back

487
00:16:30,480 --> 00:16:33,519
in this case we see that jon snow is

488
00:16:32,320 --> 00:16:35,440
apparently the most

489
00:16:33,519 --> 00:16:37,519
important note in our network with a

490
00:16:35,440 --> 00:16:40,079
page rank of 17 point

491
00:16:37,519 --> 00:16:41,920
something followed by tyrion lannister

492
00:16:40,079 --> 00:16:43,359
and ceci lannister

493
00:16:41,920 --> 00:16:45,360
for those of you who've read the books

494
00:16:43,360 --> 00:16:47,040
that kind of make sense at least to me

495
00:16:45,360 --> 00:16:48,560
they are the most important characters

496
00:16:47,040 --> 00:16:51,279
in the book series

497
00:16:48,560 --> 00:16:52,800
so at least it's returning what we would

498
00:16:51,279 --> 00:16:56,880
have expected

499
00:16:52,800 --> 00:16:59,920
um to show a more detailed example

500
00:16:56,880 --> 00:17:05,119
because we're running out of time um

501
00:16:59,920 --> 00:17:06,639
we have no that doesn't work because um

502
00:17:05,119 --> 00:17:08,399
yeah i think we don't have much more

503
00:17:06,640 --> 00:17:11,439
time for more examples

504
00:17:08,400 --> 00:17:14,400
um so let's switch back to the

505
00:17:11,439 --> 00:17:14,400
demonstration

506
00:17:16,839 --> 00:17:23,039
right the presentation i mean

507
00:17:19,919 --> 00:17:24,880
again um just a short wrap-up of how the

508
00:17:23,039 --> 00:17:27,280
algorithm syntax looks like we have

509
00:17:24,880 --> 00:17:28,000
always a call because we want to in

510
00:17:27,280 --> 00:17:30,240
cypher

511
00:17:28,000 --> 00:17:31,679
we want to run the procedure we have the

512
00:17:30,240 --> 00:17:32,960
algorithm name and then the mode

513
00:17:31,679 --> 00:17:34,799
we have the graph name and then the

514
00:17:32,960 --> 00:17:36,080
configuration so you can specify many

515
00:17:34,799 --> 00:17:37,280
more things for the algorithm for

516
00:17:36,080 --> 00:17:40,639
pagerank for example

517
00:17:37,280 --> 00:17:42,320
you can specify the dampening factor

518
00:17:40,640 --> 00:17:43,840
or whatever configuration you have or

519
00:17:42,320 --> 00:17:44,399
when you write back you can you have to

520
00:17:43,840 --> 00:17:45,918
specify

521
00:17:44,400 --> 00:17:48,559
into which property you want to write

522
00:17:45,919 --> 00:17:50,799
the page rank value

523
00:17:48,559 --> 00:17:52,000
we have usually three different modes we

524
00:17:50,799 --> 00:17:53,520
have write we have stream and then we

525
00:17:52,000 --> 00:17:55,360
have a stats mode which basically just

526
00:17:53,520 --> 00:17:57,679
returns

527
00:17:55,360 --> 00:17:59,039
the metadata about an algorithm runs

528
00:17:57,679 --> 00:18:00,400
basically just as writing

529
00:17:59,039 --> 00:18:02,559
without the writing but it gives you

530
00:18:00,400 --> 00:18:03,520
some information about how long did the

531
00:18:02,559 --> 00:18:06,320
algorithm take to

532
00:18:03,520 --> 00:18:08,879
compute maybe some information about a

533
00:18:06,320 --> 00:18:11,439
distribution of the result

534
00:18:08,880 --> 00:18:13,280
here's another example with weakly

535
00:18:11,440 --> 00:18:15,840
connected components so you can see you

536
00:18:13,280 --> 00:18:19,280
can specify many more

537
00:18:15,840 --> 00:18:22,240
properties or yeah configuration options

538
00:18:19,280 --> 00:18:22,240
for your algorithm run

539
00:18:22,640 --> 00:18:26,000
and with that i want to thank you for

540
00:18:24,880 --> 00:18:27,440
listening as

541
00:18:26,000 --> 00:18:29,919
i said we have open source the

542
00:18:27,440 --> 00:18:31,600
repository just last week i think you

543
00:18:29,919 --> 00:18:33,280
can find it under neo technology just

544
00:18:31,600 --> 00:18:35,760
graph analytics on github

545
00:18:33,280 --> 00:18:36,559
uh currently it doesn't build uh we

546
00:18:35,760 --> 00:18:39,039
haven't

547
00:18:36,559 --> 00:18:40,480
it doesn't it is green but there we

548
00:18:39,039 --> 00:18:41,760
haven't released anything of our build

549
00:18:40,480 --> 00:18:42,080
configuration yet that's a bit of a

550
00:18:41,760 --> 00:18:44,400
problem

551
00:18:42,080 --> 00:18:45,918
we're working on that soon you will be

552
00:18:44,400 --> 00:18:47,360
able to also build that but

553
00:18:45,919 --> 00:18:49,520
at least you can already have a look at

554
00:18:47,360 --> 00:18:52,240
the at the code and

555
00:18:49,520 --> 00:18:53,840
hopefully at some point start hacking on

556
00:18:52,240 --> 00:18:57,840
it and trying it out

557
00:18:53,840 --> 00:18:57,840
thank you

558
00:19:01,200 --> 00:19:10,320
so uh questions we have

559
00:19:04,400 --> 00:19:12,720
time for maybe two or three questions

560
00:19:10,320 --> 00:19:13,840
um is the data science library uh

561
00:19:12,720 --> 00:19:16,880
accessible from like

562
00:19:13,840 --> 00:19:18,240
titan or other languages so the question

563
00:19:16,880 --> 00:19:20,960
is if it's accessible from

564
00:19:18,240 --> 00:19:23,120
from python or other languages um it is

565
00:19:20,960 --> 00:19:25,840
kind of through cipher i mean you can

566
00:19:23,120 --> 00:19:27,039
use the python cipher driver and then i

567
00:19:25,840 --> 00:19:28,559
mean what you're writing is basically

568
00:19:27,039 --> 00:19:30,960
just cipher queries you can

569
00:19:28,559 --> 00:19:32,879
prepend or append cipher statements

570
00:19:30,960 --> 00:19:34,160
around your algo call as you as you see

571
00:19:32,880 --> 00:19:36,080
fit

572
00:19:34,160 --> 00:19:37,600
there's currently no way of basically

573
00:19:36,080 --> 00:19:39,120
writing your own algorithms in python

574
00:19:37,600 --> 00:19:40,639
we've been thinking about that we've

575
00:19:39,120 --> 00:19:42,320
experimented a bit with that but we

576
00:19:40,640 --> 00:19:47,200
don't have anything that is working in

577
00:19:42,320 --> 00:19:47,200
that direction currently

578
00:19:47,280 --> 00:19:53,840
allows you to use

579
00:20:01,600 --> 00:20:07,840
next tuesday in amsterdam in the

580
00:20:04,840 --> 00:20:07,840
graphics

581
00:20:11,360 --> 00:20:16,479
just maybe uh two things it's actually

582
00:20:13,360 --> 00:20:17,760
uh slash neo4j slash graph data science

583
00:20:16,480 --> 00:20:20,320
if you want to go to the

584
00:20:17,760 --> 00:20:20,320
version of it

585
00:20:30,320 --> 00:20:34,399
it's also available online free for

586
00:20:32,320 --> 00:20:34,960
download so the book that was around

587
00:20:34,400 --> 00:20:37,760
here

588
00:20:34,960 --> 00:20:39,120
um just go to neo4j.com and you can

589
00:20:37,760 --> 00:20:40,559
download the copy of the book which

590
00:20:39,120 --> 00:20:44,000
explains all the articles

591
00:20:40,559 --> 00:20:46,320
that are part of the library

592
00:20:44,000 --> 00:20:47,520
and with the pre-release that max

593
00:20:46,320 --> 00:20:49,760
mentioned for next week

594
00:20:47,520 --> 00:20:51,440
we will also do a docs prerelease that

595
00:20:49,760 --> 00:20:52,400
explains all the api that he just

596
00:20:51,440 --> 00:20:55,760
sketched over

597
00:20:52,400 --> 00:21:03,840
in of course very much more detail

598
00:20:55,760 --> 00:21:03,840
so yeah thanks again max

599
00:21:06,720 --> 00:21:08,799
you

