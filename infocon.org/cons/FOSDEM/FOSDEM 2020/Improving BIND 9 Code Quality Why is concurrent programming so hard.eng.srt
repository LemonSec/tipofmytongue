1
00:00:07,040 --> 00:00:10,400
hello welcome everyone

2
00:00:08,880 --> 00:00:12,400
i would like to present our next speaker

3
00:00:10,400 --> 00:00:13,280
it's andre suri from isc who will be

4
00:00:12,400 --> 00:00:15,360
talking about

5
00:00:13,280 --> 00:00:17,680
bind nine code quality i don't think

6
00:00:15,360 --> 00:00:18,640
this is actually a dns talk is it

7
00:00:17,680 --> 00:00:20,960
oh no

8
00:00:18,640 --> 00:00:24,480
[Laughter]

9
00:00:20,960 --> 00:00:26,560
right good luck a little bit so um

10
00:00:24,480 --> 00:00:29,359
just to get a feeling of the room who

11
00:00:26,560 --> 00:00:32,399
who knows bind

12
00:00:29,359 --> 00:00:35,440
who who uses mind okay

13
00:00:32,399 --> 00:00:39,440
who is a developer here oh

14
00:00:35,440 --> 00:00:41,280
so many no no

15
00:00:39,440 --> 00:00:42,879
i would i would know something about it

16
00:00:41,280 --> 00:00:45,280
and who who

17
00:00:42,879 --> 00:00:46,320
ever programmed something about dns like

18
00:00:45,280 --> 00:00:50,160
dns developers

19
00:00:46,320 --> 00:00:52,000
okay so um this talk is more about like

20
00:00:50,160 --> 00:00:52,800
what we are doing to bind at the moment

21
00:00:52,000 --> 00:00:54,719
so it's not

22
00:00:52,800 --> 00:00:56,000
strictly about the dns it's more about

23
00:00:54,719 --> 00:00:58,399
the bind and

24
00:00:56,000 --> 00:00:59,120
uh and about the concurrent programming

25
00:00:58,399 --> 00:01:02,399
um

26
00:00:59,120 --> 00:01:05,518
so so my my question would be who does

27
00:01:02,399 --> 00:01:08,960
threaded programming okay

28
00:01:05,519 --> 00:01:08,960
quite a lot of hints um

29
00:01:09,760 --> 00:01:13,119
so um there's a couple of prerequisites

30
00:01:12,720 --> 00:01:16,400
uh

31
00:01:13,119 --> 00:01:18,560
for us um in in bind

32
00:01:16,400 --> 00:01:20,159
uh that's continuous integration because

33
00:01:18,560 --> 00:01:21,040
if you don't use the tools i'm going to

34
00:01:20,159 --> 00:01:23,439
show you

35
00:01:21,040 --> 00:01:24,640
uh on a regular basis it it doesn't make

36
00:01:23,439 --> 00:01:27,758
sense at all so

37
00:01:24,640 --> 00:01:29,360
so if you ever use the tools just

38
00:01:27,759 --> 00:01:31,360
integrate them into your continuous

39
00:01:29,360 --> 00:01:33,119
integration and then you have to have

40
00:01:31,360 --> 00:01:37,039
the time to fix all the bugs

41
00:01:33,119 --> 00:01:40,880
so uh about mind it's a 20 years

42
00:01:37,040 --> 00:01:44,960
plus old code base so you can imagine

43
00:01:40,880 --> 00:01:47,360
um it's it's pretty 1999 code

44
00:01:44,960 --> 00:01:48,559
sometimes and it's getting better it's

45
00:01:47,360 --> 00:01:52,399
multi-threaded

46
00:01:48,560 --> 00:01:56,000
uh it uses locking it has its own

47
00:01:52,399 --> 00:01:58,000
rw lock which uh

48
00:01:56,000 --> 00:01:59,840
have some advantages like it allows

49
00:01:58,000 --> 00:02:03,040
downgrade and upgrade

50
00:01:59,840 --> 00:02:04,640
and and since by 914 which is current

51
00:02:03,040 --> 00:02:07,119
stable

52
00:02:04,640 --> 00:02:08,878
we are right now just before the release

53
00:02:07,119 --> 00:02:12,239
in 916 stable version

54
00:02:08,878 --> 00:02:12,640
it uses the std atomics or or the shims

55
00:02:12,239 --> 00:02:16,319
for

56
00:02:12,640 --> 00:02:20,000
in gcc or in windows

57
00:02:16,319 --> 00:02:20,000
api so um

58
00:02:20,239 --> 00:02:23,599
i don't know if you can actually see

59
00:02:21,520 --> 00:02:26,560
that but there are a couple tools that

60
00:02:23,599 --> 00:02:28,560
that we can use or or we are already

61
00:02:26,560 --> 00:02:30,959
using and it's kind of built from

62
00:02:28,560 --> 00:02:31,760
uh clank i'm going to talk about a cpp

63
00:02:30,959 --> 00:02:35,040
check

64
00:02:31,760 --> 00:02:37,200
um there's also clank tidy which does

65
00:02:35,040 --> 00:02:38,560
a different kind of checks uh we are not

66
00:02:37,200 --> 00:02:40,319
using that yet

67
00:02:38,560 --> 00:02:41,599
uh for the runtime analyzers this

68
00:02:40,319 --> 00:02:45,200
there's a lot of

69
00:02:41,599 --> 00:02:49,920
uh sanitizers from from gcc

70
00:02:45,200 --> 00:02:52,079
and an llv vm uh which are very good

71
00:02:49,920 --> 00:02:53,200
and there are some commercial tools like

72
00:02:52,080 --> 00:02:55,680
the cover this

73
00:02:53,200 --> 00:02:59,599
covert scan which can be actually used

74
00:02:55,680 --> 00:02:59,599
for free for the open source projects

75
00:02:59,760 --> 00:03:04,560
there's something called solar cloud i

76
00:03:02,159 --> 00:03:07,599
think uh um

77
00:03:04,560 --> 00:03:09,360
but that's that's like very chatted it

78
00:03:07,599 --> 00:03:11,359
reports all kind of

79
00:03:09,360 --> 00:03:13,360
weird stuff that's not even like it has

80
00:03:11,360 --> 00:03:16,560
a lot of false positives

81
00:03:13,360 --> 00:03:20,400
for us and there's look good to me

82
00:03:16,560 --> 00:03:23,040
dot com which also looks very good um

83
00:03:20,400 --> 00:03:24,400
and and the last two will be used for

84
00:03:23,040 --> 00:03:28,000
buying is cosinel

85
00:03:24,400 --> 00:03:29,599
uh it's a very good seal for refactoring

86
00:03:28,000 --> 00:03:32,080
large code bases it's

87
00:03:29,599 --> 00:03:33,920
it's mainly being used for linux kernel

88
00:03:32,080 --> 00:03:36,000
but we are using that too

89
00:03:33,920 --> 00:03:37,679
so so what's what's the scan build it's

90
00:03:36,000 --> 00:03:41,200
static code analyzer

91
00:03:37,680 --> 00:03:43,360
um it works by replacing the cc and cxx

92
00:03:41,200 --> 00:03:44,560
environment variable and it comes from

93
00:03:43,360 --> 00:03:47,200
the llvm

94
00:03:44,560 --> 00:03:48,640
and clank suite so the usage is quite

95
00:03:47,200 --> 00:03:49,760
simple this is for the auto counter

96
00:03:48,640 --> 00:03:51,839
based projects you

97
00:03:49,760 --> 00:03:53,599
you need to use it for configure and

98
00:03:51,840 --> 00:03:56,480
then when you're running make

99
00:03:53,599 --> 00:03:57,839
you keep the cc variables set from the

100
00:03:56,480 --> 00:04:00,720
configure step

101
00:03:57,840 --> 00:04:02,720
and and the output is this is just one

102
00:04:00,720 --> 00:04:06,159
of the comments because we tried to be

103
00:04:02,720 --> 00:04:08,319
uh more verbose than

104
00:04:06,159 --> 00:04:10,480
uh just fix back in the comment messages

105
00:04:08,319 --> 00:04:13,040
so this includes uh

106
00:04:10,480 --> 00:04:14,159
um the the real reports from the uh from

107
00:04:13,040 --> 00:04:18,079
the scan build

108
00:04:14,159 --> 00:04:20,959
uh and it it finds that like

109
00:04:18,079 --> 00:04:22,720
little stuff the the bind code base is

110
00:04:20,959 --> 00:04:26,080
quite good in regard regarding

111
00:04:22,720 --> 00:04:27,919
the scan build uh so it found like

112
00:04:26,080 --> 00:04:30,320
small stuff like the result is never

113
00:04:27,919 --> 00:04:34,880
used and uh

114
00:04:30,320 --> 00:04:37,919
and so we fixed that obviously um

115
00:04:34,880 --> 00:04:39,040
then the cpp check um that that's a

116
00:04:37,919 --> 00:04:40,799
different tool

117
00:04:39,040 --> 00:04:43,600
it's independent projects also static

118
00:04:40,800 --> 00:04:46,800
code analyzer it's more difficult to use

119
00:04:43,600 --> 00:04:48,960
uh if you if you use autoconf because it

120
00:04:46,800 --> 00:04:52,720
requires compilation database which is a

121
00:04:48,960 --> 00:04:56,560
json file with like which includes

122
00:04:52,720 --> 00:05:00,000
all the configuration options and and

123
00:04:56,560 --> 00:05:01,440
see flags and ld flags and and the path

124
00:05:00,000 --> 00:05:03,680
to files

125
00:05:01,440 --> 00:05:05,280
and and you need to build the

126
00:05:03,680 --> 00:05:06,639
compilation database so there are some

127
00:05:05,280 --> 00:05:07,520
tools that that can build that

128
00:05:06,639 --> 00:05:10,720
automatically

129
00:05:07,520 --> 00:05:12,960
i think cmake and others for automate

130
00:05:10,720 --> 00:05:14,000
it's it's more complicated

131
00:05:12,960 --> 00:05:16,799
and it has a different level of

132
00:05:14,000 --> 00:05:20,639
strictness the the most strict level is

133
00:05:16,800 --> 00:05:22,479
is um crazy at the moment for bind

134
00:05:20,639 --> 00:05:24,080
i'm not saying it reverse false false

135
00:05:22,479 --> 00:05:27,440
positive it returns good stuff

136
00:05:24,080 --> 00:05:29,599
but uh we are not there yet so um

137
00:05:27,440 --> 00:05:30,800
this is this is the usage so you run

138
00:05:29,600 --> 00:05:33,680
configure then

139
00:05:30,800 --> 00:05:34,880
you for for me ought to make an

140
00:05:33,680 --> 00:05:38,479
automatic use

141
00:05:34,880 --> 00:05:40,960
tool called bear which is i think

142
00:05:38,479 --> 00:05:41,840
like shortcut for built ear so it

143
00:05:40,960 --> 00:05:44,719
listens what

144
00:05:41,840 --> 00:05:45,359
what goes on and then you run cpp check

145
00:05:44,720 --> 00:05:47,199
on the

146
00:05:45,360 --> 00:05:48,880
compile commands json that's the

147
00:05:47,199 --> 00:05:51,520
compilation database

148
00:05:48,880 --> 00:05:52,320
and it runs the scan on all your source

149
00:05:51,520 --> 00:05:54,719
files

150
00:05:52,320 --> 00:05:56,560
so it's important to run your project in

151
00:05:54,720 --> 00:05:58,880
like a debug mode or

152
00:05:56,560 --> 00:06:00,240
or enable you enable everything in the

153
00:05:58,880 --> 00:06:03,360
configure so it gets

154
00:06:00,240 --> 00:06:05,360
analyzed um and the output looks like

155
00:06:03,360 --> 00:06:07,039
this so it's uh

156
00:06:05,360 --> 00:06:08,400
this is outperformed a tool called

157
00:06:07,039 --> 00:06:11,440
cppcheck

158
00:06:08,400 --> 00:06:15,120
dash html report and

159
00:06:11,440 --> 00:06:18,479
you are lucky because the cpp check 1.90

160
00:06:15,120 --> 00:06:21,680
just came out and it found a new errors

161
00:06:18,479 --> 00:06:24,800
because we were cvp clean before so this

162
00:06:21,680 --> 00:06:28,080
is this is from the cpp check 9.90

163
00:06:24,800 --> 00:06:30,960
um so it found a new new errors

164
00:06:28,080 --> 00:06:32,159
um and then if you click the individual

165
00:06:30,960 --> 00:06:35,198
error it looks like

166
00:06:32,160 --> 00:06:36,319
uh it looks like this so it uh it's

167
00:06:35,199 --> 00:06:39,280
annotated source

168
00:06:36,319 --> 00:06:41,440
your source code um and it shows the

169
00:06:39,280 --> 00:06:42,638
path through the file and it's it's very

170
00:06:41,440 --> 00:06:44,880
it's very good

171
00:06:42,639 --> 00:06:46,960
um so if you're on if you are developers

172
00:06:44,880 --> 00:06:50,319
and not using the cpp check i

173
00:06:46,960 --> 00:06:53,359
invite you to do so because we like it

174
00:06:50,319 --> 00:06:56,880
quite a lot um

175
00:06:53,360 --> 00:07:00,160
so um the next tool the cosinel

176
00:06:56,880 --> 00:07:01,440
um it's a program matching and

177
00:07:00,160 --> 00:07:03,520
transformation engine

178
00:07:01,440 --> 00:07:05,280
and it has something like called

179
00:07:03,520 --> 00:07:07,520
semantic patches

180
00:07:05,280 --> 00:07:09,679
um the usage is that you call the

181
00:07:07,520 --> 00:07:12,560
command as patch then you

182
00:07:09,680 --> 00:07:16,800
pass it the patch to the semantic patch

183
00:07:12,560 --> 00:07:18,960
it can work on on git repositories and

184
00:07:16,800 --> 00:07:20,720
there are some other small options so

185
00:07:18,960 --> 00:07:22,880
this is and it outputs the

186
00:07:20,720 --> 00:07:25,039
number of files it matches according to

187
00:07:22,880 --> 00:07:27,680
rules and then if there's

188
00:07:25,039 --> 00:07:28,560
anything needs that needs to be patched

189
00:07:27,680 --> 00:07:31,039
then it

190
00:07:28,560 --> 00:07:32,160
outputs the patch to the standard output

191
00:07:31,039 --> 00:07:35,280
or you can

192
00:07:32,160 --> 00:07:38,319
like patch the files uh in place

193
00:07:35,280 --> 00:07:40,159
there's an option for that too um this

194
00:07:38,319 --> 00:07:43,199
is a very simple

195
00:07:40,160 --> 00:07:43,680
semantic page so what this semantic page

196
00:07:43,199 --> 00:07:46,720
does

197
00:07:43,680 --> 00:07:49,759
that if it finds an assertion

198
00:07:46,720 --> 00:07:52,080
uh for example if you have a switch

199
00:07:49,759 --> 00:07:54,000
uh switch command and there's a default

200
00:07:52,080 --> 00:07:57,758
which always asserts like

201
00:07:54,000 --> 00:08:00,879
this is like custom bind assert

202
00:07:57,759 --> 00:08:02,800
insist zero so it if if the code reaches

203
00:08:00,879 --> 00:08:06,319
the point it crashes

204
00:08:02,800 --> 00:08:09,840
uh with assertion so um

205
00:08:06,319 --> 00:08:13,759
so it adds uh isc unreachable

206
00:08:09,840 --> 00:08:17,119
which is actually just macro to um

207
00:08:13,759 --> 00:08:18,080
to attribute that the end couldn't be

208
00:08:17,120 --> 00:08:20,879
reached

209
00:08:18,080 --> 00:08:23,198
so it adds the ic unreachable to all

210
00:08:20,879 --> 00:08:25,840
occurrences of the insist

211
00:08:23,199 --> 00:08:26,879
where it's not already there so that's

212
00:08:25,840 --> 00:08:29,359
the condition

213
00:08:26,879 --> 00:08:31,120
behind i'm sorry for the unicode

214
00:08:29,360 --> 00:08:35,360
character it's actually

215
00:08:31,120 --> 00:08:38,560
uh uh

216
00:08:35,360 --> 00:08:41,760
the normal uh asterisk

217
00:08:38,559 --> 00:08:44,000
dash but the font kept like changing

218
00:08:41,760 --> 00:08:44,000
that

219
00:08:44,240 --> 00:08:47,279
and uh and this is more complicated

220
00:08:46,480 --> 00:08:49,920
example

221
00:08:47,279 --> 00:08:50,720
uh we made a recently we made a change

222
00:08:49,920 --> 00:08:54,000
to the

223
00:08:50,720 --> 00:08:56,640
bind allocator so i see mamgat

224
00:08:54,000 --> 00:08:57,360
cannot return null it if it if the

225
00:08:56,640 --> 00:08:59,760
allocation

226
00:08:57,360 --> 00:09:01,360
fails the bind will crash because if you

227
00:08:59,760 --> 00:09:03,360
don't have enough memory

228
00:09:01,360 --> 00:09:05,519
then you have different kind of problems

229
00:09:03,360 --> 00:09:08,480
anyway uh

230
00:09:05,519 --> 00:09:10,160
uh with the current allocators in in

231
00:09:08,480 --> 00:09:13,120
modern operating systems

232
00:09:10,160 --> 00:09:14,959
so this this tries to catch all the all

233
00:09:13,120 --> 00:09:19,920
the occurrences where

234
00:09:14,959 --> 00:09:19,920
um there's a statement

235
00:09:20,160 --> 00:09:24,079
which is you declare a statement s and

236
00:09:22,959 --> 00:09:27,839
then expression v

237
00:09:24,080 --> 00:09:29,600
so if v like a variable

238
00:09:27,839 --> 00:09:30,959
uh is a now and then follows the

239
00:09:29,600 --> 00:09:34,080
statement

240
00:09:30,959 --> 00:09:37,680
uh it just deletes the whole

241
00:09:34,080 --> 00:09:39,360
whole block of the uh with the variable

242
00:09:37,680 --> 00:09:40,959
and there are some uh it's it's quite

243
00:09:39,360 --> 00:09:44,160
smart it it even

244
00:09:40,959 --> 00:09:47,518
i can understand so if uh if

245
00:09:44,160 --> 00:09:50,719
the is not now and there's a block and

246
00:09:47,519 --> 00:09:51,279
uh there's else statement you can just

247
00:09:50,720 --> 00:09:54,480
keep the

248
00:09:51,279 --> 00:09:57,360
uh keep the other block which is uh

249
00:09:54,480 --> 00:09:57,839
the condition on the the first con first

250
00:09:57,360 --> 00:10:01,040
block

251
00:09:57,839 --> 00:10:02,959
on the on the right with the s1 s2

252
00:10:01,040 --> 00:10:05,040
so it can do all kinds of

253
00:10:02,959 --> 00:10:08,000
transformations so it understands the c

254
00:10:05,040 --> 00:10:10,560
code and it transforms the code properly

255
00:10:08,000 --> 00:10:13,519
so it's not like

256
00:10:10,560 --> 00:10:13,839
like find and replace it it understands

257
00:10:13,519 --> 00:10:16,800
the c

258
00:10:13,839 --> 00:10:18,399
code and can delete the whole statements

259
00:10:16,800 --> 00:10:21,359
or transform them

260
00:10:18,399 --> 00:10:21,360
into something else

261
00:10:22,000 --> 00:10:27,200
again if you are working with old cold

262
00:10:25,200 --> 00:10:30,160
call base like buying this and you need

263
00:10:27,200 --> 00:10:34,399
to do extensive refactoring this is very

264
00:10:30,160 --> 00:10:37,439
very cool uh tool and uh

265
00:10:34,399 --> 00:10:40,560
and you should try it

266
00:10:37,440 --> 00:10:40,959
so um there are some more examples how

267
00:10:40,560 --> 00:10:43,680
to

268
00:10:40,959 --> 00:10:44,959
how to do stuff with cosine there's a

269
00:10:43,680 --> 00:10:47,760
web page

270
00:10:44,959 --> 00:10:49,680
uh there's uh we have a directory with

271
00:10:47,760 --> 00:10:50,160
all the semantic patches will be used in

272
00:10:49,680 --> 00:10:52,000
bind

273
00:10:50,160 --> 00:10:54,160
but they are very bind specific and

274
00:10:52,000 --> 00:10:58,560
there's costinellara.org

275
00:10:54,160 --> 00:10:58,560
which is even more examples in a git

276
00:10:58,839 --> 00:11:02,880
repository

277
00:11:00,000 --> 00:11:03,360
so so why and and here comes the fun

278
00:11:02,880 --> 00:11:06,320
part

279
00:11:03,360 --> 00:11:07,760
of well uh it's not so funny if you have

280
00:11:06,320 --> 00:11:12,240
to fix all the bugs

281
00:11:07,760 --> 00:11:12,240
uh so who understands the memory

282
00:11:12,839 --> 00:11:16,880
ordering

283
00:11:14,560 --> 00:11:18,079
oh i'm lucky i can tell you whatever i

284
00:11:16,880 --> 00:11:20,000
want

285
00:11:18,079 --> 00:11:22,079
on a platform with weak memory or

286
00:11:20,000 --> 00:11:25,200
consistency

287
00:11:22,079 --> 00:11:28,640
okay uh me neither uh

288
00:11:25,200 --> 00:11:30,160
well i'm trying um so and what about

289
00:11:28,640 --> 00:11:33,439
memory barriers

290
00:11:30,160 --> 00:11:37,040
like do you know what's that

291
00:11:33,440 --> 00:11:40,399
okay one two

292
00:11:37,040 --> 00:11:41,199
so uh and and bonus question what's luck

293
00:11:40,399 --> 00:11:44,399
elision

294
00:11:41,200 --> 00:11:47,440
would anybody know okay i'm not going to

295
00:11:44,399 --> 00:11:51,200
talk about lock allegiance but it's a

296
00:11:47,440 --> 00:11:54,639
feature on intel processors maybe on

297
00:11:51,200 --> 00:11:58,079
mdt where you can like not block

298
00:11:54,639 --> 00:12:00,639
things but when they collide

299
00:11:58,079 --> 00:12:02,399
you roll back the whole transactions in

300
00:12:00,639 --> 00:12:04,079
on a cpu and memory

301
00:12:02,399 --> 00:12:06,079
and you actually do the locking so you

302
00:12:04,079 --> 00:12:09,920
can avoid some locking

303
00:12:06,079 --> 00:12:11,760
on the hardware very cool but i'm sure

304
00:12:09,920 --> 00:12:15,519
there are some bugs hidden in there

305
00:12:11,760 --> 00:12:15,519
especially with intel um

306
00:12:15,839 --> 00:12:20,800
so uh thread sanitizer uh this is

307
00:12:19,120 --> 00:12:22,480
runtime analyzer so it's

308
00:12:20,800 --> 00:12:25,439
it doesn't analyze the static code but

309
00:12:22,480 --> 00:12:28,399
it analyzed the like running code

310
00:12:25,440 --> 00:12:31,360
it requires tasks it requires requires a

311
00:12:28,399 --> 00:12:33,440
good test suite to run

312
00:12:31,360 --> 00:12:35,279
or you can like run it on your

313
00:12:33,440 --> 00:12:38,720
production if you are

314
00:12:35,279 --> 00:12:39,600
brave enough and it checks for data

315
00:12:38,720 --> 00:12:42,480
races

316
00:12:39,600 --> 00:12:44,160
um like if multiple threads access the

317
00:12:42,480 --> 00:12:46,880
same memory location

318
00:12:44,160 --> 00:12:48,160
uh mutex ordering so if you have like

319
00:12:46,880 --> 00:12:50,079
multiple locks

320
00:12:48,160 --> 00:12:51,600
in place and they are locked in

321
00:12:50,079 --> 00:12:52,959
different order in from different

322
00:12:51,600 --> 00:12:55,360
threads so

323
00:12:52,959 --> 00:12:57,119
there's a possibility of deadlock and

324
00:12:55,360 --> 00:12:58,240
other subtle errors in the interface

325
00:12:57,120 --> 00:13:02,240
programming

326
00:12:58,240 --> 00:13:05,440
um the usage is is again quite simple

327
00:13:02,240 --> 00:13:07,040
you just add a flag to to c flags or

328
00:13:05,440 --> 00:13:09,760
l-flags

329
00:13:07,040 --> 00:13:10,480
well you need both and and for buying we

330
00:13:09,760 --> 00:13:12,319
need to

331
00:13:10,480 --> 00:13:13,600
i told you we are using our own

332
00:13:12,320 --> 00:13:16,639
implementation of of

333
00:13:13,600 --> 00:13:19,120
rw lock uh so fred sanitizer doesn't

334
00:13:16,639 --> 00:13:22,240
understand that so we need to use the

335
00:13:19,120 --> 00:13:24,720
uh the standard p thread rw lock

336
00:13:22,240 --> 00:13:26,000
here then you you build the program and

337
00:13:24,720 --> 00:13:29,040
then you export some

338
00:13:26,000 --> 00:13:31,120
extra options um

339
00:13:29,040 --> 00:13:32,959
we because bind is quite complex we need

340
00:13:31,120 --> 00:13:34,880
to increase the history sizes

341
00:13:32,959 --> 00:13:36,160
like the amount of memory the thread

342
00:13:34,880 --> 00:13:40,320
synthesis used to

343
00:13:36,160 --> 00:13:43,360
to keep track of the memory locations

344
00:13:40,320 --> 00:13:45,120
and some other options which make it

345
00:13:43,360 --> 00:13:48,959
more

346
00:13:45,120 --> 00:13:52,639
like cleaner because

347
00:13:48,959 --> 00:13:55,760
for example lock path lock path t7

348
00:13:52,639 --> 00:13:57,440
uh basically means that the output is

349
00:13:55,760 --> 00:13:59,040
locked in the separate file and it's not

350
00:13:57,440 --> 00:14:02,639
mixed in the in this

351
00:13:59,040 --> 00:14:04,079
standard standard output uh exit code

352
00:14:02,639 --> 00:14:06,560
again means like

353
00:14:04,079 --> 00:14:08,239
usually it exists with execute 66 but if

354
00:14:06,560 --> 00:14:09,680
you are running a test suite you usually

355
00:14:08,240 --> 00:14:11,680
don't want to stop the test to it

356
00:14:09,680 --> 00:14:14,800
because

357
00:14:11,680 --> 00:14:16,800
it failed so um

358
00:14:14,800 --> 00:14:18,880
there are some like options like this

359
00:14:16,800 --> 00:14:21,439
and then you run a test to it

360
00:14:18,880 --> 00:14:22,160
um bind has both unit tests and system

361
00:14:21,440 --> 00:14:26,800
tests

362
00:14:22,160 --> 00:14:29,439
and then there's an output like this so

363
00:14:26,800 --> 00:14:30,160
uh as you can see there are data rays

364
00:14:29,440 --> 00:14:33,680
between the

365
00:14:30,160 --> 00:14:36,800
two threats uh and

366
00:14:33,680 --> 00:14:40,719
there are similar locations like

367
00:14:36,800 --> 00:14:42,399
ic nm handle unref um

368
00:14:40,720 --> 00:14:43,839
but there's a data race and it's quite

369
00:14:42,399 --> 00:14:46,240
interesting data race

370
00:14:43,839 --> 00:14:47,440
because this is the this is the unreal

371
00:14:46,240 --> 00:14:50,399
function

372
00:14:47,440 --> 00:14:51,040
uh it uses reference counting and if the

373
00:14:50,399 --> 00:14:54,160
preference

374
00:14:51,040 --> 00:14:56,399
goes to zero uh which is the the

375
00:14:54,160 --> 00:14:56,800
function isurf count decrement so if it

376
00:14:56,399 --> 00:15:00,079
go

377
00:14:56,800 --> 00:15:02,079
if if it's not zero yet then it returns

378
00:15:00,079 --> 00:15:04,560
but if it's zero then it delicates

379
00:15:02,079 --> 00:15:07,839
resources it should be correct right

380
00:15:04,560 --> 00:15:10,959
so why is there

381
00:15:07,839 --> 00:15:12,560
a data race especially in this function

382
00:15:10,959 --> 00:15:14,719
so it properly uses the reference

383
00:15:12,560 --> 00:15:16,638
counting and then the

384
00:15:14,720 --> 00:15:18,959
like the free function which is called

385
00:15:16,639 --> 00:15:21,040
here it just allocates resource and

386
00:15:18,959 --> 00:15:22,959
that's it

387
00:15:21,040 --> 00:15:25,439
it clears the resource and then it's the

388
00:15:22,959 --> 00:15:28,719
man put is basically the ic version of

389
00:15:25,440 --> 00:15:31,759
free and so

390
00:15:28,720 --> 00:15:35,839
still there's a date race it it looks

391
00:15:31,759 --> 00:15:39,279
like innocent in a cruise right um

392
00:15:35,839 --> 00:15:42,320
so the fix is to either destroy

393
00:15:39,279 --> 00:15:45,199
to the to the reference handle why

394
00:15:42,320 --> 00:15:46,639
because the refcom api uses the standard

395
00:15:45,199 --> 00:15:50,160
atomics

396
00:15:46,639 --> 00:15:51,680
and the decrement function uses the

397
00:15:50,160 --> 00:15:54,959
memory ordering

398
00:15:51,680 --> 00:15:58,160
release and the

399
00:15:54,959 --> 00:16:01,359
destroy function uses the order acquire

400
00:15:58,160 --> 00:16:04,319
and to actually understand this

401
00:16:01,360 --> 00:16:06,079
this is the from the documentation so if

402
00:16:04,320 --> 00:16:08,000
you don't use that

403
00:16:06,079 --> 00:16:09,120
there's no synchronization between the

404
00:16:08,000 --> 00:16:11,920
threads so

405
00:16:09,120 --> 00:16:12,800
the destroy function the missing destroy

406
00:16:11,920 --> 00:16:14,880
function made

407
00:16:12,800 --> 00:16:16,319
the one of the threats not to

408
00:16:14,880 --> 00:16:19,680
synchronize with the other

409
00:16:16,320 --> 00:16:20,560
doing the decrement and then there was a

410
00:16:19,680 --> 00:16:24,719
data race

411
00:16:20,560 --> 00:16:29,119
because of the missing release

412
00:16:24,720 --> 00:16:29,120
load and um

413
00:16:29,279 --> 00:16:36,560
like okay so who now thinks

414
00:16:32,320 --> 00:16:39,440
understands memory ordering

415
00:16:36,560 --> 00:16:40,560
uh i understand memory ordering and

416
00:16:39,440 --> 00:16:44,000
atomics more than i

417
00:16:40,560 --> 00:16:46,239
understood them a year ago but i'm still

418
00:16:44,000 --> 00:16:46,240
like

419
00:16:48,839 --> 00:16:56,160
um another example

420
00:16:51,440 --> 00:16:59,279
uh there's a data race on the power pc64

421
00:16:56,160 --> 00:17:02,000
uh reported by red hat because they

422
00:16:59,279 --> 00:17:03,120
do have some interesting hardware and

423
00:17:02,000 --> 00:17:06,240
it's it's caused by

424
00:17:03,120 --> 00:17:06,880
our own rw lock and the proposed patch

425
00:17:06,240 --> 00:17:10,400
again

426
00:17:06,880 --> 00:17:12,240
changes the uh

427
00:17:10,400 --> 00:17:14,160
memory earning from relaxed which

428
00:17:12,240 --> 00:17:17,520
doesn't cause any synchronization

429
00:17:14,160 --> 00:17:19,919
to acquire and

430
00:17:17,520 --> 00:17:21,760
and the compare exchange operation again

431
00:17:19,919 --> 00:17:24,959
to acquire

432
00:17:21,760 --> 00:17:26,879
on a synthetic benchmark it works i just

433
00:17:24,959 --> 00:17:27,520
i just look at the function and i think

434
00:17:26,880 --> 00:17:31,760
that

435
00:17:27,520 --> 00:17:34,160
basically uh there's an error in our rw

436
00:17:31,760 --> 00:17:37,760
implementation but we haven't seen it

437
00:17:34,160 --> 00:17:40,880
because the usual hardware has a

438
00:17:37,760 --> 00:17:41,919
strong memory consistency and it doesn't

439
00:17:40,880 --> 00:17:44,640
manifest so it

440
00:17:41,919 --> 00:17:47,200
manifests only on the power pc64 because

441
00:17:44,640 --> 00:17:50,160
it has a weak memory consistency

442
00:17:47,200 --> 00:17:50,160
again like

443
00:17:51,760 --> 00:17:56,799
so um but

444
00:17:55,280 --> 00:17:59,280
i think that there's a there's a lesson

445
00:17:56,799 --> 00:18:03,120
to be learned here so to my

446
00:17:59,280 --> 00:18:04,240
um i like the saying don't do your own

447
00:18:03,120 --> 00:18:06,399
crypto

448
00:18:04,240 --> 00:18:07,679
and i would add don't do your own

449
00:18:06,400 --> 00:18:09,280
locking

450
00:18:07,679 --> 00:18:11,520
unless you absolutely know what you are

451
00:18:09,280 --> 00:18:11,520
doing

452
00:18:12,400 --> 00:18:16,559
and um and the good news is that in a

453
00:18:15,440 --> 00:18:21,280
new version

454
00:18:16,559 --> 00:18:21,280
by 916 uh we are actually

455
00:18:21,760 --> 00:18:28,000
have running a benchmark now with the

456
00:18:24,960 --> 00:18:30,240
system library rw lock

457
00:18:28,000 --> 00:18:31,520
and with some other tweaks we are over

458
00:18:30,240 --> 00:18:34,640
one million

459
00:18:31,520 --> 00:18:35,520
requests per second so just dropping our

460
00:18:34,640 --> 00:18:37,520
own rw

461
00:18:35,520 --> 00:18:39,600
implementation increases the performance

462
00:18:37,520 --> 00:18:43,280
because we changed the other part

463
00:18:39,600 --> 00:18:43,678
of bind so that's good news we might be

464
00:18:43,280 --> 00:18:45,280
like

465
00:18:43,679 --> 00:18:47,679
we might be dropping the implementation

466
00:18:45,280 --> 00:18:47,678
at all

467
00:18:49,600 --> 00:18:53,120
another example um

468
00:18:53,520 --> 00:18:57,360
there's a comment no one else has this

469
00:18:55,840 --> 00:19:00,959
socket so we can free it

470
00:18:57,360 --> 00:19:03,600
right uh

471
00:19:00,960 --> 00:19:05,440
and and the fix is actually to lock the

472
00:19:03,600 --> 00:19:09,600
the sock instruction

473
00:19:05,440 --> 00:19:12,960
socket structure because um

474
00:19:09,600 --> 00:19:16,320
again there was a bug which

475
00:19:12,960 --> 00:19:18,000
no one else has the socket except when

476
00:19:16,320 --> 00:19:21,280
you are on freebsd

477
00:19:18,000 --> 00:19:22,240
in a vmware on a hardware reload of

478
00:19:21,280 --> 00:19:25,678
course

479
00:19:22,240 --> 00:19:28,559
it was very hard to reproduce uh

480
00:19:25,679 --> 00:19:29,840
and uh but it was reported by the

481
00:19:28,559 --> 00:19:32,879
freebsd maintainer

482
00:19:29,840 --> 00:19:33,439
uh and thank you for uh for all the work

483
00:19:32,880 --> 00:19:36,559
he does

484
00:19:33,440 --> 00:19:36,880
uh by reporting the bugs to us but it

485
00:19:36,559 --> 00:19:39,360
was

486
00:19:36,880 --> 00:19:41,280
it was very weird but we trusted like

487
00:19:39,360 --> 00:19:44,000
with a lot of cores on linux

488
00:19:41,280 --> 00:19:45,360
but it only manifests in the free on

489
00:19:44,000 --> 00:19:49,840
freebsd in vm

490
00:19:45,360 --> 00:19:49,840
vmware like

491
00:19:50,080 --> 00:19:54,639
if if anybody can save me why then i

492
00:19:53,120 --> 00:19:58,000
would be happy to listen

493
00:19:54,640 --> 00:20:01,760
um so another another

494
00:19:58,000 --> 00:20:04,400
thing uh on freebsd

495
00:20:01,760 --> 00:20:06,400
we added to our continuous integration

496
00:20:04,400 --> 00:20:07,840
we added freebsd and windows in

497
00:20:06,400 --> 00:20:10,000
september last year

498
00:20:07,840 --> 00:20:10,879
we also added open bsd because if you

499
00:20:10,000 --> 00:20:14,320
don't run in

500
00:20:10,880 --> 00:20:16,159
in the ci on every merge request then it

501
00:20:14,320 --> 00:20:17,678
it's like it's not happening because the

502
00:20:16,159 --> 00:20:18,559
developers are going to ignore the

503
00:20:17,679 --> 00:20:21,600
reports that

504
00:20:18,559 --> 00:20:23,678
came asynchronously and and there was an

505
00:20:21,600 --> 00:20:25,199
intermittent failure in the freebsd

506
00:20:23,679 --> 00:20:28,159
system test job

507
00:20:25,200 --> 00:20:30,400
and it was a crash in the lib threat

508
00:20:28,159 --> 00:20:34,480
system library

509
00:20:30,400 --> 00:20:37,679
and it was a open ssl exit concurrency

510
00:20:34,480 --> 00:20:41,200
because openssl 1.1

511
00:20:37,679 --> 00:20:42,880
automatically destroys the resources

512
00:20:41,200 --> 00:20:44,240
but if you have a multiple threads

513
00:20:42,880 --> 00:20:49,039
running and

514
00:20:44,240 --> 00:20:50,799
and shutting down the resources then

515
00:20:49,039 --> 00:20:53,200
one of the threads where destroying the

516
00:20:50,799 --> 00:20:54,639
mutex is held by the open ssl before the

517
00:20:53,200 --> 00:20:57,360
open ssl

518
00:20:54,640 --> 00:20:58,159
on exit functions ran so we had to

519
00:20:57,360 --> 00:21:02,719
request that

520
00:20:58,159 --> 00:21:05,520
like there's an internal task manager

521
00:21:02,720 --> 00:21:06,960
in bind so in the fatal function you

522
00:21:05,520 --> 00:21:09,520
have to request the

523
00:21:06,960 --> 00:21:12,080
exclusivity of a task manager so it

524
00:21:09,520 --> 00:21:16,240
finishes all the other stuff before

525
00:21:12,080 --> 00:21:19,439
it crashes again like

526
00:21:16,240 --> 00:21:21,360
uh uh it was very weird because we were

527
00:21:19,440 --> 00:21:25,280
like looking why it's crushing in the

528
00:21:21,360 --> 00:21:25,280
in the system library um

529
00:21:26,159 --> 00:21:30,640
um here's the here's a quote from the

530
00:21:27,919 --> 00:21:30,640
documentation

531
00:21:32,000 --> 00:21:35,360
the other type of the box is the lock

532
00:21:34,159 --> 00:21:37,360
order inversion

533
00:21:35,360 --> 00:21:40,080
and this is actually the the cycle at

534
00:21:37,360 --> 00:21:44,879
the beginning is quite short i have some

535
00:21:40,080 --> 00:21:47,918
like eight eight mutex long

536
00:21:44,880 --> 00:21:49,520
uh bucks uh in bind at the moment they

537
00:21:47,919 --> 00:21:52,799
are not yet fixed

538
00:21:49,520 --> 00:21:54,799
and but it looks like like like mixing

539
00:21:52,799 --> 00:21:56,840
the mutexes in a different order from

540
00:21:54,799 --> 00:22:01,280
different frets

541
00:21:56,840 --> 00:22:05,280
um just an example how it looks

542
00:22:01,280 --> 00:22:08,240
um the most simple thing you can do

543
00:22:05,280 --> 00:22:09,360
is the convert the locking to because

544
00:22:08,240 --> 00:22:11,919
there's there's a lot of

545
00:22:09,360 --> 00:22:14,000
flags and structures so we just

546
00:22:11,919 --> 00:22:16,960
converted this this flag

547
00:22:14,000 --> 00:22:17,679
removed to standard atomics dropped the

548
00:22:16,960 --> 00:22:22,720
locking at

549
00:22:17,679 --> 00:22:24,880
all and it's protected by the atomics

550
00:22:22,720 --> 00:22:27,840
and now you have to get the memory

551
00:22:24,880 --> 00:22:27,840
ordering right

552
00:22:28,880 --> 00:22:32,880
so are we there yet with the thread

553
00:22:30,720 --> 00:22:35,440
sanitizer

554
00:22:32,880 --> 00:22:38,240
not yet so this is the current result on

555
00:22:35,440 --> 00:22:41,600
the on the bind master

556
00:22:38,240 --> 00:22:43,200
there's like 10 distinct

557
00:22:41,600 --> 00:22:44,639
warnings from the from the thread

558
00:22:43,200 --> 00:22:47,919
sanitizer but

559
00:22:44,640 --> 00:22:50,159
uh there's something like more than 200

560
00:22:47,919 --> 00:22:52,159
different paths to to the warning

561
00:22:50,159 --> 00:22:56,000
there's a lot of

562
00:22:52,159 --> 00:22:58,880
duplicates like these six

563
00:22:56,000 --> 00:22:59,200
errors are probably the same one and in

564
00:22:58,880 --> 00:23:00,720
the

565
00:22:59,200 --> 00:23:02,559
in the log ordering there's probably

566
00:23:00,720 --> 00:23:04,640
also

567
00:23:02,559 --> 00:23:06,158
a lot of duplicates so it's not that

568
00:23:04,640 --> 00:23:09,200
that much box

569
00:23:06,159 --> 00:23:10,559
um but we are not there yet it doesn't

570
00:23:09,200 --> 00:23:14,080
crash on a regular basis

571
00:23:10,559 --> 00:23:16,960
it just sometimes something happens and

572
00:23:14,080 --> 00:23:16,960
we don't know why

573
00:23:18,240 --> 00:23:24,000
and and getting

574
00:23:21,760 --> 00:23:25,600
getting this clean means that we can run

575
00:23:24,000 --> 00:23:27,679
the thread synthesizer in the strict

576
00:23:25,600 --> 00:23:29,360
mode so if there's a new warning

577
00:23:27,679 --> 00:23:31,520
it will stop the merge request from

578
00:23:29,360 --> 00:23:34,719
being merged and

579
00:23:31,520 --> 00:23:39,440
uh but as i said we are not there yet

580
00:23:34,720 --> 00:23:39,440
um so thank you for listening

581
00:23:40,640 --> 00:23:43,120
and if

582
00:23:47,919 --> 00:23:52,960
we have seven minutes for questions if

583
00:23:50,000 --> 00:23:56,159
you have any questions

584
00:23:52,960 --> 00:24:04,960
not about memory ordering please

585
00:23:56,159 --> 00:24:08,000
i have several

586
00:24:04,960 --> 00:24:11,039
uh just a uh very quick one um

587
00:24:08,000 --> 00:24:14,880
did you um also uh enable more

588
00:24:11,039 --> 00:24:14,879
compiler warnings over time um

589
00:24:15,360 --> 00:24:23,760
yeah we run with uh walw

590
00:24:19,919 --> 00:24:26,559
extra all the time and we also have a

591
00:24:23,760 --> 00:24:27,919
in the ci we have multiple jobs so we

592
00:24:26,559 --> 00:24:29,918
run with clank

593
00:24:27,919 --> 00:24:32,159
we run with gcc and we run with

594
00:24:29,919 --> 00:24:33,360
different optimization options because

595
00:24:32,159 --> 00:24:36,880
sometimes it also

596
00:24:33,360 --> 00:24:38,158
if you run with minus o0 sometimes it

597
00:24:36,880 --> 00:24:41,760
reports stuff that's

598
00:24:38,159 --> 00:24:44,880
not real back but it like

599
00:24:41,760 --> 00:24:44,879
i don't know there was a

600
00:24:45,520 --> 00:24:52,720
there was a code that

601
00:24:49,600 --> 00:24:55,678
if there was a variable zero

602
00:24:52,720 --> 00:24:57,840
it didn't run a loop so on a higher

603
00:24:55,679 --> 00:25:00,559
level of optimization that got optimized

604
00:24:57,840 --> 00:25:01,678
out but on a lower level optimization it

605
00:25:00,559 --> 00:25:04,960
prints a warning

606
00:25:01,679 --> 00:25:06,480
about something so so again like trying

607
00:25:04,960 --> 00:25:09,520
different optimization options from

608
00:25:06,480 --> 00:25:11,600
minus o0 to minus o3

609
00:25:09,520 --> 00:25:13,360
is also a good option in in the ci

610
00:25:11,600 --> 00:25:15,918
because the compilers

611
00:25:13,360 --> 00:25:18,000
do a different stuff also running the

612
00:25:15,919 --> 00:25:21,760
thread synthesizer with clank

613
00:25:18,000 --> 00:25:24,240
and gcc uh various different results

614
00:25:21,760 --> 00:25:25,360
so that that's also thing you should do

615
00:25:24,240 --> 00:25:28,640
if you're running

616
00:25:25,360 --> 00:25:29,439
the sanitizers just just do the

617
00:25:28,640 --> 00:25:32,720
different

618
00:25:29,440 --> 00:25:36,720
uh compilers because they did you know

619
00:25:32,720 --> 00:25:36,720
they created a little bit different code

620
00:25:39,360 --> 00:25:43,840
i see a question you just talk loud

621
00:25:54,000 --> 00:25:59,039
i don't know i don't know what is our

622
00:25:55,360 --> 00:25:59,039
code coverage at the moment oh

623
00:26:02,799 --> 00:26:06,639
you'll go back like 30 slides

624
00:26:13,520 --> 00:26:15,760
okay

625
00:26:16,559 --> 00:26:19,200
question here

626
00:26:20,480 --> 00:26:24,080
i would like to ask you about c plus

627
00:26:22,640 --> 00:26:27,520
plus check

628
00:26:24,080 --> 00:26:30,399
you use this tool to try to find

629
00:26:27,520 --> 00:26:31,918
bugs or exceptions in your code is it

630
00:26:30,400 --> 00:26:35,440
possible to use it to

631
00:26:31,919 --> 00:26:35,440
for checking coding style

632
00:26:35,679 --> 00:26:40,320
well bind is written in plain c so uh

633
00:26:38,720 --> 00:26:41,200
but i do i don't know if the c plus plus

634
00:26:40,320 --> 00:26:44,720
check

635
00:26:41,200 --> 00:26:47,039
check check okay yeah you mean

636
00:26:44,720 --> 00:26:50,000
does it mean this one is it possible to

637
00:26:47,039 --> 00:26:54,799
check just coding style

638
00:26:50,000 --> 00:26:57,039
um some yes it um

639
00:26:54,799 --> 00:26:58,400
on some optim on some strictness level

640
00:26:57,039 --> 00:27:01,120
it also reports like

641
00:26:58,400 --> 00:27:03,600
uh variable scoping so when you can

642
00:27:01,120 --> 00:27:06,000
reduce the this cooperative variable

643
00:27:03,600 --> 00:27:08,240
uh and and some others it's it's quite

644
00:27:06,000 --> 00:27:10,960
extensive lists actually so

645
00:27:08,240 --> 00:27:11,760
uh but it would be moves to just so show

646
00:27:10,960 --> 00:27:15,279
it here

647
00:27:11,760 --> 00:27:17,919
but this is what we use so we uh

648
00:27:15,279 --> 00:27:18,320
this is this is from our ci the line so

649
00:27:17,919 --> 00:27:22,399
we are

650
00:27:18,320 --> 00:27:25,600
just using these but um i have a

651
00:27:22,399 --> 00:27:29,279
i'm in the emacs camp

652
00:27:25,600 --> 00:27:29,678
so uh and i do my coding in emacs so i

653
00:27:29,279 --> 00:27:32,880
use

654
00:27:29,679 --> 00:27:34,320
flightcheck to run cpp check and and

655
00:27:32,880 --> 00:27:38,399
clank

656
00:27:34,320 --> 00:27:40,240
um on my code so it automatically like

657
00:27:38,399 --> 00:27:41,520
highlights the the issues i'm i'm

658
00:27:40,240 --> 00:27:44,720
probably sure that

659
00:27:41,520 --> 00:27:48,960
the the stuff that the young

660
00:27:44,720 --> 00:27:51,520
people use like all the ide

661
00:27:48,960 --> 00:27:52,559
so that it does just as well but the

662
00:27:51,520 --> 00:27:53,750
e-max

663
00:27:52,559 --> 00:27:55,580
i like e-max

664
00:27:53,750 --> 00:27:57,039
[Laughter]

665
00:27:55,580 --> 00:28:01,360
[Applause]

666
00:27:57,039 --> 00:28:04,158
so what's bear make bear make it's uh

667
00:28:01,360 --> 00:28:04,559
it creates the the compilation database

668
00:28:04,159 --> 00:28:07,279
right

669
00:28:04,559 --> 00:28:07,279
okay okay

670
00:28:07,679 --> 00:28:10,559
any other questions

671
00:28:10,799 --> 00:28:14,559
so are you finding that ci is very

672
00:28:12,799 --> 00:28:16,480
expensive or

673
00:28:14,559 --> 00:28:18,320
slows down your team because i found

674
00:28:16,480 --> 00:28:22,000
that those are the options

675
00:28:18,320 --> 00:28:26,000
so right now um we are using

676
00:28:22,000 --> 00:28:28,320
uh um like hosted

677
00:28:26,000 --> 00:28:30,000
bare metal servers and we have like

678
00:28:28,320 --> 00:28:31,678
eight of them

679
00:28:30,000 --> 00:28:34,480
to run all the ci but we have something

680
00:28:31,679 --> 00:28:36,880
like 50 56 jobs at the moment

681
00:28:34,480 --> 00:28:38,000
so it and it it's getting slower and

682
00:28:36,880 --> 00:28:40,000
slower as we had more

683
00:28:38,000 --> 00:28:42,640
and more tests we also have windows in

684
00:28:40,000 --> 00:28:44,559
the ci so it's it just consumed

685
00:28:42,640 --> 00:28:46,720
one one of the machines but the other

686
00:28:44,559 --> 00:28:50,080
machines are shared so if you are

687
00:28:46,720 --> 00:28:53,279
um openbsd is ran

688
00:28:50,080 --> 00:28:55,600
in the qemu

689
00:28:53,279 --> 00:28:56,399
freebsd had also consumed its own

690
00:28:55,600 --> 00:28:59,760
machine

691
00:28:56,399 --> 00:29:00,959
and it uses jails uh we wrote a plug-in

692
00:28:59,760 --> 00:29:05,200
for gitlab ci

693
00:29:00,960 --> 00:29:08,240
to use jails in the in the gitlab ci um

694
00:29:05,200 --> 00:29:09,600
and also the openbsd that's also our own

695
00:29:08,240 --> 00:29:13,200
plugin

696
00:29:09,600 --> 00:29:15,120
for linux it uses the standard locker

697
00:29:13,200 --> 00:29:18,720
but for for the other systems we had to

698
00:29:15,120 --> 00:29:22,000
write custom executors for the gitlab ci

699
00:29:18,720 --> 00:29:25,039
um so define expensive so

700
00:29:22,000 --> 00:29:28,080
if it catches back it would cause a cv

701
00:29:25,039 --> 00:29:30,799
later was it was that expensive no no

702
00:29:28,080 --> 00:29:32,320
no but i i found in in some teams that

703
00:29:30,799 --> 00:29:34,240
it

704
00:29:32,320 --> 00:29:35,520
can scare people off like you say we're

705
00:29:34,240 --> 00:29:36,320
going to spend a thousand dollars a

706
00:29:35,520 --> 00:29:38,320
month now

707
00:29:36,320 --> 00:29:40,240
on just testing the code all the time

708
00:29:38,320 --> 00:29:42,399
they say well can we do 100

709
00:29:40,240 --> 00:29:44,159
and well yes then the team can do one

710
00:29:42,399 --> 00:29:47,439
feature a week

711
00:29:44,159 --> 00:29:48,559
yeah we are spending something under 100

712
00:29:47,440 --> 00:29:51,679
000 dollars

713
00:29:48,559 --> 00:29:54,639
per month four hundred thousand thousand

714
00:29:51,679 --> 00:29:54,640
hundred thousand thousand

715
00:30:01,279 --> 00:30:09,840
thank you

716
00:30:13,679 --> 00:30:15,760
you

