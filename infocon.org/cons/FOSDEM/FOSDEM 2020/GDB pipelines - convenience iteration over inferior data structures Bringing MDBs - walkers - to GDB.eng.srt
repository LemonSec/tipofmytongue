1
00:00:04,960 --> 00:00:08,719
hello

2
00:00:05,680 --> 00:00:09,920
uh so yeah i'm i'm going to introduce a

3
00:00:08,720 --> 00:00:12,799
plug-in

4
00:00:09,920 --> 00:00:15,838
over it and that adds the concept of

5
00:00:12,799 --> 00:00:17,840
pipelines and iterators to gdb

6
00:00:15,839 --> 00:00:18,960
this is especially handy for finding the

7
00:00:17,840 --> 00:00:21,600
interesting element

8
00:00:18,960 --> 00:00:22,320
in a data container and can easily be

9
00:00:21,600 --> 00:00:25,279
extended

10
00:00:22,320 --> 00:00:26,960
to work on whatever data structures you

11
00:00:25,279 --> 00:00:28,240
use in your program

12
00:00:26,960 --> 00:00:29,679
so i've got a set up for live

13
00:00:28,240 --> 00:00:31,198
demonstration that might need a bit of

14
00:00:29,679 --> 00:00:33,120
explanation

15
00:00:31,199 --> 00:00:35,280
this is vim open on a file where i've

16
00:00:33,120 --> 00:00:38,640
written the commands i'm going to run

17
00:00:35,280 --> 00:00:41,760
uh lines like this are commands to run

18
00:00:38,640 --> 00:00:42,879
with a uh hash our comments i've got a

19
00:00:41,760 --> 00:00:44,879
little

20
00:00:42,879 --> 00:00:46,718
thing that goes to the next comment with

21
00:00:44,879 --> 00:00:48,960
a number and runs all the commands under

22
00:00:46,719 --> 00:00:48,960
there

23
00:00:49,039 --> 00:00:54,960
so i've started gdb on a

24
00:00:52,640 --> 00:00:56,559
program that's in this uh extensions

25
00:00:54,960 --> 00:00:59,440
test suite

26
00:00:56,559 --> 00:01:02,000
the help of the new command gdb pipe

27
00:00:59,440 --> 00:01:04,878
shows the basic syntax

28
00:01:02,000 --> 00:01:06,720
this is a command that denotes the

29
00:01:04,879 --> 00:01:09,760
creation of a pipeline

30
00:01:06,720 --> 00:01:12,320
it takes a long string argument which is

31
00:01:09,760 --> 00:01:13,760
all the walkers which are the iterators

32
00:01:12,320 --> 00:01:17,679
over something

33
00:01:13,760 --> 00:01:21,040
separated by the text space bar space

34
00:01:17,680 --> 00:01:22,720
each walker can take a sequence of

35
00:01:21,040 --> 00:01:24,560
pointers

36
00:01:22,720 --> 00:01:26,640
optionally do something with them and

37
00:01:24,560 --> 00:01:28,720
then pass an up possibly different

38
00:01:26,640 --> 00:01:31,840
sequence of pointers on to the next

39
00:01:28,720 --> 00:01:34,158
rest of the pipeline should be

40
00:01:31,840 --> 00:01:36,079
reminiscent of unix pipelines with the

41
00:01:34,159 --> 00:01:38,720
place of a unix command taken by one of

42
00:01:36,079 --> 00:01:38,720
these walkers

43
00:01:39,759 --> 00:01:44,240
you can find help on uh walkers with the

44
00:01:42,720 --> 00:01:47,679
walker help command

45
00:01:44,240 --> 00:01:51,839
which has a few different forms uh you

46
00:01:47,680 --> 00:01:53,840
can request help on an individual walker

47
00:01:51,840 --> 00:01:57,200
but you can also list all walkers

48
00:01:53,840 --> 00:01:58,799
currently registered with the plugin

49
00:01:57,200 --> 00:02:00,880
list the tags that walkers are

50
00:01:58,799 --> 00:02:03,520
categorized under

51
00:02:00,880 --> 00:02:06,079
or list all walkers categorized under a

52
00:02:03,520 --> 00:02:08,239
given tag

53
00:02:06,079 --> 00:02:10,239
uh oh i should mention there's also a

54
00:02:08,239 --> 00:02:15,440
walker

55
00:02:10,239 --> 00:02:19,760
what the hell apropos

56
00:02:15,440 --> 00:02:21,520
so walker apparel pro command which

57
00:02:19,760 --> 00:02:25,040
searches through the dog strings for

58
00:02:21,520 --> 00:02:25,040
things related to a given word

59
00:02:25,360 --> 00:02:29,920
so this is the basic dim

60
00:02:28,560 --> 00:02:33,360
data structure that i'm going to give

61
00:02:29,920 --> 00:02:35,280
some uh small examples on

62
00:02:33,360 --> 00:02:37,040
i'm going to start off with examples on

63
00:02:35,280 --> 00:02:38,239
this before going on to real world

64
00:02:37,040 --> 00:02:39,920
examples

65
00:02:38,239 --> 00:02:41,920
and then showing how you would write

66
00:02:39,920 --> 00:02:45,440
your own

67
00:02:41,920 --> 00:02:48,238
so here we have a linked list structure

68
00:02:45,440 --> 00:02:49,359
where each node has a data type or some

69
00:02:48,239 --> 00:02:51,760
integer data

70
00:02:49,360 --> 00:02:52,720
and a pointer to the next uh node in the

71
00:02:51,760 --> 00:02:55,518
list

72
00:02:52,720 --> 00:02:56,160
i hope you'll just trust me that the end

73
00:02:55,519 --> 00:02:59,040
of this

74
00:02:56,160 --> 00:03:00,959
list is indicated with a null pointer in

75
00:02:59,040 --> 00:03:02,799
that next note

76
00:03:00,959 --> 00:03:05,680
structures of this sort can be iterated

77
00:03:02,800 --> 00:03:08,319
over using the linked list walker

78
00:03:05,680 --> 00:03:09,920
we can see the syntax of this walker uh

79
00:03:08,319 --> 00:03:11,760
with walker help command

80
00:03:09,920 --> 00:03:13,200
including mention that it's simply a

81
00:03:11,760 --> 00:03:15,280
convenience for

82
00:03:13,200 --> 00:03:16,238
uh using this more general follow and

83
00:03:15,280 --> 00:03:19,599
till walker

84
00:03:16,239 --> 00:03:22,560
with a more complex syntax

85
00:03:19,599 --> 00:03:23,200
so if i start the program and run until

86
00:03:22,560 --> 00:03:25,920
a

87
00:03:23,200 --> 00:03:26,879
known point in program where the head of

88
00:03:25,920 --> 00:03:29,599
this list is

89
00:03:26,879 --> 00:03:31,440
in this local variable named list head

90
00:03:29,599 --> 00:03:32,640
we can iterate over all nodes in this

91
00:03:31,440 --> 00:03:36,879
list

92
00:03:32,640 --> 00:03:39,440
with this walker we can also pass that

93
00:03:36,879 --> 00:03:42,319
to the show walker to print out the data

94
00:03:39,440 --> 00:03:44,640
element on each of these nodes

95
00:03:42,319 --> 00:03:47,200
the show walker takes the template of a

96
00:03:44,640 --> 00:03:50,559
gdb command to run

97
00:03:47,200 --> 00:03:52,798
and runs that gdb command for

98
00:03:50,560 --> 00:03:54,080
for each pointer in turn with this

99
00:03:52,799 --> 00:03:56,000
dollar curve variable

100
00:03:54,080 --> 00:03:57,200
replaced by the address coming from the

101
00:03:56,000 --> 00:04:01,200
previous uh

102
00:03:57,200 --> 00:04:04,000
preceding pipeline that dollar cur

103
00:04:01,200 --> 00:04:05,599
use is consistent throughout the pr

104
00:04:04,000 --> 00:04:09,120
plugin

105
00:04:05,599 --> 00:04:10,000
so we printed out each the data on each

106
00:04:09,120 --> 00:04:12,400
node

107
00:04:10,000 --> 00:04:13,280
but we can also filter to select only

108
00:04:12,400 --> 00:04:14,799
those nodes

109
00:04:13,280 --> 00:04:17,600
which have a data member greater than

110
00:04:14,799 --> 00:04:19,280
some value we can sort the nodes based

111
00:04:17,600 --> 00:04:21,600
on their data value

112
00:04:19,279 --> 00:04:23,679
or we can find the single node or three

113
00:04:21,600 --> 00:04:26,080
nodes with the greatest values

114
00:04:23,680 --> 00:04:28,080
or with mod uh minimum of modification

115
00:04:26,080 --> 00:04:31,919
to that initial command

116
00:04:28,080 --> 00:04:33,440
and hopefully that should be a um

117
00:04:31,919 --> 00:04:36,080
intuitive modification to the initial

118
00:04:33,440 --> 00:04:36,080
command as well

119
00:04:36,400 --> 00:04:39,440
so there you have the uh gist of the

120
00:04:38,880 --> 00:04:43,440
plugin

121
00:04:39,440 --> 00:04:45,440
we iterate over all values in something

122
00:04:43,440 --> 00:04:46,800
optionally do something with each one

123
00:04:45,440 --> 00:04:49,040
and finally

124
00:04:46,800 --> 00:04:50,720
like pass that on to the rest of the

125
00:04:49,040 --> 00:04:52,400
pipeline

126
00:04:50,720 --> 00:04:53,759
i'm now going to go into some real world

127
00:04:52,400 --> 00:04:56,799
examples uh

128
00:04:53,759 --> 00:04:59,840
i'm just starting gcc running under gdb

129
00:04:56,800 --> 00:05:01,440
which is taking a little time

130
00:04:59,840 --> 00:05:02,880
because i've i recently have been

131
00:05:01,440 --> 00:05:04,719
working on gcc and

132
00:05:02,880 --> 00:05:06,719
i've got two real world examples from

133
00:05:04,720 --> 00:05:08,800
there i'll then

134
00:05:06,720 --> 00:05:10,000
use a real world example from my

135
00:05:08,800 --> 00:05:13,680
co-workers side project

136
00:05:10,000 --> 00:05:16,960
where he's been writing an artos

137
00:05:13,680 --> 00:05:18,080
so i've now started gcc and if we list

138
00:05:16,960 --> 00:05:19,919
those categories

139
00:05:18,080 --> 00:05:23,520
you can see there's a new category named

140
00:05:19,919 --> 00:05:25,840
cc1 just at the start there

141
00:05:23,520 --> 00:05:26,880
under this category there are a bunch of

142
00:05:25,840 --> 00:05:30,080
walkers

143
00:05:26,880 --> 00:05:32,000
specifically for gcc data structures

144
00:05:30,080 --> 00:05:33,520
these have been automatically loaded

145
00:05:32,000 --> 00:05:34,400
based on the name of the binary that i'm

146
00:05:33,520 --> 00:05:36,240
debugging

147
00:05:34,400 --> 00:05:39,039
using an auto import mechanism i'll

148
00:05:36,240 --> 00:05:41,520
describe later

149
00:05:39,039 --> 00:05:42,719
as is often the case the most used

150
00:05:41,520 --> 00:05:45,198
feature of this plugin

151
00:05:42,720 --> 00:05:46,639
is the simplest and the simplest feature

152
00:05:45,199 --> 00:05:48,560
here is pretty much just to print

153
00:05:46,639 --> 00:05:52,800
everything out

154
00:05:48,560 --> 00:05:56,479
so i often find myself

155
00:05:52,800 --> 00:05:59,759
gcc has a dump uh files

156
00:05:56,479 --> 00:06:02,960
which print out the representation or in

157
00:05:59,759 --> 00:06:05,680
of its internal language at each stage

158
00:06:02,960 --> 00:06:06,000
because i'm relatively new to this i

159
00:06:05,680 --> 00:06:08,560
want

160
00:06:06,000 --> 00:06:09,360
to i quite often find myself seeing one

161
00:06:08,560 --> 00:06:12,400
of these

162
00:06:09,360 --> 00:06:13,600
statements in the dump file and going i

163
00:06:12,400 --> 00:06:15,840
want to know

164
00:06:13,600 --> 00:06:18,479
what the object looks like that causes

165
00:06:15,840 --> 00:06:18,479
that statement

166
00:06:18,560 --> 00:06:22,800
i i know the uh object is in my data

167
00:06:21,840 --> 00:06:24,318
structure somewhere

168
00:06:22,800 --> 00:06:27,199
but i don't have a reference to it in

169
00:06:24,319 --> 00:06:29,919
gdb so i can't access it

170
00:06:27,199 --> 00:06:31,840
i tend to approach this using a creative

171
00:06:29,919 --> 00:06:32,318
use of break points and conditions to

172
00:06:31,840 --> 00:06:35,440
stop

173
00:06:32,319 --> 00:06:37,039
in a point in my program where that is

174
00:06:35,440 --> 00:06:39,600
in local scope

175
00:06:37,039 --> 00:06:40,240
but using this plugin i can simply

176
00:06:39,600 --> 00:06:42,479
iterate

177
00:06:40,240 --> 00:06:43,360
over all statements printing their debug

178
00:06:42,479 --> 00:06:45,758
output

179
00:06:43,360 --> 00:06:47,039
right next to the address that the node

180
00:06:45,759 --> 00:06:48,400
is at

181
00:06:47,039 --> 00:06:50,639
again and search for the one i'm

182
00:06:48,400 --> 00:06:52,719
interested in

183
00:06:50,639 --> 00:06:53,759
and copy that address and assign it to

184
00:06:52,720 --> 00:06:56,000
an uh

185
00:06:53,759 --> 00:06:56,960
internal variable sorry convenience

186
00:06:56,000 --> 00:07:00,000
variable

187
00:06:56,960 --> 00:07:03,198
for later inspection

188
00:07:00,000 --> 00:07:05,680
if i know some criteria that is

189
00:07:03,199 --> 00:07:07,360
like so i here i know it's a function

190
00:07:05,680 --> 00:07:09,440
call that i'm interested in

191
00:07:07,360 --> 00:07:10,880
i can simply put an if statement so i

192
00:07:09,440 --> 00:07:14,240
can search through

193
00:07:10,880 --> 00:07:16,159
less statements there this means i don't

194
00:07:14,240 --> 00:07:16,720
have to move my program past the point

195
00:07:16,160 --> 00:07:18,880
that i'm

196
00:07:16,720 --> 00:07:21,759
stopped at in order to inspect that

197
00:07:18,880 --> 00:07:23,840
variable i wanted to

198
00:07:21,759 --> 00:07:25,440
so as i've said that's the most simple

199
00:07:23,840 --> 00:07:27,679
action you can do

200
00:07:25,440 --> 00:07:30,400
but you can also do any complicated

201
00:07:27,680 --> 00:07:36,800
action you can think of

202
00:07:30,400 --> 00:07:40,000
so just starting gcc again

203
00:07:36,800 --> 00:07:42,240
it has a list of passes where each

204
00:07:40,000 --> 00:07:44,319
passes a transformation

205
00:07:42,240 --> 00:07:46,639
as i mentioned it prints out a dump file

206
00:07:44,319 --> 00:07:49,919
for each of these passes

207
00:07:46,639 --> 00:07:52,960
i find myself um

208
00:07:49,919 --> 00:07:55,520
wanting to if i look through these

209
00:07:52,960 --> 00:07:56,719
dump files i can sometimes find oh

210
00:07:55,520 --> 00:07:58,878
that's the past that

211
00:07:56,720 --> 00:08:00,960
introduces the behavior i'm interested

212
00:07:58,879 --> 00:08:02,560
in and then i just need to put a break

213
00:08:00,960 --> 00:08:03,039
point on the function implementing that

214
00:08:02,560 --> 00:08:06,160
pass

215
00:08:03,039 --> 00:08:06,159
so i can start debugging

216
00:08:07,120 --> 00:08:13,280
since uh gcc

217
00:08:10,639 --> 00:08:15,599
has a data structure containing each of

218
00:08:13,280 --> 00:08:19,119
the transformations

219
00:08:15,599 --> 00:08:21,120
rather than go to the source and like

220
00:08:19,120 --> 00:08:22,720
look through how things are defined and

221
00:08:21,120 --> 00:08:24,479
where the method implementing what i'm

222
00:08:22,720 --> 00:08:27,599
interested is

223
00:08:24,479 --> 00:08:31,440
i can using this plug-in

224
00:08:27,599 --> 00:08:35,439
iterate over each

225
00:08:31,440 --> 00:08:38,640
each defined transformation in the list

226
00:08:35,440 --> 00:08:41,760
filter so i'll ignore this one but

227
00:08:38,640 --> 00:08:43,439
filter based on the name

228
00:08:41,760 --> 00:08:46,160
that this transformation has which

229
00:08:43,440 --> 00:08:48,320
correlates to that dump file

230
00:08:46,160 --> 00:08:49,680
extract the execute method of that

231
00:08:48,320 --> 00:08:52,959
transformation

232
00:08:49,680 --> 00:08:55,519
and then put a breakpoint on it i could

233
00:08:52,959 --> 00:08:56,719
also if i have many passes that i'm

234
00:08:55,519 --> 00:08:58,959
interested in

235
00:08:56,720 --> 00:09:00,320
uh put a break point on each one in turn

236
00:08:58,959 --> 00:09:04,800
with this single

237
00:09:00,320 --> 00:09:04,800
uh with this single command

238
00:09:06,000 --> 00:09:13,040
so now i'm just going to use give

239
00:09:09,600 --> 00:09:15,120
one more real world example from my

240
00:09:13,040 --> 00:09:18,079
co-workers side project

241
00:09:15,120 --> 00:09:20,839
he has a rtos and he's used this plugin

242
00:09:18,080 --> 00:09:23,839
to inspect his running state

243
00:09:20,839 --> 00:09:27,040
here uh he's iterated

244
00:09:23,839 --> 00:09:28,800
over a an array which contains

245
00:09:27,040 --> 00:09:30,880
data structures describing each of the

246
00:09:28,800 --> 00:09:34,319
allocations this artos has

247
00:09:30,880 --> 00:09:38,399
has performed and then he simply

248
00:09:34,320 --> 00:09:41,680
for each one of those increments some

249
00:09:38,399 --> 00:09:45,040
gdb uh convenience variable

250
00:09:41,680 --> 00:09:45,680
by the number of blocks uh allocated for

251
00:09:45,040 --> 00:09:48,959
that

252
00:09:45,680 --> 00:09:51,439
allocation resulting in the total

253
00:09:48,959 --> 00:09:52,959
number of allocations which number of

254
00:09:51,440 --> 00:09:55,839
blocks allocated

255
00:09:52,959 --> 00:09:57,439
with from which he can convert to bytes

256
00:09:55,839 --> 00:09:59,680
i especially like this

257
00:09:57,440 --> 00:10:02,160
example as it demonstrates these are

258
00:09:59,680 --> 00:10:03,839
just convenience for loops

259
00:10:02,160 --> 00:10:05,760
like iterating over whatever you want to

260
00:10:03,839 --> 00:10:09,120
iterate over and you can do

261
00:10:05,760 --> 00:10:11,360
any external uh calculations you feel

262
00:10:09,120 --> 00:10:11,360
like

263
00:10:11,680 --> 00:10:15,120
that's the just that's the gist of the

264
00:10:14,480 --> 00:10:16,959
plugin

265
00:10:15,120 --> 00:10:19,519
so you iterate over all elements in

266
00:10:16,959 --> 00:10:21,518
something perform some mapping

267
00:10:19,519 --> 00:10:23,040
or some filtering or some action on each

268
00:10:21,519 --> 00:10:25,519
one in turn before

269
00:10:23,040 --> 00:10:28,000
passing on the list of elements to the

270
00:10:25,519 --> 00:10:31,600
next rest of the pipeline

271
00:10:28,000 --> 00:10:33,200
so you can usually find a way to debug

272
00:10:31,600 --> 00:10:36,079
whatever you're interested in

273
00:10:33,200 --> 00:10:38,000
using the general walkers most often

274
00:10:36,079 --> 00:10:39,920
with this follow until walker

275
00:10:38,000 --> 00:10:42,880
which is essentially a for loop with a

276
00:10:39,920 --> 00:10:45,279
start increment and test expression

277
00:10:42,880 --> 00:10:46,880
i've put a lot of work into ensuring you

278
00:10:45,279 --> 00:10:48,640
can write

279
00:10:46,880 --> 00:10:51,200
walkers for your own data structures

280
00:10:48,640 --> 00:10:51,199
pretty easily

281
00:10:52,160 --> 00:10:55,279
to demonstrate this i'll start with

282
00:10:54,000 --> 00:10:58,800
another uh

283
00:10:55,279 --> 00:11:01,439
program from this extensions test suite

284
00:10:58,800 --> 00:11:02,319
here we have again a very simple node

285
00:11:01,440 --> 00:11:05,920
but instead of

286
00:11:02,320 --> 00:11:08,480
one pointer to the next uh next node

287
00:11:05,920 --> 00:11:10,640
we have two two children to create a

288
00:11:08,480 --> 00:11:13,360
nice simple tree

289
00:11:10,640 --> 00:11:14,079
if i start this program run until a

290
00:11:13,360 --> 00:11:16,959
known point

291
00:11:14,079 --> 00:11:18,880
where the root of this tree is in tree

292
00:11:16,959 --> 00:11:22,560
root

293
00:11:18,880 --> 00:11:23,200
and then import a file defining this

294
00:11:22,560 --> 00:11:25,920
walker

295
00:11:23,200 --> 00:11:27,600
a walker for that specific data type

296
00:11:25,920 --> 00:11:28,319
ignore the method of python import here

297
00:11:27,600 --> 00:11:31,120
this is just

298
00:11:28,320 --> 00:11:32,480
because it's not one of the special like

299
00:11:31,120 --> 00:11:34,720
automatically loaded ones it's a

300
00:11:32,480 --> 00:11:37,360
demonstration

301
00:11:34,720 --> 00:11:38,720
so i can now see that there's a new tag

302
00:11:37,360 --> 00:11:41,440
named treedemo

303
00:11:38,720 --> 00:11:42,000
at the bottom of that list under that

304
00:11:41,440 --> 00:11:44,160
tag

305
00:11:42,000 --> 00:11:46,160
there's a walker named tree elements

306
00:11:44,160 --> 00:11:49,279
which claims it can iterate over all

307
00:11:46,160 --> 00:11:49,279
nodes in that tree

308
00:11:49,600 --> 00:11:54,639
and just to demonstrate its use we can

309
00:11:51,920 --> 00:11:57,199
print out the data on each node

310
00:11:54,639 --> 00:11:59,200
or with a simple if condition print out

311
00:11:57,200 --> 00:12:01,680
the data on all of the leaf nodes of

312
00:11:59,200 --> 00:12:01,680
that tree

313
00:12:01,920 --> 00:12:08,079
so this is a pretty nice walker to

314
00:12:04,320 --> 00:12:11,120
demonstrate how one would write your own

315
00:12:08,079 --> 00:12:12,239
at a bare minimum you'll need to define

316
00:12:11,120 --> 00:12:13,920
a class

317
00:12:12,240 --> 00:12:15,680
uh inheriting from the walkers dot

318
00:12:13,920 --> 00:12:18,079
walker class

319
00:12:15,680 --> 00:12:20,239
this string is the help text that you

320
00:12:18,079 --> 00:12:23,279
saw printed out from walker

321
00:12:20,240 --> 00:12:26,079
help i'll just remove that for

322
00:12:23,279 --> 00:12:26,880
making things clearer we have the name

323
00:12:26,079 --> 00:12:30,560
that you use

324
00:12:26,880 --> 00:12:33,360
on the command line and the categories

325
00:12:30,560 --> 00:12:33,680
that these things are stored under and

326
00:12:33,360 --> 00:12:36,480
and

327
00:12:33,680 --> 00:12:38,319
tags you can as indicated by that list

328
00:12:36,480 --> 00:12:39,040
syntax have multiple categories that

329
00:12:38,320 --> 00:12:42,160
each

330
00:12:39,040 --> 00:12:44,719
walker can be put under and you'll need

331
00:12:42,160 --> 00:12:49,439
to implement three methods

332
00:12:44,720 --> 00:12:49,440
init from user string and it to death

333
00:12:49,680 --> 00:12:55,279
at the creation of a pipeline your class

334
00:12:52,800 --> 00:12:58,240
is to be instantiated then

335
00:12:55,279 --> 00:12:59,040
if the user types the name of your

336
00:12:58,240 --> 00:13:01,040
walker

337
00:12:59,040 --> 00:13:02,880
on the command line then your class will

338
00:13:01,040 --> 00:13:06,240
be instantiated using the from

339
00:13:02,880 --> 00:13:08,160
user string method this method takes

340
00:13:06,240 --> 00:13:10,399
a string which is the entire argument

341
00:13:08,160 --> 00:13:12,319
set that the user gave your walker

342
00:13:10,399 --> 00:13:14,000
and two booleans indicating whether this

343
00:13:12,320 --> 00:13:15,839
is the first walker in the pipeline or

344
00:13:14,000 --> 00:13:18,000
the last

345
00:13:15,839 --> 00:13:20,320
the init method is there to provide a

346
00:13:18,000 --> 00:13:23,680
nice programmatic interface for anyone

347
00:13:20,320 --> 00:13:26,560
that wants to build upon your walker

348
00:13:23,680 --> 00:13:26,959
sometime after instantiation your class

349
00:13:26,560 --> 00:13:29,518
will

350
00:13:26,959 --> 00:13:30,479
have it's it's a death method called

351
00:13:29,519 --> 00:13:33,440
this method

352
00:13:30,480 --> 00:13:34,000
takes an iterable over all the pointers

353
00:13:33,440 --> 00:13:36,720
that are coming

354
00:13:34,000 --> 00:13:38,639
into it from the pipeline and is to

355
00:13:36,720 --> 00:13:40,639
return an iterable over all the pointers

356
00:13:38,639 --> 00:13:43,199
that pass out

357
00:13:40,639 --> 00:13:44,399
each of these values is a gdp value

358
00:13:43,199 --> 00:13:47,760
representing an address

359
00:13:44,399 --> 00:13:48,079
or a pointer to something you're free to

360
00:13:47,760 --> 00:13:51,199
do

361
00:13:48,079 --> 00:13:54,479
pretty much whatever you want otherwise

362
00:13:51,199 --> 00:13:57,839
so once you've written

363
00:13:54,480 --> 00:14:00,560
uh your pipeline uh your walker sorry

364
00:13:57,839 --> 00:14:01,600
you're usually wanted around when uh

365
00:14:00,560 --> 00:14:03,839
debugging

366
00:14:01,600 --> 00:14:05,600
the binary you wrote it for but not

367
00:14:03,839 --> 00:14:08,240
around otherwise

368
00:14:05,600 --> 00:14:09,920
not uh cluttering at the help text for

369
00:14:08,240 --> 00:14:12,000
this method we haven't uh for this

370
00:14:09,920 --> 00:14:14,800
reason we have an auto import mechanism

371
00:14:12,000 --> 00:14:18,000
which is similar to the gdb one and i

372
00:14:14,800 --> 00:14:21,120
believe you could use the gdb1

373
00:14:18,000 --> 00:14:23,760
uh if if you want but

374
00:14:21,120 --> 00:14:25,120
well frankly i can't it's not well known

375
00:14:23,760 --> 00:14:28,319
enough to get these

376
00:14:25,120 --> 00:14:28,720
walkers into the main projects so i have

377
00:14:28,320 --> 00:14:33,279
a

378
00:14:28,720 --> 00:14:36,320
separate reason uh here we can see

379
00:14:33,279 --> 00:14:36,320
the cc one

380
00:14:37,279 --> 00:14:41,600
walkers that were the ones defining that

381
00:14:39,279 --> 00:14:45,120
gcc plug-in before

382
00:14:41,600 --> 00:14:47,839
so in order to use this mechanism

383
00:14:45,120 --> 00:14:49,680
if you want to if you've written walkers

384
00:14:47,839 --> 00:14:53,360
in a python file

385
00:14:49,680 --> 00:14:55,519
for the binary named mybinary you should

386
00:14:53,360 --> 00:14:58,320
name save that python file under the

387
00:14:55,519 --> 00:15:00,320
name mybinary.gdb.pi

388
00:14:58,320 --> 00:15:02,880
and put it in this plug-ins auto-import

389
00:15:00,320 --> 00:15:02,880
directory

390
00:15:04,000 --> 00:15:07,920
now if all that seems like a lot of work

391
00:15:06,399 --> 00:15:10,079
i have good news

392
00:15:07,920 --> 00:15:11,839
you may have already written the python

393
00:15:10,079 --> 00:15:13,359
code to use this plug-in on your data

394
00:15:11,839 --> 00:15:15,920
structures

395
00:15:13,360 --> 00:15:17,839
that's because this plug-in uh leverages

396
00:15:15,920 --> 00:15:19,199
the much more established gdb pretty

397
00:15:17,839 --> 00:15:21,199
printer api

398
00:15:19,199 --> 00:15:22,240
in order to iterate over data structures

399
00:15:21,199 --> 00:15:23,719
that have

400
00:15:22,240 --> 00:15:26,800
the optional method

401
00:15:23,720 --> 00:15:30,399
prettyprinter.children defined

402
00:15:26,800 --> 00:15:33,758
this method takes um well it's

403
00:15:30,399 --> 00:15:36,320
it's defined to re iterate over the

404
00:15:33,759 --> 00:15:38,320
children of some data structure for

405
00:15:36,320 --> 00:15:39,199
containers is usually implemented to

406
00:15:38,320 --> 00:15:40,800
iterate over

407
00:15:39,199 --> 00:15:43,279
all the objects that are stored in that

408
00:15:40,800 --> 00:15:43,279
container

409
00:15:43,680 --> 00:15:48,399
is defined to return an iterable over

410
00:15:46,639 --> 00:15:50,320
gdb values

411
00:15:48,399 --> 00:15:53,519
or something that can return can be

412
00:15:50,320 --> 00:15:56,560
converted into a gdp value

413
00:15:53,519 --> 00:16:00,399
this is slightly different to

414
00:15:56,560 --> 00:16:03,680
the addresses that i pass through but

415
00:16:00,399 --> 00:16:07,360
we can do a conversion if

416
00:16:03,680 --> 00:16:10,160
things satisfy certain criteria

417
00:16:07,360 --> 00:16:11,600
so the walker to iterate over these

418
00:16:10,160 --> 00:16:14,719
pretty printer objects

419
00:16:11,600 --> 00:16:17,759
is the pretty printer walker this

420
00:16:14,720 --> 00:16:18,160
when you give it a um object say example

421
00:16:17,759 --> 00:16:21,519
run

422
00:16:18,160 --> 00:16:22,880
container here it will take that object

423
00:16:21,519 --> 00:16:25,040
look up the pretty printer that's

424
00:16:22,880 --> 00:16:27,439
supposed to print it

425
00:16:25,040 --> 00:16:29,360
and then find the dot children method

426
00:16:27,440 --> 00:16:32,399
iterate over all the values

427
00:16:29,360 --> 00:16:34,959
and convert them into addresses

428
00:16:32,399 --> 00:16:35,519
i'll take the address member of that gdb

429
00:16:34,959 --> 00:16:38,959
value

430
00:16:35,519 --> 00:16:38,959
and push those down the pipeline

431
00:16:39,680 --> 00:16:43,680
there the extra restrictions on this gdb

432
00:16:42,560 --> 00:16:45,680
children

433
00:16:43,680 --> 00:16:47,599
method that is not in the g in the

434
00:16:45,680 --> 00:16:51,439
pretty printer api

435
00:16:47,600 --> 00:16:55,600
is that you return a oh an iterator

436
00:16:51,440 --> 00:16:59,440
that has elements which are um

437
00:16:55,600 --> 00:17:01,759
values with the correct address so

438
00:16:59,440 --> 00:17:04,560
you so for example a pretty printer that

439
00:17:01,759 --> 00:17:04,560
iterates over

440
00:17:04,640 --> 00:17:09,839
one zero one zero which is a case in a

441
00:17:07,839 --> 00:17:12,958
qt bitmap 3d printer i saw

442
00:17:09,839 --> 00:17:16,839
can't work directly with this but

443
00:17:12,959 --> 00:17:19,839
it seems the lipstick c plus plus 3d

444
00:17:16,839 --> 00:17:23,039
printers all satisfy this requirement

445
00:17:19,839 --> 00:17:25,599
which means we have stood vector

446
00:17:23,039 --> 00:17:27,439
stood map and a bunch of others already

447
00:17:25,599 --> 00:17:29,840
defined for us

448
00:17:27,439 --> 00:17:33,840
hopefully your pretty printer also

449
00:17:29,840 --> 00:17:33,840
satisfies these requirements

450
00:17:34,320 --> 00:17:39,760
so just gonna end on something

451
00:17:37,840 --> 00:17:41,039
some future directions possible future

452
00:17:39,760 --> 00:17:43,120
directions

453
00:17:41,039 --> 00:17:44,879
the thing i'm most interested in is how

454
00:17:43,120 --> 00:17:49,120
many pretty printers in the wild

455
00:17:44,880 --> 00:17:51,440
satisfy these requirements um

456
00:17:49,120 --> 00:17:52,399
all behaviors you want may expect so

457
00:17:51,440 --> 00:17:55,679
there's two

458
00:17:52,400 --> 00:18:00,000
sort of difference um points here

459
00:17:55,679 --> 00:18:02,080
one is how many sort of work nicely

460
00:18:00,000 --> 00:18:04,000
as an example that doesn't uh of

461
00:18:02,080 --> 00:18:07,199
something that works but does not work

462
00:18:04,000 --> 00:18:10,480
quite nicely the stud map 3d printer

463
00:18:07,200 --> 00:18:12,240
iterates over alternating key and values

464
00:18:10,480 --> 00:18:13,760
whereas what you might expect using this

465
00:18:12,240 --> 00:18:16,480
plugin is

466
00:18:13,760 --> 00:18:18,000
iterating over the pairs there's not

467
00:18:16,480 --> 00:18:19,919
much i can do

468
00:18:18,000 --> 00:18:21,440
about this other than making sure that

469
00:18:19,919 --> 00:18:22,720
writers are pretty printers know this

470
00:18:21,440 --> 00:18:24,559
plug-in exists

471
00:18:22,720 --> 00:18:26,320
uh know what the requirements are and

472
00:18:24,559 --> 00:18:28,879
hopefully believe it's useful enough to

473
00:18:26,320 --> 00:18:32,480
modify their pretty printer to work

474
00:18:28,880 --> 00:18:34,960
which is why i'm here but

475
00:18:32,480 --> 00:18:36,080
for the stood map walker in particular i

476
00:18:34,960 --> 00:18:37,840
have

477
00:18:36,080 --> 00:18:39,120
written a wrapper that iterates over

478
00:18:37,840 --> 00:18:40,720
pairs

479
00:18:39,120 --> 00:18:42,879
but i can't do that for every pretty

480
00:18:40,720 --> 00:18:46,240
printer out there

481
00:18:42,880 --> 00:18:49,520
the second question is

482
00:18:46,240 --> 00:18:51,039
how many uh iterate over gdb values that

483
00:18:49,520 --> 00:18:53,280
have the correct address assigned to

484
00:18:51,039 --> 00:18:53,280
them

485
00:18:53,679 --> 00:18:59,440
i you can use the pretty printers that

486
00:18:57,360 --> 00:19:02,080
don't have the correct address

487
00:18:59,440 --> 00:19:05,280
so to do that you'd pass an extra

488
00:19:02,080 --> 00:19:08,000
argument to the pretty printer walker

489
00:19:05,280 --> 00:19:08,960
but as soon as you do this if they had

490
00:19:08,000 --> 00:19:11,280
an address

491
00:19:08,960 --> 00:19:12,720
assigned for previously you lose the

492
00:19:11,280 --> 00:19:15,760
ability to assign

493
00:19:12,720 --> 00:19:18,400
into the memory because the

494
00:19:15,760 --> 00:19:21,120
the action of putting something into a

495
00:19:18,400 --> 00:19:23,440
convenience variable loses this ability

496
00:19:21,120 --> 00:19:24,639
like he loses where it the value

497
00:19:23,440 --> 00:19:28,640
originally was

498
00:19:24,640 --> 00:19:28,640
as in a reference to memory

499
00:19:28,880 --> 00:19:36,640
and and so for example the qt bitmap

500
00:19:32,880 --> 00:19:38,640
thing i was mentioning before you could

501
00:19:36,640 --> 00:19:40,799
iterate over the ones and zeros but

502
00:19:38,640 --> 00:19:43,360
you'd have to convert into something

503
00:19:40,799 --> 00:19:44,240
a bit more useful later or you could

504
00:19:43,360 --> 00:19:48,080
just

505
00:19:44,240 --> 00:19:48,080
modify the entire of your pipeline

506
00:19:48,559 --> 00:19:52,559
apparently i've got 10 minutes left

507
00:19:49,919 --> 00:19:54,320
that's way more than i expected

508
00:19:52,559 --> 00:19:56,160
yeah you could modify the rest of your

509
00:19:54,320 --> 00:19:58,639
pipeline to uh

510
00:19:56,160 --> 00:20:00,559
handle values instead of addresses and

511
00:19:58,640 --> 00:20:03,120
just not be able to assign anything in

512
00:20:00,559 --> 00:20:06,559
the inferior

513
00:20:03,120 --> 00:20:10,080
i have thought about using values

514
00:20:06,559 --> 00:20:13,760
everywhere instead of these addresses um

515
00:20:10,080 --> 00:20:16,480
but because of this difficulty in

516
00:20:13,760 --> 00:20:18,480
creating a template and and putting

517
00:20:16,480 --> 00:20:20,559
something into there without losing the

518
00:20:18,480 --> 00:20:23,039
information of where this

519
00:20:20,559 --> 00:20:24,879
is in memory i've not been able to do

520
00:20:23,039 --> 00:20:28,080
anything there

521
00:20:24,880 --> 00:20:29,840
um but yeah if anybody knows a better

522
00:20:28,080 --> 00:20:31,600
way of assignment with rather than this

523
00:20:29,840 --> 00:20:33,280
convenience variable

524
00:20:31,600 --> 00:20:34,639
then i'd love to hear about it but other

525
00:20:33,280 --> 00:20:37,760
than that

526
00:20:34,640 --> 00:20:38,640
i apparently finished very early there's

527
00:20:37,760 --> 00:20:42,480
the github

528
00:20:38,640 --> 00:20:49,840
where this plugin is installed and

529
00:20:42,480 --> 00:20:49,840
i'll take a few questions

530
00:20:57,039 --> 00:21:00,879
so what happens if you have a bug in

531
00:20:59,840 --> 00:21:02,320
your code

532
00:21:00,880 --> 00:21:04,640
and because that's why you use a

533
00:21:02,320 --> 00:21:06,240
debugger and your linked list doesn't

534
00:21:04,640 --> 00:21:09,919
match up correctly

535
00:21:06,240 --> 00:21:12,400
and for example yeah yeah

536
00:21:09,919 --> 00:21:13,520
well um so you notice there's an endless

537
00:21:12,400 --> 00:21:16,559
loop press control c

538
00:21:13,520 --> 00:21:18,400
and then pipe to head oh sorry what what

539
00:21:16,559 --> 00:21:19,039
happens if you have an infinite loop or

540
00:21:18,400 --> 00:21:21,919
something

541
00:21:19,039 --> 00:21:23,120
um i've hit this a few times um

542
00:21:21,919 --> 00:21:26,240
generally what happens

543
00:21:23,120 --> 00:21:29,520
is i get panicked press ctrl c

544
00:21:26,240 --> 00:21:32,159
and then pipe to head um so

545
00:21:29,520 --> 00:21:34,559
hopefully like i can basically go oh

546
00:21:32,159 --> 00:21:38,960
there's the point where it repeats

547
00:21:34,559 --> 00:21:42,879
um i could also i'm sure you can

548
00:21:38,960 --> 00:21:45,840
like there is a unique thing in there

549
00:21:42,880 --> 00:21:45,840
um which could

550
00:21:45,919 --> 00:21:49,039
uh which could be used to sort of filter

551
00:21:48,480 --> 00:21:51,360
out

552
00:21:49,039 --> 00:21:52,240
to or or you could write your own walker

553
00:21:51,360 --> 00:21:54,959
that would

554
00:21:52,240 --> 00:21:55,679
find where the start repeats again and

555
00:21:54,960 --> 00:21:58,480
something like that

556
00:21:55,679 --> 00:22:00,080
but yes it does it does mess up your

557
00:21:58,480 --> 00:22:02,320
you're right

558
00:22:00,080 --> 00:22:04,240
it's it's typical in gdb that has some

559
00:22:02,320 --> 00:22:07,280
kind of limit

560
00:22:04,240 --> 00:22:08,960
so that you don't run into these

561
00:22:07,280 --> 00:22:10,840
infinite loop cases so you could add

562
00:22:08,960 --> 00:22:13,760
some option

563
00:22:10,840 --> 00:22:16,959
like hit rate at will yes you go

564
00:22:13,760 --> 00:22:18,720
over 500 okay yeah so um

565
00:22:16,960 --> 00:22:20,960
just a comment from the person in the

566
00:22:18,720 --> 00:22:21,840
front uh it's typical in gdb there's a

567
00:22:20,960 --> 00:22:24,960
limit

568
00:22:21,840 --> 00:22:28,158
uh and suggesting that we set some

569
00:22:24,960 --> 00:22:32,159
option to say limit at however many

570
00:22:28,159 --> 00:22:32,159
like a few million something like that

571
00:22:32,880 --> 00:22:39,200
so you might have missed this but um in

572
00:22:37,919 --> 00:22:40,640
essence what you're doing is you're

573
00:22:39,200 --> 00:22:42,320
iterating over the elements of

574
00:22:40,640 --> 00:22:44,320
collections

575
00:22:42,320 --> 00:22:45,439
and if i if i understood you're right

576
00:22:44,320 --> 00:22:47,120
there needs to be a

577
00:22:45,440 --> 00:22:49,200
printer for a data structure that

578
00:22:47,120 --> 00:22:51,918
returns some sort of integrator

579
00:22:49,200 --> 00:22:52,240
but could you turn it around and say you

580
00:22:51,919 --> 00:22:55,520
know

581
00:22:52,240 --> 00:22:56,400
just create an object with um object dot

582
00:22:55,520 --> 00:22:58,000
begin

583
00:22:56,400 --> 00:22:59,440
think about a sequence that's right

584
00:22:58,000 --> 00:23:03,919
before it looks right

585
00:22:59,440 --> 00:23:06,320
um object dot begin until object was in

586
00:23:03,919 --> 00:23:07,280
and then in between always called plus

587
00:23:06,320 --> 00:23:10,399
plus

588
00:23:07,280 --> 00:23:12,559
um and so this gives you the sequence of

589
00:23:10,400 --> 00:23:15,840
objects that it individually

590
00:23:12,559 --> 00:23:20,080
can predict would that work

591
00:23:15,840 --> 00:23:20,080
so because that would make it much more

592
00:23:20,840 --> 00:23:26,320
convenient

593
00:23:22,080 --> 00:23:28,720
yeah so the the question is basically

594
00:23:26,320 --> 00:23:29,678
instead in c plus there's often

595
00:23:28,720 --> 00:23:33,200
iterators

596
00:23:29,679 --> 00:23:35,520
so you have a dot begin and a dot end um

597
00:23:33,200 --> 00:23:37,440
and is there any way that you can

598
00:23:35,520 --> 00:23:40,960
automatically use these

599
00:23:37,440 --> 00:23:41,679
uh functions and to to define some

600
00:23:40,960 --> 00:23:44,799
iterable

601
00:23:41,679 --> 00:23:47,360
in gdb um

602
00:23:44,799 --> 00:23:48,720
i basically i've tried to use these

603
00:23:47,360 --> 00:23:52,559
iterators directly

604
00:23:48,720 --> 00:23:54,320
with in in gdb a few times and

605
00:23:52,559 --> 00:23:56,639
i always hit some problem and i don't

606
00:23:54,320 --> 00:23:57,840
know why i i'm guessing there's

607
00:23:56,640 --> 00:24:01,360
something to do with

608
00:23:57,840 --> 00:24:04,480
uh in lining or whatever but there's

609
00:24:01,360 --> 00:24:08,639
there's always some problem i hit um

610
00:24:04,480 --> 00:24:08,640
yeah so i resorted to this

611
00:24:24,080 --> 00:24:27,199
yeah so the question there is i've

612
00:24:26,159 --> 00:24:29,840
always demonstrated

613
00:24:27,200 --> 00:24:31,039
using uh these this plugin using uh

614
00:24:29,840 --> 00:24:33,918
debug information

615
00:24:31,039 --> 00:24:36,400
but is it possible to use uh things just

616
00:24:33,919 --> 00:24:39,520
directly with registers etc

617
00:24:36,400 --> 00:24:40,480
um so yes you can it just makes things a

618
00:24:39,520 --> 00:24:42,480
lot more awkward

619
00:24:40,480 --> 00:24:44,400
as as debugging without debug

620
00:24:42,480 --> 00:24:46,559
information yet does

621
00:24:44,400 --> 00:24:48,320
the follow until walker literally just

622
00:24:46,559 --> 00:24:51,120
takes the gdb expression

623
00:24:48,320 --> 00:24:53,279
um so you can if you know the exact

624
00:24:51,120 --> 00:25:00,559
point of math you want to perform

625
00:24:53,279 --> 00:25:04,480
you can just type that in yeah

626
00:25:00,559 --> 00:25:15,840
uh that that looks about it

627
00:25:04,480 --> 00:25:15,840
okay cool

628
00:25:27,360 --> 00:25:30,799
oh that's a live yeah there's a random

629
00:25:29,760 --> 00:25:33,760
vim um

630
00:25:30,799 --> 00:25:34,400
plugin i wrote oh okay um quite nice

631
00:25:33,760 --> 00:25:36,400
thank you to

632
00:25:34,400 --> 00:25:37,679
this uh just kind of interactive

633
00:25:36,400 --> 00:25:41,279
demonstration yeah the

634
00:25:37,679 --> 00:25:42,000
actual the pointer the point of the

635
00:25:41,279 --> 00:25:44,880
plug-in is more

636
00:25:42,000 --> 00:25:45,360
just to help myself debug stuff because

637
00:25:44,880 --> 00:25:48,000
i can

638
00:25:45,360 --> 00:25:49,120
like whenever i'm like i write a command

639
00:25:48,000 --> 00:25:50,000
and then i'm like oh that wasn't what i

640
00:25:49,120 --> 00:25:53,600
want and i go back

641
00:25:50,000 --> 00:25:57,360
yeah but yeah it's um same

642
00:25:53,600 --> 00:26:07,039
uh github username but vsh

643
00:25:57,360 --> 00:26:07,039
yeah thank you yeah

