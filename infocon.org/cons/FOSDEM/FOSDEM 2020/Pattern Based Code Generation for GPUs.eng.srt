1
00:00:07,200 --> 00:00:10,880
so

2
00:00:07,839 --> 00:00:12,160
in the autumn of uh 2008 i started

3
00:00:10,880 --> 00:00:14,719
implementing

4
00:00:12,160 --> 00:00:15,360
mesa's glsl compiler completely from

5
00:00:14,719 --> 00:00:18,640
scratch

6
00:00:15,360 --> 00:00:19,840
we had a glsl compiler but for a whole

7
00:00:18,640 --> 00:00:21,520
bunch of reasons that

8
00:00:19,840 --> 00:00:23,519
i think i've talked about in other talks

9
00:00:21,520 --> 00:00:26,320
at other conferences

10
00:00:23,519 --> 00:00:28,320
it had to go so i did i'd never written

11
00:00:26,320 --> 00:00:29,039
a compiler before i'd taken a compiler's

12
00:00:28,320 --> 00:00:31,279
class at

13
00:00:29,039 --> 00:00:32,960
university but that was it so i did a

14
00:00:31,279 --> 00:00:34,079
couple of months of research and i

15
00:00:32,960 --> 00:00:37,760
started on the project

16
00:00:34,079 --> 00:00:40,879
armed with uh with two books one was

17
00:00:37,760 --> 00:00:42,839
uh steven munchnick's seminal work

18
00:00:40,879 --> 00:00:44,000
uh advanced compiler design and

19
00:00:42,840 --> 00:00:46,320
implementation

20
00:00:44,000 --> 00:00:48,079
now even when i started this project

21
00:00:46,320 --> 00:00:50,239
that book was already

22
00:00:48,079 --> 00:00:51,600
around 10 years old and it was starting

23
00:00:50,239 --> 00:00:54,959
to feel a little bit dated

24
00:00:51,600 --> 00:00:56,480
it had a very small section about ssa as

25
00:00:54,960 --> 00:00:59,760
this is this new thing that people are

26
00:00:56,480 --> 00:01:04,479
starting to play around with

27
00:00:59,760 --> 00:01:07,679
but everything else that was in it was

28
00:01:04,479 --> 00:01:08,320
really detailed explanations of battle

29
00:01:07,680 --> 00:01:10,799
tested

30
00:01:08,320 --> 00:01:12,240
algorithms and all of the algorithms and

31
00:01:10,799 --> 00:01:14,320
data structures in it

32
00:01:12,240 --> 00:01:16,240
were related back to actual production

33
00:01:14,320 --> 00:01:17,520
compilers that people were shipping and

34
00:01:16,240 --> 00:01:19,759
the

35
00:01:17,520 --> 00:01:21,039
problems that people had with them and

36
00:01:19,759 --> 00:01:22,400
things that they had to do to actually

37
00:01:21,040 --> 00:01:26,320
make stuff work so it was

38
00:01:22,400 --> 00:01:28,479
really really solid practical advice

39
00:01:26,320 --> 00:01:30,479
and in fact there's a jit project

40
00:01:28,479 --> 00:01:33,600
started by some folks at red hat

41
00:01:30,479 --> 00:01:37,200
that's using the uh mid

42
00:01:33,600 --> 00:01:39,520
middle um ir from that book

43
00:01:37,200 --> 00:01:41,040
as its basis so people are are still

44
00:01:39,520 --> 00:01:44,320
using this it's still a great

45
00:01:41,040 --> 00:01:47,439
resource the other book that

46
00:01:44,320 --> 00:01:49,839
uh that i had in the other hand uh was a

47
00:01:47,439 --> 00:01:53,360
retargetable c compiler

48
00:01:49,840 --> 00:01:55,680
so the draw of this book this book is uh

49
00:01:53,360 --> 00:01:57,200
by a couple of university researchers

50
00:01:55,680 --> 00:02:00,880
that's primarily about the

51
00:01:57,200 --> 00:02:04,560
lcc compiler uh the draw of this book

52
00:02:00,880 --> 00:02:05,839
was elberg which was a cogenerator

53
00:02:04,560 --> 00:02:10,399
generator system

54
00:02:05,840 --> 00:02:12,480
and burrs the bottom up rewrite system

55
00:02:10,399 --> 00:02:16,080
that they had to implement code

56
00:02:12,480 --> 00:02:16,079
generation in that compiler

57
00:02:16,239 --> 00:02:20,879
so lcc has this tool that that's part of

58
00:02:20,640 --> 00:02:24,000
it

59
00:02:20,879 --> 00:02:26,000
called elberg that basically implements

60
00:02:24,000 --> 00:02:29,520
a domain specific language

61
00:02:26,000 --> 00:02:30,640
for generating code generators where you

62
00:02:29,520 --> 00:02:32,879
have

63
00:02:30,640 --> 00:02:35,119
a set of statements where you have a

64
00:02:32,879 --> 00:02:38,640
pattern of ir

65
00:02:35,120 --> 00:02:39,280
to match a blob of something that looks

66
00:02:38,640 --> 00:02:42,079
a bit like

67
00:02:39,280 --> 00:02:44,000
assembly code to generate and then an

68
00:02:42,080 --> 00:02:44,959
estimate of how much that blob of

69
00:02:44,000 --> 00:02:46,490
assembly

70
00:02:44,959 --> 00:02:49,440
costs

71
00:02:46,490 --> 00:02:52,160
[Music]

72
00:02:49,440 --> 00:02:54,400
this this set of code is then compiled

73
00:02:52,160 --> 00:02:56,879
down into some data and code

74
00:02:54,400 --> 00:02:57,840
that gets built into the compiler and

75
00:02:56,879 --> 00:03:00,239
used by

76
00:02:57,840 --> 00:03:01,840
the burs the the bottom up bottom up

77
00:03:00,239 --> 00:03:03,920
rewrite system to actually

78
00:03:01,840 --> 00:03:05,920
implement the code generator in the in

79
00:03:03,920 --> 00:03:09,679
the compiler

80
00:03:05,920 --> 00:03:12,799
so burs uses two passes

81
00:03:09,680 --> 00:03:15,680
to go over the ir trees

82
00:03:12,800 --> 00:03:16,319
it does a bottom-up pass where it looks

83
00:03:15,680 --> 00:03:18,800
at

84
00:03:16,319 --> 00:03:20,560
progressively larger and larger trees to

85
00:03:18,800 --> 00:03:22,879
kind of come up with

86
00:03:20,560 --> 00:03:23,599
what's what's the least cost way to

87
00:03:22,879 --> 00:03:25,840
implement

88
00:03:23,599 --> 00:03:27,679
this little bit and then kind of grow

89
00:03:25,840 --> 00:03:29,680
that up and it decorates

90
00:03:27,680 --> 00:03:31,200
the tree as it goes up and then it does

91
00:03:29,680 --> 00:03:35,200
a second pass going

92
00:03:31,200 --> 00:03:35,200
top down to actually emit the code

93
00:03:36,319 --> 00:03:44,000
so this has two orthogonal benefits

94
00:03:41,440 --> 00:03:44,480
one is that open coded pattern matching

95
00:03:44,000 --> 00:03:47,599
code

96
00:03:44,480 --> 00:03:51,040
is really really tedious to write and

97
00:03:47,599 --> 00:03:54,640
is super error prone uh

98
00:03:51,040 --> 00:03:58,239
so for example on later intel gpus

99
00:03:54,640 --> 00:04:00,238
we have a flag on the sources of logical

100
00:03:58,239 --> 00:04:02,560
operations that says

101
00:04:00,239 --> 00:04:03,680
take the bitwise inverse of this source

102
00:04:02,560 --> 00:04:06,480
so you can combine

103
00:04:03,680 --> 00:04:06,879
nots with your sources so we can use

104
00:04:06,480 --> 00:04:11,200
that

105
00:04:06,879 --> 00:04:14,879
say with if you see an ir pattern of

106
00:04:11,200 --> 00:04:17,120
not of a and b well you can just

107
00:04:14,879 --> 00:04:18,320
invert a and b and implement an or

108
00:04:17,120 --> 00:04:20,320
instruction instead

109
00:04:18,320 --> 00:04:22,639
so instead of emitting two instructions

110
00:04:20,320 --> 00:04:25,280
you can emit one

111
00:04:22,639 --> 00:04:26,080
to do that in the compiler hand coded

112
00:04:25,280 --> 00:04:29,119
you end up with

113
00:04:26,080 --> 00:04:30,560
this lovely eye chart uh so in order to

114
00:04:29,120 --> 00:04:34,639
fit

115
00:04:30,560 --> 00:04:36,720
this conceptually simple thing of uh

116
00:04:34,639 --> 00:04:38,639
the the code that actually implements it

117
00:04:36,720 --> 00:04:40,800
i'd use a six point font

118
00:04:38,639 --> 00:04:42,000
gut out all the comments and turn it

119
00:04:40,800 --> 00:04:44,639
into this this

120
00:04:42,000 --> 00:04:44,639
disaster

121
00:04:45,280 --> 00:04:49,440
so without the comments if you saw this

122
00:04:48,880 --> 00:04:51,759
code

123
00:04:49,440 --> 00:04:55,199
in the compiler code it's not even

124
00:04:51,759 --> 00:04:55,199
really obvious what it's doing

125
00:04:55,680 --> 00:05:01,919
so because of that we have very very few

126
00:05:00,000 --> 00:05:03,919
sort of clever bits of code generation

127
00:05:01,919 --> 00:05:07,359
like this in our compiler uh this

128
00:05:03,919 --> 00:05:09,440
i think when i implemented this uh

129
00:05:07,360 --> 00:05:11,440
it helped a few thousand shaders in our

130
00:05:09,440 --> 00:05:13,919
shader database by

131
00:05:11,440 --> 00:05:15,840
you know hundreds of instructions a

132
00:05:13,919 --> 00:05:18,400
percent or two in in them

133
00:05:15,840 --> 00:05:20,719
um so when you have things that are hard

134
00:05:18,400 --> 00:05:23,440
to implement and hard to maintain

135
00:05:20,720 --> 00:05:24,560
like they have to have a lot of of

136
00:05:23,440 --> 00:05:26,719
impact or it's just

137
00:05:24,560 --> 00:05:29,520
there's no return on on the investment

138
00:05:26,720 --> 00:05:32,160
so we don't have a lot of that

139
00:05:29,520 --> 00:05:32,159
but we could

140
00:05:33,520 --> 00:05:37,680
so the other thing that attracted us to

141
00:05:35,840 --> 00:05:38,719
having some sort of automatic code

142
00:05:37,680 --> 00:05:41,120
generation is

143
00:05:38,720 --> 00:05:42,400
this is being able to have the

144
00:05:41,120 --> 00:05:44,720
decorations of

145
00:05:42,400 --> 00:05:46,799
how much you think a particular

146
00:05:44,720 --> 00:05:50,240
instruction sequence is going to cost

147
00:05:46,800 --> 00:05:53,120
so that you can uh try to

148
00:05:50,240 --> 00:05:54,080
do more take a little bit more of a

149
00:05:53,120 --> 00:05:57,440
global view

150
00:05:54,080 --> 00:06:01,919
and do um an optimal

151
00:05:57,440 --> 00:06:05,120
uh code output uh

152
00:06:01,919 --> 00:06:08,318
so this is definitely orthogonal to the

153
00:06:05,120 --> 00:06:09,840
the first benefit uh and some other work

154
00:06:08,319 --> 00:06:12,639
has been done on this

155
00:06:09,840 --> 00:06:13,919
that doesn't use a generator a code

156
00:06:12,639 --> 00:06:17,280
generator generator

157
00:06:13,919 --> 00:06:17,840
uh eric anholt has i think one of the

158
00:06:17,280 --> 00:06:21,119
oldest

159
00:06:17,840 --> 00:06:22,080
still open mrs in mesa gitlab since we

160
00:06:21,120 --> 00:06:25,680
switched over to

161
00:06:22,080 --> 00:06:29,520
to get lab for a

162
00:06:25,680 --> 00:06:31,199
thing called noltus in

163
00:06:29,520 --> 00:06:34,400
the driver that he was working on that

164
00:06:31,199 --> 00:06:36,160
that tries to apply some of this so it's

165
00:06:34,400 --> 00:06:37,758
orthogonal but the two things play

166
00:06:36,160 --> 00:06:42,000
together really well

167
00:06:37,759 --> 00:06:44,000
because if you're going to do this

168
00:06:42,000 --> 00:06:46,080
this sort of global optimization it

169
00:06:44,000 --> 00:06:48,720
helps to have a lot of different

170
00:06:46,080 --> 00:06:49,120
patterns so that it can try to find

171
00:06:48,720 --> 00:06:52,000
different

172
00:06:49,120 --> 00:06:52,800
routes through how to through emitting a

173
00:06:52,000 --> 00:06:54,880
large

174
00:06:52,800 --> 00:06:56,000
uh expression tree if you have a bunch

175
00:06:54,880 --> 00:06:58,240
of different ways

176
00:06:56,000 --> 00:06:59,840
of implementing that it gives the

177
00:06:58,240 --> 00:07:03,440
optimizer more freedom to

178
00:06:59,840 --> 00:07:05,599
to pick better things

179
00:07:03,440 --> 00:07:05,599
so

180
00:07:07,199 --> 00:07:10,880
once we started digging into this years

181
00:07:09,919 --> 00:07:13,198
ago

182
00:07:10,880 --> 00:07:14,880
the dream quickly turned into a

183
00:07:13,199 --> 00:07:18,080
nightmare

184
00:07:14,880 --> 00:07:20,080
uh there were so many

185
00:07:18,080 --> 00:07:22,159
tech both practical and technical

186
00:07:20,080 --> 00:07:24,719
problems that we ran into

187
00:07:22,160 --> 00:07:26,479
the first big problem was we'd have to

188
00:07:24,720 --> 00:07:27,360
implement our own domain specific

189
00:07:26,479 --> 00:07:29,280
language

190
00:07:27,360 --> 00:07:31,120
to do the code generator generator we'd

191
00:07:29,280 --> 00:07:34,799
have in order to implement our compiler

192
00:07:31,120 --> 00:07:38,160
we had to implement another compiler uh

193
00:07:34,800 --> 00:07:42,240
and that was a huge problem uh

194
00:07:38,160 --> 00:07:44,639
in mesa because until very recently

195
00:07:42,240 --> 00:07:45,840
we didn't have a way to be able to build

196
00:07:44,639 --> 00:07:48,960
something during

197
00:07:45,840 --> 00:07:50,000
the mesa build that would run on your

198
00:07:48,960 --> 00:07:52,638
build system

199
00:07:50,000 --> 00:07:54,160
to generate other build dependencies uh

200
00:07:52,639 --> 00:07:56,319
just because of the way

201
00:07:54,160 --> 00:07:58,720
the disaster that was mesa's build

202
00:07:56,319 --> 00:08:01,039
system uh so it took

203
00:07:58,720 --> 00:08:02,400
you know almost 12 years before we could

204
00:08:01,039 --> 00:08:06,159
have even done

205
00:08:02,400 --> 00:08:07,520
this and that ended up being a problem

206
00:08:06,160 --> 00:08:10,560
for some other things

207
00:08:07,520 --> 00:08:12,560
like how we wanted to implement the

208
00:08:10,560 --> 00:08:13,199
shading language built-in functions but

209
00:08:12,560 --> 00:08:16,800
that's

210
00:08:13,199 --> 00:08:16,800
that's another story

211
00:08:18,560 --> 00:08:24,240
so it also turns out that

212
00:08:25,280 --> 00:08:31,359
source modifiers are a big deal on gpus

213
00:08:29,039 --> 00:08:32,640
it's we can almost for free be able to

214
00:08:31,360 --> 00:08:35,360
say

215
00:08:32,640 --> 00:08:37,519
that a source in an instruction should

216
00:08:35,360 --> 00:08:38,159
be negated or have its absolute value

217
00:08:37,519 --> 00:08:41,519
taken

218
00:08:38,159 --> 00:08:42,479
or both but that's not really a thing on

219
00:08:41,519 --> 00:08:46,000
cpus

220
00:08:42,479 --> 00:08:46,880
so none of the research or any of the

221
00:08:46,000 --> 00:08:50,000
published work

222
00:08:46,880 --> 00:08:51,600
about how to actually implement a

223
00:08:50,000 --> 00:08:54,640
generator generator

224
00:08:51,600 --> 00:08:56,000
even considers these things and it turns

225
00:08:54,640 --> 00:08:59,040
out they're kind of

226
00:08:56,000 --> 00:09:00,880
a huge hassle but

227
00:08:59,040 --> 00:09:02,160
it's super important for generating

228
00:09:00,880 --> 00:09:04,880
optimal code on

229
00:09:02,160 --> 00:09:04,880
gpus

230
00:09:06,399 --> 00:09:10,240
most of the time uh especially on the

231
00:09:09,360 --> 00:09:12,160
gpus that we

232
00:09:10,240 --> 00:09:13,920
we cared about when we started

233
00:09:12,160 --> 00:09:16,480
implementing this project

234
00:09:13,920 --> 00:09:17,760
things like negation are free but not

235
00:09:16,480 --> 00:09:20,800
always

236
00:09:17,760 --> 00:09:24,399
on i-965 gpus

237
00:09:20,800 --> 00:09:25,920
for example trig functions and some

238
00:09:24,399 --> 00:09:27,279
other complex math

239
00:09:25,920 --> 00:09:30,719
you can't have any kind of source

240
00:09:27,279 --> 00:09:32,080
modifiers on so there's

241
00:09:30,720 --> 00:09:33,839
a lot of things that have to be taken

242
00:09:32,080 --> 00:09:34,560
into consideration of whether you're not

243
00:09:33,839 --> 00:09:38,640
you have to

244
00:09:34,560 --> 00:09:40,719
resolve those those source modifiers

245
00:09:38,640 --> 00:09:42,720
and it isn't even wasn't even universal

246
00:09:40,720 --> 00:09:47,279
which things were free

247
00:09:42,720 --> 00:09:50,000
so on 996.5 absolute value was free

248
00:09:47,279 --> 00:09:51,519
but on 9 15 which was a thing we still

249
00:09:50,000 --> 00:09:54,959
cared about 12 years ago

250
00:09:51,519 --> 00:09:57,839
and our 200 and r300 to kind of

251
00:09:54,959 --> 00:09:58,239
date where this started uh you had to

252
00:09:57,839 --> 00:10:00,000
use

253
00:09:58,240 --> 00:10:01,839
separate instructions for doing absolute

254
00:10:00,000 --> 00:10:05,040
value they didn't have an absolute value

255
00:10:01,839 --> 00:10:06,640
source modifier and if we were

256
00:10:05,040 --> 00:10:10,000
decorating

257
00:10:06,640 --> 00:10:13,199
if we were going to have a bunch of

258
00:10:10,000 --> 00:10:15,279
patterns to implement

259
00:10:13,200 --> 00:10:16,839
all the different possible instructions

260
00:10:15,279 --> 00:10:19,200
we didn't want to have to go through and

261
00:10:16,839 --> 00:10:21,600
decorate every single place all the

262
00:10:19,200 --> 00:10:23,600
combinatorial explosion of

263
00:10:21,600 --> 00:10:25,440
yes you can have absolute value and

264
00:10:23,600 --> 00:10:28,320
negation on both the sources

265
00:10:25,440 --> 00:10:29,120
of an ad and all of the it would have

266
00:10:28,320 --> 00:10:31,440
just made it

267
00:10:29,120 --> 00:10:34,640
way too verbose and would have kind of

268
00:10:31,440 --> 00:10:34,640
defeated the purpose

269
00:10:36,160 --> 00:10:40,399
so kind of going along with source

270
00:10:38,399 --> 00:10:42,480
modifiers there's also

271
00:10:40,399 --> 00:10:44,079
possibility of destination modifiers

272
00:10:42,480 --> 00:10:46,720
which is definitely a thing that doesn't

273
00:10:44,079 --> 00:10:49,519
exist on general purpose cpus

274
00:10:46,720 --> 00:10:52,000
you can have a saturate modifier that

275
00:10:49,519 --> 00:10:53,920
will clamp the result of an operation to

276
00:10:52,000 --> 00:10:56,320
the range zero and one

277
00:10:53,920 --> 00:10:58,399
and on some nvidia gpus there's a

278
00:10:56,320 --> 00:10:58,720
different saturated modifier that clamps

279
00:10:58,399 --> 00:11:01,839
to

280
00:10:58,720 --> 00:11:01,839
plus or minus one

281
00:11:01,920 --> 00:11:08,959
um and we've kind of come

282
00:11:05,680 --> 00:11:10,959
a long way in our compiler design of

283
00:11:08,959 --> 00:11:12,000
in the the compiler stack in mesa since

284
00:11:10,959 --> 00:11:15,040
then and it's

285
00:11:12,000 --> 00:11:18,320
kind of dubious whether or not having

286
00:11:15,040 --> 00:11:20,399
in the ir this the

287
00:11:18,320 --> 00:11:22,320
destination modifier is a special thing

288
00:11:20,399 --> 00:11:24,160
is actually that helpful

289
00:11:22,320 --> 00:11:25,360
and i think probably in the next year

290
00:11:24,160 --> 00:11:28,160
we're going to end up

291
00:11:25,360 --> 00:11:29,360
uh removing that but it's still a thing

292
00:11:28,160 --> 00:11:32,560
that has to be considered

293
00:11:29,360 --> 00:11:33,760
because being able to get that clamping

294
00:11:32,560 --> 00:11:35,680
happens a lot

295
00:11:33,760 --> 00:11:37,600
and being able to get it for free on

296
00:11:35,680 --> 00:11:40,319
instructions

297
00:11:37,600 --> 00:11:40,320
is a big deal

298
00:11:41,040 --> 00:11:44,719
uh so then

299
00:11:44,800 --> 00:11:49,120
on the gpu architectures of the day they

300
00:11:47,120 --> 00:11:51,440
were predominantly vector-based for at

301
00:11:49,120 --> 00:11:54,839
least part of their pipeline

302
00:11:51,440 --> 00:11:58,480
so swizzling was hugely important

303
00:11:54,839 --> 00:11:59,040
um and that's not a thing that even

304
00:11:58,480 --> 00:12:02,399
exists

305
00:11:59,040 --> 00:12:04,240
on cmd architectures right

306
00:12:02,399 --> 00:12:06,480
cmd architectures are just generally

307
00:12:04,240 --> 00:12:07,120
parallel up do the same thing on all the

308
00:12:06,480 --> 00:12:09,760
channels

309
00:12:07,120 --> 00:12:11,440
in their order there's no reordering of

310
00:12:09,760 --> 00:12:13,439
channels except with

311
00:12:11,440 --> 00:12:17,760
some very special instructions that are

312
00:12:13,440 --> 00:12:17,760
that are dedicated just for reordering

313
00:12:17,839 --> 00:12:22,880
swizzles end up being worse than source

314
00:12:20,959 --> 00:12:26,000
modifiers

315
00:12:22,880 --> 00:12:28,000
because source modifiers there's there's

316
00:12:26,000 --> 00:12:29,519
four combinations that you have to worry

317
00:12:28,000 --> 00:12:32,959
about none

318
00:12:29,519 --> 00:12:35,920
negate abs and negative abs

319
00:12:32,959 --> 00:12:38,000
but with swizzles on a vec 4

320
00:12:35,920 --> 00:12:40,880
architecture where you have

321
00:12:38,000 --> 00:12:43,120
four element vectors your your base

322
00:12:40,880 --> 00:12:47,120
there's either 256

323
00:12:43,120 --> 00:12:47,839
or 1296 possible combinations of

324
00:12:47,120 --> 00:12:49,680
swizzles

325
00:12:47,839 --> 00:12:52,959
there there's some architectures that

326
00:12:49,680 --> 00:12:56,000
can not only reorder x y z w

327
00:12:52,959 --> 00:12:56,800
arbitrarily per component but can also

328
00:12:56,000 --> 00:13:00,720
select

329
00:12:56,800 --> 00:13:00,719
constant values of zero and one

330
00:13:01,120 --> 00:13:04,880
and that doesn't even consider having to

331
00:13:02,720 --> 00:13:08,000
deal with right masks

332
00:13:04,880 --> 00:13:11,839
so the whole thing was just

333
00:13:08,000 --> 00:13:13,760
so far out into doing basically compiler

334
00:13:11,839 --> 00:13:14,959
research to figure out how to do these

335
00:13:13,760 --> 00:13:19,040
things

336
00:13:14,959 --> 00:13:21,599
um they was just completely impractical

337
00:13:19,040 --> 00:13:23,680
but that that dream of being able to

338
00:13:21,600 --> 00:13:24,079
write these these concise descriptions

339
00:13:23,680 --> 00:13:27,279
of

340
00:13:24,079 --> 00:13:30,560
when you see this generate this code

341
00:13:27,279 --> 00:13:31,680
was so compelling that we tried several

342
00:13:30,560 --> 00:13:35,199
times

343
00:13:31,680 --> 00:13:37,920
both myself and eric anholt each

344
00:13:35,200 --> 00:13:38,240
of us tried at least twice to come up

345
00:13:37,920 --> 00:13:42,240
with

346
00:13:38,240 --> 00:13:44,720
something that that would do this

347
00:13:42,240 --> 00:13:46,000
but every time you know ran into a

348
00:13:44,720 --> 00:13:48,800
roadblock and just

349
00:13:46,000 --> 00:13:49,360
gave up because we had to ship products

350
00:13:48,800 --> 00:13:51,680
and not

351
00:13:49,360 --> 00:13:53,440
do you know compiler research as much

352
00:13:51,680 --> 00:13:57,680
fun as that might be

353
00:13:53,440 --> 00:14:00,880
um so they say time heals all wounds

354
00:13:57,680 --> 00:14:01,519
and i i don't know if that's true but i

355
00:14:00,880 --> 00:14:04,480
do know

356
00:14:01,519 --> 00:14:06,160
that if you ignore technical problems

357
00:14:04,480 --> 00:14:09,920
long enough

358
00:14:06,160 --> 00:14:13,360
they will probably become irrelevant

359
00:14:09,920 --> 00:14:14,000
so what what what wounds did 10 years

360
00:14:13,360 --> 00:14:16,240
heal

361
00:14:14,000 --> 00:14:17,279
well first of all we don't have to write

362
00:14:16,240 --> 00:14:21,680
a dsl

363
00:14:17,279 --> 00:14:24,480
anymore pretty much everything that

364
00:14:21,680 --> 00:14:26,319
elberg or any of the other code

365
00:14:24,480 --> 00:14:28,160
generator generators that

366
00:14:26,320 --> 00:14:29,600
people had ever come up with pretty much

367
00:14:28,160 --> 00:14:32,160
anything that those

368
00:14:29,600 --> 00:14:33,440
languages needed we can handle with just

369
00:14:32,160 --> 00:14:35,199
python data

370
00:14:33,440 --> 00:14:36,959
right we can make something that look

371
00:14:35,199 --> 00:14:38,639
that we can make data structures that

372
00:14:36,959 --> 00:14:42,479
encapsulate the

373
00:14:38,639 --> 00:14:46,079
match match this do that we can do that

374
00:14:42,480 --> 00:14:49,440
really easily with just uh python data

375
00:14:46,079 --> 00:14:51,279
and in fact neuroopt algebraic

376
00:14:49,440 --> 00:14:53,040
that's already part of mesa is an

377
00:14:51,279 --> 00:14:56,839
existence proof that that

378
00:14:53,040 --> 00:14:59,920
kind of architecture works really really

379
00:14:56,839 --> 00:15:01,920
well there's a couple of things that

380
00:14:59,920 --> 00:15:02,959
it doesn't that neuropt algebraic

381
00:15:01,920 --> 00:15:05,519
doesn't support

382
00:15:02,959 --> 00:15:06,239
uh that might be nice in a generator

383
00:15:05,519 --> 00:15:09,360
generator

384
00:15:06,240 --> 00:15:12,480
uh it doesn't support any kind of

385
00:15:09,360 --> 00:15:15,920
regular expressions or or more complex

386
00:15:12,480 --> 00:15:19,360
pattern matching you just do a static

387
00:15:15,920 --> 00:15:20,959
match this exact pattern and do this

388
00:15:19,360 --> 00:15:23,760
exact thing

389
00:15:20,959 --> 00:15:25,760
and in the do that part it doesn't it's

390
00:15:23,760 --> 00:15:28,720
very limited in what you can put in the

391
00:15:25,760 --> 00:15:28,720
do that part

392
00:15:29,040 --> 00:15:32,399
and there's also it's also a bit lacking

393
00:15:31,839 --> 00:15:34,240
on

394
00:15:32,399 --> 00:15:36,800
being able to put constraints on the

395
00:15:34,240 --> 00:15:36,800
sources

396
00:15:36,959 --> 00:15:40,079
we've over the years we've added a lot

397
00:15:38,720 --> 00:15:42,880
of things to how it can do

398
00:15:40,079 --> 00:15:43,680
constraint matching on parts of the

399
00:15:42,880 --> 00:15:46,320
patterns

400
00:15:43,680 --> 00:15:47,120
but it can't do something like if you

401
00:15:46,320 --> 00:15:50,720
have a match

402
00:15:47,120 --> 00:15:51,759
expression that has say two constants in

403
00:15:50,720 --> 00:15:54,560
it

404
00:15:51,759 --> 00:15:55,680
and you want to say match this pattern

405
00:15:54,560 --> 00:15:58,000
if

406
00:15:55,680 --> 00:15:59,758
this constant is less than the other

407
00:15:58,000 --> 00:16:01,040
constant there's there's no way to do

408
00:15:59,759 --> 00:16:02,399
something like that and there's a bunch

409
00:16:01,040 --> 00:16:05,439
of cases where

410
00:16:02,399 --> 00:16:05,440
where that would be handy

411
00:16:06,880 --> 00:16:10,720
and then also you know vector

412
00:16:08,480 --> 00:16:13,360
architectures are dead that whole

413
00:16:10,720 --> 00:16:15,120
swizzling right masking all that

414
00:16:13,360 --> 00:16:17,199
nonsense just

415
00:16:15,120 --> 00:16:18,160
is irrelevant because all those

416
00:16:17,199 --> 00:16:21,758
architectures

417
00:16:18,160 --> 00:16:25,199
died off uh the last architecture

418
00:16:21,759 --> 00:16:26,240
for intel where we had to use a vector

419
00:16:25,199 --> 00:16:29,359
oriented thing

420
00:16:26,240 --> 00:16:32,639
was haswell which was

421
00:16:29,360 --> 00:16:35,199
years ago at this point broadwell

422
00:16:32,639 --> 00:16:36,720
supported it but didn't require the use

423
00:16:35,199 --> 00:16:38,719
of it and we

424
00:16:36,720 --> 00:16:41,600
we never used that in the the driver

425
00:16:38,720 --> 00:16:43,360
that we shipped um

426
00:16:41,600 --> 00:16:45,920
and there there are still a few

427
00:16:43,360 --> 00:16:49,839
architectures that

428
00:16:45,920 --> 00:16:52,079
have some kind of more traditional sim d

429
00:16:49,839 --> 00:16:53,519
within a register kinds of things like

430
00:16:52,079 --> 00:16:55,599
the uh

431
00:16:53,519 --> 00:16:56,639
there's a handful of four by eight

432
00:16:55,600 --> 00:17:00,399
instructions on

433
00:16:56,639 --> 00:17:02,800
on vc4 that that do operations on

434
00:17:00,399 --> 00:17:04,799
four parallel bytes within a single

435
00:17:02,800 --> 00:17:07,198
32-bit register but

436
00:17:04,799 --> 00:17:09,039
because those look like traditional

437
00:17:07,199 --> 00:17:12,000
cindy they don't have

438
00:17:09,039 --> 00:17:12,799
the the craziness of the swizzling and

439
00:17:12,000 --> 00:17:15,199
right masking

440
00:17:12,799 --> 00:17:16,720
and all that nonsense so they don't we

441
00:17:15,199 --> 00:17:20,880
don't have to worry about those either

442
00:17:16,720 --> 00:17:25,199
they're they're not a problem so

443
00:17:20,880 --> 00:17:28,400
looking at opt algebraic as a dsl

444
00:17:25,199 --> 00:17:30,559
you have a simple pattern to match

445
00:17:28,400 --> 00:17:32,000
is is the first field and these those

446
00:17:30,559 --> 00:17:35,760
can be arbitrary

447
00:17:32,000 --> 00:17:39,280
nested trees you have a

448
00:17:35,760 --> 00:17:39,679
replacement as the next field which are

449
00:17:39,280 --> 00:17:44,879
also

450
00:17:39,679 --> 00:17:47,520
trees and they can each of them have

451
00:17:44,880 --> 00:17:49,280
variables that are just text we have

452
00:17:47,520 --> 00:17:53,280
some convenience names for them

453
00:17:49,280 --> 00:17:55,200
abcd etc uh so you can rewrite the

454
00:17:53,280 --> 00:17:55,760
expressions and then there's a sort of a

455
00:17:55,200 --> 00:17:59,280
global

456
00:17:55,760 --> 00:18:02,320
condition flag that's that's optional

457
00:17:59,280 --> 00:18:05,280
so in this case this will do lowering

458
00:18:02,320 --> 00:18:06,480
uh if the ir has a subtract instruction

459
00:18:05,280 --> 00:18:08,160
but most gpus

460
00:18:06,480 --> 00:18:10,000
don't have a subtract instruction you

461
00:18:08,160 --> 00:18:12,480
just do add of neg

462
00:18:10,000 --> 00:18:13,390
so this does that that sort of lowering

463
00:18:12,480 --> 00:18:16,459
pass

464
00:18:13,390 --> 00:18:16,459
[Music]

465
00:18:17,919 --> 00:18:24,320
so the do that part

466
00:18:20,960 --> 00:18:28,000
of the neuropt algebraic dsl

467
00:18:24,320 --> 00:18:31,039
is always replace the old

468
00:18:28,000 --> 00:18:32,880
tree with this new tree and replacement

469
00:18:31,039 --> 00:18:33,520
is a little bit of a misnomer there

470
00:18:32,880 --> 00:18:36,240
because

471
00:18:33,520 --> 00:18:37,360
nothing gets removed from the the input

472
00:18:36,240 --> 00:18:40,080
string

473
00:18:37,360 --> 00:18:41,280
what happens is it just adds some more

474
00:18:40,080 --> 00:18:44,480
stuff

475
00:18:41,280 --> 00:18:45,760
you have a new result value and all the

476
00:18:44,480 --> 00:18:47,919
old users

477
00:18:45,760 --> 00:18:50,320
all the all the users of the old result

478
00:18:47,919 --> 00:18:52,320
get modified to use the new result

479
00:18:50,320 --> 00:18:54,159
and then we expect that later

480
00:18:52,320 --> 00:18:55,200
optimization passes like dead code

481
00:18:54,160 --> 00:18:58,799
elimination will

482
00:18:55,200 --> 00:19:00,559
will clear out uh any of the

483
00:18:58,799 --> 00:19:03,039
the bits that are that are no longer

484
00:19:00,559 --> 00:19:04,480
needed they'll do the actual deleting

485
00:19:03,039 --> 00:19:08,160
part

486
00:19:04,480 --> 00:19:10,640
the other subtle point here is

487
00:19:08,160 --> 00:19:12,080
parts of the input string might not

488
00:19:10,640 --> 00:19:15,120
match any patterns

489
00:19:12,080 --> 00:19:16,000
that exist in your your giant pattern

490
00:19:15,120 --> 00:19:18,879
file

491
00:19:16,000 --> 00:19:20,400
uh which is actually a good thing and

492
00:19:18,880 --> 00:19:22,080
eventually as you go through the

493
00:19:20,400 --> 00:19:23,520
optimization passes

494
00:19:22,080 --> 00:19:25,840
you'll get to a point where nothing

495
00:19:23,520 --> 00:19:28,320
matches otherwise you'd get stuck

496
00:19:25,840 --> 00:19:28,959
in an infinite optimization loop which

497
00:19:28,320 --> 00:19:32,320
is a bug

498
00:19:28,960 --> 00:19:34,320
that happens occasionally if you have a

499
00:19:32,320 --> 00:19:35,439
series of patterns that sort of fight

500
00:19:34,320 --> 00:19:39,039
with each other

501
00:19:35,440 --> 00:19:41,120
so if you had this pattern and had

502
00:19:39,039 --> 00:19:42,559
another pattern that converted add of

503
00:19:41,120 --> 00:19:43,918
neg to subtract

504
00:19:42,559 --> 00:19:45,600
and they weren't decorated with this

505
00:19:43,919 --> 00:19:48,000
condition they would just keep

506
00:19:45,600 --> 00:19:48,719
undoing each other and so each pass

507
00:19:48,000 --> 00:19:51,919
through

508
00:19:48,720 --> 00:19:52,320
they'd both activate it'd say yes some

509
00:19:51,919 --> 00:19:54,559
their

510
00:19:52,320 --> 00:19:56,080
optimizations happen so keep going

511
00:19:54,559 --> 00:19:56,480
through the loop and you just get stuck

512
00:19:56,080 --> 00:19:59,520
in

513
00:19:56,480 --> 00:19:59,520
in an infinite loop

514
00:20:00,000 --> 00:20:03,919
it is a bug that happens from time to

515
00:20:01,600 --> 00:20:03,918
time

516
00:20:05,360 --> 00:20:09,360
all right so especially after hearing me

517
00:20:07,360 --> 00:20:11,360
talk up neuropt algebraic it

518
00:20:09,360 --> 00:20:12,959
it's probably not hard to guess where

519
00:20:11,360 --> 00:20:15,280
this is going

520
00:20:12,960 --> 00:20:16,640
we can use the this existing

521
00:20:15,280 --> 00:20:20,000
infrastructure

522
00:20:16,640 --> 00:20:24,559
to implement a new match this

523
00:20:20,000 --> 00:20:27,440
do that kind of dsl

524
00:20:24,559 --> 00:20:29,520
but there are some still some some kind

525
00:20:27,440 --> 00:20:32,240
of sticking points

526
00:20:29,520 --> 00:20:33,120
the algebraic optimizations happen while

527
00:20:32,240 --> 00:20:38,159
the ir

528
00:20:33,120 --> 00:20:41,280
is still in a very pure uh ssa form

529
00:20:38,159 --> 00:20:43,200
uh but when we do code generation

530
00:20:41,280 --> 00:20:44,960
we've come out of ssa form and so

531
00:20:43,200 --> 00:20:49,360
there's a lot of assumptions that

532
00:20:44,960 --> 00:20:53,520
are are made by the opt algebraic

533
00:20:49,360 --> 00:20:53,520
framework that don't hold anymore

534
00:20:56,240 --> 00:21:02,320
so for example the uh opt algebraic

535
00:21:00,000 --> 00:21:04,240
can't handle source modifiers in the

536
00:21:02,320 --> 00:21:05,520
matching if it encounters a source

537
00:21:04,240 --> 00:21:08,000
modifier

538
00:21:05,520 --> 00:21:08,799
at any point while it's trying to match

539
00:21:08,000 --> 00:21:11,120
a

540
00:21:08,799 --> 00:21:12,320
pattern versus the actual ir it just

541
00:21:11,120 --> 00:21:16,239
says i

542
00:21:12,320 --> 00:21:19,520
i don't know and gives up um

543
00:21:16,240 --> 00:21:21,200
so what seems to be sufficient for code

544
00:21:19,520 --> 00:21:24,639
generation purposes

545
00:21:21,200 --> 00:21:28,720
uh is to if you encounter

546
00:21:24,640 --> 00:21:30,080
a value and a that same value but with

547
00:21:28,720 --> 00:21:32,480
some source modifiers

548
00:21:30,080 --> 00:21:34,158
is to just treat them as they're

549
00:21:32,480 --> 00:21:36,159
completely unrelated variables

550
00:21:34,159 --> 00:21:38,240
they're not it's not a value and it's

551
00:21:36,159 --> 00:21:40,400
negation it's a value

552
00:21:38,240 --> 00:21:42,720
and a different value and just match the

553
00:21:40,400 --> 00:21:46,159
patterns as though they were

554
00:21:42,720 --> 00:21:46,159
had nothing to do with each other

555
00:21:49,360 --> 00:21:52,799
so it also can't handle having the

556
00:21:52,080 --> 00:21:56,399
destination

557
00:21:52,799 --> 00:21:58,879
saturate modifier so far

558
00:21:56,400 --> 00:21:59,600
i think it is sufficient to only be able

559
00:21:58,880 --> 00:22:02,960
to

560
00:21:59,600 --> 00:22:03,678
have the destination saturate modifier

561
00:22:02,960 --> 00:22:07,200
at the

562
00:22:03,679 --> 00:22:09,600
the base of the match tree so in the

563
00:22:07,200 --> 00:22:10,880
subtract well i guess that is a very

564
00:22:09,600 --> 00:22:12,240
good one because there isn't much of a

565
00:22:10,880 --> 00:22:15,440
tree there so only the

566
00:22:12,240 --> 00:22:15,840
the root of the tree would have could

567
00:22:15,440 --> 00:22:17,679
have

568
00:22:15,840 --> 00:22:19,600
a saturate modifier in it if you

569
00:22:17,679 --> 00:22:21,200
encountered anything during the match

570
00:22:19,600 --> 00:22:23,360
farther down in the tree you say okay it

571
00:22:21,200 --> 00:22:26,640
doesn't match

572
00:22:23,360 --> 00:22:29,360
so far i haven't found any cases during

573
00:22:26,640 --> 00:22:32,080
code generation where it would actually

574
00:22:29,360 --> 00:22:35,360
be beneficial to detect

575
00:22:32,080 --> 00:22:39,360
saturate modifiers at other points

576
00:22:35,360 --> 00:22:40,158
in the tree the couple cases that i came

577
00:22:39,360 --> 00:22:43,280
across where

578
00:22:40,159 --> 00:22:43,840
maybe something clever could be done it

579
00:22:43,280 --> 00:22:46,158
turned out

580
00:22:43,840 --> 00:22:48,799
it was actually better to just implement

581
00:22:46,159 --> 00:22:50,559
an algebraic optimization to

582
00:22:48,799 --> 00:22:52,158
change what the tree was going to look

583
00:22:50,559 --> 00:22:54,639
like

584
00:22:52,159 --> 00:22:55,679
before the tree was in before the ir was

585
00:22:54,640 --> 00:22:57,840
in the state where

586
00:22:55,679 --> 00:22:59,120
you have those as modifiers where they

587
00:22:57,840 --> 00:23:01,439
where saturate is just

588
00:22:59,120 --> 00:23:02,559
an instruction do the optimizations

589
00:23:01,440 --> 00:23:04,880
earlier on

590
00:23:02,559 --> 00:23:06,399
and then later on you don't see that

591
00:23:04,880 --> 00:23:09,520
stuff during code generation

592
00:23:06,400 --> 00:23:11,120
and it it ends up being so much much

593
00:23:09,520 --> 00:23:14,158
simpler

594
00:23:11,120 --> 00:23:17,520
that may change as we come up with with

595
00:23:14,159 --> 00:23:19,840
more clever code generation patterns uh

596
00:23:17,520 --> 00:23:20,639
and if it gets to that we may have to

597
00:23:19,840 --> 00:23:24,399
just stop

598
00:23:20,640 --> 00:23:27,440
using the destination modifiers which

599
00:23:24,400 --> 00:23:28,159
we may end up doing anyway it's it's

600
00:23:27,440 --> 00:23:31,039
still

601
00:23:28,159 --> 00:23:31,039
an open question

602
00:23:32,799 --> 00:23:40,080
so can't opt algebraic

603
00:23:36,559 --> 00:23:43,678
can't handle non-ssa destinations

604
00:23:40,080 --> 00:23:47,199
so after we've come out of ssa mode

605
00:23:43,679 --> 00:23:48,480
if the shader has control flow there's

606
00:23:47,200 --> 00:23:51,600
going to be places where

607
00:23:48,480 --> 00:23:54,480
rights happen to registers and set it to

608
00:23:51,600 --> 00:23:56,799
ssa values

609
00:23:54,480 --> 00:23:59,919
and i don't that that doesn't that's

610
00:23:56,799 --> 00:24:03,840
fine it's it's completely safe to match

611
00:23:59,919 --> 00:24:05,840
the the final thing as writing to a non

612
00:24:03,840 --> 00:24:07,760
ssa value

613
00:24:05,840 --> 00:24:08,959
so the the patch that i reference there

614
00:24:07,760 --> 00:24:11,279
is

615
00:24:08,960 --> 00:24:13,919
it just deletes an assertion out of out

616
00:24:11,279 --> 00:24:17,120
of the matching code is all

617
00:24:13,919 --> 00:24:18,080
and so that's pretty easy but going

618
00:24:17,120 --> 00:24:20,799
along with that

619
00:24:18,080 --> 00:24:22,639
it also can't handle sources that are

620
00:24:20,799 --> 00:24:25,279
non-ssa values

621
00:24:22,640 --> 00:24:26,159
and we have to be able to match those

622
00:24:25,279 --> 00:24:27,760
because

623
00:24:26,159 --> 00:24:32,080
we have to be able to generate code from

624
00:24:27,760 --> 00:24:34,960
that um

625
00:24:32,080 --> 00:24:35,678
i so far i think that it is safe to

626
00:24:34,960 --> 00:24:38,720
match

627
00:24:35,679 --> 00:24:42,240
a non-ssa value in an expression tree

628
00:24:38,720 --> 00:24:42,640
if that ssa value only or that non-ssa

629
00:24:42,240 --> 00:24:45,600
value

630
00:24:42,640 --> 00:24:48,480
pardon me only appears once because the

631
00:24:45,600 --> 00:24:52,480
problem is if you have

632
00:24:48,480 --> 00:24:52,480
the the ssa values are

633
00:24:52,720 --> 00:24:59,440
by by their definition they don't change

634
00:24:56,080 --> 00:25:00,720
non-ssa values if you see two reads of

635
00:24:59,440 --> 00:25:03,679
them that are separated

636
00:25:00,720 --> 00:25:05,760
at all those reads could be reading

637
00:25:03,679 --> 00:25:07,840
different

638
00:25:05,760 --> 00:25:09,919
versions of that value so they might be

639
00:25:07,840 --> 00:25:13,439
different values

640
00:25:09,919 --> 00:25:15,279
so if you had the same thing appearing

641
00:25:13,440 --> 00:25:17,520
multiple times in an expression tree

642
00:25:15,279 --> 00:25:18,320
each of those might be different and so

643
00:25:17,520 --> 00:25:21,760
the tree

644
00:25:18,320 --> 00:25:24,000
doesn't really match um you might be

645
00:25:21,760 --> 00:25:27,039
generating bad code

646
00:25:24,000 --> 00:25:28,320
so for example if you had if you had a

647
00:25:27,039 --> 00:25:31,440
pattern that

648
00:25:28,320 --> 00:25:35,039
matched a plus a and replaced it with a

649
00:25:31,440 --> 00:25:37,679
times two well if those two a's

650
00:25:35,039 --> 00:25:39,840
were non-ssa values they might be

651
00:25:37,679 --> 00:25:41,520
different values so replacing that with

652
00:25:39,840 --> 00:25:45,439
one of them multiplied by two is going

653
00:25:41,520 --> 00:25:45,440
to give you an incorrect result

654
00:25:49,919 --> 00:25:54,720
so i think that it's safe and i have

655
00:25:52,240 --> 00:25:57,600
some results later on that that

656
00:25:54,720 --> 00:25:59,279
helped convince me that it's safe to if

657
00:25:57,600 --> 00:26:01,360
if a non-ssa value

658
00:25:59,279 --> 00:26:02,640
appears only once that it's safe to just

659
00:26:01,360 --> 00:26:05,918
match it and

660
00:26:02,640 --> 00:26:07,039
and go on with life uh the need for

661
00:26:05,919 --> 00:26:10,080
being able to have

662
00:26:07,039 --> 00:26:12,640
non-ssa sources in the trees

663
00:26:10,080 --> 00:26:13,199
poses another problem for the existing

664
00:26:12,640 --> 00:26:16,559
match

665
00:26:13,200 --> 00:26:19,770
in matching engine but i'll get to that

666
00:26:16,559 --> 00:26:20,879
again in a in a couple of slides

667
00:26:19,770 --> 00:26:25,039
[Music]

668
00:26:20,880 --> 00:26:26,080
so it has the existing infrastructure

669
00:26:25,039 --> 00:26:29,760
has

670
00:26:26,080 --> 00:26:34,480
really really limited uh type tracking

671
00:26:29,760 --> 00:26:37,760
so the values themselves in nur

672
00:26:34,480 --> 00:26:38,000
don't have any types they're just a blob

673
00:26:37,760 --> 00:26:41,840
of

674
00:26:38,000 --> 00:26:42,640
bits they only have a type when they're

675
00:26:41,840 --> 00:26:45,840
used by

676
00:26:42,640 --> 00:26:48,080
an instruction and

677
00:26:45,840 --> 00:26:49,678
the instruction dictates what the type

678
00:26:48,080 --> 00:26:51,918
is so we have separate

679
00:26:49,679 --> 00:26:54,320
floating point add an integer add

680
00:26:51,919 --> 00:26:56,400
instructions so if you have the same

681
00:26:54,320 --> 00:26:57,678
values as sources to both those

682
00:26:56,400 --> 00:26:59,919
instructions

683
00:26:57,679 --> 00:27:01,520
in one of those cases that value is

684
00:26:59,919 --> 00:27:03,600
interpreted as floating point

685
00:27:01,520 --> 00:27:04,799
and in the other case it's interpreted

686
00:27:03,600 --> 00:27:07,199
as integer

687
00:27:04,799 --> 00:27:09,760
even though it's the exact same sequence

688
00:27:07,200 --> 00:27:09,760
of bits

689
00:27:10,120 --> 00:27:15,520
[Music]

690
00:27:12,880 --> 00:27:16,159
so where this becomes a problem is for

691
00:27:15,520 --> 00:27:19,200
example

692
00:27:16,159 --> 00:27:22,320
on intel gpus we don't have

693
00:27:19,200 --> 00:27:26,240
a specific instruction to

694
00:27:22,320 --> 00:27:27,520
convert integer to float

695
00:27:26,240 --> 00:27:29,360
what we have is we have a move

696
00:27:27,520 --> 00:27:31,679
instruction and you mark

697
00:27:29,360 --> 00:27:32,559
on the move instruction that its source

698
00:27:31,679 --> 00:27:35,200
is integer

699
00:27:32,559 --> 00:27:36,240
and the destination is float so when you

700
00:27:35,200 --> 00:27:39,440
get into the

701
00:27:36,240 --> 00:27:42,320
the do that part of the patterns

702
00:27:39,440 --> 00:27:43,760
you need to know i'm just emitting a

703
00:27:42,320 --> 00:27:46,158
move instruction

704
00:27:43,760 --> 00:27:47,279
but for this source i need to know what

705
00:27:46,159 --> 00:27:49,919
type it was being

706
00:27:47,279 --> 00:27:50,880
interpreted as in the pattern that got

707
00:27:49,919 --> 00:27:53,120
matched

708
00:27:50,880 --> 00:27:55,200
so there's some additional uh tracking

709
00:27:53,120 --> 00:27:58,959
that needs to happen so that

710
00:27:55,200 --> 00:28:00,480
the values that are used in the the do

711
00:27:58,960 --> 00:28:03,440
that part can get

712
00:28:00,480 --> 00:28:05,440
back connected to where they appeared in

713
00:28:03,440 --> 00:28:08,320
the original

714
00:28:05,440 --> 00:28:08,320
matching tree

715
00:28:11,600 --> 00:28:16,000
so like i mentioned before opt algebraic

716
00:28:14,960 --> 00:28:19,919
doesn't require

717
00:28:16,000 --> 00:28:24,000
that everything in the the input

718
00:28:19,919 --> 00:28:26,320
matches something in the patterns but

719
00:28:24,000 --> 00:28:28,399
if you're generating code everything

720
00:28:26,320 --> 00:28:29,840
that exists in the ir had

721
00:28:28,399 --> 00:28:31,360
better end up as some kind of

722
00:28:29,840 --> 00:28:31,760
instructions in the output or you're

723
00:28:31,360 --> 00:28:35,199
just

724
00:28:31,760 --> 00:28:35,679
like dropping stuff on the floor so it

725
00:28:35,200 --> 00:28:38,159
isn't

726
00:28:35,679 --> 00:28:40,000
a problem per se but it's something that

727
00:28:38,159 --> 00:28:42,640
when you're writing

728
00:28:40,000 --> 00:28:44,000
the code generator descript the machine

729
00:28:42,640 --> 00:28:45,760
description for the code

730
00:28:44,000 --> 00:28:47,760
generator and when you're implementing

731
00:28:45,760 --> 00:28:49,760
the other infrastructure for the

732
00:28:47,760 --> 00:28:51,840
code generator that you have to be aware

733
00:28:49,760 --> 00:28:54,158
of so you can detect

734
00:28:51,840 --> 00:28:55,120
i sent some ir into the matching engine

735
00:28:54,159 --> 00:28:57,520
and it didn't match

736
00:28:55,120 --> 00:28:58,639
anything you need to generate some kind

737
00:28:57,520 --> 00:29:01,918
of an error or

738
00:28:58,640 --> 00:29:05,520
or do something because you

739
00:29:01,919 --> 00:29:05,520
you're about to do something bad

740
00:29:07,120 --> 00:29:11,279
uh and then the other thing that's

741
00:29:10,480 --> 00:29:14,640
that's

742
00:29:11,279 --> 00:29:17,039
kind of a quirk uh it's not really a

743
00:29:14,640 --> 00:29:20,000
problem but is again something that

744
00:29:17,039 --> 00:29:21,279
uh you have to be aware of is in opt

745
00:29:20,000 --> 00:29:24,480
algebraic

746
00:29:21,279 --> 00:29:27,679
the the input language and the output

747
00:29:24,480 --> 00:29:29,440
language are the same but

748
00:29:27,679 --> 00:29:31,120
the whole point of doing code generation

749
00:29:29,440 --> 00:29:34,320
is you're translating from

750
00:29:31,120 --> 00:29:36,320
one thing to a different thing

751
00:29:34,320 --> 00:29:38,080
so what this means in a practical sense

752
00:29:36,320 --> 00:29:40,158
is about

753
00:29:38,080 --> 00:29:42,080
half of the infrastructure that exists

754
00:29:40,159 --> 00:29:43,840
in opt algebraic

755
00:29:42,080 --> 00:29:45,600
is completely unusable for a code

756
00:29:43,840 --> 00:29:48,240
generator the only part that you can

757
00:29:45,600 --> 00:29:49,360
that is actually reusable is the

758
00:29:48,240 --> 00:29:52,480
matching part

759
00:29:49,360 --> 00:29:53,439
the we found a match now let's do

760
00:29:52,480 --> 00:29:56,720
something

761
00:29:53,440 --> 00:29:59,919
isn't isn't any good to you because

762
00:29:56,720 --> 00:30:00,960
we're doing something different and it

763
00:29:59,919 --> 00:30:04,799
turns out that

764
00:30:00,960 --> 00:30:08,080
about 45 of the work of this project

765
00:30:04,799 --> 00:30:11,840
was completely rewriting

766
00:30:08,080 --> 00:30:12,799
all of the uh the infrastructure for

767
00:30:11,840 --> 00:30:16,000
doing the

768
00:30:12,799 --> 00:30:18,639
the do that part of the um

769
00:30:16,000 --> 00:30:18,640
the process

770
00:30:19,360 --> 00:30:24,080
uh so the other difficulty

771
00:30:25,200 --> 00:30:29,039
with non-ssa values that i alluded to

772
00:30:27,679 --> 00:30:31,919
before

773
00:30:29,039 --> 00:30:32,960
uh has to do with the the optimized

774
00:30:31,919 --> 00:30:36,480
matching engine

775
00:30:32,960 --> 00:30:39,840
in opt algebraic so the

776
00:30:36,480 --> 00:30:40,960
algebraic optimization happens a huge

777
00:30:39,840 --> 00:30:44,000
number of times

778
00:30:40,960 --> 00:30:46,880
during the the main optimization loop

779
00:30:44,000 --> 00:30:47,679
and we found that it was a big chunk of

780
00:30:46,880 --> 00:30:49,919
the time

781
00:30:47,679 --> 00:30:51,840
was spent in just doing all of the

782
00:30:49,919 --> 00:30:55,039
matching

783
00:30:51,840 --> 00:30:58,158
so connor abbott wrote a

784
00:30:55,039 --> 00:31:01,039
really really optimized matching engine

785
00:30:58,159 --> 00:31:01,039
that uses a

786
00:31:01,279 --> 00:31:04,880
a modified finite state machine to to

787
00:31:03,840 --> 00:31:08,720
very quickly do

788
00:31:04,880 --> 00:31:09,519
the matching but the way that it

789
00:31:08,720 --> 00:31:13,519
implements this

790
00:31:09,519 --> 00:31:16,720
is it uses the the ssa value numbers

791
00:31:13,519 --> 00:31:20,559
the the the index on each ssa value

792
00:31:16,720 --> 00:31:22,320
as the main key for the entire engine

793
00:31:20,559 --> 00:31:23,918
so if you have to match things that

794
00:31:22,320 --> 00:31:27,760
don't have

795
00:31:23,919 --> 00:31:30,000
ssa value indices like you're stuck

796
00:31:27,760 --> 00:31:32,399
you it just the whole infrastructure

797
00:31:30,000 --> 00:31:32,799
just completely falls apart so we can't

798
00:31:32,399 --> 00:31:34,879
use

799
00:31:32,799 --> 00:31:36,799
any of the super optimized matching

800
00:31:34,880 --> 00:31:40,080
engine

801
00:31:36,799 --> 00:31:42,720
that's okay because

802
00:31:40,080 --> 00:31:43,279
while algebraic optimizations might

803
00:31:42,720 --> 00:31:46,240
happen

804
00:31:43,279 --> 00:31:47,120
hundreds of times while compiling a

805
00:31:46,240 --> 00:31:50,399
shader

806
00:31:47,120 --> 00:31:52,158
code generation happens once so if we

807
00:31:50,399 --> 00:31:52,799
can't if we have to use a slower path

808
00:31:52,159 --> 00:31:56,240
for that

809
00:31:52,799 --> 00:32:01,840
it's a thing that happens once i don't

810
00:31:56,240 --> 00:32:01,840
expect that it's going to be a big deal

811
00:32:04,399 --> 00:32:11,918
okay so the output language

812
00:32:08,000 --> 00:32:14,880
um there is a few goals and requirements

813
00:32:11,919 --> 00:32:15,200
as i was implementing this the first was

814
00:32:14,880 --> 00:32:18,559
i

815
00:32:15,200 --> 00:32:21,760
really wanted the thing that

816
00:32:18,559 --> 00:32:25,600
that a human authors to look as much

817
00:32:21,760 --> 00:32:27,919
like the actual gpu assembly as possible

818
00:32:25,600 --> 00:32:29,600
that's being implemented it as some kind

819
00:32:27,919 --> 00:32:32,399
of python objects but we

820
00:32:29,600 --> 00:32:33,439
i wanted to make it so that when you

821
00:32:32,399 --> 00:32:35,279
looked at it

822
00:32:33,440 --> 00:32:36,640
it looked like you were looking at gpu

823
00:32:35,279 --> 00:32:37,519
assembly because the people who are

824
00:32:36,640 --> 00:32:39,360
going to author

825
00:32:37,519 --> 00:32:41,440
these things and try to debug them and

826
00:32:39,360 --> 00:32:43,120
maintain them

827
00:32:41,440 --> 00:32:45,120
are going to be familiar with that right

828
00:32:43,120 --> 00:32:47,840
that's that's the output that you see

829
00:32:45,120 --> 00:32:48,479
when you're debugging shader compilation

830
00:32:47,840 --> 00:32:50,639
issues

831
00:32:48,480 --> 00:32:51,679
it's the format that's in the hardware

832
00:32:50,640 --> 00:32:54,159
documentation

833
00:32:51,679 --> 00:32:55,200
it's what we get when we look at output

834
00:32:54,159 --> 00:32:58,159
from shader db

835
00:32:55,200 --> 00:32:59,120
runs like that's that's the language

836
00:32:58,159 --> 00:33:01,200
that we work with

837
00:32:59,120 --> 00:33:03,279
so let's make this other thing look like

838
00:33:01,200 --> 00:33:03,840
that just to reduce the the cognitive

839
00:33:03,279 --> 00:33:07,039
burden

840
00:33:03,840 --> 00:33:11,439
of of you know having to

841
00:33:07,039 --> 00:33:15,039
um to understand these these patterns

842
00:33:11,440 --> 00:33:18,000
so this can be challenging because

843
00:33:15,039 --> 00:33:19,760
a lot of the instructions and the way

844
00:33:18,000 --> 00:33:22,320
that register accesses

845
00:33:19,760 --> 00:33:24,080
are encoded and a bunch of other things

846
00:33:22,320 --> 00:33:27,360
about the gpu architectures

847
00:33:24,080 --> 00:33:31,678
are weird and complicated so

848
00:33:27,360 --> 00:33:34,479
getting those to look civilized um

849
00:33:31,679 --> 00:33:36,960
as a bunch of python objects is is

850
00:33:34,480 --> 00:33:36,960
tricky

851
00:33:37,039 --> 00:33:41,919
uh so the other thing that's that's nice

852
00:33:40,559 --> 00:33:43,519
is

853
00:33:41,919 --> 00:33:45,279
you really really want to be able to

854
00:33:43,519 --> 00:33:48,080
represent

855
00:33:45,279 --> 00:33:50,080
as much of the weird quirky bits of the

856
00:33:48,080 --> 00:33:52,399
architecture as possible

857
00:33:50,080 --> 00:33:54,000
you don't necessarily have to get every

858
00:33:52,399 --> 00:33:57,360
weird quirk

859
00:33:54,000 --> 00:34:00,399
but it turns out that

860
00:33:57,360 --> 00:34:02,879
those weird corners of how

861
00:34:00,399 --> 00:34:05,518
a particular gpu works those are the

862
00:34:02,880 --> 00:34:08,240
cases where you're most likely to find

863
00:34:05,519 --> 00:34:09,239
opportunities to generate smarter code

864
00:34:08,239 --> 00:34:10,560
right

865
00:34:09,239 --> 00:34:13,599
[Music]

866
00:34:10,560 --> 00:34:15,279
the way that you can access subparts of

867
00:34:13,599 --> 00:34:17,520
registers or

868
00:34:15,280 --> 00:34:18,960
mix types and instructions or do other

869
00:34:17,520 --> 00:34:20,879
kinds of weird things

870
00:34:18,960 --> 00:34:23,599
like that's where you can generate kind

871
00:34:20,879 --> 00:34:25,520
of kind of clever stuff

872
00:34:23,599 --> 00:34:28,079
so it's beneficial if you can just

873
00:34:25,520 --> 00:34:31,440
represent that

874
00:34:28,079 --> 00:34:33,359
so as i said before

875
00:34:31,440 --> 00:34:34,560
in python you have to be able to also

876
00:34:33,359 --> 00:34:37,759
represent these things

877
00:34:34,560 --> 00:34:40,078
as a list or tree or some kind of

878
00:34:37,760 --> 00:34:40,960
collection of just python objects right

879
00:34:40,079 --> 00:34:43,119
that's the

880
00:34:40,960 --> 00:34:44,399
the whole point of the exercise of not

881
00:34:43,119 --> 00:34:49,839
implementing our own

882
00:34:44,399 --> 00:34:49,839
dsl is we can just reuse python

883
00:34:50,560 --> 00:34:57,359
and then in c right this is going to

884
00:34:53,679 --> 00:35:00,079
somehow generate out c code

885
00:34:57,359 --> 00:35:03,839
we want it to be represented as either

886
00:35:00,079 --> 00:35:07,440
data or code or some combination thereof

887
00:35:03,839 --> 00:35:08,000
and i think ideally if we can generate a

888
00:35:07,440 --> 00:35:10,960
set of

889
00:35:08,000 --> 00:35:12,400
compact data tables to represent the

890
00:35:10,960 --> 00:35:16,320
transformations and

891
00:35:12,400 --> 00:35:20,560
the patterns that that's kind of ideal

892
00:35:16,320 --> 00:35:23,920
when the code generator is hand coded

893
00:35:20,560 --> 00:35:27,040
uh the the existing hand coded one

894
00:35:23,920 --> 00:35:28,640
uh the single generator covers all the

895
00:35:27,040 --> 00:35:31,200
different gpu generations

896
00:35:28,640 --> 00:35:31,680
and that's very practical in that case

897
00:35:31,200 --> 00:35:34,720
but

898
00:35:31,680 --> 00:35:38,000
when you are when you have instead of

899
00:35:34,720 --> 00:35:40,879
a handcrafted code generator when you

900
00:35:38,000 --> 00:35:43,119
have a machine description file

901
00:35:40,880 --> 00:35:46,000
essentially that describes

902
00:35:43,119 --> 00:35:47,920
translation of patterns from the ir to a

903
00:35:46,000 --> 00:35:49,760
set of assembly instructions

904
00:35:47,920 --> 00:35:51,520
it's more natural to have a bunch of

905
00:35:49,760 --> 00:35:55,040
separate files that

906
00:35:51,520 --> 00:35:56,800
just cover a single architecture and so

907
00:35:55,040 --> 00:35:58,320
kind of the thing that naturally flows

908
00:35:56,800 --> 00:36:00,240
from that is to come

909
00:35:58,320 --> 00:36:01,839
to compile each of those machine

910
00:36:00,240 --> 00:36:04,399
descriptions into

911
00:36:01,839 --> 00:36:05,200
its own blob of data so instead of

912
00:36:04,400 --> 00:36:07,200
having

913
00:36:05,200 --> 00:36:08,480
one big chunk of c code you're going to

914
00:36:07,200 --> 00:36:11,680
have a bunch

915
00:36:08,480 --> 00:36:15,280
of pieces of data so having those

916
00:36:11,680 --> 00:36:17,520
you know five or six or seven

917
00:36:15,280 --> 00:36:18,640
giant piles of data be as compact as

918
00:36:17,520 --> 00:36:21,440
possible is

919
00:36:18,640 --> 00:36:21,440
is beneficial

920
00:36:22,720 --> 00:36:28,560
so here's how the

921
00:36:26,079 --> 00:36:28,560
um

922
00:36:29,200 --> 00:36:32,879
the output language looks as the the

923
00:36:32,320 --> 00:36:36,079
list of

924
00:36:32,880 --> 00:36:40,880
of python objects this implements the f

925
00:36:36,079 --> 00:36:44,160
sign instruction for 64-bit floats

926
00:36:40,880 --> 00:36:45,040
and i think that this covers i i picked

927
00:36:44,160 --> 00:36:48,560
this one because

928
00:36:45,040 --> 00:36:50,800
it hits almost everything that

929
00:36:48,560 --> 00:36:52,480
uh that it can that the the output

930
00:36:50,800 --> 00:36:54,720
language can support

931
00:36:52,480 --> 00:36:55,520
uh so the first thing it has is it

932
00:36:54,720 --> 00:36:57,839
declares

933
00:36:55,520 --> 00:36:59,040
a a temporary register because in this

934
00:36:57,839 --> 00:37:03,200
sequence of instructions

935
00:36:59,040 --> 00:37:03,200
it's going to generate a temporary value

936
00:37:03,440 --> 00:37:07,280
and then it has an instruction that's

937
00:37:04,960 --> 00:37:08,160
going to load that temporary register

938
00:37:07,280 --> 00:37:11,599
with the

939
00:37:08,160 --> 00:37:12,879
a double precision float immediate zero

940
00:37:11,599 --> 00:37:16,079
value

941
00:37:12,880 --> 00:37:19,359
it's does a comparison that sets the

942
00:37:16,079 --> 00:37:23,119
not zero conditional modifier flag

943
00:37:19,359 --> 00:37:26,560
uh does another move it does an

944
00:37:23,119 --> 00:37:29,119
and that a an in

945
00:37:26,560 --> 00:37:30,078
a bit wise and instruction that only

946
00:37:29,119 --> 00:37:34,079
uses the

947
00:37:30,079 --> 00:37:37,599
upper 32 bits of the 64-bit destination

948
00:37:34,079 --> 00:37:38,960
and the upper 32 bits of the 64-bit

949
00:37:37,599 --> 00:37:41,920
source

950
00:37:38,960 --> 00:37:43,920
and then it has an or instruction that

951
00:37:41,920 --> 00:37:46,480
is predicated so it only

952
00:37:43,920 --> 00:37:49,200
executes if the compare instruction

953
00:37:46,480 --> 00:37:53,920
actually set the not zero flag

954
00:37:49,200 --> 00:37:54,640
so to pretty much anyone who's familiar

955
00:37:53,920 --> 00:37:58,800
with

956
00:37:54,640 --> 00:37:58,799
the assembly language of this gpu

957
00:37:59,040 --> 00:38:02,480
what this is doing looks pretty obvious

958
00:38:01,119 --> 00:38:04,079
right if you don't know it

959
00:38:02,480 --> 00:38:05,839
if you don't know this gpu assembly

960
00:38:04,079 --> 00:38:09,119
language it's just a pilot

961
00:38:05,839 --> 00:38:10,560
but you're probably also not

962
00:38:09,119 --> 00:38:12,240
authoring or maintaining one of these

963
00:38:10,560 --> 00:38:15,279
machine description files

964
00:38:12,240 --> 00:38:19,680
but it covers pretty much everything

965
00:38:15,280 --> 00:38:22,480
and it does it in a compact concise way

966
00:38:19,680 --> 00:38:23,598
and it's just a bunch of python objects

967
00:38:22,480 --> 00:38:26,000
the instruction

968
00:38:23,599 --> 00:38:26,720
generates an object and then the the

969
00:38:26,000 --> 00:38:29,920
predicate

970
00:38:26,720 --> 00:38:33,118
method modifies that that object

971
00:38:29,920 --> 00:38:35,520
it does things in a pretty uh clean way

972
00:38:33,119 --> 00:38:35,520
i think

973
00:38:37,200 --> 00:38:46,799
uh so what i ended up doing with this

974
00:38:41,599 --> 00:38:48,720
is it the the output of when you run the

975
00:38:46,800 --> 00:38:49,520
the python scripts to convert the code

976
00:38:48,720 --> 00:38:51,520
generator

977
00:38:49,520 --> 00:38:53,200
or convert the parameter the machine

978
00:38:51,520 --> 00:38:57,119
description into c

979
00:38:53,200 --> 00:38:57,359
is it they generate a a couple of tables

980
00:38:57,119 --> 00:39:00,720
of

981
00:38:57,359 --> 00:39:03,680
byte code um there's two separate tables

982
00:39:00,720 --> 00:39:05,359
one is a table of immediate values

983
00:39:03,680 --> 00:39:08,078
because those could be

984
00:39:05,359 --> 00:39:08,560
up to 60 64 bits for each immediate

985
00:39:08,079 --> 00:39:11,520
value

986
00:39:08,560 --> 00:39:12,000
and then a sequence of instructions uh

987
00:39:11,520 --> 00:39:15,440
which

988
00:39:12,000 --> 00:39:16,079
each instruction uh is much smaller i

989
00:39:15,440 --> 00:39:18,000
don't remember if

990
00:39:16,079 --> 00:39:20,000
i managed to get it packed into 16 bits

991
00:39:18,000 --> 00:39:23,359
or 32 bits

992
00:39:20,000 --> 00:39:25,200
um and so the the byte code

993
00:39:23,359 --> 00:39:27,040
each instruction in the byte code does a

994
00:39:25,200 --> 00:39:29,200
very simple thing like

995
00:39:27,040 --> 00:39:30,720
declares an op code and then there's a

996
00:39:29,200 --> 00:39:33,200
separate instruction that declares the

997
00:39:30,720 --> 00:39:34,799
destination with all of the

998
00:39:33,200 --> 00:39:36,640
flags and modifiers that can be on a

999
00:39:34,800 --> 00:39:38,079
destination another one for each of the

1000
00:39:36,640 --> 00:39:42,078
sources that also has

1001
00:39:38,079 --> 00:39:45,599
all the flags and the

1002
00:39:42,079 --> 00:39:48,400
the c code that then converts that

1003
00:39:45,599 --> 00:39:49,359
byte code into actual machine code ended

1004
00:39:48,400 --> 00:39:52,800
up only being

1005
00:39:49,359 --> 00:39:56,759
203 lines uh including

1006
00:39:52,800 --> 00:39:59,920
the license header so you know maybe

1007
00:39:56,760 --> 00:40:00,480
150 lines of actual c code so it was

1008
00:39:59,920 --> 00:40:05,920
very

1009
00:40:00,480 --> 00:40:05,920
it's very small and very concise

1010
00:40:07,040 --> 00:40:13,200
um i ended up creating

1011
00:40:10,960 --> 00:40:14,800
six different machine description files

1012
00:40:13,200 --> 00:40:17,279
to cover all the

1013
00:40:14,800 --> 00:40:19,119
uh all the various generations of

1014
00:40:17,280 --> 00:40:22,800
intel's gpu architectures

1015
00:40:19,119 --> 00:40:24,000
and the files were are organized so that

1016
00:40:22,800 --> 00:40:27,280
it's really easy to just

1017
00:40:24,000 --> 00:40:27,280
do a diff of

1018
00:40:27,599 --> 00:40:32,079
one generation's machine description and

1019
00:40:29,920 --> 00:40:34,319
the next generations machine description

1020
00:40:32,079 --> 00:40:37,040
and you get a very compact output of oh

1021
00:40:34,319 --> 00:40:40,560
here's all the stuff that changed from

1022
00:40:37,040 --> 00:40:42,480
gen 7 to gen 8. it also makes it really

1023
00:40:40,560 --> 00:40:45,200
easy when you need to add

1024
00:40:42,480 --> 00:40:46,000
the next generation you just copy the

1025
00:40:45,200 --> 00:40:49,279
old one

1026
00:40:46,000 --> 00:40:50,079
and go to town making edits on it to add

1027
00:40:49,280 --> 00:40:53,040
new features

1028
00:40:50,079 --> 00:40:54,640
or remove things that use features that

1029
00:40:53,040 --> 00:40:55,920
that got removed or instructions that

1030
00:40:54,640 --> 00:40:59,680
don't exist or

1031
00:40:55,920 --> 00:41:02,480
or or whatever once i got the first

1032
00:40:59,680 --> 00:41:03,759
machine description written cranking out

1033
00:41:02,480 --> 00:41:07,440
all the rest of them was

1034
00:41:03,760 --> 00:41:11,359
was pretty easy you know it's always the

1035
00:41:07,440 --> 00:41:11,359
most work is to to make the first one

1036
00:41:12,160 --> 00:41:14,399
so

1037
00:41:16,480 --> 00:41:21,599
remember back a whole bunch of slides

1038
00:41:18,720 --> 00:41:24,720
there there was the eye chart

1039
00:41:21,599 --> 00:41:25,280
so we can now look at what it looks like

1040
00:41:24,720 --> 00:41:27,439
to do

1041
00:41:25,280 --> 00:41:29,440
all of that that same kind of

1042
00:41:27,440 --> 00:41:31,280
optimization but using the machine

1043
00:41:29,440 --> 00:41:34,480
description

1044
00:41:31,280 --> 00:41:36,800
it's still a lot of stuff but

1045
00:41:34,480 --> 00:41:38,160
nowhere near as much i fit it on a slide

1046
00:41:36,800 --> 00:41:40,240
in a ten point font

1047
00:41:38,160 --> 00:41:42,560
instead of a six point and i didn't have

1048
00:41:40,240 --> 00:41:46,160
to delete any of the comments

1049
00:41:42,560 --> 00:41:50,400
um but i want to just look at one of the

1050
00:41:46,160 --> 00:41:53,920
the sub patterns here so this says

1051
00:41:50,400 --> 00:41:56,560
if we have a knot of

1052
00:41:53,920 --> 00:41:59,440
a logical instruction and sources that

1053
00:41:56,560 --> 00:42:01,680
don't have any source modifiers

1054
00:41:59,440 --> 00:42:03,839
we're going to omit a single instruction

1055
00:42:01,680 --> 00:42:06,319
that's

1056
00:42:03,839 --> 00:42:07,040
the other the other logical instructions

1057
00:42:06,319 --> 00:42:10,079
so if we had

1058
00:42:07,040 --> 00:42:12,079
an and we're going to emit an or with

1059
00:42:10,079 --> 00:42:14,079
all the same sources but we're going to

1060
00:42:12,079 --> 00:42:16,640
set the negate flag on this particular

1061
00:42:14,079 --> 00:42:19,680
architecture on a logical instruction

1062
00:42:16,640 --> 00:42:23,680
if you have an a negate source modifier

1063
00:42:19,680 --> 00:42:23,680
it instead does a logical knot

1064
00:42:24,400 --> 00:42:27,440
and then all the rest of this is just to

1065
00:42:26,160 --> 00:42:29,920
handle

1066
00:42:27,440 --> 00:42:30,480
one one sort of annoying quirk that came

1067
00:42:29,920 --> 00:42:35,040
out of this

1068
00:42:30,480 --> 00:42:37,839
is all of the patterns have to match

1069
00:42:35,040 --> 00:42:39,009
for specific bit sizes so there's a lot

1070
00:42:37,839 --> 00:42:42,239
of

1071
00:42:39,010 --> 00:42:42,239
[Music]

1072
00:42:43,040 --> 00:42:46,640
there's a lot of sort of redundant

1073
00:42:45,839 --> 00:42:48,480
patterns that

1074
00:42:46,640 --> 00:42:50,720
ended up existing in in the machine

1075
00:42:48,480 --> 00:42:51,440
descriptions uh so in this case i have

1076
00:42:50,720 --> 00:42:54,720
to generate

1077
00:42:51,440 --> 00:42:55,920
separate patterns for 8 16 32 and 64

1078
00:42:54,720 --> 00:42:59,118
bits

1079
00:42:55,920 --> 00:43:01,440
because i had to know what types to

1080
00:42:59,119 --> 00:43:04,800
decorate on the sources so it was a

1081
00:43:01,440 --> 00:43:04,800
little bit of a hassle

1082
00:43:05,119 --> 00:43:08,400
and so that's why this ends up being a

1083
00:43:06,560 --> 00:43:12,000
little bit bigger than it

1084
00:43:08,400 --> 00:43:14,880
should have to be there there may be

1085
00:43:12,000 --> 00:43:15,920
a solution to that i i don't know uh it

1086
00:43:14,880 --> 00:43:19,680
didn't end up

1087
00:43:15,920 --> 00:43:21,920
affecting that many instructions that i

1088
00:43:19,680 --> 00:43:24,960
wanted to generate so it wasn't

1089
00:43:21,920 --> 00:43:26,480
it wasn't too bad um

1090
00:43:24,960 --> 00:43:30,319
but you know there's there's always

1091
00:43:26,480 --> 00:43:30,319
potentially room room for improvement

1092
00:43:31,599 --> 00:43:37,839
so you know we're talking about

1093
00:43:35,119 --> 00:43:40,560
replacing a pretty major subsystem in

1094
00:43:37,839 --> 00:43:43,520
the compiler and whenever you're

1095
00:43:40,560 --> 00:43:44,400
replacing a big subsystem with something

1096
00:43:43,520 --> 00:43:46,720
new

1097
00:43:44,400 --> 00:43:48,400
uh there's there's one important goal

1098
00:43:46,720 --> 00:43:49,279
that you really should have in mind that

1099
00:43:48,400 --> 00:43:52,240
people don't

1100
00:43:49,280 --> 00:43:53,440
talk about a lot and that's minimizing

1101
00:43:52,240 --> 00:43:56,240
disruption

1102
00:43:53,440 --> 00:43:58,000
right if you're going to replace this if

1103
00:43:56,240 --> 00:44:00,319
you're going to replace

1104
00:43:58,000 --> 00:44:01,520
some existing code that works with a you

1105
00:44:00,319 --> 00:44:03,520
know new

1106
00:44:01,520 --> 00:44:05,119
shiny better version that's going to

1107
00:44:03,520 --> 00:44:07,200
make some things faster

1108
00:44:05,119 --> 00:44:08,319
we'd better make sure that it doesn't

1109
00:44:07,200 --> 00:44:11,439
substantially hurt

1110
00:44:08,319 --> 00:44:11,440
other things right

1111
00:44:12,640 --> 00:44:15,759
and if and if if some things are hurt

1112
00:44:14,720 --> 00:44:17,680
you know

1113
00:44:15,760 --> 00:44:18,960
you have to at least make sure that it's

1114
00:44:17,680 --> 00:44:21,200
it's minimal damage

1115
00:44:18,960 --> 00:44:23,200
and that the the pros dramatically

1116
00:44:21,200 --> 00:44:26,560
outweigh the cons

1117
00:44:23,200 --> 00:44:28,879
so when i ran

1118
00:44:26,560 --> 00:44:29,920
just the straight machine descriptions

1119
00:44:28,880 --> 00:44:31,680
as as i

1120
00:44:29,920 --> 00:44:33,760
authored them without adding any new

1121
00:44:31,680 --> 00:44:36,078
optimizations

1122
00:44:33,760 --> 00:44:36,800
across our shader database which has

1123
00:44:36,079 --> 00:44:40,400
about

1124
00:44:36,800 --> 00:44:42,160
50 000 shaders from real applications

1125
00:44:40,400 --> 00:44:43,520
there was no change in the generated

1126
00:44:42,160 --> 00:44:47,359
code

1127
00:44:43,520 --> 00:44:52,079
so that that felt pretty cool um

1128
00:44:47,359 --> 00:44:54,960
it i ended up the the

1129
00:44:52,079 --> 00:44:56,160
impact on the mesa source was about 1400

1130
00:44:54,960 --> 00:45:00,160
lines of deletions

1131
00:44:56,160 --> 00:45:02,240
and 4 800 assertion insertions

1132
00:45:00,160 --> 00:45:04,879
and a huge chunk of that was just the

1133
00:45:02,240 --> 00:45:06,720
machine description files

1134
00:45:04,880 --> 00:45:11,119
because there were six of them and each

1135
00:45:06,720 --> 00:45:11,118
one averaged about 500 lines

1136
00:45:12,160 --> 00:45:15,920
so there's there's some debate about

1137
00:45:14,160 --> 00:45:18,720
whether or not we should

1138
00:45:15,920 --> 00:45:19,839
extract common bits from the machine

1139
00:45:18,720 --> 00:45:22,399
description files

1140
00:45:19,839 --> 00:45:26,400
and have them stored in a separate file

1141
00:45:22,400 --> 00:45:26,400
that then basically just gets included

1142
00:45:26,560 --> 00:45:29,599
i think it's a it's better keeping them

1143
00:45:28,720 --> 00:45:31,279
standalone

1144
00:45:29,599 --> 00:45:32,720
and where each one is entirely

1145
00:45:31,280 --> 00:45:36,400
independent because

1146
00:45:32,720 --> 00:45:40,879
as the architectures change

1147
00:45:36,400 --> 00:45:43,920
less and less is truly shared across

1148
00:45:40,880 --> 00:45:44,160
a large chunk of the architectures so it

1149
00:45:43,920 --> 00:45:46,640
kind

1150
00:45:44,160 --> 00:45:48,399
of kind of has diminishing returns as as

1151
00:45:46,640 --> 00:45:52,319
time goes on

1152
00:45:48,400 --> 00:45:55,760
um but i don't know it's it's it's still

1153
00:45:52,319 --> 00:45:58,240
a debate to be had uh

1154
00:45:55,760 --> 00:46:00,160
so and then i you know towards the end

1155
00:45:58,240 --> 00:46:03,520
of the project i added a couple

1156
00:46:00,160 --> 00:46:05,920
really simple optimizations that

1157
00:46:03,520 --> 00:46:06,880
would have been a hassle to add in the

1158
00:46:05,920 --> 00:46:10,079
hand coded

1159
00:46:06,880 --> 00:46:12,000
code generator and those helped a few

1160
00:46:10,079 --> 00:46:15,119
hundred shaders by

1161
00:46:12,000 --> 00:46:18,160
a couple percent um but at this point

1162
00:46:15,119 --> 00:46:18,960
almost no work has been done on on

1163
00:46:18,160 --> 00:46:21,759
finding

1164
00:46:18,960 --> 00:46:23,440
patterns you know new new optimization

1165
00:46:21,760 --> 00:46:26,400
patterns and and clever tricks

1166
00:46:23,440 --> 00:46:28,400
um but i have a big list of things that

1167
00:46:26,400 --> 00:46:30,560
i want to try uh

1168
00:46:28,400 --> 00:46:31,760
and i i know that there's just from

1169
00:46:30,560 --> 00:46:34,400
having looked at

1170
00:46:31,760 --> 00:46:36,480
lots of shader assembly over the years i

1171
00:46:34,400 --> 00:46:37,680
know there's a lot of stuff that we can

1172
00:46:36,480 --> 00:46:41,520
do

1173
00:46:37,680 --> 00:46:43,680
um so future work well wait no

1174
00:46:41,520 --> 00:46:44,800
no finishing current work uh there's

1175
00:46:43,680 --> 00:46:46,399
still

1176
00:46:44,800 --> 00:46:47,599
there's still a couple of the patches

1177
00:46:46,400 --> 00:46:48,400
that are that are marked work in

1178
00:46:47,599 --> 00:46:51,599
progress

1179
00:46:48,400 --> 00:46:53,119
uh the big one is is

1180
00:46:51,599 --> 00:46:54,800
like i had mentioned before about

1181
00:46:53,119 --> 00:46:56,800
deciding what we want to do about the

1182
00:46:54,800 --> 00:47:00,240
the machine description files

1183
00:46:56,800 --> 00:47:04,560
keeping them stand alone or or trying to

1184
00:47:00,240 --> 00:47:04,560
extract out common parts

1185
00:47:05,119 --> 00:47:08,720
and there's a couple of patches in in

1186
00:47:07,200 --> 00:47:10,399
the mr that

1187
00:47:08,720 --> 00:47:13,118
show what some of that would look like

1188
00:47:10,400 --> 00:47:16,560
if we if we pulled out the common parts

1189
00:47:13,119 --> 00:47:19,520
um the other thing is there's

1190
00:47:16,560 --> 00:47:20,078
still a couple of the patches that i

1191
00:47:19,520 --> 00:47:21,920
think

1192
00:47:20,079 --> 00:47:23,280
could really benefit from some unit

1193
00:47:21,920 --> 00:47:25,599
tests uh

1194
00:47:23,280 --> 00:47:26,480
in particular the one that enables

1195
00:47:25,599 --> 00:47:30,640
non-ssa

1196
00:47:26,480 --> 00:47:32,480
sources uh i i think that that's safe

1197
00:47:30,640 --> 00:47:34,319
but i would like to see

1198
00:47:32,480 --> 00:47:35,920
i would like to spend some time trying

1199
00:47:34,319 --> 00:47:38,160
to come up with some some counter

1200
00:47:35,920 --> 00:47:42,640
examples and try to encode those as

1201
00:47:38,160 --> 00:47:42,640
unit tests um

1202
00:47:44,960 --> 00:47:48,480
so i'm gonna i think i'm running out of

1203
00:47:46,880 --> 00:47:50,480
time so i'm gonna try to go through the

1204
00:47:48,480 --> 00:47:51,170
the actual future work kind of kind of

1205
00:47:50,480 --> 00:47:52,720
quickly

1206
00:47:51,170 --> 00:47:55,760
[Music]

1207
00:47:52,720 --> 00:47:59,839
so one thing some

1208
00:47:55,760 --> 00:48:02,160
instructions can't have source modifiers

1209
00:47:59,839 --> 00:48:03,520
some instructions can't have immediate

1210
00:48:02,160 --> 00:48:04,960
values as sources

1211
00:48:03,520 --> 00:48:06,880
and there's a handful of other

1212
00:48:04,960 --> 00:48:09,760
limitations like that

1213
00:48:06,880 --> 00:48:11,440
that are currently handled by adding a

1214
00:48:09,760 --> 00:48:13,599
bunch of extra patterns

1215
00:48:11,440 --> 00:48:15,520
and putting in a bunch of complex stuff

1216
00:48:13,599 --> 00:48:19,359
so for example

1217
00:48:15,520 --> 00:48:21,520
on the the intel gpus where

1218
00:48:19,359 --> 00:48:23,520
the negation source modifier on a

1219
00:48:21,520 --> 00:48:26,559
logical instruction

1220
00:48:23,520 --> 00:48:29,200
means take the logical knot we have to

1221
00:48:26,559 --> 00:48:31,040
if you have a source that that has the

1222
00:48:29,200 --> 00:48:31,520
negation source modifier on it we have

1223
00:48:31,040 --> 00:48:34,000
to emit

1224
00:48:31,520 --> 00:48:34,960
an extra move instruction to sort of

1225
00:48:34,000 --> 00:48:37,680
resolve that

1226
00:48:34,960 --> 00:48:39,760
negation and i think that it would be

1227
00:48:37,680 --> 00:48:44,078
better to encode that a different way

1228
00:48:39,760 --> 00:48:46,000
by having a set of patterns that say

1229
00:48:44,079 --> 00:48:48,240
if you have an immediate value you can

1230
00:48:46,000 --> 00:48:50,480
convert that into something else by

1231
00:48:48,240 --> 00:48:52,319
having a move or if you have source

1232
00:48:50,480 --> 00:48:54,400
modifiers you can eliminate those source

1233
00:48:52,319 --> 00:48:56,400
modifiers by adding a move

1234
00:48:54,400 --> 00:48:58,800
and then simply decorating some of those

1235
00:48:56,400 --> 00:49:02,240
patterns as

1236
00:48:58,800 --> 00:49:04,160
can't be an immediate or can't be

1237
00:49:02,240 --> 00:49:06,319
can't have a source modifier and then

1238
00:49:04,160 --> 00:49:09,839
having the pattern matching engine

1239
00:49:06,319 --> 00:49:12,240
first match the resolve kind of pattern

1240
00:49:09,839 --> 00:49:13,839
and then match the other pattern i think

1241
00:49:12,240 --> 00:49:15,598
that would end up making things a lot

1242
00:49:13,839 --> 00:49:18,799
cleaner

1243
00:49:15,599 --> 00:49:19,839
and would help support some of the some

1244
00:49:18,800 --> 00:49:22,480
of the other

1245
00:49:19,839 --> 00:49:24,720
future work that i think needs to be

1246
00:49:22,480 --> 00:49:24,720
done

1247
00:49:24,780 --> 00:49:29,280
[Music]

1248
00:49:26,079 --> 00:49:32,640
so integrate code generation with cse

1249
00:49:29,280 --> 00:49:34,960
so as you're emitting instructions do

1250
00:49:32,640 --> 00:49:36,640
the common sub expression elimination at

1251
00:49:34,960 --> 00:49:39,520
the same time so you don't

1252
00:49:36,640 --> 00:49:41,680
re-emit the same instruction in each

1253
00:49:39,520 --> 00:49:43,440
basic block

1254
00:49:41,680 --> 00:49:47,279
right now we have a separate cse pass

1255
00:49:43,440 --> 00:49:49,200
that will just going and clean that up

1256
00:49:47,280 --> 00:49:50,800
but we could just integrate it directly

1257
00:49:49,200 --> 00:49:54,000
with the code generation

1258
00:49:50,800 --> 00:49:58,079
that by itself doesn't buy you very much

1259
00:49:54,000 --> 00:50:01,280
but it does make it much easier to do uh

1260
00:49:58,079 --> 00:50:02,880
dynamic uh cost estimation

1261
00:50:01,280 --> 00:50:05,040
where if you have a sequence that's

1262
00:50:02,880 --> 00:50:06,800
going to match and you know what this

1263
00:50:05,040 --> 00:50:08,558
output pattern is

1264
00:50:06,800 --> 00:50:09,920
you want to be able to estimate what the

1265
00:50:08,559 --> 00:50:11,440
cost is going to be

1266
00:50:09,920 --> 00:50:13,359
if you know that well i don't need to

1267
00:50:11,440 --> 00:50:15,599
omit these three instructions because

1268
00:50:13,359 --> 00:50:17,598
they already exist in this basic block i

1269
00:50:15,599 --> 00:50:18,960
can just reuse those values

1270
00:50:17,599 --> 00:50:21,119
that's going to give you a completely

1271
00:50:18,960 --> 00:50:22,079
different cost estimate than if you had

1272
00:50:21,119 --> 00:50:25,359
to emit

1273
00:50:22,079 --> 00:50:29,119
all the instructions in the block

1274
00:50:25,359 --> 00:50:31,598
and it's really hard uh the reason

1275
00:50:29,119 --> 00:50:33,200
that i specifically caught say dynamic

1276
00:50:31,599 --> 00:50:35,119
cost estimation

1277
00:50:33,200 --> 00:50:37,040
a lot of the existing research about

1278
00:50:35,119 --> 00:50:40,640
code generator generators used

1279
00:50:37,040 --> 00:50:43,119
static cost estimates but

1280
00:50:40,640 --> 00:50:44,480
gpus are complicated like it's really

1281
00:50:43,119 --> 00:50:46,160
hard if you have more than

1282
00:50:44,480 --> 00:50:48,160
like two instructions in your

1283
00:50:46,160 --> 00:50:51,440
replacement pattern it's

1284
00:50:48,160 --> 00:50:52,480
hard without any context to be able to

1285
00:50:51,440 --> 00:50:55,119
estimate

1286
00:50:52,480 --> 00:50:56,079
how much those that's actually going to

1287
00:50:55,119 --> 00:50:59,119
cost

1288
00:50:56,079 --> 00:51:00,720
so the the cost estimation function it

1289
00:50:59,119 --> 00:51:04,000
has to be

1290
00:51:00,720 --> 00:51:05,040
dynamic or it's just lies and at that

1291
00:51:04,000 --> 00:51:08,160
point like why

1292
00:51:05,040 --> 00:51:10,319
why are you doing it um

1293
00:51:08,160 --> 00:51:11,279
and then you know finally we get to

1294
00:51:10,319 --> 00:51:14,079
great success

1295
00:51:11,280 --> 00:51:15,920
of we have cost estimates so then we can

1296
00:51:14,079 --> 00:51:17,359
integrate it with something like noltus

1297
00:51:15,920 --> 00:51:20,160
or some other

1298
00:51:17,359 --> 00:51:22,160
burs or some some existing uh

1299
00:51:20,160 --> 00:51:25,759
optimization scheme that tries to pick

1300
00:51:22,160 --> 00:51:30,240
the best sequence of instructions

1301
00:51:25,760 --> 00:51:32,720
for a given set of of expressions

1302
00:51:30,240 --> 00:51:34,160
uh so then i've got a bunch of links to

1303
00:51:32,720 --> 00:51:37,520
all the the mrs

1304
00:51:34,160 --> 00:51:39,759
and uh the the work at red hat that i

1305
00:51:37,520 --> 00:51:42,559
mentioned

1306
00:51:39,760 --> 00:51:43,200
uh yeah there's an extra mr in there

1307
00:51:42,559 --> 00:51:45,760
that can

1308
00:51:43,200 --> 00:51:47,118
contain some uh prerequisite patches for

1309
00:51:45,760 --> 00:51:50,720
the actual code generator

1310
00:51:47,119 --> 00:51:54,319
generator uh uh

1311
00:51:50,720 --> 00:51:58,078
and then the yeah eric's very old noltus

1312
00:51:54,319 --> 00:51:58,880
patch series and i think i finished

1313
00:51:58,079 --> 00:52:02,240
within time

1314
00:51:58,880 --> 00:52:02,240
yay are any questions

1315
00:52:02,839 --> 00:52:05,839
yes architecture in such a way that you

1316
00:52:05,440 --> 00:52:08,640
could

1317
00:52:05,839 --> 00:52:09,359
instead of having like common code all

1318
00:52:08,640 --> 00:52:11,759
of them

1319
00:52:09,359 --> 00:52:13,279
instead have it for like an older

1320
00:52:11,760 --> 00:52:15,119
version and then like

1321
00:52:13,280 --> 00:52:16,880
have a newer file and only the things

1322
00:52:15,119 --> 00:52:20,720
that i've changed in that version

1323
00:52:16,880 --> 00:52:23,280
being right so what i

1324
00:52:20,720 --> 00:52:24,399
what i did in there there is a patch in

1325
00:52:23,280 --> 00:52:27,520
the the mr

1326
00:52:24,400 --> 00:52:29,440
that basically uh

1327
00:52:27,520 --> 00:52:30,839
okay so the question was is there a

1328
00:52:29,440 --> 00:52:35,040
different way to

1329
00:52:30,839 --> 00:52:36,319
architect the the machine descriptions

1330
00:52:35,040 --> 00:52:39,200
so that

1331
00:52:36,319 --> 00:52:39,680
you basically have common stuff and then

1332
00:52:39,200 --> 00:52:41,520
in

1333
00:52:39,680 --> 00:52:44,319
newer in the machine descriptions for

1334
00:52:41,520 --> 00:52:47,920
newer architectures you just override

1335
00:52:44,319 --> 00:52:51,279
other things so what i did is

1336
00:52:47,920 --> 00:52:53,680
common parts that i pulled out

1337
00:52:51,280 --> 00:52:54,800
i would pull out a common part and i

1338
00:52:53,680 --> 00:52:58,399
would make a

1339
00:52:54,800 --> 00:53:00,079
separate uh python list for the common

1340
00:52:58,400 --> 00:53:02,960
stuff and i would give that list some

1341
00:53:00,079 --> 00:53:04,559
name and then in each generation that

1342
00:53:02,960 --> 00:53:06,800
was going to reuse that list

1343
00:53:04,559 --> 00:53:08,400
i would just concatenate it in with the

1344
00:53:06,800 --> 00:53:12,000
other list so i would have

1345
00:53:08,400 --> 00:53:14,400
sort of a concatenation of of lists to

1346
00:53:12,000 --> 00:53:15,359
pull in the shared the things that could

1347
00:53:14,400 --> 00:53:17,839
be shared and then

1348
00:53:15,359 --> 00:53:19,680
stuff that couldn't be shared uh was

1349
00:53:17,839 --> 00:53:21,040
just listed out in each machine machine

1350
00:53:19,680 --> 00:53:23,118
description

1351
00:53:21,040 --> 00:53:25,520
that seemed like the cleanest way to do

1352
00:53:23,119 --> 00:53:28,640
it um

1353
00:53:25,520 --> 00:53:30,160
as just python objects as just a list of

1354
00:53:28,640 --> 00:53:32,000
python objects

1355
00:53:30,160 --> 00:53:33,279
i don't think that there was a good way

1356
00:53:32,000 --> 00:53:36,000
to

1357
00:53:33,280 --> 00:53:37,760
override things that were in the list

1358
00:53:36,000 --> 00:53:40,240
but i'm i'm definitely not

1359
00:53:37,760 --> 00:53:40,800
i'm not the python ninja on the team so

1360
00:53:40,240 --> 00:53:43,839
they're there

1361
00:53:40,800 --> 00:53:45,599
there may be a way do i have time for

1362
00:53:43,839 --> 00:53:49,920
another

1363
00:53:45,599 --> 00:53:49,920
one minute left anyone yes in the

1364
00:53:54,960 --> 00:53:59,200
your input back and those sources might

1365
00:53:57,520 --> 00:54:01,200
appear on different instructions in your

1366
00:53:59,200 --> 00:54:01,839
pattern which might be far apart in the

1367
00:54:01,200 --> 00:54:03,359
code

1368
00:54:01,839 --> 00:54:06,319
maybe there isn't even a point in the

1369
00:54:03,359 --> 00:54:09,440
program where both of those sources

1370
00:54:06,319 --> 00:54:12,319
actually have the value that you want

1371
00:54:09,440 --> 00:54:12,319
at the same time

1372
00:54:17,520 --> 00:54:25,839
so the question is if you have multiple

1373
00:54:20,640 --> 00:54:25,839
different non-ssa sources

1374
00:54:25,920 --> 00:54:29,200
that the value that you want if you have

1375
00:54:28,880 --> 00:54:31,520
a

1376
00:54:29,200 --> 00:54:33,520
if you have a large enough tree and you

1377
00:54:31,520 --> 00:54:35,520
have multiple of those sources that

1378
00:54:33,520 --> 00:54:37,200
there might not be a point in the

1379
00:54:35,520 --> 00:54:40,960
program flow where

1380
00:54:37,200 --> 00:54:40,960
both those values actually exist

1381
00:54:42,480 --> 00:54:45,920
maybe that's true and that and that's

1382
00:54:44,480 --> 00:54:47,440
why i wanna i mean that's one of the

1383
00:54:45,920 --> 00:54:48,799
things that i want to sit down and spend

1384
00:54:47,440 --> 00:54:52,720
more time and try to

1385
00:54:48,799 --> 00:54:58,079
like find some actual concrete examples

1386
00:54:52,720 --> 00:54:58,078
of sort of counter examples um

1387
00:55:00,400 --> 00:55:04,000
there were a couple other i mean the

1388
00:55:02,240 --> 00:55:07,439
thing that bothered me about this

1389
00:55:04,000 --> 00:55:07,920
is you know i i implemented that bit and

1390
00:55:07,440 --> 00:55:09,599
i had

1391
00:55:07,920 --> 00:55:12,000
that that nagging voice in the back of

1392
00:55:09,599 --> 00:55:13,760
my head of are you sure that that's safe

1393
00:55:12,000 --> 00:55:15,520
it seems like there's a bunch of holes

1394
00:55:13,760 --> 00:55:17,599
here you might fall in

1395
00:55:15,520 --> 00:55:18,799
like all right well i have this giant

1396
00:55:17,599 --> 00:55:20,960
database of

1397
00:55:18,799 --> 00:55:22,240
thousands of shaders and some of them

1398
00:55:20,960 --> 00:55:23,760
are really huge

1399
00:55:22,240 --> 00:55:26,479
like there's like there's some uh

1400
00:55:23,760 --> 00:55:28,000
compute shaders and some games that are

1401
00:55:26,480 --> 00:55:29,599
end up generating like 10 000

1402
00:55:28,000 --> 00:55:32,960
instructions

1403
00:55:29,599 --> 00:55:36,400
and they all just compiled and didn't

1404
00:55:32,960 --> 00:55:39,200
explode so i can't find a real workload

1405
00:55:36,400 --> 00:55:41,760
that disproves it so it's hard to

1406
00:55:39,200 --> 00:55:43,839
yeah and i'm being i'm being told that

1407
00:55:41,760 --> 00:55:49,839
my time is up so i'm gonna stop so i

1408
00:55:43,839 --> 00:55:49,839
don't get in trouble

1409
00:55:57,440 --> 00:55:59,520
you

