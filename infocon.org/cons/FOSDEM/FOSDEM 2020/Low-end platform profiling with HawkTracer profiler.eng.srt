1
00:00:04,960 --> 00:00:08,240
uh hi everybody

2
00:00:06,160 --> 00:00:10,480
uh thanks for coming i know for some of

3
00:00:08,240 --> 00:00:12,960
you it's quite early yet

4
00:00:10,480 --> 00:00:13,679
my name is martin i work for prime video

5
00:00:12,960 --> 00:00:15,200
and

6
00:00:13,679 --> 00:00:17,119
this talk will be about the profiler

7
00:00:15,200 --> 00:00:20,160
that we did

8
00:00:17,119 --> 00:00:21,680
to fix performance issues

9
00:00:20,160 --> 00:00:23,359
in prime video app that's running on

10
00:00:21,680 --> 00:00:25,359
living room devices

11
00:00:23,359 --> 00:00:27,119
and i'm not going to talk a lot about

12
00:00:25,359 --> 00:00:29,119
the internals of the profiler i'd rather

13
00:00:27,119 --> 00:00:31,359
focus on how to use it how you can use

14
00:00:29,119 --> 00:00:33,120
it and adapt to your project

15
00:00:31,359 --> 00:00:35,840
but if you want to know more about

16
00:00:33,120 --> 00:00:38,160
internals i'll be here around

17
00:00:35,840 --> 00:00:39,360
till the end of the day so you can just

18
00:00:38,160 --> 00:00:42,398
speak to me

19
00:00:39,360 --> 00:00:43,519
anytime you want so i'll start with

20
00:00:42,399 --> 00:00:45,200
explaining why

21
00:00:43,520 --> 00:00:46,640
we actually started the new profiler

22
00:00:45,200 --> 00:00:47,440
because as you might know there's quite

23
00:00:46,640 --> 00:00:49,520
a lot of them

24
00:00:47,440 --> 00:00:50,960
on the market already as ltt and g f

25
00:00:49,520 --> 00:00:54,719
trays uf trace

26
00:00:50,960 --> 00:00:56,640
s trace paraffins a lot of other

27
00:00:54,719 --> 00:00:58,480
the thing is that the development

28
00:00:56,640 --> 00:01:01,039
environment that we had to work in

29
00:00:58,480 --> 00:01:02,398
was quite different than what uh you

30
00:01:01,039 --> 00:01:05,519
might get used to

31
00:01:02,399 --> 00:01:06,799
so we've been doing applications on uh

32
00:01:05,519 --> 00:01:09,520
that's running on the living room

33
00:01:06,799 --> 00:01:11,680
devices such as game consoles

34
00:01:09,520 --> 00:01:13,200
smart tvs streaming sticks and some of

35
00:01:11,680 --> 00:01:14,720
the platforms are very friendly for

36
00:01:13,200 --> 00:01:15,600
developers like game consoles they are

37
00:01:14,720 --> 00:01:18,320
amazing

38
00:01:15,600 --> 00:01:20,240
they provide lots of tools uh debugging

39
00:01:18,320 --> 00:01:22,158
utilities and so on but

40
00:01:20,240 --> 00:01:23,920
smart tvs are not that friendly for

41
00:01:22,159 --> 00:01:26,320
developers so very often

42
00:01:23,920 --> 00:01:28,080
all we have is compiler and we can't

43
00:01:26,320 --> 00:01:30,240
really deploy the

44
00:01:28,080 --> 00:01:31,520
deploy any tool to that to that device

45
00:01:30,240 --> 00:01:33,600
it's very close so

46
00:01:31,520 --> 00:01:35,439
all we can do is basically deploy the

47
00:01:33,600 --> 00:01:38,640
single app that's our

48
00:01:35,439 --> 00:01:40,399
uh our prime video app and that's it so

49
00:01:38,640 --> 00:01:44,000
we can't for example deploy

50
00:01:40,400 --> 00:01:46,640
as trace or lt tng we can't

51
00:01:44,000 --> 00:01:48,560
deploy some kernel modules and so on so

52
00:01:46,640 --> 00:01:51,040
it's very very limited environment

53
00:01:48,560 --> 00:01:53,280
and also uh our application the

54
00:01:51,040 --> 00:01:55,759
primeview application is

55
00:01:53,280 --> 00:01:57,439
is built using uh three different

56
00:01:55,759 --> 00:01:58,079
languages so we have a native layer

57
00:01:57,439 --> 00:02:00,960
which is a c

58
00:01:58,079 --> 00:02:01,759
plus plus and then that native layer

59
00:02:00,960 --> 00:02:05,119
exposes

60
00:02:01,759 --> 00:02:06,960
uh two uh scripted engines

61
00:02:05,119 --> 00:02:08,239
one for lua and one for javascript and

62
00:02:06,960 --> 00:02:09,919
we run them

63
00:02:08,239 --> 00:02:11,599
at the same time so they're basically

64
00:02:09,919 --> 00:02:13,440
three different languages

65
00:02:11,599 --> 00:02:15,920
and because those platforms some of

66
00:02:13,440 --> 00:02:17,680
those platforms are

67
00:02:15,920 --> 00:02:19,839
very low and in terms of the cpu and

68
00:02:17,680 --> 00:02:22,160
memory

69
00:02:19,840 --> 00:02:23,840
we had quite a few performance issues

70
00:02:22,160 --> 00:02:25,760
especially on the cheapers

71
00:02:23,840 --> 00:02:27,360
on the cheaper platforms and we wanted

72
00:02:25,760 --> 00:02:30,399
to debug it but as i said

73
00:02:27,360 --> 00:02:33,040
there was no much tools for for

74
00:02:30,400 --> 00:02:34,640
debugging there were some tools but they

75
00:02:33,040 --> 00:02:36,480
didn't really meet our requirements so

76
00:02:34,640 --> 00:02:37,839
we said okay maybe we can just quickly

77
00:02:36,480 --> 00:02:40,720
prototype something

78
00:02:37,840 --> 00:02:41,120
and we see if that works and yeah as you

79
00:02:40,720 --> 00:02:42,640
see

80
00:02:41,120 --> 00:02:45,120
this presentation is about the profiler

81
00:02:42,640 --> 00:02:47,200
so it actually worked

82
00:02:45,120 --> 00:02:49,680
so we come up with a list of features

83
00:02:47,200 --> 00:02:53,200
that we want to have from our profiler

84
00:02:49,680 --> 00:02:55,360
this is just a short list uh but

85
00:02:53,200 --> 00:02:57,280
there's a quite a few more features i

86
00:02:55,360 --> 00:02:59,200
just listed the more important

87
00:02:57,280 --> 00:03:01,360
so it's user space and instrumentation

88
00:02:59,200 --> 00:03:02,879
based we basically don't have access to

89
00:03:01,360 --> 00:03:05,519
kernel

90
00:03:02,879 --> 00:03:06,560
by any means so user space for us was

91
00:03:05,519 --> 00:03:08,000
the only option

92
00:03:06,560 --> 00:03:10,000
instrumentation based we can't really

93
00:03:08,000 --> 00:03:11,040
deploy a second daemon that i don't know

94
00:03:10,000 --> 00:03:13,680
for example

95
00:03:11,040 --> 00:03:15,519
checks traces every second or so so

96
00:03:13,680 --> 00:03:17,360
everything had to be built in

97
00:03:15,519 --> 00:03:19,200
into the application uh since our

98
00:03:17,360 --> 00:03:22,159
application is written in c

99
00:03:19,200 --> 00:03:24,238
and javascript and and lua we decided

100
00:03:22,159 --> 00:03:26,879
that we gonna write it in c plus plus

101
00:03:24,239 --> 00:03:28,159
or c but it should be available for

102
00:03:26,879 --> 00:03:31,518
those languages as well

103
00:03:28,159 --> 00:03:34,560
in somehow by providing a bindings layer

104
00:03:31,519 --> 00:03:36,400
so on um also

105
00:03:34,560 --> 00:03:37,920
because we port two different platforms

106
00:03:36,400 --> 00:03:39,360
those platforms are very different to

107
00:03:37,920 --> 00:03:41,280
each other some of them have different

108
00:03:39,360 --> 00:03:44,640
operating systems different

109
00:03:41,280 --> 00:03:46,959
cpus even different ndns so

110
00:03:44,640 --> 00:03:48,559
it should be easy to port those uh this

111
00:03:46,959 --> 00:03:50,400
profiler to all the platforms that we

112
00:03:48,560 --> 00:03:52,959
support by prime video

113
00:03:50,400 --> 00:03:54,560
uh low overhead i think this is uh

114
00:03:52,959 --> 00:03:55,920
something that all the profilers are

115
00:03:54,560 --> 00:03:57,760
trying to achieve

116
00:03:55,920 --> 00:04:00,079
uh we wanted to measure timings because

117
00:03:57,760 --> 00:04:01,760
that's what usually people think of

118
00:04:00,080 --> 00:04:03,120
when they do profiling how long does it

119
00:04:01,760 --> 00:04:05,359
take to execute the function

120
00:04:03,120 --> 00:04:06,239
but apart from that we also wanted to

121
00:04:05,360 --> 00:04:08,720
measure other

122
00:04:06,239 --> 00:04:09,280
metrics like memory usage cpu usage uh

123
00:04:08,720 --> 00:04:13,040
how many

124
00:04:09,280 --> 00:04:14,720
http calls we've done and so on and

125
00:04:13,040 --> 00:04:17,279
the other thing that we wanted to

126
00:04:14,720 --> 00:04:18,720
achieve we we had a group of people who

127
00:04:17,279 --> 00:04:19,679
were very into performance and were

128
00:04:18,720 --> 00:04:21,440
responsible for

129
00:04:19,680 --> 00:04:23,600
fixing performance issues but we wanted

130
00:04:21,440 --> 00:04:26,160
also other developers to

131
00:04:23,600 --> 00:04:26,720
to use profiling tools on a daily basis

132
00:04:26,160 --> 00:04:28,160
so

133
00:04:26,720 --> 00:04:29,759
while they're writing the code they can

134
00:04:28,160 --> 00:04:31,600
focus on performance as well so we don't

135
00:04:29,759 --> 00:04:34,479
have to do the job afterwards so

136
00:04:31,600 --> 00:04:35,360
we wanted to provide uh consistent user

137
00:04:34,479 --> 00:04:38,479
experience across

138
00:04:35,360 --> 00:04:41,120
different platforms so no matter what

139
00:04:38,479 --> 00:04:42,560
uh profi uh what application what device

140
00:04:41,120 --> 00:04:43,440
you're developing on whether this is a

141
00:04:42,560 --> 00:04:46,880
streaming stick

142
00:04:43,440 --> 00:04:48,719
web uh game console smart tv

143
00:04:46,880 --> 00:04:51,040
you always have the same tool so it's

144
00:04:48,720 --> 00:04:52,880
easier they just need to learn one tool

145
00:04:51,040 --> 00:04:55,040
and they can use it

146
00:04:52,880 --> 00:04:57,120
for all the different projects so that

147
00:04:55,040 --> 00:04:59,919
was a list of features and

148
00:04:57,120 --> 00:05:00,400
we come up with a very simple high-level

149
00:04:59,919 --> 00:05:01,919
design

150
00:05:00,400 --> 00:05:04,159
we have a profile device that's running

151
00:05:01,919 --> 00:05:06,240
the application we have a

152
00:05:04,160 --> 00:05:07,199
how to reset library attached to that to

153
00:05:06,240 --> 00:05:11,039
the application

154
00:05:07,199 --> 00:05:13,280
that generates a binary stream of events

155
00:05:11,039 --> 00:05:14,800
we call it htdumpstream and then we have

156
00:05:13,280 --> 00:05:16,239
a client which is on the developer

157
00:05:14,800 --> 00:05:18,800
desktop

158
00:05:16,240 --> 00:05:20,080
that's converting this byte stream to

159
00:05:18,800 --> 00:05:22,240
some human readable

160
00:05:20,080 --> 00:05:24,960
form like for example chrome trace

161
00:05:22,240 --> 00:05:26,160
format flame graphs or you can i'll show

162
00:05:24,960 --> 00:05:28,320
you later in the demo

163
00:05:26,160 --> 00:05:30,160
you can build your own uh you can build

164
00:05:28,320 --> 00:05:33,360
your own client very easily

165
00:05:30,160 --> 00:05:34,000
to do some other visualizations that our

166
00:05:33,360 --> 00:05:38,000
client

167
00:05:34,000 --> 00:05:38,639
doesn't provide this is a bit more uh

168
00:05:38,000 --> 00:05:42,560
detailed

169
00:05:38,639 --> 00:05:45,759
diagram so there's an app this app

170
00:05:42,560 --> 00:05:48,320
has a hook tracer library linked

171
00:05:45,759 --> 00:05:50,720
and the whole tracer has a timeline a

172
00:05:48,320 --> 00:05:52,960
timeline is essentially a buffer

173
00:05:50,720 --> 00:05:54,639
and application pushes events to this

174
00:05:52,960 --> 00:05:56,799
buffer this buffer uh

175
00:05:54,639 --> 00:05:58,319
these events are serialized and then

176
00:05:56,800 --> 00:06:00,080
once the buffer is full

177
00:05:58,319 --> 00:06:02,080
uh we push it to a listener and the

178
00:06:00,080 --> 00:06:02,719
listener could is basically a function

179
00:06:02,080 --> 00:06:04,560
callback

180
00:06:02,720 --> 00:06:06,080
uh so that then the listener decides

181
00:06:04,560 --> 00:06:07,919
what to do and we

182
00:06:06,080 --> 00:06:10,240
hold tracer by default provides two

183
00:06:07,919 --> 00:06:12,159
listeners it's either it stores the

184
00:06:10,240 --> 00:06:13,360
the stream to a file or it can send it

185
00:06:12,160 --> 00:06:15,120
over tcp

186
00:06:13,360 --> 00:06:16,639
but you can extend it i don't know if

187
00:06:15,120 --> 00:06:18,720
you want to send the stream

188
00:06:16,639 --> 00:06:20,960
over a serial port for example you can

189
00:06:18,720 --> 00:06:22,960
do that and then this stream

190
00:06:20,960 --> 00:06:24,719
goes to the developer desktop and again

191
00:06:22,960 --> 00:06:27,039
we provide the library

192
00:06:24,720 --> 00:06:27,840
as written in c plus plus and has python

193
00:06:27,039 --> 00:06:30,240
bindings that

194
00:06:27,840 --> 00:06:32,000
deserializes the stream of events and

195
00:06:30,240 --> 00:06:34,080
provides you nice data structures

196
00:06:32,000 --> 00:06:36,000
in your language so then you can build

197
00:06:34,080 --> 00:06:38,400
your client and we already provide

198
00:06:36,000 --> 00:06:39,680
the whole tracer converter client that

199
00:06:38,400 --> 00:06:41,359
converts this

200
00:06:39,680 --> 00:06:42,720
binary stream to some common trace

201
00:06:41,360 --> 00:06:44,400
formats uh

202
00:06:42,720 --> 00:06:46,560
we also have the library that's written

203
00:06:44,400 --> 00:06:48,880
in rust is it's not really experimental

204
00:06:46,560 --> 00:06:51,199
because i know people already use it and

205
00:06:48,880 --> 00:06:51,919
i'm gonna use it today during the demo

206
00:06:51,199 --> 00:06:54,000
so

207
00:06:51,919 --> 00:06:55,680
if that's gonna work then it won't be

208
00:06:54,000 --> 00:06:58,720
experimental anymore

209
00:06:55,680 --> 00:07:01,199
um hopefully it will work

210
00:06:58,720 --> 00:07:02,800
so i mentioned here you see that there's

211
00:07:01,199 --> 00:07:04,319
a there is a timeline

212
00:07:02,800 --> 00:07:06,319
and the timeline is conceptually as a

213
00:07:04,319 --> 00:07:08,000
buffer but it actually

214
00:07:06,319 --> 00:07:09,360
is a little bit more and you need to

215
00:07:08,000 --> 00:07:11,759
provide some configuration

216
00:07:09,360 --> 00:07:13,840
for that timeline and so to simplify

217
00:07:11,759 --> 00:07:15,199
this process of creating the timeline we

218
00:07:13,840 --> 00:07:17,440
hope to receive provides a global

219
00:07:15,199 --> 00:07:20,160
timeline which is quite efficient

220
00:07:17,440 --> 00:07:20,560
it's kind of multiple timelines actually

221
00:07:20,160 --> 00:07:22,880
it's

222
00:07:20,560 --> 00:07:24,240
timeline per thread so if you push

223
00:07:22,880 --> 00:07:25,840
events to

224
00:07:24,240 --> 00:07:27,440
to the timeline we don't require any

225
00:07:25,840 --> 00:07:28,960
locks because it's

226
00:07:27,440 --> 00:07:30,560
you have an instance per thread so

227
00:07:28,960 --> 00:07:32,638
there's no problem with data races and

228
00:07:30,560 --> 00:07:34,160
so on

229
00:07:32,639 --> 00:07:36,639
and you can easily access it by just

230
00:07:34,160 --> 00:07:39,039
calling ht global timeline get function

231
00:07:36,639 --> 00:07:40,720
uh i recommend just using that to be

232
00:07:39,039 --> 00:07:41,599
honest i don't think in my real projects

233
00:07:40,720 --> 00:07:44,080
i ever use

234
00:07:41,599 --> 00:07:45,360
different approach so it's probably good

235
00:07:44,080 --> 00:07:48,000
enough

236
00:07:45,360 --> 00:07:48,560
so i mentioned that uh the basic data

237
00:07:48,000 --> 00:07:51,520
unit

238
00:07:48,560 --> 00:07:52,400
uh in hawke tracer is an event uh so you

239
00:07:51,520 --> 00:07:55,039
can do either

240
00:07:52,400 --> 00:07:56,239
we have quite a few events defined in

241
00:07:55,039 --> 00:07:58,719
hope tracer

242
00:07:56,240 --> 00:08:00,639
event types but you can define your own

243
00:07:58,720 --> 00:08:02,160
as basically a c structure you define

244
00:08:00,639 --> 00:08:05,360
you define it using a

245
00:08:02,160 --> 00:08:07,680
c macro uh and you provide the

246
00:08:05,360 --> 00:08:08,960
event class name uh which could be my

247
00:08:07,680 --> 00:08:11,120
event for example

248
00:08:08,960 --> 00:08:12,080
it supports inheritance so all the

249
00:08:11,120 --> 00:08:14,400
events

250
00:08:12,080 --> 00:08:15,840
must eventually inherit from hd event

251
00:08:14,400 --> 00:08:18,878
which is a very base class

252
00:08:15,840 --> 00:08:20,239
and then you provide a set of set of

253
00:08:18,879 --> 00:08:22,639
fields that you want to

254
00:08:20,240 --> 00:08:23,520
have in this event and you define it by

255
00:08:22,639 --> 00:08:25,840
three properties

256
00:08:23,520 --> 00:08:26,960
as a type is either integer string

257
00:08:25,840 --> 00:08:30,400
struct float

258
00:08:26,960 --> 00:08:32,799
double um or pointer i think um

259
00:08:30,400 --> 00:08:33,598
then you provide the actual c type of

260
00:08:32,799 --> 00:08:36,718
that and

261
00:08:33,599 --> 00:08:39,760
and the name and that converts to the

262
00:08:36,719 --> 00:08:42,240
to the c structure and

263
00:08:39,760 --> 00:08:44,240
additionally it generates automatically

264
00:08:42,240 --> 00:08:45,200
a few helper methods like for example a

265
00:08:44,240 --> 00:08:47,040
method for

266
00:08:45,200 --> 00:08:48,800
serializing the event so when you have

267
00:08:47,040 --> 00:08:51,760
this event and you want to push it to

268
00:08:48,800 --> 00:08:53,040
uh to the byte stream this macro already

269
00:08:51,760 --> 00:08:55,519
will generate

270
00:08:53,040 --> 00:08:56,240
a function that does it for you and then

271
00:08:55,519 --> 00:08:58,800
when you

272
00:08:56,240 --> 00:08:59,440
already have the event uh if you want to

273
00:08:58,800 --> 00:09:01,199
push

274
00:08:59,440 --> 00:09:03,120
the instance of this event type to the

275
00:09:01,200 --> 00:09:04,480
timeline you just call ht timeline push

276
00:09:03,120 --> 00:09:05,680
event macro

277
00:09:04,480 --> 00:09:07,519
you pass the timeline as the first

278
00:09:05,680 --> 00:09:08,800
parameter the the second parameter is

279
00:09:07,519 --> 00:09:11,920
the name of your function

280
00:09:08,800 --> 00:09:13,199
of your event type and then all the all

281
00:09:11,920 --> 00:09:16,399
the values all the fields

282
00:09:13,200 --> 00:09:19,279
and that's that's pretty much it um

283
00:09:16,399 --> 00:09:21,519
so i've i said that before that we

284
00:09:19,279 --> 00:09:23,920
provide the client that parses the

285
00:09:21,519 --> 00:09:24,880
the binary stream but then i said that

286
00:09:23,920 --> 00:09:27,199
you can write

287
00:09:24,880 --> 00:09:29,279
your own event type uh so you might be

288
00:09:27,200 --> 00:09:32,000
wondering how the client knows

289
00:09:29,279 --> 00:09:32,959
how to uh deserialize these new event

290
00:09:32,000 --> 00:09:35,040
types

291
00:09:32,959 --> 00:09:37,199
and for that purpose we have the we

292
00:09:35,040 --> 00:09:39,599
divided the event stream into two

293
00:09:37,200 --> 00:09:41,040
sub streams there's a metadata stream

294
00:09:39,600 --> 00:09:42,959
that describes the

295
00:09:41,040 --> 00:09:45,279
all the types and there's the actual

296
00:09:42,959 --> 00:09:48,399
event stream uh with all the values

297
00:09:45,279 --> 00:09:50,640
and since everything in hawke tracer is

298
00:09:48,399 --> 00:09:52,720
an event even the definition of the

299
00:09:50,640 --> 00:09:54,959
event is

300
00:09:52,720 --> 00:09:56,080
uh event as well so we have special

301
00:09:54,959 --> 00:09:58,160
events uh

302
00:09:56,080 --> 00:09:59,279
that describe your type and the first

303
00:09:58,160 --> 00:10:01,519
event is

304
00:09:59,279 --> 00:10:03,120
just describing the name and uh and the

305
00:10:01,519 --> 00:10:06,240
number of fields that you have

306
00:10:03,120 --> 00:10:07,360
and then you have each each event new

307
00:10:06,240 --> 00:10:10,320
event for each

308
00:10:07,360 --> 00:10:12,000
field of this uh of this class so in

309
00:10:10,320 --> 00:10:15,040
that case we'll expect

310
00:10:12,000 --> 00:10:15,519
one event one event for a class info

311
00:10:15,040 --> 00:10:18,880
invent

312
00:10:15,519 --> 00:10:19,680
and three uh events for class field info

313
00:10:18,880 --> 00:10:22,000
event and

314
00:10:19,680 --> 00:10:22,959
in class field import event we provide

315
00:10:22,000 --> 00:10:26,160
information like

316
00:10:22,959 --> 00:10:29,680
uh like the field type

317
00:10:26,160 --> 00:10:31,439
field name the size of of that field and

318
00:10:29,680 --> 00:10:34,239
and the data type whether it is a string

319
00:10:31,440 --> 00:10:37,279
integer struct and so on

320
00:10:34,240 --> 00:10:40,000
and this uh they both the

321
00:10:37,279 --> 00:10:40,480
both streams are serialized as a byte

322
00:10:40,000 --> 00:10:43,040
stream

323
00:10:40,480 --> 00:10:44,959
so you can see that basically it's just

324
00:10:43,040 --> 00:10:47,920
like 30 or 40

325
00:10:44,959 --> 00:10:50,079
40 bytes for for those events and then

326
00:10:47,920 --> 00:10:52,479
eventually you have the actual event

327
00:10:50,079 --> 00:10:54,000
and this event has a type so it's number

328
00:10:52,480 --> 00:10:57,120
nine as you can see

329
00:10:54,000 --> 00:11:00,160
the the class id is 9 here and the

330
00:10:57,120 --> 00:11:01,760
info class id 9 again so all of them are

331
00:11:00,160 --> 00:11:04,719
kind of connected to each other

332
00:11:01,760 --> 00:11:06,640
by this uh by this identifier and uh

333
00:11:04,720 --> 00:11:07,279
it's important that you first need to

334
00:11:06,640 --> 00:11:09,519
send

335
00:11:07,279 --> 00:11:10,720
the the definition of the event type

336
00:11:09,519 --> 00:11:12,720
before you actually send

337
00:11:10,720 --> 00:11:14,800
the first event of this type because

338
00:11:12,720 --> 00:11:17,760
otherwise the parser doesn't know how to

339
00:11:14,800 --> 00:11:19,199
how to parse this event and yeah uh but

340
00:11:17,760 --> 00:11:19,760
the hawk thresher does everything for

341
00:11:19,200 --> 00:11:22,240
you so

342
00:11:19,760 --> 00:11:22,880
it's just uh can i ask a question yeah

343
00:11:22,240 --> 00:11:26,240
go ahead

344
00:11:22,880 --> 00:11:28,160
if if the puzzle loses sync with the

345
00:11:26,240 --> 00:11:30,240
stream is there a way for it to re-gain

346
00:11:28,160 --> 00:11:31,040
sync later so no at the moment it's not

347
00:11:30,240 --> 00:11:33,440
possible

348
00:11:31,040 --> 00:11:35,439
i'm working on improvement that it will

349
00:11:33,440 --> 00:11:37,760
be actually possible but at the moment

350
00:11:35,440 --> 00:11:39,200
if you lose the metadata stream yeah

351
00:11:37,760 --> 00:11:42,079
there's a problem

352
00:11:39,200 --> 00:11:44,320
so yeah but i'm aware of this problem

353
00:11:42,079 --> 00:11:46,640
and we'll be working on that

354
00:11:44,320 --> 00:11:48,079
um okay uh so i mentioned that we also

355
00:11:46,640 --> 00:11:50,000
want to measure time

356
00:11:48,079 --> 00:11:51,839
and that was actually quite important

357
00:11:50,000 --> 00:11:54,000
requirement for us so

358
00:11:51,839 --> 00:11:56,160
to make it even easier we've inter we

359
00:11:54,000 --> 00:11:56,639
predi we have predefined event types

360
00:11:56,160 --> 00:12:00,079
that

361
00:11:56,639 --> 00:12:00,560
um that are already for measuring time

362
00:12:00,079 --> 00:12:03,120
and they

363
00:12:00,560 --> 00:12:05,119
take a label and that they they take the

364
00:12:03,120 --> 00:12:07,360
duration and the time stamp

365
00:12:05,120 --> 00:12:09,200
and uh we have a macros that

366
00:12:07,360 --> 00:12:10,480
automatically generate those events and

367
00:12:09,200 --> 00:12:14,240
push them

368
00:12:10,480 --> 00:12:15,839
to the timeline and so for c plus plus

369
00:12:14,240 --> 00:12:17,519
depending on what you want to do if you

370
00:12:15,839 --> 00:12:18,079
just trace the whole function you just

371
00:12:17,519 --> 00:12:21,120
put the

372
00:12:18,079 --> 00:12:22,319
this macro ht trace function at the

373
00:12:21,120 --> 00:12:23,839
beginning

374
00:12:22,320 --> 00:12:26,079
and you just want to trace the random

375
00:12:23,839 --> 00:12:27,920
scope there's hd trace

376
00:12:26,079 --> 00:12:29,359
there is a few more macros that are more

377
00:12:27,920 --> 00:12:30,719
optimized for that

378
00:12:29,360 --> 00:12:33,120
they for example they have some hash

379
00:12:30,720 --> 00:12:36,240
maps so you don't have to send the

380
00:12:33,120 --> 00:12:38,079
uh the string every time for every event

381
00:12:36,240 --> 00:12:40,240
it's even more optimized version that

382
00:12:38,079 --> 00:12:43,599
uses uh some tricks with static

383
00:12:40,240 --> 00:12:46,639
thread local uh objects so

384
00:12:43,600 --> 00:12:48,720
even even hashmap is not necessary for

385
00:12:46,639 --> 00:12:52,160
some of them uh it's documented so

386
00:12:48,720 --> 00:12:55,040
i don't want to spend much time on that

387
00:12:52,160 --> 00:12:56,560
and we did bindings for a few languages

388
00:12:55,040 --> 00:12:59,120
for now the public one

389
00:12:56,560 --> 00:13:00,880
is python and rust uh we have one for

390
00:12:59,120 --> 00:13:03,120
javascript as well it's not

391
00:13:00,880 --> 00:13:04,639
ready yet to be published but we'll do

392
00:13:03,120 --> 00:13:06,880
that in the future

393
00:13:04,639 --> 00:13:08,399
and for lua as well um so this is how

394
00:13:06,880 --> 00:13:10,800
you do that in python you import

395
00:13:08,399 --> 00:13:13,040
the trace decorator and you just put it

396
00:13:10,800 --> 00:13:15,680
for the function that you want to trace

397
00:13:13,040 --> 00:13:16,319
and the the same for us uh there are

398
00:13:15,680 --> 00:13:19,120
some

399
00:13:16,320 --> 00:13:20,320
macros i'm not an author of the of the

400
00:13:19,120 --> 00:13:22,160
rouse bindings so

401
00:13:20,320 --> 00:13:24,240
probably if you want to know more about

402
00:13:22,160 --> 00:13:27,360
this uh this alex andrew he's

403
00:13:24,240 --> 00:13:28,800
in foster i'm not sure if he's uh today

404
00:13:27,360 --> 00:13:31,040
in this room but

405
00:13:28,800 --> 00:13:32,399
um yeah he's he's an author of that and

406
00:13:31,040 --> 00:13:35,199
basically that's how you do that

407
00:13:32,399 --> 00:13:38,240
also there are some kind of rust macros

408
00:13:35,200 --> 00:13:41,279
that you can trace the scope

409
00:13:38,240 --> 00:13:42,000
okay so that was it and i just want to

410
00:13:41,279 --> 00:13:43,600
show you some

411
00:13:42,000 --> 00:13:45,040
some demos so you can see how you can

412
00:13:43,600 --> 00:13:47,920
use it

413
00:13:45,040 --> 00:13:50,160
the first one is we have a c plus plus

414
00:13:47,920 --> 00:13:52,880
application that allocates the memory

415
00:13:50,160 --> 00:13:53,519
and then we want to we want to see on

416
00:13:52,880 --> 00:13:55,600
the graph

417
00:13:53,519 --> 00:13:57,360
how the memory grows we also want to

418
00:13:55,600 --> 00:13:59,920
know how many allocations we've done

419
00:13:57,360 --> 00:14:02,240
in this program so we'll write a simple

420
00:13:59,920 --> 00:14:04,639
python client that receives the

421
00:14:02,240 --> 00:14:06,560
hulk tracer event stream and does the

422
00:14:04,639 --> 00:14:09,760
visualization

423
00:14:06,560 --> 00:14:10,880
and i start with the with the program

424
00:14:09,760 --> 00:14:12,959
itself

425
00:14:10,880 --> 00:14:15,120
so at the very beginning we need to

426
00:14:12,959 --> 00:14:18,160
initialize the whole tracer library

427
00:14:15,120 --> 00:14:20,000
and then so this is the event that we

428
00:14:18,160 --> 00:14:22,480
even type that we define as i said

429
00:14:20,000 --> 00:14:24,560
there's a name the base type and we have

430
00:14:22,480 --> 00:14:25,440
two fields memory usage and allocation

431
00:14:24,560 --> 00:14:30,319
count

432
00:14:25,440 --> 00:14:33,360
they both are integers size t type

433
00:14:30,320 --> 00:14:35,120
and the event uh before you want to use

434
00:14:33,360 --> 00:14:36,560
it you need to register it this method

435
00:14:35,120 --> 00:14:38,720
is auto-generated by

436
00:14:36,560 --> 00:14:41,518
uh by the macro that i showed before by

437
00:14:38,720 --> 00:14:43,279
this macro hd declare event type

438
00:14:41,519 --> 00:14:44,800
um you just need to call it before you

439
00:14:43,279 --> 00:14:47,360
use it it registers

440
00:14:44,800 --> 00:14:48,959
uh some information hawke tracer system

441
00:14:47,360 --> 00:14:51,040
and then you create the listener

442
00:14:48,959 --> 00:14:52,959
to the timeline i said the global

443
00:14:51,040 --> 00:14:54,800
timeline is the best option

444
00:14:52,959 --> 00:14:56,319
so we're using global timeline here

445
00:14:54,800 --> 00:14:59,839
there are some parameters like

446
00:14:56,320 --> 00:15:00,959
port this is the buffer size we set it

447
00:14:59,839 --> 00:15:02,880
to zero so we'll get

448
00:15:00,959 --> 00:15:04,479
we don't actually buffer anything we

449
00:15:02,880 --> 00:15:06,240
stream it directly

450
00:15:04,480 --> 00:15:08,480
to the client and we say that we want to

451
00:15:06,240 --> 00:15:11,040
use it we want to use tcp

452
00:15:08,480 --> 00:15:13,839
client so we can stream it directly to

453
00:15:11,040 --> 00:15:15,439
the client and we can get the real data

454
00:15:13,839 --> 00:15:17,120
hog tracer already provides the

455
00:15:15,440 --> 00:15:19,920
functions to get

456
00:15:17,120 --> 00:15:21,279
the memory usage it also provides some

457
00:15:19,920 --> 00:15:24,479
functions to

458
00:15:21,279 --> 00:15:25,439
trace the allocation so you just need to

459
00:15:24,480 --> 00:15:28,720
provide

460
00:15:25,440 --> 00:15:31,759
a callback this is for malloc primalog

461
00:15:28,720 --> 00:15:32,399
then it's post malloc pre reallock post

462
00:15:31,759 --> 00:15:33,920
dialogue

463
00:15:32,399 --> 00:15:35,920
and so on and so on we are only

464
00:15:33,920 --> 00:15:39,519
interested in pre malloc

465
00:15:35,920 --> 00:15:42,240
hooks so we register that and

466
00:15:39,519 --> 00:15:45,040
this is basically our function uh we get

467
00:15:42,240 --> 00:15:48,560
the memory usage

468
00:15:45,040 --> 00:15:51,120
we get the the allocation count

469
00:15:48,560 --> 00:15:52,000
which is read uh in the other callback

470
00:15:51,120 --> 00:15:54,240
so here

471
00:15:52,000 --> 00:15:56,399
this is our malloc callback so we

472
00:15:54,240 --> 00:15:59,600
increase the allocation count every time

473
00:15:56,399 --> 00:16:02,240
somebody calls malloc uh so we get that

474
00:15:59,600 --> 00:16:03,440
all in the context object uh and this

475
00:16:02,240 --> 00:16:06,240
that's basically what we do

476
00:16:03,440 --> 00:16:07,040
we push the event uh so this is our type

477
00:16:06,240 --> 00:16:09,759
those are

478
00:16:07,040 --> 00:16:11,680
our values and this is the yeah this is

479
00:16:09,759 --> 00:16:13,920
the memory usage virtual memory usage

480
00:16:11,680 --> 00:16:16,399
and this is the allocation count

481
00:16:13,920 --> 00:16:17,439
and this is the client it's written in

482
00:16:16,399 --> 00:16:20,240
python

483
00:16:17,440 --> 00:16:21,839
um all we need to do we need to start

484
00:16:20,240 --> 00:16:25,040
the client

485
00:16:21,839 --> 00:16:25,759
the hog tracer client we say okay listen

486
00:16:25,040 --> 00:16:30,079
to

487
00:16:25,759 --> 00:16:31,920
8765 port on this ip address

488
00:16:30,079 --> 00:16:33,680
this is the animate method that's

489
00:16:31,920 --> 00:16:35,199
basically the anim that does the

490
00:16:33,680 --> 00:16:37,599
drawing the graph but the most

491
00:16:35,199 --> 00:16:40,000
interesting bit is this one

492
00:16:37,600 --> 00:16:41,600
so this is basically how we read events

493
00:16:40,000 --> 00:16:44,800
from hawke tracer

494
00:16:41,600 --> 00:16:47,440
um this is our client so we're waiting

495
00:16:44,800 --> 00:16:49,199
uh for end of stream if it's not then we

496
00:16:47,440 --> 00:16:50,560
pull in event if there is an event in

497
00:16:49,199 --> 00:16:53,599
the queue

498
00:16:50,560 --> 00:16:55,758
we check the the the first this is a

499
00:16:53,600 --> 00:16:57,360
tuple and the first element of the tuple

500
00:16:55,759 --> 00:16:58,720
is the event name so we check if this is

501
00:16:57,360 --> 00:17:01,839
the event that we want

502
00:16:58,720 --> 00:17:03,839
and if so uh we get the timestamp we get

503
00:17:01,839 --> 00:17:04,559
allocation count and we get a memory

504
00:17:03,839 --> 00:17:06,400
usage

505
00:17:04,559 --> 00:17:09,439
and then we put the memory usage on the

506
00:17:06,400 --> 00:17:13,919
graph and we print the allocation count

507
00:17:09,439 --> 00:17:19,600
so it's very very simple let's run it

508
00:17:13,919 --> 00:17:22,240
so we run the client and now we run

509
00:17:19,599 --> 00:17:23,198
the program that we want to trace so you

510
00:17:22,240 --> 00:17:26,400
can see

511
00:17:23,199 --> 00:17:28,400
that the memory usage is growing and you

512
00:17:26,400 --> 00:17:31,120
can also see the allocation count

513
00:17:28,400 --> 00:17:32,160
is is going up and so you might be

514
00:17:31,120 --> 00:17:34,799
wondering why

515
00:17:32,160 --> 00:17:37,280
the memory usage is growing if we go

516
00:17:34,799 --> 00:17:40,320
back to our application

517
00:17:37,280 --> 00:17:44,840
we see that we have a loop

518
00:17:40,320 --> 00:17:48,320
and we do malloc so and it's called

519
00:17:44,840 --> 00:17:51,600
um hundred

520
00:17:48,320 --> 00:17:53,840
thousand times so we can see

521
00:17:51,600 --> 00:17:55,280
how many mallocs we actually got it's

522
00:17:53,840 --> 00:17:57,039
more than hundred thousands

523
00:17:55,280 --> 00:17:58,720
there's probably some other allocations

524
00:17:57,039 --> 00:18:00,879
going on um

525
00:17:58,720 --> 00:18:02,799
again this is the and this is the graph

526
00:18:00,880 --> 00:18:04,559
so that's how you can get the real data

527
00:18:02,799 --> 00:18:05,360
from the hook tracer by defining your

528
00:18:04,559 --> 00:18:06,960
own event

529
00:18:05,360 --> 00:18:08,959
it could be it doesn't have to be memory

530
00:18:06,960 --> 00:18:12,000
usage you for example can trace a

531
00:18:08,960 --> 00:18:14,640
number of uh http calls for example

532
00:18:12,000 --> 00:18:15,280
and so on um yeah so that was the first

533
00:18:14,640 --> 00:18:16,960
demo

534
00:18:15,280 --> 00:18:19,039
and the second one is going to be more

535
00:18:16,960 --> 00:18:20,000
complex a little i want to show you how

536
00:18:19,039 --> 00:18:23,679
you can

537
00:18:20,000 --> 00:18:25,360
trace um multiple languages at the same

538
00:18:23,679 --> 00:18:27,200
time because that was our actually

539
00:18:25,360 --> 00:18:28,879
our real use case we had application

540
00:18:27,200 --> 00:18:31,120
written in class plus and then we run

541
00:18:28,880 --> 00:18:33,120
lua and javascript on top of that

542
00:18:31,120 --> 00:18:36,479
so i do slightly different example i

543
00:18:33,120 --> 00:18:38,320
have a main application written in rust

544
00:18:36,480 --> 00:18:40,480
this application downloads the image

545
00:18:38,320 --> 00:18:42,000
using a downloader library that's

546
00:18:40,480 --> 00:18:45,039
written in c

547
00:18:42,000 --> 00:18:45,919
it uses curl and then i rotate this

548
00:18:45,039 --> 00:18:48,960
image

549
00:18:45,919 --> 00:18:51,280
using some image i think it's opencv

550
00:18:48,960 --> 00:18:53,360
maybe not opencv i actually changed it

551
00:18:51,280 --> 00:18:54,720
but yeah it rotates the image in python

552
00:18:53,360 --> 00:18:58,000
so i run python

553
00:18:54,720 --> 00:18:58,400
interpreter in rust and then at the same

554
00:18:58,000 --> 00:19:00,000
time

555
00:18:58,400 --> 00:19:01,840
while i'm rotating the image i also

556
00:19:00,000 --> 00:19:02,720
upload the image that i downloaded in

557
00:19:01,840 --> 00:19:04,959
the first step

558
00:19:02,720 --> 00:19:09,360
to to the s3 bucket and i want to know

559
00:19:04,960 --> 00:19:09,360
how much time i spend in each particular

560
00:19:09,679 --> 00:19:14,080
of in each particular operation so i

561
00:19:12,559 --> 00:19:17,120
again start with the code

562
00:19:14,080 --> 00:19:17,840
so this is our rust client uh even

563
00:19:17,120 --> 00:19:19,439
though you're not

564
00:19:17,840 --> 00:19:21,600
you might not be familiar with rust i

565
00:19:19,440 --> 00:19:25,120
think it's pretty pretty simple

566
00:19:21,600 --> 00:19:28,320
um so we start with download file

567
00:19:25,120 --> 00:19:31,120
this is download file rs it's basically

568
00:19:28,320 --> 00:19:32,879
just the wrapper for the download file

569
00:19:31,120 --> 00:19:34,399
library a

570
00:19:32,880 --> 00:19:36,320
function from the library that's written

571
00:19:34,400 --> 00:19:39,280
in c um

572
00:19:36,320 --> 00:19:39,840
then once we have the file downloaded we

573
00:19:39,280 --> 00:19:42,559
spawn

574
00:19:39,840 --> 00:19:45,120
two threads one is doing the rotation in

575
00:19:42,559 --> 00:19:47,200
python it starts the python interpreter

576
00:19:45,120 --> 00:19:48,320
and does the rotation and the other one

577
00:19:47,200 --> 00:19:51,360
at the same time

578
00:19:48,320 --> 00:19:53,678
uploads uh uploads the file to s3

579
00:19:51,360 --> 00:19:54,479
you might see that all of the functions

580
00:19:53,679 --> 00:19:57,440
here

581
00:19:54,480 --> 00:20:00,160
are decorated with with those macros and

582
00:19:57,440 --> 00:20:02,799
we also have some other trace points

583
00:20:00,160 --> 00:20:03,440
in here we can look at the downloader

584
00:20:02,799 --> 00:20:05,520
file

585
00:20:03,440 --> 00:20:07,760
it's pretty simple one it's just the

586
00:20:05,520 --> 00:20:09,840
curl wrapped around

587
00:20:07,760 --> 00:20:12,640
we trace the function here at the

588
00:20:09,840 --> 00:20:14,879
beginning and we also

589
00:20:12,640 --> 00:20:16,960
see how long does it take to to call

590
00:20:14,880 --> 00:20:18,320
curl easy perform so we trace the whole

591
00:20:16,960 --> 00:20:23,039
scope here

592
00:20:18,320 --> 00:20:26,158
and just last bit is the python one

593
00:20:23,039 --> 00:20:29,520
we import the

594
00:20:26,159 --> 00:20:31,200
the decorator and we decorate all the

595
00:20:29,520 --> 00:20:32,720
functions so we basically rotate the

596
00:20:31,200 --> 00:20:35,360
image

597
00:20:32,720 --> 00:20:36,960
and save the image we load the image we

598
00:20:35,360 --> 00:20:37,918
rotate the image and then we save the

599
00:20:36,960 --> 00:20:40,640
image to the file

600
00:20:37,919 --> 00:20:42,320
so not not really a rocket science here

601
00:20:40,640 --> 00:20:44,400
it's important that if you want to run

602
00:20:42,320 --> 00:20:45,760
it with python this environmental

603
00:20:44,400 --> 00:20:49,440
variable needs to be set

604
00:20:45,760 --> 00:20:51,679
otherwise uh the python bypasses all the

605
00:20:49,440 --> 00:20:53,520
all the trace decorators so it's

606
00:20:51,679 --> 00:20:54,240
actually it doesn't have much impact on

607
00:20:53,520 --> 00:20:55,840
the memo

608
00:20:54,240 --> 00:20:56,799
on the performance if you disable that

609
00:20:55,840 --> 00:20:58,720
so you can even have it in the

610
00:20:56,799 --> 00:21:03,039
production code

611
00:20:58,720 --> 00:21:03,039
okay so let's run this

612
00:21:03,760 --> 00:21:07,200
so this is our program it downloaded the

613
00:21:05,440 --> 00:21:09,039
file successfully it's doing the

614
00:21:07,200 --> 00:21:10,720
rotation and it's doing the upload so

615
00:21:09,039 --> 00:21:14,320
you can see that it actually

616
00:21:10,720 --> 00:21:17,919
did rotate uh some image

617
00:21:14,320 --> 00:21:20,960
let's start three from zero

618
00:21:17,919 --> 00:21:23,919
yes as a hulk and it's basically all the

619
00:21:20,960 --> 00:21:26,400
all the angles are here uh if we delete

620
00:21:23,919 --> 00:21:26,400
that one

621
00:21:26,799 --> 00:21:34,080
we have also rotate hd dump which is the

622
00:21:30,799 --> 00:21:37,840
binary file uh

623
00:21:34,080 --> 00:21:39,600
with all the events all the traces

624
00:21:37,840 --> 00:21:41,760
oh this is not going to work because i

625
00:21:39,600 --> 00:21:44,639
forgot the

626
00:21:41,760 --> 00:21:46,799
i forgot this environment variable here

627
00:21:44,640 --> 00:21:50,400
so we wouldn't have the python traces

628
00:21:46,799 --> 00:21:53,520
so i run it again i'm

629
00:21:50,400 --> 00:21:56,080
gonna delete the images

630
00:21:53,520 --> 00:21:57,760
so we have the the hd dump file which is

631
00:21:56,080 --> 00:22:02,000
the binary stream

632
00:21:57,760 --> 00:22:05,039
we can now use a hog tracer converter

633
00:22:02,000 --> 00:22:06,799
as the one that's experimental so hope

634
00:22:05,039 --> 00:22:10,240
is working

635
00:22:06,799 --> 00:22:13,679
and we generate the chrome trace format

636
00:22:10,240 --> 00:22:17,280
so we say it will be output

637
00:22:13,679 --> 00:22:20,320
dot json okay it converted so

638
00:22:17,280 --> 00:22:21,840
now you can use the tool that's deployed

639
00:22:20,320 --> 00:22:25,039
with

640
00:22:21,840 --> 00:22:25,918
uh with chromium and you see that first

641
00:22:25,039 --> 00:22:27,919
you see that

642
00:22:25,919 --> 00:22:29,120
we have three threads here one two three

643
00:22:27,919 --> 00:22:30,240
and that's exactly what we had

644
00:22:29,120 --> 00:22:32,879
because we have the main thread and then

645
00:22:30,240 --> 00:22:36,159
we spawned two two extra threads

646
00:22:32,880 --> 00:22:38,400
for uh for rotate and for upload

647
00:22:36,159 --> 00:22:41,039
this is the first bit that's in c plus

648
00:22:38,400 --> 00:22:42,320
plus uh or c we download the file this

649
00:22:41,039 --> 00:22:44,000
http request

650
00:22:42,320 --> 00:22:45,520
and then just after that we wrote we

651
00:22:44,000 --> 00:22:48,320
start rotating python

652
00:22:45,520 --> 00:22:50,158
and those trace points here those are

653
00:22:48,320 --> 00:22:52,799
from python save image rotate

654
00:22:50,159 --> 00:22:55,039
main those trace points are from python

655
00:22:52,799 --> 00:22:57,600
and this one uploads to s3

656
00:22:55,039 --> 00:22:58,640
is in rust so as you can see you can

657
00:22:57,600 --> 00:23:01,280
trace

658
00:22:58,640 --> 00:23:02,799
uh you can have everything in one trace

659
00:23:01,280 --> 00:23:04,559
file

660
00:23:02,799 --> 00:23:07,039
and you can easily analyze what's going

661
00:23:04,559 --> 00:23:10,320
on in the program you can also

662
00:23:07,039 --> 00:23:10,320
convert it to

663
00:23:11,520 --> 00:23:14,240
flame graphs

664
00:23:18,480 --> 00:23:24,159
so if you want the flame graph view

665
00:23:22,000 --> 00:23:25,760
you can just do that this is a very

666
00:23:24,159 --> 00:23:27,120
simple program so the flame graph also

667
00:23:25,760 --> 00:23:30,960
is very simple but

668
00:23:27,120 --> 00:23:32,879
yeah so that's it we have some

669
00:23:30,960 --> 00:23:34,400
planned for improving this there are

670
00:23:32,880 --> 00:23:37,039
some of the items but

671
00:23:34,400 --> 00:23:38,880
not all of them as you mentioned we want

672
00:23:37,039 --> 00:23:39,520
to add some extra protection layer in

673
00:23:38,880 --> 00:23:43,440
case

674
00:23:39,520 --> 00:23:43,440
we lose some events on the way

675
00:23:43,679 --> 00:23:46,720
and yeah that's it thank you there's a

676
00:23:45,600 --> 00:23:48,879
bunch of links

677
00:23:46,720 --> 00:23:50,559
feel free to contact me there's a

678
00:23:48,880 --> 00:23:51,440
documentation on the website there are

679
00:23:50,559 --> 00:23:53,678
tutorials

680
00:23:51,440 --> 00:23:54,720
uh there they say how to integrate it

681
00:23:53,679 --> 00:23:57,679
with your project

682
00:23:54,720 --> 00:23:58,880
basically hog tracer can be uh combined

683
00:23:57,679 --> 00:24:00,799
into one single

684
00:23:58,880 --> 00:24:02,240
c plus plus and header files so it's

685
00:24:00,799 --> 00:24:03,918
easy to uh

686
00:24:02,240 --> 00:24:06,000
to link it to your project if you want

687
00:24:03,919 --> 00:24:06,880
uh there are other links for bindings

688
00:24:06,000 --> 00:24:11,440
and for

689
00:24:06,880 --> 00:24:11,440
for contra converter so uh thank you

690
00:24:16,799 --> 00:24:20,559
i think we'll have one minute for

691
00:24:18,000 --> 00:24:23,679
questions but if that's not enough then

692
00:24:20,559 --> 00:24:26,960
i'll be around okay

693
00:24:23,679 --> 00:24:31,120
yeah which methods like you showed tcp

694
00:24:26,960 --> 00:24:32,080
now right so in addition to tcp what do

695
00:24:31,120 --> 00:24:35,039
you currently

696
00:24:32,080 --> 00:24:36,158
natively so this is the tcp that we use

697
00:24:35,039 --> 00:24:38,158
in the first demo

698
00:24:36,159 --> 00:24:39,200
and the file which was used as the

699
00:24:38,159 --> 00:24:41,279
second demo

700
00:24:39,200 --> 00:24:43,600
yeah so those are natively supported at

701
00:24:41,279 --> 00:24:43,600
the moment

702
00:24:44,880 --> 00:24:48,159
sorry so if you want something like

703
00:24:46,559 --> 00:24:48,480
serial yeah you need to write down your

704
00:24:48,159 --> 00:24:51,600
own so

705
00:24:48,480 --> 00:24:53,440
sorry the question was what uh what

706
00:24:51,600 --> 00:24:55,600
listener types we support and

707
00:24:53,440 --> 00:24:57,279
my answer is so currently we support

708
00:24:55,600 --> 00:25:01,840
file and tcp listeners

709
00:24:57,279 --> 00:25:01,840
yeah thank you

