1
00:00:05,040 --> 00:00:09,040
uh

2
00:00:05,600 --> 00:00:13,200
thank you everyone for coming um

3
00:00:09,040 --> 00:00:16,560
and let's start first some introduction

4
00:00:13,200 --> 00:00:18,480
uh you know my name i'm a bit of a nomad

5
00:00:16,560 --> 00:00:20,000
and what you see in the bottom is

6
00:00:18,480 --> 00:00:21,600
gibberish if you don't understand it

7
00:00:20,000 --> 00:00:22,080
it's fine because you don't know finnish

8
00:00:21,600 --> 00:00:25,840
then

9
00:00:22,080 --> 00:00:27,919
but that's my song which means it says i

10
00:00:25,840 --> 00:00:31,198
this it's not my home which is a good

11
00:00:27,920 --> 00:00:34,239
song for no man like me

12
00:00:31,199 --> 00:00:36,800
i work for red hat and

13
00:00:34,239 --> 00:00:37,360
work on false i've been working on free

14
00:00:36,800 --> 00:00:41,360
software

15
00:00:37,360 --> 00:00:45,280
and open source for a long time now

16
00:00:41,360 --> 00:00:48,719
and i've been to flying and i love cats

17
00:00:45,280 --> 00:00:50,719
um so i had a similar talk at

18
00:00:48,719 --> 00:00:52,239
rust fest so if some of you were there

19
00:00:50,719 --> 00:00:53,920
then it's a recap otherwise it's a

20
00:00:52,239 --> 00:00:57,680
background story

21
00:00:53,920 --> 00:00:59,120
real quick so the whole thing started

22
00:00:57,680 --> 00:01:02,079
with this project called geoclue

23
00:00:59,120 --> 00:01:02,480
it's a uh it's a daemon it's a service

24
00:01:02,079 --> 00:01:05,439
on

25
00:01:02,480 --> 00:01:06,240
on your linux laptops uh which finds

26
00:01:05,438 --> 00:01:09,199
where you are

27
00:01:06,240 --> 00:01:10,720
through different sources and stuff um

28
00:01:09,200 --> 00:01:14,400
and

29
00:01:10,720 --> 00:01:15,360
the and i've been um it's a geolocation

30
00:01:14,400 --> 00:01:17,520
service it's

31
00:01:15,360 --> 00:01:18,799
as i said it finds you where you are and

32
00:01:17,520 --> 00:01:22,158
it's written in

33
00:01:18,799 --> 00:01:24,960
in c currently and um

34
00:01:22,159 --> 00:01:27,360
i've been a maintainer since the rewrite

35
00:01:24,960 --> 00:01:30,399
it was in 2013 i think

36
00:01:27,360 --> 00:01:33,840
um and

37
00:01:30,400 --> 00:01:36,960
i thought like let's oxidize it but

38
00:01:33,840 --> 00:01:40,560
you will ask why um and i have

39
00:01:36,960 --> 00:01:42,960
reasons and it's called crash reports

40
00:01:40,560 --> 00:01:44,079
i got a lot of crash reports and will

41
00:01:42,960 --> 00:01:47,759
was telling me

42
00:01:44,079 --> 00:01:51,039
that uh on their end and endless uh they

43
00:01:47,759 --> 00:01:53,600
saw a huge amount of crashes in geoclue

44
00:01:51,040 --> 00:01:54,399
so i was like yeah i'm working on that

45
00:01:53,600 --> 00:01:56,880
so

46
00:01:54,399 --> 00:01:58,560
permanently and i it's my spare time

47
00:01:56,880 --> 00:02:01,360
thing so i don't want to

48
00:01:58,560 --> 00:02:01,680
you know chase after crash reports and

49
00:02:01,360 --> 00:02:05,439
see

50
00:02:01,680 --> 00:02:07,360
code so um also like

51
00:02:05,439 --> 00:02:08,799
location is the most sensitive data that

52
00:02:07,360 --> 00:02:10,720
is about you so

53
00:02:08,800 --> 00:02:12,640
you don't want to be trusted by everyone

54
00:02:10,720 --> 00:02:13,359
and anything and especially if it's

55
00:02:12,640 --> 00:02:16,000
written in a

56
00:02:13,360 --> 00:02:17,280
unsecured very very unsecure language

57
00:02:16,000 --> 00:02:21,120
it's not it's not a good

58
00:02:17,280 --> 00:02:22,800
idea and i just love rust

59
00:02:21,120 --> 00:02:24,640
um for various reasons i have a blog

60
00:02:22,800 --> 00:02:27,760
post about it if you want to read

61
00:02:24,640 --> 00:02:28,958
um so i i thought like let's let's do it

62
00:02:27,760 --> 00:02:30,319
let's oxidize it but what are the

63
00:02:28,959 --> 00:02:31,760
challenge what were the challenges that

64
00:02:30,319 --> 00:02:33,760
i was looking forward to

65
00:02:31,760 --> 00:02:35,599
first one was mason it's a build system

66
00:02:33,760 --> 00:02:36,560
that is being used by a lot of projects

67
00:02:35,599 --> 00:02:40,560
out there now

68
00:02:36,560 --> 00:02:42,400
um and i thought because mason doesn't

69
00:02:40,560 --> 00:02:43,680
have like built-in support for cargo so

70
00:02:42,400 --> 00:02:44,560
i thought like it would be a bit of a

71
00:02:43,680 --> 00:02:48,879
challenge

72
00:02:44,560 --> 00:02:51,519
um and the other thing was d bus like

73
00:02:48,879 --> 00:02:53,120
as i said it's a service on your laptop

74
00:02:51,519 --> 00:02:53,920
so it's you it's uh it's a deeper

75
00:02:53,120 --> 00:02:57,360
service

76
00:02:53,920 --> 00:03:00,079
um i'll talk about debuss a bit um

77
00:02:57,360 --> 00:03:02,080
it's if you're not familiar with it it's

78
00:03:00,080 --> 00:03:04,640
a very efficient binary inter-process

79
00:03:02,080 --> 00:03:06,959
communication protocol

80
00:03:04,640 --> 00:03:09,518
and it's used in desktop and embedded

81
00:03:06,959 --> 00:03:12,959
systems quite a lot

82
00:03:09,519 --> 00:03:14,959
and it's

83
00:03:12,959 --> 00:03:17,440
there is one crate already existing it's

84
00:03:14,959 --> 00:03:20,640
called dbus rs

85
00:03:17,440 --> 00:03:24,480
and i was i wasn't very happy with the

86
00:03:20,640 --> 00:03:27,440
ap api and stuff but i wanted to um

87
00:03:24,480 --> 00:03:28,959
use it even though it depends on a c

88
00:03:27,440 --> 00:03:31,040
library called libdivas

89
00:03:28,959 --> 00:03:33,280
uh that library is not very famous for

90
00:03:31,040 --> 00:03:34,798
its interfaces and stuff

91
00:03:33,280 --> 00:03:36,720
and i think there's some bunch of other

92
00:03:34,799 --> 00:03:40,799
problems with it i don't think anyone

93
00:03:36,720 --> 00:03:40,799
not many people use it anymore even

94
00:03:41,120 --> 00:03:44,720
and so yeah we had had this many many

95
00:03:43,280 --> 00:03:48,000
issues

96
00:03:44,720 --> 00:03:49,840
but i still decided to use um uh the

97
00:03:48,000 --> 00:03:51,280
this crate because that was the only one

98
00:03:49,840 --> 00:03:53,040
and i didn't have a lot of time it's

99
00:03:51,280 --> 00:03:55,280
it's as i said it well it's all my spare

100
00:03:53,040 --> 00:03:56,720
time stuff um

101
00:03:55,280 --> 00:03:59,360
i even contributed to it in the

102
00:03:56,720 --> 00:04:00,239
beginning uh a few patches there and

103
00:03:59,360 --> 00:04:03,840
stuff and

104
00:04:00,239 --> 00:04:06,400
um um and then the we had a

105
00:04:03,840 --> 00:04:07,280
heck fest uh we do this rust gnome hack

106
00:04:06,400 --> 00:04:10,400
fest which is about

107
00:04:07,280 --> 00:04:11,680
gnome and rust um every about every six

108
00:04:10,400 --> 00:04:14,720
months twice a year

109
00:04:11,680 --> 00:04:17,280
and this the last the one um in

110
00:04:14,720 --> 00:04:18,000
last year one of them was in may in

111
00:04:17,279 --> 00:04:20,238
berlin

112
00:04:18,000 --> 00:04:21,358
and i started working on this to oxidize

113
00:04:20,238 --> 00:04:24,880
geoclue

114
00:04:21,358 --> 00:04:25,280
um but turns out like the mason stuff

115
00:04:24,880 --> 00:04:27,440
was

116
00:04:25,280 --> 00:04:29,039
it turns out to be very much easier to

117
00:04:27,440 --> 00:04:30,479
work around like the workaround was

118
00:04:29,040 --> 00:04:33,600
pretty simple and

119
00:04:30,479 --> 00:04:36,880
um it was not a big issue um but

120
00:04:33,600 --> 00:04:37,280
um so i could call from mason i could

121
00:04:36,880 --> 00:04:39,199
call

122
00:04:37,280 --> 00:04:41,280
cargo and cargo does its own thing and

123
00:04:39,199 --> 00:04:44,160
that's that's it

124
00:04:41,280 --> 00:04:45,440
so i didn't need something back from the

125
00:04:44,160 --> 00:04:48,000
results of cargo

126
00:04:45,440 --> 00:04:49,840
uh to into mason so it made it

127
00:04:48,000 --> 00:04:53,120
simplified a lot of things

128
00:04:49,840 --> 00:04:54,799
um but the debus rs api

129
00:04:53,120 --> 00:04:56,160
turned out to be quite over complicated

130
00:04:54,800 --> 00:04:57,600
and i couldn't figure it out

131
00:04:56,160 --> 00:04:59,360
i asked others around and they couldn't

132
00:04:57,600 --> 00:05:02,320
figure it out either so

133
00:04:59,360 --> 00:05:04,000
um i was like how about i write first

134
00:05:02,320 --> 00:05:07,360
viewers from scratch

135
00:05:04,000 --> 00:05:09,520
um and um yeah i thought

136
00:05:07,360 --> 00:05:11,840
how hard can it be right let's check it

137
00:05:09,520 --> 00:05:11,840
out

138
00:05:12,080 --> 00:05:16,240
so i look tired looking to what's

139
00:05:14,240 --> 00:05:19,280
involved and

140
00:05:16,240 --> 00:05:22,880
on a high level is you have objects

141
00:05:19,280 --> 00:05:25,679
and each object has a as a

142
00:05:22,880 --> 00:05:27,199
path it's called object path and it's

143
00:05:25,680 --> 00:05:29,039
just a string that represents that

144
00:05:27,199 --> 00:05:31,440
object on the bus

145
00:05:29,039 --> 00:05:32,159
in dbus you have buses like it's a think

146
00:05:31,440 --> 00:05:35,520
of it as

147
00:05:32,160 --> 00:05:36,800
sockets and they're talking to

148
00:05:35,520 --> 00:05:39,198
apps talking to each other on those

149
00:05:36,800 --> 00:05:42,320
sockets and

150
00:05:39,199 --> 00:05:45,919
the the services expose

151
00:05:42,320 --> 00:05:48,479
objects and on obj on those objects

152
00:05:45,919 --> 00:05:49,520
they you have certain interfaces each

153
00:05:48,479 --> 00:05:51,359
object can

154
00:05:49,520 --> 00:05:53,440
support multiple interfaces or one

155
00:05:51,360 --> 00:05:55,680
interface but it has to support one at

156
00:05:53,440 --> 00:05:55,680
least

157
00:05:55,759 --> 00:05:59,840
and those interfaces and then methods on

158
00:05:58,000 --> 00:06:00,880
them so it's a bit dynamic like the

159
00:05:59,840 --> 00:06:03,919
reason it's like

160
00:06:00,880 --> 00:06:06,080
that we have interfaces and not methods

161
00:06:03,919 --> 00:06:08,240
an api directly on the object is that it

162
00:06:06,080 --> 00:06:10,000
could be more dynamic that you can

163
00:06:08,240 --> 00:06:12,000
on the fly change like okay this object

164
00:06:10,000 --> 00:06:15,680
now supports this interface and

165
00:06:12,000 --> 00:06:18,960
and not so yeah you have methods on them

166
00:06:15,680 --> 00:06:20,560
simple input output parameters and

167
00:06:18,960 --> 00:06:22,400
signal is just the same it's just the

168
00:06:20,560 --> 00:06:25,440
other way around so you have

169
00:06:22,400 --> 00:06:28,799
um parameters from them and you get

170
00:06:25,440 --> 00:06:31,039
signals called on you like as a client

171
00:06:28,800 --> 00:06:33,440
you get signals and you send method

172
00:06:31,039 --> 00:06:36,080
calls

173
00:06:33,440 --> 00:06:38,000
and also you have properties that

174
00:06:36,080 --> 00:06:41,680
represent different properties on your

175
00:06:38,000 --> 00:06:41,680
interfaces um

176
00:06:41,759 --> 00:06:45,840
but on the low level it's just message

177
00:06:44,080 --> 00:06:48,960
passing on the

178
00:06:45,840 --> 00:06:49,599
on sockets as i said and there is a wire

179
00:06:48,960 --> 00:06:52,880
format

180
00:06:49,599 --> 00:06:52,880
for for these um

181
00:06:52,960 --> 00:06:58,719
sort for interfacing with the dbus

182
00:06:56,080 --> 00:06:59,359
and it's also you can call it g variant

183
00:06:58,720 --> 00:07:02,960
but not

184
00:06:59,360 --> 00:07:04,319
quite because uh g-variant is a g-lib

185
00:07:02,960 --> 00:07:08,000
api to to handle

186
00:07:04,319 --> 00:07:09,440
um this bar format but

187
00:07:08,000 --> 00:07:11,360
the people who are working on that they

188
00:07:09,440 --> 00:07:13,599
made some changes and

189
00:07:11,360 --> 00:07:15,680
the the intention was to put those

190
00:07:13,599 --> 00:07:16,080
changes back into deeper space so d bus

191
00:07:15,680 --> 00:07:18,560
itself

192
00:07:16,080 --> 00:07:20,080
will change but that didn't happen for

193
00:07:18,560 --> 00:07:22,240
some reason i don't know why

194
00:07:20,080 --> 00:07:23,199
um so yeah g variant is slightly

195
00:07:22,240 --> 00:07:25,520
different than

196
00:07:23,199 --> 00:07:26,479
the fire format of dbus but it's based

197
00:07:25,520 --> 00:07:28,400
heavily on that

198
00:07:26,479 --> 00:07:29,840
so there's a lot of similarity so at

199
00:07:28,400 --> 00:07:30,960
least you can have the same api so for

200
00:07:29,840 --> 00:07:34,799
example glib has

201
00:07:30,960 --> 00:07:37,359
d bus apis and they use g variant so you

202
00:07:34,800 --> 00:07:38,639
um you you deal with g variant and they

203
00:07:37,360 --> 00:07:41,919
convert

204
00:07:38,639 --> 00:07:45,039
behind the scene um

205
00:07:41,919 --> 00:07:45,599
so um and this this format g variant uh

206
00:07:45,039 --> 00:07:48,479
is used

207
00:07:45,599 --> 00:07:49,039
standalone as well um projects like os

208
00:07:48,479 --> 00:07:51,599
tree

209
00:07:49,039 --> 00:07:53,440
uh and flat pack and decons they're

210
00:07:51,599 --> 00:07:56,319
they're using it there are some examples

211
00:07:53,440 --> 00:07:57,599
but i think there's a lot more out there

212
00:07:56,319 --> 00:08:00,400
um

213
00:07:57,599 --> 00:08:01,120
and so what what is this of our format

214
00:08:00,400 --> 00:08:02,878
um

215
00:08:01,120 --> 00:08:05,039
it's just uh they defined a bunch of

216
00:08:02,879 --> 00:08:08,720
data types and their encodings

217
00:08:05,039 --> 00:08:11,199
um on them so in

218
00:08:08,720 --> 00:08:12,879
and since it's a binary format there's

219
00:08:11,199 --> 00:08:13,440
the alignment consideration in the

220
00:08:12,879 --> 00:08:15,440
memory

221
00:08:13,440 --> 00:08:16,560
so but it follows natural alignment so

222
00:08:15,440 --> 00:08:19,599
if you have

223
00:08:16,560 --> 00:08:21,680
unsigned integer of four bytes so the

224
00:08:19,599 --> 00:08:23,520
alignment for that is four bytes

225
00:08:21,680 --> 00:08:25,759
if it's eight bytes and it's eight bytes

226
00:08:23,520 --> 00:08:28,080
and stuff like that

227
00:08:25,759 --> 00:08:29,759
we'll see that later and each data type

228
00:08:28,080 --> 00:08:31,680
has a signature signature is just a

229
00:08:29,759 --> 00:08:34,880
string that represents that type

230
00:08:31,680 --> 00:08:38,320
um so the basic types they

231
00:08:34,880 --> 00:08:39,599
um have one character string like for

232
00:08:38,320 --> 00:08:42,640
example s

233
00:08:39,599 --> 00:08:44,000
for strings and stuff like that um but

234
00:08:42,640 --> 00:08:47,199
for complicated one you

235
00:08:44,000 --> 00:08:51,040
have like uh longer signatures

236
00:08:47,200 --> 00:08:54,080
but there's um limited to

237
00:08:51,040 --> 00:08:56,319
255 characters because we will see later

238
00:08:54,080 --> 00:08:56,320
why

239
00:08:56,480 --> 00:09:03,120
and basic types are like mapping very

240
00:08:59,600 --> 00:09:05,839
nicely to the rust basic types so it's

241
00:09:03,120 --> 00:09:07,839
that's not hard and containers kind of

242
00:09:05,839 --> 00:09:09,600
also like you have arrays which is like

243
00:09:07,839 --> 00:09:13,360
vector or an array and

244
00:09:09,600 --> 00:09:17,120
rust structure and

245
00:09:13,360 --> 00:09:19,680
dictionary is just like a hash map

246
00:09:17,120 --> 00:09:20,640
and we have another type called variant

247
00:09:19,680 --> 00:09:23,760
uh which is

248
00:09:20,640 --> 00:09:26,080
very which is a um it looks very simple

249
00:09:23,760 --> 00:09:27,680
but it's it makes things a bit hard uh

250
00:09:26,080 --> 00:09:30,399
because debus

251
00:09:27,680 --> 00:09:30,959
the format the wire format is not um

252
00:09:30,399 --> 00:09:33,760
self

253
00:09:30,959 --> 00:09:34,079
uh self defined so it's you have to have

254
00:09:33,760 --> 00:09:35,600
this

255
00:09:34,080 --> 00:09:37,519
the signature you don't need to know the

256
00:09:35,600 --> 00:09:39,200
signature or what data is in there

257
00:09:37,519 --> 00:09:42,240
what kind of data to to be able to

258
00:09:39,200 --> 00:09:45,279
decode it um so it's not self-describing

259
00:09:42,240 --> 00:09:48,640
um but this data this type is because

260
00:09:45,279 --> 00:09:51,200
for the signature for this type um

261
00:09:48,640 --> 00:09:52,319
is is dynamic so you get it in the

262
00:09:51,200 --> 00:09:54,480
encoded data

263
00:09:52,320 --> 00:09:55,360
what is actually in the in the variant

264
00:09:54,480 --> 00:09:57,200
so you can put it

265
00:09:55,360 --> 00:09:58,640
any of those types that i mentioned in

266
00:09:57,200 --> 00:10:01,200
the variant and

267
00:09:58,640 --> 00:10:02,959
you put the signature and before it and

268
00:10:01,200 --> 00:10:05,440
you send it to the other side so

269
00:10:02,959 --> 00:10:07,359
it's for dynamically typing things um

270
00:10:05,440 --> 00:10:08,800
used used quite a lot actually in on

271
00:10:07,360 --> 00:10:11,600
device

272
00:10:08,800 --> 00:10:12,160
um example so that you understand what

273
00:10:11,600 --> 00:10:15,200
the hell

274
00:10:12,160 --> 00:10:16,719
am i talking about um so let's say it is

275
00:10:15,200 --> 00:10:18,480
you have a string you want to transfer

276
00:10:16,720 --> 00:10:21,360
on in this format so

277
00:10:18,480 --> 00:10:21,839
um uh the format like like we will go

278
00:10:21,360 --> 00:10:23,920
from

279
00:10:21,839 --> 00:10:25,920
right to left oh and uh in the bottom

280
00:10:23,920 --> 00:10:29,920
you have the uh byte addresses

281
00:10:25,920 --> 00:10:33,040
uh in the message um and um

282
00:10:29,920 --> 00:10:33,599
i've highlighted the four byte boundary

283
00:10:33,040 --> 00:10:36,719
so

284
00:10:33,600 --> 00:10:40,000
you you can tell more easily what's what

285
00:10:36,720 --> 00:10:42,720
um so yeah you then string you it's

286
00:10:40,000 --> 00:10:44,000
supposed to be null terminated and uh

287
00:10:42,720 --> 00:10:47,120
just before the string

288
00:10:44,000 --> 00:10:50,560
uh you you uh you put the bite length

289
00:10:47,120 --> 00:10:51,680
it's not the um yeah sorry it's the

290
00:10:50,560 --> 00:10:53,920
length of the

291
00:10:51,680 --> 00:10:54,800
uh string but without the null byte

292
00:10:53,920 --> 00:10:58,079
that's

293
00:10:54,800 --> 00:11:00,560
uh i learned it the hard way i

294
00:10:58,079 --> 00:11:02,239
forgot about that and test kids weren't

295
00:11:00,560 --> 00:11:04,560
passing and then i found out

296
00:11:02,240 --> 00:11:06,160
um so yeah you have the length and then

297
00:11:04,560 --> 00:11:08,319
since the length is a

298
00:11:06,160 --> 00:11:10,319
is the fixed part of this string

299
00:11:08,320 --> 00:11:13,600
encoding and that's four bytes

300
00:11:10,320 --> 00:11:14,640
um you have the alignment of four bytes

301
00:11:13,600 --> 00:11:17,760
so that's why

302
00:11:14,640 --> 00:11:20,319
we needed two two bytes before it

303
00:11:17,760 --> 00:11:21,200
null bytes or padding to align it on a

304
00:11:20,320 --> 00:11:24,240
eight byte bond

305
00:11:21,200 --> 00:11:24,240
sorry four byte boundary

306
00:11:26,560 --> 00:11:30,640
and in variant it's the same um there's

307
00:11:29,760 --> 00:11:32,399
a reason i'm

308
00:11:30,640 --> 00:11:34,560
giving you these details and you'll see

309
00:11:32,399 --> 00:11:36,640
later

310
00:11:34,560 --> 00:11:37,920
you when you put a string in a variant

311
00:11:36,640 --> 00:11:39,839
it's the same if you look

312
00:11:37,920 --> 00:11:41,599
from right to left you have the null

313
00:11:39,839 --> 00:11:43,680
byte you have the string

314
00:11:41,600 --> 00:11:46,560
and you have the byte length of it and

315
00:11:43,680 --> 00:11:48,319
again you need to pad it

316
00:11:46,560 --> 00:11:50,399
and since you are putting it in a

317
00:11:48,320 --> 00:11:51,440
variant what you do is the first part is

318
00:11:50,399 --> 00:11:54,240
the signature

319
00:11:51,440 --> 00:11:56,560
of the data because you only know at

320
00:11:54,240 --> 00:11:56,880
runtime if your c decoded it you only

321
00:11:56,560 --> 00:11:58,560
know

322
00:11:56,880 --> 00:12:00,480
at runtime what what is encoded in the

323
00:11:58,560 --> 00:12:01,040
variant so you need a signature first in

324
00:12:00,480 --> 00:12:03,440
it

325
00:12:01,040 --> 00:12:04,719
and signature is encoded as in the same

326
00:12:03,440 --> 00:12:06,399
way as a string

327
00:12:04,720 --> 00:12:08,240
the only difference is that the length

328
00:12:06,399 --> 00:12:10,639
is one byte

329
00:12:08,240 --> 00:12:12,399
size so uh that is a good thing because

330
00:12:10,639 --> 00:12:16,399
then you need don't need any alignment

331
00:12:12,399 --> 00:12:18,880
because it's one bite um and

332
00:12:16,399 --> 00:12:19,839
you um yeah you but you're limited to

333
00:12:18,880 --> 00:12:21,760
255

334
00:12:19,839 --> 00:12:22,959
characters of signature but that's more

335
00:12:21,760 --> 00:12:25,279
than enough you don't

336
00:12:22,959 --> 00:12:27,518
want a complex type so complex that it's

337
00:12:25,279 --> 00:12:29,600
more than 255 characters long

338
00:12:27,519 --> 00:12:31,360
um anyway so that's that's how you

339
00:12:29,600 --> 00:12:34,399
encode a

340
00:12:31,360 --> 00:12:35,680
string in a variant so i was like

341
00:12:34,399 --> 00:12:37,760
looking at that i was like that's not so

342
00:12:35,680 --> 00:12:40,079
hard let's do it

343
00:12:37,760 --> 00:12:42,000
so i i was working on in the hack fest

344
00:12:40,079 --> 00:12:44,638
and after for three days

345
00:12:42,000 --> 00:12:45,360
and um well i was not distracted by this

346
00:12:44,639 --> 00:12:48,480
work thing

347
00:12:45,360 --> 00:12:51,279
so it went very fast and

348
00:12:48,480 --> 00:12:52,639
i i managed to do made some good

349
00:12:51,279 --> 00:12:54,000
progress in just a few days like

350
00:12:52,639 --> 00:12:57,040
established a connection

351
00:12:54,000 --> 00:12:59,360
called a method on the other side and

352
00:12:57,040 --> 00:13:00,160
i was like yeah i can do it let's let's

353
00:12:59,360 --> 00:13:03,839
do it

354
00:13:00,160 --> 00:13:06,319
cool so i decided to create a new

355
00:13:03,839 --> 00:13:08,240
library called zebus and

356
00:13:06,320 --> 00:13:11,519
why name zebus because it sounds really

357
00:13:08,240 --> 00:13:13,600
awesome so let's choose this name

358
00:13:11,519 --> 00:13:15,600
but i thought like let's start with the

359
00:13:13,600 --> 00:13:18,160
hard part the lower level so if i'm

360
00:13:15,600 --> 00:13:20,480
writing a d bus library i should write

361
00:13:18,160 --> 00:13:23,279
it completely in rust like from scratch

362
00:13:20,480 --> 00:13:23,680
and i call that part z variant because

363
00:13:23,279 --> 00:13:26,160
it

364
00:13:23,680 --> 00:13:26,719
deals with the variants it's called

365
00:13:26,160 --> 00:13:30,319
because

366
00:13:26,720 --> 00:13:32,560
g variant and all you know um

367
00:13:30,320 --> 00:13:34,959
so i had these goals in mind like how i

368
00:13:32,560 --> 00:13:36,880
would do things and i wanted to be it to

369
00:13:34,959 --> 00:13:38,800
be very efficient

370
00:13:36,880 --> 00:13:42,320
if possible even more efficient than the

371
00:13:38,800 --> 00:13:44,639
c implementation in g-lib

372
00:13:42,320 --> 00:13:46,880
which i think i'll achieve if i haven't

373
00:13:44,639 --> 00:13:49,199
already

374
00:13:46,880 --> 00:13:49,920
but the silly goal was um i wanted to be

375
00:13:49,199 --> 00:13:51,599
efficient from

376
00:13:49,920 --> 00:13:53,839
from day one and i don't think that's a

377
00:13:51,600 --> 00:13:54,160
good idea so if you ever start a project

378
00:13:53,839 --> 00:13:58,320
don't

379
00:13:54,160 --> 00:14:00,639
don't do it this way um and um

380
00:13:58,320 --> 00:14:02,000
i came up with this first trait i was

381
00:14:00,639 --> 00:14:04,880
like yeah this is the trait that

382
00:14:02,000 --> 00:14:06,480
will all the data type that can be

383
00:14:04,880 --> 00:14:07,839
encoded and decoded from

384
00:14:06,480 --> 00:14:09,839
from this format they will implement

385
00:14:07,839 --> 00:14:11,839
this uh interface

386
00:14:09,839 --> 00:14:13,279
um and as you can see there's lifetimes

387
00:14:11,839 --> 00:14:17,120
in there and that's because i wanted to

388
00:14:13,279 --> 00:14:20,480
be super efficient um

389
00:14:17,120 --> 00:14:21,600
so lots of issues of course any project

390
00:14:20,480 --> 00:14:23,920
from if you start from scratch

391
00:14:21,600 --> 00:14:27,600
especially

392
00:14:23,920 --> 00:14:27,599
loads of fun with lifetimes

393
00:14:28,839 --> 00:14:34,079
and the variant representation

394
00:14:32,000 --> 00:14:36,000
proved to be a bit challenging like the

395
00:14:34,079 --> 00:14:36,638
most natural i was thinking first was

396
00:14:36,000 --> 00:14:38,720
like

397
00:14:36,639 --> 00:14:39,680
um i can have generic type on the

398
00:14:38,720 --> 00:14:41,680
variant of

399
00:14:39,680 --> 00:14:43,120
value like have a struct signature and

400
00:14:41,680 --> 00:14:44,880
then value and

401
00:14:43,120 --> 00:14:46,560
that's it and that would be generic but

402
00:14:44,880 --> 00:14:47,040
then when you are decoding you need to

403
00:14:46,560 --> 00:14:49,040
know

404
00:14:47,040 --> 00:14:50,800
you know how do you decode like you you

405
00:14:49,040 --> 00:14:51,760
need to know the type in advance like

406
00:14:50,800 --> 00:14:54,800
the whole type

407
00:14:51,760 --> 00:14:58,000
so i did you don't exactly work so

408
00:14:54,800 --> 00:15:00,639
um i went with enums it's much better i

409
00:14:58,000 --> 00:15:00,639
think it that way

410
00:15:02,000 --> 00:15:06,240
and but eventually i dealt with all

411
00:15:04,800 --> 00:15:08,160
these problems and

412
00:15:06,240 --> 00:15:10,720
and i had test cases for each data type

413
00:15:08,160 --> 00:15:14,319
i added support for

414
00:15:10,720 --> 00:15:17,440
and it started to look really good um

415
00:15:14,320 --> 00:15:18,000
and i was like about to you know i said

416
00:15:17,440 --> 00:15:20,079
let's just

417
00:15:18,000 --> 00:15:21,519
document it and just you know release

418
00:15:20,079 --> 00:15:22,399
the first version of z variant it would

419
00:15:21,519 --> 00:15:25,920
be cool

420
00:15:22,399 --> 00:15:27,279
uh but i as soon as i added test uh the

421
00:15:25,920 --> 00:15:28,399
support for hash maps like the

422
00:15:27,279 --> 00:15:30,800
dictionary type

423
00:15:28,399 --> 00:15:32,720
uh test cases are not passing i thought

424
00:15:30,800 --> 00:15:34,959
it's a test case but it wasn't

425
00:15:32,720 --> 00:15:36,720
i'll give you a chance if you can tell

426
00:15:34,959 --> 00:15:39,199
me what is wrong with this

427
00:15:36,720 --> 00:15:41,839
um this is where it goes wrong like when

428
00:15:39,199 --> 00:15:41,839
i added

429
00:15:41,920 --> 00:15:45,040
like when i put it in a variant the

430
00:15:43,279 --> 00:15:48,720
dictionary um

431
00:15:45,040 --> 00:15:49,680
so i hit a problem um so i was looking

432
00:15:48,720 --> 00:15:52,399
at this

433
00:15:49,680 --> 00:15:53,040
and it looked right this is uh just the

434
00:15:52,399 --> 00:15:54,880
same as i

435
00:15:53,040 --> 00:15:57,199
we did a string in a variant now it's an

436
00:15:54,880 --> 00:16:00,720
array of 64

437
00:15:57,199 --> 00:16:01,680
64-bit integer in a in an array in a

438
00:16:00,720 --> 00:16:04,240
variant

439
00:16:01,680 --> 00:16:05,680
um so how you do it is the same very

440
00:16:04,240 --> 00:16:08,880
similar to the string you have the

441
00:16:05,680 --> 00:16:10,800
array itself and you have

442
00:16:08,880 --> 00:16:12,079
the elements like the first element need

443
00:16:10,800 --> 00:16:15,199
to be at least padded

444
00:16:12,079 --> 00:16:17,120
um and you have the length of the array

445
00:16:15,199 --> 00:16:18,800
in bytes by the way this is in bytes not

446
00:16:17,120 --> 00:16:21,759
in not the

447
00:16:18,800 --> 00:16:23,359
number of elements in the area and then

448
00:16:21,759 --> 00:16:24,560
the padding for the length itself and

449
00:16:23,360 --> 00:16:27,759
then the signature

450
00:16:24,560 --> 00:16:29,920
like we had with um with the string

451
00:16:27,759 --> 00:16:31,680
but this time you have like a is for

452
00:16:29,920 --> 00:16:34,479
array and t is for

453
00:16:31,680 --> 00:16:37,199
uh the 64-bit integers um so you can

454
00:16:34,480 --> 00:16:38,800
tell what is inside the variant

455
00:16:37,199 --> 00:16:41,279
uh but there is one thing that's wrong

456
00:16:38,800 --> 00:16:43,519
in here can anyone tell me what is wrong

457
00:16:41,279 --> 00:16:43,519
here

458
00:16:43,600 --> 00:16:52,000
huh no no

459
00:16:50,160 --> 00:16:53,279
what about alignment like you're not

460
00:16:52,000 --> 00:16:56,720
calculating the alignment

461
00:16:53,279 --> 00:16:58,880
correctly for the variable size

462
00:16:56,720 --> 00:16:58,880
no

463
00:17:00,399 --> 00:17:06,400
okay i'll move forward so i couldn't

464
00:17:03,199 --> 00:17:08,959
figure this out for many days right so

465
00:17:06,400 --> 00:17:09,600
and i was like back to diba's spec

466
00:17:08,959 --> 00:17:13,120
reading

467
00:17:09,599 --> 00:17:14,958
um and staring and stuff and uh figuring

468
00:17:13,119 --> 00:17:17,678
out what the hell is going on

469
00:17:14,959 --> 00:17:19,439
um till i realized that i think i'm

470
00:17:17,679 --> 00:17:20,959
wrong about the padding

471
00:17:19,439 --> 00:17:22,959
as i said like the variant does not

472
00:17:20,959 --> 00:17:24,160
require any padding itself because

473
00:17:22,959 --> 00:17:26,240
it starts with a signature and

474
00:17:24,160 --> 00:17:29,679
signatures length is one bite

475
00:17:26,240 --> 00:17:31,520
so that doesn't require any padding but

476
00:17:29,679 --> 00:17:33,280
but the more i read this pack i was

477
00:17:31,520 --> 00:17:36,960
getting more and more sure that

478
00:17:33,280 --> 00:17:39,360
the the

479
00:17:36,960 --> 00:17:41,200
array itself or the anything in the

480
00:17:39,360 --> 00:17:43,918
variant itself the value of the variant

481
00:17:41,200 --> 00:17:45,280
does not require padding either um and

482
00:17:43,919 --> 00:17:49,280
that's what what is wrong

483
00:17:45,280 --> 00:17:50,960
so i was like okay how do i fix this um

484
00:17:49,280 --> 00:17:52,559
i was like this is this needs a complete

485
00:17:50,960 --> 00:17:54,320
overhaul of the whole how the

486
00:17:52,559 --> 00:17:57,039
all the variant encoding and decoding is

487
00:17:54,320 --> 00:17:58,080
working so like okay whatever i have to

488
00:17:57,039 --> 00:18:00,400
do this

489
00:17:58,080 --> 00:18:02,399
but i first was like okay let's this

490
00:18:00,400 --> 00:18:03,120
lifetime's like each time i made any

491
00:18:02,400 --> 00:18:05,600
change

492
00:18:03,120 --> 00:18:07,120
significant change in the whole thing um

493
00:18:05,600 --> 00:18:08,480
lifetime would come on the way so i was

494
00:18:07,120 --> 00:18:10,799
like this is

495
00:18:08,480 --> 00:18:11,919
uh not good and that's why i should have

496
00:18:10,799 --> 00:18:14,720
shouldn't have started with super

497
00:18:11,919 --> 00:18:17,120
efficient implementation from day one

498
00:18:14,720 --> 00:18:18,320
um so i was like let's kill all the

499
00:18:17,120 --> 00:18:20,639
lifetimes first

500
00:18:18,320 --> 00:18:21,678
so i had the way i did it was i created

501
00:18:20,640 --> 00:18:24,080
this uh

502
00:18:21,679 --> 00:18:25,520
data type i looked around her first like

503
00:18:24,080 --> 00:18:27,120
if there is exactly like something like

504
00:18:25,520 --> 00:18:28,320
this there is cursor but cursor is not

505
00:18:27,120 --> 00:18:30,879
exactly like this

506
00:18:28,320 --> 00:18:31,439
so you this allows you to create like a

507
00:18:30,880 --> 00:18:34,559
shared

508
00:18:31,440 --> 00:18:36,400
um you can have a slice of a of a data

509
00:18:34,559 --> 00:18:38,320
and you can you know have as many slices

510
00:18:36,400 --> 00:18:40,840
as possible and pass it around

511
00:18:38,320 --> 00:18:42,399
the clones of it because it's used as a

512
00:18:40,840 --> 00:18:43,840
rc um

513
00:18:42,400 --> 00:18:46,160
and it knows its position in the whole

514
00:18:43,840 --> 00:18:48,720
buffer because the alignment is based on

515
00:18:46,160 --> 00:18:50,559
the your position in the entire buffer

516
00:18:48,720 --> 00:18:52,480
the entire messages if it's a debus

517
00:18:50,559 --> 00:18:54,320
message than the entire dbus message

518
00:18:52,480 --> 00:18:55,600
uh so you need to know where you exactly

519
00:18:54,320 --> 00:18:59,039
your you are

520
00:18:55,600 --> 00:19:00,879
at that point um

521
00:18:59,039 --> 00:19:02,960
and efficiency is not a religion so we

522
00:19:00,880 --> 00:19:04,799
can do it later it would be nice of

523
00:19:02,960 --> 00:19:07,919
course but

524
00:19:04,799 --> 00:19:10,080
so after two months of this

525
00:19:07,919 --> 00:19:11,919
lifetime killing and creating this new

526
00:19:10,080 --> 00:19:14,639
uh interface and everything

527
00:19:11,919 --> 00:19:16,320
i was done and i was like okay let's see

528
00:19:14,640 --> 00:19:16,880
the test case and i was sitting and i

529
00:19:16,320 --> 00:19:19,120
was

530
00:19:16,880 --> 00:19:20,000
about to hit enter after you know cargo

531
00:19:19,120 --> 00:19:22,799
test and

532
00:19:20,000 --> 00:19:25,840
i was like well it fast would it pass no

533
00:19:22,799 --> 00:19:25,840
it didn't pass

534
00:19:27,120 --> 00:19:33,840
so i went back to more spec reading and

535
00:19:30,160 --> 00:19:35,440
bite steering turns out it wasn't the

536
00:19:33,840 --> 00:19:37,678
padding after all you know you do need

537
00:19:35,440 --> 00:19:40,880
to pad everything

538
00:19:37,679 --> 00:19:44,559
and it was the length uh

539
00:19:40,880 --> 00:19:46,000
the length uh does not include the first

540
00:19:44,559 --> 00:19:48,240
elements padding

541
00:19:46,000 --> 00:19:50,160
the specs showed it very clearly for

542
00:19:48,240 --> 00:19:53,679
some reason i missed that

543
00:19:50,160 --> 00:19:55,760
so um so yeah um that's that's the only

544
00:19:53,679 --> 00:19:57,280
small thing i had missed previously

545
00:19:55,760 --> 00:19:59,039
and i did the whole changes and

546
00:19:57,280 --> 00:20:01,678
everything and

547
00:19:59,039 --> 00:20:02,720
it was this trivial thing and it i fixed

548
00:20:01,679 --> 00:20:06,799
it soon

549
00:20:02,720 --> 00:20:08,559
so it should be 16 because yeah

550
00:20:06,799 --> 00:20:09,918
yes so there's eight bites and then

551
00:20:08,559 --> 00:20:13,840
eight bites so that's

552
00:20:09,919 --> 00:20:13,840
16. um

553
00:20:14,080 --> 00:20:19,199
yeah trivial to fix well christmas

554
00:20:16,559 --> 00:20:22,000
holiday investment

555
00:20:19,200 --> 00:20:22,799
um i published the variant it's out

556
00:20:22,000 --> 00:20:25,520
there you can

557
00:20:22,799 --> 00:20:27,679
find it it's you know i've added docs

558
00:20:25,520 --> 00:20:31,360
too

559
00:20:27,679 --> 00:20:34,559
um it's uh you can use it in

560
00:20:31,360 --> 00:20:36,719
you know in a very easy way you can

561
00:20:34,559 --> 00:20:37,840
you just you have a very in this example

562
00:20:36,720 --> 00:20:39,600
for example you have a string you want

563
00:20:37,840 --> 00:20:41,600
to encode you tell it which format

564
00:20:39,600 --> 00:20:42,879
currently we only do dbs format so it

565
00:20:41,600 --> 00:20:46,158
doesn't matter

566
00:20:42,880 --> 00:20:49,200
um and um yeah

567
00:20:46,159 --> 00:20:52,080
and then you can decode it back

568
00:20:49,200 --> 00:20:53,440
simple um a bit slightly more

569
00:20:52,080 --> 00:20:56,559
complicated

570
00:20:53,440 --> 00:20:57,280
integer in a variant for example um same

571
00:20:56,559 --> 00:21:00,000
thing but

572
00:20:57,280 --> 00:21:02,000
you convert it to a variant and then

573
00:21:00,000 --> 00:21:02,400
encode the variant itself and then back

574
00:21:02,000 --> 00:21:04,080
to

575
00:21:02,400 --> 00:21:06,559
it and then you can get the value from

576
00:21:04,080 --> 00:21:06,559
the variant

577
00:21:07,919 --> 00:21:13,919
so don't use it yet but because

578
00:21:10,960 --> 00:21:14,400
i do want efficiency so i'm back into

579
00:21:13,919 --> 00:21:17,360
that

580
00:21:14,400 --> 00:21:18,080
and i think i'll need api breakage for

581
00:21:17,360 --> 00:21:22,000
sure

582
00:21:18,080 --> 00:21:25,280
um not just because of that but also um

583
00:21:22,000 --> 00:21:26,880
imagine what uh first issue anyone filed

584
00:21:25,280 --> 00:21:29,039
on on this great

585
00:21:26,880 --> 00:21:30,080
support for certain like why don't you

586
00:21:29,039 --> 00:21:32,000
have said the api

587
00:21:30,080 --> 00:21:33,520
so um i was looking into that and i was

588
00:21:32,000 --> 00:21:35,919
like yeah it makes sense and

589
00:21:33,520 --> 00:21:36,720
if i can make it work and i'm working on

590
00:21:35,919 --> 00:21:41,520
that

591
00:21:36,720 --> 00:21:43,120
i have an experimental branch for it um

592
00:21:41,520 --> 00:21:44,799
the main challenge with certain is that

593
00:21:43,120 --> 00:21:47,840
it's way too generic

594
00:21:44,799 --> 00:21:51,600
um so

595
00:21:47,840 --> 00:21:52,959
as i'll show you so that i have a

596
00:21:51,600 --> 00:21:55,360
proof of concept serialization

597
00:21:52,960 --> 00:21:59,120
serializer implementation already and

598
00:21:55,360 --> 00:22:02,240
it works as far as i know um but

599
00:21:59,120 --> 00:22:05,760
um if you're familiar with certain

600
00:22:02,240 --> 00:22:07,440
um usually you get like um an api like

601
00:22:05,760 --> 00:22:11,679
this where you say two bytes

602
00:22:07,440 --> 00:22:14,960
and or whatever two to write or what

603
00:22:11,679 --> 00:22:15,360
whatever is the output of the output

604
00:22:14,960 --> 00:22:18,799
type

605
00:22:15,360 --> 00:22:20,879
of the api and um

606
00:22:18,799 --> 00:22:22,559
but the only difference is that i am

607
00:22:20,880 --> 00:22:26,080
requiring another trait

608
00:22:22,559 --> 00:22:29,200
uh from the the type you want to encode

609
00:22:26,080 --> 00:22:30,720
or later decode as well um and the

610
00:22:29,200 --> 00:22:34,240
reason is that i need the signature

611
00:22:30,720 --> 00:22:36,960
at the moment at least um so

612
00:22:34,240 --> 00:22:38,320
i'm trying my best to i mean because

613
00:22:36,960 --> 00:22:38,799
otherwise what's the point of certain

614
00:22:38,320 --> 00:22:41,280
because

615
00:22:38,799 --> 00:22:43,280
it said that you should be able anything

616
00:22:41,280 --> 00:22:44,399
that implements the service serialize or

617
00:22:43,280 --> 00:22:46,879
deserialize

618
00:22:44,400 --> 00:22:48,640
that type should be serializable by all

619
00:22:46,880 --> 00:22:50,080
the crates that implement certain

620
00:22:48,640 --> 00:22:52,080
and that's the whole point of it is

621
00:22:50,080 --> 00:22:54,240
generic um

622
00:22:52,080 --> 00:22:56,080
so i i don't see by much point of

623
00:22:54,240 --> 00:22:58,880
providing saturday if i can't

624
00:22:56,080 --> 00:23:00,399
uh remove this limitation so i'm i'm

625
00:22:58,880 --> 00:23:02,080
working on it

626
00:23:00,400 --> 00:23:04,080
even if i provide a macro right like

627
00:23:02,080 --> 00:23:06,399
like like certain provides

628
00:23:04,080 --> 00:23:08,240
easy derived macros so you can put it on

629
00:23:06,400 --> 00:23:10,400
your custom type and

630
00:23:08,240 --> 00:23:12,240
it has serialized and deseries then so

631
00:23:10,400 --> 00:23:14,080
you can add one more but

632
00:23:12,240 --> 00:23:15,679
just for my crate you would add that

633
00:23:14,080 --> 00:23:18,080
that's weird so

634
00:23:15,679 --> 00:23:19,039
um yeah i'm really trying hard to avoid

635
00:23:18,080 --> 00:23:22,000
that

636
00:23:19,039 --> 00:23:23,520
yeah drop it and once i have that and

637
00:23:22,000 --> 00:23:24,720
i'll look into deserializer i looked a

638
00:23:23,520 --> 00:23:26,240
bit but i haven't done any

639
00:23:24,720 --> 00:23:28,400
implementation

640
00:23:26,240 --> 00:23:29,919
um and i think the byte order should be

641
00:23:28,400 --> 00:23:32,960
configurable right now i just

642
00:23:29,919 --> 00:23:34,559
assume native byte order it works fine

643
00:23:32,960 --> 00:23:35,600
with dbus because you know it's on the

644
00:23:34,559 --> 00:23:39,360
same

645
00:23:35,600 --> 00:23:42,639
machine um and

646
00:23:39,360 --> 00:23:46,080
g variant support shouldn't be that hard

647
00:23:42,640 --> 00:23:49,120
but fingers crossed and a few

648
00:23:46,080 --> 00:23:50,000
goodies like that right nj variant yeah

649
00:23:49,120 --> 00:23:51,918
zebra and i mean

650
00:23:50,000 --> 00:23:53,279
and also large area handling uh i've

651
00:23:51,919 --> 00:23:55,039
i've been told like a lot

652
00:23:53,279 --> 00:23:56,880
some of the projects at least os tree

653
00:23:55,039 --> 00:23:59,200
for example um store

654
00:23:56,880 --> 00:24:00,720
like a large array in a file with which

655
00:23:59,200 --> 00:24:02,320
is

656
00:24:00,720 --> 00:24:05,520
variant it's in the g variant format but

657
00:24:02,320 --> 00:24:07,520
it's a large array and it's not ideal to

658
00:24:05,520 --> 00:24:08,879
have to load at all to decode it it's

659
00:24:07,520 --> 00:24:10,158
it's not ideal at all

660
00:24:08,880 --> 00:24:12,159
so i would like to have some kind of

661
00:24:10,159 --> 00:24:14,559
streaming api that you

662
00:24:12,159 --> 00:24:16,880
can pretty easily like you say i want to

663
00:24:14,559 --> 00:24:19,200
read from index this to this and

664
00:24:16,880 --> 00:24:20,480
that's the you know elements you get

665
00:24:19,200 --> 00:24:23,520
from the array

666
00:24:20,480 --> 00:24:26,880
um directly from file

667
00:24:23,520 --> 00:24:29,918
um so yeah back to what i want to

668
00:24:26,880 --> 00:24:31,840
have um so i already have some

669
00:24:29,919 --> 00:24:32,320
implementation i haven't released zebus

670
00:24:31,840 --> 00:24:34,879
yet

671
00:24:32,320 --> 00:24:36,158
at all because z variant is not

672
00:24:34,880 --> 00:24:38,640
finalized yet

673
00:24:36,159 --> 00:24:39,840
um but this is how it currently looks

674
00:24:38,640 --> 00:24:42,640
like and it would look something like

675
00:24:39,840 --> 00:24:45,439
similar on the lower level at least

676
00:24:42,640 --> 00:24:46,799
so you have you establish a connection

677
00:24:45,440 --> 00:24:50,320
you tell it which

678
00:24:46,799 --> 00:24:51,520
um which service then which objects you

679
00:24:50,320 --> 00:24:53,918
want to talk to

680
00:24:51,520 --> 00:24:55,360
and you tell it the interface and then

681
00:24:53,919 --> 00:24:59,360
the method and stuff

682
00:24:55,360 --> 00:25:01,678
and that's how you call a method um

683
00:24:59,360 --> 00:25:03,120
and then you get a reply and then you

684
00:25:01,679 --> 00:25:05,200
it's very it's based on

685
00:25:03,120 --> 00:25:06,158
z variant like variant api that i just

686
00:25:05,200 --> 00:25:08,640
showed

687
00:25:06,159 --> 00:25:09,279
so yeah this is the standard interface

688
00:25:08,640 --> 00:25:11,760
that

689
00:25:09,279 --> 00:25:13,600
uh d bus any device broker on your

690
00:25:11,760 --> 00:25:17,679
machine will implement so you can

691
00:25:13,600 --> 00:25:17,678
use it um

692
00:25:18,640 --> 00:25:22,880
in terms of debuss after i have all that

693
00:25:20,960 --> 00:25:24,480
i need to do a few things like receiving

694
00:25:22,880 --> 00:25:27,840
messages maybe

695
00:25:24,480 --> 00:25:30,640
so yeah and

696
00:25:27,840 --> 00:25:31,279
signals this is not just methods um

697
00:25:30,640 --> 00:25:34,159
async

698
00:25:31,279 --> 00:25:34,799
i want uh i'll hopefully it will be

699
00:25:34,159 --> 00:25:37,840
async

700
00:25:34,799 --> 00:25:41,600
just async std-based because it's

701
00:25:37,840 --> 00:25:44,799
it's the coolest api i see for

702
00:25:41,600 --> 00:25:48,158
async and rust um

703
00:25:44,799 --> 00:25:49,918
and um a high level api then like once i

704
00:25:48,159 --> 00:25:52,159
have the low level so

705
00:25:49,919 --> 00:25:52,960
um so that you can work with objects for

706
00:25:52,159 --> 00:25:54,880
i'll mod

707
00:25:52,960 --> 00:25:56,240
i want to model it after glib's api

708
00:25:54,880 --> 00:25:58,480
where you

709
00:25:56,240 --> 00:26:00,000
if you are a client you create a proxy

710
00:25:58,480 --> 00:26:02,240
object for a specific

711
00:26:00,000 --> 00:26:03,840
uh object on a specific interface and

712
00:26:02,240 --> 00:26:05,279
then you can call different methods or

713
00:26:03,840 --> 00:26:07,760
get read properties from it

714
00:26:05,279 --> 00:26:08,320
and it even caches the properties local

715
00:26:07,760 --> 00:26:11,440
like on

716
00:26:08,320 --> 00:26:13,439
on your site um and

717
00:26:11,440 --> 00:26:16,000
in terms of server you have something

718
00:26:13,440 --> 00:26:19,279
similar you have server object and

719
00:26:16,000 --> 00:26:20,720
you add interface to it um and

720
00:26:19,279 --> 00:26:22,960
yeah and then you implement those

721
00:26:20,720 --> 00:26:25,679
methods like anything

722
00:26:22,960 --> 00:26:28,480
like any trade so it will be trade based

723
00:26:25,679 --> 00:26:28,480
on the server side

724
00:26:29,120 --> 00:26:32,719
um code generation a lot of projects out

725
00:26:32,000 --> 00:26:34,640
there they use

726
00:26:32,720 --> 00:26:35,840
like if especially client side they use

727
00:26:34,640 --> 00:26:38,880
code generation

728
00:26:35,840 --> 00:26:42,080
um because nobody has time to you know

729
00:26:38,880 --> 00:26:45,279
write individual uh interfaces um and

730
00:26:42,080 --> 00:26:46,639
like uh yeah so it's it's harder if you

731
00:26:45,279 --> 00:26:50,400
don't use code generation

732
00:26:46,640 --> 00:26:53,840
and in g-lab there's the gt bus code gen

733
00:26:50,400 --> 00:26:55,679
uh which is really cool um and i think

734
00:26:53,840 --> 00:26:56,959
you cute has something similar i never

735
00:26:55,679 --> 00:27:00,640
managed to use it but

736
00:26:56,960 --> 00:27:02,400
it's it's there uh

737
00:27:00,640 --> 00:27:04,559
maybe also macros that would be cool

738
00:27:02,400 --> 00:27:07,840
some people asked for it

739
00:27:04,559 --> 00:27:09,360
so that it's uh i worked previously on a

740
00:27:07,840 --> 00:27:12,080
language called walla and it has

741
00:27:09,360 --> 00:27:12,959
like syntax special syntax for uh doing

742
00:27:12,080 --> 00:27:15,279
um

743
00:27:12,960 --> 00:27:16,320
dbus uh server and client-side

744
00:27:15,279 --> 00:27:18,960
implementation

745
00:27:16,320 --> 00:27:22,799
which makes it really convenient um so

746
00:27:18,960 --> 00:27:22,799
macros would allow for something similar

747
00:27:24,559 --> 00:27:35,840
and a lot of other easy stuff

748
00:27:28,240 --> 00:27:35,840
that's it sorry i'm done early

749
00:27:45,279 --> 00:27:50,559
i'm not answering question was if uh zed

750
00:27:49,039 --> 00:27:52,799
bus stands for

751
00:27:50,559 --> 00:27:53,770
zhishan first of all it's zebras not zed

752
00:27:52,799 --> 00:27:56,639
but

753
00:27:53,770 --> 00:28:00,320
[Laughter]

754
00:27:56,640 --> 00:28:02,559
that that that gives you a hint right

755
00:28:00,320 --> 00:28:04,320
i did not fully understand what the

756
00:28:02,559 --> 00:28:07,600
great difference is with the current

757
00:28:04,320 --> 00:28:08,879
uh so there dude so

758
00:28:07,600 --> 00:28:11,279
the question is what's the big

759
00:28:08,880 --> 00:28:14,640
difference between this and the current

760
00:28:11,279 --> 00:28:16,960
debus rs crate right um the first one is

761
00:28:14,640 --> 00:28:19,840
that it doesn't depend on

762
00:28:16,960 --> 00:28:20,320
the c library the lib debuss um which is

763
00:28:19,840 --> 00:28:23,039
not just

764
00:28:20,320 --> 00:28:23,760
that it's in c but it's also the api is

765
00:28:23,039 --> 00:28:26,960
not

766
00:28:23,760 --> 00:28:27,760
that nice and it shows in in the rest

767
00:28:26,960 --> 00:28:30,799
api that

768
00:28:27,760 --> 00:28:32,559
the wrap the wrapper api so it would be

769
00:28:30,799 --> 00:28:33,840
good to break away from from that for

770
00:28:32,559 --> 00:28:36,559
multiple reasons

771
00:28:33,840 --> 00:28:37,840
and yeah so the whole reason i started

772
00:28:36,559 --> 00:28:40,480
with the whole effort was

773
00:28:37,840 --> 00:28:42,158
i want something very safe so and if you

774
00:28:40,480 --> 00:28:42,799
depend on a c library for your main

775
00:28:42,159 --> 00:28:46,399
thing

776
00:28:42,799 --> 00:28:46,399
it won't be very safe so

777
00:28:48,880 --> 00:28:51,520
yes yeah

778
00:28:52,000 --> 00:28:55,440
the first one is like you mentioned os3

779
00:28:54,320 --> 00:28:57,200
and larger rays

780
00:28:55,440 --> 00:28:59,520
and i think that what they usually do

781
00:28:57,200 --> 00:29:03,520
it's kind of like an idiom

782
00:28:59,520 --> 00:29:06,639
os3 is the memory map like this large

783
00:29:03,520 --> 00:29:08,080
body and stuff yeah memory and then just

784
00:29:06,640 --> 00:29:09,840
the code out of that and they

785
00:29:08,080 --> 00:29:11,678
by like this large blob they're

786
00:29:09,840 --> 00:29:13,199
basically just like pointers

787
00:29:11,679 --> 00:29:14,799
yeah i think that in our case like it

788
00:29:13,200 --> 00:29:17,600
makes sense to like slice

789
00:29:14,799 --> 00:29:18,399
references to this memory map area if

790
00:29:17,600 --> 00:29:20,158
you can

791
00:29:18,399 --> 00:29:22,239
yeah when you're on this that's that's a

792
00:29:20,159 --> 00:29:24,240
comment another question which is

793
00:29:22,240 --> 00:29:26,000
um do you know like how different the

794
00:29:24,240 --> 00:29:28,240
body and stuff

795
00:29:26,000 --> 00:29:30,159
can i first repeat for the recording or

796
00:29:28,240 --> 00:29:33,760
streaming

797
00:29:30,159 --> 00:29:36,000
what was that uh for the for the every

798
00:29:33,760 --> 00:29:37,520
now there was this um look i said that

799
00:29:36,000 --> 00:29:39,919
there's a

800
00:29:37,520 --> 00:29:41,279
usually in for example an os tree where

801
00:29:39,919 --> 00:29:43,840
you have the large arrays

802
00:29:41,279 --> 00:29:45,039
um they just use memory mapping for they

803
00:29:43,840 --> 00:29:46,720
map the whole file and

804
00:29:45,039 --> 00:29:48,480
then they can read whatever part they

805
00:29:46,720 --> 00:29:50,799
want to read and that's the way

806
00:29:48,480 --> 00:29:55,840
the person was like do you know how much

807
00:29:50,799 --> 00:29:55,840
difference that is between the parties

808
00:29:56,960 --> 00:30:00,159
the variant part is the same as for as i

809
00:29:58,960 --> 00:30:03,200
know it's the

810
00:30:00,159 --> 00:30:05,279
arrays and it's the other uh

811
00:30:03,200 --> 00:30:06,840
data types that are encoded a bit

812
00:30:05,279 --> 00:30:09,840
differently

813
00:30:06,840 --> 00:30:09,840
um

814
00:30:12,720 --> 00:30:16,480
i'm pretty confident that the api i have

815
00:30:15,679 --> 00:30:19,919
it will not

816
00:30:16,480 --> 00:30:23,840
need to change um so it should be

817
00:30:19,919 --> 00:30:23,840
should be good

818
00:30:23,919 --> 00:30:27,840
so i i have a small uh

819
00:30:28,240 --> 00:30:31,360
piece of code that i need to write at

820
00:30:30,720 --> 00:30:33,039
some point

821
00:30:31,360 --> 00:30:34,399
just to retrieve a couple of numbers

822
00:30:33,039 --> 00:30:37,520
from modem manager

823
00:30:34,399 --> 00:30:38,959
over uh over d-bus um i know i was gonna

824
00:30:37,520 --> 00:30:42,320
do it for us because

825
00:30:38,960 --> 00:30:44,720
why not um and i just wondered if you

826
00:30:42,320 --> 00:30:48,320
had any sort of rough feel for

827
00:30:44,720 --> 00:30:49,120
when this would be uh the right crate to

828
00:30:48,320 --> 00:30:52,240
pick

829
00:30:49,120 --> 00:30:54,879
versus the existing one

830
00:30:52,240 --> 00:30:55,840
so yeah the question is if i can provide

831
00:30:54,880 --> 00:30:58,960
a rough estimate

832
00:30:55,840 --> 00:31:02,158
uh on when z bus will be ready for

833
00:30:58,960 --> 00:31:06,880
consumption yeah basic functionality

834
00:31:02,159 --> 00:31:09,519
depends on what basic means but um

835
00:31:06,880 --> 00:31:10,480
i would say uh ideally i think i should

836
00:31:09,519 --> 00:31:13,840
be done

837
00:31:10,480 --> 00:31:16,080
by summer but you need to keep in mind

838
00:31:13,840 --> 00:31:19,600
it's my spare time thing so

839
00:31:16,080 --> 00:31:22,559
it depends on a lot of things and um

840
00:31:19,600 --> 00:31:22,559
i have a life too so

841
00:31:26,559 --> 00:31:30,080
everything goes in there straight away

842
00:31:29,360 --> 00:31:32,479
yes yeah yeah

843
00:31:30,080 --> 00:31:33,199
i i even my experimental branches isn't

844
00:31:32,480 --> 00:31:36,480
there

845
00:31:33,200 --> 00:31:39,279
so um but on the deepest side

846
00:31:36,480 --> 00:31:39,840
like when i changed the z variant api it

847
00:31:39,279 --> 00:31:42,399
wouldn't be

848
00:31:39,840 --> 00:31:43,600
such a big change so if you want to

849
00:31:42,399 --> 00:31:46,719
accelerate things

850
00:31:43,600 --> 00:31:47,840
please do contribute if you can and we

851
00:31:46,720 --> 00:31:49,519
can collaborate

852
00:31:47,840 --> 00:31:51,840
uh there was already one person after

853
00:31:49,519 --> 00:31:55,120
rustfest they contributed some patch

854
00:31:51,840 --> 00:31:55,918
um and was nice and yeah so it's already

855
00:31:55,120 --> 00:31:58,559
possible

856
00:31:55,919 --> 00:32:00,960
and i will handle when once the zebra

857
00:31:58,559 --> 00:32:04,240
api changes and you have to port it i'll

858
00:32:00,960 --> 00:32:04,240
do the porting so don't worry about it

859
00:32:05,919 --> 00:32:09,919
yeah i i only expect it to grow like

860
00:32:08,480 --> 00:32:15,200
it's the existing api

861
00:32:09,919 --> 00:32:18,399
won't change much as i don't think so

862
00:32:15,200 --> 00:32:19,440
any other question now as you have done

863
00:32:18,399 --> 00:32:21,518
our larger rust

864
00:32:19,440 --> 00:32:23,200
project and had some problems finding

865
00:32:21,519 --> 00:32:25,120
errors i

866
00:32:23,200 --> 00:32:27,679
would like to ask you if you have some

867
00:32:25,120 --> 00:32:29,918
tips on debugging rust programs

868
00:32:27,679 --> 00:32:31,440
because what i'm currently doing is

869
00:32:29,919 --> 00:32:33,200
including a ton of print lines and then

870
00:32:31,440 --> 00:32:34,640
removing them again when the release is

871
00:32:33,200 --> 00:32:38,320
rolling out and that's sort of

872
00:32:34,640 --> 00:32:41,440
primitive i i did that too to be honest

873
00:32:38,320 --> 00:32:43,279
um yeah the

874
00:32:41,440 --> 00:32:44,960
one of the things like if you go to the

875
00:32:43,279 --> 00:32:47,519
channels the the

876
00:32:44,960 --> 00:32:48,320
discord channel and irc channel there's

877
00:32:47,519 --> 00:32:51,519
a lot of

878
00:32:48,320 --> 00:32:52,960
really helpful people there so i paste

879
00:32:51,519 --> 00:32:55,519
quotes in somewhere in the

880
00:32:52,960 --> 00:32:56,159
the playground ross playground and i ask

881
00:32:55,519 --> 00:32:58,880
and they

882
00:32:56,159 --> 00:33:00,159
usually there is an answer so that for

883
00:32:58,880 --> 00:33:01,919
me that helps a lot

884
00:33:00,159 --> 00:33:03,360
and the only thing is that you need to

885
00:33:01,919 --> 00:33:06,399
create like a small

886
00:33:03,360 --> 00:33:08,719
test case for your for your issue

887
00:33:06,399 --> 00:33:09,518
that is doesn't involve all the details

888
00:33:08,720 --> 00:33:11,440
that you

889
00:33:09,519 --> 00:33:13,039
that are specific to your project so if

890
00:33:11,440 --> 00:33:15,360
you can create a sample code

891
00:33:13,039 --> 00:33:16,399
it really really helps a lot to get help

892
00:33:15,360 --> 00:33:21,039
on on your issue

893
00:33:16,399 --> 00:33:24,719
specification i just want to add to this

894
00:33:21,039 --> 00:33:27,760
comment you can use the dpt

895
00:33:24,720 --> 00:33:28,640
macro and it returns the contained value

896
00:33:27,760 --> 00:33:31,039
so

897
00:33:28,640 --> 00:33:34,640
no need for extra print line um

898
00:33:31,039 --> 00:33:38,960
statements just put dbg around

899
00:33:34,640 --> 00:33:38,960
parameters or return values

900
00:33:50,840 --> 00:33:55,678
sorry uh so the

901
00:33:53,840 --> 00:33:57,519
question the well it was more like a

902
00:33:55,679 --> 00:34:00,720
suggestion how to

903
00:33:57,519 --> 00:34:03,760
how to make it debugging uh easier

904
00:34:00,720 --> 00:34:07,840
and there's this tbg macro that

905
00:34:03,760 --> 00:34:07,840
helps with you know

906
00:34:15,359 --> 00:34:20,078
you started out saying that you wanted

907
00:34:18,480 --> 00:34:23,040
to make things go really fast

908
00:34:20,079 --> 00:34:24,720
by using lifetimes to make sure that

909
00:34:23,040 --> 00:34:26,000
data structures are in one place and

910
00:34:24,719 --> 00:34:28,078
prevent copying

911
00:34:26,000 --> 00:34:31,839
and then you found it very difficult to

912
00:34:28,079 --> 00:34:34,240
maintain so you ripped it all out

913
00:34:31,839 --> 00:34:35,520
it seems to be a common progression and

914
00:34:34,239 --> 00:34:37,918
change amongst

915
00:34:35,520 --> 00:34:39,440
developers are there any other

916
00:34:37,918 --> 00:34:41,598
experiences that you had that

917
00:34:39,440 --> 00:34:43,040
you you began trying to use all the rust

918
00:34:41,599 --> 00:34:46,399
features and then you

919
00:34:43,040 --> 00:34:48,719
sold them out i think the speaker before

920
00:34:46,399 --> 00:34:50,960
said we were going to use generics

921
00:34:48,719 --> 00:34:52,000
all the time and then he said that

922
00:34:50,960 --> 00:34:54,159
wasn't a good idea

923
00:34:52,000 --> 00:34:56,800
do you have any other suggestions that

924
00:34:54,159 --> 00:34:56,800
you could think of

925
00:34:57,839 --> 00:35:02,240
no that first i would like to clarify

926
00:35:00,320 --> 00:35:05,440
your question

927
00:35:02,240 --> 00:35:05,439
do you have to repeat right

928
00:35:06,160 --> 00:35:09,680
yeah the question is if i have a tips

929
00:35:07,760 --> 00:35:13,200
about like as i said like

930
00:35:09,680 --> 00:35:16,480
i removed um uh the

931
00:35:13,200 --> 00:35:18,319
lifetimes and then it was easier to to

932
00:35:16,480 --> 00:35:19,599
change things um if i have any

933
00:35:18,320 --> 00:35:21,040
suggestion of any other

934
00:35:19,599 --> 00:35:23,119
similar examples right that's what the

935
00:35:21,040 --> 00:35:24,640
question is uh the first of all i would

936
00:35:23,119 --> 00:35:25,839
clarify that i'll remove the lifetime

937
00:35:24,640 --> 00:35:29,200
temporarily

938
00:35:25,839 --> 00:35:31,680
um i want to you know first change

939
00:35:29,200 --> 00:35:32,879
because i was doing a lot of changes so

940
00:35:31,680 --> 00:35:35,520
that was on the way

941
00:35:32,880 --> 00:35:36,160
so once i have done that then i can put

942
00:35:35,520 --> 00:35:37,680
it back

943
00:35:36,160 --> 00:35:40,000
so it's not like i've removed it

944
00:35:37,680 --> 00:35:41,680
permanently so but

945
00:35:40,000 --> 00:35:43,280
apart from that i don't think there's

946
00:35:41,680 --> 00:35:46,319
any other things that i had to remove

947
00:35:43,280 --> 00:35:47,359
to to make things easier um but

948
00:35:46,320 --> 00:35:50,079
certainly i would

949
00:35:47,359 --> 00:35:51,839
comment that a lot of times uh rest

950
00:35:50,079 --> 00:35:54,160
developers tell you like yeah don't

951
00:35:51,839 --> 00:35:55,599
don't mess with lifetimes and you don't

952
00:35:54,160 --> 00:35:56,720
need to know about lifetimes

953
00:35:55,599 --> 00:35:59,280
i don't think that's true you need to

954
00:35:56,720 --> 00:36:01,839
know about lifetimes if you want to

955
00:35:59,280 --> 00:36:04,640
do really good just you know code you

956
00:36:01,839 --> 00:36:04,640
know if you want to quote it

957
00:36:11,200 --> 00:36:14,640
to be better rust and not the energy

958
00:36:13,200 --> 00:36:17,279
based application

959
00:36:14,640 --> 00:36:19,920
on the client side i'd expect that um

960
00:36:17,280 --> 00:36:21,839
you'd end up using the geocompliant in

961
00:36:19,920 --> 00:36:23,520
gtk based applications for example which

962
00:36:21,839 --> 00:36:26,960
will already have their own

963
00:36:23,520 --> 00:36:26,960
device connection via

964
00:36:30,720 --> 00:36:38,240
uh the question is uh since uh

965
00:36:33,839 --> 00:36:39,440
the i will only oxidize the server side

966
00:36:38,240 --> 00:36:40,959
of geoclue

967
00:36:39,440 --> 00:36:43,359
and not the client side which is a

968
00:36:40,960 --> 00:36:46,640
library um which is gtk

969
00:36:43,359 --> 00:36:47,759
sorry based and it's very good for glib

970
00:36:46,640 --> 00:36:49,839
applications out there

971
00:36:47,760 --> 00:36:51,200
and also it's good for other languages

972
00:36:49,839 --> 00:36:54,960
too because of the

973
00:36:51,200 --> 00:36:57,200
object inspection and stuff um

974
00:36:54,960 --> 00:36:58,880
yeah if there would be any problems

975
00:36:57,200 --> 00:37:01,520
having these two different worlds

976
00:36:58,880 --> 00:37:02,240
in the same repository um no i don't

977
00:37:01,520 --> 00:37:04,400
think

978
00:37:02,240 --> 00:37:06,160
there will be any problems and the good

979
00:37:04,400 --> 00:37:07,520
thing is that the geoclue service is

980
00:37:06,160 --> 00:37:08,000
quite standalone the code is pretty

981
00:37:07,520 --> 00:37:23,839
standalone

982
00:37:08,000 --> 00:37:23,839
so i know i don't expect any problems

983
00:37:29,359 --> 00:37:35,759
yeah so the question is if um

984
00:37:32,480 --> 00:37:38,240
if the recommended method for the apps

985
00:37:35,760 --> 00:37:38,880
that are written in rust would it be to

986
00:37:38,240 --> 00:37:42,000
use

987
00:37:38,880 --> 00:37:44,400
this micrate the rust crate

988
00:37:42,000 --> 00:37:45,200
uh for to talk debuss or to still use

989
00:37:44,400 --> 00:37:49,599
the

990
00:37:45,200 --> 00:37:52,480
the g based c api i provide

991
00:37:49,599 --> 00:37:54,400
i know i think it's up to them but if i

992
00:37:52,480 --> 00:37:57,200
get to the code generation and macros

993
00:37:54,400 --> 00:37:57,839
then it would be super easy to you know

994
00:37:57,200 --> 00:38:00,000
um

995
00:37:57,839 --> 00:38:02,078
create the interface needed to talk to

996
00:38:00,000 --> 00:38:04,640
geoclue so then they can just use

997
00:38:02,079 --> 00:38:05,280
use that and i think that's what they

998
00:38:04,640 --> 00:38:07,839
should use

999
00:38:05,280 --> 00:38:07,839
ideally

1000
00:38:17,119 --> 00:38:20,800
to yes decode the sequence of the

1001
00:38:19,680 --> 00:38:23,200
message that i got back

1002
00:38:20,800 --> 00:38:23,839
from the other end so i don't know if

1003
00:38:23,200 --> 00:38:26,960
it's possible

1004
00:38:23,839 --> 00:38:30,400
to fight for variance at least and maybe

1005
00:38:26,960 --> 00:38:31,200
to make it deeper whatever you know

1006
00:38:30,400 --> 00:38:32,640
about the message

1007
00:38:31,200 --> 00:38:35,040
so that i can see you i am not getting

1008
00:38:32,640 --> 00:38:35,040
results

1009
00:38:36,880 --> 00:38:41,359
if that's possible i don't know um

1010
00:38:40,160 --> 00:38:45,200
i'm not sure if i understood the

1011
00:38:41,359 --> 00:38:47,680
question like you want

1012
00:38:45,200 --> 00:38:49,680
the z variant to to be able to tell you

1013
00:38:47,680 --> 00:38:53,759
about the data that is contained

1014
00:38:49,680 --> 00:38:55,440
uh if it is um if it's a variant type

1015
00:38:53,760 --> 00:38:58,079
then yeah of course you will you have

1016
00:38:55,440 --> 00:39:00,320
the signature encoded in the data

1017
00:38:58,079 --> 00:39:01,680
but if it's not a variant type then you

1018
00:39:00,320 --> 00:39:04,800
don't have the signature

1019
00:39:01,680 --> 00:39:05,598
at all so you yeah you can't you can't

1020
00:39:04,800 --> 00:39:07,440
do that

1021
00:39:05,599 --> 00:39:09,040
um but if you know the interface you

1022
00:39:07,440 --> 00:39:09,839
know which signature it would be then

1023
00:39:09,040 --> 00:39:14,720
yeah

1024
00:39:09,839 --> 00:39:18,078
you can

1025
00:39:14,720 --> 00:39:23,839
uh no

1026
00:39:18,079 --> 00:39:29,839
i don't think so thank you very much

1027
00:39:23,839 --> 00:39:29,839
thank you

1028
00:39:30,160 --> 00:39:32,240
you

