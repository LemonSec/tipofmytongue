1
00:00:05,200 --> 00:00:08,080
and our next talk is related to the

2
00:00:06,799 --> 00:00:11,440
previous one this one we're talking

3
00:00:08,080 --> 00:00:11,440
about the encoder please welcome

4
00:00:14,920 --> 00:00:20,080
luka so

5
00:00:16,720 --> 00:00:23,439
hi everybody uh

6
00:00:20,080 --> 00:00:26,320
we did talk a bit of a talk for

7
00:00:23,439 --> 00:00:27,680
the coding and now i'm presenting um

8
00:00:26,320 --> 00:00:31,519
encoder

9
00:00:27,680 --> 00:00:32,719
so i'm a contributor for both david and

10
00:00:31,519 --> 00:00:35,040
ravi

11
00:00:32,719 --> 00:00:36,640
among the other open source software

12
00:00:35,040 --> 00:00:40,239
here are the contacts if you want to

13
00:00:36,640 --> 00:00:43,680
ask me question after uh

14
00:00:40,239 --> 00:00:46,480
so i will talk about everyone

15
00:00:43,680 --> 00:00:48,000
a lot about ravi probably i will mention

16
00:00:46,480 --> 00:00:51,919
rust a couple of times

17
00:00:48,000 --> 00:00:53,760
i won't be too preachy i will

18
00:00:51,920 --> 00:00:55,280
talk a little about memory performance

19
00:00:53,760 --> 00:00:59,839
profiling on linux

20
00:00:55,280 --> 00:00:59,840
if you went where with a previous talk

21
00:01:00,079 --> 00:01:04,000
you probably already know what i'm going

22
00:01:01,840 --> 00:01:07,840
to say

23
00:01:04,000 --> 00:01:10,560
this won't be about many details

24
00:01:07,840 --> 00:01:13,040
because i don't have enough time and

25
00:01:10,560 --> 00:01:17,119
it's mostly about road maps

26
00:01:13,040 --> 00:01:20,080
so interact me anytime ask me question

27
00:01:17,119 --> 00:01:20,960
i will try to answer so i hope you will

28
00:01:20,080 --> 00:01:24,400
have fun

29
00:01:20,960 --> 00:01:28,158
first ravi and everyone encoder

30
00:01:24,400 --> 00:01:30,640
is written in rust strange we know

31
00:01:28,159 --> 00:01:31,280
it does have a lot of our specific

32
00:01:30,640 --> 00:01:34,560
assembly

33
00:01:31,280 --> 00:01:38,320
because we are importing it from david

34
00:01:34,560 --> 00:01:40,320
and since we are using rust

35
00:01:38,320 --> 00:01:42,639
if you want to try it it's quite easy to

36
00:01:40,320 --> 00:01:43,758
do that you just use cargo and you have

37
00:01:42,640 --> 00:01:47,040
it

38
00:01:43,759 --> 00:01:49,680
if you are more traditional

39
00:01:47,040 --> 00:01:51,200
you can enjoy it from streamer ffmpeg

40
00:01:49,680 --> 00:01:54,399
and pretty much

41
00:01:51,200 --> 00:01:57,119
any software that could consume rc or a

42
00:01:54,399 --> 00:01:57,119
rust api

43
00:01:57,200 --> 00:02:01,520
so gravity has to be fast feature full

44
00:02:00,159 --> 00:02:06,000
and safe

45
00:02:01,520 --> 00:02:09,598
uh how far we are let's see

46
00:02:06,000 --> 00:02:12,800
so dramatis already presented

47
00:02:09,598 --> 00:02:16,319
what everyone is who is involved

48
00:02:12,800 --> 00:02:18,319
so i can skip all of this

49
00:02:16,319 --> 00:02:20,079
because i know that all of you were

50
00:02:18,319 --> 00:02:23,119
before

51
00:02:20,080 --> 00:02:26,080
so the summary is

52
00:02:23,120 --> 00:02:27,599
everyone we are pretty well positioned

53
00:02:26,080 --> 00:02:30,800
for the decoding side

54
00:02:27,599 --> 00:02:33,920
because of david uh

55
00:02:30,800 --> 00:02:37,280
we have support for all the browsers

56
00:02:33,920 --> 00:02:40,958
again because of david mainly

57
00:02:37,280 --> 00:02:44,560
and this part is a

58
00:02:40,959 --> 00:02:48,000
sort of down problem besides 10 bits but

59
00:02:44,560 --> 00:02:50,640
works being done

60
00:02:48,000 --> 00:02:51,840
and we have hardware so all is good

61
00:02:50,640 --> 00:02:54,160
right

62
00:02:51,840 --> 00:02:54,879
well encoding is a different story

63
00:02:54,160 --> 00:02:58,319
encoding

64
00:02:54,879 --> 00:03:02,640
is normally hard if we consider the past

65
00:02:58,319 --> 00:03:06,159
history x264 about seven years to be

66
00:03:02,640 --> 00:03:09,440
the great encoder that it is h265

67
00:03:06,159 --> 00:03:10,239
another good project to be a good

68
00:03:09,440 --> 00:03:13,519
competitor

69
00:03:10,239 --> 00:03:17,360
for even x64

70
00:03:13,519 --> 00:03:20,080
it took about the same time and

71
00:03:17,360 --> 00:03:22,319
in the case it managed to leverage a

72
00:03:20,080 --> 00:03:25,040
good deal of experience

73
00:03:22,319 --> 00:03:27,599
because uh they shared a bit of code

74
00:03:25,040 --> 00:03:31,440
with the previous one

75
00:03:27,599 --> 00:03:34,798
hevc is much harder much more difficult

76
00:03:31,440 --> 00:03:38,000
than h.264 right

77
00:03:34,799 --> 00:03:39,920
so what happens with every one that is a

78
00:03:38,000 --> 00:03:43,200
lot more complex

79
00:03:39,920 --> 00:03:46,079
with lots of more features well

80
00:03:43,200 --> 00:03:46,480
what we have here open source wise we

81
00:03:46,080 --> 00:03:49,840
have

82
00:03:46,480 --> 00:03:53,840
libreom sdtv1 both

83
00:03:49,840 --> 00:03:57,040
are coming from a lot of previous code

84
00:03:53,840 --> 00:03:59,840
one is the generator of

85
00:03:57,040 --> 00:04:01,280
vpx so most of the structure is from

86
00:03:59,840 --> 00:04:04,319
there

87
00:04:01,280 --> 00:04:04,879
svt is a whole family of encoders you

88
00:04:04,319 --> 00:04:07,518
have

89
00:04:04,879 --> 00:04:08,720
svt whichever product you can think

90
00:04:07,519 --> 00:04:12,080
about

91
00:04:08,720 --> 00:04:16,399
again long tradition and

92
00:04:12,080 --> 00:04:19,280
they are doing a lot of effort to get

93
00:04:16,399 --> 00:04:20,880
everyone ready and produce something

94
00:04:19,279 --> 00:04:23,599
that isn't as amazing as

95
00:04:20,880 --> 00:04:24,080
everyone should be because everyone in

96
00:04:23,600 --> 00:04:26,560
itself

97
00:04:24,080 --> 00:04:27,599
at least on paper and partially on

98
00:04:26,560 --> 00:04:31,600
practice

99
00:04:27,600 --> 00:04:31,600
is a really good codec

100
00:04:32,400 --> 00:04:38,799
so what happens well

101
00:04:35,600 --> 00:04:41,680
libby eom is dance low

102
00:04:38,800 --> 00:04:43,840
it's really slow is where all the

103
00:04:41,680 --> 00:04:46,720
experiment happened

104
00:04:43,840 --> 00:04:49,359
and because of how it's managed we could

105
00:04:46,720 --> 00:04:51,280
say that is some kind of graveyard

106
00:04:49,360 --> 00:04:52,880
because even the code that didn't manage

107
00:04:51,280 --> 00:04:57,320
to the specifications

108
00:04:52,880 --> 00:05:01,199
sort of lives inside lingering

109
00:04:57,320 --> 00:05:04,960
svtv1 is blazing fast it's really fast

110
00:05:01,199 --> 00:05:08,800
it needs lots of hardware a lot

111
00:05:04,960 --> 00:05:12,880
and obviously there are tradeoffs so

112
00:05:08,800 --> 00:05:15,840
currently svtv1 could be a good solution

113
00:05:12,880 --> 00:05:17,759
at least if you have enough ceo to

114
00:05:15,840 --> 00:05:20,960
sacrifice to

115
00:05:17,759 --> 00:05:22,840
the svt god if you don't well super

116
00:05:20,960 --> 00:05:26,719
grapes

117
00:05:22,840 --> 00:05:30,320
rabi what's the plan with reviews

118
00:05:26,720 --> 00:05:32,720
completely new uh it comes from

119
00:05:30,320 --> 00:05:34,479
a different kind of experience because

120
00:05:32,720 --> 00:05:37,360
most of the dollar team

121
00:05:34,479 --> 00:05:37,359
is now working on

122
00:05:37,520 --> 00:05:44,639
a review scratch written in rust

123
00:05:40,560 --> 00:05:46,240
but we have some background so to speak

124
00:05:44,639 --> 00:05:48,160
and we focus on something completely

125
00:05:46,240 --> 00:05:50,400
different

126
00:05:48,160 --> 00:05:52,639
we want to explore we want to leverage

127
00:05:50,400 --> 00:05:54,960
the experience from data

128
00:05:52,639 --> 00:05:55,680
so the focus is on getting different

129
00:05:54,960 --> 00:05:57,919
solution

130
00:05:55,680 --> 00:06:00,319
try different path use different

131
00:05:57,919 --> 00:06:03,440
algorithms

132
00:06:00,319 --> 00:06:05,759
and focus on trying to get the best

133
00:06:03,440 --> 00:06:10,479
perceived quality

134
00:06:05,759 --> 00:06:13,280
so speed is a concern

135
00:06:10,479 --> 00:06:14,400
memory footprint is a concern but the

136
00:06:13,280 --> 00:06:18,000
main focus is

137
00:06:14,400 --> 00:06:22,400
try to experiment more

138
00:06:18,000 --> 00:06:24,960
and see what we can do and obviously

139
00:06:22,400 --> 00:06:26,159
initially it was quite fast because was

140
00:06:24,960 --> 00:06:29,039
quite tiny

141
00:06:26,160 --> 00:06:31,360
and we want to try to stay fast and even

142
00:06:29,039 --> 00:06:35,759
faster

143
00:06:31,360 --> 00:06:38,960
so first part we want the code that

144
00:06:35,759 --> 00:06:41,039
is readable so not many many many too

145
00:06:38,960 --> 00:06:44,239
many lines of code and not

146
00:06:41,039 --> 00:06:47,360
uh something that was sort of smart

147
00:06:44,240 --> 00:06:48,960
to write once and then the future you is

148
00:06:47,360 --> 00:06:52,400
going to complain a lot with the past

149
00:06:48,960 --> 00:06:56,239
you for your choices uh

150
00:06:52,400 --> 00:06:59,599
speed is a concern but we don't want to

151
00:06:56,240 --> 00:07:00,479
get speed just because we want to use

152
00:06:59,599 --> 00:07:02,400
more hardware

153
00:07:00,479 --> 00:07:03,758
we want to get something that is fast it

154
00:07:02,400 --> 00:07:04,400
doesn't matter the kind of hardware that

155
00:07:03,759 --> 00:07:08,080
you

156
00:07:04,400 --> 00:07:09,679
can have compact that means

157
00:07:08,080 --> 00:07:12,240
you can have instances multiple

158
00:07:09,680 --> 00:07:13,919
instances without requiring way too much

159
00:07:12,240 --> 00:07:16,400
memory

160
00:07:13,919 --> 00:07:18,240
and we would like to make sure that

161
00:07:16,400 --> 00:07:22,000
real-time encoding

162
00:07:18,240 --> 00:07:24,720
could be a thing batch vod encoding

163
00:07:22,000 --> 00:07:26,240
could be a thing and everything that is

164
00:07:24,720 --> 00:07:30,560
in between those

165
00:07:26,240 --> 00:07:34,560
two extremes could be viable

166
00:07:30,560 --> 00:07:37,840
so a lot on our plate

167
00:07:34,560 --> 00:07:40,960
uh when i say that ravi is lean

168
00:07:37,840 --> 00:07:44,400
i mean that if we consider libero m

169
00:07:40,960 --> 00:07:48,560
that is large it's really large

170
00:07:44,400 --> 00:07:50,878
and the code is lots of c

171
00:07:48,560 --> 00:07:52,639
lots of c plus plus because uh the way

172
00:07:50,879 --> 00:07:56,000
uh we are doing tests

173
00:07:52,639 --> 00:07:58,960
in libreom and some assembly

174
00:07:56,000 --> 00:07:59,599
so you can get lost just because there

175
00:07:58,960 --> 00:08:01,840
is

176
00:07:59,599 --> 00:08:03,599
way too much line of code to search and

177
00:08:01,840 --> 00:08:07,679
sift through

178
00:08:03,599 --> 00:08:10,800
ravi consider all the optimization

179
00:08:07,680 --> 00:08:13,280
is nearly a fifth of it

180
00:08:10,800 --> 00:08:14,240
and if we could if we consider just the

181
00:08:13,280 --> 00:08:18,400
rouse code

182
00:08:14,240 --> 00:08:22,639
so no assembly optimization is about 55k

183
00:08:18,400 --> 00:08:26,960
line of code so fairly tiny

184
00:08:22,639 --> 00:08:29,520
if we aggregate the pro the two projects

185
00:08:26,960 --> 00:08:30,239
david and review so we have something

186
00:08:29,520 --> 00:08:33,679
that is

187
00:08:30,240 --> 00:08:37,039
functionally similar to aom

188
00:08:33,679 --> 00:08:39,039
we are still half of the size even if we

189
00:08:37,039 --> 00:08:42,240
consider all the assembly

190
00:08:39,039 --> 00:08:44,319
that we are using so

191
00:08:42,240 --> 00:08:46,480
if you care about everyone and you want

192
00:08:44,320 --> 00:08:48,800
to to have an idea of

193
00:08:46,480 --> 00:08:49,920
how it works you can take the two

194
00:08:48,800 --> 00:08:52,959
projects

195
00:08:49,920 --> 00:08:54,079
all together just the c code for one

196
00:08:52,959 --> 00:08:56,479
side

197
00:08:54,080 --> 00:08:58,320
and the rust code for the other side

198
00:08:56,480 --> 00:09:02,720
says within

199
00:08:58,320 --> 00:09:05,760
about 100k line of code so

200
00:09:02,720 --> 00:09:07,920
it's still quite less to have

201
00:09:05,760 --> 00:09:09,360
to read to figure out what's going on

202
00:09:07,920 --> 00:09:11,599
and both code bases

203
00:09:09,360 --> 00:09:13,760
are sort of easy to read compared to

204
00:09:11,600 --> 00:09:16,720
others

205
00:09:13,760 --> 00:09:18,240
so we want to be fast how you can get

206
00:09:16,720 --> 00:09:22,640
faster

207
00:09:18,240 --> 00:09:26,240
well i say our first focus is to get

208
00:09:22,640 --> 00:09:29,199
better algorithms so even the

209
00:09:26,240 --> 00:09:29,200
theory behind

210
00:09:29,279 --> 00:09:35,200
has to change before you can actually

211
00:09:32,080 --> 00:09:37,760
get something that is fast

212
00:09:35,200 --> 00:09:38,480
but also you can just look at what you

213
00:09:37,760 --> 00:09:41,760
did

214
00:09:38,480 --> 00:09:45,279
and try to figure out if you can

215
00:09:41,760 --> 00:09:45,279
not do some work

216
00:09:46,000 --> 00:09:52,240
and another easy way to much easier

217
00:09:49,040 --> 00:09:55,360
way to be faster just leverage

218
00:09:52,240 --> 00:09:58,320
what the cpu provides

219
00:09:55,360 --> 00:09:59,440
cmd is available pretty much everywhere

220
00:09:58,320 --> 00:10:02,560
using cmd

221
00:09:59,440 --> 00:10:05,839
is something that gets you good results

222
00:10:02,560 --> 00:10:08,560
and does not require as much as

223
00:10:05,839 --> 00:10:11,680
intellectual effort as rethinking all

224
00:10:08,560 --> 00:10:14,719
the algorithm that you are going to use

225
00:10:11,680 --> 00:10:17,040
another item that is important is to be

226
00:10:14,720 --> 00:10:18,720
careful about how you use the memory

227
00:10:17,040 --> 00:10:20,880
cache locality is something that is

228
00:10:18,720 --> 00:10:24,640
going to kill you or save you

229
00:10:20,880 --> 00:10:27,519
depending on how your code is laid out

230
00:10:24,640 --> 00:10:27,519
uh last

231
00:10:28,000 --> 00:10:33,200
so one online question is berlin calling

232
00:10:30,640 --> 00:10:35,839
us thinking ready

233
00:10:33,200 --> 00:10:36,720
as distributed in several machines i

234
00:10:35,839 --> 00:10:40,959
will answer it

235
00:10:36,720 --> 00:10:40,959
at the end it will be

236
00:10:41,760 --> 00:10:48,560
so last but not least multi-thread

237
00:10:45,600 --> 00:10:49,680
we throw more hardware at the problem

238
00:10:48,560 --> 00:10:51,920
and

239
00:10:49,680 --> 00:10:54,399
since in many cases we do have multiple

240
00:10:51,920 --> 00:10:57,839
cores in our machine

241
00:10:54,399 --> 00:11:01,040
could be useful

242
00:10:57,839 --> 00:11:02,079
depending on your use case what i mean

243
00:11:01,040 --> 00:11:04,480
with algorithmic

244
00:11:02,079 --> 00:11:05,439
improvements well we can have something

245
00:11:04,480 --> 00:11:08,640
that is

246
00:11:05,440 --> 00:11:11,360
sort of easy so we have lots of

247
00:11:08,640 --> 00:11:14,720
processing that is working on

248
00:11:11,360 --> 00:11:18,640
applying some kernel on an image and

249
00:11:14,720 --> 00:11:18,640
in many cases the intermediate results

250
00:11:18,880 --> 00:11:25,439
can be reused the concept of integral

251
00:11:22,000 --> 00:11:28,720
images let you lay out

252
00:11:25,440 --> 00:11:29,839
what you are doing so that all the

253
00:11:28,720 --> 00:11:34,160
intermediate

254
00:11:29,839 --> 00:11:35,920
do not have to be recomputed all over

255
00:11:34,160 --> 00:11:39,279
and that managed to speed up a lot the

256
00:11:35,920 --> 00:11:39,279
loop restoration process

257
00:11:39,360 --> 00:11:44,880
redistortion optimization this is where

258
00:11:42,320 --> 00:11:48,640
we are spending most of the time

259
00:11:44,880 --> 00:11:50,639
so what you can do in that case well the

260
00:11:48,640 --> 00:11:53,519
this kind of code is like walking in a

261
00:11:50,639 --> 00:11:56,800
tree so you make decision and you do

262
00:11:53,519 --> 00:11:59,760
you decide where to go if you prune it

263
00:11:56,800 --> 00:12:00,399
properly because you know that going

264
00:11:59,760 --> 00:12:02,480
down

265
00:12:00,399 --> 00:12:03,760
is not going to lead you to anything

266
00:12:02,480 --> 00:12:06,560
useful

267
00:12:03,760 --> 00:12:08,800
you're going to spare a lot of time so

268
00:12:06,560 --> 00:12:12,638
we did a lot of work to get

269
00:12:08,800 --> 00:12:14,560
some early exit condition set up

270
00:12:12,639 --> 00:12:17,519
so we are not doing work that we are

271
00:12:14,560 --> 00:12:20,000
going to discard anyway

272
00:12:17,519 --> 00:12:23,200
and this kind of work is something that

273
00:12:20,000 --> 00:12:23,200
we are doing all the time

274
00:12:23,279 --> 00:12:26,639
simply we love cindy everybody loves

275
00:12:25,200 --> 00:12:28,720
cindy

276
00:12:26,639 --> 00:12:30,160
we don't want to write some cindy code

277
00:12:28,720 --> 00:12:32,880
well a good

278
00:12:30,160 --> 00:12:34,160
a good number of people but anyway we

279
00:12:32,880 --> 00:12:38,000
like it

280
00:12:34,160 --> 00:12:41,279
so how to do cmd in a rascald base

281
00:12:38,000 --> 00:12:44,880
two ways one is using stdr

282
00:12:41,279 --> 00:12:47,839
that is part of the standard library

283
00:12:44,880 --> 00:12:48,480
they are somehow like the c intrinsics

284
00:12:47,839 --> 00:12:52,079
but

285
00:12:48,480 --> 00:12:53,360
arguably better performance wise on the

286
00:12:52,079 --> 00:12:56,239
other side

287
00:12:53,360 --> 00:12:57,760
assembly is good the people that are

288
00:12:56,240 --> 00:13:02,480
working mainly on david love

289
00:12:57,760 --> 00:13:02,480
assembly we can share it we can use it

290
00:13:03,200 --> 00:13:06,800
and since we are using rust even the

291
00:13:05,279 --> 00:13:11,040
compiler is going to

292
00:13:06,800 --> 00:13:13,279
help us much more compared to c because

293
00:13:11,040 --> 00:13:14,319
the rust language get the compiler more

294
00:13:13,279 --> 00:13:16,000
information

295
00:13:14,320 --> 00:13:18,320
and through that the compiler can

296
00:13:16,000 --> 00:13:21,360
produce

297
00:13:18,320 --> 00:13:24,480
better active vectorized code

298
00:13:21,360 --> 00:13:27,839
and that is helping us a lot even more

299
00:13:24,480 --> 00:13:30,160
if people want to use avx2 because

300
00:13:27,839 --> 00:13:31,440
you can just enable it and then the

301
00:13:30,160 --> 00:13:35,279
compiler is going to

302
00:13:31,440 --> 00:13:39,680
produce fairly good ivx 2 code for

303
00:13:35,279 --> 00:13:42,959
your normal loops so that part is good

304
00:13:39,680 --> 00:13:46,959
multitrading multitrading and rust

305
00:13:42,959 --> 00:13:49,040
are sort of a sweet story

306
00:13:46,959 --> 00:13:51,599
since when you're writing multi-thread

307
00:13:49,040 --> 00:13:54,399
code in other languages

308
00:13:51,600 --> 00:13:56,320
you will end up making mistakes you will

309
00:13:54,399 --> 00:13:57,519
end up spending lots of time debugging

310
00:13:56,320 --> 00:14:01,199
it

311
00:13:57,519 --> 00:14:04,880
in rust you cannot do those mistakes

312
00:14:01,199 --> 00:14:07,279
if it compiles it usually runs

313
00:14:04,880 --> 00:14:08,160
beside if you made logic mistakes but in

314
00:14:07,279 --> 00:14:10,800
the case

315
00:14:08,160 --> 00:14:10,800
is your fault

316
00:14:12,000 --> 00:14:17,839
and what we can do with that well

317
00:14:19,920 --> 00:14:27,599
another question if you want

318
00:14:23,120 --> 00:14:30,240
okay so that one will wait

319
00:14:27,600 --> 00:14:30,720
so i was saying multitrading we can do

320
00:14:30,240 --> 00:14:33,760
that

321
00:14:30,720 --> 00:14:37,360
rust enable you to do something with

322
00:14:33,760 --> 00:14:41,360
much easier but also rust let you

323
00:14:37,360 --> 00:14:44,480
have something that is sort of magic

324
00:14:41,360 --> 00:14:47,839
because rust abstractions are really

325
00:14:44,480 --> 00:14:47,839
zero cost most of the time

326
00:14:48,160 --> 00:14:52,240
and as i say if we are using iterators

327
00:14:51,040 --> 00:14:54,880
the compiler is going to have to

328
00:14:52,240 --> 00:14:56,720
vectorize them already

329
00:14:54,880 --> 00:14:58,959
what happens when you are using

330
00:14:56,720 --> 00:15:01,199
something that take your

331
00:14:58,959 --> 00:15:02,560
serial iterator and advance it in

332
00:15:01,199 --> 00:15:05,359
parallel

333
00:15:02,560 --> 00:15:06,638
well you have parallelism for almost

334
00:15:05,360 --> 00:15:10,079
three

335
00:15:06,639 --> 00:15:13,680
what does it mean almost free this is

336
00:15:10,079 --> 00:15:18,160
our main loop is a bit of a

337
00:15:13,680 --> 00:15:21,519
mouthful but basically we work on tiles

338
00:15:18,160 --> 00:15:22,560
and for each style we encode it simple

339
00:15:21,519 --> 00:15:25,680
right

340
00:15:22,560 --> 00:15:28,239
okay so this is serial

341
00:15:25,680 --> 00:15:29,599
you get the list of tiles each style

342
00:15:28,240 --> 00:15:31,519
gets processed

343
00:15:29,600 --> 00:15:33,279
and that's it but the ties are

344
00:15:31,519 --> 00:15:35,680
independent so

345
00:15:33,279 --> 00:15:37,360
we want to do that in multiple threads

346
00:15:35,680 --> 00:15:41,120
that's it

347
00:15:37,360 --> 00:15:44,800
just a single line and everything works

348
00:15:41,120 --> 00:15:47,040
in parallel and we don't have to think

349
00:15:44,800 --> 00:15:47,040
much

350
00:15:47,279 --> 00:15:51,759
well we have to think a little we have

351
00:15:49,920 --> 00:15:52,800
to make sure that the data types we are

352
00:15:51,759 --> 00:15:56,320
using

353
00:15:52,800 --> 00:15:59,359
are sort of thread safe and we have to

354
00:15:56,320 --> 00:16:03,920
not mutate what we are doing the closure

355
00:15:59,360 --> 00:16:03,920
and with closure i mean this thing

356
00:16:05,759 --> 00:16:11,920
and that's it that's how we can

357
00:16:08,959 --> 00:16:13,680
get lots of multithread goodness with

358
00:16:11,920 --> 00:16:15,599
the minimal effort

359
00:16:13,680 --> 00:16:17,519
we are doing even a bit more work

360
00:16:15,600 --> 00:16:20,720
because we are not so

361
00:16:17,519 --> 00:16:21,759
lazy so in the future releases you will

362
00:16:20,720 --> 00:16:23,680
have

363
00:16:21,759 --> 00:16:26,240
an alternative api that is based on

364
00:16:23,680 --> 00:16:28,959
channels so people that are used to go

365
00:16:26,240 --> 00:16:30,240
or people that are writing rust you will

366
00:16:28,959 --> 00:16:32,638
have an api that is

367
00:16:30,240 --> 00:16:34,320
much more streamlined and much easier to

368
00:16:32,639 --> 00:16:37,839
use

369
00:16:34,320 --> 00:16:37,839
and this is

370
00:16:38,160 --> 00:16:44,560
how it looks now so

371
00:16:41,519 --> 00:16:46,639
our api has a send

372
00:16:44,560 --> 00:16:48,399
frame call that is using to fit the

373
00:16:46,639 --> 00:16:50,880
encoder with frames

374
00:16:48,399 --> 00:16:53,279
and a receive packet that is pulling out

375
00:16:50,880 --> 00:16:56,720
from the encoder then coded packets

376
00:16:53,279 --> 00:16:58,959
sort of simple and this is the effect of

377
00:16:56,720 --> 00:17:02,839
rayon

378
00:16:58,959 --> 00:17:04,159
all this part is running in multiple

379
00:17:02,839 --> 00:17:07,360
threads

380
00:17:04,160 --> 00:17:10,640
more or less in an optimal way

381
00:17:07,359 --> 00:17:13,359
we have work to do on getting this part

382
00:17:10,640 --> 00:17:15,360
on different threads so we don't have

383
00:17:13,359 --> 00:17:18,399
this kind of

384
00:17:15,359 --> 00:17:22,079
large gap that is fully serial

385
00:17:18,400 --> 00:17:25,360
but this is how he's yet been

386
00:17:22,079 --> 00:17:25,359
improving our situation

387
00:17:26,079 --> 00:17:30,720
how we are doing that what we are doing

388
00:17:29,039 --> 00:17:33,520
uh essay i will mention

389
00:17:30,720 --> 00:17:34,720
some of the tool that we are using

390
00:17:33,520 --> 00:17:38,080
because i did that

391
00:17:34,720 --> 00:17:43,440
in the morning i will compress it

392
00:17:38,080 --> 00:17:45,439
but mainly we try to keep all our code

393
00:17:43,440 --> 00:17:47,039
as good as possible we are trying to not

394
00:17:45,440 --> 00:17:50,480
use to mesh memory we are

395
00:17:47,039 --> 00:17:52,640
we are trying to see if the

396
00:17:50,480 --> 00:17:53,760
new tools that we are implementing are

397
00:17:52,640 --> 00:17:57,039
having a strong

398
00:17:53,760 --> 00:18:01,679
impact or a small impact on the

399
00:17:57,039 --> 00:18:05,520
overall speed and to see what i mean

400
00:18:01,679 --> 00:18:09,360
uh regarding measuring this is

401
00:18:05,520 --> 00:18:12,240
what happened to the location

402
00:18:09,360 --> 00:18:12,799
we were using way too much memory and

403
00:18:12,240 --> 00:18:15,919
way

404
00:18:12,799 --> 00:18:20,160
too much location in my opinion

405
00:18:15,919 --> 00:18:22,720
0.1 6k quite a lot the kernel has to

406
00:18:20,160 --> 00:18:22,720
work a bit

407
00:18:23,760 --> 00:18:31,600
2.0 we managed to cut that

408
00:18:27,679 --> 00:18:35,760
to half that is something that caused uh

409
00:18:31,600 --> 00:18:39,280
also a speed increase uh

410
00:18:35,760 --> 00:18:43,679
two days ago i ran the numbers and

411
00:18:39,280 --> 00:18:46,480
we got even further below so

412
00:18:43,679 --> 00:18:47,440
again something that is useful and we do

413
00:18:46,480 --> 00:18:50,559
this kind of

414
00:18:47,440 --> 00:18:53,360
uh analysis

415
00:18:50,559 --> 00:18:54,720
more or less all the time to give you a

416
00:18:53,360 --> 00:18:58,000
comparison

417
00:18:54,720 --> 00:19:01,120
this is svtv1

418
00:18:58,000 --> 00:19:03,520
as you can see it is locating a bit of

419
00:19:01,120 --> 00:19:03,520
memory

420
00:19:04,160 --> 00:19:10,799
i mean one gigabyte

421
00:19:07,200 --> 00:19:13,120
same content six gigabytes

422
00:19:10,799 --> 00:19:16,400
now you see what i mean when i say that

423
00:19:13,120 --> 00:19:19,760
you have to be resource conscious

424
00:19:16,400 --> 00:19:23,120
uh speed wise we always

425
00:19:19,760 --> 00:19:26,879
keep improving we try to keep improving

426
00:19:23,120 --> 00:19:29,520
this is uh what you see at our top speed

427
00:19:26,880 --> 00:19:30,320
is not something that you can write home

428
00:19:29,520 --> 00:19:33,200
yet

429
00:19:30,320 --> 00:19:34,000
because more than 3 fps is still not

430
00:19:33,200 --> 00:19:37,440
something that is

431
00:19:34,000 --> 00:19:40,480
exactly great but compared to

432
00:19:37,440 --> 00:19:42,640
about 1 fps well

433
00:19:40,480 --> 00:19:44,960
we are doing well we are improving we

434
00:19:42,640 --> 00:19:49,760
will keep improving

435
00:19:44,960 --> 00:19:51,440
and this is about speed about specific

436
00:19:49,760 --> 00:19:55,360
features since i say that

437
00:19:51,440 --> 00:19:58,559
ravi is focusing on different algorithms

438
00:19:55,360 --> 00:20:01,120
we did work on rdo biasing

439
00:19:58,559 --> 00:20:02,000
that is basically we have our decision

440
00:20:01,120 --> 00:20:05,439
tree and we

441
00:20:02,000 --> 00:20:08,720
try to move the decision

442
00:20:05,440 --> 00:20:13,039
based on how the future will be

443
00:20:08,720 --> 00:20:15,360
behaved for each blocks so if something

444
00:20:13,039 --> 00:20:17,679
in the future will say the same we will

445
00:20:15,360 --> 00:20:20,799
try to bias it

446
00:20:17,679 --> 00:20:21,200
so it will decide to keep the block even

447
00:20:20,799 --> 00:20:24,960
if

448
00:20:21,200 --> 00:20:24,960
uh by uh

449
00:20:25,120 --> 00:20:29,039
the matrix that you have you can apply

450
00:20:27,280 --> 00:20:30,960
just for the single frame

451
00:20:29,039 --> 00:20:32,400
it might not be considered that

452
00:20:30,960 --> 00:20:35,520
interesting

453
00:20:32,400 --> 00:20:35,840
uh chroma lumen balance that's something

454
00:20:35,520 --> 00:20:39,360
that

455
00:20:35,840 --> 00:20:41,280
goes against the the common

456
00:20:39,360 --> 00:20:42,559
sense encoding because if you consider

457
00:20:41,280 --> 00:20:44,879
yuv

458
00:20:42,559 --> 00:20:46,720
you say always luma is more important

459
00:20:44,880 --> 00:20:49,840
than chroma

460
00:20:46,720 --> 00:20:52,880
well it's not always that because

461
00:20:49,840 --> 00:20:55,199
once you start to quantize the two you

462
00:20:52,880 --> 00:20:57,120
cannot end up in a point to a point in

463
00:20:55,200 --> 00:20:59,600
which

464
00:20:57,120 --> 00:21:01,520
the chroma differences because of

465
00:20:59,600 --> 00:21:02,799
quantization

466
00:21:01,520 --> 00:21:04,639
are something that you are going to

467
00:21:02,799 --> 00:21:07,840
perceive more that the luma

468
00:21:04,640 --> 00:21:11,120
differences for quantization so you can

469
00:21:07,840 --> 00:21:12,799
try to strike a balance so with your bit

470
00:21:11,120 --> 00:21:14,719
budgets

471
00:21:12,799 --> 00:21:16,720
you are going to spend a little bit more

472
00:21:14,720 --> 00:21:18,640
on chroma and get better perceptual

473
00:21:16,720 --> 00:21:20,880
results

474
00:21:18,640 --> 00:21:22,400
last but not least everyone has a

475
00:21:20,880 --> 00:21:26,000
concept of

476
00:21:22,400 --> 00:21:29,120
per frame quantizer deltas so

477
00:21:26,000 --> 00:21:31,840
in every frame for each block you can

478
00:21:29,120 --> 00:21:33,199
change a little your quantizing up and

479
00:21:31,840 --> 00:21:36,480
down

480
00:21:33,200 --> 00:21:40,320
and you can optimize a lot with that

481
00:21:36,480 --> 00:21:44,240
and get optimal results without using

482
00:21:40,320 --> 00:21:48,639
many bits to signal that kind of change

483
00:21:44,240 --> 00:21:50,799
since we like to have pictures

484
00:21:48,640 --> 00:21:52,320
are you all biasing so the tree is

485
00:21:50,799 --> 00:21:55,760
always the same

486
00:21:52,320 --> 00:21:59,439
but this part is going to change

487
00:21:55,760 --> 00:22:01,679
so you are not going to spend a lot

488
00:21:59,440 --> 00:22:02,799
on this chair even if it's something

489
00:22:01,679 --> 00:22:04,960
that you can predict

490
00:22:02,799 --> 00:22:06,400
quite well in that picture because it's

491
00:22:04,960 --> 00:22:08,559
going to be covered

492
00:22:06,400 --> 00:22:09,440
the three on the other hand you want to

493
00:22:08,559 --> 00:22:12,320
it to

494
00:22:09,440 --> 00:22:13,679
spend a little more in the past so you

495
00:22:12,320 --> 00:22:15,039
are not going to spend a lot in the

496
00:22:13,679 --> 00:22:17,600
future

497
00:22:15,039 --> 00:22:20,480
and this is the concept quite simple the

498
00:22:17,600 --> 00:22:24,320
implementation is a bit gory

499
00:22:20,480 --> 00:22:26,240
block importance again same idea

500
00:22:24,320 --> 00:22:27,520
if the future is better we are going to

501
00:22:26,240 --> 00:22:30,720
spend more bits if

502
00:22:27,520 --> 00:22:32,879
the future is grim we are not

503
00:22:30,720 --> 00:22:35,120
and this is how we visualize the whole

504
00:22:32,880 --> 00:22:35,120
thing

505
00:22:35,760 --> 00:22:43,679
uh how much time do we have

506
00:22:39,280 --> 00:22:47,760
minus two minutes oh great

507
00:22:43,679 --> 00:22:47,760
so trust me everything is great

508
00:22:48,799 --> 00:22:52,639
so keep it for next year maybe

509
00:22:52,880 --> 00:22:59,919
so what to expect uh we started with

510
00:22:56,640 --> 00:23:03,440
0.1 uh in tokyo

511
00:22:59,919 --> 00:23:07,880
in december vdd uh we got

512
00:23:03,440 --> 00:23:11,039
0.2 about a month ago

513
00:23:07,880 --> 00:23:13,919
0.2.1 in which we managed to

514
00:23:11,039 --> 00:23:14,400
have different kind of improvement and

515
00:23:13,919 --> 00:23:17,679
we

516
00:23:14,400 --> 00:23:18,240
had some kind of trade-offs so we are

517
00:23:17,679 --> 00:23:20,960
overall

518
00:23:18,240 --> 00:23:22,400
about one percent better with a little

519
00:23:20,960 --> 00:23:25,679
slowdown

520
00:23:22,400 --> 00:23:26,159
and for 0.3 that will appear in the next

521
00:23:25,679 --> 00:23:29,280
week

522
00:23:26,159 --> 00:23:33,120
possibly we did

523
00:23:29,280 --> 00:23:36,480
more work on multitrading more cmd code

524
00:23:33,120 --> 00:23:37,600
written work on cod paths so the

525
00:23:36,480 --> 00:23:40,960
compiler is going to act

526
00:23:37,600 --> 00:23:43,120
vectorize them for us less bound checks

527
00:23:40,960 --> 00:23:45,039
so the safety from russ is not going to

528
00:23:43,120 --> 00:23:47,199
slow it uh us down

529
00:23:45,039 --> 00:23:48,720
and about a sixth of the memory

530
00:23:47,200 --> 00:23:52,080
allocation less

531
00:23:48,720 --> 00:23:55,440
so mark compact we're

532
00:23:52,080 --> 00:23:58,000
working on the rdo base biosync so

533
00:23:55,440 --> 00:24:00,400
it works better but that cause a slow

534
00:23:58,000 --> 00:24:02,880
down on the high speeds

535
00:24:00,400 --> 00:24:04,559
we are implementing more tools so now we

536
00:24:02,880 --> 00:24:07,120
have fine directional

537
00:24:04,559 --> 00:24:08,559
directional uh prediction and entire

538
00:24:07,120 --> 00:24:11,279
edge filter

539
00:24:08,559 --> 00:24:12,080
we are giving more features to the user

540
00:24:11,279 --> 00:24:13,679
so

541
00:24:12,080 --> 00:24:15,360
if you want to use which frame and

542
00:24:13,679 --> 00:24:17,840
experiment with uh which

543
00:24:15,360 --> 00:24:18,559
is which frames we have it if you want

544
00:24:17,840 --> 00:24:21,199
to use

545
00:24:18,559 --> 00:24:21,200
revvy to

546
00:24:21,760 --> 00:24:28,799
make still pictures

547
00:24:25,279 --> 00:24:30,400
so everyone has an image format instead

548
00:24:28,799 --> 00:24:33,360
of a video format

549
00:24:30,400 --> 00:24:33,919
now that part is working uh if you want

550
00:24:33,360 --> 00:24:36,879
to

551
00:24:33,919 --> 00:24:38,640
get crazy and put the encoder in the

552
00:24:36,880 --> 00:24:41,360
browser

553
00:24:38,640 --> 00:24:42,080
uh there is a little bit of work that it

554
00:24:41,360 --> 00:24:46,959
will appear

555
00:24:42,080 --> 00:24:49,199
so it will be quite easy to do that

556
00:24:46,960 --> 00:24:50,000
further in the future the channel based

557
00:24:49,200 --> 00:24:53,279
api

558
00:24:50,000 --> 00:24:57,039
should be complete by 0.4 so

559
00:24:53,279 --> 00:25:00,080
better thread usage easier

560
00:24:57,039 --> 00:25:02,640
usage model for you we are going to do

561
00:25:00,080 --> 00:25:03,199
a lot of work on the rate control since

562
00:25:02,640 --> 00:25:05,760
this is

563
00:25:03,200 --> 00:25:06,799
one of the weakest point for most of the

564
00:25:05,760 --> 00:25:11,200
encoders

565
00:25:06,799 --> 00:25:15,039
we're going to try to make it uh fast

566
00:25:11,200 --> 00:25:17,360
and uh overall useful so doing

567
00:25:15,039 --> 00:25:19,120
a choose pass encoding is not good to be

568
00:25:17,360 --> 00:25:22,158
a daunting task

569
00:25:19,120 --> 00:25:25,678
and the api is going to be expanded

570
00:25:22,159 --> 00:25:28,720
so to answer to the initial question

571
00:25:25,679 --> 00:25:30,320
ravi is going to support chunking coding

572
00:25:28,720 --> 00:25:31,919
and the chunk can be encoded in

573
00:25:30,320 --> 00:25:34,240
different nodes

574
00:25:31,919 --> 00:25:35,440
after the whole process you will have a

575
00:25:34,240 --> 00:25:38,159
way to

576
00:25:35,440 --> 00:25:40,080
aggregate the whole thing not just the

577
00:25:38,159 --> 00:25:42,240
packets that you are producing

578
00:25:40,080 --> 00:25:43,199
but also the rate control information so

579
00:25:42,240 --> 00:25:46,799
you can have

580
00:25:43,200 --> 00:25:51,919
multiple paths across multiple nodes

581
00:25:46,799 --> 00:25:51,918
and this should happen in 0.4

582
00:25:52,480 --> 00:25:58,640
uh the other question from the network

583
00:25:56,400 --> 00:26:00,960
how do you track subjective quality over

584
00:25:58,640 --> 00:26:00,960
time

585
00:26:02,799 --> 00:26:09,279
so you can see the questions uh

586
00:26:06,400 --> 00:26:10,240
we have are we compressed yet in which

587
00:26:09,279 --> 00:26:14,400
we

588
00:26:10,240 --> 00:26:16,480
spend a lot of cpu time

589
00:26:14,400 --> 00:26:17,440
to do multiple encodings with multiple

590
00:26:16,480 --> 00:26:20,559
settings

591
00:26:17,440 --> 00:26:22,000
from a large corpus that is giving you a

592
00:26:20,559 --> 00:26:26,240
good coverage

593
00:26:22,000 --> 00:26:26,240
and get lots of uh

594
00:26:26,720 --> 00:26:33,840
crazy objective uh results

595
00:26:30,159 --> 00:26:36,559
we don't have anything we don't have uh

596
00:26:33,840 --> 00:26:36,959
any kind of uh group of volunteers that

597
00:26:36,559 --> 00:26:38,879
are

598
00:26:36,960 --> 00:26:40,559
keep watching the same movie many times

599
00:26:38,880 --> 00:26:42,799
to tell us which is

600
00:26:40,559 --> 00:26:44,720
which looks better and which not if

601
00:26:42,799 --> 00:26:48,000
somebody wants to volunteer that

602
00:26:44,720 --> 00:26:51,520
they are welcome i'm sorry we'll have to

603
00:26:48,000 --> 00:26:52,640
stop there because we it's already 2 30.

604
00:26:51,520 --> 00:26:54,799
if you have any more questions you can

605
00:26:52,640 --> 00:27:07,360
ask luka

606
00:26:54,799 --> 00:27:07,360
that's it

