1
00:00:06,960 --> 00:00:10,320
uh thank you georgios for inviting me uh

2
00:00:08,880 --> 00:00:11,200
my name is doug krieger i'm here from

3
00:00:10,320 --> 00:00:13,280
github

4
00:00:11,200 --> 00:00:14,879
i'm not going to talk about left pad or

5
00:00:13,280 --> 00:00:17,439
event stream unlike most of the

6
00:00:14,880 --> 00:00:18,800
previous talks in this room instead i'm

7
00:00:17,440 --> 00:00:20,160
going to be talking about some code

8
00:00:18,800 --> 00:00:21,039
navigation work that we've been doing

9
00:00:20,160 --> 00:00:22,480
recently

10
00:00:21,039 --> 00:00:24,640
at github i'm the manager of the

11
00:00:22,480 --> 00:00:26,480
semantic code team we're a team

12
00:00:24,640 --> 00:00:28,320
as georgia says that does static

13
00:00:26,480 --> 00:00:30,240
analysis at scale

14
00:00:28,320 --> 00:00:32,079
on basically the entire corpus of code

15
00:00:30,240 --> 00:00:33,600
that's hosted on github so that

16
00:00:32,079 --> 00:00:36,239
uh lends some interesting challenges

17
00:00:33,600 --> 00:00:36,239
that we have to solve

18
00:00:36,559 --> 00:00:40,320
okay so um my team back in november at

19
00:00:39,360 --> 00:00:43,360
github universe

20
00:00:40,320 --> 00:00:45,680
announced the ga launch of code

21
00:00:43,360 --> 00:00:50,800
navigation fuzzy code navigation

22
00:00:45,680 --> 00:00:53,360
on github.com if you've used any kind of

23
00:00:50,800 --> 00:00:54,800
editor or id modern editor id in the

24
00:00:53,360 --> 00:00:56,320
recent you know years you've probably

25
00:00:54,800 --> 00:00:58,000
encountered code navigation before this

26
00:00:56,320 --> 00:00:59,520
is not a fundamentally new concept

27
00:00:58,000 --> 00:01:01,440
uh it's exciting for us because we get

28
00:00:59,520 --> 00:01:04,080
to launch it directly on the code view

29
00:01:01,440 --> 00:01:05,518
of github itself so you're looking at a

30
00:01:04,080 --> 00:01:07,280
particular code base

31
00:01:05,519 --> 00:01:09,920
on github this in particular is an

32
00:01:07,280 --> 00:01:10,880
example of kubernetes so some go code

33
00:01:09,920 --> 00:01:12,720
you're looking at it you're trying to

34
00:01:10,880 --> 00:01:13,920
figure out how it works you see a call

35
00:01:12,720 --> 00:01:15,679
to a method

36
00:01:13,920 --> 00:01:17,200
you can click on it it pulls up a hover

37
00:01:15,680 --> 00:01:20,000
card that shows you a link to the

38
00:01:17,200 --> 00:01:21,680
definition of that method

39
00:01:20,000 --> 00:01:23,759
clicking on the link takes you to the

40
00:01:21,680 --> 00:01:25,280
source code that defines the method

41
00:01:23,759 --> 00:01:26,720
once you're there you can also click on

42
00:01:25,280 --> 00:01:28,640
its definition and that'll pull up a

43
00:01:26,720 --> 00:01:30,320
list of all of the other references

44
00:01:28,640 --> 00:01:32,400
to that method so again it's it's jump

45
00:01:30,320 --> 00:01:33,439
to definition and find all references

46
00:01:32,400 --> 00:01:36,479
just like you would see

47
00:01:33,439 --> 00:01:40,240
in an editor or an ide but direct in the

48
00:01:36,479 --> 00:01:42,560
code view on github.com

49
00:01:40,240 --> 00:01:44,240
okay so we're very excited by it we're

50
00:01:42,560 --> 00:01:46,079
very happy to have gotten this launched

51
00:01:44,240 --> 00:01:47,520
it was a big milestone for my team

52
00:01:46,079 --> 00:01:49,679
like we were happy with the result there

53
00:01:47,520 --> 00:01:51,200
are limitations in what we've shipped

54
00:01:49,680 --> 00:01:53,439
so i want to talk about a few of those

55
00:01:51,200 --> 00:01:57,040
and what we're doing to address those

56
00:01:53,439 --> 00:01:58,398
moving forward one of the first

57
00:01:57,040 --> 00:02:01,439
limitations to talk about

58
00:01:58,399 --> 00:02:03,920
is that it's only ga launched for three

59
00:02:01,439 --> 00:02:05,439
programming languages right now python

60
00:02:03,920 --> 00:02:07,119
go and ruby

61
00:02:05,439 --> 00:02:08,639
we do have three others that are in beta

62
00:02:07,119 --> 00:02:10,800
so javascript typescript

63
00:02:08,639 --> 00:02:12,559
and php there's about a 10 chance that

64
00:02:10,800 --> 00:02:13,520
your repository has code navigation

65
00:02:12,560 --> 00:02:16,319
activated for it

66
00:02:13,520 --> 00:02:17,760
and a 90 chance that it doesn't um we do

67
00:02:16,319 --> 00:02:18,000
have other languages that we're working

68
00:02:17,760 --> 00:02:20,160
on

69
00:02:18,000 --> 00:02:22,160
as well queued up behind those but right

70
00:02:20,160 --> 00:02:22,799
now it's only ga launched for these

71
00:02:22,160 --> 00:02:24,239
three

72
00:02:22,800 --> 00:02:26,000
it is important to call out though that

73
00:02:24,239 --> 00:02:28,800
it's ga launched for

74
00:02:26,000 --> 00:02:29,520
all public and private repositories on

75
00:02:28,800 --> 00:02:31,200
github

76
00:02:29,520 --> 00:02:32,560
that has any code with any of those

77
00:02:31,200 --> 00:02:34,000
three languages so

78
00:02:32,560 --> 00:02:35,440
it's it's still a pretty substantial

79
00:02:34,000 --> 00:02:37,120
launch for us even though it's just a

80
00:02:35,440 --> 00:02:39,920
relatively small number of individual

81
00:02:37,120 --> 00:02:39,920
programming languages

82
00:02:41,440 --> 00:02:45,280
a more jarring i would say limitation

83
00:02:43,519 --> 00:02:46,720
here is as i called it fuzzy code

84
00:02:45,280 --> 00:02:47,200
navigation when i first talked about

85
00:02:46,720 --> 00:02:48,720
that

86
00:02:47,200 --> 00:02:50,640
and we also like to call this c tags

87
00:02:48,720 --> 00:02:54,560
like and what this means

88
00:02:50,640 --> 00:02:56,799
is that when you click on a reference

89
00:02:54,560 --> 00:02:58,480
to a function we're not doing anything

90
00:02:56,800 --> 00:03:00,959
clever to figure out which

91
00:02:58,480 --> 00:03:02,319
particular function that you're calling

92
00:03:00,959 --> 00:03:03,200
all we're doing is we're matching up the

93
00:03:02,319 --> 00:03:05,200
name of the symbol

94
00:03:03,200 --> 00:03:06,640
so this is why we call it c tags like so

95
00:03:05,200 --> 00:03:08,640
if you have a lot of

96
00:03:06,640 --> 00:03:10,000
functions or methods in your repository

97
00:03:08,640 --> 00:03:11,518
that have the same name

98
00:03:10,000 --> 00:03:13,680
we're going to present an ambiguous

99
00:03:11,519 --> 00:03:15,040
result where you click on a method call

100
00:03:13,680 --> 00:03:16,720
and we do show you all of the

101
00:03:15,040 --> 00:03:19,280
possibilities based on that symbol name

102
00:03:16,720 --> 00:03:20,400
match

103
00:03:19,280 --> 00:03:21,599
similarly if you're looking at

104
00:03:20,400 --> 00:03:22,879
references if you're looking at a

105
00:03:21,599 --> 00:03:24,319
particular definition

106
00:03:22,879 --> 00:03:26,399
we're going to be showing you all of the

107
00:03:24,319 --> 00:03:28,640
references to any function with that

108
00:03:26,400 --> 00:03:31,040
name in your repository not necessarily

109
00:03:28,640 --> 00:03:32,000
the calls to this particular function so

110
00:03:31,040 --> 00:03:34,400
this is

111
00:03:32,000 --> 00:03:35,440
like we said fuzzy or c tags like we're

112
00:03:34,400 --> 00:03:37,760
not actually using

113
00:03:35,440 --> 00:03:38,959
c tags itself as the way of extracting

114
00:03:37,760 --> 00:03:41,840
this data so

115
00:03:38,959 --> 00:03:43,519
in particular we are using real parsing

116
00:03:41,840 --> 00:03:45,200
of the languages in question so we're

117
00:03:43,519 --> 00:03:46,319
not doing just regular expression based

118
00:03:45,200 --> 00:03:48,079
matches

119
00:03:46,319 --> 00:03:49,679
that's interesting in that we do get a

120
00:03:48,080 --> 00:03:51,280
little bit more syntactic information

121
00:03:49,680 --> 00:03:52,159
about the symbols we can see if you're

122
00:03:51,280 --> 00:03:54,480
talking about

123
00:03:52,159 --> 00:03:55,920
a function call or a local variable

124
00:03:54,480 --> 00:03:57,760
reference and we are able to tweak the

125
00:03:55,920 --> 00:03:59,359
user interface slightly based on that

126
00:03:57,760 --> 00:04:00,480
but we are still you know limited to

127
00:03:59,360 --> 00:04:03,760
that fact that we're just doing this

128
00:04:00,480 --> 00:04:03,760
textual match of the symbols

129
00:04:04,480 --> 00:04:08,079
okay the last limitation that i want to

130
00:04:06,720 --> 00:04:10,000
talk about today and i think the one

131
00:04:08,080 --> 00:04:12,000
most relevant to this audience

132
00:04:10,000 --> 00:04:14,480
in the dependency management room is

133
00:04:12,000 --> 00:04:17,358
that this is only code navigation within

134
00:04:14,480 --> 00:04:18,478
your repository so you can see the links

135
00:04:17,358 --> 00:04:21,039
to the functions that you're calling

136
00:04:18,478 --> 00:04:22,800
that are defined in the same repository

137
00:04:21,040 --> 00:04:25,040
but not two links that cross a

138
00:04:22,800 --> 00:04:27,360
repository boundary

139
00:04:25,040 --> 00:04:29,360
now i am being very careful to use the

140
00:04:27,360 --> 00:04:32,560
word repository here

141
00:04:29,360 --> 00:04:33,600
it is possibly cross-dependency code

142
00:04:32,560 --> 00:04:35,440
navigation

143
00:04:33,600 --> 00:04:36,880
for those languages or projects where

144
00:04:35,440 --> 00:04:38,800
you're vendoring your dependencies where

145
00:04:36,880 --> 00:04:41,360
you're actually placing a copy of the

146
00:04:38,800 --> 00:04:43,199
code into your repository with you

147
00:04:41,360 --> 00:04:44,560
and in go that's actually relatively

148
00:04:43,199 --> 00:04:46,160
prevalent so

149
00:04:44,560 --> 00:04:47,919
for many go projects you actually are

150
00:04:46,160 --> 00:04:49,680
getting cross package

151
00:04:47,919 --> 00:04:51,520
code navigation with what's currently

152
00:04:49,680 --> 00:04:52,800
launched just because of that tendency

153
00:04:51,520 --> 00:04:54,799
to do vendoring

154
00:04:52,800 --> 00:04:56,400
but most language communities don't

155
00:04:54,800 --> 00:04:58,000
consider that to be a best practice and

156
00:04:56,400 --> 00:04:59,840
so we really do want to think about what

157
00:04:58,000 --> 00:05:00,639
a cross-repository solution to this

158
00:04:59,840 --> 00:05:02,479
would look like

159
00:05:00,639 --> 00:05:04,240
if we want to do this for real for the

160
00:05:02,479 --> 00:05:06,560
entirety of of the corpus of code on

161
00:05:04,240 --> 00:05:06,560
github

162
00:05:07,759 --> 00:05:10,800
okay so we've talked about these three

163
00:05:08,960 --> 00:05:12,239
limitations a limited number of

164
00:05:10,800 --> 00:05:14,160
languages so far

165
00:05:12,240 --> 00:05:15,759
fuzzy code matching or fuzzy symbol

166
00:05:14,160 --> 00:05:17,360
matching instead of precise

167
00:05:15,759 --> 00:05:19,440
and the fact that this is just within a

168
00:05:17,360 --> 00:05:20,160
repository instead of a cross repository

169
00:05:19,440 --> 00:05:23,199
boundaries

170
00:05:20,160 --> 00:05:24,320
and we are actively working on extending

171
00:05:23,199 --> 00:05:26,240
the code navigation

172
00:05:24,320 --> 00:05:27,680
implementation that's been launched to

173
00:05:26,240 --> 00:05:29,520
address all three of those

174
00:05:27,680 --> 00:05:31,600
limitations and what's really

175
00:05:29,520 --> 00:05:33,758
interesting is that for our purposes

176
00:05:31,600 --> 00:05:36,400
the main bottleneck the limiting factor

177
00:05:33,759 --> 00:05:38,000
here is really just a question of scale

178
00:05:36,400 --> 00:05:39,919
there are techniques out there that let

179
00:05:38,000 --> 00:05:41,840
us extract symbol information

180
00:05:39,919 --> 00:05:42,960
for more languages than just the three

181
00:05:41,840 --> 00:05:44,960
that have been launched

182
00:05:42,960 --> 00:05:46,080
and that let us extract precise symbol

183
00:05:44,960 --> 00:05:48,159
information not just

184
00:05:46,080 --> 00:05:49,758
fuzzy and can even do that across

185
00:05:48,160 --> 00:05:51,600
repository boundaries because we have

186
00:05:49,759 --> 00:05:52,000
the ability to parse manifest files and

187
00:05:51,600 --> 00:05:53,280
download

188
00:05:52,000 --> 00:05:55,199
all of the code and just you know run

189
00:05:53,280 --> 00:05:57,119
our implementation across

190
00:05:55,199 --> 00:05:58,240
all of your dependencies the issue is

191
00:05:57,120 --> 00:06:00,240
one of scale

192
00:05:58,240 --> 00:06:02,319
right so we've only launched to these

193
00:06:00,240 --> 00:06:04,240
three languages so far

194
00:06:02,319 --> 00:06:06,000
because the database that we're storing

195
00:06:04,240 --> 00:06:08,639
all of this data into is large enough to

196
00:06:06,000 --> 00:06:10,000
hold that set of three languages and we

197
00:06:08,639 --> 00:06:11,520
have to sort of increase our database

198
00:06:10,000 --> 00:06:12,720
size to be able to move on to the next

199
00:06:11,520 --> 00:06:16,479
one

200
00:06:12,720 --> 00:06:16,479
and it's the most recent comment

201
00:06:18,560 --> 00:06:22,000
so what we're doing right now is the

202
00:06:20,560 --> 00:06:24,560
most recent commit on

203
00:06:22,000 --> 00:06:26,319
any named branch so it's not just master

204
00:06:24,560 --> 00:06:27,600
it's any named branch but it is just the

205
00:06:26,319 --> 00:06:31,039
most recent one

206
00:06:27,600 --> 00:06:32,800
um it's in the same commit

207
00:06:31,039 --> 00:06:34,318
so you're looking at a particular commit

208
00:06:32,800 --> 00:06:36,080
because we're doing within repo right

209
00:06:34,319 --> 00:06:37,840
now we can do this on the commit level

210
00:06:36,080 --> 00:06:39,280
um so when you follow a link it keeps

211
00:06:37,840 --> 00:06:42,799
you within the current commit

212
00:06:39,280 --> 00:06:45,280
um we don't uh we we gc old commits

213
00:06:42,800 --> 00:06:46,319
but it's sort of as an ad hoc basis so

214
00:06:45,280 --> 00:06:48,239
you might still have

215
00:06:46,319 --> 00:06:49,440
lingering data but there's no guarantee

216
00:06:48,240 --> 00:06:52,240
that it'll stick around if it's not a

217
00:06:49,440 --> 00:06:52,240
named branch tip

218
00:06:52,479 --> 00:06:57,120
okay um so yeah so scale is the limiting

219
00:06:55,599 --> 00:06:58,159
factor here we want to figure out how to

220
00:06:57,120 --> 00:07:00,840
do this

221
00:06:58,160 --> 00:07:02,319
efficiently for the entire corpus of

222
00:07:00,840 --> 00:07:03,919
good

223
00:07:02,319 --> 00:07:05,759
so there's three main takeaways i want

224
00:07:03,919 --> 00:07:06,318
to hopefully convince you of sort of in

225
00:07:05,759 --> 00:07:07,759
related

226
00:07:06,319 --> 00:07:09,599
you know related to addressing these

227
00:07:07,759 --> 00:07:12,240
limitations the first

228
00:07:09,599 --> 00:07:14,159
is that local development is not the

229
00:07:12,240 --> 00:07:16,000
same as a hosted service and so the way

230
00:07:14,160 --> 00:07:19,039
that you would implement code navigation

231
00:07:16,000 --> 00:07:22,000
for editing locally in your ide

232
00:07:19,039 --> 00:07:23,680
on your laptop is different than how we

233
00:07:22,000 --> 00:07:25,759
would possibly implement code navigation

234
00:07:23,680 --> 00:07:27,120
for a large hosted service like github

235
00:07:25,759 --> 00:07:28,319
there's different constraints and that

236
00:07:27,120 --> 00:07:31,120
might lead us in the direction of a

237
00:07:28,319 --> 00:07:33,280
different implementation

238
00:07:31,120 --> 00:07:34,160
in particular because of the scale that

239
00:07:33,280 --> 00:07:37,280
we're operating at

240
00:07:34,160 --> 00:07:38,560
incremental processing is a must what

241
00:07:37,280 --> 00:07:40,880
this means is that

242
00:07:38,560 --> 00:07:41,599
as a new push is coming in from one of

243
00:07:40,880 --> 00:07:42,800
our users

244
00:07:41,599 --> 00:07:44,960
there's a very good chance that it's

245
00:07:42,800 --> 00:07:46,720
only touching a small number of files

246
00:07:44,960 --> 00:07:48,799
in the repository and that a lot of the

247
00:07:46,720 --> 00:07:49,440
files are unchanged from the previous

248
00:07:48,800 --> 00:07:51,520
commit

249
00:07:49,440 --> 00:07:53,039
we really really really want to be able

250
00:07:51,520 --> 00:07:55,198
to reuse the results

251
00:07:53,039 --> 00:07:57,039
from that previous commit not have to

252
00:07:55,199 --> 00:07:58,080
reanalyze the contents of a file that

253
00:07:57,039 --> 00:08:00,639
we've already seen

254
00:07:58,080 --> 00:08:01,599
not have to restore store additional

255
00:08:00,639 --> 00:08:03,199
copies of

256
00:08:01,599 --> 00:08:04,878
the data for the files that we've

257
00:08:03,199 --> 00:08:06,720
already seen we really want incremental

258
00:08:04,879 --> 00:08:08,400
processing

259
00:08:06,720 --> 00:08:09,280
and then lastly and this is maybe a

260
00:08:08,400 --> 00:08:10,638
little bit interesting and

261
00:08:09,280 --> 00:08:13,280
counter-intuitive

262
00:08:10,639 --> 00:08:14,000
if we can figure out how to generate

263
00:08:13,280 --> 00:08:17,119
precise

264
00:08:14,000 --> 00:08:19,039
symbol mappings incrementally within a

265
00:08:17,120 --> 00:08:21,280
repository

266
00:08:19,039 --> 00:08:22,240
that same solution will work for

267
00:08:21,280 --> 00:08:24,799
generating

268
00:08:22,240 --> 00:08:26,560
incremental precise symbol data across

269
00:08:24,800 --> 00:08:28,160
repository boundaries

270
00:08:26,560 --> 00:08:29,520
and that one maybe is like i said a

271
00:08:28,160 --> 00:08:30,800
little bit counterintuitive so once we

272
00:08:29,520 --> 00:08:32,799
see some examples later on

273
00:08:30,800 --> 00:08:33,919
hopefully i can convince you of that and

274
00:08:32,799 --> 00:08:35,519
it's nice because

275
00:08:33,919 --> 00:08:37,199
we can you know sort of solve this once

276
00:08:35,519 --> 00:08:39,440
for the in repository case

277
00:08:37,200 --> 00:08:41,200
get precise symbol mappings and then

278
00:08:39,440 --> 00:08:42,719
once we start to you know connect in

279
00:08:41,200 --> 00:08:44,000
with things like the dependency graph

280
00:08:42,719 --> 00:08:45,600
and other ways of you know

281
00:08:44,000 --> 00:08:47,360
expanding out and figuring out your

282
00:08:45,600 --> 00:08:48,800
package transitive closure

283
00:08:47,360 --> 00:08:51,680
then we can sort of extend this and get

284
00:08:48,800 --> 00:08:55,519
cross repo code nav as well

285
00:08:51,680 --> 00:08:57,439
cool okay let's jump in

286
00:08:55,519 --> 00:09:00,800
so the first takeaway local development

287
00:08:57,440 --> 00:09:02,480
is not the same as a hosted service

288
00:09:00,800 --> 00:09:04,000
uh otherwise known as why aren't we

289
00:09:02,480 --> 00:09:05,440
using lsp uh so

290
00:09:04,000 --> 00:09:06,959
can i do a quick straw poll here who

291
00:09:05,440 --> 00:09:08,959
here is familiar with the language

292
00:09:06,959 --> 00:09:10,479
server protocol

293
00:09:08,959 --> 00:09:12,239
we're not using it for codenav as

294
00:09:10,480 --> 00:09:13,920
shipped on github and we often get

295
00:09:12,240 --> 00:09:14,640
questions about why we're not so i'm

296
00:09:13,920 --> 00:09:16,319
going to certainly

297
00:09:14,640 --> 00:09:17,760
drill into some of the implementation

298
00:09:16,320 --> 00:09:20,160
constraints that led us in a different

299
00:09:17,760 --> 00:09:20,160
direction

300
00:09:21,040 --> 00:09:27,360
so what is true of local development

301
00:09:25,279 --> 00:09:28,640
right so what is true that makes the

302
00:09:27,360 --> 00:09:31,360
language server protocol

303
00:09:28,640 --> 00:09:32,160
a very very good implementation of code

304
00:09:31,360 --> 00:09:34,160
navigation

305
00:09:32,160 --> 00:09:35,680
for local development and it is by the

306
00:09:34,160 --> 00:09:37,360
way i'm not at all trying to disparage

307
00:09:35,680 --> 00:09:40,959
lsp at all

308
00:09:37,360 --> 00:09:42,560
so the first is that user choice is

309
00:09:40,959 --> 00:09:44,719
paramount right if

310
00:09:42,560 --> 00:09:46,239
the the stereotypical vi versus emacs

311
00:09:44,720 --> 00:09:47,360
debate and it's only extended since then

312
00:09:46,240 --> 00:09:49,440
this we have things like

313
00:09:47,360 --> 00:09:50,399
vs code and adam and other kinds of

314
00:09:49,440 --> 00:09:51,920
editors right

315
00:09:50,399 --> 00:09:53,680
user choice is important they're going

316
00:09:51,920 --> 00:09:56,160
to be using whatever editor they want

317
00:09:53,680 --> 00:09:57,760
we don't get to dictate what tools

318
00:09:56,160 --> 00:09:58,959
they're going to use on their laptop for

319
00:09:57,760 --> 00:10:00,480
local development

320
00:09:58,959 --> 00:10:03,040
in order to bring about something like

321
00:10:00,480 --> 00:10:05,279
code navigation as a useful feature

322
00:10:03,040 --> 00:10:06,800
and on the flip side the programming

323
00:10:05,279 --> 00:10:08,160
language that the user is using

324
00:10:06,800 --> 00:10:10,000
is something that we have no control

325
00:10:08,160 --> 00:10:11,839
over we want to provide code navigation

326
00:10:10,000 --> 00:10:14,320
as a useful service regardless of your

327
00:10:11,839 --> 00:10:15,600
if you're using go or python or ruby or

328
00:10:14,320 --> 00:10:18,240
rust or any of those

329
00:10:15,600 --> 00:10:20,079
so we have this very interesting m by n

330
00:10:18,240 --> 00:10:20,560
problem this matrix of capabilities

331
00:10:20,079 --> 00:10:22,399
where

332
00:10:20,560 --> 00:10:23,920
every editor needs to be able to support

333
00:10:22,399 --> 00:10:25,839
every single programming language in the

334
00:10:23,920 --> 00:10:27,760
worst case

335
00:10:25,839 --> 00:10:29,440
it's also interesting that your context

336
00:10:27,760 --> 00:10:30,800
is sort of like a single workspace like

337
00:10:29,440 --> 00:10:32,399
it's it's almost like a tunnel vision

338
00:10:30,800 --> 00:10:33,839
kind of thing there's one user

339
00:10:32,399 --> 00:10:35,040
or maybe a pair or something like that

340
00:10:33,839 --> 00:10:36,640
if you're working with somebody but

341
00:10:35,040 --> 00:10:39,199
you're looking at a single screen

342
00:10:36,640 --> 00:10:41,120
at a single thing at a time and so as

343
00:10:39,200 --> 00:10:43,040
the editor is shifting

344
00:10:41,120 --> 00:10:44,240
what as the user is shifting what it is

345
00:10:43,040 --> 00:10:47,279
that they're looking at

346
00:10:44,240 --> 00:10:48,800
the tool that is figuring out what the

347
00:10:47,279 --> 00:10:49,680
symbol data is and how it should be

348
00:10:48,800 --> 00:10:51,120
exposed

349
00:10:49,680 --> 00:10:53,279
needs to be shifting and changing as

350
00:10:51,120 --> 00:10:54,880
well so there's this uh

351
00:10:53,279 --> 00:10:56,240
single tunnel vision focus where they're

352
00:10:54,880 --> 00:10:57,200
really only looking at one thing at a

353
00:10:56,240 --> 00:10:58,800
time

354
00:10:57,200 --> 00:11:00,320
and lastly it needs to be very very

355
00:10:58,800 --> 00:11:01,199
interactive it looks like i misspelled

356
00:11:00,320 --> 00:11:04,480
that

357
00:11:01,200 --> 00:11:06,640
um maybe i didn't interactive so for

358
00:11:04,480 --> 00:11:08,399
local development as you're actively

359
00:11:06,640 --> 00:11:10,480
editing the code we want your editor to

360
00:11:08,399 --> 00:11:12,320
be able to respond quickly like as you

361
00:11:10,480 --> 00:11:13,839
type to the individual keystrokes

362
00:11:12,320 --> 00:11:15,440
so that means we need a very tight

363
00:11:13,839 --> 00:11:16,640
turnaround time we need to be able to

364
00:11:15,440 --> 00:11:18,560
react quickly

365
00:11:16,640 --> 00:11:20,399
to the changes that you're making and

366
00:11:18,560 --> 00:11:21,680
the tool that we're using to analyze the

367
00:11:20,399 --> 00:11:23,200
content of that code

368
00:11:21,680 --> 00:11:24,719
as you're editing it needs to be

369
00:11:23,200 --> 00:11:26,160
executing quickly enough

370
00:11:24,720 --> 00:11:30,160
that we can present the results to the

371
00:11:26,160 --> 00:11:30,160
user with very very low latency

372
00:11:30,320 --> 00:11:34,959
okay so all of these constraints sort of

373
00:11:33,279 --> 00:11:37,120
steer you in the direction of a solution

374
00:11:34,959 --> 00:11:39,199
and an lsp is sort of like the

375
00:11:37,120 --> 00:11:40,640
the the natural direction that you get

376
00:11:39,200 --> 00:11:42,160
to the natural shape of an

377
00:11:40,640 --> 00:11:44,480
implementation that you get to

378
00:11:42,160 --> 00:11:45,920
for those constraints and the way that

379
00:11:44,480 --> 00:11:47,680
it works if you're not familiar with it

380
00:11:45,920 --> 00:11:49,279
is that it sort of separates it provides

381
00:11:47,680 --> 00:11:51,359
a nice abstraction boundary

382
00:11:49,279 --> 00:11:53,040
between the part that knows about the

383
00:11:51,360 --> 00:11:54,560
programming language that you're using

384
00:11:53,040 --> 00:11:56,079
and the part that knows about the editor

385
00:11:54,560 --> 00:11:58,959
that you're using so if

386
00:11:56,079 --> 00:12:01,439
if any editor supports the lsp protocol

387
00:11:58,959 --> 00:12:03,839
it can consume code nav data from

388
00:12:01,440 --> 00:12:05,519
the language tooling for any programming

389
00:12:03,839 --> 00:12:06,639
language that supports the language sort

390
00:12:05,519 --> 00:12:08,320
of server protocol

391
00:12:06,639 --> 00:12:09,760
and vice versa so it's a really really

392
00:12:08,320 --> 00:12:11,680
good solution to this m

393
00:12:09,760 --> 00:12:13,519
by n problem because it's sort of that

394
00:12:11,680 --> 00:12:15,519
abstraction barrier turns it into an n

395
00:12:13,519 --> 00:12:17,680
plus n problem and that's great we love

396
00:12:15,519 --> 00:12:17,680
that

397
00:12:20,639 --> 00:12:24,000
the other thing that's interesting about

398
00:12:22,480 --> 00:12:26,720
how lsp works though is

399
00:12:24,000 --> 00:12:28,000
because of that sort of single context

400
00:12:26,720 --> 00:12:30,079
and interactivity

401
00:12:28,000 --> 00:12:31,519
constraints what's happening is that

402
00:12:30,079 --> 00:12:32,239
your language server is like a

403
00:12:31,519 --> 00:12:34,399
long-running

404
00:12:32,240 --> 00:12:35,279
sidecar process it's living right next

405
00:12:34,399 --> 00:12:36,720
to your editor

406
00:12:35,279 --> 00:12:38,639
and the connection between the two is

407
00:12:36,720 --> 00:12:40,480
very very chatty right there's

408
00:12:38,639 --> 00:12:42,240
the the editor is sending messages into

409
00:12:40,480 --> 00:12:44,079
the language server protocol to either

410
00:12:42,240 --> 00:12:45,920
give it the updates directly or to send

411
00:12:44,079 --> 00:12:46,959
it messages that a file has changed and

412
00:12:45,920 --> 00:12:49,040
it should reload

413
00:12:46,959 --> 00:12:50,880
but it's a very chatty uh back and forth

414
00:12:49,040 --> 00:12:53,120
communication pattern

415
00:12:50,880 --> 00:12:55,200
so that means that the language server

416
00:12:53,120 --> 00:12:57,839
is able to maintain

417
00:12:55,200 --> 00:12:59,360
a state in memory about its current view

418
00:12:57,839 --> 00:13:01,120
of the code that's being edited

419
00:12:59,360 --> 00:13:02,720
and that's what allows it to get the

420
00:13:01,120 --> 00:13:03,519
sort of very tight turnaround the low

421
00:13:02,720 --> 00:13:07,839
latency

422
00:13:03,519 --> 00:13:07,839
that that supports the interactivity

423
00:13:08,399 --> 00:13:12,000
okay what's different about a hosted

424
00:13:09,680 --> 00:13:13,599
service so

425
00:13:12,000 --> 00:13:15,680
on the one hand we don't have a single

426
00:13:13,600 --> 00:13:17,040
context it's not one user with a single

427
00:13:15,680 --> 00:13:18,079
window in their editor looking at a

428
00:13:17,040 --> 00:13:20,160
single thing

429
00:13:18,079 --> 00:13:22,160
it's millions of users looking at

430
00:13:20,160 --> 00:13:23,760
millions of repositories at any given

431
00:13:22,160 --> 00:13:24,800
time and we don't really know in advance

432
00:13:23,760 --> 00:13:25,680
what it is that they're going to want to

433
00:13:24,800 --> 00:13:27,760
look at

434
00:13:25,680 --> 00:13:29,199
so in some ways we kind of just have to

435
00:13:27,760 --> 00:13:30,240
steer into the idea that what we're

436
00:13:29,200 --> 00:13:31,920
looking at here

437
00:13:30,240 --> 00:13:33,360
is something like a database we just

438
00:13:31,920 --> 00:13:35,920
need to be able to store

439
00:13:33,360 --> 00:13:38,000
the symbol data for all of the

440
00:13:35,920 --> 00:13:39,839
repositories that our users are creating

441
00:13:38,000 --> 00:13:41,440
and browsing and interacting with

442
00:13:39,839 --> 00:13:42,959
and make sure that it's available for

443
00:13:41,440 --> 00:13:45,279
them whenever they come

444
00:13:42,959 --> 00:13:47,518
and want to query it about any of those

445
00:13:45,279 --> 00:13:50,160
repositories or branches or whatever

446
00:13:47,519 --> 00:13:51,600
so it needs to be immediately available

447
00:13:50,160 --> 00:13:53,040
but it's also something where we don't

448
00:13:51,600 --> 00:13:54,800
get to sort of have that

449
00:13:53,040 --> 00:13:56,639
single focus that allows us to do one

450
00:13:54,800 --> 00:13:59,279
thing at a time with a nice in-memory

451
00:13:56,639 --> 00:13:59,279
representation

452
00:13:59,440 --> 00:14:04,000
we don't need the as you type

453
00:14:02,160 --> 00:14:05,680
interactivity because

454
00:14:04,000 --> 00:14:07,279
you're not actually interacting with the

455
00:14:05,680 --> 00:14:08,000
hosted service as you're editing the

456
00:14:07,279 --> 00:14:10,880
code

457
00:14:08,000 --> 00:14:12,399
we are instead responding to pushes as

458
00:14:10,880 --> 00:14:13,760
they come in so they make some edits

459
00:14:12,399 --> 00:14:14,959
they make a commit locally and then they

460
00:14:13,760 --> 00:14:18,000
push it up to github

461
00:14:14,959 --> 00:14:19,839
we need to react to those pushes so we

462
00:14:18,000 --> 00:14:21,440
don't have quite the same

463
00:14:19,839 --> 00:14:22,959
tight latency bounds quite the same

464
00:14:21,440 --> 00:14:24,480
interactivity requirements

465
00:14:22,959 --> 00:14:26,800
but we do actually still care about

466
00:14:24,480 --> 00:14:28,240
latency because we want it to be the

467
00:14:26,800 --> 00:14:30,000
case what we're sort of aiming for

468
00:14:28,240 --> 00:14:33,120
internally as our team goal

469
00:14:30,000 --> 00:14:33,519
is that once you save locally and push

470
00:14:33,120 --> 00:14:35,440
up

471
00:14:33,519 --> 00:14:36,720
we kind of want the data to be available

472
00:14:35,440 --> 00:14:38,959
on github.com

473
00:14:36,720 --> 00:14:40,000
before you have a chance to alt tab over

474
00:14:38,959 --> 00:14:41,599
to your web browser

475
00:14:40,000 --> 00:14:43,120
from your git client whether it's

476
00:14:41,600 --> 00:14:44,000
command line or editor or whatever so

477
00:14:43,120 --> 00:14:45,440
that's like really

478
00:14:44,000 --> 00:14:47,839
tight we still have to be able to

479
00:14:45,440 --> 00:14:48,880
process really really quickly

480
00:14:47,839 --> 00:14:50,079
and that informs that sort of

481
00:14:48,880 --> 00:14:52,800
incremental processing that i was

482
00:14:50,079 --> 00:14:52,800
talking about earlier

483
00:14:54,639 --> 00:14:58,399
another constraint or another feature of

484
00:14:56,880 --> 00:15:00,320
of a hosted service here is that

485
00:14:58,399 --> 00:15:01,519
everything is hidden behind an api so we

486
00:15:00,320 --> 00:15:04,000
don't actually have

487
00:15:01,519 --> 00:15:05,680
quite the same m by n problem that you

488
00:15:04,000 --> 00:15:09,279
do for local development

489
00:15:05,680 --> 00:15:10,880
we have one web ui and

490
00:15:09,279 --> 00:15:12,639
we have to provide data for it but we

491
00:15:10,880 --> 00:15:15,519
don't have to provide data for it

492
00:15:12,639 --> 00:15:16,800
in a way that's directly consumable by

493
00:15:15,519 --> 00:15:18,399
lots of different clients or the way

494
00:15:16,800 --> 00:15:19,760
that we do that is through an api that

495
00:15:18,399 --> 00:15:21,120
you know sort of is

496
00:15:19,760 --> 00:15:24,000
again sort of like a single thing that

497
00:15:21,120 --> 00:15:24,000
we just get to implement

498
00:15:24,160 --> 00:15:27,920
and then the last thing is that we carry

499
00:15:25,440 --> 00:15:29,440
a pager right this is a hosted service

500
00:15:27,920 --> 00:15:31,199
my team is responsible for making sure

501
00:15:29,440 --> 00:15:32,800
that it's up and running 24 7.

502
00:15:31,199 --> 00:15:34,560
so we really need to have a deep

503
00:15:32,800 --> 00:15:36,719
understanding of all of the different

504
00:15:34,560 --> 00:15:38,160
libraries and pieces of software that

505
00:15:36,720 --> 00:15:38,959
goes into the implementation of our

506
00:15:38,160 --> 00:15:40,959
service

507
00:15:38,959 --> 00:15:42,638
and that means that adopting external

508
00:15:40,959 --> 00:15:44,560
code like a language server

509
00:15:42,639 --> 00:15:46,079
even if it's very very capable and

510
00:15:44,560 --> 00:15:47,758
accurate that's just

511
00:15:46,079 --> 00:15:49,359
uh it's adding operational and

512
00:15:47,759 --> 00:15:50,800
maintenance work on top

513
00:15:49,360 --> 00:15:52,720
of the work that my team is already

514
00:15:50,800 --> 00:15:53,120
doing even if it is saving development

515
00:15:52,720 --> 00:15:56,720
work

516
00:15:53,120 --> 00:15:56,720
so it's not necessarily a free ride

517
00:15:57,440 --> 00:16:01,839
so how are we going to do that instead

518
00:15:58,800 --> 00:16:02,959
right so we we don't have the end by end

519
00:16:01,839 --> 00:16:04,399
problem where we have to worry about

520
00:16:02,959 --> 00:16:05,599
supporting lots of editors but we do

521
00:16:04,399 --> 00:16:07,519
still have the part of it where we have

522
00:16:05,600 --> 00:16:08,560
to support lots of programming languages

523
00:16:07,519 --> 00:16:10,000
i'm going to go through this part

524
00:16:08,560 --> 00:16:11,680
relatively quickly because i you know

525
00:16:10,000 --> 00:16:13,440
i'm starting to get limited for time

526
00:16:11,680 --> 00:16:15,199
but we want to make it as easy as

527
00:16:13,440 --> 00:16:16,880
possible to add

528
00:16:15,199 --> 00:16:19,758
support for a new programming language

529
00:16:16,880 --> 00:16:21,439
to our program analysis framework

530
00:16:19,759 --> 00:16:23,120
and the way that we do this is through

531
00:16:21,440 --> 00:16:24,480
code generation we want to still limit

532
00:16:23,120 --> 00:16:26,240
the amount of development work that it

533
00:16:24,480 --> 00:16:28,720
takes

534
00:16:26,240 --> 00:16:30,079
so for us for symantec the open source

535
00:16:28,720 --> 00:16:30,639
project that we've created for all of

536
00:16:30,079 --> 00:16:32,000
this

537
00:16:30,639 --> 00:16:33,680
the first thing that's required for

538
00:16:32,000 --> 00:16:35,040
adding support for a new language is to

539
00:16:33,680 --> 00:16:37,599
create a parser for it

540
00:16:35,040 --> 00:16:39,040
using the tree sitter parsing framework

541
00:16:37,600 --> 00:16:40,639
that's another open source project that

542
00:16:39,040 --> 00:16:42,319
my team is responsible for

543
00:16:40,639 --> 00:16:43,920
it's used for other interesting use

544
00:16:42,320 --> 00:16:44,959
cases like syntax highlighting on

545
00:16:43,920 --> 00:16:47,120
github.com

546
00:16:44,959 --> 00:16:48,399
and in an increasingly increasing number

547
00:16:47,120 --> 00:16:51,519
of editors

548
00:16:48,399 --> 00:16:52,959
so we're hoping that the act of creating

549
00:16:51,519 --> 00:16:53,839
a tree sitter parser will be something

550
00:16:52,959 --> 00:16:55,518
that there's enough

551
00:16:53,839 --> 00:16:57,279
value to that language communities will

552
00:16:55,519 --> 00:16:58,480
take that work on themselves

553
00:16:57,279 --> 00:17:00,720
and it's not that hard it's it's a

554
00:16:58,480 --> 00:17:02,160
parser right it's it's uh

555
00:17:00,720 --> 00:17:03,120
relatively straightforward and we think

556
00:17:02,160 --> 00:17:04,879
that there's you know decent

557
00:17:03,120 --> 00:17:07,439
documentation for this so

558
00:17:04,880 --> 00:17:09,600
this is an example of the tree sitter go

559
00:17:07,439 --> 00:17:12,559
parser this is the rule for a function

560
00:17:09,599 --> 00:17:14,799
call the syntax for a function call

561
00:17:12,559 --> 00:17:16,480
what's interesting is that tree sitter

562
00:17:14,799 --> 00:17:18,240
in addition to producing the actual

563
00:17:16,480 --> 00:17:19,520
code that implements the parser giving

564
00:17:18,240 --> 00:17:21,599
that parser description

565
00:17:19,520 --> 00:17:22,720
will also create a nice machine readable

566
00:17:21,599 --> 00:17:25,119
description

567
00:17:22,720 --> 00:17:26,720
of the parse states that go into the

568
00:17:25,119 --> 00:17:28,399
implementation of the parser

569
00:17:26,720 --> 00:17:30,559
why is that important the fact that it's

570
00:17:28,400 --> 00:17:33,200
machine readable means that

571
00:17:30,559 --> 00:17:34,240
this is the entirety of the code in

572
00:17:33,200 --> 00:17:36,240
semantic

573
00:17:34,240 --> 00:17:37,360
that allows us to use a tree sitter

574
00:17:36,240 --> 00:17:39,200
parser for go

575
00:17:37,360 --> 00:17:40,959
and have the parse results available in

576
00:17:39,200 --> 00:17:41,919
the rest of our library so we're using

577
00:17:40,960 --> 00:17:44,080
haskell

578
00:17:41,919 --> 00:17:45,440
this is using a feature of haskell

579
00:17:44,080 --> 00:17:47,039
called template haskell

580
00:17:45,440 --> 00:17:48,720
it's basically just code generation

581
00:17:47,039 --> 00:17:50,320
running inside the compiler instead of

582
00:17:48,720 --> 00:17:51,520
as like a separate script as part of

583
00:17:50,320 --> 00:17:53,280
your build process

584
00:17:51,520 --> 00:17:54,879
but this is just running some code that

585
00:17:53,280 --> 00:17:56,320
says you know take in that machine

586
00:17:54,880 --> 00:17:58,080
readable description

587
00:17:56,320 --> 00:18:00,240
of the go parser and it will

588
00:17:58,080 --> 00:18:02,080
automatically generate all of the

589
00:18:00,240 --> 00:18:04,320
haskell data types that we will use to

590
00:18:02,080 --> 00:18:06,080
store the parse results

591
00:18:04,320 --> 00:18:07,600
and that includes generating api

592
00:18:06,080 --> 00:18:09,918
documentation so if you go look

593
00:18:07,600 --> 00:18:11,199
at package which is the haskell package

594
00:18:09,919 --> 00:18:13,120
management

595
00:18:11,200 --> 00:18:14,960
package manager you can see the linked

596
00:18:13,120 --> 00:18:15,360
documentation for all of this generated

597
00:18:14,960 --> 00:18:18,559
code

598
00:18:15,360 --> 00:18:19,840
even though these uh data types don't

599
00:18:18,559 --> 00:18:21,280
exist directly in the code

600
00:18:19,840 --> 00:18:22,959
itself so we still have documentation

601
00:18:21,280 --> 00:18:25,200
for it

602
00:18:22,960 --> 00:18:27,280
given those data types you can write an

603
00:18:25,200 --> 00:18:28,880
instance of some pattern matching rules

604
00:18:27,280 --> 00:18:30,559
so if you haven't programmed in haskell

605
00:18:28,880 --> 00:18:31,520
this might look kind of esoteric and

606
00:18:30,559 --> 00:18:33,120
hard to follow

607
00:18:31,520 --> 00:18:35,360
but if you have followed haskell i think

608
00:18:33,120 --> 00:18:37,439
it's actually relatively readable

609
00:18:35,360 --> 00:18:39,120
what it's doing is it's basically taking

610
00:18:37,440 --> 00:18:41,520
apart those

611
00:18:39,120 --> 00:18:42,879
parsed ast representations of the code

612
00:18:41,520 --> 00:18:45,120
and what this is saying

613
00:18:42,880 --> 00:18:47,120
is that if you have a call expression

614
00:18:45,120 --> 00:18:48,959
that is a definition

615
00:18:47,120 --> 00:18:50,399
no sorry a reference call expression not

616
00:18:48,960 --> 00:18:52,160
not a function definition if you have a

617
00:18:50,400 --> 00:18:54,320
call expression this is a reference

618
00:18:52,160 --> 00:18:55,520
and so it's pulling out the parts of the

619
00:18:54,320 --> 00:18:57,600
call expression

620
00:18:55,520 --> 00:18:59,120
that define the symbol name for that

621
00:18:57,600 --> 00:19:00,799
reference

622
00:18:59,120 --> 00:19:02,320
and you know there's a few different

623
00:19:00,799 --> 00:19:02,559
possibilities depending on if it's like

624
00:19:02,320 --> 00:19:04,799
a

625
00:19:02,559 --> 00:19:05,678
qualified name or not but you know it's

626
00:19:04,799 --> 00:19:07,120
it's a sort of

627
00:19:05,679 --> 00:19:08,400
relatively small number of cases that

628
00:19:07,120 --> 00:19:09,120
you have to think about for this

629
00:19:08,400 --> 00:19:11,280
particular

630
00:19:09,120 --> 00:19:12,559
parse note there's a little bit of

631
00:19:11,280 --> 00:19:14,240
boilerplate where you have to go through

632
00:19:12,559 --> 00:19:15,600
and say that for all of the other ones

633
00:19:14,240 --> 00:19:17,280
you don't get to there aren't any

634
00:19:15,600 --> 00:19:18,959
definitions or references there

635
00:19:17,280 --> 00:19:20,480
so it's a little bit of boilerplate but

636
00:19:18,960 --> 00:19:22,880
you're at least not having to say how to

637
00:19:20,480 --> 00:19:24,720
recurse down into the parse trees so it

638
00:19:22,880 --> 00:19:26,240
could be worse

639
00:19:24,720 --> 00:19:28,000
but once you've done that we've

640
00:19:26,240 --> 00:19:32,799
extracted all of the data that we need

641
00:19:28,000 --> 00:19:32,799
for go to do fuzzy code match

642
00:19:33,440 --> 00:19:37,760
okay so what's really nice about that

643
00:19:36,240 --> 00:19:39,360
approach is that we can produce the data

644
00:19:37,760 --> 00:19:41,120
incrementally so i called out earlier

645
00:19:39,360 --> 00:19:43,039
that that's really important to us

646
00:19:41,120 --> 00:19:44,719
if you use something like this to pull

647
00:19:43,039 --> 00:19:46,400
out the list of definitions and

648
00:19:44,720 --> 00:19:49,360
references in a file

649
00:19:46,400 --> 00:19:50,160
that list depends only on the content of

650
00:19:49,360 --> 00:19:51,678
that file

651
00:19:50,160 --> 00:19:53,679
it doesn't depend on any of the other

652
00:19:51,679 --> 00:19:54,960
files in your repository

653
00:19:53,679 --> 00:19:56,799
and that's exactly the incremental

654
00:19:54,960 --> 00:19:57,919
property that we care about a new file a

655
00:19:56,799 --> 00:20:00,000
new commit comes in

656
00:19:57,919 --> 00:20:01,600
if the file is unchanged we get to reuse

657
00:20:00,000 --> 00:20:02,880
the list of definitions and references

658
00:20:01,600 --> 00:20:04,399
that we had already calculated

659
00:20:02,880 --> 00:20:07,840
that's in our database already we just

660
00:20:04,400 --> 00:20:07,840
leave it there we're good to go

661
00:20:08,080 --> 00:20:12,000
so incremental processing is absolutely

662
00:20:09,760 --> 00:20:12,720
a must the only reason we were able to

663
00:20:12,000 --> 00:20:15,360
ship

664
00:20:12,720 --> 00:20:16,000
fuzzy code nav in the way that we did

665
00:20:15,360 --> 00:20:18,000
for the

666
00:20:16,000 --> 00:20:19,919
set of repositories that we did for all

667
00:20:18,000 --> 00:20:20,640
of the python go and ruby packages on

668
00:20:19,919 --> 00:20:21,919
github

669
00:20:20,640 --> 00:20:23,840
is because of that incremental

670
00:20:21,919 --> 00:20:25,360
processing if we didn't have it the cpu

671
00:20:23,840 --> 00:20:26,959
requirements would have been too high

672
00:20:25,360 --> 00:20:29,120
the data storage would have been too

673
00:20:26,960 --> 00:20:30,559
high and the user perceived latency

674
00:20:29,120 --> 00:20:31,840
would have been too high right like we

675
00:20:30,559 --> 00:20:33,200
talked about wanting to have the data

676
00:20:31,840 --> 00:20:34,000
ready when you alt tab over to the

677
00:20:33,200 --> 00:20:36,240
browser

678
00:20:34,000 --> 00:20:38,000
if you have to process all five or ten

679
00:20:36,240 --> 00:20:38,480
thousand files in your repository every

680
00:20:38,000 --> 00:20:41,280
time

681
00:20:38,480 --> 00:20:41,280
it's not going to happen

682
00:20:41,520 --> 00:20:46,240
so the important question is can we do

683
00:20:43,280 --> 00:20:48,000
this also for precise symbol matches

684
00:20:46,240 --> 00:20:49,440
if we want to actually say that this

685
00:20:48,000 --> 00:20:51,760
particular function

686
00:20:49,440 --> 00:20:53,280
call refers to this particular method

687
00:20:51,760 --> 00:20:54,799
and not any of the other ones that

688
00:20:53,280 --> 00:20:58,320
happens to have the same name

689
00:20:54,799 --> 00:21:00,000
can we do that incrementally and to show

690
00:20:58,320 --> 00:21:01,520
why it's kind of an issue right so this

691
00:21:00,000 --> 00:21:03,039
is just a very toy example where you've

692
00:21:01,520 --> 00:21:04,879
got three python files

693
00:21:03,039 --> 00:21:06,080
if somebody wanted to click on that

694
00:21:04,880 --> 00:21:07,440
reference to foo

695
00:21:06,080 --> 00:21:09,199
we would love to be able to show them

696
00:21:07,440 --> 00:21:10,720
that it refers to this definition down

697
00:21:09,200 --> 00:21:12,159
in b.pie

698
00:21:10,720 --> 00:21:13,520
and if you just sort of look at this

699
00:21:12,159 --> 00:21:14,640
hopefully you can see that that is the

700
00:21:13,520 --> 00:21:16,400
case there's a couple of

701
00:21:14,640 --> 00:21:18,240
import statements that sort of propagate

702
00:21:16,400 --> 00:21:20,480
the reference through a couple of files

703
00:21:18,240 --> 00:21:21,760
but this is the example where that sort

704
00:21:20,480 --> 00:21:23,760
of highlights how it's not

705
00:21:21,760 --> 00:21:24,879
incremental at least in the sort of

706
00:21:23,760 --> 00:21:27,760
naive case

707
00:21:24,880 --> 00:21:29,679
because we have to look at files that

708
00:21:27,760 --> 00:21:31,520
aren't the one that holds the definition

709
00:21:29,679 --> 00:21:32,880
or the one that holds a reference and

710
00:21:31,520 --> 00:21:34,639
to be able to figure out what it

711
00:21:32,880 --> 00:21:36,159
actually points to

712
00:21:34,640 --> 00:21:38,400
and if a new commit comes in that

713
00:21:36,159 --> 00:21:40,559
changes that file in the middle

714
00:21:38,400 --> 00:21:41,919
right we've changed not just what foo

715
00:21:40,559 --> 00:21:44,639
refers to but which

716
00:21:41,919 --> 00:21:45,200
file the thing that foo refers to lives

717
00:21:44,640 --> 00:21:47,360
in

718
00:21:45,200 --> 00:21:50,960
in a way that depended on basically the

719
00:21:47,360 --> 00:21:50,959
entire contents of your repository

720
00:21:51,120 --> 00:21:54,080
and it gets even worse if you have to

721
00:21:52,640 --> 00:21:55,919
sort of trace things through function

722
00:21:54,080 --> 00:21:58,799
calls right so this is trying to say

723
00:21:55,919 --> 00:22:01,120
i want this reference to foo to refer to

724
00:21:58,799 --> 00:22:02,799
the field down here in this class

725
00:22:01,120 --> 00:22:04,639
but that's being passed through a

726
00:22:02,799 --> 00:22:05,840
function call in a really weird way and

727
00:22:04,640 --> 00:22:06,559
that function is living in a different

728
00:22:05,840 --> 00:22:08,799
file so

729
00:22:06,559 --> 00:22:10,080
how can we do this in an incremental way

730
00:22:08,799 --> 00:22:11,520
as well it's not just sort of

731
00:22:10,080 --> 00:22:12,639
syntactically do the things live in

732
00:22:11,520 --> 00:22:14,559
different files but

733
00:22:12,640 --> 00:22:15,840
are you tracing things through control

734
00:22:14,559 --> 00:22:17,918
flow that bounces through different

735
00:22:15,840 --> 00:22:20,959
files at runtime in different ways

736
00:22:17,919 --> 00:22:21,360
and this is really hard and i don't have

737
00:22:20,960 --> 00:22:22,640
an

738
00:22:21,360 --> 00:22:24,000
answer that i can tell you about we have

739
00:22:22,640 --> 00:22:25,200
we have experiments that are starting to

740
00:22:24,000 --> 00:22:28,000
work and hopefully we can tell you

741
00:22:25,200 --> 00:22:29,840
really quickly and soon about it working

742
00:22:28,000 --> 00:22:31,360
but this is why it's really really

743
00:22:29,840 --> 00:22:32,639
difficult this is another reason why we

744
00:22:31,360 --> 00:22:34,080
can't rely on something like the

745
00:22:32,640 --> 00:22:36,080
language server protocol

746
00:22:34,080 --> 00:22:37,840
because it will give us something like

747
00:22:36,080 --> 00:22:38,559
this if your lsp implementation is

748
00:22:37,840 --> 00:22:41,120
really good

749
00:22:38,559 --> 00:22:42,559
but it's going to require a lot of cpu

750
00:22:41,120 --> 00:22:44,399
and it's going to have to look at and

751
00:22:42,559 --> 00:22:47,120
analyze the contents of the entirety of

752
00:22:44,400 --> 00:22:50,320
your repository every time

753
00:22:47,120 --> 00:22:52,000
okay last one i hope that i can really

754
00:22:50,320 --> 00:22:52,480
quickly in my remaining time convince

755
00:22:52,000 --> 00:22:54,240
you that

756
00:22:52,480 --> 00:22:56,080
within repository is the same as cross

757
00:22:54,240 --> 00:22:59,120
repository right so

758
00:22:56,080 --> 00:22:59,439
if we can find an answer that works for

759
00:22:59,120 --> 00:23:00,639
this

760
00:22:59,440 --> 00:23:02,480
here's the shortest version of this

761
00:23:00,640 --> 00:23:04,480
argument it doesn't matter whether these

762
00:23:02,480 --> 00:23:05,679
two files live in the same repository or

763
00:23:04,480 --> 00:23:06,559
in a different package in another

764
00:23:05,679 --> 00:23:08,080
repository

765
00:23:06,559 --> 00:23:09,678
the only thing that changed is the set

766
00:23:08,080 --> 00:23:11,600
of files that we have to look at when we

767
00:23:09,679 --> 00:23:13,280
try to stitch things together

768
00:23:11,600 --> 00:23:16,158
if we can figure out how to do this on a

769
00:23:13,280 --> 00:23:17,360
per file basis the location of the files

770
00:23:16,159 --> 00:23:19,440
what packages they live in what

771
00:23:17,360 --> 00:23:19,918
repositories they live in is no longer

772
00:23:19,440 --> 00:23:21,360
the

773
00:23:19,919 --> 00:23:23,840
sort of bottleneck concern that we have

774
00:23:21,360 --> 00:23:23,840
to worry about

775
00:23:27,280 --> 00:23:30,879
so that's that's the end i think we

776
00:23:30,000 --> 00:23:32,480
probably don't have

777
00:23:30,880 --> 00:23:37,840
a lot of time for very many questions

778
00:23:32,480 --> 00:23:37,840
but thanks very much for your attention

779
00:23:42,320 --> 00:23:51,840
okay cool any questions

780
00:23:58,960 --> 00:24:02,880
yes it absolutely will so the question

781
00:24:00,720 --> 00:24:04,559
was for the precise code matching are we

782
00:24:02,880 --> 00:24:06,400
going to be doing anything with graph

783
00:24:04,559 --> 00:24:10,158
theory basically and the short answer is

784
00:24:06,400 --> 00:24:11,520
yes yes very much yes um and and briefly

785
00:24:10,159 --> 00:24:12,559
the part that's hard is that if you

786
00:24:11,520 --> 00:24:15,120
tried to

787
00:24:12,559 --> 00:24:16,000
construct a call graph that encoded that

788
00:24:15,120 --> 00:24:17,678
information

789
00:24:16,000 --> 00:24:19,120
the problem is that the portions of the

790
00:24:17,679 --> 00:24:22,000
graph that

791
00:24:19,120 --> 00:24:23,439
uh come from this file might live in

792
00:24:22,000 --> 00:24:24,799
remote parts of the graph because you

793
00:24:23,440 --> 00:24:26,480
had to follow those links into other

794
00:24:24,799 --> 00:24:28,158
files and that's sort of like uh

795
00:24:26,480 --> 00:24:30,240
a pres or like a nice succinct

796
00:24:28,159 --> 00:24:32,559
description of why it's not

797
00:24:30,240 --> 00:24:34,000
easily and obviously incremental because

798
00:24:32,559 --> 00:24:35,600
the structure of that graph is not

799
00:24:34,000 --> 00:24:36,960
something that obviously depends only on

800
00:24:35,600 --> 00:24:38,000
the contents of your file

801
00:24:36,960 --> 00:24:41,200
but there will definitely be graph

802
00:24:38,000 --> 00:24:41,200
structure involved in order to make it

803
00:24:44,840 --> 00:24:47,840
work

804
00:24:48,320 --> 00:24:51,600
uh so will we be analyzing code from

805
00:24:50,159 --> 00:24:52,559
third-party package managers and so i

806
00:24:51,600 --> 00:24:54,879
guess to

807
00:24:52,559 --> 00:24:56,799
clarify you mean a package uploaded to

808
00:24:54,880 --> 00:24:59,200
npm where the source did not come

809
00:24:56,799 --> 00:25:01,360
from a git repository and probably even

810
00:24:59,200 --> 00:25:02,720
github in particular

811
00:25:01,360 --> 00:25:04,559
so there's a couple of answers to that

812
00:25:02,720 --> 00:25:06,480
one is that all of this is in a couple

813
00:25:04,559 --> 00:25:08,000
of open source libraries so semantic and

814
00:25:06,480 --> 00:25:09,520
tree center are open source and so you

815
00:25:08,000 --> 00:25:10,240
could use the tools to analyze that

816
00:25:09,520 --> 00:25:11,760
yourself

817
00:25:10,240 --> 00:25:13,440
it's not something that at least for the

818
00:25:11,760 --> 00:25:15,840
first revision we plan on

819
00:25:13,440 --> 00:25:17,120
including not because we don't want to

820
00:25:15,840 --> 00:25:18,240
but just because we're trying to limit

821
00:25:17,120 --> 00:25:21,279
scope and have something that's a little

822
00:25:18,240 --> 00:25:21,279
bit more tractable to begin

823
00:25:27,279 --> 00:25:31,279
method with working across multiple

824
00:25:30,559 --> 00:25:33,520
files

825
00:25:31,279 --> 00:25:35,120
do you anticipate that that is something

826
00:25:33,520 --> 00:25:35,918
that could ultimately be translated to

827
00:25:35,120 --> 00:25:40,080
making a

828
00:25:35,919 --> 00:25:40,080
more efficient cpu efficiency

829
00:25:40,799 --> 00:25:44,240
that's a really good question so the

830
00:25:41,919 --> 00:25:47,039
question was if we can do this

831
00:25:44,240 --> 00:25:48,799
incremental precise extraction in a

832
00:25:47,039 --> 00:25:49,440
cross-file way that works for our hosted

833
00:25:48,799 --> 00:25:51,918
service

834
00:25:49,440 --> 00:25:53,120
will any of those uh benefits translate

835
00:25:51,919 --> 00:25:56,799
over to codenav

836
00:25:53,120 --> 00:25:59,760
in local development and

837
00:25:56,799 --> 00:26:00,960
i mean yes in that the techniques would

838
00:25:59,760 --> 00:26:03,440
certainly work there and

839
00:26:00,960 --> 00:26:04,799
in that you are still doing things like

840
00:26:03,440 --> 00:26:06,400
creating commits and

841
00:26:04,799 --> 00:26:08,639
doing edits as you type and stuff like

842
00:26:06,400 --> 00:26:10,320
that we can probably still have that

843
00:26:08,640 --> 00:26:12,320
incremental thing work

844
00:26:10,320 --> 00:26:13,760
it's in the local development in the

845
00:26:12,320 --> 00:26:15,200
editing case it's actually even a little

846
00:26:13,760 --> 00:26:16,559
bit more fine-grained it's not just that

847
00:26:15,200 --> 00:26:17,120
you want to care about the edits to the

848
00:26:16,559 --> 00:26:18,240
file

849
00:26:17,120 --> 00:26:20,158
it's that you want to care about the

850
00:26:18,240 --> 00:26:21,279
edits to the particular part of the file

851
00:26:20,159 --> 00:26:23,360
right so a lot of the

852
00:26:21,279 --> 00:26:25,679
incremental things and editors recognize

853
00:26:23,360 --> 00:26:27,199
that i changed this line and so i don't

854
00:26:25,679 --> 00:26:29,679
have to re-syntax highlight

855
00:26:27,200 --> 00:26:31,039
the seven pages that occurred before and

856
00:26:29,679 --> 00:26:32,559
that's something that wouldn't directly

857
00:26:31,039 --> 00:26:34,559
translate across because we really are

858
00:26:32,559 --> 00:26:39,840
operating on the file boundary with what

859
00:26:34,559 --> 00:26:39,840
we're doing right now

860
00:26:54,880 --> 00:26:59,919
yeah so are we are we doing things where

861
00:26:57,039 --> 00:27:03,200
we can do cogeneration based on

862
00:26:59,919 --> 00:27:04,640
extracting asts um we that's that is

863
00:27:03,200 --> 00:27:06,080
effectively what we're doing it's just

864
00:27:04,640 --> 00:27:07,679
that we've sort of at least right now

865
00:27:06,080 --> 00:27:09,199
again for limiting scope we're just sort

866
00:27:07,679 --> 00:27:10,480
of locking down the way that you would

867
00:27:09,200 --> 00:27:11,760
implement the parser that generates

868
00:27:10,480 --> 00:27:13,360
those asts

869
00:27:11,760 --> 00:27:15,919
but but that is what we're doing so we

870
00:27:13,360 --> 00:27:17,600
have um we get the source code we

871
00:27:15,919 --> 00:27:19,279
extract an est from it and then we run

872
00:27:17,600 --> 00:27:20,959
that sort of pattern matching code that

873
00:27:19,279 --> 00:27:23,840
i showed you the example of

874
00:27:20,960 --> 00:27:27,120
to extract from that the definitions and

875
00:27:23,840 --> 00:27:27,120
references out of that ast

876
00:27:27,520 --> 00:27:35,840
okay i think with that i'm done thanks

877
00:27:29,520 --> 00:27:35,840
very much

878
00:27:40,640 --> 00:27:42,720
you

