1
00:00:04,960 --> 00:00:08,000
hello everyone

2
00:00:06,399 --> 00:00:10,719
let's welcome our next speaker in

3
00:00:08,000 --> 00:00:13,920
security lever room it's gills and

4
00:00:10,719 --> 00:00:17,240
his talk about implement incrementality

5
00:00:13,920 --> 00:00:21,119
and deck functions

6
00:00:17,240 --> 00:00:24,560
[Applause]

7
00:00:21,119 --> 00:00:26,480
thank you welcome everyone thank you for

8
00:00:24,560 --> 00:00:28,880
attending my talk during the lunch time

9
00:00:26,480 --> 00:00:30,800
or almost lunch time

10
00:00:28,880 --> 00:00:32,558
so indeed in this talk i will talk about

11
00:00:30,800 --> 00:00:35,120
symmetric cryptography

12
00:00:32,558 --> 00:00:36,640
and um i will talk about some some

13
00:00:35,120 --> 00:00:39,440
considerations we've had

14
00:00:36,640 --> 00:00:40,960
recently um around the notion of

15
00:00:39,440 --> 00:00:44,160
incrementality

16
00:00:40,960 --> 00:00:46,239
so when i say we in this presentation

17
00:00:44,160 --> 00:00:48,480
everything i'm going to say is joint

18
00:00:46,239 --> 00:00:50,480
work with the rest of the ketchup team

19
00:00:48,480 --> 00:00:53,919
namely guido bertoni johann diamonds at

20
00:00:50,480 --> 00:00:56,160
offered michael peters and honey vance

21
00:00:53,920 --> 00:00:57,520
so just a bit of background on what we

22
00:00:56,160 --> 00:00:59,599
do

23
00:00:57,520 --> 00:01:01,199
so we are interested in

24
00:00:59,600 --> 00:01:03,600
permutation-based crypto

25
00:01:01,199 --> 00:01:04,319
so permutation-based crypto is something

26
00:01:03,600 --> 00:01:06,400
um

27
00:01:04,319 --> 00:01:07,600
a new kind of crypto in a sense that we

28
00:01:06,400 --> 00:01:09,840
instead of having

29
00:01:07,600 --> 00:01:11,360
a block cipher we use a keyless

30
00:01:09,840 --> 00:01:13,760
permutation

31
00:01:11,360 --> 00:01:15,200
um the kitchen the name ketchup kim

32
00:01:13,760 --> 00:01:17,200
comes from the designers

33
00:01:15,200 --> 00:01:19,040
originally from the designers of ketchup

34
00:01:17,200 --> 00:01:21,360
which was selected as chattry

35
00:01:19,040 --> 00:01:22,400
during the shuttle competition we

36
00:01:21,360 --> 00:01:24,960
designed some

37
00:01:22,400 --> 00:01:27,119
many stuff based on permutations so we

38
00:01:24,960 --> 00:01:29,679
didn't stop at hashing we also looked at

39
00:01:27,119 --> 00:01:30,799
encryption and authentication we

40
00:01:29,680 --> 00:01:34,159
developed some new

41
00:01:30,799 --> 00:01:37,119
constructions um one instance is

42
00:01:34,159 --> 00:01:38,400
a key duplex another one is farfalle

43
00:01:37,119 --> 00:01:40,079
these

44
00:01:38,400 --> 00:01:41,840
from from these you can build um

45
00:01:40,079 --> 00:01:42,079
encryption scheme authentication schemes

46
00:01:41,840 --> 00:01:45,200
or

47
00:01:42,079 --> 00:01:46,320
authenticated encryption schemes um and

48
00:01:45,200 --> 00:01:49,520
we develop of course we

49
00:01:46,320 --> 00:01:51,679
um design some some specific instances

50
00:01:49,520 --> 00:01:54,079
but yeah in this talk this it's not

51
00:01:51,680 --> 00:01:56,240
going to be about all these new schemes

52
00:01:54,079 --> 00:01:57,919
instead i would like to to talk about

53
00:01:56,240 --> 00:01:59,199
what i call incrementality so

54
00:01:57,920 --> 00:02:01,600
incrementality

55
00:01:59,200 --> 00:02:03,600
is the notion that um if you have some

56
00:02:01,600 --> 00:02:06,079
some kind of cryptographic primitive

57
00:02:03,600 --> 00:02:06,640
you have some input some output um you

58
00:02:06,079 --> 00:02:09,440
can

59
00:02:06,640 --> 00:02:09,919
from the input get some output and then

60
00:02:09,440 --> 00:02:12,079
you can

61
00:02:09,919 --> 00:02:13,200
take your input and you increase you you

62
00:02:12,080 --> 00:02:14,879
add some more

63
00:02:13,200 --> 00:02:17,040
more string to your input and you get

64
00:02:14,879 --> 00:02:18,799
another output then you add

65
00:02:17,040 --> 00:02:21,280
more string you have another output and

66
00:02:18,800 --> 00:02:24,000
so on you every time get some some

67
00:02:21,280 --> 00:02:26,959
output on everything that you have

68
00:02:24,000 --> 00:02:27,840
on constructing your inputs step by step

69
00:02:26,959 --> 00:02:29,599
the key thing

70
00:02:27,840 --> 00:02:30,959
about incrementality is that every time

71
00:02:29,599 --> 00:02:31,840
you do that you don't have to start all

72
00:02:30,959 --> 00:02:34,080
over again

73
00:02:31,840 --> 00:02:34,959
you only pay the price for the

74
00:02:34,080 --> 00:02:37,040
additional

75
00:02:34,959 --> 00:02:39,280
string that you're adding to your input

76
00:02:37,040 --> 00:02:42,319
that's what i mean with incrementality

77
00:02:39,280 --> 00:02:44,319
and we we're trying to to look around

78
00:02:42,319 --> 00:02:45,839
this notion and we think it's an

79
00:02:44,319 --> 00:02:48,399
ingredient that can help

80
00:02:45,840 --> 00:02:48,879
uh simplifying uh symmetric crypto so

81
00:02:48,400 --> 00:02:50,959
that's

82
00:02:48,879 --> 00:02:53,200
what we want to to do something that is

83
00:02:50,959 --> 00:02:54,640
simpler in in

84
00:02:53,200 --> 00:02:56,399
in terms of description in terms of

85
00:02:54,640 --> 00:02:58,958
implementation when it comes to

86
00:02:56,400 --> 00:03:00,959
authenticating encryption

87
00:02:58,959 --> 00:03:02,080
we recently developed something called a

88
00:03:00,959 --> 00:03:03,440
deck function

89
00:03:02,080 --> 00:03:05,120
so a deck function is not a new

90
00:03:03,440 --> 00:03:07,280
construction on top of all your

91
00:03:05,120 --> 00:03:08,239
other constructions that i mentioned

92
00:03:07,280 --> 00:03:10,879
it's more

93
00:03:08,239 --> 00:03:13,280
an interface something that aims at

94
00:03:10,879 --> 00:03:15,200
capturing the notion of incrementality

95
00:03:13,280 --> 00:03:16,319
and on top of this this interface we can

96
00:03:15,200 --> 00:03:19,119
build

97
00:03:16,319 --> 00:03:21,920
modes for authentication encryption and

98
00:03:19,120 --> 00:03:25,440
authenticating encryption

99
00:03:21,920 --> 00:03:28,879
okay so um in this presentation i will

100
00:03:25,440 --> 00:03:29,680
talk first about incrementality and for

101
00:03:28,879 --> 00:03:32,399
that i will take

102
00:03:29,680 --> 00:03:32,799
as an example the disco protocol and

103
00:03:32,400 --> 00:03:34,640
then

104
00:03:32,799 --> 00:03:37,040
i will talk about deck functions more

105
00:03:34,640 --> 00:03:40,238
specifically

106
00:03:37,040 --> 00:03:41,840
so why is incrementality useful and in

107
00:03:40,239 --> 00:03:45,280
in the sense that it can help us

108
00:03:41,840 --> 00:03:46,640
simplify things so the disco

109
00:03:45,280 --> 00:03:48,400
i will explain of course what the disco

110
00:03:46,640 --> 00:03:51,839
protocol is but to start

111
00:03:48,400 --> 00:03:54,400
um i need to go back to the basics

112
00:03:51,840 --> 00:03:56,319
and the first let's say incremental um

113
00:03:54,400 --> 00:03:57,760
construction that we defined was the

114
00:03:56,319 --> 00:03:59,439
duplex construction

115
00:03:57,760 --> 00:04:01,280
so the duplex if you you may know that

116
00:03:59,439 --> 00:04:03,120
the ketchup is uses the sponge

117
00:04:01,280 --> 00:04:04,879
construction the duplex construction

118
00:04:03,120 --> 00:04:06,319
is just cryptographically equivalent to

119
00:04:04,879 --> 00:04:08,720
the sponge construction

120
00:04:06,319 --> 00:04:10,720
the only difference is the interface the

121
00:04:08,720 --> 00:04:13,200
interface allows us to have

122
00:04:10,720 --> 00:04:14,799
uh input one input block one put block

123
00:04:13,200 --> 00:04:18,159
one input lock one of the lock

124
00:04:14,799 --> 00:04:19,120
every time um so it uses a permutation

125
00:04:18,160 --> 00:04:21,680
the permutation

126
00:04:19,120 --> 00:04:22,720
is f here you have some block of input

127
00:04:21,680 --> 00:04:24,160
and you can get some log

128
00:04:22,720 --> 00:04:26,080
of output then you have a second block

129
00:04:24,160 --> 00:04:26,880
of input permutation log of output and

130
00:04:26,080 --> 00:04:28,800
so on

131
00:04:26,880 --> 00:04:30,719
and if you look at maybe this this block

132
00:04:28,800 --> 00:04:31,600
of output this block of output is going

133
00:04:30,720 --> 00:04:34,320
to depend on

134
00:04:31,600 --> 00:04:36,080
all the past input blocks so we have

135
00:04:34,320 --> 00:04:38,080
this notion of incrementality

136
00:04:36,080 --> 00:04:39,680
but as such the duplex is not really

137
00:04:38,080 --> 00:04:41,440
useful we need to have some

138
00:04:39,680 --> 00:04:44,240
layer on top of it to build something

139
00:04:41,440 --> 00:04:47,280
concrete and useful in crypto

140
00:04:44,240 --> 00:04:49,600
um one thing that we can do

141
00:04:47,280 --> 00:04:51,359
is to use the strobe protocol so this

142
00:04:49,600 --> 00:04:52,160
rock protocol was designed by mike

143
00:04:51,360 --> 00:04:53,600
hemberg

144
00:04:52,160 --> 00:04:55,440
and it was presented at real world

145
00:04:53,600 --> 00:04:58,560
crypto three years ago

146
00:04:55,440 --> 00:05:00,320
and so it's just a layer of duplex but

147
00:04:58,560 --> 00:05:01,280
it provides a really nice and simple

148
00:05:00,320 --> 00:05:03,039
syntax on

149
00:05:01,280 --> 00:05:05,119
um that you can use for instance to

150
00:05:03,039 --> 00:05:08,320
build secure channels or

151
00:05:05,120 --> 00:05:10,560
to hash the transcript of a protocol

152
00:05:08,320 --> 00:05:12,560
and it's simple enough that it allows

153
00:05:10,560 --> 00:05:13,039
for a really compact implementation so

154
00:05:12,560 --> 00:05:15,360
in

155
00:05:13,039 --> 00:05:17,360
um in terms of lines of code it's fairly

156
00:05:15,360 --> 00:05:19,199
compact

157
00:05:17,360 --> 00:05:21,199
uh concretely what can you do with the

158
00:05:19,199 --> 00:05:24,479
um stroke protocol

159
00:05:21,199 --> 00:05:25,759
you can have some

160
00:05:24,479 --> 00:05:28,080
these are the functions you can have

161
00:05:25,759 --> 00:05:28,479
some um associate data that is some data

162
00:05:28,080 --> 00:05:30,400
that

163
00:05:28,479 --> 00:05:32,000
does not need to be encrypted but you

164
00:05:30,400 --> 00:05:34,080
need to authenticate

165
00:05:32,000 --> 00:05:35,440
uh you can input a secret key actually

166
00:05:34,080 --> 00:05:36,639
you would start with inputting the

167
00:05:35,440 --> 00:05:40,479
secret key

168
00:05:36,639 --> 00:05:42,639
uh you can get some output prf

169
00:05:40,479 --> 00:05:44,479
and then there is this notion of client

170
00:05:42,639 --> 00:05:45,680
server communication you can send data

171
00:05:44,479 --> 00:05:48,719
in the clear

172
00:05:45,680 --> 00:05:51,360
but besides sending the data the data

173
00:05:48,720 --> 00:05:52,000
the state of strobe will be affected by

174
00:05:51,360 --> 00:05:54,000
by the data

175
00:05:52,000 --> 00:05:56,080
so it will authenticate if you when you

176
00:05:54,000 --> 00:05:57,840
authenticate it will um also

177
00:05:56,080 --> 00:05:59,919
authenticate the clear text data

178
00:05:57,840 --> 00:06:01,599
receive clear text is the equivalent but

179
00:05:59,919 --> 00:06:03,440
from server to client

180
00:06:01,600 --> 00:06:04,720
send encrypted i'm going to send some

181
00:06:03,440 --> 00:06:08,319
data and

182
00:06:04,720 --> 00:06:09,840
but in an encrypted form and my state is

183
00:06:08,319 --> 00:06:11,759
going to depend on it

184
00:06:09,840 --> 00:06:13,359
receive is vice versa i'm getting some

185
00:06:11,759 --> 00:06:14,720
ciphertext and i want to get back to

186
00:06:13,360 --> 00:06:17,919
plain text and i want

187
00:06:14,720 --> 00:06:20,240
my state to depend on it send mac

188
00:06:17,919 --> 00:06:22,240
i need to authenticate myself to server

189
00:06:20,240 --> 00:06:24,000
i send a message authentication code

190
00:06:22,240 --> 00:06:25,440
depending on everything that that was

191
00:06:24,000 --> 00:06:28,160
done so far uh

192
00:06:25,440 --> 00:06:29,520
receive mac i i get a mac from from the

193
00:06:28,160 --> 00:06:33,759
server i need to check that

194
00:06:29,520 --> 00:06:36,719
it fits my my key and my

195
00:06:33,759 --> 00:06:37,759
context and then finally ratchet is

196
00:06:36,720 --> 00:06:40,000
something that

197
00:06:37,759 --> 00:06:40,000
um

198
00:06:41,120 --> 00:06:44,880
ensures forward secrecy so it erases

199
00:06:43,600 --> 00:06:46,240
part of the state in a way that you

200
00:06:44,880 --> 00:06:50,000
cannot go back

201
00:06:46,240 --> 00:06:52,960
um in case the state gets compromised

202
00:06:50,000 --> 00:06:54,319
um here is a small example of a protocol

203
00:06:52,960 --> 00:06:56,400
on top of

204
00:06:54,319 --> 00:06:57,759
a strobe so it's a really simple

205
00:06:56,400 --> 00:06:58,880
protocol in the sense that we have a

206
00:06:57,759 --> 00:07:01,759
client server

207
00:06:58,880 --> 00:07:02,159
the client is going to request a file we

208
00:07:01,759 --> 00:07:03,919
want

209
00:07:02,160 --> 00:07:06,000
this request to be encrypted so the name

210
00:07:03,919 --> 00:07:08,080
of the file is going to be encrypted

211
00:07:06,000 --> 00:07:10,000
and we want the server to send back the

212
00:07:08,080 --> 00:07:13,198
file in an encrypted form

213
00:07:10,000 --> 00:07:15,360
so i start by putting my

214
00:07:13,199 --> 00:07:17,280
secret key here it's either a pre-shared

215
00:07:15,360 --> 00:07:20,160
key or a key that comes from

216
00:07:17,280 --> 00:07:21,679
a public key operation like helman and

217
00:07:20,160 --> 00:07:25,360
then i have some context

218
00:07:21,680 --> 00:07:27,199
x that is going to summarize on what the

219
00:07:25,360 --> 00:07:30,880
state depends

220
00:07:27,199 --> 00:07:33,280
um and i start with an empty x

221
00:07:30,880 --> 00:07:33,919
so the next operation is a d so i'm

222
00:07:33,280 --> 00:07:36,799
going to

223
00:07:33,919 --> 00:07:37,440
add to my context some associate data in

224
00:07:36,800 --> 00:07:39,599
this case

225
00:07:37,440 --> 00:07:40,800
um the string nonce and the sequence

226
00:07:39,599 --> 00:07:42,159
counter i

227
00:07:40,800 --> 00:07:44,080
that is going to be incremented every

228
00:07:42,160 --> 00:07:46,800
time i use it

229
00:07:44,080 --> 00:07:47,359
then the string oath data followed by

230
00:07:46,800 --> 00:07:49,039
the

231
00:07:47,360 --> 00:07:50,960
ip addresses of the client and the

232
00:07:49,039 --> 00:07:53,440
server

233
00:07:50,960 --> 00:07:54,799
so when i write that x is gets

234
00:07:53,440 --> 00:07:56,160
incremented with all these strings it

235
00:07:54,800 --> 00:07:57,520
doesn't mean we have a buffer with all

236
00:07:56,160 --> 00:07:58,879
these strings it means that these

237
00:07:57,520 --> 00:08:01,198
strings are absorbed

238
00:07:58,879 --> 00:08:02,639
and the state of the cryptographic

239
00:08:01,199 --> 00:08:05,680
object the duplex object

240
00:08:02,639 --> 00:08:08,000
underlying strobe somehow

241
00:08:05,680 --> 00:08:10,080
contains a hash of everything that is in

242
00:08:08,000 --> 00:08:12,639
x

243
00:08:10,080 --> 00:08:14,080
then i want to send my request get file

244
00:08:12,639 --> 00:08:16,160
file is being a file name

245
00:08:14,080 --> 00:08:17,680
i just encrypt this string get file

246
00:08:16,160 --> 00:08:19,520
under the key k

247
00:08:17,680 --> 00:08:21,759
and that's my software text that i send

248
00:08:19,520 --> 00:08:23,520
to the server and at the same time i

249
00:08:21,759 --> 00:08:27,199
update my context use

250
00:08:23,520 --> 00:08:28,719
with this get file string then i send a

251
00:08:27,199 --> 00:08:31,280
message authentication code

252
00:08:28,720 --> 00:08:33,440
that depends on the entire context so

253
00:08:31,280 --> 00:08:33,439
from

254
00:08:33,599 --> 00:08:37,599
the entire transcript of the protocol so

255
00:08:35,839 --> 00:08:40,159
far

256
00:08:37,599 --> 00:08:41,200
then the server sends me back the file

257
00:08:40,159 --> 00:08:43,760
in ciphertext

258
00:08:41,200 --> 00:08:45,040
i'm going to decrypt it and get the

259
00:08:43,760 --> 00:08:48,160
plain text so the

260
00:08:45,040 --> 00:08:51,199
file in the clear i update my context

261
00:08:48,160 --> 00:08:52,880
accordingly and then i check the mac the

262
00:08:51,200 --> 00:08:55,040
mac contains everything

263
00:08:52,880 --> 00:08:56,720
and in particular it contains the plain

264
00:08:55,040 --> 00:08:59,120
text that i just received so i'm

265
00:08:56,720 --> 00:09:00,320
i'm now sure that my file was not

266
00:08:59,120 --> 00:09:03,120
tampered with

267
00:09:00,320 --> 00:09:04,320
on the way from the server back to me

268
00:09:03,120 --> 00:09:06,560
okay so

269
00:09:04,320 --> 00:09:08,800
um in the end it's fairly nice syntax

270
00:09:06,560 --> 00:09:11,518
you can build many things

271
00:09:08,800 --> 00:09:11,519
of this form

272
00:09:11,839 --> 00:09:15,920
then so strobe is only about the

273
00:09:14,480 --> 00:09:17,440
symmetric key part

274
00:09:15,920 --> 00:09:18,880
what about the public keyboard there is

275
00:09:17,440 --> 00:09:20,240
another protocol called the noise

276
00:09:18,880 --> 00:09:22,080
protocol framework

277
00:09:20,240 --> 00:09:24,320
defined by trevor perrin and presented

278
00:09:22,080 --> 00:09:26,240
uphill crypto two years ago

279
00:09:24,320 --> 00:09:27,600
it's a fairly popular protocol in the

280
00:09:26,240 --> 00:09:29,440
sense that it's used for instance in

281
00:09:27,600 --> 00:09:32,399
whatsapp and wireguard

282
00:09:29,440 --> 00:09:32,880
um it does two things first it handles

283
00:09:32,399 --> 00:09:36,320
the

284
00:09:32,880 --> 00:09:37,040
publicy handshake so it does typically

285
00:09:36,320 --> 00:09:40,640
crypt um

286
00:09:37,040 --> 00:09:42,880
elliptic curve operations to establish a

287
00:09:40,640 --> 00:09:44,160
common secret key and then it also

288
00:09:42,880 --> 00:09:46,480
handles the

289
00:09:44,160 --> 00:09:49,040
secret key encryption authentication

290
00:09:46,480 --> 00:09:50,880
aspects

291
00:09:49,040 --> 00:09:52,640
in this diagram so you can see what's

292
00:09:50,880 --> 00:09:55,680
happening inside noise

293
00:09:52,640 --> 00:09:57,360
um so i'm focusing on everything

294
00:09:55,680 --> 00:09:59,760
i'm not going to detail this figure i'm

295
00:09:57,360 --> 00:10:02,160
just showing it to um

296
00:09:59,760 --> 00:10:04,160
point out that it's fairly complicated

297
00:10:02,160 --> 00:10:05,839
when it comes to describing what happens

298
00:10:04,160 --> 00:10:07,519
in in the symmetric part of

299
00:10:05,839 --> 00:10:09,600
of noise so you have different

300
00:10:07,519 --> 00:10:12,480
primitives you have hash functions

301
00:10:09,600 --> 00:10:14,240
key derivation functions cipher so

302
00:10:12,480 --> 00:10:17,040
authenticate encryption and all that

303
00:10:14,240 --> 00:10:20,800
gets mixed in a fairly complicated way

304
00:10:17,040 --> 00:10:23,199
um so the idea was the idea of disco so

305
00:10:20,800 --> 00:10:25,199
this code was presented by david wong

306
00:10:23,200 --> 00:10:26,240
at black hat three years ago and the

307
00:10:25,200 --> 00:10:28,720
idea is just to

308
00:10:26,240 --> 00:10:29,920
take notes but replace the symmetric

309
00:10:28,720 --> 00:10:32,640
part of noise with

310
00:10:29,920 --> 00:10:33,680
something based on strobe and the idea

311
00:10:32,640 --> 00:10:36,800
is to make things

312
00:10:33,680 --> 00:10:37,359
simpler and if you take the previous

313
00:10:36,800 --> 00:10:40,319
figure

314
00:10:37,360 --> 00:10:41,440
and now you look at disco instead of

315
00:10:40,320 --> 00:10:43,920
noise itself

316
00:10:41,440 --> 00:10:45,120
then you can see that the symmetric path

317
00:10:43,920 --> 00:10:48,000
is much clearer it's just

318
00:10:45,120 --> 00:10:49,200
one call to strobe every time the entire

319
00:10:48,000 --> 00:10:51,279
state is maintained by

320
00:10:49,200 --> 00:10:52,399
by strobe itself there is no need to

321
00:10:51,279 --> 00:10:55,600
have different

322
00:10:52,399 --> 00:10:57,519
things running in in parallel somehow

323
00:10:55,600 --> 00:10:59,440
you may say okay but maybe now the

324
00:10:57,519 --> 00:11:02,000
complexity is hidden behind these

325
00:10:59,440 --> 00:11:02,560
these uh function calls well if you look

326
00:11:02,000 --> 00:11:04,399
inside

327
00:11:02,560 --> 00:11:07,040
these functions calls it it really

328
00:11:04,399 --> 00:11:10,720
relies on the duplex construction

329
00:11:07,040 --> 00:11:13,199
which as operations only need to

330
00:11:10,720 --> 00:11:14,880
soar some strings into the state and

331
00:11:13,200 --> 00:11:15,680
apply the permutation when it's needed

332
00:11:14,880 --> 00:11:17,439
so

333
00:11:15,680 --> 00:11:20,079
this the kind of operations that lie

334
00:11:17,440 --> 00:11:22,640
behind these functions calls are

335
00:11:20,079 --> 00:11:24,000
really simple and that makes the

336
00:11:22,640 --> 00:11:28,720
implementation of

337
00:11:24,000 --> 00:11:31,200
disco really really nice very simple

338
00:11:28,720 --> 00:11:31,920
here are some figures provided by davin

339
00:11:31,200 --> 00:11:35,440
wong

340
00:11:31,920 --> 00:11:38,079
about the size of disco written in c

341
00:11:35,440 --> 00:11:40,160
c sharp and go and you can see that this

342
00:11:38,079 --> 00:11:42,800
school fits in a few thousand lines

343
00:11:40,160 --> 00:11:44,000
if you compare that to openssl it's of

344
00:11:42,800 --> 00:11:46,800
course much

345
00:11:44,000 --> 00:11:48,480
smaller um i don't think these figures

346
00:11:46,800 --> 00:11:49,359
are really fair because openssl does a

347
00:11:48,480 --> 00:11:50,959
lot of

348
00:11:49,360 --> 00:11:52,480
more things and they have many many

349
00:11:50,959 --> 00:11:54,638
options um

350
00:11:52,480 --> 00:11:57,120
to look at but still i mean my point is

351
00:11:54,639 --> 00:12:00,720
that this cocaine

352
00:11:57,120 --> 00:12:03,040
is really simple and one aspect

353
00:12:00,720 --> 00:12:05,279
of it is the use of the duplex object

354
00:12:03,040 --> 00:12:07,920
and its incrementality to allow for this

355
00:12:05,279 --> 00:12:07,920
simplicity

356
00:12:08,240 --> 00:12:14,800
okay okay so starting from

357
00:12:11,760 --> 00:12:17,360
incrementality we decided yeah let's

358
00:12:14,800 --> 00:12:20,000
let's take a step back and look at how

359
00:12:17,360 --> 00:12:22,320
can we define incrementality how can we

360
00:12:20,000 --> 00:12:24,079
maybe refine this notion and and try to

361
00:12:22,320 --> 00:12:26,639
define things

362
00:12:24,079 --> 00:12:27,680
on top of a new object a new interface

363
00:12:26,639 --> 00:12:31,120
that we call

364
00:12:27,680 --> 00:12:32,719
deck function so what is a deck function

365
00:12:31,120 --> 00:12:34,480
i'm sorry that's the most technical

366
00:12:32,720 --> 00:12:36,720
slide of representation

367
00:12:34,480 --> 00:12:38,160
it has some notation but basically a

368
00:12:36,720 --> 00:12:40,320
deck function

369
00:12:38,160 --> 00:12:41,760
is absolutely random function that takes

370
00:12:40,320 --> 00:12:44,320
as input

371
00:12:41,760 --> 00:12:46,079
a sequence of strings so the input is

372
00:12:44,320 --> 00:12:47,440
either one string of two strings or

373
00:12:46,079 --> 00:12:49,199
three strings

374
00:12:47,440 --> 00:12:51,360
and it's a deterministic function so it

375
00:12:49,200 --> 00:12:53,360
takes a secret key and the sequence of

376
00:12:51,360 --> 00:12:56,399
strings and it's going to produce

377
00:12:53,360 --> 00:12:58,000
as many output bits as you wish these

378
00:12:56,399 --> 00:12:59,120
output bits depend on secret key they

379
00:12:58,000 --> 00:13:00,959
depend on the input

380
00:12:59,120 --> 00:13:02,240
if you change just a single bit of your

381
00:13:00,959 --> 00:13:05,359
input you get some

382
00:13:02,240 --> 00:13:06,959
unrelated outputs it's deterministic so

383
00:13:05,360 --> 00:13:08,639
if you know the secret key and of course

384
00:13:06,959 --> 00:13:10,079
you have the input you can compute and

385
00:13:08,639 --> 00:13:12,639
if you compute it twice you get the same

386
00:13:10,079 --> 00:13:12,959
result i'd say the random in the sense

387
00:13:12,639 --> 00:13:14,639
that

388
00:13:12,959 --> 00:13:16,638
from the point of view of another

389
00:13:14,639 --> 00:13:18,959
version who doesn't know the secret key

390
00:13:16,639 --> 00:13:21,200
these output bits they just look like

391
00:13:18,959 --> 00:13:22,638
unbiased random bits they just

392
00:13:21,200 --> 00:13:24,880
they cannot and as also we cannot

393
00:13:22,639 --> 00:13:27,839
predict them for a new

394
00:13:24,880 --> 00:13:30,079
a new input string so i said it's it

395
00:13:27,839 --> 00:13:30,079
takes

396
00:13:31,279 --> 00:13:34,480
it outputs as many bits as you want of

397
00:13:33,440 --> 00:13:36,720
course you don't

398
00:13:34,480 --> 00:13:37,760
need an infinite number of bits and this

399
00:13:36,720 --> 00:13:40,160
notation

400
00:13:37,760 --> 00:13:41,519
is i'm not going to detail the notation

401
00:13:40,160 --> 00:13:46,480
but it just says that

402
00:13:41,519 --> 00:13:46,480
i can take n bits starting from offset q

403
00:13:46,560 --> 00:13:50,160
okay that's a deck function but that's

404
00:13:49,839 --> 00:13:52,399
not

405
00:13:50,160 --> 00:13:53,199
all of it um another requirement of a

406
00:13:52,399 --> 00:13:55,839
deck function

407
00:13:53,199 --> 00:13:57,760
is to allow for this incrementality

408
00:13:55,839 --> 00:13:59,199
maybe i forgot to mention that dec

409
00:13:57,760 --> 00:14:00,880
stands for doubly extendable

410
00:13:59,199 --> 00:14:02,319
cryptographic key function so doubly

411
00:14:00,880 --> 00:14:04,240
extendable is really the

412
00:14:02,320 --> 00:14:06,480
feature i'm now describing which is the

413
00:14:04,240 --> 00:14:08,160
incrementality i want to have extendable

414
00:14:06,480 --> 00:14:10,240
input and extendable output

415
00:14:08,160 --> 00:14:11,600
by extendable input i mean let's say you

416
00:14:10,240 --> 00:14:14,720
first compute

417
00:14:11,600 --> 00:14:17,839
fx over some string x and then

418
00:14:14,720 --> 00:14:18,880
later on you want to compute fx over y

419
00:14:17,839 --> 00:14:21,920
after x

420
00:14:18,880 --> 00:14:22,320
but you already computed f of x you have

421
00:14:21,920 --> 00:14:25,279
maybe

422
00:14:22,320 --> 00:14:26,240
kept some state then if you do that the

423
00:14:25,279 --> 00:14:29,279
computation of

424
00:14:26,240 --> 00:14:30,959
f y after x does not cost you

425
00:14:29,279 --> 00:14:33,279
because the cost only depends on the

426
00:14:30,959 --> 00:14:34,719
length of y not not the length of x you

427
00:14:33,279 --> 00:14:35,680
don't need to start all over again you

428
00:14:34,720 --> 00:14:38,639
don't need to pay for

429
00:14:35,680 --> 00:14:39,680
for evaluating f of y after x if you

430
00:14:38,639 --> 00:14:42,839
already evaluated

431
00:14:39,680 --> 00:14:44,079
f of y so that's incrementality on the

432
00:14:42,839 --> 00:14:47,360
input

433
00:14:44,079 --> 00:14:48,880
on the output it's it's um also very

434
00:14:47,360 --> 00:14:51,440
simple i mean you can take

435
00:14:48,880 --> 00:14:53,279
some some bits of output and if you need

436
00:14:51,440 --> 00:14:55,279
more you just pay for these extra bits

437
00:14:53,279 --> 00:14:58,639
you don't need to stop all over again

438
00:14:55,279 --> 00:14:59,760
okay so that's the double um the doubly

439
00:14:58,639 --> 00:15:03,199
extendable feature of

440
00:14:59,760 --> 00:15:04,720
optic function okay so now

441
00:15:03,199 --> 00:15:06,319
assume that we have some some deck

442
00:15:04,720 --> 00:15:08,160
function i'm going to

443
00:15:06,320 --> 00:15:10,240
of course describe how we can build one

444
00:15:08,160 --> 00:15:11,839
concretely but assume we have one

445
00:15:10,240 --> 00:15:13,440
what can we do concretely with the deck

446
00:15:11,839 --> 00:15:15,120
function um

447
00:15:13,440 --> 00:15:16,720
first application very simple

448
00:15:15,120 --> 00:15:18,959
application i want to just to

449
00:15:16,720 --> 00:15:20,720
encrypt some data so i have my deck

450
00:15:18,959 --> 00:15:23,680
function i input the secret key and i

451
00:15:20,720 --> 00:15:25,839
input some sequence number a nonce and

452
00:15:23,680 --> 00:15:27,760
then the output i use it as a key stream

453
00:15:25,839 --> 00:15:29,519
i saw every bit of my plain text with

454
00:15:27,760 --> 00:15:31,439
the corresponding bit of the key stream

455
00:15:29,519 --> 00:15:34,079
and the result is my ciphertext

456
00:15:31,440 --> 00:15:35,759
the decrypt i just do the same i saw the

457
00:15:34,079 --> 00:15:38,959
key stream to the cipher text

458
00:15:35,759 --> 00:15:40,560
and if you saw the same thing twice you

459
00:15:38,959 --> 00:15:42,959
they cancel each other and you get back

460
00:15:40,560 --> 00:15:44,880
the plain text so encryption stream

461
00:15:42,959 --> 00:15:47,839
encryption very simple

462
00:15:44,880 --> 00:15:49,120
application to do authentication you

463
00:15:47,839 --> 00:15:51,360
input your message

464
00:15:49,120 --> 00:15:52,480
to the deck function the output is your

465
00:15:51,360 --> 00:15:56,399
authentication tag

466
00:15:52,480 --> 00:15:59,759
that you attach to your message

467
00:15:56,399 --> 00:16:00,880
okay um now about incrementality so we

468
00:15:59,759 --> 00:16:02,880
can have

469
00:16:00,880 --> 00:16:04,800
this this deck function the output is

470
00:16:02,880 --> 00:16:06,959
going to depend on everything that was

471
00:16:04,800 --> 00:16:08,079
received so far so if you maintain a

472
00:16:06,959 --> 00:16:09,839
deck function

473
00:16:08,079 --> 00:16:11,199
and you encrypt different messages that

474
00:16:09,839 --> 00:16:13,120
follow each other

475
00:16:11,199 --> 00:16:14,479
then you can have something which we

476
00:16:13,120 --> 00:16:17,600
call a session and

477
00:16:14,480 --> 00:16:18,399
by session i mean that if you exchange

478
00:16:17,600 --> 00:16:20,639
some messages

479
00:16:18,399 --> 00:16:22,480
and let's say you extreme three messages

480
00:16:20,639 --> 00:16:24,880
the tag on the third message

481
00:16:22,480 --> 00:16:25,839
the third message to the authentication

482
00:16:24,880 --> 00:16:28,240
of the third message

483
00:16:25,839 --> 00:16:29,040
is not just locally authenticating this

484
00:16:28,240 --> 00:16:30,480
third message

485
00:16:29,040 --> 00:16:32,240
but really the sequence of all the

486
00:16:30,480 --> 00:16:33,839
messages received so far

487
00:16:32,240 --> 00:16:35,600
so maybe this last message is just a

488
00:16:33,839 --> 00:16:38,079
confirmation it's just a big

489
00:16:35,600 --> 00:16:40,079
okay with the tag you don't want the

490
00:16:38,079 --> 00:16:41,920
adversary to be able to reuse

491
00:16:40,079 --> 00:16:43,758
this okay in different contexts

492
00:16:41,920 --> 00:16:45,519
otherwise you can the adversary could

493
00:16:43,759 --> 00:16:46,560
send an okay on something you don't want

494
00:16:45,519 --> 00:16:48,240
maybe

495
00:16:46,560 --> 00:16:50,719
but in this case because attack depends

496
00:16:48,240 --> 00:16:52,320
on all the past is okay it's clearly

497
00:16:50,720 --> 00:16:54,240
referring to the context which is the

498
00:16:52,320 --> 00:16:55,680
sequence of previous messages

499
00:16:54,240 --> 00:16:57,440
so i think it's really convenient and

500
00:16:55,680 --> 00:16:59,519
comes naturally with the notion of

501
00:16:57,440 --> 00:17:03,360
incrementality that

502
00:16:59,519 --> 00:17:06,640
is buried in deck functions

503
00:17:03,360 --> 00:17:07,120
okay um yeah i'm going to go quickly

504
00:17:06,640 --> 00:17:10,240
over

505
00:17:07,119 --> 00:17:11,039
this slide so we defined a mode called

506
00:17:10,240 --> 00:17:14,640
dexaine

507
00:17:11,039 --> 00:17:17,839
which does this session based encryption

508
00:17:14,640 --> 00:17:18,240
using a nonce and it's really simple so

509
00:17:17,839 --> 00:17:20,240
you

510
00:17:18,240 --> 00:17:22,000
initialize it with some some nouns and

511
00:17:20,240 --> 00:17:23,520
you can get a tag over the

512
00:17:22,000 --> 00:17:24,959
initialization

513
00:17:23,520 --> 00:17:27,199
let's say you have a first message

514
00:17:24,959 --> 00:17:29,200
composed of metadata something

515
00:17:27,199 --> 00:17:30,880
you want to authenticate but not encrypt

516
00:17:29,200 --> 00:17:32,960
and plain text

517
00:17:30,880 --> 00:17:34,160
you use the deck function to produce

518
00:17:32,960 --> 00:17:37,520
some some

519
00:17:34,160 --> 00:17:40,080
key stream you encrypt it has done

520
00:17:37,520 --> 00:17:41,360
two or three slides before and the tag

521
00:17:40,080 --> 00:17:43,760
includes

522
00:17:41,360 --> 00:17:45,600
everything including the metadata and

523
00:17:43,760 --> 00:17:47,840
the site of text

524
00:17:45,600 --> 00:17:49,120
now because we already processed the

525
00:17:47,840 --> 00:17:50,879
nonce this node

526
00:17:49,120 --> 00:17:53,199
is now grayed on my slide it means we

527
00:17:50,880 --> 00:17:57,280
don't need to pay for it we just pay for

528
00:17:53,200 --> 00:17:57,919
this side to the metadata and type of

529
00:17:57,280 --> 00:18:00,960
text

530
00:17:57,919 --> 00:18:03,200
and if i have if i have a second message

531
00:18:00,960 --> 00:18:04,960
then i need to pay the price only for

532
00:18:03,200 --> 00:18:08,000
this second message

533
00:18:04,960 --> 00:18:09,679
okay all right so dexen

534
00:18:08,000 --> 00:18:11,120
needs announced it means that you need

535
00:18:09,679 --> 00:18:12,720
to have a sequence number and

536
00:18:11,120 --> 00:18:15,360
maybe it's a packet number but if you

537
00:18:12,720 --> 00:18:16,320
repeat that value then then you get into

538
00:18:15,360 --> 00:18:18,479
trouble

539
00:18:16,320 --> 00:18:19,360
so there are other deck based modes that

540
00:18:18,480 --> 00:18:21,840
we we define

541
00:18:19,360 --> 00:18:23,918
one is called sensei and the idea is to

542
00:18:21,840 --> 00:18:25,840
replace the sequence number by some

543
00:18:23,919 --> 00:18:27,440
synthetic synthetic sequence number

544
00:18:25,840 --> 00:18:28,879
based only on the plain text

545
00:18:27,440 --> 00:18:31,600
so you don't need to really maintain

546
00:18:28,880 --> 00:18:34,080
this this sequence number

547
00:18:31,600 --> 00:18:35,199
and the other one is dec wbc white block

548
00:18:34,080 --> 00:18:36,960
cipher

549
00:18:35,200 --> 00:18:39,440
the idea is to achieve authenticate

550
00:18:36,960 --> 00:18:39,840
encryption with minimal expansion so if

551
00:18:39,440 --> 00:18:41,520
you have

552
00:18:39,840 --> 00:18:43,439
plaintext that already contains some

553
00:18:41,520 --> 00:18:45,360
redundancy you can just re

554
00:18:43,440 --> 00:18:47,600
base yourself on this redundancy to

555
00:18:45,360 --> 00:18:48,959
ensure authenticity and maybe you want

556
00:18:47,600 --> 00:18:50,320
to encrypt something

557
00:18:48,960 --> 00:18:52,480
into something else without any

558
00:18:50,320 --> 00:18:55,039
expansion because uh of course

559
00:18:52,480 --> 00:18:56,160
in dexa index like sensei you have this

560
00:18:55,039 --> 00:18:57,919
extra tag

561
00:18:56,160 --> 00:18:59,440
that increases the size of your cycle so

562
00:18:57,919 --> 00:19:00,480
you have ciphertext and the tag that you

563
00:18:59,440 --> 00:19:03,600
need to transmit so we have

564
00:19:00,480 --> 00:19:05,280
some expansion with wbc you can manage

565
00:19:03,600 --> 00:19:07,039
if you have enough redundancy you can

566
00:19:05,280 --> 00:19:08,840
just have your ciphertext

567
00:19:07,039 --> 00:19:10,160
whose length is equal to the plaintext

568
00:19:08,840 --> 00:19:13,918
fullstar

569
00:19:10,160 --> 00:19:17,600
so that's really a nice feature

570
00:19:13,919 --> 00:19:21,280
yeah then a few minutes about how

571
00:19:17,600 --> 00:19:24,080
we can build an efficient deck function

572
00:19:21,280 --> 00:19:26,320
so recently we developed a new

573
00:19:24,080 --> 00:19:28,799
construction called farfalle

574
00:19:26,320 --> 00:19:29,439
the name farfalle comes from yeah maybe

575
00:19:28,799 --> 00:19:32,799
it's ship

576
00:19:29,440 --> 00:19:34,400
i don't know so again i'm not going to

577
00:19:32,799 --> 00:19:35,440
detail everything that's happening

578
00:19:34,400 --> 00:19:38,799
inside so it

579
00:19:35,440 --> 00:19:41,120
takes a secret key and some input blocks

580
00:19:38,799 --> 00:19:43,200
but the key thing to look at on this

581
00:19:41,120 --> 00:19:45,439
figure is that the permutation f that is

582
00:19:43,200 --> 00:19:47,280
being evaluated in this reconstruction

583
00:19:45,440 --> 00:19:49,120
they get all evaluated they can be

584
00:19:47,280 --> 00:19:49,440
evaluated at the same time because they

585
00:19:49,120 --> 00:19:51,678
are

586
00:19:49,440 --> 00:19:53,520
they can run it in parallel so you can

587
00:19:51,679 --> 00:19:54,799
parallelize your implementation and

588
00:19:53,520 --> 00:19:56,320
maybe you can plug in

589
00:19:54,799 --> 00:19:57,918
a vector implementation of this

590
00:19:56,320 --> 00:20:00,559
permutation you can compute

591
00:19:57,919 --> 00:20:02,400
two permutations at once four eight

592
00:20:00,559 --> 00:20:04,840
depending on the size of your

593
00:20:02,400 --> 00:20:06,000
vector uh s imd instruction vector

594
00:20:04,840 --> 00:20:08,480
instructions

595
00:20:06,000 --> 00:20:10,400
so it can really speed up things and the

596
00:20:08,480 --> 00:20:12,159
same goes for the output all these f's

597
00:20:10,400 --> 00:20:13,840
all these permutations can be computed

598
00:20:12,159 --> 00:20:16,880
at the same time

599
00:20:13,840 --> 00:20:18,879
so basically we define two instances

600
00:20:16,880 --> 00:20:20,240
of ciphers based on farfalle the first

601
00:20:18,880 --> 00:20:22,159
one is called kravate

602
00:20:20,240 --> 00:20:23,679
and kavate uses a ketchup permutation

603
00:20:22,159 --> 00:20:26,799
reduced to six rounds so that's

604
00:20:23,679 --> 00:20:29,600
one f we

605
00:20:26,799 --> 00:20:30,960
claim that it has a security of 128 bits

606
00:20:29,600 --> 00:20:33,600
and we claim that it also

607
00:20:30,960 --> 00:20:34,720
includes adversaries who would have

608
00:20:33,600 --> 00:20:38,320
access to a quantum

609
00:20:34,720 --> 00:20:38,960
computer so cavaday is fairly fast the

610
00:20:38,320 --> 00:20:41,678
only

611
00:20:38,960 --> 00:20:42,400
disadvantage is a big block size of 200

612
00:20:41,679 --> 00:20:45,280
bytes

613
00:20:42,400 --> 00:20:46,799
so we defined another permutation that

614
00:20:45,280 --> 00:20:49,760
was done recently

615
00:20:46,799 --> 00:20:52,158
um called zudu that's a 384 bit

616
00:20:49,760 --> 00:20:54,879
permutation so 48 bytes

617
00:20:52,159 --> 00:20:56,880
and we defined zoof which is farfalle

618
00:20:54,880 --> 00:20:58,559
using zodo with six rounds

619
00:20:56,880 --> 00:21:00,320
there again we claim a security of at

620
00:20:58,559 --> 00:21:02,720
least 128 bits

621
00:21:00,320 --> 00:21:03,760
this post quantum claim was reduced a

622
00:21:02,720 --> 00:21:06,400
little bit because

623
00:21:03,760 --> 00:21:07,200
the permutation is smaller and that's

624
00:21:06,400 --> 00:21:10,320
just

625
00:21:07,200 --> 00:21:14,240
a consequence of this of this size

626
00:21:10,320 --> 00:21:16,879
um so performance figures

627
00:21:14,240 --> 00:21:18,240
so that's cavate on a skylake processor

628
00:21:16,880 --> 00:21:21,600
so skylig processor

629
00:21:18,240 --> 00:21:24,640
is a fairly common processor nowadays

630
00:21:21,600 --> 00:21:29,199
it has um avx2 instructions

631
00:21:24,640 --> 00:21:32,320
vx2 are 256 bit simd instructions

632
00:21:29,200 --> 00:21:34,960
and using that we can implement cavate

633
00:21:32,320 --> 00:21:36,080
um with a speed that is slightly so it's

634
00:21:34,960 --> 00:21:39,440
slightly faster

635
00:21:36,080 --> 00:21:41,439
than aes encounter mode on that platform

636
00:21:39,440 --> 00:21:43,600
bear in mind that on this platform there

637
00:21:41,440 --> 00:21:44,480
is the aes ni instruction so basically

638
00:21:43,600 --> 00:21:47,039
the aes

639
00:21:44,480 --> 00:21:48,320
implementation is a hardware

640
00:21:47,039 --> 00:21:51,280
implementation

641
00:21:48,320 --> 00:21:52,720
whereas cavate uses just the regular the

642
00:21:51,280 --> 00:21:56,480
general purpose

643
00:21:52,720 --> 00:21:56,480
vector instructions on that machine

644
00:21:56,880 --> 00:22:03,120
okay so last thing is about zoof

645
00:22:00,640 --> 00:22:04,400
so zoof as the name suggests is supposed

646
00:22:03,120 --> 00:22:06,639
to be fast

647
00:22:04,400 --> 00:22:08,480
but the key message for zuf is that

648
00:22:06,640 --> 00:22:09,679
because we use a smaller permutation

649
00:22:08,480 --> 00:22:12,320
this permutation

650
00:22:09,679 --> 00:22:12,799
the state can fit in 12 resistors of 32

651
00:22:12,320 --> 00:22:16,559
bits

652
00:22:12,799 --> 00:22:20,320
so that can fit in a typical arm cortex

653
00:22:16,559 --> 00:22:21,360
processor it can also run fast on small

654
00:22:20,320 --> 00:22:23,678
processors

655
00:22:21,360 --> 00:22:25,039
and because of the parallelism it can

656
00:22:23,679 --> 00:22:28,799
also run fast on

657
00:22:25,039 --> 00:22:29,840
high end processors so concretely on the

658
00:22:28,799 --> 00:22:32,400
cortex

659
00:22:29,840 --> 00:22:33,039
m0 processor that's a fairly small one

660
00:22:32,400 --> 00:22:35,840
it's about

661
00:22:33,039 --> 00:22:36,720
four to five times faster than the aes

662
00:22:35,840 --> 00:22:38,399
and

663
00:22:36,720 --> 00:22:41,520
about the same figures for i mean the

664
00:22:38,400 --> 00:22:43,840
same ratio for cortex m3

665
00:22:41,520 --> 00:22:45,600
um on skylake it's slightly slower than

666
00:22:43,840 --> 00:22:47,600
the ac encounter mode

667
00:22:45,600 --> 00:22:49,120
but if you have access to the new avx

668
00:22:47,600 --> 00:22:51,439
512 instructions

669
00:22:49,120 --> 00:22:52,479
then it again becomes faster than the es

670
00:22:51,440 --> 00:22:56,159
encounter mode

671
00:22:52,480 --> 00:22:58,080
again using general purpose instructions

672
00:22:56,159 --> 00:23:00,720
so that's all i wanted to say just to

673
00:22:58,080 --> 00:23:02,559
conclude in this talk i'll try to um

674
00:23:00,720 --> 00:23:03,840
to explain to you why we think

675
00:23:02,559 --> 00:23:06,639
incrementality

676
00:23:03,840 --> 00:23:08,399
in symmetric crypto can make protocols

677
00:23:06,640 --> 00:23:09,919
simpler we've seen that with an example

678
00:23:08,400 --> 00:23:11,520
which is disco

679
00:23:09,919 --> 00:23:13,600
we also think that it can make some

680
00:23:11,520 --> 00:23:16,080
modes more natural the notion of

681
00:23:13,600 --> 00:23:18,080
sessions really directly benefits from

682
00:23:16,080 --> 00:23:19,840
from this incrementality

683
00:23:18,080 --> 00:23:21,199
and then to capture this incrementality

684
00:23:19,840 --> 00:23:24,000
we define the deck function

685
00:23:21,200 --> 00:23:24,400
interface and we showed that we could

686
00:23:24,000 --> 00:23:29,200
make

687
00:23:24,400 --> 00:23:30,480
some efficient schemes based on that

688
00:23:29,200 --> 00:23:32,880
specifically using the farfalle

689
00:23:30,480 --> 00:23:37,840
construction and

690
00:23:32,880 --> 00:23:37,840
that's it thank you for our attention

691
00:23:39,410 --> 00:23:43,600
[Applause]

692
00:23:41,440 --> 00:23:47,039
we've got time for one or two short

693
00:23:43,600 --> 00:23:47,039
questions so is there any of these

694
00:23:48,840 --> 00:23:51,840
questions

695
00:23:58,400 --> 00:24:01,919
okay thank you very much for this

696
00:24:00,000 --> 00:24:03,919
interesting talk uh it was not clear

697
00:24:01,919 --> 00:24:04,960
from the your description of the forfeit

698
00:24:03,919 --> 00:24:07,919
construction

699
00:24:04,960 --> 00:24:09,919
you can parallelize uh the encryption

700
00:24:07,919 --> 00:24:12,400
and decryption operations but

701
00:24:09,919 --> 00:24:14,480
can you receive messages out of order

702
00:24:12,400 --> 00:24:14,960
and validate the macs that correspond to

703
00:24:14,480 --> 00:24:16,640
it

704
00:24:14,960 --> 00:24:18,400
because that would be an a very

705
00:24:16,640 --> 00:24:20,000
important use case for things like wire

706
00:24:18,400 --> 00:24:21,760
guard for instance

707
00:24:20,000 --> 00:24:23,039
okay so if you have out of order

708
00:24:21,760 --> 00:24:25,360
messages so

709
00:24:23,039 --> 00:24:26,559
basically the notion of session doesn't

710
00:24:25,360 --> 00:24:28,559
simply doesn't work

711
00:24:26,559 --> 00:24:30,240
so you cannot really exploit it the

712
00:24:28,559 --> 00:24:34,158
parallelism i was mentioning

713
00:24:30,240 --> 00:24:34,559
it was not about this session mechanism

714
00:24:34,159 --> 00:24:36,880
it's

715
00:24:34,559 --> 00:24:38,158
independent it's just that this

716
00:24:36,880 --> 00:24:41,279
construction

717
00:24:38,159 --> 00:24:42,320
allows you to implement so the longer

718
00:24:41,279 --> 00:24:44,240
the input

719
00:24:42,320 --> 00:24:45,678
the more parallelism you can exploit

720
00:24:44,240 --> 00:24:47,440
independently of

721
00:24:45,679 --> 00:24:49,200
session mechanism if it's out of order

722
00:24:47,440 --> 00:24:51,200
or anything

723
00:24:49,200 --> 00:24:52,720
is from the security point of view we

724
00:24:51,200 --> 00:24:55,120
would like to validate

725
00:24:52,720 --> 00:24:57,440
max as fast as possible to avoid denial

726
00:24:55,120 --> 00:25:00,879
of service conditions

727
00:24:57,440 --> 00:25:02,559
um so having two large messages is not

728
00:25:00,880 --> 00:25:06,159
necessary of course

729
00:25:02,559 --> 00:25:09,279
and that's why in in this mode

730
00:25:06,159 --> 00:25:10,799
we have a tag at session starter so you

731
00:25:09,279 --> 00:25:11,120
have a tag that you can immediately

732
00:25:10,799 --> 00:25:13,200
check

733
00:25:11,120 --> 00:25:14,559
just based on the nonce so denial of

734
00:25:13,200 --> 00:25:16,400
service attacks

735
00:25:14,559 --> 00:25:18,158
i mean they need to have this tag

736
00:25:16,400 --> 00:25:19,840
correct otherwise you can just stop

737
00:25:18,159 --> 00:25:23,840
there and you don't need to

738
00:25:19,840 --> 00:25:23,840
check the whole message okay thank you

739
00:25:27,279 --> 00:25:31,279
we are out of the time so thank you for

740
00:25:29,120 --> 00:25:42,239
your questions and for your talk

741
00:25:31,279 --> 00:25:42,240
thank you

