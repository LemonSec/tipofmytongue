1
00:00:07,680 --> 00:00:10,719
let's go

2
00:00:08,720 --> 00:00:12,080
so hi everybody before i introduce

3
00:00:10,719 --> 00:00:14,639
myself

4
00:00:12,080 --> 00:00:16,400
just uh a few words i'm going to speak

5
00:00:14,639 --> 00:00:18,320
about the about fedora

6
00:00:16,400 --> 00:00:19,759
so federer is a linux distribution based

7
00:00:18,320 --> 00:00:22,800
on rpm

8
00:00:19,760 --> 00:00:24,320
and it has several releases

9
00:00:22,800 --> 00:00:28,160
and the one i've been using during this

10
00:00:24,320 --> 00:00:31,760
talk is rawhide which basically means

11
00:00:28,160 --> 00:00:34,640
the latest version of each package is

12
00:00:31,760 --> 00:00:37,120
going to ride and then they settle down

13
00:00:34,640 --> 00:00:40,320
so it's basically the same as unstable

14
00:00:37,120 --> 00:00:43,680
in debian okay so uh

15
00:00:40,320 --> 00:00:47,360
we're using that as a test

16
00:00:43,680 --> 00:00:48,800
all the binary package in fedora are

17
00:00:47,360 --> 00:00:51,840
compiled with gcc

18
00:00:48,800 --> 00:00:54,239
and that's a strong requirement and

19
00:00:51,840 --> 00:00:55,039
basically we're trying to switch to

20
00:00:54,239 --> 00:00:58,000
clang

21
00:00:55,039 --> 00:00:58,879
not for the distribution but just to

22
00:00:58,000 --> 00:01:02,000
test

23
00:00:58,879 --> 00:01:04,000
both the packages and clang so that we

24
00:01:02,000 --> 00:01:08,320
can gather more information so that's

25
00:01:04,000 --> 00:01:08,320
the overall topic of the talk

26
00:01:08,640 --> 00:01:12,880
so i'm serge i'm working for red hat as

27
00:01:11,600 --> 00:01:15,919
a computer engineer

28
00:01:12,880 --> 00:01:17,920
mostly on llvm

29
00:01:15,920 --> 00:01:19,280
and we're going to speak about claringer

30
00:01:17,920 --> 00:01:21,439
and fedora

31
00:01:19,280 --> 00:01:23,200
but before we speak about fedora let's

32
00:01:21,439 --> 00:01:26,559
speak about about

33
00:01:23,200 --> 00:01:29,759
firefox so this

34
00:01:26,560 --> 00:01:30,479
fiscal steam stuff is the federal

35
00:01:29,759 --> 00:01:32,799
engineering

36
00:01:30,479 --> 00:01:34,000
steering committee and whenever you want

37
00:01:32,799 --> 00:01:37,360
to do something

38
00:01:34,000 --> 00:01:39,040
that does not obey the rule of fedora

39
00:01:37,360 --> 00:01:40,880
you need to open an issue and then there

40
00:01:39,040 --> 00:01:43,920
is a discussion

41
00:01:40,880 --> 00:01:45,520
and something happens or doesn't happen

42
00:01:43,920 --> 00:01:47,119
and this particular discussion was

43
00:01:45,520 --> 00:01:50,240
interesting because

44
00:01:47,119 --> 00:01:53,680
firefox upstream decided

45
00:01:50,240 --> 00:01:54,880
not to support gcc anymore as their

46
00:01:53,680 --> 00:01:58,240
native compiler

47
00:01:54,880 --> 00:02:01,600
which means that for both osx

48
00:01:58,240 --> 00:02:02,798
windows and linux the package is

49
00:02:01,600 --> 00:02:04,798
compiled with clang

50
00:02:02,799 --> 00:02:06,079
there are two main advantages of doing

51
00:02:04,799 --> 00:02:09,200
that

52
00:02:06,079 --> 00:02:10,639
which are if you take apart the quality

53
00:02:09,199 --> 00:02:13,519
of clang of course

54
00:02:10,639 --> 00:02:14,319
is uh you need to need to support one

55
00:02:13,520 --> 00:02:16,879
compiler

56
00:02:14,319 --> 00:02:18,958
and not one compiler for windows one

57
00:02:16,879 --> 00:02:19,599
compiler for osx and one compiler for

58
00:02:18,959 --> 00:02:21,920
linux

59
00:02:19,599 --> 00:02:23,599
you've got the same compiler so whatever

60
00:02:21,920 --> 00:02:26,559
compiler specific stuff

61
00:02:23,599 --> 00:02:27,519
you're going to support it's only going

62
00:02:26,560 --> 00:02:30,400
to happen once

63
00:02:27,520 --> 00:02:30,800
so that's cool for them and the other

64
00:02:30,400 --> 00:02:33,920
more

65
00:02:30,800 --> 00:02:35,200
technical thing is that firefox is being

66
00:02:33,920 --> 00:02:38,160
partially rewritten

67
00:02:35,200 --> 00:02:39,200
in rust and the rest compiler is using

68
00:02:38,160 --> 00:02:42,000
lsvm

69
00:02:39,200 --> 00:02:44,000
as an internal representation and

70
00:02:42,000 --> 00:02:46,000
firefox is still using c plus plus

71
00:02:44,000 --> 00:02:48,319
so they both if both use the same

72
00:02:46,000 --> 00:02:50,480
internal representation it opens

73
00:02:48,319 --> 00:02:51,440
a lot of opportunities for optimization

74
00:02:50,480 --> 00:02:54,160
at least time

75
00:02:51,440 --> 00:02:56,000
which is not possible if the c plus plus

76
00:02:54,160 --> 00:02:58,079
code is compiled with gcc and the other

77
00:02:56,000 --> 00:03:00,159
part is compiled with llvm so they are

78
00:02:58,080 --> 00:03:04,879
good motivation for fedora for

79
00:03:00,159 --> 00:03:08,239
firefox to switch to clanger but then

80
00:03:04,879 --> 00:03:10,159
they still accept gcc fixes

81
00:03:08,239 --> 00:03:11,519
that is if the firefox code base does

82
00:03:10,159 --> 00:03:13,280
not compile with gcc

83
00:03:11,519 --> 00:03:15,040
and you've got a patch that accept it

84
00:03:13,280 --> 00:03:19,040
they don't test it anymore

85
00:03:15,040 --> 00:03:22,079
so as a what should you do

86
00:03:19,040 --> 00:03:25,120
either supports the gcc build which is

87
00:03:22,080 --> 00:03:26,080
a lot of effort or switch to the same

88
00:03:25,120 --> 00:03:28,400
compiler

89
00:03:26,080 --> 00:03:30,159
as upstream and use clang and which is

90
00:03:28,400 --> 00:03:31,280
okay because clang is also packaged in

91
00:03:30,159 --> 00:03:35,359
fedora

92
00:03:31,280 --> 00:03:37,120
but it does not obey the rule of fedora

93
00:03:35,360 --> 00:03:39,519
so they asked for an exception and first

94
00:03:37,120 --> 00:03:41,680
they got it and that the expect

95
00:03:39,519 --> 00:03:46,159
the exception got removed and that's the

96
00:03:41,680 --> 00:03:49,680
topic of the thread

97
00:03:46,159 --> 00:03:52,640
and why did it got removed

98
00:03:49,680 --> 00:03:54,159
there was quite a lot of objection to

99
00:03:52,640 --> 00:03:56,319
using clang

100
00:03:54,159 --> 00:03:58,239
and without going into the details some

101
00:03:56,319 --> 00:03:59,839
of them were related to

102
00:03:58,239 --> 00:04:02,560
the quality of the debug information

103
00:03:59,840 --> 00:04:05,280
generated by clang compared to

104
00:04:02,560 --> 00:04:06,319
the debug information generated by gcc

105
00:04:05,280 --> 00:04:10,319
which is

106
00:04:06,319 --> 00:04:13,280
a relatively well-known topic

107
00:04:10,319 --> 00:04:15,200
another one was related to the default

108
00:04:13,280 --> 00:04:17,759
flag like

109
00:04:15,200 --> 00:04:21,120
for exception only whether asynchronous

110
00:04:17,759 --> 00:04:23,840
unwind was activated by default or not

111
00:04:21,120 --> 00:04:25,040
for all targets and gcc and don't have

112
00:04:23,840 --> 00:04:28,880
the same behavior

113
00:04:25,040 --> 00:04:31,040
to that respect a more

114
00:04:28,880 --> 00:04:32,719
interesting one was the support of

115
00:04:31,040 --> 00:04:34,880
semantic interposition

116
00:04:32,720 --> 00:04:35,840
so semantic interposition is another

117
00:04:34,880 --> 00:04:38,240
thing

118
00:04:35,840 --> 00:04:39,919
that states basically that any symbol

119
00:04:38,240 --> 00:04:44,160
that is

120
00:04:39,919 --> 00:04:46,320
exported in a shared library

121
00:04:44,160 --> 00:04:47,360
may have its behavior or its

122
00:04:46,320 --> 00:04:49,599
implementation

123
00:04:47,360 --> 00:04:51,280
changed at runtime for instance through

124
00:04:49,600 --> 00:04:53,360
ld preload

125
00:04:51,280 --> 00:04:54,320
which means that it's a strong

126
00:04:53,360 --> 00:04:56,160
optimization

127
00:04:54,320 --> 00:04:57,840
barrier for any inter-procedural

128
00:04:56,160 --> 00:05:00,880
optimization

129
00:04:57,840 --> 00:05:05,119
and by default gcc obeys the

130
00:05:00,880 --> 00:05:08,000
elf rules and clan doesn't

131
00:05:05,120 --> 00:05:08,639
did not have any flag to enforce that

132
00:05:08,000 --> 00:05:11,919
rule

133
00:05:08,639 --> 00:05:12,720
until very recently and so that's a big

134
00:05:11,919 --> 00:05:15,758
difference

135
00:05:12,720 --> 00:05:17,039
it's a big difference for performance i

136
00:05:15,759 --> 00:05:20,080
know that in fedora

137
00:05:17,039 --> 00:05:21,919
the python library switched it to no

138
00:05:20,080 --> 00:05:24,560
semantics imposition

139
00:05:21,919 --> 00:05:26,799
for the for their gcc build because of

140
00:05:24,560 --> 00:05:30,320
the performance impact

141
00:05:26,800 --> 00:05:33,600
but by default it's not the case in gcc

142
00:05:30,320 --> 00:05:36,880
and clang has the opposite behavior

143
00:05:33,600 --> 00:05:40,080
so that could be a blocker

144
00:05:36,880 --> 00:05:41,280
a very important topic was security

145
00:05:40,080 --> 00:05:43,280
flags

146
00:05:41,280 --> 00:05:45,198
all fedora package are compiled by

147
00:05:43,280 --> 00:05:47,039
default by with

148
00:05:45,199 --> 00:05:48,320
a set of optimization flags and you've

149
00:05:47,039 --> 00:05:52,080
got of course

150
00:05:48,320 --> 00:05:55,199
minus o2 plus basically most

151
00:05:52,080 --> 00:05:58,400
of gcc security features turned on

152
00:05:55,199 --> 00:06:00,720
one of them is fortify source it's more

153
00:05:58,400 --> 00:06:04,960
for c code

154
00:06:00,720 --> 00:06:08,319
and it was not well respected by clang

155
00:06:04,960 --> 00:06:09,599
if you activate that the clan compiles

156
00:06:08,319 --> 00:06:11,919
your code correctly

157
00:06:09,600 --> 00:06:13,199
but the security hardening does not

158
00:06:11,919 --> 00:06:16,479
actually happen

159
00:06:13,199 --> 00:06:18,880
on all situations which is a problem

160
00:06:16,479 --> 00:06:21,680
when i'm saying playing that's clang 9

161
00:06:18,880 --> 00:06:23,840
not clank 10.

162
00:06:21,680 --> 00:06:26,080
someone claims that the stack protection

163
00:06:23,840 --> 00:06:29,758
thing were not as evolved

164
00:06:26,080 --> 00:06:31,680
in clang as in gcc the rightfully

165
00:06:29,759 --> 00:06:33,039
pointed out that stack clash protection

166
00:06:31,680 --> 00:06:37,440
was not implemented

167
00:06:33,039 --> 00:06:39,840
in clearing at all while it is in ngcc

168
00:06:37,440 --> 00:06:41,280
so basically one of the stronger

169
00:06:39,840 --> 00:06:44,239
positions was

170
00:06:41,280 --> 00:06:45,599
if you compile your code with clanger

171
00:06:44,240 --> 00:06:49,120
it's less secure

172
00:06:45,600 --> 00:06:51,599
with some definition of secure than

173
00:06:49,120 --> 00:06:52,720
if you compile it with gcc and that led

174
00:06:51,599 --> 00:06:56,000
to firefox

175
00:06:52,720 --> 00:06:59,599
still being supported for gcc by

176
00:06:56,000 --> 00:07:01,199
the fedora guys which is for from a

177
00:06:59,599 --> 00:07:02,800
maintainer point of view that's not a

178
00:07:01,199 --> 00:07:06,160
very good property but

179
00:07:02,800 --> 00:07:08,880
that's how it is so we told ourselves

180
00:07:06,160 --> 00:07:09,360
that's a good opportunity to improve

181
00:07:08,880 --> 00:07:12,319
clang

182
00:07:09,360 --> 00:07:13,840
and maybe to remove some of this

183
00:07:12,319 --> 00:07:17,840
constraint

184
00:07:13,840 --> 00:07:20,719
so the fortify so i

185
00:07:17,840 --> 00:07:21,440
i had a look to that and for fortify it

186
00:07:20,720 --> 00:07:24,080
was very

187
00:07:21,440 --> 00:07:25,919
interesting the way fortification is

188
00:07:24,080 --> 00:07:28,479
implemented in the glibc

189
00:07:25,919 --> 00:07:29,198
is basically you've got your mem copy

190
00:07:28,479 --> 00:07:31,599
and then

191
00:07:29,199 --> 00:07:32,880
if fortify is activated you've got an

192
00:07:31,599 --> 00:07:36,400
inline definition

193
00:07:32,880 --> 00:07:40,560
that overrides the behavior of memcopy

194
00:07:36,400 --> 00:07:44,000
but the clone behavior was

195
00:07:40,560 --> 00:07:46,720
if you use a built-in and m copy

196
00:07:44,000 --> 00:07:47,759
is considered as a recognized built-in

197
00:07:46,720 --> 00:07:50,960
then

198
00:07:47,759 --> 00:07:52,160
you don't care about any overloads that

199
00:07:50,960 --> 00:07:54,479
would be given by

200
00:07:52,160 --> 00:07:56,240
the user you're using the actual

201
00:07:54,479 --> 00:07:58,639
built-in semantic

202
00:07:56,240 --> 00:07:59,680
and so they were not using the fortified

203
00:07:58,639 --> 00:08:01,840
semantic because

204
00:07:59,680 --> 00:08:03,919
it was recognized either built-in so we

205
00:08:01,840 --> 00:08:07,119
changed that and now when you

206
00:08:03,919 --> 00:08:08,960
compute when you compile with clang and

207
00:08:07,120 --> 00:08:10,960
fortify on

208
00:08:08,960 --> 00:08:12,479
and you found a mem copy if there is an

209
00:08:10,960 --> 00:08:13,919
inline definition that changes the

210
00:08:12,479 --> 00:08:17,599
behavior of memcopy

211
00:08:13,919 --> 00:08:19,599
clang is going to honor that version

212
00:08:17,599 --> 00:08:21,039
and so you've got the runtime checks and

213
00:08:19,599 --> 00:08:24,800
so on so that's

214
00:08:21,039 --> 00:08:26,800
one more step forward that's not full

215
00:08:24,800 --> 00:08:28,560
fortify specification well there is no

216
00:08:26,800 --> 00:08:31,520
fortify specification right

217
00:08:28,560 --> 00:08:32,159
there is just uh the gcc implementation

218
00:08:31,520 --> 00:08:35,039
which is

219
00:08:32,159 --> 00:08:36,958
tightly linked to the gdbc one but if

220
00:08:35,039 --> 00:08:40,080
you want to have the same observable

221
00:08:36,958 --> 00:08:44,640
observable behavior you're getting

222
00:08:40,080 --> 00:08:46,800
closer so that's one good thing

223
00:08:44,640 --> 00:08:48,880
there's also warnings at some point you

224
00:08:46,800 --> 00:08:49,680
could say and many packets do compile

225
00:08:48,880 --> 00:08:52,839
with w

226
00:08:49,680 --> 00:08:56,079
error that if gcc detects

227
00:08:52,839 --> 00:08:59,519
uh a security issue and wants about it

228
00:08:56,080 --> 00:09:02,640
maybe clan should warn about it too and

229
00:08:59,519 --> 00:09:06,160
one of the issue was sprintf

230
00:09:02,640 --> 00:09:08,399
if you can compute statically

231
00:09:06,160 --> 00:09:10,319
the size of your buffer then you can do

232
00:09:08,399 --> 00:09:13,200
some kind of checks whether the format

233
00:09:10,320 --> 00:09:16,320
is going to fit into the buffer or not

234
00:09:13,200 --> 00:09:20,560
and this is some

235
00:09:16,320 --> 00:09:23,680
not that much advanced analysis

236
00:09:20,560 --> 00:09:25,518
on that topic and clang had a few of

237
00:09:23,680 --> 00:09:28,880
them but

238
00:09:25,519 --> 00:09:31,440
to a lesser extent and now we

239
00:09:28,880 --> 00:09:32,959
can implement full understanding of the

240
00:09:31,440 --> 00:09:36,480
printf specification

241
00:09:32,959 --> 00:09:40,399
and can compute the lower bound of the

242
00:09:36,480 --> 00:09:42,160
buffer size requirements and warn you if

243
00:09:40,399 --> 00:09:44,240
the buffer is not large enough so i

244
00:09:42,160 --> 00:09:47,360
don't expect that warning to be issued

245
00:09:44,240 --> 00:09:47,360
a lot of time but still

246
00:09:47,839 --> 00:09:51,839
that's something that can be now

247
00:09:49,360 --> 00:09:55,920
detected and it has

248
00:09:51,839 --> 00:09:57,839
end in clang but

249
00:09:55,920 --> 00:09:59,760
probably not clang 10 it would be

250
00:09:57,839 --> 00:10:01,920
incling 11

251
00:09:59,760 --> 00:10:02,880
and that's something that gcg does not

252
00:10:01,920 --> 00:10:05,120
implement now

253
00:10:02,880 --> 00:10:06,240
as much so we are raising each other but

254
00:10:05,120 --> 00:10:08,959
that's saying

255
00:10:06,240 --> 00:10:11,920
no yeah that's saying emulation so i'm

256
00:10:08,959 --> 00:10:11,920
totally fine with that

257
00:10:13,040 --> 00:10:17,519
about semantic interposition that sounds

258
00:10:15,519 --> 00:10:19,760
like a very difficult thing to implement

259
00:10:17,519 --> 00:10:20,560
because it basically means that whenever

260
00:10:19,760 --> 00:10:23,200
you've got

261
00:10:20,560 --> 00:10:24,560
an inter-procedural optimization in

262
00:10:23,200 --> 00:10:27,760
clang

263
00:10:24,560 --> 00:10:29,920
you need to change the behavior of this

264
00:10:27,760 --> 00:10:31,120
optimization depending on the status of

265
00:10:29,920 --> 00:10:34,000
the symbol

266
00:10:31,120 --> 00:10:35,200
based on basically its visibility and

267
00:10:34,000 --> 00:10:37,040
linkage type

268
00:10:35,200 --> 00:10:39,519
the good thing was it was already

269
00:10:37,040 --> 00:10:41,839
implemented at the llvm level

270
00:10:39,519 --> 00:10:42,720
but there was no switch to activate that

271
00:10:41,839 --> 00:10:45,440
in clang

272
00:10:42,720 --> 00:10:46,560
so what looked like a tremendous task

273
00:10:45,440 --> 00:10:49,360
actually was not

274
00:10:46,560 --> 00:10:50,640
that difficult and would make it

275
00:10:49,360 --> 00:10:53,200
possible to land it in

276
00:10:50,640 --> 00:10:54,000
one week or so so now the default in

277
00:10:53,200 --> 00:10:57,279
clang

278
00:10:54,000 --> 00:11:00,959
clank 11 is still no semantic

279
00:10:57,279 --> 00:11:04,000
interposition but you can force

280
00:11:00,959 --> 00:11:04,560
the flag to minus f centimeter position

281
00:11:04,000 --> 00:11:07,680
then

282
00:11:04,560 --> 00:11:09,920
it will be respected just like in gcc

283
00:11:07,680 --> 00:11:10,959
for package where it matters to have

284
00:11:09,920 --> 00:11:14,000
symbols

285
00:11:10,959 --> 00:11:17,439
change that load time or

286
00:11:14,000 --> 00:11:20,000
runtime so just to give you an hint

287
00:11:17,440 --> 00:11:21,120
about the impact if you've got this

288
00:11:20,000 --> 00:11:22,800
small

289
00:11:21,120 --> 00:11:24,399
this mod code with semantic

290
00:11:22,800 --> 00:11:26,560
interposition on

291
00:11:24,399 --> 00:11:28,320
you can inline full but you can't in

292
00:11:26,560 --> 00:11:31,680
line bar

293
00:11:28,320 --> 00:11:33,600
because bar could be changed at runtime

294
00:11:31,680 --> 00:11:35,040
and so changing its implementation would

295
00:11:33,600 --> 00:11:37,920
not

296
00:11:35,040 --> 00:11:37,920
have the same impact

297
00:11:38,959 --> 00:11:44,160
if you inline it then as it's the

298
00:11:42,160 --> 00:11:47,439
ld preload thing will not change all the

299
00:11:44,160 --> 00:11:47,439
behavior of bar

300
00:11:48,640 --> 00:11:54,800
then there is stack clash protection uh

301
00:11:51,680 --> 00:11:58,479
funnily enough that's so the star clash

302
00:11:54,800 --> 00:12:00,900
vulnerability is one year and a half

303
00:11:58,480 --> 00:12:02,560
old and

304
00:12:00,900 --> 00:12:05,279
[Music]

305
00:12:02,560 --> 00:12:05,839
the flag got into gcc relatively quickly

306
00:12:05,279 --> 00:12:08,399
and

307
00:12:05,839 --> 00:12:09,519
not at all in clang the basic idea is

308
00:12:08,399 --> 00:12:13,600
whenever you

309
00:12:09,519 --> 00:12:16,720
allocate memory on the stack

310
00:12:13,600 --> 00:12:20,000
if it's

311
00:12:16,720 --> 00:12:23,279
larger than one page then there is

312
00:12:20,000 --> 00:12:25,680
a risk that it overlaps

313
00:12:23,279 --> 00:12:27,279
the page guard allocated by the kernel

314
00:12:25,680 --> 00:12:30,399
and so your stack is going

315
00:12:27,279 --> 00:12:32,000
to overlap with your hip which is not

316
00:12:30,399 --> 00:12:32,560
the property you want and that's the

317
00:12:32,000 --> 00:12:35,680
beginning

318
00:12:32,560 --> 00:12:38,719
of the of the attack

319
00:12:35,680 --> 00:12:41,839
and so the the contour measure

320
00:12:38,720 --> 00:12:43,920
is basically don't allocate large stack

321
00:12:41,839 --> 00:12:46,320
but allocate by

322
00:12:43,920 --> 00:12:47,839
by chunk of one page and touch memory

323
00:12:46,320 --> 00:12:50,880
each time you do that so you are

324
00:12:47,839 --> 00:12:52,720
sure that you will trigger the page

325
00:12:50,880 --> 00:12:56,800
guard allocated by the kernel

326
00:12:52,720 --> 00:13:00,000
and then you've got your signal and

327
00:12:56,800 --> 00:13:02,880
you're safe so there's an implementation

328
00:13:00,000 --> 00:13:06,399
for x86

329
00:13:02,880 --> 00:13:07,519
under review it turned out to be a bit

330
00:13:06,399 --> 00:13:10,240
more difficult than

331
00:13:07,519 --> 00:13:10,800
expected and it's only for x86 it's

332
00:13:10,240 --> 00:13:14,399
obviously

333
00:13:10,800 --> 00:13:16,399
very architecture dependent

334
00:13:14,399 --> 00:13:17,920
but you can see on that small example

335
00:13:16,399 --> 00:13:21,120
that you're allocating

336
00:13:17,920 --> 00:13:25,040
a large amount of stack and instead of

337
00:13:21,120 --> 00:13:26,240
having a single sub you have two of them

338
00:13:25,040 --> 00:13:29,360
with a move

339
00:13:26,240 --> 00:13:33,279
interleaved which actually touches

340
00:13:29,360 --> 00:13:35,200
the page the good thing with x86 is that

341
00:13:33,279 --> 00:13:37,279
whenever you make a function call you're

342
00:13:35,200 --> 00:13:41,440
saving the return address on the stack

343
00:13:37,279 --> 00:13:43,439
so you've got a free a lot of free

344
00:13:41,440 --> 00:13:45,920
probes in the stack so you can implement

345
00:13:43,440 --> 00:13:47,519
that locally at the function level

346
00:13:45,920 --> 00:13:49,199
and it may not be the case of all

347
00:13:47,519 --> 00:13:50,480
architecture which is why it's not

348
00:13:49,199 --> 00:13:53,920
implemented at a

349
00:13:50,480 --> 00:13:56,959
higher level so

350
00:13:53,920 --> 00:14:01,040
um okay most of the

351
00:13:56,959 --> 00:14:05,040
with that set of patches most of the

352
00:14:01,040 --> 00:14:08,319
points raised during the firefox stuff

353
00:14:05,040 --> 00:14:10,639
got handled and so it's okay maybe uh

354
00:14:08,320 --> 00:14:12,000
the situation can evolve but it also

355
00:14:10,639 --> 00:14:15,040
rings a bell

356
00:14:12,000 --> 00:14:17,760
what about the next package that want to

357
00:14:15,040 --> 00:14:19,040
switch for to clang upstream and what

358
00:14:17,760 --> 00:14:22,160
are we going to do

359
00:14:19,040 --> 00:14:23,519
or maybe we could state it otherwise we

360
00:14:22,160 --> 00:14:26,959
learned a lot

361
00:14:23,519 --> 00:14:28,240
by using clang as a compiler for firefox

362
00:14:26,959 --> 00:14:30,638
within fedora

363
00:14:28,240 --> 00:14:32,160
maybe if we don't compile only firefox

364
00:14:30,639 --> 00:14:34,880
but all the package we can

365
00:14:32,160 --> 00:14:36,160
learn much more things so that's what we

366
00:14:34,880 --> 00:14:38,800
did basically

367
00:14:36,160 --> 00:14:40,639
changing the default compiler in a

368
00:14:38,800 --> 00:14:43,519
separate bid root so

369
00:14:40,639 --> 00:14:44,320
in another fedora build and gathering

370
00:14:43,519 --> 00:14:46,399
information

371
00:14:44,320 --> 00:14:47,440
and that's the second part of the talk

372
00:14:46,399 --> 00:14:52,079
sharing some of the

373
00:14:47,440 --> 00:14:55,040
insight we get so we are still at the

374
00:14:52,079 --> 00:14:56,319
collection information gathering step so

375
00:14:55,040 --> 00:15:00,319
no

376
00:14:56,320 --> 00:15:02,959
answers but uh good hints about

377
00:15:00,320 --> 00:15:06,800
where we can we could drive clanger and

378
00:15:02,959 --> 00:15:06,800
that's for real uh real package

379
00:15:06,880 --> 00:15:12,560
so all the data collection or

380
00:15:10,160 --> 00:15:13,519
the setup of the bedroot and so on was

381
00:15:12,560 --> 00:15:16,319
done by a

382
00:15:13,519 --> 00:15:17,760
storm sailor so a huge thanks for him

383
00:15:16,320 --> 00:15:20,160
because i'm not

384
00:15:17,760 --> 00:15:21,120
proficient enough on that part and so he

385
00:15:20,160 --> 00:15:24,319
did all the

386
00:15:21,120 --> 00:15:24,880
dirty stuff and i only had to grab full

387
00:15:24,320 --> 00:15:27,920
logs

388
00:15:24,880 --> 00:15:30,320
which is totally in my scope

389
00:15:27,920 --> 00:15:31,439
and then starting to implement the thing

390
00:15:30,320 --> 00:15:34,800
in lvm which

391
00:15:31,440 --> 00:15:38,160
i could start to work on

392
00:15:34,800 --> 00:15:39,199
so it's not about clang but it's about

393
00:15:38,160 --> 00:15:41,680
fedora fedora

394
00:15:39,199 --> 00:15:42,639
rawhide requires python 3. we could

395
00:15:41,680 --> 00:15:44,880
still

396
00:15:42,639 --> 00:15:46,240
depend on python 2 but well the word is

397
00:15:44,880 --> 00:15:48,959
moving so let's move

398
00:15:46,240 --> 00:15:50,639
with it well the world started to move

399
00:15:48,959 --> 00:15:51,839
10 years ago so it's a good time to

400
00:15:50,639 --> 00:15:55,199
start to move

401
00:15:51,839 --> 00:15:57,360
on our own many tools

402
00:15:55,199 --> 00:15:58,959
and i'm not speaking about utility

403
00:15:57,360 --> 00:16:02,560
scripts but tools that the

404
00:15:58,959 --> 00:16:05,839
end user actually sees depend on python

405
00:16:02,560 --> 00:16:08,959
so that's especially the case for lldb

406
00:16:05,839 --> 00:16:10,800
for all the debugger scripting parts but

407
00:16:08,959 --> 00:16:12,239
that's also the case for clang format or

408
00:16:10,800 --> 00:16:15,599
conformative

409
00:16:12,240 --> 00:16:18,320
and so uh if we want to ship these

410
00:16:15,600 --> 00:16:19,120
scripts in fedora we need to to have

411
00:16:18,320 --> 00:16:22,480
these scripts

412
00:16:19,120 --> 00:16:24,320
run correctly in python 3.

413
00:16:22,480 --> 00:16:25,920
but if you have a look at the

414
00:16:24,320 --> 00:16:30,880
requirement for lvm it's

415
00:16:25,920 --> 00:16:34,399
python 2.9.2.7 still now

416
00:16:30,880 --> 00:16:37,199
so we had to port all the scripts

417
00:16:34,399 --> 00:16:38,320
to being portable between python 2 and

418
00:16:37,199 --> 00:16:41,599
python 3

419
00:16:38,320 --> 00:16:43,279
which was quite a huge task not a very

420
00:16:41,600 --> 00:16:46,480
difficult one

421
00:16:43,279 --> 00:16:47,439
because we are not using a lot of string

422
00:16:46,480 --> 00:16:49,680
manipulation

423
00:16:47,440 --> 00:16:51,260
in the script so that was basically okay

424
00:16:49,680 --> 00:16:52,719
but still

425
00:16:51,260 --> 00:16:55,279
[Music]

426
00:16:52,720 --> 00:16:58,160
it was some kind of an effort but now

427
00:16:55,279 --> 00:17:01,439
all the python code base of llvm

428
00:16:58,160 --> 00:17:03,759
is compatible with both python version

429
00:17:01,440 --> 00:17:05,839
and i start in a thread which received

430
00:17:03,759 --> 00:17:08,559
relatively good

431
00:17:05,839 --> 00:17:09,918
feedback that by the end of this year we

432
00:17:08,559 --> 00:17:13,359
could probably drop

433
00:17:09,919 --> 00:17:15,280
python 2 and switch to python 3 which

434
00:17:13,359 --> 00:17:16,879
would not be and python 2 is not

435
00:17:15,280 --> 00:17:19,119
supported for this world year so

436
00:17:16,880 --> 00:17:20,720
it totally makes sense and lfm doesn't

437
00:17:19,119 --> 00:17:23,280
have a strong history of

438
00:17:20,720 --> 00:17:23,280
supporting

439
00:17:23,760 --> 00:17:29,840
aging technologies so we are

440
00:17:27,039 --> 00:17:31,200
upgrading the semi version quite often

441
00:17:29,840 --> 00:17:33,840
so we can also upgrade

442
00:17:31,200 --> 00:17:35,440
the python version but at least that was

443
00:17:33,840 --> 00:17:39,280
a requirement for fedora and

444
00:17:35,440 --> 00:17:41,600
this requirement is fulfilled

445
00:17:39,280 --> 00:17:43,039
so another specific tool to federalize

446
00:17:41,600 --> 00:17:46,799
an obin

447
00:17:43,039 --> 00:17:47,679
so anubian basically it's a plugin for

448
00:17:46,799 --> 00:17:50,879
gcc and

449
00:17:47,679 --> 00:17:55,039
it records all the compiler flags into

450
00:17:50,880 --> 00:17:57,600
notes so that for each function

451
00:17:55,039 --> 00:17:59,200
in the binary we know which compiler

452
00:17:57,600 --> 00:18:02,559
flags were used and that's

453
00:17:59,200 --> 00:18:03,120
more mostly used for security you know

454
00:18:02,559 --> 00:18:06,000
which

455
00:18:03,120 --> 00:18:06,799
security flags were used for each

456
00:18:06,000 --> 00:18:09,440
function

457
00:18:06,799 --> 00:18:10,080
and then you know for your wall binary

458
00:18:09,440 --> 00:18:12,080
if

459
00:18:10,080 --> 00:18:15,280
some functions were not compiled with

460
00:18:12,080 --> 00:18:19,280
the appropriate flags

461
00:18:15,280 --> 00:18:21,918
so that's a gcc plugin and it relies

462
00:18:19,280 --> 00:18:24,160
on some specific linker supports

463
00:18:21,919 --> 00:18:28,240
basically it was about

464
00:18:24,160 --> 00:18:31,440
notes were attached to function through

465
00:18:28,240 --> 00:18:36,160
health groups and when you merge

466
00:18:31,440 --> 00:18:38,559
groups the notes got removed by lld

467
00:18:36,160 --> 00:18:41,440
and it's no longer the case but it was

468
00:18:38,559 --> 00:18:44,320
something we needed to implement

469
00:18:41,440 --> 00:18:45,919
and if we want to make one step further

470
00:18:44,320 --> 00:18:48,080
this plugin this underpinning plugin

471
00:18:45,919 --> 00:18:51,600
could also be implemented

472
00:18:48,080 --> 00:18:54,840
for clang and that's being done

473
00:18:51,600 --> 00:18:58,639
internally after that by a colleague of

474
00:18:54,840 --> 00:19:00,399
mine with my support so

475
00:18:58,640 --> 00:19:02,799
as this and this plugin is used by

476
00:19:00,400 --> 00:19:06,320
default we

477
00:19:02,799 --> 00:19:06,320
it was important to do that task

478
00:19:07,039 --> 00:19:10,400
then about the real normal package now

479
00:19:09,440 --> 00:19:13,039
that we have set up

480
00:19:10,400 --> 00:19:14,799
a decent environment how do you change

481
00:19:13,039 --> 00:19:15,200
the underlying compiler because we've

482
00:19:14,799 --> 00:19:17,200
got

483
00:19:15,200 --> 00:19:19,280
all these spec files the spec file is

484
00:19:17,200 --> 00:19:21,919
just a recipe about how you build your

485
00:19:19,280 --> 00:19:23,280
actual fedora package

486
00:19:21,919 --> 00:19:26,080
how do you change from the system

487
00:19:23,280 --> 00:19:27,760
compiler to uh to clang

488
00:19:26,080 --> 00:19:29,280
it turns out that the easiest way to do

489
00:19:27,760 --> 00:19:32,160
that was to

490
00:19:29,280 --> 00:19:34,559
provide a new set of rpm macro basically

491
00:19:32,160 --> 00:19:38,240
stating that whenever you mention

492
00:19:34,559 --> 00:19:39,200
the person cc is going to be redirected

493
00:19:38,240 --> 00:19:40,880
to clang

494
00:19:39,200 --> 00:19:43,280
and the same thing for makes he make and

495
00:19:40,880 --> 00:19:46,880
so on

496
00:19:43,280 --> 00:19:48,720
it assumes that everybody is writing an

497
00:19:46,880 --> 00:19:50,840
abstract description

498
00:19:48,720 --> 00:19:52,160
of the build process which was not the

499
00:19:50,840 --> 00:19:56,320
case

500
00:19:52,160 --> 00:19:57,440
at all but fixing that is also a way to

501
00:19:56,320 --> 00:20:00,320
fix packager

502
00:19:57,440 --> 00:20:01,840
uh package description so that was a

503
00:20:00,320 --> 00:20:04,158
good road to follow

504
00:20:01,840 --> 00:20:05,280
and once we get at that we get some

505
00:20:04,159 --> 00:20:07,280
builds that fail

506
00:20:05,280 --> 00:20:08,399
we get logs and we can grab through that

507
00:20:07,280 --> 00:20:11,360
to understand why

508
00:20:08,400 --> 00:20:13,440
we've got errors so that's the basic

509
00:20:11,360 --> 00:20:16,639
process

510
00:20:13,440 --> 00:20:22,000
and that's the result so

511
00:20:16,640 --> 00:20:22,000
on the 4000 package we we rebuilt

512
00:20:22,080 --> 00:20:25,760
three quarters of them just rebuild

513
00:20:24,880 --> 00:20:28,640
without

514
00:20:25,760 --> 00:20:30,960
any issue which is both a good surprise

515
00:20:28,640 --> 00:20:34,640
but it also means that 1000 of them

516
00:20:30,960 --> 00:20:38,159
remains not some of them didn't build

517
00:20:34,640 --> 00:20:40,480
with gcc either i mean because

518
00:20:38,159 --> 00:20:41,360
of some reason uh which are out of my

519
00:20:40,480 --> 00:20:44,000
scope so

520
00:20:41,360 --> 00:20:45,520
we put this one apart and so we are

521
00:20:44,000 --> 00:20:49,039
interested in the

522
00:20:45,520 --> 00:20:51,760
100 1141

523
00:20:49,039 --> 00:20:52,158
ones that actually failed and so i had

524
00:20:51,760 --> 00:20:56,080
to dig

525
00:20:52,159 --> 00:20:59,520
through the eurologs and understand why

526
00:20:56,080 --> 00:21:03,678
and so more almost

527
00:20:59,520 --> 00:21:06,559
300 of them just failed because

528
00:21:03,679 --> 00:21:07,120
they were compiling with clanger but

529
00:21:06,559 --> 00:21:10,480
using

530
00:21:07,120 --> 00:21:14,840
some gcc specific flags and so

531
00:21:10,480 --> 00:21:17,520
we get an error so we also had

532
00:21:14,840 --> 00:21:19,280
some clang specific flags that were

533
00:21:17,520 --> 00:21:21,679
added

534
00:21:19,280 --> 00:21:22,799
by us in the process and they were not

535
00:21:21,679 --> 00:21:25,919
supported by

536
00:21:22,799 --> 00:21:28,158
gcc which means that our

537
00:21:25,919 --> 00:21:30,320
instrumentation of gcc failed which is

538
00:21:28,159 --> 00:21:32,320
also a good information

539
00:21:30,320 --> 00:21:34,000
to some extent so stack protection is

540
00:21:32,320 --> 00:21:36,720
not

541
00:21:34,000 --> 00:21:37,520
respected but we knew that so some arm

542
00:21:36,720 --> 00:21:41,120
specific

543
00:21:37,520 --> 00:21:44,720
things about neon and quadrup

544
00:21:41,120 --> 00:21:45,120
accuracy floats something about how you

545
00:21:44,720 --> 00:21:47,520
pass

546
00:21:45,120 --> 00:21:48,399
arguments which we could probably ignore

547
00:21:47,520 --> 00:21:50,158
in clanger

548
00:21:48,400 --> 00:21:51,600
there's already a bunch of flags that we

549
00:21:50,159 --> 00:21:53,919
just

550
00:21:51,600 --> 00:21:55,760
ignore so we could have that one that

551
00:21:53,919 --> 00:21:56,960
tracking is to improve the quality of

552
00:21:55,760 --> 00:21:58,720
the debug information

553
00:21:56,960 --> 00:22:00,240
so we can relate that to the quality of

554
00:21:58,720 --> 00:22:02,880
debug information

555
00:22:00,240 --> 00:22:04,159
in clanger but we could probably ignore

556
00:22:02,880 --> 00:22:06,159
that one too because

557
00:22:04,159 --> 00:22:07,760
well it's just debug information it

558
00:22:06,159 --> 00:22:09,120
doesn't affect the user experience at

559
00:22:07,760 --> 00:22:13,520
all

560
00:22:09,120 --> 00:22:15,760
no trampoline is more related to

561
00:22:13,520 --> 00:22:17,360
gcc implementing nested function through

562
00:22:15,760 --> 00:22:18,240
trampolines so it's a way to control

563
00:22:17,360 --> 00:22:21,120
that

564
00:22:18,240 --> 00:22:22,080
and no one force exceptionally expects

565
00:22:21,120 --> 00:22:25,439
it's something to

566
00:22:22,080 --> 00:22:29,120
lighten the cost of exceptions

567
00:22:25,440 --> 00:22:31,840
or make or and shrink the binary size

568
00:22:29,120 --> 00:22:33,918
so maybe we could implement that i don't

569
00:22:31,840 --> 00:22:37,280
know

570
00:22:33,919 --> 00:22:39,760
sometimes we just failed to hook

571
00:22:37,280 --> 00:22:41,520
clang and we instead of gcc and we

572
00:22:39,760 --> 00:22:44,320
detected that so

573
00:22:41,520 --> 00:22:45,039
to detect that we just go through all

574
00:22:44,320 --> 00:22:48,240
the

575
00:22:45,039 --> 00:22:50,080
binaries generated

576
00:22:48,240 --> 00:22:51,760
from well shipped in the package and we

577
00:22:50,080 --> 00:22:52,639
go into the command section of the

578
00:22:51,760 --> 00:22:54,960
binary and

579
00:22:52,640 --> 00:22:56,080
if we don't find the compiled with clang

580
00:22:54,960 --> 00:22:58,960
then it means that

581
00:22:56,080 --> 00:23:00,559
we did not compile any object if we file

582
00:22:58,960 --> 00:23:01,120
compiled with clang it means that at

583
00:23:00,559 --> 00:23:03,039
least one

584
00:23:01,120 --> 00:23:06,559
object of the package got compiled with

585
00:23:03,039 --> 00:23:06,559
claim which is not all of them

586
00:23:06,640 --> 00:23:11,440
there is always unfortunately the gcc

587
00:23:09,520 --> 00:23:14,400
well unfortunately

588
00:23:11,440 --> 00:23:15,600
for our tracking thing uh the gcc

589
00:23:14,400 --> 00:23:19,039
comment because

590
00:23:15,600 --> 00:23:22,480
uh we are still using the crt

591
00:23:19,039 --> 00:23:26,720
stuff on gcc as a linker so

592
00:23:22,480 --> 00:23:28,080
there is always the gcc watermark

593
00:23:26,720 --> 00:23:30,000
but at least some of them were not

594
00:23:28,080 --> 00:23:33,360
compiled at all so we need to

595
00:23:30,000 --> 00:23:38,159
to understand why some people find it

596
00:23:33,360 --> 00:23:40,399
smart to compile with w error and

597
00:23:38,159 --> 00:23:42,000
for our task he's not smart at all

598
00:23:40,400 --> 00:23:45,600
because

599
00:23:42,000 --> 00:23:47,760
clang and gcc differ a lot to the extent

600
00:23:45,600 --> 00:23:50,959
of the warning implemented and

601
00:23:47,760 --> 00:23:51,919
what kind of area of situations they

602
00:23:50,960 --> 00:23:53,520
catch

603
00:23:51,919 --> 00:23:56,159
and so something like printf being

604
00:23:53,520 --> 00:23:57,039
redefined is not an error on gcc and it

605
00:23:56,159 --> 00:23:58,880
is

606
00:23:57,039 --> 00:24:01,440
well it's not warning on gcc but it is

607
00:23:58,880 --> 00:24:01,440
including

608
00:24:01,760 --> 00:24:06,960
ignoring virtual value

609
00:24:04,799 --> 00:24:09,440
detective infinite recursions this kind

610
00:24:06,960 --> 00:24:10,960
of thing so it's

611
00:24:09,440 --> 00:24:12,880
it's probably we're not going to

612
00:24:10,960 --> 00:24:15,279
implement the same set of warnings

613
00:24:12,880 --> 00:24:16,559
so i i don't quite know what to do about

614
00:24:15,279 --> 00:24:21,440
that one probably remove

615
00:24:16,559 --> 00:24:21,440
war would be a decent approach

616
00:24:21,919 --> 00:24:26,400
but i'm not going to spend much time on

617
00:24:24,159 --> 00:24:26,400
that

618
00:24:27,279 --> 00:24:30,559
some when you activate fast mat you've

619
00:24:29,840 --> 00:24:33,360
got some

620
00:24:30,559 --> 00:24:34,399
specific implementation of the matte

621
00:24:33,360 --> 00:24:38,080
library

622
00:24:34,400 --> 00:24:41,679
and it turns out that gcc relies on some

623
00:24:38,080 --> 00:24:44,320
new symbols that's finished by infinite

624
00:24:41,679 --> 00:24:45,279
and these symbols sometimes we fail to

625
00:24:44,320 --> 00:24:47,600
link with them

626
00:24:45,279 --> 00:24:48,400
when using clang i have not i can't say

627
00:24:47,600 --> 00:24:50,639
why

628
00:24:48,400 --> 00:24:52,159
but so it could either be a packaging

629
00:24:50,640 --> 00:24:55,840
issue or

630
00:24:52,159 --> 00:24:58,080
a clone issue i don't know

631
00:24:55,840 --> 00:25:00,240
but still it means that there is some

632
00:24:58,080 --> 00:25:02,879
implicit things are coded

633
00:25:00,240 --> 00:25:05,440
in gcc or in the package that are not

634
00:25:02,880 --> 00:25:05,440
well described

635
00:25:07,120 --> 00:25:11,678
the famous configure error we have got a

636
00:25:09,120 --> 00:25:11,678
lot of them

637
00:25:12,159 --> 00:25:15,679
you may be aware of the difficulty of

638
00:25:14,080 --> 00:25:18,799
writing portable

639
00:25:15,679 --> 00:25:21,600
autoconf tests and if you're not

640
00:25:18,799 --> 00:25:22,158
having a look at all the tests that fail

641
00:25:21,600 --> 00:25:25,439
because

642
00:25:22,159 --> 00:25:26,880
clang is not capable of compiling a c

643
00:25:25,440 --> 00:25:29,120
code

644
00:25:26,880 --> 00:25:30,559
that's the only output we get from the

645
00:25:29,120 --> 00:25:32,879
configure we could

646
00:25:30,559 --> 00:25:33,760
of course have a look to the config.log

647
00:25:32,880 --> 00:25:37,200
but

648
00:25:33,760 --> 00:25:40,080
so many package failed just to configure

649
00:25:37,200 --> 00:25:41,360
because using clang during the

650
00:25:40,080 --> 00:25:44,480
configuration step

651
00:25:41,360 --> 00:25:47,760
just fails my hint about that

652
00:25:44,480 --> 00:25:50,080
is that because we use some specific

653
00:25:47,760 --> 00:25:51,520
compiler flags they are used during the

654
00:25:50,080 --> 00:25:54,559
configuration step

655
00:25:51,520 --> 00:25:56,799
and so if we've got any of these w

656
00:25:54,559 --> 00:25:58,879
error things or unsupported argument

657
00:25:56,799 --> 00:26:01,279
thing we are going to detect that

658
00:25:58,880 --> 00:26:03,500
at configuration step and so we just

659
00:26:01,279 --> 00:26:04,640
fade to configure

660
00:26:03,500 --> 00:26:06,240
[Music]

661
00:26:04,640 --> 00:26:08,080
does it mean that we need to rewrite the

662
00:26:06,240 --> 00:26:10,400
configure step which means contacting

663
00:26:08,080 --> 00:26:13,199
each upstream package to

664
00:26:10,400 --> 00:26:13,600
update that or do something else i can

665
00:26:13,200 --> 00:26:16,799
tell

666
00:26:13,600 --> 00:26:18,639
but that's something which

667
00:26:16,799 --> 00:26:21,039
will not be very pleasing to fix and

668
00:26:18,640 --> 00:26:25,840
maybe not of much interest

669
00:26:21,039 --> 00:26:25,840
with respect to just clang

670
00:26:26,400 --> 00:26:29,760
something that is important from clang

671
00:26:28,320 --> 00:26:32,799
but only in fedora

672
00:26:29,760 --> 00:26:35,440
sometimes client fails to find it

673
00:26:32,799 --> 00:26:37,520
some part of the runtime either because

674
00:26:35,440 --> 00:26:39,520
it's not well packaged or because there

675
00:26:37,520 --> 00:26:42,799
are some assumptions that are not met

676
00:26:39,520 --> 00:26:44,559
i can't i am doing the packaging so

677
00:26:42,799 --> 00:26:46,240
i do hope that it's not a packaging

678
00:26:44,559 --> 00:26:49,279
issue but i fear it is

679
00:26:46,240 --> 00:26:49,279
and we need to check that

680
00:26:49,600 --> 00:26:53,279
i can't tell about the gcc underscore c

681
00:26:51,600 --> 00:26:56,399
and i did not took time

682
00:26:53,279 --> 00:26:57,039
to to investigate what this implement

683
00:26:56,400 --> 00:27:00,080
but we can

684
00:26:57,039 --> 00:27:02,320
discuss about it a bit later

685
00:27:00,080 --> 00:27:03,918
sometimes uh there's disagreement on the

686
00:27:02,320 --> 00:27:04,720
standards so that's something that is

687
00:27:03,919 --> 00:27:07,760
very valuable

688
00:27:04,720 --> 00:27:10,159
either for clang if

689
00:27:07,760 --> 00:27:11,600
they wrongly disagree or for the

690
00:27:10,159 --> 00:27:13,919
upstream package

691
00:27:11,600 --> 00:27:16,080
if it means that they could improve

692
00:27:13,919 --> 00:27:18,070
their code base

693
00:27:16,080 --> 00:27:19,360
so sometimes it's linked to

694
00:27:18,070 --> 00:27:21,020
[Music]

695
00:27:19,360 --> 00:27:22,719
gcc extension so the one

696
00:27:21,020 --> 00:27:24,879
[Music]

697
00:27:22,720 --> 00:27:26,399
like you don't support a nested function

698
00:27:24,880 --> 00:27:29,200
sometimes it's

699
00:27:26,399 --> 00:27:31,560
comparison between pointers should be

700
00:27:29,200 --> 00:27:33,200
equal or different but not

701
00:27:31,560 --> 00:27:36,480
[Music]

702
00:27:33,200 --> 00:27:38,080
or that comparison and i don't know if

703
00:27:36,480 --> 00:27:41,200
what the standard actually says about

704
00:27:38,080 --> 00:27:44,240
that but obviously gcc and can disagree

705
00:27:41,200 --> 00:27:46,000
so maybe we could improve the situation

706
00:27:44,240 --> 00:27:48,080
and sometimes there is just use of and

707
00:27:46,000 --> 00:27:50,000
declare the notifier and i

708
00:27:48,080 --> 00:27:51,600
i would be surprised to investigate and

709
00:27:50,000 --> 00:27:53,679
check why kang

710
00:27:51,600 --> 00:27:55,918
doesn't fight the indian fire while gcc

711
00:27:53,679 --> 00:27:55,919
does

712
00:27:56,000 --> 00:28:00,080
so that's more of an upstream issue so

713
00:27:58,399 --> 00:28:03,039
the language extension stuff

714
00:28:00,080 --> 00:28:04,559
here you have nested uh nested function

715
00:28:03,039 --> 00:28:05,120
something you can easily write with a

716
00:28:04,559 --> 00:28:09,600
lambda

717
00:28:05,120 --> 00:28:12,799
in c plus plus but gcc allows to do that

718
00:28:09,600 --> 00:28:16,080
in c for an extension and some

719
00:28:12,799 --> 00:28:17,520
package rely on that and it's probably

720
00:28:16,080 --> 00:28:19,039
going to be difficult to make them

721
00:28:17,520 --> 00:28:20,639
change their mind because if they choose

722
00:28:19,039 --> 00:28:23,679
that extension it's because

723
00:28:20,640 --> 00:28:27,600
it makes their development

724
00:28:23,679 --> 00:28:27,600
flow easier or i don't know

725
00:28:27,679 --> 00:28:30,960
and when you get you try to compile that

726
00:28:29,520 --> 00:28:32,879
code there is a warning like

727
00:28:30,960 --> 00:28:34,640
okay clang is not supporting that and

728
00:28:32,880 --> 00:28:37,200
it's not going to support that

729
00:28:34,640 --> 00:28:38,640
so it's clearly stating in the in the

730
00:28:37,200 --> 00:28:41,840
error message that

731
00:28:38,640 --> 00:28:45,360
um we can't do anything about that or

732
00:28:41,840 --> 00:28:47,600
we could maintain a patch at the federal

733
00:28:45,360 --> 00:28:51,360
level but

734
00:28:47,600 --> 00:28:53,840
i don't want to do that openmp and it's

735
00:28:51,360 --> 00:28:55,360
also related it's probably related to

736
00:28:53,840 --> 00:28:58,559
either packaging issue or

737
00:28:55,360 --> 00:29:00,479
dependency issues sometimes clank

738
00:28:58,559 --> 00:29:03,039
doesn't find

739
00:29:00,480 --> 00:29:04,559
the runtime support for openmp or the

740
00:29:03,039 --> 00:29:07,600
configuration step

741
00:29:04,559 --> 00:29:08,960
fails and fails to detect openmp when

742
00:29:07,600 --> 00:29:12,000
compiled with clang we need to

743
00:29:08,960 --> 00:29:12,000
investigate because that's

744
00:29:12,080 --> 00:29:16,240
not a good thing if clang users can't

745
00:29:14,159 --> 00:29:19,120
use openmp out of the box

746
00:29:16,240 --> 00:29:19,679
in fedora but probably not a clang issue

747
00:29:19,120 --> 00:29:22,719
more

748
00:29:19,679 --> 00:29:26,080
probably either a configuration issue or

749
00:29:22,720 --> 00:29:28,720
a packaging issue

750
00:29:26,080 --> 00:29:29,360
and some package just use still use gcc

751
00:29:28,720 --> 00:29:31,440
because

752
00:29:29,360 --> 00:29:34,639
there are art codes make or they are

753
00:29:31,440 --> 00:29:38,880
code gcc or g plus plus

754
00:29:34,640 --> 00:29:41,679
either in the package or in the actual

755
00:29:38,880 --> 00:29:42,720
upstream sources which makes sense

756
00:29:41,679 --> 00:29:45,039
because

757
00:29:42,720 --> 00:29:46,880
if you're not sensible to portability

758
00:29:45,039 --> 00:29:48,480
you just use gcc and it works since

759
00:29:46,880 --> 00:29:51,039
there's no reason to

760
00:29:48,480 --> 00:29:51,520
to worry about that until you realize

761
00:29:51,039 --> 00:29:53,200
that

762
00:29:51,520 --> 00:29:55,760
some users may want to compile with

763
00:29:53,200 --> 00:29:57,600
clang with good argument or clang or

764
00:29:55,760 --> 00:29:59,440
whatever others it could be

765
00:29:57,600 --> 00:30:01,360
intel compiler because of performance i

766
00:29:59,440 --> 00:30:04,240
don't know and

767
00:30:01,360 --> 00:30:06,158
and then it could be an improvement both

768
00:30:04,240 --> 00:30:07,919
for the packager and for upstream to

769
00:30:06,159 --> 00:30:11,120
have a more generic build

770
00:30:07,919 --> 00:30:14,240
process so that's the end of

771
00:30:11,120 --> 00:30:14,239
uh of my talk

772
00:30:14,320 --> 00:30:21,360
so the ideas i would like to

773
00:30:19,200 --> 00:30:23,200
to share i'd like to share with that

774
00:30:21,360 --> 00:30:24,959
talk was

775
00:30:23,200 --> 00:30:26,399
there's a lot of learn there's a lot of

776
00:30:24,960 --> 00:30:29,679
things to learn

777
00:30:26,399 --> 00:30:31,439
while having such a diverse set of

778
00:30:29,679 --> 00:30:33,600
programs to compile with clang

779
00:30:31,440 --> 00:30:35,279
and that's far from the test suit of

780
00:30:33,600 --> 00:30:38,480
llvm

781
00:30:35,279 --> 00:30:40,640
so a good opportunity to improve

782
00:30:38,480 --> 00:30:43,120
probably making all this information

783
00:30:40,640 --> 00:30:45,600
available in a way that

784
00:30:43,120 --> 00:30:47,039
anybody could access them opening all

785
00:30:45,600 --> 00:30:50,158
the bugs

786
00:30:47,039 --> 00:30:51,600
on boxier or on github depending on how

787
00:30:50,159 --> 00:30:55,039
it evolves

788
00:30:51,600 --> 00:30:56,158
could be a good thing it's probably less

789
00:30:55,039 --> 00:30:59,039
important for

790
00:30:56,159 --> 00:31:00,960
the lvm community to do the upstream

791
00:30:59,039 --> 00:31:04,879
work i mean trying to

792
00:31:00,960 --> 00:31:07,679
update every package packaged in fedora

793
00:31:04,880 --> 00:31:07,679
to support clang

794
00:31:08,159 --> 00:31:12,640
is more of a social task than of an

795
00:31:10,640 --> 00:31:14,240
engineering task so it requires special

796
00:31:12,640 --> 00:31:17,519
skills

797
00:31:14,240 --> 00:31:18,240
but some people may be open to that and

798
00:31:17,519 --> 00:31:21,600
some

799
00:31:18,240 --> 00:31:24,080
may not but that's still

800
00:31:21,600 --> 00:31:25,279
an opportunity for upstream to improve

801
00:31:24,080 --> 00:31:29,360
too

802
00:31:25,279 --> 00:31:31,039
but i see a lot of good thing for clang

803
00:31:29,360 --> 00:31:32,959
at least for the past month when i've

804
00:31:31,039 --> 00:31:34,559
been working on that and so it also

805
00:31:32,960 --> 00:31:36,720
fills my daily job

806
00:31:34,559 --> 00:31:38,879
on interesting tasks so other personal

807
00:31:36,720 --> 00:31:41,120
points that's a good thing

808
00:31:38,880 --> 00:31:42,080
and i want it to last with that final

809
00:31:41,120 --> 00:31:44,399
error

810
00:31:42,080 --> 00:31:45,678
so if you are compiling in class plus a

811
00:31:44,399 --> 00:31:49,439
new

812
00:31:45,679 --> 00:31:51,200
name one of your member function

813
00:31:49,440 --> 00:31:52,799
d printf and then you compile with

814
00:31:51,200 --> 00:31:56,080
fortify source

815
00:31:52,799 --> 00:31:56,960
but you order your includes in a way

816
00:31:56,080 --> 00:31:59,199
that

817
00:31:56,960 --> 00:32:00,480
sometimes you will get the macro

818
00:31:59,200 --> 00:32:03,760
redefinition

819
00:32:00,480 --> 00:32:05,760
from the std sd

820
00:32:03,760 --> 00:32:06,960
i o headers and sometimes you don't then

821
00:32:05,760 --> 00:32:08,960
you end up

822
00:32:06,960 --> 00:32:10,000
with part of your class having a d

823
00:32:08,960 --> 00:32:12,399
printf number

824
00:32:10,000 --> 00:32:13,600
and the actual implementation using

825
00:32:12,399 --> 00:32:16,239
another name

826
00:32:13,600 --> 00:32:16,879
and uh so you you've got an error just

827
00:32:16,240 --> 00:32:19,919
because

828
00:32:16,880 --> 00:32:21,919
uh of

829
00:32:19,919 --> 00:32:24,000
basically macros and the way they

830
00:32:21,919 --> 00:32:26,720
interact with fortify source

831
00:32:24,000 --> 00:32:27,120
and that was a funny one only one in the

832
00:32:26,720 --> 00:32:30,880
world

833
00:32:27,120 --> 00:32:33,760
fedora code base but

834
00:32:30,880 --> 00:32:35,519
an unexpected one so now if you have any

835
00:32:33,760 --> 00:32:38,799
questions i'm happy to share more

836
00:32:35,519 --> 00:32:40,320
information or yep thanks for your talk

837
00:32:38,799 --> 00:32:42,399
i was curious about um you mentioned

838
00:32:40,320 --> 00:32:44,480
earlier gcc plug-in about recording the

839
00:32:42,399 --> 00:32:46,639
exact compiler indication in the notes

840
00:32:44,480 --> 00:32:47,519
section of the elf object that sounds

841
00:32:46,640 --> 00:32:49,440
generically

842
00:32:47,519 --> 00:32:50,880
useful theoretically that could be a

843
00:32:49,440 --> 00:32:52,640
dash f flag

844
00:32:50,880 --> 00:32:54,240
in the compiler it doesn't need to be a

845
00:32:52,640 --> 00:32:57,679
plug-in right

846
00:32:54,240 --> 00:33:00,399
so the question was uh recording all the

847
00:32:57,679 --> 00:33:02,720
optimization flag and security flags

848
00:33:00,399 --> 00:33:03,918
is something that is generally useful

849
00:33:02,720 --> 00:33:07,200
and so why

850
00:33:03,919 --> 00:33:11,840
using a plugin and not an actual

851
00:33:07,200 --> 00:33:15,840
compiler flag maybe

852
00:33:11,840 --> 00:33:18,000
i'm not the one developing that plugin

853
00:33:15,840 --> 00:33:19,918
the plugin is open so that's not a

854
00:33:18,000 --> 00:33:22,960
property

855
00:33:19,919 --> 00:33:25,760
reason but that could be

856
00:33:22,960 --> 00:33:26,399
my guess would be it's easier to write a

857
00:33:25,760 --> 00:33:28,480
plugin

858
00:33:26,399 --> 00:33:30,320
it may be the first step before you go

859
00:33:28,480 --> 00:33:32,720
into the code base that's

860
00:33:30,320 --> 00:33:34,480
what academics do they don't write into

861
00:33:32,720 --> 00:33:35,279
the call lfm code base they first write

862
00:33:34,480 --> 00:33:38,559
plugins

863
00:33:35,279 --> 00:33:41,600
and eventually it gets in so plug-in is

864
00:33:38,559 --> 00:33:44,240
a good first step so that could be an

865
00:33:41,600 --> 00:33:44,799
engineering answer would be why not

866
00:33:44,240 --> 00:33:46,480
starting

867
00:33:44,799 --> 00:33:48,000
with a plug-in it's easier you can

868
00:33:46,480 --> 00:33:49,039
maintain it you don't have to get

869
00:33:48,000 --> 00:33:51,840
through the

870
00:33:49,039 --> 00:33:52,240
review process of the actual compiler

871
00:33:51,840 --> 00:33:53,850
and

872
00:33:52,240 --> 00:33:55,279
should it evolve into

873
00:33:53,850 --> 00:33:58,399
[Music]

874
00:33:55,279 --> 00:33:58,399
an actual compiler flag

875
00:33:59,200 --> 00:34:02,799
it does make sense to me at least

876
00:34:04,720 --> 00:34:08,560
yeah whatever order i think people are

877
00:34:07,200 --> 00:34:09,119
interested in talking many interesting

878
00:34:08,560 --> 00:34:12,879
details

879
00:34:09,119 --> 00:34:13,599
uh well let me wonder uh do you consider

880
00:34:12,879 --> 00:34:15,759
this journey

881
00:34:13,599 --> 00:34:17,520
a success for you and also like as you

882
00:34:15,760 --> 00:34:20,000
still like got a lot accomplished

883
00:34:17,520 --> 00:34:21,119
uh what are the most valuable outcomes

884
00:34:20,000 --> 00:34:23,520
which you got for

885
00:34:21,119 --> 00:34:24,480
for your digital data out of this

886
00:34:23,520 --> 00:34:27,280
project

887
00:34:24,480 --> 00:34:27,839
so your so the question is for testing

888
00:34:27,280 --> 00:34:31,919
but

889
00:34:27,839 --> 00:34:35,119
for fedora but what what kind of testing

890
00:34:31,918 --> 00:34:38,480
could you operate you get out of

891
00:34:35,119 --> 00:34:39,839
this position i don't quite understand

892
00:34:38,480 --> 00:34:41,359
the question can you repeat please

893
00:34:39,839 --> 00:34:43,359
you said you did this project for

894
00:34:41,359 --> 00:34:45,918
testing uh justin what uh

895
00:34:43,359 --> 00:34:48,239
can you give more details what you will

896
00:34:45,918 --> 00:34:50,799
try to test with this

897
00:34:48,239 --> 00:34:52,000
so the question is we did that for

898
00:34:50,800 --> 00:34:54,240
testing

899
00:34:52,000 --> 00:34:56,239
what's next and what are the the

900
00:34:54,239 --> 00:35:00,399
conclusion or the outcomes

901
00:34:56,239 --> 00:35:03,919
and so my personal take on that

902
00:35:00,400 --> 00:35:08,000
is clang did clang llvm did

903
00:35:03,920 --> 00:35:11,040
improve a lot thanks to this testing

904
00:35:08,000 --> 00:35:14,000
on here on the firefox part and so

905
00:35:11,040 --> 00:35:16,240
from all the information we gathered on

906
00:35:14,000 --> 00:35:19,200
the larger scale

907
00:35:16,240 --> 00:35:20,640
test there's a lot of situations where

908
00:35:19,200 --> 00:35:24,078
we could improve clang

909
00:35:20,640 --> 00:35:27,920
based on the gcc experience basically

910
00:35:24,079 --> 00:35:31,599
and that's a good thing i mean

911
00:35:27,920 --> 00:35:33,599
it's not only about trying to match gcc

912
00:35:31,599 --> 00:35:35,280
so that's the initial motivation but in

913
00:35:33,599 --> 00:35:39,040
the end what you get

914
00:35:35,280 --> 00:35:42,240
is uh more feature for the clan users

915
00:35:39,040 --> 00:35:44,480
and i'm going to go on that way

916
00:35:42,240 --> 00:35:45,680
because not for all the flags i'm going

917
00:35:44,480 --> 00:35:46,800
to sort out the things that i'm

918
00:35:45,680 --> 00:35:49,759
interested in

919
00:35:46,800 --> 00:35:51,359
and the things that uh seems valuable

920
00:35:49,760 --> 00:35:53,680
for clone as a wall

921
00:35:51,359 --> 00:35:55,598
or could be accepted because like nested

922
00:35:53,680 --> 00:35:58,000
function i could find it interesting

923
00:35:55,599 --> 00:35:58,960
on my own but it won't get accepted

924
00:35:58,000 --> 00:36:02,560
upstream so

925
00:35:58,960 --> 00:36:04,079
i won't work on that and it also

926
00:36:02,560 --> 00:36:06,880
provides opportunities for people to

927
00:36:04,079 --> 00:36:09,839
work on that apart from just

928
00:36:06,880 --> 00:36:12,400
the mt in red hat so basically it

929
00:36:09,839 --> 00:36:15,839
provides more opportunity to fix bugs

930
00:36:12,400 --> 00:36:17,760
or add new features and driven by

931
00:36:15,839 --> 00:36:20,160
actual test case and not only my

932
00:36:17,760 --> 00:36:22,800
imagination

933
00:36:20,160 --> 00:36:26,000
victor i know that the previously

934
00:36:22,800 --> 00:36:28,160
operating system is

935
00:36:26,000 --> 00:36:29,520
there is also a project to rebuild

936
00:36:28,160 --> 00:36:31,359
debian using claim

937
00:36:29,520 --> 00:36:35,040
yep are you collaborating with this

938
00:36:31,359 --> 00:36:38,319
project i'm collaborating with

939
00:36:35,040 --> 00:36:41,200
the debian project on that so

940
00:36:38,320 --> 00:36:42,160
the question was uh there's not only

941
00:36:41,200 --> 00:36:44,240
fedora

942
00:36:42,160 --> 00:36:46,480
the bsd systems some of them are

943
00:36:44,240 --> 00:36:50,160
compiling with clang

944
00:36:46,480 --> 00:36:52,480
there is a side project of debian

945
00:36:50,160 --> 00:36:54,319
of compiling debian with clang which is

946
00:36:52,480 --> 00:36:57,119
which has more much more history

947
00:36:54,320 --> 00:36:58,960
than we have uh are we on our in our

948
00:36:57,119 --> 00:37:00,960
bubble or collaborating

949
00:36:58,960 --> 00:37:03,040
so it happens that i personally know the

950
00:37:00,960 --> 00:37:05,200
guy in charge of that for debian

951
00:37:03,040 --> 00:37:06,400
and so we do collaborate both on the

952
00:37:05,200 --> 00:37:08,720
packaging side

953
00:37:06,400 --> 00:37:10,800
whenever i have a patch that i need to

954
00:37:08,720 --> 00:37:12,560
apply to lfm i'm discussing with him

955
00:37:10,800 --> 00:37:14,640
are you applying that patch in the bn2

956
00:37:12,560 --> 00:37:17,920
why for this kind of thing

957
00:37:14,640 --> 00:37:20,560
and also for the

958
00:37:17,920 --> 00:37:22,480
general approach especially on for

959
00:37:20,560 --> 00:37:23,520
firefox because this guy appears to also

960
00:37:22,480 --> 00:37:27,040
be

961
00:37:23,520 --> 00:37:28,160
in the firefox team so for instance all

962
00:37:27,040 --> 00:37:30,079
the fortify

963
00:37:28,160 --> 00:37:31,200
stuff and the stack flash protection

964
00:37:30,079 --> 00:37:33,760
stuff

965
00:37:31,200 --> 00:37:35,520
while being reviewed by lvm were also

966
00:37:33,760 --> 00:37:38,720
recom

967
00:37:35,520 --> 00:37:42,640
tested on the firefox

968
00:37:38,720 --> 00:37:43,680
version recompiled because they plan to

969
00:37:42,640 --> 00:37:44,960
use it

970
00:37:43,680 --> 00:37:47,040
they are really interested in that

971
00:37:44,960 --> 00:37:49,200
feature so even if they don't

972
00:37:47,040 --> 00:37:50,320
make it to the fedora build they will

973
00:37:49,200 --> 00:37:52,319
make it to

974
00:37:50,320 --> 00:37:54,000
the farrier fox build so there is some

975
00:37:52,320 --> 00:37:57,040
kind of cooperation

976
00:37:54,000 --> 00:37:59,599
cooperation one more question yeah what

977
00:37:57,040 --> 00:38:03,440
about actual testing

978
00:37:59,599 --> 00:38:05,680
that it builds no home whole

979
00:38:03,440 --> 00:38:06,640
it pains me that you have so much so

980
00:38:05,680 --> 00:38:09,919
less trust

981
00:38:06,640 --> 00:38:11,839
into the packager job uh

982
00:38:09,920 --> 00:38:13,280
whenever you do a package you've got a

983
00:38:11,839 --> 00:38:14,880
test section and basically you're

984
00:38:13,280 --> 00:38:17,920
running the test

985
00:38:14,880 --> 00:38:21,040
section um no

986
00:38:17,920 --> 00:38:23,359
how many packages actually have tests

987
00:38:21,040 --> 00:38:25,599
well i can only speak about the package

988
00:38:23,359 --> 00:38:28,078
i maintain in fedora which is

989
00:38:25,599 --> 00:38:29,760
very small amounts but all of them do

990
00:38:28,079 --> 00:38:32,480
have a test section

991
00:38:29,760 --> 00:38:34,720
so it's also true that for some

992
00:38:32,480 --> 00:38:35,359
architecture the test section of llvm

993
00:38:34,720 --> 00:38:38,879
has a

994
00:38:35,359 --> 00:38:40,240
if arm then okay but well we're actually

995
00:38:38,880 --> 00:38:41,119
running the test and ignoring the

996
00:38:40,240 --> 00:38:44,839
results

997
00:38:41,119 --> 00:38:48,160
but not for x86 so but

998
00:38:44,839 --> 00:38:52,160
um there is a test section and

999
00:38:48,160 --> 00:38:55,200
we are encouraged to use it and i think

1000
00:38:52,160 --> 00:38:57,200
some i've not mentioned that but some of

1001
00:38:55,200 --> 00:39:00,560
them we had segfault in the test

1002
00:38:57,200 --> 00:39:03,759
like the tests were run and uh

1003
00:39:00,560 --> 00:39:06,078
this effort and the from my experience

1004
00:39:03,760 --> 00:39:06,880
on working on obscene compiler we don't

1005
00:39:06,079 --> 00:39:08,320
like

1006
00:39:06,880 --> 00:39:10,320
debugging this situation because you

1007
00:39:08,320 --> 00:39:12,400
don't know the tests

1008
00:39:10,320 --> 00:39:13,440
you don't know the actual program and

1009
00:39:12,400 --> 00:39:15,839
that's a pain

1010
00:39:13,440 --> 00:39:17,359
but that's one thing that could be very

1011
00:39:15,839 --> 00:39:23,520
interesting because if

1012
00:39:17,359 --> 00:39:23,520
if clown is miscompiling something

1013
00:39:24,040 --> 00:39:29,839
okay thanks very much

1014
00:39:38,680 --> 00:39:41,680
yep

