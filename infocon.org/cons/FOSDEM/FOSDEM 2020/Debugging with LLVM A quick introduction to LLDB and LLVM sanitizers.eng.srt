1
00:00:05,600 --> 00:00:09,840
okay i'll start now

2
00:00:07,600 --> 00:00:10,879
so thanks very much welcome to this talk

3
00:00:09,840 --> 00:00:13,200
on

4
00:00:10,880 --> 00:00:14,960
debugging with lvm my name is sanjay

5
00:00:13,200 --> 00:00:16,720
this is my colleague graham

6
00:00:14,960 --> 00:00:19,039
and we'll try to showcase technologies

7
00:00:16,720 --> 00:00:22,400
within lvm that will help you with

8
00:00:19,039 --> 00:00:25,519
solving various problems um both graeme

9
00:00:22,400 --> 00:00:28,159
and myself are compiler engineers at arm

10
00:00:25,519 --> 00:00:30,479
we work on the scalable vector extension

11
00:00:28,160 --> 00:00:31,920
support for r64 64.

12
00:00:30,480 --> 00:00:33,760
none of the technologies that we'll be

13
00:00:31,920 --> 00:00:35,760
describing today is something that we

14
00:00:33,760 --> 00:00:37,120
work on it's something that we use on

15
00:00:35,760 --> 00:00:37,920
daily basis something that we're very

16
00:00:37,120 --> 00:00:40,879
fond of

17
00:00:37,920 --> 00:00:42,239
and we feel that it does deserve a bit

18
00:00:40,879 --> 00:00:44,320
more advertising

19
00:00:42,239 --> 00:00:46,559
so this presentation is split into two

20
00:00:44,320 --> 00:00:47,120
parts i will introduce and talk about

21
00:00:46,559 --> 00:00:49,839
ldb

22
00:00:47,120 --> 00:00:51,519
to begin with and then graham will jump

23
00:00:49,840 --> 00:00:55,440
in and he'll introduce you to

24
00:00:51,520 --> 00:00:55,440
lvm sanitizers um

25
00:00:55,760 --> 00:01:00,000
ldb one of the nicest things about ldb

26
00:00:58,399 --> 00:01:01,520
is very compatible with gdb and i think

27
00:01:00,000 --> 00:01:02,879
it's important because a lot of people

28
00:01:01,520 --> 00:01:04,239
are familiar with gdb

29
00:01:02,879 --> 00:01:06,158
and they are concerned about switching

30
00:01:04,239 --> 00:01:08,000
to ldb and this is

31
00:01:06,159 --> 00:01:09,439
apparent when you realize what the

32
00:01:08,000 --> 00:01:12,159
architecture of ldb is

33
00:01:09,439 --> 00:01:13,439
so uppercase ldb is just a sub project

34
00:01:12,159 --> 00:01:15,439
within lvm

35
00:01:13,439 --> 00:01:17,679
now that's a project implements a bunch

36
00:01:15,439 --> 00:01:18,880
of binaries like lowercase ldb lowercase

37
00:01:17,680 --> 00:01:20,799
ldb server

38
00:01:18,880 --> 00:01:22,880
and what happens you as a user you'll be

39
00:01:20,799 --> 00:01:24,640
using ldb typing commands

40
00:01:22,880 --> 00:01:26,720
but behind the scenes it's actually the

41
00:01:24,640 --> 00:01:28,240
ldb server that does all the heavy

42
00:01:26,720 --> 00:01:29,759
lifting like memory reads

43
00:01:28,240 --> 00:01:31,839
memory right register reader is the

44
00:01:29,759 --> 00:01:32,880
right and the two communicate with each

45
00:01:31,840 --> 00:01:35,600
other using the

46
00:01:32,880 --> 00:01:37,520
gdb remote serial protocol which means

47
00:01:35,600 --> 00:01:39,280
that in principle ldb server

48
00:01:37,520 --> 00:01:40,640
implements gdb server and can be a

49
00:01:39,280 --> 00:01:43,040
drop-in replacement for

50
00:01:40,640 --> 00:01:43,759
gdb server and same with ldb in

51
00:01:43,040 --> 00:01:46,000
principle

52
00:01:43,759 --> 00:01:47,439
it works i tried it in certain scenarios

53
00:01:46,000 --> 00:01:49,040
but obviously there will be some clashes

54
00:01:47,439 --> 00:01:50,559
but still i think

55
00:01:49,040 --> 00:01:52,000
it's fairly obvious that they try to

56
00:01:50,560 --> 00:01:54,320
make it compatible with gdb and i think

57
00:01:52,000 --> 00:01:56,640
that's important

58
00:01:54,320 --> 00:01:58,000
if you're interested in the gdp remote

59
00:01:56,640 --> 00:02:01,439
serial protocol

60
00:01:58,000 --> 00:02:02,560
it's fairly straightforward every packet

61
00:02:01,439 --> 00:02:05,039
starts with a dollar sign

62
00:02:02,560 --> 00:02:06,719
followed by data followed by a hash sign

63
00:02:05,040 --> 00:02:08,560
and a checksum

64
00:02:06,719 --> 00:02:10,478
and now ld actually extends that because

65
00:02:08,560 --> 00:02:12,319
because you can do that and ldb works on

66
00:02:10,479 --> 00:02:14,959
a lot of complex platforms

67
00:02:12,319 --> 00:02:16,480
um but what's interesting from a user

68
00:02:14,959 --> 00:02:18,319
perspective you can use

69
00:02:16,480 --> 00:02:20,319
lock enable gdp remote packets with an

70
00:02:18,319 --> 00:02:22,000
ldb and see all the packets being

71
00:02:20,319 --> 00:02:24,480
exchanged between ld and ldb

72
00:02:22,000 --> 00:02:25,840
server and that can be useful because if

73
00:02:24,480 --> 00:02:27,440
you're on a new platform and something

74
00:02:25,840 --> 00:02:28,800
doesn't work and you're wondering why

75
00:02:27,440 --> 00:02:30,000
then you can use that to see whether

76
00:02:28,800 --> 00:02:30,800
packets are being exchanged and

77
00:02:30,000 --> 00:02:32,160
acknowledged

78
00:02:30,800 --> 00:02:33,840
or if you just want to see how for

79
00:02:32,160 --> 00:02:35,040
instance register being requested and

80
00:02:33,840 --> 00:02:37,360
read

81
00:02:35,040 --> 00:02:40,160
so this can be just a fun thing to use

82
00:02:37,360 --> 00:02:40,879
and in fact ldb has a lot of logging

83
00:02:40,160 --> 00:02:42,640
channels

84
00:02:40,879 --> 00:02:45,040
and you can check them by typing log

85
00:02:42,640 --> 00:02:48,799
list and the list is very long

86
00:02:45,040 --> 00:02:51,920
um and this brings me to a structure

87
00:02:48,800 --> 00:02:53,040
of ldb commands each command is

88
00:02:51,920 --> 00:02:55,440
basically

89
00:02:53,040 --> 00:02:56,319
a noun like breakpoint followed by a

90
00:02:55,440 --> 00:02:58,239
verb like

91
00:02:56,319 --> 00:03:00,079
set followed by a bunch of options

92
00:02:58,239 --> 00:03:02,319
another example is

93
00:03:00,080 --> 00:03:03,360
process launch which basically means

94
00:03:02,319 --> 00:03:06,799
start your

95
00:03:03,360 --> 00:03:08,239
debuggy um these are variables

96
00:03:06,800 --> 00:03:10,080
but they're aliases so you don't have to

97
00:03:08,239 --> 00:03:11,040
worry about it and i'll show show some

98
00:03:10,080 --> 00:03:12,239
examples

99
00:03:11,040 --> 00:03:13,599
if you stuck and you don't know what

100
00:03:12,239 --> 00:03:14,800
you're looking for or you don't know

101
00:03:13,599 --> 00:03:15,840
where to start you can just type a

102
00:03:14,800 --> 00:03:17,440
proper and a keyword

103
00:03:15,840 --> 00:03:19,200
and keyword doesn't have to be a command

104
00:03:17,440 --> 00:03:21,840
it has can be something

105
00:03:19,200 --> 00:03:23,359
just fairly random and ldb will display

106
00:03:21,840 --> 00:03:25,280
your list of help pages

107
00:03:23,360 --> 00:03:27,440
with relevant info and then you can look

108
00:03:25,280 --> 00:03:28,799
to a corresponding help page

109
00:03:27,440 --> 00:03:32,319
but i think it's much more interesting

110
00:03:28,799 --> 00:03:32,319
to see this stuff in action

111
00:03:32,400 --> 00:03:39,280
so i have a few examples

112
00:03:36,239 --> 00:03:39,280
the first one is

113
00:03:40,480 --> 00:03:45,040
it's not complex it's basically a main

114
00:03:43,519 --> 00:03:48,480
function that

115
00:03:45,040 --> 00:03:49,280
declares a array of names andre graham

116
00:03:48,480 --> 00:03:50,480
and jay graham

117
00:03:49,280 --> 00:03:52,159
and looks over all the names and

118
00:03:50,480 --> 00:03:53,679
displays either hello and j or goodbye

119
00:03:52,159 --> 00:03:57,679
graham depending which name it sees

120
00:03:53,680 --> 00:03:57,680
or i am confused if it sees something

121
00:03:58,840 --> 00:04:03,599
else

122
00:04:00,400 --> 00:04:07,840
if i now build it oh uh

123
00:04:03,599 --> 00:04:07,839
sorry uh

124
00:04:10,000 --> 00:04:17,839
uh ldb uh

125
00:04:14,640 --> 00:04:17,839
ldb example

126
00:04:19,918 --> 00:04:31,680
yes sorry

127
00:04:28,639 --> 00:04:33,759
sorry for that uh so yeah it goes and

128
00:04:31,680 --> 00:04:34,880
hello nj goodbye graham because that's

129
00:04:33,759 --> 00:04:38,080
what's implemented

130
00:04:34,880 --> 00:04:40,560
now if you run it in ldb excuse me

131
00:04:38,080 --> 00:04:42,000
yes when you type an ldb command could

132
00:04:40,560 --> 00:04:43,440
you always say what you're typing

133
00:04:42,000 --> 00:04:45,199
because i don't see it i'm only

134
00:04:43,440 --> 00:04:48,320
interested in the lgb commands

135
00:04:45,199 --> 00:04:52,160
yes so i'm starting ldb

136
00:04:48,320 --> 00:04:56,159
and i'm typing breakpoint set

137
00:04:52,160 --> 00:04:57,600
dash n main i don't need that uh so

138
00:04:56,160 --> 00:04:58,639
that's the variables way of setting a

139
00:04:57,600 --> 00:05:02,400
breakpoint

140
00:04:58,639 --> 00:05:02,400
i'm setting a breakpoint uh

141
00:05:03,680 --> 00:05:08,000
i'm running my process and it's

142
00:05:06,240 --> 00:05:12,160
displaying the assembly

143
00:05:08,000 --> 00:05:15,280
which is not what i wanted uh

144
00:05:12,160 --> 00:05:18,960
because i didn't build the debugger info

145
00:05:15,280 --> 00:05:21,039
so let's do that again and

146
00:05:18,960 --> 00:05:23,198
okay and immediately you see how nice

147
00:05:21,039 --> 00:05:25,039
ldb is because it displays you

148
00:05:23,199 --> 00:05:27,039
the source code with the surrounding

149
00:05:25,039 --> 00:05:28,000
context it highlights where you hit the

150
00:05:27,039 --> 00:05:30,880
breakpoint

151
00:05:28,000 --> 00:05:32,320
including raw and column which is which

152
00:05:30,880 --> 00:05:34,320
is useful because sometimes you can have

153
00:05:32,320 --> 00:05:37,280
multiple expression in one column

154
00:05:34,320 --> 00:05:38,400
um and now if i just step through and

155
00:05:37,280 --> 00:05:41,280
i'm typing n

156
00:05:38,400 --> 00:05:43,198
in ldb which is an alias for stepping

157
00:05:41,280 --> 00:05:45,840
over which is

158
00:05:43,199 --> 00:05:46,639
compatible with gdb it redisplays the

159
00:05:45,840 --> 00:05:48,719
same stuff

160
00:05:46,639 --> 00:05:49,919
and highlights where exactly on which

161
00:05:48,720 --> 00:05:53,039
line you're stopping

162
00:05:49,919 --> 00:05:53,520
now but what i really like about ldb is

163
00:05:53,039 --> 00:05:57,039
the

164
00:05:53,520 --> 00:05:57,039
expression evaluation engine

165
00:05:57,120 --> 00:06:01,759
and you can basically type any c plus

166
00:05:59,840 --> 00:06:05,198
plus

167
00:06:01,759 --> 00:06:08,639
modern c code that you want so

168
00:06:05,199 --> 00:06:11,280
now i'm overwriting the contents of the

169
00:06:08,639 --> 00:06:12,000
uh character array so i'm just typing

170
00:06:11,280 --> 00:06:14,159
express

171
00:06:12,000 --> 00:06:15,600
x for expression and then you type your

172
00:06:14,160 --> 00:06:18,319
c plus plus

173
00:06:15,600 --> 00:06:19,520
expression uh in this case for auto name

174
00:06:18,319 --> 00:06:21,440
and names

175
00:06:19,520 --> 00:06:24,479
name set to pinky which is just random

176
00:06:21,440 --> 00:06:24,479
name and now

177
00:06:27,360 --> 00:06:32,319
oops you can see that

178
00:06:30,479 --> 00:06:33,758
it has overwritten it so it jitted the

179
00:06:32,319 --> 00:06:34,160
code and it did something behind the

180
00:06:33,759 --> 00:06:37,039
scenes

181
00:06:34,160 --> 00:06:38,160
and now it's changed and if i continue

182
00:06:37,039 --> 00:06:40,159
it's confused

183
00:06:38,160 --> 00:06:42,080
which is fantastic because sometimes and

184
00:06:40,160 --> 00:06:43,919
i do it all the time you might be

185
00:06:42,080 --> 00:06:45,599
tricked into okay i'm gonna modify my

186
00:06:43,919 --> 00:06:46,960
source code recompile rerun and the

187
00:06:45,600 --> 00:06:49,599
debugger and see what happens

188
00:06:46,960 --> 00:06:50,479
you don't have to do that ldb leverages

189
00:06:49,599 --> 00:06:52,639
lip clank

190
00:06:50,479 --> 00:06:53,919
and has very access to very powerful jit

191
00:06:52,639 --> 00:06:59,120
so you can do stuff like that

192
00:06:53,919 --> 00:06:59,120
uh live um

193
00:06:59,199 --> 00:07:06,000
but let's try another example

194
00:07:02,560 --> 00:07:07,280
uh this one uh the source is not very

195
00:07:06,000 --> 00:07:08,000
important so i'm trying a different

196
00:07:07,280 --> 00:07:10,318
example this

197
00:07:08,000 --> 00:07:11,759
implements a multi-threaded very simple

198
00:07:10,319 --> 00:07:15,360
multi-threaded

199
00:07:11,759 --> 00:07:15,360
increment of three numbers so

200
00:07:15,759 --> 00:07:19,919
it increments x y and z to some very big

201
00:07:18,080 --> 00:07:24,400
value

202
00:07:19,919 --> 00:07:27,520
and it does so in three frets if i do it

203
00:07:24,400 --> 00:07:29,280
if you look look at it in ldb so

204
00:07:27,520 --> 00:07:30,479
this time i'm using just b to set the

205
00:07:29,280 --> 00:07:31,758
breakpoint because there's an alias i

206
00:07:30,479 --> 00:07:33,919
don't have to do breakpoint set

207
00:07:31,759 --> 00:07:34,960
b is fine so that's something you know

208
00:07:33,919 --> 00:07:38,880
from ldb

209
00:07:34,960 --> 00:07:39,599
gdb and i'm setting a breakpoint on

210
00:07:38,880 --> 00:07:41,280
function and

211
00:07:39,599 --> 00:07:43,280
x because i know i implemented the five

212
00:07:41,280 --> 00:07:44,638
so i know it's one of the methods that's

213
00:07:43,280 --> 00:07:48,159
executed in

214
00:07:44,639 --> 00:07:48,160
parallel that does the increment

215
00:07:48,400 --> 00:07:52,159
and again it displays the relevant code

216
00:07:50,319 --> 00:07:53,759
it doesn't fit on the screen

217
00:07:52,160 --> 00:07:56,479
but you can see the breakpoint is being

218
00:07:53,759 --> 00:07:56,479
hit over there

219
00:07:56,639 --> 00:07:59,599
and because this is multi-threaded i

220
00:07:58,160 --> 00:08:00,240
know there will be multiple threads

221
00:07:59,599 --> 00:08:03,840
stopped

222
00:08:00,240 --> 00:08:05,919
so i'm typing thread list

223
00:08:03,840 --> 00:08:07,520
and indeed there are three frets but i

224
00:08:05,919 --> 00:08:08,960
want to know what's happening with these

225
00:08:07,520 --> 00:08:10,719
three threads

226
00:08:08,960 --> 00:08:12,239
and for that i think it's really nice to

227
00:08:10,720 --> 00:08:14,400
actually use

228
00:08:12,240 --> 00:08:16,800
gui which is graphical user interface so

229
00:08:14,400 --> 00:08:20,400
i'm typing gy in ldb

230
00:08:16,800 --> 00:08:22,080
and it takes you here and you get this

231
00:08:20,400 --> 00:08:25,198
for free out of the box and it just

232
00:08:22,080 --> 00:08:26,318
works main window is your source

233
00:08:25,199 --> 00:08:28,639
and highlights where you hit your

234
00:08:26,319 --> 00:08:28,960
breakpoint your variables are displayed

235
00:08:28,639 --> 00:08:31,039
here

236
00:08:28,960 --> 00:08:32,799
from the current frame and there's a

237
00:08:31,039 --> 00:08:34,799
process and that one

238
00:08:32,799 --> 00:08:36,000
is the most interesting one because you

239
00:08:34,799 --> 00:08:39,120
can expand it

240
00:08:36,000 --> 00:08:40,799
and you have three frets all fine

241
00:08:39,120 --> 00:08:42,399
and then you can jump between the

242
00:08:40,799 --> 00:08:43,598
threads and it shows you exactly where

243
00:08:42,399 --> 00:08:46,080
in each fret you are

244
00:08:43,599 --> 00:08:46,800
and you can also go over different

245
00:08:46,080 --> 00:08:48,480
frames

246
00:08:46,800 --> 00:08:51,760
within each fret which i think is

247
00:08:48,480 --> 00:08:51,760
fantastic and really useful

248
00:08:53,279 --> 00:08:56,160
another feature

249
00:08:58,160 --> 00:09:02,000
is embedded python temperature so you

250
00:09:00,560 --> 00:09:03,839
just type script

251
00:09:02,000 --> 00:09:05,120
and you enter a python interpreter

252
00:09:03,839 --> 00:09:08,399
inside your debugger

253
00:09:05,120 --> 00:09:11,360
and and you can type anything

254
00:09:08,399 --> 00:09:12,240
basically you know from python what i'll

255
00:09:11,360 --> 00:09:15,200
show you is

256
00:09:12,240 --> 00:09:16,160
an example of using ldb python bindings

257
00:09:15,200 --> 00:09:19,360
uh

258
00:09:16,160 --> 00:09:19,360
so you can do something like

259
00:09:19,600 --> 00:09:24,080
so i'm typing print ldb target get

260
00:09:22,240 --> 00:09:26,080
triple

261
00:09:24,080 --> 00:09:27,279
and if you're familiar with lvm you'll

262
00:09:26,080 --> 00:09:29,760
know that triple

263
00:09:27,279 --> 00:09:31,600
is something that lvm uses internally to

264
00:09:29,760 --> 00:09:34,160
describe the platform you on

265
00:09:31,600 --> 00:09:35,600
so i'm just printing that using ldb's

266
00:09:34,160 --> 00:09:38,800
python bindings

267
00:09:35,600 --> 00:09:40,640
and it's x86 64 mac os

268
00:09:38,800 --> 00:09:43,199
there's many more there's many many many

269
00:09:40,640 --> 00:09:46,800
male and

270
00:09:43,200 --> 00:09:48,320
and as a matter of fact you can use

271
00:09:46,800 --> 00:09:51,839
those python bindings to script your

272
00:09:48,320 --> 00:09:51,839
debugger and extend it

273
00:09:53,680 --> 00:09:59,760
and in order to present that

274
00:09:56,800 --> 00:10:01,680
i will use a i have a hobby project

275
00:09:59,760 --> 00:10:03,760
called lvm tutor it's a collection

276
00:10:01,680 --> 00:10:05,439
of passes and if you're familiar with

277
00:10:03,760 --> 00:10:06,880
lvm passes you'll know that each one

278
00:10:05,440 --> 00:10:08,399
implements this run method

279
00:10:06,880 --> 00:10:10,320
but it's either run on module run on

280
00:10:08,399 --> 00:10:11,760
basic block random function run

281
00:10:10,320 --> 00:10:13,920
and then you have the new pass manager

282
00:10:11,760 --> 00:10:14,720
old pass manager and if something breaks

283
00:10:13,920 --> 00:10:17,680
i just want to

284
00:10:14,720 --> 00:10:18,079
start the ldb and hit a breakpoint and

285
00:10:17,680 --> 00:10:19,680
don't

286
00:10:18,079 --> 00:10:21,359
think which method it needs to be i want

287
00:10:19,680 --> 00:10:22,479
to be just like just just set a

288
00:10:21,360 --> 00:10:27,120
breakpoint

289
00:10:22,480 --> 00:10:27,120
um so um

290
00:10:27,200 --> 00:10:29,920
let's try

291
00:10:30,720 --> 00:10:34,320
so i'm starting ldb and this is a long

292
00:10:32,560 --> 00:10:34,959
command but let me just quickly explain

293
00:10:34,320 --> 00:10:37,519
what it does

294
00:10:34,959 --> 00:10:39,119
i'm debugging opt which is lvm's tool

295
00:10:37,519 --> 00:10:40,720
for running passes

296
00:10:39,120 --> 00:10:42,720
implemented in shared objects i'm

297
00:10:40,720 --> 00:10:43,279
loading so i'm specifying which shared

298
00:10:42,720 --> 00:10:45,600
object

299
00:10:43,279 --> 00:10:47,040
i want to load so it's this one and

300
00:10:45,600 --> 00:10:50,079
that's something i implemented

301
00:10:47,040 --> 00:10:51,680
and then just bunch of um uh

302
00:10:50,079 --> 00:10:54,000
options to specify which pass i want to

303
00:10:51,680 --> 00:10:55,680
run so this is a bit complex because i'm

304
00:10:54,000 --> 00:10:56,800
actually debugging opt and my pass is

305
00:10:55,680 --> 00:10:59,599
dynamically loaded

306
00:10:56,800 --> 00:11:02,079
not yet because i haven't started yet

307
00:10:59,600 --> 00:11:04,640
and i'm thinking i will be lucky

308
00:11:02,079 --> 00:11:06,880
so i'm starting break point i'm typing b

309
00:11:04,640 --> 00:11:06,880
run

310
00:11:07,760 --> 00:11:10,959
run on module and i'm thinking i'm being

311
00:11:09,680 --> 00:11:13,040
lucky because

312
00:11:10,959 --> 00:11:14,079
debuggers are clever and it finds 73

313
00:11:13,040 --> 00:11:16,319
locations

314
00:11:14,079 --> 00:11:18,239
makes sense because i'm debugging in

315
00:11:16,320 --> 00:11:19,839
principle opt which belongs to lvm

316
00:11:18,240 --> 00:11:22,560
which has a lot of passes so there'll be

317
00:11:19,839 --> 00:11:25,040
a lot of random module methods

318
00:11:22,560 --> 00:11:26,839
but i know it hasn't found the one that

319
00:11:25,040 --> 00:11:30,880
i'm interested in

320
00:11:26,839 --> 00:11:33,440
because i do image list within ldb

321
00:11:30,880 --> 00:11:34,560
and it tells me which shed objects have

322
00:11:33,440 --> 00:11:36,480
been already loaded

323
00:11:34,560 --> 00:11:38,239
and you have a full list and you can

324
00:11:36,480 --> 00:11:38,640
check the the path hasn't been loaded

325
00:11:38,240 --> 00:11:41,200
yet

326
00:11:38,640 --> 00:11:44,160
because i haven't started opt anyway i'm

327
00:11:41,200 --> 00:11:46,640
being naive i'm thinking i'm being lucky

328
00:11:44,160 --> 00:11:47,920
i type run and i hit breakpoint inside

329
00:11:46,640 --> 00:11:50,319
my pass

330
00:11:47,920 --> 00:11:50,959
so automatically behind the scenes what

331
00:11:50,320 --> 00:11:53,600
happened

332
00:11:50,959 --> 00:11:55,359
opt started running it loaded the pass

333
00:11:53,600 --> 00:11:58,399
the shared object at some point

334
00:11:55,360 --> 00:12:00,000
ldb notices that and goes right you're

335
00:11:58,399 --> 00:12:02,160
loading some new objects

336
00:12:00,000 --> 00:12:03,839
earlier you requested some breakpoints

337
00:12:02,160 --> 00:12:05,279
i'm going to investigate this new object

338
00:12:03,839 --> 00:12:06,399
and see maybe i can set a breakpoint in

339
00:12:05,279 --> 00:12:09,040
that object

340
00:12:06,399 --> 00:12:10,399
and there you go and it just works

341
00:12:09,040 --> 00:12:12,079
fantastically behind the scenes

342
00:12:10,399 --> 00:12:14,160
now you may be taking this for granted

343
00:12:12,079 --> 00:12:16,399
but a few years ago stuff like this

344
00:12:14,160 --> 00:12:17,519
didn't work and it's quite impressive

345
00:12:16,399 --> 00:12:21,440
that it just

346
00:12:17,519 --> 00:12:24,800
happens to work but

347
00:12:21,440 --> 00:12:27,360
this worked and

348
00:12:24,800 --> 00:12:28,800
that was just one pass now i'm doing

349
00:12:27,360 --> 00:12:29,920
exactly the same thing but with a

350
00:12:28,800 --> 00:12:31,839
different pass

351
00:12:29,920 --> 00:12:33,199
so it's just a different shared object

352
00:12:31,839 --> 00:12:34,000
and different command line options but

353
00:12:33,200 --> 00:12:38,480
otherwise

354
00:12:34,000 --> 00:12:40,959
i'm doing the same thing so

355
00:12:38,480 --> 00:12:43,120
run on module exactly same exercise

356
00:12:40,959 --> 00:12:46,160
found 73 locations

357
00:12:43,120 --> 00:12:46,720
and run and it's not hitting the

358
00:12:46,160 --> 00:12:48,560
breakpoint

359
00:12:46,720 --> 00:12:50,639
the pass runs displays the output from

360
00:12:48,560 --> 00:12:52,479
the pass but the breakpoint wasn't hit

361
00:12:50,639 --> 00:12:54,399
because the method this time is not run

362
00:12:52,480 --> 00:12:56,880
on module

363
00:12:54,399 --> 00:12:56,880
however

364
00:12:57,600 --> 00:13:00,720
i have this method that i implemented in

365
00:13:00,079 --> 00:13:02,479
python

366
00:13:00,720 --> 00:13:04,079
which is not complicated called lgm

367
00:13:02,480 --> 00:13:06,560
tutor because that's my project

368
00:13:04,079 --> 00:13:07,680
and that simply passes the command line

369
00:13:06,560 --> 00:13:09,920
that i passed to ldb

370
00:13:07,680 --> 00:13:12,079
it has access to that via ldb python

371
00:13:09,920 --> 00:13:14,000
bindings it's not not really magic

372
00:13:12,079 --> 00:13:15,680
and it identifies okay you load it

373
00:13:14,000 --> 00:13:17,600
hellowelt and it knows that because it

374
00:13:15,680 --> 00:13:19,839
just checks the name of the file

375
00:13:17,600 --> 00:13:21,360
and sets a breakpoint accordingly and it

376
00:13:19,839 --> 00:13:22,399
knows where to set it because i told it

377
00:13:21,360 --> 00:13:25,600
i have a

378
00:13:22,399 --> 00:13:28,880
map of pass and which method to stop on

379
00:13:25,600 --> 00:13:31,920
so if i now type run it again

380
00:13:28,880 --> 00:13:36,560
automatically set the breakpoint and

381
00:13:31,920 --> 00:13:40,719
it hit it and you can do a lot of

382
00:13:36,560 --> 00:13:42,239
things like oh sorry i removed this one

383
00:13:40,720 --> 00:13:45,760
but let me show you how i implemented

384
00:13:42,240 --> 00:13:45,760
that that method

385
00:13:45,920 --> 00:13:49,839
so there's two steps

386
00:13:50,639 --> 00:13:57,519
uh the first step is dot ldb init file

387
00:13:54,800 --> 00:13:58,800
that's loaded when you start ldb and it

388
00:13:57,519 --> 00:14:00,639
has just a bunch of things that you want

389
00:13:58,800 --> 00:14:03,040
to do whenever you start lb

390
00:14:00,639 --> 00:14:03,680
first the commands it's settings set

391
00:14:03,040 --> 00:14:06,079
again

392
00:14:03,680 --> 00:14:07,040
a noun followed by a verb and it just

393
00:14:06,079 --> 00:14:09,439
says display

394
00:14:07,040 --> 00:14:10,719
20 lines of code around where you hit

395
00:14:09,440 --> 00:14:12,560
the breakpoint or where you stop

396
00:14:10,720 --> 00:14:14,079
so that's the setting i use on my on my

397
00:14:12,560 --> 00:14:16,638
computer and

398
00:14:14,079 --> 00:14:17,680
the other thing is comment script import

399
00:14:16,639 --> 00:14:20,399
command store pi

400
00:14:17,680 --> 00:14:21,359
so this basically says take that file

401
00:14:20,399 --> 00:14:23,440
and load it

402
00:14:21,360 --> 00:14:25,120
uh and finally on this line i'm just

403
00:14:23,440 --> 00:14:25,680
saying take the file that you just

404
00:14:25,120 --> 00:14:27,839
loaded

405
00:14:25,680 --> 00:14:29,120
take method that implements my custom

406
00:14:27,839 --> 00:14:31,680
command and

407
00:14:29,120 --> 00:14:34,160
alias it as lvm tutor and that's it

408
00:14:31,680 --> 00:14:34,160
that's done

409
00:14:35,199 --> 00:14:40,560
and that's more or less

410
00:14:40,800 --> 00:14:47,439
what i had on the ldb this is

411
00:14:44,000 --> 00:14:49,760
uh a few aliases available with an led

412
00:14:47,440 --> 00:14:51,360
but i actually copied some of them from

413
00:14:49,760 --> 00:14:53,040
official documentation of ldp

414
00:14:51,360 --> 00:14:55,120
i recommend you go there the list is

415
00:14:53,040 --> 00:14:58,480
very long and there's a lot of

416
00:14:55,120 --> 00:15:00,079
aliases like this um i show the

417
00:14:58,480 --> 00:15:03,040
expression evaluation engine

418
00:15:00,079 --> 00:15:03,439
uh we talked about python interpreter

419
00:15:03,040 --> 00:15:06,800
and

420
00:15:03,440 --> 00:15:09,680
implementing custom commands now

421
00:15:06,800 --> 00:15:11,199
uh there's a few lengths so ldp tutorial

422
00:15:09,680 --> 00:15:13,760
available on the official

423
00:15:11,199 --> 00:15:14,719
page of ldb is amazing there's a lot of

424
00:15:13,760 --> 00:15:17,120
examples

425
00:15:14,720 --> 00:15:18,639
and it's written very very well so i

426
00:15:17,120 --> 00:15:22,240
recommend visiting that and

427
00:15:18,639 --> 00:15:23,680
uh and trying to follow the examples

428
00:15:22,240 --> 00:15:25,920
gdbrsp

429
00:15:23,680 --> 00:15:27,599
protocol was really really really well

430
00:15:25,920 --> 00:15:30,639
described

431
00:15:27,600 --> 00:15:31,600
uh over that and if you're interested in

432
00:15:30,639 --> 00:15:33,759
my examples

433
00:15:31,600 --> 00:15:35,120
then you can also look at them now

434
00:15:33,759 --> 00:15:38,240
there's a lot of things

435
00:15:35,120 --> 00:15:40,720
that you cannot do with a debugger

436
00:15:38,240 --> 00:15:42,000
and you can deal with them using a

437
00:15:40,720 --> 00:15:55,839
sanitizer and that's something that

438
00:15:42,000 --> 00:15:55,839
graham will talk about

439
00:16:15,120 --> 00:16:23,120
okay right

440
00:16:18,720 --> 00:16:27,440
so what is a sanitizer

441
00:16:23,120 --> 00:16:30,480
it's a feature in lvm and gcc as well

442
00:16:27,440 --> 00:16:33,279
uh that allows you to build your program

443
00:16:30,480 --> 00:16:34,880
with additional instrumentation code

444
00:16:33,279 --> 00:16:37,199
that helps you find bugs that you didn't

445
00:16:34,880 --> 00:16:39,920
know were there

446
00:16:37,199 --> 00:16:41,040
and it's pretty easy to start using in

447
00:16:39,920 --> 00:16:43,839
that you just need to

448
00:16:41,040 --> 00:16:44,639
have this extra command flag on your

449
00:16:43,839 --> 00:16:47,279
compile line

450
00:16:44,639 --> 00:16:49,120
of sanitize equals and then the name of

451
00:16:47,279 --> 00:16:50,880
the sanitizer

452
00:16:49,120 --> 00:16:52,800
and there's several sanitizers available

453
00:16:50,880 --> 00:16:56,079
for things like

454
00:16:52,800 --> 00:16:57,439
figuring out whether you've come up with

455
00:16:56,079 --> 00:17:00,560
an invalid memory address

456
00:16:57,440 --> 00:17:02,639
and tried to de-reference it or

457
00:17:00,560 --> 00:17:05,280
if you've invoked some undefined

458
00:17:02,639 --> 00:17:07,679
behavior from c

459
00:17:05,280 --> 00:17:08,799
and it performs this instrumentation by

460
00:17:07,679 --> 00:17:10,880
wrapping

461
00:17:08,799 --> 00:17:13,199
key operations within your program so

462
00:17:10,880 --> 00:17:16,160
things like loads and stores

463
00:17:13,199 --> 00:17:17,360
it will call off to an internal routine

464
00:17:16,160 --> 00:17:20,799
that it's linked to

465
00:17:17,359 --> 00:17:24,319
and build up a map of memory

466
00:17:20,799 --> 00:17:26,879
showing which addresses are valid and

467
00:17:24,319 --> 00:17:29,760
generating a log of where a piece of

468
00:17:26,880 --> 00:17:29,760
memory came from

469
00:17:30,720 --> 00:17:34,880
if you run top when you are executing

470
00:17:33,360 --> 00:17:37,600
one of these you will often see

471
00:17:34,880 --> 00:17:38,720
something like a virtual memory size of

472
00:17:37,600 --> 00:17:40,959
20 terabytes

473
00:17:38,720 --> 00:17:43,440
which looks a little alarming at first

474
00:17:40,960 --> 00:17:45,280
but it's not really that big

475
00:17:43,440 --> 00:17:48,000
it does have an overheads of somewhere

476
00:17:45,280 --> 00:17:50,960
between three and 15 times

477
00:17:48,000 --> 00:17:52,480
space wise depending on what which

478
00:17:50,960 --> 00:17:54,080
sanitizer you use and which options

479
00:17:52,480 --> 00:17:56,799
you're going to use

480
00:17:54,080 --> 00:17:59,039
but generally it's not that bad unless

481
00:17:56,799 --> 00:18:03,120
you're going to do something like

482
00:17:59,039 --> 00:18:04,480
launch six of the electron apps at once

483
00:18:03,120 --> 00:18:05,520
and have them all instrumented you're

484
00:18:04,480 --> 00:18:07,919
probably not going to run into any

485
00:18:05,520 --> 00:18:07,918
problems

486
00:18:08,480 --> 00:18:12,960
there's behavior that's tunable when you

487
00:18:11,760 --> 00:18:16,320
encounter an error

488
00:18:12,960 --> 00:18:17,919
so the default is to just report that an

489
00:18:16,320 --> 00:18:18,799
error occurred and then keep on going

490
00:18:17,919 --> 00:18:21,200
and

491
00:18:18,799 --> 00:18:24,000
help you make it through depending what

492
00:18:21,200 --> 00:18:27,280
it was you may crash anyway

493
00:18:24,000 --> 00:18:29,039
there's an option if no sanitizer cover

494
00:18:27,280 --> 00:18:31,440
which says no as soon as you see an

495
00:18:29,039 --> 00:18:32,960
error i want to stop

496
00:18:31,440 --> 00:18:34,720
and then if you're just using the

497
00:18:32,960 --> 00:18:36,480
undefined behavior sanitizer

498
00:18:34,720 --> 00:18:38,640
that doesn't need the extra tracking of

499
00:18:36,480 --> 00:18:39,200
memory so you have the option to just

500
00:18:38,640 --> 00:18:40,799
say

501
00:18:39,200 --> 00:18:44,799
plan to trap instruction and i don't

502
00:18:40,799 --> 00:18:44,799
need to link in the compiler runtime

503
00:18:45,440 --> 00:18:50,880
these can be combined to some degree so

504
00:18:48,080 --> 00:18:53,199
if you wanted to

505
00:18:50,880 --> 00:18:54,720
track the whether you'd hit a signed

506
00:18:53,200 --> 00:18:57,760
integer overflow

507
00:18:54,720 --> 00:18:58,799
but then definitely stop if you walked

508
00:18:57,760 --> 00:19:01,840
off the edge of an array

509
00:18:58,799 --> 00:19:03,679
you can do that but

510
00:19:01,840 --> 00:19:05,600
for the address memory and thread

511
00:19:03,679 --> 00:19:06,720
sanitizers they all want to control the

512
00:19:05,600 --> 00:19:09,120
heap and

513
00:19:06,720 --> 00:19:12,160
control all of malik and stuff so you

514
00:19:09,120 --> 00:19:15,918
cannot use them together

515
00:19:12,160 --> 00:19:16,799
uh so let's go into a brief example of

516
00:19:15,919 --> 00:19:20,559
what we can actually

517
00:19:16,799 --> 00:19:24,080
get out of this so i've got a

518
00:19:20,559 --> 00:19:25,520
simple example here over two files and i

519
00:19:24,080 --> 00:19:28,159
suspect a few of you have already seen

520
00:19:25,520 --> 00:19:28,160
what the bug is

521
00:19:28,960 --> 00:19:31,200
but

522
00:19:33,440 --> 00:19:39,840
if i compile this

523
00:19:43,200 --> 00:19:47,600
so we're kind of expecting a zero here

524
00:19:46,559 --> 00:19:49,120
because

525
00:19:47,600 --> 00:19:50,719
we're summing up all the things in the

526
00:19:49,120 --> 00:19:51,039
array all the integers in the array and

527
00:19:50,720 --> 00:19:53,280
we

528
00:19:51,039 --> 00:19:56,160
had initialized them all to zero so

529
00:19:53,280 --> 00:19:56,160
something's gone wrong

530
00:19:56,799 --> 00:20:02,799
if we use the address sanitizer

531
00:20:03,600 --> 00:20:09,678
and rerun it'll now show you that yeah

532
00:20:06,799 --> 00:20:10,400
you've gone off the edge and so what it

533
00:20:09,679 --> 00:20:13,840
shows you

534
00:20:10,400 --> 00:20:18,640
is that you've got a read of size four

535
00:20:13,840 --> 00:20:18,639
so one integer from your my loop

536
00:20:19,039 --> 00:20:23,039
and that memory that mary's closest to

537
00:20:21,919 --> 00:20:26,000
was

538
00:20:23,039 --> 00:20:26,960
just a 40 byte region so your 10

539
00:20:26,000 --> 00:20:30,559
integers times

540
00:20:26,960 --> 00:20:32,320
four bytes um which was allocated in

541
00:20:30,559 --> 00:20:35,360
main

542
00:20:32,320 --> 00:20:36,480
and you've hit the red zone region just

543
00:20:35,360 --> 00:20:40,158
beyond that

544
00:20:36,480 --> 00:20:41,760
so it basically what this simple example

545
00:20:40,159 --> 00:20:44,000
shows is that this isn't just

546
00:20:41,760 --> 00:20:45,919
instrumenting your local code within the

547
00:20:44,000 --> 00:20:49,360
function this is a global

548
00:20:45,919 --> 00:20:51,280
kind of bounce checking mechanism that

549
00:20:49,360 --> 00:20:52,559
memory that's been allocated in one

550
00:20:51,280 --> 00:20:56,158
thread

551
00:20:52,559 --> 00:20:59,120
can be protected and guarded against

552
00:20:56,159 --> 00:21:00,840
overruns and well in one file can be

553
00:20:59,120 --> 00:21:03,840
protected against overrans in another

554
00:21:00,840 --> 00:21:03,840
file

555
00:21:14,320 --> 00:21:19,120
here is yeah

556
00:21:21,280 --> 00:21:26,960
okay so the address sanitizer

557
00:21:25,280 --> 00:21:28,960
detects how the bounds accesses like

558
00:21:26,960 --> 00:21:30,880
that but it also

559
00:21:28,960 --> 00:21:32,880
picks up use after free or after scope

560
00:21:30,880 --> 00:21:36,320
or double free

561
00:21:32,880 --> 00:21:37,280
on linux um there's a default well it's

562
00:21:36,320 --> 00:21:40,399
on by default

563
00:21:37,280 --> 00:21:41,440
you can detect leaks in your program and

564
00:21:40,400 --> 00:21:44,640
you can also

565
00:21:41,440 --> 00:21:47,600
detect initialization order problem so

566
00:21:44,640 --> 00:21:49,280
if you have init functions for your

567
00:21:47,600 --> 00:21:50,639
various libraries

568
00:21:49,280 --> 00:21:52,158
and they might reference memory that

569
00:21:50,640 --> 00:21:53,600
hasn't been set up yet by another

570
00:21:52,159 --> 00:21:58,559
function in another library it can

571
00:21:53,600 --> 00:22:02,399
detect that kind of problem

572
00:21:58,559 --> 00:22:04,799
so the undefined behavior sanitizer this

573
00:22:02,400 --> 00:22:05,760
a class of behavior within the c

574
00:22:04,799 --> 00:22:09,440
standards

575
00:22:05,760 --> 00:22:09,760
which is not implementation defined so

576
00:22:09,440 --> 00:22:11,520
that

577
00:22:09,760 --> 00:22:13,679
it has a known thing but it depends on

578
00:22:11,520 --> 00:22:16,720
which vendor it's

579
00:22:13,679 --> 00:22:19,760
anything is valid if you do these

580
00:22:16,720 --> 00:22:22,000
cases things like

581
00:22:19,760 --> 00:22:24,480
signed integer overflow is a case of

582
00:22:22,000 --> 00:22:27,440
that and

583
00:22:24,480 --> 00:22:29,840
in theory uh deleting all of your home

584
00:22:27,440 --> 00:22:32,880
directory is a valid response to

585
00:22:29,840 --> 00:22:34,639
trying to run that code in practice the

586
00:22:32,880 --> 00:22:35,520
compiler generally just deletes some big

587
00:22:34,640 --> 00:22:39,520
chunk of your

588
00:22:35,520 --> 00:22:42,000
program and things go subtly wrong

589
00:22:39,520 --> 00:22:42,720
um it can also catch very similar cases

590
00:22:42,000 --> 00:22:45,039
that are not

591
00:22:42,720 --> 00:22:45,840
technically undefined behavior so

592
00:22:45,039 --> 00:22:49,039
unsigned

593
00:22:45,840 --> 00:22:51,840
integer overflow but

594
00:22:49,039 --> 00:22:53,600
nevertheless useful to catch because you

595
00:22:51,840 --> 00:22:55,520
generally don't expect a very large

596
00:22:53,600 --> 00:22:57,120
number to overwrap to a very very small

597
00:22:55,520 --> 00:22:59,760
number or

598
00:22:57,120 --> 00:22:59,760
the opposite

599
00:23:06,840 --> 00:23:09,840
okay

600
00:23:12,320 --> 00:23:16,158
okay so the we were trying to find an

601
00:23:15,440 --> 00:23:19,440
offset

602
00:23:16,159 --> 00:23:23,840
uh between 8 and 32 and

603
00:23:19,440 --> 00:23:23,840
that's not quite correct

604
00:23:34,840 --> 00:23:39,918
but

605
00:23:36,400 --> 00:23:40,400
so in this case i'm showing that there's

606
00:23:39,919 --> 00:23:42,240
an

607
00:23:40,400 --> 00:23:44,080
additional tool beyond just saying if

608
00:23:42,240 --> 00:23:47,039
centerized equals

609
00:23:44,080 --> 00:23:48,639
undefined that you can specify an

610
00:23:47,039 --> 00:23:51,679
additional behavior that it has

611
00:23:48,640 --> 00:23:54,320
just to track that kind of thing

612
00:23:51,679 --> 00:23:56,240
so it's it's a long list of all the

613
00:23:54,320 --> 00:23:58,799
undefined behaviors and

614
00:23:56,240 --> 00:24:00,080
close to undefined but undesirable

615
00:23:58,799 --> 00:24:05,840
behaviors that it will

616
00:24:00,080 --> 00:24:05,840
report to you

617
00:24:10,240 --> 00:24:15,840
okay thread sanitizer

618
00:24:14,159 --> 00:24:19,840
so this is obviously your thing to

619
00:24:15,840 --> 00:24:19,840
report data races

620
00:24:21,039 --> 00:24:33,840
i've got an example for that as well

621
00:24:42,640 --> 00:24:48,640
okay so the thread sanitizer in this

622
00:24:45,520 --> 00:24:52,720
case is reporting that

623
00:24:48,640 --> 00:24:57,760
we had a data race between

624
00:24:52,720 --> 00:25:01,440
uh the threads on ready and on item

625
00:24:57,760 --> 00:25:04,799
in that it will tell you which threads

626
00:25:01,440 --> 00:25:06,159
wrote first which one wrote to it second

627
00:25:04,799 --> 00:25:08,720
and that there's no synchronization

628
00:25:06,159 --> 00:25:08,720
between them

629
00:25:13,440 --> 00:25:17,360
so it catches data races like that and

630
00:25:15,840 --> 00:25:19,520
that includes data races on

631
00:25:17,360 --> 00:25:20,719
mutexes which you'd normally expect to

632
00:25:19,520 --> 00:25:22,480
be okay

633
00:25:20,720 --> 00:25:23,919
because sometimes you might have split

634
00:25:22,480 --> 00:25:25,919
off and then one thread tries to

635
00:25:23,919 --> 00:25:27,520
initialize it but before it's done so

636
00:25:25,919 --> 00:25:29,039
another thread is already trying to lock

637
00:25:27,520 --> 00:25:30,799
it

638
00:25:29,039 --> 00:25:32,240
it catches problems where you're trying

639
00:25:30,799 --> 00:25:34,080
to destroy a mutex

640
00:25:32,240 --> 00:25:35,840
say if it was a scope one while it's

641
00:25:34,080 --> 00:25:39,039
still locked

642
00:25:35,840 --> 00:25:39,918
uh catches problems where a signal

643
00:25:39,039 --> 00:25:42,720
handler

644
00:25:39,919 --> 00:25:45,120
might overwrite erno so if you had an

645
00:25:42,720 --> 00:25:47,520
asynchronous signal come in

646
00:25:45,120 --> 00:25:48,799
you probably don't want it to overwrite

647
00:25:47,520 --> 00:25:52,158
whatever area you've got

648
00:25:48,799 --> 00:25:55,440
coming back from a file open

649
00:25:52,159 --> 00:25:57,039
and in cases where thread sanitizer

650
00:25:55,440 --> 00:25:57,600
doesn't yet understand what it's looking

651
00:25:57,039 --> 00:26:01,200
at

652
00:25:57,600 --> 00:26:02,879
you can help it out a bit so if you were

653
00:26:01,200 --> 00:26:06,000
to use

654
00:26:02,880 --> 00:26:07,600
openmp and you try and run uh that

655
00:26:06,000 --> 00:26:11,039
simple example

656
00:26:07,600 --> 00:26:13,760
and you'd deliberately put in an omp

657
00:26:11,039 --> 00:26:14,320
flush which acts as a fence and

658
00:26:13,760 --> 00:26:15,679
basically

659
00:26:14,320 --> 00:26:17,760
stops everything from crossing that

660
00:26:15,679 --> 00:26:19,679
barrier

661
00:26:17,760 --> 00:26:22,840
threat senator doesn't yet understand

662
00:26:19,679 --> 00:26:25,200
that so you can tell it

663
00:26:22,840 --> 00:26:26,399
that you could use the annotations to

664
00:26:25,200 --> 00:26:28,960
tell it that the the right

665
00:26:26,400 --> 00:26:31,600
to item happened before this flush and

666
00:26:28,960 --> 00:26:34,559
that the right already happened after it

667
00:26:31,600 --> 00:26:35,279
and then similarly in thread two and if

668
00:26:34,559 --> 00:26:36,799
you do that

669
00:26:35,279 --> 00:26:38,799
then it will actually understand what's

670
00:26:36,799 --> 00:26:40,960
going on and say okay that's fine

671
00:26:38,799 --> 00:26:43,600
and keep on hunting from bugs elsewhere

672
00:26:40,960 --> 00:26:43,600
in your program

673
00:26:44,880 --> 00:26:50,480
memory sanitizer this is to pick up

674
00:26:48,320 --> 00:26:52,879
issues where you haven't managed to

675
00:26:50,480 --> 00:26:56,400
initialize a piece of memory so

676
00:26:52,880 --> 00:26:59,520
in this case some old program understood

677
00:26:56,400 --> 00:27:03,520
a couple of command line options

678
00:26:59,520 --> 00:27:05,679
initialized foo in those cases

679
00:27:03,520 --> 00:27:08,480
otherwise didn't bother and then at some

680
00:27:05,679 --> 00:27:09,919
point somebody adds a new flag

681
00:27:08,480 --> 00:27:12,240
and something goes wrong somewhere down

682
00:27:09,919 --> 00:27:12,240
the line

683
00:27:12,720 --> 00:27:16,240
i'd love to show you that one but

684
00:27:14,400 --> 00:27:19,360
unfortunately

685
00:27:16,240 --> 00:27:21,840
that one doesn't work on mac os so it's

686
00:27:19,360 --> 00:27:22,399
linux freebsd or netbsd only at the

687
00:27:21,840 --> 00:27:24,639
moment

688
00:27:22,399 --> 00:27:27,279
uh there might be the other bsds but i

689
00:27:24,640 --> 00:27:30,159
don't think they've been properly tested

690
00:27:27,279 --> 00:27:31,520
uh and similar to the other ones it can

691
00:27:30,159 --> 00:27:34,720
track the origins of memory

692
00:27:31,520 --> 00:27:36,000
so that it knows where it was allocated

693
00:27:34,720 --> 00:27:37,840
and where

694
00:27:36,000 --> 00:27:39,279
it might have been partially initialized

695
00:27:37,840 --> 00:27:41,039
but not all the way

696
00:27:39,279 --> 00:27:43,919
so you get an idea of where you should

697
00:27:41,039 --> 00:27:43,919
focus your attention

698
00:27:44,960 --> 00:27:49,440
so say you've started to use the

699
00:27:47,679 --> 00:27:53,120
sanitizers on your program

700
00:27:49,440 --> 00:27:54,720
but it's just too much overhead

701
00:27:53,120 --> 00:27:55,678
so you've got some really big compute

702
00:27:54,720 --> 00:27:56,880
happening in the middle and you're

703
00:27:55,679 --> 00:28:00,240
pretty sure that that bit's

704
00:27:56,880 --> 00:28:02,080
correct and you want to focus

705
00:28:00,240 --> 00:28:05,200
on finding bugs in things like your

706
00:28:02,080 --> 00:28:08,320
parser because parches usually go wrong

707
00:28:05,200 --> 00:28:08,960
and so you can add an attribute in your

708
00:28:08,320 --> 00:28:11,600
source

709
00:28:08,960 --> 00:28:13,200
of don't touch this one with the address

710
00:28:11,600 --> 00:28:14,480
sanitizer or don't touch it with the

711
00:28:13,200 --> 00:28:18,159
thread sanitizer or something

712
00:28:14,480 --> 00:28:20,799
like that but trying to add

713
00:28:18,159 --> 00:28:21,840
all little attributions all over the

714
00:28:20,799 --> 00:28:24,480
codes as

715
00:28:21,840 --> 00:28:24,959
you find that they're they've hit too

716
00:28:24,480 --> 00:28:28,399
much

717
00:28:24,960 --> 00:28:29,600
cpu time or memory is maybe a bit too

718
00:28:28,399 --> 00:28:31,199
much

719
00:28:29,600 --> 00:28:32,719
and so you can actually just give it a

720
00:28:31,200 --> 00:28:35,200
file and say

721
00:28:32,720 --> 00:28:36,799
for the for this source file i don't

722
00:28:35,200 --> 00:28:39,840
want you to instrument

723
00:28:36,799 --> 00:28:42,840
func one with anything

724
00:28:39,840 --> 00:28:44,158
for this other one i don't want you to

725
00:28:42,840 --> 00:28:47,840
uh

726
00:28:44,159 --> 00:28:50,240
annotate this with the address sanitizer

727
00:28:47,840 --> 00:28:51,360
unfortunately sequels plus names have to

728
00:28:50,240 --> 00:28:55,279
be mangled

729
00:28:51,360 --> 00:28:58,158
so you that's why you got this z9 thing

730
00:28:55,279 --> 00:28:59,679
but it does allow shell wild card of

731
00:28:58,159 --> 00:29:02,799
star to match

732
00:28:59,679 --> 00:29:02,799
everything with that prefix

733
00:29:04,240 --> 00:29:09,039
more info so i have definitely not

734
00:29:06,559 --> 00:29:11,360
covered all this yet

735
00:29:09,039 --> 00:29:13,520
there's a few other useful ones so point

736
00:29:11,360 --> 00:29:16,240
of compare and point and subtract

737
00:29:13,520 --> 00:29:18,000
if you've mallocked two separate objects

738
00:29:16,240 --> 00:29:18,640
and you try and compare pointers on them

739
00:29:18,000 --> 00:29:21,039
that's

740
00:29:18,640 --> 00:29:22,720
undefined because hey they might be

741
00:29:21,039 --> 00:29:24,720
completely different memory spaces you

742
00:29:22,720 --> 00:29:28,320
don't know

743
00:29:24,720 --> 00:29:29,360
control flow integrity if some sneaky

744
00:29:28,320 --> 00:29:31,360
bit of

745
00:29:29,360 --> 00:29:32,879
user data is trying to overwrite your

746
00:29:31,360 --> 00:29:34,639
stack pointers and

747
00:29:32,880 --> 00:29:37,279
get you into a bit of memory you're not

748
00:29:34,640 --> 00:29:41,440
supposed to uh you've got the cfi

749
00:29:37,279 --> 00:29:42,880
to catch that the data flow sanitizer is

750
00:29:41,440 --> 00:29:44,880
a bit of an interesting one because it's

751
00:29:42,880 --> 00:29:48,399
not an automatic one like the others

752
00:29:44,880 --> 00:29:52,080
um in that you have to manually

753
00:29:48,399 --> 00:29:55,360
tag pieces of memory with a name

754
00:29:52,080 --> 00:29:55,840
and then it will keep that tag wherever

755
00:29:55,360 --> 00:29:58,080
that

756
00:29:55,840 --> 00:29:59,520
value goes through memory um and that's

757
00:29:58,080 --> 00:30:02,559
quite interesting to see

758
00:29:59,520 --> 00:30:04,158
whether the age of a debugger

759
00:30:02,559 --> 00:30:07,440
and there's more in the process of being

760
00:30:04,159 --> 00:30:09,039
written so the type sanitizer

761
00:30:07,440 --> 00:30:11,120
is currently under review if anybody

762
00:30:09,039 --> 00:30:12,799
wants to go and look at that

763
00:30:11,120 --> 00:30:14,639
for caching strict aliasing problems

764
00:30:12,799 --> 00:30:17,120
which is yet another class of undefined

765
00:30:14,640 --> 00:30:17,120
behavior

766
00:30:17,760 --> 00:30:22,080
there's the the main clang documentation

767
00:30:20,240 --> 00:30:24,080
site which contains

768
00:30:22,080 --> 00:30:25,439
a lot of useful information on these

769
00:30:24,080 --> 00:30:29,439
sanitizers and how to

770
00:30:25,440 --> 00:30:32,960
invoke them and there's a an older

771
00:30:29,440 --> 00:30:32,960
set of documentation from google

772
00:30:33,440 --> 00:30:37,360
some of it's out of date but it still

773
00:30:34,799 --> 00:30:39,279
contains some useful information

774
00:30:37,360 --> 00:30:41,120
and i have seen people set these things

775
00:30:39,279 --> 00:30:43,200
up in public ci like travis

776
00:30:41,120 --> 00:30:44,719
so that they get you know at least

777
00:30:43,200 --> 00:30:51,200
weekly builds

778
00:30:44,720 --> 00:31:05,840
verifying what they've done

779
00:30:51,200 --> 00:31:05,840
back back

780
00:31:10,480 --> 00:31:16,399
with yeah i'll quickly wrap up with

781
00:31:13,840 --> 00:31:17,439
a one final example because you might be

782
00:31:16,399 --> 00:31:22,000
wondering

783
00:31:17,440 --> 00:31:24,399
right ldb sanitizers it's in a way

784
00:31:22,000 --> 00:31:26,960
connected by a bit orthogonal can you

785
00:31:24,399 --> 00:31:30,879
marry them together

786
00:31:26,960 --> 00:31:34,480
and yes the answer is you can um

787
00:31:30,880 --> 00:31:38,480
so i'll try right

788
00:31:34,480 --> 00:31:42,720
uh that's the wrong directory

789
00:31:38,480 --> 00:31:43,600
yes um very trivial example basically

790
00:31:42,720 --> 00:31:46,399
allocate memory

791
00:31:43,600 --> 00:31:47,918
deallocate memory in f1 f2 and then you

792
00:31:46,399 --> 00:31:52,239
try to write to that memory

793
00:31:47,919 --> 00:31:52,240
after the allocation uh

794
00:31:54,000 --> 00:32:00,720
i don't know that was yeah so

795
00:31:58,320 --> 00:32:01,760
the sanitizer should capture that and it

796
00:32:00,720 --> 00:32:03,519
does

797
00:32:01,760 --> 00:32:04,879
yeah so that's something that graham

798
00:32:03,519 --> 00:32:06,159
showed you um

799
00:32:04,880 --> 00:32:09,120
well it's a slightly different example

800
00:32:06,159 --> 00:32:11,760
but uh the concept is the same now

801
00:32:09,120 --> 00:32:13,760
you want a bit more insight you want to

802
00:32:11,760 --> 00:32:17,440
do it within ldb

803
00:32:13,760 --> 00:32:19,840
so let's start ldb uh i'm typing

804
00:32:17,440 --> 00:32:21,440
dmaine so setting breakpoint on the main

805
00:32:19,840 --> 00:32:25,519
function

806
00:32:21,440 --> 00:32:28,960
run uh i'm stepping over f1 and f2 that

807
00:32:25,519 --> 00:32:28,960
does allocation the allocation

808
00:32:29,919 --> 00:32:33,519
and i hit the point where i'm trying to

809
00:32:32,080 --> 00:32:34,080
put something into the array that has

810
00:32:33,519 --> 00:32:38,399
already been

811
00:32:34,080 --> 00:32:41,519
deallocated and

812
00:32:38,399 --> 00:32:43,840
you type memory history name of the

813
00:32:41,519 --> 00:32:45,519
variable

814
00:32:43,840 --> 00:32:47,360
and it shows you the stuff from the

815
00:32:45,519 --> 00:32:49,279
sanitizer it shows you

816
00:32:47,360 --> 00:32:50,399
well i apologize it's not displayed very

817
00:32:49,279 --> 00:32:51,600
nicely because it doesn't fit on the

818
00:32:50,399 --> 00:32:53,199
screen but basically

819
00:32:51,600 --> 00:32:54,959
it shows you the back trace of

820
00:32:53,200 --> 00:32:56,159
allocation and the allocation

821
00:32:54,960 --> 00:32:58,480
so you have the insight from the

822
00:32:56,159 --> 00:32:59,120
sanitizer within ldb and that's all

823
00:32:58,480 --> 00:33:02,240
wrapped up

824
00:32:59,120 --> 00:33:05,039
into this memory history array you can

825
00:33:02,240 --> 00:33:08,399
have a look what it is

826
00:33:05,039 --> 00:33:08,399
by typing help memory

827
00:33:09,120 --> 00:33:14,559
um history this gives you access to the

828
00:33:12,480 --> 00:33:15,919
address sanitizer you have access to

829
00:33:14,559 --> 00:33:18,720
other sanitizers as well

830
00:33:15,919 --> 00:33:20,240
it's not wrapped up in nice commands but

831
00:33:18,720 --> 00:33:24,240
you have access to that

832
00:33:20,240 --> 00:33:27,360
um and

833
00:33:24,240 --> 00:33:30,640
otherwise um

834
00:33:27,360 --> 00:33:32,158
i think i will just uh finish here so

835
00:33:30,640 --> 00:33:33,840
most of all thank you very much to the

836
00:33:32,159 --> 00:33:35,039
community because this is stuff that the

837
00:33:33,840 --> 00:33:36,879
community has developed

838
00:33:35,039 --> 00:33:38,799
and it's really nice and we can use it

839
00:33:36,880 --> 00:33:41,440
and leverage to be more productive

840
00:33:38,799 --> 00:33:43,279
um we rush through a few things so if

841
00:33:41,440 --> 00:33:45,279
you have questions afterwards obviously

842
00:33:43,279 --> 00:33:46,559
we can have questions now but feel free

843
00:33:45,279 --> 00:33:48,799
to email us with

844
00:33:46,559 --> 00:33:53,840
follow ups and otherwise here thank you

845
00:33:48,799 --> 00:33:53,840
very much

846
00:33:58,159 --> 00:34:02,080
yes so we have around five minutes for

847
00:33:59,760 --> 00:34:02,080
questions

848
00:34:03,200 --> 00:34:06,799
remind me presenters to repeat the

849
00:34:04,880 --> 00:34:10,000
questions

850
00:34:06,799 --> 00:34:10,879
yeah my question would be is i'm just

851
00:34:10,000 --> 00:34:13,440
using the ldp

852
00:34:10,879 --> 00:34:14,719
and uh yeah you know like what would be

853
00:34:13,440 --> 00:34:17,040
your main motivation

854
00:34:14,719 --> 00:34:18,638
to switch for it like the other

855
00:34:17,040 --> 00:34:22,639
additional features would

856
00:34:18,639 --> 00:34:24,159
would prob so the question is uh

857
00:34:22,639 --> 00:34:26,800
what would be the reasons for switching

858
00:34:24,159 --> 00:34:28,960
from gdp to ldb um

859
00:34:26,800 --> 00:34:30,079
that question comes up a lot and my

860
00:34:28,960 --> 00:34:33,679
answer is

861
00:34:30,079 --> 00:34:34,240
um it's best would be best to ask a ldp

862
00:34:33,679 --> 00:34:36,480
developer

863
00:34:34,239 --> 00:34:37,759
my personal take is i don't have such

864
00:34:36,480 --> 00:34:40,000
thing i switch between

865
00:34:37,760 --> 00:34:41,200
gdp and ldb and the way i look at it

866
00:34:40,000 --> 00:34:45,119
they are complementary

867
00:34:41,199 --> 00:34:47,199
if you're on mac os gdb is

868
00:34:45,119 --> 00:34:50,079
well sadly not as well supported as it

869
00:34:47,199 --> 00:34:54,239
could be so you can only use ldb

870
00:34:50,079 --> 00:34:56,240
um ldb by default you have this nine

871
00:34:54,239 --> 00:34:57,279
nice interface that displays you a

872
00:34:56,239 --> 00:35:00,479
context

873
00:34:57,280 --> 00:35:02,160
it leverages lip clank so you have c

874
00:35:00,480 --> 00:35:03,760
plus plus expression evaluation

875
00:35:02,160 --> 00:35:05,520
out of the box and whenever something

876
00:35:03,760 --> 00:35:06,240
comes in at c plus plus you get it

877
00:35:05,520 --> 00:35:08,880
immediately as

878
00:35:06,240 --> 00:35:10,240
as soon as lvm gets it i don't think you

879
00:35:08,880 --> 00:35:12,640
get that in gdb

880
00:35:10,240 --> 00:35:14,078
also you might be on some exotic target

881
00:35:12,640 --> 00:35:15,359
for which there's only ldp

882
00:35:14,079 --> 00:35:16,000
implementation or you might be on a

883
00:35:15,359 --> 00:35:18,640
target that

884
00:35:16,000 --> 00:35:20,160
has only gdp implementation so i think

885
00:35:18,640 --> 00:35:24,240
uh the way i look at it

886
00:35:20,160 --> 00:35:25,359
it's uh it pays off to know both tools

887
00:35:24,240 --> 00:35:27,839
does it depend on the target

888
00:35:25,359 --> 00:35:27,839
architecture

889
00:35:28,400 --> 00:35:34,880
okay okay but i thought because you have

890
00:35:31,440 --> 00:35:36,160
ldb and uh ldv server gdb and gdp server

891
00:35:34,880 --> 00:35:38,320
architecture

892
00:35:36,160 --> 00:35:39,279
that kind of removes that dependency in

893
00:35:38,320 --> 00:35:41,520
the gdp as well

894
00:35:39,280 --> 00:35:43,200
gdp that's been compiled for 32-bit arm

895
00:35:41,520 --> 00:35:47,280
and then we'll support x86

896
00:35:43,200 --> 00:35:47,279
okay okay yeah

897
00:35:48,160 --> 00:35:53,279
yeah so i'm coming mostly from a gdp

898
00:35:51,359 --> 00:35:55,359
world and one of the problems i have

899
00:35:53,280 --> 00:35:58,400
with gdp is that we have complex

900
00:35:55,359 --> 00:35:59,598
templated code then sometimes gdp has a

901
00:35:58,400 --> 00:36:02,560
very hard time of

902
00:35:59,599 --> 00:36:03,839
like analyzing the variables in the

903
00:36:02,560 --> 00:36:06,078
local stack frame

904
00:36:03,839 --> 00:36:07,920
and most of the time it's not that big

905
00:36:06,079 --> 00:36:08,960
of a deal because for worst case it says

906
00:36:07,920 --> 00:36:11,440
i don't know it

907
00:36:08,960 --> 00:36:13,040
but sometimes it actually starts to hang

908
00:36:11,440 --> 00:36:14,400
and then basically i have to stop the

909
00:36:13,040 --> 00:36:17,599
whole debug session

910
00:36:14,400 --> 00:36:19,599
because gdp just like stops

911
00:36:17,599 --> 00:36:21,839
and so the question would be does that

912
00:36:19,599 --> 00:36:23,520
is led better in that respect i mean i'm

913
00:36:21,839 --> 00:36:25,200
not necessarily talking about

914
00:36:23,520 --> 00:36:27,040
resolving everything but at least not

915
00:36:25,200 --> 00:36:28,720
crashing so i can start to

916
00:36:27,040 --> 00:36:30,720
do a different introspection of the one

917
00:36:28,720 --> 00:36:32,399
i'm currently doing so so i think the

918
00:36:30,720 --> 00:36:34,640
question is

919
00:36:32,400 --> 00:36:37,040
is in certain scenarios they'll be more

920
00:36:34,640 --> 00:36:38,480
stable unreliable than gdb

921
00:36:37,040 --> 00:36:41,680
in particular when you have heavily

922
00:36:38,480 --> 00:36:44,960
templated code

923
00:36:41,680 --> 00:36:48,000
my personal experience uh

924
00:36:44,960 --> 00:36:49,680
i for me both gdb and ldb are are very

925
00:36:48,000 --> 00:36:50,160
stable for what i'm before i've been

926
00:36:49,680 --> 00:36:52,399
using

927
00:36:50,160 --> 00:36:55,040
in the past i admit i was switching

928
00:36:52,400 --> 00:36:57,040
between ld and gdb and ldb was

929
00:36:55,040 --> 00:36:59,200
very flaky but that was three four years

930
00:36:57,040 --> 00:37:00,240
ago i'm using it now on daily basis for

931
00:36:59,200 --> 00:37:03,279
debugging lvm

932
00:37:00,240 --> 00:37:04,959
and it's rock solid i'm really impressed

933
00:37:03,280 --> 00:37:07,040
and the scenario that you're describing

934
00:37:04,960 --> 00:37:10,160
heavily templated code well that's

935
00:37:07,040 --> 00:37:11,920
tricky for debuggers because um because

936
00:37:10,160 --> 00:37:13,680
once stuff is compiled and you request

937
00:37:11,920 --> 00:37:15,599
that template that it's not

938
00:37:13,680 --> 00:37:16,960
it hasn't been instantiated so there's

939
00:37:15,599 --> 00:37:20,079
there's been a

940
00:37:16,960 --> 00:37:21,440
development in el within ldb to actually

941
00:37:20,079 --> 00:37:24,800
make that work better

942
00:37:21,440 --> 00:37:26,720
based on modules and i think uh

943
00:37:24,800 --> 00:37:28,320
patches are being upstreamed well there

944
00:37:26,720 --> 00:37:30,319
was a talk at lvm dev

945
00:37:28,320 --> 00:37:32,079
maybe that something would be relevant

946
00:37:30,320 --> 00:37:34,400
for the scenarios you're describing

947
00:37:32,079 --> 00:37:35,280
but my personal experience they in part

948
00:37:34,400 --> 00:37:38,560
but

949
00:37:35,280 --> 00:37:40,240
maybe my my problem mostly is that if

950
00:37:38,560 --> 00:37:41,839
something just doesn't work because

951
00:37:40,240 --> 00:37:43,680
it just has to do so much and it would

952
00:37:41,839 --> 00:37:46,320
like take three hours to actually

953
00:37:43,680 --> 00:37:47,759
give me yeah yeah yeah i would like to

954
00:37:46,320 --> 00:37:50,960
have some way to say okay forget about

955
00:37:47,760 --> 00:37:50,960
that variable i look at something

956
00:37:58,960 --> 00:38:02,800
i think would be interesting if you

957
00:38:00,720 --> 00:38:06,240
compared and came back

958
00:38:02,800 --> 00:38:06,240
because i'm interested myself

959
00:38:06,640 --> 00:38:10,879
one more question yeah one one more

960
00:38:08,560 --> 00:38:13,759
question

961
00:38:10,880 --> 00:38:13,760
did you find a bug

962
00:38:14,240 --> 00:38:17,680
i heard about something called hardware

963
00:38:15,680 --> 00:38:20,879
a sam his arm helping out

964
00:38:17,680 --> 00:38:23,440
with accelerating

965
00:38:20,880 --> 00:38:24,560
so the question is about uh hardware

966
00:38:23,440 --> 00:38:28,560
sanitizer

967
00:38:24,560 --> 00:38:28,560
and i'll just pause the graham

968
00:38:30,800 --> 00:38:34,079
so there is a hardware assisted

969
00:38:32,400 --> 00:38:35,359
sanitizer that's mostly developed by

970
00:38:34,079 --> 00:38:38,320
google i think we've

971
00:38:35,359 --> 00:38:39,200
arm has contributed a little bit to it

972
00:38:38,320 --> 00:38:40,800
um

973
00:38:39,200 --> 00:38:43,520
but it basically takes advantage of the

974
00:38:40,800 --> 00:38:46,240
fact that arch 64

975
00:38:43,520 --> 00:38:47,280
can reserve the top end bits of a

976
00:38:46,240 --> 00:38:49,759
pointer

977
00:38:47,280 --> 00:38:51,359
for any other purpose and still be able

978
00:38:49,760 --> 00:38:54,400
to use that pointer

979
00:38:51,359 --> 00:38:56,480
as a plain load and store

980
00:38:54,400 --> 00:38:57,440
and i think that's used to save the

981
00:38:56,480 --> 00:39:01,040
address

982
00:38:57,440 --> 00:39:03,920
generation for stack variables

983
00:39:01,040 --> 00:39:05,520
well you also have an upcoming feature

984
00:39:03,920 --> 00:39:08,560
of memory tagging

985
00:39:05,520 --> 00:39:09,200
which should do a lot of what you get in

986
00:39:08,560 --> 00:39:12,320
the

987
00:39:09,200 --> 00:39:15,040
address sanitizer for free by coloring

988
00:39:12,320 --> 00:39:16,880
memory and storing bits of

989
00:39:15,040 --> 00:39:19,279
storing that data what color that memory

990
00:39:16,880 --> 00:39:20,560
is elsewhere in memory

991
00:39:19,280 --> 00:39:24,079
such that the hardware can actually

992
00:39:20,560 --> 00:39:28,279
detect um overruns for you

993
00:39:24,079 --> 00:39:31,859
okay thanks very much

994
00:39:28,280 --> 00:39:31,859
[Applause]

