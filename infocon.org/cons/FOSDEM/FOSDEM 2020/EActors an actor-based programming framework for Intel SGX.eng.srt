1
00:00:05,660 --> 00:00:14,059
my name is Vasily Sirocco and I would

2
00:00:10,050 --> 00:00:14,059
like to present you the actors from work

3
00:00:15,200 --> 00:00:21,060
the first question which I wanted to try

4
00:00:18,480 --> 00:00:23,130
for answer for which I want to try to

5
00:00:21,060 --> 00:00:25,380
find is why do we need another framework

6
00:00:23,130 --> 00:00:33,620
because because a lot of frameworks why

7
00:00:25,380 --> 00:00:35,730
another one so just for the cup

8
00:00:33,620 --> 00:00:37,769
intelligence or for new system

9
00:00:35,730 --> 00:00:39,599
components or calling cliffs in clays

10
00:00:37,769 --> 00:00:42,899
are part of user space applications and

11
00:00:39,600 --> 00:00:45,120
they isolated from the code on data of

12
00:00:42,899 --> 00:00:48,089
enclave's is related from that of adding

13
00:00:45,120 --> 00:00:50,129
clips so an N cliff can let's a call

14
00:00:48,089 --> 00:00:52,409
from an cliff can access data allocated

15
00:00:50,129 --> 00:00:54,269
in ring for inside application but

16
00:00:52,409 --> 00:00:57,690
cannot access dated and code inside

17
00:00:54,269 --> 00:00:59,640
another clip and in place are protected

18
00:00:57,690 --> 00:01:03,860
from a text based on physical access by

19
00:00:59,640 --> 00:01:06,540
the use of encryption of physical memory

20
00:01:03,860 --> 00:01:08,220
removes the P rating system and the

21
00:01:06,540 --> 00:01:10,740
hypervisor from the rustic computing

22
00:01:08,220 --> 00:01:12,658
base and offer very interesting features

23
00:01:10,740 --> 00:01:19,189
like local remote attestation and data

24
00:01:12,659 --> 00:01:22,020
sitting in and more Intel offers

25
00:01:19,189 --> 00:01:24,529
intelligence decays this is decay

26
00:01:22,020 --> 00:01:27,390
provides you necessary primitives to

27
00:01:24,530 --> 00:01:29,610
program in claves and they do this in a

28
00:01:27,390 --> 00:01:32,520
very straightforward and easy way so you

29
00:01:29,610 --> 00:01:34,920
can create a function and decorate it in

30
00:01:32,520 --> 00:01:38,579
a special way then compile this function

31
00:01:34,920 --> 00:01:41,969
together is the intelligence SDK and SDK

32
00:01:38,579 --> 00:01:46,048
generates a binary or multiple binaries

33
00:01:41,969 --> 00:01:51,719
of increase and glue code which allows

34
00:01:46,049 --> 00:01:53,789
to start or deploy enclave's and this is

35
00:01:51,719 --> 00:01:55,798
a very intuitive view so is it just an

36
00:01:53,789 --> 00:02:00,560
LPG like manner of programming of in

37
00:01:55,799 --> 00:02:02,909
class however there is a problem to

38
00:02:00,560 --> 00:02:05,159
enter into an cliff you need to perform

39
00:02:02,909 --> 00:02:07,439
something called alcohol so there are

40
00:02:05,159 --> 00:02:09,060
mechanisms for switching between

41
00:02:07,439 --> 00:02:11,640
untrusted and trusted execution

42
00:02:09,060 --> 00:02:14,250
environments and those transitions are

43
00:02:11,640 --> 00:02:15,720
very very slow compared to ordinary

44
00:02:14,250 --> 00:02:18,060
system called

45
00:02:15,720 --> 00:02:18,560
switching between trusted and untrusted

46
00:02:18,060 --> 00:02:21,020
50

47
00:02:18,560 --> 00:02:23,630
I'm slower and more than 50 times slow

48
00:02:21,020 --> 00:02:25,670
it's only for the beginning and you will

49
00:02:23,630 --> 00:02:29,540
need to leave your enclaved very very

50
00:02:25,670 --> 00:02:31,579
soon because inside and clave you cannot

51
00:02:29,540 --> 00:02:33,290
directly interact with the kernel so if

52
00:02:31,580 --> 00:02:35,450
you want to interact with the kernel or

53
00:02:33,290 --> 00:02:37,040
use the function which is not located

54
00:02:35,450 --> 00:02:39,920
inside a nuclear you need to leave this

55
00:02:37,040 --> 00:02:41,630
in code again 50 times slower for

56
00:02:39,920 --> 00:02:43,190
example you have two threads those two

57
00:02:41,630 --> 00:02:45,560
threads need to pass a critical section

58
00:02:43,190 --> 00:02:47,329
they need to use mutexes mutexes

59
00:02:45,560 --> 00:02:48,950
requires the involvement of the kernel

60
00:02:47,330 --> 00:02:52,360
boss thread needs to leave the in clave

61
00:02:48,950 --> 00:02:54,500
we have more than three 200 times slower

62
00:02:52,360 --> 00:02:57,110
synchronization mechanism compared to

63
00:02:54,500 --> 00:03:01,239
ordinary middle mutexes so it's very

64
00:02:57,110 --> 00:03:05,080
very slow it's a response for this issue

65
00:03:01,239 --> 00:03:08,000
researchers provided several frameworks

66
00:03:05,080 --> 00:03:11,420
frameworks like heavens corn Griffin is

67
00:03:08,000 --> 00:03:13,880
jigs as jig so KL pan apply and maybe

68
00:03:11,420 --> 00:03:17,869
some other so more than five different

69
00:03:13,880 --> 00:03:20,180
frameworks well and they follow same and

70
00:03:17,870 --> 00:03:21,980
different approaches at the same time so

71
00:03:20,180 --> 00:03:24,170
you don't need to leave an end clip if

72
00:03:21,980 --> 00:03:25,250
you can do everything what you need

73
00:03:24,170 --> 00:03:27,440
inside and in clave

74
00:03:25,250 --> 00:03:29,810
so for example you can emulate some

75
00:03:27,440 --> 00:03:31,730
unavailable system calls inside it in

76
00:03:29,810 --> 00:03:35,540
clave and therefore you don't need to

77
00:03:31,730 --> 00:03:37,760
leave them in clay and virus projects

78
00:03:35,540 --> 00:03:40,160
abstract different layers of the

79
00:03:37,760 --> 00:03:44,000
software stack so someone or substract

80
00:03:40,160 --> 00:03:47,239
the leap steve interface another project

81
00:03:44,000 --> 00:03:50,079
abstract the whole deck let's say in the

82
00:03:47,239 --> 00:03:52,220
kernel interface but conceptually

83
00:03:50,079 --> 00:03:56,780
conceptually those frameworks have

84
00:03:52,220 --> 00:03:58,670
problem it's a monolithic design with a

85
00:03:56,780 --> 00:04:00,799
lot of these a very huge drastic

86
00:03:58,670 --> 00:04:02,888
computing base so this is the kind of

87
00:04:00,799 --> 00:04:05,329
irony you wanted to remove the

88
00:04:02,889 --> 00:04:07,850
complicated kernel from the trusted

89
00:04:05,329 --> 00:04:10,100
computing base but to run your legacy

90
00:04:07,850 --> 00:04:12,049
application you anyway put parts of the

91
00:04:10,100 --> 00:04:17,779
kernel inside this trusted environment

92
00:04:12,049 --> 00:04:21,530
so latch GCV is the problem however

93
00:04:17,779 --> 00:04:23,210
there is another way and a single host a

94
00:04:21,529 --> 00:04:25,250
single process can host multiple

95
00:04:23,210 --> 00:04:28,969
enclaves and this is a very interesting

96
00:04:25,250 --> 00:04:31,670
feature of LG's and clips inside the one

97
00:04:28,970 --> 00:04:33,710
memory in the lated environment you can

98
00:04:31,670 --> 00:04:38,060
multiple and in process you can put

99
00:04:33,710 --> 00:04:40,280
multiple enclave's so your program can

100
00:04:38,060 --> 00:04:42,440
consist of multiple mutually distrusted

101
00:04:40,280 --> 00:04:45,349
components located inside different in

102
00:04:42,440 --> 00:04:48,050
claves what can be what application can

103
00:04:45,350 --> 00:04:50,920
be for example you have a message server

104
00:04:48,050 --> 00:04:54,260
like XMPP server and you want to make

105
00:04:50,920 --> 00:04:55,370
group chats you can put a one group chat

106
00:04:54,260 --> 00:04:57,200
inside one and cliff

107
00:04:55,370 --> 00:04:59,330
another group chat another another in

108
00:04:57,200 --> 00:05:01,460
cliff so they will be protected in in

109
00:04:59,330 --> 00:05:03,830
the case of intrusion this date will be

110
00:05:01,460 --> 00:05:09,250
protected obviously and at the same time

111
00:05:03,830 --> 00:05:12,409
since it's the one single service client

112
00:05:09,250 --> 00:05:15,050
or should have a mechanism for to

113
00:05:12,410 --> 00:05:18,140
interact through in place another

114
00:05:15,050 --> 00:05:19,550
example was considered by people from

115
00:05:18,140 --> 00:05:21,919
Microsoft thank you very nice like that

116
00:05:19,550 --> 00:05:25,280
multi-party computation when you have

117
00:05:21,920 --> 00:05:28,370
multiple mutually distrusted binaries

118
00:05:25,280 --> 00:05:31,989
but those binary so bill which belong to

119
00:05:28,370 --> 00:05:34,820
different owners should perform

120
00:05:31,990 --> 00:05:37,130
mathematical function or find the

121
00:05:34,820 --> 00:05:39,950
consensus or make a decision together

122
00:05:37,130 --> 00:05:42,230
without involved without exposing of

123
00:05:39,950 --> 00:05:45,080
internal values in the simple case you

124
00:05:42,230 --> 00:05:47,720
have several in isolated parties each

125
00:05:45,080 --> 00:05:49,700
party has is located inside a link layer

126
00:05:47,720 --> 00:05:52,820
for example this in clave has a secret

127
00:05:49,700 --> 00:05:56,060
value inside and three parties should

128
00:05:52,820 --> 00:05:58,880
perform a mathematical Sun without in

129
00:05:56,060 --> 00:06:00,530
exposing of urban values so for that

130
00:05:58,880 --> 00:06:01,700
again you need to have multiple in place

131
00:06:00,530 --> 00:06:04,340
you need to have a mechanism for

132
00:06:01,700 --> 00:06:06,740
interaction between them and at the same

133
00:06:04,340 --> 00:06:09,080
time it should be one unique application

134
00:06:06,740 --> 00:06:11,330
but not a distributed set of desolated

135
00:06:09,080 --> 00:06:13,340
or distributed set of different

136
00:06:11,330 --> 00:06:14,570
applications and to implement such

137
00:06:13,340 --> 00:06:16,159
applications you need to have a

138
00:06:14,570 --> 00:06:19,780
programming framework and you need to

139
00:06:16,160 --> 00:06:22,640
have necessary system support and I

140
00:06:19,780 --> 00:06:26,390
think the right way is to do this by the

141
00:06:22,640 --> 00:06:29,210
applying of the actor of the conception

142
00:06:26,390 --> 00:06:31,669
of actors because actors conceptually

143
00:06:29,210 --> 00:06:34,219
are not blocking entities and and

144
00:06:31,670 --> 00:06:36,680
therefore and they follow the conception

145
00:06:34,220 --> 00:06:39,830
of no sharing so you don't need to

146
00:06:36,680 --> 00:06:41,180
involve synchronization primitives so

147
00:06:39,830 --> 00:06:42,590
you don't need to leave an end clave you

148
00:06:41,180 --> 00:06:44,230
don't need to develop mechanism for

149
00:06:42,590 --> 00:06:46,330
synchronization is using the

150
00:06:44,230 --> 00:06:49,600
clave so it's very easy so they don't

151
00:06:46,330 --> 00:06:51,880
use logs in conception they're very

152
00:06:49,600 --> 00:06:54,070
lightweight so it's very nice from the

153
00:06:51,880 --> 00:06:56,920
point of view of another problem related

154
00:06:54,070 --> 00:06:59,230
to ethics in claims it's the EPC problem

155
00:06:56,920 --> 00:07:01,720
so there is a problem of paging if the

156
00:06:59,230 --> 00:07:05,170
size of following claves reaches let's

157
00:07:01,720 --> 00:07:08,560
say near ninety two megabytes so Actos

158
00:07:05,170 --> 00:07:11,080
and of course there are many actor based

159
00:07:08,560 --> 00:07:11,800
systems and the problem that they very

160
00:07:11,080 --> 00:07:14,409
heavy

161
00:07:11,800 --> 00:07:16,810
it's very complicated well it's not very

162
00:07:14,410 --> 00:07:20,170
complicated to pork let's say a long VM

163
00:07:16,810 --> 00:07:22,960
into SGX the question is what our head

164
00:07:20,170 --> 00:07:24,760
view you have if you port this so we we

165
00:07:22,960 --> 00:07:28,330
can use but this very high overhead

166
00:07:24,760 --> 00:07:31,659
everyone Java and conceptually those

167
00:07:28,330 --> 00:07:33,550
frameworks are not tailor it for trusted

168
00:07:31,660 --> 00:07:36,010
execution environment so yes you can run

169
00:07:33,550 --> 00:07:40,240
it but they are not you they they don't

170
00:07:36,010 --> 00:07:41,770
use features of in class and let the

171
00:07:40,240 --> 00:07:43,390
reason why I decide that we need to know

172
00:07:41,770 --> 00:07:47,289
different work and I will present it

173
00:07:43,390 --> 00:07:51,159
today so it's a actors is an actor basic

174
00:07:47,290 --> 00:07:54,280
framework as many other factor basic

175
00:07:51,160 --> 00:07:56,620
frameworks to describe it I will answer

176
00:07:54,280 --> 00:07:59,440
three questions what an actor is what is

177
00:07:56,620 --> 00:08:02,050
an actor how the stock to communicate

178
00:07:59,440 --> 00:08:05,800
and what system support the framework

179
00:08:02,050 --> 00:08:09,760
provides this figure shows a general

180
00:08:05,800 --> 00:08:11,560
view of the actor of of the application

181
00:08:09,760 --> 00:08:15,219
of an application written in this

182
00:08:11,560 --> 00:08:19,840
framework so derived several enclaves

183
00:08:15,220 --> 00:08:22,960
wanting to and there are actors they

184
00:08:19,840 --> 00:08:26,560
colored a actor in the notion of an

185
00:08:22,960 --> 00:08:29,739
actor in this framework so there are

186
00:08:26,560 --> 00:08:31,210
four actors and two actors allocated

187
00:08:29,740 --> 00:08:33,370
inside one in Clips there are doctors

188
00:08:31,210 --> 00:08:36,939
located in another clip and there are

189
00:08:33,370 --> 00:08:39,909
workers workers technically are patriots

190
00:08:36,940 --> 00:08:43,660
physical threats that provide execution

191
00:08:39,909 --> 00:08:45,730
context for actors so actors itself a

192
00:08:43,659 --> 00:08:48,400
passive entities and they can act only

193
00:08:45,730 --> 00:08:51,130
if they have

194
00:08:48,400 --> 00:08:53,890
execution context and there are bindings

195
00:08:51,130 --> 00:08:55,420
between actors and enclaves for example

196
00:08:53,890 --> 00:08:57,270
you see two actors inside this in clave

197
00:08:55,420 --> 00:09:00,160
two actors and said this in clave

198
00:08:57,270 --> 00:09:01,930
workers two CPUs it's the CPU a finicky

199
00:09:00,160 --> 00:09:04,390
you can say that this threat will work

200
00:09:01,930 --> 00:09:05,920
will be attached to this CPU that can be

201
00:09:04,390 --> 00:09:09,490
very useful from the point of view of

202
00:09:05,920 --> 00:09:14,380
performance and intimidation and actors

203
00:09:09,490 --> 00:09:17,650
two workers as I said provokers provide

204
00:09:14,380 --> 00:09:21,970
execution context to create this

205
00:09:17,650 --> 00:09:24,850
application you need to have the

206
00:09:21,970 --> 00:09:30,000
framework the source code of your actors

207
00:09:24,850 --> 00:09:34,060
and the XML file that describes the

208
00:09:30,000 --> 00:09:36,700
deployment scenario itself so they'll be

209
00:09:34,060 --> 00:09:39,310
the number one aim of the framework is

210
00:09:36,700 --> 00:09:41,680
to provide the very simple tools which

211
00:09:39,310 --> 00:09:43,540
help you to build a very flexible

212
00:09:41,680 --> 00:09:45,400
application today for example we wanted

213
00:09:43,540 --> 00:09:47,319
to put all actors inside one and cliff

214
00:09:45,400 --> 00:09:50,020
tomorrow let's say you want to have five

215
00:09:47,320 --> 00:09:52,210
different in clips and the switching

216
00:09:50,020 --> 00:09:55,449
between actors between and clips should

217
00:09:52,210 --> 00:09:58,360
be very very easy from the point of view

218
00:09:55,450 --> 00:10:01,240
of the developer and deployment

219
00:09:58,360 --> 00:10:04,810
scenarios are encoded in or store it

220
00:10:01,240 --> 00:10:09,220
inside an XML while you don't need to

221
00:10:04,810 --> 00:10:11,339
fix the source code of your application

222
00:10:09,220 --> 00:10:15,400
if you want to change the deployment the

223
00:10:11,339 --> 00:10:18,490
framework itself generates binary binary

224
00:10:15,400 --> 00:10:20,800
of enclave's so for example we have five

225
00:10:18,490 --> 00:10:23,830
way enclaves the framework you generate

226
00:10:20,800 --> 00:10:26,979
you five different enclave's and each in

227
00:10:23,830 --> 00:10:29,140
clave you have only use it inside this

228
00:10:26,980 --> 00:10:31,209
in clave our source code of factors so

229
00:10:29,140 --> 00:10:36,699
they very lightweight without the

230
00:10:31,209 --> 00:10:38,500
unnecessary code inside and this is a

231
00:10:36,700 --> 00:10:40,690
very simple application so there is a

232
00:10:38,500 --> 00:10:43,240
constructor for an actor so this

233
00:10:40,690 --> 00:10:48,040
constructor initializes usually

234
00:10:43,240 --> 00:10:50,560
initialize communication interface

235
00:10:48,040 --> 00:10:53,050
between other actors and actors this is

236
00:10:50,560 --> 00:10:55,930
the baldy function of the actor so by

237
00:10:53,050 --> 00:10:58,150
definition an actor can interact with

238
00:10:55,930 --> 00:11:00,498
other actors only by messages so

239
00:10:58,150 --> 00:11:03,019
actually what's going on we

240
00:11:00,499 --> 00:11:06,139
you receive or send message and we will

241
00:11:03,019 --> 00:11:08,299
act with this actor reacts if this actor

242
00:11:06,139 --> 00:11:13,339
receives a message Punk from another

243
00:11:08,299 --> 00:11:15,468
actor question number one how the actor

244
00:11:13,339 --> 00:11:19,219
can interact with each other and they

245
00:11:15,469 --> 00:11:21,469
use nodes it's obstruction which

246
00:11:19,219 --> 00:11:24,469
describes it's a fundamental obstruction

247
00:11:21,469 --> 00:11:26,419
for messaging for messaging so it's

248
00:11:24,469 --> 00:11:28,759
technically it's a part of memory and

249
00:11:26,419 --> 00:11:30,559
this part of memory can be trusted

250
00:11:28,759 --> 00:11:32,889
located inside a net wave or can be

251
00:11:30,559 --> 00:11:35,959
untrusted located outside and then cliff

252
00:11:32,889 --> 00:11:39,379
it consists of two components there is a

253
00:11:35,959 --> 00:11:44,268
header and there is a mode so it

254
00:11:39,379 --> 00:11:46,699
suggests there is payload as memory for

255
00:11:44,269 --> 00:11:48,769
data and with hid or header is used to

256
00:11:46,699 --> 00:11:52,218
include and to include multiple nodes

257
00:11:48,769 --> 00:11:55,609
into queues and all notes allocated at

258
00:11:52,219 --> 00:11:58,399
the start so part of the framework the

259
00:11:55,609 --> 00:12:02,269
framework provides API to deal with

260
00:11:58,399 --> 00:12:06,879
those queues of very obvious W at least

261
00:12:02,269 --> 00:12:10,639
with Lea four and five for interfaces

262
00:12:06,879 --> 00:12:12,999
synchronization of nodes are protected

263
00:12:10,639 --> 00:12:15,649
by the use of have very low collision

264
00:12:12,999 --> 00:12:17,659
it's a very very high performance

265
00:12:15,649 --> 00:12:20,689
synchronization mechanism without any

266
00:12:17,659 --> 00:12:25,479
side effects compared without any side

267
00:12:20,689 --> 00:12:28,699
effects and this primitive can be used

268
00:12:25,479 --> 00:12:31,069
by multi producers and multi consumers

269
00:12:28,699 --> 00:12:32,868
so you just have a queue you have set

270
00:12:31,069 --> 00:12:34,608
the factors that can write to this queue

271
00:12:32,869 --> 00:12:35,319
and set of factors that read from this

272
00:12:34,609 --> 00:12:37,699
queue

273
00:12:35,319 --> 00:12:39,259
let's consider an example we have two

274
00:12:37,699 --> 00:12:41,569
actors pig and pork and they're located

275
00:12:39,259 --> 00:12:43,509
inside different you click to send a

276
00:12:41,569 --> 00:12:47,509
message from and travel to the claves to

277
00:12:43,509 --> 00:12:49,909
the first actor should have access to

278
00:12:47,509 --> 00:12:53,929
pool of empty messages and to inbox

279
00:12:49,909 --> 00:12:58,249
obstruction so firstly pink needs to DQ

280
00:12:53,929 --> 00:13:01,639
an empty node from pool right and after

281
00:12:58,249 --> 00:13:03,619
that the first actor will get exclusive

282
00:13:01,639 --> 00:13:05,269
access to this node no one else can read

283
00:13:03,619 --> 00:13:08,599
and write it and even access to refer

284
00:13:05,269 --> 00:13:11,149
somehow then a cliff can that actor can

285
00:13:08,599 --> 00:13:12,190
write that inside decent life side is

286
00:13:11,149 --> 00:13:15,580
known then

287
00:13:12,190 --> 00:13:17,530
no it must be Hewitt internal inbox so

288
00:13:15,580 --> 00:13:21,250
Dayton and by the way can be encrypted

289
00:13:17,530 --> 00:13:23,620
and unencrypted should be including two

290
00:13:21,250 --> 00:13:26,380
end box at the same time the second

291
00:13:23,620 --> 00:13:29,670
actor tries to DQ messages from the same

292
00:13:26,380 --> 00:13:33,400
inbox and look succeed and will get

293
00:13:29,670 --> 00:13:37,300
success it will get exclusive access

294
00:13:33,400 --> 00:13:40,090
again safely read data inside it and

295
00:13:37,300 --> 00:13:41,949
clave decrypt it if it's necessary and

296
00:13:40,090 --> 00:13:46,540
then it needs to read it need it need

297
00:13:41,950 --> 00:13:50,410
return it needs to return use it note

298
00:13:46,540 --> 00:13:53,110
back to the pool so very simple and this

299
00:13:50,410 --> 00:13:55,209
obstruction can be as I said really can

300
00:13:53,110 --> 00:13:58,180
be used by multi producers and multi

301
00:13:55,210 --> 00:14:00,490
consumers but by default communication

302
00:13:58,180 --> 00:14:02,829
are not encrypted so you mean because

303
00:14:00,490 --> 00:14:05,340
because of multiple reasons and the

304
00:14:02,830 --> 00:14:08,170
flavor provides more complicated

305
00:14:05,340 --> 00:14:11,110
abstractions on top of this very simple

306
00:14:08,170 --> 00:14:14,099
interface those abstractions are called

307
00:14:11,110 --> 00:14:16,870
Carcosa connectors and they provide

308
00:14:14,100 --> 00:14:18,970
encrypted again can be encrypted and

309
00:14:16,870 --> 00:14:21,100
unencrypted with absolutely the same

310
00:14:18,970 --> 00:14:23,230
interface so for example today you have

311
00:14:21,100 --> 00:14:25,330
two actors you places those two actors

312
00:14:23,230 --> 00:14:27,630
inside and in clip and obviously you

313
00:14:25,330 --> 00:14:31,290
don't need to use encryption because

314
00:14:27,630 --> 00:14:34,570
because those actors are protected by

315
00:14:31,290 --> 00:14:36,910
geeks itself so therefore you don't need

316
00:14:34,570 --> 00:14:38,410
to spend time to encrypt it but tomorrow

317
00:14:36,910 --> 00:14:40,329
let's say you want to create two

318
00:14:38,410 --> 00:14:42,160
independent in clips put two different

319
00:14:40,330 --> 00:14:43,840
actor in two different in clips and

320
00:14:42,160 --> 00:14:47,410
obviously you need to have a mechanism

321
00:14:43,840 --> 00:14:49,690
for which you encrypt your messages and

322
00:14:47,410 --> 00:14:51,969
Cardosi connectors offer this

323
00:14:49,690 --> 00:14:54,520
abstraction so with the same source code

324
00:14:51,970 --> 00:14:57,670
just by switching one or two source line

325
00:14:54,520 --> 00:15:00,220
of code you can turn your non encrypted

326
00:14:57,670 --> 00:15:04,270
messages into encrypted messages however

327
00:15:00,220 --> 00:15:06,339
of course there are it's not for free so

328
00:15:04,270 --> 00:15:09,089
this interface can be used only by

329
00:15:06,339 --> 00:15:14,490
single producers single consumer

330
00:15:09,089 --> 00:15:17,110
peer-to-peer form but the framework for

331
00:15:14,490 --> 00:15:19,240
mechanisms for remote for local

332
00:15:17,110 --> 00:15:22,360
attestation using the key exchange

333
00:15:19,240 --> 00:15:24,730
procedure so if you have let's say five

334
00:15:22,360 --> 00:15:25,580
enclaves with five different actors and

335
00:15:24,730 --> 00:15:27,470
those actually

336
00:15:25,580 --> 00:15:30,440
have five in the for let's say

337
00:15:27,470 --> 00:15:33,790
independent communication channels the

338
00:15:30,440 --> 00:15:37,400
framework will generate necessary glue

339
00:15:33,790 --> 00:15:40,370
necessary check sounds which will help

340
00:15:37,400 --> 00:15:46,010
you to establish encrypted connections

341
00:15:40,370 --> 00:15:49,610
by the use of local attestation what

342
00:15:46,010 --> 00:15:53,140
what else the framework offers several

343
00:15:49,610 --> 00:15:57,650
system components because you cannot use

344
00:15:53,140 --> 00:16:00,110
well you shouldn't use equals inside and

345
00:15:57,650 --> 00:16:03,920
in clave and therefore you need to use

346
00:16:00,110 --> 00:16:05,510
messages to get access to system

347
00:16:03,920 --> 00:16:08,920
components that are unavailable inside

348
00:16:05,510 --> 00:16:12,200
and click for that the framework offers

349
00:16:08,920 --> 00:16:13,880
system actors and they are untrusted

350
00:16:12,200 --> 00:16:16,670
they are working outside enclaves and

351
00:16:13,880 --> 00:16:18,650
they interact with all other actors by

352
00:16:16,670 --> 00:16:22,280
the messages because it's an actor based

353
00:16:18,650 --> 00:16:24,530
framework so for example and those

354
00:16:22,280 --> 00:16:26,810
actors implement mechanism so that can

355
00:16:24,530 --> 00:16:29,600
be a system call for read for write for

356
00:16:26,810 --> 00:16:32,239
pipe for interaction this pipe read

357
00:16:29,600 --> 00:16:36,020
write to the file system if you want so

358
00:16:32,240 --> 00:16:38,060
it's just mechanism and then you for

359
00:16:36,020 --> 00:16:39,680
example if you want to open the file you

360
00:16:38,060 --> 00:16:42,770
need to send a message this actor will

361
00:16:39,680 --> 00:16:46,430
perform this mechanism of it will open

362
00:16:42,770 --> 00:16:48,530
the file and send back file descriptor

363
00:16:46,430 --> 00:16:51,770
so the same system actor can be

364
00:16:48,530 --> 00:16:54,800
simultaneously used by multiple other

365
00:16:51,770 --> 00:16:59,810
actors because because it doesn't store

366
00:16:54,800 --> 00:17:02,390
it doesn't have a state another thing so

367
00:16:59,810 --> 00:17:04,819
now we can have access to any hardware

368
00:17:02,390 --> 00:17:09,829
from our in case it is the same

369
00:17:04,819 --> 00:17:16,700
interface and but anyway sometimes you

370
00:17:09,829 --> 00:17:19,010
need to have a mechanism to to don't to

371
00:17:16,700 --> 00:17:21,260
store data inside and in cliff is out

372
00:17:19,010 --> 00:17:25,190
share the statements sound a bit strange

373
00:17:21,260 --> 00:17:27,920
I will explain so conceptual actors

374
00:17:25,190 --> 00:17:31,750
cannot have state and cannot have access

375
00:17:27,920 --> 00:17:34,100
to share it entity but at the same time

376
00:17:31,750 --> 00:17:35,390
instead of saying for example have one

377
00:17:34,100 --> 00:17:39,050
message and you need to send this

378
00:17:35,390 --> 00:17:41,470
message to let's say 5 or 10 actors and

379
00:17:39,050 --> 00:17:44,690
this message is absolutely the same

380
00:17:41,470 --> 00:17:49,280
sending five or ten sequential messages

381
00:17:44,690 --> 00:17:52,810
is inefficient so in in actual basic

382
00:17:49,280 --> 00:17:55,820
framework there is a conception of

383
00:17:52,810 --> 00:17:57,490
object store which is not a store as a

384
00:17:55,820 --> 00:18:01,370
share identity so you might consider

385
00:17:57,490 --> 00:18:03,740
object stall as a set of cues a set of

386
00:18:01,370 --> 00:18:07,070
persistent cues where you put data but

387
00:18:03,740 --> 00:18:09,830
into this queue but this data can be

388
00:18:07,070 --> 00:18:13,280
accessed by or ridden by multiple actors

389
00:18:09,830 --> 00:18:15,710
without without any problems so the

390
00:18:13,280 --> 00:18:18,230
framework offers the Oireachtas object

391
00:18:15,710 --> 00:18:22,250
store it's technically it's atomic key

392
00:18:18,230 --> 00:18:24,980
value store it can be private or can be

393
00:18:22,250 --> 00:18:32,450
public so it's not an active entity it's

394
00:18:24,980 --> 00:18:36,020
a set of api's so a set of api's that

395
00:18:32,450 --> 00:18:39,140
can be invoked by actors so any piece of

396
00:18:36,020 --> 00:18:44,090
memory if it has a necessary size can be

397
00:18:39,140 --> 00:18:46,820
turned into object store and actors who

398
00:18:44,090 --> 00:18:51,760
has access to it can read and write to

399
00:18:46,820 --> 00:18:56,889
this talk also this store can be

400
00:18:51,760 --> 00:19:00,800
persistent for example you can map a

401
00:18:56,890 --> 00:19:03,800
file into untrusted memory and turn this

402
00:19:00,800 --> 00:19:10,490
puppet memory into an object store so

403
00:19:03,800 --> 00:19:10,970
you'll have persistence on demand that's

404
00:19:10,490 --> 00:19:15,260
all

405
00:19:10,970 --> 00:19:18,200
regarding the design the question which

406
00:19:15,260 --> 00:19:21,080
i want to show you the answer later is

407
00:19:18,200 --> 00:19:23,960
to show you how to how fast is the

408
00:19:21,080 --> 00:19:27,050
communication primitives because the

409
00:19:23,960 --> 00:19:29,660
original motivation was we want to omit

410
00:19:27,050 --> 00:19:31,850
the use of equals and or cost and for

411
00:19:29,660 --> 00:19:36,350
that we use the synchronous messages are

412
00:19:31,850 --> 00:19:38,990
how how fast are they for that let's

413
00:19:36,350 --> 00:19:40,189
consider two and two actors located

414
00:19:38,990 --> 00:19:43,670
inside different enclave's

415
00:19:40,190 --> 00:19:45,230
and in this case they use equals to

416
00:19:43,670 --> 00:19:47,990
leave an end clave to send the message

417
00:19:45,230 --> 00:19:51,410
to another one and the messages use it

418
00:19:47,990 --> 00:19:53,450
by and unboxers users by two different

419
00:19:51,410 --> 00:19:56,950
written on top of different book so

420
00:19:53,450 --> 00:20:00,800
there is this very simple ping pong pong

421
00:19:56,950 --> 00:20:04,610
example with 1 million messages with

422
00:20:00,800 --> 00:20:07,340
those messages have different size

423
00:20:04,610 --> 00:20:10,429
starting from 16 bytes up to 1 megawatt

424
00:20:07,340 --> 00:20:12,290
half of a megabyte to thread so the

425
00:20:10,430 --> 00:20:16,250
straight one destroy everything is

426
00:20:12,290 --> 00:20:17,409
honest again different threads just the

427
00:20:16,250 --> 00:20:21,200
same actors just different

428
00:20:17,410 --> 00:20:25,340
synchronization mechanism this is the

429
00:20:21,200 --> 00:20:29,750
performance of of the SDK as you can see

430
00:20:25,340 --> 00:20:33,310
it is a pike which is near 32 K it's

431
00:20:29,750 --> 00:20:36,100
exactly size of the first line cache

432
00:20:33,310 --> 00:20:38,480
because when you transfer message from

433
00:20:36,100 --> 00:20:40,189
trusted area to trusted by the use of

434
00:20:38,480 --> 00:20:42,020
all calls there is a Marshall in

435
00:20:40,190 --> 00:20:44,600
mechanism which copies data from one

436
00:20:42,020 --> 00:20:47,780
memory to another and obviously if this

437
00:20:44,600 --> 00:20:50,449
memory fits into the l1 cache this works

438
00:20:47,780 --> 00:20:53,330
very very fast so this is the end of the

439
00:20:50,450 --> 00:20:57,290
cache and it has let's say steady aware

440
00:20:53,330 --> 00:21:04,189
after 128 K and this is the performance

441
00:20:57,290 --> 00:21:07,670
for you actor so much much faster very

442
00:21:04,190 --> 00:21:12,020
fast and because I was using in this

443
00:21:07,670 --> 00:21:14,570
example cargo so as I said you can very

444
00:21:12,020 --> 00:21:16,490
easily to switch from just switch a

445
00:21:14,570 --> 00:21:18,590
cargo from encrypted into non-encrypted

446
00:21:16,490 --> 00:21:21,010
former vice versa this is the

447
00:21:18,590 --> 00:21:24,010
performance for encrypted cards so

448
00:21:21,010 --> 00:21:27,050
encrypted even encrypted cargos

449
00:21:24,010 --> 00:21:29,900
approximately three times faster than

450
00:21:27,050 --> 00:21:33,879
non-encrypted non-encrypted a cold basic

451
00:21:29,900 --> 00:21:33,880
messages and the difference between

452
00:21:34,870 --> 00:21:41,060
non-encrypted cargoes and equals

453
00:21:37,280 --> 00:21:44,629
approximately 30 times so this interface

454
00:21:41,060 --> 00:21:46,820
is very fast and you can write very very

455
00:21:44,630 --> 00:21:51,590
high performance application on top of

456
00:21:46,820 --> 00:21:52,700
this framework sources are available you

457
00:21:51,590 --> 00:21:55,970
can check if you want

458
00:21:52,700 --> 00:21:58,580
there are several examples here with the

459
00:21:55,970 --> 00:22:01,820
template so which which shows an

460
00:21:58,580 --> 00:22:04,820
ordinary hello world application there

461
00:22:01,820 --> 00:22:07,450
are there is a set of virus pi

462
00:22:04,820 --> 00:22:09,590
songs that use encrypted non-encrypted

463
00:22:07,450 --> 00:22:12,289
carbon-based non-character basic

464
00:22:09,590 --> 00:22:15,350
messages also there is Network version

465
00:22:12,289 --> 00:22:17,929
of this fine funk application and there

466
00:22:15,350 --> 00:22:20,809
is a huge set of various forms of local

467
00:22:17,929 --> 00:22:24,679
attestation diffie-hellman and something

468
00:22:20,809 --> 00:22:28,158
else so at least three different pine

469
00:22:24,679 --> 00:22:32,120
points which use different mechanisms to

470
00:22:28,159 --> 00:22:33,559
establish an encrypted connection also

471
00:22:32,120 --> 00:22:35,418
there is an example for secure

472
00:22:33,559 --> 00:22:40,309
multi-party computation it's a secure

473
00:22:35,419 --> 00:22:43,840
assume some the Yocto subject store and

474
00:22:40,309 --> 00:22:56,570
there is an HTTP webserver which

475
00:22:43,840 --> 00:22:59,629
provides ssl connection yes this is

476
00:22:56,570 --> 00:23:02,418
wrong but there is a service prima dot i

477
00:22:59,629 --> 00:23:06,110
BR here should be pre mod it's the title

478
00:23:02,419 --> 00:23:10,460
it's a group site it's a site of our

479
00:23:06,110 --> 00:23:13,279
group and this site is hosted on top of

480
00:23:10,460 --> 00:23:15,590
the framework so it shows how how

481
00:23:13,279 --> 00:23:18,529
exactly you can terminate SSL inside and

482
00:23:15,590 --> 00:23:20,000
in clave and how you can write HTTP

483
00:23:18,529 --> 00:23:26,409
based application on top of this

484
00:23:20,000 --> 00:23:29,000
framework let's talk about future plans

485
00:23:26,409 --> 00:23:31,639
because this project was a kind of

486
00:23:29,000 --> 00:23:34,340
research project it's written in C very

487
00:23:31,639 --> 00:23:36,199
safe language obviously you may ask a

488
00:23:34,340 --> 00:23:38,539
lot of questions about the preak ability

489
00:23:36,200 --> 00:23:41,629
of this framework in general and one of

490
00:23:38,539 --> 00:23:43,519
the primary problem is how to make the

491
00:23:41,629 --> 00:23:49,299
programming language and environment

492
00:23:43,519 --> 00:23:53,899
more let's say more safe so currently

493
00:23:49,299 --> 00:23:55,570
I'm working on the hardening of of of

494
00:23:53,899 --> 00:23:59,449
the framework here will be

495
00:23:55,570 --> 00:24:04,340
instrumentation mechanism provided by

496
00:23:59,450 --> 00:24:06,350
LLVM which will limit a matter of memory

497
00:24:04,340 --> 00:24:09,980
acts that can be accessed by different

498
00:24:06,350 --> 00:24:15,129
actors so we exam this mechanism will

499
00:24:09,980 --> 00:24:17,900
help solve problems related to

500
00:24:15,130 --> 00:24:20,830
uncontrolled access to memory by the C

501
00:24:17,900 --> 00:24:24,320
language mechanisms for partitioning

502
00:24:20,830 --> 00:24:30,020
because the framework provides mechanism

503
00:24:24,320 --> 00:24:33,129
for easy deployment and obviously it

504
00:24:30,020 --> 00:24:36,370
will be nice to have a mechanism to self

505
00:24:33,130 --> 00:24:39,470
deployment or self partitioning of

506
00:24:36,370 --> 00:24:42,290
actors because actors are independent

507
00:24:39,470 --> 00:24:44,300
that they can be splitted without or

508
00:24:42,290 --> 00:24:46,399
partition it without any any

509
00:24:44,300 --> 00:24:48,919
dependencies and problems so this is the

510
00:24:46,400 --> 00:24:50,750
another direction of the work of course

511
00:24:48,920 --> 00:24:54,560
moulting cliff applications so though

512
00:24:50,750 --> 00:24:56,420
the framework was developed to to give a

513
00:24:54,560 --> 00:25:01,070
tool to build such multiwave

514
00:24:56,420 --> 00:25:03,530
applications the HTTP server will be

515
00:25:01,070 --> 00:25:08,570
improved will support multiple domains

516
00:25:03,530 --> 00:25:12,379
and the rest there is additional ideas

517
00:25:08,570 --> 00:25:15,379
related to IOT and currently the

518
00:25:12,380 --> 00:25:17,570
framework relies on the Intel SGX SDK

519
00:25:15,380 --> 00:25:20,000
which is not very good from performance

520
00:25:17,570 --> 00:25:24,189
from security point of view so probably

521
00:25:20,000 --> 00:25:43,330
we will try to remove remove this legacy

522
00:25:24,190 --> 00:25:46,270
so thank you very much questions yes I

523
00:25:43,330 --> 00:25:49,189
cannot give you numbers but conceptually

524
00:25:46,270 --> 00:25:52,610
all the synchronous queues a synchronous

525
00:25:49,190 --> 00:25:54,920
call by AGC SDK this interface they

526
00:25:52,610 --> 00:25:56,840
absolutely I mean conceptual is the same

527
00:25:54,920 --> 00:25:58,760
you have to thread one thread and side

528
00:25:56,840 --> 00:26:00,590
of the clave once a month ready now they

529
00:25:58,760 --> 00:26:02,960
are outside of the clave and there is

530
00:26:00,590 --> 00:26:06,169
Charlotte memory which is used to incur

531
00:26:02,960 --> 00:26:08,480
in DQ a data so it will be the primitive

532
00:26:06,170 --> 00:26:09,950
as a pretty primitive it's near the same

533
00:26:08,480 --> 00:26:13,850
as a permutation

534
00:26:09,950 --> 00:26:17,170
well I cannot compare me switch less

535
00:26:13,850 --> 00:26:17,169
call by calls but

536
00:26:17,930 --> 00:26:22,640
there is no many things that you can

537
00:26:20,750 --> 00:26:24,650
apply so you can use atomic instructions

538
00:26:22,640 --> 00:26:28,310
you can use heart very low collision and

539
00:26:24,650 --> 00:26:30,710
you can use nothing else so maybe two

540
00:26:28,310 --> 00:26:34,159
two approaches or and spin locks so

541
00:26:30,710 --> 00:26:37,130
three different approaches so they near

542
00:26:34,160 --> 00:26:39,170
the same performance actually these

543
00:26:37,130 --> 00:26:43,910
scales differently but conceptually are

544
00:26:39,170 --> 00:26:46,610
the same so you can assume that switch

545
00:26:43,910 --> 00:26:51,460
let's calls mean has near the same

546
00:26:46,610 --> 00:26:51,459
performance yes please

547
00:27:29,919 --> 00:27:37,749
so the question is how local attestation

548
00:27:35,169 --> 00:27:42,520
works I will paraphrase this if you

549
00:27:37,749 --> 00:27:44,729
don't mind so the framework provides

550
00:27:42,520 --> 00:27:49,989
[Music]

551
00:27:44,729 --> 00:27:52,919
primitives to create encrypted channels

552
00:27:49,989 --> 00:27:56,549
by the use of local attestation and

553
00:27:52,919 --> 00:27:59,799
during the compiling files the

554
00:27:56,549 --> 00:28:01,690
environment generates signatures so a

555
00:27:59,799 --> 00:28:05,559
Merlin clave if you know what is it

556
00:28:01,690 --> 00:28:07,299
signatures of each in clave and you need

557
00:28:05,559 --> 00:28:10,209
to have let's say the root of trust so

558
00:28:07,299 --> 00:28:13,869
some one in 12 that includes all marine

559
00:28:10,209 --> 00:28:15,489
claves scientists inside so it's a

560
00:28:13,869 --> 00:28:17,408
sequential process there is a root of

561
00:28:15,489 --> 00:28:20,109
trust with the first and clave dissing

562
00:28:17,409 --> 00:28:21,009
clave has a set of all or maybe subset

563
00:28:20,109 --> 00:28:23,678
of enclave's

564
00:28:21,009 --> 00:28:25,869
or communication channels and then you

565
00:28:23,679 --> 00:28:29,289
establish one two three four five let's

566
00:28:25,869 --> 00:28:32,408
say and sequentially they perform local

567
00:28:29,289 --> 00:28:35,529
attestation so of course it cannot be

568
00:28:32,409 --> 00:28:38,079
very general approach so currently it's

569
00:28:35,529 --> 00:28:41,619
tailored for sequential initialization

570
00:28:38,079 --> 00:28:46,448
of in place and sequential generation of

571
00:28:41,619 --> 00:28:48,458
encrypted channels but this job

572
00:28:46,449 --> 00:28:50,859
significant this environment

573
00:28:48,459 --> 00:28:53,909
significantly reduces the complexity of

574
00:28:50,859 --> 00:28:57,249
this procedure so if you can map your

575
00:28:53,909 --> 00:28:59,649
application to this design so like you

576
00:28:57,249 --> 00:29:02,019
can sequentially establish connections

577
00:28:59,649 --> 00:29:04,329
between several in place yes you can

578
00:29:02,019 --> 00:29:06,249
apply in this framework immediately and

579
00:29:04,329 --> 00:29:08,440
the framework will generate necessary

580
00:29:06,249 --> 00:29:10,540
parts otherwise well bother wise you

581
00:29:08,440 --> 00:29:13,420
will need to

582
00:29:10,540 --> 00:29:15,670
great let's say ye God or something very

583
00:29:13,420 --> 00:29:17,590
initial very very read of root of trust

584
00:29:15,670 --> 00:29:20,080
and this root of trust will establish

585
00:29:17,590 --> 00:29:22,179
connections between different and clave

586
00:29:20,080 --> 00:30:02,020
so this will require you to modify the

587
00:29:22,180 --> 00:30:05,470
framework very very good question the

588
00:30:02,020 --> 00:30:08,200
question is what about namespace inside

589
00:30:05,470 --> 00:30:10,830
it inside the network inside the

590
00:30:08,200 --> 00:30:14,050
framework to distinguish different

591
00:30:10,830 --> 00:30:15,970
actors and I would say no the reason

592
00:30:14,050 --> 00:30:19,360
mechanism there is no mechanism for that

593
00:30:15,970 --> 00:30:22,630
because you are absolutely right so name

594
00:30:19,360 --> 00:30:27,300
discovery so this car or mechanism which

595
00:30:22,630 --> 00:30:30,550
maps that Maps actors to unique names

596
00:30:27,300 --> 00:30:34,060
well would be it's very complicated in

597
00:30:30,550 --> 00:30:37,200
general in distributed systems so in the

598
00:30:34,060 --> 00:30:41,169
framework the reason mechanism for

599
00:30:37,200 --> 00:30:45,280
naming and identification of actors at

600
00:30:41,170 --> 00:30:48,340
the source code level so a tool which a

601
00:30:45,280 --> 00:30:50,230
tool that generates binaries know

602
00:30:48,340 --> 00:30:53,470
something about source code of actors

603
00:30:50,230 --> 00:30:55,090
and their names but there is no

604
00:30:53,470 --> 00:31:01,080
independent mechanism for name

605
00:30:55,090 --> 00:31:01,080
discovering yo your question

606
00:31:14,290 --> 00:31:33,659
I will say that it's a very recent so

607
00:31:16,600 --> 00:31:40,120
this diagram let's say two years old I

608
00:31:33,660 --> 00:31:45,730
would say that each each micro code

609
00:31:40,120 --> 00:31:51,070
update cuts performance they're very

610
00:31:45,730 --> 00:32:30,730
very significant I would say so this is

611
00:31:51,070 --> 00:32:32,710
the problem the question is do it is

612
00:32:30,730 --> 00:32:38,320
this a right way to use messages instead

613
00:32:32,710 --> 00:32:41,290
of equals at the beginning I did not

614
00:32:38,320 --> 00:32:44,139
consider so at some moment for some

615
00:32:41,290 --> 00:32:48,670
applications I thought that the use of

616
00:32:44,140 --> 00:32:51,220
equals is okay but now I don't think so

617
00:32:48,670 --> 00:32:53,590
I still believe that and I see these

618
00:32:51,220 --> 00:32:54,400
numbers that a synchronous interface is

619
00:32:53,590 --> 00:32:56,939
much better

620
00:32:54,400 --> 00:33:00,100
however it has significant drawback

621
00:32:56,940 --> 00:33:02,800
because you cannot stop thread inside

622
00:33:00,100 --> 00:33:04,600
the Dan clave and this trade anyway will

623
00:33:02,800 --> 00:33:09,340
need to leave the enclaves at some

624
00:33:04,600 --> 00:33:12,580
moment so and which means that anyway at

625
00:33:09,340 --> 00:33:15,699
some moment for some reason or due to

626
00:33:12,580 --> 00:33:17,679
the reasons of scalability on any of my

627
00:33:15,700 --> 00:33:20,770
thread will leave them in class or

628
00:33:17,680 --> 00:33:22,840
in some form or call still exist but the

629
00:33:20,770 --> 00:33:25,990
programming model doesn't rely on this

630
00:33:22,840 --> 00:33:30,059
that lets the pot this is important yes

631
00:33:25,990 --> 00:33:30,059
please please

632
00:34:42,239 --> 00:34:50,138
first of all yes distributed problems of

633
00:34:47,590 --> 00:34:53,139
distributed computing applied for this

634
00:34:50,139 --> 00:34:56,350
design absolutely without any except

635
00:34:53,139 --> 00:34:58,500
let's say I also consider this form of

636
00:34:56,350 --> 00:35:01,360
secure multi-party computation is a

637
00:34:58,500 --> 00:35:05,520
mechanism to improve performance exactly

638
00:35:01,360 --> 00:35:08,290
so instead of let's say five different

639
00:35:05,520 --> 00:35:10,330
separate machines like servers located

640
00:35:08,290 --> 00:35:12,730
in different countries which say you

641
00:35:10,330 --> 00:35:15,160
have a platform where you upload your

642
00:35:12,730 --> 00:35:17,950
binary see you there they represent your

643
00:35:15,160 --> 00:35:19,990
original server and in this local in

644
00:35:17,950 --> 00:35:21,819
this local place they can compute much

645
00:35:19,990 --> 00:35:24,930
faster and then go back let's say that

646
00:35:21,820 --> 00:35:27,580
so that's the design in the background

647
00:35:24,930 --> 00:35:31,720
but but of course the problems related

648
00:35:27,580 --> 00:35:34,330
to try I mean the consensus very funny

649
00:35:31,720 --> 00:35:36,549
BFG our raft and other stuff can be

650
00:35:34,330 --> 00:35:37,900
applied and should be of course we don't

651
00:35:36,550 --> 00:35:40,230
solve this and we cannot solve the

652
00:35:37,900 --> 00:35:40,230
setting

653
00:36:29,890 --> 00:36:36,520
firstly you can provide some mechanisms

654
00:36:34,160 --> 00:36:39,890
for some of the mechanism for setting

655
00:36:36,520 --> 00:36:43,038
affinity was exactly for this so when

656
00:36:39,890 --> 00:36:45,078
you want to co-locate your code and data

657
00:36:43,039 --> 00:36:47,480
within the same cone with the same call

658
00:36:45,079 --> 00:36:49,640
and if you want to and if you need a

659
00:36:47,480 --> 00:36:52,690
mechanism for scheduling that this

660
00:36:49,640 --> 00:36:55,009
mechanism also can be implemented at the

661
00:36:52,690 --> 00:36:55,670
assignment level not inside in the

662
00:36:55,010 --> 00:37:00,589
source code

663
00:36:55,670 --> 00:37:02,539
however this not it's not the primary

664
00:37:00,589 --> 00:37:04,130
approach to solve this problem I mean

665
00:37:02,539 --> 00:37:06,799
the problem when you need to leave an in

666
00:37:04,130 --> 00:37:09,619
clave and the best way I found it's not

667
00:37:06,799 --> 00:37:12,410
a part of the framework but you need to

668
00:37:09,619 --> 00:37:14,839
have them let's say at some moment when

669
00:37:12,410 --> 00:37:17,569
you cannot get a message you need to

670
00:37:14,839 --> 00:37:22,250
leave an end clave manually but you do

671
00:37:17,569 --> 00:37:24,859
this for not random but let's say

672
00:37:22,250 --> 00:37:27,619
statically identify a statistically

673
00:37:24,859 --> 00:37:32,440
identified impure interval of time there

674
00:37:27,619 --> 00:37:32,440
is nothing better oh I don't know thank

675
00:37:32,600 --> 00:37:39,229
you

676
00:37:33,330 --> 00:37:39,229
[Applause]

