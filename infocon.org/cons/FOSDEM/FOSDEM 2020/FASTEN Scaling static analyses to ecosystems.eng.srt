1
00:00:05,200 --> 00:00:08,160
i thank you all for

2
00:00:06,480 --> 00:00:10,559
coming to this session about dividends

3
00:00:08,160 --> 00:00:13,280
management

4
00:00:10,559 --> 00:00:14,559
my name is georgios guzios i'm assistant

5
00:00:13,280 --> 00:00:15,440
professor at the dark university of

6
00:00:14,559 --> 00:00:18,080
technology

7
00:00:15,440 --> 00:00:19,600
in the netherlands you can find me on

8
00:00:18,080 --> 00:00:22,159
the internet using this

9
00:00:19,600 --> 00:00:24,160
tag here on twitter github or any other

10
00:00:22,160 --> 00:00:26,080
social media of your choice

11
00:00:24,160 --> 00:00:27,359
what i'm going to be talking about is

12
00:00:26,080 --> 00:00:28,839
basically a project that we are

13
00:00:27,359 --> 00:00:32,800
currently running

14
00:00:28,840 --> 00:00:35,840
and that what it tries to do effectively

15
00:00:32,800 --> 00:00:38,480
is to scale static analysis

16
00:00:35,840 --> 00:00:40,640
at the ecosystem level for four

17
00:00:38,480 --> 00:00:42,078
programming languages

18
00:00:40,640 --> 00:00:43,680
we're in a room about dependency

19
00:00:42,079 --> 00:00:45,920
management so i don't need to

20
00:00:43,680 --> 00:00:47,120
explain a lot what dependency management

21
00:00:45,920 --> 00:00:50,960
management is

22
00:00:47,120 --> 00:00:53,120
so well we have we can

23
00:00:50,960 --> 00:00:54,879
basically on any programming language we

24
00:00:53,120 --> 00:00:57,120
can have a dependency to package

25
00:00:54,879 --> 00:00:58,559
and this package can can have its own

26
00:00:57,120 --> 00:01:00,800
dependencies

27
00:00:58,559 --> 00:01:02,800
and you know dependency to dependency

28
00:01:00,800 --> 00:01:04,640
dependency if you're a computer science

29
00:01:02,800 --> 00:01:06,798
scientist you or immediately understand

30
00:01:04,640 --> 00:01:09,600
it this forms a graph

31
00:01:06,799 --> 00:01:11,760
and the graph has certain properties um

32
00:01:09,600 --> 00:01:13,039
for example it is version so every time

33
00:01:11,760 --> 00:01:14,799
that there is a new

34
00:01:13,040 --> 00:01:16,479
version of the package we have a new

35
00:01:14,799 --> 00:01:18,159
version of the graph

36
00:01:16,479 --> 00:01:20,320
the graphs are pretty big for common

37
00:01:18,159 --> 00:01:21,280
languages for example maven it currently

38
00:01:20,320 --> 00:01:24,000
has around

39
00:01:21,280 --> 00:01:24,840
the maven repository has around 3.5

40
00:01:24,000 --> 00:01:27,600
million

41
00:01:24,840 --> 00:01:29,759
artifacts and an artifact in maven is

42
00:01:27,600 --> 00:01:32,240
the package plaza version so

43
00:01:29,759 --> 00:01:33,759
just in terms of nodes it's pretty big

44
00:01:32,240 --> 00:01:34,240
and also the number of connections can

45
00:01:33,759 --> 00:01:37,119
be

46
00:01:34,240 --> 00:01:37,119
pretty big as well

47
00:01:37,439 --> 00:01:41,520
what we have been seeing lately is that

48
00:01:39,680 --> 00:01:43,040
the ground such graphs are also very

49
00:01:41,520 --> 00:01:46,000
fragile

50
00:01:43,040 --> 00:01:46,399
one thing that basically triggered much

51
00:01:46,000 --> 00:01:47,920
of the

52
00:01:46,399 --> 00:01:50,079
research community at least to do

53
00:01:47,920 --> 00:01:53,119
research into ecosystem

54
00:01:50,079 --> 00:01:56,399
happened in 2016 when somebody

55
00:01:53,119 --> 00:01:58,719
removed something from npm very small

56
00:01:56,399 --> 00:02:00,719
package just 11 lines of code

57
00:01:58,719 --> 00:02:01,839
and you know in response the whole

58
00:02:00,719 --> 00:02:05,199
internet died

59
00:02:01,840 --> 00:02:09,598
basically so it was very very

60
00:02:05,200 --> 00:02:13,040
central into the npm

61
00:02:09,598 --> 00:02:15,359
let's say dependency graph so the whole

62
00:02:13,040 --> 00:02:17,359
there was no resolution that would work

63
00:02:15,360 --> 00:02:18,560
for many hours and you know there was

64
00:02:17,360 --> 00:02:21,520
quite a bit of

65
00:02:18,560 --> 00:02:23,280
trouble there and the equifax system is

66
00:02:21,520 --> 00:02:25,840
also related to dependency management

67
00:02:23,280 --> 00:02:27,520
more recent uh cases of failures the

68
00:02:25,840 --> 00:02:28,640
event stream incident where somebody

69
00:02:27,520 --> 00:02:31,519
injected

70
00:02:28,640 --> 00:02:32,559
a code to steal bitcoin uh from a user

71
00:02:31,519 --> 00:02:34,480
wallet

72
00:02:32,560 --> 00:02:36,560
a rest client that happened like two

73
00:02:34,480 --> 00:02:39,679
three months ago if i remember correctly

74
00:02:36,560 --> 00:02:41,760
again it was um it is a rest api client

75
00:02:39,680 --> 00:02:44,640
for ruby and somebody ejected code

76
00:02:41,760 --> 00:02:46,160
to get login information and post it to

77
00:02:44,640 --> 00:02:48,079
another

78
00:02:46,160 --> 00:02:49,440
url and so on the list goes on every

79
00:02:48,080 --> 00:02:52,800
week there is a new failure

80
00:02:49,440 --> 00:02:54,720
that we need to account for people have

81
00:02:52,800 --> 00:02:57,920
been doing research on that front

82
00:02:54,720 --> 00:02:58,640
um there have been quite a bit of

83
00:02:57,920 --> 00:03:01,679
interest

84
00:02:58,640 --> 00:03:04,159
lately tom will be surely

85
00:03:01,680 --> 00:03:05,440
presenting a lot of his own work on that

86
00:03:04,159 --> 00:03:08,239
front

87
00:03:05,440 --> 00:03:11,120
but i have some numbers here so we have

88
00:03:08,239 --> 00:03:13,280
done some work in 2017

89
00:03:11,120 --> 00:03:14,720
just before the left but the incident

90
00:03:13,280 --> 00:03:16,800
happened and we started

91
00:03:14,720 --> 00:03:18,400
looking into the dependency graphs and

92
00:03:16,800 --> 00:03:21,760
we found that the average javascript

93
00:03:18,400 --> 00:03:23,760
project had 54 dependencies some people

94
00:03:21,760 --> 00:03:25,040
replicated our work this year this grew

95
00:03:23,760 --> 00:03:28,560
up to 80.

96
00:03:25,040 --> 00:03:30,640
and i heard uh i think it was jeff today

97
00:03:28,560 --> 00:03:32,400
that raised this number to more than a

98
00:03:30,640 --> 00:03:34,640
hundred so the average

99
00:03:32,400 --> 00:03:36,560
project on github or the average package

100
00:03:34,640 --> 00:03:38,640
actually on npm

101
00:03:36,560 --> 00:03:41,440
has around 100 dependencies and this is

102
00:03:38,640 --> 00:03:43,279
growing very very fast

103
00:03:41,440 --> 00:03:44,560
another thing that happens is that you

104
00:03:43,280 --> 00:03:47,920
know those ecosystem

105
00:03:44,560 --> 00:03:48,720
systems changing a very high rate so we

106
00:03:47,920 --> 00:03:51,119
have done it

107
00:03:48,720 --> 00:03:53,439
in our own research we found that from

108
00:03:51,120 --> 00:03:55,599
the transitive dependency closure so

109
00:03:53,439 --> 00:03:58,480
all the dependencies that we get by

110
00:03:55,599 --> 00:04:00,480
doing a package resolution let's say

111
00:03:58,480 --> 00:04:01,840
50 of those change over the course of

112
00:04:00,480 --> 00:04:04,959
six months

113
00:04:01,840 --> 00:04:08,000
why because new package versions um

114
00:04:04,959 --> 00:04:09,519
are released so we um you know the our

115
00:04:08,000 --> 00:04:12,159
transited by disclosure

116
00:04:09,519 --> 00:04:13,760
even though we don't change our client

117
00:04:12,159 --> 00:04:14,000
the code that we include in our client

118
00:04:13,760 --> 00:04:16,880
will

119
00:04:14,000 --> 00:04:17,519
change okay so it is very important to

120
00:04:16,880 --> 00:04:19,440
have

121
00:04:17,519 --> 00:04:20,959
an understanding of what's going on in

122
00:04:19,440 --> 00:04:22,079
the periphery of our dependencies not

123
00:04:20,959 --> 00:04:25,040
just in our immediate

124
00:04:22,079 --> 00:04:25,040
immediate dependencies

125
00:04:25,280 --> 00:04:29,679
we also found that um now there exists

126
00:04:28,639 --> 00:04:31,759
packages in

127
00:04:29,680 --> 00:04:33,280
ecosystems like rubygems for example

128
00:04:31,759 --> 00:04:35,759
that if we just remove them

129
00:04:33,280 --> 00:04:37,039
and i can tell you which those are and

130
00:04:35,759 --> 00:04:39,120
which versions

131
00:04:37,040 --> 00:04:40,320
around 40 of the ecosystem will collapse

132
00:04:39,120 --> 00:04:43,680
so we'll have another

133
00:04:40,320 --> 00:04:45,280
leftmod incident

134
00:04:43,680 --> 00:04:47,360
another dark side of dependency

135
00:04:45,280 --> 00:04:50,080
maintenance is that

136
00:04:47,360 --> 00:04:51,199
very few packages sorry a large number

137
00:04:50,080 --> 00:04:54,800
of core packages

138
00:04:51,199 --> 00:04:58,000
is maintained by very few people so

139
00:04:54,800 --> 00:05:00,080
what we um this is those researchers

140
00:04:58,000 --> 00:05:02,560
zimmerman and all have found is that

141
00:05:00,080 --> 00:05:05,599
just 400 people maintain basically

142
00:05:02,560 --> 00:05:06,720
the 10 most 10 000 most important more

143
00:05:05,600 --> 00:05:09,120
central

144
00:05:06,720 --> 00:05:11,840
packages in the node ecosystem in the

145
00:05:09,120 --> 00:05:11,840
npm ecosystem

146
00:05:12,800 --> 00:05:16,240
now from the consumer side from the

147
00:05:14,320 --> 00:05:18,320
developer side

148
00:05:16,240 --> 00:05:20,080
and it is very difficult developers

149
00:05:18,320 --> 00:05:23,120
complain that it's very difficult to

150
00:05:20,080 --> 00:05:26,479
assess basically the impact of an update

151
00:05:23,120 --> 00:05:29,440
so it is there has been research there

152
00:05:26,479 --> 00:05:31,039
because there is no tooling so you can

153
00:05:29,440 --> 00:05:32,880
basically

154
00:05:31,039 --> 00:05:34,320
update but you don't know what your code

155
00:05:32,880 --> 00:05:36,000
you're going to bring in first and you

156
00:05:34,320 --> 00:05:39,280
don't know what the impact of this code

157
00:05:36,000 --> 00:05:41,520
of this update will be in your own code

158
00:05:39,280 --> 00:05:41,520
okay

159
00:05:43,199 --> 00:05:49,440
so what we raul cooler found

160
00:05:46,800 --> 00:05:51,039
in his research is that 85 percent of

161
00:05:49,440 --> 00:05:54,080
the dependencies in maven

162
00:05:51,039 --> 00:05:55,520
are outdated and fifty percent

163
00:05:54,080 --> 00:05:57,680
in fifty percent of the most important

164
00:05:55,520 --> 00:06:00,560
packages so the top packages in terms of

165
00:05:57,680 --> 00:06:00,560
incoming connections

166
00:06:02,319 --> 00:06:05,520
even more alarmingly seventy percent of

167
00:06:04,800 --> 00:06:09,039
the

168
00:06:05,520 --> 00:06:10,639
dependencies have some kind of linking

169
00:06:09,039 --> 00:06:12,479
to a dependency that has a security

170
00:06:10,639 --> 00:06:15,199
issue

171
00:06:12,479 --> 00:06:16,000
why is that developer said that they

172
00:06:15,199 --> 00:06:17,680
were unaware

173
00:06:16,000 --> 00:06:19,600
basically of these security those

174
00:06:17,680 --> 00:06:21,280
security problems

175
00:06:19,600 --> 00:06:22,800
and as a result there's basically

176
00:06:21,280 --> 00:06:24,638
vulnerabilities that proliferate in

177
00:06:22,800 --> 00:06:27,280
ecosystems so

178
00:06:24,639 --> 00:06:29,120
there was a technical report by comcast

179
00:06:27,280 --> 00:06:32,159
in 2017 that showed that

180
00:06:29,120 --> 00:06:34,479
one-fourth of four library downloads

181
00:06:32,160 --> 00:06:36,000
actually include the vulnerability by in

182
00:06:34,479 --> 00:06:38,880
the tragedy closure not

183
00:06:36,000 --> 00:06:40,000
necessarily in the library itself and

184
00:06:38,880 --> 00:06:42,960
one third of the top

185
00:06:40,000 --> 00:06:44,800
uh case 100k sites have a vulnerable

186
00:06:42,960 --> 00:06:46,318
dependency they include the verdant

187
00:06:44,800 --> 00:06:48,160
vulnerable dependence in their

188
00:06:46,319 --> 00:06:50,479
javascript code base

189
00:06:48,160 --> 00:06:53,039
i am pretty sure that those numbers are

190
00:06:50,479 --> 00:06:57,199
a bit alarming

191
00:06:53,039 --> 00:06:59,039
so if we aggregate all the

192
00:06:57,199 --> 00:07:01,360
what researchers basically have found

193
00:06:59,039 --> 00:07:03,919
the last two three years that this

194
00:07:01,360 --> 00:07:04,800
has been very active we can see we can

195
00:07:03,919 --> 00:07:08,318
cut find

196
00:07:04,800 --> 00:07:10,080
a top let's say um four basic problems

197
00:07:08,319 --> 00:07:13,759
there's the observability problem we

198
00:07:10,080 --> 00:07:15,440
don't know whether new dependency

199
00:07:13,759 --> 00:07:16,960
was released and what is the impact of

200
00:07:15,440 --> 00:07:18,800
this dependency

201
00:07:16,960 --> 00:07:20,560
and this is also encoded into the update

202
00:07:18,800 --> 00:07:24,160
problem so if i update

203
00:07:20,560 --> 00:07:26,880
what will break the compliance problem

204
00:07:24,160 --> 00:07:27,840
there was a whole discussion in the

205
00:07:26,880 --> 00:07:29,599
morning about that

206
00:07:27,840 --> 00:07:31,039
how do i know that i'm not violating

207
00:07:29,599 --> 00:07:33,199
anyone's copyrights or

208
00:07:31,039 --> 00:07:34,800
in any case how i know what distribute

209
00:07:33,199 --> 00:07:38,000
code that is compatible with

210
00:07:34,800 --> 00:07:39,199
the licenses the license publications

211
00:07:38,000 --> 00:07:41,199
that i have

212
00:07:39,199 --> 00:07:42,880
and there's also the trust problem i

213
00:07:41,199 --> 00:07:46,000
have all the date i have my precious

214
00:07:42,880 --> 00:07:46,639
data how can i trust my precious data to

215
00:07:46,000 --> 00:07:47,840
code that

216
00:07:46,639 --> 00:07:50,400
somebody else has written on the

217
00:07:47,840 --> 00:07:51,359
internet somebody else might be a

218
00:07:50,400 --> 00:07:55,440
company but

219
00:07:51,360 --> 00:07:58,560
you know this doesn't actually give any

220
00:07:55,440 --> 00:07:59,759
assurance there there's no assurance now

221
00:07:58,560 --> 00:08:03,599
on the main turner side

222
00:07:59,759 --> 00:08:06,240
if you maintain a library we have again

223
00:08:03,599 --> 00:08:06,639
the let's say the maintenance problem so

224
00:08:06,240 --> 00:08:09,840
if i

225
00:08:06,639 --> 00:08:11,280
update let's say a function signature or

226
00:08:09,840 --> 00:08:14,638
a function

227
00:08:11,280 --> 00:08:14,638
how many clients will i break

228
00:08:14,800 --> 00:08:18,319
and as a result because we cannot answer

229
00:08:16,560 --> 00:08:20,000
this question and what happens is that

230
00:08:18,319 --> 00:08:21,360
people keep stuffing

231
00:08:20,000 --> 00:08:23,120
stuff into the dependencies so the

232
00:08:21,360 --> 00:08:26,879
dependencies grow bigger

233
00:08:23,120 --> 00:08:29,360
and the code bases you know become

234
00:08:26,879 --> 00:08:29,360
really big

235
00:08:30,479 --> 00:08:33,519
there is also the lack of incentive

236
00:08:31,840 --> 00:08:34,880
problem this is a meta problem i would

237
00:08:33,519 --> 00:08:38,240
say

238
00:08:34,880 --> 00:08:40,958
how can we ensure that maintainers

239
00:08:38,240 --> 00:08:43,360
that do such an important job are

240
00:08:40,958 --> 00:08:45,439
basically adequately funded

241
00:08:43,360 --> 00:08:47,120
by the clients by their clients even

242
00:08:45,440 --> 00:08:49,120
though those clients are not explicit

243
00:08:47,120 --> 00:08:52,000
there is no contract

244
00:08:49,120 --> 00:08:53,120
in big companies so why should an open

245
00:08:52,000 --> 00:08:54,560
source developer

246
00:08:53,120 --> 00:08:56,160
you know respond to issues that is

247
00:08:54,560 --> 00:08:58,079
coming from you know

248
00:08:56,160 --> 00:09:01,360
from big openings that are not

249
00:08:58,080 --> 00:09:01,360
contributing to this development

250
00:09:02,320 --> 00:09:05,360
the state of the art independence

251
00:09:03,680 --> 00:09:07,359
management well

252
00:09:05,360 --> 00:09:09,200
what people do is that they either lock

253
00:09:07,360 --> 00:09:13,040
their dependencies so they don't

254
00:09:09,200 --> 00:09:16,720
pull in updates this might be good but

255
00:09:13,040 --> 00:09:21,120
you know it also helps in

256
00:09:16,720 --> 00:09:23,839
well not being able to update against

257
00:09:21,120 --> 00:09:23,839
security patches

258
00:09:24,560 --> 00:09:27,839
another thing that emerged lately the

259
00:09:26,080 --> 00:09:29,600
last couple of years is that we have

260
00:09:27,839 --> 00:09:32,880
dependency checkers

261
00:09:29,600 --> 00:09:33,360
bots on github especially where that

262
00:09:32,880 --> 00:09:36,000
read

263
00:09:33,360 --> 00:09:37,440
let's say the package descriptors and

264
00:09:36,000 --> 00:09:39,360
know

265
00:09:37,440 --> 00:09:41,440
that there is a new update in a specific

266
00:09:39,360 --> 00:09:43,519
library that is included in the podcast

267
00:09:41,440 --> 00:09:44,560
descriptor and then they propose either

268
00:09:43,519 --> 00:09:46,880
a full request or they

269
00:09:44,560 --> 00:09:48,880
in case of github they have a message in

270
00:09:46,880 --> 00:09:50,959
the

271
00:09:48,880 --> 00:09:52,959
one in the repository but this is not

272
00:09:50,959 --> 00:09:56,079
necessarily

273
00:09:52,959 --> 00:10:00,560
a panacea because well

274
00:09:56,080 --> 00:10:02,079
um the analysis level is very high level

275
00:10:00,560 --> 00:10:03,680
just because we include something in our

276
00:10:02,079 --> 00:10:05,199
transitive dependency said doesn't mean

277
00:10:03,680 --> 00:10:06,560
that we actually use the code

278
00:10:05,200 --> 00:10:09,040
right so there are lots of false

279
00:10:06,560 --> 00:10:09,040
positives

280
00:10:10,160 --> 00:10:15,920
and beyond that there is not a lot

281
00:10:13,040 --> 00:10:18,240
beyond package version management

282
00:10:15,920 --> 00:10:20,240
we don't help the maintainers to

283
00:10:18,240 --> 00:10:22,320
maintain those dependencies

284
00:10:20,240 --> 00:10:24,320
there is no support in making decisions

285
00:10:22,320 --> 00:10:27,440
on which libraries to include

286
00:10:24,320 --> 00:10:30,320
in our dependency set

287
00:10:27,440 --> 00:10:33,279
and there is also no support in

288
00:10:30,320 --> 00:10:34,480
assessing updates

289
00:10:33,279 --> 00:10:36,720
this is the state of dependency

290
00:10:34,480 --> 00:10:37,440
management as at least is being encoded

291
00:10:36,720 --> 00:10:41,760
by

292
00:10:37,440 --> 00:10:41,760
researchers the last two three years

293
00:10:43,040 --> 00:10:47,120
well we believe that we can do better

294
00:10:44,720 --> 00:10:49,440
than that and

295
00:10:47,120 --> 00:10:51,040
to get to the root cause of the problem

296
00:10:49,440 --> 00:10:54,079
what we see is that

297
00:10:51,040 --> 00:10:56,000
while most dependency management

298
00:10:54,079 --> 00:10:57,519
is being done at the package level and

299
00:10:56,000 --> 00:10:59,360
the analysis is being done at the

300
00:10:57,519 --> 00:11:02,399
package level

301
00:10:59,360 --> 00:11:06,640
the actual use of the dependency

302
00:11:02,399 --> 00:11:08,880
happens in the code so

303
00:11:06,640 --> 00:11:10,079
this might look like a dependency tree

304
00:11:08,880 --> 00:11:13,120
or dependency

305
00:11:10,079 --> 00:11:16,319
linear dependency here in that case

306
00:11:13,120 --> 00:11:17,120
but the actual dependency usage of the

307
00:11:16,320 --> 00:11:19,279
dependencies

308
00:11:17,120 --> 00:11:20,959
might indicate for example that this

309
00:11:19,279 --> 00:11:22,240
part of the code is not used at all so

310
00:11:20,959 --> 00:11:24,479
if there is a

311
00:11:22,240 --> 00:11:27,200
security back here we might want to

312
00:11:24,480 --> 00:11:30,399
update but it's not necessarily

313
00:11:27,200 --> 00:11:31,760
important okay

314
00:11:30,399 --> 00:11:33,519
we believe that this is the root cause

315
00:11:31,760 --> 00:11:35,279
that the analysis that we are doing

316
00:11:33,519 --> 00:11:38,160
currently

317
00:11:35,279 --> 00:11:38,160
is very high level

318
00:11:39,279 --> 00:11:45,839
so what we propose is instead of doing

319
00:11:43,680 --> 00:11:48,160
analysis at the package level to do that

320
00:11:45,839 --> 00:11:51,040
at the call graph level

321
00:11:48,160 --> 00:11:51,600
what is a call graph a call graph is a

322
00:11:51,040 --> 00:11:54,719
graph as

323
00:11:51,600 --> 00:11:57,360
the name says that links function calls

324
00:11:54,720 --> 00:11:58,160
across the project okay this is as

325
00:11:57,360 --> 00:11:59,920
simple as that

326
00:11:58,160 --> 00:12:01,680
of course it's a bit complicated to do

327
00:11:59,920 --> 00:12:03,199
static analysis in all programming

328
00:12:01,680 --> 00:12:06,079
languages in order to

329
00:12:03,200 --> 00:12:07,279
get chord graphs but we are working

330
00:12:06,079 --> 00:12:08,880
towards

331
00:12:07,279 --> 00:12:11,839
building tools that will allow us do

332
00:12:08,880 --> 00:12:11,839
that

333
00:12:14,160 --> 00:12:18,240
so if we have such a call based

334
00:12:15,920 --> 00:12:21,279
dependency network in our

335
00:12:18,240 --> 00:12:23,839
as we propose we can solve

336
00:12:21,279 --> 00:12:25,760
quite a few problems in one goal perhaps

337
00:12:23,839 --> 00:12:27,760
not all the problems we cannot solve the

338
00:12:25,760 --> 00:12:30,720
trust problem for example because this

339
00:12:27,760 --> 00:12:32,800
is a larger and meta problem i would say

340
00:12:30,720 --> 00:12:34,560
but many of the problems that we are

341
00:12:32,800 --> 00:12:35,120
currently facing dependency management

342
00:12:34,560 --> 00:12:37,760
we can

343
00:12:35,120 --> 00:12:38,560
do something about those at least one of

344
00:12:37,760 --> 00:12:40,639
them

345
00:12:38,560 --> 00:12:42,638
is for example does this vulnerability

346
00:12:40,639 --> 00:12:45,040
affect my code because we can have

347
00:12:42,639 --> 00:12:46,160
a direct path from a vulnerability in a

348
00:12:45,040 --> 00:12:48,160
function

349
00:12:46,160 --> 00:12:49,920
down to our code so if we find the path

350
00:12:48,160 --> 00:12:51,279
in the chord graph

351
00:12:49,920 --> 00:12:53,839
this means that we are affected and we

352
00:12:51,279 --> 00:12:53,839
should update

353
00:12:54,000 --> 00:12:57,600
we can do a more precise impact analysis

354
00:12:56,320 --> 00:13:00,720
to help the maintainers

355
00:12:57,600 --> 00:13:01,360
so we can say for example uh well if i

356
00:13:00,720 --> 00:13:04,399
change the

357
00:13:01,360 --> 00:13:07,519
if i add if i remove

358
00:13:04,399 --> 00:13:09,440
a function uh argument

359
00:13:07,519 --> 00:13:12,000
from a function call how many clients

360
00:13:09,440 --> 00:13:14,720
will i break before i release the

361
00:13:12,000 --> 00:13:16,320
my update and you know the clients

362
00:13:14,720 --> 00:13:17,680
actually see what that i have broken

363
00:13:16,320 --> 00:13:19,519
them

364
00:13:17,680 --> 00:13:21,199
so if i break lots of clients perhaps i

365
00:13:19,519 --> 00:13:24,800
might make the decision

366
00:13:21,200 --> 00:13:26,480
to not release this update perhaps do a

367
00:13:24,800 --> 00:13:30,079
function overload

368
00:13:26,480 --> 00:13:30,399
okay so what we're effectively trying to

369
00:13:30,079 --> 00:13:33,680
do

370
00:13:30,399 --> 00:13:36,079
is to augment the soundness

371
00:13:33,680 --> 00:13:36,719
by soundness in static analysis we mean

372
00:13:36,079 --> 00:13:39,519
basically

373
00:13:36,720 --> 00:13:40,320
the ground truth with more precision so

374
00:13:39,519 --> 00:13:43,839
make the ground

375
00:13:40,320 --> 00:13:47,040
the actual reuse not the actual

376
00:13:43,839 --> 00:13:47,440
the analysis of the reuse more precise i

377
00:13:47,040 --> 00:13:51,760
have

378
00:13:47,440 --> 00:13:53,440
by changing the unit of analysis

379
00:13:51,760 --> 00:13:55,439
we have done this uh an initial

380
00:13:53,440 --> 00:13:56,720
prototype and which we presented last

381
00:13:55,440 --> 00:14:00,079
year at fosdem

382
00:13:56,720 --> 00:14:02,000
and we have made basically build

383
00:14:00,079 --> 00:14:04,239
quarters for 70 percent of all the cargo

384
00:14:02,000 --> 00:14:06,000
packages cargo is the package manager

385
00:14:04,240 --> 00:14:08,560
for us

386
00:14:06,000 --> 00:14:09,600
it was a very precise um you know

387
00:14:08,560 --> 00:14:12,880
attempt to

388
00:14:09,600 --> 00:14:15,120
construct this huge core graph but the

389
00:14:12,880 --> 00:14:17,199
problem was in our case was that the

390
00:14:15,120 --> 00:14:18,560
call government generatory rust was very

391
00:14:17,199 --> 00:14:21,040
in a bad shape back then

392
00:14:18,560 --> 00:14:21,680
we're working on it currently but it's

393
00:14:21,040 --> 00:14:23,760
still

394
00:14:21,680 --> 00:14:25,519
um it didn't allow us to show the full

395
00:14:23,760 --> 00:14:27,360
potential of the approach

396
00:14:25,519 --> 00:14:29,600
but still it was a very promising

397
00:14:27,360 --> 00:14:31,760
prototype and we

398
00:14:29,600 --> 00:14:33,760
you know based on the ideas that we have

399
00:14:31,760 --> 00:14:35,199
we designed and you know got acqua

400
00:14:33,760 --> 00:14:37,199
acquired some funding for the fasting

401
00:14:35,199 --> 00:14:38,000
project which is like a big big european

402
00:14:37,199 --> 00:14:41,680
project with

403
00:14:38,000 --> 00:14:44,720
seven partners across europe that we

404
00:14:41,680 --> 00:14:45,279
that aims basically to implement the

405
00:14:44,720 --> 00:14:48,399
proj

406
00:14:45,279 --> 00:14:51,439
prezi technology or

407
00:14:48,399 --> 00:14:54,240
idea in that case for java c

408
00:14:51,440 --> 00:14:54,240
python and rust

409
00:14:54,880 --> 00:15:00,639
and on top of the actual core groups we

410
00:14:58,000 --> 00:15:03,120
can do various analysis that will be

411
00:15:00,639 --> 00:15:03,120
offered

412
00:15:03,519 --> 00:15:09,040
as part of a package manager um

413
00:15:06,639 --> 00:15:10,240
and those analysis can be can i safely

414
00:15:09,040 --> 00:15:13,439
update for example

415
00:15:10,240 --> 00:15:15,040
um you know security propagation and so

416
00:15:13,440 --> 00:15:17,199
on

417
00:15:15,040 --> 00:15:18,240
so let's see how this whole thing works

418
00:15:17,199 --> 00:15:20,719
and i can tell you

419
00:15:18,240 --> 00:15:21,279
where we are and where we're heading to

420
00:15:20,720 --> 00:15:24,399
um

421
00:15:21,279 --> 00:15:26,399
so we get um updates

422
00:15:24,399 --> 00:15:29,040
from all those repositories the four

423
00:15:26,399 --> 00:15:32,160
repositories that we support java debian

424
00:15:29,040 --> 00:15:32,560
pip and cargo in streaming fashion so we

425
00:15:32,160 --> 00:15:36,719
have

426
00:15:32,560 --> 00:15:40,239
streams of of new package releases

427
00:15:36,720 --> 00:15:43,120
we have a call graph generator those are

428
00:15:40,240 --> 00:15:44,639
basically per language for java there

429
00:15:43,120 --> 00:15:46,320
are quite a few that are already there

430
00:15:44,639 --> 00:15:47,920
that are high quality for python for

431
00:15:46,320 --> 00:15:49,279
example we're developing our own because

432
00:15:47,920 --> 00:15:53,040
there is no tooling

433
00:15:49,279 --> 00:15:56,800
for us we are also developing our own

434
00:15:53,040 --> 00:16:00,000
for debian we're using existing tools

435
00:15:56,800 --> 00:16:02,079
this gets into two databases um

436
00:16:00,000 --> 00:16:03,920
the metadata database which is basically

437
00:16:02,079 --> 00:16:04,638
based on postgres will be based on

438
00:16:03,920 --> 00:16:06,319
paragraph

439
00:16:04,639 --> 00:16:08,160
actually because it's not fully

440
00:16:06,320 --> 00:16:10,560
implemented yet and we

441
00:16:08,160 --> 00:16:12,480
are also building an in-memory high

442
00:16:10,560 --> 00:16:15,758
performance

443
00:16:12,480 --> 00:16:18,079
graph index that will allow

444
00:16:15,759 --> 00:16:18,959
fast reachability queries on top of huge

445
00:16:18,079 --> 00:16:21,920
graphs if you

446
00:16:18,959 --> 00:16:22,959
take maven uh for example we're

447
00:16:21,920 --> 00:16:25,599
expecting

448
00:16:22,959 --> 00:16:27,119
because it has already millions of

449
00:16:25,600 --> 00:16:29,040
packages package releases

450
00:16:27,120 --> 00:16:31,360
we're expecting billions of nodes and

451
00:16:29,040 --> 00:16:32,880
perhaps hundreds of billions of hedges

452
00:16:31,360 --> 00:16:34,880
so it's very important to have a custom

453
00:16:32,880 --> 00:16:38,639
query layer to do propagation

454
00:16:34,880 --> 00:16:41,680
analysis then we have

455
00:16:38,639 --> 00:16:45,120
this metadata database and we augment

456
00:16:41,680 --> 00:16:45,599
with data that's coming from sources

457
00:16:45,120 --> 00:16:47,440
that are

458
00:16:45,600 --> 00:16:48,800
part of the community one of them is

459
00:16:47,440 --> 00:16:49,759
clearly defined we're going to have a

460
00:16:48,800 --> 00:16:52,240
talk about that

461
00:16:49,759 --> 00:16:53,839
afterwards another one is from g8

462
00:16:52,240 --> 00:16:55,680
storage which is a tool that collects

463
00:16:53,839 --> 00:16:57,519
all data from github and we do some

464
00:16:55,680 --> 00:16:59,359
analysis on top of that

465
00:16:57,519 --> 00:17:00,880
and we also try to collect vulnerability

466
00:16:59,360 --> 00:17:02,639
information from open sources

467
00:17:00,880 --> 00:17:04,240
sneak is not currently an open source

468
00:17:02,639 --> 00:17:08,480
but for some reason i have the

469
00:17:04,240 --> 00:17:10,400
logo here so but the other ones are open

470
00:17:08,480 --> 00:17:12,400
so we will we are trying to collect this

471
00:17:10,400 --> 00:17:13,839
and basically annotate

472
00:17:12,400 --> 00:17:16,160
the appropriate location either a

473
00:17:13,839 --> 00:17:18,399
function or a file or a package with

474
00:17:16,160 --> 00:17:21,839
information from all those

475
00:17:18,400 --> 00:17:24,880
sources another thing that we're

476
00:17:21,839 --> 00:17:26,159
trying to do is to try to come up with a

477
00:17:24,880 --> 00:17:30,160
bill of materials

478
00:17:26,160 --> 00:17:32,480
which was a very hot topic today

479
00:17:30,160 --> 00:17:34,000
at least in the meeting rooms that i was

480
00:17:32,480 --> 00:17:35,919
and

481
00:17:34,000 --> 00:17:37,760
basically get information about that and

482
00:17:35,919 --> 00:17:40,240
annotate our metadata

483
00:17:37,760 --> 00:17:41,679
and this we do by building the actual

484
00:17:40,240 --> 00:17:43,919
packages

485
00:17:41,679 --> 00:17:45,600
and on top of our two databases we have

486
00:17:43,919 --> 00:17:46,000
a custom query layer that allows to

487
00:17:45,600 --> 00:17:47,760
combine

488
00:17:46,000 --> 00:17:50,000
data from between the two for example if

489
00:17:47,760 --> 00:17:52,960
you want to get a call graph

490
00:17:50,000 --> 00:17:54,400
for you know five dependencies you can

491
00:17:52,960 --> 00:17:56,640
give it a dependency tree

492
00:17:54,400 --> 00:17:58,840
and it will try get individual progress

493
00:17:56,640 --> 00:18:00,080
for the packages and stitch them

494
00:17:58,840 --> 00:18:01,840
together

495
00:18:00,080 --> 00:18:03,360
in order to come up with a global call

496
00:18:01,840 --> 00:18:05,439
graph

497
00:18:03,360 --> 00:18:07,520
the analysis sit on top of course the

498
00:18:05,440 --> 00:18:08,960
query language and there is a rest api

499
00:18:07,520 --> 00:18:10,000
that will allow the package managers

500
00:18:08,960 --> 00:18:13,679
basically to get

501
00:18:10,000 --> 00:18:16,400
information from all those sources

502
00:18:13,679 --> 00:18:17,520
so the streaming sources which is

503
00:18:16,400 --> 00:18:20,640
basically

504
00:18:17,520 --> 00:18:21,280
updated as new packages come in will be

505
00:18:20,640 --> 00:18:24,000
available

506
00:18:21,280 --> 00:18:26,960
also to the public you can take a look

507
00:18:24,000 --> 00:18:26,960
at the code feeder project

508
00:18:27,200 --> 00:18:31,280
relatively soon hopefully in a couple of

509
00:18:28,960 --> 00:18:31,280
months

510
00:18:31,360 --> 00:18:35,840
now how question that arises is how we

511
00:18:34,080 --> 00:18:38,240
identify

512
00:18:35,840 --> 00:18:39,760
a function uniquely so what is the node

513
00:18:38,240 --> 00:18:41,200
in our project in our project is

514
00:18:39,760 --> 00:18:43,280
basically a function

515
00:18:41,200 --> 00:18:45,200
so how we identify function uniquely

516
00:18:43,280 --> 00:18:46,320
across everything we design the custom

517
00:18:45,200 --> 00:18:48,320
protocol

518
00:18:46,320 --> 00:18:52,240
to support that we have a grammar to

519
00:18:48,320 --> 00:18:52,240
validate of course those urls and so on

520
00:18:52,880 --> 00:18:56,400
the core technology that you are using

521
00:18:54,480 --> 00:19:00,000
we call it call graph stating

522
00:18:56,400 --> 00:19:03,280
what happens is that what we want to do

523
00:19:00,000 --> 00:19:06,000
is to only build a call graph

524
00:19:03,280 --> 00:19:07,520
a per package version so usually call

525
00:19:06,000 --> 00:19:09,679
graph generators what they do is that

526
00:19:07,520 --> 00:19:13,360
they build the whole project first

527
00:19:09,679 --> 00:19:16,799
and then they try to explore it

528
00:19:13,360 --> 00:19:19,678
to come up with nodes and you know

529
00:19:16,799 --> 00:19:21,600
draw edges between the nodes and if you

530
00:19:19,679 --> 00:19:23,360
scale that up to the maven scale for

531
00:19:21,600 --> 00:19:25,120
example what you will be doing is

532
00:19:23,360 --> 00:19:26,479
analyzing the same thing over and over

533
00:19:25,120 --> 00:19:29,600
and over again because there are

534
00:19:26,480 --> 00:19:30,320
lots of packages that are reused log4j

535
00:19:29,600 --> 00:19:33,439
for example

536
00:19:30,320 --> 00:19:34,320
slf for day projects like that all right

537
00:19:33,440 --> 00:19:37,200
so what we do

538
00:19:34,320 --> 00:19:38,559
is instead of doing that we analyze all

539
00:19:37,200 --> 00:19:40,240
packages spare packets

540
00:19:38,559 --> 00:19:41,918
at the package package version level

541
00:19:40,240 --> 00:19:43,600
sorry we create a caller for that we

542
00:19:41,919 --> 00:19:45,600
annotate the extension points

543
00:19:43,600 --> 00:19:46,959
and then we load them and link them

544
00:19:45,600 --> 00:19:49,520
together

545
00:19:46,960 --> 00:19:52,559
okay that's on request and we call this

546
00:19:49,520 --> 00:19:54,320
process call graph teaching

547
00:19:52,559 --> 00:19:56,480
this is how our choreographers look like

548
00:19:54,320 --> 00:19:59,120
so we have designed the format

549
00:19:56,480 --> 00:19:59,520
to basically exchange chord graphs get

550
00:19:59,120 --> 00:20:00,719
the

551
00:19:59,520 --> 00:20:03,120
information from the chord graph

552
00:20:00,720 --> 00:20:04,080
generator and put it into our metadata

553
00:20:03,120 --> 00:20:06,559
database

554
00:20:04,080 --> 00:20:07,760
but this is part of the open data that

555
00:20:06,559 --> 00:20:11,200
we'll be releasing

556
00:20:07,760 --> 00:20:13,280
relatively soon so it records

557
00:20:11,200 --> 00:20:15,440
information about the class hierarchy

558
00:20:13,280 --> 00:20:18,158
the graph itself which is basically you

559
00:20:15,440 --> 00:20:19,840
know an adjacency list

560
00:20:18,159 --> 00:20:22,720
and information about the products that

561
00:20:19,840 --> 00:20:22,720
we are analyzing

562
00:20:23,039 --> 00:20:29,280
now how can we use this

563
00:20:26,559 --> 00:20:30,639
one particular paint problem that i have

564
00:20:29,280 --> 00:20:32,480
described is basically how we do

565
00:20:30,640 --> 00:20:34,640
dependency updates

566
00:20:32,480 --> 00:20:35,760
so the prototype that i will be uh

567
00:20:34,640 --> 00:20:37,919
showing here is

568
00:20:35,760 --> 00:20:39,440
not based on fast and currently but it

569
00:20:37,919 --> 00:20:42,880
will be based on fasting in

570
00:20:39,440 --> 00:20:45,280
its immediate release next version

571
00:20:42,880 --> 00:20:46,880
so what people usually do in order to do

572
00:20:45,280 --> 00:20:48,240
dependency updates is that they use

573
00:20:46,880 --> 00:20:50,159
dependable

574
00:20:48,240 --> 00:20:51,919
this is the default tool on github it

575
00:20:50,159 --> 00:20:55,039
was actually acquired by github

576
00:20:51,919 --> 00:20:57,760
a couple of months ago pretty successful

577
00:20:55,039 --> 00:21:00,158
2 million pull requests and so on what

578
00:20:57,760 --> 00:21:02,158
dependable and similar tools

579
00:21:00,159 --> 00:21:04,480
do in order to ensure updates is that

580
00:21:02,159 --> 00:21:06,640
they run the tests

581
00:21:04,480 --> 00:21:07,760
and they have some well in the

582
00:21:06,640 --> 00:21:11,200
description of

583
00:21:07,760 --> 00:21:13,679
all those bots is that you run your

584
00:21:11,200 --> 00:21:15,120
test suites and this assures you that

585
00:21:13,679 --> 00:21:17,039
well the dependency update will be

586
00:21:15,120 --> 00:21:20,719
successful

587
00:21:17,039 --> 00:21:20,720
who thinks that this is a good strategy

588
00:21:21,919 --> 00:21:31,840
only one hand okay what do you think why

589
00:21:24,960 --> 00:21:31,840
is not a good strategy

590
00:21:32,799 --> 00:21:37,679
it's not testing transitive dependencies

591
00:21:35,440 --> 00:21:39,120
is it testing direct dependencies

592
00:21:37,679 --> 00:21:41,520
are we testing direct dependencies what

593
00:21:39,120 --> 00:21:41,520
do we think

594
00:21:43,280 --> 00:21:47,440
oh we don't have to think a lot also in

595
00:21:45,760 --> 00:21:50,799
interest of time we have done this

596
00:21:47,440 --> 00:21:52,720
for around 500 projects and

597
00:21:50,799 --> 00:21:55,520
what we did is that we measured function

598
00:21:52,720 --> 00:21:58,000
coverage and by faction coverage we mean

599
00:21:55,520 --> 00:21:59,280
uh whether there if there is a function

600
00:21:58,000 --> 00:22:01,600
that links into

601
00:21:59,280 --> 00:22:03,678
a call to a dependency does this line

602
00:22:01,600 --> 00:22:05,439
get executed while we're running tests

603
00:22:03,679 --> 00:22:07,760
so we instrumented the jvm while the

604
00:22:05,440 --> 00:22:10,559
tests were running and we tried to find

605
00:22:07,760 --> 00:22:11,679
from all the dependency calls from all

606
00:22:10,559 --> 00:22:14,799
the calls basically

607
00:22:11,679 --> 00:22:18,080
how many of those were executed during

608
00:22:14,799 --> 00:22:19,520
a test run in the case of direct

609
00:22:18,080 --> 00:22:20,080
dependencies actually it was not that

610
00:22:19,520 --> 00:22:23,120
bad

611
00:22:20,080 --> 00:22:24,799
to our surprise it was around 60 percent

612
00:22:23,120 --> 00:22:26,239
of direct dependency calls are being

613
00:22:24,799 --> 00:22:28,158
executed by this

614
00:22:26,240 --> 00:22:30,799
but if you factor in transitive

615
00:22:28,159 --> 00:22:33,520
dependencies it's like only 20

616
00:22:30,799 --> 00:22:35,200
so of the all the paths basically that

617
00:22:33,520 --> 00:22:35,760
lead into transitive dependencies only

618
00:22:35,200 --> 00:22:39,120
20

619
00:22:35,760 --> 00:22:40,720
are basically being executed not a great

620
00:22:39,120 --> 00:22:42,559
scenario

621
00:22:40,720 --> 00:22:44,159
okay because most of the updates will

622
00:22:42,559 --> 00:22:45,360
happen statistically will happen in the

623
00:22:44,159 --> 00:22:48,559
transitive set not in

624
00:22:45,360 --> 00:22:51,439
your direct dependency set all right

625
00:22:48,559 --> 00:22:51,440
so what we do

626
00:22:51,679 --> 00:22:58,240
is that we take to

627
00:22:55,280 --> 00:22:59,600
dependency versions we do a source level

628
00:22:58,240 --> 00:23:00,860
astd

629
00:22:59,600 --> 00:23:03,280
using a tool from

630
00:23:00,860 --> 00:23:06,399
[Music]

631
00:23:03,280 --> 00:23:07,760
spoon yes what spoon allows us to do is

632
00:23:06,400 --> 00:23:10,960
to come up with a list of

633
00:23:07,760 --> 00:23:14,080
precise changes at the function level so

634
00:23:10,960 --> 00:23:16,720
what we get is information like this

635
00:23:14,080 --> 00:23:17,520
if statement change the condition from x

636
00:23:16,720 --> 00:23:19,360
to z

637
00:23:17,520 --> 00:23:20,840
something like that so we get a very

638
00:23:19,360 --> 00:23:24,240
detailed list of

639
00:23:20,840 --> 00:23:25,918
changes then we build the call graph

640
00:23:24,240 --> 00:23:27,600
and then we try to see whether from the

641
00:23:25,919 --> 00:23:29,200
functions that we have

642
00:23:27,600 --> 00:23:30,639
into the updated dependency said there

643
00:23:29,200 --> 00:23:32,640
is a direct path

644
00:23:30,640 --> 00:23:34,559
back to the develop back to the project

645
00:23:32,640 --> 00:23:37,039
that we are analyzing

646
00:23:34,559 --> 00:23:40,158
okay this is basically some um easy form

647
00:23:37,039 --> 00:23:40,158
of reachability analysis

648
00:23:40,480 --> 00:23:44,880
in order to test this idea um we took

649
00:23:43,360 --> 00:23:48,240
sample requests on

650
00:23:44,880 --> 00:23:49,760
from dependable very fresh ones we

651
00:23:48,240 --> 00:23:52,080
have a product called jh torrent that

652
00:23:49,760 --> 00:23:53,679
collects data live from github so we

653
00:23:52,080 --> 00:23:55,600
mine very recent pull requests from

654
00:23:53,679 --> 00:23:58,080
dependable

655
00:23:55,600 --> 00:23:59,360
and you know what dependable tells you

656
00:23:58,080 --> 00:24:02,559
is that there is

657
00:23:59,360 --> 00:24:05,439
this version here that updated

658
00:24:02,559 --> 00:24:07,440
from this you know he only did a minor

659
00:24:05,440 --> 00:24:08,960
it's not even a minor it's a

660
00:24:07,440 --> 00:24:10,720
you know a patch version that changed

661
00:24:08,960 --> 00:24:11,520
right so theoretically you wouldn't

662
00:24:10,720 --> 00:24:14,400
expect

663
00:24:11,520 --> 00:24:14,400
a ton of changes

664
00:24:15,200 --> 00:24:18,880
this is the comment that we actually

665
00:24:17,440 --> 00:24:21,440
inserted into the dependable

666
00:24:18,880 --> 00:24:22,000
request what we can see here is that yes

667
00:24:21,440 --> 00:24:24,799
it is

668
00:24:22,000 --> 00:24:25,760
indeed a patch version that changed but

669
00:24:24,799 --> 00:24:30,080
we found that

670
00:24:25,760 --> 00:24:33,760
uh 773 functions actually changed or

671
00:24:30,080 --> 00:24:37,600
84 of which are actually affecting

672
00:24:33,760 --> 00:24:40,799
our own code okay

673
00:24:37,600 --> 00:24:44,840
and what we do is that we have

674
00:24:40,799 --> 00:24:49,440
information about the paths that were

675
00:24:44,840 --> 00:24:49,439
affected and also um

676
00:24:49,600 --> 00:24:54,399
basically the the paths and the

677
00:24:51,360 --> 00:24:57,199
functions that assemble functions that

678
00:24:54,400 --> 00:24:57,200
allows us to

679
00:24:57,520 --> 00:25:02,240
allow the developer basically to see

680
00:25:00,240 --> 00:25:05,600
what the problem

681
00:25:02,240 --> 00:25:05,600
where the problem in their code is

682
00:25:06,320 --> 00:25:10,080
and you know we have also done some a

683
00:25:08,799 --> 00:25:13,679
bit more research

684
00:25:10,080 --> 00:25:15,039
and we try to evaluate let's say whether

685
00:25:13,679 --> 00:25:17,200
that error which is the name of the tool

686
00:25:15,039 --> 00:25:18,320
that we have developed actually detects

687
00:25:17,200 --> 00:25:21,360
the changes

688
00:25:18,320 --> 00:25:23,760
in terms of tests it was around 40 so we

689
00:25:21,360 --> 00:25:25,360
introduced artificial changes in the

690
00:25:23,760 --> 00:25:27,919
transitive dependency set

691
00:25:25,360 --> 00:25:29,600
in the case of tests it was around 40

692
00:25:27,919 --> 00:25:30,559
the detection rate in the case of data

693
00:25:29,600 --> 00:25:32,399
it was around

694
00:25:30,559 --> 00:25:34,240
90 something percent so it's way more

695
00:25:32,400 --> 00:25:36,320
precise

696
00:25:34,240 --> 00:25:37,600
this part here is uh basically

697
00:25:36,320 --> 00:25:41,120
represents reflection

698
00:25:37,600 --> 00:25:44,158
so if you do reflection we're lost

699
00:25:41,120 --> 00:25:46,719
okay not simple as that

700
00:25:44,159 --> 00:25:47,760
anyway my time is up so i wanted to show

701
00:25:46,720 --> 00:25:50,480
you some

702
00:25:47,760 --> 00:25:52,080
how you know the fastest would look like

703
00:25:50,480 --> 00:25:54,320
in terms of developer workflow

704
00:25:52,080 --> 00:25:55,360
think about this update scenario that i

705
00:25:54,320 --> 00:25:58,879
presented

706
00:25:55,360 --> 00:25:58,879
being integrated into pip

707
00:26:00,000 --> 00:26:10,480
yeah now let's let's send it there just

708
00:26:02,640 --> 00:26:12,000
to give

709
00:26:10,480 --> 00:26:14,080
so if you want to know more information

710
00:26:12,000 --> 00:26:16,080
about the project it's here um we are

711
00:26:14,080 --> 00:26:17,600
running cultural survey about dependency

712
00:26:16,080 --> 00:26:20,639
management if you want to help us

713
00:26:17,600 --> 00:26:23,279
and this is the url over there so

714
00:26:20,640 --> 00:26:25,039
and we are will be around four questions

715
00:26:23,279 --> 00:26:28,880
and so on

716
00:26:25,039 --> 00:26:30,559
thank you any questions

717
00:26:28,880 --> 00:26:32,960
yes are you actually doing binary

718
00:26:30,559 --> 00:26:32,960
analysis

719
00:26:34,960 --> 00:26:38,799
we're we are doing choreographer for

720
00:26:37,600 --> 00:26:42,559
debian binaries yes

721
00:26:38,799 --> 00:26:42,559
using cisco and svf

722
00:26:44,080 --> 00:26:47,360
so one of the examples you had mentioned

723
00:26:45,679 --> 00:26:50,400
was that you could use the

724
00:26:47,360 --> 00:26:53,840
call graph level dependency graph

725
00:26:50,400 --> 00:26:55,440
as a false positive producer or uh

726
00:26:53,840 --> 00:26:56,480
impact analysis when you make a breaking

727
00:26:55,440 --> 00:26:59,120
change so you can tell if you're

728
00:26:56,480 --> 00:27:00,880
actually using the part of the library

729
00:26:59,120 --> 00:27:02,239
did you also do that when you were

730
00:27:00,880 --> 00:27:05,039
analyzing whether or not

731
00:27:02,240 --> 00:27:06,320
the downstream packages were testing

732
00:27:05,039 --> 00:27:09,440
their dependencies

733
00:27:06,320 --> 00:27:11,520
no no but

734
00:27:09,440 --> 00:27:13,360
that's a very good suggestion basically

735
00:27:11,520 --> 00:27:15,760
actually we submitted this specific

736
00:27:13,360 --> 00:27:17,360
paper like a couple of days ago

737
00:27:15,760 --> 00:27:18,960
yesterday when i was putting the sludge

738
00:27:17,360 --> 00:27:20,559
together you know

739
00:27:18,960 --> 00:27:22,000
it can it just crossed my mind so we

740
00:27:20,559 --> 00:27:24,720
didn't really change

741
00:27:22,000 --> 00:27:25,360
the result yeah yeah yeah yeah yeah i

742
00:27:24,720 --> 00:27:27,039
mean we

743
00:27:25,360 --> 00:27:28,879
could add this information in the report

744
00:27:27,039 --> 00:27:29,200
that we in the comments that we do in

745
00:27:28,880 --> 00:27:30,720
the

746
00:27:29,200 --> 00:27:35,840
independent request and it would be very

747
00:27:30,720 --> 00:27:35,840
helpful actually

748
00:27:40,060 --> 00:27:43,139
[Music]

749
00:27:43,200 --> 00:27:46,720
we don't do that because we expect the

750
00:27:45,120 --> 00:27:48,158
compiler to be able to do that in

751
00:27:46,720 --> 00:27:50,399
compiled languages

752
00:27:48,159 --> 00:27:51,679
and so if you compile with a new version

753
00:27:50,399 --> 00:27:53,439
you know there's an api

754
00:27:51,679 --> 00:27:55,120
that breaks the compiler will tell you

755
00:27:53,440 --> 00:27:57,120
but you know that's valuable for

756
00:27:55,120 --> 00:28:00,239
languages that don't have a compiler

757
00:27:57,120 --> 00:28:00,239
but we don't do that currently

758
00:28:00,720 --> 00:28:03,840
yes at the moment guys

759
00:28:26,559 --> 00:28:31,440
yes the usually the

760
00:28:29,679 --> 00:28:33,279
what you do with static analysis is you

761
00:28:31,440 --> 00:28:35,440
tend to over approximate

762
00:28:33,279 --> 00:28:37,760
which will generate some false positives

763
00:28:35,440 --> 00:28:39,279
but for use cases like security for

764
00:28:37,760 --> 00:28:41,440
example it's better to have

765
00:28:39,279 --> 00:28:42,720
false positives than you know false

766
00:28:41,440 --> 00:28:44,960
negatives because it gives

767
00:28:42,720 --> 00:28:45,760
a wrong impression to the developers so

768
00:28:44,960 --> 00:28:47,200
the

769
00:28:45,760 --> 00:28:49,200
direct answer to your question is that

770
00:28:47,200 --> 00:28:51,440
we don't have new features we basically

771
00:28:49,200 --> 00:28:51,440
let it

772
00:28:57,120 --> 00:29:01,039
bigger explode expanding the number of

773
00:29:00,320 --> 00:29:03,360
languages

774
00:29:01,039 --> 00:29:05,120
and things that you cover the biggest

775
00:29:03,360 --> 00:29:05,760
challenge is that core graph generation

776
00:29:05,120 --> 00:29:07,600
is not

777
00:29:05,760 --> 00:29:10,320
a solved problem it's actually an

778
00:29:07,600 --> 00:29:12,320
unsolvable problem to be precise

779
00:29:10,320 --> 00:29:13,678
because you can never you can never be

780
00:29:12,320 --> 00:29:17,360
100

781
00:29:13,679 --> 00:29:20,000
um sound by definition

782
00:29:17,360 --> 00:29:21,120
uh so the better the tooling the more

783
00:29:20,000 --> 00:29:23,039
assurances

784
00:29:21,120 --> 00:29:24,799
we can give to the developers so

785
00:29:23,039 --> 00:29:27,440
languages like java for example they

786
00:29:24,799 --> 00:29:29,120
call of status there is pretty good

787
00:29:27,440 --> 00:29:30,799
languages like pythons that are

788
00:29:29,120 --> 00:29:31,199
javascript that even worse basically

789
00:29:30,799 --> 00:29:33,918
that

790
00:29:31,200 --> 00:29:41,840
are completely dynamic there is so much

791
00:29:33,919 --> 00:29:41,840
that we can do with static analysis

792
00:29:48,960 --> 00:29:54,240
yes one one plan we have is to

793
00:29:52,320 --> 00:29:55,918
because we're doing doing that at the

794
00:29:54,240 --> 00:29:58,480
massive scale

795
00:29:55,919 --> 00:29:59,200
to actually run the tests uh in all the

796
00:29:58,480 --> 00:30:01,440
projects

797
00:29:59,200 --> 00:30:03,679
and in many cases the tests allow you to

798
00:30:01,440 --> 00:30:05,120
allow projects to execute reflection

799
00:30:03,679 --> 00:30:07,200
paths paths that are affected by

800
00:30:05,120 --> 00:30:09,360
reflection so we will take those

801
00:30:07,200 --> 00:30:10,320
edges basically and put them into our

802
00:30:09,360 --> 00:30:12,080
call graph so our

803
00:30:10,320 --> 00:30:13,600
graph will be richer by running the

804
00:30:12,080 --> 00:30:15,600
tests across all projects

805
00:30:13,600 --> 00:30:17,439
and we also plan to actually crowdsource

806
00:30:15,600 --> 00:30:20,559
the test running so

807
00:30:17,440 --> 00:30:21,679
allow people that have the use our

808
00:30:20,559 --> 00:30:23,120
tooling basically to

809
00:30:21,679 --> 00:30:25,120
upload part of the call graph that is

810
00:30:23,120 --> 00:30:29,678
not you know in their own code base

811
00:30:25,120 --> 00:30:29,678
uh back to our database

812
00:30:30,640 --> 00:30:33,840
there's so much we can do with

813
00:30:31,760 --> 00:30:36,559
reflection as well um there have been

814
00:30:33,840 --> 00:30:39,918
people that are doing that in

815
00:30:36,559 --> 00:30:40,240
java with toolkits like dupe but it is

816
00:30:39,919 --> 00:30:45,600
not

817
00:30:40,240 --> 00:30:45,600
extremely scalable and also it relies on

818
00:30:48,840 --> 00:30:51,840
heuristics

819
00:30:53,120 --> 00:30:55,199
you

