1
00:00:05,200 --> 00:00:08,240
so

2
00:00:05,680 --> 00:00:10,399
our next speaker is going to introduce

3
00:00:08,240 --> 00:00:16,960
himself and his topic for now so a big

4
00:00:10,400 --> 00:00:18,800
round of applause

5
00:00:16,960 --> 00:00:21,119
thank you all for coming my name is

6
00:00:18,800 --> 00:00:23,039
rafael gomez i work at octobus

7
00:00:21,119 --> 00:00:24,800
we're a small consulting company

8
00:00:23,039 --> 00:00:27,840
specialized on mercurial

9
00:00:24,800 --> 00:00:31,439
um i'm going to talk about how we use

10
00:00:27,840 --> 00:00:33,760
python and rust together in this big

11
00:00:31,439 --> 00:00:34,960
old project when i say oldest like an

12
00:00:33,760 --> 00:00:37,839
old code base

13
00:00:34,960 --> 00:00:39,920
and what were the pain points and how we

14
00:00:37,840 --> 00:00:42,719
fixed them with some of them

15
00:00:39,920 --> 00:00:44,879
so as a recap for people who don't know

16
00:00:42,719 --> 00:00:46,800
what mercurial is they're few of them

17
00:00:44,879 --> 00:00:48,160
it's a version control system same

18
00:00:46,800 --> 00:00:49,680
generation as git it

19
00:00:48,160 --> 00:00:53,038
actually was made in the same month of

20
00:00:49,680 --> 00:00:56,160
april 2005 by a kernel developer

21
00:00:53,039 --> 00:00:58,800
it's written mostly in python it has a

22
00:00:56,160 --> 00:01:01,839
decent chunk of c extensions for

23
00:00:58,800 --> 00:01:03,599
mainly for speed um it handles

24
00:01:01,840 --> 00:01:05,600
huge repositories for companies like

25
00:01:03,600 --> 00:01:08,080
facebook and mozilla for example

26
00:01:05,600 --> 00:01:08,960
with millions of files and revisions and

27
00:01:08,080 --> 00:01:10,560
it has a very

28
00:01:08,960 --> 00:01:12,479
interesting and powerful extension

29
00:01:10,560 --> 00:01:14,400
system which i have very little time to

30
00:01:12,479 --> 00:01:16,080
talk about so maybe i'll have like a few

31
00:01:14,400 --> 00:01:17,600
snippets it's very cool check it out on

32
00:01:16,080 --> 00:01:19,679
your own

33
00:01:17,600 --> 00:01:21,600
but we're here to talk about rust and

34
00:01:19,680 --> 00:01:23,200
why we chose rust for

35
00:01:21,600 --> 00:01:24,880
mercurial because we just said that we

36
00:01:23,200 --> 00:01:27,920
have like 40 000 lines of c

37
00:01:24,880 --> 00:01:29,280
code in in mercurial so why switch to

38
00:01:27,920 --> 00:01:32,640
rust why move

39
00:01:29,280 --> 00:01:33,840
um so most of you know what rust is and

40
00:01:32,640 --> 00:01:35,840
why it's pretty good so

41
00:01:33,840 --> 00:01:37,920
i'll keep this short basically it has a

42
00:01:35,840 --> 00:01:40,799
better signal to noise ratio for us

43
00:01:37,920 --> 00:01:42,159
you have few fewer lines that are

44
00:01:40,799 --> 00:01:43,119
completely orthogonal to what you're

45
00:01:42,159 --> 00:01:45,920
trying to do and

46
00:01:43,119 --> 00:01:47,439
you get in focus on actually you know

47
00:01:45,920 --> 00:01:49,840
making the algorithm that you need

48
00:01:47,439 --> 00:01:51,839
to fix the issue um the compile-time

49
00:01:49,840 --> 00:01:55,040
guarantees are interesting for vcs

50
00:01:51,840 --> 00:01:59,280
um cargo and formatting

51
00:01:55,040 --> 00:02:01,520
and the testing framework all very nice

52
00:01:59,280 --> 00:02:02,560
and the save by default aspect is very

53
00:02:01,520 --> 00:02:05,679
reassuring

54
00:02:02,560 --> 00:02:06,000
um but i think that's no news for any of

55
00:02:05,680 --> 00:02:09,360
you

56
00:02:06,000 --> 00:02:12,160
um so i'm going to skip uh right into

57
00:02:09,360 --> 00:02:13,040
the performance aspect so there was an

58
00:02:12,160 --> 00:02:16,480
experiment

59
00:02:13,040 --> 00:02:19,679
by valentine's guest who's a

60
00:02:16,480 --> 00:02:24,000
developer at jane street

61
00:02:19,680 --> 00:02:27,360
and he he built a very small subset

62
00:02:24,000 --> 00:02:30,000
of the status command uh in pure rus

63
00:02:27,360 --> 00:02:31,920
so it's it's not complete it does just a

64
00:02:30,000 --> 00:02:33,360
little bit of what status does

65
00:02:31,920 --> 00:02:35,440
but it was good enough for their

66
00:02:33,360 --> 00:02:36,080
purposes and as you can see the

67
00:02:35,440 --> 00:02:38,480
performance

68
00:02:36,080 --> 00:02:41,280
is is just miles better from the pi

69
00:02:38,480 --> 00:02:42,959
reference python and c implementation

70
00:02:41,280 --> 00:02:44,720
so that that that sparked a lot of

71
00:02:42,959 --> 00:02:49,360
interest in the community

72
00:02:44,720 --> 00:02:51,359
and uh als although the the um

73
00:02:49,360 --> 00:02:53,120
the plan to introduce rust within

74
00:02:51,360 --> 00:02:56,400
mercurial was already put in place

75
00:02:53,120 --> 00:02:58,239
maybe a year before that um it really

76
00:02:56,400 --> 00:02:59,280
was about around this time that we

77
00:02:58,239 --> 00:03:01,440
really started to

78
00:02:59,280 --> 00:03:02,959
to put it to use um and to really dig

79
00:03:01,440 --> 00:03:04,560
into it

80
00:03:02,959 --> 00:03:06,640
so there are many different ways of

81
00:03:04,560 --> 00:03:09,280
connecting python and rust together

82
00:03:06,640 --> 00:03:11,518
um i'm not going to go into detail as to

83
00:03:09,280 --> 00:03:12,959
why exactly we chose rusty python it

84
00:03:11,519 --> 00:03:15,920
compiles on rust stable

85
00:03:12,959 --> 00:03:16,879
all right that's it there you go um it's

86
00:03:15,920 --> 00:03:19,280
composed of two

87
00:03:16,879 --> 00:03:20,879
crates the first one being a very low

88
00:03:19,280 --> 00:03:22,720
level crate that just binds to the c

89
00:03:20,879 --> 00:03:24,560
python abi and does all of the

90
00:03:22,720 --> 00:03:26,000
tedious work that you really don't want

91
00:03:24,560 --> 00:03:29,440
to be doing by hand

92
00:03:26,000 --> 00:03:32,640
and a higher level crate that is more

93
00:03:29,440 --> 00:03:34,640
functional in in the sense of

94
00:03:32,640 --> 00:03:36,559
exposing a module to python that just

95
00:03:34,640 --> 00:03:38,798
looks like a python module from rust

96
00:03:36,560 --> 00:03:40,319
creating classes functions that kind of

97
00:03:38,799 --> 00:03:43,840
stuff you have an eval function

98
00:03:40,319 --> 00:03:47,440
which is pretty useful sometimes

99
00:03:43,840 --> 00:03:51,120
um so that gives the following structure

100
00:03:47,440 --> 00:03:52,319
um so for people who are not using c

101
00:03:51,120 --> 00:03:55,519
python i'm sorry but

102
00:03:52,319 --> 00:03:57,439
there you go um pure python code

103
00:03:55,519 --> 00:03:59,840
of course talks to its back end the c

104
00:03:57,439 --> 00:04:02,079
extensions also talk to c python and

105
00:03:59,840 --> 00:04:04,080
from the rough side we chose a

106
00:04:02,080 --> 00:04:05,599
well i should say we just before i came

107
00:04:04,080 --> 00:04:07,360
into the project this structure was

108
00:04:05,599 --> 00:04:10,640
chosen of of using

109
00:04:07,360 --> 00:04:14,720
two separate crates this one hd core

110
00:04:10,640 --> 00:04:16,000
um is a self-contained mercurial library

111
00:04:14,720 --> 00:04:18,399
with no

112
00:04:16,000 --> 00:04:19,358
idea whatsoever that there's a python

113
00:04:18,399 --> 00:04:21,120
somewhere

114
00:04:19,358 --> 00:04:23,520
the idea is to have it self-contained

115
00:04:21,120 --> 00:04:26,639
and it should work on its own

116
00:04:23,520 --> 00:04:29,599
and agc python is one of the crates that

117
00:04:26,639 --> 00:04:30,639
we have which is like way more developed

118
00:04:29,600 --> 00:04:32,560
than the others because

119
00:04:30,639 --> 00:04:34,000
it's the more common one but it's one of

120
00:04:32,560 --> 00:04:34,320
the possible crates that you could have

121
00:04:34,000 --> 00:04:36,720
to

122
00:04:34,320 --> 00:04:37,440
bridge uh the python code and the and

123
00:04:36,720 --> 00:04:40,639
the

124
00:04:37,440 --> 00:04:42,400
the rust pure ross code so i was very

125
00:04:40,639 --> 00:04:43,759
excited to start working on on this

126
00:04:42,400 --> 00:04:45,039
because you know you get paid to to

127
00:04:43,759 --> 00:04:48,720
write rust so that's

128
00:04:45,040 --> 00:04:52,639
super cool and uh an open source rest

129
00:04:48,720 --> 00:04:54,560
um but it was not super convincing at

130
00:04:52,639 --> 00:04:56,320
first the first non-trivial

131
00:04:54,560 --> 00:04:57,759
program that i tried to write was about

132
00:04:56,320 --> 00:04:59,440
twice as slow

133
00:04:57,759 --> 00:05:01,280
as the reference implementation even

134
00:04:59,440 --> 00:05:04,400
though it was written rust and it was

135
00:05:01,280 --> 00:05:08,080
pretty sad and this is due to

136
00:05:04,400 --> 00:05:10,320
a couple of factors the main one being

137
00:05:08,080 --> 00:05:11,199
friction in general if you're trying to

138
00:05:10,320 --> 00:05:13,199
bridge

139
00:05:11,199 --> 00:05:14,800
two languages together you always have

140
00:05:13,199 --> 00:05:16,720
friction at the

141
00:05:14,800 --> 00:05:19,759
ffi layer you have a border within the

142
00:05:16,720 --> 00:05:22,160
two languages and you have to interface

143
00:05:19,759 --> 00:05:23,919
them they don't work the same way

144
00:05:22,160 --> 00:05:25,759
especially python and rust have like

145
00:05:23,919 --> 00:05:27,039
very different ways of handling memory

146
00:05:25,759 --> 00:05:29,919
and and thinking about

147
00:05:27,039 --> 00:05:30,479
ownership and that kind of stuff um so

148
00:05:29,919 --> 00:05:32,479
you

149
00:05:30,479 --> 00:05:33,758
you pay two prices you pay the the

150
00:05:32,479 --> 00:05:36,000
cognitive price

151
00:05:33,759 --> 00:05:37,520
the developer price i could say of the

152
00:05:36,000 --> 00:05:38,240
complex interface code that you have to

153
00:05:37,520 --> 00:05:41,120
write that is

154
00:05:38,240 --> 00:05:42,560
basically not it's it feels useless

155
00:05:41,120 --> 00:05:44,479
because you know that you're just trying

156
00:05:42,560 --> 00:05:46,160
to exchange data and that's it but you

157
00:05:44,479 --> 00:05:48,880
have to still write a lot of code

158
00:05:46,160 --> 00:05:50,160
to do this and it's not the main thing

159
00:05:48,880 --> 00:05:51,039
that you're trying to do but you still

160
00:05:50,160 --> 00:05:53,840
have to do it

161
00:05:51,039 --> 00:05:55,120
it's an engineering constraint and it's

162
00:05:53,840 --> 00:05:57,119
it's what you have to do

163
00:05:55,120 --> 00:05:58,160
but it's complex and and so it takes

164
00:05:57,120 --> 00:06:01,440
away

165
00:05:58,160 --> 00:06:02,639
some of your budget you have to think

166
00:06:01,440 --> 00:06:05,680
about all of those things

167
00:06:02,639 --> 00:06:06,160
and the fact of the matter is exchanging

168
00:06:05,680 --> 00:06:09,520
data

169
00:06:06,160 --> 00:06:11,360
in general is costly just having to

170
00:06:09,520 --> 00:06:13,280
allocate memory at all moving memory

171
00:06:11,360 --> 00:06:15,759
around looping on objects

172
00:06:13,280 --> 00:06:16,318
and just in general having the guild for

173
00:06:15,759 --> 00:06:18,000
example

174
00:06:16,319 --> 00:06:19,440
you cannot do those things in parallel

175
00:06:18,000 --> 00:06:21,600
because python

176
00:06:19,440 --> 00:06:23,919
has the guild so if you're trying to

177
00:06:21,600 --> 00:06:25,280
create an object in python you can

178
00:06:23,919 --> 00:06:27,280
do some of the stuff outside of the

179
00:06:25,280 --> 00:06:28,479
guild but but in the

180
00:06:27,280 --> 00:06:29,840
at the end of the day if you're trying

181
00:06:28,479 --> 00:06:31,680
to communicate with python you still

182
00:06:29,840 --> 00:06:34,159
have to have the guild so

183
00:06:31,680 --> 00:06:35,759
global interpreter for some people who

184
00:06:34,160 --> 00:06:39,039
don't know

185
00:06:35,759 --> 00:06:41,120
so i have an example on my laptop if i

186
00:06:39,039 --> 00:06:43,199
try to start a hundred thousand files

187
00:06:41,120 --> 00:06:45,520
in rust in parallel with hot kernel

188
00:06:43,199 --> 00:06:47,520
caches i get about 30 milliseconds of

189
00:06:45,520 --> 00:06:48,000
wall time which is pretty cool and then

190
00:06:47,520 --> 00:06:49,919
i try

191
00:06:48,000 --> 00:06:52,319
to give those results to the python

192
00:06:49,919 --> 00:06:53,520
layer in any meaningful way and i get an

193
00:06:52,319 --> 00:06:55,919
order of magnitude

194
00:06:53,520 --> 00:06:57,198
more on top of what i was trying to do

195
00:06:55,919 --> 00:06:59,359
completely negating

196
00:06:57,199 --> 00:07:00,240
the usefulness of doing it in the first

197
00:06:59,360 --> 00:07:02,479
place

198
00:07:00,240 --> 00:07:04,319
so that's that's you know pretty

199
00:07:02,479 --> 00:07:06,880
frustrating

200
00:07:04,319 --> 00:07:07,599
so we have many possible solutions one

201
00:07:06,880 --> 00:07:10,400
of them is

202
00:07:07,599 --> 00:07:11,680
to communicate with c directly with the

203
00:07:10,400 --> 00:07:14,318
c layer

204
00:07:11,680 --> 00:07:15,520
um there's a thing in the in the python

205
00:07:14,319 --> 00:07:19,039
standard library called

206
00:07:15,520 --> 00:07:22,159
capsules that allow you to share like a

207
00:07:19,039 --> 00:07:23,840
see an api of function pointers between

208
00:07:22,160 --> 00:07:25,919
c extensions and you can just target the

209
00:07:23,840 --> 00:07:27,840
c api with rust and use

210
00:07:25,919 --> 00:07:30,960
capsules to communicate with the c layer

211
00:07:27,840 --> 00:07:33,520
of python directly which is pretty cool

212
00:07:30,960 --> 00:07:36,318
you can exchange less data so in general

213
00:07:33,520 --> 00:07:37,919
move up an abstraction layer and maybe

214
00:07:36,319 --> 00:07:39,919
give the file name instead of the file

215
00:07:37,919 --> 00:07:42,560
contents and that kind of stuff

216
00:07:39,919 --> 00:07:43,599
and in general just do more in rust

217
00:07:42,560 --> 00:07:45,680
right

218
00:07:43,599 --> 00:07:46,800
um but to move up those abstraction

219
00:07:45,680 --> 00:07:49,199
layers you need

220
00:07:46,800 --> 00:07:50,639
support for features for for those

221
00:07:49,199 --> 00:07:53,680
abstractions

222
00:07:50,639 --> 00:07:54,560
so in rusty python we had a few missing

223
00:07:53,680 --> 00:07:56,879
features that were

224
00:07:54,560 --> 00:07:58,479
quite important first one of them was

225
00:07:56,879 --> 00:08:00,639
just a set in

226
00:07:58,479 --> 00:08:01,680
in in python it said is a very useful

227
00:08:00,639 --> 00:08:03,680
collection

228
00:08:01,680 --> 00:08:05,120
um that appears in a lot in the

229
00:08:03,680 --> 00:08:07,039
mercurial code base and there was just

230
00:08:05,120 --> 00:08:07,840
no way of interacting or creating a set

231
00:08:07,039 --> 00:08:10,080
from rust

232
00:08:07,840 --> 00:08:13,280
at that time so that's what we had to do

233
00:08:10,080 --> 00:08:15,680
that um supports for capsules so that

234
00:08:13,280 --> 00:08:18,080
just made like a pie capsule macro

235
00:08:15,680 --> 00:08:20,560
that would allow you to to get and

236
00:08:18,080 --> 00:08:23,520
create a capsule

237
00:08:20,560 --> 00:08:25,520
and then a few more hairy ones first one

238
00:08:23,520 --> 00:08:26,240
being inheritance for classes written in

239
00:08:25,520 --> 00:08:29,599
rust

240
00:08:26,240 --> 00:08:31,280
so you have a pi class macro in uh

241
00:08:29,599 --> 00:08:32,640
in rusty python that allows you to

242
00:08:31,280 --> 00:08:36,240
create a python class

243
00:08:32,640 --> 00:08:38,799
backed by rust collections or

244
00:08:36,240 --> 00:08:39,360
data in general and that's pretty cool

245
00:08:38,799 --> 00:08:42,079
but

246
00:08:39,360 --> 00:08:43,279
if your python code then tries to

247
00:08:42,080 --> 00:08:46,560
inherit from

248
00:08:43,279 --> 00:08:47,519
your rust backed class it will just

249
00:08:46,560 --> 00:08:49,279
crash and say no

250
00:08:47,519 --> 00:08:51,519
it's not a valid base type you cannot

251
00:08:49,279 --> 00:08:54,720
inherit from this

252
00:08:51,519 --> 00:08:57,360
and the reason is that

253
00:08:54,720 --> 00:08:59,040
the feature was not added because what

254
00:08:57,360 --> 00:09:00,080
happens if you forget to call the

255
00:08:59,040 --> 00:09:02,079
initializer

256
00:09:00,080 --> 00:09:03,600
what happens if if you inherit and you

257
00:09:02,080 --> 00:09:04,959
just don't call super like what

258
00:09:03,600 --> 00:09:07,519
what happens to the memory it's a

259
00:09:04,959 --> 00:09:09,760
complicated program because either you

260
00:09:07,519 --> 00:09:11,530
have some very strong runtime invariants

261
00:09:09,760 --> 00:09:12,800
or you just don't do it so that the

262
00:09:11,530 --> 00:09:15,920
[Music]

263
00:09:12,800 --> 00:09:17,680
um what was chosen was to just not do it

264
00:09:15,920 --> 00:09:19,439
so you have to use composition over

265
00:09:17,680 --> 00:09:20,239
inheritance which sounds good in theory

266
00:09:19,440 --> 00:09:21,839
but in practice

267
00:09:20,240 --> 00:09:24,080
it's just writing a lot of boilerplate

268
00:09:21,839 --> 00:09:27,360
code that adds an indirection

269
00:09:24,080 --> 00:09:28,720
and that method calls in python are

270
00:09:27,360 --> 00:09:30,560
pretty expensive so if you're trying to

271
00:09:28,720 --> 00:09:32,480
shave off milliseconds that that's not

272
00:09:30,560 --> 00:09:35,599
really helping

273
00:09:32,480 --> 00:09:38,240
so that's one of the issues that we have

274
00:09:35,600 --> 00:09:40,000
properties and the set adder so giving

275
00:09:38,240 --> 00:09:42,320
instance attributes

276
00:09:40,000 --> 00:09:44,320
uh to so instances of class so they

277
00:09:42,320 --> 00:09:46,640
could have attributes and properties

278
00:09:44,320 --> 00:09:48,160
it's a very common pattern in python so

279
00:09:46,640 --> 00:09:49,439
if you're trying to have a dropping

280
00:09:48,160 --> 00:09:52,399
replacement you just

281
00:09:49,440 --> 00:09:54,000
like change a class you can't because

282
00:09:52,399 --> 00:09:57,680
there's no support yet for

283
00:09:54,000 --> 00:09:59,360
properties and the last one i want to

284
00:09:57,680 --> 00:10:00,719
talk a bit more about it because i

285
00:09:59,360 --> 00:10:01,760
figured it's more interesting and it has

286
00:10:00,720 --> 00:10:04,399
to do with the

287
00:10:01,760 --> 00:10:05,279
the terrible joke in the in the

288
00:10:04,399 --> 00:10:08,480
presentation

289
00:10:05,279 --> 00:10:09,920
title um being iterators on russ

290
00:10:08,480 --> 00:10:12,959
collections and what that means

291
00:10:09,920 --> 00:10:13,920
is um you have any rus collection for

292
00:10:12,959 --> 00:10:16,160
example a vector

293
00:10:13,920 --> 00:10:17,680
to take a simple one and you want to

294
00:10:16,160 --> 00:10:20,880
share

295
00:10:17,680 --> 00:10:23,439
the reference to that object

296
00:10:20,880 --> 00:10:25,200
with python and rust at the same time to

297
00:10:23,440 --> 00:10:27,120
allow for

298
00:10:25,200 --> 00:10:28,959
a lower memory overhead better

299
00:10:27,120 --> 00:10:30,800
performance and just in general not

300
00:10:28,959 --> 00:10:33,439
moving the entire object through the ffi

301
00:10:30,800 --> 00:10:36,560
layer at once

302
00:10:33,440 --> 00:10:37,120
so what that means is that a python

303
00:10:36,560 --> 00:10:40,479
iterator

304
00:10:37,120 --> 00:10:43,120
in rust should behave the same way as

305
00:10:40,480 --> 00:10:43,600
a python iterator would which means that

306
00:10:43,120 --> 00:10:47,200
it has

307
00:10:43,600 --> 00:10:47,920
different rules about what you can and

308
00:10:47,200 --> 00:10:52,560
cannot do

309
00:10:47,920 --> 00:10:56,000
at runtime so if you're trying to mutate

310
00:10:52,560 --> 00:10:58,079
a uh if you're trying to to to mutate an

311
00:10:56,000 --> 00:10:58,959
iterator so calling next on a python

312
00:10:58,079 --> 00:11:01,439
iterator

313
00:10:58,959 --> 00:11:03,199
if you already have a reference to it is

314
00:11:01,440 --> 00:11:04,000
valid as long as you don't try to read

315
00:11:03,200 --> 00:11:07,200
the reference

316
00:11:04,000 --> 00:11:08,800
after that you you if you then try to

317
00:11:07,200 --> 00:11:10,399
read from the iterator it will

318
00:11:08,800 --> 00:11:12,000
get a runtime error and just said that

319
00:11:10,399 --> 00:11:13,279
something moved between the iterations

320
00:11:12,000 --> 00:11:16,240
or anything this is

321
00:11:13,279 --> 00:11:18,560
different from what rust does because

322
00:11:16,240 --> 00:11:21,040
rust would just not allow to have those

323
00:11:18,560 --> 00:11:22,160
two references one mutable one immutable

324
00:11:21,040 --> 00:11:24,480
at this at the same time

325
00:11:22,160 --> 00:11:25,760
in the first place at compile time so

326
00:11:24,480 --> 00:11:27,600
you have to use something called

327
00:11:25,760 --> 00:11:28,000
generational poisoning which is just

328
00:11:27,600 --> 00:11:31,200
basically

329
00:11:28,000 --> 00:11:35,360
keeping a counter of which generation of

330
00:11:31,200 --> 00:11:38,560
which of which reference um

331
00:11:35,360 --> 00:11:40,320
we were part of like so every older

332
00:11:38,560 --> 00:11:42,640
reference gets invalidated

333
00:11:40,320 --> 00:11:43,760
if you're moving something so that it's

334
00:11:42,640 --> 00:11:45,839
one of the

335
00:11:43,760 --> 00:11:47,040
ways that you can do it of course you

336
00:11:45,839 --> 00:11:48,560
have to tell the rust compiler that

337
00:11:47,040 --> 00:11:50,399
really has to let go of the memory

338
00:11:48,560 --> 00:11:51,760
because it's you're trying to push

339
00:11:50,399 --> 00:11:53,839
memory and to share it with something

340
00:11:51,760 --> 00:11:56,800
that has no control over which is like

341
00:11:53,839 --> 00:11:57,680
really not good in rust terms which is

342
00:11:56,800 --> 00:11:59,120
basically

343
00:11:57,680 --> 00:12:01,279
sharing the reference between the two

344
00:11:59,120 --> 00:12:03,920
languages

345
00:12:01,279 --> 00:12:04,720
so there was a proof of concept by my

346
00:12:03,920 --> 00:12:08,079
colleague george

347
00:12:04,720 --> 00:12:10,079
over here in june of last year

348
00:12:08,079 --> 00:12:11,599
there was upstream that i have streamed

349
00:12:10,079 --> 00:12:15,120
about a month later for

350
00:12:11,600 --> 00:12:15,920
a small but non-trivial data structure

351
00:12:15,120 --> 00:12:18,320
in rust

352
00:12:15,920 --> 00:12:20,319
um and since then it has been upstream

353
00:12:18,320 --> 00:12:21,760
by another material contributor in rusty

354
00:12:20,320 --> 00:12:23,519
python so it's something that you

355
00:12:21,760 --> 00:12:24,959
can use if you try to bridge the two

356
00:12:23,519 --> 00:12:29,279
languages you can use

357
00:12:24,959 --> 00:12:29,279
this system that we've put into place

358
00:12:29,360 --> 00:12:34,000
and it relies on a lifetime extension

359
00:12:32,720 --> 00:12:36,399
track

360
00:12:34,000 --> 00:12:38,160
so it means that you take in a lifetime

361
00:12:36,399 --> 00:12:41,120
and you just say this is static

362
00:12:38,160 --> 00:12:41,439
it's fine everything is okay and then

363
00:12:41,120 --> 00:12:44,160
you

364
00:12:41,440 --> 00:12:47,360
you have uh it's unsafe of course it is

365
00:12:44,160 --> 00:12:51,040
ffi it is unsafe but the invariant

366
00:12:47,360 --> 00:12:52,800
to have it not actually unsafe

367
00:12:51,040 --> 00:12:54,160
is pretty easy to uphold the only thing

368
00:12:52,800 --> 00:12:56,399
that you don't have like

369
00:12:54,160 --> 00:12:57,279
that you have to think about is to not

370
00:12:56,399 --> 00:13:00,399
move

371
00:12:57,279 --> 00:13:01,279
the to move the reference out of the

372
00:13:00,399 --> 00:13:03,120
boroscope

373
00:13:01,279 --> 00:13:05,200
which is like you don't have to do any

374
00:13:03,120 --> 00:13:06,000
manual dropping any any something very

375
00:13:05,200 --> 00:13:07,680
complicated you just

376
00:13:06,000 --> 00:13:09,519
have to not move it out of scope which

377
00:13:07,680 --> 00:13:10,880
is reasonably easy to do within the

378
00:13:09,519 --> 00:13:12,320
context that we're working on because

379
00:13:10,880 --> 00:13:14,000
you have like a pie class so

380
00:13:12,320 --> 00:13:15,760
it's pretty hard to move things out of

381
00:13:14,000 --> 00:13:17,200
it um

382
00:13:15,760 --> 00:13:19,360
but yeah i just said it uses

383
00:13:17,200 --> 00:13:23,120
generational pointing

384
00:13:19,360 --> 00:13:25,440
um so we did some upstream work as i

385
00:13:23,120 --> 00:13:28,399
said the pi set is has been upstream

386
00:13:25,440 --> 00:13:29,279
last year uh so has the capsule support

387
00:13:28,399 --> 00:13:32,320
this

388
00:13:29,279 --> 00:13:34,399
iterator thing it's is is more general

389
00:13:32,320 --> 00:13:36,639
than just iterators is technically any

390
00:13:34,399 --> 00:13:39,199
shareable data

391
00:13:36,639 --> 00:13:41,120
so it can i actually still have an issue

392
00:13:39,199 --> 00:13:43,199
with

393
00:13:41,120 --> 00:13:44,480
a python class that i want to expose

394
00:13:43,199 --> 00:13:47,279
multiple parts of

395
00:13:44,480 --> 00:13:48,160
as separate python classes and that's

396
00:13:47,279 --> 00:13:51,439
just

397
00:13:48,160 --> 00:13:52,560
super like there's a ton of boilerplate

398
00:13:51,440 --> 00:13:54,000
involved if you're trying to do it

399
00:13:52,560 --> 00:13:55,279
because you have to always go through

400
00:13:54,000 --> 00:13:57,519
the same indirection layer

401
00:13:55,279 --> 00:13:58,560
so maybe that can help i still have to

402
00:13:57,519 --> 00:14:00,480
try

403
00:13:58,560 --> 00:14:03,439
properties that are being worked on so

404
00:14:00,480 --> 00:14:06,800
that's going to happen

405
00:14:03,440 --> 00:14:07,920
so that's our target that's what we're

406
00:14:06,800 --> 00:14:10,880
trying to achieve

407
00:14:07,920 --> 00:14:13,040
but it is the unrealistic target because

408
00:14:10,880 --> 00:14:14,959
it does not do what

409
00:14:13,040 --> 00:14:16,079
it should do it does not do all of what

410
00:14:14,959 --> 00:14:19,359
it should do

411
00:14:16,079 --> 00:14:20,959
um so where are we now i i i've been

412
00:14:19,360 --> 00:14:22,800
working on it for a few months and there

413
00:14:20,959 --> 00:14:23,359
was a lot of work that was ungratifying

414
00:14:22,800 --> 00:14:26,560
as you

415
00:14:23,360 --> 00:14:28,000
as you saw but we're starting to make a

416
00:14:26,560 --> 00:14:31,119
little grounds

417
00:14:28,000 --> 00:14:33,519
so i have two cases first one being a

418
00:14:31,120 --> 00:14:35,199
pathological case of something that is

419
00:14:33,519 --> 00:14:37,839
in our favor so it's

420
00:14:35,199 --> 00:14:39,199
it's a particularly bad repository with

421
00:14:37,839 --> 00:14:41,360
very terrible performance

422
00:14:39,199 --> 00:14:44,639
and um as you can see the standard

423
00:14:41,360 --> 00:14:47,680
status takes about six seconds which is

424
00:14:44,639 --> 00:14:49,360
like super slow and uh the new version

425
00:14:47,680 --> 00:14:51,920
with some rust takes

426
00:14:49,360 --> 00:14:52,480
about one and a half so that's it's

427
00:14:51,920 --> 00:14:54,560
better

428
00:14:52,480 --> 00:14:56,240
uh it's definitely not perfect but it's

429
00:14:54,560 --> 00:14:59,599
better

430
00:14:56,240 --> 00:15:02,079
um for a more realistic case on any

431
00:14:59,600 --> 00:15:06,079
other repositories that i've i've seen

432
00:15:02,079 --> 00:15:07,839
you get more of a 50

433
00:15:06,079 --> 00:15:09,599
increase in performance which is

434
00:15:07,839 --> 00:15:11,199
definitely nice like 50

435
00:15:09,600 --> 00:15:13,680
actually compounds a lot if you have a

436
00:15:11,199 --> 00:15:16,880
ci system that calls mercurial a lot

437
00:15:13,680 --> 00:15:18,800
um but it's still so far from the 50

438
00:15:16,880 --> 00:15:21,920
milliseconds that we had

439
00:15:18,800 --> 00:15:23,839
in the first place so

440
00:15:21,920 --> 00:15:25,760
what can we do and what can you do in

441
00:15:23,839 --> 00:15:28,959
general to

442
00:15:25,760 --> 00:15:30,959
you know make it go faster it's

443
00:15:28,959 --> 00:15:32,638
not that complicated from a from a high

444
00:15:30,959 --> 00:15:34,000
level perspective do more things in

445
00:15:32,639 --> 00:15:36,240
parallel so we all know

446
00:15:34,000 --> 00:15:37,519
that building parallel code in rust is a

447
00:15:36,240 --> 00:15:40,480
lot easier than

448
00:15:37,519 --> 00:15:41,680
in most other languages especially in c

449
00:15:40,480 --> 00:15:44,000
um

450
00:15:41,680 --> 00:15:44,959
and i think there's only yeah and i

451
00:15:44,000 --> 00:15:47,199
wrote the code so i

452
00:15:44,959 --> 00:15:49,199
have to remember but there there's only

453
00:15:47,199 --> 00:15:51,199
one loop that has been done in parallel

454
00:15:49,199 --> 00:15:53,599
and it's not the most

455
00:15:51,199 --> 00:15:54,719
hungry one as you could say so there's

456
00:15:53,600 --> 00:15:56,800
still

457
00:15:54,720 --> 00:15:58,880
the performance numbers that we just had

458
00:15:56,800 --> 00:16:00,079
was just optimizing one of the three

459
00:15:58,880 --> 00:16:01,600
main loops and not the

460
00:16:00,079 --> 00:16:03,439
not the biggest one so you still have

461
00:16:01,600 --> 00:16:04,000
like a lot of performance to gain from

462
00:16:03,440 --> 00:16:07,199
that

463
00:16:04,000 --> 00:16:09,360
uh from doing more things in parallel

464
00:16:07,199 --> 00:16:10,240
of course better conditional execution

465
00:16:09,360 --> 00:16:12,880
that just

466
00:16:10,240 --> 00:16:15,040
comes from the fact that rewriting in a

467
00:16:12,880 --> 00:16:17,199
15 year old code base

468
00:16:15,040 --> 00:16:19,439
you don't want to do it all at once it

469
00:16:17,199 --> 00:16:21,279
is it's very bad idea because you will

470
00:16:19,440 --> 00:16:23,199
get new bugs you will have two different

471
00:16:21,279 --> 00:16:25,279
complete implementations with basically

472
00:16:23,199 --> 00:16:27,279
just you to maintain it it's just

473
00:16:25,279 --> 00:16:29,839
like just not a good idea so we you have

474
00:16:27,279 --> 00:16:31,279
to do it piece by piece at places that

475
00:16:29,839 --> 00:16:32,320
make sense that are very performance

476
00:16:31,279 --> 00:16:35,439
critical

477
00:16:32,320 --> 00:16:39,519
um so to start you just

478
00:16:35,440 --> 00:16:41,920
do some uh some work that is just better

479
00:16:39,519 --> 00:16:44,000
in any way if it's good enough

480
00:16:41,920 --> 00:16:45,199
you start upstreaming that and then you

481
00:16:44,000 --> 00:16:47,759
work your way up so

482
00:16:45,199 --> 00:16:50,319
better conditional execution would be to

483
00:16:47,759 --> 00:16:53,040
think about removing some past in some

484
00:16:50,320 --> 00:16:55,040
cases and and doing a little bit better

485
00:16:53,040 --> 00:16:56,399
it's absolutely not specific to our case

486
00:16:55,040 --> 00:16:58,880
it just in general

487
00:16:56,399 --> 00:17:00,959
try to move more incrementally we're

488
00:16:58,880 --> 00:17:02,639
thinking the order of execution

489
00:17:00,959 --> 00:17:04,639
that has a little bit more to do with

490
00:17:02,639 --> 00:17:08,000
rust because

491
00:17:04,640 --> 00:17:08,799
rust allows us with its very strong type

492
00:17:08,000 --> 00:17:12,000
system

493
00:17:08,799 --> 00:17:15,039
to define better constraints

494
00:17:12,000 --> 00:17:16,640
on what we're able to do than what we

495
00:17:15,039 --> 00:17:18,079
could do with python in the first place

496
00:17:16,640 --> 00:17:20,319
so maybe we can do

497
00:17:18,079 --> 00:17:22,240
two loops at the same time that we

498
00:17:20,319 --> 00:17:22,959
didn't really know if we were capable of

499
00:17:22,240 --> 00:17:24,400
doing

500
00:17:22,959 --> 00:17:26,240
in python because it was just too

501
00:17:24,400 --> 00:17:28,559
complicated to do

502
00:17:26,240 --> 00:17:30,000
uh of course there's fewer extensions

503
00:17:28,559 --> 00:17:30,960
between python and rus as i just said

504
00:17:30,000 --> 00:17:33,120
anything going through

505
00:17:30,960 --> 00:17:34,480
through the ffi layer is just additional

506
00:17:33,120 --> 00:17:36,719
time lost

507
00:17:34,480 --> 00:17:38,559
and uh the usual suspects of fewer

508
00:17:36,720 --> 00:17:39,280
allocation memory alignment and bit

509
00:17:38,559 --> 00:17:41,840
fields and

510
00:17:39,280 --> 00:17:43,200
all that kind of stuff so right now the

511
00:17:41,840 --> 00:17:46,320
the i'm expecting

512
00:17:43,200 --> 00:17:49,600
to have way better performance without

513
00:17:46,320 --> 00:17:52,559
doing that kind of i mean i'm not doing

514
00:17:49,600 --> 00:17:54,000
completely wild allocations or anything

515
00:17:52,559 --> 00:17:56,240
but

516
00:17:54,000 --> 00:17:57,600
you don't have to go particularly deep

517
00:17:56,240 --> 00:18:00,080
into performance to get

518
00:17:57,600 --> 00:18:01,199
to to gain a lot of it for for something

519
00:18:00,080 --> 00:18:04,159
very important like

520
00:18:01,200 --> 00:18:04,160
io for example

521
00:18:04,480 --> 00:18:09,760
but also you could just not start python

522
00:18:08,400 --> 00:18:11,600
so i know this is this can be

523
00:18:09,760 --> 00:18:13,520
controversial

524
00:18:11,600 --> 00:18:16,240
maybe less in that room than yesterday

525
00:18:13,520 --> 00:18:16,240
in the python room

526
00:18:17,840 --> 00:18:22,320
but python has a startup time that is

527
00:18:20,880 --> 00:18:25,520
none

528
00:18:22,320 --> 00:18:26,720
that kind of adds up like a third of the

529
00:18:25,520 --> 00:18:29,280
entire

530
00:18:26,720 --> 00:18:30,160
run of the test suite that we have we

531
00:18:29,280 --> 00:18:33,039
have about like

532
00:18:30,160 --> 00:18:34,480
900 integration tests a third of that is

533
00:18:33,039 --> 00:18:35,360
just starting python and getting the

534
00:18:34,480 --> 00:18:36,880
imports

535
00:18:35,360 --> 00:18:38,799
going through and we have optimized

536
00:18:36,880 --> 00:18:39,440
imports in mercurial like we we've tried

537
00:18:38,799 --> 00:18:42,720
to get it

538
00:18:39,440 --> 00:18:44,480
to go better and if you're trying if

539
00:18:42,720 --> 00:18:45,280
you're aiming for 50 millisecond status

540
00:18:44,480 --> 00:18:48,640
time you've just

541
00:18:45,280 --> 00:18:50,879
lost because you have to to you know to

542
00:18:48,640 --> 00:18:52,880
start python so

543
00:18:50,880 --> 00:18:54,480
i am absolutely not saying that python

544
00:18:52,880 --> 00:18:56,080
is not a good language or that you

545
00:18:54,480 --> 00:18:57,760
should not use it etc i'm just saying

546
00:18:56,080 --> 00:19:00,240
that some use cases

547
00:18:57,760 --> 00:19:02,240
are better suited for you know faster

548
00:19:00,240 --> 00:19:05,919
languages or compiled languages

549
00:19:02,240 --> 00:19:05,919
um for example we could

550
00:19:06,480 --> 00:19:10,000
start embedding python so that means

551
00:19:09,679 --> 00:19:13,520
that

552
00:19:10,000 --> 00:19:16,640
mercurial could become a rust

553
00:19:13,520 --> 00:19:19,840
executable that embeds python

554
00:19:16,640 --> 00:19:22,080
and that can fast path some

555
00:19:19,840 --> 00:19:23,439
commands so for example the hd version

556
00:19:22,080 --> 00:19:25,280
command has

557
00:19:23,440 --> 00:19:27,039
no reason to take more than one

558
00:19:25,280 --> 00:19:28,799
millisecond for example because it is

559
00:19:27,039 --> 00:19:30,559
just like give me the version

560
00:19:28,799 --> 00:19:32,000
and it actually can slow down

561
00:19:30,559 --> 00:19:34,080
considerably some

562
00:19:32,000 --> 00:19:35,039
ci systems even if it just takes you

563
00:19:34,080 --> 00:19:36,879
know

564
00:19:35,039 --> 00:19:38,720
60 milliseconds or something it can add

565
00:19:36,880 --> 00:19:39,440
up so that it's it's tiny things that

566
00:19:38,720 --> 00:19:42,320
make up

567
00:19:39,440 --> 00:19:43,200
a lot of difference and most ci systems

568
00:19:42,320 --> 00:19:44,918
don't care

569
00:19:43,200 --> 00:19:46,799
that much about the extent the

570
00:19:44,919 --> 00:19:48,640
extendability like the the

571
00:19:46,799 --> 00:19:50,160
using extensions and making custom

572
00:19:48,640 --> 00:19:50,480
things usually they want the diff they

573
00:19:50,160 --> 00:19:52,720
want

574
00:19:50,480 --> 00:19:54,160
a status they want a log and they want

575
00:19:52,720 --> 00:19:55,520
it very fast

576
00:19:54,160 --> 00:19:57,760
and they want to clone and that kind of

577
00:19:55,520 --> 00:19:59,918
stuff it's not operations that are

578
00:19:57,760 --> 00:20:01,520
super complicated or user based they're

579
00:19:59,919 --> 00:20:05,360
based on data structures and

580
00:20:01,520 --> 00:20:08,720
them being executed fast um

581
00:20:05,360 --> 00:20:11,280
so there's a pyroxidizer who's heard of

582
00:20:08,720 --> 00:20:14,480
pi oxidizer here

583
00:20:11,280 --> 00:20:17,200
a few people all right cool uh it's

584
00:20:14,480 --> 00:20:18,320
something that was done by a major

585
00:20:17,200 --> 00:20:21,840
material contributor

586
00:20:18,320 --> 00:20:24,720
it's a rust crate that allows to

587
00:20:21,840 --> 00:20:26,240
allows you to embed python applications

588
00:20:24,720 --> 00:20:28,000
it's basically a tool for distribution

589
00:20:26,240 --> 00:20:30,960
at first but you can you can do it for

590
00:20:28,000 --> 00:20:32,159
a little bit more than that and we have

591
00:20:30,960 --> 00:20:33,760
a plan to

592
00:20:32,159 --> 00:20:36,000
start distributing mercurial with pi

593
00:20:33,760 --> 00:20:38,640
oxidizers for packaging reasons and

594
00:20:36,000 --> 00:20:39,919
at first but also now i have a rust

595
00:20:38,640 --> 00:20:42,000
entry point

596
00:20:39,919 --> 00:20:44,080
so i can just maybe not start python in

597
00:20:42,000 --> 00:20:47,039
some in some cases so that that

598
00:20:44,080 --> 00:20:49,840
would be a major performance gain of

599
00:20:47,039 --> 00:20:49,840
course

600
00:20:50,400 --> 00:20:54,559
rust is a great language for writing vcs

601
00:20:53,360 --> 00:20:55,918
i don't think and that may be

602
00:20:54,559 --> 00:20:57,520
controversial i don't think that russ is

603
00:20:55,919 --> 00:20:59,840
a great language for any

604
00:20:57,520 --> 00:21:02,158
single application in much the same way

605
00:20:59,840 --> 00:21:04,240
that i don't think that python

606
00:21:02,159 --> 00:21:05,919
would be very nice for every single

607
00:21:04,240 --> 00:21:09,280
application

608
00:21:05,919 --> 00:21:11,200
but vcs they like data structures

609
00:21:09,280 --> 00:21:12,960
data structure abstractions because a

610
00:21:11,200 --> 00:21:16,559
lot of it is just

611
00:21:12,960 --> 00:21:18,960
graphs and and append only databases and

612
00:21:16,559 --> 00:21:19,678
that kind of stuff that works really

613
00:21:18,960 --> 00:21:23,440
well

614
00:21:19,679 --> 00:21:26,080
with um with the trade system basically

615
00:21:23,440 --> 00:21:27,440
um and it's been very nice to to to work

616
00:21:26,080 --> 00:21:30,320
with rust

617
00:21:27,440 --> 00:21:31,840
to have invariants that are compile time

618
00:21:30,320 --> 00:21:33,280
instead of just you know figuring out

619
00:21:31,840 --> 00:21:34,959
with assets whether it's going to

620
00:21:33,280 --> 00:21:36,960
explode or not

621
00:21:34,960 --> 00:21:38,640
vcs they need to be both correct and

622
00:21:36,960 --> 00:21:40,159
fast so you have different

623
00:21:38,640 --> 00:21:41,760
constraints than say in the video game

624
00:21:40,159 --> 00:21:42,960
industry in some aspects i'm not saying

625
00:21:41,760 --> 00:21:46,320
that they don't have to be correct

626
00:21:42,960 --> 00:21:48,720
at all but but we have like it's not a

627
00:21:46,320 --> 00:21:51,120
huge deal if you're if your game crashes

628
00:21:48,720 --> 00:21:52,720
sometimes uh but if your vcs crashes and

629
00:21:51,120 --> 00:21:54,799
it crashes every second because there's

630
00:21:52,720 --> 00:21:57,039
like a million people using it

631
00:21:54,799 --> 00:21:58,000
right um vcs like to do things in

632
00:21:57,039 --> 00:22:00,320
parallel because you have

633
00:21:58,000 --> 00:22:02,400
like hundreds of thousands or millions

634
00:22:00,320 --> 00:22:03,918
of files and most of it you just want to

635
00:22:02,400 --> 00:22:05,360
repeat the same operation for

636
00:22:03,919 --> 00:22:07,039
all of them and then collect the results

637
00:22:05,360 --> 00:22:09,760
so rust is very good for that

638
00:22:07,039 --> 00:22:10,480
and also vcs they have to work on bytes

639
00:22:09,760 --> 00:22:12,158
they don't

640
00:22:10,480 --> 00:22:13,840
don't just like like to work on bags

641
00:22:12,159 --> 00:22:14,559
they have to work on bytes because

642
00:22:13,840 --> 00:22:17,120
encoding

643
00:22:14,559 --> 00:22:17,760
is not always unicode i'm sorry and i

644
00:22:17,120 --> 00:22:20,399
know that

645
00:22:17,760 --> 00:22:22,480
i would really love to just use path

646
00:22:20,400 --> 00:22:24,640
from the standard rust library to

647
00:22:22,480 --> 00:22:26,080
to use a path but but you can do that

648
00:22:24,640 --> 00:22:28,640
because it's a vcs and people use

649
00:22:26,080 --> 00:22:30,480
different encoders that unicode

650
00:22:28,640 --> 00:22:32,559
so i like rust and i like it for riding

651
00:22:30,480 --> 00:22:41,200
vcs fast stuff

652
00:22:32,559 --> 00:22:44,399
and yeah thank you

653
00:22:41,200 --> 00:22:44,400
do we have any questions

654
00:22:44,679 --> 00:22:47,679
yes

655
00:22:52,960 --> 00:22:58,559
uh most of the yeah sorry uh um

656
00:22:56,320 --> 00:23:00,320
the question was did we do any profiling

657
00:22:58,559 --> 00:23:03,678
on the startup type of python

658
00:23:00,320 --> 00:23:06,240
basically to figure out in general

659
00:23:03,679 --> 00:23:07,919
yes we do a lot of profiling um one of

660
00:23:06,240 --> 00:23:10,240
the reasons why we started to put sea

661
00:23:07,919 --> 00:23:12,320
and rust etc was because the profiler

662
00:23:10,240 --> 00:23:13,919
showed up some you know hot spots that

663
00:23:12,320 --> 00:23:16,320
we'd have to to to help

664
00:23:13,919 --> 00:23:17,520
the startup time of python is is

665
00:23:16,320 --> 00:23:20,000
sometimes out of our hands

666
00:23:17,520 --> 00:23:20,960
most of it most most of what we can do

667
00:23:20,000 --> 00:23:23,280
about it is to

668
00:23:20,960 --> 00:23:24,240
simplify imports and do less and do

669
00:23:23,280 --> 00:23:26,559
things lazily

670
00:23:24,240 --> 00:23:27,919
uh but most of the work was already done

671
00:23:26,559 --> 00:23:30,240
a few years ago

672
00:23:27,919 --> 00:23:32,480
um so it's just a cost because python is

673
00:23:30,240 --> 00:23:34,559
like a fantastic machine to do very very

674
00:23:32,480 --> 00:23:35,679
complicated stuff so you it has to have

675
00:23:34,559 --> 00:23:38,879
a cost

676
00:23:35,679 --> 00:23:41,840
so i hope that answers your question

677
00:23:38,880 --> 00:23:43,039
yes have you heard of monologue which is

678
00:23:41,840 --> 00:23:45,120
a

679
00:23:43,039 --> 00:23:46,799
have i heard of mononoke which is the

680
00:23:45,120 --> 00:23:48,559
facebook server

681
00:23:46,799 --> 00:23:50,158
implementation of mercury yes and i

682
00:23:48,559 --> 00:23:51,760
actually know one of the developers of

683
00:23:50,159 --> 00:23:53,440
mononake he's a very nice person who is

684
00:23:51,760 --> 00:23:56,559
way better at rust than i am

685
00:23:53,440 --> 00:23:58,799
um and he yeah

686
00:23:56,559 --> 00:24:00,480
it's very interesting but it's very good

687
00:23:58,799 --> 00:24:02,000
for facebook i'm not saying that the

688
00:24:00,480 --> 00:24:04,080
idea is not good in general

689
00:24:02,000 --> 00:24:05,520
like it's a good idea but it works for

690
00:24:04,080 --> 00:24:06,080
facebook because they have the problems

691
00:24:05,520 --> 00:24:08,000
that they have

692
00:24:06,080 --> 00:24:10,639
and they're just using path because all

693
00:24:08,000 --> 00:24:11,600
of their all of their paths are utf-8

694
00:24:10,640 --> 00:24:13,840
and so they don't care

695
00:24:11,600 --> 00:24:15,279
so it's very specific and it's cool and

696
00:24:13,840 --> 00:24:16,000
some of the ideas that we we can

697
00:24:15,279 --> 00:24:17,760
actually

698
00:24:16,000 --> 00:24:19,039
like talk to them to maybe get them

699
00:24:17,760 --> 00:24:22,960
inside mercurial

700
00:24:19,039 --> 00:24:22,960
um but yes i've definitely heard of them

701
00:24:23,760 --> 00:24:29,440
do you have any more time yeah

702
00:24:26,799 --> 00:24:29,440
one more question

703
00:24:31,039 --> 00:24:33,840
base yes

704
00:24:34,240 --> 00:24:38,240
if that is true then can you do it the

705
00:24:36,480 --> 00:24:40,320
way is holding a point in the direction

706
00:24:38,240 --> 00:24:42,159
yes that's one of the issues that we

707
00:24:40,320 --> 00:24:46,799
have so now

708
00:24:42,159 --> 00:24:48,799
yes sorry i really have to um

709
00:24:46,799 --> 00:24:50,320
how do we figure out how to handle

710
00:24:48,799 --> 00:24:52,400
extensions that can change commands if

711
00:24:50,320 --> 00:24:55,840
we're just not starting python which has

712
00:24:52,400 --> 00:24:58,240
withholds the entire extension system um

713
00:24:55,840 --> 00:24:59,120
good question because we still have to

714
00:24:58,240 --> 00:25:02,960
figure that out

715
00:24:59,120 --> 00:25:03,918
um there's uh there's a need right now

716
00:25:02,960 --> 00:25:05,840
to get

717
00:25:03,919 --> 00:25:07,440
hd to go faster in general so people

718
00:25:05,840 --> 00:25:10,639
will give up some extension

719
00:25:07,440 --> 00:25:12,400
system for for their ci for example so

720
00:25:10,640 --> 00:25:14,559
i think a fast passive is acceptable as

721
00:25:12,400 --> 00:25:16,400
long as it's configurable

722
00:25:14,559 --> 00:25:18,639
and after that i really want to get

723
00:25:16,400 --> 00:25:20,799
extensions to go faster also because

724
00:25:18,640 --> 00:25:22,559
repositories have been getting like huge

725
00:25:20,799 --> 00:25:23,918
and extensions are slow

726
00:25:22,559 --> 00:25:26,080
so that's another point should we

727
00:25:23,919 --> 00:25:27,840
rewrite the extensions in rust how do we

728
00:25:26,080 --> 00:25:29,520
interface we're still not at that point

729
00:25:27,840 --> 00:25:41,840
right now

730
00:25:29,520 --> 00:25:41,840
thank you very much thanks

