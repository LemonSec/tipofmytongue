1
00:00:05,839 --> 00:00:08,480
okay

2
00:00:06,480 --> 00:00:09,519
sorry for the uh technical hitch there

3
00:00:08,480 --> 00:00:11,280
um

4
00:00:09,519 --> 00:00:12,639
right i'm uh i was supposed to be doing

5
00:00:11,280 --> 00:00:15,599
this talk with uh

6
00:00:12,639 --> 00:00:16,960
a colleague who works with g on jfr um

7
00:00:15,599 --> 00:00:17,760
unfortunately he wasn't able to come so

8
00:00:16,960 --> 00:00:20,080
i'm going to cover the

9
00:00:17,760 --> 00:00:21,359
material he's provided for the talk this

10
00:00:20,080 --> 00:00:23,038
is a talk about

11
00:00:21,359 --> 00:00:24,720
our attempts to add some new

12
00:00:23,039 --> 00:00:27,840
functionality to

13
00:00:24,720 --> 00:00:29,679
growl vm so

14
00:00:27,840 --> 00:00:31,439
what i'll do is i'll start by providing

15
00:00:29,679 --> 00:00:33,360
some background what grall is just to

16
00:00:31,439 --> 00:00:35,120
give an overview of how it works and

17
00:00:33,360 --> 00:00:36,800
the the the what we're actually trying

18
00:00:35,120 --> 00:00:38,000
to achieve talk about the things we

19
00:00:36,800 --> 00:00:39,919
wanted to do

20
00:00:38,000 --> 00:00:41,200
um explain how that went some of the

21
00:00:39,920 --> 00:00:42,879
problems that we had

22
00:00:41,200 --> 00:00:43,920
uh what we actually succeeded in doing

23
00:00:42,879 --> 00:00:44,800
some of the things we learned from the

24
00:00:43,920 --> 00:00:46,000
process

25
00:00:44,800 --> 00:00:47,440
and i suspect we probably won't have

26
00:00:46,000 --> 00:00:47,920
time for questions but i'd be happy to

27
00:00:47,440 --> 00:00:51,360
talk

28
00:00:47,920 --> 00:00:53,920
with them outside so um

29
00:00:51,360 --> 00:00:55,920
growl is not just one thing it's

30
00:00:53,920 --> 00:00:57,600
actually a whole series of components

31
00:00:55,920 --> 00:01:00,079
all written in java

32
00:00:57,600 --> 00:01:01,920
at the core of that is a compiler which

33
00:01:00,079 --> 00:01:04,000
is used for various different purposes

34
00:01:01,920 --> 00:01:05,760
it can function as a jit compiler as an

35
00:01:04,000 --> 00:01:07,360
ahead of time compiler

36
00:01:05,760 --> 00:01:09,280
there's an interpreter framework for

37
00:01:07,360 --> 00:01:10,560
called truffle which can be used to

38
00:01:09,280 --> 00:01:12,479
provide support for a whole lot of

39
00:01:10,560 --> 00:01:14,400
interpreted languages that these

40
00:01:12,479 --> 00:01:15,679
because the compiler can then optimize

41
00:01:14,400 --> 00:01:17,439
by compiling

42
00:01:15,680 --> 00:01:19,200
there's a native image generator that

43
00:01:17,439 --> 00:01:21,839
can take a java

44
00:01:19,200 --> 00:01:23,040
program and finds a closed world of all

45
00:01:21,840 --> 00:01:25,200
the code that's uh

46
00:01:23,040 --> 00:01:27,600
called the program and will generate a

47
00:01:25,200 --> 00:01:29,680
small executable from that code

48
00:01:27,600 --> 00:01:30,880
that can run independent from open jdk

49
00:01:29,680 --> 00:01:32,799
doesn't need a jvm

50
00:01:30,880 --> 00:01:34,479
because it's got its own little jvm

51
00:01:32,799 --> 00:01:36,880
inside there called substrate

52
00:01:34,479 --> 00:01:39,600
which replicates all the functionality

53
00:01:36,880 --> 00:01:41,520
you need from open jdk to run a small

54
00:01:39,600 --> 00:01:43,280
native java image as a self-contained

55
00:01:41,520 --> 00:01:45,360
binary you can also generate shared

56
00:01:43,280 --> 00:01:47,200
libraries with it as well

57
00:01:45,360 --> 00:01:48,640
it's just a binary with multiple entry

58
00:01:47,200 --> 00:01:51,200
points essentially

59
00:01:48,640 --> 00:01:53,119
so what grail looks like at the core of

60
00:01:51,200 --> 00:01:56,159
it all is this compiler

61
00:01:53,119 --> 00:01:57,280
and you can use it at open jdk as a jit

62
00:01:56,159 --> 00:01:59,600
compiler so

63
00:01:57,280 --> 00:02:01,600
if you were to plug it in by the jvmci

64
00:01:59,600 --> 00:02:04,880
compiler plugin interface

65
00:02:01,600 --> 00:02:06,479
uh um openjdk will create some compiler

66
00:02:04,880 --> 00:02:08,000
threads and start handing methods to it

67
00:02:06,479 --> 00:02:10,000
to compile and get compiled code

68
00:02:08,000 --> 00:02:12,160
back and that will be used as the

69
00:02:10,000 --> 00:02:14,319
compiled code from jdk

70
00:02:12,160 --> 00:02:16,560
in order to do that it has a front end

71
00:02:14,319 --> 00:02:17,839
which passes by code and generates a

72
00:02:16,560 --> 00:02:19,920
graph structure

73
00:02:17,840 --> 00:02:22,000
there's a the usual high middle and low

74
00:02:19,920 --> 00:02:23,760
tiers that massage that graph

75
00:02:22,000 --> 00:02:25,280
into a shape that you can spit code out

76
00:02:23,760 --> 00:02:26,560
and a back end that generates code

77
00:02:25,280 --> 00:02:27,840
buffers and there they are you've got

78
00:02:26,560 --> 00:02:29,680
compiled methods

79
00:02:27,840 --> 00:02:31,599
a slightly different configuration of

80
00:02:29,680 --> 00:02:33,200
the compiler most specifically with a

81
00:02:31,599 --> 00:02:34,000
very different backend for linking in a

82
00:02:33,200 --> 00:02:36,238
different way

83
00:02:34,000 --> 00:02:38,319
can be used in in the ahead of time

84
00:02:36,239 --> 00:02:39,760
compilation for java and open jdk

85
00:02:38,319 --> 00:02:41,518
and that can be used to populate the

86
00:02:39,760 --> 00:02:43,359
class data sharing segment

87
00:02:41,519 --> 00:02:45,519
application class data sharing with

88
00:02:43,360 --> 00:02:47,200
pre-defined methods so we need bootstrap

89
00:02:45,519 --> 00:02:48,879
you've already got compiled code for

90
00:02:47,200 --> 00:02:49,518
java runtime methods or application

91
00:02:48,879 --> 00:02:51,760
methods

92
00:02:49,519 --> 00:02:53,200
so the same compiler has been repurposed

93
00:02:51,760 --> 00:02:55,200
by reconfiguring

94
00:02:53,200 --> 00:02:56,480
all the the the the components in the

95
00:02:55,200 --> 00:02:59,679
compiler

96
00:02:56,480 --> 00:03:01,840
another use for it from truffle um

97
00:02:59,680 --> 00:03:03,599
truffle allows you to build interpreters

98
00:03:01,840 --> 00:03:05,599
that parse a language and there's

99
00:03:03,599 --> 00:03:08,399
various truffle language implementations

100
00:03:05,599 --> 00:03:09,599
and execute by walking the abstract

101
00:03:08,400 --> 00:03:12,800
syntax tree for the

102
00:03:09,599 --> 00:03:14,480
parsed language program the uh

103
00:03:12,800 --> 00:03:16,319
truffle interpreter framework knows how

104
00:03:14,480 --> 00:03:18,399
to take a node in that graph

105
00:03:16,319 --> 00:03:19,518
that syntax tree and maybe some of its

106
00:03:18,400 --> 00:03:21,200
sub nodes

107
00:03:19,519 --> 00:03:23,200
push the graph straight into the

108
00:03:21,200 --> 00:03:24,560
compiler bypassing any byte code

109
00:03:23,200 --> 00:03:26,000
parsing front end because you've already

110
00:03:24,560 --> 00:03:27,599
got um you've got a different

111
00:03:26,000 --> 00:03:30,159
representation of the program

112
00:03:27,599 --> 00:03:31,200
it pushes it through the the stages in

113
00:03:30,159 --> 00:03:33,120
the compiler

114
00:03:31,200 --> 00:03:34,879
out pops code at the back end and you

115
00:03:33,120 --> 00:03:35,760
can install that as an execute method

116
00:03:34,879 --> 00:03:38,480
for the

117
00:03:35,760 --> 00:03:40,079
interpreted language to call directly

118
00:03:38,480 --> 00:03:42,399
rather than interpreting the graph

119
00:03:40,080 --> 00:03:43,519
running on open jdk you can also use it

120
00:03:42,400 --> 00:03:44,879
in native images

121
00:03:43,519 --> 00:03:47,120
where you've compiled things the native

122
00:03:44,879 --> 00:03:49,200
compiler and the grail compiler can run

123
00:03:47,120 --> 00:03:51,360
inside a self-contained binary

124
00:03:49,200 --> 00:03:53,280
as part of a program running uh some

125
00:03:51,360 --> 00:03:55,120
truffle language

126
00:03:53,280 --> 00:03:56,400
the native image generator itself makes

127
00:03:55,120 --> 00:03:59,599
two uses of

128
00:03:56,400 --> 00:04:02,000
the compiler you start from a method

129
00:03:59,599 --> 00:04:03,679
in a particular class or a set of entry

130
00:04:02,000 --> 00:04:06,159
methods for a library

131
00:04:03,680 --> 00:04:08,400
and it takes that uh method and the

132
00:04:06,159 --> 00:04:09,840
class is associated with with jvmci

133
00:04:08,400 --> 00:04:11,680
descriptions of them

134
00:04:09,840 --> 00:04:13,120
eats the bytecode and instead of

135
00:04:11,680 --> 00:04:14,159
compiling it out of machine code in the

136
00:04:13,120 --> 00:04:15,760
first pass it

137
00:04:14,159 --> 00:04:17,440
analyzes the method and at the bottom of

138
00:04:15,760 --> 00:04:18,320
the transformation stage in the graph

139
00:04:17,440 --> 00:04:21,600
processing

140
00:04:18,320 --> 00:04:22,719
comes um and a transform method and a

141
00:04:21,600 --> 00:04:25,040
list of methods that

142
00:04:22,720 --> 00:04:26,960
and types that that method refers to

143
00:04:25,040 --> 00:04:28,720
they're put into a pool into a universe

144
00:04:26,960 --> 00:04:29,680
which built is built up recursively

145
00:04:28,720 --> 00:04:31,520
processed

146
00:04:29,680 --> 00:04:33,199
finding all the references from classes

147
00:04:31,520 --> 00:04:33,919
to other classes methods to other

148
00:04:33,199 --> 00:04:36,240
methods

149
00:04:33,919 --> 00:04:38,000
until you build up a closed world of all

150
00:04:36,240 --> 00:04:39,759
the code that can be reached from the

151
00:04:38,000 --> 00:04:40,960
initial entry points

152
00:04:39,759 --> 00:04:43,120
you can then take all the type

153
00:04:40,960 --> 00:04:45,840
information you've derived and the

154
00:04:43,120 --> 00:04:46,400
methods that you've found and compile

155
00:04:45,840 --> 00:04:48,960
them

156
00:04:46,400 --> 00:04:50,000
to a completely self-contained

157
00:04:48,960 --> 00:04:51,919
executable image

158
00:04:50,000 --> 00:04:53,199
that has a closed world model you found

159
00:04:51,919 --> 00:04:54,799
all the code you could reach

160
00:04:53,199 --> 00:04:56,800
from that entry point for that library

161
00:04:54,800 --> 00:04:58,400
or that application

162
00:04:56,800 --> 00:05:01,440
it's not quite as simple as that because

163
00:04:58,400 --> 00:05:03,120
this closed world executable image

164
00:05:01,440 --> 00:05:04,560
is at some point when you call into the

165
00:05:03,120 --> 00:05:06,560
jdk runtime

166
00:05:04,560 --> 00:05:08,000
methods is going to expect to call out

167
00:05:06,560 --> 00:05:10,720
and have a jvm under there

168
00:05:08,000 --> 00:05:12,000
under normal operation have opened jdk

169
00:05:10,720 --> 00:05:13,680
and of course this program has to run

170
00:05:12,000 --> 00:05:15,520
its own without open jk

171
00:05:13,680 --> 00:05:16,960
and it can't reuse all the jvm

172
00:05:15,520 --> 00:05:18,479
functionality from jdk because that

173
00:05:16,960 --> 00:05:20,320
expects to do class loading

174
00:05:18,479 --> 00:05:21,680
and keep track of classes and it's all

175
00:05:20,320 --> 00:05:23,039
meant to be compiled into the image

176
00:05:21,680 --> 00:05:24,720
self-contained

177
00:05:23,039 --> 00:05:26,400
so what this translation process that

178
00:05:24,720 --> 00:05:27,680
the first stage does is it also

179
00:05:26,400 --> 00:05:30,400
substitutes

180
00:05:27,680 --> 00:05:31,840
invocations of jdk runtime code at

181
00:05:30,400 --> 00:05:33,599
certain cut points

182
00:05:31,840 --> 00:05:35,280
and side steps them into substrate which

183
00:05:33,600 --> 00:05:37,039
provides an equivalent thing

184
00:05:35,280 --> 00:05:39,280
that will do the same sort of job as

185
00:05:37,039 --> 00:05:40,880
open jdk in this delivered image with

186
00:05:39,280 --> 00:05:42,479
limited shared library

187
00:05:40,880 --> 00:05:44,080
um it used to be that all the

188
00:05:42,479 --> 00:05:46,240
functionality that was provided to

189
00:05:44,080 --> 00:05:48,800
emulate open the opengdk vm

190
00:05:46,240 --> 00:05:50,160
was implemented as java code that became

191
00:05:48,800 --> 00:05:50,880
a bit of a burden when they realized

192
00:05:50,160 --> 00:05:52,800
they would have to keep

193
00:05:50,880 --> 00:05:55,199
porting that for 11 and all the later

194
00:05:52,800 --> 00:05:56,400
releases so from a lot of the native

195
00:05:55,199 --> 00:05:58,960
code that's implemented c

196
00:05:56,400 --> 00:05:59,599
code in native libraries like the zip

197
00:05:58,960 --> 00:06:02,638
library

198
00:05:59,600 --> 00:06:04,319
the libnet code that's been put in and

199
00:06:02,639 --> 00:06:05,840
linked underneath the substrate image

200
00:06:04,319 --> 00:06:07,120
and it's used directly to avoid having

201
00:06:05,840 --> 00:06:09,039
to maintain so much

202
00:06:07,120 --> 00:06:10,319
java code but substrate obviously has to

203
00:06:09,039 --> 00:06:11,039
emulate some of the things that normally

204
00:06:10,319 --> 00:06:13,360
go on inside

205
00:06:11,039 --> 00:06:14,800
the vm code and provide an alternative

206
00:06:13,360 --> 00:06:17,440
because you've got a different model for

207
00:06:14,800 --> 00:06:17,440
execution

208
00:06:17,520 --> 00:06:21,039
so there's this set of things that were

209
00:06:20,400 --> 00:06:22,719
the term

210
00:06:21,039 --> 00:06:23,759
started arriving a few years back and we

211
00:06:22,720 --> 00:06:25,280
were looking at this about two and a

212
00:06:23,759 --> 00:06:26,800
half years ago and thought well

213
00:06:25,280 --> 00:06:28,479
the arm port isn't really properly

214
00:06:26,800 --> 00:06:30,240
supported it's the sort of second-class

215
00:06:28,479 --> 00:06:32,400
citizen so our first idea was

216
00:06:30,240 --> 00:06:33,280
we'd do some work to help make the arm

217
00:06:32,400 --> 00:06:35,520
back end

218
00:06:33,280 --> 00:06:37,520
be on a par with x86 and our goal there

219
00:06:35,520 --> 00:06:39,680
was architecture parity

220
00:06:37,520 --> 00:06:41,280
more recently we've been interested in

221
00:06:39,680 --> 00:06:43,039
the native image generation because of

222
00:06:41,280 --> 00:06:46,080
our middleware product caucus

223
00:06:43,039 --> 00:06:49,280
so we looked at adding jfr support um

224
00:06:46,080 --> 00:06:51,440
into the substrate and vm

225
00:06:49,280 --> 00:06:52,960
and into the app the native application

226
00:06:51,440 --> 00:06:54,000
all the monitoring capabilities you have

227
00:06:52,960 --> 00:06:56,080
open jdk

228
00:06:54,000 --> 00:06:57,919
are not currently present in these

229
00:06:56,080 --> 00:07:00,318
native generated images

230
00:06:57,919 --> 00:07:02,080
and really for usability users are going

231
00:07:00,319 --> 00:07:03,840
to need to understand what's going on

232
00:07:02,080 --> 00:07:05,599
in the application and also have some

233
00:07:03,840 --> 00:07:06,318
way of identifying things when it goes

234
00:07:05,599 --> 00:07:08,240
wrong

235
00:07:06,319 --> 00:07:10,479
so jfr was what we decided we want to

236
00:07:08,240 --> 00:07:11,680
port oracle already have plans to have

237
00:07:10,479 --> 00:07:13,359
that in their enterprise edition of

238
00:07:11,680 --> 00:07:14,880
grail we wanted to add it as a community

239
00:07:13,360 --> 00:07:16,479
feature

240
00:07:14,880 --> 00:07:18,080
and that's really critical we think for

241
00:07:16,479 --> 00:07:19,359
usability

242
00:07:18,080 --> 00:07:21,520
for the community edition the open

243
00:07:19,360 --> 00:07:24,000
source edition um

244
00:07:21,520 --> 00:07:25,758
with uh debug info for for debuggers

245
00:07:24,000 --> 00:07:28,400
this is a different story

246
00:07:25,759 --> 00:07:29,360
um a program that runs on opengdk if you

247
00:07:28,400 --> 00:07:31,120
get a native

248
00:07:29,360 --> 00:07:32,560
compil a native image compiled version

249
00:07:31,120 --> 00:07:35,360
of it and in any way

250
00:07:32,560 --> 00:07:36,960
diverges from open jdk behavior that'll

251
00:07:35,360 --> 00:07:38,800
be because the compiler has compiled

252
00:07:36,960 --> 00:07:41,280
code into this heavily optimized

253
00:07:38,800 --> 00:07:42,240
uh executable program that is doing the

254
00:07:41,280 --> 00:07:43,359
wrong thing

255
00:07:42,240 --> 00:07:44,639
so you've got to be able to work what

256
00:07:43,360 --> 00:07:45,599
happens if everything like that should

257
00:07:44,639 --> 00:07:47,520
arise

258
00:07:45,599 --> 00:07:48,719
so we've wanted to put debug info in

259
00:07:47,520 --> 00:07:49,919
that would allow you to take the

260
00:07:48,720 --> 00:07:51,520
executable image

261
00:07:49,919 --> 00:07:53,120
and refer back execution the

262
00:07:51,520 --> 00:07:53,919
instructions there to the original java

263
00:07:53,120 --> 00:07:56,319
source code

264
00:07:53,919 --> 00:07:57,039
in a debugger like gdb or in visual

265
00:07:56,319 --> 00:07:58,639
studio

266
00:07:57,039 --> 00:07:59,919
so you could actually deal with that

267
00:07:58,639 --> 00:08:01,280
problem should it ever arise and

268
00:07:59,919 --> 00:08:03,280
understand what's gone wrong

269
00:08:01,280 --> 00:08:06,878
and then go and fix growl probably so

270
00:08:03,280 --> 00:08:06,878
this is more a supportability goal

271
00:08:06,960 --> 00:08:12,239
so um for the uh the answer 64 code what

272
00:08:10,319 --> 00:08:13,599
we wanted to do was just add very basic

273
00:08:12,240 --> 00:08:15,360
stuff two and a half years ago there was

274
00:08:13,599 --> 00:08:17,039
very minimal things like um

275
00:08:15,360 --> 00:08:18,720
addressing there were no displacements

276
00:08:17,039 --> 00:08:19,280
embedded in in addressing it was they're

277
00:08:18,720 --> 00:08:21,199
actually

278
00:08:19,280 --> 00:08:23,758
loaded as independent values into

279
00:08:21,199 --> 00:08:26,560
registers but there's no pre-fetching

280
00:08:23,759 --> 00:08:28,160
things like merging an abstract shift

281
00:08:26,560 --> 00:08:28,639
and a mask operation and using one of

282
00:08:28,160 --> 00:08:30,960
the bit

283
00:08:28,639 --> 00:08:32,479
bit fetch instructions in arm that we

284
00:08:30,960 --> 00:08:34,319
wanted optimizations like that

285
00:08:32,479 --> 00:08:35,760
and the most important was using load

286
00:08:34,320 --> 00:08:37,039
acquire store release for volatile

287
00:08:35,760 --> 00:08:38,559
operations rather than having memory

288
00:08:37,039 --> 00:08:39,838
barriers for efficiency

289
00:08:38,559 --> 00:08:41,598
so there was a lot of stuff that really

290
00:08:39,839 --> 00:08:44,959
just wasn't there we needed to put in

291
00:08:41,599 --> 00:08:47,440
um with jfr we really just wanted to get

292
00:08:44,959 --> 00:08:49,760
jrfr working so we wanted this a lower

293
00:08:47,440 --> 00:08:52,000
overhead profiling mechanic method uh

294
00:08:49,760 --> 00:08:55,200
mechanism because it's really critical

295
00:08:52,000 --> 00:08:57,519
um we needed to have um as many of the

296
00:08:55,200 --> 00:08:58,880
vm events we wanted the equivalent sorts

297
00:08:57,519 --> 00:09:00,800
of things that made sense

298
00:08:58,880 --> 00:09:02,320
to come out of the substrate vm so you

299
00:09:00,800 --> 00:09:04,640
can see what the virtual machine and the

300
00:09:02,320 --> 00:09:06,640
native runtime code is doing

301
00:09:04,640 --> 00:09:08,000
we'd also want to have support for user

302
00:09:06,640 --> 00:09:09,839
events um

303
00:09:08,000 --> 00:09:11,120
and we'd also like if there's something

304
00:09:09,839 --> 00:09:11,440
about the way substrate works there

305
00:09:11,120 --> 00:09:13,360
doesn't

306
00:09:11,440 --> 00:09:14,640
isn't really a correlative open jdk we

307
00:09:13,360 --> 00:09:14,959
were thinking of adding new events for

308
00:09:14,640 --> 00:09:16,319
that

309
00:09:14,959 --> 00:09:17,920
we mostly just wanted to reuse the

310
00:09:16,320 --> 00:09:20,320
existing code as much as possible so

311
00:09:17,920 --> 00:09:22,160
we'd have to reinvent the wheel

312
00:09:20,320 --> 00:09:23,680
the debug support we had a fairly simple

313
00:09:22,160 --> 00:09:25,199
set of capabilities we thought would be

314
00:09:23,680 --> 00:09:28,000
enough to debug problems

315
00:09:25,200 --> 00:09:30,320
uh breakpoints by by method name

316
00:09:28,000 --> 00:09:32,080
breakpoints by file and line number

317
00:09:30,320 --> 00:09:33,600
the ability to step when you reach a

318
00:09:32,080 --> 00:09:35,839
breakpoint line by line

319
00:09:33,600 --> 00:09:36,800
stepping into a rover functions back

320
00:09:35,839 --> 00:09:38,399
traces

321
00:09:36,800 --> 00:09:40,319
we'd like to print objects field by

322
00:09:38,399 --> 00:09:41,680
field if we can and we'd like to use

323
00:09:40,320 --> 00:09:43,440
path expressions to

324
00:09:41,680 --> 00:09:44,800
the reference through objects and pick

325
00:09:43,440 --> 00:09:47,680
values out using a

326
00:09:44,800 --> 00:09:50,560
as a field axis so on so that's the sort

327
00:09:47,680 --> 00:09:53,760
of capability we really wanted to add

328
00:09:50,560 --> 00:09:55,199
um so what happened

329
00:09:53,760 --> 00:09:57,200
what were the things we encountered we

330
00:09:55,200 --> 00:09:59,040
did that well um

331
00:09:57,200 --> 00:10:00,720
with the arm code two and a half years

332
00:09:59,040 --> 00:10:03,040
ago we started this it's actually

333
00:10:00,720 --> 00:10:04,880
still ongoing we've been slowly adding

334
00:10:03,040 --> 00:10:06,079
things we've met in real problems

335
00:10:04,880 --> 00:10:06,959
because of the complexity of the

336
00:10:06,079 --> 00:10:09,279
compiler

337
00:10:06,959 --> 00:10:10,319
um it was very difficult to get things

338
00:10:09,279 --> 00:10:11,519
into the code base

339
00:10:10,320 --> 00:10:12,880
but actually there were problems with

340
00:10:11,519 --> 00:10:13,920
the development process and where that

341
00:10:12,880 --> 00:10:16,079
was organized

342
00:10:13,920 --> 00:10:17,599
and there was also problems with our

343
00:10:16,079 --> 00:10:18,000
understanding of where grahl was going

344
00:10:17,600 --> 00:10:21,920
what the

345
00:10:18,000 --> 00:10:21,920
the road map was for growl um

346
00:10:22,000 --> 00:10:26,240
i'll talk quite a bit about the capacity

347
00:10:23,760 --> 00:10:28,720
because this is really quite important

348
00:10:26,240 --> 00:10:29,360
any compiler is going to be complex

349
00:10:28,720 --> 00:10:31,200
you've got

350
00:10:29,360 --> 00:10:32,640
usually a high middle and low tier of

351
00:10:31,200 --> 00:10:35,920
transformation stages in

352
00:10:32,640 --> 00:10:37,680
in a graph model and um

353
00:10:35,920 --> 00:10:40,240
so there's a whole load of different uh

354
00:10:37,680 --> 00:10:41,839
uh uh operations happen in in various

355
00:10:40,240 --> 00:10:43,200
stages some of them are itchative some

356
00:10:41,839 --> 00:10:44,640
of them are nested

357
00:10:43,200 --> 00:10:45,920
understanding what happens with where

358
00:10:44,640 --> 00:10:47,360
the flow of controllers is really quite

359
00:10:45,920 --> 00:10:48,880
difficult thing to do

360
00:10:47,360 --> 00:10:51,040
and you're massaging a graph and

361
00:10:48,880 --> 00:10:53,360
transforming its shape all the time

362
00:10:51,040 --> 00:10:54,640
so um nodes come and go so aligning the

363
00:10:53,360 --> 00:10:56,320
life cycles of the graph

364
00:10:54,640 --> 00:10:58,319
and the life cycles of the phases is

365
00:10:56,320 --> 00:11:00,399
always a problem when you have a very

366
00:10:58,320 --> 00:11:02,480
deep node hierarchy you may have a phase

367
00:11:00,399 --> 00:11:05,040
that operates on a generic node type

368
00:11:02,480 --> 00:11:06,000
but which actual types of node does it

369
00:11:05,040 --> 00:11:08,399
really operate on

370
00:11:06,000 --> 00:11:09,839
same views a lot of interfaces so these

371
00:11:08,399 --> 00:11:11,600
are generic problems but the

372
00:11:09,839 --> 00:11:12,720
the problems that are the problems that

373
00:11:11,600 --> 00:11:13,760
growl faces but i think it's

374
00:11:12,720 --> 00:11:15,200
particularly difficult with growl

375
00:11:13,760 --> 00:11:16,800
because of questions of scale

376
00:11:15,200 --> 00:11:18,480
but there's also the configurability

377
00:11:16,800 --> 00:11:20,560
issue

378
00:11:18,480 --> 00:11:21,839
growl is used by many clients for many

379
00:11:20,560 --> 00:11:24,000
different purposes

380
00:11:21,839 --> 00:11:25,760
so all those phases that apply in each

381
00:11:24,000 --> 00:11:28,720
suite and all the different back ends

382
00:11:25,760 --> 00:11:29,680
are different for different uses and

383
00:11:28,720 --> 00:11:31,040
that makes it

384
00:11:29,680 --> 00:11:32,719
that means there's a lot of possible

385
00:11:31,040 --> 00:11:33,760
combinations of choices of what might be

386
00:11:32,720 --> 00:11:35,279
going on in the gra

387
00:11:33,760 --> 00:11:37,439
in the graph transformation process

388
00:11:35,279 --> 00:11:38,560
particularly they also use a plug-in

389
00:11:37,440 --> 00:11:39,200
model which allows you to take a

390
00:11:38,560 --> 00:11:40,959
particular

391
00:11:39,200 --> 00:11:42,720
method operation or a family of method

392
00:11:40,959 --> 00:11:44,800
operations or a particular

393
00:11:42,720 --> 00:11:46,079
code operation and to have some special

394
00:11:44,800 --> 00:11:48,959
handy viral plug-in

395
00:11:46,079 --> 00:11:49,519
and each each uh different client plugs

396
00:11:48,959 --> 00:11:50,959
in different

397
00:11:49,519 --> 00:11:52,320
phases to these different operations

398
00:11:50,959 --> 00:11:54,319
there's another indirection makers of

399
00:11:52,320 --> 00:11:56,240
where things happen

400
00:11:54,320 --> 00:11:58,320
annotations are used on the code to

401
00:11:56,240 --> 00:12:00,079
guide these operations to guide

402
00:11:58,320 --> 00:12:02,160
how the phases operate how the plugins

403
00:12:00,079 --> 00:12:02,479
operate so you need to understand how

404
00:12:02,160 --> 00:12:04,480
the

405
00:12:02,480 --> 00:12:06,079
annotations actually side affect this

406
00:12:04,480 --> 00:12:06,720
and what makes it really complicated is

407
00:12:06,079 --> 00:12:08,079
that

408
00:12:06,720 --> 00:12:10,079
some of the annotations are defined in

409
00:12:08,079 --> 00:12:12,399
substrate classes and they affect the

410
00:12:10,079 --> 00:12:13,199
way that jdk classes are modified and

411
00:12:12,399 --> 00:12:14,880
compiled

412
00:12:13,200 --> 00:12:16,160
there's an indirect mechanism so you can

413
00:12:14,880 --> 00:12:17,120
see there's lots of hooks and lots of

414
00:12:16,160 --> 00:12:18,639
indirections that

415
00:12:17,120 --> 00:12:20,639
make the complexity of this really

416
00:12:18,639 --> 00:12:22,399
really difficult to follow

417
00:12:20,639 --> 00:12:24,240
and a lot of the configuration is done

418
00:12:22,399 --> 00:12:27,040
with a layered hierarchical

419
00:12:24,240 --> 00:12:27,519
uh overriding model so you have a a

420
00:12:27,040 --> 00:12:28,959
basic

421
00:12:27,519 --> 00:12:30,639
uh suite provider that provides the

422
00:12:28,959 --> 00:12:32,638
phases you have a hotspot

423
00:12:30,639 --> 00:12:34,560
for suite provider and then you have an

424
00:12:32,639 --> 00:12:35,200
aot hotspot suite provider so there are

425
00:12:34,560 --> 00:12:36,479
these

426
00:12:35,200 --> 00:12:39,040
not everything's in one place it's

427
00:12:36,480 --> 00:12:40,480
distributed so it's really really very

428
00:12:39,040 --> 00:12:42,000
complex

429
00:12:40,480 --> 00:12:45,040
some of the numbers involved there are

430
00:12:42,000 --> 00:12:46,160
150 subclasses of class phase this is a

431
00:12:45,040 --> 00:12:47,519
thing that does a single graph

432
00:12:46,160 --> 00:12:49,439
transformation

433
00:12:47,519 --> 00:12:51,680
there are 200 different types of graph

434
00:12:49,440 --> 00:12:53,519
node in in the code base

435
00:12:51,680 --> 00:12:55,760
access which is an interface that's used

436
00:12:53,519 --> 00:12:57,600
to encapsulate all the memory nodes has

437
00:12:55,760 --> 00:12:58,160
21 different types of read or write

438
00:12:57,600 --> 00:13:00,959
nodes

439
00:12:58,160 --> 00:13:02,719
or in one case a read write node um the

440
00:13:00,959 --> 00:13:04,160
graph builder plug-in that does special

441
00:13:02,720 --> 00:13:05,040
case side effecting for particular

442
00:13:04,160 --> 00:13:07,519
transformations

443
00:13:05,040 --> 00:13:09,040
200 different uh graph builder plugins

444
00:13:07,519 --> 00:13:11,360
nine different types of plugins doing

445
00:13:09,040 --> 00:13:13,279
different types of transformations

446
00:13:11,360 --> 00:13:14,959
and there are 200 annotations that

447
00:13:13,279 --> 00:13:16,720
direct these operations these

448
00:13:14,959 --> 00:13:19,839
transformation operations in different

449
00:13:16,720 --> 00:13:21,760
different paths and of course the other

450
00:13:19,839 --> 00:13:22,079
problem we had was when when we started

451
00:13:21,760 --> 00:13:24,240
this

452
00:13:22,079 --> 00:13:25,680
the arm port was relatively new so there

453
00:13:24,240 --> 00:13:27,120
were problems with the code and the

454
00:13:25,680 --> 00:13:30,399
shifting code base

455
00:13:27,120 --> 00:13:32,399
um uh the arm64 code was the least

456
00:13:30,399 --> 00:13:33,680
stable part of the compiler

457
00:13:32,399 --> 00:13:35,040
but actually there were problems with

458
00:13:33,680 --> 00:13:35,519
some of the generic code so when we

459
00:13:35,040 --> 00:13:36,880
tried to

460
00:13:35,519 --> 00:13:39,440
fix what we thought were back-end

461
00:13:36,880 --> 00:13:41,439
problems in the r64 port and improve

462
00:13:39,440 --> 00:13:42,639
code quality we actually ran up against

463
00:13:41,440 --> 00:13:43,760
things that were problems in generic

464
00:13:42,639 --> 00:13:44,560
code that didn't quite do what was

465
00:13:43,760 --> 00:13:46,000
needed so

466
00:13:44,560 --> 00:13:48,000
there were generic fixes needed we

467
00:13:46,000 --> 00:13:50,959
weren't in a position to do that

468
00:13:48,000 --> 00:13:52,800
um and actually um that that generic

469
00:13:50,959 --> 00:13:54,319
code was also still in flux a bit at

470
00:13:52,800 --> 00:13:55,279
that point it's got better synths and

471
00:13:54,320 --> 00:13:56,399
we've managed to make some of the

472
00:13:55,279 --> 00:13:57,839
generic changes

473
00:13:56,399 --> 00:13:59,920
but um it really meant that we had to

474
00:13:57,839 --> 00:14:00,959
either rework things or withdraw some of

475
00:13:59,920 --> 00:14:02,800
things because they were just too

476
00:14:00,959 --> 00:14:04,560
fragile

477
00:14:02,800 --> 00:14:05,839
but the really biggest problem was the

478
00:14:04,560 --> 00:14:08,638
development process

479
00:14:05,839 --> 00:14:10,800
um the growl engineers that stage were

480
00:14:08,639 --> 00:14:12,880
working on their own on their own repo

481
00:14:10,800 --> 00:14:14,800
with their own management system and

482
00:14:12,880 --> 00:14:16,240
they put up a github repo with pr's for

483
00:14:14,800 --> 00:14:17,599
us to try and push things in

484
00:14:16,240 --> 00:14:19,199
but they were really focused somewhere

485
00:14:17,600 --> 00:14:20,880
else and they weren't ready to be

486
00:14:19,199 --> 00:14:22,160
receiving things from us they weren't

487
00:14:20,880 --> 00:14:23,680
even really looking at what we were

488
00:14:22,160 --> 00:14:25,519
doing because they were actually looking

489
00:14:23,680 --> 00:14:27,359
internally to their own group so getting

490
00:14:25,519 --> 00:14:28,880
them to actually be prepared and

491
00:14:27,360 --> 00:14:30,240
understand the implications of trying to

492
00:14:28,880 --> 00:14:31,360
build a community and to work with that

493
00:14:30,240 --> 00:14:34,639
was actually quite a long

494
00:14:31,360 --> 00:14:36,480
a long slow process um it it didn't help

495
00:14:34,639 --> 00:14:38,320
also that the final testing stage this

496
00:14:36,480 --> 00:14:39,440
is an old story of over jdk was done

497
00:14:38,320 --> 00:14:42,240
behind the scenes

498
00:14:39,440 --> 00:14:43,360
in oracle and so when we put changes in

499
00:14:42,240 --> 00:14:44,959
did get them through

500
00:14:43,360 --> 00:14:46,160
we sometimes get a cryptic message

501
00:14:44,959 --> 00:14:47,439
something had gone wrong but we couldn't

502
00:14:46,160 --> 00:14:49,279
see what had gone wrong

503
00:14:47,440 --> 00:14:50,880
because we couldn't see the tests and we

504
00:14:49,279 --> 00:14:51,519
couldn't see what changes oracle putting

505
00:14:50,880 --> 00:14:52,720
into the

506
00:14:51,519 --> 00:14:54,000
uh into the code base it might have

507
00:14:52,720 --> 00:14:54,800
broken our tests until they eventually

508
00:14:54,000 --> 00:14:56,880
came forward

509
00:14:54,800 --> 00:14:58,399
into their shadow reaper we could see so

510
00:14:56,880 --> 00:15:00,880
it was really done at a distance it was

511
00:14:58,399 --> 00:15:00,880
quite hard

512
00:15:02,000 --> 00:15:05,920
sorry did i just yeah um the other the

513
00:15:04,639 --> 00:15:07,680
other problem was that um

514
00:15:05,920 --> 00:15:09,680
where what this product was and where it

515
00:15:07,680 --> 00:15:11,359
was going was quite difficult for us to

516
00:15:09,680 --> 00:15:12,880
see growler's got a very long history

517
00:15:11,360 --> 00:15:15,360
relates back to maxine

518
00:15:12,880 --> 00:15:16,639
i think before that jikes this idea of

519
00:15:15,360 --> 00:15:18,480
java and java and

520
00:15:16,639 --> 00:15:19,760
all the sort of generalizations that

521
00:15:18,480 --> 00:15:20,639
graham was doing all these capable

522
00:15:19,760 --> 00:15:22,079
capabilities

523
00:15:20,639 --> 00:15:23,920
was think we gradually began to

524
00:15:22,079 --> 00:15:25,439
understand it wasn't just a jit compiler

525
00:15:23,920 --> 00:15:27,279
and an aot compiler

526
00:15:25,440 --> 00:15:28,800
it was actually not just an interpreter

527
00:15:27,279 --> 00:15:29,600
framework it had all these other uses as

528
00:15:28,800 --> 00:15:32,639
well

529
00:15:29,600 --> 00:15:34,160
and um part of that was us not really

530
00:15:32,639 --> 00:15:35,759
knowing enough about it and not reading

531
00:15:34,160 --> 00:15:37,439
the right things we just went in to do a

532
00:15:35,759 --> 00:15:39,199
job and fix some code

533
00:15:37,440 --> 00:15:41,279
part of it i think was that the the map

534
00:15:39,199 --> 00:15:43,120
that oracle labs had for the product was

535
00:15:41,279 --> 00:15:44,240
not clear anyway they had different

536
00:15:43,120 --> 00:15:44,880
ideas about what they would do with

537
00:15:44,240 --> 00:15:46,320
growl

538
00:15:44,880 --> 00:15:48,480
what would be the key thing that would

539
00:15:46,320 --> 00:15:50,880
be his key value proposition and so on

540
00:15:48,480 --> 00:15:52,000
so there was it wasn't all our fault but

541
00:15:50,880 --> 00:15:54,320
it was uh that was in

542
00:15:52,000 --> 00:15:56,079
to a great degree our problem but there

543
00:15:54,320 --> 00:15:56,959
was no public road map it wasn't really

544
00:15:56,079 --> 00:15:58,880
because it was a

545
00:15:56,959 --> 00:16:00,319
a private project that was trying to

546
00:15:58,880 --> 00:16:03,040
become an open source project and none

547
00:16:00,320 --> 00:16:06,000
of the things were in place there

548
00:16:03,040 --> 00:16:07,360
um with jfo our support there were josh

549
00:16:06,000 --> 00:16:08,480
had real problems understanding he had

550
00:16:07,360 --> 00:16:09,839
to go through much the same learning

551
00:16:08,480 --> 00:16:11,120
process i had with a compiler with

552
00:16:09,839 --> 00:16:12,880
substrate vm

553
00:16:11,120 --> 00:16:14,480
understand some of the limits of how it

554
00:16:12,880 --> 00:16:16,079
operates um

555
00:16:14,480 --> 00:16:17,279
he was trying to link in jfr code

556
00:16:16,079 --> 00:16:19,279
there's native code and there's real

557
00:16:17,279 --> 00:16:21,199
issues with linking things in

558
00:16:19,279 --> 00:16:22,560
this substitution mechanic replaces

559
00:16:21,199 --> 00:16:23,519
things meant you could think this thing

560
00:16:22,560 --> 00:16:24,880
was going to happen because that's the

561
00:16:23,519 --> 00:16:26,639
way it works in the

562
00:16:24,880 --> 00:16:27,920
in the jdk runtime but actually it's

563
00:16:26,639 --> 00:16:28,880
different in substrate

564
00:16:27,920 --> 00:16:30,639
and just putting the whole thing

565
00:16:28,880 --> 00:16:31,519
together required a lot of understanding

566
00:16:30,639 --> 00:16:33,279
and of course be

567
00:16:31,519 --> 00:16:34,800
since it was more new than to compile

568
00:16:33,279 --> 00:16:37,519
even though we did this more recently

569
00:16:34,800 --> 00:16:38,639
it was still a bit of a moving target

570
00:16:37,519 --> 00:16:40,320
one of the things that you have to

571
00:16:38,639 --> 00:16:42,560
really deal with is the fact that

572
00:16:40,320 --> 00:16:43,600
um you can't use reflection and you

573
00:16:42,560 --> 00:16:45,359
can't load close

574
00:16:43,600 --> 00:16:46,880
load classes dynamically so you've got

575
00:16:45,360 --> 00:16:47,440
to make sure that any class you want the

576
00:16:46,880 --> 00:16:50,079
image

577
00:16:47,440 --> 00:16:51,839
is notified to the growl um code

578
00:16:50,079 --> 00:16:53,519
analysis the points to analysis

579
00:16:51,839 --> 00:16:55,600
so that it will get linked in and

580
00:16:53,519 --> 00:16:57,920
compiled in ahead ahead of time

581
00:16:55,600 --> 00:16:59,759
so you've got to actually go about

582
00:16:57,920 --> 00:17:01,839
getting code that uses relies on these

583
00:16:59,759 --> 00:17:02,959
features to work in a different way

584
00:17:01,839 --> 00:17:04,400
and you have to understand how to do

585
00:17:02,959 --> 00:17:05,918
that and similarly jay and i you can't

586
00:17:04,400 --> 00:17:06,480
just load a library and have native

587
00:17:05,919 --> 00:17:08,640
methods

588
00:17:06,480 --> 00:17:11,039
there's a registration mechanism for

589
00:17:08,640 --> 00:17:13,839
registering uh foreign code

590
00:17:11,039 --> 00:17:14,319
um that was actually quite um tricky to

591
00:17:13,839 --> 00:17:17,599
do

592
00:17:14,319 --> 00:17:18,000
um and this actually changed part way

593
00:17:17,599 --> 00:17:20,000
through as

594
00:17:18,000 --> 00:17:22,559
i said all the java code was replaced

595
00:17:20,000 --> 00:17:25,520
with callouts to the java libraries

596
00:17:22,559 --> 00:17:27,678
so lib libnet lib zip and so on the one

597
00:17:25,520 --> 00:17:29,679
library that wasn't included was lib jvm

598
00:17:27,679 --> 00:17:30,799
and of course the jfr code that we

599
00:17:29,679 --> 00:17:33,200
wanted to use

600
00:17:30,799 --> 00:17:34,000
is in lib jvm so josh is still working

601
00:17:33,200 --> 00:17:35,679
on getting that

602
00:17:34,000 --> 00:17:38,320
factored out and actually linking that

603
00:17:35,679 --> 00:17:40,000
as as a separate static library

604
00:17:38,320 --> 00:17:41,039
um and that means the other

605
00:17:40,000 --> 00:17:42,320
authenticator would have been rewriting

606
00:17:41,039 --> 00:17:43,679
it all in java and that's really not an

607
00:17:42,320 --> 00:17:44,960
interactive proposition

608
00:17:43,679 --> 00:17:47,280
so that's been the biggest stumbling

609
00:17:44,960 --> 00:17:49,760
block that hasn't resolved yet

610
00:17:47,280 --> 00:17:51,520
um as i said if you're if you you're

611
00:17:49,760 --> 00:17:53,440
looking at the way that the um the

612
00:17:51,520 --> 00:17:54,879
jdk runtime code works josh was looking

613
00:17:53,440 --> 00:17:55,840
at system load library trying to get a

614
00:17:54,880 --> 00:17:57,760
library loaded

615
00:17:55,840 --> 00:17:59,280
to get some foreign code in and system

616
00:17:57,760 --> 00:18:00,720
load library never got called because

617
00:17:59,280 --> 00:18:02,320
they'd cut above that point

618
00:18:00,720 --> 00:18:04,160
so he spent a long time trying to work

619
00:18:02,320 --> 00:18:08,320
out why his code wasn't being run

620
00:18:04,160 --> 00:18:11,840
and eventually found this out um

621
00:18:08,320 --> 00:18:14,080
the um there's another thing that that

622
00:18:11,840 --> 00:18:16,320
substrate does for optimization you can

623
00:18:14,080 --> 00:18:17,120
generate in the native image that you

624
00:18:16,320 --> 00:18:19,678
produce

625
00:18:17,120 --> 00:18:20,959
you can populate pre-populated heap with

626
00:18:19,679 --> 00:18:23,200
static

627
00:18:20,960 --> 00:18:25,280
class field data including objects that

628
00:18:23,200 --> 00:18:27,200
are computed at build time

629
00:18:25,280 --> 00:18:28,399
or else you can run class initializers

630
00:18:27,200 --> 00:18:29,760
at runtime

631
00:18:28,400 --> 00:18:31,600
now you've got to get those two things

632
00:18:29,760 --> 00:18:34,160
consistent across all the classes that

633
00:18:31,600 --> 00:18:35,678
might be side affected by

634
00:18:34,160 --> 00:18:37,280
computing and evaluate something at the

635
00:18:35,679 --> 00:18:37,840
bill in the build time context versus

636
00:18:37,280 --> 00:18:39,200
what you might

637
00:18:37,840 --> 00:18:40,879
generate if you compute things in the

638
00:18:39,200 --> 00:18:42,799
runtime context you get those wrong you

639
00:18:40,880 --> 00:18:44,080
get these really subtle bugs so that was

640
00:18:42,799 --> 00:18:45,760
another thing that was really hard

641
00:18:44,080 --> 00:18:47,360
to decide what should be initialized at

642
00:18:45,760 --> 00:18:48,559
build time what should be initialized at

643
00:18:47,360 --> 00:18:50,240
runtime and whether any existing

644
00:18:48,559 --> 00:18:51,840
decisions that were made about that

645
00:18:50,240 --> 00:18:53,280
might snooker you so josh spent a lot of

646
00:18:51,840 --> 00:18:55,199
time working through that

647
00:18:53,280 --> 00:18:58,399
so he's had a really difficult time of

648
00:18:55,200 --> 00:19:00,480
it actually um

649
00:18:58,400 --> 00:19:01,919
and again this code was in flux there

650
00:19:00,480 --> 00:19:03,600
were things changing but particularly

651
00:19:01,919 --> 00:19:05,120
the library the way that the jni and the

652
00:19:03,600 --> 00:19:06,719
library stuff was changed really

653
00:19:05,120 --> 00:19:08,959
meant you had to redo a whole lot of

654
00:19:06,720 --> 00:19:10,320
work the debuggings

655
00:19:08,960 --> 00:19:12,000
work is something i've done much more

656
00:19:10,320 --> 00:19:13,439
recently than josh and it's been

657
00:19:12,000 --> 00:19:15,440
probably the easiest thing but i think

658
00:19:13,440 --> 00:19:17,039
by this stage we understand a lot more

659
00:19:15,440 --> 00:19:18,640
um it's actually also a relatively

660
00:19:17,039 --> 00:19:20,640
self-contained thing which is

661
00:19:18,640 --> 00:19:22,320
if you've got code in your code base or

662
00:19:20,640 --> 00:19:23,679
types in your your type base for this

663
00:19:22,320 --> 00:19:26,240
analysis universe

664
00:19:23,679 --> 00:19:27,039
how do you tell a debugger about it so

665
00:19:26,240 --> 00:19:28,240
um

666
00:19:27,039 --> 00:19:30,320
that one of the problems we had was to

667
00:19:28,240 --> 00:19:31,840
put this in a way that doesn't upset the

668
00:19:30,320 --> 00:19:32,559
upstream implementation that already

669
00:19:31,840 --> 00:19:33,840
exists

670
00:19:32,559 --> 00:19:34,639
so that's one of the constraints we're

671
00:19:33,840 --> 00:19:36,480
going to have to go through in the

672
00:19:34,640 --> 00:19:37,840
review process

673
00:19:36,480 --> 00:19:39,840
the biggest technical challenge is

674
00:19:37,840 --> 00:19:41,600
making sure that the the stuff that

675
00:19:39,840 --> 00:19:42,159
writes the object file doesn't have to

676
00:19:41,600 --> 00:19:44,639
know about

677
00:19:42,160 --> 00:19:46,240
all the other uh types that the in in in

678
00:19:44,640 --> 00:19:47,120
the compiler and the heap management

679
00:19:46,240 --> 00:19:49,039
code and so on

680
00:19:47,120 --> 00:19:50,479
so that there's only one one sort of

681
00:19:49,039 --> 00:19:52,160
constraint and that just was defining

682
00:19:50,480 --> 00:19:53,120
single interfaces to allow these things

683
00:19:52,160 --> 00:19:55,520
to happen but that was

684
00:19:53,120 --> 00:19:57,199
decoupled fairly easily um i haven't

685
00:19:55,520 --> 00:19:58,879
looked yet at making this a

686
00:19:57,200 --> 00:20:00,400
an optional feature using all the sort

687
00:19:58,880 --> 00:20:02,320
of mechanisms grail uses for

688
00:20:00,400 --> 00:20:03,760
enabling features i'm assuming that's

689
00:20:02,320 --> 00:20:04,720
going to come out of the review process

690
00:20:03,760 --> 00:20:07,919
i hope so

691
00:20:04,720 --> 00:20:10,000
but it's been pretty successful so with

692
00:20:07,919 --> 00:20:12,240
the jit we did get some very basic

693
00:20:10,000 --> 00:20:13,840
things in about two years ago

694
00:20:12,240 --> 00:20:15,840
we had another little round about 18

695
00:20:13,840 --> 00:20:18,158
months ago and got a little bit more in

696
00:20:15,840 --> 00:20:19,600
in the last year uh roland westerlin has

697
00:20:18,159 --> 00:20:20,799
managed to make some generic changes

698
00:20:19,600 --> 00:20:23,439
with the grail compiler

699
00:20:20,799 --> 00:20:24,559
team and actually um arm have also

700
00:20:23,440 --> 00:20:26,799
contributed some of the

701
00:20:24,559 --> 00:20:28,240
instruction reduction optimizations

702
00:20:26,799 --> 00:20:29,600
quite a lot of stuff there so

703
00:20:28,240 --> 00:20:31,120
we have had quite a lot of success

704
00:20:29,600 --> 00:20:32,799
eventually it just took several goes to

705
00:20:31,120 --> 00:20:34,559
get there

706
00:20:32,799 --> 00:20:35,840
josh is still really struggling getting

707
00:20:34,559 --> 00:20:38,000
a working prototype

708
00:20:35,840 --> 00:20:39,439
in a native image he's got the event

709
00:20:38,000 --> 00:20:40,159
stuff worked out he understands what he

710
00:20:39,440 --> 00:20:41,679
needs to do

711
00:20:40,159 --> 00:20:43,039
we can run that in fullback mode when it

712
00:20:41,679 --> 00:20:44,240
runs on opportunity and that we know

713
00:20:43,039 --> 00:20:45,840
it's going to work but he's still going

714
00:20:44,240 --> 00:20:46,240
to deal with the library linkage problem

715
00:20:45,840 --> 00:20:47,760
so

716
00:20:46,240 --> 00:20:49,120
we'll probably be a few more weeks

717
00:20:47,760 --> 00:20:50,480
before we get anywhere having something

718
00:20:49,120 --> 00:20:52,639
that's a working prototype

719
00:20:50,480 --> 00:20:54,080
that we can then polish up and submit so

720
00:20:52,640 --> 00:20:55,440
that's still a work in progress there

721
00:20:54,080 --> 00:20:58,158
unfortunately

722
00:20:55,440 --> 00:20:59,280
the debug stuff i actually um two weeks

723
00:20:58,159 --> 00:21:01,679
ago submitted a

724
00:20:59,280 --> 00:21:02,320
a pull request with the first three

725
00:21:01,679 --> 00:21:04,799
features

726
00:21:02,320 --> 00:21:05,360
it so we now have for linux and gdb we

727
00:21:04,799 --> 00:21:08,158
have

728
00:21:05,360 --> 00:21:10,320
working break points working um line

729
00:21:08,159 --> 00:21:12,000
stepping and working back traces

730
00:21:10,320 --> 00:21:13,840
and the type stuff is the next thing i'm

731
00:21:12,000 --> 00:21:14,720
going to add in that's just gone in for

732
00:21:13,840 --> 00:21:17,678
review

733
00:21:14,720 --> 00:21:18,240
and um uh we've had i got just two days

734
00:21:17,679 --> 00:21:20,320
ago

735
00:21:18,240 --> 00:21:22,080
um a nice big set of review comments

736
00:21:20,320 --> 00:21:24,000
from paul burger which is really good so

737
00:21:22,080 --> 00:21:25,520
oracle were really helpful with this

738
00:21:24,000 --> 00:21:26,240
they um they actually gave us a whole

739
00:21:25,520 --> 00:21:27,679
lot of hints and

740
00:21:26,240 --> 00:21:29,600
some which i'd already found which i

741
00:21:27,679 --> 00:21:30,159
haven't when we we raised this as an

742
00:21:29,600 --> 00:21:31,280
issue

743
00:21:30,159 --> 00:21:32,720
and they've actually they've actually

744
00:21:31,280 --> 00:21:34,480
been very cooperative about getting this

745
00:21:32,720 --> 00:21:35,600
into the product so that's been really

746
00:21:34,480 --> 00:21:37,280
quite heartening and i think this will

747
00:21:35,600 --> 00:21:38,399
probably go in in the next two or three

748
00:21:37,280 --> 00:21:40,240
weeks i'll have the core

749
00:21:38,400 --> 00:21:42,159
debug functionality and then i'll work

750
00:21:40,240 --> 00:21:45,520
on round two next

751
00:21:42,159 --> 00:21:46,080
um the process has got better the oracle

752
00:21:45,520 --> 00:21:48,000
engineers

753
00:21:46,080 --> 00:21:49,600
and in labs are much more aware of our

754
00:21:48,000 --> 00:21:50,720
existence i mean we've been bombarding

755
00:21:49,600 --> 00:21:51,439
them in a way with lots pull requests

756
00:21:50,720 --> 00:21:53,360
not just us

757
00:21:51,440 --> 00:21:55,200
but the caucus team and many other users

758
00:21:53,360 --> 00:21:56,399
of growl but a lot of them have risen to

759
00:21:55,200 --> 00:21:58,080
that and started working with the

760
00:21:56,400 --> 00:21:59,679
community more um

761
00:21:58,080 --> 00:22:01,439
they're still working on their own repo

762
00:21:59,679 --> 00:22:02,799
that's the problem but they are more

763
00:22:01,440 --> 00:22:04,080
aware and they're more responsive

764
00:22:02,799 --> 00:22:05,679
they've always been helpful it's just

765
00:22:04,080 --> 00:22:07,039
the time this response has been

766
00:22:05,679 --> 00:22:08,720
the biggest problem they're now much

767
00:22:07,039 --> 00:22:09,520
quicker and we know who people are and

768
00:22:08,720 --> 00:22:11,039
that really helps

769
00:22:09,520 --> 00:22:12,639
and they know who we are as well we had

770
00:22:11,039 --> 00:22:14,158
a committers workshop we met them

771
00:22:12,640 --> 00:22:16,320
we made some good contacts so that's

772
00:22:14,159 --> 00:22:18,000
really helped in terms of us actually uh

773
00:22:16,320 --> 00:22:19,120
just getting things to happen because it

774
00:22:18,000 --> 00:22:21,600
just makes a difference if you've

775
00:22:19,120 --> 00:22:23,520
met face to face and you know people

776
00:22:21,600 --> 00:22:26,240
it's just a fact of the world

777
00:22:23,520 --> 00:22:27,840
um the planning process we understand a

778
00:22:26,240 --> 00:22:29,200
lot more where growlers come from and

779
00:22:27,840 --> 00:22:31,360
that was particularly helped by think

780
00:22:29,200 --> 00:22:33,440
talking to the growl developers and they

781
00:22:31,360 --> 00:22:35,280
they also we also have more idea of

782
00:22:33,440 --> 00:22:36,799
where the products going and how we can

783
00:22:35,280 --> 00:22:38,559
now fit our work in

784
00:22:36,799 --> 00:22:39,840
um and the committee's workshop was

785
00:22:38,559 --> 00:22:40,879
actually very helpful in getting all

786
00:22:39,840 --> 00:22:42,480
that to happen

787
00:22:40,880 --> 00:22:44,720
and we've got a we've got an agreement

788
00:22:42,480 --> 00:22:46,240
that the open jdk team

789
00:22:44,720 --> 00:22:48,559
and our middleware team who are working

790
00:22:46,240 --> 00:22:49,120
on caucus will regularly review and some

791
00:22:48,559 --> 00:22:50,879
of the other

792
00:22:49,120 --> 00:22:52,719
people contributing outside of red hat

793
00:22:50,880 --> 00:22:53,919
as well will regularly review things of

794
00:22:52,720 --> 00:22:55,200
the growl team we're trying to just

795
00:22:53,919 --> 00:22:58,000
improve the process

796
00:22:55,200 --> 00:22:59,120
and and and make sure we plan things

797
00:22:58,000 --> 00:23:00,880
we've been actually given

798
00:22:59,120 --> 00:23:02,320
ownership of the issues for some of the

799
00:23:00,880 --> 00:23:04,559
compiler issues and

800
00:23:02,320 --> 00:23:05,760
for the debug info and i'm assuming that

801
00:23:04,559 --> 00:23:06,399
in the longer term we'll get that with

802
00:23:05,760 --> 00:23:08,158
the jfr

803
00:23:06,400 --> 00:23:10,240
issue as well so we now actually have

804
00:23:08,159 --> 00:23:11,360
responsible for the ability to negotiate

805
00:23:10,240 --> 00:23:13,120
all that with the community

806
00:23:11,360 --> 00:23:14,719
and seeing it through your view so

807
00:23:13,120 --> 00:23:16,239
there's been a certain devolution of

808
00:23:14,720 --> 00:23:17,919
ownership and responsibility as well

809
00:23:16,240 --> 00:23:19,600
which i see is one of the most positive

810
00:23:17,919 --> 00:23:22,240
things that's happened just in the last

811
00:23:19,600 --> 00:23:23,039
last week that happened so i think

812
00:23:22,240 --> 00:23:25,679
hopefully

813
00:23:23,039 --> 00:23:26,320
just to wrap up um we had a lot of

814
00:23:25,679 --> 00:23:28,640
problems

815
00:23:26,320 --> 00:23:30,480
there are still some structural problems

816
00:23:28,640 --> 00:23:31,039
we've learned a lot by doing all this

817
00:23:30,480 --> 00:23:33,039
and

818
00:23:31,039 --> 00:23:35,039
we've also i think we've helped educate

819
00:23:33,039 --> 00:23:36,400
the oracle lab stream about how to work

820
00:23:35,039 --> 00:23:38,320
with the community and how to build up a

821
00:23:36,400 --> 00:23:39,600
community and benefit from having

822
00:23:38,320 --> 00:23:41,918
community input

823
00:23:39,600 --> 00:23:43,520
um the project is now i think

824
00:23:41,919 --> 00:23:44,880
stabilizing a lot more it's

825
00:23:43,520 --> 00:23:46,000
oracle are clear where they're going or

826
00:23:44,880 --> 00:23:46,559
the labs are clear where they're going

827
00:23:46,000 --> 00:23:48,720
with this

828
00:23:46,559 --> 00:23:50,720
and i think we know where we need to go

829
00:23:48,720 --> 00:23:52,960
with it to to keep the

830
00:23:50,720 --> 00:23:54,640
functionality we need in the community

831
00:23:52,960 --> 00:23:55,440
and so i'm hoping that this is going to

832
00:23:54,640 --> 00:23:58,080
be an up and up

833
00:23:55,440 --> 00:24:00,320
rather than um something that gets

834
00:23:58,080 --> 00:24:01,520
stymied or stagnated here so i'm

835
00:24:00,320 --> 00:24:03,360
quite optimistic about this at the

836
00:24:01,520 --> 00:24:06,960
moment so

837
00:24:03,360 --> 00:24:09,439
how's that doing time for questions no

838
00:24:06,960 --> 00:24:10,159
not really all right well i'll take them

839
00:24:09,440 --> 00:24:12,000
offline

840
00:24:10,159 --> 00:24:13,760
i'm sure andrew would be happy to answer

841
00:24:12,000 --> 00:24:18,200
any and all of your questions

842
00:24:13,760 --> 00:24:24,910
on the corridor track

843
00:24:18,200 --> 00:24:24,910
[Applause]

