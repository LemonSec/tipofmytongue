1
00:00:13,280 --> 00:00:16,720
so

2
00:00:13,679 --> 00:00:17,440
um hello everyone i'm vitaly i work for

3
00:00:16,720 --> 00:00:19,759
red hat

4
00:00:17,440 --> 00:00:22,240
and i'm gonna talk about cpu

5
00:00:19,760 --> 00:00:26,880
vulnerabilities and public clouds today

6
00:00:22,240 --> 00:00:28,640
so i usually work on linux kernel

7
00:00:26,880 --> 00:00:30,080
enabling linux on like third-party

8
00:00:28,640 --> 00:00:33,600
hypervisors and public

9
00:00:30,080 --> 00:00:36,640
clouds and i'm also a kvm reviewer in my

10
00:00:33,600 --> 00:00:39,440
spare time one of the kvm reviewers

11
00:00:36,640 --> 00:00:40,079
so uh as you know there were like a

12
00:00:39,440 --> 00:00:42,800
couple

13
00:00:40,079 --> 00:00:44,640
vulnerabilities uh discovered in the

14
00:00:42,800 --> 00:00:46,879
last like two years

15
00:00:44,640 --> 00:00:48,399
and you've probably heard about all of

16
00:00:46,879 --> 00:00:49,599
them they have someone something in

17
00:00:48,399 --> 00:00:52,320
common they are like

18
00:00:49,600 --> 00:00:53,600
speculative uh execution like side

19
00:00:52,320 --> 00:00:57,280
channel attacks

20
00:00:53,600 --> 00:00:58,079
which um allow an attacker to gain some

21
00:00:57,280 --> 00:01:00,399
information

22
00:00:58,079 --> 00:01:02,960
by analyzing the micro architectural the

23
00:01:00,399 --> 00:01:06,560
lower state of the cpu

24
00:01:02,960 --> 00:01:08,560
and this is something new and

25
00:01:06,560 --> 00:01:10,240
the question is like uh if you're

26
00:01:08,560 --> 00:01:12,320
running your own uh

27
00:01:10,240 --> 00:01:13,600
architecture you should be aware of them

28
00:01:12,320 --> 00:01:15,679
you should go read and

29
00:01:13,600 --> 00:01:17,280
uh see how you need to mitigate there is

30
00:01:15,680 --> 00:01:18,720
no way around that

31
00:01:17,280 --> 00:01:20,479
but what if you are running your

32
00:01:18,720 --> 00:01:22,080
workload on a public cloud right

33
00:01:20,479 --> 00:01:24,159
when there is a new vulnerability you

34
00:01:22,080 --> 00:01:27,200
probably uh you know

35
00:01:24,159 --> 00:01:28,479
open up some websites on day one and you

36
00:01:27,200 --> 00:01:29,439
read those there is a new scarab

37
00:01:28,479 --> 00:01:31,280
vulnerability

38
00:01:29,439 --> 00:01:33,839
but then there is a link to my cloud

39
00:01:31,280 --> 00:01:35,600
provider's blog post which tells me

40
00:01:33,840 --> 00:01:36,960
we took care of everything we knew about

41
00:01:35,600 --> 00:01:38,240
it for the last like three months we

42
00:01:36,960 --> 00:01:41,839
updated our fleet

43
00:01:38,240 --> 00:01:43,679
it's all good so is this toe or is

44
00:01:41,840 --> 00:01:44,960
there something you still need to be

45
00:01:43,680 --> 00:01:47,759
aware of

46
00:01:44,960 --> 00:01:48,158
the answer depends so let's take a look

47
00:01:47,759 --> 00:01:51,119
at

48
00:01:48,159 --> 00:01:52,320
the possible like attack scenarios so

49
00:01:51,119 --> 00:01:53,759
one vm like

50
00:01:52,320 --> 00:01:55,199
when we are talking about public cloud

51
00:01:53,759 --> 00:01:56,719
they're running vms they call them

52
00:01:55,200 --> 00:02:00,560
instances they call them

53
00:01:56,719 --> 00:02:01,520
uh some other types but uh the question

54
00:02:00,560 --> 00:02:03,600
is like

55
00:02:01,520 --> 00:02:05,439
start through four types of attacks like

56
00:02:03,600 --> 00:02:06,158
measure like one vm can attack another

57
00:02:05,439 --> 00:02:09,199
vm

58
00:02:06,159 --> 00:02:11,599
the vm can attack hypervisor

59
00:02:09,199 --> 00:02:12,238
and there are two other types like uh

60
00:02:11,599 --> 00:02:14,799
you can do

61
00:02:12,239 --> 00:02:16,879
mount attacks inside the vm right so

62
00:02:14,800 --> 00:02:18,959
some user space application can attack

63
00:02:16,879 --> 00:02:20,840
kernel or some user space application

64
00:02:18,959 --> 00:02:22,080
can attack another user space

65
00:02:20,840 --> 00:02:26,000
application

66
00:02:22,080 --> 00:02:28,080
so your cloud provider will most likely

67
00:02:26,000 --> 00:02:29,520
uh take care of the first two because

68
00:02:28,080 --> 00:02:30,959
they're not crazy right they can get

69
00:02:29,520 --> 00:02:34,800
sued for that

70
00:02:30,959 --> 00:02:38,000
and but what about the other two

71
00:02:34,800 --> 00:02:40,560
and the answers again it depends

72
00:02:38,000 --> 00:02:41,920
but because they think or the cloud

73
00:02:40,560 --> 00:02:43,760
providers think of

74
00:02:41,920 --> 00:02:45,839
that it's a little bit outside of their

75
00:02:43,760 --> 00:02:47,280
domain of responsibility right they

76
00:02:45,840 --> 00:02:48,959
don't guarantee you anything because

77
00:02:47,280 --> 00:02:50,239
there are multiple types of attacks

78
00:02:48,959 --> 00:02:53,840
which can be mounted

79
00:02:50,239 --> 00:02:54,400
inside the vm but they still sometimes

80
00:02:53,840 --> 00:02:56,400
need to

81
00:02:54,400 --> 00:02:58,319
provide you some tools so you can

82
00:02:56,400 --> 00:03:00,560
actually mitigate some of these

83
00:02:58,319 --> 00:03:04,000
vulnerabilities in your vms

84
00:03:00,560 --> 00:03:07,040
so the question is

85
00:03:04,000 --> 00:03:09,599
like when do you need these tools and uh

86
00:03:07,040 --> 00:03:11,280
it very much depends on what's happening

87
00:03:09,599 --> 00:03:13,599
inside your vm

88
00:03:11,280 --> 00:03:14,400
and you have to answer the questions

89
00:03:13,599 --> 00:03:15,760
like if

90
00:03:14,400 --> 00:03:18,400
it's like a single tenant or a

91
00:03:15,760 --> 00:03:20,560
multi-tenant vm if it's like

92
00:03:18,400 --> 00:03:21,599
a single task vm vm which basically runs

93
00:03:20,560 --> 00:03:23,680
one application

94
00:03:21,599 --> 00:03:25,040
or you have like multiple applications

95
00:03:23,680 --> 00:03:26,640
running there

96
00:03:25,040 --> 00:03:28,560
uh are you relying on like a

97
00:03:26,640 --> 00:03:30,839
language-based securities or is there

98
00:03:28,560 --> 00:03:34,400
like a jitted environment there

99
00:03:30,840 --> 00:03:37,519
and it's actually hyper threading

100
00:03:34,400 --> 00:03:39,680
important for you so uh

101
00:03:37,519 --> 00:03:41,680
i will go through the vulnerabilities i

102
00:03:39,680 --> 00:03:43,280
won't go into details because

103
00:03:41,680 --> 00:03:44,799
there are too many of them and i don't

104
00:03:43,280 --> 00:03:46,879
have that much time but

105
00:03:44,799 --> 00:03:48,720
i will give you like a brief overview of

106
00:03:46,879 --> 00:03:49,280
them and if you need some hardware

107
00:03:48,720 --> 00:03:50,640
features

108
00:03:49,280 --> 00:03:53,599
do they need to get passed through to

109
00:03:50,640 --> 00:03:55,599
your vm or not so uh

110
00:03:53,599 --> 00:03:56,640
let's start with spectra v1 because it's

111
00:03:55,599 --> 00:03:59,359
31

112
00:03:56,640 --> 00:04:00,559
and the attack is basically a buffer

113
00:03:59,360 --> 00:04:03,599
overflow without

114
00:04:00,560 --> 00:04:05,599
buffer overflow if you have a user

115
00:04:03,599 --> 00:04:06,640
control offset you can mount this attack

116
00:04:05,599 --> 00:04:10,159
when switching between

117
00:04:06,640 --> 00:04:11,599
different contacts if you

118
00:04:10,159 --> 00:04:13,280
want to learn more you can go for

119
00:04:11,599 --> 00:04:15,040
example to intel website whereas the

120
00:04:13,280 --> 00:04:18,560
deep dive about it

121
00:04:15,040 --> 00:04:21,759
and the way how we mitigate it

122
00:04:18,560 --> 00:04:24,560
is pure and software so the cloud

123
00:04:21,759 --> 00:04:26,800
provider will likely fix the hypervisor

124
00:04:24,560 --> 00:04:29,040
and there is no like microcode or any

125
00:04:26,800 --> 00:04:30,320
other update required so

126
00:04:29,040 --> 00:04:32,639
there is nothing which needs to be

127
00:04:30,320 --> 00:04:33,520
passed through to your vm but you still

128
00:04:32,639 --> 00:04:36,320
need to

129
00:04:33,520 --> 00:04:36,960
uh have the mitigation because they

130
00:04:36,320 --> 00:04:40,080
happen on

131
00:04:36,960 --> 00:04:42,000
a case by case basis right so whenever

132
00:04:40,080 --> 00:04:43,599
there is a gadget in your kernel it

133
00:04:42,000 --> 00:04:45,759
needs to get fixed

134
00:04:43,600 --> 00:04:47,680
so you just need to keep your kernel

135
00:04:45,759 --> 00:04:48,720
updated basically and you are going to

136
00:04:47,680 --> 00:04:51,280
be fine

137
00:04:48,720 --> 00:04:52,720
with this particular attack there is a

138
00:04:51,280 --> 00:04:56,239
modification of it

139
00:04:52,720 --> 00:04:58,240
which is called like swap gs bigger but

140
00:04:56,240 --> 00:04:59,520
it's not the same but the same in a way

141
00:04:58,240 --> 00:05:02,160
that we get

142
00:04:59,520 --> 00:05:02,639
outside of the allowed range when we

143
00:05:02,160 --> 00:05:05,680
access

144
00:05:02,639 --> 00:05:08,400
data and uh

145
00:05:05,680 --> 00:05:10,800
again it's mitigated in software for the

146
00:05:08,400 --> 00:05:13,198
existing cpus which are vulnerable

147
00:05:10,800 --> 00:05:15,199
and there's going to be new cpus which

148
00:05:13,199 --> 00:05:16,240
won't have the vulnerability and you

149
00:05:15,199 --> 00:05:19,199
will have

150
00:05:16,240 --> 00:05:20,400
css flag in your vm which will make it a

151
00:05:19,199 --> 00:05:22,320
little bit faster but

152
00:05:20,400 --> 00:05:24,479
it's all mitigated in software just keep

153
00:05:22,320 --> 00:05:27,039
your kernel updated

154
00:05:24,479 --> 00:05:27,599
uh spectra v2 is an interesting one

155
00:05:27,039 --> 00:05:30,560
actually

156
00:05:27,600 --> 00:05:32,080
uh it's a vulnerability when we use a

157
00:05:30,560 --> 00:05:34,960
branch predictor

158
00:05:32,080 --> 00:05:35,520
and we train it in one context and then

159
00:05:34,960 --> 00:05:38,239
uh

160
00:05:35,520 --> 00:05:40,479
it's been like misused or it mispredicts

161
00:05:38,240 --> 00:05:42,880
targets in another context

162
00:05:40,479 --> 00:05:45,280
and to mitigate this particular

163
00:05:42,880 --> 00:05:49,759
vulnerability you actually need

164
00:05:45,280 --> 00:05:52,320
both like software and hardware features

165
00:05:49,759 --> 00:05:54,960
and hardware features i won't go through

166
00:05:52,320 --> 00:05:56,800
all of them but basically they either

167
00:05:54,960 --> 00:05:58,560
stop the speculation between uh

168
00:05:56,800 --> 00:06:01,759
different contexts like

169
00:05:58,560 --> 00:06:02,400
different uh privilege levels or they

170
00:06:01,759 --> 00:06:06,160
provide

171
00:06:02,400 --> 00:06:09,039
a barrier and in software we do

172
00:06:06,160 --> 00:06:09,600
a technique called reptalin invented by

173
00:06:09,039 --> 00:06:12,639
google

174
00:06:09,600 --> 00:06:16,080
and it's a clever way to uh prevent

175
00:06:12,639 --> 00:06:19,280
uh speculation purely in software

176
00:06:16,080 --> 00:06:21,599
so uh thinking about

177
00:06:19,280 --> 00:06:22,880
attacking like between vms and vms to

178
00:06:21,600 --> 00:06:25,520
hypervisors for

179
00:06:22,880 --> 00:06:27,360
uh attacks between vms it's not possible

180
00:06:25,520 --> 00:06:30,080
if you are not sharing cores

181
00:06:27,360 --> 00:06:31,680
and actually for almost all bigger

182
00:06:30,080 --> 00:06:34,318
instance types of of

183
00:06:31,680 --> 00:06:36,000
on cloud providers there is no core

184
00:06:34,319 --> 00:06:38,880
sharing there you get cores

185
00:06:36,000 --> 00:06:41,039
to your like exclusive usage you can

186
00:06:38,880 --> 00:06:43,199
still attack the hypervisor

187
00:06:41,039 --> 00:06:45,199
but your cloud provider will likely take

188
00:06:43,199 --> 00:06:46,479
care of it by utilizing one of these

189
00:06:45,199 --> 00:06:48,400
techniques either like

190
00:06:46,479 --> 00:06:49,758
rebuild this hypervisor research pauline

191
00:06:48,400 --> 00:06:52,318
or using this

192
00:06:49,759 --> 00:06:54,000
uh hardware features but what about the

193
00:06:52,319 --> 00:06:56,240
nvme attacks

194
00:06:54,000 --> 00:06:57,919
uh yeah i'm also showing uh how you can

195
00:06:56,240 --> 00:06:59,680
check what's going on inside your vm

196
00:06:57,919 --> 00:07:01,520
there is an interface in sys

197
00:06:59,680 --> 00:07:03,520
which colonel will tell you what's going

198
00:07:01,520 --> 00:07:06,719
on for all of them

199
00:07:03,520 --> 00:07:07,919
so uh for enhanced bearers is something

200
00:07:06,720 --> 00:07:11,199
which will be in

201
00:07:07,919 --> 00:07:12,960
i think cascade lake uh and uh

202
00:07:11,199 --> 00:07:14,560
then it will be to certain extent

203
00:07:12,960 --> 00:07:16,318
mitigated in hardware

204
00:07:14,560 --> 00:07:18,000
but to a certain extent mean that there

205
00:07:16,319 --> 00:07:19,520
is going to be no speculation between

206
00:07:18,000 --> 00:07:22,080
different privilege levels

207
00:07:19,520 --> 00:07:24,240
on the same privilege levels for example

208
00:07:22,080 --> 00:07:27,039
one user space attacking another one

209
00:07:24,240 --> 00:07:28,319
you still need a barrier and for that

210
00:07:27,039 --> 00:07:30,240
your cloud provider

211
00:07:28,319 --> 00:07:32,560
needs to provide you this hardware

212
00:07:30,240 --> 00:07:34,960
feature if it's not provided to you

213
00:07:32,560 --> 00:07:36,400
it's nothing you can do about it only i

214
00:07:34,960 --> 00:07:38,080
mean if there is user space which you

215
00:07:36,400 --> 00:07:38,560
can like rebuild with earthquakes or

216
00:07:38,080 --> 00:07:40,159
something

217
00:07:38,560 --> 00:07:42,080
then you can mitigate if you have some

218
00:07:40,160 --> 00:07:43,680
legacy workload there is basically

219
00:07:42,080 --> 00:07:46,800
nothing you can do

220
00:07:43,680 --> 00:07:49,680
there and also as

221
00:07:46,800 --> 00:07:51,440
it's like cross uh hyper threat so the

222
00:07:49,680 --> 00:07:54,560
branch predictor can be shared

223
00:07:51,440 --> 00:07:57,120
across cores it may happen that uh

224
00:07:54,560 --> 00:07:58,479
one thing happening on one thread is

225
00:07:57,120 --> 00:07:59,759
attacking another thing happening on

226
00:07:58,479 --> 00:08:01,919
another thread

227
00:07:59,759 --> 00:08:03,360
and for that there is no good protection

228
00:08:01,919 --> 00:08:06,878
you may actually

229
00:08:03,360 --> 00:08:08,400
want to go to uh disabling smt is it can

230
00:08:06,879 --> 00:08:10,879
actually be faster than some of the

231
00:08:08,400 --> 00:08:13,520
intel cpu features which are

232
00:08:10,879 --> 00:08:14,240
been designed to uh protect you against

233
00:08:13,520 --> 00:08:17,440
these

234
00:08:14,240 --> 00:08:20,639
vulnerabilities uh

235
00:08:17,440 --> 00:08:22,960
going forward um uh

236
00:08:20,639 --> 00:08:24,720
meltdown meltdown is an intel specific

237
00:08:22,960 --> 00:08:26,960
vulnerability uh

238
00:08:24,720 --> 00:08:26,960
which

239
00:08:27,919 --> 00:08:32,000
is about page tables when uh your page

240
00:08:30,319 --> 00:08:32,719
tables are shared between your user

241
00:08:32,000 --> 00:08:35,519
space

242
00:08:32,719 --> 00:08:37,039
and kernel and we are uh speculatively

243
00:08:35,519 --> 00:08:39,440
reading some memory which doesn't belong

244
00:08:37,039 --> 00:08:42,640
to user space

245
00:08:39,440 --> 00:08:45,680
uh we currently uh uh

246
00:08:42,640 --> 00:08:46,399
i mean again there is no uh hardware

247
00:08:45,680 --> 00:08:49,519
support

248
00:08:46,399 --> 00:08:52,720
required for mitigation uh

249
00:08:49,519 --> 00:08:54,880
for uh to mitigate between like vms and

250
00:08:52,720 --> 00:08:57,040
vms and hypervisors there is

251
00:08:54,880 --> 00:08:59,120
nothing needed because uh usually they

252
00:08:57,040 --> 00:09:01,360
don't share page tables it was only zen

253
00:08:59,120 --> 00:09:04,240
pv which was still using where were

254
00:09:01,360 --> 00:09:05,760
all the aws instances when they had to

255
00:09:04,240 --> 00:09:07,120
play some trick and they actually put

256
00:09:05,760 --> 00:09:10,560
zen pv in an

257
00:09:07,120 --> 00:09:14,480
hvm container to mitigate this initially

258
00:09:10,560 --> 00:09:16,560
uh inside uh vm uh you also need like an

259
00:09:14,480 --> 00:09:18,959
updated kernel but it's already like

260
00:09:16,560 --> 00:09:20,959
two years old right so everything after

261
00:09:18,959 --> 00:09:22,880
2018 should be protected the

262
00:09:20,959 --> 00:09:24,800
technique is called page tape table

263
00:09:22,880 --> 00:09:26,560
isolation so you have different page

264
00:09:24,800 --> 00:09:28,560
tables between user space

265
00:09:26,560 --> 00:09:30,399
and kernel and eventually when this is

266
00:09:28,560 --> 00:09:31,119
fixed in hardware you won't need it it

267
00:09:30,399 --> 00:09:33,920
will run

268
00:09:31,120 --> 00:09:33,920
slightly faster

269
00:09:34,160 --> 00:09:37,839
speculative store bypass uh an

270
00:09:36,160 --> 00:09:39,519
interesting one basically

271
00:09:37,839 --> 00:09:41,120
to mount the attack you are right into

272
00:09:39,519 --> 00:09:42,160
memory and reading from the same address

273
00:09:41,120 --> 00:09:44,800
from memory

274
00:09:42,160 --> 00:09:46,959
and in some cases your read can happen

275
00:09:44,800 --> 00:09:49,040
actually before your right finishes

276
00:09:46,959 --> 00:09:50,479
and usually it doesn't really matter

277
00:09:49,040 --> 00:09:52,480
because you have control over this

278
00:09:50,480 --> 00:09:53,279
memory but in some contexts it actually

279
00:09:52,480 --> 00:09:56,800
does

280
00:09:53,279 --> 00:09:58,640
so you are reading the scale value and

281
00:09:56,800 --> 00:10:00,319
to actually mitigate this vulnerability

282
00:09:58,640 --> 00:10:02,560
you need a hardware feature

283
00:10:00,320 --> 00:10:03,360
called speculative store bypass disable

284
00:10:02,560 --> 00:10:07,599
or

285
00:10:03,360 --> 00:10:10,240
word on amd there is a different one and

286
00:10:07,600 --> 00:10:12,240
again uh it doesn't seem that we are

287
00:10:10,240 --> 00:10:16,640
able to use this vulnerability to

288
00:10:12,240 --> 00:10:19,519
attack like other vms or the hypervisor

289
00:10:16,640 --> 00:10:20,160
and it seems that this environment which

290
00:10:19,519 --> 00:10:23,200
is

291
00:10:20,160 --> 00:10:24,480
at risk is the jitted environment where

292
00:10:23,200 --> 00:10:26,560
we can actually

293
00:10:24,480 --> 00:10:27,839
ride the speculative guards that we need

294
00:10:26,560 --> 00:10:31,680
because it provides us an

295
00:10:27,839 --> 00:10:34,320
easy way to you know do them and

296
00:10:31,680 --> 00:10:35,040
by default if you have this cpu feature

297
00:10:34,320 --> 00:10:37,760
in your

298
00:10:35,040 --> 00:10:38,480
vmware like on hardware after microcode

299
00:10:37,760 --> 00:10:42,399
update

300
00:10:38,480 --> 00:10:43,040
it's only enabled for uh prctl and

301
00:10:42,399 --> 00:10:45,680
second

302
00:10:43,040 --> 00:10:46,160
processes because it again slows you

303
00:10:45,680 --> 00:10:49,920
down

304
00:10:46,160 --> 00:10:51,680
right and uh mostly you need it

305
00:10:49,920 --> 00:10:55,439
if you are running an untrusted jitted

306
00:10:51,680 --> 00:10:59,599
code in your vm like java vs

307
00:10:55,440 --> 00:11:02,320
uh l1 terminal fault

308
00:10:59,600 --> 00:11:03,360
again uh related to page tables that

309
00:11:02,320 --> 00:11:05,920
when we

310
00:11:03,360 --> 00:11:07,839
there is a page table which is like not

311
00:11:05,920 --> 00:11:11,439
present for example or

312
00:11:07,839 --> 00:11:12,880
reserved then uh usually you don't have

313
00:11:11,440 --> 00:11:15,440
access there but

314
00:11:12,880 --> 00:11:16,399
speculatively your cpu can actually

315
00:11:15,440 --> 00:11:19,120
access to some

316
00:11:16,399 --> 00:11:20,720
memory location which is under the

317
00:11:19,120 --> 00:11:24,399
attacker's control

318
00:11:20,720 --> 00:11:24,959
and there is a feature again with which

319
00:11:24,399 --> 00:11:28,240
comes

320
00:11:24,959 --> 00:11:30,719
to you with microcode update but um

321
00:11:28,240 --> 00:11:32,079
basically you only need it if you are

322
00:11:30,720 --> 00:11:34,320
running

323
00:11:32,079 --> 00:11:35,920
your own hypervisor on bare metal

324
00:11:34,320 --> 00:11:37,600
because even if you are running

325
00:11:35,920 --> 00:11:39,920
like a nested hypervisor on public

326
00:11:37,600 --> 00:11:40,720
clouds and not many public clouds allow

327
00:11:39,920 --> 00:11:43,839
you to do that but

328
00:11:40,720 --> 00:11:45,600
for example azure does you

329
00:11:43,839 --> 00:11:47,279
don't really need it because they mo

330
00:11:45,600 --> 00:11:50,000
they most likely take care

331
00:11:47,279 --> 00:11:51,680
of this when switching between like vm

332
00:11:50,000 --> 00:11:54,880
and hypervisor

333
00:11:51,680 --> 00:11:57,760
in uh soft

334
00:11:54,880 --> 00:11:58,959
in on the hypervisor we use this feature

335
00:11:57,760 --> 00:12:00,639
uh

336
00:11:58,959 --> 00:12:02,719
there is an interesting implication of

337
00:12:00,639 --> 00:12:06,160
this one that uh

338
00:12:02,720 --> 00:12:09,440
l1 cache is actually shared again

339
00:12:06,160 --> 00:12:10,399
on it's actually the one l1 cache for

340
00:12:09,440 --> 00:12:13,360
the whole core

341
00:12:10,399 --> 00:12:15,279
so all hyper threads are using it and

342
00:12:13,360 --> 00:12:16,639
the question is like what for example

343
00:12:15,279 --> 00:12:18,880
happens when

344
00:12:16,639 --> 00:12:19,760
one of your hyper thread exits to the

345
00:12:18,880 --> 00:12:21,600
hypervisor

346
00:12:19,760 --> 00:12:22,880
and the other still has like user space

347
00:12:21,600 --> 00:12:25,040
task running right

348
00:12:22,880 --> 00:12:26,240
so there were some techniques suggested

349
00:12:25,040 --> 00:12:28,160
like kick it

350
00:12:26,240 --> 00:12:29,839
out of the execution to the hypervisor

351
00:12:28,160 --> 00:12:33,279
to block the cpu

352
00:12:29,839 --> 00:12:34,000
so um we don't know for sure to which

353
00:12:33,279 --> 00:12:36,560
extent this

354
00:12:34,000 --> 00:12:38,399
techniques are being used on hypervisors

355
00:12:36,560 --> 00:12:41,518
and cloud providers

356
00:12:38,399 --> 00:12:44,160
hopefully they do something we cannot

357
00:12:41,519 --> 00:12:44,160
really check

358
00:12:44,320 --> 00:12:48,560
but again

359
00:12:48,880 --> 00:12:53,200
to mitigate against the attack inside

360
00:12:52,160 --> 00:12:56,079
the vm

361
00:12:53,200 --> 00:12:57,920
we use a software-based technique which

362
00:12:56,079 --> 00:12:59,120
is called pt inversion we basically

363
00:12:57,920 --> 00:13:02,399
write some

364
00:12:59,120 --> 00:13:03,200
adders which cannot be normally used to

365
00:13:02,399 --> 00:13:06,240
access

366
00:13:03,200 --> 00:13:10,000
any data to pts which are not

367
00:13:06,240 --> 00:13:13,200
uh which are not present or reserved

368
00:13:10,000 --> 00:13:15,120
and uh again this l one

369
00:13:13,200 --> 00:13:17,200
there is a parameter to a kernel which

370
00:13:15,120 --> 00:13:18,720
you can switch the mitigation but you

371
00:13:17,200 --> 00:13:20,320
don't really need it unless you're

372
00:13:18,720 --> 00:13:23,600
running like bare metal

373
00:13:20,320 --> 00:13:25,200
uh hypervisor and better metal uh the

374
00:13:23,600 --> 00:13:26,639
pt inversion the software-based

375
00:13:25,200 --> 00:13:28,000
technique which comes to you with an

376
00:13:26,639 --> 00:13:32,320
updated kernel is like

377
00:13:28,000 --> 00:13:35,120
good enough uh mds

378
00:13:32,320 --> 00:13:36,240
interesting one uh there are some

379
00:13:35,120 --> 00:13:38,800
smaller

380
00:13:36,240 --> 00:13:41,680
structures in the cpu which you don't

381
00:13:38,800 --> 00:13:45,040
cannot access with any instructions but

382
00:13:41,680 --> 00:13:46,000
uh after doing some execution in the cpu

383
00:13:45,040 --> 00:13:48,800
there can be some

384
00:13:46,000 --> 00:13:50,240
leftovers in the structures and with

385
00:13:48,800 --> 00:13:53,839
some techniques

386
00:13:50,240 --> 00:13:56,160
there are like many of them and new

387
00:13:53,839 --> 00:13:57,199
types of attacks are being discovered in

388
00:13:56,160 --> 00:14:00,160
this space

389
00:13:57,199 --> 00:14:01,920
uh you can actually get some like bits

390
00:14:00,160 --> 00:14:04,880
from there

391
00:14:01,920 --> 00:14:05,760
it's not that you're getting like access

392
00:14:04,880 --> 00:14:09,839
to

393
00:14:05,760 --> 00:14:12,079
uh some you know full user pages

394
00:14:09,839 --> 00:14:14,079
or anything because these uh structures

395
00:14:12,079 --> 00:14:15,839
are really really really small

396
00:14:14,079 --> 00:14:17,760
but you can still get some bits for

397
00:14:15,839 --> 00:14:20,000
example and if there is like

398
00:14:17,760 --> 00:14:22,160
uh some interesting like security

399
00:14:20,000 --> 00:14:22,959
related computation has been done on

400
00:14:22,160 --> 00:14:26,800
another

401
00:14:22,959 --> 00:14:32,079
uh hyper thread it's kind of risky

402
00:14:26,800 --> 00:14:36,160
and again new cpus are supposed to get

403
00:14:32,079 --> 00:14:37,040
fixed and you cannot attack another core

404
00:14:36,160 --> 00:14:40,560
or another

405
00:14:37,040 --> 00:14:40,959
vm and but you can attack the hypervisor

406
00:14:40,560 --> 00:14:43,760
when

407
00:14:40,959 --> 00:14:45,920
an exit has been done there so your

408
00:14:43,760 --> 00:14:47,839
cloud provider most likely will

409
00:14:45,920 --> 00:14:49,920
take care of it by updating the hyper

410
00:14:47,839 --> 00:14:51,839
code and using and clearing all these

411
00:14:49,920 --> 00:14:53,680
buffers when it switches to your vm and

412
00:14:51,839 --> 00:14:57,199
back

413
00:14:53,680 --> 00:14:57,760
again the same thing as with l1 terminal

414
00:14:57,199 --> 00:15:01,599
fault

415
00:14:57,760 --> 00:15:04,560
is that when one

416
00:15:01,600 --> 00:15:06,000
hyper thread exits to the hypervisor

417
00:15:04,560 --> 00:15:06,560
what happens on the other one right

418
00:15:06,000 --> 00:15:08,560
because

419
00:15:06,560 --> 00:15:10,560
they can they are sharing this structure

420
00:15:08,560 --> 00:15:14,160
the hyper threats are not

421
00:15:10,560 --> 00:15:17,599
real course right and uh

422
00:15:14,160 --> 00:15:18,560
again uh like curve scheduling uh was

423
00:15:17,600 --> 00:15:21,839
suggested that

424
00:15:18,560 --> 00:15:23,518
uh only one vm belonging to only one

425
00:15:21,839 --> 00:15:24,480
tenant has been scheduled on the core at

426
00:15:23,519 --> 00:15:27,440
the same time

427
00:15:24,480 --> 00:15:28,000
and if it exits to for example interrupt

428
00:15:27,440 --> 00:15:31,199
then

429
00:15:28,000 --> 00:15:33,040
we may want to block another core cloud

430
00:15:31,199 --> 00:15:35,920
providers most likely

431
00:15:33,040 --> 00:15:36,240
do something about this so the question

432
00:15:35,920 --> 00:15:41,680
is

433
00:15:36,240 --> 00:15:43,920
um what do you do in uh

434
00:15:41,680 --> 00:15:44,959
software on your vm and i'm actually

435
00:15:43,920 --> 00:15:48,959
grouping this like

436
00:15:44,959 --> 00:15:52,000
uh transaction as the t6sync abort here

437
00:15:48,959 --> 00:15:53,758
because basically it's another way

438
00:15:52,000 --> 00:15:55,279
to mount the attack but you're attacking

439
00:15:53,759 --> 00:15:58,320
the same uh

440
00:15:55,279 --> 00:16:01,040
structures and

441
00:15:58,320 --> 00:16:02,800
it was uh mitigated in a weird way by

442
00:16:01,040 --> 00:16:05,040
intel at least

443
00:16:02,800 --> 00:16:06,240
that an existing instruction was

444
00:16:05,040 --> 00:16:09,599
repurposed to

445
00:16:06,240 --> 00:16:10,639
clean the buffers so or there is a

446
00:16:09,600 --> 00:16:12,560
feature flag

447
00:16:10,639 --> 00:16:13,920
called mdclear you can see it in your

448
00:16:12,560 --> 00:16:16,160
like cpu flags

449
00:16:13,920 --> 00:16:18,160
if it's present there or not it will

450
00:16:16,160 --> 00:16:20,880
tell you when it's present you know

451
00:16:18,160 --> 00:16:22,000
that buffers are being cleaned when the

452
00:16:20,880 --> 00:16:25,199
instructions executed

453
00:16:22,000 --> 00:16:27,680
and your kernel actually does that

454
00:16:25,199 --> 00:16:30,000
but if it's not present you cannot

455
00:16:27,680 --> 00:16:31,839
really tell for sure because it may

456
00:16:30,000 --> 00:16:33,759
be the case that your cloud provider

457
00:16:31,839 --> 00:16:37,279
actually updated microcode

458
00:16:33,759 --> 00:16:37,839
but just didn't expose this uh feature

459
00:16:37,279 --> 00:16:39,519
to you

460
00:16:37,839 --> 00:16:41,519
and you can still use the mitigation by

461
00:16:39,519 --> 00:16:43,759
issuing the instruction on the cpu

462
00:16:41,519 --> 00:16:45,600
and that's what actually what linux does

463
00:16:43,759 --> 00:16:47,759
uh it still tries

464
00:16:45,600 --> 00:16:49,839
it tells you like well the state is

465
00:16:47,759 --> 00:16:52,639
unknown yeah but i will still try to

466
00:16:49,839 --> 00:16:56,639
issue the instruction just in case

467
00:16:52,639 --> 00:16:59,839
uh it prevents like uh

468
00:16:56,639 --> 00:17:00,399
user space against like kernel attacks

469
00:16:59,839 --> 00:17:03,279
but

470
00:17:00,399 --> 00:17:04,000
if again if you are having two user

471
00:17:03,279 --> 00:17:05,760
space tasks

472
00:17:04,000 --> 00:17:08,000
of like different tenants running on the

473
00:17:05,760 --> 00:17:10,240
same core different hyper threads

474
00:17:08,000 --> 00:17:11,439
at the same time you are still very

475
00:17:10,240 --> 00:17:13,439
vulnerable because

476
00:17:11,439 --> 00:17:15,199
there is no good place to you know put

477
00:17:13,439 --> 00:17:16,559
the flush right so you cannot flush

478
00:17:15,199 --> 00:17:18,079
after every instruction

479
00:17:16,559 --> 00:17:19,760
you can only flash for example when you

480
00:17:18,079 --> 00:17:20,159
enter kernel and leave kernel but if

481
00:17:19,760 --> 00:17:23,439
they're

482
00:17:20,160 --> 00:17:26,480
running simultaneously it can still

483
00:17:23,439 --> 00:17:29,200
gain some data from another

484
00:17:26,480 --> 00:17:30,880
thread and in that case if you are

485
00:17:29,200 --> 00:17:31,600
really worried about such types of

486
00:17:30,880 --> 00:17:34,240
attacks

487
00:17:31,600 --> 00:17:34,719
you can either like isolate your course

488
00:17:34,240 --> 00:17:37,840
and put

489
00:17:34,720 --> 00:17:38,480
tasks like manually pin your tasks to

490
00:17:37,840 --> 00:17:40,879
different

491
00:17:38,480 --> 00:17:42,799
physical cores assuming that you

492
00:17:40,880 --> 00:17:43,520
actually trust your cloud provider to

493
00:17:42,799 --> 00:17:45,760
give you

494
00:17:43,520 --> 00:17:47,120
genuine smt topology which they actually

495
00:17:45,760 --> 00:17:49,600
do because it's

496
00:17:47,120 --> 00:17:51,918
like in their interest to expose you

497
00:17:49,600 --> 00:17:54,879
know trustworthy topology to you

498
00:17:51,919 --> 00:17:55,280
or you can just disable smt completely

499
00:17:54,880 --> 00:18:00,320
and

500
00:17:55,280 --> 00:18:04,480
uh it depends right to which extent you

501
00:18:00,320 --> 00:18:07,678
care about such attacks

502
00:18:04,480 --> 00:18:09,600
just for the sake of completeness

503
00:18:07,679 --> 00:18:11,120
there was some other vulnerability

504
00:18:09,600 --> 00:18:14,480
discovered

505
00:18:11,120 --> 00:18:16,799
early in the fall of 19 yeah

506
00:18:14,480 --> 00:18:18,799
like several months ago and called like

507
00:18:16,799 --> 00:18:21,039
it'll be multi-hit and uh

508
00:18:18,799 --> 00:18:22,080
it's not a speculative execution uh

509
00:18:21,039 --> 00:18:24,480
attack it's uh

510
00:18:22,080 --> 00:18:26,840
actually a way to mount a dos attack on

511
00:18:24,480 --> 00:18:29,840
your physical cpu when you

512
00:18:26,840 --> 00:18:32,959
create uh two

513
00:18:29,840 --> 00:18:35,120
different page size structures and don't

514
00:18:32,960 --> 00:18:37,520
flush your tlb buffer in between

515
00:18:35,120 --> 00:18:39,600
your cpu may actually encounter an error

516
00:18:37,520 --> 00:18:42,960
just stop like physical cpu

517
00:18:39,600 --> 00:18:45,039
but for sure your cloud provider

518
00:18:42,960 --> 00:18:46,400
took care of this one you can actually

519
00:18:45,039 --> 00:18:49,039
try right execute

520
00:18:46,400 --> 00:18:49,760
you know the exploit and your cloud

521
00:18:49,039 --> 00:18:52,320
provider

522
00:18:49,760 --> 00:18:52,960
either took care of it or he won't let

523
00:18:52,320 --> 00:18:58,080
you do

524
00:18:52,960 --> 00:19:01,440
anything ever again but up to you

525
00:18:58,080 --> 00:19:03,600
so um no

526
00:19:01,440 --> 00:19:05,039
it's been mitigated in software on if

527
00:19:03,600 --> 00:19:06,559
you are interested how it's been done on

528
00:19:05,039 --> 00:19:09,360
the hypervisor

529
00:19:06,559 --> 00:19:11,200
so we are either forbidding different

530
00:19:09,360 --> 00:19:13,678
pages page sizes or like

531
00:19:11,200 --> 00:19:15,840
mounting just mapping them as like

532
00:19:13,679 --> 00:19:16,960
non-executable pages so whenever an

533
00:19:15,840 --> 00:19:18,559
execution happens

534
00:19:16,960 --> 00:19:20,320
we actually like split them that's what

535
00:19:18,559 --> 00:19:24,080
we for example do in

536
00:19:20,320 --> 00:19:26,080
uh kvm so uh

537
00:19:24,080 --> 00:19:28,080
now i just wanted to show you some uh

538
00:19:26,080 --> 00:19:30,080
examples of some like existing

539
00:19:28,080 --> 00:19:31,840
instance types on on different cloud

540
00:19:30,080 --> 00:19:34,879
providers

541
00:19:31,840 --> 00:19:38,080
uh and let's start with

542
00:19:34,880 --> 00:19:40,640
aws so here is like

543
00:19:38,080 --> 00:19:41,360
r5 and large instance and if you go to

544
00:19:40,640 --> 00:19:44,320
like

545
00:19:41,360 --> 00:19:45,918
this this interface and see what's

546
00:19:44,320 --> 00:19:46,720
happening you will see something like

547
00:19:45,919 --> 00:19:50,240
that

548
00:19:46,720 --> 00:19:52,880
how do you read it so the first one

549
00:19:50,240 --> 00:19:53,280
is kind of irrelevant because there is

550
00:19:52,880 --> 00:19:55,360
no

551
00:19:53,280 --> 00:19:56,480
vmx exposed to you so you don't really

552
00:19:55,360 --> 00:19:59,360
care about itlb

553
00:19:56,480 --> 00:20:01,280
this uh different page sizes the

554
00:19:59,360 --> 00:20:04,959
hypervisor takes care of it and

555
00:20:01,280 --> 00:20:06,720
it's just irrelevant to you l1tf

556
00:20:04,960 --> 00:20:08,080
as i told you has been mitigated in

557
00:20:06,720 --> 00:20:11,120
software with dpt

558
00:20:08,080 --> 00:20:14,240
inversion so you can see it here

559
00:20:11,120 --> 00:20:15,918
mds the feature wasn't exposed to us we

560
00:20:14,240 --> 00:20:19,440
don't see mdclear

561
00:20:15,919 --> 00:20:23,039
so we still try to do uh

562
00:20:19,440 --> 00:20:26,720
the buffer flashing but we're not sure

563
00:20:23,039 --> 00:20:29,600
most likely it is mitigated uh

564
00:20:26,720 --> 00:20:31,919
meltdown again software-based mitigation

565
00:20:29,600 --> 00:20:35,360
base stable isolation

566
00:20:31,919 --> 00:20:36,320
very likely secure uh speculative store

567
00:20:35,360 --> 00:20:38,320
bypass

568
00:20:36,320 --> 00:20:40,320
we don't get the feature didn't get the

569
00:20:38,320 --> 00:20:43,039
feature so it's nothing we can do

570
00:20:40,320 --> 00:20:44,879
so in case we are running this untrusted

571
00:20:43,039 --> 00:20:47,440
jitted code then we may

572
00:20:44,880 --> 00:20:49,280
be in trouble again you can try to

573
00:20:47,440 --> 00:20:51,760
mitigate by putting it like

574
00:20:49,280 --> 00:20:52,960
on different cores because it's an

575
00:20:51,760 --> 00:20:56,799
attack against uh

576
00:20:52,960 --> 00:20:59,919
level one uh cache

577
00:20:56,799 --> 00:21:01,840
uh spectral one uh

578
00:20:59,919 --> 00:21:04,000
again software-based mitigation in the

579
00:21:01,840 --> 00:21:07,439
kernel very good

580
00:21:04,000 --> 00:21:11,200
spectre v2 not really uh we didn't get

581
00:21:07,440 --> 00:21:14,400
this uh stabp and ibpb features

582
00:21:11,200 --> 00:21:16,320
so uh if we care about one user space

583
00:21:14,400 --> 00:21:17,760
attacking another user space you cannot

584
00:21:16,320 --> 00:21:18,639
attack your kernel because it's user at

585
00:21:17,760 --> 00:21:20,480
palin's

586
00:21:18,640 --> 00:21:22,080
but you can attack user space which

587
00:21:20,480 --> 00:21:23,440
doesn't use red balloons from another

588
00:21:22,080 --> 00:21:27,280
user space

589
00:21:23,440 --> 00:21:29,760
then again what you can do is you can

590
00:21:27,280 --> 00:21:30,879
pin them to different cores or you can

591
00:21:29,760 --> 00:21:33,679
just avoid running

592
00:21:30,880 --> 00:21:34,960
this like multi-tenant and secure

593
00:21:33,679 --> 00:21:38,720
workloads in one

594
00:21:34,960 --> 00:21:40,559
instance there is no hardware features

595
00:21:38,720 --> 00:21:43,679
provided to you

596
00:21:40,559 --> 00:21:46,399
azure f8s v2

597
00:21:43,679 --> 00:21:47,120
i just i was just picking some random uh

598
00:21:46,400 --> 00:21:52,080
instances

599
00:21:47,120 --> 00:21:52,080
these two are things skylakes so

600
00:21:52,240 --> 00:21:55,440
no particular thought was put into

601
00:21:54,480 --> 00:21:57,520
picking one of

602
00:21:55,440 --> 00:21:59,760
another instance type and i cannot show

603
00:21:57,520 --> 00:22:02,879
you all of them there are way too many

604
00:21:59,760 --> 00:22:05,840
but uh it's very very

605
00:22:02,880 --> 00:22:06,960
close to what i just showed you were aws

606
00:22:05,840 --> 00:22:09,840
the only difference

607
00:22:06,960 --> 00:22:11,440
is that they actually expose vmax

608
00:22:09,840 --> 00:22:14,158
capabilities to you

609
00:22:11,440 --> 00:22:15,520
so you can actually run nested

610
00:22:14,159 --> 00:22:16,640
hypervisors there

611
00:22:15,520 --> 00:22:19,120
though you don't need all these

612
00:22:16,640 --> 00:22:20,559
mitigations which you can still use but

613
00:22:19,120 --> 00:22:23,120
we have no

614
00:22:20,559 --> 00:22:25,039
smart logic for example in kernel to not

615
00:22:23,120 --> 00:22:28,080
use them when we are running

616
00:22:25,039 --> 00:22:30,400
nested and again the same story

617
00:22:28,080 --> 00:22:32,080
uh those which are mitigated in software

618
00:22:30,400 --> 00:22:33,600
are mitigated because i'm running a

619
00:22:32,080 --> 00:22:36,320
recent enough kernel it was

620
00:22:33,600 --> 00:22:38,158
five five rc samsung kernel like a

621
00:22:36,320 --> 00:22:41,439
couple of weeks ago

622
00:22:38,159 --> 00:22:44,480
and uh for mds and

623
00:22:41,440 --> 00:22:46,480
uh taa we don't know the flag wasn't

624
00:22:44,480 --> 00:22:50,080
exposed to us we still try

625
00:22:46,480 --> 00:22:53,280
with this instruction uh for spectre v2

626
00:22:50,080 --> 00:22:54,000
it's the same story that no hardware

627
00:22:53,280 --> 00:22:57,039
features

628
00:22:54,000 --> 00:22:59,120
so we cannot share different user space

629
00:22:57,039 --> 00:23:02,400
tasks which don't trust each other

630
00:22:59,120 --> 00:23:03,199
on the same core the last one i want to

631
00:23:02,400 --> 00:23:06,799
show you is

632
00:23:03,200 --> 00:23:10,480
from google cloud engine and

633
00:23:06,799 --> 00:23:13,760
it's a cascade lake so or like a newer

634
00:23:10,480 --> 00:23:15,440
cpu and there are some noticeable

635
00:23:13,760 --> 00:23:19,120
differences here

636
00:23:15,440 --> 00:23:22,720
for example uh for uh ssbd

637
00:23:19,120 --> 00:23:23,439
and spectre v2 features were exposed to

638
00:23:22,720 --> 00:23:26,720
us

639
00:23:23,440 --> 00:23:29,840
so our kernel actually is using them

640
00:23:26,720 --> 00:23:33,039
and this actually

641
00:23:29,840 --> 00:23:33,918
is the reason why the cloud providers

642
00:23:33,039 --> 00:23:36,158
may not

643
00:23:33,919 --> 00:23:37,280
want to expose these features because as

644
00:23:36,159 --> 00:23:39,360
soon as they do

645
00:23:37,280 --> 00:23:40,320
your kernel will automatically start

646
00:23:39,360 --> 00:23:42,399
using them oh

647
00:23:40,320 --> 00:23:43,760
i have features for hardware mitigation

648
00:23:42,400 --> 00:23:47,039
i need to use them

649
00:23:43,760 --> 00:23:47,600
and this kills the performance so there

650
00:23:47,039 --> 00:23:50,960
are some

651
00:23:47,600 --> 00:23:52,719
legacy performance which and it's not

652
00:23:50,960 --> 00:23:54,799
like a couple percent it can be like you

653
00:23:52,720 --> 00:23:57,120
know like fifty percent or sixty percent

654
00:23:54,799 --> 00:23:58,960
performance hit depending on what you do

655
00:23:57,120 --> 00:24:02,080
but uh for example

656
00:23:58,960 --> 00:24:05,200
like st ibp which was like mentioned on

657
00:24:02,080 --> 00:24:06,799
here which is like disabled it's not the

658
00:24:05,200 --> 00:24:08,320
great way how these features are

659
00:24:06,799 --> 00:24:09,200
presented here i was actually sending an

660
00:24:08,320 --> 00:24:12,960
rfc

661
00:24:09,200 --> 00:24:14,640
to uh print st ibp like not available

662
00:24:12,960 --> 00:24:15,840
that you don't have support and hardware

663
00:24:14,640 --> 00:24:17,919
because here it says

664
00:24:15,840 --> 00:24:19,199
it's disabled you don't know if it's

665
00:24:17,919 --> 00:24:21,840
disabled by

666
00:24:19,200 --> 00:24:24,320
the kernel by you or there is no

667
00:24:21,840 --> 00:24:27,600
hardware support for that

668
00:24:24,320 --> 00:24:29,520
so here it's like a newer cpu so norwich

669
00:24:27,600 --> 00:24:32,559
balance needed so you can see

670
00:24:29,520 --> 00:24:35,360
that enhanced ibrs has been used instead

671
00:24:32,559 --> 00:24:36,240
and but they actually passed through all

672
00:24:35,360 --> 00:24:38,399
these features

673
00:24:36,240 --> 00:24:40,320
they don't probably care that much about

674
00:24:38,400 --> 00:24:40,720
the performance of legacy workloads but

675
00:24:40,320 --> 00:24:44,158
they

676
00:24:40,720 --> 00:24:47,760
do care more about giving you like

677
00:24:44,159 --> 00:24:50,880
all those features to do mitigations

678
00:24:47,760 --> 00:24:53,360
and uh that's it from me uh

679
00:24:50,880 --> 00:24:54,320
yeah uh we don't really have time for

680
00:24:53,360 --> 00:24:57,039
questions as i

681
00:24:54,320 --> 00:24:58,480
predicted but i already answered some

682
00:24:57,039 --> 00:25:00,400
before my talk so

683
00:24:58,480 --> 00:25:02,799
uh if you have any questions just catch

684
00:25:00,400 --> 00:25:14,880
me somewhere in the corridor and i'll be

685
00:25:02,799 --> 00:25:14,879
happy to chat so thank you

