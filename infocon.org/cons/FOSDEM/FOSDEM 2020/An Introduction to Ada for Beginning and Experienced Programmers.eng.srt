1
00:00:05,200 --> 00:00:09,760
my next duty

2
00:00:06,399 --> 00:00:12,960
is to introduce the next speaker

3
00:00:09,760 --> 00:00:16,720
jean-pierre rosen that's myself hello

4
00:00:12,960 --> 00:00:20,160
and i'm going to

5
00:00:16,720 --> 00:00:22,240
give you a general overview of the ada

6
00:00:20,160 --> 00:00:24,800
language for those who never heard about

7
00:00:22,240 --> 00:00:24,799
it before

8
00:00:25,920 --> 00:00:31,199
so unless you have any questions about

9
00:00:28,720 --> 00:00:34,640
the organization

10
00:00:31,199 --> 00:00:36,000
okay that's fine everybody's got a

11
00:00:34,640 --> 00:00:40,079
raffle ticket

12
00:00:36,000 --> 00:00:40,079
yeah okay

13
00:00:41,600 --> 00:00:45,840
there it is

14
00:00:57,600 --> 00:00:59,840
okay

15
00:01:02,559 --> 00:01:07,759
let's go before i start i'm working for

16
00:01:05,600 --> 00:01:12,080
a company called edalog

17
00:01:07,760 --> 00:01:14,880
i have wrote some flyers too and so

18
00:01:12,080 --> 00:01:19,280
that's a company doing

19
00:01:14,880 --> 00:01:22,240
training consultancy and etc about ada

20
00:01:19,280 --> 00:01:22,880
so you may think oh that guy is telling

21
00:01:22,240 --> 00:01:26,000
us

22
00:01:22,880 --> 00:01:29,199
how nice it is because that's his

23
00:01:26,000 --> 00:01:30,079
business okay no in fact it's the other

24
00:01:29,200 --> 00:01:33,439
way around

25
00:01:30,079 --> 00:01:35,039
in a previous life i was a teacher in an

26
00:01:33,439 --> 00:01:38,240
engineering school

27
00:01:35,040 --> 00:01:40,400
and i was a mother responsible for

28
00:01:38,240 --> 00:01:42,079
the teaching of programming languages

29
00:01:40,400 --> 00:01:44,479
and compilers

30
00:01:42,079 --> 00:01:46,000
and it's because i thought that ada was

31
00:01:44,479 --> 00:01:49,200
a very nice language

32
00:01:46,000 --> 00:01:51,759
that i made my business with ada okay

33
00:01:49,200 --> 00:01:53,759
so it's not because it's my business

34
00:01:51,759 --> 00:01:56,320
it's the other way around

35
00:01:53,759 --> 00:01:56,870
so when talking about ada you hear

36
00:01:56,320 --> 00:01:58,960
certain

37
00:01:56,870 --> 00:02:02,000
[Music]

38
00:01:58,960 --> 00:02:05,360
dates and numbers

39
00:02:02,000 --> 00:02:07,040
ada is not an acronym the name of ada

40
00:02:05,360 --> 00:02:10,639
byron

41
00:02:07,040 --> 00:02:14,000
contest of lovelace and she was

42
00:02:10,639 --> 00:02:16,559
she's famous for being the first

43
00:02:14,000 --> 00:02:18,000
programmer in history she worked on

44
00:02:16,560 --> 00:02:22,560
babbage machine

45
00:02:18,000 --> 00:02:26,080
if you heard about that and um

46
00:02:22,560 --> 00:02:28,400
so she she could never run

47
00:02:26,080 --> 00:02:29,280
her programs because the machine never

48
00:02:28,400 --> 00:02:33,120
worked

49
00:02:29,280 --> 00:02:36,239
however they were later recorded in

50
00:02:33,120 --> 00:02:40,239
pier one i think and worked right

51
00:02:36,239 --> 00:02:42,800
out of the box so the first program had

52
00:02:40,239 --> 00:02:43,680
no bugs and the first programmer was a

53
00:02:42,800 --> 00:02:50,720
lady

54
00:02:43,680 --> 00:02:55,920
we've changed that since

55
00:02:50,720 --> 00:03:00,720
oops so come on

56
00:02:55,920 --> 00:03:04,958
the first version was in 1983.

57
00:03:00,720 --> 00:03:08,080
don't tell me it's very old it's much

58
00:03:04,959 --> 00:03:10,959
it's much more modern than c

59
00:03:08,080 --> 00:03:11,440
and it's approximately the same time

60
00:03:10,959 --> 00:03:14,800
that c

61
00:03:11,440 --> 00:03:18,000
plus plus appeared so it's not

62
00:03:14,800 --> 00:03:22,319
older than a must use

63
00:03:18,000 --> 00:03:24,840
programming languages to nowadays

64
00:03:22,319 --> 00:03:26,000
at that time is quite it was quite

65
00:03:24,840 --> 00:03:30,480
revolutionary

66
00:03:26,000 --> 00:03:33,840
by already having in a well designed

67
00:03:30,480 --> 00:03:36,079
set exception generics tasking

68
00:03:33,840 --> 00:03:36,879
and many features that you could not

69
00:03:36,080 --> 00:03:40,239
find

70
00:03:36,879 --> 00:03:40,239
in the same language

71
00:03:40,480 --> 00:03:43,760
at that time there was

72
00:03:44,159 --> 00:03:51,519
my mouse is jumping um

73
00:03:48,799 --> 00:03:51,519
and i think

74
00:03:53,760 --> 00:04:01,599
yeah 1995

75
00:03:58,319 --> 00:04:05,040
was a major rework

76
00:04:01,599 --> 00:04:08,000
introduced object-oriented programming

77
00:04:05,040 --> 00:04:10,959
a kind of mechanism a synchronization

78
00:04:08,000 --> 00:04:14,319
mechanism called protected objects

79
00:04:10,959 --> 00:04:17,759
and a way of organizing

80
00:04:14,319 --> 00:04:20,880
the various modules of your design into

81
00:04:17,759 --> 00:04:22,560
a hierarchy called hierarchical

82
00:04:20,880 --> 00:04:26,320
libraries

83
00:04:22,560 --> 00:04:28,560
by the way it was the first language

84
00:04:26,320 --> 00:04:29,680
that was object it was the first

85
00:04:28,560 --> 00:04:32,800
object-oriented

86
00:04:29,680 --> 00:04:35,440
language to be standardized at least at

87
00:04:32,800 --> 00:04:39,360
an international level as an iso

88
00:04:35,440 --> 00:04:43,840
language that was about three years

89
00:04:39,360 --> 00:04:43,840
before c plus

90
00:04:46,479 --> 00:04:52,479
205 brought some improvement

91
00:04:49,680 --> 00:04:53,199
from other languages especially the

92
00:04:52,479 --> 00:04:56,479
notion of

93
00:04:53,199 --> 00:05:01,199
interfaces that work mostly like java

94
00:04:56,479 --> 00:05:04,639
interfaces and also some

95
00:05:01,199 --> 00:05:07,840
more and more libraries and

96
00:05:04,639 --> 00:05:09,919
services that are that are

97
00:05:07,840 --> 00:05:11,919
added to the language in the form of

98
00:05:09,919 --> 00:05:15,520
extra libraries

99
00:05:11,919 --> 00:05:20,159
and in 2012 which is

100
00:05:15,520 --> 00:05:23,599
the latest revision to date

101
00:05:20,160 --> 00:05:25,680
eda was has been going more formal with

102
00:05:23,600 --> 00:05:27,600
contracts preconditions

103
00:05:25,680 --> 00:05:29,759
post-condition what is called

104
00:05:27,600 --> 00:05:32,639
programming by contract

105
00:05:29,759 --> 00:05:33,520
so it's moving to be more and more

106
00:05:32,639 --> 00:05:36,800
formal

107
00:05:33,520 --> 00:05:39,359
and more and more not exactly provable

108
00:05:36,800 --> 00:05:42,080
but checkable a trend time for various

109
00:05:39,360 --> 00:05:42,080
conditions

110
00:05:44,479 --> 00:05:50,639
so especially here

111
00:05:47,600 --> 00:05:52,720
it's my pleasure to say that eda is a

112
00:05:50,639 --> 00:05:56,000
free language it does not

113
00:05:52,720 --> 00:06:00,800
belong to any big industry

114
00:05:56,000 --> 00:06:03,280
or any major brand

115
00:06:00,800 --> 00:06:04,800
it is first of all an international

116
00:06:03,280 --> 00:06:07,679
standard

117
00:06:04,800 --> 00:06:08,800
and it's entirely controlled by its

118
00:06:07,680 --> 00:06:12,000
users

119
00:06:08,800 --> 00:06:15,759
the the evolution of the language

120
00:06:12,000 --> 00:06:19,280
is made by a group from iso

121
00:06:15,759 --> 00:06:19,600
and those belong to various companies

122
00:06:19,280 --> 00:06:23,758
and

123
00:06:19,600 --> 00:06:23,759
all work to improve the language

124
00:06:23,919 --> 00:06:31,758
you have three compilers

125
00:06:28,000 --> 00:06:35,120
well gcc has an ada

126
00:06:31,759 --> 00:06:36,560
version you know gcc is all languages

127
00:06:35,120 --> 00:06:40,160
compilers so

128
00:06:36,560 --> 00:06:42,319
what we call math is actually the eda

129
00:06:40,160 --> 00:06:45,840
front end to gcc

130
00:06:42,319 --> 00:06:49,199
and it's like all of the cc distributed

131
00:06:45,840 --> 00:06:51,919
as free software you also have

132
00:06:49,199 --> 00:06:52,319
proprietary compilers that's normal

133
00:06:51,919 --> 00:06:56,240
that's

134
00:06:52,319 --> 00:07:00,400
a world of business many free resources

135
00:06:56,240 --> 00:07:02,800
are available and you have a dynamic

136
00:07:00,400 --> 00:07:07,599
community so you have youth group

137
00:07:02,800 --> 00:07:10,479
and groups on all the usual

138
00:07:07,599 --> 00:07:10,479
social media

139
00:07:12,800 --> 00:07:20,880
so you may think that you don't see

140
00:07:16,479 --> 00:07:21,520
much ada that's true but that's because

141
00:07:20,880 --> 00:07:25,199
the people

142
00:07:21,520 --> 00:07:28,799
who use ada are not generally

143
00:07:25,199 --> 00:07:32,160
those that you see everywhere i mean

144
00:07:28,800 --> 00:07:35,280
if you take the tiob index for example

145
00:07:32,160 --> 00:07:38,720
you'll see eda completely down

146
00:07:35,280 --> 00:07:39,758
in the ranking why because the tiob

147
00:07:38,720 --> 00:07:42,800
index

148
00:07:39,759 --> 00:07:44,720
is based on the number of software on

149
00:07:42,800 --> 00:07:47,120
bit github

150
00:07:44,720 --> 00:07:49,039
and the popularity in the social

151
00:07:47,120 --> 00:07:52,479
networks

152
00:07:49,039 --> 00:07:56,639
now euro control

153
00:07:52,479 --> 00:07:58,960
for example has 2.5 million lines of ada

154
00:07:56,639 --> 00:07:59,680
i don't think they are on github they're

155
00:07:58,960 --> 00:08:02,960
not

156
00:07:59,680 --> 00:08:06,560
of course and when palace design

157
00:08:02,960 --> 00:08:09,359
civilian and military radars

158
00:08:06,560 --> 00:08:11,919
they're not on github okay and the

159
00:08:09,360 --> 00:08:14,319
software for the ariane e6 rockette

160
00:08:11,919 --> 00:08:16,000
is not on github and so on it's an

161
00:08:14,319 --> 00:08:18,800
industrial language

162
00:08:16,000 --> 00:08:20,000
and those people don't put the software

163
00:08:18,800 --> 00:08:23,840
on github

164
00:08:20,000 --> 00:08:25,440
okay so if you know as a physicist

165
00:08:23,840 --> 00:08:27,440
when you measure something you have to

166
00:08:25,440 --> 00:08:30,080
know what you are measuring

167
00:08:27,440 --> 00:08:32,080
the tiob index is a very good index of

168
00:08:30,080 --> 00:08:36,799
the popularity

169
00:08:32,080 --> 00:08:40,800
of the languages for hobbyists

170
00:08:36,799 --> 00:08:44,240
but not for industrials okay so it

171
00:08:40,799 --> 00:08:46,560
doesn't prove so here are a few

172
00:08:44,240 --> 00:08:48,560
examples of where you can find eta

173
00:08:46,560 --> 00:08:52,319
software the tgv has

174
00:08:48,560 --> 00:08:56,719
lots of ada software in it

175
00:08:52,320 --> 00:09:00,399
the a 380 and many other airplanes

176
00:08:56,720 --> 00:09:00,399
at airbus and boeing

177
00:09:00,480 --> 00:09:06,320
the automated uh metro line in paris

178
00:09:04,000 --> 00:09:08,320
that that works so well that it has been

179
00:09:06,320 --> 00:09:10,720
sold to the american it's also

180
00:09:08,320 --> 00:09:13,120
the system in automated subway of new

181
00:09:10,720 --> 00:09:13,120
york

182
00:09:13,600 --> 00:09:20,560
this was the rosetta probe

183
00:09:17,120 --> 00:09:23,839
that explored a comet

184
00:09:20,560 --> 00:09:24,560
it worked for 10 years and then woke up

185
00:09:23,839 --> 00:09:28,320
and

186
00:09:24,560 --> 00:09:31,439
achieved successfully its mission

187
00:09:28,320 --> 00:09:33,839
this is a brand luxury goat

188
00:09:31,440 --> 00:09:36,640
that has been entirely written in nature

189
00:09:33,839 --> 00:09:39,920
and so on

190
00:09:36,640 --> 00:09:43,439
so why would you use ada in general

191
00:09:39,920 --> 00:09:46,719
it uh forbids a lot of things

192
00:09:43,440 --> 00:09:47,760
you know most languages tell you oh our

193
00:09:46,720 --> 00:09:50,880
language

194
00:09:47,760 --> 00:09:54,080
is very it's very good it

195
00:09:50,880 --> 00:09:56,399
allows you to do a number of things with

196
00:09:54,080 --> 00:09:59,040
eda the other people will tell you

197
00:09:56,399 --> 00:10:00,000
our language is great it forbids you

198
00:09:59,040 --> 00:10:03,279
from making

199
00:10:00,000 --> 00:10:04,000
many errors okay it's a language for

200
00:10:03,279 --> 00:10:07,279
safety

201
00:10:04,000 --> 00:10:07,920
it's a language for uh software that

202
00:10:07,279 --> 00:10:10,880
works

203
00:10:07,920 --> 00:10:10,880
out of the box

204
00:10:12,320 --> 00:10:15,600
so thing when i hear people complaining

205
00:10:15,200 --> 00:10:18,959
about

206
00:10:15,600 --> 00:10:20,240
buffer overflows or the attacks or those

207
00:10:18,959 --> 00:10:23,880
kind of thing

208
00:10:20,240 --> 00:10:27,519
well this problem has been solved since

209
00:10:23,880 --> 00:10:30,480
1983. so there is no reason

210
00:10:27,519 --> 00:10:32,399
nowadays to complain about buffer

211
00:10:30,480 --> 00:10:33,920
overflows if you have one it's just that

212
00:10:32,399 --> 00:10:36,399
you do it you don't use the proper

213
00:10:33,920 --> 00:10:36,399
language

214
00:10:38,800 --> 00:10:46,000
and so as i mentioned the idea of ada

215
00:10:42,800 --> 00:10:49,680
is to check as much as possible at

216
00:10:46,000 --> 00:10:51,600
compile time so

217
00:10:49,680 --> 00:10:53,040
when you write something in era in

218
00:10:51,600 --> 00:10:56,399
general it will

219
00:10:53,040 --> 00:10:58,719
never compile the first time the

220
00:10:56,399 --> 00:10:59,440
compiler will always find something

221
00:10:58,720 --> 00:11:03,040
that's

222
00:10:59,440 --> 00:11:06,320
not correct in your code the good news

223
00:11:03,040 --> 00:11:09,279
is when you run it for the first time it

224
00:11:06,320 --> 00:11:10,279
very often runs out of the box and that

225
00:11:09,279 --> 00:11:14,320
is very

226
00:11:10,279 --> 00:11:17,600
satisfactory okay i write something

227
00:11:14,320 --> 00:11:21,040
the compiler helps me run

228
00:11:17,600 --> 00:11:24,160
write the test run okay it works

229
00:11:21,040 --> 00:11:24,160
go to the next problem

230
00:11:26,160 --> 00:11:32,719
so what's important in a language is not

231
00:11:29,839 --> 00:11:32,720
what it allows

232
00:11:33,680 --> 00:11:36,959
what's important in a language is what

233
00:11:35,600 --> 00:11:39,279
it forbids

234
00:11:36,959 --> 00:11:40,399
okay because that's where the safety

235
00:11:39,279 --> 00:11:42,800
comes from

236
00:11:40,399 --> 00:11:43,519
if you have a language like c that

237
00:11:42,800 --> 00:11:45,680
allows

238
00:11:43,519 --> 00:11:47,600
everything well that's normal it's a

239
00:11:45,680 --> 00:11:50,439
portable assembly language

240
00:11:47,600 --> 00:11:51,600
so you have to take up the

241
00:11:50,440 --> 00:11:54,639
responsibility

242
00:11:51,600 --> 00:11:57,040
of safety if you allow everything there

243
00:11:54,639 --> 00:12:00,000
is nothing you can prove

244
00:11:57,040 --> 00:12:00,399
the only thing you can prove is when you

245
00:12:00,000 --> 00:12:03,680
have

246
00:12:00,399 --> 00:12:07,200
rules that forbid some

247
00:12:03,680 --> 00:12:09,279
for some incorrect constructs

248
00:12:07,200 --> 00:12:12,160
so here is a little picture that

249
00:12:09,279 --> 00:12:16,560
summarizes the shape of ada

250
00:12:12,160 --> 00:12:16,560
you have a big concrete

251
00:12:16,720 --> 00:12:24,639
basis each language the syntax

252
00:12:20,720 --> 00:12:29,519
is based on pascal it i was

253
00:12:24,639 --> 00:12:29,519
designed after a competitive

254
00:12:31,839 --> 00:12:39,200
competition and readability

255
00:12:36,079 --> 00:12:40,160
was very important a very important

256
00:12:39,200 --> 00:12:42,959
criteria

257
00:12:40,160 --> 00:12:44,639
in that competition all the languages

258
00:12:42,959 --> 00:12:48,880
that made it to the half

259
00:12:44,639 --> 00:12:52,160
final were had a syntax based on ada

260
00:12:48,880 --> 00:12:55,279
and pascal honestly

261
00:12:52,160 --> 00:12:59,920
i don't understand why all the new

262
00:12:55,279 --> 00:13:04,160
languages find it obligatory to have a c

263
00:12:59,920 --> 00:13:08,000
based syntax c

264
00:13:04,160 --> 00:13:11,120
don't misunderstand me c is a very good

265
00:13:08,000 --> 00:13:14,079
low level language certainly the best

266
00:13:11,120 --> 00:13:14,639
low-level language the requirements for

267
00:13:14,079 --> 00:13:17,359
c

268
00:13:14,639 --> 00:13:19,680
was to be a portable assembly and as a

269
00:13:17,360 --> 00:13:22,240
portable assembly it's very good

270
00:13:19,680 --> 00:13:22,880
we'll see that with eda we work at a

271
00:13:22,240 --> 00:13:25,920
different

272
00:13:22,880 --> 00:13:28,079
level of abstraction okay

273
00:13:25,920 --> 00:13:29,519
but having a high level language with a

274
00:13:28,079 --> 00:13:32,319
syntax of c i don't

275
00:13:29,519 --> 00:13:34,880
understand quite well the benefit anyway

276
00:13:32,320 --> 00:13:37,920
we will have lots of examples

277
00:13:34,880 --> 00:13:42,079
on top of that you have a very strong

278
00:13:37,920 --> 00:13:45,199
typing system i think yes that's it

279
00:13:42,079 --> 00:13:48,399
so the typing system is

280
00:13:45,199 --> 00:13:52,079
really the backbone of the language

281
00:13:48,399 --> 00:13:55,519
everything is directed

282
00:13:52,079 --> 00:13:58,239
after the notion of types so

283
00:13:55,519 --> 00:14:00,320
almost every other language appears as

284
00:13:58,240 --> 00:14:03,519
weakly typed compared to

285
00:14:00,320 --> 00:14:07,279
error so we'll have some examples

286
00:14:03,519 --> 00:14:11,600
and then you have a number of pillars

287
00:14:07,279 --> 00:14:12,639
here that are features of the language

288
00:14:11,600 --> 00:14:16,720
that serve

289
00:14:12,639 --> 00:14:18,720
each precise goal of software

290
00:14:16,720 --> 00:14:21,920
engineering

291
00:14:18,720 --> 00:14:26,000
packages is the way to split

292
00:14:21,920 --> 00:14:29,599
your program into well-defined

293
00:14:26,000 --> 00:14:30,560
independent modules it's strange that

294
00:14:29,600 --> 00:14:33,120
few

295
00:14:30,560 --> 00:14:34,560
languages address that question of

296
00:14:33,120 --> 00:14:37,600
modules

297
00:14:34,560 --> 00:14:40,638
even name spaces for example in c

298
00:14:37,600 --> 00:14:44,079
plus plus a way to control

299
00:14:40,639 --> 00:14:47,680
visibility but you can

300
00:14:44,079 --> 00:14:49,599
add anything at any time to a namespace

301
00:14:47,680 --> 00:14:53,040
so there is no control

302
00:14:49,600 --> 00:14:53,839
of the modularity of it okay here we

303
00:14:53,040 --> 00:14:57,120
have

304
00:14:53,839 --> 00:15:00,160
the ide that we build

305
00:14:57,120 --> 00:15:01,839
an application from software components

306
00:15:00,160 --> 00:15:03,920
with someone who provides a software

307
00:15:01,839 --> 00:15:08,079
component someone who uses the

308
00:15:03,920 --> 00:15:10,399
software company exceptions well now

309
00:15:08,079 --> 00:15:13,120
it's quite common in most languages so i

310
00:15:10,399 --> 00:15:14,000
assume you know what it is that the way

311
00:15:13,120 --> 00:15:17,519
of having

312
00:15:14,000 --> 00:15:20,560
runtime safety in ada

313
00:15:17,519 --> 00:15:24,000
everything that can happen that's bad

314
00:15:20,560 --> 00:15:26,560
will be translated into an exception

315
00:15:24,000 --> 00:15:27,040
the requirements were that anything that

316
00:15:26,560 --> 00:15:30,000
happens

317
00:15:27,040 --> 00:15:31,040
at run time will translate into an

318
00:15:30,000 --> 00:15:32,959
exception

319
00:15:31,040 --> 00:15:34,240
because when you are writing software

320
00:15:32,959 --> 00:15:37,439
for a missile

321
00:15:34,240 --> 00:15:39,279
for example you cannot run after it and

322
00:15:37,440 --> 00:15:43,040
press ctrl alt l

323
00:15:39,279 --> 00:15:43,680
okay the missile has to care for himself

324
00:15:43,040 --> 00:15:47,120
whatever

325
00:15:43,680 --> 00:15:50,560
happens okay so

326
00:15:47,120 --> 00:15:52,959
even memory vibration in c

327
00:15:50,560 --> 00:15:54,319
code for example that you call from eda

328
00:15:52,959 --> 00:15:57,839
will be translated

329
00:15:54,320 --> 00:16:00,639
into an exception or an

330
00:15:57,839 --> 00:16:01,199
io error or an overflow or whatever you

331
00:16:00,639 --> 00:16:04,240
have

332
00:16:01,199 --> 00:16:06,800
will be translated into exceptions

333
00:16:04,240 --> 00:16:08,639
generics well they're a bit like

334
00:16:06,800 --> 00:16:11,279
templates in c plus plus

335
00:16:08,639 --> 00:16:15,600
or should i say templates in c plus plus

336
00:16:11,279 --> 00:16:18,959
were inspired from edit generics

337
00:16:15,600 --> 00:16:22,480
it's a way to have reusability

338
00:16:18,959 --> 00:16:25,920
in the presence of strong typing if you

339
00:16:22,480 --> 00:16:29,120
write an algorithm for a certain type

340
00:16:25,920 --> 00:16:32,240
you cannot use it for another type so

341
00:16:29,120 --> 00:16:36,160
it's a way of parameterizing your

342
00:16:32,240 --> 00:16:37,839
software with so you can use it on

343
00:16:36,160 --> 00:16:40,719
various types

344
00:16:37,839 --> 00:16:41,920
task multitasking is an integral part of

345
00:16:40,720 --> 00:16:45,040
the language

346
00:16:41,920 --> 00:16:48,639
and because data is also used

347
00:16:45,040 --> 00:16:51,599
for embedded software you have

348
00:16:48,639 --> 00:16:52,399
a lot a number of features that allow

349
00:16:51,600 --> 00:16:55,839
you to

350
00:16:52,399 --> 00:16:56,560
access the low level without losing the

351
00:16:55,839 --> 00:16:59,120
high level

352
00:16:56,560 --> 00:16:59,119
approach

353
00:17:02,079 --> 00:17:08,438
and all that is

354
00:17:05,280 --> 00:17:09,599
supporting the roof the programming

355
00:17:08,439 --> 00:17:13,039
methodologies

356
00:17:09,599 --> 00:17:16,240
that's very important itada was designed

357
00:17:13,039 --> 00:17:19,439
to support methodology

358
00:17:16,240 --> 00:17:22,160
now nowadays some people say well it's

359
00:17:19,439 --> 00:17:25,039
important to have good methodologies

360
00:17:22,160 --> 00:17:26,240
nobody would dare saying the opposite of

361
00:17:25,039 --> 00:17:29,760
course

362
00:17:26,240 --> 00:17:32,240
however some people say well we have a

363
00:17:29,760 --> 00:17:35,360
good design methodology so

364
00:17:32,240 --> 00:17:36,799
we don't care what the coding language

365
00:17:35,360 --> 00:17:40,479
is used after that

366
00:17:36,799 --> 00:17:41,600
okay in error we say no why would you

367
00:17:40,480 --> 00:17:44,880
stop

368
00:17:41,600 --> 00:17:46,799
the methodological effort when you go to

369
00:17:44,880 --> 00:17:50,320
the coding phase

370
00:17:46,799 --> 00:17:51,679
if you have a language that actively

371
00:17:50,320 --> 00:17:53,760
supports

372
00:17:51,679 --> 00:17:55,600
the methodology which means that you

373
00:17:53,760 --> 00:17:58,559
have a direct

374
00:17:55,600 --> 00:18:02,080
traceable connection between a

375
00:17:58,559 --> 00:18:05,120
methodology and according language

376
00:18:02,080 --> 00:18:05,760
then you can trace it all over and there

377
00:18:05,120 --> 00:18:09,760
is also an

378
00:18:05,760 --> 00:18:12,400
effect it's hard to prove but we

379
00:18:09,760 --> 00:18:13,600
witnessed that every day that if you

380
00:18:12,400 --> 00:18:16,080
have a

381
00:18:13,600 --> 00:18:17,120
error in your methodology and your

382
00:18:16,080 --> 00:18:20,159
language

383
00:18:17,120 --> 00:18:22,639
matches the methodology

384
00:18:20,160 --> 00:18:25,280
then a design er will translate into

385
00:18:22,640 --> 00:18:28,160
something that doesn't compile

386
00:18:25,280 --> 00:18:30,879
i cannot tell you how often i've seen

387
00:18:28,160 --> 00:18:33,360
people coming to my office saying

388
00:18:30,880 --> 00:18:36,160
well that done language i wrote that it

389
00:18:33,360 --> 00:18:36,159
won't compile

390
00:18:37,280 --> 00:18:40,639
look at what you've written is it

391
00:18:39,440 --> 00:18:42,559
consistent

392
00:18:40,640 --> 00:18:43,760
don't you think that there is something

393
00:18:42,559 --> 00:18:47,039
that's

394
00:18:43,760 --> 00:18:49,600
misguided here oh um

395
00:18:47,039 --> 00:18:51,440
yes i'll change that and when you think

396
00:18:49,600 --> 00:18:52,799
the designer around magically it

397
00:18:51,440 --> 00:18:56,160
compiles

398
00:18:52,799 --> 00:18:59,200
so because your types all the features

399
00:18:56,160 --> 00:19:00,720
matches exactly the objects of your

400
00:18:59,200 --> 00:19:04,240
methodology

401
00:19:00,720 --> 00:19:07,520
so the idea of ada is to

402
00:19:04,240 --> 00:19:10,880
further the methodological effort

403
00:19:07,520 --> 00:19:12,879
into the programming language including

404
00:19:10,880 --> 00:19:17,120
now since 1995

405
00:19:12,880 --> 00:19:17,120
of course object orientation

406
00:19:18,559 --> 00:19:23,200
and you have the dog houses on the side

407
00:19:22,000 --> 00:19:25,440
here

408
00:19:23,200 --> 00:19:26,240
that are called spatial need annexes

409
00:19:25,440 --> 00:19:29,600
because not

410
00:19:26,240 --> 00:19:33,039
everyone has the same needs and because

411
00:19:29,600 --> 00:19:35,439
every ada compiler is validated against

412
00:19:33,039 --> 00:19:39,760
a very

413
00:19:35,440 --> 00:19:42,559
difficult validation suite

414
00:19:39,760 --> 00:19:43,760
if you put something in the language you

415
00:19:42,559 --> 00:19:46,879
must provide it

416
00:19:43,760 --> 00:19:50,000
no subset no supersets is allowed

417
00:19:46,880 --> 00:19:52,160
by the way i have here the

418
00:19:50,000 --> 00:19:53,760
data reference manual if some of you

419
00:19:52,160 --> 00:19:56,810
want to have a look

420
00:19:53,760 --> 00:19:58,080
but don't take it it's fine um

421
00:19:56,810 --> 00:20:00,879
[Music]

422
00:19:58,080 --> 00:20:02,879
and although nowadays you have it on the

423
00:20:00,880 --> 00:20:06,960
on the web

424
00:20:02,880 --> 00:20:10,080
it's nice to have it on paper sometimes

425
00:20:06,960 --> 00:20:14,000
so extra services

426
00:20:10,080 --> 00:20:18,000
that are not required from

427
00:20:14,000 --> 00:20:21,280
all compilers are put into the annexes

428
00:20:18,000 --> 00:20:23,440
for special purpose so uh

429
00:20:21,280 --> 00:20:25,120
i'll talk later about the distributed

430
00:20:23,440 --> 00:20:27,919
system annex

431
00:20:25,120 --> 00:20:28,559
you have some analytics for real-time

432
00:20:27,919 --> 00:20:30,960
systems

433
00:20:28,559 --> 00:20:32,840
you know it's for system programming

434
00:20:30,960 --> 00:20:36,720
analytics for

435
00:20:32,840 --> 00:20:40,000
um information system for numerics

436
00:20:36,720 --> 00:20:42,559
and so on so people who don't care for

437
00:20:40,000 --> 00:20:46,240
numerics do not need to bring in all the

438
00:20:42,559 --> 00:20:46,240
numeric stuff that's what it means

439
00:20:47,600 --> 00:20:54,080
so it when you look at it

440
00:20:50,799 --> 00:20:57,200
it looks like an improved pascal it

441
00:20:54,080 --> 00:21:00,080
looks very classy a classical language

442
00:20:57,200 --> 00:21:00,799
but when you use it you discover that

443
00:21:00,080 --> 00:21:03,760
it's much

444
00:21:00,799 --> 00:21:05,440
more different from other languages than

445
00:21:03,760 --> 00:21:08,400
the syntax

446
00:21:05,440 --> 00:21:08,400
seems to show

447
00:21:10,480 --> 00:21:19,440
okay something to understand

448
00:21:14,080 --> 00:21:19,439
is the building block approach of ada

449
00:21:19,520 --> 00:21:23,760
you've heard that ada was an

450
00:21:21,200 --> 00:21:25,919
object-oriented language

451
00:21:23,760 --> 00:21:27,280
you look at the list of keywords

452
00:21:25,919 --> 00:21:31,679
surprise surprise

453
00:21:27,280 --> 00:21:35,360
class is not a key word in that language

454
00:21:31,679 --> 00:21:39,280
actually the idea is to

455
00:21:35,360 --> 00:21:42,959
make building blocks and to construct

456
00:21:39,280 --> 00:21:46,240
paradigms by assembling building blocks

457
00:21:42,960 --> 00:21:49,760
so i i'll give you

458
00:21:46,240 --> 00:21:53,200
an idea about what it means you have

459
00:21:49,760 --> 00:21:57,600
the lego the primable against

460
00:21:53,200 --> 00:21:58,240
lego approach if you have primables you

461
00:21:57,600 --> 00:22:01,918
have

462
00:21:58,240 --> 00:22:03,280
very nice pictures that are designed for

463
00:22:01,919 --> 00:22:06,480
a special purpose

464
00:22:03,280 --> 00:22:08,879
and cannot be used for anything else

465
00:22:06,480 --> 00:22:10,720
than their intended purpose they're

466
00:22:08,880 --> 00:22:12,080
ready to use but if you want to make

467
00:22:10,720 --> 00:22:15,039
something different with it

468
00:22:12,080 --> 00:22:15,039
it's not possible

469
00:22:15,520 --> 00:22:18,960
if you take a piece of lego a single

470
00:22:17,760 --> 00:22:22,400
piece of lego

471
00:22:18,960 --> 00:22:22,400
there is nothing you can do with that

472
00:22:23,200 --> 00:22:30,000
just that that's not funny okay but if

473
00:22:26,559 --> 00:22:32,240
you assemble those pieces together

474
00:22:30,000 --> 00:22:34,159
then you can make very simple things

475
00:22:32,240 --> 00:22:38,159
like this one

476
00:22:34,159 --> 00:22:41,520
or very sophisticated ones like this one

477
00:22:38,159 --> 00:22:44,559
or even this

478
00:22:41,520 --> 00:22:47,760
so the era approach is

479
00:22:44,559 --> 00:22:50,320
to have various building blocks

480
00:22:47,760 --> 00:22:53,039
and you assemble them to build your

481
00:22:50,320 --> 00:22:53,039
paradigms

482
00:22:53,679 --> 00:23:00,320
so let's see at some data

483
00:22:56,720 --> 00:23:01,280
as i mentioned it's a pascal like syntax

484
00:23:00,320 --> 00:23:04,960
so if i have

485
00:23:01,280 --> 00:23:08,080
a type color and i want to iterate over

486
00:23:04,960 --> 00:23:11,120
over it i can say for say

487
00:23:08,080 --> 00:23:14,639
in color loop and every

488
00:23:11,120 --> 00:23:16,080
construct every statement is terminated

489
00:23:14,640 --> 00:23:18,960
by a matching

490
00:23:16,080 --> 00:23:20,720
and loop so you don't have curly

491
00:23:18,960 --> 00:23:22,559
brackets beginning and

492
00:23:20,720 --> 00:23:24,559
if you have that you need if you have

493
00:23:22,559 --> 00:23:26,799
only one statement and so on

494
00:23:24,559 --> 00:23:28,480
you always have a clear beginning a

495
00:23:26,799 --> 00:23:32,000
clear end

496
00:23:28,480 --> 00:23:33,919
and uh an interesting property of that

497
00:23:32,000 --> 00:23:38,080
syntax

498
00:23:33,919 --> 00:23:41,120
is that if you copy a line

499
00:23:38,080 --> 00:23:44,639
and paste it somewhere else

500
00:23:41,120 --> 00:23:47,520
it won't introduce syntax errors

501
00:23:44,640 --> 00:23:49,520
you cannot say that of many other

502
00:23:47,520 --> 00:23:52,879
languages

503
00:23:49,520 --> 00:23:55,679
also the control

504
00:23:52,880 --> 00:23:57,039
object i don't say variable c here for

505
00:23:55,679 --> 00:23:59,600
example

506
00:23:57,039 --> 00:24:00,799
is considered a constant by the rule of

507
00:23:59,600 --> 00:24:03,360
the language

508
00:24:00,799 --> 00:24:04,320
you cannot change it in the middle of

509
00:24:03,360 --> 00:24:06,799
the loop

510
00:24:04,320 --> 00:24:08,080
and it's local to the loop so you are

511
00:24:06,799 --> 00:24:10,799
certain that you

512
00:24:08,080 --> 00:24:11,520
don't have any remaining value that you

513
00:24:10,799 --> 00:24:14,080
use

514
00:24:11,520 --> 00:24:14,559
incorrectly after that because you don't

515
00:24:14,080 --> 00:24:19,840
have it

516
00:24:14,559 --> 00:24:23,039
after that you also have the usual

517
00:24:19,840 --> 00:24:27,600
uh while loop

518
00:24:23,039 --> 00:24:27,600
you can give a name to a loop

519
00:24:29,760 --> 00:24:34,640
oh yes i have it here so you can give a

520
00:24:32,080 --> 00:24:35,520
name to a loop and if you give a name to

521
00:24:34,640 --> 00:24:38,400
the loop

522
00:24:35,520 --> 00:24:39,918
you must repeat it to at the end and

523
00:24:38,400 --> 00:24:41,760
that's very convenient

524
00:24:39,919 --> 00:24:43,360
because when you have several end loop

525
00:24:41,760 --> 00:24:45,520
and loop and loop and loop

526
00:24:43,360 --> 00:24:46,719
you can document which loop you are

527
00:24:45,520 --> 00:24:48,879
closing

528
00:24:46,720 --> 00:24:51,360
don't tell me oh yes i'd see there i can

529
00:24:48,880 --> 00:24:54,080
do that with a comment

530
00:24:51,360 --> 00:24:55,918
because you never know if a comment is

531
00:24:54,080 --> 00:24:58,480
true

532
00:24:55,919 --> 00:25:00,799
while here it's checked by the compiler

533
00:24:58,480 --> 00:25:03,039
therefore you can rely on it

534
00:25:00,799 --> 00:25:03,039
okay

535
00:25:08,159 --> 00:25:16,400
so you have the usual if else if acif

536
00:25:12,159 --> 00:25:16,960
a stretcher you have a case statement so

537
00:25:16,400 --> 00:25:20,000
for

538
00:25:16,960 --> 00:25:22,320
the c language people it's a switch the

539
00:25:20,000 --> 00:25:26,720
equivalent of a switch case

540
00:25:22,320 --> 00:25:30,559
but there is a very nice feature of eda

541
00:25:26,720 --> 00:25:32,559
given the type of eye did i mention aid

542
00:25:30,559 --> 00:25:36,000
i was strongly typed yes i did

543
00:25:32,559 --> 00:25:39,440
um you know all the possible

544
00:25:36,000 --> 00:25:42,559
values because a type data is a set

545
00:25:39,440 --> 00:25:45,200
of values with a set of operations it's

546
00:25:42,559 --> 00:25:48,240
mathematically well-defined

547
00:25:45,200 --> 00:25:49,600
and knowing the set of value the

548
00:25:48,240 --> 00:25:53,039
compiler will

549
00:25:49,600 --> 00:25:56,719
check that every possible value

550
00:25:53,039 --> 00:25:59,360
is provided in the various branches

551
00:25:56,720 --> 00:26:01,039
of the kit statement or you can have a

552
00:25:59,360 --> 00:26:04,799
one of those to cover

553
00:26:01,039 --> 00:26:08,080
all the remaining ones and that's a

554
00:26:04,799 --> 00:26:11,840
very important feature of eta awa users

555
00:26:08,080 --> 00:26:15,520
love that feature because in general you

556
00:26:11,840 --> 00:26:18,559
avoid when others close and therefore

557
00:26:15,520 --> 00:26:20,639
if you change anything in your type add

558
00:26:18,559 --> 00:26:23,440
new values or

559
00:26:20,640 --> 00:26:24,559
change it in any way the compiler will

560
00:26:23,440 --> 00:26:27,200
automatically

561
00:26:24,559 --> 00:26:28,480
tell you all the places where change

562
00:26:27,200 --> 00:26:31,120
needs to be made

563
00:26:28,480 --> 00:26:32,320
if you add a new value and forget some

564
00:26:31,120 --> 00:26:35,439
case statements

565
00:26:32,320 --> 00:26:37,678
it will not silently ignore it it will

566
00:26:35,440 --> 00:26:39,440
tell you oh here you forgot to give me

567
00:26:37,679 --> 00:26:42,320
that value

568
00:26:39,440 --> 00:26:43,919
and if the instead of chasing a bug for

569
00:26:42,320 --> 00:26:45,760
two days

570
00:26:43,919 --> 00:26:49,440
you'll immediately fix the compiler

571
00:26:45,760 --> 00:26:49,440
error and that will be all

572
00:26:50,840 --> 00:26:53,840
okay

573
00:26:56,320 --> 00:27:02,879
also ada makes every attempt

574
00:27:00,159 --> 00:27:03,919
to allow you to work directly with

575
00:27:02,880 --> 00:27:07,840
high-level

576
00:27:03,919 --> 00:27:11,360
objects and not go down

577
00:27:07,840 --> 00:27:14,639
to loops into loops into loops over the

578
00:27:11,360 --> 00:27:15,840
individual elements for example there is

579
00:27:14,640 --> 00:27:19,120
a notation called

580
00:27:15,840 --> 00:27:21,760
aggregates if you want to write

581
00:27:19,120 --> 00:27:22,559
the value of a matrix you can write it

582
00:27:21,760 --> 00:27:26,320
directly

583
00:27:22,559 --> 00:27:28,158
like that okay you don't have to assign

584
00:27:26,320 --> 00:27:31,439
to individual

585
00:27:28,159 --> 00:27:32,320
elements or for example here i have a

586
00:27:31,440 --> 00:27:35,600
piece

587
00:27:32,320 --> 00:27:39,039
of a linked list so in my

588
00:27:35,600 --> 00:27:40,399
head i create a node initialized by a

589
00:27:39,039 --> 00:27:42,799
certain value

590
00:27:40,399 --> 00:27:45,439
and the next element is itself a node

591
00:27:42,799 --> 00:27:48,960
initialized by a certain value

592
00:27:45,440 --> 00:27:49,600
and uh well we'll stop there so the next

593
00:27:48,960 --> 00:27:53,279
element is

594
00:27:49,600 --> 00:27:55,600
no you describe globally your structure

595
00:27:53,279 --> 00:27:56,480
you don't have to go down deep in the

596
00:27:55,600 --> 00:27:59,520
structure

597
00:27:56,480 --> 00:28:02,880
with every element and

598
00:27:59,520 --> 00:28:05,440
needless to say all the

599
00:28:02,880 --> 00:28:07,520
consistency of the values is always

600
00:28:05,440 --> 00:28:09,440
checked at compile time

601
00:28:07,520 --> 00:28:10,559
so if there is anything that's not

602
00:28:09,440 --> 00:28:13,679
correct

603
00:28:10,559 --> 00:28:13,678
you'll know immediately

604
00:28:14,320 --> 00:28:18,480
so i said strong typing what does it

605
00:28:17,279 --> 00:28:21,520
mean

606
00:28:18,480 --> 00:28:26,640
imagine i have the

607
00:28:21,520 --> 00:28:31,120
age the age of a person well when you

608
00:28:26,640 --> 00:28:34,559
design a type types in data

609
00:28:31,120 --> 00:28:38,320
are abstractions of real

610
00:28:34,559 --> 00:28:41,760
world objects well you cannot

611
00:28:38,320 --> 00:28:45,520
add the age of a person

612
00:28:41,760 --> 00:28:49,120
to a number of flows it's meaningless

613
00:28:45,520 --> 00:28:50,000
okay so in eda you define a type and

614
00:28:49,120 --> 00:28:53,039
every type

615
00:28:50,000 --> 00:28:55,679
is different if you have here something

616
00:28:53,039 --> 00:28:55,679
that says

617
00:28:57,440 --> 00:29:02,399
if it says type is it's

618
00:29:00,559 --> 00:29:03,840
always a different type that's

619
00:29:02,399 --> 00:29:07,120
incompatible with

620
00:29:03,840 --> 00:29:08,959
any other type so we have if i have the

621
00:29:07,120 --> 00:29:13,840
age of a person

622
00:29:08,960 --> 00:29:13,840
and the number of flaws in a building

623
00:29:14,320 --> 00:29:21,760
i can use the appropriate values here

624
00:29:18,159 --> 00:29:25,679
but if i can if i try to mix them up

625
00:29:21,760 --> 00:29:29,520
it will simply not compile

626
00:29:25,679 --> 00:29:32,799
tell that to a six years

627
00:29:29,520 --> 00:29:34,960
old boy and he

628
00:29:32,799 --> 00:29:36,240
he will look at you with glass eyes

629
00:29:34,960 --> 00:29:39,039
saying well it's been

630
00:29:36,240 --> 00:29:39,679
a certain number of years even at that

631
00:29:39,039 --> 00:29:42,640
age

632
00:29:39,679 --> 00:29:45,039
that he's been told that you don't mix

633
00:29:42,640 --> 00:29:48,480
apple and oranges

634
00:29:45,039 --> 00:29:51,520
but ada is the only language that allows

635
00:29:48,480 --> 00:29:55,840
you to check that at uh

636
00:29:51,520 --> 00:29:55,840
compile time at language level

637
00:29:58,880 --> 00:30:06,320
so the id when you design a software

638
00:30:03,279 --> 00:30:10,080
okay you should always do it this way

639
00:30:06,320 --> 00:30:13,200
first you model the problem space

640
00:30:10,080 --> 00:30:16,559
there you have edges you have flaws

641
00:30:13,200 --> 00:30:20,000
you have things like that okay

642
00:30:16,559 --> 00:30:21,440
and then you have to map those high

643
00:30:20,000 --> 00:30:25,120
level types

644
00:30:21,440 --> 00:30:26,159
to a matching level where you have only

645
00:30:25,120 --> 00:30:29,039
bite inks

646
00:30:26,159 --> 00:30:29,039
and things like that

647
00:30:30,559 --> 00:30:34,480
that the language level okay

648
00:30:34,640 --> 00:30:38,320
with other languages you have to do the

649
00:30:37,600 --> 00:30:41,199
mapping

650
00:30:38,320 --> 00:30:42,240
even with supposedly high-level

651
00:30:41,200 --> 00:30:45,679
languages like

652
00:30:42,240 --> 00:30:48,320
java or simplestress and so on

653
00:30:45,679 --> 00:30:50,159
all the integer types you have are the

654
00:30:48,320 --> 00:30:53,360
machine types

655
00:30:50,159 --> 00:30:55,520
so you have to do the mapping the new

656
00:30:53,360 --> 00:30:58,399
thing with ada

657
00:30:55,520 --> 00:30:58,720
is that ada gives you access directly to

658
00:30:58,399 --> 00:31:02,239
that

659
00:30:58,720 --> 00:31:04,159
level and therefore it's the compiler

660
00:31:02,240 --> 00:31:07,600
who does the mapping

661
00:31:04,159 --> 00:31:11,200
it means that it relieves you from many

662
00:31:07,600 --> 00:31:14,080
portability problems because that level

663
00:31:11,200 --> 00:31:16,000
is completely machine independent

664
00:31:14,080 --> 00:31:17,360
therefore the compiler chooses the

665
00:31:16,000 --> 00:31:20,080
compiler knows

666
00:31:17,360 --> 00:31:22,559
the machine and it will always choose

667
00:31:20,080 --> 00:31:23,840
the appropriate representation for your

668
00:31:22,559 --> 00:31:26,799
types

669
00:31:23,840 --> 00:31:29,519
but your types are by nature machine

670
00:31:26,799 --> 00:31:29,519
independent

671
00:31:31,039 --> 00:31:36,080
packages i mentioned that you still have

672
00:31:36,320 --> 00:31:46,080
seeds but just be careful with my

673
00:31:41,200 --> 00:31:49,840
little wire hair um

674
00:31:46,080 --> 00:31:52,080
packages are the way to

675
00:31:49,840 --> 00:31:52,080
make

676
00:31:54,399 --> 00:32:01,439
modules with a well-defined interface

677
00:31:58,320 --> 00:32:04,158
and the main principle is that the

678
00:32:01,440 --> 00:32:05,760
user of a take it as a library for

679
00:32:04,159 --> 00:32:08,960
example

680
00:32:05,760 --> 00:32:12,320
does not know how it works

681
00:32:08,960 --> 00:32:12,799
and the designer of a library does not

682
00:32:12,320 --> 00:32:16,158
know

683
00:32:12,799 --> 00:32:19,679
who will use it okay so

684
00:32:16,159 --> 00:32:21,200
it guarantees the independence of this

685
00:32:19,679 --> 00:32:24,559
point of view

686
00:32:21,200 --> 00:32:28,159
so a package has a specification

687
00:32:24,559 --> 00:32:32,240
for example here i have a column manager

688
00:32:28,159 --> 00:32:34,960
and i define a color type as private

689
00:32:32,240 --> 00:32:37,039
it means okay i tell you there is a type

690
00:32:34,960 --> 00:32:40,799
it's called color but i don't

691
00:32:37,039 --> 00:32:44,399
tell you how it's it's made inside

692
00:32:40,799 --> 00:32:48,158
and then you can provide operation

693
00:32:44,399 --> 00:32:48,158
here we have the

694
00:32:50,320 --> 00:32:53,519
here we have the redefinition of

695
00:32:52,399 --> 00:32:56,959
operation

696
00:32:53,519 --> 00:33:00,320
so i can add two colors

697
00:32:56,960 --> 00:33:04,159
to make an another color or multiply a

698
00:33:00,320 --> 00:33:07,120
certain color by a certain density

699
00:33:04,159 --> 00:33:09,679
i announce those properties but i don't

700
00:33:07,120 --> 00:33:11,918
tell how it's done

701
00:33:09,679 --> 00:33:14,080
there is a problem because the compiler

702
00:33:11,919 --> 00:33:15,360
needs to know the implementation if you

703
00:33:14,080 --> 00:33:18,639
want to be able

704
00:33:15,360 --> 00:33:20,399
to use that abstraction using only the

705
00:33:18,640 --> 00:33:24,480
visible part

706
00:33:20,399 --> 00:33:27,439
so a package can have a private part

707
00:33:24,480 --> 00:33:30,000
where you tell the truth to the compiler

708
00:33:27,440 --> 00:33:33,919
but the external user cannot make

709
00:33:30,000 --> 00:33:39,679
any use of that private part it's

710
00:33:33,919 --> 00:33:41,840
completely checked by the compiler

711
00:33:39,679 --> 00:33:43,440
and then you have the package body that

712
00:33:41,840 --> 00:33:46,720
the implementation

713
00:33:43,440 --> 00:33:49,840
of the package where you

714
00:33:46,720 --> 00:33:54,159
give the actual code for all the

715
00:33:49,840 --> 00:33:54,158
provided operations okay

716
00:33:54,480 --> 00:33:59,440
and an important feature of ada is that

717
00:33:57,600 --> 00:34:01,678
you can use the package

718
00:33:59,440 --> 00:34:03,200
as soon as you have compiled the

719
00:34:01,679 --> 00:34:06,320
specification

720
00:34:03,200 --> 00:34:09,359
you don't even need to

721
00:34:06,320 --> 00:34:12,639
have written the body okay

722
00:34:09,359 --> 00:34:15,918
so you can write a specification then

723
00:34:12,639 --> 00:34:17,839
you write the users of the specification

724
00:34:15,918 --> 00:34:19,598
this allows you to check that what

725
00:34:17,839 --> 00:34:23,040
you've specified

726
00:34:19,599 --> 00:34:25,599
matches the needs of the user

727
00:34:23,040 --> 00:34:26,879
and once you are certain that what you

728
00:34:25,599 --> 00:34:30,480
have proposed

729
00:34:26,879 --> 00:34:32,960
is what is needed only then you think

730
00:34:30,480 --> 00:34:35,679
about the implementation

731
00:34:32,960 --> 00:34:36,399
so that says a lot of time because too

732
00:34:35,679 --> 00:34:38,639
often

733
00:34:36,399 --> 00:34:40,319
people write a lot of code just to

734
00:34:38,639 --> 00:34:41,280
discover that it's not what was

735
00:34:40,320 --> 00:34:45,200
necessary

736
00:34:41,280 --> 00:34:45,200
okay with data you can check it

737
00:34:46,839 --> 00:34:49,839
beforehand

738
00:34:50,879 --> 00:34:56,960
okay and then well you just

739
00:34:54,560 --> 00:34:58,400
when you you when you are using one of

740
00:34:56,960 --> 00:35:01,440
those packages

741
00:34:58,400 --> 00:35:05,280
you must always mention them

742
00:35:01,440 --> 00:35:06,480
in a ways clause so every dependence

743
00:35:05,280 --> 00:35:09,760
between modules

744
00:35:06,480 --> 00:35:11,599
is explicit in error which means that

745
00:35:09,760 --> 00:35:15,440
you can have

746
00:35:11,599 --> 00:35:18,240
automated makers i should say

747
00:35:15,440 --> 00:35:19,440
without the need of a make file and so

748
00:35:18,240 --> 00:35:22,160
without errors

749
00:35:19,440 --> 00:35:22,700
in the make file because that's

750
00:35:22,160 --> 00:35:23,920
something i

751
00:35:22,700 --> 00:35:26,240
[Music]

752
00:35:23,920 --> 00:35:27,040
never had a good explanation about how

753
00:35:26,240 --> 00:35:31,839
do you

754
00:35:27,040 --> 00:35:31,839
prove that the makefile is correct

755
00:35:32,400 --> 00:35:39,040
well make files are supposed to

756
00:35:35,920 --> 00:35:41,119
have less compilations let's face it

757
00:35:39,040 --> 00:35:43,040
every time you use the make files if you

758
00:35:41,119 --> 00:35:47,200
have a doubt

759
00:35:43,040 --> 00:35:49,920
you say make clean make right

760
00:35:47,200 --> 00:35:51,919
that's the exactly the opposite goal or

761
00:35:49,920 --> 00:35:52,240
the make file which is supposed to save

762
00:35:51,920 --> 00:35:54,880
you

763
00:35:52,240 --> 00:35:56,959
compilation okay but because you don't

764
00:35:54,880 --> 00:35:59,040
know well

765
00:35:56,960 --> 00:36:01,359
you could as well recompile everything

766
00:35:59,040 --> 00:36:04,000
every time

767
00:36:01,359 --> 00:36:05,160
so the idea is to enforce abstraction by

768
00:36:04,000 --> 00:36:09,200
separating

769
00:36:05,160 --> 00:36:13,440
specification from implementation

770
00:36:09,200 --> 00:36:16,720
and so as i said you have no make files

771
00:36:13,440 --> 00:36:19,680
a feature of data that is uh

772
00:36:16,720 --> 00:36:21,839
that you won't find in many in most

773
00:36:19,680 --> 00:36:24,160
languages actually i don't know if any

774
00:36:21,839 --> 00:36:25,440
other language that had that is a

775
00:36:24,160 --> 00:36:28,319
possibility

776
00:36:25,440 --> 00:36:30,880
of having parameterized types they are

777
00:36:28,320 --> 00:36:33,119
called discriminated types

778
00:36:30,880 --> 00:36:34,079
so the same way as you could define

779
00:36:33,119 --> 00:36:37,760
parameters

780
00:36:34,079 --> 00:36:41,520
to a subprogram you can define

781
00:36:37,760 --> 00:36:42,320
parameters to a type and you see i can

782
00:36:41,520 --> 00:36:46,000
have

783
00:36:42,320 --> 00:36:49,760
a component here whose size

784
00:36:46,000 --> 00:36:53,040
depends on the parameter or i can

785
00:36:49,760 --> 00:36:56,320
even have case parts where

786
00:36:53,040 --> 00:37:00,400
the elements that are part of the record

787
00:36:56,320 --> 00:37:03,359
depends on the variant of the parameter

788
00:37:00,400 --> 00:37:04,480
so it's very convenient when you have

789
00:37:03,359 --> 00:37:06,720
flexible

790
00:37:04,480 --> 00:37:07,920
types like here it would be a student

791
00:37:06,720 --> 00:37:11,359
record

792
00:37:07,920 --> 00:37:12,480
so we have students may have various

793
00:37:11,359 --> 00:37:14,880
majors

794
00:37:12,480 --> 00:37:17,040
and if it's in letter they have a

795
00:37:14,880 --> 00:37:23,839
grading relating and so on

796
00:37:17,040 --> 00:37:23,839
okay so variant records

797
00:37:24,080 --> 00:37:27,230
[Music]

798
00:37:30,480 --> 00:37:37,040
object oriented programming

799
00:37:33,839 --> 00:37:40,400
be careful the model of ada

800
00:37:37,040 --> 00:37:45,119
is somehow different from what you can

801
00:37:40,400 --> 00:37:45,119
know from other languages

802
00:37:46,240 --> 00:37:49,279
that's where you see the building block

803
00:37:48,480 --> 00:37:51,200
approach

804
00:37:49,280 --> 00:37:53,119
we have seen the packages support

805
00:37:51,200 --> 00:37:56,000
encapsulation

806
00:37:53,119 --> 00:37:56,480
there is a special kind of type called

807
00:37:56,000 --> 00:38:01,760
tag

808
00:37:56,480 --> 00:38:01,760
types that support dynamic binding

809
00:38:03,200 --> 00:38:10,000
a class is a

810
00:38:06,560 --> 00:38:13,279
type with dynamic binding

811
00:38:10,000 --> 00:38:16,400
which is encapsulated therefore

812
00:38:13,280 --> 00:38:16,800
it's a design pattern in either it's a

813
00:38:16,400 --> 00:38:20,800
tag

814
00:38:16,800 --> 00:38:23,920
type within a package so typically

815
00:38:20,800 --> 00:38:27,200
that's not very original i have a widget

816
00:38:23,920 --> 00:38:30,880
so i call my package widget and

817
00:38:27,200 --> 00:38:31,680
i give the type that corresponds to the

818
00:38:30,880 --> 00:38:33,839
data

819
00:38:31,680 --> 00:38:36,319
a special name that's not required by

820
00:38:33,839 --> 00:38:39,359
the language it's just a good habit

821
00:38:36,320 --> 00:38:41,520
called for example instance so it's a

822
00:38:39,359 --> 00:38:45,359
tag type because you have the word

823
00:38:41,520 --> 00:38:49,040
tagged here okay

824
00:38:45,359 --> 00:38:52,078
and then i can have procedures that

825
00:38:49,040 --> 00:38:54,880
work on that those procedures that are

826
00:38:52,079 --> 00:38:55,520
given in the same package specification

827
00:38:54,880 --> 00:38:58,880
as the

828
00:38:55,520 --> 00:39:02,320
tag type are what you would call

829
00:38:58,880 --> 00:39:04,400
methods in other languages so

830
00:39:02,320 --> 00:39:07,440
presumably you've heard of c plus plus

831
00:39:04,400 --> 00:39:11,119
in c plus plus you define a class

832
00:39:07,440 --> 00:39:14,079
with data members and

833
00:39:11,119 --> 00:39:14,960
function members okay the function

834
00:39:14,079 --> 00:39:18,240
members

835
00:39:14,960 --> 00:39:22,880
are the methods in eda if you want

836
00:39:18,240 --> 00:39:26,399
the package played the role of the class

837
00:39:22,880 --> 00:39:29,599
the data members are gathered into that

838
00:39:26,400 --> 00:39:32,400
tag type and the operations

839
00:39:29,599 --> 00:39:33,359
are the methods so it's not that far

840
00:39:32,400 --> 00:39:36,000
away

841
00:39:33,359 --> 00:39:36,480
from what happens in c plus plus except

842
00:39:36,000 --> 00:39:39,440
that

843
00:39:36,480 --> 00:39:43,839
all the data parts are grouped into the

844
00:39:39,440 --> 00:39:43,839
tag type

845
00:39:45,200 --> 00:39:49,919
and then of course you can inherit so

846
00:39:47,440 --> 00:39:54,079
you can define a new type

847
00:39:49,920 --> 00:39:54,079
as inheriting from

848
00:39:54,400 --> 00:39:59,760
the type of above where is my mouse it's

849
00:39:56,800 --> 00:40:02,960
here so it inherits from this one

850
00:39:59,760 --> 00:40:06,240
and you can add a visible part

851
00:40:02,960 --> 00:40:09,119
or a private part you may want to give

852
00:40:06,240 --> 00:40:13,200
the extra components

853
00:40:09,119 --> 00:40:24,400
to leave them visible or to hide them

854
00:40:13,200 --> 00:40:27,399
in the private part so

855
00:40:24,400 --> 00:40:29,680
an important feature of ada is that

856
00:40:27,400 --> 00:40:31,839
object-oriented programming is not

857
00:40:29,680 --> 00:40:35,680
related to pointers

858
00:40:31,839 --> 00:40:38,720
much most languages allow you to do

859
00:40:35,680 --> 00:40:42,078
object-oriented programming only

860
00:40:38,720 --> 00:40:45,118
with will use pointers in ada

861
00:40:42,079 --> 00:40:46,640
you can write huge programs including

862
00:40:45,119 --> 00:40:49,920
object-oriented ones

863
00:40:46,640 --> 00:40:53,598
without any pointer okay

864
00:40:49,920 --> 00:40:58,000
so the whole issue of the

865
00:40:53,599 --> 00:40:58,000
memory management becomes much simpler

866
00:40:58,720 --> 00:41:05,439
so this model gives you an important div

867
00:41:02,240 --> 00:41:08,399
that's what the important difference

868
00:41:05,440 --> 00:41:11,200
and others here i have a hierarchy of

869
00:41:08,400 --> 00:41:15,280
those types

870
00:41:11,200 --> 00:41:18,560
and there is a different type called

871
00:41:15,280 --> 00:41:20,960
the class wide type that includes

872
00:41:18,560 --> 00:41:22,319
the whole tree in eda we make the

873
00:41:20,960 --> 00:41:25,440
difference

874
00:41:22,319 --> 00:41:27,680
between a single type called the

875
00:41:25,440 --> 00:41:30,880
specific type

876
00:41:27,680 --> 00:41:32,000
and the whole tree most languages

877
00:41:30,880 --> 00:41:37,280
confuse

878
00:41:32,000 --> 00:41:37,280
those two notions and so you can have

879
00:41:39,280 --> 00:41:46,560
for example if i have a procedure move

880
00:41:42,800 --> 00:41:49,920
with a parameter of type widget

881
00:41:46,560 --> 00:41:53,759
class it means it can work on

882
00:41:49,920 --> 00:41:58,079
every value from the whole tree

883
00:41:53,760 --> 00:42:02,079
okay the set of value for the classroom

884
00:41:58,079 --> 00:42:05,400
type is the union of all values from

885
00:42:02,079 --> 00:42:08,960
each type that's in it okay and so you

886
00:42:05,400 --> 00:42:08,960
differentiate with that

887
00:42:10,880 --> 00:42:14,720
operations method that are on a single

888
00:42:13,680 --> 00:42:17,839
type

889
00:42:14,720 --> 00:42:18,480
and class wide operation that operate on

890
00:42:17,839 --> 00:42:21,599
the whole

891
00:42:18,480 --> 00:42:25,359
tree and of course if i'm calling that

892
00:42:21,599 --> 00:42:26,720
move here at compile time i don't know

893
00:42:25,359 --> 00:42:29,440
which kind

894
00:42:26,720 --> 00:42:30,480
of type i have here therefore it will

895
00:42:29,440 --> 00:42:34,800
introduce

896
00:42:30,480 --> 00:42:34,800
dynamic binding okay

897
00:42:36,160 --> 00:42:39,839
so time is running

898
00:42:40,720 --> 00:42:44,560
starting with 205 there are interfaces

899
00:42:43,920 --> 00:42:47,920
that work

900
00:42:44,560 --> 00:42:51,440
roughly like java interfaces

901
00:42:47,920 --> 00:42:54,480
you can define type as an

902
00:42:51,440 --> 00:42:55,440
interface and they can have only

903
00:42:54,480 --> 00:42:57,680
abstract

904
00:42:55,440 --> 00:42:58,960
or no operation by the way small

905
00:42:57,680 --> 00:43:01,680
improvement

906
00:42:58,960 --> 00:43:03,119
and every operation that claims to

907
00:43:01,680 --> 00:43:06,399
implement that type

908
00:43:03,119 --> 00:43:09,200
must provide the operations

909
00:43:06,400 --> 00:43:09,839
and you can inherit from one real tag

910
00:43:09,200 --> 00:43:12,960
type

911
00:43:09,839 --> 00:43:16,640
and as many interfaces as you want

912
00:43:12,960 --> 00:43:16,640
like in other languages

913
00:43:17,520 --> 00:43:22,400
as i mentioned every runtime error

914
00:43:19,520 --> 00:43:26,240
results in exceptions

915
00:43:22,400 --> 00:43:29,599
and every exception can be handled

916
00:43:26,240 --> 00:43:33,200
so this is the mantra once you have

917
00:43:29,599 --> 00:43:36,480
taken care of the unexpected

918
00:43:33,200 --> 00:43:39,680
take care of the unexpected unexpected

919
00:43:36,480 --> 00:43:41,359
okay at the end of an inner program you

920
00:43:39,680 --> 00:43:44,399
can have a one-horse

921
00:43:41,359 --> 00:43:49,440
when other handler that will catch

922
00:43:44,400 --> 00:43:49,440
everything that can happen at run time

923
00:43:50,480 --> 00:43:55,200
generics as i mentioned are algorithms

924
00:43:53,200 --> 00:43:58,799
that work on any data type

925
00:43:55,200 --> 00:44:00,000
so you can say that you have a procedure

926
00:43:58,800 --> 00:44:03,520
swap

927
00:44:00,000 --> 00:44:06,560
and that you have to give it a type

928
00:44:03,520 --> 00:44:08,800
is private means it has

929
00:44:06,560 --> 00:44:10,480
only the property is known to all

930
00:44:08,800 --> 00:44:14,000
private types which are

931
00:44:10,480 --> 00:44:16,240
assignments and comparisons and look

932
00:44:14,000 --> 00:44:17,359
and therefore for every type that

933
00:44:16,240 --> 00:44:20,000
matches

934
00:44:17,359 --> 00:44:23,598
a certain number of minimal properties

935
00:44:20,000 --> 00:44:27,119
you can

936
00:44:23,599 --> 00:44:30,640
you can instantiate that generic

937
00:44:27,119 --> 00:44:33,040
like this you can add the compiler to

938
00:44:30,640 --> 00:44:36,078
build a procedure swap edge

939
00:44:33,040 --> 00:44:39,200
by taking that generic swap

940
00:44:36,079 --> 00:44:42,880
and replacing everywhere age

941
00:44:39,200 --> 00:44:46,078
item by age okay but there is a

942
00:44:42,880 --> 00:44:49,520
major difference between eta generics

943
00:44:46,079 --> 00:44:54,079
and zebra stress templates

944
00:44:49,520 --> 00:44:57,359
in that generics are compiled checked

945
00:44:54,079 --> 00:44:59,920
and provided that the type

946
00:44:57,359 --> 00:45:00,880
or any other thing that you provide

947
00:44:59,920 --> 00:45:04,800
match

948
00:45:00,880 --> 00:45:08,240
the requirements then the instantiation

949
00:45:04,800 --> 00:45:11,359
is always correct okay you don't

950
00:45:08,240 --> 00:45:15,118
turn you don't check

951
00:45:11,359 --> 00:45:19,759
at um right at compile time

952
00:45:15,119 --> 00:45:22,160
if it's correct it works okay i hurry

953
00:45:19,760 --> 00:45:23,440
so you have tasking i'm afraid i was a

954
00:45:22,160 --> 00:45:26,560
bit slow

955
00:45:23,440 --> 00:45:29,920
just a word uh but

956
00:45:26,560 --> 00:45:34,480
the low level so you can speed you have

957
00:45:29,920 --> 00:45:38,000
here record you can specify

958
00:45:34,480 --> 00:45:40,960
bit by bit exactly the layout

959
00:45:38,000 --> 00:45:40,960
of the record

960
00:45:42,079 --> 00:45:46,160
and therefore if you change a bit you

961
00:45:44,880 --> 00:45:50,079
keep the high level

962
00:45:46,160 --> 00:45:53,598
approach and you get at assembly level

963
00:45:50,079 --> 00:45:55,839
exactly what you want so the idea of it

964
00:45:53,599 --> 00:45:57,680
is once again that you specify the high

965
00:45:55,839 --> 00:46:01,839
level the compiler

966
00:45:57,680 --> 00:46:01,839
takes care of the low level

967
00:46:02,240 --> 00:46:11,439
okay i'll have to skip these ones

968
00:46:05,920 --> 00:46:11,440
i mention here are the various annexes

969
00:46:11,839 --> 00:46:15,839
and that says that really it's very nice

970
00:46:15,359 --> 00:46:19,119
i

971
00:46:15,839 --> 00:46:20,240
often develop on my laptop that is under

972
00:46:19,119 --> 00:46:23,200
windows

973
00:46:20,240 --> 00:46:23,919
and i take the code i recompile and i

974
00:46:23,200 --> 00:46:27,359
put in

975
00:46:23,920 --> 00:46:30,400
in survey in operation on my linux box

976
00:46:27,359 --> 00:46:32,960
i don't even run the checks again

977
00:46:30,400 --> 00:46:33,920
because if it works on one side it will

978
00:46:32,960 --> 00:46:38,800
work

979
00:46:33,920 --> 00:46:38,800
exactly the same on the other side

980
00:46:39,760 --> 00:46:44,960
okay we have a good compiler with good

981
00:46:42,000 --> 00:46:44,960
error messages

982
00:46:45,599 --> 00:46:52,240
a number of

983
00:46:48,960 --> 00:46:55,520
libraries so you can check with you can

984
00:46:52,240 --> 00:46:57,279
google any library space ada and you'll

985
00:46:55,520 --> 00:46:58,480
find that there is an implementation of

986
00:46:57,280 --> 00:47:01,119
it for it

987
00:46:58,480 --> 00:47:03,520
so in short conclusion you might expect

988
00:47:01,119 --> 00:47:06,560
that i tell you use ada

989
00:47:03,520 --> 00:47:09,040
no i won't you are grown up people

990
00:47:06,560 --> 00:47:09,599
you are responsible i don't have to tell

991
00:47:09,040 --> 00:47:12,800
you

992
00:47:09,599 --> 00:47:13,440
what you have to do in conclusion i'll

993
00:47:12,800 --> 00:47:17,599
just say

994
00:47:13,440 --> 00:47:17,599
please please

995
00:47:18,160 --> 00:47:25,118
try it okay you have three compilers

996
00:47:22,240 --> 00:47:26,479
you have a number of benefits try it by

997
00:47:25,119 --> 00:47:29,680
yourself

998
00:47:26,480 --> 00:47:32,800
and then you can decide if it fits your

999
00:47:29,680 --> 00:47:36,839
spirit or your needs or everything

1000
00:47:32,800 --> 00:47:39,839
that you may require from a language

1001
00:47:36,839 --> 00:47:39,839
okay

1002
00:47:41,680 --> 00:47:45,040
questions yep it's i think it's the

1003
00:47:44,000 --> 00:47:47,280
oldest language

1004
00:47:45,040 --> 00:47:48,400
i know for the moment because the five

1005
00:47:47,280 --> 00:47:51,040
three year growth

1006
00:47:48,400 --> 00:47:52,319
it exists already so i have a question

1007
00:47:51,040 --> 00:47:55,520
which will be

1008
00:47:52,319 --> 00:47:58,000
a suggestion ah it's very

1009
00:47:55,520 --> 00:47:59,040
something similar to pascal to have a

1010
00:47:58,000 --> 00:48:02,079
comparison

1011
00:47:59,040 --> 00:48:04,720
between pascal and well

1012
00:48:02,079 --> 00:48:06,960
in a sense you could define ada as an

1013
00:48:04,720 --> 00:48:10,078
industrial pascal

1014
00:48:06,960 --> 00:48:12,960
pascal was too small it was designed to

1015
00:48:10,079 --> 00:48:15,119
be a pedagogical for universities

1016
00:48:12,960 --> 00:48:16,720
and it doesn't grow up to be an

1017
00:48:15,119 --> 00:48:19,119
industrial language

1018
00:48:16,720 --> 00:48:20,160
same thing as you cannot extend a

1019
00:48:19,119 --> 00:48:23,839
language design

1020
00:48:20,160 --> 00:48:28,240
for web to a real-time language

1021
00:48:23,839 --> 00:48:28,240
if you see what i mean okay

1022
00:48:28,800 --> 00:48:33,119
yeah we learned about packages and

1023
00:48:30,800 --> 00:48:34,000
generics is there a way to specify

1024
00:48:33,119 --> 00:48:35,440
properties of

1025
00:48:34,000 --> 00:48:38,160
the methods that you define like

1026
00:48:35,440 --> 00:48:40,960
associate associativity or

1027
00:48:38,160 --> 00:48:44,000
symmetry so that when you implement or

1028
00:48:40,960 --> 00:48:48,720
instantiate you know these properties

1029
00:48:44,000 --> 00:48:51,119
well associativity is very difficult

1030
00:48:48,720 --> 00:48:52,799
okay there is a for the next revision of

1031
00:48:51,119 --> 00:48:54,880
the language which is by the way

1032
00:48:52,800 --> 00:48:57,200
scheduled for next year

1033
00:48:54,880 --> 00:48:59,839
there are some reflections about that

1034
00:48:57,200 --> 00:49:02,399
but it appears to be extremely difficult

1035
00:48:59,839 --> 00:49:03,599
especially if you consider associativity

1036
00:49:02,400 --> 00:49:07,740
of floating points

1037
00:49:03,599 --> 00:49:10,920
for example that's awful okay

1038
00:49:07,740 --> 00:49:10,919
[Music]

1039
00:49:11,280 --> 00:49:18,720
there in 2020 in 2012

1040
00:49:14,800 --> 00:49:22,160
you have contracts so those contracts

1041
00:49:18,720 --> 00:49:25,439
are checked as runtime there is a

1042
00:49:22,160 --> 00:49:28,480
special subset of ada that allows

1043
00:49:25,440 --> 00:49:32,240
much more provable thing called spark

1044
00:49:28,480 --> 00:49:35,520
it doesn't cover the the whole language

1045
00:49:32,240 --> 00:49:38,959
but where ada will check at runtime

1046
00:49:35,520 --> 00:49:40,960
spark will prove at compile time

1047
00:49:38,960 --> 00:49:42,400
but of course in that case you don't

1048
00:49:40,960 --> 00:49:43,440
have the full language because not

1049
00:49:42,400 --> 00:49:46,800
everything is

1050
00:49:43,440 --> 00:49:46,800
provable okay

1051
00:49:46,880 --> 00:49:52,720
anything else okay fine thank you for

1052
00:49:50,559 --> 00:49:54,000
listening now it's time to make the

1053
00:49:52,720 --> 00:49:59,359
drawing

1054
00:49:54,000 --> 00:50:02,479
so please

1055
00:49:59,360 --> 00:50:02,479
[Applause]

1056
00:50:05,079 --> 00:50:13,839
141 who is the lucky winner

1057
00:50:09,440 --> 00:50:13,839
you've got it

1058
00:50:14,559 --> 00:50:17,680
one one seven

1059
00:50:21,599 --> 00:50:28,400
okay one one seven

1060
00:50:25,680 --> 00:50:28,399
here you are

1061
00:50:30,559 --> 00:50:33,599
okay you're not a beginner

1062
00:50:33,839 --> 00:50:41,119
thank you so 140

1063
00:50:37,119 --> 00:50:43,920
one for zero

1064
00:50:41,119 --> 00:50:43,920
left already

1065
00:50:44,160 --> 00:50:46,640
too bad

1066
00:50:48,960 --> 00:50:58,400
okay next one one five five

1067
00:50:55,440 --> 00:50:58,400
okay with pleasure

1068
00:50:59,119 --> 00:51:02,160
and the last one

1069
00:51:03,280 --> 00:51:06,400
one five six

1070
00:51:06,880 --> 00:51:09,839
here you are

1071
00:51:10,400 --> 00:51:14,160
okay you've got something from four of

1072
00:51:16,760 --> 00:51:19,760
them

