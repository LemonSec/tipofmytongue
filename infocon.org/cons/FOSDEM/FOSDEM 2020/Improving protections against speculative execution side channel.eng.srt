1
00:00:06,080 --> 00:00:09,679
good afternoon everyone

2
00:00:07,759 --> 00:00:11,360
um i'd like to welcome to the stage

3
00:00:09,679 --> 00:00:12,000
david who's traveled all the way from

4
00:00:11,360 --> 00:00:14,160
oregon

5
00:00:12,000 --> 00:00:16,400
in the states to talk to us today about

6
00:00:14,160 --> 00:00:19,440
speculative execution side channels

7
00:00:16,400 --> 00:00:19,439
thank you so much

8
00:00:21,600 --> 00:00:25,039
it's wonderful to be here at fosdem i've

9
00:00:24,080 --> 00:00:26,320
heard about this

10
00:00:25,039 --> 00:00:28,320
conference for many years this is my

11
00:00:26,320 --> 00:00:29,519
first time uh being here though so i'm a

12
00:00:28,320 --> 00:00:32,558
little bit uh

13
00:00:29,519 --> 00:00:34,640
i'm a little bit excited and uh very um

14
00:00:32,558 --> 00:00:36,320
a little bit uh intimidated by all of

15
00:00:34,640 --> 00:00:38,160
you but this is a great room so that all

16
00:00:36,320 --> 00:00:39,760
the introverts can sit as far apart from

17
00:00:38,160 --> 00:00:42,000
each other as possible

18
00:00:39,760 --> 00:00:43,760
awesome it's my kind of room different

19
00:00:42,000 --> 00:00:45,440
from the security track yesterday where

20
00:00:43,760 --> 00:00:47,280
everyone was really packed in

21
00:00:45,440 --> 00:00:49,120
i really want to acknowledge by the way

22
00:00:47,280 --> 00:00:52,960
before we start um

23
00:00:49,120 --> 00:00:54,959
this uh content was uh created by

24
00:00:52,960 --> 00:00:57,039
somebody in my group antonio gomez

25
00:00:54,960 --> 00:00:58,399
iglesias who did a phenomenal job doing

26
00:00:57,039 --> 00:00:58,960
the research and putting the slides

27
00:00:58,399 --> 00:01:01,120
together

28
00:00:58,960 --> 00:01:03,520
he would be here but he was given a talk

29
00:01:01,120 --> 00:01:06,000
the same weekend in washington d.c

30
00:01:03,520 --> 00:01:07,360
for a bunch of security hackers so uh

31
00:01:06,000 --> 00:01:07,760
unfortunately he couldn't be here but

32
00:01:07,360 --> 00:01:09,439
i'm

33
00:01:07,760 --> 00:01:12,240
delighted to make use of his great

34
00:01:09,439 --> 00:01:12,798
material so anyway i wanted to shout out

35
00:01:12,240 --> 00:01:14,320
to him

36
00:01:12,799 --> 00:01:15,920
and in the part and then the spirit of

37
00:01:14,320 --> 00:01:17,439
fosdem um every

38
00:01:15,920 --> 00:01:18,960
i'm going to be talking a lot about how

39
00:01:17,439 --> 00:01:20,720
uh collaborative uh

40
00:01:18,960 --> 00:01:22,479
effort uh goes into a lot of what we're

41
00:01:20,720 --> 00:01:24,240
talking about on this subject and so

42
00:01:22,479 --> 00:01:25,679
it's very much a part of how we can

43
00:01:24,240 --> 00:01:27,839
cooperate together and we're

44
00:01:25,680 --> 00:01:30,320
we're really interested in working with

45
00:01:27,840 --> 00:01:33,360
folks on this

46
00:01:30,320 --> 00:01:35,039
intel corporation pays my paycheck so

47
00:01:33,360 --> 00:01:37,119
it's important that i put this slide up

48
00:01:35,040 --> 00:01:37,520
however i want to say up front that i'm

49
00:01:37,119 --> 00:01:40,159
not

50
00:01:37,520 --> 00:01:40,960
a spokesperson for intel in no way shape

51
00:01:40,159 --> 00:01:44,320
or form

52
00:01:40,960 --> 00:01:45,839
um also uh this is the first time i've

53
00:01:44,320 --> 00:01:46,960
actually presented this material

54
00:01:45,840 --> 00:01:49,759
publicly so

55
00:01:46,960 --> 00:01:50,880
please uh uh uh hold back on the

56
00:01:49,759 --> 00:01:52,399
trolling a little bit

57
00:01:50,880 --> 00:01:54,000
i know one of my friends said she might

58
00:01:52,399 --> 00:01:56,560
be here just to troll me but

59
00:01:54,000 --> 00:01:58,320
i don't see her so maybe i'm good uh so

60
00:01:56,560 --> 00:01:59,040
the other thing i wanted to say because

61
00:01:58,320 --> 00:02:01,919
i'm not

62
00:01:59,040 --> 00:02:03,759
here speaking specifically as an intel

63
00:02:01,920 --> 00:02:06,000
spokesperson or something like that

64
00:02:03,759 --> 00:02:06,880
when i say we in the talk and when i'm

65
00:02:06,000 --> 00:02:09,199
talking about we

66
00:02:06,880 --> 00:02:11,120
it's not intel what i'm talking when i

67
00:02:09,199 --> 00:02:11,679
refer to we it's the group that i work

68
00:02:11,120 --> 00:02:13,440
in

69
00:02:11,680 --> 00:02:14,720
it's a group that works specifically on

70
00:02:13,440 --> 00:02:16,959
these areas of

71
00:02:14,720 --> 00:02:18,879
um side channels speculative execution

72
00:02:16,959 --> 00:02:21,440
side channels other sort of very

73
00:02:18,879 --> 00:02:23,120
um severe security issues or functional

74
00:02:21,440 --> 00:02:24,560
issues that we're trying to resolve so

75
00:02:23,120 --> 00:02:27,040
when i talk about we that's what i'm

76
00:02:24,560 --> 00:02:29,200
referring to all right well

77
00:02:27,040 --> 00:02:30,879
let's start uh when we uh talk about

78
00:02:29,200 --> 00:02:32,000
speculative execution side channel we

79
00:02:30,879 --> 00:02:33,840
need to talk about

80
00:02:32,000 --> 00:02:35,920
uh let's start with this barista this

81
00:02:33,840 --> 00:02:39,440
barista is a very uh

82
00:02:35,920 --> 00:02:41,119
good coffee maker he really wants to

83
00:02:39,440 --> 00:02:42,879
do a great job for his customers he

84
00:02:41,120 --> 00:02:43,440
knows as you come into the coffee shop

85
00:02:42,879 --> 00:02:46,399
at

86
00:02:43,440 --> 00:02:47,599
6 29 a.m every morning on the dot now i

87
00:02:46,400 --> 00:02:49,200
don't know about you but i'm not sure

88
00:02:47,599 --> 00:02:50,000
i'd be there at 6 29 every morning but

89
00:02:49,200 --> 00:02:51,920
every morning

90
00:02:50,000 --> 00:02:54,000
you're in there at the coffee shop and

91
00:02:51,920 --> 00:02:54,879
order kind of an unusual drink a four

92
00:02:54,000 --> 00:02:58,080
shot

93
00:02:54,879 --> 00:02:59,440
half calf cinnamon latte with

94
00:02:58,080 --> 00:03:01,280
almond milk or something like that right

95
00:02:59,440 --> 00:03:04,319
kind of unusual but 6 29

96
00:03:01,280 --> 00:03:06,319
every day and then uh so he prepares the

97
00:03:04,319 --> 00:03:08,958
drink in advance has it on the

98
00:03:06,319 --> 00:03:10,720
bar right at 6 29 and this goes

99
00:03:08,959 --> 00:03:11,440
swimmingly for a while and then one day

100
00:03:10,720 --> 00:03:13,680
you grow up

101
00:03:11,440 --> 00:03:14,879
you go to work maybe uh had too much

102
00:03:13,680 --> 00:03:17,280
beer the night before and

103
00:03:14,879 --> 00:03:18,319
don't make it to 6 29. by the way i've

104
00:03:17,280 --> 00:03:20,159
heard that there's supposed to be beer

105
00:03:18,319 --> 00:03:21,839
at fosdem i haven't heard any proof i've

106
00:03:20,159 --> 00:03:25,200
seen any proof of that so um

107
00:03:21,840 --> 00:03:25,760
you know anyway so um anyway so the

108
00:03:25,200 --> 00:03:28,560
drink

109
00:03:25,760 --> 00:03:30,079
goes away so he simply uh pours the the

110
00:03:28,560 --> 00:03:30,879
drink down the drain throws the cup in

111
00:03:30,080 --> 00:03:32,239
the trash

112
00:03:30,879 --> 00:03:34,239
but if someone's able to look in the

113
00:03:32,239 --> 00:03:36,400
trash and see the cup in there with the

114
00:03:34,239 --> 00:03:38,239
the drink uh someone might be able to

115
00:03:36,400 --> 00:03:40,159
intuit something about you

116
00:03:38,239 --> 00:03:41,599
based on the information on the cup

117
00:03:40,159 --> 00:03:43,599
right it was thrown away but

118
00:03:41,599 --> 00:03:44,879
they might be able to into something

119
00:03:43,599 --> 00:03:48,000
then about the data

120
00:03:44,879 --> 00:03:49,840
because of the metadata all right so um

121
00:03:48,000 --> 00:03:51,840
by that same sort of analogy when we're

122
00:03:49,840 --> 00:03:54,720
talking about side channels

123
00:03:51,840 --> 00:03:56,159
um it there the whole idea of side

124
00:03:54,720 --> 00:03:57,040
channels at a broad level have been

125
00:03:56,159 --> 00:04:00,319
around for

126
00:03:57,040 --> 00:04:02,640
quite a long time and they're really uh

127
00:04:00,319 --> 00:04:04,958
an intent to try to collect information

128
00:04:02,640 --> 00:04:06,079
from some other unauthorized way in the

129
00:04:04,959 --> 00:04:07,920
computer and that

130
00:04:06,080 --> 00:04:09,439
it really does target all levels of

131
00:04:07,920 --> 00:04:13,359
hardware and software

132
00:04:09,439 --> 00:04:15,760
um these uh when we talk about

133
00:04:13,360 --> 00:04:17,759
the use of power you know the amount of

134
00:04:15,760 --> 00:04:19,519
power that a computer uses varies on the

135
00:04:17,759 --> 00:04:21,120
instructions that are being run

136
00:04:19,519 --> 00:04:22,800
right if you're running more complex

137
00:04:21,120 --> 00:04:24,000
instructions the computer tends to take

138
00:04:22,800 --> 00:04:25,360
more power

139
00:04:24,000 --> 00:04:27,360
and it's been shown you can actually

140
00:04:25,360 --> 00:04:28,000
intuit what the computer is running

141
00:04:27,360 --> 00:04:31,680
based on the amount

142
00:04:28,000 --> 00:04:33,360
of power that's consumed now uh sound

143
00:04:31,680 --> 00:04:35,040
this the sound of someone typing on a

144
00:04:33,360 --> 00:04:36,880
keyboard has been shown to actually

145
00:04:35,040 --> 00:04:38,320
um be clues to help discover what

146
00:04:36,880 --> 00:04:41,520
passwords are

147
00:04:38,320 --> 00:04:43,280
uh you know the caches are various

148
00:04:41,520 --> 00:04:44,560
micro architectural features within the

149
00:04:43,280 --> 00:04:47,119
cpus that allow

150
00:04:44,560 --> 00:04:48,720
someone to to be able to perhaps just to

151
00:04:47,120 --> 00:04:49,280
determine what might be in memory and

152
00:04:48,720 --> 00:04:52,080
then

153
00:04:49,280 --> 00:04:54,080
time is how long things take if things

154
00:04:52,080 --> 00:04:55,520
take a short time or a long time

155
00:04:54,080 --> 00:04:57,919
you can determine things about what's

156
00:04:55,520 --> 00:04:59,440
running on the computer now

157
00:04:57,919 --> 00:05:01,198
i was thinking about this this morning

158
00:04:59,440 --> 00:05:02,320
in terms of power you know if you can

159
00:05:01,199 --> 00:05:03,680
figure out what's going on on the

160
00:05:02,320 --> 00:05:04,560
computer based on how much power is

161
00:05:03,680 --> 00:05:06,880
consumed maybe

162
00:05:04,560 --> 00:05:08,000
you know would we try and mitigate that

163
00:05:06,880 --> 00:05:08,639
i would i would think the answer would

164
00:05:08,000 --> 00:05:10,960
be no

165
00:05:08,639 --> 00:05:13,120
because we want to try and save power as

166
00:05:10,960 --> 00:05:14,880
much as possible right for

167
00:05:13,120 --> 00:05:16,479
social responsibility reasons if nothing

168
00:05:14,880 --> 00:05:17,840
else we want to make sure that

169
00:05:16,479 --> 00:05:19,520
we limit the amount of power that

170
00:05:17,840 --> 00:05:21,679
computers use for the sake of

171
00:05:19,520 --> 00:05:22,719
using less power and issues of climate

172
00:05:21,680 --> 00:05:26,000
change and the like

173
00:05:22,720 --> 00:05:26,479
but you know all of the oh i may have to

174
00:05:26,000 --> 00:05:28,479
drink a

175
00:05:26,479 --> 00:05:30,800
bit of water all of these side channels

176
00:05:28,479 --> 00:05:32,880
have similar characteristics that is

177
00:05:30,800 --> 00:05:35,280
that they require a set of deep system

178
00:05:32,880 --> 00:05:35,280
knowledge

179
00:05:35,680 --> 00:05:39,759
there has to be an understanding of how

180
00:05:38,320 --> 00:05:42,479
the hardware software

181
00:05:39,759 --> 00:05:44,240
is implemented it usually targets a

182
00:05:42,479 --> 00:05:47,199
particular implementation

183
00:05:44,240 --> 00:05:49,120
so if you are typing on one kind of

184
00:05:47,199 --> 00:05:50,560
keyboard and you have the acoustics

185
00:05:49,120 --> 00:05:52,800
from that situation you move to a

186
00:05:50,560 --> 00:05:54,160
different keyboard you may be unlikely

187
00:05:52,800 --> 00:05:55,600
to determine the same amount of

188
00:05:54,160 --> 00:05:57,520
information

189
00:05:55,600 --> 00:05:59,360
and typically for all of these the

190
00:05:57,520 --> 00:06:00,240
system is working as it was designed to

191
00:05:59,360 --> 00:06:01,680
work it's not

192
00:06:00,240 --> 00:06:04,000
like it's something that's that's an

193
00:06:01,680 --> 00:06:05,919
unusual uh kind of behavior if someone

194
00:06:04,000 --> 00:06:07,600
has just been able to take advantage of

195
00:06:05,919 --> 00:06:10,639
of some of these things

196
00:06:07,600 --> 00:06:13,360
now when we talk about timing attacks

197
00:06:10,639 --> 00:06:14,800
it's a particular uh class of of side

198
00:06:13,360 --> 00:06:16,639
channels where you can say well

199
00:06:14,800 --> 00:06:18,720
if something takes a longer period of

200
00:06:16,639 --> 00:06:20,479
time versus a shorter period of time

201
00:06:18,720 --> 00:06:22,000
can we determine something about what

202
00:06:20,479 --> 00:06:23,440
the computer is doing can we get a

203
00:06:22,000 --> 00:06:25,840
secret out of the computer

204
00:06:23,440 --> 00:06:29,280
based on that this uh this particular

205
00:06:25,840 --> 00:06:31,520
paper in 1996 by uh coker was a

206
00:06:29,280 --> 00:06:33,919
a pretty seminal work in this he uh

207
00:06:31,520 --> 00:06:34,880
demonstrated that you could actually uh

208
00:06:33,919 --> 00:06:38,159
determine

209
00:06:34,880 --> 00:06:40,960
um you know diffie-hellman rsa dss uh

210
00:06:38,160 --> 00:06:42,720
and other crypto keys based on timing so

211
00:06:40,960 --> 00:06:45,680
that was in 1996

212
00:06:42,720 --> 00:06:47,280
several years ago since then this area

213
00:06:45,680 --> 00:06:49,599
of timing has become a very

214
00:06:47,280 --> 00:06:50,799
rich area of research even up to last

215
00:06:49,599 --> 00:06:53,360
year people are

216
00:06:50,800 --> 00:06:54,639
using the amount of time that that

217
00:06:53,360 --> 00:06:56,720
software takes to run

218
00:06:54,639 --> 00:06:58,080
to determine things about that what the

219
00:06:56,720 --> 00:07:00,319
computer is running

220
00:06:58,080 --> 00:07:02,080
so it's important to understand that

221
00:07:00,319 --> 00:07:05,360
yeah if timing attacks are not

222
00:07:02,080 --> 00:07:08,240
a a new issue um and but

223
00:07:05,360 --> 00:07:09,759
but there's a lot of uh research uh in a

224
00:07:08,240 --> 00:07:12,560
number of different areas

225
00:07:09,759 --> 00:07:14,400
um because of this area of site of uh

226
00:07:12,560 --> 00:07:18,080
timing attacks

227
00:07:14,400 --> 00:07:18,638
so what's new january 3rd of 2018 was

228
00:07:18,080 --> 00:07:21,359
when

229
00:07:18,639 --> 00:07:22,639
uh we first got an indication of uh

230
00:07:21,360 --> 00:07:25,840
timing attacks that were taking

231
00:07:22,639 --> 00:07:28,080
advantage of speculative execution

232
00:07:25,840 --> 00:07:29,520
um what's new about these is that it's

233
00:07:28,080 --> 00:07:32,318
really a very innovative

234
00:07:29,520 --> 00:07:33,919
kind of approach to trying to to create

235
00:07:32,319 --> 00:07:36,319
side channels in this area

236
00:07:33,919 --> 00:07:38,400
um it really addresses the hardware

237
00:07:36,319 --> 00:07:40,720
software interface and so

238
00:07:38,400 --> 00:07:42,479
that was an area of attack that was new

239
00:07:40,720 --> 00:07:43,759
and again targeting speculative

240
00:07:42,479 --> 00:07:47,039
execution

241
00:07:43,759 --> 00:07:50,080
now as we think about this whole area

242
00:07:47,039 --> 00:07:50,800
notice i'm talking about pocs or proofs

243
00:07:50,080 --> 00:07:54,000
of concept

244
00:07:50,800 --> 00:07:56,080
these proves the concept um really

245
00:07:54,000 --> 00:07:58,319
are a subject of research paper

246
00:07:56,080 --> 00:07:59,919
typically if a researcher finds that

247
00:07:58,319 --> 00:08:01,120
there may be something to be used as a

248
00:07:59,919 --> 00:08:03,280
side channel there's

249
00:08:01,120 --> 00:08:05,039
usually a piece of code and it's usually

250
00:08:03,280 --> 00:08:06,159
a proof of concept as opposed to an

251
00:08:05,039 --> 00:08:08,800
actual exploit

252
00:08:06,160 --> 00:08:10,240
in fact in many cases a lot of these uh

253
00:08:08,800 --> 00:08:12,319
things that have become popular

254
00:08:10,240 --> 00:08:13,440
there's a logo created for them a cute

255
00:08:12,319 --> 00:08:15,360
name uh

256
00:08:13,440 --> 00:08:16,639
and then sometimes even a theme song

257
00:08:15,360 --> 00:08:18,160
there was one that came out in december

258
00:08:16,639 --> 00:08:19,840
that had a theme song that they they

259
00:08:18,160 --> 00:08:22,560
sang was part of the conference it was

260
00:08:19,840 --> 00:08:23,039
kind of entertaining and so the um you

261
00:08:22,560 --> 00:08:26,080
know but

262
00:08:23,039 --> 00:08:27,840
but relative to um the actual uh

263
00:08:26,080 --> 00:08:29,199
exploit there are not necessarily uh

264
00:08:27,840 --> 00:08:29,758
practical exploits that come out of

265
00:08:29,199 --> 00:08:32,479
these things

266
00:08:29,759 --> 00:08:34,000
but in every case all these are local

267
00:08:32,479 --> 00:08:36,479
methods what that means is

268
00:08:34,000 --> 00:08:38,320
um they're typically not methods that uh

269
00:08:36,479 --> 00:08:38,880
can reach across the internet or any

270
00:08:38,320 --> 00:08:41,760
kind of

271
00:08:38,880 --> 00:08:43,439
networking they don't usually involve

272
00:08:41,760 --> 00:08:44,959
privilege escalation it's not like

273
00:08:43,440 --> 00:08:47,360
somebody with unprep

274
00:08:44,959 --> 00:08:48,560
unprivileged user can get root access or

275
00:08:47,360 --> 00:08:49,519
something like that through these

276
00:08:48,560 --> 00:08:51,119
attacks

277
00:08:49,519 --> 00:08:52,880
and then typically they're only read

278
00:08:51,120 --> 00:08:55,120
only access uh

279
00:08:52,880 --> 00:08:57,200
in other words an attacker can't change

280
00:08:55,120 --> 00:08:58,000
data write data they can only read data

281
00:08:57,200 --> 00:09:00,880
so these are

282
00:08:58,000 --> 00:09:02,399
things in common now when we talk about

283
00:09:00,880 --> 00:09:05,680
speculative execution

284
00:09:02,399 --> 00:09:07,600
um i actually uh took a walk with my

285
00:09:05,680 --> 00:09:09,760
sister in 2018 it was on uh

286
00:09:07,600 --> 00:09:11,120
a 500 mile walk through spain and she's

287
00:09:09,760 --> 00:09:12,640
a non-technical person

288
00:09:11,120 --> 00:09:14,720
and she i was trying to describe this

289
00:09:12,640 --> 00:09:16,319
whole area to her and a non-typical

290
00:09:14,720 --> 00:09:18,800
person she was she thought that the

291
00:09:16,320 --> 00:09:20,160
she had the thought the term speculative

292
00:09:18,800 --> 00:09:21,760
execution was so funny

293
00:09:20,160 --> 00:09:22,880
and i said well what's funny about that

294
00:09:21,760 --> 00:09:24,720
and said well i suppose if you don't

295
00:09:22,880 --> 00:09:25,360
know what execution specula yeah okay

296
00:09:24,720 --> 00:09:27,360
sounds

297
00:09:25,360 --> 00:09:29,040
kind of funny i guess anyway she thought

298
00:09:27,360 --> 00:09:31,120
it was it was hilarious

299
00:09:29,040 --> 00:09:33,199
so um with there are a variety of

300
00:09:31,120 --> 00:09:34,720
classes of uh parallelism that are

301
00:09:33,200 --> 00:09:36,720
involved in the hardware so

302
00:09:34,720 --> 00:09:38,080
um instruction level parallelism is one

303
00:09:36,720 --> 00:09:40,800
of the oldest levels

304
00:09:38,080 --> 00:09:42,160
uh dating back i think to the 60s where

305
00:09:40,800 --> 00:09:44,079
you know typically we talk about a

306
00:09:42,160 --> 00:09:44,640
five-stage pipeline for the processor

307
00:09:44,080 --> 00:09:47,519
you

308
00:09:44,640 --> 00:09:48,560
uh uh fetch and uh decode instructions

309
00:09:47,519 --> 00:09:51,440
in the front end

310
00:09:48,560 --> 00:09:53,279
and the back end you're you're fetching

311
00:09:51,440 --> 00:09:54,800
operands doing execution and updating

312
00:09:53,279 --> 00:09:57,680
architectural state so

313
00:09:54,800 --> 00:09:59,439
the fastest uh processing you can do is

314
00:09:57,680 --> 00:10:00,719
when all those pipeline stages are

315
00:09:59,440 --> 00:10:02,240
running simultaneously

316
00:10:00,720 --> 00:10:03,600
so you're fetching instructions while

317
00:10:02,240 --> 00:10:04,880
you're and decoding instructions while

318
00:10:03,600 --> 00:10:05,920
you're updating architectural state and

319
00:10:04,880 --> 00:10:06,560
all the rest of it so you can actually

320
00:10:05,920 --> 00:10:08,800
get

321
00:10:06,560 --> 00:10:10,880
multiple instructions per clock that's

322
00:10:08,800 --> 00:10:14,479
that's sort of the goal of

323
00:10:10,880 --> 00:10:16,880
of of ilp um out of order execution on

324
00:10:14,480 --> 00:10:18,079
by contrast is where there's some sort

325
00:10:16,880 --> 00:10:19,839
of execution that's going

326
00:10:18,079 --> 00:10:21,359
on that requires some sort of operand

327
00:10:19,839 --> 00:10:24,800
that's not available perhaps

328
00:10:21,360 --> 00:10:26,320
in a register so um if the the processor

329
00:10:24,800 --> 00:10:28,319
takes advantage of this and tries to

330
00:10:26,320 --> 00:10:30,800
execute some other instructions

331
00:10:28,320 --> 00:10:32,160
that are you know after the instructions

332
00:10:30,800 --> 00:10:33,760
that it's waiting for

333
00:10:32,160 --> 00:10:35,439
understanding that architectural state

334
00:10:33,760 --> 00:10:35,920
doesn't get updated until the end when

335
00:10:35,440 --> 00:10:38,560
all the

336
00:10:35,920 --> 00:10:40,800
the the instructions retire and then

337
00:10:38,560 --> 00:10:43,119
speculative execution is that class of

338
00:10:40,800 --> 00:10:43,839
of uh parallelism where perhaps there's

339
00:10:43,120 --> 00:10:45,920
a branch

340
00:10:43,839 --> 00:10:47,440
that you have you've taken regularly or

341
00:10:45,920 --> 00:10:49,599
jump you've taken regularly

342
00:10:47,440 --> 00:10:50,480
and so the processor will attempt to

343
00:10:49,600 --> 00:10:52,320
again do

344
00:10:50,480 --> 00:10:53,680
specul will attempt to execute those

345
00:10:52,320 --> 00:10:56,079
instructions but won't

346
00:10:53,680 --> 00:10:57,120
update the actual architectural state of

347
00:10:56,079 --> 00:10:59,199
the machine

348
00:10:57,120 --> 00:11:00,720
but what's uh true of all of these

349
00:10:59,200 --> 00:11:01,360
things is there's a period of time in

350
00:11:00,720 --> 00:11:03,200
which

351
00:11:01,360 --> 00:11:05,440
the microarchitectural state will have

352
00:11:03,200 --> 00:11:07,760
been updated as sort of a side effect of

353
00:11:05,440 --> 00:11:08,959
the speculative execution and so micro

354
00:11:07,760 --> 00:11:10,880
architectural means

355
00:11:08,959 --> 00:11:12,319
typically this is very specific to a

356
00:11:10,880 --> 00:11:13,839
particular processor

357
00:11:12,320 --> 00:11:15,519
right and it's going to be different for

358
00:11:13,839 --> 00:11:16,240
every generation of the processor that's

359
00:11:15,519 --> 00:11:19,200
what makes it

360
00:11:16,240 --> 00:11:20,720
micro architectural um when it becomes

361
00:11:19,200 --> 00:11:22,320
something that is standard that's when

362
00:11:20,720 --> 00:11:23,040
it becomes architectural that's sort of

363
00:11:22,320 --> 00:11:24,800
the difference

364
00:11:23,040 --> 00:11:26,399
so this microarchitectural state is

365
00:11:24,800 --> 00:11:28,240
something that someone might be able to

366
00:11:26,399 --> 00:11:30,240
take advantage of as a result of

367
00:11:28,240 --> 00:11:31,360
some other activity that's going on in

368
00:11:30,240 --> 00:11:33,839
parallel

369
00:11:31,360 --> 00:11:34,640
so let's get specific on this and talk

370
00:11:33,839 --> 00:11:37,920
about uh

371
00:11:34,640 --> 00:11:39,519
last may of last year

372
00:11:37,920 --> 00:11:42,000
there was an issue that was made public

373
00:11:39,519 --> 00:11:43,680
called uh microarchitecture

374
00:11:42,000 --> 00:11:46,160
data sampling got to get the name right

375
00:11:43,680 --> 00:11:48,479
micro architecture data assembly or mds

376
00:11:46,160 --> 00:11:50,079
so this is an issue where um there are

377
00:11:48,480 --> 00:11:51,120
certain micro architects certain

378
00:11:50,079 --> 00:11:53,199
processors

379
00:11:51,120 --> 00:11:55,040
that have certain buffers within them

380
00:11:53,200 --> 00:11:57,120
there's the store buffer

381
00:11:55,040 --> 00:11:59,920
the fill buffer and the load port so the

382
00:11:57,120 --> 00:12:01,680
store buffer is just a piece of

383
00:11:59,920 --> 00:12:03,599
memory within the processor that this

384
00:12:01,680 --> 00:12:06,160
uses a staging area for

385
00:12:03,600 --> 00:12:08,480
stores out of registers into memory the

386
00:12:06,160 --> 00:12:10,719
fill buffer is used as a staging area in

387
00:12:08,480 --> 00:12:11,760
in reading data into registers and then

388
00:12:10,720 --> 00:12:14,639
the load port

389
00:12:11,760 --> 00:12:15,279
is used for memory and i o and so um

390
00:12:14,639 --> 00:12:18,399
what we're

391
00:12:15,279 --> 00:12:20,880
um what we're doing here is is uh

392
00:12:18,399 --> 00:12:23,120
what this issue is about is sometimes as

393
00:12:20,880 --> 00:12:24,880
operations go on on these processors

394
00:12:23,120 --> 00:12:26,320
there may be some stale data that's left

395
00:12:24,880 --> 00:12:28,399
in these buffers after

396
00:12:26,320 --> 00:12:29,839
before or after one of these operations

397
00:12:28,399 --> 00:12:32,160
and so it might be possible for a

398
00:12:29,839 --> 00:12:34,320
malicious actor to redirect this

399
00:12:32,160 --> 00:12:35,199
data to some sort of disclosure gadget

400
00:12:34,320 --> 00:12:36,880
so

401
00:12:35,200 --> 00:12:39,040
you can see here that there's a there's

402
00:12:36,880 --> 00:12:40,560
some you know data sampling going on

403
00:12:39,040 --> 00:12:41,519
with these little micro architectural

404
00:12:40,560 --> 00:12:44,719
instructions

405
00:12:41,519 --> 00:12:47,680
now in addition to this

406
00:12:44,720 --> 00:12:49,360
uh there was a uh another issue that was

407
00:12:47,680 --> 00:12:52,719
made public after may

408
00:12:49,360 --> 00:12:53,680
what was called taa or tsx asynchronous

409
00:12:52,720 --> 00:12:56,720
abort

410
00:12:53,680 --> 00:12:58,880
so this is a case where um uh

411
00:12:56,720 --> 00:13:00,000
you know there's a there's a technology

412
00:12:58,880 --> 00:13:02,240
called tsx

413
00:13:00,000 --> 00:13:04,160
it's about multi-threaded applications

414
00:13:02,240 --> 00:13:06,639
there's a technology in the

415
00:13:04,160 --> 00:13:07,360
cpu that allows you if you have software

416
00:13:06,639 --> 00:13:09,120
that has

417
00:13:07,360 --> 00:13:10,639
a multi-threaded software often you need

418
00:13:09,120 --> 00:13:12,320
some sort of locking right you'll need a

419
00:13:10,639 --> 00:13:13,440
not locking primitive so if you have a

420
00:13:12,320 --> 00:13:15,120
critical section

421
00:13:13,440 --> 00:13:17,120
you lock it so that nobody can change

422
00:13:15,120 --> 00:13:19,760
the data during that critical section

423
00:13:17,120 --> 00:13:21,360
so this technology was created in order

424
00:13:19,760 --> 00:13:24,160
to speed up software that

425
00:13:21,360 --> 00:13:25,279
typically doesn't have contented locks

426
00:13:24,160 --> 00:13:27,760
right so this is

427
00:13:25,279 --> 00:13:28,800
um this is a technology was made

428
00:13:27,760 --> 00:13:32,560
available some

429
00:13:28,800 --> 00:13:34,160
software makes use of it and

430
00:13:32,560 --> 00:13:35,839
this was a case where an attacker could

431
00:13:34,160 --> 00:13:38,160
make use of this technology

432
00:13:35,839 --> 00:13:40,320
where the attacker could use tsx and

433
00:13:38,160 --> 00:13:43,360
actually could figure out uh

434
00:13:40,320 --> 00:13:43,920
how to exploit again the same mds uh

435
00:13:43,360 --> 00:13:47,040
issue

436
00:13:43,920 --> 00:13:47,360
right so um you know typically again

437
00:13:47,040 --> 00:13:49,279
it's

438
00:13:47,360 --> 00:13:50,639
it's it's not used by all software but

439
00:13:49,279 --> 00:13:51,199
it's something that's sort of available

440
00:13:50,639 --> 00:13:53,440
that was

441
00:13:51,199 --> 00:13:55,279
was taken advantage of again these are

442
00:13:53,440 --> 00:13:58,160
these are issues that are

443
00:13:55,279 --> 00:13:59,360
very specific to certain processors but

444
00:13:58,160 --> 00:14:01,199
let me show you how

445
00:13:59,360 --> 00:14:03,199
the the threat model works on this one

446
00:14:01,199 --> 00:14:04,719
so not not my intention by the way is

447
00:14:03,199 --> 00:14:06,719
not to help you create

448
00:14:04,720 --> 00:14:08,639
um you know an exploit but help you

449
00:14:06,720 --> 00:14:11,440
understand a little bit how it works

450
00:14:08,639 --> 00:14:13,120
so let's take a cloud scenario right so

451
00:14:11,440 --> 00:14:14,959
we're running in uh maybe infrastructure

452
00:14:13,120 --> 00:14:17,920
as a service something of that sort

453
00:14:14,959 --> 00:14:19,760
um you have some code that's trying to

454
00:14:17,920 --> 00:14:21,920
leak information out and it's

455
00:14:19,760 --> 00:14:24,399
running on the system this is a a four

456
00:14:21,920 --> 00:14:26,959
core uh server in the cloud each

457
00:14:24,399 --> 00:14:27,760
core has two hyper threads so what it's

458
00:14:26,959 --> 00:14:31,920
doing is

459
00:14:27,760 --> 00:14:34,079
uh running on one of the cores so um

460
00:14:31,920 --> 00:14:35,199
the victim has to actually be on the

461
00:14:34,079 --> 00:14:37,439
other thread

462
00:14:35,199 --> 00:14:38,639
of the same core okay now in a cloud

463
00:14:37,440 --> 00:14:40,639
scenario of course

464
00:14:38,639 --> 00:14:41,760
typically those people running the cloud

465
00:14:40,639 --> 00:14:44,399
don't have an

466
00:14:41,760 --> 00:14:46,079
idea exactly where their thread is

467
00:14:44,399 --> 00:14:47,360
running versus any other threat in the

468
00:14:46,079 --> 00:14:49,359
system that's the whole idea behind

469
00:14:47,360 --> 00:14:50,959
cloud computing right

470
00:14:49,360 --> 00:14:52,880
in addition they may not even know what

471
00:14:50,959 --> 00:14:54,239
the architecture of the underlying

472
00:14:52,880 --> 00:14:56,560
processor is

473
00:14:54,240 --> 00:14:58,560
most cloud service providers try to you

474
00:14:56,560 --> 00:15:00,319
know don't necessarily like to reveal

475
00:14:58,560 --> 00:15:00,800
that information so if they schedule you

476
00:15:00,320 --> 00:15:02,399
on a

477
00:15:00,800 --> 00:15:03,920
a processor that's seven years old

478
00:15:02,399 --> 00:15:04,639
versus one that was bought yesterday

479
00:15:03,920 --> 00:15:06,240
then they can

480
00:15:04,639 --> 00:15:07,760
you know charge the same amount of money

481
00:15:06,240 --> 00:15:08,320
for it i think that's a great business

482
00:15:07,760 --> 00:15:10,000
model

483
00:15:08,320 --> 00:15:12,240
but it doesn't mean that you can you can

484
00:15:10,000 --> 00:15:14,240
never know exactly which processor you

485
00:15:12,240 --> 00:15:16,800
happen to be sitting on in a cloud

486
00:15:14,240 --> 00:15:17,680
um then what has to happen is that the

487
00:15:16,800 --> 00:15:19,839
uh

488
00:15:17,680 --> 00:15:21,680
oh by the way the the attacker has no

489
00:15:19,839 --> 00:15:23,680
control over the victim the con

490
00:15:21,680 --> 00:15:25,359
the attacker can't actually control what

491
00:15:23,680 --> 00:15:26,079
the victim is doing the victim is just

492
00:15:25,360 --> 00:15:28,240
doing what it's

493
00:15:26,079 --> 00:15:30,160
what it's doing um as part of this

494
00:15:28,240 --> 00:15:31,440
program and that victim has to bring

495
00:15:30,160 --> 00:15:33,600
data in repeatedly

496
00:15:31,440 --> 00:15:35,279
it has to happen you know more than more

497
00:15:33,600 --> 00:15:37,920
than just one access and has to have

498
00:15:35,279 --> 00:15:39,920
repeated access

499
00:15:37,920 --> 00:15:41,360
then what's required is that you know

500
00:15:39,920 --> 00:15:44,479
there's an actual small

501
00:15:41,360 --> 00:15:45,600
window of time to extract data so it's

502
00:15:44,480 --> 00:15:47,920
not something that

503
00:15:45,600 --> 00:15:50,320
can be happen instantaneously it really

504
00:15:47,920 --> 00:15:53,040
has to take place over a period of time

505
00:15:50,320 --> 00:15:54,639
but there's a a an actual small window

506
00:15:53,040 --> 00:15:55,040
to extract the data because again these

507
00:15:54,639 --> 00:15:56,639
are

508
00:15:55,040 --> 00:15:58,240
buffers that are you know being

509
00:15:56,639 --> 00:15:59,440
constantly overwritten as loads and

510
00:15:58,240 --> 00:16:01,920
stores happen

511
00:15:59,440 --> 00:16:03,519
um and then these two threads by the way

512
00:16:01,920 --> 00:16:04,000
have to share the same core for a period

513
00:16:03,519 --> 00:16:06,000
of time

514
00:16:04,000 --> 00:16:08,720
extended period of time so that the data

515
00:16:06,000 --> 00:16:10,320
sampling can take place and then finally

516
00:16:08,720 --> 00:16:12,160
after all of these requirements

517
00:16:10,320 --> 00:16:13,440
the attacker has to post process the

518
00:16:12,160 --> 00:16:15,439
data to see if you

519
00:16:13,440 --> 00:16:16,560
if it's seen enough accesses of

520
00:16:15,440 --> 00:16:18,480
something and says hmm

521
00:16:16,560 --> 00:16:20,160
maybe that's interesting right because

522
00:16:18,480 --> 00:16:21,199
again this is a data sampling attack

523
00:16:20,160 --> 00:16:23,199
this is not like

524
00:16:21,199 --> 00:16:25,439
the attacker can control where the data

525
00:16:23,199 --> 00:16:29,279
is it's just what happens to show up

526
00:16:25,440 --> 00:16:33,040
in these buffers so um after all of this

527
00:16:29,279 --> 00:16:35,040
it might seem kind of uh a weak attack

528
00:16:33,040 --> 00:16:36,719
uh for somebody to to kind of worry too

529
00:16:35,040 --> 00:16:37,360
much about this in a cloud scenario and

530
00:16:36,720 --> 00:16:39,600
in fact

531
00:16:37,360 --> 00:16:41,279
i think in a lot of circumstances it is

532
00:16:39,600 --> 00:16:42,720
difficult uh to exploit

533
00:16:41,279 --> 00:16:44,639
and why i think we have we've never

534
00:16:42,720 --> 00:16:45,040
actually seen any of these issues show

535
00:16:44,639 --> 00:16:47,920
up

536
00:16:45,040 --> 00:16:49,120
um in the wild so to speak as an exploit

537
00:16:47,920 --> 00:16:51,599
um

538
00:16:49,120 --> 00:16:52,240
now i told you i worked in a group that

539
00:16:51,600 --> 00:16:54,800
works on

540
00:16:52,240 --> 00:16:56,240
uh this sort of uh software area

541
00:16:54,800 --> 00:16:57,120
particularly open source but also

542
00:16:56,240 --> 00:16:59,360
working with uh

543
00:16:57,120 --> 00:17:00,399
the uh you know a variety of open source

544
00:16:59,360 --> 00:17:02,880
communities so

545
00:17:00,399 --> 00:17:03,519
we actually uh i did a panel discussion

546
00:17:02,880 --> 00:17:06,640
in uh

547
00:17:03,519 --> 00:17:08,880
in lyon at the uh um what do they call

548
00:17:06,640 --> 00:17:10,079
open source summit europe i think is is

549
00:17:08,880 --> 00:17:11,280
what what they're calling it and one of

550
00:17:10,079 --> 00:17:11,918
the things i did was i brought on the

551
00:17:11,280 --> 00:17:13,520
panel

552
00:17:11,919 --> 00:17:15,120
various of the organizations and

553
00:17:13,520 --> 00:17:17,679
communities we work with so

554
00:17:15,119 --> 00:17:18,799
we actually work with both the um you

555
00:17:17,679 --> 00:17:22,319
know communities like

556
00:17:18,799 --> 00:17:24,160
the linux community openbsd uh freebsd

557
00:17:22,319 --> 00:17:24,799
et cetera we're also collaborating with

558
00:17:24,160 --> 00:17:27,120
a lot of the

559
00:17:24,799 --> 00:17:28,160
uh non-open source uh proprietary

560
00:17:27,119 --> 00:17:29,840
software uh

561
00:17:28,160 --> 00:17:33,200
folks that are doing uh system software

562
00:17:29,840 --> 00:17:35,760
and vmms and things like that so um

563
00:17:33,200 --> 00:17:36,880
basically uh one of the ways to address

564
00:17:35,760 --> 00:17:40,240
this issue

565
00:17:36,880 --> 00:17:40,799
is through uh the uh through microcode

566
00:17:40,240 --> 00:17:43,919
so

567
00:17:40,799 --> 00:17:45,200
since the 90s uh folks have been not you

568
00:17:43,919 --> 00:17:47,760
know designing the

569
00:17:45,200 --> 00:17:50,000
cpu so they don't literally actually

570
00:17:47,760 --> 00:17:50,559
execute x86 instructions the circuit

571
00:17:50,000 --> 00:17:52,799
doesn't

572
00:17:50,559 --> 00:17:54,080
execute you know an ad instruction or

573
00:17:52,799 --> 00:17:56,639
what have you instead

574
00:17:54,080 --> 00:17:58,159
what it does is it translates that x86

575
00:17:56,640 --> 00:17:59,039
instruction into a sequence of micro

576
00:17:58,160 --> 00:18:01,360
operations

577
00:17:59,039 --> 00:18:02,080
and it's the microcode it's actually in

578
00:18:01,360 --> 00:18:04,159
some sort of

579
00:18:02,080 --> 00:18:05,120
uh you know some sort of space that's as

580
00:18:04,160 --> 00:18:07,440
the cpu is

581
00:18:05,120 --> 00:18:09,678
is manufactured but there's also an

582
00:18:07,440 --> 00:18:12,480
ability to update that microcode

583
00:18:09,679 --> 00:18:14,320
so in fact it's possible to update the

584
00:18:12,480 --> 00:18:16,000
way the cpu actually

585
00:18:14,320 --> 00:18:18,000
executes these instructions by changing

586
00:18:16,000 --> 00:18:19,440
the microcode and this is a powerful

587
00:18:18,000 --> 00:18:21,840
capability because

588
00:18:19,440 --> 00:18:24,080
what it allows us to do is uh in the

589
00:18:21,840 --> 00:18:25,678
field allow us to update the uh

590
00:18:24,080 --> 00:18:27,120
the very way that the processor is

591
00:18:25,679 --> 00:18:31,120
interacting with a lot of these

592
00:18:27,120 --> 00:18:33,360
these uh areas um now in addition to

593
00:18:31,120 --> 00:18:34,239
um the micro oh by the way along those

594
00:18:33,360 --> 00:18:37,199
same lines

595
00:18:34,240 --> 00:18:39,039
that is if you have a cpu the microcode

596
00:18:37,200 --> 00:18:40,080
is different from firmware from bios

597
00:18:39,039 --> 00:18:42,720
anything like that

598
00:18:40,080 --> 00:18:43,520
so what you want to try and do is is uh

599
00:18:42,720 --> 00:18:45,840
keep your

600
00:18:43,520 --> 00:18:47,200
you know bios refreshed also linux and

601
00:18:45,840 --> 00:18:48,240
various other operating systems have the

602
00:18:47,200 --> 00:18:50,559
ability to

603
00:18:48,240 --> 00:18:52,000
you know update microcode uh live so

604
00:18:50,559 --> 00:18:53,760
it's really a good idea to keep your

605
00:18:52,000 --> 00:18:55,840
micro code up to date

606
00:18:53,760 --> 00:18:57,440
um but one of the ways we're able to

607
00:18:55,840 --> 00:18:58,639
address this problem is through this

608
00:18:57,440 --> 00:19:00,240
area of microcode and

609
00:18:58,640 --> 00:19:01,840
you know we have a large instructor set

610
00:19:00,240 --> 00:19:04,080
architecture or isa

611
00:19:01,840 --> 00:19:05,600
and it's got some legacy instructions in

612
00:19:04,080 --> 00:19:07,840
it so one of the things

613
00:19:05,600 --> 00:19:09,840
um you know one of the ways to address

614
00:19:07,840 --> 00:19:11,120
this was to take a legacy instruction

615
00:19:09,840 --> 00:19:13,199
v-e-r-w

616
00:19:11,120 --> 00:19:14,959
and that instruction if you're uh

617
00:19:13,200 --> 00:19:16,480
curious what it does is it tests

618
00:19:14,960 --> 00:19:18,000
to see whether a memory segment is

619
00:19:16,480 --> 00:19:21,200
writable so

620
00:19:18,000 --> 00:19:24,320
uh we the microcode actually enhances

621
00:19:21,200 --> 00:19:26,559
the vrw instruction to flush these uh

622
00:19:24,320 --> 00:19:29,520
buffers the load buffer the store buffer

623
00:19:26,559 --> 00:19:30,480
fill buffer load buffer etc so what the

624
00:19:29,520 --> 00:19:32,160
vrw

625
00:19:30,480 --> 00:19:35,360
instruction now does with the new

626
00:19:32,160 --> 00:19:37,280
microcode will be to flush those buffers

627
00:19:35,360 --> 00:19:38,399
we also by the way define some software

628
00:19:37,280 --> 00:19:40,080
sequences if you

629
00:19:38,400 --> 00:19:41,840
if you for whatever reason can't update

630
00:19:40,080 --> 00:19:43,360
the microcode and all the software

631
00:19:41,840 --> 00:19:45,039
sequence does is do a bunch of loads and

632
00:19:43,360 --> 00:19:46,559
stores and that that effectively clears

633
00:19:45,039 --> 00:19:48,879
those buffers as well

634
00:19:46,559 --> 00:19:50,000
so then what's necessary you need to be

635
00:19:48,880 --> 00:19:52,160
able to somehow

636
00:19:50,000 --> 00:19:53,520
uh oh one other thing in the microcode

637
00:19:52,160 --> 00:19:56,720
was a uh

638
00:19:53,520 --> 00:19:58,400
uh an addition of a a model specific

639
00:19:56,720 --> 00:20:00,559
register or msr

640
00:19:58,400 --> 00:20:02,559
and these msrs are there to give you

641
00:20:00,559 --> 00:20:03,440
data about the specific processor you're

642
00:20:02,559 --> 00:20:05,440
running on

643
00:20:03,440 --> 00:20:07,679
and in this case we gave the capability

644
00:20:05,440 --> 00:20:10,080
there's a vector called uh

645
00:20:07,679 --> 00:20:11,760
i32 arc capabilities and it's a vector

646
00:20:10,080 --> 00:20:14,080
that sets bits based on

647
00:20:11,760 --> 00:20:15,360
um is this issue present or not in the

648
00:20:14,080 --> 00:20:16,879
in the cpu

649
00:20:15,360 --> 00:20:19,840
and do you have the capability of

650
00:20:16,880 --> 00:20:23,039
addressing it right so with the vrw

651
00:20:19,840 --> 00:20:23,840
enhanced uh capability and this vector

652
00:20:23,039 --> 00:20:25,760
of bits

653
00:20:23,840 --> 00:20:27,199
you're able to put together an os that

654
00:20:25,760 --> 00:20:30,080
can deal with this issue

655
00:20:27,200 --> 00:20:30,640
so um what we then did was in working

656
00:20:30,080 --> 00:20:32,799
with the

657
00:20:30,640 --> 00:20:34,159
um the linux community collaborating

658
00:20:32,799 --> 00:20:37,440
with them and various other

659
00:20:34,159 --> 00:20:39,120
folks we're actually um able to use this

660
00:20:37,440 --> 00:20:41,520
varw instruction

661
00:20:39,120 --> 00:20:42,559
every time you do a return from client

662
00:20:41,520 --> 00:20:45,039
to you or sorry

663
00:20:42,559 --> 00:20:46,158
every time you do a return for kernel to

664
00:20:45,039 --> 00:20:48,720
user space so that

665
00:20:46,159 --> 00:20:49,520
kernel user transition plus context

666
00:20:48,720 --> 00:20:51,520
switches

667
00:20:49,520 --> 00:20:52,639
what this allows us to do is to say well

668
00:20:51,520 --> 00:20:54,720
every time user code

669
00:20:52,640 --> 00:20:56,400
um you know and basically this happens

670
00:20:54,720 --> 00:20:57,280
anytime you do a system call you call

671
00:20:56,400 --> 00:20:59,200
into kernel

672
00:20:57,280 --> 00:21:01,600
every return from kernel will then call

673
00:20:59,200 --> 00:21:04,640
this verw instruction if the cpu

674
00:21:01,600 --> 00:21:06,158
is affected by this issue and will

675
00:21:04,640 --> 00:21:07,840
flush the buffer so there's no

676
00:21:06,159 --> 00:21:09,200
possibility that some user level

677
00:21:07,840 --> 00:21:10,799
attacker can somehow

678
00:21:09,200 --> 00:21:12,480
observe data that's going on in the

679
00:21:10,799 --> 00:21:14,799
chrome

680
00:21:12,480 --> 00:21:16,159
uh ring transitions yeah that's what

681
00:21:14,799 --> 00:21:18,240
that basically is

682
00:21:16,159 --> 00:21:19,280
um by the way the other thing we

683
00:21:18,240 --> 00:21:21,440
engineered was

684
00:21:19,280 --> 00:21:22,399
uh the ability to disable the

685
00:21:21,440 --> 00:21:23,840
mitigations

686
00:21:22,400 --> 00:21:25,600
right because there are some conditions

687
00:21:23,840 --> 00:21:26,720
where you might say well i don't really

688
00:21:25,600 --> 00:21:29,199
need to have this

689
00:21:26,720 --> 00:21:30,240
you know vrw calling thing i don't

690
00:21:29,200 --> 00:21:32,799
really need to

691
00:21:30,240 --> 00:21:33,520
you know slow down the ring transition

692
00:21:32,799 --> 00:21:35,120
so i can just

693
00:21:33,520 --> 00:21:36,720
disable it if i've analyzed the

694
00:21:35,120 --> 00:21:37,439
situation in fact i think this is really

695
00:21:36,720 --> 00:21:39,919
a good idea

696
00:21:37,440 --> 00:21:41,760
to say what's the situation i'm running

697
00:21:39,919 --> 00:21:43,600
in and do i even need to really run

698
00:21:41,760 --> 00:21:45,919
these mitigations or not and so

699
00:21:43,600 --> 00:21:47,918
we engineered in the ability to you know

700
00:21:45,919 --> 00:21:50,240
uh have a boot time parameters that let

701
00:21:47,919 --> 00:21:53,200
you turn these things off in linux

702
00:21:50,240 --> 00:21:54,640
um uh finally the other thing we

703
00:21:53,200 --> 00:21:58,000
engineered in was uh

704
00:21:54,640 --> 00:22:00,159
uh a uh this uh um

705
00:21:58,000 --> 00:22:01,200
interface basically user level to again

706
00:22:00,159 --> 00:22:03,600
detect whether

707
00:22:01,200 --> 00:22:04,320
the cpu is is vulnerable or not and then

708
00:22:03,600 --> 00:22:07,120
whether the

709
00:22:04,320 --> 00:22:08,960
mitigations are turned on or off um to

710
00:22:07,120 --> 00:22:11,039
make it is simple there's an open source

711
00:22:08,960 --> 00:22:13,760
project called speed47 uh called

712
00:22:11,039 --> 00:22:14,480
sorry it's speed 47 if you look in

713
00:22:13,760 --> 00:22:15,840
github

714
00:22:14,480 --> 00:22:18,480
you'll find the project it's called

715
00:22:15,840 --> 00:22:21,360
spectre meltdown checker and so

716
00:22:18,480 --> 00:22:22,159
smelts yes spectremeltdownchecker.sh and

717
00:22:21,360 --> 00:22:23,840
and it's a

718
00:22:22,159 --> 00:22:26,559
script that we've been working

719
00:22:23,840 --> 00:22:28,000
collaborating with to enhance it to

720
00:22:26,559 --> 00:22:29,600
you know with all new issues as they

721
00:22:28,000 --> 00:22:31,760
come up so you can call that and see

722
00:22:29,600 --> 00:22:36,080
whether your system is vulnerable or not

723
00:22:31,760 --> 00:22:39,280
so after all of that um we can

724
00:22:36,080 --> 00:22:41,199
also engineer in the things with uh

725
00:22:39,280 --> 00:22:43,520
taa this is similarly again i talked

726
00:22:41,200 --> 00:22:46,320
about tsx being a technology

727
00:22:43,520 --> 00:22:48,158
we actually worked with the guys working

728
00:22:46,320 --> 00:22:51,439
on the microcode to say if you want to

729
00:22:48,159 --> 00:22:53,679
even disable tsx some systems will

730
00:22:51,440 --> 00:22:55,280
actually disable tsx by default

731
00:22:53,679 --> 00:22:58,000
but there's also a control there that

732
00:22:55,280 --> 00:23:00,480
allows you to turn it on off as well

733
00:22:58,000 --> 00:23:01,280
and if you want to have tsx turned on

734
00:23:00,480 --> 00:23:04,240
you can also

735
00:23:01,280 --> 00:23:06,639
use this verw mitigation to basically

736
00:23:04,240 --> 00:23:08,400
handle it that way as well so

737
00:23:06,640 --> 00:23:10,320
as i said the work is collaborative we

738
00:23:08,400 --> 00:23:11,120
work very hard with the linux community

739
00:23:10,320 --> 00:23:13,360
and various

740
00:23:11,120 --> 00:23:14,719
um folks so that before the issue

741
00:23:13,360 --> 00:23:17,360
becomes public before this

742
00:23:14,720 --> 00:23:19,200
issue became public in in may we worked

743
00:23:17,360 --> 00:23:19,678
very hard on the patches to make sure

744
00:23:19,200 --> 00:23:22,720
that

745
00:23:19,679 --> 00:23:24,159
um on the day it became public linus

746
00:23:22,720 --> 00:23:26,559
could uh pull in the

747
00:23:24,159 --> 00:23:28,640
patches basically into linux we had back

748
00:23:26,559 --> 00:23:29,760
ports ready for the lts versions of

749
00:23:28,640 --> 00:23:31,919
linux

750
00:23:29,760 --> 00:23:33,360
and the other operating systems that are

751
00:23:31,919 --> 00:23:35,360
whether open source operating systems or

752
00:23:33,360 --> 00:23:37,520
hypervisors bare metal hypervisors

753
00:23:35,360 --> 00:23:38,879
or proprietary everybody had something

754
00:23:37,520 --> 00:23:41,760
ready on the day

755
00:23:38,880 --> 00:23:43,200
the thing became public all the software

756
00:23:41,760 --> 00:23:45,520
was ready to to fix this and the

757
00:23:43,200 --> 00:23:47,039
microcode updated

758
00:23:45,520 --> 00:23:49,039
so that gives you a little insight as to

759
00:23:47,039 --> 00:23:50,879
what we're uh you know kind of

760
00:23:49,039 --> 00:23:54,480
engineering with some of these things

761
00:23:50,880 --> 00:23:56,559
um now one of the things i think uh

762
00:23:54,480 --> 00:23:58,240
i don't think our work is over when when

763
00:23:56,559 --> 00:24:00,240
this happens there's additional

764
00:23:58,240 --> 00:24:01,279
work that we're trying to do to try and

765
00:24:00,240 --> 00:24:03,919
optimize

766
00:24:01,279 --> 00:24:04,880
uh these uh these mitigations so for

767
00:24:03,919 --> 00:24:07,440
example if you

768
00:24:04,880 --> 00:24:09,360
if you look at um that's not that threat

769
00:24:07,440 --> 00:24:10,720
model that i talked about in terms of

770
00:24:09,360 --> 00:24:12,320
you know things running on different

771
00:24:10,720 --> 00:24:13,440
threads well what if you wanted to

772
00:24:12,320 --> 00:24:16,240
actually try to

773
00:24:13,440 --> 00:24:17,600
um you know make you know fix that issue

774
00:24:16,240 --> 00:24:20,880
is there something you could do

775
00:24:17,600 --> 00:24:23,039
with the uh for example um defining

776
00:24:20,880 --> 00:24:24,640
trust domains within the cpu so a trust

777
00:24:23,039 --> 00:24:29,039
domain in this case would be

778
00:24:24,640 --> 00:24:31,760
um maybe i define it a trust domain as

779
00:24:29,039 --> 00:24:33,120
each of my cloud clients if i got

780
00:24:31,760 --> 00:24:34,080
different tenants running at the same

781
00:24:33,120 --> 00:24:36,719
time in a system

782
00:24:34,080 --> 00:24:38,320
make each tenant its own trust domain so

783
00:24:36,720 --> 00:24:39,760
each tenant would trust itself but not

784
00:24:38,320 --> 00:24:41,840
necessarily any other tenant

785
00:24:39,760 --> 00:24:43,520
or maybe i would define some other model

786
00:24:41,840 --> 00:24:45,840
for using these trust domains

787
00:24:43,520 --> 00:24:47,360
so um you know one of the things we

788
00:24:45,840 --> 00:24:48,158
worked on we're working on in this in

789
00:24:47,360 --> 00:24:50,559
the linux

790
00:24:48,159 --> 00:24:52,000
world is what we refer to as as a core

791
00:24:50,559 --> 00:24:54,080
scheduler and in fact we're

792
00:24:52,000 --> 00:24:55,919
we're doing this development in open in

793
00:24:54,080 --> 00:24:56,960
the open source you can go to lkml and

794
00:24:55,919 --> 00:24:58,720
read about this

795
00:24:56,960 --> 00:25:00,480
um we're partnering with digitalocean

796
00:24:58,720 --> 00:25:02,799
they're a cloud service provider

797
00:25:00,480 --> 00:25:04,400
and various others that are working on

798
00:25:02,799 --> 00:25:07,840
with us on this idea

799
00:25:04,400 --> 00:25:09,120
um you know and what the basic idea

800
00:25:07,840 --> 00:25:11,760
about this is if you have

801
00:25:09,120 --> 00:25:13,760
you know different uh you know processes

802
00:25:11,760 --> 00:25:15,760
they'll typically by the linux schedule

803
00:25:13,760 --> 00:25:16,960
they'll get scheduled on threads you

804
00:25:15,760 --> 00:25:18,559
know without

805
00:25:16,960 --> 00:25:20,799
really caring what the topology of the

806
00:25:18,559 --> 00:25:23,600
system is it will just look at

807
00:25:20,799 --> 00:25:24,400
at logical processors and and schedule

808
00:25:23,600 --> 00:25:26,639
processes

809
00:25:24,400 --> 00:25:27,600
on those processors but the idea of the

810
00:25:26,640 --> 00:25:29,679
course scheduler

811
00:25:27,600 --> 00:25:30,639
is if you can define trust domains you

812
00:25:29,679 --> 00:25:32,480
can actually

813
00:25:30,640 --> 00:25:33,679
it will say well if i've caught two

814
00:25:32,480 --> 00:25:36,320
different trust domains

815
00:25:33,679 --> 00:25:37,760
i'll make sure that two uh processes

816
00:25:36,320 --> 00:25:39,600
from different trust domains don't ever

817
00:25:37,760 --> 00:25:41,279
run on the same core

818
00:25:39,600 --> 00:25:42,799
right and one of the things that we're

819
00:25:41,279 --> 00:25:44,159
we're doing in this uh

820
00:25:42,799 --> 00:25:46,000
as part of our collaboration with the

821
00:25:44,159 --> 00:25:46,559
links community on this is that we're

822
00:25:46,000 --> 00:25:48,400
trying to

823
00:25:46,559 --> 00:25:49,760
do a lot of performance analysis as well

824
00:25:48,400 --> 00:25:52,240
and say you know if you're

825
00:25:49,760 --> 00:25:52,960
if you're doing this uh you know you're

826
00:25:52,240 --> 00:25:56,080
using this

827
00:25:52,960 --> 00:25:57,600
uh core scheduler um uh what we

828
00:25:56,080 --> 00:25:59,678
found the data that we found is that

829
00:25:57,600 --> 00:26:02,480
there's there's barely any

830
00:25:59,679 --> 00:26:04,159
you know ripple in the in the uh in the

831
00:26:02,480 --> 00:26:05,520
overall performance of the system

832
00:26:04,159 --> 00:26:07,679
based on a bunch of the workloads that

833
00:26:05,520 --> 00:26:10,000
we're running but that's under both low

834
00:26:07,679 --> 00:26:12,240
cont in low contention situations what

835
00:26:10,000 --> 00:26:13,919
about in high contention situations well

836
00:26:12,240 --> 00:26:15,919
you may have a situation in a high

837
00:26:13,919 --> 00:26:18,320
contention uh situation

838
00:26:15,919 --> 00:26:19,520
and we're we're running extremely uh

839
00:26:18,320 --> 00:26:21,760
high uh

840
00:26:19,520 --> 00:26:23,600
you know systems here where you know

841
00:26:21,760 --> 00:26:25,039
highly loaded systems here's a p6 that

842
00:26:23,600 --> 00:26:28,240
you can kind of see

843
00:26:25,039 --> 00:26:29,279
um under normal under the regulus linux

844
00:26:28,240 --> 00:26:31,279
scheduler

845
00:26:29,279 --> 00:26:33,279
you might have it so that really

846
00:26:31,279 --> 00:26:35,200
anything can be scheduled anywhere

847
00:26:33,279 --> 00:26:36,799
but under a core scheduler under high

848
00:26:35,200 --> 00:26:38,720
contention you kind of see well

849
00:26:36,799 --> 00:26:40,559
we weren't able to schedule p6 because

850
00:26:38,720 --> 00:26:42,880
we weren't we didn't find a processor

851
00:26:40,559 --> 00:26:44,559
that was uh you know that didn't have

852
00:26:42,880 --> 00:26:46,000
somebody from another uh trusted main

853
00:26:44,559 --> 00:26:47,918
running on that core

854
00:26:46,000 --> 00:26:49,440
so yeah in some cases for high

855
00:26:47,919 --> 00:26:51,120
contention you may have some

856
00:26:49,440 --> 00:26:52,640
you know idle threads and so it's

857
00:26:51,120 --> 00:26:54,639
possible you might actually

858
00:26:52,640 --> 00:26:55,840
take longer under those situations to

859
00:26:54,640 --> 00:26:58,159
run

860
00:26:55,840 --> 00:26:59,439
so we're doing a lot of exp we're

861
00:26:58,159 --> 00:27:01,440
publishing all this information by the

862
00:26:59,440 --> 00:27:03,840
way on lkml so i suggest

863
00:27:01,440 --> 00:27:05,200
go to the linux kernel mailing list you

864
00:27:03,840 --> 00:27:07,120
know look at the performance

865
00:27:05,200 --> 00:27:08,720
information that's been posted one of

866
00:27:07,120 --> 00:27:09,840
the engineers in the group named agata

867
00:27:08,720 --> 00:27:13,200
gruza is posting this

868
00:27:09,840 --> 00:27:15,279
uh data and uh you know um

869
00:27:13,200 --> 00:27:16,400
interact with it comment on it we're

870
00:27:15,279 --> 00:27:17,279
trying to continue to post the

871
00:27:16,400 --> 00:27:20,000
information

872
00:27:17,279 --> 00:27:20,399
i think this uh patch has a lot of uh

873
00:27:20,000 --> 00:27:21,919
pro

874
00:27:20,399 --> 00:27:24,158
a lot of promise and i think it's going

875
00:27:21,919 --> 00:27:25,679
to be uh really helpful for folks

876
00:27:24,159 --> 00:27:27,760
particularly in the cloud space or other

877
00:27:25,679 --> 00:27:28,880
spaces that really care about you know

878
00:27:27,760 --> 00:27:30,559
fixing this issue

879
00:27:28,880 --> 00:27:32,559
but by the way it's interesting that the

880
00:27:30,559 --> 00:27:33,440
other factor about the core scheduler is

881
00:27:32,559 --> 00:27:35,440
that it can be used

882
00:27:33,440 --> 00:27:36,480
actually for quality of service this is

883
00:27:35,440 --> 00:27:38,080
something that uh

884
00:27:36,480 --> 00:27:39,039
i think is an interesting side effect of

885
00:27:38,080 --> 00:27:40,720
the fact that we're adding this

886
00:27:39,039 --> 00:27:42,240
capability to segregate

887
00:27:40,720 --> 00:27:43,520
you know processors based on certain

888
00:27:42,240 --> 00:27:45,200
characteristics right it may not

889
00:27:43,520 --> 00:27:47,039
necessarily be trust domains

890
00:27:45,200 --> 00:27:49,360
one of the things uh one of the features

891
00:27:47,039 --> 00:27:51,600
in skylake is this uh

892
00:27:49,360 --> 00:27:53,039
feature called avx-512 this is the

893
00:27:51,600 --> 00:27:56,000
ability to

894
00:27:53,039 --> 00:27:57,039
have large registers that are 512-bit

895
00:27:56,000 --> 00:27:59,039
registers right

896
00:27:57,039 --> 00:28:00,720
and large vector operations that go on

897
00:27:59,039 --> 00:28:02,640
those vectors well because

898
00:28:00,720 --> 00:28:04,000
the operations tend to take up a lot of

899
00:28:02,640 --> 00:28:06,080
the the chip

900
00:28:04,000 --> 00:28:07,360
um typically the amount of power that

901
00:28:06,080 --> 00:28:10,559
could be utilized

902
00:28:07,360 --> 00:28:12,240
tends to be higher so the um the cpu

903
00:28:10,559 --> 00:28:15,039
tries to limit the total amount

904
00:28:12,240 --> 00:28:16,799
of frequency that's used on those cores

905
00:28:15,039 --> 00:28:18,240
that are running these instructions

906
00:28:16,799 --> 00:28:20,320
so you can kind of see under under

907
00:28:18,240 --> 00:28:22,799
normal scheduling you could actually

908
00:28:20,320 --> 00:28:24,799
slow down because if some of this avx

909
00:28:22,799 --> 00:28:26,399
512 is running on the as

910
00:28:24,799 --> 00:28:28,080
at the same time as a process that

911
00:28:26,399 --> 00:28:30,879
doesn't use those instructions

912
00:28:28,080 --> 00:28:32,320
it brings down the the top turbo rate so

913
00:28:30,880 --> 00:28:33,840
we have something called turbo that's

914
00:28:32,320 --> 00:28:36,080
used for frequency adjustment

915
00:28:33,840 --> 00:28:38,320
it will bring down the top turbo rate if

916
00:28:36,080 --> 00:28:39,039
you s if it sees something with avx 512

917
00:28:38,320 --> 00:28:42,080
running on it

918
00:28:39,039 --> 00:28:43,600
right so in fact by using uh

919
00:28:42,080 --> 00:28:45,360
the core scheduler what you're able to

920
00:28:43,600 --> 00:28:47,678
do is if you can

921
00:28:45,360 --> 00:28:49,520
determine that the uh process uses avx

922
00:28:47,679 --> 00:28:50,240
512 you can segregate it to its own

923
00:28:49,520 --> 00:28:52,080
cores

924
00:28:50,240 --> 00:28:53,440
and actually the runtime runs faster in

925
00:28:52,080 --> 00:28:55,439
the circumstance because

926
00:28:53,440 --> 00:28:56,799
the things that don't use avx 512 can

927
00:28:55,440 --> 00:28:59,279
turbo higher can actually

928
00:28:56,799 --> 00:28:59,840
complete sooner there's another uh

929
00:28:59,279 --> 00:29:01,440
thread

930
00:28:59,840 --> 00:29:02,639
over here by the way says bw that's

931
00:29:01,440 --> 00:29:03,360
intended to be a high bandwidth

932
00:29:02,640 --> 00:29:05,039
consuming

933
00:29:03,360 --> 00:29:07,039
uh process again same kind of thing it

934
00:29:05,039 --> 00:29:08,320
may not necessarily be avx 512 maybe

935
00:29:07,039 --> 00:29:11,520
it's using high bandwidth

936
00:29:08,320 --> 00:29:13,200
so you can use this mechanism to to

937
00:29:11,520 --> 00:29:16,320
control some of those things and

938
00:29:13,200 --> 00:29:18,880
and uh the interface uh basically uh

939
00:29:16,320 --> 00:29:20,240
it uses c groups and this is the way you

940
00:29:18,880 --> 00:29:21,520
know c groups if you're not familiar to

941
00:29:20,240 --> 00:29:24,399
linux capability to

942
00:29:21,520 --> 00:29:26,080
um that's underlying containers someone

943
00:29:24,399 --> 00:29:27,678
who is going to be trolling me here said

944
00:29:26,080 --> 00:29:29,120
if she heard anything about containers

945
00:29:27,679 --> 00:29:30,240
she was going to scream i don't she must

946
00:29:29,120 --> 00:29:30,879
not be here because i don't hear any

947
00:29:30,240 --> 00:29:32,720
screaming

948
00:29:30,880 --> 00:29:33,919
anyway it's one of the base technologies

949
00:29:32,720 --> 00:29:36,240
under containers

950
00:29:33,919 --> 00:29:37,919
and uh you know by defining the c groups

951
00:29:36,240 --> 00:29:38,720
the core scheduler will actually

952
00:29:37,919 --> 00:29:40,559
separate

953
00:29:38,720 --> 00:29:43,039
um these threads into onto different

954
00:29:40,559 --> 00:29:45,678
cores so that's the way that works

955
00:29:43,039 --> 00:29:46,320
um so that's one optimization that we're

956
00:29:45,679 --> 00:29:47,919
working on

957
00:29:46,320 --> 00:29:50,000
another one is uh well i was going to

958
00:29:47,919 --> 00:29:52,559
talk about the rendezvous

959
00:29:50,000 --> 00:29:54,640
case but in this case i'm i i'm going to

960
00:29:52,559 --> 00:29:56,799
skip this i think and talk about this

961
00:29:54,640 --> 00:29:58,480
uh idea of selective ver w based on the

962
00:29:56,799 --> 00:30:00,559
time i've got

963
00:29:58,480 --> 00:30:02,080
so i said about this verw instruction

964
00:30:00,559 --> 00:30:03,918
just to remind you the new

965
00:30:02,080 --> 00:30:05,120
microcode what it does is every time you

966
00:30:03,919 --> 00:30:07,840
call that instruction

967
00:30:05,120 --> 00:30:09,760
it clears the buffers right but in fact

968
00:30:07,840 --> 00:30:12,158
doing it every time you go from

969
00:30:09,760 --> 00:30:13,679
uh a ring ring transition i in other

970
00:30:12,159 --> 00:30:16,000
words going from kernel to user

971
00:30:13,679 --> 00:30:17,120
space maybe you don't need that right if

972
00:30:16,000 --> 00:30:17,760
you're talking about different trust

973
00:30:17,120 --> 00:30:19,520
domains

974
00:30:17,760 --> 00:30:21,039
like we did with the core scheduler

975
00:30:19,520 --> 00:30:22,399
maybe it's unnecessary to clear the

976
00:30:21,039 --> 00:30:23,679
buffers every time you're running in the

977
00:30:22,399 --> 00:30:25,360
same trust domain

978
00:30:23,679 --> 00:30:26,880
so we're actually working on something

979
00:30:25,360 --> 00:30:29,520
that's a uh um

980
00:30:26,880 --> 00:30:30,399
you know an enhancement to to this verw

981
00:30:29,520 --> 00:30:33,039
capability

982
00:30:30,399 --> 00:30:34,239
so instead of you know in this case verw

983
00:30:33,039 --> 00:30:36,399
gets called on every

984
00:30:34,240 --> 00:30:37,919
you know context switch instead if

985
00:30:36,399 --> 00:30:39,760
you're within the same trust domain

986
00:30:37,919 --> 00:30:41,520
eliminate the vw call

987
00:30:39,760 --> 00:30:43,279
and uh we think this is an optimization

988
00:30:41,520 --> 00:30:45,039
that will really help accelerate uh

989
00:30:43,279 --> 00:30:48,320
systems that are that choose to

990
00:30:45,039 --> 00:30:50,240
you know to do this mds mitigation right

991
00:30:48,320 --> 00:30:52,080
this is a patch i think we have not

992
00:30:50,240 --> 00:30:53,679
posted this yet but we're doing some

993
00:30:52,080 --> 00:30:54,960
performance investigation on it it's

994
00:30:53,679 --> 00:30:55,919
linked to the ideas in the course

995
00:30:54,960 --> 00:30:57,600
scheduler

996
00:30:55,919 --> 00:30:58,960
and uh i think one of the things we're

997
00:30:57,600 --> 00:31:00,158
trying to develop is a good trust model

998
00:30:58,960 --> 00:31:02,480
around it so we can

999
00:31:00,159 --> 00:31:04,000
you know publicly vet exactly what we

1000
00:31:02,480 --> 00:31:09,120
think is going on here what this

1001
00:31:04,000 --> 00:31:09,120
is going to address okay uh

1002
00:31:09,279 --> 00:31:14,000
all right uh okay uh the last part of

1003
00:31:12,960 --> 00:31:16,000
the talk i really wanted

1004
00:31:14,000 --> 00:31:17,120
to refer to what you can do as a

1005
00:31:16,000 --> 00:31:19,600
programmer

1006
00:31:17,120 --> 00:31:20,799
to uh actually do something about

1007
00:31:19,600 --> 00:31:22,959
speculative

1008
00:31:20,799 --> 00:31:24,240
um execution side channels and side

1009
00:31:22,960 --> 00:31:26,640
channels in general

1010
00:31:24,240 --> 00:31:28,640
you know there's a lot of uh common best

1011
00:31:26,640 --> 00:31:30,320
practices by the way i'm not a

1012
00:31:28,640 --> 00:31:32,640
security i'm not one of those people

1013
00:31:30,320 --> 00:31:34,720
who've been spending uh you know

1014
00:31:32,640 --> 00:31:35,919
20 or 30 years in security i'm not one

1015
00:31:34,720 --> 00:31:37,519
of those people coming and scare you

1016
00:31:35,919 --> 00:31:39,840
right away about security because i

1017
00:31:37,519 --> 00:31:40,799
i i it's something i've kind of grown

1018
00:31:39,840 --> 00:31:42,320
into over a

1019
00:31:40,799 --> 00:31:44,158
period of time i've actually been

1020
00:31:42,320 --> 00:31:46,559
involved in open source

1021
00:31:44,159 --> 00:31:48,240
majority of my career which is kind of

1022
00:31:46,559 --> 00:31:49,678
unusual for somebody my age

1023
00:31:48,240 --> 00:31:51,279
to be able to make that claim but anyway

1024
00:31:49,679 --> 00:31:52,000
once i'll say open source once or

1025
00:31:51,279 --> 00:31:55,039
another

1026
00:31:52,000 --> 00:31:57,120
um but there are some some uh well uh

1027
00:31:55,039 --> 00:31:59,120
understood practices i i keep hearing

1028
00:31:57,120 --> 00:31:59,760
about various of these as these issues

1029
00:31:59,120 --> 00:32:01,120
come out

1030
00:31:59,760 --> 00:32:03,120
and i think it's really important as

1031
00:32:01,120 --> 00:32:05,600
you're writing software to take a

1032
00:32:03,120 --> 00:32:06,320
very conscious thought about these

1033
00:32:05,600 --> 00:32:08,879
things

1034
00:32:06,320 --> 00:32:09,840
um probably the first and obvious ones

1035
00:32:08,880 --> 00:32:12,240
is use well

1036
00:32:09,840 --> 00:32:15,199
maintained libraries we've i've heard a

1037
00:32:12,240 --> 00:32:18,080
lot at fosdem this year about openssl

1038
00:32:15,200 --> 00:32:18,880
and openssl is a great library when uh

1039
00:32:18,080 --> 00:32:20,960
heartbleed

1040
00:32:18,880 --> 00:32:22,799
came out the community was very quick

1041
00:32:20,960 --> 00:32:23,919
about fixing that particular issue in

1042
00:32:22,799 --> 00:32:25,600
openssl

1043
00:32:23,919 --> 00:32:27,360
but if somebody had an ssl

1044
00:32:25,600 --> 00:32:29,760
implementation that was not

1045
00:32:27,360 --> 00:32:31,199
as well maintained they might be uh

1046
00:32:29,760 --> 00:32:34,000
subject to various other

1047
00:32:31,200 --> 00:32:35,600
uh issues relative to ssl so you

1048
00:32:34,000 --> 00:32:36,960
identifying library and then most

1049
00:32:35,600 --> 00:32:37,600
programmers want to use libraries right

1050
00:32:36,960 --> 00:32:39,519
we don't want to

1051
00:32:37,600 --> 00:32:42,399
have to reinvent the wheel every time

1052
00:32:39,519 --> 00:32:42,799
using a well-maintained libraries is a

1053
00:32:42,399 --> 00:32:45,039
key

1054
00:32:42,799 --> 00:32:46,639
to making uh sure that issues as they

1055
00:32:45,039 --> 00:32:49,200
come up get addressed

1056
00:32:46,640 --> 00:32:50,880
right i say automate um actually it's

1057
00:32:49,200 --> 00:32:51,679
antonio's slide he says automate but i

1058
00:32:50,880 --> 00:32:53,360
really agree

1059
00:32:51,679 --> 00:32:54,960
in this case what we're talking about is

1060
00:32:53,360 --> 00:32:57,120
if you have something that is

1061
00:32:54,960 --> 00:32:58,000
fixed you know is an issue you're aware

1062
00:32:57,120 --> 00:32:59,840
of

1063
00:32:58,000 --> 00:33:01,600
you want to automate the tests that are

1064
00:32:59,840 --> 00:33:03,600
going into making sure they remain

1065
00:33:01,600 --> 00:33:04,959
fixed right one of the worst nightmares

1066
00:33:03,600 --> 00:33:06,158
i think you could have in an open source

1067
00:33:04,960 --> 00:33:08,640
environment particular

1068
00:33:06,159 --> 00:33:09,360
is you fix some sort of security issue

1069
00:33:08,640 --> 00:33:11,919
in some

1070
00:33:09,360 --> 00:33:13,918
other contributor accidentally unfixes

1071
00:33:11,919 --> 00:33:16,159
it right and so being able to to

1072
00:33:13,919 --> 00:33:17,760
automatically test these things against

1073
00:33:16,159 --> 00:33:19,120
your upstream and against whatever

1074
00:33:17,760 --> 00:33:20,559
development is going on

1075
00:33:19,120 --> 00:33:23,039
extremely important in fact you could

1076
00:33:20,559 --> 00:33:25,760
probably break something as well

1077
00:33:23,039 --> 00:33:27,279
inadvertently right um only providing

1078
00:33:25,760 --> 00:33:30,480
necessary information

1079
00:33:27,279 --> 00:33:32,320
um if i log into a site and it uh with a

1080
00:33:30,480 --> 00:33:34,720
username password combination

1081
00:33:32,320 --> 00:33:36,158
um and it says invalid username it's

1082
00:33:34,720 --> 00:33:37,600
suddenly given an attacker

1083
00:33:36,159 --> 00:33:39,840
oh that's interesting additional

1084
00:33:37,600 --> 00:33:41,840
information if it says invalid password

1085
00:33:39,840 --> 00:33:43,840
oh the username is correct i'll just

1086
00:33:41,840 --> 00:33:46,559
keep working on the password right

1087
00:33:43,840 --> 00:33:48,320
so actually you don't need to provide so

1088
00:33:46,559 --> 00:33:50,000
much information so only providing

1089
00:33:48,320 --> 00:33:51,439
necessary information so an attacker

1090
00:33:50,000 --> 00:33:53,360
doesn't have the ability to

1091
00:33:51,440 --> 00:33:55,279
you know attack you further and then

1092
00:33:53,360 --> 00:33:57,120
including an update mechanism this is

1093
00:33:55,279 --> 00:33:59,039
incredibly important i worked a number

1094
00:33:57,120 --> 00:34:01,279
of years in the iot space

1095
00:33:59,039 --> 00:34:03,120
this is something i find incredible as a

1096
00:34:01,279 --> 00:34:06,159
lot of iot products go out

1097
00:34:03,120 --> 00:34:06,879
without ever being updated and so uh

1098
00:34:06,159 --> 00:34:08,639
malicious

1099
00:34:06,880 --> 00:34:10,560
you know and by the way every piece of

1100
00:34:08,639 --> 00:34:13,280
software yours included

1101
00:34:10,560 --> 00:34:15,279
mine every piece of software the day it

1102
00:34:13,280 --> 00:34:16,720
gets shipped has security issues in it i

1103
00:34:15,280 --> 00:34:19,919
i nearly guarantee it

1104
00:34:16,719 --> 00:34:20,480
it's it's just been waiting to be found

1105
00:34:19,918 --> 00:34:22,399
and so

1106
00:34:20,480 --> 00:34:23,918
this zero day issues what you know

1107
00:34:22,399 --> 00:34:26,159
people typically refer to that

1108
00:34:23,918 --> 00:34:27,520
means that it it stands to reason that

1109
00:34:26,159 --> 00:34:29,520
there will be an attack

1110
00:34:27,520 --> 00:34:30,560
in the future so having an update

1111
00:34:29,520 --> 00:34:32,480
mechanism now

1112
00:34:30,560 --> 00:34:34,639
that's a great engineering statement in

1113
00:34:32,480 --> 00:34:35,520
fact you need the policy to actually do

1114
00:34:34,639 --> 00:34:37,599
the updates

1115
00:34:35,520 --> 00:34:39,759
and actually you know invest in the in

1116
00:34:37,599 --> 00:34:40,079
the uh in the validation to make sure

1117
00:34:39,760 --> 00:34:41,599
that

1118
00:34:40,079 --> 00:34:43,119
your updated software doesn't corrupt

1119
00:34:41,599 --> 00:34:43,520
something else right or brick the system

1120
00:34:43,119 --> 00:34:45,359
or

1121
00:34:43,520 --> 00:34:48,079
you know fixes the issue so having an

1122
00:34:45,359 --> 00:34:51,199
update mechanism is incredibly important

1123
00:34:48,079 --> 00:34:51,679
uh so then ensuring data can't be easily

1124
00:34:51,199 --> 00:34:53,279
guessed

1125
00:34:51,679 --> 00:34:55,520
there's a variety of these i'm going to

1126
00:34:53,280 --> 00:34:58,240
actually focus on each of these uh

1127
00:34:55,520 --> 00:35:00,800
in the next couple of slides so the

1128
00:34:58,240 --> 00:35:04,240
first of these is constant timing

1129
00:35:00,800 --> 00:35:05,920
often we're found that uh uh um

1130
00:35:04,240 --> 00:35:07,759
you know what's wrong with this this

1131
00:35:05,920 --> 00:35:08,880
piece of code in terms of this is doing

1132
00:35:07,760 --> 00:35:11,599
a string compare and

1133
00:35:08,880 --> 00:35:16,000
doing something with the result any

1134
00:35:11,599 --> 00:35:17,680
problem with this

1135
00:35:16,000 --> 00:35:19,200
more characters match the longer it

1136
00:35:17,680 --> 00:35:20,560
takes exactly right so

1137
00:35:19,200 --> 00:35:21,919
thank you i wish i had a candy bar or

1138
00:35:20,560 --> 00:35:23,520
something to throw to you but i'm but

1139
00:35:21,920 --> 00:35:24,800
i'm off of sugar right now we'll throw a

1140
00:35:23,520 --> 00:35:27,920
virtual candy bar

1141
00:35:24,800 --> 00:35:28,400
um it's all the fault of the new york

1142
00:35:27,920 --> 00:35:31,920
times

1143
00:35:28,400 --> 00:35:32,880
uh so the the um so yeah exactly right

1144
00:35:31,920 --> 00:35:36,079
the stir comp

1145
00:35:32,880 --> 00:35:36,560
uh library function is optimized so that

1146
00:35:36,079 --> 00:35:38,880
when

1147
00:35:36,560 --> 00:35:39,680
uh the strings don't match it returns

1148
00:35:38,880 --> 00:35:42,720
immediately

1149
00:35:39,680 --> 00:35:43,440
right so this is a case where um you can

1150
00:35:42,720 --> 00:35:45,439
intuit

1151
00:35:43,440 --> 00:35:47,119
whether the you know things about

1152
00:35:45,440 --> 00:35:49,680
whether how much of the password

1153
00:35:47,119 --> 00:35:50,320
matches based on how long the operation

1154
00:35:49,680 --> 00:35:52,560
takes

1155
00:35:50,320 --> 00:35:53,680
so every time we hear about these issues

1156
00:35:52,560 --> 00:35:56,160
we i we here

1157
00:35:53,680 --> 00:35:58,319
use constant time programming constant

1158
00:35:56,160 --> 00:36:00,960
time programming to avoid side channels

1159
00:35:58,320 --> 00:36:01,680
now it's a bit of a challenge um because

1160
00:36:00,960 --> 00:36:04,079
uh

1161
00:36:01,680 --> 00:36:05,680
uh you know if you write your own

1162
00:36:04,079 --> 00:36:08,160
function so maybe you don't trust store

1163
00:36:05,680 --> 00:36:10,160
compensed or incomp to be constant time

1164
00:36:08,160 --> 00:36:12,480
if you write your own function though be

1165
00:36:10,160 --> 00:36:14,640
careful of your compiler um here's an

1166
00:36:12,480 --> 00:36:16,880
example of some code that

1167
00:36:14,640 --> 00:36:18,560
it's you know does it's supposed to do

1168
00:36:16,880 --> 00:36:21,760
constant time programming right

1169
00:36:18,560 --> 00:36:25,440
what it does is uh it accumulates an

1170
00:36:21,760 --> 00:36:26,079
m the uh you know the the xor of every

1171
00:36:25,440 --> 00:36:28,400
character

1172
00:36:26,079 --> 00:36:29,359
right so at some point it will be set to

1173
00:36:28,400 --> 00:36:31,280
one

1174
00:36:29,359 --> 00:36:32,880
and then but the code is scanning

1175
00:36:31,280 --> 00:36:34,640
through the entire string

1176
00:36:32,880 --> 00:36:36,000
so that it takes the same amount of time

1177
00:36:34,640 --> 00:36:36,799
whether the character whether the

1178
00:36:36,000 --> 00:36:40,160
strings

1179
00:36:36,800 --> 00:36:41,440
match or not okay so this looks you know

1180
00:36:40,160 --> 00:36:44,160
pretty good and

1181
00:36:41,440 --> 00:36:46,160
uh you know the unfortunate thing is

1182
00:36:44,160 --> 00:36:46,720
that compiler optimizations what they'll

1183
00:36:46,160 --> 00:36:49,920
do

1184
00:36:46,720 --> 00:36:53,040
is they'll say oh once m is one

1185
00:36:49,920 --> 00:36:54,960
it will never be zero right so a lot of

1186
00:36:53,040 --> 00:36:55,279
times compiler optimizations will drop

1187
00:36:54,960 --> 00:36:57,920
you

1188
00:36:55,280 --> 00:36:59,040
out of the routine immediately but as

1189
00:36:57,920 --> 00:37:01,920
soon as

1190
00:36:59,040 --> 00:37:03,759
m turns to one by the way how can you

1191
00:37:01,920 --> 00:37:04,400
figure out whether this is happening or

1192
00:37:03,760 --> 00:37:06,480
not

1193
00:37:04,400 --> 00:37:07,440
i suggest it might be good to become the

1194
00:37:06,480 --> 00:37:09,599
friend of uh

1195
00:37:07,440 --> 00:37:11,280
your friendly neighborhood disassembler

1196
00:37:09,599 --> 00:37:12,960
i mean disassembling little a little

1197
00:37:11,280 --> 00:37:13,839
routine and see what the assembler has

1198
00:37:12,960 --> 00:37:18,160
actually done

1199
00:37:13,839 --> 00:37:18,160
assembly language is not too scary

1200
00:37:18,640 --> 00:37:22,799
no but it's a it's a good way to see how

1201
00:37:20,400 --> 00:37:23,520
this works um by the way there's there's

1202
00:37:22,800 --> 00:37:25,200
one fix

1203
00:37:23,520 --> 00:37:27,040
uh that some will work for some

1204
00:37:25,200 --> 00:37:29,359
compilers was declaring

1205
00:37:27,040 --> 00:37:30,240
in this case in to be uh m to be

1206
00:37:29,359 --> 00:37:31,440
volatile

1207
00:37:30,240 --> 00:37:33,520
and that's usually a clue to the

1208
00:37:31,440 --> 00:37:34,560
compiler that oh something else i'm

1209
00:37:33,520 --> 00:37:36,400
counting on some other

1210
00:37:34,560 --> 00:37:38,560
external behavior from m so don't

1211
00:37:36,400 --> 00:37:40,880
optimize away all these loops

1212
00:37:38,560 --> 00:37:42,400
okay so that's one technique volatile

1213
00:37:40,880 --> 00:37:43,599
isn't always available in every c

1214
00:37:42,400 --> 00:37:46,320
compiler

1215
00:37:43,599 --> 00:37:46,720
um but what about python i like python

1216
00:37:46,320 --> 00:37:48,480
uh

1217
00:37:46,720 --> 00:37:50,720
if you're a pi any python programmers

1218
00:37:48,480 --> 00:37:52,800
here off you oh good

1219
00:37:50,720 --> 00:37:55,439
so if you're looking at python this is a

1220
00:37:52,800 --> 00:37:58,160
similar kind of function that's designed

1221
00:37:55,440 --> 00:37:59,280
to be constant time uh string comparison

1222
00:37:58,160 --> 00:38:01,520
in python

1223
00:37:59,280 --> 00:38:03,119
the only problem is again depending on

1224
00:38:01,520 --> 00:38:04,640
the you know of course we all know that

1225
00:38:03,119 --> 00:38:05,200
python as a language has various

1226
00:38:04,640 --> 00:38:07,680
different

1227
00:38:05,200 --> 00:38:09,040
implementations see python is is just

1228
00:38:07,680 --> 00:38:11,118
the default ones there are plenty of

1229
00:38:09,040 --> 00:38:14,000
others iron python pi pi

1230
00:38:11,119 --> 00:38:15,119
a variety of them right um in general

1231
00:38:14,000 --> 00:38:18,640
though this is again

1232
00:38:15,119 --> 00:38:19,520
not constant time so um what can you do

1233
00:38:18,640 --> 00:38:22,400
about that

1234
00:38:19,520 --> 00:38:22,800
uh it turns out since python 3.3 there

1235
00:38:22,400 --> 00:38:26,079
is

1236
00:38:22,800 --> 00:38:28,400
a constant time uh comparator uh

1237
00:38:26,079 --> 00:38:30,720
that's on the screen here and if you

1238
00:38:28,400 --> 00:38:32,720
needed an excuse to update the python 3

1239
00:38:30,720 --> 00:38:34,000
well i just gave you a great one right

1240
00:38:32,720 --> 00:38:35,359
so just yeah

1241
00:38:34,000 --> 00:38:37,280
update if you haven't already anyone

1242
00:38:35,359 --> 00:38:40,799
still on python 2

1243
00:38:37,280 --> 00:38:43,920
ah nobody awesome okay good so yeah

1244
00:38:40,800 --> 00:38:47,280
uh okay so um

1245
00:38:43,920 --> 00:38:48,240
so yeah what else can you do uh relative

1246
00:38:47,280 --> 00:38:50,400
to this whole deal

1247
00:38:48,240 --> 00:38:51,598
of uh trying to you know take care of

1248
00:38:50,400 --> 00:38:53,520
side channels one of the things you

1249
00:38:51,599 --> 00:38:55,599
could do is if you have a secret

1250
00:38:53,520 --> 00:38:56,880
a good thing to do is actually eliminate

1251
00:38:55,599 --> 00:39:00,079
the secret from memory

1252
00:38:56,880 --> 00:39:01,280
right now what's a secret i had this

1253
00:39:00,079 --> 00:39:03,760
question uh

1254
00:39:01,280 --> 00:39:04,320
posed to me actually i posted myself uh

1255
00:39:03,760 --> 00:39:05,760
uh

1256
00:39:04,320 --> 00:39:07,839
a little while ago i was like well it

1257
00:39:05,760 --> 00:39:11,359
could be a password but it could be

1258
00:39:07,839 --> 00:39:12,240
uh you know my birth date or my income

1259
00:39:11,359 --> 00:39:14,560
it could be your

1260
00:39:12,240 --> 00:39:16,160
you know your your annual income or your

1261
00:39:14,560 --> 00:39:18,078
spouse's annual income or your

1262
00:39:16,160 --> 00:39:18,480
girlfriend's annual income or whatever

1263
00:39:18,079 --> 00:39:21,200
right

1264
00:39:18,480 --> 00:39:23,119
so the idea behind this is to say uh

1265
00:39:21,200 --> 00:39:26,319
let's clear these out of memory

1266
00:39:23,119 --> 00:39:27,119
um now one of the things that uh you can

1267
00:39:26,320 --> 00:39:29,200
use is

1268
00:39:27,119 --> 00:39:30,560
memsat library routine to zero out the

1269
00:39:29,200 --> 00:39:34,240
memory uh

1270
00:39:30,560 --> 00:39:36,240
again uh at you know dash capo zero

1271
00:39:34,240 --> 00:39:38,399
no optimization the compiler will call

1272
00:39:36,240 --> 00:39:40,799
memset but even at just the first level

1273
00:39:38,400 --> 00:39:43,920
of optimization dash cap 01

1274
00:39:40,800 --> 00:39:45,520
uh the call to memsa disappears and why

1275
00:39:43,920 --> 00:39:46,560
that is again it's operating on

1276
00:39:45,520 --> 00:39:48,480
something that

1277
00:39:46,560 --> 00:39:49,759
uh the compiler says well this thing

1278
00:39:48,480 --> 00:39:51,280
isn't going to be used with the local

1279
00:39:49,760 --> 00:39:53,040
variables so i'll just eliminate the

1280
00:39:51,280 --> 00:39:56,000
call

1281
00:39:53,040 --> 00:39:57,440
so you know there's a few other options

1282
00:39:56,000 --> 00:39:59,040
mem said underscore s

1283
00:39:57,440 --> 00:40:00,960
you know can't be optimized out it's

1284
00:39:59,040 --> 00:40:03,839
part of the c11 standard

1285
00:40:00,960 --> 00:40:06,240
not every compiler has it unfortunately

1286
00:40:03,839 --> 00:40:08,078
there's also an explicit underscore b0

1287
00:40:06,240 --> 00:40:09,759
that can't be optimized out again

1288
00:40:08,079 --> 00:40:11,359
some of these options are useful to know

1289
00:40:09,760 --> 00:40:12,319
about and test whether these functions

1290
00:40:11,359 --> 00:40:14,078
are available

1291
00:40:12,319 --> 00:40:15,359
in the compiler in your source code and

1292
00:40:14,079 --> 00:40:18,560
i think that's a good

1293
00:40:15,359 --> 00:40:19,680
a good procedure one other technique i

1294
00:40:18,560 --> 00:40:22,960
think is very helpful

1295
00:40:19,680 --> 00:40:24,960
is to clear the cache you know if you

1296
00:40:22,960 --> 00:40:26,800
have a secret again whatever the secret

1297
00:40:24,960 --> 00:40:29,760
is is dependent on the software you're

1298
00:40:26,800 --> 00:40:31,520
you're writing but uh clearing the the

1299
00:40:29,760 --> 00:40:33,520
the cat the secret out of the cache may

1300
00:40:31,520 --> 00:40:35,440
be a useful thing how do you do that

1301
00:40:33,520 --> 00:40:37,200
uh x86 has a couple of useful

1302
00:40:35,440 --> 00:40:39,760
instructions uh one of them

1303
00:40:37,200 --> 00:40:40,879
is uh cl flush and the other one is co

1304
00:40:39,760 --> 00:40:43,359
flush opt

1305
00:40:40,880 --> 00:40:45,040
um and most compilers have a way to call

1306
00:40:43,359 --> 00:40:47,759
these instructions directly

1307
00:40:45,040 --> 00:40:48,240
uh and so uh this is this is a way to

1308
00:40:47,760 --> 00:40:50,160
you know

1309
00:40:48,240 --> 00:40:52,919
again get the get the system to work for

1310
00:40:50,160 --> 00:40:55,920
you to clear some of those secrets out

1311
00:40:52,920 --> 00:40:59,359
okay

1312
00:40:55,920 --> 00:41:02,640
right i think

1313
00:40:59,359 --> 00:41:05,119
okay so if i've if you remember

1314
00:41:02,640 --> 00:41:06,640
anything from today's talk i want you to

1315
00:41:05,119 --> 00:41:07,119
think about this i want you to think

1316
00:41:06,640 --> 00:41:09,920
about

1317
00:41:07,119 --> 00:41:12,000
does your system need to use um you know

1318
00:41:09,920 --> 00:41:14,160
these mitigations do you need to even

1319
00:41:12,000 --> 00:41:15,839
have the mitigations you know turned on

1320
00:41:14,160 --> 00:41:17,440
in your system at all what's the kind of

1321
00:41:15,839 --> 00:41:18,799
load running in your system if you know

1322
00:41:17,440 --> 00:41:20,079
all the software that's already running

1323
00:41:18,800 --> 00:41:22,000
on it and you can't have a malicious

1324
00:41:20,079 --> 00:41:23,520
actor running on the system i think it's

1325
00:41:22,000 --> 00:41:24,640
a good candidate for turning those

1326
00:41:23,520 --> 00:41:26,079
mitigations off

1327
00:41:24,640 --> 00:41:28,240
i think the other thing to think about

1328
00:41:26,079 --> 00:41:30,720
is if you're involved in in linux

1329
00:41:28,240 --> 00:41:31,839
uh and open source uh you know operating

1330
00:41:30,720 --> 00:41:33,680
system development

1331
00:41:31,839 --> 00:41:35,440
join with us to collaborate we're very

1332
00:41:33,680 --> 00:41:37,279
open for ideas i love to

1333
00:41:35,440 --> 00:41:38,720
you know get some uh collaboration

1334
00:41:37,280 --> 00:41:40,319
additional collaboration on some of

1335
00:41:38,720 --> 00:41:41,118
these things to help them help the

1336
00:41:40,319 --> 00:41:42,720
entire

1337
00:41:41,119 --> 00:41:44,319
right the entire community on these

1338
00:41:42,720 --> 00:41:46,720
things and if you're a programmer

1339
00:41:44,319 --> 00:41:48,000
i i highly recommend you look at some of

1340
00:41:46,720 --> 00:41:50,160
these techniques and implement

1341
00:41:48,000 --> 00:41:52,240
these techniques to make your your code

1342
00:41:50,160 --> 00:41:55,279
less sensitive to

1343
00:41:52,240 --> 00:42:02,479
to side channels so

1344
00:41:55,280 --> 00:42:04,800
thank you very much oh my

1345
00:42:02,480 --> 00:42:05,920
god kinds of questions shouldn't have

1346
00:42:04,800 --> 00:42:06,880
done that are you happy to take

1347
00:42:05,920 --> 00:42:10,000
questions

1348
00:42:06,880 --> 00:42:10,000
we've got to say five minutes

1349
00:42:10,160 --> 00:42:14,240
uh thank you very good uh talk uh you

1350
00:42:12,240 --> 00:42:14,879
talked about the mds mitigation where

1351
00:42:14,240 --> 00:42:18,000
you flush

1352
00:42:14,880 --> 00:42:20,480
the data when going to use land

1353
00:42:18,000 --> 00:42:21,520
right is that the exact part where this

1354
00:42:20,480 --> 00:42:23,520
performance loss

1355
00:42:21,520 --> 00:42:25,359
comes from or is there more going on no

1356
00:42:23,520 --> 00:42:28,640
that's it's really about

1357
00:42:25,359 --> 00:42:30,160
in in um so i think that yeah

1358
00:42:28,640 --> 00:42:32,078
if there's any performance difference

1359
00:42:30,160 --> 00:42:34,240
it'd be that vrw

1360
00:42:32,079 --> 00:42:36,079
instruction now clears these buffers

1361
00:42:34,240 --> 00:42:37,919
right so that takes additional time for

1362
00:42:36,079 --> 00:42:39,359
the circuit to clear the buffers and so

1363
00:42:37,920 --> 00:42:41,040
if there's additional time yeah that's

1364
00:42:39,359 --> 00:42:42,319
where it comes from yeah

1365
00:42:41,040 --> 00:42:44,079
and so that's why as we're talking about

1366
00:42:42,319 --> 00:42:45,759
optimizing you know having

1367
00:42:44,079 --> 00:42:47,119
oh i should repeat the question that's a

1368
00:42:45,760 --> 00:42:48,160
good that's a good problem the question

1369
00:42:47,119 --> 00:42:51,040
was for

1370
00:42:48,160 --> 00:42:52,160
mds uh yes it's this enhanced ver w

1371
00:42:51,040 --> 00:42:54,880
instruction that is

1372
00:42:52,160 --> 00:42:56,319
is takes additional time yeah thanks for

1373
00:42:54,880 --> 00:42:58,960
the reminder yes

1374
00:42:56,319 --> 00:43:00,880
yeah so lately there's been a lot of uh

1375
00:42:58,960 --> 00:43:01,359
sentiment in the security community that

1376
00:43:00,880 --> 00:43:04,079
uh

1377
00:43:01,359 --> 00:43:04,960
multi um hyper threading is a was a very

1378
00:43:04,079 --> 00:43:07,760
bad idea

1379
00:43:04,960 --> 00:43:09,359
do you agree um hyper threading again

1380
00:43:07,760 --> 00:43:12,800
from the standpoint of uh

1381
00:43:09,359 --> 00:43:14,799
mds uh oh the question is oh

1382
00:43:12,800 --> 00:43:16,400
golly can i think about what the there

1383
00:43:14,800 --> 00:43:19,440
have been people who who say

1384
00:43:16,400 --> 00:43:23,040
uh oh you know uh hyper threading is

1385
00:43:19,440 --> 00:43:24,079
is is won't you know i don't want to

1386
00:43:23,040 --> 00:43:25,839
quote what they're saying because i

1387
00:43:24,079 --> 00:43:27,200
don't agree with them so they've been

1388
00:43:25,839 --> 00:43:27,839
suggesting hyper threading is somehow

1389
00:43:27,200 --> 00:43:29,520
dangerous

1390
00:43:27,839 --> 00:43:31,759
but as one of things i went through is

1391
00:43:29,520 --> 00:43:32,560
with this threat model is help explain

1392
00:43:31,760 --> 00:43:34,400
exactly

1393
00:43:32,560 --> 00:43:36,400
what the issue is with height with hyper

1394
00:43:34,400 --> 00:43:37,520
threading all of the the steps that i

1395
00:43:36,400 --> 00:43:39,599
went through on that

1396
00:43:37,520 --> 00:43:41,520
um and even you know if you decide well

1397
00:43:39,599 --> 00:43:43,119
gee i just can't tolerate

1398
00:43:41,520 --> 00:43:44,560
you know issues that come up with hyper

1399
00:43:43,119 --> 00:43:45,680
threading you know i just don't want to

1400
00:43:44,560 --> 00:43:47,040
take the chance

1401
00:43:45,680 --> 00:43:48,720
then we're doing work with the core

1402
00:43:47,040 --> 00:43:50,160
scheduler that's going to help you know

1403
00:43:48,720 --> 00:43:52,640
eliminate even those

1404
00:43:50,160 --> 00:43:54,000
so um all the performance studies we've

1405
00:43:52,640 --> 00:43:55,920
done is that

1406
00:43:54,000 --> 00:43:57,200
um you know the core scheduler is

1407
00:43:55,920 --> 00:43:59,040
actually much better than turning off

1408
00:43:57,200 --> 00:43:59,359
hyper 30 from a performance standpoint

1409
00:43:59,040 --> 00:44:00,960
and

1410
00:43:59,359 --> 00:44:02,880
adds all the protection that's that's

1411
00:44:00,960 --> 00:44:05,040
that's really needed for this issue so

1412
00:44:02,880 --> 00:44:06,560
that's that's a lot of the focus of what

1413
00:44:05,040 --> 00:44:08,400
we're doing is making sure that

1414
00:44:06,560 --> 00:44:09,680
there are no issues with hypothermia i

1415
00:44:08,400 --> 00:44:11,200
know is anyone turning off hyper

1416
00:44:09,680 --> 00:44:13,520
threading now

1417
00:44:11,200 --> 00:44:16,078
a couple okay i know one particular

1418
00:44:13,520 --> 00:44:17,680
engineer always sitting in the back

1419
00:44:16,079 --> 00:44:19,040
i wanted to make sure that particular

1420
00:44:17,680 --> 00:44:20,720
engineer knows that he doesn't need to

1421
00:44:19,040 --> 00:44:24,160
turn off hyper threading anymore

1422
00:44:20,720 --> 00:44:25,200
in his product thank you for asking the

1423
00:44:24,160 --> 00:44:28,000
question that was awesome

1424
00:44:25,200 --> 00:44:28,640
so um another side channel is memory

1425
00:44:28,000 --> 00:44:30,319
access

1426
00:44:28,640 --> 00:44:32,319
uh and it also has other attacks like

1427
00:44:30,319 --> 00:44:33,920
like row hammer um

1428
00:44:32,319 --> 00:44:36,000
and it could actually be interesting to

1429
00:44:33,920 --> 00:44:39,440
extend trust domains into

1430
00:44:36,000 --> 00:44:41,280
memory so limited trust domain to a

1431
00:44:39,440 --> 00:44:43,520
memory channel or a dim

1432
00:44:41,280 --> 00:44:45,040
do you have any plans uh to build such a

1433
00:44:43,520 --> 00:44:47,680
thing

1434
00:44:45,040 --> 00:44:49,200
it's the first i'd ever heard of it it's

1435
00:44:47,680 --> 00:44:50,720
an interesting idea i think i'll

1436
00:44:49,200 --> 00:44:52,078
definitely be uh

1437
00:44:50,720 --> 00:44:54,319
jotting that down i think it's a really

1438
00:44:52,079 --> 00:44:56,880
interesting idea yeah

1439
00:44:54,319 --> 00:44:57,520
yes uh could you illustrate the current

1440
00:44:56,880 --> 00:44:59,599
progress

1441
00:44:57,520 --> 00:45:01,200
on uh mitigations against the recent

1442
00:44:59,599 --> 00:45:04,240
cash out attacks that

1443
00:45:01,200 --> 00:45:07,759
partially circumvent mitigations uh

1444
00:45:04,240 --> 00:45:11,040
you presented against mds

1445
00:45:07,760 --> 00:45:11,920
um so the question is the the recent

1446
00:45:11,040 --> 00:45:15,520
issue about

1447
00:45:11,920 --> 00:45:16,960
that that people were calling cash out

1448
00:45:15,520 --> 00:45:19,040
i have to think through my jet lag brain

1449
00:45:16,960 --> 00:45:22,319
about exactly what that that maps do

1450
00:45:19,040 --> 00:45:23,839
um yeah what what basically that

1451
00:45:22,319 --> 00:45:25,440
again this is one of these great names i

1452
00:45:23,839 --> 00:45:26,960
i got to think about the actual

1453
00:45:25,440 --> 00:45:28,000
technology because the name sometimes is

1454
00:45:26,960 --> 00:45:31,200
confusing to me

1455
00:45:28,000 --> 00:45:33,440
so um in this case this is

1456
00:45:31,200 --> 00:45:34,879
another as i understand that this is

1457
00:45:33,440 --> 00:45:36,560
another um

1458
00:45:34,880 --> 00:45:37,680
i may not understand this correctly so

1459
00:45:36,560 --> 00:45:39,440
take this with a grain of salt i think

1460
00:45:37,680 --> 00:45:40,879
this is another mds like attack so you

1461
00:45:39,440 --> 00:45:42,640
can use the same kind of

1462
00:45:40,880 --> 00:45:45,040
you know strategy for it but but

1463
00:45:42,640 --> 00:45:47,680
actually this is another example where

1464
00:45:45,040 --> 00:45:48,240
the microcode itself will actually uh

1465
00:45:47,680 --> 00:45:49,680
fix

1466
00:45:48,240 --> 00:45:51,279
the whole problem and so there's a

1467
00:45:49,680 --> 00:45:51,759
microcode update that will actually fix

1468
00:45:51,280 --> 00:45:55,280
these

1469
00:45:51,760 --> 00:45:56,480
entirely yeah so it's it's it's a it's a

1470
00:45:55,280 --> 00:45:58,319
different area it doesn't

1471
00:45:56,480 --> 00:46:01,520
it doesn't affect the other mitigations

1472
00:45:58,319 --> 00:46:04,880
i talked about yeah

1473
00:46:01,520 --> 00:46:08,079
yeah so a follow-up question to um

1474
00:46:04,880 --> 00:46:10,720
core scheduling what kind of cleanup

1475
00:46:08,079 --> 00:46:12,480
does it do when it hands over from the

1476
00:46:10,720 --> 00:46:14,160
core from one

1477
00:46:12,480 --> 00:46:16,000
security domain to another one so for

1478
00:46:14,160 --> 00:46:18,879
example from one guest vm to another

1479
00:46:16,000 --> 00:46:20,319
if it's about yeah um i gotta be a

1480
00:46:18,880 --> 00:46:22,000
little bit careful here because i know

1481
00:46:20,319 --> 00:46:22,400
jesse's looking at me and he's like uh

1482
00:46:22,000 --> 00:46:23,680
yeah

1483
00:46:22,400 --> 00:46:24,960
what's your answer in this one

1484
00:46:23,680 --> 00:46:25,598
unfortunately i don't know the answer

1485
00:46:24,960 --> 00:46:28,960
exactly

1486
00:46:25,599 --> 00:46:30,480
there is there's um the little i know

1487
00:46:28,960 --> 00:46:31,359
about a little knowledge is sometimes a

1488
00:46:30,480 --> 00:46:33,839
dangerous thing

1489
00:46:31,359 --> 00:46:35,440
is that um the length scheduler has a

1490
00:46:33,839 --> 00:46:36,240
placement algorithm and a load balancing

1491
00:46:35,440 --> 00:46:38,560
algorithm

1492
00:46:36,240 --> 00:46:39,359
so what's necessary is that you have to

1493
00:46:38,560 --> 00:46:41,440
you have to

1494
00:46:39,359 --> 00:46:43,440
both modify placement to say make sure

1495
00:46:41,440 --> 00:46:44,720
you're not placing things incorrectly

1496
00:46:43,440 --> 00:46:46,240
and also when you're doing load

1497
00:46:44,720 --> 00:46:48,240
balancing you don't load balance

1498
00:46:46,240 --> 00:46:52,078
incorrectly so both of them need to be

1499
00:46:48,240 --> 00:46:52,078
modified i believe is the answer

1500
00:46:54,240 --> 00:46:58,560
hi thanks for the presentation uh i have

1501
00:46:56,800 --> 00:47:00,560
a question about the trust domains

1502
00:46:58,560 --> 00:47:01,680
uh you mentioned so implemented in c

1503
00:47:00,560 --> 00:47:04,319
group apparently

1504
00:47:01,680 --> 00:47:05,440
yeah that's the idea um is the id more

1505
00:47:04,319 --> 00:47:08,400
to uh

1506
00:47:05,440 --> 00:47:11,440
like you had names like avx and blah

1507
00:47:08,400 --> 00:47:13,200
blah blah

1508
00:47:11,440 --> 00:47:14,480
was an example sorry i'm not repeating

1509
00:47:13,200 --> 00:47:16,640
the question

1510
00:47:14,480 --> 00:47:18,720
i apologize go ahead ask your question

1511
00:47:16,640 --> 00:47:21,598
yeah the question was um

1512
00:47:18,720 --> 00:47:22,720
is the idea for now to specify specify c

1513
00:47:21,599 --> 00:47:25,200
groups i mean

1514
00:47:22,720 --> 00:47:27,359
on the cpu part of c groups only the

1515
00:47:25,200 --> 00:47:30,640
subsets of the

1516
00:47:27,359 --> 00:47:32,880
instructions you wish to to use or is

1517
00:47:30,640 --> 00:47:35,040
the idea to be more generic like

1518
00:47:32,880 --> 00:47:36,000
okay this process i consider not

1519
00:47:35,040 --> 00:47:39,040
truthworthy

1520
00:47:36,000 --> 00:47:41,119
i'm i'm being uh a bit uh okay

1521
00:47:39,040 --> 00:47:42,480
and precise on purpose here i think what

1522
00:47:41,119 --> 00:47:45,520
i heard i'm having trouble

1523
00:47:42,480 --> 00:47:47,440
uh uh hearing from back here um i think

1524
00:47:45,520 --> 00:47:49,680
what i heard you ask is what's the sort

1525
00:47:47,440 --> 00:47:51,599
of policy you might use for sea groups

1526
00:47:49,680 --> 00:47:53,680
yes because it seems to delegate the

1527
00:47:51,599 --> 00:47:54,640
choice of who applies the policy to the

1528
00:47:53,680 --> 00:47:57,040
users

1529
00:47:54,640 --> 00:47:58,240
i mean sorry to the program uh owners

1530
00:47:57,040 --> 00:47:59,839
let's say yeah correct

1531
00:47:58,240 --> 00:48:01,919
and and what we're trying to do with

1532
00:47:59,839 --> 00:48:02,720
this is define mechanism as opposed to

1533
00:48:01,920 --> 00:48:05,760
policy

1534
00:48:02,720 --> 00:48:07,598
and so uh we this is kind of a common

1535
00:48:05,760 --> 00:48:08,079
design principle for unix and linux is

1536
00:48:07,599 --> 00:48:10,480
to

1537
00:48:08,079 --> 00:48:13,520
is to define mechanism and allow whoever

1538
00:48:10,480 --> 00:48:16,240
is is uh using it to define the policy

1539
00:48:13,520 --> 00:48:18,000
i would imagine a common thing to do in

1540
00:48:16,240 --> 00:48:18,640
the case of a cloud service provider for

1541
00:48:18,000 --> 00:48:21,760
example would

1542
00:48:18,640 --> 00:48:23,279
be to have every um every tenant if

1543
00:48:21,760 --> 00:48:24,400
you're in a multi-tenant infrastructure

1544
00:48:23,280 --> 00:48:26,559
as a service sort of

1545
00:48:24,400 --> 00:48:28,319
implementation is to have every tenant

1546
00:48:26,559 --> 00:48:30,559
be in its own c group and that way

1547
00:48:28,319 --> 00:48:32,079
um that's probably not a bad you know

1548
00:48:30,559 --> 00:48:35,839
strategy uh anyway

1549
00:48:32,079 --> 00:48:35,839
yeah okay makes sense thanks

1550
00:48:41,200 --> 00:48:44,799
hello thank you for the talk i was just

1551
00:48:43,359 --> 00:48:48,078
wondering personally

1552
00:48:44,800 --> 00:48:50,880
what are you doing to protect future

1553
00:48:48,079 --> 00:48:52,880
generations of cpu by design against the

1554
00:48:50,880 --> 00:48:54,160
current uh attacks currently known

1555
00:48:52,880 --> 00:48:55,680
attacks that's a great question the

1556
00:48:54,160 --> 00:48:57,920
question is what are we doing

1557
00:48:55,680 --> 00:48:59,759
uh not we in this case what is intel

1558
00:48:57,920 --> 00:49:01,520
doing because we as

1559
00:48:59,760 --> 00:49:03,440
i'm just a bunch of software so in the

1560
00:49:01,520 --> 00:49:05,280
case of what is intel doing to

1561
00:49:03,440 --> 00:49:06,559
uh you know kind of address these things

1562
00:49:05,280 --> 00:49:09,760
with future processors

1563
00:49:06,559 --> 00:49:10,800
as we um as security researchers work

1564
00:49:09,760 --> 00:49:13,440
with intel

1565
00:49:10,800 --> 00:49:15,119
um there's a a major effort to look at

1566
00:49:13,440 --> 00:49:17,040
the architecture overall

1567
00:49:15,119 --> 00:49:18,960
and to understand you know is this

1568
00:49:17,040 --> 00:49:20,240
something that that we can fix in future

1569
00:49:18,960 --> 00:49:23,599
processors and so

1570
00:49:20,240 --> 00:49:25,359
um and it's not just you know can we uh

1571
00:49:23,599 --> 00:49:26,800
use the fixes that we've done at one

1572
00:49:25,359 --> 00:49:28,799
point in time we're constantly looking

1573
00:49:26,800 --> 00:49:30,160
at ways of of optimizing uh the

1574
00:49:28,800 --> 00:49:32,559
mitigations as well so

1575
00:49:30,160 --> 00:49:34,240
that's a strong you know area of work to

1576
00:49:32,559 --> 00:49:34,800
make sure that that future processors

1577
00:49:34,240 --> 00:49:37,279
don't have

1578
00:49:34,800 --> 00:49:38,240
uh any of these issues yeah but you know

1579
00:49:37,280 --> 00:49:41,520
of course it's there's

1580
00:49:38,240 --> 00:49:41,520
it's a constant area of work

1581
00:49:41,920 --> 00:49:45,040
i think i'm out of time yeah i think

1582
00:49:43,280 --> 00:49:46,640
that time thank you for fielding so many

1583
00:49:45,040 --> 00:49:54,949
questions and for coming to talk to us

1584
00:49:46,640 --> 00:49:54,949
[Applause]

1585
00:49:56,680 --> 00:49:59,680
today

