1
00:00:14,070 --> 00:00:21,029
hello everyone I guess I can start now

2
00:00:16,800 --> 00:00:23,400
at a 1405 so my name is Chi Kang I'm a

3
00:00:21,029 --> 00:00:25,050
software engineer at Red Hat primarily

4
00:00:23,400 --> 00:00:28,348
on Mission Control and flight recorder

5
00:00:25,050 --> 00:00:30,539
and along with me he's not actually here

6
00:00:28,349 --> 00:00:33,350
is Marcus art director of engineering at

7
00:00:30,539 --> 00:00:35,850
datavac he's the lead of Mission Control

8
00:00:33,350 --> 00:00:37,680
originally we were planning to do a talk

9
00:00:35,850 --> 00:00:38,070
together but unfortunately couldn't make

10
00:00:37,680 --> 00:00:39,720
it

11
00:00:38,070 --> 00:00:43,110
however a lot of content here is

12
00:00:39,720 --> 00:00:46,980
contributed from Marcus so I've included

13
00:00:43,110 --> 00:00:49,760
him so yeah today James G and J F are

14
00:00:46,980 --> 00:00:54,029
kind of in brackets 20/20 vision

15
00:00:49,760 --> 00:00:56,220
looking ahead so on the agenda I'll just

16
00:00:54,030 --> 00:00:57,840
give a brief introduction to JMC and JFR

17
00:00:56,220 --> 00:01:00,470
what they are and I'll talk about

18
00:00:57,840 --> 00:01:03,390
development updates in the past year too

19
00:01:00,470 --> 00:01:07,100
as well as the roadmap for the coming

20
00:01:03,390 --> 00:01:11,850
year I guess and then a nice demo of

21
00:01:07,100 --> 00:01:14,609
Mission Control in the cloud so yet

22
00:01:11,850 --> 00:01:17,759
James T and J far for those of you who

23
00:01:14,609 --> 00:01:19,649
have haven't heard of it before J far is

24
00:01:17,759 --> 00:01:22,170
the JDK flight recorder it's events

25
00:01:19,649 --> 00:01:26,310
based JVM tech for production time

26
00:01:22,170 --> 00:01:28,710
profiling and diagnostics while JM c

27
00:01:26,310 --> 00:01:31,170
stands for JDK Mission Control and it's

28
00:01:28,710 --> 00:01:33,990
a desktop application for jerax browsing

29
00:01:31,170 --> 00:01:39,030
as well as JFR visualization and

30
00:01:33,990 --> 00:01:41,130
analysis so JDK flight recorder it's a

31
00:01:39,030 --> 00:01:44,310
low overhead recording its compact

32
00:01:41,130 --> 00:01:46,920
subscribing data in the JFR file format

33
00:01:44,310 --> 00:01:49,439
it's extensible and you can kind of

34
00:01:46,920 --> 00:01:52,709
think of it as analogous to a fly

35
00:01:49,439 --> 00:01:54,990
recorder in an airplane

36
00:01:52,709 --> 00:01:56,880
Mission Control again desktop

37
00:01:54,990 --> 00:02:00,600
application provides two main features

38
00:01:56,880 --> 00:02:03,208
you can connect to JVMs and browse gmx

39
00:02:00,600 --> 00:02:08,728
related data and then more importantly

40
00:02:03,209 --> 00:02:11,190
though it has a huge amount of tools for

41
00:02:08,729 --> 00:02:15,120
visualization and analysis of the flight

42
00:02:11,190 --> 00:02:17,680
recording files so JDK Mission Control

43
00:02:15,120 --> 00:02:21,069
really depends heavily

44
00:02:17,680 --> 00:02:24,189
GFI the third thing along with that

45
00:02:21,069 --> 00:02:26,858
though is JMC project does have core

46
00:02:24,189 --> 00:02:28,510
libraries for parsing and analyzing JFR

47
00:02:26,859 --> 00:02:31,780
data and they are available for

48
00:02:28,510 --> 00:02:34,179
third-party use so if you're looking at

49
00:02:31,780 --> 00:02:36,599
using JDK flight recorder and you want

50
00:02:34,180 --> 00:02:38,620
to analyze or visualize in ways that JMC

51
00:02:36,599 --> 00:02:41,108
doesn't currently have you can easily

52
00:02:38,620 --> 00:02:44,469
develop your own tools using the core

53
00:02:41,109 --> 00:02:47,170
libraries yeah so looking at the tool

54
00:02:44,469 --> 00:02:49,180
chain for flight quarter in general

55
00:02:47,170 --> 00:02:51,970
there's three main parts first is

56
00:02:49,180 --> 00:02:55,329
controlling JFR you can do that through

57
00:02:51,970 --> 00:02:58,299
CLI Poggio jmx etc so you can start and

58
00:02:55,329 --> 00:03:00,939
stop flight recordings of a JVM

59
00:02:58,299 --> 00:03:04,209
application you can ask it to be dumped

60
00:03:00,939 --> 00:03:08,379
on exit you can set the max memory size

61
00:03:04,209 --> 00:03:11,349
that JFR is going to take etc then you

62
00:03:08,379 --> 00:03:12,069
can add data to JFR so there's API for

63
00:03:11,349 --> 00:03:16,388
that

64
00:03:12,069 --> 00:03:18,730
JMC provides an agent that I'll go touch

65
00:03:16,389 --> 00:03:20,769
upon briefly for a dynamic injection of

66
00:03:18,730 --> 00:03:23,849
jeffer events and then of course you can

67
00:03:20,769 --> 00:03:26,650
have your own integrations as well so

68
00:03:23,849 --> 00:03:29,048
JFR does come with a lot of pre-built

69
00:03:26,650 --> 00:03:31,440
information inside the JVM itself but

70
00:03:29,049 --> 00:03:33,599
for an application you may have specific

71
00:03:31,440 --> 00:03:36,400
application data that you want to also

72
00:03:33,599 --> 00:03:39,488
record and you can use the flight

73
00:03:36,400 --> 00:03:42,099
recorder system that's in the JVM to do

74
00:03:39,489 --> 00:03:43,720
that and then at the end of the day of

75
00:03:42,099 --> 00:03:45,939
course the whole reason we're doing this

76
00:03:43,720 --> 00:03:48,129
is to use the data to find problems in

77
00:03:45,939 --> 00:03:50,978
our in our application to try to solve

78
00:03:48,129 --> 00:03:52,659
performance bottlenecks etc so that's

79
00:03:50,979 --> 00:03:56,229
where Mission Control comes in there's

80
00:03:52,659 --> 00:03:59,828
also a GFI utility tool that's provided

81
00:03:56,229 --> 00:04:02,319
by the JDK that you can use on command

82
00:03:59,829 --> 00:04:05,049
line and then you can also build your

83
00:04:02,319 --> 00:04:08,259
own third-party applications to analyze

84
00:04:05,049 --> 00:04:11,409
letter equipments so if we just look at

85
00:04:08,259 --> 00:04:13,540
a general workflow you run your JVM with

86
00:04:11,409 --> 00:04:17,529
JFR enabled various configuration

87
00:04:13,540 --> 00:04:19,259
options that will output a JFR file that

88
00:04:17,529 --> 00:04:21,608
you will need to store somewhere

89
00:04:19,259 --> 00:04:25,210
probably not in the production system

90
00:04:21,608 --> 00:04:27,340
and then eventually you get that jr4

91
00:04:25,210 --> 00:04:29,289
file maybe on to your local desktop and

92
00:04:27,340 --> 00:04:31,310
you analyze the data with Mission

93
00:04:29,289 --> 00:04:34,520
Control or with other tools

94
00:04:31,310 --> 00:04:38,840
so you have mini demo just quickly

95
00:04:34,520 --> 00:04:41,570
showing Mission Control in use so on the

96
00:04:38,840 --> 00:04:44,419
command line I've started Mission

97
00:04:41,570 --> 00:04:49,670
Control from the github repo targeting

98
00:04:44,420 --> 00:04:52,640
JK 11 that opens up this interface so

99
00:04:49,670 --> 00:04:54,440
it's desktop application on the left

100
00:04:52,640 --> 00:04:55,940
side we have our JVM browser so

101
00:04:54,440 --> 00:04:58,040
currently on my laptop

102
00:04:55,940 --> 00:05:00,590
the only ajv I'm running is Mission

103
00:04:58,040 --> 00:05:04,370
Control itself we open up up we can

104
00:05:00,590 --> 00:05:07,130
connect to the ambient server so this

105
00:05:04,370 --> 00:05:10,780
shows live data of various basic things

106
00:05:07,130 --> 00:05:14,000
CPU usage cheat memory etc has triggers

107
00:05:10,780 --> 00:05:16,159
so you could trigger like if CPU usage

108
00:05:14,000 --> 00:05:19,340
goes too high I want a flight recording

109
00:05:16,160 --> 00:05:20,600
dumps things like that so it's it's got

110
00:05:19,340 --> 00:05:24,409
some neat tools in there you could

111
00:05:20,600 --> 00:05:27,320
diagnose the command but of course the

112
00:05:24,410 --> 00:05:31,310
most interesting part is I think the

113
00:05:27,320 --> 00:05:33,260
flight recorder section so over here we

114
00:05:31,310 --> 00:05:35,090
can see that for Mission Control it's

115
00:05:33,260 --> 00:05:37,370
already having it already has a

116
00:05:35,090 --> 00:05:40,130
continuous recording which started as

117
00:05:37,370 --> 00:05:42,260
soon as the JVM launched so if I double

118
00:05:40,130 --> 00:05:46,100
click that I can choose to dump the last

119
00:05:42,260 --> 00:05:49,640
5 minutes for example this outputs a JFR

120
00:05:46,100 --> 00:05:52,190
file and then we get to all of the the

121
00:05:49,640 --> 00:05:56,000
tools that JMC comes with for analyzing

122
00:05:52,190 --> 00:05:57,920
that data so just to cover a few the

123
00:05:56,000 --> 00:06:00,350
automated analysis results is pretty

124
00:05:57,920 --> 00:06:02,360
neat so it will analyze all of the

125
00:06:00,350 --> 00:06:05,330
events in the JFR file and there are

126
00:06:02,360 --> 00:06:07,220
specific rules that are written to read

127
00:06:05,330 --> 00:06:10,669
specific events to try and score them

128
00:06:07,220 --> 00:06:12,050
and provide useful info and on maybe

129
00:06:10,670 --> 00:06:14,990
there's an issue here that you should

130
00:06:12,050 --> 00:06:17,180
look at it cetera so that's being

131
00:06:14,990 --> 00:06:19,760
constantly developed there's various

132
00:06:17,180 --> 00:06:21,680
pages here like the threads you can look

133
00:06:19,760 --> 00:06:25,280
at all the threads that are that we're

134
00:06:21,680 --> 00:06:27,200
running and their states over time it's

135
00:06:25,280 --> 00:06:29,330
pretty neat there's a huge amount of

136
00:06:27,200 --> 00:06:33,260
pages I won't go through all of them but

137
00:06:29,330 --> 00:06:37,640
that's basically Mission Control yeah

138
00:06:33,260 --> 00:06:41,409
demoed so development updates before I

139
00:06:37,640 --> 00:06:43,969
go into this hopefully you've all heard

140
00:06:41,410 --> 00:06:46,670
Oracle open source Mission Control and

141
00:06:43,970 --> 00:06:51,650
flight recorder about two years ago now

142
00:06:46,670 --> 00:06:53,680
I think in 2018 may ish timeline and so

143
00:06:51,650 --> 00:06:56,000
that's even the reason why I'm here

144
00:06:53,680 --> 00:07:00,260
working on Mission Control on flight

145
00:06:56,000 --> 00:07:03,890
recorder so since that time one of the

146
00:07:00,260 --> 00:07:06,770
biggest updates last 2 months ago maybe

147
00:07:03,890 --> 00:07:08,300
now I don't know what time flies is the

148
00:07:06,770 --> 00:07:11,299
jamesy project is now on github via

149
00:07:08,300 --> 00:07:14,510
SCARA so the contribution process can be

150
00:07:11,300 --> 00:07:16,100
started with a simple pull request which

151
00:07:14,510 --> 00:07:18,289
is pretty neat there's a lot of tools

152
00:07:16,100 --> 00:07:20,240
and BOTS around there too so the

153
00:07:18,290 --> 00:07:26,450
development process of Mission Control

154
00:07:20,240 --> 00:07:29,080
is very much open from the floor but

155
00:07:26,450 --> 00:07:31,729
going into actual development updates so

156
00:07:29,080 --> 00:07:36,919
Oracle did open source Mission Control

157
00:07:31,730 --> 00:07:39,830
in 2018 and then in June of 2019 which

158
00:07:36,920 --> 00:07:44,590
is now last year the very first open

159
00:07:39,830 --> 00:07:48,530
source release of JMC was tagged 7.0 and

160
00:07:44,590 --> 00:07:51,200
then following that in December which is

161
00:07:48,530 --> 00:07:56,900
last month or 2 months ago it's February

162
00:07:51,200 --> 00:07:58,520
now 7.1 data was tagged so if anyone's

163
00:07:56,900 --> 00:08:01,460
wondering what happened to Mission

164
00:07:58,520 --> 00:08:04,099
Control after open surah Oracle open

165
00:08:01,460 --> 00:08:06,229
source it it is continue it is it does

166
00:08:04,100 --> 00:08:08,840
have an active community we are

167
00:08:06,230 --> 00:08:11,720
developing new features for it and are

168
00:08:08,840 --> 00:08:14,570
looking to improve it in into the future

169
00:08:11,720 --> 00:08:17,420
as well so some of the features in 7.1

170
00:08:14,570 --> 00:08:20,030
doto are more optimizations of the rules

171
00:08:17,420 --> 00:08:22,130
so the automated analysis that I showed

172
00:08:20,030 --> 00:08:24,260
a little earlier it does have some

173
00:08:22,130 --> 00:08:26,060
issues when dealing with multiple

174
00:08:24,260 --> 00:08:29,840
gigabyte sized

175
00:08:26,060 --> 00:08:32,059
JFR files trying to get to analyze all

176
00:08:29,840 --> 00:08:34,970
the events etc like that so that's an

177
00:08:32,059 --> 00:08:38,390
ongoing thing actually the J overflow of

178
00:08:34,970 --> 00:08:40,670
you so there is a view that JMC comes

179
00:08:38,390 --> 00:08:44,090
with for heap dump analysis that's

180
00:08:40,669 --> 00:08:47,390
converted from using Java effects to SWT

181
00:08:44,090 --> 00:08:48,080
now so you no longer need to also have

182
00:08:47,390 --> 00:08:50,390
Java

183
00:08:48,080 --> 00:08:52,340
tax on your system to use that and then

184
00:08:50,390 --> 00:08:56,060
we also have two new views on the flame

185
00:08:52,340 --> 00:09:00,170
graph which is pretty cool actually and

186
00:08:56,060 --> 00:09:01,819
then each chart histogram so yeah of

187
00:09:00,170 --> 00:09:03,589
course there's a huge number of bug

188
00:09:01,820 --> 00:09:07,040
fixes and stuff like that as you'll see

189
00:09:03,590 --> 00:09:09,260
um just to try it oh I just realized I

190
00:09:07,040 --> 00:09:12,920
probably should a click present so it's

191
00:09:09,260 --> 00:09:15,189
full screen but anyways so a project

192
00:09:12,920 --> 00:09:19,900
commits since the initial open-sourcing

193
00:09:15,190 --> 00:09:25,130
to 7.0 they were actually 128 commits

194
00:09:19,900 --> 00:09:29,240
7.0 to 7.1 399 and the github project

195
00:09:25,130 --> 00:09:32,720
itself when I created this slide had 238

196
00:09:29,240 --> 00:09:35,240
commits so it's definitely actively

197
00:09:32,720 --> 00:09:38,890
being worked on and there's a lot of

198
00:09:35,240 --> 00:09:42,430
features we want we want to add as well

199
00:09:38,890 --> 00:09:46,160
distribution wise adopt open JDK has

200
00:09:42,430 --> 00:09:48,709
provided binaries for download actually

201
00:09:46,160 --> 00:09:51,740
for the time being these are snapshot

202
00:09:48,710 --> 00:09:55,850
versions so the latest in the repository

203
00:09:51,740 --> 00:09:58,150
and I have heard from the developers

204
00:09:55,850 --> 00:10:00,700
there that they are going to do release

205
00:09:58,150 --> 00:10:03,709
binaries as well in the future

206
00:10:00,700 --> 00:10:07,510
Oracle of course does have binaries as

207
00:10:03,710 --> 00:10:09,530
well as long as it clips update site

208
00:10:07,510 --> 00:10:12,530
unfortunately they have yet to do the

209
00:10:09,530 --> 00:10:14,420
7.1 dot or release but hopefully you'll

210
00:10:12,530 --> 00:10:16,880
see that into the next few months and

211
00:10:14,420 --> 00:10:20,060
then Red Hat has rpms for fedora and rel

212
00:10:16,880 --> 00:10:23,360
so if you are using for Doral you can

213
00:10:20,060 --> 00:10:24,800
DNF where young install those yeah and

214
00:10:23,360 --> 00:10:27,410
then there are a few other distributions

215
00:10:24,800 --> 00:10:29,900
like Azul has their mission control but

216
00:10:27,410 --> 00:10:34,640
basically they're at the moment all the

217
00:10:29,900 --> 00:10:36,860
same which i think is good yeah so a

218
00:10:34,640 --> 00:10:39,319
quick slide on contributing the

219
00:10:36,860 --> 00:10:42,080
repository is on github there's a

220
00:10:39,320 --> 00:10:44,840
mailing list we have slack which is

221
00:10:42,080 --> 00:10:48,650
pretty active then our bug tracker is

222
00:10:44,840 --> 00:10:53,210
the the JDK open JDK JIRA instance and

223
00:10:48,650 --> 00:10:55,250
as well a little plug for Marcus's JMC

224
00:10:53,210 --> 00:10:58,130
tutorial if you are looking to learn how

225
00:10:55,250 --> 00:11:01,139
to use JMC to analyze various problems

226
00:10:58,130 --> 00:11:04,230
Marcus did procreate

227
00:11:01,139 --> 00:11:08,730
a quite decent set of problems like

228
00:11:04,230 --> 00:11:12,689
dealing with memory leaks or hot methods

229
00:11:08,730 --> 00:11:15,569
etc and how you would see that using JFR

230
00:11:12,689 --> 00:11:15,779
and using GMC so you can always try that

231
00:11:15,569 --> 00:11:18,358
out

232
00:11:15,779 --> 00:11:23,100
so yeah moving on to the road map what's

233
00:11:18,359 --> 00:11:25,290
up in the future before I talk about J

234
00:11:23,100 --> 00:11:28,049
and C's road map there is one thing I do

235
00:11:25,290 --> 00:11:31,679
want to share regarding JFR and so

236
00:11:28,049 --> 00:11:36,059
Arkell did open-source GFR and JMC for

237
00:11:31,679 --> 00:11:38,970
open JDK 11 plus but the community it

238
00:11:36,059 --> 00:11:41,910
has worked on putting GFR into open JDK

239
00:11:38,970 --> 00:11:44,970
8 and so the CSR was finalized and

240
00:11:41,910 --> 00:11:47,269
closed in December the remaining to do

241
00:11:44,970 --> 00:11:50,459
is just to merge it into mainline and

242
00:11:47,269 --> 00:11:55,350
Mario actually started the thread for

243
00:11:50,459 --> 00:11:58,049
that in January a week ago maybe so yeah

244
00:11:55,350 --> 00:12:01,790
once that's accepted we're gonna see JFR

245
00:11:58,049 --> 00:12:05,009
in open JDK 8 which will be awesome so

246
00:12:01,790 --> 00:12:08,610
yeah back to JMC though the road map is

247
00:12:05,009 --> 00:12:12,449
Mission Control 8 so this is our early

248
00:12:08,610 --> 00:12:14,910
access splash screen but it's going to

249
00:12:12,449 --> 00:12:17,399
be a major release so there will be

250
00:12:14,910 --> 00:12:20,309
breaking changes if anyone uses the core

251
00:12:17,399 --> 00:12:25,799
API for example and it's going to target

252
00:12:20,309 --> 00:12:29,160
open JDK 15 so 15 releases if there's no

253
00:12:25,799 --> 00:12:32,309
delays in September 2020 and so you will

254
00:12:29,160 --> 00:12:35,189
see JMC 8 a few months afterwards as we

255
00:12:32,309 --> 00:12:39,029
make sure that it actually works on open

256
00:12:35,189 --> 00:12:43,410
JDK 15 so what are what's what are we

257
00:12:39,029 --> 00:12:46,769
adding to 8/3 keep things here James C

258
00:12:43,410 --> 00:12:48,689
agent rules update and then core library

259
00:12:46,769 --> 00:12:52,919
updates I'll go into each of these

260
00:12:48,689 --> 00:12:56,099
so the JMC agent is actually a quite

261
00:12:52,919 --> 00:12:59,759
neat tool it's for dynamic insertion of

262
00:12:56,100 --> 00:13:02,669
JRR events at runtime so as I said

263
00:12:59,759 --> 00:13:04,919
earlier you can extend your own events

264
00:13:02,669 --> 00:13:07,589
into the JFR system but that does

265
00:13:04,919 --> 00:13:09,899
requires like writing annotations etc in

266
00:13:07,589 --> 00:13:14,549
the code and then obviously recompiling

267
00:13:09,899 --> 00:13:15,000
redeploying so the of course you can do

268
00:13:14,549 --> 00:13:17,699
bike

269
00:13:15,000 --> 00:13:19,950
instrumentation with other tools to do

270
00:13:17,700 --> 00:13:23,550
this as well but the JMC agent will be

271
00:13:19,950 --> 00:13:26,190
designed ground up for insertion of GFR

272
00:13:23,550 --> 00:13:28,199
events at runtime so if you wanted to

273
00:13:26,190 --> 00:13:30,150
modify your application without having

274
00:13:28,200 --> 00:13:33,690
to rewrite the code we recompile

275
00:13:30,150 --> 00:13:39,209
redeploy you can do that it's optimized

276
00:13:33,690 --> 00:13:41,790
for the job so hopefully we will see

277
00:13:39,210 --> 00:13:45,090
that as part of the JMC distribution in

278
00:13:41,790 --> 00:13:47,069
a thought oh yeah and technically the

279
00:13:45,090 --> 00:13:49,890
code is already in upstream repository

280
00:13:47,070 --> 00:13:52,050
and it's being developed on there so if

281
00:13:49,890 --> 00:13:55,590
if you are interested there are a lot of

282
00:13:52,050 --> 00:13:56,400
open issues for that too and then rules

283
00:13:55,590 --> 00:13:58,890
2.0

284
00:13:56,400 --> 00:14:01,530
again mainly the automated analysis

285
00:13:58,890 --> 00:14:03,390
section there's going to be improvements

286
00:14:01,530 --> 00:14:05,220
for performance there's going to be a

287
00:14:03,390 --> 00:14:09,540
redesign of the rules in general so that

288
00:14:05,220 --> 00:14:12,840
they can be reused the idea from the

289
00:14:09,540 --> 00:14:15,689
developer was like you could use rule

290
00:14:12,840 --> 00:14:19,010
rule a results and rule B and those can

291
00:14:15,690 --> 00:14:21,810
be used in rule C etc and build up rules

292
00:14:19,010 --> 00:14:23,850
in a more organized fashion than than

293
00:14:21,810 --> 00:14:25,979
what they are now and there'll be more

294
00:14:23,850 --> 00:14:28,530
typed information in the rule itself so

295
00:14:25,980 --> 00:14:31,800
that you we can more easily visualize

296
00:14:28,530 --> 00:14:33,689
the rule results and then for whatever

297
00:14:31,800 --> 00:14:35,670
reason some of them have HTML and

298
00:14:33,690 --> 00:14:38,790
they're not gonna have that in the

299
00:14:35,670 --> 00:14:42,930
future and then going into the core API

300
00:14:38,790 --> 00:14:45,110
so this is the API that JMC also

301
00:14:42,930 --> 00:14:49,250
provides to third-party applications

302
00:14:45,110 --> 00:14:51,600
mainly to do with reading in JFR files

303
00:14:49,250 --> 00:14:55,670
managing the flight recorder system of

304
00:14:51,600 --> 00:14:58,110
JVMs or discovering jaebeum's in general

305
00:14:55,670 --> 00:15:00,439
so a lot of these features are extremely

306
00:14:58,110 --> 00:15:03,900
useful for third-party applications and

307
00:15:00,440 --> 00:15:06,270
and JMC 8 we're going to be updating it

308
00:15:03,900 --> 00:15:08,790
to use JDK 8 language features and

309
00:15:06,270 --> 00:15:13,290
previously it was 7 so this isn't to do

310
00:15:08,790 --> 00:15:16,219
with compatibility between JFR and your

311
00:15:13,290 --> 00:15:20,640
open JDK version this is just the actual

312
00:15:16,220 --> 00:15:22,620
code of the API will compile on 8 plus

313
00:15:20,640 --> 00:15:25,939
and run on 8 plus because we're going to

314
00:15:22,620 --> 00:15:27,889
be using JDK 8 language features and

315
00:15:25,940 --> 00:15:29,899
more thing

316
00:15:27,889 --> 00:15:32,989
from the application will be moved into

317
00:15:29,899 --> 00:15:37,149
core to be reused by third-party

318
00:15:32,989 --> 00:15:37,149
applications because they are useful

319
00:15:37,839 --> 00:15:42,920
yeah and so some more features in terms

320
00:15:40,429 --> 00:15:44,509
of I guess the visual aspect of JMC

321
00:15:42,920 --> 00:15:46,639
we're gonna have new sectors

322
00:15:44,509 --> 00:15:49,369
visualizations we're gonna have

323
00:15:46,639 --> 00:15:52,040
improvements to the thread graph the

324
00:15:49,369 --> 00:15:53,809
flame graph is already being updated as

325
00:15:52,040 --> 00:15:55,910
we speak but there's gonna be a large

326
00:15:53,809 --> 00:15:59,059
amount of improvements there and then

327
00:15:55,910 --> 00:16:01,029
this is something Marcus has like a

328
00:15:59,059 --> 00:16:03,290
prototype for on his own repo but

329
00:16:01,029 --> 00:16:05,929
visualizations of stack traces with

330
00:16:03,290 --> 00:16:08,509
various graphing tools so the image is

331
00:16:05,929 --> 00:16:13,569
just an example of method profile events

332
00:16:08,509 --> 00:16:16,489
in a graph format so yeah moving on to

333
00:16:13,569 --> 00:16:20,689
the demo portion JFR management in

334
00:16:16,489 --> 00:16:23,839
openshift with container JFR so before i

335
00:16:20,689 --> 00:16:26,179
jump into the demo i do want to give a

336
00:16:23,839 --> 00:16:28,489
little bit of context so this is like a

337
00:16:26,179 --> 00:16:30,619
huge diagram explaining how the demo is

338
00:16:28,489 --> 00:16:33,829
set up and what's going on which i will

339
00:16:30,619 --> 00:16:37,040
show again but the basis behind this is

340
00:16:33,829 --> 00:16:39,679
this new project called container JFR

341
00:16:37,040 --> 00:16:41,899
that my team's been working on it's

342
00:16:39,679 --> 00:16:44,269
under the github org alright CMC team

343
00:16:41,899 --> 00:16:47,209
and the whole idea is just to make it

344
00:16:44,269 --> 00:16:50,179
easier for users to control flight

345
00:16:47,209 --> 00:16:52,849
recorder on JVMs that are in containers

346
00:16:50,179 --> 00:16:58,129
whether it's docker kubernetes openshift

347
00:16:52,850 --> 00:17:00,679
etc so the features are pretty simple

348
00:16:58,129 --> 00:17:02,119
you can start and stop recordings you

349
00:17:00,679 --> 00:17:04,039
can archive recording so you can

350
00:17:02,119 --> 00:17:06,649
download them you can view automated

351
00:17:04,039 --> 00:17:09,138
analysis immediately without opening

352
00:17:06,648 --> 00:17:11,239
your desktop application you can view

353
00:17:09,138 --> 00:17:15,319
events available for the specific JVM

354
00:17:11,240 --> 00:17:18,620
and this is all able to be manipulated

355
00:17:15,319 --> 00:17:20,329
via web UI or command-line tool and then

356
00:17:18,619 --> 00:17:22,158
we also are looking into various

357
00:17:20,329 --> 00:17:26,418
integrations with things like griffin o

358
00:17:22,159 --> 00:17:28,069
of Prometheus etc but those are more

359
00:17:26,419 --> 00:17:32,419
like experimental so they might

360
00:17:28,069 --> 00:17:34,668
disappear so but the idea is all this

361
00:17:32,419 --> 00:17:36,950
stuff you can do now but doing it with

362
00:17:34,669 --> 00:17:39,049
je viens and containers or je viens

363
00:17:36,950 --> 00:17:41,240
running on orchestration platforms like

364
00:17:39,049 --> 00:17:44,179
openshift is not necessarily the

365
00:17:41,240 --> 00:17:46,400
the easiest thing to set up and the idea

366
00:17:44,179 --> 00:17:51,020
here is running this project alongside

367
00:17:46,400 --> 00:17:56,090
your your deployment you can do that

368
00:17:51,020 --> 00:17:58,670
without any extra work so jiff container

369
00:17:56,090 --> 00:18:01,309
jeffires made up of four core components

370
00:17:58,670 --> 00:18:03,920
each of them are their own repository

371
00:18:01,309 --> 00:18:05,350
there's the main container GFI which

372
00:18:03,920 --> 00:18:07,670
contains the management service

373
00:18:05,350 --> 00:18:10,100
including the API for kubernetes and

374
00:18:07,670 --> 00:18:13,040
OpenShift there's the core which has

375
00:18:10,100 --> 00:18:15,350
core libraries for JFR management so the

376
00:18:13,040 --> 00:18:16,879
idea here is technically if you wanted

377
00:18:15,350 --> 00:18:19,699
to write your own stuff you could extend

378
00:18:16,880 --> 00:18:22,730
off our core library which contains like

379
00:18:19,700 --> 00:18:26,059
useful features for dealing with likes

380
00:18:22,730 --> 00:18:28,490
for example JVM discovery in openshift

381
00:18:26,059 --> 00:18:32,120
or kubernetes or something there's a web

382
00:18:28,490 --> 00:18:34,390
front-end just to give a web UI to

383
00:18:32,120 --> 00:18:37,909
easily do things and then there's

384
00:18:34,390 --> 00:18:40,070
operator project so I'm not sure how

385
00:18:37,910 --> 00:18:42,800
familiar everyone is with how kubernetes

386
00:18:40,070 --> 00:18:45,169
and openshift work but they have this

387
00:18:42,800 --> 00:18:47,780
operator concept to help deployment of

388
00:18:45,170 --> 00:18:50,059
things and so we do provide an operator

389
00:18:47,780 --> 00:18:52,700
where it's basically becomes like a

390
00:18:50,059 --> 00:18:55,428
one-click operation you click subscribe

391
00:18:52,700 --> 00:18:58,580
and then everything is started and

392
00:18:55,429 --> 00:18:59,480
automatic automated and managed by

393
00:18:58,580 --> 00:19:03,080
OpenShift

394
00:18:59,480 --> 00:19:05,270
or kubernetes and then along with that

395
00:19:03,080 --> 00:19:07,730
we there's the side project JFR

396
00:19:05,270 --> 00:19:10,100
datasource and it provides a data source

397
00:19:07,730 --> 00:19:12,320
for graph ana for JFR files so if you

398
00:19:10,100 --> 00:19:14,510
have a JFR file you can you can upload

399
00:19:12,320 --> 00:19:16,850
it into this data source and then you

400
00:19:14,510 --> 00:19:20,690
could view any time series or related

401
00:19:16,850 --> 00:19:21,409
data in Griffin ah and then finally for

402
00:19:20,690 --> 00:19:23,840
the demo

403
00:19:21,410 --> 00:19:26,179
there is also an incorporation of Iger

404
00:19:23,840 --> 00:19:29,389
which is end-to-end distributed tracing

405
00:19:26,179 --> 00:19:31,910
for your applications so if you're

406
00:19:29,390 --> 00:19:34,370
deploying like four or five different

407
00:19:31,910 --> 00:19:36,230
micro services that are HTTP based and

408
00:19:34,370 --> 00:19:38,540
they're requesting across networks to

409
00:19:36,230 --> 00:19:43,250
each other you can build a map of what's

410
00:19:38,540 --> 00:19:46,428
happening using distributed tracing so

411
00:19:43,250 --> 00:19:48,500
yeah going back to the diagram the setup

412
00:19:46,429 --> 00:19:50,600
is basically this micro service called

413
00:19:48,500 --> 00:19:52,669
the robot shop which consists of an

414
00:19:50,600 --> 00:19:55,189
order service a customer service and a

415
00:19:52,669 --> 00:19:57,410
factory service so users can

416
00:19:55,190 --> 00:19:59,680
come in and request an order for a robot

417
00:19:57,410 --> 00:20:02,030
that goes into the order service which

418
00:19:59,680 --> 00:20:03,470
tells the factory that it needs to build

419
00:20:02,030 --> 00:20:05,420
a robot and then tells the customer

420
00:20:03,470 --> 00:20:08,120
service that they have a customer who

421
00:20:05,420 --> 00:20:11,330
needs like the database to be updated

422
00:20:08,120 --> 00:20:13,280
with their order etc and so eventually a

423
00:20:11,330 --> 00:20:16,760
robot gets built and then gets sent back

424
00:20:13,280 --> 00:20:18,560
to the user and so these are three

425
00:20:16,760 --> 00:20:21,980
different Java applications that are

426
00:20:18,560 --> 00:20:23,360
running basically HTTP servers there

427
00:20:21,980 --> 00:20:28,250
that are going to be deployed in

428
00:20:23,360 --> 00:20:32,689
openshift and then on the side we have a

429
00:20:28,250 --> 00:20:36,320
Jager operator below which manages an

430
00:20:32,690 --> 00:20:41,570
instance of Jager and the services are

431
00:20:36,320 --> 00:20:43,669
all and implemented to to work with

432
00:20:41,570 --> 00:20:47,000
Jager for distributed tracing so they'll

433
00:20:43,670 --> 00:20:50,120
be sending traces to to the Jager

434
00:20:47,000 --> 00:20:53,600
instance as well we'll have the

435
00:20:50,120 --> 00:20:55,250
container JFR operator deployed so

436
00:20:53,600 --> 00:20:59,090
there's one of those per project and

437
00:20:55,250 --> 00:21:02,180
that will manage a single container JFR

438
00:20:59,090 --> 00:21:04,310
instance which contains the web UI

439
00:21:02,180 --> 00:21:06,680
container JFR the data source and

440
00:21:04,310 --> 00:21:09,169
Agrafena instance and that will be able

441
00:21:06,680 --> 00:21:14,270
to connect to any of the applications

442
00:21:09,170 --> 00:21:18,260
that are running for retrieving flight

443
00:21:14,270 --> 00:21:19,250
recordings from them so you'll see as

444
00:21:18,260 --> 00:21:21,260
well

445
00:21:19,250 --> 00:21:23,630
it's more of an implementation detail

446
00:21:21,260 --> 00:21:27,129
but the operator will be running flight

447
00:21:23,630 --> 00:21:30,290
recorder instances resources per

448
00:21:27,130 --> 00:21:33,380
application in the project which is used

449
00:21:30,290 --> 00:21:36,680
for management purposes it's not too

450
00:21:33,380 --> 00:21:43,970
important so yeah we can jump into the

451
00:21:36,680 --> 00:21:46,490
demo so there is a portion that's

452
00:21:43,970 --> 00:21:49,790
internet related but the Internet's of

453
00:21:46,490 --> 00:21:53,060
its body so I might skip it oh yeah in

454
00:21:49,790 --> 00:21:55,280
the project I created in in openshift

455
00:21:53,060 --> 00:21:58,760
cluster on my local machine I called it

456
00:21:55,280 --> 00:22:01,850
Fossum 2020 if we go into the operators

457
00:21:58,760 --> 00:22:05,390
I've installed the Jaeger operator as

458
00:22:01,850 --> 00:22:08,000
well as a container JFR operator and

459
00:22:05,390 --> 00:22:09,510
then the Jaeger operator itself installs

460
00:22:08,000 --> 00:22:12,870
the elasticsearch off

461
00:22:09,510 --> 00:22:15,860
though I don't technically use it if we

462
00:22:12,870 --> 00:22:20,189
look at the deployments I have a

463
00:22:15,860 --> 00:22:25,830
container for operator Jaeger fantastic

464
00:22:20,190 --> 00:22:27,690
search and the Seeger instance so when

465
00:22:25,830 --> 00:22:30,659
it comes to to setting up container

466
00:22:27,690 --> 00:22:32,640
Jerry fired the basics behind it is you

467
00:22:30,660 --> 00:22:34,410
install the operator through through the

468
00:22:32,640 --> 00:22:36,900
operator hub and then once you've

469
00:22:34,410 --> 00:22:39,090
installed it you you simply go into the

470
00:22:36,900 --> 00:22:41,430
project that you want an instance of and

471
00:22:39,090 --> 00:22:44,550
you click create instance and then you

472
00:22:41,430 --> 00:22:46,260
hit in the spec minimal either true or

473
00:22:44,550 --> 00:22:48,600
false

474
00:22:46,260 --> 00:22:51,510
so that will decide if you want to

475
00:22:48,600 --> 00:22:54,600
deploy the web UI and related tools or

476
00:22:51,510 --> 00:22:56,370
not so if you want the web UI you put in

477
00:22:54,600 --> 00:23:01,260
minimum or false and then you just hit

478
00:22:56,370 --> 00:23:03,780
create and then from there everything

479
00:23:01,260 --> 00:23:05,870
else is is automatically set up by the

480
00:23:03,780 --> 00:23:09,800
system and and you're done

481
00:23:05,870 --> 00:23:11,669
so once you have that up and running I

482
00:23:09,800 --> 00:23:13,889
already have an instance called

483
00:23:11,670 --> 00:23:16,440
container tray fire and I just created

484
00:23:13,890 --> 00:23:19,110
the example instance but if we go into

485
00:23:16,440 --> 00:23:22,770
our route section this stuff it's

486
00:23:19,110 --> 00:23:26,610
automatically created so there are

487
00:23:22,770 --> 00:23:29,700
exposed HTTP endpoints for container JFR

488
00:23:26,610 --> 00:23:32,000
so I can visit that now so this one just

489
00:23:29,700 --> 00:23:34,820
opens up our working problem

490
00:23:32,000 --> 00:23:38,550
work-in-progress web UI and so this is

491
00:23:34,820 --> 00:23:40,649
where you can through UI look at the JVM

492
00:23:38,550 --> 00:23:44,490
s that are running in this openshift

493
00:23:40,650 --> 00:23:45,990
project so going back to the cluster if

494
00:23:44,490 --> 00:23:48,480
we look at the deployment coffee this is

495
00:23:45,990 --> 00:23:53,280
actually where I've deployed the robot

496
00:23:48,480 --> 00:23:56,700
shop with poorly named means so RCS is

497
00:23:53,280 --> 00:24:00,270
the customer service our FS is factory

498
00:23:56,700 --> 00:24:03,200
service and RLS is the order service so

499
00:24:00,270 --> 00:24:05,580
these are the deployments that

500
00:24:03,200 --> 00:24:10,530
correspond to the micro services I

501
00:24:05,580 --> 00:24:13,889
showed earlier so here we can connect to

502
00:24:10,530 --> 00:24:16,110
the target je viens at the moment it

503
00:24:13,890 --> 00:24:20,400
basically just shows their their

504
00:24:16,110 --> 00:24:23,010
hostname and then the port so down below

505
00:24:20,400 --> 00:24:25,320
here is the RCS

506
00:24:23,010 --> 00:24:27,600
it's the IRFs sports and our OS ports

507
00:24:25,320 --> 00:24:30,899
for the micro services so on these

508
00:24:27,600 --> 00:24:35,070
applications I have exposed for our GM X

509
00:24:30,900 --> 00:24:39,360
connections 1991 so for example in this

510
00:24:35,070 --> 00:24:41,820
RCS 1991 I can connect to it and then

511
00:24:39,360 --> 00:24:46,590
the basic UI is you can create

512
00:24:41,820 --> 00:24:51,240
recordings can set a snapshot time what

513
00:24:46,590 --> 00:24:53,220
events the name etc and then once you

514
00:24:51,240 --> 00:24:56,330
have a recording for example this one

515
00:24:53,220 --> 00:25:04,980
which is continuously running you can

516
00:24:56,330 --> 00:25:07,740
view a summary which will load the

517
00:25:04,980 --> 00:25:10,680
automated analysis reports in the in the

518
00:25:07,740 --> 00:25:13,050
web UI you can choose to download it you

519
00:25:10,680 --> 00:25:17,190
can save it into the archive which works

520
00:25:13,050 --> 00:25:19,850
with persistent persistent storage for

521
00:25:17,190 --> 00:25:23,100
open shift and then that's basically

522
00:25:19,850 --> 00:25:29,550
getting your JFR files outs out of your

523
00:25:23,100 --> 00:25:31,500
out of your cluster ok so as far as the

524
00:25:29,550 --> 00:25:34,379
demo is concerned we have three micro

525
00:25:31,500 --> 00:25:37,560
services that are running and I'm gonna

526
00:25:34,380 --> 00:25:40,440
submit an order to them from my local

527
00:25:37,560 --> 00:25:46,980
machine so I have this load application

528
00:25:40,440 --> 00:25:51,200
I'm just gonna run yeah so the load

529
00:25:46,980 --> 00:25:54,950
application will target those three

530
00:25:51,200 --> 00:25:58,380
services which expose HTTP routes

531
00:25:54,950 --> 00:26:03,390
hopefully this works and so you can see

532
00:25:58,380 --> 00:26:06,150
here it's it has pretty extensive

533
00:26:03,390 --> 00:26:08,310
logging but in general it's ordering

534
00:26:06,150 --> 00:26:11,820
three robots to be created and then

535
00:26:08,310 --> 00:26:16,139
delivered to the user so if we go back

536
00:26:11,820 --> 00:26:21,960
here we can open up

537
00:26:16,140 --> 00:26:24,960
Jagr and see we do have this services

538
00:26:21,960 --> 00:26:28,590
and their traces so like you can find

539
00:26:24,960 --> 00:26:31,890
that and then with distributed tracing

540
00:26:28,590 --> 00:26:34,330
we'd get a overlook of exactly what

541
00:26:31,890 --> 00:26:39,360
occurred in the HTTP

542
00:26:34,330 --> 00:26:41,559
work so request was made to order

543
00:26:39,360 --> 00:26:43,959
validated user and then there's three

544
00:26:41,559 --> 00:26:47,980
build robot requests so it built a robot

545
00:26:43,960 --> 00:26:49,929
three times and there's pickup etc as

546
00:26:47,980 --> 00:26:52,330
well we can go into dependencies and

547
00:26:49,929 --> 00:26:57,399
look at the directed Silla graph and

548
00:26:52,330 --> 00:27:00,220
just see in our setup of services when

549
00:26:57,399 --> 00:27:02,500
the request came in the order service

550
00:27:00,220 --> 00:27:04,659
made 10 requests the factory service and

551
00:27:02,500 --> 00:27:07,029
also one request the customer service so

552
00:27:04,659 --> 00:27:11,019
it just shows you the connections

553
00:27:07,029 --> 00:27:16,649
between your your micro services and

554
00:27:11,019 --> 00:27:19,419
then back to the trace so given a trace

555
00:27:16,649 --> 00:27:22,689
there is quite a bit of information you

556
00:27:19,419 --> 00:27:25,929
can see for example here in the creating

557
00:27:22,690 --> 00:27:29,889
chastity it was of type T 800 and it

558
00:27:25,929 --> 00:27:31,899
took 469 milliseconds to do that whereas

559
00:27:29,889 --> 00:27:35,408
when it was creating this Wally robot it

560
00:27:31,899 --> 00:27:38,229
took 670 milliseconds and then you can

561
00:27:35,409 --> 00:27:40,059
see across a whole request how long it

562
00:27:38,230 --> 00:27:42,820
took to point four seconds here at three

563
00:27:40,059 --> 00:27:46,840
seconds etc so you do get a neat

564
00:27:42,820 --> 00:27:49,389
overview of what's going on at a little

565
00:27:46,840 --> 00:27:51,010
higher level in your application but

566
00:27:49,389 --> 00:27:54,399
when you when you're trying to diagnose

567
00:27:51,010 --> 00:27:56,950
issues or potential performance problems

568
00:27:54,399 --> 00:27:59,229
you do need a little more and that's

569
00:27:56,950 --> 00:28:03,429
where in combination with something like

570
00:27:59,230 --> 00:28:05,740
JFR you can solve a lot so in this

571
00:28:03,429 --> 00:28:08,649
scenario with this is obviously a dummy

572
00:28:05,740 --> 00:28:12,070
project there are a few problems coded

573
00:28:08,649 --> 00:28:16,719
into it for example in the creating

574
00:28:12,070 --> 00:28:18,158
chassis x' you can see here when i was

575
00:28:16,720 --> 00:28:20,710
creating the wally robot for whatever

576
00:28:18,159 --> 00:28:24,370
reason it took 670 milliseconds whereas

577
00:28:20,710 --> 00:28:27,039
when I was doing coffee it was only 272

578
00:28:24,370 --> 00:28:28,870
it's a huge difference if you know a

579
00:28:27,039 --> 00:28:32,590
little bit about your own application

580
00:28:28,870 --> 00:28:34,268
maybe this is an unexpected result these

581
00:28:32,590 --> 00:28:38,320
two robots should take a similar amount

582
00:28:34,269 --> 00:28:40,779
of time so from here though you can't

583
00:28:38,320 --> 00:28:42,908
get much more than than the information

584
00:28:40,779 --> 00:28:45,370
it shows right like so why did it take

585
00:28:42,909 --> 00:28:48,039
more time and that's where I'm gonna go

586
00:28:45,370 --> 00:28:49,899
in now with JFR so this was in

587
00:28:48,039 --> 00:28:53,379
factory service so I'm gonna get a

588
00:28:49,899 --> 00:28:55,619
recording of that back to the web UI I'm

589
00:28:53,379 --> 00:28:58,988
going to target the factory service

590
00:28:55,619 --> 00:29:02,590
it says port it has a continuous

591
00:28:58,989 --> 00:29:05,889
recording enabled so I'm just going to

592
00:29:02,590 --> 00:29:07,259
download that to my system so with with

593
00:29:05,889 --> 00:29:09,189
your click it's now on my own machine

594
00:29:07,259 --> 00:29:15,039
and then going back to Mission Control

595
00:29:09,190 --> 00:29:20,340
now I can open that up real quickly in

596
00:29:15,039 --> 00:29:23,769
the Downloads factory service dachi FR

597
00:29:20,340 --> 00:29:25,899
so yeah on the get go for the factory

598
00:29:23,769 --> 00:29:28,059
servers there isn't too much and

599
00:29:25,899 --> 00:29:29,590
automated announce results unfortunately

600
00:29:28,059 --> 00:29:33,970
so you do have to go digging a little

601
00:29:29,590 --> 00:29:35,649
deeper so one thing I can look at in

602
00:29:33,970 --> 00:29:39,789
this case I know it's the creating

603
00:29:35,649 --> 00:29:42,580
jassi's and in this process when it

604
00:29:39,789 --> 00:29:46,599
creates a robot it uses a thread pool

605
00:29:42,580 --> 00:29:50,158
system so I can look at the that the set

606
00:29:46,599 --> 00:29:57,509
of threads in this case the factory line

607
00:29:50,159 --> 00:29:57,509
and see what's going on so if I then

608
00:29:58,409 --> 00:30:08,769
zoom in to that I can see here the

609
00:30:06,429 --> 00:30:11,889
execution of these threads and what they

610
00:30:08,769 --> 00:30:12,489
were stated their state was so actually

611
00:30:11,889 --> 00:30:15,969
in my demo

612
00:30:12,489 --> 00:30:17,859
I sent the request quite a while ago so

613
00:30:15,970 --> 00:30:20,109
some of the information isn't around and

614
00:30:17,859 --> 00:30:23,039
the reason for that is it's a continuous

615
00:30:20,109 --> 00:30:27,759
recording which I've set to only keep

616
00:30:23,039 --> 00:30:31,029
128 megabytes of space so the recording

617
00:30:27,759 --> 00:30:33,159
won't contain events from the lifetime

618
00:30:31,029 --> 00:30:35,440
of the JVM if it's lasting for a long

619
00:30:33,159 --> 00:30:37,450
time but that's a configuration option

620
00:30:35,440 --> 00:30:39,999
but in any case we can still see some

621
00:30:37,450 --> 00:30:43,749
interesting information here we're in

622
00:30:39,999 --> 00:30:47,950
the scope of building a robot a huge

623
00:30:43,749 --> 00:30:50,559
portion of time was spent blocked and so

624
00:30:47,950 --> 00:30:55,710
there's obviously a concurrency problem

625
00:30:50,559 --> 00:30:58,418
here going on because I can make

626
00:30:55,710 --> 00:31:00,489
hopefully decent assumption that it was

627
00:30:58,419 --> 00:31:01,870
blocked because of something else like

628
00:31:00,489 --> 00:31:04,390
the other factory line

629
00:31:01,870 --> 00:31:08,590
right because this so the blue is it's

630
00:31:04,390 --> 00:31:12,940
it's sleeping and then here it's blocked

631
00:31:08,590 --> 00:31:14,590
and then this is I think active but so

632
00:31:12,940 --> 00:31:16,929
if I actually click into the block

633
00:31:14,590 --> 00:31:21,879
section go and look at the stack trace

634
00:31:16,929 --> 00:31:22,570
portion I can see that in its block

635
00:31:21,880 --> 00:31:28,000
states

636
00:31:22,570 --> 00:31:31,510
oops down here it was in the paint robot

637
00:31:28,000 --> 00:31:35,260
which was then in in in the logger so I

638
00:31:31,510 --> 00:31:37,360
have a little bit of code now that I can

639
00:31:35,260 --> 00:31:40,658
go back to my project code and say maybe

640
00:31:37,360 --> 00:31:43,439
I'll go look into this logging of ok

641
00:31:40,659 --> 00:31:46,029
robot or logging of create jassi's and

642
00:31:43,440 --> 00:31:53,380
see what's happening there so if I go

643
00:31:46,029 --> 00:31:59,529
and open up my code editor now and the

644
00:31:53,380 --> 00:32:04,899
project so I'm just gonna search me

645
00:31:59,529 --> 00:32:07,870
chassis so in the chassis code there is

646
00:32:04,899 --> 00:32:10,178
a span dollar for tracing purposes and

647
00:32:07,870 --> 00:32:12,129
then there's a logger call right here

648
00:32:10,179 --> 00:32:14,140
and then the sleep it's supposed to

649
00:32:12,130 --> 00:32:17,110
simulate building each a sees which is

650
00:32:14,140 --> 00:32:19,330
supposed to be constant time so um

651
00:32:17,110 --> 00:32:20,649
because the the secretary showed that it

652
00:32:19,330 --> 00:32:23,289
was sleeping in logger I'm I'm gonna

653
00:32:20,649 --> 00:32:25,750
check the logger out now coño logger

654
00:32:23,289 --> 00:32:28,960
Java will see that Marcus decided to

655
00:32:25,750 --> 00:32:30,640
make this synchronized static void

656
00:32:28,960 --> 00:32:33,370
message which is terrible for logging

657
00:32:30,640 --> 00:32:35,169
purposes because we have for factory

658
00:32:33,370 --> 00:32:36,428
lines that are trying to make robots and

659
00:32:35,169 --> 00:32:39,179
they're gonna all hit the slogging

660
00:32:36,429 --> 00:32:42,190
synchronize thing and get blocked so

661
00:32:39,179 --> 00:32:46,200
we'd have to work that out so this is

662
00:32:42,190 --> 00:32:49,000
just a quick example of how you can take

663
00:32:46,200 --> 00:32:52,240
distributed tracing and JFR together to

664
00:32:49,000 --> 00:32:59,559
get a deeper look at problems in your in

665
00:32:52,240 --> 00:33:05,230
your code yeah and so going back to the

666
00:32:59,559 --> 00:33:07,658
open shift set up just for some clarity

667
00:33:05,230 --> 00:33:10,570
in terms of your JVM application

668
00:33:07,659 --> 00:33:14,620
apart from deploying container JFR the

669
00:33:10,570 --> 00:33:15,280
only thing you now need to do for JVM

670
00:33:14,620 --> 00:33:18,429
application

671
00:33:15,280 --> 00:33:21,100
in a container is exposed a connection

672
00:33:18,430 --> 00:33:23,800
for container to fire in this case we do

673
00:33:21,100 --> 00:33:25,540
support IgM X so if we look at our

674
00:33:23,800 --> 00:33:27,220
deployment configs and the environment

675
00:33:25,540 --> 00:33:30,790
variables we'll see there's a Java op

676
00:33:27,220 --> 00:33:36,450
section that I set up and in this Java

677
00:33:30,790 --> 00:33:36,450
ops I'm going to make it bigger yeah

678
00:33:37,020 --> 00:33:45,550
okay that was too big I exposed

679
00:33:41,530 --> 00:33:47,860
9091 obviously on a non production

680
00:33:45,550 --> 00:33:48,970
system without authentication and then

681
00:33:47,860 --> 00:33:53,620
these are the settings for flight

682
00:33:48,970 --> 00:33:56,500
recorder to be continuous so yeah in

683
00:33:53,620 --> 00:34:00,159
general territory far the idea is to

684
00:33:56,500 --> 00:34:04,890
make getting JFR files out of je viens

685
00:34:00,160 --> 00:34:04,890
and containers as easy as possible and

686
00:34:05,910 --> 00:34:12,190
yeah the other neat thing to hear while

687
00:34:09,879 --> 00:34:14,290
in there is just for example in an

688
00:34:12,190 --> 00:34:16,929
orchestration system there's concept of

689
00:34:14,290 --> 00:34:19,060
internal external networks so normally

690
00:34:16,929 --> 00:34:20,679
when you do a JMX connection you want it

691
00:34:19,060 --> 00:34:24,100
to be secure because if you're opening a

692
00:34:20,679 --> 00:34:25,629
port in in the system than anyone could

693
00:34:24,100 --> 00:34:28,089
maybe exercise and do something

694
00:34:25,629 --> 00:34:31,690
malicious but with internal external

695
00:34:28,090 --> 00:34:34,179
networks the port is actually in the set

696
00:34:31,690 --> 00:34:37,870
up I have only on an internal OpenShift

697
00:34:34,179 --> 00:34:39,429
network so only OpenShift services with

698
00:34:37,870 --> 00:34:41,529
the correct privileges are able to

699
00:34:39,429 --> 00:34:44,350
access it so you get the security there

700
00:34:41,530 --> 00:34:47,050
for free so theoretically this stuff

701
00:34:44,350 --> 00:34:53,889
isn't exposed as long as open Chiffre

702
00:34:47,050 --> 00:35:02,370
with their code correctly yeah so going

703
00:34:53,889 --> 00:35:02,370
back to the slides here

704
00:35:02,749 --> 00:35:07,468
again that was the demo demo for JFR

705
00:35:05,940 --> 00:35:10,469
management and open shipping container

706
00:35:07,469 --> 00:35:12,359
and finally I'd like to end off again

707
00:35:10,469 --> 00:35:14,640
with contributing to J and C we have a

708
00:35:12,359 --> 00:35:17,940
repo meaning it cetera we're pretty

709
00:35:14,640 --> 00:35:20,308
active there's a huge amount of issues

710
00:35:17,940 --> 00:35:31,319
in a variety of areas so you can work on

711
00:35:20,309 --> 00:35:33,440
and yeah thank you so I guess I have

712
00:35:31,319 --> 00:35:42,630
some time if anyone has questions uh

713
00:35:33,440 --> 00:35:45,809
sure in the center so that's something

714
00:35:42,630 --> 00:35:48,119
oh yeah so the question was if the GMC

715
00:35:45,809 --> 00:35:50,940
core libraries will ever be published on

716
00:35:48,119 --> 00:35:53,329
maven central so that one actually

717
00:35:50,940 --> 00:35:56,880
became a little complicated because

718
00:35:53,329 --> 00:35:59,400
Oracle had plans to publish it into Sona

719
00:35:56,880 --> 00:36:01,829
type and so they started the process and

720
00:35:59,400 --> 00:36:05,609
they got the permissions and the admin

721
00:36:01,829 --> 00:36:07,259
rights and then they stopped and I don't

722
00:36:05,609 --> 00:36:10,019
know where they went but they have the

723
00:36:07,259 --> 00:36:11,670
admin rights to the name for the core

724
00:36:10,019 --> 00:36:16,229
libraries and everything so we have to

725
00:36:11,670 --> 00:36:18,089
discuss that but in general we do want

726
00:36:16,229 --> 00:36:19,769
them to be on mute and central so people

727
00:36:18,089 --> 00:36:22,680
can easily get them into their maven

728
00:36:19,769 --> 00:36:27,738
projects for the time being adopt open

729
00:36:22,680 --> 00:36:30,479
JDK actually publishes to a a repository

730
00:36:27,739 --> 00:36:32,940
the core libraries so you can pull that

731
00:36:30,479 --> 00:36:37,259
from your maven projects you just need

732
00:36:32,940 --> 00:36:42,140
to add an external repo yeah

733
00:36:37,259 --> 00:36:42,140
any other questions sure back

734
00:36:44,609 --> 00:36:52,029
thanks Andrew thank you um regarding the

735
00:36:48,790 --> 00:36:54,250
container JFR what's the deployment

736
00:36:52,030 --> 00:36:57,609
model like is it like a sight card

737
00:36:54,250 --> 00:37:00,760
that's injected into every JVM and since

738
00:36:57,609 --> 00:37:03,190
it sees no is it like a Damon's head or

739
00:37:00,760 --> 00:37:05,230
so how does this scale I mean just okay

740
00:37:03,190 --> 00:37:09,849
yeah so the question was what's the

741
00:37:05,230 --> 00:37:12,430
deployment method of container JFR and

742
00:37:09,849 --> 00:37:15,849
how it interacts the JVM s that it's

743
00:37:12,430 --> 00:37:17,770
trying to monitor it is not a agent it's

744
00:37:15,849 --> 00:37:20,740
not an agent that you inject into the

745
00:37:17,770 --> 00:37:22,990
JVM itself or into the the pod that's

746
00:37:20,740 --> 00:37:27,098
running the JVM it at the moment solely

747
00:37:22,990 --> 00:37:31,629
relies on connection protocols for

748
00:37:27,099 --> 00:37:34,810
example our gmx or JD p to connect to je

749
00:37:31,630 --> 00:37:38,980
viens that are running so the general

750
00:37:34,810 --> 00:37:41,890
process is for an application developer

751
00:37:38,980 --> 00:37:44,500
you deploy your JVM you expose our gmx

752
00:37:41,890 --> 00:37:47,470
and then you're done container JFR runs

753
00:37:44,500 --> 00:37:51,849
on the side as long as it has access to

754
00:37:47,470 --> 00:37:53,500
the same network it will see that a 9091

755
00:37:51,849 --> 00:37:57,369
port is exposed and then be able to

756
00:37:53,500 --> 00:38:00,760
connect to it and go from there so so

757
00:37:57,369 --> 00:38:03,640
the discovery at the moment is is pretty

758
00:38:00,760 --> 00:38:06,550
dumb it discovers it tries to discover

759
00:38:03,640 --> 00:38:08,290
everything but we we're trying to

760
00:38:06,550 --> 00:38:10,300
fine-tune it for example you could add

761
00:38:08,290 --> 00:38:12,730
an environment variable or something

762
00:38:10,300 --> 00:38:15,130
this is specific to kubernetes or

763
00:38:12,730 --> 00:38:18,520
openshift but to specify that this is a

764
00:38:15,130 --> 00:38:20,380
JVM that's exposing a connection for you

765
00:38:18,520 --> 00:38:23,250
and then so will connect directly bad

766
00:38:20,380 --> 00:38:23,250
but

767
00:38:26,870 --> 00:38:31,720
yeah so Prometheus is Apple based system

768
00:38:40,630 --> 00:38:50,120
so compared to Prometheus Oh so the

769
00:38:48,050 --> 00:38:52,880
question here was how does this compare

770
00:38:50,120 --> 00:38:56,529
to prometheus is discovery protocol and

771
00:38:52,880 --> 00:38:59,300
so Prometheus for those that don't know

772
00:38:56,530 --> 00:39:02,810
works on a primarily pull based system

773
00:38:59,300 --> 00:39:07,040
where the aged the running application

774
00:39:02,810 --> 00:39:08,600
exposes a base basic web service that

775
00:39:07,040 --> 00:39:12,290
prometheus connects to and poles from

776
00:39:08,600 --> 00:39:14,060
repeatedly and how Prometheus discovers

777
00:39:12,290 --> 00:39:17,630
these is through service tags and things

778
00:39:14,060 --> 00:39:20,150
like that so we will have a similar

779
00:39:17,630 --> 00:39:23,210
system for kubernetes and OpenShift

780
00:39:20,150 --> 00:39:24,680
where you can apply it in an open ship

781
00:39:23,210 --> 00:39:27,020
for example they have this concept of

782
00:39:24,680 --> 00:39:30,500
labels which you can apply to an

783
00:39:27,020 --> 00:39:33,290
application deployment and then we can

784
00:39:30,500 --> 00:39:36,620
read those labels and and see that oh

785
00:39:33,290 --> 00:39:40,250
that's far label so we should check that

786
00:39:36,620 --> 00:39:41,960
out but otherwise at the moment the

787
00:39:40,250 --> 00:39:43,790
discovery protocol is within the

788
00:39:41,960 --> 00:39:47,630
OpenShift networking system or

789
00:39:43,790 --> 00:39:51,140
kubernetes networking system where we as

790
00:39:47,630 --> 00:39:53,390
a deployment in the same project have

791
00:39:51,140 --> 00:39:56,210
access to the network and we can see all

792
00:39:53,390 --> 00:39:58,700
of the things running on that network

793
00:39:56,210 --> 00:40:00,080
and so we don't actually need your

794
00:39:58,700 --> 00:40:05,990
application to specify anything

795
00:40:00,080 --> 00:40:09,830
technically what's that help any other

796
00:40:05,990 --> 00:40:11,419
questions yeah I think you should

797
00:40:09,830 --> 00:40:12,860
probably take those outside we need to

798
00:40:11,420 --> 00:40:15,880
have time to turn around the room for

799
00:40:12,860 --> 00:40:17,680
the next speaker thank you very much

800
00:40:15,880 --> 00:40:17,980
[Applause]

801
00:40:17,680 --> 00:40:22,960
you

802
00:40:17,980 --> 00:40:22,960
[Applause]

