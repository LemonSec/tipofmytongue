1
00:00:05,920 --> 00:00:08,960
hello everyone

2
00:00:07,359 --> 00:00:10,719
thanks for waking up early and turning

3
00:00:08,960 --> 00:00:12,719
this talk on saturday morning

4
00:00:10,719 --> 00:00:14,879
can you hear me can you hear me at the

5
00:00:12,719 --> 00:00:16,560
back yes okay cool

6
00:00:14,880 --> 00:00:17,760
um so there's no sound system this is

7
00:00:16,560 --> 00:00:18,640
only for recording in case you're

8
00:00:17,760 --> 00:00:20,640
wondering

9
00:00:18,640 --> 00:00:22,400
um so my name is guillaume tucker i work

10
00:00:20,640 --> 00:00:23,680
at collabora and this talk is about

11
00:00:22,400 --> 00:00:25,359
kernel cis so i

12
00:00:23,680 --> 00:00:27,198
had a talk last year already about

13
00:00:25,359 --> 00:00:29,439
kernel ci first then this is

14
00:00:27,199 --> 00:00:31,119
kind of an update on what things have

15
00:00:29,439 --> 00:00:34,640
happened in the past year

16
00:00:31,119 --> 00:00:37,040
but also about the future really

17
00:00:34,640 --> 00:00:38,160
um so what is the purpose of kernel ci

18
00:00:37,040 --> 00:00:39,440
in case you haven't

19
00:00:38,160 --> 00:00:41,599
in case you're not familiar with the

20
00:00:39,440 --> 00:00:43,040
project and also what it wants to

21
00:00:41,600 --> 00:00:44,719
achieve in the longer term so

22
00:00:43,040 --> 00:00:47,760
it's kind of climbing a big tall

23
00:00:44,719 --> 00:00:49,039
mountain really we're trying to

24
00:00:47,760 --> 00:00:51,280
reach the point where kernels are

25
00:00:49,039 --> 00:00:53,120
released without bugs um

26
00:00:51,280 --> 00:00:55,360
and you know have at least quality

27
00:00:53,120 --> 00:00:58,640
control so we know which birds are

28
00:00:55,360 --> 00:01:02,160
in the kernel um and extending

29
00:00:58,640 --> 00:01:05,280
chest coverage this and also

30
00:01:02,160 --> 00:01:06,960
having reusable tools so the idea is to

31
00:01:05,280 --> 00:01:08,560
test the upstream kernel but anyone

32
00:01:06,960 --> 00:01:10,158
using the kernel in their own

33
00:01:08,560 --> 00:01:13,840
downstream environment should be able to

34
00:01:10,159 --> 00:01:13,840
reuse these tools

35
00:01:13,920 --> 00:01:16,960
we now have an official mission

36
00:01:15,360 --> 00:01:18,560
statement

37
00:01:16,960 --> 00:01:20,479
as written here so that's basically what

38
00:01:18,560 --> 00:01:21,200
i'm trying to explain here but this is

39
00:01:20,479 --> 00:01:24,000
like

40
00:01:21,200 --> 00:01:25,600
the official word we have now so people

41
00:01:24,000 --> 00:01:26,479
spend some time making it making this

42
00:01:25,600 --> 00:01:30,000
subtitle

43
00:01:26,479 --> 00:01:30,000
deserves at least a slide here

44
00:01:30,240 --> 00:01:34,880
so yeah last year i said maybe it will

45
00:01:33,040 --> 00:01:36,079
become a linux foundation project and

46
00:01:34,880 --> 00:01:39,679
this has happened so

47
00:01:36,079 --> 00:01:42,158
in october um kernel ci has become

48
00:01:39,680 --> 00:01:43,680
a new uh project of the linux foundation

49
00:01:42,159 --> 00:01:45,360
with all the members listed here so

50
00:01:43,680 --> 00:01:47,360
collaborate madelibri red hat google

51
00:01:45,360 --> 00:01:49,439
microsoft fan resort io and civil

52
00:01:47,360 --> 00:01:53,119
infrastructure platform which is another

53
00:01:49,439 --> 00:01:54,798
lean explanation project

54
00:01:53,119 --> 00:01:56,159
now we're still in the early days of we

55
00:01:54,799 --> 00:01:57,040
know what does that actually mean for

56
00:01:56,159 --> 00:01:58,960
the project

57
00:01:57,040 --> 00:02:00,240
so you know we have a mission statement

58
00:01:58,960 --> 00:02:02,559
that's the first step

59
00:02:00,240 --> 00:02:04,479
uh we have a budget and some stickers

60
00:02:02,560 --> 00:02:06,840
but there's a lot of other things coming

61
00:02:04,479 --> 00:02:09,360
soon hopefully

62
00:02:06,840 --> 00:02:12,640
um there's a website also

63
00:02:09,360 --> 00:02:15,360
um a part of the website explaining

64
00:02:12,640 --> 00:02:16,640
what that means for the project so

65
00:02:15,360 --> 00:02:17,840
although it has become a linux

66
00:02:16,640 --> 00:02:20,079
foundation project the

67
00:02:17,840 --> 00:02:21,520
the aim is still to be really community

68
00:02:20,080 --> 00:02:22,160
oriented so of course there are things

69
00:02:21,520 --> 00:02:24,480
that are

70
00:02:22,160 --> 00:02:26,959
done by the members for the members but

71
00:02:24,480 --> 00:02:28,480
it's really uh to facilitate

72
00:02:26,959 --> 00:02:30,720
things to happen for the kernel

73
00:02:28,480 --> 00:02:32,799
community at large

74
00:02:30,720 --> 00:02:34,720
so it's still focused on upstream

75
00:02:32,800 --> 00:02:36,480
completely i mean the tool again can be

76
00:02:34,720 --> 00:02:38,080
reused for other things so if red hat

77
00:02:36,480 --> 00:02:38,560
wants to test the fedora kernel they can

78
00:02:38,080 --> 00:02:40,319
do that

79
00:02:38,560 --> 00:02:41,840
or maybe the project will help make it

80
00:02:40,319 --> 00:02:42,958
happen as an example

81
00:02:41,840 --> 00:02:46,239
but it's still about testing the

82
00:02:42,959 --> 00:02:47,440
mainline kernel upstream kernel

83
00:02:46,239 --> 00:02:49,519
and it's still about sending email

84
00:02:47,440 --> 00:02:51,359
repository mailing lists

85
00:02:49,519 --> 00:02:53,360
and engaging engaging more with

86
00:02:51,360 --> 00:02:54,319
subsystem maintainers and developers in

87
00:02:53,360 --> 00:02:58,640
general

88
00:02:54,319 --> 00:02:58,640
um to basically help people

89
00:02:58,720 --> 00:03:03,040
add their own tests to kernel ci a lot

90
00:03:00,800 --> 00:03:04,000
of well every subsystem have different

91
00:03:03,040 --> 00:03:05,679
workflows and some

92
00:03:04,000 --> 00:03:08,080
maintainers have created their own small

93
00:03:05,680 --> 00:03:09,040
ci which works perfectly well for them

94
00:03:08,080 --> 00:03:10,879
probably

95
00:03:09,040 --> 00:03:13,040
but then uh they might be reinventing

96
00:03:10,879 --> 00:03:15,518
some wheel and also not have access to

97
00:03:13,040 --> 00:03:16,879
all the hardware that kernel ci provides

98
00:03:15,519 --> 00:03:19,040
so anyway that's the kind of

99
00:03:16,879 --> 00:03:21,359
consolidation this uh that

100
00:03:19,040 --> 00:03:22,640
that is um the main main objective we're

101
00:03:21,360 --> 00:03:26,480
trying to achieve

102
00:03:22,640 --> 00:03:27,599
so one um kind of philosophy behind

103
00:03:26,480 --> 00:03:30,159
kernel ci

104
00:03:27,599 --> 00:03:31,119
um is what we call the european testing

105
00:03:30,159 --> 00:03:32,560
philosophy

106
00:03:31,120 --> 00:03:34,400
because you know there is only one

107
00:03:32,560 --> 00:03:35,200
million kernels so in the same way that

108
00:03:34,400 --> 00:03:37,200
people

109
00:03:35,200 --> 00:03:38,720
from many different origins from many

110
00:03:37,200 --> 00:03:40,560
different reasons contribute to the same

111
00:03:38,720 --> 00:03:43,200
code base the linux kernel you know when

112
00:03:40,560 --> 00:03:44,640
kernel 5.4 is released that's for 5.4

113
00:03:43,200 --> 00:03:47,119
that's going to run on a

114
00:03:44,640 --> 00:03:48,079
on a computer on an android phone or on

115
00:03:47,120 --> 00:03:50,159
anything it's the same

116
00:03:48,080 --> 00:03:51,840
kernel the same code base although it

117
00:03:50,159 --> 00:03:54,319
does a lot of different things

118
00:03:51,840 --> 00:03:55,760
so the reason why there are so many

119
00:03:54,319 --> 00:03:57,119
different test systems is because of

120
00:03:55,760 --> 00:04:00,480
these different use cases

121
00:03:57,120 --> 00:04:02,080
but we could also have a common way of

122
00:04:00,480 --> 00:04:04,000
at least sharing the results because

123
00:04:02,080 --> 00:04:08,159
some tests are relevant to all of

124
00:04:04,000 --> 00:04:09,840
these uh cases uh if we want to like

125
00:04:08,159 --> 00:04:11,599
test for memory leaks in the kernel you

126
00:04:09,840 --> 00:04:13,519
can do that any you know wherever the

127
00:04:11,599 --> 00:04:16,000
kernel is running

128
00:04:13,519 --> 00:04:16,639
so everybody is doing their own product

129
00:04:16,000 --> 00:04:20,079
tests

130
00:04:16,639 --> 00:04:22,320
but this this is the idea is to have um

131
00:04:20,079 --> 00:04:23,919
have a test system that allows people to

132
00:04:22,320 --> 00:04:24,639
contribute their tests and contribute

133
00:04:23,919 --> 00:04:26,840
their hardware

134
00:04:24,639 --> 00:04:28,080
in the same way that they contribute the

135
00:04:26,840 --> 00:04:30,799
code

136
00:04:28,080 --> 00:04:32,320
um so yeah like i said so this large

137
00:04:30,800 --> 00:04:36,400
number of contributors

138
00:04:32,320 --> 00:04:39,759
um so yeah basically that's uh

139
00:04:36,400 --> 00:04:41,919
what i'll explain here um the image is

140
00:04:39,759 --> 00:04:42,639
trying to say that we should try to like

141
00:04:41,919 --> 00:04:44,719
have um

142
00:04:42,639 --> 00:04:45,919
the same surface of between tests and

143
00:04:44,720 --> 00:04:47,360
the code so it's a bit like test

144
00:04:45,919 --> 00:04:50,880
coverage if you want but like

145
00:04:47,360 --> 00:04:52,800
align the two things like the whole

146
00:04:50,880 --> 00:04:54,000
idea of having open source development

147
00:04:52,800 --> 00:04:56,320
and having

148
00:04:54,000 --> 00:04:58,880
open source testing open testing on top

149
00:04:56,320 --> 00:05:01,360
of it basically

150
00:04:58,880 --> 00:05:02,000
now how do you achieve that so this is a

151
00:05:01,360 --> 00:05:04,960
like an

152
00:05:02,000 --> 00:05:06,000
abstract pipeline explaining how kernel

153
00:05:04,960 --> 00:05:09,039
ci works

154
00:05:06,000 --> 00:05:10,400
for all of these blocks there is

155
00:05:09,039 --> 00:05:12,320
at least one implementation but you

156
00:05:10,400 --> 00:05:14,000
could have different things for each of

157
00:05:12,320 --> 00:05:16,639
them different instances

158
00:05:14,000 --> 00:05:18,080
so it starts from the beginning so you

159
00:05:16,639 --> 00:05:18,720
have a developer in the top left corner

160
00:05:18,080 --> 00:05:22,320
so someone

161
00:05:18,720 --> 00:05:24,800
writing some code so the code ends up as

162
00:05:22,320 --> 00:05:26,159
patches kernel ci doesn't test patches

163
00:05:24,800 --> 00:05:28,800
directly at the moment but

164
00:05:26,160 --> 00:05:30,400
it can be done other systems do it all

165
00:05:28,800 --> 00:05:31,520
git branches then of course it gets

166
00:05:30,400 --> 00:05:33,758
built

167
00:05:31,520 --> 00:05:36,000
the purple arrows are like when files

168
00:05:33,759 --> 00:05:39,680
and results are pushed to then you have

169
00:05:36,000 --> 00:05:41,199
build artifacts and after that

170
00:05:39,680 --> 00:05:42,960
when you have a build you can run tests

171
00:05:41,199 --> 00:05:44,560
and then process the results to detect

172
00:05:42,960 --> 00:05:48,159
when there was a regression

173
00:05:44,560 --> 00:05:48,880
um or basically see what needs to be

174
00:05:48,160 --> 00:05:52,160
reported

175
00:05:48,880 --> 00:05:54,080
from the results uh and then your

176
00:05:52,160 --> 00:05:56,000
results are stored and analyzed to be

177
00:05:54,080 --> 00:05:56,639
able to then provide a report to the

178
00:05:56,000 --> 00:05:58,880
people

179
00:05:56,639 --> 00:06:00,080
and uh the developers and this is when

180
00:05:58,880 --> 00:06:02,319
the loop is closed

181
00:06:00,080 --> 00:06:03,520
it's like a it's been like an in

182
00:06:02,319 --> 00:06:05,440
automation when you

183
00:06:03,520 --> 00:06:06,639
the objective is to have a working

184
00:06:05,440 --> 00:06:10,560
kernel you know

185
00:06:06,639 --> 00:06:10,560
like if you try to automate um

186
00:06:13,039 --> 00:06:16,639
an arm for example like a mechanical arm

187
00:06:15,120 --> 00:06:17,440
you want to know where in which position

188
00:06:16,639 --> 00:06:19,039
it's going to be

189
00:06:17,440 --> 00:06:20,960
if it's completely open and you just

190
00:06:19,039 --> 00:06:22,400
move something and you don't really look

191
00:06:20,960 --> 00:06:23,680
at it you can guess where it's going but

192
00:06:22,400 --> 00:06:25,039
if you have some sensors that will

193
00:06:23,680 --> 00:06:26,560
actually know where it is and you know

194
00:06:25,039 --> 00:06:27,360
the angle of everything then you can

195
00:06:26,560 --> 00:06:30,000
have

196
00:06:27,360 --> 00:06:30,960
um you know closed loop automated system

197
00:06:30,000 --> 00:06:32,400
and this is kind of

198
00:06:30,960 --> 00:06:34,400
what we're doing here except that it's

199
00:06:32,400 --> 00:06:36,239
doing this around developers and not

200
00:06:34,400 --> 00:06:40,000
very own machines

201
00:06:36,240 --> 00:06:40,000
but this is it's a similar kind of thing

202
00:06:40,080 --> 00:06:43,919
yep sorry okay i'll speak louder thanks

203
00:06:42,400 --> 00:06:45,758
uh there's uh there's a link here you

204
00:06:43,919 --> 00:06:48,719
can now so these slides are available as

205
00:06:45,759 --> 00:06:50,960
pdf there's a link on the um

206
00:06:48,720 --> 00:06:52,160
on the page for this talk and on this

207
00:06:50,960 --> 00:06:54,719
slide seven

208
00:06:52,160 --> 00:06:56,479
there's also a link to a shared document

209
00:06:54,720 --> 00:06:57,440
that has a more detailed description of

210
00:06:56,479 --> 00:07:00,719
the

211
00:06:57,440 --> 00:07:02,560
pipeline design modular pipeline

212
00:07:00,720 --> 00:07:04,880
so this is like the theory now in

213
00:07:02,560 --> 00:07:08,240
practice what is that

214
00:07:04,880 --> 00:07:10,639
uh how does that work so

215
00:07:08,240 --> 00:07:12,479
right now we have kernel ci.org there is

216
00:07:10,639 --> 00:07:13,919
one database that's being used that's

217
00:07:12,479 --> 00:07:14,880
been used for a long time but we have a

218
00:07:13,919 --> 00:07:17,359
new one using

219
00:07:14,880 --> 00:07:19,120
google bigquery and the idea is to have

220
00:07:17,360 --> 00:07:22,479
to use that as a prototyping

221
00:07:19,120 --> 00:07:25,599
database but with access to more uh

222
00:07:22,479 --> 00:07:26,639
more testing systems so all the tests

223
00:07:25,599 --> 00:07:28,319
currently

224
00:07:26,639 --> 00:07:30,960
the test results currently available on

225
00:07:28,319 --> 00:07:33,759
currencial.org are also sent to this

226
00:07:30,960 --> 00:07:35,440
database and now we have also red hat

227
00:07:33,759 --> 00:07:37,199
submitting test results to it

228
00:07:35,440 --> 00:07:39,120
and we would like to see maybe other

229
00:07:37,199 --> 00:07:40,000
people so typically typically member

230
00:07:39,120 --> 00:07:41,360
companies

231
00:07:40,000 --> 00:07:44,080
would be the first ones maybe to

232
00:07:41,360 --> 00:07:46,479
contribute to that um

233
00:07:44,080 --> 00:07:48,479
so we're kind of refining the database

234
00:07:46,479 --> 00:07:50,400
schema for like storing bill results and

235
00:07:48,479 --> 00:07:52,479
test results

236
00:07:50,400 --> 00:07:53,919
and the the first outcome we would want

237
00:07:52,479 --> 00:07:56,159
to have is have a unified

238
00:07:53,919 --> 00:07:58,799
test email report so based on all that

239
00:07:56,160 --> 00:07:59,199
collective data we could then send an

240
00:07:58,800 --> 00:08:01,840
email

241
00:07:59,199 --> 00:08:02,720
say for you know a stable branch release

242
00:08:01,840 --> 00:08:04,159
or something instead

243
00:08:02,720 --> 00:08:06,000
i don't if you've noticed unstable

244
00:08:04,160 --> 00:08:07,759
branch mailing lists

245
00:08:06,000 --> 00:08:09,599
on stable mailing list you have a lot of

246
00:08:07,759 --> 00:08:12,080
test results from coming from different

247
00:08:09,599 --> 00:08:15,120
test systems so that's one of the

248
00:08:12,080 --> 00:08:18,000
the targets of having a common uh

249
00:08:15,120 --> 00:08:19,759
upstream kernel testing test system is

250
00:08:18,000 --> 00:08:21,520
to have uh to have only one report

251
00:08:19,759 --> 00:08:23,759
that's gathering all the data so

252
00:08:21,520 --> 00:08:25,280
having this database is the first step

253
00:08:23,759 --> 00:08:26,000
so if you look on the previous slide

254
00:08:25,280 --> 00:08:29,919
that's basically

255
00:08:26,000 --> 00:08:32,320
the um the

256
00:08:29,919 --> 00:08:33,360
the store bit so yeah store is artifact

257
00:08:32,320 --> 00:08:37,200
and database but

258
00:08:33,360 --> 00:08:37,200
this is at least the the database part

259
00:08:38,958 --> 00:08:42,239
yeah and then we can build kernels in

260
00:08:40,640 --> 00:08:43,838
different places so that's you know the

261
00:08:42,240 --> 00:08:44,720
block block number two bill how do you

262
00:08:43,839 --> 00:08:46,320
build where if

263
00:08:44,720 --> 00:08:48,640
you have different people providing

264
00:08:46,320 --> 00:08:49,920
different like cloud compute and

265
00:08:48,640 --> 00:08:51,839
different ways of doing it if you're

266
00:08:49,920 --> 00:08:54,719
modular enough then you can include them

267
00:08:51,839 --> 00:08:56,959
so uh that makes the project easier to

268
00:08:54,720 --> 00:08:59,760
scale

269
00:08:56,959 --> 00:09:00,640
and right now we're using jenkins but

270
00:08:59,760 --> 00:09:02,319
we've made it in

271
00:09:00,640 --> 00:09:03,519
we've changed it in a way so that it can

272
00:09:02,320 --> 00:09:05,920
run anywhere so you can run all the

273
00:09:03,519 --> 00:09:08,160
kernel ci steps in a in the terminal

274
00:09:05,920 --> 00:09:09,760
and some people have tried also using it

275
00:09:08,160 --> 00:09:12,079
in gitlab already

276
00:09:09,760 --> 00:09:13,519
so kevin is not here kevin hillman has

277
00:09:12,080 --> 00:09:16,320
done this in a

278
00:09:13,519 --> 00:09:17,440
as a gitlab ci way so he's using the

279
00:09:16,320 --> 00:09:21,279
kernel ci

280
00:09:17,440 --> 00:09:24,000
command line tools in his um in a branch

281
00:09:21,279 --> 00:09:24,959
in a kernel branch uh so automatically

282
00:09:24,000 --> 00:09:26,240
when there's when your

283
00:09:24,959 --> 00:09:28,079
new changes are being pushed through the

284
00:09:26,240 --> 00:09:28,640
branch it uses gitlab ci to build and

285
00:09:28,080 --> 00:09:32,080
test

286
00:09:28,640 --> 00:09:33,600
things like in other gitlab ci projects

287
00:09:32,080 --> 00:09:36,399
but this could be used in other test

288
00:09:33,600 --> 00:09:39,519
systems as well

289
00:09:36,399 --> 00:09:41,040
and also abstracting the lab api so you

290
00:09:39,519 --> 00:09:44,560
know test labs are where

291
00:09:41,040 --> 00:09:46,959
hardware is available to test kernels

292
00:09:44,560 --> 00:09:47,839
so by default we use lava which is you

293
00:09:46,959 --> 00:09:51,439
know the linear

294
00:09:47,839 --> 00:09:53,200
project for automating tests um

295
00:09:51,440 --> 00:09:54,880
but it's normally i mean there are

296
00:09:53,200 --> 00:09:58,160
plenty of other things

297
00:09:54,880 --> 00:09:59,200
um so we've made an abstraction in the

298
00:09:58,160 --> 00:10:01,839
kernel ci

299
00:09:59,200 --> 00:10:02,320
core tools so that it can submit things

300
00:10:01,839 --> 00:10:04,240
to

301
00:10:02,320 --> 00:10:06,560
any lab so right now it's only sending

302
00:10:04,240 --> 00:10:09,920
things to lava but we can send it to any

303
00:10:06,560 --> 00:10:14,719
any other lab that has a web api

304
00:10:09,920 --> 00:10:19,680
uh and can accept the test definition

305
00:10:14,720 --> 00:10:22,640
so these are things we're working on

306
00:10:19,680 --> 00:10:23,519
so yeah the development goals um a bit

307
00:10:22,640 --> 00:10:25,600
more specific

308
00:10:23,519 --> 00:10:28,079
so the command line tools are like kcibl

309
00:10:25,600 --> 00:10:29,360
to do kernels to reproduce a kernel ci

310
00:10:28,079 --> 00:10:31,839
build from scratch

311
00:10:29,360 --> 00:10:33,200
kci test how to generate test

312
00:10:31,839 --> 00:10:36,079
definitions

313
00:10:33,200 --> 00:10:36,880
um so these are the the things we're

314
00:10:36,079 --> 00:10:38,640
trying to

315
00:10:36,880 --> 00:10:41,040
improve so people so they become more

316
00:10:38,640 --> 00:10:41,040
portable

317
00:10:41,519 --> 00:10:45,519
also we want to make it easier like i

318
00:10:43,839 --> 00:10:46,959
said a bit before to

319
00:10:45,519 --> 00:10:48,320
make it easier for people to contribute

320
00:10:46,959 --> 00:10:50,000
tests so if you're a maintainer or

321
00:10:48,320 --> 00:10:51,120
developer and you have a test or maybe

322
00:10:50,000 --> 00:10:53,040
you work on a

323
00:10:51,120 --> 00:10:55,040
part of the kernel and you make some

324
00:10:53,040 --> 00:10:55,839
tests for it it should be easy for you

325
00:10:55,040 --> 00:10:57,920
to

326
00:10:55,839 --> 00:11:00,399
enable this in kernel ci and right now

327
00:10:57,920 --> 00:11:02,240
this kind of um

328
00:11:00,399 --> 00:11:03,600
steep learning curve if you want to do

329
00:11:02,240 --> 00:11:04,959
this at the moment you need to be you

330
00:11:03,600 --> 00:11:06,959
need to know too much about the

331
00:11:04,959 --> 00:11:08,719
internals of kernel ci to be able to add

332
00:11:06,959 --> 00:11:10,000
a add a test to the list

333
00:11:08,720 --> 00:11:12,839
but that's one of the things we're

334
00:11:10,000 --> 00:11:15,680
trying to like lower the bar basically

335
00:11:12,839 --> 00:11:16,880
um and we need some good interaction

336
00:11:15,680 --> 00:11:17,120
with that so we need some collaboration

337
00:11:16,880 --> 00:11:19,600
for

338
00:11:17,120 --> 00:11:21,040
people who make the test as well so we

339
00:11:19,600 --> 00:11:25,200
we started with like a key

340
00:11:21,040 --> 00:11:26,640
people to try to try to do that

341
00:11:25,200 --> 00:11:29,200
so maybe next year i'll come back and

342
00:11:26,640 --> 00:11:30,640
see maybe if you follow the project

343
00:11:29,200 --> 00:11:31,600
you'll see maybe things will become

344
00:11:30,640 --> 00:11:33,439
easier

345
00:11:31,600 --> 00:11:34,640
uh but right now it is not very easy

346
00:11:33,440 --> 00:11:35,839
it's it's still a good

347
00:11:34,640 --> 00:11:37,360
thing you know if you have a test you

348
00:11:35,839 --> 00:11:39,279
really want it to be internal ci you can

349
00:11:37,360 --> 00:11:42,160
send it to the mailing list or an irc

350
00:11:39,279 --> 00:11:43,519
kernel ci on freenode or kernel search

351
00:11:42,160 --> 00:11:47,120
groups.i o

352
00:11:43,519 --> 00:11:49,519
mailing list all just on the

353
00:11:47,120 --> 00:11:51,519
on the subsystem mailing list people

354
00:11:49,519 --> 00:11:54,399
know about kernel ci

355
00:11:51,519 --> 00:11:55,760
now also yeah we're trying to improve

356
00:11:54,399 --> 00:11:57,040
the web dashboard so i don't know if

357
00:11:55,760 --> 00:12:00,160
you've seen the

358
00:11:57,040 --> 00:12:01,839
current kernel ci dashboard but here

359
00:12:00,160 --> 00:12:04,240
we're showing mostly

360
00:12:01,839 --> 00:12:05,279
bills and boot results it's not really

361
00:12:04,240 --> 00:12:07,279
there is a test

362
00:12:05,279 --> 00:12:09,279
tab but it's not really good at showing

363
00:12:07,279 --> 00:12:11,040
test results

364
00:12:09,279 --> 00:12:13,120
because kernel ci was originally about

365
00:12:11,040 --> 00:12:13,680
building kernels like a variety of

366
00:12:13,120 --> 00:12:16,560
different

367
00:12:13,680 --> 00:12:18,000
arm dev configs and then about root

368
00:12:16,560 --> 00:12:19,119
testing and it's still kind of stuck in

369
00:12:18,000 --> 00:12:21,360
that phase

370
00:12:19,120 --> 00:12:22,880
uh so we've we're starting running tests

371
00:12:21,360 --> 00:12:24,160
but the results are not shown properly

372
00:12:22,880 --> 00:12:25,680
on the web front end

373
00:12:24,160 --> 00:12:27,360
on the web dashboard so that's that's

374
00:12:25,680 --> 00:12:27,920
one thing we're fixing actually right

375
00:12:27,360 --> 00:12:29,760
now to

376
00:12:27,920 --> 00:12:32,079
unlock a lot of things there's many

377
00:12:29,760 --> 00:12:34,399
tests that we kind of held back because

378
00:12:32,079 --> 00:12:36,959
maybe we could run them and then email

379
00:12:34,399 --> 00:12:38,399
reports have some limitations and if the

380
00:12:36,959 --> 00:12:40,880
if the web dashboard doesn't show all

381
00:12:38,399 --> 00:12:42,560
the results then the test can

382
00:12:40,880 --> 00:12:43,920
get hidden and that's that's a waste of

383
00:12:42,560 --> 00:12:46,479
results

384
00:12:43,920 --> 00:12:47,680
um but we still also need to improve the

385
00:12:46,480 --> 00:12:49,920
um

386
00:12:47,680 --> 00:12:50,719
email reports that's also a two-way

387
00:12:49,920 --> 00:12:53,839
process

388
00:12:50,720 --> 00:12:55,600
because it's hard to design something

389
00:12:53,839 --> 00:12:57,120
uh from like from the beginning it's

390
00:12:55,600 --> 00:12:59,120
more like you know sending email reports

391
00:12:57,120 --> 00:13:01,279
and seeing how people react to it and

392
00:12:59,120 --> 00:13:03,360
whether you know what is useful what is

393
00:13:01,279 --> 00:13:04,639
not useful and different subsystems or

394
00:13:03,360 --> 00:13:07,200
different mailing lists need different

395
00:13:04,639 --> 00:13:08,720
types of report section

396
00:13:07,200 --> 00:13:11,279
so the key message i guess here is we

397
00:13:08,720 --> 00:13:15,279
need feedback

398
00:13:11,279 --> 00:13:17,040
and if the email you get is not perfect

399
00:13:15,279 --> 00:13:18,560
uh often people say if you send another

400
00:13:17,040 --> 00:13:20,800
one like that i'll just you know

401
00:13:18,560 --> 00:13:21,839
put your put a filter to put all you can

402
00:13:20,800 --> 00:13:24,399
also emails in

403
00:13:21,839 --> 00:13:25,040
in spam or in drunk something like that

404
00:13:24,399 --> 00:13:27,680
well that's

405
00:13:25,040 --> 00:13:28,160
maybe if it keeps getting bad all the

406
00:13:27,680 --> 00:13:30,880
time

407
00:13:28,160 --> 00:13:32,079
but normally we try to like uh improve

408
00:13:30,880 --> 00:13:35,040
things as we go so

409
00:13:32,079 --> 00:13:36,800
uh let's the key message is you know we

410
00:13:35,040 --> 00:13:39,599
can't get to a perfect thing from from

411
00:13:36,800 --> 00:13:39,599
day one basically

412
00:13:39,920 --> 00:13:43,920
uh and also a slightly more longer term

413
00:13:42,800 --> 00:13:47,439
project

414
00:13:43,920 --> 00:13:49,120
goal is to improve test bisection so we

415
00:13:47,440 --> 00:13:51,920
have buy section for boot

416
00:13:49,120 --> 00:13:53,680
tests for you know just plain boots at

417
00:13:51,920 --> 00:13:55,439
the moment so like booting to a login if

418
00:13:53,680 --> 00:13:57,120
you can log in there to boot

419
00:13:55,440 --> 00:13:59,440
and that's very easy to buy sec because

420
00:13:57,120 --> 00:14:02,480
it's only one pass fail result

421
00:13:59,440 --> 00:14:03,120
per per test per run uh but as we're

422
00:14:02,480 --> 00:14:05,360
running more

423
00:14:03,120 --> 00:14:06,800
test suites that have a lot of tests uh

424
00:14:05,360 --> 00:14:08,000
then it becomes harder to buy sick

425
00:14:06,800 --> 00:14:08,880
things when you have different test

426
00:14:08,000 --> 00:14:11,600
cases

427
00:14:08,880 --> 00:14:12,240
passing or failing at different rates uh

428
00:14:11,600 --> 00:14:14,639
so that

429
00:14:12,240 --> 00:14:16,399
we we have um i'll come back to this in

430
00:14:14,639 --> 00:14:18,720
a in another slide but we have some

431
00:14:16,399 --> 00:14:20,880
some um some ideas on how to do this as

432
00:14:18,720 --> 00:14:20,880
well

433
00:14:21,600 --> 00:14:25,600
so reusable tools uh yes so we have kci

434
00:14:24,959 --> 00:14:28,560
build

435
00:14:25,600 --> 00:14:30,000
test seo route fs and there's um two to

436
00:14:28,560 --> 00:14:34,160
create root file systems

437
00:14:30,000 --> 00:14:36,639
there's um a wiki page that might

438
00:14:34,160 --> 00:14:37,680
that might be written in uh in a not too

439
00:14:36,639 --> 00:14:39,040
distant future but

440
00:14:37,680 --> 00:14:40,319
right now there's a wiki page kind of

441
00:14:39,040 --> 00:14:41,360
work in progress that gives you at least

442
00:14:40,320 --> 00:14:43,199
a starting point

443
00:14:41,360 --> 00:14:45,199
if you want to start if you want to see

444
00:14:43,199 --> 00:14:46,880
what these tools do

445
00:14:45,199 --> 00:14:48,240
we also have the interface to the

446
00:14:46,880 --> 00:14:50,720
bigquery

447
00:14:48,240 --> 00:14:52,720
database so there's a command line tool

448
00:14:50,720 --> 00:14:53,199
for submitting kernel ci results to the

449
00:14:52,720 --> 00:14:56,480
common

450
00:14:53,199 --> 00:14:57,920
kernel ci so if you have

451
00:14:56,480 --> 00:14:59,519
a test system and you want in your

452
00:14:57,920 --> 00:15:01,279
testing upstream kernel you want to

453
00:14:59,519 --> 00:15:02,720
submit results you can get in touch and

454
00:15:01,279 --> 00:15:04,160
use that tool and you know we can give

455
00:15:02,720 --> 00:15:06,560
you a token and then you submit your

456
00:15:04,160 --> 00:15:06,560
results

457
00:15:06,639 --> 00:15:11,040
then also docker containers i haven't

458
00:15:09,120 --> 00:15:12,880
worked on it myself

459
00:15:11,040 --> 00:15:14,560
recently so i'm not an expert in the

460
00:15:12,880 --> 00:15:15,839
state of all of these but i know that

461
00:15:14,560 --> 00:15:16,800
there's some good progress that has been

462
00:15:15,839 --> 00:15:18,399
done

463
00:15:16,800 --> 00:15:19,920
to have containers with the lava

464
00:15:18,399 --> 00:15:21,360
instance with uh you know jenkins

465
00:15:19,920 --> 00:15:24,399
configured for kernel ci

466
00:15:21,360 --> 00:15:25,360
and the back end that's the back end

467
00:15:24,399 --> 00:15:27,920
currently used on

468
00:15:25,360 --> 00:15:28,720
kernel ci.org with mongodb and the

469
00:15:27,920 --> 00:15:30,399
front-end

470
00:15:28,720 --> 00:15:31,920
which is youngster.look so there are

471
00:15:30,399 --> 00:15:32,959
containers to make it easy for someone

472
00:15:31,920 --> 00:15:36,880
to recreate the whole

473
00:15:32,959 --> 00:15:38,239
system uh in their own environment

474
00:15:36,880 --> 00:15:39,839
and again if you try it and find some

475
00:15:38,240 --> 00:15:40,320
issues it's all on github on the kernel

476
00:15:39,839 --> 00:15:43,440
ci

477
00:15:40,320 --> 00:15:44,320
project on github but we need we need

478
00:15:43,440 --> 00:15:46,720
more people to

479
00:15:44,320 --> 00:15:48,160
use it basically to get some get some

480
00:15:46,720 --> 00:15:51,920
feedback on it

481
00:15:48,160 --> 00:15:54,399
um so yeah about advanced pi sections so

482
00:15:51,920 --> 00:15:55,360
there's this tool i worked on called

483
00:15:54,399 --> 00:15:58,959
scalpel

484
00:15:55,360 --> 00:16:01,759
which is inspired by easy bench

485
00:15:58,959 --> 00:16:02,479
which was written by martin perez at

486
00:16:01,759 --> 00:16:04,560
intel

487
00:16:02,480 --> 00:16:05,680
so we've been talking because he made

488
00:16:04,560 --> 00:16:09,040
this tool

489
00:16:05,680 --> 00:16:10,319
for um for graphics testing uh

490
00:16:09,040 --> 00:16:12,160
it's actually not really used in

491
00:16:10,320 --> 00:16:14,240
production easy bench at the moment

492
00:16:12,160 --> 00:16:16,240
but there it had a much advance much

493
00:16:14,240 --> 00:16:17,199
more advanced bisection feature than the

494
00:16:16,240 --> 00:16:18,880
normal git

495
00:16:17,199 --> 00:16:20,560
uh bisect command you have because this

496
00:16:18,880 --> 00:16:22,720
can deal with different several test

497
00:16:20,560 --> 00:16:25,839
cases at the same time so when you run

498
00:16:22,720 --> 00:16:26,959
one test you can provide the results for

499
00:16:25,839 --> 00:16:28,880
many test cases

500
00:16:26,959 --> 00:16:30,719
it can also request tests to be run

501
00:16:28,880 --> 00:16:33,839
several times if they are

502
00:16:30,720 --> 00:16:35,759
not stable so

503
00:16:33,839 --> 00:16:38,079
the scalp project is basically

504
00:16:35,759 --> 00:16:40,079
extracting this and boiling it down to a

505
00:16:38,079 --> 00:16:43,519
more portable thing that can be used

506
00:16:40,079 --> 00:16:46,719
and as a if you look at the project on

507
00:16:43,519 --> 00:16:48,320
on on this gitlab project you can find

508
00:16:46,720 --> 00:16:50,240
there's a demo that will run

509
00:16:48,320 --> 00:16:52,320
like create a good history with like

510
00:16:50,240 --> 00:16:55,519
dummy past fail things and it will

511
00:16:52,320 --> 00:16:57,120
find a final problem in it

512
00:16:55,519 --> 00:16:59,440
and it's kind of ready to be used in

513
00:16:57,120 --> 00:17:00,000
kernel ci but uh will come a bit later i

514
00:16:59,440 --> 00:17:03,519
think but

515
00:17:00,000 --> 00:17:05,760
that i hope that will really help

516
00:17:03,519 --> 00:17:06,880
for some things so people say maybe we

517
00:17:05,760 --> 00:17:09,039
should be testing

518
00:17:06,880 --> 00:17:10,720
patches as people send them because when

519
00:17:09,039 --> 00:17:11,919
you have one patch on a mailing list you

520
00:17:10,720 --> 00:17:13,199
can test it on its own and

521
00:17:11,919 --> 00:17:15,600
if it's good or bad before it gets

522
00:17:13,199 --> 00:17:18,640
merged and yes that's ideal but it means

523
00:17:15,599 --> 00:17:20,799
that there's a lot of patches so

524
00:17:18,640 --> 00:17:22,240
adding you know supporting all of it and

525
00:17:20,799 --> 00:17:24,959
you know building if you want

526
00:17:22,240 --> 00:17:26,559
to build all the kernel configs we build

527
00:17:24,959 --> 00:17:28,480
or even a subset of that say if you want

528
00:17:26,559 --> 00:17:28,960
to build 10 kernels for each patch that

529
00:17:28,480 --> 00:17:32,400
is sent

530
00:17:28,960 --> 00:17:33,679
and tested with 200 different platforms

531
00:17:32,400 --> 00:17:35,360
and you know that

532
00:17:33,679 --> 00:17:38,160
doesn't scale very well i think so maybe

533
00:17:35,360 --> 00:17:39,840
in some cases if we do it wisely we can

534
00:17:38,160 --> 00:17:42,240
only test a subset based on

535
00:17:39,840 --> 00:17:45,280
which subsystem the patch was sent to

536
00:17:42,240 --> 00:17:47,760
but i can take a lot of tweaking

537
00:17:45,280 --> 00:17:49,840
so the idea of the the whole advantage

538
00:17:47,760 --> 00:17:51,679
of having bisection is when you test

539
00:17:49,840 --> 00:17:53,199
linux next for example where all the new

540
00:17:51,679 --> 00:17:54,960
patches that have been applied

541
00:17:53,200 --> 00:17:56,640
are merged together and if something

542
00:17:54,960 --> 00:17:58,960
break um

543
00:17:56,640 --> 00:18:00,000
so if something breaks at this point

544
00:17:58,960 --> 00:18:02,799
then you only need

545
00:18:00,000 --> 00:18:05,039
maybe 10 iterations to to bisect from

546
00:18:02,799 --> 00:18:07,280
yesterday's next to two days next

547
00:18:05,039 --> 00:18:09,280
um so you build 10 kernels basically to

548
00:18:07,280 --> 00:18:10,559
find when when you know that there is

549
00:18:09,280 --> 00:18:14,399
actually a problem so it can be

550
00:18:10,559 --> 00:18:15,760
very efficient

551
00:18:14,400 --> 00:18:19,360
so that's why bisection is such an

552
00:18:15,760 --> 00:18:22,000
important thing for kernel ci

553
00:18:19,360 --> 00:18:23,918
uh okay so tests wish list so these are

554
00:18:22,000 --> 00:18:24,960
the things that have been identified so

555
00:18:23,919 --> 00:18:27,679
far but

556
00:18:24,960 --> 00:18:29,120
again maybe some people would think that

557
00:18:27,679 --> 00:18:30,400
network keeps training all the time

558
00:18:29,120 --> 00:18:32,719
other things maybe

559
00:18:30,400 --> 00:18:33,600
are also important to test but these are

560
00:18:32,720 --> 00:18:36,720
kind of obvious

561
00:18:33,600 --> 00:18:38,799
things that are directly

562
00:18:36,720 --> 00:18:41,960
to the yeah the ones at the top are the

563
00:18:38,799 --> 00:18:43,120
ones that kind of come with the kernel

564
00:18:41,960 --> 00:18:44,559
[Music]

565
00:18:43,120 --> 00:18:46,639
and we're not really doing them too well

566
00:18:44,559 --> 00:18:48,799
right now but that's

567
00:18:46,640 --> 00:18:50,000
i think that's like an obvious list of

568
00:18:48,799 --> 00:18:51,918
things we should be doing

569
00:18:50,000 --> 00:18:54,320
a linux test project i know that ltp

570
00:18:51,919 --> 00:18:56,000
that was mentioned a bit earlier that's

571
00:18:54,320 --> 00:18:57,840
at least some parts of it because some

572
00:18:56,000 --> 00:18:58,160
parts may not be completely relevant to

573
00:18:57,840 --> 00:18:59,840
the

574
00:18:58,160 --> 00:19:01,200
kernel maybe more like user space

575
00:18:59,840 --> 00:19:03,120
oriented but there are definitely some

576
00:19:01,200 --> 00:19:05,520
things in there that we

577
00:19:03,120 --> 00:19:07,039
that you would expect to be run on on on

578
00:19:05,520 --> 00:19:09,918
a kernel test system

579
00:19:07,039 --> 00:19:10,720
and then some some are more subsystem

580
00:19:09,919 --> 00:19:13,120
centric

581
00:19:10,720 --> 00:19:14,960
like you know for media subsystem you

582
00:19:13,120 --> 00:19:15,678
have visual 2 compliance and other

583
00:19:14,960 --> 00:19:18,720
things

584
00:19:15,679 --> 00:19:21,760
an igt and xfs test

585
00:19:18,720 --> 00:19:22,640
there's a lot of them basically and this

586
00:19:21,760 --> 00:19:25,200
is where

587
00:19:22,640 --> 00:19:26,960
more integration with well more

588
00:19:25,200 --> 00:19:28,720
communication with the subsystem

589
00:19:26,960 --> 00:19:31,039
maintainers and developers needs to

590
00:19:28,720 --> 00:19:31,039
happen

591
00:19:31,919 --> 00:19:37,919
uh and that's basically like sorry where

592
00:19:35,200 --> 00:19:38,210
are we trying to be we're trying to go

593
00:19:37,919 --> 00:19:39,360
um

594
00:19:38,210 --> 00:19:41,039
[Music]

595
00:19:39,360 --> 00:19:42,559
there's a lot more that can be said it's

596
00:19:41,039 --> 00:19:45,120
a very big project

597
00:19:42,559 --> 00:19:46,720
and it's kind of old because it has been

598
00:19:45,120 --> 00:19:48,320
around for five years but it's new at

599
00:19:46,720 --> 00:19:51,280
the same time because now we have

600
00:19:48,320 --> 00:19:52,879
a budget and we have some ideas we have

601
00:19:51,280 --> 00:19:54,960
a lot of limitations

602
00:19:52,880 --> 00:19:56,880
have been removed uh since we've joined

603
00:19:54,960 --> 00:19:59,360
the linux foundation

604
00:19:56,880 --> 00:20:00,080
so um i'm hoping it's like a rebirth for

605
00:19:59,360 --> 00:20:01,760
the project

606
00:20:00,080 --> 00:20:03,600
we need also some engagement from the

607
00:20:01,760 --> 00:20:06,158
people we need people to realize that

608
00:20:03,600 --> 00:20:07,199
now you know this has been selected by

609
00:20:06,159 --> 00:20:09,039
by the linux

610
00:20:07,200 --> 00:20:11,679
kernel community basically as the main

611
00:20:09,039 --> 00:20:13,440
project for testing testing upstream

612
00:20:11,679 --> 00:20:15,919
and you can reuse it for your own

613
00:20:13,440 --> 00:20:19,919
products as well

614
00:20:15,919 --> 00:20:20,720
so does anybody have any questions yeah

615
00:20:19,919 --> 00:20:23,039
uh

616
00:20:20,720 --> 00:20:24,559
could you please just mention the

617
00:20:23,039 --> 00:20:26,960
technologies that are using

618
00:20:24,559 --> 00:20:29,360
uh used for the tests like what kind of

619
00:20:26,960 --> 00:20:31,280
languages are the tests written that

620
00:20:29,360 --> 00:20:32,479
kind of technologies are used in the

621
00:20:31,280 --> 00:20:33,678
stack

622
00:20:32,480 --> 00:20:35,520
okay so the question is about the

623
00:20:33,679 --> 00:20:38,960
technologies used for

624
00:20:35,520 --> 00:20:40,799
uh testing in general so

625
00:20:38,960 --> 00:20:42,400
there are many different things so the

626
00:20:40,799 --> 00:20:44,240
tests that come with the kernel are

627
00:20:42,400 --> 00:20:46,159
normally written in c like a self-test

628
00:20:44,240 --> 00:20:50,480
or you have some shell scripts as well

629
00:20:46,159 --> 00:20:52,159
um and well uh the static analysis

630
00:20:50,480 --> 00:20:55,360
coccinelli is a separate

631
00:20:52,159 --> 00:20:56,320
language um and k unit is also written

632
00:20:55,360 --> 00:20:58,399
in i mean

633
00:20:56,320 --> 00:20:59,520
cassandra and the these are like

634
00:20:58,400 --> 00:21:02,000
built-in things so

635
00:20:59,520 --> 00:21:03,360
the kernel configs you enable basically

636
00:21:02,000 --> 00:21:04,799
and community is a bit the same it's

637
00:21:03,360 --> 00:21:05,439
part of the kernel so it's all written

638
00:21:04,799 --> 00:21:07,600
in c

639
00:21:05,440 --> 00:21:08,880
now you can have there are also some

640
00:21:07,600 --> 00:21:10,480
test suites a lot of

641
00:21:08,880 --> 00:21:12,480
basically the quick answer is a lot of

642
00:21:10,480 --> 00:21:14,000
it is written in c because it talks to

643
00:21:12,480 --> 00:21:15,679
the kernel so it does a lot of system

644
00:21:14,000 --> 00:21:16,640
calls and it makes sense to have a low

645
00:21:15,679 --> 00:21:20,000
level

646
00:21:16,640 --> 00:21:23,200
language does the test are described for

647
00:21:20,000 --> 00:21:26,320
anything uh

648
00:21:23,200 --> 00:21:29,039
sorry to so you can repeat

649
00:21:26,320 --> 00:21:30,240
in other user space projects we're

650
00:21:29,039 --> 00:21:32,720
testing use

651
00:21:30,240 --> 00:21:33,919
using a high-level language that collect

652
00:21:32,720 --> 00:21:36,000
that defines the

653
00:21:33,919 --> 00:21:39,200
declares the test and then that is

654
00:21:36,000 --> 00:21:42,320
translated into the native language

655
00:21:39,200 --> 00:21:43,679
yeah but there is no such language

656
00:21:42,320 --> 00:21:45,840
so the question is whether there's a

657
00:21:43,679 --> 00:21:48,400
high-level language to define the tests

658
00:21:45,840 --> 00:21:49,280
and then run them so yeah for for

659
00:21:48,400 --> 00:21:51,440
example the

660
00:21:49,280 --> 00:21:53,200
uh the test run in lava there's a yemen

661
00:21:51,440 --> 00:21:54,000
definition that explains what needs to

662
00:21:53,200 --> 00:21:56,000
be run

663
00:21:54,000 --> 00:21:57,200
and then you will have you'll have some

664
00:21:56,000 --> 00:21:59,280
commands there that might be

665
00:21:57,200 --> 00:22:01,520
binaries or maybe shell scripts or maybe

666
00:21:59,280 --> 00:22:02,320
python so it depends each test suite has

667
00:22:01,520 --> 00:22:07,440
a different

668
00:22:02,320 --> 00:22:07,439
way of being run um yeah

669
00:22:08,720 --> 00:22:14,400
i think you were second so for a single

670
00:22:11,840 --> 00:22:16,158
test run uh what's the average runtime

671
00:22:14,400 --> 00:22:17,919
and what is what would be considered

672
00:22:16,159 --> 00:22:21,120
like a reasonable

673
00:22:17,919 --> 00:22:23,360
run time for a single uh ground test

674
00:22:21,120 --> 00:22:24,320
test problem okay so the question is for

675
00:22:23,360 --> 00:22:26,639
one run uh

676
00:22:24,320 --> 00:22:28,480
for one test when what is the usual run

677
00:22:26,640 --> 00:22:30,880
time and what's the expected

678
00:22:28,480 --> 00:22:33,360
time for that basically what would be

679
00:22:30,880 --> 00:22:33,360
reasonable

680
00:22:33,840 --> 00:22:40,240
okay so uh of course each

681
00:22:37,360 --> 00:22:41,760
so the question can be answered in

682
00:22:40,240 --> 00:22:44,080
different ways so if you want to test

683
00:22:41,760 --> 00:22:45,520
everything then you can add you know

684
00:22:44,080 --> 00:22:46,960
time how long it takes of course some

685
00:22:45,520 --> 00:22:48,720
things run in parallel so it's going to

686
00:22:46,960 --> 00:22:49,440
be like until you get the whole results

687
00:22:48,720 --> 00:22:52,799
it's going to be

688
00:22:49,440 --> 00:22:55,200
what takes the longest that can also be

689
00:22:52,799 --> 00:22:57,039
done by splitting test suites into

690
00:22:55,200 --> 00:22:58,960
smaller things to run more in parallel

691
00:22:57,039 --> 00:23:00,640
so there isn't a simple answer to that

692
00:22:58,960 --> 00:23:03,679
but what is ex

693
00:23:00,640 --> 00:23:03,679
what is um

694
00:23:04,080 --> 00:23:08,240
what is desirable basically from the

695
00:23:06,080 --> 00:23:10,158
time duration i think it depends on

696
00:23:08,240 --> 00:23:11,600
where in the process you are where in

697
00:23:10,159 --> 00:23:14,240
the

698
00:23:11,600 --> 00:23:14,959
um kernel workflow you are what you know

699
00:23:14,240 --> 00:23:16,320
so if you're

700
00:23:14,960 --> 00:23:18,640
if you're sending a patch for example

701
00:23:16,320 --> 00:23:20,799
you want the result to be quick enough

702
00:23:18,640 --> 00:23:22,320
if it's um if it's linux next because

703
00:23:20,799 --> 00:23:23,760
there's a version every day you expect

704
00:23:22,320 --> 00:23:26,399
to have the results maybe within

705
00:23:23,760 --> 00:23:28,240
like six hours that wouldn't be too bad

706
00:23:26,400 --> 00:23:30,559
or maybe 12 hours even if it's

707
00:23:28,240 --> 00:23:32,240
running a lot of things uh if it takes

708
00:23:30,559 --> 00:23:33,760
more than that then you have more kernel

709
00:23:32,240 --> 00:23:35,679
versions to test than at

710
00:23:33,760 --> 00:23:37,200
times it takes to actually run the test

711
00:23:35,679 --> 00:23:39,120
if it's for

712
00:23:37,200 --> 00:23:41,039
the stable release maybe maybe you can

713
00:23:39,120 --> 00:23:41,840
run more tests it will take two days and

714
00:23:41,039 --> 00:23:44,960
it will be

715
00:23:41,840 --> 00:23:46,480
valuable so it depends on which version

716
00:23:44,960 --> 00:23:50,400
of the kernel at which stage you are in

717
00:23:46,480 --> 00:23:50,720
the development of the question is more

718
00:23:50,400 --> 00:23:53,039
like

719
00:23:50,720 --> 00:23:55,279
if you would like to use the doctor

720
00:23:53,039 --> 00:23:56,720
image and put it on say travis ci

721
00:23:55,279 --> 00:23:58,640
and have like free version the limit

722
00:23:56,720 --> 00:24:00,720
there's like 50 minutes for a single

723
00:23:58,640 --> 00:24:01,919
docker run so you basically would have

724
00:24:00,720 --> 00:24:03,679
to design

725
00:24:01,919 --> 00:24:05,039
things to work within the limitation

726
00:24:03,679 --> 00:24:08,000
unless you want to go for the

727
00:24:05,039 --> 00:24:08,000
paid version let's say

728
00:24:08,880 --> 00:24:12,880
okay so the question was about

729
00:24:10,720 --> 00:24:18,159
integrating it in travis ci

730
00:24:12,880 --> 00:24:20,080
to uh as an example yeah

731
00:24:18,159 --> 00:24:22,240
the idea is that if if you want to run

732
00:24:20,080 --> 00:24:25,918
it in travis ci as a docker

733
00:24:22,240 --> 00:24:28,640
yeah then the limit is 50 minutes okay

734
00:24:25,919 --> 00:24:29,200
so what you can do is uh for a single

735
00:24:28,640 --> 00:24:31,600
docker

736
00:24:29,200 --> 00:24:32,640
yeah so then you have to split it up in

737
00:24:31,600 --> 00:24:37,279
let's say

738
00:24:32,640 --> 00:24:40,000
if it's 500 minutes but it's 10 docker

739
00:24:37,279 --> 00:24:40,720
divided into 10 dockers running parallel

740
00:24:40,000 --> 00:24:42,559
okay

741
00:24:40,720 --> 00:24:44,240
yeah so choose a comment about if you

742
00:24:42,559 --> 00:24:46,000
wanted to integrate it in travis ci with

743
00:24:44,240 --> 00:24:47,360
a limit to 50 minutes basically you need

744
00:24:46,000 --> 00:24:49,200
to accommodate things around

745
00:24:47,360 --> 00:24:51,120
you can also like build only one kernel

746
00:24:49,200 --> 00:24:52,960
version if you know the diff config the

747
00:24:51,120 --> 00:24:56,000
architecture you care about

748
00:24:52,960 --> 00:24:57,840
and then does it even make sense to run

749
00:24:56,000 --> 00:24:59,120
docker because you are not running the

750
00:24:57,840 --> 00:25:01,918
kernel you build them

751
00:24:59,120 --> 00:25:03,360
right uh i guess so the question is

752
00:25:01,919 --> 00:25:05,120
about does it make sense to run docker

753
00:25:03,360 --> 00:25:08,000
you can use docker to build a kernel and

754
00:25:05,120 --> 00:25:08,000
run things that will

755
00:25:08,080 --> 00:25:11,199
point right you can use docker to build

756
00:25:10,159 --> 00:25:13,520
a kernel at least

757
00:25:11,200 --> 00:25:14,799
so you have an environment to build it

758
00:25:13,520 --> 00:25:17,440
anyway yes

759
00:25:14,799 --> 00:25:18,000
uh yes how are tests being triggered do

760
00:25:17,440 --> 00:25:19,520
you need to

761
00:25:18,000 --> 00:25:21,440
submit them to a currency active

762
00:25:19,520 --> 00:25:22,480
activity or do you scrape full requests

763
00:25:21,440 --> 00:25:24,880
off the mail in this

764
00:25:22,480 --> 00:25:26,480
because i guess that's the actual goal

765
00:25:24,880 --> 00:25:28,320
so right now there's a list of good

766
00:25:26,480 --> 00:25:30,080
branches that are monitored everywhere

767
00:25:28,320 --> 00:25:31,439
so the question is how are kernel ci

768
00:25:30,080 --> 00:25:32,960
tests triggered

769
00:25:31,440 --> 00:25:34,400
and the answer is right now there's a

770
00:25:32,960 --> 00:25:36,080
list of good branches that are being

771
00:25:34,400 --> 00:25:36,880
monitored you can see them on you know

772
00:25:36,080 --> 00:25:39,120
on the

773
00:25:36,880 --> 00:25:42,400
website here you have trees and branches

774
00:25:39,120 --> 00:25:44,080
so all these are monitored every hour

775
00:25:42,400 --> 00:25:45,760
and the system knows the last version

776
00:25:44,080 --> 00:25:47,918
that was tested

777
00:25:45,760 --> 00:25:49,120
um and if there's a new version then it

778
00:25:47,919 --> 00:25:49,679
triggers the whole thing and it builds a

779
00:25:49,120 --> 00:25:52,000
bunch of

780
00:25:49,679 --> 00:25:52,000
tests

781
00:25:54,080 --> 00:25:58,320
it's even if one more even if one more

782
00:25:56,880 --> 00:25:59,600
comment was pushed to the branch that's

783
00:25:58,320 --> 00:26:00,879
a different revision at the head of the

784
00:25:59,600 --> 00:26:03,918
branch and that's enough

785
00:26:00,880 --> 00:26:05,200
now like i said also um

786
00:26:03,919 --> 00:26:07,679
we've proved that it can work in a

787
00:26:05,200 --> 00:26:09,440
gitlab ci environment where it's

788
00:26:07,679 --> 00:26:11,200
when you know your typical gitlab ci

789
00:26:09,440 --> 00:26:12,960
workflow and that can trigger

790
00:26:11,200 --> 00:26:14,640
things as well so you can reuse the same

791
00:26:12,960 --> 00:26:16,080
tools in a different setting if you want

792
00:26:14,640 --> 00:26:18,640
to

793
00:26:16,080 --> 00:26:19,600
uh i think maybe you were next yeah and

794
00:26:18,640 --> 00:26:25,039
then

795
00:26:19,600 --> 00:26:28,000
okay okay so two more questions here

796
00:26:25,039 --> 00:26:28,640
okay so i want to move to testing like

797
00:26:28,000 --> 00:26:30,799
uh

798
00:26:28,640 --> 00:26:32,720
on the mailing list how are we going to

799
00:26:30,799 --> 00:26:34,080
define which tests to run

800
00:26:32,720 --> 00:26:36,000
because we are obviously don't want to

801
00:26:34,080 --> 00:26:38,000
run them off but what if there is

802
00:26:36,000 --> 00:26:40,080
actually like memory management breaking

803
00:26:38,000 --> 00:26:42,799
file system

804
00:26:40,080 --> 00:26:42,799
so the question is

805
00:26:44,400 --> 00:26:47,600
you need to look at the page right

806
00:26:47,679 --> 00:26:51,279
yeah so the question is if we start

807
00:26:49,679 --> 00:26:52,000
testing patches how do we determine

808
00:26:51,279 --> 00:26:55,200
which tests

809
00:26:52,000 --> 00:26:57,039
to run basically um so

810
00:26:55,200 --> 00:26:59,279
first you know which mailing list was

811
00:26:57,039 --> 00:27:00,960
sent to there that could be a clue

812
00:26:59,279 --> 00:27:04,840
and then of course you can do some stats

813
00:27:00,960 --> 00:27:08,640
on the um the files that it's touching

814
00:27:04,840 --> 00:27:10,399
um and you can also

815
00:27:08,640 --> 00:27:12,159
well right now we have some there are

816
00:27:10,400 --> 00:27:13,840
already tools

817
00:27:12,159 --> 00:27:15,279
i think the patches and looking at the

818
00:27:13,840 --> 00:27:17,279
files that are changing yeah

819
00:27:15,279 --> 00:27:19,120
i'm trying to figure out that i guess

820
00:27:17,279 --> 00:27:21,120
that's the red hat

821
00:27:19,120 --> 00:27:24,239
terminal testing stop dust so people are

822
00:27:21,120 --> 00:27:24,239
working on solutions

823
00:27:24,799 --> 00:27:29,679
um but yeah so we have a yaml based

824
00:27:27,760 --> 00:27:31,679
configuration at the moment to

825
00:27:29,679 --> 00:27:32,799
for each git branch with tester and we

826
00:27:31,679 --> 00:27:34,240
could have something like that for

827
00:27:32,799 --> 00:27:36,000
patches so you know depending on which

828
00:27:34,240 --> 00:27:37,440
mailing is it was sent and

829
00:27:36,000 --> 00:27:38,799
maybe some people will care more about

830
00:27:37,440 --> 00:27:40,799
some things like uh you know some

831
00:27:38,799 --> 00:27:41,520
maintainers will say every time i push

832
00:27:40,799 --> 00:27:43,039
something or

833
00:27:41,520 --> 00:27:44,559
well maybe my tennis don't send that

834
00:27:43,039 --> 00:27:46,158
many patches but

835
00:27:44,559 --> 00:27:47,678
we could have any kind of arbitrary

836
00:27:46,159 --> 00:27:49,600
rules to uh

837
00:27:47,679 --> 00:27:51,279
i think it was a question here i was

838
00:27:49,600 --> 00:27:52,719
just wondering if it's also across like

839
00:27:51,279 --> 00:28:03,360
arbitrary

840
00:27:52,720 --> 00:28:05,520
times if we're monitoring the course

841
00:28:03,360 --> 00:28:06,799
so we are yeah we're monitoring a lot of

842
00:28:05,520 --> 00:28:07,679
different branches so the question is

843
00:28:06,799 --> 00:28:09,520
can we

844
00:28:07,679 --> 00:28:10,880
are we monitoring any random branches so

845
00:28:09,520 --> 00:28:12,879
we're monitoring the main ones of course

846
00:28:10,880 --> 00:28:14,960
like mainline and next and stable

847
00:28:12,880 --> 00:28:16,080
um and we're doing as much testing as we

848
00:28:14,960 --> 00:28:19,039
can on them

849
00:28:16,080 --> 00:28:20,000
uh then we're monitoring subsystem ones

850
00:28:19,039 --> 00:28:21,679
uh and we do

851
00:28:20,000 --> 00:28:23,360
a lot of testing but maybe a bit less

852
00:28:21,679 --> 00:28:23,760
and then the further away you are from

853
00:28:23,360 --> 00:28:25,520
the

854
00:28:23,760 --> 00:28:27,200
master mainline master branch the less

855
00:28:25,520 --> 00:28:27,918
testing you get basically so it scales

856
00:28:27,200 --> 00:28:30,080
in that way

857
00:28:27,919 --> 00:28:32,399
so you could have an individual branch

858
00:28:30,080 --> 00:28:34,879
you know from like a maintainer or any

859
00:28:32,399 --> 00:28:36,559
individual developer uh maybe if you

860
00:28:34,880 --> 00:28:37,440
have like only one or two kernel bills

861
00:28:36,559 --> 00:28:39,760
and you don't you do

862
00:28:37,440 --> 00:28:40,480
only a few tests on that then it will

863
00:28:39,760 --> 00:28:42,480
you know

864
00:28:40,480 --> 00:28:44,159
for one linux next if you do 200 bills

865
00:28:42,480 --> 00:28:45,600
that's like 200 people doing one build

866
00:28:44,159 --> 00:28:46,399
basically so that's the way kind of

867
00:28:45,600 --> 00:28:49,039
scales

868
00:28:46,399 --> 00:28:50,639
uh if the community think it's useful to

869
00:28:49,039 --> 00:28:52,080
have a branch like when someone wants to

870
00:28:50,640 --> 00:28:54,080
have a branch edit they send

871
00:28:52,080 --> 00:28:55,520
a request basically if people think it's

872
00:28:54,080 --> 00:28:57,120
a good idea and if you have

873
00:28:55,520 --> 00:28:58,799
enough bill and test resources then it

874
00:28:57,120 --> 00:29:00,639
can be added there's no

875
00:28:58,799 --> 00:29:02,320
as long well the main rule is i guess

876
00:29:00,640 --> 00:29:03,840
that it needs to be obtain oriented so

877
00:29:02,320 --> 00:29:04,879
if if it's a downstream branch for your

878
00:29:03,840 --> 00:29:06,720
own product that's

879
00:29:04,880 --> 00:29:09,120
not something that would be on kernel

880
00:29:06,720 --> 00:29:09,120
normally

881
00:29:10,840 --> 00:29:13,840
okay you were building a generalized lab

882
00:29:13,200 --> 00:29:16,159
api

883
00:29:13,840 --> 00:29:17,600
to integrate with the grid so i was

884
00:29:16,159 --> 00:29:18,720
wondering what kind of functionality

885
00:29:17,600 --> 00:29:21,279
does your lab

886
00:29:18,720 --> 00:29:22,320
support in order to integrate correctly

887
00:29:21,279 --> 00:29:26,159
with

888
00:29:22,320 --> 00:29:29,918
this okay so the question was about um

889
00:29:26,159 --> 00:29:32,960
a generic um way to talk to

890
00:29:29,919 --> 00:29:34,960
labs so right now

891
00:29:32,960 --> 00:29:36,080
so there's uh there's a common line tool

892
00:29:34,960 --> 00:29:40,960
called uh

893
00:29:36,080 --> 00:29:43,279
kci test um

894
00:29:40,960 --> 00:29:44,159
if i show you so basically it's about

895
00:29:43,279 --> 00:29:46,159
the

896
00:29:44,159 --> 00:29:47,279
the bit when when we have a build and

897
00:29:46,159 --> 00:29:49,200
you go to the run

898
00:29:47,279 --> 00:29:50,399
box basically that's when you start to

899
00:29:49,200 --> 00:29:53,600
start the test

900
00:29:50,399 --> 00:29:55,918
so um right now we're using so this

901
00:29:53,600 --> 00:29:56,399
command line tool kci test is in python

902
00:29:55,919 --> 00:29:58,399
it does

903
00:29:56,399 --> 00:30:00,879
like an abstract class with some methods

904
00:29:58,399 --> 00:30:02,320
like there's one like to generate a test

905
00:30:00,880 --> 00:30:03,440
definition another one to submit the

906
00:30:02,320 --> 00:30:05,200
test definition

907
00:30:03,440 --> 00:30:06,720
and we could add other things like

908
00:30:05,200 --> 00:30:08,159
receive the result so right now the

909
00:30:06,720 --> 00:30:09,200
results are sent directly to the back

910
00:30:08,159 --> 00:30:14,000
end

911
00:30:09,200 --> 00:30:14,000
in some cases we could like have the

912
00:30:14,320 --> 00:30:18,639
test lab send a result back to a place

913
00:30:16,880 --> 00:30:19,840
where kci tests would be used as well to

914
00:30:18,640 --> 00:30:21,360
receive the results

915
00:30:19,840 --> 00:30:23,439
and process it and store it in a

916
00:30:21,360 --> 00:30:25,360
database so

917
00:30:23,440 --> 00:30:27,120
these are kind of the main primitive

918
00:30:25,360 --> 00:30:29,520
functions and

919
00:30:27,120 --> 00:30:31,360
to really have it work in practice we

920
00:30:29,520 --> 00:30:33,120
need to test it with more labs right now

921
00:30:31,360 --> 00:30:34,000
it's kind of only working with lava so

922
00:30:33,120 --> 00:30:35,918
it's still

923
00:30:34,000 --> 00:30:37,440
not very mature but that's basically

924
00:30:35,919 --> 00:30:39,279
where it's coming

925
00:30:37,440 --> 00:30:49,919
so i think we're running out of time yep

926
00:30:39,279 --> 00:30:49,919
thank you very much

