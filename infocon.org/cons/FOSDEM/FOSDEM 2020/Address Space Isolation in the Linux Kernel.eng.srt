1
00:00:05,359 --> 00:00:09,519
welcome everybody to uh

2
00:00:06,960 --> 00:00:11,360
next talk this talk is from mike and

3
00:00:09,519 --> 00:00:13,440
james who worked at ibm

4
00:00:11,360 --> 00:00:15,120
and they will give a talk about address

5
00:00:13,440 --> 00:00:18,000
space isolation

6
00:00:15,120 --> 00:00:19,119
um please when the talk finishes and the

7
00:00:18,000 --> 00:00:20,640
q a starts

8
00:00:19,119 --> 00:00:22,400
please remain seated it's not going to

9
00:00:20,640 --> 00:00:24,320
take long and we can

10
00:00:22,400 --> 00:00:26,159
hear the questions and then afterwards

11
00:00:24,320 --> 00:00:29,359
we can leave and don't disturb the

12
00:00:26,160 --> 00:00:30,560
q a for next one i'll give the warm

13
00:00:29,359 --> 00:00:32,960
welcome to these people

14
00:00:30,560 --> 00:00:34,960
please give a warm plows and this is

15
00:00:32,960 --> 00:00:39,760
yours

16
00:00:34,960 --> 00:00:43,440
[Applause]

17
00:00:39,760 --> 00:00:45,519
thanks i'm mike i work on a

18
00:00:43,440 --> 00:00:46,800
memory management in linux kernel i

19
00:00:45,520 --> 00:00:48,800
happen to maintain

20
00:00:46,800 --> 00:00:50,078
a boot time memory management called

21
00:00:48,800 --> 00:00:54,239
memblock

22
00:00:50,079 --> 00:00:57,280
and i'm an employee of ibm research

23
00:00:54,239 --> 00:00:59,199
and we are going to talk about

24
00:00:57,280 --> 00:01:00,559
our research how to use memory

25
00:00:59,199 --> 00:01:02,559
management techniques

26
00:01:00,559 --> 00:01:04,319
to make containers even more secure than

27
00:01:02,559 --> 00:01:07,360
they are today

28
00:01:04,319 --> 00:01:08,880
okay and i'm james my job

29
00:01:07,360 --> 00:01:11,600
in all of this was really just to

30
00:01:08,880 --> 00:01:13,280
persuade mike that it was worth doing

31
00:01:11,600 --> 00:01:15,039
and since i gave a talk this morning my

32
00:01:13,280 --> 00:01:16,400
voice isn't doing too well so he's going

33
00:01:15,040 --> 00:01:17,439
to be doing all the talking telling you

34
00:01:16,400 --> 00:01:18,960
what it's about

35
00:01:17,439 --> 00:01:20,479
i'm going to be the demo monkey because

36
00:01:18,960 --> 00:01:22,320
we have a demo right in the middle

37
00:01:20,479 --> 00:01:24,560
explaining how this all works in

38
00:01:22,320 --> 00:01:25,758
practice and so with that i'll hand over

39
00:01:24,560 --> 00:01:29,040
to mike to do the slides

40
00:01:25,759 --> 00:01:32,320
thank you so

41
00:01:29,040 --> 00:01:35,759
er it took

42
00:01:32,320 --> 00:01:38,960
a couple of years to get from ch root to

43
00:01:35,759 --> 00:01:42,240
cloud native and

44
00:01:38,960 --> 00:01:44,720
the containers as you probably know is

45
00:01:42,240 --> 00:01:46,240
can can be described the kind of siege

46
00:01:44,720 --> 00:01:48,560
route on steroids

47
00:01:46,240 --> 00:01:49,759
and thanks to technologies like docker

48
00:01:48,560 --> 00:01:52,720
and kubernetes

49
00:01:49,759 --> 00:01:54,960
containers now everywhere it's probably

50
00:01:52,720 --> 00:01:58,880
the most popular

51
00:01:54,960 --> 00:01:58,880
form of application deployment

52
00:01:59,360 --> 00:02:06,799
and you may find the containers

53
00:02:03,439 --> 00:02:09,440
deployments in that or other form

54
00:02:06,799 --> 00:02:11,200
in both in private data centers and in

55
00:02:09,440 --> 00:02:14,879
public clouds

56
00:02:11,200 --> 00:02:16,640
uh if you noticed if you used container

57
00:02:14,879 --> 00:02:20,160
a services in public

58
00:02:16,640 --> 00:02:22,640
clouds they all run their kubernetes

59
00:02:20,160 --> 00:02:27,040
clusters on top virtual machines

60
00:02:22,640 --> 00:02:30,559
which creates kind of unnecessary

61
00:02:27,040 --> 00:02:34,640
level of virtualization which

62
00:02:30,560 --> 00:02:36,959
obviously costs additional money cycles

63
00:02:34,640 --> 00:02:40,000
performance and so on

64
00:02:36,959 --> 00:02:40,959
one of the claims and to use virtual

65
00:02:40,000 --> 00:02:42,879
machines to run

66
00:02:40,959 --> 00:02:44,640
container installations because the

67
00:02:42,879 --> 00:02:48,560
containers are less secure than

68
00:02:44,640 --> 00:02:51,200
virtual machines and proponents of

69
00:02:48,560 --> 00:02:53,120
this claim usually saying guys come on a

70
00:02:51,200 --> 00:02:56,079
virtual machines have hardware that

71
00:02:53,120 --> 00:02:56,640
ensures their security and like we all

72
00:02:56,080 --> 00:02:58,959
know

73
00:02:56,640 --> 00:02:59,920
with meltdown l1tf and everything

74
00:02:58,959 --> 00:03:03,040
harvard probably

75
00:02:59,920 --> 00:03:06,159
not as good to ensure security for

76
00:03:03,040 --> 00:03:08,319
anything particularly with l1tf vms are

77
00:03:06,159 --> 00:03:11,120
much more vulnerable than

78
00:03:08,319 --> 00:03:12,958
containers or simple processes

79
00:03:11,120 --> 00:03:15,599
nevertheless

80
00:03:12,959 --> 00:03:16,800
as the researchers we were looking at

81
00:03:15,599 --> 00:03:19,920
interesting problems

82
00:03:16,800 --> 00:03:21,440
and we said okay we also can use some

83
00:03:19,920 --> 00:03:22,720
hardware to ensure isolation of

84
00:03:21,440 --> 00:03:25,840
containers

85
00:03:22,720 --> 00:03:26,879
and what we have is mmu so we will try

86
00:03:25,840 --> 00:03:29,519
to use mmu

87
00:03:26,879 --> 00:03:33,200
and to protect linux containers within

88
00:03:29,519 --> 00:03:37,840
page tables

89
00:03:33,200 --> 00:03:42,000
our goal is to make a containers

90
00:03:37,840 --> 00:03:42,000
less vulnerable and

91
00:03:42,239 --> 00:03:47,280
besides we can presume that

92
00:03:45,680 --> 00:03:48,799
every system will be vulnerable in that

93
00:03:47,280 --> 00:03:51,200
way only

94
00:03:48,799 --> 00:03:52,400
so once an attacker has gained some

95
00:03:51,200 --> 00:03:54,958
control of the system

96
00:03:52,400 --> 00:03:57,200
we are trying to make sure it will be

97
00:03:54,959 --> 00:04:00,239
harder for him or her

98
00:03:57,200 --> 00:04:02,640
to penetrate to

99
00:04:00,239 --> 00:04:05,200
containers of other tenants sharing the

100
00:04:02,640 --> 00:04:05,200
same system

101
00:04:05,920 --> 00:04:14,480
for that we are proposing

102
00:04:09,360 --> 00:04:17,519
to use restricted address spaces in

103
00:04:14,480 --> 00:04:21,519
to allow a better isolation of

104
00:04:17,519 --> 00:04:24,560
a con of privileged context of different

105
00:04:21,519 --> 00:04:27,120
tenants in the system

106
00:04:24,560 --> 00:04:27,120
and

107
00:04:27,759 --> 00:04:34,080
the container surface attack surface

108
00:04:31,120 --> 00:04:35,600
is the entire system called interface of

109
00:04:34,080 --> 00:04:38,880
linux kernel which about

110
00:04:35,600 --> 00:04:39,759
400 plus system calls so the first

111
00:04:38,880 --> 00:04:42,560
question

112
00:04:39,759 --> 00:04:43,040
question we asked ourselves was what can

113
00:04:42,560 --> 00:04:46,479
we do

114
00:04:43,040 --> 00:04:49,680
to make system call less vulnerable

115
00:04:46,479 --> 00:04:52,880
or at least less exposing the rest of

116
00:04:49,680 --> 00:04:55,919
the system to the attacker

117
00:04:52,880 --> 00:04:56,159
and the other thing we've been thinking

118
00:04:55,919 --> 00:05:01,520
of

119
00:04:56,160 --> 00:05:04,880
is that in linux containers isolated

120
00:05:01,520 --> 00:05:07,198
mostly using linux namespaces

121
00:05:04,880 --> 00:05:08,719
so what we are trying to do is to

122
00:05:07,199 --> 00:05:12,000
provide namespaces

123
00:05:08,720 --> 00:05:13,280
their mean of hardware isolation and in

124
00:05:12,000 --> 00:05:15,840
other words we're trying to

125
00:05:13,280 --> 00:05:16,880
broader namespaces with their own page

126
00:05:15,840 --> 00:05:19,599
tables

127
00:05:16,880 --> 00:05:20,479
and we'll explain in a bit more detail

128
00:05:19,600 --> 00:05:23,600
what we are trying

129
00:05:20,479 --> 00:05:27,520
what we are trying to achieve

130
00:05:23,600 --> 00:05:31,039
and there is a similar work that's done

131
00:05:27,520 --> 00:05:31,520
and some of it is already there and all

132
00:05:31,039 --> 00:05:34,320
of you

133
00:05:31,520 --> 00:05:36,240
probably know that as a result of

134
00:05:34,320 --> 00:05:38,320
meltdown vulnerability

135
00:05:36,240 --> 00:05:40,160
linux kernel and started using

136
00:05:38,320 --> 00:05:43,199
restricted address namespaces for the

137
00:05:40,160 --> 00:05:46,560
first time which is page table isolation

138
00:05:43,199 --> 00:05:49,680
and there is a work on going at

139
00:05:46,560 --> 00:05:52,960
a kvm area to

140
00:05:49,680 --> 00:05:53,919
protect virtual memories from the host

141
00:05:52,960 --> 00:05:56,638
and from

142
00:05:53,919 --> 00:05:58,880
each other that also tried to implement

143
00:05:56,639 --> 00:06:03,199
address-based isolation in kvm

144
00:05:58,880 --> 00:06:06,719
and another another mechanism that was

145
00:06:03,199 --> 00:06:09,280
dubbed as a process local memory

146
00:06:06,720 --> 00:06:10,560
to ensure that vm secrets are visible

147
00:06:09,280 --> 00:06:12,479
only to that vm and

148
00:06:10,560 --> 00:06:15,440
are not visible in the hostile in the

149
00:06:12,479 --> 00:06:15,440
other virtual machines

150
00:06:15,520 --> 00:06:20,639
so what we tried first

151
00:06:18,720 --> 00:06:23,919
is to create a restricted address space

152
00:06:20,639 --> 00:06:27,199
for execution of a system call

153
00:06:23,919 --> 00:06:30,000
it builds on the technology pti

154
00:06:27,199 --> 00:06:32,240
introduced into the linux kernel where

155
00:06:30,000 --> 00:06:32,240
the

156
00:06:33,039 --> 00:06:37,919
kernel mappings are very much restricted

157
00:06:36,800 --> 00:06:41,440
for the user space

158
00:06:37,919 --> 00:06:43,758
and part of the application and

159
00:06:41,440 --> 00:06:44,800
the only thing user space the page

160
00:06:43,759 --> 00:06:47,280
tables contain

161
00:06:44,800 --> 00:06:48,160
are the code necessary to jump into the

162
00:06:47,280 --> 00:06:51,440
system called

163
00:06:48,160 --> 00:06:52,400
to the interrupt handler we thought that

164
00:06:51,440 --> 00:06:55,360
probably would

165
00:06:52,400 --> 00:06:55,919
make sense to extend this a bit and to

166
00:06:55,360 --> 00:06:58,400
make

167
00:06:55,919 --> 00:06:59,840
a system call execution inside the linux

168
00:06:58,400 --> 00:07:02,239
kernel also use

169
00:06:59,840 --> 00:07:02,960
some very minimalistic page table and

170
00:07:02,240 --> 00:07:06,960
then

171
00:07:02,960 --> 00:07:11,440
map required pages on demand

172
00:07:06,960 --> 00:07:11,440
so it would be something like james

173
00:07:12,800 --> 00:07:19,360
oh so this

174
00:07:16,000 --> 00:07:21,919
is a page table of the kernel part

175
00:07:19,360 --> 00:07:22,880
of the process this is a page table of

176
00:07:21,919 --> 00:07:25,520
the user

177
00:07:22,880 --> 00:07:27,120
part of the process and the privileged

178
00:07:25,520 --> 00:07:29,919
code and data are not mapped

179
00:07:27,120 --> 00:07:30,800
in the user space page table except for

180
00:07:29,919 --> 00:07:34,080
the

181
00:07:30,800 --> 00:07:35,199
small part if required for entering into

182
00:07:34,080 --> 00:07:38,318
the kernel

183
00:07:35,199 --> 00:07:38,639
and we introduced yet another page table

184
00:07:38,319 --> 00:07:42,319
that

185
00:07:38,639 --> 00:07:46,400
adds some code that allows

186
00:07:42,319 --> 00:07:48,160
code and data that allows selection of a

187
00:07:46,400 --> 00:07:51,039
particular system called

188
00:07:48,160 --> 00:07:51,840
execution and then when system call

189
00:07:51,039 --> 00:07:55,199
continues

190
00:07:51,840 --> 00:07:58,560
its execution and we try to

191
00:07:55,199 --> 00:08:01,360
demand page a with whatever code of data

192
00:07:58,560 --> 00:08:01,360
is necessary

193
00:08:02,479 --> 00:08:07,599
the idea was that whenever we enter

194
00:08:05,039 --> 00:08:10,719
system call the switch in other space

195
00:08:07,599 --> 00:08:11,520
and then we remain in a restricted

196
00:08:10,720 --> 00:08:14,720
address space

197
00:08:11,520 --> 00:08:16,878
and every access to unmapped area causes

198
00:08:14,720 --> 00:08:18,639
page fault and page fault handler can

199
00:08:16,879 --> 00:08:21,840
decide if they access safe

200
00:08:18,639 --> 00:08:23,199
or not if the access is not safe we kill

201
00:08:21,840 --> 00:08:25,840
the offender

202
00:08:23,199 --> 00:08:28,400
and if access is considered safe we map

203
00:08:25,840 --> 00:08:32,079
the page and continue the execution

204
00:08:28,400 --> 00:08:35,279
we actually implemented this thing

205
00:08:32,080 --> 00:08:38,719
and i think here the

206
00:08:35,279 --> 00:08:42,000
patches and we found out

207
00:08:38,719 --> 00:08:44,800
this really slow like two times

208
00:08:42,000 --> 00:08:45,519
slower than normal system call execution

209
00:08:44,800 --> 00:08:50,719
and

210
00:08:45,519 --> 00:08:54,240
that context switch are really costly

211
00:08:50,720 --> 00:08:54,880
and also it has some security weaknesses

212
00:08:54,240 --> 00:08:57,920
as well

213
00:08:54,880 --> 00:09:00,720
and we couldn't validate red

214
00:08:57,920 --> 00:09:02,160
targets to actually prevent a rope

215
00:09:00,720 --> 00:09:05,279
attack properly

216
00:09:02,160 --> 00:09:07,279
and we were competing with upcoming cet

217
00:09:05,279 --> 00:09:09,279
technologies that probably eventually

218
00:09:07,279 --> 00:09:12,720
will be available sometime

219
00:09:09,279 --> 00:09:12,720
do you know anything about city

220
00:09:14,720 --> 00:09:18,720
intel has been promising it for several

221
00:09:16,720 --> 00:09:21,279
years it's supposed to be in their next

222
00:09:18,720 --> 00:09:23,600
chip but nobody's seen it

223
00:09:21,279 --> 00:09:24,959
intel city is going to do the same thing

224
00:09:23,600 --> 00:09:27,360
but in the harbor

225
00:09:24,959 --> 00:09:28,319
so if the chips will be available there

226
00:09:27,360 --> 00:09:32,080
is no sense in

227
00:09:28,320 --> 00:09:34,000
implementing our approach and

228
00:09:32,080 --> 00:09:35,600
but we also thought about another

229
00:09:34,000 --> 00:09:38,800
possibility we didn't try

230
00:09:35,600 --> 00:09:41,440
to implement anything that

231
00:09:38,800 --> 00:09:43,439
one can use f trace to create a shadow

232
00:09:41,440 --> 00:09:47,200
stack of the execution

233
00:09:43,440 --> 00:09:49,360
and then upon return from

234
00:09:47,200 --> 00:09:51,040
any routine and there is a possibility

235
00:09:49,360 --> 00:09:54,240
to insert

236
00:09:51,040 --> 00:09:56,640
red hunks using gcco level vm

237
00:09:54,240 --> 00:09:58,160
that's what red palin does for instance

238
00:09:56,640 --> 00:09:59,920
with the call

239
00:09:58,160 --> 00:10:01,360
it's possible to do the same thing with

240
00:09:59,920 --> 00:10:04,079
red and then

241
00:10:01,360 --> 00:10:04,480
at that thunks and there is a way to

242
00:10:04,079 --> 00:10:06,719
check

243
00:10:04,480 --> 00:10:07,839
if the return address actually matches

244
00:10:06,720 --> 00:10:10,480
the

245
00:10:07,839 --> 00:10:12,160
shadow stack created with an f-trace

246
00:10:10,480 --> 00:10:13,519
this should be faster than using the

247
00:10:12,160 --> 00:10:16,839
page fault for that

248
00:10:13,519 --> 00:10:18,720
and we don't know yet if it will fly at

249
00:10:16,839 --> 00:10:21,680
all

250
00:10:18,720 --> 00:10:25,200
and the next thing we were trying to do

251
00:10:21,680 --> 00:10:25,199
came actually from the idea

252
00:10:25,680 --> 00:10:29,760
some of the kvm developers proposed a

253
00:10:28,399 --> 00:10:33,120
while ago on the mailing list

254
00:10:29,760 --> 00:10:36,000
they call it process local memory

255
00:10:33,120 --> 00:10:36,640
what we are suggesting suggesting is to

256
00:10:36,000 --> 00:10:40,800
hide

257
00:10:36,640 --> 00:10:43,040
a piece of user process from the kernel

258
00:10:40,800 --> 00:10:44,079
and obviously it won't be mapped in

259
00:10:43,040 --> 00:10:48,160
other processes

260
00:10:44,079 --> 00:10:51,199
and so this memory can be used to store

261
00:10:48,160 --> 00:10:53,120
secrets for instance keys and maybe some

262
00:10:51,200 --> 00:10:56,079
other sensitive information

263
00:10:53,120 --> 00:10:58,320
another possible use case is to hide the

264
00:10:56,079 --> 00:10:59,120
virtual machine memory from the entire

265
00:10:58,320 --> 00:11:02,399
kernel

266
00:10:59,120 --> 00:11:02,399
and from the entire host

267
00:11:03,680 --> 00:11:07,599
and for instance for storing a secret

268
00:11:06,079 --> 00:11:10,959
this may be used in a

269
00:11:07,600 --> 00:11:14,000
way described here we create a mapping

270
00:11:10,959 --> 00:11:17,760
with a particular flags

271
00:11:14,000 --> 00:11:21,279
we open a secret file and

272
00:11:17,760 --> 00:11:24,000
then read its contents into that mapping

273
00:11:21,279 --> 00:11:25,200
and the pages are here if anybody is

274
00:11:24,000 --> 00:11:27,920
interested

275
00:11:25,200 --> 00:11:30,160
it was a long discussion about this

276
00:11:27,920 --> 00:11:31,839
approach about using a memory map with

277
00:11:30,160 --> 00:11:34,800
some flag

278
00:11:31,839 --> 00:11:35,279
the outcome more or less summarized here

279
00:11:34,800 --> 00:11:38,880
the

280
00:11:35,279 --> 00:11:41,120
pros were that it was relatively simple

281
00:11:38,880 --> 00:11:42,800
at least our submission was about 200

282
00:11:41,120 --> 00:11:46,640
lines of difference

283
00:11:42,800 --> 00:11:47,519
and it can be easily plugged into

284
00:11:46,640 --> 00:11:50,079
existing

285
00:11:47,519 --> 00:11:51,440
user space allocators and it can be

286
00:11:50,079 --> 00:11:53,839
easily plugged into

287
00:11:51,440 --> 00:11:56,959
existing applications with m advise and

288
00:11:53,839 --> 00:12:00,399
protect and such

289
00:11:56,959 --> 00:12:02,319
but at the downside

290
00:12:00,399 --> 00:12:03,600
the implementation has to take into

291
00:12:02,320 --> 00:12:06,959
account a

292
00:12:03,600 --> 00:12:07,680
various places of the memory management

293
00:12:06,959 --> 00:12:10,719
code

294
00:12:07,680 --> 00:12:12,638
to address the kind of the mapping

295
00:12:10,720 --> 00:12:15,040
and to see if for instance it is

296
00:12:12,639 --> 00:12:17,839
possible to do any advice on such an

297
00:12:15,040 --> 00:12:18,880
area or if it's possible to pipe into

298
00:12:17,839 --> 00:12:21,920
their

299
00:12:18,880 --> 00:12:25,839
splice and so on et cetera and the

300
00:12:21,920 --> 00:12:25,839
most significant

301
00:12:27,040 --> 00:12:30,639
disadvantage of this was the necessity

302
00:12:29,760 --> 00:12:32,480
to fragment

303
00:12:30,639 --> 00:12:34,160
the direct map kernel used to map the

304
00:12:32,480 --> 00:12:36,480
physical memory

305
00:12:34,160 --> 00:12:37,680
because whenever we create a special

306
00:12:36,480 --> 00:12:39,440
mapping

307
00:12:37,680 --> 00:12:41,680
in order to make it invisible for the

308
00:12:39,440 --> 00:12:44,560
kernel and for the privileged code

309
00:12:41,680 --> 00:12:46,079
we drop this may this memory from the

310
00:12:44,560 --> 00:12:49,518
direct map

311
00:12:46,079 --> 00:12:51,920
and it requires a splitting of

312
00:12:49,519 --> 00:12:55,200
large and very large pages that usually

313
00:12:51,920 --> 00:12:55,199
constitute the direct map

314
00:12:59,839 --> 00:13:02,800
i think okay

315
00:13:03,200 --> 00:13:10,160
so one of the feedbacks we've got

316
00:13:06,720 --> 00:13:12,240
on the map map exclusive suggestion

317
00:13:10,160 --> 00:13:13,920
was that it's probably better to use

318
00:13:12,240 --> 00:13:16,480
file descriptor or device

319
00:13:13,920 --> 00:13:18,079
a character device to create such secret

320
00:13:16,480 --> 00:13:21,120
mappings

321
00:13:18,079 --> 00:13:22,000
and we came with another version of the

322
00:13:21,120 --> 00:13:24,959
patch

323
00:13:22,000 --> 00:13:26,399
that actually extends the mfd mfd create

324
00:13:24,959 --> 00:13:29,839
system call

325
00:13:26,399 --> 00:13:31,519
so to create a secret area one has to

326
00:13:29,839 --> 00:13:35,519
create a file descriptor

327
00:13:31,519 --> 00:13:38,959
this mfd create secret

328
00:13:35,519 --> 00:13:42,320
and then you must

329
00:13:38,959 --> 00:13:42,880
call ioctl to specify exactly the way

330
00:13:42,320 --> 00:13:46,320
kernel

331
00:13:42,880 --> 00:13:50,480
would treat your memory it could be

332
00:13:46,320 --> 00:13:54,079
exclusive unmapped uncached maybe some

333
00:13:50,480 --> 00:13:57,360
other different properties there

334
00:13:54,079 --> 00:14:03,839
and then continue with map

335
00:13:57,360 --> 00:14:03,839
and use the memory in a secure way

336
00:14:05,040 --> 00:14:10,079
it has an advantage of less

337
00:14:08,240 --> 00:14:11,199
modifications to the core memory

338
00:14:10,079 --> 00:14:14,719
management

339
00:14:11,199 --> 00:14:18,399
we don't mark the allocated area

340
00:14:14,720 --> 00:14:21,839
with anything except vm specials so

341
00:14:18,399 --> 00:14:23,120
we won't wouldn't need to insert as many

342
00:14:21,839 --> 00:14:25,680
if something

343
00:14:23,120 --> 00:14:26,880
in the core mm it is possible to

344
00:14:25,680 --> 00:14:29,680
pre-allocate memory

345
00:14:26,880 --> 00:14:30,000
boot and then use it as a baking memory

346
00:14:29,680 --> 00:14:32,719
for

347
00:14:30,000 --> 00:14:34,480
such file descriptor based memory

348
00:14:32,720 --> 00:14:37,839
management

349
00:14:34,480 --> 00:14:38,959
we still would need to audit all the

350
00:14:37,839 --> 00:14:42,079
memory management

351
00:14:38,959 --> 00:14:45,518
code to make sure that

352
00:14:42,079 --> 00:14:46,638
nothing would try to access the secret

353
00:14:45,519 --> 00:14:50,959
memory and

354
00:14:46,639 --> 00:14:54,480
that the safety is preserved

355
00:14:50,959 --> 00:14:57,518
and as it sees file based

356
00:14:54,480 --> 00:15:00,480
memory management we are

357
00:14:57,519 --> 00:15:02,079
it it would use page cache mechanism in

358
00:15:00,480 --> 00:15:04,880
such way or another

359
00:15:02,079 --> 00:15:05,760
and the final implementation may

360
00:15:04,880 --> 00:15:08,079
introduce

361
00:15:05,760 --> 00:15:09,519
some complexities into page cache

362
00:15:08,079 --> 00:15:12,719
management

363
00:15:09,519 --> 00:15:14,800
and still we didn't address the huge gap

364
00:15:12,720 --> 00:15:16,240
of the fragmentation of the direct map

365
00:15:14,800 --> 00:15:19,519
which also may cause

366
00:15:16,240 --> 00:15:19,519
some pain in the future

367
00:15:19,600 --> 00:15:23,279
i've recorded it it's like just in case

368
00:15:22,399 --> 00:15:25,839
but now

369
00:15:23,279 --> 00:15:26,639
okay it's all yours my job is to be the

370
00:15:25,839 --> 00:15:28,560
demo monkey

371
00:15:26,639 --> 00:15:30,320
can i actually get this demo up and

372
00:15:28,560 --> 00:15:40,160
running let's just

373
00:15:30,320 --> 00:15:43,839
stop the presentation

374
00:15:40,160 --> 00:15:47,120
let's get a same as

375
00:15:43,839 --> 00:15:47,120
so i can see what i'm doing

376
00:15:52,839 --> 00:15:55,839
good

377
00:15:55,920 --> 00:16:01,599
let's bring up a genuine terminal how

378
00:15:58,079 --> 00:16:01,599
big does it need to be for you lord

379
00:16:03,279 --> 00:16:09,839
so everybody can see that let me

380
00:16:11,680 --> 00:16:15,920
yeah of course every tab you start also

381
00:16:13,680 --> 00:16:18,319
has to be sized great

382
00:16:15,920 --> 00:16:20,079
so mike actually sent the patch that

383
00:16:18,320 --> 00:16:23,279
does this to the mailing list

384
00:16:20,079 --> 00:16:24,959
what three days ago so i have built

385
00:16:23,279 --> 00:16:26,800
a five five kernel with this patch

386
00:16:24,959 --> 00:16:28,319
integrated and that's actually what i'm

387
00:16:26,800 --> 00:16:31,199
going to demo to you

388
00:16:28,320 --> 00:16:32,000
so uh ignore the fact this is ufi secure

389
00:16:31,199 --> 00:16:35,120
boot this is where

390
00:16:32,000 --> 00:16:37,120
i've got all my demo kernels

391
00:16:35,120 --> 00:16:39,839
so i'm just going to boot up this kernel

392
00:16:37,120 --> 00:16:39,839
in kvm

393
00:16:40,959 --> 00:16:44,239
and then once it's booted up i will log

394
00:16:43,120 --> 00:16:47,199
into it

395
00:16:44,240 --> 00:16:48,639
and we're going to try twice to poke at

396
00:16:47,199 --> 00:16:50,479
the memory of

397
00:16:48,639 --> 00:16:52,079
what should be a container but in order

398
00:16:50,480 --> 00:16:53,600
to convince you that this works

399
00:16:52,079 --> 00:16:54,880
generally i'm just going to do a normal

400
00:16:53,600 --> 00:16:56,800
ordinary process

401
00:16:54,880 --> 00:16:59,279
and prove that we can actually abstract

402
00:16:56,800 --> 00:16:59,279
secrets

403
00:16:59,839 --> 00:17:05,839
so if i just log into this system

404
00:17:08,480 --> 00:17:12,480
i actually have a very simple program

405
00:17:10,880 --> 00:17:14,000
that uses openssl

406
00:17:12,480 --> 00:17:16,240
one of the great things about using

407
00:17:14,000 --> 00:17:17,039
openssl is for reasons best known to the

408
00:17:16,240 --> 00:17:19,120
openssl

409
00:17:17,039 --> 00:17:21,199
developers they insisted on rewriting

410
00:17:19,119 --> 00:17:24,000
the body allocation interface for

411
00:17:21,199 --> 00:17:25,280
linux for glibc memory because they

412
00:17:24,000 --> 00:17:26,240
claimed it would make the program more

413
00:17:25,280 --> 00:17:28,559
secure

414
00:17:26,240 --> 00:17:30,960
so openssl malloc if you use it in an

415
00:17:28,559 --> 00:17:34,080
open ssl program and openssl does use it

416
00:17:30,960 --> 00:17:35,520
for all of the private keys

417
00:17:34,080 --> 00:17:37,520
should be actually giving you more

418
00:17:35,520 --> 00:17:39,039
security according to openssl

419
00:17:37,520 --> 00:17:41,280
realistically as will demonstrate it

420
00:17:39,039 --> 00:17:43,360
doesn't but one of the great things is

421
00:17:41,280 --> 00:17:45,360
i can just use a preload library to

422
00:17:43,360 --> 00:17:48,399
override openssl malloc

423
00:17:45,360 --> 00:17:50,799
and insert our special allocation thing

424
00:17:48,400 --> 00:17:53,039
into their body allocator and then open

425
00:17:50,799 --> 00:17:55,120
ssl malik is really allocating all of

426
00:17:53,039 --> 00:17:56,879
your private keys and secure memory

427
00:17:55,120 --> 00:17:58,879
and so the purpose of this demonstration

428
00:17:56,880 --> 00:18:01,840
is a very very simple program

429
00:17:58,880 --> 00:18:01,840
to actually do that

430
00:18:04,880 --> 00:18:10,640
very hands so this is it it's basically

431
00:18:08,480 --> 00:18:12,799
i allocate a secure pointer using the

432
00:18:10,640 --> 00:18:14,720
openssl malloc i allocate an insecure

433
00:18:12,799 --> 00:18:16,480
pointer using the standard linux malloc

434
00:18:14,720 --> 00:18:18,480
i copy two strings into each of these

435
00:18:16,480 --> 00:18:20,400
pointers and i print them out again

436
00:18:18,480 --> 00:18:21,600
this is obviously highly insecure if you

437
00:18:20,400 --> 00:18:23,600
have access to the console

438
00:18:21,600 --> 00:18:25,280
but it serves as a demonstration the

439
00:18:23,600 --> 00:18:27,039
reason for printing it out again is to

440
00:18:25,280 --> 00:18:28,879
prove that the process itself can still

441
00:18:27,039 --> 00:18:30,480
get access to memory with designated

442
00:18:28,880 --> 00:18:33,840
secure

443
00:18:30,480 --> 00:18:35,679
and if i actually just oh and um

444
00:18:33,840 --> 00:18:37,520
usually when you're dealing with secrets

445
00:18:35,679 --> 00:18:40,000
the trick is to get the secret in

446
00:18:37,520 --> 00:18:41,600
use it and shred it as fast as possible

447
00:18:40,000 --> 00:18:44,240
in order to demonstrate

448
00:18:41,600 --> 00:18:44,719
the actual program working i put a pause

449
00:18:44,240 --> 00:18:46,799
in here

450
00:18:44,720 --> 00:18:48,400
that allows me to go in and actually try

451
00:18:46,799 --> 00:18:51,679
and extract the secret

452
00:18:48,400 --> 00:18:53,679
so if i run this program

453
00:18:51,679 --> 00:18:55,360
it's going to print out the two pointers

454
00:18:53,679 --> 00:18:58,080
so i mean i haven't

455
00:18:55,360 --> 00:19:01,678
done an ld so override so this is only

456
00:18:58,080 --> 00:19:01,678
open ssl's protection

457
00:19:02,400 --> 00:19:06,160
and what i'm going to do is i'm going to

458
00:19:04,320 --> 00:19:07,918
use the biggest hammer i can possibly do

459
00:19:06,160 --> 00:19:10,960
which is log into the virtual machine as

460
00:19:07,919 --> 00:19:15,200
root and see if i can extract the secret

461
00:19:10,960 --> 00:19:15,200
so all i have to do is find the process

462
00:19:16,080 --> 00:19:25,840
there it is and then i can just ask

463
00:19:20,320 --> 00:19:25,840
gdb to attach to it

464
00:19:28,320 --> 00:19:33,678
which it does with no problem it's stuck

465
00:19:30,720 --> 00:19:33,679
at pause so i just

466
00:19:36,840 --> 00:19:39,840
sorry

467
00:19:40,480 --> 00:19:44,640
okay so i go up in the stack frame and

468
00:19:43,200 --> 00:19:46,960
now i can actually print out the

469
00:19:44,640 --> 00:19:49,360
pointers

470
00:19:46,960 --> 00:19:51,200
so here's the insecure pointer this is

471
00:19:49,360 --> 00:19:52,719
i'm running as root so i can easily grab

472
00:19:51,200 --> 00:19:56,080
about in anybody's memory

473
00:19:52,720 --> 00:19:56,080
and here's the secure pointer

474
00:19:58,000 --> 00:20:01,600
so i can just as root extract all

475
00:20:00,640 --> 00:20:04,080
secrets from

476
00:20:01,600 --> 00:20:04,879
the system so if i managed to compromise

477
00:20:04,080 --> 00:20:06,879
the system

478
00:20:04,880 --> 00:20:08,159
sufficiently i could also do the secret

479
00:20:06,880 --> 00:20:10,000
extraction

480
00:20:08,159 --> 00:20:10,320
so now what we're going to do is leave

481
00:20:10,000 --> 00:20:12,000
this

482
00:20:10,320 --> 00:20:15,280
[Music]

483
00:20:12,000 --> 00:20:15,280
i'll come out here

484
00:20:17,840 --> 00:20:23,520
kill this and now i'm just going to

485
00:20:21,679 --> 00:20:25,520
add a preload that overrides the open

486
00:20:23,520 --> 00:20:27,120
ssl malloc let me actually

487
00:20:25,520 --> 00:20:29,200
show you roughly what the preload looks

488
00:20:27,120 --> 00:20:31,360
like it's basically the same

489
00:20:29,200 --> 00:20:32,720
program mike showed you so all it's

490
00:20:31,360 --> 00:20:35,520
doing is getting a secret

491
00:20:32,720 --> 00:20:36,000
memory thing it's mapping a single page

492
00:20:35,520 --> 00:20:38,480
and it's

493
00:20:36,000 --> 00:20:39,760
putting that page in a secure pool and

494
00:20:38,480 --> 00:20:42,159
when you call

495
00:20:39,760 --> 00:20:44,158
open ssl malloc it just returns the page

496
00:20:42,159 --> 00:20:45,760
this obviously is not a body allocator

497
00:20:44,159 --> 00:20:47,520
but for the purpose of demonstration

498
00:20:45,760 --> 00:20:49,520
where we only have a single allocation

499
00:20:47,520 --> 00:20:51,200
it demonstrates all of the principles

500
00:20:49,520 --> 00:20:52,639
and obviously if i'm going to do this in

501
00:20:51,200 --> 00:20:53,919
practice i would have actually written

502
00:20:52,640 --> 00:20:55,760
the buddy allocator

503
00:20:53,919 --> 00:20:59,039
but i did this on fly last night and i

504
00:20:55,760 --> 00:21:00,879
couldn't be bothered so

505
00:20:59,039 --> 00:21:02,080
let's apply the preload and again the

506
00:21:00,880 --> 00:21:04,240
program runs

507
00:21:02,080 --> 00:21:06,320
i actually if you looked put a debugging

508
00:21:04,240 --> 00:21:08,640
print in the open ssl

509
00:21:06,320 --> 00:21:10,240
malloc override so we know that the

510
00:21:08,640 --> 00:21:12,799
secure pointer is now

511
00:21:10,240 --> 00:21:14,080
actually in mike's secure memory so what

512
00:21:12,799 --> 00:21:17,840
we're going to do

513
00:21:14,080 --> 00:21:17,840
is find it again

514
00:21:19,440 --> 00:21:22,799
attach to it with gdb

515
00:21:27,280 --> 00:21:33,840
okay go up and obviously

516
00:21:32,320 --> 00:21:35,520
the insecure pointer was only an

517
00:21:33,840 --> 00:21:37,280
ordinary malloc memory so i should still

518
00:21:35,520 --> 00:21:38,960
be able to get access to it

519
00:21:37,280 --> 00:21:41,039
but now let's see what happens if i

520
00:21:38,960 --> 00:21:43,360
actually try to grab about in here

521
00:21:41,039 --> 00:21:44,960
and get access to the secure pointer my

522
00:21:43,360 --> 00:21:47,120
program is killed

523
00:21:44,960 --> 00:21:50,000
and if i actually have a look at what

524
00:21:47,120 --> 00:21:50,000
happened to the kernel

525
00:21:50,159 --> 00:21:57,039
that is a paging fault in the direct map

526
00:21:54,240 --> 00:21:59,039
so even root on this machine cannot get

527
00:21:57,039 --> 00:22:00,799
access to the secrets that a process

528
00:21:59,039 --> 00:22:03,919
deposited into

529
00:22:00,799 --> 00:22:04,240
its memory and so this affords us a lot

530
00:22:03,919 --> 00:22:07,039
of

531
00:22:04,240 --> 00:22:07,600
useful secrecy for things like openssl

532
00:22:07,039 --> 00:22:10,840
keys

533
00:22:07,600 --> 00:22:13,840
https establishing secure channels in

534
00:22:10,840 --> 00:22:13,840
containers

535
00:22:14,240 --> 00:22:20,080
yeah sure so as we can easily see right

536
00:22:16,880 --> 00:22:20,080
the page is not present here

537
00:22:20,240 --> 00:22:23,440
back to the presentation back to the

538
00:22:21,840 --> 00:22:27,840
presentation okay

539
00:22:23,440 --> 00:22:27,840
let me just

540
00:22:29,679 --> 00:22:34,159
and yeah i know you want it bigger

541
00:22:34,480 --> 00:22:36,799
thanks

542
00:22:37,520 --> 00:22:41,120
now another another thing we are trying

543
00:22:39,280 --> 00:22:42,480
to do is to protect address spaces with

544
00:22:41,120 --> 00:22:45,520
namespaces

545
00:22:42,480 --> 00:22:49,039
namespaces with address spaces and

546
00:22:45,520 --> 00:22:52,400
and namespaces in linux anyway create

547
00:22:49,039 --> 00:22:54,158
their objects in a way that is

548
00:22:52,400 --> 00:22:55,520
is isolated from the rest of the system

549
00:22:54,159 --> 00:22:58,799
so there is no actual

550
00:22:55,520 --> 00:23:00,480
need for a kernel code running in one

551
00:22:58,799 --> 00:23:04,080
namespace to access objects in the

552
00:23:00,480 --> 00:23:06,559
or any objects in the other namespace

553
00:23:04,080 --> 00:23:08,240
and that's why we think it would be

554
00:23:06,559 --> 00:23:10,158
possible to give

555
00:23:08,240 --> 00:23:12,960
each and every name space its own page

556
00:23:10,159 --> 00:23:16,159
table and then just

557
00:23:12,960 --> 00:23:17,840
take care of some rare cases of

558
00:23:16,159 --> 00:23:19,679
namespace transition for different

559
00:23:17,840 --> 00:23:22,158
objects

560
00:23:19,679 --> 00:23:22,720
we've started with the network namespace

561
00:23:22,159 --> 00:23:26,000
and

562
00:23:22,720 --> 00:23:27,440
network namespace creates a known copy

563
00:23:26,000 --> 00:23:31,200
of the entire network stack

564
00:23:27,440 --> 00:23:33,039
tcp caches udp caches sockets everything

565
00:23:31,200 --> 00:23:34,720
they're all private to that network

566
00:23:33,039 --> 00:23:38,000
namespace there is no

567
00:23:34,720 --> 00:23:39,360
need for any other namespace to touch

568
00:23:38,000 --> 00:23:42,320
the data

569
00:23:39,360 --> 00:23:43,279
in the caches of the network stack of

570
00:23:42,320 --> 00:23:46,320
other namespace

571
00:23:43,279 --> 00:23:47,039
the only the only thing that behaves

572
00:23:46,320 --> 00:23:50,158
different

573
00:23:47,039 --> 00:23:53,440
differently is ascii maps which

574
00:23:50,159 --> 00:23:56,400
represent packets that usually traverse

575
00:23:53,440 --> 00:23:57,360
several namespaces on their way to other

576
00:23:56,400 --> 00:24:04,480
services

577
00:23:57,360 --> 00:24:07,439
out of the machine or into the machine

578
00:24:04,480 --> 00:24:08,640
and and then we started working on this

579
00:24:07,440 --> 00:24:11,200
and

580
00:24:08,640 --> 00:24:13,279
more or less at the same time kvm

581
00:24:11,200 --> 00:24:18,240
developers submitted their work for

582
00:24:13,279 --> 00:24:21,360
what they call kvm isi and

583
00:24:18,240 --> 00:24:23,840
one of the comments for their for their

584
00:24:21,360 --> 00:24:25,918
submissions from thomas glexner one of

585
00:24:23,840 --> 00:24:28,320
x86 maintainers

586
00:24:25,919 --> 00:24:29,200
was that there are actually four points

587
00:24:28,320 --> 00:24:33,120
to creation

588
00:24:29,200 --> 00:24:35,919
of restricted namespaces and there need

589
00:24:33,120 --> 00:24:36,959
to be a way to create restricted mapping

590
00:24:35,919 --> 00:24:39,679
there need to be

591
00:24:36,960 --> 00:24:40,880
a way to switch into it and switch back

592
00:24:39,679 --> 00:24:44,240
to it

593
00:24:40,880 --> 00:24:46,000
and there should be some

594
00:24:44,240 --> 00:24:48,480
machinery to track the state to

595
00:24:46,000 --> 00:24:51,840
understand so the code could understand

596
00:24:48,480 --> 00:24:55,200
which and which address space it is

597
00:24:51,840 --> 00:24:58,399
actually using at the moment and then

598
00:24:55,200 --> 00:24:58,840
together with the kvm guys we started to

599
00:24:58,400 --> 00:25:02,080
work

600
00:24:58,840 --> 00:25:04,320
on some generic apis

601
00:25:02,080 --> 00:25:06,879
that will allow usage of restricted

602
00:25:04,320 --> 00:25:10,480
address spaces in the kernel

603
00:25:06,880 --> 00:25:10,960
and first of all the api for creation of

604
00:25:10,480 --> 00:25:14,240
the

605
00:25:10,960 --> 00:25:17,600
page tables and

606
00:25:14,240 --> 00:25:18,720
what we thought is that we need a first

607
00:25:17,600 --> 00:25:21,120
class abstraction

608
00:25:18,720 --> 00:25:23,440
for a kernel page table which is

609
00:25:21,120 --> 00:25:26,158
non-existent as of today

610
00:25:23,440 --> 00:25:27,520
the kernel presumes that everything

611
00:25:26,159 --> 00:25:30,799
every address space

612
00:25:27,520 --> 00:25:31,440
has its mm struct that actually used to

613
00:25:30,799 --> 00:25:34,799
represent

614
00:25:31,440 --> 00:25:36,559
user's user process memory it has a lot

615
00:25:34,799 --> 00:25:38,480
of information that is not necessary to

616
00:25:36,559 --> 00:25:40,879
represent the kernel page table

617
00:25:38,480 --> 00:25:43,520
so what we're trying to do is to extract

618
00:25:40,880 --> 00:25:44,640
a page table information proper from a

619
00:25:43,520 --> 00:25:46,480
mem struct and

620
00:25:44,640 --> 00:25:49,279
create a first class abstraction we call

621
00:25:46,480 --> 00:25:52,080
it pg table for now

622
00:25:49,279 --> 00:25:52,559
it may evolve with the this time gun it

623
00:25:52,080 --> 00:25:55,678
was

624
00:25:52,559 --> 00:25:56,000
and then we need some api to populate

625
00:25:55,679 --> 00:25:58,880
this

626
00:25:56,000 --> 00:26:00,080
pg table and we need an api that will be

627
00:25:58,880 --> 00:26:04,559
able to tear down this

628
00:26:00,080 --> 00:26:07,678
pg table the

629
00:26:04,559 --> 00:26:11,200
context creation varies in

630
00:26:07,679 --> 00:26:13,919
between different use cases kvm guys

631
00:26:11,200 --> 00:26:14,880
have it explicit on the vm interview

632
00:26:13,919 --> 00:26:17,919
exit

633
00:26:14,880 --> 00:26:19,919
with a network namespace address with

634
00:26:17,919 --> 00:26:22,720
the address basis of processes

635
00:26:19,919 --> 00:26:24,240
it becomes implicit as a part of the

636
00:26:22,720 --> 00:26:27,039
context which

637
00:26:24,240 --> 00:26:27,840
is just the page table of particular

638
00:26:27,039 --> 00:26:30,720
context

639
00:26:27,840 --> 00:26:31,199
is reduced and because it is already

640
00:26:30,720 --> 00:26:34,159
there

641
00:26:31,200 --> 00:26:36,640
inside the namespace or because of some

642
00:26:34,159 --> 00:26:36,640
other reason

643
00:26:36,840 --> 00:26:42,158
and

644
00:26:39,840 --> 00:26:43,039
and the freeing the restricted page

645
00:26:42,159 --> 00:26:46,559
table is

646
00:26:43,039 --> 00:26:50,400
kind of pain in the whatever

647
00:26:46,559 --> 00:26:52,879
because currently the

648
00:26:50,400 --> 00:26:54,159
code in the kernels that actually freeze

649
00:26:52,880 --> 00:26:57,360
page table

650
00:26:54,159 --> 00:26:58,240
very tightly bound to the mm struct and

651
00:26:57,360 --> 00:27:01,360
to the assumption

652
00:26:58,240 --> 00:27:04,480
that kernel page tables are never freed

653
00:27:01,360 --> 00:27:07,600
and there is a lot of care that must be

654
00:27:04,480 --> 00:27:10,559
taken in front page tables and to

655
00:27:07,600 --> 00:27:11,760
probably play pro properly play with the

656
00:27:10,559 --> 00:27:16,399
atlbs and

657
00:27:11,760 --> 00:27:17,360
to avoid tlb shoot downs as much as

658
00:27:16,400 --> 00:27:18,799
possible and

659
00:27:17,360 --> 00:27:21,840
there is a lot of work we are going to

660
00:27:18,799 --> 00:27:21,840
do in that area

661
00:27:23,760 --> 00:27:26,480
what did i do

662
00:27:27,840 --> 00:27:32,399
you should warn me

663
00:27:30,170 --> 00:27:35,120
[Music]

664
00:27:32,399 --> 00:27:36,559
so on top of these page table management

665
00:27:35,120 --> 00:27:37,840
primitives that we are going to

666
00:27:36,559 --> 00:27:41,200
implement someday

667
00:27:37,840 --> 00:27:42,720
we are trying to implement a private

668
00:27:41,200 --> 00:27:45,919
memory management allocation

669
00:27:42,720 --> 00:27:48,000
private memory allocations that page

670
00:27:45,919 --> 00:27:50,559
allocate malloc will receive

671
00:27:48,000 --> 00:27:51,520
a particular flag that will say okay i

672
00:27:50,559 --> 00:27:54,158
want this page

673
00:27:51,520 --> 00:27:56,960
visible only in my page table and i want

674
00:27:54,159 --> 00:27:59,279
it absent in all the other page tables

675
00:27:56,960 --> 00:28:03,840
and i want it dropped out of there from

676
00:27:59,279 --> 00:28:03,840
the direct map

677
00:28:04,640 --> 00:28:11,039
and so the idea was to add

678
00:28:08,000 --> 00:28:14,559
some page flags for struct page

679
00:28:11,039 --> 00:28:17,600
and some flux for struct slab and

680
00:28:14,559 --> 00:28:20,720
as we got a pretty much

681
00:28:17,600 --> 00:28:22,080
of pushback on using new page flux on

682
00:28:20,720 --> 00:28:24,320
our first submission of

683
00:28:22,080 --> 00:28:26,720
em up exclusive we'll need to think

684
00:28:24,320 --> 00:28:30,879
about some different way probably using

685
00:28:26,720 --> 00:28:34,159
a page extension for this mechanism

686
00:28:30,880 --> 00:28:37,600
and then we can use existing interface

687
00:28:34,159 --> 00:28:40,799
to tweak in the direct map like

688
00:28:37,600 --> 00:28:43,199
set memory and p and set memory p which

689
00:28:40,799 --> 00:28:44,559
makes my pages present or not present in

690
00:28:43,200 --> 00:28:47,279
the direct map

691
00:28:44,559 --> 00:28:50,240
and again despite the availability of

692
00:28:47,279 --> 00:28:50,240
this interface

693
00:28:50,399 --> 00:28:55,520
it is really not good to use it because

694
00:28:53,520 --> 00:28:57,679
it will fragment the direct memory

695
00:28:55,520 --> 00:28:58,879
memory and there is some groundwork

696
00:28:57,679 --> 00:29:01,840
required

697
00:28:58,880 --> 00:29:02,880
to properly implement direct map

698
00:29:01,840 --> 00:29:06,399
manipulations

699
00:29:02,880 --> 00:29:09,440
and maybe doing something like php for

700
00:29:06,399 --> 00:29:09,439
direct memory as well

701
00:29:11,120 --> 00:29:18,399
and for the private allocations using

702
00:29:14,480 --> 00:29:20,640
a k malloc and this family

703
00:29:18,399 --> 00:29:22,799
came mk charlotte we are proposing

704
00:29:20,640 --> 00:29:25,919
mechanism which is similar to what

705
00:29:22,799 --> 00:29:26,559
memory c group is currently doing and we

706
00:29:25,919 --> 00:29:28,720
create

707
00:29:26,559 --> 00:29:30,559
another level in the hierarchy of the

708
00:29:28,720 --> 00:29:34,240
game allocations

709
00:29:30,559 --> 00:29:37,918
and for every context there will be a

710
00:29:34,240 --> 00:29:40,559
new cache that belong to particular

711
00:29:37,919 --> 00:29:43,120
like c groups create their own we will

712
00:29:40,559 --> 00:29:47,120
also create our own for

713
00:29:43,120 --> 00:29:47,120
address space 1 aerospace 2 etc

714
00:29:49,200 --> 00:29:55,600
and if we are looking again at a

715
00:29:52,480 --> 00:29:59,279
address spaces for network namespace

716
00:29:55,600 --> 00:30:00,959
we add the page table to the structnet

717
00:29:59,279 --> 00:30:03,039
which is the kernel representation of

718
00:30:00,960 --> 00:30:06,960
the network namespace

719
00:30:03,039 --> 00:30:09,200
and then whenever process joins the

720
00:30:06,960 --> 00:30:12,240
network namespaces using clone

721
00:30:09,200 --> 00:30:14,080
settings or something like that its page

722
00:30:12,240 --> 00:30:16,720
table gets overwritten with the page

723
00:30:14,080 --> 00:30:19,760
tables it is common to all the processes

724
00:30:16,720 --> 00:30:22,240
present in that network namespace and

725
00:30:19,760 --> 00:30:22,879
every allocation the memory inside the

726
00:30:22,240 --> 00:30:26,080
kernel

727
00:30:22,880 --> 00:30:28,000
and makes sure that the

728
00:30:26,080 --> 00:30:29,520
pages allocated privately to that

729
00:30:28,000 --> 00:30:31,360
namespace and that

730
00:30:29,520 --> 00:30:34,480
they are not visible in the direct map

731
00:30:31,360 --> 00:30:34,479
in other namespaces

732
00:30:35,440 --> 00:30:39,360
we had this some proof of concept mostly

733
00:30:38,559 --> 00:30:42,720
working

734
00:30:39,360 --> 00:30:45,918
and that socket objects and sk

735
00:30:42,720 --> 00:30:47,039
buffers were allocated using jfp

736
00:30:45,919 --> 00:30:50,159
exclusive

737
00:30:47,039 --> 00:30:53,600
and using the exclusive memory and i

738
00:30:50,159 --> 00:30:57,679
actually planned another demo but i

739
00:30:53,600 --> 00:31:00,559
couldn't get wi-fi on my laptop so

740
00:30:57,679 --> 00:31:00,559
sorry about that

741
00:31:02,880 --> 00:31:08,480
and this is our current vision of how is

742
00:31:06,799 --> 00:31:12,240
going to happen

743
00:31:08,480 --> 00:31:13,840
and it may evolve over the time so

744
00:31:12,240 --> 00:31:16,000
we are going to implement some page

745
00:31:13,840 --> 00:31:18,799
table management api for management

746
00:31:16,000 --> 00:31:20,960
for management of the kernel page table

747
00:31:18,799 --> 00:31:21,360
pager locators live allocator will use

748
00:31:20,960 --> 00:31:25,120
these

749
00:31:21,360 --> 00:31:25,918
apis and then it will be available to

750
00:31:25,120 --> 00:31:29,600
namespaces

751
00:31:25,919 --> 00:31:33,360
installation as well as to kvm isolation

752
00:31:29,600 --> 00:31:36,559
for what kvm people are doing

753
00:31:33,360 --> 00:31:38,879
and for the exclusive memory mappings

754
00:31:36,559 --> 00:31:40,639
currently we are looking at extending

755
00:31:38,880 --> 00:31:43,279
page cache functionality

756
00:31:40,640 --> 00:31:46,000
and using that to implement exclusive

757
00:31:43,279 --> 00:31:49,600
memory mappings

758
00:31:46,000 --> 00:31:51,600
okay so to conclude well first of all it

759
00:31:49,600 --> 00:31:53,439
would be nice to make all this work

760
00:31:51,600 --> 00:31:54,959
it will take a couple of years or so i

761
00:31:53,440 --> 00:31:58,240
presume

762
00:31:54,960 --> 00:32:01,360
and we

763
00:31:58,240 --> 00:32:04,640
can presume that using restricted

764
00:32:01,360 --> 00:32:08,879
address spaces does reduce

765
00:32:04,640 --> 00:32:12,000
attack surface but we yet to evaluate

766
00:32:08,880 --> 00:32:14,559
the security benefits

767
00:32:12,000 --> 00:32:16,559
versus the added complexity and probably

768
00:32:14,559 --> 00:32:19,918
performance degradation

769
00:32:16,559 --> 00:32:22,000
so to evaluate the pros and cons

770
00:32:19,919 --> 00:32:23,600
we need to implement so it will take

771
00:32:22,000 --> 00:32:27,760
some time

772
00:32:23,600 --> 00:32:29,678
and as we seen with sci this is no goal

773
00:32:27,760 --> 00:32:30,158
and the system consolation we tried to

774
00:32:29,679 --> 00:32:33,039
do

775
00:32:30,159 --> 00:32:33,760
was too slow we hope that exclusive

776
00:32:33,039 --> 00:32:36,000
memory

777
00:32:33,760 --> 00:32:37,039
will be fast enough to be useful in

778
00:32:36,000 --> 00:32:38,640
production

779
00:32:37,039 --> 00:32:42,480
and we hope that address spaces for

780
00:32:38,640 --> 00:32:44,480
namespaces will also be fast enough and

781
00:32:42,480 --> 00:32:45,679
reworking kernel address space

782
00:32:44,480 --> 00:32:48,880
management

783
00:32:45,679 --> 00:32:50,159
in kernel is a really difficult because

784
00:32:48,880 --> 00:32:52,320
we

785
00:32:50,159 --> 00:32:55,120
have to break a lot of assumptions that

786
00:32:52,320 --> 00:32:58,080
go into kernel memory management

787
00:32:55,120 --> 00:33:00,000
the major assumption was that there is a

788
00:32:58,080 --> 00:33:02,480
single kernel page table

789
00:33:00,000 --> 00:33:03,120
and we don't need anything to actually

790
00:33:02,480 --> 00:33:06,640
management

791
00:33:03,120 --> 00:33:06,639
manage it it's always there

792
00:33:06,799 --> 00:33:12,720
so that's all i had to say do you want

793
00:33:09,919 --> 00:33:12,720
to add something

794
00:33:12,799 --> 00:33:16,639
and if you have any questions

795
00:33:17,930 --> 00:33:21,049
[Applause]

796
00:33:23,279 --> 00:33:26,799
thank you please raise your hand if you

797
00:33:25,200 --> 00:33:28,880
have a question we quit

798
00:33:26,799 --> 00:33:30,559
we finished quite early so we have

799
00:33:28,880 --> 00:33:33,279
plenty of time to move to the other room

800
00:33:30,559 --> 00:33:33,279
after questions

801
00:33:33,440 --> 00:33:38,399
ah hello thank you for the talk i'm

802
00:33:35,840 --> 00:33:41,600
afraid terminating processes this way

803
00:33:38,399 --> 00:33:42,799
will break like overflow of traces and

804
00:33:41,600 --> 00:33:45,279
debuggers

805
00:33:42,799 --> 00:33:46,158
i mean they usually expect some kind of

806
00:33:45,279 --> 00:33:49,679
error

807
00:33:46,159 --> 00:33:53,120
when they try to access a memory

808
00:33:49,679 --> 00:33:56,000
that's the idea right yeah but

809
00:33:53,120 --> 00:33:57,678
in this demo there was just a killed

810
00:33:56,000 --> 00:33:59,519
purchase

811
00:33:57,679 --> 00:34:00,960
right but the theory of the demo is that

812
00:33:59,519 --> 00:34:03,120
somebody is already broken into your

813
00:34:00,960 --> 00:34:05,440
machine and tried something nefarious

814
00:34:03,120 --> 00:34:07,279
you don't get killed in normal operation

815
00:34:05,440 --> 00:34:08,960
and because it's the kernel page fault

816
00:34:07,279 --> 00:34:11,040
we can actually choose the signal we

817
00:34:08,960 --> 00:34:13,679
give to terminate the process

818
00:34:11,040 --> 00:34:15,599
and that signal can be picked up by the

819
00:34:13,679 --> 00:34:18,159
container orchestration software

820
00:34:15,599 --> 00:34:20,639
and in addition the kernel log is

821
00:34:18,159 --> 00:34:22,639
contains a bit of a verbose uh trace of

822
00:34:20,639 --> 00:34:24,720
what went on that can also be passed up

823
00:34:22,639 --> 00:34:26,960
through kafka in the container world

824
00:34:24,719 --> 00:34:28,239
and analyzed to show that you have a

825
00:34:26,960 --> 00:34:30,159
problem i mean

826
00:34:28,239 --> 00:34:31,918
if i actually saw a log message like

827
00:34:30,159 --> 00:34:33,679
this on one of my containers what it

828
00:34:31,918 --> 00:34:34,719
shows me is somebody is trying to break

829
00:34:33,679 --> 00:34:36,240
into your system

830
00:34:34,719 --> 00:34:37,918
and they already have enough privilege

831
00:34:36,239 --> 00:34:39,678
to be trying to steal secrets

832
00:34:37,918 --> 00:34:41,598
so this machine needs to be shut down as

833
00:34:39,679 --> 00:34:46,720
fast as possible

834
00:34:41,599 --> 00:34:46,720
okay all right next question over there

835
00:34:46,879 --> 00:34:49,839
thank you great talk

836
00:34:53,839 --> 00:34:57,119
in the mfd case how does it play with

837
00:34:56,159 --> 00:34:58,960
scm rights

838
00:34:57,119 --> 00:35:03,839
and could you theoretically adapt this

839
00:34:58,960 --> 00:35:03,839
to be passed between processes

840
00:35:04,240 --> 00:35:07,839
how it going to play with c groups no no

841
00:35:06,640 --> 00:35:10,960
scm rights like

842
00:35:07,839 --> 00:35:13,200
passing the mfd to another process could

843
00:35:10,960 --> 00:35:13,680
you theoretically use something like scm

844
00:35:13,200 --> 00:35:15,759
rights

845
00:35:13,680 --> 00:35:16,720
to then securely donate that memory to

846
00:35:15,760 --> 00:35:19,920
another product yes

847
00:35:16,720 --> 00:35:22,399
oh cool it's a normal file descriptor so

848
00:35:19,920 --> 00:35:24,240
you can do scm writes you can do lsm on

849
00:35:22,400 --> 00:35:25,119
it and everything you can do in the file

850
00:35:24,240 --> 00:35:28,560
description

851
00:35:25,119 --> 00:35:31,680
pretty much like like memo fd today

852
00:35:28,560 --> 00:35:32,160
is the usual name of d we just thought

853
00:35:31,680 --> 00:35:33,759
that

854
00:35:32,160 --> 00:35:35,839
instead of introducing a new system

855
00:35:33,760 --> 00:35:37,359
called we extend the existing one

856
00:35:35,839 --> 00:35:39,759
so you can you would then update the

857
00:35:37,359 --> 00:35:45,680
other processes page tables

858
00:35:39,760 --> 00:35:48,160
yes very cool okay next question

859
00:35:45,680 --> 00:35:49,598
would it be possible to use this work to

860
00:35:48,160 --> 00:35:51,759
further lock down

861
00:35:49,599 --> 00:35:53,680
file system implementations in linux

862
00:35:51,760 --> 00:35:56,480
kernel to isolate file system

863
00:35:53,680 --> 00:35:56,480
implementations

864
00:35:57,280 --> 00:36:03,359
well in theory it's possible um so

865
00:36:00,640 --> 00:36:04,400
if you looked at the um patches we are

866
00:36:03,359 --> 00:36:07,040
planning for

867
00:36:04,400 --> 00:36:07,440
network isolation uh we're planning to

868
00:36:07,040 --> 00:36:09,920
give

869
00:36:07,440 --> 00:36:11,040
the network namespace its own allocation

870
00:36:09,920 --> 00:36:12,640
of socket buffs

871
00:36:11,040 --> 00:36:14,400
and if you terminate at the end with a

872
00:36:12,640 --> 00:36:16,160
virtual function that means we have an

873
00:36:14,400 --> 00:36:18,400
isolated network stack

874
00:36:16,160 --> 00:36:20,960
it is not impossible in the kernel to

875
00:36:18,400 --> 00:36:23,200
isolate the file system in the same way

876
00:36:20,960 --> 00:36:25,119
using the mounting space so we have a

877
00:36:23,200 --> 00:36:26,879
namespace to do this

878
00:36:25,119 --> 00:36:28,480
it's just that neither of us has looked

879
00:36:26,880 --> 00:36:30,079
at what the complexity of actually

880
00:36:28,480 --> 00:36:31,359
adding private allocations to the amount

881
00:36:30,079 --> 00:36:33,680
name space is

882
00:36:31,359 --> 00:36:36,480
so i can answer theoretically yes but i

883
00:36:33,680 --> 00:36:39,118
have no idea because we've not tried it

884
00:36:36,480 --> 00:36:41,839
thank you okay i see your next question

885
00:36:39,119 --> 00:36:41,839
over there

886
00:36:42,800 --> 00:36:47,280
thank you all for being so quiet it's

887
00:36:44,560 --> 00:36:47,279
really special

888
00:36:49,119 --> 00:36:52,960
have you explored looking at using this

889
00:36:51,440 --> 00:36:54,640
with keyrings

890
00:36:52,960 --> 00:36:56,640
being able to allocate secure memory for

891
00:36:54,640 --> 00:36:59,040
key rings seems like an obvious choice

892
00:36:56,640 --> 00:37:00,560
so there is a specific problem with the

893
00:36:59,040 --> 00:37:03,680
kernel keyring mechanism

894
00:37:00,560 --> 00:37:05,040
in that it has no c group or name space

895
00:37:03,680 --> 00:37:06,640
isolation currently

896
00:37:05,040 --> 00:37:08,720
so right at the moment key rings are

897
00:37:06,640 --> 00:37:10,879
shared amongst all processes

898
00:37:08,720 --> 00:37:12,799
where it is theoretically possible that

899
00:37:10,880 --> 00:37:14,560
we could use secret memory for say the

900
00:37:12,800 --> 00:37:16,960
user part of the key ring

901
00:37:14,560 --> 00:37:18,400
but the protections it affords may not

902
00:37:16,960 --> 00:37:21,760
be as great as you think

903
00:37:18,400 --> 00:37:22,720
because um you don't have i mean in in

904
00:37:21,760 --> 00:37:25,040
the current model

905
00:37:22,720 --> 00:37:26,799
it's actually only the children of the

906
00:37:25,040 --> 00:37:27,520
process can get access to the memory and

907
00:37:26,800 --> 00:37:30,560
in fact

908
00:37:27,520 --> 00:37:31,920
we uh did the mfd with clothes on exact

909
00:37:30,560 --> 00:37:32,560
which means even the children don't get

910
00:37:31,920 --> 00:37:34,720
access

911
00:37:32,560 --> 00:37:36,480
so this is really restricted the keyring

912
00:37:34,720 --> 00:37:38,319
has a much more general

913
00:37:36,480 --> 00:37:40,160
use case within the kernel and it's much

914
00:37:38,320 --> 00:37:42,640
longer lived so i think

915
00:37:40,160 --> 00:37:44,480
we won't get key rings in secret memory

916
00:37:42,640 --> 00:37:46,480
until we get the keyring namespace

917
00:37:44,480 --> 00:37:48,560
which is actually necessary in order to

918
00:37:46,480 --> 00:37:50,800
consume key rings and containers anyway

919
00:37:48,560 --> 00:37:52,880
without the keyring name space a key you

920
00:37:50,800 --> 00:37:54,480
put into a key ring even in inside a

921
00:37:52,880 --> 00:37:57,040
container is shared by all of the

922
00:37:54,480 --> 00:37:57,040
containers

923
00:37:57,680 --> 00:38:05,520
thank you any other questions

924
00:38:01,280 --> 00:38:08,480
no one here one more question

925
00:38:05,520 --> 00:38:09,680
uh this architecture especially adding

926
00:38:08,480 --> 00:38:12,320
context to k melo

927
00:38:09,680 --> 00:38:14,399
looks much like a first step to micro

928
00:38:12,320 --> 00:38:16,839
kernels

929
00:38:14,400 --> 00:38:18,000
do you think we are heading into the

930
00:38:16,839 --> 00:38:20,960
direction

931
00:38:18,000 --> 00:38:23,280
okay so this work does have contact

932
00:38:20,960 --> 00:38:24,880
points with micro kernels

933
00:38:23,280 --> 00:38:27,359
but if you think about the architecture

934
00:38:24,880 --> 00:38:29,040
of a microkernel and actually

935
00:38:27,359 --> 00:38:30,799
although mike and i are standing up here

936
00:38:29,040 --> 00:38:32,000
we had a third guy called joel neider

937
00:38:30,800 --> 00:38:34,240
who also worked on us

938
00:38:32,000 --> 00:38:36,640
with ibm haifa doing this he was a

939
00:38:34,240 --> 00:38:38,319
microkernel guy so his job was to bring

940
00:38:36,640 --> 00:38:40,640
micro kernel techniques to what we were

941
00:38:38,320 --> 00:38:42,320
doing but in a standard micro kernel

942
00:38:40,640 --> 00:38:44,319
it's actually all of the internal

943
00:38:42,320 --> 00:38:46,079
servers within the micro kernel that run

944
00:38:44,320 --> 00:38:47,520
in their own address space and the

945
00:38:46,079 --> 00:38:49,680
problem is that

946
00:38:47,520 --> 00:38:51,680
if a tenant can exploit one of those

947
00:38:49,680 --> 00:38:52,560
servers you can limit the exploit to

948
00:38:51,680 --> 00:38:55,680
that server

949
00:38:52,560 --> 00:38:57,920
but that tenant can still compromise any

950
00:38:55,680 --> 00:39:00,000
other tenant also using that server

951
00:38:57,920 --> 00:39:01,599
so it doesn't provide a lot of

952
00:39:00,000 --> 00:39:04,079
protection in the microkernel

953
00:39:01,599 --> 00:39:04,880
against exploits that are exercised by

954
00:39:04,079 --> 00:39:06,640
tenants

955
00:39:04,880 --> 00:39:08,480
whereas if you look at what we're doing

956
00:39:06,640 --> 00:39:11,440
we're actually trying to bring up

957
00:39:08,480 --> 00:39:12,880
an entire address space that belongs to

958
00:39:11,440 --> 00:39:15,040
the tenant alone

959
00:39:12,880 --> 00:39:16,800
so any other tenant running in the

960
00:39:15,040 --> 00:39:17,440
kernel can't get access to this address

961
00:39:16,800 --> 00:39:19,200
space

962
00:39:17,440 --> 00:39:20,640
so instead of trying to isolate the

963
00:39:19,200 --> 00:39:22,240
servers within the kernel

964
00:39:20,640 --> 00:39:24,400
we're actually trying to isolate the

965
00:39:22,240 --> 00:39:26,479
access from the tenant from the top

966
00:39:24,400 --> 00:39:28,320
that actually is a ver conceptually is

967
00:39:26,480 --> 00:39:28,960
very different from the way microkernels

968
00:39:28,320 --> 00:39:31,119
operate

969
00:39:28,960 --> 00:39:32,560
so it's true to say that some we

970
00:39:31,119 --> 00:39:34,400
definitely got our ideas by looking at

971
00:39:32,560 --> 00:39:37,359
microkernel work because joel was

972
00:39:34,400 --> 00:39:39,280
very very fanatical about it but the

973
00:39:37,359 --> 00:39:40,560
ultimate implementation we have

974
00:39:39,280 --> 00:39:42,850
is very dissimilar from what a

975
00:39:40,560 --> 00:39:44,560
microkernel would do

976
00:39:42,850 --> 00:39:48,400
[Music]

977
00:39:44,560 --> 00:39:51,359
thank you we have two more questions

978
00:39:48,400 --> 00:39:51,359
still plenty of time

979
00:39:52,400 --> 00:39:55,599
so with your dummy you stopped a bit

980
00:39:55,040 --> 00:39:58,560
traced

981
00:39:55,599 --> 00:40:00,960
by stereo from accessing the tracy

982
00:39:58,560 --> 00:40:03,440
memory but what's it stops from like

983
00:40:00,960 --> 00:40:04,079
injecting code into the context of the

984
00:40:03,440 --> 00:40:07,920
process

985
00:40:04,079 --> 00:40:07,920
and well basically executing it

986
00:40:08,400 --> 00:40:13,280
so the question is really about

987
00:40:10,640 --> 00:40:16,480
mechanisms we can use for protection

988
00:40:13,280 --> 00:40:18,000
thanks to the no execute bit um in the

989
00:40:16,480 --> 00:40:20,480
modern processes it's actually very

990
00:40:18,000 --> 00:40:22,079
difficult to inject code into processes

991
00:40:20,480 --> 00:40:24,480
and force them to execute it

992
00:40:22,079 --> 00:40:25,760
it is definitely not impossible and a

993
00:40:24,480 --> 00:40:27,839
root attacker has

994
00:40:25,760 --> 00:40:29,440
many other ways of compromising a

995
00:40:27,839 --> 00:40:31,440
process other than

996
00:40:29,440 --> 00:40:33,119
by trying to pull secrets straight out

997
00:40:31,440 --> 00:40:34,720
of the memory so if they know we've

998
00:40:33,119 --> 00:40:38,400
deployed this protect i mean

999
00:40:34,720 --> 00:40:40,160
security is basically a turtles game

1000
00:40:38,400 --> 00:40:41,599
so you know we've gone down about a

1001
00:40:40,160 --> 00:40:43,200
couple of layers in the turtle but in

1002
00:40:41,599 --> 00:40:44,880
order to get perfect security

1003
00:40:43,200 --> 00:40:47,200
you have to go down the infinite layers

1004
00:40:44,880 --> 00:40:47,680
of the turtle but what we're hoping is

1005
00:40:47,200 --> 00:40:49,520
that

1006
00:40:47,680 --> 00:40:51,359
this is definitely a building block for

1007
00:40:49,520 --> 00:40:53,280
providing enhanced security

1008
00:40:51,359 --> 00:40:55,200
coupled with a few other security

1009
00:40:53,280 --> 00:40:57,359
techniques that containers will use

1010
00:40:55,200 --> 00:40:59,040
like no execute memory enhanced

1011
00:40:57,359 --> 00:40:59,839
protections for the name space various

1012
00:40:59,040 --> 00:41:01,759
other things

1013
00:40:59,839 --> 00:41:03,279
we might be able to block most of the

1014
00:41:01,760 --> 00:41:05,440
standard attack channels

1015
00:41:03,280 --> 00:41:06,960
and obviously when you do this the black

1016
00:41:05,440 --> 00:41:09,040
hats just tend to come up with new

1017
00:41:06,960 --> 00:41:10,720
attack channels which we look forward to

1018
00:41:09,040 --> 00:41:12,400
seeing what they are and we end up in an

1019
00:41:10,720 --> 00:41:13,839
arms race to see if we can also block

1020
00:41:12,400 --> 00:41:16,000
those with the same technology

1021
00:41:13,839 --> 00:41:17,440
or whether we need new technology so

1022
00:41:16,000 --> 00:41:19,119
this is definitely not an

1023
00:41:17,440 --> 00:41:21,839
end point for security and containers

1024
00:41:19,119 --> 00:41:21,839
this is just the beginning

1025
00:41:23,280 --> 00:41:28,079
okay thank you we have another question

1026
00:41:25,839 --> 00:41:28,078
there

1027
00:41:33,200 --> 00:41:36,799
hey um have you discussed your design

1028
00:41:36,079 --> 00:41:40,480
with

1029
00:41:36,800 --> 00:41:42,750
the potential consumers of those um

1030
00:41:40,480 --> 00:41:44,000
patches say um

1031
00:41:42,750 --> 00:41:46,160
[Music]

1032
00:41:44,000 --> 00:41:47,040
the orchestra a container orchestration

1033
00:41:46,160 --> 00:41:50,078
community

1034
00:41:47,040 --> 00:41:52,880
or the tls providing

1035
00:41:50,079 --> 00:41:54,240
libraries or something like that and if

1036
00:41:52,880 --> 00:41:56,400
so

1037
00:41:54,240 --> 00:41:58,078
what was their reaction and will they

1038
00:41:56,400 --> 00:42:02,400
adopt

1039
00:41:58,079 --> 00:42:05,680
the features that you just presented

1040
00:42:02,400 --> 00:42:07,200
okay so um as you probably know there is

1041
00:42:05,680 --> 00:42:09,200
a bit of a bifurcation

1042
00:42:07,200 --> 00:42:11,118
between the container orchestration

1043
00:42:09,200 --> 00:42:13,439
community docker go

1044
00:42:11,119 --> 00:42:14,800
and the actual mechanisms in linux that

1045
00:42:13,440 --> 00:42:16,480
implement containers

1046
00:42:14,800 --> 00:42:18,240
most docker people can get their heads

1047
00:42:16,480 --> 00:42:20,400
around name spaces and c groups

1048
00:42:18,240 --> 00:42:22,160
but if you look at what docker does it

1049
00:42:20,400 --> 00:42:24,480
still can't take advantage of a lot of

1050
00:42:22,160 --> 00:42:26,160
the security mechanisms we have in linux

1051
00:42:24,480 --> 00:42:27,440
the username space being the classic

1052
00:42:26,160 --> 00:42:30,319
example

1053
00:42:27,440 --> 00:42:31,440
and so the kernel developers view of the

1054
00:42:30,319 --> 00:42:33,040
docker community

1055
00:42:31,440 --> 00:42:34,319
is that in the rare case they can

1056
00:42:33,040 --> 00:42:35,920
actually formulate the question

1057
00:42:34,319 --> 00:42:36,880
correctly they usually don't understand

1058
00:42:35,920 --> 00:42:39,280
the answer

1059
00:42:36,880 --> 00:42:41,040
so i would agree exactly that what we

1060
00:42:39,280 --> 00:42:41,920
need to be doing is evangelizing our

1061
00:42:41,040 --> 00:42:44,319
features

1062
00:42:41,920 --> 00:42:46,480
but just due to the fact that the

1063
00:42:44,319 --> 00:42:47,119
complexity of what we've done in the

1064
00:42:46,480 --> 00:42:49,200
kernel

1065
00:42:47,119 --> 00:42:51,200
is almost incomprehensible to people who

1066
00:42:49,200 --> 00:42:53,118
are managing orchestration systems

1067
00:42:51,200 --> 00:42:54,720
it's very difficult to have a sensible

1068
00:42:53,119 --> 00:42:57,280
conversation about

1069
00:42:54,720 --> 00:42:58,000
how you would make use of it so i think

1070
00:42:57,280 --> 00:42:59,920
the business

1071
00:42:58,000 --> 00:43:01,920
end of the conversation goes to that

1072
00:42:59,920 --> 00:43:03,520
demo that i showed you this is a way of

1073
00:43:01,920 --> 00:43:04,800
using a preload library in a container

1074
00:43:03,520 --> 00:43:08,560
which is very easy to do

1075
00:43:04,800 --> 00:43:10,319
to get security just put this ld.so in

1076
00:43:08,560 --> 00:43:12,400
attach it and your container is more

1077
00:43:10,319 --> 00:43:13,839
secure and the docker community will be

1078
00:43:12,400 --> 00:43:15,760
perfectly happy about that

1079
00:43:13,839 --> 00:43:17,520
trying to explain to them the mechanics

1080
00:43:15,760 --> 00:43:19,040
of an address-based separation mechanism

1081
00:43:17,520 --> 00:43:19,599
that pushes the page out of the direct

1082
00:43:19,040 --> 00:43:21,200
map

1083
00:43:19,599 --> 00:43:27,839
is probably going to cause their eyes to

1084
00:43:21,200 --> 00:43:27,839
fall back in their head

1085
00:43:28,079 --> 00:43:31,280
thank you that let's

1086
00:43:32,160 --> 00:43:36,000
let's uh leave that these questions it's

1087
00:43:33,839 --> 00:43:37,279
been a good time already

1088
00:43:36,000 --> 00:43:40,400
thank the speakers thank you for

1089
00:43:37,280 --> 00:43:50,480
clapping already

1090
00:43:40,400 --> 00:43:50,480
thank you guys

