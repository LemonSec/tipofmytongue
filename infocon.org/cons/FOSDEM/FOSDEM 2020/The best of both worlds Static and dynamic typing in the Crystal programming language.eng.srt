1
00:00:05,359 --> 00:00:07,759
go ahead

2
00:00:08,160 --> 00:00:15,679
okay uh sorry for the delay in starting

3
00:00:11,840 --> 00:00:19,840
i had a hell of a time setting up

4
00:00:15,679 --> 00:00:23,359
my laptop died last night so

5
00:00:19,840 --> 00:00:24,880
apologies so

6
00:00:23,359 --> 00:00:26,800
i'm here to talk about static and

7
00:00:24,880 --> 00:00:30,160
dynamic typing crystal

8
00:00:26,800 --> 00:00:33,200
um and is it the best of both worlds

9
00:00:30,160 --> 00:00:34,640
if we can have both a mix a little bit

10
00:00:33,200 --> 00:00:37,200
of a compromise between

11
00:00:34,640 --> 00:00:39,600
static and dynamic typing and that's

12
00:00:37,200 --> 00:00:42,320
what crystal aims to achieve

13
00:00:39,600 --> 00:00:45,680
um i'm gonna talk a lot about static

14
00:00:42,320 --> 00:00:48,879
versus dynamic typing in this talk

15
00:00:45,680 --> 00:00:51,600
and so it's a

16
00:00:48,879 --> 00:00:52,800
discussion that's raised for a long time

17
00:00:51,600 --> 00:00:56,320
online

18
00:00:52,800 --> 00:00:58,239
and there's a lot of being written about

19
00:00:56,320 --> 00:00:58,800
static and dynamic typing a lot of wars

20
00:00:58,239 --> 00:01:02,000
online

21
00:00:58,800 --> 00:01:03,519
and arguments in irc channels and

22
00:01:02,000 --> 00:01:05,199
mailing lists

23
00:01:03,520 --> 00:01:10,159
but i've written a couple of points

24
00:01:05,199 --> 00:01:10,158
about um both dynamic and static typing

25
00:01:10,479 --> 00:01:14,080
dynamic languages tend to be less

26
00:01:12,560 --> 00:01:17,360
verbose

27
00:01:14,080 --> 00:01:18,320
um typically when you talk to a static

28
00:01:17,360 --> 00:01:20,799
language

29
00:01:18,320 --> 00:01:22,320
so a dynamic language uh enthusiasts

30
00:01:20,799 --> 00:01:23,759
they'll think about python they'll think

31
00:01:22,320 --> 00:01:27,039
about ruby

32
00:01:23,759 --> 00:01:29,280
and um

33
00:01:27,040 --> 00:01:31,200
when you talk about static languages you

34
00:01:29,280 --> 00:01:32,799
think about java c-sharp

35
00:01:31,200 --> 00:01:35,280
and there's a there's a lot more

36
00:01:32,799 --> 00:01:38,560
verbosity in static languages

37
00:01:35,280 --> 00:01:41,600
historically now that's not

38
00:01:38,560 --> 00:01:42,640
a trait of static or dynamic languages

39
00:01:41,600 --> 00:01:46,000
specifically

40
00:01:42,640 --> 00:01:48,640
but that is um

41
00:01:46,000 --> 00:01:50,399
how they've evolved in the past because

42
00:01:48,640 --> 00:01:51,439
type influence has not been up to the

43
00:01:50,399 --> 00:01:54,000
task of

44
00:01:51,439 --> 00:01:54,880
removing that verbosity but now we're

45
00:01:54,000 --> 00:01:57,600
coming into a

46
00:01:54,880 --> 00:01:59,039
period where the distinction is starting

47
00:01:57,600 --> 00:02:02,960
to blur

48
00:01:59,040 --> 00:02:03,840
and dynamic typing proponents tend to

49
00:02:02,960 --> 00:02:05,199
say that

50
00:02:03,840 --> 00:02:07,439
you don't have to think about types in a

51
00:02:05,200 --> 00:02:09,360
dynamic language but obviously you have

52
00:02:07,439 --> 00:02:11,359
to think about the interface of

53
00:02:09,360 --> 00:02:12,800
every variable in your code and every

54
00:02:11,360 --> 00:02:14,720
object in your code

55
00:02:12,800 --> 00:02:16,239
as much in dynamic languages as in

56
00:02:14,720 --> 00:02:17,840
static languages

57
00:02:16,239 --> 00:02:19,840
so you do have to think about types in

58
00:02:17,840 --> 00:02:23,280
dynamic languages you just

59
00:02:19,840 --> 00:02:25,280
don't have to write them down as much

60
00:02:23,280 --> 00:02:28,879
and you think about them in a slightly

61
00:02:25,280 --> 00:02:28,879
different way slightly more flexible way

62
00:02:29,680 --> 00:02:34,080
dynamic languages you tend to have

63
00:02:31,599 --> 00:02:36,799
faster development cycles

64
00:02:34,080 --> 00:02:38,239
often so a good example of this is php

65
00:02:36,800 --> 00:02:41,200
you just save your code

66
00:02:38,239 --> 00:02:43,599
and then refresh the page and your

67
00:02:41,200 --> 00:02:45,359
changes are alive immediately

68
00:02:43,599 --> 00:02:47,760
um a lot of people like that a lot of

69
00:02:45,360 --> 00:02:47,760
people

70
00:02:48,160 --> 00:02:53,280
like that and sort of the rebel style

71
00:02:50,080 --> 00:02:56,480
levels are harder to do in um

72
00:02:53,280 --> 00:02:58,080
statically typed languages so dynamic

73
00:02:56,480 --> 00:02:59,760
code reloading is another thing which is

74
00:02:58,080 --> 00:03:00,400
a lot easier in dynamic languages than

75
00:02:59,760 --> 00:03:04,560
static

76
00:03:00,400 --> 00:03:06,000
statically typed languages

77
00:03:04,560 --> 00:03:08,080
easy to create complex deer cells

78
00:03:06,000 --> 00:03:10,319
because often type systems are a little

79
00:03:08,080 --> 00:03:12,800
bit uh

80
00:03:10,319 --> 00:03:14,640
stuck in their ways they can't represent

81
00:03:12,800 --> 00:03:15,840
um

82
00:03:14,640 --> 00:03:17,679
they can't be flexible enough to

83
00:03:15,840 --> 00:03:20,800
represent complex deer cells

84
00:03:17,680 --> 00:03:25,040
or often you get some crazy generic

85
00:03:20,800 --> 00:03:27,760
crap to represent your

86
00:03:25,040 --> 00:03:27,760
your dsl

87
00:03:28,640 --> 00:03:33,599
and sadly a lot of people write in

88
00:03:31,840 --> 00:03:37,280
dynamic languages they

89
00:03:33,599 --> 00:03:41,200
have an api some json that they emit and

90
00:03:37,280 --> 00:03:44,319
it's really not um

91
00:03:41,200 --> 00:03:47,599
easy to use

92
00:03:44,319 --> 00:03:48,958
apis at certain that um that have been

93
00:03:47,599 --> 00:03:50,959
made in dynamic languages

94
00:03:48,959 --> 00:03:53,840
in statically typed languages because

95
00:03:50,959 --> 00:03:53,840
you have um

96
00:03:54,720 --> 00:04:01,439
like json objects for example it's hard

97
00:03:57,120 --> 00:04:03,360
to um uh create types of those json

98
00:04:01,439 --> 00:04:05,280
objects if um

99
00:04:03,360 --> 00:04:06,400
if you haven't thought about the types

100
00:04:05,280 --> 00:04:08,080
beforehand and

101
00:04:06,400 --> 00:04:09,439
in the dynamic languages obviously you

102
00:04:08,080 --> 00:04:10,560
don't have to think so much about the

103
00:04:09,439 --> 00:04:14,720
types

104
00:04:10,560 --> 00:04:19,358
um and it can make it harder to

105
00:04:14,720 --> 00:04:22,079
do uh for statically typed languages

106
00:04:19,358 --> 00:04:23,039
um you have a promise that it works

107
00:04:22,079 --> 00:04:25,680
first try

108
00:04:23,040 --> 00:04:26,479
obviously that's not catching all errors

109
00:04:25,680 --> 00:04:29,520
there's a lot of

110
00:04:26,479 --> 00:04:33,039
logic areas a lot of other errors

111
00:04:29,520 --> 00:04:35,520
different error types which statically

112
00:04:33,040 --> 00:04:38,800
typed languages

113
00:04:35,520 --> 00:04:42,000
don't statically type languages

114
00:04:38,800 --> 00:04:43,600
can't detect but you can get stricter

115
00:04:42,000 --> 00:04:45,440
and stricter type systems which detect

116
00:04:43,600 --> 00:04:47,759
more and more of these errors

117
00:04:45,440 --> 00:04:50,880
um but for a lot of uh static type

118
00:04:47,759 --> 00:04:53,600
languages it's mostly typos and

119
00:04:50,880 --> 00:04:54,320
everyone makes a lot of typos so it does

120
00:04:53,600 --> 00:04:57,440
actually uh

121
00:04:54,320 --> 00:04:59,120
detect quite a lot of errors

122
00:04:57,440 --> 00:05:00,479
it's easier to create tooling in static

123
00:04:59,120 --> 00:05:03,360
languages because

124
00:05:00,479 --> 00:05:04,960
you your ides your compiler all of the

125
00:05:03,360 --> 00:05:06,880
different tooling for language

126
00:05:04,960 --> 00:05:08,400
can agree on a way to work out the types

127
00:05:06,880 --> 00:05:10,320
of every variable

128
00:05:08,400 --> 00:05:11,599
in java for example it's very easy to

129
00:05:10,320 --> 00:05:12,960
work out the type of variable because

130
00:05:11,600 --> 00:05:14,320
it's written right next to it almost all

131
00:05:12,960 --> 00:05:17,680
the time

132
00:05:14,320 --> 00:05:19,440
um that's another form of velocity it

133
00:05:17,680 --> 00:05:21,280
helps the tools but it

134
00:05:19,440 --> 00:05:22,960
doesn't so much help the process by the

135
00:05:21,280 --> 00:05:24,400
programmer

136
00:05:22,960 --> 00:05:26,638
so yeah you have a set of rules to work

137
00:05:24,400 --> 00:05:28,560
out the types it's easier to write

138
00:05:26,639 --> 00:05:31,759
optimizers for static languages

139
00:05:28,560 --> 00:05:34,560
subtly type languages because you have

140
00:05:31,759 --> 00:05:35,039
a little bit of a better idea of if you

141
00:05:34,560 --> 00:05:37,520
know

142
00:05:35,039 --> 00:05:39,520
exactly which types of variable can be

143
00:05:37,520 --> 00:05:42,719
you can have a much better guarantee

144
00:05:39,520 --> 00:05:43,680
and optimizers are limited code

145
00:05:42,720 --> 00:05:46,320
optimizers

146
00:05:43,680 --> 00:05:47,600
are limited by the edge cases not by the

147
00:05:46,320 --> 00:05:50,840
common case

148
00:05:47,600 --> 00:05:52,560
so if you can remove all the edge cases

149
00:05:50,840 --> 00:05:54,799
of

150
00:05:52,560 --> 00:05:56,319
of your code by having statically typed

151
00:05:54,800 --> 00:05:58,880
in more guarantees

152
00:05:56,319 --> 00:06:01,840
then you can write better optimizers

153
00:05:58,880 --> 00:06:04,719
write them more easily

154
00:06:01,840 --> 00:06:05,758
and a human aspect statically typed

155
00:06:04,720 --> 00:06:09,520
static

156
00:06:05,759 --> 00:06:11,759
types can help guide you towards

157
00:06:09,520 --> 00:06:13,120
cleaner code it can help quite like

158
00:06:11,759 --> 00:06:14,400
clean the code because you have to think

159
00:06:13,120 --> 00:06:17,039
about it a little more

160
00:06:14,400 --> 00:06:18,560
you have to think about how things are

161
00:06:17,039 --> 00:06:21,039
structured what names you're going to

162
00:06:18,560 --> 00:06:24,160
give things a little more than

163
00:06:21,039 --> 00:06:26,000
in dynamically typed languages

164
00:06:24,160 --> 00:06:29,199
and of course types of documentation as

165
00:06:26,000 --> 00:06:31,199
well if you've got big code base

166
00:06:29,199 --> 00:06:32,319
especially with newer onboarding new

167
00:06:31,199 --> 00:06:36,160
developers

168
00:06:32,319 --> 00:06:37,919
then it's a lot easier to

169
00:06:36,160 --> 00:06:39,600
for them to navigate around if they know

170
00:06:37,919 --> 00:06:42,240
the types of everything and they

171
00:06:39,600 --> 00:06:43,680
uh can it helps them to spot patterns

172
00:06:42,240 --> 00:06:45,360
and um

173
00:06:43,680 --> 00:06:47,360
look at the documentation above each

174
00:06:45,360 --> 00:06:49,919
type um and they can quickly navigate

175
00:06:47,360 --> 00:06:52,800
around the code base

176
00:06:49,919 --> 00:06:54,560
so recently in recent years a lot of

177
00:06:52,800 --> 00:06:56,960
languages have tried for a static

178
00:06:54,560 --> 00:06:59,599
more hybrid approach we've seen that

179
00:06:56,960 --> 00:07:02,560
with uh type lua which was presented

180
00:06:59,599 --> 00:07:03,599
a couple of presentations back the

181
00:07:02,560 --> 00:07:06,560
examples i've got here

182
00:07:03,599 --> 00:07:08,159
are python type annotations python

183
00:07:06,560 --> 00:07:09,599
python has recently introduced type

184
00:07:08,160 --> 00:07:14,000
annotations

185
00:07:09,599 --> 00:07:16,080
to the language they are

186
00:07:14,000 --> 00:07:17,520
easy to add to existing code bases

187
00:07:16,080 --> 00:07:19,840
incrementally

188
00:07:17,520 --> 00:07:19,840
and

189
00:07:21,759 --> 00:07:25,280
right they're easy to add to existing

190
00:07:23,520 --> 00:07:28,479
code bases incrementally

191
00:07:25,280 --> 00:07:28,799
and um i haven't used python so i don't

192
00:07:28,479 --> 00:07:32,800
know

193
00:07:28,800 --> 00:07:34,960
too much about them but um

194
00:07:32,800 --> 00:07:37,120
the type checking is performed by linter

195
00:07:34,960 --> 00:07:39,758
which is external to python

196
00:07:37,120 --> 00:07:41,120
you are not compiling your python into

197
00:07:39,759 --> 00:07:42,400
non-typed python

198
00:07:41,120 --> 00:07:44,960
you're checking it with an external

199
00:07:42,400 --> 00:07:46,400
program which is unrelated to the python

200
00:07:44,960 --> 00:07:49,280
interpreter

201
00:07:46,400 --> 00:07:49,919
and so it doesn't have to be 100

202
00:07:49,280 --> 00:07:51,840
accurate

203
00:07:49,919 --> 00:07:54,159
there are holes in your type annotations

204
00:07:51,840 --> 00:07:55,520
you can always decide not to annotate

205
00:07:54,160 --> 00:07:56,720
something if you want to do something

206
00:07:55,520 --> 00:07:57,940
fancy

207
00:07:56,720 --> 00:07:59,919
you can um

208
00:07:57,940 --> 00:08:02,719
[Music]

209
00:07:59,919 --> 00:08:04,240
just it doesn't have to be 100 accurate

210
00:08:02,720 --> 00:08:07,120
and that doesn't mean you have 100

211
00:08:04,240 --> 00:08:07,840
confidence in your type system you don't

212
00:08:07,120 --> 00:08:10,960
have 100

213
00:08:07,840 --> 00:08:10,960
confidence in your

214
00:08:11,199 --> 00:08:16,800
in your types in your code and

215
00:08:14,479 --> 00:08:18,479
obviously it means you can't perform

216
00:08:16,800 --> 00:08:20,560
optimizations based on the types because

217
00:08:18,479 --> 00:08:23,039
you don't have any guarantee

218
00:08:20,560 --> 00:08:24,720
um that your the types are actually

219
00:08:23,039 --> 00:08:26,719
being obeyed

220
00:08:24,720 --> 00:08:30,479
when you're running the program because

221
00:08:26,720 --> 00:08:32,800
it's done by an external checking tool

222
00:08:30,479 --> 00:08:33,679
so another approach to that is

223
00:08:32,799 --> 00:08:37,598
typescript

224
00:08:33,679 --> 00:08:37,598
and flow which are

225
00:08:38,080 --> 00:08:41,440
essentially typed javascript they're

226
00:08:39,599 --> 00:08:43,039
different types of type javascript so

227
00:08:41,440 --> 00:08:45,040
they're also easy to add to

228
00:08:43,039 --> 00:08:46,480
existing code bases incrementally you

229
00:08:45,040 --> 00:08:48,160
take your javascript you add type

230
00:08:46,480 --> 00:08:49,440
annotations it tells you where you've

231
00:08:48,160 --> 00:08:52,640
messed up

232
00:08:49,440 --> 00:08:54,399
um and this time type checking is

233
00:08:52,640 --> 00:08:55,600
performed by a compiler so you have the

234
00:08:54,399 --> 00:08:57,839
typescript compiler

235
00:08:55,600 --> 00:08:59,040
takes typescript code and it emits

236
00:08:57,839 --> 00:09:01,200
javascript

237
00:08:59,040 --> 00:09:02,480
and this means that you can influence

238
00:09:01,200 --> 00:09:04,560
codegen

239
00:09:02,480 --> 00:09:05,680
typescript actually doesn't do this but

240
00:09:04,560 --> 00:09:11,040
you can

241
00:09:05,680 --> 00:09:13,279
have your types in your typed javascript

242
00:09:11,040 --> 00:09:14,240
influence the javascript code which is

243
00:09:13,279 --> 00:09:15,920
generated

244
00:09:14,240 --> 00:09:17,360
and you could perform optimizations

245
00:09:15,920 --> 00:09:22,560
based on

246
00:09:17,360 --> 00:09:25,680
on this

247
00:09:22,560 --> 00:09:27,439
and so typescript and flow are very

248
00:09:25,680 --> 00:09:29,599
interesting because they've developed

249
00:09:27,440 --> 00:09:30,959
very complex type systems to model

250
00:09:29,600 --> 00:09:33,040
javascript

251
00:09:30,959 --> 00:09:34,560
they've done a lot of work on pushing

252
00:09:33,040 --> 00:09:38,319
the boundaries of

253
00:09:34,560 --> 00:09:41,199
how to make a tight type system describe

254
00:09:38,320 --> 00:09:43,040
a dynamically type describe dynamically

255
00:09:41,200 --> 00:09:45,839
typed idioms

256
00:09:43,040 --> 00:09:48,160
very well so for example flow typing

257
00:09:45,839 --> 00:09:50,800
union types

258
00:09:48,160 --> 00:09:51,920
typescript has intersection types which

259
00:09:50,800 --> 00:09:55,760
very interesting

260
00:09:51,920 --> 00:09:57,199
and um all these different

261
00:09:55,760 --> 00:09:58,800
innovations which i'm going to cover

262
00:09:57,200 --> 00:10:01,279
some of these later when i talk about

263
00:09:58,800 --> 00:10:04,319
crystal finally

264
00:10:01,279 --> 00:10:05,760
um because crystal has some of these too

265
00:10:04,320 --> 00:10:07,680
but it's very interesting to look into

266
00:10:05,760 --> 00:10:10,160
typescript as a

267
00:10:07,680 --> 00:10:10,800
person who's interested in type systems

268
00:10:10,160 --> 00:10:13,760
and

269
00:10:10,800 --> 00:10:15,760
it's they've they've done a good job so

270
00:10:13,760 --> 00:10:19,120
yeah flow typing union types

271
00:10:15,760 --> 00:10:22,000
but it still has a hole you don't

272
00:10:19,120 --> 00:10:23,360
have to type everything because you

273
00:10:22,000 --> 00:10:24,959
still have to support

274
00:10:23,360 --> 00:10:27,360
the old javascript you still have to

275
00:10:24,959 --> 00:10:27,359
support

276
00:10:27,440 --> 00:10:30,880
interacting with things that you can't

277
00:10:28,880 --> 00:10:31,360
type there's a lot of code out there

278
00:10:30,880 --> 00:10:33,600
which

279
00:10:31,360 --> 00:10:36,240
you can't type in typescript you'd have

280
00:10:33,600 --> 00:10:39,200
to create a crazy complex type system

281
00:10:36,240 --> 00:10:40,220
to do it so you have the any type which

282
00:10:39,200 --> 00:10:41,920
means

283
00:10:40,220 --> 00:10:44,959
[Music]

284
00:10:41,920 --> 00:10:46,959
just give up so the type the typescript

285
00:10:44,959 --> 00:10:51,119
compiler doesn't do any checking

286
00:10:46,959 --> 00:10:53,119
um so you can't be 100 confident in any

287
00:10:51,120 --> 00:10:55,519
code which uses any

288
00:10:53,120 --> 00:10:56,720
so this brings me to crystal which is

289
00:10:55,519 --> 00:10:58,240
what i work on

290
00:10:56,720 --> 00:11:00,959
i'm a core developer of the crystal

291
00:10:58,240 --> 00:11:03,839
programming language it's been

292
00:11:00,959 --> 00:11:06,239
around for a couple of years now has any

293
00:11:03,839 --> 00:11:09,839
of you heard of it before

294
00:11:06,240 --> 00:11:13,600
good that's why you're here

295
00:11:09,839 --> 00:11:13,600
so a bit of history about the language

296
00:11:13,680 --> 00:11:18,560
it started as an attempt to compile

297
00:11:17,040 --> 00:11:20,319
something very close to ruby

298
00:11:18,560 --> 00:11:20,900
as close to ruby as they could make it

299
00:11:20,320 --> 00:11:23,040
and um

300
00:11:20,900 --> 00:11:25,519
[Music]

301
00:11:23,040 --> 00:11:27,120
it was never an attempt so much to have

302
00:11:25,519 --> 00:11:31,120
a typed ruby

303
00:11:27,120 --> 00:11:33,519
but it was intended to stick as close to

304
00:11:31,120 --> 00:11:39,040
ruby as it possibly could

305
00:11:33,519 --> 00:11:42,720
um started back in 2011 or 2012

306
00:11:39,040 --> 00:11:47,439
a bunch of guys down in south america

307
00:11:42,720 --> 00:11:49,040
um harry and

308
00:11:47,440 --> 00:11:50,560
they did a very good job in the early

309
00:11:49,040 --> 00:11:53,680
days of sticking

310
00:11:50,560 --> 00:11:57,680
very close to ruby and making

311
00:11:53,680 --> 00:11:59,599
crystal um very accessible to ruby

312
00:11:57,680 --> 00:12:02,880
developers

313
00:11:59,600 --> 00:12:03,839
but we chose to crystal chose to break

314
00:12:02,880 --> 00:12:07,120
this movie

315
00:12:03,839 --> 00:12:09,200
in a couple of key areas which sets it

316
00:12:07,120 --> 00:12:10,399
apart from typescript and python type

317
00:12:09,200 --> 00:12:13,839
annotations

318
00:12:10,399 --> 00:12:16,240
by expanding beyond the language that

319
00:12:13,839 --> 00:12:18,000
we were influenced by and creating a

320
00:12:16,240 --> 00:12:20,240
programming language which is unique in

321
00:12:18,000 --> 00:12:22,399
its own ways

322
00:12:20,240 --> 00:12:24,160
for example if you have an empty array

323
00:12:22,399 --> 00:12:25,279
and you access the first element in ruby

324
00:12:24,160 --> 00:12:28,240
you will get nil

325
00:12:25,279 --> 00:12:29,760
in crystal you will get an exception and

326
00:12:28,240 --> 00:12:31,920
obviously

327
00:12:29,760 --> 00:12:32,959
because we're strict about nil in

328
00:12:31,920 --> 00:12:36,079
crystal

329
00:12:32,959 --> 00:12:37,199
um if you if every array access could

330
00:12:36,079 --> 00:12:39,199
return nil

331
00:12:37,200 --> 00:12:40,800
depending on the length of the array

332
00:12:39,200 --> 00:12:42,240
then you'd have to check

333
00:12:40,800 --> 00:12:44,399
for nil every time you do an array

334
00:12:42,240 --> 00:12:47,680
access and this isn't

335
00:12:44,399 --> 00:12:50,000
um this will make your code a lot longer

336
00:12:47,680 --> 00:12:52,239
so we decided the only way to solve this

337
00:12:50,000 --> 00:12:54,240
is to raise an exception at one time

338
00:12:52,240 --> 00:12:56,480
if you try and access an array element

339
00:12:54,240 --> 00:12:59,600
which doesn't exist

340
00:12:56,480 --> 00:13:03,279
so in crystal it just returns t

341
00:12:59,600 --> 00:13:04,720
the type of array and we've removed some

342
00:13:03,279 --> 00:13:07,120
of the warts from

343
00:13:04,720 --> 00:13:07,920
ruby as well like post fix while i don't

344
00:13:07,120 --> 00:13:10,560
think anyone

345
00:13:07,920 --> 00:13:11,920
needs a postfix while uh it's very

346
00:13:10,560 --> 00:13:15,040
confusing

347
00:13:11,920 --> 00:13:18,800
uh we've added some new things

348
00:13:15,040 --> 00:13:20,800
really okay so we've also got flow

349
00:13:18,800 --> 00:13:24,000
typing immunotypes

350
00:13:20,800 --> 00:13:28,000
um and it's quite easy to create

351
00:13:24,000 --> 00:13:29,519
uh beautiful dsls in crystal um

352
00:13:28,000 --> 00:13:32,160
and we don't have any hulls everything

353
00:13:29,519 --> 00:13:35,440
is completely typed

354
00:13:32,160 --> 00:13:36,880
there's no escape hatch into not being

355
00:13:35,440 --> 00:13:41,279
able to type something

356
00:13:36,880 --> 00:13:42,880
um you're completely

357
00:13:41,279 --> 00:13:44,320
you're you can trust the pipe system

358
00:13:42,880 --> 00:13:45,760
completely because you can't escape from

359
00:13:44,320 --> 00:13:49,839
it

360
00:13:45,760 --> 00:13:52,720
so we're going to go over a few examples

361
00:13:49,839 --> 00:13:55,600
of the type system so we like to think

362
00:13:52,720 --> 00:13:57,920
of crystal as compile time duct typing

363
00:13:55,600 --> 00:13:59,199
you have an example here of a twice

364
00:13:57,920 --> 00:14:03,519
function it's just x plus

365
00:13:59,199 --> 00:14:07,199
x now the plus operator is implemented

366
00:14:03,519 --> 00:14:09,839
on numbers and strings

367
00:14:07,199 --> 00:14:10,560
so if you type twice of one then you get

368
00:14:09,839 --> 00:14:14,000
two

369
00:14:10,560 --> 00:14:14,000
twice as high you get high high

370
00:14:15,519 --> 00:14:19,519
and this function doesn't know note any

371
00:14:18,160 --> 00:14:20,959
types but it's still completely

372
00:14:19,519 --> 00:14:24,160
statically typed

373
00:14:20,959 --> 00:14:27,119
this is implicitly a generic function

374
00:14:24,160 --> 00:14:28,160
so the same way you have duct typing in

375
00:14:27,120 --> 00:14:29,839
ruby if it

376
00:14:28,160 --> 00:14:32,240
quite if it looks like a duck and it

377
00:14:29,839 --> 00:14:35,040
cracks like a duck it probably is a duck

378
00:14:32,240 --> 00:14:35,040
then um

379
00:14:36,079 --> 00:14:39,199
it works pretty much the same way but

380
00:14:38,480 --> 00:14:41,360
the

381
00:14:39,199 --> 00:14:42,800
duck typing is done at compile time and

382
00:14:41,360 --> 00:14:44,639
um

383
00:14:42,800 --> 00:14:47,680
you can be completely certain there's no

384
00:14:44,639 --> 00:14:50,800
errors um

385
00:14:47,680 --> 00:14:54,239
so what is the type of x here um

386
00:14:50,800 --> 00:14:55,040
is it one is it a number or a string or

387
00:14:54,240 --> 00:14:57,519
is it

388
00:14:55,040 --> 00:14:58,319
or what could it be well actually under

389
00:14:57,519 --> 00:14:59,839
the hood

390
00:14:58,320 --> 00:15:01,440
what we have is we generate two

391
00:14:59,839 --> 00:15:04,079
functions so

392
00:15:01,440 --> 00:15:05,040
the example the twice function is

393
00:15:04,079 --> 00:15:08,079
actually generic

394
00:15:05,040 --> 00:15:11,279
it's implicitly generic so if you

395
00:15:08,079 --> 00:15:12,959
give twice an int it will return an int

396
00:15:11,279 --> 00:15:14,639
if you give it a string it will return a

397
00:15:12,959 --> 00:15:16,319
string so this creates two different

398
00:15:14,639 --> 00:15:19,440
functions

399
00:15:16,320 --> 00:15:22,639
um two different function

400
00:15:19,440 --> 00:15:26,320
implementations at

401
00:15:22,639 --> 00:15:27,680
the typing time and at the compile time

402
00:15:26,320 --> 00:15:30,320
you have essentially two different

403
00:15:27,680 --> 00:15:31,839
functions but they're represented by the

404
00:15:30,320 --> 00:15:35,519
same

405
00:15:31,839 --> 00:15:35,519
source code it's generic

406
00:15:38,959 --> 00:15:42,160
so we have complete type safety so if

407
00:15:41,279 --> 00:15:45,040
you try and do

408
00:15:42,160 --> 00:15:46,160
twice true you get a nice little error

409
00:15:45,040 --> 00:15:48,560
undefined method

410
00:15:46,160 --> 00:15:51,279
plus for boar because all our operators

411
00:15:48,560 --> 00:15:51,279
are methods too

412
00:15:51,360 --> 00:15:55,120
and you can actually get a really nice

413
00:15:53,040 --> 00:15:57,120
long error if you want

414
00:15:55,120 --> 00:15:58,720
which gives you even more details of

415
00:15:57,120 --> 00:16:02,079
where it

416
00:15:58,720 --> 00:16:04,959
um noticed that you were passing a ball

417
00:16:02,079 --> 00:16:06,000
and it can find where your boolean came

418
00:16:04,959 --> 00:16:08,719
from

419
00:16:06,000 --> 00:16:11,120
so you get lots of options for nice

420
00:16:08,720 --> 00:16:11,120
errors

421
00:16:11,199 --> 00:16:18,240
and we have type restrictions so if you

422
00:16:14,800 --> 00:16:21,279
type restricts your argument x to

423
00:16:18,240 --> 00:16:22,000
in 32 or string so this is introducing

424
00:16:21,279 --> 00:16:24,959
union types

425
00:16:22,000 --> 00:16:25,680
so you can specify a type which can be

426
00:16:24,959 --> 00:16:29,119
either a

427
00:16:25,680 --> 00:16:32,319
in 32 or a string so a 32

428
00:16:29,120 --> 00:16:35,040
integer or a string and this restricts

429
00:16:32,320 --> 00:16:36,959
it so that you

430
00:16:35,040 --> 00:16:40,240
explicitly say that this function twice

431
00:16:36,959 --> 00:16:42,079
can only take integers or strings

432
00:16:40,240 --> 00:16:44,079
and you get a slightly nicer type error

433
00:16:42,079 --> 00:16:45,199
if you do that because it doesn't have

434
00:16:44,079 --> 00:16:46,959
to go through and

435
00:16:45,199 --> 00:16:48,880
find out where you've made the error it

436
00:16:46,959 --> 00:16:51,839
can just say you passed in the wrong

437
00:16:48,880 --> 00:16:55,040
type to this function right away

438
00:16:51,839 --> 00:16:57,440
uh a bit of an example about unions

439
00:16:55,040 --> 00:16:58,800
so you have the gets function it gets a

440
00:16:57,440 --> 00:17:00,880
string from the terminal

441
00:16:58,800 --> 00:17:02,240
it can return the string that you typed

442
00:17:00,880 --> 00:17:05,039
in or

443
00:17:02,240 --> 00:17:06,240
if you have an eof like you press ctrl d

444
00:17:05,039 --> 00:17:10,720
at the terminal

445
00:17:06,240 --> 00:17:14,319
end of end of file um it can return nil

446
00:17:10,720 --> 00:17:18,079
so if you write this code hello

447
00:17:14,319 --> 00:17:21,760
what is your name hello your name um

448
00:17:18,079 --> 00:17:24,000
you get a error because gets can return

449
00:17:21,760 --> 00:17:24,000
nil

450
00:17:25,039 --> 00:17:33,039
so a way to solve this

451
00:17:28,640 --> 00:17:36,480
so yeah gets returns string or nil

452
00:17:33,039 --> 00:17:39,679
um we have flow typing

453
00:17:36,480 --> 00:17:42,960
so if you um

454
00:17:39,679 --> 00:17:46,559
you assign your name to gets

455
00:17:42,960 --> 00:17:47,120
and if you you check if you can check

456
00:17:46,559 --> 00:17:50,720
whether

457
00:17:47,120 --> 00:17:53,760
a name is nil and the compiler will

458
00:17:50,720 --> 00:17:57,039
infer that inside this if branch

459
00:17:53,760 --> 00:18:00,320
name cannot be nil name cannot

460
00:17:57,039 --> 00:18:01,679
be the nail type so then you run this

461
00:18:00,320 --> 00:18:04,000
code again

462
00:18:01,679 --> 00:18:05,039
uh because you've essentially said to

463
00:18:04,000 --> 00:18:09,280
the compiler

464
00:18:05,039 --> 00:18:10,799
if the end of file case happens and if

465
00:18:09,280 --> 00:18:12,399
gets returned to nil

466
00:18:10,799 --> 00:18:14,799
then we will do nothing we will not

467
00:18:12,400 --> 00:18:17,600
print any string at all

468
00:18:14,799 --> 00:18:20,240
and that will compile and you've saved

469
00:18:17,600 --> 00:18:20,240
yourself a bug

470
00:18:20,320 --> 00:18:23,760
you have this function chromulate

471
00:18:24,240 --> 00:18:31,760
another example of slow typing um

472
00:18:28,320 --> 00:18:32,720
here we have a perfectly cromulent

473
00:18:31,760 --> 00:18:35,120
function

474
00:18:32,720 --> 00:18:36,000
if you type it if you um give it a

475
00:18:35,120 --> 00:18:38,159
string

476
00:18:36,000 --> 00:18:39,360
then it will take the third character of

477
00:18:38,160 --> 00:18:42,720
the string

478
00:18:39,360 --> 00:18:44,320
or if you type in a number

479
00:18:42,720 --> 00:18:46,480
then it will give you two-thirds of that

480
00:18:44,320 --> 00:18:47,439
number it's a bit of a weird function

481
00:18:46,480 --> 00:18:50,400
but it's a

482
00:18:47,440 --> 00:18:52,799
weird example and this will actually

483
00:18:50,400 --> 00:18:52,799
give you

484
00:18:53,760 --> 00:18:58,799
so what i'm trying to demonstrate here

485
00:18:55,200 --> 00:19:02,880
sorry is that um

486
00:18:58,799 --> 00:19:03,600
the value value can take a different

487
00:19:02,880 --> 00:19:06,559
type

488
00:19:03,600 --> 00:19:07,439
depending on how you've restricted it so

489
00:19:06,559 --> 00:19:10,240
obviously the

490
00:19:07,440 --> 00:19:10,640
bracket the indexing for the third value

491
00:19:10,240 --> 00:19:13,760
of

492
00:19:10,640 --> 00:19:17,440
value will not work if it's

493
00:19:13,760 --> 00:19:21,440
a um in 32 so

494
00:19:17,440 --> 00:19:23,360
if you restrict value to a string then

495
00:19:21,440 --> 00:19:24,480
obviously you can then do that indexing

496
00:19:23,360 --> 00:19:26,479
operation

497
00:19:24,480 --> 00:19:29,360
and if you restrict your knit 32 you can

498
00:19:26,480 --> 00:19:31,440
multiply it by two and divide it

499
00:19:29,360 --> 00:19:33,760
so here at the bottom i've got the

500
00:19:31,440 --> 00:19:38,000
different instantiations of

501
00:19:33,760 --> 00:19:41,520
the chromulate function as well okay

502
00:19:38,000 --> 00:19:43,440
near the end um another

503
00:19:41,520 --> 00:19:45,360
real example of flow typing this time

504
00:19:43,440 --> 00:19:49,200
this is in the standard library

505
00:19:45,360 --> 00:19:49,199
this is a uri resolve

506
00:19:49,600 --> 00:19:54,000
it resolves one ura uri versus another

507
00:19:52,400 --> 00:19:57,120
one so example if you have

508
00:19:54,000 --> 00:19:58,300
example.com uri and then you try and

509
00:19:57,120 --> 00:19:59,600
resolve

510
00:19:58,300 --> 00:20:01,918
[Music]

511
00:19:59,600 --> 00:20:02,959
index.html relative to that you will get

512
00:20:01,919 --> 00:20:06,400
the uri

513
00:20:02,960 --> 00:20:07,919
example.com for index.html so

514
00:20:06,400 --> 00:20:10,240
at the start of this function we need to

515
00:20:07,919 --> 00:20:13,520
work out if you've passed in

516
00:20:10,240 --> 00:20:17,520
another uri or a string to this function

517
00:20:13,520 --> 00:20:20,720
so if it's uri it will duplicate the uri

518
00:20:17,520 --> 00:20:22,080
otherwise it will pass the uri from the

519
00:20:20,720 --> 00:20:24,159
string that you pass in

520
00:20:22,080 --> 00:20:26,639
this is one function which takes a union

521
00:20:24,159 --> 00:20:30,400
type and then it will

522
00:20:26,640 --> 00:20:33,520
based on that union type it will

523
00:20:30,400 --> 00:20:36,799
do a different thing and this is

524
00:20:33,520 --> 00:20:40,240
flow typing because

525
00:20:36,799 --> 00:20:44,240
uh the target variable

526
00:20:40,240 --> 00:20:47,200
has a different um different type of

527
00:20:44,240 --> 00:20:48,000
multiple different points in this um

528
00:20:47,200 --> 00:20:51,600
function

529
00:20:48,000 --> 00:20:55,760
so at the top here it's a uri or string

530
00:20:51,600 --> 00:20:59,120
union um here it's only uri

531
00:20:55,760 --> 00:21:00,720
so you can call duplicate and

532
00:20:59,120 --> 00:21:02,399
here it's only a string because you've

533
00:21:00,720 --> 00:21:04,559
removed your life in the union it can

534
00:21:02,400 --> 00:21:06,799
only ever be a string here

535
00:21:04,559 --> 00:21:08,320
so you can pass that string into ui.pass

536
00:21:06,799 --> 00:21:10,400
and get another uri

537
00:21:08,320 --> 00:21:11,520
and at the end at the end of this if

538
00:21:10,400 --> 00:21:14,240
branch

539
00:21:11,520 --> 00:21:17,760
then target will be a uri because you've

540
00:21:14,240 --> 00:21:19,600
written code to ensure that

541
00:21:17,760 --> 00:21:21,039
so we're going to end up with a

542
00:21:19,600 --> 00:21:25,600
comparison of crystal

543
00:21:21,039 --> 00:21:29,600
versus um how we've done essentially

544
00:21:25,600 --> 00:21:32,080
how crystal does as a dynamic language

545
00:21:29,600 --> 00:21:34,639
versus a statically typed language and

546
00:21:32,080 --> 00:21:38,799
how it compromises between the two

547
00:21:34,640 --> 00:21:40,720
so types are in crystal aren't mentioned

548
00:21:38,799 --> 00:21:43,520
more than dynamic languages

549
00:21:40,720 --> 00:21:44,000
so you can write crystal code and it

550
00:21:43,520 --> 00:21:46,960
looks like

551
00:21:44,000 --> 00:21:48,480
ruby it feels like ruby and you don't

552
00:21:46,960 --> 00:21:48,799
have to write types all over the place

553
00:21:48,480 --> 00:21:53,520
like

554
00:21:48,799 --> 00:21:55,200
java or c-sharp um

555
00:21:53,520 --> 00:21:56,799
types change and flow like a dynamic

556
00:21:55,200 --> 00:21:59,039
language the flow typing that i've

557
00:21:56,799 --> 00:22:02,799
demonstrated to my examples

558
00:21:59,039 --> 00:22:04,879
you don't have to think about

559
00:22:02,799 --> 00:22:06,080
one variable is one not one type it can

560
00:22:04,880 --> 00:22:08,159
change throughout the

561
00:22:06,080 --> 00:22:09,280
course of a function and you can write

562
00:22:08,159 --> 00:22:12,960
neat code

563
00:22:09,280 --> 00:22:14,720
using that and write code which is that

564
00:22:12,960 --> 00:22:17,440
feels a lot more familiar to you as a

565
00:22:14,720 --> 00:22:20,320
dynamic language programmer

566
00:22:17,440 --> 00:22:20,880
um this i haven't covered yield itself

567
00:22:20,320 --> 00:22:22,799
but it's

568
00:22:20,880 --> 00:22:24,960
if you look in the documentation it's a

569
00:22:22,799 --> 00:22:27,039
very nice way to

570
00:22:24,960 --> 00:22:29,600
allow expressive type safety sales in

571
00:22:27,039 --> 00:22:32,879
crystal which is something which

572
00:22:29,600 --> 00:22:35,760
i think crystal excels very well at

573
00:22:32,880 --> 00:22:36,159
we have nil safety everything is checked

574
00:22:35,760 --> 00:22:39,520
every

575
00:22:36,159 --> 00:22:40,000
you will never have a null pointer

576
00:22:39,520 --> 00:22:41,520
exception

577
00:22:40,000 --> 00:22:43,600
like in java you will never have one of

578
00:22:41,520 --> 00:22:46,639
those again if you use crystal

579
00:22:43,600 --> 00:22:47,280
um you have memory safety as well there

580
00:22:46,640 --> 00:22:50,960
will

581
00:22:47,280 --> 00:22:53,039
never be any uh never be any

582
00:22:50,960 --> 00:22:55,840
seg faults in crystal unless you use

583
00:22:53,039 --> 00:22:55,840
unsaved code

584
00:22:56,960 --> 00:23:02,159
and other good things at crystal it's

585
00:22:59,840 --> 00:23:04,639
object orientated like ruby

586
00:23:02,159 --> 00:23:05,600
we have csp concurrency so if you've

587
00:23:04,640 --> 00:23:08,640
used go

588
00:23:05,600 --> 00:23:09,918
we have a good implementation of

589
00:23:08,640 --> 00:23:12,080
essentially the same thing as go

590
00:23:09,919 --> 00:23:13,039
routines and channels we have fibers and

591
00:23:12,080 --> 00:23:16,320
channels

592
00:23:13,039 --> 00:23:18,799
and so crystal is very good at

593
00:23:16,320 --> 00:23:20,439
concurrency everything's asynchronous io

594
00:23:18,799 --> 00:23:21,918
by default so it's very good for

595
00:23:20,440 --> 00:23:25,120
developing

596
00:23:21,919 --> 00:23:26,960
daemons web applications servers

597
00:23:25,120 --> 00:23:28,479
a lot of people use it for that you've

598
00:23:26,960 --> 00:23:31,360
got a simple tool chain

599
00:23:28,480 --> 00:23:33,919
it's a very easy to use tool chain at

600
00:23:31,360 --> 00:23:36,399
the command line

601
00:23:33,919 --> 00:23:38,000
very fast generated code because we have

602
00:23:36,400 --> 00:23:38,799
all these guarantees about types we can

603
00:23:38,000 --> 00:23:41,200
use that

604
00:23:38,799 --> 00:23:43,200
feed the result into lvm and get

605
00:23:41,200 --> 00:23:46,320
essentially code which runs at the

606
00:23:43,200 --> 00:23:48,320
at the same speed as c but

607
00:23:46,320 --> 00:23:50,080
it feels like a dynamic language and it

608
00:23:48,320 --> 00:23:52,559
looks like a dynamic language

609
00:23:50,080 --> 00:23:54,720
but you get all the type safety as well

610
00:23:52,559 --> 00:23:57,918
so try it out it's fun

611
00:23:54,720 --> 00:23:59,360
uh there's the url crystalling finished

612
00:23:57,919 --> 00:24:05,840
right on time apparently

613
00:23:59,360 --> 00:24:05,840
ask me questions

614
00:24:07,650 --> 00:24:10,859
[Applause]

615
00:24:12,000 --> 00:24:15,760
nothing i did well then you what's the

616
00:24:14,720 --> 00:24:19,039
question

617
00:24:15,760 --> 00:24:19,600
uh about the flow typing yes how does it

618
00:24:19,039 --> 00:24:22,320
resolve

619
00:24:19,600 --> 00:24:23,279
uh does it resolve loops uh yes it does

620
00:24:22,320 --> 00:24:26,320
resolve loops

621
00:24:23,279 --> 00:24:29,520
essentially um

622
00:24:26,320 --> 00:24:30,320
yeah there's a fixed point um so the

623
00:24:29,520 --> 00:24:33,360
question was

624
00:24:30,320 --> 00:24:35,200
how does uh crystal deal with how does

625
00:24:33,360 --> 00:24:37,520
flow typing interact with loops and

626
00:24:35,200 --> 00:24:41,120
essentially there's a fixed point which

627
00:24:37,520 --> 00:24:41,120
the crystal compiler can work out

628
00:24:45,200 --> 00:24:49,120
checking and yes that crystal uh threw

629
00:24:47,440 --> 00:24:51,440
an exception

630
00:24:49,120 --> 00:24:52,320
can you flow the dimensions of the error

631
00:24:51,440 --> 00:24:56,880
as part

632
00:24:52,320 --> 00:24:58,799
as part of the type the question is

633
00:24:56,880 --> 00:25:01,520
with bounds checking for rays is it

634
00:24:58,799 --> 00:25:04,400
possible to

635
00:25:01,520 --> 00:25:06,240
look at the possible range of values

636
00:25:04,400 --> 00:25:09,679
that the

637
00:25:06,240 --> 00:25:10,480
array index can take and elide the

638
00:25:09,679 --> 00:25:12,240
band's check

639
00:25:10,480 --> 00:25:14,000
in that case and the answer is no

640
00:25:12,240 --> 00:25:17,919
crystal can't do this optimization

641
00:25:14,000 --> 00:25:19,440
just yet but it's something we'll

642
00:25:17,919 --> 00:25:21,840
probably look at later

643
00:25:19,440 --> 00:25:24,000
we're focused on getting the language to

644
00:25:21,840 --> 00:25:25,918
1.0 supporting windows other

645
00:25:24,000 --> 00:25:28,320
different types of things before working

646
00:25:25,919 --> 00:25:29,600
on optimizations like that thank you we

647
00:25:28,320 --> 00:25:30,559
need to switch greek speakers because

648
00:25:29,600 --> 00:25:32,959
they're both

649
00:25:30,559 --> 00:25:33,840
also volunteers in this room okay it

650
00:25:32,960 --> 00:25:43,840
gets complicated

651
00:25:33,840 --> 00:25:43,840
thank you

652
00:25:54,840 --> 00:26:09,279
uh

653
00:25:57,520 --> 00:26:09,279
make sure

