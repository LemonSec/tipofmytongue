1
00:00:06,080 --> 00:00:09,679
right

2
00:00:06,640 --> 00:00:10,639
so hello everyone um in the agenda it

3
00:00:09,679 --> 00:00:12,719
says that

4
00:00:10,639 --> 00:00:14,239
i was i was supposed to to be joined by

5
00:00:12,719 --> 00:00:15,599
my colleague fabian

6
00:00:14,240 --> 00:00:17,440
but he could not come because of

7
00:00:15,599 --> 00:00:18,640
logistics reasons so if you came here

8
00:00:17,440 --> 00:00:21,840
just to listen to him

9
00:00:18,640 --> 00:00:22,400
you'll be disappointed so my talk is

10
00:00:21,840 --> 00:00:24,560
called

11
00:00:22,400 --> 00:00:26,159
llvm meets code property graphs and

12
00:00:24,560 --> 00:00:28,160
today i want to talk about this thing

13
00:00:26,160 --> 00:00:30,400
like what is called property graphs and

14
00:00:28,160 --> 00:00:32,960
its application in the security and

15
00:00:30,400 --> 00:00:35,120
software analysis domain

16
00:00:32,960 --> 00:00:36,399
so a few words about me uh if you want

17
00:00:35,120 --> 00:00:38,879
to to find out more

18
00:00:36,399 --> 00:00:40,399
uh there is a blog i'm on twitter and

19
00:00:38,879 --> 00:00:41,440
also you can drop me an email if you

20
00:00:40,399 --> 00:00:43,920
have any questions

21
00:00:41,440 --> 00:00:45,519
and such so i work for a company called

22
00:00:43,920 --> 00:00:48,800
shift left security and

23
00:00:45,520 --> 00:00:49,440
we are basically building the tools for

24
00:00:48,800 --> 00:00:51,199
custom

25
00:00:49,440 --> 00:00:52,718
static code analysis so my

26
00:00:51,199 --> 00:00:55,519
responsibility there is to

27
00:00:52,719 --> 00:00:57,120
make it work with llvm so that we can

28
00:00:55,520 --> 00:01:00,239
handle languages like cc

29
00:00:57,120 --> 00:01:01,120
plus and so on like more more of them so

30
00:01:00,239 --> 00:01:04,319
before we start

31
00:01:01,120 --> 00:01:07,439
um yeah i want to ask you some questions

32
00:01:04,319 --> 00:01:12,479
uh can you see a problem with this code

33
00:01:07,439 --> 00:01:15,439
anyone just shout like

34
00:01:12,479 --> 00:01:16,479
yeah double free nice so it was like

35
00:01:15,439 --> 00:01:20,399
four seconds

36
00:01:16,479 --> 00:01:20,400
um can you see a problem on this code

37
00:01:20,479 --> 00:01:24,080
use after three yeah that was actually

38
00:01:22,080 --> 00:01:27,679
faster but um

39
00:01:24,080 --> 00:01:29,840
can you see a problem in this code

40
00:01:27,680 --> 00:01:31,520
so apparently you can if you if you get

41
00:01:29,840 --> 00:01:33,439
uh if you have enough time

42
00:01:31,520 --> 00:01:35,679
and power you can probably spend some

43
00:01:33,439 --> 00:01:37,360
ages and to analyze it manually to see

44
00:01:35,680 --> 00:01:39,840
how it works and so on but

45
00:01:37,360 --> 00:01:40,960
yeah that's not practical therefore we

46
00:01:39,840 --> 00:01:43,360
kind of have to use

47
00:01:40,960 --> 00:01:45,520
some tooling and gently ask machines to

48
00:01:43,360 --> 00:01:48,960
help us with with this task

49
00:01:45,520 --> 00:01:52,479
so i want to show you some demo so

50
00:01:48,960 --> 00:01:54,399
this is the basic example the first one

51
00:01:52,479 --> 00:01:55,920
was double free like how do you find it

52
00:01:54,399 --> 00:01:58,079
was with the tooling

53
00:01:55,920 --> 00:01:59,840
so first you need to create uh to load

54
00:01:58,079 --> 00:02:01,679
this program into memory and

55
00:01:59,840 --> 00:02:04,079
uh yeah so that you can can run some

56
00:02:01,680 --> 00:02:07,600
queries to analyze it

57
00:02:04,079 --> 00:02:10,720
then it's actually very easy it's

58
00:02:07,600 --> 00:02:10,720
yeah it's an easy example

59
00:02:10,800 --> 00:02:16,000
um yeah so to find double free

60
00:02:13,920 --> 00:02:17,920
uh we just need uh from like dataflow

61
00:02:16,000 --> 00:02:18,319
perspective we just need to find a floor

62
00:02:17,920 --> 00:02:21,440
from

63
00:02:18,319 --> 00:02:22,160
one free call uh to the other one where

64
00:02:21,440 --> 00:02:25,760
the parameter

65
00:02:22,160 --> 00:02:28,079
is the same so we have a source

66
00:02:25,760 --> 00:02:29,840
which is the parameter of the free and

67
00:02:28,080 --> 00:02:32,160
we also have a sink

68
00:02:29,840 --> 00:02:33,360
that is also parameter to the the

69
00:02:32,160 --> 00:02:37,200
function three

70
00:02:33,360 --> 00:02:40,560
so now if if i run

71
00:02:37,200 --> 00:02:42,959
like show me all the flaws from sync to

72
00:02:40,560 --> 00:02:42,959
swords

73
00:02:44,000 --> 00:02:47,360
yeah then it doesn't work because i

74
00:02:45,840 --> 00:02:50,560
forgot

75
00:02:47,360 --> 00:02:53,440
one thing all flows

76
00:02:50,560 --> 00:02:54,800
yeah here we are so it says that uh the

77
00:02:53,440 --> 00:02:58,000
first call is

78
00:02:54,800 --> 00:02:58,640
uh at line six in file m and the second

79
00:02:58,000 --> 00:03:02,080
one and

80
00:02:58,640 --> 00:03:04,399
line eight so you can run

81
00:03:02,080 --> 00:03:06,640
more sophisticated queries for that but

82
00:03:04,400 --> 00:03:09,920
we'll get to it

83
00:03:06,640 --> 00:03:12,079
in a moment yeah so

84
00:03:09,920 --> 00:03:13,760
this tool is basically built on this

85
00:03:12,080 --> 00:03:16,560
idea of property graphs

86
00:03:13,760 --> 00:03:18,000
and before that i have to make a step

87
00:03:16,560 --> 00:03:20,319
back and talk about the property

88
00:03:18,000 --> 00:03:21,920
graphs in general so i assume that you

89
00:03:20,319 --> 00:03:24,720
probably all know what the graph

90
00:03:21,920 --> 00:03:26,480
is uh if not so basically you have some

91
00:03:24,720 --> 00:03:28,400
set of nodes and those nodes are

92
00:03:26,480 --> 00:03:31,119
connected with just some edges

93
00:03:28,400 --> 00:03:32,080
like some by some means and the property

94
00:03:31,120 --> 00:03:34,560
graph it's basically

95
00:03:32,080 --> 00:03:35,840
an extension of graph or uh it's also

96
00:03:34,560 --> 00:03:39,120
called multi-graph

97
00:03:35,840 --> 00:03:41,599
where the nodes they may have several

98
00:03:39,120 --> 00:03:43,280
uh edges connected like two nodes may be

99
00:03:41,599 --> 00:03:45,119
connected by several edges

100
00:03:43,280 --> 00:03:46,640
and those edges and nodes as well they

101
00:03:45,120 --> 00:03:48,799
may have a number of

102
00:03:46,640 --> 00:03:51,119
properties basically like key value

103
00:03:48,799 --> 00:03:51,120
things

104
00:03:51,360 --> 00:03:54,720
yeah and the cpg the code property graph

105
00:03:54,159 --> 00:03:56,959
it

106
00:03:54,720 --> 00:03:57,920
takes several representations of the

107
00:03:56,959 --> 00:04:01,439
program

108
00:03:57,920 --> 00:04:04,079
namely it combines ast it combines the

109
00:04:01,439 --> 00:04:05,840
control flow graph and program

110
00:04:04,080 --> 00:04:09,519
dependence graph

111
00:04:05,840 --> 00:04:10,400
so in the end uh basically you have this

112
00:04:09,519 --> 00:04:13,360
multi graph

113
00:04:10,400 --> 00:04:14,080
somewhere in memory or not and normally

114
00:04:13,360 --> 00:04:17,440
uh

115
00:04:14,080 --> 00:04:18,320
there are tools like neo4j or apache

116
00:04:17,440 --> 00:04:20,798
something

117
00:04:18,320 --> 00:04:21,599
that uh allow you to work with the with

118
00:04:20,798 --> 00:04:22,880
those graphs

119
00:04:21,600 --> 00:04:24,800
so basically you can just run some

120
00:04:22,880 --> 00:04:27,440
queries like if you do with

121
00:04:24,800 --> 00:04:28,080
sql you can just like select from blah

122
00:04:27,440 --> 00:04:30,160
blah

123
00:04:28,080 --> 00:04:31,919
and this is basically uh what's what

124
00:04:30,160 --> 00:04:33,040
happens here in this in this example so

125
00:04:31,919 --> 00:04:37,919
we just run queries

126
00:04:33,040 --> 00:04:39,840
against the database so

127
00:04:37,919 --> 00:04:41,599
the beautiful part of this code property

128
00:04:39,840 --> 00:04:43,280
graph or at least this implementation

129
00:04:41,600 --> 00:04:46,000
effects that

130
00:04:43,280 --> 00:04:46,799
uh it's kind of multi-layered thing so

131
00:04:46,000 --> 00:04:48,960
at the very

132
00:04:46,800 --> 00:04:50,400
uh on this example at the very low level

133
00:04:48,960 --> 00:04:52,960
you have just like

134
00:04:50,400 --> 00:04:54,960
rough database representation and it's

135
00:04:52,960 --> 00:04:55,599
not really nice to work with as a human

136
00:04:54,960 --> 00:04:57,039
being

137
00:04:55,600 --> 00:04:59,759
because you just need to write lots of

138
00:04:57,040 --> 00:05:01,759
boilerplates for us for some things

139
00:04:59,759 --> 00:05:03,280
so for the cut property graph there is

140
00:05:01,759 --> 00:05:05,440
another level that uh

141
00:05:03,280 --> 00:05:07,198
adds some more like syntactic sugar so

142
00:05:05,440 --> 00:05:10,320
that you can run some simple queries

143
00:05:07,199 --> 00:05:13,520
and find more information

144
00:05:10,320 --> 00:05:17,280
there are more overlays and

145
00:05:13,520 --> 00:05:19,359
all of them are they are domain specific

146
00:05:17,280 --> 00:05:20,400
so for example in our application uh

147
00:05:19,360 --> 00:05:23,440
there are some

148
00:05:20,400 --> 00:05:26,560
specific overlays for web applications

149
00:05:23,440 --> 00:05:28,080
saying that okay you have basically you

150
00:05:26,560 --> 00:05:30,400
just like load the cpg

151
00:05:28,080 --> 00:05:31,520
into the program and then you run a

152
00:05:30,400 --> 00:05:33,919
query like show me

153
00:05:31,520 --> 00:05:34,799
all sql injections and it shows the

154
00:05:33,919 --> 00:05:38,320
flows from

155
00:05:34,800 --> 00:05:40,080
uh api route to

156
00:05:38,320 --> 00:05:42,000
to some some place in the code where the

157
00:05:40,080 --> 00:05:46,000
sql injection may may happen

158
00:05:42,000 --> 00:05:46,000
and it may be exploited by the user

159
00:05:48,000 --> 00:05:53,039
yeah so if you're familiar with llvm or

160
00:05:50,720 --> 00:05:57,039
clank or and its architecture then

161
00:05:53,039 --> 00:05:59,599
you will recognize this slide basically

162
00:05:57,039 --> 00:06:02,000
so what cpg is it just another

163
00:05:59,600 --> 00:06:04,880
intermediate representation that

164
00:06:02,000 --> 00:06:05,520
just presents the program so at the

165
00:06:04,880 --> 00:06:08,319
front end

166
00:06:05,520 --> 00:06:09,919
uh there is a number of uh yeah number

167
00:06:08,319 --> 00:06:13,120
of front ends for each language

168
00:06:09,919 --> 00:06:15,280
so that they emit the cpg and then cpg

169
00:06:13,120 --> 00:06:18,400
is being used by the back end

170
00:06:15,280 --> 00:06:22,080
so currently uh yeah originally

171
00:06:18,400 --> 00:06:22,960
uh we're using the neo4j it's the graph

172
00:06:22,080 --> 00:06:25,520
database

173
00:06:22,960 --> 00:06:26,799
but it's like too general and it just uh

174
00:06:25,520 --> 00:06:29,280
doesn't really fit the

175
00:06:26,800 --> 00:06:30,560
our needs and it's it was too slow

176
00:06:29,280 --> 00:06:32,239
because

177
00:06:30,560 --> 00:06:34,319
if you want to to analyze some big

178
00:06:32,240 --> 00:06:35,840
projects and you you should load the

179
00:06:34,319 --> 00:06:37,600
whole database in the memory

180
00:06:35,840 --> 00:06:38,880
and for some projects it may require

181
00:06:37,600 --> 00:06:41,520
like

182
00:06:38,880 --> 00:06:42,400
hundreds or tens of gigabytes so an

183
00:06:41,520 --> 00:06:46,240
overflow db

184
00:06:42,400 --> 00:06:48,799
is just uh the same graph database that

185
00:06:46,240 --> 00:06:50,880
stores the information it lost the

186
00:06:48,800 --> 00:06:52,479
information lazily and if it not if it

187
00:06:50,880 --> 00:06:55,120
doesn't need anything it just

188
00:06:52,479 --> 00:06:56,479
can overflow it on the disk so basically

189
00:06:55,120 --> 00:06:58,000
if you don't have enough memory on your

190
00:06:56,479 --> 00:07:00,240
machine you can still use it but

191
00:06:58,000 --> 00:07:02,240
uh you pay with performance because of

192
00:07:00,240 --> 00:07:04,479
the swaps with the disk

193
00:07:02,240 --> 00:07:05,440
so and what what i've shown this uh

194
00:07:04,479 --> 00:07:07,280
command line tool

195
00:07:05,440 --> 00:07:09,199
it's called ocular there is a

196
00:07:07,280 --> 00:07:11,919
counterpart it's called urine

197
00:07:09,199 --> 00:07:14,080
so the urine is the open source part

198
00:07:11,919 --> 00:07:16,479
it's uh

199
00:07:14,080 --> 00:07:17,120
it's yeah mainly targeted for cnc plus

200
00:07:16,479 --> 00:07:20,159
plus and

201
00:07:17,120 --> 00:07:23,120
it's using the fuzzy c front end

202
00:07:20,160 --> 00:07:26,000
and fuzzy means that uh it's not real uh

203
00:07:23,120 --> 00:07:30,400
compiler front end it's just

204
00:07:26,000 --> 00:07:32,400
sort of a set of uh regular expressions

205
00:07:30,400 --> 00:07:34,159
it's yeah it's it's more complicated

206
00:07:32,400 --> 00:07:36,560
than that but uh that's

207
00:07:34,160 --> 00:07:38,400
yeah not important the ocular is more

208
00:07:36,560 --> 00:07:40,639
it's a commercial tool

209
00:07:38,400 --> 00:07:42,239
uh but it's very similar to urine its

210
00:07:40,639 --> 00:07:44,160
capabilities but it has just more

211
00:07:42,240 --> 00:07:44,879
overlays for the main specific things

212
00:07:44,160 --> 00:07:46,560
like

213
00:07:44,879 --> 00:07:48,720
i know some enterprise apps and

214
00:07:46,560 --> 00:07:51,440
customers and such

215
00:07:48,720 --> 00:07:53,520
so my goal today is to talk more about

216
00:07:51,440 --> 00:07:55,199
the llvm to cpg

217
00:07:53,520 --> 00:07:57,599
so originally the project was born

218
00:07:55,199 --> 00:07:59,599
because we have some customers and

219
00:07:57,599 --> 00:08:01,520
clients they use fuzzy c to cpg

220
00:07:59,599 --> 00:08:03,280
but it's not quite good for when it

221
00:08:01,520 --> 00:08:05,280
comes to c plus plus or when you

222
00:08:03,280 --> 00:08:06,559
want to get some better idea of a

223
00:08:05,280 --> 00:08:08,479
program

224
00:08:06,560 --> 00:08:10,160
it has some advantages like you don't

225
00:08:08,479 --> 00:08:11,120
have to compile the code you can just

226
00:08:10,160 --> 00:08:13,199
run

227
00:08:11,120 --> 00:08:14,479
run it on some source files and it will

228
00:08:13,199 --> 00:08:17,039
just work

229
00:08:14,479 --> 00:08:19,120
but so there were many requests to to

230
00:08:17,039 --> 00:08:23,039
add better support for cnc plus plus

231
00:08:19,120 --> 00:08:25,120
so this is how lvmcpg started

232
00:08:23,039 --> 00:08:26,318
the question that i'm always getting

233
00:08:25,120 --> 00:08:29,599
when i talk about this stuff

234
00:08:26,319 --> 00:08:30,400
that uh why it's llvm pcpg and not clang

235
00:08:29,599 --> 00:08:32,399
to cpg

236
00:08:30,400 --> 00:08:34,000
because i mean it's it's like obvious

237
00:08:32,399 --> 00:08:36,399
that uh you can get

238
00:08:34,000 --> 00:08:37,279
much better uh information from the

239
00:08:36,399 --> 00:08:40,159
source code

240
00:08:37,279 --> 00:08:41,279
and if you go to the llvm level you lose

241
00:08:40,159 --> 00:08:44,000
some information

242
00:08:41,279 --> 00:08:45,760
so we acknowledged that but we also were

243
00:08:44,000 --> 00:08:46,959
curious about some other parts like what

244
00:08:45,760 --> 00:08:48,080
are the other advantages and

245
00:08:46,959 --> 00:08:50,399
disadvantages

246
00:08:48,080 --> 00:08:52,240
and the other one is integration it's

247
00:08:50,399 --> 00:08:53,279
arguable but in my opinion it's much

248
00:08:52,240 --> 00:08:55,760
easier to get

249
00:08:53,279 --> 00:08:56,800
lvm bit code then connect some clank

250
00:08:55,760 --> 00:09:00,160
tool to

251
00:08:56,800 --> 00:09:03,599
archive build system or let's say some

252
00:09:00,160 --> 00:09:05,120
xcode projects on macos platform

253
00:09:03,600 --> 00:09:06,959
yeah the other part that supported

254
00:09:05,120 --> 00:09:10,320
languages so

255
00:09:06,959 --> 00:09:11,439
uh if we want let's say yeah it's it's

256
00:09:10,320 --> 00:09:14,000
very common on

257
00:09:11,440 --> 00:09:15,120
macos platform that objective c code mix

258
00:09:14,000 --> 00:09:16,880
with swift

259
00:09:15,120 --> 00:09:18,399
for that you cannot use just clank you

260
00:09:16,880 --> 00:09:20,720
would have to we would have to

261
00:09:18,399 --> 00:09:22,640
combine swift compiler and clan compiler

262
00:09:20,720 --> 00:09:24,640
and somehow cooperate with this

263
00:09:22,640 --> 00:09:26,080
but because of the llvm like as a

264
00:09:24,640 --> 00:09:28,959
baseline we can just

265
00:09:26,080 --> 00:09:29,440
use multiple uh source languages in in

266
00:09:28,959 --> 00:09:31,839
one

267
00:09:29,440 --> 00:09:32,640
in one place and also the language

268
00:09:31,839 --> 00:09:35,839
feature set

269
00:09:32,640 --> 00:09:36,160
so c c plus plus objective c they are

270
00:09:35,839 --> 00:09:38,399
just

271
00:09:36,160 --> 00:09:40,000
huge we could have built the support for

272
00:09:38,399 --> 00:09:40,800
that but it would probably take several

273
00:09:40,000 --> 00:09:42,320
years

274
00:09:40,800 --> 00:09:43,839
and with a little vm it's much much

275
00:09:42,320 --> 00:09:45,920
smaller uh that

276
00:09:43,839 --> 00:09:47,600
basically means that the time to market

277
00:09:45,920 --> 00:09:49,120
is much faster

278
00:09:47,600 --> 00:09:51,200
yeah so these are these are the

279
00:09:49,120 --> 00:09:53,279
conclusions um

280
00:09:51,200 --> 00:09:56,720
some of them yeah arguable but that's

281
00:09:53,279 --> 00:09:56,720
the state current state

282
00:09:56,800 --> 00:10:02,319
yeah so the strategy was that uh we

283
00:10:00,240 --> 00:10:04,000
take a little vmg code as a baseline and

284
00:10:02,320 --> 00:10:07,120
then uh basically

285
00:10:04,000 --> 00:10:08,560
oriented by feedback we just uh yeah

286
00:10:07,120 --> 00:10:10,560
basically customers say okay

287
00:10:08,560 --> 00:10:13,040
we don't see something in objective c

288
00:10:10,560 --> 00:10:15,439
code and we just add support for that

289
00:10:13,040 --> 00:10:16,800
and we are dream driven by feedback in

290
00:10:15,440 --> 00:10:18,720
this case

291
00:10:16,800 --> 00:10:21,279
so previously i mentioned that uh we

292
00:10:18,720 --> 00:10:21,920
have ast right the part of the cpg is

293
00:10:21,279 --> 00:10:24,240
ast

294
00:10:21,920 --> 00:10:25,199
but we kind of don't have that at lvm

295
00:10:24,240 --> 00:10:28,240
level

296
00:10:25,200 --> 00:10:29,600
uh but still we can mimic it so

297
00:10:28,240 --> 00:10:31,120
on the left there is very simple

298
00:10:29,600 --> 00:10:32,800
function identity that just takes the

299
00:10:31,120 --> 00:10:34,560
parameter and returns it and on the

300
00:10:32,800 --> 00:10:35,920
right you can see the loving bit code

301
00:10:34,560 --> 00:10:38,800
that just

302
00:10:35,920 --> 00:10:39,680
not optimized thus does the same so

303
00:10:38,800 --> 00:10:42,560
first we

304
00:10:39,680 --> 00:10:43,040
uh made an assumption that okay we'll

305
00:10:42,560 --> 00:10:45,040
treat

306
00:10:43,040 --> 00:10:46,079
every llvm instruction as a function

307
00:10:45,040 --> 00:10:48,640
call

308
00:10:46,079 --> 00:10:50,079
so it's it's not really useful uh for

309
00:10:48,640 --> 00:10:51,760
especially for the user for

310
00:10:50,079 --> 00:10:53,920
human beings who use the tool because

311
00:10:51,760 --> 00:10:55,360
they just it just doesn't make sense

312
00:10:53,920 --> 00:10:57,279
like loads and stores like it's

313
00:10:55,360 --> 00:11:01,279
basically working on the assembly level

314
00:10:57,279 --> 00:11:03,760
not as nice so then we applied some

315
00:11:01,279 --> 00:11:03,760
um

316
00:11:04,320 --> 00:11:08,240
yeah made some some other assumptions

317
00:11:05,839 --> 00:11:10,079
and basically okay we specialized some

318
00:11:08,240 --> 00:11:12,320
of those instructions and basically load

319
00:11:10,079 --> 00:11:15,599
and store they are just assignments with

320
00:11:12,320 --> 00:11:18,560
um direction so that we could build

321
00:11:15,600 --> 00:11:20,880
in the end from from this uh bit code we

322
00:11:18,560 --> 00:11:23,119
could build the ast that looks like this

323
00:11:20,880 --> 00:11:25,680
so it's not a one-to-one mapping just

324
00:11:23,120 --> 00:11:29,360
just as an example

325
00:11:25,680 --> 00:11:32,560
uh then with this st we could build the

326
00:11:29,360 --> 00:11:34,720
add cfg connections

327
00:11:32,560 --> 00:11:36,319
yeah and with this code we can now it's

328
00:11:34,720 --> 00:11:37,519
full now it's complete and we can run

329
00:11:36,320 --> 00:11:40,839
some things

330
00:11:37,519 --> 00:11:43,200
some queries and find some nice

331
00:11:40,839 --> 00:11:46,399
properties

332
00:11:43,200 --> 00:11:47,760
so yeah as i mentioned uh we acknowledge

333
00:11:46,399 --> 00:11:49,360
that we lose the information

334
00:11:47,760 --> 00:11:51,519
but we are still curious like what kind

335
00:11:49,360 --> 00:11:54,880
of of information we lose

336
00:11:51,519 --> 00:11:56,240
and the one is the yeah comes about

337
00:11:54,880 --> 00:11:57,920
types because this is

338
00:11:56,240 --> 00:12:00,160
probably the most interesting part when

339
00:11:57,920 --> 00:12:02,479
you do analysis as a security person

340
00:12:00,160 --> 00:12:03,519
because uh yeah what i observed people

341
00:12:02,480 --> 00:12:05,760
look for

342
00:12:03,519 --> 00:12:07,279
things like okay find all the members

343
00:12:05,760 --> 00:12:10,639
named length

344
00:12:07,279 --> 00:12:12,959
and see if if this length can be uh

345
00:12:10,639 --> 00:12:14,720
controlled by something and if this

346
00:12:12,959 --> 00:12:16,880
length is participating in the

347
00:12:14,720 --> 00:12:19,519
malloc course for example because then

348
00:12:16,880 --> 00:12:21,920
you can probably exploit the stuff

349
00:12:19,519 --> 00:12:23,279
so with the names of the structs itself

350
00:12:21,920 --> 00:12:25,839
of the types

351
00:12:23,279 --> 00:12:27,120
they are there some like most of the

352
00:12:25,839 --> 00:12:29,440
time they are in place

353
00:12:27,120 --> 00:12:31,040
and uh they available but we definitely

354
00:12:29,440 --> 00:12:32,720
lose the names of the members because

355
00:12:31,040 --> 00:12:34,399
for llvm it just doesn't matter it's

356
00:12:32,720 --> 00:12:37,440
just like indices uh

357
00:12:34,399 --> 00:12:39,680
zero one two whatever but we still can

358
00:12:37,440 --> 00:12:40,639
look at the debug information and if

359
00:12:39,680 --> 00:12:43,680
it's present of course

360
00:12:40,639 --> 00:12:46,000
and attach the right names for structs

361
00:12:43,680 --> 00:12:46,880
but that's certainly not the case for

362
00:12:46,000 --> 00:12:48,720
unions

363
00:12:46,880 --> 00:12:50,639
because at the at the source level we

364
00:12:48,720 --> 00:12:53,760
can have two uh

365
00:12:50,639 --> 00:12:54,720
two members of a union but at the llvm

366
00:12:53,760 --> 00:12:57,680
level it just

367
00:12:54,720 --> 00:12:58,160
like one one field like was one property

368
00:12:57,680 --> 00:13:01,120
and

369
00:12:58,160 --> 00:13:02,639
it's always uh so from the call like to

370
00:13:01,120 --> 00:13:04,959
get element pointer

371
00:13:02,639 --> 00:13:06,639
it's index zero we cannot know uh

372
00:13:04,959 --> 00:13:10,160
whether it was using the

373
00:13:06,639 --> 00:13:10,160
a or b in this example

374
00:13:11,200 --> 00:13:18,240
yeah the other part that was

375
00:13:14,240 --> 00:13:21,279
a bit surprising not unexpected but

376
00:13:18,240 --> 00:13:24,480
the abi plays a huge role in this uh

377
00:13:21,279 --> 00:13:25,760
in this conversion so at the source code

378
00:13:24,480 --> 00:13:27,200
level we have a

379
00:13:25,760 --> 00:13:29,040
function that takes a struct as a

380
00:13:27,200 --> 00:13:31,440
parameter and returns a struct

381
00:13:29,040 --> 00:13:32,480
and if uh on this the cpg level if you

382
00:13:31,440 --> 00:13:34,560
want to run a query

383
00:13:32,480 --> 00:13:36,720
okay find all the functions that return

384
00:13:34,560 --> 00:13:38,719
the construct

385
00:13:36,720 --> 00:13:40,880
what's this named color then you'll not

386
00:13:38,720 --> 00:13:42,000
find anything because of the llvm level

387
00:13:40,880 --> 00:13:44,079
it returns void

388
00:13:42,000 --> 00:13:46,720
and instead it takes two structs as the

389
00:13:44,079 --> 00:13:46,719
parameters

390
00:13:46,880 --> 00:13:50,480
yeah and it it gets even worse uh with

391
00:13:49,360 --> 00:13:52,160
different types because

392
00:13:50,480 --> 00:13:53,680
in this example these are all doubles

393
00:13:52,160 --> 00:13:56,719
and they are kind of passed as

394
00:13:53,680 --> 00:14:00,000
a singles thing as as a struct uh but

395
00:13:56,720 --> 00:14:00,959
if we change that to integers then

396
00:14:00,000 --> 00:14:04,079
because of the again

397
00:14:00,959 --> 00:14:05,439
of the api of this specific platform you

398
00:14:04,079 --> 00:14:07,120
don't even have structs

399
00:14:05,440 --> 00:14:08,800
so there are just like two numbers and

400
00:14:07,120 --> 00:14:13,440
that's it they are then

401
00:14:08,800 --> 00:14:15,760
kind of decoded by the machine

402
00:14:13,440 --> 00:14:17,600
another part surprising one was the

403
00:14:15,760 --> 00:14:20,800
constants and it's actually

404
00:14:17,600 --> 00:14:23,680
uh by far the biggest problem so if uh

405
00:14:20,800 --> 00:14:24,319
here in the in the function main we

406
00:14:23,680 --> 00:14:26,479
define

407
00:14:24,320 --> 00:14:28,160
locally a constant that holds a number

408
00:14:26,480 --> 00:14:31,360
of pointers to some

409
00:14:28,160 --> 00:14:32,639
some functions at a lvm level it will be

410
00:14:31,360 --> 00:14:35,120
a global variable

411
00:14:32,639 --> 00:14:36,800
and uh global variables are not very

412
00:14:35,120 --> 00:14:37,360
nice when it comes to the data flow

413
00:14:36,800 --> 00:14:40,079
tracking

414
00:14:37,360 --> 00:14:41,760
and code analysis because you can do

415
00:14:40,079 --> 00:14:43,599
like intra procedural

416
00:14:41,760 --> 00:14:44,880
analysis and it's kind of small because

417
00:14:43,600 --> 00:14:46,720
you have just one function

418
00:14:44,880 --> 00:14:48,639
but if you need to also analyze the

419
00:14:46,720 --> 00:14:51,600
global variables then you have to

420
00:14:48,639 --> 00:14:52,480
find okay who may write to this who may

421
00:14:51,600 --> 00:14:54,959
read from this

422
00:14:52,480 --> 00:14:55,680
are there any aliases and so on it just

423
00:14:54,959 --> 00:14:58,719
the

424
00:14:55,680 --> 00:15:00,638
search space explodes and that gives us

425
00:14:58,720 --> 00:15:02,160
like really hard times to to get it

426
00:15:00,639 --> 00:15:05,040
right uh

427
00:15:02,160 --> 00:15:06,079
yeah just as a workaround so far uh

428
00:15:05,040 --> 00:15:08,000
they're just

429
00:15:06,079 --> 00:15:09,279
we're kind of wait listing some uh edge

430
00:15:08,000 --> 00:15:12,720
cases like this

431
00:15:09,279 --> 00:15:13,279
and uh making them basically putting

432
00:15:12,720 --> 00:15:15,839
them back

433
00:15:13,279 --> 00:15:16,639
like locally in the in the function but

434
00:15:15,839 --> 00:15:21,199
it's it's not

435
00:15:16,639 --> 00:15:21,199
a universal solution unfortunately

436
00:15:23,120 --> 00:15:26,959
yeah this is the uh the other parts like

437
00:15:25,920 --> 00:15:29,120
the big

438
00:15:26,959 --> 00:15:30,399
so far like the biggest problem uh well

439
00:15:29,120 --> 00:15:31,759
not the biggest but one of the big

440
00:15:30,399 --> 00:15:35,199
problems that i just faced

441
00:15:31,759 --> 00:15:38,639
uh several weeks ago um

442
00:15:35,199 --> 00:15:41,199
in source code you can define a type in

443
00:15:38,639 --> 00:15:42,959
a struct uh in header like struct and

444
00:15:41,199 --> 00:15:45,199
then you include this uh header

445
00:15:42,959 --> 00:15:47,199
into two different compilation units

446
00:15:45,199 --> 00:15:49,599
then you compile them both differently

447
00:15:47,199 --> 00:15:51,040
and at the llvm level you have two bit

448
00:15:49,600 --> 00:15:53,519
code files that

449
00:15:51,040 --> 00:15:54,240
have types like struct point and struct

450
00:15:53,519 --> 00:15:56,639
point

451
00:15:54,240 --> 00:15:58,560
uh in the other module if you load them

452
00:15:56,639 --> 00:16:02,079
in this into the same context

453
00:15:58,560 --> 00:16:03,758
then llvm must uh rename those to avoid

454
00:16:02,079 --> 00:16:04,719
collisions because basically the types

455
00:16:03,759 --> 00:16:07,279
are stored in

456
00:16:04,720 --> 00:16:09,120
just like map basically like key value

457
00:16:07,279 --> 00:16:11,519
storage

458
00:16:09,120 --> 00:16:13,199
and apparently uh there is no good

459
00:16:11,519 --> 00:16:14,560
solution for that uh so we want to

460
00:16:13,199 --> 00:16:17,599
duplicate these types

461
00:16:14,560 --> 00:16:20,000
but there is no way to do it

462
00:16:17,600 --> 00:16:22,639
at least uh currently in the using llvm

463
00:16:20,000 --> 00:16:24,720
built-in things

464
00:16:22,639 --> 00:16:27,199
so this is one of the examples why it

465
00:16:24,720 --> 00:16:29,920
doesn't work uh because in lvm

466
00:16:27,199 --> 00:16:30,959
uh types are considered equal if they

467
00:16:29,920 --> 00:16:33,360
point to the same

468
00:16:30,959 --> 00:16:34,560
uh object basically so all the types

469
00:16:33,360 --> 00:16:37,600
they are allocated on

470
00:16:34,560 --> 00:16:38,719
on the hip and uh if you have two

471
00:16:37,600 --> 00:16:40,639
different contacts

472
00:16:38,720 --> 00:16:42,240
and you ask two different like two

473
00:16:40,639 --> 00:16:44,480
floors they are i mean

474
00:16:42,240 --> 00:16:45,519
they are the same type right but llvm

475
00:16:44,480 --> 00:16:49,360
considers them to be

476
00:16:45,519 --> 00:16:50,079
different so uh the first attempt to

477
00:16:49,360 --> 00:16:51,920
solve this problem

478
00:16:50,079 --> 00:16:54,000
was to use the function called ease

479
00:16:51,920 --> 00:16:56,639
layout identical you can just run it on

480
00:16:54,000 --> 00:16:59,759
on a struct and it says yes or no

481
00:16:56,639 --> 00:17:01,120
but uh it doesn't work so

482
00:16:59,759 --> 00:17:02,880
the strikes on the left they have

483
00:17:01,120 --> 00:17:05,039
identical layout and

484
00:17:02,880 --> 00:17:07,199
uh yeah it's all correct but on the

485
00:17:05,039 --> 00:17:09,280
right llvm does not consider them to be

486
00:17:07,199 --> 00:17:11,199
identical because this function just

487
00:17:09,280 --> 00:17:12,879
checks that all the members they they

488
00:17:11,199 --> 00:17:16,880
have the same type

489
00:17:12,880 --> 00:17:19,280
but in fact so in my opinion it's like

490
00:17:16,880 --> 00:17:21,439
it's under implemented uh in the base

491
00:17:19,280 --> 00:17:22,799
case

492
00:17:21,439 --> 00:17:24,880
that should not be like that or it

493
00:17:22,799 --> 00:17:27,439
should be renamed like is

494
00:17:24,880 --> 00:17:28,480
members identical that would be more

495
00:17:27,439 --> 00:17:32,080
valid thing

496
00:17:28,480 --> 00:17:34,160
so we discovered that uh much longer

497
00:17:32,080 --> 00:17:36,480
in the implementation and had to have to

498
00:17:34,160 --> 00:17:39,280
find some other solution

499
00:17:36,480 --> 00:17:40,320
and the solution that we used uh that

500
00:17:39,280 --> 00:17:43,280
also didn't work well

501
00:17:40,320 --> 00:17:46,159
the ir linker or also there is a command

502
00:17:43,280 --> 00:17:49,200
line tool called llvm link

503
00:17:46,160 --> 00:17:51,440
so basically it just tries to combine

504
00:17:49,200 --> 00:17:52,559
two modules and to eliminate as much

505
00:17:51,440 --> 00:17:54,160
types as possible

506
00:17:52,559 --> 00:17:56,080
so in this case it works perfectly

507
00:17:54,160 --> 00:17:58,160
because there is just one type point

508
00:17:56,080 --> 00:18:00,480
left and we can use it

509
00:17:58,160 --> 00:18:01,360
but in in this case if you have two

510
00:18:00,480 --> 00:18:03,360
different uh

511
00:18:01,360 --> 00:18:05,760
like two different types from the user

512
00:18:03,360 --> 00:18:07,840
point of view like points and tuple

513
00:18:05,760 --> 00:18:09,120
but they have the same layout uh one of

514
00:18:07,840 --> 00:18:10,959
them will be eliminated

515
00:18:09,120 --> 00:18:12,840
and so basically we're losing even more

516
00:18:10,960 --> 00:18:16,559
information

517
00:18:12,840 --> 00:18:18,799
so yeah don't don't

518
00:18:16,559 --> 00:18:20,639
i would suggest don't you don't use ir

519
00:18:18,799 --> 00:18:22,559
linker if you want to

520
00:18:20,640 --> 00:18:25,200
uh preserve the type information or be

521
00:18:22,559 --> 00:18:27,200
careful because uh what it also does it

522
00:18:25,200 --> 00:18:30,799
makes you screw the types in a way that

523
00:18:27,200 --> 00:18:33,520
uh there may appear a type that

524
00:18:30,799 --> 00:18:34,400
just was never like never existed in the

525
00:18:33,520 --> 00:18:36,639
in the high level

526
00:18:34,400 --> 00:18:37,760
uh thing of course you should not rely

527
00:18:36,640 --> 00:18:40,400
on this information

528
00:18:37,760 --> 00:18:43,760
and so on but still uh we want to rely

529
00:18:40,400 --> 00:18:46,960
on this

530
00:18:43,760 --> 00:18:50,000
so our attempt to solve the type type

531
00:18:46,960 --> 00:18:53,039
the duplication problem was inspired by

532
00:18:50,000 --> 00:18:56,240
three automata and ranked alphabets

533
00:18:53,039 --> 00:18:59,440
so basically a ranked alphabet

534
00:18:56,240 --> 00:19:01,440
is just a set of symbols and each symbol

535
00:18:59,440 --> 00:19:02,960
has a number of parameters you can think

536
00:19:01,440 --> 00:19:04,559
of it as like functions

537
00:19:02,960 --> 00:19:06,880
and you can combine those functions to

538
00:19:04,559 --> 00:19:07,918
form a trees and this is where the tree

539
00:19:06,880 --> 00:19:10,720
automata comes in

540
00:19:07,919 --> 00:19:12,720
and each tree can be represented as uh

541
00:19:10,720 --> 00:19:16,000
as a string like single string

542
00:19:12,720 --> 00:19:16,640
so then our task to just encode the

543
00:19:16,000 --> 00:19:20,400
types

544
00:19:16,640 --> 00:19:21,440
uh into such trees convert them into the

545
00:19:20,400 --> 00:19:24,400
strings

546
00:19:21,440 --> 00:19:27,600
and yeah then then basically we uh we

547
00:19:24,400 --> 00:19:27,600
compared the the thing

548
00:19:30,240 --> 00:19:36,080
so the next part i wanted to show you

549
00:19:34,160 --> 00:19:38,480
i tried to put it on the slide but it

550
00:19:36,080 --> 00:19:40,960
just like doesn't fit i will

551
00:19:38,480 --> 00:19:41,840
try to explain it a little bit so it

552
00:19:40,960 --> 00:19:44,880
comes yeah

553
00:19:41,840 --> 00:19:46,559
it's about objective c

554
00:19:44,880 --> 00:19:48,720
so that was that was actually very easy

555
00:19:46,559 --> 00:19:50,480
to like the easiest part was to recover

556
00:19:48,720 --> 00:19:53,840
the information from objective c because

557
00:19:50,480 --> 00:19:53,840
it's all there in the bit code

558
00:19:54,000 --> 00:19:57,919
but there are some quirks like yeah i

559
00:19:56,320 --> 00:20:01,200
should have should have found

560
00:19:57,919 --> 00:20:03,919
a nice picture for that but

561
00:20:01,200 --> 00:20:03,919
i didn't

562
00:20:04,480 --> 00:20:08,960
yeah so i'll i'll try to to explain

563
00:20:07,039 --> 00:20:11,760
using this example

564
00:20:08,960 --> 00:20:12,880
so in objective c each each class has a

565
00:20:11,760 --> 00:20:15,840
super class and

566
00:20:12,880 --> 00:20:16,400
a meta class this is the by definition

567
00:20:15,840 --> 00:20:20,000
and

568
00:20:16,400 --> 00:20:23,120
uh a meta class

569
00:20:20,000 --> 00:20:25,600
of a class is the meta class itself

570
00:20:23,120 --> 00:20:26,639
and the parent class of a meta class uh

571
00:20:25,600 --> 00:20:28,719
might be either

572
00:20:26,640 --> 00:20:29,919
some other meta class or might be the

573
00:20:28,720 --> 00:20:32,400
class

574
00:20:29,919 --> 00:20:33,280
the that defines this object like in the

575
00:20:32,400 --> 00:20:36,320
first place so

576
00:20:33,280 --> 00:20:36,320
it's it's very mixed

577
00:20:38,640 --> 00:20:44,159
yeah just to mention that part

578
00:20:45,010 --> 00:20:49,440
[Music]

579
00:20:46,840 --> 00:20:51,360
um

580
00:20:49,440 --> 00:20:52,559
yeah i think it was it went faster than

581
00:20:51,360 --> 00:20:56,240
than i expected i

582
00:20:52,559 --> 00:20:58,639
uh probably miss missed some something

583
00:20:56,240 --> 00:20:59,600
yeah i'll just uh say what i missed to

584
00:20:58,640 --> 00:21:02,400
say before

585
00:20:59,600 --> 00:21:03,199
um so one of the big big problems in

586
00:21:02,400 --> 00:21:06,480
this case or

587
00:21:03,200 --> 00:21:06,880
uh of of big issues uh because the cpg

588
00:21:06,480 --> 00:21:09,360
thing

589
00:21:06,880 --> 00:21:11,200
it has kind of two users two one is

590
00:21:09,360 --> 00:21:12,959
explicit user a human being that is

591
00:21:11,200 --> 00:21:15,280
sitting and running those queries

592
00:21:12,960 --> 00:21:16,159
and the other user is the data flow

593
00:21:15,280 --> 00:21:18,639
tracker

594
00:21:16,159 --> 00:21:19,200
and this is where we we just don't have

595
00:21:18,640 --> 00:21:20,880
the right

596
00:21:19,200 --> 00:21:22,320
uh i mean there is no right answer like

597
00:21:20,880 --> 00:21:25,360
what to do because

598
00:21:22,320 --> 00:21:27,200
in all vm if you run optimized if you

599
00:21:25,360 --> 00:21:28,399
optimize the bit code and you load it

600
00:21:27,200 --> 00:21:31,760
into the cpg

601
00:21:28,400 --> 00:21:33,520
then you get much smaller thing and uh

602
00:21:31,760 --> 00:21:35,039
data flow tracker is much more happy

603
00:21:33,520 --> 00:21:36,960
about that but

604
00:21:35,039 --> 00:21:38,559
as a user you basically again you lose

605
00:21:36,960 --> 00:21:39,200
the information and you cannot work with

606
00:21:38,559 --> 00:21:42,799
this

607
00:21:39,200 --> 00:21:44,880
with this so this is uh

608
00:21:42,799 --> 00:21:47,039
yeah one of the kind of dilemmas that

609
00:21:44,880 --> 00:21:50,400
that we have

610
00:21:47,039 --> 00:21:52,559
so our next steps uh for

611
00:21:50,400 --> 00:21:53,760
for this project are basically to to

612
00:21:52,559 --> 00:21:56,240
make it stable and

613
00:21:53,760 --> 00:21:57,120
uh to add more languages like more

614
00:21:56,240 --> 00:21:58,799
features from

615
00:21:57,120 --> 00:22:01,199
from some other languages i don't know

616
00:21:58,799 --> 00:22:04,480
like rus swift fortron

617
00:22:01,200 --> 00:22:07,440
uh we the other part that

618
00:22:04,480 --> 00:22:07,919
we are kind of started started working

619
00:22:07,440 --> 00:22:10,640
on but

620
00:22:07,919 --> 00:22:12,000
uh not not there yet is we want to hook

621
00:22:10,640 --> 00:22:15,200
back into the clank into

622
00:22:12,000 --> 00:22:18,640
the ast and just basically

623
00:22:15,200 --> 00:22:20,159
extend the the bit code like the cpg

624
00:22:18,640 --> 00:22:21,120
representation that we have on the base

625
00:22:20,159 --> 00:22:22,720
on the bit code

626
00:22:21,120 --> 00:22:24,559
so that we don't really rely on the

627
00:22:22,720 --> 00:22:26,960
debug information because it's not

628
00:22:24,559 --> 00:22:28,639
uh it's not as nice it doesn't always

629
00:22:26,960 --> 00:22:29,520
work especially if you have different

630
00:22:28,640 --> 00:22:32,720
versions of

631
00:22:29,520 --> 00:22:36,320
llvm and different versions of compilers

632
00:22:32,720 --> 00:22:38,559
and so on yeah and the other part that

633
00:22:36,320 --> 00:22:40,000
we want to analyze more projects and to

634
00:22:38,559 --> 00:22:42,158
to get some results because

635
00:22:40,000 --> 00:22:43,120
so the original work on the core

636
00:22:42,159 --> 00:22:46,240
property graphs

637
00:22:43,120 --> 00:22:47,039
uh the fabian actually the clique who

638
00:22:46,240 --> 00:22:49,440
couldn't join

639
00:22:47,039 --> 00:22:50,960
uh they analyzed the linux kernel and

640
00:22:49,440 --> 00:22:51,679
they found some vulnerabilities that

641
00:22:50,960 --> 00:22:54,400
were not

642
00:22:51,679 --> 00:22:54,880
known before that so we want to kind of

643
00:22:54,400 --> 00:22:59,280
try

644
00:22:54,880 --> 00:22:59,280
try to do it with some other projects

645
00:22:59,360 --> 00:23:03,520
so um yeah some some resources if you're

646
00:23:02,720 --> 00:23:06,400
interested i

647
00:23:03,520 --> 00:23:08,240
do recommend you to check out yarn it's

648
00:23:06,400 --> 00:23:10,400
free open source and such there is also

649
00:23:08,240 --> 00:23:14,000
ocular it's commercial product

650
00:23:10,400 --> 00:23:17,520
um but yeah maybe uh you're interested

651
00:23:14,000 --> 00:23:21,039
uh in it at your company so

652
00:23:17,520 --> 00:23:22,559
i did not talk um oh yeah type equality

653
00:23:21,039 --> 00:23:25,520
so i i wrote down this

654
00:23:22,559 --> 00:23:27,520
the thing um i think i would be happy to

655
00:23:25,520 --> 00:23:29,440
actually contribute it back to llvm but

656
00:23:27,520 --> 00:23:32,320
i i still have feeling that it's a bit

657
00:23:29,440 --> 00:23:33,919
uh too complicated and over engineered

658
00:23:32,320 --> 00:23:36,240
so i'm kind of trying to get some

659
00:23:33,919 --> 00:23:38,080
feedback from llvm folks and it's not

660
00:23:36,240 --> 00:23:40,000
really successful so far

661
00:23:38,080 --> 00:23:41,918
so if yeah if you have some comments

662
00:23:40,000 --> 00:23:44,720
please be my guest

663
00:23:41,919 --> 00:23:45,600
yeah the last point uh it's the link to

664
00:23:44,720 --> 00:23:48,159
to the other talk

665
00:23:45,600 --> 00:23:49,039
that uh is more general like how you

666
00:23:48,159 --> 00:23:52,240
build tools

667
00:23:49,039 --> 00:23:53,919
based on lvm it's uh yeah given at url

668
00:23:52,240 --> 00:23:55,120
vm it's based on my experience building

669
00:23:53,919 --> 00:23:57,440
such tools

670
00:23:55,120 --> 00:23:59,120
so i decided not to cover the same parts

671
00:23:57,440 --> 00:24:00,400
in this talk and just refer the other

672
00:23:59,120 --> 00:24:05,199
one so that

673
00:24:00,400 --> 00:24:07,440
i don't repeat myself

674
00:24:05,200 --> 00:24:09,679
yeah so i think you will get longer

675
00:24:07,440 --> 00:24:10,240
break after this talk so if you have any

676
00:24:09,679 --> 00:24:19,840
questions

677
00:24:10,240 --> 00:24:19,840
uh yeah i would be happy to answer them

678
00:24:24,880 --> 00:24:28,159
do you have any figures of the

679
00:24:26,559 --> 00:24:31,918
performance to generate

680
00:24:28,159 --> 00:24:31,919
cpg for i don't know

681
00:24:44,400 --> 00:24:48,320
so the question is uh how much time does

682
00:24:46,480 --> 00:24:50,799
it take to generate cpg for some some

683
00:24:48,320 --> 00:24:50,799
projects

684
00:24:51,279 --> 00:24:55,919
so yeah uh generally depends on the

685
00:24:53,440 --> 00:24:56,320
front end but for llvm to cpg i can say

686
00:24:55,919 --> 00:24:59,200
that

687
00:24:56,320 --> 00:25:00,080
for uh i tried it on blender which is

688
00:24:59,200 --> 00:25:02,799
quite big but

689
00:25:00,080 --> 00:25:03,199
it wasn't full project and it was taking

690
00:25:02,799 --> 00:25:04,960
on

691
00:25:03,200 --> 00:25:06,880
i think on this machine like roughly 15

692
00:25:04,960 --> 00:25:10,159
minutes and we also did it

693
00:25:06,880 --> 00:25:10,880
on the uh mac os kernel and that was

694
00:25:10,159 --> 00:25:13,520
also like

695
00:25:10,880 --> 00:25:14,960
about 15 minutes uh just just to get

696
00:25:13,520 --> 00:25:18,000
this thing

697
00:25:14,960 --> 00:25:22,240
so yeah it's it's reasonably fast

698
00:25:18,000 --> 00:25:22,240
i would say all right thank you

699
00:25:22,400 --> 00:25:28,320
so i assume you

700
00:25:25,440 --> 00:25:29,279
there know the amalek is something that

701
00:25:28,320 --> 00:25:31,600
allocates memory

702
00:25:29,279 --> 00:25:32,320
um you essentially know what all of the

703
00:25:31,600 --> 00:25:35,360
system

704
00:25:32,320 --> 00:25:38,240
libraries do and could you

705
00:25:35,360 --> 00:25:40,080
take a project and basically query does

706
00:25:38,240 --> 00:25:42,000
this use any networking

707
00:25:40,080 --> 00:25:43,199
so to verify that some random project

708
00:25:42,000 --> 00:25:46,320
you're going um

709
00:25:43,200 --> 00:25:47,360
pulling down uh internet is not sending

710
00:25:46,320 --> 00:25:49,760
anything

711
00:25:47,360 --> 00:25:50,639
yeah yeah so uh as an example uh yeah

712
00:25:49,760 --> 00:25:54,720
the question is

713
00:25:50,640 --> 00:25:56,799
uh is there some some way to

714
00:25:54,720 --> 00:25:58,080
find some some patterns right in the

715
00:25:56,799 --> 00:26:00,720
code can i

716
00:25:58,080 --> 00:26:02,399
see it yeah like this so or find like

717
00:26:00,720 --> 00:26:04,080
specifically the idea of putting

718
00:26:02,400 --> 00:26:05,200
something that you don't know about and

719
00:26:04,080 --> 00:26:07,120
saying does this

720
00:26:05,200 --> 00:26:08,640
yeah what what does it do like yeah to

721
00:26:07,120 --> 00:26:09,120
mining some properties of this program

722
00:26:08,640 --> 00:26:11,360
like

723
00:26:09,120 --> 00:26:13,120
yeah does it send network requests does

724
00:26:11,360 --> 00:26:16,080
it allocate memory and so on

725
00:26:13,120 --> 00:26:17,760
yeah so i think it boils down to two

726
00:26:16,080 --> 00:26:20,080
things so

727
00:26:17,760 --> 00:26:21,679
i'll get back to this yeah this thing

728
00:26:20,080 --> 00:26:23,678
first so this is the

729
00:26:21,679 --> 00:26:24,880
command line interface it's like very

730
00:26:23,679 --> 00:26:27,279
similar to sqlite

731
00:26:24,880 --> 00:26:28,240
and it's basically the scala so first of

732
00:26:27,279 --> 00:26:30,559
all one can write

733
00:26:28,240 --> 00:26:33,039
scripts in scala interfacing with the

734
00:26:30,559 --> 00:26:36,000
cpg with the database and uh

735
00:26:33,039 --> 00:26:38,559
having those queries for example uh if

736
00:26:36,000 --> 00:26:40,080
if you have some domain specific so

737
00:26:38,559 --> 00:26:41,918
this is what our security team does

738
00:26:40,080 --> 00:26:43,039
actually uh there are projects like

739
00:26:41,919 --> 00:26:45,760
kernels and

740
00:26:43,039 --> 00:26:47,039
some drivers they don't necessarily have

741
00:26:45,760 --> 00:26:49,679
i mean they use malloc

742
00:26:47,039 --> 00:26:51,279
sometimes but uh sometimes they have

743
00:26:49,679 --> 00:26:53,440
some wrappers around those medics

744
00:26:51,279 --> 00:26:54,480
so they kind of annotate the functions

745
00:26:53,440 --> 00:26:56,480
of interests

746
00:26:54,480 --> 00:26:57,520
manually and then they run some queries

747
00:26:56,480 --> 00:27:00,080
okay show me those

748
00:26:57,520 --> 00:27:02,000
those functions and the that's that's

749
00:27:00,080 --> 00:27:03,360
one part so it's uh it's technically

750
00:27:02,000 --> 00:27:06,799
possible so there is no

751
00:27:03,360 --> 00:27:08,240
uh i mean if you ask me now to

752
00:27:06,799 --> 00:27:09,520
to check if there are network requests

753
00:27:08,240 --> 00:27:11,039
there is no such thing but it's

754
00:27:09,520 --> 00:27:13,760
technically possible to build

755
00:27:11,039 --> 00:27:15,440
and this is where this the overlays come

756
00:27:13,760 --> 00:27:17,120
in

757
00:27:15,440 --> 00:27:19,600
yeah as i said they're domain specific

758
00:27:17,120 --> 00:27:22,239
so we have in fact a number of

759
00:27:19,600 --> 00:27:23,199
overlays for gold language uh for web

760
00:27:22,240 --> 00:27:25,279
applications

761
00:27:23,200 --> 00:27:27,200
specifically like show like find all the

762
00:27:25,279 --> 00:27:29,440
roots uh all the api

763
00:27:27,200 --> 00:27:30,399
endpoints in this application so just as

764
00:27:29,440 --> 00:27:33,679
an example

765
00:27:30,399 --> 00:27:34,799
so if i have a program that i'm going to

766
00:27:33,679 --> 00:27:38,080
say emacs

767
00:27:34,799 --> 00:27:40,960
yeah i could annotate functions that say

768
00:27:38,080 --> 00:27:42,960
this can put something in a buffer and

769
00:27:40,960 --> 00:27:43,840
then this one is affected by x global

770
00:27:42,960 --> 00:27:46,320
variable

771
00:27:43,840 --> 00:27:46,879
and go can we can find me the functions

772
00:27:46,320 --> 00:27:50,000
that

773
00:27:46,880 --> 00:27:52,000
can this global variable eventually put

774
00:27:50,000 --> 00:27:54,720
something in a buffer

775
00:27:52,000 --> 00:27:56,480
yes yeah so generally you can do it it

776
00:27:54,720 --> 00:27:57,200
depends on the scale and size but yeah

777
00:27:56,480 --> 00:28:00,559
generally

778
00:27:57,200 --> 00:28:01,200
so uh i i've yeah this shown this

779
00:28:00,559 --> 00:28:03,200
example

780
00:28:01,200 --> 00:28:04,799
from the demo so this is basically what

781
00:28:03,200 --> 00:28:05,360
happens here so it's very like

782
00:28:04,799 --> 00:28:08,158
simplified

783
00:28:05,360 --> 00:28:09,439
like the most simple example uh so our

784
00:28:08,159 --> 00:28:11,039
security guys uh

785
00:28:09,440 --> 00:28:12,880
they are they are doing some like really

786
00:28:11,039 --> 00:28:14,080
crazy stuff with it and i just not able

787
00:28:12,880 --> 00:28:15,760
to reuse it

788
00:28:14,080 --> 00:28:17,918
but this is this is basically what you

789
00:28:15,760 --> 00:28:19,440
do you define one part you define the

790
00:28:17,919 --> 00:28:20,880
other part and then you find like some

791
00:28:19,440 --> 00:28:24,080
some connections

792
00:28:20,880 --> 00:28:27,760
yeah does it make sense yeah okay

793
00:28:24,080 --> 00:28:27,760
thank you um please

794
00:28:28,960 --> 00:28:32,000
the first is how do you um things like a

795
00:28:30,480 --> 00:28:35,279
bariatric template parameter

796
00:28:32,000 --> 00:28:37,360
by expansion packs so that's the beauty

797
00:28:35,279 --> 00:28:40,000
of llvm because we don't really have to

798
00:28:37,360 --> 00:28:41,360
uh take care about that because uh yeah

799
00:28:40,000 --> 00:28:44,320
the the question is how do we handle

800
00:28:41,360 --> 00:28:46,240
variatic templates and such in

801
00:28:44,320 --> 00:28:47,678
in our case so because we work on the

802
00:28:46,240 --> 00:28:50,240
llvm bit code level

803
00:28:47,679 --> 00:28:50,880
uh this information kind of encoded into

804
00:28:50,240 --> 00:28:53,600
the

805
00:28:50,880 --> 00:28:54,240
signature uh into the name of the

806
00:28:53,600 --> 00:28:57,520
function

807
00:28:54,240 --> 00:28:59,840
or method so what like in this case

808
00:28:57,520 --> 00:29:01,120
currently what we do only just de-mangle

809
00:28:59,840 --> 00:29:03,279
this name

810
00:29:01,120 --> 00:29:04,639
so that users can see something

811
00:29:03,279 --> 00:29:07,840
reasonable

812
00:29:04,640 --> 00:29:09,200
but i mean it's like

813
00:29:07,840 --> 00:29:11,120
we have all this information in the

814
00:29:09,200 --> 00:29:12,159
string already so we can parse it we can

815
00:29:11,120 --> 00:29:15,439
rebuild the whole

816
00:29:12,159 --> 00:29:17,679
uh template thing but it's just yeah no

817
00:29:15,440 --> 00:29:19,600
one asked for that

818
00:29:17,679 --> 00:29:20,880
i work on cpg that has this issue where

819
00:29:19,600 --> 00:29:23,678
we want to retrieve more complex

820
00:29:20,880 --> 00:29:23,679
information about that

821
00:29:24,240 --> 00:29:28,080
the other question i had is um how do

822
00:29:26,399 --> 00:29:30,080
you deal with things like a constitution

823
00:29:28,080 --> 00:29:31,840
in the lvm type system so like i might

824
00:29:30,080 --> 00:29:34,480
want to ask whether or not a variable

825
00:29:31,840 --> 00:29:35,360
um uh has uh you know constant at

826
00:29:34,480 --> 00:29:37,760
compile time

827
00:29:35,360 --> 00:29:41,840
that might be possibly violated by some

828
00:29:37,760 --> 00:29:41,840
uh memory access at one time

829
00:29:44,559 --> 00:29:49,240
so yeah the question is how do we handle

830
00:29:46,320 --> 00:29:51,520
the constant types in

831
00:29:49,240 --> 00:29:55,200
um

832
00:29:51,520 --> 00:29:56,879
yeah um

833
00:29:55,200 --> 00:29:58,799
yeah so far i think we don't have any

834
00:29:56,880 --> 00:30:00,880
any special treating for that

835
00:29:58,799 --> 00:30:02,480
uh if it's i mean it's it's the global

836
00:30:00,880 --> 00:30:04,720
variable right normally

837
00:30:02,480 --> 00:30:06,640
and uh there is no great support like by

838
00:30:04,720 --> 00:30:09,440
the specific of the cpg

839
00:30:06,640 --> 00:30:09,760
because of the space uh space explosion

840
00:30:09,440 --> 00:30:11,200
so

841
00:30:09,760 --> 00:30:13,440
i mean it can be implemented we just

842
00:30:11,200 --> 00:30:17,200
didn't get there but uh so far

843
00:30:13,440 --> 00:30:19,039
for uh yeah i think in most of the cases

844
00:30:17,200 --> 00:30:21,200
uh when we are interested in the global

845
00:30:19,039 --> 00:30:23,200
variables uh these are either function

846
00:30:21,200 --> 00:30:26,399
pointers because it helps for the

847
00:30:23,200 --> 00:30:28,080
data flow resolutions and or the

848
00:30:26,399 --> 00:30:29,918
constant like string constants for

849
00:30:28,080 --> 00:30:33,600
example so that a user can see that okay

850
00:30:29,919 --> 00:30:33,600
these are the strings are used and so on

851
00:30:35,679 --> 00:30:38,720
yeah so um if i understood correctly

852
00:30:38,080 --> 00:30:40,879
this is

853
00:30:38,720 --> 00:30:42,080
a data structure helping with static

854
00:30:40,880 --> 00:30:43,679
analysis

855
00:30:42,080 --> 00:30:45,279
is it possible to compare that with

856
00:30:43,679 --> 00:30:46,080
something like the client static

857
00:30:45,279 --> 00:30:48,880
analyzer

858
00:30:46,080 --> 00:30:51,520
or is it just so completely different

859
00:30:48,880 --> 00:30:53,679
that it's incomparable

860
00:30:51,520 --> 00:30:54,960
so you can compare that i think to a

861
00:30:53,679 --> 00:30:58,640
certain extent

862
00:30:54,960 --> 00:31:00,559
so this tool is more uh in its uh

863
00:30:58,640 --> 00:31:01,760
like in a nutshell it's it's more like

864
00:31:00,559 --> 00:31:05,360
user-driven

865
00:31:01,760 --> 00:31:06,158
so uh and i think the the audience of

866
00:31:05,360 --> 00:31:08,158
this tool is

867
00:31:06,159 --> 00:31:09,919
uh security teams like red teams blue

868
00:31:08,159 --> 00:31:12,480
teams who analyze the code

869
00:31:09,919 --> 00:31:14,240
uh and we don't really have such checks

870
00:31:12,480 --> 00:31:16,240
uh the same checks that clank

871
00:31:14,240 --> 00:31:18,159
analyzer has because i mean because

872
00:31:16,240 --> 00:31:19,679
there is link analyzer and it's just you

873
00:31:18,159 --> 00:31:20,720
can already use it so there are other

874
00:31:19,679 --> 00:31:23,760
tools

875
00:31:20,720 --> 00:31:26,240
yeah but we can do it um sorry

876
00:31:23,760 --> 00:31:29,120
that was a question so on this question

877
00:31:26,240 --> 00:31:32,880
of struct types being equal or not

878
00:31:29,120 --> 00:31:34,399
um i'm kind of wondering because

879
00:31:32,880 --> 00:31:35,840
in the end if you have two struct types

880
00:31:34,399 --> 00:31:37,279
that have the same shape you can

881
00:31:35,840 --> 00:31:38,799
basically always replace one

882
00:31:37,279 --> 00:31:40,399
for another so do you know or does

883
00:31:38,799 --> 00:31:42,399
anybody else in the room know

884
00:31:40,399 --> 00:31:44,479
why lvm works like this why doesn't it

885
00:31:42,399 --> 00:31:46,320
automatically deduplicate structure is

886
00:31:44,480 --> 00:31:47,679
that a conscious decision design

887
00:31:46,320 --> 00:31:49,918
decision at some point

888
00:31:47,679 --> 00:31:50,880
or has it just it's just a maximum of

889
00:31:49,919 --> 00:31:53,360
history

890
00:31:50,880 --> 00:31:54,480
yeah so the question is more open to the

891
00:31:53,360 --> 00:31:59,360
community so why

892
00:31:54,480 --> 00:32:02,320
does llvm not deduplicate the types

893
00:31:59,360 --> 00:32:03,439
by default so i i don't have an answer i

894
00:32:02,320 --> 00:32:07,120
mean

895
00:32:03,440 --> 00:32:09,440
i don't know i don't know sorry yeah

896
00:32:07,120 --> 00:32:10,719
maybe it's an answer for the question

897
00:32:09,440 --> 00:32:12,960
which was right

898
00:32:10,720 --> 00:32:14,799
maybe because in some cases uh when your

899
00:32:12,960 --> 00:32:17,039
structure is super complicated

900
00:32:14,799 --> 00:32:18,559
uh it's indecisive or it's super

901
00:32:17,039 --> 00:32:19,840
complicated to have an algorithm which

902
00:32:18,559 --> 00:32:22,720
can decide

903
00:32:19,840 --> 00:32:23,199
whether two structures are equal from a

904
00:32:22,720 --> 00:32:25,279
layout

905
00:32:23,200 --> 00:32:27,360
point of view you you've designed a

906
00:32:25,279 --> 00:32:30,320
solution which relied on

907
00:32:27,360 --> 00:32:31,918
some graph and layouts to recursively

908
00:32:30,320 --> 00:32:34,480
check if

909
00:32:31,919 --> 00:32:36,000
two streaks are the same but there may

910
00:32:34,480 --> 00:32:38,559
be edge cases

911
00:32:36,000 --> 00:32:39,760
when you use some unions some gcc

912
00:32:38,559 --> 00:32:42,000
extensions or

913
00:32:39,760 --> 00:32:43,519
chrome extensions where this thing is

914
00:32:42,000 --> 00:32:44,559
not going to work because we're relying

915
00:32:43,519 --> 00:32:49,000
on obscure

916
00:32:44,559 --> 00:32:50,799
oscar uh pictures which are not

917
00:32:49,000 --> 00:32:54,240
disadvantaged

918
00:32:50,799 --> 00:32:58,720
yeah okay the question is uh

919
00:32:54,240 --> 00:33:00,480
yeah it's not yeah but um

920
00:32:58,720 --> 00:33:02,640
i mean i still can can comment on that

921
00:33:00,480 --> 00:33:04,480
there is another approach to that uh so

922
00:33:02,640 --> 00:33:07,760
first of all in our case we don't really

923
00:33:04,480 --> 00:33:09,679
use the layout equality to decide but we

924
00:33:07,760 --> 00:33:13,679
kind of use the structural quality

925
00:33:09,679 --> 00:33:13,679
so that if a struct uh so they

926
00:33:13,840 --> 00:33:16,879
so destruct if you draw the structs as a

927
00:33:16,240 --> 00:33:19,679
graph

928
00:33:16,880 --> 00:33:21,919
or as a tree they must have equal shape

929
00:33:19,679 --> 00:33:24,960
so this is our definition of equality

930
00:33:21,919 --> 00:33:28,000
and there is another uh approach i think

931
00:33:24,960 --> 00:33:31,120
it's called like based on hubcraft's uh

932
00:33:28,000 --> 00:33:32,559
dfa minimization algorithm i think

933
00:33:31,120 --> 00:33:35,039
at least my colleague told that this is

934
00:33:32,559 --> 00:33:36,799
what ir linker does or it looked to him

935
00:33:35,039 --> 00:33:39,519
that this is what ir linker does

936
00:33:36,799 --> 00:33:40,080
and there is also some other uh i think

937
00:33:39,519 --> 00:33:42,960
scheme

938
00:33:40,080 --> 00:33:43,760
project that they do this they use this

939
00:33:42,960 --> 00:33:47,600
algorithm

940
00:33:43,760 --> 00:33:51,519
but it it uses different uh quality

941
00:33:47,600 --> 00:33:53,439
thing so we it doesn't i mean it doesn't

942
00:33:51,519 --> 00:33:57,120
fit our definition of equality so this

943
00:33:53,440 --> 00:34:00,320
is this is why we do it uh the other way

944
00:33:57,120 --> 00:34:03,439
so there are two questions um yeah um

945
00:34:00,320 --> 00:34:07,840
i wonder this type of application

946
00:34:03,440 --> 00:34:07,840
thing uh

947
00:34:12,399 --> 00:34:17,359
yeah so it doesn't treat pointers as the

948
00:34:14,639 --> 00:34:18,560
same so that's the point and to to avoid

949
00:34:17,359 --> 00:34:21,119
uh recursion

950
00:34:18,560 --> 00:34:22,239
so basically uh when we build this tree

951
00:34:21,119 --> 00:34:25,440
we rename

952
00:34:22,239 --> 00:34:26,319
uh we don't take names into account we

953
00:34:25,440 --> 00:34:29,280
just rename

954
00:34:26,320 --> 00:34:30,240
uh all the structs we just give some

955
00:34:29,280 --> 00:34:33,280
them some id

956
00:34:30,239 --> 00:34:35,118
like numerical id so basically if you if

957
00:34:33,280 --> 00:34:36,480
you see the struct that you already seen

958
00:34:35,119 --> 00:34:38,560
like recursive case

959
00:34:36,480 --> 00:34:39,520
you just emit okay this is the same uh

960
00:34:38,560 --> 00:34:41,918
struct

961
00:34:39,520 --> 00:34:43,359
and we don't emit anything further so it

962
00:34:41,918 --> 00:34:44,799
kind of

963
00:34:43,359 --> 00:34:46,480
so it's a graph and we convert this

964
00:34:44,800 --> 00:34:48,879
graph to a tree so there is no recursion

965
00:34:46,480 --> 00:34:51,679
in this case

966
00:34:48,879 --> 00:34:53,359
yeah that was i think that sorry i think

967
00:34:51,679 --> 00:34:56,240
that answers my question

968
00:34:53,359 --> 00:34:58,000
because in currently pointers and ldm

969
00:34:56,239 --> 00:34:59,680
still have a pointy time

970
00:34:58,000 --> 00:35:01,520
even though conceptually the idea is to

971
00:34:59,680 --> 00:35:03,520
get away from that once pointers are

972
00:35:01,520 --> 00:35:05,040
opaque that problem just disappears it

973
00:35:03,520 --> 00:35:06,800
becomes trivial because you no longer

974
00:35:05,040 --> 00:35:08,640
have forward references

975
00:35:06,800 --> 00:35:10,640
right and then you could deduplicate by

976
00:35:08,640 --> 00:35:12,078
default because but because historically

977
00:35:10,640 --> 00:35:13,680
pointers have pointy types it's a

978
00:35:12,079 --> 00:35:17,280
problem

979
00:35:13,680 --> 00:35:19,040
yeah that's yeah there is uh just uh

980
00:35:17,280 --> 00:35:20,480
just another comment there is a writer

981
00:35:19,040 --> 00:35:23,680
by chris latner there was

982
00:35:20,480 --> 00:35:26,800
the about type system uh

983
00:35:23,680 --> 00:35:28,160
change around llvm3 and there are some

984
00:35:26,800 --> 00:35:30,480
some good points on why

985
00:35:28,160 --> 00:35:32,160
this the type system the way it is

986
00:35:30,480 --> 00:35:34,800
currently

987
00:35:32,160 --> 00:35:36,240
yeah there were some questions here and

988
00:35:34,800 --> 00:35:39,119
one there i think

989
00:35:36,240 --> 00:35:40,799
yeah please the question is when you get

990
00:35:39,119 --> 00:35:44,560
a bytecode it's already

991
00:35:40,800 --> 00:35:46,480
optimized how you get back to search but

992
00:35:44,560 --> 00:35:48,000
yeah so the question is uh when we get

993
00:35:46,480 --> 00:35:49,760
the bytecode it's optimized and how we

994
00:35:48,000 --> 00:35:52,079
get back to the source code so

995
00:35:49,760 --> 00:35:53,280
it's not necessarily optimized it's up

996
00:35:52,079 --> 00:35:56,079
to the users

997
00:35:53,280 --> 00:35:57,200
uh how to how to meet this bytecode it

998
00:35:56,079 --> 00:36:00,000
can be like

999
00:35:57,200 --> 00:36:01,839
totally unoptimized and to get back to

1000
00:36:00,000 --> 00:36:03,920
the source code we can only buy

1001
00:36:01,839 --> 00:36:05,200
uh the mean of debug information because

1002
00:36:03,920 --> 00:36:06,160
all the instructions with the debug

1003
00:36:05,200 --> 00:36:08,960
information they have

1004
00:36:06,160 --> 00:36:09,359
a notion like where they came from and

1005
00:36:08,960 --> 00:36:11,680
uh

1006
00:36:09,359 --> 00:36:13,279
yeah we can basically reconstruct some

1007
00:36:11,680 --> 00:36:15,040
interesting parts we can just look back

1008
00:36:13,280 --> 00:36:18,560
at the source code and the ast and

1009
00:36:15,040 --> 00:36:20,880
and see what's what's in there

1010
00:36:18,560 --> 00:36:21,599
one more question yeah the like last

1011
00:36:20,880 --> 00:36:27,839
question

1012
00:36:21,599 --> 00:36:27,839
that was one i think yeah

1013
00:36:44,240 --> 00:36:48,319
yeah it's a very good question um so the

1014
00:36:46,880 --> 00:36:49,760
question is why like basically why don't

1015
00:36:48,320 --> 00:36:52,240
we use the ssa form

1016
00:36:49,760 --> 00:36:52,880
right and kind of invent some something

1017
00:36:52,240 --> 00:36:54,560
else

1018
00:36:52,880 --> 00:36:56,720
so we have some debates in the team

1019
00:36:54,560 --> 00:36:59,040
about this once in a while as well

1020
00:36:56,720 --> 00:37:01,040
but uh so basically historical reasons

1021
00:36:59,040 --> 00:37:04,320
so the tool was first built for

1022
00:37:01,040 --> 00:37:06,240
uh i think with java in mind uh and this

1023
00:37:04,320 --> 00:37:08,079
this is the format

1024
00:37:06,240 --> 00:37:09,279
yeah the way it is and we have a number

1025
00:37:08,079 --> 00:37:11,839
of frontends supporting different

1026
00:37:09,280 --> 00:37:14,720
languages like csharp python go and such

1027
00:37:11,839 --> 00:37:16,400
and uh i think by now only llvm has this

1028
00:37:14,720 --> 00:37:19,040
ssa form in this like

1029
00:37:16,400 --> 00:37:20,560
pure ssa form so if you want to use ssa

1030
00:37:19,040 --> 00:37:21,520
form we would have to change all the

1031
00:37:20,560 --> 00:37:25,119
other languages

1032
00:37:21,520 --> 00:37:25,119
which is quite an effort

1033
00:37:25,440 --> 00:37:37,839
okay thank you very much thank you

1034
00:37:38,640 --> 00:37:40,720
you

