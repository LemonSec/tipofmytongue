1
00:00:05,120 --> 00:00:09,120
all right well hey guys

2
00:00:06,560 --> 00:00:10,080
uh welcome to the testing and automation

3
00:00:09,120 --> 00:00:13,120
uh dev room

4
00:00:10,080 --> 00:00:13,920
today i'm gonna be talking about writing

5
00:00:13,120 --> 00:00:16,320
good tests

6
00:00:13,920 --> 00:00:17,119
writing go tests and writing good goat

7
00:00:16,320 --> 00:00:20,160
tests

8
00:00:17,119 --> 00:00:22,320
probably in that order i tried to my

9
00:00:20,160 --> 00:00:24,800
best to cater this talk to a wide

10
00:00:22,320 --> 00:00:26,800
range of experience with go so if i have

11
00:00:24,800 --> 00:00:28,320
experts listening out there

12
00:00:26,800 --> 00:00:30,000
please just be patient with some of the

13
00:00:28,320 --> 00:00:31,519
introductory material

14
00:00:30,000 --> 00:00:33,840
and i promise we'll work our way up to

15
00:00:31,519 --> 00:00:36,000
some of the more complex cases

16
00:00:33,840 --> 00:00:38,399
and to any novices if you're new to go

17
00:00:36,000 --> 00:00:41,600
don't just don't get discouraged by

18
00:00:38,399 --> 00:00:43,840
any unfamiliar go concepts or packages

19
00:00:41,600 --> 00:00:45,840
much of what i'm going to cover is like

20
00:00:43,840 --> 00:00:47,520
directly from the godox so

21
00:00:45,840 --> 00:00:48,879
if you want to reference those at the

22
00:00:47,520 --> 00:00:51,840
end to revisit anything

23
00:00:48,879 --> 00:00:53,680
you're welcome to do so hopefully

24
00:00:51,840 --> 00:00:55,120
regardless of your experience level

25
00:00:53,680 --> 00:00:56,559
you're all visual learners i'm going to

26
00:00:55,120 --> 00:00:59,440
have a lot of code on the screen and

27
00:00:56,559 --> 00:01:02,078
kind of be like tutorial based

28
00:00:59,440 --> 00:01:02,800
for each concept so hopefully by the

29
00:01:02,079 --> 00:01:04,799
time

30
00:01:02,800 --> 00:01:06,560
we're done here you guys will walk out

31
00:01:04,799 --> 00:01:07,360
with a better understanding of best

32
00:01:06,560 --> 00:01:10,840
practices

33
00:01:07,360 --> 00:01:13,840
in general testing and in goaling

34
00:01:10,840 --> 00:01:13,840
testing

35
00:01:15,040 --> 00:01:18,240
my name is nikki atiyah and i'm a work

36
00:01:17,600 --> 00:01:20,720
from home

37
00:01:18,240 --> 00:01:21,839
dog mom who hacks on distributed systems

38
00:01:20,720 --> 00:01:25,119
and workflows

39
00:01:21,840 --> 00:01:27,439
i'm based in southern california um

40
00:01:25,119 --> 00:01:29,119
and you can find me at my handle listed

41
00:01:27,439 --> 00:01:30,240
on any social media you could just look

42
00:01:29,119 --> 00:01:33,680
for the baby yoda

43
00:01:30,240 --> 00:01:37,679
avatar sipping a soup and that's me um

44
00:01:33,680 --> 00:01:40,320
i why am i talking about go tests um

45
00:01:37,680 --> 00:01:41,119
i have a long history with testing and

46
00:01:40,320 --> 00:01:43,919
go

47
00:01:41,119 --> 00:01:44,320
so i uh at the power and performance

48
00:01:43,920 --> 00:01:46,479
team

49
00:01:44,320 --> 00:01:47,839
at apple i maintained automation

50
00:01:46,479 --> 00:01:49,759
frameworks for ios

51
00:01:47,840 --> 00:01:51,119
and watch os performance testing and we

52
00:01:49,759 --> 00:01:53,680
used ruby and

53
00:01:51,119 --> 00:01:56,000
python for that and currently i'm a

54
00:01:53,680 --> 00:01:58,000
software engineer at sensu which is an

55
00:01:56,000 --> 00:01:59,200
open source and open core monitoring

56
00:01:58,000 --> 00:02:00,960
tool kind of like

57
00:01:59,200 --> 00:02:02,399
nagios on steroids if you're familiar

58
00:02:00,960 --> 00:02:04,079
with either of those

59
00:02:02,399 --> 00:02:06,399
and for about the last three years i've

60
00:02:04,079 --> 00:02:08,799
been contributing to the sensugo

61
00:02:06,399 --> 00:02:10,878
project which judging by the name is a

62
00:02:08,800 --> 00:02:14,000
rewrite in go

63
00:02:10,878 --> 00:02:15,840
senzu inc the company i work for

64
00:02:14,000 --> 00:02:18,400
has supported all of my efforts to come

65
00:02:15,840 --> 00:02:20,080
here from halfway across the world so

66
00:02:18,400 --> 00:02:21,599
a huge thank you to them and their

67
00:02:20,080 --> 00:02:23,200
support of open source

68
00:02:21,599 --> 00:02:24,959
so if you're curious about what we do at

69
00:02:23,200 --> 00:02:27,119
sun tzu at all you can check out our

70
00:02:24,959 --> 00:02:29,760
github right there

71
00:02:27,120 --> 00:02:31,280
all right so let's start by answering

72
00:02:29,760 --> 00:02:32,079
the first question you might have on

73
00:02:31,280 --> 00:02:34,640
your mind

74
00:02:32,080 --> 00:02:36,720
why go believe it or not there's a lot

75
00:02:34,640 --> 00:02:38,480
more to golang than the cute little

76
00:02:36,720 --> 00:02:42,400
gopher mascot such as this belgium

77
00:02:38,480 --> 00:02:43,760
styled gopher by ashley mcnamara

78
00:02:42,400 --> 00:02:45,519
for starters it's an open source

79
00:02:43,760 --> 00:02:48,840
language which is pretty important

80
00:02:45,519 --> 00:02:50,000
designed by google you can find it at

81
00:02:48,840 --> 00:02:52,879
github.com

82
00:02:50,000 --> 00:02:54,480
so it's a comparatively young language

83
00:02:52,879 --> 00:02:57,040
especially compared to the ones that

84
00:02:54,480 --> 00:02:58,799
uh more the popular ones we use today

85
00:02:57,040 --> 00:03:00,799
and it's been almost eight years since

86
00:02:58,800 --> 00:03:03,599
its initial release

87
00:03:00,800 --> 00:03:04,080
to the public so as a result the

88
00:03:03,599 --> 00:03:06,640
original

89
00:03:04,080 --> 00:03:08,480
offer authors were able to address more

90
00:03:06,640 --> 00:03:09,440
current and relevant problems in the

91
00:03:08,480 --> 00:03:11,359
landscape

92
00:03:09,440 --> 00:03:12,640
um like at the time that they were

93
00:03:11,360 --> 00:03:15,200
designing it

94
00:03:12,640 --> 00:03:16,480
so these include runtime efficiency high

95
00:03:15,200 --> 00:03:17,679
performance networking and

96
00:03:16,480 --> 00:03:20,480
multi-processing

97
00:03:17,680 --> 00:03:22,640
so as such many consider it like the hot

98
00:03:20,480 --> 00:03:24,720
new language and distributed programming

99
00:03:22,640 --> 00:03:26,958
uh including those big companies like

100
00:03:24,720 --> 00:03:28,799
uber twitch netflix which all require

101
00:03:26,959 --> 00:03:32,159
like high concurrent performance

102
00:03:28,799 --> 00:03:33,519
so it's a good language uh

103
00:03:32,159 --> 00:03:35,599
now that we have a little go history

104
00:03:33,519 --> 00:03:37,040
let's talk about uh the design of the

105
00:03:35,599 --> 00:03:39,040
language

106
00:03:37,040 --> 00:03:40,480
for the most part it's considered

107
00:03:39,040 --> 00:03:43,200
considered statically

108
00:03:40,480 --> 00:03:44,000
and structurally typed it's type safe

109
00:03:43,200 --> 00:03:46,480
requiring

110
00:03:44,000 --> 00:03:47,680
a strict type for each object and field

111
00:03:46,480 --> 00:03:49,679
memory safe

112
00:03:47,680 --> 00:03:52,239
allocating memory for each object and

113
00:03:49,680 --> 00:03:54,799
field so in these instances the compiled

114
00:03:52,239 --> 00:03:57,280
binary is a lot faster at runtime which

115
00:03:54,799 --> 00:03:59,439
of course is a performance win

116
00:03:57,280 --> 00:04:01,280
but the caveat to this characteristic is

117
00:03:59,439 --> 00:04:03,920
that go also supports some

118
00:04:01,280 --> 00:04:06,080
instances of dynamic typing so if you're

119
00:04:03,920 --> 00:04:07,200
used to like ruby and doing really dirty

120
00:04:06,080 --> 00:04:09,760
like

121
00:04:07,200 --> 00:04:11,439
things in ruby uh go is capable of doing

122
00:04:09,760 --> 00:04:13,359
that um

123
00:04:11,439 --> 00:04:15,439
but it's just more considered on the

124
00:04:13,360 --> 00:04:18,479
statically typed language side

125
00:04:15,439 --> 00:04:21,120
so using techniques such as reflection

126
00:04:18,478 --> 00:04:22,880
you can treat go objects generically at

127
00:04:21,120 --> 00:04:26,320
a little bit of a performance trade-off

128
00:04:22,880 --> 00:04:26,880
so generic functions if you decide to do

129
00:04:26,320 --> 00:04:29,360
that they

130
00:04:26,880 --> 00:04:30,560
encourage code reuse and can compile the

131
00:04:29,360 --> 00:04:32,160
program faster

132
00:04:30,560 --> 00:04:33,840
but might be a little slower at runtime

133
00:04:32,160 --> 00:04:35,520
because of the additional dynamic

134
00:04:33,840 --> 00:04:37,520
processing it's doing

135
00:04:35,520 --> 00:04:39,120
so for the sake of testing we'll focus

136
00:04:37,520 --> 00:04:42,320
more on the statically typed cases

137
00:04:39,120 --> 00:04:44,639
because they're very straightforward

138
00:04:42,320 --> 00:04:46,479
it is a compiled language which with a

139
00:04:44,639 --> 00:04:49,040
very large standard library

140
00:04:46,479 --> 00:04:50,560
it produces tools such as go build go

141
00:04:49,040 --> 00:04:52,240
run and go test

142
00:04:50,560 --> 00:04:54,080
therefore when you download the language

143
00:04:52,240 --> 00:04:55,680
itself it's quite large i think

144
00:04:54,080 --> 00:04:59,120
comparatively to other languages

145
00:04:55,680 --> 00:05:02,560
as well the most recent version of go

146
00:04:59,120 --> 00:05:06,080
is a 116 megabytes on mac os and

147
00:05:02,560 --> 00:05:09,199
linux systems but due to the

148
00:05:06,080 --> 00:05:10,320
enriched standard library that they have

149
00:05:09,199 --> 00:05:12,639
a lot of the functions you're going to

150
00:05:10,320 --> 00:05:16,080
need on a day-to-day basis such as

151
00:05:12,639 --> 00:05:17,440
i o calls os exec encoding networking

152
00:05:16,080 --> 00:05:20,159
syncing and of course

153
00:05:17,440 --> 00:05:21,680
our testing operations are all contained

154
00:05:20,160 --> 00:05:23,680
in these built-in packages

155
00:05:21,680 --> 00:05:25,759
so it limits the need for external

156
00:05:23,680 --> 00:05:28,880
dependencies

157
00:05:25,759 --> 00:05:31,759
so speaking of containment

158
00:05:28,880 --> 00:05:33,440
it's self-contained so you say go build

159
00:05:31,759 --> 00:05:35,759
and it's good to go

160
00:05:33,440 --> 00:05:37,280
so when you run go build it produces a

161
00:05:35,759 --> 00:05:39,360
static binary

162
00:05:37,280 --> 00:05:40,960
against a target operating system and

163
00:05:39,360 --> 00:05:42,800
architecture so

164
00:05:40,960 --> 00:05:44,479
the resulting binary includes any

165
00:05:42,800 --> 00:05:46,479
external dependencies you have with your

166
00:05:44,479 --> 00:05:48,560
dependency management system

167
00:05:46,479 --> 00:05:50,000
and it'll run on systems that don't have

168
00:05:48,560 --> 00:05:52,080
the language installed so

169
00:05:50,000 --> 00:05:54,880
it makes distribution of go projects

170
00:05:52,080 --> 00:05:57,120
super super easy

171
00:05:54,880 --> 00:05:58,319
and finally it's concurrent and

172
00:05:57,120 --> 00:06:00,639
asynchronous

173
00:05:58,319 --> 00:06:02,639
with go routines programs can handle

174
00:06:00,639 --> 00:06:04,720
tasks simultaneously

175
00:06:02,639 --> 00:06:06,400
and with channels and weight groups

176
00:06:04,720 --> 00:06:07,680
programs can execute tasks

177
00:06:06,400 --> 00:06:10,000
asynchronously

178
00:06:07,680 --> 00:06:11,680
so both of these properties improve

179
00:06:10,000 --> 00:06:14,080
performance and responsiveness for your

180
00:06:11,680 --> 00:06:14,080
program

181
00:06:14,639 --> 00:06:18,560
regardless of the pros and cons of these

182
00:06:16,960 --> 00:06:20,159
characteristics as a whole

183
00:06:18,560 --> 00:06:23,440
they all have a different impact or

184
00:06:20,160 --> 00:06:26,160
implication on how you would write tests

185
00:06:23,440 --> 00:06:27,840
so tests like i mentioned in

186
00:06:26,160 --> 00:06:29,840
structurally typed languages

187
00:06:27,840 --> 00:06:31,520
are a lot more straightforward because

188
00:06:29,840 --> 00:06:34,159
your input and output types

189
00:06:31,520 --> 00:06:35,840
are already defined and you would

190
00:06:34,160 --> 00:06:38,960
probably have a compile time error

191
00:06:35,840 --> 00:06:40,880
if that was incorrect therefore testing

192
00:06:38,960 --> 00:06:41,919
fixtures are a really common practice in

193
00:06:40,880 --> 00:06:44,319
go

194
00:06:41,919 --> 00:06:46,719
they can be read in from a json file or

195
00:06:44,319 --> 00:06:48,800
compiled in your go file directly

196
00:06:46,720 --> 00:06:50,880
but essentially they'll provide a quick

197
00:06:48,800 --> 00:06:54,319
reliable and easy way to invoke

198
00:06:50,880 --> 00:06:56,880
test artifacts in your tests

199
00:06:54,319 --> 00:06:58,880
the standard library makes writing tests

200
00:06:56,880 --> 00:07:01,280
really really convenient

201
00:06:58,880 --> 00:07:02,240
the testing package is built in and it's

202
00:07:01,280 --> 00:07:06,400
really huge

203
00:07:02,240 --> 00:07:07,599
it's got functions to make assertions

204
00:07:06,400 --> 00:07:10,159
and they can be made without any

205
00:07:07,599 --> 00:07:12,560
external dependencies

206
00:07:10,160 --> 00:07:14,880
it also has packages for mocks and

207
00:07:12,560 --> 00:07:16,880
things such as like a test http server

208
00:07:14,880 --> 00:07:18,800
which we'll get into a little later

209
00:07:16,880 --> 00:07:21,759
for more of the more involved

210
00:07:18,800 --> 00:07:21,759
integration tests

211
00:07:22,319 --> 00:07:26,000
self-containment how this relates to

212
00:07:24,000 --> 00:07:30,000
testing is it helps keep tests

213
00:07:26,000 --> 00:07:31,680
organized unit and integration tests are

214
00:07:30,000 --> 00:07:33,680
written as go files and they live

215
00:07:31,680 --> 00:07:36,160
directly in your code

216
00:07:33,680 --> 00:07:38,080
these tests of course are not built and

217
00:07:36,160 --> 00:07:38,880
packaged and shipped when you run go

218
00:07:38,080 --> 00:07:40,880
build

219
00:07:38,880 --> 00:07:42,080
but you can easily run the tests in a ci

220
00:07:40,880 --> 00:07:44,400
pipeline

221
00:07:42,080 --> 00:07:45,359
and end tests however uh capture more of

222
00:07:44,400 --> 00:07:48,400
a larger scope

223
00:07:45,360 --> 00:07:50,240
but go build kind of empowers you to do

224
00:07:48,400 --> 00:07:52,000
that a little easier in a ci pipeline so

225
00:07:50,240 --> 00:07:52,879
you could go build and then run and end

226
00:07:52,000 --> 00:07:56,160
tests on

227
00:07:52,879 --> 00:07:56,160
that resulting binary

228
00:07:56,960 --> 00:08:01,039
um the concurrent and asynchronous

229
00:07:59,360 --> 00:08:02,479
features of a go program are

230
00:08:01,039 --> 00:08:04,159
some of the biggest challenges to

231
00:08:02,479 --> 00:08:05,840
testing and go

232
00:08:04,160 --> 00:08:07,520
because they're more prone to race

233
00:08:05,840 --> 00:08:09,280
conditions and blocking calls

234
00:08:07,520 --> 00:08:11,520
therefore running these kinds of tests

235
00:08:09,280 --> 00:08:12,960
with a race detector and a timeout is

236
00:08:11,520 --> 00:08:15,039
typically encouraged

237
00:08:12,960 --> 00:08:16,878
so we'll get into some examples about

238
00:08:15,039 --> 00:08:17,759
how to deal with concurrent complexities

239
00:08:16,879 --> 00:08:19,440
and tests

240
00:08:17,759 --> 00:08:22,160
but for now i hope i've convinced you

241
00:08:19,440 --> 00:08:24,960
the pros outweigh the cons when it comes

242
00:08:22,160 --> 00:08:27,680
to go design and tests

243
00:08:24,960 --> 00:08:28,239
so whether you came in new to the

244
00:08:27,680 --> 00:08:30,319
language

245
00:08:28,240 --> 00:08:32,640
um or not i hope that background was

246
00:08:30,319 --> 00:08:35,279
useful uh because it's gonna

247
00:08:32,640 --> 00:08:36,640
help us understand at greater depth um

248
00:08:35,279 --> 00:08:38,799
you know the background of the language

249
00:08:36,640 --> 00:08:41,360
and help us write better tests

250
00:08:38,799 --> 00:08:42,559
um so regardless of the language we

251
00:08:41,360 --> 00:08:43,919
choose even if

252
00:08:42,559 --> 00:08:46,000
you're not choosing go and you're just

253
00:08:43,919 --> 00:08:48,640
trying to get a good seat for the next

254
00:08:46,000 --> 00:08:50,640
session uh we still need to be able to

255
00:08:48,640 --> 00:08:52,560
recognize what actually makes a test

256
00:08:50,640 --> 00:08:54,560
good and what techniques we can use to

257
00:08:52,560 --> 00:08:56,000
write them simply and concisely

258
00:08:54,560 --> 00:08:58,800
so what are some properties of

259
00:08:56,000 --> 00:09:01,200
well-written tests

260
00:08:58,800 --> 00:09:02,079
similar to a scientific experiment a

261
00:09:01,200 --> 00:09:04,959
good test

262
00:09:02,080 --> 00:09:06,240
will only test one thing at a time so

263
00:09:04,959 --> 00:09:08,959
control variables

264
00:09:06,240 --> 00:09:09,440
are designed to isolate the effects of a

265
00:09:08,959 --> 00:09:11,920
single

266
00:09:09,440 --> 00:09:13,200
independent variable on that it has on

267
00:09:11,920 --> 00:09:14,959
that outcome

268
00:09:13,200 --> 00:09:16,720
and just as there are control variables

269
00:09:14,959 --> 00:09:17,279
in like a scientific experiment like

270
00:09:16,720 --> 00:09:19,360
this

271
00:09:17,279 --> 00:09:21,120
a test should also contain controls for

272
00:09:19,360 --> 00:09:22,480
each iteration so for each thing you're

273
00:09:21,120 --> 00:09:25,519
stressing

274
00:09:22,480 --> 00:09:28,080
you should have some constants around it

275
00:09:25,519 --> 00:09:29,120
even in larger scope tests such as end

276
00:09:28,080 --> 00:09:31,680
and testing

277
00:09:29,120 --> 00:09:32,720
you want to focus on testing just the

278
00:09:31,680 --> 00:09:36,399
happy path or

279
00:09:32,720 --> 00:09:38,000
just a networking failure for example

280
00:09:36,399 --> 00:09:40,000
otherwise you could end up with multiple

281
00:09:38,000 --> 00:09:41,440
points of failure which

282
00:09:40,000 --> 00:09:44,640
makes it really difficult to isolate

283
00:09:41,440 --> 00:09:44,640
which component caused what

284
00:09:45,760 --> 00:09:48,880
while we want to make sure we're only

285
00:09:47,760 --> 00:09:51,040
testing one

286
00:09:48,880 --> 00:09:52,480
single thing at once we also want to

287
00:09:51,040 --> 00:09:55,120
make sure we're testing

288
00:09:52,480 --> 00:09:57,200
many things together and that's not a

289
00:09:55,120 --> 00:09:59,360
contradiction i promise

290
00:09:57,200 --> 00:10:01,600
software components can have many like

291
00:09:59,360 --> 00:10:04,079
entangled interdependencies

292
00:10:01,600 --> 00:10:05,279
so for this reason we should exercise as

293
00:10:04,079 --> 00:10:08,000
many permutations

294
00:10:05,279 --> 00:10:10,720
as possible in our tests so each

295
00:10:08,000 --> 00:10:12,880
permutation of code like in this image

296
00:10:10,720 --> 00:10:13,760
is going to be unique in context and

297
00:10:12,880 --> 00:10:15,920
order

298
00:10:13,760 --> 00:10:17,839
and although the permis permutation

299
00:10:15,920 --> 00:10:20,319
itself is unique it can still yield the

300
00:10:17,839 --> 00:10:22,320
same outcome as other tests

301
00:10:20,320 --> 00:10:23,680
so for example like having the same

302
00:10:22,320 --> 00:10:27,440
number of blues and reds

303
00:10:23,680 --> 00:10:29,519
in each column and just because we have

304
00:10:27,440 --> 00:10:31,519
a redundant outcome doesn't necessarily

305
00:10:29,519 --> 00:10:36,000
mean that the test is bad and we're

306
00:10:31,519 --> 00:10:38,160
being redundant because we're actually

307
00:10:36,000 --> 00:10:39,600
creating multiple success and failure

308
00:10:38,160 --> 00:10:40,800
scenarios

309
00:10:39,600 --> 00:10:43,519
triggered by all of these different

310
00:10:40,800 --> 00:10:45,199
variables working together so

311
00:10:43,519 --> 00:10:47,519
the variety of the code paths that get

312
00:10:45,200 --> 00:10:50,720
touched by these different combinations

313
00:10:47,519 --> 00:10:52,640
are what makes a test really really good

314
00:10:50,720 --> 00:10:54,079
um are you guys familiar with marine

315
00:10:52,640 --> 00:10:57,760
condo in europe

316
00:10:54,079 --> 00:10:59,439
some of us okay so we want to be able to

317
00:10:57,760 --> 00:11:01,760
test a single thing at once and

318
00:10:59,440 --> 00:11:03,519
additionally multiple things together

319
00:11:01,760 --> 00:11:05,600
but how are we supposed to do that

320
00:11:03,519 --> 00:11:07,839
especially in systems that grow

321
00:11:05,600 --> 00:11:09,279
in complexity over time and often like

322
00:11:07,839 --> 00:11:12,079
per commit

323
00:11:09,279 --> 00:11:13,279
simply put we can marie condo our code

324
00:11:12,079 --> 00:11:15,279
she's a netflix

325
00:11:13,279 --> 00:11:17,200
documentary person and she helps people

326
00:11:15,279 --> 00:11:19,920
like organize the garage and stuff

327
00:11:17,200 --> 00:11:21,920
um it doesn't mean we want to erase the

328
00:11:19,920 --> 00:11:24,959
code that like doesn't spark joy

329
00:11:21,920 --> 00:11:28,319
like we still need our code um

330
00:11:24,959 --> 00:11:29,920
but for example if a project resembles a

331
00:11:28,320 --> 00:11:31,680
messy garage that hasn't been

332
00:11:29,920 --> 00:11:34,000
cleaned out in years it's going to be

333
00:11:31,680 --> 00:11:35,839
really difficult to verify the contents

334
00:11:34,000 --> 00:11:37,440
and usability of anything that's in

335
00:11:35,839 --> 00:11:39,279
there so

336
00:11:37,440 --> 00:11:41,200
on the other hand if we murray condo at

337
00:11:39,279 --> 00:11:43,120
our garage we'll probably have

338
00:11:41,200 --> 00:11:44,560
transparent containers they're clearly

339
00:11:43,120 --> 00:11:47,519
labeled organized by

340
00:11:44,560 --> 00:11:48,959
season or activity and they're easily

341
00:11:47,519 --> 00:11:50,480
accessible for when we need it

342
00:11:48,959 --> 00:11:52,239
so the same goes for code in that

343
00:11:50,480 --> 00:11:55,200
metaphor

344
00:11:52,240 --> 00:11:56,320
organization and compartmentalization

345
00:11:55,200 --> 00:11:58,560
will help simplify

346
00:11:56,320 --> 00:11:59,760
our code and therefore our tests so our

347
00:11:58,560 --> 00:12:02,719
unit tests are smaller

348
00:11:59,760 --> 00:12:03,360
they're testing smaller things by

349
00:12:02,720 --> 00:12:06,240
dividing

350
00:12:03,360 --> 00:12:07,920
complex tasks and functions into smaller

351
00:12:06,240 --> 00:12:08,800
and more manageable pieces we can

352
00:12:07,920 --> 00:12:11,120
encourage

353
00:12:08,800 --> 00:12:12,479
some of that same code reusability and

354
00:12:11,120 --> 00:12:15,200
isolate those specific

355
00:12:12,480 --> 00:12:16,480
uh problem points so obviously those

356
00:12:15,200 --> 00:12:19,279
smaller code blocks are

357
00:12:16,480 --> 00:12:19,920
far easier to unit test than large like

358
00:12:19,279 --> 00:12:22,079
run-on

359
00:12:19,920 --> 00:12:22,959
integrated code blocks that just start

360
00:12:22,079 --> 00:12:25,599
getting really like

361
00:12:22,959 --> 00:12:25,599
intertingled

362
00:12:26,399 --> 00:12:29,519
another component to writing good tests

363
00:12:29,120 --> 00:12:32,880
is

364
00:12:29,519 --> 00:12:33,920
writing failing tests this tweet says

365
00:12:32,880 --> 00:12:36,639
you

366
00:12:33,920 --> 00:12:38,000
from another talk i'm not sure where

367
00:12:36,639 --> 00:12:40,399
says you should never trust a test

368
00:12:38,000 --> 00:12:42,079
you haven't seen fail i'm not sure that

369
00:12:40,399 --> 00:12:43,600
joe or gwen here were the first ones to

370
00:12:42,079 --> 00:12:45,199
say that i don't know if they're going

371
00:12:43,600 --> 00:12:47,279
to be the last ones to say that because

372
00:12:45,200 --> 00:12:49,360
i'm saying that now

373
00:12:47,279 --> 00:12:50,959
but we shouldn't just write tests to

374
00:12:49,360 --> 00:12:53,200
pass we should be making

375
00:12:50,959 --> 00:12:55,199
incorrect assumptions on our code so we

376
00:12:53,200 --> 00:12:57,519
can actually observe that failure

377
00:12:55,200 --> 00:12:58,320
so personally my favorite way of doing

378
00:12:57,519 --> 00:13:00,959
this in

379
00:12:58,320 --> 00:13:01,760
practice is with bug fixes so if i've

380
00:13:00,959 --> 00:13:04,239
narrowed down

381
00:13:01,760 --> 00:13:05,279
kind of to where i think the problem is

382
00:13:04,240 --> 00:13:07,360
i'll immediately

383
00:13:05,279 --> 00:13:09,839
write a test for it without even

384
00:13:07,360 --> 00:13:12,399
attempting to like fix the bug

385
00:13:09,839 --> 00:13:14,079
um observe that it fails ultimately

386
00:13:12,399 --> 00:13:17,600
reproducing the

387
00:13:14,079 --> 00:13:22,160
bug that's reported and then

388
00:13:17,600 --> 00:13:23,120
i can basically confirm that the code

389
00:13:22,160 --> 00:13:25,199
was behaving

390
00:13:23,120 --> 00:13:26,240
improperly before and properly once the

391
00:13:25,200 --> 00:13:28,399
fix is shipped

392
00:13:26,240 --> 00:13:30,079
so your code reviewers will thank you

393
00:13:28,399 --> 00:13:32,560
when your test explains exactly what's

394
00:13:30,079 --> 00:13:32,560
going on

395
00:13:33,360 --> 00:13:36,560
so that last slide is really just a

396
00:13:35,040 --> 00:13:38,000
funner and like

397
00:13:36,560 --> 00:13:40,319
longer way to say test driven

398
00:13:38,000 --> 00:13:42,399
development some might argue that

399
00:13:40,320 --> 00:13:43,360
it's just a vicious cycle of endless

400
00:13:42,399 --> 00:13:45,920
handoffs or

401
00:13:43,360 --> 00:13:47,519
maybe riddled with like developer bias

402
00:13:45,920 --> 00:13:50,719
um but in many cases

403
00:13:47,519 --> 00:13:52,480
uh at least in unit case unit tests

404
00:13:50,720 --> 00:13:54,800
it will help you achieve really good

405
00:13:52,480 --> 00:13:57,040
code and really good coverage

406
00:13:54,800 --> 00:13:58,560
so in practice uh writing a test prior

407
00:13:57,040 --> 00:13:59,120
to fixing the bug or implementing a

408
00:13:58,560 --> 00:14:00,319
feature

409
00:13:59,120 --> 00:14:02,240
sounds great especially for those

410
00:14:00,320 --> 00:14:04,320
smaller scope tests

411
00:14:02,240 --> 00:14:06,720
but in reality for real world

412
00:14:04,320 --> 00:14:08,240
applications and larger scope tests

413
00:14:06,720 --> 00:14:10,399
they're not as easily testable through

414
00:14:08,240 --> 00:14:12,240
this method so don't

415
00:14:10,399 --> 00:14:14,399
beat yourself up over it i'd recommend

416
00:14:12,240 --> 00:14:16,959
using a test driven development when

417
00:14:14,399 --> 00:14:19,199
possible but focusing more on shipping

418
00:14:16,959 --> 00:14:22,880
organized and compartmentalized code

419
00:14:19,199 --> 00:14:22,880
which in the end makes it more testable

420
00:14:23,040 --> 00:14:27,279
so that's kind of my overview on writing

421
00:14:24,959 --> 00:14:29,119
good tests and best practices

422
00:14:27,279 --> 00:14:31,199
i write and speak a lot about testing in

423
00:14:29,120 --> 00:14:32,639
general so if you want more of that

424
00:14:31,199 --> 00:14:35,519
be sure to check out the resources at

425
00:14:32,639 --> 00:14:39,040
the end but for now let's shift into go

426
00:14:35,519 --> 00:14:40,880
tests specifically before we start

427
00:14:39,040 --> 00:14:42,800
writing go test we'll kind of discuss

428
00:14:40,880 --> 00:14:44,880
how we would run a go test

429
00:14:42,800 --> 00:14:46,719
i mentioned earlier that goling produces

430
00:14:44,880 --> 00:14:47,360
tools such as go build go run and go

431
00:14:46,720 --> 00:14:49,519
test

432
00:14:47,360 --> 00:14:51,040
and you guessed it go test is meant to

433
00:14:49,519 --> 00:14:53,279
run our tests

434
00:14:51,040 --> 00:14:55,760
so it includes other features such as

435
00:14:53,279 --> 00:14:57,760
benchmarking and parallelization

436
00:14:55,760 --> 00:14:59,600
which we won't get into in this talk but

437
00:14:57,760 --> 00:15:01,199
they're great resources

438
00:14:59,600 --> 00:15:03,440
into gathering and reporting some more

439
00:15:01,199 --> 00:15:05,839
context about your code

440
00:15:03,440 --> 00:15:07,360
so to test you simply run go test from

441
00:15:05,839 --> 00:15:09,120
the directory where your tests are

442
00:15:07,360 --> 00:15:11,600
stored or you can utilize some other

443
00:15:09,120 --> 00:15:15,199
attributes of the tool

444
00:15:11,600 --> 00:15:16,320
so here's a couple use cases for how one

445
00:15:15,199 --> 00:15:18,560
might use the tool

446
00:15:16,320 --> 00:15:20,000
you can run all the tests in the current

447
00:15:18,560 --> 00:15:21,839
working directory

448
00:15:20,000 --> 00:15:23,519
you can run a single test against a

449
00:15:21,839 --> 00:15:26,720
fully qualified package name

450
00:15:23,519 --> 00:15:27,760
which you have like the github path

451
00:15:26,720 --> 00:15:30,720
there

452
00:15:27,760 --> 00:15:32,480
you can tag go files with a simple

453
00:15:30,720 --> 00:15:34,560
comment at the beginning of the file

454
00:15:32,480 --> 00:15:36,079
so if you want to just run integration

455
00:15:34,560 --> 00:15:37,839
tests you could tag

456
00:15:36,079 --> 00:15:39,040
all of your integration files with that

457
00:15:37,839 --> 00:15:41,839
and that's just going to run all of

458
00:15:39,040 --> 00:15:41,839
those

459
00:15:42,000 --> 00:15:47,440
i think i skipped over dash v is just

460
00:15:44,320 --> 00:15:50,720
going to verbosely print any output

461
00:15:47,440 --> 00:15:53,199
any additional output from your go

462
00:15:50,720 --> 00:15:55,680
testing tool

463
00:15:53,199 --> 00:15:56,560
you can enable race detectors with dash

464
00:15:55,680 --> 00:15:58,399
race

465
00:15:56,560 --> 00:16:00,239
and timeouts for tests that might depend

466
00:15:58,399 --> 00:16:02,160
on blocking calls so

467
00:16:00,240 --> 00:16:03,360
if you're calling something with dash

468
00:16:02,160 --> 00:16:06,000
race you're probably going to want to

469
00:16:03,360 --> 00:16:06,000
time out as well

470
00:16:06,320 --> 00:16:11,440
you can also get a snapshot of code

471
00:16:09,519 --> 00:16:13,120
coverage with dash cover

472
00:16:11,440 --> 00:16:14,720
i know code coverage can be a pretty

473
00:16:13,120 --> 00:16:16,720
controversial topic

474
00:16:14,720 --> 00:16:17,759
uh while i believe we should all be

475
00:16:16,720 --> 00:16:20,320
shooting for

476
00:16:17,759 --> 00:16:21,040
100 code cover at least on unit tests

477
00:16:20,320 --> 00:16:23,920
it's

478
00:16:21,040 --> 00:16:24,560
really not feasible in some instances

479
00:16:23,920 --> 00:16:26,880
and

480
00:16:24,560 --> 00:16:28,560
writing high quality code in meaningful

481
00:16:26,880 --> 00:16:30,079
tests is a lot more important than just

482
00:16:28,560 --> 00:16:32,239
checking that box and saying like okay

483
00:16:30,079 --> 00:16:36,560
100 code gov we're good

484
00:16:32,240 --> 00:16:39,440
um and lastly some editors such as

485
00:16:36,560 --> 00:16:41,279
a vs code which is what i use can even

486
00:16:39,440 --> 00:16:43,120
highlight the covered and uncovered

487
00:16:41,279 --> 00:16:44,480
lines of code if you run the tool

488
00:16:43,120 --> 00:16:47,360
through the editor

489
00:16:44,480 --> 00:16:48,880
um so it's kind of really helpful to

490
00:16:47,360 --> 00:16:49,519
identify if your test is actually

491
00:16:48,880 --> 00:16:51,839
hitting those

492
00:16:49,519 --> 00:16:51,839
lines

493
00:16:52,959 --> 00:16:57,199
some basic syntax and project details

494
00:16:55,920 --> 00:16:59,360
that you'll need to know about writing

495
00:16:57,199 --> 00:17:03,279
go test before we get started

496
00:16:59,360 --> 00:17:05,360
the first is the file naming convention

497
00:17:03,279 --> 00:17:06,640
all shippable go code should be in a

498
00:17:05,359 --> 00:17:09,119
file ending in

499
00:17:06,640 --> 00:17:10,079
go just like that well all non-shipped

500
00:17:09,119 --> 00:17:12,399
test code

501
00:17:10,079 --> 00:17:14,399
should have the postfix underscore

502
00:17:12,400 --> 00:17:17,520
test.go so it's still a go file

503
00:17:14,400 --> 00:17:19,439
it just has that test

504
00:17:17,520 --> 00:17:20,639
when writing fixtures for your ghost

505
00:17:19,439 --> 00:17:21,120
trucks that are going to be using your

506
00:17:20,640 --> 00:17:22,959
tests

507
00:17:21,119 --> 00:17:24,239
i would actually recommend to organize

508
00:17:22,959 --> 00:17:27,600
those fixtures in

509
00:17:24,240 --> 00:17:29,200
the go file not the test file um

510
00:17:27,599 --> 00:17:31,120
in the same package where that struct

511
00:17:29,200 --> 00:17:33,120
was defined because this is going to

512
00:17:31,120 --> 00:17:34,239
help limit circular dependencies that

513
00:17:33,120 --> 00:17:37,039
could arise

514
00:17:34,240 --> 00:17:38,160
when importing those fixtures in tests

515
00:17:37,039 --> 00:17:41,679
across

516
00:17:38,160 --> 00:17:45,039
packages secondly

517
00:17:41,679 --> 00:17:46,720
the test naming convention a go test is

518
00:17:45,039 --> 00:17:49,280
written as a regular go function

519
00:17:46,720 --> 00:17:50,160
like this with the caveat that it always

520
00:17:49,280 --> 00:17:53,600
follows the same

521
00:17:50,160 --> 00:17:56,320
function signature so it's prefixed with

522
00:17:53,600 --> 00:17:58,480
the word test with a capital t and it

523
00:17:56,320 --> 00:18:01,439
accepts a single testing.t

524
00:17:58,480 --> 00:18:04,080
parameter which is like the core testing

525
00:18:01,440 --> 00:18:07,120
package and go

526
00:18:04,080 --> 00:18:09,918
the first letter it should follow

527
00:18:07,120 --> 00:18:12,479
just like regular camel case and that's

528
00:18:09,919 --> 00:18:15,840
kind of goes

529
00:18:12,480 --> 00:18:16,240
styling preference so the function name

530
00:18:15,840 --> 00:18:18,399
will

531
00:18:16,240 --> 00:18:19,919
identify that test routine like that

532
00:18:18,400 --> 00:18:23,600
test xxx

533
00:18:19,919 --> 00:18:25,840
and uh it should be capitalized

534
00:18:23,600 --> 00:18:27,360
so with all of the prerequisites we

535
00:18:25,840 --> 00:18:30,000
discussed in mind

536
00:18:27,360 --> 00:18:31,918
let's move on to writing tests and go

537
00:18:30,000 --> 00:18:33,840
we'll start out with very basic cuts

538
00:18:31,919 --> 00:18:35,840
and work our way up to more complex use

539
00:18:33,840 --> 00:18:36,799
cases with like race conditions and all

540
00:18:35,840 --> 00:18:40,639
of that

541
00:18:36,799 --> 00:18:43,679
um so patience is a virtue

542
00:18:40,640 --> 00:18:45,280
for the sake of consensus consistency

543
00:18:43,679 --> 00:18:46,799
um i'm gonna try and use the same

544
00:18:45,280 --> 00:18:49,760
example throughout

545
00:18:46,799 --> 00:18:50,639
so this gopher is getting pretty lit on

546
00:18:49,760 --> 00:18:52,480
beer

547
00:18:50,640 --> 00:18:55,039
beer seems to be pretty popular here in

548
00:18:52,480 --> 00:18:56,160
belgium and i love beer so we'll go with

549
00:18:55,039 --> 00:18:58,559
that

550
00:18:56,160 --> 00:18:59,280
our business model for our program can

551
00:18:58,559 --> 00:19:01,200
be an

552
00:18:59,280 --> 00:19:03,600
online beer store and subscription

553
00:19:01,200 --> 00:19:03,600
service

554
00:19:04,240 --> 00:19:10,080
for some context i created a few structs

555
00:19:08,080 --> 00:19:11,840
to represent each object in our business

556
00:19:10,080 --> 00:19:14,080
model so a cart

557
00:19:11,840 --> 00:19:15,199
is a shopping cart that contains a list

558
00:19:14,080 --> 00:19:19,199
of cases

559
00:19:15,200 --> 00:19:21,120
a case is a pack of beer that

560
00:19:19,200 --> 00:19:22,880
can be a specific amount such as a six

561
00:19:21,120 --> 00:19:25,600
pack or a thirty rack

562
00:19:22,880 --> 00:19:26,559
and then a beer represents details about

563
00:19:25,600 --> 00:19:29,120
the specific

564
00:19:26,559 --> 00:19:31,440
beer such as its brand its name its size

565
00:19:29,120 --> 00:19:35,039
and fluid ounces

566
00:19:31,440 --> 00:19:37,039
so on and so forth so i've also written

567
00:19:35,039 --> 00:19:38,879
some preliminary fixture functions i've

568
00:19:37,039 --> 00:19:40,640
only pictured one here there's some

569
00:19:38,880 --> 00:19:42,080
other ones in the code but they're a

570
00:19:40,640 --> 00:19:45,679
little

571
00:19:42,080 --> 00:19:46,879
intuitive once you see them in the tests

572
00:19:45,679 --> 00:19:49,360
and this is just going to allow us to

573
00:19:46,880 --> 00:19:50,640
rapidly initialize this struct so i

574
00:19:49,360 --> 00:19:52,559
don't need to take up

575
00:19:50,640 --> 00:19:53,919
six or seven lines of code creating this

576
00:19:52,559 --> 00:19:57,039
every time i wanna

577
00:19:53,919 --> 00:19:58,880
create one of these objects

578
00:19:57,039 --> 00:20:01,039
lastly the function we're gonna test

579
00:19:58,880 --> 00:20:01,760
first is really simple it's called add

580
00:20:01,039 --> 00:20:03,919
case

581
00:20:01,760 --> 00:20:06,400
and it simply appends a single case of

582
00:20:03,919 --> 00:20:09,280
beer onto the list of cases

583
00:20:06,400 --> 00:20:09,280
in the shopping cart

584
00:20:09,520 --> 00:20:13,039
so our first test is pretty simple we

585
00:20:12,320 --> 00:20:14,960
initialize

586
00:20:13,039 --> 00:20:16,158
a new empty cart again that function

587
00:20:14,960 --> 00:20:19,440
wasn't pictured

588
00:20:16,159 --> 00:20:21,120
but it just initializes a cart object

589
00:20:19,440 --> 00:20:22,799
before we do anything else we're going

590
00:20:21,120 --> 00:20:25,199
to make sure the

591
00:20:22,799 --> 00:20:26,158
length is equal to zero with an if

592
00:20:25,200 --> 00:20:29,760
statement

593
00:20:26,159 --> 00:20:31,360
and call t.fatal in the event that it

594
00:20:29,760 --> 00:20:33,520
fails so it'll print

595
00:20:31,360 --> 00:20:35,520
expected empty cart if for whatever

596
00:20:33,520 --> 00:20:38,559
reason there was beer populated in our

597
00:20:35,520 --> 00:20:38,559
cart to begin with what's up

598
00:20:46,840 --> 00:20:54,240
yes typically yes only used for the test

599
00:20:50,000 --> 00:20:57,919
um but if you if you want to use that

600
00:20:54,240 --> 00:20:58,320
fixture um in other packages like when

601
00:20:57,919 --> 00:21:00,159
you're

602
00:20:58,320 --> 00:21:01,520
say i'm testing in another package and i

603
00:21:00,159 --> 00:21:04,960
want to use that fixture

604
00:21:01,520 --> 00:21:06,720
i can't export that in the test

605
00:21:04,960 --> 00:21:08,400
and the test code itself it'll only look

606
00:21:06,720 --> 00:21:09,200
for the code in the go test or the go

607
00:21:08,400 --> 00:21:12,880
file i'm sorry

608
00:21:09,200 --> 00:21:16,240
does that make sense um

609
00:21:12,880 --> 00:21:20,400
okay so custom error

610
00:21:16,240 --> 00:21:23,679
uh we'll create fixtures here

611
00:21:20,400 --> 00:21:25,280
um so we can add those fixtures into our

612
00:21:23,679 --> 00:21:27,360
add case function

613
00:21:25,280 --> 00:21:29,678
the bat blue light is my favorite beer

614
00:21:27,360 --> 00:21:32,320
it's a canadian pilsner

615
00:21:29,679 --> 00:21:32,720
typically found in 12-ounce cans so

616
00:21:32,320 --> 00:21:36,399
we'll

617
00:21:32,720 --> 00:21:38,880
fill that up in the case and

618
00:21:36,400 --> 00:21:40,159
if it works properly our tests pass the

619
00:21:38,880 --> 00:21:42,559
second assertion as well

620
00:21:40,159 --> 00:21:44,000
because we're making that if statement

621
00:21:42,559 --> 00:21:47,200
on the length of

622
00:21:44,000 --> 00:21:49,440
the cart so as i just

623
00:21:47,200 --> 00:21:51,760
demonstrated in that last slide using

624
00:21:49,440 --> 00:21:54,000
the go testing package alone

625
00:21:51,760 --> 00:21:55,440
we can explicitly mark tests as passed

626
00:21:54,000 --> 00:21:58,640
or failed depending on the

627
00:21:55,440 --> 00:21:59,280
if conditions this makes code more human

628
00:21:58,640 --> 00:22:01,520
readable

629
00:21:59,280 --> 00:22:03,360
but it can kind of create all of these

630
00:22:01,520 --> 00:22:04,879
like dangling conditionals that make it

631
00:22:03,360 --> 00:22:06,158
a little bit more tiresome

632
00:22:04,880 --> 00:22:08,559
and we're going to be writing a lot of

633
00:22:06,159 --> 00:22:13,200
tests today so i want to introduce you

634
00:22:08,559 --> 00:22:15,360
to testify's assert and require packages

635
00:22:13,200 --> 00:22:17,200
testify is a lightweight external

636
00:22:15,360 --> 00:22:18,479
dependency that acts as a testing

637
00:22:17,200 --> 00:22:21,600
toolkit around

638
00:22:18,480 --> 00:22:24,880
the go standard library testing package

639
00:22:21,600 --> 00:22:26,959
so it wraps the testing object t

640
00:22:24,880 --> 00:22:28,400
that's your top level parameter in all

641
00:22:26,960 --> 00:22:31,200
of your tests

642
00:22:28,400 --> 00:22:33,039
and it extends common assertions such as

643
00:22:31,200 --> 00:22:35,919
equal not equal

644
00:22:33,039 --> 00:22:38,480
error no error nil not nil and many

645
00:22:35,919 --> 00:22:41,120
other conditions

646
00:22:38,480 --> 00:22:42,400
every function takes that object t as

647
00:22:41,120 --> 00:22:44,719
the first argument

648
00:22:42,400 --> 00:22:48,080
and as a result it can write those same

649
00:22:44,720 --> 00:22:48,080
errors out to the go tool

650
00:22:49,120 --> 00:22:53,840
the assert and require functions also

651
00:22:51,840 --> 00:22:55,439
return booleans indicating if the

652
00:22:53,840 --> 00:22:57,199
assertion was successful or not

653
00:22:55,440 --> 00:22:59,280
so if you want to build off of each

654
00:22:57,200 --> 00:23:01,200
assertions and only make

655
00:22:59,280 --> 00:23:02,320
assertions based on like what you just

656
00:23:01,200 --> 00:23:03,600
previously asserted

657
00:23:02,320 --> 00:23:05,840
you could do that we're not going to do

658
00:23:03,600 --> 00:23:07,280
an example of that here

659
00:23:05,840 --> 00:23:09,439
we're just going to ignore and swallow

660
00:23:07,280 --> 00:23:11,520
the returned booleans but for future

661
00:23:09,440 --> 00:23:14,640
reference if you have special code paths

662
00:23:11,520 --> 00:23:15,280
i would recommend that so the same test

663
00:23:14,640 --> 00:23:16,960
we just did

664
00:23:15,280 --> 00:23:19,280
can be written in a few less lines of

665
00:23:16,960 --> 00:23:20,159
code simply by invoking testify's assert

666
00:23:19,280 --> 00:23:21,760
package

667
00:23:20,159 --> 00:23:23,440
so rather than making that if statement

668
00:23:21,760 --> 00:23:26,720
we can just assert equal

669
00:23:23,440 --> 00:23:29,520
the length of the cart and have

670
00:23:26,720 --> 00:23:30,000
uh this empty or expected md cart

671
00:23:29,520 --> 00:23:34,000
message

672
00:23:30,000 --> 00:23:36,720
so a cert can take uh

673
00:23:34,000 --> 00:23:37,679
three to four parameters the first being

674
00:23:36,720 --> 00:23:40,159
t

675
00:23:37,679 --> 00:23:42,400
the second parameter being the exp uh

676
00:23:40,159 --> 00:23:44,159
expected value the third parameter being

677
00:23:42,400 --> 00:23:45,760
the

678
00:23:44,159 --> 00:23:47,360
actual value and then the fourth

679
00:23:45,760 --> 00:23:49,679
parameter being

680
00:23:47,360 --> 00:23:51,760
an optional like custom error message so

681
00:23:49,679 --> 00:23:55,679
that's what it'll print to the go

682
00:23:51,760 --> 00:23:55,679
test tool in the event of an error

683
00:23:57,840 --> 00:24:01,600
the require package is almost identical

684
00:24:01,279 --> 00:24:04,720
to

685
00:24:01,600 --> 00:24:06,480
the assertion or the assert package

686
00:24:04,720 --> 00:24:08,880
the only difference being that if you

687
00:24:06,480 --> 00:24:11,679
call require dot

688
00:24:08,880 --> 00:24:13,360
equal and that fails it's similar to

689
00:24:11,679 --> 00:24:16,400
running

690
00:24:13,360 --> 00:24:16,879
t.fail now which will short circuit the

691
00:24:16,400 --> 00:24:19,039
test

692
00:24:16,880 --> 00:24:20,240
in the event that it fails and it won't

693
00:24:19,039 --> 00:24:21,919
continue on

694
00:24:20,240 --> 00:24:23,919
so i'd recommend you kind of use your

695
00:24:21,919 --> 00:24:25,360
best discretion when deciding between an

696
00:24:23,919 --> 00:24:26,240
assert condition versus required

697
00:24:25,360 --> 00:24:28,320
condition

698
00:24:26,240 --> 00:24:29,520
but for any like non-catastrophic

699
00:24:28,320 --> 00:24:31,678
failure scenarios

700
00:24:29,520 --> 00:24:33,120
it's probably easier to use assert so

701
00:24:31,679 --> 00:24:35,600
any failed test cases

702
00:24:33,120 --> 00:24:36,559
in some algorithm or some mathematical

703
00:24:35,600 --> 00:24:39,439
equation that you're

704
00:24:36,559 --> 00:24:41,678
computing will still be surfaced despite

705
00:24:39,440 --> 00:24:43,360
any failures prior

706
00:24:41,679 --> 00:24:44,960
so we talked about test driven

707
00:24:43,360 --> 00:24:46,320
development a little earlier

708
00:24:44,960 --> 00:24:48,240
now that we've gotten our feet a little

709
00:24:46,320 --> 00:24:50,480
bit wet with some go examples

710
00:24:48,240 --> 00:24:52,000
we're going to see it in practice so

711
00:24:50,480 --> 00:24:54,080
let's say i want to write a function

712
00:24:52,000 --> 00:24:55,919
called subtotal that calculates the

713
00:24:54,080 --> 00:24:57,039
subtotal of the contents in my shopping

714
00:24:55,919 --> 00:24:58,799
cart

715
00:24:57,039 --> 00:25:00,320
instead of jumping directly to the dot

716
00:24:58,799 --> 00:25:01,520
go file i'm going to start with the

717
00:25:00,320 --> 00:25:02,879
test.go file

718
00:25:01,520 --> 00:25:05,760
writing a case that i know is going to

719
00:25:02,880 --> 00:25:07,520
fail writing it before my code is going

720
00:25:05,760 --> 00:25:08,158
to encourage me to adhere to the

721
00:25:07,520 --> 00:25:10,400
original

722
00:25:08,159 --> 00:25:13,200
expectations i have for the function and

723
00:25:10,400 --> 00:25:16,720
probably the original

724
00:25:13,200 --> 00:25:19,919
function signature as well so

725
00:25:16,720 --> 00:25:22,400
test subtotal similar to the add case

726
00:25:19,919 --> 00:25:23,360
test i can fix root beers and cases and

727
00:25:22,400 --> 00:25:26,080
add them to

728
00:25:23,360 --> 00:25:27,678
my shopping cart google tells me duvel

729
00:25:26,080 --> 00:25:29,360
triple hop is a very popular

730
00:25:27,679 --> 00:25:31,200
belgian beer and although it's quite

731
00:25:29,360 --> 00:25:33,039
expensive for a pack of four

732
00:25:31,200 --> 00:25:34,240
i'll be worldly and try it out and throw

733
00:25:33,039 --> 00:25:36,640
it in our cart

734
00:25:34,240 --> 00:25:38,559
so we also might be playing some

735
00:25:36,640 --> 00:25:38,960
drinking games later we need a 30 rack

736
00:25:38,559 --> 00:25:42,240
of

737
00:25:38,960 --> 00:25:45,520
lebat blue for 24.99

738
00:25:42,240 --> 00:25:48,080
so i'm expecting the subtotal

739
00:25:45,520 --> 00:25:49,360
function here which we haven't yet

740
00:25:48,080 --> 00:25:51,840
written

741
00:25:49,360 --> 00:25:53,199
to accept zero parameters so empty

742
00:25:51,840 --> 00:25:56,799
parentheses

743
00:25:53,200 --> 00:25:58,960
and return a single value which is a

744
00:25:56,799 --> 00:26:00,799
float

745
00:25:58,960 --> 00:26:03,240
if this function works as i would expect

746
00:26:00,799 --> 00:26:05,840
it to the calculated value should be

747
00:26:03,240 --> 00:26:07,760
39.98 but let's round up to 40 for the

748
00:26:05,840 --> 00:26:08,480
sake of this test so we can first assert

749
00:26:07,760 --> 00:26:12,000
the failure

750
00:26:08,480 --> 00:26:13,840
and then fix it later on so

751
00:26:12,000 --> 00:26:15,760
our test assumed the function signature

752
00:26:13,840 --> 00:26:17,520
was shown here so this is how it should

753
00:26:15,760 --> 00:26:20,158
be defined

754
00:26:17,520 --> 00:26:21,520
so it should plug and play perfectly

755
00:26:20,159 --> 00:26:24,159
we're going to do some really intense

756
00:26:21,520 --> 00:26:26,320
math here to calculate the subtotal

757
00:26:24,159 --> 00:26:27,760
we'll iterate through each case uh in

758
00:26:26,320 --> 00:26:29,439
the cart adding the price

759
00:26:27,760 --> 00:26:30,879
to the subtotal and then return that

760
00:26:29,440 --> 00:26:34,559
value so

761
00:26:30,880 --> 00:26:36,080
it fails with an expected

762
00:26:34,559 --> 00:26:38,720
value of 40 and passes with the

763
00:26:36,080 --> 00:26:42,080
corrected value of 39.98

764
00:26:38,720 --> 00:26:44,240
so while tdd kind of gets us to

765
00:26:42,080 --> 00:26:46,158
decent coverage in the small helper

766
00:26:44,240 --> 00:26:47,279
function

767
00:26:46,159 --> 00:26:49,360
i'd like to believe we're a little bit

768
00:26:47,279 --> 00:26:51,760
more thorough than that and we want to

769
00:26:49,360 --> 00:26:54,000
test more than one instance of the

770
00:26:51,760 --> 00:26:57,440
calculation

771
00:26:54,000 --> 00:26:59,120
so uh although it may have passed

772
00:26:57,440 --> 00:27:00,640
uh like what happens if our card is

773
00:26:59,120 --> 00:27:02,080
empty what happens if there's a negative

774
00:27:00,640 --> 00:27:04,320
value for some reason

775
00:27:02,080 --> 00:27:06,000
more than two cases duplicate cases in

776
00:27:04,320 --> 00:27:08,240
our cart

777
00:27:06,000 --> 00:27:09,440
and then lastly how can we capture all

778
00:27:08,240 --> 00:27:12,559
of these edge cases

779
00:27:09,440 --> 00:27:16,000
while simultaneously optimizing our code

780
00:27:12,559 --> 00:27:18,320
reusability so for this purpose

781
00:27:16,000 --> 00:27:20,240
a common practice for unit tests and go

782
00:27:18,320 --> 00:27:22,399
are called test tables

783
00:27:20,240 --> 00:27:23,840
so you can create a test table which is

784
00:27:22,399 --> 00:27:27,760
basically a slice

785
00:27:23,840 --> 00:27:29,760
array of input and output variables

786
00:27:27,760 --> 00:27:30,879
defined directly within the test so this

787
00:27:29,760 --> 00:27:33,760
struct doesn't have to

788
00:27:30,880 --> 00:27:35,120
exist anywhere else it's just right here

789
00:27:33,760 --> 00:27:38,480
we can take the name

790
00:27:35,120 --> 00:27:41,279
of our test it'll accept a

791
00:27:38,480 --> 00:27:42,720
cart as an input value and the output

792
00:27:41,279 --> 00:27:46,159
value for the test case is going to be

793
00:27:42,720 --> 00:27:46,159
the subtotal which is that float

794
00:27:47,120 --> 00:27:51,760
so using normal ghost syntax and logic

795
00:27:49,760 --> 00:27:53,600
we can actually just iterate through all

796
00:27:51,760 --> 00:27:57,520
of the test cases here

797
00:27:53,600 --> 00:28:00,480
and t dot run is going to

798
00:27:57,520 --> 00:28:01,200
run each function as a subset or subtest

799
00:28:00,480 --> 00:28:03,039
of t

800
00:28:01,200 --> 00:28:04,399
in a separate go routine but that go

801
00:28:03,039 --> 00:28:07,760
routine will block until

802
00:28:04,399 --> 00:28:08,799
each test is finished doing this allows

803
00:28:07,760 --> 00:28:11,600
us to reuse

804
00:28:08,799 --> 00:28:13,279
this line of code but if you have longer

805
00:28:11,600 --> 00:28:15,199
tests if it's an integration test it's

806
00:28:13,279 --> 00:28:16,880
going to be nice that you have

807
00:28:15,200 --> 00:28:18,159
your test tables here because you're

808
00:28:16,880 --> 00:28:21,279
only going to have to define your

809
00:28:18,159 --> 00:28:21,279
testable stuff once

810
00:28:23,120 --> 00:28:26,158
so instead of writing an entirely new

811
00:28:25,360 --> 00:28:28,799
test

812
00:28:26,159 --> 00:28:30,399
we can validate all of these multiple

813
00:28:28,799 --> 00:28:32,799
edge cases as subtests

814
00:28:30,399 --> 00:28:33,678
so empty values multiple values negative

815
00:28:32,799 --> 00:28:35,200
values

816
00:28:33,679 --> 00:28:38,320
they all abide by the same function

817
00:28:35,200 --> 00:28:40,159
signature and we're good to go

818
00:28:38,320 --> 00:28:42,559
i'm not sure under our business model

819
00:28:40,159 --> 00:28:46,080
but circumstances would create a

820
00:28:42,559 --> 00:28:50,080
negative value or like a free beer um

821
00:28:46,080 --> 00:28:51,760
but in this case uh

822
00:28:50,080 --> 00:28:53,520
we're at least like aware of what we

823
00:28:51,760 --> 00:28:54,720
need to add and

824
00:28:53,520 --> 00:28:56,960
we probably just need like some

825
00:28:54,720 --> 00:28:58,960
additional validation in

826
00:28:56,960 --> 00:29:00,080
either our fixture or in the struct

827
00:28:58,960 --> 00:29:02,200
itself

828
00:29:00,080 --> 00:29:04,320
so while we aim to compar

829
00:29:02,200 --> 00:29:05,520
compartmentalize our code we can do the

830
00:29:04,320 --> 00:29:08,399
same for our tests

831
00:29:05,520 --> 00:29:10,480
so as a code reviewer it's a lot more

832
00:29:08,399 --> 00:29:12,158
clear to identify like what your tests

833
00:29:10,480 --> 00:29:15,360
are actually trying to accomplish

834
00:29:12,159 --> 00:29:16,159
when they're broken out like this so the

835
00:29:15,360 --> 00:29:18,000
more complex

836
00:29:16,159 --> 00:29:19,840
the setup and verification the larger

837
00:29:18,000 --> 00:29:22,559
trade-off you get with some of this code

838
00:29:19,840 --> 00:29:22,559
reusability

839
00:29:23,360 --> 00:29:27,039
http test is another standard library

840
00:29:25,919 --> 00:29:31,120
package which

841
00:29:27,039 --> 00:29:33,039
provides utilities for http testing

842
00:29:31,120 --> 00:29:34,719
the new server function starts and

843
00:29:33,039 --> 00:29:36,480
returns a new server

844
00:29:34,720 --> 00:29:39,520
the caller of course being responsible

845
00:29:36,480 --> 00:29:42,720
for stopping and cleaning up that server

846
00:29:39,520 --> 00:29:44,399
it gets created with a unique url

847
00:29:42,720 --> 00:29:46,159
so it's important that the component

848
00:29:44,399 --> 00:29:46,959
that you're testing has a way to pass

849
00:29:46,159 --> 00:29:49,200
that variable

850
00:29:46,960 --> 00:29:52,880
in so we can make our tests against the

851
00:29:49,200 --> 00:29:52,880
test server rather than a real server

852
00:29:53,279 --> 00:29:58,799
the function also accepts a http handler

853
00:29:56,799 --> 00:30:00,960
that gets invoked each time the url is

854
00:29:58,799 --> 00:30:02,639
called so we can

855
00:30:00,960 --> 00:30:04,720
basically mock out the server and have

856
00:30:02,640 --> 00:30:07,600
it return different

857
00:30:04,720 --> 00:30:08,880
status codes so for example let's think

858
00:30:07,600 --> 00:30:10,879
about how our business model

859
00:30:08,880 --> 00:30:13,440
might interact with like an external or

860
00:30:10,880 --> 00:30:15,679
arbitrary http api

861
00:30:13,440 --> 00:30:17,760
uh so say we have a third party service

862
00:30:15,679 --> 00:30:19,039
uh to process payments we can simply

863
00:30:17,760 --> 00:30:22,080
just do an http

864
00:30:19,039 --> 00:30:24,399
post such as this to

865
00:30:22,080 --> 00:30:26,000
send the payload there uh it could

866
00:30:24,399 --> 00:30:28,559
include other things such as

867
00:30:26,000 --> 00:30:31,200
like the total amount that's due any

868
00:30:28,559 --> 00:30:32,720
credit card information if it's secure

869
00:30:31,200 --> 00:30:34,480
and whatever else the payment server

870
00:30:32,720 --> 00:30:37,039
needs

871
00:30:34,480 --> 00:30:38,480
and this function as is is actually

872
00:30:37,039 --> 00:30:41,760
really difficult to test

873
00:30:38,480 --> 00:30:43,840
because pay.nee is hard-coded directly

874
00:30:41,760 --> 00:30:44,960
within the function itself so we have no

875
00:30:43,840 --> 00:30:46,240
control over

876
00:30:44,960 --> 00:30:49,200
what the server is going to do so we

877
00:30:46,240 --> 00:30:50,960
wouldn't want to do this um

878
00:30:49,200 --> 00:30:53,279
and then it would just leave us really

879
00:30:50,960 --> 00:30:54,480
prone to like intermittent service

880
00:30:53,279 --> 00:30:56,320
errors and we wouldn't be able to

881
00:30:54,480 --> 00:30:59,600
actually like change the outcomes

882
00:30:56,320 --> 00:31:02,320
of uh the service

883
00:30:59,600 --> 00:31:03,360
so passing the server address as an

884
00:31:02,320 --> 00:31:06,399
additional parameter

885
00:31:03,360 --> 00:31:07,840
is much more suitable for this test so

886
00:31:06,399 --> 00:31:09,120
the payment server here it could still

887
00:31:07,840 --> 00:31:10,879
be a constant but we're just going to

888
00:31:09,120 --> 00:31:14,799
pass it at the highest scope

889
00:31:10,880 --> 00:31:16,640
in the function so this will allow us

890
00:31:14,799 --> 00:31:20,480
when we're testing a process payment

891
00:31:16,640 --> 00:31:23,760
to pass the url of the test server

892
00:31:20,480 --> 00:31:25,840
up here and we can control the custom

893
00:31:23,760 --> 00:31:27,679
handlers that are going to respond

894
00:31:25,840 --> 00:31:29,600
so as such we can simulate things such

895
00:31:27,679 --> 00:31:31,679
as off errors server errors

896
00:31:29,600 --> 00:31:33,120
and of course like a successful payment

897
00:31:31,679 --> 00:31:36,880
processing

898
00:31:33,120 --> 00:31:39,039
um so if we have more code down here

899
00:31:36,880 --> 00:31:40,559
that like is dependent on the response

900
00:31:39,039 --> 00:31:43,840
of http post

901
00:31:40,559 --> 00:31:47,120
we can exercise those code paths as well

902
00:31:43,840 --> 00:31:47,678
um the handler func type that you see up

903
00:31:47,120 --> 00:31:50,879
here

904
00:31:47,679 --> 00:31:51,519
is defined in the http package um and it

905
00:31:50,880 --> 00:31:53,120
basically

906
00:31:51,519 --> 00:31:55,279
is an adapter that's going to allow us

907
00:31:53,120 --> 00:31:57,439
to use ordinary functions that we write

908
00:31:55,279 --> 00:31:59,200
as http handlers

909
00:31:57,440 --> 00:32:00,799
so if it abides by the appropriate

910
00:31:59,200 --> 00:32:04,720
signature here with

911
00:32:00,799 --> 00:32:05,918
a response writer and an http request

912
00:32:04,720 --> 00:32:08,320
we'll be able to pass that in as the

913
00:32:05,919 --> 00:32:08,320
handler

914
00:32:08,640 --> 00:32:12,720
the signature it looks maybe a little

915
00:32:11,360 --> 00:32:14,000
weird if you've never seen this before

916
00:32:12,720 --> 00:32:16,960
but it's the same signature

917
00:32:14,000 --> 00:32:17,440
that if i was writing my own go server i

918
00:32:16,960 --> 00:32:20,480
would

919
00:32:17,440 --> 00:32:25,039
uh run the function serv http

920
00:32:20,480 --> 00:32:28,159
and it just mimics that as a real server

921
00:32:25,039 --> 00:32:30,240
so in each test case we'll write a

922
00:32:28,159 --> 00:32:32,799
custom function here these two different

923
00:32:30,240 --> 00:32:32,799
handlers

924
00:32:32,880 --> 00:32:38,799
one for exercising a 200 status code

925
00:32:36,640 --> 00:32:41,039
so we'll do that with the right header

926
00:32:38,799 --> 00:32:43,200
function and we'll pass the status okay

927
00:32:41,039 --> 00:32:44,240
and then w dot write lets us pass a

928
00:32:43,200 --> 00:32:47,039
response body

929
00:32:44,240 --> 00:32:47,360
um through the test server and then here

930
00:32:47,039 --> 00:32:49,039
for

931
00:32:47,360 --> 00:32:50,559
our internal service error we'll just

932
00:32:49,039 --> 00:32:52,799
write that header and it won't have a

933
00:32:50,559 --> 00:32:54,639
response body

934
00:32:52,799 --> 00:32:57,039
kind of similar to how a server might

935
00:32:54,640 --> 00:32:58,960
act in the wild

936
00:32:57,039 --> 00:33:00,399
in each subtest we'll start by

937
00:32:58,960 --> 00:33:03,600
initializing a new

938
00:33:00,399 --> 00:33:06,639
http test server right here

939
00:33:03,600 --> 00:33:09,678
this handler func is from that test case

940
00:33:06,640 --> 00:33:11,600
so those little custom handlers we built

941
00:33:09,679 --> 00:33:13,519
immediately we want to make sure that we

942
00:33:11,600 --> 00:33:15,519
defer

943
00:33:13,519 --> 00:33:17,120
ts.close which means at the end of all

944
00:33:15,519 --> 00:33:18,000
of our tests or at the end of each

945
00:33:17,120 --> 00:33:20,879
iteration

946
00:33:18,000 --> 00:33:23,120
it's going to close the test server so

947
00:33:20,880 --> 00:33:26,000
it's ready to create a new one

948
00:33:23,120 --> 00:33:26,559
um so for both of the test case that we

949
00:33:26,000 --> 00:33:29,919
defined

950
00:33:26,559 --> 00:33:32,080
in the last slide the expected errors

951
00:33:29,919 --> 00:33:33,279
and the expected body are asserted as

952
00:33:32,080 --> 00:33:36,720
well

953
00:33:33,279 --> 00:33:37,279
so it should match up but it actually

954
00:33:36,720 --> 00:33:40,080
doesn't

955
00:33:37,279 --> 00:33:42,000
and it's kind of a caveat to how the

956
00:33:40,080 --> 00:33:45,600
http post method works

957
00:33:42,000 --> 00:33:50,840
does anyone know why our test might fail

958
00:33:45,600 --> 00:33:54,799
um so http post actually doesn't return

959
00:33:50,840 --> 00:33:57,439
um if it's like a 500 response code

960
00:33:54,799 --> 00:33:58,639
it still returns a nil error because it

961
00:33:57,440 --> 00:34:02,080
was actually successful

962
00:33:58,640 --> 00:34:04,960
in processing the post command so um

963
00:34:02,080 --> 00:34:05,519
what we actually need is some error

964
00:34:04,960 --> 00:34:06,799
checking

965
00:34:05,519 --> 00:34:08,560
or some checking around the response

966
00:34:06,799 --> 00:34:09,520
status code so if anything greater than

967
00:34:08,560 --> 00:34:11,918
a 400

968
00:34:09,520 --> 00:34:12,560
we want our actual function to return

969
00:34:11,918 --> 00:34:14,638
that error

970
00:34:12,560 --> 00:34:16,480
so we can have this custom payment

971
00:34:14,639 --> 00:34:17,200
server error and give us what the status

972
00:34:16,480 --> 00:34:20,320
code is

973
00:34:17,199 --> 00:34:22,399
so um

974
00:34:20,320 --> 00:34:23,359
the previous tests would fail under i'm

975
00:34:22,399 --> 00:34:25,759
sorry would pass

976
00:34:23,359 --> 00:34:29,119
under these conditions now and remember

977
00:34:25,760 --> 00:34:31,520
never trust a test you haven't seen fail

978
00:34:29,119 --> 00:34:32,480
so that caveat kind of reminds me of

979
00:34:31,520 --> 00:34:34,639
another gotcha

980
00:34:32,480 --> 00:34:36,719
that i've come across in the go world

981
00:34:34,639 --> 00:34:38,560
and it has to do with contexts

982
00:34:36,719 --> 00:34:39,759
uh specifically how it relates to text

983
00:34:38,560 --> 00:34:42,399
testing

984
00:34:39,760 --> 00:34:44,639
so the context package in go is

985
00:34:42,399 --> 00:34:46,078
responsible for carrying like deadlines

986
00:34:44,639 --> 00:34:49,280
and cancellation signals

987
00:34:46,079 --> 00:34:50,480
across api boundaries and processes it's

988
00:34:49,280 --> 00:34:53,040
extremely powerful

989
00:34:50,480 --> 00:34:54,079
but equally as important to understand

990
00:34:53,040 --> 00:34:56,320
so you

991
00:34:54,079 --> 00:34:57,440
want to initialize a parent context and

992
00:34:56,320 --> 00:35:00,000
you can call

993
00:34:57,440 --> 00:35:01,680
one of these two methods to do that they

994
00:35:00,000 --> 00:35:02,000
actually both initialize in non-nil

995
00:35:01,680 --> 00:35:05,598
empty

996
00:35:02,000 --> 00:35:05,599
context the main difference being

997
00:35:06,359 --> 00:35:12,000
context.background is typically done in

998
00:35:10,000 --> 00:35:13,040
the main function initialization and

999
00:35:12,000 --> 00:35:16,000
tests

1000
00:35:13,040 --> 00:35:17,119
whereas to do kind of acts more as like

1001
00:35:16,000 --> 00:35:20,800
a to-do

1002
00:35:17,119 --> 00:35:23,040
like comment with the idea that you will

1003
00:35:20,800 --> 00:35:23,920
eventually like replace it in the future

1004
00:35:23,040 --> 00:35:25,359
um so

1005
00:35:23,920 --> 00:35:27,599
maybe at the time that you're writing

1006
00:35:25,359 --> 00:35:29,119
the function you don't have a context

1007
00:35:27,599 --> 00:35:30,000
that's actually being passed down

1008
00:35:29,119 --> 00:35:32,560
through

1009
00:35:30,000 --> 00:35:34,960
a higher scoped function so you'll put

1010
00:35:32,560 --> 00:35:38,160
it to do there or you're unsure of which

1011
00:35:34,960 --> 00:35:39,440
context is appropriate to use but the

1012
00:35:38,160 --> 00:35:39,759
intention is that we're going to replace

1013
00:35:39,440 --> 00:35:41,680
that

1014
00:35:39,760 --> 00:35:43,520
so it doesn't really make sense to use

1015
00:35:41,680 --> 00:35:45,680
it to do in tests because

1016
00:35:43,520 --> 00:35:48,000
we have no intention on replacing it and

1017
00:35:45,680 --> 00:35:50,960
the test is already at the highest scope

1018
00:35:48,000 --> 00:35:53,119
so um if you ever notice inconsistent

1019
00:35:50,960 --> 00:35:54,880
uses of to-do and background and tests

1020
00:35:53,119 --> 00:35:56,560
that you're reviewing in the future

1021
00:35:54,880 --> 00:35:58,000
save someone from getting nerd sniped

1022
00:35:56,560 --> 00:36:00,880
and direct them to

1023
00:35:58,000 --> 00:36:02,240
background uh while they're

1024
00:36:00,880 --> 00:36:04,640
programmatically the same

1025
00:36:02,240 --> 00:36:06,799
uh if you use them correctly you can

1026
00:36:04,640 --> 00:36:08,160
actually use like static analysis tools

1027
00:36:06,800 --> 00:36:10,560
and it'll help validate that you're

1028
00:36:08,160 --> 00:36:12,799
using and passing around context through

1029
00:36:10,560 --> 00:36:15,359
your components

1030
00:36:12,800 --> 00:36:17,119
correctly so it'll help surface problems

1031
00:36:15,359 --> 00:36:19,119
early on

1032
00:36:17,119 --> 00:36:20,960
so now that we know what context to use

1033
00:36:19,119 --> 00:36:21,920
and when we can start creating functions

1034
00:36:20,960 --> 00:36:24,160
which require them

1035
00:36:21,920 --> 00:36:25,920
and test them out so context should

1036
00:36:24,160 --> 00:36:26,720
always be the first parameter in a go

1037
00:36:25,920 --> 00:36:29,040
function so

1038
00:36:26,720 --> 00:36:31,439
in this start subscription timer it's

1039
00:36:29,040 --> 00:36:33,040
the first and only parameter

1040
00:36:31,440 --> 00:36:35,119
here i've implemented a subscription

1041
00:36:33,040 --> 00:36:39,440
timer which

1042
00:36:35,119 --> 00:36:41,839
basically will listen for a context

1043
00:36:39,440 --> 00:36:43,280
cancellation signal if it's done we'll

1044
00:36:41,839 --> 00:36:46,799
just return from this

1045
00:36:43,280 --> 00:36:50,400
function if not on every interval

1046
00:36:46,800 --> 00:36:54,320
of this ticker it will send a

1047
00:36:50,400 --> 00:36:56,480
cart along the message channel

1048
00:36:54,320 --> 00:36:57,839
so you see it doesn't return here after

1049
00:36:56,480 --> 00:37:00,079
so each

1050
00:36:57,839 --> 00:37:01,040
each time that timer or that ticker

1051
00:37:00,079 --> 00:37:02,800
expires

1052
00:37:01,040 --> 00:37:04,560
it'll keep sending those messages on the

1053
00:37:02,800 --> 00:37:07,119
channel

1054
00:37:04,560 --> 00:37:08,640
so as a beer subscription service will

1055
00:37:07,119 --> 00:37:09,359
have multiple orders to fulfill

1056
00:37:08,640 --> 00:37:11,040
concurrently

1057
00:37:09,359 --> 00:37:12,480
so we'll likely have to call start

1058
00:37:11,040 --> 00:37:14,960
subscription timer

1059
00:37:12,480 --> 00:37:16,800
through a go routine for each active

1060
00:37:14,960 --> 00:37:18,560
subscription

1061
00:37:16,800 --> 00:37:20,000
um when the order is ready to be

1062
00:37:18,560 --> 00:37:21,599
processed we just send it on that

1063
00:37:20,000 --> 00:37:22,960
message chan and we'll have another

1064
00:37:21,599 --> 00:37:25,599
component of our code actually

1065
00:37:22,960 --> 00:37:28,960
responsible for receiving those messages

1066
00:37:25,599 --> 00:37:31,599
so how do we test channels to test this

1067
00:37:28,960 --> 00:37:34,400
function we'll create two unique carts

1068
00:37:31,599 --> 00:37:34,400
they're at the top

1069
00:37:35,119 --> 00:37:38,800
for the sake of this test it makes sense

1070
00:37:36,640 --> 00:37:39,520
to have a short interval duration such

1071
00:37:38,800 --> 00:37:41,920
as one second

1072
00:37:39,520 --> 00:37:43,040
or even like a higher granularity like

1073
00:37:41,920 --> 00:37:45,760
millisecond

1074
00:37:43,040 --> 00:37:47,759
duration uh but that's how we set it

1075
00:37:45,760 --> 00:37:49,440
through the subscription itself

1076
00:37:47,760 --> 00:37:51,359
um the timer is designed to run

1077
00:37:49,440 --> 00:37:53,680
continuously and it doesn't return

1078
00:37:51,359 --> 00:37:54,480
so like i said we need to run this as a

1079
00:37:53,680 --> 00:37:57,359
go routine

1080
00:37:54,480 --> 00:37:57,920
in the test if we don't it's just gonna

1081
00:37:57,359 --> 00:38:02,480
sit there

1082
00:37:57,920 --> 00:38:02,480
and block and um likely time out

1083
00:38:02,720 --> 00:38:06,399
so our function is sending values along

1084
00:38:05,599 --> 00:38:08,000
the channel

1085
00:38:06,400 --> 00:38:09,359
but we need to verify that the correct

1086
00:38:08,000 --> 00:38:10,800
message is actually being received on

1087
00:38:09,359 --> 00:38:13,839
that message chan

1088
00:38:10,800 --> 00:38:15,839
so this channel syntax here is just

1089
00:38:13,839 --> 00:38:19,440
gonna allow us to um

1090
00:38:15,839 --> 00:38:22,160
just like pop that message out of

1091
00:38:19,440 --> 00:38:22,960
the channel and then we'll do a type

1092
00:38:22,160 --> 00:38:24,560
assertion

1093
00:38:22,960 --> 00:38:26,640
to make sure that it's actually a cart

1094
00:38:24,560 --> 00:38:28,078
object and assert that it's equal to

1095
00:38:26,640 --> 00:38:30,000
this card up here

1096
00:38:28,079 --> 00:38:31,200
so i've done this twice because i want

1097
00:38:30,000 --> 00:38:34,640
to make sure that we can

1098
00:38:31,200 --> 00:38:37,919
test consecutive items and that the

1099
00:38:34,640 --> 00:38:39,200
contents of this item is unique to the

1100
00:38:37,920 --> 00:38:43,200
one that we defined

1101
00:38:39,200 --> 00:38:45,200
earlier now that we've

1102
00:38:43,200 --> 00:38:46,960
verified our program can send values on

1103
00:38:45,200 --> 00:38:48,799
a channel we want to work on a

1104
00:38:46,960 --> 00:38:49,440
concurrent component that's designed to

1105
00:38:48,800 --> 00:38:51,280
receive them

1106
00:38:49,440 --> 00:38:52,960
so we have the start order handler

1107
00:38:51,280 --> 00:38:55,680
function

1108
00:38:52,960 --> 00:38:56,960
it's again designed to continuously wait

1109
00:38:55,680 --> 00:38:58,799
and handle any

1110
00:38:56,960 --> 00:39:02,480
messages that are received up here so

1111
00:38:58,800 --> 00:39:02,480
that same syntax that we use in our test

1112
00:39:03,760 --> 00:39:06,960
for each cart that it receives on the

1113
00:39:06,000 --> 00:39:10,560
message channel

1114
00:39:06,960 --> 00:39:14,240
it's going to attempt to place the order

1115
00:39:10,560 --> 00:39:16,160
in this arbitrary function

1116
00:39:14,240 --> 00:39:18,799
that's basically just going to iterate

1117
00:39:16,160 --> 00:39:20,720
something in our order handler

1118
00:39:18,800 --> 00:39:22,160
so if it fails we'll log but we'll

1119
00:39:20,720 --> 00:39:25,759
continue on and stay

1120
00:39:22,160 --> 00:39:28,078
in here if there's any type assertion

1121
00:39:25,760 --> 00:39:29,440
failure we'll log that as well the only

1122
00:39:28,079 --> 00:39:32,560
time we're actually going to exit

1123
00:39:29,440 --> 00:39:34,320
this program or this go routine is if

1124
00:39:32,560 --> 00:39:37,680
the channel itself is closed which we

1125
00:39:34,320 --> 00:39:37,680
can detect up there

1126
00:39:37,920 --> 00:39:41,040
to test this asynchronous behavior we

1127
00:39:40,160 --> 00:39:42,799
can simply

1128
00:39:41,040 --> 00:39:44,800
start the order handler in a go routine

1129
00:39:42,800 --> 00:39:45,599
and send a few objects on the message

1130
00:39:44,800 --> 00:39:47,920
chan

1131
00:39:45,599 --> 00:39:49,760
so we start the function here assert

1132
00:39:47,920 --> 00:39:51,119
that the length is equal before we even

1133
00:39:49,760 --> 00:39:53,359
start sending anything

1134
00:39:51,119 --> 00:39:55,040
and then we send a couple messages on

1135
00:39:53,359 --> 00:39:57,440
the message chan

1136
00:39:55,040 --> 00:39:59,119
you can see that this is a case object

1137
00:39:57,440 --> 00:40:03,200
not a cart object but

1138
00:39:59,119 --> 00:40:06,400
we are guarding against um

1139
00:40:03,200 --> 00:40:06,879
wrongful like type assertions in our

1140
00:40:06,400 --> 00:40:09,359
code

1141
00:40:06,880 --> 00:40:11,359
so we know that there's only two carts

1142
00:40:09,359 --> 00:40:12,400
that are processed and the length is

1143
00:40:11,359 --> 00:40:16,720
equal to two so

1144
00:40:12,400 --> 00:40:18,240
this message isn't actually received

1145
00:40:16,720 --> 00:40:20,720
well the message is received but it

1146
00:40:18,240 --> 00:40:23,598
doesn't count in our length

1147
00:40:20,720 --> 00:40:26,078
um so at this point we have two

1148
00:40:23,599 --> 00:40:28,079
asynchronous and concurrent components

1149
00:40:26,079 --> 00:40:30,560
of our project our subscription timer

1150
00:40:28,079 --> 00:40:32,720
and our order handler

1151
00:40:30,560 --> 00:40:34,720
they're both basically small enough to

1152
00:40:32,720 --> 00:40:36,078
fit in a single side which is kind of a

1153
00:40:34,720 --> 00:40:37,118
good indicator that

1154
00:40:36,079 --> 00:40:38,960
they're broken down and

1155
00:40:37,119 --> 00:40:40,160
compartmentalized which again we said

1156
00:40:38,960 --> 00:40:42,079
was really good

1157
00:40:40,160 --> 00:40:44,720
um so breaking things out is just going

1158
00:40:42,079 --> 00:40:47,119
to make our lives easier in the future

1159
00:40:44,720 --> 00:40:48,480
um in a nutshell we have a working

1160
00:40:47,119 --> 00:40:49,920
program with pseudocode that

1161
00:40:48,480 --> 00:40:52,319
demonstrates some of those basics for

1162
00:40:49,920 --> 00:40:54,480
writing go tests

1163
00:40:52,319 --> 00:40:56,000
but we have yet to polish up on one of

1164
00:40:54,480 --> 00:40:58,079
the harder concepts and go

1165
00:40:56,000 --> 00:41:00,640
which is race conditions and race

1166
00:40:58,079 --> 00:41:00,640
detection

1167
00:41:00,880 --> 00:41:05,520
introducing that complexity kind of

1168
00:41:03,680 --> 00:41:06,240
increases vulnerabilities such as race

1169
00:41:05,520 --> 00:41:08,640
conditions

1170
00:41:06,240 --> 00:41:11,839
whenever we're using concern concurrency

1171
00:41:08,640 --> 00:41:14,640
such as gut routines and

1172
00:41:11,839 --> 00:41:15,119
channels i'm going to try and speed up a

1173
00:41:14,640 --> 00:41:17,279
little bit

1174
00:41:15,119 --> 00:41:20,560
again we can use the dash race argument

1175
00:41:17,280 --> 00:41:25,760
to detect race conditions

1176
00:41:20,560 --> 00:41:28,960
where yeah we'll just skip over that

1177
00:41:25,760 --> 00:41:31,040
so we already have our test written

1178
00:41:28,960 --> 00:41:32,800
and i actually have a race condition in

1179
00:41:31,040 --> 00:41:35,440
one of them already

1180
00:41:32,800 --> 00:41:36,880
it was somewhat intentional it's fine

1181
00:41:35,440 --> 00:41:37,520
but there's a couple techniques that we

1182
00:41:36,880 --> 00:41:41,200
can use

1183
00:41:37,520 --> 00:41:43,040
to resolve unsafe memory access such as

1184
00:41:41,200 --> 00:41:45,279
blocking with weight groups blocking

1185
00:41:43,040 --> 00:41:46,720
with channels or turning a channel or

1186
00:41:45,280 --> 00:41:48,160
using a mutex

1187
00:41:46,720 --> 00:41:50,078
some of these solutions are going to

1188
00:41:48,160 --> 00:41:51,440
require me to refactor code and i don't

1189
00:41:50,079 --> 00:41:53,359
really have time for that

1190
00:41:51,440 --> 00:41:54,560
uh so we'll look at the stack trace and

1191
00:41:53,359 --> 00:41:57,200
try to identify

1192
00:41:54,560 --> 00:41:58,078
why it's failing basically this is just

1193
00:41:57,200 --> 00:42:00,879
what it looks like

1194
00:41:58,079 --> 00:42:01,359
it's saying on line 123 and line 138 in

1195
00:42:00,880 --> 00:42:06,400
my

1196
00:42:01,359 --> 00:42:08,640
go file and i go test that's what is

1197
00:42:06,400 --> 00:42:10,640
problematic and comparing these two

1198
00:42:08,640 --> 00:42:13,200
lines you can see that

1199
00:42:10,640 --> 00:42:15,680
i'm attempting to read from the

1200
00:42:13,200 --> 00:42:17,919
subscription cart

1201
00:42:15,680 --> 00:42:20,480
in the main function and then in the

1202
00:42:17,920 --> 00:42:23,440
test i'm trying to

1203
00:42:20,480 --> 00:42:25,520
set the subscription cart and mutate it

1204
00:42:23,440 --> 00:42:26,560
and write to it so that's really unsafe

1205
00:42:25,520 --> 00:42:28,160
especially when you have multiple

1206
00:42:26,560 --> 00:42:30,480
concurrent processes that could

1207
00:42:28,160 --> 00:42:33,200
access this so in this case we're going

1208
00:42:30,480 --> 00:42:36,480
to want to use a mutex

1209
00:42:33,200 --> 00:42:37,279
to protect against us so the sync

1210
00:42:36,480 --> 00:42:39,520
package

1211
00:42:37,280 --> 00:42:41,040
i wish i had a little bit more time to

1212
00:42:39,520 --> 00:42:43,359
dive into the synchronous

1213
00:42:41,040 --> 00:42:45,680
synchronization that it can offer but

1214
00:42:43,359 --> 00:42:47,920
it's basically intended for uh use by

1215
00:42:45,680 --> 00:42:50,399
like low level library routines

1216
00:42:47,920 --> 00:42:51,359
uh mutex uh stands for like mutual

1217
00:42:50,400 --> 00:42:54,079
exclusion lock

1218
00:42:51,359 --> 00:42:55,119
so basically you can lock a value and

1219
00:42:54,079 --> 00:42:58,400
unlock a value

1220
00:42:55,119 --> 00:43:01,200
and locking it will

1221
00:42:58,400 --> 00:43:02,480
block any like reads and writes to that

1222
00:43:01,200 --> 00:43:05,759
value

1223
00:43:02,480 --> 00:43:07,440
until it's unlocked so we only need to

1224
00:43:05,760 --> 00:43:09,440
make a couple more changes to make that

1225
00:43:07,440 --> 00:43:12,079
test pass

1226
00:43:09,440 --> 00:43:12,800
first we'll create we'll make sure the

1227
00:43:12,079 --> 00:43:15,839
cart

1228
00:43:12,800 --> 00:43:18,319
and interval variables are not exported

1229
00:43:15,839 --> 00:43:19,680
so we can't access them outside of our

1230
00:43:18,319 --> 00:43:22,960
package

1231
00:43:19,680 --> 00:43:25,279
we'll add mu a mutual

1232
00:43:22,960 --> 00:43:26,319
mutual exclusion lock and then any time

1233
00:43:25,280 --> 00:43:28,079
we want to

1234
00:43:26,319 --> 00:43:29,440
we'll create those getters and setters

1235
00:43:28,079 --> 00:43:31,920
and any time we want to

1236
00:43:29,440 --> 00:43:33,280
either get the value of the cart or set

1237
00:43:31,920 --> 00:43:36,720
the value of the cart

1238
00:43:33,280 --> 00:43:38,560
we will lock it set it get it and then

1239
00:43:36,720 --> 00:43:40,640
unlock it so that we'll just do that

1240
00:43:38,560 --> 00:43:42,160
with the defer statement here

1241
00:43:40,640 --> 00:43:44,400
sorry i know we went over that a little

1242
00:43:42,160 --> 00:43:46,560
bit fast but lo and behold

1243
00:43:44,400 --> 00:43:48,720
synchronization protects our concurrent

1244
00:43:46,560 --> 00:43:50,720
functions and the race detector

1245
00:43:48,720 --> 00:43:53,200
okays our tests with just those simple

1246
00:43:50,720 --> 00:43:55,680
changes such as a mutex

1247
00:43:53,200 --> 00:43:57,279
so sync is just one of the many packages

1248
00:43:55,680 --> 00:43:59,359
that uh

1249
00:43:57,280 --> 00:44:00,560
we went over today um and it's really

1250
00:43:59,359 --> 00:44:02,078
really important so

1251
00:44:00,560 --> 00:44:03,759
i would definitely suggest going over

1252
00:44:02,079 --> 00:44:06,720
that a little bit uh

1253
00:44:03,760 --> 00:44:08,079
sorry i'm rambling on but i really

1254
00:44:06,720 --> 00:44:10,319
appreciate you guys listening to me at

1255
00:44:08,079 --> 00:44:12,319
nerd out on testing and going

1256
00:44:10,319 --> 00:44:13,839
um all of the examples you saw are up on

1257
00:44:12,319 --> 00:44:18,160
my github which is uh

1258
00:44:13,839 --> 00:44:18,480
nikki xdev um and then a special thanks

1259
00:44:18,160 --> 00:44:20,000
to

1260
00:44:18,480 --> 00:44:21,599
all of these folks that contribute to

1261
00:44:20,000 --> 00:44:24,319
open source with their for con

1262
00:44:21,599 --> 00:44:25,520
or their gopher illustrations so thank

1263
00:44:24,319 --> 00:44:37,839
you guys i don't know if you have time

1264
00:44:25,520 --> 00:44:37,839
for tests but come find me out after

1265
00:44:38,960 --> 00:44:41,040
you

