1
00:00:05,040 --> 00:00:09,440
um

2
00:00:05,680 --> 00:00:12,480
so our next speaker is evan wu

3
00:00:09,440 --> 00:00:14,559
she is active an active member of the

4
00:00:12,480 --> 00:00:17,119
elixir community for a long time

5
00:00:14,559 --> 00:00:17,759
i remember personally singer speaking at

6
00:00:17,119 --> 00:00:22,000
elixir

7
00:00:17,760 --> 00:00:25,039
london 2017 and then elixir conf 2019

8
00:00:22,000 --> 00:00:27,439
um and now here at fosdem 2020 so uh

9
00:00:25,039 --> 00:00:28,880
in this year she has also a number of

10
00:00:27,439 --> 00:00:31,599
open source projects

11
00:00:28,880 --> 00:00:32,000
in elixir and yes she is going to talk

12
00:00:31,599 --> 00:00:33,760
about

13
00:00:32,000 --> 00:00:35,550
processes and grains so let's give it up

14
00:00:33,760 --> 00:00:39,120
for revenue

15
00:00:35,550 --> 00:00:41,440
[Applause]

16
00:00:39,120 --> 00:00:42,320
so thank you thank you very much i think

17
00:00:41,440 --> 00:00:46,000
i talked too much

18
00:00:42,320 --> 00:00:48,239
so today i'll try to keep it very short

19
00:00:46,000 --> 00:00:50,079
so for myself i basically write programs

20
00:00:48,239 --> 00:00:50,718
and sometimes they break so i fix them

21
00:00:50,079 --> 00:00:53,520
so

22
00:00:50,719 --> 00:00:54,320
i watch them and that's my twitter

23
00:00:53,520 --> 00:00:57,120
account

24
00:00:54,320 --> 00:00:59,359
which you could use to you know to

25
00:00:57,120 --> 00:01:02,399
discuss certain things with me if needed

26
00:00:59,359 --> 00:01:02,960
so today's topic is about um it's about

27
00:01:02,399 --> 00:01:05,600
audience

28
00:01:02,960 --> 00:01:07,280
and especially within the context of

29
00:01:05,600 --> 00:01:10,399
elixir applications

30
00:01:07,280 --> 00:01:12,799
so what exactly is earliest um

31
00:01:10,400 --> 00:01:15,040
i believe if the framing of the audience

32
00:01:12,799 --> 00:01:15,920
paper is correct then it started with a

33
00:01:15,040 --> 00:01:18,560
problem brewing

34
00:01:15,920 --> 00:01:21,200
inside of microsoft where it's really

35
00:01:18,560 --> 00:01:23,520
related to managing management of state

36
00:01:21,200 --> 00:01:24,880
that doesn't fit on a single machine so

37
00:01:23,520 --> 00:01:26,479
usually when you when you write

38
00:01:24,880 --> 00:01:28,240
applications you start with one server

39
00:01:26,479 --> 00:01:30,880
and that server is a database server

40
00:01:28,240 --> 00:01:31,600
so you have a single server it's a pet

41
00:01:30,880 --> 00:01:34,079
then

42
00:01:31,600 --> 00:01:36,000
well state history in the database but

43
00:01:34,079 --> 00:01:36,960
then you may end up with something like

44
00:01:36,000 --> 00:01:38,640
this where

45
00:01:36,960 --> 00:01:40,000
one server is no longer enough because

46
00:01:38,640 --> 00:01:41,920
it gets overloaded so now

47
00:01:40,000 --> 00:01:43,920
you have one database server and many

48
00:01:41,920 --> 00:01:45,759
stateless application servers

49
00:01:43,920 --> 00:01:47,680
in this case the state is still stored

50
00:01:45,759 --> 00:01:49,119
on the database but now in order for

51
00:01:47,680 --> 00:01:50,000
this data to be processed and brought to

52
00:01:49,119 --> 00:01:51,680
the end user

53
00:01:50,000 --> 00:01:54,079
you now have to have the data travel

54
00:01:51,680 --> 00:01:55,680
through two tiers of networking first

55
00:01:54,079 --> 00:01:56,880
from the database to the actual server

56
00:01:55,680 --> 00:01:58,799
which doesn't work

57
00:01:56,880 --> 00:02:00,000
and then the end result is incentive

58
00:01:58,799 --> 00:02:00,799
sent to the customer so there's

59
00:02:00,000 --> 00:02:04,640
basically

60
00:02:00,799 --> 00:02:07,360
no consistency um so basically

61
00:02:04,640 --> 00:02:08,959
uh sorry i pressed two times so but

62
00:02:07,360 --> 00:02:11,520
basically in this situation

63
00:02:08,959 --> 00:02:13,840
you end up with a lot of network traffic

64
00:02:11,520 --> 00:02:16,879
and sometimes you still get overloaded

65
00:02:13,840 --> 00:02:19,440
in this regard so usually you will add

66
00:02:16,879 --> 00:02:20,840
some kind of cache server in this case

67
00:02:19,440 --> 00:02:24,160
where since the database is so

68
00:02:20,840 --> 00:02:26,000
overloaded you add some replica

69
00:02:24,160 --> 00:02:27,680
webcam nodes and they might still not be

70
00:02:26,000 --> 00:02:29,200
enough so you add a cache server or

71
00:02:27,680 --> 00:02:31,280
multiple cache nodes

72
00:02:29,200 --> 00:02:32,720
and you end up with no consistency

73
00:02:31,280 --> 00:02:34,000
because now you have to handle cache

74
00:02:32,720 --> 00:02:35,519
invalidation

75
00:02:34,000 --> 00:02:37,599
this is a problem that plagues the web

76
00:02:35,519 --> 00:02:39,280
community um

77
00:02:37,599 --> 00:02:41,040
and has plagued with community since the

78
00:02:39,280 --> 00:02:43,760
beginning of time

79
00:02:41,040 --> 00:02:44,560
in rails for example all cache objects

80
00:02:43,760 --> 00:02:46,720
in rails

81
00:02:44,560 --> 00:02:48,560
usually contain some kind of cache key

82
00:02:46,720 --> 00:02:52,160
the cache key is a hash

83
00:02:48,560 --> 00:02:56,000
or just just a timestamp of the object

84
00:02:52,160 --> 00:02:57,920
so it was actually revised i think in a

85
00:02:56,000 --> 00:02:59,680
more recent version of rails where

86
00:02:57,920 --> 00:03:01,760
instead of doing this which pollutes the

87
00:02:59,680 --> 00:03:03,519
cache because if an object is modified

88
00:03:01,760 --> 00:03:06,480
the old version that has been cached

89
00:03:03,519 --> 00:03:08,159
doesn't go away a new version isn't

90
00:03:06,480 --> 00:03:09,440
generated and put into cache now in the

91
00:03:08,159 --> 00:03:11,599
cache you have two

92
00:03:09,440 --> 00:03:12,959
objects one old one new and the old old

93
00:03:11,599 --> 00:03:14,640
one isn't used anymore

94
00:03:12,959 --> 00:03:16,640
so you introduce all the cache pressure

95
00:03:14,640 --> 00:03:17,679
and so on i think in the most recent

96
00:03:16,640 --> 00:03:20,720
version of rails

97
00:03:17,680 --> 00:03:23,440
it has been updated to a point where

98
00:03:20,720 --> 00:03:24,799
the cache key only contains the object's

99
00:03:23,440 --> 00:03:26,400
object's identity

100
00:03:24,799 --> 00:03:28,000
but then within it there is some kind of

101
00:03:26,400 --> 00:03:31,200
hierarchical structure

102
00:03:28,000 --> 00:03:32,959
so if the object needs to be updated the

103
00:03:31,200 --> 00:03:35,040
key is reduced but the content of

104
00:03:32,959 --> 00:03:36,080
of that key or the content that's linked

105
00:03:35,040 --> 00:03:38,720
with that key

106
00:03:36,080 --> 00:03:40,319
is updated in this manner anyway there's

107
00:03:38,720 --> 00:03:43,040
a lot of management you have to do in

108
00:03:40,319 --> 00:03:44,958
this kind of setup

109
00:03:43,040 --> 00:03:46,560
because now you have two places not

110
00:03:44,959 --> 00:03:48,879
potentially store date stores

111
00:03:46,560 --> 00:03:50,480
store state for you so you have to

112
00:03:48,879 --> 00:03:51,518
consult the cash if it's not in cash

113
00:03:50,480 --> 00:03:53,200
consult a database

114
00:03:51,519 --> 00:03:54,560
and remember to update the cash remember

115
00:03:53,200 --> 00:03:56,159
to not update the cash when the data it

116
00:03:54,560 --> 00:03:57,920
has been updated again and so on and so

117
00:03:56,159 --> 00:04:02,000
on there is no consistency

118
00:03:57,920 --> 00:04:04,000
and it's horrible so yeah

119
00:04:02,000 --> 00:04:05,280
basically two issues you have to too

120
00:04:04,000 --> 00:04:06,720
many computers and you have the wrong

121
00:04:05,280 --> 00:04:07,760
kind of computers and the computers

122
00:04:06,720 --> 00:04:08,799
should have don't do these things you

123
00:04:07,760 --> 00:04:10,399
want and computers

124
00:04:08,799 --> 00:04:11,840
that are doing the things you want are

125
00:04:10,400 --> 00:04:13,680
not the ones you have and so one is the

126
00:04:11,840 --> 00:04:16,160
one so you have infrastructure sprawl

127
00:04:13,680 --> 00:04:18,000
this is what happens and you're having

128
00:04:16,160 --> 00:04:20,320
invalidation issues

129
00:04:18,000 --> 00:04:21,358
so at least that's that was the framing

130
00:04:20,320 --> 00:04:24,400
of the paper

131
00:04:21,358 --> 00:04:25,840
where since this was an issue a

132
00:04:24,400 --> 00:04:27,599
stateless middle tier doesn't provide

133
00:04:25,840 --> 00:04:29,119
data locality you have to move data from

134
00:04:27,600 --> 00:04:31,199
one place to another

135
00:04:29,120 --> 00:04:34,080
so there's a lot of transportation going

136
00:04:31,199 --> 00:04:36,479
on for for that data

137
00:04:34,080 --> 00:04:37,680
so they look at the actual model and the

138
00:04:36,479 --> 00:04:39,440
actual model looks

139
00:04:37,680 --> 00:04:41,120
looks appealing because you can write a

140
00:04:39,440 --> 00:04:43,600
function and put the function anywhere

141
00:04:41,120 --> 00:04:45,759
to run the function local to the data

142
00:04:43,600 --> 00:04:46,400
and well in a more modern way of saying

143
00:04:45,759 --> 00:04:48,960
it's

144
00:04:46,400 --> 00:04:51,198
saying it it's basically data gravity

145
00:04:48,960 --> 00:04:53,359
but in microsoft speak it's basically

146
00:04:51,199 --> 00:04:55,280
this

147
00:04:53,360 --> 00:04:57,120
so they continue on to say the action

148
00:04:55,280 --> 00:04:59,440
models such as earlier

149
00:04:57,120 --> 00:05:01,680
burden developers with many distributed

150
00:04:59,440 --> 00:05:03,520
system complexities

151
00:05:01,680 --> 00:05:05,120
uh the key challenges are that you need

152
00:05:03,520 --> 00:05:06,560
to manage the lifecycle of actors

153
00:05:05,120 --> 00:05:08,400
because you have to create them one

154
00:05:06,560 --> 00:05:09,919
in one place you have to communicate

155
00:05:08,400 --> 00:05:10,960
with them and when you're done with them

156
00:05:09,919 --> 00:05:12,560
you have to tell them to go away

157
00:05:10,960 --> 00:05:14,880
otherwise they will stay around and so

158
00:05:12,560 --> 00:05:17,840
and so on

159
00:05:14,880 --> 00:05:19,919
so the developer must be a distributed

160
00:05:17,840 --> 00:05:22,159
systems expert unless if orleans come

161
00:05:19,919 --> 00:05:24,000
coming to play that's essentially what

162
00:05:22,160 --> 00:05:27,759
their paper was about

163
00:05:24,000 --> 00:05:29,919
so um their result was basically

164
00:05:27,759 --> 00:05:31,600
um each actor is represented as some

165
00:05:29,919 --> 00:05:33,198
kind of grain a great you can implement

166
00:05:31,600 --> 00:05:34,479
code for a grain like you implement any

167
00:05:33,199 --> 00:05:36,560
kind of object.net

168
00:05:34,479 --> 00:05:38,400
and the grain has four states where

169
00:05:36,560 --> 00:05:40,080
persistent means that

170
00:05:38,400 --> 00:05:41,919
there is only information in some kind

171
00:05:40,080 --> 00:05:43,758
of data service like a database

172
00:05:41,919 --> 00:05:45,120
and there is actually no computation

173
00:05:43,759 --> 00:05:46,240
going on there is no process running in

174
00:05:45,120 --> 00:05:48,560
your server

175
00:05:46,240 --> 00:05:50,000
but you can address anything address a

176
00:05:48,560 --> 00:05:51,919
virtual actor by the name

177
00:05:50,000 --> 00:05:53,520
let's say for example a customer pays

178
00:05:51,919 --> 00:05:55,280
the customer pays an invoice in this

179
00:05:53,520 --> 00:05:56,719
case you have actually two actors

180
00:05:55,280 --> 00:05:58,799
one is a customer another one is the

181
00:05:56,720 --> 00:05:59,759
invoice so when the customer pays an

182
00:05:58,800 --> 00:06:01,520
invoice

183
00:05:59,759 --> 00:06:02,720
you call upon the virtual actor

184
00:06:01,520 --> 00:06:04,000
representing the customer and you call

185
00:06:02,720 --> 00:06:05,840
upon the virtual actor representing

186
00:06:04,000 --> 00:06:06,479
invoicing with each refund database do

187
00:06:05,840 --> 00:06:07,758
the right thing

188
00:06:06,479 --> 00:06:09,919
and then you tell the customer you are

189
00:06:07,759 --> 00:06:11,360
paying this invoice that's essentially

190
00:06:09,919 --> 00:06:12,799
how the virtual actor works and then you

191
00:06:11,360 --> 00:06:14,560
don't have to worry about

192
00:06:12,800 --> 00:06:15,919
stuff such as okay so now i'm done with

193
00:06:14,560 --> 00:06:17,680
the customer i close down the customer

194
00:06:15,919 --> 00:06:19,198
actually i close down invoice actor

195
00:06:17,680 --> 00:06:21,600
essentially orleans runtime does it for

196
00:06:19,199 --> 00:06:23,520
you so that's why you have these four

197
00:06:21,600 --> 00:06:26,240
states

198
00:06:23,520 --> 00:06:28,080
yeah so within the construct of orleans

199
00:06:26,240 --> 00:06:29,199
a grain basically has an identity which

200
00:06:28,080 --> 00:06:30,479
is an identifier

201
00:06:29,199 --> 00:06:32,560
email address for the customer invoice

202
00:06:30,479 --> 00:06:34,240
number for an invoice or so on

203
00:06:32,560 --> 00:06:36,080
uh there is some kind of behavior which

204
00:06:34,240 --> 00:06:36,639
is linked with that kind of grain which

205
00:06:36,080 --> 00:06:38,159
is

206
00:06:36,639 --> 00:06:40,000
well internet is basically your class

207
00:06:38,160 --> 00:06:42,960
and in our elixir that would

208
00:06:40,000 --> 00:06:44,479
be similar to how you always use gen

209
00:06:42,960 --> 00:06:46,000
servers but in many gen server

210
00:06:44,479 --> 00:06:47,280
implementations you always do use chain

211
00:06:46,000 --> 00:06:48,560
server so you comply to

212
00:06:47,280 --> 00:06:50,318
general behavior but you actually

213
00:06:48,560 --> 00:06:51,120
implement different callback modules so

214
00:06:50,319 --> 00:06:52,720
that's the behavior

215
00:06:51,120 --> 00:06:54,400
and the state obviously obviously is

216
00:06:52,720 --> 00:06:56,639
date

217
00:06:54,400 --> 00:06:58,080
well and obviously orleans being

218
00:06:56,639 --> 00:07:00,160
oriented if you if you

219
00:06:58,080 --> 00:07:01,520
look look up uh on the web today and

220
00:07:00,160 --> 00:07:03,360
look for his documentation it'll tell

221
00:07:01,520 --> 00:07:05,440
you okay this is how you deploy

222
00:07:03,360 --> 00:07:06,800
so well wait a second here so all in

223
00:07:05,440 --> 00:07:08,160
green space would represent singles

224
00:07:06,800 --> 00:07:09,599
rated processes

225
00:07:08,160 --> 00:07:11,520
one count two they can be configured to

226
00:07:09,599 --> 00:07:13,840
a lot of re-entry holes

227
00:07:11,520 --> 00:07:15,680
which you may or may not want but uh but

228
00:07:13,840 --> 00:07:18,479
it's going to be imported later on

229
00:07:15,680 --> 00:07:18,960
so they are scheduled cooperatively so

230
00:07:18,479 --> 00:07:21,599
unlike

231
00:07:18,960 --> 00:07:23,280
elixir or erlang it's never preempted so

232
00:07:21,599 --> 00:07:25,599
if any grain takes a long time

233
00:07:23,280 --> 00:07:26,559
within orleans then everything gets low

234
00:07:25,599 --> 00:07:28,319
or they will block

235
00:07:26,560 --> 00:07:30,639
and the justification provided in the

236
00:07:28,319 --> 00:07:32,800
paper was that this was actually better

237
00:07:30,639 --> 00:07:34,720
for disciplined teams because it

238
00:07:32,800 --> 00:07:35,759
provides better predictability and

239
00:07:34,720 --> 00:07:38,880
multitasking

240
00:07:35,759 --> 00:07:41,520
but you have to keep in mind the context

241
00:07:38,880 --> 00:07:43,199
now the good part so these virtual

242
00:07:41,520 --> 00:07:44,159
actors are automatically activated when

243
00:07:43,199 --> 00:07:45,360
there are messages

244
00:07:44,160 --> 00:07:47,520
if there are no messages they're not

245
00:07:45,360 --> 00:07:48,800
activated and also when they're done

246
00:07:47,520 --> 00:07:51,599
they stick around for a bit and then

247
00:07:48,800 --> 00:07:53,440
they go away automatically

248
00:07:51,599 --> 00:07:55,599
so so that's a good part because in

249
00:07:53,440 --> 00:07:57,199
elixir or around applications

250
00:07:55,599 --> 00:07:59,120
well you got supervisors if you want to

251
00:07:57,199 --> 00:08:00,160
use them you got distributed supervisors

252
00:07:59,120 --> 00:08:01,840
built upon light loss

253
00:08:00,160 --> 00:08:03,840
or swarm or horde if you want to use

254
00:08:01,840 --> 00:08:05,198
them but you have to create your own

255
00:08:03,840 --> 00:08:06,560
processes yourself

256
00:08:05,199 --> 00:08:09,759
and you have to name it yourself and you

257
00:08:06,560 --> 00:08:12,560
have to tell them to go away on your own

258
00:08:09,759 --> 00:08:13,360
so yeah so early hosts or silos in this

259
00:08:12,560 --> 00:08:15,360
regard

260
00:08:13,360 --> 00:08:17,039
they are responsible for hosting grains

261
00:08:15,360 --> 00:08:18,240
so you can't just take a grain and just

262
00:08:17,039 --> 00:08:20,800
run the other thing there

263
00:08:18,240 --> 00:08:22,720
because in in the context of oreos there

264
00:08:20,800 --> 00:08:23,919
is no such thing as a scheduler already

265
00:08:22,720 --> 00:08:25,680
already implemented

266
00:08:23,919 --> 00:08:27,840
so they went on and implemented a

267
00:08:25,680 --> 00:08:29,440
scheduler which is responsible for

268
00:08:27,840 --> 00:08:32,640
executing work for

269
00:08:29,440 --> 00:08:35,760
that these screens are asked to do and

270
00:08:32,640 --> 00:08:38,000
there was no um no out of the box

271
00:08:35,760 --> 00:08:40,718
clustering distribution and so on so

272
00:08:38,000 --> 00:08:43,279
they implemented this part as well

273
00:08:40,719 --> 00:08:44,880
and there's a global way of scanning the

274
00:08:43,279 --> 00:08:45,839
whole whole world and finding out where

275
00:08:44,880 --> 00:08:47,519
the grains are

276
00:08:45,839 --> 00:08:49,680
if you want to do a listing but the

277
00:08:47,519 --> 00:08:53,440
paper also acknowledged this is

278
00:08:49,680 --> 00:08:57,519
kind of expensive to do well

279
00:08:53,440 --> 00:08:58,720
so obviously this is what happens

280
00:08:57,519 --> 00:09:01,360
whenever whenever you have something

281
00:08:58,720 --> 00:09:02,240
like that so audience basically

282
00:09:01,360 --> 00:09:05,760
resembles

283
00:09:02,240 --> 00:09:08,959
an erlang paradigm so obviously

284
00:09:05,760 --> 00:09:12,000
somebody has ported it back to erlang so

285
00:09:08,959 --> 00:09:14,640
um a fellow uh mister

286
00:09:12,000 --> 00:09:15,519
so basically if a fellow mr slaughter

287
00:09:14,640 --> 00:09:18,640
actually

288
00:09:15,519 --> 00:09:22,080
ported it to erlang a few years ago

289
00:09:18,640 --> 00:09:23,519
and i i think he might be here

290
00:09:22,080 --> 00:09:25,440
at the event i don't know where he is

291
00:09:23,519 --> 00:09:26,880
but i think he's based here

292
00:09:25,440 --> 00:09:28,640
so it's called erlings which is

293
00:09:26,880 --> 00:09:30,720
basically urban orleans

294
00:09:28,640 --> 00:09:32,720
and the premise is basically okay so

295
00:09:30,720 --> 00:09:33,920
each grain is basically singles ready so

296
00:09:32,720 --> 00:09:36,320
it's one process

297
00:09:33,920 --> 00:09:38,000
so each grain is one process process

298
00:09:36,320 --> 00:09:40,320
registration

299
00:09:38,000 --> 00:09:41,920
um in airline or elixir well you can use

300
00:09:40,320 --> 00:09:42,720
pg two process group two which is

301
00:09:41,920 --> 00:09:44,640
updated version of

302
00:09:42,720 --> 00:09:46,880
process group that's in the core erlang

303
00:09:44,640 --> 00:09:49,600
distribution or core airline

304
00:09:46,880 --> 00:09:50,000
bundle is part of the kernel or you can

305
00:09:49,600 --> 00:09:52,640
use

306
00:09:50,000 --> 00:09:54,640
warm or to do process registration

307
00:09:52,640 --> 00:09:57,439
but in this case he chose to use

308
00:09:54,640 --> 00:09:59,199
lasp for it because last um well it's

309
00:09:57,440 --> 00:10:00,000
more modern and it does provide very

310
00:09:59,200 --> 00:10:01,760
scalability

311
00:10:00,000 --> 00:10:03,680
and it works with partisan if you want

312
00:10:01,760 --> 00:10:05,760
to

313
00:10:03,680 --> 00:10:07,120
there is another point which is grains

314
00:10:05,760 --> 00:10:09,200
are either staple

315
00:10:07,120 --> 00:10:11,120
meaning they have state if you work with

316
00:10:09,200 --> 00:10:12,800
it it has some kind of state and when it

317
00:10:11,120 --> 00:10:14,000
it gets deactivated the state actually

318
00:10:12,800 --> 00:10:15,279
is stored elsewhere so when it's

319
00:10:14,000 --> 00:10:18,160
activated again

320
00:10:15,279 --> 00:10:20,399
that stored state comes back up and is

321
00:10:18,160 --> 00:10:23,519
hydrated and put into the grain again

322
00:10:20,399 --> 00:10:24,720
so um arlene's has a ets back or ellen

323
00:10:23,519 --> 00:10:27,120
turn storage

324
00:10:24,720 --> 00:10:28,079
back provider which does it for you it's

325
00:10:27,120 --> 00:10:29,519
out of the box

326
00:10:28,079 --> 00:10:31,680
available you can use that or you can

327
00:10:29,519 --> 00:10:33,760
choose not to use that

328
00:10:31,680 --> 00:10:35,120
and obviously grains are implemented in

329
00:10:33,760 --> 00:10:35,680
a way that you implement callback

330
00:10:35,120 --> 00:10:39,279
modules

331
00:10:35,680 --> 00:10:39,279
so it's very similar to gen server

332
00:10:39,680 --> 00:10:45,760
so yeah and last thing

333
00:10:42,959 --> 00:10:46,000
if you don't want to use earliest but

334
00:10:45,760 --> 00:10:47,519
you

335
00:10:46,000 --> 00:10:49,200
have a similar problem for example you

336
00:10:47,519 --> 00:10:50,959
already have a system in place

337
00:10:49,200 --> 00:10:52,240
running running elixir running earlier

338
00:10:50,959 --> 00:10:53,920
on that already has a lot of processes

339
00:10:52,240 --> 00:10:54,560
you just want to you know make them go

340
00:10:53,920 --> 00:10:57,920
away

341
00:10:54,560 --> 00:11:01,599
when you're done with them then you say

342
00:10:57,920 --> 00:11:04,079
state machine or more precisely use the

343
00:11:01,600 --> 00:11:05,120
bondome machine for otp the gen state

344
00:11:04,079 --> 00:11:07,920
and behavior

345
00:11:05,120 --> 00:11:08,959
genstagem is provided as part of the otp

346
00:11:07,920 --> 00:11:10,959
distribution

347
00:11:08,959 --> 00:11:12,479
and it allows you to do something like

348
00:11:10,959 --> 00:11:14,560
okay transition my

349
00:11:12,480 --> 00:11:16,399
my machine from this date into that

350
00:11:14,560 --> 00:11:18,079
state but at a time out

351
00:11:16,399 --> 00:11:20,560
invalidate the timeout if i get any

352
00:11:18,079 --> 00:11:22,959
message otherwise continue

353
00:11:20,560 --> 00:11:23,760
and this allows you to very easily build

354
00:11:22,959 --> 00:11:25,599
something

355
00:11:23,760 --> 00:11:27,360
that goes away automatically even about

356
00:11:25,600 --> 00:11:28,399
it but sticks around to process more

357
00:11:27,360 --> 00:11:31,920
events

358
00:11:28,399 --> 00:11:31,920
without having to use the framework

359
00:11:32,240 --> 00:11:36,800
yeah so i figured that it would be

360
00:11:35,120 --> 00:11:40,079
better for me to

361
00:11:36,800 --> 00:11:41,279
show you some examples using using

362
00:11:40,079 --> 00:11:43,439
earlines

363
00:11:41,279 --> 00:11:45,439
and my chosen example is this this is

364
00:11:43,440 --> 00:11:47,600
the conway's game of life

365
00:11:45,440 --> 00:11:49,600
and if you look at the game of life you

366
00:11:47,600 --> 00:11:50,720
can find some interesting things so

367
00:11:49,600 --> 00:11:54,079
basically

368
00:11:50,720 --> 00:11:57,839
it kind of resembles nature each block

369
00:11:54,079 --> 00:11:59,920
is a cell and there are rules around

370
00:11:57,839 --> 00:12:00,959
when cells become alive when cells

371
00:11:59,920 --> 00:12:03,279
become dead

372
00:12:00,959 --> 00:12:04,479
and when cells remain alive or remain

373
00:12:03,279 --> 00:12:07,200
dead

374
00:12:04,480 --> 00:12:08,880
so obviously the implementation here is

375
00:12:07,200 --> 00:12:11,920
not okay so each

376
00:12:08,880 --> 00:12:14,720
each cell is a grain

377
00:12:11,920 --> 00:12:15,360
and the grains either talk with each

378
00:12:14,720 --> 00:12:17,839
other

379
00:12:15,360 --> 00:12:19,519
so each one talks with each its neighbor

380
00:12:17,839 --> 00:12:20,720
to find out whether it should die or it

381
00:12:19,519 --> 00:12:23,040
should become alive

382
00:12:20,720 --> 00:12:24,639
or alternatively each grain can query a

383
00:12:23,040 --> 00:12:26,319
database

384
00:12:24,639 --> 00:12:28,560
and the database contains state as to

385
00:12:26,320 --> 00:12:31,040
whether grains should be alive or dead

386
00:12:28,560 --> 00:12:32,800
and you start with a randomized state

387
00:12:31,040 --> 00:12:35,439
and you end up with something like this

388
00:12:32,800 --> 00:12:36,800
so this is just a video but i have some

389
00:12:35,440 --> 00:12:40,240
live versions here

390
00:12:36,800 --> 00:12:42,560
i think so

391
00:12:40,240 --> 00:12:42,560
um

392
00:12:44,000 --> 00:12:48,240
okay so i'm just going to start an

393
00:12:46,480 --> 00:12:52,320
interactive elixir

394
00:12:48,240 --> 00:12:54,079
console here and this version contains

395
00:12:52,320 --> 00:12:56,880
the version where greens ask each other

396
00:12:54,079 --> 00:12:56,880
about what's going on

397
00:12:59,839 --> 00:13:02,160
so

398
00:13:04,079 --> 00:13:08,959
so i put in some kind of helper function

399
00:13:10,560 --> 00:13:17,839
so it's easier to easier to try

400
00:13:14,639 --> 00:13:19,600
okay so i'll explain

401
00:13:17,839 --> 00:13:22,240
what all you have just seen basically

402
00:13:19,600 --> 00:13:25,360
when i started the helper function

403
00:13:22,240 --> 00:13:27,360
what it did was okay i want to first

404
00:13:25,360 --> 00:13:28,560
find a reference to a particular grain

405
00:13:27,360 --> 00:13:30,800
or in this case

406
00:13:28,560 --> 00:13:33,279
the big rank the game grain the game

407
00:13:30,800 --> 00:13:35,199
green is in charge of creating the game

408
00:13:33,279 --> 00:13:37,519
and maintaining the game and more

409
00:13:35,200 --> 00:13:39,680
importantly making sure these sales are

410
00:13:37,519 --> 00:13:42,000
updated

411
00:13:39,680 --> 00:13:43,920
on precise ticks and not just randomly

412
00:13:42,000 --> 00:13:46,399
or just whenever they want to

413
00:13:43,920 --> 00:13:47,040
so find a game grain tell it stop it on

414
00:13:46,399 --> 00:13:48,800
yourselves

415
00:13:47,040 --> 00:13:50,480
and when you're ready because it's a

416
00:13:48,800 --> 00:13:53,680
call so the code block

417
00:13:50,480 --> 00:13:55,199
when you're ready start a timer and

418
00:13:53,680 --> 00:13:57,040
this is because although the game of

419
00:13:55,199 --> 00:13:59,920
life specifies how the cells

420
00:13:57,040 --> 00:14:00,399
will come up come alive uh become dead

421
00:13:59,920 --> 00:14:02,959
or

422
00:14:00,399 --> 00:14:04,560
remain in library remain dead it doesn't

423
00:14:02,959 --> 00:14:06,319
it doesn't do something something like

424
00:14:04,560 --> 00:14:08,319
it wouldn't specify how you should

425
00:14:06,320 --> 00:14:09,120
implement it and if you have a lot of

426
00:14:08,320 --> 00:14:10,880
sales

427
00:14:09,120 --> 00:14:13,040
and they can all make decisions that

428
00:14:10,880 --> 00:14:14,480
affect not their own states but also

429
00:14:13,040 --> 00:14:16,480
future states and states of other

430
00:14:14,480 --> 00:14:18,959
neighbors you want to make sure they

431
00:14:16,480 --> 00:14:20,000
make these decisions in an orchestrated

432
00:14:18,959 --> 00:14:22,719
manner

433
00:14:20,000 --> 00:14:24,639
so in this implementation in particular

434
00:14:22,720 --> 00:14:28,160
each cell can be told

435
00:14:24,639 --> 00:14:31,199
to tell its neighbors

436
00:14:28,160 --> 00:14:32,719
about its own state so this is this is

437
00:14:31,199 --> 00:14:33,760
the first thing that cells can be told

438
00:14:32,720 --> 00:14:35,600
about to do

439
00:14:33,760 --> 00:14:37,519
and the second thing that cells can be

440
00:14:35,600 --> 00:14:39,279
told about to do was to

441
00:14:37,519 --> 00:14:40,560
according to how many neighbors have

442
00:14:39,279 --> 00:14:43,120
told it

443
00:14:40,560 --> 00:14:43,920
that the neighbors were alive figure out

444
00:14:43,120 --> 00:14:49,120
whether it should die or

445
00:14:43,920 --> 00:14:49,120
not so this is how this version works

446
00:14:52,800 --> 00:14:57,599
yeah so let's request modules this is

447
00:14:56,160 --> 00:14:58,800
basically the callback module

448
00:14:57,600 --> 00:15:02,160
implementing

449
00:14:58,800 --> 00:15:04,639
the early screens early scoring behavior

450
00:15:02,160 --> 00:15:06,560
specify there is a provider for saving

451
00:15:04,639 --> 00:15:08,079
state the provider has a short name

452
00:15:06,560 --> 00:15:09,040
called in-memory this is configured

453
00:15:08,079 --> 00:15:10,638
elsewhere

454
00:15:09,040 --> 00:15:12,639
and the placement of the grain is

455
00:15:10,639 --> 00:15:15,120
preferably on the local host

456
00:15:12,639 --> 00:15:17,040
this is because again in in erlangs as

457
00:15:15,120 --> 00:15:18,399
as as in orleans

458
00:15:17,040 --> 00:15:21,279
the placement of the grain can be

459
00:15:18,399 --> 00:15:23,920
locally or anywhere in the cluster

460
00:15:21,279 --> 00:15:25,519
depending on also you you choose that as

461
00:15:23,920 --> 00:15:26,639
a developer but also you choose that

462
00:15:25,519 --> 00:15:27,600
depending on whether your grain should

463
00:15:26,639 --> 00:15:29,440
be stateless or not

464
00:15:27,600 --> 00:15:30,639
because in in ground design or orleans

465
00:15:29,440 --> 00:15:32,079
you cannot you can actually use

466
00:15:30,639 --> 00:15:33,600
queensland's workers

467
00:15:32,079 --> 00:15:34,800
although in elixir application you

468
00:15:33,600 --> 00:15:35,920
probably want to use gun stage or

469
00:15:34,800 --> 00:15:36,639
something like that which is higher

470
00:15:35,920 --> 00:15:40,399
level

471
00:15:36,639 --> 00:15:42,959
and closer to the spirit of elixir so

472
00:15:40,399 --> 00:15:43,839
when when the sale starts um it's got a

473
00:15:42,959 --> 00:15:46,319
game id

474
00:15:43,839 --> 00:15:48,000
and an id this id actually is basically

475
00:15:46,320 --> 00:15:50,320
the coordinate

476
00:15:48,000 --> 00:15:52,079
and there are some management functions

477
00:15:50,320 --> 00:15:53,440
but the cells can be told to prepare or

478
00:15:52,079 --> 00:15:57,519
to commit

479
00:15:53,440 --> 00:15:59,199
in preparation it counts its neighbors

480
00:15:57,519 --> 00:16:00,959
and according to the current status

481
00:15:59,199 --> 00:16:02,639
determine whether whether the upcoming

482
00:16:00,959 --> 00:16:05,359
status is alive or dead

483
00:16:02,639 --> 00:16:07,360
any commit it updates the future states

484
00:16:05,360 --> 00:16:08,000
it grabs the upcoming status put into

485
00:16:07,360 --> 00:16:11,199
current status

486
00:16:08,000 --> 00:16:13,600
and clears close upcoming status so as

487
00:16:11,199 --> 00:16:17,120
you the neighbors

488
00:16:13,600 --> 00:16:20,000
basically each cell is started with

489
00:16:17,120 --> 00:16:21,680
eight possible neighbor fields this is

490
00:16:20,000 --> 00:16:23,839
the state held by the cell

491
00:16:21,680 --> 00:16:24,880
so the game grain actually makes these

492
00:16:23,839 --> 00:16:28,079
cells

493
00:16:24,880 --> 00:16:29,759
and sets uh sets new neighbors yeah so

494
00:16:28,079 --> 00:16:31,199
so the type spec is incorrect because

495
00:16:29,759 --> 00:16:33,040
actually there are

496
00:16:31,199 --> 00:16:34,839
eight possible neighbors i just haven't

497
00:16:33,040 --> 00:16:37,839
updated ties back

498
00:16:34,839 --> 00:16:41,040
anyway in this in this version

499
00:16:37,839 --> 00:16:42,560
just basically this cell asks each

500
00:16:41,040 --> 00:16:44,240
neighboring cell

501
00:16:42,560 --> 00:16:46,959
but there is a problem with this

502
00:16:44,240 --> 00:16:49,600
implementation which is that

503
00:16:46,959 --> 00:16:50,479
the game grain can tell all the cells to

504
00:16:49,600 --> 00:16:52,160
update

505
00:16:50,480 --> 00:16:53,759
but in this case the game grain will be

506
00:16:52,160 --> 00:16:55,439
making calls to each cell

507
00:16:53,759 --> 00:16:57,360
and if again grain were to make a call

508
00:16:55,440 --> 00:16:59,120
to that cell that's still green

509
00:16:57,360 --> 00:17:00,480
then that celebrate is going to be busy

510
00:16:59,120 --> 00:17:01,519
and it wouldn't be able to answer any

511
00:17:00,480 --> 00:17:04,720
other calls

512
00:17:01,519 --> 00:17:06,000
so in this implementation the update is

513
00:17:04,720 --> 00:17:08,720
basically single spreaded

514
00:17:06,000 --> 00:17:10,000
because you cannot have one cell

515
00:17:08,720 --> 00:17:12,799
answering anything else when it's

516
00:17:10,000 --> 00:17:17,599
already answering something else

517
00:17:12,799 --> 00:17:20,000
and yeah so it's it's not very good

518
00:17:17,599 --> 00:17:21,520
alternatively and also in a in a version

519
00:17:20,000 --> 00:17:25,679
that's more closer to the

520
00:17:21,520 --> 00:17:25,679
spirit of um

521
00:17:26,240 --> 00:17:31,679
okay to the spirit of orleans

522
00:17:29,600 --> 00:17:33,439
there's another version which is also

523
00:17:31,679 --> 00:17:36,480
simpler it's got fewer

524
00:17:33,440 --> 00:17:38,720
fewer files and i shall show you this

525
00:17:36,480 --> 00:17:38,720
one

526
00:17:41,840 --> 00:17:46,159
so in this case again i first basically

527
00:17:44,480 --> 00:17:49,440
start everything up

528
00:17:46,160 --> 00:17:50,480
and it works but internally it's

529
00:17:49,440 --> 00:17:53,360
entirely different

530
00:17:50,480 --> 00:17:54,320
and i'll explain in this version when i

531
00:17:53,360 --> 00:17:56,559
start the game

532
00:17:54,320 --> 00:17:58,559
i actually make a game entity and i

533
00:17:56,559 --> 00:18:00,639
store it in in the dollar store

534
00:17:58,559 --> 00:18:01,678
then i grab the grain representing the

535
00:18:00,640 --> 00:18:04,880
game

536
00:18:01,679 --> 00:18:06,480
and i tell it uh the idea of the game is

537
00:18:04,880 --> 00:18:10,880
back into the identity and i tell it

538
00:18:06,480 --> 00:18:13,039
start and when a game grain starts

539
00:18:10,880 --> 00:18:14,320
well it just starts a timer it doesn't

540
00:18:13,039 --> 00:18:15,760
do anything else it doesn't do any kind

541
00:18:14,320 --> 00:18:16,639
of perforation why because that logic

542
00:18:15,760 --> 00:18:19,600
isn't in the cells

543
00:18:16,640 --> 00:18:20,320
but more importantly when the game grin

544
00:18:19,600 --> 00:18:23,360
wants to

545
00:18:20,320 --> 00:18:26,000
update on the timer tick

546
00:18:23,360 --> 00:18:27,600
it asynchronously calls all the grains

547
00:18:26,000 --> 00:18:30,720
at the same time

548
00:18:27,600 --> 00:18:32,480
to first prepare an incumbent uh

549
00:18:30,720 --> 00:18:35,280
and these cell grants actually do not

550
00:18:32,480 --> 00:18:38,320
call each other anymore

551
00:18:35,280 --> 00:18:39,840
instead what they do is

552
00:18:38,320 --> 00:18:41,600
when well first when we start up it

553
00:18:39,840 --> 00:18:42,240
loads blows from a database but what

554
00:18:41,600 --> 00:18:45,600
they do

555
00:18:42,240 --> 00:18:49,600
when they want to count the neighbors

556
00:18:45,600 --> 00:18:51,120
is by doing repo queries so

557
00:18:49,600 --> 00:18:52,799
i have eight possible neighbors and in

558
00:18:51,120 --> 00:18:53,678
this case um the game is actually wrong

559
00:18:52,799 --> 00:18:55,760
on the torus

560
00:18:53,679 --> 00:18:57,360
so the the tuple's edge is basically

561
00:18:55,760 --> 00:19:00,000
linked with the bottomless edge

562
00:18:57,360 --> 00:19:01,199
so there are no boundaries in this

563
00:19:00,000 --> 00:19:02,480
version

564
00:19:01,200 --> 00:19:04,559
so the game just basically looks at the

565
00:19:02,480 --> 00:19:06,799
database and determines how it should

566
00:19:04,559 --> 00:19:08,320
behave so in this case there is no more

567
00:19:06,799 --> 00:19:11,120
communication dependency between the

568
00:19:08,320 --> 00:19:13,918
cells and so you can run this program

569
00:19:11,120 --> 00:19:14,639
very very in very high parallel up

570
00:19:13,919 --> 00:19:17,679
basically

571
00:19:14,640 --> 00:19:19,760
very high levels of parallelism where um

572
00:19:17,679 --> 00:19:22,640
i think all cores available are being

573
00:19:19,760 --> 00:19:22,640
packed at the moment

574
00:19:22,840 --> 00:19:26,399
yeah yeah so all the cords are being

575
00:19:25,360 --> 00:19:28,000
used this is

576
00:19:26,400 --> 00:19:29,360
i think this is the most inefficient

577
00:19:28,000 --> 00:19:31,919
implementation of the game of life you

578
00:19:29,360 --> 00:19:31,918
will ever see

579
00:19:32,960 --> 00:19:40,080
what yeah basically like that

580
00:19:36,320 --> 00:19:42,159
so in this case it's like 20 20 30 35 30

581
00:19:40,080 --> 00:19:44,480
something like that so close to a dozen

582
00:19:42,160 --> 00:19:44,480
things

583
00:19:47,280 --> 00:19:51,600
obviously this implication this

584
00:19:49,919 --> 00:19:53,280
implementation imitates nature

585
00:19:51,600 --> 00:19:54,719
and a better implementation wouldn't

586
00:19:53,280 --> 00:19:56,320
wouldn't have done it like that it would

587
00:19:54,720 --> 00:19:58,559
a better implementation may

588
00:19:56,320 --> 00:20:00,320
have just allocated a two-dimensional

589
00:19:58,559 --> 00:20:01,918
array and just uh

590
00:20:00,320 --> 00:20:03,678
have done with a with a single function

591
00:20:01,919 --> 00:20:06,240
and the function does the thing on the

592
00:20:03,679 --> 00:20:08,320
array in iterative manner

593
00:20:06,240 --> 00:20:09,520
and that will be much faster and it will

594
00:20:08,320 --> 00:20:11,918
probably just use one

595
00:20:09,520 --> 00:20:13,200
a little fraction of available

596
00:20:11,919 --> 00:20:16,400
processing power

597
00:20:13,200 --> 00:20:18,000
but if you want to use orleans i think

598
00:20:16,400 --> 00:20:21,440
this shows you how orients

599
00:20:18,000 --> 00:20:24,799
could be used again each

600
00:20:21,440 --> 00:20:27,440
isolated process or each isolated ring

601
00:20:24,799 --> 00:20:28,320
controls its own state uh reading from

602
00:20:27,440 --> 00:20:31,280
the data store

603
00:20:28,320 --> 00:20:32,799
persisting to the data store doesn't

604
00:20:31,280 --> 00:20:34,559
really communicate with other grains too

605
00:20:32,799 --> 00:20:35,840
much especially not at the same level it

606
00:20:34,559 --> 00:20:36,720
may communicate with a parent may come

607
00:20:35,840 --> 00:20:40,000
here with a child

608
00:20:36,720 --> 00:20:41,440
but not at the same tier so as to

609
00:20:40,000 --> 00:20:45,679
work around the same work around that

610
00:20:41,440 --> 00:20:45,679
microsoft people use reentrancy to solve

611
00:20:47,120 --> 00:20:52,320
yeah so i guess there's

612
00:20:50,240 --> 00:20:54,159
there's only one last question left

613
00:20:52,320 --> 00:20:55,918
which is should you use it in your

614
00:20:54,159 --> 00:20:59,200
elixir applications

615
00:20:55,919 --> 00:21:02,159
i think it depends but uh keep in mind

616
00:20:59,200 --> 00:21:03,280
that burlings in itself provides you

617
00:21:02,159 --> 00:21:04,720
with a framework

618
00:21:03,280 --> 00:21:07,520
that you can base your application

619
00:21:04,720 --> 00:21:09,039
design upon and in any case if you're

620
00:21:07,520 --> 00:21:10,559
creating a lot of actors

621
00:21:09,039 --> 00:21:14,000
you ought to have a way to make them go

622
00:21:10,559 --> 00:21:15,280
away at the end of their useful life

623
00:21:14,000 --> 00:21:16,660
all right thank you very much any

624
00:21:15,280 --> 00:21:25,070
questions

625
00:21:16,660 --> 00:21:25,070
[Applause]

626
00:21:31,919 --> 00:21:36,080
so the question is do grains provide

627
00:21:34,080 --> 00:21:39,280
ways to asynchronously message

628
00:21:36,080 --> 00:21:42,320
each other and the answer is yes

629
00:21:39,280 --> 00:21:44,720
because grains are processes

630
00:21:42,320 --> 00:21:46,000
in erlang and elixir and processes can

631
00:21:44,720 --> 00:21:48,240
send each other messages

632
00:21:46,000 --> 00:21:49,360
the only problem is if one grain is busy

633
00:21:48,240 --> 00:21:50,799
doing one thing

634
00:21:49,360 --> 00:21:52,559
and the other green is trying to message

635
00:21:50,799 --> 00:21:54,000
it now you have two busy grades because

636
00:21:52,559 --> 00:21:55,678
the second one

637
00:21:54,000 --> 00:21:58,000
cannot get a response until the first

638
00:21:55,679 --> 00:22:00,240
first one becomes free

639
00:21:58,000 --> 00:22:01,520
so this is why in the dynamic

640
00:22:00,240 --> 00:22:04,159
implementation of orleans

641
00:22:01,520 --> 00:22:06,240
there is reentrancy so you can call the

642
00:22:04,159 --> 00:22:06,720
grain again and the scheduler does its

643
00:22:06,240 --> 00:22:09,760
magic

644
00:22:06,720 --> 00:22:10,880
for you but in this case i think

645
00:22:09,760 --> 00:22:12,960
i think there might be a very

646
00:22:10,880 --> 00:22:14,880
complicated way of doing it which is for

647
00:22:12,960 --> 00:22:16,400
example you don't use code anymore

648
00:22:14,880 --> 00:22:18,159
everything is cast

649
00:22:16,400 --> 00:22:19,760
so this screen sends a message

650
00:22:18,159 --> 00:22:20,960
asynchronously to another green without

651
00:22:19,760 --> 00:22:23,760
waiting for a reply

652
00:22:20,960 --> 00:22:26,159
and then carries on something like that

653
00:22:23,760 --> 00:22:29,520
and if you move everything to costs

654
00:22:26,159 --> 00:22:32,480
only then yeah it's doable

655
00:22:29,520 --> 00:22:34,000
or you can redesign your architecture so

656
00:22:32,480 --> 00:22:36,640
there is no need for such kinds of

657
00:22:34,000 --> 00:22:36,640
communication

658
00:22:52,720 --> 00:22:55,120
function

659
00:23:00,480 --> 00:23:06,880
what the last pg and parties and

660
00:23:04,000 --> 00:23:06,880
libraries offered

661
00:23:07,039 --> 00:23:11,280
so how do you handle if for example i

662
00:23:09,840 --> 00:23:13,760
want to add a node

663
00:23:11,280 --> 00:23:14,799
to the cluster that's not known

664
00:23:13,760 --> 00:23:16,640
beforehand

665
00:23:14,799 --> 00:23:18,639
that is an airline level service

666
00:23:16,640 --> 00:23:21,600
discovery question

667
00:23:18,640 --> 00:23:23,440
it's a no discovery question and i am

668
00:23:21,600 --> 00:23:25,360
not too familiar with los pg to answer

669
00:23:23,440 --> 00:23:26,640
whether when there's a new node added to

670
00:23:25,360 --> 00:23:28,479
the cluster whether it picks up that

671
00:23:26,640 --> 00:23:30,720
node automatically but i think it does

672
00:23:28,480 --> 00:23:32,720
so last pg according to documentation

673
00:23:30,720 --> 00:23:33,840
uses either is in-house uh distribution

674
00:23:32,720 --> 00:23:36,320
algo or it uses

675
00:23:33,840 --> 00:23:37,840
or falls back to airline distribution

676
00:23:36,320 --> 00:23:38,480
and if you add a node to iron

677
00:23:37,840 --> 00:23:40,559
distribution

678
00:23:38,480 --> 00:23:41,840
obviously not that node is there so

679
00:23:40,559 --> 00:23:43,200
related to that there is a question of

680
00:23:41,840 --> 00:23:45,039
low balancing which is

681
00:23:43,200 --> 00:23:47,039
if i have a lot of grains running on in

682
00:23:45,039 --> 00:23:48,799
one silo and i add another xylo

683
00:23:47,039 --> 00:23:50,720
this side will automatically take over

684
00:23:48,799 --> 00:23:54,000
50 of the grains

685
00:23:50,720 --> 00:23:57,840
i think the answer is no it doesn't

686
00:23:54,000 --> 00:24:00,000
um however if you use a similar

687
00:23:57,840 --> 00:24:00,959
library called swarm written by bit

688
00:24:00,000 --> 00:24:04,240
walker

689
00:24:00,960 --> 00:24:05,760
swarm does do that so swarm moves the

690
00:24:04,240 --> 00:24:08,400
processes around

691
00:24:05,760 --> 00:24:09,360
based on available resources and based

692
00:24:08,400 --> 00:24:11,679
on available hosts

693
00:24:09,360 --> 00:24:13,199
so so so if you spin up another host i

694
00:24:11,679 --> 00:24:14,080
think it does it does move to our city

695
00:24:13,200 --> 00:24:16,559
for you

696
00:24:14,080 --> 00:24:18,080
but if you were to try and implement

697
00:24:16,559 --> 00:24:19,760
your system in a way that load is

698
00:24:18,080 --> 00:24:21,760
automatically balanced

699
00:24:19,760 --> 00:24:23,279
then the best way would possibly be to

700
00:24:21,760 --> 00:24:23,840
make sure you don't have long running

701
00:24:23,279 --> 00:24:27,360
grains

702
00:24:23,840 --> 00:24:28,959
so grains work and they return to idle

703
00:24:27,360 --> 00:24:30,639
and when they return idle they will

704
00:24:28,960 --> 00:24:33,279
eventually be recycled

705
00:24:30,640 --> 00:24:33,679
so they don't they don't already exist

706
00:24:33,279 --> 00:24:36,720
so

707
00:24:33,679 --> 00:24:37,919
when that ring is needed at a later time

708
00:24:36,720 --> 00:24:40,559
it will just be spun up

709
00:24:37,919 --> 00:24:40,559
anywhere else

710
00:24:44,840 --> 00:24:48,240
yes

711
00:24:46,559 --> 00:24:49,918
so question is this distributed around

712
00:24:48,240 --> 00:24:51,919
only the answer is

713
00:24:49,919 --> 00:24:53,520
no i wrote it on a single note and it

714
00:24:51,919 --> 00:24:55,520
ran on a single note

715
00:24:53,520 --> 00:24:56,960
i mean can you get it to run two notes

716
00:24:55,520 --> 00:24:58,158
without this

717
00:24:56,960 --> 00:24:59,440
can you run it on two notes whether

718
00:24:58,159 --> 00:25:00,080
distributed earlier the answer is yes or

719
00:24:59,440 --> 00:25:01,520
no

720
00:25:00,080 --> 00:25:03,279
if you have two nulls and they don't

721
00:25:01,520 --> 00:25:04,480
communicate with each other then you

722
00:25:03,279 --> 00:25:06,320
cannot have the grains

723
00:25:04,480 --> 00:25:08,080
running on one fell over to spill over

724
00:25:06,320 --> 00:25:11,439
to another one

725
00:25:08,080 --> 00:25:13,120
so it wouldn't make sense um if you're

726
00:25:11,440 --> 00:25:14,640
asking whether beyond distributed or

727
00:25:13,120 --> 00:25:15,918
long can you use another technology to

728
00:25:14,640 --> 00:25:17,279
achieve the same function so you have

729
00:25:15,919 --> 00:25:19,200
grains that are linked but you don't use

730
00:25:17,279 --> 00:25:22,640
distributed erlang the answer is yes

731
00:25:19,200 --> 00:25:26,080
you can so lost pg itself supports using

732
00:25:22,640 --> 00:25:26,080
something other than distributed erlang

733
00:25:26,240 --> 00:25:29,840
does that answer the question

734
00:25:31,600 --> 00:25:34,158
anything else

735
00:25:35,679 --> 00:25:39,279
well if there are no further questions

736
00:25:38,080 --> 00:25:43,840
then thank you very much

737
00:25:39,279 --> 00:25:43,840
for coming today

738
00:25:44,900 --> 00:25:48,769
[Applause]

