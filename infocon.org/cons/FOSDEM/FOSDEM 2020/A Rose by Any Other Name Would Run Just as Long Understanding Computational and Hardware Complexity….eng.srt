1
00:00:05,600 --> 00:00:09,280
awesome

2
00:00:06,799 --> 00:00:10,719
uh so it turns out names don't really

3
00:00:09,280 --> 00:00:12,879
matter um because i changed the name of

4
00:00:10,719 --> 00:00:14,959
the talk

5
00:00:12,880 --> 00:00:16,480
so so dog by any other name the original

6
00:00:14,960 --> 00:00:18,160
name was a you know rose by any other

7
00:00:16,480 --> 00:00:19,039
name so shakespeare right names don't

8
00:00:18,160 --> 00:00:20,400
really matter

9
00:00:19,039 --> 00:00:21,760
um and then i realized this was putting

10
00:00:20,400 --> 00:00:23,359
the talk together that i had a really

11
00:00:21,760 --> 00:00:25,840
cool metaphor about dogs

12
00:00:23,359 --> 00:00:26,640
so i changed the name um the real

13
00:00:25,840 --> 00:00:28,080
punchline is

14
00:00:26,640 --> 00:00:29,519
sort of understanding computational

15
00:00:28,080 --> 00:00:30,479
hardware complexity and software defined

16
00:00:29,519 --> 00:00:32,879
radio

17
00:00:30,480 --> 00:00:34,079
marcus sort of give us a wonderful

18
00:00:32,880 --> 00:00:35,760
wonderful end of the perspective from

19
00:00:34,079 --> 00:00:37,600
the cpu side which is sort of this is

20
00:00:35,760 --> 00:00:39,440
what we're seeing in terms of scheduling

21
00:00:37,600 --> 00:00:41,120
um and hopefully i'll kind of pitch in

22
00:00:39,440 --> 00:00:43,360
and provide a complimentary view

23
00:00:41,120 --> 00:00:44,160
um unfortunately it's not going to be as

24
00:00:43,360 --> 00:00:46,719
sort of

25
00:00:44,160 --> 00:00:49,199
technical and sort of advanced but the

26
00:00:46,719 --> 00:00:50,960
the basic idea is that if you are new

27
00:00:49,200 --> 00:00:52,960
to sdr or you are new to putting things

28
00:00:50,960 --> 00:00:54,160
on fpgas what are the things that go

29
00:00:52,960 --> 00:00:56,079
awry

30
00:00:54,160 --> 00:00:57,519
why isn't this working or if you've had

31
00:00:56,079 --> 00:01:00,239
experience with an fpga

32
00:00:57,520 --> 00:01:03,280
and felt really bad afterwards maybe i

33
00:01:00,239 --> 00:01:03,279
could tell you what happened

34
00:01:04,000 --> 00:01:08,799
um and so my primary thesis that kind of

35
00:01:07,280 --> 00:01:10,320
underlies almost everything i do

36
00:01:08,799 --> 00:01:12,159
is that algorithms change to suit the

37
00:01:10,320 --> 00:01:14,639
hardware context

38
00:01:12,159 --> 00:01:15,439
and in part i'm an evangelist i am here

39
00:01:14,640 --> 00:01:17,360
to tell you this

40
00:01:15,439 --> 00:01:18,880
and convince you and give you some of my

41
00:01:17,360 --> 00:01:20,560
religion that

42
00:01:18,880 --> 00:01:23,679
you can't just take the stuff that works

43
00:01:20,560 --> 00:01:26,240
on cpu and run it on an fpga

44
00:01:23,680 --> 00:01:27,520
that's not how this works hopefully by

45
00:01:26,240 --> 00:01:29,600
the end you'll agree with me

46
00:01:27,520 --> 00:01:31,280
um if not at least there'll be a tiny

47
00:01:29,600 --> 00:01:32,960
little voice in that in the backyard so

48
00:01:31,280 --> 00:01:34,640
who am i to say this though right like

49
00:01:32,960 --> 00:01:37,439
i'm just a guy who wandered in

50
00:01:34,640 --> 00:01:38,640
an hour ago right so i'm i'm a digital

51
00:01:37,439 --> 00:01:41,679
hardware engineer right

52
00:01:38,640 --> 00:01:43,600
so i've contributed to chips at public

53
00:01:41,680 --> 00:01:45,840
trade companies right big chips

54
00:01:43,600 --> 00:01:46,880
so those were titaniums and eight core

55
00:01:45,840 --> 00:01:49,360
xeon

56
00:01:46,880 --> 00:01:51,280
um intel's really cool gpu that never

57
00:01:49,360 --> 00:01:54,479
really took off

58
00:01:51,280 --> 00:01:56,159
um you know an actual gpu later um and

59
00:01:54,479 --> 00:01:57,679
then i tape out my own chips to examine

60
00:01:56,159 --> 00:01:59,280
radiation effects right so

61
00:01:57,680 --> 00:02:00,880
you know i'm kind of all consumed with

62
00:01:59,280 --> 00:02:02,880
how things work back

63
00:02:00,880 --> 00:02:04,399
long ago before i did all this i started

64
00:02:02,880 --> 00:02:05,600
out with hardware software co-design so

65
00:02:04,399 --> 00:02:06,159
one of the challenges somebody gave me

66
00:02:05,600 --> 00:02:07,919
was

67
00:02:06,159 --> 00:02:09,920
if we wanted to take a gpu and have it

68
00:02:07,920 --> 00:02:11,680
render movies like pixar does

69
00:02:09,919 --> 00:02:13,519
how do we do that the answer is very

70
00:02:11,680 --> 00:02:14,480
small triangles and it involves changing

71
00:02:13,520 --> 00:02:16,480
all of the hardware

72
00:02:14,480 --> 00:02:19,599
and not doing it any any other way that

73
00:02:16,480 --> 00:02:19,599
the pixar people did it

74
00:02:20,319 --> 00:02:25,679
um so i ended up moving on from that to

75
00:02:23,360 --> 00:02:27,599
domain-specific languages to rtl for

76
00:02:25,680 --> 00:02:28,959
image processing right so how do i take

77
00:02:27,599 --> 00:02:31,040
high-level descriptions of an image

78
00:02:28,959 --> 00:02:31,680
processing application and turn it into

79
00:02:31,040 --> 00:02:33,040
hardware

80
00:02:31,680 --> 00:02:34,800
and so i spent a lot of time thinking

81
00:02:33,040 --> 00:02:36,560
about abstractions how to make this good

82
00:02:34,800 --> 00:02:38,560
and everything sort of ends up being

83
00:02:36,560 --> 00:02:39,760
line buffers and local buffers

84
00:02:38,560 --> 00:02:41,040
and then there's things that don't fit

85
00:02:39,760 --> 00:02:41,599
in this format and then those are bad

86
00:02:41,040 --> 00:02:44,879
ideas

87
00:02:41,599 --> 00:02:45,359
is this sort of the the general rule of

88
00:02:44,879 --> 00:02:46,879
thumb

89
00:02:45,360 --> 00:02:48,480
and anytime somebody goes but i want

90
00:02:46,879 --> 00:02:51,518
something else i go

91
00:02:48,480 --> 00:02:53,119
great but you need to pay for it um and

92
00:02:51,519 --> 00:02:55,120
so we we wrote this up

93
00:02:53,120 --> 00:02:56,720
so this was actually my thesis um we had

94
00:02:55,120 --> 00:02:58,159
a publication at siggraph sort of

95
00:02:56,720 --> 00:03:00,000
describing the abstraction

96
00:02:58,159 --> 00:03:01,280
and then the much better version of this

97
00:03:00,000 --> 00:03:03,680
is called halide

98
00:03:01,280 --> 00:03:04,319
um that actually does have all this

99
00:03:03,680 --> 00:03:05,760
implemented

100
00:03:04,319 --> 00:03:07,359
sort of we talked to those guys as was

101
00:03:05,760 --> 00:03:09,200
doing this work and then they made it

102
00:03:07,360 --> 00:03:10,560
real and made it free and open source

103
00:03:09,200 --> 00:03:12,000
and so i'd encourage you to look at that

104
00:03:10,560 --> 00:03:12,959
one of the their solutions to the

105
00:03:12,000 --> 00:03:14,879
scheduling problem

106
00:03:12,959 --> 00:03:16,239
is to actually let the user directly

107
00:03:14,879 --> 00:03:17,518
describe the schedule

108
00:03:16,239 --> 00:03:18,720
and so they've sort of thrown their

109
00:03:17,519 --> 00:03:20,400
heads up and said well it's not my

110
00:03:18,720 --> 00:03:23,200
problem my job is just to implement what

111
00:03:20,400 --> 00:03:23,200
you tell me to implement

112
00:03:23,599 --> 00:03:28,159
um so as a part of that my thesis work

113
00:03:25,920 --> 00:03:31,119
we were constantly demoing things to

114
00:03:28,159 --> 00:03:32,319
darpa on fpgas and wouldn't you know two

115
00:03:31,120 --> 00:03:35,280
weeks before the demo

116
00:03:32,319 --> 00:03:38,159
it would be dog slow and i'd be super

117
00:03:35,280 --> 00:03:39,840
sad because that wasn't my job

118
00:03:38,159 --> 00:03:42,640
i was doing the asic stuff somebody else

119
00:03:39,840 --> 00:03:44,480
was in charge of the fpga stuff

120
00:03:42,640 --> 00:03:46,000
but i'm the one who looks silly in front

121
00:03:44,480 --> 00:03:47,200
of darpa so

122
00:03:46,000 --> 00:03:49,040
we spent a lot of time reading through

123
00:03:47,200 --> 00:03:50,640
the manuals to figure out why is it slow

124
00:03:49,040 --> 00:03:51,920
and it turned out in most cases it's

125
00:03:50,640 --> 00:03:53,359
because we just didn't understand how

126
00:03:51,920 --> 00:03:54,879
the primitives worked

127
00:03:53,360 --> 00:03:56,400
um we we had some fundamental

128
00:03:54,879 --> 00:03:57,518
misconceptions and so some of this is

129
00:03:56,400 --> 00:03:59,200
this

130
00:03:57,519 --> 00:04:01,519
and so that work has also been open

131
00:03:59,200 --> 00:04:02,640
sourced um jing poo did that halide to

132
00:04:01,519 --> 00:04:04,239
hls flow

133
00:04:02,640 --> 00:04:05,760
um and he has a wonderful paper

134
00:04:04,239 --> 00:04:08,319
exploring some for

135
00:04:05,760 --> 00:04:09,679
excuse me further topics in that area um

136
00:04:08,319 --> 00:04:11,119
so currently we're working on

137
00:04:09,680 --> 00:04:12,720
this general problem that's actually how

138
00:04:11,120 --> 00:04:14,319
we got interested in gnu radio

139
00:04:12,720 --> 00:04:16,238
is it's sort of this wonderful set of

140
00:04:14,319 --> 00:04:18,079
applications and wonderful abstractions

141
00:04:16,238 --> 00:04:19,918
to sort of look at what's going on so

142
00:04:18,079 --> 00:04:21,840
given a set of code written by domain

143
00:04:19,918 --> 00:04:23,599
experts can you identify kernels

144
00:04:21,839 --> 00:04:25,919
procedurally label those kernels in some

145
00:04:23,600 --> 00:04:27,120
format discover the taxonomy kernels and

146
00:04:25,919 --> 00:04:28,719
predict an arbitrage

147
00:04:27,120 --> 00:04:30,320
you know this might be the the solution

148
00:04:28,720 --> 00:04:31,759
to somebody gave me a new radio block

149
00:04:30,320 --> 00:04:32,719
that is the entire processing

150
00:04:31,759 --> 00:04:34,560
application

151
00:04:32,720 --> 00:04:36,639
in one block right how would i break it

152
00:04:34,560 --> 00:04:41,280
into little blocks

153
00:04:36,639 --> 00:04:42,960
um you know and maybe produce fpga code

154
00:04:41,280 --> 00:04:44,479
um so we're currently focusing on

155
00:04:42,960 --> 00:04:45,919
discovering kernels in the code so the

156
00:04:44,479 --> 00:04:46,960
big problem is if you look at a static

157
00:04:45,919 --> 00:04:48,639
trace of code

158
00:04:46,960 --> 00:04:50,400
you have no idea what it does what you

159
00:04:48,639 --> 00:04:52,479
see is little colored blocks that are

160
00:04:50,400 --> 00:04:54,159
incomprehensible assembly if you went

161
00:04:52,479 --> 00:04:55,520
back and relearned asm

162
00:04:54,160 --> 00:04:56,800
you you might eventually be able to

163
00:04:55,520 --> 00:04:58,080
piece it together but for all i'm

164
00:04:56,800 --> 00:04:59,440
concerned it's just little pieces of the

165
00:04:58,080 --> 00:05:03,039
rainbow

166
00:04:59,440 --> 00:05:04,000
so you run it and then you get little

167
00:05:03,039 --> 00:05:05,520
pieces of the rainbow

168
00:05:04,000 --> 00:05:07,600
smeared all over the place right you see

169
00:05:05,520 --> 00:05:09,520
your basic blocks executed in time

170
00:05:07,600 --> 00:05:11,680
and eventually from that you can figure

171
00:05:09,520 --> 00:05:13,280
out how they cluster and what the data

172
00:05:11,680 --> 00:05:15,440
flow is and so this is sort of the

173
00:05:13,280 --> 00:05:16,719
you know the five second pitch for some

174
00:05:15,440 --> 00:05:17,759
ongoing work that we've had that we've

175
00:05:16,720 --> 00:05:19,199
open sourced on

176
00:05:17,759 --> 00:05:21,039
you know how do you do this tracing and

177
00:05:19,199 --> 00:05:22,400
how do you isolate the kernels together

178
00:05:21,039 --> 00:05:24,320
so we have code ocean with some of our

179
00:05:22,400 --> 00:05:25,840
data set for that and uh

180
00:05:24,320 --> 00:05:27,280
the the actual stuff and we have a

181
00:05:25,840 --> 00:05:28,479
pre-print if you want to find out all

182
00:05:27,280 --> 00:05:30,159
the cool details

183
00:05:28,479 --> 00:05:32,240
about what's going on um but we view

184
00:05:30,160 --> 00:05:33,919
this as sort of you know procedural way

185
00:05:32,240 --> 00:05:35,600
to kind of discover the things that that

186
00:05:33,919 --> 00:05:39,039
i'm about to talk about

187
00:05:35,600 --> 00:05:41,520
so on to the metaphor fpgas are like

188
00:05:39,039 --> 00:05:41,520
puppies

189
00:05:42,320 --> 00:05:50,080
puppies are really cute you see a puppy

190
00:05:45,360 --> 00:05:50,080
and you want a puppy right

191
00:05:51,039 --> 00:05:58,639
it is it and cats definitely cats too

192
00:05:55,759 --> 00:06:00,000
right hey and you you look at them and

193
00:05:58,639 --> 00:06:02,800
you go i gotta have this i gotta have

194
00:06:00,000 --> 00:06:04,960
this in my system and so why

195
00:06:02,800 --> 00:06:06,880
why do you guys think this about fpgas

196
00:06:04,960 --> 00:06:08,479
well so what i did was i went back

197
00:06:06,880 --> 00:06:09,759
you know maybe for the past 15 years

198
00:06:08,479 --> 00:06:12,479
looked at all a lot of the published

199
00:06:09,759 --> 00:06:14,160
numbers for different things

200
00:06:12,479 --> 00:06:16,080
and it turns out that in general you

201
00:06:14,160 --> 00:06:16,720
know bottom left here is the good part

202
00:06:16,080 --> 00:06:20,880
bottom is

203
00:06:16,720 --> 00:06:21,759
area left is energy you know fpgas are

204
00:06:20,880 --> 00:06:25,520
in general

205
00:06:21,759 --> 00:06:27,919
you know get 25x better than processors

206
00:06:25,520 --> 00:06:29,039
they're not better than asics but you

207
00:06:27,919 --> 00:06:31,198
don't want nasik

208
00:06:29,039 --> 00:06:32,400
because an asic does one thing you want

209
00:06:31,199 --> 00:06:35,280
something programmable

210
00:06:32,400 --> 00:06:36,479
and your choices seem to be dsps and

211
00:06:35,280 --> 00:06:37,919
fpgas

212
00:06:36,479 --> 00:06:40,560
we could give a whole other talk about

213
00:06:37,919 --> 00:06:43,758
dsps but fpgas seem a little bit more

214
00:06:40,560 --> 00:06:43,759
reasonable for the time slot

215
00:06:43,840 --> 00:06:48,239
so you get about 25x and that's just if

216
00:06:46,720 --> 00:06:49,520
you're putting them on equal footing and

217
00:06:48,240 --> 00:06:50,400
all the systems that you're going to

218
00:06:49,520 --> 00:06:52,000
deal with

219
00:06:50,400 --> 00:06:53,919
they've disproportionately allocated

220
00:06:52,000 --> 00:06:55,599
resources to the fpga

221
00:06:53,919 --> 00:06:57,198
so they've given the processor one watt

222
00:06:55,599 --> 00:07:00,719
and they've given the fpga

223
00:06:57,199 --> 00:07:01,520
10 watts so take that 25x or sorry that

224
00:07:00,720 --> 00:07:04,160
40x

225
00:07:01,520 --> 00:07:04,799
and now you have 400x so you should be

226
00:07:04,160 --> 00:07:06,080
expecting

227
00:07:04,800 --> 00:07:07,120
two to three orders of magnitude

228
00:07:06,080 --> 00:07:08,639
improvement when you go to run your

229
00:07:07,120 --> 00:07:11,440
applications

230
00:07:08,639 --> 00:07:13,280
but often as we're just hearing that

231
00:07:11,440 --> 00:07:14,560
just doesn't happen

232
00:07:13,280 --> 00:07:16,159
um the other thing is that people are

233
00:07:14,560 --> 00:07:17,360
selling really cool toys so this is a

234
00:07:16,160 --> 00:07:19,360
lime sdr

235
00:07:17,360 --> 00:07:21,680
um right i thought it was just a pretty

236
00:07:19,360 --> 00:07:21,680
board

237
00:07:22,240 --> 00:07:25,280
they're neat you know as an electrical

238
00:07:23,759 --> 00:07:28,319
engineer i love things with little black

239
00:07:25,280 --> 00:07:32,880
boxes and solder all over it

240
00:07:28,319 --> 00:07:35,919
um so the problem is you go by your fpga

241
00:07:32,880 --> 00:07:35,919
now you have a puppy

242
00:07:36,000 --> 00:07:39,360
right and now you're sort of addressed

243
00:07:38,400 --> 00:07:41,919
with the reality

244
00:07:39,360 --> 00:07:42,880
that you know you gotta feed and take

245
00:07:41,919 --> 00:07:44,799
care of this thing

246
00:07:42,880 --> 00:07:45,919
right it's not all cool pictures with

247
00:07:44,800 --> 00:07:48,560
matching hoodies

248
00:07:45,919 --> 00:07:50,159
right you need uh and so these are

249
00:07:48,560 --> 00:07:51,840
roughly what your system pitfalls are

250
00:07:50,160 --> 00:07:53,599
right um there's a whole architecture

251
00:07:51,840 --> 00:07:55,359
metaphor about the feed and care of your

252
00:07:53,599 --> 00:07:57,039
accelerators you know and that's sort of

253
00:07:55,360 --> 00:07:59,039
here too

254
00:07:57,039 --> 00:08:00,400
um the other problem is you need to

255
00:07:59,039 --> 00:08:02,878
figure out how to work with this animal

256
00:08:00,400 --> 00:08:04,799
right and so it turns out that dogs do

257
00:08:02,879 --> 00:08:07,360
not like to be yelled at

258
00:08:04,800 --> 00:08:10,160
that if you just keep yelling roll over

259
00:08:07,360 --> 00:08:12,160
they will never roll over

260
00:08:10,160 --> 00:08:13,360
so the way that you teach dogs to do

261
00:08:12,160 --> 00:08:16,479
things is you sort of

262
00:08:13,360 --> 00:08:18,160
work through small atoms of a trick so a

263
00:08:16,479 --> 00:08:20,479
rollover is like six

264
00:08:18,160 --> 00:08:21,759
six steps that you have to teach a dog

265
00:08:20,479 --> 00:08:23,680
and if you work through those six things

266
00:08:21,759 --> 00:08:25,440
get them to sequence it they can do it

267
00:08:23,680 --> 00:08:27,599
fpga design is sort of the same way once

268
00:08:25,440 --> 00:08:30,000
you learn what the atoms of the fp

269
00:08:27,599 --> 00:08:31,280
fpga are you're fine and after that you

270
00:08:30,000 --> 00:08:32,399
can model what's going to happen with

271
00:08:31,280 --> 00:08:33,919
your accelerators

272
00:08:32,399 --> 00:08:35,679
by just sort of putting those atoms

273
00:08:33,919 --> 00:08:36,880
together and it turns out that fpga

274
00:08:35,679 --> 00:08:40,159
doesn't have that many

275
00:08:36,880 --> 00:08:42,799
so it's not too awful to learn

276
00:08:40,159 --> 00:08:44,080
so what are the system pitfalls so we're

277
00:08:42,799 --> 00:08:45,199
going to start really basic and some of

278
00:08:44,080 --> 00:08:47,440
you are just going to are

279
00:08:45,200 --> 00:08:48,640
going to groan but you really need to

280
00:08:47,440 --> 00:08:51,200
understand what your application's

281
00:08:48,640 --> 00:08:52,720
composition is

282
00:08:51,200 --> 00:08:54,240
so you have an application right we have

283
00:08:52,720 --> 00:08:55,040
a bunch of red stuff happening and a

284
00:08:54,240 --> 00:08:56,800
purple

285
00:08:55,040 --> 00:08:59,360
you decide the purple's really cool and

286
00:08:56,800 --> 00:09:02,319
that's the thing you sped up

287
00:08:59,360 --> 00:09:02,320
and it didn't matter

288
00:09:03,519 --> 00:09:06,720
you got a little bit but it's

289
00:09:05,040 --> 00:09:07,760
underwhelming right i was just talking

290
00:09:06,720 --> 00:09:10,880
about 400x

291
00:09:07,760 --> 00:09:11,519
where's my 400x right this this just

292
00:09:10,880 --> 00:09:13,839
didn't happen

293
00:09:11,519 --> 00:09:14,880
so you need to optimize the things that

294
00:09:13,839 --> 00:09:17,680
matter right so

295
00:09:14,880 --> 00:09:18,480
take all the red things and speed those

296
00:09:17,680 --> 00:09:21,519
up

297
00:09:18,480 --> 00:09:22,000
on the fpga and then life is better so

298
00:09:21,519 --> 00:09:24,560
if you don't

299
00:09:22,000 --> 00:09:26,160
actually know what's in your application

300
00:09:24,560 --> 00:09:27,680
mapping it to an fpga is going to be

301
00:09:26,160 --> 00:09:29,360
very very hard it's not going to be a

302
00:09:27,680 --> 00:09:31,040
straight code dump sort of thing

303
00:09:29,360 --> 00:09:33,120
so for most folks this is kind of

304
00:09:31,040 --> 00:09:34,560
obvious but it bears saying

305
00:09:33,120 --> 00:09:36,640
the sort of interesting thing here

306
00:09:34,560 --> 00:09:40,079
though is that if you were hoping for

307
00:09:36,640 --> 00:09:43,040
you know at least 40x you have to map 98

308
00:09:40,080 --> 00:09:44,560
of your runtime at minimum to get it if

309
00:09:43,040 --> 00:09:46,480
the accelerator is running infinitely

310
00:09:44,560 --> 00:09:47,760
fast if you're not paying any latencies

311
00:09:46,480 --> 00:09:51,440
and if you're not dealing with any

312
00:09:47,760 --> 00:09:52,800
overheads 98 percent is a lot

313
00:09:51,440 --> 00:09:54,480
right so in a real application you

314
00:09:52,800 --> 00:09:57,439
should be looking at like three nines

315
00:09:54,480 --> 00:09:58,800
of your runtime these maps so nothing

316
00:09:57,440 --> 00:10:02,240
running on the cpu

317
00:09:58,800 --> 00:10:02,240
everything running on the fpga

318
00:10:02,720 --> 00:10:06,000
um so first understand your sources of

319
00:10:05,200 --> 00:10:08,720
latency

320
00:10:06,000 --> 00:10:10,399
your source of latency is that these are

321
00:10:08,720 --> 00:10:12,160
very complicated things

322
00:10:10,399 --> 00:10:13,279
there's tons of wires everywhere tons of

323
00:10:12,160 --> 00:10:14,079
channels and all the channels have

324
00:10:13,279 --> 00:10:16,000
latency

325
00:10:14,079 --> 00:10:18,319
so this is from the zinc ultra scale

326
00:10:16,000 --> 00:10:20,160
plus spec

327
00:10:18,320 --> 00:10:21,440
don't worry about what's in it the real

328
00:10:20,160 --> 00:10:22,880
point is that this is an atrocious

329
00:10:21,440 --> 00:10:24,079
figure to try and figure out what what

330
00:10:22,880 --> 00:10:25,760
is going on

331
00:10:24,079 --> 00:10:27,199
when your processor is communicating

332
00:10:25,760 --> 00:10:29,040
with your programmable logic

333
00:10:27,200 --> 00:10:31,120
it's even worse if you're using one of

334
00:10:29,040 --> 00:10:32,240
the usb ones because you are going

335
00:10:31,120 --> 00:10:34,000
through the back plane of your

336
00:10:32,240 --> 00:10:34,880
motherboard through the usb controller

337
00:10:34,000 --> 00:10:38,720
through the usb

338
00:10:34,880 --> 00:10:41,839
and it's just totally gross and awful um

339
00:10:38,720 --> 00:10:44,720
oops that's not mine this one's mine

340
00:10:41,839 --> 00:10:47,680
so for context right we go back to our

341
00:10:44,720 --> 00:10:50,000
thing that was totally awesome

342
00:10:47,680 --> 00:10:51,760
and now we added latency right so you

343
00:10:50,000 --> 00:10:53,279
guys are comms people right

344
00:10:51,760 --> 00:10:55,040
you should have noticed that all of my

345
00:10:53,279 --> 00:10:58,000
communication lines were horizontal

346
00:10:55,040 --> 00:11:00,399
i was committing a sin right there's no

347
00:10:58,000 --> 00:11:02,399
free communication

348
00:11:00,399 --> 00:11:04,000
so all of a sudden i am now approaching

349
00:11:02,399 --> 00:11:05,680
the original speed that i had even

350
00:11:04,000 --> 00:11:09,440
though i'm totally sped up

351
00:11:05,680 --> 00:11:09,839
so you know where does this all come

352
00:11:09,440 --> 00:11:11,519
from

353
00:11:09,839 --> 00:11:12,959
so for dramatic effect this isn't how

354
00:11:11,519 --> 00:11:13,600
most things work but this is how bad it

355
00:11:12,959 --> 00:11:15,518
could be

356
00:11:13,600 --> 00:11:17,040
so your user makes a blocking call to

357
00:11:15,519 --> 00:11:18,880
the os to use the driver

358
00:11:17,040 --> 00:11:20,800
don't do this get rid of your operating

359
00:11:18,880 --> 00:11:23,120
system

360
00:11:20,800 --> 00:11:24,800
the os forced the cache to flush not

361
00:11:23,120 --> 00:11:26,480
because it was a good idea but because

362
00:11:24,800 --> 00:11:29,680
security protocols require it to flush

363
00:11:26,480 --> 00:11:31,440
caches now

364
00:11:29,680 --> 00:11:32,800
the driver then forced a data copy

365
00:11:31,440 --> 00:11:34,399
because the memory spaces aren't shared

366
00:11:32,800 --> 00:11:36,800
between user space and the driver space

367
00:11:34,399 --> 00:11:39,519
so it actually has to do a memory copy

368
00:11:36,800 --> 00:11:42,560
on the processor side before it can do

369
00:11:39,519 --> 00:11:44,240
any work

370
00:11:42,560 --> 00:11:45,839
the driver then needs to send a command

371
00:11:44,240 --> 00:11:47,600
to the dma engine in the

372
00:11:45,839 --> 00:11:49,839
programmable logic to ask for the data

373
00:11:47,600 --> 00:11:52,959
that it wants

374
00:11:49,839 --> 00:11:52,959
then the driver needs to pull

375
00:11:53,760 --> 00:11:56,880
then finally the driver can send a

376
00:11:55,360 --> 00:11:58,639
command to the accelerator that it's

377
00:11:56,880 --> 00:12:01,360
allowed to read from the dma to make

378
00:11:58,639 --> 00:12:01,360
forward progress

379
00:12:02,160 --> 00:12:06,560
then the driver needs to pull the

380
00:12:03,440 --> 00:12:08,000
accelerator for completion

381
00:12:06,560 --> 00:12:11,599
then it commands the other dma to get

382
00:12:08,000 --> 00:12:13,120
the data back

383
00:12:11,600 --> 00:12:14,240
needs to pull the dma to see if it's

384
00:12:13,120 --> 00:12:15,839
done because it's really hard to know

385
00:12:14,240 --> 00:12:17,279
when these things are done

386
00:12:15,839 --> 00:12:19,600
and then at that point the os can

387
00:12:17,279 --> 00:12:21,200
restore the user thing and at that point

388
00:12:19,600 --> 00:12:22,720
all of its locality and its caches are

389
00:12:21,200 --> 00:12:25,839
gone because everything has been flushed

390
00:12:22,720 --> 00:12:25,839
to dram

391
00:12:25,920 --> 00:12:30,240
and then there was more i'm sure it was

392
00:12:27,920 --> 00:12:30,240
awful

393
00:12:30,560 --> 00:12:34,239
so what are the tricks here right you

394
00:12:32,800 --> 00:12:35,439
know these are solved problems we all

395
00:12:34,240 --> 00:12:37,360
have gpus or

396
00:12:35,440 --> 00:12:38,639
most of us play games it has this

397
00:12:37,360 --> 00:12:40,399
problem why

398
00:12:38,639 --> 00:12:41,920
why don't we encounter these things

399
00:12:40,399 --> 00:12:42,959
there well their trick is they hide the

400
00:12:41,920 --> 00:12:45,599
latency

401
00:12:42,959 --> 00:12:47,359
so they overlap transfer and operations

402
00:12:45,600 --> 00:12:48,800
and they

403
00:12:47,360 --> 00:12:50,560
right so if i just overlap the

404
00:12:48,800 --> 00:12:52,000
communications and i have multiple

405
00:12:50,560 --> 00:12:54,560
things in flight

406
00:12:52,000 --> 00:12:55,360
all of a sudden my life got a lot better

407
00:12:54,560 --> 00:12:58,800
but now

408
00:12:55,360 --> 00:13:02,079
my cpu has a full-time job right is it

409
00:12:58,800 --> 00:13:03,680
it is now the mother for the fpga

410
00:13:02,079 --> 00:13:05,920
that is all it's doing that is all it

411
00:13:03,680 --> 00:13:07,920
has time to do you have now lost a

412
00:13:05,920 --> 00:13:08,959
processing resource to gain a processing

413
00:13:07,920 --> 00:13:11,760
resource

414
00:13:08,959 --> 00:13:13,279
that is truly gross and awful so instead

415
00:13:11,760 --> 00:13:15,439
you should execute

416
00:13:13,279 --> 00:13:17,439
um you should sequence the operations in

417
00:13:15,440 --> 00:13:19,519
the pl so that you don't need to do any

418
00:13:17,440 --> 00:13:21,040
of this handshaking yourself

419
00:13:19,519 --> 00:13:22,639
right because it should just take care

420
00:13:21,040 --> 00:13:25,439
of it on the other side in the original

421
00:13:22,639 --> 00:13:25,440
config blast

422
00:13:25,920 --> 00:13:28,560
so it looks a little more like that

423
00:13:27,200 --> 00:13:30,160
where you send one packet over

424
00:13:28,560 --> 00:13:31,680
configuring the whole process

425
00:13:30,160 --> 00:13:33,600
and then run it over and this is one of

426
00:13:31,680 --> 00:13:34,959
the deep insights about opengl

427
00:13:33,600 --> 00:13:36,639
is that when the driver does a launch

428
00:13:34,959 --> 00:13:37,359
you actually send the full pipeline

429
00:13:36,639 --> 00:13:40,639
configuration

430
00:13:37,360 --> 00:13:42,320
in one go and then it runs and then at

431
00:13:40,639 --> 00:13:44,639
that point you get really low

432
00:13:42,320 --> 00:13:45,920
bandwidth high latency coms to talk to

433
00:13:44,639 --> 00:13:47,120
it

434
00:13:45,920 --> 00:13:49,199
other than that it's just ripping

435
00:13:47,120 --> 00:13:50,480
through um the problem is is that you

436
00:13:49,199 --> 00:13:52,560
need to avoid blocking

437
00:13:50,480 --> 00:13:53,760
in that path so you need to skip your

438
00:13:52,560 --> 00:13:55,680
false memory barriers

439
00:13:53,760 --> 00:13:57,439
so everybody who's used libraries really

440
00:13:55,680 --> 00:13:59,040
likes to do one library call

441
00:13:57,440 --> 00:14:01,519
wait till it's done and then do the next

442
00:13:59,040 --> 00:14:03,199
library call when you can start as soon

443
00:14:01,519 --> 00:14:04,639
as you have the data right so an fft you

444
00:14:03,199 --> 00:14:05,199
can start as soon as you have half the

445
00:14:04,639 --> 00:14:07,440
data

446
00:14:05,199 --> 00:14:09,120
if you decide to do the top and middle

447
00:14:07,440 --> 00:14:09,519
if you decide to start with the two top

448
00:14:09,120 --> 00:14:10,720
ones

449
00:14:09,519 --> 00:14:12,880
you can start as soon as you get two

450
00:14:10,720 --> 00:14:14,160
data points right so start as soon as

451
00:14:12,880 --> 00:14:15,839
you have everything you need

452
00:14:14,160 --> 00:14:17,040
and there are also true memory barriers

453
00:14:15,839 --> 00:14:19,680
and we could talk about all the cool

454
00:14:17,040 --> 00:14:22,160
tricks to hide that

455
00:14:19,680 --> 00:14:23,760
but we need to move on you should

456
00:14:22,160 --> 00:14:24,959
understand your application's data rate

457
00:14:23,760 --> 00:14:26,079
because after you've fixed all your

458
00:14:24,959 --> 00:14:28,399
latency problems

459
00:14:26,079 --> 00:14:29,359
you need to feed the beast it likes to

460
00:14:28,399 --> 00:14:31,600
eat data

461
00:14:29,360 --> 00:14:33,360
and it's hard to get it there and all

462
00:14:31,600 --> 00:14:35,040
the applications we like to use

463
00:14:33,360 --> 00:14:37,519
have really bad compute to bandwidth

464
00:14:35,040 --> 00:14:40,719
ratios

465
00:14:37,519 --> 00:14:41,920
so this is rough right and fft is this

466
00:14:40,720 --> 00:14:44,240
sort of login one

467
00:14:41,920 --> 00:14:45,839
ratio which is bad i love my matrix

468
00:14:44,240 --> 00:14:46,399
multiply because i send a little bit of

469
00:14:45,839 --> 00:14:48,240
data

470
00:14:46,399 --> 00:14:50,560
and i get to do a lot of work it's

471
00:14:48,240 --> 00:14:53,279
beautiful

472
00:14:50,560 --> 00:14:55,040
um and why do i think like this well i

473
00:14:53,279 --> 00:14:56,800
go look at the resource bandwidths

474
00:14:55,040 --> 00:14:58,719
right so i have dram ports i have two of

475
00:14:56,800 --> 00:15:01,120
them they're each 128 bits they clock at

476
00:14:58,720 --> 00:15:04,399
about 300 megahertz i get 77

477
00:15:01,120 --> 00:15:07,040
gigabits per second if i'm a god

478
00:15:04,399 --> 00:15:07,920
that's never going to happen i have b

479
00:15:07,040 --> 00:15:09,680
ram ports

480
00:15:07,920 --> 00:15:12,959
so all the distributed memory i have

481
00:15:09,680 --> 00:15:15,199
about 2018 bits

482
00:15:12,959 --> 00:15:16,638
of b rams each of them have a 32-bit

483
00:15:15,199 --> 00:15:18,160
channel we'll just worry about the read

484
00:15:16,639 --> 00:15:21,360
side don't worry about the right side

485
00:15:18,160 --> 00:15:22,399
they run at 600 megahertz they go at 38

486
00:15:21,360 --> 00:15:25,600
terabits per second

487
00:15:22,399 --> 00:15:27,519
right the real problem is my dsp runs at

488
00:15:25,600 --> 00:15:29,839
114 terabits per second

489
00:15:27,519 --> 00:15:30,720
so it's still yet faster than my local

490
00:15:29,839 --> 00:15:34,639
memories

491
00:15:30,720 --> 00:15:36,880
and way way faster than my dram

492
00:15:34,639 --> 00:15:38,639
so anything that i'm doing needs to live

493
00:15:36,880 --> 00:15:41,519
on the fpga

494
00:15:38,639 --> 00:15:44,480
it doesn't get to leave the fpga is

495
00:15:41,519 --> 00:15:44,480
hotel california

496
00:15:44,720 --> 00:15:48,000
the registers help a bit but the

497
00:15:46,560 --> 00:15:50,160
registers are everywhere

498
00:15:48,000 --> 00:15:52,399
and they're single bit and they don't

499
00:15:50,160 --> 00:15:56,560
actually run at 600 megahertz

500
00:15:52,399 --> 00:15:56,560
that's only if you're really really good

501
00:15:56,959 --> 00:16:01,040
but we'll talk about how to get close to

502
00:15:58,720 --> 00:16:03,360
that at the end

503
00:16:01,040 --> 00:16:04,959
so you need to exploit locality so the

504
00:16:03,360 --> 00:16:05,440
uh we've been calling this the memory

505
00:16:04,959 --> 00:16:06,880
wall

506
00:16:05,440 --> 00:16:08,639
so registers are going to mitigate your

507
00:16:06,880 --> 00:16:09,920
band limit and b ram b ram mitigates

508
00:16:08,639 --> 00:16:11,440
your band limit in dram

509
00:16:09,920 --> 00:16:13,599
and avoid writing back intermediates

510
00:16:11,440 --> 00:16:14,639
right as if the next processing stage is

511
00:16:13,600 --> 00:16:16,240
going to consume it

512
00:16:14,639 --> 00:16:17,839
don't write it somewhere i don't know

513
00:16:16,240 --> 00:16:18,959
what it is with some computer scientists

514
00:16:17,839 --> 00:16:21,839
but they're hoarders

515
00:16:18,959 --> 00:16:23,279
they like to have their data in dram for

516
00:16:21,839 --> 00:16:24,560
no good reason they're never going to

517
00:16:23,279 --> 00:16:27,279
look at it but they feel really

518
00:16:24,560 --> 00:16:30,719
comfortable knowing where it is

519
00:16:27,279 --> 00:16:31,279
stop it so how does this locality trick

520
00:16:30,720 --> 00:16:34,160
work

521
00:16:31,279 --> 00:16:35,759
think of this big block as dram as your

522
00:16:34,160 --> 00:16:37,040
bram this is your local cache where i'm

523
00:16:35,759 --> 00:16:37,839
going to keep some of my immediate

524
00:16:37,040 --> 00:16:39,360
locality

525
00:16:37,839 --> 00:16:41,519
these little blocks are registers where

526
00:16:39,360 --> 00:16:43,680
i'm keeping local values

527
00:16:41,519 --> 00:16:44,560
this is one kernel running or one

528
00:16:43,680 --> 00:16:46,239
processing block

529
00:16:44,560 --> 00:16:47,839
and this is its neighboring block they

530
00:16:46,240 --> 00:16:49,279
are eating out of the same buffer

531
00:16:47,839 --> 00:16:50,959
so they're not telling each other when

532
00:16:49,279 --> 00:16:53,120
the buffer is done they are

533
00:16:50,959 --> 00:16:54,399
immediately grabbing things right off

534
00:16:53,120 --> 00:16:56,959
the bat

535
00:16:54,399 --> 00:16:58,240
and as it's processing it chunks data in

536
00:16:56,959 --> 00:16:59,439
and the other one slides its window

537
00:16:58,240 --> 00:17:01,360
along

538
00:16:59,440 --> 00:17:02,639
and it just moves along and it's pretty

539
00:17:01,360 --> 00:17:04,480
and data gets evicted

540
00:17:02,639 --> 00:17:06,079
and i never actually need to hold what

541
00:17:04,480 --> 00:17:07,439
you might think is the real working set

542
00:17:06,079 --> 00:17:10,559
right i don't need to hold

543
00:17:07,439 --> 00:17:12,400
a full image i just need to hold

544
00:17:10,559 --> 00:17:14,879
the last thing in and the thing i'm

545
00:17:12,400 --> 00:17:17,120
evicting and then if i'm really clever

546
00:17:14,880 --> 00:17:18,400
this is a window right if you look at

547
00:17:17,119 --> 00:17:21,359
the window

548
00:17:18,400 --> 00:17:22,799
the window shares six squares every time

549
00:17:21,359 --> 00:17:23,760
so i store the six squares in little

550
00:17:22,799 --> 00:17:25,199
boxes

551
00:17:23,760 --> 00:17:27,520
and then only update the three new

552
00:17:25,199 --> 00:17:29,120
squares and so that's how i solve some

553
00:17:27,520 --> 00:17:30,240
of my bandwidth problems out of my my

554
00:17:29,120 --> 00:17:31,760
cache right

555
00:17:30,240 --> 00:17:33,360
and so thinking about where these

556
00:17:31,760 --> 00:17:34,799
locality exists in the different layers

557
00:17:33,360 --> 00:17:36,000
of locality is really important for

558
00:17:34,799 --> 00:17:37,200
getting high performance audio

559
00:17:36,000 --> 00:17:38,559
accelerators

560
00:17:37,200 --> 00:17:41,360
and this is this is sort of how we're

561
00:17:38,559 --> 00:17:41,360
going to feed the beast

562
00:17:42,400 --> 00:17:45,520
so so these are some of the the system

563
00:17:44,480 --> 00:17:47,280
system pitfalls

564
00:17:45,520 --> 00:17:48,639
there's a good number of other ones but

565
00:17:47,280 --> 00:17:49,280
you know i want to kind of get it

566
00:17:48,640 --> 00:17:51,120
through

567
00:17:49,280 --> 00:17:52,639
there you know first we're going to

568
00:17:51,120 --> 00:17:54,239
train individual actions and then we're

569
00:17:52,640 --> 00:17:55,520
going to train tricks so this is a trick

570
00:17:54,240 --> 00:17:59,840
i call sitting pretty

571
00:17:55,520 --> 00:18:02,559
it has two steps sit on the mat and

572
00:17:59,840 --> 00:18:02,559
cross your legs

573
00:18:02,640 --> 00:18:07,200
it's a dumb it brings me great pleasure

574
00:18:07,679 --> 00:18:11,120
to get her to do that i needed to teach

575
00:18:09,120 --> 00:18:12,959
her both things independently

576
00:18:11,120 --> 00:18:14,639
work through it a large number of times

577
00:18:12,960 --> 00:18:15,679
and then work through work that they are

578
00:18:14,640 --> 00:18:18,880
together

579
00:18:15,679 --> 00:18:20,559
fpgas are kind of similar there's not

580
00:18:18,880 --> 00:18:22,559
that much in an fpga

581
00:18:20,559 --> 00:18:24,080
we can sort this out so we need to think

582
00:18:22,559 --> 00:18:26,840
structurally about design

583
00:18:24,080 --> 00:18:29,039
so what is an fpga well roughly they're

584
00:18:26,840 --> 00:18:30,559
tiles

585
00:18:29,039 --> 00:18:32,400
they're organized so that you get a pair

586
00:18:30,559 --> 00:18:35,600
of b rams each 18 kb

587
00:18:32,400 --> 00:18:37,919
with a 36 bit read write interface

588
00:18:35,600 --> 00:18:39,120
you get two dsps that for some reason

589
00:18:37,919 --> 00:18:41,919
even though it's a mac it has

590
00:18:39,120 --> 00:18:44,559
four ports in and one port out it's

591
00:18:41,919 --> 00:18:47,360
because it's not a mac

592
00:18:44,559 --> 00:18:48,960
then i have some number of luts and some

593
00:18:47,360 --> 00:18:50,479
local crossbar i think

594
00:18:48,960 --> 00:18:52,000
back of the envelope for the processor i

595
00:18:50,480 --> 00:18:55,360
was looking at was about

596
00:18:52,000 --> 00:18:56,240
three hundred five to two uh look up

597
00:18:55,360 --> 00:18:59,280
tables

598
00:18:56,240 --> 00:19:01,360
and about 300 one bit states so

599
00:18:59,280 --> 00:19:02,799
there's not a whole lot in this tile but

600
00:19:01,360 --> 00:19:03,120
this is kind of your view of the world

601
00:19:02,799 --> 00:19:05,440
right

602
00:19:03,120 --> 00:19:06,879
is i get a dsp that gets to talk to

603
00:19:05,440 --> 00:19:08,720
these brands

604
00:19:06,880 --> 00:19:09,840
i do get to go north and i get to go

605
00:19:08,720 --> 00:19:11,440
south because the way that they've

606
00:19:09,840 --> 00:19:13,039
designed this is its cookie cutter

607
00:19:11,440 --> 00:19:14,559
they took the shape and then stamped it

608
00:19:13,039 --> 00:19:16,240
out a bunch of times

609
00:19:14,559 --> 00:19:17,678
so going north and south is really easy

610
00:19:16,240 --> 00:19:20,720
there is a global interconnect it's

611
00:19:17,679 --> 00:19:22,720
truly gross and awful

612
00:19:20,720 --> 00:19:24,320
so some minor misconceptions that i'm

613
00:19:22,720 --> 00:19:26,400
not really going to get into

614
00:19:24,320 --> 00:19:28,559
so hopefully at this point you're

615
00:19:26,400 --> 00:19:31,120
convinced that an fpga is not a verilog

616
00:19:28,559 --> 00:19:33,120
accelerator

617
00:19:31,120 --> 00:19:34,479
it looks a more it looks a lot more like

618
00:19:33,120 --> 00:19:37,120
somebody stopped doing their job on a

619
00:19:34,480 --> 00:19:40,720
systolic array part way through

620
00:19:37,120 --> 00:19:42,639
and said the rest is you um

621
00:19:40,720 --> 00:19:44,240
they're actually slices it's not luts

622
00:19:42,640 --> 00:19:45,840
and registers the tool loves to lie to

623
00:19:44,240 --> 00:19:47,120
you they actually have a macro with tons

624
00:19:45,840 --> 00:19:48,320
of cool stuff buried in it

625
00:19:47,120 --> 00:19:50,000
it's worth going and looking in the

626
00:19:48,320 --> 00:19:51,439
manual what it does it also changes

627
00:19:50,000 --> 00:19:53,840
every generation so you need to re-read

628
00:19:51,440 --> 00:19:56,000
the manual every year

629
00:19:53,840 --> 00:19:57,678
wires are expensive not gates but for

630
00:19:56,000 --> 00:19:59,360
some reason the tool only reports the

631
00:19:57,679 --> 00:20:01,840
gates it never reports the wires it

632
00:19:59,360 --> 00:20:03,280
drives me nuts

633
00:20:01,840 --> 00:20:05,760
you tell them and then they go well we

634
00:20:03,280 --> 00:20:07,440
can't figure out how to report it

635
00:20:05,760 --> 00:20:08,960
i know it's a problem and i have asic

636
00:20:07,440 --> 00:20:12,080
tools that tell me how it's a problem

637
00:20:08,960 --> 00:20:14,400
it's not that hard global wires are

638
00:20:12,080 --> 00:20:14,399
worse

639
00:20:14,480 --> 00:20:19,200
so what what's my takeaway from this

640
00:20:17,679 --> 00:20:21,120
pipeline your dsps

641
00:20:19,200 --> 00:20:23,600
so for some reason everybody wants to do

642
00:20:21,120 --> 00:20:26,080
a single multiply accumulate in a cycle

643
00:20:23,600 --> 00:20:28,080
the macro that's hard baked in there has

644
00:20:26,080 --> 00:20:30,240
four pipe stages in it

645
00:20:28,080 --> 00:20:34,240
if you ask for the four pipe stage dsp

646
00:20:30,240 --> 00:20:35,760
you get a four pipe stage dsp

647
00:20:34,240 --> 00:20:37,520
that is how you get this to run at 600

648
00:20:35,760 --> 00:20:39,120
megahertz if you do not do that it runs

649
00:20:37,520 --> 00:20:43,200
at 100 megahertz

650
00:20:39,120 --> 00:20:46,320
that's sad that's a regret factor of six

651
00:20:43,200 --> 00:20:49,039
also really neat it has a pre-adder

652
00:20:46,320 --> 00:20:50,480
that seems kind of helpful because if

653
00:20:49,039 --> 00:20:53,039
you're doing complex multiplies

654
00:20:50,480 --> 00:20:56,240
sometimes you do a pre-ad i'm pretty

655
00:20:53,039 --> 00:20:56,240
sure that's the reason that it's there

656
00:20:58,880 --> 00:21:03,360
so that was a caricature that's not what

657
00:21:00,720 --> 00:21:04,480
it really is it's this it's way worse

658
00:21:03,360 --> 00:21:05,918
there's all these wires that going

659
00:21:04,480 --> 00:21:07,919
everywhere there's muxes there's extra

660
00:21:05,919 --> 00:21:09,360
flip-flops i didn't even talk about

661
00:21:07,919 --> 00:21:10,320
the first picture came from the front of

662
00:21:09,360 --> 00:21:13,120
the manual where they're trying to

663
00:21:10,320 --> 00:21:17,280
convince you this is a good thing

664
00:21:13,120 --> 00:21:20,320
this came from the back of the manual

665
00:21:17,280 --> 00:21:20,320
but this is more helpful

666
00:21:21,440 --> 00:21:25,760
pipeline your b ramps everybody wants

667
00:21:24,240 --> 00:21:27,679
single cycle memory lookups

668
00:21:25,760 --> 00:21:28,799
some people like a memory lookup while

669
00:21:27,679 --> 00:21:31,840
they're doing math

670
00:21:28,799 --> 00:21:33,679
that's craziness these have input flops

671
00:21:31,840 --> 00:21:34,399
for the addresses and output flops for

672
00:21:33,679 --> 00:21:36,960
the data

673
00:21:34,400 --> 00:21:38,640
they also have input flops for the for

674
00:21:36,960 --> 00:21:41,520
the incoming write data

675
00:21:38,640 --> 00:21:42,880
if you do not do it it runs dog's flow

676
00:21:41,520 --> 00:21:43,200
this was actually the thing that killed

677
00:21:42,880 --> 00:21:45,360
us

678
00:21:43,200 --> 00:21:46,640
on most of our image processing problems

679
00:21:45,360 --> 00:21:47,360
probably because we had a ton of these

680
00:21:46,640 --> 00:21:49,520
everywhere

681
00:21:47,360 --> 00:21:50,879
but um this will be one of the biggest

682
00:21:49,520 --> 00:21:51,360
contributors to running slow because it

683
00:21:50,880 --> 00:21:53,360
would just

684
00:21:51,360 --> 00:21:54,559
never occur to you that memory accesses

685
00:21:53,360 --> 00:21:56,240
are pipelined

686
00:21:54,559 --> 00:21:57,678
this is how your caches work so most

687
00:21:56,240 --> 00:21:59,919
caches l1 is two

688
00:21:57,679 --> 00:22:00,960
two pipe stages your l2 is like four or

689
00:21:59,919 --> 00:22:02,559
five pipe stages

690
00:22:00,960 --> 00:22:04,240
this is just how memory is now if you

691
00:22:02,559 --> 00:22:07,840
build a custom asic i'm going to try and

692
00:22:04,240 --> 00:22:07,840
make this as deep as humanly possible

693
00:22:09,039 --> 00:22:12,320
um so when i'm thinking about it

694
00:22:11,039 --> 00:22:13,919
structurally

695
00:22:12,320 --> 00:22:15,360
the goal i have is to maximize my

696
00:22:13,919 --> 00:22:18,000
resource utilization so i

697
00:22:15,360 --> 00:22:19,600
roughly have three assets i have dsps

698
00:22:18,000 --> 00:22:20,960
that have rates and location

699
00:22:19,600 --> 00:22:23,520
this is kind of a weird view of the

700
00:22:20,960 --> 00:22:24,320
world because i have dsps that are local

701
00:22:23,520 --> 00:22:25,840
to memories

702
00:22:24,320 --> 00:22:27,600
and i have dsps that are not local to

703
00:22:25,840 --> 00:22:30,320
memories so

704
00:22:27,600 --> 00:22:31,840
that specific dsp is a resource brams

705
00:22:30,320 --> 00:22:32,320
are weird because they have capacity

706
00:22:31,840 --> 00:22:34,480
boards

707
00:22:32,320 --> 00:22:36,080
ports bandwidth and location and

708
00:22:34,480 --> 00:22:37,440
oftentimes i'm picking and choosing what

709
00:22:36,080 --> 00:22:39,760
i want and we'll talk about how that

710
00:22:37,440 --> 00:22:41,600
works with fft

711
00:22:39,760 --> 00:22:43,039
dram i have bandwidth and i have ports

712
00:22:41,600 --> 00:22:44,320
it turns out that often i need to share

713
00:22:43,039 --> 00:22:46,640
the drm with other people

714
00:22:44,320 --> 00:22:48,480
and it's really hard so sometimes i have

715
00:22:46,640 --> 00:22:51,039
to build a controller just to arbitrage

716
00:22:48,480 --> 00:22:52,960
who gets to deal with the dram generally

717
00:22:51,039 --> 00:22:55,120
my goals are spatial utilization i want

718
00:22:52,960 --> 00:22:56,640
to be between seventy and ninety percent

719
00:22:55,120 --> 00:22:57,918
below seventy percent somebody's not

720
00:22:56,640 --> 00:22:59,280
doing what they're supposed to be doing

721
00:22:57,919 --> 00:23:00,799
at seventy percent

722
00:22:59,280 --> 00:23:02,158
they're at the point where most industry

723
00:23:00,799 --> 00:23:04,559
people will say they did a good job but

724
00:23:02,159 --> 00:23:04,559
they didn't

725
00:23:06,880 --> 00:23:09,919
roughly the difference between 70 and 90

726
00:23:08,960 --> 00:23:11,360
is space

727
00:23:09,919 --> 00:23:12,960
if you know where things are you can get

728
00:23:11,360 --> 00:23:14,158
to 90. if you didn't want to look at

729
00:23:12,960 --> 00:23:15,440
where things are you're going to sit at

730
00:23:14,159 --> 00:23:18,000
70.

731
00:23:15,440 --> 00:23:19,600
temporal utilization if you've allocated

732
00:23:18,000 --> 00:23:22,080
something

733
00:23:19,600 --> 00:23:23,760
use it 99 of the time most people get a

734
00:23:22,080 --> 00:23:25,439
high spatial utilization but everything

735
00:23:23,760 --> 00:23:28,320
is off

736
00:23:25,440 --> 00:23:29,360
what was the point and then minimize

737
00:23:28,320 --> 00:23:30,960
your regret right

738
00:23:29,360 --> 00:23:33,360
don't utilize something just to run six

739
00:23:30,960 --> 00:23:36,640
times slower than you would otherwise

740
00:23:33,360 --> 00:23:39,918
that is sad

741
00:23:36,640 --> 00:23:41,919
so how do we plan a trick so

742
00:23:39,919 --> 00:23:44,240
the way i think about this right is so

743
00:23:41,919 --> 00:23:46,400
let's do an in-place fft right we'll do

744
00:23:44,240 --> 00:23:47,840
a radix 2 butterfly we'll do 32-bit

745
00:23:46,400 --> 00:23:50,320
floats

746
00:23:47,840 --> 00:23:51,120
so in order to service this right i need

747
00:23:50,320 --> 00:23:55,200
a bandwidth

748
00:23:51,120 --> 00:23:56,639
to support that 128 bit in 128 bit out

749
00:23:55,200 --> 00:23:58,960
so the limiting factor is going to be

750
00:23:56,640 --> 00:24:01,600
the bandwidth on my brands

751
00:23:58,960 --> 00:24:02,320
one two three four now i could tie them

752
00:24:01,600 --> 00:24:05,120
straight in

753
00:24:02,320 --> 00:24:07,200
but i have a problem in the early part

754
00:24:05,120 --> 00:24:08,239
of the fft it's an even odd calculation

755
00:24:07,200 --> 00:24:09,919
right because i'm going to grab

756
00:24:08,240 --> 00:24:12,720
every other thing so i could stride the

757
00:24:09,919 --> 00:24:15,200
axises on the back end

758
00:24:12,720 --> 00:24:16,799
they're all going to be on the left side

759
00:24:15,200 --> 00:24:18,159
so now i have a problem

760
00:24:16,799 --> 00:24:19,840
so they call this the conflict problem

761
00:24:18,159 --> 00:24:21,520
in fft allocations

762
00:24:19,840 --> 00:24:23,120
um and it's really hard to do in place

763
00:24:21,520 --> 00:24:24,320
ffts this way

764
00:24:23,120 --> 00:24:26,320
so the trick is is that as you're

765
00:24:24,320 --> 00:24:28,320
writing things back you need to move it

766
00:24:26,320 --> 00:24:29,600
so if you've dealt with the xylinks

767
00:24:28,320 --> 00:24:30,639
accelerators the way they solve this

768
00:24:29,600 --> 00:24:32,158
problem is that they

769
00:24:30,640 --> 00:24:34,240
unroll it in space and actually have a

770
00:24:32,159 --> 00:24:36,559
dedicated room unit to reshuffle the

771
00:24:34,240 --> 00:24:36,559
data

772
00:24:38,400 --> 00:24:42,159
this is also going to be super deeply

773
00:24:40,320 --> 00:24:44,720
pipelined

774
00:24:42,159 --> 00:24:48,159
this is going to be three cycles this is

775
00:24:44,720 --> 00:24:48,159
roughly going to be 12 cycles

776
00:24:48,320 --> 00:24:51,678
in this in order to get the 600

777
00:24:49,919 --> 00:24:52,799
megahertz out of the programmable logic

778
00:24:51,679 --> 00:24:54,240
because this is all going to need to be

779
00:24:52,799 --> 00:24:55,440
implemented in programmable logic in a

780
00:24:54,240 --> 00:24:57,440
set of state machines

781
00:24:55,440 --> 00:24:59,600
controlling that that sequencer this is

782
00:24:57,440 --> 00:25:00,880
probably going to be 10 cycles

783
00:24:59,600 --> 00:25:02,799
it's not going to make any sense that

784
00:25:00,880 --> 00:25:04,799
it's 10 cycles

785
00:25:02,799 --> 00:25:05,840
but roughly every time you have a 5 to 2

786
00:25:04,799 --> 00:25:08,400
lookup table

787
00:25:05,840 --> 00:25:11,120
you have a register so if you don't use

788
00:25:08,400 --> 00:25:12,720
the register you're throwing it away

789
00:25:11,120 --> 00:25:14,158
so you always want to deeply pipeline

790
00:25:12,720 --> 00:25:16,080
your programmable logic

791
00:25:14,159 --> 00:25:17,360
and if i could leave you with any one

792
00:25:16,080 --> 00:25:19,840
big takeaway about how to build these

793
00:25:17,360 --> 00:25:21,600
accelerators is that on the fpga

794
00:25:19,840 --> 00:25:22,879
they sort of want to be pipelined in an

795
00:25:21,600 --> 00:25:25,039
irritating way

796
00:25:22,880 --> 00:25:26,320
like two or three logic levels per pipe

797
00:25:25,039 --> 00:25:28,480
stage

798
00:25:26,320 --> 00:25:30,000
it sounds really weird to say as an asic

799
00:25:28,480 --> 00:25:30,640
person because i shoot for 20 logic

800
00:25:30,000 --> 00:25:32,080
levels

801
00:25:30,640 --> 00:25:34,080
per pipe stage that's sort of a good

802
00:25:32,080 --> 00:25:35,840
place to be

803
00:25:34,080 --> 00:25:37,600
but this really wants three or four

804
00:25:35,840 --> 00:25:39,360
logic levels or two logic levels at the

805
00:25:37,600 --> 00:25:40,639
most

806
00:25:39,360 --> 00:25:42,719
part of the reason is that the logic's

807
00:25:40,640 --> 00:25:44,559
not expensive it's the wire and any time

808
00:25:42,720 --> 00:25:48,240
you touch the logic it has to run around

809
00:25:44,559 --> 00:25:48,240
some crossbar to get where it's going

810
00:25:48,720 --> 00:25:50,880
so

811
00:25:52,080 --> 00:25:56,320
now i'm going to end with the you know

812
00:25:54,159 --> 00:25:57,760
sort of an argument for

813
00:25:56,320 --> 00:25:59,600
to get your opinion and hear where you

814
00:25:57,760 --> 00:26:02,400
are or say something controversial

815
00:25:59,600 --> 00:26:03,760
um you know you wouldn't have had to

816
00:26:02,400 --> 00:26:06,799
listen to everything i just said if

817
00:26:03,760 --> 00:26:10,400
there was a good verilog library right

818
00:26:06,799 --> 00:26:12,158
you could blow me off and go dude

819
00:26:10,400 --> 00:26:13,679
there's this library i can ignore

820
00:26:12,159 --> 00:26:14,799
everything you said right you don't

821
00:26:13,679 --> 00:26:17,039
actually need to know how to write a

822
00:26:14,799 --> 00:26:18,879
really good fftw

823
00:26:17,039 --> 00:26:20,559
there i mean a really good fft right at

824
00:26:18,880 --> 00:26:21,600
this point i just say the library name

825
00:26:20,559 --> 00:26:23,760
fftw

826
00:26:21,600 --> 00:26:26,559
instead of actually thinking fft right

827
00:26:23,760 --> 00:26:29,440
is it's one to one in my head right now

828
00:26:26,559 --> 00:26:31,120
so why isn't it like that for verilog

829
00:26:29,440 --> 00:26:32,799
right why can't we utilize best

830
00:26:31,120 --> 00:26:33,760
practices from software why can't it

831
00:26:32,799 --> 00:26:37,120
have compact

832
00:26:33,760 --> 00:26:38,000
apis why can't it have parametric calls

833
00:26:37,120 --> 00:26:39,439
why can't we

834
00:26:38,000 --> 00:26:41,039
parameterize these things why isn't it

835
00:26:39,440 --> 00:26:42,559
well documented i think there's

836
00:26:41,039 --> 00:26:44,158
something about electrical engineers and

837
00:26:42,559 --> 00:26:47,200
specifically digital engineers

838
00:26:44,159 --> 00:26:47,200
about documentation

839
00:26:47,840 --> 00:26:53,360
i hate doing it my students make me

840
00:26:50,960 --> 00:26:54,799
hate making them do it so it's it's just

841
00:26:53,360 --> 00:26:56,879
all sorts of awful

842
00:26:54,799 --> 00:26:57,918
um and i have yet to see anybody

843
00:26:56,880 --> 00:26:59,919
actually benchmark

844
00:26:57,919 --> 00:27:01,360
code that they've given out as verilog

845
00:26:59,919 --> 00:27:04,400
but that's standard practice

846
00:27:01,360 --> 00:27:04,399
in a software library

847
00:27:04,559 --> 00:27:08,559
right so you know these are all things

848
00:27:07,600 --> 00:27:11,199
that

849
00:27:08,559 --> 00:27:12,720
you know how do we get part way there

850
00:27:11,200 --> 00:27:14,559
how do we even figure this out and then

851
00:27:12,720 --> 00:27:15,440
there's really awful catch-22s built

852
00:27:14,559 --> 00:27:17,440
into this too

853
00:27:15,440 --> 00:27:19,440
because right now anything free in terms

854
00:27:17,440 --> 00:27:22,799
of verilog is crap

855
00:27:19,440 --> 00:27:24,559
unmitigated crap it's awful if it's free

856
00:27:22,799 --> 00:27:27,440
it's bad right it's like finding a

857
00:27:24,559 --> 00:27:27,440
doughnut in the garbage

858
00:27:27,760 --> 00:27:32,320
because if they gave it away they

859
00:27:29,120 --> 00:27:32,320
thought it had no value

860
00:27:33,200 --> 00:27:36,799
the other problem is nobody will use

861
00:27:35,440 --> 00:27:38,240
anything they find in the wild if they

862
00:27:36,799 --> 00:27:39,679
think it's good because there's a chance

863
00:27:38,240 --> 00:27:42,559
that it wasn't used in a tape out

864
00:27:39,679 --> 00:27:42,559
we only got a few minutes

865
00:27:44,159 --> 00:27:49,520
so if you want to argue with me more or

866
00:27:47,600 --> 00:27:52,799
talk with me more about how awful

867
00:27:49,520 --> 00:27:55,200
foss hardware is i will be around

868
00:27:52,799 --> 00:27:57,520
um so thank you thoughts concerns hope

869
00:27:55,200 --> 00:27:57,520
streams

870
00:28:00,960 --> 00:28:04,240
right if desires want to leave please

871
00:28:03,120 --> 00:28:05,918
leave now i

872
00:28:04,240 --> 00:28:07,760
think we have quite a queue for the

873
00:28:05,919 --> 00:28:11,279
satellite talk

874
00:28:07,760 --> 00:28:17,840
um yeah go ahead

875
00:28:11,279 --> 00:28:17,840
what do you think about i know

876
00:28:25,600 --> 00:28:29,120
so certainly a lot of the devices that

877
00:28:27,760 --> 00:28:31,440
couple the

878
00:28:29,120 --> 00:28:32,799
fpga with the dax directly so that

879
00:28:31,440 --> 00:28:33,679
you're streaming from the dax directly

880
00:28:32,799 --> 00:28:42,158
into the fpga

881
00:28:33,679 --> 00:28:42,159
solve a lot of these problems

