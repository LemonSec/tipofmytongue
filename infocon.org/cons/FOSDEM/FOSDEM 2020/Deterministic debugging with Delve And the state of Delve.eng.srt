1
00:00:08,240 --> 00:00:12,559
all right

2
00:00:08,960 --> 00:00:14,559
hello everybody um uh

3
00:00:12,559 --> 00:00:16,160
yes thank you very much uh my name is

4
00:00:14,559 --> 00:00:18,080
derek parker um

5
00:00:16,160 --> 00:00:19,760
i am once again going to be talking

6
00:00:18,080 --> 00:00:23,839
about delph this is true

7
00:00:19,760 --> 00:00:25,519
um uh so this time the the predominant

8
00:00:23,840 --> 00:00:28,240
theme of this talk will be

9
00:00:25,519 --> 00:00:30,080
deterministic debugging with delve this

10
00:00:28,240 --> 00:00:33,360
is a talk that i'm particularly excited

11
00:00:30,080 --> 00:00:37,360
about um as i think that this

12
00:00:33,360 --> 00:00:40,239
this style of debugging is not only

13
00:00:37,360 --> 00:00:40,559
not very well known but as a result of

14
00:00:40,239 --> 00:00:43,839
that

15
00:00:40,559 --> 00:00:45,599
under utilized i think a lot of people

16
00:00:43,840 --> 00:00:46,719
think of debugging in the traditional

17
00:00:45,600 --> 00:00:49,360
sense of

18
00:00:46,719 --> 00:00:50,800
you're debugging a live process um a lot

19
00:00:49,360 --> 00:00:52,320
of different things can happen

20
00:00:50,800 --> 00:00:54,000
a lot of things can happen between

21
00:00:52,320 --> 00:00:56,399
debugging sessions and between runs of

22
00:00:54,000 --> 00:00:58,960
the process and things like that so

23
00:00:56,399 --> 00:00:59,920
how do we how do we eliminate a lot of

24
00:00:58,960 --> 00:01:03,840
that and

25
00:00:59,920 --> 00:01:07,439
especially uh if you have a bug

26
00:01:03,840 --> 00:01:09,680
that say only uh only exposes itself

27
00:01:07,439 --> 00:01:13,039
maybe one out of a hundred runs

28
00:01:09,680 --> 00:01:14,159
how do you sanely debug that that's the

29
00:01:13,040 --> 00:01:17,280
kind of things that i'm going to be

30
00:01:14,159 --> 00:01:17,280
talking about during this talk

31
00:01:23,520 --> 00:01:26,640
just to introduce myself a little bit

32
00:01:24,880 --> 00:01:30,880
more again my name is derek parker

33
00:01:26,640 --> 00:01:34,320
i am a software engineer at red hat um

34
00:01:30,880 --> 00:01:35,039
i work on go tooling upstream and i work

35
00:01:34,320 --> 00:01:36,559
on

36
00:01:35,040 --> 00:01:38,079
delve as well and some of the go

37
00:01:36,560 --> 00:01:42,079
packages that we ship

38
00:01:38,079 --> 00:01:46,000
through rel um

39
00:01:42,079 --> 00:01:47,360
i uh am the original author of delve

40
00:01:46,000 --> 00:01:49,040
and have been working on that for a long

41
00:01:47,360 --> 00:01:55,840
time um among

42
00:01:49,040 --> 00:01:55,840
among a few other things

43
00:01:56,640 --> 00:02:02,880
okay so i want to give kind of a rundown

44
00:02:00,240 --> 00:02:04,000
of what we're gonna go through in this

45
00:02:02,880 --> 00:02:07,119
talk

46
00:02:04,000 --> 00:02:10,160
so as mentioned um i've

47
00:02:07,119 --> 00:02:11,599
i've started to steal the uh the idea

48
00:02:10,160 --> 00:02:14,160
for the state of go

49
00:02:11,599 --> 00:02:15,920
and um i've spoken here uh for a few

50
00:02:14,160 --> 00:02:18,079
years so i like to kind of give

51
00:02:15,920 --> 00:02:20,319
an update on the state of delve what's

52
00:02:18,080 --> 00:02:24,239
happened uh what new features and what

53
00:02:20,319 --> 00:02:26,000
things have changed since last year

54
00:02:24,239 --> 00:02:27,360
because in a year a lot of things can

55
00:02:26,000 --> 00:02:30,560
change a lot of new features

56
00:02:27,360 --> 00:02:31,120
uh can be can be completed um and i

57
00:02:30,560 --> 00:02:32,879
think it

58
00:02:31,120 --> 00:02:34,720
it gives kind of an idea of the pace of

59
00:02:32,879 --> 00:02:37,120
the project and the types of things that

60
00:02:34,720 --> 00:02:39,040
we're working on and focused on

61
00:02:37,120 --> 00:02:40,480
also allows a little bit bit of feedback

62
00:02:39,040 --> 00:02:42,799
from from just

63
00:02:40,480 --> 00:02:44,000
users in general everybody here about

64
00:02:42,800 --> 00:02:45,840
maybe what they would like to see in the

65
00:02:44,000 --> 00:02:48,000
future

66
00:02:45,840 --> 00:02:51,280
uh after that i'll go into what

67
00:02:48,000 --> 00:02:54,319
deterministic debugging is and explain

68
00:02:51,280 --> 00:02:55,920
uh how it works first of all just

69
00:02:54,319 --> 00:02:57,760
explain the concept for

70
00:02:55,920 --> 00:02:59,040
for those who may not be familiar with

71
00:02:57,760 --> 00:03:02,399
it and then

72
00:02:59,040 --> 00:03:03,840
i'll dig into a little bit of how it

73
00:03:02,400 --> 00:03:07,840
works under the hood so

74
00:03:03,840 --> 00:03:10,000
actually um how how you can

75
00:03:07,840 --> 00:03:11,519
get rid of all of these deterministic or

76
00:03:10,000 --> 00:03:14,159
und non-deterministic

77
00:03:11,519 --> 00:03:15,280
things that happen in every process run

78
00:03:14,159 --> 00:03:18,480
and have

79
00:03:15,280 --> 00:03:20,080
a repeatable debugging session

80
00:03:18,480 --> 00:03:23,040
so how that actually works from a

81
00:03:20,080 --> 00:03:25,840
relatively low level

82
00:03:23,040 --> 00:03:26,720
following that i'll talk about how delve

83
00:03:25,840 --> 00:03:32,239
leverages

84
00:03:26,720 --> 00:03:35,680
this to be able to debug go programs

85
00:03:32,239 --> 00:03:38,560
uh and then finally i'll do a live demo

86
00:03:35,680 --> 00:03:39,760
just kind of showing off uh showing off

87
00:03:38,560 --> 00:03:41,920
the concept a little bit

88
00:03:39,760 --> 00:03:44,319
showing it in action and giving a sense

89
00:03:41,920 --> 00:03:45,200
of how just how easy it is to do this

90
00:03:44,319 --> 00:03:48,319
yourself

91
00:03:45,200 --> 00:03:50,079
in your day-to-day debugging and work

92
00:03:48,319 --> 00:03:51,920
and programming workflow so that

93
00:03:50,080 --> 00:03:54,159
hopefully this is something that you'll

94
00:03:51,920 --> 00:03:55,119
reach for or at least know to reach for

95
00:03:54,159 --> 00:03:58,239
if you come into

96
00:03:55,120 --> 00:04:01,840
a problem where uh this style of

97
00:03:58,239 --> 00:04:01,840
debugging might come in handy

98
00:04:05,280 --> 00:04:09,760
okay so first of all let's just jump

99
00:04:08,159 --> 00:04:10,560
right into the state of delve let's talk

100
00:04:09,760 --> 00:04:12,959
about what's

101
00:04:10,560 --> 00:04:15,040
what's happened in the last year some of

102
00:04:12,959 --> 00:04:16,798
the new features some of the new changes

103
00:04:15,040 --> 00:04:18,079
and then we'll briefly talk about some

104
00:04:16,798 --> 00:04:21,198
things that were that we're going to

105
00:04:18,079 --> 00:04:21,199
work on going forward

106
00:04:21,519 --> 00:04:28,720
um so the project is now six years old

107
00:04:25,040 --> 00:04:32,639
uh which is crazy to me um it's uh

108
00:04:28,720 --> 00:04:34,960
you know they grow up so fast right um

109
00:04:32,639 --> 00:04:35,919
uh i'm very excited to have been working

110
00:04:34,960 --> 00:04:38,799
on it and

111
00:04:35,919 --> 00:04:40,080
um that so many people have found it to

112
00:04:38,800 --> 00:04:43,440
be useful

113
00:04:40,080 --> 00:04:47,198
it's very exciting um

114
00:04:43,440 --> 00:04:49,600
we've had 175 commits over the last year

115
00:04:47,199 --> 00:04:51,280
uh not a ton but for a more esoteric

116
00:04:49,600 --> 00:04:53,360
project as a debugger

117
00:04:51,280 --> 00:04:55,679
um that's that's really really good and

118
00:04:53,360 --> 00:04:57,199
we've had a ton of new contributors

119
00:04:55,680 --> 00:04:58,560
which is great we love first time

120
00:04:57,199 --> 00:05:00,160
contributors and try to encourage that

121
00:04:58,560 --> 00:05:02,720
as much as possible

122
00:05:00,160 --> 00:05:06,800
and folks building in some really huge

123
00:05:02,720 --> 00:05:06,800
features which i'll i'll talk about next

124
00:05:09,440 --> 00:05:13,600
so what's uh what's changed since last

125
00:05:11,919 --> 00:05:14,479
fosdem well there's been a couple go

126
00:05:13,600 --> 00:05:18,080
releases

127
00:05:14,479 --> 00:05:20,000
right so we've we've released uh

128
00:05:18,080 --> 00:05:22,479
uh some new versions of delve that

129
00:05:20,000 --> 00:05:26,080
support that so specifically 113

130
00:05:22,479 --> 00:05:28,800
and 114 which which will be released

131
00:05:26,080 --> 00:05:29,359
uh another big big big change that's

132
00:05:28,800 --> 00:05:32,800
happened

133
00:05:29,360 --> 00:05:35,280
uh over the last year is arm 64 support

134
00:05:32,800 --> 00:05:37,440
so uh before this we only really

135
00:05:35,280 --> 00:05:41,280
supported x86 64.

136
00:05:37,440 --> 00:05:42,560
um we've just gotten a a great patch in

137
00:05:41,280 --> 00:05:44,880
recently to add

138
00:05:42,560 --> 00:05:46,160
uh kind of initial arm 64 support

139
00:05:44,880 --> 00:05:46,639
there's still some more work to be done

140
00:05:46,160 --> 00:05:49,600
there

141
00:05:46,639 --> 00:05:52,320
but that's that's still a huge a huge

142
00:05:49,600 --> 00:05:53,680
addition to the project we

143
00:05:52,320 --> 00:05:55,440
obviously aim to support every

144
00:05:53,680 --> 00:05:57,440
architecture and operating system that

145
00:05:55,440 --> 00:05:59,120
go supports natively

146
00:05:57,440 --> 00:06:02,479
but you know it just takes some time so

147
00:05:59,120 --> 00:06:02,479
contributions are always welcome

148
00:06:02,639 --> 00:06:06,639
another big thing is freebsd support

149
00:06:04,880 --> 00:06:08,800
again we want to

150
00:06:06,639 --> 00:06:10,479
we want to include as many operating

151
00:06:08,800 --> 00:06:11,120
systems and everything as we possibly

152
00:06:10,479 --> 00:06:13,599
can

153
00:06:11,120 --> 00:06:14,400
so that was another big big addition we

154
00:06:13,600 --> 00:06:17,520
already support

155
00:06:14,400 --> 00:06:20,318
you know various linuxes windows

156
00:06:17,520 --> 00:06:21,359
and osx so this just adds one more

157
00:06:20,319 --> 00:06:25,199
operating system to the

158
00:06:21,360 --> 00:06:27,440
repertoire um

159
00:06:25,199 --> 00:06:28,400
we've added uh the ability to script

160
00:06:27,440 --> 00:06:30,800
delve via

161
00:06:28,400 --> 00:06:32,000
a language called starlark which was

162
00:06:30,800 --> 00:06:34,880
originally

163
00:06:32,000 --> 00:06:36,560
created for the build system basil um

164
00:06:34,880 --> 00:06:39,759
it's based it's a python-esque

165
00:06:36,560 --> 00:06:41,360
dialect uh and that adds a lot of

166
00:06:39,759 --> 00:06:44,240
powerful scripting features

167
00:06:41,360 --> 00:06:46,000
uh into delve so you can you can define

168
00:06:44,240 --> 00:06:46,639
new commands within delve and other

169
00:06:46,000 --> 00:06:49,360
things

170
00:06:46,639 --> 00:06:50,240
uh just by writing this this starlark

171
00:06:49,360 --> 00:06:51,440
language

172
00:06:50,240 --> 00:06:54,720
and those those commands will be

173
00:06:51,440 --> 00:06:56,960
available to you in your debug session

174
00:06:54,720 --> 00:06:58,720
uh we've also added support for

175
00:06:56,960 --> 00:07:00,799
debugging go plugins

176
00:06:58,720 --> 00:07:02,400
so for anybody using that feature that's

177
00:07:00,800 --> 00:07:03,840
now supported

178
00:07:02,400 --> 00:07:06,400
windows mini dump support which is

179
00:07:03,840 --> 00:07:09,440
basically windows core dumps

180
00:07:06,400 --> 00:07:12,880
and improved support for debugging pies

181
00:07:09,440 --> 00:07:15,360
position independent executables

182
00:07:12,880 --> 00:07:16,960
some other notable just changes some

183
00:07:15,360 --> 00:07:18,960
internal refactoring

184
00:07:16,960 --> 00:07:20,719
just ongoing code maintenance cleanup i

185
00:07:18,960 --> 00:07:24,000
think that's an important thing

186
00:07:20,720 --> 00:07:26,400
several performance improvements

187
00:07:24,000 --> 00:07:28,479
especially on breakpoint handling and a

188
00:07:26,400 --> 00:07:30,560
lot of other things

189
00:07:28,479 --> 00:07:31,919
improved handling of optimized binaries

190
00:07:30,560 --> 00:07:33,360
i think this is an important one

191
00:07:31,919 --> 00:07:35,440
and this took a lot of coordination with

192
00:07:33,360 --> 00:07:37,759
the go team uh

193
00:07:35,440 --> 00:07:39,280
you if you have a if you have a binary

194
00:07:37,759 --> 00:07:40,880
that's actually running in production or

195
00:07:39,280 --> 00:07:42,400
something like that or you build it just

196
00:07:40,880 --> 00:07:45,120
just normally with go build it's going

197
00:07:42,400 --> 00:07:48,719
to be optimized so we want to be able to

198
00:07:45,120 --> 00:07:50,319
to debug those ideally as well as you

199
00:07:48,720 --> 00:07:51,759
can debug

200
00:07:50,319 --> 00:07:55,520
binaries that you've built with

201
00:07:51,759 --> 00:07:55,520
optimizations explicitly turned off

202
00:07:55,840 --> 00:07:59,280
we've improved function call support and

203
00:07:58,000 --> 00:08:01,759
just in general

204
00:07:59,280 --> 00:08:04,960
uh we've we've included a bunch of other

205
00:08:01,759 --> 00:08:04,960
improvements in bug fixes

206
00:08:06,639 --> 00:08:12,960
okay so now let's go on to part two the

207
00:08:09,759 --> 00:08:14,240
uh the real the real kind of me and

208
00:08:12,960 --> 00:08:16,799
subject of this talk

209
00:08:14,240 --> 00:08:18,319
so first off um i'm up here speaking

210
00:08:16,800 --> 00:08:20,720
about it but i would like to thank my

211
00:08:18,319 --> 00:08:23,120
co-maintainer who happens to be here

212
00:08:20,720 --> 00:08:25,199
uh for doing all the hard work of

213
00:08:23,120 --> 00:08:28,080
actually plumbing up delve to

214
00:08:25,199 --> 00:08:29,919
the uh the record replay back-end that

215
00:08:28,080 --> 00:08:32,478
we used to to achieve this

216
00:08:29,919 --> 00:08:33,838
um he did a lot of the hard work i just

217
00:08:32,479 --> 00:08:35,279
reviewed it and now i'm up here bragging

218
00:08:33,839 --> 00:08:41,839
about it so i just wanted to give credit

219
00:08:35,279 --> 00:08:41,838
where credit's due and say thank you

220
00:08:42,559 --> 00:08:46,880
okay now let's talk a little bit about

221
00:08:44,720 --> 00:08:48,640
uh what is deterministic debugging

222
00:08:46,880 --> 00:08:50,000
um and let's also talk about what's that

223
00:08:48,640 --> 00:08:53,120
weird little character down at the

224
00:08:50,000 --> 00:08:55,040
at the bottom of the screen uh so um

225
00:08:53,120 --> 00:08:56,800
my my son is four and a half years old

226
00:08:55,040 --> 00:08:57,920
watches a lot of cartoons this is a new

227
00:08:56,800 --> 00:08:59,920
toy story cartoon

228
00:08:57,920 --> 00:09:00,959
who starts off a lot of his sentences

229
00:08:59,920 --> 00:09:02,880
asking what is

230
00:09:00,959 --> 00:09:04,800
something so i thought it would be funny

231
00:09:02,880 --> 00:09:06,560
to include him in the slide saying what

232
00:09:04,800 --> 00:09:09,839
is deterministic debugging

233
00:09:06,560 --> 00:09:12,640
it's more for me than it is for you uh

234
00:09:09,839 --> 00:09:13,839
um anyway so just to kind of gauge the

235
00:09:12,640 --> 00:09:16,560
room a little bit

236
00:09:13,839 --> 00:09:19,760
how many people have heard of

237
00:09:16,560 --> 00:09:19,760
deterministic debugging

238
00:09:20,160 --> 00:09:24,160
very few that is perfect that is that is

239
00:09:22,480 --> 00:09:25,440
actually exactly what i wanted to see

240
00:09:24,160 --> 00:09:27,360
and it kind of proves my point that i

241
00:09:25,440 --> 00:09:29,680
think this is an and a relatively

242
00:09:27,360 --> 00:09:32,880
unknown and very underutilized

243
00:09:29,680 --> 00:09:35,920
uh way to debug your programs

244
00:09:32,880 --> 00:09:38,320
so i want to talk a little bit uh about

245
00:09:35,920 --> 00:09:41,199
what it is just to give some context

246
00:09:38,320 --> 00:09:41,839
and then as i mentioned i'll i'll go

247
00:09:41,200 --> 00:09:44,399
into

248
00:09:41,839 --> 00:09:44,880
uh like a pretty deep dive of how it

249
00:09:44,399 --> 00:09:47,040
works

250
00:09:44,880 --> 00:09:48,800
and and the the different kinds of

251
00:09:47,040 --> 00:09:51,839
things that that is done to

252
00:09:48,800 --> 00:09:54,079
uh to actually achieve this so

253
00:09:51,839 --> 00:09:54,959
um one more one more quick question how

254
00:09:54,080 --> 00:09:58,160
many people

255
00:09:54,959 --> 00:09:59,760
have seen the movie groundhog day

256
00:09:58,160 --> 00:10:01,360
a good amount of people okay so for

257
00:09:59,760 --> 00:10:04,079
those who haven't seen it

258
00:10:01,360 --> 00:10:06,320
um it's a movie where bill murray goes

259
00:10:04,079 --> 00:10:07,279
to this town pakistani pennsylvania

260
00:10:06,320 --> 00:10:10,320
where

261
00:10:07,279 --> 00:10:10,959
uh every year actually today on february

262
00:10:10,320 --> 00:10:13,519
2nd

263
00:10:10,959 --> 00:10:15,119
it turns out a groundhog comes out of

264
00:10:13,519 --> 00:10:16,079
the out of the ground and if it sees its

265
00:10:15,120 --> 00:10:18,560
shadow or doesn't

266
00:10:16,079 --> 00:10:20,160
it has some sort of mystical bearing on

267
00:10:18,560 --> 00:10:20,959
on how long the the winter is going to

268
00:10:20,160 --> 00:10:24,399
last

269
00:10:20,959 --> 00:10:27,439
but the the connection here is that

270
00:10:24,399 --> 00:10:29,600
every day uh in this movie that he wakes

271
00:10:27,440 --> 00:10:31,760
up it's groundhog day over and over and

272
00:10:29,600 --> 00:10:34,320
over again he's repeating the same day

273
00:10:31,760 --> 00:10:35,040
over and over and over again every

274
00:10:34,320 --> 00:10:36,720
single day

275
00:10:35,040 --> 00:10:38,959
every time he wakes up for a really long

276
00:10:36,720 --> 00:10:38,959
time

277
00:10:39,120 --> 00:10:44,160
um and the the

278
00:10:42,160 --> 00:10:46,160
no matter what he does no matter what he

279
00:10:44,160 --> 00:10:48,160
changes in in his environment when he

280
00:10:46,160 --> 00:10:49,920
starts the day over again the next day

281
00:10:48,160 --> 00:10:51,839
he goes through the same exact series of

282
00:10:49,920 --> 00:10:53,519
events the same exact people talk to him

283
00:10:51,839 --> 00:10:55,279
and say the same exact things

284
00:10:53,519 --> 00:10:57,279
over and over and over again and this

285
00:10:55,279 --> 00:10:59,040
happens forever well at least for a

286
00:10:57,279 --> 00:11:02,160
really long time

287
00:10:59,040 --> 00:11:03,839
and the connection here is that that's

288
00:11:02,160 --> 00:11:04,319
essentially what deterministic debugging

289
00:11:03,839 --> 00:11:06,560
is

290
00:11:04,320 --> 00:11:08,800
that's what it's trying to achieve so

291
00:11:06,560 --> 00:11:09,518
the point of it is that every single

292
00:11:08,800 --> 00:11:12,479
time you

293
00:11:09,519 --> 00:11:13,440
you start this session debugging what

294
00:11:12,480 --> 00:11:14,320
we're going to get to know as a

295
00:11:13,440 --> 00:11:17,040
recording

296
00:11:14,320 --> 00:11:18,959
everything is exactly the same um and

297
00:11:17,040 --> 00:11:22,000
this includes memory layout uh

298
00:11:18,959 --> 00:11:23,439
signal delivery uh you know

299
00:11:22,000 --> 00:11:25,040
a lot of a lot of the different

300
00:11:23,440 --> 00:11:26,560
variables that may change and may

301
00:11:25,040 --> 00:11:29,360
slightly change how

302
00:11:26,560 --> 00:11:30,560
a bug is is reproduced are always

303
00:11:29,360 --> 00:11:33,600
exactly the same

304
00:11:30,560 --> 00:11:34,479
so as i mentioned before if this if your

305
00:11:33,600 --> 00:11:37,519
bug only

306
00:11:34,480 --> 00:11:39,360
shows up maybe once uh

307
00:11:37,519 --> 00:11:40,640
once in a hundred runs if you capture it

308
00:11:39,360 --> 00:11:42,959
just that one time

309
00:11:40,640 --> 00:11:45,040
you can replay it indefinitely to try to

310
00:11:42,959 --> 00:11:48,319
figure out where the bug is

311
00:11:45,040 --> 00:11:49,839
so how is this possible uh as we know

312
00:11:48,320 --> 00:11:51,200
every time you run a program there's a

313
00:11:49,839 --> 00:11:54,959
lot of things that are different

314
00:11:51,200 --> 00:11:56,880
uh memory layout threads um

315
00:11:54,959 --> 00:11:59,279
uh where where variables are stored in

316
00:11:56,880 --> 00:12:00,480
memory what happens as a result of

317
00:11:59,279 --> 00:12:03,279
certain sys calls

318
00:12:00,480 --> 00:12:05,600
when signals are delivered etc there's a

319
00:12:03,279 --> 00:12:08,079
lot of things that are different

320
00:12:05,600 --> 00:12:09,279
how can we eliminate all of this

321
00:12:08,079 --> 00:12:11,760
non-determinism

322
00:12:09,279 --> 00:12:12,800
and faithfully reproduce the execution

323
00:12:11,760 --> 00:12:16,160
of a process

324
00:12:12,800 --> 00:12:18,560
and as a result faithfully reproduce the

325
00:12:16,160 --> 00:12:21,199
events leading up to the bug that you're

326
00:12:18,560 --> 00:12:21,199
trying to fix

327
00:12:21,360 --> 00:12:24,720
so the solution turns out to be record

328
00:12:22,959 --> 00:12:26,399
and replay uh

329
00:12:24,720 --> 00:12:28,560
and what this what this actually means

330
00:12:26,399 --> 00:12:30,560
is we we essentially record the

331
00:12:28,560 --> 00:12:35,279
execution of a process

332
00:12:30,560 --> 00:12:36,399
um record all uh the different types of

333
00:12:35,279 --> 00:12:38,320
the result of any kind of

334
00:12:36,399 --> 00:12:41,360
non-deterministic operation

335
00:12:38,320 --> 00:12:43,760
and are able to replay that back

336
00:12:41,360 --> 00:12:45,600
so anytime one of those operations is

337
00:12:43,760 --> 00:12:46,079
hit again instead of actually going

338
00:12:45,600 --> 00:12:47,680
through

339
00:12:46,079 --> 00:12:50,560
and doing the operation or making the

340
00:12:47,680 --> 00:12:53,279
actual assist call or anything like that

341
00:12:50,560 --> 00:12:54,800
the the pre-recorded output is just

342
00:12:53,279 --> 00:12:57,040
replayed back to the program

343
00:12:54,800 --> 00:13:00,719
now this turns out to be pretty

344
00:12:57,040 --> 00:13:04,079
difficult but also very very powerful

345
00:13:00,720 --> 00:13:05,680
um now

346
00:13:04,079 --> 00:13:07,199
there's a lot of different types to do

347
00:13:05,680 --> 00:13:08,880
this some are

348
00:13:07,200 --> 00:13:11,360
are kind of better than others i'll i'll

349
00:13:08,880 --> 00:13:14,720
go through a little bit of

350
00:13:11,360 --> 00:13:17,200
of uh existing implementations

351
00:13:14,720 --> 00:13:19,279
so there's vm recording which isn't

352
00:13:17,200 --> 00:13:21,279
actually very widely supported

353
00:13:19,279 --> 00:13:24,320
vmware actually even dropped it from

354
00:13:21,279 --> 00:13:26,000
their uh their virtual machine offering

355
00:13:24,320 --> 00:13:27,760
there's there's a couple things but

356
00:13:26,000 --> 00:13:28,800
they're really clunky really heavyweight

357
00:13:27,760 --> 00:13:30,079
and really

358
00:13:28,800 --> 00:13:32,560
typically you only want to record a

359
00:13:30,079 --> 00:13:34,000
process not the entire execution of the

360
00:13:32,560 --> 00:13:35,119
kernel and operating system and

361
00:13:34,000 --> 00:13:37,760
everything else so

362
00:13:35,120 --> 00:13:39,120
it tends to be bloated and not not very

363
00:13:37,760 --> 00:13:41,040
useful

364
00:13:39,120 --> 00:13:42,399
uh there's also some user space

365
00:13:41,040 --> 00:13:46,079
recording

366
00:13:42,399 --> 00:13:48,639
undo db replay engine and mozilla rr

367
00:13:46,079 --> 00:13:49,439
we'll talk about rr a lot more at in the

368
00:13:48,639 --> 00:13:51,279
end of this talk

369
00:13:49,440 --> 00:13:53,440
there's pros and cons to each so some of

370
00:13:51,279 --> 00:13:55,279
them do code instrumentation which i

371
00:13:53,440 --> 00:13:58,160
personally am not a huge fan of

372
00:13:55,279 --> 00:13:59,519
um uh i think leaving leaving the code

373
00:13:58,160 --> 00:14:01,040
as unchanged as possible

374
00:13:59,519 --> 00:14:02,079
is kind of in the spirit of debugging

375
00:14:01,040 --> 00:14:03,519
you're not you're not trying to change a

376
00:14:02,079 --> 00:14:04,880
person's code you're just trying to

377
00:14:03,519 --> 00:14:07,519
show them what happened so that they can

378
00:14:04,880 --> 00:14:07,519
find the issue

379
00:14:08,160 --> 00:14:11,519
so let's go through some of the pros and

380
00:14:09,680 --> 00:14:12,560
cons real quick of some of the existing

381
00:14:11,519 --> 00:14:15,760
implementations

382
00:14:12,560 --> 00:14:17,199
as i mentioned with vm recording

383
00:14:15,760 --> 00:14:18,880
you have to debug within within a

384
00:14:17,199 --> 00:14:21,920
virtual machine that supports it

385
00:14:18,880 --> 00:14:23,439
that adds a lot of bloat um and

386
00:14:21,920 --> 00:14:25,120
not a lot of virtual machines actually

387
00:14:23,440 --> 00:14:27,440
support this uh

388
00:14:25,120 --> 00:14:28,160
so it's it's really not portable and

389
00:14:27,440 --> 00:14:30,959
doesn't

390
00:14:28,160 --> 00:14:31,680
doesn't tend to work very well with your

391
00:14:30,959 --> 00:14:33,040
workflow

392
00:14:31,680 --> 00:14:35,279
um especially if you're not using a

393
00:14:33,040 --> 00:14:36,000
virtual machine or you're on bare metal

394
00:14:35,279 --> 00:14:38,720
or

395
00:14:36,000 --> 00:14:39,920
just kind of writing code on your laptop

396
00:14:38,720 --> 00:14:42,560
you're probably not running it within a

397
00:14:39,920 --> 00:14:42,560
virtual machine

398
00:14:42,880 --> 00:14:48,000
it produces large traces a lot of bloat

399
00:14:45,760 --> 00:14:50,399
um

400
00:14:48,000 --> 00:14:51,120
it's not widely supported as i mentioned

401
00:14:50,399 --> 00:14:53,600
um

402
00:14:51,120 --> 00:14:54,320
and so let's let's move on to user space

403
00:14:53,600 --> 00:14:57,440
recording

404
00:14:54,320 --> 00:15:00,000
uh it doesn't some problems with that um

405
00:14:57,440 --> 00:15:00,560
it doesn't record kernel execution uh

406
00:15:00,000 --> 00:15:02,240
we'll

407
00:15:00,560 --> 00:15:04,319
i'll explain later why this actually

408
00:15:02,240 --> 00:15:05,760
turns out to not be that big of a deal

409
00:15:04,320 --> 00:15:07,360
as i mentioned some required code

410
00:15:05,760 --> 00:15:10,480
instrumentation the the

411
00:15:07,360 --> 00:15:12,800
the back end that we use does not

412
00:15:10,480 --> 00:15:13,519
so uh it we get rid of that and some

413
00:15:12,800 --> 00:15:15,120
require

414
00:15:13,519 --> 00:15:18,079
some require kernel extensions which

415
00:15:15,120 --> 00:15:20,800
again uh destroys portability

416
00:15:18,079 --> 00:15:22,079
so there's a lot of cons sounds terrible

417
00:15:20,800 --> 00:15:23,599
why am i even talking about it what's

418
00:15:22,079 --> 00:15:26,560
the solution

419
00:15:23,600 --> 00:15:27,199
uh so what we use is mozilla rr and i'll

420
00:15:26,560 --> 00:15:30,319
talk about

421
00:15:27,199 --> 00:15:32,079
how how it works a little bit um but

422
00:15:30,320 --> 00:15:33,759
it it solves a lot of those problems by

423
00:15:32,079 --> 00:15:34,800
not doing not doing any kind of code

424
00:15:33,759 --> 00:15:37,279
instrumentation

425
00:15:34,800 --> 00:15:38,560
it's it's pretty lightweight and and

426
00:15:37,279 --> 00:15:40,000
relatively performant

427
00:15:38,560 --> 00:15:42,479
there are some drawbacks that i'll

428
00:15:40,000 --> 00:15:45,279
discuss a little bit uh especially with

429
00:15:42,480 --> 00:15:46,079
um with certain go programs but it's

430
00:15:45,279 --> 00:15:47,360
still

431
00:15:46,079 --> 00:15:49,359
i think the best solution that we have

432
00:15:47,360 --> 00:15:49,839
available right now and it's a start

433
00:15:49,360 --> 00:15:52,240
right

434
00:15:49,839 --> 00:15:53,759
i think as as kind of shown by the

435
00:15:52,240 --> 00:15:54,000
polling in the room not a lot of people

436
00:15:53,759 --> 00:15:55,759
know

437
00:15:54,000 --> 00:15:57,279
about or are using this technology so i

438
00:15:55,759 --> 00:15:58,880
think as awareness grows

439
00:15:57,279 --> 00:16:00,240
more people can work on it improve it

440
00:15:58,880 --> 00:16:02,399
and we'll get better solutions in the

441
00:16:00,240 --> 00:16:07,680
future but right now

442
00:16:02,399 --> 00:16:09,839
rr is is is the preferred solution

443
00:16:07,680 --> 00:16:10,800
so eliminating sources of

444
00:16:09,839 --> 00:16:12,399
non-determinism

445
00:16:10,800 --> 00:16:15,439
how can we do that and what are some of

446
00:16:12,399 --> 00:16:17,519
the sources of non-determinism

447
00:16:15,440 --> 00:16:19,199
uh so here's a couple that that we can

448
00:16:17,519 --> 00:16:22,399
control right

449
00:16:19,199 --> 00:16:24,719
uh certain cpu instructions so most

450
00:16:22,399 --> 00:16:26,399
cpu instructions are deterministic you

451
00:16:24,720 --> 00:16:27,920
feed them you know

452
00:16:26,399 --> 00:16:29,920
the the input or whatever they do in

453
00:16:27,920 --> 00:16:31,439
operation they put that the results of

454
00:16:29,920 --> 00:16:32,160
that operation in memory or register or

455
00:16:31,440 --> 00:16:34,320
whatever

456
00:16:32,160 --> 00:16:35,439
and uh it's going to be the same every

457
00:16:34,320 --> 00:16:37,279
single time you call it

458
00:16:35,440 --> 00:16:38,800
but there are some that that aren't so

459
00:16:37,279 --> 00:16:40,399
like rd rand a gen

460
00:16:38,800 --> 00:16:42,240
uh instruction to generate random

461
00:16:40,399 --> 00:16:43,360
numbers hopefully that's not

462
00:16:42,240 --> 00:16:47,360
deterministic

463
00:16:43,360 --> 00:16:49,040
um so uh the way to get around this

464
00:16:47,360 --> 00:16:50,720
the way that rr does it is it actually

465
00:16:49,040 --> 00:16:52,079
it turns out it's not used very much

466
00:16:50,720 --> 00:16:53,440
that actual instruction most people

467
00:16:52,079 --> 00:16:55,439
prefer devrandom

468
00:16:53,440 --> 00:16:57,199
so it can just be patched out of

469
00:16:55,440 --> 00:16:59,839
anything that uses it

470
00:16:57,199 --> 00:17:00,240
uh there's also like timestamp counter

471
00:16:59,839 --> 00:17:02,480
uh

472
00:17:00,240 --> 00:17:04,559
instructions um those can actually be

473
00:17:02,480 --> 00:17:07,280
trapped and recorded

474
00:17:04,559 --> 00:17:08,399
and cpu id that's mostly deterministic

475
00:17:07,280 --> 00:17:11,520
if you're running in the same

476
00:17:08,400 --> 00:17:12,000
the same hardware but it does return

477
00:17:11,520 --> 00:17:14,559
which

478
00:17:12,000 --> 00:17:15,919
uh which core the process is running on

479
00:17:14,559 --> 00:17:16,559
that can be different each time so

480
00:17:15,919 --> 00:17:18,720
that's also

481
00:17:16,559 --> 00:17:21,119
trapped and recorded on newer kernels

482
00:17:18,720 --> 00:17:22,959
and intel cpus

483
00:17:21,119 --> 00:17:24,319
uh thread scheduling so this is

484
00:17:22,959 --> 00:17:28,000
important especially for go

485
00:17:24,319 --> 00:17:30,399
uh so what what rr does and and

486
00:17:28,000 --> 00:17:31,360
one of the the kind of performance hits

487
00:17:30,400 --> 00:17:34,640
that it takes

488
00:17:31,360 --> 00:17:37,199
is it runs everything single threaded so

489
00:17:34,640 --> 00:17:38,640
it handles thread scheduling it does do

490
00:17:37,200 --> 00:17:40,880
preemption and things like that

491
00:17:38,640 --> 00:17:42,720
for via signals and everything but it

492
00:17:40,880 --> 00:17:45,280
runs your program single threaded so

493
00:17:42,720 --> 00:17:46,000
for large go programs and programs that

494
00:17:45,280 --> 00:17:47,678
are are

495
00:17:46,000 --> 00:17:49,039
really really highly parallel this could

496
00:17:47,679 --> 00:17:51,840
incur some slow down

497
00:17:49,039 --> 00:17:54,320
um but unfortunately that's that's a

498
00:17:51,840 --> 00:17:57,520
penalty in a price that we have to pay

499
00:17:54,320 --> 00:17:57,520
uh for right now

500
00:17:58,840 --> 00:18:03,199
um so

501
00:18:00,480 --> 00:18:05,120
system calls uh the result of a system

502
00:18:03,200 --> 00:18:09,200
call could potentially be different

503
00:18:05,120 --> 00:18:11,918
uh we can we can trap uh the

504
00:18:09,200 --> 00:18:13,120
um whenever whenever a system call is

505
00:18:11,919 --> 00:18:15,919
executed and inc

506
00:18:13,120 --> 00:18:17,199
and record inputs and outputs so we can

507
00:18:15,919 --> 00:18:20,000
just replay that back

508
00:18:17,200 --> 00:18:20,720
after uh when we're when we're replaying

509
00:18:20,000 --> 00:18:24,160
the

510
00:18:20,720 --> 00:18:26,799
the recording memory layout

511
00:18:24,160 --> 00:18:28,080
again we want to ensure that memories

512
00:18:26,799 --> 00:18:30,000
are that variables are

513
00:18:28,080 --> 00:18:31,918
at the same address and memory because

514
00:18:30,000 --> 00:18:34,480
potentially that leads to a certain

515
00:18:31,919 --> 00:18:35,120
bug or exhibit certain symptoms so we

516
00:18:34,480 --> 00:18:37,200
want to

517
00:18:35,120 --> 00:18:38,639
again we want to recreate the process as

518
00:18:37,200 --> 00:18:40,640
faithfully as we can as

519
00:18:38,640 --> 00:18:43,520
it was executing exactly when it was

520
00:18:40,640 --> 00:18:47,039
first run

521
00:18:43,520 --> 00:18:49,600
shared memory this is a big a big one

522
00:18:47,039 --> 00:18:52,160
actually for non-determinism um

523
00:18:49,600 --> 00:18:53,039
but for for rr again it runs single

524
00:18:52,160 --> 00:18:54,080
threaded so

525
00:18:53,039 --> 00:18:56,400
you don't have to worry about different

526
00:18:54,080 --> 00:18:59,199
threads or whatever within your process

527
00:18:56,400 --> 00:19:00,559
messing with shared memory um there

528
00:18:59,200 --> 00:19:02,640
there are some things where

529
00:19:00,559 --> 00:19:04,000
like the x server and pulse audio and

530
00:19:02,640 --> 00:19:05,520
things like that communicate back and

531
00:19:04,000 --> 00:19:09,039
forth using shared memory but

532
00:19:05,520 --> 00:19:12,320
we there's ways of disabling that

533
00:19:09,039 --> 00:19:15,120
signal handling um so rr

534
00:19:12,320 --> 00:19:15,600
is also able to handle this um we can we

535
00:19:15,120 --> 00:19:18,559
can

536
00:19:15,600 --> 00:19:19,520
uh replay signal execution uh and

537
00:19:18,559 --> 00:19:21,840
delivery

538
00:19:19,520 --> 00:19:23,840
um by using uh hardware performance

539
00:19:21,840 --> 00:19:25,280
counters so basically we can count and

540
00:19:23,840 --> 00:19:26,480
know where we are in the program and

541
00:19:25,280 --> 00:19:28,879
what's happening when that's

542
00:19:26,480 --> 00:19:29,520
when we're at that specific spot so when

543
00:19:28,880 --> 00:19:31,360
a signal

544
00:19:29,520 --> 00:19:33,039
signal is delivered at a certain point

545
00:19:31,360 --> 00:19:34,639
in the execution of the process

546
00:19:33,039 --> 00:19:37,200
we can record when that happens and

547
00:19:34,640 --> 00:19:37,200
replay it

548
00:19:37,520 --> 00:19:41,360
um so some sources that we that we can't

549
00:19:39,760 --> 00:19:42,879
control just really quick

550
00:19:41,360 --> 00:19:44,719
uh we don't control anything that

551
00:19:42,880 --> 00:19:45,120
actually happens outside of user space

552
00:19:44,720 --> 00:19:46,720
but

553
00:19:45,120 --> 00:19:48,320
as i mentioned it turns out we don't

554
00:19:46,720 --> 00:19:51,600
really need to because we just can we

555
00:19:48,320 --> 00:19:55,760
just record the result of that anyways

556
00:19:51,600 --> 00:19:57,199
um so hardware failures

557
00:19:55,760 --> 00:19:58,799
i mean if that's happening you're not

558
00:19:57,200 --> 00:20:02,000
going to have a lot of luck anyways

559
00:19:58,799 --> 00:20:03,600
um so i'm kind of getting a little bit

560
00:20:02,000 --> 00:20:05,039
low on time so i'll kind of go through

561
00:20:03,600 --> 00:20:06,559
some of this pretty quickly to show a

562
00:20:05,039 --> 00:20:09,360
bit of a demo

563
00:20:06,559 --> 00:20:10,639
so some pros and cons pros relatively

564
00:20:09,360 --> 00:20:13,120
low overhead

565
00:20:10,640 --> 00:20:14,960
except for single threaded you can

566
00:20:13,120 --> 00:20:16,320
faithfully reproduce bugs every single

567
00:20:14,960 --> 00:20:18,000
time

568
00:20:16,320 --> 00:20:19,439
you can record a trace and replay it

569
00:20:18,000 --> 00:20:20,240
anywhere so you can record a trace on

570
00:20:19,440 --> 00:20:22,559
your server

571
00:20:20,240 --> 00:20:24,559
and replay it locally for easier

572
00:20:22,559 --> 00:20:26,720
debugging

573
00:20:24,559 --> 00:20:27,600
can execute programs in reverse so you

574
00:20:26,720 --> 00:20:29,600
can go to the

575
00:20:27,600 --> 00:20:31,678
where a bug exhibits itself and kind of

576
00:20:29,600 --> 00:20:33,918
work backwards instead of trying to work

577
00:20:31,679 --> 00:20:35,440
forwards towards the bug and replaying

578
00:20:33,919 --> 00:20:38,559
that every time which i think

579
00:20:35,440 --> 00:20:40,000
turns out to be pretty powerful

580
00:20:38,559 --> 00:20:41,760
you can replay from the beginning

581
00:20:40,000 --> 00:20:44,720
execute the same sequence of events it's

582
00:20:41,760 --> 00:20:46,400
always recorded always the same

583
00:20:44,720 --> 00:20:48,320
cons there's a performance hit for

584
00:20:46,400 --> 00:20:51,679
highly parallel programs

585
00:20:48,320 --> 00:20:53,600
it only works on linux and only works

586
00:20:51,679 --> 00:20:56,960
with

587
00:20:53,600 --> 00:20:58,639
performance counters enabled

588
00:20:56,960 --> 00:21:00,080
so let's talk about how to use it with

589
00:20:58,640 --> 00:21:02,480
delve first

590
00:21:00,080 --> 00:21:03,678
use linux right now it's only supported

591
00:21:02,480 --> 00:21:08,159
on linux

592
00:21:03,679 --> 00:21:11,200
unfortunately osx is not supported um

593
00:21:08,159 --> 00:21:12,400
install install rr mozilla rr that's not

594
00:21:11,200 --> 00:21:13,520
installed for you automatically when you

595
00:21:12,400 --> 00:21:15,600
install delve

596
00:21:13,520 --> 00:21:17,360
and there's three options for using the

597
00:21:15,600 --> 00:21:17,918
rr backend with delve which i'll talk

598
00:21:17,360 --> 00:21:19,600
about

599
00:21:17,919 --> 00:21:22,000
quickly now and then i'll i'll save a

600
00:21:19,600 --> 00:21:23,600
little bit of time still for a demo

601
00:21:22,000 --> 00:21:25,120
so option one is a little bit more

602
00:21:23,600 --> 00:21:27,120
manual

603
00:21:25,120 --> 00:21:28,799
so the the first thing that you're going

604
00:21:27,120 --> 00:21:30,479
to want to do is build your program

605
00:21:28,799 --> 00:21:32,320
again ideally you're building it with

606
00:21:30,480 --> 00:21:33,600
optimizations disabled that's what those

607
00:21:32,320 --> 00:21:36,480
flags are

608
00:21:33,600 --> 00:21:38,158
you use rr and path pass it the path to

609
00:21:36,480 --> 00:21:40,480
your binary it's going to record it

610
00:21:38,159 --> 00:21:43,520
and save a trace somewhere and then you

611
00:21:40,480 --> 00:21:46,880
can use delve to replay that trace

612
00:21:43,520 --> 00:21:49,679
once it once it's completed

613
00:21:46,880 --> 00:21:51,200
uh option two uh is a little is a lot

614
00:21:49,679 --> 00:21:51,760
easier there's one command that just

615
00:21:51,200 --> 00:21:54,000
kind of

616
00:21:51,760 --> 00:21:55,440
does this whole process for you so you

617
00:21:54,000 --> 00:21:58,480
can use the delve debug

618
00:21:55,440 --> 00:22:01,600
uh sub command pass at the back end rr

619
00:21:58,480 --> 00:22:02,320
and then it'll compile the program run

620
00:22:01,600 --> 00:22:04,399
the trace

621
00:22:02,320 --> 00:22:06,559
record it everything and then open it up

622
00:22:04,400 --> 00:22:08,720
so that you can start debugging

623
00:22:06,559 --> 00:22:10,000
um and then last you can use the

624
00:22:08,720 --> 00:22:11,280
scripting feature that i mentioned

625
00:22:10,000 --> 00:22:13,520
earlier so

626
00:22:11,280 --> 00:22:15,120
um this this is actually included in the

627
00:22:13,520 --> 00:22:16,639
documentation on our github so you don't

628
00:22:15,120 --> 00:22:19,600
have to memorize this command

629
00:22:16,640 --> 00:22:21,679
but essentially what it does is uh it

630
00:22:19,600 --> 00:22:24,080
introduces a command called flaky

631
00:22:21,679 --> 00:22:25,360
where it'll rerun the process over and

632
00:22:24,080 --> 00:22:26,240
over and over and over and over again

633
00:22:25,360 --> 00:22:29,678
until

634
00:22:26,240 --> 00:22:32,880
it uh until it hits a bug so it exits um

635
00:22:29,679 --> 00:22:36,000
you know with uh with a bad error code

636
00:22:32,880 --> 00:22:36,799
um and then uh once it once it does that

637
00:22:36,000 --> 00:22:38,240
it'll stop

638
00:22:36,799 --> 00:22:40,158
running the process over and over again

639
00:22:38,240 --> 00:22:42,320
and you'll be debugging that trace so

640
00:22:40,159 --> 00:22:44,400
if you don't want to do this manually

641
00:22:42,320 --> 00:22:44,879
you know make the computer do it right

642
00:22:44,400 --> 00:22:47,120
and

643
00:22:44,880 --> 00:22:48,640
uh once it's done and once it stops

644
00:22:47,120 --> 00:22:51,840
you'll be

645
00:22:48,640 --> 00:22:55,840
you'll be recording uh the uh

646
00:22:51,840 --> 00:22:57,678
the bug so let me do a quick little demo

647
00:22:55,840 --> 00:23:01,840
just to show

648
00:22:57,679 --> 00:23:01,840
how how some of this stuff works

649
00:23:06,840 --> 00:23:09,840
um

650
00:23:10,159 --> 00:23:17,760
okay i'll be really quick okay uh so

651
00:23:13,280 --> 00:23:17,760
um as mentioned you can just um

652
00:23:18,960 --> 00:23:23,440
debug with back-end rr um it's recorded

653
00:23:22,000 --> 00:23:25,200
you can see the output of the run of the

654
00:23:23,440 --> 00:23:29,440
program um

655
00:23:25,200 --> 00:23:31,360
and uh now we're actually

656
00:23:29,440 --> 00:23:32,480
we're actually debugging the trace so if

657
00:23:31,360 --> 00:23:35,520
we set a breakpoint

658
00:23:32,480 --> 00:23:37,039
at main continue

659
00:23:35,520 --> 00:23:38,799
we can see some of the things that it's

660
00:23:37,039 --> 00:23:39,840
doing right so it's saying it's asking

661
00:23:38,799 --> 00:23:41,440
what date it is

662
00:23:39,840 --> 00:23:43,279
printing that out and it's also opening

663
00:23:41,440 --> 00:23:45,120
devrandom um

664
00:23:43,279 --> 00:23:47,440
which should be different every time

665
00:23:45,120 --> 00:23:52,158
right so if we

666
00:23:47,440 --> 00:23:54,960
if we next a little bit we can see um

667
00:23:52,159 --> 00:23:55,679
we read we read from dev random uh and

668
00:23:54,960 --> 00:23:58,080
if we print

669
00:23:55,679 --> 00:23:59,120
the result of that so like the bytes

670
00:23:58,080 --> 00:24:02,480
that we have

671
00:23:59,120 --> 00:24:04,239
um you can see kind of roughly just

672
00:24:02,480 --> 00:24:05,760
the output that we get right so just

673
00:24:04,240 --> 00:24:09,360
remember the first two

674
00:24:05,760 --> 00:24:12,960
180 183 uh so let's

675
00:24:09,360 --> 00:24:17,199
set a breakpoint here on our test i go

676
00:24:12,960 --> 00:24:19,120
24. um so we'll restart we're restarting

677
00:24:17,200 --> 00:24:21,279
um all the way from the beginning again

678
00:24:19,120 --> 00:24:22,959
continue continue again to our second

679
00:24:21,279 --> 00:24:23,919
break point and if we print the value of

680
00:24:22,960 --> 00:24:26,960
that variable again

681
00:24:23,919 --> 00:24:29,360
we see it's exactly the same um

682
00:24:26,960 --> 00:24:31,120
so even even complete sources of

683
00:24:29,360 --> 00:24:32,479
randomness will be replayed faithfully

684
00:24:31,120 --> 00:24:34,639
every single time

685
00:24:32,480 --> 00:24:36,080
and just to show that it's not a trick

686
00:24:34,640 --> 00:24:39,279
uh

687
00:24:36,080 --> 00:24:41,678
you can see when i run it for real

688
00:24:39,279 --> 00:24:43,360
every single time the output is actually

689
00:24:41,679 --> 00:24:44,799
different so we are recording and we're

690
00:24:43,360 --> 00:25:00,639
playing faithfully

691
00:24:44,799 --> 00:25:00,639
and that's time thank you very much

