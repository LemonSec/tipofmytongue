1
00:00:04,960 --> 00:00:11,440
hi everyone thank you for coming

2
00:00:07,279 --> 00:00:14,000
um yeah so i'm happy to introduce

3
00:00:11,440 --> 00:00:16,160
suraj is going to talk about dissecting

4
00:00:14,000 --> 00:00:20,120
the inline keyword in kotlin

5
00:00:16,160 --> 00:00:22,400
so please welcome him thank you hi

6
00:00:20,120 --> 00:00:25,119
[Applause]

7
00:00:22,400 --> 00:00:25,840
um so i'm suraj i'm going to be talking

8
00:00:25,119 --> 00:00:28,800
about

9
00:00:25,840 --> 00:00:31,359
dissecting the inline keyword in kotlin

10
00:00:28,800 --> 00:00:34,480
before i begin uh a bit about myself

11
00:00:31,359 --> 00:00:36,800
so i uh i'm an android developer i

12
00:00:34,480 --> 00:00:38,559
write i have contributed to firefox the

13
00:00:36,800 --> 00:00:40,718
 stitch sdk

14
00:00:38,559 --> 00:00:42,160
and the real message on client as well

15
00:00:40,719 --> 00:00:43,920
uh i

16
00:00:42,160 --> 00:00:45,519
was writing java before then i switched

17
00:00:43,920 --> 00:00:46,719
to kotlin and now i'm actually exploring

18
00:00:45,520 --> 00:00:49,920
golang a bit

19
00:00:46,719 --> 00:00:51,920
uh i did android and now i've

20
00:00:49,920 --> 00:00:53,440
moved to back in mostly i am pretty

21
00:00:51,920 --> 00:00:55,360
active on twitter and

22
00:00:53,440 --> 00:00:57,519
you can email me questions about slides

23
00:00:55,360 --> 00:01:00,079
etc etc if you have

24
00:00:57,520 --> 00:01:01,359
um i work at a company called q talk

25
00:01:00,079 --> 00:01:03,199
it's mostly uh

26
00:01:01,359 --> 00:01:04,720
it's a company about synchronous

27
00:01:03,199 --> 00:01:07,360
communication making it fun

28
00:01:04,720 --> 00:01:09,439
like you can do play games and browse

29
00:01:07,360 --> 00:01:12,240
the web together all over a call

30
00:01:09,439 --> 00:01:12,798
it is 100 kotlin uh client and back-end

31
00:01:12,240 --> 00:01:14,880
code

32
00:01:12,799 --> 00:01:16,159
and we are also the default dialer on

33
00:01:14,880 --> 00:01:17,920
android so it's pretty

34
00:01:16,159 --> 00:01:19,680
heavy engineering that goes on too and

35
00:01:17,920 --> 00:01:23,840
all of it is in kotlin

36
00:01:19,680 --> 00:01:28,560
um there there are some links to it

37
00:01:23,840 --> 00:01:30,159
cool so um inline keyword um

38
00:01:28,560 --> 00:01:31,680
when we are actually writing a lambda or

39
00:01:30,159 --> 00:01:34,720
something in kotlin

40
00:01:31,680 --> 00:01:36,560
uh the ide mostly prompts us that try

41
00:01:34,720 --> 00:01:38,560
using an inline keyboard for it

42
00:01:36,560 --> 00:01:40,159
but why do we actually use it like why

43
00:01:38,560 --> 00:01:42,799
do we need it why can't the compile

44
00:01:40,159 --> 00:01:44,560
actually do it like automatically for us

45
00:01:42,799 --> 00:01:46,399
so basically the meaning of inline

46
00:01:44,560 --> 00:01:48,320
actually goes for like placing things or

47
00:01:46,399 --> 00:01:51,119
arranging them in a line or doing things

48
00:01:48,320 --> 00:01:52,639
just like like in a line but if it's

49
00:01:51,119 --> 00:01:53,360
that simple then why why does scotland

50
00:01:52,640 --> 00:01:54,960
need an actual

51
00:01:53,360 --> 00:01:58,000
a keyword for it like why can't the

52
00:01:54,960 --> 00:02:00,719
compiler automatically do it for you

53
00:01:58,000 --> 00:02:01,759
there are multiple aspects over here uh

54
00:02:00,719 --> 00:02:03,919
if we can drill down

55
00:02:01,759 --> 00:02:04,880
mostly into the version of java that

56
00:02:03,920 --> 00:02:07,360
actually

57
00:02:04,880 --> 00:02:08,799
plays underlining then we can actually

58
00:02:07,360 --> 00:02:11,599
dig deeper into it

59
00:02:08,800 --> 00:02:13,200
so java version compatibility uh let's

60
00:02:11,599 --> 00:02:15,200
start with lambdas

61
00:02:13,200 --> 00:02:16,799
uh lambdas as we all know higher order

62
00:02:15,200 --> 00:02:19,280
functions are anonymous functions

63
00:02:16,800 --> 00:02:20,640
uh they were introduced in java from

64
00:02:19,280 --> 00:02:22,640
java eight

65
00:02:20,640 --> 00:02:24,160
uh they are mostly implemented in java

66
00:02:22,640 --> 00:02:27,599
using functional interfaces

67
00:02:24,160 --> 00:02:29,040
and they leverage on a specific bytecode

68
00:02:27,599 --> 00:02:31,518
instruction that was that was introduced

69
00:02:29,040 --> 00:02:33,760
in java 7 called as invoke dynamic

70
00:02:31,519 --> 00:02:35,760
it's a it's a very special uh bytecode

71
00:02:33,760 --> 00:02:38,959
instruction which does a lot of things

72
00:02:35,760 --> 00:02:41,519
around it but uh after like since

73
00:02:38,959 --> 00:02:42,239
it was introduced in java seven like uh

74
00:02:41,519 --> 00:02:44,720
it

75
00:02:42,239 --> 00:02:46,400
and lambdas are pretty important in uh

76
00:02:44,720 --> 00:02:49,519
constructed programming

77
00:02:46,400 --> 00:02:52,400
uh we lose a lot of stuff if we uh just

78
00:02:49,519 --> 00:02:53,200
like try targeting into java 8. so we

79
00:02:52,400 --> 00:02:55,519
it's

80
00:02:53,200 --> 00:02:57,920
better like in order to have it working

81
00:02:55,519 --> 00:03:01,120
for like java version 6 etc we need to

82
00:02:57,920 --> 00:03:02,958
have tools like retro lambda etc etc

83
00:03:01,120 --> 00:03:04,560
now the question is if we have tools

84
00:03:02,959 --> 00:03:06,560
like retro lambda and all of these

85
00:03:04,560 --> 00:03:08,400
components around it why actually

86
00:03:06,560 --> 00:03:09,920
take up the effort like why does it how

87
00:03:08,400 --> 00:03:12,720
does it even affect kotlin

88
00:03:09,920 --> 00:03:14,480
so the ideology around kotlin is that it

89
00:03:12,720 --> 00:03:17,280
tries to do more things natively rather

90
00:03:14,480 --> 00:03:20,480
than using more number of libraries or

91
00:03:17,280 --> 00:03:22,720
tools around it and why should we care

92
00:03:20,480 --> 00:03:23,280
since it's java 6 and you have java 14

93
00:03:22,720 --> 00:03:25,280
coming

94
00:03:23,280 --> 00:03:26,640
and a lot of things have changed in our

95
00:03:25,280 --> 00:03:29,040
world like why why even

96
00:03:26,640 --> 00:03:30,720
care about java 6 the problem over here

97
00:03:29,040 --> 00:03:33,200
is that it's android

98
00:03:30,720 --> 00:03:33,760
so android and java 6 are like android

99
00:03:33,200 --> 00:03:35,119
is pretty

100
00:03:33,760 --> 00:03:37,840
much holding back the entire java

101
00:03:35,120 --> 00:03:41,280
ecosystem all together because um

102
00:03:37,840 --> 00:03:44,239
java 8 and android 7.1 which is uh

103
00:03:41,280 --> 00:03:45,680
no android 7 actually was the first

104
00:03:44,239 --> 00:03:48,799
version of android started

105
00:03:45,680 --> 00:03:50,239
which introduced java 8. so yeah we

106
00:03:48,799 --> 00:03:53,360
should care because of

107
00:03:50,239 --> 00:03:53,760
java 6 and android mostly so that is the

108
00:03:53,360 --> 00:03:56,560
whole

109
00:03:53,760 --> 00:03:57,359
uh need of the of the inline keyword is

110
00:03:56,560 --> 00:03:59,840
because

111
00:03:57,360 --> 00:04:01,599
you can't actually have it working below

112
00:03:59,840 --> 00:04:05,200
java 7 below java 8

113
00:04:01,599 --> 00:04:07,599
7 and 8 actually yeah

114
00:04:05,200 --> 00:04:09,119
so let's start with the why how so how

115
00:04:07,599 --> 00:04:11,280
does actually kotlin achieve it

116
00:04:09,120 --> 00:04:13,040
since we if you know that kotlin

117
00:04:11,280 --> 00:04:14,319
compiles to java byte code and if the

118
00:04:13,040 --> 00:04:15,120
bytecode instruction itself is not

119
00:04:14,319 --> 00:04:16,798
present

120
00:04:15,120 --> 00:04:18,320
then how how would how would actually

121
00:04:16,798 --> 00:04:21,198
achieve it so

122
00:04:18,320 --> 00:04:23,440
before we move there like uh let's once

123
00:04:21,199 --> 00:04:25,280
again dive into lambdas and closures and

124
00:04:23,440 --> 00:04:27,040
a few concepts around them

125
00:04:25,280 --> 00:04:29,280
so kotlin lambdas are actually different

126
00:04:27,040 --> 00:04:32,320
than the lambdas which you have in java

127
00:04:29,280 --> 00:04:34,320
kotlin lambdas are mostly implemented

128
00:04:32,320 --> 00:04:37,199
using function types

129
00:04:34,320 --> 00:04:39,199
uh so you actually have a class called

130
00:04:37,199 --> 00:04:40,720
functions.kt which has function

131
00:04:39,199 --> 00:04:42,240
like which has interfaces from function

132
00:04:40,720 --> 00:04:43,520
0 to function 32

133
00:04:42,240 --> 00:04:44,560
based on the number of parameter

134
00:04:43,520 --> 00:04:45,919
arguments you have in a function like

135
00:04:44,560 --> 00:04:47,759
function 0 having 0 arguments and

136
00:04:45,919 --> 00:04:48,479
function 32 have a 32 having 32

137
00:04:47,759 --> 00:04:50,400
arguments

138
00:04:48,479 --> 00:04:52,639
there's actually an interesting key for

139
00:04:50,400 --> 00:04:54,000
expanding it to function 255 which is

140
00:04:52,639 --> 00:04:56,560
the maximum number of arguments you can

141
00:04:54,000 --> 00:04:58,639
have in java um

142
00:04:56,560 --> 00:05:00,560
and the reason why java java does it or

143
00:04:58,639 --> 00:05:03,360
content does it this way is because

144
00:05:00,560 --> 00:05:04,320
um in kotlin functions are first-class

145
00:05:03,360 --> 00:05:07,280
citizens

146
00:05:04,320 --> 00:05:08,719
like um like null pointer exception is a

147
00:05:07,280 --> 00:05:10,479
foster class

148
00:05:08,720 --> 00:05:13,039
nullability is a first-class citizen in

149
00:05:10,479 --> 00:05:14,800
kotlin similarly functions are also a

150
00:05:13,039 --> 00:05:18,639
first-class citizen in kotlin

151
00:05:14,800 --> 00:05:19,440
meaning that um you are you can actually

152
00:05:18,639 --> 00:05:21,520
assign a video

153
00:05:19,440 --> 00:05:24,080
you can assign a function to a variable

154
00:05:21,520 --> 00:05:26,400
invoker functions object later on

155
00:05:24,080 --> 00:05:28,159
pass a function to a function etc etc

156
00:05:26,400 --> 00:05:28,719
and that's the reason why you do it this

157
00:05:28,160 --> 00:05:30,880
way

158
00:05:28,720 --> 00:05:32,800
closures closures on the other hand uh

159
00:05:30,880 --> 00:05:35,759
it's more of a programming concept

160
00:05:32,800 --> 00:05:37,680
it's like it's more related to a lambda

161
00:05:35,759 --> 00:05:39,280
anything which is outside the scope of a

162
00:05:37,680 --> 00:05:40,639
lambre and if it's consumed inside

163
00:05:39,280 --> 00:05:42,559
captured inside a lambda then you call

164
00:05:40,639 --> 00:05:44,240
it a closure

165
00:05:42,560 --> 00:05:46,160
that's just basic concepts which you're

166
00:05:44,240 --> 00:05:48,400
going to use further down the slide so

167
00:05:46,160 --> 00:05:50,400
it's just good to have it clear all of

168
00:05:48,400 --> 00:05:52,239
this if you just see it programmatically

169
00:05:50,400 --> 00:05:54,239
once i have the code is legible

170
00:05:52,240 --> 00:05:55,280
so if you if you consider this example

171
00:05:54,240 --> 00:05:56,000
we're going to use this example

172
00:05:55,280 --> 00:05:57,758
throughout

173
00:05:56,000 --> 00:06:00,080
so we have a function called as test

174
00:05:57,759 --> 00:06:03,120
lambdas which has a lambda

175
00:06:00,080 --> 00:06:06,560
my lambda and we have this

176
00:06:03,120 --> 00:06:08,800
this uh sorry i'm so sorry

177
00:06:06,560 --> 00:06:10,000
and we have this uh my big loop which is

178
00:06:08,800 --> 00:06:11,600
actually the uh

179
00:06:10,000 --> 00:06:13,120
implementation of that lambda which

180
00:06:11,600 --> 00:06:15,360
consumes the lambda and you have this

181
00:06:13,120 --> 00:06:16,960
value value enclosure which actually

182
00:06:15,360 --> 00:06:18,479
does nothing but just prints the value

183
00:06:16,960 --> 00:06:20,960
inside the lambda which is

184
00:06:18,479 --> 00:06:22,880
test lambda and the lambda value so this

185
00:06:20,960 --> 00:06:24,400
is lambda's enclosures

186
00:06:22,880 --> 00:06:26,240
we'll move on to the next concept which

187
00:06:24,400 --> 00:06:28,719
is call sites

188
00:06:26,240 --> 00:06:30,960
um so call sites again are mostly a

189
00:06:28,720 --> 00:06:33,039
concept which is related to lambdas

190
00:06:30,960 --> 00:06:34,080
and it's basically where you actually

191
00:06:33,039 --> 00:06:35,680
call a call site

192
00:06:34,080 --> 00:06:37,120
so mostly when we're actually debugging

193
00:06:35,680 --> 00:06:38,800
on the java application onto java

194
00:06:37,120 --> 00:06:41,039
application on content applications

195
00:06:38,800 --> 00:06:42,479
using ide like uh android studio or

196
00:06:41,039 --> 00:06:44,159
intellij you actually

197
00:06:42,479 --> 00:06:46,000
find an option for lambda function which

198
00:06:44,160 --> 00:06:48,800
is um if you press

199
00:06:46,000 --> 00:06:50,000
like jump to jump to source you actually

200
00:06:48,800 --> 00:06:53,039
find two options which is

201
00:06:50,000 --> 00:06:53,599
um check the source or check the call

202
00:06:53,039 --> 00:06:54,960
site

203
00:06:53,599 --> 00:06:56,719
so call site is basically where you

204
00:06:54,960 --> 00:06:58,719
actually call the function

205
00:06:56,720 --> 00:07:00,160
uh there's a bug in this there's a

206
00:06:58,720 --> 00:07:01,440
there's a mistake in this code is that

207
00:07:00,160 --> 00:07:04,240
there's no lambda actually

208
00:07:01,440 --> 00:07:04,960
but still yeah so if if print me was a

209
00:07:04,240 --> 00:07:07,440
lambda

210
00:07:04,960 --> 00:07:10,638
and it was being consumed then i imgroot

211
00:07:07,440 --> 00:07:13,440
would be the calling set for that lambda

212
00:07:10,639 --> 00:07:13,840
non-inline lambdas before we actually

213
00:07:13,440 --> 00:07:16,080
see

214
00:07:13,840 --> 00:07:17,840
how lambdas are and what do they do it

215
00:07:16,080 --> 00:07:18,960
would be a good point of reference to

216
00:07:17,840 --> 00:07:21,359
actually know

217
00:07:18,960 --> 00:07:22,479
what how non-inline lambdas would look

218
00:07:21,360 --> 00:07:24,960
like because

219
00:07:22,479 --> 00:07:25,758
there is a lot of an optimization like

220
00:07:24,960 --> 00:07:27,120
we'll actually

221
00:07:25,759 --> 00:07:30,080
get to see the difference between onion

222
00:07:27,120 --> 00:07:33,599
and lambdas and inline lambdas

223
00:07:30,080 --> 00:07:34,159
so um we'll uh consider the same example

224
00:07:33,599 --> 00:07:36,319
as before

225
00:07:34,160 --> 00:07:38,160
we have a test lambda which is our

226
00:07:36,319 --> 00:07:40,000
lambda function we have our

227
00:07:38,160 --> 00:07:41,440
my big loop which is consuming the

228
00:07:40,000 --> 00:07:44,160
lambda and

229
00:07:41,440 --> 00:07:44,800
it's gonna iterate like we have an int

230
00:07:44,160 --> 00:07:47,440
range

231
00:07:44,800 --> 00:07:48,639
which is 0 to 50 both inclusive and it's

232
00:07:47,440 --> 00:07:50,800
going to run a loop

233
00:07:48,639 --> 00:07:52,080
and it's going to call the lambda for

234
00:07:50,800 --> 00:07:54,639
the

235
00:07:52,080 --> 00:07:56,639
number of times the loop is going to run

236
00:07:54,639 --> 00:07:58,080
so uh this is the and the logical logic

237
00:07:56,639 --> 00:07:59,520
part of it which is a test lambdas

238
00:07:58,080 --> 00:08:00,159
function which is a lambda being called

239
00:07:59,520 --> 00:08:02,560
and printing

240
00:08:00,160 --> 00:08:04,560
a particular variable this is

241
00:08:02,560 --> 00:08:06,479
essentially the logical part of it

242
00:08:04,560 --> 00:08:08,400
now let's let's take a step ahead and

243
00:08:06,479 --> 00:08:11,680
try to try decompiling this

244
00:08:08,400 --> 00:08:12,560
source code and assembling it into java

245
00:08:11,680 --> 00:08:14,560
again

246
00:08:12,560 --> 00:08:18,000
so if we do that we see something like

247
00:08:14,560 --> 00:08:20,960
this this a huge block of code which is

248
00:08:18,000 --> 00:08:22,400
a lot of compiler injected code which we

249
00:08:20,960 --> 00:08:24,159
actually don't care about

250
00:08:22,400 --> 00:08:26,560
but the interesting concept over here is

251
00:08:24,160 --> 00:08:29,759
that the test lambdas our function

252
00:08:26,560 --> 00:08:32,080
was actually compiled into a class

253
00:08:29,759 --> 00:08:33,440
which actually implements a function one

254
00:08:32,080 --> 00:08:35,760
type interface

255
00:08:33,440 --> 00:08:36,640
and we know function one because it has

256
00:08:35,760 --> 00:08:38,240
one argument

257
00:08:36,640 --> 00:08:39,519
so if hence this function were different

258
00:08:38,240 --> 00:08:40,240
at zero arguments it would be function

259
00:08:39,519 --> 00:08:43,039
zero

260
00:08:40,240 --> 00:08:44,720
and it exchanged a lambda so your method

261
00:08:43,039 --> 00:08:46,480
having a lambda actually is compiled

262
00:08:44,720 --> 00:08:48,959
into a class now

263
00:08:46,480 --> 00:08:51,040
uh class extending lambda and

264
00:08:48,959 --> 00:08:53,599
implementing the function one interface

265
00:08:51,040 --> 00:08:54,719
and the logic for that particular lambda

266
00:08:53,600 --> 00:08:56,320
inside the invoke

267
00:08:54,720 --> 00:08:59,040
which is just printing a particular

268
00:08:56,320 --> 00:09:01,600
variable and if you see the call site

269
00:08:59,040 --> 00:09:03,519
this is where the actual problem begins

270
00:09:01,600 --> 00:09:04,240
uh the call site looks something like

271
00:09:03,519 --> 00:09:05,839
this

272
00:09:04,240 --> 00:09:08,080
again it's a lot of compiler injected

273
00:09:05,839 --> 00:09:10,720
code which we do not care for much

274
00:09:08,080 --> 00:09:12,880
if you look at the lambda exec like the

275
00:09:10,720 --> 00:09:15,200
lambda method being invoked specifically

276
00:09:12,880 --> 00:09:17,600
you see the test lambda function

277
00:09:15,200 --> 00:09:19,120
called along with the lambda which is

278
00:09:17,600 --> 00:09:21,440
actually and

279
00:09:19,120 --> 00:09:23,440
a new instance of of the particular

280
00:09:21,440 --> 00:09:24,880
class we just saw

281
00:09:23,440 --> 00:09:27,120
the problem is here with the new

282
00:09:24,880 --> 00:09:28,880
instance is that it will create a new

283
00:09:27,120 --> 00:09:31,760
instance for every time the iteration

284
00:09:28,880 --> 00:09:33,360
for every time the uh the iteration will

285
00:09:31,760 --> 00:09:34,959
run like

286
00:09:33,360 --> 00:09:37,040
and it has been converted into an

287
00:09:34,959 --> 00:09:38,239
integrable because of interrange

288
00:09:37,040 --> 00:09:41,519
interest compiles to

289
00:09:38,240 --> 00:09:42,720
an iterable in java so that is a problem

290
00:09:41,519 --> 00:09:47,519
so you'll actually have

291
00:09:42,720 --> 00:09:50,320
50 instances or 51 instances technically

292
00:09:47,519 --> 00:09:51,200
of the inline function that is going to

293
00:09:50,320 --> 00:09:52,800
happen

294
00:09:51,200 --> 00:09:55,040
it's pretty bad and so this is the worst

295
00:09:52,800 --> 00:09:56,399
case scenario but kotlin compiler is a

296
00:09:55,040 --> 00:09:59,360
bit smart it also has a

297
00:09:56,399 --> 00:10:00,880
semi optimized scenario wherein if you

298
00:09:59,360 --> 00:10:02,560
don't have a closure

299
00:10:00,880 --> 00:10:03,920
it optimizes some things because if you

300
00:10:02,560 --> 00:10:06,000
don't have a closure it does not have to

301
00:10:03,920 --> 00:10:07,360
create a stack for you for every method

302
00:10:06,000 --> 00:10:09,600
in order to capture the variable that

303
00:10:07,360 --> 00:10:12,000
you have for that so for non-inline

304
00:10:09,600 --> 00:10:13,519
in for uh non-in-line lambdas without

305
00:10:12,000 --> 00:10:14,800
closure you don't actually have to care

306
00:10:13,519 --> 00:10:16,240
about much because there'll just be a

307
00:10:14,800 --> 00:10:17,279
singleton instance of that particular

308
00:10:16,240 --> 00:10:20,079
lambda

309
00:10:17,279 --> 00:10:22,800
if we if we take the similar example as

310
00:10:20,079 --> 00:10:23,920
we've seen before except for the closure

311
00:10:22,800 --> 00:10:25,519
you can see that there's no closure

312
00:10:23,920 --> 00:10:27,519
there's just println you're just

313
00:10:25,519 --> 00:10:29,200
consuming the value of the lambda within

314
00:10:27,519 --> 00:10:30,880
the lambda

315
00:10:29,200 --> 00:10:33,040
and if you try decompiling this source

316
00:10:30,880 --> 00:10:34,640
code you see that and you just

317
00:10:33,040 --> 00:10:36,800
print the call set because the lambda

318
00:10:34,640 --> 00:10:39,760
won't actually change it's only the

319
00:10:36,800 --> 00:10:40,560
call side that actually changes and you

320
00:10:39,760 --> 00:10:42,560
can see

321
00:10:40,560 --> 00:10:43,760
there's you don't have a new instance of

322
00:10:42,560 --> 00:10:44,399
it running every time you just have a

323
00:10:43,760 --> 00:10:47,439
singleton

324
00:10:44,399 --> 00:10:48,800
instance being created it's still a bad

325
00:10:47,440 --> 00:10:53,120
thing because functions

326
00:10:48,800 --> 00:10:56,079
are technically native or technically

327
00:10:53,120 --> 00:10:56,720
more of like a very strong construct

328
00:10:56,079 --> 00:10:58,839
inside

329
00:10:56,720 --> 00:11:00,240
java so like it would not be good if we

330
00:10:58,839 --> 00:11:02,160
have

331
00:11:00,240 --> 00:11:03,440
an instance of it every time even though

332
00:11:02,160 --> 00:11:04,880
even though it's a singleton instance

333
00:11:03,440 --> 00:11:06,160
because if you have n number of lambdas

334
00:11:04,880 --> 00:11:07,519
you'll actually have n number of

335
00:11:06,160 --> 00:11:09,040
instances which you wouldn't have

336
00:11:07,519 --> 00:11:11,200
otherwise

337
00:11:09,040 --> 00:11:12,079
uh also it's not the way how java does

338
00:11:11,200 --> 00:11:13,920
java uses

339
00:11:12,079 --> 00:11:16,160
the invoke dynamic keyboard which

340
00:11:13,920 --> 00:11:18,640
bytecode which kotlin does not

341
00:11:16,160 --> 00:11:19,600
to maintain compatibility so this is how

342
00:11:18,640 --> 00:11:21,519
this is the worst case

343
00:11:19,600 --> 00:11:23,360
second this is a semi-optimized scenario

344
00:11:21,519 --> 00:11:26,079
wherein you don't have

345
00:11:23,360 --> 00:11:28,240
the new instance created every time now

346
00:11:26,079 --> 00:11:29,839
how about inline lambdas

347
00:11:28,240 --> 00:11:31,839
how how do they look when you decompile

348
00:11:29,839 --> 00:11:33,279
them let's take a similar example from

349
00:11:31,839 --> 00:11:34,800
before where you have a test lambda and

350
00:11:33,279 --> 00:11:36,640
your lambda and the

351
00:11:34,800 --> 00:11:38,160
and the loop which is consuming it the

352
00:11:36,640 --> 00:11:40,480
same number of iterations

353
00:11:38,160 --> 00:11:42,079
all all we do now is just modify it by

354
00:11:40,480 --> 00:11:43,440
adding one particular keyboard which is

355
00:11:42,079 --> 00:11:45,760
inline

356
00:11:43,440 --> 00:11:46,880
and just again just put it inside the

357
00:11:45,760 --> 00:11:48,560
decompiler and just

358
00:11:46,880 --> 00:11:50,560
throw out let's try printing the java

359
00:11:48,560 --> 00:11:51,839
code out of it and if you see

360
00:11:50,560 --> 00:11:53,599
the code this time is different you

361
00:11:51,839 --> 00:11:54,399
don't have this is this is all that you

362
00:11:53,600 --> 00:11:56,720
get from it

363
00:11:54,399 --> 00:11:58,240
you have no classes you have no uh

364
00:11:56,720 --> 00:11:59,680
instances you have no implementation of

365
00:11:58,240 --> 00:12:01,839
functional interfaces

366
00:11:59,680 --> 00:12:03,359
no class which extension lambda nothing

367
00:12:01,839 --> 00:12:04,880
this is the only thing which you get you

368
00:12:03,360 --> 00:12:06,160
have two static functions in the test

369
00:12:04,880 --> 00:12:08,079
lambda and the myback loop which you

370
00:12:06,160 --> 00:12:10,800
actually had in java as well

371
00:12:08,079 --> 00:12:12,239
now here is the fun part which begins is

372
00:12:10,800 --> 00:12:14,319
that if you

373
00:12:12,240 --> 00:12:16,240
if you see inside the uh my big loop

374
00:12:14,320 --> 00:12:17,120
function you see the value enclosures

375
00:12:16,240 --> 00:12:18,639
actually accepting the

376
00:12:17,120 --> 00:12:20,240
so this was the worst case scenario it

377
00:12:18,639 --> 00:12:21,920
it's actually having the closure as well

378
00:12:20,240 --> 00:12:23,600
inside the lambda

379
00:12:21,920 --> 00:12:25,040
it has a loop as well but it has no

380
00:12:23,600 --> 00:12:27,040
instances nothing

381
00:12:25,040 --> 00:12:29,199
it's just like compiler copy paste is

382
00:12:27,040 --> 00:12:32,399
just everything is inlined it has taken

383
00:12:29,200 --> 00:12:35,600
the logical block from your lambda

384
00:12:32,399 --> 00:12:38,639
taken it out and printed into your

385
00:12:35,600 --> 00:12:39,760
call site this is the actual power of

386
00:12:38,639 --> 00:12:42,720
inline and

387
00:12:39,760 --> 00:12:43,200
it's magical in many ways because it not

388
00:12:42,720 --> 00:12:45,360
this

389
00:12:43,200 --> 00:12:47,519
infrastructure forms the basis of many

390
00:12:45,360 --> 00:12:48,800
things in kotlin it forms the basis for

391
00:12:47,519 --> 00:12:50,959
sequences

392
00:12:48,800 --> 00:12:53,199
street uh which is which are equivalent

393
00:12:50,959 --> 00:12:54,319
to streams in java it forms the basis

394
00:12:53,200 --> 00:12:56,800
for

395
00:12:54,320 --> 00:12:58,560
uh you have for each and all of these

396
00:12:56,800 --> 00:13:00,079
functions and you have

397
00:12:58,560 --> 00:13:02,000
in fact anything which leverages on the

398
00:13:00,079 --> 00:13:04,160
lambda architecture actually uses inline

399
00:13:02,000 --> 00:13:06,000
internally you have core routines also

400
00:13:04,160 --> 00:13:08,639
because of their entire syntax you have

401
00:13:06,000 --> 00:13:12,720
keywords like apply etc etc

402
00:13:08,639 --> 00:13:14,560
so um it is it it

403
00:13:12,720 --> 00:13:15,839
just doesn't stop there you have other

404
00:13:14,560 --> 00:13:19,199
aspects as well

405
00:13:15,839 --> 00:13:24,079
for example one of the like the real

406
00:13:19,200 --> 00:13:27,200
power over here is type verification um

407
00:13:24,079 --> 00:13:28,479
so if we if we were to define how the

408
00:13:27,200 --> 00:13:30,399
verified keyboard or the

409
00:13:28,480 --> 00:13:31,839
uh the entire verification mechanism

410
00:13:30,399 --> 00:13:34,160
it's actually it means

411
00:13:31,839 --> 00:13:36,399
making something concrete or having

412
00:13:34,160 --> 00:13:39,600
something survive

413
00:13:36,399 --> 00:13:40,240
uh through a lot of stages so and the

414
00:13:39,600 --> 00:13:43,120
context for

415
00:13:40,240 --> 00:13:43,680
it definitely is generics so if you if

416
00:13:43,120 --> 00:13:45,760
you take

417
00:13:43,680 --> 00:13:48,399
java for example how many of you over

418
00:13:45,760 --> 00:13:49,760
here know java type erasure type raise

419
00:13:48,399 --> 00:13:51,519
your concepts in java

420
00:13:49,760 --> 00:13:54,079
okay so uh theoretically what it

421
00:13:51,519 --> 00:13:56,000
happened what happens is that um

422
00:13:54,079 --> 00:13:57,599
anything inside angular bracket once

423
00:13:56,000 --> 00:13:59,279
it's passed into the compiler

424
00:13:57,600 --> 00:14:01,279
the you don't have the instance of it at

425
00:13:59,279 --> 00:14:03,040
runtime it's just java

426
00:14:01,279 --> 00:14:04,320
like the runtime does not know what type

427
00:14:03,040 --> 00:14:06,000
of instance it is

428
00:14:04,320 --> 00:14:07,519
so consider this example over here you

429
00:14:06,000 --> 00:14:09,120
have a list of string which is actually

430
00:14:07,519 --> 00:14:10,480
an array list which is an arrow which is

431
00:14:09,120 --> 00:14:12,000
an instance of an error list

432
00:14:10,480 --> 00:14:13,519
and if you try printing the instance of

433
00:14:12,000 --> 00:14:15,839
that error list

434
00:14:13,519 --> 00:14:17,760
you like if you try running this code

435
00:14:15,839 --> 00:14:19,680
you actually get an error

436
00:14:17,760 --> 00:14:21,360
saying it's an illegal generic type for

437
00:14:19,680 --> 00:14:22,638
instance off because the compiler

438
00:14:21,360 --> 00:14:23,600
because the runtime does not actually

439
00:14:22,639 --> 00:14:24,480
know and the compiler throws you a

440
00:14:23,600 --> 00:14:26,000
warning for that

441
00:14:24,480 --> 00:14:27,760
because your runtime does not know what

442
00:14:26,000 --> 00:14:28,160
what type of list what type of instance

443
00:14:27,760 --> 00:14:30,639
it is

444
00:14:28,160 --> 00:14:31,839
because even though list of even the

445
00:14:30,639 --> 00:14:33,920
string is a type of

446
00:14:31,839 --> 00:14:37,199
is an instance of object list of string

447
00:14:33,920 --> 00:14:39,439
is not an instance of list of object

448
00:14:37,199 --> 00:14:40,800
but if you try changing a list of object

449
00:14:39,440 --> 00:14:44,240
to list of string

450
00:14:40,800 --> 00:14:46,560
or to just list it it works because

451
00:14:44,240 --> 00:14:48,720
you you it's still a list you don't know

452
00:14:46,560 --> 00:14:50,560
what list it is but it's still a list

453
00:14:48,720 --> 00:14:51,920
so this is essentially the type area

454
00:14:50,560 --> 00:14:55,040
concept in java

455
00:14:51,920 --> 00:14:57,519
now how does it apply at uh for kotlin

456
00:14:55,040 --> 00:14:58,079
and can inline help over here so let's

457
00:14:57,519 --> 00:15:00,880
let's

458
00:14:58,079 --> 00:15:02,319
take a more kotlin example over here and

459
00:15:00,880 --> 00:15:04,639
see how things work

460
00:15:02,320 --> 00:15:05,839
so consider this example you have um you

461
00:15:04,639 --> 00:15:08,000
have a generic function

462
00:15:05,839 --> 00:15:08,880
with uh called ray fight test and you

463
00:15:08,000 --> 00:15:10,160
are printing

464
00:15:08,880 --> 00:15:12,880
the type of the class and you're

465
00:15:10,160 --> 00:15:15,920
matching if it's a string or not

466
00:15:12,880 --> 00:15:17,839
in in very crude way um

467
00:15:15,920 --> 00:15:19,519
how many of you think this code would

468
00:15:17,839 --> 00:15:22,959
work actually

469
00:15:19,519 --> 00:15:25,440
you like any ideas

470
00:15:22,959 --> 00:15:27,119
like this code it doesn't because it

471
00:15:25,440 --> 00:15:28,320
again throws this the same error because

472
00:15:27,120 --> 00:15:30,720
java and kotlin both have the same

473
00:15:28,320 --> 00:15:32,240
problem it says that you can't actually

474
00:15:30,720 --> 00:15:34,560
it's not a concrete type it's not a

475
00:15:32,240 --> 00:15:36,399
refined type user class instance so

476
00:15:34,560 --> 00:15:37,279
we've seen many apis and we've seen many

477
00:15:36,399 --> 00:15:40,639
uh

478
00:15:37,279 --> 00:15:42,800
libraries use uh class with a capital c

479
00:15:40,639 --> 00:15:43,920
just so that they can actually do these

480
00:15:42,800 --> 00:15:46,959
type of

481
00:15:43,920 --> 00:15:48,240
operations on them now what if we do

482
00:15:46,959 --> 00:15:49,920
something like this we add two

483
00:15:48,240 --> 00:15:52,959
parameters to it which is

484
00:15:49,920 --> 00:15:54,479
inline and verified and that's it it

485
00:15:52,959 --> 00:15:55,839
just works

486
00:15:54,480 --> 00:15:57,759
and if you see the internals for them

487
00:15:55,839 --> 00:15:58,399
how do they work like this is our actual

488
00:15:57,759 --> 00:16:00,399
function

489
00:15:58,399 --> 00:16:01,839
in line verified along with all the

490
00:16:00,399 --> 00:16:03,519
parameters in them

491
00:16:01,839 --> 00:16:05,040
and if we decompile them and we come by

492
00:16:03,519 --> 00:16:08,160
that particular source code and

493
00:16:05,040 --> 00:16:08,959
we see this particular function the test

494
00:16:08,160 --> 00:16:11,680
function

495
00:16:08,959 --> 00:16:13,920
at the where the verified test function

496
00:16:11,680 --> 00:16:16,160
is actually called

497
00:16:13,920 --> 00:16:17,519
sorry you see that it's actually

498
00:16:16,160 --> 00:16:19,120
comparing string and string it's not

499
00:16:17,519 --> 00:16:21,120
doing anything it has actually

500
00:16:19,120 --> 00:16:22,240
taken everything from the logical piece

501
00:16:21,120 --> 00:16:24,160
of code and i just

502
00:16:22,240 --> 00:16:26,000
it's just checking string actually

503
00:16:24,160 --> 00:16:27,519
string to string so it's going to return

504
00:16:26,000 --> 00:16:29,360
true for you over there which you which

505
00:16:27,519 --> 00:16:30,720
is actual desired result

506
00:16:29,360 --> 00:16:32,800
and you still have the lambda function

507
00:16:30,720 --> 00:16:34,720
available which

508
00:16:32,800 --> 00:16:36,240
just checks for an object and a string

509
00:16:34,720 --> 00:16:37,920
and it's going to return you false

510
00:16:36,240 --> 00:16:39,120
because it's just def to maintain

511
00:16:37,920 --> 00:16:40,319
compatibility and to maintain the

512
00:16:39,120 --> 00:16:40,800
presence of the function so you don't

513
00:16:40,320 --> 00:16:44,560
get

514
00:16:40,800 --> 00:16:47,439
method not found exceptions so

515
00:16:44,560 --> 00:16:49,119
this is how refined works and the

516
00:16:47,440 --> 00:16:50,959
original logic block always remains the

517
00:16:49,120 --> 00:16:52,880
same which is what you are checking over

518
00:16:50,959 --> 00:16:54,560
here

519
00:16:52,880 --> 00:16:56,320
it just doesn't stop there you are the

520
00:16:54,560 --> 00:16:58,079
concept of inline over your

521
00:16:56,320 --> 00:17:00,320
which is applied to functions actually

522
00:16:58,079 --> 00:17:02,719
is extended to classes as well

523
00:17:00,320 --> 00:17:04,400
uh which again essentially means that

524
00:17:02,720 --> 00:17:07,439
you can in line

525
00:17:04,400 --> 00:17:08,160
like you can make things work during the

526
00:17:07,439 --> 00:17:09,839
compile time

527
00:17:08,160 --> 00:17:11,839
make the compiler do some heavy lifting

528
00:17:09,839 --> 00:17:14,958
for you so

529
00:17:11,839 --> 00:17:16,559
let's consider like um

530
00:17:14,959 --> 00:17:18,640
the in-depth annotation any android

531
00:17:16,559 --> 00:17:21,119
developers around

532
00:17:18,640 --> 00:17:22,480
so you have you like android developers

533
00:17:21,119 --> 00:17:23,839
might have seen the in-depth annotation

534
00:17:22,480 --> 00:17:26,480
in the android source code

535
00:17:23,839 --> 00:17:27,438
so actually what it does is that um it's

536
00:17:26,480 --> 00:17:30,720
a type of

537
00:17:27,439 --> 00:17:32,080
it's a way to restrict your type

538
00:17:30,720 --> 00:17:34,000
which is only present in the compile

539
00:17:32,080 --> 00:17:35,918
stage because there's a there's an

540
00:17:34,000 --> 00:17:36,400
annotation processor which just removes

541
00:17:35,919 --> 00:17:39,440
it

542
00:17:36,400 --> 00:17:41,600
post compile and you just have it during

543
00:17:39,440 --> 00:17:43,840
the working stage just to restrict your

544
00:17:41,600 --> 00:17:46,159
types so the idea over here is very

545
00:17:43,840 --> 00:17:47,360
is is an amazing idea because you just

546
00:17:46,160 --> 00:17:50,080
want something

547
00:17:47,360 --> 00:17:50,399
at the compile stage to restrict types

548
00:17:50,080 --> 00:17:52,480
but

549
00:17:50,400 --> 00:17:53,679
and they are essentially primitives half

550
00:17:52,480 --> 00:17:55,120
of the things that we do around these

551
00:17:53,679 --> 00:17:58,559
things are primitives

552
00:17:55,120 --> 00:17:59,360
so that's how inline classes were born

553
00:17:58,559 --> 00:18:00,720
actually so

554
00:17:59,360 --> 00:18:03,120
you have compiled restrictions on

555
00:18:00,720 --> 00:18:06,240
objects for example

556
00:18:03,120 --> 00:18:08,559
uh this is a very bad example but

557
00:18:06,240 --> 00:18:09,440
yeah so you can actually take this as an

558
00:18:08,559 --> 00:18:11,360
example and

559
00:18:09,440 --> 00:18:12,880
we can have let's say an inline class

560
00:18:11,360 --> 00:18:15,280
which is actually a boolean

561
00:18:12,880 --> 00:18:17,600
a boolean parameter which says that can

562
00:18:15,280 --> 00:18:20,559
a candidate have a seat or not

563
00:18:17,600 --> 00:18:22,080
and that's it it's essentially used to

564
00:18:20,559 --> 00:18:23,440
restrict types

565
00:18:22,080 --> 00:18:25,520
it has a couple of advantages and

566
00:18:23,440 --> 00:18:26,799
disadvantages let's discuss both of them

567
00:18:25,520 --> 00:18:28,879
as we go

568
00:18:26,799 --> 00:18:30,559
so the advantage is that it opens up an

569
00:18:28,880 --> 00:18:32,640
area of possibilities again to have

570
00:18:30,559 --> 00:18:34,080
things which java could never have

571
00:18:32,640 --> 00:18:36,000
like for example you have unsigned

572
00:18:34,080 --> 00:18:39,360
integers unsigned long unsight

573
00:18:36,000 --> 00:18:41,360
byte unsight um all the

574
00:18:39,360 --> 00:18:43,520
numerical parameters over here in kotlin

575
00:18:41,360 --> 00:18:44,799
which java could not could never have

576
00:18:43,520 --> 00:18:47,360
what it does over here is that it

577
00:18:44,799 --> 00:18:49,520
essentially just takes it

578
00:18:47,360 --> 00:18:51,520
does some compiler tricks over you uh on

579
00:18:49,520 --> 00:18:52,879
it and essentially just prints out an

580
00:18:51,520 --> 00:18:54,799
integer variable itself because

581
00:18:52,880 --> 00:18:57,840
it's still an end or it's still along

582
00:18:54,799 --> 00:19:01,120
for an unsigned log

583
00:18:57,840 --> 00:19:04,879
it makes it opens up a possibility and

584
00:19:01,120 --> 00:19:06,639
also it's true that uh

585
00:19:04,880 --> 00:19:08,320
inline classes make great database ids

586
00:19:06,640 --> 00:19:11,840
because you have let's say

587
00:19:08,320 --> 00:19:14,240
cat and uh uh you have a you have an

588
00:19:11,840 --> 00:19:15,760
you have a database of zoos or animals

589
00:19:14,240 --> 00:19:18,000
or something like that

590
00:19:15,760 --> 00:19:19,360
every database id itself is a long but

591
00:19:18,000 --> 00:19:19,919
you have different ideas for different

592
00:19:19,360 --> 00:19:22,159
things

593
00:19:19,919 --> 00:19:23,520
so you in order to since they're long

594
00:19:22,160 --> 00:19:24,320
itself but you want to restrict the type

595
00:19:23,520 --> 00:19:25,679
of long

596
00:19:24,320 --> 00:19:26,639
you can actually use inline classes to

597
00:19:25,679 --> 00:19:28,559
register the type of long there's

598
00:19:26,640 --> 00:19:31,280
actually a very good blog post on them

599
00:19:28,559 --> 00:19:33,678
on this saying that inline classes make

600
00:19:31,280 --> 00:19:36,000
great database ids

601
00:19:33,679 --> 00:19:37,039
it reduces the need to create wrappers

602
00:19:36,000 --> 00:19:39,280
around primitives

603
00:19:37,039 --> 00:19:40,720
you can always create custom objects

604
00:19:39,280 --> 00:19:42,160
like i can create

605
00:19:40,720 --> 00:19:43,360
a customer instead of using the in-depth

606
00:19:42,160 --> 00:19:44,480
annotation i can actually create a

607
00:19:43,360 --> 00:19:46,959
custom

608
00:19:44,480 --> 00:19:47,919
custom object itself and have an integer

609
00:19:46,960 --> 00:19:49,679
inside it

610
00:19:47,919 --> 00:19:51,200
but having wrapper classes around

611
00:19:49,679 --> 00:19:52,480
primitives are not the best way because

612
00:19:51,200 --> 00:19:54,240
you are actually

613
00:19:52,480 --> 00:19:55,760
creating more instances it's not it's

614
00:19:54,240 --> 00:19:56,720
not a good memory practice to do the

615
00:19:55,760 --> 00:19:58,559
same thing

616
00:19:56,720 --> 00:20:00,559
so it reduces the need to have wrappers

617
00:19:58,559 --> 00:20:01,840
around primitives

618
00:20:00,559 --> 00:20:03,520
these are one of these are some of the

619
00:20:01,840 --> 00:20:05,600
great advantages of inline classes but

620
00:20:03,520 --> 00:20:07,200
there are some disadvantages as well

621
00:20:05,600 --> 00:20:09,520
the biggest disadvantage is that it has

622
00:20:07,200 --> 00:20:10,480
mangling why does it have mangling is

623
00:20:09,520 --> 00:20:12,240
because

624
00:20:10,480 --> 00:20:14,000
consider this inline class which is the

625
00:20:12,240 --> 00:20:14,480
unsend integer class it's actually taken

626
00:20:14,000 --> 00:20:18,960
from the

627
00:20:14,480 --> 00:20:18,960
uh quarterly documentation online

628
00:20:19,039 --> 00:20:22,640
you take this function which has uh

629
00:20:21,200 --> 00:20:23,600
which is a compute function which takes

630
00:20:22,640 --> 00:20:25,039
an integer

631
00:20:23,600 --> 00:20:26,399
and you take this function which is a

632
00:20:25,039 --> 00:20:27,280
compute function which takes an unsigned

633
00:20:26,400 --> 00:20:28,960
integer

634
00:20:27,280 --> 00:20:30,639
both of them when when they'll be

635
00:20:28,960 --> 00:20:32,080
compiled they'll be they'll be the same

636
00:20:30,640 --> 00:20:35,280
function which is

637
00:20:32,080 --> 00:20:37,280
void compute and integer

638
00:20:35,280 --> 00:20:38,399
so now since you have conflict over here

639
00:20:37,280 --> 00:20:41,918
for the naming

640
00:20:38,400 --> 00:20:42,640
the compiler appends um kind of a hash

641
00:20:41,919 --> 00:20:45,600
code

642
00:20:42,640 --> 00:20:47,039
we have behind the functions which use

643
00:20:45,600 --> 00:20:48,559
inline classes

644
00:20:47,039 --> 00:20:50,320
you can actually see them once you see

645
00:20:48,559 --> 00:20:52,158
the compile code for them i actually

646
00:20:50,320 --> 00:20:53,600
forgot to print it over here this is my

647
00:20:52,159 --> 00:20:56,000
mistake

648
00:20:53,600 --> 00:20:57,280
uh the second disadvantage with inline

649
00:20:56,000 --> 00:20:58,720
classes is that it still has an

650
00:20:57,280 --> 00:21:01,600
experimental status

651
00:20:58,720 --> 00:21:03,840
it is not mature yet for no reason y and

652
00:21:01,600 --> 00:21:05,360
it sounds very similar to type alias

653
00:21:03,840 --> 00:21:08,000
it's not actually type alias because

654
00:21:05,360 --> 00:21:10,080
type alias does not introduce a new type

655
00:21:08,000 --> 00:21:11,039
it's just they both are used for type

656
00:21:10,080 --> 00:21:12,799
restrictions but

657
00:21:11,039 --> 00:21:15,039
type alias does not introduce a new type

658
00:21:12,799 --> 00:21:15,679
whereas inline classes introduce a new

659
00:21:15,039 --> 00:21:17,679
type

660
00:21:15,679 --> 00:21:18,799
so suppose you create new inline class

661
00:21:17,679 --> 00:21:21,600
for something let's say

662
00:21:18,799 --> 00:21:22,158
a database a database id for cacs then

663
00:21:21,600 --> 00:21:25,439
that would

664
00:21:22,159 --> 00:21:27,200
actually be a type during compile stage

665
00:21:25,440 --> 00:21:29,039
post compiler it won't

666
00:21:27,200 --> 00:21:30,880
but during compile stage it is so the

667
00:21:29,039 --> 00:21:32,960
actual advantage of inline classes

668
00:21:30,880 --> 00:21:35,440
kick in when you actually use primitives

669
00:21:32,960 --> 00:21:38,000
it's otherwise it's just the same

670
00:21:35,440 --> 00:21:40,559
you have the same uh there are certain

671
00:21:38,000 --> 00:21:42,559
advanced concepts in inline as well

672
00:21:40,559 --> 00:21:44,158
uh one would be cross in line they just

673
00:21:42,559 --> 00:21:46,559
control the degree

674
00:21:44,159 --> 00:21:47,280
of inline you like the inlining of the

675
00:21:46,559 --> 00:21:48,799
lambda

676
00:21:47,280 --> 00:21:50,559
that the compiler that you want the

677
00:21:48,799 --> 00:21:52,400
compiler to do

678
00:21:50,559 --> 00:21:54,559
cross indian is is actually pretty

679
00:21:52,400 --> 00:21:57,760
interesting because

680
00:21:54,559 --> 00:21:59,918
it restricts non-local returns by

681
00:21:57,760 --> 00:22:03,520
non-local returns we mean

682
00:21:59,919 --> 00:22:05,039
you actually block lambda from returning

683
00:22:03,520 --> 00:22:07,039
the parent function

684
00:22:05,039 --> 00:22:09,200
and the one which is not cross in line

685
00:22:07,039 --> 00:22:11,440
does not block the same

686
00:22:09,200 --> 00:22:13,360
let's let's look at this example so over

687
00:22:11,440 --> 00:22:14,960
here the cross inline

688
00:22:13,360 --> 00:22:16,959
keyword is present on the non-local

689
00:22:14,960 --> 00:22:18,400
return lambda which is actually lambda

690
00:22:16,960 --> 00:22:19,840
function and you have a normal lambda as

691
00:22:18,400 --> 00:22:22,000
well

692
00:22:19,840 --> 00:22:24,399
and if we and this is how the call site

693
00:22:22,000 --> 00:22:26,720
might look like

694
00:22:24,400 --> 00:22:28,559
so if you look at it carefully the

695
00:22:26,720 --> 00:22:32,000
non-local lambda return has

696
00:22:28,559 --> 00:22:34,240
two returns one is that it returns

697
00:22:32,000 --> 00:22:35,120
the lambda itself this operation is

698
00:22:34,240 --> 00:22:37,600
permitted

699
00:22:35,120 --> 00:22:39,199
because you're still returning locally

700
00:22:37,600 --> 00:22:40,559
which is you're still returning inside

701
00:22:39,200 --> 00:22:42,880
the scope of the lambda

702
00:22:40,559 --> 00:22:43,600
you're not actually trying to return

703
00:22:42,880 --> 00:22:44,880
outside the

704
00:22:43,600 --> 00:22:46,320
like outside the scope of the lambda

705
00:22:44,880 --> 00:22:47,919
which is the function which is calling

706
00:22:46,320 --> 00:22:50,799
that particular lambda

707
00:22:47,919 --> 00:22:52,640
but this would be illegal this is what

708
00:22:50,799 --> 00:22:55,440
cross in line actually restricts

709
00:22:52,640 --> 00:22:56,400
it restricts non local returns that is

710
00:22:55,440 --> 00:22:59,760
it restricts

711
00:22:56,400 --> 00:23:00,720
returns from the same uh returns from

712
00:22:59,760 --> 00:23:03,679
the lambda which

713
00:23:00,720 --> 00:23:04,720
are not like which is not like returns

714
00:23:03,679 --> 00:23:05,200
to the lambda which are its calling

715
00:23:04,720 --> 00:23:08,159
function

716
00:23:05,200 --> 00:23:09,840
in a way and theoretically both of them

717
00:23:08,159 --> 00:23:12,559
would be possible inside the

718
00:23:09,840 --> 00:23:13,360
normal lambda function uh there's

719
00:23:12,559 --> 00:23:16,480
another

720
00:23:13,360 --> 00:23:18,879
point to it which is no no in line no

721
00:23:16,480 --> 00:23:21,039
inline as the name suggests

722
00:23:18,880 --> 00:23:23,039
is does not in line the code base for

723
00:23:21,039 --> 00:23:25,360
does not inline the lambda for you

724
00:23:23,039 --> 00:23:26,879
uh if you ask what might be the reason

725
00:23:25,360 --> 00:23:29,360
to do this

726
00:23:26,880 --> 00:23:30,960
the reason is simple you since kotlin in

727
00:23:29,360 --> 00:23:32,799
since in kotlin functions

728
00:23:30,960 --> 00:23:34,640
are first-class citizens you might

729
00:23:32,799 --> 00:23:36,960
actually pass a lambda

730
00:23:34,640 --> 00:23:38,640
to a function to a system api or to some

731
00:23:36,960 --> 00:23:40,400
function which is not under your control

732
00:23:38,640 --> 00:23:41,120
and if that function might not have been

733
00:23:40,400 --> 00:23:42,480
inlined

734
00:23:41,120 --> 00:23:45,760
then there is no way for the compiler to

735
00:23:42,480 --> 00:23:48,240
actually inline it in simple words

736
00:23:45,760 --> 00:23:50,240
like if you are passing a lambda to a

737
00:23:48,240 --> 00:23:51,520
function which is not inlined

738
00:23:50,240 --> 00:23:52,640
then there is no way for the component

739
00:23:51,520 --> 00:23:54,480
to actually inline it so that's what

740
00:23:52,640 --> 00:23:55,840
that's when you specify no inline

741
00:23:54,480 --> 00:23:57,600
that's when the compiler will not do the

742
00:23:55,840 --> 00:24:00,639
optimizations for you in terms of memory

743
00:23:57,600 --> 00:24:02,000
and cpu it will create more number of

744
00:24:00,640 --> 00:24:02,880
instances if you have a closure or it

745
00:24:02,000 --> 00:24:06,320
will create a static

746
00:24:02,880 --> 00:24:08,960
instance if you do not have a closure

747
00:24:06,320 --> 00:24:10,799
and if you if we consider an example

748
00:24:08,960 --> 00:24:13,919
over here

749
00:24:10,799 --> 00:24:15,840
and this is our no inline lambda 2 this

750
00:24:13,919 --> 00:24:17,440
is a function which is not in line

751
00:24:15,840 --> 00:24:19,120
which actually takes a parameter as a

752
00:24:17,440 --> 00:24:21,440
lambda

753
00:24:19,120 --> 00:24:22,959
this would be illegal this function

754
00:24:21,440 --> 00:24:26,559
would be illegal if

755
00:24:22,960 --> 00:24:27,200
lambda 2 was not no inline because again

756
00:24:26,559 --> 00:24:28,879
as we said

757
00:24:27,200 --> 00:24:32,720
as we discussed the compiler has no way

758
00:24:28,880 --> 00:24:35,760
for you to actually inline it

759
00:24:32,720 --> 00:24:36,720
that's it there's there are a couple of

760
00:24:35,760 --> 00:24:40,000
links that

761
00:24:36,720 --> 00:24:41,760
are useful to this particular talk uh

762
00:24:40,000 --> 00:24:43,279
there there's a blog written on this

763
00:24:41,760 --> 00:24:46,400
it's still it's

764
00:24:43,279 --> 00:24:48,000
incomplete uh so there's a link to it

765
00:24:46,400 --> 00:24:50,320
there's a good read on inline functions

766
00:24:48,000 --> 00:24:51,840
in general invoke dynamic uh it's a

767
00:24:50,320 --> 00:24:53,439
beautiful keyboard that was introduced

768
00:24:51,840 --> 00:24:54,080
in java 7. it does a lot of heavy

769
00:24:53,440 --> 00:24:57,520
lifting

770
00:24:54,080 --> 00:24:59,360
for java as an ecosystem from java 8.

771
00:24:57,520 --> 00:25:01,360
and inline classes which make great

772
00:24:59,360 --> 00:25:03,279
database ids the layer it's it's a blog

773
00:25:01,360 --> 00:25:06,479
post by jake walton

774
00:25:03,279 --> 00:25:06,960
uh who is uh people non-android people

775
00:25:06,480 --> 00:25:10,080
might not

776
00:25:06,960 --> 00:25:13,120
be knowing jay gordon and

777
00:25:10,080 --> 00:25:13,439
the app to my uh the link to the q talk

778
00:25:13,120 --> 00:25:14,719
app

779
00:25:13,440 --> 00:25:16,320
the place where i work i have a couple

780
00:25:14,720 --> 00:25:16,960
of stickers as well in case you guys

781
00:25:16,320 --> 00:25:18,720
want to collect

782
00:25:16,960 --> 00:25:20,159
and the link to this presentation this

783
00:25:18,720 --> 00:25:21,200
presentation was actually called power

784
00:25:20,159 --> 00:25:24,720
of inline

785
00:25:21,200 --> 00:25:27,360
and the title just changed overnight

786
00:25:24,720 --> 00:25:29,279
i might be a bit fast i'm sorry for this

787
00:25:27,360 --> 00:25:32,320
but yeah

788
00:25:29,279 --> 00:25:35,279
are there any questions about lambda's

789
00:25:32,320 --> 00:25:37,600
java inlining that i can i have 10

790
00:25:35,279 --> 00:25:37,600
minutes

791
00:25:39,120 --> 00:25:43,840
any questions anything

792
00:25:50,960 --> 00:25:57,690
okay any questions guys

793
00:25:54,000 --> 00:26:01,449
no i'm done

794
00:25:57,690 --> 00:26:01,449
[Applause]

