1
00:00:07,279 --> 00:00:11,440
you can read

2
00:00:08,000 --> 00:00:13,280
my bio on the fasdem website

3
00:00:11,440 --> 00:00:15,759
i want to take as much time as possible

4
00:00:13,280 --> 00:00:19,680
to talk about this subject and not me

5
00:00:15,759 --> 00:00:22,400
so i'll start right away uh

6
00:00:19,680 --> 00:00:22,960
so the title of the car the car the talk

7
00:00:22,400 --> 00:00:25,919
sorry

8
00:00:22,960 --> 00:00:27,599
is the consequences of sing bin log not

9
00:00:25,920 --> 00:00:30,160
equal to one

10
00:00:27,599 --> 00:00:31,759
actually the full title of the talk

11
00:00:30,160 --> 00:00:33,280
should be the consequence of sing been

12
00:00:31,760 --> 00:00:36,480
long not equal to wand

13
00:00:33,280 --> 00:00:37,200
and of innodb flash log at trx comet

14
00:00:36,480 --> 00:00:40,319
equal

15
00:00:37,200 --> 00:00:41,840
uh not equal to two sorry uh

16
00:00:40,320 --> 00:00:44,399
because like one without the other

17
00:00:41,840 --> 00:00:46,719
doesn't really make sense uh

18
00:00:44,399 --> 00:00:48,559
like if you still sync in odb and you

19
00:00:46,719 --> 00:00:49,200
don't sync the bin logs like you're

20
00:00:48,559 --> 00:00:51,760
you're still

21
00:00:49,200 --> 00:00:53,039
adding the cost of a sync there might be

22
00:00:51,760 --> 00:00:56,239
edge case but like

23
00:00:53,039 --> 00:00:58,800
that's that's what we're talking about

24
00:00:56,239 --> 00:01:00,559
and i will use in the talk trx commit

25
00:00:58,800 --> 00:01:01,038
for short because like this is just too

26
00:01:00,559 --> 00:01:04,559
long

27
00:01:01,039 --> 00:01:08,159
to write in slides uh so

28
00:01:04,559 --> 00:01:08,720
uh in the in the abstract of the talk i

29
00:01:08,159 --> 00:01:12,560
say that

30
00:01:08,720 --> 00:01:14,080
it's faster but uh we'll see by how much

31
00:01:12,560 --> 00:01:15,920
uh then we'll talk about what is

32
00:01:14,080 --> 00:01:17,280
replication and what are those two

33
00:01:15,920 --> 00:01:19,759
parameters

34
00:01:17,280 --> 00:01:20,640
i'll talk about avoiding uh setting

35
00:01:19,759 --> 00:01:23,360
segment log

36
00:01:20,640 --> 00:01:25,040
to a value different than one then the

37
00:01:23,360 --> 00:01:28,720
consequence mitigating

38
00:01:25,040 --> 00:01:30,320
and closing uh comments uh so this talk

39
00:01:28,720 --> 00:01:33,439
is mostly about my sequel five

40
00:01:30,320 --> 00:01:36,000
six and five seven uh

41
00:01:33,439 --> 00:01:37,600
most of it also applies to edo uh some

42
00:01:36,000 --> 00:01:40,799
things about murray db

43
00:01:37,600 --> 00:01:42,798
and i will explicitly mention it and i

44
00:01:40,799 --> 00:01:44,960
don't waste time taking pictures of the

45
00:01:42,799 --> 00:01:45,600
slide there online and you can follow

46
00:01:44,960 --> 00:01:47,039
the slides

47
00:01:45,600 --> 00:01:49,600
right now on your phone if you're not

48
00:01:47,040 --> 00:01:54,000
able to see the lowest part of

49
00:01:49,600 --> 00:01:57,199
the slides so faster by how much so like

50
00:01:54,000 --> 00:01:59,840
we're in benchmark land here uh so i did

51
00:01:57,200 --> 00:02:02,320
uh i use sysbench single threaded insert

52
00:01:59,840 --> 00:02:05,360
benchmark without secondary index

53
00:02:02,320 --> 00:02:09,119
because i really want to test uh

54
00:02:05,360 --> 00:02:12,720
like the syncing part of uh of

55
00:02:09,119 --> 00:02:16,000
mysql on google cloud uh with ssd

56
00:02:12,720 --> 00:02:17,920
persistent this mysql 5726

57
00:02:16,000 --> 00:02:19,200
so sing bin log equal one and trx

58
00:02:17,920 --> 00:02:21,280
committee grow one

59
00:02:19,200 --> 00:02:23,519
200 transactions per second single

60
00:02:21,280 --> 00:02:25,760
credit this is not a lot

61
00:02:23,520 --> 00:02:26,560
uh on this on the slave it's a little

62
00:02:25,760 --> 00:02:29,599
more

63
00:02:26,560 --> 00:02:30,239
because here my client is remote from

64
00:02:29,599 --> 00:02:31,920
the

65
00:02:30,239 --> 00:02:34,000
from the master so there's a round trip

66
00:02:31,920 --> 00:02:37,119
time between the client and the database

67
00:02:34,000 --> 00:02:40,560
on this slave there's no such thing

68
00:02:37,120 --> 00:02:43,120
if i reduce durability uh so sing bin

69
00:02:40,560 --> 00:02:46,400
log equals 0 to x commit equal to

70
00:02:43,120 --> 00:02:48,080
uh 3.7 000 transactions on the master 18

71
00:02:46,400 --> 00:02:51,120
times faster

72
00:02:48,080 --> 00:02:52,000
and a 7 000 transactions per second on a

73
00:02:51,120 --> 00:02:54,319
slave

74
00:02:52,000 --> 00:02:56,400
30 times faster so obviously people

75
00:02:54,319 --> 00:02:57,920
having a replication lag problem this is

76
00:02:56,400 --> 00:03:00,560
a very tempting

77
00:02:57,920 --> 00:03:02,159
uh configuration to do to solve a

78
00:03:00,560 --> 00:03:04,560
replication-like problem

79
00:03:02,159 --> 00:03:05,519
but it has consequences uh we'll see

80
00:03:04,560 --> 00:03:08,879
about

81
00:03:05,519 --> 00:03:12,480
this the whole uh benchmark setup is uh

82
00:03:08,879 --> 00:03:13,760
discussed on one of my blog so this is

83
00:03:12,480 --> 00:03:14,879
like this is what we're talking about

84
00:03:13,760 --> 00:03:16,640
this is the speed difference we're

85
00:03:14,879 --> 00:03:19,440
talking about

86
00:03:16,640 --> 00:03:20,238
uh quick overview of replication a

87
00:03:19,440 --> 00:03:22,800
transaction

88
00:03:20,239 --> 00:03:24,400
commit on the master it goes in enodb

89
00:03:22,800 --> 00:03:26,879
and in the binary logs

90
00:03:24,400 --> 00:03:27,599
those binary logs are downloaded by the

91
00:03:26,879 --> 00:03:30,319
i o thread

92
00:03:27,599 --> 00:03:32,319
sorry it's the lowest part of the slide

93
00:03:30,319 --> 00:03:34,319
are downloaded by the i o thread

94
00:03:32,319 --> 00:03:36,879
that connects to the master download the

95
00:03:34,319 --> 00:03:39,518
binary logs put them in the relay log

96
00:03:36,879 --> 00:03:41,040
the sql thread execute the relay log put

97
00:03:39,519 --> 00:03:44,159
data in enodb

98
00:03:41,040 --> 00:03:44,879
and eventually the slave produces binary

99
00:03:44,159 --> 00:03:48,159
log if

100
00:03:44,879 --> 00:03:51,440
log slave update is enabled

101
00:03:48,159 --> 00:03:53,760
so sync bin log and trx commit

102
00:03:51,440 --> 00:03:55,120
they're here those are parameter

103
00:03:53,760 --> 00:03:57,518
controlling

104
00:03:55,120 --> 00:03:59,760
what happens on enodb on commit and what

105
00:03:57,519 --> 00:04:02,959
happens on the binary logs on commit

106
00:03:59,760 --> 00:04:06,319
and they're also here so

107
00:04:02,959 --> 00:04:09,040
sing bin log equal something zero to

108
00:04:06,319 --> 00:04:09,439
any number uh well i guess it's limited

109
00:04:09,040 --> 00:04:12,720
by

110
00:04:09,439 --> 00:04:13,519
a size of an int uh so sendin log equals

111
00:04:12,720 --> 00:04:16,798
something

112
00:04:13,519 --> 00:04:17,600
the bin logs are flush to every uh to

113
00:04:16,798 --> 00:04:19,839
disk every

114
00:04:17,600 --> 00:04:20,880
something transaction so if sync bin log

115
00:04:19,839 --> 00:04:23,520
equal one

116
00:04:20,880 --> 00:04:25,440
the binary log will be flush to this so

117
00:04:23,520 --> 00:04:27,039
that means the data is actually on

118
00:04:25,440 --> 00:04:30,400
persistent disk

119
00:04:27,040 --> 00:04:32,800
not in an operating system buffer

120
00:04:30,400 --> 00:04:33,919
after each transaction if you set this

121
00:04:32,800 --> 00:04:36,000
to zero

122
00:04:33,919 --> 00:04:37,680
the bin logs will be in the operating

123
00:04:36,000 --> 00:04:38,479
system but you don't know if they're on

124
00:04:37,680 --> 00:04:40,960
disk

125
00:04:38,479 --> 00:04:41,680
they will actually be flushed at every

126
00:04:40,960 --> 00:04:43,840
bin log

127
00:04:41,680 --> 00:04:46,880
rotation there are some problems about

128
00:04:43,840 --> 00:04:50,239
this but i won't go into the details

129
00:04:46,880 --> 00:04:51,520
so this controls if our bin logs are

130
00:04:50,240 --> 00:04:55,280
persistent on disk

131
00:04:51,520 --> 00:04:58,400
or not trx commit can be equal to one

132
00:04:55,280 --> 00:05:00,880
two or zero one uh

133
00:04:58,400 --> 00:05:03,599
the redo log so the log of enodb is

134
00:05:00,880 --> 00:05:06,800
flush to disk after each transaction

135
00:05:03,600 --> 00:05:07,840
two the redo log is written to the

136
00:05:06,800 --> 00:05:10,240
operating system

137
00:05:07,840 --> 00:05:11,599
so it sits and the data sits in an

138
00:05:10,240 --> 00:05:13,600
operating system buffer

139
00:05:11,600 --> 00:05:15,039
but it's not flushed on disk at this

140
00:05:13,600 --> 00:05:18,240
point it will be flushed on this

141
00:05:15,039 --> 00:05:20,719
every second for uh you know db uh

142
00:05:18,240 --> 00:05:21,759
housekeeping and zero we're not really

143
00:05:20,720 --> 00:05:25,199
talking about this

144
00:05:21,759 --> 00:05:25,840
uh it's uh like we we avoid the system

145
00:05:25,199 --> 00:05:29,280
call at

146
00:05:25,840 --> 00:05:31,198
each transaction the data is in a mysql

147
00:05:29,280 --> 00:05:31,840
buffer in an innodb buffer and it will

148
00:05:31,199 --> 00:05:34,320
be

149
00:05:31,840 --> 00:05:35,280
uh sent to our printing system once in a

150
00:05:34,320 --> 00:05:39,120
while

151
00:05:35,280 --> 00:05:39,840
every second so that's what those two

152
00:05:39,120 --> 00:05:42,960
settings

153
00:05:39,840 --> 00:05:45,679
are controlling so i mentioned

154
00:05:42,960 --> 00:05:46,960
flushed flush to disk so this this means

155
00:05:45,680 --> 00:05:49,120
that the data

156
00:05:46,960 --> 00:05:51,280
in an operating system buffer is

157
00:05:49,120 --> 00:05:54,320
actually persistent to disk

158
00:05:51,280 --> 00:05:57,758
so this is not fast so

159
00:05:54,320 --> 00:05:58,319
in an old spinning rust disc a flush was

160
00:05:57,759 --> 00:06:01,360
taking

161
00:05:58,319 --> 00:06:05,280
uh 18 to 25 millisecond

162
00:06:01,360 --> 00:06:08,400
so that means we can do only 40 flush

163
00:06:05,280 --> 00:06:09,599
per second uh so like 40 transactions

164
00:06:08,400 --> 00:06:12,560
per second that's not

165
00:06:09,600 --> 00:06:14,160
a lot uh comes from sumer grade ssd so

166
00:06:12,560 --> 00:06:15,039
what you probably have on your laptop

167
00:06:14,160 --> 00:06:17,919
right now

168
00:06:15,039 --> 00:06:20,639
uh it's very variable a flush can take

169
00:06:17,919 --> 00:06:22,880
up to 10 milliseconds and on them

170
00:06:20,639 --> 00:06:23,759
on some of their ssds at 0.5

171
00:06:22,880 --> 00:06:25,680
milliseconds

172
00:06:23,759 --> 00:06:27,840
just do an i o ping on your laptop

173
00:06:25,680 --> 00:06:31,120
you'll know how much time it takes

174
00:06:27,840 --> 00:06:33,280
uh like enterprise that says these so

175
00:06:31,120 --> 00:06:34,560
all those are local this like 1 10 of a

176
00:06:33,280 --> 00:06:38,638
millisecond

177
00:06:34,560 --> 00:06:41,680
uh if you have a raid cache with a ram

178
00:06:38,639 --> 00:06:45,120
uh battery backup ram

179
00:06:41,680 --> 00:06:47,120
uh at 0.04 seconds

180
00:06:45,120 --> 00:06:48,639
but we don't have only local disk we

181
00:06:47,120 --> 00:06:52,160
have network disk

182
00:06:48,639 --> 00:06:54,880
fiber channel iscsi like any type of san

183
00:06:52,160 --> 00:06:56,800
like that's the network latency 0.5

184
00:06:54,880 --> 00:06:57,280
millisecond to one millisecond depending

185
00:06:56,800 --> 00:06:59,840
on the

186
00:06:57,280 --> 00:07:00,559
efficiency of your network and in cloud

187
00:06:59,840 --> 00:07:04,080
environments

188
00:07:00,560 --> 00:07:07,759
disks are remote so

189
00:07:04,080 --> 00:07:09,599
so gcp or aws like between 0.5

190
00:07:07,759 --> 00:07:11,039
millisecond to 1 millisecond to go to

191
00:07:09,599 --> 00:07:15,280
the storage

192
00:07:11,039 --> 00:07:18,479
in aws you can have local ssds which are

193
00:07:15,280 --> 00:07:21,520
efficient and that's fast so like

194
00:07:18,479 --> 00:07:23,039
flushing to disk is not fast and what

195
00:07:21,520 --> 00:07:27,198
does this mean

196
00:07:23,039 --> 00:07:28,719
uh if uh so what does this mean is that

197
00:07:27,199 --> 00:07:30,800
every transaction is durable like

198
00:07:28,720 --> 00:07:32,319
synthetic equal one trx commit equal one

199
00:07:30,800 --> 00:07:34,880
after each commit transactions

200
00:07:32,319 --> 00:07:36,800
are on disk so we don't lose anything

201
00:07:34,880 --> 00:07:40,400
but if it's equal zero or equal

202
00:07:36,800 --> 00:07:42,160
to if my sequel d crash

203
00:07:40,400 --> 00:07:44,080
then the data is not lost because the

204
00:07:42,160 --> 00:07:44,879
operating system is still alive and it

205
00:07:44,080 --> 00:07:46,719
has the data

206
00:07:44,879 --> 00:07:48,240
in the buffer but if the operating

207
00:07:46,720 --> 00:07:53,199
system crashes

208
00:07:48,240 --> 00:07:55,840
we lose transaction and uh

209
00:07:53,199 --> 00:07:56,960
and also maybe enodb and the binary logs

210
00:07:55,840 --> 00:08:00,239
are not in sync

211
00:07:56,960 --> 00:08:03,359
so here if we do transaction a b c d

212
00:08:00,240 --> 00:08:03,919
and so on maybe the binary logs are

213
00:08:03,360 --> 00:08:07,440
synced

214
00:08:03,919 --> 00:08:09,280
up to e and in odb is synced up to k

215
00:08:07,440 --> 00:08:10,479
and then we do other transactions and we

216
00:08:09,280 --> 00:08:12,878
crash

217
00:08:10,479 --> 00:08:13,840
at recovery the binary logs will contain

218
00:08:12,879 --> 00:08:16,879
up to e

219
00:08:13,840 --> 00:08:20,719
and enodb will contain up to k so

220
00:08:16,879 --> 00:08:25,280
we we have a problem of consistency here

221
00:08:20,720 --> 00:08:25,680
um and there's also the other scenario

222
00:08:25,280 --> 00:08:28,159
where

223
00:08:25,680 --> 00:08:29,360
the bin logs are ahead of enodb it's

224
00:08:28,160 --> 00:08:30,800
less

225
00:08:29,360 --> 00:08:33,440
there's a less probability but it can

226
00:08:30,800 --> 00:08:33,440
also happen

227
00:08:34,399 --> 00:08:37,120
skip this

228
00:08:38,640 --> 00:08:44,159
so mysql and five seven or uh

229
00:08:41,679 --> 00:08:45,040
800 by default are like this the

230
00:08:44,159 --> 00:08:48,480
defaults are not

231
00:08:45,040 --> 00:08:51,439
now safe murray db defaults are not safe

232
00:08:48,480 --> 00:08:52,399
uh i'm not it's not the best like the

233
00:08:51,440 --> 00:08:56,800
choice here is

234
00:08:52,399 --> 00:08:56,800
theirs i'm not sure i agree with this

235
00:08:57,839 --> 00:09:04,560
so we would like to avoid

236
00:09:00,959 --> 00:09:07,119
uh setting send bin log to something

237
00:09:04,560 --> 00:09:09,439
different than zero so the solutions

238
00:09:07,120 --> 00:09:11,600
here are either to get faster disks

239
00:09:09,440 --> 00:09:12,800
or to run things in parallel and so a

240
00:09:11,600 --> 00:09:15,200
single sink

241
00:09:12,800 --> 00:09:16,079
will persist many transactions at the

242
00:09:15,200 --> 00:09:18,399
same time

243
00:09:16,080 --> 00:09:19,440
so this is a binary lab group commit on

244
00:09:18,399 --> 00:09:21,760
the master

245
00:09:19,440 --> 00:09:22,640
or if you use parallel replication so if

246
00:09:21,760 --> 00:09:25,040
you use

247
00:09:22,640 --> 00:09:27,279
if you run more than one transactions at

248
00:09:25,040 --> 00:09:28,399
the same time on slaves maybe you'll be

249
00:09:27,279 --> 00:09:31,760
able to

250
00:09:28,399 --> 00:09:35,360
commit many things at the same time so

251
00:09:31,760 --> 00:09:38,000
we'll explore this a little so

252
00:09:35,360 --> 00:09:39,519
we remember the numbers uh very low

253
00:09:38,000 --> 00:09:40,240
transaction throughput with singh bin

254
00:09:39,519 --> 00:09:43,279
log equal

255
00:09:40,240 --> 00:09:44,800
one and as we use more and more tread

256
00:09:43,279 --> 00:09:45,760
we're able to get a better transaction

257
00:09:44,800 --> 00:09:48,640
throughput

258
00:09:45,760 --> 00:09:49,600
uh with single log equals zero and

259
00:09:48,640 --> 00:09:52,080
single threaded

260
00:09:49,600 --> 00:09:52,959
we have a more decent transaction

261
00:09:52,080 --> 00:09:54,640
throughput

262
00:09:52,959 --> 00:09:56,319
this is not with replication this is

263
00:09:54,640 --> 00:09:59,680
what a client doing a round trip

264
00:09:56,320 --> 00:10:00,480
so around three thousand but this this

265
00:09:59,680 --> 00:10:03,599
curve grows

266
00:10:00,480 --> 00:10:04,640
much faster than the other uh so even if

267
00:10:03,600 --> 00:10:06,880
we're able to get

268
00:10:04,640 --> 00:10:08,480
a better transaction throughput with uh

269
00:10:06,880 --> 00:10:10,240
multithreaded on the master

270
00:10:08,480 --> 00:10:11,519
like we need a hundred two hundred

271
00:10:10,240 --> 00:10:14,399
treads to get

272
00:10:11,519 --> 00:10:15,680
uh a better transaction throughput and

273
00:10:14,399 --> 00:10:18,480
sending log equals zero

274
00:10:15,680 --> 00:10:19,599
like we have we have better so um when

275
00:10:18,480 --> 00:10:22,240
you're looking for

276
00:10:19,600 --> 00:10:23,839
the best transaction throughput uh like

277
00:10:22,240 --> 00:10:27,040
sending log equals zero is still

278
00:10:23,839 --> 00:10:29,680
still better this is for with four vcpus

279
00:10:27,040 --> 00:10:34,399
in google cloud and this is with 16

280
00:10:29,680 --> 00:10:35,920
so it scales a little with replication

281
00:10:34,399 --> 00:10:37,760
murraydb has something called slave

282
00:10:35,920 --> 00:10:41,120
group commit

283
00:10:37,760 --> 00:10:43,279
which is pretty exciting

284
00:10:41,120 --> 00:10:44,560
it basically gets the transaction

285
00:10:43,279 --> 00:10:47,120
throughput of

286
00:10:44,560 --> 00:10:47,839
syncbin log equals zero uh with many

287
00:10:47,120 --> 00:10:50,800
treads

288
00:10:47,839 --> 00:10:52,079
without the consequence of it uh you can

289
00:10:50,800 --> 00:10:55,040
look it up i have a link

290
00:10:52,079 --> 00:10:56,640
down there and parallel replication on

291
00:10:55,040 --> 00:10:57,680
the benchmark i'm doing on the insert

292
00:10:56,640 --> 00:10:59,279
benchmark

293
00:10:57,680 --> 00:11:00,719
is like this is this is the worst

294
00:10:59,279 --> 00:11:02,399
benchmark for uh

295
00:11:00,720 --> 00:11:03,760
for parallel replication because there's

296
00:11:02,399 --> 00:11:07,040
a lot of contention

297
00:11:03,760 --> 00:11:08,800
uh sting bin log equal one we scale but

298
00:11:07,040 --> 00:11:11,279
with single log equals zero it's still

299
00:11:08,800 --> 00:11:12,880
better so like we're still like tortured

300
00:11:11,279 --> 00:11:14,560
here if we want the best

301
00:11:12,880 --> 00:11:16,240
transaction per second sync then log

302
00:11:14,560 --> 00:11:20,079
equal zero is still our

303
00:11:16,240 --> 00:11:21,920
best choice those are all the graphs on

304
00:11:20,079 --> 00:11:24,399
the same page

305
00:11:21,920 --> 00:11:25,439
so now about the consequence so now we

306
00:11:24,399 --> 00:11:28,240
get in the real

307
00:11:25,440 --> 00:11:28,800
subject of the talk this is a copy from

308
00:11:28,240 --> 00:11:30,480
uh

309
00:11:28,800 --> 00:11:32,319
from the previous slide so just

310
00:11:30,480 --> 00:11:36,079
remembering transaction

311
00:11:32,320 --> 00:11:39,120
a b c d bin logs are synced up to e

312
00:11:36,079 --> 00:11:42,479
e in odb sinks up to k

313
00:11:39,120 --> 00:11:44,480
and then we crash uh

314
00:11:42,480 --> 00:11:47,120
maybe it's a time for one question here

315
00:11:44,480 --> 00:11:50,800
before i i move forward

316
00:11:47,120 --> 00:11:53,360
everything is clear so far okay

317
00:11:50,800 --> 00:11:54,319
so let's see about the consequences of

318
00:11:53,360 --> 00:11:56,639
this

319
00:11:54,320 --> 00:11:58,480
so if the master crash so we're only

320
00:11:56,639 --> 00:11:59,200
interested in operating system crashes

321
00:11:58,480 --> 00:12:01,200
like if

322
00:11:59,200 --> 00:12:02,720
if my sequel d crash we don't lose

323
00:12:01,200 --> 00:12:05,839
anything everything is in

324
00:12:02,720 --> 00:12:06,560
is in a buffer so if a master crash and

325
00:12:05,839 --> 00:12:10,800
we're using

326
00:12:06,560 --> 00:12:14,000
legacy replication so file in position

327
00:12:10,800 --> 00:12:15,519
so the slave is pointing in the binary

328
00:12:14,000 --> 00:12:20,320
log that will

329
00:12:15,519 --> 00:12:22,800
vanish so after the crash

330
00:12:20,320 --> 00:12:23,440
mysql will create a new binary log and

331
00:12:22,800 --> 00:12:26,399
if we keep

332
00:12:23,440 --> 00:12:27,519
writing data will be happened to the new

333
00:12:26,399 --> 00:12:29,519
binary logs

334
00:12:27,519 --> 00:12:31,279
but the slaves are pointing to something

335
00:12:29,519 --> 00:12:33,680
that is now gone

336
00:12:31,279 --> 00:12:35,760
so during the crash the slaves are not

337
00:12:33,680 --> 00:12:37,439
able to connect to the master but after

338
00:12:35,760 --> 00:12:38,720
the recovery the slaves connect to the

339
00:12:37,440 --> 00:12:39,920
master and they connect in something

340
00:12:38,720 --> 00:12:43,120
that doesn't exist and then

341
00:12:39,920 --> 00:12:46,319
replication breaks so

342
00:12:43,120 --> 00:12:48,399
that is obviously not cool uh because

343
00:12:46,320 --> 00:12:50,240
if like now you lose all your slaves you

344
00:12:48,399 --> 00:12:52,160
can still write to your master which is

345
00:12:50,240 --> 00:12:53,839
kind of inconsistent enodb and the

346
00:12:52,160 --> 00:12:56,480
binary logs are not in sync

347
00:12:53,839 --> 00:12:57,920
you lost some data the slaves is

348
00:12:56,480 --> 00:13:00,160
actually more data

349
00:12:57,920 --> 00:13:01,519
than the master because they didn't lose

350
00:13:00,160 --> 00:13:04,800
the last transaction

351
00:13:01,519 --> 00:13:06,959
the master did so you are

352
00:13:04,800 --> 00:13:08,160
not in sync and with broken replication

353
00:13:06,959 --> 00:13:14,160
this is really really

354
00:13:08,160 --> 00:13:16,959
not cool and if you have lagging slaves

355
00:13:14,160 --> 00:13:18,959
that are pointing in an old binary log

356
00:13:16,959 --> 00:13:19,518
like they will keep going but they will

357
00:13:18,959 --> 00:13:21,518
be

358
00:13:19,519 --> 00:13:23,040
like they will have corrupted data so

359
00:13:21,519 --> 00:13:26,720
everything is out of sync

360
00:13:23,040 --> 00:13:30,719
pretty bad if you're running with

361
00:13:26,720 --> 00:13:33,040
gtid so

362
00:13:30,720 --> 00:13:34,399
let's say at the moment of the crash we

363
00:13:33,040 --> 00:13:37,920
have gtid up to

364
00:13:34,399 --> 00:13:41,600
60 on the master and the slave adds

365
00:13:37,920 --> 00:13:44,880
up to 58 and then we crash

366
00:13:41,600 --> 00:13:48,000
now this the master goes back up and

367
00:13:44,880 --> 00:13:51,360
because the the gtid state is stored in

368
00:13:48,000 --> 00:13:53,600
the master the slaves start back

369
00:13:51,360 --> 00:13:54,880
in the binary log the slave start back

370
00:13:53,600 --> 00:13:59,760
the master starts at

371
00:13:54,880 --> 00:14:02,959
gtid 50. and so it will write 50 51.52

372
00:13:59,760 --> 00:14:05,279
but the slaves are already 1 to 58

373
00:14:02,959 --> 00:14:06,959
but those are the old transactions and

374
00:14:05,279 --> 00:14:07,439
now we have new transactions that have

375
00:14:06,959 --> 00:14:11,359
the same

376
00:14:07,440 --> 00:14:13,680
id so two things will happen here

377
00:14:11,360 --> 00:14:14,399
either the master will be able to write

378
00:14:13,680 --> 00:14:17,519
up to

379
00:14:14,399 --> 00:14:19,199
gtid 58 fast enough

380
00:14:17,519 --> 00:14:20,959
before the slaves reconnect and then

381
00:14:19,199 --> 00:14:24,000
everything will work but we'll have

382
00:14:20,959 --> 00:14:27,359
corruption or the slave will be faster

383
00:14:24,000 --> 00:14:29,279
it will reconnect while gtid 58 doesn't

384
00:14:27,360 --> 00:14:30,000
exist on the master and then replication

385
00:14:29,279 --> 00:14:31,279
will break because

386
00:14:30,000 --> 00:14:33,920
the slave has something that doesn't

387
00:14:31,279 --> 00:14:36,880
exist on the master and that will break

388
00:14:33,920 --> 00:14:39,599
so that's another scenario where things

389
00:14:36,880 --> 00:14:39,600
break here

390
00:14:43,120 --> 00:14:47,519
and that's what i just explained so

391
00:14:46,240 --> 00:14:49,199
that's in the case of an operating

392
00:14:47,519 --> 00:14:52,399
system crash

393
00:14:49,199 --> 00:14:54,399
if the slave crash and we are using file

394
00:14:52,399 --> 00:14:56,320
and position replication

395
00:14:54,399 --> 00:14:58,079
uh if we are using crash safe

396
00:14:56,320 --> 00:15:01,120
replication basically

397
00:14:58,079 --> 00:15:03,519
the replication position is in enodb so

398
00:15:01,120 --> 00:15:05,440
innodb will do crash recovery

399
00:15:03,519 --> 00:15:07,279
that information will be consistent and

400
00:15:05,440 --> 00:15:10,320
then the slave is able to

401
00:15:07,279 --> 00:15:12,480
uh to restart to reconnect to the master

402
00:15:10,320 --> 00:15:14,720
it still has binary log that we cannot

403
00:15:12,480 --> 00:15:17,360
trust because now they're out of sync

404
00:15:14,720 --> 00:15:20,079
but there's no data corruption in enodb

405
00:15:17,360 --> 00:15:20,079
in this case

406
00:15:20,399 --> 00:15:24,560
so if you're running with gtid with

407
00:15:23,440 --> 00:15:26,720
binary logs

408
00:15:24,560 --> 00:15:28,638
disabled on the slave which is a feature

409
00:15:26,720 --> 00:15:31,040
of five seven

410
00:15:28,639 --> 00:15:32,399
the position the gtid position is also

411
00:15:31,040 --> 00:15:34,240
stored in enodb

412
00:15:32,399 --> 00:15:36,399
so there's no problem here the data is

413
00:15:34,240 --> 00:15:38,959
safe the binary logs on the slave

414
00:15:36,399 --> 00:15:40,480
obviously is out of sync with the data

415
00:15:38,959 --> 00:15:41,359
but the slave will reconnect to the

416
00:15:40,480 --> 00:15:43,440
master

417
00:15:41,360 --> 00:15:45,279
and it will and the data of the slave

418
00:15:43,440 --> 00:15:47,279
will be consistent

419
00:15:45,279 --> 00:15:49,040
but if you're running with binary logs

420
00:15:47,279 --> 00:15:51,439
enable because the

421
00:15:49,040 --> 00:15:54,079
position of replication is stored if

422
00:15:51,440 --> 00:15:56,720
you're if you're running a slave with

423
00:15:54,079 --> 00:15:59,839
gtid and binary logs enabled five six

424
00:15:56,720 --> 00:16:01,920
or five seven the gtid position of the

425
00:15:59,839 --> 00:16:04,320
slave is in the binary log

426
00:16:01,920 --> 00:16:04,959
we crash we lose binary logs we're out

427
00:16:04,320 --> 00:16:08,320
of sync

428
00:16:04,959 --> 00:16:11,920
between enodb and the binary logs and so

429
00:16:08,320 --> 00:16:14,079
we start replicating at the wrong place

430
00:16:11,920 --> 00:16:15,839
so again data corruption either

431
00:16:14,079 --> 00:16:19,040
replication will break

432
00:16:15,839 --> 00:16:22,320
or we will have silent data corruption

433
00:16:19,040 --> 00:16:26,079
so those are the consequences of running

434
00:16:22,320 --> 00:16:29,759
with this parameter

435
00:16:26,079 --> 00:16:32,880
something in my sequel 807 uh

436
00:16:29,759 --> 00:16:35,680
gtid position in enodb unclear

437
00:16:32,880 --> 00:16:36,320
uh there's there's hardcore reading

438
00:16:35,680 --> 00:16:39,839
about

439
00:16:36,320 --> 00:16:40,399
this if you want more details and now we

440
00:16:39,839 --> 00:16:43,839
are at

441
00:16:40,399 --> 00:16:46,639
mitigating this so if you're running

442
00:16:43,839 --> 00:16:48,560
with saying belong not equal to zero

443
00:16:46,639 --> 00:16:50,160
basically there's one thing that you

444
00:16:48,560 --> 00:16:53,199
need to remember

445
00:16:50,160 --> 00:16:54,000
is that either on the master or on the

446
00:16:53,199 --> 00:16:56,639
slave

447
00:16:54,000 --> 00:16:57,360
after an operating system crash you

448
00:16:56,639 --> 00:17:00,320
cannot

449
00:16:57,360 --> 00:17:01,759
trust the bin logs like obviously you

450
00:17:00,320 --> 00:17:05,120
didn't sync them

451
00:17:01,759 --> 00:17:07,520
you cannot trust the bin logs so

452
00:17:05,119 --> 00:17:09,918
what can you do in a situation where you

453
00:17:07,520 --> 00:17:13,439
cannot trust your bin logs

454
00:17:09,919 --> 00:17:16,720
so on a master after restarting

455
00:17:13,439 --> 00:17:19,600
mysql after an operating system crash

456
00:17:16,720 --> 00:17:20,480
what i do is i make sure the master will

457
00:17:19,599 --> 00:17:23,918
restart in

458
00:17:20,480 --> 00:17:25,439
offline mode equal on so no clients

459
00:17:23,919 --> 00:17:29,919
connect to it

460
00:17:25,439 --> 00:17:33,200
no slaves no clients and then

461
00:17:29,919 --> 00:17:34,880
i decide as a dba what to do

462
00:17:33,200 --> 00:17:37,440
the best thing is to fail over to a

463
00:17:34,880 --> 00:17:38,720
slave but if i do not automate failover

464
00:17:37,440 --> 00:17:41,280
if this is manual

465
00:17:38,720 --> 00:17:42,400
i do want not want clients to write to

466
00:17:41,280 --> 00:17:45,520
my master

467
00:17:42,400 --> 00:17:46,640
and i do not want slaves to connect to

468
00:17:45,520 --> 00:17:50,160
it

469
00:17:46,640 --> 00:17:52,480
and here i arrive as the dba i

470
00:17:50,160 --> 00:17:55,120
check if this is an operating system

471
00:17:52,480 --> 00:17:57,360
crash in which case i need to failover

472
00:17:55,120 --> 00:17:59,678
or maybe it's just a mysql d crash and

473
00:17:57,360 --> 00:18:01,678
then i set offline mode equal

474
00:17:59,679 --> 00:18:05,280
off and then i continue because at that

475
00:18:01,679 --> 00:18:05,280
moment i didn't lose anything

476
00:18:07,679 --> 00:18:13,440
on slaves having so

477
00:18:10,720 --> 00:18:14,960
on slaves if my sequel restart after

478
00:18:13,440 --> 00:18:18,480
such a crash

479
00:18:14,960 --> 00:18:20,160
uh if you have binary logs on the slave

480
00:18:18,480 --> 00:18:22,400
like you need to purge them

481
00:18:20,160 --> 00:18:24,160
like you need to completely delete the

482
00:18:22,400 --> 00:18:25,039
binary logs because now potentially you

483
00:18:24,160 --> 00:18:28,240
have a hole

484
00:18:25,039 --> 00:18:29,280
in there if if the slice is will

485
00:18:28,240 --> 00:18:31,360
eventually be

486
00:18:29,280 --> 00:18:33,600
a candidate master you cannot trust its

487
00:18:31,360 --> 00:18:35,918
binary log so wipe the binary logs on a

488
00:18:33,600 --> 00:18:35,918
slave

489
00:18:36,320 --> 00:18:40,559
if you're running with gtid a reset

490
00:18:38,480 --> 00:18:43,840
master will

491
00:18:40,559 --> 00:18:48,960
erase your gtid position so you need to

492
00:18:43,840 --> 00:18:50,879
uh you need to restore this

493
00:18:48,960 --> 00:18:52,400
intermediate master are both master and

494
00:18:50,880 --> 00:18:56,000
slave so you have to do the

495
00:18:52,400 --> 00:19:00,320
two things when you're running

496
00:18:56,000 --> 00:19:03,520
with gtid on a slave with sing-bin log

497
00:19:00,320 --> 00:19:07,360
not equal to one so

498
00:19:03,520 --> 00:19:10,320
gtid replication is not crash safe

499
00:19:07,360 --> 00:19:12,159
so normally what you would have to do is

500
00:19:10,320 --> 00:19:14,879
you would have to restore a backup

501
00:19:12,160 --> 00:19:16,480
and this this is very annoying for a dba

502
00:19:14,880 --> 00:19:21,760
to restore a backup

503
00:19:16,480 --> 00:19:23,840
so there's a way to avoid this

504
00:19:21,760 --> 00:19:25,520
it's because file and position in a

505
00:19:23,840 --> 00:19:29,840
table can be trusted

506
00:19:25,520 --> 00:19:33,360
at that moment so if you're running

507
00:19:29,840 --> 00:19:35,360
crash safe replication not with gtid

508
00:19:33,360 --> 00:19:37,600
with file and position

509
00:19:35,360 --> 00:19:39,280
there's some voodoo you can do here

510
00:19:37,600 --> 00:19:40,959
either if you're running single threaded

511
00:19:39,280 --> 00:19:42,639
or if you're running multithreaded with

512
00:19:40,960 --> 00:19:44,799
slave preserve commit order

513
00:19:42,640 --> 00:19:47,520
there's some voodoo you can do here to

514
00:19:44,799 --> 00:19:51,200
avoid restoring the backup

515
00:19:47,520 --> 00:19:52,160
and so the idea here is when the slave

516
00:19:51,200 --> 00:19:54,080
restarts

517
00:19:52,160 --> 00:19:56,240
make sure that replication doesn't start

518
00:19:54,080 --> 00:19:57,918
you cannot start at this moment the gtid

519
00:19:56,240 --> 00:20:01,360
position cannot be trusted

520
00:19:57,919 --> 00:20:01,360
but the file and position

521
00:20:01,440 --> 00:20:07,200
can be trusted so what you can do here

522
00:20:04,720 --> 00:20:07,919
is you note the gtid executed of that

523
00:20:07,200 --> 00:20:09,919
slave

524
00:20:07,919 --> 00:20:11,520
and then you wipe the binary logs reset

525
00:20:09,919 --> 00:20:14,159
master like the binary logs on that

526
00:20:11,520 --> 00:20:16,559
slave cannot be trusted

527
00:20:14,159 --> 00:20:17,600
then you restart replication with file

528
00:20:16,559 --> 00:20:20,720
and position

529
00:20:17,600 --> 00:20:24,320
which is trusted

530
00:20:20,720 --> 00:20:26,880
and then you need to restore the gtid

531
00:20:24,320 --> 00:20:28,480
position and this you'll have to figure

532
00:20:26,880 --> 00:20:30,480
out by yourself it's left

533
00:20:28,480 --> 00:20:31,919
as an exercise if you're not able to

534
00:20:30,480 --> 00:20:35,840
figure this out by yourself you

535
00:20:31,919 --> 00:20:35,840
shouldn't do this voodoo

536
00:20:36,480 --> 00:20:41,280
so that's how i run my uh

537
00:20:41,679 --> 00:20:46,400
my slaves uh with sing bin log not equal

538
00:20:44,640 --> 00:20:48,880
to one

539
00:20:46,400 --> 00:20:50,080
so in conclusion like we saw the

540
00:20:48,880 --> 00:20:52,159
consequence

541
00:20:50,080 --> 00:20:55,280
we understood it we understood how to

542
00:20:52,159 --> 00:20:59,200
avoid it how to mitigate it

543
00:20:55,280 --> 00:21:01,760
uh so i have i have a

544
00:20:59,200 --> 00:21:03,600
guess an educated guess that more and

545
00:21:01,760 --> 00:21:04,720
more people would run with singing log

546
00:21:03,600 --> 00:21:07,439
not equal

547
00:21:04,720 --> 00:21:08,080
to one because of the cloud syncing in

548
00:21:07,440 --> 00:21:11,120
the cloud

549
00:21:08,080 --> 00:21:12,559
is very slow uh so

550
00:21:11,120 --> 00:21:14,719
you need to run with sync bin log not

551
00:21:12,559 --> 00:21:17,600
equal to one if you want decent tps

552
00:21:14,720 --> 00:21:18,720
in the cloud and so to be fully cloud

553
00:21:17,600 --> 00:21:21,760
ready

554
00:21:18,720 --> 00:21:25,039
mysql should make it easier for

555
00:21:21,760 --> 00:21:27,440
us dbas to like run in the cloud so

556
00:21:25,039 --> 00:21:29,200
basically i would like auto offline mode

557
00:21:27,440 --> 00:21:32,000
after an operating system crash

558
00:21:29,200 --> 00:21:33,919
and auto skip slave start after an

559
00:21:32,000 --> 00:21:36,400
operating system crash

560
00:21:33,919 --> 00:21:37,039
and i have two rants on my three ransom

561
00:21:36,400 --> 00:21:40,720
my favorite

562
00:21:37,039 --> 00:21:44,080
feature uh so like gtid

563
00:21:40,720 --> 00:21:45,919
makes things very complicated uh so

564
00:21:44,080 --> 00:21:47,840
there's a gti state in the table there's

565
00:21:45,919 --> 00:21:49,919
a gtid state in the binary logs and now

566
00:21:47,840 --> 00:21:51,360
there's a gtid state not in the redo log

567
00:21:49,919 --> 00:21:54,320
it's an enodb

568
00:21:51,360 --> 00:21:56,479
uh so like there's there's cleanup to do

569
00:21:54,320 --> 00:21:58,559
here

570
00:21:56,480 --> 00:21:59,520
and one last thing about gtid like

571
00:21:58,559 --> 00:22:01,600
somebody left

572
00:21:59,520 --> 00:22:02,879
but like this gdid state is just

573
00:22:01,600 --> 00:22:06,320
horrible uh so

574
00:22:02,880 --> 00:22:06,320
like we need a way to clean that

575
00:22:06,960 --> 00:22:15,200
sorry just split into multiple lines yes

576
00:22:11,840 --> 00:22:18,240
i have links in my slides

577
00:22:15,200 --> 00:22:20,159
uh classic thing uh my employer is

578
00:22:18,240 --> 00:22:23,360
hiring

579
00:22:20,159 --> 00:22:26,000
please rate my talk and i have

580
00:22:23,360 --> 00:22:27,039
time for questions three minutes three

581
00:22:26,000 --> 00:22:29,760
minutes for question

582
00:22:27,039 --> 00:22:29,760
yes marco

583
00:22:31,760 --> 00:22:34,400
the variation

584
00:22:35,440 --> 00:22:40,720
and of course that needs some

585
00:22:37,679 --> 00:22:40,720
implementation which

586
00:22:45,600 --> 00:22:50,158
yes so the question is

587
00:22:50,640 --> 00:22:54,000
so the question is did i do tests about

588
00:22:53,679 --> 00:22:56,640
not

589
00:22:54,000 --> 00:22:57,120
syncing in odb and the context of that

590
00:22:56,640 --> 00:23:00,720
question

591
00:22:57,120 --> 00:23:03,760
is that uh in in some next versions of

592
00:23:00,720 --> 00:23:04,960
my sequel muradi uh there will be

593
00:23:03,760 --> 00:23:08,000
features of

594
00:23:04,960 --> 00:23:11,600
uh keeping consistency without

595
00:23:08,000 --> 00:23:14,080
syncing inodb so like removing a sync

596
00:23:11,600 --> 00:23:16,799
instead of having two like you'll double

597
00:23:14,080 --> 00:23:19,280
my results like 200 transactions per

598
00:23:16,799 --> 00:23:21,918
second will end up being 400

599
00:23:19,280 --> 00:23:23,840
which is very far from three thousand i

600
00:23:21,919 --> 00:23:24,720
haven't formally test that but i can do

601
00:23:23,840 --> 00:23:28,480
an educated

602
00:23:24,720 --> 00:23:30,880
guess here uh so it's uh

603
00:23:28,480 --> 00:23:32,000
it's an it's a nice improvement to re to

604
00:23:30,880 --> 00:23:36,080
remove a sink

605
00:23:32,000 --> 00:23:37,360
uh in in enodb personally i think it's

606
00:23:36,080 --> 00:23:39,600
not game changer

607
00:23:37,360 --> 00:23:41,279
we're just changing by a constant we're

608
00:23:39,600 --> 00:23:46,320
multiplying by two

609
00:23:41,279 --> 00:23:48,559
uh if i would have to choose between

610
00:23:46,320 --> 00:23:50,000
this feature not syncing in odb and

611
00:23:48,559 --> 00:23:53,200
keeping things consistent and

612
00:23:50,000 --> 00:23:55,840
making my sequel or mario db

613
00:23:53,200 --> 00:23:56,720
easier to run with sing bin log equal

614
00:23:55,840 --> 00:23:59,120
zero

615
00:23:56,720 --> 00:24:00,960
i would choose this one but like it's

616
00:23:59,120 --> 00:24:03,199
like different people

617
00:24:00,960 --> 00:24:04,000
work on different parts of the server so

618
00:24:03,200 --> 00:24:05,840
uh

619
00:24:04,000 --> 00:24:09,039
like it's it's still an improvement but

620
00:24:05,840 --> 00:24:18,158
i don't think it's game changer

621
00:24:09,039 --> 00:24:20,480
other questions yes

622
00:24:18,159 --> 00:24:22,240
yeah it's it's basically uh so the

623
00:24:20,480 --> 00:24:25,279
question is about having synthen log

624
00:24:22,240 --> 00:24:28,320
equal to one and trx commit equal to two

625
00:24:25,279 --> 00:24:29,679
uh so uh currently there will be

626
00:24:28,320 --> 00:24:33,120
inconsistencies

627
00:24:29,679 --> 00:24:37,039
uh like between the bin logs and enodb

628
00:24:33,120 --> 00:24:39,039
uh it will remove one sync like doing

629
00:24:37,039 --> 00:24:40,799
one sync on transaction commit instead

630
00:24:39,039 --> 00:24:43,120
of two uh

631
00:24:40,799 --> 00:24:44,240
which in the end is not game changer

632
00:24:43,120 --> 00:24:47,439
because like we're still

633
00:24:44,240 --> 00:24:50,400
waiting for this

634
00:24:47,440 --> 00:24:50,880
so i haven't done tests and thought much

635
00:24:50,400 --> 00:24:54,480
about it

636
00:24:50,880 --> 00:24:58,840
my intuition here it's it's not

637
00:24:54,480 --> 00:25:00,799
in the current context it's not super

638
00:24:58,840 --> 00:25:04,240
useful

639
00:25:00,799 --> 00:25:07,360
any other questions if i have time

640
00:25:04,240 --> 00:25:10,480
one last question one last question yes

641
00:25:07,360 --> 00:25:10,959
would it make sense or what's your view

642
00:25:10,480 --> 00:25:13,520
on

643
00:25:10,960 --> 00:25:16,000
instead of trying to maybe handle

644
00:25:13,520 --> 00:25:18,879
clusters of microscope like beds

645
00:25:16,000 --> 00:25:20,720
handle more like thousands as it is

646
00:25:18,880 --> 00:25:24,559
commonly said instead of trying to

647
00:25:20,720 --> 00:25:27,760
fix either all to maximum

648
00:25:24,559 --> 00:25:28,720
persistence every 31 or if you don't

649
00:25:27,760 --> 00:25:32,000
have the throughput

650
00:25:28,720 --> 00:25:35,120
go to okay it's crash

651
00:25:32,000 --> 00:25:36,559
let's fail lower yes uh so the question

652
00:25:35,120 --> 00:25:38,639
here is instead of taking

653
00:25:36,559 --> 00:25:40,639
each server and being very careful about

654
00:25:38,640 --> 00:25:43,679
the consistency of each server

655
00:25:40,640 --> 00:25:44,640
thinking about like my sequel as like

656
00:25:43,679 --> 00:25:47,919
the full

657
00:25:44,640 --> 00:25:50,400
distributed system uh and if the master

658
00:25:47,919 --> 00:25:52,159
crash failed over to the slave

659
00:25:50,400 --> 00:25:53,679
this is the solution in the case where

660
00:25:52,159 --> 00:25:55,360
you have an operating system crash

661
00:25:53,679 --> 00:25:56,960
on a master if you're running with some

662
00:25:55,360 --> 00:26:02,000
bean log equals zero

663
00:25:56,960 --> 00:26:02,000
you need to fail over to a slave uh so

664
00:26:02,400 --> 00:26:06,559
because you potentially lost data and

665
00:26:04,799 --> 00:26:09,600
your slaves are corrupted so

666
00:26:06,559 --> 00:26:10,879
uh yes that's the solution the dba needs

667
00:26:09,600 --> 00:26:12,879
to think about not

668
00:26:10,880 --> 00:26:14,559
one server but the whole distributed

669
00:26:12,880 --> 00:26:16,000
system which is like replication is a

670
00:26:14,559 --> 00:26:19,120
distributed system

671
00:26:16,000 --> 00:26:20,159
so we have to fail over yes i'm not sure

672
00:26:19,120 --> 00:26:22,399
i have time for

673
00:26:20,159 --> 00:26:24,720
another question but i will be out of

674
00:26:22,400 --> 00:26:27,039
the room if you have questions for me

675
00:26:24,720 --> 00:26:28,559
i'll be just out of the room and ready

676
00:26:27,039 --> 00:26:39,520
to answer your questions

677
00:26:28,559 --> 00:26:41,600
thank you very much

678
00:26:39,520 --> 00:26:41,600
you

