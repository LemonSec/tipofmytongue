1
00:00:05,279 --> 00:00:11,760
okay so we moved to our next talk

2
00:00:07,120 --> 00:00:11,760
please welcome r1 we'll speak about jpeg

3
00:00:14,920 --> 00:00:18,240
2000s

4
00:00:16,480 --> 00:00:19,760
uh good morning everybody my name is

5
00:00:18,240 --> 00:00:23,119
aaron and

6
00:00:19,760 --> 00:00:25,599
today i'm going to talk about jpeg 2000

7
00:00:23,119 --> 00:00:27,920
um just a show of hands has anyone ever

8
00:00:25,599 --> 00:00:30,960
intentionally stored an image

9
00:00:27,920 --> 00:00:33,520
as jpeg 2000 okay

10
00:00:30,960 --> 00:00:35,440
that's impressive um so it was actually

11
00:00:33,520 --> 00:00:38,480
designed to replace

12
00:00:35,440 --> 00:00:40,320
jpeg um but never about 20 years ago but

13
00:00:38,480 --> 00:00:43,519
never really made it

14
00:00:40,320 --> 00:00:44,239
um but i has been one of my obsessions

15
00:00:43,520 --> 00:00:47,039
for the last

16
00:00:44,239 --> 00:00:48,320
five years and i think it's actually the

17
00:00:47,039 --> 00:00:52,000
codec of the future

18
00:00:48,320 --> 00:00:55,280
and that's what we'll go into today

19
00:00:52,000 --> 00:00:57,600
so to understand jpeg 2000 we have to go

20
00:00:55,280 --> 00:00:58,960
back to its predecessor jpeg

21
00:00:57,600 --> 00:01:00,879
and i'm going to take you back into the

22
00:00:58,960 --> 00:01:04,159
90s

23
00:01:00,879 --> 00:01:07,439
to the rise of jpeg so

24
00:01:04,159 --> 00:01:09,600
um this was standardized in 1992

25
00:01:07,439 --> 00:01:10,479
and it really came of age with the

26
00:01:09,600 --> 00:01:12,880
internet as

27
00:01:10,479 --> 00:01:13,920
with the dawn of the internet and by the

28
00:01:12,880 --> 00:01:16,000
end of the 90s

29
00:01:13,920 --> 00:01:17,200
uh about a quarter of the internet

30
00:01:16,000 --> 00:01:20,320
traffic was uh

31
00:01:17,200 --> 00:01:21,119
jpegs now um we all know that was mostly

32
00:01:20,320 --> 00:01:22,960
porn

33
00:01:21,119 --> 00:01:24,640
but uh still that was that was an

34
00:01:22,960 --> 00:01:27,839
important way of

35
00:01:24,640 --> 00:01:29,680
of rising up in the internet and now we

36
00:01:27,840 --> 00:01:31,439
all have a jpeg encoder

37
00:01:29,680 --> 00:01:33,360
a decoder in our pockets in our phone so

38
00:01:31,439 --> 00:01:37,199
it's extremely successful

39
00:01:33,360 --> 00:01:39,520
standard but there were some issues

40
00:01:37,200 --> 00:01:41,680
so um here you have on the right picture

41
00:01:39,520 --> 00:01:44,560
of a flower and you can see

42
00:01:41,680 --> 00:01:45,520
this is about a one bit per sample image

43
00:01:44,560 --> 00:01:48,720
so you can see

44
00:01:45,520 --> 00:01:51,439
the block artifacts that you get

45
00:01:48,720 --> 00:01:52,640
in these that you've all seen over here

46
00:01:51,439 --> 00:01:55,119
because

47
00:01:52,640 --> 00:01:57,360
jpeg uses an eight by eight uh pixel

48
00:01:55,119 --> 00:01:59,280
block to do its compression and so

49
00:01:57,360 --> 00:02:01,520
um when you get very low bit rates you

50
00:01:59,280 --> 00:02:03,600
start to see the boundaries around the

51
00:02:01,520 --> 00:02:04,560
um the pixel blocks the eight by eight

52
00:02:03,600 --> 00:02:06,719
pixel blocks

53
00:02:04,560 --> 00:02:08,959
so that's a big problem another issue is

54
00:02:06,719 --> 00:02:10,000
it's only lossy so if you need lossless

55
00:02:08,959 --> 00:02:12,239
compression

56
00:02:10,000 --> 00:02:14,640
uh you can't use jpeg there is another

57
00:02:12,239 --> 00:02:16,959
there's a lossless standard for jpeg

58
00:02:14,640 --> 00:02:19,200
but nobody really uses it and it's a

59
00:02:16,959 --> 00:02:22,480
completely different codec framework

60
00:02:19,200 --> 00:02:24,399
so um which is an ideal we're also

61
00:02:22,480 --> 00:02:25,920
limited to eight bits so if you wanted

62
00:02:24,400 --> 00:02:28,879
to do a medical

63
00:02:25,920 --> 00:02:31,119
or remote sensing you can't use jpeg for

64
00:02:28,879 --> 00:02:31,120
that

65
00:02:31,280 --> 00:02:35,440
more limitations are you can only use

66
00:02:33,360 --> 00:02:37,200
three components

67
00:02:35,440 --> 00:02:38,560
there's limits on the dimensions of the

68
00:02:37,200 --> 00:02:41,679
image uh

69
00:02:38,560 --> 00:02:44,640
to 16-bit and one of the big

70
00:02:41,680 --> 00:02:46,080
issues is recom rate control so the only

71
00:02:44,640 --> 00:02:48,399
way to actually

72
00:02:46,080 --> 00:02:50,640
uh target a specific rate for an image

73
00:02:48,400 --> 00:02:52,800
is to continually recompress

74
00:02:50,640 --> 00:02:53,679
until you get down to that target image

75
00:02:52,800 --> 00:02:55,360
and um

76
00:02:53,680 --> 00:02:57,440
each time you recompress you're losing

77
00:02:55,360 --> 00:03:00,800
data so it's really not ideal

78
00:02:57,440 --> 00:03:04,319
um so those were the limits um

79
00:03:00,800 --> 00:03:07,280
that gave rise to jpeg 2000

80
00:03:04,319 --> 00:03:08,799
which was supposed to address these

81
00:03:07,280 --> 00:03:10,000
limitations but it also added a whole

82
00:03:08,800 --> 00:03:11,360
bunch of new features which i'm going to

83
00:03:10,000 --> 00:03:14,720
go into

84
00:03:11,360 --> 00:03:16,239
in a moment so um only six years after

85
00:03:14,720 --> 00:03:19,519
jpeg was standardized

86
00:03:16,239 --> 00:03:21,599
this jpeg 2000 they began to standardize

87
00:03:19,519 --> 00:03:24,319
typic 2000 um it was based on the work

88
00:03:21,599 --> 00:03:27,839
by david taubman his thesis work

89
00:03:24,319 --> 00:03:29,040
uh those are the monikers for um the itu

90
00:03:27,840 --> 00:03:32,640
and iso

91
00:03:29,040 --> 00:03:34,879
uh standards and it is free uh

92
00:03:32,640 --> 00:03:36,399
taubman actually donated his ip so that

93
00:03:34,879 --> 00:03:39,840
he would make sure that it was a

94
00:03:36,400 --> 00:03:43,440
royalty-free codec

95
00:03:39,840 --> 00:03:45,680
and um when you introduce a new codec

96
00:03:43,440 --> 00:03:47,599
you definitely want to have better image

97
00:03:45,680 --> 00:03:51,599
compression than the original

98
00:03:47,599 --> 00:03:52,000
so that is in fact the case so jpeg 2000

99
00:03:51,599 --> 00:03:54,959
has

100
00:03:52,000 --> 00:03:56,720
up to 200 percent better performance

101
00:03:54,959 --> 00:03:57,840
than jpeg meaning you get smaller images

102
00:03:56,720 --> 00:04:01,120
for the same

103
00:03:57,840 --> 00:04:03,360
um uh um same

104
00:04:01,120 --> 00:04:05,439
same same bit rate or same uh signal to

105
00:04:03,360 --> 00:04:09,040
noise ratio

106
00:04:05,439 --> 00:04:11,120
um but besides that um you look at the

107
00:04:09,040 --> 00:04:12,640
um artifacts between these two images

108
00:04:11,120 --> 00:04:14,400
it's the it's about

109
00:04:12,640 --> 00:04:16,399
it's a one bit per sample image of the

110
00:04:14,400 --> 00:04:19,680
lena image but you see

111
00:04:16,399 --> 00:04:22,880
um on the right is jpeg 2000 um

112
00:04:19,680 --> 00:04:24,160
because of the transform for a jpeg 2000

113
00:04:22,880 --> 00:04:26,800
we do a wavelet transform

114
00:04:24,160 --> 00:04:27,440
versus a eight by eight uh transfer for

115
00:04:26,800 --> 00:04:29,680
jpeg

116
00:04:27,440 --> 00:04:30,479
so when you lose data you just blur the

117
00:04:29,680 --> 00:04:32,639
image

118
00:04:30,479 --> 00:04:34,080
uh you don't get those pixelated

119
00:04:32,639 --> 00:04:37,120
artifacts in jpeg

120
00:04:34,080 --> 00:04:40,080
so that was a big advantage

121
00:04:37,120 --> 00:04:40,080
for the new standard

122
00:04:40,960 --> 00:04:46,479
and also it supports lossy and lossless

123
00:04:45,120 --> 00:04:47,919
in one framework

124
00:04:46,479 --> 00:04:50,159
um which is nice the only difference

125
00:04:47,919 --> 00:04:51,919
being losty and lossless is um the

126
00:04:50,160 --> 00:04:54,560
transform is a little different

127
00:04:51,919 --> 00:04:56,240
for lossy and there's quantization where

128
00:04:54,560 --> 00:04:58,880
you lose data but otherwise the

129
00:04:56,240 --> 00:04:59,840
framework is exactly the same um and

130
00:04:58,880 --> 00:05:03,039
then you can get

131
00:04:59,840 --> 00:05:03,520
visually lossless uh encoding where

132
00:05:03,039 --> 00:05:06,240
there is

133
00:05:03,520 --> 00:05:08,080
loss of data but you can't uh the human

134
00:05:06,240 --> 00:05:10,240
eye can't detect the difference

135
00:05:08,080 --> 00:05:12,400
so that's visually excuse me visually

136
00:05:10,240 --> 00:05:14,320
lossless

137
00:05:12,400 --> 00:05:15,679
um one of the big innovations though is

138
00:05:14,320 --> 00:05:18,719
the progression um

139
00:05:15,680 --> 00:05:21,919
that it introduces so um progression is

140
00:05:18,720 --> 00:05:24,080
used by a codec to um so that the

141
00:05:21,919 --> 00:05:25,680
decoder can do a partial decode of the

142
00:05:24,080 --> 00:05:28,960
image and still get something

143
00:05:25,680 --> 00:05:30,320
useful out of it and here this is what

144
00:05:28,960 --> 00:05:32,560
people are mostly familiar with

145
00:05:30,320 --> 00:05:33,440
is a progression by quality so you can

146
00:05:32,560 --> 00:05:36,240
see that

147
00:05:33,440 --> 00:05:36,719
image of the butterfly being downloaded

148
00:05:36,240 --> 00:05:39,360
and

149
00:05:36,720 --> 00:05:40,800
already by the first second or third

150
00:05:39,360 --> 00:05:41,840
frame you can start to see something

151
00:05:40,800 --> 00:05:43,520
useful even though you've only

152
00:05:41,840 --> 00:05:46,799
downloaded about eight percent

153
00:05:43,520 --> 00:05:50,880
of the image so um jpeg 2000

154
00:05:46,800 --> 00:05:53,680
allows you to um create quality layers

155
00:05:50,880 --> 00:05:54,400
and that you can and package up those

156
00:05:53,680 --> 00:05:57,520
layers

157
00:05:54,400 --> 00:05:59,840
and if you progress by quality you can

158
00:05:57,520 --> 00:06:01,599
progressively download and get a useful

159
00:05:59,840 --> 00:06:03,440
image when you haven't downloaded the

160
00:06:01,600 --> 00:06:04,840
the complete result and this is how we

161
00:06:03,440 --> 00:06:07,840
do it

162
00:06:04,840 --> 00:06:08,479
so that's an image of a castle in eight

163
00:06:07,840 --> 00:06:11,919
bits

164
00:06:08,479 --> 00:06:14,000
so these are the bit planes for all the

165
00:06:11,919 --> 00:06:15,599
bits in each of those samples

166
00:06:14,000 --> 00:06:17,199
so that's the so that's the most

167
00:06:15,600 --> 00:06:19,280
significant bit over there

168
00:06:17,199 --> 00:06:20,479
and so we create these bit planes and

169
00:06:19,280 --> 00:06:22,799
each plane is

170
00:06:20,479 --> 00:06:23,840
compressed uh there's three different

171
00:06:22,800 --> 00:06:26,000
passes that we

172
00:06:23,840 --> 00:06:27,599
run through the through the plane to

173
00:06:26,000 --> 00:06:29,600
compress it so it's very

174
00:06:27,600 --> 00:06:30,720
computationally expensive but we create

175
00:06:29,600 --> 00:06:34,160
many different

176
00:06:30,720 --> 00:06:36,000
uh layers or or passes

177
00:06:34,160 --> 00:06:37,440
for that image that we can then package

178
00:06:36,000 --> 00:06:39,199
up into different quality layers and you

179
00:06:37,440 --> 00:06:41,840
get a very fine-grained

180
00:06:39,199 --> 00:06:42,800
uh set of quality layers that you can

181
00:06:41,840 --> 00:06:48,239
break the image

182
00:06:42,800 --> 00:06:52,080
up into and and that's

183
00:06:48,240 --> 00:06:54,720
a graph of the distortion as you

184
00:06:52,080 --> 00:06:56,240
build up the bit planes so for an 8-bit

185
00:06:54,720 --> 00:06:58,319
image you could have 23

186
00:06:56,240 --> 00:06:59,680
different passes and each pass can be

187
00:06:58,319 --> 00:07:03,199
packaged up in different

188
00:06:59,680 --> 00:07:05,759
quality layers using this epcot which is

189
00:07:03,199 --> 00:07:06,639
the formula the algorithm for for

190
00:07:05,759 --> 00:07:09,840
determining these

191
00:07:06,639 --> 00:07:13,199
quality layers and um and so

192
00:07:09,840 --> 00:07:14,400
that was a big innovation but there's

193
00:07:13,199 --> 00:07:16,400
three other different ways of

194
00:07:14,400 --> 00:07:18,400
progressing in jpeg 2000 this is

195
00:07:16,400 --> 00:07:19,919
progression by resolution so that's a

196
00:07:18,400 --> 00:07:22,638
that's a wavelet

197
00:07:19,919 --> 00:07:24,400
uh transform of this image we we do low

198
00:07:22,639 --> 00:07:26,319
and high pass filters

199
00:07:24,400 --> 00:07:28,638
on the x and y coordinates and so we

200
00:07:26,319 --> 00:07:29,759
actually uh on the top left you get a

201
00:07:28,639 --> 00:07:32,080
low res

202
00:07:29,759 --> 00:07:33,440
thumbnail of the original image and then

203
00:07:32,080 --> 00:07:36,880
high pass

204
00:07:33,440 --> 00:07:38,880
high pass bands they're called sub bands

205
00:07:36,880 --> 00:07:40,800
so there's four different sub bands and

206
00:07:38,880 --> 00:07:41,440
so built in baked into the codec you

207
00:07:40,800 --> 00:07:43,599
have

208
00:07:41,440 --> 00:07:45,840
lower resolution replicas of the

209
00:07:43,599 --> 00:07:48,878
original image without any redundancy

210
00:07:45,840 --> 00:07:51,280
and we would do this wavelet transform

211
00:07:48,879 --> 00:07:53,520
maybe four or five times so you inside

212
00:07:51,280 --> 00:07:55,198
the actual image there are multiple

213
00:07:53,520 --> 00:07:56,878
lower resolution replicas that you could

214
00:07:55,199 --> 00:07:59,919
then as you're decoding

215
00:07:56,879 --> 00:08:01,039
um you could bring those images out

216
00:07:59,919 --> 00:08:02,878
without actually

217
00:08:01,039 --> 00:08:04,479
storing extra data as a thumbnail it's

218
00:08:02,879 --> 00:08:06,879
actually built in so you can progress by

219
00:08:04,479 --> 00:08:10,000
resolution

220
00:08:06,879 --> 00:08:11,840
if you if that's how you encode it

221
00:08:10,000 --> 00:08:13,680
there's also a progression by spatial

222
00:08:11,840 --> 00:08:16,080
region uh

223
00:08:13,680 --> 00:08:16,960
you can see these are the original sub

224
00:08:16,080 --> 00:08:19,758
bands that

225
00:08:16,960 --> 00:08:20,479
we had from the wavelet these big blue

226
00:08:19,759 --> 00:08:23,120
boxes

227
00:08:20,479 --> 00:08:24,400
and then inside we have the precincts

228
00:08:23,120 --> 00:08:25,360
and inside the precincts we have the

229
00:08:24,400 --> 00:08:28,400
code blocks

230
00:08:25,360 --> 00:08:31,599
and so you can actually encode by

231
00:08:28,400 --> 00:08:33,598
precinct and store the image

232
00:08:31,599 --> 00:08:35,919
progressing that way and that's useful

233
00:08:33,599 --> 00:08:37,360
for let's say you have a scanner

234
00:08:35,919 --> 00:08:40,240
let's say you're limited by memory you

235
00:08:37,360 --> 00:08:43,279
might want to encode one

236
00:08:40,240 --> 00:08:46,160
precinct at a time and then move on

237
00:08:43,279 --> 00:08:46,959
and it's also useful for random access

238
00:08:46,160 --> 00:08:49,839
into the

239
00:08:46,959 --> 00:08:51,040
into the image and the final one is

240
00:08:49,839 --> 00:08:55,200
progression by component

241
00:08:51,040 --> 00:08:57,199
so if it's an rgb image you can

242
00:08:55,200 --> 00:08:58,959
break it down into your luminance and

243
00:08:57,200 --> 00:09:01,839
your chroma channels and you can

244
00:08:58,959 --> 00:09:03,359
progress by those channels and if you're

245
00:09:01,839 --> 00:09:04,640
a grayscale printer maybe you can just

246
00:09:03,360 --> 00:09:07,360
throw away the chroma

247
00:09:04,640 --> 00:09:10,800
and keep the luminance so that's that's

248
00:09:07,360 --> 00:09:12,160
another progression that you can get

249
00:09:10,800 --> 00:09:14,479
there's a bunch of other features that

250
00:09:12,160 --> 00:09:17,439
you you have in jpeg 2000 one is

251
00:09:14,480 --> 00:09:19,120
error resilience so you built into the

252
00:09:17,440 --> 00:09:19,760
code stream when you're encoding it you

253
00:09:19,120 --> 00:09:22,080
can

254
00:09:19,760 --> 00:09:24,000
you have to terminate each code stream

255
00:09:22,080 --> 00:09:25,440
segment and you can terminate those

256
00:09:24,000 --> 00:09:27,279
segments in a way that

257
00:09:25,440 --> 00:09:28,720
when the decoder is decoding those

258
00:09:27,279 --> 00:09:29,920
segments it can tell whether there's

259
00:09:28,720 --> 00:09:33,440
been an error

260
00:09:29,920 --> 00:09:35,920
in the segment and also we have these

261
00:09:33,440 --> 00:09:37,519
precincts that contain

262
00:09:35,920 --> 00:09:39,360
errors in the code so if there's an

263
00:09:37,519 --> 00:09:41,440
error in one precinct it can't

264
00:09:39,360 --> 00:09:43,519
migrate into the next precinct so we

265
00:09:41,440 --> 00:09:46,959
contain errors that way

266
00:09:43,519 --> 00:09:49,279
we also have recompression resilience so

267
00:09:46,959 --> 00:09:50,959
typically an image might be compressed

268
00:09:49,279 --> 00:09:54,160
and decompressed multiple times

269
00:09:50,959 --> 00:09:56,560
and so uh the codec is doesn't

270
00:09:54,160 --> 00:09:57,920
lose a lot of information for the for

271
00:09:56,560 --> 00:09:59,518
the subsequent

272
00:09:57,920 --> 00:10:01,439
compression and recompression like

273
00:09:59,519 --> 00:10:03,519
decode and decode so

274
00:10:01,440 --> 00:10:05,680
it's um it's a that's another feature to

275
00:10:03,519 --> 00:10:08,880
have that we have

276
00:10:05,680 --> 00:10:10,000
um and then you get random access into

277
00:10:08,880 --> 00:10:12,560
the code stream from

278
00:10:10,000 --> 00:10:14,240
if you do uh progression by code block

279
00:10:12,560 --> 00:10:15,279
so if you have an enormous image from a

280
00:10:14,240 --> 00:10:17,200
remote sensing

281
00:10:15,279 --> 00:10:19,279
let's say you want to just decode a

282
00:10:17,200 --> 00:10:21,519
small piece of the image you can

283
00:10:19,279 --> 00:10:23,120
actually put markers into the code so

284
00:10:21,519 --> 00:10:25,120
that you can locate that

285
00:10:23,120 --> 00:10:26,240
particular region of the image and

286
00:10:25,120 --> 00:10:30,240
decode that

287
00:10:26,240 --> 00:10:30,240
which is useful for for huge images

288
00:10:30,640 --> 00:10:34,720
we also do low latency because it's an

289
00:10:32,320 --> 00:10:37,120
intra codec so each frame is encoded

290
00:10:34,720 --> 00:10:39,519
individually and so you can um get very

291
00:10:37,120 --> 00:10:40,720
low latency unlike uh for example h.264

292
00:10:39,519 --> 00:10:42,640
where you have groups of pictures

293
00:10:40,720 --> 00:10:43,760
that are encoded together each frame is

294
00:10:42,640 --> 00:10:46,399
encoded separately

295
00:10:43,760 --> 00:10:48,560
and you can get low latency that way

296
00:10:46,399 --> 00:10:50,480
also a region of interest where you just

297
00:10:48,560 --> 00:10:53,359
increase the quality in a certain part

298
00:10:50,480 --> 00:10:54,800
of the image let's say you're doing

299
00:10:53,360 --> 00:10:56,640
video conferencing you want to focus on

300
00:10:54,800 --> 00:11:00,319
the face so that's

301
00:10:56,640 --> 00:11:01,199
built in as well so with all these cool

302
00:11:00,320 --> 00:11:04,240
features um

303
00:11:01,200 --> 00:11:05,120
who adopted j2k um first of all with

304
00:11:04,240 --> 00:11:06,959
medical

305
00:11:05,120 --> 00:11:09,040
imaging it's uh considered the gold

306
00:11:06,959 --> 00:11:11,359
standard because you can do lossless

307
00:11:09,040 --> 00:11:13,360
which is important for legal issues and

308
00:11:11,360 --> 00:11:17,279
you can do high bit rates like 10

309
00:11:13,360 --> 00:11:17,839
12 and 16 bits so medical imaging it's

310
00:11:17,279 --> 00:11:19,920
popular

311
00:11:17,839 --> 00:11:21,040
in remote sensing because you can

312
00:11:19,920 --> 00:11:23,839
support 16

313
00:11:21,040 --> 00:11:26,160
000 components if you like so and very

314
00:11:23,839 --> 00:11:29,839
large dimensions so it's popular

315
00:11:26,160 --> 00:11:31,199
there um and also a few people realize

316
00:11:29,839 --> 00:11:33,200
that whenever you watch a movie you're

317
00:11:31,200 --> 00:11:34,560
actually watching jpeg 2000 decoding

318
00:11:33,200 --> 00:11:37,120
because it's the standard

319
00:11:34,560 --> 00:11:40,079
for digital cinema and the reason is

320
00:11:37,120 --> 00:11:42,160
because of that resolution by

321
00:11:40,079 --> 00:11:44,239
a progression by resolution because the

322
00:11:42,160 --> 00:11:47,600
4k image that you encode

323
00:11:44,240 --> 00:11:48,800
has a 2k image built in so the 2k

324
00:11:47,600 --> 00:11:51,920
projector can

325
00:11:48,800 --> 00:11:54,000
actually just decode the low level

326
00:11:51,920 --> 00:11:56,160
sub band and throw away the rest so it's

327
00:11:54,000 --> 00:11:59,680
backwards compatible and that's

328
00:11:56,160 --> 00:11:59,680
used it's a standard today

329
00:12:00,160 --> 00:12:04,800
and so what went wrong with all these

330
00:12:02,720 --> 00:12:08,839
wonderful features

331
00:12:04,800 --> 00:12:11,920
yes there is an xkcd comic for this

332
00:12:08,839 --> 00:12:14,399
um well first of all patents

333
00:12:11,920 --> 00:12:15,439
um there was a company called lizard

334
00:12:14,399 --> 00:12:18,240
tech

335
00:12:15,440 --> 00:12:19,839
which uh claimed all wavelet based

336
00:12:18,240 --> 00:12:21,440
codecs were there where

337
00:12:19,839 --> 00:12:23,600
you had to license from them and that

338
00:12:21,440 --> 00:12:26,480
was eventually invalidated but that was

339
00:12:23,600 --> 00:12:27,279
caused some fun for the emerging

340
00:12:26,480 --> 00:12:29,519
standard

341
00:12:27,279 --> 00:12:30,880
microsoft was uh the monopoly in those

342
00:12:29,519 --> 00:12:31,600
days and they had their competing

343
00:12:30,880 --> 00:12:36,079
standard called

344
00:12:31,600 --> 00:12:39,680
xr jpxr so they didn't support jp2000

345
00:12:36,079 --> 00:12:42,479
there was browser support was poor even

346
00:12:39,680 --> 00:12:43,760
this is 2015. you can see only 20 of the

347
00:12:42,480 --> 00:12:47,600
browsers support

348
00:12:43,760 --> 00:12:49,519
the standard and um hardware support

349
00:12:47,600 --> 00:12:50,639
um the hardware vendors were waiting for

350
00:12:49,519 --> 00:12:53,360
the software

351
00:12:50,639 --> 00:12:54,800
uh people to be able to display the

352
00:12:53,360 --> 00:12:56,160
images the software vendors were waiting

353
00:12:54,800 --> 00:12:58,560
for the hardware to

354
00:12:56,160 --> 00:12:59,279
produce those images so it they never

355
00:12:58,560 --> 00:13:02,719
really

356
00:12:59,279 --> 00:13:03,519
supported them in hardware and finally

357
00:13:02,720 --> 00:13:05,440
performance

358
00:13:03,519 --> 00:13:07,600
this because of the complexity of the

359
00:13:05,440 --> 00:13:08,079
codec it's very very slow because of all

360
00:13:07,600 --> 00:13:09,839
those

361
00:13:08,079 --> 00:13:12,399
passes through all those bit planes it's

362
00:13:09,839 --> 00:13:15,760
a very very complex codec and so it was

363
00:13:12,399 --> 00:13:16,800
very slow um and jpeg was already there

364
00:13:15,760 --> 00:13:20,160
so that was good enough

365
00:13:16,800 --> 00:13:23,920
so those were all the reasons why

366
00:13:20,160 --> 00:13:27,120
it never really made it um

367
00:13:23,920 --> 00:13:30,160
now there's been a change in the codec

368
00:13:27,120 --> 00:13:34,079
to address the performance

369
00:13:30,160 --> 00:13:35,920
called high throughput jpeg 2000 and

370
00:13:34,079 --> 00:13:38,160
they keep everything the same and they

371
00:13:35,920 --> 00:13:40,959
change the block coder which is the

372
00:13:38,160 --> 00:13:41,600
piece at the very center uh of the codec

373
00:13:40,959 --> 00:13:43,199
that actually

374
00:13:41,600 --> 00:13:44,800
creates the bitstream and that's what

375
00:13:43,199 --> 00:13:46,800
what creates all those

376
00:13:44,800 --> 00:13:49,279
bit planes and all those passes so

377
00:13:46,800 --> 00:13:52,000
they've simplified the block coder

378
00:13:49,279 --> 00:13:52,720
and um this gives you a big speed

379
00:13:52,000 --> 00:13:55,839
increase

380
00:13:52,720 --> 00:13:57,440
uh 10 times possibly and it's was

381
00:13:55,839 --> 00:14:00,880
standardized this year

382
00:13:57,440 --> 00:14:02,800
sorry last year 2019 and so it's also

383
00:14:00,880 --> 00:14:06,959
royalty free

384
00:14:02,800 --> 00:14:09,839
and the difference is that it's actually

385
00:14:06,959 --> 00:14:11,119
friendly for gpus and vector

386
00:14:09,839 --> 00:14:12,800
calculations which was

387
00:14:11,120 --> 00:14:14,320
different than the original encoder

388
00:14:12,800 --> 00:14:16,800
which was designed when actually

389
00:14:14,320 --> 00:14:19,199
multiplication was expensive

390
00:14:16,800 --> 00:14:20,560
so they tried to avoid multiplication by

391
00:14:19,199 --> 00:14:23,599
creating branches and

392
00:14:20,560 --> 00:14:25,279
and and doing a very serial approach

393
00:14:23,600 --> 00:14:27,360
and so that doesn't really work on

394
00:14:25,279 --> 00:14:30,000
modern hardware so this one is designed

395
00:14:27,360 --> 00:14:31,120
um with cindy in mind there are fewer

396
00:14:30,000 --> 00:14:33,279
passes

397
00:14:31,120 --> 00:14:34,240
and you just sacrifice the quality

398
00:14:33,279 --> 00:14:36,240
scalability

399
00:14:34,240 --> 00:14:39,040
that you had from the original jpeg but

400
00:14:36,240 --> 00:14:41,839
everything else is the same

401
00:14:39,040 --> 00:14:44,079
and you can also losslessly transcode

402
00:14:41,839 --> 00:14:46,320
between the two formats so you can

403
00:14:44,079 --> 00:14:47,199
encode it one way it for speed and then

404
00:14:46,320 --> 00:14:50,639
later

405
00:14:47,199 --> 00:14:54,000
convert it to the original for

406
00:14:50,639 --> 00:14:56,240
distribution and they're trying there is

407
00:14:54,000 --> 00:14:56,800
a decoder in it by within script and

408
00:14:56,240 --> 00:14:59,279
that will

409
00:14:56,800 --> 00:15:02,000
hopefully address the browser issues

410
00:14:59,279 --> 00:15:04,160
that they had with the original standard

411
00:15:02,000 --> 00:15:05,440
um these are the open source toolkits

412
00:15:04,160 --> 00:15:09,040
open jpeg is the

413
00:15:05,440 --> 00:15:10,839
and the granddaddy of j2k toolkits

414
00:15:09,040 --> 00:15:12,719
there's grok which is one that i

415
00:15:10,839 --> 00:15:14,800
maintain

416
00:15:12,720 --> 00:15:17,760
and there's something called open jph

417
00:15:14,800 --> 00:15:22,240
which is only for

418
00:15:17,760 --> 00:15:26,560
high throughput jpeg 2000

419
00:15:22,240 --> 00:15:29,199
and any questions

420
00:15:26,560 --> 00:15:29,680
i i i have a lot of time for questions

421
00:15:29,199 --> 00:15:32,880
we have

422
00:15:29,680 --> 00:15:36,479
questions from um the online

423
00:15:32,880 --> 00:15:37,920
uh forum a lot of questions about jpeg

424
00:15:36,480 --> 00:15:39,920
access

425
00:15:37,920 --> 00:15:41,519
right actually i had slides for jpeg xs

426
00:15:39,920 --> 00:15:43,680
and i took them out because i

427
00:15:41,519 --> 00:15:44,560
i thought i would be going over time but

428
00:15:43,680 --> 00:15:46,959
um so

429
00:15:44,560 --> 00:15:47,839
so yeah i can talk about that a little

430
00:15:46,959 --> 00:15:50,638
bit um so

431
00:15:47,839 --> 00:15:51,360
jpeg xs is actually a competing standard

432
00:15:50,639 --> 00:15:54,560
for the same

433
00:15:51,360 --> 00:15:58,000
space it's based on a wavelet transform

434
00:15:54,560 --> 00:15:59,599
it's also low complexity low latency

435
00:15:58,000 --> 00:16:02,079
the big difference is that it's actually

436
00:15:59,600 --> 00:16:03,199
a patented standard it's being promoted

437
00:16:02,079 --> 00:16:05,519
by intupix

438
00:16:03,199 --> 00:16:08,479
and fraunhofer the people who brought

439
00:16:05,519 --> 00:16:11,759
you the mp3 patents um

440
00:16:08,480 --> 00:16:14,800
they are way hoping to license that

441
00:16:11,759 --> 00:16:16,240
so i'm hoping that the open

442
00:16:14,800 --> 00:16:17,920
solution is going to win but they're

443
00:16:16,240 --> 00:16:20,880
they're in the same space and actually

444
00:16:17,920 --> 00:16:22,479
from what i've heard the j2k is actually

445
00:16:20,880 --> 00:16:25,600
faster

446
00:16:22,480 --> 00:16:27,519
than the um than the jpeg xs

447
00:16:25,600 --> 00:16:29,279
and it's actually the image quality is

448
00:16:27,519 --> 00:16:32,560
is higher for the same bit rates

449
00:16:29,279 --> 00:16:34,160
so um so it looks promising but that is

450
00:16:32,560 --> 00:16:37,439
a competing standard

451
00:16:34,160 --> 00:16:41,439
in the same space um how do you think

452
00:16:37,440 --> 00:16:41,440
also about any questions

453
00:16:41,600 --> 00:16:45,600
what about the new energetic standard

454
00:16:44,320 --> 00:16:48,320
called xl

455
00:16:45,600 --> 00:16:50,959
with the google algorithm that will

456
00:16:48,320 --> 00:16:50,959
start next

457
00:16:58,160 --> 00:17:02,000
sorry the question is um how will the

458
00:17:00,240 --> 00:17:05,679
new jpeg xl

459
00:17:02,000 --> 00:17:08,160
standard compare with jpeg 2000 um

460
00:17:05,679 --> 00:17:10,000
actually i'm not i actually don't not

461
00:17:08,160 --> 00:17:13,360
familiar with the xl standard

462
00:17:10,000 --> 00:17:18,400
so um i can't really comment on that

463
00:17:13,359 --> 00:17:21,599
but um

464
00:17:18,400 --> 00:17:26,319
some people from google and it's

465
00:17:21,599 --> 00:17:30,240
great compatible with jpeg but as

466
00:17:26,319 --> 00:17:32,399
complicated but has additional features

467
00:17:30,240 --> 00:17:32,400
from

468
00:17:32,960 --> 00:17:38,320
really um yeah well um yeah i

469
00:17:36,080 --> 00:17:40,000
i i can't really it's hard to say but

470
00:17:38,320 --> 00:17:41,439
it's um i mean the more standards

471
00:17:40,000 --> 00:17:42,720
i think i mean the nice thing about

472
00:17:41,440 --> 00:17:43,520
standards is there's so many to choose

473
00:17:42,720 --> 00:17:46,320
from

474
00:17:43,520 --> 00:17:48,559
and um so i think it'll be it's it's

475
00:17:46,320 --> 00:17:50,639
we're actually in a renaissance a jpeg

476
00:17:48,559 --> 00:17:51,760
of jpeg standards and there's uh there's

477
00:17:50,640 --> 00:17:54,080
there's xt

478
00:17:51,760 --> 00:17:55,600
i think which is backwards compatible

479
00:17:54,080 --> 00:17:57,520
with jpeg but adds

480
00:17:55,600 --> 00:17:58,799
hdr and things like that so i think i

481
00:17:57,520 --> 00:18:00,639
think it's a good thing that

482
00:17:58,799 --> 00:18:03,120
i i'd have to learn more about this

483
00:18:00,640 --> 00:18:05,760
codec to comment

484
00:18:03,120 --> 00:18:08,479
so you mentioned that it's a very kind

485
00:18:05,760 --> 00:18:12,879
of a scalable project that you can

486
00:18:08,480 --> 00:18:15,840
extract low resolution images from

487
00:18:12,880 --> 00:18:15,840
uh

488
00:18:33,600 --> 00:18:41,039
so the question is would is it possible

489
00:18:37,600 --> 00:18:42,799
to decode an image

490
00:18:41,039 --> 00:18:44,240
starting with the lower resolution first

491
00:18:42,799 --> 00:18:47,520
and progressing

492
00:18:44,240 --> 00:18:50,640
upwards is that yes so you can start

493
00:18:47,520 --> 00:18:52,240
um so yeah that's that's the whole yeah

494
00:18:50,640 --> 00:18:54,000
yes you can so that's the whole point of

495
00:18:52,240 --> 00:18:54,880
progression is the way if you encode it

496
00:18:54,000 --> 00:18:57,200
and store it

497
00:18:54,880 --> 00:18:58,640
by resolution then you can actually you

498
00:18:57,200 --> 00:18:59,600
can actually choose i only want the

499
00:18:58,640 --> 00:19:01,520
lowest two

500
00:18:59,600 --> 00:19:03,039
or three resolutions and you throw away

501
00:19:01,520 --> 00:19:05,200
everything else and you can only

502
00:19:03,039 --> 00:19:06,480
you may not even just send that low

503
00:19:05,200 --> 00:19:11,840
resolution piece

504
00:19:06,480 --> 00:19:11,840
so yeah it's designed to do that

505
00:19:18,000 --> 00:19:24,480
um oh sorry the question is

506
00:19:21,679 --> 00:19:25,280
is it possible to only truncate by

507
00:19:24,480 --> 00:19:27,840
resolution

508
00:19:25,280 --> 00:19:28,320
and then throw away the rest um well you

509
00:19:27,840 --> 00:19:30,720
mean

510
00:19:28,320 --> 00:19:31,360
from the encoder to actually encoding in

511
00:19:30,720 --> 00:19:33,919
terms of

512
00:19:31,360 --> 00:19:34,559
if you wanted to store lower resolution

513
00:19:33,919 --> 00:19:36,320
textures

514
00:19:34,559 --> 00:19:38,240
you could literally store the first 10

515
00:19:36,320 --> 00:19:41,039
of the file if that date is held in a

516
00:19:38,240 --> 00:19:43,919
linear in that linear fashion

517
00:19:41,039 --> 00:19:44,720
um you would not become i think you

518
00:19:43,919 --> 00:19:46,480
would if you

519
00:19:44,720 --> 00:19:48,000
it wouldn't really be compliant because

520
00:19:46,480 --> 00:19:49,600
the the header would say i have 10

521
00:19:48,000 --> 00:19:51,679
resolutions and you've only

522
00:19:49,600 --> 00:19:52,959
stored three but most of the decoders

523
00:19:51,679 --> 00:19:56,080
are used to handling all

524
00:19:52,960 --> 00:19:56,799
um abuse of the standard and so they

525
00:19:56,080 --> 00:19:59,760
will

526
00:19:56,799 --> 00:20:02,080
um handle that they will only you could

527
00:19:59,760 --> 00:20:04,000
you could store it it would be decoded

528
00:20:02,080 --> 00:20:05,199
they might complain about it but they

529
00:20:04,000 --> 00:20:06,880
they would decode

530
00:20:05,200 --> 00:20:08,000
those lower so it's that's that you

531
00:20:06,880 --> 00:20:09,200
could you could definitely do that and

532
00:20:08,000 --> 00:20:10,640
there's actually a

533
00:20:09,200 --> 00:20:12,640
i didn't go into there's a there's

534
00:20:10,640 --> 00:20:14,159
something called jpip which is a

535
00:20:12,640 --> 00:20:16,000
progressive

536
00:20:14,159 --> 00:20:17,679
format for for doing this actually

537
00:20:16,000 --> 00:20:18,400
there's that for for sending it over the

538
00:20:17,679 --> 00:20:20,880
wire

539
00:20:18,400 --> 00:20:22,240
there's actually a a standard part of

540
00:20:20,880 --> 00:20:26,880
the jpeg 2000

541
00:20:22,240 --> 00:20:29,200
standard for doing progressive um

542
00:20:26,880 --> 00:20:31,440
sending it progressively over the the

543
00:20:29,200 --> 00:20:33,679
network

544
00:20:31,440 --> 00:20:33,679
yes

545
00:20:43,280 --> 00:20:48,399
the question is is jpeg 2000 available

546
00:20:45,360 --> 00:20:51,280
as mxf so

547
00:20:48,400 --> 00:20:52,080
mxf is the exchange format for um so yes

548
00:20:51,280 --> 00:20:55,440
so ms

549
00:20:52,080 --> 00:20:57,199
mxf supports jpeg 2000 and so you could

550
00:20:55,440 --> 00:20:59,440
you could package it

551
00:20:57,200 --> 00:20:59,440
um

552
00:21:00,400 --> 00:21:04,960
well this is very new so i think you'll

553
00:21:02,559 --> 00:21:07,280
be getting i don't think mxf supports it

554
00:21:04,960 --> 00:21:08,799
they're going to be adding it to mxf i

555
00:21:07,280 --> 00:21:10,158
know that and they're going to be adding

556
00:21:08,799 --> 00:21:12,240
it to the digital

557
00:21:10,159 --> 00:21:14,880
cinema standard and i think everyone's

558
00:21:12,240 --> 00:21:17,840
going to be adopting us because

559
00:21:14,880 --> 00:21:19,679
it's uh just fixes some problems and

560
00:21:17,840 --> 00:21:20,480
doesn't really have much of a downside

561
00:21:19,679 --> 00:21:22,240
for those

562
00:21:20,480 --> 00:21:24,000
workflows because because you don't need

563
00:21:22,240 --> 00:21:27,919
the progression by quality

564
00:21:24,000 --> 00:21:29,919
so much for for in that workflow so

565
00:21:27,919 --> 00:21:31,440
um but mxf yeah i don't think it

566
00:21:29,919 --> 00:21:33,039
supports because it was just

567
00:21:31,440 --> 00:21:35,280
uh end of last year that they

568
00:21:33,039 --> 00:21:45,840
standardized the high throughput so

569
00:21:35,280 --> 00:21:45,840
it but i think it will come

570
00:21:48,000 --> 00:21:52,720
so the question is how much slower is

571
00:21:50,400 --> 00:21:54,400
jpeg 2000 versus jpeg

572
00:21:52,720 --> 00:21:56,080
it depends a lot on the implementation

573
00:21:54,400 --> 00:21:59,120
so

574
00:21:56,080 --> 00:22:02,399
the for example open jpeg was really

575
00:21:59,120 --> 00:22:05,199
in terms of open source toolkits so

576
00:22:02,400 --> 00:22:06,400
so david taubman has his own codec

577
00:22:05,200 --> 00:22:10,000
that's um

578
00:22:06,400 --> 00:22:12,240
closed kodak called kakadu which has

579
00:22:10,000 --> 00:22:13,200
always been very fast and had all the

580
00:22:12,240 --> 00:22:16,080
features

581
00:22:13,200 --> 00:22:16,559
and the open source toolkits were slow

582
00:22:16,080 --> 00:22:19,120
and

583
00:22:16,559 --> 00:22:19,918
and filled with bugs for the longest

584
00:22:19,120 --> 00:22:22,000
time

585
00:22:19,919 --> 00:22:24,480
but recently um they've gotten quite

586
00:22:22,000 --> 00:22:27,760
fast so they now support multi-threading

587
00:22:24,480 --> 00:22:31,440
they've tried to optimize them um so

588
00:22:27,760 --> 00:22:33,520
i don't have actual numbers but um

589
00:22:31,440 --> 00:22:35,760
on a modern machine with a good with

590
00:22:33,520 --> 00:22:37,918
even with open jpeg or with my

591
00:22:35,760 --> 00:22:40,480
uh toolkit um i think you're you're

592
00:22:37,919 --> 00:22:43,679
looking at maybe

593
00:22:40,480 --> 00:22:45,120
twice as slow for the j2k but with the

594
00:22:43,679 --> 00:22:47,280
with the with a new high throughput i

595
00:22:45,120 --> 00:22:49,918
think we could actually get faster

596
00:22:47,280 --> 00:22:50,960
than jpeg because it's designed for um

597
00:22:49,919 --> 00:22:52,880
gpu and for

598
00:22:50,960 --> 00:22:54,400
for vector operations so i think we can

599
00:22:52,880 --> 00:22:56,400
actually get faster

600
00:22:54,400 --> 00:22:58,960
than jpeg which is going to be really

601
00:22:56,400 --> 00:22:58,960
cool i think

602
00:23:06,840 --> 00:23:09,840
yes

603
00:23:14,010 --> 00:23:17,079
[Music]

604
00:23:18,559 --> 00:23:21,678
so the question is what's the expected

605
00:23:20,400 --> 00:23:24,880
encode time for

606
00:23:21,679 --> 00:23:28,240
for it it depends on the size of the

607
00:23:24,880 --> 00:23:31,760
image and a 4k image um

608
00:23:28,240 --> 00:23:34,960
okay so uh on modern hardware um

609
00:23:31,760 --> 00:23:37,360
so so to so now you could get you could

610
00:23:34,960 --> 00:23:39,600
encode that okay encoding

611
00:23:37,360 --> 00:23:41,520
see the some of the codecs they don't

612
00:23:39,600 --> 00:23:43,039
focus on encoding they focus on decoding

613
00:23:41,520 --> 00:23:44,559
and encoding is slow it actually open

614
00:23:43,039 --> 00:23:48,320
jpeg gets single threaded

615
00:23:44,559 --> 00:23:51,520
but um so encoding a 4k image um

616
00:23:48,320 --> 00:23:52,480
it's like an 8 bit uh 8-bit image or a

617
00:23:51,520 --> 00:23:55,440
12-bit

618
00:23:52,480 --> 00:23:56,240
8-bit um i guess maybe you could do it

619
00:23:55,440 --> 00:23:59,440
um

620
00:23:56,240 --> 00:24:01,679
uh 10-15 frames per second on

621
00:23:59,440 --> 00:24:03,200
on a modern machine and with the

622
00:24:01,679 --> 00:24:05,120
multi-core with the you know with the

623
00:24:03,200 --> 00:24:06,080
new uh thread rippers and all that you

624
00:24:05,120 --> 00:24:08,479
can really

625
00:24:06,080 --> 00:24:09,600
get a good performance but um it's it

626
00:24:08,480 --> 00:24:10,480
would it would really depend a lot on

627
00:24:09,600 --> 00:24:12,639
the image

628
00:24:10,480 --> 00:24:13,600
and the content and how compressible it

629
00:24:12,640 --> 00:24:16,400
is and

630
00:24:13,600 --> 00:24:17,520
um how many cores and all that but um

631
00:24:16,400 --> 00:24:20,400
you can

632
00:24:17,520 --> 00:24:20,960
you could get maybe 10 15 frames per

633
00:24:20,400 --> 00:24:24,000
second

634
00:24:20,960 --> 00:24:27,039
encoding on on a modern cpu and

635
00:24:24,000 --> 00:24:28,080
the decoder could be even um maybe 20

636
00:24:27,039 --> 00:24:30,879
frames per second

637
00:24:28,080 --> 00:24:32,399
decoding a 4k which is and the and the

638
00:24:30,880 --> 00:24:34,960
high throughput is maybe

639
00:24:32,400 --> 00:24:36,640
three or four times faster than that

640
00:24:34,960 --> 00:24:38,240
when you do the whole encoding the block

641
00:24:36,640 --> 00:24:40,480
coder is much faster but the whole

642
00:24:38,240 --> 00:24:42,880
codec is going to be on significantly

643
00:24:40,480 --> 00:24:42,880
faster

644
00:24:43,279 --> 00:24:47,840
last question

645
00:24:55,120 --> 00:24:58,639
so the question is is encoding and

646
00:24:57,200 --> 00:25:01,279
decoding different

647
00:24:58,640 --> 00:25:02,400
in terms of speed um there's actually

648
00:25:01,279 --> 00:25:04,000
there are actually some tricks you can

649
00:25:02,400 --> 00:25:05,679
do in encoding that you don't you can't

650
00:25:04,000 --> 00:25:06,799
do in decoding meaning because you know

651
00:25:05,679 --> 00:25:09,360
the whole

652
00:25:06,799 --> 00:25:10,720
you actually know all the pixels in in

653
00:25:09,360 --> 00:25:12,000
it

654
00:25:10,720 --> 00:25:13,520
you actually know all the pixels that

655
00:25:12,000 --> 00:25:14,799
you're going to be encoding before

656
00:25:13,520 --> 00:25:16,879
you're encoding them so you can actually

657
00:25:14,799 --> 00:25:19,679
do some tricks to speed things up

658
00:25:16,880 --> 00:25:22,880
but um i think decoding is going to be

659
00:25:19,679 --> 00:25:24,559
faster than the encoding

660
00:25:22,880 --> 00:25:26,799
it's the way it's designed because most

661
00:25:24,559 --> 00:25:29,840
you usually decode many times the only

662
00:25:26,799 --> 00:25:32,240
code one time so it should be

663
00:25:29,840 --> 00:25:34,158
it depends on a lot of other factors how

664
00:25:32,240 --> 00:25:43,840
they implemented it and

665
00:25:34,159 --> 00:25:43,840
and that sort of thing thank you

666
00:25:46,400 --> 00:25:48,480
you

