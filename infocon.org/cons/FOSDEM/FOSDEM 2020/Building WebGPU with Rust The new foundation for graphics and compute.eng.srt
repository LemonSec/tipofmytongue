1
00:00:05,200 --> 00:00:08,800
hello fosdem

2
00:00:06,240 --> 00:00:10,240
i'm dmitry malshev i'm a graphics

3
00:00:08,800 --> 00:00:13,679
engineer at mozilla

4
00:00:10,240 --> 00:00:14,480
and i'm gonna dive into the history of

5
00:00:13,679 --> 00:00:16,960
web gpu

6
00:00:14,480 --> 00:00:18,960
with you fortunately and if you survive

7
00:00:16,960 --> 00:00:22,240
i'm gonna show you how we use rust in it

8
00:00:18,960 --> 00:00:24,640
so there's also quite a bit of

9
00:00:22,240 --> 00:00:26,080
bright colors here beware if you have a

10
00:00:24,640 --> 00:00:29,679
history of

11
00:00:26,080 --> 00:00:31,038
epilepsy or something so this is the

12
00:00:29,679 --> 00:00:33,120
fairly long agenda

13
00:00:31,039 --> 00:00:36,000
um i hope we are going to get at least 2

14
00:00:33,120 --> 00:00:39,680
0.4 here

15
00:00:36,000 --> 00:00:42,879
the most interesting stuff is at 0.5 so

16
00:00:39,680 --> 00:00:42,879
we'll try to keep the pace

17
00:00:43,280 --> 00:00:46,879
this is the screenshot from red dot

18
00:00:45,120 --> 00:00:49,599
redemption and

19
00:00:46,879 --> 00:00:50,559
what i want is for us to be able to

20
00:00:49,600 --> 00:00:52,719
write code

21
00:00:50,559 --> 00:00:53,839
graphics code which would produce a

22
00:00:52,719 --> 00:00:57,280
similar picture

23
00:00:53,840 --> 00:00:59,920
on all platforms including the web

24
00:00:57,280 --> 00:01:00,719
today is not impossible at all if you

25
00:00:59,920 --> 00:01:02,399
use

26
00:01:00,719 --> 00:01:04,400
a commercial engine like the one that

27
00:01:02,399 --> 00:01:06,799
rockstar uses then

28
00:01:04,400 --> 00:01:08,799
you may be able to reach consoles and

29
00:01:06,799 --> 00:01:09,520
some of the desktop platforms not all of

30
00:01:08,799 --> 00:01:12,320
them

31
00:01:09,520 --> 00:01:12,880
and you will not reach the web by that

32
00:01:12,320 --> 00:01:15,439
so

33
00:01:12,880 --> 00:01:16,080
this is a very very unreachable goal

34
00:01:15,439 --> 00:01:18,320
today

35
00:01:16,080 --> 00:01:19,360
and this is what we are trying to fix in

36
00:01:18,320 --> 00:01:22,000
the web gpu

37
00:01:19,360 --> 00:01:22,000
working group

38
00:01:23,119 --> 00:01:30,960
the api that is today that is portable

39
00:01:27,040 --> 00:01:34,000
is opengl um unfortunately

40
00:01:30,960 --> 00:01:36,240
opengl is dying

41
00:01:34,000 --> 00:01:36,240
and

42
00:01:38,240 --> 00:01:45,119
every vendor tries to implement their

43
00:01:41,759 --> 00:01:46,399
falcon drivers in such a way that opengl

44
00:01:45,119 --> 00:01:49,200
is just an afterthought

45
00:01:46,399 --> 00:01:49,600
and nobody optimizes for opengl and it

46
00:01:49,200 --> 00:01:52,840
has

47
00:01:49,600 --> 00:01:54,158
very many limitations that i try to

48
00:01:52,840 --> 00:01:56,079
express

49
00:01:54,159 --> 00:01:57,200
the only good thing about opengl is that

50
00:01:56,079 --> 00:02:00,399
you can target the web

51
00:01:57,200 --> 00:02:02,719
with it today with some limited subset

52
00:02:00,399 --> 00:02:02,719
of it

53
00:02:04,159 --> 00:02:08,560
many concepts of opengl survived through

54
00:02:07,119 --> 00:02:10,800
the beginning and they

55
00:02:08,560 --> 00:02:12,080
are very far from either the way

56
00:02:10,800 --> 00:02:13,840
hardware works

57
00:02:12,080 --> 00:02:15,120
or the way we think about graphics

58
00:02:13,840 --> 00:02:17,520
programming so

59
00:02:15,120 --> 00:02:18,879
it's not a protocol for us graphics

60
00:02:17,520 --> 00:02:20,840
engineer to

61
00:02:18,879 --> 00:02:23,840
nearest to talk to the modern hardware

62
00:02:20,840 --> 00:02:23,840
today

63
00:02:23,920 --> 00:02:28,399
microsoft is not officially supporting

64
00:02:27,680 --> 00:02:30,560
opengl

65
00:02:28,400 --> 00:02:33,200
and it's forbidden in the universal

66
00:02:30,560 --> 00:02:36,720
windows platform

67
00:02:33,200 --> 00:02:39,920
webgl actually works via d3d11

68
00:02:36,720 --> 00:02:41,359
on the most popular platform and apple

69
00:02:39,920 --> 00:02:45,839
officially deprecated it

70
00:02:41,360 --> 00:02:45,840
so you can make conclusions from here

71
00:02:46,239 --> 00:02:54,239
this is a more technical slide

72
00:02:49,680 --> 00:02:56,480
we can't use multiple cores

73
00:02:54,239 --> 00:02:57,519
we can't predict where the driver is

74
00:02:56,480 --> 00:02:59,599
gonna

75
00:02:57,519 --> 00:03:00,720
try to freeze us for hundreds of

76
00:02:59,599 --> 00:03:04,238
milliseconds

77
00:03:00,720 --> 00:03:07,359
optimizing for mobile is a challenge

78
00:03:04,239 --> 00:03:10,000
data transfers is a an art

79
00:03:07,360 --> 00:03:12,400
and webgl 2 is not even portably

80
00:03:10,000 --> 00:03:12,400
supported

81
00:03:15,040 --> 00:03:19,760
opgl evolved in such a way that allows

82
00:03:16,879 --> 00:03:23,120
you to skip it and do more on the gpu

83
00:03:19,760 --> 00:03:24,879
and that path that does not allow rich

84
00:03:23,120 --> 00:03:26,560
walls like the one that i showed you in

85
00:03:24,879 --> 00:03:28,560
the beginning where

86
00:03:26,560 --> 00:03:29,680
there is like thousands of small objects

87
00:03:28,560 --> 00:03:33,840
with different materials

88
00:03:29,680 --> 00:03:33,840
this is just not acceptable

89
00:03:35,440 --> 00:03:39,359
so the first question has anyone heard

90
00:03:38,239 --> 00:03:42,959
the fact that

91
00:03:39,360 --> 00:03:46,959
apple started web gpu yes

92
00:03:42,959 --> 00:03:50,400
two people great this is not correct

93
00:03:46,959 --> 00:03:51,200
um it couldn't be farther from truth the

94
00:03:50,400 --> 00:03:53,519
only thing that

95
00:03:51,200 --> 00:03:57,040
apple started with web gpu is the name

96
00:03:53,519 --> 00:03:57,040
which the group took from apple

97
00:03:57,840 --> 00:04:02,400
so this is how it started um 2016

98
00:04:01,040 --> 00:04:04,879
vancouver

99
00:04:02,400 --> 00:04:05,439
we gathered around the browser vendors

100
00:04:04,879 --> 00:04:07,679
intel

101
00:04:05,439 --> 00:04:08,720
a few more folks and we didn't know what

102
00:04:07,680 --> 00:04:10,799
we were doing

103
00:04:08,720 --> 00:04:12,159
we were trying to figure out is there a

104
00:04:10,799 --> 00:04:14,560
way to design

105
00:04:12,159 --> 00:04:16,399
an api that wouldn't be as complex as

106
00:04:14,560 --> 00:04:18,639
vulcan while still be portable

107
00:04:16,399 --> 00:04:21,198
and maybe target the web because you

108
00:04:18,639 --> 00:04:23,520
know webgl is technically acronis

109
00:04:21,199 --> 00:04:25,360
project and opengl and vulkan are both

110
00:04:23,520 --> 00:04:26,960
kernels projects so this was in the

111
00:04:25,360 --> 00:04:30,240
kronos meeting

112
00:04:26,960 --> 00:04:31,840
and browser vendors came with their own

113
00:04:30,240 --> 00:04:33,280
proposals on what this is going to look

114
00:04:31,840 --> 00:04:36,320
like

115
00:04:33,280 --> 00:04:39,599
we mozilla brought something called

116
00:04:36,320 --> 00:04:42,960
webmetal it worked

117
00:04:39,600 --> 00:04:45,919
on top of falcon apple brought something

118
00:04:42,960 --> 00:04:46,400
that's worked very similarly like metal

119
00:04:45,919 --> 00:04:48,960
and they

120
00:04:46,400 --> 00:04:50,320
quickly implemented it in safari preview

121
00:04:48,960 --> 00:04:51,919
now all of that code that they

122
00:04:50,320 --> 00:04:54,400
prototyped is gone

123
00:04:51,919 --> 00:04:56,159
um our code was implemented on top of

124
00:04:54,400 --> 00:04:58,880
servo and it's also gone

125
00:04:56,160 --> 00:05:00,960
and google brought something original

126
00:04:58,880 --> 00:05:03,039
that they called nxt

127
00:05:00,960 --> 00:05:04,479
and there were some heated discussions

128
00:05:03,039 --> 00:05:07,599
on where do we go from

129
00:05:04,479 --> 00:05:09,440
from there the main conclusion was we

130
00:05:07,600 --> 00:05:12,479
couldn't work with chronos

131
00:05:09,440 --> 00:05:16,560
because reasons those

132
00:05:12,479 --> 00:05:16,560
are something that we cannot explain

133
00:05:18,880 --> 00:05:24,240
so apple created a w3c group

134
00:05:22,479 --> 00:05:25,520
and invited pretty much the same people

135
00:05:24,240 --> 00:05:28,800
as have been working

136
00:05:25,520 --> 00:05:32,479
on that so we moved to the group

137
00:05:28,800 --> 00:05:35,360
and started debating basic principles of

138
00:05:32,479 --> 00:05:38,080
how apis should be designed

139
00:05:35,360 --> 00:05:39,520
in 2017 we agreed on the binding model

140
00:05:38,080 --> 00:05:42,159
which is critical

141
00:05:39,520 --> 00:05:43,758
for us because we didn't want to agree

142
00:05:42,160 --> 00:05:45,360
on the shading language and having the

143
00:05:43,759 --> 00:05:46,080
binding model allows us to decide that

144
00:05:45,360 --> 00:05:49,440
later

145
00:05:46,080 --> 00:05:52,719
or never i don't know

146
00:05:49,440 --> 00:05:55,199
maybe even next week we'll see so in

147
00:05:52,720 --> 00:05:56,720
2018 we agreed on implicit barriers

148
00:05:55,199 --> 00:05:58,000
which is important for setting the

149
00:05:56,720 --> 00:06:00,800
direction of

150
00:05:58,000 --> 00:06:01,600
how the api uh how simple this is going

151
00:06:00,800 --> 00:06:04,560
to be

152
00:06:01,600 --> 00:06:06,160
to be used because vulcan and d312

153
00:06:04,560 --> 00:06:08,000
require you to explicitly

154
00:06:06,160 --> 00:06:09,600
transition your resources between states

155
00:06:08,000 --> 00:06:12,319
and synchronization

156
00:06:09,600 --> 00:06:14,400
synchronize between pipeline stages in

157
00:06:12,319 --> 00:06:17,280
2018 we started

158
00:06:14,400 --> 00:06:20,080
rust project called wgpu which

159
00:06:17,280 --> 00:06:23,520
implements a gpu for native platforms

160
00:06:20,080 --> 00:06:26,080
and in 19 a year from there we started

161
00:06:23,520 --> 00:06:28,240
integrating it into gecko and use it as

162
00:06:26,080 --> 00:06:30,240
a basis for web gpu implementation in

163
00:06:28,240 --> 00:06:32,639
gecko

164
00:06:30,240 --> 00:06:33,360
and gecko is the engine for firefox in

165
00:06:32,639 --> 00:06:36,160
case

166
00:06:33,360 --> 00:06:36,160
i haven't seen that

167
00:06:39,039 --> 00:06:42,080
the basic principle is we try to

168
00:06:40,479 --> 00:06:44,318
intersect the apis and see

169
00:06:42,080 --> 00:06:45,840
which parts are portable which parts can

170
00:06:44,319 --> 00:06:49,199
be executed on all of them

171
00:06:45,840 --> 00:06:51,599
in the end we converged to basically

172
00:06:49,199 --> 00:06:52,800
metal with vulcan binding model but

173
00:06:51,599 --> 00:06:54,560
again this was not

174
00:06:52,800 --> 00:06:56,800
coming from a single api this was coming

175
00:06:54,560 --> 00:06:59,360
from outside and trying to find the

176
00:06:56,800 --> 00:06:59,360
sweet spot

177
00:07:00,240 --> 00:07:04,319
you know the comic about the 15th

178
00:07:02,000 --> 00:07:06,080
standard that was the main feedback we

179
00:07:04,319 --> 00:07:09,360
got from developers please

180
00:07:06,080 --> 00:07:12,880
don't do any more npis we're

181
00:07:09,360 --> 00:07:16,319
there's too many um sorry we did

182
00:07:12,880 --> 00:07:18,639
and it is going to happen and

183
00:07:16,319 --> 00:07:20,960
we believe in it and we believe that

184
00:07:18,639 --> 00:07:23,280
that new api is actually needed because

185
00:07:20,960 --> 00:07:24,960
it's going to be the new era opengl sort

186
00:07:23,280 --> 00:07:27,119
of thing it's going to be something that

187
00:07:24,960 --> 00:07:28,318
you would be able to target all of the

188
00:07:27,120 --> 00:07:30,639
platforms

189
00:07:28,319 --> 00:07:31,840
with not much effort which you can

190
00:07:30,639 --> 00:07:35,759
explain to your kids

191
00:07:31,840 --> 00:07:38,719
and they can understand your code um so

192
00:07:35,759 --> 00:07:40,800
today as i said only opengl is close to

193
00:07:38,720 --> 00:07:44,319
that but it's dying so

194
00:07:40,800 --> 00:07:46,720
that's what webgp is trying to be

195
00:07:44,319 --> 00:07:47,520
the principles we followed for designing

196
00:07:46,720 --> 00:07:48,960
it

197
00:07:47,520 --> 00:07:50,719
obviously performance everybody says

198
00:07:48,960 --> 00:07:51,840
performance nobody knows how to judge it

199
00:07:50,720 --> 00:07:54,879
between the others

200
00:07:51,840 --> 00:07:55,758
so security means that we validate all

201
00:07:54,879 --> 00:07:58,000
the inputs

202
00:07:55,759 --> 00:07:59,360
we don't allow anything to come to the

203
00:07:58,000 --> 00:07:59,919
driver that the driver doesn't know what

204
00:07:59,360 --> 00:08:02,800
to do with

205
00:07:59,919 --> 00:08:04,479
so in case of vulcan validation we

206
00:08:02,800 --> 00:08:06,960
require the workloads

207
00:08:04,479 --> 00:08:09,758
to reach the driver with zero validation

208
00:08:06,960 --> 00:08:11,280
warnings or errors

209
00:08:09,759 --> 00:08:13,280
it also means that we need to sanitize

210
00:08:11,280 --> 00:08:15,599
the shader out of bound access and

211
00:08:13,280 --> 00:08:16,400
lots of things which may potentially

212
00:08:15,599 --> 00:08:18,719
make your

213
00:08:16,400 --> 00:08:20,560
programs slower but we're trying our

214
00:08:18,720 --> 00:08:21,840
best to reduce this overhead to the

215
00:08:20,560 --> 00:08:23,520
minimum

216
00:08:21,840 --> 00:08:26,638
and portability is the most tricky part

217
00:08:23,520 --> 00:08:28,318
at least it took me a while maybe a few

218
00:08:26,639 --> 00:08:31,919
years to understand what this means

219
00:08:28,319 --> 00:08:33,360
so this means that programs are not only

220
00:08:31,919 --> 00:08:35,760
compiled on all platforms

221
00:08:33,360 --> 00:08:36,719
they behave similarly like if you have a

222
00:08:35,760 --> 00:08:38,640
use case

223
00:08:36,719 --> 00:08:40,560
and you api tells you that there is an

224
00:08:38,640 --> 00:08:44,000
optimization for your use case

225
00:08:40,559 --> 00:08:45,199
then you you can expect that it's not

226
00:08:44,000 --> 00:08:46,480
going to be slower on

227
00:08:45,200 --> 00:08:48,800
some platform because of that

228
00:08:46,480 --> 00:08:50,800
optimization so this is not the case for

229
00:08:48,800 --> 00:08:52,800
any other apis any other ips device

230
00:08:50,800 --> 00:08:54,399
require you to discover the features

231
00:08:52,800 --> 00:08:56,240
on the platform you are running on and

232
00:08:54,399 --> 00:08:58,720
use those features so

233
00:08:56,240 --> 00:09:00,399
we expose features in such a way that if

234
00:08:58,720 --> 00:09:02,399
it matches your use case

235
00:09:00,399 --> 00:09:03,920
and you use it you can we can guarantee

236
00:09:02,399 --> 00:09:06,399
that it's going to be not slower or

237
00:09:03,920 --> 00:09:08,479
likely faster

238
00:09:06,399 --> 00:09:10,480
and obviously we want it to be usable as

239
00:09:08,480 --> 00:09:11,279
i said we want it to be a teachable api

240
00:09:10,480 --> 00:09:14,880
we want

241
00:09:11,279 --> 00:09:14,880
people to understand what they write

242
00:09:15,680 --> 00:09:18,959
these are early native benchmarks of the

243
00:09:17,920 --> 00:09:21,680
aquarium demo

244
00:09:18,959 --> 00:09:23,359
um many people may have seen it in webgl

245
00:09:21,680 --> 00:09:26,880
world

246
00:09:23,360 --> 00:09:29,680
done by intel um not very convincing

247
00:09:26,880 --> 00:09:31,360
but it's basically 10 to 30 percent it's

248
00:09:29,680 --> 00:09:33,120
very early

249
00:09:31,360 --> 00:09:34,640
benchmarking is one of the areas where

250
00:09:33,120 --> 00:09:36,880
we are still lacking and we're going to

251
00:09:34,640 --> 00:09:40,160
catch up to that

252
00:09:36,880 --> 00:09:42,160
so the other numbers apple gave us

253
00:09:40,160 --> 00:09:43,279
are more convincing but i don't know if

254
00:09:42,160 --> 00:09:46,240
we can seriously

255
00:09:43,279 --> 00:09:47,600
take them um you can see like sometimes

256
00:09:46,240 --> 00:09:50,160
performance on

257
00:09:47,600 --> 00:09:51,600
number of triangles and i'm not sure why

258
00:09:50,160 --> 00:09:53,279
number of triangles would be

259
00:09:51,600 --> 00:09:55,120
different because it's anyway reaching

260
00:09:53,279 --> 00:09:56,959
the gpu and gpu is going to do this

261
00:09:55,120 --> 00:09:59,200
the work but that's the numbers they

262
00:09:56,959 --> 00:09:59,199
have

263
00:10:00,000 --> 00:10:03,519
now we're going to go through a example

264
00:10:03,200 --> 00:10:06,440
of

265
00:10:03,519 --> 00:10:08,079
a rust program in written against

266
00:10:06,440 --> 00:10:10,480
wgpu.rs

267
00:10:08,079 --> 00:10:11,279
explaining what this means and how it

268
00:10:10,480 --> 00:10:15,200
works

269
00:10:11,279 --> 00:10:17,279
so this is initialization which means we

270
00:10:15,200 --> 00:10:18,959
create an adapter and we create a device

271
00:10:17,279 --> 00:10:21,120
an adapter represents

272
00:10:18,959 --> 00:10:22,079
sort of a physical instance of your

273
00:10:21,120 --> 00:10:24,399
hardware

274
00:10:22,079 --> 00:10:26,079
you can say and the device is a logical

275
00:10:24,399 --> 00:10:27,120
instance that you work with that owns

276
00:10:26,079 --> 00:10:29,199
all the resources

277
00:10:27,120 --> 00:10:30,720
so we can say we want no power

278
00:10:29,200 --> 00:10:32,560
preference and we want

279
00:10:30,720 --> 00:10:34,320
any kind of back end which the back end

280
00:10:32,560 --> 00:10:37,599
can be d3d12

281
00:10:34,320 --> 00:10:37,600
vulcan or not all

282
00:10:37,760 --> 00:10:40,800
and we request the device with some

283
00:10:39,120 --> 00:10:43,760
features and we get the device

284
00:10:40,800 --> 00:10:45,439
these operations are in the api they are

285
00:10:43,760 --> 00:10:47,200
asynchronous

286
00:10:45,440 --> 00:10:50,800
in the in our wrapper so far there are

287
00:10:47,200 --> 00:10:50,800
synchronous we're gonna change that

288
00:10:51,360 --> 00:10:55,040
now the swap chain initialization is

289
00:10:53,040 --> 00:10:57,199
completely separate from the device

290
00:10:55,040 --> 00:10:58,399
this is for any of you who only know

291
00:10:57,200 --> 00:11:00,720
opengl can be

292
00:10:58,399 --> 00:11:03,040
weird because you don't have to have a

293
00:11:00,720 --> 00:11:04,880
swap chain you can do compute only work

294
00:11:03,040 --> 00:11:06,959
loads without even caring about

295
00:11:04,880 --> 00:11:08,800
presenting anything

296
00:11:06,959 --> 00:11:10,479
so this is optional if you need to

297
00:11:08,800 --> 00:11:12,160
present something you create your swap

298
00:11:10,480 --> 00:11:15,839
chain based on the surface

299
00:11:12,160 --> 00:11:15,839
that you get from the window

300
00:11:17,360 --> 00:11:20,640
we create the data and the important bit

301
00:11:19,680 --> 00:11:22,959
here

302
00:11:20,640 --> 00:11:24,399
um for buffer creation we specify what

303
00:11:22,959 --> 00:11:27,199
this buffer is going to use

304
00:11:24,399 --> 00:11:28,560
to in which case the vertex means it's

305
00:11:27,200 --> 00:11:29,360
going to be used as a vertex saturated

306
00:11:28,560 --> 00:11:31,040
buffer

307
00:11:29,360 --> 00:11:32,480
and this is a descriptor of the vertex

308
00:11:31,040 --> 00:11:35,279
data that we're going to

309
00:11:32,480 --> 00:11:37,360
use later on um note that the descriptor

310
00:11:35,279 --> 00:11:39,279
is separated from the actual data

311
00:11:37,360 --> 00:11:41,519
in opengl where you provide those

312
00:11:39,279 --> 00:11:42,079
layouts you provide a pointer to the

313
00:11:41,519 --> 00:11:43,200
data

314
00:11:42,079 --> 00:11:45,680
which doesn't make sense for the

315
00:11:43,200 --> 00:11:45,680
hardware

316
00:11:47,519 --> 00:11:53,040
um explicit apis is a

317
00:11:51,360 --> 00:11:54,720
long topic but i guess by this point you

318
00:11:53,040 --> 00:11:57,839
realize that the answer is now like all

319
00:11:54,720 --> 00:11:57,839
the headlines

320
00:11:57,920 --> 00:12:01,360
this is an example in vulcan in order to

321
00:12:00,079 --> 00:12:03,120
create an image

322
00:12:01,360 --> 00:12:04,959
you have to go through four steps or

323
00:12:03,120 --> 00:12:06,959
five

324
00:12:04,959 --> 00:12:08,880
you figure out what the requirements are

325
00:12:06,959 --> 00:12:10,638
you create logical image you find your

326
00:12:08,880 --> 00:12:11,839
memory pools allocate memory and then

327
00:12:10,639 --> 00:12:14,079
bind them to image so

328
00:12:11,839 --> 00:12:15,440
there's a lot of going on and this is

329
00:12:14,079 --> 00:12:17,279
not something simple people make

330
00:12:15,440 --> 00:12:19,600
mistakes all the time in that

331
00:12:17,279 --> 00:12:20,720
and in web gpu is just one command of

332
00:12:19,600 --> 00:12:23,519
course

333
00:12:20,720 --> 00:12:24,800
by hiding this we introduced some level

334
00:12:23,519 --> 00:12:26,560
of uncertainty

335
00:12:24,800 --> 00:12:28,560
maybe you will not have enough memory

336
00:12:26,560 --> 00:12:30,638
and we will have to allocate more

337
00:12:28,560 --> 00:12:33,439
this is the the balance that we've

338
00:12:30,639 --> 00:12:33,440
reached so far

339
00:12:35,360 --> 00:12:40,160
and this is a highly subjective scale

340
00:12:38,399 --> 00:12:43,120
that will allow you to reason about what

341
00:12:40,160 --> 00:12:45,600
web gpu is and why we are doing this

342
00:12:43,120 --> 00:12:48,880
the most performant versus the ease of

343
00:12:45,600 --> 00:12:50,320
use api is vulcan

344
00:12:48,880 --> 00:12:52,560
it's close to the hardware it's not

345
00:12:50,320 --> 00:12:56,399
exactly hardware um

346
00:12:52,560 --> 00:12:59,199
and opengl is sort of

347
00:12:56,399 --> 00:12:59,920
neither it's it's easy but it's not

348
00:12:59,200 --> 00:13:02,959
performant

349
00:12:59,920 --> 00:13:04,240
battle is pretty good it's both and i

350
00:13:02,959 --> 00:13:07,439
can talk more about metal

351
00:13:04,240 --> 00:13:08,480
after the talk and web gpu is sort of

352
00:13:07,440 --> 00:13:11,839
trying to get the best

353
00:13:08,480 --> 00:13:11,839
of the world here

354
00:13:12,320 --> 00:13:16,639
so we're separating data from the layout

355
00:13:15,200 --> 00:13:18,800
of the data and this is the

356
00:13:16,639 --> 00:13:21,120
bind groups mind groups is a sort of

357
00:13:18,800 --> 00:13:24,479
descriptor set in vulcan or

358
00:13:21,120 --> 00:13:27,040
a range of descriptors in d3d12

359
00:13:24,480 --> 00:13:28,880
which has a number of resources that you

360
00:13:27,040 --> 00:13:31,839
bind at once that's why

361
00:13:28,880 --> 00:13:31,839
it bound as a group

362
00:13:33,200 --> 00:13:36,480
and we create the bind group by

363
00:13:34,639 --> 00:13:37,680
providing the exact buffer that we just

364
00:13:36,480 --> 00:13:39,440
created

365
00:13:37,680 --> 00:13:42,319
and this is the explanation of why we

366
00:13:39,440 --> 00:13:42,320
need the bind groups

367
00:13:42,480 --> 00:13:46,320
the shaders uh communicate with bind

368
00:13:44,880 --> 00:13:48,079
groups at the bottom

369
00:13:46,320 --> 00:13:49,440
they get input from the vertex buffers

370
00:13:48,079 --> 00:13:51,519
to the left and

371
00:13:49,440 --> 00:13:55,120
they render to render targets at the top

372
00:13:51,519 --> 00:13:58,800
now we're going to talk about pipelines

373
00:13:55,120 --> 00:14:03,199
um why do we need pipelines if you ask

374
00:13:58,800 --> 00:14:06,240
if you used opengl only historically

375
00:14:03,199 --> 00:14:09,040
the graphics hardware was

376
00:14:06,240 --> 00:14:09,519
just having fixed function pipeline it

377
00:14:09,040 --> 00:14:12,079
no

378
00:14:09,519 --> 00:14:12,880
it knew how to shade simply some

379
00:14:12,079 --> 00:14:15,760
triangles

380
00:14:12,880 --> 00:14:16,720
and then some of the stages became more

381
00:14:15,760 --> 00:14:18,319
programmable

382
00:14:16,720 --> 00:14:20,639
then they became even more programmable

383
00:14:18,320 --> 00:14:21,440
and then they became united into compute

384
00:14:20,639 --> 00:14:23,360
stages

385
00:14:21,440 --> 00:14:25,279
and then more and more fixed function

386
00:14:23,360 --> 00:14:26,880
stages that were left

387
00:14:25,279 --> 00:14:28,880
internally the drivers started to

388
00:14:26,880 --> 00:14:31,360
convert to code and linked to the whole

389
00:14:28,880 --> 00:14:31,920
shader stages that they have so when you

390
00:14:31,360 --> 00:14:34,240
switch

391
00:14:31,920 --> 00:14:36,479
your blend mode in opengl this is not a

392
00:14:34,240 --> 00:14:38,800
simple switch the driver will need to

393
00:14:36,480 --> 00:14:40,320
internally rebuild your complete program

394
00:14:38,800 --> 00:14:42,959
reallocate registers

395
00:14:40,320 --> 00:14:44,880
and do crazy amount of work just to let

396
00:14:42,959 --> 00:14:47,920
your next throw call to pass

397
00:14:44,880 --> 00:14:51,600
so the pipeline is a concept that

398
00:14:47,920 --> 00:14:54,240
gets the shooter with all the dependent

399
00:14:51,600 --> 00:14:55,360
structures that it needs to work with

400
00:14:54,240 --> 00:14:58,000
and

401
00:14:55,360 --> 00:14:59,440
forces you to declare them in advance so

402
00:14:58,000 --> 00:15:00,399
when you create the pipeline you expect

403
00:14:59,440 --> 00:15:02,320
it to be slow

404
00:15:00,399 --> 00:15:04,720
and you have to specify what your vertex

405
00:15:02,320 --> 00:15:06,639
buffer layout is but not the data

406
00:15:04,720 --> 00:15:08,320
what your render target format is but

407
00:15:06,639 --> 00:15:10,480
not the data and again what your bind

408
00:15:08,320 --> 00:15:12,399
group layouts is

409
00:15:10,480 --> 00:15:13,839
finally the vertex buffer thing is

410
00:15:12,399 --> 00:15:16,800
something that we consider

411
00:15:13,839 --> 00:15:17,600
to not have try to imagine yourself

412
00:15:16,800 --> 00:15:19,920
programming

413
00:15:17,600 --> 00:15:21,519
a model without versus buffers maybe you

414
00:15:19,920 --> 00:15:23,680
will have to i don't know

415
00:15:21,519 --> 00:15:26,240
the problem is that it's very difficult

416
00:15:23,680 --> 00:15:29,599
to make them secure

417
00:15:26,240 --> 00:15:32,000
out of bound access is not covered by

418
00:15:29,600 --> 00:15:33,040
auto bound extensions for vertice

419
00:15:32,000 --> 00:15:35,040
buffers and

420
00:15:33,040 --> 00:15:38,800
it's complex so we're still trying to

421
00:15:35,040 --> 00:15:38,800
figure this out we will try to keep them

422
00:15:39,199 --> 00:15:42,560
this is how we create pipeline as i said

423
00:15:41,040 --> 00:15:44,240
we have to specify

424
00:15:42,560 --> 00:15:45,758
all of the state that your sheeter

425
00:15:44,240 --> 00:15:48,480
depends on which

426
00:15:45,759 --> 00:15:49,839
is the your render target information

427
00:15:48,480 --> 00:15:52,880
vertex buffer information

428
00:15:49,839 --> 00:15:54,000
your shaders and pipeline layout which

429
00:15:52,880 --> 00:15:56,160
includes all the resources

430
00:15:54,000 --> 00:15:57,360
that your sheeter sees based on the

431
00:15:56,160 --> 00:15:59,360
stages so you declare

432
00:15:57,360 --> 00:16:01,360
all of that at once again this is rust

433
00:15:59,360 --> 00:16:05,920
code it uses

434
00:16:01,360 --> 00:16:05,920
enums it uses references

435
00:16:06,079 --> 00:16:10,880
for me it's pretty readable to work with

436
00:16:12,160 --> 00:16:19,600
now we have rendering has render passes

437
00:16:16,320 --> 00:16:22,639
which means that you don't just bind

438
00:16:19,600 --> 00:16:25,040
a target and draw render passes are

439
00:16:22,639 --> 00:16:25,040
needed

440
00:16:26,160 --> 00:16:32,319
because mobile devices where there is

441
00:16:29,519 --> 00:16:34,000
fast memory and they don't want to work

442
00:16:32,320 --> 00:16:36,079
with the whole screen at once

443
00:16:34,000 --> 00:16:37,120
loading pixels into this fast and cheap

444
00:16:36,079 --> 00:16:39,519
memory is

445
00:16:37,120 --> 00:16:40,240
heavy it's slow processing them is

446
00:16:39,519 --> 00:16:43,680
cheaper

447
00:16:40,240 --> 00:16:45,279
and so typically uh it would go

448
00:16:43,680 --> 00:16:47,040
tile by tile and it would load all the

449
00:16:45,279 --> 00:16:48,800
pixels that you have on the target

450
00:16:47,040 --> 00:16:51,040
it would run your shaders on it and then

451
00:16:48,800 --> 00:16:52,880
it would store them back into the tile

452
00:16:51,040 --> 00:16:54,480
loading and storing is memory intensive

453
00:16:52,880 --> 00:16:57,759
operation that is

454
00:16:54,480 --> 00:16:59,680
very slow and therefore

455
00:16:57,759 --> 00:17:01,120
you can control it you can say don't

456
00:16:59,680 --> 00:17:01,920
load anything for me don't store

457
00:17:01,120 --> 00:17:03,920
anything for me

458
00:17:01,920 --> 00:17:06,159
just clear it to this color which means

459
00:17:03,920 --> 00:17:08,639
you're saving a lot of memory bandwidth

460
00:17:06,160 --> 00:17:11,839
this is the thing that is acknowledged

461
00:17:08,640 --> 00:17:14,000
by all of the native apis today

462
00:17:11,839 --> 00:17:15,039
it was from the beginning in both vulcan

463
00:17:14,000 --> 00:17:17,599
and metal and

464
00:17:15,039 --> 00:17:19,119
lately it will got added to d312 the

465
00:17:17,599 --> 00:17:21,918
latest version also has

466
00:17:19,119 --> 00:17:23,599
render passes and you can see here how

467
00:17:21,919 --> 00:17:24,640
we are creating a render path and we

468
00:17:23,599 --> 00:17:26,399
specify

469
00:17:24,640 --> 00:17:28,480
we are specifying the load operation to

470
00:17:26,400 --> 00:17:32,559
be clear which means we don't want to

471
00:17:28,480 --> 00:17:32,559
to be loaded we just want the clear

472
00:17:32,640 --> 00:17:36,880
we specify the clear color inside the

473
00:17:35,039 --> 00:17:38,240
render paths we do all the rendering and

474
00:17:36,880 --> 00:17:38,960
we set all the state which is the

475
00:17:38,240 --> 00:17:41,360
pipeline

476
00:17:38,960 --> 00:17:43,120
the bind group index vertex buffers and

477
00:17:41,360 --> 00:17:46,080
issuing the draw call

478
00:17:43,120 --> 00:17:48,239
the beauty of this setup is that by the

479
00:17:46,080 --> 00:17:50,159
time we call draw indexed

480
00:17:48,240 --> 00:17:52,320
all the state that it depends on is

481
00:17:50,160 --> 00:17:52,960
already set through index is blazingly

482
00:17:52,320 --> 00:17:54,720
fast

483
00:17:52,960 --> 00:17:56,160
it's there is nothing that's going on in

484
00:17:54,720 --> 00:17:58,160
the draw index

485
00:17:56,160 --> 00:18:01,520
other than maybe some vertex buffer

486
00:17:58,160 --> 00:18:04,000
validation that i mentioned

487
00:18:01,520 --> 00:18:04,720
and you can you are supposed to be able

488
00:18:04,000 --> 00:18:07,840
to

489
00:18:04,720 --> 00:18:09,039
issue thousands tens of thousands of

490
00:18:07,840 --> 00:18:12,480
draw calls

491
00:18:09,039 --> 00:18:14,240
in big fat render passes

492
00:18:12,480 --> 00:18:15,840
this is the goal that would allow us to

493
00:18:14,240 --> 00:18:18,960
let to produce those

494
00:18:15,840 --> 00:18:18,959
you know shiny pictures

495
00:18:20,240 --> 00:18:26,240
see that um multi-threading is something

496
00:18:24,400 --> 00:18:28,320
that all of the new apis support

497
00:18:26,240 --> 00:18:30,559
in this example there is three threads

498
00:18:28,320 --> 00:18:32,240
involved on the first thread we recorded

499
00:18:30,559 --> 00:18:33,280
this big render pass that we just talked

500
00:18:32,240 --> 00:18:35,679
about

501
00:18:33,280 --> 00:18:37,120
on the second thread we compute some we

502
00:18:35,679 --> 00:18:39,760
record some compute work

503
00:18:37,120 --> 00:18:41,039
and um at this stage where we compute it

504
00:18:39,760 --> 00:18:43,200
we don't know when exactly it's going to

505
00:18:41,039 --> 00:18:46,240
be executed we just tell it what to do

506
00:18:43,200 --> 00:18:47,520
but then we send it to the thread that

507
00:18:46,240 --> 00:18:49,440
owns the queue

508
00:18:47,520 --> 00:18:52,080
and we say submit first and then second

509
00:18:49,440 --> 00:18:53,760
this is where the order is set up

510
00:18:52,080 --> 00:18:55,439
so all of these can be on separate

511
00:18:53,760 --> 00:18:57,679
threads

512
00:18:55,440 --> 00:18:59,600
this this is especially important on

513
00:18:57,679 --> 00:19:02,000
again on mobile devices where we have

514
00:18:59,600 --> 00:19:04,799
lots of threads but maybe not so

515
00:19:02,000 --> 00:19:04,799
powerful threads

516
00:19:06,240 --> 00:19:10,559
this is how it's done in code you create

517
00:19:08,480 --> 00:19:13,679
an encoder the encoder can then

518
00:19:10,559 --> 00:19:14,960
have some compute or render passes you

519
00:19:13,679 --> 00:19:15,600
finish encoder you get the command

520
00:19:14,960 --> 00:19:17,840
buffer which

521
00:19:15,600 --> 00:19:19,360
you can send to the queue or just

522
00:19:17,840 --> 00:19:20,879
provide the queue directly and

523
00:19:19,360 --> 00:19:25,840
submission is

524
00:19:20,880 --> 00:19:25,840
getting a array of them

525
00:19:25,919 --> 00:19:29,039
implicit barriers is something i

526
00:19:27,360 --> 00:19:30,639
mentioned as well so

527
00:19:29,039 --> 00:19:32,320
here you can see that we have four

528
00:19:30,640 --> 00:19:35,840
different pieces in the command stream

529
00:19:32,320 --> 00:19:37,840
and the usage of texture and the buffer

530
00:19:35,840 --> 00:19:39,760
changes between the operations

531
00:19:37,840 --> 00:19:41,439
some of the usages can be combined these

532
00:19:39,760 --> 00:19:44,320
are really only usages

533
00:19:41,440 --> 00:19:46,000
like in this 3d 12 mutable usages cannot

534
00:19:44,320 --> 00:19:47,918
be combined if you try to combine them

535
00:19:46,000 --> 00:19:49,600
within the render pass

536
00:19:47,919 --> 00:19:52,080
which is the synchronization scope for

537
00:19:49,600 --> 00:19:54,959
us we will trigger an error and you will

538
00:19:52,080 --> 00:19:54,960
not have what you need

539
00:19:55,760 --> 00:20:00,000
um wsl is that our shipping language i

540
00:19:58,720 --> 00:20:00,799
mentioned that we haven't figured out

541
00:20:00,000 --> 00:20:03,440
yet

542
00:20:00,799 --> 00:20:04,158
no it's not it's just a proposal from

543
00:20:03,440 --> 00:20:06,799
apple

544
00:20:04,159 --> 00:20:09,679
uh mostly we're discussing whether we

545
00:20:06,799 --> 00:20:09,679
can accept it or not

546
00:20:10,880 --> 00:20:14,240
we don't have scheduling language as i

547
00:20:12,720 --> 00:20:16,320
mentioned we don't support multiple

548
00:20:14,240 --> 00:20:18,240
queues which would be important for

549
00:20:16,320 --> 00:20:19,918
a sync compute which you kind of can do

550
00:20:18,240 --> 00:20:22,640
already but multiple queues make

551
00:20:19,919 --> 00:20:24,799
it nicer and our data transfers between

552
00:20:22,640 --> 00:20:26,799
cpu and gpu are

553
00:20:24,799 --> 00:20:28,480
not optimal yet it's hard to figure

554
00:20:26,799 --> 00:20:31,520
those out in terms of the

555
00:20:28,480 --> 00:20:32,400
security not allowing cpu and gpu to

556
00:20:31,520 --> 00:20:34,400
race

557
00:20:32,400 --> 00:20:36,640
to change and inspect the data because

558
00:20:34,400 --> 00:20:40,400
this racing introduces non-portable

559
00:20:36,640 --> 00:20:40,400
behavior potentially unsecured behavior

560
00:20:41,679 --> 00:20:47,120
this is the main question you think it's

561
00:20:45,440 --> 00:20:49,760
only for the web who thinks it's only

562
00:20:47,120 --> 00:20:51,840
for the web nobody

563
00:20:49,760 --> 00:20:53,280
great because that's the main point of

564
00:20:51,840 --> 00:20:56,158
confusion i've seen

565
00:20:53,280 --> 00:20:57,918
every person that has heard of web gpu

566
00:20:56,159 --> 00:20:59,120
says oh it's another web thing i'm not

567
00:20:57,919 --> 00:21:02,240
going to touch it

568
00:20:59,120 --> 00:21:04,959
okay so the working group is

569
00:21:02,240 --> 00:21:06,400
designing it for the web but what we

570
00:21:04,960 --> 00:21:08,640
realized as in

571
00:21:06,400 --> 00:21:10,240
mozilla and google at least is that it's

572
00:21:08,640 --> 00:21:12,159
a very good

573
00:21:10,240 --> 00:21:14,640
api for native platforms as well as i

574
00:21:12,159 --> 00:21:17,679
mentioned the new kind of opengl thing

575
00:21:14,640 --> 00:21:18,480
so we are working on shared headers the

576
00:21:17,679 --> 00:21:20,559
c headers

577
00:21:18,480 --> 00:21:22,559
that you will be able to link to so that

578
00:21:20,559 --> 00:21:24,240
you can use interchangeably either

579
00:21:22,559 --> 00:21:26,158
our implementation or google's

580
00:21:24,240 --> 00:21:29,440
implementation on native platforms

581
00:21:26,159 --> 00:21:31,919
in fact people have already shipped

582
00:21:29,440 --> 00:21:32,960
applications on app store using our

583
00:21:31,919 --> 00:21:36,880
implementation

584
00:21:32,960 --> 00:21:36,880
on native only without any web stuff so

585
00:21:37,840 --> 00:21:42,000
oh this is supposed to be demo time oh

586
00:21:42,320 --> 00:21:46,320
that's gonna be fun okay

587
00:21:46,960 --> 00:21:50,159
okay we're here

588
00:21:51,840 --> 00:21:56,840
so this is generating mid-maps where i

589
00:21:54,559 --> 00:21:59,840
will explain why it's complex

590
00:21:56,840 --> 00:21:59,840
later

591
00:22:00,480 --> 00:22:05,919
this is some two shadows

592
00:22:03,600 --> 00:22:07,280
um you can see some validation errors

593
00:22:05,919 --> 00:22:10,559
which were discovered to be

594
00:22:07,280 --> 00:22:13,840
validation error validation layer bugs

595
00:22:10,559 --> 00:22:13,840
which is fun

596
00:22:14,559 --> 00:22:17,280
and this is

597
00:22:18,159 --> 00:22:22,799
i wonder if it's oh it's loaded on my

598
00:22:20,480 --> 00:22:22,799
machine

599
00:22:22,880 --> 00:22:27,840
great how do i show it to you

600
00:22:29,360 --> 00:22:36,719
yep yep

601
00:22:33,360 --> 00:22:40,158
oh great it didn't go well

602
00:22:36,720 --> 00:22:43,440
okay so this is like 10

603
00:22:40,159 --> 00:22:45,520
000 objects with some ray tracing and a

604
00:22:43,440 --> 00:22:47,360
lot of other good stuff and physics

605
00:22:45,520 --> 00:22:48,960
and it's all running on falcon on my

606
00:22:47,360 --> 00:22:52,240
machine it's equally well running on

607
00:22:48,960 --> 00:22:52,240
d312 and metal

608
00:22:52,880 --> 00:22:57,170
all right now

609
00:22:55,919 --> 00:23:03,280
back

610
00:22:57,170 --> 00:23:06,480
[Applause]

611
00:23:03,280 --> 00:23:09,840
thank you now i hit something

612
00:23:06,480 --> 00:23:13,039
that i wasn't supposed to um

613
00:23:09,840 --> 00:23:16,158
if you don't know what gfx is

614
00:23:13,039 --> 00:23:18,400
i encourage you to rewind back time

615
00:23:16,159 --> 00:23:20,640
two years before where on this track me

616
00:23:18,400 --> 00:23:23,039
and marcus from gfx team were

617
00:23:20,640 --> 00:23:25,760
describing what this is on a very

618
00:23:23,039 --> 00:23:25,760
similar slide

619
00:23:26,960 --> 00:23:30,720
so one problem that we had with gfx that

620
00:23:29,600 --> 00:23:32,959
is solved here

621
00:23:30,720 --> 00:23:35,120
is that if your rendering depends on the

622
00:23:32,960 --> 00:23:35,600
backend and we use generics for the back

623
00:23:35,120 --> 00:23:37,600
end

624
00:23:35,600 --> 00:23:39,760
then it becomes contagious and you have

625
00:23:37,600 --> 00:23:41,199
to have all of your game depending on

626
00:23:39,760 --> 00:23:43,200
the backend type which is

627
00:23:41,200 --> 00:23:46,720
very inconvenient and you can switch

628
00:23:43,200 --> 00:23:46,720
back and set runtime if you want to

629
00:23:47,520 --> 00:23:51,840
what we came up with is

630
00:23:52,000 --> 00:23:56,799
a macro so there is a ec function and we

631
00:23:55,039 --> 00:24:00,799
expose the c api

632
00:23:56,799 --> 00:24:02,720
that gets the id

633
00:24:00,799 --> 00:24:05,279
figures out what the back end it needs

634
00:24:02,720 --> 00:24:07,200
and just checks the back end in a match

635
00:24:05,279 --> 00:24:09,279
and calls the appropriate generic

636
00:24:07,200 --> 00:24:11,039
function device create buffer here

637
00:24:09,279 --> 00:24:12,400
so this is what we use internally this

638
00:24:11,039 --> 00:24:14,559
is just the means

639
00:24:12,400 --> 00:24:15,600
for your perspective nothing is generic

640
00:24:14,559 --> 00:24:17,039
you just work with web

641
00:24:15,600 --> 00:24:19,678
you don't even know what backend it is

642
00:24:17,039 --> 00:24:23,120
until you ask so it will choose one that

643
00:24:19,679 --> 00:24:23,120
works best for you automatically

644
00:24:24,240 --> 00:24:28,240
this is what id looks like you can see

645
00:24:26,400 --> 00:24:30,320
the last three bits is the back end

646
00:24:28,240 --> 00:24:32,159
in the middle there is epoch so that we

647
00:24:30,320 --> 00:24:34,240
can reuse indices

648
00:24:32,159 --> 00:24:36,880
in case your resources perish and we

649
00:24:34,240 --> 00:24:39,520
need to recreate them

650
00:24:36,880 --> 00:24:40,320
and those tables of actual data that we

651
00:24:39,520 --> 00:24:43,279
have

652
00:24:40,320 --> 00:24:44,000
they are back in specific so we have a

653
00:24:43,279 --> 00:24:46,159
table

654
00:24:44,000 --> 00:24:49,279
of buffers for vulcan table of buffers

655
00:24:46,159 --> 00:24:49,279
for metal and so forth

656
00:24:50,720 --> 00:24:55,919
usage structure helps us to um

657
00:24:54,000 --> 00:24:57,760
figure out how resources transition from

658
00:24:55,919 --> 00:25:00,320
like one usage to another

659
00:24:57,760 --> 00:25:01,679
in this scheme we came up with is that

660
00:25:00,320 --> 00:25:04,559
each tracker

661
00:25:01,679 --> 00:25:06,559
knows about correspondence to indices to

662
00:25:04,559 --> 00:25:08,158
states and the state is again a map of

663
00:25:06,559 --> 00:25:10,399
sub-resources to usage and why do we

664
00:25:08,159 --> 00:25:12,960
need sub-resources

665
00:25:10,400 --> 00:25:14,000
sub-resource a texture can have many

666
00:25:12,960 --> 00:25:16,880
mipmap levels

667
00:25:14,000 --> 00:25:18,799
each midpimp level can have many layers

668
00:25:16,880 --> 00:25:21,039
each of those can have its own states

669
00:25:18,799 --> 00:25:23,039
if we go deeper depth and stencil in

670
00:25:21,039 --> 00:25:24,080
some variations of apis can also have

671
00:25:23,039 --> 00:25:27,440
different states that's

672
00:25:24,080 --> 00:25:30,320
like a third dimension and this is

673
00:25:27,440 --> 00:25:31,840
um this sounds trivial but it's fairly

674
00:25:30,320 --> 00:25:32,720
complex to implement at least google

675
00:25:31,840 --> 00:25:34,480
hasn't yet

676
00:25:32,720 --> 00:25:36,080
and we have and that's why i mentioned

677
00:25:34,480 --> 00:25:38,400
that mid map generation is

678
00:25:36,080 --> 00:25:40,399
sort of hard because you change the

679
00:25:38,400 --> 00:25:42,000
usage and one micmap does not equal to

680
00:25:40,400 --> 00:25:44,799
the usage of another mipmap when you

681
00:25:42,000 --> 00:25:44,799
generate it so

682
00:25:45,919 --> 00:25:52,159
this is how we define the scopes

683
00:25:48,960 --> 00:25:54,960
the errors i inserted is where we try to

684
00:25:52,159 --> 00:25:56,640
insert a synchronization in the command

685
00:25:54,960 --> 00:25:58,480
stream and

686
00:25:56,640 --> 00:26:00,559
the interesting bit here is that render

687
00:25:58,480 --> 00:26:02,480
pass is a whole scope

688
00:26:00,559 --> 00:26:04,559
copy operation is single scope but

689
00:26:02,480 --> 00:26:06,559
compute pass is not a whole scope

690
00:26:04,559 --> 00:26:08,240
and that that matches behavior by

691
00:26:06,559 --> 00:26:11,520
default in metal

692
00:26:08,240 --> 00:26:13,760
and it's it's really tricky because

693
00:26:11,520 --> 00:26:16,000
we are trying to minimize the the risk

694
00:26:13,760 --> 00:26:19,600
of um

695
00:26:16,000 --> 00:26:20,960
races and what what we do we synchronize

696
00:26:19,600 --> 00:26:21,678
between these patches if there is the

697
00:26:20,960 --> 00:26:23,919
same

698
00:26:21,679 --> 00:26:25,440
resource used as a storage for example

699
00:26:23,919 --> 00:26:26,720
and you can use resources for different

700
00:26:25,440 --> 00:26:30,000
usages within

701
00:26:26,720 --> 00:26:32,080
a pass but you can argue that

702
00:26:30,000 --> 00:26:34,559
within a single dispatch call there may

703
00:26:32,080 --> 00:26:37,600
be multiple races on the gpu

704
00:26:34,559 --> 00:26:40,240
and we don't protect you from that

705
00:26:37,600 --> 00:26:41,199
so there's always this you know scale of

706
00:26:40,240 --> 00:26:43,120
where to throw

707
00:26:41,200 --> 00:26:44,480
draw the line and in this particular

708
00:26:43,120 --> 00:26:46,320
case we decided to draw

709
00:26:44,480 --> 00:26:47,760
throw it between these patches we may

710
00:26:46,320 --> 00:26:50,720
introduce an option

711
00:26:47,760 --> 00:26:52,559
to like have compute pass as a single

712
00:26:50,720 --> 00:26:56,000
scope it's not a big deal for us but

713
00:26:52,559 --> 00:26:56,879
it affects you so that's how it looks

714
00:26:56,000 --> 00:26:59,039
today

715
00:26:56,880 --> 00:27:00,640
and when we patch between those scopes

716
00:26:59,039 --> 00:27:03,679
we know where each scope

717
00:27:00,640 --> 00:27:06,400
expects the usage to be and that's the

718
00:27:03,679 --> 00:27:08,960
expected value and we push between those

719
00:27:06,400 --> 00:27:10,559
between those so the bind group and

720
00:27:08,960 --> 00:27:14,400
render path usages are all

721
00:27:10,559 --> 00:27:16,399
combined they can be mutated inside

722
00:27:14,400 --> 00:27:18,320
and the command buffer and device usages

723
00:27:16,400 --> 00:27:20,960
are transitioned one from another

724
00:27:18,320 --> 00:27:22,158
so this this is a different logic and

725
00:27:20,960 --> 00:27:25,440
what we were

726
00:27:22,159 --> 00:27:27,360
trying very hard to express

727
00:27:25,440 --> 00:27:29,120
is using the rust type system right

728
00:27:27,360 --> 00:27:30,959
between this is different logic why

729
00:27:29,120 --> 00:27:34,399
don't you use generics you ask

730
00:27:30,960 --> 00:27:36,720
so we had three attempts to

731
00:27:34,399 --> 00:27:38,559
implement it using genetics and it you

732
00:27:36,720 --> 00:27:42,880
can get it to work

733
00:27:38,559 --> 00:27:45,360
but it's not looking pretty at all so

734
00:27:42,880 --> 00:27:46,399
what we ended up doing this slide is

735
00:27:45,360 --> 00:27:47,760
should not be here

736
00:27:46,399 --> 00:27:50,158
i think i explained it before about

737
00:27:47,760 --> 00:27:52,240
mipmaps so

738
00:27:50,159 --> 00:27:54,159
what we end up with is just runtime

739
00:27:52,240 --> 00:27:56,880
thing as you can see the

740
00:27:54,159 --> 00:27:58,240
initial state is an option which means

741
00:27:56,880 --> 00:27:59,600
if you want to transition it to a

742
00:27:58,240 --> 00:28:00,960
different one we remember what the

743
00:27:59,600 --> 00:28:03,918
initial state was

744
00:28:00,960 --> 00:28:05,440
and you may wonder why it's so simple

745
00:28:03,919 --> 00:28:07,279
what are you showing me here

746
00:28:05,440 --> 00:28:09,520
right as i mentioned there was like

747
00:28:07,279 --> 00:28:12,960
multiple tries to use

748
00:28:09,520 --> 00:28:16,240
rust type system they ended up being

749
00:28:12,960 --> 00:28:18,720
very complex hardly maintainable code

750
00:28:16,240 --> 00:28:20,240
so this solution is super simple it's

751
00:28:18,720 --> 00:28:22,480
straightforward everybody can

752
00:28:20,240 --> 00:28:24,480
see what it's doing it's more generic

753
00:28:22,480 --> 00:28:26,399
it's an example of how

754
00:28:24,480 --> 00:28:28,240
solving a more generic problem gives you

755
00:28:26,399 --> 00:28:31,840
a simpler solution and i think it's a

756
00:28:28,240 --> 00:28:31,840
it's a good example of that

757
00:28:32,080 --> 00:28:37,678
we track resources uh for the user

758
00:28:35,200 --> 00:28:39,600
so user has one link to a resource

759
00:28:37,679 --> 00:28:41,120
device has one link to resource and then

760
00:28:39,600 --> 00:28:43,360
everything else like commands and bind

761
00:28:41,120 --> 00:28:46,559
groups have different links

762
00:28:43,360 --> 00:28:47,439
um once those other links including the

763
00:28:46,559 --> 00:28:51,120
user one

764
00:28:47,440 --> 00:28:53,039
go away and device is the sole

765
00:28:51,120 --> 00:28:54,399
owner of the resource we figure out what

766
00:28:53,039 --> 00:28:56,320
was the last submission

767
00:28:54,399 --> 00:28:57,678
the resource was used and we associated

768
00:28:56,320 --> 00:28:59,279
with the submission then

769
00:28:57,679 --> 00:29:01,120
periodically we check the submission to

770
00:28:59,279 --> 00:29:02,880
see oh is it done yet

771
00:29:01,120 --> 00:29:04,799
and if it's done then that's the time

772
00:29:02,880 --> 00:29:07,360
where we actually release the resource

773
00:29:04,799 --> 00:29:10,639
and try to recycle its memory this is

774
00:29:07,360 --> 00:29:10,639
all done automatically for you

775
00:29:10,799 --> 00:29:16,480
this is the structure of wgpu um

776
00:29:14,480 --> 00:29:18,640
many ways here i'm trying to explain the

777
00:29:16,480 --> 00:29:21,120
main ones so the one that we have now

778
00:29:18,640 --> 00:29:22,000
is the only one going from double gpu rs

779
00:29:21,120 --> 00:29:25,360
which is our

780
00:29:22,000 --> 00:29:28,159
rust wrapper to the native which is this

781
00:29:25,360 --> 00:29:31,439
implementation or c api implementation

782
00:29:28,159 --> 00:29:35,520
that goes into core which goes into gfx

783
00:29:31,440 --> 00:29:38,399
what we will have is that wgpu rs will

784
00:29:35,520 --> 00:29:39,279
call websis and will allow you to target

785
00:29:38,399 --> 00:29:40,799
the web directly

786
00:29:39,279 --> 00:29:42,320
without going through rams scripting or

787
00:29:40,799 --> 00:29:45,520
anything

788
00:29:42,320 --> 00:29:47,200
alternatively you can use them scripting

789
00:29:45,520 --> 00:29:50,720
to target

790
00:29:47,200 --> 00:29:52,080
the web or you can use the shared path

791
00:29:50,720 --> 00:29:54,480
between web gpu native

792
00:29:52,080 --> 00:29:55,199
and on because they share the same c

793
00:29:54,480 --> 00:29:57,039
headers

794
00:29:55,200 --> 00:29:59,679
and you can run on top of google's

795
00:29:57,039 --> 00:29:59,679
implementation

796
00:30:02,080 --> 00:30:06,080
enamels are beautiful i i think

797
00:30:04,399 --> 00:30:08,080
everybody understands that and they work

798
00:30:06,080 --> 00:30:10,240
very well for us

799
00:30:08,080 --> 00:30:11,918
render past resources the the problem we

800
00:30:10,240 --> 00:30:13,360
have is that within the past we don't

801
00:30:11,919 --> 00:30:15,600
want to reference resources

802
00:30:13,360 --> 00:30:16,399
but the api requires us to hold them

803
00:30:15,600 --> 00:30:18,000
alive

804
00:30:16,399 --> 00:30:19,918
and that's three key because we don't

805
00:30:18,000 --> 00:30:20,799
want that overhead as i said you can

806
00:30:19,919 --> 00:30:22,159
have 10 000

807
00:30:20,799 --> 00:30:24,080
draw calls in the same render pass we

808
00:30:22,159 --> 00:30:26,320
don't want for each draw call try to

809
00:30:24,080 --> 00:30:29,279
lock those resources and keep them alive

810
00:30:26,320 --> 00:30:30,320
so we enforce the lifetimes they give it

811
00:30:29,279 --> 00:30:33,360
to us

812
00:30:30,320 --> 00:30:34,960
or at least for us for free but

813
00:30:33,360 --> 00:30:36,559
you pay for the headache because you're

814
00:30:34,960 --> 00:30:39,600
going to use that and

815
00:30:36,559 --> 00:30:41,120
lifetimes is not something that people

816
00:30:39,600 --> 00:30:42,799
love to see errors about but actually

817
00:30:41,120 --> 00:30:45,039
it's fairly straightforward

818
00:30:42,799 --> 00:30:46,879
so what we ended up with is a system

819
00:30:45,039 --> 00:30:48,240
where rust allows us to express those

820
00:30:46,880 --> 00:30:51,279
optimization guarantees

821
00:30:48,240 --> 00:30:52,799
with you and if you need them to be held

822
00:30:51,279 --> 00:30:56,559
you do it on your side typically you

823
00:30:52,799 --> 00:30:56,559
don't so you don't pay anything for that

824
00:30:58,720 --> 00:31:04,159
command encoders are they have special

825
00:31:02,000 --> 00:31:05,039
marker that does not let them to be

826
00:31:04,159 --> 00:31:08,240
moved or

827
00:31:05,039 --> 00:31:09,120
synced um automatically because send and

828
00:31:08,240 --> 00:31:12,080
sync are

829
00:31:09,120 --> 00:31:12,959
auto trades so this prevents those auto

830
00:31:12,080 --> 00:31:15,039
trades and

831
00:31:12,960 --> 00:31:16,559
this allows us to enforce the guarantee

832
00:31:15,039 --> 00:31:18,000
that when you're encoding

833
00:31:16,559 --> 00:31:22,080
you're not moving between threads or

834
00:31:18,000 --> 00:31:22,080
you're not doing it unsynchronized

835
00:31:22,240 --> 00:31:26,640
we use a lot of borrowing and the the

836
00:31:24,880 --> 00:31:27,600
pretty thing is that when we generate

837
00:31:26,640 --> 00:31:30,080
the c

838
00:31:27,600 --> 00:31:31,439
header we can still use external c

839
00:31:30,080 --> 00:31:33,360
functions with borrowing

840
00:31:31,440 --> 00:31:34,480
it translates to a pointer but not

841
00:31:33,360 --> 00:31:38,320
slices just

842
00:31:34,480 --> 00:31:40,960
regular things this is one of the

843
00:31:38,320 --> 00:31:42,639
most complex bits we have so as i

844
00:31:40,960 --> 00:31:44,240
mentioned our

845
00:31:42,640 --> 00:31:46,000
low level structures are placed in

846
00:31:44,240 --> 00:31:48,640
arrays and we lock those arrays in order

847
00:31:46,000 --> 00:31:50,159
to access them and you can imagine a

848
00:31:48,640 --> 00:31:50,640
case where the locks go in the wrong

849
00:31:50,159 --> 00:31:54,000
order

850
00:31:50,640 --> 00:31:57,600
that did happen so we ended up with type

851
00:31:54,000 --> 00:32:00,320
level lock order protection

852
00:31:57,600 --> 00:32:01,120
which is here the token i try to

853
00:32:00,320 --> 00:32:02,639
highlight

854
00:32:01,120 --> 00:32:04,719
including the one that failed to

855
00:32:02,640 --> 00:32:07,440
highlight these are

856
00:32:04,720 --> 00:32:08,399
all different types as in they depend on

857
00:32:07,440 --> 00:32:11,360
the different genetic

858
00:32:08,399 --> 00:32:12,320
and that genetic changes it shows the

859
00:32:11,360 --> 00:32:15,678
code

860
00:32:12,320 --> 00:32:17,439
what is accessible to lock so if you're

861
00:32:15,679 --> 00:32:18,399
trying to lock something weird your code

862
00:32:17,440 --> 00:32:19,919
will not compile

863
00:32:18,399 --> 00:32:21,518
if your code compiles it doesn't have

864
00:32:19,919 --> 00:32:24,080
phrase conditions and

865
00:32:21,519 --> 00:32:24,080
deadlocks

866
00:32:24,640 --> 00:32:28,320
we use parking lot which was mentioned

867
00:32:26,559 --> 00:32:31,360
already uh great stuff

868
00:32:28,320 --> 00:32:33,760
uh various arrays c binding that i

869
00:32:31,360 --> 00:32:35,840
mentioned for examples we use we need

870
00:32:33,760 --> 00:32:36,799
and of course we're based on gfx and a

871
00:32:35,840 --> 00:32:40,840
bit of frendy

872
00:32:36,799 --> 00:32:42,158
just the descriptor and memory stuff of

873
00:32:40,840 --> 00:32:44,158
randy

874
00:32:42,159 --> 00:32:45,840
as i mentioned you can have extensive

875
00:32:44,159 --> 00:32:48,159
function with the borrowed

876
00:32:45,840 --> 00:32:49,760
uh pointer but you can have slices and

877
00:32:48,159 --> 00:32:50,640
that's very annoying we have a lot of

878
00:32:49,760 --> 00:32:53,440
slices

879
00:32:50,640 --> 00:32:53,919
and uh always converts in between slices

880
00:32:53,440 --> 00:32:57,200
and

881
00:32:53,919 --> 00:32:58,640
pointers is not pretty so i would love

882
00:32:57,200 --> 00:33:01,919
that to be better

883
00:32:58,640 --> 00:33:02,480
and the one lesson that i want to tell

884
00:33:01,919 --> 00:33:05,679
you is

885
00:33:02,480 --> 00:33:07,200
like rust community is that we concluded

886
00:33:05,679 --> 00:33:09,440
that genetics are not always good

887
00:33:07,200 --> 00:33:10,960
um maybe it's obvious for you we used a

888
00:33:09,440 --> 00:33:13,120
ton of genetics in gfx

889
00:33:10,960 --> 00:33:14,080
and on webview we're trying to minimize

890
00:33:13,120 --> 00:33:17,039
that

891
00:33:14,080 --> 00:33:17,840
generics slow down the compilation time

892
00:33:17,039 --> 00:33:21,120
and

893
00:33:17,840 --> 00:33:22,879
they limit the user quite a bit

894
00:33:21,120 --> 00:33:24,479
they make it difficult to work with the

895
00:33:22,880 --> 00:33:27,679
code so

896
00:33:24,480 --> 00:33:27,679
we're trying to do less of them

897
00:33:29,120 --> 00:33:32,399
so i mentioned we are going to target

898
00:33:31,360 --> 00:33:34,799
websites directly

899
00:33:32,399 --> 00:33:38,158
that's one of the things error handling

900
00:33:34,799 --> 00:33:40,639
is bare bones we have

901
00:33:38,159 --> 00:33:41,919
asserts somewhere results but all of

902
00:33:40,640 --> 00:33:44,000
that is going to be replaced by the

903
00:33:41,919 --> 00:33:46,880
proper error model in the api which is

904
00:33:44,000 --> 00:33:48,480
the internal nullability

905
00:33:46,880 --> 00:33:50,000
which means if you're trying to do

906
00:33:48,480 --> 00:33:52,399
something illegal to an object

907
00:33:50,000 --> 00:33:53,279
like you created a buffer with the wrong

908
00:33:52,399 --> 00:33:56,080
descriptor

909
00:33:53,279 --> 00:33:57,039
then it may be internally invalid you

910
00:33:56,080 --> 00:33:58,879
can ask it

911
00:33:57,039 --> 00:34:00,320
whether it's valid or not but you might

912
00:33:58,880 --> 00:34:02,640
as well just continue your

913
00:34:00,320 --> 00:34:04,158
recording and pretend that it's valid

914
00:34:02,640 --> 00:34:06,480
only to discover it later

915
00:34:04,159 --> 00:34:08,320
and the reason it's done is because we

916
00:34:06,480 --> 00:34:11,119
can't give it to you synchronously

917
00:34:08,320 --> 00:34:12,480
and we can't let you block so you can we

918
00:34:11,119 --> 00:34:14,960
kind of let you go

919
00:34:12,480 --> 00:34:16,000
and then when you're ready you're gonna

920
00:34:14,960 --> 00:34:17,760
check whether

921
00:34:16,000 --> 00:34:19,760
your workload is valid or not on our

922
00:34:17,760 --> 00:34:21,919
site we're not gonna

923
00:34:19,760 --> 00:34:23,679
do any invalid work of course if we if

924
00:34:21,918 --> 00:34:25,118
we see during command buffer encoding

925
00:34:23,679 --> 00:34:28,240
that you used in valid buffer

926
00:34:25,119 --> 00:34:31,119
your cool command buffer becomes invalid

927
00:34:28,239 --> 00:34:31,918
um we very much would like to target

928
00:34:31,119 --> 00:34:34,480
opengl

929
00:34:31,918 --> 00:34:35,839
as well it's it's technically a target

930
00:34:34,480 --> 00:34:38,480
for us but

931
00:34:35,839 --> 00:34:40,320
it's rough um we don't recommend people

932
00:34:38,480 --> 00:34:41,679
to use it we don't even expose it via

933
00:34:40,320 --> 00:34:45,679
the rust wrapper yet

934
00:34:41,679 --> 00:34:47,359
so more work coming um

935
00:34:45,679 --> 00:34:49,200
there is a summer of code project that

936
00:34:47,359 --> 00:34:50,879
is related to that so maybe in half a

937
00:34:49,199 --> 00:34:54,239
year the situation is going to be better

938
00:34:50,879 --> 00:34:56,960
ideally we would target webgl

939
00:34:54,239 --> 00:34:59,279
2.0 by web gpu which is going to be fun

940
00:34:56,960 --> 00:34:59,280
as well

941
00:35:00,640 --> 00:35:05,200
these are some links of the projects uh

942
00:35:03,200 --> 00:35:08,319
at the top there is a

943
00:35:05,200 --> 00:35:09,279
spec repo i'm one of the editors for the

944
00:35:08,320 --> 00:35:12,240
spec

945
00:35:09,280 --> 00:35:13,359
and the there is the web gpu headers at

946
00:35:12,240 --> 00:35:16,399
the bottom and there is

947
00:35:13,359 --> 00:35:18,480
our previous talk about gfx at the

948
00:35:16,400 --> 00:35:22,000
bottom

949
00:35:18,480 --> 00:35:25,280
so now we have we have time

950
00:35:22,000 --> 00:35:25,280
we're going to talk about browsers

951
00:35:25,920 --> 00:35:30,560
this is how gecko is structured today

952
00:35:28,640 --> 00:35:34,000
you can see it in

953
00:35:30,560 --> 00:35:36,480
nightly we have a small

954
00:35:34,000 --> 00:35:38,160
crate which you call which is called wgp

955
00:35:36,480 --> 00:35:41,839
remote which allows

956
00:35:38,160 --> 00:35:41,839
you to record passes and

957
00:35:42,960 --> 00:35:48,480
create ids and allow the content process

958
00:35:46,160 --> 00:35:49,200
to manage ids and passes and the gpu

959
00:35:48,480 --> 00:35:52,320
process

960
00:35:49,200 --> 00:35:54,078
to actually execute them so um

961
00:35:52,320 --> 00:35:56,240
this is a fairly simple structure but

962
00:35:54,079 --> 00:35:59,200
the point is web gpu is used across

963
00:35:56,240 --> 00:35:59,200
multiple processes

964
00:36:00,720 --> 00:36:04,480
this is an example of how it's done so

965
00:36:02,720 --> 00:36:07,680
the client creates an id

966
00:36:04,480 --> 00:36:11,359
it sends it to both javascript

967
00:36:07,680 --> 00:36:13,520
and the server and the cro server will

968
00:36:11,359 --> 00:36:15,920
only afterwards actually create the

969
00:36:13,520 --> 00:36:15,920
buffer

970
00:36:17,119 --> 00:36:21,599
render pass recording as i mentioned is

971
00:36:19,119 --> 00:36:23,359
completely on the client side so while

972
00:36:21,599 --> 00:36:24,240
you create your render pass it's super

973
00:36:23,359 --> 00:36:27,279
lightweight

974
00:36:24,240 --> 00:36:29,439
it doesn't take anything we use peak

975
00:36:27,280 --> 00:36:32,160
poke serialization library i know

976
00:36:29,440 --> 00:36:33,280
everybody uses survey so peak poke is a

977
00:36:32,160 --> 00:36:35,200
kind of

978
00:36:33,280 --> 00:36:36,480
dark horse alternative it's not

979
00:36:35,200 --> 00:36:40,000
recommended to be used it's

980
00:36:36,480 --> 00:36:42,960
only used by webrender today and web gpu

981
00:36:40,000 --> 00:36:45,280
we'll try to make it more accessible

982
00:36:42,960 --> 00:36:47,440
it's just slightly faster

983
00:36:45,280 --> 00:36:48,640
and then when render pass is done we

984
00:36:47,440 --> 00:36:50,800
send the whole thing

985
00:36:48,640 --> 00:36:53,040
via shared memory to gpu process which

986
00:36:50,800 --> 00:36:56,000
actually executes commands

987
00:36:53,040 --> 00:36:57,040
there is a lot going on here that is

988
00:36:56,000 --> 00:37:00,240
that you don't see

989
00:36:57,040 --> 00:37:00,960
um imagine that the barrier between

990
00:37:00,240 --> 00:37:03,040
processes

991
00:37:00,960 --> 00:37:04,000
involves a code generation change in c

992
00:37:03,040 --> 00:37:05,920
plus plus

993
00:37:04,000 --> 00:37:07,280
the barrier between javascript involves

994
00:37:05,920 --> 00:37:10,800
a co-generation phase

995
00:37:07,280 --> 00:37:14,400
in javascript bindings and between

996
00:37:10,800 --> 00:37:16,079
each of those there is a c to rust

997
00:37:14,400 --> 00:37:18,160
boundary so we we cross like four

998
00:37:16,079 --> 00:37:20,240
different boundaries across the stack

999
00:37:18,160 --> 00:37:23,839
um it's fairly annoying and we're trying

1000
00:37:20,240 --> 00:37:23,839
to get it better

1001
00:37:24,000 --> 00:37:28,079
this is a subjective measure of

1002
00:37:26,400 --> 00:37:31,200
completeness between browsers

1003
00:37:28,079 --> 00:37:31,599
chromium is fairly good they have a

1004
00:37:31,200 --> 00:37:35,279
large

1005
00:37:31,599 --> 00:37:36,800
team and they are

1006
00:37:35,280 --> 00:37:39,280
they have a lot of api service

1007
00:37:36,800 --> 00:37:42,560
implemented we

1008
00:37:39,280 --> 00:37:45,200
just got the compute working you can get

1009
00:37:42,560 --> 00:37:46,640
you can get the nightly go to the prefs

1010
00:37:45,200 --> 00:37:48,960
enable web gpu

1011
00:37:46,640 --> 00:37:49,680
and run the compute example let everyone

1012
00:37:48,960 --> 00:37:52,960
that

1013
00:37:49,680 --> 00:37:54,000
chrome does we will work on presentation

1014
00:37:52,960 --> 00:37:55,839
rendering next

1015
00:37:54,000 --> 00:37:57,920
and servo is also catching up for servo

1016
00:37:55,839 --> 00:37:59,680
catching up is fairly simple because

1017
00:37:57,920 --> 00:38:01,040
it's pure rust you don't have as many

1018
00:37:59,680 --> 00:38:02,480
barriers that i mentioned

1019
00:38:01,040 --> 00:38:05,839
but it's using the same infrastructure

1020
00:38:02,480 --> 00:38:05,839
it's using ww

1021
00:38:06,000 --> 00:38:09,920
and i'd like to thank some people my gfx

1022
00:38:09,119 --> 00:38:12,960
team

1023
00:38:09,920 --> 00:38:16,720
wgpu community josh especially

1024
00:38:12,960 --> 00:38:20,480
and currency from google for helping out

1025
00:38:16,720 --> 00:38:20,480
on the spec and with the slides

1026
00:38:21,119 --> 00:38:25,520
so that's it i think we've been finished

1027
00:38:30,839 --> 00:38:33,839
early

1028
00:38:37,760 --> 00:38:44,000
you mentioned that you don't have any

1029
00:38:41,040 --> 00:38:46,079
final proposal for stating languages so

1030
00:38:44,000 --> 00:38:49,920
what are the proposals

1031
00:38:46,079 --> 00:38:49,920
the most possible ones

1032
00:38:51,440 --> 00:38:57,040
and which more which proposes

1033
00:38:54,880 --> 00:38:58,960
languages the question is what are the

1034
00:38:57,040 --> 00:39:01,680
proposals for scheduling languages

1035
00:38:58,960 --> 00:39:02,800
so we are considering three different

1036
00:39:01,680 --> 00:39:06,160
things

1037
00:39:02,800 --> 00:39:07,359
wsl is what apple is proposing and it

1038
00:39:06,160 --> 00:39:09,520
was originally

1039
00:39:07,359 --> 00:39:11,200
called by two different names i think

1040
00:39:09,520 --> 00:39:12,079
it's they call it whistle now it was

1041
00:39:11,200 --> 00:39:14,879
based on

1042
00:39:12,079 --> 00:39:15,839
wglsl originally now it's something not

1043
00:39:14,880 --> 00:39:19,119
original

1044
00:39:15,839 --> 00:39:21,040
oh now it's something original and um

1045
00:39:19,119 --> 00:39:23,119
the other alternative is prv

1046
00:39:21,040 --> 00:39:24,320
the problem with prv is basically the

1047
00:39:23,119 --> 00:39:27,599
same problem as

1048
00:39:24,320 --> 00:39:29,680
why we are not doing it in chronos so

1049
00:39:27,599 --> 00:39:30,640
because it's a chronos thing and we are

1050
00:39:29,680 --> 00:39:33,200
concerned about

1051
00:39:30,640 --> 00:39:34,560
four kings prv and whether it's gonna we

1052
00:39:33,200 --> 00:39:36,399
will be able to

1053
00:39:34,560 --> 00:39:37,839
like synchronize with the main

1054
00:39:36,400 --> 00:39:39,200
development of spear v

1055
00:39:37,839 --> 00:39:40,960
how our interests are gonna be

1056
00:39:39,200 --> 00:39:43,520
represented and so forth

1057
00:39:40,960 --> 00:39:44,720
and we are exploring something that

1058
00:39:43,520 --> 00:39:47,200
would be

1059
00:39:44,720 --> 00:39:48,000
likes purvi or semantically close to

1060
00:39:47,200 --> 00:39:49,680
spree but

1061
00:39:48,000 --> 00:39:51,520
it's going to be textual so that you can

1062
00:39:49,680 --> 00:39:54,560
see the text but you can

1063
00:39:51,520 --> 00:39:56,000
like do a single pass and convert it to

1064
00:39:54,560 --> 00:39:57,440
or from spur v

1065
00:39:56,000 --> 00:39:59,920
which may be the compromise that we are

1066
00:39:57,440 --> 00:39:59,920
looking for

1067
00:40:00,800 --> 00:40:04,480
yes i guess if i was seeing a bungee or

1068
00:40:02,960 --> 00:40:05,440
something and thinking about writing the

1069
00:40:04,480 --> 00:40:07,280
kind of thing at the beginning

1070
00:40:05,440 --> 00:40:08,960
like destiny or something or you've got

1071
00:40:07,280 --> 00:40:09,599
multiple passes to do all your lighting

1072
00:40:08,960 --> 00:40:10,960
because

1073
00:40:09,599 --> 00:40:12,720
i'm going to ask you where the diff sets

1074
00:40:10,960 --> 00:40:14,240
so you know metal doesn't allow you to

1075
00:40:12,720 --> 00:40:14,879
do the different sets right the falcon

1076
00:40:14,240 --> 00:40:17,359
does

1077
00:40:14,880 --> 00:40:18,560
and that's one of the key performance

1078
00:40:17,359 --> 00:40:20,880
things for generating your

1079
00:40:18,560 --> 00:40:23,680
next frame your pipeline and you don't

1080
00:40:20,880 --> 00:40:25,520
have any of those i suppose

1081
00:40:23,680 --> 00:40:26,799
sorry is your question about descriptor

1082
00:40:25,520 --> 00:40:28,000
sets yeah well but the diff you know

1083
00:40:26,800 --> 00:40:29,599
when you can take the diff sets so you

1084
00:40:28,000 --> 00:40:31,119
can just say which state has changed and

1085
00:40:29,599 --> 00:40:32,240
what hasn't and then you can update that

1086
00:40:31,119 --> 00:40:34,319
without having to

1087
00:40:32,240 --> 00:40:35,598
sync the whole thing metal doesn't have

1088
00:40:34,319 --> 00:40:36,800
that metal two doesn't have that

1089
00:40:35,599 --> 00:40:40,000
revolving does

1090
00:40:36,800 --> 00:40:41,760
and your question is about the diff sets

1091
00:40:40,000 --> 00:40:44,079
for the pipeline

1092
00:40:41,760 --> 00:40:45,359
oh no we don't have the gifts for i

1093
00:40:44,079 --> 00:40:48,720
think that's a very very

1094
00:40:45,359 --> 00:40:50,799
like low level thing that is

1095
00:40:48,720 --> 00:40:52,078
not exactly like we would need to go

1096
00:40:50,800 --> 00:40:53,920
through the process of doing the

1097
00:40:52,079 --> 00:40:56,160
benchmarks and seeing what platforms

1098
00:40:53,920 --> 00:40:56,960
affect how we can port it to other

1099
00:40:56,160 --> 00:40:58,640
platforms and

1100
00:40:56,960 --> 00:41:00,880
we have much more bigger things on the

1101
00:40:58,640 --> 00:41:03,359
table now than this one but

1102
00:41:00,880 --> 00:41:04,480
yes we kind of keep that in mind the api

1103
00:41:03,359 --> 00:41:06,400
is not finished

1104
00:41:04,480 --> 00:41:08,560
it's a work working progress still the

1105
00:41:06,400 --> 00:41:10,480
later this year we are hoping to get the

1106
00:41:08,560 --> 00:41:12,799
minimal viable product of the api that

1107
00:41:10,480 --> 00:41:16,000
people can try and is implemented in

1108
00:41:12,800 --> 00:41:21,839
three browsers or maybe four with servo

1109
00:41:16,000 --> 00:41:23,839
so we're still working on that

1110
00:41:21,839 --> 00:41:25,920
is there any interest in standardizing

1111
00:41:23,839 --> 00:41:28,000
texture formats

1112
00:41:25,920 --> 00:41:29,280
is there any interesting standardizing

1113
00:41:28,000 --> 00:41:31,680
texture formats

1114
00:41:29,280 --> 00:41:32,640
we are going to have a list of supported

1115
00:41:31,680 --> 00:41:36,078
formats

1116
00:41:32,640 --> 00:41:37,920
but all of the compressed ones

1117
00:41:36,079 --> 00:41:41,920
are going to be extensions because

1118
00:41:37,920 --> 00:41:45,359
they're not supported on any particular

1119
00:41:41,920 --> 00:41:45,359
on all the platforms and

1120
00:41:45,599 --> 00:41:48,720
we are interested we are going to be

1121
00:41:48,240 --> 00:41:51,598
looking

1122
00:41:48,720 --> 00:41:54,160
at more elaborate texture formats as a

1123
00:41:51,599 --> 00:41:54,160
follow-up

1124
00:41:56,240 --> 00:41:59,680
yeah you mentioned removing vertex

1125
00:41:58,079 --> 00:42:03,839
buffers did you

1126
00:41:59,680 --> 00:42:03,839
say what the alternative api would be

1127
00:42:04,319 --> 00:42:11,119
what would be the alternative api for

1128
00:42:07,359 --> 00:42:13,839
providing versus data so we have the

1129
00:42:11,119 --> 00:42:15,680
shader seized resources in bind groups

1130
00:42:13,839 --> 00:42:18,319
and you can technically just

1131
00:42:15,680 --> 00:42:18,799
bind your buffers inside some bind

1132
00:42:18,319 --> 00:42:22,800
groups

1133
00:42:18,800 --> 00:42:24,400
and read them directly which

1134
00:42:22,800 --> 00:42:26,480
is no worse in fact we did some

1135
00:42:24,400 --> 00:42:29,599
benchmarking and on many platforms

1136
00:42:26,480 --> 00:42:33,359
this is what the drivers actually do

1137
00:42:29,599 --> 00:42:35,680
so we don't see any performance penalty

1138
00:42:33,359 --> 00:42:37,279
but on some very few especially older

1139
00:42:35,680 --> 00:42:37,839
platforms which still have some fixed

1140
00:42:37,280 --> 00:42:41,680
function

1141
00:42:37,839 --> 00:42:42,880
hardware this is slightly slower and the

1142
00:42:41,680 --> 00:42:44,960
main problem is that it's just

1143
00:42:42,880 --> 00:42:58,400
inconvenient nobody is used to that

1144
00:42:44,960 --> 00:43:00,720
workflow that you don't have 36 buffers

1145
00:42:58,400 --> 00:43:02,800
that's just a comment my actual question

1146
00:43:00,720 --> 00:43:04,480
was

1147
00:43:02,800 --> 00:43:05,839
more regarding shader compilation

1148
00:43:04,480 --> 00:43:09,920
performance because

1149
00:43:05,839 --> 00:43:13,839
uh so far we've worked a lot with

1150
00:43:09,920 --> 00:43:15,599
webgl even the glsl for webgl 2

1151
00:43:13,839 --> 00:43:17,359
is much simpler probably whatever you're

1152
00:43:15,599 --> 00:43:19,200
going to make for web gpu

1153
00:43:17,359 --> 00:43:21,200
and the compilation performance is still

1154
00:43:19,200 --> 00:43:22,720
absolutely terrible and you and yourself

1155
00:43:21,200 --> 00:43:25,118
pretty much

1156
00:43:22,720 --> 00:43:26,399
how do you i mean i talk to people from

1157
00:43:25,119 --> 00:43:28,720
rome and apple

1158
00:43:26,400 --> 00:43:29,440
and do your promise is going to be all

1159
00:43:28,720 --> 00:43:30,959
but

1160
00:43:29,440 --> 00:43:32,640
i don't know do you think it's real

1161
00:43:30,960 --> 00:43:33,920
progress being mad

1162
00:43:32,640 --> 00:43:36,879
because you i know you have to do a lot

1163
00:43:33,920 --> 00:43:40,480
of validation for the compilation

1164
00:43:36,880 --> 00:43:40,800
but do you think there's new discoveries

1165
00:43:40,480 --> 00:43:42,880
or

1166
00:43:40,800 --> 00:43:45,200
ways on how to actually implement that

1167
00:43:42,880 --> 00:43:48,640
because that's in my opinion the biggest

1168
00:43:45,200 --> 00:43:51,839
imager on doing something quite large uh

1169
00:43:48,640 --> 00:43:54,000
on the web so that's my question okay so

1170
00:43:51,839 --> 00:43:55,359
the first note was about the number of

1171
00:43:54,000 --> 00:43:58,319
bind groups and

1172
00:43:55,359 --> 00:44:00,480
we we have the the limit structure that

1173
00:43:58,319 --> 00:44:02,240
you have from the adapter and you can

1174
00:44:00,480 --> 00:44:04,000
see that the adapter supports more and

1175
00:44:02,240 --> 00:44:05,680
you can request more so

1176
00:44:04,000 --> 00:44:07,040
you can design your application so that

1177
00:44:05,680 --> 00:44:08,640
it's not going to run on mobile

1178
00:44:07,040 --> 00:44:11,680
if you wanted to but if you go by

1179
00:44:08,640 --> 00:44:14,879
default you only get four mine groups

1180
00:44:11,680 --> 00:44:16,640
for another question was how do we

1181
00:44:14,880 --> 00:44:18,880
handle slow

1182
00:44:16,640 --> 00:44:20,480
pipeline creation performance because of

1183
00:44:18,880 --> 00:44:22,160
the shader building and because of

1184
00:44:20,480 --> 00:44:24,480
the fact that we need to transform the

1185
00:44:22,160 --> 00:44:26,480
shaders to do bounce checking and a lot

1186
00:44:24,480 --> 00:44:29,839
of other safety transformations

1187
00:44:26,480 --> 00:44:32,720
so our measurements so far show that

1188
00:44:29,839 --> 00:44:33,440
at least in case of sprv the time spent

1189
00:44:32,720 --> 00:44:35,598
on

1190
00:44:33,440 --> 00:44:38,000
doing the transformation passes on our

1191
00:44:35,599 --> 00:44:40,800
side even converting from

1192
00:44:38,000 --> 00:44:42,400
a whistle to sprv is negligible

1193
00:44:40,800 --> 00:44:43,520
comparing to the time that the driver

1194
00:44:42,400 --> 00:44:45,520
spends

1195
00:44:43,520 --> 00:44:47,200
that builds in the actual microcode for

1196
00:44:45,520 --> 00:44:48,400
our shader so

1197
00:44:47,200 --> 00:44:50,240
measures that we're gonna take

1198
00:44:48,400 --> 00:44:52,640
internally is like aggressive use of

1199
00:44:50,240 --> 00:44:56,479
pipeline caches and

1200
00:44:52,640 --> 00:44:57,920
that stuff but the other thing on from

1201
00:44:56,480 --> 00:45:00,560
the api side we

1202
00:44:57,920 --> 00:45:01,359
we will have it asynchronous so you

1203
00:45:00,560 --> 00:45:02,720
request

1204
00:45:01,359 --> 00:45:04,960
the pipeline to be created but you don't

1205
00:45:02,720 --> 00:45:06,640
get it right away you get a notification

1206
00:45:04,960 --> 00:45:10,240
where you can use the pipeline

1207
00:45:06,640 --> 00:45:12,640
um i don't think there is much we can do

1208
00:45:10,240 --> 00:45:14,720
besides that like once we once we pass

1209
00:45:12,640 --> 00:45:17,359
this prv or msl to

1210
00:45:14,720 --> 00:45:19,439
to the driver there is nothing we can do

1211
00:45:17,359 --> 00:45:20,000
but we we have very good relationships

1212
00:45:19,440 --> 00:45:21,920
with the

1213
00:45:20,000 --> 00:45:23,200
vendors from kronos so we are going to

1214
00:45:21,920 --> 00:45:33,760
be talking to them

1215
00:45:23,200 --> 00:45:35,839
as well thank you very much

1216
00:45:33,760 --> 00:45:35,839
you

