1
00:00:08,000 --> 00:00:10,320
okay

2
00:00:11,280 --> 00:00:19,600
hello our next speaker is

3
00:00:14,880 --> 00:00:22,720
free ikanayaka he is a member of the lxd

4
00:00:19,600 --> 00:00:25,279
at canonical and he will present

5
00:00:22,720 --> 00:00:26,400
dekulite a distributed embeddable

6
00:00:25,279 --> 00:00:31,119
database

7
00:00:26,400 --> 00:00:33,680
please welcome

8
00:00:31,119 --> 00:00:34,880
thank you very much i guess you can hear

9
00:00:33,680 --> 00:00:38,160
me

10
00:00:34,880 --> 00:00:41,520
uh so yeah my name is free uh that's

11
00:00:38,160 --> 00:00:45,519
the real name uh not a nick as weird

12
00:00:41,520 --> 00:00:49,280
as it could sound and as you mentioned

13
00:00:45,520 --> 00:00:52,559
a member of the lex d team at canonical

14
00:00:49,280 --> 00:00:52,879
likes d is a container management system

15
00:00:52,559 --> 00:00:57,919
for

16
00:00:52,879 --> 00:01:01,358
system containers and as part of it

17
00:00:57,920 --> 00:01:04,640
we started a sub project called dqlite

18
00:01:01,359 --> 00:01:05,119
when we had to uh implement clustering

19
00:01:04,640 --> 00:01:08,320
in

20
00:01:05,119 --> 00:01:11,439
lexdi so instead of having just

21
00:01:08,320 --> 00:01:12,158
one node running your containers now you

22
00:01:11,439 --> 00:01:15,360
can have

23
00:01:12,159 --> 00:01:19,600
a cluster of them and it behaves

24
00:01:15,360 --> 00:01:19,600
in coherently in a consistent way

25
00:01:19,759 --> 00:01:25,520
we were using sqlite before and so we

26
00:01:23,680 --> 00:01:28,320
thought it would be a good idea to keep

27
00:01:25,520 --> 00:01:31,199
using that model

28
00:01:28,320 --> 00:01:31,199
before i start

29
00:01:31,680 --> 00:01:38,720
how many of you do not know about

30
00:01:35,119 --> 00:01:38,720
sqlite or sqlite

31
00:01:39,200 --> 00:01:43,040
i don't see many hands raised actually

32
00:01:42,640 --> 00:01:46,640
none

33
00:01:43,040 --> 00:01:49,840
which is expected uh

34
00:01:46,640 --> 00:01:54,240
because yes uh sqlite is

35
00:01:49,840 --> 00:01:56,960
one of the probably the most widely

36
00:01:54,240 --> 00:01:58,640
used database in the world because of

37
00:01:56,960 --> 00:02:02,880
embedded systems uh

38
00:01:58,640 --> 00:02:03,520
android and uh and similar things there

39
00:02:02,880 --> 00:02:07,039
are

40
00:02:03,520 --> 00:02:11,038
billions of of deployments

41
00:02:07,040 --> 00:02:14,480
and it's a very solid code base

42
00:02:11,038 --> 00:02:18,000
uh very high quality uh with a

43
00:02:14,480 --> 00:02:20,799
core team of maintainers that

44
00:02:18,000 --> 00:02:23,440
has been keeping up for for more than 20

45
00:02:20,800 --> 00:02:26,720
years now

46
00:02:23,440 --> 00:02:27,760
there are many use cases for it so the

47
00:02:26,720 --> 00:02:31,519
the

48
00:02:27,760 --> 00:02:35,120
cq lite author advertises it

49
00:02:31,519 --> 00:02:36,000
as a replacement of f open in the sense

50
00:02:35,120 --> 00:02:39,040
that it's

51
00:02:36,000 --> 00:02:41,920
as easy to use as

52
00:02:39,040 --> 00:02:42,720
you know a system called to open a file

53
00:02:41,920 --> 00:02:47,599
but

54
00:02:42,720 --> 00:02:49,440
in return you get a structured way to to

55
00:02:47,599 --> 00:02:52,640
manage your data

56
00:02:49,440 --> 00:02:56,000
so yeah it's using embedded devices in

57
00:02:52,640 --> 00:02:59,119
agents such as lexd

58
00:02:56,000 --> 00:03:00,159
or in desktop applications for example

59
00:02:59,120 --> 00:03:03,040
firefox

60
00:03:00,159 --> 00:03:04,959
chrome all use just to organize

61
00:03:03,040 --> 00:03:07,120
bookmarks and stuff like that as you

62
00:03:04,959 --> 00:03:07,120
know

63
00:03:08,159 --> 00:03:12,640
so what do you get with the dq lite that

64
00:03:11,120 --> 00:03:17,599
you don't get with

65
00:03:12,640 --> 00:03:19,839
sqlite so well that's high availability

66
00:03:17,599 --> 00:03:20,799
the main problem with the sqlite is of

67
00:03:19,840 --> 00:03:23,120
course

68
00:03:20,800 --> 00:03:24,799
everything is local to your node which

69
00:03:23,120 --> 00:03:28,000
is a good thing because

70
00:03:24,799 --> 00:03:28,720
it simplifies everything things are

71
00:03:28,000 --> 00:03:31,440
faster

72
00:03:28,720 --> 00:03:32,799
etc but it's also a single point of

73
00:03:31,440 --> 00:03:35,920
failure

74
00:03:32,799 --> 00:03:38,239
for example in lexdi uh if you

75
00:03:35,920 --> 00:03:40,000
if you put everything in one node if you

76
00:03:38,239 --> 00:03:45,120
lose that single node

77
00:03:40,000 --> 00:03:48,239
everything uh would be gone um

78
00:03:45,120 --> 00:03:49,440
yeah with the with dq light uh we

79
00:03:48,239 --> 00:03:52,720
distribute

80
00:03:49,440 --> 00:03:55,280
uh the the data across

81
00:03:52,720 --> 00:03:56,480
all the nodes of the cluster the data is

82
00:03:55,280 --> 00:04:00,799
replicated

83
00:03:56,480 --> 00:04:03,040
so in case of of failure of a node

84
00:04:00,799 --> 00:04:04,560
there are automatic mechanisms for

85
00:04:03,040 --> 00:04:07,439
failover

86
00:04:04,560 --> 00:04:10,560
and as long as your client can connect

87
00:04:07,439 --> 00:04:15,200
to another node in the cluster

88
00:04:10,560 --> 00:04:18,639
you're good so um

89
00:04:15,200 --> 00:04:21,839
this is a very simple uh

90
00:04:18,639 --> 00:04:24,479
diagram of the classic way of of using

91
00:04:21,839 --> 00:04:25,840
sqlite so you have your application

92
00:04:24,479 --> 00:04:31,199
process

93
00:04:25,840 --> 00:04:34,080
sqlite is a c library that that you link

94
00:04:31,199 --> 00:04:34,400
depending on your application language

95
00:04:34,080 --> 00:04:36,479
you

96
00:04:34,400 --> 00:04:39,198
you will use bindings so the original

97
00:04:36,479 --> 00:04:43,199
body lines are in c

98
00:04:39,199 --> 00:04:47,120
and and if you have an external client

99
00:04:43,199 --> 00:04:49,280
either by an api or even command line

100
00:04:47,120 --> 00:04:51,520
you you you can drive your application

101
00:04:49,280 --> 00:04:56,239
through it

102
00:04:51,520 --> 00:04:59,520
with dqlite the model is similar

103
00:04:56,240 --> 00:05:02,639
except that you have

104
00:04:59,520 --> 00:05:02,639
more than one node

105
00:05:03,120 --> 00:05:10,000
so you have a cluster of processes

106
00:05:07,039 --> 00:05:11,840
your your your application will run on

107
00:05:10,000 --> 00:05:14,479
different nodes each nodes

108
00:05:11,840 --> 00:05:17,520
typically run one instance of your

109
00:05:14,479 --> 00:05:21,520
application process

110
00:05:17,520 --> 00:05:25,120
and instead of talking to the

111
00:05:21,520 --> 00:05:28,159
sqlite api you'd talk to the

112
00:05:25,120 --> 00:05:28,160
dqlite api

113
00:05:29,199 --> 00:05:32,800
still it's embedded in in the process

114
00:05:31,919 --> 00:05:35,840
the qlite is

115
00:05:32,800 --> 00:05:41,440
as well a c library which gets

116
00:05:35,840 --> 00:05:44,799
linked to your process inside the q lite

117
00:05:41,440 --> 00:05:48,719
there is an engine which uses

118
00:05:44,800 --> 00:05:51,440
raft to replicate the data and

119
00:05:48,720 --> 00:05:52,000
sqlite actually to process the data to

120
00:05:51,440 --> 00:05:56,479
to offer

121
00:05:52,000 --> 00:05:56,479
you the sqlite engine

122
00:05:56,960 --> 00:06:05,680
there's an important difference

123
00:06:01,360 --> 00:06:10,080
in that with sqlite with the capi

124
00:06:05,680 --> 00:06:13,600
you you talk locally to your node

125
00:06:10,080 --> 00:06:14,159
with dq lite uh since it's based on on

126
00:06:13,600 --> 00:06:18,800
raft

127
00:06:14,160 --> 00:06:18,800
we we can talk about this uh later

128
00:06:18,960 --> 00:06:22,400
you will have to connect to the leader

129
00:06:21,680 --> 00:06:26,639
of the

130
00:06:22,400 --> 00:06:30,799
of the cluster so is there a

131
00:06:26,639 --> 00:06:34,130
a pointer somewhere i didn't ask

132
00:06:30,800 --> 00:06:36,240
okay no anyway um

133
00:06:34,130 --> 00:06:38,719
[Music]

134
00:06:36,240 --> 00:06:40,560
you have to connect to the leader of the

135
00:06:38,720 --> 00:06:44,479
of the cluster which can be

136
00:06:40,560 --> 00:06:47,520
any of those processes and that leader

137
00:06:44,479 --> 00:06:49,659
will will be the one actually serving

138
00:06:47,520 --> 00:06:51,120
your queries

139
00:06:49,660 --> 00:06:55,199
[Music]

140
00:06:51,120 --> 00:06:58,880
so it retains the light retains

141
00:06:55,199 --> 00:07:02,319
the embedded part of sqlite

142
00:06:58,880 --> 00:07:05,360
but there's no way you can

143
00:07:02,319 --> 00:07:09,280
keep the 100 local part

144
00:07:05,360 --> 00:07:11,520
you need to go through the network and

145
00:07:09,280 --> 00:07:12,638
this is uh and this is uh one one

146
00:07:11,520 --> 00:07:16,799
important uh

147
00:07:12,639 --> 00:07:20,720
different uh should any of your

148
00:07:16,800 --> 00:07:23,280
processes die uh the data in

149
00:07:20,720 --> 00:07:24,080
your database is replicated as they said

150
00:07:23,280 --> 00:07:26,880
and

151
00:07:24,080 --> 00:07:29,198
your your process or your client

152
00:07:26,880 --> 00:07:31,840
depending where you put the logic

153
00:07:29,199 --> 00:07:33,680
can connect to to to the new leader can

154
00:07:31,840 --> 00:07:38,479
discover the new leader

155
00:07:33,680 --> 00:07:42,319
and and go on with the computation

156
00:07:38,479 --> 00:07:45,599
okay turkey's chip show me the code this

157
00:07:42,319 --> 00:07:46,240
is a quote from linux turbos uh so i

158
00:07:45,599 --> 00:07:50,319
will

159
00:07:46,240 --> 00:07:53,840
try to show you um

160
00:07:50,319 --> 00:07:57,120
a very simple application the the goal

161
00:07:53,840 --> 00:08:00,239
is to to demonstrate

162
00:07:57,120 --> 00:08:05,120
that you can write a go

163
00:08:00,240 --> 00:08:09,280
program with 132 lines of code

164
00:08:05,120 --> 00:08:12,560
and using exclusively the standard lab

165
00:08:09,280 --> 00:08:16,318
library and the go bindings for

166
00:08:12,560 --> 00:08:19,680
dq lite and with that program you

167
00:08:16,319 --> 00:08:21,039
actually get a distributed application

168
00:08:19,680 --> 00:08:24,840
with the distributed

169
00:08:21,039 --> 00:08:27,039
database and fault tolerance

170
00:08:24,840 --> 00:08:30,239
fulfillments

171
00:08:27,039 --> 00:08:33,120
so uh the case studies uh uh

172
00:08:30,240 --> 00:08:35,279
just uh just to to to make things uh you

173
00:08:33,120 --> 00:08:38,479
know a bit more interesting

174
00:08:35,279 --> 00:08:38,880
a medical device so one of the use cases

175
00:08:38,479 --> 00:08:42,399
i

176
00:08:38,880 --> 00:08:47,439
think dq-lite would have is with the

177
00:08:42,399 --> 00:08:50,560
devices iot you might want

178
00:08:47,440 --> 00:08:53,680
to to to to have redundancy in

179
00:08:50,560 --> 00:08:56,640
in your devices so in this case

180
00:08:53,680 --> 00:08:57,519
i picked a pulse oximeter which i i

181
00:08:56,640 --> 00:09:00,720
didn't know

182
00:08:57,519 --> 00:09:02,800
about before so for for those of you

183
00:09:00,720 --> 00:09:06,560
that didn't don't know as well

184
00:09:02,800 --> 00:09:09,839
uh it's a device to measure

185
00:09:06,560 --> 00:09:10,160
the oxygen saturation in in your blood

186
00:09:09,839 --> 00:09:13,200
so

187
00:09:10,160 --> 00:09:15,439
how much oxygen there is in your blood

188
00:09:13,200 --> 00:09:16,320
i don't know much about details almost

189
00:09:15,440 --> 00:09:19,519
anything but

190
00:09:16,320 --> 00:09:22,720
for for the curious uh it works

191
00:09:19,519 --> 00:09:26,000
uh with with with the lead uh it

192
00:09:22,720 --> 00:09:26,720
emits light through your your body at

193
00:09:26,000 --> 00:09:30,399
different

194
00:09:26,720 --> 00:09:33,920
wavelengths and since the

195
00:09:30,399 --> 00:09:36,800
hemoglobin in your blood

196
00:09:33,920 --> 00:09:37,199
has absorbs light differently depending

197
00:09:36,800 --> 00:09:40,880
uh

198
00:09:37,200 --> 00:09:42,480
on whether it's bound to oxygen or not

199
00:09:40,880 --> 00:09:45,680
the light will be as absorbed

200
00:09:42,480 --> 00:09:48,160
differently and there is um

201
00:09:45,680 --> 00:09:48,719
another another component at the other

202
00:09:48,160 --> 00:09:51,920
end

203
00:09:48,720 --> 00:09:54,080
light a dude that uh

204
00:09:51,920 --> 00:09:56,240
essentially reads the amount of light

205
00:09:54,080 --> 00:09:58,720
that was uh

206
00:09:56,240 --> 00:09:59,760
that that passed through so you you can

207
00:09:58,720 --> 00:10:02,880
uh

208
00:09:59,760 --> 00:10:06,399
uh you can deduce the the amount of

209
00:10:02,880 --> 00:10:09,279
of oxygen in the in the

210
00:10:06,399 --> 00:10:09,279
bound to amalgam

211
00:10:09,839 --> 00:10:14,480
the the algorithm will be very simple

212
00:10:14,560 --> 00:10:21,199
so we want to measure uh

213
00:10:18,480 --> 00:10:22,720
the to perform this measurement at the

214
00:10:21,200 --> 00:10:26,320
at regular intervals

215
00:10:22,720 --> 00:10:30,320
so we keep an history of um

216
00:10:26,320 --> 00:10:31,040
of the percentage of oxygen in in your

217
00:10:30,320 --> 00:10:34,320
blood

218
00:10:31,040 --> 00:10:35,760
across across the time and we want to

219
00:10:34,320 --> 00:10:38,880
expose an api

220
00:10:35,760 --> 00:10:42,000
so that we can we can inspect

221
00:10:38,880 --> 00:10:46,800
the average uh i don't know in the last

222
00:10:42,000 --> 00:10:50,000
five minutes or one hour or whatever

223
00:10:46,800 --> 00:10:52,560
uh the function to measure uh

224
00:10:50,000 --> 00:10:53,519
oxygen saturation is just a mock-up

225
00:10:52,560 --> 00:10:56,640
thing so

226
00:10:53,519 --> 00:10:59,680
we imagine we have this fancy hardware

227
00:10:56,640 --> 00:11:02,079
that does what i described and

228
00:10:59,680 --> 00:11:03,120
so it just returns a random value

229
00:11:02,079 --> 00:11:06,719
between 95

230
00:11:03,120 --> 00:11:10,160
and 100 which is more or less

231
00:11:06,720 --> 00:11:13,519
the usual value that that you find

232
00:11:10,160 --> 00:11:16,079
in your body this is the function

233
00:11:13,519 --> 00:11:17,120
that we will use in the program we

234
00:11:16,079 --> 00:11:20,640
initialize the

235
00:11:17,120 --> 00:11:23,120
the database uh this for those of you

236
00:11:20,640 --> 00:11:25,439
familiar with uh with go but

237
00:11:23,120 --> 00:11:26,839
it's the same with the other bindings it

238
00:11:25,440 --> 00:11:30,000
just creates

239
00:11:26,839 --> 00:11:33,279
a table where we will store

240
00:11:30,000 --> 00:11:35,519
uh the the the measurement uh

241
00:11:33,279 --> 00:11:37,519
along with the with the timestamp where

242
00:11:35,519 --> 00:11:42,079
when the the measurement

243
00:11:37,519 --> 00:11:44,800
was made and and that's it and we hope

244
00:11:42,079 --> 00:11:46,800
as i said uh sqlite is is very simple

245
00:11:44,800 --> 00:11:50,000
you just have to open

246
00:11:46,800 --> 00:11:50,560
uh the database as you would open a file

247
00:11:50,000 --> 00:11:53,680
and and

248
00:11:50,560 --> 00:11:55,119
and that's it so this part is probably

249
00:11:53,680 --> 00:11:59,760
very familiar

250
00:11:55,120 --> 00:11:59,760
to the sqlite users among you

251
00:11:59,920 --> 00:12:07,279
then we have of course to to save

252
00:12:03,279 --> 00:12:10,959
our measurements so we have this persist

253
00:12:07,279 --> 00:12:13,439
saturation function and we

254
00:12:10,959 --> 00:12:14,719
just just perform an insert a simple

255
00:12:13,440 --> 00:12:18,800
insert

256
00:12:14,720 --> 00:12:22,320
uh of the of the value that that we read

257
00:12:18,800 --> 00:12:24,160
and since the the the schema has a

258
00:12:22,320 --> 00:12:26,320
default current timestamp the the

259
00:12:24,160 --> 00:12:29,600
timestamp will be

260
00:12:26,320 --> 00:12:32,079
saved automatically

261
00:12:29,600 --> 00:12:33,040
and finally the last piece essentially

262
00:12:32,079 --> 00:12:36,638
of the of the mode

263
00:12:33,040 --> 00:12:39,199
of this little toy application is

264
00:12:36,639 --> 00:12:41,680
to retrieve the average saturation and

265
00:12:39,200 --> 00:12:45,600
we just make a select query

266
00:12:41,680 --> 00:12:50,319
uh taking the average over

267
00:12:45,600 --> 00:12:53,360
the last number of minutes or seconds

268
00:12:50,320 --> 00:12:54,160
or hours that's uh that that will be

269
00:12:53,360 --> 00:12:57,519
part of the

270
00:12:54,160 --> 00:13:00,800
of the query of the user

271
00:12:57,519 --> 00:13:01,920
and that's basically it you can put it

272
00:13:00,800 --> 00:13:05,599
all together

273
00:13:01,920 --> 00:13:09,439
uh your main function will

274
00:13:05,600 --> 00:13:11,120
initialize the database it starts a go

275
00:13:09,440 --> 00:13:13,360
routine

276
00:13:11,120 --> 00:13:15,279
for those of you that are not familiar

277
00:13:13,360 --> 00:13:18,240
with go

278
00:13:15,279 --> 00:13:18,959
go teams are you can think about that as

279
00:13:18,240 --> 00:13:20,880
a

280
00:13:18,959 --> 00:13:24,160
thread of computations that go on in

281
00:13:20,880 --> 00:13:28,000
parallel with the rest of the program so

282
00:13:24,160 --> 00:13:28,319
this is an infinite for loop that slips

283
00:13:28,000 --> 00:13:32,560
for

284
00:13:28,320 --> 00:13:35,680
for some seconds and then

285
00:13:32,560 --> 00:13:36,800
makes a new measurement and saves it to

286
00:13:35,680 --> 00:13:41,599
the database to the

287
00:13:36,800 --> 00:13:44,399
to the local database and then we expose

288
00:13:41,600 --> 00:13:45,519
the the the service through through to

289
00:13:44,399 --> 00:13:48,800
the web

290
00:13:45,519 --> 00:13:52,959
with with an http

291
00:13:48,800 --> 00:13:55,439
handler which just takes uh the tail

292
00:13:52,959 --> 00:13:56,319
uh the tail parameter which is a how

293
00:13:55,440 --> 00:14:00,000
many

294
00:13:56,320 --> 00:14:03,519
minutes or seconds you want to

295
00:14:00,000 --> 00:14:07,199
average uh against and then it returns

296
00:14:03,519 --> 00:14:10,320
the average in in in that uh

297
00:14:07,199 --> 00:14:13,439
window of of time so that that's

298
00:14:10,320 --> 00:14:14,079
everything i you you need to do for for

299
00:14:13,440 --> 00:14:17,519
this

300
00:14:14,079 --> 00:14:20,719
thai implementation

301
00:14:17,519 --> 00:14:25,920
we can see it in action

302
00:14:20,720 --> 00:14:25,920
i can build the program

303
00:14:28,839 --> 00:14:33,600
um

304
00:14:30,320 --> 00:14:34,079
so this this is uh uh the tags lipstick

305
00:14:33,600 --> 00:14:37,600
light

306
00:14:34,079 --> 00:14:38,239
uh um parameter for those of you who

307
00:14:37,600 --> 00:14:42,079
know about

308
00:14:38,240 --> 00:14:44,240
go is needed because the bindings

309
00:14:42,079 --> 00:14:45,120
uh it's a way to tell the bindings

310
00:14:44,240 --> 00:14:49,040
please use

311
00:14:45,120 --> 00:14:51,519
the system uh shared library object

312
00:14:49,040 --> 00:14:52,719
instead of compiling the world thing

313
00:14:51,519 --> 00:14:54,720
into your

314
00:14:52,720 --> 00:14:56,560
uh executable so it's a it's a bit

315
00:14:54,720 --> 00:15:00,800
faster

316
00:14:56,560 --> 00:15:05,760
and i can then start the program

317
00:15:00,800 --> 00:15:05,760
and if i perform a query

318
00:15:06,720 --> 00:15:14,880
uh asking for for example the last

319
00:15:11,440 --> 00:15:18,560
five minutes of uh of value i

320
00:15:14,880 --> 00:15:22,399
i i get average back this will be

321
00:15:18,560 --> 00:15:26,719
refreshed uh every

322
00:15:22,399 --> 00:15:29,920
every 30 seconds or whatever and so

323
00:15:26,720 --> 00:15:32,720
and all the data is saved locally as you

324
00:15:29,920 --> 00:15:32,719
might expect

325
00:15:36,079 --> 00:15:39,439
so we have the history of mana of

326
00:15:38,560 --> 00:15:43,599
measurements

327
00:15:39,440 --> 00:15:43,600
locally in in your node

328
00:15:45,199 --> 00:15:52,160
so as i mentioned before this is

329
00:15:48,240 --> 00:15:53,440
simple and nice but uh in in a real

330
00:15:52,160 --> 00:15:56,880
world the imaginary

331
00:15:53,440 --> 00:16:00,880
real world situation what happens

332
00:15:56,880 --> 00:16:04,320
uh if the the underlying storage media

333
00:16:00,880 --> 00:16:06,639
fails and so you you don't have access

334
00:16:04,320 --> 00:16:08,079
anymore to your data and maybe the the

335
00:16:06,639 --> 00:16:10,240
there are critical

336
00:16:08,079 --> 00:16:11,920
for for for assessing the health of the

337
00:16:10,240 --> 00:16:15,360
patient or whatever

338
00:16:11,920 --> 00:16:17,759
or if you uh need to do

339
00:16:15,360 --> 00:16:18,880
some some maintenance over your your

340
00:16:17,759 --> 00:16:20,639
devices and

341
00:16:18,880 --> 00:16:23,439
you need to replace it but you don't

342
00:16:20,639 --> 00:16:24,880
want to interrupt the the monitoring or

343
00:16:23,440 --> 00:16:28,160
stuff like that

344
00:16:24,880 --> 00:16:29,920
or another thing could be that the the

345
00:16:28,160 --> 00:16:31,199
hardware that that performs a

346
00:16:29,920 --> 00:16:33,680
measurement

347
00:16:31,199 --> 00:16:34,959
uh has some issues perhaps it's

348
00:16:33,680 --> 00:16:38,239
inaccurate

349
00:16:34,959 --> 00:16:39,279
maybe even in small ways so you may want

350
00:16:38,240 --> 00:16:42,880
to perform

351
00:16:39,279 --> 00:16:43,439
the measurements uh several times using

352
00:16:42,880 --> 00:16:45,600
several

353
00:16:43,440 --> 00:16:46,880
instances of the hardware and and may

354
00:16:45,600 --> 00:16:49,680
and

355
00:16:46,880 --> 00:16:50,079
average the the results to to to reduce

356
00:16:49,680 --> 00:16:54,959
the

357
00:16:50,079 --> 00:16:59,040
the the error in case one of them

358
00:16:54,959 --> 00:17:00,079
is not uh accurate uh so in these cases

359
00:16:59,040 --> 00:17:05,119
you want uh

360
00:17:00,079 --> 00:17:08,799
of course a cluster of of devices and

361
00:17:05,119 --> 00:17:12,079
that's a good use case for uh dqlite

362
00:17:08,799 --> 00:17:16,000
so you would run uh just the decolite

363
00:17:12,079 --> 00:17:18,799
application and for example three

364
00:17:16,000 --> 00:17:21,039
instances of your devices three pulse

365
00:17:18,799 --> 00:17:24,079
oximeters

366
00:17:21,039 --> 00:17:25,679
each oximeter would independently make

367
00:17:24,079 --> 00:17:29,600
the measurement

368
00:17:25,679 --> 00:17:33,919
it would save the measurement in the

369
00:17:29,600 --> 00:17:37,678
distributed database and

370
00:17:33,919 --> 00:17:40,400
yeah even if one of the of them dies

371
00:17:37,679 --> 00:17:41,840
it's still good because the otherwise

372
00:17:40,400 --> 00:17:45,039
the other

373
00:17:41,840 --> 00:17:48,559
have replicated data and can still

374
00:17:45,039 --> 00:17:52,480
serve your query

375
00:17:48,559 --> 00:17:57,440
so the changes to the code that

376
00:17:52,480 --> 00:18:00,799
i just showed to you are minimal

377
00:17:57,440 --> 00:18:03,840
one thing you need to do in your main

378
00:18:00,799 --> 00:18:07,918
function is to assign

379
00:18:03,840 --> 00:18:10,799
an identity to each of the the instances

380
00:18:07,919 --> 00:18:13,120
of your application running in the

381
00:18:10,799 --> 00:18:16,160
cluster

382
00:18:13,120 --> 00:18:16,879
an id a numerical id which needs to be

383
00:18:16,160 --> 00:18:20,000
unique for

384
00:18:16,880 --> 00:18:23,880
for each node this is basically used by

385
00:18:20,000 --> 00:18:25,679
the underlying raft engine

386
00:18:23,880 --> 00:18:29,840
[Music]

387
00:18:25,679 --> 00:18:31,820
very simply put to to to see

388
00:18:29,840 --> 00:18:33,199
which nodes have

389
00:18:31,820 --> 00:18:36,480
[Music]

390
00:18:33,200 --> 00:18:36,480
replicated which data

391
00:18:36,640 --> 00:18:40,480
so just just pass an id to to your main

392
00:18:39,840 --> 00:18:43,918
function

393
00:18:40,480 --> 00:18:48,160
and we will pass it to the

394
00:18:43,919 --> 00:18:51,840
function that initializes the database

395
00:18:48,160 --> 00:18:54,640
in turn the function that initializes

396
00:18:51,840 --> 00:18:54,639
the database

397
00:18:54,880 --> 00:19:01,679
will need not just to to connect to

398
00:18:58,000 --> 00:19:04,480
your your local sqlite instead

399
00:19:01,679 --> 00:19:06,880
it needs to start the dqlite engine as i

400
00:19:04,480 --> 00:19:10,000
mentioned before

401
00:19:06,880 --> 00:19:12,720
there is some networking going on and

402
00:19:10,000 --> 00:19:13,679
the dq-lite engine running in your

403
00:19:12,720 --> 00:19:16,480
process

404
00:19:13,679 --> 00:19:19,200
in your application process is the one

405
00:19:16,480 --> 00:19:21,440
which will be in charge of this

406
00:19:19,200 --> 00:19:24,080
network and which is completely

407
00:19:21,440 --> 00:19:26,640
transparent to to your application

408
00:19:24,080 --> 00:19:29,360
so the start engine function which which

409
00:19:26,640 --> 00:19:32,880
i will show you in the next slide

410
00:19:29,360 --> 00:19:33,918
will do that there is another function

411
00:19:32,880 --> 00:19:38,720
called the

412
00:19:33,919 --> 00:19:40,080
join cluster you need to to tell dqlite

413
00:19:38,720 --> 00:19:44,080
essentially

414
00:19:40,080 --> 00:19:47,120
which nodes are part of your cluster so

415
00:19:44,080 --> 00:19:49,280
this will just be essentially uh the

416
00:19:47,120 --> 00:19:51,039
easiest way to do it

417
00:19:49,280 --> 00:19:52,879
we could talk about membership

418
00:19:51,039 --> 00:19:56,160
management later on but

419
00:19:52,880 --> 00:19:59,360
in this case uh each node essentially

420
00:19:56,160 --> 00:20:00,880
tries to join the node if if if it has

421
00:19:59,360 --> 00:20:04,158
already joined in the passes

422
00:20:00,880 --> 00:20:07,200
it's just a knob and the

423
00:20:04,159 --> 00:20:07,840
last thing the third one is to register

424
00:20:07,200 --> 00:20:11,360
the driver

425
00:20:07,840 --> 00:20:15,520
this is also a golang specific

426
00:20:11,360 --> 00:20:19,600
thing so for those of you familiar

427
00:20:15,520 --> 00:20:23,600
go has a standard library package called

428
00:20:19,600 --> 00:20:23,600
sql and you can

429
00:20:23,840 --> 00:20:30,959
register different drivers for different

430
00:20:27,280 --> 00:20:33,678
database backends so in this case

431
00:20:30,960 --> 00:20:34,960
we want to register the dqlite driver

432
00:20:33,679 --> 00:20:38,400
and we need to do it

433
00:20:34,960 --> 00:20:41,840
to do it explicitly because

434
00:20:38,400 --> 00:20:45,120
some other libraries they just register

435
00:20:41,840 --> 00:20:48,240
their driver transparently for

436
00:20:45,120 --> 00:20:49,520
for example sqlite there is a single

437
00:20:48,240 --> 00:20:51,919
instance of the

438
00:20:49,520 --> 00:20:53,120
driver object which can be shared but in

439
00:20:51,919 --> 00:20:55,200
in our case

440
00:20:53,120 --> 00:20:56,799
you need to instantiate the deco light

441
00:20:55,200 --> 00:20:58,159
instance so you need the regis to

442
00:20:56,799 --> 00:21:00,639
register drive okay

443
00:20:58,159 --> 00:21:03,679
this is muscle implementation detail of

444
00:21:00,640 --> 00:21:06,559
of column

445
00:21:03,679 --> 00:21:07,600
yeah okay you start the engine so to

446
00:21:06,559 --> 00:21:10,639
start the decollete

447
00:21:07,600 --> 00:21:11,520
engine you need a couple of things as i

448
00:21:10,640 --> 00:21:14,880
mentioned you need

449
00:21:11,520 --> 00:21:17,200
the id that you will use for the node

450
00:21:14,880 --> 00:21:18,240
you need a network address in this case

451
00:21:17,200 --> 00:21:20,799
we just

452
00:21:18,240 --> 00:21:21,520
use a network address which is derived

453
00:21:20,799 --> 00:21:25,039
from the

454
00:21:21,520 --> 00:21:30,720
the id we just append the number uh

455
00:21:25,039 --> 00:21:34,799
to the to the to the port um

456
00:21:30,720 --> 00:21:37,280
and you need a directory where

457
00:21:34,799 --> 00:21:39,760
you will save the the data so the data

458
00:21:37,280 --> 00:21:42,960
will not be saved in a regular

459
00:21:39,760 --> 00:21:45,840
uh sqlite data database file it it will

460
00:21:42,960 --> 00:21:45,840
be saved

461
00:21:46,559 --> 00:21:53,200
in the rafter log more about this

462
00:21:50,640 --> 00:21:54,960
later then there is there are a couple

463
00:21:53,200 --> 00:21:58,080
of options that that you

464
00:21:54,960 --> 00:21:59,200
probably want to set one is a band

465
00:21:58,080 --> 00:22:01,520
address

466
00:21:59,200 --> 00:22:03,440
which is what i said this will tell the

467
00:22:01,520 --> 00:22:07,280
dqlite engine

468
00:22:03,440 --> 00:22:10,720
please start listening to this

469
00:22:07,280 --> 00:22:13,200
network address and

470
00:22:10,720 --> 00:22:14,240
all the traffic between nodes will will

471
00:22:13,200 --> 00:22:18,559
will go through

472
00:22:14,240 --> 00:22:20,960
through that that socket

473
00:22:18,559 --> 00:22:23,600
and you might also want to specify the

474
00:22:20,960 --> 00:22:26,960
network latency

475
00:22:23,600 --> 00:22:27,600
we can we can delve into this later as

476
00:22:26,960 --> 00:22:31,039
well

477
00:22:27,600 --> 00:22:34,719
essentially this should be

478
00:22:31,039 --> 00:22:36,640
uh the latency the one-way latency

479
00:22:34,720 --> 00:22:38,159
between your nodes for example if you

480
00:22:36,640 --> 00:22:40,400
know i specify

481
00:22:38,159 --> 00:22:42,080
10 milliseconds here because i will be

482
00:22:40,400 --> 00:22:44,880
running on localhost

483
00:22:42,080 --> 00:22:45,678
which is fast anyway depending on your

484
00:22:44,880 --> 00:22:49,440
network

485
00:22:45,679 --> 00:22:52,000
you should you should specify

486
00:22:49,440 --> 00:22:52,480
more or less how how much it takes to

487
00:22:52,000 --> 00:22:55,360
send

488
00:22:52,480 --> 00:22:59,039
one packet from one node to another this

489
00:22:55,360 --> 00:23:02,399
is used internally by raft to decide

490
00:22:59,039 --> 00:23:03,280
when it should consider the current

491
00:23:02,400 --> 00:23:08,080
leader dead

492
00:23:03,280 --> 00:23:11,600
so another leader will step in

493
00:23:08,080 --> 00:23:14,879
and that's it that's it as i mentioned

494
00:23:11,600 --> 00:23:15,600
you have to join the cluster uh you can

495
00:23:14,880 --> 00:23:18,960
use the

496
00:23:15,600 --> 00:23:22,879
dqlite go client to tell the

497
00:23:18,960 --> 00:23:23,760
the engine please join the node we don't

498
00:23:22,880 --> 00:23:26,480
join the node

499
00:23:23,760 --> 00:23:27,200
if the id is one because node one will

500
00:23:26,480 --> 00:23:29,360
be

501
00:23:27,200 --> 00:23:31,280
the first node of the cluster the

502
00:23:29,360 --> 00:23:32,320
classroom will have just one node at the

503
00:23:31,280 --> 00:23:35,760
beginning so

504
00:23:32,320 --> 00:23:36,960
you don't need to join it and the other

505
00:23:35,760 --> 00:23:39,360
notes will just uh

506
00:23:36,960 --> 00:23:41,360
try to join and if uh they failed they

507
00:23:39,360 --> 00:23:44,879
just move on

508
00:23:41,360 --> 00:23:47,360
assuming that uh uh they joined it

509
00:23:44,880 --> 00:23:48,880
john before we we leave out error

510
00:23:47,360 --> 00:23:52,639
handling and stuff like that for

511
00:23:48,880 --> 00:23:54,400
for this demo uh we registered the

512
00:23:52,640 --> 00:23:58,640
driver okay this

513
00:23:54,400 --> 00:23:58,640
is a an important part

514
00:24:00,240 --> 00:24:05,520
your the golang dqlite client will have

515
00:24:04,480 --> 00:24:09,039
to know

516
00:24:05,520 --> 00:24:11,279
uh the addresses of the nodes in your

517
00:24:09,039 --> 00:24:14,158
cluster so in case

518
00:24:11,279 --> 00:24:15,919
one node dies delete the current leader

519
00:24:14,159 --> 00:24:19,039
dies it will connect to another

520
00:24:15,919 --> 00:24:22,799
node in this case we just

521
00:24:19,039 --> 00:24:25,120
hard code the list but of course

522
00:24:22,799 --> 00:24:26,480
you can organize your code as you want

523
00:24:25,120 --> 00:24:29,760
to

524
00:24:26,480 --> 00:24:33,279
to know the current list of nodes and

525
00:24:29,760 --> 00:24:35,919
you can wire it when when you build

526
00:24:33,279 --> 00:24:35,919
the client

527
00:24:37,360 --> 00:24:40,959
okay the the total program as i

528
00:24:40,000 --> 00:24:44,000
mentioned

529
00:24:40,960 --> 00:24:47,039
is a 132 lines of

530
00:24:44,000 --> 00:24:50,960
of go code and it has

531
00:24:47,039 --> 00:24:54,080
everything so i will show

532
00:24:50,960 --> 00:24:55,120
how it works so instead of compiling

533
00:24:54,080 --> 00:24:58,840
this

534
00:24:55,120 --> 00:25:01,840
program i i will compile the other one

535
00:24:58,840 --> 00:25:01,840
and

536
00:25:04,159 --> 00:25:11,600
as you see the final binary is

537
00:25:07,919 --> 00:25:11,600
less than 10 megabytes

538
00:25:12,840 --> 00:25:19,039
um

539
00:25:15,520 --> 00:25:20,559
ah okay anyway this uh these are the

540
00:25:19,039 --> 00:25:23,600
shared libraries uh

541
00:25:20,559 --> 00:25:24,320
uh it's uh it's length two you can

542
00:25:23,600 --> 00:25:27,520
notice

543
00:25:24,320 --> 00:25:31,200
sqlite of course uh

544
00:25:27,520 --> 00:25:33,840
and dqlite and there are another

545
00:25:31,200 --> 00:25:34,400
few libraries which are the dependencies

546
00:25:33,840 --> 00:25:38,080
of

547
00:25:34,400 --> 00:25:41,440
of dqlite which are libuvi

548
00:25:38,080 --> 00:25:45,279
which is uh the interloop

549
00:25:41,440 --> 00:25:47,919
the same event loop loop used by node.js

550
00:25:45,279 --> 00:25:49,120
so internally dukelite is a single

551
00:25:47,919 --> 00:25:53,520
thread

552
00:25:49,120 --> 00:25:57,199
a synchronous loop event loop

553
00:25:53,520 --> 00:25:59,520
and it uses libiv just for for

554
00:25:57,200 --> 00:26:00,960
footer proof portability and it's also a

555
00:25:59,520 --> 00:26:03,760
very good library

556
00:26:00,960 --> 00:26:04,559
but it's a very libby it's a very thin

557
00:26:03,760 --> 00:26:08,240
roper

558
00:26:04,559 --> 00:26:11,440
under around ipo on linux

559
00:26:08,240 --> 00:26:13,760
then there is a lipco which is a cool

560
00:26:11,440 --> 00:26:17,039
routine library

561
00:26:13,760 --> 00:26:22,080
if you're curious why we we use this

562
00:26:17,039 --> 00:26:22,080
it's a one file long library

563
00:26:22,320 --> 00:26:26,080
i didn't support for cool things and see

564
00:26:24,320 --> 00:26:28,000
if you're curious uh

565
00:26:26,080 --> 00:26:29,199
i can explain why but it's not

566
00:26:28,000 --> 00:26:33,440
particularly

567
00:26:29,200 --> 00:26:36,000
important for for now and libraft

568
00:26:33,440 --> 00:26:36,880
which is the rough library that we we

569
00:26:36,000 --> 00:26:39,679
wrote

570
00:26:36,880 --> 00:26:41,679
as part of the qlite for for

571
00:26:39,679 --> 00:26:46,000
implementing raft

572
00:26:41,679 --> 00:26:49,200
okay we can start

573
00:26:46,000 --> 00:26:52,240
the first node okay

574
00:26:49,200 --> 00:26:55,600
and we can query it

575
00:26:52,240 --> 00:26:55,600
like we did

576
00:26:56,400 --> 00:26:59,360
with the other one

577
00:27:01,200 --> 00:27:04,840
and it will return you the the current

578
00:27:04,080 --> 00:27:09,360
uh

579
00:27:04,840 --> 00:27:13,360
average of the oxygen saturation

580
00:27:09,360 --> 00:27:15,520
then we can start another node

581
00:27:13,360 --> 00:27:17,279
which as i showed you before will

582
00:27:15,520 --> 00:27:19,600
automatically join

583
00:27:17,279 --> 00:27:21,200
that cluster that that was created by

584
00:27:19,600 --> 00:27:24,719
the first node

585
00:27:21,200 --> 00:27:28,320
and a third node

586
00:27:24,720 --> 00:27:35,840
as well so now all the nodes

587
00:27:28,320 --> 00:27:35,840
are online

588
00:27:38,320 --> 00:27:42,158
and i can query them

589
00:27:43,520 --> 00:27:46,879
so all of them will return the same

590
00:27:45,919 --> 00:27:51,120
value

591
00:27:46,880 --> 00:27:55,200
because the the database is is shared

592
00:27:51,120 --> 00:27:58,639
so all the nodes see the exact same view

593
00:27:55,200 --> 00:28:02,559
of the database from their point of view

594
00:27:58,640 --> 00:28:04,720
it's as if they were talking to a local

595
00:28:02,559 --> 00:28:06,158
database all the consistency proper

596
00:28:04,720 --> 00:28:10,320
properties that you have

597
00:28:06,159 --> 00:28:14,159
with the local database are maintained

598
00:28:10,320 --> 00:28:17,600
now if i kill

599
00:28:14,159 --> 00:28:19,679
so in this case uh the

600
00:28:17,600 --> 00:28:21,439
leader of the cluster will be the first

601
00:28:19,679 --> 00:28:24,320
node because uh

602
00:28:21,440 --> 00:28:24,960
nothing this disruptive has happened so

603
00:28:24,320 --> 00:28:28,000
far

604
00:28:24,960 --> 00:28:29,279
so the first node uh noticed that it was

605
00:28:28,000 --> 00:28:32,000
the only one

606
00:28:29,279 --> 00:28:32,880
so it became the leader since it was the

607
00:28:32,000 --> 00:28:34,480
only one

608
00:28:32,880 --> 00:28:36,559
the other two notes when they joined

609
00:28:34,480 --> 00:28:38,080
there was already a stable leader they

610
00:28:36,559 --> 00:28:41,600
didn't

611
00:28:38,080 --> 00:28:46,080
need to do anything so if i

612
00:28:41,600 --> 00:28:51,918
uh killed the the current leader

613
00:28:46,080 --> 00:28:59,120
oh sorry okay anyway it terminated

614
00:28:51,919 --> 00:29:01,840
uh so what did i do

615
00:28:59,120 --> 00:29:01,840
what's up job

616
00:29:02,559 --> 00:29:05,039
say it again

617
00:29:05,600 --> 00:29:08,959
ah so it was true because i didn't i

618
00:29:07,600 --> 00:29:12,240
didn't kill the first one okay

619
00:29:08,960 --> 00:29:15,440
thank you you can see that

620
00:29:12,240 --> 00:29:19,200
uh the first note doesn't

621
00:29:15,440 --> 00:29:22,159
doesn't uh um reply anymore

622
00:29:19,200 --> 00:29:23,440
but the other two do since they elected

623
00:29:22,159 --> 00:29:25,520
the new leader

624
00:29:23,440 --> 00:29:26,640
they already had a copy of the wall

625
00:29:25,520 --> 00:29:30,399
thing

626
00:29:26,640 --> 00:29:32,640
so it's fine if

627
00:29:30,399 --> 00:29:32,639
the

628
00:29:33,919 --> 00:29:38,880
the leader actually the older node

629
00:29:36,240 --> 00:29:41,760
actually comes back

630
00:29:38,880 --> 00:29:42,720
it will immediately join the cluster the

631
00:29:41,760 --> 00:29:45,360
data

632
00:29:42,720 --> 00:29:46,159
the it if you it will connect to the the

633
00:29:45,360 --> 00:29:48,639
current leader

634
00:29:46,159 --> 00:29:49,200
whatever was elected and it will have

635
00:29:48,640 --> 00:29:51,120
immediate

636
00:29:49,200 --> 00:29:53,440
access to to the current state of the

637
00:29:51,120 --> 00:29:54,799
database and in the background it will

638
00:29:53,440 --> 00:29:58,159
start to

639
00:29:54,799 --> 00:30:02,799
replicate what was uh missing one

640
00:29:58,159 --> 00:30:02,799
we can do the same exercise with uh

641
00:30:03,039 --> 00:30:10,240
with another node and of course

642
00:30:06,880 --> 00:30:13,360
it will fail but

643
00:30:10,240 --> 00:30:13,360
if we start it

644
00:30:13,440 --> 00:30:20,640
it will be good uh yeah that's

645
00:30:17,360 --> 00:30:25,120
that's it for for the demo

646
00:30:20,640 --> 00:30:28,320
so we'll just pause for for some time

647
00:30:25,120 --> 00:30:30,879
before i delve into more details if you

648
00:30:28,320 --> 00:30:36,720
have questions already we can decide

649
00:30:30,880 --> 00:30:39,200
in which directions to go

650
00:30:36,720 --> 00:30:39,200
say it again

651
00:30:40,240 --> 00:30:43,440
reads don't go to con through

652
00:30:42,559 --> 00:30:45,840
consistency

653
00:30:43,440 --> 00:30:48,799
so you're asking what is the consistency

654
00:30:45,840 --> 00:30:48,799
model essentially

655
00:30:48,840 --> 00:30:55,760
um okay

656
00:30:51,760 --> 00:30:56,240
so a cup theorem i'm not sure how many

657
00:30:55,760 --> 00:31:00,240
of you

658
00:30:56,240 --> 00:31:03,120
are familiar with it but put it simply

659
00:31:00,240 --> 00:31:04,720
in any distributed system you have to

660
00:31:03,120 --> 00:31:07,840
make some choices

661
00:31:04,720 --> 00:31:07,840
around consistency

662
00:31:08,000 --> 00:31:14,720
since dq light is based on raft

663
00:31:11,039 --> 00:31:18,240
the choices that that are made

664
00:31:14,720 --> 00:31:21,279
are essentially consistency

665
00:31:18,240 --> 00:31:24,880
and tolerance to to partition

666
00:31:21,279 --> 00:31:29,039
failures but consistency is there

667
00:31:24,880 --> 00:31:29,039
that means in raft

668
00:31:29,279 --> 00:31:36,080
reads are consistent if you make a read

669
00:31:32,799 --> 00:31:36,559
it will read the last the value of the

670
00:31:36,080 --> 00:31:41,039
last

671
00:31:36,559 --> 00:31:44,639
last write that means in terms of

672
00:31:41,039 --> 00:31:47,120
sql if you have a transaction

673
00:31:44,640 --> 00:31:48,480
if you use the sql translations like we

674
00:31:47,120 --> 00:31:51,840
all know

675
00:31:48,480 --> 00:31:51,840
things will work as you expect

676
00:31:53,200 --> 00:31:59,919
so there's a acid semantics if you will

677
00:31:57,919 --> 00:32:01,600
because the reads are served by the

678
00:31:59,919 --> 00:32:04,240
leader this is probably

679
00:32:01,600 --> 00:32:05,439
the the point that should make you

680
00:32:04,240 --> 00:32:07,760
understand why

681
00:32:05,440 --> 00:32:09,919
the the reads are served by the the

682
00:32:07,760 --> 00:32:12,960
leader so they always have their

683
00:32:09,919 --> 00:32:16,559
most recent value

684
00:32:12,960 --> 00:32:20,000
um it's possible to have reads

685
00:32:16,559 --> 00:32:23,760
served by non-leader nodes so called

686
00:32:20,000 --> 00:32:23,760
follower nodes for scaling

687
00:32:23,919 --> 00:32:28,240
there there is a way to do it without

688
00:32:27,039 --> 00:32:30,879
sacrificing

689
00:32:28,240 --> 00:32:31,279
consistency so retaining exactly the

690
00:32:30,880 --> 00:32:34,320
same

691
00:32:31,279 --> 00:32:37,760
consistency property as acid if we

692
00:32:34,320 --> 00:32:38,480
if you will uh but it's not implemented

693
00:32:37,760 --> 00:32:41,600
yet in

694
00:32:38,480 --> 00:32:42,799
dqlight so for for now all rates are

695
00:32:41,600 --> 00:32:47,840
served by the

696
00:32:42,799 --> 00:32:47,840
leader does it answer the question yeah

697
00:32:47,919 --> 00:32:57,840
go ahead i don't have

698
00:32:51,039 --> 00:32:57,840
the microphones

699
00:32:59,600 --> 00:33:03,279
just can you dynamically change the

700
00:33:01,760 --> 00:33:03,679
number of notes in the cluster as well

701
00:33:03,279 --> 00:33:07,760
yes

702
00:33:03,679 --> 00:33:11,840
so let's see if

703
00:33:07,760 --> 00:33:11,840
we have something

704
00:33:15,679 --> 00:33:18,960
no i don't i don't have probably a slide

705
00:33:18,320 --> 00:33:22,240
for this

706
00:33:18,960 --> 00:33:24,399
but um yes you it's uh the the

707
00:33:22,240 --> 00:33:27,519
membership management and

708
00:33:24,399 --> 00:33:30,559
lately got

709
00:33:27,519 --> 00:33:32,080
quite sophisticated so as

710
00:33:30,559 --> 00:33:34,399
as you saw that the membership

711
00:33:32,080 --> 00:33:35,600
management in the demo is absolutely a

712
00:33:34,399 --> 00:33:37,600
toy

713
00:33:35,600 --> 00:33:39,600
but you can change membership

714
00:33:37,600 --> 00:33:43,120
dynamically

715
00:33:39,600 --> 00:33:46,799
you can say for example one example

716
00:33:43,120 --> 00:33:48,879
that we use in lexi i have 20 nodes in

717
00:33:46,799 --> 00:33:52,320
my cluster

718
00:33:48,880 --> 00:33:55,519
i want three of them to be voting nodes

719
00:33:52,320 --> 00:33:58,799
those are the ones that

720
00:33:55,519 --> 00:34:00,399
are critical for your data and you you

721
00:33:58,799 --> 00:34:02,720
will survive to the loss of

722
00:34:00,399 --> 00:34:04,639
one of those nodes or you can have five

723
00:34:02,720 --> 00:34:06,640
voting nodes if you want to survive the

724
00:34:04,640 --> 00:34:10,079
loss of two

725
00:34:06,640 --> 00:34:13,599
then you can specify the

726
00:34:10,079 --> 00:34:16,879
standby nodes which are nodes that

727
00:34:13,599 --> 00:34:19,200
do replicate the data

728
00:34:16,879 --> 00:34:21,359
do write data on disk but they don't

729
00:34:19,199 --> 00:34:25,199
participate in voting so they

730
00:34:21,359 --> 00:34:26,799
won't be bottlenecks as far as latency

731
00:34:25,199 --> 00:34:29,199
is concerned

732
00:34:26,800 --> 00:34:30,800
so you don't have to wait for them to

733
00:34:29,199 --> 00:34:33,359
complete their rights

734
00:34:30,800 --> 00:34:34,000
to reach the quorum that you need before

735
00:34:33,359 --> 00:34:36,560
you say okay

736
00:34:34,000 --> 00:34:39,199
this transaction is committed and then

737
00:34:36,560 --> 00:34:41,918
you can also have uh

738
00:34:39,199 --> 00:34:42,960
spare nodes which are just part of the

739
00:34:41,918 --> 00:34:46,719
cluster

740
00:34:42,960 --> 00:34:50,079
they they just sit there doing nothing

741
00:34:46,719 --> 00:34:53,279
they don't replicate data they don't uh

742
00:34:50,079 --> 00:34:54,000
participate in voting and there is an

743
00:34:53,280 --> 00:34:57,040
api

744
00:34:54,000 --> 00:35:00,880
to assign roles dynamically

745
00:34:57,040 --> 00:35:03,839
to all these nodes for example in lexd

746
00:35:00,880 --> 00:35:05,200
we have that code so for example when

747
00:35:03,839 --> 00:35:08,320
you shut down

748
00:35:05,200 --> 00:35:11,279
a node gracefully at least

749
00:35:08,320 --> 00:35:12,560
uh we transfer leadership to another

750
00:35:11,280 --> 00:35:16,480
node if

751
00:35:12,560 --> 00:35:19,359
the the node was the leader we

752
00:35:16,480 --> 00:35:20,079
elect a standby node which is a fast

753
00:35:19,359 --> 00:35:22,480
follower

754
00:35:20,079 --> 00:35:23,119
to be voting for example to replace the

755
00:35:22,480 --> 00:35:26,480
voters

756
00:35:23,119 --> 00:35:29,040
stuff like that so there are advanced uh

757
00:35:26,480 --> 00:35:29,680
membership management options that you

758
00:35:29,040 --> 00:35:31,839
can

759
00:35:29,680 --> 00:35:31,839
use

760
00:35:32,880 --> 00:35:38,160
okay uh i'm curious um the rough clocks

761
00:35:36,480 --> 00:35:39,200
themselves need to be transactional and

762
00:35:38,160 --> 00:35:42,000
i'm curious why

763
00:35:39,200 --> 00:35:44,399
you didn't use sqlite itself to uh sorry

764
00:35:42,000 --> 00:35:47,440
i i can't hear you

765
00:35:44,400 --> 00:35:49,119
logs themselves need to be transactional

766
00:35:47,440 --> 00:35:53,280
and i'm curious why you didn't use

767
00:35:49,119 --> 00:35:56,480
sqlite itself to persist the rough logs

768
00:35:53,280 --> 00:35:57,839
okay so the question is uh since the

769
00:35:56,480 --> 00:36:00,560
raft logs

770
00:35:57,839 --> 00:36:02,640
are transactional by themselves why

771
00:36:00,560 --> 00:36:05,839
didn't you use

772
00:36:02,640 --> 00:36:08,640
sqlite itself to store

773
00:36:05,839 --> 00:36:08,640
to store them

774
00:36:08,870 --> 00:36:14,880
[Music]

775
00:36:10,839 --> 00:36:18,560
so when answer is uh

776
00:36:14,880 --> 00:36:22,000
uh like

777
00:36:18,560 --> 00:36:25,119
the logs in in rafter are

778
00:36:22,000 --> 00:36:25,760
are a bit simpler a bit simpler data

779
00:36:25,119 --> 00:36:28,960
model

780
00:36:25,760 --> 00:36:32,000
than sql first

781
00:36:28,960 --> 00:36:36,160
and also a bit different uh

782
00:36:32,000 --> 00:36:40,000
the second reason is also performance

783
00:36:36,160 --> 00:36:42,399
so you want the two bottlenecks

784
00:36:40,000 --> 00:36:44,079
of raft are the network and the disk of

785
00:36:42,400 --> 00:36:47,119
course

786
00:36:44,079 --> 00:36:51,520
so everything you can do to minimize

787
00:36:47,119 --> 00:36:57,200
those uh paths those hot pads is good

788
00:36:51,520 --> 00:36:57,200
in dq light i probably have a slide for

789
00:37:06,839 --> 00:37:13,040
this

790
00:37:09,200 --> 00:37:15,759
yeah um in dq lite

791
00:37:13,040 --> 00:37:17,119
as i mentioned it's a single thread

792
00:37:15,760 --> 00:37:22,960
engine

793
00:37:17,119 --> 00:37:26,720
so it doesn't ever block

794
00:37:22,960 --> 00:37:30,480
to to do this ko it uses

795
00:37:26,720 --> 00:37:33,200
a not very well known kernel

796
00:37:30,480 --> 00:37:34,240
interface which is the asynchronous io

797
00:37:33,200 --> 00:37:37,520
interface

798
00:37:34,240 --> 00:37:39,759
the main system call involved here is

799
00:37:37,520 --> 00:37:42,000
io underscore submit for for those who

800
00:37:39,760 --> 00:37:45,599
knows and it doesn't block

801
00:37:42,000 --> 00:37:48,480
sqlite by default it blocks

802
00:37:45,599 --> 00:37:49,359
so for example if uh if if i have to

803
00:37:48,480 --> 00:37:52,320
write

804
00:37:49,359 --> 00:37:53,598
the commit to disk i have to block do do

805
00:37:52,320 --> 00:37:56,320
nothing else

806
00:37:53,599 --> 00:37:58,640
in the meantime there's network going on

807
00:37:56,320 --> 00:38:02,400
etc etc

808
00:37:58,640 --> 00:38:04,720
the choice of going single thread

809
00:38:02,400 --> 00:38:06,960
there are many reasons we we can go

810
00:38:04,720 --> 00:38:10,959
through them separately but i think this

811
00:38:06,960 --> 00:38:10,960
at least answers your question

812
00:38:13,520 --> 00:38:22,240
any other question okay

813
00:38:17,119 --> 00:38:22,240
uh so i have a few more details um

814
00:38:23,359 --> 00:38:30,640
uh one important thing is uh the

815
00:38:26,880 --> 00:38:32,079
i have a question ah okay i i i'm a bit

816
00:38:30,640 --> 00:38:36,480
curious about the need to

817
00:38:32,079 --> 00:38:39,680
use some external library like lib coral

818
00:38:36,480 --> 00:38:41,920
could you elaborate a bit about this

819
00:38:39,680 --> 00:38:42,960
uh sorry can you keep the microphone

820
00:38:41,920 --> 00:38:45,680
closer because

821
00:38:42,960 --> 00:38:46,240
could you elaborate a bit about the need

822
00:38:45,680 --> 00:38:49,359
for

823
00:38:46,240 --> 00:38:52,959
the use of lip color

824
00:38:49,359 --> 00:38:56,160
no the the libre is not lib curl

825
00:38:52,960 --> 00:39:01,040
it's a libuvim

826
00:38:56,160 --> 00:39:02,560
i think you mean this one ah libco anna

827
00:39:01,040 --> 00:39:06,000
sorry litko lipcon

828
00:39:02,560 --> 00:39:09,680
okay so

829
00:39:06,000 --> 00:39:13,040
lipco how many of you have

830
00:39:09,680 --> 00:39:16,240
are familiar with cool routines

831
00:39:13,040 --> 00:39:20,000
okay uh for those of you

832
00:39:16,240 --> 00:39:20,000
that are not familiar with it um

833
00:39:20,560 --> 00:39:28,320
in c there is no so a core routine

834
00:39:24,240 --> 00:39:33,680
is essentially a um

835
00:39:28,320 --> 00:39:36,320
a way to do concurrent uh computing

836
00:39:33,680 --> 00:39:36,960
in a single thread let's keep it simple

837
00:39:36,320 --> 00:39:40,880
so

838
00:39:36,960 --> 00:39:43,680
you have some non-blocking part of code

839
00:39:40,880 --> 00:39:45,520
it does its job until it can because at

840
00:39:43,680 --> 00:39:48,799
some point it hits some

841
00:39:45,520 --> 00:39:49,119
uh blocking a job to do network of your

842
00:39:48,800 --> 00:39:52,240
disk

843
00:39:49,119 --> 00:39:55,440
you then that function

844
00:39:52,240 --> 00:39:59,598
or that coroutine poses

845
00:39:55,440 --> 00:40:02,000
still executing the same cpu same thread

846
00:39:59,599 --> 00:40:02,960
and it passes control to another core

847
00:40:02,000 --> 00:40:06,000
routine

848
00:40:02,960 --> 00:40:10,319
same thread same cpu and

849
00:40:06,000 --> 00:40:10,800
and and the computation goes on so it's

850
00:40:10,319 --> 00:40:14,720
a way

851
00:40:10,800 --> 00:40:15,359
to it's a cool things are lightweight

852
00:40:14,720 --> 00:40:18,399
threads

853
00:40:15,359 --> 00:40:20,400
you you don't have to contact switch

854
00:40:18,400 --> 00:40:21,839
you don't have to pay that over they're

855
00:40:20,400 --> 00:40:26,319
really really really

856
00:40:21,839 --> 00:40:27,180
good for networking like a

857
00:40:26,319 --> 00:40:30,240
famous

858
00:40:27,180 --> 00:40:32,720
[Music]

859
00:40:30,240 --> 00:40:33,598
web engines are are based on on on this

860
00:40:32,720 --> 00:40:36,640
model like

861
00:40:33,599 --> 00:40:40,800
nginx aha proxy

862
00:40:36,640 --> 00:40:43,759
and stuff like that so in c there is no

863
00:40:40,800 --> 00:40:45,920
model for co routines you can't just

864
00:40:43,760 --> 00:40:48,640
stop in the middle of the function

865
00:40:45,920 --> 00:40:49,760
and start another function on another

866
00:40:48,640 --> 00:40:52,720
stack

867
00:40:49,760 --> 00:40:53,760
like like out of no blue out of the blue

868
00:40:52,720 --> 00:40:56,799
so

869
00:40:53,760 --> 00:41:00,400
libco uh is a way

870
00:40:56,800 --> 00:41:02,880
to say it has some black magic

871
00:41:00,400 --> 00:41:04,240
depending on on the architecture it will

872
00:41:02,880 --> 00:41:07,359
save

873
00:41:04,240 --> 00:41:09,118
the current state of all registers and

874
00:41:07,359 --> 00:41:12,400
stuff like that

875
00:41:09,119 --> 00:41:15,599
uh all that kind of black magic

876
00:41:12,400 --> 00:41:16,800
and it will transfer the the program

877
00:41:15,599 --> 00:41:19,359
flow to

878
00:41:16,800 --> 00:41:20,720
to another uh to to an entry point in

879
00:41:19,359 --> 00:41:23,440
another function

880
00:41:20,720 --> 00:41:25,919
why i need this this is related to the

881
00:41:23,440 --> 00:41:30,470
other question actually because

882
00:41:25,920 --> 00:41:31,599
sqlite is blocking so

883
00:41:30,470 --> 00:41:34,799
[Music]

884
00:41:31,599 --> 00:41:35,760
when i reach the point inside the sqlite

885
00:41:34,800 --> 00:41:38,319
code where

886
00:41:35,760 --> 00:41:40,319
i need to commit the transaction instead

887
00:41:38,319 --> 00:41:44,560
of writing to disk i have to

888
00:41:40,319 --> 00:41:46,880
ask raft to do a commit essentially

889
00:41:44,560 --> 00:41:49,200
and that part is a synchronous indica

890
00:41:46,880 --> 00:41:50,880
light nuclide is callback based

891
00:41:49,200 --> 00:41:54,319
asynchronous

892
00:41:50,880 --> 00:41:57,440
so there wasn't a way to stop sqlite

893
00:41:54,319 --> 00:42:01,200
there just hanging for this

894
00:41:57,440 --> 00:42:04,000
without using threads so i i had to

895
00:42:01,200 --> 00:42:06,240
to use the quartering trick to to do

896
00:42:04,000 --> 00:42:06,240
that

897
00:42:07,280 --> 00:42:11,760
i hope that answers the question okay

898
00:42:11,920 --> 00:42:19,119
yeah speaking of which

899
00:42:15,280 --> 00:42:21,920
the sqlite version that the qlite needs

900
00:42:19,119 --> 00:42:22,480
is not the upstream one it's a patched

901
00:42:21,920 --> 00:42:26,319
version

902
00:42:22,480 --> 00:42:26,319
for for the reason i just mentioned uh

903
00:42:26,400 --> 00:42:30,000
not sure how many of you are familiar

904
00:42:28,160 --> 00:42:33,040
with internal of of

905
00:42:30,000 --> 00:42:35,440
sqlite but when when when

906
00:42:33,040 --> 00:42:36,160
it comes to to to commit the transaction

907
00:42:35,440 --> 00:42:39,200
to disk

908
00:42:36,160 --> 00:42:40,000
of course it has an api for for right

909
00:42:39,200 --> 00:42:43,040
into the

910
00:42:40,000 --> 00:42:46,160
right ahead log i

911
00:42:43,040 --> 00:42:47,200
put some hooks in there essentially to

912
00:42:46,160 --> 00:42:49,839
to call

913
00:42:47,200 --> 00:42:50,879
some custom interface that you can

914
00:42:49,839 --> 00:42:53,040
specify

915
00:42:50,880 --> 00:42:54,160
in my case in my case it's the dc light

916
00:42:53,040 --> 00:42:57,359
interface

917
00:42:54,160 --> 00:42:58,640
so i can do all the magic so the patch

918
00:42:57,359 --> 00:43:02,799
is

919
00:42:58,640 --> 00:43:05,279
is very small it's not a big one for now

920
00:43:02,800 --> 00:43:06,800
and i've been maintaining it for a

921
00:43:05,280 --> 00:43:10,079
couple of years now

922
00:43:06,800 --> 00:43:10,880
uh updating it at every release and so

923
00:43:10,079 --> 00:43:14,800
far i

924
00:43:10,880 --> 00:43:18,960
just rebased the code and

925
00:43:14,800 --> 00:43:22,000
i occasionally get trivial conflicts but

926
00:43:18,960 --> 00:43:25,200
that's it that's a very stable part

927
00:43:22,000 --> 00:43:28,400
of the sqlite codebase and the

928
00:43:25,200 --> 00:43:33,040
the the patch is

929
00:43:28,400 --> 00:43:34,800
is minimal um for now i would like to

930
00:43:33,040 --> 00:43:36,720
grow the patch a bit we can talk about

931
00:43:34,800 --> 00:43:39,920
it uh if you will to

932
00:43:36,720 --> 00:43:42,399
to to add new uh

933
00:43:39,920 --> 00:43:44,560
ways of supporting replication but

934
00:43:42,400 --> 00:43:47,280
that's it

935
00:43:44,560 --> 00:43:48,720
uh probably you you might want to know

936
00:43:47,280 --> 00:43:52,160
whether this is going to be

937
00:43:48,720 --> 00:43:55,839
upstreamed the answer is uh

938
00:43:52,160 --> 00:43:55,839
yes eventually hopefully

939
00:43:55,920 --> 00:43:58,720
ask you light

940
00:43:58,960 --> 00:44:03,760
as a particular project the quoting from

941
00:44:01,760 --> 00:44:06,720
from from them

942
00:44:03,760 --> 00:44:07,359
it's not open contribution the project

943
00:44:06,720 --> 00:44:11,118
does not

944
00:44:07,359 --> 00:44:12,078
accept patches this is funny only 27

945
00:44:11,119 --> 00:44:14,480
individuals

946
00:44:12,079 --> 00:44:16,240
have ever contributed to any code in

947
00:44:14,480 --> 00:44:19,119
sqlite

948
00:44:16,240 --> 00:44:20,160
and of those only 16 have traces in the

949
00:44:19,119 --> 00:44:22,079
latest release

950
00:44:20,160 --> 00:44:24,640
only three developers have contributed

951
00:44:22,079 --> 00:44:27,440
to non-comment changes

952
00:44:24,640 --> 00:44:28,078
in the last five years so it's not

953
00:44:27,440 --> 00:44:30,319
something

954
00:44:28,079 --> 00:44:32,000
like you you push a purchase pull

955
00:44:30,319 --> 00:44:34,640
request on github and

956
00:44:32,000 --> 00:44:36,000
and it gets merged it will be very

957
00:44:34,640 --> 00:44:39,040
difficult to get any changes

958
00:44:36,000 --> 00:44:39,920
in so i will wait first when i'm

959
00:44:39,040 --> 00:44:41,759
absolutely

960
00:44:39,920 --> 00:44:43,599
certain that the patch will not change

961
00:44:41,760 --> 00:44:46,480
for for some time

962
00:44:43,599 --> 00:44:48,240
in the future and perhaps wait for

963
00:44:46,480 --> 00:44:50,000
decolite abduction

964
00:44:48,240 --> 00:44:51,359
to hopefully raise and have some more

965
00:44:50,000 --> 00:44:56,000
arguments

966
00:44:51,359 --> 00:44:59,119
okay we have a few minutes left uh

967
00:44:56,000 --> 00:45:02,160
if there are questions or i think

968
00:44:59,119 --> 00:45:02,160
we're done we can

969
00:45:02,720 --> 00:45:06,078
five minutes more so

970
00:45:09,280 --> 00:45:17,119
um okay so for now the only

971
00:45:14,720 --> 00:45:18,240
language which is really supported by dq

972
00:45:17,119 --> 00:45:22,960
lite is

973
00:45:18,240 --> 00:45:25,279
is go because lex d is written in go

974
00:45:22,960 --> 00:45:27,599
as i mentioned when your application

975
00:45:25,280 --> 00:45:29,839
talks to the database it doesn't talk

976
00:45:27,599 --> 00:45:30,960
to anything local it needs to connect to

977
00:45:29,839 --> 00:45:33,040
the leader

978
00:45:30,960 --> 00:45:34,240
and when they speak they speak a wire

979
00:45:33,040 --> 00:45:37,440
protocol

980
00:45:34,240 --> 00:45:41,118
similar to postgres or

981
00:45:37,440 --> 00:45:44,160
my sequel i didn't pick

982
00:45:41,119 --> 00:45:48,000
my secular postcrash protocol

983
00:45:44,160 --> 00:45:49,759
for reasons this is uh another topic

984
00:45:48,000 --> 00:45:51,680
but there is a wire protocol that your

985
00:45:49,760 --> 00:45:54,160
client needs to speak there is a go

986
00:45:51,680 --> 00:45:58,839
client that speaks this protocol

987
00:45:54,160 --> 00:46:00,960
but that's the only supported language

988
00:45:58,839 --> 00:46:04,319
um

989
00:46:00,960 --> 00:46:06,319
if you want to to support your own

990
00:46:04,319 --> 00:46:08,800
language you will have to write

991
00:46:06,319 --> 00:46:11,279
the client as as for today but what a

992
00:46:08,800 --> 00:46:14,240
protocol is documented

993
00:46:11,280 --> 00:46:15,359
and you can take a look at the go one

994
00:46:14,240 --> 00:46:17,118
for example to

995
00:46:15,359 --> 00:46:19,279
to have an idea how it works it should

996
00:46:17,119 --> 00:46:21,680
be doable but

997
00:46:19,280 --> 00:46:24,000
we we would love to implement more

998
00:46:21,680 --> 00:46:29,839
clients in other languages but

999
00:46:24,000 --> 00:46:29,839
for now we didn't have time um

1000
00:46:30,720 --> 00:46:39,200
yeah yeah one last thing is

1001
00:46:35,920 --> 00:46:43,359
as i mentioned for now the way

1002
00:46:39,200 --> 00:46:46,560
data is replicated is by

1003
00:46:43,359 --> 00:46:50,720
transferring pages of the

1004
00:46:46,560 --> 00:46:53,520
right ahead log of of sqlite

1005
00:46:50,720 --> 00:46:54,000
that's that's good and robust but it

1006
00:46:53,520 --> 00:46:56,400
might

1007
00:46:54,000 --> 00:46:57,280
be too much for example if you change if

1008
00:46:56,400 --> 00:47:00,319
you if your

1009
00:46:57,280 --> 00:47:02,960
insert query just changes a few cells

1010
00:47:00,319 --> 00:47:03,839
in the in the b3 so you change just a

1011
00:47:02,960 --> 00:47:07,119
few records

1012
00:47:03,839 --> 00:47:08,160
that might be overkill so i would like

1013
00:47:07,119 --> 00:47:10,960
to implement

1014
00:47:08,160 --> 00:47:12,720
b3 based replication so in the

1015
00:47:10,960 --> 00:47:16,640
transaction i just look at which

1016
00:47:12,720 --> 00:47:18,640
which cells were modified and i just uh

1017
00:47:16,640 --> 00:47:20,000
replicate a logical representation of

1018
00:47:18,640 --> 00:47:23,440
the change

1019
00:47:20,000 --> 00:47:26,480
um pretty much like postgres does

1020
00:47:23,440 --> 00:47:27,040
i think more or less or even statement

1021
00:47:26,480 --> 00:47:29,839
based

1022
00:47:27,040 --> 00:47:32,160
replication those those are way smaller

1023
00:47:29,839 --> 00:47:35,920
payloads to transfer over the wire

1024
00:47:32,160 --> 00:47:38,799
and to to write on disk it depends

1025
00:47:35,920 --> 00:47:40,319
this needs to be benchmarked because

1026
00:47:38,800 --> 00:47:43,440
often it doesn't matter

1027
00:47:40,319 --> 00:47:46,079
much if you transfer just a few

1028
00:47:43,440 --> 00:47:46,880
bytes or a full page because network and

1029
00:47:46,079 --> 00:47:50,480
disk

1030
00:47:46,880 --> 00:47:54,720
but that's it

1031
00:47:50,480 --> 00:47:57,359
so what's up yeah okay thank you

1032
00:47:54,720 --> 00:47:57,359
thank you free

1033
00:48:00,960 --> 00:48:05,200
and time for more questions

1034
00:48:09,920 --> 00:48:14,720
are there constraints instead in terms

1035
00:48:12,319 --> 00:48:17,839
of hardware or

1036
00:48:14,720 --> 00:48:19,118
architecture to run are there

1037
00:48:17,839 --> 00:48:21,920
constraints in terms of

1038
00:48:19,119 --> 00:48:24,000
hardware or or architecture architecture

1039
00:48:21,920 --> 00:48:25,760
architecture no the only constraint is

1040
00:48:24,000 --> 00:48:29,280
for now is the operating system

1041
00:48:25,760 --> 00:48:33,520
we are targeting linux because of that

1042
00:48:29,280 --> 00:48:33,520
asynchronous disk io but

1043
00:48:33,760 --> 00:48:37,040
that that could be ported to other

1044
00:48:35,359 --> 00:48:39,598
operating systems as well but

1045
00:48:37,040 --> 00:48:41,359
no architectures whatever you want we

1046
00:48:39,599 --> 00:48:44,559
run it on army we

1047
00:48:41,359 --> 00:48:49,200
run it on s3 90 and

1048
00:48:44,559 --> 00:48:51,440
whatever yeah whatever linux supports

1049
00:48:49,200 --> 00:48:53,598
uh have you benchmarked the performance

1050
00:48:51,440 --> 00:48:56,800
hit for the raft protocol

1051
00:48:53,599 --> 00:48:57,760
um and what kind of extra latency does

1052
00:48:56,800 --> 00:49:01,200
that add to queries

1053
00:48:57,760 --> 00:49:01,200
so yeah as i mentioned

1054
00:49:01,440 --> 00:49:04,960
your bottleneck will be the disc and the

1055
00:49:04,000 --> 00:49:08,240
network

1056
00:49:04,960 --> 00:49:09,520
so the the inter compared to sqlite

1057
00:49:08,240 --> 00:49:12,879
sqlite needs to do

1058
00:49:09,520 --> 00:49:15,040
a disk right more or less that that's

1059
00:49:12,880 --> 00:49:16,880
the same the client needs to do a disk

1060
00:49:15,040 --> 00:49:19,839
write on any node that

1061
00:49:16,880 --> 00:49:20,480
happens in parallel so that part you can

1062
00:49:19,839 --> 00:49:22,558
expect

1063
00:49:20,480 --> 00:49:23,599
more or less the same performance as

1064
00:49:22,559 --> 00:49:25,920
sqlite

1065
00:49:23,599 --> 00:49:26,800
the overhead will be one network round

1066
00:49:25,920 --> 00:49:29,440
trip

1067
00:49:26,800 --> 00:49:30,319
because you need to to propagate the

1068
00:49:29,440 --> 00:49:32,880
change

1069
00:49:30,319 --> 00:49:34,319
and get an answer to to decide that

1070
00:49:32,880 --> 00:49:38,720
there's a quorum

1071
00:49:34,319 --> 00:49:38,720
so it's sqlite plus one network

1072
00:49:38,960 --> 00:49:42,800
round trip that's more or less what we

1073
00:49:42,839 --> 00:49:47,920
observed

1074
00:49:44,559 --> 00:49:50,559
so first thank you for the talk um

1075
00:49:47,920 --> 00:49:52,319
uh i want to do a question about a

1076
00:49:50,559 --> 00:49:52,880
synchronous io i'm not used to a

1077
00:49:52,319 --> 00:49:55,520
synchronous

1078
00:49:52,880 --> 00:49:57,119
unc but in other platforms how do you

1079
00:49:55,520 --> 00:49:59,200
manage to

1080
00:49:57,119 --> 00:50:01,359
can you hear me i'll leave you merely

1081
00:49:59,200 --> 00:50:03,439
berlin

1082
00:50:01,359 --> 00:50:05,759
can you hear me yeah now yeah okay how

1083
00:50:03,440 --> 00:50:08,079
do you manage to

1084
00:50:05,760 --> 00:50:09,520
perform blocking and unblocking

1085
00:50:08,079 --> 00:50:12,480
operations using a

1086
00:50:09,520 --> 00:50:14,000
libsio do you have like worker treads

1087
00:50:12,480 --> 00:50:18,319
when you perform

1088
00:50:14,000 --> 00:50:20,880
only the synchros blocking operations or

1089
00:50:18,319 --> 00:50:22,720
so the question is how do you perform

1090
00:50:20,880 --> 00:50:25,680
blocking

1091
00:50:22,720 --> 00:50:27,200
calls using a libco the the thing is you

1092
00:50:25,680 --> 00:50:30,240
don't

1093
00:50:27,200 --> 00:50:35,759
decollete does not use any

1094
00:50:30,240 --> 00:50:35,759
blocking system call

1095
00:50:36,319 --> 00:50:41,200
say it again yeah that that's the reason

1096
00:50:40,400 --> 00:50:44,319
why we

1097
00:50:41,200 --> 00:50:47,279
use lipco in the first place when you

1098
00:50:44,319 --> 00:50:49,119
enter the the commit path of the sqlite

1099
00:50:47,280 --> 00:50:52,240
transaction

1100
00:50:49,119 --> 00:50:56,559
the sqlite logic code will

1101
00:50:52,240 --> 00:50:59,118
pose there the registers will be swapped

1102
00:50:56,559 --> 00:51:00,559
and the the the raft engine will run so

1103
00:50:59,119 --> 00:51:02,800
to speak

1104
00:51:00,559 --> 00:51:03,920
that code will will slip there nothing

1105
00:51:02,800 --> 00:51:07,280
else will will happen

1106
00:51:03,920 --> 00:51:09,200
also the readers uh well the readers

1107
00:51:07,280 --> 00:51:09,680
actually gone in parallel but other

1108
00:51:09,200 --> 00:51:12,399
white

1109
00:51:09,680 --> 00:51:13,919
writers will be blocked like sql so

1110
00:51:12,400 --> 00:51:17,119
sqlite will be frozen

1111
00:51:13,920 --> 00:51:17,520
in in that in that particular spot in

1112
00:51:17,119 --> 00:51:19,599
the

1113
00:51:17,520 --> 00:51:21,040
cicolite code so that's from the point

1114
00:51:19,599 --> 00:51:22,800
of view of sqlite

1115
00:51:21,040 --> 00:51:25,119
that's blocking but from the point of

1116
00:51:22,800 --> 00:51:25,839
view of the cpu i'm just dropping the

1117
00:51:25,119 --> 00:51:29,680
registers

1118
00:51:25,839 --> 00:51:34,720
and going on with something else okay

1119
00:51:29,680 --> 00:51:34,720
okay time is up thank you again thank

1120
00:51:34,839 --> 00:51:37,839
you

1121
00:51:42,160 --> 00:51:44,240
you

