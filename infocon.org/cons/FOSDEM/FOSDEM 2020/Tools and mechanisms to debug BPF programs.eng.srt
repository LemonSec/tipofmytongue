1
00:00:06,080 --> 00:00:09,920
hi

2
00:00:07,919 --> 00:00:12,239
hi everyone thank you for attending so

3
00:00:09,920 --> 00:00:14,960
we're gonna talk about bpf again

4
00:00:12,240 --> 00:00:15,360
uh so many of you probably know that we

5
00:00:14,960 --> 00:00:18,480
can

6
00:00:15,360 --> 00:00:22,640
somewhat trace many things

7
00:00:18,480 --> 00:00:23,359
on linux with bpf i want to talk about

8
00:00:22,640 --> 00:00:25,599
how to

9
00:00:23,359 --> 00:00:27,840
try and understand what may go wrong

10
00:00:25,599 --> 00:00:30,400
with those bpf programs themselves

11
00:00:27,840 --> 00:00:31,359
so not trying to try something else but

12
00:00:30,400 --> 00:00:33,920
just uh

13
00:00:31,359 --> 00:00:36,559
the bpf programs so i'm quentin i've

14
00:00:33,920 --> 00:00:39,360
been working with bpa for the last

15
00:00:36,559 --> 00:00:40,800
four years or so first in a company

16
00:00:39,360 --> 00:00:42,559
called six screen doing software

17
00:00:40,800 --> 00:00:44,800
acceleration

18
00:00:42,559 --> 00:00:46,000
for packet processing for networks then

19
00:00:44,800 --> 00:00:49,199
at metronome

20
00:00:46,000 --> 00:00:50,559
where i worked on hardware fluid of bpf

21
00:00:49,200 --> 00:00:53,360
packet processing

22
00:00:50,559 --> 00:00:54,000
uh so with all of that you might you may

23
00:00:53,360 --> 00:00:56,160
find that

24
00:00:54,000 --> 00:00:57,520
some of the examples are slightly more

25
00:00:56,160 --> 00:01:00,160
focused on

26
00:00:57,520 --> 00:01:02,640
bpa for network processing rather than

27
00:01:00,160 --> 00:01:04,720
tracing but

28
00:01:02,640 --> 00:01:07,040
everything i will present should be the

29
00:01:04,720 --> 00:01:10,320
same for the different use cases

30
00:01:07,040 --> 00:01:13,280
so bpf is the extended version of

31
00:01:10,320 --> 00:01:16,000
berkeley packet filter

32
00:01:13,280 --> 00:01:17,360
you could use it to write your own

33
00:01:16,000 --> 00:01:19,520
programs for example in c

34
00:01:17,360 --> 00:01:20,479
code and then compile them into ebpf

35
00:01:19,520 --> 00:01:23,920
bytecode

36
00:01:20,479 --> 00:01:25,280
and inject that into the kernel where it

37
00:01:23,920 --> 00:01:27,119
is verified

38
00:01:25,280 --> 00:01:29,840
in order to make sure that the programs

39
00:01:27,119 --> 00:01:33,200
are safe and that they terminate

40
00:01:29,840 --> 00:01:36,400
in order to avoid security issues or

41
00:01:33,200 --> 00:01:40,240
crashing your kernel this kind of

42
00:01:36,400 --> 00:01:42,159
small issues you want to avoid

43
00:01:40,240 --> 00:01:43,439
so you you have an interpreter in the

44
00:01:42,159 --> 00:01:45,920
kernel

45
00:01:43,439 --> 00:01:48,240
you also have a jit compiler to to get

46
00:01:45,920 --> 00:01:49,920
better performance with bpf programs

47
00:01:48,240 --> 00:01:51,439
and once they are loaded in the kernel

48
00:01:49,920 --> 00:01:52,560
you can attach them to one of the

49
00:01:51,439 --> 00:01:55,199
existing

50
00:01:52,560 --> 00:01:56,799
hooks so for example network processing

51
00:01:55,200 --> 00:02:00,240
or tracing hooks

52
00:01:56,799 --> 00:02:01,600
um so so yeah that's about it so the

53
00:02:00,240 --> 00:02:04,640
instructions are

54
00:02:01,600 --> 00:02:07,600
64-bit you have 11 registers uh

55
00:02:04,640 --> 00:02:09,360
500 bytes stack it's not ring complete

56
00:02:07,600 --> 00:02:11,519
in the sense that we don't have generic

57
00:02:09,360 --> 00:02:14,000
loops now we have bounded loops

58
00:02:11,520 --> 00:02:15,920
um and it comes also with a number of

59
00:02:14,000 --> 00:02:18,400
additional features we have

60
00:02:15,920 --> 00:02:19,440
maps that are shared between bpf

61
00:02:18,400 --> 00:02:22,560
programming the kernel

62
00:02:19,440 --> 00:02:24,239
and user space or several bpf programs

63
00:02:22,560 --> 00:02:26,319
we have some functions we can call from

64
00:02:24,239 --> 00:02:29,680
the kernel we have btf

65
00:02:26,319 --> 00:02:32,879
on which i'll come back later

66
00:02:29,680 --> 00:02:35,599
so that's about it for

67
00:02:32,879 --> 00:02:36,319
for bpf the the following diagram can

68
00:02:35,599 --> 00:02:38,879
summarize

69
00:02:36,319 --> 00:02:40,958
workflows so we compile our c

70
00:02:38,879 --> 00:02:42,799
programming to ebpf instructions that we

71
00:02:40,959 --> 00:02:45,440
inject into the kernel

72
00:02:42,800 --> 00:02:47,519
it may or may not be cheat compiled and

73
00:02:45,440 --> 00:02:48,000
at some point we'll attach it to a hook

74
00:02:47,519 --> 00:02:50,720
where it's

75
00:02:48,000 --> 00:02:52,319
run where when the event appears so

76
00:02:50,720 --> 00:02:53,680
where the function that we want to trace

77
00:02:52,319 --> 00:02:57,760
is triggered for example

78
00:02:53,680 --> 00:02:59,640
um so the the rest of the presentation

79
00:02:57,760 --> 00:03:02,239
will be organized like this

80
00:02:59,640 --> 00:03:05,679
[Music]

81
00:03:02,239 --> 00:03:08,400
like this that's better so uh

82
00:03:05,680 --> 00:03:10,000
reminder of evpf that's done uh the

83
00:03:08,400 --> 00:03:12,560
tools to inspect ppf

84
00:03:10,000 --> 00:03:13,519
uh objects uh so we have a number of

85
00:03:12,560 --> 00:03:16,800
them i would like to

86
00:03:13,519 --> 00:03:19,440
to introduce them in the first part uh

87
00:03:16,800 --> 00:03:21,120
for the different steps of that diagram

88
00:03:19,440 --> 00:03:25,040
i just showed before

89
00:03:21,120 --> 00:03:27,200
um and then in a second but i'd like to

90
00:03:25,040 --> 00:03:30,159
make a somewhat deeper introduction to

91
00:03:27,200 --> 00:03:33,280
bpf2 which is used a lot to try

92
00:03:30,159 --> 00:03:33,840
uh to get some information about the

93
00:03:33,280 --> 00:03:35,840
objects

94
00:03:33,840 --> 00:03:37,360
the bpf objects loaded in the system so

95
00:03:35,840 --> 00:03:38,239
that would be programs and maps for

96
00:03:37,360 --> 00:03:41,200
example

97
00:03:38,239 --> 00:03:42,720
um i would like also to give a brief

98
00:03:41,200 --> 00:03:45,599
overview of the

99
00:03:42,720 --> 00:03:48,000
possible next steps in terms of bpf

100
00:03:45,599 --> 00:03:49,920
introspection and debugging

101
00:03:48,000 --> 00:03:52,080
what's being discussed at the moment in

102
00:03:49,920 --> 00:03:54,000
the community and what we could do

103
00:03:52,080 --> 00:03:55,439
so i just forgot to mention the main use

104
00:03:54,000 --> 00:03:58,319
cases for bpf

105
00:03:55,439 --> 00:03:58,959
so we have networking tracing we have

106
00:03:58,319 --> 00:04:01,599
also

107
00:03:58,959 --> 00:04:02,319
some use case for circuit filtering

108
00:04:01,599 --> 00:04:06,000
between c

109
00:04:02,319 --> 00:04:07,599
groups there is a work in progress for

110
00:04:06,000 --> 00:04:10,560
linux security module

111
00:04:07,599 --> 00:04:10,959
and we have also more use cases smaller

112
00:04:10,560 --> 00:04:13,360
ones

113
00:04:10,959 --> 00:04:15,439
that you that exist today and probably

114
00:04:13,360 --> 00:04:19,199
some others that will

115
00:04:15,439 --> 00:04:21,839
appear in the future so let's start with

116
00:04:19,199 --> 00:04:23,840
uh the first step of our workflow when i

117
00:04:21,839 --> 00:04:26,159
try to

118
00:04:23,840 --> 00:04:28,239
compile a c program for example into

119
00:04:26,160 --> 00:04:30,240
ebpf bytecode

120
00:04:28,240 --> 00:04:32,639
at that step of the process i want to

121
00:04:30,240 --> 00:04:35,759
make sure that the bpf byte code

122
00:04:32,639 --> 00:04:38,560
is consistent with the program i had in

123
00:04:35,759 --> 00:04:42,479
mind with what i wanted to create

124
00:04:38,560 --> 00:04:44,960
and so how can i do that uh

125
00:04:42,479 --> 00:04:47,039
so i have this clearing command line

126
00:04:44,960 --> 00:04:49,840
because you compile your your c into bpf

127
00:04:47,040 --> 00:04:53,199
with clearing and llvm there is also a

128
00:04:49,840 --> 00:04:56,560
gcc uh back end now but it's uh

129
00:04:53,199 --> 00:04:59,919
not as complete as clearing

130
00:04:56,560 --> 00:05:01,759
and once i have my object file i can use

131
00:04:59,919 --> 00:05:04,159
llvm optim to

132
00:05:01,759 --> 00:05:06,080
dump the the the bytecode of the program

133
00:05:04,160 --> 00:05:10,000
so that's what we have here

134
00:05:06,080 --> 00:05:12,719
uh b7 and the the rest of zeros

135
00:05:10,000 --> 00:05:14,639
is putting the value zero into register

136
00:05:12,720 --> 00:05:17,120
zero which is used

137
00:05:14,639 --> 00:05:17,919
for for storing the written value of the

138
00:05:17,120 --> 00:05:19,520
program

139
00:05:17,919 --> 00:05:21,758
and then i have a second instruction

140
00:05:19,520 --> 00:05:22,320
which says exit and return from the

141
00:05:21,759 --> 00:05:25,440
program

142
00:05:22,320 --> 00:05:28,479
so return zero basically

143
00:05:25,440 --> 00:05:30,639
i can also get the the

144
00:05:28,479 --> 00:05:31,520
c source code in that output if i were

145
00:05:30,639 --> 00:05:35,840
to uh

146
00:05:31,520 --> 00:05:37,520
to provide the t flag to clang and

147
00:05:35,840 --> 00:05:40,560
use the different options with lvm

148
00:05:37,520 --> 00:05:44,719
option so that's useful to to check

149
00:05:40,560 --> 00:05:44,720
what what i have in my object file

150
00:05:45,120 --> 00:05:49,039
i have an option also that might be

151
00:05:47,919 --> 00:05:52,320
useful which is

152
00:05:49,039 --> 00:05:56,000
instead of combining directly from

153
00:05:52,320 --> 00:05:59,520
c into bpa bytecode i can compile into

154
00:05:56,000 --> 00:06:02,000
assembly ebpf assembly and uh

155
00:05:59,520 --> 00:06:02,639
that gives me an assembly file a dot s

156
00:06:02,000 --> 00:06:05,520
file

157
00:06:02,639 --> 00:06:06,000
that is much easier to to edit if i want

158
00:06:05,520 --> 00:06:09,359
to

159
00:06:06,000 --> 00:06:11,759
change my bpf code itself

160
00:06:09,360 --> 00:06:12,639
without having to write all the code by

161
00:06:11,759 --> 00:06:15,199
hand

162
00:06:12,639 --> 00:06:17,360
and if i want to test a specific

163
00:06:15,199 --> 00:06:20,000
sequence of instructions to test

164
00:06:17,360 --> 00:06:21,759
some kernel bpa feature to test so for

165
00:06:20,000 --> 00:06:23,199
example for hardware flows we wanted to

166
00:06:21,759 --> 00:06:25,759
make sure that some

167
00:06:23,199 --> 00:06:28,720
instruction sequences were processed in

168
00:06:25,759 --> 00:06:30,319
a particular way so that's useful

169
00:06:28,720 --> 00:06:32,840
and clearing again can compare this

170
00:06:30,319 --> 00:06:35,520
assembly into a regular bpf

171
00:06:32,840 --> 00:06:37,119
um so that's it for the first step

172
00:06:35,520 --> 00:06:37,680
there's not much to debug really at this

173
00:06:37,120 --> 00:06:40,080
point

174
00:06:37,680 --> 00:06:42,240
that's mostly to inspect things that's

175
00:06:40,080 --> 00:06:43,680
also the case when you try to load your

176
00:06:42,240 --> 00:06:46,840
program so you have your

177
00:06:43,680 --> 00:06:50,080
bpf bytecode and you're trying to

178
00:06:46,840 --> 00:06:52,960
mostly past the very fire that's

179
00:06:50,080 --> 00:06:54,880
something here in the kernel acting as a

180
00:06:52,960 --> 00:06:57,758
guardian somehow and that

181
00:06:54,880 --> 00:06:58,960
often tells you no this i don't want of

182
00:06:57,759 --> 00:07:01,440
it

183
00:06:58,960 --> 00:07:04,560
there is a security risk so you have to

184
00:07:01,440 --> 00:07:06,479
to change your programs so

185
00:07:04,560 --> 00:07:07,919
we want to the program to pass the

186
00:07:06,479 --> 00:07:10,400
verifier or at least we want to

187
00:07:07,919 --> 00:07:13,758
understand why it's rejected

188
00:07:10,400 --> 00:07:16,000
which is essentially improving the

189
00:07:13,759 --> 00:07:18,319
program to get something that works

190
00:07:16,000 --> 00:07:19,759
so we have a variety of resources that

191
00:07:18,319 --> 00:07:22,160
can be used to

192
00:07:19,759 --> 00:07:25,280
inject the program uh into the kernel

193
00:07:22,160 --> 00:07:27,440
and possibly get this uh

194
00:07:25,280 --> 00:07:29,119
output information from the verifier the

195
00:07:27,440 --> 00:07:30,160
debug information that the verifier

196
00:07:29,120 --> 00:07:32,400
sends back

197
00:07:30,160 --> 00:07:34,160
so there is lib bpf which is in

198
00:07:32,400 --> 00:07:36,880
particular used in bpf tool which is a

199
00:07:34,160 --> 00:07:40,960
command line utility

200
00:07:36,880 --> 00:07:42,319
for networking we have iptc bcc but bcc

201
00:07:40,960 --> 00:07:45,440
is mostly used with

202
00:07:42,319 --> 00:07:46,319
tracing use cases tracing programs so we

203
00:07:45,440 --> 00:07:48,800
can

204
00:07:46,319 --> 00:07:49,440
load programs with those tools without

205
00:07:48,800 --> 00:07:51,360
having to

206
00:07:49,440 --> 00:07:55,120
implement everything ourselves and use

207
00:07:51,360 --> 00:07:57,520
and code manually the bpf system call

208
00:07:55,120 --> 00:08:00,720
and we can do some additional management

209
00:07:57,520 --> 00:08:04,159
of the bpf programs and maps

210
00:08:00,720 --> 00:08:06,639
so we have different things that can

211
00:08:04,160 --> 00:08:08,639
give us some information we have the

212
00:08:06,639 --> 00:08:11,360
logs from the verifier we have

213
00:08:08,639 --> 00:08:13,039
kernel logs sometimes for some specific

214
00:08:11,360 --> 00:08:15,840
bpf errors

215
00:08:13,039 --> 00:08:17,440
for networking we can have netflix

216
00:08:15,840 --> 00:08:21,198
extact messages

217
00:08:17,440 --> 00:08:23,520
to from ip or tc for example and

218
00:08:21,199 --> 00:08:24,800
we have some places where we have

219
00:08:23,520 --> 00:08:26,799
documentation to

220
00:08:24,800 --> 00:08:28,639
understand this error so typically that

221
00:08:26,800 --> 00:08:30,879
would be the filter.text

222
00:08:28,639 --> 00:08:32,080
documentation file in the kernel

223
00:08:30,879 --> 00:08:35,120
documentation

224
00:08:32,080 --> 00:08:38,800
or the cdm guide about bpf

225
00:08:35,120 --> 00:08:38,799
which is really complete

226
00:08:39,039 --> 00:08:45,519
so this is a non-exhaustive list

227
00:08:42,320 --> 00:08:48,800
of what the verifier tries to uh

228
00:08:45,519 --> 00:08:50,720
to check so if you have uh not valid bpf

229
00:08:48,800 --> 00:08:51,760
syntax it will be rejected too many

230
00:08:50,720 --> 00:08:53,760
instructions

231
00:08:51,760 --> 00:08:54,800
uh more than the kernel supports it will

232
00:08:53,760 --> 00:08:58,080
be rejected

233
00:08:54,800 --> 00:09:00,079
and so on and so forth so just so that

234
00:08:58,080 --> 00:09:01,920
you can have a look at an example

235
00:09:00,080 --> 00:09:04,000
error message from the verifier so i'm

236
00:09:01,920 --> 00:09:06,560
trying to inject a program here

237
00:09:04,000 --> 00:09:07,519
and i'm trying to read a packet a

238
00:09:06,560 --> 00:09:10,239
network packet

239
00:09:07,519 --> 00:09:12,080
but i haven't checked that the offset

240
00:09:10,240 --> 00:09:15,760
inside that packet

241
00:09:12,080 --> 00:09:18,240
um is a safe offset in the term

242
00:09:15,760 --> 00:09:19,680
that my packet is big enough for me to

243
00:09:18,240 --> 00:09:22,720
uh try and access

244
00:09:19,680 --> 00:09:24,560
the the given offset in the packet so i

245
00:09:22,720 --> 00:09:27,040
have a potential risk

246
00:09:24,560 --> 00:09:29,599
of out of bound access which may never

247
00:09:27,040 --> 00:09:31,920
happen because if i'm trying that on the

248
00:09:29,600 --> 00:09:33,279
second bite of the packet i never have

249
00:09:31,920 --> 00:09:35,120
out of bound access

250
00:09:33,279 --> 00:09:36,800
because my packet will always have a mac

251
00:09:35,120 --> 00:09:38,399
header so i

252
00:09:36,800 --> 00:09:40,800
i literally have no risk but the

253
00:09:38,399 --> 00:09:42,640
verifier doesn't care if logically there

254
00:09:40,800 --> 00:09:45,120
is a risk of out of bound access the

255
00:09:42,640 --> 00:09:48,240
program is rejected

256
00:09:45,120 --> 00:09:50,560
so the message is very useful when you

257
00:09:48,240 --> 00:09:53,440
know what you're talking about

258
00:09:50,560 --> 00:09:55,760
bpf context invalid bpf context access

259
00:09:53,440 --> 00:09:58,480
but for newcomers especially that's

260
00:09:55,760 --> 00:10:01,839
very cryptic messages it's very hard to

261
00:09:58,480 --> 00:10:05,360
understand what it refers to

262
00:10:01,839 --> 00:10:06,640
so we we would like to have some better

263
00:10:05,360 --> 00:10:10,079
things in the future maybe

264
00:10:06,640 --> 00:10:13,519
some additional documentation or faqs

265
00:10:10,079 --> 00:10:16,000
uh that would uh tell us where to look

266
00:10:13,519 --> 00:10:18,240
in that case

267
00:10:16,000 --> 00:10:19,279
but still we do want to have those

268
00:10:18,240 --> 00:10:21,440
messages so it's

269
00:10:19,279 --> 00:10:22,720
especially important to be able to print

270
00:10:21,440 --> 00:10:25,120
them into the console

271
00:10:22,720 --> 00:10:26,560
or you're just on your own to understand

272
00:10:25,120 --> 00:10:30,000
what's going on so

273
00:10:26,560 --> 00:10:32,719
uh we have uh some debug flags that can

274
00:10:30,000 --> 00:10:34,399
be passed to uh to the tools

275
00:10:32,720 --> 00:10:36,160
to the various tools so you have to

276
00:10:34,399 --> 00:10:39,360
provide for example if you

277
00:10:36,160 --> 00:10:42,959
if you were to uh inject

278
00:10:39,360 --> 00:10:46,079
all on your own your program with

279
00:10:42,959 --> 00:10:48,880
a custom management program

280
00:10:46,079 --> 00:10:50,479
calling the bpf system called yourself

281
00:10:48,880 --> 00:10:53,040
you would have to be careful to

282
00:10:50,480 --> 00:10:54,320
uh to pass a buffer to the candle too so

283
00:10:53,040 --> 00:10:57,680
that the kernel can

284
00:10:54,320 --> 00:11:00,480
write into this buffer the the logs

285
00:10:57,680 --> 00:11:02,160
that correspond to that message which we

286
00:11:00,480 --> 00:11:05,200
we saw just before

287
00:11:02,160 --> 00:11:07,519
um because we have number of tools

288
00:11:05,200 --> 00:11:10,720
already such as bpf2

289
00:11:07,519 --> 00:11:15,120
and libpf which is used in bpf2 uh

290
00:11:10,720 --> 00:11:19,279
such low level buffer management is

291
00:11:15,120 --> 00:11:21,600
already done for us to some extent but

292
00:11:19,279 --> 00:11:22,959
for example ebpf itself does have an

293
00:11:21,600 --> 00:11:24,320
additional number of different

294
00:11:22,959 --> 00:11:28,239
information too

295
00:11:24,320 --> 00:11:30,000
so that might be information about

296
00:11:28,240 --> 00:11:32,160
hey now i'm trying to inject a program

297
00:11:30,000 --> 00:11:33,120
in the kernel or before that hey now i'm

298
00:11:32,160 --> 00:11:36,319
trying to perform

299
00:11:33,120 --> 00:11:38,800
l free location about some stuff from

300
00:11:36,320 --> 00:11:40,720
a given section of your object file that

301
00:11:38,800 --> 00:11:42,719
i'm trying to

302
00:11:40,720 --> 00:11:44,320
put back to the correct place into the

303
00:11:42,720 --> 00:11:44,959
rest of the bpf instructions we have a

304
00:11:44,320 --> 00:11:47,440
number of

305
00:11:44,959 --> 00:11:49,439
elf magic stuff that's happening uh

306
00:11:47,440 --> 00:11:52,959
before injecting the program so

307
00:11:49,440 --> 00:11:55,440
um you you may have to uh

308
00:11:52,959 --> 00:11:56,079
to tell the bpa to them this information

309
00:11:55,440 --> 00:11:58,079
so for

310
00:11:56,079 --> 00:11:59,199
bpf2 for example you can have

311
00:11:58,079 --> 00:12:03,519
information from

312
00:11:59,200 --> 00:12:06,639
the bpf and from the the kernel with the

313
00:12:03,519 --> 00:12:08,800
debug option so that's something useful

314
00:12:06,639 --> 00:12:10,639
to know too

315
00:12:08,800 --> 00:12:11,839
so for interpreting this information we

316
00:12:10,639 --> 00:12:14,320
have uh

317
00:12:11,839 --> 00:12:16,160
that's the same uh locations that i

318
00:12:14,320 --> 00:12:17,920
mentioned earlier the filter the text

319
00:12:16,160 --> 00:12:20,240
documentation the serium guide

320
00:12:17,920 --> 00:12:22,000
uh there is also some additional

321
00:12:20,240 --> 00:12:24,399
information now on the documentation

322
00:12:22,000 --> 00:12:28,160
slash

323
00:12:24,399 --> 00:12:31,839
networking i think slash bpf

324
00:12:28,160 --> 00:12:34,480
although it's still not perfect i think

325
00:12:31,839 --> 00:12:36,399
the the hardcore solution if you don't

326
00:12:34,480 --> 00:12:39,760
get anything better is to

327
00:12:36,399 --> 00:12:42,959
go and read the kernel code

328
00:12:39,760 --> 00:12:45,200
yeah that's not really ideal too

329
00:12:42,959 --> 00:12:46,319
so yeah maybe in the future we'll have

330
00:12:45,200 --> 00:12:48,800
something a bit

331
00:12:46,320 --> 00:12:53,120
more user-friendly that would be nice to

332
00:12:48,800 --> 00:12:56,240
to have sorry about that

333
00:12:53,120 --> 00:12:58,240
uh so now we have managed somehow to

334
00:12:56,240 --> 00:13:00,240
uh to fix our program and to pass the

335
00:12:58,240 --> 00:13:02,000
verifier based on the

336
00:13:00,240 --> 00:13:04,320
on the output we managed to make it work

337
00:13:02,000 --> 00:13:07,600
to add that check that was missing for

338
00:13:04,320 --> 00:13:09,120
uh packet access so the program is now

339
00:13:07,600 --> 00:13:12,320
loaded in the kernel it's not

340
00:13:09,120 --> 00:13:15,279
attached yet uh it can be attached

341
00:13:12,320 --> 00:13:17,200
um it's just here in the kernel it's

342
00:13:15,279 --> 00:13:18,800
referenced by something in user space so

343
00:13:17,200 --> 00:13:20,000
that it doesn't get wiped out from the

344
00:13:18,800 --> 00:13:23,359
kernel so that can be

345
00:13:20,000 --> 00:13:23,360
a file descriptor typically

346
00:13:23,519 --> 00:13:27,360
or when the program gets attached then

347
00:13:25,440 --> 00:13:30,639
it's referenced in the kernel until we

348
00:13:27,360 --> 00:13:33,120
we detach it so we have our

349
00:13:30,639 --> 00:13:34,160
program sitting here and what can we do

350
00:13:33,120 --> 00:13:36,639
with it with it

351
00:13:34,160 --> 00:13:37,279
so we have an options a number of

352
00:13:36,639 --> 00:13:39,760
options

353
00:13:37,279 --> 00:13:41,519
uh such as listing existing programs in

354
00:13:39,760 --> 00:13:44,160
the kernel and maps

355
00:13:41,519 --> 00:13:45,839
and dumping those the instructions for

356
00:13:44,160 --> 00:13:46,639
the programs of the content of those

357
00:13:45,839 --> 00:13:48,959
maps

358
00:13:46,639 --> 00:13:50,000
so maps will typically be array maps or

359
00:13:48,959 --> 00:13:51,439
hash maps

360
00:13:50,000 --> 00:13:53,680
or there are a number of additional maps

361
00:13:51,440 --> 00:13:57,120
for some specific use cases

362
00:13:53,680 --> 00:14:02,000
um so bpf tool here is

363
00:13:57,120 --> 00:14:05,040
uh the the main tool that we use

364
00:14:02,000 --> 00:14:06,560
on a daily basis to to to inspect those

365
00:14:05,040 --> 00:14:09,439
objects when they are loaded in the

366
00:14:06,560 --> 00:14:10,079
kernel um i'll come back to bpf2 later

367
00:14:09,440 --> 00:14:12,399
though

368
00:14:10,079 --> 00:14:13,120
i'll just move on to something else

369
00:14:12,399 --> 00:14:17,760
which is

370
00:14:13,120 --> 00:14:21,120
a btf for bpf

371
00:14:17,760 --> 00:14:26,319
sorry for bpf type format

372
00:14:21,120 --> 00:14:29,680
so since channel 4.18 i think so that's

373
00:14:26,320 --> 00:14:30,000
recent btf objects can be used to embed

374
00:14:29,680 --> 00:14:33,519
some

375
00:14:30,000 --> 00:14:35,839
debug information about the bpf programs

376
00:14:33,519 --> 00:14:38,079
and maps

377
00:14:35,839 --> 00:14:40,240
so it's something that's similar to the

378
00:14:38,079 --> 00:14:42,560
dual format that's being used with

379
00:14:40,240 --> 00:14:44,079
gdb for example so you have a number of

380
00:14:42,560 --> 00:14:46,079
information that are stored into your

381
00:14:44,079 --> 00:14:48,079
object file and that are passed down to

382
00:14:46,079 --> 00:14:49,920
the kernel when you eject your program

383
00:14:48,079 --> 00:14:52,000
which means that the kernel does have

384
00:14:49,920 --> 00:14:54,399
some may have some information about the

385
00:14:52,000 --> 00:14:56,240
bpf programs or maps

386
00:14:54,399 --> 00:14:59,279
so for programs it's just a matter of

387
00:14:56,240 --> 00:15:02,160
using a recent enough version of

388
00:14:59,279 --> 00:15:02,959
clearing and llvm and passing the debug

389
00:15:02,160 --> 00:15:04,959
flag

390
00:15:02,959 --> 00:15:06,079
for maps we have to do some wrapping in

391
00:15:04,959 --> 00:15:09,680
the source code

392
00:15:06,079 --> 00:15:12,719
so what i have here is a

393
00:15:09,680 --> 00:15:13,680
classic definition of my bpf map that

394
00:15:12,720 --> 00:15:18,639
would be in the

395
00:15:13,680 --> 00:15:18,638
c source code and i have above that to

396
00:15:18,800 --> 00:15:21,839
to to add some information in particular

397
00:15:21,279 --> 00:15:24,399
about the

398
00:15:21,839 --> 00:15:25,360
type for the key which is a pointer to

399
00:15:24,399 --> 00:15:28,079
nint and

400
00:15:25,360 --> 00:15:29,040
the type for the for the value which is

401
00:15:28,079 --> 00:15:32,719
a point to

402
00:15:29,040 --> 00:15:36,000
that strict there are more details

403
00:15:32,720 --> 00:15:37,839
uh sadly just mostly in the commit log

404
00:15:36,000 --> 00:15:40,160
of that change for now

405
00:15:37,839 --> 00:15:42,079
the reference for uh seeing how those

406
00:15:40,160 --> 00:15:44,319
things work would be the

407
00:15:42,079 --> 00:15:46,160
samples and safe tests in the in the

408
00:15:44,320 --> 00:15:47,360
kernel repository for now we're still

409
00:15:46,160 --> 00:15:50,800
waiting for

410
00:15:47,360 --> 00:15:53,040
documentation to to catch up uh

411
00:15:50,800 --> 00:15:55,920
so an example of a program that's being

412
00:15:53,040 --> 00:15:59,439
dumped with a btf format

413
00:15:55,920 --> 00:16:01,920
i have the sorry didn't want to click

414
00:15:59,440 --> 00:16:02,720
i have the regular bpf bytecode

415
00:16:01,920 --> 00:16:05,599
instructions

416
00:16:02,720 --> 00:16:06,480
here and below and in the middle of that

417
00:16:05,600 --> 00:16:10,000
i have the

418
00:16:06,480 --> 00:16:13,839
c instructions i hope you can read

419
00:16:10,000 --> 00:16:16,000
hopefully somewhat so here i have a

420
00:16:13,839 --> 00:16:17,360
nint balancer ingress which is the name

421
00:16:16,000 --> 00:16:20,720
of the function here i have

422
00:16:17,360 --> 00:16:24,240
um if data plus

423
00:16:20,720 --> 00:16:26,880
offset is superior to data end

424
00:16:24,240 --> 00:16:27,360
then and my program goes on so this is

425
00:16:26,880 --> 00:16:29,519
the c

426
00:16:27,360 --> 00:16:32,320
instructions uh that were used to

427
00:16:29,519 --> 00:16:33,199
compile the the program into bpf byte

428
00:16:32,320 --> 00:16:34,720
code

429
00:16:33,199 --> 00:16:36,560
but i get this information from the

430
00:16:34,720 --> 00:16:39,140
kernel now because the kernel knows this

431
00:16:36,560 --> 00:16:40,479
information about the program

432
00:16:39,140 --> 00:16:43,680
[Music]

433
00:16:40,480 --> 00:16:45,279
so that's that's useful to you to

434
00:16:43,680 --> 00:16:48,479
understand what's going on

435
00:16:45,279 --> 00:16:51,680
and it's also being used for some other

436
00:16:48,480 --> 00:16:55,120
bpa features in the sense that ptf

437
00:16:51,680 --> 00:16:56,560
objects like this uh are checked by the

438
00:16:55,120 --> 00:16:58,320
kernel especially formats that are

439
00:16:56,560 --> 00:17:01,119
checked for consistency

440
00:16:58,320 --> 00:17:03,199
so that you cannot just load anything

441
00:17:01,120 --> 00:17:04,880
any information

442
00:17:03,199 --> 00:17:06,240
you like to but something that really

443
00:17:04,880 --> 00:17:06,959
corresponds to the map that's being

444
00:17:06,240 --> 00:17:10,160
loaded

445
00:17:06,959 --> 00:17:11,439
and some advanced uh bpf features uh

446
00:17:10,160 --> 00:17:14,160
rely on btf

447
00:17:11,439 --> 00:17:15,679
uh objects to to work but that's

448
00:17:14,160 --> 00:17:19,360
something uh

449
00:17:15,679 --> 00:17:21,600
different uh just

450
00:17:19,359 --> 00:17:24,319
let's just think of it as giving

451
00:17:21,599 --> 00:17:28,319
information available to us for now

452
00:17:24,319 --> 00:17:29,039
um so i have had the possibility to

453
00:17:28,319 --> 00:17:32,879
inspect my

454
00:17:29,039 --> 00:17:34,799
uh my objects in the kernel and

455
00:17:32,880 --> 00:17:36,799
that's good i have my programs loaded

456
00:17:34,799 --> 00:17:38,960
now i want to run them maybe

457
00:17:36,799 --> 00:17:40,480
so i want to do some actual work with my

458
00:17:38,960 --> 00:17:42,160
programs for some processing some

459
00:17:40,480 --> 00:17:44,880
dressing whatever

460
00:17:42,160 --> 00:17:45,919
so i attached them to one of the hooks

461
00:17:44,880 --> 00:17:47,600
in the kernel

462
00:17:45,919 --> 00:17:50,240
so for tracing that would be trace

463
00:17:47,600 --> 00:17:52,480
points or k probes

464
00:17:50,240 --> 00:17:53,679
for for networking that would be tc

465
00:17:52,480 --> 00:17:57,200
hooks or

466
00:17:53,679 --> 00:17:59,200
xdp at the driver level and

467
00:17:57,200 --> 00:18:00,720
for the other use cases that's something

468
00:17:59,200 --> 00:18:04,000
different still

469
00:18:00,720 --> 00:18:06,160
but how can i understand why my

470
00:18:04,000 --> 00:18:07,600
program doesn't work as i expected i

471
00:18:06,160 --> 00:18:08,799
mean i've attached my program to an

472
00:18:07,600 --> 00:18:11,678
interface

473
00:18:08,799 --> 00:18:12,879
and it doesn't drop the packets i wanted

474
00:18:11,679 --> 00:18:15,039
it to drop or

475
00:18:12,880 --> 00:18:16,640
it doesn't give me the arguments of the

476
00:18:15,039 --> 00:18:19,760
function i was expected to

477
00:18:16,640 --> 00:18:23,039
to trace so what's happening

478
00:18:19,760 --> 00:18:24,559
we have a number of solutions we don't

479
00:18:23,039 --> 00:18:27,200
have

480
00:18:24,559 --> 00:18:28,000
a step-by-step debugger yet so it's

481
00:18:27,200 --> 00:18:31,360
mostly again

482
00:18:28,000 --> 00:18:34,480
about introspection um

483
00:18:31,360 --> 00:18:36,719
we do have a printf like

484
00:18:34,480 --> 00:18:38,160
thing because we internally small print

485
00:18:36,720 --> 00:18:40,720
k like thing

486
00:18:38,160 --> 00:18:43,200
uh it's a function that that can be

487
00:18:40,720 --> 00:18:44,880
called from the bpf programs themselves

488
00:18:43,200 --> 00:18:46,799
so it's just

489
00:18:44,880 --> 00:18:48,080
when you're debugging your program with

490
00:18:46,799 --> 00:18:51,520
printf everywhere

491
00:18:48,080 --> 00:18:53,199
that's same thing uh except it doesn't

492
00:18:51,520 --> 00:18:54,000
print to the console because it runs in

493
00:18:53,200 --> 00:18:57,679
the candle so

494
00:18:54,000 --> 00:19:01,360
it goes to a csfs file or pipe you have

495
00:18:57,679 --> 00:19:04,320
two files actually that can be used um

496
00:19:01,360 --> 00:19:05,039
and you you you get the output of

497
00:19:04,320 --> 00:19:07,678
whatever

498
00:19:05,039 --> 00:19:09,280
information you feed to your program so

499
00:19:07,679 --> 00:19:12,080
you have to use a

500
00:19:09,280 --> 00:19:13,440
constant string at the first argument

501
00:19:12,080 --> 00:19:16,399
but that's pretty much

502
00:19:13,440 --> 00:19:17,280
the same thing as other printed

503
00:19:16,400 --> 00:19:20,400
functions

504
00:19:17,280 --> 00:19:21,918
otherwise so in that case i'm printing

505
00:19:20,400 --> 00:19:25,520
the four

506
00:19:21,919 --> 00:19:27,760
first bytes of packets so

507
00:19:25,520 --> 00:19:28,879
i pass format string the size of the

508
00:19:27,760 --> 00:19:33,120
format string

509
00:19:28,880 --> 00:19:37,200
and then the data that i want to use for

510
00:19:33,120 --> 00:19:38,879
person x here so that's good for

511
00:19:37,200 --> 00:19:40,640
debugging for understanding what's going

512
00:19:38,880 --> 00:19:42,080
on that's not good in terms of

513
00:19:40,640 --> 00:19:43,200
performance so we have a different

514
00:19:42,080 --> 00:19:46,240
mechanism which is

515
00:19:43,200 --> 00:19:48,880
a bit more complex to use

516
00:19:46,240 --> 00:19:51,120
perf event arrays but that can be used

517
00:19:48,880 --> 00:19:51,679
to stream data more efficiently from the

518
00:19:51,120 --> 00:19:54,479
kernel

519
00:19:51,679 --> 00:19:56,720
to user space so that what you would use

520
00:19:54,480 --> 00:20:00,320
for example if you were to

521
00:19:56,720 --> 00:20:03,120
re-implement a tcp dump but

522
00:20:00,320 --> 00:20:04,000
with bpf programs attached to xdp

523
00:20:03,120 --> 00:20:06,399
interface

524
00:20:04,000 --> 00:20:07,440
you would stream data with uh perfume

525
00:20:06,400 --> 00:20:10,640
arrays

526
00:20:07,440 --> 00:20:11,840
or you could use that to send the flow

527
00:20:10,640 --> 00:20:14,960
of data like

528
00:20:11,840 --> 00:20:15,439
for tracing each time a system color is

529
00:20:14,960 --> 00:20:17,440
called

530
00:20:15,440 --> 00:20:18,720
uh and you want to print the arguments

531
00:20:17,440 --> 00:20:21,440
for that system called

532
00:20:18,720 --> 00:20:23,039
that's also possible to uh to to use

533
00:20:21,440 --> 00:20:24,880
perf event arrays to

534
00:20:23,039 --> 00:20:26,559
notify the user space and user space you

535
00:20:24,880 --> 00:20:27,360
can print them into the console so you

536
00:20:26,559 --> 00:20:30,639
could have

537
00:20:27,360 --> 00:20:32,799
uh something that's close to a stress at

538
00:20:30,640 --> 00:20:35,360
least

539
00:20:32,799 --> 00:20:36,799
in appearance you would have something

540
00:20:35,360 --> 00:20:40,000
somewhat similar

541
00:20:36,799 --> 00:20:41,440
so uh yeah and one of the advantage of

542
00:20:40,000 --> 00:20:43,200
this is that it can be used with a

543
00:20:41,440 --> 00:20:45,360
hardware fluid for network processing

544
00:20:43,200 --> 00:20:45,360
too

545
00:20:46,960 --> 00:20:52,000
so one thing that's interesting too is

546
00:20:50,000 --> 00:20:54,559
that bpf can be used for tracing right

547
00:20:52,000 --> 00:20:56,320
so why don't we reuse bpa for tracing

548
00:20:54,559 --> 00:20:59,600
epf programs

549
00:20:56,320 --> 00:21:02,080
well actually that's possible now uh

550
00:20:59,600 --> 00:21:04,480
since the the latest linux version i'm

551
00:21:02,080 --> 00:21:05,360
not even sure it's art 5.5 i think it's

552
00:21:04,480 --> 00:21:08,400
uh

553
00:21:05,360 --> 00:21:11,600
being um

554
00:21:08,400 --> 00:21:14,559
it's the merge window right now uh

555
00:21:11,600 --> 00:21:15,600
so we do have a possibility to attach

556
00:21:14,559 --> 00:21:19,039
bpf programs

557
00:21:15,600 --> 00:21:20,879
at the entry or the exit of another bpf

558
00:21:19,039 --> 00:21:22,559
programs at least for networking

559
00:21:20,880 --> 00:21:24,159
programs i'm not sure it works with

560
00:21:22,559 --> 00:21:27,600
tracing programs

561
00:21:24,159 --> 00:21:27,600
so at least for networking programs

562
00:21:28,880 --> 00:21:32,640
okay so it doesn't but for networking

563
00:21:31,360 --> 00:21:34,879
programs that

564
00:21:32,640 --> 00:21:37,039
it's supposed to work so you can uh you

565
00:21:34,880 --> 00:21:40,320
can have the

566
00:21:37,039 --> 00:21:43,120
the input packet the data the packet you

567
00:21:40,320 --> 00:21:44,720
you are processing with the program you

568
00:21:43,120 --> 00:21:48,000
are debugging

569
00:21:44,720 --> 00:21:50,480
and you can also get the the output data

570
00:21:48,000 --> 00:21:53,840
so you can check the difference between

571
00:21:50,480 --> 00:21:58,000
the two and see how your program

572
00:21:53,840 --> 00:22:01,439
managed to process the packet um

573
00:21:58,000 --> 00:22:03,919
you can also use a bcc or bpf trace to

574
00:22:01,440 --> 00:22:08,720
inject programs to trace the kernel

575
00:22:03,919 --> 00:22:10,720
if you are hitting some

576
00:22:08,720 --> 00:22:13,200
some unknown issue that's happening for

577
00:22:10,720 --> 00:22:15,039
example during verification time

578
00:22:13,200 --> 00:22:16,559
i've been using bpf trace a couple of

579
00:22:15,039 --> 00:22:19,039
times to understand

580
00:22:16,559 --> 00:22:22,000
what was the function inside the kernel

581
00:22:19,039 --> 00:22:23,840
verifier that was rejecting my programs

582
00:22:22,000 --> 00:22:25,520
so it can be useful to some extent but

583
00:22:23,840 --> 00:22:27,360
that's not the

584
00:22:25,520 --> 00:22:29,600
easiest way to to understand what's

585
00:22:27,360 --> 00:22:31,678
going on but still that's something

586
00:22:29,600 --> 00:22:34,158
good to think about if you're stuck

587
00:22:31,679 --> 00:22:34,159
otherwise

588
00:22:34,960 --> 00:22:41,440
so we have a feature that can help us

589
00:22:38,159 --> 00:22:44,640
testing bpf programs and by testing

590
00:22:41,440 --> 00:22:47,440
in test runs i mean instead of attaching

591
00:22:44,640 --> 00:22:50,720
a program to a network interface

592
00:22:47,440 --> 00:22:53,600
and wait for packets what i do is

593
00:22:50,720 --> 00:22:54,640
manually tell the system to run this

594
00:22:53,600 --> 00:22:56,959
program

595
00:22:54,640 --> 00:22:58,000
not on a real packet but on that input

596
00:22:56,960 --> 00:23:01,600
buffer

597
00:22:58,000 --> 00:23:03,600
and to give me back the output data

598
00:23:01,600 --> 00:23:05,039
once the program has run so there is a

599
00:23:03,600 --> 00:23:08,559
specific program

600
00:23:05,039 --> 00:23:10,240
type for that that can be uh

601
00:23:08,559 --> 00:23:12,960
no that's not a program type sorry

602
00:23:10,240 --> 00:23:13,679
that's a subcommand for the bpf system

603
00:23:12,960 --> 00:23:16,880
code

604
00:23:13,679 --> 00:23:18,559
uh and that works best again with

605
00:23:16,880 --> 00:23:19,520
networking program because it's a bit

606
00:23:18,559 --> 00:23:23,039
more tricky to

607
00:23:19,520 --> 00:23:24,080
to use with tracing programs so you you

608
00:23:23,039 --> 00:23:27,200
provide input you get

609
00:23:24,080 --> 00:23:29,760
output and you can see what's happening

610
00:23:27,200 --> 00:23:31,120
it has some limitations so not all

611
00:23:29,760 --> 00:23:33,120
program types

612
00:23:31,120 --> 00:23:34,879
for tracing it's a bit difficult to

613
00:23:33,120 --> 00:23:36,959
check how

614
00:23:34,880 --> 00:23:40,240
can channel data structures that might

615
00:23:36,960 --> 00:23:42,400
be changed by the programmer

616
00:23:40,240 --> 00:23:44,400
are changed or not so it's a bit more

617
00:23:42,400 --> 00:23:46,960
complicated to implement

618
00:23:44,400 --> 00:23:48,840
some bpf helpers are so those functions

619
00:23:46,960 --> 00:23:50,640
that you can call from within bpf

620
00:23:48,840 --> 00:23:53,600
programs

621
00:23:50,640 --> 00:23:55,120
are very hard to support in that with

622
00:23:53,600 --> 00:23:57,279
that mechanism

623
00:23:55,120 --> 00:23:58,639
for example when you try to redirect a

624
00:23:57,279 --> 00:24:01,679
packet to a different

625
00:23:58,640 --> 00:24:03,600
interface how can you check that it

626
00:24:01,679 --> 00:24:04,400
really worked just by getting an output

627
00:24:03,600 --> 00:24:08,399
buffer

628
00:24:04,400 --> 00:24:09,840
that's another issue and we would like

629
00:24:08,400 --> 00:24:11,520
well some people at least would like to

630
00:24:09,840 --> 00:24:14,639
have this feature available for

631
00:24:11,520 --> 00:24:15,120
non-root users in order to run test

632
00:24:14,640 --> 00:24:17,840
suits

633
00:24:15,120 --> 00:24:19,439
on bpf programs but there are security

634
00:24:17,840 --> 00:24:21,600
issues against

635
00:24:19,440 --> 00:24:23,360
so yeah so a number of these uh

636
00:24:21,600 --> 00:24:26,240
limitations are

637
00:24:23,360 --> 00:24:26,639
have been proposed uh in a conference in

638
00:24:26,240 --> 00:24:29,600
march

639
00:24:26,640 --> 00:24:30,640
the dev conference for for discussion so

640
00:24:29,600 --> 00:24:34,639
things might

641
00:24:30,640 --> 00:24:34,640
evolve and improve hopefully

642
00:24:34,799 --> 00:24:38,639
another things that might be useful for

643
00:24:36,559 --> 00:24:41,120
understanding what's going on

644
00:24:38,640 --> 00:24:41,679
is uh that you have statistics now

645
00:24:41,120 --> 00:24:44,879
regarding

646
00:24:41,679 --> 00:24:47,840
programs so uh you have to active that

647
00:24:44,880 --> 00:24:48,960
to activate them with this control and

648
00:24:47,840 --> 00:24:52,158
then you get

649
00:24:48,960 --> 00:24:54,880
the duration of your program run and

650
00:24:52,159 --> 00:24:56,480
uh the the number of times the program

651
00:24:54,880 --> 00:24:58,559
has run so at least you can check that

652
00:24:56,480 --> 00:25:01,600
your program has run the number of times

653
00:24:58,559 --> 00:25:03,279
you expected it to run it's not enabled

654
00:25:01,600 --> 00:25:04,799
by default because there is a slight

655
00:25:03,279 --> 00:25:06,400
overhead for

656
00:25:04,799 --> 00:25:07,918
gathering statistics when you run the

657
00:25:06,400 --> 00:25:11,200
program so you have to

658
00:25:07,919 --> 00:25:14,080
uh to activate it

659
00:25:11,200 --> 00:25:14,960
a small number of machine learners

660
00:25:14,080 --> 00:25:17,439
things to

661
00:25:14,960 --> 00:25:19,919
to know about uh debugging at runtime

662
00:25:17,440 --> 00:25:23,360
too so pf has support for annotating

663
00:25:19,919 --> 00:25:27,679
bpf programs so you can run perftop

664
00:25:23,360 --> 00:25:30,399
and go to the annotated pattern you can

665
00:25:27,679 --> 00:25:34,080
find the instructions of your program on

666
00:25:30,400 --> 00:25:36,000
which the cpu is spending some time

667
00:25:34,080 --> 00:25:37,918
so who knows if you need to to check

668
00:25:36,000 --> 00:25:41,360
what's happening on that side

669
00:25:37,919 --> 00:25:42,320
you're being covered there are a number

670
00:25:41,360 --> 00:25:44,959
of

671
00:25:42,320 --> 00:25:46,320
user space bpf machines so they are

672
00:25:44,960 --> 00:25:48,159
nowhere as complete as

673
00:25:46,320 --> 00:25:52,158
what's in the kernel but still if you

674
00:25:48,159 --> 00:25:55,520
wanted to run a bpf machine under gdb

675
00:25:52,159 --> 00:25:56,000
today you will have to turn to uh to one

676
00:25:55,520 --> 00:25:58,559
of these

677
00:25:56,000 --> 00:25:59,039
use space machines so ubpf especially is

678
00:25:58,559 --> 00:26:01,918
in c

679
00:25:59,039 --> 00:26:03,440
or bpf is in rust uh but otherwise

680
00:26:01,919 --> 00:26:07,679
they're pretty equivalent

681
00:26:03,440 --> 00:26:09,520
um there is a small debugger too i think

682
00:26:07,679 --> 00:26:11,679
it's step by step i don't remember it's

683
00:26:09,520 --> 00:26:15,360
a difficult tool but it's for

684
00:26:11,679 --> 00:26:18,400
legacy cbpf which is much simpler than

685
00:26:15,360 --> 00:26:22,559
ebps also simpler to debug

686
00:26:18,400 --> 00:26:26,400
and that's under the kernel repository

687
00:26:22,559 --> 00:26:28,399
so that's about it for uh

688
00:26:26,400 --> 00:26:29,760
loading and running bpf programs and

689
00:26:28,400 --> 00:26:34,320
just wanted to

690
00:26:29,760 --> 00:26:37,520
speak quickly about writing

691
00:26:34,320 --> 00:26:41,039
programs in user space to manage your

692
00:26:37,520 --> 00:26:43,918
ppf objects so um

693
00:26:41,039 --> 00:26:46,080
so what we want is the ability to debug

694
00:26:43,919 --> 00:26:48,000
such programs to uh to improve ppf

695
00:26:46,080 --> 00:26:49,918
support in the tool chain in general so

696
00:26:48,000 --> 00:26:52,080
we have

697
00:26:49,919 --> 00:26:54,240
the ability to use those frameworks that

698
00:26:52,080 --> 00:26:56,240
work already bcc bpf trace

699
00:26:54,240 --> 00:26:57,279
elipcoffee has a library i've been

700
00:26:56,240 --> 00:26:59,919
working for

701
00:26:57,279 --> 00:27:01,039
and that turns some featuring rules into

702
00:26:59,919 --> 00:27:02,640
bpf programs

703
00:27:01,039 --> 00:27:04,879
network filtering rules into bpf

704
00:27:02,640 --> 00:27:07,520
programs

705
00:27:04,880 --> 00:27:08,880
you have a leap bpf of course that can

706
00:27:07,520 --> 00:27:11,520
be used to

707
00:27:08,880 --> 00:27:12,400
implement your programs managing ppf

708
00:27:11,520 --> 00:27:16,240
objects

709
00:27:12,400 --> 00:27:20,480
uh you have a feature that allows you to

710
00:27:16,240 --> 00:27:23,679
dump the list of bpf related features

711
00:27:20,480 --> 00:27:25,279
on your system with bpf2 so that you can

712
00:27:23,679 --> 00:27:26,880
check what's available what program

713
00:27:25,279 --> 00:27:28,000
types are available what map types are

714
00:27:26,880 --> 00:27:31,120
available

715
00:27:28,000 --> 00:27:32,720
what bpf helpers even and if the

716
00:27:31,120 --> 00:27:35,840
bpfc is called in the first place you

717
00:27:32,720 --> 00:27:35,840
support it these kind of things

718
00:27:35,919 --> 00:27:40,640
since it's the debugging tool anyway we

719
00:27:37,919 --> 00:27:42,640
have support for bpf in s trace

720
00:27:40,640 --> 00:27:44,000
we have bpf support in valgrind although

721
00:27:42,640 --> 00:27:47,200
in valgrind i think it might

722
00:27:44,000 --> 00:27:50,320
be getting a bit outdated but

723
00:27:47,200 --> 00:27:52,960
s trace i think is mostly up to date uh

724
00:27:50,320 --> 00:27:55,039
so that's really nice to to have um

725
00:27:52,960 --> 00:27:57,200
especially when you're trying to

726
00:27:55,039 --> 00:27:59,360
to inject a program into the candle and

727
00:27:57,200 --> 00:28:00,080
you don't get much information you just

728
00:27:59,360 --> 00:28:03,678
get an

729
00:28:00,080 --> 00:28:07,279
error code and it turns out that

730
00:28:03,679 --> 00:28:10,000
your bpf2 program has been trying

731
00:28:07,279 --> 00:28:10,399
several different things like checking

732
00:28:10,000 --> 00:28:13,120
that

733
00:28:10,399 --> 00:28:13,918
basically i can inject a very simple

734
00:28:13,120 --> 00:28:16,479
program

735
00:28:13,919 --> 00:28:18,720
and then it tried to create a map and

736
00:28:16,480 --> 00:28:19,840
that at last it tried to inject your

737
00:28:18,720 --> 00:28:22,240
program so

738
00:28:19,840 --> 00:28:24,158
which of those different codes fade i'm

739
00:28:22,240 --> 00:28:24,960
not really sure so i can trace it with a

740
00:28:24,159 --> 00:28:28,240
stress

741
00:28:24,960 --> 00:28:31,360
uh that's very useful

742
00:28:28,240 --> 00:28:34,480
so that's it about the

743
00:28:31,360 --> 00:28:36,959
introspection debugging bpf in general i

744
00:28:34,480 --> 00:28:40,080
wanted to uh to talk a bit more about

745
00:28:36,960 --> 00:28:43,120
uh ppf tool because that's really

746
00:28:40,080 --> 00:28:44,320
useful to to do all those things not all

747
00:28:43,120 --> 00:28:47,439
of them but most of them

748
00:28:44,320 --> 00:28:50,080
so one of the

749
00:28:47,440 --> 00:28:50,640
i hope you can read at the back of the

750
00:28:50,080 --> 00:28:54,080
room

751
00:28:50,640 --> 00:28:55,360
one of the simplest function is listing

752
00:28:54,080 --> 00:28:56,879
the programs that are running on the

753
00:28:55,360 --> 00:29:00,639
system so i have epf 2

754
00:28:56,880 --> 00:29:03,840
prog show so this is a list of

755
00:29:00,640 --> 00:29:07,520
programs attached to um

756
00:29:03,840 --> 00:29:10,639
to circuit and in c groups so those

757
00:29:07,520 --> 00:29:13,120
first seven programs had actually been

758
00:29:10,640 --> 00:29:16,559
loaded by systemd on my system

759
00:29:13,120 --> 00:29:18,959
for fire rolling things

760
00:29:16,559 --> 00:29:20,080
and then at the end there is one program

761
00:29:18,960 --> 00:29:24,840
that i had

762
00:29:20,080 --> 00:29:28,158
added to but xp so networking processing

763
00:29:24,840 --> 00:29:30,799
um i can list those programs i can also

764
00:29:28,159 --> 00:29:32,159
dump the instructions so i can done the

765
00:29:30,799 --> 00:29:34,240
what we call the translating

766
00:29:32,159 --> 00:29:35,760
instructions that's after my program has

767
00:29:34,240 --> 00:29:37,840
been loaded into the kernel

768
00:29:35,760 --> 00:29:39,600
uh kernel verifies the program and does

769
00:29:37,840 --> 00:29:42,639
the number of rewrites

770
00:29:39,600 --> 00:29:45,600
and uh because of that there are some

771
00:29:42,640 --> 00:29:47,760
small changes possibly not in terms of

772
00:29:45,600 --> 00:29:50,158
um

773
00:29:47,760 --> 00:29:52,480
of the the logics of the program but

774
00:29:50,159 --> 00:29:54,640
just in terms of

775
00:29:52,480 --> 00:29:56,640
small offsets regarding to the different

776
00:29:54,640 --> 00:29:59,760
data structures being used

777
00:29:56,640 --> 00:30:01,600
uh so i can have just these

778
00:29:59,760 --> 00:30:03,200
uh instructions as they are in the

779
00:30:01,600 --> 00:30:06,240
program but i can also

780
00:30:03,200 --> 00:30:08,240
uh dump the cheated instructions so

781
00:30:06,240 --> 00:30:09,100
in the second case it was cheat compiled

782
00:30:08,240 --> 00:30:10,399
into

783
00:30:09,100 --> 00:30:13,520
[Applause]

784
00:30:10,399 --> 00:30:18,000
a native binary for for

785
00:30:13,520 --> 00:30:20,399
x86 and i can get all those instructions

786
00:30:18,000 --> 00:30:21,039
so that's that's interesting to to to

787
00:30:20,399 --> 00:30:24,239
see what's

788
00:30:21,039 --> 00:30:25,919
happening with the jet compiler i can

789
00:30:24,240 --> 00:30:28,799
load the program

790
00:30:25,919 --> 00:30:30,880
i can attach it to a variety of hooks i

791
00:30:28,799 --> 00:30:33,918
don't think i can attach it to

792
00:30:30,880 --> 00:30:34,840
k probes or trespawns with bpf2 at this

793
00:30:33,919 --> 00:30:38,159
time

794
00:30:34,840 --> 00:30:41,039
um so i have the

795
00:30:38,159 --> 00:30:42,880
related commands ppf2 pro load f2 proc

796
00:30:41,039 --> 00:30:45,200
attach

797
00:30:42,880 --> 00:30:48,159
c group attach and for networking that

798
00:30:45,200 --> 00:30:48,159
would be net attach

799
00:30:49,600 --> 00:30:56,080
i can work with maps too so i have ebf2

800
00:30:52,960 --> 00:31:00,559
map show to list the maps all those uh

801
00:30:56,080 --> 00:31:04,559
lpm try uh where were related to the

802
00:31:00,559 --> 00:31:07,039
systemd programs injected in my system

803
00:31:04,559 --> 00:31:07,600
i can look upon trees in maps so here's

804
00:31:07,039 --> 00:31:10,480
the case

805
00:31:07,600 --> 00:31:13,439
of a very simple array map and i'm

806
00:31:10,480 --> 00:31:15,919
dumping the content of

807
00:31:13,440 --> 00:31:16,720
the first entry so what we don't have

808
00:31:15,919 --> 00:31:20,080
here

809
00:31:16,720 --> 00:31:20,799
is uh btf which is missing with bit of

810
00:31:20,080 --> 00:31:23,600
information

811
00:31:20,799 --> 00:31:24,320
uh i would have more data than this i

812
00:31:23,600 --> 00:31:27,760
forgot to

813
00:31:24,320 --> 00:31:31,200
put the picture i would have the the

814
00:31:27,760 --> 00:31:33,600
fields of

815
00:31:31,200 --> 00:31:35,120
my entry so my entry here is a comes

816
00:31:33,600 --> 00:31:37,360
from a c struct with a

817
00:31:35,120 --> 00:31:38,959
number of fields of attributes and i

818
00:31:37,360 --> 00:31:40,559
would have the name of the attributes

819
00:31:38,960 --> 00:31:44,840
and the values beside them

820
00:31:40,559 --> 00:31:47,279
instead of just a blob of hexadecimal

821
00:31:44,840 --> 00:31:50,799
values so i can

822
00:31:47,279 --> 00:31:53,279
dump the full map at once too

823
00:31:50,799 --> 00:31:55,760
i can update an entry in the map or

824
00:31:53,279 --> 00:31:58,559
delete an entry in the map too

825
00:31:55,760 --> 00:31:59,360
it even works for some specific more

826
00:31:58,559 --> 00:32:01,600
specific

827
00:31:59,360 --> 00:32:03,279
map dives such as the one used for

828
00:32:01,600 --> 00:32:05,039
jumping from one program into another

829
00:32:03,279 --> 00:32:08,960
one you have this kind of features

830
00:32:05,039 --> 00:32:11,279
and bpf2 is uh really helpful to to just

831
00:32:08,960 --> 00:32:13,840
update the map i'm sorry this picture is

832
00:32:11,279 --> 00:32:16,880
really small i'm not sure why

833
00:32:13,840 --> 00:32:19,039
so the idea is what i presented earlier

834
00:32:16,880 --> 00:32:20,559
can i zoom on that

835
00:32:19,039 --> 00:32:22,158
i don't know how to zoom on that i'm

836
00:32:20,559 --> 00:32:24,559
sorry

837
00:32:22,159 --> 00:32:26,320
so it shows a list of bpf features

838
00:32:24,559 --> 00:32:29,360
spotted on the system so

839
00:32:26,320 --> 00:32:31,439
first one is beef pfc is called uh

840
00:32:29,360 --> 00:32:33,918
from privileged users is enabled on that

841
00:32:31,440 --> 00:32:36,159
system cheat compiler is teasable

842
00:32:33,919 --> 00:32:37,200
and so on and so forth we have a number

843
00:32:36,159 --> 00:32:40,240
of uh

844
00:32:37,200 --> 00:32:42,320
bpf related config options uh for

845
00:32:40,240 --> 00:32:44,080
uh that were used when compiling the

846
00:32:42,320 --> 00:32:46,480
kernel so that we know

847
00:32:44,080 --> 00:32:48,639
what bpa features will be available and

848
00:32:46,480 --> 00:32:51,039
all that can be reused when you uh

849
00:32:48,640 --> 00:32:54,240
when you write user space programs uh

850
00:32:51,039 --> 00:32:54,240
working with bps stuff

851
00:32:54,840 --> 00:33:02,320
yeah so this

852
00:32:57,840 --> 00:33:05,840
is uh not too big but not a small

853
00:33:02,320 --> 00:33:06,960
picture of a bpf program so what i'm

854
00:33:05,840 --> 00:33:10,320
doing here is

855
00:33:06,960 --> 00:33:10,799
uh just running a test run of a program

856
00:33:10,320 --> 00:33:13,200
i've

857
00:33:10,799 --> 00:33:14,158
loaded previously into the kernel so i'm

858
00:33:13,200 --> 00:33:17,360
providing

859
00:33:14,159 --> 00:33:20,159
so i have epf2 program this is a handle

860
00:33:17,360 --> 00:33:20,158
to my program

861
00:33:20,559 --> 00:33:27,440
i'm providing input data data in and

862
00:33:24,080 --> 00:33:30,639
my input file data out and dash to tell

863
00:33:27,440 --> 00:33:33,120
it to do to dump into the console and i

864
00:33:30,640 --> 00:33:36,320
want to run that program 10 times

865
00:33:33,120 --> 00:33:38,479
so i get here the output data hello

866
00:33:36,320 --> 00:33:40,639
twitter that was because i wanted to put

867
00:33:38,480 --> 00:33:42,799
that in a in a tweet

868
00:33:40,640 --> 00:33:45,120
written value of the program is zero and

869
00:33:42,799 --> 00:33:47,679
i have the duration on average of those

870
00:33:45,120 --> 00:33:51,760
ten runs

871
00:33:47,679 --> 00:33:54,559
so here it is four four four

872
00:33:51,760 --> 00:33:56,720
test runs so some additional features

873
00:33:54,559 --> 00:34:00,320
for bpf2

874
00:33:56,720 --> 00:34:02,240
without any screenshots because they're

875
00:34:00,320 --> 00:34:05,439
too small anyway

876
00:34:02,240 --> 00:34:07,200
so we can list programs per c group per

877
00:34:05,440 --> 00:34:09,119
network interface to

878
00:34:07,200 --> 00:34:10,560
purchasing hooks so we can really

879
00:34:09,119 --> 00:34:14,079
inspect at that

880
00:34:10,560 --> 00:34:16,639
tracing hook what do i have we can

881
00:34:14,079 --> 00:34:18,399
load several programs at once especially

882
00:34:16,639 --> 00:34:19,679
useful when you have a number of

883
00:34:18,399 --> 00:34:21,279
programs with

884
00:34:19,679 --> 00:34:23,880
what we call tail calls and you jump

885
00:34:21,280 --> 00:34:25,359
from one into the other one

886
00:34:23,880 --> 00:34:28,720
[Music]

887
00:34:25,359 --> 00:34:30,719
we can dump directly into the console

888
00:34:28,719 --> 00:34:34,560
the output of bpf trace print k

889
00:34:30,719 --> 00:34:38,239
we can dump from birth event maps

890
00:34:34,560 --> 00:34:40,000
uh there's a thing about a generation of

891
00:34:38,239 --> 00:34:44,078
a skeleton header file

892
00:34:40,000 --> 00:34:45,839
uh for um for for

893
00:34:44,079 --> 00:34:47,839
for helping with writing programs for

894
00:34:45,839 --> 00:34:48,399
managing bpf objects but that's pretty

895
00:34:47,839 --> 00:34:51,279
new

896
00:34:48,399 --> 00:34:54,000
we have batch mode we have json support

897
00:34:51,280 --> 00:34:57,040
which is pretty nice

898
00:34:54,000 --> 00:34:58,960
bash completion and more so i had made a

899
00:34:57,040 --> 00:35:00,079
twitter thread if you want to look into

900
00:34:58,960 --> 00:35:02,000
that

901
00:35:00,079 --> 00:35:03,599
more information obviously there is some

902
00:35:02,000 --> 00:35:06,720
documentation for bpf2

903
00:35:03,599 --> 00:35:09,440
at least we have man bpf tool and

904
00:35:06,720 --> 00:35:11,520
uh different uh man pages for the

905
00:35:09,440 --> 00:35:14,000
different subcommands so bpf2

906
00:35:11,520 --> 00:35:15,680
pro bpf tool map and so on

907
00:35:14,000 --> 00:35:19,119
[Music]

908
00:35:15,680 --> 00:35:22,319
so here you are ready to use bpf2 now

909
00:35:19,119 --> 00:35:24,960
uh it's it's been packaged now on fedora

910
00:35:22,320 --> 00:35:28,640
and ubuntu too on the latest ones

911
00:35:24,960 --> 00:35:33,200
i think it should be added to latino for

912
00:35:28,640 --> 00:35:36,640
some some time otherwise ppf2 is uh

913
00:35:33,200 --> 00:35:40,720
is located under the kernel repository

914
00:35:36,640 --> 00:35:41,680
uh a few words about what's coming next

915
00:35:40,720 --> 00:35:45,118
for bpf

916
00:35:41,680 --> 00:35:48,078
debugging so we want to add

917
00:35:45,119 --> 00:35:49,920
more stuff to debug like can we have

918
00:35:48,079 --> 00:35:52,880
more modular programs with

919
00:35:49,920 --> 00:35:53,440
more modular curves between programs uh

920
00:35:52,880 --> 00:35:55,040
so

921
00:35:53,440 --> 00:35:57,200
there is something that was added very

922
00:35:55,040 --> 00:35:59,200
recently to the channel

923
00:35:57,200 --> 00:36:01,040
for having that could could that help

924
00:35:59,200 --> 00:36:03,839
with for debug maybe

925
00:36:01,040 --> 00:36:06,160
uh there is a discussion about adding

926
00:36:03,839 --> 00:36:09,359
more information to the csfs

927
00:36:06,160 --> 00:36:11,440
uh system file uh and also

928
00:36:09,359 --> 00:36:14,400
a discussion about improvements for the

929
00:36:11,440 --> 00:36:17,119
test run feature

930
00:36:14,400 --> 00:36:18,160
it would be really really oh so nice to

931
00:36:17,119 --> 00:36:21,200
have a real

932
00:36:18,160 --> 00:36:22,960
step-by-step debugger for bpf

933
00:36:21,200 --> 00:36:25,118
we don't have that at the moment but

934
00:36:22,960 --> 00:36:27,920
people are really thinking into

935
00:36:25,119 --> 00:36:29,200
into that so how can we do that should

936
00:36:27,920 --> 00:36:34,079
we

937
00:36:29,200 --> 00:36:34,078
sorry white betray

938
00:36:36,320 --> 00:36:41,119
where is p3 i i don't know betrays

939
00:36:40,240 --> 00:36:42,959
enough to

940
00:36:41,119 --> 00:36:44,880
to know if that would work that's uh

941
00:36:42,960 --> 00:36:47,520
that's an idea maybe

942
00:36:44,880 --> 00:36:47,520
so we have a

943
00:36:48,560 --> 00:36:54,320
yeah we should we should talk about that

944
00:36:52,240 --> 00:36:56,879
so here are some uh some ideas that were

945
00:36:54,320 --> 00:36:58,880
proposed uh besides speedtrace

946
00:36:56,880 --> 00:37:00,640
uh running a program in the vm freezing

947
00:36:58,880 --> 00:37:03,440
and freezing it is that doable

948
00:37:00,640 --> 00:37:03,839
extend the bpf processor and interface

949
00:37:03,440 --> 00:37:06,560
uh

950
00:37:03,839 --> 00:37:09,279
attach k probes to every single

951
00:37:06,560 --> 00:37:13,040
instructions is that something doable

952
00:37:09,280 --> 00:37:15,200
that's just leads to explore for now uh

953
00:37:13,040 --> 00:37:16,800
we would like i would like at least have

954
00:37:15,200 --> 00:37:20,560
an updated documentation

955
00:37:16,800 --> 00:37:23,359
uh because what's existing is

956
00:37:20,560 --> 00:37:24,160
not always up to date and i definitely

957
00:37:23,359 --> 00:37:27,759
think we would

958
00:37:24,160 --> 00:37:29,279
beneficiate from a real troubleshooting

959
00:37:27,760 --> 00:37:32,560
guide that would tell you

960
00:37:29,280 --> 00:37:34,640
uh this error is often related to

961
00:37:32,560 --> 00:37:36,640
uh that thing in your source code that

962
00:37:34,640 --> 00:37:40,240
you should should change to

963
00:37:36,640 --> 00:37:41,680
that other thing so again in particular

964
00:37:40,240 --> 00:37:44,799
the things about

965
00:37:41,680 --> 00:37:46,720
step-by-step debugging and ccfs

966
00:37:44,800 --> 00:37:48,839
are being proposed to the next dev

967
00:37:46,720 --> 00:37:51,759
conference in march

968
00:37:48,839 --> 00:37:55,599
uh so to conclude

969
00:37:51,760 --> 00:37:57,520
uh debugging bpf programs is not trivial

970
00:37:55,599 --> 00:37:59,839
we don't have a step-by-step debugger

971
00:37:57,520 --> 00:38:01,520
yet but the tooling is getting better

972
00:37:59,839 --> 00:38:04,720
and better we have more tools

973
00:38:01,520 --> 00:38:07,599
more efficient we can dump instructions

974
00:38:04,720 --> 00:38:09,520
and map contents at any stage of the

975
00:38:07,599 --> 00:38:11,599
workflow we can print data

976
00:38:09,520 --> 00:38:15,440
when the program's running we can do

977
00:38:11,599 --> 00:38:19,599
test runs in the kernel we can run

978
00:38:15,440 --> 00:38:20,560
in user space vms that's not the best we

979
00:38:19,599 --> 00:38:23,119
can do but

980
00:38:20,560 --> 00:38:23,920
that can help debugging what's happening

981
00:38:23,119 --> 00:38:27,359
uh

982
00:38:23,920 --> 00:38:31,280
vpf itself can be used to um to

983
00:38:27,359 --> 00:38:33,598
to inspect other programs

984
00:38:31,280 --> 00:38:35,520
which is really nice we have the should

985
00:38:33,599 --> 00:38:38,640
have added here the btf

986
00:38:35,520 --> 00:38:40,320
uh debug info format that's being used

987
00:38:38,640 --> 00:38:43,520
to provide more information so

988
00:38:40,320 --> 00:38:46,000
all of this is it's here it's already

989
00:38:43,520 --> 00:38:48,800
very good and hopefully we will have

990
00:38:46,000 --> 00:38:52,160
better things in the future too

991
00:38:48,800 --> 00:38:55,280
so fingers crossed and that's it for my

992
00:38:52,160 --> 00:38:55,279
presentation thank you

993
00:38:58,079 --> 00:39:01,200
so i don't know if you have time for

994
00:39:00,000 --> 00:39:04,720
questions

995
00:39:01,200 --> 00:39:10,078
quick okay so yeah

996
00:39:04,720 --> 00:39:10,078
so if i want to generate code by myself

997
00:39:11,930 --> 00:39:15,520
[Music]

998
00:39:13,520 --> 00:39:16,880
you you can if you want to generate it

999
00:39:15,520 --> 00:39:19,839
yourself

1000
00:39:16,880 --> 00:39:19,839
so the question is

1001
00:39:21,520 --> 00:39:24,800
so so if you want to code your own bpf

1002
00:39:24,000 --> 00:39:28,160
uh

1003
00:39:24,800 --> 00:39:32,079
assembler program you can do that uh

1004
00:39:28,160 --> 00:39:34,078
you might hit a number of uh

1005
00:39:32,079 --> 00:39:35,359
issues not on basic program it will work

1006
00:39:34,079 --> 00:39:38,640
for basic programs

1007
00:39:35,359 --> 00:39:40,640
not using uh advanced features but if

1008
00:39:38,640 --> 00:39:42,078
you're trying to use a btf debugging

1009
00:39:40,640 --> 00:39:46,160
information for example

1010
00:39:42,079 --> 00:39:48,320
are more advanced

1011
00:39:46,160 --> 00:39:50,078
calls from one program to the other one

1012
00:39:48,320 --> 00:39:51,440
there is a number of things that are

1013
00:39:50,079 --> 00:39:54,079
happening

1014
00:39:51,440 --> 00:39:54,640
when i mentioned health relocation stuff

1015
00:39:54,079 --> 00:39:56,480
and

1016
00:39:54,640 --> 00:39:58,240
this is getting more and more complex so

1017
00:39:56,480 --> 00:40:01,680
you could re-implement that

1018
00:39:58,240 --> 00:40:03,598
but that would not be trivial so lee bpf

1019
00:40:01,680 --> 00:40:06,399
is really a reference here

1020
00:40:03,599 --> 00:40:09,440
uh it doesn't prevent you to work on

1021
00:40:06,400 --> 00:40:12,160
your side with another bps assembler but

1022
00:40:09,440 --> 00:40:13,839
for more complex stuff you will have

1023
00:40:12,160 --> 00:40:16,160
more work to do and more time to spend

1024
00:40:13,839 --> 00:40:16,160
on that

1025
00:40:18,000 --> 00:40:25,839
other questions yes

1026
00:40:31,760 --> 00:40:36,839
is it possible to to manage a hardware

1027
00:40:34,560 --> 00:40:40,160
interrupt from bpf program

1028
00:40:36,839 --> 00:40:41,920
i don't think so

1029
00:40:40,160 --> 00:40:43,680
i'm not sure i don't think so you don't

1030
00:40:41,920 --> 00:40:46,480
have a hook on that i think

1031
00:40:43,680 --> 00:40:46,480
so i would say no

1032
00:40:47,119 --> 00:40:54,400
there was another question at the back

1033
00:40:50,839 --> 00:40:54,400
yeah i'm sorry

1034
00:41:01,040 --> 00:41:07,839
can you can you speak louder come over

1035
00:41:04,839 --> 00:41:07,839
here

1036
00:41:22,160 --> 00:41:26,240
yeah so so how big is uh is a network

1037
00:41:25,359 --> 00:41:29,200
programming

1038
00:41:26,240 --> 00:41:29,598
bpa is a network bpa program on average

1039
00:41:29,200 --> 00:41:32,640
uh

1040
00:41:29,599 --> 00:41:34,720
it was limited to 4k instructions before

1041
00:41:32,640 --> 00:41:36,000
now it's limited to up to 1 million

1042
00:41:34,720 --> 00:41:37,200
instructions but that's

1043
00:41:36,000 --> 00:41:40,800
not really true because that's the

1044
00:41:37,200 --> 00:41:42,240
number of instructions that the verifier

1045
00:41:40,800 --> 00:41:43,839
can check and it checks some

1046
00:41:42,240 --> 00:41:46,720
instructions several times

1047
00:41:43,839 --> 00:41:48,000
and so the average it's hard to tell

1048
00:41:46,720 --> 00:41:50,640
because it depends on what you're

1049
00:41:48,000 --> 00:41:51,599
running uh but the 4k limitations was

1050
00:41:50,640 --> 00:41:53,359
definitely

1051
00:41:51,599 --> 00:41:55,280
a hard limit to some people and they

1052
00:41:53,359 --> 00:41:57,119
want you to have more than that

1053
00:41:55,280 --> 00:41:58,480
that's also why you can jump from one

1054
00:41:57,119 --> 00:42:02,000
program to another one

1055
00:41:58,480 --> 00:42:03,680
uh one one motivation was to circumvent

1056
00:42:02,000 --> 00:42:07,359
that limitation

1057
00:42:03,680 --> 00:42:11,040
so i don't have a number in mind but

1058
00:42:07,359 --> 00:42:13,920
programs can range to a few

1059
00:42:11,040 --> 00:42:16,079
a few dozen instructions to thousands

1060
00:42:13,920 --> 00:42:17,680
and thousands of instruction now so

1061
00:42:16,079 --> 00:42:20,319
it really depends on the complexity of

1062
00:42:17,680 --> 00:42:20,319
your programs

1063
00:42:21,200 --> 00:42:29,279
you're welcome

