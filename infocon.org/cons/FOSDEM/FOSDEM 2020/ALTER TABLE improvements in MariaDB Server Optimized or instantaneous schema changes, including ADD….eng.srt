1
00:00:05,440 --> 00:00:10,480
so marco it's all yours

2
00:00:07,759 --> 00:00:12,000
okay my name is marco makara i have been

3
00:00:10,480 --> 00:00:15,280
working on

4
00:00:12,000 --> 00:00:19,359
inno db since i joined innobase

5
00:00:15,280 --> 00:00:23,520
company in 2003 and before that i was

6
00:00:19,359 --> 00:00:23,520
using linux from

7
00:00:23,960 --> 00:00:29,760
1993 i think so i have

8
00:00:27,359 --> 00:00:30,880
some background in in free software and

9
00:00:29,760 --> 00:00:34,320
open source

10
00:00:30,880 --> 00:00:37,519
and since 2016 december

11
00:00:34,320 --> 00:00:40,640
i have been working for maria db

12
00:00:37,520 --> 00:00:41,200
until then i was working at at the inno

13
00:00:40,640 --> 00:00:45,120
base and

14
00:00:41,200 --> 00:00:48,320
later oracle and later mysql

15
00:00:45,120 --> 00:00:50,879
department and today i will talk about

16
00:00:48,320 --> 00:00:53,520
outer table improvements in mysql and

17
00:00:50,879 --> 00:00:53,519
mariadb

18
00:00:54,000 --> 00:00:59,199
oh let's see this is how the slide

19
00:00:56,960 --> 00:01:02,879
changes so in the beginning there was

20
00:00:59,199 --> 00:01:05,360
only only this generic

21
00:01:02,879 --> 00:01:06,240
form of outer table which would

22
00:01:05,360 --> 00:01:11,840
internally

23
00:01:06,240 --> 00:01:13,839
create a new table corresponding to the

24
00:01:11,840 --> 00:01:14,960
requested change the table definition

25
00:01:13,840 --> 00:01:17,920
and then copy

26
00:01:14,960 --> 00:01:19,600
all the rows one row by one from the old

27
00:01:17,920 --> 00:01:22,720
table to the new table

28
00:01:19,600 --> 00:01:25,199
and then finally rename the old table

29
00:01:22,720 --> 00:01:26,798
to a temporary name and rename the

30
00:01:25,200 --> 00:01:27,759
intermediate copy of the table the

31
00:01:26,799 --> 00:01:31,280
original name and

32
00:01:27,759 --> 00:01:33,600
drop the original table and

33
00:01:31,280 --> 00:01:34,640
starting with the mysql 5 6 and marily

34
00:01:33,600 --> 00:01:37,679
b10

35
00:01:34,640 --> 00:01:40,159
this fallback mechanism

36
00:01:37,680 --> 00:01:41,840
is called algorithm equals copy so you

37
00:01:40,159 --> 00:01:45,520
can explicitly request it

38
00:01:41,840 --> 00:01:48,640
to have that form of the table

39
00:01:45,520 --> 00:01:51,759
and until mysql 800 and

40
00:01:48,640 --> 00:01:54,000
rdb102 this is creating unnecessary

41
00:01:51,759 --> 00:01:55,439
undo logging while it's internally

42
00:01:54,000 --> 00:01:57,840
copying this table

43
00:01:55,439 --> 00:01:59,919
one row by row it's creating undo log

44
00:01:57,840 --> 00:02:02,960
for each row that it's copying

45
00:01:59,920 --> 00:02:05,759
so in case you kill the server

46
00:02:02,960 --> 00:02:06,559
and it restarts the server will roll

47
00:02:05,759 --> 00:02:08,959
back

48
00:02:06,560 --> 00:02:10,800
the insert into this intermediate table

49
00:02:08,959 --> 00:02:12,480
which should not be visible to the user

50
00:02:10,800 --> 00:02:15,520
in the first place

51
00:02:12,480 --> 00:02:17,760
so we had a hack hekitori the creator of

52
00:02:15,520 --> 00:02:18,560
innodb asked me to do this stupid hack

53
00:02:17,760 --> 00:02:21,280
that

54
00:02:18,560 --> 00:02:23,040
let's commit the insert for every 10 000

55
00:02:21,280 --> 00:02:24,080
copied rows so that the rollback will be

56
00:02:23,040 --> 00:02:27,679
faster

57
00:02:24,080 --> 00:02:29,680
but then after a while i thought that

58
00:02:27,680 --> 00:02:31,680
maybe we should fix that and not write

59
00:02:29,680 --> 00:02:34,319
those unnecessary undo lock records in

60
00:02:31,680 --> 00:02:37,840
the first place so that's what we did in

61
00:02:34,319 --> 00:02:42,399
mascara 8-0 before i left the oracle and

62
00:02:37,840 --> 00:02:42,400
we also back-bodied that to marily b-102

63
00:02:43,200 --> 00:02:49,920
and this is copying the data

64
00:02:46,720 --> 00:02:51,040
one table row at a time for each in each

65
00:02:49,920 --> 00:02:53,679
index

66
00:02:51,040 --> 00:02:56,319
so it's there is no sorting taking place

67
00:02:53,680 --> 00:02:59,680
so it will basically insert the data

68
00:02:56,319 --> 00:03:01,518
in random order to each index not very

69
00:02:59,680 --> 00:03:03,840
efficient

70
00:03:01,519 --> 00:03:05,040
and then we got this native outer table

71
00:03:03,840 --> 00:03:08,400
it started with the

72
00:03:05,040 --> 00:03:11,359
enodb plugin for mysql51 that was

73
00:03:08,400 --> 00:03:12,159
published when oracle had acquired

74
00:03:11,360 --> 00:03:15,360
innobase

75
00:03:12,159 --> 00:03:17,120
but but mysql was

76
00:03:15,360 --> 00:03:19,360
still an independent company later my

77
00:03:17,120 --> 00:03:22,400
school was bought by sun and

78
00:03:19,360 --> 00:03:23,599
sun by oracle but this this was very

79
00:03:22,400 --> 00:03:27,920
very old times

80
00:03:23,599 --> 00:03:28,959
like maybe 2004 or five something like

81
00:03:27,920 --> 00:03:32,319
that

82
00:03:28,959 --> 00:03:35,120
so in there we had this at

83
00:03:32,319 --> 00:03:36,798
secondary indexes unique or non-unique

84
00:03:35,120 --> 00:03:37,599
secondary indexes or you could add

85
00:03:36,799 --> 00:03:39,519
primary key

86
00:03:37,599 --> 00:03:41,839
to a table and that would be done

87
00:03:39,519 --> 00:03:44,480
natively inside innodb

88
00:03:41,840 --> 00:03:45,599
and this is pre-sorting all the data and

89
00:03:44,480 --> 00:03:48,319
it's a

90
00:03:45,599 --> 00:03:52,319
inserting the data in sorted order into

91
00:03:48,319 --> 00:03:52,319
each index and it's not writing undo log

92
00:03:52,959 --> 00:03:59,519
in mask 5.6 we got

93
00:03:56,400 --> 00:04:04,080
more features to that you can also

94
00:03:59,519 --> 00:04:05,920
add or drop columns or you can

95
00:04:04,080 --> 00:04:08,159
drop primary key and at the same time

96
00:04:05,920 --> 00:04:11,040
add a different primary key

97
00:04:08,159 --> 00:04:11,920
and you can change the column to accept

98
00:04:11,040 --> 00:04:14,959
or not accept

99
00:04:11,920 --> 00:04:17,120
null values and all this can be done

100
00:04:14,959 --> 00:04:20,320
by rebuilding the table but using this

101
00:04:17,120 --> 00:04:23,520
native algorithm to rebuild it

102
00:04:20,320 --> 00:04:24,560
and some operations with this algorithm

103
00:04:23,520 --> 00:04:26,719
in place which

104
00:04:24,560 --> 00:04:28,560
scene that was introduced in five six

105
00:04:26,720 --> 00:04:31,919
and which is chosen by default when

106
00:04:28,560 --> 00:04:33,759
when that's when it's possible some

107
00:04:31,919 --> 00:04:35,599
operations are instantaneous for example

108
00:04:33,759 --> 00:04:38,479
if you rename a column

109
00:04:35,600 --> 00:04:40,240
previously it would use the algorithm

110
00:04:38,479 --> 00:04:42,159
copy to copy your

111
00:04:40,240 --> 00:04:43,360
huge table just because you wanted to

112
00:04:42,160 --> 00:04:45,600
rename a column

113
00:04:43,360 --> 00:04:48,320
but starting with mysql file six and

114
00:04:45,600 --> 00:04:50,320
marily b10 it will just

115
00:04:48,320 --> 00:04:51,520
change the column name both in the fram

116
00:04:50,320 --> 00:04:54,240
file and and in the

117
00:04:51,520 --> 00:04:56,000
innodb internal data dictionary or if

118
00:04:54,240 --> 00:04:58,320
you change the default value of a column

119
00:04:56,000 --> 00:05:00,240
in odp doesn't actually care about the

120
00:04:58,320 --> 00:05:00,960
default value at all it doesn't store it

121
00:05:00,240 --> 00:05:04,080
anywhere

122
00:05:00,960 --> 00:05:05,840
so in that case you don't need to update

123
00:05:04,080 --> 00:05:08,639
the frame file

124
00:05:05,840 --> 00:05:09,359
some people call this native algorithm

125
00:05:08,639 --> 00:05:12,000
in place

126
00:05:09,360 --> 00:05:13,120
they call it the online author even when

127
00:05:12,000 --> 00:05:16,160
there is no

128
00:05:13,120 --> 00:05:16,720
online operation going on like there is

129
00:05:16,160 --> 00:05:20,080
no

130
00:05:16,720 --> 00:05:22,880
concurrent insert or update or delete by

131
00:05:20,080 --> 00:05:23,440
other connections or or it's not allowed

132
00:05:22,880 --> 00:05:26,240
because

133
00:05:23,440 --> 00:05:27,840
in some cases we don't allow online

134
00:05:26,240 --> 00:05:30,320
author for example if you add an

135
00:05:27,840 --> 00:05:32,638
auto increment column to a table it's

136
00:05:30,320 --> 00:05:35,520
not possible to do that online because

137
00:05:32,639 --> 00:05:36,639
you have to assign new values for the

138
00:05:35,520 --> 00:05:38,320
outer increment column

139
00:05:36,639 --> 00:05:40,160
and if you are at the same time allowing

140
00:05:38,320 --> 00:05:42,240
concurrent updates while

141
00:05:40,160 --> 00:05:43,639
while this alter is running it's simply

142
00:05:42,240 --> 00:05:45,840
not possible to

143
00:05:43,639 --> 00:05:48,639
deterministically assign those auto

144
00:05:45,840 --> 00:05:48,638
increment values

145
00:05:50,720 --> 00:05:56,960
in moscow five seven and marily b102

146
00:05:54,960 --> 00:05:59,359
we got the bulk in this creation this is

147
00:05:56,960 --> 00:06:00,960
something that i didn't develop i i was

148
00:05:59,360 --> 00:06:03,199
uh

149
00:06:00,960 --> 00:06:05,120
slightly involved with the design i

150
00:06:03,199 --> 00:06:08,160
suggested that uh

151
00:06:05,120 --> 00:06:10,960
that we could skip the redo logging

152
00:06:08,160 --> 00:06:12,800
for for the pages that we are writing

153
00:06:10,960 --> 00:06:15,840
when we are creating the indexes

154
00:06:12,800 --> 00:06:18,160
and i think that in retrospect it turned

155
00:06:15,840 --> 00:06:22,159
out to be a mistake because it's a

156
00:06:18,160 --> 00:06:24,880
complicating online backup in mariadb

157
00:06:22,160 --> 00:06:26,800
we have maria backup has an option that

158
00:06:24,880 --> 00:06:29,759
if it detects that the table

159
00:06:26,800 --> 00:06:30,240
was being altered during the backup then

160
00:06:29,759 --> 00:06:32,720
it will

161
00:06:30,240 --> 00:06:34,160
recopy the data file at the end that's

162
00:06:32,720 --> 00:06:36,080
one way of doing it but we also

163
00:06:34,160 --> 00:06:37,919
introduced in mariadb this option inno

164
00:06:36,080 --> 00:06:40,800
db lock optimized

165
00:06:37,919 --> 00:06:42,880
ddl which you can set to off it's on by

166
00:06:40,800 --> 00:06:45,840
default for compatibility but you can

167
00:06:42,880 --> 00:06:48,719
disable it so that your backups will

168
00:06:45,840 --> 00:06:51,758
work based on the redo log

169
00:06:48,720 --> 00:06:52,400
but the main change there is that it's

170
00:06:51,759 --> 00:06:54,720
building

171
00:06:52,400 --> 00:06:56,239
the index is one leave page at the time

172
00:06:54,720 --> 00:06:59,360
instead of inserting

173
00:06:56,240 --> 00:07:01,840
records one record at a time

174
00:06:59,360 --> 00:07:02,400
and then doing page splits and so on

175
00:07:01,840 --> 00:07:04,560
it's

176
00:07:02,400 --> 00:07:06,239
first building the leaf pages and then

177
00:07:04,560 --> 00:07:07,919
building the upper level pages so it's a

178
00:07:06,240 --> 00:07:12,240
little bit

179
00:07:07,919 --> 00:07:12,240
more a little more efficient

180
00:07:12,560 --> 00:07:16,319
i would claim that some features in

181
00:07:14,720 --> 00:07:20,080
mysql five six and five

182
00:07:16,319 --> 00:07:22,960
seven are are a bit incomplete or

183
00:07:20,080 --> 00:07:23,680
or half baked because they don't support

184
00:07:22,960 --> 00:07:27,440
the native

185
00:07:23,680 --> 00:07:30,080
outer table to full extent

186
00:07:27,440 --> 00:07:31,840
so if you have multiple full text

187
00:07:30,080 --> 00:07:34,719
indexes in your table and you

188
00:07:31,840 --> 00:07:35,520
need to rebuild the table it will be

189
00:07:34,720 --> 00:07:37,680
refused

190
00:07:35,520 --> 00:07:38,560
because there is some artificial

191
00:07:37,680 --> 00:07:40,400
limitation that

192
00:07:38,560 --> 00:07:41,840
you can only create one full text index

193
00:07:40,400 --> 00:07:44,080
at a time

194
00:07:41,840 --> 00:07:46,960
so if you need table rebuild it will go

195
00:07:44,080 --> 00:07:50,560
to do algorithm copy

196
00:07:46,960 --> 00:07:50,878
and also in five seven some combinations

197
00:07:50,560 --> 00:07:53,199
of

198
00:07:50,879 --> 00:07:54,240
operations involving virtual columns are

199
00:07:53,199 --> 00:07:57,280
not allowed

200
00:07:54,240 --> 00:07:58,080
i would say that it's only due to that

201
00:07:57,280 --> 00:08:03,039
implementation

202
00:07:58,080 --> 00:08:03,039
of the virtual column feature in mysql57

203
00:08:05,039 --> 00:08:08,960
okay then as a special case of a native

204
00:08:08,400 --> 00:08:12,000
author

205
00:08:08,960 --> 00:08:12,719
we have online outer table mariodb has

206
00:08:12,000 --> 00:08:16,800
the syntax

207
00:08:12,720 --> 00:08:17,280
outer online table originally in mysql56

208
00:08:16,800 --> 00:08:20,000
it's called

209
00:08:17,280 --> 00:08:22,000
other table and then you can explicitly

210
00:08:20,000 --> 00:08:23,759
specify lock equals none if you

211
00:08:22,000 --> 00:08:27,680
want the operation to fail if it can't

212
00:08:23,759 --> 00:08:30,160
be performed online

213
00:08:27,680 --> 00:08:32,640
so two kinds of operations are allowed

214
00:08:30,160 --> 00:08:36,080
online you can add secondary indexes

215
00:08:32,640 --> 00:08:38,799
or you can rebuild the table

216
00:08:36,080 --> 00:08:41,680
there is even this keyword force if you

217
00:08:38,799 --> 00:08:44,399
want to request the table to be rebuilt

218
00:08:41,679 --> 00:08:46,800
even if it if the reboot wouldn't be

219
00:08:44,399 --> 00:08:49,200
needed otherwise

220
00:08:46,800 --> 00:08:51,519
and this online alter is not implemented

221
00:08:49,200 --> 00:08:53,760
for full text or spatial indexes

222
00:08:51,519 --> 00:08:55,360
i would claim that these indexes are

223
00:08:53,760 --> 00:08:57,920
very buggy we have

224
00:08:55,360 --> 00:08:58,399
fixed some or several hangs for full

225
00:08:57,920 --> 00:09:01,839
text

226
00:08:58,399 --> 00:09:05,360
indexes shut down hanks and tanks during

227
00:09:01,839 --> 00:09:07,760
uh server normal operation in mariadb

228
00:09:05,360 --> 00:09:09,040
and there is still no end in sight for

229
00:09:07,760 --> 00:09:11,760
full text index bugs

230
00:09:09,040 --> 00:09:13,040
also for spatial index we have a test

231
00:09:11,760 --> 00:09:16,800
that has a

232
00:09:13,040 --> 00:09:20,079
concurrent rollback and mvcc read

233
00:09:16,800 --> 00:09:22,240
and it's occasionally returning

234
00:09:20,080 --> 00:09:23,839
wrong results so i think that the

235
00:09:22,240 --> 00:09:26,240
spatial index has

236
00:09:23,839 --> 00:09:28,320
some design problems i wouldn't

237
00:09:26,240 --> 00:09:30,000
recommend using them

238
00:09:28,320 --> 00:09:32,399
so those are not supported by online

239
00:09:30,000 --> 00:09:32,399
alter

240
00:09:33,279 --> 00:09:37,839
now next section of my talk is about

241
00:09:35,360 --> 00:09:41,600
instant altar what can you do

242
00:09:37,839 --> 00:09:41,600
without spending much time

243
00:09:42,240 --> 00:09:45,680
and without changing the existing data

244
00:09:44,240 --> 00:09:48,160
format

245
00:09:45,680 --> 00:09:48,719
so in 5 6 and 10 0 you could rename

246
00:09:48,160 --> 00:09:50,399
columns

247
00:09:48,720 --> 00:09:52,240
and you could change the default value

248
00:09:50,399 --> 00:09:52,959
not very fancy but still better than

249
00:09:52,240 --> 00:09:55,440
nothing

250
00:09:52,959 --> 00:09:57,119
and five seven you could extend work

251
00:09:55,440 --> 00:10:00,080
columns in some cases

252
00:09:57,120 --> 00:10:00,560
there is a bit too strict limitation

253
00:10:00,080 --> 00:10:03,519
that

254
00:10:00,560 --> 00:10:05,119
if you extend the column from less than

255
00:10:03,519 --> 00:10:07,600
256 bytes

256
00:10:05,120 --> 00:10:08,480
to at least 256 then it will not be

257
00:10:07,600 --> 00:10:10,079
allowed

258
00:10:08,480 --> 00:10:12,480
even though we could allow it in some

259
00:10:10,079 --> 00:10:14,959
cases but that's that's how it is in

260
00:10:12,480 --> 00:10:17,440
five seven and ten two

261
00:10:14,959 --> 00:10:18,319
in ten three we introduced the new

262
00:10:17,440 --> 00:10:21,600
syntax

263
00:10:18,320 --> 00:10:22,240
so that you can specify that uh i want

264
00:10:21,600 --> 00:10:24,079
this to be

265
00:10:22,240 --> 00:10:25,680
instant or i want this to be done

266
00:10:24,079 --> 00:10:27,439
without copying the table

267
00:10:25,680 --> 00:10:29,199
and if it can't be done that way then

268
00:10:27,440 --> 00:10:31,279
the other table will fail so

269
00:10:29,200 --> 00:10:33,760
you can request that please if this

270
00:10:31,279 --> 00:10:36,640
would cause the table to be rebuilt

271
00:10:33,760 --> 00:10:38,079
return an error and don't kill my server

272
00:10:36,640 --> 00:10:41,360
for the next few hours

273
00:10:38,079 --> 00:10:44,880
by running that huge altar

274
00:10:41,360 --> 00:10:48,560
in 103 we also got some

275
00:10:44,880 --> 00:10:50,320
simple metadata changes uh

276
00:10:48,560 --> 00:10:51,920
they are an instantly if you drop a

277
00:10:50,320 --> 00:10:52,640
check constraint which we have in

278
00:10:51,920 --> 00:10:54,719
material

279
00:10:52,640 --> 00:10:56,560
or you drop a foreign key constraint

280
00:10:54,720 --> 00:10:59,360
that can be done instantly

281
00:10:56,560 --> 00:11:00,880
or if you enable or disable the

282
00:10:59,360 --> 00:11:03,440
attribute that you want system

283
00:11:00,880 --> 00:11:06,000
versioning for a particular column

284
00:11:03,440 --> 00:11:07,680
that's the topic of the next talk you

285
00:11:06,000 --> 00:11:09,839
can do that instantly

286
00:11:07,680 --> 00:11:11,199
but if you enable or disable the system

287
00:11:09,839 --> 00:11:14,640
version for the entire table

288
00:11:11,200 --> 00:11:17,040
that will require a rebuild in ten four

289
00:11:14,640 --> 00:11:18,319
you can instantly change the character

290
00:11:17,040 --> 00:11:22,240
set from

291
00:11:18,320 --> 00:11:25,200
three byte utf-8 to four byte utf-8

292
00:11:22,240 --> 00:11:26,240
and you can change the correlation if

293
00:11:25,200 --> 00:11:29,519
the column is not

294
00:11:26,240 --> 00:11:32,560
indexed then the correlation doesn't

295
00:11:29,519 --> 00:11:34,640
actually affect anything it's just a

296
00:11:32,560 --> 00:11:35,920
an attribute of the character set that

297
00:11:34,640 --> 00:11:37,439
will affect some

298
00:11:35,920 --> 00:11:39,920
queries that you execute against the

299
00:11:37,440 --> 00:11:43,040
table but if it's not indexed then

300
00:11:39,920 --> 00:11:45,120
there is no no change to any

301
00:11:43,040 --> 00:11:46,800
internal data storage so you can change

302
00:11:45,120 --> 00:11:49,440
the correlation but if you have an index

303
00:11:46,800 --> 00:11:51,439
on that on that column then of course

304
00:11:49,440 --> 00:11:54,839
that index on the column needs to be

305
00:11:51,440 --> 00:11:57,279
rebuilt but the whole table could

306
00:11:54,839 --> 00:11:57,760
could you could save the rebuild for the

307
00:11:57,279 --> 00:11:59,760
table

308
00:11:57,760 --> 00:12:01,680
it would only rebuild the indexes that

309
00:11:59,760 --> 00:12:05,200
use those columns

310
00:12:01,680 --> 00:12:05,199
for which the correlation is changed

311
00:12:06,639 --> 00:12:11,839
uh about extending variable length

312
00:12:09,279 --> 00:12:11,839
columns

313
00:12:12,399 --> 00:12:18,720
in mysql 503 i introduced

314
00:12:15,440 --> 00:12:19,279
a more compact data storage format which

315
00:12:18,720 --> 00:12:21,600
is

316
00:12:19,279 --> 00:12:24,480
called raw format compact and the later

317
00:12:21,600 --> 00:12:24,480
variations of it

318
00:12:24,720 --> 00:12:28,800
dynamic it only differs for the

319
00:12:26,959 --> 00:12:30,959
treatment of blob columns

320
00:12:28,800 --> 00:12:33,760
and and draw format compressed which i

321
00:12:30,959 --> 00:12:36,560
did in the 5 1 plugin

322
00:12:33,760 --> 00:12:38,160
so this format is not encoding the

323
00:12:36,560 --> 00:12:42,079
length of fixed length columns at

324
00:12:38,160 --> 00:12:45,199
all and for variable and columns

325
00:12:42,079 --> 00:12:46,160
if the maximum length is at most 255

326
00:12:45,200 --> 00:12:49,120
bytes

327
00:12:46,160 --> 00:12:51,279
then it will use one byte for encoding

328
00:12:49,120 --> 00:12:54,560
the length or if the actual length is

329
00:12:51,279 --> 00:12:56,480
less than less than one if the actual

330
00:12:54,560 --> 00:12:58,160
length fits in seven bytes then it will

331
00:12:56,480 --> 00:12:59,040
also be encoded in one byte the most

332
00:12:58,160 --> 00:13:02,000
significant

333
00:12:59,040 --> 00:13:03,519
byte would then be at zero otherwise if

334
00:13:02,000 --> 00:13:07,519
the maximum length exceeds

335
00:13:03,519 --> 00:13:11,040
256 then and at the same time

336
00:13:07,519 --> 00:13:14,079
this uh current length it exists 1

337
00:13:11,040 --> 00:13:15,199
28 then we will encode it in two bytes

338
00:13:14,079 --> 00:13:17,279
and the first

339
00:13:15,200 --> 00:13:19,360
byte will have the most significant bit

340
00:13:17,279 --> 00:13:22,160
set so this means that

341
00:13:19,360 --> 00:13:23,600
actually if the maximum length is less

342
00:13:22,160 --> 00:13:27,519
than

343
00:13:23,600 --> 00:13:28,560
than 128 bytes then we can extend to

344
00:13:27,519 --> 00:13:30,160
anything

345
00:13:28,560 --> 00:13:32,800
without changing the format because we

346
00:13:30,160 --> 00:13:35,360
know that for every column in the table

347
00:13:32,800 --> 00:13:37,359
this length will be encoded in such a

348
00:13:35,360 --> 00:13:37,600
way that the most significant bit will

349
00:13:37,360 --> 00:13:40,800
be

350
00:13:37,600 --> 00:13:41,920
zero so we can allow that and also for

351
00:13:40,800 --> 00:13:44,160
the original

352
00:13:41,920 --> 00:13:46,719
row format of inner db where we

353
00:13:44,160 --> 00:13:50,000
explicitly store the length of

354
00:13:46,720 --> 00:13:50,480
all columns we can allow any extension

355
00:13:50,000 --> 00:13:54,800
of

356
00:13:50,480 --> 00:13:56,880
varchar columns for car columns in utf-8

357
00:13:54,800 --> 00:13:58,719
we are internally in this new format we

358
00:13:56,880 --> 00:14:00,480
are using a variable length format so

359
00:13:58,720 --> 00:14:03,360
this applies also

360
00:14:00,480 --> 00:14:05,920
to car columns but not not for row from

361
00:14:03,360 --> 00:14:05,920
redundant

362
00:14:06,000 --> 00:14:10,160
and if you change the character set of a

363
00:14:07,600 --> 00:14:13,279
column of course if the length in bytes

364
00:14:10,160 --> 00:14:16,160
changes so that

365
00:14:13,279 --> 00:14:17,439
this thing or this thing cannot be

366
00:14:16,160 --> 00:14:20,639
applied

367
00:14:17,440 --> 00:14:23,920
then it will have to use

368
00:14:20,639 --> 00:14:28,800
algorithm copy because we don't support

369
00:14:23,920 --> 00:14:28,800
native rebuild when any data type is

370
00:14:28,839 --> 00:14:32,240
changing

371
00:14:30,240 --> 00:14:33,760
we only support it for removing or

372
00:14:32,240 --> 00:14:38,000
adding the not now

373
00:14:33,760 --> 00:14:41,760
attribute so what can we do even better

374
00:14:38,000 --> 00:14:45,040
to have more instant outer table by

375
00:14:41,760 --> 00:14:46,720
changing the file format

376
00:14:45,040 --> 00:14:48,399
first i would like to say a little bit

377
00:14:46,720 --> 00:14:49,279
about compatibility because it was

378
00:14:48,399 --> 00:14:52,720
mentioned by

379
00:14:49,279 --> 00:14:55,279
peter zaitsev that at mariadb we don't

380
00:14:52,720 --> 00:14:59,199
guarantee that you can downgrade but

381
00:14:55,279 --> 00:15:01,760
i i at least personally want to

382
00:14:59,199 --> 00:15:04,319
to keep that in mind i want to be

383
00:15:01,760 --> 00:15:07,199
careful about the data format changes

384
00:15:04,320 --> 00:15:08,480
so that the goal is that they you can

385
00:15:07,199 --> 00:15:10,240
downgrade and if

386
00:15:08,480 --> 00:15:11,760
for some reason there is some new

387
00:15:10,240 --> 00:15:13,519
feature that doesn't work in the old

388
00:15:11,760 --> 00:15:15,680
versions then it should

389
00:15:13,519 --> 00:15:17,600
fade in an obvious way okay this is not

390
00:15:15,680 --> 00:15:20,719
true for the undo lock format change in

391
00:15:17,600 --> 00:15:24,800
material 103 but for

392
00:15:20,720 --> 00:15:26,320
for the data file format it should be

393
00:15:24,800 --> 00:15:28,479
and of course there are other parts of

394
00:15:26,320 --> 00:15:31,040
the server which

395
00:15:28,480 --> 00:15:31,839
which will suffer for downgrading but uh

396
00:15:31,040 --> 00:15:33,680
for

397
00:15:31,839 --> 00:15:35,120
exporting or importing data files i

398
00:15:33,680 --> 00:15:37,120
think this is important that

399
00:15:35,120 --> 00:15:41,519
you can take a data file from a newer

400
00:15:37,120 --> 00:15:44,000
version to an older version if needed

401
00:15:41,519 --> 00:15:46,240
so basically it is to told that if you

402
00:15:44,000 --> 00:15:49,360
don't use the instant add or drop column

403
00:15:46,240 --> 00:15:51,040
in mario db then three or later then you

404
00:15:49,360 --> 00:15:53,440
should be able to import that file to

405
00:15:51,040 --> 00:15:55,279
order server

406
00:15:53,440 --> 00:15:57,519
so intensity we got the instant add

407
00:15:55,279 --> 00:16:00,639
column as the last column and with a

408
00:15:57,519 --> 00:16:03,519
constant default value

409
00:16:00,639 --> 00:16:04,880
we didn't change any data dictionary

410
00:16:03,519 --> 00:16:07,120
table format for this

411
00:16:04,880 --> 00:16:10,160
this is uh everything is self contained

412
00:16:07,120 --> 00:16:11,600
in the ibd file in the ndp data file

413
00:16:10,160 --> 00:16:13,920
this doesn't support raw format

414
00:16:11,600 --> 00:16:16,160
compressed this is based on

415
00:16:13,920 --> 00:16:17,199
something earlier that was done both by

416
00:16:16,160 --> 00:16:20,959
alibaba and

417
00:16:17,199 --> 00:16:24,000
tencent in their mysql five six forks

418
00:16:20,959 --> 00:16:27,439
but the default value is something

419
00:16:24,000 --> 00:16:29,519
new and also that we are keeping all the

420
00:16:27,440 --> 00:16:30,880
metadata inside the data file it's it's

421
00:16:29,519 --> 00:16:34,000
new in mariadb

422
00:16:30,880 --> 00:16:35,680
mysqlite got something similar but they

423
00:16:34,000 --> 00:16:37,440
are storing the metadata

424
00:16:35,680 --> 00:16:39,120
externally in the global data dictionary

425
00:16:37,440 --> 00:16:40,959
so i believe that the

426
00:16:39,120 --> 00:16:42,720
import or export of the data files will

427
00:16:40,959 --> 00:16:45,680
not work i didn't test it but i would

428
00:16:42,720 --> 00:16:45,680
just assume so

429
00:16:46,240 --> 00:16:50,480
so my db is implementing the default

430
00:16:48,240 --> 00:16:54,320
expression at the outer table time and

431
00:16:50,480 --> 00:16:56,320
then storing the values in a hidden

432
00:16:54,320 --> 00:16:57,279
metadata record here is an example we

433
00:16:56,320 --> 00:17:00,720
create the table

434
00:16:57,279 --> 00:17:04,240
insert three rows into it and then we

435
00:17:00,720 --> 00:17:04,720
instantly add a few columns it's adding

436
00:17:04,240 --> 00:17:07,439
this

437
00:17:04,720 --> 00:17:08,880
hidden metadata record where it's adding

438
00:17:07,439 --> 00:17:11,199
the default values

439
00:17:08,880 --> 00:17:13,120
of the columns as they were when the

440
00:17:11,199 --> 00:17:16,160
other table was executed

441
00:17:13,119 --> 00:17:18,079
and the user records are not touched at

442
00:17:16,160 --> 00:17:19,520
all so we're basically inserting one one

443
00:17:18,079 --> 00:17:22,879
record here

444
00:17:19,520 --> 00:17:25,839
and when we are reading data we will

445
00:17:22,880 --> 00:17:26,640
see all the values for the old old

446
00:17:25,839 --> 00:17:29,440
records

447
00:17:26,640 --> 00:17:31,360
that are coming from the metadata record

448
00:17:29,440 --> 00:17:33,360
and when we update something

449
00:17:31,360 --> 00:17:34,959
like in this case for the last row we

450
00:17:33,360 --> 00:17:38,080
update this column t

451
00:17:34,960 --> 00:17:39,840
to the null value in that case

452
00:17:38,080 --> 00:17:41,600
because the last column still

453
00:17:39,840 --> 00:17:43,520
corresponds to the same value as in the

454
00:17:41,600 --> 00:17:44,320
metadata record it's not stored in the

455
00:17:43,520 --> 00:17:48,639
record

456
00:17:44,320 --> 00:17:53,200
in the table in the index but

457
00:17:48,640 --> 00:17:57,039
all fields up to the last changed record

458
00:17:53,200 --> 00:17:57,039
a change column will be stored

459
00:17:59,440 --> 00:18:02,799
uh in mario db 10-4 we got the instant

460
00:18:02,000 --> 00:18:04,960
drop column

461
00:18:02,799 --> 00:18:05,918
and changing the ordering of column and

462
00:18:04,960 --> 00:18:08,240
also

463
00:18:05,919 --> 00:18:10,160
adding a column anywhere in the table

464
00:18:08,240 --> 00:18:13,440
internally we are still

465
00:18:10,160 --> 00:18:15,280
storing the new added columns at the end

466
00:18:13,440 --> 00:18:16,400
of the cluster linux record but we are

467
00:18:15,280 --> 00:18:19,600
keeping a

468
00:18:16,400 --> 00:18:20,240
metadata the metadata record gives a

469
00:18:19,600 --> 00:18:24,639
mapping

470
00:18:20,240 --> 00:18:27,360
of table columns to index fields

471
00:18:24,640 --> 00:18:29,360
and this mapping allows us to drop

472
00:18:27,360 --> 00:18:31,360
columns so the cones are kept as a

473
00:18:29,360 --> 00:18:33,918
garbage in in the old

474
00:18:31,360 --> 00:18:34,719
ultra records and we will keep storing

475
00:18:33,919 --> 00:18:37,840
dummy values

476
00:18:34,720 --> 00:18:37,840
for the dropped cones

477
00:18:39,360 --> 00:18:44,240
and the secondary index record format

478
00:18:42,160 --> 00:18:45,840
doesn't change at all

479
00:18:44,240 --> 00:18:48,240
so all this of course means that the

480
00:18:45,840 --> 00:18:51,439
performance of dml operations will

481
00:18:48,240 --> 00:18:54,000
or can can decrease

482
00:18:51,440 --> 00:18:55,760
basically you use shelter table as as

483
00:18:54,000 --> 00:18:57,360
normally and if you don't want to have

484
00:18:55,760 --> 00:18:58,640
instant operation for adding or dropping

485
00:18:57,360 --> 00:19:00,639
you use the force

486
00:18:58,640 --> 00:19:02,320
cross there is a block post about that

487
00:19:00,640 --> 00:19:03,039
and there is a counter that you can

488
00:19:02,320 --> 00:19:06,159
check

489
00:19:03,039 --> 00:19:09,520
to see how many table re builds you

490
00:19:06,160 --> 00:19:12,799
avoided by these format changes

491
00:19:09,520 --> 00:19:15,200
well i'm already over time i'm trying

492
00:19:12,799 --> 00:19:17,120
to go quickly through the rest so we

493
00:19:15,200 --> 00:19:17,840
have some problem with the online table

494
00:19:17,120 --> 00:19:20,639
rebuild

495
00:19:17,840 --> 00:19:22,000
and create index and biggest problem is

496
00:19:20,640 --> 00:19:25,200
with replication

497
00:19:22,000 --> 00:19:26,720
that replication slave will only start

498
00:19:25,200 --> 00:19:28,480
doing its work when the master has

499
00:19:26,720 --> 00:19:30,480
already committed this is a problem with

500
00:19:28,480 --> 00:19:34,160
both mysql and maria libby

501
00:19:30,480 --> 00:19:37,280
marilliby 10 5 will hopefully fix this

502
00:19:34,160 --> 00:19:39,760
so that the slave will start replicating

503
00:19:37,280 --> 00:19:42,480
when the master starts executing the

504
00:19:39,760 --> 00:19:42,480
online alter

505
00:19:42,720 --> 00:19:46,960
and for on an alter we need to buffer

506
00:19:45,440 --> 00:19:50,400
concurrent changes currently

507
00:19:46,960 --> 00:19:53,840
inode writes this lock before committing

508
00:19:50,400 --> 00:19:54,559
the concurrent dml operations this means

509
00:19:53,840 --> 00:19:57,760
that

510
00:19:54,559 --> 00:20:01,600
if you got the duplicate key error

511
00:19:57,760 --> 00:20:03,600
in a dml operation then the alter table

512
00:20:01,600 --> 00:20:04,639
would fail also with the duplicate key

513
00:20:03,600 --> 00:20:08,158
error because

514
00:20:04,640 --> 00:20:10,640
we are writing log both both for

515
00:20:08,159 --> 00:20:11,600
for doing the operation and for rolling

516
00:20:10,640 --> 00:20:13,120
back the operation

517
00:20:11,600 --> 00:20:14,719
if we defer the lock writing until

518
00:20:13,120 --> 00:20:16,158
commit time then we wouldn't have this

519
00:20:14,720 --> 00:20:18,880
problem

520
00:20:16,159 --> 00:20:19,520
and in rdb we are working on doing cross

521
00:20:18,880 --> 00:20:21,280
engine

522
00:20:19,520 --> 00:20:23,520
outer online table which means that it's

523
00:20:21,280 --> 00:20:25,678
algorithm copy with with the logging

524
00:20:23,520 --> 00:20:27,280
and it would fix this problem but i

525
00:20:25,679 --> 00:20:27,760
think we still need the engine native

526
00:20:27,280 --> 00:20:31,120
for

527
00:20:27,760 --> 00:20:34,158
creating secondary indexes or or for uh

528
00:20:31,120 --> 00:20:37,199
instant changes

529
00:20:34,159 --> 00:20:38,240
well this is uh we could speed up bulk

530
00:20:37,200 --> 00:20:41,520
operations

531
00:20:38,240 --> 00:20:43,520
by doing smarter undo logging

532
00:20:41,520 --> 00:20:47,360
and then i had some section about

533
00:20:43,520 --> 00:20:51,280
theoretical limits what you could do

534
00:20:47,360 --> 00:20:53,520
like uh if we if we tagged the records

535
00:20:51,280 --> 00:20:54,720
what was the schema definition when this

536
00:20:53,520 --> 00:20:56,480
record was written

537
00:20:54,720 --> 00:20:58,480
then we could lazily convert the records

538
00:20:56,480 --> 00:21:01,679
to the newest version

539
00:20:58,480 --> 00:21:02,000
when reading the table and we could also

540
00:21:01,679 --> 00:21:06,080
have

541
00:21:02,000 --> 00:21:09,039
a have some validation step

542
00:21:06,080 --> 00:21:09,439
even if we have some change that could

543
00:21:09,039 --> 00:21:13,200
uh

544
00:21:09,440 --> 00:21:13,200
could fail like if you are

545
00:21:13,360 --> 00:21:21,678
if you are if you are changing

546
00:21:16,880 --> 00:21:23,760
an unsigned assigned integer to unsigned

547
00:21:21,679 --> 00:21:24,720
with the smaller range even it might be

548
00:21:23,760 --> 00:21:27,760
okay if

549
00:21:24,720 --> 00:21:30,400
all the rows are are fine but

550
00:21:27,760 --> 00:21:31,440
we have to validate the table contents

551
00:21:30,400 --> 00:21:34,480
so we could do this

552
00:21:31,440 --> 00:21:35,120
by some format tagging and as a special

553
00:21:34,480 --> 00:21:36,960
case of this

554
00:21:35,120 --> 00:21:38,399
even with our data format changes we

555
00:21:36,960 --> 00:21:40,559
could do

556
00:21:38,400 --> 00:21:42,640
a check constraint or add foreign key

557
00:21:40,559 --> 00:21:45,039
constant without rebuilding a table just

558
00:21:42,640 --> 00:21:47,039
doing validation steps that's not going

559
00:21:45,039 --> 00:21:50,879
being done currently so we are currently

560
00:21:47,039 --> 00:21:50,879
doing an unnecessary table rebuild

561
00:21:53,120 --> 00:22:01,039
so in summary modeldb 10 3 and 10

562
00:21:57,840 --> 00:22:01,840
change the data file format to allow

563
00:22:01,039 --> 00:22:04,000
instant

564
00:22:01,840 --> 00:22:05,120
add and drop column and changing the

565
00:22:04,000 --> 00:22:07,360
order of columns

566
00:22:05,120 --> 00:22:08,158
if you don't want to have that format

567
00:22:07,360 --> 00:22:11,360
change then you

568
00:22:08,159 --> 00:22:14,640
have to use the force keyword

569
00:22:11,360 --> 00:22:16,240
and i think it would be useful to have

570
00:22:14,640 --> 00:22:18,880
an option that

571
00:22:16,240 --> 00:22:20,159
a configuration parameter that even when

572
00:22:18,880 --> 00:22:22,159
you don't specify this

573
00:22:20,159 --> 00:22:23,679
you could use the original format

574
00:22:22,159 --> 00:22:26,880
because there is some

575
00:22:23,679 --> 00:22:27,600
overhead for all dml operations when the

576
00:22:26,880 --> 00:22:29,440
when you have

577
00:22:27,600 --> 00:22:31,760
used instant alter if you for example if

578
00:22:29,440 --> 00:22:33,520
you have used instant drop column

579
00:22:31,760 --> 00:22:36,158
then you will have the garbage in the

580
00:22:33,520 --> 00:22:37,440
table forever if it was a not null fixed

581
00:22:36,159 --> 00:22:38,559
strength column you will have to

582
00:22:37,440 --> 00:22:40,799
allocate

583
00:22:38,559 --> 00:22:42,720
space for those not now fixed length

584
00:22:40,799 --> 00:22:43,440
columns for all records even though it's

585
00:22:42,720 --> 00:22:45,919
not there

586
00:22:43,440 --> 00:22:47,919
so the table could be smaller if you re

587
00:22:45,919 --> 00:22:51,840
beat the table after drop column

588
00:22:47,919 --> 00:22:54,000
and same thing after add column if the

589
00:22:51,840 --> 00:22:56,799
data length is varying a lot you can't

590
00:22:54,000 --> 00:22:59,679
do in-place updates

591
00:22:56,799 --> 00:23:00,960
so it could be better to rebuild so

592
00:22:59,679 --> 00:23:03,039
maybe a

593
00:23:00,960 --> 00:23:04,400
good idea could be the on the

594
00:23:03,039 --> 00:23:06,960
replication slave

595
00:23:04,400 --> 00:23:08,320
have it always rebuilt the table and on

596
00:23:06,960 --> 00:23:10,720
the master do instant

597
00:23:08,320 --> 00:23:10,720
other

598
00:23:12,640 --> 00:23:16,559
okay that was it uh are there any

599
00:23:15,600 --> 00:23:20,799
questions or

600
00:23:16,559 --> 00:23:21,678
comments yes so for me a deal breaker is

601
00:23:20,799 --> 00:23:24,799
that

602
00:23:21,679 --> 00:23:26,960
if the migration needs to uh needs to

603
00:23:24,799 --> 00:23:29,360
run fully on a replica and the replica

604
00:23:26,960 --> 00:23:30,000
replication catches lag that is

605
00:23:29,360 --> 00:23:32,240
something

606
00:23:30,000 --> 00:23:33,360
for me i cannot work with because i

607
00:23:32,240 --> 00:23:35,120
cannot ship really

608
00:23:33,360 --> 00:23:36,959
traffic to the replicas is there any

609
00:23:35,120 --> 00:23:38,399
thought that if the master runs in the

610
00:23:36,960 --> 00:23:40,000
instant at the table

611
00:23:38,400 --> 00:23:41,760
then maybe the replicas can do that as

612
00:23:40,000 --> 00:23:43,919
well yes

613
00:23:41,760 --> 00:23:45,520
currently i think it's uh so that they

614
00:23:43,919 --> 00:23:46,640
if you are using the same version of on

615
00:23:45,520 --> 00:23:48,639
on the master and slave

616
00:23:46,640 --> 00:23:50,480
then it will be instant altar on both

617
00:23:48,640 --> 00:23:53,760
but like i mentioned

618
00:23:50,480 --> 00:23:56,080
in uh mascot 105 we have this

619
00:23:53,760 --> 00:23:56,080
task

620
00:23:58,000 --> 00:24:05,840
where was it

621
00:24:13,279 --> 00:24:16,880
uh yeah this this one is the change in

622
00:24:15,760 --> 00:24:19,279
ten five that

623
00:24:16,880 --> 00:24:21,120
it would start doing the outer table on

624
00:24:19,279 --> 00:24:23,919
the slave at the same time when when the

625
00:24:21,120 --> 00:24:23,918
master starts it

626
00:24:24,159 --> 00:24:32,559
so that's currently being worked uh

627
00:24:27,840 --> 00:24:36,399
worked around by uh on uh

628
00:24:32,559 --> 00:24:42,399
by third-party tools like a github os

629
00:24:36,400 --> 00:24:42,400
c and percona toolkit yes motivate you

630
00:24:44,840 --> 00:24:47,840
um

631
00:24:49,840 --> 00:24:56,158
oh yes yes but uh my common topic is

632
00:24:53,520 --> 00:24:58,639
in odb so i didn't consider yes it's a

633
00:24:56,159 --> 00:25:00,640
same problem with uh

634
00:24:58,640 --> 00:25:03,200
if you do this cross engine on our other

635
00:25:00,640 --> 00:25:03,200
table then

636
00:25:04,159 --> 00:25:09,760
yeah yeah you're right about it

637
00:25:07,440 --> 00:25:09,760
yep

638
00:25:12,960 --> 00:25:17,520
would yes the flow or would that be

639
00:25:15,279 --> 00:25:19,039
built into the replication

640
00:25:17,520 --> 00:25:23,679
i think it would be built into the

641
00:25:19,039 --> 00:25:23,679
replication so it would just work like

642
00:25:26,840 --> 00:25:29,840
that

643
00:25:32,799 --> 00:25:43,039
well i i understood that it's referring

644
00:25:34,799 --> 00:25:56,720
to bin lock events and not comments

645
00:25:43,039 --> 00:25:56,720
okay thank you

