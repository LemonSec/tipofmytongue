1
00:00:06,399 --> 00:00:10,800
good morning everyone

2
00:00:07,600 --> 00:00:11,599
and uh welcome to fosdem uh i'm jeremy

3
00:00:10,800 --> 00:00:14,799
bennett

4
00:00:11,599 --> 00:00:16,880
um i'm chief executive of ember cosm um

5
00:00:14,799 --> 00:00:18,640
but i am an engineer by profession and

6
00:00:16,880 --> 00:00:21,840
this is an engineering talk

7
00:00:18,640 --> 00:00:24,800
um just if you're wondering

8
00:00:21,840 --> 00:00:26,880
why i'm looking like a 1960s civil

9
00:00:24,800 --> 00:00:30,000
servant out of a kneeling comedy

10
00:00:26,880 --> 00:00:31,038
um i'm part of open uk which is the

11
00:00:30,000 --> 00:00:34,399
trade body for

12
00:00:31,039 --> 00:00:36,160
open source businesses in the uk

13
00:00:34,399 --> 00:00:38,480
it has got a new niece of life with a

14
00:00:36,160 --> 00:00:40,398
new chief executive

15
00:00:38,480 --> 00:00:42,160
and you'll see they've got a stand

16
00:00:40,399 --> 00:00:42,800
downstairs and they're all wearing hats

17
00:00:42,160 --> 00:00:44,800
like this

18
00:00:42,800 --> 00:00:48,000
and so i'm advertising it it is boiling

19
00:00:44,800 --> 00:00:48,000
hot i'm going to take it off now

20
00:00:48,079 --> 00:00:53,199
um so that's a little less formal

21
00:00:55,520 --> 00:01:02,239
so the subject of this talk

22
00:00:58,640 --> 00:01:03,280
is about using benchmarks to improve

23
00:01:02,239 --> 00:01:06,158
compilers

24
00:01:03,280 --> 00:01:06,640
our day job what envecosm does is we

25
00:01:06,159 --> 00:01:08,880
develop

26
00:01:06,640 --> 00:01:10,960
llvm and gcc compilers if you've got a

27
00:01:08,880 --> 00:01:12,560
new processor chip you're bringing out

28
00:01:10,960 --> 00:01:14,880
we're probably the company you come to

29
00:01:12,560 --> 00:01:17,920
to are to help you bring up gcc

30
00:01:14,880 --> 00:01:20,158
llvm and all the tools around it

31
00:01:17,920 --> 00:01:20,159
um

32
00:01:20,960 --> 00:01:25,119
i have been involved with the mbench

33
00:01:23,040 --> 00:01:26,080
project for the last year or so i'll

34
00:01:25,119 --> 00:01:28,960
tell you a bit more about

35
00:01:26,080 --> 00:01:30,400
that and then this is more of a talk

36
00:01:28,960 --> 00:01:31,839
about a process

37
00:01:30,400 --> 00:01:33,119
i'm not magically going to tell you all

38
00:01:31,840 --> 00:01:35,200
the secret tricks for improving the

39
00:01:33,119 --> 00:01:38,720
compiler but i'm going to tell you how

40
00:01:35,200 --> 00:01:38,720
you can find out what those are

41
00:01:39,759 --> 00:01:44,399
so first of all about m bench the first

42
00:01:42,640 --> 00:01:47,680
version of m bench

43
00:01:44,399 --> 00:01:51,119
will be launched at embedded world next

44
00:01:47,680 --> 00:01:52,720
uh later this month um it's in bench 0.5

45
00:01:51,119 --> 00:01:54,640
because we still consider it our first

46
00:01:52,720 --> 00:01:57,280
sort of experimental version

47
00:01:54,640 --> 00:01:58,960
and it's a free and open source set of

48
00:01:57,280 --> 00:02:03,520
benchmark programs

49
00:01:58,960 --> 00:02:07,280
for benchmarking computers

50
00:02:03,520 --> 00:02:08,878
let me tell you a bit more about it

51
00:02:07,280 --> 00:02:11,599
we've tried to benchmark computers going

52
00:02:08,878 --> 00:02:13,040
a long way back 1972 whetstone

53
00:02:11,599 --> 00:02:16,238
how many people here have ever run

54
00:02:13,040 --> 00:02:19,679
whetstone how many people here were born

55
00:02:16,239 --> 00:02:19,680
before whetstone was written

56
00:02:20,560 --> 00:02:26,000
yeah okay um

57
00:02:24,000 --> 00:02:27,120
then we've got linpack linpack is still

58
00:02:26,000 --> 00:02:29,360
used it's the

59
00:02:27,120 --> 00:02:32,480
basis of the top 500 super computers but

60
00:02:29,360 --> 00:02:34,319
it was written in 1977.

61
00:02:32,480 --> 00:02:36,238
dry stone came along inspired by

62
00:02:34,319 --> 00:02:37,839
whetstone it's the first general

63
00:02:36,239 --> 00:02:41,760
synthetic benchmark

64
00:02:37,840 --> 00:02:44,160
for running on systems and evaluating

65
00:02:41,760 --> 00:02:46,239
how a general computer works

66
00:02:44,160 --> 00:02:48,319
and then you get the industry consortium

67
00:02:46,239 --> 00:02:51,519
the spec consortium forming

68
00:02:48,319 --> 00:02:53,200
to actually try and say

69
00:02:51,519 --> 00:02:55,040
a single program isn't enough let's have

70
00:02:53,200 --> 00:02:56,399
a set of programs and that's an industry

71
00:02:55,040 --> 00:02:58,720
consortium

72
00:02:56,400 --> 00:02:59,840
very well respected downside is you have

73
00:02:58,720 --> 00:03:02,640
to pay to play

74
00:02:59,840 --> 00:03:03,440
um it's not freely available and you

75
00:03:02,640 --> 00:03:04,958
find

76
00:03:03,440 --> 00:03:06,159
core mark that came out of embassy and

77
00:03:04,959 --> 00:03:06,879
i'll say a bit more about embassy in the

78
00:03:06,159 --> 00:03:09,120
moment but

79
00:03:06,879 --> 00:03:10,879
core mark is what everyone quotes and

80
00:03:09,120 --> 00:03:13,200
i've just been told the risk five

81
00:03:10,879 --> 00:03:15,040
uh dev room downstairs has just been

82
00:03:13,200 --> 00:03:16,480
quoting coremark as the performance of

83
00:03:15,040 --> 00:03:18,079
the low-risk platform

84
00:03:16,480 --> 00:03:19,840
and the problem is core mark is like dry

85
00:03:18,080 --> 00:03:22,000
so it's a new dry stone it's a synthetic

86
00:03:19,840 --> 00:03:23,599
benchmark it's a single program

87
00:03:22,000 --> 00:03:25,360
and it has done one thing it has

88
00:03:23,599 --> 00:03:28,399
improved the abilities of compilers to

89
00:03:25,360 --> 00:03:28,400
optimize core mark

90
00:03:28,720 --> 00:03:34,000
okay and then others another mainstream

91
00:03:32,239 --> 00:03:34,560
one mlperf you may have seen it any

92
00:03:34,000 --> 00:03:37,840
times

93
00:03:34,560 --> 00:03:39,519
uh last week that's a new

94
00:03:37,840 --> 00:03:41,200
benchmark suite for measuring the

95
00:03:39,519 --> 00:03:42,720
performance of

96
00:03:41,200 --> 00:03:44,798
machine learning systems very much for

97
00:03:42,720 --> 00:03:46,560
the ai world and there is a connection

98
00:03:44,799 --> 00:03:50,319
which i shall come to

99
00:03:46,560 --> 00:03:52,000
in a moment and then there are some

100
00:03:50,319 --> 00:03:53,359
others that are less well known the top

101
00:03:52,000 --> 00:03:55,040
rows the well-known ones

102
00:03:53,360 --> 00:03:56,640
there's embassy well embassy is

103
00:03:55,040 --> 00:03:57,280
reasonably well known in the embedded

104
00:03:56,640 --> 00:04:01,119
space

105
00:03:57,280 --> 00:04:04,640
um it's a set of embedded benchmarks

106
00:04:01,120 --> 00:04:07,439
again it's pay to play it's a consortium

107
00:04:04,640 --> 00:04:09,040
um it's it's not free and available but

108
00:04:07,439 --> 00:04:12,079
they're quite widely used

109
00:04:09,040 --> 00:04:13,359
um uh over time when we get to the free

110
00:04:12,080 --> 00:04:14,239
and open source world you've got my

111
00:04:13,360 --> 00:04:16,720
bench

112
00:04:14,239 --> 00:04:17,680
and my bench has been around for what 20

113
00:04:16,720 --> 00:04:19,600
years nearly

114
00:04:17,680 --> 00:04:21,358
and that's a set of small programs you

115
00:04:19,600 --> 00:04:22,960
can use for evaluating systems widely

116
00:04:21,358 --> 00:04:24,799
used in academia because it's freely

117
00:04:22,960 --> 00:04:27,280
available

118
00:04:24,800 --> 00:04:28,400
we did some work on energy efficiency

119
00:04:27,280 --> 00:04:30,080
some of you may have come to the dev

120
00:04:28,400 --> 00:04:33,679
room five years ago here

121
00:04:30,080 --> 00:04:35,198
um looking at um how

122
00:04:33,680 --> 00:04:36,960
energy efficient how compilers could

123
00:04:35,199 --> 00:04:37,600
influence energy efficiency on embedded

124
00:04:36,960 --> 00:04:38,960
systems

125
00:04:37,600 --> 00:04:40,400
we needed a set of benchmarks for

126
00:04:38,960 --> 00:04:41,758
embedded systems that means they don't

127
00:04:40,400 --> 00:04:43,758
use printf

128
00:04:41,759 --> 00:04:45,120
they don't use libraries very much and

129
00:04:43,759 --> 00:04:47,040
that's the bristol end because i'm

130
00:04:45,120 --> 00:04:48,560
embedded benchmark suite or biebs and

131
00:04:47,040 --> 00:04:49,520
actually biebs isn't new because it

132
00:04:48,560 --> 00:04:51,759
builds on

133
00:04:49,520 --> 00:04:52,639
my bench and one or two other benchmark

134
00:04:51,759 --> 00:04:54,479
suites there

135
00:04:52,639 --> 00:04:56,400
and lastly you've got the timing

136
00:04:54,479 --> 00:04:58,639
analysis benchmark tackle bench which

137
00:04:56,400 --> 00:05:00,719
came out only a couple of years ago

138
00:04:58,639 --> 00:05:02,080
and not many people have heard that but

139
00:05:00,720 --> 00:05:03,600
it's a good set of programs and in fact

140
00:05:02,080 --> 00:05:07,039
tackle bench builds on

141
00:05:03,600 --> 00:05:10,160
previous benchmark suites as well

142
00:05:07,039 --> 00:05:12,560
so we came to the conclusion that

143
00:05:10,160 --> 00:05:14,160
there was nothing perfect for general

144
00:05:12,560 --> 00:05:16,479
use

145
00:05:14,160 --> 00:05:17,440
okay so we decided to create a new

146
00:05:16,479 --> 00:05:20,479
benchmark suite

147
00:05:17,440 --> 00:05:23,039
it's called mbench

148
00:05:20,479 --> 00:05:24,400
and we drew seven lessons from all those

149
00:05:23,039 --> 00:05:25,440
existing benchmarks first of all it's

150
00:05:24,400 --> 00:05:27,919
got to be free

151
00:05:25,440 --> 00:05:29,520
okay if you don't make it free spec an m

152
00:05:27,919 --> 00:05:30,240
bench and why does everyone use core

153
00:05:29,520 --> 00:05:32,479
mark

154
00:05:30,240 --> 00:05:33,280
and not its parent embassy because core

155
00:05:32,479 --> 00:05:36,560
mark is free

156
00:05:33,280 --> 00:05:37,198
and embassy is not um even though

157
00:05:36,560 --> 00:05:38,639
embassy

158
00:05:37,199 --> 00:05:41,199
being a set of programs is a better

159
00:05:38,639 --> 00:05:43,840
option it must be easy to port and run

160
00:05:41,199 --> 00:05:45,919
if it's a pain to bring it up then

161
00:05:43,840 --> 00:05:47,679
people won't use it

162
00:05:45,919 --> 00:05:49,520
it must be real programs the problem

163
00:05:47,680 --> 00:05:50,880
with synthetic benchmarks is they

164
00:05:49,520 --> 00:05:52,880
they try and capture a bit of everything

165
00:05:50,880 --> 00:05:56,080
and end up being a bit of nothing

166
00:05:52,880 --> 00:05:57,840
and so we wanted to build a benchmark

167
00:05:56,080 --> 00:05:59,599
suite built on real programs like spec

168
00:05:57,840 --> 00:06:03,440
and embassy do

169
00:05:59,600 --> 00:06:04,720
um you look at some of those benchmark

170
00:06:03,440 --> 00:06:06,080
suites drystone there isn't an

171
00:06:04,720 --> 00:06:09,280
organization to maintain it

172
00:06:06,080 --> 00:06:11,440
it's the same forever and forever

173
00:06:09,280 --> 00:06:12,960
so you need a supporting organization to

174
00:06:11,440 --> 00:06:15,120
maintain it

175
00:06:12,960 --> 00:06:16,880
but people still want things simplified

176
00:06:15,120 --> 00:06:18,639
they want a single number so you need a

177
00:06:16,880 --> 00:06:21,199
summarizing score you need to be i said

178
00:06:18,639 --> 00:06:23,440
this is my m bench score

179
00:06:21,199 --> 00:06:23,440
um

180
00:06:24,560 --> 00:06:29,120
there's all sorts of ways you can

181
00:06:25,840 --> 00:06:31,919
summarize we came to the conclusion that

182
00:06:29,120 --> 00:06:34,319
actually benchmark suite can be

183
00:06:31,919 --> 00:06:35,359
dominated by one big program or one fast

184
00:06:34,319 --> 00:06:38,560
program

185
00:06:35,360 --> 00:06:39,680
geometric means actually help to level

186
00:06:38,560 --> 00:06:42,240
that out

187
00:06:39,680 --> 00:06:43,759
and using the standard deviation means

188
00:06:42,240 --> 00:06:45,840
you can see the variability so you can

189
00:06:43,759 --> 00:06:48,160
see if one program is dominating

190
00:06:45,840 --> 00:06:50,239
the impact the other thing we do is we

191
00:06:48,160 --> 00:06:51,120
make the data relative

192
00:06:50,240 --> 00:06:53,360
instead of saying we've done the

193
00:06:51,120 --> 00:06:53,680
geometric of all these program sizes if

194
00:06:53,360 --> 00:06:55,840
we're

195
00:06:53,680 --> 00:06:56,720
measuring code size we'll take it

196
00:06:55,840 --> 00:07:00,840
relevant to

197
00:06:56,720 --> 00:07:04,000
relative to a particular baseline value

198
00:07:00,840 --> 00:07:06,560
and lastly

199
00:07:04,000 --> 00:07:09,120
we see on those benchmark suites there

200
00:07:06,560 --> 00:07:12,880
are some that purely academic

201
00:07:09,120 --> 00:07:16,080
like um tackle bench like my bench

202
00:07:12,880 --> 00:07:17,840
and they're not heavily used in industry

203
00:07:16,080 --> 00:07:19,840
we find things like embassy and spec

204
00:07:17,840 --> 00:07:23,039
mark they've done my industry

205
00:07:19,840 --> 00:07:24,799
but no one uses them widely because

206
00:07:23,039 --> 00:07:26,719
they're all paid for their team to pay

207
00:07:24,800 --> 00:07:28,639
for and they're focused just on

208
00:07:26,720 --> 00:07:29,759
industries needs and coremark is free

209
00:07:28,639 --> 00:07:32,800
and was developed

210
00:07:29,759 --> 00:07:34,160
by industry but

211
00:07:32,800 --> 00:07:36,400
actually hasn't had the input of

212
00:07:34,160 --> 00:07:38,319
academic latest thinking

213
00:07:36,400 --> 00:07:40,239
so we wanted to involve both academia

214
00:07:38,319 --> 00:07:43,599
and industry

215
00:07:40,240 --> 00:07:45,360
so what was the plan so we started the

216
00:07:43,599 --> 00:07:46,479
first six months of last year small four

217
00:07:45,360 --> 00:07:49,599
of us dave patterson

218
00:07:46,479 --> 00:07:50,240
and dave patterson is the originator of

219
00:07:49,599 --> 00:07:52,319
risk one

220
00:07:50,240 --> 00:07:54,240
and the originator of risk five uh

221
00:07:52,319 --> 00:07:55,360
professor professor emeritus now at

222
00:07:54,240 --> 00:07:56,879
berkeley

223
00:07:55,360 --> 00:07:58,560
and he drove that and that's the

224
00:07:56,879 --> 00:08:01,280
connection to ml perth because he also

225
00:07:58,560 --> 00:08:03,199
was behind ml perth

226
00:08:01,280 --> 00:08:04,559
i came in and the reason i came in is my

227
00:08:03,199 --> 00:08:07,280
involvement with biebs and

228
00:08:04,560 --> 00:08:09,199
m bench is derived from biebs palmer

229
00:08:07,280 --> 00:08:10,239
dabelt came in because the risk five

230
00:08:09,199 --> 00:08:11,520
community were

231
00:08:10,240 --> 00:08:13,280
very interesting this at the time he was

232
00:08:11,520 --> 00:08:15,359
at sci-fi he's now at google

233
00:08:13,280 --> 00:08:17,280
and cesare garlatti came in because it's

234
00:08:15,360 --> 00:08:20,720
not all about compute speed

235
00:08:17,280 --> 00:08:23,198
cesare is very much looking at

236
00:08:20,720 --> 00:08:24,400
how fast things react what are context

237
00:08:23,199 --> 00:08:26,720
switch times

238
00:08:24,400 --> 00:08:29,039
what are interrupt handling times so

239
00:08:26,720 --> 00:08:32,399
it's more than just compute times

240
00:08:29,039 --> 00:08:35,760
and for six months we met every month in

241
00:08:32,399 --> 00:08:36,399
california in sci-fi's offices and in

242
00:08:35,760 --> 00:08:38,080
june

243
00:08:36,399 --> 00:08:39,760
we announced this project to the ryder

244
00:08:38,080 --> 00:08:41,279
world and

245
00:08:39,760 --> 00:08:42,799
opened a wider group and there is now

246
00:08:41,279 --> 00:08:44,000
group if you go to mbench.org you can

247
00:08:42,799 --> 00:08:45,120
join the mailing list you can join the

248
00:08:44,000 --> 00:08:46,720
monthly calls

249
00:08:45,120 --> 00:08:48,720
there's a git repository with all this

250
00:08:46,720 --> 00:08:50,720
on okay if you go to embench.org

251
00:08:48,720 --> 00:08:52,000
you can find all the links there and the

252
00:08:50,720 --> 00:08:53,440
goal is to launch

253
00:08:52,000 --> 00:08:55,360
at the end of this month at embedded

254
00:08:53,440 --> 00:08:57,360
world a first version

255
00:08:55,360 --> 00:08:59,360
that is reasonably stable and that

256
00:08:57,360 --> 00:09:00,160
people can try but it is only a first

257
00:08:59,360 --> 00:09:01,760
version

258
00:09:00,160 --> 00:09:03,360
because one of the things that came from

259
00:09:01,760 --> 00:09:04,319
our principles is you've got to keep

260
00:09:03,360 --> 00:09:06,000
this alive

261
00:09:04,320 --> 00:09:07,360
m bench in two years time will be a

262
00:09:06,000 --> 00:09:08,720
different set of programs

263
00:09:07,360 --> 00:09:11,120
because we don't want all the compilers

264
00:09:08,720 --> 00:09:12,720
to be improved to our set of programs

265
00:09:11,120 --> 00:09:14,399
and then they're just good at optimizing

266
00:09:12,720 --> 00:09:15,440
that set of programs

267
00:09:14,399 --> 00:09:16,800
we're going to keep on changing them

268
00:09:15,440 --> 00:09:18,720
that's what spec mark's done it's what

269
00:09:16,800 --> 00:09:22,319
embassy's done

270
00:09:18,720 --> 00:09:23,920
okay um it's currently

271
00:09:22,320 --> 00:09:25,200
we tried not to do everything at once

272
00:09:23,920 --> 00:09:25,839
because otherwise you'll see so we've

273
00:09:25,200 --> 00:09:28,480
focused

274
00:09:25,839 --> 00:09:29,680
initially just on the small iot class

275
00:09:28,480 --> 00:09:33,760
device

276
00:09:29,680 --> 00:09:36,160
64k ram rom and

277
00:09:33,760 --> 00:09:38,240
we've got 19 benchmarks which are small

278
00:09:36,160 --> 00:09:40,399
program kernels real programmed kernels

279
00:09:38,240 --> 00:09:41,760
aimed at deeply embedded computing we'd

280
00:09:40,399 --> 00:09:43,839
like a couple more i think we're running

281
00:09:41,760 --> 00:09:45,600
out of time for 0.5 we'd like to get

282
00:09:43,839 --> 00:09:47,279
bluetooth le represented in there we'd

283
00:09:45,600 --> 00:09:48,880
like elliptic curve dsa

284
00:09:47,279 --> 00:09:50,320
it's quite hard to find an elliptic

285
00:09:48,880 --> 00:09:52,240
curve dsa system

286
00:09:50,320 --> 00:09:53,360
that's real that will fit in that size

287
00:09:52,240 --> 00:09:57,680
program

288
00:09:53,360 --> 00:09:59,040
okay so um we also have an early version

289
00:09:57,680 --> 00:10:00,560
of a context switching

290
00:09:59,040 --> 00:10:02,480
benchmark so that's that thing that

291
00:10:00,560 --> 00:10:04,160
chesra is interested in we really would

292
00:10:02,480 --> 00:10:04,959
like more help with that that's not

293
00:10:04,160 --> 00:10:07,839
going to be

294
00:10:04,959 --> 00:10:09,680
that's going to be a just an exemplar

295
00:10:07,839 --> 00:10:11,519
that has to be written in assembler

296
00:10:09,680 --> 00:10:13,120
it's not a program you just compile and

297
00:10:11,519 --> 00:10:14,560
run it's a

298
00:10:13,120 --> 00:10:16,240
description of how you write an

299
00:10:14,560 --> 00:10:17,439
assembler program to measure this on

300
00:10:16,240 --> 00:10:20,480
your platform

301
00:10:17,440 --> 00:10:22,880
okay at this stage

302
00:10:20,480 --> 00:10:24,640
um we've got simple python build and run

303
00:10:22,880 --> 00:10:26,480
script and that's where the last minute

304
00:10:24,640 --> 00:10:29,519
panic work is being done at the moment

305
00:10:26,480 --> 00:10:32,560
is to get that clean and easy to use

306
00:10:29,519 --> 00:10:34,160
ready for uh three weeks time um

307
00:10:32,560 --> 00:10:35,518
so far most of the testing has actually

308
00:10:34,160 --> 00:10:36,719
been with verilator models and

309
00:10:35,519 --> 00:10:38,399
simulators

310
00:10:36,720 --> 00:10:39,680
the latest work is starting to actually

311
00:10:38,399 --> 00:10:41,279
get it working on real hardware because

312
00:10:39,680 --> 00:10:43,439
it's no use if you can't run it on real

313
00:10:41,279 --> 00:10:45,680
hardware and for deeply embedded systems

314
00:10:43,440 --> 00:10:47,279
that's not quite as easy as it is for

315
00:10:45,680 --> 00:10:50,479
something running linux

316
00:10:47,279 --> 00:10:51,760
okay um so we're widening it um you'll

317
00:10:50,480 --> 00:10:54,240
see me talking about

318
00:10:51,760 --> 00:10:55,360
arm and uh risk five today because i

319
00:10:54,240 --> 00:10:56,880
want to do comparative stuff but we've

320
00:10:55,360 --> 00:10:57,680
done it on arc we've done it on atmel

321
00:10:56,880 --> 00:10:59,600
avr

322
00:10:57,680 --> 00:11:02,160
and we'll do it on more as we go forward

323
00:10:59,600 --> 00:11:05,040
so we've got a benchmark suite

324
00:11:02,160 --> 00:11:06,000
here it is here are the 19 programs each

325
00:11:05,040 --> 00:11:08,240
none of these are new

326
00:11:06,000 --> 00:11:09,120
we've taken them from other people okay

327
00:11:08,240 --> 00:11:12,800
they're free and open

328
00:11:09,120 --> 00:11:14,480
it's gpl3 licensed you can see

329
00:11:12,800 --> 00:11:16,079
their hundreds or a small number of

330
00:11:14,480 --> 00:11:18,240
thousands of lines of code

331
00:11:16,079 --> 00:11:20,719
they're hundreds or i think the biggest

332
00:11:18,240 --> 00:11:24,000
what 10 kilobytes of um

333
00:11:20,720 --> 00:11:24,560
code and data size and code size data

334
00:11:24,000 --> 00:11:26,800
size

335
00:11:24,560 --> 00:11:28,079
and they've all been normalized to sit

336
00:11:26,800 --> 00:11:31,040
in a loop so they all take about

337
00:11:28,079 --> 00:11:31,040
four seconds to run

338
00:11:31,120 --> 00:11:34,480
on any platform and there is a parameter

339
00:11:33,200 --> 00:11:36,079
to control that

340
00:11:34,480 --> 00:11:37,920
the other thing is they're tried to be a

341
00:11:36,079 --> 00:11:38,800
mix and this is something that came from

342
00:11:37,920 --> 00:11:41,360
biebs

343
00:11:38,800 --> 00:11:43,680
so we looked at what the proportion of

344
00:11:41,360 --> 00:11:46,079
branching programs memory access

345
00:11:43,680 --> 00:11:46,800
was in alu in the programs and you can

346
00:11:46,079 --> 00:11:48,959
see here

347
00:11:46,800 --> 00:11:49,839
some of them have got lots of branches

348
00:11:48,959 --> 00:11:51,518
some of them have got

349
00:11:49,839 --> 00:11:53,200
very few branches some have got lots of

350
00:11:51,519 --> 00:11:54,720
arithmetic some have got a few

351
00:11:53,200 --> 00:11:56,480
some have got a lot of memory some have

352
00:11:54,720 --> 00:11:57,680
got a few there's no floating point in

353
00:11:56,480 --> 00:11:59,040
here one of the things we also said

354
00:11:57,680 --> 00:12:01,279
let's just do an integer one to start

355
00:11:59,040 --> 00:12:03,279
with we'll worry about floating point

356
00:12:01,279 --> 00:12:04,560
well there's almost no floating point

357
00:12:03,279 --> 00:12:05,600
you can't have real programs with a

358
00:12:04,560 --> 00:12:06,800
little bit floating point but we've

359
00:12:05,600 --> 00:12:11,839
thrown out the exclu

360
00:12:06,800 --> 00:12:11,839
the explicitly floating point ones

361
00:12:12,880 --> 00:12:18,560
so that's the benchmark suite i say

362
00:12:16,079 --> 00:12:20,319
please join in it it is a community

363
00:12:18,560 --> 00:12:22,800
effort there is no one paying for it

364
00:12:20,320 --> 00:12:24,959
other than people giving up their time

365
00:12:22,800 --> 00:12:26,160
the group is chaired by dave patterson

366
00:12:24,959 --> 00:12:26,959
so it's a good chance to get to know

367
00:12:26,160 --> 00:12:28,240
dave if you

368
00:12:26,959 --> 00:12:30,239
want to talk to one of our great

369
00:12:28,240 --> 00:12:31,360
computer scientists i'm the vice chair

370
00:12:30,240 --> 00:12:32,240
so i'm the one who makes sure all the

371
00:12:31,360 --> 00:12:34,800
meetings happen

372
00:12:32,240 --> 00:12:34,800
and so forth

373
00:12:36,560 --> 00:12:39,680
this is not really a talk about m bench

374
00:12:38,399 --> 00:12:41,680
i just wanted you to know about it

375
00:12:39,680 --> 00:12:44,800
because this is a talk about compiler

376
00:12:41,680 --> 00:12:47,199
in optimization so

377
00:12:44,800 --> 00:12:49,199
what affects m bench or indeed any

378
00:12:47,200 --> 00:12:50,880
benchmark results

379
00:12:49,200 --> 00:12:52,639
well the instruction said architecture

380
00:12:50,880 --> 00:12:54,079
how good is your architecture is it arm

381
00:12:52,639 --> 00:12:57,360
or risk 5 or

382
00:12:54,079 --> 00:12:59,359
arc or avr

383
00:12:57,360 --> 00:13:01,360
okay what extensions are using is it the

384
00:12:59,360 --> 00:13:03,200
arm v7 or the v8 architecture using

385
00:13:01,360 --> 00:13:05,279
thumb thumb 2

386
00:13:03,200 --> 00:13:07,519
are you using rv32 which they have

387
00:13:05,279 --> 00:13:09,839
extensions mcb whatever

388
00:13:07,519 --> 00:13:11,760
okay what compiler are you using one of

389
00:13:09,839 --> 00:13:14,800
the open ones like gcc

390
00:13:11,760 --> 00:13:17,360
or clang uh as a clang lvm or a

391
00:13:14,800 --> 00:13:20,719
proprietary one like iar

392
00:13:17,360 --> 00:13:22,079
okay and which optimizations are

393
00:13:20,720 --> 00:13:23,839
including so you're using the compiler

394
00:13:22,079 --> 00:13:25,439
but how much optimization you turned on

395
00:13:23,839 --> 00:13:27,040
are you optimizing for size are you

396
00:13:25,440 --> 00:13:31,040
optimizing for speed

397
00:13:27,040 --> 00:13:32,480
okay okay and you might think that

398
00:13:31,040 --> 00:13:34,160
you've got a brand new

399
00:13:32,480 --> 00:13:35,839
architecture come out its compiler might

400
00:13:34,160 --> 00:13:38,160
be immature

401
00:13:35,839 --> 00:13:39,920
and if you've got an old architecture

402
00:13:38,160 --> 00:13:41,279
its compiler might be mature so

403
00:13:39,920 --> 00:13:42,719
today i'm going to look at arm and risk

404
00:13:41,279 --> 00:13:44,079
five risk five quite new i've been

405
00:13:42,720 --> 00:13:45,279
around for a while

406
00:13:44,079 --> 00:13:47,599
the other thing that can affect things

407
00:13:45,279 --> 00:13:48,079
is the libraries and i'm not going to

408
00:13:47,600 --> 00:13:50,639
talk about

409
00:13:48,079 --> 00:13:52,160
libraries today but you can make your

410
00:13:50,639 --> 00:13:54,320
programs as good as you like but if your

411
00:13:52,160 --> 00:13:55,040
libraries they rely on and even embedded

412
00:13:54,320 --> 00:13:56,639
systems

413
00:13:55,040 --> 00:13:58,959
rely on libraries for things like

414
00:13:56,639 --> 00:14:02,639
emulation and so forth

415
00:13:58,959 --> 00:14:03,518
of floating points what however much you

416
00:14:02,639 --> 00:14:05,279
rely on that

417
00:14:03,519 --> 00:14:06,880
um you're going to have some library

418
00:14:05,279 --> 00:14:09,040
code in there so

419
00:14:06,880 --> 00:14:09,920
m bench at the moment and this is still

420
00:14:09,040 --> 00:14:12,240
a bit of a debate

421
00:14:09,920 --> 00:14:13,120
excludes libraries when sizing because

422
00:14:12,240 --> 00:14:14,720
actually

423
00:14:13,120 --> 00:14:16,800
even the little emulation libraries the

424
00:14:14,720 --> 00:14:17,440
c runtime startup for those smaller

425
00:14:16,800 --> 00:14:19,199
programs

426
00:14:17,440 --> 00:14:20,480
they can completely dominate the code

427
00:14:19,199 --> 00:14:22,479
size um

428
00:14:20,480 --> 00:14:23,760
less so the performance and we don't

429
00:14:22,480 --> 00:14:25,199
want to keep on measuring the same thing

430
00:14:23,760 --> 00:14:27,760
again

431
00:14:25,199 --> 00:14:29,519
so if i want to use it for compiler

432
00:14:27,760 --> 00:14:31,360
let's have a comparison matrix because

433
00:14:29,519 --> 00:14:32,880
what i want to do is learn from other

434
00:14:31,360 --> 00:14:34,720
people just as the previous talk

435
00:14:32,880 --> 00:14:36,320
you've got the question about llvmg and

436
00:14:34,720 --> 00:14:39,199
lldb and gdb

437
00:14:36,320 --> 00:14:40,480
you can learn from each other so let's

438
00:14:39,199 --> 00:14:44,959
look in two dimensions

439
00:14:40,480 --> 00:14:47,600
what can we learn by comparing tang llvm

440
00:14:44,959 --> 00:14:49,439
with gcc for a particular architecture

441
00:14:47,600 --> 00:14:52,480
and secondly what can we learn

442
00:14:49,440 --> 00:14:53,360
by comparing clang llvm for different

443
00:14:52,480 --> 00:14:55,440
architectures

444
00:14:53,360 --> 00:14:56,880
what does clang llvm do well on one

445
00:14:55,440 --> 00:14:59,279
architecture and near another

446
00:14:56,880 --> 00:15:02,240
and the idea here is to share knowledge

447
00:14:59,279 --> 00:15:05,600
to learn from others

448
00:15:02,240 --> 00:15:09,199
so the gross level we can

449
00:15:05,600 --> 00:15:12,320
actually look at two compilers so here's

450
00:15:09,199 --> 00:15:14,959
risk five llvm against risk five gcc

451
00:15:12,320 --> 00:15:16,560
i've looked at code size i've looked at

452
00:15:14,959 --> 00:15:18,000
the various optimization levels and what

453
00:15:16,560 --> 00:15:22,239
it does to code size

454
00:15:18,000 --> 00:15:25,279
so you can see here that um

455
00:15:22,240 --> 00:15:26,079
as we increase optimization code gets

456
00:15:25,279 --> 00:15:28,160
bigger

457
00:15:26,079 --> 00:15:30,000
okay and notice that they're all

458
00:15:28,160 --> 00:15:31,120
normalized to a reference platform the

459
00:15:30,000 --> 00:15:35,120
reference platform

460
00:15:31,120 --> 00:15:38,160
happens to be the code size of um

461
00:15:35,120 --> 00:15:40,880
risk five imc run with minus os using

462
00:15:38,160 --> 00:15:42,000
gcc nine okay

463
00:15:40,880 --> 00:15:43,680
that's actually going to change the

464
00:15:42,000 --> 00:15:45,920
release the reference base architecture

465
00:15:43,680 --> 00:15:48,160
will be cortex m4 but

466
00:15:45,920 --> 00:15:49,680
i'm using what we've got today and you

467
00:15:48,160 --> 00:15:52,800
can see there are little bars

468
00:15:49,680 --> 00:15:54,959
those bars are the geometric

469
00:15:52,800 --> 00:15:55,920
a single geometric standard deviation up

470
00:15:54,959 --> 00:15:58,800
and down

471
00:15:55,920 --> 00:16:00,560
okay and you can see that you know this

472
00:15:58,800 --> 00:16:02,800
is close to the reference

473
00:16:00,560 --> 00:16:03,839
okay um so this is the reference for

474
00:16:02,800 --> 00:16:06,800
size os

475
00:16:03,839 --> 00:16:09,040
okay and the error bars are quite small

476
00:16:06,800 --> 00:16:12,399
up this end they're quite big

477
00:16:09,040 --> 00:16:12,399
okay and

478
00:16:12,800 --> 00:16:17,040
we can also look at code speed so m

479
00:16:15,040 --> 00:16:18,719
bench doesn't actually say

480
00:16:17,040 --> 00:16:20,719
what the metric is for you can do it for

481
00:16:18,720 --> 00:16:22,000
code size you can do it for code speed

482
00:16:20,720 --> 00:16:24,639
we haven't done it yet but in principle

483
00:16:22,000 --> 00:16:28,079
you could do it for energy efficiency

484
00:16:24,639 --> 00:16:30,880
okay and if we look at code speed

485
00:16:28,079 --> 00:16:32,399
um what we find here is that obviously

486
00:16:30,880 --> 00:16:33,439
when you go for small code things go a

487
00:16:32,399 --> 00:16:36,480
bit slower

488
00:16:33,440 --> 00:16:38,639
when you go for high optimization things

489
00:16:36,480 --> 00:16:40,959
go a bit faster

490
00:16:38,639 --> 00:16:42,560
this time it's normalized against risk 5

491
00:16:40,959 --> 00:16:47,279
32 imc

492
00:16:42,560 --> 00:16:49,599
um with minus o2 and gcc 9.

493
00:16:47,279 --> 00:16:51,279
um perhaps surprising for risk 5 you

494
00:16:49,600 --> 00:16:52,720
don't get a huge amount of speed up

495
00:16:51,279 --> 00:16:55,600
optimization is not

496
00:16:52,720 --> 00:16:56,000
perhaps as effective as you might hope

497
00:16:55,600 --> 00:16:58,800
so

498
00:16:56,000 --> 00:17:02,000
we can do that gross comparison that's

499
00:16:58,800 --> 00:17:04,879
just to give us a big picture

500
00:17:02,000 --> 00:17:06,559
and we can look by architecture um for

501
00:17:04,880 --> 00:17:07,919
architecture i'm going to focus on code

502
00:17:06,559 --> 00:17:08,720
size the reason for that is i haven't

503
00:17:07,919 --> 00:17:10,799
actually got

504
00:17:08,720 --> 00:17:11,919
good reliable measurements of arm

505
00:17:10,799 --> 00:17:13,839
execution speed

506
00:17:11,919 --> 00:17:15,439
and because i'm focusing on embedded i'm

507
00:17:13,839 --> 00:17:16,720
going to focus for the moment on cut

508
00:17:15,439 --> 00:17:20,400
this the rest of this talk

509
00:17:16,720 --> 00:17:22,240
on optimization for code size the same

510
00:17:20,400 --> 00:17:24,160
analysis applies to optimization for

511
00:17:22,240 --> 00:17:27,760
code speed it's just i've only got

512
00:17:24,160 --> 00:17:29,679
a 40 minutes long okay so code size by

513
00:17:27,760 --> 00:17:31,679
architecture so yellow for arm

514
00:17:29,679 --> 00:17:33,120
and here you see the arm is a more

515
00:17:31,679 --> 00:17:36,720
mature compiler

516
00:17:33,120 --> 00:17:38,320
when you optimize for size it actually

517
00:17:36,720 --> 00:17:41,679
does better

518
00:17:38,320 --> 00:17:43,678
than risk five when it's a more mature

519
00:17:41,679 --> 00:17:46,400
architecture with a mortgage

520
00:17:43,679 --> 00:17:48,080
when you optimize for speed actually

521
00:17:46,400 --> 00:17:49,679
arms code size goes out the window but

522
00:17:48,080 --> 00:17:52,080
that's a bit because arm is doing

523
00:17:49,679 --> 00:17:53,280
far more optimizations there if i did

524
00:17:52,080 --> 00:17:54,799
have the performance figures you'd

525
00:17:53,280 --> 00:17:56,960
actually see arm gets much more of a

526
00:17:54,799 --> 00:17:58,799
speed up when you turn on -3

527
00:17:56,960 --> 00:18:00,400
okay that's at the expense of doing a

528
00:17:58,799 --> 00:18:02,480
lot of a loop unrolling and

529
00:18:00,400 --> 00:18:03,760
inlining and so forth so the code size

530
00:18:02,480 --> 00:18:05,200
gets bigger that's exactly what you

531
00:18:03,760 --> 00:18:07,200
would expect to see

532
00:18:05,200 --> 00:18:09,039
so far so good but it doesn't hugely

533
00:18:07,200 --> 00:18:10,799
help the compiler writer beyond being

534
00:18:09,039 --> 00:18:11,919
able to talk about how good my compiler

535
00:18:10,799 --> 00:18:14,160
is in the in the round

536
00:18:11,919 --> 00:18:15,360
that's not what i'm interested in so

537
00:18:14,160 --> 00:18:17,760
let's go down

538
00:18:15,360 --> 00:18:20,479
to the next level and let's look at

539
00:18:17,760 --> 00:18:23,840
individual benchmarks

540
00:18:20,480 --> 00:18:25,360
um let's compare llvm and gcc code size

541
00:18:23,840 --> 00:18:27,600
this is for risk five

542
00:18:25,360 --> 00:18:29,439
with minus os there's optimization for

543
00:18:27,600 --> 00:18:32,320
size i've compared with minus os

544
00:18:29,440 --> 00:18:33,360
because gcc does not support minus oz

545
00:18:32,320 --> 00:18:36,320
okay

546
00:18:33,360 --> 00:18:37,120
now you can see there just visually that

547
00:18:36,320 --> 00:18:40,720
some of the

548
00:18:37,120 --> 00:18:44,320
benchmarks risk five

549
00:18:40,720 --> 00:18:45,919
has bigger code and uh and so llvm has

550
00:18:44,320 --> 00:18:47,840
bigger code and gcc has

551
00:18:45,919 --> 00:18:49,679
smaller code and for others it's the

552
00:18:47,840 --> 00:18:51,280
other way around but it's a bit all over

553
00:18:49,679 --> 00:18:52,720
the place it's much better if you sort

554
00:18:51,280 --> 00:18:54,879
those benchmarks

555
00:18:52,720 --> 00:18:56,640
by that's exactly the same data but i've

556
00:18:54,880 --> 00:18:59,200
now sorted by the difference so at the

557
00:18:56,640 --> 00:19:02,559
end you've got a harmon 64.

558
00:18:59,200 --> 00:19:05,039
and for that llvm

559
00:19:02,559 --> 00:19:06,879
the the geometric mean sorry sorry the

560
00:19:05,039 --> 00:19:07,840
llvmv the code size there's no means

561
00:19:06,880 --> 00:19:08,640
here because this is individual

562
00:19:07,840 --> 00:19:12,000
benchmarks

563
00:19:08,640 --> 00:19:13,280
um is nearly twice as big as the code

564
00:19:12,000 --> 00:19:16,880
size that you get

565
00:19:13,280 --> 00:19:19,200
with um gcc so we could learn

566
00:19:16,880 --> 00:19:21,919
something by looking at that one what is

567
00:19:19,200 --> 00:19:24,559
it with that particular benchmark

568
00:19:21,919 --> 00:19:26,400
that risk five does so dreadfully so

569
00:19:24,559 --> 00:19:29,918
that llvm does so dreadfully

570
00:19:26,400 --> 00:19:30,480
when compared with gcc up the other end

571
00:19:29,919 --> 00:19:32,320
here

572
00:19:30,480 --> 00:19:34,240
we can look at huff bench and say there

573
00:19:32,320 --> 00:19:34,799
are some there where llvms getting it

574
00:19:34,240 --> 00:19:37,919
right

575
00:19:34,799 --> 00:19:40,320
what's llvm doing right about bench

576
00:19:37,919 --> 00:19:41,360
that gcc isn't so good and that helps

577
00:19:40,320 --> 00:19:43,200
both the gcc

578
00:19:41,360 --> 00:19:44,719
and the llvm team it's not this is not

579
00:19:43,200 --> 00:19:48,720
who's got the better compiler

580
00:19:44,720 --> 00:19:51,919
it's what can i learn from each other um

581
00:19:48,720 --> 00:19:52,559
and we can do the same analysis on arm

582
00:19:51,919 --> 00:19:55,840
okay

583
00:19:52,559 --> 00:19:56,320
and so you can see from arm that there

584
00:19:55,840 --> 00:19:58,240
is

585
00:19:56,320 --> 00:19:59,678
the cubic program and the crypto

586
00:19:58,240 --> 00:20:01,520
programs

587
00:19:59,679 --> 00:20:03,440
arms code size is really good if you

588
00:20:01,520 --> 00:20:05,039
want to write a small crypto program

589
00:20:03,440 --> 00:20:06,720
choose arm as your architecture not risk

590
00:20:05,039 --> 00:20:08,960
five that's the message there

591
00:20:06,720 --> 00:20:10,880
um but there are others here where um

592
00:20:08,960 --> 00:20:12,159
they're solving the n body problem and a

593
00:20:10,880 --> 00:20:15,360
state machine

594
00:20:12,159 --> 00:20:16,640
actually um the compile code for risk

595
00:20:15,360 --> 00:20:18,959
five with llvm

596
00:20:16,640 --> 00:20:20,000
is better than that for arm okay so we

597
00:20:18,960 --> 00:20:21,360
can look at both of those

598
00:20:20,000 --> 00:20:23,440
and the arm guys can look at that and

599
00:20:21,360 --> 00:20:24,719
see well what is it that the risk five

600
00:20:23,440 --> 00:20:27,840
compiler is getting right

601
00:20:24,720 --> 00:20:27,840
the arm could learn from

602
00:20:29,440 --> 00:20:33,679
so we're starting to get now and see

603
00:20:32,080 --> 00:20:34,158
there are some interesting programs

604
00:20:33,679 --> 00:20:36,000
there

605
00:20:34,159 --> 00:20:38,000
so let's go deep and this is where we

606
00:20:36,000 --> 00:20:40,640
start to get the useful information

607
00:20:38,000 --> 00:20:42,880
there's a really good option to nm that

608
00:20:40,640 --> 00:20:46,159
sorts your symbols by size so i've

609
00:20:42,880 --> 00:20:49,280
done nm size sort for the clang

610
00:20:46,159 --> 00:20:52,000
and gcc compilations of the program with

611
00:20:49,280 --> 00:20:54,960
the biggest difference

612
00:20:52,000 --> 00:20:56,960
okay and i've only shown the text size

613
00:20:54,960 --> 00:20:58,880
that i've stripped out all the data

614
00:20:56,960 --> 00:21:00,880
results there because not interested at

615
00:20:58,880 --> 00:21:03,120
the moment

616
00:21:00,880 --> 00:21:05,039
i draw your attention to this there

617
00:21:03,120 --> 00:21:08,719
appear to be three programs

618
00:21:05,039 --> 00:21:10,559
in the gcc image that are not

619
00:21:08,720 --> 00:21:13,200
so three functions that are not in the

620
00:21:10,559 --> 00:21:16,720
clang image

621
00:21:13,200 --> 00:21:19,760
those have clearly been in lined

622
00:21:16,720 --> 00:21:23,679
and you can see that that

623
00:21:19,760 --> 00:21:26,879
the benchmark body is a hex 160

624
00:21:23,679 --> 00:21:30,000
on gcc and the benchmark body over there

625
00:21:26,880 --> 00:21:33,840
is 5 c6 so it's much much bigger

626
00:21:30,000 --> 00:21:37,200
three times bigger on clang llvm so

627
00:21:33,840 --> 00:21:37,199
let's delve in deeper

628
00:21:37,840 --> 00:21:41,199
well if we look at the source code

629
00:21:39,320 --> 00:21:44,320
mont64.c for this

630
00:21:41,200 --> 00:21:47,360
we'll see that those famous functions

631
00:21:44,320 --> 00:21:50,559
mal 64 modulo 64

632
00:21:47,360 --> 00:21:52,559
are called many times

633
00:21:50,559 --> 00:21:54,480
partly from mold but mostly in benchmark

634
00:21:52,559 --> 00:21:57,760
body okay

635
00:21:54,480 --> 00:21:59,679
so if i am doing in lining

636
00:21:57,760 --> 00:22:01,039
i'm going to put three copies of each of

637
00:21:59,679 --> 00:22:03,520
those

638
00:22:01,039 --> 00:22:05,840
into the benchmark body which given i'm

639
00:22:03,520 --> 00:22:07,918
optimizing for size is possibly

640
00:22:05,840 --> 00:22:08,879
not such a good thing the third one that

641
00:22:07,919 --> 00:22:12,000
we're missing

642
00:22:08,880 --> 00:22:12,960
um the xgcd function actually only

643
00:22:12,000 --> 00:22:14,159
appears once

644
00:22:12,960 --> 00:22:16,240
inlining something that only appears

645
00:22:14,159 --> 00:22:17,760
once is probably not a bad idea for code

646
00:22:16,240 --> 00:22:20,720
size

647
00:22:17,760 --> 00:22:22,320
okay and we see that if we disassemble

648
00:22:20,720 --> 00:22:23,520
the benchmark body because if you look

649
00:22:22,320 --> 00:22:25,840
in benchmark body

650
00:22:23,520 --> 00:22:28,240
you see series of coatings that become

651
00:22:25,840 --> 00:22:30,879
mul uh mullah chumulhu

652
00:22:28,240 --> 00:22:31,919
mul ad and that same sequence appears

653
00:22:30,880 --> 00:22:34,480
three times

654
00:22:31,919 --> 00:22:35,200
which is the inlining three times of the

655
00:22:34,480 --> 00:22:38,080
function

656
00:22:35,200 --> 00:22:39,919
whereas it those are the only moles you

657
00:22:38,080 --> 00:22:40,879
see at all in benchmark body and gcc and

658
00:22:39,919 --> 00:22:42,880
they're nothing to do with those

659
00:22:40,880 --> 00:22:45,760
functions anyway

660
00:22:42,880 --> 00:22:47,840
what that's telling us there is we can

661
00:22:45,760 --> 00:22:49,120
learn there there's too much inlining

662
00:22:47,840 --> 00:22:52,840
going on

663
00:22:49,120 --> 00:22:55,120
arguably in llvm for minus os

664
00:22:52,840 --> 00:22:57,760
now there is a case to be made for

665
00:22:55,120 --> 00:23:00,239
saying well but i've got minus oz

666
00:22:57,760 --> 00:23:01,919
in llvm and maybe i'll turn it off in

667
00:23:00,240 --> 00:23:04,480
minus oz

668
00:23:01,919 --> 00:23:05,440
but that's given you some insight that

669
00:23:04,480 --> 00:23:07,120
if you've got

670
00:23:05,440 --> 00:23:08,880
you're worried that os is perhaps not

671
00:23:07,120 --> 00:23:10,559
yielding what you want you could perhaps

672
00:23:08,880 --> 00:23:13,039
look at inlining

673
00:23:10,559 --> 00:23:14,960
and in fact you can look at the debug

674
00:23:13,039 --> 00:23:16,960
information because there's a helpful dw

675
00:23:14,960 --> 00:23:18,480
tag inline subroutine to tell you when

676
00:23:16,960 --> 00:23:20,960
you've inlined something

677
00:23:18,480 --> 00:23:22,000
and if we compare all the binaries llvm

678
00:23:20,960 --> 00:23:25,600
and gcc

679
00:23:22,000 --> 00:23:27,840
we see that in general that llvm

680
00:23:25,600 --> 00:23:28,879
at minus os does far more in lining so

681
00:23:27,840 --> 00:23:31,918
if we want to improve

682
00:23:28,880 --> 00:23:35,200
llvm for risk five one thing we could do

683
00:23:31,919 --> 00:23:37,280
is reduce the heuristics that control

684
00:23:35,200 --> 00:23:40,559
the amount of inlining going on

685
00:23:37,280 --> 00:23:40,559
okay and

686
00:23:40,640 --> 00:23:45,360
i draw your attention to pico jpeg now

687
00:23:43,360 --> 00:23:46,799
pico jpeg i think is third in the list

688
00:23:45,360 --> 00:23:48,879
of ones with differences

689
00:23:46,799 --> 00:23:50,960
and look at that it's got 180 in line

690
00:23:48,880 --> 00:23:54,080
functions compared to 40 and gcc

691
00:23:50,960 --> 00:23:55,679
even gcc doesn't mean lining here but

692
00:23:54,080 --> 00:23:57,760
the point is it it's got that

693
00:23:55,679 --> 00:23:59,919
huge amount of inline going on it's not

694
00:23:57,760 --> 00:24:01,600
actually it is only third in the list

695
00:23:59,919 --> 00:24:03,520
it's not top of the list

696
00:24:01,600 --> 00:24:04,719
so there's more going on in code size

697
00:24:03,520 --> 00:24:06,559
than that so we've done a bit more

698
00:24:04,720 --> 00:24:08,400
digging and this can go on for ages and

699
00:24:06,559 --> 00:24:10,559
ages and i'm not going to go on for ages

700
00:24:08,400 --> 00:24:15,200
and ages

701
00:24:10,559 --> 00:24:15,200
so if we look at

702
00:24:15,360 --> 00:24:19,199
cubic minus os which is one where the

703
00:24:17,760 --> 00:24:20,240
inlining is lesser in fact there's no

704
00:24:19,200 --> 00:24:23,600
inlining gone on

705
00:24:20,240 --> 00:24:26,799
at all in cubic but cubic is still worse

706
00:24:23,600 --> 00:24:28,719
um between clang and gcc

707
00:24:26,799 --> 00:24:32,240
what we see is the main routine solved

708
00:24:28,720 --> 00:24:34,240
cubic is notably bigger

709
00:24:32,240 --> 00:24:36,640
on there so that suggests looking at

710
00:24:34,240 --> 00:24:40,000
solve cubic would be an idea

711
00:24:36,640 --> 00:24:43,520
well the first thing we notice is that

712
00:24:40,000 --> 00:24:44,799
the first line of solve cubic is to set

713
00:24:43,520 --> 00:24:47,679
up the stack

714
00:24:44,799 --> 00:24:48,840
and on llvm i have a far far bigger

715
00:24:47,679 --> 00:24:52,320
stack frame

716
00:24:48,840 --> 00:24:55,600
1424 compared to 304 bytes

717
00:24:52,320 --> 00:24:58,639
on them on

718
00:24:55,600 --> 00:25:00,000
gcc and the reason for that becomes

719
00:24:58,640 --> 00:25:02,080
clear so that gives you a hint

720
00:25:00,000 --> 00:25:04,080
that what's what's the difference there

721
00:25:02,080 --> 00:25:08,080
and you can see it here

722
00:25:04,080 --> 00:25:08,080
which is where um

723
00:25:08,240 --> 00:25:12,080
i've looked at one particular line of

724
00:25:10,320 --> 00:25:13,279
code and how it's translated i've picked

725
00:25:12,080 --> 00:25:14,720
this out to illustrate it we looked at

726
00:25:13,279 --> 00:25:18,880
the whole thing but

727
00:25:14,720 --> 00:25:21,840
um look at this

728
00:25:18,880 --> 00:25:24,080
when i want to load a constant llvm

729
00:25:21,840 --> 00:25:25,039
explicitly loads a 32-bit constant by

730
00:25:24,080 --> 00:25:27,918
loading the upper

731
00:25:25,039 --> 00:25:30,320
immediate and then adding in the lower

732
00:25:27,919 --> 00:25:30,320
bits

733
00:25:30,400 --> 00:25:36,640
gcc has a small data area

734
00:25:34,799 --> 00:25:38,320
where it puts those constants at once

735
00:25:36,640 --> 00:25:42,559
and it can do a single load

736
00:25:38,320 --> 00:25:43,918
so 32 bits here 64 bits needed here

737
00:25:42,559 --> 00:25:45,918
okay so that's one of the reasons the

738
00:25:43,919 --> 00:25:47,039
code size and

739
00:25:45,919 --> 00:25:48,480
there's an element you're going to end

740
00:25:47,039 --> 00:25:50,400
up saving stuff on stack which is why

741
00:25:48,480 --> 00:25:53,919
the stack has got so big

742
00:25:50,400 --> 00:25:53,919
okay and

743
00:25:54,799 --> 00:25:58,240
if you go and look and debug and look at

744
00:25:56,640 --> 00:26:00,000
the s data

745
00:25:58,240 --> 00:26:03,840
a begin plus a they do have the

746
00:26:00,000 --> 00:26:07,039
constants in there that you would expect

747
00:26:03,840 --> 00:26:09,039
so gcc is making aggressive uses of a

748
00:26:07,039 --> 00:26:12,400
small data section that

749
00:26:09,039 --> 00:26:14,158
hasn't made it into lvm yet so there's a

750
00:26:12,400 --> 00:26:17,120
an optimization we could add to clang

751
00:26:14,159 --> 00:26:19,039
llvm by looking at what gcc does

752
00:26:17,120 --> 00:26:20,879
but we can also learn more from gcc

753
00:26:19,039 --> 00:26:22,559
because actually

754
00:26:20,880 --> 00:26:24,880
the first two times that it does two

755
00:26:22,559 --> 00:26:25,678
32-bit instructions to load two 32-bit

756
00:26:24,880 --> 00:26:29,039
constants

757
00:26:25,679 --> 00:26:32,320
those 32-bit constants are zero

758
00:26:29,039 --> 00:26:33,279
at ox four zero zero zero zero zero zero

759
00:26:32,320 --> 00:26:36,639
zero

760
00:26:33,279 --> 00:26:39,440
okay and llvm actually

761
00:26:36,640 --> 00:26:42,080
is intelligent so yes it uses small data

762
00:26:39,440 --> 00:26:43,760
but it uses it mindlessly in gcc

763
00:26:42,080 --> 00:26:45,678
llvm doesn't use small data but it's

764
00:26:43,760 --> 00:26:47,039
quite intelligent about constants it can

765
00:26:45,679 --> 00:26:49,039
do clever things with

766
00:26:47,039 --> 00:26:50,879
so it knows that it can use a short

767
00:26:49,039 --> 00:26:54,000
instruction c dot li just to load z

768
00:26:50,880 --> 00:26:55,840
a 32 bit zero value and it knows

769
00:26:54,000 --> 00:26:57,600
it can actually only need to load the

770
00:26:55,840 --> 00:27:00,559
upper bits to set

771
00:26:57,600 --> 00:27:01,360
um that big constant there so in this

772
00:27:00,559 --> 00:27:04,320
case

773
00:27:01,360 --> 00:27:04,320
gcc used

774
00:27:04,480 --> 00:27:10,720
64 bits we only use 48 bits in

775
00:27:08,000 --> 00:27:11,279
clang llvm so the gcc guys can learn

776
00:27:10,720 --> 00:27:13,919
something from

777
00:27:11,279 --> 00:27:15,760
clang llvm on that one and the point of

778
00:27:13,919 --> 00:27:18,320
the benchmark suite is

779
00:27:15,760 --> 00:27:20,080
it gave you the pointers to find this

780
00:27:18,320 --> 00:27:22,320
and that's why benchmark suite

781
00:27:20,080 --> 00:27:23,760
is useful and the analysis that goes

782
00:27:22,320 --> 00:27:26,879
with it

783
00:27:23,760 --> 00:27:28,158
i'm going to finish now with just a

784
00:27:26,880 --> 00:27:29,679
passing comment

785
00:27:28,159 --> 00:27:32,000
because you can do the same looking at

786
00:27:29,679 --> 00:27:34,640
arm risk five and

787
00:27:32,000 --> 00:27:35,440
very quickly you see things like here

788
00:27:34,640 --> 00:27:38,399
the

789
00:27:35,440 --> 00:27:39,279
um um sort of augmented instructions

790
00:27:38,399 --> 00:27:43,439
where

791
00:27:39,279 --> 00:27:46,399
you've got an exclusive or um

792
00:27:43,440 --> 00:27:46,960
of r2 and ip into r0 but you're allowed

793
00:27:46,399 --> 00:27:49,360
to

794
00:27:46,960 --> 00:27:50,159
actually rotate the second operand so

795
00:27:49,360 --> 00:27:51,840
you've got these

796
00:27:50,159 --> 00:27:53,840
synthesized operators that's really

797
00:27:51,840 --> 00:27:56,879
useful for cryptographic things which

798
00:27:53,840 --> 00:27:58,320
gets heavy use in metal aes the the as

799
00:27:56,880 --> 00:28:01,440
function

800
00:27:58,320 --> 00:28:04,799
so what you do in 32 bits in arm

801
00:28:01,440 --> 00:28:06,799
you need a total of um if i've added

802
00:28:04,799 --> 00:28:10,480
that up right

803
00:28:06,799 --> 00:28:12,720
96 bits in risk five okay

804
00:28:10,480 --> 00:28:14,000
and that structure comes up quite a lot

805
00:28:12,720 --> 00:28:17,279
in that cryptographic code

806
00:28:14,000 --> 00:28:20,000
that's why arm actually comes out well

807
00:28:17,279 --> 00:28:21,520
on um the cryptographic stuff that's

808
00:28:20,000 --> 00:28:22,080
something to bear in mind when looking

809
00:28:21,520 --> 00:28:24,399
at

810
00:28:22,080 --> 00:28:25,520
instruction set extensions for risk five

811
00:28:24,399 --> 00:28:27,279
it we

812
00:28:25,520 --> 00:28:29,760
we can't do much about that in the

813
00:28:27,279 --> 00:28:30,320
compiler that's an architectural thing

814
00:28:29,760 --> 00:28:32,480
okay

815
00:28:30,320 --> 00:28:34,399
so sometimes the answer you'll get given

816
00:28:32,480 --> 00:28:37,760
is you can't fix this

817
00:28:34,399 --> 00:28:40,959
but other times you do we do

818
00:28:37,760 --> 00:28:42,080
observe other things arm makes heavy use

819
00:28:40,960 --> 00:28:44,559
of constant pools

820
00:28:42,080 --> 00:28:46,240
we saw a bit of that in gcc okay at the

821
00:28:44,559 --> 00:28:46,960
end of functions and having a global

822
00:28:46,240 --> 00:28:48,799
area of

823
00:28:46,960 --> 00:28:51,440
with short excesses for for global

824
00:28:48,799 --> 00:28:54,320
constants of our other registers

825
00:28:51,440 --> 00:28:54,960
whereas risk five tends to have many

826
00:28:54,320 --> 00:28:57,918
global

827
00:28:54,960 --> 00:28:58,399
loads and stores the other thing we see

828
00:28:57,919 --> 00:28:59,919
is

829
00:28:58,399 --> 00:29:02,399
arm famously has conditional

830
00:28:59,919 --> 00:29:03,600
instructions those turn into explicit

831
00:29:02,399 --> 00:29:06,000
loops in risk fight

832
00:29:03,600 --> 00:29:06,639
so we can do something about constant

833
00:29:06,000 --> 00:29:07,919
pools

834
00:29:06,640 --> 00:29:10,240
because we can implement that in clang

835
00:29:07,919 --> 00:29:12,080
llvm the other two are architectural

836
00:29:10,240 --> 00:29:14,559
that's over to the chip designers to

837
00:29:12,080 --> 00:29:14,559
sort out

838
00:29:15,039 --> 00:29:19,279
so i hope that was useful um i was

839
00:29:17,520 --> 00:29:20,960
exploring how you go around

840
00:29:19,279 --> 00:29:23,200
the day-to-day job of improving a

841
00:29:20,960 --> 00:29:27,039
compiler

842
00:29:23,200 --> 00:29:30,000
so standard benchmarks provide

843
00:29:27,039 --> 00:29:31,440
a useful comparison tool and comparison

844
00:29:30,000 --> 00:29:32,399
between different environments can

845
00:29:31,440 --> 00:29:34,720
identify

846
00:29:32,399 --> 00:29:35,600
optimization possibilities by comparing

847
00:29:34,720 --> 00:29:39,120
compilers

848
00:29:35,600 --> 00:29:40,480
by comparing architectures but

849
00:29:39,120 --> 00:29:42,639
some problems can't be fixed by the

850
00:29:40,480 --> 00:29:45,760
compiler and

851
00:29:42,640 --> 00:29:46,960
it works for any benchmark set i've

852
00:29:45,760 --> 00:29:48,240
chosen m bench

853
00:29:46,960 --> 00:29:49,440
because i've worked with m bench and

854
00:29:48,240 --> 00:29:51,360
it's being launched next month it's a

855
00:29:49,440 --> 00:29:53,279
good chance to talk about it

856
00:29:51,360 --> 00:29:54,719
and we use that professionally in our

857
00:29:53,279 --> 00:29:55,679
day-to-day job but there are other

858
00:29:54,720 --> 00:29:57,039
benchmark suites

859
00:29:55,679 --> 00:29:59,279
out there you can use any of the ones i

860
00:29:57,039 --> 00:30:00,559
talked earlier there are other specific

861
00:29:59,279 --> 00:30:02,080
components i particularly draw your

862
00:30:00,559 --> 00:30:03,120
attention to our colleagues from western

863
00:30:02,080 --> 00:30:06,840
digital

864
00:30:03,120 --> 00:30:08,959
and their repository of tiny code

865
00:30:06,840 --> 00:30:11,520
fragments

866
00:30:08,960 --> 00:30:13,039
that break compilers okay and you can do

867
00:30:11,520 --> 00:30:16,240
exactly the same analysis

868
00:30:13,039 --> 00:30:18,720
it's not a benchmark suite it's a

869
00:30:16,240 --> 00:30:19,440
is your compiler any good suite and

870
00:30:18,720 --> 00:30:21,760
that's a

871
00:30:19,440 --> 00:30:23,840
great set of code fragments to look at

872
00:30:21,760 --> 00:30:26,399
but exactly the same analysis applies

873
00:30:23,840 --> 00:30:29,439
it's the same technique

874
00:30:26,399 --> 00:30:30,080
so thank you very much that's my company

875
00:30:29,440 --> 00:30:32,080
address and

876
00:30:30,080 --> 00:30:34,158
mbench.org i do encourage you to get

877
00:30:32,080 --> 00:30:35,520
involved with mbench

878
00:30:34,159 --> 00:30:37,360
if it's going to succeed as a free and

879
00:30:35,520 --> 00:30:38,480
open benchmark suite it needs many many

880
00:30:37,360 --> 00:30:39,600
hands on it

881
00:30:38,480 --> 00:30:42,399
and i should take questions and i've

882
00:30:39,600 --> 00:30:42,399
already got one yes

883
00:30:45,440 --> 00:30:51,200
so the question is so the question is

884
00:30:48,159 --> 00:30:52,799
how can you get involved with mbench

885
00:30:51,200 --> 00:30:54,720
you go to the website you sign up for

886
00:30:52,799 --> 00:30:56,480
the mailing list it's a conventional

887
00:30:54,720 --> 00:30:57,279
listserv mailing list

888
00:30:56,480 --> 00:30:58,880
one of the things that will get

889
00:30:57,279 --> 00:30:59,840
announced on that mailing list is the

890
00:30:58,880 --> 00:31:02,000
date and time

891
00:30:59,840 --> 00:31:03,039
of the monthly call which is the third

892
00:31:02,000 --> 00:31:06,399
monday

893
00:31:03,039 --> 00:31:09,360
of every month on uh at um

894
00:31:06,399 --> 00:31:10,320
8 a.m california time so 5 p.m in

895
00:31:09,360 --> 00:31:13,360
belgium

896
00:31:10,320 --> 00:31:16,559
and that

897
00:31:13,360 --> 00:31:18,000
that is that that call is actually

898
00:31:16,559 --> 00:31:22,000
implemented using zoom i

899
00:31:18,000 --> 00:31:24,720
know the concerns over using zoom um

900
00:31:22,000 --> 00:31:25,200
we can't get everything right but okay

901
00:31:24,720 --> 00:31:27,600
so

902
00:31:25,200 --> 00:31:29,760
um that's how you get involved and it's

903
00:31:27,600 --> 00:31:31,840
a repository it's a github repository

904
00:31:29,760 --> 00:31:32,799
sending your issues send in your pull

905
00:31:31,840 --> 00:31:35,279
requests

906
00:31:32,799 --> 00:31:36,720
and my next three weeks will be spent

907
00:31:35,279 --> 00:31:38,320
dealing with the queue of pull requests

908
00:31:36,720 --> 00:31:41,600
and issues that have been raised

909
00:31:38,320 --> 00:31:43,760
and the more the merrier

910
00:31:41,600 --> 00:31:45,120
and it goes on it's launched next month

911
00:31:43,760 --> 00:31:46,240
but it's going to go on it's going to be

912
00:31:45,120 --> 00:31:49,360
renewed year after year

913
00:31:46,240 --> 00:31:51,760
so new benchmarks are always welcome

914
00:31:49,360 --> 00:31:53,918
are you planning to version and bench so

915
00:31:51,760 --> 00:31:55,120
for example like you've got spec 2k6 so

916
00:31:53,919 --> 00:31:56,399
even though you might be changing the

917
00:31:55,120 --> 00:31:59,199
programs people can still

918
00:31:56,399 --> 00:32:01,279
get the historical data so the question

919
00:31:59,200 --> 00:32:03,840
is are we going to version benchmark

920
00:32:01,279 --> 00:32:05,679
version and bench the answer is yes

921
00:32:03,840 --> 00:32:08,080
version 0.5 this year

922
00:32:05,679 --> 00:32:09,039
the intention is to renew it every two

923
00:32:08,080 --> 00:32:11,600
years

924
00:32:09,039 --> 00:32:13,279
i suspect the first full version of m

925
00:32:11,600 --> 00:32:15,039
bench will probably come out after only

926
00:32:13,279 --> 00:32:16,480
a year because i think that'll be enough

927
00:32:15,039 --> 00:32:18,158
and then every two years and i've

928
00:32:16,480 --> 00:32:18,960
already got the first submission of a

929
00:32:18,159 --> 00:32:20,399
program

930
00:32:18,960 --> 00:32:22,559
for the net to go into the benchmark

931
00:32:20,399 --> 00:32:26,719
suite next time round

932
00:32:22,559 --> 00:32:26,720
all right i'll take this one over here

933
00:32:27,120 --> 00:32:30,239
yeah but there are obviously differences

934
00:32:29,760 --> 00:32:31,919
between

935
00:32:30,240 --> 00:32:33,840
chips because some might have this

936
00:32:31,919 --> 00:32:34,720
especially with five some new ones might

937
00:32:33,840 --> 00:32:37,439
have speculative

938
00:32:34,720 --> 00:32:37,919
speculative execution some might not so

939
00:32:37,440 --> 00:32:39,519
uh

940
00:32:37,919 --> 00:32:40,960
so these benchmark numbers you showed

941
00:32:39,519 --> 00:32:43,840
for the performance so

942
00:32:40,960 --> 00:32:45,600
what's kind of the reference platform so

943
00:32:43,840 --> 00:32:46,480
the question is what is the reference

944
00:32:45,600 --> 00:32:49,360
platform

945
00:32:46,480 --> 00:32:50,480
used for m bench because reference

946
00:32:49,360 --> 00:32:52,080
platforms are implemented by the

947
00:32:50,480 --> 00:32:55,360
hardware implementation

948
00:32:52,080 --> 00:32:58,559
it is the ri5 cy risky

949
00:32:55,360 --> 00:33:01,279
core from the pulp project at eth zurich

950
00:32:58,559 --> 00:33:02,399
and that's an open implementation and it

951
00:33:01,279 --> 00:33:04,799
is a specific

952
00:33:02,399 --> 00:33:06,399
commit from their github repository of

953
00:33:04,799 --> 00:33:10,000
the verilog source

954
00:33:06,399 --> 00:33:10,879
thank you if you plan to separate the

955
00:33:10,000 --> 00:33:13,600
14-point

956
00:33:10,880 --> 00:33:15,840
test benchmark from this point parts

957
00:33:13,600 --> 00:33:19,199
because

958
00:33:15,840 --> 00:33:21,678
the numbers so the question is are we

959
00:33:19,200 --> 00:33:21,679
going to

960
00:33:22,159 --> 00:33:25,840
separate out point benchmarks the answer

961
00:33:25,360 --> 00:33:27,519
is

962
00:33:25,840 --> 00:33:29,519
the first benchmark suite is not called

963
00:33:27,519 --> 00:33:30,480
m bench it's called mbench iot it's

964
00:33:29,519 --> 00:33:33,919
specifically

965
00:33:30,480 --> 00:33:34,559
iot class integer we see two directions

966
00:33:33,919 --> 00:33:36,960
going

967
00:33:34,559 --> 00:33:39,120
in the immediate one is to do a floating

968
00:33:36,960 --> 00:33:40,559
point aimed at that same class of

969
00:33:39,120 --> 00:33:42,000
processor because there are

970
00:33:40,559 --> 00:33:44,559
embedded floating point and then you can

971
00:33:42,000 --> 00:33:49,039
get m4 with floating point unit you can

972
00:33:44,559 --> 00:33:51,918
have rv32 if

973
00:33:49,039 --> 00:33:52,960
so absolutely and the second is we also

974
00:33:51,919 --> 00:33:55,200
want to do

975
00:33:52,960 --> 00:33:56,240
benchmarks appropriate for application

976
00:33:55,200 --> 00:33:58,960
class processes

977
00:33:56,240 --> 00:34:00,960
that are going to run on a an x86 or an

978
00:33:58,960 --> 00:34:03,519
rma class processor arch

979
00:34:00,960 --> 00:34:05,039
64 type architecture those are projects

980
00:34:03,519 --> 00:34:06,240
for the future

981
00:34:05,039 --> 00:34:08,480
we're looking for people who want to

982
00:34:06,240 --> 00:34:10,079
join in take ownerships of those so i

983
00:34:08,480 --> 00:34:12,480
would expect in the future

984
00:34:10,079 --> 00:34:14,399
there will be a series of repositories

985
00:34:12,480 --> 00:34:17,040
for the different classes event bench

986
00:34:14,399 --> 00:34:17,040
each version

987
00:34:18,000 --> 00:34:21,839
yes john

988
00:34:24,560 --> 00:34:30,879
very good question from jerome um the uh

989
00:34:27,599 --> 00:34:33,440
are those benchmark figures for speed

990
00:34:30,879 --> 00:34:34,480
numbers or are they relative to the

991
00:34:33,440 --> 00:34:38,079
clock rate

992
00:34:34,480 --> 00:34:40,639
and the answer is we report both okay

993
00:34:38,079 --> 00:34:42,639
the absolute value you know tells you

994
00:34:40,639 --> 00:34:44,560
how fast your processor is

995
00:34:42,639 --> 00:34:46,480
the value per megahertz tells you how

996
00:34:44,560 --> 00:34:48,560
efficiently you've implemented it

997
00:34:46,480 --> 00:34:50,480
okay and we did do some figures with

998
00:34:48,560 --> 00:34:53,679
risk five comparing the

999
00:34:50,480 --> 00:34:56,879
risky core from uh uh

1000
00:34:53,679 --> 00:35:00,640
eth zurich with an early um

1001
00:34:56,879 --> 00:35:02,799
sci-fi uh core and actually

1002
00:35:00,640 --> 00:35:04,160
you found the risky core was about five

1003
00:35:02,800 --> 00:35:05,680
percent more efficiently implemented

1004
00:35:04,160 --> 00:35:08,560
when you divided by the megahertz

1005
00:35:05,680 --> 00:35:10,399
it was the same the speed data i gave

1006
00:35:08,560 --> 00:35:12,720
you were from a very later model of the

1007
00:35:10,400 --> 00:35:14,240
risky core which i happened to clock at

1008
00:35:12,720 --> 00:35:15,680
notionally one megahertz so it was

1009
00:35:14,240 --> 00:35:17,839
divided by one so the two figures are

1010
00:35:15,680 --> 00:35:17,839
the same

1011
00:35:19,040 --> 00:35:31,839
any more questions thank you very much

1012
00:35:21,839 --> 00:35:33,920
perfect timing

1013
00:35:31,839 --> 00:35:33,920
you

