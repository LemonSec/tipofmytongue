1
00:00:01,410 --> 00:00:06,030
[Music]

2
00:00:08,559 --> 00:00:11,679
um hi again my name is miguel a cayez

3
00:00:11,679 --> 00:00:14,000
i'm here to share some lessons learned

4
00:00:14,000 --> 00:00:17,920
of costly ones from serverless computing

5
00:00:17,920 --> 00:00:19,680
so first let's just start with sharing

6
00:00:19,680 --> 00:00:22,160
who we are and a little bit about our

7
00:00:22,160 --> 00:00:24,160
serverless journey

8
00:00:24,160 --> 00:00:26,720
so veritol is a startup in the tolling

9
00:00:26,720 --> 00:00:29,199
and transportation industry we believe

10
00:00:29,199 --> 00:00:31,840
in bringing innovation to the industry

11
00:00:31,840 --> 00:00:33,200
by leveraging

12
00:00:33,200 --> 00:00:35,840
mobile crowd source and cloud-based

13
00:00:35,840 --> 00:00:37,520
technologies

14
00:00:37,520 --> 00:00:40,160
in order to bring this innovation to the

15
00:00:40,160 --> 00:00:42,239
industry we also need innovative

16
00:00:42,239 --> 00:00:44,399
technologies and that's how we landed on

17
00:00:44,399 --> 00:00:45,760
serverless

18
00:00:45,760 --> 00:00:47,920
with serverless we're allowed to focus

19
00:00:47,920 --> 00:00:50,879
on application development and

20
00:00:50,879 --> 00:00:53,600
develop rapidly and deploy rapidly we

21
00:00:53,600 --> 00:00:55,280
can do it with less

22
00:00:55,280 --> 00:00:57,520
infrastructure than typically done

23
00:00:57,520 --> 00:01:00,000
with server-based approach we can also

24
00:01:00,000 --> 00:01:01,840
reduce our maintenance overhead

25
00:01:01,840 --> 00:01:03,600
throughout the software development life

26
00:01:03,600 --> 00:01:06,320
cycle and if properly designed we can

27
00:01:06,320 --> 00:01:09,679
lower our costs as well

28
00:01:10,240 --> 00:01:11,840
so some of you may be wondering what

29
00:01:11,840 --> 00:01:14,799
serverless is serverless is a technology

30
00:01:14,799 --> 00:01:16,320
that allows you

31
00:01:16,320 --> 00:01:17,439
to

32
00:01:17,439 --> 00:01:19,360
deploy applications without having to

33
00:01:19,360 --> 00:01:21,040
manage the server

34
00:01:21,040 --> 00:01:23,200
some wonder well how can you have

35
00:01:23,200 --> 00:01:25,520
technology without a server and i agree

36
00:01:25,520 --> 00:01:26,960
there's got to be a server somewhere

37
00:01:26,960 --> 00:01:29,119
within the technology stack but the

38
00:01:29,119 --> 00:01:30,159
point is

39
00:01:30,159 --> 00:01:31,680
we don't have to

40
00:01:31,680 --> 00:01:33,600
provision it we don't have to configure

41
00:01:33,600 --> 00:01:35,119
it we don't have to manage it we don't

42
00:01:35,119 --> 00:01:37,119
have to secure it

43
00:01:37,119 --> 00:01:39,119
there's underlying technology there that

44
00:01:39,119 --> 00:01:41,520
we just need to upload our

45
00:01:41,520 --> 00:01:45,119
function code or our configuration

46
00:01:45,119 --> 00:01:47,280
and we can then focus on developing the

47
00:01:47,280 --> 00:01:48,880
application putting all the pieces

48
00:01:48,880 --> 00:01:50,159
together

49
00:01:50,159 --> 00:01:53,520
so it makes development a lot quicker

50
00:01:53,520 --> 00:01:55,600
um so just give you an idea of what

51
00:01:55,600 --> 00:01:57,759
serverless looks like

52
00:01:57,759 --> 00:02:00,560
we built audito one of our platforms

53
00:02:00,560 --> 00:02:03,280
using amazon web services so we have a

54
00:02:03,280 --> 00:02:05,200
serverless website and a serverless

55
00:02:05,200 --> 00:02:06,240
backend

56
00:02:06,240 --> 00:02:08,239
so for the website we're leveraging

57
00:02:08,239 --> 00:02:09,360
three

58
00:02:09,360 --> 00:02:13,280
major services on aws or route 53 for

59
00:02:13,280 --> 00:02:16,080
domain name service dns

60
00:02:16,080 --> 00:02:17,440
s3 for

61
00:02:17,440 --> 00:02:19,920
hosting our object storage

62
00:02:19,920 --> 00:02:22,160
and cloudfront for a content delivery

63
00:02:22,160 --> 00:02:24,000
network or cdn

64
00:02:24,000 --> 00:02:25,440
so what happens when

65
00:02:25,440 --> 00:02:26,160
a

66
00:02:26,160 --> 00:02:28,400
user goes to our web application

67
00:02:28,400 --> 00:02:30,879
autotold.io

68
00:02:30,879 --> 00:02:33,840
route53 resolves that to an ip address

69
00:02:33,840 --> 00:02:35,519
that ip address

70
00:02:35,519 --> 00:02:38,000
then gets redirected to

71
00:02:38,000 --> 00:02:40,400
cloudfront to does cdn

72
00:02:40,400 --> 00:02:42,879
if the desired content is already been

73
00:02:42,879 --> 00:02:45,280
cached at the edge then it just serves

74
00:02:45,280 --> 00:02:46,959
that cache content

75
00:02:46,959 --> 00:02:49,040
really quickly back to the web app

76
00:02:49,040 --> 00:02:50,800
in the event that it's not cached it

77
00:02:50,800 --> 00:02:52,160
goes to

78
00:02:52,160 --> 00:02:54,879
s3 obtains the content and then serves

79
00:02:54,879 --> 00:02:58,400
it back to the web application

80
00:02:58,400 --> 00:03:01,599
now our website also needs a backend

81
00:03:01,599 --> 00:03:03,599
and our mobile app

82
00:03:03,599 --> 00:03:07,040
uses a back-end as well

83
00:03:07,040 --> 00:03:09,680
we do this by leveraging three other aws

84
00:03:09,680 --> 00:03:13,120
services api gateway for defining api

85
00:03:13,120 --> 00:03:18,000
endpoints using the rest restful designs

86
00:03:18,000 --> 00:03:20,480
lambda for serverless functions and

87
00:03:20,480 --> 00:03:24,239
dynamodb for serverless database tables

88
00:03:24,239 --> 00:03:26,480
so what happens when the mobile app or

89
00:03:26,480 --> 00:03:28,560
the website need to get data from the

90
00:03:28,560 --> 00:03:31,440
backend they make an api call that gets

91
00:03:31,440 --> 00:03:33,760
set to api gateway

92
00:03:33,760 --> 00:03:36,000
api gateway will then forward that

93
00:03:36,000 --> 00:03:38,640
request event to a lambda function

94
00:03:38,640 --> 00:03:41,040
the function will process the event and

95
00:03:41,040 --> 00:03:43,200
do what it needs to it may need to read

96
00:03:43,200 --> 00:03:45,519
or write to a database and send data

97
00:03:45,519 --> 00:03:47,040
back

98
00:03:47,040 --> 00:03:48,400
so once it does

99
00:03:48,400 --> 00:03:50,400
its execution it sends the data back to

100
00:03:50,400 --> 00:03:52,319
the gateway and the gateway sends it

101
00:03:52,319 --> 00:03:55,040
back to the mobile app or website

102
00:03:55,040 --> 00:03:57,519
so hopefully this gives you a feel for

103
00:03:57,519 --> 00:04:00,560
what serverless looks like and how a

104
00:04:00,560 --> 00:04:03,280
typical service serverless design

105
00:04:03,280 --> 00:04:04,760
uh

106
00:04:04,760 --> 00:04:08,560
is is implemented

107
00:04:08,560 --> 00:04:10,000
so here's the bulk of the talk i'm going

108
00:04:10,000 --> 00:04:12,560
to share some some lessons learned so

109
00:04:12,560 --> 00:04:14,080
there's going to be a structure to this

110
00:04:14,080 --> 00:04:16,560
we're going to have a category and

111
00:04:16,560 --> 00:04:19,199
describe the scenario the lesson we

112
00:04:19,199 --> 00:04:20,000
learned

113
00:04:20,000 --> 00:04:22,079
the remediation we put

114
00:04:22,079 --> 00:04:25,040
in place to address our finding

115
00:04:25,040 --> 00:04:27,040
and conclude with some risk and

116
00:04:27,040 --> 00:04:29,360
mitigations you you can

117
00:04:29,360 --> 00:04:33,280
take away to avoid similar scenarios

118
00:04:33,280 --> 00:04:36,560
the first category is inputs of oauth

119
00:04:36,560 --> 00:04:38,240
serverless top 10

120
00:04:38,240 --> 00:04:39,680
identified

121
00:04:39,680 --> 00:04:43,280
input injection as the number one uh

122
00:04:43,280 --> 00:04:45,120
top security risk

123
00:04:45,120 --> 00:04:47,120
so in this scenario what we had is we

124
00:04:47,120 --> 00:04:48,160
had

125
00:04:48,160 --> 00:04:50,560
an api endpoint that

126
00:04:50,560 --> 00:04:53,120
gets uh sends data to lambda function

127
00:04:53,120 --> 00:04:55,440
and it reads from a database

128
00:04:55,440 --> 00:04:58,639
and we found that this database changes

129
00:04:58,639 --> 00:05:00,960
very frequently so it doesn't change

130
00:05:00,960 --> 00:05:02,639
very often

131
00:05:02,639 --> 00:05:05,680
we implemented api gateway cache so that

132
00:05:05,680 --> 00:05:08,160
once the api request comes the gateway

133
00:05:08,160 --> 00:05:10,479
can serve it right back similar to what

134
00:05:10,479 --> 00:05:12,880
a cdn does that way it doesn't ever have

135
00:05:12,880 --> 00:05:13,840
to

136
00:05:13,840 --> 00:05:16,080
do a lambda function call and a database

137
00:05:16,080 --> 00:05:17,600
read in

138
00:05:17,600 --> 00:05:20,080
for most situations but there were times

139
00:05:20,080 --> 00:05:22,560
when the database did get updated and we

140
00:05:22,560 --> 00:05:25,520
don't want to serve old cache data

141
00:05:25,520 --> 00:05:27,440
so we had a different process in place

142
00:05:27,440 --> 00:05:29,440
where when the database is updated it

143
00:05:29,440 --> 00:05:32,320
would send an update event to a lambda

144
00:05:32,320 --> 00:05:33,280
function

145
00:05:33,280 --> 00:05:35,120
the lambda function will then say oh i

146
00:05:35,120 --> 00:05:36,960
got an update i'm going to click i want

147
00:05:36,960 --> 00:05:40,000
to send a request to the api gateway and

148
00:05:40,000 --> 00:05:41,680
have it clear as cache

149
00:05:41,680 --> 00:05:43,680
seems pretty straightforward right what

150
00:05:43,680 --> 00:05:46,639
we found was that there was accidental

151
00:05:46,639 --> 00:05:48,160
injection attacks that we weren't

152
00:05:48,160 --> 00:05:49,520
expecting

153
00:05:49,520 --> 00:05:52,479
for whatever reason sometimes aws would

154
00:05:52,479 --> 00:05:56,240
send the lambda function old events so

155
00:05:56,240 --> 00:05:58,160
the table had not been updated recently

156
00:05:58,160 --> 00:05:59,600
but yet it was still sending all the

157
00:05:59,600 --> 00:06:00,560
events

158
00:06:00,560 --> 00:06:03,120
uh that the london function uh that

159
00:06:03,120 --> 00:06:04,840
shouldn't have should have not

160
00:06:04,840 --> 00:06:07,199
happened so the function was saying oh i

161
00:06:07,199 --> 00:06:08,800
got an event and send the

162
00:06:08,800 --> 00:06:11,280
a a clear cash request to the gateway oh

163
00:06:11,280 --> 00:06:13,280
got another one clear cash player class

164
00:06:13,280 --> 00:06:15,680
it was happening so many times in a very

165
00:06:15,680 --> 00:06:17,280
short period of time

166
00:06:17,280 --> 00:06:19,440
and the api gateway ended up getting so

167
00:06:19,440 --> 00:06:20,960
overwhelmed i said

168
00:06:20,960 --> 00:06:23,039
i'm not making any more i'm not

169
00:06:23,039 --> 00:06:25,280
accepting any more requests and even

170
00:06:25,280 --> 00:06:28,240
from api endpoints over http using the

171
00:06:28,240 --> 00:06:29,919
restful protocol

172
00:06:29,919 --> 00:06:31,759
ended up turning into a self-induced

173
00:06:31,759 --> 00:06:33,680
denial of service attack

174
00:06:33,680 --> 00:06:34,639
yikes

175
00:06:34,639 --> 00:06:36,400
so we had some outages that we were not

176
00:06:36,400 --> 00:06:37,360
planning

177
00:06:37,360 --> 00:06:39,280
so to remediate this what we ended up

178
00:06:39,280 --> 00:06:42,400
putting in place was uh we've had the

179
00:06:42,400 --> 00:06:44,560
function do input validation according

180
00:06:44,560 --> 00:06:45,759
to

181
00:06:45,759 --> 00:06:47,840
the number one risk

182
00:06:47,840 --> 00:06:50,240
recommendation to mitigate that so the

183
00:06:50,240 --> 00:06:52,639
only process the newest events we also

184
00:06:52,639 --> 00:06:54,639
had to land the function keep track of

185
00:06:54,639 --> 00:06:56,800
when the last

186
00:06:56,800 --> 00:06:58,880
cache clearing happened and limit it to

187
00:06:58,880 --> 00:07:01,199
every five even five minutes so that you

188
00:07:01,199 --> 00:07:03,039
can only clear the cache once every five

189
00:07:03,039 --> 00:07:04,400
minutes to avoid

190
00:07:04,400 --> 00:07:07,039
overwhelming the api gateway

191
00:07:07,039 --> 00:07:08,880
so this kind of describes how you can

192
00:07:08,880 --> 00:07:10,720
avoid input injection

193
00:07:10,720 --> 00:07:14,000
attacks even accidental ones

194
00:07:14,000 --> 00:07:16,160
just as a side note we ended up

195
00:07:16,160 --> 00:07:18,800
determining that the lat the database

196
00:07:18,800 --> 00:07:21,599
only gets updated during the release

197
00:07:21,599 --> 00:07:22,880
process

198
00:07:22,880 --> 00:07:24,880
based on some configuration parameters

199
00:07:24,880 --> 00:07:27,360
and build specific changes

200
00:07:27,360 --> 00:07:29,199
so we went away from this paradigm that

201
00:07:29,199 --> 00:07:31,120
we have here in the diagram and started

202
00:07:31,120 --> 00:07:33,759
using serverless plugins and when there

203
00:07:33,759 --> 00:07:36,880
was a release in the cicd pipeline

204
00:07:36,880 --> 00:07:39,199
the the serverless plugin would make the

205
00:07:39,199 --> 00:07:42,000
api call to the gateway and say clear

206
00:07:42,000 --> 00:07:43,360
the cache

207
00:07:43,360 --> 00:07:45,520
because the database was being updated

208
00:07:45,520 --> 00:07:48,560
at that time during the release

209
00:07:48,560 --> 00:07:50,800
so we mentioned some of the risk

210
00:07:50,800 --> 00:07:52,879
so code injection it could be sql

211
00:07:52,879 --> 00:07:55,199
commands

212
00:07:55,199 --> 00:07:56,840
aws

213
00:07:56,840 --> 00:07:59,840
commands uh graphql if you're using like

214
00:07:59,840 --> 00:08:01,039
the appsync

215
00:08:01,039 --> 00:08:01,919
func

216
00:08:01,919 --> 00:08:02,960
service

217
00:08:02,960 --> 00:08:04,960
that there's a nested uh recursive

218
00:08:04,960 --> 00:08:06,720
attack this really

219
00:08:06,720 --> 00:08:08,960
awesome demo from the oauths

220
00:08:08,960 --> 00:08:12,319
uh ca uh hapsac cali 2019 that shows

221
00:08:12,319 --> 00:08:15,360
that demo how it turned into like a

222
00:08:15,360 --> 00:08:17,280
couple minute long execution and a

223
00:08:17,280 --> 00:08:19,280
thousand times it ended up being several

224
00:08:19,280 --> 00:08:20,879
thousand dollar cost

225
00:08:20,879 --> 00:08:24,080
um so regular expression attacks and

226
00:08:24,080 --> 00:08:26,400
if there's a bad input it could result

227
00:08:26,400 --> 00:08:29,280
in an unexpected 500 error if if not

228
00:08:29,280 --> 00:08:31,680
planned properly so to mitigate make

229
00:08:31,680 --> 00:08:33,919
sure you always validate your inputs do

230
00:08:33,919 --> 00:08:37,519
safety deserve it and deserialize your

231
00:08:37,519 --> 00:08:39,519
inputs like json

232
00:08:39,519 --> 00:08:41,200
and make sure you have safe regular

233
00:08:41,200 --> 00:08:44,240
expressions if in the event there is

234
00:08:44,240 --> 00:08:46,160
a code ejection attack that makes it

235
00:08:46,160 --> 00:08:48,240
through make sure you have the lowest

236
00:08:48,240 --> 00:08:50,000
identity and access management

237
00:08:50,000 --> 00:08:52,720
privileges so that it cannot execute any

238
00:08:52,720 --> 00:08:55,360
unintended functions take advantage of

239
00:08:55,360 --> 00:08:57,680
great tools that are built into ides or

240
00:08:57,680 --> 00:09:00,399
as plugins put them into the cacd

241
00:09:00,399 --> 00:09:03,200
pipeline to do linting and static code

242
00:09:03,200 --> 00:09:04,480
analysis and

243
00:09:04,480 --> 00:09:06,480
take advantage of try catch blocks you

244
00:09:06,480 --> 00:09:07,360
can

245
00:09:07,360 --> 00:09:09,120
exit gracefully when

246
00:09:09,120 --> 00:09:10,160
a

247
00:09:10,160 --> 00:09:12,080
bad input makes it through

248
00:09:12,080 --> 00:09:14,320
so the next one is on rate limiting

249
00:09:14,320 --> 00:09:16,720
well typical for most multi-factor

250
00:09:16,720 --> 00:09:19,200
two-step verification we had a we had

251
00:09:19,200 --> 00:09:22,480
implemented a mobile app for client so

252
00:09:22,480 --> 00:09:24,640
user needed to log in and send the api

253
00:09:24,640 --> 00:09:26,959
request to the gateway

254
00:09:26,959 --> 00:09:28,320
then it gets sent to the function the

255
00:09:28,320 --> 00:09:30,160
function then verifies the username and

256
00:09:30,160 --> 00:09:33,120
password against the identity provider

257
00:09:33,120 --> 00:09:34,160
awesome

258
00:09:34,160 --> 00:09:35,839
if it's successful that any provider

259
00:09:35,839 --> 00:09:38,880
sends a two-digit code via sms to the

260
00:09:38,880 --> 00:09:41,680
phone the user then

261
00:09:41,680 --> 00:09:44,160
entered the six digit code

262
00:09:44,160 --> 00:09:46,880
sent the api request function verifies

263
00:09:46,880 --> 00:09:49,519
against the identity provider

264
00:09:49,519 --> 00:09:51,680
cool all successful the user is logged

265
00:09:51,680 --> 00:09:53,920
in and gets the json web token back uh

266
00:09:53,920 --> 00:09:55,680
to have the session

267
00:09:55,680 --> 00:09:57,360
on the application

268
00:09:57,360 --> 00:09:59,760
well uh we found during penetration

269
00:09:59,760 --> 00:10:02,399
testing that uh

270
00:10:02,399 --> 00:10:04,240
the process the business object looks

271
00:10:04,240 --> 00:10:06,200
good but there was a

272
00:10:06,200 --> 00:10:09,200
unexpected flaw in the design someone

273
00:10:09,200 --> 00:10:10,880
could do a brute force attack try a

274
00:10:10,880 --> 00:10:12,720
million codes and

275
00:10:12,720 --> 00:10:14,000
bypass the

276
00:10:14,000 --> 00:10:15,839
two-step verification

277
00:10:15,839 --> 00:10:18,000
yikes

278
00:10:18,000 --> 00:10:20,480
what we did to remedy this is we did a

279
00:10:20,480 --> 00:10:22,560
rate limiting at the api gateway so only

280
00:10:22,560 --> 00:10:24,320
a certain number of requests can make it

281
00:10:24,320 --> 00:10:27,360
through in any given minute and also do

282
00:10:27,360 --> 00:10:29,839
lockouts if it fails let's say

283
00:10:29,839 --> 00:10:31,760
after three failed attempts either the

284
00:10:31,760 --> 00:10:33,839
username and password

285
00:10:33,839 --> 00:10:35,120
or the

286
00:10:35,120 --> 00:10:37,440
verification code then it would do a

287
00:10:37,440 --> 00:10:39,920
lockout and you couldn't log in for

288
00:10:39,920 --> 00:10:42,560
do another attempt for a period of time

289
00:10:42,560 --> 00:10:45,040
we also decided to do a moving target if

290
00:10:45,040 --> 00:10:47,839
in the event that the incorrect code was

291
00:10:47,839 --> 00:10:51,839
sent uh it would then send another

292
00:10:51,839 --> 00:10:54,320
six digit code so that there's always a

293
00:10:54,320 --> 00:10:56,560
moving target you couldn't just

294
00:10:56,560 --> 00:11:00,480
pick uh try to get the same code

295
00:11:00,480 --> 00:11:02,720
so

296
00:11:03,360 --> 00:11:04,800
but i'm not having

297
00:11:04,800 --> 00:11:05,760
limiting

298
00:11:05,760 --> 00:11:07,440
your application could be vulnerable to

299
00:11:07,440 --> 00:11:10,240
brute force attacks bot scraping or

300
00:11:10,240 --> 00:11:12,240
analyzing your application

301
00:11:12,240 --> 00:11:13,200
and

302
00:11:13,200 --> 00:11:15,680
various denial service attacks um and

303
00:11:15,680 --> 00:11:17,360
the costly part is you could have a cost

304
00:11:17,360 --> 00:11:19,200
spike that could

305
00:11:19,200 --> 00:11:20,560
increase your cost

306
00:11:20,560 --> 00:11:22,240
and if it's an extended period time it

307
00:11:22,240 --> 00:11:24,160
can be very costly

308
00:11:24,160 --> 00:11:26,079
so the way to help mitigate against

309
00:11:26,079 --> 00:11:28,160
these things is to have web application

310
00:11:28,160 --> 00:11:31,040
firewalls you can put a waf in front of

311
00:11:31,040 --> 00:11:33,680
your web application and also in front

312
00:11:33,680 --> 00:11:37,040
of the api to help reduce

313
00:11:37,040 --> 00:11:38,880
brute forcing bots

314
00:11:38,880 --> 00:11:42,160
and all service attacks

315
00:11:42,160 --> 00:11:44,079
also wanted to mention that you should

316
00:11:44,079 --> 00:11:47,200
be monitoring um usage

317
00:11:47,200 --> 00:11:48,800
errors

318
00:11:48,800 --> 00:11:50,880
uh and all uh just understanding what

319
00:11:50,880 --> 00:11:52,160
your application is doing and your

320
00:11:52,160 --> 00:11:54,560
billing so that you can

321
00:11:54,560 --> 00:11:56,000
know when something anomalous is

322
00:11:56,000 --> 00:11:57,760
happening you can uh

323
00:11:57,760 --> 00:12:00,560
address it right away and avoid an uh a

324
00:12:00,560 --> 00:12:04,319
surprise bill later on

325
00:12:04,720 --> 00:12:07,920
all right so over provisioning um just

326
00:12:07,920 --> 00:12:10,160
for simplicity and just to keep the

327
00:12:10,160 --> 00:12:12,000
configuration on our assembler

328
00:12:12,000 --> 00:12:14,720
serverless framework file looking clean

329
00:12:14,720 --> 00:12:16,639
we had defaulted to

330
00:12:16,639 --> 00:12:19,120
default

331
00:12:19,760 --> 00:12:23,120
compute size default timeouts and set a

332
00:12:23,120 --> 00:12:24,959
standard read write provision for the

333
00:12:24,959 --> 00:12:26,079
database

334
00:12:26,079 --> 00:12:26,880
well

335
00:12:26,880 --> 00:12:28,639
what we found was if

336
00:12:28,639 --> 00:12:32,639
sometimes bugs sneak into releases

337
00:12:32,639 --> 00:12:33,440
and

338
00:12:33,440 --> 00:12:35,440
when and when they go live all of a

339
00:12:35,440 --> 00:12:37,440
sudden you have all these errors popping

340
00:12:37,440 --> 00:12:39,360
up and it could be

341
00:12:39,360 --> 00:12:40,639
many

342
00:12:40,639 --> 00:12:43,600
error errors being

343
00:12:43,600 --> 00:12:44,880
realized

344
00:12:44,880 --> 00:12:47,040
and if you have the maximum compute and

345
00:12:47,040 --> 00:12:49,040
the maximum timeout well you're going to

346
00:12:49,040 --> 00:12:52,320
be paying for all that execution time

347
00:12:52,320 --> 00:12:54,160
and it gets more expensive the longer

348
00:12:54,160 --> 00:12:56,720
and the bigger the compute size is

349
00:12:56,720 --> 00:12:59,040
and same thing with provision read write

350
00:12:59,040 --> 00:13:01,040
capacity if you

351
00:13:01,040 --> 00:13:03,760
just for simplicity make it a big

352
00:13:03,760 --> 00:13:05,839
amount of provision that well you have

353
00:13:05,839 --> 00:13:07,600
to you're going to be paying for that

354
00:13:07,600 --> 00:13:09,440
while it's happening so that can get

355
00:13:09,440 --> 00:13:11,360
really costly as well

356
00:13:11,360 --> 00:13:14,399
so to remedy these situations we

357
00:13:14,399 --> 00:13:17,279
understood how each function

358
00:13:17,279 --> 00:13:18,560
executes

359
00:13:18,560 --> 00:13:21,200
and try to optimize it so sometimes

360
00:13:21,200 --> 00:13:24,480
having low memory or low cpu

361
00:13:24,480 --> 00:13:27,279
is fine if the function does very simple

362
00:13:27,279 --> 00:13:29,600
things but sometimes it's better to pay

363
00:13:29,600 --> 00:13:31,920
for more compute and memory

364
00:13:31,920 --> 00:13:33,839
uh

365
00:13:33,839 --> 00:13:36,639
uh if the function is intensive

366
00:13:36,639 --> 00:13:38,800
yeah so if yeah maybe more costly at the

367
00:13:38,800 --> 00:13:40,800
compute side the execution time is

368
00:13:40,800 --> 00:13:43,199
smaller and so it kind of offsets and

369
00:13:43,199 --> 00:13:45,920
ends up being more cost efficient

370
00:13:45,920 --> 00:13:48,480
then also understanding how long a

371
00:13:48,480 --> 00:13:50,480
function typically executes

372
00:13:50,480 --> 00:13:52,720
and then understanding

373
00:13:52,720 --> 00:13:54,240
uh how long

374
00:13:54,240 --> 00:13:55,760
what's the maximum amount of time it

375
00:13:55,760 --> 00:13:58,320
should need before it

376
00:13:58,320 --> 00:14:00,959
it times out sometimes you can do it

377
00:14:00,959 --> 00:14:03,040
during unit testing or integration

378
00:14:03,040 --> 00:14:04,399
testing that

379
00:14:04,399 --> 00:14:06,399
in certain

380
00:14:06,399 --> 00:14:09,279
bogus or erroneous inputs to see how the

381
00:14:09,279 --> 00:14:11,440
functions execute

382
00:14:11,440 --> 00:14:14,079
with an error so then that way you can

383
00:14:14,079 --> 00:14:15,519
if a function

384
00:14:15,519 --> 00:14:17,440
typically takes two seconds maybe you

385
00:14:17,440 --> 00:14:19,199
could cap it off four

386
00:14:19,199 --> 00:14:22,000
seconds uh so that's usually the longest

387
00:14:22,000 --> 00:14:25,600
it would need to execute for an error

388
00:14:25,600 --> 00:14:27,199
for a database

389
00:14:27,199 --> 00:14:29,360
we decided to move to on-demand we had

390
00:14:29,360 --> 00:14:31,839
very spike key traffic so there was no

391
00:14:31,839 --> 00:14:35,199
need to have constant provision

392
00:14:35,199 --> 00:14:36,880
resources

393
00:14:36,880 --> 00:14:38,320
read write

394
00:14:38,320 --> 00:14:40,320
so

395
00:14:40,320 --> 00:14:42,079
the having

396
00:14:42,079 --> 00:14:44,800
to pay more per write and read requests

397
00:14:44,800 --> 00:14:47,839
ended up being more cost efficient

398
00:14:47,839 --> 00:14:48,959
and

399
00:14:48,959 --> 00:14:51,680
then having a dedicated amount um

400
00:14:51,680 --> 00:14:53,600
something to keep in mind though with if

401
00:14:53,600 --> 00:14:54,720
there is

402
00:14:54,720 --> 00:14:56,639
if you're not doing rate limiting on

403
00:14:56,639 --> 00:14:58,240
your functions that read and write

404
00:14:58,240 --> 00:15:00,560
against database

405
00:15:00,560 --> 00:15:03,440
a cost spike or an attack could be

406
00:15:03,440 --> 00:15:06,560
expensive so something just uh tying it

407
00:15:06,560 --> 00:15:08,160
back to rate limiting

408
00:15:08,160 --> 00:15:10,880
that's a mitigation for on-demand

409
00:15:10,880 --> 00:15:15,600
database region write capacity units

410
00:15:16,000 --> 00:15:18,639
so we talked about the risk

411
00:15:18,639 --> 00:15:21,360
for just the mitigations understand how

412
00:15:21,360 --> 00:15:23,760
your application functions and size it

413
00:15:23,760 --> 00:15:26,760
appropriately

414
00:15:26,959 --> 00:15:29,199
so for over privileged policies again

415
00:15:29,199 --> 00:15:31,440
this is a a risk in the serverless top

416
00:15:31,440 --> 00:15:33,600
10.

417
00:15:33,600 --> 00:15:34,800
so what we've

418
00:15:34,800 --> 00:15:37,279
what we what we're doing again

419
00:15:37,279 --> 00:15:39,600
you know just developer simplicity all

420
00:15:39,600 --> 00:15:40,399
the

421
00:15:40,399 --> 00:15:41,680
required

422
00:15:41,680 --> 00:15:43,920
im privileges uh

423
00:15:43,920 --> 00:15:45,440
for every function were put in the

424
00:15:45,440 --> 00:15:47,920
default role and so what that resulted

425
00:15:47,920 --> 00:15:49,920
is functions were now being

426
00:15:49,920 --> 00:15:52,079
given overly permissive policies they

427
00:15:52,079 --> 00:15:53,600
were allowed to do things that we're not

428
00:15:53,600 --> 00:15:55,759
supposed to do so for example this one

429
00:15:55,759 --> 00:15:57,920
function is meant to just read a

430
00:15:57,920 --> 00:15:59,839
database

431
00:15:59,839 --> 00:16:02,639
but we found that it could do something

432
00:16:02,639 --> 00:16:03,839
like

433
00:16:03,839 --> 00:16:06,639
modify the im's password policy so you

434
00:16:06,639 --> 00:16:08,720
see on the left side of the function

435
00:16:08,720 --> 00:16:11,120
there's a overly permissive

436
00:16:11,120 --> 00:16:13,279
policy there i made it admin just to get

437
00:16:13,279 --> 00:16:14,639
the point across

438
00:16:14,639 --> 00:16:16,160
that

439
00:16:16,160 --> 00:16:17,839
if you have

440
00:16:17,839 --> 00:16:21,360
overly permissive or admin privileges

441
00:16:21,360 --> 00:16:22,959
some bad things can happen so what we

442
00:16:22,959 --> 00:16:25,199
did is we crafted some malicious intent

443
00:16:25,199 --> 00:16:27,600
a remote execution attack we were able

444
00:16:27,600 --> 00:16:29,199
to successfully

445
00:16:29,199 --> 00:16:31,839
modify the im password policies that's

446
00:16:31,839 --> 00:16:33,519
that's not good

447
00:16:33,519 --> 00:16:36,160
um so what we decided to do was to stop

448
00:16:36,160 --> 00:16:39,120
using the default role and do one i am

449
00:16:39,120 --> 00:16:41,600
role per function so that the policy was

450
00:16:41,600 --> 00:16:43,519
limited to what it was done so you see

451
00:16:43,519 --> 00:16:44,480
the

452
00:16:44,480 --> 00:16:47,600
the the the change on the left hand side

453
00:16:47,600 --> 00:16:50,160
in the json that it it's this function

454
00:16:50,160 --> 00:16:52,320
is only allowed to query and it's only

455
00:16:52,320 --> 00:16:56,079
allowed to query a specific table

456
00:16:56,079 --> 00:16:59,040
so that way when we tried the malicious

457
00:16:59,040 --> 00:17:01,360
remote execution attack again we were

458
00:17:01,360 --> 00:17:04,480
not able to modify the i am

459
00:17:04,480 --> 00:17:06,640
the i am password policy

460
00:17:06,640 --> 00:17:10,079
uh so the risk of having over over

461
00:17:10,079 --> 00:17:12,240
permissive over privileged policies and

462
00:17:12,240 --> 00:17:15,760
roles is that a malicious actor can

463
00:17:15,760 --> 00:17:18,319
do execution attacks get do lateral

464
00:17:18,319 --> 00:17:19,439
movements

465
00:17:19,439 --> 00:17:22,400
through out your aws infrastructure

466
00:17:22,400 --> 00:17:25,199
could need to account take over

467
00:17:25,199 --> 00:17:27,679
take account takeovers and data leakage

468
00:17:27,679 --> 00:17:29,440
i believe the

469
00:17:29,440 --> 00:17:31,200
capital one breach from a couple years

470
00:17:31,200 --> 00:17:33,039
ago was a result of

471
00:17:33,039 --> 00:17:35,039
over permissive

472
00:17:35,039 --> 00:17:36,880
i am policies

473
00:17:36,880 --> 00:17:38,160
so we mentioned

474
00:17:38,160 --> 00:17:40,320
some uh i mentioned the

475
00:17:40,320 --> 00:17:42,240
remediations those are mitigations you

476
00:17:42,240 --> 00:17:43,760
can put in place

477
00:17:43,760 --> 00:17:46,400
i highly encourage leveraging

478
00:17:46,400 --> 00:17:48,720
temporary credentials of aws has a

479
00:17:48,720 --> 00:17:51,280
service called security token service

480
00:17:51,280 --> 00:17:53,120
where it could issue

481
00:17:53,120 --> 00:17:56,080
a limited lifetime credentials rather

482
00:17:56,080 --> 00:17:58,720
than having an an access key that lives

483
00:17:58,720 --> 00:18:02,240
on forever until revoked

484
00:18:02,240 --> 00:18:04,799
and it's set let's say to

485
00:18:04,799 --> 00:18:08,480
uh has wild cards all over its palace uh

486
00:18:08,480 --> 00:18:09,840
policy

487
00:18:09,840 --> 00:18:12,000
you can just do

488
00:18:12,000 --> 00:18:14,320
if you can least privileged uh but even

489
00:18:14,320 --> 00:18:16,640
if it's admin or very permissive

490
00:18:16,640 --> 00:18:18,559
it's short-lived like 15 minutes now

491
00:18:18,559 --> 00:18:21,039
that way and your ci cd pipeline and

492
00:18:21,039 --> 00:18:23,200
even on your own developer machine you

493
00:18:23,200 --> 00:18:25,039
can keep the policy

494
00:18:25,039 --> 00:18:27,360
short-lived uh active short and

495
00:18:27,360 --> 00:18:28,720
short-lived

496
00:18:28,720 --> 00:18:30,559
another thing we found that was really

497
00:18:30,559 --> 00:18:33,039
costly was failure

498
00:18:33,039 --> 00:18:35,840
not keeping track of aws

499
00:18:35,840 --> 00:18:37,760
service outages and failures in our

500
00:18:37,760 --> 00:18:40,240
application

501
00:18:40,240 --> 00:18:42,640
as great as these cloud providers can be

502
00:18:42,640 --> 00:18:46,000
they they do experience outages um

503
00:18:46,000 --> 00:18:46,720
and

504
00:18:46,720 --> 00:18:49,039
so if we're not aware that there's an

505
00:18:49,039 --> 00:18:51,200
outage and we're not keeping track of

506
00:18:51,200 --> 00:18:53,440
let's say 500 errors as a result of an

507
00:18:53,440 --> 00:18:56,799
outage or 500 errors as a result of a

508
00:18:56,799 --> 00:18:58,240
bot attack

509
00:18:58,240 --> 00:19:01,200
it can have cost implications it could

510
00:19:01,200 --> 00:19:03,919
affect uh result in data loss

511
00:19:03,919 --> 00:19:05,200
in one of our

512
00:19:05,200 --> 00:19:07,600
client applications we found that it was

513
00:19:07,600 --> 00:19:11,440
an aws outage in for over an hour and we

514
00:19:11,440 --> 00:19:14,240
were losing pricing data so we couldn't

515
00:19:14,240 --> 00:19:16,320
our bill our customers accurately and

516
00:19:16,320 --> 00:19:17,760
that's bad

517
00:19:17,760 --> 00:19:19,200
that's not good

518
00:19:19,200 --> 00:19:21,200
so we started monitoring

519
00:19:21,200 --> 00:19:24,799
when when aws went down do some internal

520
00:19:24,799 --> 00:19:26,400
monitoring as well to see if we see if

521
00:19:26,400 --> 00:19:29,679
we can detect it before aws reports it

522
00:19:29,679 --> 00:19:30,799
officially

523
00:19:30,799 --> 00:19:33,200
uh keeping track of one 500 errors and

524
00:19:33,200 --> 00:19:34,960
we started exploring

525
00:19:34,960 --> 00:19:37,760
multi-region design so if let's say

526
00:19:37,760 --> 00:19:41,120
north virginia was down in aws and and

527
00:19:41,120 --> 00:19:43,360
ohio was functioning our application can

528
00:19:43,360 --> 00:19:46,080
still keep running

529
00:19:46,799 --> 00:19:50,840
that comes in handy when uh let's

530
00:19:50,840 --> 00:19:53,840
if uh so related to multi-region you can

531
00:19:53,840 --> 00:19:57,440
do multi-cloud designs as well um

532
00:19:57,440 --> 00:20:01,440
summer of 2020 azure had an outage in

533
00:20:01,440 --> 00:20:03,600
every region i think for

534
00:20:03,600 --> 00:20:05,200
you know an hour or two

535
00:20:05,200 --> 00:20:06,799
and so if you if your application was

536
00:20:06,799 --> 00:20:09,200
solely hosted on azure your application

537
00:20:09,200 --> 00:20:11,280
would be down completely but let's say

538
00:20:11,280 --> 00:20:13,760
if you had uh design it so that it can

539
00:20:13,760 --> 00:20:18,960
run on google cloud and also on aws

540
00:20:18,960 --> 00:20:19,679
your then

541
00:20:19,679 --> 00:20:21,520
can still be running maybe in a degraded

542
00:20:21,520 --> 00:20:23,440
state but it'd still be up

543
00:20:23,440 --> 00:20:25,919
uh so some of the risks we mentioned uh

544
00:20:25,919 --> 00:20:28,559
we experienced data loss uh an attacker

545
00:20:28,559 --> 00:20:29,840
can use

546
00:20:29,840 --> 00:20:32,240
uh 500 messages

547
00:20:32,240 --> 00:20:33,600
for reconnaissance so if we're not

548
00:20:33,600 --> 00:20:35,919
tracking that there are spikes in 500

549
00:20:35,919 --> 00:20:38,640
messages we may we not may not realize

550
00:20:38,640 --> 00:20:42,080
that our applications being investigated

551
00:20:42,080 --> 00:20:43,520
um

552
00:20:43,520 --> 00:20:45,600
but i just recommend using monitoring

553
00:20:45,600 --> 00:20:47,440
and learning to be aware of that this is

554
00:20:47,440 --> 00:20:50,159
happening and for your clients

555
00:20:50,159 --> 00:20:52,320
leverage local storage a web

556
00:20:52,320 --> 00:20:54,960
the web browsers and mobile apps have

557
00:20:54,960 --> 00:20:57,600
local storage and session storage and

558
00:20:57,600 --> 00:21:00,159
secure storage you can put your data

559
00:21:00,159 --> 00:21:02,799
there first and then make the api call

560
00:21:02,799 --> 00:21:05,520
and if the api call fails it'll still be

561
00:21:05,520 --> 00:21:07,039
stored locally

562
00:21:07,039 --> 00:21:09,120
so that the next time the server is back

563
00:21:09,120 --> 00:21:13,280
up you can try again to write the data

564
00:21:13,280 --> 00:21:14,960
lastly i want to conclude with cost

565
00:21:14,960 --> 00:21:17,679
engineering so it's just

566
00:21:17,679 --> 00:21:20,480
cost engineering is the exercise of

567
00:21:20,480 --> 00:21:22,720
understanding your costs understanding

568
00:21:22,720 --> 00:21:24,480
how your application works and how you

569
00:21:24,480 --> 00:21:27,120
can keep your application functioning as

570
00:21:27,120 --> 00:21:28,960
efficiently as possible with the lowest

571
00:21:28,960 --> 00:21:30,400
amount of cost

572
00:21:30,400 --> 00:21:32,320
so it's related to

573
00:21:32,320 --> 00:21:33,840
many of the things we've

574
00:21:33,840 --> 00:21:34,799
already

575
00:21:34,799 --> 00:21:36,559
presented earlier

576
00:21:36,559 --> 00:21:38,799
so in this example we launched a

577
00:21:38,799 --> 00:21:39,840
serverless

578
00:21:39,840 --> 00:21:42,000
application

579
00:21:42,000 --> 00:21:44,559
and when and it went operational and as

580
00:21:44,559 --> 00:21:45,760
we started

581
00:21:45,760 --> 00:21:47,840
adding more customers we

582
00:21:47,840 --> 00:21:50,240
we started seeing slight cost increase

583
00:21:50,240 --> 00:21:51,200
and then it

584
00:21:51,200 --> 00:21:53,039
noticed the cost was increasing

585
00:21:53,039 --> 00:21:55,360
significantly by june

586
00:21:55,360 --> 00:21:57,840
of that year and

587
00:21:57,840 --> 00:22:00,240
by about time we

588
00:22:00,240 --> 00:22:01,840
started look thinking about doing

589
00:22:01,840 --> 00:22:04,000
something about it it was july

590
00:22:04,000 --> 00:22:05,120
so it

591
00:22:05,120 --> 00:22:07,280
our peak this is relative cost so the

592
00:22:07,280 --> 00:22:10,159
the peak is in in june and that's the

593
00:22:10,159 --> 00:22:13,600
highest cost so we decided to understand

594
00:22:13,600 --> 00:22:15,840
what our application how our application

595
00:22:15,840 --> 00:22:18,080
was designed and how we can keep our

596
00:22:18,080 --> 00:22:19,600
costs low

597
00:22:19,600 --> 00:22:22,320
so we started doing a cost engineering

598
00:22:22,320 --> 00:22:26,080
exercise in july and by august it's that

599
00:22:26,080 --> 00:22:27,840
we started seeing lower costs and we

600
00:22:27,840 --> 00:22:30,720
kept contin continuing to do that over

601
00:22:30,720 --> 00:22:31,919
over uh

602
00:22:31,919 --> 00:22:33,440
two to three months

603
00:22:33,440 --> 00:22:34,720
and and by

604
00:22:34,720 --> 00:22:35,919
uh

605
00:22:35,919 --> 00:22:37,919
by october we were

606
00:22:37,919 --> 00:22:42,880
at 98 of the cost from the peak in june

607
00:22:42,880 --> 00:22:46,240
so we found this to be very powerful

608
00:22:46,240 --> 00:22:47,280
that

609
00:22:47,280 --> 00:22:49,120
we didn't have to change very much in

610
00:22:49,120 --> 00:22:51,440
our application

611
00:22:51,440 --> 00:22:53,440
just with some optimization

612
00:22:53,440 --> 00:22:55,840
we can still have the same

613
00:22:55,840 --> 00:22:58,880
level uh same design and same

614
00:22:58,880 --> 00:23:01,840
level of quality for application but at

615
00:23:01,840 --> 00:23:04,720
98 of our cost and that's huge that's

616
00:23:04,720 --> 00:23:06,720
that that can be a game changer

617
00:23:06,720 --> 00:23:08,240
especially if you're trying to run lean

618
00:23:08,240 --> 00:23:10,559
and mean

619
00:23:10,960 --> 00:23:13,280
so just uh just as mentioned there's it

620
00:23:13,280 --> 00:23:15,760
can be expensive and cost

621
00:23:15,760 --> 00:23:16,640
by

622
00:23:16,640 --> 00:23:18,960
not doing cost engineering you may be

623
00:23:18,960 --> 00:23:21,360
paying for more than what you need to

624
00:23:21,360 --> 00:23:23,679
so some things you can do to help with

625
00:23:23,679 --> 00:23:26,000
cost engineering is to do price analysis

626
00:23:26,000 --> 00:23:27,600
now there may be

627
00:23:27,600 --> 00:23:29,280
some services that

628
00:23:29,280 --> 00:23:31,200
similar enough

629
00:23:31,200 --> 00:23:33,520
either within the same cloud provider

630
00:23:33,520 --> 00:23:37,919
across different cloud providers and one

631
00:23:37,919 --> 00:23:40,159
one may be cheaper and still provide the

632
00:23:40,159 --> 00:23:42,480
same

633
00:23:43,120 --> 00:23:44,480
benefits and may still meet your

634
00:23:44,480 --> 00:23:45,840
requirements

635
00:23:45,840 --> 00:23:47,440
so you can just choose the less

636
00:23:47,440 --> 00:23:49,840
expensive one

637
00:23:49,840 --> 00:23:51,520
recommend doing stress tests on your

638
00:23:51,520 --> 00:23:53,360
system before

639
00:23:53,360 --> 00:23:54,400
making it

640
00:23:54,400 --> 00:23:56,559
live putting it into production that way

641
00:23:56,559 --> 00:23:58,080
you can see how your system reacts when

642
00:23:58,080 --> 00:23:59,919
it's under a load and you can catch

643
00:23:59,919 --> 00:24:02,240
potential cost spikes in advance and

644
00:24:02,240 --> 00:24:04,880
actually potentially mitigate them

645
00:24:04,880 --> 00:24:06,880
ahead ahead of time before they even

646
00:24:06,880 --> 00:24:08,480
happen

647
00:24:08,480 --> 00:24:10,720
and as mentioned before just

648
00:24:10,720 --> 00:24:12,559
monitor your application monitor costs

649
00:24:12,559 --> 00:24:13,919
make sure you understand how it's

650
00:24:13,919 --> 00:24:18,279
operating so you can catch anomalies

651
00:24:18,559 --> 00:24:21,440
so in the spirit of 20th anniversary we

652
00:24:21,440 --> 00:24:22,559
want to think

653
00:24:22,559 --> 00:24:24,080
what is veritol trying to achieve for

654
00:24:24,080 --> 00:24:25,600
the next 20 years in the tolling

655
00:24:25,600 --> 00:24:28,159
industry and how to how do we

656
00:24:28,159 --> 00:24:29,679
do that securely

657
00:24:29,679 --> 00:24:32,159
so our goal is to reduce the total cost

658
00:24:32,159 --> 00:24:34,880
to collect for a toll operator so that

659
00:24:34,880 --> 00:24:37,360
they have to only spend a few cents to

660
00:24:37,360 --> 00:24:38,240
collect

661
00:24:38,240 --> 00:24:39,600
their tolls

662
00:24:39,600 --> 00:24:41,279
costs from customers

663
00:24:41,279 --> 00:24:42,960
and so we believe we can do that through

664
00:24:42,960 --> 00:24:45,120
cloud computing especially especially

665
00:24:45,120 --> 00:24:48,080
serverless technologies

666
00:24:48,080 --> 00:24:50,240
serverless allows us to scale up

667
00:24:50,240 --> 00:24:52,480
very quickly and as you saw from cost

668
00:24:52,480 --> 00:24:55,039
engineer we can aim to keep costs

669
00:24:55,039 --> 00:24:57,760
much lower which we can then pass on to

670
00:24:57,760 --> 00:25:00,799
our customers and allow the tolling

671
00:25:00,799 --> 00:25:03,200
agencies the tolling operators to pass

672
00:25:03,200 --> 00:25:05,360
on their cost savings onto their

673
00:25:05,360 --> 00:25:08,240
customers as well maybe in the form of

674
00:25:08,240 --> 00:25:10,559
lower toll payments

675
00:25:10,559 --> 00:25:13,440
we also want to

676
00:25:13,520 --> 00:25:16,720
provide a way a secure way a private uh

677
00:25:16,720 --> 00:25:17,760
uh

678
00:25:17,760 --> 00:25:20,320
to uh people to work off their tools uh

679
00:25:20,320 --> 00:25:21,279
so that

680
00:25:21,279 --> 00:25:23,360
they can use mobile apps and cloud-based

681
00:25:23,360 --> 00:25:25,279
services to

682
00:25:25,279 --> 00:25:28,320
to to earn income to help offset their

683
00:25:28,320 --> 00:25:29,600
total cost

684
00:25:29,600 --> 00:25:31,679
giving them opportunities

685
00:25:31,679 --> 00:25:34,320
maybe for a better job that's further

686
00:25:34,320 --> 00:25:36,559
away from where they live

687
00:25:36,559 --> 00:25:37,840
so as you may

688
00:25:37,840 --> 00:25:40,000
wonder there's going to be a lot of

689
00:25:40,000 --> 00:25:42,799
transactions a lot of processing in the

690
00:25:42,799 --> 00:25:45,440
cloud it's going to be sensitive data

691
00:25:45,440 --> 00:25:48,400
like license plates names addresses

692
00:25:48,400 --> 00:25:51,360
billing information gps data

693
00:25:51,360 --> 00:25:53,760
and so we believe we can do that at

694
00:25:53,760 --> 00:25:55,600
scale with serverless and also do it

695
00:25:55,600 --> 00:25:58,240
securely by leveraging

696
00:25:58,240 --> 00:26:00,000
proper cloud

697
00:26:00,000 --> 00:26:03,120
security principles

698
00:26:04,159 --> 00:26:05,919
so there are many resources out there

699
00:26:05,919 --> 00:26:07,279
for those of you interested in

700
00:26:07,279 --> 00:26:09,120
serverless and serverless security and

701
00:26:09,120 --> 00:26:11,520
how obasp has the top 10. the cloud

702
00:26:11,520 --> 00:26:13,840
security alliance has their their 12 top

703
00:26:13,840 --> 00:26:14,960
12.

704
00:26:14,960 --> 00:26:17,520
there's many good blog posts

705
00:26:17,520 --> 00:26:19,679
on serverless best practices serverless

706
00:26:19,679 --> 00:26:22,240
security there are books on

707
00:26:22,240 --> 00:26:25,279
serverless from a press and o'reilly and

708
00:26:25,279 --> 00:26:27,440
there's the cloud provider documentation

709
00:26:27,440 --> 00:26:29,039
i find it really helpful i read through

710
00:26:29,039 --> 00:26:31,840
that a lot because they in many of their

711
00:26:31,840 --> 00:26:34,559
configuration guides have sections for

712
00:26:34,559 --> 00:26:36,799
how do you configure it how do you do a

713
00:26:36,799 --> 00:26:39,039
proper architecture and even some

714
00:26:39,039 --> 00:26:41,360
security things you keep in mind and

715
00:26:41,360 --> 00:26:43,600
there's github repositories also that

716
00:26:43,600 --> 00:26:46,320
have compilations of serverless content

717
00:26:46,320 --> 00:26:50,240
as well i noted one of them here

718
00:26:50,240 --> 00:26:52,640
so i'd love to hear from you i'll be on

719
00:26:52,640 --> 00:26:54,240
the slack channel to answer any

720
00:26:54,240 --> 00:26:55,679
questions

721
00:26:55,679 --> 00:26:57,279
but do

722
00:26:57,279 --> 00:27:00,960
contact me via email and linkedin

723
00:27:00,960 --> 00:27:02,080
and

724
00:27:02,080 --> 00:27:03,279
uh

725
00:27:03,279 --> 00:27:06,240
i am a published author and i do write a

726
00:27:06,240 --> 00:27:08,799
write i post content on my blog so

727
00:27:08,799 --> 00:27:10,240
check out my site

728
00:27:10,240 --> 00:27:11,760
thank you so much i hope you found this

729
00:27:11,760 --> 00:27:13,760
presentation helpful

730
00:27:13,760 --> 00:27:15,600
and i just want to share that a press

731
00:27:15,600 --> 00:27:17,520
has agreed to do a book giveaway for

732
00:27:17,520 --> 00:27:19,200
serverless security so if you're

733
00:27:19,200 --> 00:27:21,679
interested go to my website go to the

734
00:27:21,679 --> 00:27:23,840
owasp20

735
00:27:23,840 --> 00:27:25,600
address and

736
00:27:25,600 --> 00:27:28,159
enter your email for a chance to win

737
00:27:28,159 --> 00:27:31,279
thanks again

