1
00:00:18,420 --> 00:00:24,840
it's so easy to go to a security
conference will be involved in security

2
00:00:24,840 --> 00:00:30,410
and it's all bad news and difficulty in
communication challenges and cultural

3
00:00:30,410 --> 00:00:36,000
challenges and development challenges in
financial challenges in fear in news and

4
00:00:36,000 --> 00:00:41,129
politics it's like it a lot of bad news
a lot of bad news I want to read that

5
00:00:41,129 --> 00:00:45,420
twice sprinkle good news my name is
Jimmy Cowan primarily secure coding

6
00:00:45,420 --> 00:00:49,280
instructor teaching people how to write
SecureCode some trying to point out the

7
00:00:49,280 --> 00:00:54,360
good things that I see in frameworks and
languages that really make me believe

8
00:00:54,360 --> 00:00:59,479
that there's hope for this industry
leaders hope for secure software as we

9
00:00:59,479 --> 00:01:04,420
continue on the path of software
development our industry but we put

10
00:01:04,420 --> 00:01:08,610
people on the moon we've done as a as a
race of beings we've been so many

11
00:01:08,610 --> 00:01:13,380
amazing engineering challenges
successfully I just see secure coding at

12
00:01:13,380 --> 00:01:18,429
another intellectual challenge
engineering challenge that can be solved

13
00:01:18,430 --> 00:01:22,010
through proper discipline and
engineering techniques when I look

14
00:01:22,010 --> 00:01:26,409
around at all the frameworks that we
used to build software I see so many

15
00:01:26,409 --> 00:01:31,430
little things done incredibly right but
in the future of we start putting all

16
00:01:31,430 --> 00:01:35,229
these things together we're gonna be
able to provide a secure coding

17
00:01:35,229 --> 00:01:39,420
framework urge to solve a development
framework to developers that have huge

18
00:01:39,420 --> 00:01:42,840
classes of problems that we struggle
with today

19
00:01:42,840 --> 00:01:48,090
fixed automatically for the developer so
let's start with the quick and dirty

20
00:01:48,090 --> 00:01:54,719
framework control maturity model when we
look at spring or structure Ruby on

21
00:01:54,719 --> 00:01:59,509
Rails or go or no to whatever your
framework is of choice we want to look

22
00:01:59,509 --> 00:02:04,780
at the needed controls to build secure
software and measure how good the

23
00:02:04,780 --> 00:02:09,490
framework is doing at putting that
control into the framework so lets this

24
00:02:09,490 --> 00:02:16,050
is my quick and dirty maturity model we
analyze and control and look at it

25
00:02:16,050 --> 00:02:19,810
within a framework rates of the first
ones gonna be of course we don't defend

26
00:02:19,810 --> 00:02:24,020
against it in any way in our framework
right that's just straight up no no

27
00:02:24,020 --> 00:02:30,080
don't do that there is a lot of ways to
integrate controls into a framework if

28
00:02:30,080 --> 00:02:31,460
you're not even considering it

29
00:02:31,460 --> 00:02:36,530
you're you're way off the match at least
for that particular way off the mark for

30
00:02:36,530 --> 00:02:39,530
that particular control and I think if
specially if you're building a new

31
00:02:39,530 --> 00:02:44,090
framework today whether it's a generic
one in open source whether it's a custom

32
00:02:44,090 --> 00:02:48,810
on for your company and your you have
this Greenfield chance to build a new

33
00:02:48,810 --> 00:02:54,910
software framework and you're not adding
court controls in that's a huge lost

34
00:02:54,910 --> 00:02:59,859
opportunity and I daresay critical
mistake about number two we have the

35
00:02:59,860 --> 00:03:05,320
security control API available like if
you're forced developer for Salesforce

36
00:03:05,320 --> 00:03:09,470
the output encoding libraries all the
stuff available to you so it's it's it's

37
00:03:09,470 --> 00:03:10,410
available

38
00:03:10,410 --> 00:03:16,380
challenging to use is not documented
origin incredibly complex that's also a

39
00:03:16,380 --> 00:03:21,400
big no right to me did we want something
that's that's not gonna require a lot of

40
00:03:21,400 --> 00:03:25,540
additional labor from the developer how
about this what about a simple to use

41
00:03:25,540 --> 00:03:31,209
API that straightforward with really
good documentation I still think no

42
00:03:31,210 --> 00:03:37,150
because it developer has to take action
and change configuration and these

43
00:03:37,150 --> 00:03:41,740
benefits still requires developers
interaction what we have about an

44
00:03:41,740 --> 00:03:46,310
automatic defense it's there it's just
you turn it on it it's there but it's

45
00:03:46,310 --> 00:03:50,580
off by default you have to go in and
enable configuration to turn that

46
00:03:50,580 --> 00:03:56,880
control on that's also complete know
what we want our a series of automatic

47
00:03:56,880 --> 00:04:01,730
defenses that are on by default and at
least block that activity from happening

48
00:04:01,730 --> 00:04:06,649
we want to go back to fence that may fix
bad code dynamically through recursion

49
00:04:06,650 --> 00:04:07,830
and similar

50
00:04:07,830 --> 00:04:12,300
out of control but just gives us an
additional good defensive property in

51
00:04:12,300 --> 00:04:16,680
our framework so when we look at you go
through and look at a couple modern

52
00:04:16,680 --> 00:04:21,000
controls and frameworks in this
presentation we really want to see him

53
00:04:21,000 --> 00:04:26,520
hit five six and seven preferably seven
we're just adding a good solid defense

54
00:04:26,520 --> 00:04:31,430
into our framework and the developer
gets that benefit just by using the

55
00:04:31,430 --> 00:04:35,880
framework now by having to enable it or
use it or call the right API or

56
00:04:35,880 --> 00:04:38,890
sacrifice a goat whatever to get it
right

57
00:04:38,890 --> 00:04:42,560
automatic defenses are where it's at
that's what we're going to focus on in

58
00:04:42,560 --> 00:04:44,849
this presentation automatic

59
00:04:44,849 --> 00:04:49,069
fences anything it's possible you think
it's possible to build a framework which

60
00:04:49,069 --> 00:04:54,009
certain controls and defensive players
built into it that developers get

61
00:04:54,009 --> 00:04:59,539
automatically without having to take any
action do you think this is realistic or

62
00:04:59,539 --> 00:05:03,409
is this more of a pie in the sky idea
what do you think it's realistic

63
00:05:03,409 --> 00:05:07,990
especially for four more generic
technical controls it's not just

64
00:05:07,990 --> 00:05:13,559
realistic I say it two major gap if
you're not doing it you can think of

65
00:05:13,559 --> 00:05:18,649
some areas we're adding automatic
defenses into your framework is not

66
00:05:18,649 --> 00:05:24,139
possible or not realistic he liked the
injection class of problems much of what

67
00:05:24,139 --> 00:05:28,550
will be focusing on I think all of them
are solvable through automatic defensive

68
00:05:28,550 --> 00:05:33,259
strategies you think of any areas where
it's not going to be or not to be able

69
00:05:33,259 --> 00:05:43,269
to pull this off I'm sure you that it
was in fact a talk from like less than

70
00:05:43,269 --> 00:05:47,330
12 hours ago that talked about automatic
method so I think even that a really

71
00:05:47,330 --> 00:05:51,829
hard problem I was convinced in the last
12 hours it is possible show you some of

72
00:05:51,829 --> 00:05:55,300
that research so I dare say that's true
anywhere anywhere else you think it's

73
00:05:55,300 --> 00:06:02,119
not possible to automatically security
would be large legacy code bases I'm

74
00:06:02,119 --> 00:06:07,229
gonna first certain risks may be but I'm
gonna show you a couple hacks into PHP

75
00:06:07,229 --> 00:06:11,579
and proposals that will take legacy
existing sequel injectable vulnerable

76
00:06:11,579 --> 00:06:15,999
PHP code bases there's a lot of that out
there and and automatic security to it

77
00:06:15,999 --> 00:06:19,129
without being too involved a developer
and coat so let's see if you buy it or

78
00:06:19,129 --> 00:06:20,599
not I will it will look at it

79
00:06:20,599 --> 00:06:24,509
where else you think is really not
possible and the questions were can we

80
00:06:24,509 --> 00:06:28,899
im sorry just for the recording can we
ought to meet eighty was like we can't

81
00:06:28,899 --> 00:06:33,389
automate HTML sanitization from a
WYSIWYG editor I agreed with you until

82
00:06:33,389 --> 00:06:37,019
recently I think there's other solutions
there will look at him the other quite

83
00:06:37,019 --> 00:06:40,979
the other question was your comment was
we can't automatically execute

84
00:06:40,979 --> 00:06:42,919
automatically secure

85
00:06:42,919 --> 00:06:47,519
old legacy code base I tend to agree
with that but there are some methods to

86
00:06:47,519 --> 00:06:53,539
consider at least looking for though
what security areas are security defense

87
00:06:53,539 --> 00:06:58,009
of topics it really tough to just
automatically provide security

88
00:06:58,009 --> 00:07:06,629
the framework level commercial
off-the-shelf software firm or not not

89
00:07:06,629 --> 00:07:11,589
the kind of software but more of the
architectural security component in that

90
00:07:11,589 --> 00:07:15,419
software like what but here's one
subject cross-site scripting defense

91
00:07:15,419 --> 00:07:19,719
another topic is password storage
another topic is authentication best

92
00:07:19,719 --> 00:07:24,419
practices or injection protection what
security area you think we're always

93
00:07:24,419 --> 00:07:27,469
gonna have to write ourselves in some
way

94
00:07:27,469 --> 00:07:30,960
bingo that's exactly what I was looking
for

95
00:07:30,960 --> 00:07:33,849
there's a lot of companies who are like
we could just buy our product and

96
00:07:33,849 --> 00:07:37,490
slapping from the afternoon got really
good authentication or by our enterprise

97
00:07:37,490 --> 00:07:41,589
products I put on your lap and i got
really advanced multi-tenant out of

98
00:07:41,589 --> 00:07:46,169
control and they don't exist in fact in
our frameworks today I can jack little

99
00:07:46,169 --> 00:07:51,099
to no one has access control correct for
the modern era in the modern era we need

100
00:07:51,099 --> 00:07:55,800
to support two major access control
features multi-tenancy multiple

101
00:07:55,800 --> 00:08:00,189
customers and to think code base with
different rule sets and did a contextual

102
00:08:00,189 --> 00:08:04,830
access control low-level access control
this comes up all the time now it's no

103
00:08:04,830 --> 00:08:09,620
longer a special case it's a normal case
in all more frameworks don't even begin

104
00:08:09,620 --> 00:08:15,740
to address that so we are forced to code
that stuff ourselves authentication and

105
00:08:15,740 --> 00:08:24,559
that's that's a lot in this mix of all
water open IDC connect symbol your

106
00:08:24,559 --> 00:08:29,319
normal single sign-on layer your normal
web app level authentication is a huge

107
00:08:29,319 --> 00:08:34,190
morass of technology that we have to
stitch together it is really hard to buy

108
00:08:34,190 --> 00:08:38,389
your way or framework your way out of
those things so I agree where does that

109
00:08:38,389 --> 00:08:41,969
leave us that lets talk about again
these should be common defensive

110
00:08:41,969 --> 00:08:47,060
strategies in common risk that we've
talked about multiple times so let's

111
00:08:47,060 --> 00:08:49,040
start with and love this topic

112
00:08:49,040 --> 00:08:52,130
cross-site scripting talk about
automated cross-site scripting defense

113
00:08:52,130 --> 00:08:56,750
and look at some of the strategies out
there right I like to look at rails

114
00:08:56,750 --> 00:09:02,040
rails as one of the early popular
frameworks that integrated automatic

115
00:09:02,040 --> 00:09:07,050
defense so in Rails three or four when
you just drop a parameter in a Rails

116
00:09:07,050 --> 00:09:11,500
user interface without needing to
configure anything with

117
00:09:11,500 --> 00:09:16,420
out needing to involve the developer
without needing to enable some API when

118
00:09:16,420 --> 00:09:22,130
you drop data in a UI rails escapes as
we see in the first example there and

119
00:09:22,130 --> 00:09:28,280
then if the developer wants to turn off
escaping like to render HTML to that

120
00:09:28,280 --> 00:09:34,560
variable than they can send a wrong
parameter or so stay this a perimeter .

121
00:09:34,560 --> 00:09:39,680
HTML safe when you specify a variable is
safe

122
00:09:39,680 --> 00:09:43,829
that means you're gonna turn off
security and let the content render

123
00:09:43,830 --> 00:09:51,310
directly when you as an auditor look at
this call HTML safe what does this say

124
00:09:51,310 --> 00:09:59,150
to you as an auditor really was a tu it
says it says the opposite of what it

125
00:09:59,150 --> 00:10:03,750
should it so this is an early example of
a framework providing automatic security

126
00:10:03,750 --> 00:10:09,170
with the way to disable it I believe it
was designed fundamentally wrong because

127
00:10:09,170 --> 00:10:15,969
we audit code HTML safe does not make
content safe so early adopter of auto

128
00:10:15,970 --> 00:10:20,280
escaping with you get it done a bit
better if we look at most of us who are

129
00:10:20,280 --> 00:10:25,449
building new development today you're
either using react amber Ajax are your

130
00:10:25,450 --> 00:10:29,120
couple of years behind I stick with
respect using one of these three major

131
00:10:29,120 --> 00:10:35,040
JavaScript frameworks to do advanced
user interface development and again

132
00:10:35,040 --> 00:10:39,170
when you drop date in to react
especially with their JSX Technology

133
00:10:39,170 --> 00:10:44,589
Akure technology it automatically
escapes and if you're not using JSX with

134
00:10:44,590 --> 00:10:48,300
reactive you're probably a little bit
crazy because it is a this is a core

135
00:10:48,300 --> 00:10:52,030
component that provides a lot of
automatic defense you escaped everything

136
00:10:52,030 --> 00:10:57,410
by default in in some of the main
context the problem is why I'm

137
00:10:57,410 --> 00:11:02,959
critiquing little because react to fully
protect you from XSS there's a bunch of

138
00:11:02,960 --> 00:11:06,670
vectors when this really
well-thought-out framework built from

139
00:11:06,670 --> 00:11:07,729
Facebook

140
00:11:07,730 --> 00:11:13,200
they punted on a few edge cases within
reacted could have locked down with a

141
00:11:13,200 --> 00:11:16,770
little bit of design work but they
didn't so although I'm a big fan of the

142
00:11:16,770 --> 00:11:19,860
work they're doing here I feel it

143
00:11:19,860 --> 00:11:25,990
little bit of a missed opportunity
because they do great things like this

144
00:11:25,990 --> 00:11:30,050
all strings are converted to HTML
entities and tokenizer becomes

145
00:11:30,050 --> 00:11:36,229
extraordinarily difficult in some cases
impossible to access to a standard Ruby

146
00:11:36,230 --> 00:11:42,950
on Rails template and put the truck with
a standard through a standard react Jas

147
00:11:42,950 --> 00:11:47,480
program through normal programming
however we have some of these kinds of

148
00:11:47,480 --> 00:11:51,839
problems we're just keeping just doesn't
save you all the time if you're putting

149
00:11:51,839 --> 00:11:59,000
untrusted data into an event handler on
click on blur even escaped data execute

150
00:11:59,000 --> 00:12:04,540
an event handler attribute so we have
that problem that comes up often we have

151
00:12:04,540 --> 00:12:11,399
issues where with your accepting the URL
from a user can you drop it in a href

152
00:12:11,399 --> 00:12:17,579
coded so you can't break out of the HRF
but they still support JavaScript URLs

153
00:12:17,579 --> 00:12:24,099
and probably had a problem we had in
blogging software couple of years back

154
00:12:24,100 --> 00:12:29,279
pops up again even in brand new
frameworks we also had to write what I

155
00:12:29,279 --> 00:12:32,689
do like about reactors framework
developers are getting a lot more

156
00:12:32,690 --> 00:12:37,170
intelligent about how to turn off
security so when you want to turn off

157
00:12:37,170 --> 00:12:39,800
automatic escaping in react you have to
say

158
00:12:39,800 --> 00:12:47,949
dangerously set innerHTML yeah that's
the first time I've seen a framework

159
00:12:47,949 --> 00:12:53,300
that gets the name right and it really
without having to document without

160
00:12:53,300 --> 00:12:59,500
having to like educated developer just
by naming and building the frame work

161
00:12:59,500 --> 00:13:05,089
correctly the developer get it instantly
that's a big win in the problem is those

162
00:13:05,089 --> 00:13:08,620
things do all wrong like you have a
problem with the auto escaping

163
00:13:08,620 --> 00:13:14,000
technology where I can run trusted data
drives the kind of data and the server

164
00:13:14,000 --> 00:13:18,329
side looks at that variable to determine
is JSON object is this a string and the

165
00:13:18,329 --> 00:13:22,729
client can drive that now the attacker
can turn off escaping by manipulating

166
00:13:22,730 --> 00:13:28,680
input and we saw this against reactant
version 2.1 for the eventually added an

167
00:13:28,680 --> 00:13:32,050
automatic mechanism where

168
00:13:32,050 --> 00:13:36,149
server-side code would now recognized
input properly handle it properly so now

169
00:13:36,149 --> 00:13:41,769
boom they had to go through a couple
bumps but again there's a few edge cases

170
00:13:41,769 --> 00:13:46,550
I can still pop react by using it
normally an insanely that's a problem

171
00:13:46,550 --> 00:13:50,910
that not everything is properly escaped
when they turn off escaping they make it

172
00:13:50,910 --> 00:13:56,269
correct it so it's ok they're doing do
not fully up to maturity stack level but

173
00:13:56,269 --> 00:14:01,000
they're reasonable me a lot of smart
choices overall even better and I'm

174
00:14:01,000 --> 00:14:05,850
gonna say the best cases of a framework
handling cross-site scripting by far is

175
00:14:05,850 --> 00:14:10,600
go templates no one's even close to them
right now go is one of the only user

176
00:14:10,600 --> 00:14:14,589
interface template technologies don't
walk around Jim I'm sorry forgot that

177
00:14:14,589 --> 00:14:23,250
they put ya one of things that go
templates does well first of all it's

178
00:14:23,250 --> 00:14:27,779
very concise codebase Google rewrote the
whole file upload mechanism ago and one

179
00:14:27,779 --> 00:14:31,130
from several million lines of code to
like couple thousand it was a very

180
00:14:31,130 --> 00:14:34,470
concise expressive language that I
really like that the combination of the

181
00:14:34,470 --> 00:14:35,190
two

182
00:14:35,190 --> 00:14:40,779
the air contextually escaping in the
right context automatically just by

183
00:14:40,779 --> 00:14:44,589
using the template and if you render a
variable in a location that can't be

184
00:14:44,589 --> 00:14:50,279
escaped safely the template will not
compile and work so even better this is

185
00:14:50,279 --> 00:14:53,899
mind boggling that someone's doing this
in the last couple of years

186
00:14:53,899 --> 00:15:02,370
look at this context right here in this
context it's a weary it's a query string

187
00:15:02,370 --> 00:15:07,130
parameter inside of an H ref tag before
you look here how am I supposed to

188
00:15:07,130 --> 00:15:12,420
encode this if I'm going to URL and I
have a variable I'm dropping in a query

189
00:15:12,420 --> 00:15:19,880
string parameter how am I supposed to
encode this for XSS defense where else

190
00:15:19,880 --> 00:15:24,769
which one

191
00:15:24,769 --> 00:15:31,949
your own polling zone coating which one
you're all the edges both just mean you

192
00:15:31,949 --> 00:15:35,618
can get away with your own coating and
not get pop but you're really supposed

193
00:15:35,619 --> 00:15:41,600
to do is first you URL encode certain
characters cause you're putting it into

194
00:15:41,600 --> 00:15:47,009
your own context and then you encoded
with HTML encoding because you're an

195
00:15:47,009 --> 00:15:51,410
attribute no one gets most developers
don't get this right but here's a

196
00:15:51,410 --> 00:15:58,589
framework you doing this right its
encoding both URL encoded tagged and

197
00:15:58,589 --> 00:16:03,869
then its HTML intent and re-encoding the
single quote so it's properly represent

198
00:16:03,869 --> 00:16:09,579
an output it's mind-boggling to me that
we see from Google an example of this

199
00:16:09,579 --> 00:16:10,628
done right

200
00:16:10,629 --> 00:16:16,579
my hope in the future that every single
software framework will be doing this

201
00:16:16,579 --> 00:16:20,388
and just a matter of a couple years
otherwise no I don't think a lot of hope

202
00:16:20,389 --> 00:16:24,829
for this particular risk category so it
can be done what did even

203
00:16:24,829 --> 00:16:28,939
what's an equally good example of a
framework that handles cross-site

204
00:16:28,939 --> 00:16:37,610
scripting automatically any thoughts
from dinette missing a lot of briefly to

205
00:16:37,610 --> 00:16:44,100
missing a team of sanitation a key part
of excess defense has anti excess

206
00:16:44,100 --> 00:16:48,649
library for.net but I have to say I
don't just use NBC and get the

207
00:16:48,649 --> 00:16:53,279
protection I to be a smart developer and
use the API score correctly and that's

208
00:16:53,279 --> 00:16:57,179
lower down the majority stack dotnet
were the first ones to have an output

209
00:16:57,179 --> 00:17:01,360
encoding library they were the first to
give us the ability to write secure user

210
00:17:01,360 --> 00:17:04,360
interfaces but they never carried out
far enough

211
00:17:04,359 --> 00:17:07,719
anyone else want to jump in what
software development framework as were

212
00:17:07,720 --> 00:17:15,020
the most mature CrossRef defenses in
2016 I'll give you a hint it's not

213
00:17:15,020 --> 00:17:21,359
linear it's it's angular anyone have any
experience with angular around

214
00:17:21,359 --> 00:17:25,178
cross-site scripting defense anybody
ever tried to pen test to an angular

215
00:17:25,179 --> 00:17:33,330
Apple for anybody here in the room with
me know I still early for this right so

216
00:17:33,330 --> 00:17:37,809
we have angular has three different
tiers are 2 different tears

217
00:17:37,809 --> 00:17:42,908
of automatic HTML seated position when
you try to buying the variable of any

218
00:17:42,909 --> 00:17:44,679
tears the snippet at the top

219
00:17:44,679 --> 00:17:50,210
there's the attack went on mouseover its
mouth over the attack launches so here

220
00:17:50,210 --> 00:17:55,490
we have energy bind just answer this do
with you this one first automatic

221
00:17:55,490 --> 00:18:00,649
escaping when you use the basic energy
buying an angular just how you put date

222
00:18:00,649 --> 00:18:05,018
on screens nothing special about this it
automatically context escapes in most

223
00:18:05,019 --> 00:18:10,139
contexts so I see the code but nothing
execute now look at and look at this

224
00:18:10,139 --> 00:18:13,289
this is often if you say are you ready

225
00:18:13,289 --> 00:18:18,710
deliberately trust dangerous snippet
developer does that and let

226
00:18:18,710 --> 00:18:23,230
untrustworthy to go in there is Darwin a
place developer Darwinism and we see it

227
00:18:23,230 --> 00:18:28,389
actually execute here and they turned
off good security for no reason I can't

228
00:18:28,389 --> 00:18:31,799
help you there but at least as an
auditor I can order the stuff very

229
00:18:31,799 --> 00:18:35,649
quickly and see all the places where
scrapings turned off and deal with it

230
00:18:35,649 --> 00:18:39,969
but again most variables automatically
escape and if you declare the widget to

231
00:18:39,970 --> 00:18:41,769
be HTML

232
00:18:41,769 --> 00:18:46,149
allows a wait list of certain markup to
go through and strips everything else

233
00:18:46,149 --> 00:18:46,998
out

234
00:18:46,999 --> 00:18:51,159
magically without configuration just
average

235
00:18:51,159 --> 00:18:55,789
new developer uses angular even modestly
correct

236
00:18:55,789 --> 00:19:03,360
major class of XSS goes away now here's
the problem where can and where can a

237
00:19:03,360 --> 00:19:08,959
where did your appt go wrong if you look
at like the top tax assessor's on the

238
00:19:08,960 --> 00:19:10,379
planet in my opinion

239
00:19:10,379 --> 00:19:14,009
number one exercise guru is Mario
Heinrich from Germany member of our

240
00:19:14,009 --> 00:19:14,789
community

241
00:19:14,789 --> 00:19:18,830
number two is a Sharjah fed by Pakistan
he's hit every bug bounty known to man

242
00:19:18,830 --> 00:19:23,899
Chris Christoff over a Google these are
some of the top tax assessor's on the

243
00:19:23,899 --> 00:19:28,529
planet and when you give them an angular
there's a couple cases they can populate

244
00:19:28,529 --> 00:19:33,279
problems in the framework of her super
esoteric these guys don't always like to

245
00:19:33,279 --> 00:19:37,519
give their secrets away Mario does like
to give a secret way that's alright so

246
00:19:37,519 --> 00:19:40,649
he has a couple of agencies want to
share sometimes so the elite can get

247
00:19:40,649 --> 00:19:47,279
through how do you stop Mario from
accessing even fully locked down a penny

248
00:19:47,279 --> 00:19:51,240
can how do you stop the elite elite
attackers from popping

249
00:19:51,240 --> 00:19:59,500
up you gotta add one more technology to
the particular play here are for wimps

250
00:19:59,500 --> 00:20:03,640
don't even go there and with an F for
reason because you're that's what you

251
00:20:03,640 --> 00:20:06,300
are you depend on it so sorry about that

252
00:20:06,300 --> 00:20:14,830
bank that the only technology available
today that will stop the deep attackers

253
00:20:14,830 --> 00:20:19,439
from popping your apt and anger is one
of the only frameworks out there that

254
00:20:19,440 --> 00:20:23,970
natively allows the needle allows for a
CSF pluggin with proper configuration

255
00:20:23,970 --> 00:20:30,020
they change different CSS code it's hurt
performance to tiny bit but it's got the

256
00:20:30,020 --> 00:20:36,250
complete the trifecta of defenses
automatic escaping HTML sanitization

257
00:20:36,250 --> 00:20:42,250
content security policy integration and
when you turn this stuff off the API is

258
00:20:42,250 --> 00:20:51,000
abundantly clear this is the future of
excess defense so that's a bonus we see

259
00:20:51,000 --> 00:20:55,030
some of the Googlers in the W three see
folks working on a technology called

260
00:20:55,030 --> 00:20:59,340
safe node which will do some of these
this work on the client as well as the W

261
00:20:59,340 --> 00:21:03,510
three ci thats like couple days ago this
conversation was going down another

262
00:21:03,510 --> 00:21:11,000
interesting thing about angular is that
as a as a user interface UI framework

263
00:21:11,000 --> 00:21:15,400
the primary use case for angular they
have really good cross-site request

264
00:21:15,400 --> 00:21:22,420
forgery defense built in for the modern
era many angular apps talk tonight

265
00:21:22,420 --> 00:21:26,309
traditional web apps with two most
angular apps talk to you on the back end

266
00:21:26,309 --> 00:21:32,980
today would you most heavy JavaScript
build applications how do they talk to

267
00:21:32,980 --> 00:21:38,780
the back end all talk about rest now
correct and it is a very profiling

268
00:21:38,780 --> 00:21:42,379
things I wanna I wanna steel yourself
when I say that you're not going to

269
00:21:42,380 --> 00:21:46,410
believe this I know it's crazy
buttressed developers want to build

270
00:21:46,410 --> 00:21:52,140
something called a stateless rest micro
service have you heard that this hurts

271
00:21:52,140 --> 00:21:56,559
me to even talk about this statelessness
what it would mean by I want my server

272
00:21:56,559 --> 00:22:01,200
my heavy transaction e-commerce with
lots of access control

273
00:22:01,200 --> 00:22:04,150
want to be state with what does that
mean what to do about what the

274
00:22:04,150 --> 00:22:07,640
company is saying is that they're saying
this is a look we only have a limited

275
00:22:07,640 --> 00:22:12,000
amount of resources we have executives
and they have got to get their bonuses

276
00:22:12,000 --> 00:22:15,440
you know much a Ferrari cost to get
fixed so we're not gonna bother actually

277
00:22:15,440 --> 00:22:18,750
buying real hardware for the servers
we're not gonna bother getting a real

278
00:22:18,750 --> 00:22:23,170
pipe in we're gonna be super cheap shot
you'll obey them with your server and

279
00:22:23,170 --> 00:22:27,240
get you the cheapest server that I can
give you without complaining remember

280
00:22:27,240 --> 00:22:32,470
Ferraris and bonuses just the way it is
so how can you use that server with this

281
00:22:32,470 --> 00:22:36,950
little resources possible and still
scale the whole world that are stateless

282
00:22:36,950 --> 00:22:41,230
web services come in at having to store
this on the server and take that hit

283
00:22:41,230 --> 00:22:46,040
both and performance in storage and all
these will just take a cookie practice

284
00:22:46,040 --> 00:22:51,700
session in a cookie do some crypto hand
waving will sign it may go down to you

285
00:22:51,700 --> 00:22:55,850
and will do nothing on the server to
hold state it's that cookie in your

286
00:22:55,850 --> 00:22:59,080
browser that holds state and good luck
with that

287
00:22:59,080 --> 00:23:02,610
how does that sound for development I
think it's insanity but the reality is

288
00:23:02,610 --> 00:23:07,729
what we're doing and so as an amateur
security professional I can say don't do

289
00:23:07,730 --> 00:23:09,270
that

290
00:23:09,270 --> 00:23:13,660
amateur stuff though right as a
professional I'm gonna say all right so

291
00:23:13,660 --> 00:23:18,090
you want to do some really crazy stuff I
cool let me help you do that it's secure

292
00:23:18,090 --> 00:23:25,189
as we can so when you're doing restless
restful State Police Services how do you

293
00:23:25,190 --> 00:23:29,290
do cross-site request forgery defense
what didn't mean defense to stop

294
00:23:29,290 --> 00:23:33,100
cross-site record cross-site request
forgery first of all what's the main

295
00:23:33,100 --> 00:23:37,610
defense a pattern of cryptographic token
that where do you normally keep that

296
00:23:37,610 --> 00:23:43,959
token in the server in the session so
what do you do if there's no session how

297
00:23:43,960 --> 00:23:52,230
do you track that not that that state
you do you do you just don't put it in

298
00:23:52,230 --> 00:23:57,040
the server anymore you you packing the
cookie and so we have no client server

299
00:23:57,040 --> 00:24:01,560
comes each request must be independent
and with the information to complete

300
00:24:01,560 --> 00:24:05,480
complete that process and the sessions
date is now on the client and to do this

301
00:24:05,480 --> 00:24:09,800
right at the very least you're doing a
digital signature on the cookie why at

302
00:24:09,800 --> 00:24:12,440
the very least we sign the cookie

303
00:24:12,440 --> 00:24:16,860
stateless cookie contains usually the
log-in time the user I D

304
00:24:16,860 --> 00:24:21,479
hopefully not have much more why am I
saying we have to sign this cookie at

305
00:24:21,480 --> 00:24:25,230
the very least and verified on the
server will benefit do I get from that

306
00:24:25,230 --> 00:24:31,179
non tampering if I give someone a
session cookie and that's that is their

307
00:24:31,179 --> 00:24:36,120
state and they can tamper with it what
might be a temper about that user I D

308
00:24:36,120 --> 00:24:41,799
boom game over right so anger has some a
default cross-site request forgery

309
00:24:41,799 --> 00:24:46,559
pattern in it called the double subic
cookie defense this defensive pattern

310
00:24:46,559 --> 00:24:53,178
was discussed for the first time
probably eight years ago by by certain

311
00:24:53,179 --> 00:24:56,340
gentleman who's in the room right now
actually in and we saw a lot of

312
00:24:56,340 --> 00:25:00,639
frameworks begin to use it years ago but
just in the last year or two since we

313
00:25:00,640 --> 00:25:04,690
were moving so quickly to JavaScript
most of those frameworks provide this

314
00:25:04,690 --> 00:25:09,690
exact defense to make sure Javascript
you I double ceramic cookie state with

315
00:25:09,690 --> 00:25:13,490
rest cross-site request forgery defense
ready

316
00:25:13,490 --> 00:25:17,679
out of the box and all you have to do is
check for a few variables on the server

317
00:25:17,679 --> 00:25:22,860
all you're doing is you're checking to
make sure of cookie called XRF token is

318
00:25:22,860 --> 00:25:27,639
delivered to the browser and it also has
a header with that same value

319
00:25:27,640 --> 00:25:32,580
you're just checking to make sure they
match without having to track any server

320
00:25:32,580 --> 00:25:36,449
state why does his defense work it's an
older defense but it's something that's

321
00:25:36,450 --> 00:25:41,040
in newer frameworks that need to be in
newer frameworks sentence patterns

322
00:25:41,040 --> 00:25:46,379
become so common the region this works
is because you're usually see your cross

323
00:25:46,380 --> 00:25:51,780
site request forgery cookie you're
usually setting a cookie that is not

324
00:25:51,780 --> 00:26:03,440
HttpOnly flag cookies HTTP only tangible
benefit do you get off that

325
00:26:03,440 --> 00:26:10,240
philosophical what can no longer read
your cookie JavaScript now for the

326
00:26:10,240 --> 00:26:14,690
double cookie submit pattern to work you
need JavaScript to read your knots

327
00:26:14,690 --> 00:26:20,200
cookie to you turn off HttpOnly and when
someone hits on your server you need

328
00:26:20,200 --> 00:26:24,600
JavaScript code to read the value of the
cookie put in the request header and

329
00:26:24,600 --> 00:26:29,240
ship those both up the region this works
is because cross domains hosting your

330
00:26:29,240 --> 00:26:30,350
CrossFit request for

331
00:26:30,350 --> 00:26:36,340
attack how much can they read your
cookies they can't so the origin of the

332
00:26:36,340 --> 00:26:41,080
page it's a different site that means an
attacker is hosting a cross-site request

333
00:26:41,080 --> 00:26:45,129
forgery attack than that JavaScript
can't read the cookie and there's no

334
00:26:45,130 --> 00:26:50,530
easy way for the attacker to ship up old
cookie and a header with the value in

335
00:26:50,530 --> 00:26:54,500
this is why this defense work to depend
upon origin policy for this to be

336
00:26:54,500 --> 00:27:00,760
successful again bad domain can't read
the cookie and the the good guy server

337
00:27:00,760 --> 00:27:06,030
is just checking to make sure both of
these values are are the same and again

338
00:27:06,030 --> 00:27:10,990
again we see this integrated naturally
into angular without any action on the

339
00:27:10,990 --> 00:27:15,340
user or developer needed to be taken as
well the better ways to solve this

340
00:27:15,340 --> 00:27:20,620
problem emerging defenses I see people
talking about in this category is there

341
00:27:20,620 --> 00:27:25,850
the era of the nazis going away in most
modern applications I haven't seen

342
00:27:25,850 --> 00:27:30,469
anyone build this yet I just seen it in
some applications so I think this is you

343
00:27:30,470 --> 00:27:35,059
look at this up to maturity stack it
still at the top because the developer

344
00:27:35,059 --> 00:27:40,470
has to write the process he called on
the server to check W even better is I

345
00:27:40,470 --> 00:27:45,440
think we see people who are going away
from novices and just checking the

346
00:27:45,440 --> 00:27:49,980
origin and referer header to make sure
the landing origin of that page was the

347
00:27:49,980 --> 00:27:54,900
same domain i'd never I'll try to not
depend upon origin policy with the

348
00:27:54,900 --> 00:28:00,419
security but we we now have origin
header being central library and most in

349
00:28:00,419 --> 00:28:05,090
most browsers firefox is about to play
ball I get a sneaking suspicion to

350
00:28:05,090 --> 00:28:10,780
Safari njema care about the soon as they
bring in smart people right and so the

351
00:28:10,780 --> 00:28:15,350
next generation origin refer her
checking to make sure the landing pages

352
00:28:15,350 --> 00:28:18,270
the right domain will look a couple of
emerging defenses in just a moment

353
00:28:18,270 --> 00:28:22,260
another key thing and still to this day
when you look at cross-site request

354
00:28:22,260 --> 00:28:27,110
forgery one XSS floor and your your
cross-site request forgery defense is

355
00:28:27,110 --> 00:28:31,370
gone what do you think is more difficult
for your appt to get a cross-site

356
00:28:31,370 --> 00:28:35,000
request forgery token working to get
your apt to be a hundred per cent

357
00:28:35,000 --> 00:28:39,730
bulletproof and cross-site scripting
what's more difficult

358
00:28:39,730 --> 00:28:44,830
by many factors I even think cross-site
scripting defense in a legacy app is

359
00:28:44,830 --> 00:28:49,040
more difficult encrypt decrypt alright
it's so many places things can go wrong

360
00:28:49,040 --> 00:28:55,180
so it's a big challenge 1 excess floor
and we can just read the token from the

361
00:28:55,180 --> 00:28:59,710
page and replays toward cross-site
scripting stored CSR efforts are stored

362
00:28:59,710 --> 00:29:00,880
XSS

363
00:29:00,880 --> 00:29:06,560
accessory different domain it becomes
easy to violate double double cookie

364
00:29:06,560 --> 00:29:11,060
submit so I want I think the next
generation of this defensive strategy

365
00:29:11,060 --> 00:29:12,139
will be origins

366
00:29:12,140 --> 00:29:16,320
checking next angular injects real quick

367
00:29:16,320 --> 00:29:20,879
older attack but we even see new
frameworks putting this in the last year

368
00:29:20,880 --> 00:29:27,730
or so if you have a pure JSON object
then cross domain can read that data in

369
00:29:27,730 --> 00:29:32,930
a very obscure ways called JSON
hijacking so most modern frameworks will

370
00:29:32,930 --> 00:29:37,750
pat your JSON with a couple characters
and now it's not proper Jason it stop

371
00:29:37,750 --> 00:29:42,980
this hijacking attack your client side
code will grab the first four characters

372
00:29:42,980 --> 00:29:48,130
from a JSON reach first five characters
from JSON response discard it and then

373
00:29:48,130 --> 00:29:52,770
parse the rest is really
well-thought-out built into angular by

374
00:29:52,770 --> 00:29:53,940
defaults

375
00:29:53,940 --> 00:30:00,610
might hope my hope for a better water
struck out of order emerging CSRF

376
00:30:00,610 --> 00:30:06,709
defenses I think this problem will help
this problem completely go away the main

377
00:30:06,710 --> 00:30:11,500
one from my quest is things like cookie
attribute it look this is an active

378
00:30:11,500 --> 00:30:15,420
discussion from a couple days ago this
is now really under bleeding edge of

379
00:30:15,420 --> 00:30:19,280
what standard bodies and next-generation
frameworks are trying to do to stop

380
00:30:19,280 --> 00:30:24,520
cross a request forgery when you set
cookie here like this it doesn't matter

381
00:30:24,520 --> 00:30:28,020
what the origin of your pages it doesn't
matter what page

382
00:30:28,020 --> 00:30:32,530
initiate the request that cookie leaves
the building this is how again

383
00:30:32,530 --> 00:30:37,350
cross-site request forgery works I host
the attack on a Web site

384
00:30:37,350 --> 00:30:41,409
the victim hit that page in the request
goes off and who cares where the request

385
00:30:41,410 --> 00:30:46,510
originated from that cookie is going
with it unless you flag a seam site

386
00:30:46,510 --> 00:30:52,379
active in chrome today seemed a scene
site request says unless the origin and

387
00:30:52,380 --> 00:30:57,220
their respective the page I'm going to
are the same don't ship the cookie is

388
00:30:57,220 --> 00:31:03,240
usually you're hosting the CSRF attack
on evil dot com that makes a request to

389
00:31:03,240 --> 00:31:11,610
good good good dotcom my questions on
the lead developers of chrome he's also

390
00:31:11,610 --> 00:31:17,090
a member the W three C and just in
january twentieth he did little

391
00:31:17,090 --> 00:31:21,220
modification specification is available
for testing I believe in Canary

392
00:31:21,220 --> 00:31:26,650
I can check and we can answer that but
this is bleeding edge and when when when

393
00:31:26,650 --> 00:31:36,010
seen site cookies are in vogue in the
browser in a couple years almost cool

394
00:31:36,010 --> 00:31:40,580
way for us it will ever happen to think
about it just used the web and when it

395
00:31:40,580 --> 00:31:45,220
comes to these two V's new bleeding edge
defenses chrome picked it up instantly

396
00:31:45,220 --> 00:31:50,190
Firefox is soon to follow but we always
have two browsers that are laggards when

397
00:31:50,190 --> 00:31:55,130
it comes to some of the leading IT
security standards IE and Safari so far

398
00:31:55,130 --> 00:32:00,659
is probably the worst of them all I is
trying to play ball and so you know what

399
00:32:00,659 --> 00:32:06,140
we can do as a community is help inform
the different browser developers that we

400
00:32:06,140 --> 00:32:09,740
do want these defenses and and and and I
think they're very receptive to these

401
00:32:09,740 --> 00:32:14,510
conversations right let's talk about
sequel injection defense again how do

402
00:32:14,510 --> 00:32:19,879
you what is the conventional wisdom of
how we tell developers not to do single

403
00:32:19,880 --> 00:32:29,600
injection with the conventional best
practice wisdom today and and

404
00:32:29,600 --> 00:32:33,850
know it's it's it's premature as queries
in the binding of variables as you can

405
00:32:33,850 --> 00:32:37,799
use the My School PTO library the Java
prepared statement class the

406
00:32:37,799 --> 00:32:42,129
ActiveRecord API and just build a query
dynamically and shoveled into the

407
00:32:42,130 --> 00:32:45,840
prepared statement call and you're
vulnerable to you I'm just picking here

408
00:32:45,840 --> 00:32:50,539
is you've got the right answer dies you
got a parametrized and buying all your

409
00:32:50,539 --> 00:32:55,669
variables so but that requires the
programmer to conduct a certain activity

410
00:32:55,669 --> 00:32:59,970
what's the first technology that came
out that auto protected us from sequel

411
00:32:59,970 --> 00:33:04,299
injection just by using the technology
to write code a fancy way you just use

412
00:33:04,299 --> 00:33:10,510
this obstructed labor and you and sequel
injections impossible for your code no

413
00:33:10,510 --> 00:33:16,929
partner answer that probably not not
nope yes not complete though what

414
00:33:16,929 --> 00:33:22,900
technology and what framework just
automatically gets equal protection in

415
00:33:22,900 --> 00:33:27,179
Java I'm talking it eight by eight QL
hibernate query language or object query

416
00:33:27,179 --> 00:33:31,520
language and I don't use parametrization
I can get object query language

417
00:33:31,520 --> 00:33:35,408
injection or hibernate query language
injection the piece of it but it's not

418
00:33:35,409 --> 00:33:40,650
the full answer which technology in
which framework was the first to give us

419
00:33:40,650 --> 00:33:48,230
100 percent single injection protection
for procedures do not be several books

420
00:33:48,230 --> 00:33:53,309
say this and they're all wrong you can
write a stored procedure that's callable

421
00:33:53,309 --> 00:33:56,950
injectable way and that's injectable in
the code itself if you don't

422
00:33:56,950 --> 00:34:01,590
parameterize properly or build a stored
procedure properly anyone who tells you

423
00:34:01,590 --> 00:34:05,870
stored procedure gives you automatic
sequence extra protection is flat out

424
00:34:05,870 --> 00:34:09,600
wrong and many big books from big
publishers say this and they're all

425
00:34:09,600 --> 00:34:10,618
wrong

426
00:34:10,619 --> 00:34:14,210
makes it difficult to you know get this
knowledge on the right way no offense

427
00:34:14,210 --> 00:34:21,649
meant . netters what technology did you
have in 2007 that stop sequin junction

428
00:34:21,649 --> 00:34:30,980
cold while most job in PHP after getting
ripped apart also the link system the

429
00:34:30,980 --> 00:34:36,379
language integrated query system to norm
it's an object relational mapping engine

430
00:34:36,379 --> 00:34:38,190
first of all you can map

431
00:34:38,190 --> 00:34:43,300
dotnet a.net classes to specific
database entries and then you just write

432
00:34:43,300 --> 00:34:49,040
the query throw variables into it and it
automatically parameterize the query

433
00:34:49,040 --> 00:34:54,239
when writing SQL this is brilliant
because now its developer I just use the

434
00:34:54,239 --> 00:34:58,879
technology stack wow my queries together
haphazardly and I'm at least immune to

435
00:34:58,880 --> 00:35:04,180
see cool injection and this is just
fantastic what's wrong with this though

436
00:35:04,180 --> 00:35:08,020
what's the weirdest developer have to do
a lot of labor to pull this off though

437
00:35:08,020 --> 00:35:11,869
the actual object relational mapping
part of it

438
00:35:11,869 --> 00:35:15,290
anybody here ever work with an object
relational mapping engine before in

439
00:35:15,290 --> 00:35:20,190
their career how much time did you spend
writing code and how much time did you

440
00:35:20,190 --> 00:35:25,410
spend tweaking configuration and testing
tweaking configuration and testing

441
00:35:25,410 --> 00:35:30,480
that's how familiar you spend all your
time living in an XML file or Jason file

442
00:35:30,480 --> 00:35:33,970
fixing your mapping you just want to
beat your head against the wall after

443
00:35:33,970 --> 00:35:38,560
few days of doing that so it's a lot of
work to do object relational mapping so

444
00:35:38,560 --> 00:35:44,830
how can we write a sequel statement that
closer to see quo for now we have Ruby

445
00:35:44,830 --> 00:35:50,830
on Rails 2011 who took a stab at it with
Carol Ann Darrow gives me a meta query

446
00:35:50,830 --> 00:35:52,150
language that looked at

447
00:35:52,150 --> 00:35:57,500
one-to-one mapping with SQL it looks
like SQL running away but it's not

448
00:35:57,500 --> 00:36:04,250
exactly SQL it's giving me a metal
language abstract above it that is

449
00:36:04,250 --> 00:36:08,770
pretty much one-to-one with building SQL
the auto parameterize is everything

450
00:36:08,770 --> 00:36:13,430
that's a step in a better direction it
still stops before marching SQL though

451
00:36:13,430 --> 00:36:18,049
it still forces me to use an abstraction
which is a hit so here's why I think the

452
00:36:18,050 --> 00:36:25,320
future is this is this is a proposal
from Google employees that came out just

453
00:36:25,320 --> 00:36:31,750
a few months ago and it's under heavy
discussion for Java set for PHP 714

454
00:36:31,750 --> 00:36:36,650
probably PHP 8 what he's doing is
basically take tracking and not as a

455
00:36:36,650 --> 00:36:43,910
plugin or as add-on but as part of the
PHP core language itself and he finished

456
00:36:43,910 --> 00:36:48,589
this is pushed live not in PHP and his
demo so you can look at it here he could

457
00:36:48,589 --> 00:36:53,130
detect if a variable is static and if
it's it's static could be a lot of

458
00:36:53,130 --> 00:36:55,280
different things look at the second

459
00:36:55,280 --> 00:37:00,060
static and all the element of your SQL
come from static sources it's a safe

460
00:37:00,060 --> 00:37:04,870
string if any part of the SQL was
dynamic that it's dangerous it will

461
00:37:04,870 --> 00:37:09,000
block the query from running and this is
something you can push live into an

462
00:37:09,000 --> 00:37:14,390
existing PHP application with zero
developer activity and protect you from

463
00:37:14,390 --> 00:37:19,049
single injection so that these are
static right to select from table or

464
00:37:19,050 --> 00:37:22,170
we're defining a static call me know
even though this is string concatenation

465
00:37:22,170 --> 00:37:27,070
public weary we know it's just bite we
know it's a static portion of a query or

466
00:37:27,070 --> 00:37:31,530
even this is determined to be safe even
though the user type is dynamic from the

467
00:37:31,530 --> 00:37:36,760
user we're only gonna put the static
admin or user in this variable

468
00:37:36,760 --> 00:37:41,070
injections not possible with this code
and and this proposal recognize that

469
00:37:41,070 --> 00:37:46,740
this is also safe pulling data from
config and this is how you circumvented

470
00:37:46,740 --> 00:37:51,700
security disabled seagull injection
protection I like it because it's cool

471
00:37:51,700 --> 00:37:57,080
it's very clear that you're doing
something crazy but we have to do this

472
00:37:57,080 --> 00:38:01,560
if I'm building administrator screen to
run sequel than I need to for those kind

473
00:38:01,560 --> 00:38:06,230
of tools I need to seek injection by
design for admins and this is an unsafe

474
00:38:06,230 --> 00:38:10,990
Querrey we're now a variable is directly
dumped into aquarium just explicitly

475
00:38:10,990 --> 00:38:17,290
block this automatic defense no
developer activity needed during runtime

476
00:38:17,290 --> 00:38:20,640
to developers Querrey will stop running
will get a book an error message saying

477
00:38:20,640 --> 00:38:25,140
you just put in on open variable into
aquarium we're not gonna let that run

478
00:38:25,140 --> 00:38:30,810
for your own sake please go fix it and
this is a major change to PHP it's the

479
00:38:30,810 --> 00:38:32,440
right thing to do

480
00:38:32,440 --> 00:38:36,920
there's a lot of the poor developers up
each peak or who do not want this to

481
00:38:36,920 --> 00:38:41,190
roll in it it's a heated debate so those
of us in the abstract community if you

482
00:38:41,190 --> 00:38:46,990
care about PHP I care about PHP jump
into this conversation and add your

483
00:38:46,990 --> 00:38:52,270
feedback to this proposal I think Pete
Pete teen core realizes they need to add

484
00:38:52,270 --> 00:38:56,350
automatic sequence Jackson crossing
through protection at the language level

485
00:38:56,350 --> 00:39:00,680
and they're really just at the forefront
of that conversation taking it seriously

486
00:39:00,680 --> 00:39:06,620
if any of you depend upon PHP care about
PHP or like two issues snarky you know

487
00:39:06,620 --> 00:39:08,538
antiestablishment college

488
00:39:08,539 --> 00:39:13,019
a PHP better and this is the
conversation where it's happening right

489
00:39:13,019 --> 00:39:19,419
now we also you 58 few things to make it
easier I used to trash mobile

490
00:39:19,419 --> 00:39:24,098
application rappers like these are
brilliant I was in a situation recently

491
00:39:24,099 --> 00:39:28,029
with this developer and esteem low
resourced they need to move the whole

492
00:39:28,029 --> 00:39:34,299
apt to be HTTPS it's not easy to do
HTTPS on the client your YouTube and in

493
00:39:34,299 --> 00:39:38,969
that connection yourself in code so
there's a few companies that will give

494
00:39:38,969 --> 00:39:43,509
you a wrapper for your mobile app your
rapid and now only thing leaving that

495
00:39:43,509 --> 00:39:49,880
little mobile app is well tuned HTTPS
changing my tune because it's a quick

496
00:39:49,880 --> 00:39:54,469
win it's not that expensive hit the
right vendor and it provides pretty

497
00:39:54,469 --> 00:39:58,769
significant security out of the box one
other quick know if we finish up his

498
00:39:58,769 --> 00:40:02,779
eighth St S is not playing well with
mixed content if you have mixed content

499
00:40:02,779 --> 00:40:07,369
is actually block your page because the
mix content check happens before the

500
00:40:07,369 --> 00:40:12,469
strict transport security check so what
do you think we see in CSP which was

501
00:40:12,469 --> 00:40:15,439
recommended for days ago

502
00:40:15,439 --> 00:40:19,868
sure you knew things before day ago
conversation he upgraded secure request

503
00:40:19,869 --> 00:40:25,599
call so now what I hate your first page
over HTTP and you respond with the

504
00:40:25,599 --> 00:40:30,799
content security policy and you know the
whole site to PHP s you can tell the

505
00:40:30,799 --> 00:40:37,140
browser upgrade insecure request so
everything else that that domain does

506
00:40:37,140 --> 00:40:43,969
within that policy time is gonna only
make HPS request even external links

507
00:40:43,969 --> 00:40:48,429
transport security does not do that
today Transport Security blocks and this

508
00:40:48,429 --> 00:40:52,650
is saying let's force upgrade it clears
the problem if you're the new york times

509
00:40:52,650 --> 00:40:58,209
you have under incident X number of
articles out there and your archives are

510
00:40:58,209 --> 00:41:03,319
now all HTTP for many years ago do you
want to go back to your fifty thousand

511
00:41:03,319 --> 00:41:09,359
articles and change every HTTP HTTPS the
answer is no you don't get a monstrous

512
00:41:09,359 --> 00:41:13,619
problem when your publisher with that
problem so we have this proposal for

513
00:41:13,619 --> 00:41:19,239
again from my quest to allow inflicted
New York Times to deliver the CSP policy

514
00:41:19,239 --> 00:41:21,829
and without rewriting 50,000

515
00:41:21,829 --> 00:41:26,029
pages are more force the whole site ugh
to be at the class level go ahead sir

516
00:41:26,029 --> 00:41:37,249
famous last words when you have like
several hundred thousand pages good luck

517
00:41:37,249 --> 00:41:39,549
with that is it another way to go about
that

518
00:41:39,549 --> 00:41:44,150
less why this all important it's less
effort for the developer they just do it

519
00:41:44,150 --> 00:41:47,910
and the whole site changes could take
years for this really sinks in which

520
00:41:47,910 --> 00:41:51,578
just makes it easier on the development
automatic writing those rules can be

521
00:41:51,579 --> 00:41:56,619
super problematic and and terminator

522
00:41:56,619 --> 00:42:02,079
now do you normally we went to a show
more validation we build some kind of

523
00:42:02,079 --> 00:42:07,489
XML or programmatic policy to determine
which tags are ok which tags are not and

524
00:42:07,489 --> 00:42:11,160
when you have a complex policy just
becomes difficult to manage this is best

525
00:42:11,160 --> 00:42:15,848
practice right now so awesome job HTML
sanitizer is what I used in production

526
00:42:15,849 --> 00:42:20,279
but we can we can go about this in a
different ways where language security

527
00:42:20,279 --> 00:42:25,989
comes in where the idea to treat a lot
code to although tokenizer everything

528
00:42:25,989 --> 00:42:29,319
running to a VCM simulating the browser

529
00:42:29,319 --> 00:42:32,869
this is the kind of things more the
advanced thinkers in this area are doing

530
00:42:32,869 --> 00:42:37,619
and they can get wire speeds with very
low false positives with this kind of

531
00:42:37,619 --> 00:42:39,839
thinking

532
00:42:39,839 --> 00:42:45,150
interesting from phenomenon he talked
about this yesterday it really made me

533
00:42:45,150 --> 00:42:49,190
look differently and how do I add to
citation now there's automatic methods

534
00:42:49,190 --> 00:42:54,170
both on the server with these kinds of
defensive techniques as well as on the

535
00:42:54,170 --> 00:42:58,619
client here's a discussion from a few
days ago david ross also from Google

536
00:42:58,619 --> 00:43:04,969
wants to build a safe node instead of
giving me the whole policy on which tags

537
00:43:04,969 --> 00:43:10,079
are good which ones are not that's a rat
racial never win now we can take a node

538
00:43:10,079 --> 00:43:15,410
and say that enable the FIFA tribute and
don't allow external content download

539
00:43:15,410 --> 00:43:19,680
this many other rules we can add now I
have this untrusted markup from which

540
00:43:19,680 --> 00:43:23,259
you will get better and I could just
drop it in the safe no doubt has this

541
00:43:23,259 --> 00:43:28,119
rule and it will automatically do the
same position for me again the things

542
00:43:28,119 --> 00:43:32,569
I'm trying to highlight in this talk are
things that are automatic that we can

543
00:43:32,569 --> 00:43:35,450
take the developer out of the equation
to some degree

544
00:43:35,450 --> 00:43:40,620
and we have you don't we have spring in
2013 adding a variety of the security

545
00:43:40,620 --> 00:43:42,120
headers by default

546
00:43:42,120 --> 00:43:47,560
Ruby on Rails and 2013 added extra
options and these are just every single

547
00:43:47,560 --> 00:43:52,340
response just by using this framework as
all these security headers for us and

548
00:43:52,340 --> 00:43:56,620
the developer had to turn it off it's
not it's not off by two faltered on it

549
00:43:56,620 --> 00:44:01,870
is on an enabled by default and modified
if necessary

550
00:44:01,870 --> 00:44:05,560
this is the hope for a better future by
the way I did it in and access control

551
00:44:05,560 --> 00:44:11,759
center that it's just hard freaking work
sorry there's no way around it are two

552
00:44:11,760 --> 00:44:17,230
areas you want to invest heavily in
early I love life cycle to rewrite your

553
00:44:17,230 --> 00:44:22,990
Access Controller you're rewriting too
nervous system of the whole at so I am

554
00:44:22,990 --> 00:44:28,080
almost over time that the point of this
talk is that do not lament this is a

555
00:44:28,080 --> 00:44:32,720
great time for security folks are
getting paid well we're getting the

556
00:44:32,720 --> 00:44:36,680
blessing in a difficult economy we're
we're being listened to for the first

557
00:44:36,680 --> 00:44:41,600
time in security history we have a huge
amount intellect going into building a

558
00:44:41,600 --> 00:44:45,920
more secure future don't worry about the
problem worried about the solution and

559
00:44:45,920 --> 00:44:49,970
try to help move that ball down the
field I hope this this conversation

560
00:44:49,970 --> 00:44:54,080
helped push you in that direction in
some way thank you so much for being

561
00:44:54,080 --> 00:44:55,100
here

562
00:44:55,100 --> 00:45:06,230
any any questions before we wrap it up
if you don't mind you talked a little

563
00:45:06,230 --> 00:45:10,200
bit about angular but is there any other
frameworks that really stand out to you

564
00:45:10,200 --> 00:45:14,279
that are just doing it right and they're
going everything goes very close go has

565
00:45:14,280 --> 00:45:20,160
go has the best contextual escaping of
any template system it's doing doubling

566
00:45:20,160 --> 00:45:23,930
coding and some context we believe I
barely even talk about that and teaching

567
00:45:23,930 --> 00:45:28,660
but it's the right way to do it and
automatic for them that's genius that

568
00:45:28,660 --> 00:45:33,810
the mics and other people's work will
pull that off by like angle better

569
00:45:33,810 --> 00:45:40,190
though it does escaping CSP and each
motivation all built in I know of no

570
00:45:40,190 --> 00:45:43,800
other framework that is that complete so
if you're gonna build these other

571
00:45:43,800 --> 00:45:45,370
components in the future

572
00:45:45,370 --> 00:45:48,310
follow their lead those that's what I
needed to develop or two

573
00:45:48,310 --> 00:45:56,690
really stop access it's not tough
questions what a great pleasure to have

574
00:45:56,690 --> 00:46:01,370
you all here go for any questions I'm
Jim Eto'o hasta or go forth and write

575
00:46:01,370 --> 00:46:04,990
and tell people right to cure code enjoy
the rest of the conference thank you so

576
00:46:04,990 --> 00:46:05,569
much everyone

