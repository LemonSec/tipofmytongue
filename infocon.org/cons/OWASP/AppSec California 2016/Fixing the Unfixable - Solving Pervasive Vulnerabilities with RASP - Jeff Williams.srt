1
00:00:18,390 --> 00:00:28,730
i'm jeff and I'm CTO at a comical
contract security we offer product that

2
00:00:28,730 --> 00:00:34,260
supports the whole SDLC it has I asked
and rasp in a single agent so that's the

3
00:00:34,260 --> 00:00:39,160
unique please stop by and check it out
I'm really psyched to be here today if

4
00:00:39,160 --> 00:00:44,010
you see me talk before then you know
that I'm all about scale and it's not

5
00:00:44,010 --> 00:00:49,070
just cuz i'm tall I'm actually
interested in scale because every

6
00:00:49,070 --> 00:00:53,000
absolute program that I've worked with
over the last fifteen years is

7
00:00:53,000 --> 00:00:58,210
struggling with scale they've all other
Internet seen their only touching a

8
00:00:58,210 --> 00:01:02,690
small fraction of what they really ought
to be doing and in my mind

9
00:01:04,059 --> 00:01:09,759
abstract ought to apply to all of the
application portfolio right not just the

10
00:01:09,759 --> 00:01:14,140
internal apps but all of them they need
to be continuously monitored and

11
00:01:14,140 --> 00:01:18,520
protected right that's a huge thing
anybody disagree with that premise just

12
00:01:18,520 --> 00:01:19,350
starting out here

13
00:01:19,350 --> 00:01:22,658
ok who here thinks that the perimeter

14
00:01:23,430 --> 00:01:27,380
permanent protections are not doing a
great job of protecting applications

15
00:01:27,380 --> 00:01:32,979
really expecting like more who thinks
that

16
00:01:32,979 --> 00:01:38,240
devices are protecting applications are
huge not answering any questions

17
00:01:39,170 --> 00:01:44,729
ok that's good to know so if you if you
raise your hands then please stop

18
00:01:44,729 --> 00:01:50,720
talking about internal applications if
there's no perimeter there's no internal

19
00:01:50,720 --> 00:01:55,899
everything is an external piecing
application and I really want you think

20
00:01:55,899 --> 00:02:02,880
that way when you should think about
your application portfolio so today I'm

21
00:02:02,880 --> 00:02:07,119
gonna take you on a journey from really
small to like this or the smallest

22
00:02:07,119 --> 00:02:13,209
application security concerns all the
way to really big enterprise scale app

23
00:02:13,209 --> 00:02:19,299
second give up speed and portfolio scale
kind of stuff so for the next 40 minutes

24
00:02:19,299 --> 00:02:23,519
or so I want you forget what you know
about application security as well I'm

25
00:02:23,519 --> 00:02:26,670
gonna talk about it a little bit
different I have a different take on

26
00:02:26,670 --> 00:02:31,380
application security and order for quite
a long time and I'm going to try to

27
00:02:31,380 --> 00:02:41,910
suggest a new way of thinking about the
problem so malfunction here okay so

28
00:02:41,910 --> 00:02:47,590
here's what I've seen and maybe gets a
share this experience right a lot of

29
00:02:47,590 --> 00:02:52,640
penetration testing over the years and i
think is weird is that almost no

30
00:02:52,640 --> 00:02:58,768
applications ever recognize that I'm
attacking them I'm really noisy pen test

31
00:02:58,769 --> 00:03:03,950
Russian all kinds of crap to
applications totally obviously attacks

32
00:03:03,950 --> 00:03:08,828
but applications don't say stop the
police are on the way we've lost

33
00:03:08,829 --> 00:03:15,859
everything they say yeah I didn't
understand your request please try again

34
00:03:16,829 --> 00:03:23,630
they want to keep hacking that's really
weird rate so lake to me the simplest

35
00:03:23,630 --> 00:03:28,359
thing that you could do this to improve
application securities identify obvious

36
00:03:28,359 --> 00:03:36,040
attacks and block them right so why is
it that the clickers networking

37
00:03:36,040 --> 00:03:41,940
whatsoever so why don't applications
protect themselves that's strange to me

38
00:03:41,940 --> 00:03:46,940
we're you know rasp is a one-time
application self-protection and

39
00:03:46,940 --> 00:03:48,859
self-protection is a really key

40
00:03:48,860 --> 00:03:54,190
key concept here entry when asked why
don't applications protect themselves

41
00:03:54,190 --> 00:04:01,490
well there's research two options right
you can build insecurity and that's

42
00:04:01,490 --> 00:04:06,220
really hard right I'm gonna stayed after
twenty years of trying that this

43
00:04:06,220 --> 00:04:11,480
approach is not likely to start working
all of a sudden rate nothing's changed I

44
00:04:11,480 --> 00:04:18,180
mean is really hard to get it at scale
to build secure out we can argue about

45
00:04:18,180 --> 00:04:22,740
that later he's giving me the so you
know you could try to SLC and frankly I

46
00:04:22,740 --> 00:04:26,210
don't care if you're measuring yourself
against other organizations were doing

47
00:04:26,210 --> 00:04:31,190
stuff that doesn't work that doesn't
help there are projects like absence or

48
00:04:31,190 --> 00:04:35,360
any sappy out there to try to help
organizations build apps that detect

49
00:04:35,360 --> 00:04:40,200
attacks and block them but that hasn't
worked either really that they're not

50
00:04:40,200 --> 00:04:45,570
widely adopted country words although I
think they're great for the other

51
00:04:45,570 --> 00:04:49,750
approaches really to try to add on
security to application like block ad

52
00:04:49,750 --> 00:04:52,910
blocking on the outside a perimeter
device not just say you know that that

53
00:04:52,910 --> 00:04:58,940
is never going to work either it's very
difficult to defend applications without

54
00:04:58,940 --> 00:05:03,469
the context of what's going on inside
the application but there is a third

55
00:05:03,470 --> 00:05:09,880
option and monitor what he threw that in
this talk I'm gonna start by introducing

56
00:05:09,880 --> 00:05:16,540
this this is a Raspberry Pi anybody
later and I'm gonna be in the settlement

57
00:05:16,540 --> 00:05:19,840
walk out of my boxer second so this a
Raspberry Pi 0

58
00:05:19,840 --> 00:05:26,349
just passed round it's a $5 computer and
its amazing this once in a case but you

59
00:05:26,350 --> 00:05:32,419
can open up that thing but I got my kids
from Raspberry Pi zeros for Christmas

60
00:05:32,419 --> 00:05:35,109
Kothari fun to teach them some
electronics and play around with them

61
00:05:35,110 --> 00:05:40,570
and it's awesome and then I thought hey
what would happen if I put out of

62
00:05:40,570 --> 00:05:45,090
honorable application on this and
protected it with rest so I did that it

63
00:05:45,090 --> 00:05:50,599
put a vulnerable application on here is
really quite good and I put a recipe

64
00:05:50,600 --> 00:05:55,260
tonight it to protect it then I wired it
up so that if there's

65
00:05:55,260 --> 00:05:59,409
you know if detective older but this is
a power supply by the way to the battery

66
00:05:59,410 --> 00:06:03,310
this is the actual computer it's got
wireless connecting back to my computer

67
00:06:03,310 --> 00:06:09,860
here but if it detects a vulnerability
it lights up yellow if it blocks and

68
00:06:09,860 --> 00:06:13,610
attack it lights up green if it detects
an effective attack you later blue and

69
00:06:13,610 --> 00:06:17,870
then if it's a Tekkit exploited it
lights up red and the only reason that

70
00:06:17,870 --> 00:06:23,490
something would get exploited is if the
rest is set to log mode right then you

71
00:06:23,490 --> 00:06:26,790
get an alert that it was it was
exploited but it didn't actually block

72
00:06:26,790 --> 00:06:31,870
attack so we demonstrate this accident
presentation and I'm gonna demonstrate

73
00:06:31,870 --> 00:06:40,280
this so here's a simple application that
running on this pie and over the edge

74
00:06:40,280 --> 00:06:44,400
here this year this works see the lights
at all

75
00:06:44,400 --> 00:06:51,320
alright well we'll see so I'm gonna put
in some some garbage data foo bar zoo

76
00:06:51,320 --> 00:06:57,650
here to submit this you can see it it
detects 3 vulnerabilities in this

77
00:06:57,650 --> 00:07:01,030
application right noticed that we
detected vulnerabilities without

78
00:07:01,030 --> 00:07:08,000
exploiting them that's something that I
asked him raskin do and the three

79
00:07:08,000 --> 00:07:11,000
vulnerabilities are crossing scripting
sequel injection and weak encryption

80
00:07:11,000 --> 00:07:15,610
that this page happens to have it you
can see there's an encrypted token there

81
00:07:15,610 --> 00:07:21,240
so let's try attacking this thing will
opportunistic injection attack so

82
00:07:21,240 --> 00:07:30,060
putting food single too or one equals 1
and submit this and we get a warning to

83
00:07:30,060 --> 00:07:35,840
cost you met here so the rest agent
identified this attack in real time

84
00:07:35,840 --> 00:07:40,780
blocked it and defend this and you know
it also detected the vulnerabilities as

85
00:07:40,780 --> 00:07:41,950
well

86
00:07:41,950 --> 00:07:47,450
are trying to take that won't work here
this authentication token is encrypted

87
00:07:47,450 --> 00:07:52,159
it goes into the database but only after
his been encrypted so when

88
00:07:52,160 --> 00:08:03,280
when we put this in the agent or so this
one get encrypted before it's what rasp

89
00:08:03,280 --> 00:08:08,859
would identify as a in effective attack
right cause the data is encrypted before

90
00:08:08,860 --> 00:08:13,120
it went into the query so it's not an
effective attack and then I've got a

91
00:08:13,120 --> 00:08:18,050
path injection floor here the
vulnerability is just you know reading

92
00:08:18,050 --> 00:08:28,260
from an untrusted source so what kind of
attacks were put in here but this lets

93
00:08:28,260 --> 00:08:32,439
you request a file and it prints the
contents of that file so if you are

94
00:08:32,440 --> 00:08:37,539
attacking this what would you go for ok
good chillaz do that so let's go . US

95
00:08:37,539 --> 00:08:50,850
sees / password and this one I have the
defense turned to launch mode so you see

96
00:08:50,850 --> 00:08:56,100
we got a really the point I'm trying to
make here is that rest is incredibly

97
00:08:56,100 --> 00:09:02,350
powerful it can apply to any application
at any size small

98
00:09:02,350 --> 00:09:06,740
all the way up to the largest enterprise
application it can build defenses in so

99
00:09:06,740 --> 00:09:16,630
we're gonna do now so I tell you how
that actually happens so instrumentation

100
00:09:16,630 --> 00:09:23,000
is really powerful idea it applies to
basically anything that complicated you

101
00:09:23,000 --> 00:09:29,630
can build instrumentation into it so
that it can monitor itself or affect the

102
00:09:29,630 --> 00:09:33,200
behavior of the thing so industrial
factories have this you monitor

103
00:09:33,200 --> 00:09:37,560
temperature and sound and vibration and
all sorts of stuff and it's really

104
00:09:37,560 --> 00:09:41,969
critical to running a complex operation
will our software is probably the most

105
00:09:41,970 --> 00:09:46,830
complex thing that ever been created by
man and we need to instrument in order

106
00:09:46,830 --> 00:09:51,100
to monitor how it behaves but we don't
write there's almost no instrumentation

107
00:09:51,100 --> 00:09:59,450
built into most applications so rasp is
basically instrumentation for security

108
00:09:59,450 --> 00:10:01,329
purposes right

109
00:10:01,329 --> 00:10:04,479
and there's a few kinds of
instrumentation the simplest kind is

110
00:10:04,480 --> 00:10:09,439
just instrument in the source code so
this is an example of adding some code

111
00:10:09,439 --> 00:10:16,519
to the MySQL JDBC implementation right
to go to the methods that would be

112
00:10:16,519 --> 00:10:19,869
susceptible to sequel injection and you
can weave in a couple of lines of code

113
00:10:19,869 --> 00:10:24,769
that I hate warn me if anybody uses this
API in this case gimme the whole stack

114
00:10:24,769 --> 00:10:30,069
trace I can see where it got called from
and if you added this to your database

115
00:10:30,069 --> 00:10:35,319
drivers and then push that out as per
your standard application stack in a

116
00:10:35,319 --> 00:10:39,699
matter of hours or days you could go
everywhere in your company where you're

117
00:10:39,699 --> 00:10:43,959
potentially susceptible to seek
rejection of the problem with this is

118
00:10:43,959 --> 00:10:47,579
that it's not very accurate right you
get a lot of places that are vulnerable

119
00:10:47,579 --> 00:10:51,388
the sequel injection this is a simple
example to try to give you get you

120
00:10:51,389 --> 00:10:55,670
understand how instrumentation work so
this is just a simple static method call

121
00:10:55,670 --> 00:10:59,829
very safe doesn't affect the application
at all just gathers a little bit of data

122
00:10:59,829 --> 00:11:05,309
and reports it to you that's doing it in
the source code recompiling redeploy

123
00:11:05,309 --> 00:11:10,189
that you can also do binary
instrumentation so there are a lot of

124
00:11:10,189 --> 00:11:15,799
tools for this out there things Lake ASM
and be so because actually built into

125
00:11:15,799 --> 00:11:18,999
the Java Virtual Machine there's one
for.net in other languages

126
00:11:20,209 --> 00:11:23,929
this is usually widely for measuring
performance like a memory use

127
00:11:24,520 --> 00:11:29,170
and bottlenecks and things like that
companies like New Relic and dynamics

128
00:11:29,170 --> 00:11:33,540
use this for performance monitoring
she's to weave an extra logging into

129
00:11:33,540 --> 00:11:37,990
applications proven technology very safe
and you're almost certainly using this

130
00:11:37,990 --> 00:11:42,430
already in your enterprises because it's
built into tons of libraries like

131
00:11:42,430 --> 00:11:49,439
dependency injection librarian and so on
so on instrumentation weaves those same

132
00:11:49,440 --> 00:11:52,050
changes in it just does it into the
bytecode rate so then you've got

133
00:11:52,050 --> 00:11:56,349
modified jar file the benefit is that
you don't have to change the way your

134
00:11:56,350 --> 00:12:00,790
building and testing your source code
you just we've in these changes later so

135
00:12:00,790 --> 00:12:06,829
then the next level of this is dynamic
binary instrumentation so this happened

136
00:12:06,830 --> 00:12:10,610
at runtime in this is where the runtime
part of runtime application

137
00:12:10,610 --> 00:12:14,790
self-protection comes from this
instrumentation happens as the

138
00:12:14,790 --> 00:12:20,589
application runs so you see here the
binary code from your disk gets loaded

139
00:12:20,590 --> 00:12:28,060
into memory and you can hook that
process to modify those buns to do the

140
00:12:28,060 --> 00:12:31,989
instrumentation on the spiders as
they're loaded into memory again it's

141
00:12:31,990 --> 00:12:35,780
the same instrumentation libraries and
so is still very safe it's just done as

142
00:12:35,780 --> 00:12:40,189
the code gets loaded and in Java you can
use the Java instrumentation API for

143
00:12:40,190 --> 00:12:45,540
this indictment you can use the profiler
API is for this most modern platforms

144
00:12:45,540 --> 00:12:50,230
have a way of doing this and it's really
powerful it allows you to weave in

145
00:12:50,230 --> 00:12:55,680
security sensors and actuators into your
applications so that now you instrument

146
00:12:55,680 --> 00:13:01,420
all your code for the things that you
want and because its dynamic you really

147
00:13:01,420 --> 00:13:05,030
don't have to change the way that you
build test and deploy your code at all

148
00:13:05,030 --> 00:13:08,300
you just deployed the normal way and
though this instrumentation happens at

149
00:13:08,300 --> 00:13:15,430
runtime so that's the essential
ingredients for rest now the question is

150
00:13:15,430 --> 00:13:21,469
what do we instrument in well grasp the
way I think of it is rasp starts with a

151
00:13:21,470 --> 00:13:25,900
sort of ordinary insecure application of
the naive application that most of us

152
00:13:25,900 --> 00:13:32,060
right and at runtime as the application
loads rasp weaves in

153
00:13:32,060 --> 00:13:36,739
in new security capabilities into your
application and really there's not any

154
00:13:36,740 --> 00:13:40,390
limit to what can we even gonna talk
about some of the things that rest does

155
00:13:40,390 --> 00:13:45,610
today but the future for this is really
very bright very excited about what we

156
00:13:45,610 --> 00:13:50,440
can do with this but once you do this
then the application is self protecting

157
00:13:50,440 --> 00:13:55,290
right and that protection goes with the
application wherever you deploy this

158
00:13:55,290 --> 00:13:59,930
application and and the rest Beijing the
protection goes with it right so you can

159
00:13:59,930 --> 00:14:03,939
move it from your internal network to
your external and internal external but

160
00:14:03,940 --> 00:14:06,990
moving head onto the internet moving
into the cloud moved into container

161
00:14:06,990 --> 00:14:11,390
doesn't matter wherever the girls with
the application itself protecting from

162
00:14:11,390 --> 00:14:18,830
that point so here's what we weave in
sensors are basically passive called

163
00:14:18,830 --> 00:14:22,400
acts like the one that I should in them
I sequel driver to just gather some

164
00:14:22,400 --> 00:14:26,060
information from your running
application you might want to gather

165
00:14:26,060 --> 00:14:31,930
information about the things that you
are securely relevant right you might

166
00:14:31,930 --> 00:14:38,329
gather data from what we call sources
like request I get parameter 1 to know

167
00:14:38,330 --> 00:14:43,030
where those calls are made or sinks Lake
the sequel one we saw your ex assessing

168
00:14:43,030 --> 00:14:49,300
sore XXII traditional vulnerabilities
anything related to that kind of stuff

169
00:14:49,300 --> 00:14:52,510
you might want to gather data from the
HttpRequest

170
00:14:52,510 --> 00:14:57,290
together data from the the the
configuration files anything that the

171
00:14:57,290 --> 00:15:01,890
application has access to
instrumentation can put a sensor on it

172
00:15:01,890 --> 00:15:06,030
and gather that and make it part of your
security announces this is what I mean

173
00:15:06,030 --> 00:15:10,370
by context if you want to identify
vulnerabilities and attacks accurately

174
00:15:10,370 --> 00:15:15,260
gotta have that context from the running
application so the other thing that we

175
00:15:15,260 --> 00:15:19,390
we've got a call actuators these are
active callbacks that allow the

176
00:15:19,390 --> 00:15:22,670
applicant would allow the interpretation
to do something within the application

177
00:15:22,670 --> 00:15:28,870
link blocker request or add logging or
added security header to HttpResponse

178
00:15:28,870 --> 00:15:33,320
those kinds of things can also be done
with instrumentation so we got sensors

179
00:15:33,320 --> 00:15:38,090
and actuators the agent handles them in
then the feedback goes back to the agent

180
00:15:38,090 --> 00:15:41,580
rates on the centers run they provide
data to the age of

181
00:15:41,580 --> 00:15:45,660
nation can communicate that out to see
it a central console somewhere you know

182
00:15:45,660 --> 00:15:49,050
server command and control purposes with
me so far

183
00:15:50,660 --> 00:15:55,689
oK so that's instrumentation is very
powerful I think I mentioned a lot of

184
00:15:55,690 --> 00:16:00,210
these things one thing that i think is
interested in mention was that secret

185
00:16:00,210 --> 00:16:05,030
instrumentation can access all the code
the binary code itself so we can do

186
00:16:05,030 --> 00:16:10,160
things like static analysis for certain
kinds of vulnerabilities it also has

187
00:16:10,160 --> 00:16:15,120
access to all the libraries and
frameworks in the application and

188
00:16:15,120 --> 00:16:19,740
exactly how they're used by the
application and so we've been doing some

189
00:16:19,740 --> 00:16:25,880
analysis of this it's actually pretty
interesting only about seven percent of

190
00:16:25,880 --> 00:16:32,760
the library code in your application
ever actually gets used most of it is

191
00:16:32,760 --> 00:16:38,090
there you know because of compile time
dependencies or extra methods in in

192
00:16:38,090 --> 00:16:41,820
libraries that you're not using but you
know people talk about insecure

193
00:16:41,820 --> 00:16:46,960
libraries we added it is a 92 those top
10 but until you really study what's

194
00:16:46,960 --> 00:16:50,350
actually happening in your application
you could be fixing or replacing

195
00:16:50,350 --> 00:16:58,080
libraries that you're never even using
spent a lot of time on that so in a way

196
00:16:58,870 --> 00:17:02,670
security instrumentation can provide a
lot of the benefit of static analysis

197
00:17:02,670 --> 00:17:07,000
and dynamic analysis and things like wax
and ideas

198
00:17:07,000 --> 00:17:11,390
IPs and all deliver it through an agent
inside the application where it can

199
00:17:11,390 --> 00:17:19,650
happen so he's a little interesting sort
of data visualization here this is an

200
00:17:19,650 --> 00:17:25,100
XSS in a spring outfits incredibly
simple exercise right just a few lines

201
00:17:25,099 --> 00:17:30,199
of code that introduced this but what it
shows is what I call a cluster bomb

202
00:17:30,200 --> 00:17:35,360
effect of string handling in most modern
foreign words so when a string comes

203
00:17:35,360 --> 00:17:40,090
into your application as part of an HTTP
request for instance strings are

204
00:17:40,090 --> 00:17:42,449
immutable in languages like time

205
00:17:42,450 --> 00:17:47,549
Java so every time you add something to
a string or split a string into pieces

206
00:17:47,549 --> 00:17:52,210
you're really creating new streaks and
then they get processed and so when you

207
00:17:52,210 --> 00:17:55,679
know I think of it like a cluster bomb
right thing comes in its explodes into a

208
00:17:55,679 --> 00:17:59,110
bunch of parts and then each of those
practiced processing along and explodes

209
00:17:59,110 --> 00:18:03,309
into a bunch more parts and they're all
potential attack vectors all of those

210
00:18:03,309 --> 00:18:07,408
string parts so what this does is
essentially trace you can see the HTTP

211
00:18:07,409 --> 00:18:11,169
request down here at the bottom right
and then it traces the flow all the way

212
00:18:11,169 --> 00:18:14,679
through all those little pieces of the
cluster bomb end up in the application

213
00:18:14,679 --> 00:18:20,299
and the reason I mention this is if you
want to analyze the security behavior of

214
00:18:20,299 --> 00:18:25,039
an application you have to be able to
see this level of detail is very

215
00:18:25,039 --> 00:18:30,500
difficult to generate any other way than
watching the Apple application run it's

216
00:18:30,500 --> 00:18:33,539
invisible in the source code for
instance very difficult to sort of

217
00:18:33,539 --> 00:18:42,120
reverse engineer this and understand it
so here's how r ask my block a attack so

218
00:18:42,120 --> 00:18:46,459
let's imagine the attacker over here
sends an HTTP request with a sequin

219
00:18:46,460 --> 00:18:51,360
Jackson attack it like I just did on the
little Raspberry Pi thing here the

220
00:18:51,360 --> 00:18:57,320
attack comes in and there will be some
some sensors in the controller tells hey

221
00:18:57,320 --> 00:19:01,549
a new HTTP request came in sort of add
that to our security context down here

222
00:19:01,549 --> 00:19:04,629
as part of the agent and then as we go
through the processing of the

223
00:19:04,630 --> 00:19:09,440
application different events will fire
things that we've instrumented will fire

224
00:19:09,440 --> 00:19:13,510
events and add them to the security
context so we can see hey here's how the

225
00:19:13,510 --> 00:19:15,450
state of fluid through the application

226
00:19:15,450 --> 00:19:19,950
here's the validation and encoding that
went on on that data and we just track

227
00:19:19,950 --> 00:19:25,149
that all the way through eventually in
this case that data Enza in a sequel

228
00:19:25,149 --> 00:19:30,889
query right we finally got to the sequel
API and we we notified the agent hey

229
00:19:30,889 --> 00:19:35,070
here's a new query that's going to the
database will the agent can analyze this

230
00:19:35,070 --> 00:19:36,470
and say hey you know what

231
00:19:36,470 --> 00:19:41,340
when we look at that query and we see
exactly where the attackers data fit

232
00:19:41,340 --> 00:19:47,059
into that query when we analyze it that
that attacker was able to change the

233
00:19:47,059 --> 00:19:53,230
meaning of that query with a change in
the quarry modified the meaning meaning

234
00:19:53,230 --> 00:19:53,779
that it's an

235
00:19:53,779 --> 00:19:57,749
attack so then we know for sure that
it's an attack in this was really the

236
00:19:57,749 --> 00:20:03,309
difference between sort of perimeter
defenses and rest is the rest has inside

237
00:20:03,309 --> 00:20:04,690
access to what's going on

238
00:20:04,690 --> 00:20:09,929
it has all the context so it's extremely
accurate when it identifies attacks and

239
00:20:09,929 --> 00:20:13,539
in this case it can block the attacks
like a shadow on this thing you can do

240
00:20:13,539 --> 00:20:18,070
whatever you want the application to do
in that case a warning or call the

241
00:20:18,070 --> 00:20:22,289
police or if you want to do if you're
actually being attacked this is the

242
00:20:22,289 --> 00:20:32,219
essence of being a shelf protecting
application so I wanted to compare and

243
00:20:32,219 --> 00:20:38,999
raspy and yes raskin block attacks like
aware but I don't really like that

244
00:20:38,999 --> 00:20:44,739
comparison because I'm gonna explain rap
is really much broader than just the

245
00:20:44,739 --> 00:20:51,559
weft use case in this case I think
there's some advantages to rest so

246
00:20:51,559 --> 00:20:55,259
really there's three problems with the
first one is that Western bottleneck

247
00:20:55,259 --> 00:21:00,799
right if you've got a whole bunch of
users through one wow and support a

248
00:21:00,799 --> 00:21:04,849
bunch of applications then as the load
goes up the performance penalties gonna

249
00:21:04,849 --> 00:21:06,309
increase on the web

250
00:21:06,309 --> 00:21:11,039
rasp is distributed so every application
protects itself every instance of every

251
00:21:11,039 --> 00:21:15,149
application protects itself so the
defense is done in a distributed fashion

252
00:21:15,149 --> 00:21:23,518
you don't need any extra box to do this
thing is we have no context rates when

253
00:21:23,519 --> 00:21:29,219
they see the attack all they see is you
know or want equals one on the wire that

254
00:21:29,219 --> 00:21:33,450
might be an attack but it absolutely
might not be an attack I know in the

255
00:21:33,450 --> 00:21:34,179
past

256
00:21:34,179 --> 00:21:38,739
somewhere frauds that just blocked every
request that had the word selected it a

257
00:21:38,739 --> 00:21:42,899
problem if you're writing an email
message board selected it gets black

258
00:21:42,899 --> 00:21:47,369
they don't have enough context to
accurately block and so that's why you

259
00:21:47,369 --> 00:21:50,320
know if you have a wealth you probably
also have a bunch of people that are

260
00:21:50,320 --> 00:21:53,019
managing the rules on that we're
updating it every time the application

261
00:21:53,019 --> 00:21:58,149
changes rest doesn't have that problem
and the last thing is something called

262
00:21:58,149 --> 00:22:00,500
the impedance mismatch problem

263
00:22:00,500 --> 00:22:07,100
familiar with impedance mismatch get the
idea here is that the data on the wire

264
00:22:07,100 --> 00:22:14,100
might be encoded in a bunch of different
ways that the application sees

265
00:22:14,100 --> 00:22:17,360
differently right by the time they get
the data gets up through the stack into

266
00:22:17,360 --> 00:22:21,719
the application in might have indicated
in a bunch of interesting ways rasp use

267
00:22:21,720 --> 00:22:26,180
the data the same way that the
application sees it right so it's it

268
00:22:26,180 --> 00:22:29,540
doesn't have to have a separate set of
decoders and train guess the way the

269
00:22:29,540 --> 00:22:33,710
application stack is going to decode it
it's gonna actually used the same data

270
00:22:33,710 --> 00:22:43,900
that the the application is using so it
solves that problem manager for asking

271
00:22:43,900 --> 00:22:46,900
is that it can question

272
00:22:56,020 --> 00:22:59,900
for just a sec ago sliding performance
in just a second ok I got some numbers

273
00:22:59,900 --> 00:23:07,830
so I wanna get your question but let's
just wait so protecting services is

274
00:23:07,830 --> 00:23:11,909
really difficult I we see a lot of
development going on in services and

275
00:23:11,910 --> 00:23:17,520
API's all your mobile apps connect back
to a service lot of even regular web

276
00:23:17,520 --> 00:23:21,220
apps these days they're really just
JavaScript friends that connect back to

277
00:23:21,220 --> 00:23:27,060
services so securing services is really
important problem is that I just had a

278
00:23:27,060 --> 00:23:34,389
talk at last con about how well set and
death support web services and the

279
00:23:34,390 --> 00:23:41,670
results are pretty shocking they don't
really work on services also work on

280
00:23:41,670 --> 00:23:47,150
services and services really hard to
understand the syntax of a more complex

281
00:23:47,150 --> 00:23:49,000
API like that

282
00:23:49,000 --> 00:23:53,110
rest is another problem inside the
application so to rest

283
00:23:53,680 --> 00:23:58,640
JSON request or XML request it looks
basically the same right

284
00:23:58,640 --> 00:24:02,460
rest tracked the data from XML file
interaction through the application

285
00:24:02,460 --> 00:24:06,540
where it goes it can identify
vulnerabilities and attacks the same way

286
00:24:06,540 --> 00:24:15,680
that it does for regular HTTP requests
so here's the performance slide right so

287
00:24:15,680 --> 00:24:19,900
hopefully I address some of your
questions so rest is really fantastic

288
00:24:19,900 --> 00:24:26,560
for performance in my opinion typical
processing on web good we used as an

289
00:24:26,560 --> 00:24:34,190
example we loaded it up and rest pads 50
microseconds for normal traffic that's

290
00:24:34,190 --> 00:24:42,660
twentieth of a millisecond per round
trip request so probably faster than if

291
00:24:42,660 --> 00:24:47,910
the developer had written validation
into the application rest was really

292
00:24:47,910 --> 00:24:52,170
really fast because it's it's really
relying on a lot of work that the

293
00:24:52,170 --> 00:24:56,500
application platform is already done
right if you do this in a way if you've

294
00:24:56,500 --> 00:25:01,600
got a receive all the parts of the HTTP
request you know assemble the TCP stream

295
00:25:01,600 --> 00:25:02,090
in there

296
00:25:02,090 --> 00:25:07,750
walking up the staff parse the HTTP
request and then send back out on the

297
00:25:07,750 --> 00:25:12,789
wires haha rest is another problem it's
just straighten were using the data

298
00:25:12,789 --> 00:25:18,379
exactly from the API's that the
application is using so with mixed

299
00:25:18,380 --> 00:25:21,590
traffic that sorta like half and half at
a click a medium level attack

300
00:25:22,970 --> 00:25:26,409
270 microseconds and even really heavy
attack traffic

301
00:25:27,010 --> 00:25:33,590
203 microseconds so cordova milliseconds
really really fast performance here

302
00:25:33,590 --> 00:25:36,590
insert help answer your question

303
00:25:38,080 --> 00:25:43,110
ok good yes there is a penalty
absolutely but I think it's important to

304
00:25:43,110 --> 00:25:46,870
understand the rest was really efficient
and it does it in the way they you know

305
00:25:46,870 --> 00:25:50,799
your code or should have done it if they
have it in the attack detection and

306
00:25:50,799 --> 00:25:59,360
prevention into the application itself I
just another thing on sort of scaling

307
00:25:59,360 --> 00:26:03,149
and performances that works on
applications of any size you know I

308
00:26:03,149 --> 00:26:08,299
demoed on tiny little application here
but we've used it on applications that

309
00:26:08,299 --> 00:26:12,010
are twenty million lines of code because
it's just sort of woven into the

310
00:26:12,010 --> 00:26:16,049
application as part of the
infrastructure it doesn't add a lot in

311
00:26:16,049 --> 00:26:22,450
terms of performance and even a very
large application ok so what to talk

312
00:26:22,450 --> 00:26:29,909
about the Java deserialization flaws in
very familiar with this is for recent

313
00:26:29,909 --> 00:26:35,740
attacks the folks I think this really
interesting right so many applications

314
00:26:35,740 --> 00:26:42,750
use serialized objects to communicate
between client and server and basically

315
00:26:42,750 --> 00:26:47,909
this application is waiting for a DS
serialized object to come in and when it

316
00:26:47,909 --> 00:26:50,539
comes in it's going to deserialize that
it's got a couple of fields the

317
00:26:50,539 --> 00:26:56,320
mean-field in the record I D and the
owner and what's really important is the

318
00:26:56,320 --> 00:27:01,510
type here so the way that the person
works is

319
00:27:02,440 --> 00:27:07,009
Java accept these objects and then looks
in the stream for what type of object to

320
00:27:07,009 --> 00:27:10,970
deserialize this into well that's a
problem because nearly got the bad guy

321
00:27:10,970 --> 00:27:15,629
over here and he creates his own
serialized object there's a tool called

322
00:27:15,629 --> 00:27:22,820
why so cereal like why so serious why so
serious that will create these militias

323
00:27:22,820 --> 00:27:28,649
serialized objects and in this case he's
using a gadget called Acme internal type

324
00:27:28,649 --> 00:27:34,059
and you can use any type that you want
that's available in the target platform

325
00:27:34,059 --> 00:27:39,509
in the you know the platform of the
target application because of the

326
00:27:39,509 --> 00:27:43,740
explosion libraries that have happened
over the last ten years or so those

327
00:27:43,740 --> 00:27:47,909
papers are incredibly rich there's huge
numbers of classes available that the

328
00:27:47,909 --> 00:27:53,850
attacker can try to misuse and so
there's a number of these gadgets that

329
00:27:53,850 --> 00:28:00,689
actually take data and then turn it into
running code so in this case you can see

330
00:28:00,690 --> 00:28:05,019
he's found one called at me internal
type that has some some data objects in

331
00:28:05,019 --> 00:28:10,299
the juggling runtime that's the object
the method to invoke and the command to

332
00:28:10,299 --> 00:28:15,779
pass into that method so now what
happens is when the attacker sends that

333
00:28:15,779 --> 00:28:20,750
malicious object to the vulnerable
application it deserialize it creates an

334
00:28:20,750 --> 00:28:28,690
instance of this acne internal type and
importantly it calls the constructor on

335
00:28:28,690 --> 00:28:32,809
this object rates invokes the
constructor which is now the state has

336
00:28:32,809 --> 00:28:37,590
been filled in and if that constructor
invokes the method here if your

337
00:28:37,590 --> 00:28:44,860
reflection then this command will run
and probably calculator whatever you

338
00:28:44,860 --> 00:28:48,529
gonna do right so this is a really
powerful attack and it turns out that

339
00:28:48,529 --> 00:28:53,720
these deserialize she realized object
interfaces are pretty common so there

340
00:28:53,720 --> 00:28:59,370
are a bunch of major products that take
destroys objects articulated objects and

341
00:28:59,370 --> 00:29:04,629
are vulnerable to this the challenges
it's really hard to find these in your

342
00:29:04,629 --> 00:29:08,809
portfolio like you might get five
hundred applications are you gonna go

343
00:29:08,809 --> 00:29:13,809
find all the places where you accept
untrusted data and try to deserialize it

344
00:29:14,580 --> 00:29:20,480
it's tricky cuz it's all custom code
everywhere so we actually released a

345
00:29:20,480 --> 00:29:26,059
open source rest agent for this and
Rasmus really uniquely well-suited to

346
00:29:26,059 --> 00:29:34,370
deal with this problem so what this
country is true or zero or because the

347
00:29:34,370 --> 00:29:39,860
at every job is serialized object if you
base 64 encoded it starts out with the

348
00:29:39,860 --> 00:29:44,979
letters are as you're okay so that's why
its name but what the rest of engine

349
00:29:44,980 --> 00:29:50,260
does is you can just deployed on your
application stack and it looks into the

350
00:29:50,260 --> 00:29:55,929
decentralisation process and looks at
the objects that are trying to be

351
00:29:55,929 --> 00:30:01,159
serialized if they're on the blacklist
which it comes with then they get

352
00:30:01,159 --> 00:30:04,840
blocked you can change over Norway list
which would be better if you know that

353
00:30:04,840 --> 00:30:09,908
your destroys the picture only gonna be
instances of string in vector and stuff

354
00:30:09,909 --> 00:30:14,490
like that then that's a little safer way
to go but we'll keep that list up to

355
00:30:14,490 --> 00:30:19,820
date but you could add this to your
stack and prevent visualization attacks

356
00:30:19,820 --> 00:30:30,490
everywhere in your enterprise really
easily ok so let's assume a little bit

357
00:30:30,490 --> 00:30:35,200
right so I want you to think about rest
now we're going to the other end of the

358
00:30:35,200 --> 00:30:39,610
spectrum I started really small number
get really big ok so you don't imagine

359
00:30:39,610 --> 00:30:45,510
dressed as a security API into your
applications right so imagine that you

360
00:30:45,510 --> 00:30:51,149
had a way of connecting with your
applications and adding monitoring

361
00:30:51,149 --> 00:30:58,399
adding policy enforcement to your
applications dynamically so here you can

362
00:30:58,399 --> 00:31:01,479
imagine let's say you want to know all
the places in your enterprise were you

363
00:31:01,480 --> 00:31:06,419
using single death there might be
something interesting to know right well

364
00:31:06,419 --> 00:31:10,240
with raspy if you deploy or a speech in
as part of your standard application

365
00:31:10,240 --> 00:31:15,250
step now you have that capability and
you can ask your application portfolio

366
00:31:15,250 --> 00:31:18,190
hey who's winning single this out there
and get

367
00:31:18,190 --> 00:31:23,460
back back on that never had this
capability before right you can do

368
00:31:23,460 --> 00:31:30,690
things Lake user asked to turn off XML
doctype processing if you do that in all

369
00:31:30,690 --> 00:31:35,049
your XML parsers everywhere throughout
your organization just defeated XXII

370
00:31:35,049 --> 00:31:41,279
everywhere right that's powerful maybe
one asset Xtreme options on every

371
00:31:41,279 --> 00:31:46,049
HttpResponse that goes out you could do
it with a wealth but if you really

372
00:31:46,049 --> 00:31:51,500
painful this is a fast way to do it from
within the application themselves things

373
00:31:51,500 --> 00:31:56,289
like this like adding a header 40
performance hit right that's a

374
00:31:56,289 --> 00:32:02,210
instantaneous call that a single header
to an HttpResponse so you can make a

375
00:32:02,210 --> 00:32:06,940
solid protection against clickjacking
everywhere in your application portfolio

376
00:32:06,940 --> 00:32:12,059
really quickly and a bunch of other use
cases like you can imagine

377
00:32:12,059 --> 00:32:18,200
basically doing anything from a security
perspective so I sort of think of rasp

378
00:32:18,200 --> 00:32:24,970
as an adapter that we have never had
insecurity 22 nowhere applications are

379
00:32:24,970 --> 00:32:30,490
what's in them what vulnerabilities they
might have what protections we might

380
00:32:30,490 --> 00:32:38,070
want to put in place so if you think
about it it's actually establishing will

381
00:32:38,070 --> 00:32:42,960
call an absolute control plane and
there's been in the networked world has

382
00:32:42,960 --> 00:32:45,210
been network control planes for a long
time

383
00:32:45,210 --> 00:32:48,350
rate you have a single place where you
can go to control endpoint protection

384
00:32:48,350 --> 00:32:52,168
and firewall things like that we have
their visibility on the network clear

385
00:32:52,169 --> 00:32:56,529
but right now our applications are out
there in the wild wild west are you have

386
00:32:56,529 --> 00:32:59,529
no way to communicate with them to it
and what they're doing

387
00:33:00,279 --> 00:33:05,919
raskin established this security control
plane pusher enterprise and that's

388
00:33:05,919 --> 00:33:11,029
really doing application security a
DevOps speed and portfolio scale right

389
00:33:11,029 --> 00:33:17,289
this is all real time so I want you to
think for a second about what would

390
00:33:17,289 --> 00:33:22,840
happen if another deserialization bug
came out tomorrow right how long would

391
00:33:22,840 --> 00:33:27,889
it take you to protect your enterprise
against that flaw what would you do

392
00:33:28,460 --> 00:33:29,309
would you start

393
00:33:29,309 --> 00:33:34,289
refine it with static to go run through
all your whole portfolio with your

394
00:33:34,289 --> 00:33:39,940
second else's story that could be years
and then you have to go fix it and there

395
00:33:39,940 --> 00:33:43,360
could be another one the next day rates
we need to be we need to change our

396
00:33:43,360 --> 00:33:48,709
response paradigm from years nouveau her
please

397
00:33:48,710 --> 00:33:53,909
two minutes right and we can do that
it's possible but we need to enable

398
00:33:53,909 --> 00:34:02,049
applications to be self protecting so
one other point that i think is

399
00:34:02,049 --> 00:34:08,619
interesting here is the rasp enabled
application can move once you've set up

400
00:34:08,619 --> 00:34:13,220
the protection and you have centralized
control over policy it doesn't matter

401
00:34:13,219 --> 00:34:16,459
where your application is deployed
you've got it on your internal network

402
00:34:16,460 --> 00:34:22,159
and you've got restful said you can move
that applications to the cloud and the

403
00:34:22,159 --> 00:34:25,800
same policies apply or you could apply
different set of policies for things

404
00:34:25,800 --> 00:34:30,119
that are deployed in the clout and I
think that's really powerful because

405
00:34:30,119 --> 00:34:38,819
applications due to these things are
possible today we can weave these kind

406
00:34:38,819 --> 00:34:43,750
of capabilities into applications things
Lake attack detection and prevention

407
00:34:43,750 --> 00:34:50,730
community control over applications even
simple things like just figuring out

408
00:34:50,730 --> 00:34:55,060
what's in your application inventory out
there that identification problem is

409
00:34:55,060 --> 00:35:00,160
huge for some companies but if you build
rest into your application stack then

410
00:35:00,160 --> 00:35:04,520
you've turned application security
inside out I know but you work for

411
00:35:04,520 --> 00:35:09,069
absolute groups and you've gotta go out
to each development team as they please

412
00:35:09,069 --> 00:35:14,390
can we test your application that's a
painting with Reggie turn that

413
00:35:14,390 --> 00:35:18,040
relationship inside out right now the
information is coming to you so you know

414
00:35:18,040 --> 00:35:22,190
where the applications are you know
what's in them the basic architecture

415
00:35:22,190 --> 00:35:23,079
and

416
00:35:23,079 --> 00:35:28,880
you can move on from there virtual
patching is really powerful if a new

417
00:35:28,880 --> 00:35:33,359
attack comes down it's easy to deploy
that kind of virtual patching that's the

418
00:35:33,359 --> 00:35:38,709
case that I always liked about wax is
that if there's a new attack that's

419
00:35:38,709 --> 00:35:42,719
really dangerous you could push out of
virtual patch to block that attack based

420
00:35:42,719 --> 00:35:46,969
on some signature very quickly across
the infrastructure that's a use case

421
00:35:46,969 --> 00:35:51,519
that every application needs because
there's gonna be another attack tomorrow

422
00:35:51,519 --> 00:35:55,689
that nobody's ever thought of before and
you're gonna protect your hopefully it's

423
00:35:55,690 --> 00:35:59,940
just a pain to do it with West rate this
can do it's centrally push that virtual

424
00:35:59,940 --> 00:36:03,059
patch out quickly and then you can
figure out what to do with it in your

425
00:36:03,059 --> 00:36:04,059
leisure

426
00:36:04,059 --> 00:36:09,279
we've done this with libraries as well
so if there's a new CD comes out on

427
00:36:09,279 --> 00:36:14,690
strikes or spring or something you can
push out a virtual patch that weaves

428
00:36:14,690 --> 00:36:19,709
itself into the library allows you to
continue operating with that vulnerable

429
00:36:19,709 --> 00:36:23,538
every anybody here still using an old
version of structure spring anywhere in

430
00:36:23,539 --> 00:36:29,069
a press to everyone is cuz it's really
hard to replace it right I had one

431
00:36:29,069 --> 00:36:33,029
client come you see every time there's a
newsprint vulnerability we've gotta go

432
00:36:33,029 --> 00:36:38,849
fix a thousand applications and it costs
ten million dollars to upgrade retest

433
00:36:38,849 --> 00:36:44,979
redeploy and it could happen again
tomorrow so they really love this idea

434
00:36:44,979 --> 00:36:50,910
of weaving in these these virtual
patches into libraries I think the idea

435
00:36:50,910 --> 00:36:54,808
of self self in Pretoria South profiling
is really important cause of so many

436
00:36:54,809 --> 00:36:58,680
applications out there that nobody knows
the really running and even security

437
00:36:58,680 --> 00:37:05,779
locking this has been a challenge for us
for a long time is a major looked at

438
00:37:05,779 --> 00:37:10,489
like 530 really great security
information in there a lot of stack

439
00:37:10,489 --> 00:37:17,359
traces lot of debug information but is a
great security log know but we can weave

440
00:37:17,359 --> 00:37:21,900
that in with rest and improved looks at
you get actually really good logs and

441
00:37:21,900 --> 00:37:25,799
then everything downstream benefits
right take this better logs and feed

442
00:37:25,799 --> 00:37:29,490
them in your sim freedom in your fraud
detection feed them in two years

443
00:37:29,490 --> 00:37:35,169
your sock they can do better job of
identifying attacks across your

444
00:37:35,170 --> 00:37:41,140
enterprise because arrest because we can
make those logs better that's where I

445
00:37:41,140 --> 00:37:47,290
wanted to come here and talk about I
love to take your questions and comments

446
00:37:47,290 --> 00:37:51,840
on anything else actually yeah

447
00:38:04,100 --> 00:38:14,600
just question about the date others
being logged like perhaps it contains

448
00:38:14,600 --> 00:38:19,509
some sensitive information would that be
something that an attacker can leverage

449
00:38:19,510 --> 00:38:26,300
to attack the application itself to
things so you know what specifically

450
00:38:26,300 --> 00:38:31,270
Getzlaf depends on your rest
implementation and most of the stuff the

451
00:38:31,270 --> 00:38:37,160
rest is gonna log like vulnerabilities
and attacks is already sensitive right

452
00:38:37,160 --> 00:38:40,779
foot peg guys knowing where your
vulnerabilities are doing what attacks

453
00:38:40,780 --> 00:38:44,790
were happening on you but it is true you
could end up liking you no user data

454
00:38:44,790 --> 00:38:47,380
like credit card numbers and social
security numbers and so you should

455
00:38:47,380 --> 00:38:51,960
probably have some kind of masking in
your grasp implementation but I'm not

456
00:38:51,960 --> 00:38:55,730
seeing any specific products here I'm
really talk about the class of products

457
00:38:55,730 --> 00:39:02,970
that Israel but I wouldn't recommend you
know just making that raspy data open to

458
00:39:02,970 --> 00:39:08,310
anyone that private that's just you know
if you look at the the control plane

459
00:39:08,310 --> 00:39:14,900
it's like these people up here that have
these people appear that you know have a

460
00:39:14,900 --> 00:39:21,470
reason to know about the application
security information there that's that's

461
00:39:21,470 --> 00:39:23,399
would have access

462
00:39:23,400 --> 00:39:26,400
yeah

463
00:39:28,810 --> 00:39:35,029
product-specific rate and if you're
talking to vendors you should be really

464
00:39:35,030 --> 00:39:38,760
clear about you know what attacks you
care about what vulnerabilities do you

465
00:39:38,760 --> 00:39:45,220
care about and what is the product that
you're using actually work on a variety

466
00:39:45,220 --> 00:39:46,759
of products out there

467
00:39:46,760 --> 00:40:11,830
the different approaches to this so are
communicating and you know again its

468
00:40:11,830 --> 00:40:17,930
product specific but what you're looking
for is a way of visualizing all of that

469
00:40:17,930 --> 00:40:22,669
data in a way that that really is useful
now I believe that bringing

470
00:40:22,670 --> 00:40:27,580
vulnerability data and attack data
together in the same dashboard is really

471
00:40:27,580 --> 00:40:32,140
really useful because it lets your
developers know what's being attacked

472
00:40:32,140 --> 00:40:37,720
which is pretty important information if
they gotta prioritize and it also helps

473
00:40:37,720 --> 00:40:42,759
you know where to you knowing where the
vulnerabilities are will help you know

474
00:40:42,760 --> 00:40:43,240
what

475
00:40:43,240 --> 00:40:47,649
attacks are really important so you know
i think thats sort of an evolution is

476
00:40:47,650 --> 00:40:53,430
we'll see unified dashboards that if you
think about it the history of at SEC is

477
00:40:53,430 --> 00:40:55,609
split between

478
00:40:55,610 --> 00:41:00,400
have an arms race on the debit side
there's pain testers and static analysis

479
00:41:00,400 --> 00:41:05,620
and dashed and encoder viewers and I
spent a lot of my career over on the

480
00:41:05,620 --> 00:41:09,690
side of things finding vulnerabilities
and fixing them and then there's a

481
00:41:09,690 --> 00:41:14,740
totally separate side that's up its
attack blocking the production side of

482
00:41:14,740 --> 00:41:20,500
things where you know you're defying
attacks and blocking them and to me

483
00:41:20,500 --> 00:41:26,130
they're the same problem really I mean
if you think about of reliability it is

484
00:41:26,130 --> 00:41:30,400
like an open window right in an attack
is a guy climbing through the open

485
00:41:30,400 --> 00:41:35,260
window so they're very related you know
that the path through the code is almost

486
00:41:35,260 --> 00:41:39,430
identical for vulnerabilities and
attacks and so it's really weird that we

487
00:41:39,430 --> 00:41:43,720
have these two whole classes of of
technologies and never the twain shall

488
00:41:43,720 --> 00:41:49,560
meet but I believe you know when I asked
coming together as a single agent is the

489
00:41:49,560 --> 00:41:54,830
way that this this will evolve it's the
same technology used for two slightly

490
00:41:54,830 --> 00:41:57,790
different purposes and it just makes
sense to put them together in the

491
00:41:57,790 --> 00:42:04,040
dashboard and it's really you know the
way that development is going anyway so

492
00:42:04,040 --> 00:42:09,210
for building heading towards DevOps and
we can't continue to be two communities

493
00:42:09,210 --> 00:42:14,700
of dev adopts we need to have the same
tools on both sides of the equation so

494
00:42:14,700 --> 00:42:19,250
hopefully that is your question you know
I would look at the different vendors

495
00:42:19,250 --> 00:42:24,210
dashboards and you know see which ones
look like rich useful information that

496
00:42:24,210 --> 00:42:35,190
you can get security value out of and
which ones are just log files laps

497
00:42:35,190 --> 00:42:44,480
vulnerabilities validation yeah you know
rasp is a top-level specific kind of

498
00:42:44,480 --> 00:42:49,030
technology right so you need to talk to
her about what applications you wanted

499
00:42:49,030 --> 00:42:54,180
to work on their arrest implications for
almost every platform out there but not

500
00:42:54,180 --> 00:42:58,450
every vendor support every technology so
you just have to have to talk to them

501
00:42:58,450 --> 00:43:03,919
but you know I believe I fully believe
that in the next five years every

502
00:43:03,920 --> 00:43:08,650
application is instrumented for security
because it's so powerful and

503
00:43:08,650 --> 00:43:14,210
you know it's awful lot of of logistical
issues around upset ya

504
00:43:19,700 --> 00:43:26,859
that's actually great segue if we r
could have a suddenly rasp enabled

505
00:43:26,859 --> 00:43:31,690
portfolio as the slide describes in one
year five years what's the next thing we

506
00:43:31,690 --> 00:43:34,520
worried about is it

507
00:43:34,520 --> 00:43:38,540
who is attacking you know this this
after this looks like a great way to

508
00:43:38,540 --> 00:43:44,210
block the actual tax but then what we
care about next to me the way security

509
00:43:44,210 --> 00:43:51,010
works is you know you have a model of
how you want security to be in you you

510
00:43:51,010 --> 00:43:55,510
can set up your asked to evaluate
yourself against that model right and

511
00:43:55,510 --> 00:43:59,520
there may be delta's that you can work
on to improve your performance against

512
00:43:59,520 --> 00:44:05,290
that model but what you work on going
forward is improved the model right that

513
00:44:05,290 --> 00:44:10,270
understanding the threat thinking about
what new attacks they might have so you

514
00:44:10,270 --> 00:44:14,960
know it's very reactive we discovered
the chairman is here somewhere he

515
00:44:14,960 --> 00:44:20,869
discovers clickjacking in you know 2007
or five or something I was at the talk

516
00:44:20,869 --> 00:44:26,329
when he talked about it and then you
know we're like eight years later and

517
00:44:26,329 --> 00:44:29,900
there's still a ton applications that
don't take the simple precaution of

518
00:44:29,900 --> 00:44:34,650
adding extra martians headed to their
application it's ridiculous we can't we

519
00:44:34,650 --> 00:44:38,650
can't wait years I mean like twenty-five
years and counting a buffer overflows

520
00:44:38,650 --> 00:44:47,079
nineteen years on XSS and sequins action
it's crazy so you know we gotta do

521
00:44:47,079 --> 00:44:50,500
something to get in front of that a
little better and I think this will help

522
00:44:50,500 --> 00:44:54,609
raise this all day to get a handle on
the vulnerabilities that you got what

523
00:44:54,609 --> 00:44:58,700
you got a legacy portfolio full of a
bunch of flaws get in front of it with

524
00:44:58,700 --> 00:45:03,669
rest and then be strategic about what
you want to focus on going forward I

525
00:45:03,670 --> 00:45:09,290
would suggest spending time doing some
threat modeling that but this frees up

526
00:45:09,290 --> 00:45:13,960
your your security experts from being
exercised some keys right I know

527
00:45:13,960 --> 00:45:18,250
companies that have teams of people that
all they do is review the output from

528
00:45:18,250 --> 00:45:23,819
static tools and ticket to the developer
hurts as they could you fix this in the

529
00:45:23,819 --> 00:45:24,759
end up just being

530
00:45:24,760 --> 00:45:31,040
you know access machinery that's not
useful we need to use with a limited

531
00:45:31,040 --> 00:45:35,740
number of a sick people in the world and
we need to use them strategically on

532
00:45:35,740 --> 00:45:43,819
hard stuff like access control
authentication encryption those kinds of

533
00:45:43,820 --> 00:45:49,780
things are you know the simple stuff
that we can you do to me and get out of

534
00:45:49,780 --> 00:45:54,470
the way with automated protections great
question by the way

535
00:45:57,220 --> 00:46:00,220
yeah

536
00:46:16,869 --> 00:46:23,910
it's a good question and it's possible
rate my my suspicions though is that if

537
00:46:23,910 --> 00:46:30,509
you give developers instant feedback as
their testing locally and they type in

538
00:46:30,509 --> 00:46:38,609
an XSS flaw and something in the
environment because they get a

539
00:46:38,609 --> 00:46:42,980
notification on alert or compiler
warning or whatever it is my suspicion

540
00:46:42,980 --> 00:46:47,640
is that they're gonna fix it right there
and turnover clean-cut but look at the

541
00:46:47,640 --> 00:46:51,950
job of a developer right now the rate
code and six months later

542
00:46:52,529 --> 00:46:56,190
occurs through some static thing and get
back

543
00:46:56,190 --> 00:47:00,039
report that doesn't have just the floods
that they introduce everybody has flaws

544
00:47:00,039 --> 00:47:04,890
in it so they gotta search through five
thousand vulnerabilities to figure out

545
00:47:04,890 --> 00:47:09,249
which ones are proud of their code then
track it down to one line of code if

546
00:47:09,249 --> 00:47:13,299
it's a real vulnerability and what they
need to do to fix it is not reasonable

547
00:47:13,299 --> 00:47:18,319
right in most cases those guys are gone
they're working on the next project and

548
00:47:18,319 --> 00:47:21,430
this thing just go to some meanings
developer whose Compton how many flaws

549
00:47:21,430 --> 00:47:26,308
they can fix in a day so they fix it
wrong there are 40 percent failure rate

550
00:47:26,309 --> 00:47:30,890
on security fixes even when they're
given the full details of the flying

551
00:47:30,890 --> 00:47:32,269
told exactly how to fix it

552
00:47:32,269 --> 00:47:37,609
40 percent failure rate that's no good
right so we need to get instant feedback

553
00:47:49,660 --> 00:47:52,660
understand the question

554
00:47:56,349 --> 00:48:00,479
so the interpretation is actually really
easy different vendors have sort of

555
00:48:00,479 --> 00:48:05,299
different approaches to this but
typically it's a really small agent so

556
00:48:05,299 --> 00:48:10,019
you contrast agent is the three megabyte
jar file for Joba it's a small installer

557
00:48:10,019 --> 00:48:15,470
for the.net platform and NodeJS is
another small install you know it's it's

558
00:48:15,470 --> 00:48:16,979
tiny

559
00:48:16,979 --> 00:48:24,019
the power comes because that tiny thing
has tentacles that in the region to an

560
00:48:24,019 --> 00:48:29,499
instrument the whole application right
took a bunch of the budget taps into

561
00:48:29,499 --> 00:48:32,499
your application that pull out the data
where it's needed

562
00:48:35,589 --> 00:48:40,849
ok I think that's it for questions so
I'm around please stop by the contrast

563
00:48:40,849 --> 00:48:45,259
booth if you're interested I'd love to
show you how we do rest and if you want

564
00:48:45,259 --> 00:48:52,019
you can enter a raffle you can women
cool something and we look at these

565
00:48:52,019 --> 00:48:53,848
things like user-defined

