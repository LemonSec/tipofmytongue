1
00:00:46,520 --> 00:01:09,300
intuition why this is the case comes
down to the fact that developers write

2
00:01:09,300 --> 00:01:14,300
code on top of API's are inherently
prone to particular class of all

3
00:01:14,300 --> 00:01:19,830
abilities right so if you're writing
code against a sequel teary API and

4
00:01:19,830 --> 00:01:24,060
you're not careful you'll enjoy it as a
single injection bug similarly if you're

5
00:01:24,060 --> 00:01:27,570
writing code against the web platform
API you're dealing with a very

6
00:01:27,570 --> 00:01:30,820
complicated if you are that's full of
sharp edges and there's very very many

7
00:01:30,820 --> 00:01:34,398
opportunities for you to introduce
mistakes that end result in liability

8
00:01:34,399 --> 00:01:40,270
about availability security bugs are
vulnerabilities and so basically what we

9
00:01:40,270 --> 00:01:44,660
have a decision we have is that we
expect developers to always in every

10
00:01:44,660 --> 00:01:48,360
single one of those cases where the
UCI's API's be very careful and beware

11
00:01:48,360 --> 00:01:52,979
of all the security considerations which
by the way too often orthogonal to the

12
00:01:52,979 --> 00:01:56,149
primary purpose of this API right to see
quicker API doesn't really have that

13
00:01:56,149 --> 00:01:59,979
much to do with security it's about
creating data from a database and web

14
00:01:59,979 --> 00:02:03,610
platforms about rendering you I and the
fact that there is actually security

15
00:02:03,610 --> 00:02:08,380
considerations is sort of a secondary
concern is that it's very easy to forget

16
00:02:08,380 --> 00:02:13,810
that as you develop it right and he's
API's often vary widely used if you look

17
00:02:13,810 --> 00:02:16,750
at the web platform API is in a
large-scale web application you'll find

18
00:02:16,750 --> 00:02:20,750
probably hundreds if not thousands of
code sites that could potentially result

19
00:02:20,750 --> 00:02:25,310
in about and so democracy human they
make mistakes so we're basically in a

20
00:02:25,310 --> 00:02:30,000
situation where we have many potential
bugs and then therefore some actual bugs

21
00:02:30,000 --> 00:02:36,590
it's it's it's very much as inevitable
and what we have to do is because we now

22
00:02:36,590 --> 00:02:41,010
have code that has bugs in it we have to
try and isolate those find those

23
00:02:41,010 --> 00:02:44,829
eliminate them before we ship the bugs
before we ship their the quarter

24
00:02:44,830 --> 00:02:48,190
production of course unfortunately the
approaches that we have at our disposal

25
00:02:48,190 --> 00:02:53,060
there are inherently incompletes relying
on static analysis tools are inherently

26
00:02:53,060 --> 00:02:55,140
incomplete relying on testing relying on

27
00:02:55,140 --> 00:02:59,049
human quarter of you will never find all
the bugs once they're introduced and so

28
00:02:59,050 --> 00:03:02,560
we're going to ship something productive
to production and we're in a in a bad

29
00:03:02,560 --> 00:03:10,840
place so what I'm proposing is to
instead take the view that really the

30
00:03:10,840 --> 00:03:15,600
problem is with the API right the
problem is not with the developer who is

31
00:03:15,600 --> 00:03:20,579
making mistakes the problem is that we
have designed if you guys that permit

32
00:03:20,580 --> 00:03:26,860
the introduction of bugs that are kind
of secondary orthogonal to the primary

33
00:03:26,860 --> 00:03:30,830
purpose of the API and in particular
then are bugs that result in security

34
00:03:30,830 --> 00:03:34,040
vulnerabilities and that's really an
unreasonable burden that were placing on

35
00:03:34,040 --> 00:03:38,440
the developer and it doesn't work right
so what we need to do is intact put the

36
00:03:38,440 --> 00:03:43,519
burden on the API and the API's design
the API's implementation to ensure that

37
00:03:43,519 --> 00:03:47,110
it's impossible for the developer to
make these mistakes as are using the API

38
00:03:47,110 --> 00:03:56,150
so we want is what I call inherently
safer because I guess my slides are and

39
00:03:56,150 --> 00:04:02,160
what what that means is basically an API
that has roughly the same or has the

40
00:04:02,160 --> 00:04:06,299
same functionality as the one that's
their to date but also has the property

41
00:04:06,299 --> 00:04:10,660
that it doesn't allow the developer to
accidentally interviews blogs at the end

42
00:04:10,660 --> 00:04:16,519
result in security vulnerabilities and
of course we have to make this API is

43
00:04:16,519 --> 00:04:21,048
usable so we have to make them
approximately as convenient to use as

44
00:04:21,048 --> 00:04:25,419
the original fallibility prodipe I
that's an interesting question can we

45
00:04:25,419 --> 00:04:28,650
actually do this right is this practical
can we come up with API is that are both

46
00:04:28,650 --> 00:04:32,719
constrain enough to prevent application
code from being written on top of the

47
00:04:32,720 --> 00:04:36,770
API that might have security
vulnerabilities but at the same time

48
00:04:36,770 --> 00:04:41,700
expressive enough so that our developer
can still write the code that you used

49
00:04:41,700 --> 00:04:43,289
to write and do so

50
00:04:43,289 --> 00:04:45,340
productively right so we're we're

51
00:04:45,340 --> 00:04:50,400
we have to make sure that you guys are
actually usable so what I like to do for

52
00:04:50,400 --> 00:04:55,789
the remainder of the talk for most part
is just talked about two areas where we

53
00:04:55,790 --> 00:04:59,220
worked on this problem and where I think
we actually reasonably well succeeded in

54
00:04:59,220 --> 00:05:03,639
in coming up with solutions that the
first thing i wanna talk about single

55
00:05:03,639 --> 00:05:13,199
injection I don't think I need to
explain this but you know how to make

56
00:05:13,199 --> 00:05:19,479
sure that the right way and I can
explain

57
00:05:20,110 --> 00:05:25,500
injection diesel I think everybody here
knows what what the problem is what it

58
00:05:25,500 --> 00:05:30,870
comes down to is that basically queries
are assembled from strains in program

59
00:05:30,870 --> 00:05:36,960
code and then in a way where
untrustworthy data externally controlled

60
00:05:36,960 --> 00:05:42,049
data is somehow introduced in the query
and then results in an attacker's

61
00:05:42,050 --> 00:05:45,770
ability to modify its use in tax and
semantics of the query

62
00:05:50,710 --> 00:05:56,950
so far the existing best practices to
try and avoid these types of birds is

63
00:05:56,950 --> 00:06:01,320
that we tell developers well you should
be using prepared statements which if

64
00:06:01,320 --> 00:06:05,990
they're used consistently prevent the
bog because all the externally

65
00:06:05,990 --> 00:06:09,790
controlled data the parameters to the
query are introduced sort of out of

66
00:06:09,790 --> 00:06:14,380
bands will bind variables and so they
can't be any injection unfortunately as

67
00:06:14,380 --> 00:06:17,860
we've seen development as we all know
developers are humans and they are

68
00:06:17,860 --> 00:06:21,240
sometimes make mistakes they forget
about the guideline or they just aren't

69
00:06:21,240 --> 00:06:24,990
aware of it when they start coding and
so then we end up with code that doesn't

70
00:06:24,990 --> 00:06:28,640
use prepared statements and so therefore
is potentially vulnerable and then

71
00:06:28,640 --> 00:06:32,940
sometimes I actually believe all we also
may sometimes run into situations where

72
00:06:32,940 --> 00:06:36,520
they follow the spirit of the rule so
they're using prepared statements but

73
00:06:36,520 --> 00:06:40,240
the sort of miss the whole point and we
end up with cold like this that you know

74
00:06:40,240 --> 00:06:45,600
its injectable despite the fact that
it's using the prepared statement if you

75
00:06:45,600 --> 00:06:52,780
I the other approach that when you sort
of asked developers to consider is to

76
00:06:52,780 --> 00:06:57,590
use structural clearly API substructure
CareerBuilder API is things like

77
00:06:57,590 --> 00:07:01,349
hibernate criteria where you actually
use the programmatic if you have to

78
00:07:01,350 --> 00:07:04,600
assemble the structure of the query and
then that's also inherently safe from

79
00:07:04,600 --> 00:07:09,100
Jackson unfortunately that's also pretty
cumbersome for a more complex query this

80
00:07:09,100 --> 00:07:13,240
gets quite tedious as opposed to the
convenience of ratings equal so the

81
00:07:13,240 --> 00:07:17,370
question is can we come up with their
with an API that allows developers to

82
00:07:17,370 --> 00:07:22,500
basically still build queries from
string concatenation but in a way that

83
00:07:22,500 --> 00:07:29,810
prevents the introduction of injection
vulnerabilities and here's an API that

84
00:07:29,810 --> 00:07:34,050
basically does that it's a very very
simple API it's just a wrapper for a

85
00:07:34,050 --> 00:07:38,030
StringBuilder and the only thing it does
is that it has an append method that

86
00:07:38,030 --> 00:07:42,599
says you're only supposed to append
strains that come from a constant

87
00:07:42,600 --> 00:07:46,280
compile time constant expression
expression is part of the programs are

88
00:07:46,280 --> 00:07:50,580
inherently trustworthy and so what we
basically then end up with is the

89
00:07:50,580 --> 00:07:55,000
invariant at the result from using this
builder is a strength composition

90
00:07:55,000 --> 00:08:00,340
contamination strings which means they
cannot the NE

91
00:08:00,340 --> 00:08:06,119
entrusted data flow dependent or any
dependency diferencia entre the data

92
00:08:06,120 --> 00:08:10,330
into that period which means they can be
an injection right you can only depend

93
00:08:10,330 --> 00:08:15,159
constants to the query time constants
which means you can't write code inject

94
00:08:15,160 --> 00:08:18,729
anything that's not trustworthy of
course the problem is you know as we

95
00:08:18,729 --> 00:08:22,919
know developers don't always read
documentation if we just had this this

96
00:08:22,919 --> 00:08:27,210
API documentation please only call this
with compile-time constant expressions

97
00:08:27,210 --> 00:08:31,340
it I can guarantee you that within weeks
or months we have code like this right

98
00:08:31,340 --> 00:08:35,559
where somebody gets to do that doesn't
read the documentation then we end up

99
00:08:35,559 --> 00:08:39,140
basically in square one we end up with
code that is injectable answer to

100
00:08:39,140 --> 00:08:43,429
prevent this what we did is we added a
study checker to our Java Java toolchain

101
00:08:43,429 --> 00:08:49,040
that tees off on this at compile-time
constant rotation there and potentially

102
00:08:49,040 --> 00:08:52,660
enforces that for any cause side of a
method with a parent parameter thats

103
00:08:52,660 --> 00:08:57,370
declared at compile time constant we
enforce that compile time that the

104
00:08:57,370 --> 00:09:01,220
actual parameters actually competent
counsel expression and so we implement

105
00:09:01,220 --> 00:09:04,830
this and so if you do not try to compile
the code in the Google tool chain in our

106
00:09:04,830 --> 00:09:09,690
job at all chain that has this check our
plugin built into it it won't compile

107
00:09:09,690 --> 00:09:13,980
it'll give you a compiler error and so
without you really cannot write code

108
00:09:13,980 --> 00:09:17,830
against this API that has even a
potential sequel injector and it

109
00:09:17,830 --> 00:09:21,990
basically enforces by the design of the
EPI in combination with his little check

110
00:09:21,990 --> 00:09:30,430
our that's the that's the decree is a
concatenation of time constant strings

111
00:09:30,430 --> 00:09:33,430
and therefore not injectable

112
00:09:34,350 --> 00:09:38,130
now for a look at the resulting codes
are in the before and after world we

113
00:09:38,130 --> 00:09:42,290
also see that the structure of the code
is basically the same right

114
00:09:42,800 --> 00:09:47,810
the old API is using string
concatenation to build a query and the

115
00:09:47,810 --> 00:09:51,680
new state API is still doing that we're
still a pending strings to the query the

116
00:09:51,680 --> 00:09:54,239
only difference is that we used

117
00:09:54,240 --> 00:09:59,560
variability depend instead of plastic
balls on a string and then of course we

118
00:09:59,560 --> 00:10:02,119
can see that on the left side there is
actually a single injection

119
00:10:02,120 --> 00:10:05,520
vulnerability in their code because
we're dating

120
00:10:06,070 --> 00:10:10,930
untrustworthy the external input to the
query so we have to have a bug here and

121
00:10:10,930 --> 00:10:14,790
now we try to translate that into the
new EP I wouldn't compile and then that

122
00:10:14,790 --> 00:10:19,730
compels us to use a so you can see this
but I mean here a little basically be

123
00:10:19,730 --> 00:10:27,940
using a binder a matter for this rating
right so basically the API compels a

124
00:10:27,940 --> 00:10:30,330
developer to actually follow the best
practice that they're supposed to be

125
00:10:30,330 --> 00:10:35,450
following anyway and if they don't get a
compiler error that tells them went into

126
00:10:35,450 --> 00:10:40,860
the documentation for this builder and
tell them what do you think you can see

127
00:10:40,860 --> 00:10:45,560
here is that we added a little bit of
additional syntactic sugar to the if you

128
00:10:45,560 --> 00:10:49,949
will to the API so the API since we now
have a builder doesn't only assembled

129
00:10:49,950 --> 00:10:54,650
the clearing itself it also allows us to
add code methods to assemble the bind

130
00:10:54,650 --> 00:11:00,410
parameters which then allows you to move
the statement that binds the value for a

131
00:11:00,410 --> 00:11:04,780
particular primary right next to the
place where the parameters introduced in

132
00:11:04,780 --> 00:11:10,110
the query so for instance this finds a
user ID you that's in this code inserted

133
00:11:10,110 --> 00:11:13,530
into the clear here but over there we
can actually move this right next to

134
00:11:13,530 --> 00:11:18,640
their statement where the user ID
parameter is introduced into it very

135
00:11:18,640 --> 00:11:24,250
fortunate Kansas so how did this turn
out in practice we basically went and

136
00:11:24,250 --> 00:11:30,070
implemented builder API's in the style
for databases that are used this

137
00:11:30,070 --> 00:11:34,770
includes f1 and spanner which are
planets gael highly scalable databases

138
00:11:34,770 --> 00:11:40,329
that are used to back and use our facing
applications and there's various papers

139
00:11:40,330 --> 00:11:44,180
at conferences about them and then
hibernate which is more frequently used

140
00:11:44,180 --> 00:11:47,660
it doesn't lead to that scale but it's
quite frequently used in internal facing

141
00:11:47,660 --> 00:11:51,100
applications as we implement these
builders and then we did a global

142
00:11:51,100 --> 00:11:55,630
refactoring of all the existing client
code of the original creepy eyes and

143
00:11:55,630 --> 00:12:00,930
changed it to use the new rules saves
CareerBuilder API this was a couple of

144
00:12:00,930 --> 00:12:04,589
water person quarters worth of effort
but in the end it was not hard because

145
00:12:04,590 --> 00:12:07,660
as we've seen the structure of the old
code in the new code is basically the

146
00:12:07,660 --> 00:12:10,680
same so it's an almost I mean it was
actually in some cases are made about

147
00:12:10,680 --> 00:12:14,569
the refectory but it wasn't very hard
way it was somewhat tedious and then if

148
00:12:14,570 --> 00:12:18,490
you consider that you know there's like
probably a couple of thousands of

149
00:12:18,490 --> 00:12:19,560
developers writing

150
00:12:19,560 --> 00:12:23,699
Google against these API is the fact
that it was like you know a few person

151
00:12:23,700 --> 00:12:28,670
quarters to clean up is really a very
modest effort was actually very

152
00:12:28,670 --> 00:12:33,870
reasonable and then once we're done with
that factoring we removed the original

153
00:12:33,870 --> 00:12:39,080
execute query of a string method that is
injected that's inherently prone to go

154
00:12:39,080 --> 00:12:42,790
with that might be vulnerable from
injections from the API altogether is

155
00:12:42,790 --> 00:12:48,120
gone and so without the public API for
those databases really does not allow

156
00:12:48,120 --> 00:12:51,570
you to write code that is even
potentially injectable right adjustments

157
00:12:51,570 --> 00:12:57,250
even compile its so basically in return
for the present quarter efforts we now

158
00:12:57,250 --> 00:13:01,000
are completely done worrying about
single injection just can't write code

159
00:13:01,000 --> 00:13:05,510
that has single injection so this was a
very nice result the only thing I want

160
00:13:05,510 --> 00:13:09,410
to stress is that the implementation is
really very very straightforward right

161
00:13:09,410 --> 00:13:14,870
so there are no like complicated whole
program ten static analysis checkers any

162
00:13:14,870 --> 00:13:18,870
involved it's that builder that you
basically saw the essence of it on one

163
00:13:18,870 --> 00:13:22,950
slide and then the static checker which
is implemented in error-prone which is a

164
00:13:22,950 --> 00:13:29,720
open source static checker pluggable
framework that allows you to write

165
00:13:29,720 --> 00:13:37,290
products on the type and rotated Java
syntax tree and in that framework it's

166
00:13:37,290 --> 00:13:40,319
probably like fifty or a hundred lines
of code to write the shakers very very

167
00:13:40,320 --> 00:13:43,430
simple it right so basically in return
for a couple hundred lines of code

168
00:13:43,430 --> 00:13:47,550
implementation we could actually very
rigorous scanty that single injection

169
00:13:47,550 --> 00:13:53,069
simply can't happen and all this without
any kind of complicated static analysis

170
00:13:53,070 --> 00:13:59,589
is actually a pretty nice result now you
notice maybe this little asterisks here

171
00:13:59,589 --> 00:14:05,250
when I said we have removed this execute
query the thing is there's always

172
00:14:05,250 --> 00:14:15,820
exceptions right so there's there's
certain scenarios where

173
00:14:15,820 --> 00:14:20,170
this API because it has a constraint
that the query is a concatenation of

174
00:14:20,170 --> 00:14:25,740
program clinton's essentially is not
usable to implement what you're trying

175
00:14:25,740 --> 00:14:31,250
to implement canonical example would be
a command-line utility for the database

176
00:14:31,250 --> 00:14:36,010
which by design gets to query from
standard input and i cant be a

177
00:14:36,010 --> 00:14:39,420
compile-time constant string in that
case injection is not a concern because

178
00:14:39,420 --> 00:14:43,640
the principal who is providing the cree
is the same as the principal that's

179
00:14:43,640 --> 00:14:47,920
added to the database and thereby design
supposed to be able to execute any query

180
00:14:47,920 --> 00:14:51,400
against the tables at the access to at
the database level right so we still

181
00:14:51,400 --> 00:14:55,180
need to be able to implement this and to
do this what we did is essentially a

182
00:14:55,180 --> 00:15:03,390
provide a a a restricted but
unconstrained API that effectively still

183
00:15:03,390 --> 00:15:08,600
gives you the execute query of a string
behavior that's potentially injection

184
00:15:08,600 --> 00:15:12,660
prone but we made it subject to security
of you and we actually because we have a

185
00:15:12,660 --> 00:15:16,750
lot of developers that may not always
read read the documentation that tells

186
00:15:16,750 --> 00:15:21,160
him that he should be getting a review
before using this API we actually put a

187
00:15:21,160 --> 00:15:25,300
mechanism in place to enforce that their
review took place to do that we used a

188
00:15:25,300 --> 00:15:30,000
mechanism in our bill system which is
also open source as baseball that allows

189
00:15:30,000 --> 00:15:35,160
you to specify for certain libraries a
white list of packages that made you is

190
00:15:35,160 --> 00:15:38,730
that right and so essentially if
somebody wants to uses this backdoor epi

191
00:15:38,730 --> 00:15:39,710
so to speak

192
00:15:39,710 --> 00:15:43,060
they have to get a widely-used and for
that they need our approval because we

193
00:15:43,060 --> 00:15:46,849
own that directory and so they can just
started using they have to come to which

194
00:15:46,850 --> 00:15:49,950
is what we want right now but once
they've convinced us that they use cases

195
00:15:49,950 --> 00:15:53,710
reasonable it's very very lightweight we
just added to the white laces one change

196
00:15:53,710 --> 00:15:59,420
and they're going to go and what what is
essential for this whole thing to work

197
00:15:59,420 --> 00:16:05,530
or to be practical is that this
exceptional API is only necessary in the

198
00:16:05,530 --> 00:16:08,810
very small number of sites in this
turned out to be the case so we found

199
00:16:08,810 --> 00:16:12,180
that when we did this for factoring
almost all the code that was there could

200
00:16:12,180 --> 00:16:15,550
be a factor to use the CPI and there
were only a very small number of

201
00:16:15,550 --> 00:16:20,589
exceptions where we had to use the
unsafe API that requires manual

202
00:16:20,590 --> 00:16:39,720
do well to talk about scripting a little
bit so ok so I think the the the reason

203
00:16:40,470 --> 00:16:46,240
gripping as such a particularly
intractable class a bug in my intuition

204
00:16:46,240 --> 00:16:52,380
seems to stem from the fact that there
is very very many potential in Jackson

205
00:16:52,380 --> 00:16:56,950
sings but many but potentially
vulnerable sites in a in a large-scale

206
00:16:56,950 --> 00:17:00,920
about often hundreds if not thousands
and then on top of that the data that

207
00:17:00,920 --> 00:17:05,520
flows into these injections think sinks
very frequently comes from far away in

208
00:17:05,520 --> 00:17:10,889
the program so we are dealing with
complex whole system data flows into

209
00:17:10,890 --> 00:17:14,570
those API's which are very difficult to
reason about so as an example I have a

210
00:17:14,569 --> 00:17:20,389
little slice of a typical bad as it
might exist at Google where we see some

211
00:17:20,390 --> 00:17:26,020
code that implemented in JavaScript that
render some UI and then the data either

212
00:17:26,020 --> 00:17:30,450
goes into that you I comes from a bunch
of back into the web application

213
00:17:30,450 --> 00:17:36,780
front-end and back-end and then there's
some stories later now for a unfortunate

214
00:17:36,780 --> 00:17:41,420
security engineer has to review this app
for cross-site scripting bugs what will

215
00:17:41,420 --> 00:17:46,070
basically do it will start with the
injections things will start in goal and

216
00:17:46,070 --> 00:17:50,200
we look for things like assignments to
compel because that's where the trouble

217
00:17:50,200 --> 00:17:56,230
starts us and so will find one here we
see that what goes into that is its

218
00:17:56,230 --> 00:18:00,430
general mark-up that's been composed
using ad-hoc string concatenation so we

219
00:18:00,430 --> 00:18:04,860
look at what happened here and we can
see that there is to sort of subsidiary

220
00:18:04,860 --> 00:18:06,379
injection points if you will

221
00:18:06,380 --> 00:18:11,430
where variables are introduced into that
marked up that's been constructed here

222
00:18:11,430 --> 00:18:16,240
we can see there's one here which is a
whole is called profiles as profile I

223
00:18:16,240 --> 00:18:19,710
can holder is like a message object

224
00:18:19,710 --> 00:18:25,380
or whatever that contains a bunch of
fields of user data domain object I

225
00:18:25,380 --> 00:18:29,940
guess you could call it and we can see
that they actually went and HTML escape

226
00:18:29,940 --> 00:18:35,630
this before putting it into this href
attribute but the emitted code that does

227
00:18:35,630 --> 00:18:40,850
any kind of validation right so we don't
know what would happen if this homepage

228
00:18:40,850 --> 00:18:44,240
value could be JavaScript Poland's
largest code in which case there would

229
00:18:44,240 --> 00:18:47,409
be an injection and there's no code here
that does is validation so we sort of

230
00:18:47,409 --> 00:18:53,309
have to guess that maybe they relied on
input validation of that field of that

231
00:18:53,309 --> 00:18:56,700
data when it somehow made it into the
system earlier but we are really don't

232
00:18:56,700 --> 00:19:00,620
know said something about it right
because there is no code that does the

233
00:19:00,620 --> 00:19:04,678
actual validation at runtime right there
and then the other thing we see is there

234
00:19:04,679 --> 00:19:09,240
is a field called about HTML that gets
inserted into a div and so this whole

235
00:19:09,240 --> 00:19:15,270
thing is like a part of a profile page
it renders a piece of a user's profile

236
00:19:15,270 --> 00:19:18,620
in some way you know photo sharing
application or social network or

237
00:19:18,620 --> 00:19:22,479
something like that and so the intent
here is that this contains a subset of

238
00:19:22,480 --> 00:19:26,610
HTML markup that is hopefully safe
hopefully inert and will not cause

239
00:19:26,610 --> 00:19:30,990
JavaScript execution intended as sort of
a future perspective that users can

240
00:19:30,990 --> 00:19:34,330
write about themselves they can use
fonts and they can use inline images of

241
00:19:34,330 --> 00:19:35,110
that kind of stuff

242
00:19:35,110 --> 00:19:44,889
emoticons whatever and so we expect to
see a subset of html fonts and stuff but

243
00:19:44,890 --> 00:19:47,539
there shouldn't be any script tags in
there but again there's no cold here

244
00:19:47,539 --> 00:19:52,200
that validates this right so if we're
doing a review of this piece of code we

245
00:19:52,200 --> 00:19:57,059
have to validate we have to ascertain
whether data comes from in and make sure

246
00:19:57,059 --> 00:20:03,970
that somehow along the path into this
into this code validation to place right

247
00:20:03,970 --> 00:20:07,279
so we'll see where does it come from
well we're getting it past year we get

248
00:20:07,279 --> 00:20:12,809
to see this profile object this domain
objects from an RPC response to an

249
00:20:12,809 --> 00:20:17,850
XMLHttpRequest from a web frontend so
we're here we're now in Java code and in

250
00:20:17,850 --> 00:20:22,199
this is the Google protocol buffer that
is what generates system an object but

251
00:20:22,200 --> 00:20:25,070
this could be a piece of Java code
either

252
00:20:25,070 --> 00:20:29,789
also seen here there's a bunch of Java
code that just gets his profile object

253
00:20:29,789 --> 00:20:33,590
from about against which is not written
in C++ and hearing it from a database

254
00:20:33,590 --> 00:20:40,449
from a storage database schema and then
we're still not sure if there is about a

255
00:20:40,450 --> 00:20:45,370
billion not because we haven't seen any
validation along the way here right so

256
00:20:45,370 --> 00:20:49,100
presumably this application relies on
external input validation but now you

257
00:20:49,100 --> 00:20:51,658
can see there they might actually be
used like several front and side right

258
00:20:51,659 --> 00:20:55,389
to this profile so right there might be
a backend for a mobile app that might be

259
00:20:55,389 --> 00:21:00,789
a developer facing REST API and there
might be a profile management front and

260
00:21:00,789 --> 00:21:05,330
they might be internal customer service
applications windows right now we

261
00:21:05,330 --> 00:21:07,980
actually have to look at all of these to
figure out where the hell does that come

262
00:21:07,980 --> 00:21:09,909
from so this is very quickly

263
00:21:09,909 --> 00:21:13,070
their deep down the rabbit hole is
quickly becoming intractable right and

264
00:21:13,070 --> 00:21:16,408
is also something if you look at it
that's essentially a hopeless problem

265
00:21:16,409 --> 00:21:21,419
for an automated it static analysis
system to try and reason about this

266
00:21:21,419 --> 00:21:24,429
whole system data flow because we're
going like across three different

267
00:21:24,429 --> 00:21:29,529
languages different RBC mechanisms
storage schema and then who knows what

268
00:21:29,529 --> 00:21:33,730
goes in here right so this gets very
very intractable and they're very

269
00:21:33,730 --> 00:21:38,690
difficult so what do we do about this
well the first area want to address is

270
00:21:38,690 --> 00:21:41,779
the construction of HTML

271
00:21:48,630 --> 00:21:58,080
so the the the first thing on addresses
the ad hoc concatenation of HTML markup

272
00:21:58,080 --> 00:22:03,629
what we did is we introduce tempting
systems that are contextually auto

273
00:22:03,630 --> 00:22:07,730
escaping which means that the template
system actually understands HTML markup

274
00:22:07,730 --> 00:22:12,220
and he knows in which context in the
HTML markup substitution takes place it

275
00:22:12,220 --> 00:22:16,650
so that the template system will
basically parse the HTML markup in the

276
00:22:16,650 --> 00:22:21,640
template and then figure out what
context all these substitutions take

277
00:22:21,640 --> 00:22:26,370
place and then infer appropriate runtime
sanitization and escaping to ensure that

278
00:22:26,370 --> 00:22:32,010
no scripting can take place and so in
this case competition would infer these

279
00:22:32,010 --> 00:22:35,930
escaping directives which in the old
version the developer might have had to

280
00:22:35,930 --> 00:22:41,570
actually put in there manually but now
that enforces them and put them there on

281
00:22:41,570 --> 00:22:46,570
its own and we can see that it worked
out that here this is basically the body

282
00:22:46,570 --> 00:22:51,560
of an element so we just need to HTML
escape this one appears in a valued

283
00:22:51,560 --> 00:22:55,179
attributes so we first need to validate
that this is a savior lol its not

284
00:22:55,180 --> 00:22:59,940
Javascript something something it's
formed HDB euro and then we cannot

285
00:22:59,940 --> 00:23:05,150
escape and then again in inside a an
element so we escape so this is great

286
00:23:05,150 --> 00:23:10,140
because now the template system
basically makes a promise it has again

287
00:23:10,140 --> 00:23:14,740
to you that for arbitrary inputs into
the template system as long as a

288
00:23:14,740 --> 00:23:18,940
template itself compiles we have the
guarantee you that the resulting mark-up

289
00:23:18,940 --> 00:23:22,210
cannot result in excess because the
template system guarantees that it

290
00:23:22,210 --> 00:23:26,070
always perfectly valid and escape the
data at runtime so that they can be

291
00:23:26,070 --> 00:23:30,470
accessed bugs from rendering this
template so this is this is wonderful

292
00:23:30,470 --> 00:23:34,920
except we have a problem that's here
there's actually a feature that expects

293
00:23:34,920 --> 00:23:37,990
us to render HTML that we're getting
from somewhere right so for you just

294
00:23:37,990 --> 00:23:42,720
leave that left us as is we'd be
escaping the HTML markup that's in here

295
00:23:42,720 --> 00:23:47,460
like the poll tax that are in the use of
rich text format HTML that should be

296
00:23:47,460 --> 00:23:52,090
rendered here so we need a mechanism to
turn off the automatic escaping hear

297
00:23:52,090 --> 00:23:56,419
what you have to do is we had directives
like no other escape that the developer

298
00:23:56,420 --> 00:24:00,310
putting here that would turn this off
but we found that then again we're back

299
00:24:00,310 --> 00:24:01,810
in this place where you still have to

300
00:24:01,810 --> 00:24:06,970
analyze this long data flow into this
field to figure out if the appropriate

301
00:24:06,970 --> 00:24:10,790
sanitization of that markup safe
construction of that markup actually

302
00:24:10,790 --> 00:24:14,730
took place so this didn't really help us
and it actually resulted in a number of

303
00:24:14,730 --> 00:24:20,280
bugs so we did instead is we came up
with a different mechanism to instruct

304
00:24:20,280 --> 00:24:24,060
the template system to suppress the
automatically inferred escaping or

305
00:24:24,060 --> 00:24:28,679
sanitization and it's based on type so
interviews vocabulary of these types

306
00:24:28,680 --> 00:24:32,830
that are basically a string like objects
but the area along with them

307
00:24:33,340 --> 00:24:37,740
contracts promises that say that their
values have to be sick are safe to use

308
00:24:37,740 --> 00:24:42,430
in a particular context so that I
tickets to mel is safe to use in HTML

309
00:24:42,430 --> 00:24:48,040
markup in an HTML markup context inside
an element in its been a template or its

310
00:24:48,040 --> 00:24:55,120
safety assigned to enter its tomorrow if
your name is it for context and

311
00:24:55,120 --> 00:25:02,610
contracts are insured by those those
types public API so we have factored

312
00:25:02,610 --> 00:25:06,879
methods and builders and sanitizers that
themselves ensure that if you get an

313
00:25:06,880 --> 00:25:12,760
instance of one of those types back from
that API it guarantees that the value

314
00:25:12,760 --> 00:25:17,000
actually it here so its contract so we
can then basically use these type

315
00:25:17,000 --> 00:25:23,100
contracts as assumptions in the sinks
222 basically suppress automatic

316
00:25:23,100 --> 00:25:26,330
escaping because we know that the values
are easy for that contest so the the

317
00:25:26,330 --> 00:25:30,350
template system keys of these types and
we'd see the value of types if it's

318
00:25:30,350 --> 00:25:34,120
gmail it'll not run it through the
automatic escaping that it would

319
00:25:34,120 --> 00:25:37,550
normally do because it knows it sorry
safety using context so that the

320
00:25:37,550 --> 00:25:43,360
mechanism that we use to suppress the
automatic escaping the other thing that

321
00:25:43,360 --> 00:25:47,060
goes without including rules that
essentially prohibit the use of the

322
00:25:47,060 --> 00:25:52,389
regular injection vulnerability
prominent Ahmeti so for instance

323
00:25:52,390 --> 00:25:57,360
assignments to enter HTML and
assignments location href are basically

324
00:25:57,360 --> 00:26:01,879
banned from application code and instead
you're supposed to use a safe harbor for

325
00:26:01,880 --> 00:26:06,020
instance rendering one of those
templates or using a little wrapper for

326
00:26:06,809 --> 00:26:11,999
assignments to a location href that does
senators Asian at runtime so we

327
00:26:11,999 --> 00:26:17,519
basically layering across the top of the
Adamo API that's full of sharp edges a

328
00:26:17,519 --> 00:26:21,999
wrapper API that is safe and mostly
relies on these types to achieve that

329
00:26:21,999 --> 00:26:28,549
city and the those those constraints are
enforced by a compile-time check which

330
00:26:28,549 --> 00:26:33,639
is basically just a white list of sites
where we're essentially the only

331
00:26:33,639 --> 00:26:38,330
assignment to enter it should occur
inside those rapper libraries but it

332
00:26:38,330 --> 00:26:50,740
should never occur in now and then when
we now look at the same slice of this

333
00:26:50,740 --> 00:26:56,450
application in this new models in code
that is conformance to this could enroll

334
00:26:56,450 --> 00:27:04,009
we see that the situation looks a lot
better so we we now find that because

335
00:27:04,009 --> 00:27:08,009
we're hearing to the coating rule that
no more assignments two interesting

336
00:27:08,009 --> 00:27:11,340
things like that are allowed in
application code well they aren't any

337
00:27:11,340 --> 00:27:12,289
right i mean they're gone

338
00:27:12,289 --> 00:27:16,600
instead they using the render their
using one of these templates

339
00:27:16,600 --> 00:27:20,689
surrendering to save template which
again is something that cannot buy

340
00:27:20,690 --> 00:27:25,389
design result in excess so from a review
of perspective not something we have to

341
00:27:25,389 --> 00:27:30,168
look at in order to suppress the
automatic escaping of this particular

342
00:27:30,169 --> 00:27:35,139
field the developer now had to do
something special which is to use one of

343
00:27:35,139 --> 00:27:39,389
these types so in this in this domain
object the had to change the type of

344
00:27:39,389 --> 00:27:45,639
this field from string to save HTML
which is then what has the what it

345
00:27:45,639 --> 00:27:48,990
struck template system to suppress the
automatic escaping because it basically

346
00:27:48,990 --> 00:27:52,820
tells it rely on that type contract
don't your automatic escaping because

347
00:27:52,820 --> 00:27:57,519
the type promises that its values are
you safe to use in that context now if

348
00:27:57,519 --> 00:28:01,119
we go and then basically this domain
objects threats the whole way through

349
00:28:01,119 --> 00:28:04,879
across all these are PCs across the
different languages and now is we're in

350
00:28:04,879 --> 00:28:09,619
the back end where we read the data from
a database things get a little bit

351
00:28:09,619 --> 00:28:13,580
interesting because of a type mismatch
right the the data that comes out of the

352
00:28:13,580 --> 00:28:18,009
database out of that column is is a
string but we actually need to put into

353
00:28:18,009 --> 00:28:19,299
that domain object

354
00:28:19,299 --> 00:28:23,200
is safe it so we somehow need to make
that conversion and we don't have a

355
00:28:23,200 --> 00:28:27,769
public API design that just lets you
promise that just let you bless us

356
00:28:27,769 --> 00:28:33,379
training as as the types of HTML because
we know that that would be misused based

357
00:28:33,379 --> 00:28:37,129
on experience for them what we do is we
have a bunch of the library is that

358
00:28:37,129 --> 00:28:45,668
allow you to instruct HTML using sort of
like the API or we have a sanitizer

359
00:28:45,669 --> 00:28:52,409
module that is a commonly shared library
that takes as input an arbitrary strain

360
00:28:52,409 --> 00:28:57,509
that is assumed to contain HTML markup
but we're assuming militias and then the

361
00:28:57,509 --> 00:29:04,600
whole thing it's parsed and reduced to
two basically as safe subset subset of

362
00:29:04,600 --> 00:29:09,498
its remarkable and then the result of
that gets returned to you the caller the

363
00:29:09,499 --> 00:29:15,330
application in the form of this type
safety now because I designed the

364
00:29:15,330 --> 00:29:20,090
sanitizer reduces an arbitrary input to
a string that satisfies that I contract

365
00:29:20,090 --> 00:29:24,178
in this case that it's safe to use it
you know so do you back and no change to

366
00:29:24,179 --> 00:29:26,919
basically read the data from the
database passage for the sanitizer and

367
00:29:26,919 --> 00:29:30,169
then we have the right type to stick
into this domain object and everything

368
00:29:30,169 --> 00:29:34,080
trickles through and everybody's happy
and it it just works now we look at this

369
00:29:34,080 --> 00:29:39,480
from the perspective of security viewer
gets very interesting because there's

370
00:29:39,480 --> 00:29:42,570
not very little for us to look at to
establish the property that these

371
00:29:42,570 --> 00:29:46,950
applications for your excess because
what we need to do is we look at their

372
00:29:46,950 --> 00:29:51,109
compiler configuration make sure they
are using our site listing rules and we

373
00:29:51,109 --> 00:29:54,699
we we double check that they don't have
any extra entries on the white list

374
00:29:54,700 --> 00:29:59,769
basically but if we don't see that then
we know that their JavaScript franco's

375
00:29:59,769 --> 00:30:03,149
not using assignments dinner HTML so
there's nothing for us to look at

376
00:30:03,149 --> 00:30:07,100
we know that the only way they can still
render into the DOM is using safe

377
00:30:07,100 --> 00:30:10,230
rappers such as for instance using
strict template systems or these other

378
00:30:10,230 --> 00:30:15,320
types of API's we don't have to look at
that the types of flow through the

379
00:30:15,320 --> 00:30:18,109
system we don't really have to look at
that the only thing we actually have to

380
00:30:18,109 --> 00:30:24,789
look at is to direct vent into code that
makes conversion from a plane strength

381
00:30:24,789 --> 00:30:29,070
to this type because that's really the
security sensitive operation where

382
00:30:29,070 --> 00:30:31,230
basically claiming that

383
00:30:31,230 --> 00:30:35,360
string actually has a type contract this
case the only place where we see this

384
00:30:35,360 --> 00:30:40,699
user is actually this common library
that or even viewed obviously and so we

385
00:30:40,700 --> 00:30:44,790
don't have anything to look at where we
effectively are now in the position

386
00:30:44,790 --> 00:30:49,418
instead of having to read pretty much
the entire all the front-end code and

387
00:30:49,419 --> 00:30:53,000
reason about these complicated data
flows we're pretty much done with

388
00:30:53,000 --> 00:30:56,080
looking for exercise in like 15 minutes
right because all we need to do is make

389
00:30:56,080 --> 00:30:59,220
sure that they are hearing that they
have the study checks in place to adhere

390
00:30:59,220 --> 00:31:05,280
to the guidelines and we have to look if
they have any application specific fan

391
00:31:05,280 --> 00:31:09,230
in into these unchecked conversion
methods that blesses string as one of

392
00:31:09,230 --> 00:31:13,030
those types and if they don't there's
really no way for the application code

393
00:31:13,030 --> 00:31:17,299
to be responsible for a Nexus S so
there's nothing for us to look at this

394
00:31:17,299 --> 00:31:23,139
is really very compelling because it it
actually makes our code review task

395
00:31:23,140 --> 00:31:26,380
tractable gotta get up a little bit I
think

396
00:31:32,200 --> 00:31:35,720
so in terms of practical application we
basically implemented as we implement a

397
00:31:35,720 --> 00:31:40,289
strict contextual tempting systems in a
couple of template systems including

398
00:31:40,289 --> 00:31:45,330
some open source ones there's also a
couple of internal ones and then work

399
00:31:45,330 --> 00:31:50,029
with some flax products Google+ gmail
and so on

400
00:31:50,029 --> 00:31:55,000
to up adopt this approach and the oxygen
a lot of work to refactor the existing

401
00:31:55,000 --> 00:32:01,990
front-end code to follow this coding
guidelines and we did see very drastic

402
00:32:01,990 --> 00:32:05,909
reduction in bugs right so bugs are
excess stocks are pretty pretty

403
00:32:05,909 --> 00:32:10,299
prevalent we probably across all go
several hundreds every year and then we

404
00:32:10,299 --> 00:32:14,190
saw that in these applications that
adopted this approach there but count

405
00:32:14,190 --> 00:32:18,080
went down drastically right so in one of
those cases they had something like

406
00:32:18,080 --> 00:32:22,529
thirty exercise in 2011 and then took
them like a year or whatever to to the

407
00:32:22,529 --> 00:32:27,990
recycler in overtime and then they
really have had no approximately zero so

408
00:32:27,990 --> 00:32:33,610
I'm watching a little bit exercise since
2013 after they were done with us

409
00:32:34,240 --> 00:32:39,580
the fudge is due to the fact that there
were some exercise but they were ones

410
00:32:39,580 --> 00:32:44,830
where you basically are still within the
confines of our goal which is to make it

411
00:32:44,830 --> 00:32:48,658
so that application code cannot be
responsible for exercise so we had we

412
00:32:48,659 --> 00:32:51,409
had one or two where there was actually
about in one of these infrastructure

413
00:32:51,409 --> 00:32:54,870
libraries and the template system and
then there's a couple other classes of

414
00:32:54,870 --> 00:32:59,330
exercise that are not related to
rendering HTML markup the use of the DOM

415
00:32:59,330 --> 00:33:02,250
API so things like rendering

416
00:33:02,250 --> 00:33:10,170
entrusted data in your domain without
the right stuff right so we've had a

417
00:33:10,170 --> 00:33:13,980
couple of those but they're sort of
outside of the scope of this effort but

418
00:33:13,980 --> 00:33:21,410
within in terms of bugs that were really
you know that would have been there and

419
00:33:21,410 --> 00:33:26,510
would have been the fault of application
code that's engaged in rendering you I

420
00:33:26,510 --> 00:33:30,320
really haven't had any after that this
has been about it so this is pretty nice

421
00:33:30,320 --> 00:33:36,870
course are in the last couple of minutes
I just wanted to summarize and

422
00:33:36,870 --> 00:33:43,820
extrapolate a little bit on some of the
approaches to the API design that

423
00:33:43,820 --> 00:33:50,399
underlies this this this work basically
what it comes down to is that we're

424
00:33:50,400 --> 00:33:58,010
introducing these these guys that are
designed to make it impossible for kind

425
00:33:58,010 --> 00:34:01,950
code for application called built on top
of them to have certain specific classes

426
00:34:01,950 --> 00:34:05,090
of security bugs right so what we're
doing with that is that we're

427
00:34:05,090 --> 00:34:09,219
effectively eliminating the potential
for bugs that are otherwise was there

428
00:34:09,219 --> 00:34:14,620
because the underlying originally I had
a potential bug in every single one of

429
00:34:14,620 --> 00:34:19,918
its uses so all over the application and
we're now eliminating that potential for

430
00:34:19,918 --> 00:34:23,699
those bags because he is being used that
simply doesn't allow the bug to occur

431
00:34:23,699 --> 00:34:29,629
and so we're done effectively is we've
eliminated these this bug potential from

432
00:34:29,629 --> 00:34:33,730
all the application code and have
confined it in the implementation of

433
00:34:33,730 --> 00:34:39,190
those API is right there still of course
potential bugs there but it has to be in

434
00:34:39,190 --> 00:34:42,860
the code that implements as if you guys
which is sort of you could think of it

435
00:34:42,860 --> 00:34:48,700
as the trusted computing base base with
respect to this particular property and

436
00:34:48,699 --> 00:34:52,839
so this of course then in in practice in
large-scale application constitutes a

437
00:34:52,840 --> 00:34:56,960
huge reduction of potential for bauxite
because previously we had potential bugs

438
00:34:56,960 --> 00:35:01,030
all over application code and now we
just have them inside the API which is a

439
00:35:01,030 --> 00:35:04,340
very small fraction of the code base and
then as we've seen in particular in the

440
00:35:04,340 --> 00:35:07,369
case of excess is really results results
in a

441
00:35:07,369 --> 00:35:11,720
pretty drastic reduction in many cases
of the actual bugs that we see resulting

442
00:35:11,720 --> 00:35:20,749
from that potential a key principle in
the design of these API's is that we API

443
00:35:20,749 --> 00:35:25,939
designer don't allow us don't allow
ourselves to make any unsupported

444
00:35:25,940 --> 00:35:31,230
assumptions about data that comes across
the EPI boundary to us so in particular

445
00:35:31,230 --> 00:35:35,490
we're not allowed to make any
assumptions whatsoever about values of

446
00:35:35,490 --> 00:35:40,529
basic types in particular strengths
which in turn means that if we get a

447
00:35:40,529 --> 00:35:45,299
string and we're using it inside the API
in a context that is prone to injection

448
00:35:45,299 --> 00:35:50,249
for instance it's strange that way then
using in an HTML element or something

449
00:35:50,249 --> 00:35:54,149
like that we are responsible for taking
that data and making it safe right

450
00:35:54,150 --> 00:35:58,670
solely responsible for applying the
necessary runtime validation or escaping

451
00:35:58,670 --> 00:36:01,660
or whatever is necessary to make the
data say it's it's our responsibility

452
00:36:01,660 --> 00:36:06,859
it's no longer the responsibility of our
client and we're not allowed to make any

453
00:36:06,859 --> 00:36:12,049
assumptions about our clients doing the
right thing sort of on their own basis

454
00:36:12,049 --> 00:36:15,609
right because we've seen that asking
developers to do that just doesn't work

455
00:36:15,609 --> 00:36:20,880
so it sits squarely on us what's
interesting is it might think this

456
00:36:20,880 --> 00:36:24,940
results in a lot of extra overhead but
actually really doesn't because this

457
00:36:24,940 --> 00:36:29,599
runtime escaping which is more for the
most part what we're talking about is

458
00:36:29,599 --> 00:36:32,749
something that anyway has to take place
so it doesn't really matter if the data

459
00:36:32,749 --> 00:36:36,899
is trusted and untrusted if we're taking
a string that presents represents text

460
00:36:36,900 --> 00:36:42,009
and we're using it in an HTML element we
have to HTML escape it if it's not if

461
00:36:42,009 --> 00:36:45,609
it's a trusted string if it's a string
that's controlled by the application for

462
00:36:45,609 --> 00:36:48,839
getting that results not in a security
about but it could still result in a

463
00:36:48,839 --> 00:36:52,269
rendering era because we're not escaping
so correctly right so anyway have to

464
00:36:52,269 --> 00:36:57,279
escape anyway and we have to escape the
data irrespective of whether or not it

465
00:36:57,279 --> 00:37:00,279
came from an untrusted source of it came
from a trusted source and this is sort

466
00:37:00,279 --> 00:37:04,130
of mostly the case which means we're not
actually doing a lot of extra work which

467
00:37:04,130 --> 00:37:08,920
is moving where that works takes place
and who's responsible for it right

468
00:37:08,920 --> 00:37:11,789
previously it was sort of the
responsibility of the application code

469
00:37:11,789 --> 00:37:16,680
to do this somewhere and now it's just
basically our job at CBS job the other

470
00:37:16,680 --> 00:37:19,499
sort of interesting things I think about
is that this is sort of this approach is

471
00:37:19,499 --> 00:37:20,209
kind of a

472
00:37:20,210 --> 00:37:26,470
do all to the change tracking approach
that is usually used to think about

473
00:37:26,470 --> 00:37:30,439
injection problems I'd injection
problems are really problems related to

474
00:37:30,440 --> 00:37:34,670
untrustworthy data flow that comes from
somewhere and then makes it an injection

475
00:37:34,670 --> 00:37:38,820
injection sink where causes trouble and
so it's natural to think about this in

476
00:37:38,820 --> 00:37:43,420
terms of techniques that rely on
tracking that tent right so we have

477
00:37:43,420 --> 00:37:48,210
static analysis which is basically
studying whole program analysis and we

478
00:37:48,210 --> 00:37:53,760
have maybe dynamic tension alice's but
it turns out that is actually not a very

479
00:37:53,760 --> 00:37:57,080
efficient way to approach this problem
because in an interesting application

480
00:37:57,080 --> 00:38:00,470
most of the variables that float around
are you there

481
00:38:00,470 --> 00:38:02,939
entrust the data right so we're
basically trying to track all these

482
00:38:02,940 --> 00:38:06,760
various variables that are coming
through very very complex whole system

483
00:38:06,760 --> 00:38:11,750
data flows and so we're setting us up
for a very very intractable problem and

484
00:38:11,750 --> 00:38:15,089
what we're doing here is sort of the
exact opposite we're just assuming that

485
00:38:15,089 --> 00:38:18,910
everything that gets to the API unless
proven otherwise is potentially unsafe

486
00:38:18,910 --> 00:38:23,080
and we just deal with it at runtime it's
a much much simpler approach that it

487
00:38:23,080 --> 00:38:25,580
also gives us more rigorous guarantees
because it is something that we can

488
00:38:25,580 --> 00:38:30,339
reliably whereas hope program changing
is is is basically always a heuristic

489
00:38:30,339 --> 00:38:34,560
right i mean we can't we can't do it
reliably and now we get to the unless

490
00:38:34,560 --> 00:38:35,640
proven otherwise

491
00:38:35,640 --> 00:38:39,980
aspect because there are some cases
where our API actually has to make

492
00:38:39,980 --> 00:38:43,320
assumptions about the data because
otherwise it just wouldn't be able to do

493
00:38:43,320 --> 00:38:47,740
what we expect from it and the way we do
this is through these types right so we

494
00:38:47,740 --> 00:38:54,750
use types to substantiate assumptions
about data that comes into the FBI and

495
00:38:54,750 --> 00:38:58,790
so we kind of see is that basically the
type contract is sort of a mechanism

496
00:38:58,790 --> 00:39:04,700
that allows us to if you will teleport a
promise or a property of the data that

497
00:39:04,700 --> 00:39:07,970
we've established somewhere at its
source in the example of that was in the

498
00:39:07,970 --> 00:39:12,560
back end where we ran it through the
HTML sanitizer library and then we

499
00:39:12,560 --> 00:39:16,799
teleport that promise about the data all
the way to the sink where we have to

500
00:39:16,800 --> 00:39:20,099
rely on it which is in this case in the
template system where r inserting it

501
00:39:20,099 --> 00:39:25,370
into the template without without any
kind of escaping right and

502
00:39:25,370 --> 00:39:30,870
so we basically use a mechanism to allow
us to reason about the whole program

503
00:39:30,870 --> 00:39:37,210
property that there is no escaping or
validation that had to take place but

504
00:39:37,210 --> 00:39:40,580
using a mechanism that allows us to do
this without having to read the whole

505
00:39:40,580 --> 00:39:44,610
program right so we can we basically
used types to give us a reform of local

506
00:39:44,610 --> 00:39:49,100
reasoning to establish whole program
properties and that's why I think it

507
00:39:49,100 --> 00:39:54,540
pretty pretty powerful mechanism there's
of course one key assumption in there

508
00:39:54,540 --> 00:39:59,440
which is that these types of integrity
right so we rely on no application codes

509
00:39:59,440 --> 00:40:03,670
digging behind the public API's of these
types and messing with their internal

510
00:40:03,670 --> 00:40:07,380
isn't just you know writing an arbitrary
string into the strength that trapped

511
00:40:07,380 --> 00:40:11,440
inside a city that's generally a
reasonable assumption because our model

512
00:40:11,440 --> 00:40:14,510
for this is that the developers not
actually militias they're they're just

513
00:40:14,510 --> 00:40:17,170
human and make mistakes right so we're
not worried about developers that

514
00:40:17,170 --> 00:40:21,740
actively try to subvert this situation
where people were getting a little bit

515
00:40:21,740 --> 00:40:28,560
overly creative but you know we deal
with that on a case-by-case basis just a

516
00:40:28,560 --> 00:40:32,140
few words about these sort of practical
ability usability of this the

517
00:40:32,140 --> 00:40:36,920
practicality of this approach is of
course key right i mean this homework

518
00:40:36,920 --> 00:40:42,380
will be pointless if it wasn't usable in
real-world software development one

519
00:40:42,380 --> 00:40:48,360
thing that i think is key for this is
that we we we've come up with API is

520
00:40:48,360 --> 00:40:53,540
that are very similar in terms of the
API itself and result including patterns

521
00:40:53,540 --> 00:40:58,190
as originally a sequel case for instance
we're still allowing the developer to

522
00:40:58,190 --> 00:41:01,650
use string concatenation to build it
frees the code really has exacted

523
00:41:01,650 --> 00:41:04,820
structure as before just adding this
little constrained to make sure that

524
00:41:04,820 --> 00:41:08,430
these stick to the best practice of
always using bind parameters and using

525
00:41:08,430 --> 00:41:14,029
queries that are themselves trustworthy
same thing in the in the excess case

526
00:41:14,030 --> 00:41:17,470
template system is the same one that the
use before so for instance closure

527
00:41:17,470 --> 00:41:22,209
templates we just strengthened its
properties in terms of the escaping that

528
00:41:22,210 --> 00:41:24,869
it applies to all the data and we made
sort of a

529
00:41:24,869 --> 00:41:28,339
very simple and straightforward contract
between the template and its users which

530
00:41:28,339 --> 00:41:32,970
has the templates always responsible for
security properties for absence of

531
00:41:32,970 --> 00:41:41,038
excess other aspect is that there is
always going to be exceptions and so we

532
00:41:41,039 --> 00:41:46,210
chose not to try and make the primary
API more complex to accommodate all

533
00:41:46,210 --> 00:41:50,109
these exceptions which kept this very
simple in the case of the sequel example

534
00:41:50,109 --> 00:41:55,900
it was basically utterly trivial and
instead we just rely on a lightweight

535
00:41:55,900 --> 00:41:58,849
mechanism to accommodate these
exceptions where we allow developers to

536
00:41:58,849 --> 00:42:03,420
use the previous effectively
unconstrained API but make it subject to

537
00:42:03,420 --> 00:42:07,710
a mandatory review and if that doesn't
happen very often it's alright so for

538
00:42:07,710 --> 00:42:13,430
instance in the sequel realm it's
basically like you know probably three

539
00:42:13,430 --> 00:42:17,098
percent of my time to take care of this
for the whole company because I get like

540
00:42:17,099 --> 00:42:21,089
a question about this doctor ABI
whatever every couple of weeks and then

541
00:42:21,089 --> 00:42:24,369
have the time they need it at the time
they don't be talkin and that's it right

542
00:42:24,369 --> 00:42:30,589
so it's very lightweight the other thing
that we found to be very helpful is that

543
00:42:30,589 --> 00:42:35,259
in this approach we are surfacing
aerostat pertain to potential security

544
00:42:35,259 --> 00:42:39,579
bugs at compile time so that most of the
time these are just tight areas that

545
00:42:39,579 --> 00:42:45,420
happened from incorrect typing correct
usage of an API or it could be you know

546
00:42:45,420 --> 00:42:50,089
this incorrect use of this API that once
upon a time constant expression which

547
00:42:50,089 --> 00:42:53,849
really is kind of a it's a custom type
out his nephew also it smells like it hi

548
00:42:53,849 --> 00:42:58,579
there it's very easy for developers
understand its compiler that they used

549
00:42:58,579 --> 00:43:03,390
to getting anyway and it's it's also
very clear-cut right it's not like a

550
00:43:03,390 --> 00:43:06,799
potential but that you getting from some
tool that comes on later on after

551
00:43:06,799 --> 00:43:10,960
checking the code and then the data
analysis ran on it and then you have to

552
00:43:10,960 --> 00:43:14,480
deal with these potential issues you're
just using the API wrong the

553
00:43:14,480 --> 00:43:17,369
documentation says you're supposed to
give it a compile-time constant

554
00:43:17,369 --> 00:43:21,119
expression you didn't it's it's a clear
coherent and so that makes it very

555
00:43:21,119 --> 00:43:25,039
straightforward for developers to reason
about and also you don't get into the

556
00:43:25,039 --> 00:43:28,390
situation where cause already checked in
and then you have a potential bug and

557
00:43:28,390 --> 00:43:31,180
then you have to argue with people
whether or not that merits

558
00:43:31,180 --> 00:43:34,629
refectory right it's it never even get
that far because it never even compile

559
00:43:34,630 --> 00:43:39,980
so that's actually I think very helpful
in practice and then finally there is

560
00:43:39,980 --> 00:43:44,140
sort of another angle to look at this
which is this is really about designed

561
00:43:44,140 --> 00:43:50,049
for reader review ability by which I
mean so their property if you will

562
00:43:50,050 --> 00:43:53,619
how much of an overall applications
codebase throughout you have to look at

563
00:43:53,619 --> 00:43:57,430
you have to understand and analyze and
reason about to establish a particular

564
00:43:57,430 --> 00:44:01,259
property of the whole program in this
case absence of a particular classifieds

565
00:44:01,260 --> 00:44:05,550
absence of sequence action absence of
exercise how much of the whole quarter

566
00:44:05,550 --> 00:44:09,230
after read and sort of thinking about
this practically if the answer to that

567
00:44:09,230 --> 00:44:12,790
question is asked to read a pretty good
chunk of the overall app right of the

568
00:44:12,790 --> 00:44:17,910
application code then this is just not
going to work because it's a lot of code

569
00:44:17,910 --> 00:44:21,879
I don't have time to read it I have i
dont have tools that really can

570
00:44:21,880 --> 00:44:25,980
understand it accurately and it's
constantly changing underneath of me and

571
00:44:25,980 --> 00:44:30,670
so that approach really just makes it
almost inevitable that there will be

572
00:44:30,670 --> 00:44:38,270
bugs raised in this case we end up with
by design a situation where the Dakota

573
00:44:38,270 --> 00:44:42,190
you to review is the implementations of
the API which is a very very small

574
00:44:42,190 --> 00:44:46,809
fraction of the code base and so we we
actually end up in a situation where

575
00:44:46,809 --> 00:44:52,770
it's possible for us to read all the
coat in depth and analyzed in depth and

576
00:44:52,770 --> 00:44:57,720
test and do whatever we need to do to
get confidence in its correctness for

577
00:44:57,720 --> 00:45:01,520
the code that is responsible for
avoiding the bug which is the

578
00:45:01,520 --> 00:45:08,099
implementations of these APIC template
system that's equal period older and so

579
00:45:08,099 --> 00:45:11,960
we we basically are now in a situation
where we can be very very

580
00:45:14,609 --> 00:45:19,380
sort of in-depth review the code that is
that pertains to that particular

581
00:45:19,380 --> 00:45:24,690
classifieds and hence we can get high
confidence assessment out of that where

582
00:45:24,690 --> 00:45:28,170
as in the previous case we kind of had
to sort of hope we kind of caught some

583
00:45:28,170 --> 00:45:32,440
of the bugs in the pay gap that we kind
of read part of it right and so it's a

584
00:45:32,440 --> 00:45:38,470
it's a very very different game without
and with that I'm done time for a few

585
00:45:38,470 --> 00:45:46,098
questions as I mentioned a bunch of this
work is is in open source projects or

586
00:45:46,099 --> 00:45:49,579
there's budget template systems that
we're open source and so that the code

587
00:45:49,579 --> 00:45:52,980
we added to it is is there as well I
think these lights will be published

588
00:45:52,980 --> 00:45:59,380
these all links to the respective pages
and without its time for a couple of

589
00:45:59,380 --> 00:46:02,380
questions

590
00:46:18,900 --> 00:46:27,240
rely on on types and statically typed
languages not really I'm so in fact

591
00:46:27,240 --> 00:46:31,089
included templates is dynamically typed
so the decision whether or not the

592
00:46:31,089 --> 00:46:34,770
values of types if it's a male or a
plain string and then handsets be

593
00:46:34,770 --> 00:46:39,960
escaped happens at runtime all we need
is that these types are reasonably well

594
00:46:39,960 --> 00:46:44,500
encapsulated so and that sort of depends
a lot on the idiomatic lose you saw the

595
00:46:44,500 --> 00:46:47,589
language rights or incident in Java
somebody could use reflection to poke

596
00:46:47,589 --> 00:46:51,619
inside those types but you don't really
see reflection based coating application

597
00:46:51,619 --> 00:46:54,220
code if you send out for code review
somebody will go after you with a big

598
00:46:54,220 --> 00:46:57,919
stick right now in other languages I'm
not familiar with Ruby all that much but

599
00:46:57,920 --> 00:47:02,880
from what I can tell you is like the use
of nixon's is pretty pretty sort of

600
00:47:02,880 --> 00:47:06,390
romantic and so therefore it's kind of
more likely that maybe somebody will

601
00:47:06,390 --> 00:47:10,000
write code that cracks open type and
then at behavior toward that actually

602
00:47:10,000 --> 00:47:15,500
makes it unsafe and violates the
contract but but there is no inherent

603
00:47:15,500 --> 00:47:19,650
reliance on static typing I'm personally
a big fan of static typing because you

604
00:47:19,650 --> 00:47:23,410
get your your errands earlier right but
if you like to live dangerously and only

605
00:47:23,410 --> 00:47:27,578
find out at runtime that you have to
type it still works right i mean just

606
00:47:27,579 --> 00:47:30,579
know later in the stage of development

607
00:47:40,510 --> 00:47:47,930
so this is interesting so basically the
the the property we needed to enforce is

608
00:47:47,930 --> 00:47:53,339
that the actual parameter to a
particular method is a compile-time

609
00:47:53,340 --> 00:47:56,790
constant expression and we couldn't find
a way of expressing this in the Java

610
00:47:56,790 --> 00:48:00,690
type system if anybody can think of one
at the happy to hear it but it turns out

611
00:48:00,690 --> 00:48:06,120
we were actually able to do it in C++
and then go there's like some obscure

612
00:48:06,120 --> 00:48:10,609
ways that will hopefully at some point
open source that let you do this in in

613
00:48:10,610 --> 00:48:16,360
C++ he also relied on so clang clang
compiler has this enable if attribute

614
00:48:16,360 --> 00:48:20,110
which the clan custom thing that
actually kind of allows you to express

615
00:48:20,110 --> 00:48:24,850
this property in a somewhat convoluted
way but it it works and then goal there

616
00:48:24,850 --> 00:48:28,819
some trick with I forget exactly exactly
exactly exactly how it works but there

617
00:48:28,820 --> 00:48:34,270
some trick with package visibility that
allows you to make a type that cannot be

618
00:48:34,270 --> 00:48:39,240
constructed that is basically a strain
but it cannot be constructed by code

619
00:48:39,240 --> 00:48:44,509
that's not in the same package and so
you can you can basically a property but

620
00:48:44,510 --> 00:48:47,510
in Java couldn't so we need to resort to
a custom checker

621
00:49:01,690 --> 00:49:06,510
yeah that's a good question so the
question is what control do you have

622
00:49:06,510 --> 00:49:11,250
over the library is that people are
using I think that is one of the

623
00:49:11,250 --> 00:49:15,900
advantage we have a Google is that all
development comes out of a single large

624
00:49:15,900 --> 00:49:24,580
repository and that allows us to to keep
some leftover what's being used right so

625
00:49:24,580 --> 00:49:28,950
there is basically a process for
importing for instance third-party

626
00:49:28,950 --> 00:49:32,980
libraries that involves people that
check about the license and archived

627
00:49:32,980 --> 00:49:35,930
stuff but the security team is plugged
into that so for instance somebody went

628
00:49:35,930 --> 00:49:43,629
and wanted to introduce another sequel
or AIM later or another template system

629
00:49:43,630 --> 00:49:48,870
we kind of get to at least say that
that's happening and then in some cases

630
00:49:48,870 --> 00:49:55,440
we either find that we need to deal with
it and and argue with them tonight do

631
00:49:55,440 --> 00:49:59,050
that or find an alternative solution or
maybe in their particular case it's okay

632
00:49:59,050 --> 00:50:03,390
and then we we often use this mechanism
that have mentioned build visibility

633
00:50:03,390 --> 00:50:07,359
which allows you to whitelist users of a
particular package right so he said okay

634
00:50:07,360 --> 00:50:11,350
fine you're an internal tool use your
favorite template system it's not really

635
00:50:11,350 --> 00:50:17,569
worth our time to to deal with that but
before anyone wants uses in a external

636
00:50:17,570 --> 00:50:21,040
facing application they have to get on
that widely-used and you know we put a

637
00:50:21,040 --> 00:50:23,700
comment there says please talk to the
security team and usually the owners of

638
00:50:23,700 --> 00:50:27,660
these things are responsible and do that
so there is some sort of makes a process

639
00:50:27,660 --> 00:50:34,870
and just hoping that people are
reasonable and and some speed bumps if

640
00:50:34,870 --> 00:50:39,720
you are our measures in the system
itself for that

641
00:50:49,770 --> 00:50:50,730
thank you

