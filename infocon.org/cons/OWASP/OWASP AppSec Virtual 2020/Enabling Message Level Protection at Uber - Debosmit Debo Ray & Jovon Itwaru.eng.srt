1
00:00:00,260 --> 00:00:17,990
[Music]

2
00:00:19,279 --> 00:00:20,880
hello everyone thank you for joining us

3
00:00:20,880 --> 00:00:21,840
today

4
00:00:21,840 --> 00:00:23,600
we're going to be talking about how to

5
00:00:23,600 --> 00:00:25,359
protect data

6
00:00:25,359 --> 00:00:27,359
and what we did to accomplish that

7
00:00:27,359 --> 00:00:30,359
mission

8
00:00:30,800 --> 00:00:32,640
so quick introduction my name is joe

9
00:00:32,640 --> 00:00:34,800
vaughn i'm from uber i'm a security

10
00:00:34,800 --> 00:00:36,880
engineer what i like to do is hang off

11
00:00:36,880 --> 00:00:38,559
my two kids they're pretty much monsters

12
00:00:38,559 --> 00:00:41,040
but i love them i also like spicy food

13
00:00:41,040 --> 00:00:43,120
and rehabbing gross properties and make

14
00:00:43,120 --> 00:00:44,559
them look good

15
00:00:44,559 --> 00:00:46,480
my co-presenter his name is debbo he's

16
00:00:46,480 --> 00:00:48,559
pretty smart guy he really enjoys

17
00:00:48,559 --> 00:00:51,680
cooking and eating he's okay at tennis

18
00:00:51,680 --> 00:00:53,760
and he likes to beat up his computers in

19
00:00:53,760 --> 00:00:55,520
his spare time and make him do things

20
00:00:55,520 --> 00:00:58,920
they shouldn't do

21
00:00:59,120 --> 00:01:01,120
so why are we here

22
00:01:01,120 --> 00:01:02,399
like we said we're going to be talking

23
00:01:02,399 --> 00:01:04,559
about message protection and so what

24
00:01:04,559 --> 00:01:07,040
you'll see on the screen is our agenda

25
00:01:07,040 --> 00:01:09,680
and at a high level how do we actually

26
00:01:09,680 --> 00:01:11,600
accomplish this essentially what i like

27
00:01:11,600 --> 00:01:14,799
to do is frame a story of how we

28
00:01:14,799 --> 00:01:15,840
looked at

29
00:01:15,840 --> 00:01:17,360
protecting messages

30
00:01:17,360 --> 00:01:20,400
and how we took this idea looked at what

31
00:01:20,400 --> 00:01:22,560
was out there

32
00:01:22,560 --> 00:01:24,320
changed that up for our environment and

33
00:01:24,320 --> 00:01:26,400
then actually implemented a solution and

34
00:01:26,400 --> 00:01:27,759
then along the way we'll talk about some

35
00:01:27,759 --> 00:01:29,840
of the challenges we faced and what

36
00:01:29,840 --> 00:01:33,200
we're going to do in the future

37
00:01:34,479 --> 00:01:36,960
so let's start with the beginning

38
00:01:36,960 --> 00:01:40,240
what exactly is message level encryption

39
00:01:40,240 --> 00:01:42,560
so message level encryption is kind of a

40
00:01:42,560 --> 00:01:44,240
vague or broad term

41
00:01:44,240 --> 00:01:45,040
but

42
00:01:45,040 --> 00:01:46,079
let's just

43
00:01:46,079 --> 00:01:47,600
scope this down a little bit so we can

44
00:01:47,600 --> 00:01:49,040
talk about this problem and how we

45
00:01:49,040 --> 00:01:50,960
intend to solve it

46
00:01:50,960 --> 00:01:53,600
at uber we handle lots of data ranging

47
00:01:53,600 --> 00:01:54,880
from

48
00:01:54,880 --> 00:01:57,759
someone's address someone's name their

49
00:01:57,759 --> 00:01:59,520
phone number all the way up to their

50
00:01:59,520 --> 00:02:00,880
health data

51
00:02:00,880 --> 00:02:02,799
correspondingly we handle credit card

52
00:02:02,799 --> 00:02:04,479
information and also government

53
00:02:04,479 --> 00:02:05,920
identifiers

54
00:02:05,920 --> 00:02:07,439
for us it's extremely important to make

55
00:02:07,439 --> 00:02:09,280
sure this data is protected as it goes

56
00:02:09,280 --> 00:02:12,160
throughout our network

57
00:02:12,400 --> 00:02:15,200
we'll also like to talk about is

58
00:02:15,200 --> 00:02:16,959
how does that what are the impacts of

59
00:02:16,959 --> 00:02:19,120
message level encryption where do we

60
00:02:19,120 --> 00:02:20,800
decide to implement message level

61
00:02:20,800 --> 00:02:22,720
encryption and how it's actually helped

62
00:02:22,720 --> 00:02:25,680
us in our environment

63
00:02:27,280 --> 00:02:29,200
so what are we trying to do

64
00:02:29,200 --> 00:02:30,319
um

65
00:02:30,319 --> 00:02:32,319
we we have this notion of sensitive data

66
00:02:32,319 --> 00:02:33,920
i think every large organization even

67
00:02:33,920 --> 00:02:36,080
small organizations handle sensitive

68
00:02:36,080 --> 00:02:38,160
data what do you do with it we've all

69
00:02:38,160 --> 00:02:39,680
seen these

70
00:02:39,680 --> 00:02:40,560
these

71
00:02:40,560 --> 00:02:43,200
uh news articles and and stories in the

72
00:02:43,200 --> 00:02:45,360
news where this large organization was

73
00:02:45,360 --> 00:02:47,440
hacked and someone got to their database

74
00:02:47,440 --> 00:02:48,879
and then all the passwords were there or

75
00:02:48,879 --> 00:02:50,080
all the credit card numbers were there

76
00:02:50,080 --> 00:02:52,000
in plain text so we don't want to be in

77
00:02:52,000 --> 00:02:53,280
that situation

78
00:02:53,280 --> 00:02:55,440
so what are we trying to accomplish one

79
00:02:55,440 --> 00:02:56,959
of the goals here is to protect our

80
00:02:56,959 --> 00:02:59,920
sensitive data at rest and that means a

81
00:02:59,920 --> 00:03:01,440
lot of things but for us it means

82
00:03:01,440 --> 00:03:03,440
protecting our data as it's stored in

83
00:03:03,440 --> 00:03:05,200
our data stores and as it moves through

84
00:03:05,200 --> 00:03:07,120
our logging systems

85
00:03:07,120 --> 00:03:08,720
the second goal

86
00:03:08,720 --> 00:03:10,239
of this solution is to make sure it's

87
00:03:10,239 --> 00:03:12,400
secure so while we can do encryption

88
00:03:12,400 --> 00:03:14,800
arbitrarily what we'd like to do is do

89
00:03:14,800 --> 00:03:18,239
proper encryption proper crypto so do we

90
00:03:18,239 --> 00:03:21,840
use aes cbc or ebc or do we use more

91
00:03:21,840 --> 00:03:24,400
authenticated encryptions such as aes

92
00:03:24,400 --> 00:03:26,159
gcm

93
00:03:26,159 --> 00:03:28,000
um in addition to that how do we choose

94
00:03:28,000 --> 00:03:30,560
same defaults for the algorithms and

95
00:03:30,560 --> 00:03:32,159
also the key material that support those

96
00:03:32,159 --> 00:03:33,840
algorithms

97
00:03:33,840 --> 00:03:36,560
thirdly we want a simple api

98
00:03:36,560 --> 00:03:38,720
the reason we want a simple api api is

99
00:03:38,720 --> 00:03:40,080
because we want our developers and

100
00:03:40,080 --> 00:03:42,799
engineers to use this product and not

101
00:03:42,799 --> 00:03:44,720
have any issues with it and what do i

102
00:03:44,720 --> 00:03:48,720
mean by that if if crypto is too complex

103
00:03:48,720 --> 00:03:50,720
that means there's more opportunity to

104
00:03:50,720 --> 00:03:52,799
make a mistake or make an error

105
00:03:52,799 --> 00:03:54,000
if there's too many knobs and

106
00:03:54,000 --> 00:03:56,319
configuration devices that means someone

107
00:03:56,319 --> 00:03:58,720
might make a configuration choice that

108
00:03:58,720 --> 00:04:01,200
would have adverse effects to their data

109
00:04:01,200 --> 00:04:03,360
and to their service and so what we want

110
00:04:03,360 --> 00:04:04,720
to do is make it very simple for

111
00:04:04,720 --> 00:04:06,159
engineers to

112
00:04:06,159 --> 00:04:08,480
spend time doing the work they do and

113
00:04:08,480 --> 00:04:10,159
then be able to encrypt data in a very

114
00:04:10,159 --> 00:04:11,599
easy manner

115
00:04:11,599 --> 00:04:14,640
last we want to make sure that there is

116
00:04:14,640 --> 00:04:16,798
scalability flexibility and adaptability

117
00:04:16,798 --> 00:04:18,238
let's just bucket that into something

118
00:04:18,238 --> 00:04:20,320
called agility so

119
00:04:20,320 --> 00:04:21,918
we kind of want to look around the

120
00:04:21,918 --> 00:04:24,160
corner so in the future let's say the

121
00:04:24,160 --> 00:04:26,160
algorithm we chose today is no longer

122
00:04:26,160 --> 00:04:27,919
the algorithm algorithm we want to use

123
00:04:27,919 --> 00:04:28,880
later

124
00:04:28,880 --> 00:04:32,000
can the solution adapt to that

125
00:04:32,000 --> 00:04:33,759
also can it be performant to handle

126
00:04:33,759 --> 00:04:38,520
various workloads and various work sizes

127
00:04:42,639 --> 00:04:44,800
so we talked about it the the solution

128
00:04:44,800 --> 00:04:45,919
being simple

129
00:04:45,919 --> 00:04:47,600
and one of the reasons i want to bring

130
00:04:47,600 --> 00:04:50,000
that up is to show this example

131
00:04:50,000 --> 00:04:52,000
what we see here is a really small code

132
00:04:52,000 --> 00:04:53,759
snippet of someone encrypting

133
00:04:53,759 --> 00:04:55,600
information and

134
00:04:55,600 --> 00:04:58,000
they're passing in a key a nonce and the

135
00:04:58,000 --> 00:05:00,000
plain text itself what you'll see

136
00:05:00,000 --> 00:05:01,600
highlighted on the screen

137
00:05:01,600 --> 00:05:03,680
is that the per the user is passing in

138
00:05:03,680 --> 00:05:06,240
the nonce the same nods twice

139
00:05:06,240 --> 00:05:08,160
and so this is definitely a security

140
00:05:08,160 --> 00:05:09,600
issue you should not be using the same

141
00:05:09,600 --> 00:05:12,320
nonce with a corresponding key

142
00:05:12,320 --> 00:05:14,720
now i know that the standard library

143
00:05:14,720 --> 00:05:16,479
from all the different languages say

144
00:05:16,479 --> 00:05:18,880
don't do this however it's still an

145
00:05:18,880 --> 00:05:21,520
option the developer can still choose to

146
00:05:21,520 --> 00:05:24,560
do this whether it's unintentional or or

147
00:05:24,560 --> 00:05:25,840
they're in a rush and they need to do

148
00:05:25,840 --> 00:05:26,720
this

149
00:05:26,720 --> 00:05:28,080
and so

150
00:05:28,080 --> 00:05:29,840
what we want to do is is make this

151
00:05:29,840 --> 00:05:30,880
decision

152
00:05:30,880 --> 00:05:32,880
for the developer so they don't need to

153
00:05:32,880 --> 00:05:35,280
think about oh what knots do i use what

154
00:05:35,280 --> 00:05:36,720
size do i use so if these are different

155
00:05:36,720 --> 00:05:38,960
nods do i need to encrypt the nonce

156
00:05:38,960 --> 00:05:40,960
some of these questions are are not

157
00:05:40,960 --> 00:05:42,880
really applicable but if you don't have

158
00:05:42,880 --> 00:05:44,240
that context

159
00:05:44,240 --> 00:05:46,800
you'll you'll get stuck

160
00:05:46,800 --> 00:05:48,320
the second thing to notice is at the

161
00:05:48,320 --> 00:05:50,160
bottom we have this encrypt function

162
00:05:50,160 --> 00:05:52,320
it's very generic however the encrypt

163
00:05:52,320 --> 00:05:54,000
api is pretty simple looking right at

164
00:05:54,000 --> 00:05:55,520
first glance you pass it a couple of

165
00:05:55,520 --> 00:05:57,680
parameters it does its thing and then

166
00:05:57,680 --> 00:05:59,440
you get back cycle text

167
00:05:59,440 --> 00:06:01,360
but underneath the hood as a developer

168
00:06:01,360 --> 00:06:03,360
which mode do i choose if i'm using

169
00:06:03,360 --> 00:06:06,080
symmetric encryption and aes should i be

170
00:06:06,080 --> 00:06:09,680
using cbc gcm what key size should i use

171
00:06:09,680 --> 00:06:11,440
do i use a notch or an iv what's the

172
00:06:11,440 --> 00:06:12,960
difference and then what kind of

173
00:06:12,960 --> 00:06:15,360
strategy do i use do i need to compress

174
00:06:15,360 --> 00:06:17,120
and then encrypt do i need to mac and

175
00:06:17,120 --> 00:06:18,400
then encrypt

176
00:06:18,400 --> 00:06:21,199
which one should i choose and so

177
00:06:21,199 --> 00:06:22,800
talking about making something simple

178
00:06:22,800 --> 00:06:24,639
and reducing the friction for developers

179
00:06:24,639 --> 00:06:26,560
on board is why we want to make some of

180
00:06:26,560 --> 00:06:28,960
these choices for them and make sane

181
00:06:28,960 --> 00:06:31,440
defaults

182
00:06:33,120 --> 00:06:34,639
so we talked about some goals we showed

183
00:06:34,639 --> 00:06:36,479
an example now let's move a little bit

184
00:06:36,479 --> 00:06:39,039
more to the requirements so we we handle

185
00:06:39,039 --> 00:06:40,560
this sensitive data

186
00:06:40,560 --> 00:06:41,919
and we have requirements from third

187
00:06:41,919 --> 00:06:43,759
parties one of the third parties that we

188
00:06:43,759 --> 00:06:46,000
have just like other organizations are

189
00:06:46,000 --> 00:06:48,639
compliance regulations so for example we

190
00:06:48,639 --> 00:06:50,080
all know pci

191
00:06:50,080 --> 00:06:53,120
some of us have heard about psd2 gdpr

192
00:06:53,120 --> 00:06:54,960
so whatever this means is like since

193
00:06:54,960 --> 00:06:57,120
we're handling the sensitive data we

194
00:06:57,120 --> 00:06:59,199
need to protect it in a certain manner

195
00:06:59,199 --> 00:07:03,039
whether that's at rest or in transit

196
00:07:03,039 --> 00:07:05,360
another requirement is we touched on

197
00:07:05,360 --> 00:07:07,440
earlier about this agility notion

198
00:07:07,440 --> 00:07:10,400
so we have to have this ability to move

199
00:07:10,400 --> 00:07:12,720
the algorithm the key size different

200
00:07:12,720 --> 00:07:15,360
components without having to rework the

201
00:07:15,360 --> 00:07:17,599
entire application

202
00:07:17,599 --> 00:07:19,280
and so in our search for choosing a

203
00:07:19,280 --> 00:07:20,800
solution these are some of the things we

204
00:07:20,800 --> 00:07:22,000
kept in mind

205
00:07:22,000 --> 00:07:23,280
thirdly

206
00:07:23,280 --> 00:07:25,039
we need to figure out how we're going to

207
00:07:25,039 --> 00:07:27,120
handle the key so the key can come from

208
00:07:27,120 --> 00:07:28,960
multiple sources it can be a local

209
00:07:28,960 --> 00:07:31,599
source or it can be from a

210
00:07:31,599 --> 00:07:35,199
key management system like aws or vault

211
00:07:35,199 --> 00:07:37,440
and whatever solution we choose has to

212
00:07:37,440 --> 00:07:39,440
inter-operate between these different

213
00:07:39,440 --> 00:07:41,440
key management solutions

214
00:07:41,440 --> 00:07:42,720
lastly

215
00:07:42,720 --> 00:07:43,599
if

216
00:07:43,599 --> 00:07:46,000
someone cannot access their data we're

217
00:07:46,000 --> 00:07:47,840
in a really bad situation because it's

218
00:07:47,840 --> 00:07:49,919
quite easy to encrypt something

219
00:07:49,919 --> 00:07:51,360
but then how do you make sure that data

220
00:07:51,360 --> 00:07:53,120
is always available for an authorized

221
00:07:53,120 --> 00:07:54,160
user

222
00:07:54,160 --> 00:07:55,440
so combining these goals and

223
00:07:55,440 --> 00:07:57,919
requirements we needed a

224
00:07:57,919 --> 00:08:00,160
solution that was easy to onboard

225
00:08:00,160 --> 00:08:01,440
easy to use

226
00:08:01,440 --> 00:08:02,479
secure

227
00:08:02,479 --> 00:08:05,199
and reliable

228
00:08:08,319 --> 00:08:10,000
before we explain the process that we

229
00:08:10,000 --> 00:08:11,599
use to review the different solutions

230
00:08:11,599 --> 00:08:14,080
let's take a quick look at what the uber

231
00:08:14,080 --> 00:08:16,000
service graph looks like

232
00:08:16,000 --> 00:08:18,160
and what i want to highlight here is

233
00:08:18,160 --> 00:08:19,520
this craziness that you see on the

234
00:08:19,520 --> 00:08:20,400
screen

235
00:08:20,400 --> 00:08:22,720
is is indicative of uber it's indicative

236
00:08:22,720 --> 00:08:24,240
of our infrastructure it's indicative of

237
00:08:24,240 --> 00:08:24,960
the

238
00:08:24,960 --> 00:08:27,039
different mobile apps the different

239
00:08:27,039 --> 00:08:29,360
back-end services the web apps the the

240
00:08:29,360 --> 00:08:31,919
operational apps the data handling apps

241
00:08:31,919 --> 00:08:33,360
all these different services that make

242
00:08:33,360 --> 00:08:34,958
up the uber machine

243
00:08:34,958 --> 00:08:37,760
are depicted in some in some fashion

244
00:08:37,760 --> 00:08:39,200
here

245
00:08:39,200 --> 00:08:41,120
all these systems somehow communicate

246
00:08:41,120 --> 00:08:42,880
with each other so what does that really

247
00:08:42,880 --> 00:08:44,880
mean that means that when data such as

248
00:08:44,880 --> 00:08:46,320
someone entering their social security

249
00:08:46,320 --> 00:08:48,399
number enters our network from a mobile

250
00:08:48,399 --> 00:08:49,440
app

251
00:08:49,440 --> 00:08:50,800
it's going to traverse through different

252
00:08:50,800 --> 00:08:52,800
systems to ultimately get to that data

253
00:08:52,800 --> 00:08:54,720
store where it resides

254
00:08:54,720 --> 00:08:56,320
and so how do we make sure that this

255
00:08:56,320 --> 00:08:59,680
data is is secure through the entire

256
00:08:59,680 --> 00:09:00,880
journey

257
00:09:00,880 --> 00:09:03,040
as it gets to the data store

258
00:09:03,040 --> 00:09:05,120
another thing to consider is in addition

259
00:09:05,120 --> 00:09:07,519
to this complex environment we also have

260
00:09:07,519 --> 00:09:09,279
business functionality requirements

261
00:09:09,279 --> 00:09:11,839
where an operator and what an operator

262
00:09:11,839 --> 00:09:13,120
is is let's call it like a customer

263
00:09:13,120 --> 00:09:15,200
service agent if i'm a user and i have a

264
00:09:15,200 --> 00:09:16,720
problem i call up an operator and they

265
00:09:16,720 --> 00:09:18,480
kind of give me help

266
00:09:18,480 --> 00:09:20,080
and so in this example let's say i'm a

267
00:09:20,080 --> 00:09:22,640
driver and the customer service agent or

268
00:09:22,640 --> 00:09:24,320
operator needs access to my driver

269
00:09:24,320 --> 00:09:26,720
information to give me assistance so

270
00:09:26,720 --> 00:09:28,880
that operator needs to be able to see

271
00:09:28,880 --> 00:09:30,560
some sensitive data

272
00:09:30,560 --> 00:09:32,800
additionally data analysts how do we

273
00:09:32,800 --> 00:09:34,240
know how many trips we're going to have

274
00:09:34,240 --> 00:09:35,760
or project how many trips we're gonna

275
00:09:35,760 --> 00:09:37,920
have in a given area they need to know

276
00:09:37,920 --> 00:09:39,120
trip data

277
00:09:39,120 --> 00:09:40,880
another example would be our engineers

278
00:09:40,880 --> 00:09:43,200
let's say we're debugging our our ride

279
00:09:43,200 --> 00:09:45,519
app or our driving app and we need

280
00:09:45,519 --> 00:09:47,279
access to the event system the log

281
00:09:47,279 --> 00:09:48,959
system sometimes there's sensitive data

282
00:09:48,959 --> 00:09:52,480
there so we talk about this to then ask

283
00:09:52,480 --> 00:09:54,640
the question how do we enable this

284
00:09:54,640 --> 00:09:56,720
business functionality while protecting

285
00:09:56,720 --> 00:09:58,720
sensitive data but also minimizing

286
00:09:58,720 --> 00:10:01,200
impact to our existing infrastructure

287
00:10:01,200 --> 00:10:02,560
some of the ways we thought about this

288
00:10:02,560 --> 00:10:04,240
was like well do we just implement

289
00:10:04,240 --> 00:10:05,920
mutual tls all throughout our

290
00:10:05,920 --> 00:10:08,800
infrastructure do we use disk encryption

291
00:10:08,800 --> 00:10:11,360
you know what what exactly do we use to

292
00:10:11,360 --> 00:10:13,040
to solve this problem

293
00:10:13,040 --> 00:10:15,040
given our our complexities in our

294
00:10:15,040 --> 00:10:18,040
environment

295
00:10:19,839 --> 00:10:22,720
so what did we decide on

296
00:10:22,720 --> 00:10:25,040
is the notion of field level encryption

297
00:10:25,040 --> 00:10:26,640
and what you'll see in this depiction

298
00:10:26,640 --> 00:10:28,160
here is you'll see one record from a

299
00:10:28,160 --> 00:10:29,360
data store

300
00:10:29,360 --> 00:10:30,839
and it's a user

301
00:10:30,839 --> 00:10:33,839
record and let's just think about a user

302
00:10:33,839 --> 00:10:35,760
as having a first name a last name their

303
00:10:35,760 --> 00:10:37,600
age their address ssn this is a

304
00:10:37,600 --> 00:10:39,440
hypothetical example but we're trying to

305
00:10:39,440 --> 00:10:41,680
drive the point home is that we have

306
00:10:41,680 --> 00:10:44,079
this this large object and inside of

307
00:10:44,079 --> 00:10:45,519
this object there are certain fields

308
00:10:45,519 --> 00:10:47,040
that are sensitive

309
00:10:47,040 --> 00:10:48,560
most of the time the sensitivity is

310
00:10:48,560 --> 00:10:50,880
based on compliance or something

311
00:10:50,880 --> 00:10:52,720
around business logic but in this

312
00:10:52,720 --> 00:10:54,959
example let's say that address and ssn

313
00:10:54,959 --> 00:10:56,640
are the sensitive fields

314
00:10:56,640 --> 00:10:58,079
so what we can do here is instead of

315
00:10:58,079 --> 00:11:00,480
encrypting the entire user object we can

316
00:11:00,480 --> 00:11:02,399
encrypt certain fields within that user

317
00:11:02,399 --> 00:11:04,399
object

318
00:11:04,399 --> 00:11:06,800
some of the benefits of this is that we

319
00:11:06,800 --> 00:11:09,120
can now minimize performance costs

320
00:11:09,120 --> 00:11:10,959
because encryption is not free it

321
00:11:10,959 --> 00:11:12,720
doesn't it does incur some performance

322
00:11:12,720 --> 00:11:14,720
penalties but by encrypting certain

323
00:11:14,720 --> 00:11:17,120
fields instead of the entire object we

324
00:11:17,120 --> 00:11:20,240
can minimize that impact additionally

325
00:11:20,240 --> 00:11:22,079
if for whatever reason we've had to send

326
00:11:22,079 --> 00:11:24,079
this data over insecure communication

327
00:11:24,079 --> 00:11:26,880
channel such as http we can do that now

328
00:11:26,880 --> 00:11:29,760
because this data is encrypted

329
00:11:29,760 --> 00:11:31,120
this type of strategy is going to help

330
00:11:31,120 --> 00:11:33,200
us defend against certain attacks such

331
00:11:33,200 --> 00:11:35,120
as a disgruntled employee or some

332
00:11:35,120 --> 00:11:37,519
curious engineer trying to read the logs

333
00:11:37,519 --> 00:11:41,959
or manipulate the the network packets

334
00:11:44,079 --> 00:11:45,519
so we said that

335
00:11:45,519 --> 00:11:47,360
encryption is kind of easy and what i

336
00:11:47,360 --> 00:11:48,959
mean to say is that it's relatively

337
00:11:48,959 --> 00:11:50,240
straightforward

338
00:11:50,240 --> 00:11:51,839
when you have encryption

339
00:11:51,839 --> 00:11:53,440
when you're going to do encryption you

340
00:11:53,440 --> 00:11:55,279
pick a good algorithm you pick the

341
00:11:55,279 --> 00:11:57,839
proper key size the non-size and some of

342
00:11:57,839 --> 00:11:59,040
the other parameters and you just

343
00:11:59,040 --> 00:12:00,399
encrypt that data

344
00:12:00,399 --> 00:12:02,399
but what happens after that what are the

345
00:12:02,399 --> 00:12:04,560
impacts of encrypting data

346
00:12:04,560 --> 00:12:06,320
so some of the impacts have to do with

347
00:12:06,320 --> 00:12:08,320
performance and some of the impacts have

348
00:12:08,320 --> 00:12:10,639
to do with the actual data itself

349
00:12:10,639 --> 00:12:12,560
so when we talk about performance we can

350
00:12:12,560 --> 00:12:14,160
break those down a bit further into

351
00:12:14,160 --> 00:12:16,800
latency it's a throughput

352
00:12:16,800 --> 00:12:18,240
when we talk about latency we're talking

353
00:12:18,240 --> 00:12:20,480
about the speed

354
00:12:20,480 --> 00:12:23,200
and most services categorize speed in

355
00:12:23,200 --> 00:12:26,160
terms of p99 latency

356
00:12:26,160 --> 00:12:28,639
and so what that really means is that 99

357
00:12:28,639 --> 00:12:30,720
of all operations for a given endpoint

358
00:12:30,720 --> 00:12:33,279
during a given time take at most x

359
00:12:33,279 --> 00:12:35,200
number of milliseconds and let's give a

360
00:12:35,200 --> 00:12:36,959
concrete example to drive this home

361
00:12:36,959 --> 00:12:38,639
let's say you have this end point where

362
00:12:38,639 --> 00:12:42,160
you register a new user onto your site

363
00:12:42,160 --> 00:12:44,320
and that endpoint has a p99 of 30

364
00:12:44,320 --> 00:12:46,079
seconds 30 milliseconds

365
00:12:46,079 --> 00:12:48,560
what does that mean that means 99 of the

366
00:12:48,560 --> 00:12:51,120
time for the last 24 hours

367
00:12:51,120 --> 00:12:53,279
it's taken 30 milliseconds for that

368
00:12:53,279 --> 00:12:54,959
operation to complete

369
00:12:54,959 --> 00:12:56,480
okay cool so let's go back to our

370
00:12:56,480 --> 00:12:58,959
example when we had this user object and

371
00:12:58,959 --> 00:13:00,720
now we want to introduce this notion of

372
00:13:00,720 --> 00:13:03,440
field level encryption to the to the

373
00:13:03,440 --> 00:13:04,880
user object

374
00:13:04,880 --> 00:13:06,399
some considerations that we need to make

375
00:13:06,399 --> 00:13:09,760
is are where are the keys located

376
00:13:09,760 --> 00:13:11,360
let's say for example we store our keys

377
00:13:11,360 --> 00:13:14,160
remotely in this key management system

378
00:13:14,160 --> 00:13:16,480
well if that's the case then our latency

379
00:13:16,480 --> 00:13:18,320
is going to increase because now we need

380
00:13:18,320 --> 00:13:21,519
to make rbc calls to this kms

381
00:13:21,519 --> 00:13:23,600
authenticate to the kms retrieve the

382
00:13:23,600 --> 00:13:26,639
correct key and also that kms might do

383
00:13:26,639 --> 00:13:28,240
some auditing on their side or some

384
00:13:28,240 --> 00:13:30,880
operations on their side such as

385
00:13:30,880 --> 00:13:33,760
logging that that key request

386
00:13:33,760 --> 00:13:34,880
now that we have the key we need to

387
00:13:34,880 --> 00:13:37,120
encrypt so we say that encryption is not

388
00:13:37,120 --> 00:13:39,360
only free so depending on what algorithm

389
00:13:39,360 --> 00:13:41,519
you choose there are cycles involved in

390
00:13:41,519 --> 00:13:42,720
that as well

391
00:13:42,720 --> 00:13:45,040
so there's time added overall

392
00:13:45,040 --> 00:13:47,279
so what does that time really add up to

393
00:13:47,279 --> 00:13:49,920
is it five milliseconds ten milliseconds

394
00:13:49,920 --> 00:13:51,519
in our example we said

395
00:13:51,519 --> 00:13:53,519
our operation take uh took 30

396
00:13:53,519 --> 00:13:55,279
milliseconds so if we're adding 10

397
00:13:55,279 --> 00:13:57,760
milliseconds while that seems small

398
00:13:57,760 --> 00:13:59,760
that's pretty significant for this

399
00:13:59,760 --> 00:14:00,959
scenario

400
00:14:00,959 --> 00:14:02,880
and so what it really means is that

401
00:14:02,880 --> 00:14:06,240
these processes are this latency is tied

402
00:14:06,240 --> 00:14:09,360
very deeply to this specific service and

403
00:14:09,360 --> 00:14:13,040
contextually to the um the use case

404
00:14:13,040 --> 00:14:14,240
another thing to consider is a

405
00:14:14,240 --> 00:14:17,360
throughput so in this example throughput

406
00:14:17,360 --> 00:14:18,560
means size

407
00:14:18,560 --> 00:14:20,880
so let's go back to our registering new

408
00:14:20,880 --> 00:14:22,560
user let's say that's done the user is

409
00:14:22,560 --> 00:14:24,399
happy and

410
00:14:24,399 --> 00:14:26,240
now we need to get information about the

411
00:14:26,240 --> 00:14:28,480
user so let's say they're a driver and

412
00:14:28,480 --> 00:14:30,720
we need their driver's license and also

413
00:14:30,720 --> 00:14:32,720
their driver registration so these are

414
00:14:32,720 --> 00:14:34,399
usually come in the form of images or

415
00:14:34,399 --> 00:14:35,920
pdf documents

416
00:14:35,920 --> 00:14:37,920
and these documents can be

417
00:14:37,920 --> 00:14:40,240
varying in size some of them might be

418
00:14:40,240 --> 00:14:42,800
five megabytes maybe 10 megabytes

419
00:14:42,800 --> 00:14:44,399
and what that means is now we need to

420
00:14:44,399 --> 00:14:46,639
take this larger piece of data and we

421
00:14:46,639 --> 00:14:48,480
need to encrypt the entire thing so

422
00:14:48,480 --> 00:14:50,639
again that's increasing the amount of

423
00:14:50,639 --> 00:14:52,800
operations increasing the size and

424
00:14:52,800 --> 00:14:55,199
that's adding some complexity and stress

425
00:14:55,199 --> 00:14:57,839
on our infrastructure so between latency

426
00:14:57,839 --> 00:14:58,959
and throughput

427
00:14:58,959 --> 00:15:02,000
we might add so much latency so much

428
00:15:02,000 --> 00:15:04,399
time and duration to this operation

429
00:15:04,399 --> 00:15:06,320
where the user that was wanting to sign

430
00:15:06,320 --> 00:15:08,480
up is going to get upset because now

431
00:15:08,480 --> 00:15:10,639
this process is taking too long which

432
00:15:10,639 --> 00:15:12,560
ultimately leads to that person leaving

433
00:15:12,560 --> 00:15:13,839
our platform

434
00:15:13,839 --> 00:15:16,399
so we don't want that

435
00:15:16,399 --> 00:15:18,639
the other options are data access and

436
00:15:18,639 --> 00:15:20,480
data migrations

437
00:15:20,480 --> 00:15:22,800
so going back to that register new user

438
00:15:22,800 --> 00:15:24,399
we we added this user we encrypted their

439
00:15:24,399 --> 00:15:26,000
information and that information now

440
00:15:26,000 --> 00:15:28,000
lives in a user data store

441
00:15:28,000 --> 00:15:29,279
well what happens when we have a

442
00:15:29,279 --> 00:15:31,440
customer service rep that needs to

443
00:15:31,440 --> 00:15:33,759
provide support for that user so i'm a

444
00:15:33,759 --> 00:15:35,199
user i call up say hey listen

445
00:15:35,199 --> 00:15:36,959
something's wrong with my account i need

446
00:15:36,959 --> 00:15:38,240
help

447
00:15:38,240 --> 00:15:39,839
now that customer service rep needs

448
00:15:39,839 --> 00:15:41,680
access to that data

449
00:15:41,680 --> 00:15:43,199
and in order to get access to that data

450
00:15:43,199 --> 00:15:45,600
they need a key so what do they do in

451
00:15:45,600 --> 00:15:47,360
order to get access to that key and if

452
00:15:47,360 --> 00:15:49,199
they can't get access to the key

453
00:15:49,199 --> 00:15:52,000
then they can't do their job

454
00:15:52,000 --> 00:15:53,759
kind of in parallel we have this notion

455
00:15:53,759 --> 00:15:56,000
of data migrations so

456
00:15:56,000 --> 00:15:58,399
if when we started this project

457
00:15:58,399 --> 00:16:00,320
there were other solutions at uber

458
00:16:00,320 --> 00:16:02,000
whether homegrown or third-party

459
00:16:02,000 --> 00:16:03,600
products now

460
00:16:03,600 --> 00:16:06,480
if in the database we had multiple

461
00:16:06,480 --> 00:16:07,839
pieces of data that were encrypted with

462
00:16:07,839 --> 00:16:09,680
different schemes what do we do with

463
00:16:09,680 --> 00:16:10,639
that

464
00:16:10,639 --> 00:16:12,399
one option is to

465
00:16:12,399 --> 00:16:14,560
just have all these different encryption

466
00:16:14,560 --> 00:16:16,399
mechanisms coexist

467
00:16:16,399 --> 00:16:17,519
but that would

468
00:16:17,519 --> 00:16:19,759
require to have this branching logic in

469
00:16:19,759 --> 00:16:21,199
all of our services

470
00:16:21,199 --> 00:16:22,560
and that wouldn't be a very clean

471
00:16:22,560 --> 00:16:23,680
mechanism

472
00:16:23,680 --> 00:16:24,880
so

473
00:16:24,880 --> 00:16:26,560
another option is just to decrypt the

474
00:16:26,560 --> 00:16:28,160
old data and then re-encrypt it with the

475
00:16:28,160 --> 00:16:29,680
new scheme

476
00:16:29,680 --> 00:16:30,399
so

477
00:16:30,399 --> 00:16:32,480
now that we've talked about a couple of

478
00:16:32,480 --> 00:16:35,120
impacts and goals and requirements now

479
00:16:35,120 --> 00:16:37,120
we can start evaluating solutions that

480
00:16:37,120 --> 00:16:40,079
can address this problem

481
00:16:45,279 --> 00:16:47,440
so what we want to do is talk about the

482
00:16:47,440 --> 00:16:48,880
ways we thought about addressing this

483
00:16:48,880 --> 00:16:51,600
problem and a couple of things we need

484
00:16:51,600 --> 00:16:54,320
to consider one is

485
00:16:54,320 --> 00:16:55,519
what are the threats that we're trying

486
00:16:55,519 --> 00:16:58,320
to solve here is it a user stealing is

487
00:16:58,320 --> 00:17:00,800
this an attacker stealing a hard disk

488
00:17:00,800 --> 00:17:03,199
is it someone doing sql injection is it

489
00:17:03,199 --> 00:17:05,919
a rogue dba or or engineer trying to get

490
00:17:05,919 --> 00:17:07,839
access to the system and then how can we

491
00:17:07,839 --> 00:17:09,679
mitigate against it

492
00:17:09,679 --> 00:17:12,640
in parallel how complex is a solution

493
00:17:12,640 --> 00:17:14,160
so just to kind of touch base we still

494
00:17:14,160 --> 00:17:15,760
haven't decided on a solution yet right

495
00:17:15,760 --> 00:17:18,240
we're still we're still contemplating

496
00:17:18,240 --> 00:17:20,400
solutions whether we do it whether we

497
00:17:20,400 --> 00:17:23,280
build it internally or whether we

498
00:17:23,280 --> 00:17:25,520
go to an existing third party so let's

499
00:17:25,520 --> 00:17:28,160
dive a bit into how we looked at all

500
00:17:28,160 --> 00:17:31,400
these approaches

501
00:17:33,039 --> 00:17:34,960
now a little bit more specific on the

502
00:17:34,960 --> 00:17:36,000
approaches

503
00:17:36,000 --> 00:17:37,520
one of the main

504
00:17:37,520 --> 00:17:39,200
considerations is where is encryption

505
00:17:39,200 --> 00:17:41,200
happening so is it in the application

506
00:17:41,200 --> 00:17:43,679
level is it at the disk level at the os

507
00:17:43,679 --> 00:17:45,679
level and what kind of security

508
00:17:45,679 --> 00:17:48,000
guarantees do we get based on that level

509
00:17:48,000 --> 00:17:49,760
another thing to consider is are we

510
00:17:49,760 --> 00:17:53,120
using a kms remotely or are the keys

511
00:17:53,120 --> 00:17:54,240
stored

512
00:17:54,240 --> 00:17:56,559
right next to the sensitive data and as

513
00:17:56,559 --> 00:17:58,160
we go through that let's start thinking

514
00:17:58,160 --> 00:17:59,840
about the trade-offs to figure out

515
00:17:59,840 --> 00:18:02,880
what's best for our approach

516
00:18:02,880 --> 00:18:04,720
all right so first up what do we have we

517
00:18:04,720 --> 00:18:06,880
have volume and disk encryption so an

518
00:18:06,880 --> 00:18:08,880
example of this is you know the the

519
00:18:08,880 --> 00:18:10,400
encryption that's on your file on your

520
00:18:10,400 --> 00:18:12,080
file system on your laptop or your

521
00:18:12,080 --> 00:18:15,200
server and another example is bitlocker

522
00:18:15,200 --> 00:18:17,600
so as long as your system can boot and

523
00:18:17,600 --> 00:18:19,200
you can mount that volume

524
00:18:19,200 --> 00:18:21,679
you should be fine so

525
00:18:21,679 --> 00:18:22,880
some of the good things about this is

526
00:18:22,880 --> 00:18:24,960
that this is transparent it doesn't

527
00:18:24,960 --> 00:18:26,799
really

528
00:18:26,799 --> 00:18:28,880
cause any issues with the user

529
00:18:28,880 --> 00:18:30,960
but at the same time this doesn't really

530
00:18:30,960 --> 00:18:32,880
solve our threat model

531
00:18:32,880 --> 00:18:34,320
the this solves a threat model of

532
00:18:34,320 --> 00:18:36,320
someone stealing the physical hard drive

533
00:18:36,320 --> 00:18:38,000
or something the the

534
00:18:38,000 --> 00:18:39,840
volume and that's not what we're going

535
00:18:39,840 --> 00:18:41,039
for here

536
00:18:41,039 --> 00:18:42,640
so we're trying to solve for someone

537
00:18:42,640 --> 00:18:44,240
getting access to the data store or

538
00:18:44,240 --> 00:18:45,919
seeing data as it moves throughout the

539
00:18:45,919 --> 00:18:47,280
network

540
00:18:47,280 --> 00:18:49,600
so we didn't use this option

541
00:18:49,600 --> 00:18:50,799
another option we considered is

542
00:18:50,799 --> 00:18:52,000
something called

543
00:18:52,000 --> 00:18:54,160
i think transparent disk encryption

544
00:18:54,160 --> 00:18:56,160
or data encryption and this is included

545
00:18:56,160 --> 00:18:58,080
in a lot of different databases so for

546
00:18:58,080 --> 00:19:00,720
example you have this in my sql now

547
00:19:00,720 --> 00:19:01,919
what's cool about this is that it's

548
00:19:01,919 --> 00:19:04,080
transparent and all of your sql queries

549
00:19:04,080 --> 00:19:06,720
still work so let's say you have a

550
00:19:06,720 --> 00:19:09,440
a user service if you enabled this

551
00:19:09,440 --> 00:19:11,280
database tde

552
00:19:11,280 --> 00:19:12,799
nothing would need to change with your

553
00:19:12,799 --> 00:19:14,799
application all the changes would happen

554
00:19:14,799 --> 00:19:16,320
with your database

555
00:19:16,320 --> 00:19:17,919
so what's actually happening underneath

556
00:19:17,919 --> 00:19:20,799
the hood is that it's encrypting the

557
00:19:20,799 --> 00:19:22,720
files the files that support those

558
00:19:22,720 --> 00:19:23,679
tables

559
00:19:23,679 --> 00:19:24,799
so

560
00:19:24,799 --> 00:19:26,400
the problem here is that we're still not

561
00:19:26,400 --> 00:19:27,840
really protecting against the use case

562
00:19:27,840 --> 00:19:29,679
that we want to protect events this

563
00:19:29,679 --> 00:19:31,440
really just protects against someone

564
00:19:31,440 --> 00:19:33,120
stealing your disk

565
00:19:33,120 --> 00:19:35,280
additionally the keys are still stored

566
00:19:35,280 --> 00:19:37,520
in the database

567
00:19:37,520 --> 00:19:40,080
a rogue dba or someone gets access to

568
00:19:40,080 --> 00:19:41,840
the database could potentially steal the

569
00:19:41,840 --> 00:19:44,639
keys as well

570
00:19:46,320 --> 00:19:47,840
we're still in the database but now we

571
00:19:47,840 --> 00:19:50,000
have a little bit of stronger

572
00:19:50,000 --> 00:19:51,919
encryption we have this thing called

573
00:19:51,919 --> 00:19:54,480
column level encryption what mysql does

574
00:19:54,480 --> 00:19:55,919
as an example is use enterprise

575
00:19:55,919 --> 00:19:57,679
encryption now this one's pretty cool

576
00:19:57,679 --> 00:19:59,280
because now the keys are not stored

577
00:19:59,280 --> 00:20:00,559
locally in the database or at least they

578
00:20:00,559 --> 00:20:03,760
don't have to be they can be stored in a

579
00:20:03,760 --> 00:20:05,200
kms

580
00:20:05,200 --> 00:20:07,120
so we're getting a little bit stronger

581
00:20:07,120 --> 00:20:09,360
with our security guarantees because

582
00:20:09,360 --> 00:20:10,880
now we're protecting against the rogue

583
00:20:10,880 --> 00:20:11,919
dba

584
00:20:11,919 --> 00:20:13,919
and we have keys coming from a different

585
00:20:13,919 --> 00:20:15,120
source

586
00:20:15,120 --> 00:20:16,880
some of the issues that arise with this

587
00:20:16,880 --> 00:20:18,000
is that now we're going to have to start

588
00:20:18,000 --> 00:20:20,240
introducing code changes so there's a

589
00:20:20,240 --> 00:20:22,320
higher level of friction here

590
00:20:22,320 --> 00:20:24,799
but at the same time some of the

591
00:20:24,799 --> 00:20:26,720
implementations that we've seen used

592
00:20:26,720 --> 00:20:28,159
weaker algorithms

593
00:20:28,159 --> 00:20:30,400
and we didn't really like that so

594
00:20:30,400 --> 00:20:31,840
we still didn't we didn't choose this

595
00:20:31,840 --> 00:20:34,640
choice either

596
00:20:34,640 --> 00:20:36,159
so as we're walking a little higher up

597
00:20:36,159 --> 00:20:37,760
in the tech stack we finally get to

598
00:20:37,760 --> 00:20:40,159
application layer so apple application

599
00:20:40,159 --> 00:20:41,600
layer the first one we'll talk about is

600
00:20:41,600 --> 00:20:43,919
server side so as an example you can

601
00:20:43,919 --> 00:20:46,559
think of s3 server-side encryption

602
00:20:46,559 --> 00:20:48,159
so what's good about this is that this

603
00:20:48,159 --> 00:20:49,760
is independent of a database so we're

604
00:20:49,760 --> 00:20:52,320
not tied to the mysql implementation or

605
00:20:52,320 --> 00:20:54,640
the microsoft sql implementation and

606
00:20:54,640 --> 00:20:56,799
it's also fairly easy to onboard

607
00:20:56,799 --> 00:20:58,480
yes there are going to be code changes

608
00:20:58,480 --> 00:21:00,960
but those code changes are mainly adding

609
00:21:00,960 --> 00:21:03,280
an sdk or a library such that a service

610
00:21:03,280 --> 00:21:06,000
can make a api call any changes to the

611
00:21:06,000 --> 00:21:08,480
api happen on the api side so your

612
00:21:08,480 --> 00:21:10,640
client library should still work

613
00:21:10,640 --> 00:21:12,080
some of the issues that arise here is

614
00:21:12,080 --> 00:21:14,799
that if an admin gets access to

615
00:21:14,799 --> 00:21:15,679
this

616
00:21:15,679 --> 00:21:18,080
s3 bucket usually they can get access to

617
00:21:18,080 --> 00:21:20,080
the data that's housed there as well

618
00:21:20,080 --> 00:21:22,080
so this is really only protecting

619
00:21:22,080 --> 00:21:24,080
against a rogue engineer who gets access

620
00:21:24,080 --> 00:21:25,120
there

621
00:21:25,120 --> 00:21:27,760
additionally the keys that can be stored

622
00:21:27,760 --> 00:21:30,799
either with the kms or by the user

623
00:21:30,799 --> 00:21:33,200
themselves and so we're getting better

624
00:21:33,200 --> 00:21:35,280
security guarantees but the friction is

625
00:21:35,280 --> 00:21:37,440
also increasing as well

626
00:21:37,440 --> 00:21:39,200
now we still didn't like this choice

627
00:21:39,200 --> 00:21:40,880
because it wasn't as flexible as we

628
00:21:40,880 --> 00:21:42,640
wanted we were still tied into the

629
00:21:42,640 --> 00:21:44,400
algorithms that were supported by the

630
00:21:44,400 --> 00:21:46,880
server-side technology

631
00:21:46,880 --> 00:21:48,880
which leads us to the last

632
00:21:48,880 --> 00:21:50,799
option we considered so the last option

633
00:21:50,799 --> 00:21:53,039
is client-side encryption and as an

634
00:21:53,039 --> 00:21:54,640
example you have google tank or you have

635
00:21:54,640 --> 00:21:57,600
aws s3 client-side encryption so with

636
00:21:57,600 --> 00:21:59,120
this one we have the pros of we can

637
00:21:59,120 --> 00:22:01,280
choose our algorithm we can choose the

638
00:22:01,280 --> 00:22:03,039
key material we can choose the controls

639
00:22:03,039 --> 00:22:05,039
that we wanted to use

640
00:22:05,039 --> 00:22:07,120
but with that flexibility came those

641
00:22:07,120 --> 00:22:08,799
cons of we had to make a lot of code

642
00:22:08,799 --> 00:22:11,039
changes additionally we had to discover

643
00:22:11,039 --> 00:22:12,960
where sensitive data lives

644
00:22:12,960 --> 00:22:15,039
so what that means is that we can do all

645
00:22:15,039 --> 00:22:16,400
these good things about creating an

646
00:22:16,400 --> 00:22:18,720
encryption system or using an existing

647
00:22:18,720 --> 00:22:19,520
one

648
00:22:19,520 --> 00:22:20,720
but

649
00:22:20,720 --> 00:22:22,000
we need to figure out where sensitive

650
00:22:22,000 --> 00:22:24,400
data lives

651
00:22:24,400 --> 00:22:25,760
the good thing about this is that now

652
00:22:25,760 --> 00:22:27,440
we're predicting threats where we have a

653
00:22:27,440 --> 00:22:29,200
man in the middle or you're a rogue

654
00:22:29,200 --> 00:22:31,360
engineer so in both of those primary

655
00:22:31,360 --> 00:22:33,360
threats we're protecting against those

656
00:22:33,360 --> 00:22:34,159
now

657
00:22:34,159 --> 00:22:34,880
um

658
00:22:34,880 --> 00:22:36,960
also the keys they can come from a legit

659
00:22:36,960 --> 00:22:39,360
kms or we can we can supply them as a

660
00:22:39,360 --> 00:22:40,480
user

661
00:22:40,480 --> 00:22:42,080
like i said this friction is higher

662
00:22:42,080 --> 00:22:44,720
because there's more um there's more

663
00:22:44,720 --> 00:22:46,480
flexibility here

664
00:22:46,480 --> 00:22:48,559
so ultimately we chose this option we

665
00:22:48,559 --> 00:22:51,919
chose to use the client side option

666
00:22:51,919 --> 00:22:54,320
and in so doing we wanted to use wanted

667
00:22:54,320 --> 00:22:57,280
to build our own solution

668
00:22:58,720 --> 00:23:01,520
so the natural question to that is

669
00:23:01,520 --> 00:23:04,480
why not just choose the

670
00:23:04,480 --> 00:23:06,480
to choose an existing application that

671
00:23:06,480 --> 00:23:08,000
already lives out there we mentioned

672
00:23:08,000 --> 00:23:10,559
google tink there's lip sodium there's

673
00:23:10,559 --> 00:23:12,559
bouncy castle spongy castle all these

674
00:23:12,559 --> 00:23:13,919
different choices

675
00:23:13,919 --> 00:23:15,440
and so there are many solutions that

676
00:23:15,440 --> 00:23:17,280
might satisfy our goals or requirements

677
00:23:17,280 --> 00:23:19,440
why build something new instead of using

678
00:23:19,440 --> 00:23:21,280
the existing solution

679
00:23:21,280 --> 00:23:23,280
another question we asked ourselves is

680
00:23:23,280 --> 00:23:25,360
why wouldn't a service owner at uber

681
00:23:25,360 --> 00:23:28,880
just use lipsodium or xyz tool

682
00:23:28,880 --> 00:23:30,960
directly why do we need a centrally

683
00:23:30,960 --> 00:23:32,480
managed solution

684
00:23:32,480 --> 00:23:35,919
well as we showed in a previous slide

685
00:23:35,919 --> 00:23:38,080
the google machine is very complex

686
00:23:38,080 --> 00:23:39,120
there's

687
00:23:39,120 --> 00:23:40,960
lots of different microservices lots of

688
00:23:40,960 --> 00:23:43,039
different data stores lots of custom

689
00:23:43,039 --> 00:23:45,679
data stores and logging systems we can't

690
00:23:45,679 --> 00:23:47,360
always just take something off the shelf

691
00:23:47,360 --> 00:23:48,880
whether it's free open source or

692
00:23:48,880 --> 00:23:50,400
commercial and just add it to our

693
00:23:50,400 --> 00:23:52,799
environment and expect it to work

694
00:23:52,799 --> 00:23:54,320
when we hear things like oh why don't

695
00:23:54,320 --> 00:23:56,480
you just use this or just use that it's

696
00:23:56,480 --> 00:23:58,080
been our experience if that's not really

697
00:23:58,080 --> 00:24:00,400
viable we can't use those

698
00:24:00,400 --> 00:24:02,159
right off the shelf

699
00:24:02,159 --> 00:24:04,559
additionally with our own solution we

700
00:24:04,559 --> 00:24:06,640
now have the ability to have a central

701
00:24:06,640 --> 00:24:07,840
place to audit

702
00:24:07,840 --> 00:24:10,159
we mentioned earlier that we need to

703
00:24:10,159 --> 00:24:11,360
provide

704
00:24:11,360 --> 00:24:12,960
we need to satisfy regulations and

705
00:24:12,960 --> 00:24:15,520
compliance mandates well using something

706
00:24:15,520 --> 00:24:16,559
like this

707
00:24:16,559 --> 00:24:19,840
we can now do that

708
00:24:22,880 --> 00:24:25,039
so my co-presenter devil is going to go

709
00:24:25,039 --> 00:24:26,080
through some of that some of those

710
00:24:26,080 --> 00:24:27,360
implementation details in the

711
00:24:27,360 --> 00:24:28,960
implementation section

712
00:24:28,960 --> 00:24:32,240
so let's take a step into the design and

713
00:24:32,240 --> 00:24:33,600
figure out how we thought about

714
00:24:33,600 --> 00:24:37,200
designing this solution

715
00:24:37,200 --> 00:24:37,919
so

716
00:24:37,919 --> 00:24:39,039
the things that we want to talk about

717
00:24:39,039 --> 00:24:40,640
with design are going to be what

718
00:24:40,640 --> 00:24:43,120
encryption strategy do we use how do we

719
00:24:43,120 --> 00:24:45,120
configure it and maybe some of the high

720
00:24:45,120 --> 00:24:48,799
level tech specifications for it

721
00:24:49,440 --> 00:24:51,840
so the main strategy we're using

722
00:24:51,840 --> 00:24:53,840
is envelope encryption

723
00:24:53,840 --> 00:24:55,760
now specifically we're using a symmetric

724
00:24:55,760 --> 00:24:56,799
key

725
00:24:56,799 --> 00:24:58,799
and we're using symmetric encryption

726
00:24:58,799 --> 00:25:01,200
with aes gcm

727
00:25:01,200 --> 00:25:04,240
and this is mainly for our strategy of

728
00:25:04,240 --> 00:25:06,400
storing data in a database we have other

729
00:25:06,400 --> 00:25:08,559
strategies like store data and logs and

730
00:25:08,559 --> 00:25:10,640
setting data set third parties but for

731
00:25:10,640 --> 00:25:12,400
the use case of storing data is storing

732
00:25:12,400 --> 00:25:14,480
data in a database we're going to use

733
00:25:14,480 --> 00:25:16,320
symmetric encryption and use an envelope

734
00:25:16,320 --> 00:25:18,640
encryption strategy for those that are

735
00:25:18,640 --> 00:25:20,400
not familiar with that all it really

736
00:25:20,400 --> 00:25:22,880
means is we have this let's just call it

737
00:25:22,880 --> 00:25:25,279
a master key or a keck so a key

738
00:25:25,279 --> 00:25:28,080
encrypting key so we have this main key

739
00:25:28,080 --> 00:25:30,880
and that key then generates can then we

740
00:25:30,880 --> 00:25:32,000
generate a

741
00:25:32,000 --> 00:25:34,880
femoral key which we'll call a deck

742
00:25:34,880 --> 00:25:38,720
now the keck is used to protect the deck

743
00:25:38,720 --> 00:25:40,400
by means of encrypting it

744
00:25:40,400 --> 00:25:42,000
and then the deck is used to encrypt

745
00:25:42,000 --> 00:25:43,600
your plain text

746
00:25:43,600 --> 00:25:45,279
so let's go over that one more time just

747
00:25:45,279 --> 00:25:46,960
to make sure we're all clear we have a

748
00:25:46,960 --> 00:25:47,919
keck

749
00:25:47,919 --> 00:25:49,919
and we have a deck the deck is used to

750
00:25:49,919 --> 00:25:51,840
encrypt your plain text and then the

751
00:25:51,840 --> 00:25:53,840
keck is used to encrypt your deck

752
00:25:53,840 --> 00:25:55,440
now what you do is you take your

753
00:25:55,440 --> 00:25:58,159
encrypted ciphertext and your encrypted

754
00:25:58,159 --> 00:26:01,200
deck and you store them in your database

755
00:26:01,200 --> 00:26:03,440
so why is that important well on the

756
00:26:03,440 --> 00:26:06,240
flip side when we go to decrypt the data

757
00:26:06,240 --> 00:26:07,679
if all that information lives in the

758
00:26:07,679 --> 00:26:10,720
data in the ciphertext we can then use

759
00:26:10,720 --> 00:26:12,720
that we can parse it and then decrypt

760
00:26:12,720 --> 00:26:15,200
the data

761
00:26:18,640 --> 00:26:20,159
so let's talk a little bit about what

762
00:26:20,159 --> 00:26:21,919
the config looks like we mentioned

763
00:26:21,919 --> 00:26:23,279
earlier that we wanted this solution to

764
00:26:23,279 --> 00:26:24,799
be config driven

765
00:26:24,799 --> 00:26:27,440
so we have this notion of a name space a

766
00:26:27,440 --> 00:26:29,279
parallel analogy would be something like

767
00:26:29,279 --> 00:26:32,559
a key ring or key space

768
00:26:32,559 --> 00:26:34,640
i think keyring is used more more often

769
00:26:34,640 --> 00:26:36,880
in certain technologies but what you

770
00:26:36,880 --> 00:26:39,360
have here is is you have this

771
00:26:39,360 --> 00:26:42,640
kind of sandbox where you specify what's

772
00:26:42,640 --> 00:26:45,919
my kms what's my key what's my cipher

773
00:26:45,919 --> 00:26:48,000
and you could have multiple name spaces

774
00:26:48,000 --> 00:26:50,080
but this name space is you so when you

775
00:26:50,080 --> 00:26:52,640
go to encrypt a piece of data our system

776
00:26:52,640 --> 00:26:54,400
can look up a namespace and say oh

777
00:26:54,400 --> 00:26:56,640
you're using this example namespace well

778
00:26:56,640 --> 00:26:58,320
i know this example namespace uses

779
00:26:58,320 --> 00:27:00,880
aesgcm256

780
00:27:00,880 --> 00:27:02,559
i know that it uses

781
00:27:02,559 --> 00:27:05,760
version 3 of a key i know it uses a

782
00:27:05,760 --> 00:27:06,640
vault

783
00:27:06,640 --> 00:27:09,760
kms and so i have all these kind of like

784
00:27:09,760 --> 00:27:12,240
key material or lookups to know what to

785
00:27:12,240 --> 00:27:15,120
how to how to actually encrypt

786
00:27:15,120 --> 00:27:17,200
when we talk about decrypt we can have

787
00:27:17,200 --> 00:27:19,039
different versions of a key so let's say

788
00:27:19,039 --> 00:27:21,360
for example we figured out that

789
00:27:21,360 --> 00:27:23,520
we want to rotate a key every year so

790
00:27:23,520 --> 00:27:24,880
let's say we're in the third year of

791
00:27:24,880 --> 00:27:26,559
this process and now we have three

792
00:27:26,559 --> 00:27:28,000
versions of key

793
00:27:28,000 --> 00:27:30,480
so in some cases we'll have one active

794
00:27:30,480 --> 00:27:32,320
key that's used for encrypting and then

795
00:27:32,320 --> 00:27:34,399
you'll have your older keys like you

796
00:27:34,399 --> 00:27:36,399
know version zero or version one that

797
00:27:36,399 --> 00:27:38,159
are used to decrypt

798
00:27:38,159 --> 00:27:41,200
previously encrypted data

799
00:27:41,200 --> 00:27:42,960
when we talk about algorithm it's kind

800
00:27:42,960 --> 00:27:45,520
of implicit in this config because this

801
00:27:45,520 --> 00:27:46,399
is the

802
00:27:46,399 --> 00:27:49,360
more basic config but we're able to

803
00:27:49,360 --> 00:27:51,360
specify which algorithm that we want to

804
00:27:51,360 --> 00:27:52,799
use

805
00:27:52,799 --> 00:27:55,520
so again if it's asgcm

806
00:27:55,520 --> 00:27:56,880
256

807
00:27:56,880 --> 00:27:59,360
maybe it's uh cha cha poly maybe it's

808
00:27:59,360 --> 00:28:01,200
something else but we're able to specify

809
00:28:01,200 --> 00:28:03,039
this with our config

810
00:28:03,039 --> 00:28:04,399
the last kind of

811
00:28:04,399 --> 00:28:06,080
config option we want to talk about is

812
00:28:06,080 --> 00:28:08,320
this notion of a key provider a key

813
00:28:08,320 --> 00:28:10,240
provider is our extraction on top of a

814
00:28:10,240 --> 00:28:11,600
kms

815
00:28:11,600 --> 00:28:15,120
so our goal for this this solution is to

816
00:28:15,120 --> 00:28:17,039
create a

817
00:28:17,039 --> 00:28:18,559
create an abstraction layer such that

818
00:28:18,559 --> 00:28:20,799
you can use multiple kms's let's say

819
00:28:20,799 --> 00:28:22,799
this year we use vault this year next

820
00:28:22,799 --> 00:28:25,039
year we use aws and maybe the year after

821
00:28:25,039 --> 00:28:27,760
that we develop our own kms

822
00:28:27,760 --> 00:28:29,039
each of those should be able to work

823
00:28:29,039 --> 00:28:31,360
independently of each other and so for

824
00:28:31,360 --> 00:28:33,200
example if this service let's go back to

825
00:28:33,200 --> 00:28:35,679
our example of a user service if they've

826
00:28:35,679 --> 00:28:38,080
over the last three years use different

827
00:28:38,080 --> 00:28:40,000
key management systems and they've

828
00:28:40,000 --> 00:28:41,840
encrypted different data with different

829
00:28:41,840 --> 00:28:42,799
keys

830
00:28:42,799 --> 00:28:44,320
they should still be able to decrypt all

831
00:28:44,320 --> 00:28:46,320
of their data and nothing really

832
00:28:46,320 --> 00:28:48,880
different should happen i i as a service

833
00:28:48,880 --> 00:28:50,640
should be able to call it decrypt and

834
00:28:50,640 --> 00:28:52,080
then all my data gets magically

835
00:28:52,080 --> 00:28:54,639
decrypted

836
00:28:56,240 --> 00:28:57,679
last thing we'll talk about are the tech

837
00:28:57,679 --> 00:29:00,399
specs um specifically the language so

838
00:29:00,399 --> 00:29:01,919
for the first iteration we're focusing

839
00:29:01,919 --> 00:29:03,120
on golang

840
00:29:03,120 --> 00:29:04,960
that's primarily what we use for our

841
00:29:04,960 --> 00:29:07,440
back-end services and so we needed this

842
00:29:07,440 --> 00:29:08,880
solution that we're going to build to be

843
00:29:08,880 --> 00:29:11,760
in golem um we use a lot of dependency

844
00:29:11,760 --> 00:29:13,840
injection in our frameworks and so we

845
00:29:13,840 --> 00:29:15,440
need to develop the solution such that

846
00:29:15,440 --> 00:29:17,200
we can expose constructors and

847
00:29:17,200 --> 00:29:18,720
interfaces

848
00:29:18,720 --> 00:29:21,279
in the di model such that other modules

849
00:29:21,279 --> 00:29:22,480
can reuse

850
00:29:22,480 --> 00:29:26,000
those exposed constructors

851
00:29:26,000 --> 00:29:28,159
also wanted this to integrate with our

852
00:29:28,159 --> 00:29:29,039
our

853
00:29:29,039 --> 00:29:31,679
logging and data store frameworks so we

854
00:29:31,679 --> 00:29:34,000
use mysql we use some logging frameworks

855
00:29:34,000 --> 00:29:35,760
we wanted to make sure that if i'm the

856
00:29:35,760 --> 00:29:37,600
user service i can integrate this

857
00:29:37,600 --> 00:29:40,399
directly and just call our our service

858
00:29:40,399 --> 00:29:41,919
our encryption crypto effects service

859
00:29:41,919 --> 00:29:44,720
directly or i can leverage our data

860
00:29:44,720 --> 00:29:46,559
store framework and then behind the

861
00:29:46,559 --> 00:29:47,520
scenes

862
00:29:47,520 --> 00:29:49,039
the integration with crypto effects in

863
00:29:49,039 --> 00:29:51,200
the data store happens and automatically

864
00:29:51,200 --> 00:29:53,440
encrypts the data

865
00:29:53,440 --> 00:29:54,480
so

866
00:29:54,480 --> 00:29:56,080
now that we've kind of talked about some

867
00:29:56,080 --> 00:29:58,559
of our goals some of our requirements

868
00:29:58,559 --> 00:29:59,679
some of our

869
00:29:59,679 --> 00:30:02,000
our approach that we considered and the

870
00:30:02,000 --> 00:30:03,520
result that we got

871
00:30:03,520 --> 00:30:05,120
i'd like to pass it off to my

872
00:30:05,120 --> 00:30:07,200
co-presenter demo to talk more about the

873
00:30:07,200 --> 00:30:08,399
implementation

874
00:30:08,399 --> 00:30:09,440
and

875
00:30:09,440 --> 00:30:12,000
how we actually arrived at solving these

876
00:30:12,000 --> 00:30:14,000
challenges

877
00:30:14,000 --> 00:30:17,440
so thanks jovan now we'll talk about how

878
00:30:17,440 --> 00:30:20,080
this client-side crypto solution is put

879
00:30:20,080 --> 00:30:21,120
together

880
00:30:21,120 --> 00:30:23,440
and how we deliberated about the knobs

881
00:30:23,440 --> 00:30:27,600
that we chose to expose to our end users

882
00:30:28,080 --> 00:30:29,679
as we start talking about the

883
00:30:29,679 --> 00:30:32,720
implementation section it's important to

884
00:30:32,720 --> 00:30:35,279
understand where we got started like

885
00:30:35,279 --> 00:30:37,679
many companies uber did not have a

886
00:30:37,679 --> 00:30:40,080
remote encryption service offering or

887
00:30:40,080 --> 00:30:42,640
even a formal remote kms feature for

888
00:30:42,640 --> 00:30:43,760
that matter

889
00:30:43,760 --> 00:30:48,640
our service secrets are mounted as files

890
00:30:48,640 --> 00:30:51,919
backed by a temp fs so secrets are

891
00:30:51,919 --> 00:30:55,039
always only present in volatile storage

892
00:30:55,039 --> 00:30:57,279
very similar to what is uh offered by

893
00:30:57,279 --> 00:31:00,000
kubernetes if you are more familiar with

894
00:31:00,000 --> 00:31:02,159
that environment

895
00:31:02,159 --> 00:31:04,399
so there was a project being spun up to

896
00:31:04,399 --> 00:31:07,440
utilize slash productionize hashicorp

897
00:31:07,440 --> 00:31:10,159
falls transit secret engine to service

898
00:31:10,159 --> 00:31:12,880
both a key management system as well as

899
00:31:12,880 --> 00:31:15,760
a remote encryption offering

900
00:31:15,760 --> 00:31:18,080
meanwhile there was a multitude of

901
00:31:18,080 --> 00:31:20,799
business requirements that begged for a

902
00:31:20,799 --> 00:31:22,720
managed crypto offering in the short

903
00:31:22,720 --> 00:31:23,600
term

904
00:31:23,600 --> 00:31:26,000
and these requirements would have to be

905
00:31:26,000 --> 00:31:28,080
met before vault

906
00:31:28,080 --> 00:31:29,120
would be

907
00:31:29,120 --> 00:31:31,679
truly fully productionized

908
00:31:31,679 --> 00:31:33,200
as a result

909
00:31:33,200 --> 00:31:36,000
we opted for a library design pattern

910
00:31:36,000 --> 00:31:38,080
that would currently utilize the secret

911
00:31:38,080 --> 00:31:41,360
delivery mechanism as a kms but also

912
00:31:41,360 --> 00:31:44,799
allow us to get to a world that is fully

913
00:31:44,799 --> 00:31:47,519
centrally managed uh and it would offer

914
00:31:47,519 --> 00:31:51,120
encryption as a service as a solution

915
00:31:51,120 --> 00:31:53,519
obviously this would also require us to

916
00:31:53,519 --> 00:31:56,000
migrate keys over but that is an

917
00:31:56,000 --> 00:31:58,000
operational issue we would deal with

918
00:31:58,000 --> 00:32:00,880
down the line this is what the key

919
00:32:00,880 --> 00:32:04,080
provider component unlocks for us

920
00:32:04,080 --> 00:32:06,080
the cipher component gives us the

921
00:32:06,080 --> 00:32:09,360
flexibility to perform crypto operations

922
00:32:09,360 --> 00:32:11,919
with various algorithms which is limited

923
00:32:11,919 --> 00:32:13,919
by the capabilities of the keys that are

924
00:32:13,919 --> 00:32:16,320
available to us

925
00:32:16,320 --> 00:32:18,480
so both of these are knobs that can be

926
00:32:18,480 --> 00:32:21,200
controlled by the end user albeit behind

927
00:32:21,200 --> 00:32:23,519
a set of same defaults

928
00:32:23,519 --> 00:32:25,840
these are also hidden behind the core

929
00:32:25,840 --> 00:32:27,519
crypto interface

930
00:32:27,519 --> 00:32:29,679
which is how we usually expect our

931
00:32:29,679 --> 00:32:33,840
service customers to interact with us

932
00:32:36,960 --> 00:32:37,919
now

933
00:32:37,919 --> 00:32:40,080
we need to start thinking about

934
00:32:40,080 --> 00:32:42,320
where to encrypt and how to encrypt

935
00:32:42,320 --> 00:32:43,519
these blobs

936
00:32:43,519 --> 00:32:45,519
so the main considerations that we

937
00:32:45,519 --> 00:32:49,120
should have are latency and performance

938
00:32:49,120 --> 00:32:51,360
so nowadays most implementations in

939
00:32:51,360 --> 00:32:54,399
languages like golang are quite fast so

940
00:32:54,399 --> 00:32:56,640
we'll only focus on the network latency

941
00:32:56,640 --> 00:32:57,760
aspect

942
00:32:57,760 --> 00:33:00,640
on the security side we'll consider how

943
00:33:00,640 --> 00:33:03,039
widely the keys are being shared and how

944
00:33:03,039 --> 00:33:06,399
many systems they are traversing through

945
00:33:06,399 --> 00:33:09,519
on the operational complexity side will

946
00:33:09,519 --> 00:33:11,919
measure the impact to the existing data

947
00:33:11,919 --> 00:33:14,799
access patterns and we'll also consider

948
00:33:14,799 --> 00:33:16,960
how difficult it is to onboard to this

949
00:33:16,960 --> 00:33:18,559
new solution

950
00:33:18,559 --> 00:33:20,880
some further points to keep in mind here

951
00:33:20,880 --> 00:33:23,679
are there will be services that have to

952
00:33:23,679 --> 00:33:25,279
deal with large

953
00:33:25,279 --> 00:33:27,600
message blobs for example if you want to

954
00:33:27,600 --> 00:33:30,000
store things like images

955
00:33:30,000 --> 00:33:31,679
encrypted in storage

956
00:33:31,679 --> 00:33:32,640
or

957
00:33:32,640 --> 00:33:34,320
services that usually deal with

958
00:33:34,320 --> 00:33:37,600
extremely high throughput traffic

959
00:33:37,600 --> 00:33:40,720
so now let's uh talk about what a truly

960
00:33:40,720 --> 00:33:43,120
local encryption solution would look

961
00:33:43,120 --> 00:33:46,159
like in this case the data encryption

962
00:33:46,159 --> 00:33:47,360
case

963
00:33:47,360 --> 00:33:50,399
would essentially live on local and the

964
00:33:50,399 --> 00:33:52,559
encryption operations would also happen

965
00:33:52,559 --> 00:33:54,559
locally and both of these things would

966
00:33:54,559 --> 00:33:56,720
remain contained to the current

967
00:33:56,720 --> 00:33:59,120
applications process

968
00:33:59,120 --> 00:34:01,600
for the remote encryption option

969
00:34:01,600 --> 00:34:03,600
everything would be completely remote

970
00:34:03,600 --> 00:34:06,159
where the data encryption case would

971
00:34:06,159 --> 00:34:08,960
never really leave the boundaries of the

972
00:34:08,960 --> 00:34:10,800
encryption as a service

973
00:34:10,800 --> 00:34:13,199
so the model of interacting with this is

974
00:34:13,199 --> 00:34:15,599
the library would simply send the blog

975
00:34:15,599 --> 00:34:17,199
that you want encrypted to this remote

976
00:34:17,199 --> 00:34:19,918
service and you get a cipher text back

977
00:34:19,918 --> 00:34:20,879
and then

978
00:34:20,879 --> 00:34:22,480
when you want to get the plain text

979
00:34:22,480 --> 00:34:24,239
again you interact with that remote

980
00:34:24,239 --> 00:34:25,599
service

981
00:34:25,599 --> 00:34:28,560
and as long as the person interacting

982
00:34:28,560 --> 00:34:30,079
has um

983
00:34:30,079 --> 00:34:32,159
the reasonable access control setup you

984
00:34:32,159 --> 00:34:33,599
should be able to get the plain text

985
00:34:33,599 --> 00:34:34,480
back

986
00:34:34,480 --> 00:34:36,639
then there is the hybrid model

987
00:34:36,639 --> 00:34:39,119
this is where the end user has the

988
00:34:39,119 --> 00:34:41,440
ability to obtain a data encryption key

989
00:34:41,440 --> 00:34:43,280
from this remote service

990
00:34:43,280 --> 00:34:45,760
and then potentially uh

991
00:34:45,760 --> 00:34:48,639
use the same data encryption key to

992
00:34:48,639 --> 00:34:49,760
encrypt

993
00:34:49,760 --> 00:34:52,239
one or more messages

994
00:34:52,239 --> 00:34:54,320
and essentially they have the controls

995
00:34:54,320 --> 00:34:56,239
to refresh this data encryption key

996
00:34:56,239 --> 00:34:59,119
based on whatever interval they see fit

997
00:34:59,119 --> 00:35:02,000
nowadays since most crypto operations

998
00:35:02,000 --> 00:35:04,960
take the order of microseconds the only

999
00:35:04,960 --> 00:35:07,200
real latencies to consider here are the

1000
00:35:07,200 --> 00:35:10,079
network latencies that's why we offer

1001
00:35:10,079 --> 00:35:11,839
all three of these options to the end

1002
00:35:11,839 --> 00:35:14,839
user

1003
00:35:16,240 --> 00:35:18,560
now let's start talking about the actual

1004
00:35:18,560 --> 00:35:21,520
code that gets exposed to our customers

1005
00:35:21,520 --> 00:35:23,599
at uber as jovan has mentioned in the

1006
00:35:23,599 --> 00:35:25,680
past we use a lot of dependency

1007
00:35:25,680 --> 00:35:26,720
injection

1008
00:35:26,720 --> 00:35:28,880
um both for golang and java which are

1009
00:35:28,880 --> 00:35:30,880
our primary languages

1010
00:35:30,880 --> 00:35:33,680
as a result we envision this crypto

1011
00:35:33,680 --> 00:35:36,320
module to be able to provide multiple

1012
00:35:36,320 --> 00:35:39,119
small scoped interfaces that are geared

1013
00:35:39,119 --> 00:35:41,760
to perform individual independent units

1014
00:35:41,760 --> 00:35:43,119
of work

1015
00:35:43,119 --> 00:35:45,760
our prioritization of this development

1016
00:35:45,760 --> 00:35:48,079
work has always been driven by business

1017
00:35:48,079 --> 00:35:50,960
requirements and therefore what we have

1018
00:35:50,960 --> 00:35:53,359
here are the current set of interfaces

1019
00:35:53,359 --> 00:35:56,240
that are provided by our crypto module

1020
00:35:56,240 --> 00:35:58,240
i'll go into some of the obstacles that

1021
00:35:58,240 --> 00:36:01,040
we encountered along the way by virtue

1022
00:36:01,040 --> 00:36:03,280
of everything being driven by business

1023
00:36:03,280 --> 00:36:05,599
uh requirements and but that'll be in

1024
00:36:05,599 --> 00:36:08,079
the next section um including some of

1025
00:36:08,079 --> 00:36:11,200
the ways in which we had to rethink the

1026
00:36:11,200 --> 00:36:14,240
is to suit both internal only flows as

1027
00:36:14,240 --> 00:36:16,240
well as cases where

1028
00:36:16,240 --> 00:36:18,960
data transmits beyond the boundaries of

1029
00:36:18,960 --> 00:36:21,440
uber

1030
00:36:23,440 --> 00:36:25,920
so once we had the crypto interface out

1031
00:36:25,920 --> 00:36:28,320
to a few customers there came upon the

1032
00:36:28,320 --> 00:36:30,079
need to be able to search over some

1033
00:36:30,079 --> 00:36:31,680
encrypted records

1034
00:36:31,680 --> 00:36:34,560
in order to enable this we built out a

1035
00:36:34,560 --> 00:36:37,599
hasher interface to generate digests the

1036
00:36:37,599 --> 00:36:40,000
customer would then generate a digest

1037
00:36:40,000 --> 00:36:41,599
for the field or string that they would

1038
00:36:41,599 --> 00:36:44,240
like to encrypt in parallel they would

1039
00:36:44,240 --> 00:36:46,160
also generate a ciphertext for that

1040
00:36:46,160 --> 00:36:48,079
exact same field or string

1041
00:36:48,079 --> 00:36:50,079
then both of these entries would get

1042
00:36:50,079 --> 00:36:52,400
written to the database

1043
00:36:52,400 --> 00:36:56,400
the generated hmac sha-256 digest would

1044
00:36:56,400 --> 00:36:58,640
be the deterministic component that

1045
00:36:58,640 --> 00:37:00,880
would enable search ability thus

1046
00:37:00,880 --> 00:37:02,800
allowing the service to retrieve the

1047
00:37:02,800 --> 00:37:05,280
relevant object from its data store

1048
00:37:05,280 --> 00:37:08,160
um the encrypted fields would then get

1049
00:37:08,160 --> 00:37:10,240
decrypted using the normal techniques

1050
00:37:10,240 --> 00:37:11,760
using the crypto i showed in the

1051
00:37:11,760 --> 00:37:14,560
previous slide

1052
00:37:16,160 --> 00:37:18,880
so very soon we started to realize that

1053
00:37:18,880 --> 00:37:21,599
while our same configuration driven

1054
00:37:21,599 --> 00:37:24,079
defaults worked fairly well

1055
00:37:24,079 --> 00:37:25,280
they had made some interesting

1056
00:37:25,280 --> 00:37:26,880
assumptions

1057
00:37:26,880 --> 00:37:28,880
imagine if a service was performing a

1058
00:37:28,880 --> 00:37:31,359
single type of crypto operation i only

1059
00:37:31,359 --> 00:37:34,560
local ops or only remote ops or if it

1060
00:37:34,560 --> 00:37:37,359
was using keys from a single namespace

1061
00:37:37,359 --> 00:37:39,119
everything worked great

1062
00:37:39,119 --> 00:37:41,280
but as soon as surveyors started needing

1063
00:37:41,280 --> 00:37:43,760
to deal with different namespaces or if

1064
00:37:43,760 --> 00:37:46,000
someone wanted to do both local and

1065
00:37:46,000 --> 00:37:48,880
remote ops for different business flows

1066
00:37:48,880 --> 00:37:50,400
it became a problem

1067
00:37:50,400 --> 00:37:52,320
and the customers wanted to provide this

1068
00:37:52,320 --> 00:37:54,320
information to this crypto effects

1069
00:37:54,320 --> 00:37:55,599
library

1070
00:37:55,599 --> 00:37:57,760
at the points at which they were

1071
00:37:57,760 --> 00:38:00,079
interacting with the real interfaces

1072
00:38:00,079 --> 00:38:02,800
and to enable this functionality we

1073
00:38:02,800 --> 00:38:05,040
built out these encryption

1074
00:38:05,040 --> 00:38:07,359
options which would essentially allow

1075
00:38:07,359 --> 00:38:09,440
the customers to specify things like the

1076
00:38:09,440 --> 00:38:11,520
name spaces or where certain encryption

1077
00:38:11,520 --> 00:38:13,839
operations would happen and they would

1078
00:38:13,839 --> 00:38:15,440
be able to configure this at the call

1079
00:38:15,440 --> 00:38:18,440
sites

1080
00:38:19,520 --> 00:38:22,000
so then we ended up instrumenting all of

1081
00:38:22,000 --> 00:38:25,359
our top level interfaces which were uh

1082
00:38:25,359 --> 00:38:28,400
exposed by this crypto fx module

1083
00:38:28,400 --> 00:38:30,720
this model made the interface methods

1084
00:38:30,720 --> 00:38:33,280
much more extensible without us having

1085
00:38:33,280 --> 00:38:35,920
to worry about significant breaking api

1086
00:38:35,920 --> 00:38:37,920
changes in the future

1087
00:38:37,920 --> 00:38:40,640
in our world at uber we have made a

1088
00:38:40,640 --> 00:38:43,760
large push towards mono repos recently

1089
00:38:43,760 --> 00:38:45,920
and as a result of this many of these

1090
00:38:45,920 --> 00:38:48,400
migrations even in case of potential

1091
00:38:48,400 --> 00:38:50,720
breaking api changes the migrations can

1092
00:38:50,720 --> 00:38:53,440
still be centralized but we would still

1093
00:38:53,440 --> 00:38:56,160
want to reduce unnecessary operational

1094
00:38:56,160 --> 00:39:00,920
complexities as far as possible

1095
00:39:01,359 --> 00:39:03,440
so now let's talk a little bit about

1096
00:39:03,440 --> 00:39:05,920
what the cipher text that is returned by

1097
00:39:05,920 --> 00:39:08,800
this crypto fx library looks like

1098
00:39:08,800 --> 00:39:10,960
for the general use case

1099
00:39:10,960 --> 00:39:12,800
all the fields that you can see in the

1100
00:39:12,800 --> 00:39:14,800
slide are the ones

1101
00:39:14,800 --> 00:39:17,200
we would need to be able

1102
00:39:17,200 --> 00:39:20,079
to have the service

1103
00:39:20,079 --> 00:39:22,400
have the ability to decrypt a given

1104
00:39:22,400 --> 00:39:24,400
ciphertext provided that they have

1105
00:39:24,400 --> 00:39:27,040
access to all the keys so some of the

1106
00:39:27,040 --> 00:39:28,480
things like the name space is an

1107
00:39:28,480 --> 00:39:30,480
identifier for

1108
00:39:30,480 --> 00:39:33,200
how the keys are stored in either our

1109
00:39:33,200 --> 00:39:36,079
local kms or the remote kms then we also

1110
00:39:36,079 --> 00:39:39,200
have things like what cipher was used

1111
00:39:39,200 --> 00:39:41,040
some identification information for the

1112
00:39:41,040 --> 00:39:44,720
key provider key identities etc

1113
00:39:44,720 --> 00:39:47,920
but these fields are only important for

1114
00:39:47,920 --> 00:39:50,400
the local encryption use cases

1115
00:39:50,400 --> 00:39:52,240
if you think about it

1116
00:39:52,240 --> 00:39:55,040
for the remote use case the only two

1117
00:39:55,040 --> 00:39:57,119
pieces of information that we need are

1118
00:39:57,119 --> 00:39:59,520
the key name space and the base64

1119
00:39:59,520 --> 00:40:01,200
encoded ciphertext

1120
00:40:01,200 --> 00:40:03,599
so when a customer chooses to have

1121
00:40:03,599 --> 00:40:06,079
remote encryption those are the only two

1122
00:40:06,079 --> 00:40:07,839
pieces of information that is contained

1123
00:40:07,839 --> 00:40:10,480
in the ciphertext returned by cryptofx

1124
00:40:10,480 --> 00:40:11,280
and

1125
00:40:11,280 --> 00:40:12,880
just based on those two pieces of

1126
00:40:12,880 --> 00:40:14,480
information they'll be able to obtain

1127
00:40:14,480 --> 00:40:17,359
that plain text

1128
00:40:21,520 --> 00:40:23,280
so now let's take another look at our

1129
00:40:23,280 --> 00:40:26,160
scripture interface

1130
00:40:26,160 --> 00:40:28,880
in some cases our consumers

1131
00:40:28,880 --> 00:40:31,200
wanted to invoke the encrypt or decrypt

1132
00:40:31,200 --> 00:40:33,760
options for a collection of attributes

1133
00:40:33,760 --> 00:40:36,640
instead of on a per attribute basis

1134
00:40:36,640 --> 00:40:39,359
for example when i'm trying to persist a

1135
00:40:39,359 --> 00:40:41,760
user object and say i need to encrypt

1136
00:40:41,760 --> 00:40:44,960
the first and last names i perhaps don't

1137
00:40:44,960 --> 00:40:47,839
want or need to have a different data

1138
00:40:47,839 --> 00:40:49,440
encryption key for each of those

1139
00:40:49,440 --> 00:40:50,640
attributes

1140
00:40:50,640 --> 00:40:52,480
therefore we needed a way for the

1141
00:40:52,480 --> 00:40:55,119
consumer to tell us which attributes

1142
00:40:55,119 --> 00:40:57,119
needed to be encrypted using the same

1143
00:40:57,119 --> 00:40:58,079
key

1144
00:40:58,079 --> 00:41:00,079
for a given api call to the crypto

1145
00:41:00,079 --> 00:41:01,359
interface

1146
00:41:01,359 --> 00:41:03,839
to enable this we created the encrypt

1147
00:41:03,839 --> 00:41:06,240
and decrypt struct interfaces which were

1148
00:41:06,240 --> 00:41:08,319
basically pretty wrappers on top of the

1149
00:41:08,319 --> 00:41:11,200
standard encrypt and decrypt functions

1150
00:41:11,200 --> 00:41:14,560
but they have one special feature

1151
00:41:14,960 --> 00:41:16,079
we learned

1152
00:41:16,079 --> 00:41:18,079
from the golang standard library the

1153
00:41:18,079 --> 00:41:19,359
json

1154
00:41:19,359 --> 00:41:22,240
the json encoding library that's exposed

1155
00:41:22,240 --> 00:41:24,319
we decided that struct tags would be a

1156
00:41:24,319 --> 00:41:26,960
nifty way to achieve what we wanted very

1157
00:41:26,960 --> 00:41:29,119
similar to the stuff jovan talked about

1158
00:41:29,119 --> 00:41:32,160
when discussing field level encryption

1159
00:41:32,160 --> 00:41:33,680
the idea would be

1160
00:41:33,680 --> 00:41:35,280
generate a new key as soon as the

1161
00:41:35,280 --> 00:41:37,520
function is called and then go around

1162
00:41:37,520 --> 00:41:39,760
encrypting the relevant fields using

1163
00:41:39,760 --> 00:41:42,000
that data encryption key

1164
00:41:42,000 --> 00:41:43,680
if you notice in the inter in the

1165
00:41:43,680 --> 00:41:46,480
example we can support encryption and

1166
00:41:46,480 --> 00:41:49,599
decryption of strings and byte slices

1167
00:41:49,599 --> 00:41:51,680
the library also has the ability to be

1168
00:41:51,680 --> 00:41:54,800
able to walk embedded structures

1169
00:41:54,800 --> 00:41:57,280
in some ways you can think of this as a

1170
00:41:57,280 --> 00:42:00,160
bulk encryption mechanism

1171
00:42:00,160 --> 00:42:02,400
when we get to implementing crypto

1172
00:42:02,400 --> 00:42:06,079
effects in java we'd like to have a

1173
00:42:06,079 --> 00:42:08,800
similar form of support and for that

1174
00:42:08,800 --> 00:42:13,920
we'll think of using java annotations

1175
00:42:14,960 --> 00:42:17,440
next uh we'll chat a little bit about

1176
00:42:17,440 --> 00:42:18,960
the challenges faced during the

1177
00:42:18,960 --> 00:42:21,440
development process over the last uh

1178
00:42:21,440 --> 00:42:24,319
close to one year

1179
00:42:24,560 --> 00:42:26,960
um when encountering many of these

1180
00:42:26,960 --> 00:42:29,599
challenges right the first thing that

1181
00:42:29,599 --> 00:42:31,760
does come to mind usually is why not

1182
00:42:31,760 --> 00:42:33,920
just use a standard library in this

1183
00:42:33,920 --> 00:42:35,520
service to get past the current

1184
00:42:35,520 --> 00:42:37,520
challenge and then we'll fix things in

1185
00:42:37,520 --> 00:42:38,960
the future

1186
00:42:38,960 --> 00:42:41,119
at these times it's important for us to

1187
00:42:41,119 --> 00:42:43,200
take a step back to see if there's

1188
00:42:43,200 --> 00:42:45,520
potential for us to make both our

1189
00:42:45,520 --> 00:42:46,880
product better

1190
00:42:46,880 --> 00:42:49,520
as well as to offer strategies to see if

1191
00:42:49,520 --> 00:42:51,520
the customer could indeed migrate to a

1192
00:42:51,520 --> 00:42:53,280
better more reliable more secure

1193
00:42:53,280 --> 00:42:54,640
solution

1194
00:42:54,640 --> 00:42:57,599
thus improving their security posture

1195
00:42:57,599 --> 00:42:59,359
now the points

1196
00:42:59,359 --> 00:43:02,160
we have to be thoughtful about are

1197
00:43:02,160 --> 00:43:04,079
if we keep exposing a lot of knobs to

1198
00:43:04,079 --> 00:43:06,560
the top level interfaces we'd end up

1199
00:43:06,560 --> 00:43:08,960
exposing interfaces very similar to what

1200
00:43:08,960 --> 00:43:11,200
the standard libraries already do

1201
00:43:11,200 --> 00:43:12,640
and that's something we were trying to

1202
00:43:12,640 --> 00:43:14,480
get away from since based on our

1203
00:43:14,480 --> 00:43:16,480
research we discovered that when a

1204
00:43:16,480 --> 00:43:19,040
product engineering team implements a

1205
00:43:19,040 --> 00:43:20,480
crypto solution

1206
00:43:20,480 --> 00:43:22,480
while it may meet the requirements at

1207
00:43:22,480 --> 00:43:23,920
that point in time

1208
00:43:23,920 --> 00:43:26,720
it's often not quite extensible and more

1209
00:43:26,720 --> 00:43:29,280
often than not make certain design

1210
00:43:29,280 --> 00:43:31,920
decisions that compromise on both good

1211
00:43:31,920 --> 00:43:34,480
security and reliability

1212
00:43:34,480 --> 00:43:36,480
yes the intent is there and that's

1213
00:43:36,480 --> 00:43:37,599
wonderful

1214
00:43:37,599 --> 00:43:39,920
but the execution might not always be

1215
00:43:39,920 --> 00:43:42,160
flawless

1216
00:43:42,160 --> 00:43:44,319
we also want to be able to provide

1217
00:43:44,319 --> 00:43:46,319
reasonable defaults and safeguards

1218
00:43:46,319 --> 00:43:48,880
coming from the security side to reach a

1219
00:43:48,880 --> 00:43:50,960
world where the product teams experience

1220
00:43:50,960 --> 00:43:52,880
in their interactions with

1221
00:43:52,880 --> 00:43:55,200
all of the the developer platform teams

1222
00:43:55,200 --> 00:43:57,119
the infrastructure and security teams is

1223
00:43:57,119 --> 00:43:57,920
both

1224
00:43:57,920 --> 00:44:00,079
harmonious and frictionless

1225
00:44:00,079 --> 00:44:02,400
yes we acknowledge that the first few

1226
00:44:02,400 --> 00:44:05,119
integrations will not be super smooth

1227
00:44:05,119 --> 00:44:07,520
but we want to get to a world where all

1228
00:44:07,520 --> 00:44:08,720
the knobs

1229
00:44:08,720 --> 00:44:11,200
exposed by our by our module are

1230
00:44:11,200 --> 00:44:13,440
intuitive to the product teams

1231
00:44:13,440 --> 00:44:15,280
and they get to enjoy development

1232
00:44:15,280 --> 00:44:17,839
velocity without having to block on any

1233
00:44:17,839 --> 00:44:21,520
of our core infrastructure focus teams

1234
00:44:21,520 --> 00:44:23,440
taking a little bit from some of the

1235
00:44:23,440 --> 00:44:26,079
stuff jovan talked about previously our

1236
00:44:26,079 --> 00:44:28,720
infrastructure is indeed quite unique

1237
00:44:28,720 --> 00:44:31,440
and i'd expect the internal infra of

1238
00:44:31,440 --> 00:44:33,680
most large tech companies to be very

1239
00:44:33,680 --> 00:44:36,560
similar so in our experience of the

1240
00:44:36,560 --> 00:44:39,280
shelf solutions often do not work in our

1241
00:44:39,280 --> 00:44:41,920
environment any proposed solution that

1242
00:44:41,920 --> 00:44:45,680
usually begins with why don't you just

1243
00:44:45,680 --> 00:44:47,839
in our experience is usually just not

1244
00:44:47,839 --> 00:44:50,839
viable

1245
00:44:51,040 --> 00:44:53,520
so when rolling out crypto products

1246
00:44:53,520 --> 00:44:56,000
there's a great need for developer

1247
00:44:56,000 --> 00:44:58,720
evangelism

1248
00:44:58,880 --> 00:45:01,599
i will now go on to describe some of the

1249
00:45:01,599 --> 00:45:04,640
different processes that we employed to

1250
00:45:04,640 --> 00:45:07,040
help developers onboard to our crypto

1251
00:45:07,040 --> 00:45:09,119
solutions

1252
00:45:09,119 --> 00:45:09,839
so

1253
00:45:09,839 --> 00:45:12,000
we provided white glove support to our

1254
00:45:12,000 --> 00:45:13,599
first few customers

1255
00:45:13,599 --> 00:45:16,160
even onboarded a few of them ourselves

1256
00:45:16,160 --> 00:45:18,240
as a side note this did let us get

1257
00:45:18,240 --> 00:45:20,079
acquainted with quite a few projects

1258
00:45:20,079 --> 00:45:22,960
across uber we got to see some uh

1259
00:45:22,960 --> 00:45:24,480
interesting coding patterns and got to

1260
00:45:24,480 --> 00:45:26,640
learn a lot so this was absolutely

1261
00:45:26,640 --> 00:45:28,880
excellent

1262
00:45:28,880 --> 00:45:30,720
dealing with these customers directly

1263
00:45:30,720 --> 00:45:33,040
also helped us understand these business

1264
00:45:33,040 --> 00:45:35,520
use cases better and getting closer to

1265
00:45:35,520 --> 00:45:37,280
these product and uh

1266
00:45:37,280 --> 00:45:39,599
product engineering teams

1267
00:45:39,599 --> 00:45:41,520
and building strong relationships with

1268
00:45:41,520 --> 00:45:43,839
them provided immense value to the

1269
00:45:43,839 --> 00:45:46,400
business as well as our defined helped

1270
00:45:46,400 --> 00:45:48,079
us define our future development

1271
00:45:48,079 --> 00:45:50,000
roadmaps

1272
00:45:50,000 --> 00:45:51,760
so now think a little bit about the

1273
00:45:51,760 --> 00:45:54,560
risks in when dealing with encryption

1274
00:45:54,560 --> 00:45:57,119
things um if mistakes happen

1275
00:45:57,119 --> 00:45:58,560
data could potentially become

1276
00:45:58,560 --> 00:46:00,400
irrecoverable

1277
00:46:00,400 --> 00:46:01,920
the customer doesn't know about the

1278
00:46:01,920 --> 00:46:04,079
internals of our systems and just

1279
00:46:04,079 --> 00:46:06,000
because a certain encrypt operation

1280
00:46:06,000 --> 00:46:07,599
worked error free

1281
00:46:07,599 --> 00:46:09,359
doesn't mean that the decrypt operation

1282
00:46:09,359 --> 00:46:10,560
would as well

1283
00:46:10,560 --> 00:46:12,160
especially for the alpha and beta

1284
00:46:12,160 --> 00:46:14,560
customers

1285
00:46:14,560 --> 00:46:17,200
then let's talk about coding patterns

1286
00:46:17,200 --> 00:46:19,680
engineers more often than not grip

1287
00:46:19,680 --> 00:46:22,400
around for code so we'd like to get to a

1288
00:46:22,400 --> 00:46:24,240
stage where they come across coding

1289
00:46:24,240 --> 00:46:26,560
patterns that are aligned with our

1290
00:46:26,560 --> 00:46:29,359
expected happy paths so that way in the

1291
00:46:29,359 --> 00:46:31,760
future when an engineer is doing

1292
00:46:31,760 --> 00:46:33,359
encryption things without interacting

1293
00:46:33,359 --> 00:46:35,599
with the security team at all

1294
00:46:35,599 --> 00:46:37,760
they will be following the good patterns

1295
00:46:37,760 --> 00:46:39,839
and the expected paths that we expect

1296
00:46:39,839 --> 00:46:42,480
people to take

1297
00:46:42,480 --> 00:46:45,119
now there are many times when compliance

1298
00:46:45,119 --> 00:46:48,000
and regulatory requirements drive

1299
00:46:48,000 --> 00:46:49,839
the crypto solutions for a certain

1300
00:46:49,839 --> 00:46:51,119
product

1301
00:46:51,119 --> 00:46:53,440
but other times we actually sit with our

1302
00:46:53,440 --> 00:46:55,760
product partners to help explain the

1303
00:46:55,760 --> 00:46:58,319
benefits of crypto and basically help

1304
00:46:58,319 --> 00:47:01,920
them attain a better security posture

1305
00:47:01,920 --> 00:47:03,680
one of the examples i just talked about

1306
00:47:03,680 --> 00:47:06,240
was when we use that hasher interface to

1307
00:47:06,240 --> 00:47:07,920
allow a team

1308
00:47:07,920 --> 00:47:10,160
to essentially search over data that

1309
00:47:10,160 --> 00:47:12,160
they had a compliance and regulatory

1310
00:47:12,160 --> 00:47:15,280
obligation to store encrypted at rest

1311
00:47:15,280 --> 00:47:17,760
other times there are simply people that

1312
00:47:17,760 --> 00:47:19,920
are very interested in security and we

1313
00:47:19,920 --> 00:47:22,880
absolutely love chatting with them

1314
00:47:22,880 --> 00:47:25,200
then at uber we have a fairly robust

1315
00:47:25,200 --> 00:47:28,160
sdlc at this point in time including a

1316
00:47:28,160 --> 00:47:31,119
very strong uh design review process so

1317
00:47:31,119 --> 00:47:33,680
we try to identify cases

1318
00:47:33,680 --> 00:47:35,760
where we can inject

1319
00:47:35,760 --> 00:47:37,760
some some of our crypto solutions very

1320
00:47:37,760 --> 00:47:39,760
early in the design process

1321
00:47:39,760 --> 00:47:42,000
um and

1322
00:47:42,000 --> 00:47:45,440
using this this model we get to

1323
00:47:45,440 --> 00:47:47,599
we get our engineers to start thinking

1324
00:47:47,599 --> 00:47:50,559
about crypto very very early even during

1325
00:47:50,559 --> 00:47:54,240
the documentation and design phases

1326
00:47:56,960 --> 00:47:59,200
so now at uber we get to see

1327
00:47:59,200 --> 00:48:01,760
various data flow patterns

1328
00:48:01,760 --> 00:48:03,599
there's the case of

1329
00:48:03,599 --> 00:48:06,880
an external party sending data into uber

1330
00:48:06,880 --> 00:48:09,520
services from inside uber sharing data

1331
00:48:09,520 --> 00:48:10,800
with various

1332
00:48:10,800 --> 00:48:14,160
governments third party vendors etc and

1333
00:48:14,160 --> 00:48:16,800
various internal to internal service

1334
00:48:16,800 --> 00:48:18,800
communications

1335
00:48:18,800 --> 00:48:21,040
that may or may not

1336
00:48:21,040 --> 00:48:22,960
have have a requirement for field level

1337
00:48:22,960 --> 00:48:24,319
encryption

1338
00:48:24,319 --> 00:48:26,000
many of these patterns have been

1339
00:48:26,000 --> 00:48:28,480
implemented using either uh legacy

1340
00:48:28,480 --> 00:48:30,240
libraries or

1341
00:48:30,240 --> 00:48:32,720
various standard libraries and these are

1342
00:48:32,720 --> 00:48:34,640
these integrations

1343
00:48:34,640 --> 00:48:38,480
always have various diverse ways

1344
00:48:38,480 --> 00:48:41,359
for the legacy library case um

1345
00:48:41,359 --> 00:48:43,599
we went over a few options should we

1346
00:48:43,599 --> 00:48:45,599
just support their usage patterns in our

1347
00:48:45,599 --> 00:48:47,760
new library we asked or does it make

1348
00:48:47,760 --> 00:48:49,760
more sense to maintain a fork in the

1349
00:48:49,760 --> 00:48:52,559
client service or to do a data migration

1350
00:48:52,559 --> 00:48:56,079
if the ciphertext aren't interoperable

1351
00:48:56,079 --> 00:48:58,559
for bespoke and diverse users of

1352
00:48:58,559 --> 00:49:01,119
standard library encryption products we

1353
00:49:01,119 --> 00:49:03,760
ended up with a similar solution set

1354
00:49:03,760 --> 00:49:05,680
so finally we decided on the combination

1355
00:49:05,680 --> 00:49:07,520
of the latter two options

1356
00:49:07,520 --> 00:49:09,680
if the service owner isn't willing to

1357
00:49:09,680 --> 00:49:12,319
dedicate the time now maintain a fork in

1358
00:49:12,319 --> 00:49:15,520
their code but communicate clearly

1359
00:49:15,520 --> 00:49:18,160
that data inconsistencies or support

1360
00:49:18,160 --> 00:49:20,480
related to old solutions will not be

1361
00:49:20,480 --> 00:49:22,079
provided by the team managing the

1362
00:49:22,079 --> 00:49:24,160
central solution

1363
00:49:24,160 --> 00:49:26,800
apart from this we offer all customers

1364
00:49:26,800 --> 00:49:28,880
that are custodians of large data sets

1365
00:49:28,880 --> 00:49:32,079
of encrypted messages a solution that

1366
00:49:32,079 --> 00:49:35,440
entails either a read repair strategy or

1367
00:49:35,440 --> 00:49:38,319
a process to have background jobs go and

1368
00:49:38,319 --> 00:49:40,800
encrypt all their role data

1369
00:49:40,800 --> 00:49:42,960
generally our strategy is to help

1370
00:49:42,960 --> 00:49:46,160
everyone get over to the manage central

1371
00:49:46,160 --> 00:49:49,200
offering that has not just security but

1372
00:49:49,200 --> 00:49:51,440
code logging and auditability

1373
00:49:51,440 --> 00:49:54,480
requirements built in

1374
00:49:56,559 --> 00:49:58,640
so next

1375
00:49:58,640 --> 00:50:00,880
this in this section i'll try to talk a

1376
00:50:00,880 --> 00:50:03,200
little bit about the work that we intend

1377
00:50:03,200 --> 00:50:06,480
to do um over the upcoming few months so

1378
00:50:06,480 --> 00:50:08,640
one of them as i had mentioned before we

1379
00:50:08,640 --> 00:50:10,559
need to work on importing some of the

1380
00:50:10,559 --> 00:50:13,599
local keys from this local kms of ours

1381
00:50:13,599 --> 00:50:17,440
uh to to the remote hashicorp fault kms

1382
00:50:17,440 --> 00:50:19,280
and to further

1383
00:50:19,280 --> 00:50:22,319
limit the key exposure problem

1384
00:50:22,319 --> 00:50:24,079
then in order to help some of our

1385
00:50:24,079 --> 00:50:26,559
internal customers migrate to a new

1386
00:50:26,559 --> 00:50:29,920
solution from old from either old uh

1387
00:50:29,920 --> 00:50:31,839
legacy softwares or from standard

1388
00:50:31,839 --> 00:50:34,160
library implementations we'd like to

1389
00:50:34,160 --> 00:50:35,680
provide some more

1390
00:50:35,680 --> 00:50:38,880
uh knobs and features for in our top

1391
00:50:38,880 --> 00:50:40,880
level interfaces

1392
00:50:40,880 --> 00:50:43,119
to satisfy the various encoding and

1393
00:50:43,119 --> 00:50:46,400
encryption requirements

1394
00:50:48,640 --> 00:50:50,280
so

1395
00:50:50,280 --> 00:50:51,440
[Music]

1396
00:50:51,440 --> 00:50:54,480
cryptofx currently lacks a high level

1397
00:50:54,480 --> 00:50:57,760
signer and verifier interface

1398
00:50:57,760 --> 00:51:00,400
in general our companies like uber we

1399
00:51:00,400 --> 00:51:04,240
host a lot of content behind cloud ctns

1400
00:51:04,240 --> 00:51:07,200
but most of our url signing capabilities

1401
00:51:07,200 --> 00:51:09,520
are bound by the support that's usually

1402
00:51:09,520 --> 00:51:11,760
provided by these cdns

1403
00:51:11,760 --> 00:51:14,480
and their respective sdks for example

1404
00:51:14,480 --> 00:51:17,200
products like aws's cloudfront still

1405
00:51:17,200 --> 00:51:19,599
only supports rsa verification

1406
00:51:19,599 --> 00:51:22,160
hence we cannot migrate to a solution

1407
00:51:22,160 --> 00:51:24,559
that's based on ec keys even though

1408
00:51:24,559 --> 00:51:27,280
significant signature generation is

1409
00:51:27,280 --> 00:51:29,760
significantly faster

1410
00:51:29,760 --> 00:51:31,440
regardless we'd like to get these

1411
00:51:31,440 --> 00:51:34,240
interfaces out there and getting used so

1412
00:51:34,240 --> 00:51:36,480
that when the time comes and when the

1413
00:51:36,480 --> 00:51:38,880
appropriate support is present we have a

1414
00:51:38,880 --> 00:51:41,520
fairly centralized way to bump everyone

1415
00:51:41,520 --> 00:51:42,480
to the

1416
00:51:42,480 --> 00:51:44,640
more computationally economical

1417
00:51:44,640 --> 00:51:47,640
solutions

1418
00:51:50,319 --> 00:51:53,280
so now uh to talk a little bit more

1419
00:51:53,280 --> 00:51:55,760
about searching over um encrypted

1420
00:51:55,760 --> 00:51:58,480
records these have always been things

1421
00:51:58,480 --> 00:52:00,880
that we have wanted to build but they

1422
00:52:00,880 --> 00:52:03,839
have always gotten de-prioritized due to

1423
00:52:03,839 --> 00:52:05,760
other work that has come up so one of

1424
00:52:05,760 --> 00:52:08,559
those things is fully homomorphic uh

1425
00:52:08,559 --> 00:52:10,960
encryption but one of the problems with

1426
00:52:10,960 --> 00:52:12,720
this approach would be

1427
00:52:12,720 --> 00:52:13,760
um

1428
00:52:13,760 --> 00:52:15,920
that while this is great for a

1429
00:52:15,920 --> 00:52:18,720
distributed integrity checking

1430
00:52:18,720 --> 00:52:21,359
problem space this wouldn't be a great

1431
00:52:21,359 --> 00:52:24,559
fit for most of uber's use cases given

1432
00:52:24,559 --> 00:52:26,160
the linear nature of having to go

1433
00:52:26,160 --> 00:52:27,520
through all the records to be able to

1434
00:52:27,520 --> 00:52:30,960
find the ones we're interested in

1435
00:52:31,040 --> 00:52:32,960
then there is property preserving

1436
00:52:32,960 --> 00:52:34,800
encryption so this could be a

1437
00:52:34,800 --> 00:52:36,640
combination of two things either

1438
00:52:36,640 --> 00:52:39,359
equality preserving or order preserving

1439
00:52:39,359 --> 00:52:42,000
but due to the very nature of these

1440
00:52:42,000 --> 00:52:44,160
systems uh similar to the points we

1441
00:52:44,160 --> 00:52:46,000
discussed before

1442
00:52:46,000 --> 00:52:47,599
these methods are fundamentally

1443
00:52:47,599 --> 00:52:49,920
susceptible to inference attacks which

1444
00:52:49,920 --> 00:52:52,000
are further exacerbated if you're

1445
00:52:52,000 --> 00:52:54,240
dealing with low entropy data

1446
00:52:54,240 --> 00:52:56,079
like either social security numbers or

1447
00:52:56,079 --> 00:52:58,079
credit card details

1448
00:52:58,079 --> 00:53:00,559
then there's also functional encryption

1449
00:53:00,559 --> 00:53:03,200
in theory it's uh kinda same the

1450
00:53:03,200 --> 00:53:04,960
operational nature is kind of similar to

1451
00:53:04,960 --> 00:53:07,040
what you see in homomorphic encryption

1452
00:53:07,040 --> 00:53:08,880
uh in the sense it's going to be very

1453
00:53:08,880 --> 00:53:12,480
slow since you have to go over all the

1454
00:53:12,480 --> 00:53:14,559
records that you have present in your

1455
00:53:14,559 --> 00:53:16,720
data store systems to be able to find

1456
00:53:16,720 --> 00:53:19,920
whichever records actually um

1457
00:53:19,920 --> 00:53:22,720
match your expected query patterns

1458
00:53:22,720 --> 00:53:24,400
so yeah

1459
00:53:24,400 --> 00:53:27,119
this is basically what we have um for

1460
00:53:27,119 --> 00:53:28,880
you all for today

1461
00:53:28,880 --> 00:53:31,520
thank you so much for taking the time to

1462
00:53:31,520 --> 00:53:34,520
listen

