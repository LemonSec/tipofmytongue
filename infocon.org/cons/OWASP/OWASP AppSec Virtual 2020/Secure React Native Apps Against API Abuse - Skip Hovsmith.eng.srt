1
00:00:00,260 --> 00:00:17,990
[Music]

2
00:00:20,560 --> 00:00:22,800
hi thanks for listening today to my talk

3
00:00:22,800 --> 00:00:24,560
on securing react native apps against

4
00:00:24,560 --> 00:00:27,039
api abuse my name is skip how smith and

5
00:00:27,039 --> 00:00:28,960
i work at a company called critical blue

6
00:00:28,960 --> 00:00:31,199
on a security service called approve

7
00:00:31,199 --> 00:00:32,960
approve works by authenticating mobile

8
00:00:32,960 --> 00:00:35,360
apps integrity and secures api calls

9
00:00:35,360 --> 00:00:37,120
from those mobile apps

10
00:00:37,120 --> 00:00:38,559
i actually started off my career as a

11
00:00:38,559 --> 00:00:40,800
chip designer and worked my way up the

12
00:00:40,800 --> 00:00:42,879
abstraction stack ever since

13
00:00:42,879 --> 00:00:44,559
besides chips i've worked on hardware

14
00:00:44,559 --> 00:00:47,039
accelerators reconfigurable fpgas and

15
00:00:47,039 --> 00:00:49,760
embedded systems android os optimization

16
00:00:49,760 --> 00:00:51,440
and hardware security modules as well

17
00:00:51,440 --> 00:00:53,039
before finally kind of embracing the

18
00:00:53,039 --> 00:00:55,360
cloud in mobile applications

19
00:00:55,360 --> 00:00:57,280
a common theme for me is optimization

20
00:00:57,280 --> 00:00:58,719
for example i worked on tools for

21
00:00:58,719 --> 00:01:00,879
hardware software code synthesis and

22
00:01:00,879 --> 00:01:03,239
automated software parallelization

23
00:01:03,239 --> 00:01:05,280
parallelization that's a dangerous word

24
00:01:05,280 --> 00:01:08,000
to say parallelization it's easy to

25
00:01:08,000 --> 00:01:09,920
instead hear parallelization and i did

26
00:01:09,920 --> 00:01:11,680
indeed paralyze a few systems along the

27
00:01:11,680 --> 00:01:15,200
way hopefully that won't happen today

28
00:01:15,200 --> 00:01:17,040
the objectives for today's talk are for

29
00:01:17,040 --> 00:01:18,400
to give you an appreciation for how

30
00:01:18,400 --> 00:01:20,640
react native apps themselves

31
00:01:20,640 --> 00:01:23,360
can be exploited for api abuse we're

32
00:01:23,360 --> 00:01:24,960
going to do that by following a chain of

33
00:01:24,960 --> 00:01:26,479
exploits to try and give you a feel for

34
00:01:26,479 --> 00:01:28,159
the types of attacks you're going to see

35
00:01:28,159 --> 00:01:29,920
and the kinds of defenses you can amount

36
00:01:29,920 --> 00:01:32,000
against those attacks finally at the end

37
00:01:32,000 --> 00:01:33,680
of the talk i'll give you a link to some

38
00:01:33,680 --> 00:01:35,600
work scenarios all the scenarios we

39
00:01:35,600 --> 00:01:36,799
showed today

40
00:01:36,799 --> 00:01:38,320
plus some additional stories so you can

41
00:01:38,320 --> 00:01:39,520
go ahead and go deeper you'll have

42
00:01:39,520 --> 00:01:40,960
access to all the source code so you can

43
00:01:40,960 --> 00:01:44,000
go as deep as you want

44
00:01:44,000 --> 00:01:46,000
apis these days are everywhere i'm sure

45
00:01:46,000 --> 00:01:47,439
everybody knows that

46
00:01:47,439 --> 00:01:49,759
in 2018 akame did a study on their

47
00:01:49,759 --> 00:01:51,680
secure cdn traffic

48
00:01:51,680 --> 00:01:53,600
they look back for a sort of similar

49
00:01:53,600 --> 00:01:56,640
traffic back in 2014 and then uh

50
00:01:56,640 --> 00:01:58,719
requests for apis on this network were

51
00:01:58,719 --> 00:02:01,439
less than 50 of the traffic they saw by

52
00:02:01,439 --> 00:02:03,920
2018 over that same time period it was

53
00:02:03,920 --> 00:02:05,600
up over 83

54
00:02:05,600 --> 00:02:07,360
so the use of apis had really

55
00:02:07,360 --> 00:02:09,679
skyrocketed and during that same

56
00:02:09,679 --> 00:02:12,800
six-month time frame in 2018 over 27

57
00:02:12,800 --> 00:02:15,120
billion credential abuse attempts

58
00:02:15,120 --> 00:02:18,160
were on just that secure network alone

59
00:02:18,160 --> 00:02:20,239
they ranged again but from retail into

60
00:02:20,239 --> 00:02:24,319
video entertainment financial systems

61
00:02:24,319 --> 00:02:26,560
across the map apis are in use and they

62
00:02:26,560 --> 00:02:28,959
clearly are a very

63
00:02:28,959 --> 00:02:31,920
desirable and fat target for hackers to

64
00:02:31,920 --> 00:02:34,879
get into back end systems

65
00:02:34,879 --> 00:02:36,800
if you're on a mobile app whether it's

66
00:02:36,800 --> 00:02:38,480
react native or anything else you're

67
00:02:38,480 --> 00:02:40,640
going to be relying on apis for most of

68
00:02:40,640 --> 00:02:42,879
the traffic unlike a traditional browser

69
00:02:42,879 --> 00:02:44,560
which kind of serves up pages which are

70
00:02:44,560 --> 00:02:46,480
a mix of ui

71
00:02:46,480 --> 00:02:47,760
and data

72
00:02:47,760 --> 00:02:49,920
on a mobile app the ui is pretty much

73
00:02:49,920 --> 00:02:51,519
baked in along with most of the business

74
00:02:51,519 --> 00:02:54,160
logic and really the application is

75
00:02:54,160 --> 00:02:56,560
requesting back-end data to be served up

76
00:02:56,560 --> 00:02:58,800
to it back and forth and oftentimes more

77
00:02:58,800 --> 00:03:00,879
data than it may need

78
00:03:00,879 --> 00:03:03,200
because it may be using that data over

79
00:03:03,200 --> 00:03:05,599
many different pages page equivalent

80
00:03:05,599 --> 00:03:06,959
type views

81
00:03:06,959 --> 00:03:08,640
additionally if you're using an api

82
00:03:08,640 --> 00:03:10,560
technique such as rest

83
00:03:10,560 --> 00:03:12,000
you're going to be trying very hard to

84
00:03:12,000 --> 00:03:13,840
make your api calls stateless which

85
00:03:13,840 --> 00:03:15,760
makes it even easier for attackers once

86
00:03:15,760 --> 00:03:17,440
they have an understanding of what an

87
00:03:17,440 --> 00:03:19,840
api call looks like they can use it by

88
00:03:19,840 --> 00:03:21,440
itself without having to work really

89
00:03:21,440 --> 00:03:22,959
hard to set up a bunch of extra

90
00:03:22,959 --> 00:03:25,120
conditions ahead of time or or using

91
00:03:25,120 --> 00:03:26,799
things afterwards to extract data that

92
00:03:26,799 --> 00:03:29,200
they may have triggered so much easier

93
00:03:29,200 --> 00:03:30,799
much more structured

94
00:03:30,799 --> 00:03:34,400
in using these kinds of apis

95
00:03:34,400 --> 00:03:36,319
so how would a hacker go about abusing

96
00:03:36,319 --> 00:03:37,519
apis

97
00:03:37,519 --> 00:03:39,680
through a mobile app or a react native

98
00:03:39,680 --> 00:03:41,519
mobile app well the first thing they're

99
00:03:41,519 --> 00:03:42,640
going to want to do is they're going to

100
00:03:42,640 --> 00:03:44,480
want to try and understand how the api

101
00:03:44,480 --> 00:03:45,680
works they're going to work hard to

102
00:03:45,680 --> 00:03:47,599
reverse engineer it if you're working

103
00:03:47,599 --> 00:03:50,560
with a public facing api you you

104
00:03:50,560 --> 00:03:52,000
probably already have access to

105
00:03:52,000 --> 00:03:54,080
documentation that explains quite well

106
00:03:54,080 --> 00:03:56,159
what that api calling structure and

107
00:03:56,159 --> 00:03:57,680
protocol looks like

108
00:03:57,680 --> 00:03:59,439
but if you're on a private

109
00:03:59,439 --> 00:04:00,720
private type

110
00:04:00,720 --> 00:04:02,080
api what you're going to want to be

111
00:04:02,080 --> 00:04:03,519
doing is doing your best to sort of

112
00:04:03,519 --> 00:04:05,200
protect anyone from seeing what that

113
00:04:05,200 --> 00:04:06,560
looks like

114
00:04:06,560 --> 00:04:08,640
so the first thing the attacker is going

115
00:04:08,640 --> 00:04:10,159
to do is try and reverse engineer that

116
00:04:10,159 --> 00:04:11,680
app along the way they're going to try

117
00:04:11,680 --> 00:04:14,799
and gather or generate some user

118
00:04:14,799 --> 00:04:17,279
access credentials and possibly api keys

119
00:04:17,279 --> 00:04:19,440
extracted so that they can go ahead and

120
00:04:19,440 --> 00:04:22,079
make these api calls then they're most

121
00:04:22,079 --> 00:04:23,520
likely going to

122
00:04:23,520 --> 00:04:26,000
build up a botnet and launch some very

123
00:04:26,000 --> 00:04:27,199
high volume

124
00:04:27,199 --> 00:04:29,600
attacks calling all those apis as we saw

125
00:04:29,600 --> 00:04:31,199
in the last slide credentials stuffing

126
00:04:31,199 --> 00:04:32,400
is very hard

127
00:04:32,400 --> 00:04:34,880
very popular trying to extract as many

128
00:04:34,880 --> 00:04:36,080
user

129
00:04:36,080 --> 00:04:37,600
information and user credentials as

130
00:04:37,600 --> 00:04:40,240
possible you can also make api calls to

131
00:04:40,240 --> 00:04:42,400
try and extract personal information and

132
00:04:42,400 --> 00:04:43,360
access

133
00:04:43,360 --> 00:04:45,680
data that comes with api calls

134
00:04:45,680 --> 00:04:48,639
you can use legitimate looking api calls

135
00:04:48,639 --> 00:04:50,240
to make

136
00:04:50,240 --> 00:04:52,560
application level denial of service

137
00:04:52,560 --> 00:04:54,080
attacks where you're tying up key

138
00:04:54,080 --> 00:04:57,040
resources on what look like a legitimate

139
00:04:57,040 --> 00:04:58,720
api calls they can get all the way to

140
00:04:58,720 --> 00:05:00,400
the api back-end

141
00:05:00,400 --> 00:05:02,639
but they really are just designed to

142
00:05:02,639 --> 00:05:04,320
lock up the system

143
00:05:04,320 --> 00:05:06,400
if you can use these apis to get access

144
00:05:06,400 --> 00:05:08,320
into a system you can both collect data

145
00:05:08,320 --> 00:05:10,160
and you can manipulate whatever is

146
00:05:10,160 --> 00:05:12,400
behind the system as well

147
00:05:12,400 --> 00:05:14,240
and sort of one of the most common ways

148
00:05:14,240 --> 00:05:16,400
which is not necessarily a malicious way

149
00:05:16,400 --> 00:05:18,400
to use api attacks is service

150
00:05:18,400 --> 00:05:20,000
aggregation

151
00:05:20,000 --> 00:05:22,240
one example would be a financial app

152
00:05:22,240 --> 00:05:23,120
that

153
00:05:23,120 --> 00:05:25,440
tries to give the user a uniform picture

154
00:05:25,440 --> 00:05:26,800
of all the different banking

155
00:05:26,800 --> 00:05:28,800
institutions they're banking at so the

156
00:05:28,800 --> 00:05:30,639
user will maybe surrender their

157
00:05:30,639 --> 00:05:32,960
credentials give those access to the

158
00:05:32,960 --> 00:05:34,880
service aggregator in turn they'll be

159
00:05:34,880 --> 00:05:36,479
able to get a good picture of all their

160
00:05:36,479 --> 00:05:38,320
finances but also what they've done

161
00:05:38,320 --> 00:05:40,080
along the way is giving up that

162
00:05:40,080 --> 00:05:42,160
information so that the aggregator can

163
00:05:42,160 --> 00:05:43,600
then

164
00:05:43,600 --> 00:05:45,680
probe much more information on all those

165
00:05:45,680 --> 00:05:47,520
backend institutions

166
00:05:47,520 --> 00:05:49,199
and potentially sort of take eyeballs

167
00:05:49,199 --> 00:05:52,880
away from those institutions themselves

168
00:05:52,880 --> 00:05:54,960
the really kind of four attack surfaces

169
00:05:54,960 --> 00:05:56,639
i tend to look at in this mobile

170
00:05:56,639 --> 00:05:59,039
application api space the first one is

171
00:05:59,039 --> 00:06:00,639
user credentials

172
00:06:00,639 --> 00:06:03,120
that's pretty well understood area

173
00:06:03,120 --> 00:06:05,199
using something like oauth or open id

174
00:06:05,199 --> 00:06:06,639
connect so i'm not going to focus on

175
00:06:06,639 --> 00:06:08,800
that much today the second attack

176
00:06:08,800 --> 00:06:11,199
surface is the application running on

177
00:06:11,199 --> 00:06:13,360
the device itself so this is both

178
00:06:13,360 --> 00:06:16,240
statically the application code

179
00:06:16,240 --> 00:06:18,880
as well as dynamically when it's running

180
00:06:18,880 --> 00:06:20,960
in the device environment

181
00:06:20,960 --> 00:06:22,880
once it's left the device an api call

182
00:06:22,880 --> 00:06:24,560
will transit across the channel and

183
00:06:24,560 --> 00:06:26,400
that's certainly a valid attack service

184
00:06:26,400 --> 00:06:28,160
as well can we get in and observe the

185
00:06:28,160 --> 00:06:31,360
actual api calls in action and the last

186
00:06:31,360 --> 00:06:33,680
attack surfaces is kind of the public or

187
00:06:33,680 --> 00:06:34,880
accidental

188
00:06:34,880 --> 00:06:36,720
surface which kind of gets a lot of

189
00:06:36,720 --> 00:06:37,680
press

190
00:06:37,680 --> 00:06:39,360
but if you have a public-facing api

191
00:06:39,360 --> 00:06:41,680
you've published documentation you may

192
00:06:41,680 --> 00:06:44,800
surprisingly publish api keys or

193
00:06:44,800 --> 00:06:46,319
protected calls you didn't really want

194
00:06:46,319 --> 00:06:47,600
to expose

195
00:06:47,600 --> 00:06:49,360
in that documentation

196
00:06:49,360 --> 00:06:52,639
and if you have a sort of public facing

197
00:06:52,639 --> 00:06:54,560
git repo for example

198
00:06:54,560 --> 00:06:56,319
it's not uncommon to accidentally

199
00:06:56,319 --> 00:06:57,280
publish

200
00:06:57,280 --> 00:06:59,840
credentials and secrets in those repos

201
00:06:59,840 --> 00:07:02,919
as well

202
00:07:03,280 --> 00:07:04,720
so how do you defend

203
00:07:04,720 --> 00:07:07,280
your api your first approach is trying

204
00:07:07,280 --> 00:07:09,680
to prevent reverse engineering those

205
00:07:09,680 --> 00:07:11,599
apis you want to do everything you can

206
00:07:11,599 --> 00:07:14,319
if it's not a public api to prevent

207
00:07:14,319 --> 00:07:16,560
understanding and observing that api in

208
00:07:16,560 --> 00:07:19,039
action that's a pretty tall order

209
00:07:19,039 --> 00:07:20,880
and you have to be pretty perfect to do

210
00:07:20,880 --> 00:07:22,560
that i don't know many applications that

211
00:07:22,560 --> 00:07:25,520
actually achieve that so barring that

212
00:07:25,520 --> 00:07:27,039
the second thing you need to do is make

213
00:07:27,039 --> 00:07:28,960
it very hard to construct a valid api

214
00:07:28,960 --> 00:07:31,039
call so when you require user

215
00:07:31,039 --> 00:07:33,520
credentials or when you require an api

216
00:07:33,520 --> 00:07:34,400
key

217
00:07:34,400 --> 00:07:37,039
you're trying to prove some you know who

218
00:07:37,039 --> 00:07:39,360
is using your app or what is using your

219
00:07:39,360 --> 00:07:43,360
app your api calls to make them look as

220
00:07:43,360 --> 00:07:45,360
as valid as possible and to make them

221
00:07:45,360 --> 00:07:47,919
very hard for somebody to attack to

222
00:07:47,919 --> 00:07:50,000
attack unless they've been able to

223
00:07:50,000 --> 00:07:52,560
extract those secrets along the way

224
00:07:52,560 --> 00:07:54,400
and you don't have to be perfect it's

225
00:07:54,400 --> 00:07:56,479
unlikely you can be perfect and so

226
00:07:56,479 --> 00:07:58,240
whatever you need you're doing you need

227
00:07:58,240 --> 00:08:00,639
to just make it hard enough that it's

228
00:08:00,639 --> 00:08:02,400
really not profitable to it for an

229
00:08:02,400 --> 00:08:04,000
attacker to spend their time there and

230
00:08:04,000 --> 00:08:06,400
they will pivot off to another fatter

231
00:08:06,400 --> 00:08:09,280
less secure target to go after

232
00:08:09,280 --> 00:08:11,039
so we're going to use the ship fast

233
00:08:11,039 --> 00:08:12,960
application and ship raider the service

234
00:08:12,960 --> 00:08:14,639
that's attacking it

235
00:08:14,639 --> 00:08:17,120
for our exploits today

236
00:08:17,120 --> 00:08:19,360
this is a picture of a ship fast react

237
00:08:19,360 --> 00:08:21,360
native driver app

238
00:08:21,360 --> 00:08:23,759
it's basically an app where a driver

239
00:08:23,759 --> 00:08:24,639
will

240
00:08:24,639 --> 00:08:26,319
say hey i'm available to pick up

241
00:08:26,319 --> 00:08:27,360
packages

242
00:08:27,360 --> 00:08:30,319
the ship fast service will provide it a

243
00:08:30,319 --> 00:08:32,958
sort of nearest pickup point

244
00:08:32,958 --> 00:08:34,399
the driver will go ahead drive there

245
00:08:34,399 --> 00:08:35,519
pick it up

246
00:08:35,519 --> 00:08:37,279
take it to the destination and drop it

247
00:08:37,279 --> 00:08:39,279
off the driver will be paid by the

248
00:08:39,279 --> 00:08:41,120
distance that the driver drives or the

249
00:08:41,120 --> 00:08:42,479
time that it takes to deliver the

250
00:08:42,479 --> 00:08:43,519
package

251
00:08:43,519 --> 00:08:45,440
and what's perhaps a little bit unusual

252
00:08:45,440 --> 00:08:47,600
in this app is that there's a gratuity

253
00:08:47,600 --> 00:08:49,600
that goes with every shipment and that

254
00:08:49,600 --> 00:08:51,360
gratuity is actually

255
00:08:51,360 --> 00:08:53,279
set by the shipper when they place the

256
00:08:53,279 --> 00:08:55,839
order so some

257
00:08:55,839 --> 00:08:58,000
some delivery packages will have high

258
00:08:58,000 --> 00:08:59,519
graduations some will have zero

259
00:08:59,519 --> 00:09:01,600
gratuities and the driver doesn't get

260
00:09:01,600 --> 00:09:03,600
much choice in the matter the ship fast

261
00:09:03,600 --> 00:09:05,519
wants to maximize their throughput so

262
00:09:05,519 --> 00:09:06,959
they're going to assign the nearest

263
00:09:06,959 --> 00:09:09,360
shipment regardless of that gratuity and

264
00:09:09,360 --> 00:09:11,839
drivers don't necessarily like that

265
00:09:11,839 --> 00:09:13,680
this is what the api sequence looks like

266
00:09:13,680 --> 00:09:15,519
for pickup and delivery and really the

267
00:09:15,519 --> 00:09:17,600
key call here is the one that's

268
00:09:17,600 --> 00:09:19,279
highlighted in yellow

269
00:09:19,279 --> 00:09:22,160
this is the get nearest shipment call

270
00:09:22,160 --> 00:09:25,120
we're using an api key to identify the

271
00:09:25,120 --> 00:09:27,839
app as well as a standard sort of oauth

272
00:09:27,839 --> 00:09:30,720
to bearer jot token kind of access token

273
00:09:30,720 --> 00:09:32,720
for authorization

274
00:09:32,720 --> 00:09:35,839
so that's provided and then the latitude

275
00:09:35,839 --> 00:09:38,320
and longitude of the driver the location

276
00:09:38,320 --> 00:09:40,720
of their devices used to identify what

277
00:09:40,720 --> 00:09:43,120
is the nearest package to that driver

278
00:09:43,120 --> 00:09:46,480
when they indicate they're available

279
00:09:46,480 --> 00:09:48,560
so one of the drivers decided they

280
00:09:48,560 --> 00:09:50,800
wanted to see if they could get into

281
00:09:50,800 --> 00:09:53,040
this api and figure out how could they

282
00:09:53,040 --> 00:09:56,320
see where there are the highest gratuity

283
00:09:56,320 --> 00:09:57,920
deliveries not just the ones that are

284
00:09:57,920 --> 00:09:59,760
nearest to them

285
00:09:59,760 --> 00:10:02,640
so they started hacking into the api and

286
00:10:02,640 --> 00:10:04,480
they were able to first do a proof of

287
00:10:04,480 --> 00:10:06,240
concept in a web app and then finally

288
00:10:06,240 --> 00:10:08,079
bake it into

289
00:10:08,079 --> 00:10:10,959
a sort of tweaked out version of the app

290
00:10:10,959 --> 00:10:12,560
that would enable a driver when they're

291
00:10:12,560 --> 00:10:14,880
available to see a range of shipments

292
00:10:14,880 --> 00:10:16,399
near them that would show them all the

293
00:10:16,399 --> 00:10:18,399
different gratuities and enable them to

294
00:10:18,399 --> 00:10:19,920
select not necessarily the nearest

295
00:10:19,920 --> 00:10:21,519
package but the one that is going to be

296
00:10:21,519 --> 00:10:24,160
most profitable for them

297
00:10:24,160 --> 00:10:25,920
so

298
00:10:25,920 --> 00:10:28,000
the drivers in this case really do like

299
00:10:28,000 --> 00:10:29,279
the ability to do this and they'll

300
00:10:29,279 --> 00:10:31,279
readily give up things such as their

301
00:10:31,279 --> 00:10:33,680
user credentials into this modified app

302
00:10:33,680 --> 00:10:36,320
in order to take this advantage

303
00:10:36,320 --> 00:10:38,480
um so the exploit that was actually used

304
00:10:38,480 --> 00:10:40,880
here focused again on that nearest

305
00:10:40,880 --> 00:10:42,399
shipment call

306
00:10:42,399 --> 00:10:44,640
as we can see when the

307
00:10:44,640 --> 00:10:46,880
shipment with proper user authorization

308
00:10:46,880 --> 00:10:48,800
and api key

309
00:10:48,800 --> 00:10:50,480
requests the nearest shipment it gets

310
00:10:50,480 --> 00:10:52,399
information back about that shipment for

311
00:10:52,399 --> 00:10:54,240
the driver to accept

312
00:10:54,240 --> 00:10:56,399
it includes the latitude and longitude

313
00:10:56,399 --> 00:10:58,240
and all the exploit would do in this

314
00:10:58,240 --> 00:11:00,399
case would be to repeatedly loop over

315
00:11:00,399 --> 00:11:01,680
this call

316
00:11:01,680 --> 00:11:03,440
providing a range of latitudes and

317
00:11:03,440 --> 00:11:06,240
longitudes to get a picture of where are

318
00:11:06,240 --> 00:11:08,640
the shipments around the driver

319
00:11:08,640 --> 00:11:10,160
and they'll get information both on

320
00:11:10,160 --> 00:11:12,160
where the start point is as well as the

321
00:11:12,160 --> 00:11:14,000
gratuity itself that the driver will

322
00:11:14,000 --> 00:11:16,720
then select from

323
00:11:16,720 --> 00:11:18,079
so we're going to move into the react

324
00:11:18,079 --> 00:11:20,800
native ship fast separator battle

325
00:11:20,800 --> 00:11:22,800
we have a reasonable security posture

326
00:11:22,800 --> 00:11:24,320
set up here

327
00:11:24,320 --> 00:11:26,079
there's an app which is going to be

328
00:11:26,079 --> 00:11:28,959
using user authentication through oauth

329
00:11:28,959 --> 00:11:30,560
it's going to be receiving an access

330
00:11:30,560 --> 00:11:32,480
token once the user credentials are

331
00:11:32,480 --> 00:11:33,760
verified

332
00:11:33,760 --> 00:11:36,399
it's going to be making api calls across

333
00:11:36,399 --> 00:11:37,200
a

334
00:11:37,200 --> 00:11:38,920
tls secure or

335
00:11:38,920 --> 00:11:41,120
https call

336
00:11:41,120 --> 00:11:44,160
using a single api key back into a

337
00:11:44,160 --> 00:11:46,160
back-end api server proxy which i'll

338
00:11:46,160 --> 00:11:48,640
talk a little bit about in the future

339
00:11:48,640 --> 00:11:51,279
that proxy in turn will

340
00:11:51,279 --> 00:11:54,079
will assemble the information it wants

341
00:11:54,079 --> 00:11:56,320
through the range of whatever internal

342
00:11:56,320 --> 00:12:00,160
or third party services are being used

343
00:12:00,480 --> 00:12:02,480
so one big point i want to stress is

344
00:12:02,480 --> 00:12:04,720
that user authentic authorization by

345
00:12:04,720 --> 00:12:07,839
itself is not service authorization so

346
00:12:07,839 --> 00:12:10,240
in the case of ship fast and ship raider

347
00:12:10,240 --> 00:12:12,000
customers will readily give up their

348
00:12:12,000 --> 00:12:13,760
user credentials if they think they're

349
00:12:13,760 --> 00:12:15,040
going to get something good in return

350
00:12:15,040 --> 00:12:17,120
and in this case what they're getting

351
00:12:17,120 --> 00:12:19,040
is the opportunity to get much higher

352
00:12:19,040 --> 00:12:22,160
gratuities for each trip they make

353
00:12:22,160 --> 00:12:22,959
so

354
00:12:22,959 --> 00:12:25,200
user authentication is an attempt to

355
00:12:25,200 --> 00:12:28,639
indicate who is using this api

356
00:12:28,639 --> 00:12:30,320
but what you really need to focus on and

357
00:12:30,320 --> 00:12:32,160
what traditionally is focused on with

358
00:12:32,160 --> 00:12:34,800
api keys is identifying what is it

359
00:12:34,800 --> 00:12:37,360
that's calling your api

360
00:12:37,360 --> 00:12:39,120
and aggregators that will reverse

361
00:12:39,120 --> 00:12:41,360
engineer apis are basically going to see

362
00:12:41,360 --> 00:12:44,079
how can they set up additional who and

363
00:12:44,079 --> 00:12:45,920
what kind of information to attack these

364
00:12:45,920 --> 00:12:48,399
apis

365
00:12:48,480 --> 00:12:50,639
there's almost always and i do strongly

366
00:12:50,639 --> 00:12:52,959
recommend that there be some reasonable

367
00:12:52,959 --> 00:12:55,120
uh defenses in place at the backend

368
00:12:55,120 --> 00:12:57,200
service itself usually built into api

369
00:12:57,200 --> 00:12:59,519
gateways you'll do rate and resource

370
00:12:59,519 --> 00:13:01,200
limiting to try and make sure calls

371
00:13:01,200 --> 00:13:01,920
aren't

372
00:13:01,920 --> 00:13:04,480
coming too fast or that they're not

373
00:13:04,480 --> 00:13:07,200
using too much of their high value

374
00:13:07,200 --> 00:13:08,560
resources

375
00:13:08,560 --> 00:13:10,639
you can do this also in a behavioral

376
00:13:10,639 --> 00:13:12,880
sense by examining some of the data in

377
00:13:12,880 --> 00:13:15,040
the api calls themselves

378
00:13:15,040 --> 00:13:18,399
for instance we could see a set of calls

379
00:13:18,399 --> 00:13:19,839
looking for nearest shipments from the

380
00:13:19,839 --> 00:13:21,519
same driver with different latitudes and

381
00:13:21,519 --> 00:13:24,160
longitudes calculate the velocity the

382
00:13:24,160 --> 00:13:25,920
driver would have to be driving to get

383
00:13:25,920 --> 00:13:28,480
from point a to point b to point c um

384
00:13:28,480 --> 00:13:29,839
and pretty much conclude they're going

385
00:13:29,839 --> 00:13:32,000
way too fast for reality

386
00:13:32,000 --> 00:13:34,000
you can bake these kind of resource

387
00:13:34,000 --> 00:13:36,720
checks and data checks uh automatically

388
00:13:36,720 --> 00:13:38,160
into

389
00:13:38,160 --> 00:13:40,720
calling pattern anomalies using uh deep

390
00:13:40,720 --> 00:13:42,240
learning kind of techniques ai

391
00:13:42,240 --> 00:13:43,279
techniques

392
00:13:43,279 --> 00:13:46,000
um to train a system to recognize these

393
00:13:46,000 --> 00:13:48,160
kind of anomalies

394
00:13:48,160 --> 00:13:50,079
the biggest challenge with all these

395
00:13:50,079 --> 00:13:52,959
systems is uh they're statistical based

396
00:13:52,959 --> 00:13:55,680
so they don't give you a firm yes or no

397
00:13:55,680 --> 00:13:56,880
answer

398
00:13:56,880 --> 00:13:59,440
and therefore it's possible

399
00:13:59,440 --> 00:14:01,360
the tighter you make these constraints

400
00:14:01,360 --> 00:14:03,519
the more false positives you're going to

401
00:14:03,519 --> 00:14:05,040
see we're actually potentially going to

402
00:14:05,040 --> 00:14:07,519
be rejecting legitimate customer usage

403
00:14:07,519 --> 00:14:10,800
of your apis so most of the time

404
00:14:10,800 --> 00:14:13,760
these kinds of rate and resource checks

405
00:14:13,760 --> 00:14:15,839
are loosened up to try and make sure

406
00:14:15,839 --> 00:14:18,160
that you don't turn away any legitimate

407
00:14:18,160 --> 00:14:20,079
users and

408
00:14:20,079 --> 00:14:22,560
by extension you're allowing potentially

409
00:14:22,560 --> 00:14:25,120
more malicious users in through this

410
00:14:25,120 --> 00:14:28,000
api gateway

411
00:14:28,560 --> 00:14:31,040
i do strongly recommend that you use an

412
00:14:31,040 --> 00:14:33,040
api proxy pattern and that with your

413
00:14:33,040 --> 00:14:36,079
react native app you develop a

414
00:14:36,079 --> 00:14:38,000
a single api

415
00:14:38,000 --> 00:14:40,320
between your app and the api proxy

416
00:14:40,320 --> 00:14:41,360
server

417
00:14:41,360 --> 00:14:43,839
and then that proxy server itself will

418
00:14:43,839 --> 00:14:45,519
fan out and

419
00:14:45,519 --> 00:14:47,199
implement those calls

420
00:14:47,199 --> 00:14:49,040
using whatever third party and internal

421
00:14:49,040 --> 00:14:50,720
services you want

422
00:14:50,720 --> 00:14:52,720
the main advantages you have here is

423
00:14:52,720 --> 00:14:55,199
that you've strongly decoupled the api a

424
00:14:55,199 --> 00:14:57,600
call between app and server and

425
00:14:57,600 --> 00:14:59,360
however you're going to fulfill those

426
00:14:59,360 --> 00:15:00,880
api calls

427
00:15:00,880 --> 00:15:03,440
you've taken what could be multiple api

428
00:15:03,440 --> 00:15:05,680
keys with multiple services

429
00:15:05,680 --> 00:15:06,560
and

430
00:15:06,560 --> 00:15:09,360
cut that down to one single api

431
00:15:09,360 --> 00:15:11,279
key that you're using within the app to

432
00:15:11,279 --> 00:15:12,639
service calls

433
00:15:12,639 --> 00:15:14,560
you can readily sort of evolve the

434
00:15:14,560 --> 00:15:16,959
backend switch service providers for

435
00:15:16,959 --> 00:15:19,680
your maps for example update api keys

436
00:15:19,680 --> 00:15:21,519
you can do all that without touching the

437
00:15:21,519 --> 00:15:25,199
back the application that's running

438
00:15:25,199 --> 00:15:26,880
and you can evolve

439
00:15:26,880 --> 00:15:29,759
the security for example of the apis

440
00:15:29,759 --> 00:15:32,399
between app and api service

441
00:15:32,399 --> 00:15:34,959
without impacting the back end

442
00:15:34,959 --> 00:15:37,120
so this kind of strong cup decoupling is

443
00:15:37,120 --> 00:15:38,959
good and i would even recommend that

444
00:15:38,959 --> 00:15:41,920
this api calling protocol between app

445
00:15:41,920 --> 00:15:45,040
and api service not be the same as your

446
00:15:45,040 --> 00:15:46,079
plain

447
00:15:46,079 --> 00:15:47,759
web applications if you're running web

448
00:15:47,759 --> 00:15:51,680
applications with similar functionality

449
00:15:52,560 --> 00:15:53,360
so

450
00:15:53,360 --> 00:15:55,040
let's look at the first attack that's

451
00:15:55,040 --> 00:15:56,320
going to be happening on the react

452
00:15:56,320 --> 00:15:59,440
native app as you know react native is

453
00:15:59,440 --> 00:16:02,160
enabling you to write your code much of

454
00:16:02,160 --> 00:16:04,320
your code in javascript

455
00:16:04,320 --> 00:16:06,880
and that in turn goes across a react

456
00:16:06,880 --> 00:16:09,600
native bridge and those javascript calls

457
00:16:09,600 --> 00:16:11,440
are being fulfilled

458
00:16:11,440 --> 00:16:14,480
in the backend native modules so you'll

459
00:16:14,480 --> 00:16:16,560
be making ui requests networking

460
00:16:16,560 --> 00:16:19,120
requests other platform requests

461
00:16:19,120 --> 00:16:21,040
initiated from the javascript layer

462
00:16:21,040 --> 00:16:23,839
traveling back into the native layer

463
00:16:23,839 --> 00:16:25,680
where they're fulfilled

464
00:16:25,680 --> 00:16:28,160
so you have one

465
00:16:28,160 --> 00:16:30,480
javascript bundle in either android or

466
00:16:30,480 --> 00:16:33,040
ios that contains all the javascript

467
00:16:33,040 --> 00:16:34,959
code so the first thing that any hacker

468
00:16:34,959 --> 00:16:36,800
is going to do is they're going to start

469
00:16:36,800 --> 00:16:38,800
with that javascript bundle

470
00:16:38,800 --> 00:16:41,519
they're going to unzip it and unminify

471
00:16:41,519 --> 00:16:43,680
it and take a look at what's there

472
00:16:43,680 --> 00:16:47,680
is this code in any way protected so

473
00:16:47,680 --> 00:16:49,279
right off the bat what we see here is

474
00:16:49,279 --> 00:16:51,199
that there's been no obfuscation done on

475
00:16:51,199 --> 00:16:52,320
this code

476
00:16:52,320 --> 00:16:54,480
so you can unzip it and take a look at

477
00:16:54,480 --> 00:16:56,959
it and you can clearly read the api key

478
00:16:56,959 --> 00:16:58,560
constant there

479
00:16:58,560 --> 00:17:00,720
as well as you see the code that

480
00:17:00,720 --> 00:17:04,319
actually assembles the api calls here um

481
00:17:04,319 --> 00:17:06,480
so you're getting both the strings as

482
00:17:06,480 --> 00:17:08,240
well as what additional parameters are

483
00:17:08,240 --> 00:17:11,199
being used in those api calls um so

484
00:17:11,199 --> 00:17:13,199
right off the bat here pretty easy

485
00:17:13,199 --> 00:17:15,520
attack to extract both the api key as

486
00:17:15,520 --> 00:17:16,880
well as the api

487
00:17:16,880 --> 00:17:19,280
calls themselves

488
00:17:19,280 --> 00:17:20,959
so your first defense is going to be to

489
00:17:20,959 --> 00:17:23,359
obfuscate this code so you're going to

490
00:17:23,359 --> 00:17:25,359
be trying to

491
00:17:25,359 --> 00:17:27,520
hide the secrets in the code

492
00:17:27,520 --> 00:17:30,640
as well as to blur out any kind of

493
00:17:30,640 --> 00:17:32,400
business logic to try and make it more

494
00:17:32,400 --> 00:17:34,000
difficult to follow the control flow of

495
00:17:34,000 --> 00:17:35,440
the application

496
00:17:35,440 --> 00:17:36,960
and there are various

497
00:17:36,960 --> 00:17:38,559
extensions you can add into this

498
00:17:38,559 --> 00:17:40,880
obfuscation as well as knobs you can

499
00:17:40,880 --> 00:17:43,440
turn to make the obfuscation more and

500
00:17:43,440 --> 00:17:46,240
more difficult to understand when you

501
00:17:46,240 --> 00:17:48,640
turn those knobs up too extreme

502
00:17:48,640 --> 00:17:51,039
you'll start costing the

503
00:17:51,039 --> 00:17:53,120
cost of actually de-obfuscating on the

504
00:17:53,120 --> 00:17:55,200
fly and the runtime will grow

505
00:17:55,200 --> 00:17:56,720
and the performance of the application

506
00:17:56,720 --> 00:17:58,960
overall may start to slow so you need to

507
00:17:58,960 --> 00:18:01,440
find a balance there between how obscure

508
00:18:01,440 --> 00:18:03,039
how much obfuscation you're going to be

509
00:18:03,039 --> 00:18:03,919
doing

510
00:18:03,919 --> 00:18:05,440
versus the kind of changes in

511
00:18:05,440 --> 00:18:07,280
performance that you're willing to

512
00:18:07,280 --> 00:18:08,720
put up with

513
00:18:08,720 --> 00:18:11,360
so i'll be recommending some

514
00:18:11,360 --> 00:18:13,360
free freely available packages

515
00:18:13,360 --> 00:18:14,640
throughout the talk

516
00:18:14,640 --> 00:18:16,559
so i would start with the javascript

517
00:18:16,559 --> 00:18:18,480
obfuscator package it gives you a good

518
00:18:18,480 --> 00:18:21,200
broad range of techniques that you can

519
00:18:21,200 --> 00:18:22,960
use in obfuscation

520
00:18:22,960 --> 00:18:25,600
i've taken and used that tool on the

521
00:18:25,600 --> 00:18:27,760
original unobfuscated code and just set

522
00:18:27,760 --> 00:18:29,919
the knobs very very lightly

523
00:18:29,919 --> 00:18:31,440
so if you look down here on the right

524
00:18:31,440 --> 00:18:33,600
you see that we started to cut up some

525
00:18:33,600 --> 00:18:36,240
of the strings into smaller pieces

526
00:18:36,240 --> 00:18:37,200
as you

527
00:18:37,200 --> 00:18:39,600
increase the the knobs here for strings

528
00:18:39,600 --> 00:18:41,520
you'll start to see them also be

529
00:18:41,520 --> 00:18:44,240
encrypted so they're not as easily uh

530
00:18:44,240 --> 00:18:46,240
just gathered by doing a simple sort of

531
00:18:46,240 --> 00:18:49,120
strings examination of the code

532
00:18:49,120 --> 00:18:50,000
and

533
00:18:50,000 --> 00:18:52,320
and we're starting to cut up all of the

534
00:18:52,320 --> 00:18:55,360
string assembly as well for those api

535
00:18:55,360 --> 00:18:57,520
calls

536
00:18:57,520 --> 00:19:00,160
so if you've obscured the code strongly

537
00:19:00,160 --> 00:19:00,960
enough

538
00:19:00,960 --> 00:19:02,960
then the attacker is going to pivot most

539
00:19:02,960 --> 00:19:05,200
likely off the device and take a look in

540
00:19:05,200 --> 00:19:08,080
the channel between the application and

541
00:19:08,080 --> 00:19:09,440
the back

542
00:19:09,440 --> 00:19:11,600
service that's being called

543
00:19:11,600 --> 00:19:12,400
so

544
00:19:12,400 --> 00:19:13,520
usually

545
00:19:13,520 --> 00:19:16,240
all api calls are going to be tls

546
00:19:16,240 --> 00:19:18,640
based and that security will encrypt the

547
00:19:18,640 --> 00:19:19,520
channel

548
00:19:19,520 --> 00:19:21,679
which is always a very important thing

549
00:19:21,679 --> 00:19:23,919
to do to make sure that it's not easy to

550
00:19:23,919 --> 00:19:24,880
observe

551
00:19:24,880 --> 00:19:26,799
but unfortunately

552
00:19:26,799 --> 00:19:28,960
one of the advantages that the attacker

553
00:19:28,960 --> 00:19:31,760
has is there they are in full control of

554
00:19:31,760 --> 00:19:33,360
the device that the application is

555
00:19:33,360 --> 00:19:34,720
running on

556
00:19:34,720 --> 00:19:37,360
so a very typical way to launch a man in

557
00:19:37,360 --> 00:19:40,400
the middle type attack would be to

558
00:19:40,400 --> 00:19:43,360
go ahead and generate a fake tls

559
00:19:43,360 --> 00:19:46,799
certificate that says trust me i am the

560
00:19:46,799 --> 00:19:48,720
backend service

561
00:19:48,720 --> 00:19:50,720
and i will take that certificate and

562
00:19:50,720 --> 00:19:52,160
because i control the device i'll

563
00:19:52,160 --> 00:19:55,120
install it install it in the operating

564
00:19:55,120 --> 00:19:57,120
systems trust store

565
00:19:57,120 --> 00:19:58,799
so that when the application actually

566
00:19:58,799 --> 00:20:00,640
makes a call

567
00:20:00,640 --> 00:20:02,720
i will respond as the man in the middle

568
00:20:02,720 --> 00:20:05,840
with this tls circuit certificate and

569
00:20:05,840 --> 00:20:07,679
the operating system will say yes it's

570
00:20:07,679 --> 00:20:10,159
acceptable to trust the certificate

571
00:20:10,159 --> 00:20:13,360
and it will enable me to establish a an

572
00:20:13,360 --> 00:20:15,120
encrypted channel between the app and

573
00:20:15,120 --> 00:20:17,840
myself which i can easily decrypt

574
00:20:17,840 --> 00:20:20,000
as well as i can either

575
00:20:20,000 --> 00:20:22,240
observe and pass that on to the back end

576
00:20:22,240 --> 00:20:25,200
channel or i can manipulate these calls

577
00:20:25,200 --> 00:20:27,120
along the way

578
00:20:27,120 --> 00:20:28,159
so

579
00:20:28,159 --> 00:20:31,360
that's a very common second attack

580
00:20:31,360 --> 00:20:34,240
the way to counteract that attack is

581
00:20:34,240 --> 00:20:36,880
typically through certificate pinning

582
00:20:36,880 --> 00:20:38,960
and here because we can't trust the

583
00:20:38,960 --> 00:20:40,960
device that the application is running

584
00:20:40,960 --> 00:20:43,360
on we're going to sort of set up an

585
00:20:43,360 --> 00:20:45,760
application specific

586
00:20:45,760 --> 00:20:47,679
trust store so a trust store within the

587
00:20:47,679 --> 00:20:50,159
application itself a list of

588
00:20:50,159 --> 00:20:52,080
just the few certificates that i'm

589
00:20:52,080 --> 00:20:55,280
expecting to see from the back end

590
00:20:55,280 --> 00:20:57,360
you can pin the certificates themselves

591
00:20:57,360 --> 00:20:59,360
or you can pin the public keys held by

592
00:20:59,360 --> 00:21:01,360
those certificates the advantage pinning

593
00:21:01,360 --> 00:21:03,679
public keys is that more than one

594
00:21:03,679 --> 00:21:05,600
certificate can be used

595
00:21:05,600 --> 00:21:08,960
to protect the same public key signature

596
00:21:08,960 --> 00:21:10,720
there is support for pinning

597
00:21:10,720 --> 00:21:12,799
certificates and many native networking

598
00:21:12,799 --> 00:21:14,880
stacks for react native on android for

599
00:21:14,880 --> 00:21:17,840
example ok http is the native stack

600
00:21:17,840 --> 00:21:19,360
that's being used and there is a

601
00:21:19,360 --> 00:21:20,960
certificate pinner

602
00:21:20,960 --> 00:21:22,559
support there

603
00:21:22,559 --> 00:21:24,720
one of the biggest issues about pinning

604
00:21:24,720 --> 00:21:27,200
and why no i think not enough people do

605
00:21:27,200 --> 00:21:29,039
it is there's a concern about the

606
00:21:29,039 --> 00:21:30,559
maintenance of certificate pinning and

607
00:21:30,559 --> 00:21:32,320
i'm sure you've heard of

608
00:21:32,320 --> 00:21:34,559
services that have gone down

609
00:21:34,559 --> 00:21:37,280
because this certificate has expired

610
00:21:37,280 --> 00:21:38,480
over time

611
00:21:38,480 --> 00:21:40,000
so this is concerned that if a

612
00:21:40,000 --> 00:21:42,799
certificate expires the the application

613
00:21:42,799 --> 00:21:45,360
will not be able to contact the back end

614
00:21:45,360 --> 00:21:47,919
and may not even be able to get the an

615
00:21:47,919 --> 00:21:49,600
updated certificate because it can't

616
00:21:49,600 --> 00:21:51,200
make a valid connection

617
00:21:51,200 --> 00:21:52,960
and that will require you to sort of

618
00:21:52,960 --> 00:21:54,640
back out and

619
00:21:54,640 --> 00:21:57,039
and use the app store to get an entirely

620
00:21:57,039 --> 00:21:59,600
new or updated app installed

621
00:21:59,600 --> 00:22:01,440
um

622
00:22:01,440 --> 00:22:05,360
so let's assume that the attacker is uh

623
00:22:05,360 --> 00:22:07,600
has

624
00:22:07,760 --> 00:22:10,159
launched a man in the middle attack and

625
00:22:10,159 --> 00:22:12,559
um now we're going to have to pin the

626
00:22:12,559 --> 00:22:14,559
channel to to defend it there are a

627
00:22:14,559 --> 00:22:15,919
couple different ways you can go about

628
00:22:15,919 --> 00:22:16,960
this

629
00:22:16,960 --> 00:22:18,720
i've shown just here at the top how to

630
00:22:18,720 --> 00:22:20,880
generate a public key fingerprint

631
00:22:20,880 --> 00:22:22,480
and i've recommended two packages here

632
00:22:22,480 --> 00:22:23,919
you can take a look at

633
00:22:23,919 --> 00:22:27,280
the first one react native ssl pinning

634
00:22:27,280 --> 00:22:28,400
pins

635
00:22:28,400 --> 00:22:31,039
within the javascript stack itself

636
00:22:31,039 --> 00:22:33,120
so it actually takes the typical fetch

637
00:22:33,120 --> 00:22:34,159
call

638
00:22:34,159 --> 00:22:36,400
and augments it with additional pinning

639
00:22:36,400 --> 00:22:39,120
information so if you want to use this

640
00:22:39,120 --> 00:22:40,880
technique you're going to have to go in

641
00:22:40,880 --> 00:22:42,559
and at each api calling site you're

642
00:22:42,559 --> 00:22:44,240
going to have to augment your calls

643
00:22:44,240 --> 00:22:46,880
themselves alternatively is the react

644
00:22:46,880 --> 00:22:49,200
native cert pinner

645
00:22:49,200 --> 00:22:51,600
npm package that you can look at

646
00:22:51,600 --> 00:22:53,440
and here the

647
00:22:53,440 --> 00:22:55,679
pinning actually takes place within the

648
00:22:55,679 --> 00:22:58,559
native networking layers themselves

649
00:22:58,559 --> 00:23:01,360
so in in this case there's absolutely no

650
00:23:01,360 --> 00:23:03,360
impact to the javascript um you're just

651
00:23:03,360 --> 00:23:05,440
making normal fetch calls and all the

652
00:23:05,440 --> 00:23:07,600
pinning is taking place down lower

653
00:23:07,600 --> 00:23:09,039
within the native

654
00:23:09,039 --> 00:23:11,360
code itself the advantage to that is

655
00:23:11,360 --> 00:23:13,679
that those can be quite well hidden

656
00:23:13,679 --> 00:23:16,080
within the native domain the the

657
00:23:16,080 --> 00:23:18,080
disadvantage perhaps in this technique

658
00:23:18,080 --> 00:23:19,440
is that it is

659
00:23:19,440 --> 00:23:20,880
less dynamic

660
00:23:20,880 --> 00:23:22,480
so when you install

661
00:23:22,480 --> 00:23:24,960
and set up these pins

662
00:23:24,960 --> 00:23:27,120
if you need to update or change these

663
00:23:27,120 --> 00:23:29,840
pins you may be forced to trigger a

664
00:23:29,840 --> 00:23:32,400
relaunch of the device in order to

665
00:23:32,400 --> 00:23:34,080
to have them

666
00:23:34,080 --> 00:23:36,480
be pinned when the device first picks up

667
00:23:36,480 --> 00:23:38,320
and that's different from what takes

668
00:23:38,320 --> 00:23:41,039
place in the native javascript layer

669
00:23:41,039 --> 00:23:42,960
where these pins can be changed between

670
00:23:42,960 --> 00:23:46,640
calls potentially if you wanted to

671
00:23:46,880 --> 00:23:49,039
so the attacker is going to

672
00:23:49,039 --> 00:23:51,279
get frustrated that it's not easy to do

673
00:23:51,279 --> 00:23:52,799
a man in the middle of attack to observe

674
00:23:52,799 --> 00:23:54,640
your api calls

675
00:23:54,640 --> 00:23:56,960
so their next step is to go about trying

676
00:23:56,960 --> 00:23:59,039
to unpin the channel

677
00:23:59,039 --> 00:24:00,799
and the common techniques that used for

678
00:24:00,799 --> 00:24:03,200
that is to go ahead and install an

679
00:24:03,200 --> 00:24:06,080
instrumentation framework on the device

680
00:24:06,080 --> 00:24:07,679
these instrumentation frameworks are

681
00:24:07,679 --> 00:24:09,760
typically used during debugging of

682
00:24:09,760 --> 00:24:11,919
applications where you're trying to tune

683
00:24:11,919 --> 00:24:13,440
say performance

684
00:24:13,440 --> 00:24:15,039
and they enable you to get in and sort

685
00:24:15,039 --> 00:24:17,039
of hook function calls add additional

686
00:24:17,039 --> 00:24:19,120
instrumentation count function call

687
00:24:19,120 --> 00:24:21,440
sequences and and such so great

688
00:24:21,440 --> 00:24:23,360
advantage for debuggers trying to

689
00:24:23,360 --> 00:24:25,120
optimize your your

690
00:24:25,120 --> 00:24:26,559
applications

691
00:24:26,559 --> 00:24:29,520
but also very great tools for attackers

692
00:24:29,520 --> 00:24:31,200
to learn more about your application and

693
00:24:31,200 --> 00:24:33,840
to sort of manipulate it during actual

694
00:24:33,840 --> 00:24:36,880
run time so the steps here would be to

695
00:24:36,880 --> 00:24:38,640
go ahead and root or jailbreak your

696
00:24:38,640 --> 00:24:41,520
device install a instrumentation

697
00:24:41,520 --> 00:24:43,279
framework here i'm showing frida which

698
00:24:43,279 --> 00:24:45,360
is a very popular framework

699
00:24:45,360 --> 00:24:47,440
and you're going to be looking to hook

700
00:24:47,440 --> 00:24:51,039
the call that says am i properly pinned

701
00:24:51,039 --> 00:24:54,000
and replace that with just a function

702
00:24:54,000 --> 00:24:56,240
that's going to always report yes i'm

703
00:24:56,240 --> 00:24:59,440
perfectly well pinned you're good to go

704
00:24:59,440 --> 00:25:01,120
so you do that

705
00:25:01,120 --> 00:25:03,679
by in frida's case there are actually a

706
00:25:03,679 --> 00:25:05,120
number of public scripts that you can

707
00:25:05,120 --> 00:25:07,039
take a look at and adapt your own

708
00:25:07,039 --> 00:25:08,640
circumstance

709
00:25:08,640 --> 00:25:10,799
if you've obfuscated the code

710
00:25:10,799 --> 00:25:12,799
you may not be able to as easily

711
00:25:12,799 --> 00:25:14,240
recognize some of the function names

712
00:25:14,240 --> 00:25:15,919
themselves so you're going to start a

713
00:25:15,919 --> 00:25:17,840
certain amount of trial and effort to

714
00:25:17,840 --> 00:25:20,159
identify the calling signatures

715
00:25:20,159 --> 00:25:21,600
and if you can narrow in on the

716
00:25:21,600 --> 00:25:23,520
signatures that are being called those

717
00:25:23,520 --> 00:25:24,799
are the functions you'll target or

718
00:25:24,799 --> 00:25:26,400
replace and obviously they'll be

719
00:25:26,400 --> 00:25:28,159
functions that have similar signatures

720
00:25:28,159 --> 00:25:30,799
so you'll you'll go through a bit of

721
00:25:30,799 --> 00:25:32,799
trial error until you go the right ones

722
00:25:32,799 --> 00:25:34,000
there

723
00:25:34,000 --> 00:25:35,840
an alternative if you don't want to

724
00:25:35,840 --> 00:25:37,600
unpin the device itself would be to go

725
00:25:37,600 --> 00:25:40,720
in and try and actually monkey patch the

726
00:25:40,720 --> 00:25:42,720
fetch calls themselves

727
00:25:42,720 --> 00:25:45,039
whether the raw fetch calls that were

728
00:25:45,039 --> 00:25:47,039
being used with the

729
00:25:47,039 --> 00:25:48,960
cert pinner package or whether you're

730
00:25:48,960 --> 00:25:50,480
looking at the augmented fetch calls

731
00:25:50,480 --> 00:25:52,240
with the other package

732
00:25:52,240 --> 00:25:53,679
either way you can potentially hook

733
00:25:53,679 --> 00:25:55,760
those functions completely and replace

734
00:25:55,760 --> 00:25:57,440
them with an entirely different network

735
00:25:57,440 --> 00:25:59,760
stack

736
00:26:00,240 --> 00:26:02,159
so how do you defend against this well

737
00:26:02,159 --> 00:26:04,880
the first uh and best defense is trying

738
00:26:04,880 --> 00:26:07,039
to block the routing or jailbreaking of

739
00:26:07,039 --> 00:26:08,480
your devices

740
00:26:08,480 --> 00:26:10,159
so try and make sure that your app will

741
00:26:10,159 --> 00:26:12,480
not work if it detects that um there's

742
00:26:12,480 --> 00:26:14,720
been any kind of routing going on

743
00:26:14,720 --> 00:26:17,039
additionally if you don't

744
00:26:17,039 --> 00:26:18,960
identify routing you can also look

745
00:26:18,960 --> 00:26:21,600
through actual

746
00:26:21,600 --> 00:26:23,600
operation and memory maps to try and see

747
00:26:23,600 --> 00:26:24,480
if you can

748
00:26:24,480 --> 00:26:26,480
see signatures that indicate that

749
00:26:26,480 --> 00:26:28,960
instrumentation packages do seem to be

750
00:26:28,960 --> 00:26:31,120
on the device and running

751
00:26:31,120 --> 00:26:32,720
so for react native you can use a

752
00:26:32,720 --> 00:26:34,880
package such as the npm package

753
00:26:34,880 --> 00:26:36,480
geomonkey

754
00:26:36,480 --> 00:26:38,799
and this will uh it's implemented

755
00:26:38,799 --> 00:26:40,159
natively but this will give you

756
00:26:40,159 --> 00:26:42,400
information about whether it believes

757
00:26:42,400 --> 00:26:44,559
that the device is jailbroken or rooted

758
00:26:44,559 --> 00:26:46,080
um and you can

759
00:26:46,080 --> 00:26:47,840
use this as a first line of defense

760
00:26:47,840 --> 00:26:49,039
against blocking these kind of

761
00:26:49,039 --> 00:26:50,320
techniques

762
00:26:50,320 --> 00:26:52,799
because they're just native packages um

763
00:26:52,799 --> 00:26:55,200
these packages potentially are

764
00:26:55,200 --> 00:26:58,559
vulnerable to monkey packaging um and uh

765
00:26:58,559 --> 00:27:00,720
their signatures are very plain so at

766
00:27:00,720 --> 00:27:02,400
least you have that going for you if you

767
00:27:02,400 --> 00:27:04,559
can turn up the obfuscation they're a

768
00:27:04,559 --> 00:27:07,840
little bit harder to recognize

769
00:27:08,480 --> 00:27:11,840
so if you have successfully blocked the

770
00:27:11,840 --> 00:27:14,720
unpinning here now you have a highly

771
00:27:14,720 --> 00:27:16,640
obfuscated application

772
00:27:16,640 --> 00:27:18,559
when the attacker pivoted over to the

773
00:27:18,559 --> 00:27:19,600
channel

774
00:27:19,600 --> 00:27:20,960
you've pinned the channel so they've

775
00:27:20,960 --> 00:27:22,799
been frustrated trying to observe what's

776
00:27:22,799 --> 00:27:24,799
going on there in the channel

777
00:27:24,799 --> 00:27:26,640
and you might find

778
00:27:26,640 --> 00:27:28,399
that you're going to be

779
00:27:28,399 --> 00:27:30,640
attacked by a source you didn't expect

780
00:27:30,640 --> 00:27:32,240
which would be your very own product

781
00:27:32,240 --> 00:27:33,520
manager

782
00:27:33,520 --> 00:27:36,240
and it's been our experience that many

783
00:27:36,240 --> 00:27:38,559
product managers are very nervous about

784
00:27:38,559 --> 00:27:40,000
certificate pinning

785
00:27:40,000 --> 00:27:41,520
so you may get a product manager who

786
00:27:41,520 --> 00:27:44,960
comes in and say i'm not going to allow

787
00:27:44,960 --> 00:27:47,200
any possibility of bricking my app

788
00:27:47,200 --> 00:27:49,360
so i'm going to disallow any certificate

789
00:27:49,360 --> 00:27:52,080
pinning so at this point you've lost

790
00:27:52,080 --> 00:27:55,440
your best defense here currently against

791
00:27:55,440 --> 00:27:57,760
encrypting and securing that channel

792
00:27:57,760 --> 00:27:59,600
so what you're going to have to do is

793
00:27:59,600 --> 00:28:01,279
you're going to have to pivot and move

794
00:28:01,279 --> 00:28:03,760
up the abstraction stack and see if you

795
00:28:03,760 --> 00:28:04,640
can

796
00:28:04,640 --> 00:28:07,279
encrypt or at least detect any kind of

797
00:28:07,279 --> 00:28:08,559
tampering

798
00:28:08,559 --> 00:28:09,520
occurring

799
00:28:09,520 --> 00:28:11,360
at the application level

800
00:28:11,360 --> 00:28:12,960
of the messages that are being passed

801
00:28:12,960 --> 00:28:14,240
back and forth

802
00:28:14,240 --> 00:28:15,600
so in this case we're going to use a

803
00:28:15,600 --> 00:28:17,360
somewhat ad hoc technique where we're

804
00:28:17,360 --> 00:28:19,039
just going to

805
00:28:19,039 --> 00:28:21,520
take an api call

806
00:28:21,520 --> 00:28:23,039
and we're going to

807
00:28:23,039 --> 00:28:24,399
add a secret

808
00:28:24,399 --> 00:28:27,200
for signing messages to the app

809
00:28:27,200 --> 00:28:28,960
we're going to assemble a message from

810
00:28:28,960 --> 00:28:31,600
the api call itself and a little bit of

811
00:28:31,600 --> 00:28:33,440
entropy it's not the best entropy in the

812
00:28:33,440 --> 00:28:34,960
world but you might take the access

813
00:28:34,960 --> 00:28:36,720
token for example for the user

814
00:28:36,720 --> 00:28:38,960
authorization assemble the message from

815
00:28:38,960 --> 00:28:40,799
those two and then

816
00:28:40,799 --> 00:28:43,120
sign it with an hmac algorithm using the

817
00:28:43,120 --> 00:28:44,880
secret that you've now stored on the

818
00:28:44,880 --> 00:28:46,159
device

819
00:28:46,159 --> 00:28:48,080
you're going to pass that's that secret

820
00:28:48,080 --> 00:28:50,480
across this is not encrypting the call

821
00:28:50,480 --> 00:28:52,399
in this example but what it's doing is

822
00:28:52,399 --> 00:28:54,080
trying to ensure that the call itself

823
00:28:54,080 --> 00:28:56,960
has not been manipulated in any way

824
00:28:56,960 --> 00:29:00,320
the back end service will receive the

825
00:29:00,320 --> 00:29:01,760
api call

826
00:29:01,760 --> 00:29:03,360
we'll assemble the message from the

827
00:29:03,360 --> 00:29:04,640
components

828
00:29:04,640 --> 00:29:06,240
and we'll go ahead and use the same

829
00:29:06,240 --> 00:29:07,919
secret which it knows

830
00:29:07,919 --> 00:29:10,000
run it through the hmac calculation and

831
00:29:10,000 --> 00:29:12,480
verify that the hmac signature that it

832
00:29:12,480 --> 00:29:14,720
expects is what actually came through in

833
00:29:14,720 --> 00:29:17,520
the header sfh mac

834
00:29:17,520 --> 00:29:19,279
one of the best

835
00:29:19,279 --> 00:29:21,279
features of this type of technique is

836
00:29:21,279 --> 00:29:23,279
that the secret itself is not present in

837
00:29:23,279 --> 00:29:24,399
the channel

838
00:29:24,399 --> 00:29:26,480
so you can't observe or steal that

839
00:29:26,480 --> 00:29:28,960
secret as you might if you were able to

840
00:29:28,960 --> 00:29:32,159
see say the api key um within this

841
00:29:32,159 --> 00:29:35,919
channel um but the uh the cost here um

842
00:29:35,919 --> 00:29:37,279
actually there are several cost of one

843
00:29:37,279 --> 00:29:39,120
cost is that you've added another static

844
00:29:39,120 --> 00:29:41,520
secret similar to an api key into your

845
00:29:41,520 --> 00:29:42,799
application so you're going to have to

846
00:29:42,799 --> 00:29:45,360
think about how do you protect that

847
00:29:45,360 --> 00:29:48,559
as well as you are using tls which is

848
00:29:48,559 --> 00:29:50,799
doing some encryption and you're then

849
00:29:50,799 --> 00:29:53,520
adding an another additional application

850
00:29:53,520 --> 00:29:55,760
layer which might involve encryption as

851
00:29:55,760 --> 00:29:56,960
well so

852
00:29:56,960 --> 00:29:59,200
you're doing additional processing for

853
00:29:59,200 --> 00:30:02,880
each api call that's going through

854
00:30:04,000 --> 00:30:05,520
so since you've added yet another

855
00:30:05,520 --> 00:30:08,080
application secret into the application

856
00:30:08,080 --> 00:30:09,440
package

857
00:30:09,440 --> 00:30:11,840
you should ask yourself what can i do to

858
00:30:11,840 --> 00:30:14,000
protect or remove that secret from the

859
00:30:14,000 --> 00:30:15,520
application

860
00:30:15,520 --> 00:30:17,840
so one thing you can do is you can

861
00:30:17,840 --> 00:30:19,679
attempt to remove the secret from the

862
00:30:19,679 --> 00:30:22,240
app bundle itself from the code that's

863
00:30:22,240 --> 00:30:23,840
being downloaded

864
00:30:23,840 --> 00:30:25,520
the typical approach for doing this

865
00:30:25,520 --> 00:30:27,039
would be to

866
00:30:27,039 --> 00:30:30,000
download or add the secret not in the

867
00:30:30,000 --> 00:30:31,520
package itself when the package is

868
00:30:31,520 --> 00:30:33,440
downloaded but when the application is

869
00:30:33,440 --> 00:30:37,039
first used so you may make a an insecure

870
00:30:37,039 --> 00:30:38,000
call

871
00:30:38,000 --> 00:30:40,640
typically known as trust on first use

872
00:30:40,640 --> 00:30:42,799
or you may do something such as require

873
00:30:42,799 --> 00:30:44,080
the user

874
00:30:44,080 --> 00:30:44,880
to

875
00:30:44,880 --> 00:30:46,640
accept a test message to see a

876
00:30:46,640 --> 00:30:48,480
verification code and type that into the

877
00:30:48,480 --> 00:30:50,640
application itself and once you have

878
00:30:50,640 --> 00:30:52,640
that it's no longer in the bundle it is

879
00:30:52,640 --> 00:30:54,799
in the run time you're going to want to

880
00:30:54,799 --> 00:30:57,120
secure this between usages so you're

881
00:30:57,120 --> 00:30:59,600
going to use some sort of secure storage

882
00:30:59,600 --> 00:31:00,960
there are quite a number of different

883
00:31:00,960 --> 00:31:03,679
secure storage packages for react native

884
00:31:03,679 --> 00:31:05,279
so you can take a look at the react

885
00:31:05,279 --> 00:31:07,279
native key chain package

886
00:31:07,279 --> 00:31:09,200
to use it's quite good at encrypting and

887
00:31:09,200 --> 00:31:11,440
storing key value pairs

888
00:31:11,440 --> 00:31:14,720
so the secret is in the clear in the run

889
00:31:14,720 --> 00:31:16,640
time but it's no longer in the bundle

890
00:31:16,640 --> 00:31:19,760
and when it is at rest it hopefully is

891
00:31:19,760 --> 00:31:22,879
in an encrypted state

892
00:31:23,200 --> 00:31:24,640
so now the attacker is going to take a

893
00:31:24,640 --> 00:31:25,919
look at this and they're going to have

894
00:31:25,919 --> 00:31:28,240
to do a little bit of detective work to

895
00:31:28,240 --> 00:31:30,480
try and uncover what is becoming more of

896
00:31:30,480 --> 00:31:33,279
an ad hoc approach to security

897
00:31:33,279 --> 00:31:35,600
because now you've

898
00:31:35,600 --> 00:31:38,960
gotten rid of the pinning protection

899
00:31:38,960 --> 00:31:39,840
the

900
00:31:39,840 --> 00:31:41,600
attacker is free to use a man in the

901
00:31:41,600 --> 00:31:44,000
middle type attack to be able to inspect

902
00:31:44,000 --> 00:31:46,480
the api calls that are occurring when

903
00:31:46,480 --> 00:31:48,240
they do this they'll see that what's

904
00:31:48,240 --> 00:31:50,799
changed is there's now an hmac header

905
00:31:50,799 --> 00:31:52,880
they can pretty much guess from the fact

906
00:31:52,880 --> 00:31:55,760
that you're using the term hmac in your

907
00:31:55,760 --> 00:31:58,240
header that it's a

908
00:31:58,240 --> 00:32:00,159
a hashing

909
00:32:00,159 --> 00:32:01,760
authentication code algorithm they'll

910
00:32:01,760 --> 00:32:03,000
guest sha

911
00:32:03,000 --> 00:32:05,440
3256 for example

912
00:32:05,440 --> 00:32:07,440
so they're going to go ahead and

913
00:32:07,440 --> 00:32:08,960
root the phone

914
00:32:08,960 --> 00:32:11,600
and see what can they find

915
00:32:11,600 --> 00:32:14,960
and can they get a hold of this in the

916
00:32:14,960 --> 00:32:16,320
code itself

917
00:32:16,320 --> 00:32:17,919
if they can't find it in the secure

918
00:32:17,919 --> 00:32:19,279
store if they can't break into the

919
00:32:19,279 --> 00:32:21,200
secure store then they're going to

920
00:32:21,200 --> 00:32:23,039
perhaps try and

921
00:32:23,039 --> 00:32:24,960
launch a debugger into the runtime

922
00:32:24,960 --> 00:32:26,799
environment remember they do control the

923
00:32:26,799 --> 00:32:30,000
device and can they see

924
00:32:30,000 --> 00:32:32,000
run it up and pause the

925
00:32:32,000 --> 00:32:34,399
application right when the hmac secret

926
00:32:34,399 --> 00:32:36,320
has been extracted from secure storage

927
00:32:36,320 --> 00:32:39,039
where they can see it and um and perhaps

928
00:32:39,039 --> 00:32:40,640
potentially wander through and

929
00:32:40,640 --> 00:32:42,000
understand the algorithm that's being

930
00:32:42,000 --> 00:32:44,720
used as well

931
00:32:46,159 --> 00:32:47,279
so

932
00:32:47,279 --> 00:32:48,880
you can continue to improve your

933
00:32:48,880 --> 00:32:50,880
defenses there's going to be a bit of a

934
00:32:50,880 --> 00:32:52,240
back and forth

935
00:32:52,240 --> 00:32:53,840
we're becoming more ad hoc in our

936
00:32:53,840 --> 00:32:55,279
approaches which means it's going to

937
00:32:55,279 --> 00:32:57,600
cost more in development

938
00:32:57,600 --> 00:32:59,919
to put these kind of techniques in place

939
00:32:59,919 --> 00:33:01,760
there's more chance for error

940
00:33:01,760 --> 00:33:04,159
but it also being ad hoc does add some

941
00:33:04,159 --> 00:33:06,480
new challenges to the hacker as well

942
00:33:06,480 --> 00:33:07,840
you're going to want to do your best for

943
00:33:07,840 --> 00:33:09,760
instance to try and prevent

944
00:33:09,760 --> 00:33:11,600
applications being allowed to run into

945
00:33:11,600 --> 00:33:12,880
buggers

946
00:33:12,880 --> 00:33:14,480
you're going to continue to try and

947
00:33:14,480 --> 00:33:16,080
improve the route and jailbreaking

948
00:33:16,080 --> 00:33:17,519
detection

949
00:33:17,519 --> 00:33:19,440
hackers are continually looking for new

950
00:33:19,440 --> 00:33:21,840
ways to cloak any kind of routing and

951
00:33:21,840 --> 00:33:24,159
jailbreaking activities they use so

952
00:33:24,159 --> 00:33:25,519
you're also going to have to make sure

953
00:33:25,519 --> 00:33:27,440
that you have a very

954
00:33:27,440 --> 00:33:29,200
good way to

955
00:33:29,200 --> 00:33:31,200
periodically upgrade

956
00:33:31,200 --> 00:33:33,279
the applications for example if the gel

957
00:33:33,279 --> 00:33:35,039
monkey package

958
00:33:35,039 --> 00:33:36,640
improves over time you're going to want

959
00:33:36,640 --> 00:33:39,519
to be able to install a new and improved

960
00:33:39,519 --> 00:33:41,600
monkey package into your application as

961
00:33:41,600 --> 00:33:44,159
easily and as transparently to the user

962
00:33:44,159 --> 00:33:45,600
as possible

963
00:33:45,600 --> 00:33:48,640
you can continue to kind of dial up the

964
00:33:48,640 --> 00:33:50,559
obfuscation if you see that that's a

965
00:33:50,559 --> 00:33:52,399
weak point in your application as much

966
00:33:52,399 --> 00:33:54,480
as you can without costing you in in

967
00:33:54,480 --> 00:33:57,279
performance or energy usage

968
00:33:57,279 --> 00:33:58,320
you can

969
00:33:58,320 --> 00:34:00,960
add to the obfuscation

970
00:34:00,960 --> 00:34:03,039
not just obfuscating the code but start

971
00:34:03,039 --> 00:34:05,519
adding in the ability to detect whether

972
00:34:05,519 --> 00:34:07,360
this package has been tampered with it

973
00:34:07,360 --> 00:34:09,760
anyway you can sort of add checks of the

974
00:34:09,760 --> 00:34:11,918
code to make sure it's there you can add

975
00:34:11,918 --> 00:34:14,159
false paths you can add timing checks to

976
00:34:14,159 --> 00:34:15,599
make sure that

977
00:34:15,599 --> 00:34:17,440
certain sequences of activities haven't

978
00:34:17,440 --> 00:34:19,520
been changed in any way

979
00:34:19,520 --> 00:34:21,280
and you can continue to play these types

980
00:34:21,280 --> 00:34:24,000
of games trading the the security levels

981
00:34:24,000 --> 00:34:25,440
that you're trying to achieve for the

982
00:34:25,440 --> 00:34:27,599
performance limitations that you might

983
00:34:27,599 --> 00:34:30,079
encounter

984
00:34:30,960 --> 00:34:32,320
so another

985
00:34:32,320 --> 00:34:34,320
approach that is a little bit more

986
00:34:34,320 --> 00:34:37,679
structured is to see can we take the

987
00:34:37,679 --> 00:34:39,599
secrets and more importantly the

988
00:34:39,599 --> 00:34:41,520
security decisions that were made on the

989
00:34:41,520 --> 00:34:44,000
device that might be hooked and changed

990
00:34:44,000 --> 00:34:45,280
can we move

991
00:34:45,280 --> 00:34:47,359
those off the device

992
00:34:47,359 --> 00:34:49,199
so do a little bit of indirection here

993
00:34:49,199 --> 00:34:51,199
the more we can get off the device the

994
00:34:51,199 --> 00:34:52,960
more secrets there are off the device

995
00:34:52,960 --> 00:34:55,359
there are less there is to steal

996
00:34:55,359 --> 00:34:57,119
the more that we can make security

997
00:34:57,119 --> 00:34:59,040
decisions off the device they're less

998
00:34:59,040 --> 00:35:01,599
that you have the ability to hook in and

999
00:35:01,599 --> 00:35:04,400
overturn those security decisions

1000
00:35:04,400 --> 00:35:06,480
so let's just pause it here that there's

1001
00:35:06,480 --> 00:35:08,320
some sort of secrets or application

1002
00:35:08,320 --> 00:35:10,640
authentication service and when an app

1003
00:35:10,640 --> 00:35:13,440
is ready to make an api call

1004
00:35:13,440 --> 00:35:16,560
rather than just go ahead and

1005
00:35:16,560 --> 00:35:18,480
with their best protection make the api

1006
00:35:18,480 --> 00:35:20,000
call throw in the secrets do the

1007
00:35:20,000 --> 00:35:21,839
calculations locally

1008
00:35:21,839 --> 00:35:24,720
what it will do is call up to this

1009
00:35:24,720 --> 00:35:26,880
authentication and secret service and

1010
00:35:26,880 --> 00:35:29,280
request to be attested can you make the

1011
00:35:29,280 --> 00:35:32,400
decision for me am i clean am i running

1012
00:35:32,400 --> 00:35:34,000
in a safe environment has the code been

1013
00:35:34,000 --> 00:35:35,839
tampered with in any way

1014
00:35:35,839 --> 00:35:38,240
and so you can have a protocol set up

1015
00:35:38,240 --> 00:35:40,240
between them where the

1016
00:35:40,240 --> 00:35:42,320
backend authorization service is going

1017
00:35:42,320 --> 00:35:43,599
to go ahead

1018
00:35:43,599 --> 00:35:46,240
and take some measurements on the device

1019
00:35:46,240 --> 00:35:48,560
analyze those measurements and

1020
00:35:48,560 --> 00:35:50,960
analogous to user authorization is going

1021
00:35:50,960 --> 00:35:52,000
to

1022
00:35:52,000 --> 00:35:53,599
issue some sort of

1023
00:35:53,599 --> 00:35:55,680
short-lived token that's going to be

1024
00:35:55,680 --> 00:35:57,040
able to

1025
00:35:57,040 --> 00:35:59,760
either be signed by a secret known by

1026
00:35:59,760 --> 00:36:01,520
your back-end service

1027
00:36:01,520 --> 00:36:03,280
if it believes that the application is

1028
00:36:03,280 --> 00:36:05,839
valid and healthy or it will just simply

1029
00:36:05,839 --> 00:36:07,839
have a bad signature sending through so

1030
00:36:07,839 --> 00:36:09,359
that token is

1031
00:36:09,359 --> 00:36:10,720
invalid

1032
00:36:10,720 --> 00:36:12,400
in that case the application will get a

1033
00:36:12,400 --> 00:36:14,880
token and interestingly it won't know

1034
00:36:14,880 --> 00:36:16,880
whether the decision has been made good

1035
00:36:16,880 --> 00:36:19,359
or bad i will simply take that token

1036
00:36:19,359 --> 00:36:21,520
just as it would for user asset access

1037
00:36:21,520 --> 00:36:24,640
token ship that with the api call to the

1038
00:36:24,640 --> 00:36:26,880
backend service the backend service will

1039
00:36:26,880 --> 00:36:29,440
then examine the signature of this

1040
00:36:29,440 --> 00:36:31,359
of this token just like it's checking

1041
00:36:31,359 --> 00:36:33,839
the user access token and hopefully it's

1042
00:36:33,839 --> 00:36:35,920
identifying both the who and the what

1043
00:36:35,920 --> 00:36:39,040
appear to be valid in these api calls

1044
00:36:39,040 --> 00:36:40,800
as i said these tokens themselves can be

1045
00:36:40,800 --> 00:36:42,800
very short-lived unlike user

1046
00:36:42,800 --> 00:36:44,800
authentication there's no human in the

1047
00:36:44,800 --> 00:36:46,000
loop so you can do this fairly

1048
00:36:46,000 --> 00:36:47,920
frequently so you could potentially do

1049
00:36:47,920 --> 00:36:50,320
it every api call or you could do it on

1050
00:36:50,320 --> 00:36:53,520
the order of minutes if you wanted to

1051
00:36:53,520 --> 00:36:56,400
to just continue to to check and make

1052
00:36:56,400 --> 00:36:58,320
sure that this application hasn't been

1053
00:36:58,320 --> 00:37:00,480
tampered with in any way or that the

1054
00:37:00,480 --> 00:37:02,240
device hasn't been rooted since the last

1055
00:37:02,240 --> 00:37:05,118
time we made a check

1056
00:37:05,920 --> 00:37:07,680
so this is what a sort of proof of

1057
00:37:07,680 --> 00:37:10,079
concept and implementation of this it

1058
00:37:10,079 --> 00:37:12,160
looks like there's nothing that i know

1059
00:37:12,160 --> 00:37:14,640
of currently in the

1060
00:37:14,640 --> 00:37:17,040
npm package environment

1061
00:37:17,040 --> 00:37:18,400
but you can

1062
00:37:18,400 --> 00:37:21,839
imagine that you have a an application

1063
00:37:21,839 --> 00:37:24,400
with an attestation api that's embedded

1064
00:37:24,400 --> 00:37:26,079
into an sdk

1065
00:37:26,079 --> 00:37:28,960
you're going to want to harden that sdk

1066
00:37:28,960 --> 00:37:30,560
by using the techniques we've talked

1067
00:37:30,560 --> 00:37:32,720
about such as obfuscation

1068
00:37:32,720 --> 00:37:34,400
and you're going to go ahead and crank

1069
00:37:34,400 --> 00:37:36,640
those up pretty high you're not cranking

1070
00:37:36,640 --> 00:37:38,480
everything across the entire app but

1071
00:37:38,480 --> 00:37:40,160
you're really focusing on building a

1072
00:37:40,160 --> 00:37:42,160
very secure

1073
00:37:42,160 --> 00:37:45,680
set of function calls as well as the

1074
00:37:45,680 --> 00:37:47,920
the channel used to communicate with the

1075
00:37:47,920 --> 00:37:50,480
back-end data station service

1076
00:37:50,480 --> 00:37:52,480
so the the application before it makes

1077
00:37:52,480 --> 00:37:55,119
an api call is going to request that it

1078
00:37:55,119 --> 00:37:56,640
be untested it's going to ask

1079
00:37:56,640 --> 00:37:59,200
essentially for an authorization token

1080
00:37:59,200 --> 00:38:00,800
that'll go over to the attestation

1081
00:38:00,800 --> 00:38:02,720
service the attestation service is

1082
00:38:02,720 --> 00:38:04,480
likely going to reply with some sort of

1083
00:38:04,480 --> 00:38:07,200
challenge including a nonce just to salt

1084
00:38:07,200 --> 00:38:08,800
the measurements that are being taken

1085
00:38:08,800 --> 00:38:10,960
and and to try and prevent replay

1086
00:38:10,960 --> 00:38:12,320
attacks

1087
00:38:12,320 --> 00:38:14,560
and in this simple proof of concept the

1088
00:38:14,560 --> 00:38:16,960
application is going to respond by

1089
00:38:16,960 --> 00:38:19,599
creating a hash of the signature of the

1090
00:38:19,599 --> 00:38:21,440
package so in this case we're really

1091
00:38:21,440 --> 00:38:22,560
looking at

1092
00:38:22,560 --> 00:38:25,040
has the code changed in any way

1093
00:38:25,040 --> 00:38:27,359
so it would be the signature plus hashed

1094
00:38:27,359 --> 00:38:29,280
with the nonce itself

1095
00:38:29,280 --> 00:38:31,520
and that measurement would be passed

1096
00:38:31,520 --> 00:38:34,079
back to the attestation service

1097
00:38:34,079 --> 00:38:35,920
if you wanted to include improve the

1098
00:38:35,920 --> 00:38:37,440
security here you would start also

1099
00:38:37,440 --> 00:38:39,920
adding additional sort of runtime safety

1100
00:38:39,920 --> 00:38:41,200
checks so you would be making

1101
00:38:41,200 --> 00:38:43,200
measurements about whether the device is

1102
00:38:43,200 --> 00:38:44,400
rooted or not

1103
00:38:44,400 --> 00:38:47,040
examining memory maps potentially trying

1104
00:38:47,040 --> 00:38:48,880
different function calls to see has the

1105
00:38:48,880 --> 00:38:50,160
environment

1106
00:38:50,160 --> 00:38:52,320
been tampered with in any way

1107
00:38:52,320 --> 00:38:53,839
but as i said in this case we're just

1108
00:38:53,839 --> 00:38:56,480
looking at the package signature we'll

1109
00:38:56,480 --> 00:38:58,960
pass that hash with the nonce back to

1110
00:38:58,960 --> 00:39:01,200
the attestation service the attestation

1111
00:39:01,200 --> 00:39:03,520
service will evaluate those responses

1112
00:39:03,520 --> 00:39:05,280
based on what it expects from an

1113
00:39:05,280 --> 00:39:07,599
untempered application

1114
00:39:07,599 --> 00:39:09,760
and if it's healthy it will send back a

1115
00:39:09,760 --> 00:39:12,560
signed properly signed token if it's

1116
00:39:12,560 --> 00:39:15,520
unhealthy it will send back a

1117
00:39:15,520 --> 00:39:19,599
un properly improperly signed jwt token

1118
00:39:19,599 --> 00:39:20,960
it's important to notice here that

1119
00:39:20,960 --> 00:39:22,320
monkey patching

1120
00:39:22,320 --> 00:39:24,079
is not going to be effective here

1121
00:39:24,079 --> 00:39:26,079
because you need a valid token from this

1122
00:39:26,079 --> 00:39:28,079
service in order to successfully

1123
00:39:28,079 --> 00:39:29,920
complete the api call

1124
00:39:29,920 --> 00:39:32,000
so you do need to run through this

1125
00:39:32,000 --> 00:39:34,000
attestation service to get a

1126
00:39:34,000 --> 00:39:36,160
successfully signed token

1127
00:39:36,160 --> 00:39:37,920
and if you try and patch the function

1128
00:39:37,920 --> 00:39:39,520
calls themselves

1129
00:39:39,520 --> 00:39:41,520
that would change the package signature

1130
00:39:41,520 --> 00:39:43,520
so when you do the measurement

1131
00:39:43,520 --> 00:39:46,320
then you would not get the expected

1132
00:39:46,320 --> 00:39:47,839
result and you would end up with a

1133
00:39:47,839 --> 00:39:49,200
faulty token

1134
00:39:49,200 --> 00:39:50,720
which would not enable you to complete

1135
00:39:50,720 --> 00:39:53,359
the api call when you add that to the

1136
00:39:53,359 --> 00:39:57,040
api call going to the back end

1137
00:39:57,040 --> 00:39:58,640
so at this point if you've truly

1138
00:39:58,640 --> 00:40:01,040
hardened that's that sdk just focused on

1139
00:40:01,040 --> 00:40:04,160
that that very specific set of functions

1140
00:40:04,160 --> 00:40:06,160
in that specific channel

1141
00:40:06,160 --> 00:40:08,079
then it might be

1142
00:40:08,079 --> 00:40:09,599
appropriate to reintroduce the pinning

1143
00:40:09,599 --> 00:40:11,119
service at this point

1144
00:40:11,119 --> 00:40:13,359
so once you have the secure channel you

1145
00:40:13,359 --> 00:40:15,760
can exploit it and pinning is a good way

1146
00:40:15,760 --> 00:40:17,920
to do that so you can imagine sort of

1147
00:40:17,920 --> 00:40:20,640
setting up a private pinning service

1148
00:40:20,640 --> 00:40:24,400
that allows you to actually ship these

1149
00:40:24,400 --> 00:40:26,720
seek these certificates

1150
00:40:26,720 --> 00:40:28,960
rather than using a sort of

1151
00:40:28,960 --> 00:40:30,800
unprotected tofu

1152
00:40:30,800 --> 00:40:32,560
type approach or requiring the user to

1153
00:40:32,560 --> 00:40:35,119
key in a verification code

1154
00:40:35,119 --> 00:40:37,119
you could simply attest that the app

1155
00:40:37,119 --> 00:40:39,359
looks like it's clean untempered and in

1156
00:40:39,359 --> 00:40:41,680
a healthy environment at that point you

1157
00:40:41,680 --> 00:40:43,760
could send

1158
00:40:43,760 --> 00:40:45,520
pinning certificates down to the

1159
00:40:45,520 --> 00:40:46,720
application

1160
00:40:46,720 --> 00:40:48,000
if you wanted to rotate those

1161
00:40:48,000 --> 00:40:49,599
certificates or if you wanted to update

1162
00:40:49,599 --> 00:40:51,920
them over time you could use the same

1163
00:40:51,920 --> 00:40:53,839
channel and protocol

1164
00:40:53,839 --> 00:40:55,520
to keep all those certificates up to

1165
00:40:55,520 --> 00:40:56,319
date

1166
00:40:56,319 --> 00:40:58,160
so you're free to change those as well

1167
00:40:58,160 --> 00:40:59,839
as to change the secret that you're

1168
00:40:59,839 --> 00:41:01,599
using for signing this

1169
00:41:01,599 --> 00:41:03,280
and none of that since there's no

1170
00:41:03,280 --> 00:41:05,599
secrets relying on the in the

1171
00:41:05,599 --> 00:41:08,319
application itself none of those

1172
00:41:08,319 --> 00:41:11,119
can be extracted by doing whatever you

1173
00:41:11,119 --> 00:41:12,079
can do

1174
00:41:12,079 --> 00:41:14,160
to attack the application

1175
00:41:14,160 --> 00:41:16,480
so this kind of app authorization

1176
00:41:16,480 --> 00:41:18,160
service and private pinning package

1177
00:41:18,160 --> 00:41:19,920
could well be integrated into something

1178
00:41:19,920 --> 00:41:21,839
such as that react native sort of

1179
00:41:21,839 --> 00:41:24,000
certificate pinner package that we

1180
00:41:24,000 --> 00:41:26,480
discussed earlier

1181
00:41:26,480 --> 00:41:29,040
so just to summarize here

1182
00:41:29,040 --> 00:41:31,520
we set out with a number of defense

1183
00:41:31,520 --> 00:41:33,599
objectives the first one was prevent api

1184
00:41:33,599 --> 00:41:35,599
reverse engineering

1185
00:41:35,599 --> 00:41:38,400
one of the best ways to to do that on

1186
00:41:38,400 --> 00:41:40,640
the device itself is to obfuscate the

1187
00:41:40,640 --> 00:41:42,240
code so the code can't be easily

1188
00:41:42,240 --> 00:41:44,480
disassembled and understood we used

1189
00:41:44,480 --> 00:41:46,160
pinning techniques

1190
00:41:46,160 --> 00:41:48,400
and then eventually the

1191
00:41:48,400 --> 00:41:51,119
sort of application level uh prevention

1192
00:41:51,119 --> 00:41:52,720
techniques to try and secure that

1193
00:41:52,720 --> 00:41:53,760
channel

1194
00:41:53,760 --> 00:41:56,319
went back to pinning once we had uh the

1195
00:41:56,319 --> 00:41:58,800
secure hatter station channel um in the

1196
00:41:58,800 --> 00:42:00,319
second step here we wanted to make sure

1197
00:42:00,319 --> 00:42:01,760
that it was hard to construct a valid

1198
00:42:01,760 --> 00:42:03,200
api call

1199
00:42:03,200 --> 00:42:05,440
and the remote at a station where we

1200
00:42:05,440 --> 00:42:07,520
were able to take as much of the

1201
00:42:07,520 --> 00:42:09,680
security responsibility off the device

1202
00:42:09,680 --> 00:42:11,599
as possible was probably the best

1203
00:42:11,599 --> 00:42:14,720
technique to use here we've added now a

1204
00:42:14,720 --> 00:42:16,400
new token

1205
00:42:16,400 --> 00:42:18,400
there's no longer a secret on the device

1206
00:42:18,400 --> 00:42:19,839
itself

1207
00:42:19,839 --> 00:42:22,480
and so that's helped pinning again to

1208
00:42:22,480 --> 00:42:24,560
make it hard to see and to potentially

1209
00:42:24,560 --> 00:42:26,160
manipulate what's going through that

1210
00:42:26,160 --> 00:42:28,839
channel is obviously important runtime

1211
00:42:28,839 --> 00:42:32,319
defenses um you really need to

1212
00:42:32,319 --> 00:42:35,440
work on trying to prevent rooting or

1213
00:42:35,440 --> 00:42:37,440
or jailbreaking and this is a game

1214
00:42:37,440 --> 00:42:38,800
you're going to have to be playing over

1215
00:42:38,800 --> 00:42:41,359
time or delegating to someone such as

1216
00:42:41,359 --> 00:42:42,880
gel monkey who hopefully will be

1217
00:42:42,880 --> 00:42:45,599
updating those defenses over time

1218
00:42:45,599 --> 00:42:47,440
bottom line though you just need to make

1219
00:42:47,440 --> 00:42:49,280
it hard enough that it's not worth the

1220
00:42:49,280 --> 00:42:52,319
hacker to spend their time on your api

1221
00:42:52,319 --> 00:42:54,240
calls they're too well protected versus

1222
00:42:54,240 --> 00:42:55,760
what they see

1223
00:42:55,760 --> 00:42:57,599
across other valuable targets they might

1224
00:42:57,599 --> 00:42:59,040
choose to go after

1225
00:42:59,040 --> 00:43:01,040
so you will have to evolve your security

1226
00:43:01,040 --> 00:43:03,040
approaches over time because the

1227
00:43:03,040 --> 00:43:04,800
industry as a whole will be

1228
00:43:04,800 --> 00:43:06,480
improving over time and you need to stay

1229
00:43:06,480 --> 00:43:08,000
slightly ahead

1230
00:43:08,000 --> 00:43:10,480
to make your target the least attractive

1231
00:43:10,480 --> 00:43:12,960
that you can

1232
00:43:12,960 --> 00:43:15,680
so if we've been successful here then

1233
00:43:15,680 --> 00:43:17,839
you're you will not be caught by a bear

1234
00:43:17,839 --> 00:43:19,599
in this case because you have evolved

1235
00:43:19,599 --> 00:43:21,680
your your security and stayed ahead of

1236
00:43:21,680 --> 00:43:23,599
the game

1237
00:43:23,599 --> 00:43:25,359
so going back to our objectives i hope i

1238
00:43:25,359 --> 00:43:27,119
did give you a bit of an appreciation

1239
00:43:27,119 --> 00:43:29,760
for how react native apps are open to

1240
00:43:29,760 --> 00:43:32,400
api abuse and by following that sort of

1241
00:43:32,400 --> 00:43:33,920
back and forth chain of exploits it'll

1242
00:43:33,920 --> 00:43:36,480
give you an idea of what these kind of

1243
00:43:36,480 --> 00:43:38,880
attacks that you saw different from just

1244
00:43:38,880 --> 00:43:40,480
kind of credential stuffing trying to

1245
00:43:40,480 --> 00:43:41,520
steal

1246
00:43:41,520 --> 00:43:45,040
and reuse credentials but more

1247
00:43:45,040 --> 00:43:47,040
how your attackers are going to try and

1248
00:43:47,040 --> 00:43:49,359
get at understanding the api and

1249
00:43:49,359 --> 00:43:51,280
manipulating and abusing that api

1250
00:43:51,280 --> 00:43:52,560
through

1251
00:43:52,560 --> 00:43:55,440
as i promised we will provide to you

1252
00:43:55,440 --> 00:43:57,520
these scenarios worked out in codes you

1253
00:43:57,520 --> 00:43:59,760
can build and analyze these as well as

1254
00:43:59,760 --> 00:44:01,920
well as hopefully a few more stories and

1255
00:44:01,920 --> 00:44:03,440
we'll be adding to these stories over

1256
00:44:03,440 --> 00:44:06,240
time so to access that source code and

1257
00:44:06,240 --> 00:44:08,240
all the stories and just head over to

1258
00:44:08,240 --> 00:44:09,760
approved

1259
00:44:09,760 --> 00:44:11,119
battle

1260
00:44:11,119 --> 00:44:14,160
and i do uh want to thank you today for

1261
00:44:14,160 --> 00:44:16,240
bearing with me through to the end i do

1262
00:44:16,240 --> 00:44:18,400
love questions so please if there's

1263
00:44:18,400 --> 00:44:20,079
anything you didn't understand or wanted

1264
00:44:20,079 --> 00:44:22,160
to clarify or any new suggestions or

1265
00:44:22,160 --> 00:44:24,079
stories you might have to improve the

1266
00:44:24,079 --> 00:44:25,839
presentation or

1267
00:44:25,839 --> 00:44:26,800
the

1268
00:44:26,800 --> 00:44:28,960
ship fast ship raider battle itself

1269
00:44:28,960 --> 00:44:30,640
please do reach out to me

1270
00:44:30,640 --> 00:44:32,480
and i'd be glad to help in whatever way

1271
00:44:32,480 --> 00:44:34,800
i can and please stay safe thank you

1272
00:44:34,800 --> 00:44:37,680
very much

