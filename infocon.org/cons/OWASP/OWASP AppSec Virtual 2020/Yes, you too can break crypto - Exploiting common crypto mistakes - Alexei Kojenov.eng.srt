1
00:00:00,480 --> 00:00:02,639
hello everyone and welcome to today's

2
00:00:02,639 --> 00:00:04,319
talk on the exciting topic of

3
00:00:04,319 --> 00:00:06,160
cryptography

4
00:00:06,160 --> 00:00:09,440
i wanted to start with this and if

5
00:00:09,440 --> 00:00:10,960
you don't remember

6
00:00:10,960 --> 00:00:13,040
this thing it happened seems like a

7
00:00:13,040 --> 00:00:15,200
lifetime ago it happened before the

8
00:00:15,200 --> 00:00:17,920
pandemic back in i think january this

9
00:00:17,920 --> 00:00:19,039
year

10
00:00:19,039 --> 00:00:21,199
which was um

11
00:00:21,199 --> 00:00:23,199
well not too long ago but at the same

12
00:00:23,199 --> 00:00:25,119
time it feels like

13
00:00:25,119 --> 00:00:27,599
uh it's been forever anyway somebody

14
00:00:27,599 --> 00:00:30,800
found an issue in cryptographic

15
00:00:30,800 --> 00:00:32,320
implementation

16
00:00:32,320 --> 00:00:35,200
in microsoft windows and it was a pretty

17
00:00:35,200 --> 00:00:37,440
big one

18
00:00:37,440 --> 00:00:38,719
the

19
00:00:38,719 --> 00:00:40,800
the problem was with

20
00:00:40,800 --> 00:00:42,480
validating

21
00:00:42,480 --> 00:00:45,920
signatures uh validating certain things

22
00:00:45,920 --> 00:00:46,800
that

23
00:00:46,800 --> 00:00:48,160
would allow

24
00:00:48,160 --> 00:00:50,800
potentially allow an attacker to do all

25
00:00:50,800 --> 00:00:52,879
kinds of bad things

26
00:00:52,879 --> 00:00:54,000
for example

27
00:00:54,000 --> 00:00:57,360
intercept and modify https connections

28
00:00:57,360 --> 00:01:00,719
send some files to the user that they

29
00:01:00,719 --> 00:01:03,199
would install thinking that the files

30
00:01:03,199 --> 00:01:05,600
were updates from microsoft in fact they

31
00:01:05,600 --> 00:01:07,040
were not

32
00:01:07,040 --> 00:01:08,560
and so on

33
00:01:08,560 --> 00:01:09,600
why

34
00:01:09,600 --> 00:01:12,960
did i want to talk about this so

35
00:01:12,960 --> 00:01:13,760
if

36
00:01:13,760 --> 00:01:15,360
if you read

37
00:01:15,360 --> 00:01:18,720
about about this vulnerability

38
00:01:18,720 --> 00:01:20,799
you probably noticed that the problem

39
00:01:20,799 --> 00:01:23,119
was not actually in

40
00:01:23,119 --> 00:01:25,920
like the fundamentals of cryptography it

41
00:01:25,920 --> 00:01:27,759
was not a problem with a certain

42
00:01:27,759 --> 00:01:30,159
algorithm it was not a problem with

43
00:01:30,159 --> 00:01:32,880
some cryptographic scheme

44
00:01:32,880 --> 00:01:34,799
it was not a problem with

45
00:01:34,799 --> 00:01:38,079
a protocol or whatever it was just

46
00:01:38,079 --> 00:01:41,040
one or two simple mistakes in a

47
00:01:41,040 --> 00:01:43,759
particular implementation

48
00:01:43,759 --> 00:01:45,520
right

49
00:01:45,520 --> 00:01:46,640
so

50
00:01:46,640 --> 00:01:49,520
why this talk today uh we all agree that

51
00:01:49,520 --> 00:01:52,560
that cryptography is hard and it is hard

52
00:01:52,560 --> 00:01:55,280
on multiple levels from like

53
00:01:55,280 --> 00:01:58,159
understanding what's going on to like

54
00:01:58,159 --> 00:02:01,119
implementation itself and then

55
00:02:01,119 --> 00:02:04,240
there are so many ways to make a mistake

56
00:02:04,240 --> 00:02:06,159
and mistakes are bad right

57
00:02:06,159 --> 00:02:08,560
we all agree on that and today we're

58
00:02:08,560 --> 00:02:10,080
going to talk about how to exploit some

59
00:02:10,080 --> 00:02:12,879
of these mistakes in crypto

60
00:02:12,879 --> 00:02:15,920
we're not going to talk about zero days

61
00:02:15,920 --> 00:02:17,200
um

62
00:02:17,200 --> 00:02:19,680
there's no information about that in

63
00:02:19,680 --> 00:02:21,200
this presentation

64
00:02:21,200 --> 00:02:24,000
there will be no complex math at all

65
00:02:24,000 --> 00:02:25,920
there will be just a few basic really

66
00:02:25,920 --> 00:02:27,280
basic things

67
00:02:27,280 --> 00:02:29,200
we're not going to talk about

68
00:02:29,200 --> 00:02:32,080
the dark future of cryptography

69
00:02:32,080 --> 00:02:33,599
which

70
00:02:33,599 --> 00:02:35,120
is probably quantum stuff that's going

71
00:02:35,120 --> 00:02:36,800
to break everything

72
00:02:36,800 --> 00:02:38,480
and we're not going to talk about how to

73
00:02:38,480 --> 00:02:40,160
break correctly implemented crypto

74
00:02:40,160 --> 00:02:42,640
because by definition

75
00:02:42,640 --> 00:02:44,800
it is unbreakable today might be

76
00:02:44,800 --> 00:02:46,400
breakable tomorrow but today if

77
00:02:46,400 --> 00:02:48,000
everything is implemented correctly it

78
00:02:48,000 --> 00:02:50,160
is unbreakable

79
00:02:50,160 --> 00:02:52,800
so my name is alexey and i'm a software

80
00:02:52,800 --> 00:02:54,879
developer in the past i spent over a

81
00:02:54,879 --> 00:02:57,280
decade writing code primarily for one

82
00:02:57,280 --> 00:03:00,080
big company and then i kind of switched

83
00:03:00,080 --> 00:03:02,319
gears and started doing more security

84
00:03:02,319 --> 00:03:05,280
stuff in application security world

85
00:03:05,280 --> 00:03:06,720
starting the same company and then

86
00:03:06,720 --> 00:03:08,800
moving into some security consulting and

87
00:03:08,800 --> 00:03:10,959
i currently work for salesforce

88
00:03:10,959 --> 00:03:12,319
i have

89
00:03:12,319 --> 00:03:15,120
several certifications in

90
00:03:15,120 --> 00:03:17,760
security that are listed here but the

91
00:03:17,760 --> 00:03:19,920
most important thing on this slide is

92
00:03:19,920 --> 00:03:21,519
this

93
00:03:21,519 --> 00:03:23,360
i am not a cryptographer

94
00:03:23,360 --> 00:03:24,720
so i

95
00:03:24,720 --> 00:03:26,720
i don't consider myself a cryptographer

96
00:03:26,720 --> 00:03:29,360
i probably don't know much about it i

97
00:03:29,360 --> 00:03:32,560
just come to this topic strictly from

98
00:03:32,560 --> 00:03:34,400
practical perspective

99
00:03:34,400 --> 00:03:37,840
as a hacker and

100
00:03:38,239 --> 00:03:40,480
you you would realize

101
00:03:40,480 --> 00:03:42,159
going through this presentation there is

102
00:03:42,159 --> 00:03:43,760
nothing really

103
00:03:43,760 --> 00:03:45,040
deep and

104
00:03:45,040 --> 00:03:46,560
complicated here

105
00:03:46,560 --> 00:03:48,720
but there are some practical things that

106
00:03:48,720 --> 00:03:51,200
we all can do in order to exploit some

107
00:03:51,200 --> 00:03:53,760
mistakes

108
00:03:53,840 --> 00:03:57,599
so general recommendations up front

109
00:03:57,840 --> 00:03:58,799
when

110
00:03:58,799 --> 00:04:01,840
doing crypto we need to use well-known

111
00:04:01,840 --> 00:04:03,599
and secure algorithms

112
00:04:03,599 --> 00:04:05,360
right we all know that we are not

113
00:04:05,360 --> 00:04:08,000
supposed to use des because ds is no

114
00:04:08,000 --> 00:04:10,080
longer secure

115
00:04:10,080 --> 00:04:11,920
okay

116
00:04:11,920 --> 00:04:13,599
the second thing is

117
00:04:13,599 --> 00:04:15,280
we should use standard and stable

118
00:04:15,280 --> 00:04:17,600
libraries meaning

119
00:04:17,600 --> 00:04:21,040
good implementations of those algorithms

120
00:04:21,040 --> 00:04:22,639
right we don't

121
00:04:22,639 --> 00:04:25,919
use some obscure library some code that

122
00:04:25,919 --> 00:04:28,720
you downloaded from who knows where

123
00:04:28,720 --> 00:04:30,560
and just run it

124
00:04:30,560 --> 00:04:32,960
you pick up a library that's well known

125
00:04:32,960 --> 00:04:34,720
that's well maintained

126
00:04:34,720 --> 00:04:39,759
and does not have known security bugs

127
00:04:40,160 --> 00:04:41,600
the third thing

128
00:04:41,600 --> 00:04:43,199
is very important we need to follow the

129
00:04:43,199 --> 00:04:45,199
best practices

130
00:04:45,199 --> 00:04:46,479
and that's

131
00:04:46,479 --> 00:04:48,080
basically

132
00:04:48,080 --> 00:04:48,960
a

133
00:04:48,960 --> 00:04:51,600
a very broad and deep topic

134
00:04:51,600 --> 00:04:53,520
and it really depends on

135
00:04:53,520 --> 00:04:55,600
what cryptographic scheme you use what

136
00:04:55,600 --> 00:04:57,280
algorithm you use what you're trying to

137
00:04:57,280 --> 00:04:58,160
do

138
00:04:58,160 --> 00:05:00,320
there are certain things that we we all

139
00:05:00,320 --> 00:05:03,759
need to understand and follow

140
00:05:03,919 --> 00:05:06,240
and the last but not least do not invent

141
00:05:06,240 --> 00:05:07,840
your own crypto and you have heard this

142
00:05:07,840 --> 00:05:08,800
advice

143
00:05:08,800 --> 00:05:11,520
hundreds of times but just wanted to

144
00:05:11,520 --> 00:05:13,199
throw this in

145
00:05:13,199 --> 00:05:15,759
here again

146
00:05:15,759 --> 00:05:18,720
in terms of common mistakes

147
00:05:18,720 --> 00:05:20,320
the first one is

148
00:05:20,320 --> 00:05:22,400
insufficient entropy meaning there is

149
00:05:22,400 --> 00:05:25,280
not enough randomness and randomness in

150
00:05:25,280 --> 00:05:27,680
crypto is very important

151
00:05:27,680 --> 00:05:29,039
many times

152
00:05:29,039 --> 00:05:31,919
when we deal with

153
00:05:31,919 --> 00:05:33,440
cryptography

154
00:05:33,440 --> 00:05:35,840
we we need a good random number

155
00:05:35,840 --> 00:05:38,720
generator and when we look at some data

156
00:05:38,720 --> 00:05:39,759
they might

157
00:05:39,759 --> 00:05:42,320
the data might look like

158
00:05:42,320 --> 00:05:45,280
a random noise and that's great that's

159
00:05:45,280 --> 00:05:46,240
awesome

160
00:05:46,240 --> 00:05:47,440
anything

161
00:05:47,440 --> 00:05:49,600
in those cases that doesn't look random

162
00:05:49,600 --> 00:05:50,720
enough

163
00:05:50,720 --> 00:05:53,840
is probably an indicator that

164
00:05:53,840 --> 00:05:56,560
things are not done right

165
00:05:56,560 --> 00:05:59,759
the second one is algorithm choice

166
00:05:59,759 --> 00:06:02,000
meaning we use a wrong algorithm we use

167
00:06:02,000 --> 00:06:04,319
a chainsaw where we need a hammer or

168
00:06:04,319 --> 00:06:06,960
vice versa so that's very important to

169
00:06:06,960 --> 00:06:09,840
know and understand

170
00:06:09,840 --> 00:06:12,000
and the third one that's that relates to

171
00:06:12,000 --> 00:06:14,560
those best practices so when we pick up

172
00:06:14,560 --> 00:06:15,919
an algorithm and that's the right

173
00:06:15,919 --> 00:06:18,479
algorithm for the right purpose

174
00:06:18,479 --> 00:06:21,520
we need to understand what exactly we

175
00:06:21,520 --> 00:06:23,759
need to do here like

176
00:06:23,759 --> 00:06:26,960
if there's an iv wha what what's that iv

177
00:06:26,960 --> 00:06:29,199
where do we get it and so on where do we

178
00:06:29,199 --> 00:06:31,759
get the key how we store the key

179
00:06:31,759 --> 00:06:35,840
what mode we use and so on so on

180
00:06:36,080 --> 00:06:37,680
number four

181
00:06:37,680 --> 00:06:39,840
it's often overlooked but we tend to

182
00:06:39,840 --> 00:06:42,479
focus on confidentiality right we all

183
00:06:42,479 --> 00:06:44,400
want to protect the data we don't want

184
00:06:44,400 --> 00:06:46,560
anybody to read but we often forget

185
00:06:46,560 --> 00:06:49,680
about integrity so is the message

186
00:06:49,680 --> 00:06:51,039
trustworthy

187
00:06:51,039 --> 00:06:54,000
okay we encrypted it but can somebody

188
00:06:54,000 --> 00:06:56,240
actually modify it in the way that we

189
00:06:56,240 --> 00:06:57,919
don't want

190
00:06:57,919 --> 00:07:01,759
so integrity is really really important

191
00:07:01,759 --> 00:07:04,080
the last but not least is key management

192
00:07:04,080 --> 00:07:06,080
you can do everything right

193
00:07:06,080 --> 00:07:06,960
but

194
00:07:06,960 --> 00:07:09,120
if you don't manage the keys correctly

195
00:07:09,120 --> 00:07:11,520
your keys get leaked your keys get

196
00:07:11,520 --> 00:07:13,520
cracked or

197
00:07:13,520 --> 00:07:14,560
some

198
00:07:14,560 --> 00:07:16,800
or obtained in some other way and your

199
00:07:16,800 --> 00:07:19,599
whole scheme is broken

200
00:07:19,599 --> 00:07:22,479
okay this is the math for today

201
00:07:22,479 --> 00:07:25,599
exclusive or or xor this is the only

202
00:07:25,599 --> 00:07:27,520
operation

203
00:07:27,520 --> 00:07:29,039
a mathematical

204
00:07:29,039 --> 00:07:31,199
operation that i'm going to talk today

205
00:07:31,199 --> 00:07:33,520
i call it the ultimate crypto weapon and

206
00:07:33,520 --> 00:07:35,280
you'll see why so

207
00:07:35,280 --> 00:07:37,680
but before we go there

208
00:07:37,680 --> 00:07:39,039
the uh

209
00:07:39,039 --> 00:07:41,199
you all know xor but just to reiterate

210
00:07:41,199 --> 00:07:42,960
it here here is the table on the right

211
00:07:42,960 --> 00:07:45,440
that that kind of

212
00:07:45,440 --> 00:07:48,550
like on the bit level shows the

213
00:07:48,550 --> 00:07:49,840
[Music]

214
00:07:49,840 --> 00:07:52,160
the operands and the results

215
00:07:52,160 --> 00:07:53,840
and there are a few interesting

216
00:07:53,840 --> 00:07:55,360
properties

217
00:07:55,360 --> 00:07:58,639
of xor the first one is anything xor

218
00:07:58,639 --> 00:08:00,720
with zero is the same thing doesn't

219
00:08:00,720 --> 00:08:01,680
change

220
00:08:01,680 --> 00:08:05,360
anything xor itself is zero

221
00:08:05,360 --> 00:08:09,039
and if a x or b equals c

222
00:08:09,039 --> 00:08:12,560
then a x or c equals b and b x or c

223
00:08:12,560 --> 00:08:15,039
equals a mean so that means you can move

224
00:08:15,039 --> 00:08:17,680
that operand to any side of the equation

225
00:08:17,680 --> 00:08:21,120
and it still holds true

226
00:08:23,599 --> 00:08:26,800
okay let's talk about randomness

227
00:08:26,800 --> 00:08:29,440
in terms of random number generators

228
00:08:29,440 --> 00:08:32,640
there are two big classes of them the

229
00:08:32,640 --> 00:08:34,799
first one is called true random number

230
00:08:34,799 --> 00:08:35,919
generator

231
00:08:35,919 --> 00:08:36,780
and these are

232
00:08:36,780 --> 00:08:38,000
[Music]

233
00:08:38,000 --> 00:08:40,240
things that are non-deterministic and

234
00:08:40,240 --> 00:08:43,360
they create unpredictable results

235
00:08:43,360 --> 00:08:44,560
the

236
00:08:44,560 --> 00:08:46,959
two random number generators are usually

237
00:08:46,959 --> 00:08:48,800
implemented with

238
00:08:48,800 --> 00:08:51,200
the help of hardware so there are some

239
00:08:51,200 --> 00:08:52,720
there's some input

240
00:08:52,720 --> 00:08:55,519
that is impossible to predict like for

241
00:08:55,519 --> 00:08:58,160
example inbin temperature or

242
00:08:58,160 --> 00:09:00,240
noise or um

243
00:09:00,240 --> 00:09:01,760
i don't know electric current

244
00:09:01,760 --> 00:09:04,160
fluctuations

245
00:09:04,160 --> 00:09:06,399
you name it but uh basically that's

246
00:09:06,399 --> 00:09:09,200
something that really does not depend

247
00:09:09,200 --> 00:09:11,519
on the computer itself it's some kind of

248
00:09:11,519 --> 00:09:13,360
an input from outside

249
00:09:13,360 --> 00:09:15,680
that you can convert to to random

250
00:09:15,680 --> 00:09:17,200
numbers

251
00:09:17,200 --> 00:09:20,959
and there's also pseudorandom generators

252
00:09:20,959 --> 00:09:24,000
these are deterministic

253
00:09:24,000 --> 00:09:26,800
meaning that if you run it you you if

254
00:09:26,800 --> 00:09:28,560
you give it a certain input you know

255
00:09:28,560 --> 00:09:31,120
exactly what the output is going to be

256
00:09:31,120 --> 00:09:33,839
and they're seed-based

257
00:09:33,839 --> 00:09:36,160
so you see uh zero random number

258
00:09:36,160 --> 00:09:38,240
generator with um

259
00:09:38,240 --> 00:09:41,120
like say a random number right and and

260
00:09:41,120 --> 00:09:43,519
it will give you a zero random stream so

261
00:09:43,519 --> 00:09:46,560
why why do we have two and not just one

262
00:09:46,560 --> 00:09:49,040
uh the problem is the

263
00:09:49,040 --> 00:09:51,200
true random number generators are pretty

264
00:09:51,200 --> 00:09:53,920
slow and it's very difficult to get a

265
00:09:53,920 --> 00:09:56,320
large amount of data from them

266
00:09:56,320 --> 00:09:59,040
pseudo-random generators are fast

267
00:09:59,040 --> 00:10:02,000
and they usually used in

268
00:10:02,000 --> 00:10:05,920
together so we get a we use trng to get

269
00:10:05,920 --> 00:10:09,440
that seed and then we seed prng with

270
00:10:09,440 --> 00:10:13,279
that seed and we get a stream

271
00:10:14,160 --> 00:10:15,920
all right

272
00:10:15,920 --> 00:10:17,440
a few years ago

273
00:10:17,440 --> 00:10:20,079
somebody decided to write a ransomware

274
00:10:20,079 --> 00:10:22,480
for linux the ransomware at that time

275
00:10:22,480 --> 00:10:25,360
was already popular for other platforms

276
00:10:25,360 --> 00:10:27,680
and some people thought well okay enough

277
00:10:27,680 --> 00:10:30,160
with hacking windows let's do

278
00:10:30,160 --> 00:10:32,720
let's attack linux now so they wrote

279
00:10:32,720 --> 00:10:35,200
this ransomware

280
00:10:35,200 --> 00:10:38,399
called linux encoder and

281
00:10:38,399 --> 00:10:41,279
what happened is it was immediately oh

282
00:10:41,279 --> 00:10:44,480
well almost immediately

283
00:10:45,440 --> 00:10:46,959
how to say uh

284
00:10:46,959 --> 00:10:49,200
the people were able to find an issue

285
00:10:49,200 --> 00:10:51,839
with with that ransomware

286
00:10:51,839 --> 00:10:54,480
because it depended on predictable

287
00:10:54,480 --> 00:10:56,880
encryption keys they did not

288
00:10:56,880 --> 00:11:00,240
use good entropy source and it was

289
00:11:00,240 --> 00:11:01,920
possible to

290
00:11:01,920 --> 00:11:04,320
to decrypt all the files

291
00:11:04,320 --> 00:11:06,880
without paying the ransom

292
00:11:06,880 --> 00:11:08,560
and let's see a demo for that

293
00:11:08,560 --> 00:11:10,320
i do have a demo for that

294
00:11:10,320 --> 00:11:11,920
by the way a lot of this presentation

295
00:11:11,920 --> 00:11:16,079
today will be live demos so um

296
00:11:16,079 --> 00:11:18,399
follow up and also

297
00:11:18,399 --> 00:11:20,240
at the end i'll give you a link to the

298
00:11:20,240 --> 00:11:22,880
github repo where you can download this

299
00:11:22,880 --> 00:11:25,680
code and play with it yourself and see

300
00:11:25,680 --> 00:11:28,399
what's going on analyze it modify it do

301
00:11:28,399 --> 00:11:30,079
whatever you want

302
00:11:30,079 --> 00:11:31,120
okay

303
00:11:31,120 --> 00:11:32,320
so we have

304
00:11:32,320 --> 00:11:34,800
a document

305
00:11:34,800 --> 00:11:37,200
it's a text file that says not all

306
00:11:37,200 --> 00:11:40,839
random functions were created equal

307
00:11:40,839 --> 00:11:45,200
awesome and we're going to encrypt it

308
00:11:45,200 --> 00:11:47,279
and ask for ransom so now this

309
00:11:47,279 --> 00:11:49,360
document.ransom

310
00:11:49,360 --> 00:11:51,680
is

311
00:11:52,399 --> 00:11:54,639
some kind of binary data well it's in

312
00:11:54,639 --> 00:11:57,680
its encrypted file

313
00:11:57,680 --> 00:12:00,560
we don't store the key anywhere

314
00:12:00,560 --> 00:12:02,399
if you look at the

315
00:12:02,399 --> 00:12:03,600
encrypter

316
00:12:03,600 --> 00:12:05,519
you'll see that they seed the

317
00:12:05,519 --> 00:12:07,920
pseudorandom number generator with the

318
00:12:07,920 --> 00:12:09,360
current time

319
00:12:09,360 --> 00:12:11,920
which is very very bad idea

320
00:12:11,920 --> 00:12:13,279
and why is that

321
00:12:13,279 --> 00:12:15,200
because

322
00:12:15,200 --> 00:12:16,160
the

323
00:12:16,160 --> 00:12:18,399
this file that's written on the disk has

324
00:12:18,399 --> 00:12:21,519
a timestamp the timestamp is

325
00:12:21,519 --> 00:12:23,839
with high probability exactly the same

326
00:12:23,839 --> 00:12:24,639
as

327
00:12:24,639 --> 00:12:27,760
the timestamp that was there at the time

328
00:12:27,760 --> 00:12:29,440
we were getting the seed

329
00:12:29,440 --> 00:12:32,000
so in order to decrypt this file without

330
00:12:32,000 --> 00:12:34,639
knowing the key all we need to do is to

331
00:12:34,639 --> 00:12:36,000
get the

332
00:12:36,000 --> 00:12:37,519
the

333
00:12:37,519 --> 00:12:39,360
file modification

334
00:12:39,360 --> 00:12:40,720
timestamp

335
00:12:40,720 --> 00:12:41,600
and

336
00:12:41,600 --> 00:12:43,519
use that as a seed for random number

337
00:12:43,519 --> 00:12:45,040
generator

338
00:12:45,040 --> 00:12:47,360
and decrypt the file with that so let's

339
00:12:47,360 --> 00:12:50,920
see if that works

340
00:12:53,200 --> 00:12:56,320
and it worked perfectly

341
00:12:56,320 --> 00:12:58,240
we were able to successfully decrypt the

342
00:12:58,240 --> 00:12:59,760
data

343
00:12:59,760 --> 00:13:02,160
and we got the original text and that's

344
00:13:02,160 --> 00:13:04,839
exactly what happened with that linux

345
00:13:04,839 --> 00:13:07,680
encoder ransomware they they use the

346
00:13:07,680 --> 00:13:09,839
current time to see the random number

347
00:13:09,839 --> 00:13:12,639
generator again very bad idea and here's

348
00:13:12,639 --> 00:13:14,079
a good advice

349
00:13:14,079 --> 00:13:17,279
of course it's sarcasm

350
00:13:18,160 --> 00:13:21,839
doing md5 on current time does not give

351
00:13:21,839 --> 00:13:24,560
you any advantage at all

352
00:13:24,560 --> 00:13:25,279
so

353
00:13:25,279 --> 00:13:26,399
um

354
00:13:26,399 --> 00:13:27,279
again

355
00:13:27,279 --> 00:13:30,720
this is bad advice don't use time

356
00:13:30,720 --> 00:13:32,800
okay let's talk about

357
00:13:32,800 --> 00:13:35,360
encryption algorithms

358
00:13:35,360 --> 00:13:37,839
there is this encryption algorithm that

359
00:13:37,839 --> 00:13:40,000
is not used these days it's called

360
00:13:40,000 --> 00:13:42,480
one-time pad

361
00:13:42,480 --> 00:13:44,639
let's say we have a message m and the

362
00:13:44,639 --> 00:13:45,600
key

363
00:13:45,600 --> 00:13:47,040
k

364
00:13:47,040 --> 00:13:49,040
the encryption would be a simple xor

365
00:13:49,040 --> 00:13:52,320
operation so the cipher text here c

366
00:13:52,320 --> 00:13:55,440
is m xor k and that's it that's all

367
00:13:55,440 --> 00:13:57,920
there is to this encryption algorithm

368
00:13:57,920 --> 00:14:00,639
and how how is that even encryption

369
00:14:00,639 --> 00:14:02,560
well there is a theorem

370
00:14:02,560 --> 00:14:04,800
that says that if key

371
00:14:04,800 --> 00:14:05,920
is

372
00:14:05,920 --> 00:14:07,360
uh random

373
00:14:07,360 --> 00:14:10,399
then the uh

374
00:14:10,399 --> 00:14:13,120
the key exhort with anything will also

375
00:14:13,120 --> 00:14:17,199
look like random and there is no way to

376
00:14:17,199 --> 00:14:19,839
uh to recover the original message

377
00:14:19,839 --> 00:14:21,600
just by having

378
00:14:21,600 --> 00:14:24,639
the cipher text

379
00:14:24,959 --> 00:14:27,680
well decryption due to the properties of

380
00:14:27,680 --> 00:14:28,880
xor

381
00:14:28,880 --> 00:14:32,399
is the opposite operation so we just xor

382
00:14:32,399 --> 00:14:34,880
the ciphertext with the key again and we

383
00:14:34,880 --> 00:14:37,120
get the original message

384
00:14:37,120 --> 00:14:39,440
so that's this is very very simple

385
00:14:39,440 --> 00:14:41,279
algorithm

386
00:14:41,279 --> 00:14:43,519
and here's just an example

387
00:14:43,519 --> 00:14:46,079
of ones and zeros in the message in the

388
00:14:46,079 --> 00:14:49,360
key and in the ciphertext

389
00:14:49,360 --> 00:14:50,320
so

390
00:14:50,320 --> 00:14:52,399
why is this algorithm not used these

391
00:14:52,399 --> 00:14:54,880
days well the obvious thing

392
00:14:54,880 --> 00:14:57,920
obvious problem is that key has to be as

393
00:14:57,920 --> 00:14:59,760
long as the message so if you want to

394
00:14:59,760 --> 00:15:01,760
encrypt a gigabyte of data your key has

395
00:15:01,760 --> 00:15:04,240
to be one gigabyte long and that's very

396
00:15:04,240 --> 00:15:05,839
impractical

397
00:15:05,839 --> 00:15:08,079
the second problem

398
00:15:08,079 --> 00:15:10,560
is in the name it's called one-time path

399
00:15:10,560 --> 00:15:13,920
for a reason why why one time

400
00:15:13,920 --> 00:15:16,720
well apparently if you encrypt two

401
00:15:16,720 --> 00:15:19,920
messages with the same key

402
00:15:19,920 --> 00:15:21,519
there is an issue

403
00:15:21,519 --> 00:15:24,839
if you if somebody intercepts those

404
00:15:24,839 --> 00:15:27,680
ciphertexts they can xor them

405
00:15:27,680 --> 00:15:30,560
and due to the properties of xor the key

406
00:15:30,560 --> 00:15:32,639
would cancel out and they would get an

407
00:15:32,639 --> 00:15:35,360
xor of the original messages

408
00:15:35,360 --> 00:15:38,160
this might not seem like a big issue but

409
00:15:38,160 --> 00:15:38,839
it

410
00:15:38,839 --> 00:15:40,399
is

411
00:15:40,399 --> 00:15:42,160
and

412
00:15:42,160 --> 00:15:44,399
because um the again the attacker can

413
00:15:44,399 --> 00:15:47,199
gain a lot of knowledge from

414
00:15:47,199 --> 00:15:48,480
uh just

415
00:15:48,480 --> 00:15:50,880
interception cipher text and in some

416
00:15:50,880 --> 00:15:52,480
cases

417
00:15:52,480 --> 00:15:55,839
that's enough to break the scheme

418
00:15:56,480 --> 00:15:58,720
okay

419
00:15:58,720 --> 00:16:00,560
uh

420
00:16:00,560 --> 00:16:02,320
these days we use

421
00:16:02,320 --> 00:16:04,320
instead of one-time pad we use stream

422
00:16:04,320 --> 00:16:06,320
ciphers

423
00:16:06,320 --> 00:16:07,279
so

424
00:16:07,279 --> 00:16:09,600
what is stream cipher

425
00:16:09,600 --> 00:16:11,279
instead of having

426
00:16:11,279 --> 00:16:14,480
an infinite key we have a finite key and

427
00:16:14,480 --> 00:16:17,519
we give it to a generator function

428
00:16:17,519 --> 00:16:19,680
this is basically several random number

429
00:16:19,680 --> 00:16:21,759
generator

430
00:16:21,759 --> 00:16:22,560
so

431
00:16:22,560 --> 00:16:26,320
our finite key of say 16 bytes becomes

432
00:16:26,320 --> 00:16:28,880
an infinite key stream

433
00:16:28,880 --> 00:16:30,959
and then encryption is the same as in

434
00:16:30,959 --> 00:16:32,720
one time pad we just

435
00:16:32,720 --> 00:16:33,920
xor

436
00:16:33,920 --> 00:16:36,639
message with that

437
00:16:36,639 --> 00:16:38,079
key stream

438
00:16:38,079 --> 00:16:40,000
and decryption is

439
00:16:40,000 --> 00:16:42,399
again the same thing we xor ciphertext

440
00:16:42,399 --> 00:16:45,360
with the same key but again we can see

441
00:16:45,360 --> 00:16:47,839
here that we should not reuse keys

442
00:16:47,839 --> 00:16:48,800
because

443
00:16:48,800 --> 00:16:50,639
again we'll have two messages encrypted

444
00:16:50,639 --> 00:16:52,079
with the same key

445
00:16:52,079 --> 00:16:56,320
we xor them together and we get the

446
00:16:56,320 --> 00:16:58,079
i mean we extort the ciphertext and

447
00:16:58,079 --> 00:17:02,399
we'll get the xor of original messages

448
00:17:03,040 --> 00:17:04,959
i i wanted to know that modern

449
00:17:04,959 --> 00:17:07,039
implementations of stream ciphers do

450
00:17:07,039 --> 00:17:08,880
introduce some

451
00:17:08,880 --> 00:17:10,079
randomness

452
00:17:10,079 --> 00:17:13,119
so it is these days i would say it's

453
00:17:13,119 --> 00:17:15,679
safe to use the same keys but in the

454
00:17:15,679 --> 00:17:17,839
classic sense

455
00:17:17,839 --> 00:17:18,880
each

456
00:17:18,880 --> 00:17:21,039
we should not um yeah i mean there are

457
00:17:21,039 --> 00:17:23,119
there are additional ways to additional

458
00:17:23,119 --> 00:17:24,559
ways these days in modern

459
00:17:24,559 --> 00:17:26,559
implementations to protect

460
00:17:26,559 --> 00:17:29,280
from these kind of attacks but

461
00:17:29,280 --> 00:17:30,720
let's see what happens

462
00:17:30,720 --> 00:17:34,240
if we use an older algorithm

463
00:17:34,240 --> 00:17:35,840
and encrypt the same message with the

464
00:17:35,840 --> 00:17:37,360
same key

465
00:17:37,360 --> 00:17:39,039
i mean two two different messages with

466
00:17:39,039 --> 00:17:40,640
the same key

467
00:17:40,640 --> 00:17:41,520
okay

468
00:17:41,520 --> 00:17:43,919
i have

469
00:17:43,919 --> 00:17:46,480
i have visual example here i have two

470
00:17:46,480 --> 00:17:47,440
pictures

471
00:17:47,440 --> 00:17:50,799
one picture is of myself and the other

472
00:17:50,799 --> 00:17:53,600
picture is of a smiley face

473
00:17:53,600 --> 00:17:57,520
cool so let's try to encrypt these two

474
00:17:57,520 --> 00:17:58,559
images

475
00:17:58,559 --> 00:18:01,840
with the same key

476
00:18:09,039 --> 00:18:10,880
okay

477
00:18:10,880 --> 00:18:12,000
all right

478
00:18:12,000 --> 00:18:14,480
so now in addition to these two images i

479
00:18:14,480 --> 00:18:16,640
also have

480
00:18:16,640 --> 00:18:18,480
two

481
00:18:18,480 --> 00:18:20,320
two other images that look like random

482
00:18:20,320 --> 00:18:22,480
noise and these are encrypted images

483
00:18:22,480 --> 00:18:25,520
like if i just look at one i i cannot

484
00:18:25,520 --> 00:18:27,679
tell anything about it like

485
00:18:27,679 --> 00:18:29,440
there's really

486
00:18:29,440 --> 00:18:32,400
it really looks like random data

487
00:18:32,400 --> 00:18:34,160
okay now looking at the source code

488
00:18:34,160 --> 00:18:36,720
we're using rc4

489
00:18:36,720 --> 00:18:39,200
uh algorithm which is uh again it's an

490
00:18:39,200 --> 00:18:41,600
older algorithm i do not recommend using

491
00:18:41,600 --> 00:18:43,440
it today

492
00:18:43,440 --> 00:18:45,520
but for the sake of this example

493
00:18:45,520 --> 00:18:48,720
i'm using it here just to demonstrate

494
00:18:48,720 --> 00:18:50,480
we generate a key once and then we

495
00:18:50,480 --> 00:18:53,360
encrypt two images with the same key

496
00:18:53,360 --> 00:18:55,760
all right now let's see what happens

497
00:18:55,760 --> 00:18:59,120
when i xor these two images how do i xor

498
00:18:59,120 --> 00:19:01,360
them

499
00:19:02,559 --> 00:19:05,760
i'm going to open them

500
00:19:07,039 --> 00:19:09,679
in a graphics editor and this particular

501
00:19:09,679 --> 00:19:10,960
editor

502
00:19:10,960 --> 00:19:13,600
allows me to do an xor operation so

503
00:19:13,600 --> 00:19:16,000
first thing i'm going to do is i'm going

504
00:19:16,000 --> 00:19:16,720
to

505
00:19:16,720 --> 00:19:18,400
paste

506
00:19:18,400 --> 00:19:20,160
two images

507
00:19:20,160 --> 00:19:22,640
as layers here on the right hand side

508
00:19:22,640 --> 00:19:25,280
you can see that i have two layers

509
00:19:25,280 --> 00:19:26,960
the first one is

510
00:19:26,960 --> 00:19:28,960
the the first encrypted image the second

511
00:19:28,960 --> 00:19:31,200
one is the other encrypted image

512
00:19:31,200 --> 00:19:33,840
this editor allows me to perform layer

513
00:19:33,840 --> 00:19:36,160
operations and one of them happens to be

514
00:19:36,160 --> 00:19:38,960
xor it's right here

515
00:19:38,960 --> 00:19:41,440
so if i extort them together

516
00:19:41,440 --> 00:19:43,200
see what happens

517
00:19:43,200 --> 00:19:44,080
i

518
00:19:44,080 --> 00:19:45,200
like

519
00:19:45,200 --> 00:19:47,760
i as a human can immediately

520
00:19:47,760 --> 00:19:50,080
not see just one message but both

521
00:19:50,080 --> 00:19:52,000
messages i can see that one of them was

522
00:19:52,000 --> 00:19:55,280
a portrait of a person and the other

523
00:19:55,280 --> 00:19:58,399
was a smiley face

524
00:19:58,559 --> 00:20:00,480
so it's

525
00:20:00,480 --> 00:20:01,600
to me it's

526
00:20:01,600 --> 00:20:04,000
immediately recognizable so the the that

527
00:20:04,000 --> 00:20:06,720
xor operation of the two ciphertexts

528
00:20:06,720 --> 00:20:10,159
reveals both messages to me

529
00:20:10,159 --> 00:20:14,080
moreover if i open

530
00:20:14,880 --> 00:20:16,960
if i happen to intercept

531
00:20:16,960 --> 00:20:18,880
one of the original messages like for

532
00:20:18,880 --> 00:20:20,720
example if i happen to know that one of

533
00:20:20,720 --> 00:20:23,360
them was this smiley face

534
00:20:23,360 --> 00:20:25,200
i can add it as

535
00:20:25,200 --> 00:20:26,960
a third layer

536
00:20:26,960 --> 00:20:28,720
and

537
00:20:28,720 --> 00:20:32,480
apply xor operation again

538
00:20:33,120 --> 00:20:36,240
and i get the original message

539
00:20:36,240 --> 00:20:38,559
that is uh

540
00:20:38,559 --> 00:20:40,720
that is that is a photograph

541
00:20:40,720 --> 00:20:41,840
so again

542
00:20:41,840 --> 00:20:45,280
i have three layers here random

543
00:20:45,280 --> 00:20:47,200
random

544
00:20:47,200 --> 00:20:48,480
random

545
00:20:48,480 --> 00:20:49,760
and

546
00:20:49,760 --> 00:20:51,520
a smiley face

547
00:20:51,520 --> 00:20:53,919
and when i saw them three together i get

548
00:20:53,919 --> 00:20:55,679
this like this is

549
00:20:55,679 --> 00:20:57,760
mind-blowing right

550
00:20:57,760 --> 00:21:02,360
okay cool you get the idea

551
00:21:03,600 --> 00:21:05,679
okay in additional to stream ciphers we

552
00:21:05,679 --> 00:21:08,000
also have block ciphers so stream

553
00:21:08,000 --> 00:21:09,360
ciphers

554
00:21:09,360 --> 00:21:12,559
work on on bits you can encrypt

555
00:21:12,559 --> 00:21:15,039
a single bit at a time

556
00:21:15,039 --> 00:21:17,840
block ciphers work on blocks they you

557
00:21:17,840 --> 00:21:20,400
give it a block of bytes and

558
00:21:20,400 --> 00:21:22,960
it does permutation based on the key and

559
00:21:22,960 --> 00:21:24,960
gives you ciphertext which is another

560
00:21:24,960 --> 00:21:27,280
block

561
00:21:27,360 --> 00:21:28,960
well

562
00:21:28,960 --> 00:21:31,840
usually the data we want to encrypt is

563
00:21:31,840 --> 00:21:34,400
longer than a single block it's longer

564
00:21:34,400 --> 00:21:37,120
than 16 bytes or whatever right so we

565
00:21:37,120 --> 00:21:38,320
need

566
00:21:38,320 --> 00:21:40,159
uh we need to do something about that

567
00:21:40,159 --> 00:21:41,360
the most obvious and most

568
00:21:41,360 --> 00:21:43,600
straightforward way to do that is just

569
00:21:43,600 --> 00:21:44,559
to

570
00:21:44,559 --> 00:21:46,480
to split the message

571
00:21:46,480 --> 00:21:49,280
in multiple blocks and encrypt them all

572
00:21:49,280 --> 00:21:50,559
separately

573
00:21:50,559 --> 00:21:55,120
and that might seem like okay but

574
00:21:55,679 --> 00:21:57,200
if you think about it

575
00:21:57,200 --> 00:21:58,559
if two

576
00:21:58,559 --> 00:22:00,559
plain text blocks like block one and

577
00:22:00,559 --> 00:22:03,440
block three happen to be the same then

578
00:22:03,440 --> 00:22:05,840
the two cipher text on the output will

579
00:22:05,840 --> 00:22:07,120
be the same

580
00:22:07,120 --> 00:22:09,039
and

581
00:22:09,039 --> 00:22:11,600
so so the ciphertext is no longer random

582
00:22:11,600 --> 00:22:14,480
you can see patterns there and and again

583
00:22:14,480 --> 00:22:16,720
patterns in cryptography are not good

584
00:22:16,720 --> 00:22:18,880
not good at all

585
00:22:18,880 --> 00:22:21,840
let's see what happens when we encrypt

586
00:22:21,840 --> 00:22:24,400
something with uh with the wrong mode

587
00:22:24,400 --> 00:22:25,600
like this one

588
00:22:25,600 --> 00:22:28,320
like this ecb

589
00:22:28,320 --> 00:22:31,678
again i have a visual example

590
00:22:33,919 --> 00:22:36,960
i have this image which is a screenshot

591
00:22:36,960 --> 00:22:39,520
of the title slide for this presentation

592
00:22:39,520 --> 00:22:41,280
okay

593
00:22:41,280 --> 00:22:43,520
and

594
00:22:45,840 --> 00:22:48,480
i'm going to encrypt it and this script

595
00:22:48,480 --> 00:22:50,880
encrypts it twice first it encrypts it

596
00:22:50,880 --> 00:22:52,559
with cbc mode which we have not

597
00:22:52,559 --> 00:22:55,600
discussed yet and it also encrypts it

598
00:22:55,600 --> 00:22:58,879
with ecb mode

599
00:23:00,400 --> 00:23:02,480
and here is the script it generates a

600
00:23:02,480 --> 00:23:05,120
key it does not store the key anywhere

601
00:23:05,120 --> 00:23:08,480
it encrypts files and encrypts the file

602
00:23:08,480 --> 00:23:11,039
two times with different modes

603
00:23:11,039 --> 00:23:14,000
so let's see what happens

604
00:23:17,520 --> 00:23:19,440
here is the image encrypted with ecb

605
00:23:19,440 --> 00:23:20,559
mode

606
00:23:20,559 --> 00:23:22,720
as you can tell it's

607
00:23:22,720 --> 00:23:24,640
even though it does not exactly look

608
00:23:24,640 --> 00:23:27,200
like the original image

609
00:23:27,200 --> 00:23:30,240
you can completely understand

610
00:23:30,240 --> 00:23:33,280
what was there right i we as humans can

611
00:23:33,280 --> 00:23:35,919
immediately like instantaneously analyze

612
00:23:35,919 --> 00:23:38,159
it and just

613
00:23:38,159 --> 00:23:40,480
so called decrypt the original message

614
00:23:40,480 --> 00:23:41,679
right

615
00:23:41,679 --> 00:23:44,720
in contrast here is the cbc encrypt

616
00:23:44,720 --> 00:23:46,799
encrypted image

617
00:23:46,799 --> 00:23:50,000
and that looks like random noise to me

618
00:23:50,000 --> 00:23:51,840
and there is no way for me to understand

619
00:23:51,840 --> 00:23:53,919
what's going on here

620
00:23:53,919 --> 00:23:56,720
so what is this cbc the cbc introduces

621
00:23:56,720 --> 00:23:58,080
randomness

622
00:23:58,080 --> 00:23:59,919
at for every block

623
00:23:59,919 --> 00:24:01,840
it uses

624
00:24:01,840 --> 00:24:04,480
a result of previous block encryption so

625
00:24:04,480 --> 00:24:06,559
it like for example uses this cipher

626
00:24:06,559 --> 00:24:07,760
text to

627
00:24:07,760 --> 00:24:10,000
to feed the next

628
00:24:10,000 --> 00:24:12,000
encryption operation

629
00:24:12,000 --> 00:24:15,120
so the cipher text is xor with

630
00:24:15,120 --> 00:24:16,799
plain text and then

631
00:24:16,799 --> 00:24:19,120
the whole thing is encrypted and so on

632
00:24:19,120 --> 00:24:20,559
and so on

633
00:24:20,559 --> 00:24:22,400
but for the first block we don't have

634
00:24:22,400 --> 00:24:24,799
the previous block so we need something

635
00:24:24,799 --> 00:24:26,480
else

636
00:24:26,480 --> 00:24:28,000
and that something is called

637
00:24:28,000 --> 00:24:30,400
initialization vector which is just a

638
00:24:30,400 --> 00:24:32,080
random number and it doesn't have to be

639
00:24:32,080 --> 00:24:34,880
a secret it just has to be random so you

640
00:24:34,880 --> 00:24:36,799
you generate it when you encrypt and you

641
00:24:36,799 --> 00:24:38,799
can send it along with ciphertext you

642
00:24:38,799 --> 00:24:41,200
don't have to encrypt it

643
00:24:41,200 --> 00:24:44,080
but it's it's used to to kind of to kind

644
00:24:44,080 --> 00:24:46,080
of seed that encryption operation to

645
00:24:46,080 --> 00:24:48,000
introduce randomness

646
00:24:48,000 --> 00:24:50,000
and then you use it

647
00:24:50,000 --> 00:24:51,919
during decryption

648
00:24:51,919 --> 00:24:54,080
so decryption decryption is the opposite

649
00:24:54,080 --> 00:24:56,639
operation

650
00:24:57,120 --> 00:25:01,360
at each step the previous block is used

651
00:25:01,360 --> 00:25:02,240
to

652
00:25:02,240 --> 00:25:05,520
xor with the result of decryption to get

653
00:25:05,520 --> 00:25:07,919
the original plain text

654
00:25:07,919 --> 00:25:09,520
so if we have

655
00:25:09,520 --> 00:25:11,600
the

656
00:25:11,600 --> 00:25:14,480
encrypted message of three blocks

657
00:25:14,480 --> 00:25:17,919
um c1 c2 and c3 then the decrypted

658
00:25:17,919 --> 00:25:21,120
blocks would look like this right

659
00:25:21,120 --> 00:25:23,919
so we would decrypt a block and then we

660
00:25:23,919 --> 00:25:25,760
would xor it with

661
00:25:25,760 --> 00:25:28,080
in in the case that in the case of the

662
00:25:28,080 --> 00:25:29,600
first block you would like sort it with

663
00:25:29,600 --> 00:25:30,720
iv

664
00:25:30,720 --> 00:25:32,799
second block would extort with uh with

665
00:25:32,799 --> 00:25:34,880
the first block and third block with it

666
00:25:34,880 --> 00:25:38,799
will xor with the second block and so on

667
00:25:39,679 --> 00:25:42,720
okay um

668
00:25:42,720 --> 00:25:44,880
now

669
00:25:45,840 --> 00:25:47,440
i

670
00:25:47,440 --> 00:25:50,240
one one mistake that some people make

671
00:25:50,240 --> 00:25:51,440
and

672
00:25:51,440 --> 00:25:52,880
i've seen it done

673
00:25:52,880 --> 00:25:55,120
so this is not just theoretical but it

674
00:25:55,120 --> 00:25:57,679
has been done and

675
00:25:57,679 --> 00:25:59,840
it's not a good idea

676
00:25:59,840 --> 00:26:01,919
so okay we we need this initial

677
00:26:01,919 --> 00:26:03,760
initialization vector

678
00:26:03,760 --> 00:26:06,000
and we need the key so we kind of need

679
00:26:06,000 --> 00:26:08,840
to two inputs to our encryption

680
00:26:08,840 --> 00:26:12,400
operation or decryption operation

681
00:26:12,400 --> 00:26:13,679
so why

682
00:26:13,679 --> 00:26:15,679
the question is why can't we just use

683
00:26:15,679 --> 00:26:19,600
the key as initialization vector

684
00:26:19,600 --> 00:26:20,960
well uh

685
00:26:20,960 --> 00:26:24,400
for one it's it's kind of random right

686
00:26:24,400 --> 00:26:27,200
and uh the second thing is it's secret

687
00:26:27,200 --> 00:26:29,200
so we don't even have to send it across

688
00:26:29,200 --> 00:26:31,679
with the data because whoever is

689
00:26:31,679 --> 00:26:33,760
receiving the data and decrypting it

690
00:26:33,760 --> 00:26:36,080
already knows it

691
00:26:36,080 --> 00:26:38,640
um so people try to cheat and do that

692
00:26:38,640 --> 00:26:40,720
and this is not a good idea because

693
00:26:40,720 --> 00:26:42,240
let's see what happens

694
00:26:42,240 --> 00:26:43,840
again let's say

695
00:26:43,840 --> 00:26:46,400
an attacker intercepted

696
00:26:46,400 --> 00:26:48,240
an encrypted message consisting of three

697
00:26:48,240 --> 00:26:50,640
blocks

698
00:26:50,640 --> 00:26:52,960
so if an attacker

699
00:26:52,960 --> 00:26:53,840
we

700
00:26:53,840 --> 00:26:56,480
can modify the encrypted message and

701
00:26:56,480 --> 00:26:58,000
resend it

702
00:26:58,000 --> 00:26:59,679
so it's a man in the middle right and

703
00:26:59,679 --> 00:27:02,320
resend it to the one who receives it and

704
00:27:02,320 --> 00:27:03,919
get something

705
00:27:03,919 --> 00:27:07,600
back as a result so we

706
00:27:07,600 --> 00:27:09,039
we consider

707
00:27:09,039 --> 00:27:11,279
certain assumptions here which are often

708
00:27:11,279 --> 00:27:13,120
considered in cryptography

709
00:27:13,120 --> 00:27:15,679
like in this case we can modify this

710
00:27:15,679 --> 00:27:18,159
cipher text and

711
00:27:18,159 --> 00:27:19,600
we can also

712
00:27:19,600 --> 00:27:22,880
ask the decrypter to decrypt it for us

713
00:27:22,880 --> 00:27:26,559
okay so the attacker builds this

714
00:27:26,559 --> 00:27:29,760
instead of c1 c2 and c3

715
00:27:29,760 --> 00:27:31,679
they create c1

716
00:27:31,679 --> 00:27:32,880
zeros

717
00:27:32,880 --> 00:27:35,039
and c1

718
00:27:35,039 --> 00:27:36,799
and then they give it to the decrypter

719
00:27:36,799 --> 00:27:40,000
so when the the the receiver decrypts

720
00:27:40,000 --> 00:27:41,200
that

721
00:27:41,200 --> 00:27:43,279
here's what happens

722
00:27:43,279 --> 00:27:45,520
the result of the first decryption

723
00:27:45,520 --> 00:27:47,600
operation on the first block is

724
00:27:47,600 --> 00:27:50,240
basically xored with the key because key

725
00:27:50,240 --> 00:27:52,960
is the same as ib ib is used a key is

726
00:27:52,960 --> 00:27:54,799
used as iv

727
00:27:54,799 --> 00:27:56,720
the result of the second block

728
00:27:56,720 --> 00:27:57,840
decryption

729
00:27:57,840 --> 00:28:00,640
is this and we don't care

730
00:28:00,640 --> 00:28:04,399
what it is but the result of the third

731
00:28:04,399 --> 00:28:06,559
block decryption is xor with the

732
00:28:06,559 --> 00:28:08,480
previous block

733
00:28:08,480 --> 00:28:13,360
and it's all zeros so it's just this now

734
00:28:13,360 --> 00:28:15,440
if we take that

735
00:28:15,440 --> 00:28:18,320
and this and xor them together

736
00:28:18,320 --> 00:28:20,159
we get the key

737
00:28:20,159 --> 00:28:21,520
so if

738
00:28:21,520 --> 00:28:24,159
if we can do that not only

739
00:28:24,159 --> 00:28:27,520
like we can we cannot decrypt the the

740
00:28:27,520 --> 00:28:29,120
message but we can just get the key and

741
00:28:29,120 --> 00:28:32,320
then we can decrypt the message

742
00:28:33,039 --> 00:28:35,440
and let's do a demo on that

743
00:28:35,440 --> 00:28:38,240
so for this one

744
00:28:38,960 --> 00:28:43,039
that's not the right one okay here it is

745
00:28:43,120 --> 00:28:44,399
i have

746
00:28:44,399 --> 00:28:46,960
a web application

747
00:28:46,960 --> 00:28:49,840
that gives me a session cookie

748
00:28:49,840 --> 00:28:53,760
so this session cookie happens to be

749
00:28:57,039 --> 00:29:00,240
if i look at the source code

750
00:29:02,000 --> 00:29:03,520
let's let's assume the source code is

751
00:29:03,520 --> 00:29:05,679
open anybody can analyze it

752
00:29:05,679 --> 00:29:07,360
so i'm looking at the source code i see

753
00:29:07,360 --> 00:29:10,159
that the session is a very simple object

754
00:29:10,159 --> 00:29:12,880
it has uh two

755
00:29:12,880 --> 00:29:16,320
two fields user and role and uh for for

756
00:29:16,320 --> 00:29:17,840
the guest user

757
00:29:17,840 --> 00:29:18,799
which is

758
00:29:18,799 --> 00:29:22,640
me right now the user is set to guest

759
00:29:22,640 --> 00:29:24,640
and then uh when

760
00:29:24,640 --> 00:29:26,799
when i go to this website the next time

761
00:29:26,799 --> 00:29:30,000
the this session cookie is analyzed and

762
00:29:30,000 --> 00:29:33,120
if the user is admin then i get access

763
00:29:33,120 --> 00:29:35,760
to the administrative page and if not i

764
00:29:35,760 --> 00:29:39,760
get i only get access to the guest page

765
00:29:40,559 --> 00:29:41,840
here

766
00:29:41,840 --> 00:29:45,039
we can see that the cookie is

767
00:29:45,039 --> 00:29:48,559
encrypted and is encrypted using as

768
00:29:48,559 --> 00:29:51,840
algorithm which is a good algorithm

769
00:29:51,840 --> 00:29:52,880
we use

770
00:29:52,880 --> 00:29:55,360
cbc mode great

771
00:29:55,360 --> 00:29:58,880
but we use key as iv

772
00:29:58,880 --> 00:30:01,600
let's see what can go wrong

773
00:30:01,600 --> 00:30:02,480
so

774
00:30:02,480 --> 00:30:04,640
i have this cookie value that was given

775
00:30:04,640 --> 00:30:08,360
to me by the server

776
00:30:09,600 --> 00:30:11,279
first thing i need to do is to build

777
00:30:11,279 --> 00:30:12,080
that

778
00:30:12,080 --> 00:30:14,320
really weird

779
00:30:14,320 --> 00:30:15,279
uh

780
00:30:15,279 --> 00:30:18,000
encrypted message right so instead of

781
00:30:18,000 --> 00:30:19,600
the original one

782
00:30:19,600 --> 00:30:22,640
i get this and those a's in the middle

783
00:30:22,640 --> 00:30:26,640
are the is our zero block

784
00:30:26,640 --> 00:30:29,440
now i get i

785
00:30:29,440 --> 00:30:32,720
get uh get that copy that and i refresh

786
00:30:32,720 --> 00:30:36,559
my page so that now this this new cookie

787
00:30:36,559 --> 00:30:38,559
value will get decrypted on the server

788
00:30:38,559 --> 00:30:39,760
side

789
00:30:39,760 --> 00:30:41,760
and of course

790
00:30:41,760 --> 00:30:43,760
it's not decrypted properly because

791
00:30:43,760 --> 00:30:45,760
there's some garbage here

792
00:30:45,760 --> 00:30:46,559
but

793
00:30:46,559 --> 00:30:48,720
the server is

794
00:30:48,720 --> 00:30:52,240
nice enough to tell me about it

795
00:30:52,480 --> 00:30:55,039
and even give me a base64 representation

796
00:30:55,039 --> 00:30:58,080
of the decrypted string

797
00:30:58,880 --> 00:30:59,679
and

798
00:30:59,679 --> 00:31:02,960
all i need to do now is to put that into

799
00:31:02,960 --> 00:31:05,039
my other script

800
00:31:05,039 --> 00:31:07,760
to retrieve that key

801
00:31:07,760 --> 00:31:10,159
so what are these forge and get key the

802
00:31:10,159 --> 00:31:11,440
forge is

803
00:31:11,440 --> 00:31:13,440
like very simple you know we just built

804
00:31:13,440 --> 00:31:16,240
a message using three blocks

805
00:31:16,240 --> 00:31:18,799
okay and the middle one is zeros

806
00:31:18,799 --> 00:31:20,480
and the get key

807
00:31:20,480 --> 00:31:21,840
is

808
00:31:21,840 --> 00:31:24,399
again a very simple operation it's just

809
00:31:24,399 --> 00:31:26,080
basically an xor

810
00:31:26,080 --> 00:31:28,559
this is a bitwise xor

811
00:31:28,559 --> 00:31:30,159
now how do i know that this is the

812
00:31:30,159 --> 00:31:33,120
correct key well since i since i run the

813
00:31:33,120 --> 00:31:34,480
server

814
00:31:34,480 --> 00:31:36,720
on

815
00:31:38,080 --> 00:31:39,840
on my machine

816
00:31:39,840 --> 00:31:41,600
i can just print that session key which

817
00:31:41,600 --> 00:31:43,360
is stored in the file and you see that

818
00:31:43,360 --> 00:31:46,399
it's c4 f1 e0 fb

819
00:31:46,399 --> 00:31:48,480
which is exactly matches what i was able

820
00:31:48,480 --> 00:31:51,440
to retrieve as the user who does not

821
00:31:51,440 --> 00:31:54,640
have access to the server

822
00:31:55,200 --> 00:31:56,720
cool

823
00:31:56,720 --> 00:31:58,159
okay the other problem with block

824
00:31:58,159 --> 00:32:01,440
ciphers is it only acts on blocks right

825
00:32:01,440 --> 00:32:04,720
so you you need to have your date your

826
00:32:04,720 --> 00:32:06,240
yeah your data

827
00:32:06,240 --> 00:32:07,840
uh the length of your data has to be

828
00:32:07,840 --> 00:32:10,240
multiple of the block so you can only

829
00:32:10,240 --> 00:32:11,519
encrypt

830
00:32:11,519 --> 00:32:15,360
16 bytes or 32 bytes or 48 bytes

831
00:32:15,360 --> 00:32:16,960
and so on

832
00:32:16,960 --> 00:32:19,760
but your message is not always exactly

833
00:32:19,760 --> 00:32:22,240
multiple of the block size

834
00:32:22,240 --> 00:32:25,120
so what happens then so

835
00:32:25,120 --> 00:32:27,919
what happens then is we use so-called

836
00:32:27,919 --> 00:32:28,880
padding

837
00:32:28,880 --> 00:32:31,200
let's say we have this message of

838
00:32:31,200 --> 00:32:33,120
10 bytes

839
00:32:33,120 --> 00:32:35,200
but we need 16 because our block size is

840
00:32:35,200 --> 00:32:37,440
16 this is not good

841
00:32:37,440 --> 00:32:40,320
by convention we just pad that message

842
00:32:40,320 --> 00:32:42,559
with six extra bytes

843
00:32:42,559 --> 00:32:45,919
and each one of them is set to six

844
00:32:45,919 --> 00:32:47,679
so when you decrypt

845
00:32:47,679 --> 00:32:50,000
this and you see

846
00:32:50,000 --> 00:32:53,039
that your last block is

847
00:32:53,039 --> 00:32:54,880
ends with six

848
00:32:54,880 --> 00:32:58,080
sixes then you can just throw them away

849
00:32:58,080 --> 00:33:00,159
you truncate that message because this

850
00:33:00,159 --> 00:33:02,080
is this was padding

851
00:33:02,080 --> 00:33:04,559
and padding works great for

852
00:33:04,559 --> 00:33:07,200
block ciphers

853
00:33:07,200 --> 00:33:08,880
one problem with padding

854
00:33:08,880 --> 00:33:11,679
is

855
00:33:11,679 --> 00:33:15,039
well with with implementations of

856
00:33:15,039 --> 00:33:17,519
of uh encryption of decryption

857
00:33:17,519 --> 00:33:20,559
using block ciphers is padding oracle

858
00:33:20,559 --> 00:33:22,960
what is paid in oracle so let's say your

859
00:33:22,960 --> 00:33:25,279
server who processes

860
00:33:25,279 --> 00:33:26,159
um

861
00:33:26,159 --> 00:33:28,640
encrypted data so you receive ciphertext

862
00:33:28,640 --> 00:33:30,960
you know the key you decrypt it and then

863
00:33:30,960 --> 00:33:33,039
of course you would check the padding

864
00:33:33,039 --> 00:33:35,279
and

865
00:33:35,519 --> 00:33:38,880
to to know whether you you need to um to

866
00:33:38,880 --> 00:33:41,039
trim that message or not

867
00:33:41,039 --> 00:33:45,200
and if the padding is is not okay

868
00:33:45,279 --> 00:33:47,679
it's reasonable that you give some kind

869
00:33:47,679 --> 00:33:49,200
of error message saying that your

870
00:33:49,200 --> 00:33:51,840
message was corrupt or whatever

871
00:33:51,840 --> 00:33:55,678
if everything was okay you continue

872
00:33:55,919 --> 00:33:58,480
now the problem is if you

873
00:33:58,480 --> 00:34:00,399
let the user know about this

874
00:34:00,399 --> 00:34:02,639
they

875
00:34:03,360 --> 00:34:04,960
they they can

876
00:34:04,960 --> 00:34:07,200
basically decrypt

877
00:34:07,200 --> 00:34:10,399
anything without knowing the key

878
00:34:10,399 --> 00:34:13,440
how is that possible

879
00:34:16,320 --> 00:34:18,800
that might sound like a

880
00:34:18,800 --> 00:34:21,119
strange thing how can you decrypt a

881
00:34:21,119 --> 00:34:23,760
message without knowing the key okay i

882
00:34:23,760 --> 00:34:25,839
have a petting oracle here which runs as

883
00:34:25,839 --> 00:34:27,359
a web application

884
00:34:27,359 --> 00:34:29,679
this application accepts encrypted

885
00:34:29,679 --> 00:34:32,000
messages it gives me an example

886
00:34:32,000 --> 00:34:35,119
if i refresh the page you can see that

887
00:34:35,119 --> 00:34:37,760
the message changes every time well

888
00:34:37,760 --> 00:34:39,679
actually it doesn't change it's just we

889
00:34:39,679 --> 00:34:42,719
it uses a random iv every time

890
00:34:42,719 --> 00:34:44,079
okay

891
00:34:44,079 --> 00:34:46,000
the key stays the same but

892
00:34:46,000 --> 00:34:48,079
the cipher text changes because of

893
00:34:48,079 --> 00:34:49,440
random iv

894
00:34:49,440 --> 00:34:51,119
so if i um

895
00:34:51,119 --> 00:34:52,480
click on this

896
00:34:52,480 --> 00:34:54,800
this this encrypted message gets sent in

897
00:34:54,800 --> 00:34:56,560
the url

898
00:34:56,560 --> 00:34:59,119
and it's decrypted by the server

899
00:34:59,119 --> 00:35:01,680
it gets processed i i don't know how it

900
00:35:01,680 --> 00:35:03,440
gets processed but

901
00:35:03,440 --> 00:35:05,040
um

902
00:35:05,040 --> 00:35:08,160
what if i try to change this last byte

903
00:35:08,160 --> 00:35:11,920
it's eight let's let me set it to zero

904
00:35:11,920 --> 00:35:13,839
okay

905
00:35:13,839 --> 00:35:16,640
and send it if i send it like that i get

906
00:35:16,640 --> 00:35:19,040
invalid message the title says

907
00:35:19,040 --> 00:35:21,040
unauthorized

908
00:35:21,040 --> 00:35:24,160
okay let's look at the code

909
00:35:24,160 --> 00:35:25,520
the code

910
00:35:25,520 --> 00:35:27,280
just decrypts the message using as

911
00:35:27,280 --> 00:35:30,480
algorithm using key and iv using cbc

912
00:35:30,480 --> 00:35:32,720
mode everything's good

913
00:35:32,720 --> 00:35:34,119
uh it's

914
00:35:34,119 --> 00:35:36,720
unpadding that message

915
00:35:36,720 --> 00:35:40,079
um to throw that those petting bytes

916
00:35:40,079 --> 00:35:41,280
out

917
00:35:41,280 --> 00:35:43,040
and it

918
00:35:43,040 --> 00:35:45,760
of course this is within try block and

919
00:35:45,760 --> 00:35:48,079
it catches the value error exception

920
00:35:48,079 --> 00:35:50,320
meaning something got wrong during

921
00:35:50,320 --> 00:35:51,440
decryption

922
00:35:51,440 --> 00:35:53,680
and we just say your message

923
00:35:53,680 --> 00:35:55,680
was was bad

924
00:35:55,680 --> 00:35:59,040
unauthorized whatever right and nothing

925
00:35:59,040 --> 00:36:00,720
like

926
00:36:00,720 --> 00:36:02,320
just by looking at this code you

927
00:36:02,320 --> 00:36:04,240
wouldn't assume that

928
00:36:04,240 --> 00:36:06,640
anything was done wrong here but

929
00:36:06,640 --> 00:36:08,640
this is enough for

930
00:36:08,640 --> 00:36:11,200
an attacker to decrypt message

931
00:36:11,200 --> 00:36:13,680
well i already said it like three times

932
00:36:13,680 --> 00:36:16,560
let's see how it works

933
00:36:18,800 --> 00:36:21,599
my exploit

934
00:36:23,359 --> 00:36:24,640
accepts

935
00:36:24,640 --> 00:36:26,640
the

936
00:36:26,640 --> 00:36:29,359
this url

937
00:36:30,240 --> 00:36:31,839
and what it's going to do it's going to

938
00:36:31,839 --> 00:36:34,079
retrieve that that encrypted message

939
00:36:34,079 --> 00:36:38,359
here byte by byte

940
00:36:46,160 --> 00:36:48,880
and it didn't take too long did it

941
00:36:48,880 --> 00:36:50,800
so here is the original message padding

942
00:36:50,800 --> 00:36:53,200
oracles are real

943
00:36:53,200 --> 00:36:55,680
and as as you can see it started to be

944
00:36:55,680 --> 00:36:57,119
the first block

945
00:36:57,119 --> 00:36:59,440
and starting with the last byte

946
00:36:59,440 --> 00:37:01,839
and here's s here's e s

947
00:37:01,839 --> 00:37:03,200
l e s

948
00:37:03,200 --> 00:37:05,680
c l e s and and so on and then it

949
00:37:05,680 --> 00:37:08,480
proceeded to be the next byte and

950
00:37:08,480 --> 00:37:11,440
retrieve the rest of the data

951
00:37:11,440 --> 00:37:13,760
like how did it do it

952
00:37:13,760 --> 00:37:16,560
let me run it again

953
00:37:16,560 --> 00:37:18,960
and this is the back end this is these

954
00:37:18,960 --> 00:37:20,480
are the requests on the server so

955
00:37:20,480 --> 00:37:23,440
basically this exploit sends hundreds

956
00:37:23,440 --> 00:37:26,160
of requests to the server each time a

957
00:37:26,160 --> 00:37:28,800
single bit gets well

958
00:37:28,800 --> 00:37:30,800
as a byte while

959
00:37:30,800 --> 00:37:33,040
is modified in a certain way

960
00:37:33,040 --> 00:37:35,599
and by just trying different

961
00:37:35,599 --> 00:37:37,200
different bytes

962
00:37:37,200 --> 00:37:39,680
it either gets an error

963
00:37:39,680 --> 00:37:40,560
or

964
00:37:40,560 --> 00:37:42,560
like pattern error or not no pattern

965
00:37:42,560 --> 00:37:44,320
error and

966
00:37:44,320 --> 00:37:46,560
using that information

967
00:37:46,560 --> 00:37:47,920
it's able to retrieve the original

968
00:37:47,920 --> 00:37:50,160
message here's the exploit and we're not

969
00:37:50,160 --> 00:37:52,160
going to go into details on how this is

970
00:37:52,160 --> 00:37:54,240
implemented you're welcome to study it

971
00:37:54,240 --> 00:37:56,640
on your own or contact me and i'll help

972
00:37:56,640 --> 00:37:58,480
you do that

973
00:37:58,480 --> 00:38:00,960
but it is possible it is real and these

974
00:38:00,960 --> 00:38:02,240
attacks

975
00:38:02,240 --> 00:38:03,520
are

976
00:38:03,520 --> 00:38:07,520
uh where implemented in in the world and

977
00:38:07,520 --> 00:38:09,760
i mean this is this is real stuff

978
00:38:09,760 --> 00:38:12,560
not just theory

979
00:38:12,560 --> 00:38:13,760
okay

980
00:38:13,760 --> 00:38:16,960
like i mentioned earlier we often tend

981
00:38:16,960 --> 00:38:19,280
to focus on confidentiality and forget

982
00:38:19,280 --> 00:38:21,599
about integrity

983
00:38:21,599 --> 00:38:24,640
integrity is again extremely important

984
00:38:24,640 --> 00:38:26,800
let's say we send a message

985
00:38:26,800 --> 00:38:29,440
that says send 100 to alice we encrypt

986
00:38:29,440 --> 00:38:30,560
it

987
00:38:30,560 --> 00:38:33,440
but an attacker intercepts it and

988
00:38:33,440 --> 00:38:35,920
modifies it so when the message is

989
00:38:35,920 --> 00:38:37,359
decrypted

990
00:38:37,359 --> 00:38:40,800
it says send 100 to mallory

991
00:38:40,800 --> 00:38:43,200
and alice doesn't get anything

992
00:38:43,200 --> 00:38:45,520
so is that possible

993
00:38:45,520 --> 00:38:48,400
for to do even without knowing the

994
00:38:48,400 --> 00:38:50,720
encryption key it's possible to modify

995
00:38:50,720 --> 00:38:52,320
such message

996
00:38:52,320 --> 00:38:53,920
when it's encrypted but you don't know

997
00:38:53,920 --> 00:38:56,320
the key well the answer is yes

998
00:38:56,320 --> 00:38:58,480
in some cases

999
00:38:58,480 --> 00:39:01,440
uh

1000
00:39:01,440 --> 00:39:03,119
this is this is often called the

1001
00:39:03,119 --> 00:39:06,240
philippine attack and how does it work

1002
00:39:06,240 --> 00:39:09,119
if we have if we use a stream cipher

1003
00:39:09,119 --> 00:39:10,720
and we

1004
00:39:10,720 --> 00:39:12,560
remember that stream cipher is just a

1005
00:39:12,560 --> 00:39:14,880
simple xor operation so let's say our

1006
00:39:14,880 --> 00:39:16,960
original message was guessed

1007
00:39:16,960 --> 00:39:19,520
maybe it's a session cookie right

1008
00:39:19,520 --> 00:39:22,720
so we are guessed it is encrypted

1009
00:39:22,720 --> 00:39:25,839
so this the the included message is

1010
00:39:25,839 --> 00:39:27,440
the original message

1011
00:39:27,440 --> 00:39:30,160
exort with the key stream

1012
00:39:30,160 --> 00:39:32,160
right okay

1013
00:39:32,160 --> 00:39:34,400
so attacker intercepts

1014
00:39:34,400 --> 00:39:36,160
this message

1015
00:39:36,160 --> 00:39:38,640
modifies it

1016
00:39:38,640 --> 00:39:41,680
instead of uh the original so so that

1017
00:39:41,680 --> 00:39:42,960
cipher text

1018
00:39:42,960 --> 00:39:44,800
gets xored with guest because the

1019
00:39:44,800 --> 00:39:47,280
attacker knows that if

1020
00:39:47,280 --> 00:39:49,040
it says guest

1021
00:39:49,040 --> 00:39:50,960
but the goal here is not to decrypt it

1022
00:39:50,960 --> 00:39:53,359
because it's already known the goal here

1023
00:39:53,359 --> 00:39:57,280
is to modify it so the unsuspecting

1024
00:39:57,280 --> 00:39:59,520
server

1025
00:39:59,520 --> 00:40:01,119
thinks that

1026
00:40:01,119 --> 00:40:04,560
i'm admin right so okay i xor it with

1027
00:40:04,560 --> 00:40:07,040
guest and xor it with admin why am i

1028
00:40:07,040 --> 00:40:08,160
doing it

1029
00:40:08,160 --> 00:40:08,960
now

1030
00:40:08,960 --> 00:40:10,400
let's see what happens on the server

1031
00:40:10,400 --> 00:40:13,599
whether when this message is decrypted

1032
00:40:13,599 --> 00:40:16,880
what is decrypted is simply xor with the

1033
00:40:16,880 --> 00:40:18,400
key stream

1034
00:40:18,400 --> 00:40:19,200
okay

1035
00:40:19,200 --> 00:40:21,040
which expands to this

1036
00:40:21,040 --> 00:40:23,680
so this new cipher text is basically

1037
00:40:23,680 --> 00:40:25,440
this thing

1038
00:40:25,440 --> 00:40:26,880
okay

1039
00:40:26,880 --> 00:40:29,280
now this original ciphertext is expanded

1040
00:40:29,280 --> 00:40:30,640
to this

1041
00:40:30,640 --> 00:40:33,680
now guest and guest cancel out

1042
00:40:33,680 --> 00:40:36,480
keystream and keystream cancel out

1043
00:40:36,480 --> 00:40:39,839
we get the admin

1044
00:40:40,960 --> 00:40:44,240
and i do have a demo for that

1045
00:40:49,680 --> 00:40:51,599
okay

1046
00:40:51,599 --> 00:40:53,119
again i have a very simple web

1047
00:40:53,119 --> 00:40:54,960
application

1048
00:40:54,960 --> 00:40:56,160
this time

1049
00:40:56,160 --> 00:40:59,119
it's given me session cookie encrypted

1050
00:40:59,119 --> 00:41:00,720
differently

1051
00:41:00,720 --> 00:41:01,839
not

1052
00:41:01,839 --> 00:41:04,839
not like here right

1053
00:41:04,839 --> 00:41:07,760
but if i delete this cookie

1054
00:41:07,760 --> 00:41:09,520
let me see if i can delete yep and

1055
00:41:09,520 --> 00:41:11,200
refresh the page

1056
00:41:11,200 --> 00:41:13,359
i get a different cookie value well

1057
00:41:13,359 --> 00:41:15,440
basically it's the same

1058
00:41:15,440 --> 00:41:17,520
data encrypted again

1059
00:41:17,520 --> 00:41:20,560
it's just encrypted using

1060
00:41:20,560 --> 00:41:21,920
a new

1061
00:41:21,920 --> 00:41:25,520
stream cipher called salsa 20.

1062
00:41:25,520 --> 00:41:28,960
and i'll show it to you here is also 20.

1063
00:41:28,960 --> 00:41:31,920
and this implementation is using nons

1064
00:41:31,920 --> 00:41:34,880
nonce is

1065
00:41:35,040 --> 00:41:37,280
is that randomness that i mentioned that

1066
00:41:37,280 --> 00:41:39,839
is introduced in stream ciphers

1067
00:41:39,839 --> 00:41:41,680
so

1068
00:41:41,680 --> 00:41:43,920
you know to help with stuff like key

1069
00:41:43,920 --> 00:41:45,359
reviews

1070
00:41:45,359 --> 00:41:47,839
so okay but

1071
00:41:47,839 --> 00:41:50,079
in this case i don't even care what the

1072
00:41:50,079 --> 00:41:52,000
nonsense i don't i don't even care what

1073
00:41:52,000 --> 00:41:53,760
the key is

1074
00:41:53,760 --> 00:41:55,839
i can still modify this message because

1075
00:41:55,839 --> 00:41:58,079
there are no integrity checks here

1076
00:41:58,079 --> 00:42:01,599
when the message is decrypted

1077
00:42:01,760 --> 00:42:03,680
it's decrypted right here

1078
00:42:03,680 --> 00:42:05,919
right

1079
00:42:06,240 --> 00:42:09,119
it's just converted to json and i mean

1080
00:42:09,119 --> 00:42:12,400
from json to internal object and then

1081
00:42:12,400 --> 00:42:14,839
the it gets validated against

1082
00:42:14,839 --> 00:42:16,960
admin all right

1083
00:42:16,960 --> 00:42:20,880
so i can use that bit flipping attack

1084
00:42:24,400 --> 00:42:25,440
my

1085
00:42:25,440 --> 00:42:26,960
exploit

1086
00:42:26,960 --> 00:42:28,560
just gets that

1087
00:42:28,560 --> 00:42:31,119
that ciphertext again it doesn't care

1088
00:42:31,119 --> 00:42:35,599
about the encryption key or the nouns

1089
00:42:35,680 --> 00:42:36,880
it needs

1090
00:42:36,880 --> 00:42:39,440
to know the original plain text

1091
00:42:39,440 --> 00:42:41,599
i can look at the source code and

1092
00:42:41,599 --> 00:42:43,520
analyze and understand

1093
00:42:43,520 --> 00:42:45,760
what what it is right it's user and the

1094
00:42:45,760 --> 00:42:48,560
date but conveniently it just prints it

1095
00:42:48,560 --> 00:42:52,480
here so i'm just gonna copy it from here

1096
00:42:55,599 --> 00:42:57,359
and

1097
00:42:57,359 --> 00:43:00,880
i need to put down my desired plain text

1098
00:43:00,880 --> 00:43:04,160
the desired plain text is admin

1099
00:43:04,160 --> 00:43:06,000
i want to be the admin

1100
00:43:06,000 --> 00:43:08,400
moreover if i look at the source code i

1101
00:43:08,400 --> 00:43:10,319
see that

1102
00:43:10,319 --> 00:43:13,920
the date parameter is not even used

1103
00:43:13,920 --> 00:43:17,599
so i can just completely get rid of it

1104
00:43:17,599 --> 00:43:21,520
all right so here is my new

1105
00:43:21,520 --> 00:43:23,839
message that i want the server to

1106
00:43:23,839 --> 00:43:25,440
believe

1107
00:43:25,440 --> 00:43:26,720
okay

1108
00:43:26,720 --> 00:43:28,960
cool bit flipping done here's my new

1109
00:43:28,960 --> 00:43:31,359
cookie

1110
00:43:32,720 --> 00:43:34,640
copy to my browser

1111
00:43:34,640 --> 00:43:36,880
try it again

1112
00:43:36,880 --> 00:43:39,839
now if i refresh the page

1113
00:43:39,839 --> 00:43:42,640
i'm the admin

1114
00:43:45,680 --> 00:43:46,640
well

1115
00:43:46,640 --> 00:43:49,119
it was easy with stream cipher but

1116
00:43:49,119 --> 00:43:51,119
apparently the same thing is possible

1117
00:43:51,119 --> 00:43:52,720
with block ciphers too because block

1118
00:43:52,720 --> 00:43:54,800
ciphers are using

1119
00:43:54,800 --> 00:43:57,200
initialization vector or iv

1120
00:43:57,200 --> 00:43:59,119
so especially if you're trying to modify

1121
00:43:59,119 --> 00:44:00,400
that first

1122
00:44:00,400 --> 00:44:01,599
block

1123
00:44:01,599 --> 00:44:02,400
it's

1124
00:44:02,400 --> 00:44:05,280
it can be done trivially and

1125
00:44:05,280 --> 00:44:07,359
we're not gonna go into details on this

1126
00:44:07,359 --> 00:44:09,680
but it's basically the same idea

1127
00:44:09,680 --> 00:44:12,240
because we xor with iv

1128
00:44:12,240 --> 00:44:14,960
then so we can modify that iv and submit

1129
00:44:14,960 --> 00:44:17,440
a new one and our new message

1130
00:44:17,440 --> 00:44:18,319
will

1131
00:44:18,319 --> 00:44:21,040
decrypt to what we want

1132
00:44:21,040 --> 00:44:22,720
and i have a demo for that too but i'll

1133
00:44:22,720 --> 00:44:25,200
leave it up to you as an exercise

1134
00:44:25,200 --> 00:44:27,359
when you go to github and download my

1135
00:44:27,359 --> 00:44:29,839
source code

1136
00:44:29,839 --> 00:44:32,000
so

1137
00:44:32,560 --> 00:44:34,119
to ensure

1138
00:44:34,119 --> 00:44:38,720
integrity um what we use is called

1139
00:44:38,720 --> 00:44:41,119
authenticated encryption

1140
00:44:41,119 --> 00:44:42,800
authenticated encryption

1141
00:44:42,800 --> 00:44:45,440
ensures confidentiality integrity and

1142
00:44:45,440 --> 00:44:47,520
authenticity

1143
00:44:47,520 --> 00:44:50,400
that means it is protected like

1144
00:44:50,400 --> 00:44:52,560
people cannot decrypt it if they don't

1145
00:44:52,560 --> 00:44:54,400
know the key but it's also protected

1146
00:44:54,400 --> 00:44:56,480
that people cannot modify it

1147
00:44:56,480 --> 00:44:58,640
if they don't know the key

1148
00:44:58,640 --> 00:44:59,599
uh

1149
00:44:59,599 --> 00:45:01,920
the authenticated encryption generates a

1150
00:45:01,920 --> 00:45:05,040
so-called authentication tag

1151
00:45:05,040 --> 00:45:07,599
and that authentication tag is

1152
00:45:07,599 --> 00:45:10,240
verified during decryption

1153
00:45:10,240 --> 00:45:12,319
and if it doesn't match

1154
00:45:12,319 --> 00:45:14,319
what it's supposed to be

1155
00:45:14,319 --> 00:45:17,760
then an error is generated and

1156
00:45:17,760 --> 00:45:20,000
we did not proceed we did not trust that

1157
00:45:20,000 --> 00:45:20,880
data

1158
00:45:20,880 --> 00:45:23,440
that is not authenticated

1159
00:45:23,440 --> 00:45:25,119
so very very important

1160
00:45:25,119 --> 00:45:28,079
to remember again

1161
00:45:28,240 --> 00:45:30,720
when when you doing crypto

1162
00:45:30,720 --> 00:45:33,359
make sure that you consider this

1163
00:45:33,359 --> 00:45:37,200
not just confidentiality but integrity

1164
00:45:37,200 --> 00:45:39,200
in many cases

1165
00:45:39,200 --> 00:45:41,200
not is not just as important as

1166
00:45:41,200 --> 00:45:44,319
confidentiality but in some cases it's

1167
00:45:44,319 --> 00:45:47,200
way more important

1168
00:45:47,200 --> 00:45:50,000
and the last topic that i wanted to

1169
00:45:50,000 --> 00:45:51,920
to talk to discuss today is turn in the

1170
00:45:51,920 --> 00:45:53,280
passwords

1171
00:45:53,280 --> 00:45:55,760
three things number one

1172
00:45:55,760 --> 00:45:58,400
we all know that we should not store

1173
00:45:58,400 --> 00:46:02,560
plain text passwords right because

1174
00:46:02,960 --> 00:46:05,040
because they can get leaked

1175
00:46:05,040 --> 00:46:07,440
not a good idea rule number two we

1176
00:46:07,440 --> 00:46:09,599
should not store decryptable passwords

1177
00:46:09,599 --> 00:46:11,359
okay we decided we're going to create

1178
00:46:11,359 --> 00:46:14,800
encrypt but we should not use

1179
00:46:14,800 --> 00:46:17,359
the encryption algorithms that you can

1180
00:46:17,359 --> 00:46:19,520
apply to decrypt and get the plain text

1181
00:46:19,520 --> 00:46:22,400
password because sooner or later your

1182
00:46:22,400 --> 00:46:24,880
encryption keys will get leaked

1183
00:46:24,880 --> 00:46:27,440
or compromised in some other way and

1184
00:46:27,440 --> 00:46:28,480
you'll get

1185
00:46:28,480 --> 00:46:29,839
the attacker will get access to the

1186
00:46:29,839 --> 00:46:32,480
passwords and rule number three

1187
00:46:32,480 --> 00:46:35,839
we should not use one way hash

1188
00:46:35,839 --> 00:46:37,359
and you might think

1189
00:46:37,359 --> 00:46:38,960
what

1190
00:46:38,960 --> 00:46:40,960
i thought everybody was saying that we

1191
00:46:40,960 --> 00:46:43,520
need to encrypt passwords one way

1192
00:46:43,520 --> 00:46:46,240
right yeah that's true but some people

1193
00:46:46,240 --> 00:46:48,240
take that advice

1194
00:46:48,240 --> 00:46:51,920
literally and they use one way hash

1195
00:46:51,920 --> 00:46:52,880
to

1196
00:46:52,880 --> 00:46:55,280
store the passwords

1197
00:46:55,280 --> 00:46:57,920
and why am i so specific about this

1198
00:46:57,920 --> 00:47:00,480
well there's a big difference between

1199
00:47:00,480 --> 00:47:03,280
one way hash and the other thing which

1200
00:47:03,280 --> 00:47:06,319
is also one way but it's called kdf or

1201
00:47:06,319 --> 00:47:08,960
key derivation function that's the thing

1202
00:47:08,960 --> 00:47:11,920
that we need to use for passwords

1203
00:47:11,920 --> 00:47:13,359
here's the difference

1204
00:47:13,359 --> 00:47:16,240
hash is cheap meaning it's fast

1205
00:47:16,240 --> 00:47:18,480
right

1206
00:47:18,480 --> 00:47:21,680
key derivation function is expensive

1207
00:47:21,680 --> 00:47:23,440
it can it

1208
00:47:23,440 --> 00:47:26,240
can be expensive in terms of

1209
00:47:26,240 --> 00:47:29,200
time or cpu usage or memory usage and

1210
00:47:29,200 --> 00:47:30,559
sometimes

1211
00:47:30,559 --> 00:47:32,319
all of them

1212
00:47:32,319 --> 00:47:34,720
why is it important is because if

1213
00:47:34,720 --> 00:47:38,079
somebody is trying to crack your hash

1214
00:47:38,079 --> 00:47:40,319
they can do it easily if you use a

1215
00:47:40,319 --> 00:47:42,800
one-way hash function like sha-1 for

1216
00:47:42,800 --> 00:47:44,079
example

1217
00:47:44,079 --> 00:47:46,240
or even chat to you whatever right

1218
00:47:46,240 --> 00:47:47,839
because it's by definition it's fast

1219
00:47:47,839 --> 00:47:51,680
they can iterate through thousands of

1220
00:47:51,680 --> 00:47:55,359
maybe millions of hashes per second

1221
00:47:55,359 --> 00:47:57,520
if you use kdf it becomes really

1222
00:47:57,520 --> 00:47:59,520
expensive they can iterate through a

1223
00:47:59,520 --> 00:48:02,559
handful of hashes per second and it's

1224
00:48:02,559 --> 00:48:05,359
very impractical

1225
00:48:05,359 --> 00:48:08,160
and just so you appreciate that i wanted

1226
00:48:08,160 --> 00:48:10,960
to show you a demo

1227
00:48:11,839 --> 00:48:13,280
i have a

1228
00:48:13,280 --> 00:48:14,720
hash generator

1229
00:48:14,720 --> 00:48:16,319
script

1230
00:48:16,319 --> 00:48:17,359
and

1231
00:48:17,359 --> 00:48:18,240
it

1232
00:48:18,240 --> 00:48:21,280
can generate sha-1 hashes i think it's

1233
00:48:21,280 --> 00:48:24,240
sha-1 let me double check

1234
00:48:24,240 --> 00:48:27,920
oh no it should shout to 56 cool

1235
00:48:27,920 --> 00:48:30,960
yeah shot 256 is a great hash algorithm

1236
00:48:30,960 --> 00:48:34,079
it's it's secure for its purpose right

1237
00:48:34,079 --> 00:48:37,280
it's even using random salt

1238
00:48:37,280 --> 00:48:39,200
everything is good right

1239
00:48:39,200 --> 00:48:40,960
here is the

1240
00:48:40,960 --> 00:48:43,200
generated file here is the

1241
00:48:43,200 --> 00:48:44,880
here is the hash

1242
00:48:44,880 --> 00:48:46,480
right

1243
00:48:46,480 --> 00:48:47,359
now

1244
00:48:47,359 --> 00:48:48,880
if i want to crack

1245
00:48:48,880 --> 00:48:50,800
this

1246
00:48:50,800 --> 00:48:53,119
i can run

1247
00:48:53,119 --> 00:48:54,880
different tools in this case i'm just

1248
00:48:54,880 --> 00:48:57,119
running john the ripper

1249
00:48:57,119 --> 00:48:58,480
boom and

1250
00:48:58,480 --> 00:49:00,400
my password is pink floyd

1251
00:49:00,400 --> 00:49:04,000
and it only took a fraction of a second

1252
00:49:04,000 --> 00:49:05,440
right

1253
00:49:05,440 --> 00:49:07,920
to crack this password because it's it's

1254
00:49:07,920 --> 00:49:10,000
so simple it's it's in the in it's in

1255
00:49:10,000 --> 00:49:13,040
the dictionary um and uh

1256
00:49:13,040 --> 00:49:14,240
it's in this

1257
00:49:14,240 --> 00:49:17,040
this dictionary and the tool was able to

1258
00:49:17,040 --> 00:49:20,400
iterate very quickly

1259
00:49:22,480 --> 00:49:25,680
to show you the difference let me

1260
00:49:25,680 --> 00:49:28,400
generate a hash for the same password

1261
00:49:28,400 --> 00:49:30,800
using pbkdf2

1262
00:49:30,800 --> 00:49:32,800
and

1263
00:49:32,800 --> 00:49:33,680
just

1264
00:49:33,680 --> 00:49:36,000
just to mention ppk df2 is not even the

1265
00:49:36,000 --> 00:49:37,839
latest and greatest

1266
00:49:37,839 --> 00:49:42,160
of these but just just to demonstrate

1267
00:49:43,200 --> 00:49:46,319
let me run john the ripper

1268
00:49:46,319 --> 00:49:48,800
on this

1269
00:49:49,680 --> 00:49:52,400
and you see it's taking longer already

1270
00:49:52,400 --> 00:49:54,640
first of all it's running it decides to

1271
00:49:54,640 --> 00:49:56,000
run eight

1272
00:49:56,000 --> 00:49:57,440
threads

1273
00:49:57,440 --> 00:49:59,839
to crack

1274
00:50:01,040 --> 00:50:03,119
and it's not returning yet

1275
00:50:03,119 --> 00:50:05,359
it's going to take

1276
00:50:05,359 --> 00:50:07,520
a few more seconds

1277
00:50:07,520 --> 00:50:09,040
in my

1278
00:50:09,040 --> 00:50:10,839
at least in my previous

1279
00:50:10,839 --> 00:50:13,040
tests and it should eventually return

1280
00:50:13,040 --> 00:50:15,119
okay here it returned

1281
00:50:15,119 --> 00:50:16,880
yeah the password is pink floyd he was

1282
00:50:16,880 --> 00:50:18,800
able to crack it but

1283
00:50:18,800 --> 00:50:20,559
it took

1284
00:50:20,559 --> 00:50:23,920
it took way longer like 23 seconds and

1285
00:50:23,920 --> 00:50:26,800
here are the stats it was the tool was

1286
00:50:26,800 --> 00:50:28,960
only able to iterate through

1287
00:50:28,960 --> 00:50:31,760
44 passwords per second and in the first

1288
00:50:31,760 --> 00:50:34,079
case it was able to iterate through

1289
00:50:34,079 --> 00:50:36,720
100 000 passwords per second

1290
00:50:36,720 --> 00:50:39,599
you can see it's a huge huge difference

1291
00:50:39,599 --> 00:50:43,200
so it becomes very impractical to

1292
00:50:44,160 --> 00:50:47,359
to do it for if you store the passwords

1293
00:50:47,359 --> 00:50:49,680
using a good function

1294
00:50:49,680 --> 00:50:51,119
so take aways

1295
00:50:51,119 --> 00:50:52,880
if you're a breaker you need to

1296
00:50:52,880 --> 00:50:55,200
understand the concepts of crypto on the

1297
00:50:55,200 --> 00:50:57,839
technical level yeah it's not just i

1298
00:50:57,839 --> 00:50:58,800
mean

1299
00:50:58,800 --> 00:50:59,760
um

1300
00:50:59,760 --> 00:51:02,319
sometimes it's it's enough to just know

1301
00:51:02,319 --> 00:51:04,800
the basic basics but

1302
00:51:04,800 --> 00:51:07,040
in most most of the times you need to

1303
00:51:07,040 --> 00:51:09,200
dig a little deeper

1304
00:51:09,200 --> 00:51:10,559
you need to examine the industry

1305
00:51:10,559 --> 00:51:12,000
guidelines

1306
00:51:12,000 --> 00:51:13,839
they are there for a reason

1307
00:51:13,839 --> 00:51:14,720
if

1308
00:51:14,720 --> 00:51:16,079
they say

1309
00:51:16,079 --> 00:51:19,599
a random iv needs to be used then it's

1310
00:51:19,599 --> 00:51:22,559
there for a good reason and if you see

1311
00:51:22,559 --> 00:51:24,319
that it's not being followed then

1312
00:51:24,319 --> 00:51:25,599
there's probably something wrong and

1313
00:51:25,599 --> 00:51:29,520
it's probably it could be exploitable

1314
00:51:29,520 --> 00:51:32,319
you can expand on other people's work

1315
00:51:32,319 --> 00:51:34,160
there are some tools

1316
00:51:34,160 --> 00:51:37,440
there are some there are papers

1317
00:51:37,440 --> 00:51:39,920
there are talks conference talks and and

1318
00:51:39,920 --> 00:51:43,599
whatnot and you can always use

1319
00:51:43,599 --> 00:51:45,839
the experience of other people to build

1320
00:51:45,839 --> 00:51:47,520
up on

1321
00:51:47,520 --> 00:51:49,280
if you're a builder

1322
00:51:49,280 --> 00:51:50,559
you need to understand the crypto

1323
00:51:50,559 --> 00:51:51,680
concepts

1324
00:51:51,680 --> 00:51:55,040
you don't necessarily have to dig deep

1325
00:51:55,040 --> 00:51:55,920
but

1326
00:51:55,920 --> 00:51:57,839
you need to understand

1327
00:51:57,839 --> 00:52:00,078
why

1328
00:52:00,720 --> 00:52:03,599
what you're doing and your tasks tasks

1329
00:52:03,599 --> 00:52:05,760
specifically like

1330
00:52:05,760 --> 00:52:07,920
if if you're storing the data

1331
00:52:07,920 --> 00:52:09,839
uh you want to encrypt it what algorithm

1332
00:52:09,839 --> 00:52:11,440
you need to use what keys how you store

1333
00:52:11,440 --> 00:52:12,480
the keys

1334
00:52:12,480 --> 00:52:15,119
um what encryption mode you use and so

1335
00:52:15,119 --> 00:52:16,839
on and so forth

1336
00:52:16,839 --> 00:52:18,640
and

1337
00:52:18,640 --> 00:52:20,559
of course follow all the guidelines

1338
00:52:20,559 --> 00:52:22,960
again they're there for reason if if we

1339
00:52:22,960 --> 00:52:25,200
don't follow them then we potentially

1340
00:52:25,200 --> 00:52:27,200
open up ourselves to

1341
00:52:27,200 --> 00:52:29,839
all kinds of bad things

1342
00:52:29,839 --> 00:52:31,359
and uh

1343
00:52:31,359 --> 00:52:33,760
learn uh from other people's mistakes

1344
00:52:33,760 --> 00:52:35,839
uh if

1345
00:52:35,839 --> 00:52:37,599
sometimes things like things get

1346
00:52:37,599 --> 00:52:39,920
published like uh if something was done

1347
00:52:39,920 --> 00:52:41,200
wrong like

1348
00:52:41,200 --> 00:52:42,640
and

1349
00:52:42,640 --> 00:52:45,280
you you can you can read about that and

1350
00:52:45,280 --> 00:52:48,319
see what exactly was wrong

1351
00:52:48,319 --> 00:52:50,319
and don't do that

1352
00:52:50,319 --> 00:52:51,920
for further learning

1353
00:52:51,920 --> 00:52:53,920
i i would highly recommend this course

1354
00:52:53,920 --> 00:52:55,680
on coursera it's free

1355
00:52:55,680 --> 00:52:57,280
i'm not affiliated with coursera or

1356
00:52:57,280 --> 00:52:59,119
whatever but i just happened to take

1357
00:52:59,119 --> 00:53:01,760
this course a couple of years ago and it

1358
00:53:01,760 --> 00:53:02,880
was awesome

1359
00:53:02,880 --> 00:53:04,960
i believe it's still there the second

1360
00:53:04,960 --> 00:53:07,599
thing is uh there is this

1361
00:53:07,599 --> 00:53:08,640
free

1362
00:53:08,640 --> 00:53:10,160
book

1363
00:53:10,160 --> 00:53:11,119
it's a

1364
00:53:11,119 --> 00:53:12,880
it's like open source project but it's

1365
00:53:12,880 --> 00:53:14,480
basically a pdf that you can just

1366
00:53:14,480 --> 00:53:16,079
download and read

1367
00:53:16,079 --> 00:53:17,040
uh

1368
00:53:17,040 --> 00:53:19,520
it's awesome awesome overview

1369
00:53:19,520 --> 00:53:21,359
for uh

1370
00:53:21,359 --> 00:53:23,280
in order to understand

1371
00:53:23,280 --> 00:53:24,480
some

1372
00:53:24,480 --> 00:53:25,599
well

1373
00:53:25,599 --> 00:53:27,839
it covers lots of things from really

1374
00:53:27,839 --> 00:53:30,240
basic to some really deep stuff highly

1375
00:53:30,240 --> 00:53:32,640
recommend

1376
00:53:32,640 --> 00:53:35,280
as i promised my code is on github you

1377
00:53:35,280 --> 00:53:37,920
can just go to this url

1378
00:53:37,920 --> 00:53:41,119
get downloaded play with it

1379
00:53:41,119 --> 00:53:43,920
and uh let me know if what you think let

1380
00:53:43,920 --> 00:53:47,359
me know if you wanted to uh add

1381
00:53:47,359 --> 00:53:49,520
something here i would be happy talk to

1382
00:53:49,520 --> 00:53:52,800
you and uh good luck in your crypto

1383
00:53:52,800 --> 00:53:55,800
adventures

