1
00:00:04,620 --> 00:00:07,379
hi everyone welcome back to the defender

2
00:00:07,379 --> 00:00:09,660
track I'm Muhammad farahan a volunteer

3
00:00:09,660 --> 00:00:11,280
in the WASP community and I'll be

4
00:00:11,280 --> 00:00:13,679
moderating this session uh during the

5
00:00:13,679 --> 00:00:15,480
next 45 minutes you'll be listening to

6
00:00:15,480 --> 00:00:17,760
Sohail present everything you wanted to

7
00:00:17,760 --> 00:00:19,859
know about client-side CSR but we're

8
00:00:19,859 --> 00:00:21,180
afraid to ask

9
00:00:21,180 --> 00:00:23,160
uh please submit any questions you have

10
00:00:23,160 --> 00:00:26,400
during the session in the Q a tab right

11
00:00:26,400 --> 00:00:28,920
checks to this video on the HOA platform

12
00:00:28,920 --> 00:00:31,080
I'll be asking soil your questions in

13
00:00:31,080 --> 00:00:32,880
the last 10 minutes of the session

14
00:00:32,880 --> 00:00:35,340
uh please note that the chat function in

15
00:00:35,340 --> 00:00:37,500
Zoom is disabled for attendees but you

16
00:00:37,500 --> 00:00:39,360
can leave all the comments in the chat

17
00:00:39,360 --> 00:00:41,579
tab in poor

18
00:00:41,579 --> 00:00:44,399
uh just a quick introduction about civil

19
00:00:44,399 --> 00:00:48,120
soil is a PhD candidate in Caspa helmhot

20
00:00:48,120 --> 00:00:49,920
Center of inner information security

21
00:00:49,920 --> 00:00:52,079
Germany researching in the area of web

22
00:00:52,079 --> 00:00:53,760
security automated vulnerability

23
00:00:53,760 --> 00:00:56,699
detection static and dynamic analysis

24
00:00:56,699 --> 00:00:59,160
techniques soil holds a double master's

25
00:00:59,160 --> 00:01:00,719
degree in computer science he has

26
00:01:00,719 --> 00:01:02,579
published his Works in top tier

27
00:01:02,579 --> 00:01:05,280
conferences like ndss either play SNB

28
00:01:05,280 --> 00:01:07,320
and has been invited to present his

29
00:01:07,320 --> 00:01:09,000
recent works at the Stanford security

30
00:01:09,000 --> 00:01:10,320
Lynch

31
00:01:10,320 --> 00:01:13,080
among his contributions he proposed the

32
00:01:13,080 --> 00:01:14,939
first taxonomy and detection of cross

33
00:01:14,939 --> 00:01:17,220
site leaks one of the first studies

34
00:01:17,220 --> 00:01:19,799
about the client said CSR csrf defenses

35
00:01:19,799 --> 00:01:22,080
including the same site adoption and

36
00:01:22,080 --> 00:01:24,000
other client-side vulnerabilities

37
00:01:24,000 --> 00:01:26,759
finally soil is a developer and a

38
00:01:26,759 --> 00:01:28,640
maintenance maintainer of the JavaScript

39
00:01:28,640 --> 00:01:31,259
analysis framework otherwise called Joe

40
00:01:31,259 --> 00:01:33,600
one of his first open size client-side

41
00:01:33,600 --> 00:01:35,880
JavaScript analysis Frameworks Welcome

42
00:01:35,880 --> 00:01:40,820
to Hell to our Absa Kio or to you

43
00:01:40,979 --> 00:01:42,299
um thanks Aaron for the great

44
00:01:42,299 --> 00:01:44,820
introduction so hello everybody and

45
00:01:44,820 --> 00:01:46,860
welcome to this talk my name is Sohail

46
00:01:46,860 --> 00:01:48,540
and today I'll be presenting everything

47
00:01:48,540 --> 00:01:50,100
you wanted to know about clients at

48
00:01:50,100 --> 00:01:52,740
c-serv but they're afraid to ask so if

49
00:01:52,740 --> 00:01:54,119
you're interested already about this

50
00:01:54,119 --> 00:01:56,100
talk and clients assistive attacks don't

51
00:01:56,100 --> 00:01:58,560
forget to scan this QR code down here

52
00:01:58,560 --> 00:02:00,780
where you'll find our technical paper

53
00:02:00,780 --> 00:02:02,640
open source tool and other useful

54
00:02:02,640 --> 00:02:04,500
information

55
00:02:04,500 --> 00:02:07,439
so before we started let me say a couple

56
00:02:07,439 --> 00:02:09,840
of words about me so far on already

57
00:02:09,840 --> 00:02:13,140
um uh did introduce me but I just want

58
00:02:13,140 --> 00:02:15,540
um to retreat um I'm a web security

59
00:02:15,540 --> 00:02:17,760
researcher from cispa Germany I'm

60
00:02:17,760 --> 00:02:21,480
currently doing my PhD from 2019 and my

61
00:02:21,480 --> 00:02:23,819
area of expertise and research focuses

62
00:02:23,819 --> 00:02:26,520
on building uh reusable testing tools

63
00:02:26,520 --> 00:02:28,319
and techniques for web vulnerability

64
00:02:28,319 --> 00:02:30,599
detection ranging from cross-original

65
00:02:30,599 --> 00:02:33,300
attacks to such an informational catch

66
00:02:33,300 --> 00:02:35,280
leveraging both static and dynamic

67
00:02:35,280 --> 00:02:37,379
analysis techniques

68
00:02:37,379 --> 00:02:39,720
okay so without further Ado let's get

69
00:02:39,720 --> 00:02:40,980
started

70
00:02:40,980 --> 00:02:43,140
we know that finding vulnerabilities in

71
00:02:43,140 --> 00:02:45,599
in web applications is important there

72
00:02:45,599 --> 00:02:48,360
are over 4.8 billion websites online for

73
00:02:48,360 --> 00:02:51,300
banking shopping education and so on

74
00:02:51,300 --> 00:02:54,540
with around 1.8 billion users online and

75
00:02:54,540 --> 00:02:56,459
these applications contain a variety of

76
00:02:56,459 --> 00:02:59,220
security sentencing data

77
00:02:59,220 --> 00:03:01,080
and what we also know is that the number

78
00:03:01,080 --> 00:03:02,940
of vulnerabilities in web applications

79
00:03:02,940 --> 00:03:05,280
have been increasing uh in in recent

80
00:03:05,280 --> 00:03:06,480
years

81
00:03:06,480 --> 00:03:09,480
however what has been somehow ignored is

82
00:03:09,480 --> 00:03:11,280
that the complexity of web applications

83
00:03:11,280 --> 00:03:14,220
are also Rising web applications today

84
00:03:14,220 --> 00:03:16,500
are far more complex than they used to

85
00:03:16,500 --> 00:03:18,060
be before

86
00:03:18,060 --> 00:03:20,819
okay so sorry for the delay um I had a

87
00:03:20,819 --> 00:03:23,159
problem with the slides moving

88
00:03:23,159 --> 00:03:24,599
automatically

89
00:03:24,599 --> 00:03:27,420
so okay so and what I was saying was

90
00:03:27,420 --> 00:03:28,440
that we know that finding

91
00:03:28,440 --> 00:03:30,060
vulnerabilities in web applications is

92
00:03:30,060 --> 00:03:31,739
important and we also know that the

93
00:03:31,739 --> 00:03:33,000
number of vulnerabilities in web

94
00:03:33,000 --> 00:03:34,860
applications have been increasing in

95
00:03:34,860 --> 00:03:36,000
recent years

96
00:03:36,000 --> 00:03:38,340
however what has been somehow ignored is

97
00:03:38,340 --> 00:03:40,019
that the complexity of web applications

98
00:03:40,019 --> 00:03:42,540
are also Rising

99
00:03:42,540 --> 00:03:44,819
um what has been ignored is that you

100
00:03:44,819 --> 00:03:46,620
know sub applications are far more

101
00:03:46,620 --> 00:03:49,379
complex today than there were before and

102
00:03:49,379 --> 00:03:51,140
as a result of this

103
00:03:51,140 --> 00:03:53,580
existing detection tools fall short of

104
00:03:53,580 --> 00:03:55,319
addressing this uh you know ever

105
00:03:55,319 --> 00:03:57,900
increasing complexity as a result there

106
00:03:57,900 --> 00:04:00,120
is a gap between what we can detect and

107
00:04:00,120 --> 00:04:02,519
the complexity of web applications and

108
00:04:02,519 --> 00:04:04,860
in my research I try to narrow down this

109
00:04:04,860 --> 00:04:06,299
Gap

110
00:04:06,299 --> 00:04:08,700
to better understand this problem let's

111
00:04:08,700 --> 00:04:10,560
take a look at an example of a very old

112
00:04:10,560 --> 00:04:14,220
but critical vulnerability and that is

113
00:04:14,220 --> 00:04:17,040
cross-site request forgery or shortly uh

114
00:04:17,040 --> 00:04:19,079
C server a confused Deputy security

115
00:04:19,079 --> 00:04:21,899
problem so let us Place refresh our

116
00:04:21,899 --> 00:04:24,300
knowledge about c-surf attacks what is a

117
00:04:24,300 --> 00:04:26,880
c serve basically in this attack there

118
00:04:26,880 --> 00:04:29,520
are three main actors involved a victim

119
00:04:29,520 --> 00:04:32,100
an attacker controlling manages web page

120
00:04:32,100 --> 00:04:36,419
and a Target website say bank.com

121
00:04:36,419 --> 00:04:38,520
um as you can see attack.com where the

122
00:04:38,520 --> 00:04:40,800
attacker is located is a different site

123
00:04:40,800 --> 00:04:43,860
or web origin than bank.com and that's

124
00:04:43,860 --> 00:04:46,620
why the term cross-site exists in the

125
00:04:46,620 --> 00:04:49,380
attack title so decomposing a c-serve

126
00:04:49,380 --> 00:04:52,020
into steps the attack is done price of

127
00:04:52,020 --> 00:04:54,060
two phases the preparation and the

128
00:04:54,060 --> 00:04:55,139
attack phase

129
00:04:55,139 --> 00:04:57,180
first during the preparation phase the

130
00:04:57,180 --> 00:04:59,400
attacker prepares the malicious webpage

131
00:04:59,400 --> 00:05:01,919
that includes a cross-origin or

132
00:05:01,919 --> 00:05:04,759
cross-site resource from the target site

133
00:05:04,759 --> 00:05:07,560
that if requested by the authenticated

134
00:05:07,560 --> 00:05:10,139
user results in a security sensitive

135
00:05:10,139 --> 00:05:13,320
operation like a bank transfer so here

136
00:05:13,320 --> 00:05:15,360
for instance the attack page includes a

137
00:05:15,360 --> 00:05:18,840
script tag whose SOC attribute is set to

138
00:05:18,840 --> 00:05:22,320
bank.com transfer amount 1000 into

139
00:05:22,320 --> 00:05:24,419
attacker so basically this results in an

140
00:05:24,419 --> 00:05:27,240
illicit money transfer to the attacker's

141
00:05:27,240 --> 00:05:30,120
account if the victim visits this attack

142
00:05:30,120 --> 00:05:32,880
page now during the attack page the

143
00:05:32,880 --> 00:05:34,919
attacker convinces the victim to visit

144
00:05:34,919 --> 00:05:37,740
this manager's webpage and this resource

145
00:05:37,740 --> 00:05:40,680
inclusion tricks the victim's browser to

146
00:05:40,680 --> 00:05:43,199
send an unintentional Forge request

147
00:05:43,199 --> 00:05:46,139
toward the target side automatically

148
00:05:46,139 --> 00:05:48,120
including the session cookies of the

149
00:05:48,120 --> 00:05:50,460
victim in this request simply because

150
00:05:50,460 --> 00:05:52,500
the browser complies with the same

151
00:05:52,500 --> 00:05:55,080
origin policy for cookies

152
00:05:55,080 --> 00:05:58,080
consequently this request results in a

153
00:05:58,080 --> 00:05:59,880
security sensitive state-changing

154
00:05:59,880 --> 00:06:02,220
operation like a bank transfer to be

155
00:06:02,220 --> 00:06:04,740
executed but without the victim constant

156
00:06:04,740 --> 00:06:07,320
awareness or intention now this is an

157
00:06:07,320 --> 00:06:09,960
example of a system attack which is a

158
00:06:09,960 --> 00:06:12,479
confused Deputy security flaw but do we

159
00:06:12,479 --> 00:06:14,340
know how to solve them

160
00:06:14,340 --> 00:06:15,240
um

161
00:06:15,240 --> 00:06:17,940
because sea surf attacks are an old

162
00:06:17,940 --> 00:06:20,340
security problem

163
00:06:20,340 --> 00:06:22,460
and of course the answer is yes robots

164
00:06:22,460 --> 00:06:24,960
anticipenses are are well known and they

165
00:06:24,960 --> 00:06:26,819
are indeed a plethora of these uh

166
00:06:26,819 --> 00:06:27,960
defenses

167
00:06:27,960 --> 00:06:30,419
however generally speaking we can group

168
00:06:30,419 --> 00:06:32,639
these defenses and defense in-depth

169
00:06:32,639 --> 00:06:35,940
methods in four distinct categories each

170
00:06:35,940 --> 00:06:38,220
addressing the different aspects of uh

171
00:06:38,220 --> 00:06:39,840
c-surf attacks

172
00:06:39,840 --> 00:06:42,360
the first group of defenses are origin

173
00:06:42,360 --> 00:06:44,880
checks that examine if the origin of an

174
00:06:44,880 --> 00:06:47,220
incoming HTTP request belong to a

175
00:06:47,220 --> 00:06:50,340
trusted domain or not so examples of

176
00:06:50,340 --> 00:06:52,680
these defenses are for instance refer

177
00:06:52,680 --> 00:06:55,319
origin header checks or custom HTTP

178
00:06:55,319 --> 00:06:58,500
headers like extra CrossFit that are

179
00:06:58,500 --> 00:07:00,600
added to the requests so in this

180
00:07:00,600 --> 00:07:02,400
particular example the origin of the

181
00:07:02,400 --> 00:07:04,919
request is attack.com which is not a

182
00:07:04,919 --> 00:07:07,440
trusted domain for bank.com and

183
00:07:07,440 --> 00:07:10,020
therefore bank.com can simply reject the

184
00:07:10,020 --> 00:07:12,300
request instead of serving it

185
00:07:12,300 --> 00:07:14,580
the second group of defenses at

186
00:07:14,580 --> 00:07:17,220
unguessable pseudo-random parameters to

187
00:07:17,220 --> 00:07:19,500
the request so that the attacker cannot

188
00:07:19,500 --> 00:07:22,380
reliably reproduce or replay the request

189
00:07:22,380 --> 00:07:25,380
such as a synchronizer system tokens

190
00:07:25,380 --> 00:07:27,360
double submit cookies triple submit

191
00:07:27,360 --> 00:07:29,940
cookies hmac tokens and so on

192
00:07:29,940 --> 00:07:31,860
consequently the attacker cannot

193
00:07:31,860 --> 00:07:34,199
reconstruct the valid request and the

194
00:07:34,199 --> 00:07:36,780
target side can just reject it

195
00:07:36,780 --> 00:07:39,120
the third category of defenses address

196
00:07:39,120 --> 00:07:41,880
the problem that arises by browsers

197
00:07:41,880 --> 00:07:43,680
complying to the same merging policy for

198
00:07:43,680 --> 00:07:45,720
cookies which is essentially the

199
00:07:45,720 --> 00:07:48,900
automatic inclusion of HTTP cookies in a

200
00:07:48,900 --> 00:07:51,300
cross-site request context also known as

201
00:07:51,300 --> 00:07:53,099
the ambulatory problem

202
00:07:53,099 --> 00:07:55,500
and the way they do so is by limiting

203
00:07:55,500 --> 00:07:57,419
the scope of cookies to a first party

204
00:07:57,419 --> 00:07:59,940
context for example by leveraging the

205
00:07:59,940 --> 00:08:02,400
browser Building Solutions like the

206
00:08:02,400 --> 00:08:04,740
recently uh proposed Samsung Focus

207
00:08:04,740 --> 00:08:05,960
policies

208
00:08:05,960 --> 00:08:08,699
or third-party Solutions like custom

209
00:08:08,699 --> 00:08:12,479
browser extension and hdb proxies the

210
00:08:12,479 --> 00:08:14,580
most famous of which are request Rodeo

211
00:08:14,580 --> 00:08:17,819
bbcs fire and so on

212
00:08:17,819 --> 00:08:19,919
and finally the last category of these

213
00:08:19,919 --> 00:08:22,800
self defenses aim to verify the user

214
00:08:22,800 --> 00:08:25,639
intention for example through enforcing

215
00:08:25,639 --> 00:08:28,139
re-authentication one-time tokens

216
00:08:28,139 --> 00:08:30,660
captures and recaptures

217
00:08:30,660 --> 00:08:32,880
so having these defenses properly

218
00:08:32,880 --> 00:08:35,159
enforced it seems that csap attacks can

219
00:08:35,159 --> 00:08:38,219
be old news great right

220
00:08:38,219 --> 00:08:40,320
well as it turned out that's not the

221
00:08:40,320 --> 00:08:42,679
case and let me show you an example why

222
00:08:42,679 --> 00:08:45,120
assume that we have this L application

223
00:08:45,120 --> 00:08:47,279
against cellipank.com which has this

224
00:08:47,279 --> 00:08:49,740
piece of client-side JavaScript code

225
00:08:49,740 --> 00:08:52,140
the code first reads the URL hash

226
00:08:52,140 --> 00:08:54,600
fragment and then without sanitization

227
00:08:54,600 --> 00:08:57,540
use it as a pass of an API endpoint to

228
00:08:57,540 --> 00:08:59,399
which an asynchronous request is sent

229
00:08:59,399 --> 00:09:02,300
note that this request contains a valid

230
00:09:02,300 --> 00:09:04,380
anti-forgery token

231
00:09:04,380 --> 00:09:06,000
if you have such vulnerable web

232
00:09:06,000 --> 00:09:09,060
application and attacker you can craft

233
00:09:09,060 --> 00:09:11,160
the malicious URL and lure the victim

234
00:09:11,160 --> 00:09:14,640
into clicking on it simply because the

235
00:09:14,640 --> 00:09:17,040
URL belongs to a legitimate honest but

236
00:09:17,040 --> 00:09:19,680
vulnerable website which is bank.com in

237
00:09:19,680 --> 00:09:21,180
this example

238
00:09:21,180 --> 00:09:23,100
so the client-side code in this

239
00:09:23,100 --> 00:09:24,899
particular example is sending a request

240
00:09:24,899 --> 00:09:28,620
to bank.com API transfer resulting in an

241
00:09:28,620 --> 00:09:30,360
illicit transfer of funds to the

242
00:09:30,360 --> 00:09:31,860
attackers account

243
00:09:31,860 --> 00:09:34,019
therefore the client-side code allows

244
00:09:34,019 --> 00:09:36,180
the attacker to generate requests and

245
00:09:36,180 --> 00:09:37,740
control these parameters

246
00:09:37,740 --> 00:09:39,720
now this is an example of what we call

247
00:09:39,720 --> 00:09:42,060
client-side c-serv but more generally

248
00:09:42,060 --> 00:09:43,680
client-sized these are vulnerabilities

249
00:09:43,680 --> 00:09:45,540
originate and the JavaScript program

250
00:09:45,540 --> 00:09:48,420
uses attacker controllable inputs for

251
00:09:48,420 --> 00:09:50,339
the generation of outgoing

252
00:09:50,339 --> 00:09:53,779
um asynchronous HTTP requests

253
00:09:53,779 --> 00:09:56,580
so clients at Sea surface is very new

254
00:09:56,580 --> 00:09:58,200
with the first instance affecting

255
00:09:58,200 --> 00:10:00,839
Facebook in 2018 and our knowledge about

256
00:10:00,839 --> 00:10:03,540
this vulnerability is is very limited

257
00:10:03,540 --> 00:10:06,240
as such in this work our objective is to

258
00:10:06,240 --> 00:10:08,100
study this new vulnerability

259
00:10:08,100 --> 00:10:09,959
specifically one of the first questions

260
00:10:09,959 --> 00:10:12,420
we intended to answer was quantify the

261
00:10:12,420 --> 00:10:14,040
prevalence of clients at deserve

262
00:10:14,040 --> 00:10:16,500
vulnerabilities in web applications

263
00:10:16,500 --> 00:10:18,420
then we were also interested to explore

264
00:10:18,420 --> 00:10:20,399
the different attacker models and

265
00:10:20,399 --> 00:10:23,220
possible types of exploitations that is

266
00:10:23,220 --> 00:10:25,800
a different methods an attacker can can

267
00:10:25,800 --> 00:10:28,440
control their request for example by

268
00:10:28,440 --> 00:10:31,320
manipulating the URL document referral

269
00:10:31,320 --> 00:10:34,320
web storage and the prevalence of each

270
00:10:34,320 --> 00:10:36,860
of these methods

271
00:10:36,860 --> 00:10:39,839
finally we were interested in the degree

272
00:10:39,839 --> 00:10:42,540
of attacker control that is which fields

273
00:10:42,540 --> 00:10:44,519
of a request an attacker can manipulate

274
00:10:44,519 --> 00:10:46,980
in in real web applications for example

275
00:10:46,980 --> 00:10:48,839
the endpoint of the request including

276
00:10:48,839 --> 00:10:53,399
its past query parameters domain um

277
00:10:53,399 --> 00:10:56,940
parameters in the request body and then

278
00:10:56,940 --> 00:10:58,740
how many parameters in each of these

279
00:10:58,740 --> 00:11:00,600
components that actually can can control

280
00:11:00,600 --> 00:11:02,160
and

281
00:11:02,160 --> 00:11:05,279
um basically what is the level of what

282
00:11:05,279 --> 00:11:08,040
is the injection Point can you append to

283
00:11:08,040 --> 00:11:09,899
these parameters can you prevent or can

284
00:11:09,899 --> 00:11:11,940
you overwrite these parameters

285
00:11:11,940 --> 00:11:14,160
and we wanted to understand the security

286
00:11:14,160 --> 00:11:17,160
implications of these levels of control

287
00:11:17,160 --> 00:11:18,959
now to achieve our objective you have to

288
00:11:18,959 --> 00:11:21,720
face several challenges that derive from

289
00:11:21,720 --> 00:11:23,600
the analysis of JavaScript programs

290
00:11:23,600 --> 00:11:26,339
because simply client-side seat surf as

291
00:11:26,339 --> 00:11:29,279
opposed to the traditional c-serv is a

292
00:11:29,279 --> 00:11:31,260
problem that affects the client-side

293
00:11:31,260 --> 00:11:33,680
JavaScript programs

294
00:11:33,680 --> 00:11:36,660
in particular when we look at static

295
00:11:36,660 --> 00:11:39,240
analysis and SAS tools JavaScript is an

296
00:11:39,240 --> 00:11:41,220
even driven language with a

297
00:11:41,220 --> 00:11:43,500
prototype-based inheritance runtime

298
00:11:43,500 --> 00:11:45,839
types and coercions which means that we

299
00:11:45,839 --> 00:11:48,060
have no static class hierarchies and no

300
00:11:48,060 --> 00:11:51,019
static type checking and this level of

301
00:11:51,019 --> 00:11:55,140
dynamicity makes it difficult for you

302
00:11:55,140 --> 00:11:57,000
know tools to analyze JavaScript

303
00:11:57,000 --> 00:11:59,339
programs so a static analysis of

304
00:11:59,339 --> 00:12:01,560
JavaScript is not an easy task

305
00:12:01,560 --> 00:12:03,899
for example SAS tools need to deal with

306
00:12:03,899 --> 00:12:05,940
inherent Dynamic language features of

307
00:12:05,940 --> 00:12:08,760
JavaScript such as constructs like eval

308
00:12:08,760 --> 00:12:11,100
new function set time monitor set

309
00:12:11,100 --> 00:12:13,320
interval which essentially accept a

310
00:12:13,320 --> 00:12:15,839
string and turn it into executable code

311
00:12:15,839 --> 00:12:17,279
at runtime

312
00:12:17,279 --> 00:12:19,640
now note that these strings can be

313
00:12:19,640 --> 00:12:22,920
dynamically computed obviously

314
00:12:22,920 --> 00:12:25,140
then they need to do pointer analysis

315
00:12:25,140 --> 00:12:27,420
for vulnerability detection which means

316
00:12:27,420 --> 00:12:29,279
that for example whenever we have

317
00:12:29,279 --> 00:12:32,820
expressions like this stat property they

318
00:12:32,820 --> 00:12:35,640
need to infer what hip objects uh the

319
00:12:35,640 --> 00:12:37,860
construct this refers to which is

320
00:12:37,860 --> 00:12:39,779
dependent on the scope and calling

321
00:12:39,779 --> 00:12:41,519
context

322
00:12:41,519 --> 00:12:44,160
another challenge for static analysis is

323
00:12:44,160 --> 00:12:46,680
essentially generating or trick modeling

324
00:12:46,680 --> 00:12:48,959
inter-procedural calls so SAS tools need

325
00:12:48,959 --> 00:12:51,120
to model these calls

326
00:12:51,120 --> 00:12:53,700
um and this is not an easy task when we

327
00:12:53,700 --> 00:12:56,339
have a dynamically computed property

328
00:12:56,339 --> 00:12:58,920
read and write in the language that are

329
00:12:58,920 --> 00:13:02,160
used to refer to function names that are

330
00:13:02,160 --> 00:13:03,480
invoked

331
00:13:03,480 --> 00:13:06,060
and finally we may have to handle mini

332
00:13:06,060 --> 00:13:08,579
fights or even obfuscated JavaScript

333
00:13:08,579 --> 00:13:10,320
code

334
00:13:10,320 --> 00:13:12,660
which essentially adds a layer of

335
00:13:12,660 --> 00:13:15,300
complexity to the analysis the tool

336
00:13:15,300 --> 00:13:17,519
needs to do

337
00:13:17,519 --> 00:13:19,680
and for clients like JavaScript the

338
00:13:19,680 --> 00:13:21,839
problem is aggravated by the fact that

339
00:13:21,839 --> 00:13:24,300
modeling JavaScript code alone is not

340
00:13:24,300 --> 00:13:25,320
enough

341
00:13:25,320 --> 00:13:27,959
the environment of the code also matters

342
00:13:27,959 --> 00:13:30,839
specifically the client-side code runs

343
00:13:30,839 --> 00:13:31,880
in a rich

344
00:13:31,880 --> 00:13:34,200
browser-based execution environment

345
00:13:34,200 --> 00:13:36,779
which contains the ecmascript standard

346
00:13:36,779 --> 00:13:40,139
library with around 250 abstract objects

347
00:13:40,139 --> 00:13:43,560
500 properties and 200 functions in

348
00:13:43,560 --> 00:13:45,660
addition we have different you know

349
00:13:45,660 --> 00:13:48,240
built-in native browse apis that the

350
00:13:48,240 --> 00:13:51,620
tool need to you know model and you know

351
00:13:51,620 --> 00:13:54,839
incorporate the semantic of those apis

352
00:13:54,839 --> 00:13:57,540
into the static analysis we have the

353
00:13:57,540 --> 00:14:00,860
HTML dom3 and the interaction of the

354
00:14:00,860 --> 00:14:03,839
JavaScript code with the Dom tree and

355
00:14:03,839 --> 00:14:05,519
finally we have the non-deterministic

356
00:14:05,519 --> 00:14:08,220
execution of client-side events which

357
00:14:08,220 --> 00:14:11,000
are all an extra challenge

358
00:14:11,000 --> 00:14:13,800
in addition I contrary to the Assumption

359
00:14:13,800 --> 00:14:17,579
in most static analysis approaches the

360
00:14:17,579 --> 00:14:19,980
entire code base here is never available

361
00:14:19,980 --> 00:14:23,459
for analysis simply because of the

362
00:14:23,459 --> 00:14:25,440
JavaScript streaming programming model

363
00:14:25,440 --> 00:14:27,899
which essentially means that the code is

364
00:14:27,899 --> 00:14:30,839
streamed to the user's browser and at

365
00:14:30,839 --> 00:14:32,940
any point in time you may have a set

366
00:14:32,940 --> 00:14:36,420
timeout function that loads more code so

367
00:14:36,420 --> 00:14:39,420
static analysis will not be sound

368
00:14:39,420 --> 00:14:41,880
and last but not least we have to handle

369
00:14:41,880 --> 00:14:44,940
modern client-side libraries like jQuery

370
00:14:44,940 --> 00:14:47,940
angular and so on that come with lots of

371
00:14:47,940 --> 00:14:51,060
overloading reflection and callbacks so

372
00:14:51,060 --> 00:14:52,860
they are sweet on the outside but better

373
00:14:52,860 --> 00:14:56,480
on the inside for the analysis

374
00:14:57,300 --> 00:14:59,279
um so um

375
00:14:59,279 --> 00:15:01,680
SAS tools need to model these libraries

376
00:15:01,680 --> 00:15:05,040
and modeling these you know libraries as

377
00:15:05,040 --> 00:15:07,320
they tend to repeat across different web

378
00:15:07,320 --> 00:15:09,180
pages modeling these libraries again and

379
00:15:09,180 --> 00:15:12,480
again will lead to uh poorly scalable

380
00:15:12,480 --> 00:15:15,079
Solutions

381
00:15:16,019 --> 00:15:17,940
okay so I showed you some typical

382
00:15:17,940 --> 00:15:20,160
challenges of static analysis for

383
00:15:20,160 --> 00:15:22,800
clients at JavaScript but what does they

384
00:15:22,800 --> 00:15:25,199
mean in the context of clients at CSF

385
00:15:25,199 --> 00:15:27,839
vulnerabilities let me exemplify some of

386
00:15:27,839 --> 00:15:30,600
these uh challenges for you so as soon

387
00:15:30,600 --> 00:15:32,459
we have this function called as send

388
00:15:32,459 --> 00:15:35,040
request which reads the URL hash

389
00:15:35,040 --> 00:15:38,100
fragment and use it as an endpoint of an

390
00:15:38,100 --> 00:15:40,980
asynchronous fetch request

391
00:15:40,980 --> 00:15:42,839
and note that we have the asynchronous

392
00:15:42,839 --> 00:15:44,399
fetch request that this endpoint is

393
00:15:44,399 --> 00:15:46,199
Tainted with an attacker controllable

394
00:15:46,199 --> 00:15:48,320
parameter

395
00:15:48,320 --> 00:15:51,300
obviously if this function is involved

396
00:15:51,300 --> 00:15:53,519
that a page load we have a client-side

397
00:15:53,519 --> 00:15:55,620
system vulnerability so we would like to

398
00:15:55,620 --> 00:15:57,660
detect if this is the case if this

399
00:15:57,660 --> 00:16:01,680
function send requests is invoked

400
00:16:01,680 --> 00:16:03,440
the first challenge

401
00:16:03,440 --> 00:16:05,760
that we have the first challenge to

402
00:16:05,760 --> 00:16:07,620
determine if a function send request is

403
00:16:07,620 --> 00:16:10,199
involved is that the invocation can

404
00:16:10,199 --> 00:16:12,120
happen not only via common function

405
00:16:12,120 --> 00:16:14,880
calls but also via event dispatches for

406
00:16:14,880 --> 00:16:16,920
instance in this particular example we

407
00:16:16,920 --> 00:16:18,899
have a function invocation show invoice

408
00:16:18,899 --> 00:16:21,720
price which dispatches the custom low

409
00:16:21,720 --> 00:16:23,760
demoice events for which we have a line

410
00:16:23,760 --> 00:16:25,800
of code that registers an event handler

411
00:16:25,800 --> 00:16:27,779
function for this event and the event

412
00:16:27,779 --> 00:16:30,240
handler is the send request function and

413
00:16:30,240 --> 00:16:32,160
so we have our function invoked at page

414
00:16:32,160 --> 00:16:34,519
dot eventually

415
00:16:34,519 --> 00:16:36,720
another challenge is the interaction

416
00:16:36,720 --> 00:16:39,300
between JavaScript and Dom 3. consider

417
00:16:39,300 --> 00:16:40,560
for example

418
00:16:40,560 --> 00:16:42,240
um two variables called invoice

419
00:16:42,240 --> 00:16:45,120
containing the same Dom tree node

420
00:16:45,120 --> 00:16:47,339
however the content of one variable is

421
00:16:47,339 --> 00:16:49,079
patched by a document that query

422
00:16:49,079 --> 00:16:51,360
selector and the other one by a document

423
00:16:51,360 --> 00:16:53,279
that get element by ID

424
00:16:53,279 --> 00:16:55,800
so essentially we are using Dom apis to

425
00:16:55,800 --> 00:16:58,380
point to some elements in the Dom tree

426
00:16:58,380 --> 00:17:00,779
in such a case it is often important to

427
00:17:00,779 --> 00:17:03,120
determine whether the two variables

428
00:17:03,120 --> 00:17:05,459
point to the same dumb objects that is

429
00:17:05,459 --> 00:17:07,579
doing points to analysis

430
00:17:07,579 --> 00:17:10,020
because for instance we would like to

431
00:17:10,020 --> 00:17:12,720
know on which term elements an event is

432
00:17:12,720 --> 00:17:14,640
dispatched so as to know which event

433
00:17:14,640 --> 00:17:17,880
handler is invoked however it can be

434
00:17:17,880 --> 00:17:19,859
considerably hard to do this by just

435
00:17:19,859 --> 00:17:22,079
looking at the source code AS Dom trees

436
00:17:22,079 --> 00:17:24,959
are often generated by the same program

437
00:17:24,959 --> 00:17:26,459
and finally we have to handle

438
00:17:26,459 --> 00:17:28,140
third-party libraries which means that

439
00:17:28,140 --> 00:17:30,480
instead of having the the fetch API to

440
00:17:30,480 --> 00:17:32,580
to send the request we may have a

441
00:17:32,580 --> 00:17:33,960
different function with a different

442
00:17:33,960 --> 00:17:35,960
signature sending the requests

443
00:17:35,960 --> 00:17:37,919
essentially meaning that the program

444
00:17:37,919 --> 00:17:39,780
delegates this task of sending

445
00:17:39,780 --> 00:17:41,640
asynchronous request to libraries

446
00:17:41,640 --> 00:17:44,700
instead of using built-in apis like

447
00:17:44,700 --> 00:17:48,059
fetch or XML HTTP request so it is also

448
00:17:48,059 --> 00:17:52,559
important to you know model libraries

449
00:17:53,179 --> 00:17:56,100
and in this complex landscape we also

450
00:17:56,100 --> 00:17:57,840
need to factor in and possibly address

451
00:17:57,840 --> 00:17:59,700
General detection and operational

452
00:17:59,700 --> 00:18:02,700
challenges of analyzing uh Caesar

453
00:18:02,700 --> 00:18:04,559
vulnerabilities in general

454
00:18:04,559 --> 00:18:06,480
for example if you cannot access the

455
00:18:06,480 --> 00:18:08,700
code that contains the vulnerability of

456
00:18:08,700 --> 00:18:11,160
course we cannot analyze it and this is

457
00:18:11,160 --> 00:18:12,660
the case when the functionality is

458
00:18:12,660 --> 00:18:14,760
protected by you know Access Control

459
00:18:14,760 --> 00:18:18,000
mechanisms like login so if you want to

460
00:18:18,000 --> 00:18:19,740
collect the client-side code we have to

461
00:18:19,740 --> 00:18:22,559
log into the application and then only

462
00:18:22,559 --> 00:18:24,960
then we can see the code

463
00:18:24,960 --> 00:18:26,880
second we would like to perform our

464
00:18:26,880 --> 00:18:29,340
analysis at a scale which requires us to

465
00:18:29,340 --> 00:18:31,799
analyze hundreds of pages of web

466
00:18:31,799 --> 00:18:33,660
applications so our solution need to be

467
00:18:33,660 --> 00:18:35,400
performant and this is challenging

468
00:18:35,400 --> 00:18:38,039
because of the ever increasing size and

469
00:18:38,039 --> 00:18:40,559
complexity of uh client-side JavaScript

470
00:18:40,559 --> 00:18:42,059
programs

471
00:18:42,059 --> 00:18:43,740
then there are a few operational

472
00:18:43,740 --> 00:18:46,080
challenges for for CSF vulnerabilities

473
00:18:46,080 --> 00:18:48,179
specifically such as side effect free

474
00:18:48,179 --> 00:18:50,520
testing meaning if you use Dynamic

475
00:18:50,520 --> 00:18:53,039
analysis to replay or confirm system

476
00:18:53,039 --> 00:18:55,380
requests this may change the state of

477
00:18:55,380 --> 00:18:57,539
the program for other tests so there

478
00:18:57,539 --> 00:18:59,039
will be side effects and we don't want

479
00:18:59,039 --> 00:19:02,220
that finally identifying security

480
00:19:02,220 --> 00:19:04,440
relevant State changes as opposed to

481
00:19:04,440 --> 00:19:07,799
benign State changes like writing to a

482
00:19:07,799 --> 00:19:11,220
log file is another challenge so we want

483
00:19:11,220 --> 00:19:13,380
only to detect security relevant changes

484
00:19:13,380 --> 00:19:15,600
like deleting resources disabling

485
00:19:15,600 --> 00:19:17,340
two-factor authentication or even

486
00:19:17,340 --> 00:19:19,799
changing passwords but not

487
00:19:19,799 --> 00:19:20,419
um

488
00:19:20,419 --> 00:19:23,520
changes that are not security relevant

489
00:19:23,520 --> 00:19:28,039
like maybe writing to a log file

490
00:19:28,440 --> 00:19:30,600
okay so to address some of these

491
00:19:30,600 --> 00:19:33,120
challenges in this work we present a job

492
00:19:33,120 --> 00:19:35,640
which is a scalable hybrid framework for

493
00:19:35,640 --> 00:19:38,160
detection and exploratory analysis of

494
00:19:38,160 --> 00:19:40,460
clients as itself vulnerabilities

495
00:19:40,460 --> 00:19:42,480
leveraging property graphs and

496
00:19:42,480 --> 00:19:44,520
declarative tab results

497
00:19:44,520 --> 00:19:47,220
so at the high level uh Joe is comprised

498
00:19:47,220 --> 00:19:49,440
of um three components

499
00:19:49,440 --> 00:19:51,179
um data collection model construction

500
00:19:51,179 --> 00:19:54,120
and vulnerability analysis generally

501
00:19:54,120 --> 00:19:56,600
speaking the data collection components

502
00:19:56,600 --> 00:19:59,160
collects the client-side source code of

503
00:19:59,160 --> 00:20:01,020
the applications and other runtime

504
00:20:01,020 --> 00:20:03,240
information the the graph construction

505
00:20:03,240 --> 00:20:06,059
or model construction creates an

506
00:20:06,059 --> 00:20:08,039
intermediate representation of the

507
00:20:08,039 --> 00:20:10,140
collected program and finally the

508
00:20:10,140 --> 00:20:12,240
vulnerability analysis component queries

509
00:20:12,240 --> 00:20:14,960
this intermediate representational model

510
00:20:14,960 --> 00:20:18,380
to detect vulnerabilities

511
00:20:18,380 --> 00:20:20,760
so let's have a look at the first

512
00:20:20,760 --> 00:20:22,500
component

513
00:20:22,500 --> 00:20:24,600
at the core of this you know data

514
00:20:24,600 --> 00:20:26,760
collection component is basically a

515
00:20:26,760 --> 00:20:28,620
chrome based crawler which is automated

516
00:20:28,620 --> 00:20:31,980
by selenium that starting from a single

517
00:20:31,980 --> 00:20:34,679
CD URL of the website under tests in a

518
00:20:34,679 --> 00:20:36,900
set of uh you know status scripts that

519
00:20:36,900 --> 00:20:39,539
load a particular uh you know State into

520
00:20:39,539 --> 00:20:42,120
the browser but for the crawling session

521
00:20:42,120 --> 00:20:43,679
starts

522
00:20:43,679 --> 00:20:47,580
um the crawler will collect the code so

523
00:20:47,580 --> 00:20:49,440
the goal of the status scripts is for

524
00:20:49,440 --> 00:20:51,539
for instance to load a particular State

525
00:20:51,539 --> 00:20:54,000
like login into into the browser and you

526
00:20:54,000 --> 00:20:55,919
can also log in as different users like

527
00:20:55,919 --> 00:20:58,080
login as an administrator login as a

528
00:20:58,080 --> 00:21:00,960
normal user an account with a premium

529
00:21:00,960 --> 00:21:04,020
subscription so on and so forth

530
00:21:04,020 --> 00:21:05,940
um then the crawler is also enhanced

531
00:21:05,940 --> 00:21:07,980
with the browser extension to collect

532
00:21:07,980 --> 00:21:10,620
various runtime information such as

533
00:21:10,620 --> 00:21:13,620
outgoing HTTP requests that we observed

534
00:21:13,620 --> 00:21:16,260
at runtime JavaScript library is used

535
00:21:16,260 --> 00:21:18,360
and so on

536
00:21:18,360 --> 00:21:20,340
and the output of this step will be the

537
00:21:20,340 --> 00:21:22,679
JavaScript code and a set of concrete

538
00:21:22,679 --> 00:21:24,600
values observed during the execution of

539
00:21:24,600 --> 00:21:26,880
the program which we call State values

540
00:21:26,880 --> 00:21:29,400
such as Network messages dynamically

541
00:21:29,400 --> 00:21:31,799
fired events concreted snapshots of the

542
00:21:31,799 --> 00:21:34,380
global window object such as window.

543
00:21:34,380 --> 00:21:37,679
document and web storage or window.local

544
00:21:37,679 --> 00:21:39,960
storage and snapshots of the Dom tree

545
00:21:39,960 --> 00:21:41,460
and so on

546
00:21:41,460 --> 00:21:44,400
and this will be essentially um Dynamic

547
00:21:44,400 --> 00:21:46,020
runtime information

548
00:21:46,020 --> 00:21:48,120
so the data collection module will

549
00:21:48,120 --> 00:21:51,960
output JavaScript code and state values

550
00:21:51,960 --> 00:21:54,539
then for each web page found the graph

551
00:21:54,539 --> 00:21:56,940
construction component of a jaw will

552
00:21:56,940 --> 00:21:59,340
instantiate a property graph given the

553
00:21:59,340 --> 00:22:02,460
JavaScript code and state values to do

554
00:22:02,460 --> 00:22:04,740
that joffers creates a normalized

555
00:22:04,740 --> 00:22:07,140
JavaScript program by concatenating code

556
00:22:07,140 --> 00:22:09,539
segments inside the script tags and

557
00:22:09,539 --> 00:22:12,120
inline scripts preserving the execution

558
00:22:12,120 --> 00:22:15,299
order of the program then using the data

559
00:22:15,299 --> 00:22:17,220
collected by the third party Library

560
00:22:17,220 --> 00:22:19,559
detector module of the crawler double

561
00:22:19,559 --> 00:22:23,640
symbolically model each library and then

562
00:22:23,640 --> 00:22:25,320
a symbolic model for a given Library

563
00:22:25,320 --> 00:22:29,100
already exists it reuses the model as a

564
00:22:29,100 --> 00:22:31,200
proxy for the analysis of the

565
00:22:31,200 --> 00:22:32,820
application code

566
00:22:32,820 --> 00:22:35,280
finally given the library symbolic Model

567
00:22:35,280 --> 00:22:37,559
A normalized JavaScript program and

568
00:22:37,559 --> 00:22:40,380
state values Joe creates a graph called

569
00:22:40,380 --> 00:22:43,980
hybrid property graph for in short hpg

570
00:22:43,980 --> 00:22:46,340
which we can Traverse to identify

571
00:22:46,340 --> 00:22:49,260
client-side vulnerabilities like clients

572
00:22:49,260 --> 00:22:51,780
at Sea surf

573
00:22:51,780 --> 00:22:53,700
so as you can see at the core of our

574
00:22:53,700 --> 00:22:56,280
framework jaw is the new notion of

575
00:22:56,280 --> 00:22:58,740
hybrid property graphs but what is a

576
00:22:58,740 --> 00:23:00,240
hybrid property graph

577
00:23:00,240 --> 00:23:01,860
basically if we take trade

578
00:23:01,860 --> 00:23:04,020
representation of the program that is

579
00:23:04,020 --> 00:23:07,020
abstract syntax tree or ASD control flow

580
00:23:07,020 --> 00:23:09,360
graph or CFG and program dependence

581
00:23:09,360 --> 00:23:12,000
graph or PDG that represent the program

582
00:23:12,000 --> 00:23:14,280
syntax control flow and data flow

583
00:23:14,280 --> 00:23:16,380
dependencies respectively and then

584
00:23:16,380 --> 00:23:18,620
combine these models at the safety level

585
00:23:18,620 --> 00:23:21,900
we obtain a chemical model called code

586
00:23:21,900 --> 00:23:23,760
property graph which was initially

587
00:23:23,760 --> 00:23:26,580
proposed by Yamaguchi and others for CNC

588
00:23:26,580 --> 00:23:27,960
plus plus code

589
00:23:27,960 --> 00:23:29,580
later in

590
00:23:29,580 --> 00:23:32,280
um bucket said L as the interpresidual

591
00:23:32,280 --> 00:23:34,500
call graph to this representational

592
00:23:34,500 --> 00:23:36,720
model and use it for vulnerability

593
00:23:36,720 --> 00:23:39,900
detection in server-side PHP programs in

594
00:23:39,900 --> 00:23:41,580
this work we enhance these technical

595
00:23:41,580 --> 00:23:43,980
representational model with essentially

596
00:23:43,980 --> 00:23:47,039
additional models specifically in

597
00:23:47,039 --> 00:23:48,419
JavaScript the transfer of control

598
00:23:48,419 --> 00:23:51,720
happens not only by a function codes but

599
00:23:51,720 --> 00:23:54,480
also by events therefore we add the even

600
00:23:54,480 --> 00:23:56,460
registration dispatch and dependency

601
00:23:56,460 --> 00:23:59,100
graph to to model the even driven

602
00:23:59,100 --> 00:24:01,380
execution Paradigm of JavaScript

603
00:24:01,380 --> 00:24:02,580
programs

604
00:24:02,580 --> 00:24:05,400
also as we will see next external

605
00:24:05,400 --> 00:24:08,039
libraries constitute over 60 percent of

606
00:24:08,039 --> 00:24:10,380
the total JavaScript lines have put up

607
00:24:10,380 --> 00:24:12,960
each web page and is essentially to to

608
00:24:12,960 --> 00:24:15,600
model them for example the detection of

609
00:24:15,600 --> 00:24:17,280
client-side teacher requires to

610
00:24:17,280 --> 00:24:19,559
determine when the program performs HTTP

611
00:24:19,559 --> 00:24:22,020
requests also by delegating it to to

612
00:24:22,020 --> 00:24:24,299
library functions the therefore we add

613
00:24:24,299 --> 00:24:26,940
the semantic tabs and symbolic models to

614
00:24:26,940 --> 00:24:28,980
capture the properties of statements by

615
00:24:28,980 --> 00:24:31,860
labels for example to say which

616
00:24:31,860 --> 00:24:34,620
instructions in the code send the

617
00:24:34,620 --> 00:24:37,799
request and label them with a tag called

618
00:24:37,799 --> 00:24:39,320
Rec

619
00:24:39,320 --> 00:24:41,580
finally to address the dynamic web

620
00:24:41,580 --> 00:24:43,440
execution environment of science at

621
00:24:43,440 --> 00:24:45,360
JavaScript programs we enriched this

622
00:24:45,360 --> 00:24:47,460
static representational model but

623
00:24:47,460 --> 00:24:49,919
dynamically collected State values such

624
00:24:49,919 --> 00:24:52,260
as even traces that are traces of

625
00:24:52,260 --> 00:24:53,780
concrete

626
00:24:53,780 --> 00:24:56,640
HTTP request sends and observed events

627
00:24:56,640 --> 00:24:59,580
and environment properties like the

628
00:24:59,580 --> 00:25:01,860
values of web storage cookies or

629
00:25:01,860 --> 00:25:04,679
snapshots of the Dom tree and so on

630
00:25:04,679 --> 00:25:07,080
now if we combine all these models we

631
00:25:07,080 --> 00:25:09,539
obtain a graph which captures both

632
00:25:09,539 --> 00:25:11,940
static and dynamic program behaviors

633
00:25:11,940 --> 00:25:14,400
which we call hybrid property graph

634
00:25:14,400 --> 00:25:16,500
okay so let me quickly walk you through

635
00:25:16,500 --> 00:25:19,140
some of these uh new models that we

636
00:25:19,140 --> 00:25:22,260
introduced uh in this work

637
00:25:22,260 --> 00:25:25,020
so when an event is dispatched uh one or

638
00:25:25,020 --> 00:25:26,940
more registered functions are executed

639
00:25:26,940 --> 00:25:29,159
which can change the state of the

640
00:25:29,159 --> 00:25:31,799
program register new uh handlers or

641
00:25:31,799 --> 00:25:34,500
foreign events and to capture these

642
00:25:34,500 --> 00:25:36,299
interactions we propose the even

643
00:25:36,299 --> 00:25:38,100
registration of this pattern dependency

644
00:25:38,100 --> 00:25:41,640
graph or shortly erdpg so to understand

645
00:25:41,640 --> 00:25:44,100
this model uh let us take the example of

646
00:25:44,100 --> 00:25:46,799
this uh simple JavaScript program

647
00:25:46,799 --> 00:25:49,140
let's say you have a button and there is

648
00:25:49,140 --> 00:25:51,120
a click even handle registered on this

649
00:25:51,120 --> 00:25:53,039
button so whenever a click event is

650
00:25:53,039 --> 00:25:56,100
dispatched function H is executed and a

651
00:25:56,100 --> 00:25:58,559
new asynchronous request is sent

652
00:25:58,559 --> 00:26:00,240
and somewhere in the program The Click

653
00:26:00,240 --> 00:26:03,000
event is eventually dispatched

654
00:26:03,000 --> 00:26:05,700
so having this this code we build a

655
00:26:05,700 --> 00:26:10,140
graph where nodes are non-terminal

656
00:26:10,140 --> 00:26:10,940
um

657
00:26:10,940 --> 00:26:14,100
CFG level SC nodes involved in the event

658
00:26:14,100 --> 00:26:16,320
flow and then there are three types of

659
00:26:16,320 --> 00:26:19,799
edges among them the first Edge models

660
00:26:19,799 --> 00:26:22,140
the the dispatch of the events

661
00:26:22,140 --> 00:26:24,600
um from uh basically beaten that click

662
00:26:24,600 --> 00:26:27,600
to beaten that add event listener um the

663
00:26:27,600 --> 00:26:29,340
second Edge models the registration of

664
00:26:29,340 --> 00:26:30,360
an event

665
00:26:30,360 --> 00:26:31,980
um that basically we connect an edge

666
00:26:31,980 --> 00:26:34,380
from the admin listener function to the

667
00:26:34,380 --> 00:26:38,039
to the Handler that is invoked

668
00:26:38,039 --> 00:26:40,620
um and finally the third Edge models the

669
00:26:40,620 --> 00:26:42,240
dependencies between statements and

670
00:26:42,240 --> 00:26:45,480
events meaning the asynchronous new

671
00:26:45,480 --> 00:26:48,600
asynchronous request statement will be

672
00:26:48,600 --> 00:26:51,960
executed only when the the Handler

673
00:26:51,960 --> 00:26:54,179
function H is invoked

674
00:26:54,179 --> 00:26:56,279
now remember that this is just a model

675
00:26:56,279 --> 00:26:57,960
how to automatically and accurately

676
00:26:57,960 --> 00:27:00,960
build this model without missing edges

677
00:27:00,960 --> 00:27:04,220
is another challenge

678
00:27:04,620 --> 00:27:06,960
during our evaluation we observed that

679
00:27:06,960 --> 00:27:09,059
external libraries account for over 60

680
00:27:09,059 --> 00:27:11,039
percent of the total JavaScript lines of

681
00:27:11,039 --> 00:27:13,620
code of each web page and this requires

682
00:27:13,620 --> 00:27:15,900
existing techniques to reprocess the

683
00:27:15,900 --> 00:27:17,940
same code when visiting a new page of

684
00:27:17,940 --> 00:27:19,919
the same web application which is

685
00:27:19,919 --> 00:27:21,000
inefficient

686
00:27:21,000 --> 00:27:24,419
so we addressed this uh Problem by um

687
00:27:24,419 --> 00:27:26,700
extracting a symbolic model from each

688
00:27:26,700 --> 00:27:29,340
library and use it as a proxy for the

689
00:27:29,340 --> 00:27:32,220
analysis of the application code and in

690
00:27:32,220 --> 00:27:34,440
this work the symbolic model is an

691
00:27:34,440 --> 00:27:36,779
assignment of label to libraries

692
00:27:36,779 --> 00:27:40,140
functions and object properties which we

693
00:27:40,140 --> 00:27:42,840
call semantic types or semantic labels

694
00:27:42,840 --> 00:27:45,240
Let Me Show an example so assume that we

695
00:27:45,240 --> 00:27:49,080
have a library script say lit.js which

696
00:27:49,080 --> 00:27:50,640
we want to model

697
00:27:50,640 --> 00:27:52,919
first we construct an hpg for the

698
00:27:52,919 --> 00:27:56,299
library and then we query the graph for

699
00:27:56,299 --> 00:27:58,460
nodes

700
00:27:58,460 --> 00:28:01,020
that represent native apis that are

701
00:28:01,020 --> 00:28:04,500
known for for an HTTP request such as

702
00:28:04,500 --> 00:28:06,779
examination requests or notes

703
00:28:06,779 --> 00:28:09,179
representing apis whose value can be

704
00:28:09,179 --> 00:28:11,539
under the attacker control for example

705
00:28:11,539 --> 00:28:14,220
window.location and then we assign the

706
00:28:14,220 --> 00:28:18,299
types URL or rack to these nodes

707
00:28:18,299 --> 00:28:20,279
respectively which will capture the

708
00:28:20,279 --> 00:28:22,559
semantic of these instructions for

709
00:28:22,559 --> 00:28:26,279
example Rec for XML HTTP request and URL

710
00:28:26,279 --> 00:28:28,740
for a window.location.href

711
00:28:28,740 --> 00:28:31,559
there's then these semantic types are

712
00:28:31,559 --> 00:28:33,960
propagated to other nodes following the

713
00:28:33,960 --> 00:28:36,000
calculation of the program that is our

714
00:28:36,000 --> 00:28:38,279
PDG CFG

715
00:28:38,279 --> 00:28:38,960
um

716
00:28:38,960 --> 00:28:42,659
erddg graph edges which will allow us to

717
00:28:42,659 --> 00:28:44,460
derive the symbolic model for the

718
00:28:44,460 --> 00:28:47,039
library by creating the graph for nodes

719
00:28:47,039 --> 00:28:49,799
with these semantic types therefore we

720
00:28:49,799 --> 00:28:51,539
will realize that there is a function

721
00:28:51,539 --> 00:28:53,700
called for instance external Library

722
00:28:53,700 --> 00:28:57,480
HTTP request that will that is used for

723
00:28:57,480 --> 00:28:59,940
sending an asynchronous request

724
00:28:59,940 --> 00:29:02,340
similarly libraries can be part of the

725
00:29:02,340 --> 00:29:04,260
data flows of a program and to

726
00:29:04,260 --> 00:29:06,360
reconstruct those data flows we Define

727
00:29:06,360 --> 00:29:09,659
semantic types modeling intra procedural

728
00:29:09,659 --> 00:29:11,460
input output dependencies of Library

729
00:29:11,460 --> 00:29:13,919
functions for instance we can have a

730
00:29:13,919 --> 00:29:18,360
label like or Roi if the input flows to

731
00:29:18,360 --> 00:29:22,140
their output or o tildei if the output

732
00:29:22,140 --> 00:29:24,240
of a function is conditionally dependent

733
00:29:24,240 --> 00:29:27,179
on its input parameters and these are

734
00:29:27,179 --> 00:29:31,020
only a few examples of semantic types

735
00:29:31,020 --> 00:29:33,360
okay so to share an example once we put

736
00:29:33,360 --> 00:29:36,059
all these models together we will have a

737
00:29:36,059 --> 00:29:38,700
graph like this one which has a static

738
00:29:38,700 --> 00:29:41,460
part representing the code and a dynamic

739
00:29:41,460 --> 00:29:43,260
part representing the runtime

740
00:29:43,260 --> 00:29:45,419
information and then there are edges

741
00:29:45,419 --> 00:29:47,520
connecting the two models now I don't

742
00:29:47,520 --> 00:29:48,960
want to go into the details of this

743
00:29:48,960 --> 00:29:50,640
graph but just wanted to give you an

744
00:29:50,640 --> 00:29:52,740
idea of how it could look like and then

745
00:29:52,740 --> 00:29:54,840
I can show you how we can use this for

746
00:29:54,840 --> 00:29:58,080
uh detecting clients at csurf

747
00:29:58,080 --> 00:30:01,919
okay so once we have these hpg this

748
00:30:01,919 --> 00:30:04,020
hybrid property graph

749
00:30:04,020 --> 00:30:06,059
um what do we do with it basically jaw

750
00:30:06,059 --> 00:30:08,460
Imports this hpg inside the graph

751
00:30:08,460 --> 00:30:11,460
database in particular neo4j and then we

752
00:30:11,460 --> 00:30:13,260
can declaratively Traverse this graph

753
00:30:13,260 --> 00:30:15,539
using the cipher query language to

754
00:30:15,539 --> 00:30:17,940
explore a vulnerable program behaviors

755
00:30:17,940 --> 00:30:23,419
and detect and study clients at csurf

756
00:30:24,779 --> 00:30:27,000
but how do we actually Traverse this

757
00:30:27,000 --> 00:30:29,460
graph to detect lines at csurf well um

758
00:30:29,460 --> 00:30:31,440
to illustrate that let's take a step

759
00:30:31,440 --> 00:30:33,779
back and Define what clients as user is

760
00:30:33,779 --> 00:30:35,340
precisely

761
00:30:35,340 --> 00:30:37,860
to give an example we may have this line

762
00:30:37,860 --> 00:30:40,080
of code that reads part of the URL hash

763
00:30:40,080 --> 00:30:42,299
fragment and use it verbatim as the

764
00:30:42,299 --> 00:30:44,460
domain of an asynchronous fetch

765
00:30:44,460 --> 00:30:46,740
operation and in this case our objective

766
00:30:46,740 --> 00:30:49,140
is to find line two which is Mark in

767
00:30:49,140 --> 00:30:51,960
graph another example is the case where

768
00:30:51,960 --> 00:30:54,720
the developer instantiates an external

769
00:30:54,720 --> 00:30:57,059
ship request object and the Europe hash

770
00:30:57,059 --> 00:31:00,000
fragment flows to this xhr

771
00:31:00,000 --> 00:31:01,620
and finally it may be that the the

772
00:31:01,620 --> 00:31:03,600
developer uses a third-party Library

773
00:31:03,600 --> 00:31:06,360
function to send a request and also in

774
00:31:06,360 --> 00:31:08,159
addition to controlling the URL the

775
00:31:08,159 --> 00:31:10,140
attacker can manipulate their request

776
00:31:10,140 --> 00:31:14,159
body via multiple um injection points so

777
00:31:14,159 --> 00:31:16,679
looking at these examples we can Define

778
00:31:16,679 --> 00:31:19,620
clients at c-serv as a data flow from an

779
00:31:19,620 --> 00:31:22,260
attacker controlled input to parameter

780
00:31:22,260 --> 00:31:24,840
of a request are meaning lines of code

781
00:31:24,840 --> 00:31:28,380
having both URL and semantic tags that

782
00:31:28,380 --> 00:31:31,860
are marked with orange and blue boxes in

783
00:31:31,860 --> 00:31:32,940
the example

784
00:31:32,940 --> 00:31:34,980
and then the second condition is that

785
00:31:34,980 --> 00:31:37,320
this request R should be reachable at

786
00:31:37,320 --> 00:31:39,539
page load meaning whenever you visit the

787
00:31:39,539 --> 00:31:41,640
URL the request is sent automatically

788
00:31:41,640 --> 00:31:44,640
without further interaction uh by the

789
00:31:44,640 --> 00:31:45,720
user

790
00:31:45,720 --> 00:31:48,120
so we can model these conditions using

791
00:31:48,120 --> 00:31:49,799
graph tab results

792
00:31:49,799 --> 00:31:51,600
um uh decoratively with the cipher

793
00:31:51,600 --> 00:31:52,799
required language

794
00:31:52,799 --> 00:31:55,260
for Simplicity in this presentation I

795
00:31:55,260 --> 00:31:57,720
exemplify The Cypher syntax with pretty

796
00:31:57,720 --> 00:31:59,880
good logic and set notation while

797
00:31:59,880 --> 00:32:01,799
retaining the declarative approach so

798
00:32:01,799 --> 00:32:03,480
let me show you a simple query as an

799
00:32:03,480 --> 00:32:05,760
example we can basically say that the

800
00:32:05,760 --> 00:32:08,700
query queue contains all nodes of an hpg

801
00:32:08,700 --> 00:32:10,440
for which a predicate p is to

802
00:32:10,440 --> 00:32:12,799
essentially we have this

803
00:32:12,799 --> 00:32:15,020
predicate function

804
00:32:15,020 --> 00:32:18,419
saying what properties of a node what

805
00:32:18,419 --> 00:32:20,039
properties the node should have to be

806
00:32:20,039 --> 00:32:22,559
included in the query result set note

807
00:32:22,559 --> 00:32:24,539
that the query is declarative in the

808
00:32:24,539 --> 00:32:26,399
sense that we tell the underlying query

809
00:32:26,399 --> 00:32:29,039
engine what we want by specifying this

810
00:32:29,039 --> 00:32:31,740
predicate function p and that captures

811
00:32:31,740 --> 00:32:33,240
some properties that we are interested

812
00:32:33,240 --> 00:32:35,700
in rather than how to do it essentially

813
00:32:35,700 --> 00:32:38,460
we delegate the task of how to do it to

814
00:32:38,460 --> 00:32:40,620
The Cypher query engine and this is

815
00:32:40,620 --> 00:32:42,600
fantastic because we can just describe

816
00:32:42,600 --> 00:32:45,779
the vulnerability pattern and find it

817
00:32:45,779 --> 00:32:48,539
now an example of C self detection query

818
00:32:48,539 --> 00:32:50,640
can look as follows we are basically

819
00:32:50,640 --> 00:32:53,039
looking for all nodes in that are top

820
00:32:53,039 --> 00:32:54,720
level instructions meaning there are

821
00:32:54,720 --> 00:32:57,120
declarations or statements

822
00:32:57,120 --> 00:32:59,220
um and these node ends have two children

823
00:32:59,220 --> 00:33:02,279
let's say C1 and C2 one of them has a

824
00:33:02,279 --> 00:33:04,320
Rex semantic type meaning is a request

825
00:33:04,320 --> 00:33:06,299
sending instruction and the other one

826
00:33:06,299 --> 00:33:08,460
has the URL semantic type meaning it's

827
00:33:08,460 --> 00:33:11,399
an attacker controllable data via URL so

828
00:33:11,399 --> 00:33:13,500
if a node is Tainted with both of these

829
00:33:13,500 --> 00:33:15,419
labels this means that we have a

830
00:33:15,419 --> 00:33:16,860
client-side system of vulnerability

831
00:33:16,860 --> 00:33:19,320
finally of course we can refine this

832
00:33:19,320 --> 00:33:21,960
query with additional checks for uh

833
00:33:21,960 --> 00:33:23,940
reachability

834
00:33:23,940 --> 00:33:25,980
um but basically for every node returns

835
00:33:25,980 --> 00:33:28,019
in in the output of this query we check

836
00:33:28,019 --> 00:33:30,360
if that node is reachable at a page load

837
00:33:30,360 --> 00:33:33,979
via additional Cipher queries

838
00:33:34,640 --> 00:33:38,159
now uh URL parameters such as the hash

839
00:33:38,159 --> 00:33:40,140
fragment are not the only way attackers

840
00:33:40,140 --> 00:33:42,480
can forge asynchronous request for

841
00:33:42,480 --> 00:33:44,100
exploitation

842
00:33:44,100 --> 00:33:46,019
but actually they can do so by

843
00:33:46,019 --> 00:33:48,360
manipulating various JavaScript input

844
00:33:48,360 --> 00:33:49,440
sources

845
00:33:49,440 --> 00:33:52,620
such as a window name and post messages

846
00:33:52,620 --> 00:33:55,500
and document refer

847
00:33:55,500 --> 00:33:59,279
in fact web attackers can forge requests

848
00:33:59,279 --> 00:34:01,440
using these sources if they control the

849
00:34:01,440 --> 00:34:04,620
malicious page and abuse browser apis to

850
00:34:04,620 --> 00:34:06,600
trick the vulnerable JavaScript of the

851
00:34:06,600 --> 00:34:10,879
target page to send HTTP requests

852
00:34:10,879 --> 00:34:13,379
for example we have the attacker

853
00:34:13,379 --> 00:34:16,320
controlled page here in uh whenever the

854
00:34:16,320 --> 00:34:18,719
victim visits this page a web attacker

855
00:34:18,719 --> 00:34:22,379
can use a window.open API to open the

856
00:34:22,379 --> 00:34:25,859
target URL in a new window send post

857
00:34:25,859 --> 00:34:28,859
messages to this open window uh set the

858
00:34:28,859 --> 00:34:30,960
the name of the open window via the

859
00:34:30,960 --> 00:34:34,020
window name API which can be set across

860
00:34:34,020 --> 00:34:37,280
Origins due to the same routine policy

861
00:34:37,280 --> 00:34:39,960
which essentially will allow the

862
00:34:39,960 --> 00:34:41,699
attacker to

863
00:34:41,699 --> 00:34:43,379
um you know instead of sending you the

864
00:34:43,379 --> 00:34:45,839
manager's link to to the to the victim

865
00:34:45,839 --> 00:34:48,060
the attacker can just you know create

866
00:34:48,060 --> 00:34:51,300
this attack attack page like the

867
00:34:51,300 --> 00:34:52,859
traditional C server types and then

868
00:34:52,859 --> 00:34:55,199
we'll have the same trade model uh as

869
00:34:55,199 --> 00:34:58,140
that of uh traditional system attacks

870
00:34:58,140 --> 00:35:00,500
for clients at CCF

871
00:35:00,500 --> 00:35:03,119
uh similarly a web attacker can also

872
00:35:03,119 --> 00:35:05,099
manipulate a document that refer

873
00:35:05,099 --> 00:35:07,200
leveraging the URL of the attacker

874
00:35:07,200 --> 00:35:09,900
controls web page

875
00:35:09,900 --> 00:35:12,300
then a web attacker can also add ad hoc

876
00:35:12,300 --> 00:35:17,160
data items in web storage or or Dom tree

877
00:35:17,160 --> 00:35:19,200
um and this is the case if the web

878
00:35:19,200 --> 00:35:22,020
application offers the functionality to

879
00:35:22,020 --> 00:35:24,300
do so for example via CrossFit requests

880
00:35:24,300 --> 00:35:26,880
or alternatively if the attacker has the

881
00:35:26,880 --> 00:35:28,380
knowledge of some injection

882
00:35:28,380 --> 00:35:30,660
vulnerability it can basically

883
00:35:30,660 --> 00:35:33,119
manipulate the values stored in these

884
00:35:33,119 --> 00:35:35,099
constructs

885
00:35:35,099 --> 00:35:37,560
so this essentially allows the attacker

886
00:35:37,560 --> 00:35:39,900
to implant the persistent client-side

887
00:35:39,900 --> 00:35:42,480
Caesar payload in the victims

888
00:35:42,480 --> 00:35:44,820
um and the victims browser by modifying

889
00:35:44,820 --> 00:35:46,560
uh web storage

890
00:35:46,560 --> 00:35:48,480
um which can lie dormant and exploit

891
00:35:48,480 --> 00:35:50,839
that later on to attack a victim

892
00:35:50,839 --> 00:35:53,880
finally a more powerful net Network

893
00:35:53,880 --> 00:35:56,579
level attacker can corrupt the Integrity

894
00:35:56,579 --> 00:35:58,740
of cookies that are processed by the

895
00:35:58,740 --> 00:36:03,619
application to to generate HTTP requests

896
00:36:03,619 --> 00:36:06,660
so coming to the evaluation our main

897
00:36:06,660 --> 00:36:09,000
questions uh where quantifying the

898
00:36:09,000 --> 00:36:10,740
prevalence of clients that deserve

899
00:36:10,740 --> 00:36:12,540
vulnerabilities in in web applications

900
00:36:12,540 --> 00:36:15,060
and identifying the degree of attacker

901
00:36:15,060 --> 00:36:18,180
control on unfortable requests and types

902
00:36:18,180 --> 00:36:20,700
of possible exploitations

903
00:36:20,700 --> 00:36:22,980
as such we evaluated our open source

904
00:36:22,980 --> 00:36:26,099
tool jar with 106 web applications from

905
00:36:26,099 --> 00:36:28,380
the vietnamic catalog accounting for

906
00:36:28,380 --> 00:36:31,260
over 228 million lines of JavaScript

907
00:36:31,260 --> 00:36:32,700
code

908
00:36:32,700 --> 00:36:35,940
and as a result we detected 12701

909
00:36:35,940 --> 00:36:38,579
forgeable client-side requests which

910
00:36:38,579 --> 00:36:41,820
affect 87 web applications now these

911
00:36:41,820 --> 00:36:43,560
requests can be forged by manipulating

912
00:36:43,560 --> 00:36:45,839
various JavaScript input sources such as

913
00:36:45,839 --> 00:36:48,960
URL Dom attributes document referrer and

914
00:36:48,960 --> 00:36:50,820
so on and so forth and as I showed in

915
00:36:50,820 --> 00:36:52,740
the previous slides unfortunately each

916
00:36:52,740 --> 00:36:54,359
of these input sources of course

917
00:36:54,359 --> 00:36:58,079
requires different attacker capabilities

918
00:36:58,079 --> 00:37:00,960
then we systematically look for a

919
00:37:00,960 --> 00:37:05,040
practical exploitations for a 516

920
00:37:05,040 --> 00:37:06,960
affordable requests which is a random

921
00:37:06,960 --> 00:37:09,839
subset of the the forgement requests we

922
00:37:09,839 --> 00:37:12,119
identified and the methodology for the

923
00:37:12,119 --> 00:37:14,040
selection of this request is that we

924
00:37:14,040 --> 00:37:15,720
first select all four double requests

925
00:37:15,720 --> 00:37:19,260
across all groups except for dom.reads

926
00:37:19,260 --> 00:37:21,599
category which are requests that that

927
00:37:21,599 --> 00:37:24,599
can be uh you know tainted by Dom

928
00:37:24,599 --> 00:37:26,700
attributes

929
00:37:26,700 --> 00:37:28,079
um considering the high number of

930
00:37:28,079 --> 00:37:30,780
affordable requests of this category

931
00:37:30,780 --> 00:37:32,000
which is 12

932
00:37:32,000 --> 00:37:35,700
268 requests so for dom.grade we

933
00:37:35,700 --> 00:37:38,040
randomly essentially uh randomly

934
00:37:38,040 --> 00:37:39,839
selected one request pair per web

935
00:37:39,839 --> 00:37:43,260
application and this resulted in 516

936
00:37:43,260 --> 00:37:46,140
um requests in total

937
00:37:46,140 --> 00:37:46,440
[Music]

938
00:37:46,440 --> 00:37:47,460
um

939
00:37:47,460 --> 00:37:50,400
as a result as a result of our analysis

940
00:37:50,400 --> 00:37:51,780
um we created the proof of concept

941
00:37:51,780 --> 00:37:55,859
exploit for uh 20340 requests of up 7

942
00:37:55,859 --> 00:37:59,099
web applications such as suit CRM Neos

943
00:37:59,099 --> 00:38:01,859
kibana modrics

944
00:38:01,859 --> 00:38:03,599
um resulting in um you know different

945
00:38:03,599 --> 00:38:05,579
consequences such as account takeover

946
00:38:05,579 --> 00:38:07,859
deleting user assets or execution of

947
00:38:07,859 --> 00:38:10,920
malicious queries uh to name only a few

948
00:38:10,920 --> 00:38:13,280
instances

949
00:38:13,280 --> 00:38:15,660
so let me show you a real world example

950
00:38:15,660 --> 00:38:17,400
of client-side seats are vulnerability

951
00:38:17,400 --> 00:38:20,339
affecting suit CRM

952
00:38:20,339 --> 00:38:22,920
uh in this develop the developer reads

953
00:38:22,920 --> 00:38:26,040
the value of a parameter named hxci lock

954
00:38:26,040 --> 00:38:29,700
in the URL fragment and use it verbatim

955
00:38:29,700 --> 00:38:31,800
as the endpoint to which an asynchronous

956
00:38:31,800 --> 00:38:34,500
request is sent so looking at the code

957
00:38:34,500 --> 00:38:37,440
there is a function called first load

958
00:38:37,440 --> 00:38:40,440
which is invoked by events and executed

959
00:38:40,440 --> 00:38:42,720
at page load when a particular node is

960
00:38:42,720 --> 00:38:45,020
ready in the Dom tree

961
00:38:45,020 --> 00:38:49,020
then the function first load uses the

962
00:38:49,020 --> 00:38:51,839
yui library Yahoo util library to read

963
00:38:51,839 --> 00:38:54,540
the hxui light parameter from the hash

964
00:38:54,540 --> 00:38:56,700
fragment which is passed to a function

965
00:38:56,700 --> 00:38:57,920
called

966
00:38:57,920 --> 00:39:02,520
suit.hxui dot go as a parameter

967
00:39:02,520 --> 00:39:04,260
and then the function go essentially

968
00:39:04,260 --> 00:39:06,720
uses its input parameter as a part of an

969
00:39:06,720 --> 00:39:08,880
asynchronous request and note that this

970
00:39:08,880 --> 00:39:11,520
request contains a valid CSF token which

971
00:39:11,520 --> 00:39:14,099
is embedded in a custom HTTP header

972
00:39:14,099 --> 00:39:17,520
called X signature for that request

973
00:39:17,520 --> 00:39:19,560
and this allows adversaries to forge

974
00:39:19,560 --> 00:39:21,780
authenticated requests to any sensitive

975
00:39:21,780 --> 00:39:24,900
endpoint of suture and corrupting the

976
00:39:24,900 --> 00:39:27,119
database Integrity for instance it was

977
00:39:27,119 --> 00:39:30,300
possible to delete user accounts or CRM

978
00:39:30,300 --> 00:39:33,780
models defined in suit CRM like contacts

979
00:39:33,780 --> 00:39:37,020
cases or tasks in the web application

980
00:39:37,020 --> 00:39:38,300
[Music]

981
00:39:38,300 --> 00:39:40,980
another similar example is is the

982
00:39:40,980 --> 00:39:43,320
vulnerability in in Cotton tea where the

983
00:39:43,320 --> 00:39:46,500
attacker can use the URL fragment to

984
00:39:46,500 --> 00:39:49,020
control both the endpoint and the HTTP

985
00:39:49,020 --> 00:39:52,020
method of the client-side request in

986
00:39:52,020 --> 00:39:54,060
particular the JavaScript code first

987
00:39:54,060 --> 00:39:56,400
passes the hash fragment to a function

988
00:39:56,400 --> 00:39:59,700
called Ajax load this function then

989
00:39:59,700 --> 00:40:02,280
processes the hash fragment value to

990
00:40:02,280 --> 00:40:05,040
determine the method and the endpoint of

991
00:40:05,040 --> 00:40:07,320
the asynchronous request so for example

992
00:40:07,320 --> 00:40:09,839
in the hash fragment we may have a sharp

993
00:40:09,839 --> 00:40:12,720
get or sharp post and then semicolon and

994
00:40:12,720 --> 00:40:16,380
then some key values that are used to

995
00:40:16,380 --> 00:40:18,540
essentially dynamically construct the

996
00:40:18,540 --> 00:40:19,920
endpoint to which the asynchronous

997
00:40:19,920 --> 00:40:22,859
requires this is sent

998
00:40:22,859 --> 00:40:25,020
um so sharp getter sharp post is

999
00:40:25,020 --> 00:40:27,920
specifically specify the the request

1000
00:40:27,920 --> 00:40:30,720
method so it's the get request or it's a

1001
00:40:30,720 --> 00:40:33,359
post request and the the key value is

1002
00:40:33,359 --> 00:40:36,119
after afterwards are essentially uh what

1003
00:40:36,119 --> 00:40:38,520
the attacker can use to specify the

1004
00:40:38,520 --> 00:40:41,460
endpoint uh um to which the request is

1005
00:40:41,460 --> 00:40:42,480
sent

1006
00:40:42,480 --> 00:40:44,280
so using this vulnerability it was

1007
00:40:44,280 --> 00:40:46,140
possible to manipulate administrative

1008
00:40:46,140 --> 00:40:49,380
configuration of cottonty uh for example

1009
00:40:49,380 --> 00:40:51,780
with this particular exploit one can

1010
00:40:51,780 --> 00:40:54,240
delete inactive user accounts older than

1011
00:40:54,240 --> 00:40:56,880
one minute which will probably affect

1012
00:40:56,880 --> 00:40:59,940
most of the user accounts in in

1013
00:40:59,940 --> 00:41:01,800
continuity since they were not active

1014
00:41:01,800 --> 00:41:04,280
within the last one minute

1015
00:41:04,280 --> 00:41:06,300
okay so we know that there are

1016
00:41:06,300 --> 00:41:08,400
affordable requests and these requests

1017
00:41:08,400 --> 00:41:10,740
are are prevalent but how bad is the

1018
00:41:10,740 --> 00:41:11,700
problem

1019
00:41:11,700 --> 00:41:13,920
to determine this we examine the degree

1020
00:41:13,920 --> 00:41:16,200
of manipulation an attacker can have on

1021
00:41:16,200 --> 00:41:18,180
the affordable request because the

1022
00:41:18,180 --> 00:41:20,280
exploitation landscape can be influenced

1023
00:41:20,280 --> 00:41:22,380
by such level of control

1024
00:41:22,380 --> 00:41:25,020
such be characterized HTTP requests via

1025
00:41:25,020 --> 00:41:27,599
templates where we encode and very

1026
00:41:27,599 --> 00:41:29,460
encode the type and number of fields

1027
00:41:29,460 --> 00:41:31,560
that can be manipulated as well as the

1028
00:41:31,560 --> 00:41:32,940
type of operation

1029
00:41:32,940 --> 00:41:36,359
by examining the randomly chosen 516

1030
00:41:36,359 --> 00:41:39,960
requests we identify 25 distinct request

1031
00:41:39,960 --> 00:41:42,180
templates and each template reflects the

1032
00:41:42,180 --> 00:41:44,040
level of their attackers controlled on

1033
00:41:44,040 --> 00:41:46,740
the outgoing HTTP request let me quickly

1034
00:41:46,740 --> 00:41:48,660
show you three examples of templates for

1035
00:41:48,660 --> 00:41:51,180
which we found an exploit

1036
00:41:51,180 --> 00:41:54,720
first in 185 requests an attacker can

1037
00:41:54,720 --> 00:41:57,060
manipulate any part of the domain path

1038
00:41:57,060 --> 00:41:59,280
and query parameters this means that an

1039
00:41:59,280 --> 00:42:01,380
attacker can forge requests toward other

1040
00:42:01,380 --> 00:42:03,180
domains to

1041
00:42:03,180 --> 00:42:05,880
then for 20 requests an attacker can

1042
00:42:05,880 --> 00:42:07,980
manipulate multiple parts of the pass

1043
00:42:07,980 --> 00:42:11,820
and a request body and finally 466

1044
00:42:11,820 --> 00:42:13,500
requests the attacker can only

1045
00:42:13,500 --> 00:42:15,540
manipulate a single part of the request

1046
00:42:15,540 --> 00:42:17,700
body but this level of control could be

1047
00:42:17,700 --> 00:42:20,760
enough to lead to an exploitation as we

1048
00:42:20,760 --> 00:42:23,220
saw during our evaluation now this was

1049
00:42:23,220 --> 00:42:25,160
only three examples of

1050
00:42:25,160 --> 00:42:27,599
request templates please refer to our

1051
00:42:27,599 --> 00:42:31,099
paper for more concrete cases

1052
00:42:31,099 --> 00:42:33,480
we also evaluated how different

1053
00:42:33,480 --> 00:42:35,880
components of our tool contribute to the

1054
00:42:35,880 --> 00:42:37,800
detection of client-side scissor

1055
00:42:37,800 --> 00:42:39,900
vulnerabilities and let me show you a

1056
00:42:39,900 --> 00:42:41,339
few takeaways

1057
00:42:41,339 --> 00:42:43,260
first when considering that the event

1058
00:42:43,260 --> 00:42:45,300
graph that we added the number of even

1059
00:42:45,300 --> 00:42:48,599
dispatch edges are around 6.5 million

1060
00:42:48,599 --> 00:42:51,780
compared to 7.1 million function called

1061
00:42:51,780 --> 00:42:54,420
edges this means that the ER ddg

1062
00:42:54,420 --> 00:42:55,980
representation enables the

1063
00:42:55,980 --> 00:42:59,460
identification of 89 edges transferring

1064
00:42:59,460 --> 00:43:01,619
the program and control flow

1065
00:43:01,619 --> 00:43:03,900
then when looking at the amount of code

1066
00:43:03,900 --> 00:43:07,380
we observe that uh 138 million of the

1067
00:43:07,380 --> 00:43:10,560
total 228 million lines of code are

1068
00:43:10,560 --> 00:43:13,140
libraries alone while the distinct or

1069
00:43:13,140 --> 00:43:17,160
unique Library code is only 412 K which

1070
00:43:17,160 --> 00:43:21,300
is around 335 times smaller accordingly

1071
00:43:21,300 --> 00:43:23,280
pre-processing the library code to

1072
00:43:23,280 --> 00:43:25,680
extract the symbolic model reduces by

1073
00:43:25,680 --> 00:43:28,200
more than half the effort required to

1074
00:43:28,200 --> 00:43:31,280
generate hpgs

1075
00:43:31,280 --> 00:43:33,960
finally to evaluate the impact of State

1076
00:43:33,960 --> 00:43:36,599
values and dynamic snapshotting we

1077
00:43:36,599 --> 00:43:38,700
repeated our evaluation with a variant

1078
00:43:38,700 --> 00:43:41,940
of a jaw not using Dynamic information

1079
00:43:41,940 --> 00:43:45,060
and we call that joystatic first in

1080
00:43:45,060 --> 00:43:47,700
terms of grass graph construction we

1081
00:43:47,700 --> 00:43:50,400
observe that jaw identifies a 10.7

1082
00:43:50,400 --> 00:43:53,579
million more nodes and 10 13.3 million

1083
00:43:53,579 --> 00:43:57,060
more edges meaning uh meaning that there

1084
00:43:57,060 --> 00:43:58,920
are some you know nodes and edges that

1085
00:43:58,920 --> 00:44:01,260
are missing when you only consider

1086
00:44:01,260 --> 00:44:02,940
static analysis without runtime

1087
00:44:02,940 --> 00:44:05,099
information which is because of dynamic

1088
00:44:05,099 --> 00:44:07,859
insertion of a script tasks then in

1089
00:44:07,859 --> 00:44:09,960
terms of vulnerability detection gel

1090
00:44:09,960 --> 00:44:13,800
identifies 840 more forgeable requests

1091
00:44:13,800 --> 00:44:17,400
in 14 web applications which is a seven

1092
00:44:17,400 --> 00:44:19,079
percent increase in the number of

1093
00:44:19,079 --> 00:44:22,020
vertigable requests and 19.1 percent

1094
00:44:22,020 --> 00:44:23,819
increase in the number of vulnerable

1095
00:44:23,819 --> 00:44:26,160
applications which will be false

1096
00:44:26,160 --> 00:44:28,440
negatives if if you only consider you

1097
00:44:28,440 --> 00:44:30,300
know static analysis without runtime

1098
00:44:30,300 --> 00:44:32,599
information

1099
00:44:33,300 --> 00:44:35,880
coming to the to the scalability and

1100
00:44:35,880 --> 00:44:38,040
performance metrics uh we locked our

1101
00:44:38,040 --> 00:44:40,140
processing times for throughput

1102
00:44:40,140 --> 00:44:42,660
evaluation of our tools and we observe

1103
00:44:42,660 --> 00:44:44,460
that the analysis time is in direct

1104
00:44:44,460 --> 00:44:46,560
correlation with the lines of code to be

1105
00:44:46,560 --> 00:44:48,720
analyzed and their complexity that is

1106
00:44:48,720 --> 00:44:50,819
the number of control and Dot of load

1107
00:44:50,819 --> 00:44:53,520
dependencies within the program

1108
00:44:53,520 --> 00:44:55,380
they observed that the least time

1109
00:44:55,380 --> 00:44:57,800
consuming operations are ASD and

1110
00:44:57,800 --> 00:44:59,819
intra-prestedural control flow graph

1111
00:44:59,819 --> 00:45:02,339
generation while the most time consuming

1112
00:45:02,339 --> 00:45:05,040
operation is a semantic type propagation

1113
00:45:05,040 --> 00:45:07,800
or simply the data flow analysis for the

1114
00:45:07,800 --> 00:45:10,020
tool all in all we can see that the

1115
00:45:10,020 --> 00:45:12,599
runtime could go to as high as around

1116
00:45:12,599 --> 00:45:16,940
400 seconds a per web page

1117
00:45:17,940 --> 00:45:20,339
so clients at c-surf is a critical track

1118
00:45:20,339 --> 00:45:22,260
to web applications and despite the

1119
00:45:22,260 --> 00:45:25,319
severity and prevalence as shown in this

1120
00:45:25,319 --> 00:45:27,619
Forex it can bypass state-of-the-art

1121
00:45:27,619 --> 00:45:30,900
defenses such as CSR tokens because

1122
00:45:30,900 --> 00:45:32,640
essentially the client-side code will

1123
00:45:32,640 --> 00:45:34,740
include those tokens in the request when

1124
00:45:34,740 --> 00:45:36,540
they generate the request so the obvious

1125
00:45:36,540 --> 00:45:38,160
question is how do we defend against

1126
00:45:38,160 --> 00:45:40,859
clients assistive attacks to answer this

1127
00:45:40,859 --> 00:45:42,660
question let's take a step back and have

1128
00:45:42,660 --> 00:45:45,240
a second look at client-side Caesar so

1129
00:45:45,240 --> 00:45:47,339
clients as this have originate when the

1130
00:45:47,339 --> 00:45:48,900
JavaScript program uses a Target

1131
00:45:48,900 --> 00:45:51,599
controllable inputs say your hash

1132
00:45:51,599 --> 00:45:53,819
fragment to send asynchronous HTTP

1133
00:45:53,819 --> 00:45:56,400
request so there is this data flow from

1134
00:45:56,400 --> 00:45:58,619
attacker controllable data to a request

1135
00:45:58,619 --> 00:46:00,780
sending instruction and the problem is

1136
00:46:00,780 --> 00:46:03,000
is the trust boundary meaning that there

1137
00:46:03,000 --> 00:46:05,460
is a misplaced trust in unsafe input

1138
00:46:05,460 --> 00:46:07,200
component which is similar to other

1139
00:46:07,200 --> 00:46:08,819
tainted style input validation

1140
00:46:08,819 --> 00:46:10,680
vulnerabilities like client-side

1141
00:46:10,680 --> 00:46:12,420
cross-sided scripting

1142
00:46:12,420 --> 00:46:15,060
therefore the first mitigation strategy

1143
00:46:15,060 --> 00:46:17,099
is essentially to have independent

1144
00:46:17,099 --> 00:46:19,319
requests that is avoiding the use of

1145
00:46:19,319 --> 00:46:21,500
JavaScript for the generation of

1146
00:46:21,500 --> 00:46:24,180
outgoing HTTP requests

1147
00:46:24,180 --> 00:46:26,760
instead we can have a predefined list of

1148
00:46:26,760 --> 00:46:28,980
safe request data for example request

1149
00:46:28,980 --> 00:46:30,480
endpoints and then have a switch

1150
00:46:30,480 --> 00:46:33,119
parameter in the input for example in

1151
00:46:33,119 --> 00:46:35,700
the URL to select an option from this

1152
00:46:35,700 --> 00:46:37,160
safe list

1153
00:46:37,160 --> 00:46:39,839
the second solution is input

1154
00:46:39,839 --> 00:46:42,060
sanitization which essentially validates

1155
00:46:42,060 --> 00:46:44,579
JavaScript input sources before using

1156
00:46:44,579 --> 00:46:46,560
them in security sensitive HTTP requests

1157
00:46:46,560 --> 00:46:49,500
however input validation is in general a

1158
00:46:49,500 --> 00:46:51,540
challenging error-prone task so maybe a

1159
00:46:51,540 --> 00:46:53,160
more robust solution is to have

1160
00:46:53,160 --> 00:46:55,980
pre-fined you know router structures and

1161
00:46:55,980 --> 00:46:58,980
process URL parameters Bitcoin side you

1162
00:46:58,980 --> 00:47:01,200
know routers such as the ones offered by

1163
00:47:01,200 --> 00:47:02,940
modern libraries like backbone or

1164
00:47:02,940 --> 00:47:05,040
angular but again this will work only

1165
00:47:05,040 --> 00:47:08,460
for you know URL if you know the

1166
00:47:08,460 --> 00:47:10,440
attackers contained other input sources

1167
00:47:10,440 --> 00:47:12,660
say post messages document referral

1168
00:47:12,660 --> 00:47:14,400
window name then you know having

1169
00:47:14,400 --> 00:47:16,680
predefined rooted structures via modern

1170
00:47:16,680 --> 00:47:20,359
clients and libraries do not help

1171
00:47:20,599 --> 00:47:23,579
and last but not least a jaw can be used

1172
00:47:23,579 --> 00:47:24,780
to detect client-side system

1173
00:47:24,780 --> 00:47:27,300
vulnerabilities as as we demonstrated in

1174
00:47:27,300 --> 00:47:29,280
this presentation but actually you can

1175
00:47:29,280 --> 00:47:31,440
use it to do more than that in

1176
00:47:31,440 --> 00:47:33,720
particular it is possible to Define your

1177
00:47:33,720 --> 00:47:36,000
own semantic types capturing different

1178
00:47:36,000 --> 00:47:39,180
types of sources and things conduct data

1179
00:47:39,180 --> 00:47:41,460
flow propagation and ultimately detect

1180
00:47:41,460 --> 00:47:43,319
other painted style vulnerability

1181
00:47:43,319 --> 00:47:46,319
classes such as client-side exercise so

1182
00:47:46,319 --> 00:47:48,480
it is very easy and straightforward to

1183
00:47:48,480 --> 00:47:50,460
extend your with your own semantic types

1184
00:47:50,460 --> 00:47:52,440
and you just need to you know Define a

1185
00:47:52,440 --> 00:47:54,480
mapping from JavaScript language tokens

1186
00:47:54,480 --> 00:47:56,579
to source and think of the vulnerability

1187
00:47:56,579 --> 00:47:58,980
you have in mind for example eval as a

1188
00:47:58,980 --> 00:48:02,359
thing for xss

1189
00:48:02,599 --> 00:48:05,700
so summing up in this talk we first

1190
00:48:05,700 --> 00:48:08,280
presented the first systematic study of

1191
00:48:08,280 --> 00:48:10,440
clients at c-surf which are a new breed

1192
00:48:10,440 --> 00:48:12,180
of C sub vulnerabilities affecting

1193
00:48:12,180 --> 00:48:14,400
monitor applications that can bypass

1194
00:48:14,400 --> 00:48:16,920
traditional seats of defenses then to

1195
00:48:16,920 --> 00:48:19,140
detect anesthetic lines at c-serv the

1196
00:48:19,140 --> 00:48:21,240
proposed jaw which is a hybrid scalable

1197
00:48:21,240 --> 00:48:23,280
solution that instantiates a property

1198
00:48:23,280 --> 00:48:25,680
graph and then traverses this graph to

1199
00:48:25,680 --> 00:48:28,020
identify vulnerabilities

1200
00:48:28,020 --> 00:48:31,020
then we evaluate a job with over 228

1201
00:48:31,020 --> 00:48:33,300
million lines of JavaScript code in 106

1202
00:48:33,300 --> 00:48:35,280
popular applications from the epidemic

1203
00:48:35,280 --> 00:48:37,380
catalog and we were able to identify

1204
00:48:37,380 --> 00:48:39,000
twelve thousand seven hundred one

1205
00:48:39,000 --> 00:48:41,040
Footwear requests affecting 87

1206
00:48:41,040 --> 00:48:43,440
applications out of which we created the

1207
00:48:43,440 --> 00:48:45,900
proof of concept exploits for 203

1208
00:48:45,900 --> 00:48:49,200
requests of seven applications

1209
00:48:49,200 --> 00:48:51,180
finally we discussed a few mitigation

1210
00:48:51,180 --> 00:48:53,280
techniques against clients at c-serv

1211
00:48:53,280 --> 00:48:55,440
such as input validation and independent

1212
00:48:55,440 --> 00:48:57,780
requests and with this I would like to

1213
00:48:57,780 --> 00:49:00,060
conclude my talk so Joe is open source

1214
00:49:00,060 --> 00:49:02,400
and publicly accessible on GitHub so I

1215
00:49:02,400 --> 00:49:03,780
encourage you to have a look and play

1216
00:49:03,780 --> 00:49:05,640
out with it thanks a lot for your

1217
00:49:05,640 --> 00:49:07,140
attention and if you have any questions

1218
00:49:07,140 --> 00:49:10,520
please don't hesitate to ask

1219
00:49:11,700 --> 00:49:14,400
thank you Sohail for the attendees over

1220
00:49:14,400 --> 00:49:17,819
here please use the Hua q and a panel to

1221
00:49:17,819 --> 00:49:21,599
ask questions uh dropping on the first

1222
00:49:21,599 --> 00:49:24,079
question so

1223
00:49:24,079 --> 00:49:26,940
are the new countermeasures like same

1224
00:49:26,940 --> 00:49:29,280
side cookies like the same side cookie

1225
00:49:29,280 --> 00:49:31,500
attribute mitigate client-side csrf

1226
00:49:31,500 --> 00:49:32,160
attack

1227
00:49:32,160 --> 00:49:34,920
that's actually a great question so um

1228
00:49:34,920 --> 00:49:37,319
by default now we have a same study

1229
00:49:37,319 --> 00:49:39,119
called lacks as the default sensor

1230
00:49:39,119 --> 00:49:41,400
policy in chromium-based pauses as June

1231
00:49:41,400 --> 00:49:44,940
and um so because of this window.open

1232
00:49:44,940 --> 00:49:47,460
API that we have which does not actually

1233
00:49:47,460 --> 00:49:50,040
cover uh you know these Crosshair

1234
00:49:50,040 --> 00:49:52,800
request contacts attackers can still you

1235
00:49:52,800 --> 00:49:56,280
know amount csrf attacks so same side is

1236
00:49:56,280 --> 00:49:57,720
while it is effective against the

1237
00:49:57,720 --> 00:49:59,760
traditional scissor it is not effective

1238
00:49:59,760 --> 00:50:00,900
against

1239
00:50:00,900 --> 00:50:03,000
um clients that you serve even if you

1240
00:50:03,000 --> 00:50:04,880
have same side it's called as strict

1241
00:50:04,880 --> 00:50:08,700
while this will blocked window.open

1242
00:50:08,700 --> 00:50:10,500
um you know attackers can uh you know

1243
00:50:10,500 --> 00:50:12,960
just share the links with victims and if

1244
00:50:12,960 --> 00:50:15,119
the victim just copy and paste the link

1245
00:50:15,119 --> 00:50:18,000
in to their browser because it's a top

1246
00:50:18,000 --> 00:50:19,740
level navigation this will not be

1247
00:50:19,740 --> 00:50:23,040
blocked by uh same side so yeah the

1248
00:50:23,040 --> 00:50:25,740
short answer is no same side cookies but

1249
00:50:25,740 --> 00:50:27,839
not essentially prevent client-side

1250
00:50:27,839 --> 00:50:30,540
system attacks

1251
00:50:30,540 --> 00:50:34,380
got it thank you uh and moving on to the

1252
00:50:34,380 --> 00:50:37,020
next question like uh are there any

1253
00:50:37,020 --> 00:50:38,940
space based on your research are there

1254
00:50:38,940 --> 00:50:40,560
any specific type of like web

1255
00:50:40,560 --> 00:50:43,200
applications or JavaScript Frameworks

1256
00:50:43,200 --> 00:50:46,140
where you found that client-side csrf or

1257
00:50:46,140 --> 00:50:49,380
more preliment on like yeah yeah exactly

1258
00:50:49,380 --> 00:50:51,300
that's again a great question so uh

1259
00:50:51,300 --> 00:50:54,300
indeed um we observed that uh clients

1260
00:50:54,300 --> 00:50:55,800
has deserve vulnerabilities tend to

1261
00:50:55,800 --> 00:50:57,920
happen more in single page applications

1262
00:50:57,920 --> 00:51:01,619
uh who you know tend to use you know URL

1263
00:51:01,619 --> 00:51:03,720
parameters like the hash fragment to you

1264
00:51:03,720 --> 00:51:05,819
know navigate between Pages or generate

1265
00:51:05,819 --> 00:51:08,640
requests so a significant fraction of

1266
00:51:08,640 --> 00:51:10,140
the vulnerabilities

1267
00:51:10,140 --> 00:51:13,380
um you know were noticeably belong to uh

1268
00:51:13,380 --> 00:51:15,540
you know single page applications Spas

1269
00:51:15,540 --> 00:51:18,020
essentially

1270
00:51:18,780 --> 00:51:21,240
good

1271
00:51:21,240 --> 00:51:23,520
uh

1272
00:51:23,520 --> 00:51:26,280
another question is about the job tool

1273
00:51:26,280 --> 00:51:29,460
so what's the difference between the jaw

1274
00:51:29,460 --> 00:51:32,760
Tool uh other than other JavaScript

1275
00:51:32,760 --> 00:51:36,059
analysis tool like uh GitHub Squad ql

1276
00:51:36,059 --> 00:51:38,760
queries or John so how is it different

1277
00:51:38,760 --> 00:51:40,859
from the tool and like what are its

1278
00:51:40,859 --> 00:51:43,200
advantages over the other yeah that's

1279
00:51:43,200 --> 00:51:45,420
also again a good question so basically

1280
00:51:45,420 --> 00:51:48,540
in job we tend to model clients at

1281
00:51:48,540 --> 00:51:50,640
JavaScript code as opposed to JavaScript

1282
00:51:50,640 --> 00:51:54,119
in the sense of node.js so um tools like

1283
00:51:54,119 --> 00:51:56,339
like yarn or code QR you essentially

1284
00:51:56,339 --> 00:51:58,920
give it as an input Javascript file

1285
00:51:58,920 --> 00:52:01,619
which is um you know you have single

1286
00:52:01,619 --> 00:52:03,240
Javascript file

1287
00:52:03,240 --> 00:52:05,940
um and you don't have any Dom 3 as you

1288
00:52:05,940 --> 00:52:07,079
have like

1289
00:52:07,079 --> 00:52:09,660
um in a web page you don't have any HTML

1290
00:52:09,660 --> 00:52:12,900
code it's only the JavaScript while in

1291
00:52:12,900 --> 00:52:15,720
jaw we essentially model the client site

1292
00:52:15,720 --> 00:52:17,400
code and this client side code can

1293
00:52:17,400 --> 00:52:20,460
include the HTML down three uh you know

1294
00:52:20,460 --> 00:52:22,980
the state values meaning all the things

1295
00:52:22,980 --> 00:52:24,720
that browser will include like cookies

1296
00:52:24,720 --> 00:52:27,780
local storage Etc and the JavaScript

1297
00:52:27,780 --> 00:52:29,819
code which you know can interact with

1298
00:52:29,819 --> 00:52:32,220
this you know dynamic execution

1299
00:52:32,220 --> 00:52:34,759
environment

1300
00:52:36,180 --> 00:52:38,460
that makes sense yeah

1301
00:52:38,460 --> 00:52:41,579
um uh so another question is like what

1302
00:52:41,579 --> 00:52:44,099
do you think about like identifying the

1303
00:52:44,099 --> 00:52:46,319
vulnerabilities more likely to be on a

1304
00:52:46,319 --> 00:52:48,480
static analysis or more on towards a

1305
00:52:48,480 --> 00:52:51,660
dynamic analysis like a vipd assessment

1306
00:52:51,660 --> 00:52:54,300
yeah that's that's also a great question

1307
00:52:54,300 --> 00:52:56,940
so I think um static analysis could be

1308
00:52:56,940 --> 00:52:59,700
used as an oracle to you know identify

1309
00:52:59,700 --> 00:53:01,740
suspicious you know cases and then they

1310
00:53:01,740 --> 00:53:04,079
can use Dynamic analysis to to improve

1311
00:53:04,079 --> 00:53:07,260
the accuracy or the detection power of

1312
00:53:07,260 --> 00:53:09,960
static analysis somehow there are you

1313
00:53:09,960 --> 00:53:11,640
know there are different you know things

1314
00:53:11,640 --> 00:53:13,140
that you can do you can do Blended

1315
00:53:13,140 --> 00:53:15,240
analysis which essentially means that

1316
00:53:15,240 --> 00:53:17,579
you do a static analysis but for a

1317
00:53:17,579 --> 00:53:19,380
particular concrete executions of the

1318
00:53:19,380 --> 00:53:22,559
program so you replace you know uh

1319
00:53:22,559 --> 00:53:24,420
certain you know constructs in in the

1320
00:53:24,420 --> 00:53:27,180
program like the value of closures or uh

1321
00:53:27,180 --> 00:53:29,339
you know the state values with their

1322
00:53:29,339 --> 00:53:31,559
concrete uh you know values that you see

1323
00:53:31,559 --> 00:53:34,440
in runtime and then you do uh you know

1324
00:53:34,440 --> 00:53:36,660
static analysis for each of those

1325
00:53:36,660 --> 00:53:38,700
execution so this is known as Blended

1326
00:53:38,700 --> 00:53:41,400
analysis now similarly you can use you

1327
00:53:41,400 --> 00:53:43,319
know these State values that you see at

1328
00:53:43,319 --> 00:53:45,420
runtime to improve the static analysis

1329
00:53:45,420 --> 00:53:47,040
so I would say

1330
00:53:47,040 --> 00:53:50,099
um the short answer is we need to use

1331
00:53:50,099 --> 00:53:52,920
both to basically obtain the highest

1332
00:53:52,920 --> 00:53:55,760
precision

1333
00:53:55,920 --> 00:53:57,240
perfect

1334
00:53:57,240 --> 00:54:01,079
uh that brings to the end of our

1335
00:54:01,079 --> 00:54:03,960
question list uh thank you so health for

1336
00:54:03,960 --> 00:54:05,520
this great presentation and wonderful

1337
00:54:05,520 --> 00:54:07,380
session this really gave a lot of

1338
00:54:07,380 --> 00:54:09,540
insights and knowledge on clients at

1339
00:54:09,540 --> 00:54:12,119
csrf and if you have any more questions

1340
00:54:12,119 --> 00:54:13,680
feel free to contact him on the over

1341
00:54:13,680 --> 00:54:15,359
platform

1342
00:54:15,359 --> 00:54:18,540
thank you thanks a lot yeah have a good

1343
00:54:18,540 --> 00:54:20,700
evening everybody and if you have any

1344
00:54:20,700 --> 00:54:22,559
questions please don't hesitate to

1345
00:54:22,559 --> 00:54:25,460
contact me thanks

