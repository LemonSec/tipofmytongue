1
00:00:00,290 --> 00:00:06,270
hello everyone thanks for coming I'm

2
00:00:03,840 --> 00:00:09,240
just off the damage this is Mike Samuel

3
00:00:06,270 --> 00:00:11,489
we work at Google in the hardening team

4
00:00:09,240 --> 00:00:13,110
which the mission of which is to make

5
00:00:11,490 --> 00:00:15,660
writing cold hearts

6
00:00:13,110 --> 00:00:19,080
well actually making writing vulnerable

7
00:00:15,660 --> 00:00:21,210
cold heart or making it the default case

8
00:00:19,080 --> 00:00:24,389
or the easy case to write the secure one

9
00:00:21,210 --> 00:00:25,680
so it's a pretty nice waste mission and

10
00:00:24,390 --> 00:00:27,750
we are doing that for a couple of years

11
00:00:25,680 --> 00:00:29,990
now so we have quite a bit of experience

12
00:00:27,750 --> 00:00:33,540
of trying to secure large code bases

13
00:00:29,990 --> 00:00:38,610
that with a relatively small amount of

14
00:00:33,540 --> 00:00:41,399
security people today we want to talk to

15
00:00:38,610 --> 00:00:44,820
you about one of the most prevalent

16
00:00:41,399 --> 00:00:47,700
problems that we have for Google

17
00:00:44,820 --> 00:00:52,079
software at least in the terms of web

18
00:00:47,700 --> 00:00:54,750
security which is dom-based xss we were

19
00:00:52,079 --> 00:00:56,910
thinking long for how to protect our

20
00:00:54,750 --> 00:00:59,760
applications against XSS in general and

21
00:00:56,910 --> 00:01:01,468
Dom XSS in specific as it suddenly

22
00:00:59,760 --> 00:01:04,679
becomes the most prevalent variant of it

23
00:01:01,469 --> 00:01:09,000
or most difficult to address and we

24
00:01:04,680 --> 00:01:11,420
think we have a solution that seems to

25
00:01:09,000 --> 00:01:14,280
be good enough and worthy of

26
00:01:11,420 --> 00:01:16,560
implementation and adoption in not just

27
00:01:14,280 --> 00:01:18,210
Google software but in the but will web

28
00:01:16,560 --> 00:01:20,220
platform in the browsers in general and

29
00:01:18,210 --> 00:01:22,380
this is exactly what we will talk to you

30
00:01:20,220 --> 00:01:25,679
about and this it's called trusted types

31
00:01:22,380 --> 00:01:26,939
and with that I will hand over to Mike

32
00:01:25,680 --> 00:01:29,220
to describe you a little bit of the

33
00:01:26,939 --> 00:01:31,529
solution later on I will present a demo

34
00:01:29,220 --> 00:01:34,500
because you know a picture is worth a

35
00:01:31,530 --> 00:01:36,570
thousand words a demo is usually a

36
00:01:34,500 --> 00:01:39,320
recite for disaster especially the life

37
00:01:36,570 --> 00:01:42,320
demo so let's try that

38
00:01:39,320 --> 00:01:42,320
Thanks

39
00:01:45,460 --> 00:01:51,470
next

40
00:01:48,450 --> 00:01:51,470
yeah yeah

41
00:01:54,520 --> 00:02:01,530
as you can see yeah it's always said

42
00:01:57,010 --> 00:02:01,530
that I need it ah this was trying

43
00:02:04,600 --> 00:02:13,000
yes wonderful so Dom XSS is actually if

44
00:02:10,280 --> 00:02:16,730
you saw Lucas's talk earlier it's

45
00:02:13,000 --> 00:02:20,540
Google's single largest security problem

46
00:02:16,730 --> 00:02:22,760
right now and the reasons are twofold

47
00:02:20,540 --> 00:02:26,390
one it's easy to introduce it's very

48
00:02:22,760 --> 00:02:29,810
easy for a developer to write an

49
00:02:26,390 --> 00:02:31,640
assignment to innerhtml such that the

50
00:02:29,810 --> 00:02:33,920
value assigned is controlled by an

51
00:02:31,640 --> 00:02:36,140
attacker and it's really hard to detect

52
00:02:33,920 --> 00:02:38,569
automated scanners and code reviewers

53
00:02:36,140 --> 00:02:41,599
don't do well when that assignment to

54
00:02:38,569 --> 00:02:45,890
inner HTML happens deep inside the guts

55
00:02:41,599 --> 00:02:49,940
of some client-side framework and so

56
00:02:45,890 --> 00:02:52,730
we'd like a comprehensive solution these

57
00:02:49,940 --> 00:02:54,620
are our goals I hope to convince you

58
00:02:52,730 --> 00:02:56,810
that we can actually achieve these so

59
00:02:54,620 --> 00:02:59,000
we'd like to fix the root cause the root

60
00:02:56,810 --> 00:03:01,730
cause is that we have these browser

61
00:02:59,000 --> 00:03:04,970
api's and when an attacker controlled

62
00:03:01,730 --> 00:03:10,548
string reaches them bad things happen we

63
00:03:04,970 --> 00:03:13,549
want to help developers so you know we

64
00:03:10,549 --> 00:03:15,410
need to guide developers towards safe

65
00:03:13,549 --> 00:03:18,769
abstractions in a way from ad hoc

66
00:03:15,410 --> 00:03:22,310
methods for creating strings of HTML CSS

67
00:03:18,769 --> 00:03:25,130
and other micro languages that that

68
00:03:22,310 --> 00:03:28,100
these don api is consumed and we need to

69
00:03:25,130 --> 00:03:30,769
simplify reviews there's simply no way a

70
00:03:28,100 --> 00:03:32,840
small security team is going to be able

71
00:03:30,769 --> 00:03:36,560
to review all the changes made by a

72
00:03:32,840 --> 00:03:42,440
large group of developers so we need to

73
00:03:36,560 --> 00:03:44,739
we need a mechanism that makes thank you

74
00:03:42,440 --> 00:03:47,269
we need a mechanism that makes

75
00:03:44,739 --> 00:03:49,700
interactions between developers and

76
00:03:47,269 --> 00:03:52,430
security specialists efficient and

77
00:03:49,700 --> 00:03:54,980
effective and there's a huge install

78
00:03:52,430 --> 00:03:56,540
base of applications out there so we

79
00:03:54,980 --> 00:04:01,638
need something that works for existing

80
00:03:56,540 --> 00:04:04,010
applications so I'd like to you know

81
00:04:01,639 --> 00:04:08,060
we've been doing this for server-side

82
00:04:04,010 --> 00:04:10,880
XSS for a while and I'm going to kind of

83
00:04:08,060 --> 00:04:12,840
walk you through the claim that we want

84
00:04:10,880 --> 00:04:16,790
to be to build confidence

85
00:04:12,840 --> 00:04:18,798
so we're secure against Dom XSS because

86
00:04:16,790 --> 00:04:21,959
reasons

87
00:04:18,798 --> 00:04:25,409
so what trusted types gives you is if

88
00:04:21,959 --> 00:04:27,600
you've got a if the code is running on a

89
00:04:25,410 --> 00:04:29,580
browser that supports a trusted types or

90
00:04:27,600 --> 00:04:33,270
you've loaded the trust of types

91
00:04:29,580 --> 00:04:37,050
polyfill then you can opt into trusted

92
00:04:33,270 --> 00:04:41,609
types by tweaking a CSP header so you

93
00:04:37,050 --> 00:04:43,650
can see here that the content security

94
00:04:41,610 --> 00:04:47,669
policy has ur header has this new Clause

95
00:04:43,650 --> 00:04:49,888
which is trusted types if all you do to

96
00:04:47,669 --> 00:04:51,870
your application is enable trusted types

97
00:04:49,889 --> 00:04:55,160
you're gonna break your application but

98
00:04:51,870 --> 00:04:58,889
it's instructive to see how it breaks so

99
00:04:55,160 --> 00:05:02,790
with trusted types enabled Dom syncs

100
00:04:58,889 --> 00:05:07,650
only accept trusted values so a Dom sink

101
00:05:02,790 --> 00:05:10,320
is any browser API like innerhtml

102
00:05:07,650 --> 00:05:13,590
or source that we need to keep attacker

103
00:05:10,320 --> 00:05:15,750
controlled strings away from and trusted

104
00:05:13,590 --> 00:05:18,919
types guards these sinks which means

105
00:05:15,750 --> 00:05:21,450
that you can't assign untrusted values

106
00:05:18,919 --> 00:05:25,020
to these sinks when trust types is

107
00:05:21,450 --> 00:05:28,289
enabled so with trusted types enabled

108
00:05:25,020 --> 00:05:30,539
this assignment inner HTML fails the

109
00:05:28,289 --> 00:05:33,870
payload string simply doesn't get

110
00:05:30,539 --> 00:05:35,760
assigned down here you can see that I'm

111
00:05:33,870 --> 00:05:40,320
using something called a trust types

112
00:05:35,760 --> 00:05:44,039
policy to create a trusted HTML value

113
00:05:40,320 --> 00:05:47,370
which can be assigned so this may seem

114
00:05:44,039 --> 00:05:49,349
like a trivial change in semantics but

115
00:05:47,370 --> 00:05:54,570
it actually has far-reaching effects

116
00:05:49,350 --> 00:05:57,060
that I'll explain first though there's

117
00:05:54,570 --> 00:06:01,590
an awful lot of sinks more than sixty

118
00:05:57,060 --> 00:06:05,130
and so we created a number of different

119
00:06:01,590 --> 00:06:07,799
trusted types so trusted HTML is for

120
00:06:05,130 --> 00:06:10,979
sinks that takes strings of HTML like

121
00:06:07,800 --> 00:06:15,270
inner HTML trusted script is for

122
00:06:10,979 --> 00:06:19,800
JavaScript a trusted script URL is for a

123
00:06:15,270 --> 00:06:22,770
URL that when loaded might load code

124
00:06:19,800 --> 00:06:25,229
into the application so a source script

125
00:06:22,770 --> 00:06:26,030
for example and trusted URL is for other

126
00:06:25,229 --> 00:06:29,360
URLs

127
00:06:26,030 --> 00:06:35,000
link targets images video audio that

128
00:06:29,360 --> 00:06:36,980
kind of thing so if the only thing we

129
00:06:35,000 --> 00:06:39,800
did was prevent string assignment that

130
00:06:36,980 --> 00:06:42,050
wouldn't help much some JavaScript

131
00:06:39,800 --> 00:06:44,810
developer with a deadline is simply

132
00:06:42,050 --> 00:06:48,530
going to create a policy and use it to

133
00:06:44,810 --> 00:06:50,300
unwisely mark strings as trusted so the

134
00:06:48,530 --> 00:06:53,950
first thing we realized we needed to do

135
00:06:50,300 --> 00:07:01,550
was we need to restrict policy creation

136
00:06:53,950 --> 00:07:05,360
so you can see here my header trusted

137
00:07:01,550 --> 00:07:08,630
types is followed by this name HTML

138
00:07:05,360 --> 00:07:11,120
sanitizer this is actually a policy name

139
00:07:08,630 --> 00:07:16,219
and so following trusted types is a

140
00:07:11,120 --> 00:07:20,270
policy whitelist if you control the this

141
00:07:16,220 --> 00:07:22,700
portion of the CSP header you control

142
00:07:20,270 --> 00:07:25,719
which policies can be created and since

143
00:07:22,700 --> 00:07:30,140
all trusted values are created by

144
00:07:25,720 --> 00:07:32,600
policies you effectively control which

145
00:07:30,140 --> 00:07:34,370
trusted values can be created sit down

146
00:07:32,600 --> 00:07:39,530
here in the JavaScript you can see we're

147
00:07:34,370 --> 00:07:42,710
defining the policy so this policy can

148
00:07:39,530 --> 00:07:45,200
be used to create trusted HTML but the

149
00:07:42,710 --> 00:07:49,400
HTML that it produces is always going to

150
00:07:45,200 --> 00:07:53,560
be the result of an HTML sanitizer so if

151
00:07:49,400 --> 00:07:58,510
the HTML sanitizer will have removed any

152
00:07:53,560 --> 00:08:01,040
powerful elements or attributes before

153
00:07:58,510 --> 00:08:06,950
before they become the content of this

154
00:08:01,040 --> 00:08:10,130
trusted HTML value and so maybe there's

155
00:08:06,950 --> 00:08:11,630
some code deep in a dependency of a

156
00:08:10,130 --> 00:08:14,510
dependency of a dependency that thinks

157
00:08:11,630 --> 00:08:17,210
it's a good idea to convert markdown to

158
00:08:14,510 --> 00:08:20,900
HTML without sanitizing anything so

159
00:08:17,210 --> 00:08:23,120
since this name sketchy markdown to HTML

160
00:08:20,900 --> 00:08:26,000
does not appear in our policy whitelist

161
00:08:23,120 --> 00:08:28,730
this policy will never be created and so

162
00:08:26,000 --> 00:08:31,060
will not be a source of a trusted HTML

163
00:08:28,730 --> 00:08:31,060
values

164
00:08:31,240 --> 00:08:39,549
and what this means is so policy code is

165
00:08:37,780 --> 00:08:42,159
actually the wink weakest link in this

166
00:08:39,549 --> 00:08:46,150
whole scheme policy code needs to be

167
00:08:42,159 --> 00:08:48,339
reviewed thoroughly if you unwisely mark

168
00:08:46,150 --> 00:08:51,189
values is trusted then they can make it

169
00:08:48,340 --> 00:08:55,420
through to sinks and mayhem can ensue

170
00:08:51,190 --> 00:08:57,310
so but this is a much better situation

171
00:08:55,420 --> 00:09:00,160
than having to review all the policy

172
00:08:57,310 --> 00:09:02,109
code the all of the application code

173
00:09:00,160 --> 00:09:04,240
produced by a large large application

174
00:09:02,110 --> 00:09:08,440
development group so once you've

175
00:09:04,240 --> 00:09:11,170
convinced yourself that the part that

176
00:09:08,440 --> 00:09:15,210
the code that effects the results of a

177
00:09:11,170 --> 00:09:18,219
policy is legit your job is done you

178
00:09:15,210 --> 00:09:20,140
this allows you by controlling the white

179
00:09:18,220 --> 00:09:22,120
list you can bound the amount of code

180
00:09:20,140 --> 00:09:30,000
that you as a security practitioner need

181
00:09:22,120 --> 00:09:32,770
to review to be safe against Dom XSS and

182
00:09:30,000 --> 00:09:35,620
what we found we've been doing this for

183
00:09:32,770 --> 00:09:39,670
about six years now for server-side XSS

184
00:09:35,620 --> 00:09:41,950
and what we found is that us a small

185
00:09:39,670 --> 00:09:44,770
number of tools account for the vast

186
00:09:41,950 --> 00:09:47,470
majority of policy code so for example

187
00:09:44,770 --> 00:09:50,620
strict template system automatically

188
00:09:47,470 --> 00:09:52,900
chooses escapers for untrusted values so

189
00:09:50,620 --> 00:09:58,810
the less than script greater than is

190
00:09:52,900 --> 00:10:01,840
escaped when it's interpolated a strict

191
00:09:58,810 --> 00:10:05,890
template system is a good producer of

192
00:10:01,840 --> 00:10:08,680
HTML values and it could in fact also be

193
00:10:05,890 --> 00:10:12,460
a consumer so if an interpolation was a

194
00:10:08,680 --> 00:10:15,969
trusted HTML value then it can avoid RIA

195
00:10:12,460 --> 00:10:18,310
scaping that sanitizers are another

196
00:10:15,970 --> 00:10:20,650
example of a tool a sanitizer takes in

197
00:10:18,310 --> 00:10:22,719
an in an untrusted string in a language

198
00:10:20,650 --> 00:10:25,660
and produces a string in that language

199
00:10:22,720 --> 00:10:29,290
without high privileged instructions so

200
00:10:25,660 --> 00:10:33,850
it's another example of a good producer

201
00:10:29,290 --> 00:10:37,180
of trusted values and builder api's can

202
00:10:33,850 --> 00:10:41,560
also be good for good ways to create

203
00:10:37,180 --> 00:10:43,550
trusted values and and these tools like

204
00:10:41,560 --> 00:10:46,579
these account for the vast majority

205
00:10:43,550 --> 00:10:49,490
of policy code what this means in the

206
00:10:46,580 --> 00:10:51,140
end is that for most projects you don't

207
00:10:49,490 --> 00:10:59,420
actually end up reviewing custom policy

208
00:10:51,140 --> 00:11:02,600
code and since developers have to create

209
00:10:59,420 --> 00:11:04,849
trusted HTML values to use within their

210
00:11:02,600 --> 00:11:07,940
HTML or trusted URLs to use as link

211
00:11:04,850 --> 00:11:11,060
targets and the like this this guides

212
00:11:07,940 --> 00:11:13,100
them to the trusted types kind of guides

213
00:11:11,060 --> 00:11:20,390
them towards secure abstractions and

214
00:11:13,100 --> 00:11:23,150
away from ad-hoc methods so finally

215
00:11:20,390 --> 00:11:25,870
there are some classes of strings that

216
00:11:23,150 --> 00:11:29,810
are almost universally considered ok

217
00:11:25,870 --> 00:11:32,510
it's a big pain to migrate a large

218
00:11:29,810 --> 00:11:34,339
application when the majority of what

219
00:11:32,510 --> 00:11:36,680
you're doing is saying oh it's ok to

220
00:11:34,340 --> 00:11:39,380
allow this to assign this to a link

221
00:11:36,680 --> 00:11:43,870
target because it's an HTTP URL the

222
00:11:39,380 --> 00:11:46,850
default policy mechanism allows you to

223
00:11:43,870 --> 00:11:48,170
easily migrate applications that that

224
00:11:46,850 --> 00:11:50,720
have this property where the vast

225
00:11:48,170 --> 00:11:54,459
majority of strings fall into a bucket

226
00:11:50,720 --> 00:11:57,170
because of some recognizable property so

227
00:11:54,460 --> 00:12:01,010
here you can see that I've white listed

228
00:11:57,170 --> 00:12:03,589
a policy named default default is a

229
00:12:01,010 --> 00:12:06,410
special name the default policy is

230
00:12:03,590 --> 00:12:09,290
applied implicitly whenever a string

231
00:12:06,410 --> 00:12:14,240
assignment happens and here I'm defining

232
00:12:09,290 --> 00:12:18,380
a default policy for URLs so if the URL

233
00:12:14,240 --> 00:12:21,020
starts with HTTP or HTTPS or mailto or

234
00:12:18,380 --> 00:12:23,060
it doesn't have a protocol which you

235
00:12:21,020 --> 00:12:25,510
know according to that lion noise then

236
00:12:23,060 --> 00:12:29,089
it's allowed otherwise it throws

237
00:12:25,510 --> 00:12:31,250
hopefully provides a developer with

238
00:12:29,090 --> 00:12:36,560
message which tells them what went wrong

239
00:12:31,250 --> 00:12:38,000
and and maybe how to to follow the

240
00:12:36,560 --> 00:12:40,939
approval process if what they're doing

241
00:12:38,000 --> 00:12:44,900
really is a legit case and with this

242
00:12:40,940 --> 00:12:47,600
this assignment of an HTTP URL just

243
00:12:44,900 --> 00:12:50,350
works this assignment of a JavaScript

244
00:12:47,600 --> 00:12:50,350
URL fails

245
00:12:50,700 --> 00:13:00,720
so we've been doing this for a while now

246
00:12:53,730 --> 00:13:03,600
for server-side XSS and this is actually

247
00:13:00,720 --> 00:13:06,330
our main line of defense against XSS for

248
00:13:03,600 --> 00:13:10,290
some large high-profile applications

249
00:13:06,330 --> 00:13:12,570
like Gmail and Google Plus here you can

250
00:13:10,290 --> 00:13:17,400
see we've got stats from our bug bounty

251
00:13:12,570 --> 00:13:19,110
program before the before we started

252
00:13:17,400 --> 00:13:22,439
rolling out trusted types or server-side

253
00:13:19,110 --> 00:13:26,240
code the XSS rates were trending up for

254
00:13:22,440 --> 00:13:28,560
both applications it took us a while to

255
00:13:26,240 --> 00:13:31,380
migrate these large applications but as

256
00:13:28,560 --> 00:13:34,739
we did so they dropped off and then

257
00:13:31,380 --> 00:13:37,800
after migration they've stayed low so

258
00:13:34,740 --> 00:13:39,720
it's hard to come up with clear evidence

259
00:13:37,800 --> 00:13:42,500
of efficacy for a lot of security

260
00:13:39,720 --> 00:13:48,270
tooling but this is is highly suggestive

261
00:13:42,500 --> 00:13:50,850
and and yet this we've implemented we've

262
00:13:48,270 --> 00:13:53,730
we've gone and done this kind of widely

263
00:13:50,850 --> 00:13:55,740
throughout Google's internal stacks for

264
00:13:53,730 --> 00:13:57,450
you know half a dozen languages we have

265
00:13:55,740 --> 00:14:05,250
protocol buffers kind of tying things

266
00:13:57,450 --> 00:14:07,320
together and so to recap if you control

267
00:14:05,250 --> 00:14:09,060
the CSP header then trusted types gives

268
00:14:07,320 --> 00:14:15,720
you as a security practitioner at the

269
00:14:09,060 --> 00:14:18,000
tools to manage Dom XSS and with trusted

270
00:14:15,720 --> 00:14:21,030
types enabled trust decisions are

271
00:14:18,000 --> 00:14:22,560
without trusted types enabled trust

272
00:14:21,030 --> 00:14:24,720
decisions are implicit in their code

273
00:14:22,560 --> 00:14:27,390
there's nothing about the code or the

274
00:14:24,720 --> 00:14:29,820
values that get assigned that indicate

275
00:14:27,390 --> 00:14:31,980
that these values were that that the

276
00:14:29,820 --> 00:14:36,270
code author intended to trust these

277
00:14:31,980 --> 00:14:40,340
values with trusted types enabled trust

278
00:14:36,270 --> 00:14:43,620
decisions are explicit and auditable

279
00:14:40,340 --> 00:14:45,780
since trust types guard sinks not only

280
00:14:43,620 --> 00:14:50,270
our trust decisions explicit they're

281
00:14:45,780 --> 00:14:54,120
consistently checked before values pass

282
00:14:50,270 --> 00:14:59,329
to things like the HTML parser or the

283
00:14:54,120 --> 00:14:59,330
JavaScript engine where badness happens

284
00:15:00,340 --> 00:15:06,700
with with white lists with policy white

285
00:15:04,420 --> 00:15:08,410
lists you can down the amount of code

286
00:15:06,700 --> 00:15:13,120
that you as a member of the security

287
00:15:08,410 --> 00:15:16,319
team need to review these white lists

288
00:15:13,120 --> 00:15:19,360
are very different from CSP white lists

289
00:15:16,320 --> 00:15:22,360
CSP source white lists these white lists

290
00:15:19,360 --> 00:15:24,910
tend to be smaller they don't need to

291
00:15:22,360 --> 00:15:30,310
change when code is reorganized or

292
00:15:24,910 --> 00:15:33,240
bundled and the most of the things on

293
00:15:30,310 --> 00:15:35,739
these white lists are a small number of

294
00:15:33,240 --> 00:15:39,430
kind of well under tools with well

295
00:15:35,740 --> 00:15:44,350
understood security properties and what

296
00:15:39,430 --> 00:15:46,390
we found is that the using these white

297
00:15:44,350 --> 00:15:48,390
lists allows us to guide developers

298
00:15:46,390 --> 00:15:52,870
towards safe abstractions and kind of

299
00:15:48,390 --> 00:15:54,910
incentivizes investment in in security

300
00:15:52,870 --> 00:15:59,470
engineering and and secure

301
00:15:54,910 --> 00:16:03,130
infrastructure and finally the default

302
00:15:59,470 --> 00:16:05,080
policy and a few other mechanisms are

303
00:16:03,130 --> 00:16:08,020
kind of pragmatic choices that we found

304
00:16:05,080 --> 00:16:11,500
help to migrate applications to the

305
00:16:08,020 --> 00:16:15,240
scheme and now Christoph is going to

306
00:16:11,500 --> 00:16:15,240
show you how that works in practice

307
00:16:15,870 --> 00:16:30,160
thank you Michael shorter than Mike so

308
00:16:23,940 --> 00:16:32,850
let's see some demo all right you can't

309
00:16:30,160 --> 00:16:32,850
see the screen yes

310
00:16:34,520 --> 00:16:43,470
so there is an application written in

311
00:16:38,370 --> 00:16:45,600
angular framework that intends to you

312
00:16:43,470 --> 00:16:48,089
know it's an application in which you

313
00:16:45,600 --> 00:16:49,709
can search for videos play them using

314
00:16:48,089 --> 00:16:51,360
various back-end services like YouTube

315
00:16:49,709 --> 00:16:54,630
SoundCloud Mixcloud

316
00:16:51,360 --> 00:16:56,339
it's a reasonably complex application it

317
00:16:54,630 --> 00:16:58,800
was written again using the angular

318
00:16:56,339 --> 00:17:01,140
framework run-of-the-mill application an

319
00:16:58,800 --> 00:17:04,079
exemplary one so what we did is we took

320
00:17:01,140 --> 00:17:07,020
it and just migrated it to trusted types

321
00:17:04,079 --> 00:17:08,399
in a way that's safe secure and this is

322
00:17:07,020 --> 00:17:11,639
exactly what I will demonstrate how to

323
00:17:08,400 --> 00:17:15,179
actually use the trusted types API in a

324
00:17:11,640 --> 00:17:16,890
real world application of course I can't

325
00:17:15,179 --> 00:17:20,550
show you Gmail right now but you know

326
00:17:16,890 --> 00:17:23,910
something like that so you can later on

327
00:17:20,550 --> 00:17:26,609
even check out the code it's it's under

328
00:17:23,910 --> 00:17:30,660
my github repository in the web project

329
00:17:26,609 --> 00:17:33,350
and trusted types - angular branch has

330
00:17:30,660 --> 00:17:36,980
all the code so we can follow later on

331
00:17:33,350 --> 00:17:39,480
first of all angular the framework

332
00:17:36,980 --> 00:17:40,830
nowadays JavaScript development or at

333
00:17:39,480 --> 00:17:42,360
least for the modern applications

334
00:17:40,830 --> 00:17:45,210
happens usually throughout the

335
00:17:42,360 --> 00:17:48,178
frameworks there are a couple of popular

336
00:17:45,210 --> 00:17:51,000
ones like react angularjs polymer

337
00:17:48,179 --> 00:17:53,690
sometimes and a lot of those frameworks

338
00:17:51,000 --> 00:17:57,090
already try to address the dome XSS

339
00:17:53,690 --> 00:17:59,309
problem they want to expose api's to the

340
00:17:57,090 --> 00:18:01,199
developers that are safe - construction

341
00:17:59,309 --> 00:18:04,080
or it's really hard to introduce

342
00:18:01,200 --> 00:18:07,380
vulnerabilities through them therefore

343
00:18:04,080 --> 00:18:10,399
it is safe to assume that for example

344
00:18:07,380 --> 00:18:12,990
angular the framework especially it's

345
00:18:10,400 --> 00:18:16,770
let's say the template rendering engine

346
00:18:12,990 --> 00:18:19,740
is trusted to produce a trusted HTML

347
00:18:16,770 --> 00:18:21,809
value all trusted URL values why because

348
00:18:19,740 --> 00:18:24,390
angular on its own has its HTML

349
00:18:21,809 --> 00:18:28,800
sanitizer inside it has been reviewed

350
00:18:24,390 --> 00:18:30,870
for security we know of no bypasses for

351
00:18:28,800 --> 00:18:33,059
now for that sanitization engine so it's

352
00:18:30,870 --> 00:18:34,739
really you have to take an effort in

353
00:18:33,059 --> 00:18:36,389
your custom code in order to introduce

354
00:18:34,740 --> 00:18:38,190
an XSS vulnerability in an angular

355
00:18:36,390 --> 00:18:41,940
application not angularjs and we load

356
00:18:38,190 --> 00:18:44,250
the new one so what we did is we forked

357
00:18:41,940 --> 00:18:45,550
an expert we have an experimental form

358
00:18:44,250 --> 00:18:47,650
called the angular

359
00:18:45,550 --> 00:18:50,590
simply changing one component of it

360
00:18:47,650 --> 00:18:53,680
making the sanitizer output the trusted

361
00:18:50,590 --> 00:18:56,500
values and the only thing from the

362
00:18:53,680 --> 00:18:58,810
application user point of view or the

363
00:18:56,500 --> 00:19:01,770
application outer is to in the

364
00:18:58,810 --> 00:19:04,690
packetization just switch one of the

365
00:19:01,770 --> 00:19:08,470
packages from angular to our fork right

366
00:19:04,690 --> 00:19:11,260
so instead of using the core angular or

367
00:19:08,470 --> 00:19:13,300
vanilla angular we're just using a fork

368
00:19:11,260 --> 00:19:15,010
right this is this is this is all very

369
00:19:13,300 --> 00:19:16,990
nice and as long as the application only

370
00:19:15,010 --> 00:19:18,730
uses the angular way of producing

371
00:19:16,990 --> 00:19:21,190
templates and interpolating user data

372
00:19:18,730 --> 00:19:24,730
into them this should be safe because of

373
00:19:21,190 --> 00:19:27,330
the sanitizer that angular uses so let's

374
00:19:24,730 --> 00:19:27,330
try this in action

375
00:19:28,440 --> 00:19:34,720
spoiler alert alert it will not work let

376
00:19:32,980 --> 00:19:36,640
me actually solve the thing and what you

377
00:19:34,720 --> 00:19:39,760
can immediately see is something right

378
00:19:36,640 --> 00:19:41,380
here this document requires trust

379
00:19:39,760 --> 00:19:43,900
additional assignments there's a couple

380
00:19:41,380 --> 00:19:46,330
of errors but you can already see that

381
00:19:43,900 --> 00:19:48,070
this is something happening with jQuery

382
00:19:46,330 --> 00:19:49,899
apparently this application not not only

383
00:19:48,070 --> 00:19:54,189
uses angular it also uses jQuery

384
00:19:49,900 --> 00:19:56,920
thankfully we can see where this

385
00:19:54,190 --> 00:19:59,200
actually breaks right so jQuery when

386
00:19:56,920 --> 00:20:02,110
loaded and jQuery is actually not loaded

387
00:19:59,200 --> 00:20:04,030
directly it's loaded through one of the

388
00:20:02,110 --> 00:20:06,240
dependencies of the application namely

389
00:20:04,030 --> 00:20:09,790
backbone.js

390
00:20:06,240 --> 00:20:11,260
does some Dom probing it tries to do

391
00:20:09,790 --> 00:20:14,230
some feature detection on Dom in order

392
00:20:11,260 --> 00:20:16,570
to whatever code workarounds so how do

393
00:20:14,230 --> 00:20:18,910
we address this without changing jQuery

394
00:20:16,570 --> 00:20:20,530
itself which is possible and I also did

395
00:20:18,910 --> 00:20:22,180
it but this is not not the part of this

396
00:20:20,530 --> 00:20:26,710
demo now while we can use the default

397
00:20:22,180 --> 00:20:28,450
policy that Mike told you about the

398
00:20:26,710 --> 00:20:31,780
reason why this why this assignment

399
00:20:28,450 --> 00:20:34,150
failed is because we know we enforce

400
00:20:31,780 --> 00:20:36,820
trusted types allowing only free

401
00:20:34,150 --> 00:20:39,850
policies for this particular application

402
00:20:36,820 --> 00:20:41,379
the one from that angular uses the one

403
00:20:39,850 --> 00:20:43,719
that I will talk about later and the

404
00:20:41,380 --> 00:20:45,910
default policy which I will enable right

405
00:20:43,720 --> 00:20:47,290
now so let's enable this and the

406
00:20:45,910 --> 00:20:50,740
application recompile in the meantime

407
00:20:47,290 --> 00:20:52,480
and let's look at the default policy so

408
00:20:50,740 --> 00:20:53,860
first of all this application checks if

409
00:20:52,480 --> 00:20:56,830
the trusted types API is even available

410
00:20:53,860 --> 00:20:58,709
if it is then it tries to create the

411
00:20:56,830 --> 00:21:01,500
policy name default which is supposedly

412
00:20:58,710 --> 00:21:04,770
like listed in the header and for this

413
00:21:01,500 --> 00:21:06,570
policy if this policy is being called

414
00:21:04,770 --> 00:21:08,250
whenever strings are actually assigned

415
00:21:06,570 --> 00:21:09,720
to the Dom into sensitive things in this

416
00:21:08,250 --> 00:21:12,539
particular case this function is called

417
00:21:09,720 --> 00:21:14,610
when HTML things are being called and

418
00:21:12,539 --> 00:21:18,090
what I do here is I have some whitelist

419
00:21:14,610 --> 00:21:20,270
of HTML that I simply allow to be

420
00:21:18,090 --> 00:21:22,918
written without rewriting the code and

421
00:21:20,270 --> 00:21:25,470
this is exactly what jQuery does when

422
00:21:22,919 --> 00:21:27,450
loaded it tries to insert those strings

423
00:21:25,470 --> 00:21:29,700
into the Dom clearly this is not a dumb

424
00:21:27,450 --> 00:21:31,289
exercise there's no you know JavaScript

425
00:21:29,700 --> 00:21:32,940
payloads in here or Nothing

426
00:21:31,289 --> 00:21:35,250
user-controlled there's also something

427
00:21:32,940 --> 00:21:39,809
slightly more custom they try to inject

428
00:21:35,250 --> 00:21:41,880
something that has a dynamic here ID but

429
00:21:39,809 --> 00:21:44,490
with you know with this regular

430
00:21:41,880 --> 00:21:46,919
expression being strict I can make sure

431
00:21:44,490 --> 00:21:48,450
that actually there is no bypass that

432
00:21:46,919 --> 00:21:50,880
will enable for Dom access through this

433
00:21:48,450 --> 00:21:54,179
particular vector so this default policy

434
00:21:50,880 --> 00:21:56,850
is being called when when the strings

435
00:21:54,179 --> 00:21:59,250
are being assigned to the Dom XSS sinks

436
00:21:56,850 --> 00:22:01,230
and that allows to equate to work on top

437
00:21:59,250 --> 00:22:03,659
of that we have a couple of other things

438
00:22:01,230 --> 00:22:05,490
first of all there's a fallback case if

439
00:22:03,659 --> 00:22:08,730
you're trying to well essentially load

440
00:22:05,490 --> 00:22:10,470
new scripts to the page and what I have

441
00:22:08,730 --> 00:22:12,350
here is also an aloud script regular

442
00:22:10,470 --> 00:22:16,230
expressions with some widgets from

443
00:22:12,350 --> 00:22:19,949
YouTube namely all right thank you

444
00:22:16,230 --> 00:22:23,220
there's a widget from YouTube that is

445
00:22:19,950 --> 00:22:25,250
being loaded from a URL that's somewhat

446
00:22:23,220 --> 00:22:28,710
predictable but seen and still dynamic

447
00:22:25,250 --> 00:22:31,200
and apart from that what what I do is I

448
00:22:28,710 --> 00:22:32,820
just console error just to surface to

449
00:22:31,200 --> 00:22:34,679
the developer you know you're doing

450
00:22:32,820 --> 00:22:37,770
something wrong like you're loading an

451
00:22:34,679 --> 00:22:39,630
additional script I know about this but

452
00:22:37,770 --> 00:22:42,809
I will allow for it for now right so I

453
00:22:39,630 --> 00:22:45,960
just returned the input whenever you're

454
00:22:42,809 --> 00:22:48,928
using other your others URL sinks what I

455
00:22:45,960 --> 00:22:50,909
do is just I pass the URL and if you're

456
00:22:48,929 --> 00:22:52,919
just using HTTP or HTTPS I really don't

457
00:22:50,909 --> 00:22:54,630
care you can link to our nearby websites

458
00:22:52,919 --> 00:22:58,980
like personal Tom access has involved

459
00:22:54,630 --> 00:23:01,350
here and finally if you want to use evil

460
00:22:58,980 --> 00:23:04,529
or other you know friendly functions

461
00:23:01,350 --> 00:23:07,260
I just disallow it at least one called

462
00:23:04,529 --> 00:23:09,750
with strings and let's see how this

463
00:23:07,260 --> 00:23:10,990
thing works the application actually

464
00:23:09,750 --> 00:23:13,240
reloaded and

465
00:23:10,990 --> 00:23:15,370
to the modern development practices of

466
00:23:13,240 --> 00:23:17,920
its part what we can see what is

467
00:23:15,370 --> 00:23:19,959
happening is yeah the whole application

468
00:23:17,920 --> 00:23:22,960
is working with trusted types under

469
00:23:19,960 --> 00:23:26,320
those policies so we can whatever look

470
00:23:22,960 --> 00:23:29,740
for Oh ASP try to you know click on the

471
00:23:26,320 --> 00:23:32,620
hole that some whatever some yeah it's

472
00:23:29,740 --> 00:23:34,630
place music on my laptop so you can see

473
00:23:32,620 --> 00:23:36,399
the application fully work like nothing

474
00:23:34,630 --> 00:23:39,280
breaks it was quite easy to migrate to

475
00:23:36,400 --> 00:23:43,600
trusted types what we have right now is

476
00:23:39,280 --> 00:23:44,950
we bounded this application to only only

477
00:23:43,600 --> 00:23:47,080
the code that has access to those

478
00:23:44,950 --> 00:23:49,390
policies sorry those from the index.html

479
00:23:47,080 --> 00:23:51,490
so only this one so if you're using

480
00:23:49,390 --> 00:23:54,429
angular whatever angular does we trust

481
00:23:51,490 --> 00:23:56,020
it and whatever default policy does we

482
00:23:54,429 --> 00:23:57,790
trust it in this particular case you

483
00:23:56,020 --> 00:24:01,330
know this white is of HTML does those

484
00:23:57,790 --> 00:24:06,340
other things but let's see about this

485
00:24:01,330 --> 00:24:07,570
console error what's going on so all of

486
00:24:06,340 --> 00:24:13,120
us quite a lot of errors let me maybe

487
00:24:07,570 --> 00:24:15,809
clear it and refresh what you can notice

488
00:24:13,120 --> 00:24:18,820
is yeah please refactor script URL

489
00:24:15,809 --> 00:24:20,230
what's going on well thankfully this is

490
00:24:18,820 --> 00:24:22,240
all now part of the code like the

491
00:24:20,230 --> 00:24:23,770
protection is part of your actual actual

492
00:24:22,240 --> 00:24:27,070
code base so we can just you know use

493
00:24:23,770 --> 00:24:29,170
regular debugging techniques like I'm

494
00:24:27,070 --> 00:24:33,570
just checking in a developer console all

495
00:24:29,170 --> 00:24:36,970
right so yeah indeed there is something

496
00:24:33,570 --> 00:24:38,950
loading a Google Analytics script in

497
00:24:36,970 --> 00:24:41,170
some file in the application and this

498
00:24:38,950 --> 00:24:42,940
one is using a string for for loading

499
00:24:41,170 --> 00:24:46,480
that script which is potentially user

500
00:24:42,940 --> 00:24:46,929
controlled you know it's worth looking

501
00:24:46,480 --> 00:24:49,120
into

502
00:24:46,929 --> 00:24:50,620
so let's look at this Google Analytics

503
00:24:49,120 --> 00:24:53,889
something-something model the tears in

504
00:24:50,620 --> 00:24:54,928
the source code it's being here and we

505
00:24:53,890 --> 00:24:59,170
have it

506
00:24:54,929 --> 00:25:00,780
however thankfully by making the Dom API

507
00:24:59,170 --> 00:25:03,610
strongly-typed

508
00:25:00,780 --> 00:25:07,059
we can introduce language level checks

509
00:25:03,610 --> 00:25:09,399
or static analysis checks to surface two

510
00:25:07,059 --> 00:25:09,910
vulnerabilities and this is exactly what

511
00:25:09,400 --> 00:25:13,120
we did

512
00:25:09,910 --> 00:25:15,100
we have a linter check that warns you

513
00:25:13,120 --> 00:25:18,729
that something potentially risk is going

514
00:25:15,100 --> 00:25:20,620
on in this particular case this resource

515
00:25:18,730 --> 00:25:22,390
URL assignment from string might result

516
00:25:20,620 --> 00:25:23,969
in script execution and will trigger

517
00:25:22,390 --> 00:25:26,519
trust attacks violation at runtime

518
00:25:23,970 --> 00:25:28,259
use the literal policy right I mean you

519
00:25:26,519 --> 00:25:30,000
obviously you know that the risk the

520
00:25:28,259 --> 00:25:31,980
potential risk is you do something like

521
00:25:30,000 --> 00:25:33,210
that so I calculation HF here or the

522
00:25:31,980 --> 00:25:35,549
prefix whatever like if there's

523
00:25:33,210 --> 00:25:38,909
something attacker control time is wrong

524
00:25:35,549 --> 00:25:41,129
but we can offer fix this for it because

525
00:25:38,909 --> 00:25:44,759
you know studying analysis it sort of

526
00:25:41,129 --> 00:25:48,389
works now if we have types so this is

527
00:25:44,759 --> 00:25:50,460
exactly what I did and we are using this

528
00:25:48,389 --> 00:25:52,649
extra function that magically provides

529
00:25:50,460 --> 00:25:53,580
value and security how does it work well

530
00:25:52,649 --> 00:25:55,620
it works like that

531
00:25:53,580 --> 00:25:59,990
as long as this function accepts a

532
00:25:55,620 --> 00:26:02,100
string literal that the assumption is

533
00:25:59,990 --> 00:26:04,169
the attacker cannot inject into the

534
00:26:02,100 --> 00:26:05,668
strictly literally the attacker would

535
00:26:04,169 --> 00:26:07,529
have which needs to have a server-side

536
00:26:05,669 --> 00:26:10,409
access in order to modify the actual

537
00:26:07,529 --> 00:26:13,549
JavaScript code however as soon as you

538
00:26:10,409 --> 00:26:15,750
want to say interpolate data into this

539
00:26:13,549 --> 00:26:17,908
this is potentially attacker control

540
00:26:15,750 --> 00:26:18,929
right so if I use whatever location

541
00:26:17,909 --> 00:26:23,070
sorry

542
00:26:18,929 --> 00:26:27,870
it's curly braces if I use location say

543
00:26:23,070 --> 00:26:31,379
whatever HF or harsh right or slice one

544
00:26:27,870 --> 00:26:32,699
of the typical dome accesses so as soon

545
00:26:31,379 --> 00:26:36,269
as you start interpolating into this

546
00:26:32,700 --> 00:26:39,029
string you see that there is actually a

547
00:26:36,269 --> 00:26:41,159
problem a problem that even prevents

548
00:26:39,029 --> 00:26:43,620
computation of this of this code which

549
00:26:41,159 --> 00:26:48,389
we will probably check after a couple of

550
00:26:43,620 --> 00:26:50,250
seconds here why is that yeah see so the

551
00:26:48,389 --> 00:26:52,080
application if you try to introduce if

552
00:26:50,250 --> 00:26:54,990
you try to write a let's say a dynamic

553
00:26:52,080 --> 00:26:55,500
string or a variable into a sensitive

554
00:26:54,990 --> 00:26:58,289
thing

555
00:26:55,500 --> 00:26:59,820
this becomes a compilation error so you

556
00:26:58,289 --> 00:27:01,350
get a pretty early feedback for the

557
00:26:59,820 --> 00:27:03,509
developers something is wrong you should

558
00:27:01,350 --> 00:27:07,980
be using a different method why is that

559
00:27:03,509 --> 00:27:11,159
it's because this particular function it

560
00:27:07,980 --> 00:27:13,620
uses its own policy called little script

561
00:27:11,159 --> 00:27:16,200
URL which supposedly does no validation

562
00:27:13,620 --> 00:27:18,539
however this policy is isolated in this

563
00:27:16,200 --> 00:27:20,700
particular module right in JavaScript

564
00:27:18,539 --> 00:27:23,399
modules only the exported sorry

565
00:27:20,700 --> 00:27:26,610
functions or objects are being able to

566
00:27:23,399 --> 00:27:28,979
call to be called externally so this

567
00:27:26,610 --> 00:27:32,580
policy can only be used from within this

568
00:27:28,980 --> 00:27:35,399
module and the only call side of it is

569
00:27:32,580 --> 00:27:38,260
this function and this function has type

570
00:27:35,399 --> 00:27:40,120
annotations some magic types

571
00:27:38,260 --> 00:27:42,580
you know type annotation thing that

572
00:27:40,120 --> 00:27:45,189
makes sure that this behavior is

573
00:27:42,580 --> 00:27:46,960
preserved meaning that only a string

574
00:27:45,190 --> 00:27:51,280
literal with no interpolation in sight

575
00:27:46,960 --> 00:27:54,250
can be the function argument so even if

576
00:27:51,280 --> 00:27:58,690
we do even if we did sorry even if we

577
00:27:54,250 --> 00:28:01,740
did any expression here this is also an

578
00:27:58,690 --> 00:28:05,560
error so we can be reasonably sure that

579
00:28:01,740 --> 00:28:07,720
this is secure and given that this is a

580
00:28:05,560 --> 00:28:10,870
strongly type we are leveraging the type

581
00:28:07,720 --> 00:28:13,660
system here or you know a more strongly

582
00:28:10,870 --> 00:28:15,370
typed language like typescript ish we

583
00:28:13,660 --> 00:28:16,810
can do even automatic refactorings for a

584
00:28:15,370 --> 00:28:18,459
lot of the coal sites with let's which

585
00:28:16,810 --> 00:28:23,560
lets us migrate the application pretty

586
00:28:18,460 --> 00:28:25,240
easily so in the end what happens if we

587
00:28:23,560 --> 00:28:30,730
actually try to recompile application

588
00:28:25,240 --> 00:28:36,010
using this thing that succeed yes it's

589
00:28:30,730 --> 00:28:37,990
compiled nowaday now this value the

590
00:28:36,010 --> 00:28:40,030
Google Analytics script URL is not

591
00:28:37,990 --> 00:28:41,200
actually you're a good programmer and

592
00:28:40,030 --> 00:28:42,940
you're loading script on Google

593
00:28:41,200 --> 00:28:46,990
Analytics this is part of this little

594
00:28:42,940 --> 00:28:49,540
script policy here somewhere

595
00:28:46,990 --> 00:28:51,540
yeah so this value is not going through

596
00:28:49,540 --> 00:28:54,580
the default policy and therefore by

597
00:28:51,540 --> 00:28:56,350
migrating your code or getting the

598
00:28:54,580 --> 00:28:58,060
warnings or errors through the default

599
00:28:56,350 --> 00:29:01,510
policy you have a chance of migrating

600
00:28:58,060 --> 00:29:03,490
the whole the the code the risky cold

601
00:29:01,510 --> 00:29:05,200
parts into more strict policies the

602
00:29:03,490 --> 00:29:07,270
named policies and then the default

603
00:29:05,200 --> 00:29:12,130
policy can be just like this last resort

604
00:29:07,270 --> 00:29:14,980
log on the report only or just throw if

605
00:29:12,130 --> 00:29:16,840
if you're really reasonably sure all of

606
00:29:14,980 --> 00:29:19,690
the code has been migrated so trusted

607
00:29:16,840 --> 00:29:22,689
I'll give you a way of locking down the

608
00:29:19,690 --> 00:29:26,710
application in a way that is reviewable

609
00:29:22,690 --> 00:29:28,300
auditable and dramatically reduces the

610
00:29:26,710 --> 00:29:29,650
security surface because I know for sure

611
00:29:28,300 --> 00:29:31,450
right now in this particular application

612
00:29:29,650 --> 00:29:32,740
I don't have to review a single line of

613
00:29:31,450 --> 00:29:34,870
code that doesn't have access to the

614
00:29:32,740 --> 00:29:36,280
policy object because it cannot possibly

615
00:29:34,870 --> 00:29:38,350
introduce the Dom XSS

616
00:29:36,280 --> 00:29:40,510
because it would all it would only write

617
00:29:38,350 --> 00:29:42,040
a string to the Dom and the strings are

618
00:29:40,510 --> 00:29:44,400
disallowed the default policy would

619
00:29:42,040 --> 00:29:44,399
render

620
00:29:44,440 --> 00:29:53,920
and I guess with that I can go back to

621
00:29:48,790 --> 00:30:00,879
the presentation if everything works and

622
00:29:53,920 --> 00:30:04,110
it doesn't of course an easier way I

623
00:30:00,880 --> 00:30:04,110
will just restart the presentation

624
00:30:10,650 --> 00:30:19,670
[Applause]

625
00:30:23,330 --> 00:30:29,250
now oh come on

626
00:30:25,930 --> 00:30:29,250
don't look in my password

627
00:30:34,710 --> 00:30:38,099
[Applause]

628
00:30:42,929 --> 00:30:51,100
and it's a different one amazing I know

629
00:30:48,970 --> 00:30:52,750
this the summer is the same so we can

630
00:30:51,100 --> 00:30:57,370
just go here so what's the status of the

631
00:30:52,750 --> 00:31:00,340
project we have an implementation in my

632
00:30:57,370 --> 00:31:02,379
chrome for a couple of releases now it

633
00:31:00,340 --> 00:31:04,449
changes and you know we'll keep adding

634
00:31:02,380 --> 00:31:08,740
stuff to the API you can use it using

635
00:31:04,450 --> 00:31:12,070
the origin trial it's also created as a

636
00:31:08,740 --> 00:31:14,260
spec this will go through the w3c you

637
00:31:12,070 --> 00:31:16,120
know workflows we have a discussion

638
00:31:14,260 --> 00:31:18,970
group where you can you know talk to us

639
00:31:16,120 --> 00:31:21,959
about using the API there is a polyfill

640
00:31:18,970 --> 00:31:24,760
for other browsers the code is on github

641
00:31:21,960 --> 00:31:27,640
we are adopting this approach to Google

642
00:31:24,760 --> 00:31:31,840
applications it works promising ly well

643
00:31:27,640 --> 00:31:33,940
for now and internally in Google we have

644
00:31:31,840 --> 00:31:37,600
a whole team working on adopting

645
00:31:33,940 --> 00:31:39,429
creating the API and we're working on

646
00:31:37,600 --> 00:31:41,439
external integrations Don purify is

647
00:31:39,429 --> 00:31:43,929
already integrated so don't purify if

648
00:31:41,440 --> 00:31:45,700
the trusted types API is available we'll

649
00:31:43,929 --> 00:31:50,290
produce just the type trusted HTML

650
00:31:45,700 --> 00:31:52,059
values so you get the support for free

651
00:31:50,290 --> 00:31:54,610
we have integrations with with other

652
00:31:52,059 --> 00:31:56,320
libraries or frameworks plants we

653
00:31:54,610 --> 00:31:59,320
integrate with typescript there's a type

654
00:31:56,320 --> 00:32:01,059
definition package already we do

655
00:31:59,320 --> 00:32:03,850
sometimes with angular with react and

656
00:32:01,059 --> 00:32:05,710
other frameworks and we are set to

657
00:32:03,850 --> 00:32:08,649
release some secure policies libraries

658
00:32:05,710 --> 00:32:10,960
that offer not just a primitive of you

659
00:32:08,650 --> 00:32:11,980
know the security header and you can

660
00:32:10,960 --> 00:32:13,360
create your own policies we will

661
00:32:11,980 --> 00:32:15,460
actually create policies that are safe

662
00:32:13,360 --> 00:32:20,649
and are reviewed and we you know vote

663
00:32:15,460 --> 00:32:24,730
for yeah with that I guess we can go to

664
00:32:20,650 --> 00:32:26,820
Q&A and let's and Dom XSS together thank

665
00:32:24,730 --> 00:32:26,820
you

666
00:32:28,260 --> 00:32:33,299
[Applause]

667
00:32:46,960 --> 00:32:55,210
Oh sorry if I priced this part I could

668
00:32:52,270 --> 00:32:59,410
you please compare it with TSP version 2

669
00:32:55,210 --> 00:33:01,750
and using inceptive ow i mean i

670
00:32:59,410 --> 00:33:05,940
duplicated on using detective all i need

671
00:33:01,750 --> 00:33:09,010
for some replication maybe it will be a

672
00:33:05,940 --> 00:33:13,600
little bit simpler way to prevent don't

673
00:33:09,010 --> 00:33:15,790
buy success CSP doesn't prevent access

674
00:33:13,600 --> 00:33:18,159
it rather tries to mitigate the exploits

675
00:33:15,790 --> 00:33:19,870
that come from the exercise we react

676
00:33:18,160 --> 00:33:21,250
more earlier we try to prevent the

677
00:33:19,870 --> 00:33:24,100
injections in the first place instead of

678
00:33:21,250 --> 00:33:26,440
trying to make sure that the injections

679
00:33:24,100 --> 00:33:29,679
don't contain JavaScript ich what she

680
00:33:26,440 --> 00:33:34,450
has been tries to address but in

681
00:33:29,680 --> 00:33:35,950
specific what with what we find sis we

682
00:33:34,450 --> 00:33:37,810
after after you know yes of experience

683
00:33:35,950 --> 00:33:39,940
what we find CSP good at is it

684
00:33:37,810 --> 00:33:41,649
preventing around mitigating the suicide

685
00:33:39,940 --> 00:33:43,210
accesses the stored on reflectiveness in

686
00:33:41,650 --> 00:33:51,430
specific especially the nonce based

687
00:33:43,210 --> 00:33:57,160
variant of CSP however for Dom XSS is

688
00:33:51,430 --> 00:33:59,380
just not best I mean we see a lot of Dom

689
00:33:57,160 --> 00:34:01,750
XSS ends up being a property of the

690
00:33:59,380 --> 00:34:06,790
JavaScript program and you can't easily

691
00:34:01,750 --> 00:34:08,260
tune that by just looking at the URLs of

692
00:34:06,790 --> 00:34:11,259
the scripts or maybe looking at evil

693
00:34:08,260 --> 00:34:14,080
only right so lack of unsafe evil in CSP

694
00:34:11,260 --> 00:34:18,420
can only make sure that you're not using

695
00:34:14,080 --> 00:34:21,250
evil with trusted types you get to

696
00:34:18,420 --> 00:34:24,250
instruct evil what to what to execute so

697
00:34:21,250 --> 00:34:25,989
for example it's very easier to migrate

698
00:34:24,250 --> 00:34:29,679
an application that uses evil

699
00:34:25,989 --> 00:34:31,509
selectively in some call site to trust

700
00:34:29,679 --> 00:34:34,600
the time span and would be to remove the

701
00:34:31,510 --> 00:34:38,440
email capability completely that is

702
00:34:34,600 --> 00:34:41,049
required by CSP sort of so by using

703
00:34:38,440 --> 00:34:43,090
trusted types you get more control into

704
00:34:41,050 --> 00:34:47,020
how your interactions with the Dom look

705
00:34:43,090 --> 00:34:48,940
like including the eval function will

706
00:34:47,020 --> 00:34:50,949
CSP it's more like it's binary thing

707
00:34:48,940 --> 00:34:54,210
like okay so you can load scripts from

708
00:34:50,949 --> 00:34:57,069
this URL or tab needs to have a nonce or

709
00:34:54,210 --> 00:34:58,670
you know you can use eval or you cannot

710
00:34:57,070 --> 00:35:01,400
use eval it's a decision of

711
00:34:58,670 --> 00:35:03,770
police shelter but in sentence a free

712
00:35:01,400 --> 00:35:07,940
well is not is not only about evil

713
00:35:03,770 --> 00:35:10,069
constructions button it's about the

714
00:35:07,940 --> 00:35:12,619
whole constructions like HTML it's also

715
00:35:10,069 --> 00:35:14,299
you can try simply not to include

716
00:35:12,619 --> 00:35:17,450
himself while in your content skip the

717
00:35:14,299 --> 00:35:22,520
polls yeah and it will help you to

718
00:35:17,450 --> 00:35:25,098
mitigate don't waste excess is true yes

719
00:35:22,520 --> 00:35:27,440
CSP hubs mitigate Dom XSS status there

720
00:35:25,099 --> 00:35:32,440
is a true statement it doesn't prevent

721
00:35:27,440 --> 00:35:35,710
the injections and so for example with

722
00:35:32,440 --> 00:35:37,970
let's say a hardened version of the CSP

723
00:35:35,710 --> 00:35:39,799
you didn't remove the injection point

724
00:35:37,970 --> 00:35:42,500
the attacker can still inject arbitrary

725
00:35:39,799 --> 00:35:44,660
HTML by 2 MB and just you know create a

726
00:35:42,500 --> 00:35:47,390
spoofing we create a credential

727
00:35:44,660 --> 00:35:48,950
exfiltrating page they can do it there's

728
00:35:47,390 --> 00:35:52,098
no script there it's just you know

729
00:35:48,950 --> 00:35:53,569
graphics and a form field and with

730
00:35:52,099 --> 00:35:56,299
trusted types we try to prevent the

731
00:35:53,569 --> 00:36:05,390
injections not the JavaScript execution

732
00:35:56,299 --> 00:36:06,610
from those injections Thank You

733
00:36:05,390 --> 00:36:08,759
Christophe and Mike

734
00:36:06,610 --> 00:36:08,760
[Applause]

