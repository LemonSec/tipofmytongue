1
00:00:00,030 --> 00:00:04,440
hello and thank you very much for coming

2
00:00:02,520 --> 00:00:07,949
the decision about injecting security

3
00:00:04,440 --> 00:00:10,080
controls in software applications in

4
00:00:07,950 --> 00:00:13,379
most companies the security is a

5
00:00:10,080 --> 00:00:16,379
checkbox and it's there for compliance

6
00:00:13,380 --> 00:00:19,170
regulations reasons we define the

7
00:00:16,379 --> 00:00:22,800
policies that contains the cwe's each

8
00:00:19,170 --> 00:00:25,170
company is interested to comply with SQL

9
00:00:22,800 --> 00:00:28,289
injection cross-site scripting or any

10
00:00:25,170 --> 00:00:32,640
other cwe each company is interested to

11
00:00:28,289 --> 00:00:34,770
comply wait and this is how we think of

12
00:00:32,640 --> 00:00:38,910
security like a checkbox that we must

13
00:00:34,770 --> 00:00:40,980
tick so the software is then accepted

14
00:00:38,910 --> 00:00:43,339
and release in production in particular

15
00:00:40,980 --> 00:00:47,489
in those companies where there is a

16
00:00:43,340 --> 00:00:50,070
security release gate the result of this

17
00:00:47,489 --> 00:00:52,410
approach is that a high number of

18
00:00:50,070 --> 00:00:56,219
insecure applications is still developed

19
00:00:52,410 --> 00:00:59,940
and injection is still king in the

20
00:00:56,219 --> 00:01:04,500
latest most of 10 2017 the injection is

21
00:00:59,940 --> 00:01:06,479
still in poor position at number one so

22
00:01:04,500 --> 00:01:07,950
is there anything else that we can do

23
00:01:06,479 --> 00:01:11,158
and that's what I'm going to explore as

24
00:01:07,950 --> 00:01:14,340
part of this presentation where I'm

25
00:01:11,159 --> 00:01:17,280
going to look at vulnerabilities from a

26
00:01:14,340 --> 00:01:18,780
different angle we will decompose the

27
00:01:17,280 --> 00:01:20,670
vulnerabilities into the security

28
00:01:18,780 --> 00:01:23,070
controls that prevent them and are

29
00:01:20,670 --> 00:01:25,860
familiar to developers and can be used

30
00:01:23,070 --> 00:01:30,389
in the software development cycle and we

31
00:01:25,860 --> 00:01:34,020
will focus from focusing in on the c-w

32
00:01:30,390 --> 00:01:37,590
ease which can be measured only after

33
00:01:34,020 --> 00:01:39,840
the software is developed at the end to

34
00:01:37,590 --> 00:01:42,180
focus instead on the security controls

35
00:01:39,840 --> 00:01:44,640
that prevent them are familiar to

36
00:01:42,180 --> 00:01:48,030
developers and can be used from the

37
00:01:44,640 --> 00:01:49,979
beginning a little bit about myself my

38
00:01:48,030 --> 00:01:52,380
name is Katie Anton and I come from a

39
00:01:49,979 --> 00:01:55,140
software development background where in

40
00:01:52,380 --> 00:01:58,560
my previous align I have managed and

41
00:01:55,140 --> 00:02:01,140
created teams of developers and that's

42
00:01:58,560 --> 00:02:03,390
where I got involved into the or

43
00:02:01,140 --> 00:02:07,229
September ActiveX controls which is a

44
00:02:03,390 --> 00:02:09,810
developer Noah's project for developers

45
00:02:07,229 --> 00:02:13,010
by developers I currently work as

46
00:02:09,810 --> 00:02:15,530
application security consultant advocate

47
00:02:13,010 --> 00:02:17,359
and this is where I help developers

48
00:02:15,530 --> 00:02:21,440
around the world to secure their

49
00:02:17,360 --> 00:02:23,540
applications the first category of

50
00:02:21,440 --> 00:02:25,670
vulnerabilities that I will tackle yes

51
00:02:23,540 --> 00:02:28,609
its injection this is still one of the

52
00:02:25,670 --> 00:02:33,379
most common vulnerabilities found in

53
00:02:28,610 --> 00:02:36,319
software applications as a category this

54
00:02:33,379 --> 00:02:39,679
is a large category and it contains

55
00:02:36,319 --> 00:02:42,879
multiple types of injection and you have

56
00:02:39,680 --> 00:02:46,400
command injection course I scripting XML

57
00:02:42,879 --> 00:02:48,709
code injection LDAP injection SQL

58
00:02:46,400 --> 00:02:50,840
injection just name a few injections and

59
00:02:48,709 --> 00:02:52,400
if we go into each of these

60
00:02:50,840 --> 00:02:55,250
classification then depending of the

61
00:02:52,400 --> 00:02:58,390
type of the injection you can have

62
00:02:55,250 --> 00:03:01,250
further classification you can have

63
00:02:58,390 --> 00:03:05,420
inbound injection out-of-band injection

64
00:03:01,250 --> 00:03:07,489
so it can become quite complicated and

65
00:03:05,420 --> 00:03:09,798
it makes it really difficult for

66
00:03:07,489 --> 00:03:11,390
developers to think of all of these type

67
00:03:09,799 --> 00:03:15,709
of injections while they write their

68
00:03:11,390 --> 00:03:19,339
code and all of these type of attacks if

69
00:03:15,709 --> 00:03:22,549
we go to a basic definition of what the

70
00:03:19,340 --> 00:03:26,120
injection is just go back back to the

71
00:03:22,549 --> 00:03:30,019
basics the injection occurs when some

72
00:03:26,120 --> 00:03:33,200
data is combined with a sort of a syntax

73
00:03:30,019 --> 00:03:37,760
that result is then sent to the parser

74
00:03:33,200 --> 00:03:42,798
and that when is when it ends up being

75
00:03:37,760 --> 00:03:45,200
executed as code so the theta which is

76
00:03:42,799 --> 00:03:51,380
not necessarily only from getting posed

77
00:03:45,200 --> 00:03:53,660
but it's also from HTTP headers file

78
00:03:51,380 --> 00:03:56,569
upload data from the database

79
00:03:53,660 --> 00:03:59,359
configuration files so when all this

80
00:03:56,569 --> 00:04:02,030
data from all these wide range of

81
00:03:59,359 --> 00:04:06,400
sources is combined with the sort of a

82
00:04:02,030 --> 00:04:09,260
syntax that result is sent to a parser

83
00:04:06,400 --> 00:04:12,079
which if we store data to the database

84
00:04:09,260 --> 00:04:16,760
that is the SQL parser if we render a

85
00:04:12,079 --> 00:04:21,019
webpage that is the HTML parser or the

86
00:04:16,760 --> 00:04:23,930
browser and that is we when we end up

87
00:04:21,019 --> 00:04:25,250
with code with data executive as part of

88
00:04:23,930 --> 00:04:31,320
the code

89
00:04:25,250 --> 00:04:36,300
so I will take this view and I will flip

90
00:04:31,320 --> 00:04:41,479
it to focus on the res beat the output

91
00:04:36,300 --> 00:04:45,240
which ends up being executed as curved

92
00:04:41,479 --> 00:04:47,610
so even in the case of the SQL injection

93
00:04:45,240 --> 00:04:49,830
like I said this occurs when you have

94
00:04:47,610 --> 00:04:52,979
the input which is combined with the SQL

95
00:04:49,830 --> 00:04:55,349
query that is sent to the parser and

96
00:04:52,979 --> 00:04:59,310
that's when it ends up being executed as

97
00:04:55,350 --> 00:05:03,720
SQL command the primary defense for this

98
00:04:59,310 --> 00:05:06,380
is to parametrize the queries to

99
00:05:03,720 --> 00:05:09,870
separate the input from the actual SQL

100
00:05:06,380 --> 00:05:14,449
command before sending it to the SQL

101
00:05:09,870 --> 00:05:17,430
parson this is the primary control to

102
00:05:14,449 --> 00:05:19,650
parameterize the query but as defense in

103
00:05:17,430 --> 00:05:22,080
that we still have to validate the input

104
00:05:19,650 --> 00:05:27,510
and ideally we must do that both of them

105
00:05:22,080 --> 00:05:31,229
at the same time in the case of

106
00:05:27,510 --> 00:05:35,960
cross-site scripting the primary control

107
00:05:31,229 --> 00:05:40,320
for this one is to contextually encode

108
00:05:35,960 --> 00:05:43,169
the data before creating the HTML

109
00:05:40,320 --> 00:05:46,110
document that is sent to the HTML parser

110
00:05:43,169 --> 00:05:47,370
and this is the primary control but as

111
00:05:46,110 --> 00:05:50,220
differencing that we still have to

112
00:05:47,370 --> 00:05:52,740
validate the input and similarly for the

113
00:05:50,220 --> 00:05:54,810
case of the XML injection alder

114
00:05:52,740 --> 00:05:56,370
injection and command injection in the

115
00:05:54,810 --> 00:06:00,740
case of the command injection depending

116
00:05:56,370 --> 00:06:03,270
of language use ideally we would

117
00:06:00,740 --> 00:06:06,660
parameterize the data if that is

118
00:06:03,270 --> 00:06:09,120
available if not then contextually

119
00:06:06,660 --> 00:06:11,580
encode the output before sending it to

120
00:06:09,120 --> 00:06:14,250
the parser to neutralize the characters

121
00:06:11,580 --> 00:06:17,760
that can trigger the code injection the

122
00:06:14,250 --> 00:06:20,280
command injection so rather than

123
00:06:17,760 --> 00:06:22,699
focusing of all these type of injections

124
00:06:20,280 --> 00:06:26,760
we can which can be quite overwhelming

125
00:06:22,699 --> 00:06:29,880
instead we can choose to focus as a

126
00:06:26,760 --> 00:06:33,349
primary control always to parameterize

127
00:06:29,880 --> 00:06:36,270
the data if that's not available

128
00:06:33,349 --> 00:06:37,469
contextually encode the output to

129
00:06:36,270 --> 00:06:42,030
neutralize the

130
00:06:37,470 --> 00:06:43,980
that can trigger the injection but as

131
00:06:42,030 --> 00:06:48,409
defencing that we still have to validate

132
00:06:43,980 --> 00:06:53,070
the input the input validation helps you

133
00:06:48,410 --> 00:06:56,040
reduce the attack surface and it's more

134
00:06:53,070 --> 00:06:57,719
efficient if we do this when data enters

135
00:06:56,040 --> 00:07:00,630
the application in the case of the MVC

136
00:06:57,720 --> 00:07:02,490
controller this point in the case of the

137
00:07:00,630 --> 00:07:05,190
MVC this point is in the controller and

138
00:07:02,490 --> 00:07:10,310
that's where it's best to perform the

139
00:07:05,190 --> 00:07:15,600
input validation and we have to do these

140
00:07:10,310 --> 00:07:19,020
both by and by doing this in a

141
00:07:15,600 --> 00:07:21,690
consistent manner both of them we are

142
00:07:19,020 --> 00:07:23,700
able to prevent vulnerabilities the

143
00:07:21,690 --> 00:07:25,560
developers might not be aware of a good

144
00:07:23,700 --> 00:07:27,570
example for this is the second-order SQL

145
00:07:25,560 --> 00:07:29,730
injection which is the injection where

146
00:07:27,570 --> 00:07:31,530
the injection payload stays dormant into

147
00:07:29,730 --> 00:07:36,300
the database until it finds the right

148
00:07:31,530 --> 00:07:38,760
environment to be exploited the next

149
00:07:36,300 --> 00:07:44,760
category that I will tackle is

150
00:07:38,760 --> 00:07:49,530
vulnerable components or in other words

151
00:07:44,760 --> 00:07:55,919
using software components with known

152
00:07:49,530 --> 00:07:59,729
vulnerabilities today we are pretty good

153
00:07:55,919 --> 00:08:03,289
at identifying the libraries that are

154
00:07:59,729 --> 00:08:06,020
part of a software identifying the

155
00:08:03,290 --> 00:08:09,810
vulnerabilities which are part of our

156
00:08:06,020 --> 00:08:12,180
libraries and we are pretty good on this

157
00:08:09,810 --> 00:08:14,580
because we have either open source tools

158
00:08:12,180 --> 00:08:17,400
like a dependency check or commercial

159
00:08:14,580 --> 00:08:19,440
tools but the problem that I see out

160
00:08:17,400 --> 00:08:20,940
there is that we end up with a report in

161
00:08:19,440 --> 00:08:23,690
the case of the java application this

162
00:08:20,940 --> 00:08:27,960
this can be like a few hundreds

163
00:08:23,690 --> 00:08:30,110
libraries and it takes a long time to

164
00:08:27,960 --> 00:08:35,218
actually do something about this and

165
00:08:30,110 --> 00:08:38,010
that's where the problem is and the

166
00:08:35,219 --> 00:08:40,830
software that has this problem is the

167
00:08:38,010 --> 00:08:44,790
type of software that no developer wants

168
00:08:40,830 --> 00:08:46,500
attached because if they change

169
00:08:44,790 --> 00:08:48,599
something in one place of the software

170
00:08:46,500 --> 00:08:50,790
they are going to break something in a

171
00:08:48,600 --> 00:08:53,790
different part of the software

172
00:08:50,790 --> 00:08:58,560
as a result is difficult to test it

173
00:08:53,790 --> 00:09:05,670
might have some few tests minimal

174
00:08:58,560 --> 00:09:08,040
coverage it is difficult and all of

175
00:09:05,670 --> 00:09:10,680
these means that it is difficult to

176
00:09:08,040 --> 00:09:12,630
upgrade and leads to a high level of

177
00:09:10,680 --> 00:09:14,638
technical debt and that's where the

178
00:09:12,630 --> 00:09:16,350
problem is the type of software that has

179
00:09:14,639 --> 00:09:18,600
this high number of vulnerable

180
00:09:16,350 --> 00:09:22,470
components is the type of software that

181
00:09:18,600 --> 00:09:24,060
has a high level of technical debt so is

182
00:09:22,470 --> 00:09:27,899
there anything else that we can do about

183
00:09:24,060 --> 00:09:29,939
this and I'll go for this it there is a

184
00:09:27,899 --> 00:09:32,459
strong connection between software

185
00:09:29,940 --> 00:09:34,380
development and how to deal with this

186
00:09:32,459 --> 00:09:36,899
from a security to deal with the

187
00:09:34,380 --> 00:09:39,420
security issues and they are explore for

188
00:09:36,899 --> 00:09:43,980
these three types of components the

189
00:09:39,420 --> 00:09:47,189
first one is an open source component

190
00:09:43,980 --> 00:09:49,260
like that is commonly used but they are

191
00:09:47,190 --> 00:09:51,180
not focus only on open source components

192
00:09:49,260 --> 00:09:55,199
because the problem is not only there

193
00:09:51,180 --> 00:09:57,660
are also considered an A and an API from

194
00:09:55,199 --> 00:09:59,579
a vendor and also the scenario which is

195
00:09:57,660 --> 00:10:05,160
quite common in large companies where

196
00:09:59,579 --> 00:10:07,888
you have a team that develops a package

197
00:10:05,160 --> 00:10:09,839
and then that is reused on multiple

198
00:10:07,889 --> 00:10:15,060
applications which with within the same

199
00:10:09,839 --> 00:10:18,510
company so the person are you of an open

200
00:10:15,060 --> 00:10:21,089
source library and the very common one

201
00:10:18,510 --> 00:10:22,680
is the bringing a logging library and

202
00:10:21,089 --> 00:10:26,089
like any ready-made

203
00:10:22,680 --> 00:10:29,279
library has a wealth of functionality

204
00:10:26,089 --> 00:10:33,300
and most likely your software will not

205
00:10:29,279 --> 00:10:35,010
need all of these functionality for

206
00:10:33,300 --> 00:10:39,029
example in the case of logging you only

207
00:10:35,010 --> 00:10:43,290
have want to to focus on three levels of

208
00:10:39,029 --> 00:10:49,319
logging run debugging info so for this

209
00:10:43,290 --> 00:10:53,069
scenario when you want to expose into

210
00:10:49,319 --> 00:10:55,579
your application only a subset of the

211
00:10:53,069 --> 00:10:58,949
functionality and you want to hide

212
00:10:55,579 --> 00:11:01,199
unwanted behavior a good software design

213
00:10:58,949 --> 00:11:03,599
pattern that can be used is a simple

214
00:11:01,199 --> 00:11:06,540
wrapper this

215
00:11:03,600 --> 00:11:10,620
helps you to expose only what you want

216
00:11:06,540 --> 00:11:13,890
hide unwanted behavior and this is a

217
00:11:10,620 --> 00:11:17,040
good way to reduce the attack surface

218
00:11:13,890 --> 00:11:18,720
into your software but it's also a very

219
00:11:17,040 --> 00:11:22,709
good design pattern because it helps you

220
00:11:18,720 --> 00:11:25,290
out to upgrade or even replace without

221
00:11:22,710 --> 00:11:28,530
much penalty these libraries if they

222
00:11:25,290 --> 00:11:31,500
become obsolete the next one that

223
00:11:28,530 --> 00:11:34,650
hanging to consider is to implement a

224
00:11:31,500 --> 00:11:37,200
vendor API a very good example of this

225
00:11:34,650 --> 00:11:39,360
in particular in the case of the

226
00:11:37,200 --> 00:11:42,930
e-commerce application is the payment

227
00:11:39,360 --> 00:11:46,620
gateway where you is likely hire it's

228
00:11:42,930 --> 00:11:48,810
highly likely that a website will have

229
00:11:46,620 --> 00:11:51,300
more than one payment gateway at the

230
00:11:48,810 --> 00:11:53,160
same time now from a security point of

231
00:11:51,300 --> 00:11:55,560
view we have to be aware that there is a

232
00:11:53,160 --> 00:11:57,839
trend out there at the moment and this

233
00:11:55,560 --> 00:12:00,510
is that rather than breaching the target

234
00:11:57,840 --> 00:12:03,090
we can bridge the partner of the target

235
00:12:00,510 --> 00:12:06,750
so again this is another way that we

236
00:12:03,090 --> 00:12:10,950
need to be on top of and in in the case

237
00:12:06,750 --> 00:12:13,790
of these vendor api's we need a way that

238
00:12:10,950 --> 00:12:16,350
if one of our partners has been breached

239
00:12:13,790 --> 00:12:23,250
we can get into the control of our

240
00:12:16,350 --> 00:12:25,290
software now in the case of a payment

241
00:12:23,250 --> 00:12:31,650
gateway is highly likely that the vendor

242
00:12:25,290 --> 00:12:33,449
API it has its own method and your

243
00:12:31,650 --> 00:12:37,530
software will have its own transactional

244
00:12:33,450 --> 00:12:39,900
methods so for this and it needs a way

245
00:12:37,530 --> 00:12:41,040
of conversion for this way this scenario

246
00:12:39,900 --> 00:12:42,720
where you need to convert from the

247
00:12:41,040 --> 00:12:44,040
provided interface the required

248
00:12:42,720 --> 00:12:46,850
interface the one that your software

249
00:12:44,040 --> 00:12:51,990
requires a good design pattern is the

250
00:12:46,850 --> 00:12:54,810
adapter design pattern these the benefit

251
00:12:51,990 --> 00:12:57,390
of this one is that it can works with

252
00:12:54,810 --> 00:13:00,089
multiple adoptees at the same time and

253
00:12:57,390 --> 00:13:03,360
it allows you to quickly switch between

254
00:13:00,090 --> 00:13:05,520
them so if one of the partners become is

255
00:13:03,360 --> 00:13:07,080
breech then this it's something that the

256
00:13:05,520 --> 00:13:09,660
gain helps you out to get into the

257
00:13:07,080 --> 00:13:13,200
controller of your components and the

258
00:13:09,660 --> 00:13:15,149
last example is to implement

259
00:13:13,200 --> 00:13:17,730
a package that has been developed by

260
00:13:15,149 --> 00:13:22,320
another team within the same company a

261
00:13:17,730 --> 00:13:26,130
good example for this is the a single

262
00:13:22,320 --> 00:13:27,600
sign-on and then this is reused for

263
00:13:26,130 --> 00:13:33,660
every application within the same

264
00:13:27,600 --> 00:13:36,000
company this can the example of single

265
00:13:33,660 --> 00:13:38,490
sign-on this can be quite complex

266
00:13:36,000 --> 00:13:40,290
sometimes so for this scenario when you

267
00:13:38,490 --> 00:13:42,180
actually want to simplify the

268
00:13:40,290 --> 00:13:44,639
interaction between your own software

269
00:13:42,180 --> 00:13:46,800
and the complex subsystem a good design

270
00:13:44,639 --> 00:13:50,279
pattern it's the facade design pattern

271
00:13:46,800 --> 00:13:52,709
it still offers the same benefits of

272
00:13:50,279 --> 00:13:54,510
actually getting into control you have

273
00:13:52,709 --> 00:13:58,260
the say class where you actually can't

274
00:13:54,510 --> 00:14:02,189
get into the control of your libraries

275
00:13:58,260 --> 00:14:07,139
and you can easily upgrade if something

276
00:14:02,190 --> 00:14:10,050
happens so if we are to summarize secure

277
00:14:07,139 --> 00:14:15,510
software start from the design from the

278
00:14:10,050 --> 00:14:17,430
point when we have chosen how we are

279
00:14:15,510 --> 00:14:20,130
going to implement when we bring a

280
00:14:17,430 --> 00:14:23,339
component from that point the security

281
00:14:20,130 --> 00:14:27,180
of the software starts so we can choose

282
00:14:23,339 --> 00:14:29,220
to use just a simple wrapper when we

283
00:14:27,180 --> 00:14:31,800
want to expose into our software only a

284
00:14:29,220 --> 00:14:36,449
subset from the functionality provider

285
00:14:31,800 --> 00:14:38,760
and hide unwanted behavior we can choose

286
00:14:36,449 --> 00:14:41,459
the adapter design pattern when we want

287
00:14:38,760 --> 00:14:43,800
to convert from the provided interface

288
00:14:41,459 --> 00:14:45,899
the required interface and the facade we

289
00:14:43,800 --> 00:14:49,829
want when we want to simplify between

290
00:14:45,899 --> 00:14:55,529
the complex subsystem and our own

291
00:14:49,829 --> 00:14:59,250
software this design pattern also helps

292
00:14:55,529 --> 00:15:00,990
with legacy application to get into

293
00:14:59,250 --> 00:15:04,230
control of those type of applications

294
00:15:00,990 --> 00:15:09,149
and again improve and upgrade your

295
00:15:04,230 --> 00:15:11,430
components and another type of issue

296
00:15:09,149 --> 00:15:13,470
that I am going to discuss is about

297
00:15:11,430 --> 00:15:15,989
intrusion detection or better said the

298
00:15:13,470 --> 00:15:21,089
lack of it the problem that we have out

299
00:15:15,990 --> 00:15:23,160
there is that logging fair logins

300
00:15:21,089 --> 00:15:27,080
high-level transactions are not logged

301
00:15:23,160 --> 00:15:30,449
if there is some sort of logging

302
00:15:27,080 --> 00:15:34,830
the format is not consistent enough to

303
00:15:30,450 --> 00:15:37,860
allow an organization to centralize all

304
00:15:34,830 --> 00:15:40,680
of these logs and process them in an

305
00:15:37,860 --> 00:15:45,270
automatic manner to get in a reasonable

306
00:15:40,680 --> 00:15:48,569
amount of time some information about

307
00:15:45,270 --> 00:15:50,340
any suspicious activity as a result of

308
00:15:48,570 --> 00:15:53,460
these two problems not enough

309
00:15:50,340 --> 00:15:56,960
information security information and not

310
00:15:53,460 --> 00:16:01,590
consistent format

311
00:15:56,960 --> 00:16:04,500
there are many api's and applications

312
00:16:01,590 --> 00:16:07,440
out there that are simply not monitored

313
00:16:04,500 --> 00:16:09,780
to put it simply if a panda star is able

314
00:16:07,440 --> 00:16:12,800
to get into a system without being

315
00:16:09,780 --> 00:16:18,079
detected this is a good indication that

316
00:16:12,800 --> 00:16:21,630
there is not enough monitoring and

317
00:16:18,080 --> 00:16:23,490
intrusion detection in place so what can

318
00:16:21,630 --> 00:16:26,430
we do from a software development point

319
00:16:23,490 --> 00:16:30,420
of view for these four developers we

320
00:16:26,430 --> 00:16:34,890
have the security logging this is the

321
00:16:30,420 --> 00:16:38,880
control for developers to log security

322
00:16:34,890 --> 00:16:41,550
information during the runtime operation

323
00:16:38,880 --> 00:16:43,740
of an application now this has been

324
00:16:41,550 --> 00:16:47,490
introduced by the OS of the interactive

325
00:16:43,740 --> 00:16:50,700
controls team in 2016 and then it has

326
00:16:47,490 --> 00:16:55,950
been taken over into the our top 10 2017

327
00:16:50,700 --> 00:16:57,960
as a 10 so let's go through let's go a

328
00:16:55,950 --> 00:16:59,550
little bit more in detail to see to have

329
00:16:57,960 --> 00:17:02,040
a better understanding what this means

330
00:16:59,550 --> 00:17:04,470
according to you there is a very good

331
00:17:02,040 --> 00:17:08,760
project or project which is the absence

332
00:17:04,470 --> 00:17:10,980
er and there are six types of detection

333
00:17:08,760 --> 00:17:13,369
points that are considered good attack

334
00:17:10,980 --> 00:17:15,319
identifiers and these are the

335
00:17:13,369 --> 00:17:21,139
authorization and authentication

336
00:17:15,319 --> 00:17:23,699
failures client-side input validation

337
00:17:21,140 --> 00:17:26,790
bypasses and whitelist input validation

338
00:17:23,699 --> 00:17:29,280
failures obvious code injection attacks

339
00:17:26,790 --> 00:17:32,040
like obvious SQL injection strings and

340
00:17:29,280 --> 00:17:34,080
the high rate of function years for

341
00:17:32,040 --> 00:17:36,740
example you have a high number of page

342
00:17:34,080 --> 00:17:37,919
requests in a very short period of time

343
00:17:36,740 --> 00:17:41,100
so

344
00:17:37,920 --> 00:17:45,930
go through a little bit more of some of

345
00:17:41,100 --> 00:17:49,350
these examples now in the case of a

346
00:17:45,930 --> 00:17:52,980
request if the application expects to

347
00:17:49,350 --> 00:17:55,290
receive post but instead it receives yet

348
00:17:52,980 --> 00:17:58,230
this is a very good indication that

349
00:17:55,290 --> 00:18:00,629
somebody has intercepted that

350
00:17:58,230 --> 00:18:04,830
communication and has intentionally

351
00:18:00,630 --> 00:18:08,450
changed from post to get this type of

352
00:18:04,830 --> 00:18:13,520
anomaly this exception should be logged

353
00:18:08,450 --> 00:18:17,000
equally if the application receives

354
00:18:13,520 --> 00:18:19,710
extra for or URL parameters and

355
00:18:17,000 --> 00:18:22,260
something that a panda sir will always

356
00:18:19,710 --> 00:18:25,020
do is to ask for example debug equal

357
00:18:22,260 --> 00:18:29,430
true just to see what happens if this

358
00:18:25,020 --> 00:18:31,800
happens this is another example of an

359
00:18:29,430 --> 00:18:34,520
exception that should belong in the case

360
00:18:31,800 --> 00:18:37,800
of authentication if the application

361
00:18:34,520 --> 00:18:39,750
expects to receive two parameters the

362
00:18:37,800 --> 00:18:41,610
username and the password but instead

363
00:18:39,750 --> 00:18:43,010
receives only one of them the username

364
00:18:41,610 --> 00:18:45,330
because the password has been

365
00:18:43,010 --> 00:18:47,940
intentionally removed this is another

366
00:18:45,330 --> 00:18:51,840
example of an exception that should be

367
00:18:47,940 --> 00:18:53,390
logged or if there are extra additional

368
00:18:51,840 --> 00:18:56,159
parameters that are received during

369
00:18:53,390 --> 00:18:58,230
authentication a good example of this

370
00:18:56,160 --> 00:19:03,210
and something that a pen tester will try

371
00:18:58,230 --> 00:19:05,370
is admin equal true if this happens this

372
00:19:03,210 --> 00:19:08,420
is another example of an exception that

373
00:19:05,370 --> 00:19:12,409
should be logged and in the case of the

374
00:19:08,420 --> 00:19:13,580
request exceptions for example if your

375
00:19:12,410 --> 00:19:16,770
[Music]

376
00:19:13,580 --> 00:19:18,300
server side validation fails is by the

377
00:19:16,770 --> 00:19:20,940
fact that you have a client-side

378
00:19:18,300 --> 00:19:22,980
validation and a good very simple

379
00:19:20,940 --> 00:19:27,150
example of this one you have on the

380
00:19:22,980 --> 00:19:32,070
client side of web for in one of the

381
00:19:27,150 --> 00:19:35,610
elements of the form you have an

382
00:19:32,070 --> 00:19:39,540
attribute maximum length however when

383
00:19:35,610 --> 00:19:40,979
that string reaches the server side the

384
00:19:39,540 --> 00:19:45,000
length of the string is greater than the

385
00:19:40,980 --> 00:19:46,800
one that has been defined in the client

386
00:19:45,000 --> 00:19:48,630
this is a very good indicator that

387
00:19:46,800 --> 00:19:51,710
somebody has intercepted that

388
00:19:48,630 --> 00:19:54,630
communication since it has left a high

389
00:19:51,710 --> 00:19:56,940
change intentionally changed the string

390
00:19:54,630 --> 00:19:59,250
and this is another example of a

391
00:19:56,940 --> 00:20:02,400
exception that should be logged and I

392
00:19:59,250 --> 00:20:06,750
believe in the case of non editable form

393
00:20:02,400 --> 00:20:10,170
fields like hidden fields passed radio

394
00:20:06,750 --> 00:20:11,930
buttons this as well should be validated

395
00:20:10,170 --> 00:20:14,730
and these are good examples of

396
00:20:11,930 --> 00:20:18,180
exceptions that should be logged when

397
00:20:14,730 --> 00:20:22,380
the validation fails now these are just

398
00:20:18,180 --> 00:20:25,500
four examples if you want to have a

399
00:20:22,380 --> 00:20:29,730
better understanding and to see more

400
00:20:25,500 --> 00:20:33,930
example the best pair the best for this

401
00:20:29,730 --> 00:20:35,700
is the up sensor project or was up

402
00:20:33,930 --> 00:20:37,530
sensor project now there are two parts

403
00:20:35,700 --> 00:20:40,440
of this project there is a tool and

404
00:20:37,530 --> 00:20:44,399
there is a documentation this research

405
00:20:40,440 --> 00:20:46,980
and this is refers to the documentation

406
00:20:44,400 --> 00:20:49,530
part of the project which is something

407
00:20:46,980 --> 00:20:50,910
that a developer needs to put into their

408
00:20:49,530 --> 00:20:55,170
own application as part of their

409
00:20:50,910 --> 00:20:57,300
business logic and by putting this of

410
00:20:55,170 --> 00:20:59,820
having this verification in place and

411
00:20:57,300 --> 00:21:02,580
putting these into our own software what

412
00:20:59,820 --> 00:21:05,610
were actually doing is we just validate

413
00:21:02,580 --> 00:21:08,760
that the software receive what it

414
00:21:05,610 --> 00:21:12,060
expects however when this does not

415
00:21:08,760 --> 00:21:14,610
happen and we have these exceptions by

416
00:21:12,060 --> 00:21:16,800
having this into the software what we

417
00:21:14,610 --> 00:21:20,300
are giving to the software we are giving

418
00:21:16,800 --> 00:21:23,790
it the mechanism to respond in real-time

419
00:21:20,300 --> 00:21:27,330
to possible identified attacks these are

420
00:21:23,790 --> 00:21:31,379
tasks that we have identified and the

421
00:21:27,330 --> 00:21:33,090
software can reduce or even stop these

422
00:21:31,380 --> 00:21:41,540
attacks depending of how we choose to

423
00:21:33,090 --> 00:21:46,409
write the software so if we are to recap

424
00:21:41,540 --> 00:21:52,680
what we have discussed until now every

425
00:21:46,410 --> 00:21:56,970
time we data enters our application and

426
00:21:52,680 --> 00:21:58,560
is not only from get or post is from a

427
00:21:56,970 --> 00:22:00,960
wide variety of sources

428
00:21:58,560 --> 00:22:03,730
we should validate that data at the

429
00:22:00,960 --> 00:22:09,070
point of entering your application

430
00:22:03,730 --> 00:22:12,310
any exceptions that we find those should

431
00:22:09,070 --> 00:22:14,290
be locked in a constant format to give

432
00:22:12,310 --> 00:22:16,510
the software the mechanisms to respond

433
00:22:14,290 --> 00:22:19,930
in real-time to possible identified

434
00:22:16,510 --> 00:22:22,360
attacks any output should be

435
00:22:19,930 --> 00:22:24,760
contextually encoded and when you store

436
00:22:22,360 --> 00:22:27,100
data into the database should be we

437
00:22:24,760 --> 00:22:30,640
should parameterize the queries if we

438
00:22:27,100 --> 00:22:32,620
really need to use to access operating

439
00:22:30,640 --> 00:22:34,900
system commands ideally we should not

440
00:22:32,620 --> 00:22:36,790
but if we really really need to we

441
00:22:34,900 --> 00:22:41,620
should prioritize the data separating

442
00:22:36,790 --> 00:22:44,950
but from the actual command and every

443
00:22:41,620 --> 00:22:47,739
time we're bringing a library we should

444
00:22:44,950 --> 00:22:50,080
use we should encapsulate it in users of

445
00:22:47,740 --> 00:22:55,140
their design patterns that help us to

446
00:22:50,080 --> 00:22:57,340
get into control of our components or to

447
00:22:55,140 --> 00:23:01,470
upgrade them or even replace them

448
00:22:57,340 --> 00:23:05,470
without much penalty whenever a new

449
00:23:01,470 --> 00:23:07,060
vulnerability is found now are these the

450
00:23:05,470 --> 00:23:09,550
only control that we should be using

451
00:23:07,060 --> 00:23:12,520
definitely not and depending of how you

452
00:23:09,550 --> 00:23:17,560
want to define your policy we can add to

453
00:23:12,520 --> 00:23:21,310
this so for example if you want to if

454
00:23:17,560 --> 00:23:23,620
your application needs to store they

455
00:23:21,310 --> 00:23:26,320
doesn't say sensitive data we should

456
00:23:23,620 --> 00:23:29,790
encrypt it and then store the key into

457
00:23:26,320 --> 00:23:33,310
dedicated key management solutions and

458
00:23:29,790 --> 00:23:36,550
if you want for example to amend your

459
00:23:33,310 --> 00:23:39,159
policy in order to add to it some of the

460
00:23:36,550 --> 00:23:43,149
latest most of ten like let's say for

461
00:23:39,160 --> 00:23:47,970
example the xxe XML external entity or

462
00:23:43,150 --> 00:23:53,110
Saddam 611 then the control for that is

463
00:23:47,970 --> 00:23:55,780
to harden the SQL artha before parsing

464
00:23:53,110 --> 00:23:59,379
an XML document and we can add that one

465
00:23:55,780 --> 00:24:01,060
to our list of security controls now

466
00:23:59,380 --> 00:24:07,660
what I would like you to take away is

467
00:24:01,060 --> 00:24:11,889
that we need to have policies where we

468
00:24:07,660 --> 00:24:15,580
define the CW is but instead of focusing

469
00:24:11,890 --> 00:24:16,950
on the CW is which can be measured only

470
00:24:15,580 --> 00:24:19,260
at the end of

471
00:24:16,950 --> 00:24:21,420
the software has been developed instead

472
00:24:19,260 --> 00:24:24,210
let's focus on the security controls

473
00:24:21,420 --> 00:24:27,060
that prevent these are familiar to

474
00:24:24,210 --> 00:24:29,940
developers and can be used from the

475
00:24:27,060 --> 00:24:32,940
beginning and it's also important to use

476
00:24:29,940 --> 00:24:34,260
this on a consistent manner all the time

477
00:24:32,940 --> 00:24:36,930
in the software it's not a matter of

478
00:24:34,260 --> 00:24:38,970
choosing which one of them ideal we must

479
00:24:36,930 --> 00:24:41,520
use them all of them because we have to

480
00:24:38,970 --> 00:24:43,940
remember that an attacker it's only one

481
00:24:41,520 --> 00:24:46,500
flow in order to bring down a system as

482
00:24:43,940 --> 00:24:48,870
developers we have to defend everything

483
00:24:46,500 --> 00:24:51,870
and having using them on a consistent

484
00:24:48,870 --> 00:24:54,689
manner it helps to prevent other

485
00:24:51,870 --> 00:24:58,560
vulnerabilities that a developer might

486
00:24:54,690 --> 00:25:01,560
not necessarily be aware of also it's

487
00:24:58,560 --> 00:25:03,810
very important to verify that one we

488
00:25:01,560 --> 00:25:06,240
have implemented them and we have

489
00:25:03,810 --> 00:25:09,419
implemented correctly to effectively

490
00:25:06,240 --> 00:25:10,920
prevent these cwe's and hopefully on the

491
00:25:09,420 --> 00:25:13,050
next one stop then we are not going to

492
00:25:10,920 --> 00:25:22,580
have injection that's number one thank

493
00:25:13,050 --> 00:25:22,580
you very much any questions

494
00:25:33,340 --> 00:25:43,909
yes so it's about using a wrapper to

495
00:25:36,350 --> 00:25:46,060
reduce the attack surface yes if the

496
00:25:43,910 --> 00:25:46,060
what

497
00:25:54,740 --> 00:26:01,860
so that type of design pattern in the

498
00:26:00,030 --> 00:26:04,200
facility it gives you that one point

499
00:26:01,860 --> 00:26:06,120
where you can actually apply extra

500
00:26:04,200 --> 00:26:10,620
controls if you can't necessarily

501
00:26:06,120 --> 00:26:13,439
upgrade that library within the time so

502
00:26:10,620 --> 00:26:17,070
for example you can add extra validation

503
00:26:13,440 --> 00:26:22,170
or extra other things into that one for

504
00:26:17,070 --> 00:26:25,710
a period of time now there is a good

505
00:26:22,170 --> 00:26:27,720
book it's called the clean book the

506
00:26:25,710 --> 00:26:34,080
clink health and is by Robert C Martin

507
00:26:27,720 --> 00:26:35,880
and that gives a very good example of

508
00:26:34,080 --> 00:26:38,129
how to actually implement this in the

509
00:26:35,880 --> 00:26:40,950
more detail ideally when you implement

510
00:26:38,130 --> 00:26:42,780
this you would have tests unit tests

511
00:26:40,950 --> 00:26:44,910
because when you're bringing a library

512
00:26:42,780 --> 00:26:47,309
you must know the functionality that you

513
00:26:44,910 --> 00:26:49,140
are using into your own software you

514
00:26:47,309 --> 00:26:51,210
might not necessarily know it's you

515
00:26:49,140 --> 00:26:54,540
can't know what exactly that library

516
00:26:51,210 --> 00:26:56,460
does as a an entire but you are as a

517
00:26:54,540 --> 00:26:58,230
developer are responsible to note the

518
00:26:56,460 --> 00:27:00,120
functionality that you import in your

519
00:26:58,230 --> 00:27:03,030
software and for this the only way that

520
00:27:00,120 --> 00:27:04,590
you can achieve it is with tests and if

521
00:27:03,030 --> 00:27:07,049
you need to upgrade and having those

522
00:27:04,590 --> 00:27:09,209
tests in place the unity and the

523
00:27:07,049 --> 00:27:10,500
functional test helps you out it gives

524
00:27:09,210 --> 00:27:12,540
you that assurance that your software

525
00:27:10,500 --> 00:27:14,160
after either putting controls or

526
00:27:12,540 --> 00:27:20,100
operating yours is still going to work

527
00:27:14,160 --> 00:27:22,380
as you design it to work yeah I wanted

528
00:27:20,100 --> 00:27:23,219
to you to expand a little bit on the

529
00:27:22,380 --> 00:27:27,570
injection

530
00:27:23,220 --> 00:27:30,960
maybe problem the model that you

531
00:27:27,570 --> 00:27:32,909
proposed is elegant but I feel it might

532
00:27:30,960 --> 00:27:35,150
be a little bit simplified of course

533
00:27:32,910 --> 00:27:37,710
like like any model for example

534
00:27:35,150 --> 00:27:40,919
validating input of course as a defense

535
00:27:37,710 --> 00:27:42,660
in depth and what are logging exceptions

536
00:27:40,919 --> 00:27:44,400
and then encoding the output as

537
00:27:42,660 --> 00:27:50,630
preventing injection vulnerabilities in

538
00:27:44,400 --> 00:27:50,630
general however if you apply that

539
00:27:50,750 --> 00:27:54,059
consistently

540
00:27:51,990 --> 00:27:57,750
your application no longer can output

541
00:27:54,059 --> 00:28:02,129
'html because every like if you intends

542
00:27:57,750 --> 00:28:06,210
to encode every output 'html can I mean

543
00:28:02,130 --> 00:28:08,580
as for XSS an HTML the HTML output

544
00:28:06,210 --> 00:28:10,080
needs to be escaped and therefore your

545
00:28:08,580 --> 00:28:12,629
application cannot produce outputs at

546
00:28:10,080 --> 00:28:14,250
our HTML at all right which is obviously

547
00:28:12,630 --> 00:28:17,850
not what you want I mean you want the

548
00:28:14,250 --> 00:28:19,950
application to work and encode only the

549
00:28:17,850 --> 00:28:22,860
output varies let's a user or attacker

550
00:28:19,950 --> 00:28:25,380
controlled right in order not to not to

551
00:28:22,860 --> 00:28:28,740
have data converted into code right

552
00:28:25,380 --> 00:28:33,240
that's the model if I understand

553
00:28:28,740 --> 00:28:35,550
correctly yeah but you need to also

554
00:28:33,240 --> 00:28:40,830
consider data from the database in the

555
00:28:35,550 --> 00:28:42,690
case of output so yeah and I think this

556
00:28:40,830 --> 00:28:45,679
is a important identify which is the

557
00:28:42,690 --> 00:28:48,360
data that can be tampered wait and

558
00:28:45,680 --> 00:28:50,700
that's the one that you actually want to

559
00:28:48,360 --> 00:28:54,270
encode just before you create the HTML

560
00:28:50,700 --> 00:28:56,460
document that is exactly yes but then

561
00:28:54,270 --> 00:28:58,770
that becomes a taint tracking problem

562
00:28:56,460 --> 00:29:00,990
essentially because you want to assure

563
00:28:58,770 --> 00:29:03,270
in your application that all of the

564
00:29:00,990 --> 00:29:07,170
outputs that are or all of the inputs

565
00:29:03,270 --> 00:29:10,080
that are done parable need to be you

566
00:29:07,170 --> 00:29:13,440
know consistently escaped or turned into

567
00:29:10,080 --> 00:29:16,830
parameterize queries whatever and this

568
00:29:13,440 --> 00:29:20,610
is something that we don't yet know how

569
00:29:16,830 --> 00:29:22,169
to achieve comprehensive and I feel this

570
00:29:20,610 --> 00:29:24,570
is the real cause of the vulnerable

571
00:29:22,170 --> 00:29:26,310
especially for XSS or even dom-based xss

572
00:29:24,570 --> 00:29:28,889
where you don't even have all of the

573
00:29:26,310 --> 00:29:31,020
security controls available because the

574
00:29:28,890 --> 00:29:33,330
API is on client side for example so you

575
00:29:31,020 --> 00:29:36,240
cannot you know hook into all of the API

576
00:29:33,330 --> 00:29:38,750
for example so is that the question

577
00:29:36,240 --> 00:29:41,820
about how do you trace the tainted data

578
00:29:38,750 --> 00:29:46,260
yes especially on I mean I feel this is

579
00:29:41,820 --> 00:29:48,090
the the missing part so for that one you

580
00:29:46,260 --> 00:29:51,150
can see there anything that can be

581
00:29:48,090 --> 00:29:54,419
changed as possible taint and you will

582
00:29:51,150 --> 00:29:56,700
treat it the same possible tain can be

583
00:29:54,420 --> 00:29:59,400
can come from data from the database

584
00:29:56,700 --> 00:30:01,050
data from configuration file you might

585
00:29:59,400 --> 00:30:03,150
say that they are on a server but if the

586
00:30:01,050 --> 00:30:05,490
server has been compromised and a good

587
00:30:03,150 --> 00:30:08,370
example for this was the data breach in

588
00:30:05,490 --> 00:30:10,440
Marriott or the company that they

589
00:30:08,370 --> 00:30:12,270
acquire where the attacker has been

590
00:30:10,440 --> 00:30:15,360
there for four years so you don't know

591
00:30:12,270 --> 00:30:17,310
what's on your network or who is on your

592
00:30:15,360 --> 00:30:19,860
network so you should consider the

593
00:30:17,310 --> 00:30:20,700
configuration files like data that can

594
00:30:19,860 --> 00:30:22,110
be

595
00:30:20,700 --> 00:30:24,690
and then all of that one should be

596
00:30:22,110 --> 00:30:27,270
treated in the same way if you use that

597
00:30:24,690 --> 00:30:30,030
data to create an HTML document this

598
00:30:27,270 --> 00:30:33,210
still has to be included yes I

599
00:30:30,030 --> 00:30:34,889
understand that but I guess the the

600
00:30:33,210 --> 00:30:38,730
question I'm asking him more is more

601
00:30:34,890 --> 00:30:41,430
Wiley this possible and people are doing

602
00:30:38,730 --> 00:30:43,380
that to taint the data to implement a

603
00:30:41,430 --> 00:30:45,300
taint tracking engine essentially in

604
00:30:43,380 --> 00:30:47,760
your let's say server-side code with

605
00:30:45,300 --> 00:30:49,770
whatever technology stocks you're using

606
00:30:47,760 --> 00:30:52,710
it will be Java PHP or whatever

607
00:30:49,770 --> 00:30:55,790
this one is doable whereas for say

608
00:30:52,710 --> 00:30:58,170
injection on the client-side or Dom XSS

609
00:30:55,790 --> 00:31:00,180
don't based exercise you don't really

610
00:30:58,170 --> 00:31:02,480
have that like you can't analyze the

611
00:31:00,180 --> 00:31:04,410
JavaScript code enough you can't

612
00:31:02,480 --> 00:31:06,510
statically analyze it in order to

613
00:31:04,410 --> 00:31:08,250
successfully taint the data on the

614
00:31:06,510 --> 00:31:12,360
client in the browser therefore you

615
00:31:08,250 --> 00:31:14,880
cannot with this approach only address

616
00:31:12,360 --> 00:31:18,750
you don't buy successors but that's one

617
00:31:14,880 --> 00:31:23,790
what you usually do beauty you ensure

618
00:31:18,750 --> 00:31:26,910
that in sync points you actually have

619
00:31:23,790 --> 00:31:29,760
data that is validated either on the

620
00:31:26,910 --> 00:31:31,320
even on the client-side in JavaScript so

621
00:31:29,760 --> 00:31:33,900
if you have something that comes either

622
00:31:31,320 --> 00:31:37,250
from a URL and then you use it into your

623
00:31:33,900 --> 00:31:40,320
sink which can trigger a type of a

624
00:31:37,250 --> 00:31:45,720
cross-site scripting Dominic excesses

625
00:31:40,320 --> 00:31:50,429
you still validate it there are more if

626
00:31:45,720 --> 00:31:52,560
you don't know then probably a good you

627
00:31:50,430 --> 00:31:56,070
might use a library that will deal with

628
00:31:52,560 --> 00:31:58,980
that one and there is a library of that

629
00:31:56,070 --> 00:32:01,560
Mario don't Parsa that Mario created

630
00:31:58,980 --> 00:32:04,530
that can deal with those terms you refer

631
00:32:01,560 --> 00:32:07,530
yeah yeah don't you don't you fire that

632
00:32:04,530 --> 00:32:12,560
can deal with those type of more complex

633
00:32:07,530 --> 00:32:16,660
type of possible things oh yes thank you

634
00:32:12,560 --> 00:32:19,219
okay thank you very much

635
00:32:16,660 --> 00:32:19,219
[Applause]

