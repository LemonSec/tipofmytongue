1
00:00:00,030 --> 00:00:06,779
all right so hello everyone welcome to

2
00:00:04,799 --> 00:00:08,519
this talk about common API security

3
00:00:06,779 --> 00:00:10,019
pitfalls a disclaimer I'm used to

4
00:00:08,519 --> 00:00:11,849
walking around when I present but I

5
00:00:10,019 --> 00:00:12,630
there's only like a meter here so if I

6
00:00:11,849 --> 00:00:15,450
disappear

7
00:00:12,630 --> 00:00:19,020
please come look for me behind next to

8
00:00:15,450 --> 00:00:20,880
the stage so lunch is up 1250 we have 30

9
00:00:19,020 --> 00:00:22,830
minutes to talk about API security and

10
00:00:20,880 --> 00:00:25,650
then you can get some delicious food

11
00:00:22,830 --> 00:00:27,778
here at this great conference let me

12
00:00:25,650 --> 00:00:29,330
talk about API security let's let's set

13
00:00:27,779 --> 00:00:31,289
the scene so we're going to talk about

14
00:00:29,330 --> 00:00:33,599
web applications we're going to talk

15
00:00:31,289 --> 00:00:34,920
about an application being loaded from a

16
00:00:33,600 --> 00:00:36,780
server in this case it's an application

17
00:00:34,920 --> 00:00:38,550
to post some restaurant reviews and

18
00:00:36,780 --> 00:00:40,440
essentially when the application loads

19
00:00:38,550 --> 00:00:42,180
its gonna contact an API it's going to

20
00:00:40,440 --> 00:00:44,789
fetch some data it's gonna perform some

21
00:00:42,180 --> 00:00:47,190
operations at against an API and that's

22
00:00:44,789 --> 00:00:50,070
what we're gonna talk about in this

23
00:00:47,190 --> 00:00:51,629
presentation of course web applications

24
00:00:50,070 --> 00:00:53,190
we all know that it's not only about

25
00:00:51,629 --> 00:00:55,140
applications anymore today you have

26
00:00:53,190 --> 00:00:57,539
mobile applications which are often also

27
00:00:55,140 --> 00:00:59,430
web applications just packaged in kind

28
00:00:57,539 --> 00:01:01,649
of a mobile browser and embedded browser

29
00:00:59,430 --> 00:01:03,930
but that's essentially the gist of what

30
00:01:01,649 --> 00:01:05,519
we're gonna talk about why this talk

31
00:01:03,930 --> 00:01:08,369
well actually this talk was kind of

32
00:01:05,519 --> 00:01:10,049
inspired by the AUSA top 10 from 2017

33
00:01:08,369 --> 00:01:12,390
you may remember that there was some

34
00:01:10,049 --> 00:01:14,400
kind of a controversy about that top 10

35
00:01:12,390 --> 00:01:16,049
no longer talk about that but in one of

36
00:01:14,400 --> 00:01:18,360
these release candidates they had an

37
00:01:16,049 --> 00:01:20,040
item under protected api's it was

38
00:01:18,360 --> 00:01:22,229
explicitly listed there as this is a

39
00:01:20,040 --> 00:01:23,670
major problem of course one of the

40
00:01:22,229 --> 00:01:25,530
things you see here is that the

41
00:01:23,670 --> 00:01:28,259
vulnerabilities listed there aren't very

42
00:01:25,530 --> 00:01:30,540
a P I specific of course they do appear

43
00:01:28,259 --> 00:01:32,159
in API wrote but they're reincarnation

44
00:01:30,540 --> 00:01:34,710
zuv previously existing vulnerabilities

45
00:01:32,159 --> 00:01:36,240
so these things that we had before in

46
00:01:34,710 --> 00:01:39,030
traditional applications we start seeing

47
00:01:36,240 --> 00:01:41,280
some version of that vulnerability in

48
00:01:39,030 --> 00:01:42,960
API as well by the way tomorrow there's

49
00:01:41,280 --> 00:01:44,009
a project presentation on an API

50
00:01:42,960 --> 00:01:47,130
security top ten

51
00:01:44,009 --> 00:01:49,350
so they're actually deepening this whole

52
00:01:47,130 --> 00:01:52,259
API security topic in within OS or a

53
00:01:49,350 --> 00:01:54,720
highly recommend you go there as well

54
00:01:52,259 --> 00:01:56,159
before we get started about actual API

55
00:01:54,720 --> 00:01:56,640
security pitfalls a small word about

56
00:01:56,159 --> 00:01:58,560
myself

57
00:01:56,640 --> 00:02:00,540
I'm Philip Dirac and from Belgium

58
00:01:58,560 --> 00:02:01,740
there's a lot of stuff on this slides

59
00:02:00,540 --> 00:02:03,750
you don't need to remember all of it

60
00:02:01,740 --> 00:02:06,210
just remember that I'm a trainer so I

61
00:02:03,750 --> 00:02:09,119
teach developers how to build secure

62
00:02:06,210 --> 00:02:10,679
software that's my main activity in my

63
00:02:09,119 --> 00:02:12,980
company called pragmatic web security

64
00:02:10,679 --> 00:02:14,900
and I'm also the organizer of a core

65
00:02:12,980 --> 00:02:16,579
in Belgium called second live everything

66
00:02:14,900 --> 00:02:18,409
is on this slide look it up during lunch

67
00:02:16,580 --> 00:02:20,510
talk to me during lunch I'm a very

68
00:02:18,409 --> 00:02:23,209
friendly guy so I don't mind talking to

69
00:02:20,510 --> 00:02:25,940
all of you over lunch but you're here

70
00:02:23,209 --> 00:02:28,640
for API security not for this stuff so

71
00:02:25,940 --> 00:02:30,410
let's set the baseline let's let's set a

72
00:02:28,640 --> 00:02:32,109
basic point of where we're gonna start

73
00:02:30,410 --> 00:02:35,680
we're gonna start by talking about

74
00:02:32,110 --> 00:02:38,989
German smart watches these smart watches

75
00:02:35,680 --> 00:02:40,310
for children you can put them on your

76
00:02:38,989 --> 00:02:42,140
kids and you can track where they are

77
00:02:40,310 --> 00:02:43,730
and see if they get home safely from

78
00:02:42,140 --> 00:02:46,819
school or whatever you want to do with

79
00:02:43,730 --> 00:02:49,548
your kids but they had an API and

80
00:02:46,819 --> 00:02:51,708
security wasn't too good it was so bad

81
00:02:49,549 --> 00:02:53,180
that Germany actually banned the use of

82
00:02:51,709 --> 00:02:54,620
these are the sale of these smart

83
00:02:53,180 --> 00:02:56,390
watches they said like with all due

84
00:02:54,620 --> 00:02:58,069
respect but we're dealing with kids here

85
00:02:56,390 --> 00:03:01,339
and the security is so bad you're not

86
00:02:58,069 --> 00:03:03,410
allowed to sell this anymore usually I

87
00:03:01,340 --> 00:03:05,510
don't like talking about companies that

88
00:03:03,410 --> 00:03:06,590
get it wrong because we all know it's

89
00:03:05,510 --> 00:03:08,239
hard to get it right

90
00:03:06,590 --> 00:03:10,579
but what I want to talk about here is

91
00:03:08,239 --> 00:03:12,709
that a year later so they got banned

92
00:03:10,579 --> 00:03:14,780
they supposedly fix their products and

93
00:03:12,709 --> 00:03:17,239
here later researchers took another look

94
00:03:14,780 --> 00:03:19,760
at their api's and they discovered a

95
00:03:17,239 --> 00:03:22,069
parameter saying user grade with a

96
00:03:19,760 --> 00:03:23,929
numerical value and it turns out if you

97
00:03:22,069 --> 00:03:28,849
change that numerical value to 1

98
00:03:23,930 --> 00:03:31,730
you became admin that's the baseline

99
00:03:28,849 --> 00:03:33,649
we're gonna start here this is non

100
00:03:31,730 --> 00:03:35,840
existing security so first of all you

101
00:03:33,650 --> 00:03:37,639
shouldn't be doing that but we're going

102
00:03:35,840 --> 00:03:39,500
to talk about real issues on top of that

103
00:03:37,639 --> 00:03:41,780
so we're gonna start from this point on

104
00:03:39,500 --> 00:03:44,120
and we're gonna try talk about certain

105
00:03:41,780 --> 00:03:45,590
things that you actually do get wrong in

106
00:03:44,120 --> 00:03:48,019
your API so you might want to pay

107
00:03:45,590 --> 00:03:50,690
attention to one of the things I want to

108
00:03:48,019 --> 00:03:52,010
talk about first is referring to objects

109
00:03:50,690 --> 00:03:54,769
in your API this is a story from

110
00:03:52,010 --> 00:03:57,260
t-mobile where they had an API to come

111
00:03:54,769 --> 00:03:58,849
to consult your account details and how

112
00:03:57,260 --> 00:04:00,200
they did that is they you send a request

113
00:03:58,849 --> 00:04:01,668
to the backend and they gave you your

114
00:04:00,200 --> 00:04:02,958
account it doesn't how they refer to

115
00:04:01,669 --> 00:04:04,549
your account is with a phone number

116
00:04:02,959 --> 00:04:05,629
because there are phone company and a

117
00:04:04,549 --> 00:04:08,389
phone number is kind of a unique

118
00:04:05,629 --> 00:04:11,090
identifier so why not why not use that

119
00:04:08,389 --> 00:04:13,879
phone number to actually refer to the

120
00:04:11,090 --> 00:04:15,829
account but they forgot to implement a

121
00:04:13,879 --> 00:04:17,630
proper authorization check so if I knew

122
00:04:15,829 --> 00:04:18,918
your phone number and I substituted the

123
00:04:17,630 --> 00:04:20,798
phone number in the API call

124
00:04:18,918 --> 00:04:23,719
I could yet your account details and

125
00:04:20,798 --> 00:04:25,340
that's obviously not something that you

126
00:04:23,719 --> 00:04:26,599
want happening in your API and this

127
00:04:25,340 --> 00:04:28,969
happens in a lot of places

128
00:04:26,600 --> 00:04:30,740
the mobile is on a slide here but AT&T

129
00:04:28,970 --> 00:04:33,290
had the same problem and telefónica and

130
00:04:30,740 --> 00:04:34,670
Spain had the same problem and that's a

131
00:04:33,290 --> 00:04:36,920
common vulnerability and it's known as

132
00:04:34,670 --> 00:04:38,540
an insecure direct object reference and

133
00:04:36,920 --> 00:04:39,650
essentially the underlying problem is an

134
00:04:38,540 --> 00:04:42,680
authorization problem

135
00:04:39,650 --> 00:04:44,150
you check many at API is just like the

136
00:04:42,680 --> 00:04:46,850
mobile check if the user is

137
00:04:44,150 --> 00:04:48,620
authenticated but they forgot to check

138
00:04:46,850 --> 00:04:50,900
if you're actually supposed to access

139
00:04:48,620 --> 00:04:52,850
this particular object and these things

140
00:04:50,900 --> 00:04:55,580
are unfortunately very common because

141
00:04:52,850 --> 00:04:57,710
api's do work with identifiers here's an

142
00:04:55,580 --> 00:04:59,960
example of a tutorial I found online

143
00:04:57,710 --> 00:05:01,669
it's building a universal API in ten

144
00:04:59,960 --> 00:05:03,609
minutes I can assure you in ten minutes

145
00:05:01,670 --> 00:05:07,010
there's not gonna be security in there

146
00:05:03,610 --> 00:05:09,020
but that's of course also not a point of

147
00:05:07,010 --> 00:05:10,610
tutorial but this is how you get started

148
00:05:09,020 --> 00:05:13,280
like oh yeah this is a to-do application

149
00:05:10,610 --> 00:05:15,560
of course very a simple example and you

150
00:05:13,280 --> 00:05:16,880
get a function to read a task from that

151
00:05:15,560 --> 00:05:18,230
application very straightforward very

152
00:05:16,880 --> 00:05:19,940
simple you implement some delete

153
00:05:18,230 --> 00:05:21,650
features you can see there's no

154
00:05:19,940 --> 00:05:24,080
authentication or authorization because

155
00:05:21,650 --> 00:05:26,239
that's not the point of the tutorial so

156
00:05:24,080 --> 00:05:27,500
if you start building an API you start

157
00:05:26,240 --> 00:05:29,630
with a proof of concept then you add

158
00:05:27,500 --> 00:05:31,040
authentication and then you'll think

159
00:05:29,630 --> 00:05:33,230
about oh yeah I need to check if user is

160
00:05:31,040 --> 00:05:35,150
authenticated and you implement that but

161
00:05:33,230 --> 00:05:37,190
if unless you think about hey I also

162
00:05:35,150 --> 00:05:38,479
need to check if I'm reading or deleting

163
00:05:37,190 --> 00:05:40,430
a task that the user is actually the

164
00:05:38,480 --> 00:05:41,840
owner of the task or if you have a more

165
00:05:40,430 --> 00:05:44,120
complex permission model that the user

166
00:05:41,840 --> 00:05:46,010
has access to that task through a shared

167
00:05:44,120 --> 00:05:47,870
environment or whatever and that's where

168
00:05:46,010 --> 00:05:50,450
things get tricky and unless you start

169
00:05:47,870 --> 00:05:52,790
or unless you audit your code explicitly

170
00:05:50,450 --> 00:05:54,320
for these issues you're very likely to

171
00:05:52,790 --> 00:05:55,820
miss them and that's exactly what

172
00:05:54,320 --> 00:05:57,710
happened in the t-mobile case and the

173
00:05:55,820 --> 00:06:00,230
telefónica case and so many other

174
00:05:57,710 --> 00:06:02,539
examples out there and these things

175
00:06:00,230 --> 00:06:03,440
really do happen and they are really

176
00:06:02,540 --> 00:06:05,690
problematic

177
00:06:03,440 --> 00:06:08,900
so the first pitfall is lack of proper

178
00:06:05,690 --> 00:06:11,360
authorization you need to audit your

179
00:06:08,900 --> 00:06:13,429
code every endpoint or every entry point

180
00:06:11,360 --> 00:06:15,020
you need to check what authorization

181
00:06:13,430 --> 00:06:17,630
checks do I need to have force here and

182
00:06:15,020 --> 00:06:20,630
that's a very hard problem to solve in

183
00:06:17,630 --> 00:06:22,730
real applications by the way the slides

184
00:06:20,630 --> 00:06:24,380
you're free to take pictures as much as

185
00:06:22,730 --> 00:06:26,330
you want but if you want a PDF of the

186
00:06:24,380 --> 00:06:28,250
slides are available online on my

187
00:06:26,330 --> 00:06:29,840
Twitter account you can find a link to

188
00:06:28,250 --> 00:06:31,580
the slides and there's a lot more slides

189
00:06:29,840 --> 00:06:32,840
in there as well sometimes I do longer

190
00:06:31,580 --> 00:06:35,690
versions of the talk so there's more

191
00:06:32,840 --> 00:06:38,000
pitfalls but there's also content about

192
00:06:35,690 --> 00:06:38,740
some vulnerabilities and solutions there

193
00:06:38,000 --> 00:06:40,700
as well

194
00:06:38,740 --> 00:06:42,530
authorization how do you do

195
00:06:40,700 --> 00:06:43,820
authorization well to do authorization

196
00:06:42,530 --> 00:06:46,070
you probably need to know who's making

197
00:06:43,820 --> 00:06:47,960
the call so if you want to know who's

198
00:06:46,070 --> 00:06:49,340
making the call very traditionally if

199
00:06:47,960 --> 00:06:51,729
you have a client and a back-end you

200
00:06:49,340 --> 00:06:53,960
used to have a session and a session

201
00:06:51,730 --> 00:06:55,340
well it's kind of very easy you have

202
00:06:53,960 --> 00:06:57,530
this session object you can know okay

203
00:06:55,340 --> 00:07:00,260
this is Phillip making the call yes I

204
00:06:57,530 --> 00:07:01,609
want that or not and sessions work very

205
00:07:00,260 --> 00:07:03,680
well if you have a small amount of

206
00:07:01,610 --> 00:07:06,560
clients and a small amount of servers

207
00:07:03,680 --> 00:07:08,210
and this is a state stateful system it's

208
00:07:06,560 --> 00:07:09,440
probably another REST API because the

209
00:07:08,210 --> 00:07:11,450
rest is kind of supposed to be stateless

210
00:07:09,440 --> 00:07:13,940
but this is how we use to build

211
00:07:11,450 --> 00:07:15,440
applications of course today if you're

212
00:07:13,940 --> 00:07:16,760
building an API application you're some

213
00:07:15,440 --> 00:07:18,680
probably building something like this

214
00:07:16,760 --> 00:07:19,940
you have a lot of clients a lot of

215
00:07:18,680 --> 00:07:21,650
back-end systems you don't want state

216
00:07:19,940 --> 00:07:24,050
you know on sticky sessions or session

217
00:07:21,650 --> 00:07:25,820
replication because that's we don't like

218
00:07:24,050 --> 00:07:29,960
that so we want the stateless system

219
00:07:25,820 --> 00:07:33,469
however I would argue that if you only

220
00:07:29,960 --> 00:07:34,909
have a limited number of clients if you

221
00:07:33,470 --> 00:07:37,280
know up front this is only for a couple

222
00:07:34,910 --> 00:07:38,690
of hundred users it might not be worth

223
00:07:37,280 --> 00:07:40,520
switching the whole mechanism to a

224
00:07:38,690 --> 00:07:42,260
stateless mechanism because anyone who

225
00:07:40,520 --> 00:07:44,570
has implemented a stateless API knows

226
00:07:42,260 --> 00:07:45,650
it's not that easy to do there's a lot

227
00:07:44,570 --> 00:07:47,480
of things you have to take into account

228
00:07:45,650 --> 00:07:50,239
and a lot of things change because of

229
00:07:47,480 --> 00:07:52,070
that new paradigm and this is something

230
00:07:50,240 --> 00:07:54,830
we understand very well this is

231
00:07:52,070 --> 00:07:57,140
something that has some pitfalls that

232
00:07:54,830 --> 00:07:59,780
some certain things you need take into

233
00:07:57,140 --> 00:08:01,640
account so i don't say i'm not saying

234
00:07:59,780 --> 00:08:03,289
that stateless api's are bad or stateful

235
00:08:01,640 --> 00:08:05,210
api's are good I'm saying that there is

236
00:08:03,290 --> 00:08:06,980
a use case for both of them and I don't

237
00:08:05,210 --> 00:08:09,229
see the benefit of switching to a whole

238
00:08:06,980 --> 00:08:11,930
new system just for the sake of making

239
00:08:09,230 --> 00:08:12,680
it stateless if you don't need it why go

240
00:08:11,930 --> 00:08:14,180
through the effort

241
00:08:12,680 --> 00:08:15,950
why switch something that your

242
00:08:14,180 --> 00:08:17,510
developers have understood for 15 years

243
00:08:15,950 --> 00:08:19,610
to something new where they might make

244
00:08:17,510 --> 00:08:22,340
mistakes that are not supposed to be

245
00:08:19,610 --> 00:08:24,440
there so think about that switch to a

246
00:08:22,340 --> 00:08:26,060
stateless API for the right reasons of

247
00:08:24,440 --> 00:08:28,460
course I'm also not recommending to

248
00:08:26,060 --> 00:08:30,830
write code that depends on the actual

249
00:08:28,460 --> 00:08:32,090
state but keeping track of authorization

250
00:08:30,830 --> 00:08:33,978
or authentication information on the

251
00:08:32,090 --> 00:08:37,310
server it's not that big of a violation

252
00:08:33,979 --> 00:08:39,169
of the statelessness so if you want to

253
00:08:37,309 --> 00:08:40,489
show this in a picture this is where you

254
00:08:39,169 --> 00:08:42,740
have your states in a traditional

255
00:08:40,490 --> 00:08:44,630
application in your stateless api you

256
00:08:42,740 --> 00:08:46,010
move this to the client you're

257
00:08:44,630 --> 00:08:47,270
essentially pushing this to the client

258
00:08:46,010 --> 00:08:48,860
so you can don't have to keep anything

259
00:08:47,270 --> 00:08:50,750
on the backends you can spin up a

260
00:08:48,860 --> 00:08:51,920
thousand more instances of that API and

261
00:08:50,750 --> 00:08:54,589
load

262
00:08:51,920 --> 00:08:57,110
a lot of it just like you want to sure

263
00:08:54,589 --> 00:08:59,209
you can do it it however on a PowerPoint

264
00:08:57,110 --> 00:09:01,160
slide is easy to do it's easy to move

265
00:08:59,209 --> 00:09:03,829
this to the client and we're done right

266
00:09:01,160 --> 00:09:05,839
well in reality it's not that simple in

267
00:09:03,829 --> 00:09:07,760
reality this has a very very big impact

268
00:09:05,839 --> 00:09:10,510
because now we're making authorisation

269
00:09:07,760 --> 00:09:13,399
decisions with data kept on the client

270
00:09:10,510 --> 00:09:15,649
data the attacker can modify data the

271
00:09:13,399 --> 00:09:17,480
attacker can tamper it and that makes

272
00:09:15,649 --> 00:09:19,399
this a very dangerous pattern and

273
00:09:17,480 --> 00:09:21,320
requires us to take certain things into

274
00:09:19,399 --> 00:09:23,420
account most important thing here is

275
00:09:21,320 --> 00:09:25,220
integrity you need to make sure that

276
00:09:23,420 --> 00:09:27,490
whenever whatever you get back from the

277
00:09:25,220 --> 00:09:30,380
client has not been tampered to it

278
00:09:27,490 --> 00:09:31,579
confidentiality also plays a role but

279
00:09:30,380 --> 00:09:32,410
I'm not going to talk about that in

280
00:09:31,579 --> 00:09:35,269
detail here

281
00:09:32,410 --> 00:09:37,519
how does integrity work well chances are

282
00:09:35,269 --> 00:09:38,930
if you're moving towards keeping State

283
00:09:37,519 --> 00:09:43,190
on the client you're using something

284
00:09:38,930 --> 00:09:44,630
called JWT job our JSON web tokens this

285
00:09:43,190 --> 00:09:46,430
is what the JSON web token looks like

286
00:09:44,630 --> 00:09:49,100
well reality you don't get a fancy

287
00:09:46,430 --> 00:09:50,899
colors it's just a blob of data but if

288
00:09:49,100 --> 00:09:53,269
you put this on this website job of i/o

289
00:09:50,899 --> 00:09:55,699
you get this fancy color scheme and a

290
00:09:53,269 --> 00:09:58,070
decomposition of the token so this is

291
00:09:55,699 --> 00:10:00,709
the base64 representation and these are

292
00:09:58,070 --> 00:10:03,140
different parts split out into their

293
00:10:00,709 --> 00:10:04,670
respective elements you can see that the

294
00:10:03,140 --> 00:10:06,920
purple part or the middle here is the

295
00:10:04,670 --> 00:10:09,079
payload this is the actual data very

296
00:10:06,920 --> 00:10:11,420
simple example here in reality the data

297
00:10:09,079 --> 00:10:13,099
is going to be a lot there's going to be

298
00:10:11,420 --> 00:10:15,860
a lot more in there and that's

299
00:10:13,100 --> 00:10:18,170
essentially what's going on and one of

300
00:10:15,860 --> 00:10:20,079
the good things about charts is that

301
00:10:18,170 --> 00:10:23,870
whenever you're using that you're also

302
00:10:20,079 --> 00:10:26,300
but 99.9% of cases also using a

303
00:10:23,870 --> 00:10:28,399
signature and the signature is there to

304
00:10:26,300 --> 00:10:30,740
protect integrity the signature is

305
00:10:28,399 --> 00:10:33,050
generated over the header and a payload

306
00:10:30,740 --> 00:10:34,940
and will ensure if you verify that when

307
00:10:33,050 --> 00:10:36,680
it comes back in ensure that the token

308
00:10:34,940 --> 00:10:39,649
has not been tampered with and if it has

309
00:10:36,680 --> 00:10:43,910
been Temper to it it will be rejected if

310
00:10:39,649 --> 00:10:46,130
you write that code correctly here's an

311
00:10:43,910 --> 00:10:48,199
example of how to not do it correctly so

312
00:10:46,130 --> 00:10:50,389
the API is to do this there are plenty

313
00:10:48,199 --> 00:10:52,670
of library supporting job operations and

314
00:10:50,389 --> 00:10:54,649
many of them support functions like

315
00:10:52,670 --> 00:10:57,110
decode which actually get you the data

316
00:10:54,649 --> 00:10:59,510
out of basics before without verifying

317
00:10:57,110 --> 00:11:02,300
the signature what it should be doing

318
00:10:59,510 --> 00:11:03,880
instead is using the a bit more advanced

319
00:11:02,300 --> 00:11:05,979
parts of the API

320
00:11:03,880 --> 00:11:08,350
we actually have an algorithm you build

321
00:11:05,980 --> 00:11:10,720
a verifier and then you actually verify

322
00:11:08,350 --> 00:11:14,079
the signature but this is a very easy

323
00:11:10,720 --> 00:11:15,250
pitfall because if a developer doesn't

324
00:11:14,079 --> 00:11:16,508
really know what the signature is

325
00:11:15,250 --> 00:11:18,279
supposed to do and doesn't really know

326
00:11:16,509 --> 00:11:20,800
the difference between decode and verify

327
00:11:18,279 --> 00:11:23,560
the signature chances are that you make

328
00:11:20,800 --> 00:11:26,319
a mistake in your application and again

329
00:11:23,560 --> 00:11:28,089
this will work the top code example from

330
00:11:26,319 --> 00:11:30,339
a functional perspective will work and

331
00:11:28,089 --> 00:11:33,250
unless you write a unit test giving a

332
00:11:30,339 --> 00:11:35,769
fraudulent token with a real payload but

333
00:11:33,250 --> 00:11:37,690
a mismatch in the signature unless you

334
00:11:35,769 --> 00:11:39,850
write a test you will not detect this

335
00:11:37,690 --> 00:11:42,519
problem until someone else detects it

336
00:11:39,850 --> 00:11:45,610
for you and hopefully they report it and

337
00:11:42,519 --> 00:11:47,769
not exploit it but that's kind of a big

338
00:11:45,610 --> 00:11:49,839
gamble to take so this is again a

339
00:11:47,769 --> 00:11:51,790
pitiful miss handling client side

340
00:11:49,839 --> 00:11:53,889
session data this is only one example

341
00:11:51,790 --> 00:11:56,319
there's other examples where these

342
00:11:53,889 --> 00:11:58,180
things can go wrong as well but this is

343
00:11:56,319 --> 00:11:59,829
something that makes this whole

344
00:11:58,180 --> 00:12:01,149
mechanism a bit more tricky you need to

345
00:11:59,829 --> 00:12:03,699
understand what's happening here

346
00:12:01,149 --> 00:12:05,230
by the way jots also have support for

347
00:12:03,699 --> 00:12:06,969
encryption so if you want to store

348
00:12:05,230 --> 00:12:10,149
confidential data in a job which is

349
00:12:06,970 --> 00:12:11,860
already kind of a a dangerous thing to

350
00:12:10,149 --> 00:12:13,810
do you can encrypt the whole token

351
00:12:11,860 --> 00:12:16,089
before you send it to the browser so if

352
00:12:13,810 --> 00:12:17,979
you're storing some sensitive thing

353
00:12:16,089 --> 00:12:20,139
there that might need some protection

354
00:12:17,980 --> 00:12:22,240
for privacy reasons you definitely want

355
00:12:20,139 --> 00:12:25,449
to encrypt that as well however

356
00:12:22,240 --> 00:12:27,370
encryption is even more complex to set

357
00:12:25,449 --> 00:12:28,870
up I'm not going to talk about that here

358
00:12:27,370 --> 00:12:33,160
but if you have any questions feel free

359
00:12:28,870 --> 00:12:35,079
to ask so back to our fancy jot here she

360
00:12:33,160 --> 00:12:36,939
looked closely you can see in a

361
00:12:35,079 --> 00:12:40,540
signature part that we're using an H Mac

362
00:12:36,939 --> 00:12:43,060
an H Mac uses as input the data and then

363
00:12:40,540 --> 00:12:44,649
a secret key of course in reality you

364
00:12:43,060 --> 00:12:47,649
don't call it super secret H Mickey

365
00:12:44,649 --> 00:12:49,029
that's usually not a very good a key to

366
00:12:47,649 --> 00:12:52,089
use and don't put it on power point

367
00:12:49,029 --> 00:12:54,069
slides either so keep that in mind but

368
00:12:52,089 --> 00:12:55,930
one of the properties of H max here's

369
00:12:54,069 --> 00:12:57,550
how an h-back works and the properties

370
00:12:55,930 --> 00:12:59,620
are actually quite interesting so what

371
00:12:57,550 --> 00:13:01,719
you get is you get a data you use an H

372
00:12:59,620 --> 00:13:03,670
Mac algorithm plan if libraries have H

373
00:13:01,720 --> 00:13:05,529
like algorithms and you've given the

374
00:13:03,670 --> 00:13:07,599
data and a secret key and out comes this

375
00:13:05,529 --> 00:13:09,730
H max value which you can ship to the

376
00:13:07,600 --> 00:13:11,050
client along with the date of course the

377
00:13:09,730 --> 00:13:12,250
chart library does all of this for you

378
00:13:11,050 --> 00:13:14,439
but that's what happened what's happens

379
00:13:12,250 --> 00:13:17,139
on the node how do you use it well

380
00:13:14,439 --> 00:13:17,770
whenever you get a data and a signature

381
00:13:17,139 --> 00:13:19,720
back

382
00:13:17,770 --> 00:13:22,240
a client or another party you can verify

383
00:13:19,720 --> 00:13:24,220
that you can recalculate the HVAC using

384
00:13:22,240 --> 00:13:26,260
the data and a secret key and outcomes

385
00:13:24,220 --> 00:13:29,590
this value you can compare that to the

386
00:13:26,260 --> 00:13:30,939
actual signature and if they match if

387
00:13:29,590 --> 00:13:32,650
the signatures are the same then you

388
00:13:30,940 --> 00:13:33,970
know that the inputs to the HVAC

389
00:13:32,650 --> 00:13:36,340
function were the same and if they don't

390
00:13:33,970 --> 00:13:37,840
match you know that something is wrong

391
00:13:36,340 --> 00:13:39,400
you know that either

392
00:13:37,840 --> 00:13:40,690
the key has changed which you have

393
00:13:39,400 --> 00:13:42,750
control over so that's not going to be

394
00:13:40,690 --> 00:13:46,240
the case so the data has changed somehow

395
00:13:42,750 --> 00:13:48,940
from here to here so you just throw the

396
00:13:46,240 --> 00:13:50,770
token out very very important do not

397
00:13:48,940 --> 00:13:54,250
accept a token if the signature

398
00:13:50,770 --> 00:13:56,470
mismatches very interesting to see here

399
00:13:54,250 --> 00:13:58,330
this is also known as a symmetric

400
00:13:56,470 --> 00:14:00,490
signature because you use the same key

401
00:13:58,330 --> 00:14:03,400
to generate signatures and to verify

402
00:14:00,490 --> 00:14:06,310
signatures very easy right you just

403
00:14:03,400 --> 00:14:08,230
define a string or not a string you a

404
00:14:06,310 --> 00:14:10,359
value in a vault you fetch data you can

405
00:14:08,230 --> 00:14:13,990
generate and verify tokens as much as

406
00:14:10,360 --> 00:14:15,790
you want however the moment you're

407
00:14:13,990 --> 00:14:17,890
building or sharing tokens with other

408
00:14:15,790 --> 00:14:20,230
applications or other services this

409
00:14:17,890 --> 00:14:21,970
becomes a problem because if you

410
00:14:20,230 --> 00:14:24,580
generate the token and I want to verify

411
00:14:21,970 --> 00:14:26,460
it I'm gonna need your secret will you

412
00:14:24,580 --> 00:14:29,320
give your secret to me

413
00:14:26,460 --> 00:14:32,410
probably not you're not supposed to

414
00:14:29,320 --> 00:14:34,240
either because I'm very untrustworthy no

415
00:14:32,410 --> 00:14:36,130
seriously if you start sharing this with

416
00:14:34,240 --> 00:14:37,780
other applications it becomes a problem

417
00:14:36,130 --> 00:14:39,640
because the moment somebody has a secret

418
00:14:37,780 --> 00:14:43,209
key they can generate arbitrary tokens

419
00:14:39,640 --> 00:14:45,520
so this use case for hmx is very very

420
00:14:43,210 --> 00:14:47,410
limited it's single application use only

421
00:14:45,520 --> 00:14:48,939
you have one application generating

422
00:14:47,410 --> 00:14:50,680
stuff and getting it back sure you can

423
00:14:48,940 --> 00:14:53,020
use this but even the moment you're

424
00:14:50,680 --> 00:14:55,180
using two applications sharing that

425
00:14:53,020 --> 00:14:56,910
secret among these applications is

426
00:14:55,180 --> 00:15:00,939
probably a recipe for disaster

427
00:14:56,910 --> 00:15:03,069
fortunately just support a second way of

428
00:15:00,940 --> 00:15:05,020
signing them you can use an asymmetric

429
00:15:03,070 --> 00:15:06,850
signature and here's how it works are

430
00:15:05,020 --> 00:15:08,829
from a very high level you have the data

431
00:15:06,850 --> 00:15:11,980
and you have a signing algorithm like

432
00:15:08,830 --> 00:15:14,460
RSA you feed it a key and out comes a

433
00:15:11,980 --> 00:15:16,990
signature very easy very straightforward

434
00:15:14,460 --> 00:15:19,480
this is what we send to the client and

435
00:15:16,990 --> 00:15:22,000
what you get back whenever the job comes

436
00:15:19,480 --> 00:15:25,710
back in and to verify this job now we

437
00:15:22,000 --> 00:15:28,540
can use a verification function call

438
00:15:25,710 --> 00:15:29,650
libraries implement this as a generic

439
00:15:28,540 --> 00:15:31,270
function call so you don't have to worry

440
00:15:29,650 --> 00:15:33,490
about the details and you feed it up

441
00:15:31,270 --> 00:15:35,740
the key and it gives you a boolean

442
00:15:33,490 --> 00:15:38,080
result through or false if it's true you

443
00:15:35,740 --> 00:15:39,730
know that the message is the same as the

444
00:15:38,080 --> 00:15:41,920
one has been signed and if it's false

445
00:15:39,730 --> 00:15:43,360
you know that something has changed this

446
00:15:41,920 --> 00:15:45,610
is actually a very interesting way of

447
00:15:43,360 --> 00:15:47,710
doing things because now one service can

448
00:15:45,610 --> 00:15:49,690
generate signatures with a private key

449
00:15:47,710 --> 00:15:51,910
and everybody else can verify them with

450
00:15:49,690 --> 00:15:53,230
a public key these keys are known as

451
00:15:51,910 --> 00:15:54,550
private and public because the private

452
00:15:53,230 --> 00:15:56,050
one is the one you keep secret and a

453
00:15:54,550 --> 00:15:58,780
public one is the one you distribute to

454
00:15:56,050 --> 00:16:01,180
everyone else and this is how dots are

455
00:15:58,780 --> 00:16:03,610
for example use and open any connect if

456
00:16:01,180 --> 00:16:06,160
you choose login with Google there's

457
00:16:03,610 --> 00:16:08,020
gonna a lot of complicated all that

458
00:16:06,160 --> 00:16:09,490
stuff is gonna happen but in the end the

459
00:16:08,020 --> 00:16:11,740
application is going to receive a chav

460
00:16:09,490 --> 00:16:13,450
token generated by Google signed with

461
00:16:11,740 --> 00:16:15,670
Google's private key which you can

462
00:16:13,450 --> 00:16:17,800
verify with Google's public key and

463
00:16:15,670 --> 00:16:19,569
that's a very powerful mechanism and

464
00:16:17,800 --> 00:16:21,520
that is something that many people are

465
00:16:19,570 --> 00:16:24,760
not even aware of that is available in

466
00:16:21,520 --> 00:16:26,680
the whole chopped library ecosystem so

467
00:16:24,760 --> 00:16:29,290
brings us to the pitfall don't misuse a

468
00:16:26,680 --> 00:16:31,150
signature scheme hmx are only useful

469
00:16:29,290 --> 00:16:32,829
within a single application even if

470
00:16:31,150 --> 00:16:34,689
you're building a microservice

471
00:16:32,830 --> 00:16:37,570
architecture with shots it's recommended

472
00:16:34,690 --> 00:16:40,090
to use public private keys because that

473
00:16:37,570 --> 00:16:41,890
you know which service has generated one

474
00:16:40,090 --> 00:16:44,490
you can verify the signatures with the

475
00:16:41,890 --> 00:16:47,650
public keys and you're good to go

476
00:16:44,490 --> 00:16:49,480
all right of course we're talking about

477
00:16:47,650 --> 00:16:52,270
keys here and if you're talking about

478
00:16:49,480 --> 00:16:54,250
keys we're talking about crypto and

479
00:16:52,270 --> 00:16:56,319
crypto is a very hard thing to get right

480
00:16:54,250 --> 00:16:58,390
and one of the problems many people

481
00:16:56,320 --> 00:17:01,750
don't know about or overlook is key

482
00:16:58,390 --> 00:17:03,760
management you're not supposed to use

483
00:17:01,750 --> 00:17:06,430
the same key over and over again you

484
00:17:03,760 --> 00:17:08,500
need to rotate that key every once in a

485
00:17:06,430 --> 00:17:10,810
while and if you rotate keys that means

486
00:17:08,500 --> 00:17:13,150
you might have multiple keys in rotation

487
00:17:10,810 --> 00:17:14,440
multiple keys being used so how how

488
00:17:13,150 --> 00:17:16,690
would you verify signature if you have

489
00:17:14,440 --> 00:17:18,850
five keys like try all five of them and

490
00:17:16,690 --> 00:17:20,830
see if one works well probably not the

491
00:17:18,849 --> 00:17:23,169
best way of doing things so what you

492
00:17:20,829 --> 00:17:25,079
need is you need a way to manage keys

493
00:17:23,170 --> 00:17:28,300
you need a way to identify peace and

494
00:17:25,079 --> 00:17:30,070
jobs again has a mechanism for that so

495
00:17:28,300 --> 00:17:33,100
there are various mechanisms in job

496
00:17:30,070 --> 00:17:35,649
specifications to indicate what key has

497
00:17:33,100 --> 00:17:38,439
been used to sign a particular token the

498
00:17:35,650 --> 00:17:41,800
simplest mechanism is the K ID claim in

499
00:17:38,440 --> 00:17:43,360
the header stands for key identifier so

500
00:17:41,800 --> 00:17:44,639
you can simply include a string based

501
00:17:43,360 --> 00:17:46,679
value which points

502
00:17:44,640 --> 00:17:48,450
to a particular P so let's say that you

503
00:17:46,680 --> 00:17:51,600
have an application using H Max and the

504
00:17:48,450 --> 00:17:53,430
application rotates its P every day it

505
00:17:51,600 --> 00:17:54,750
could use a random identifier to

506
00:17:53,430 --> 00:17:56,490
identify these keys

507
00:17:54,750 --> 00:17:58,260
whenever a token comes in it can read

508
00:17:56,490 --> 00:18:01,260
the header say like oh yeah this was

509
00:17:58,260 --> 00:18:03,780
sign with key 17 fetch that proper key

510
00:18:01,260 --> 00:18:05,820
and verify the signature same thing

511
00:18:03,780 --> 00:18:07,410
happens or it's possible with public

512
00:18:05,820 --> 00:18:09,389
private piece it's just a string based

513
00:18:07,410 --> 00:18:12,900
identifier so if you use that string to

514
00:18:09,390 --> 00:18:15,270
identify key they're good to go there's

515
00:18:12,900 --> 00:18:17,130
more advanced mechanisms as well if you

516
00:18:15,270 --> 00:18:19,110
for example want to do this in a

517
00:18:17,130 --> 00:18:21,600
distributed fashion then you might want

518
00:18:19,110 --> 00:18:23,729
to use key URLs so you can include a URL

519
00:18:21,600 --> 00:18:25,500
in the header saying oh yeah by the way

520
00:18:23,730 --> 00:18:29,250
you can fetch my public keys from this

521
00:18:25,500 --> 00:18:31,350
particular location that's a very very

522
00:18:29,250 --> 00:18:33,060
powerful mechanism allows a dynamic

523
00:18:31,350 --> 00:18:35,399
configuration of keys allows easier

524
00:18:33,060 --> 00:18:36,960
rotation without having to update your

525
00:18:35,400 --> 00:18:39,210
applications over and over again of

526
00:18:36,960 --> 00:18:41,400
course what matters here is that you

527
00:18:39,210 --> 00:18:42,840
don't simply accept key URLs at point

528
00:18:41,400 --> 00:18:44,910
anywhere otherwise I could give you a

529
00:18:42,840 --> 00:18:46,649
token and say like oh yeah you can fetch

530
00:18:44,910 --> 00:18:48,660
the keys from evil that example come and

531
00:18:46,650 --> 00:18:50,820
your application would load them so no

532
00:18:48,660 --> 00:18:53,070
you need to restrict regular load keys

533
00:18:50,820 --> 00:18:55,770
from what keys you consider fell it but

534
00:18:53,070 --> 00:18:58,080
there is a mechanism to handle keys when

535
00:18:55,770 --> 00:19:00,990
you use jaws so brings us here if you

536
00:18:58,080 --> 00:19:02,399
don't think about this upfront you're

537
00:19:00,990 --> 00:19:04,590
gonna have some trouble this is

538
00:19:02,400 --> 00:19:06,360
something that is often overlooked or

539
00:19:04,590 --> 00:19:07,649
not even done at all and that's

540
00:19:06,360 --> 00:19:09,330
definitely something that you need to

541
00:19:07,650 --> 00:19:11,310
think about upfront how will I manage

542
00:19:09,330 --> 00:19:13,199
that what if a key gets compromised how

543
00:19:11,310 --> 00:19:15,120
do I ensure that it's no longer

544
00:19:13,200 --> 00:19:19,650
considered to be valid in my

545
00:19:15,120 --> 00:19:22,409
applications all right so far we talked

546
00:19:19,650 --> 00:19:24,420
about keeping track of that

547
00:19:22,410 --> 00:19:26,250
authorization data representing it

548
00:19:24,420 --> 00:19:28,380
storing it on the client somewhat but

549
00:19:26,250 --> 00:19:31,740
how do you get that back how do you get

550
00:19:28,380 --> 00:19:34,320
a job from the client to the server well

551
00:19:31,740 --> 00:19:35,880
very in very traditional applications we

552
00:19:34,320 --> 00:19:38,700
would use a cookie a cookie with an

553
00:19:35,880 --> 00:19:40,770
identifier and usually not 42 but a more

554
00:19:38,700 --> 00:19:43,140
long and random string that's your

555
00:19:40,770 --> 00:19:45,810
secret identifier to point your

556
00:19:43,140 --> 00:19:47,310
server-side session object if we move to

557
00:19:45,810 --> 00:19:49,139
a stateless system chances are you using

558
00:19:47,310 --> 00:19:51,510
an authorization header with a bearer

559
00:19:49,140 --> 00:19:54,090
type and then your job token as the

560
00:19:51,510 --> 00:19:57,570
value here this is the modern way of

561
00:19:54,090 --> 00:20:00,238
doing things but this is

562
00:19:57,570 --> 00:20:02,249
often referred to as cookies versus

563
00:20:00,239 --> 00:20:04,139
tokens because this is a cookie and this

564
00:20:02,249 --> 00:20:07,470
is token but the comparison doesn't

565
00:20:04,139 --> 00:20:10,408
really make sense because why can't you

566
00:20:07,470 --> 00:20:12,809
put a job in a cookie or an ID in the

567
00:20:10,409 --> 00:20:14,759
authorization header there's nothing

568
00:20:12,809 --> 00:20:16,529
preventing you from doing that and this

569
00:20:14,759 --> 00:20:18,479
looks a bit crazy like come on

570
00:20:16,529 --> 00:20:21,929
nobody does that what are you talking

571
00:20:18,479 --> 00:20:24,450
about well honestly we do because if

572
00:20:21,929 --> 00:20:26,100
you're using all out and the client is

573
00:20:24,450 --> 00:20:27,600
calling an API with an access token

574
00:20:26,100 --> 00:20:29,369
you're probably using the authorization

575
00:20:27,600 --> 00:20:31,649
header if you're using a reference token

576
00:20:29,369 --> 00:20:34,168
you're using this pattern it's not 42

577
00:20:31,649 --> 00:20:35,789
but it's a short identifier pointing to

578
00:20:34,169 --> 00:20:37,649
some state on the authorization server

579
00:20:35,789 --> 00:20:41,039
and if you're using a self-contained

580
00:20:37,649 --> 00:20:43,889
token then you're using and this type of

581
00:20:41,039 --> 00:20:45,539
authorization header and what I'm going

582
00:20:43,889 --> 00:20:47,689
to talk about here is that first of all

583
00:20:45,539 --> 00:20:50,279
cookies versus tokens makes no sense and

584
00:20:47,690 --> 00:20:51,779
it's actually cookies versus the

585
00:20:50,279 --> 00:20:53,700
authorization header because cookies are

586
00:20:51,779 --> 00:20:54,809
a transport mechanism and a storage

587
00:20:53,700 --> 00:20:56,429
mechanism in the browser and the

588
00:20:54,809 --> 00:20:58,590
authorization header is just as well a

589
00:20:56,429 --> 00:20:59,970
transport mechanism but they have

590
00:20:58,590 --> 00:21:02,189
different properties and they have a

591
00:20:59,970 --> 00:21:03,809
certain impact on your application so

592
00:21:02,190 --> 00:21:05,039
let me put them next to each other to

593
00:21:03,809 --> 00:21:07,950
show you what the differences are and

594
00:21:05,039 --> 00:21:10,039
what the impact is first of all both

595
00:21:07,950 --> 00:21:12,239
headers can contain string based data

596
00:21:10,039 --> 00:21:14,158
nobody prevents you from putting a shell

597
00:21:12,239 --> 00:21:16,489
token in a cookie even though it seems

598
00:21:14,159 --> 00:21:19,109
silly it's definitely possible

599
00:21:16,489 --> 00:21:21,479
cookies are designed to work well with a

600
00:21:19,109 --> 00:21:23,489
single domain if you want to use the

601
00:21:21,479 --> 00:21:25,019
same cookie for different domains forget

602
00:21:23,489 --> 00:21:26,789
about it it's not gonna work the web is

603
00:21:25,019 --> 00:21:27,989
not supposed to work like that the

604
00:21:26,789 --> 00:21:29,489
authorization header you add that

605
00:21:27,989 --> 00:21:31,320
manually in your application you can

606
00:21:29,489 --> 00:21:34,830
send it wherever you want that's a

607
00:21:31,320 --> 00:21:37,259
benefit in some cases however cookies

608
00:21:34,830 --> 00:21:38,939
are handled automatically for a cookie

609
00:21:37,259 --> 00:21:40,470
you don't need to write a single line of

610
00:21:38,940 --> 00:21:42,239
code in the client the browser will do

611
00:21:40,470 --> 00:21:43,649
everything for you which is actually

612
00:21:42,239 --> 00:21:45,509
pretty cool for the authorization header

613
00:21:43,649 --> 00:21:48,209
you need to write code need to write go

614
00:21:45,509 --> 00:21:49,889
to fetch whatever you want to keep from

615
00:21:48,210 --> 00:21:50,879
a response from the server stored

616
00:21:49,889 --> 00:21:53,699
somewhere in the browser

617
00:21:50,879 --> 00:21:55,199
reattach it to add girl requests code

618
00:21:53,700 --> 00:21:56,729
you write yourself is code where you can

619
00:21:55,200 --> 00:21:59,309
introduce vulnerabilities that's

620
00:21:56,729 --> 00:22:00,989
unfortunately reality I don't want to go

621
00:21:59,309 --> 00:22:03,989
into detail on examples here but these

622
00:22:00,989 --> 00:22:05,909
things do happen in practice and then

623
00:22:03,989 --> 00:22:07,980
finally and that's maybe the biggest

624
00:22:05,909 --> 00:22:09,130
selling point of cookies cookies work

625
00:22:07,980 --> 00:22:11,470
well with a

626
00:22:09,130 --> 00:22:13,090
cookies are always present on any type

627
00:22:11,470 --> 00:22:16,090
of request leaving the browser there

628
00:22:13,090 --> 00:22:18,070
will be a cookie for example if you're

629
00:22:16,090 --> 00:22:19,510
loading an image or a script from within

630
00:22:18,070 --> 00:22:21,340
the dog the browser will send the cookie

631
00:22:19,510 --> 00:22:22,690
if it has one if you're opening a

632
00:22:21,340 --> 00:22:25,059
WebSocket connection the browser will

633
00:22:22,690 --> 00:22:26,770
send the cookie if it has one the

634
00:22:25,059 --> 00:22:29,530
authorization header you can only add it

635
00:22:26,770 --> 00:22:31,960
on the xhr calls you can only make it or

636
00:22:29,530 --> 00:22:33,520
attach it to article requests if you

637
00:22:31,960 --> 00:22:35,650
have control over the request but if you

638
00:22:33,520 --> 00:22:37,929
do new WebSocket with the URL you have

639
00:22:35,650 --> 00:22:40,360
no control and the header will not be

640
00:22:37,929 --> 00:22:43,510
there and I've actually I've had clients

641
00:22:40,360 --> 00:22:45,129
that implemented a system with the

642
00:22:43,510 --> 00:22:46,720
authorization header only to realize

643
00:22:45,130 --> 00:22:49,360
offers like oh crap we have no

644
00:22:46,720 --> 00:22:51,250
information on these types of calls and

645
00:22:49,360 --> 00:22:52,658
at that point they were like okay how

646
00:22:51,250 --> 00:22:54,460
we're gonna solve that well let's make a

647
00:22:52,659 --> 00:22:56,289
complementary mechanism using cookies

648
00:22:54,460 --> 00:22:59,230
next to the authorization header so we

649
00:22:56,289 --> 00:23:01,179
have something for those know if you're

650
00:22:59,230 --> 00:23:03,669
actually nito's properties think about

651
00:23:01,179 --> 00:23:05,409
these things upfront and decide on a

652
00:23:03,669 --> 00:23:07,330
proper mechanism and I know we all think

653
00:23:05,409 --> 00:23:09,100
cookies are dirty and the kind of are

654
00:23:07,330 --> 00:23:11,080
they need a lot of attention to make

655
00:23:09,100 --> 00:23:13,090
them secure but they have some benefits

656
00:23:11,080 --> 00:23:15,760
in certain cases so don't underestimate

657
00:23:13,090 --> 00:23:18,309
the impact of session transport it has

658
00:23:15,760 --> 00:23:19,629
in some cases more impact than you might

659
00:23:18,309 --> 00:23:23,110
think especially if you're dealing with

660
00:23:19,630 --> 00:23:27,309
course and things like that so keep that

661
00:23:23,110 --> 00:23:31,418
in mind for your applications all right

662
00:23:27,309 --> 00:23:33,820
that brings us to course api's requests

663
00:23:31,419 --> 00:23:35,919
cross-origin requests are definitely not

664
00:23:33,820 --> 00:23:38,500
abnormal the previous talk talked about

665
00:23:35,919 --> 00:23:40,659
some things coming out in the future

666
00:23:38,500 --> 00:23:43,150
to have better control but for now we're

667
00:23:40,659 --> 00:23:45,370
dealing with course and material is what

668
00:23:43,150 --> 00:23:47,169
matters here is that you are certain

669
00:23:45,370 --> 00:23:49,510
that requests across origins are

670
00:23:47,169 --> 00:23:50,860
identified as cross-origin requests and

671
00:23:49,510 --> 00:23:53,350
one of the ways to do that is to simply

672
00:23:50,860 --> 00:23:55,418
ensure you don't simply accept form

673
00:23:53,350 --> 00:23:57,459
submitted data you always require a

674
00:23:55,419 --> 00:23:59,650
custom content type like JSON data or

675
00:23:57,460 --> 00:24:01,390
whatever your application is using and

676
00:23:59,650 --> 00:24:03,400
then you do that the browser will

677
00:24:01,390 --> 00:24:05,080
includes an origin header on request

678
00:24:03,400 --> 00:24:07,150
browser will tell you like hey this

679
00:24:05,080 --> 00:24:10,750
request comes from a client-side context

680
00:24:07,150 --> 00:24:12,190
with origin HTTP malicious food come and

681
00:24:10,750 --> 00:24:13,539
then you can make a decision do I want

682
00:24:12,190 --> 00:24:15,309
to allow that or not and your course

683
00:24:13,539 --> 00:24:17,470
policy is actually gonna make that

684
00:24:15,309 --> 00:24:19,600
decision for you if you have a well

685
00:24:17,470 --> 00:24:21,460
configured course policy and this

686
00:24:19,600 --> 00:24:22,129
matters because there are applications

687
00:24:21,460 --> 00:24:24,410
that have a

688
00:24:22,130 --> 00:24:25,700
that they configured course policy and

689
00:24:24,410 --> 00:24:27,350
they are from the multi certain

690
00:24:25,700 --> 00:24:30,289
cross-origin requests that might steal

691
00:24:27,350 --> 00:24:32,629
information from that API so you need to

692
00:24:30,289 --> 00:24:34,760
instruct a strict course policy and for

693
00:24:32,630 --> 00:24:36,080
the strict course policy I know this is

694
00:24:34,760 --> 00:24:37,700
usually something that gets in the way

695
00:24:36,080 --> 00:24:39,620
as a developer like why is browser

696
00:24:37,700 --> 00:24:42,080
complaining how can I get rid of this

697
00:24:39,620 --> 00:24:43,909
errors but actually this security of

698
00:24:42,080 --> 00:24:46,370
your course policy really really matters

699
00:24:43,910 --> 00:24:50,360
there are plenty of roam abilities in

700
00:24:46,370 --> 00:24:52,520
these systems one example is if you have

701
00:24:50,360 --> 00:24:54,379
to implement your own course library so

702
00:24:52,520 --> 00:24:57,020
this is what you get from the clients an

703
00:24:54,380 --> 00:24:58,460
Origin header and today many libraries

704
00:24:57,020 --> 00:24:59,870
and many frameworks have support for

705
00:24:58,460 --> 00:25:02,320
course but course has been around for

706
00:24:59,870 --> 00:25:04,729
seven eight years and five years ago

707
00:25:02,320 --> 00:25:05,780
many frameworks did not have support so

708
00:25:04,730 --> 00:25:07,850
people started writing their own

709
00:25:05,780 --> 00:25:09,710
solutions like oh yeah we can check if

710
00:25:07,850 --> 00:25:11,719
the origin starts with rester great calm

711
00:25:09,710 --> 00:25:14,000
that's probably fine or ends with or

712
00:25:11,720 --> 00:25:16,640
contains or some dirty red hex based

713
00:25:14,000 --> 00:25:20,270
system and that's probably not a good

714
00:25:16,640 --> 00:25:22,309
place to be in because if somebody sends

715
00:25:20,270 --> 00:25:23,480
you a request from this context it's

716
00:25:22,309 --> 00:25:27,260
gonna match against some of these

717
00:25:23,480 --> 00:25:28,940
filters or something like that will also

718
00:25:27,260 --> 00:25:31,010
match this will match the end swift or

719
00:25:28,940 --> 00:25:33,530
the contains because restore a bomb is

720
00:25:31,010 --> 00:25:35,179
there at the end so you need to be aware

721
00:25:33,530 --> 00:25:37,700
of these things and this is these

722
00:25:35,179 --> 00:25:39,320
examples are and if you if you start

723
00:25:37,700 --> 00:25:41,570
looking for this there's plenty of talks

724
00:25:39,320 --> 00:25:43,520
about how course can be abused to steal

725
00:25:41,570 --> 00:25:45,260
Bitcoin currency from your wallet and

726
00:25:43,520 --> 00:25:48,200
stuff like that because many services

727
00:25:45,260 --> 00:25:49,789
are configured in securely here's one

728
00:25:48,200 --> 00:25:52,370
example of how you can even screw it up

729
00:25:49,789 --> 00:25:54,770
further this is something I found online

730
00:25:52,370 --> 00:25:56,449
when googling for course policies of a

731
00:25:54,770 --> 00:25:57,559
product you can install on your server

732
00:25:56,450 --> 00:26:00,260
and then you have to add this to your

733
00:25:57,559 --> 00:26:02,720
Apache config and you're good to go well

734
00:26:00,260 --> 00:26:04,610
it will work sure but it might work if

735
00:26:02,720 --> 00:26:05,990
it's too good because what you're doing

736
00:26:04,610 --> 00:26:07,789
here is I don't know if you can read

737
00:26:05,990 --> 00:26:09,049
Apache config or not but what you're

738
00:26:07,789 --> 00:26:10,700
doing here is you're taking the value

739
00:26:09,049 --> 00:26:13,158
from the origin header putting it into

740
00:26:10,700 --> 00:26:14,390
this value and then echoing it back to

741
00:26:13,159 --> 00:26:16,090
the browser saying like oh yeah this

742
00:26:14,390 --> 00:26:20,720
origin is allowed to send request to me

743
00:26:16,090 --> 00:26:22,158
by itself maybe not too bad but the fact

744
00:26:20,720 --> 00:26:23,929
that you say oh and by the way they can

745
00:26:22,159 --> 00:26:26,150
use whatever cookies at our store there

746
00:26:23,929 --> 00:26:29,150
allows any cross-origin context to send

747
00:26:26,150 --> 00:26:30,980
requests to this back-end from any in

748
00:26:29,150 --> 00:26:32,870
the name of the user from it in the

749
00:26:30,980 --> 00:26:35,640
user's browser and this is bad because

750
00:26:32,870 --> 00:26:37,590
course actually has a wildcard the star

751
00:26:35,640 --> 00:26:39,050
you can use to allow any origin to send

752
00:26:37,590 --> 00:26:41,310
your request but then you cannot allow

753
00:26:39,050 --> 00:26:43,379
credentials so the combination of this

754
00:26:41,310 --> 00:26:45,780
is really really dangerous so if you

755
00:26:43,380 --> 00:26:49,110
have a course policy you need to verify

756
00:26:45,780 --> 00:26:51,120
that you're not too relaxed that you

757
00:26:49,110 --> 00:26:54,990
actually force a strict course policy

758
00:26:51,120 --> 00:26:56,969
and that your implementation is is

759
00:26:54,990 --> 00:27:00,360
actually handling these things correctly

760
00:26:56,970 --> 00:27:03,120
I know this is only an overview if you

761
00:27:00,360 --> 00:27:05,639
have questions I'm available afterwards

762
00:27:03,120 --> 00:27:07,590
to give you more details but of course

763
00:27:05,640 --> 00:27:10,500
these are for industry can dive deeper

764
00:27:07,590 --> 00:27:13,020
on these topics with very useful or some

765
00:27:10,500 --> 00:27:15,270
information and stuff like that alright

766
00:27:13,020 --> 00:27:17,220
so we talked about some advanced

767
00:27:15,270 --> 00:27:19,830
pitfalls what about the basics why

768
00:27:17,220 --> 00:27:23,160
haven't I talked about basic things like

769
00:27:19,830 --> 00:27:27,330
input validation what about this input

770
00:27:23,160 --> 00:27:30,180
should API accept this yes or no maybe

771
00:27:27,330 --> 00:27:32,760
it depends you're probably not because

772
00:27:30,180 --> 00:27:34,530
this is a numerical identifier so it

773
00:27:32,760 --> 00:27:36,420
probably should reject string based data

774
00:27:34,530 --> 00:27:37,379
that leads to sequel injection but you

775
00:27:36,420 --> 00:27:39,810
kind of get the idea

776
00:27:37,380 --> 00:27:41,610
input validation matters if you were in

777
00:27:39,810 --> 00:27:43,350
a previous talk from Katie she talked

778
00:27:41,610 --> 00:27:44,939
about input validation as a defense in

779
00:27:43,350 --> 00:27:47,550
that mechanism awesome

780
00:27:44,940 --> 00:27:50,390
lack of input validation is a pitfall

781
00:27:47,550 --> 00:27:54,120
you need to have input validation

782
00:27:50,390 --> 00:27:56,700
however input validation alone can never

783
00:27:54,120 --> 00:27:59,040
be your primary defense input validation

784
00:27:56,700 --> 00:28:01,590
alone will not protect your applications

785
00:27:59,040 --> 00:28:03,379
input validation to me is good this is

786
00:28:01,590 --> 00:28:06,540
very useful to keep the crazy things out

787
00:28:03,380 --> 00:28:08,340
data you know is in fel it's just keep

788
00:28:06,540 --> 00:28:10,020
it out you don't want that but the

789
00:28:08,340 --> 00:28:12,209
moment your data becomes complex enough

790
00:28:10,020 --> 00:28:14,540
input validation is never gonna save you

791
00:28:12,210 --> 00:28:18,150
here's an example of an email address

792
00:28:14,540 --> 00:28:19,379
straight forward right no email address

793
00:28:18,150 --> 00:28:21,060
validation is a nightmare

794
00:28:19,380 --> 00:28:22,890
seriously it's it's a freaking nightmare

795
00:28:21,060 --> 00:28:25,950
and this email address is actually a

796
00:28:22,890 --> 00:28:28,380
valid email address if you ask the RFC

797
00:28:25,950 --> 00:28:31,200
they're like yeah sure this is valid if

798
00:28:28,380 --> 00:28:33,210
you insert this in a sequel query the

799
00:28:31,200 --> 00:28:35,130
way you shouldn't do it it results in

800
00:28:33,210 --> 00:28:37,230
sequel injection and this is fellow data

801
00:28:35,130 --> 00:28:40,470
and this shows you that input validation

802
00:28:37,230 --> 00:28:42,390
will never be a solid defense if you

803
00:28:40,470 --> 00:28:44,970
know it's a valid sure you can keep it

804
00:28:42,390 --> 00:28:47,790
out but even validate that can result in

805
00:28:44,970 --> 00:28:49,290
vulnerabilities later on in API by the

806
00:28:47,790 --> 00:28:51,030
way you cannot mail me on this address

807
00:28:49,290 --> 00:28:52,320
because my email provider does think

808
00:28:51,030 --> 00:28:54,690
this is involved and doesn't allow me to

809
00:28:52,320 --> 00:28:55,590
create that email address which let's

810
00:28:54,690 --> 00:28:57,690
consider that a good thing

811
00:28:55,590 --> 00:28:59,750
but the pitfall here is not rely on

812
00:28:57,690 --> 00:29:02,730
input validation as your primary defense

813
00:28:59,750 --> 00:29:04,650
it's supposed to be a first line of

814
00:29:02,730 --> 00:29:07,170
defense but not the primary defense you

815
00:29:04,650 --> 00:29:09,570
have to memorize your queries or encode

816
00:29:07,170 --> 00:29:12,120
your data if you're dealing with HTML

817
00:29:09,570 --> 00:29:15,990
data and stuff like this that brings me

818
00:29:12,120 --> 00:29:19,550
to another interesting point things are

819
00:29:15,990 --> 00:29:22,350
going to go wrong at one point in time

820
00:29:19,550 --> 00:29:25,050
this is just this is just history we

821
00:29:22,350 --> 00:29:27,719
know these things will go wrong so what

822
00:29:25,050 --> 00:29:29,280
do you do then if something goes wrong

823
00:29:27,720 --> 00:29:31,860
in your public part of your application

824
00:29:29,280 --> 00:29:35,070
doesn't affect every customer with a

825
00:29:31,860 --> 00:29:36,810
private account maybe maybe not

826
00:29:35,070 --> 00:29:39,649
and based on the cases that we see today

827
00:29:36,810 --> 00:29:41,520
most often it does a single

828
00:29:39,650 --> 00:29:42,900
vulnerability and maybe an unimportant

829
00:29:41,520 --> 00:29:44,780
part of your application has a huge

830
00:29:42,900 --> 00:29:48,330
impact on the rest because we don't

831
00:29:44,780 --> 00:29:50,399
compartmentalize why of Earth was the

832
00:29:48,330 --> 00:29:53,070
admin API for the smartwatches the same

833
00:29:50,400 --> 00:29:55,320
API as the watches use there's no point

834
00:29:53,070 --> 00:29:57,540
in knowing that split it out make it two

835
00:29:55,320 --> 00:29:59,340
completely separate things so that if

836
00:29:57,540 --> 00:30:01,290
something goes wrong in the watch API at

837
00:29:59,340 --> 00:30:03,990
least doesn't give automatic admin

838
00:30:01,290 --> 00:30:05,790
access and this is something and in my

839
00:30:03,990 --> 00:30:07,350
opinion this is the only way forward if

840
00:30:05,790 --> 00:30:10,110
we start compartmentalizing things

841
00:30:07,350 --> 00:30:12,300
there's no point in building one huge

842
00:30:10,110 --> 00:30:13,590
API using the same authorization

843
00:30:12,300 --> 00:30:15,780
mechanism everywhere because if you have

844
00:30:13,590 --> 00:30:18,750
one failure it's gonna affect everything

845
00:30:15,780 --> 00:30:20,220
that you're doing so if you want to take

846
00:30:18,750 --> 00:30:24,660
away one thing from this F this

847
00:30:20,220 --> 00:30:27,990
presentation make it this or whatever

848
00:30:24,660 --> 00:30:31,260
you want but I recommend to use this so

849
00:30:27,990 --> 00:30:33,600
to wrap it up I want to ask you to

850
00:30:31,260 --> 00:30:35,310
question everything don't trust do

851
00:30:33,600 --> 00:30:37,230
things because somebody says that's the

852
00:30:35,310 --> 00:30:38,850
way to do this don't assume that

853
00:30:37,230 --> 00:30:42,710
everything I said here needs to be

854
00:30:38,850 --> 00:30:42,709
implemented the way I say because there

