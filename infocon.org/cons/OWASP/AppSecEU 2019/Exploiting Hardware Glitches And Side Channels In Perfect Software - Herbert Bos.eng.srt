1
00:00:42,020 --> 00:00:44,430
and if you're wondering who the people

2
00:00:43,610 --> 00:00:46,019
in the back

3
00:00:44,430 --> 00:00:47,370
you know they're not very important

4
00:00:46,020 --> 00:00:49,890
they're just the members of the research

5
00:00:47,370 --> 00:00:51,360
group that I'm working at but it's

6
00:00:49,890 --> 00:00:53,760
actually their work right so these

7
00:00:51,360 --> 00:00:55,410
students they're really smart students

8
00:00:53,760 --> 00:00:57,000
and they they work for the sudden

9
00:00:55,410 --> 00:00:59,339
everything that I'm gonna present today

10
00:00:57,000 --> 00:01:01,860
is really theirs right so it's their

11
00:00:59,340 --> 00:01:03,600
work and what they're doing is they're

12
00:01:01,860 --> 00:01:05,700
building new defense it's making it

13
00:01:03,600 --> 00:01:08,750
harder for attackers to compromise our

14
00:01:05,700 --> 00:01:11,760
systems and they're also developing new

15
00:01:08,750 --> 00:01:13,020
attacks new types of vulnerabilities try

16
00:01:11,760 --> 00:01:16,080
to discover new types of vulnerabilities

17
00:01:13,020 --> 00:01:18,149
and why do we do this we do this because

18
00:01:16,080 --> 00:01:20,520
I believe that the main problem that we

19
00:01:18,150 --> 00:01:22,650
have in security is that we no longer

20
00:01:20,520 --> 00:01:26,699
understand the systems that we build

21
00:01:22,650 --> 00:01:28,680
they've become so complex that we no

22
00:01:26,700 --> 00:01:30,990
longer understand them and by exploiting

23
00:01:28,680 --> 00:01:33,360
them by finding new ways to exploit them

24
00:01:30,990 --> 00:01:35,460
right we learn a little bit more about

25
00:01:33,360 --> 00:01:39,180
you know unexpected behavior that these

26
00:01:35,460 --> 00:01:40,889
systems can exhibit right and I think

27
00:01:39,180 --> 00:01:42,930
that's extremely valuable it's also

28
00:01:40,890 --> 00:01:44,940
extremely valuable in a very direct

29
00:01:42,930 --> 00:01:47,100
sense of the word right so if you find a

30
00:01:44,940 --> 00:01:49,830
new class of vulnerability it's actually

31
00:01:47,100 --> 00:01:52,140
translated into money right so large

32
00:01:49,830 --> 00:01:54,120
companies have these bounty programs as

33
00:01:52,140 --> 00:01:56,460
you know prices paid on that you know

34
00:01:54,120 --> 00:01:58,440
and the more shady area of the internet

35
00:01:56,460 --> 00:02:01,889
it's a lot of money bounty programs of

36
00:01:58,440 --> 00:02:03,300
hundreds and thousand of dollars for you

37
00:02:01,890 --> 00:02:05,790
know a new - new vulnerability new

38
00:02:03,300 --> 00:02:08,039
zero-day that's a lot of money right and

39
00:02:05,790 --> 00:02:11,580
it so happens that I need a lot of money

40
00:02:08,039 --> 00:02:13,200
because I need a new terrace so I'm so

41
00:02:11,580 --> 00:02:14,970
what I thought you know thinking of the

42
00:02:13,200 --> 00:02:17,549
the bounty programs and all the smart

43
00:02:14,970 --> 00:02:20,850
students that I have in the group what I

44
00:02:17,550 --> 00:02:23,459
thought I would do is you know I would

45
00:02:20,850 --> 00:02:27,000
simply exploit the students make lots of

46
00:02:23,459 --> 00:02:29,250
money and get myself a new terrace so I

47
00:02:27,000 --> 00:02:31,260
thought that's let's do that and when I

48
00:02:29,250 --> 00:02:32,610
start a presentation so the long ago

49
00:02:31,260 --> 00:02:34,679
someone told me you always have to start

50
00:02:32,610 --> 00:02:36,000
with three observations but I couldn't

51
00:02:34,680 --> 00:02:38,970
think of three observations okay we're

52
00:02:36,000 --> 00:02:41,070
gonna start with two observations so the

53
00:02:38,970 --> 00:02:44,190
first observation is that so for

54
00:02:41,070 --> 00:02:45,840
exploitation nowadays you know in

55
00:02:44,190 --> 00:02:48,269
contrast to what you read in newspapers

56
00:02:45,840 --> 00:02:50,640
is actually super super hard right

57
00:02:48,269 --> 00:02:53,100
exploiting a modern browser or a modern

58
00:02:50,640 --> 00:02:54,779
operating system is exceedingly hard

59
00:02:53,100 --> 00:02:57,960
because of all the defenses that are in

60
00:02:54,780 --> 00:03:00,990
place this makes these zero days so in

61
00:02:57,960 --> 00:03:03,600
sanely valuable okay the second

62
00:03:00,990 --> 00:03:07,530
observation is that we're in a very

63
00:03:03,600 --> 00:03:09,810
interesting era where physical attacks

64
00:03:07,530 --> 00:03:13,020
side-channel attacks where people point

65
00:03:09,810 --> 00:03:15,030
with with lasers at tips or you know D

66
00:03:13,020 --> 00:03:17,570
solder chips and and all sort of clever

67
00:03:15,030 --> 00:03:20,460
things is meeting the world of software

68
00:03:17,570 --> 00:03:22,620
exploitation right so nowadays some of

69
00:03:20,460 --> 00:03:24,210
these Hardware bugs can be triggered

70
00:03:22,620 --> 00:03:25,890
from software and that's very

71
00:03:24,210 --> 00:03:28,470
interesting now why is this very

72
00:03:25,890 --> 00:03:30,660
interesting why why would you care well

73
00:03:28,470 --> 00:03:33,810
it's interesting because only a few

74
00:03:30,660 --> 00:03:35,820
years ago 2014 I would start my first

75
00:03:33,810 --> 00:03:38,070
lecture on computer network security

76
00:03:35,820 --> 00:03:39,989
here at the very north side by saying

77
00:03:38,070 --> 00:03:41,910
you know we have all of these security

78
00:03:39,990 --> 00:03:44,520
problems and they're caused by crappy

79
00:03:41,910 --> 00:03:45,690
software our own misconfigured software

80
00:03:44,520 --> 00:03:48,600
and we should really work on this

81
00:03:45,690 --> 00:03:50,250
nowadays this year when I I just had my

82
00:03:48,600 --> 00:03:53,460
lecture on our computer network security

83
00:03:50,250 --> 00:03:55,830
last week I'm basically tell the

84
00:03:53,460 --> 00:03:58,440
students look even if your software is

85
00:03:55,830 --> 00:04:01,140
perfect doesn't contain a single bug

86
00:03:58,440 --> 00:04:04,530
perfectly configured it's still it's

87
00:04:01,140 --> 00:04:06,119
still vulnerable and to see why let's go

88
00:04:04,530 --> 00:04:07,740
back to traditional software

89
00:04:06,120 --> 00:04:10,200
exploitation right so if we have our

90
00:04:07,740 --> 00:04:11,550
software hardware stack with hardware at

91
00:04:10,200 --> 00:04:14,130
the bottom and you know you're the user

92
00:04:11,550 --> 00:04:16,710
at the top the traditional way of

93
00:04:14,130 --> 00:04:19,649
exploiting a system was you would find a

94
00:04:16,709 --> 00:04:21,630
vulnerability somewhere in this in a

95
00:04:19,649 --> 00:04:23,729
program or in the operating system a

96
00:04:21,630 --> 00:04:26,280
buffer overflow perhaps and you would

97
00:04:23,730 --> 00:04:29,850
you know misuse that to compromise the

98
00:04:26,280 --> 00:04:32,340
system but as mentioned this is now very

99
00:04:29,850 --> 00:04:34,590
very difficult because of you know

100
00:04:32,340 --> 00:04:39,030
address space layout randomization non

101
00:04:34,590 --> 00:04:40,830
execution bits and stack protection

102
00:04:39,030 --> 00:04:42,719
control flow integrity all sorts of

103
00:04:40,830 --> 00:04:45,150
complicated defenses that the vendors

104
00:04:42,720 --> 00:04:48,300
are throwing at their software to make

105
00:04:45,150 --> 00:04:50,390
it more secure ok so this is super

106
00:04:48,300 --> 00:04:53,150
frustrating for our poor attacker

107
00:04:50,390 --> 00:04:56,669
because he's now left with the question

108
00:04:53,150 --> 00:04:59,909
how do I get the primitives that I need

109
00:04:56,670 --> 00:05:00,720
to compromise these systems and what

110
00:04:59,910 --> 00:05:02,940
primitives

111
00:05:00,720 --> 00:05:05,310
do you need as an attacker well you need

112
00:05:02,940 --> 00:05:07,110
a reprime ative and a right primitive

113
00:05:05,310 --> 00:05:10,370
right you need to be able to leak

114
00:05:07,110 --> 00:05:12,620
sensitive information ideally right and

115
00:05:10,370 --> 00:05:15,110
you need a way to you know violate the

116
00:05:12,620 --> 00:05:16,940
integrity of the system maybe make the

117
00:05:15,110 --> 00:05:20,150
program do something that you would want

118
00:05:16,940 --> 00:05:22,130
it to do and what read and write

119
00:05:20,150 --> 00:05:23,900
primitives can the attacker still obtain

120
00:05:22,130 --> 00:05:25,159
if we make the assumption that the

121
00:05:23,900 --> 00:05:27,049
software is perfect of course the

122
00:05:25,160 --> 00:05:28,580
software is not yet perfect but there is

123
00:05:27,050 --> 00:05:31,400
a there's a lot of work towards this

124
00:05:28,580 --> 00:05:34,219
verification is just one of them okay

125
00:05:31,400 --> 00:05:36,198
well to see that we should probably look

126
00:05:34,220 --> 00:05:38,449
at the entire history of popular

127
00:05:36,199 --> 00:05:41,150
computing so the last 60 years or so

128
00:05:38,449 --> 00:05:43,130
computing has had one goal and one goal

129
00:05:41,150 --> 00:05:44,000
only I would claim and that is

130
00:05:43,130 --> 00:05:47,229
efficiency

131
00:05:44,000 --> 00:05:50,080
everything was sacrificed at the altar

132
00:05:47,229 --> 00:05:53,150
efficiency and that includes security

133
00:05:50,080 --> 00:05:55,880
one thing that we do for instance is we

134
00:05:53,150 --> 00:05:58,700
aggressively share write do we share

135
00:05:55,880 --> 00:06:02,330
everything we share the CPU we share

136
00:05:58,700 --> 00:06:04,219
memory we share caches there's all sorts

137
00:06:02,330 --> 00:06:07,039
of stuff that we share and because

138
00:06:04,220 --> 00:06:09,380
sharing is super efficient right but I

139
00:06:07,039 --> 00:06:11,270
would claim that because of sharing this

140
00:06:09,380 --> 00:06:12,320
is a known result that's known you know

141
00:06:11,270 --> 00:06:15,770
since the 60s

142
00:06:12,320 --> 00:06:17,840
sharing is potentially susceptible to

143
00:06:15,770 --> 00:06:21,169
site channels all the sharing that you

144
00:06:17,840 --> 00:06:23,388
do may lead to side channels okay so my

145
00:06:21,169 --> 00:06:26,210
claim would be sharing is efficient but

146
00:06:23,389 --> 00:06:28,099
but really sharing is not caring right

147
00:06:26,210 --> 00:06:30,650
the more you share the more dangerous

148
00:06:28,099 --> 00:06:33,050
things become and we're gonna have a

149
00:06:30,650 --> 00:06:35,090
look at that what about serviceable this

150
00:06:33,050 --> 00:06:38,180
is what we're gonna use as a memory read

151
00:06:35,090 --> 00:06:40,099
primitive such channels okay

152
00:06:38,180 --> 00:06:42,169
what about the memory right primitive

153
00:06:40,099 --> 00:06:44,419
how do we write into the address space

154
00:06:42,169 --> 00:06:46,729
of a system where you know beyond where

155
00:06:44,419 --> 00:06:48,020
we are supposed to write if we can no

156
00:06:46,729 --> 00:06:50,479
longer do this in the traditional way

157
00:06:48,020 --> 00:06:53,389
well here there are you know things that

158
00:06:50,479 --> 00:06:54,830
we basically draw from you know these

159
00:06:53,389 --> 00:06:57,229
are these physical attacks there are

160
00:06:54,830 --> 00:07:00,169
hardware vulnerabilities that can be

161
00:06:57,229 --> 00:07:03,560
triggered from software okay and those

162
00:07:00,169 --> 00:07:05,810
are really really simple vulnerabilities

163
00:07:03,560 --> 00:07:08,330
just maybe you are able to flip a bit

164
00:07:05,810 --> 00:07:10,370
from a 0 to a 1 or 1 to 0 but they're

165
00:07:08,330 --> 00:07:13,219
very powerful these glitches from

166
00:07:10,370 --> 00:07:15,919
software or best exemplified probably by

167
00:07:13,220 --> 00:07:17,479
the the Rho hammer vulnerability so the

168
00:07:15,919 --> 00:07:18,940
Rho hammer vulnerability allows you to

169
00:07:17,479 --> 00:07:22,240
flip a bit in memory

170
00:07:18,940 --> 00:07:26,140
all right DRAM vulnerability memory chip

171
00:07:22,240 --> 00:07:28,600
okay so once we have these two

172
00:07:26,140 --> 00:07:30,520
primitives and memory primitive and a

173
00:07:28,600 --> 00:07:32,860
memory right primitives we go back to

174
00:07:30,520 --> 00:07:35,710
reliable exploits and life is good for

175
00:07:32,860 --> 00:07:37,720
the attacker okay so let's have a look

176
00:07:35,710 --> 00:07:40,359
at what that means really so for the

177
00:07:37,720 --> 00:07:42,810
past ten years most of the serious

178
00:07:40,360 --> 00:07:46,240
exploitation of at the application level

179
00:07:42,810 --> 00:07:47,890
has been on the basis of code reuse so

180
00:07:46,240 --> 00:07:50,530
you find a little snippet of code a

181
00:07:47,890 --> 00:07:52,780
bunch of snippets of code in an existing

182
00:07:50,530 --> 00:07:55,630
program and you make that do something

183
00:07:52,780 --> 00:07:57,940
new something that the attacker wants so

184
00:07:55,630 --> 00:08:01,090
to do that what do you need well you

185
00:07:57,940 --> 00:08:03,250
need to know a where those program

186
00:08:01,090 --> 00:08:05,590
snippets are right so what is the

187
00:08:03,250 --> 00:08:07,600
address of a particular program snippet

188
00:08:05,590 --> 00:08:09,669
so you can make it the program jump to

189
00:08:07,600 --> 00:08:11,740
it and then do something that you want

190
00:08:09,670 --> 00:08:14,440
as an attacker and also where the data

191
00:08:11,740 --> 00:08:16,270
is that corresponds to that and once you

192
00:08:14,440 --> 00:08:19,060
know that you can change these things

193
00:08:16,270 --> 00:08:21,549
together into a malicious payload this

194
00:08:19,060 --> 00:08:24,520
is what attackers do so we need the

195
00:08:21,550 --> 00:08:28,990
addresses of code we need the addresses

196
00:08:24,520 --> 00:08:30,430
of data as an attacker and and that's

197
00:08:28,990 --> 00:08:32,320
one of the things that we need and the

198
00:08:30,430 --> 00:08:34,630
other thing that we need is bugs we need

199
00:08:32,320 --> 00:08:37,719
bugs to find these addresses we need

200
00:08:34,630 --> 00:08:39,640
bugs to to divert the control flow so we

201
00:08:37,719 --> 00:08:41,260
want to make this program do something

202
00:08:39,640 --> 00:08:43,539
that it shouldn't normally do make it

203
00:08:41,260 --> 00:08:46,270
jump somewhere in the in the binary

204
00:08:43,539 --> 00:08:48,790
where it doesn't normally jump so this

205
00:08:46,270 --> 00:08:50,949
is getting harder and so what the

206
00:08:48,790 --> 00:08:53,740
question we ask is can we do all of this

207
00:08:50,950 --> 00:08:55,570
without any software bugs right so we

208
00:08:53,740 --> 00:08:58,840
have perfect software can we still do

209
00:08:55,570 --> 00:09:01,240
this and the answer is yes and I'm gonna

210
00:08:58,840 --> 00:09:03,760
start with the hardware glitches which

211
00:09:01,240 --> 00:09:05,650
is best exemplified as I mentioned by

212
00:09:03,760 --> 00:09:07,420
the row hammer vulnerability and I'm not

213
00:09:05,650 --> 00:09:08,590
sure if you're all familiar with the row

214
00:09:07,420 --> 00:09:11,560
haven't vulnerability but it was

215
00:09:08,590 --> 00:09:13,930
discovered quite recently 2014 and it's

216
00:09:11,560 --> 00:09:16,869
a hardware vulnerability in memory chips

217
00:09:13,930 --> 00:09:21,849
in DRAM chips okay and it's a it's a

218
00:09:16,870 --> 00:09:25,270
really funky vulnerability because it it

219
00:09:21,850 --> 00:09:27,100
allows you to flip memory at locations

220
00:09:25,270 --> 00:09:29,770
where you're not even accessing that

221
00:09:27,100 --> 00:09:31,490
location okay so if you look at a memory

222
00:09:29,770 --> 00:09:34,339
chip a DRAM chip it

223
00:09:31,490 --> 00:09:35,959
it's just you know rows and rows of bits

224
00:09:34,339 --> 00:09:38,720
right that's all it is

225
00:09:35,959 --> 00:09:41,000
and if you want to access a value in

226
00:09:38,720 --> 00:09:44,390
memory from your browser from JavaScript

227
00:09:41,000 --> 00:09:47,300
doesn't matter you basically access one

228
00:09:44,390 --> 00:09:50,209
row of those bits copy them into the row

229
00:09:47,300 --> 00:09:53,479
buffer and then that gets sent to the

230
00:09:50,209 --> 00:09:55,969
CPU for processing okay

231
00:09:53,480 --> 00:09:59,260
now these are just physical processes

232
00:09:55,970 --> 00:10:02,270
right so each of these bits is just a

233
00:09:59,260 --> 00:10:03,770
transistor and a capacitor just you know

234
00:10:02,270 --> 00:10:07,209
stuff that you find in your physics

235
00:10:03,770 --> 00:10:10,790
class okay and a capacitor holds charge

236
00:10:07,209 --> 00:10:13,880
but the charge leaks over time moreover

237
00:10:10,790 --> 00:10:17,569
what happens if you access one row right

238
00:10:13,880 --> 00:10:19,640
so maybe this row it has an effect

239
00:10:17,570 --> 00:10:22,250
because these chips the bits are so

240
00:10:19,640 --> 00:10:25,130
closely packed together if you access

241
00:10:22,250 --> 00:10:28,310
one row a little bit of charge leaks

242
00:10:25,130 --> 00:10:31,100
from the bits in the adjacent row okay

243
00:10:28,310 --> 00:10:34,430
and you can use this so if you do this

244
00:10:31,100 --> 00:10:36,230
at a very rapid rate you access this row

245
00:10:34,430 --> 00:10:38,390
and then that row and then that row

246
00:10:36,230 --> 00:10:41,000
again and that will gain a little bit of

247
00:10:38,390 --> 00:10:44,180
charge leaks from this you know poor bit

248
00:10:41,000 --> 00:10:46,520
location over there and this accumulates

249
00:10:44,180 --> 00:10:48,439
if you do this efficiently often the

250
00:10:46,520 --> 00:10:51,350
charts leak it's accumulates to the

251
00:10:48,440 --> 00:10:55,520
point where a bit flips from a 1 to a 0

252
00:10:51,350 --> 00:10:57,520
or a 0 to a 1 okay so you never accessed

253
00:10:55,520 --> 00:11:00,589
that bit location that memory location

254
00:10:57,520 --> 00:11:03,800
but you still managed to change it it's

255
00:11:00,589 --> 00:11:06,050
kind of magic ok and it's a it's a

256
00:11:03,800 --> 00:11:08,290
probabilistic process you have no idea

257
00:11:06,050 --> 00:11:11,599
which bit in that row is going to flip

258
00:11:08,290 --> 00:11:14,719
but it's a repeatable process so once a

259
00:11:11,600 --> 00:11:17,390
bit flipped once if you do this again it

260
00:11:14,720 --> 00:11:19,640
will flip again right that same bit and

261
00:11:17,390 --> 00:11:20,899
that makes is a powerful thing in the

262
00:11:19,640 --> 00:11:22,939
hands of an attacker because the

263
00:11:20,899 --> 00:11:25,760
attacker can now find out which bits are

264
00:11:22,940 --> 00:11:28,820
vulnerable in a pro in them in a

265
00:11:25,760 --> 00:11:30,829
computer system right and then give that

266
00:11:28,820 --> 00:11:32,720
to you know somewhat somebody else to

267
00:11:30,829 --> 00:11:35,209
use and then see if you can flip the bit

268
00:11:32,720 --> 00:11:37,820
and do something bad so it becomes a

269
00:11:35,209 --> 00:11:40,400
security problem let's have a look how

270
00:11:37,820 --> 00:11:44,570
that works so so row hammer was invented

271
00:11:40,400 --> 00:11:44,840
or was discovered in 2014 by the people

272
00:11:44,570 --> 00:11:47,000
at

273
00:11:44,840 --> 00:11:49,190
you at the time and since and I've been

274
00:11:47,000 --> 00:11:50,930
a little bit of work of you know to try

275
00:11:49,190 --> 00:11:53,060
and exploit this when we came into the

276
00:11:50,930 --> 00:11:56,900
game we thought what we would want to do

277
00:11:53,060 --> 00:11:58,819
is is see if we can exploit this in the

278
00:11:56,900 --> 00:12:00,680
state-of-the-art browser that we had in

279
00:11:58,820 --> 00:12:02,990
those days right so Microsoft ads was

280
00:12:00,680 --> 00:12:04,849
more advanced in terms of Defense's than

281
00:12:02,990 --> 00:12:06,140
any other browser that was available it

282
00:12:04,850 --> 00:12:07,970
had control flow guard which is a

283
00:12:06,140 --> 00:12:10,370
control flow integrity it had address

284
00:12:07,970 --> 00:12:12,830
space layout so a lot of Defense's were

285
00:12:10,370 --> 00:12:16,040
in there and we thought let's see if we

286
00:12:12,830 --> 00:12:18,530
can exploit Microsoft ads without any

287
00:12:16,040 --> 00:12:21,469
assumption about software bugs or miss

288
00:12:18,530 --> 00:12:24,829
configurations and and only from

289
00:12:21,470 --> 00:12:26,360
JavaScript okay so this is what we're

290
00:12:24,830 --> 00:12:27,860
gonna do and the the way we're gonna do

291
00:12:26,360 --> 00:12:29,510
that I'm gonna sketch the attack first

292
00:12:27,860 --> 00:12:31,280
so you have a you know rough idea of

293
00:12:29,510 --> 00:12:33,110
what I'm going to explain later is we're

294
00:12:31,280 --> 00:12:36,350
going to use a side channel which is

295
00:12:33,110 --> 00:12:38,630
known as memory deduplication right to

296
00:12:36,350 --> 00:12:40,430
leak the addresses of the data and the

297
00:12:38,630 --> 00:12:43,400
code which I said we were going to need

298
00:12:40,430 --> 00:12:45,380
and then we use this Hardware glitz

299
00:12:43,400 --> 00:12:46,850
right so once we have this information

300
00:12:45,380 --> 00:12:50,420
when you use a Hardware glitch row

301
00:12:46,850 --> 00:12:52,610
hammer flip a bit to make the control

302
00:12:50,420 --> 00:12:54,680
flow in the program you know execute

303
00:12:52,610 --> 00:12:56,750
code that we want okay

304
00:12:54,680 --> 00:12:58,550
and with that we can exploit Microsoft

305
00:12:56,750 --> 00:13:01,700
ads without any software bugs from

306
00:12:58,550 --> 00:13:04,370
JavaScript and remember we need to find

307
00:13:01,700 --> 00:13:05,660
addresses of code and data first so

308
00:13:04,370 --> 00:13:08,360
that's what we're going to use our side

309
00:13:05,660 --> 00:13:10,310
channel for and the side channel will

310
00:13:08,360 --> 00:13:12,590
get us an address for instance in the

311
00:13:10,310 --> 00:13:14,959
JavaScript engine of of Microsoft ads

312
00:13:12,590 --> 00:13:17,630
right so with chakra we just want to

313
00:13:14,960 --> 00:13:20,690
have a pointer an address of some code

314
00:13:17,630 --> 00:13:22,310
there okay and for that like I said we

315
00:13:20,690 --> 00:13:24,710
use this memory deduplication

316
00:13:22,310 --> 00:13:27,079
vulnerability and memory deduplication

317
00:13:24,710 --> 00:13:29,480
is really simple if you have a system

318
00:13:27,080 --> 00:13:30,920
with two processors running on top of an

319
00:13:29,480 --> 00:13:33,590
operating system and there's some

320
00:13:30,920 --> 00:13:35,449
physical memory some DRAM chips at the

321
00:13:33,590 --> 00:13:38,900
bottom somewhere right and let's assume

322
00:13:35,450 --> 00:13:41,660
that one of the processors has some data

323
00:13:38,900 --> 00:13:44,689
in memory writes of a 4 kilobyte page

324
00:13:41,660 --> 00:13:47,030
that exists in memory of course this

325
00:13:44,690 --> 00:13:49,880
will be really somewhere in the physical

326
00:13:47,030 --> 00:13:51,800
DRAM chip right so this this data is

327
00:13:49,880 --> 00:13:54,230
there if another process has the same

328
00:13:51,800 --> 00:13:55,240
page of memory the same 4 kilobytes of

329
00:13:54,230 --> 00:13:58,269
memory

330
00:13:55,240 --> 00:14:01,269
the in with memory deduplication the

331
00:13:58,269 --> 00:14:05,910
system will realize that wait a minute

332
00:14:01,269 --> 00:14:09,040
these bytes are exactly the same 496 by

333
00:14:05,910 --> 00:14:11,469
4096 bytes are exactly the same it's

334
00:14:09,040 --> 00:14:13,779
very inefficient to store this twice in

335
00:14:11,470 --> 00:14:16,179
physical memory let's merge them right

336
00:14:13,779 --> 00:14:18,459
so let's just store one copy and make

337
00:14:16,179 --> 00:14:20,559
both of these processes use that same

338
00:14:18,459 --> 00:14:22,989
copy and of course that's all okay as

339
00:14:20,559 --> 00:14:25,449
long as they don't modify it right it's

340
00:14:22,990 --> 00:14:27,670
if it's read-only it's perfectly fine if

341
00:14:25,449 --> 00:14:29,258
it if they start modifying of course you

342
00:14:27,670 --> 00:14:31,479
have a problem because you don't want

343
00:14:29,259 --> 00:14:33,519
somebody modifying the data and then

344
00:14:31,480 --> 00:14:36,040
because of that the data of somebody

345
00:14:33,519 --> 00:14:38,019
else changing right so if you modify

346
00:14:36,040 --> 00:14:41,399
this if your right to this data you have

347
00:14:38,019 --> 00:14:44,170
to redo placate it make a new copy and

348
00:14:41,399 --> 00:14:46,509
and this is slow this is a slow process

349
00:14:44,170 --> 00:14:49,420
because rather than just writing in to

350
00:14:46,509 --> 00:14:51,429
you know bits on a DRAM chip now you

351
00:14:49,420 --> 00:14:54,189
have to trap into the operating system

352
00:14:51,429 --> 00:14:56,709
kernel make a copy of the page you know

353
00:14:54,189 --> 00:14:58,689
change the page tables and then go back

354
00:14:56,709 --> 00:15:01,149
to user space and then right into the

355
00:14:58,689 --> 00:15:02,799
DRAM chip that is super slow its

356
00:15:01,149 --> 00:15:06,160
measurably stuff you can measure this

357
00:15:02,799 --> 00:15:08,399
from from even from JavaScript okay

358
00:15:06,160 --> 00:15:11,799
the rights to those pages that are

359
00:15:08,399 --> 00:15:13,720
deduplicated take longer okay so what

360
00:15:11,799 --> 00:15:15,879
does that mean that means that you can

361
00:15:13,720 --> 00:15:18,549
now detect you have a side channel to

362
00:15:15,879 --> 00:15:22,410
detect that somebody else if you create

363
00:15:18,549 --> 00:15:25,839
some you know a page worth of a data in

364
00:15:22,410 --> 00:15:28,149
with javascript in memory and it gets

365
00:15:25,839 --> 00:15:30,490
duplicated which because the writes get

366
00:15:28,149 --> 00:15:32,799
slower right you know that somebody else

367
00:15:30,490 --> 00:15:34,179
has the exact same daytime memory it's a

368
00:15:32,799 --> 00:15:36,730
side channel you learn something about

369
00:15:34,179 --> 00:15:38,230
what somebody else has in in memory for

370
00:15:36,730 --> 00:15:42,339
instance another process or not the

371
00:15:38,230 --> 00:15:44,589
kernel okay and we want to use this to

372
00:15:42,339 --> 00:15:46,720
leak this address of the code or the

373
00:15:44,589 --> 00:15:50,589
data okay

374
00:15:46,720 --> 00:15:53,470
the code and data pointers now let's go

375
00:15:50,589 --> 00:15:57,249
back to this right so if we have memory

376
00:15:53,470 --> 00:15:59,559
deduplication and we know exactly what

377
00:15:57,249 --> 00:16:02,139
data another process has a memory and we

378
00:15:59,559 --> 00:16:04,569
recreate the exact same data and then

379
00:16:02,139 --> 00:16:07,299
writes to the page after deduplication

380
00:16:04,569 --> 00:16:08,400
has merge them it will be slower but

381
00:16:07,299 --> 00:16:12,930
normally we don't

382
00:16:08,400 --> 00:16:16,260
no let's say we don't know all the 4096

383
00:16:12,930 --> 00:16:18,750
bytes in exactly we know all of the

384
00:16:16,260 --> 00:16:21,569
bytes except one right so how do we

385
00:16:18,750 --> 00:16:25,490
discover that last bite well what we can

386
00:16:21,570 --> 00:16:28,620
do is simply make you know 256 pages

387
00:16:25,490 --> 00:16:31,200
with different values for that one byte

388
00:16:28,620 --> 00:16:33,600
in memory and then write to all of them

389
00:16:31,200 --> 00:16:36,540
and see which one was a little bit

390
00:16:33,600 --> 00:16:39,630
slower right so that means that that

391
00:16:36,540 --> 00:16:42,089
page had the right value for that one

392
00:16:39,630 --> 00:16:43,470
byte so now we know this one byte and

393
00:16:42,090 --> 00:16:46,680
that's what we're gonna do for our

394
00:16:43,470 --> 00:16:49,490
address right so we're going to create a

395
00:16:46,680 --> 00:16:52,650
page where all of the content is known

396
00:16:49,490 --> 00:16:54,780
except for the address except for the

397
00:16:52,650 --> 00:16:57,510
add only the address is unknown so then

398
00:16:54,780 --> 00:17:00,000
we can make lots of pages and gasps the

399
00:16:57,510 --> 00:17:02,250
address because that is the only page

400
00:17:00,000 --> 00:17:04,410
where the writing will be slow now first

401
00:17:02,250 --> 00:17:06,209
of all can we do this well actually from

402
00:17:04,410 --> 00:17:08,880
JavaScript it's really simple right

403
00:17:06,209 --> 00:17:12,000
because in JavaScript in in at least in

404
00:17:08,880 --> 00:17:15,200
this JavaScript engine the end of a

405
00:17:12,000 --> 00:17:17,790
function always led to exactly the same

406
00:17:15,200 --> 00:17:19,800
code so if you wrote a JavaScript

407
00:17:17,790 --> 00:17:24,510
function it would always end with this

408
00:17:19,800 --> 00:17:29,360
and it's a it's completely constant it

409
00:17:24,510 --> 00:17:32,010
would always have trap instructions that

410
00:17:29,360 --> 00:17:33,840
run to the end of the page right so it

411
00:17:32,010 --> 00:17:36,360
would be entirely filled with trapping

412
00:17:33,840 --> 00:17:37,830
instructions and the only thing that

413
00:17:36,360 --> 00:17:40,229
would differ is there was a move

414
00:17:37,830 --> 00:17:42,929
instruction another move instruction and

415
00:17:40,230 --> 00:17:44,720
a jump instruction right entirely

416
00:17:42,930 --> 00:17:48,360
predictable everything is predictable

417
00:17:44,720 --> 00:17:50,400
except this address here right we didn't

418
00:17:48,360 --> 00:17:52,320
know that address so the entire page is

419
00:17:50,400 --> 00:17:54,360
known except the address so what we can

420
00:17:52,320 --> 00:17:56,100
do as an attacker is simply create this

421
00:17:54,360 --> 00:17:58,379
page and then have a gasps for the

422
00:17:56,100 --> 00:18:00,030
address and if it's slow if we write to

423
00:17:58,380 --> 00:18:03,060
the page we know that it was the right

424
00:18:00,030 --> 00:18:05,070
gasps right of course this is a little

425
00:18:03,060 --> 00:18:09,450
bit problematic because it's an address

426
00:18:05,070 --> 00:18:11,189
of 48 bits right so we create old

427
00:18:09,450 --> 00:18:13,770
unknown data and then we have this one

428
00:18:11,190 --> 00:18:16,200
thing that is unknown we simply gasp for

429
00:18:13,770 --> 00:18:18,810
that but it's 48 bits right so that's a

430
00:18:16,200 --> 00:18:21,100
if we have to create two to the power 48

431
00:18:18,810 --> 00:18:23,289
pages that is a bit much

432
00:18:21,100 --> 00:18:26,350
right so we can't do it but we control

433
00:18:23,289 --> 00:18:28,450
the functions that is being used for

434
00:18:26,350 --> 00:18:31,178
this right we right we have we are the

435
00:18:28,450 --> 00:18:33,460
attackers we write the JavaScript so we

436
00:18:31,179 --> 00:18:35,830
can control how large or small the

437
00:18:33,460 --> 00:18:37,780
functions are so if we make the function

438
00:18:35,830 --> 00:18:40,510
a little bit smaller we can make it such

439
00:18:37,780 --> 00:18:42,549
that only one byte gets mapped onto this

440
00:18:40,510 --> 00:18:44,830
page or two bytes get mapped onto the

441
00:18:42,549 --> 00:18:46,389
page so what we can do is if we have one

442
00:18:44,830 --> 00:18:50,080
byte mapping onto debates it's really

443
00:18:46,390 --> 00:18:52,510
easy we have to make 256 pages with

444
00:18:50,080 --> 00:18:55,149
different gasses for the value of that

445
00:18:52,510 --> 00:18:57,879
one byte and if it gets duplicated we

446
00:18:55,150 --> 00:19:00,130
know we have that byte guessed correctly

447
00:18:57,880 --> 00:19:02,049
so and then we try the next byte and the

448
00:19:00,130 --> 00:19:04,890
next byte and the next byte and the next

449
00:19:02,049 --> 00:19:08,230
byte until we have the entire address

450
00:19:04,890 --> 00:19:10,120
correctly okay so we do something

451
00:19:08,230 --> 00:19:11,320
similar for the data it's a little bit

452
00:19:10,120 --> 00:19:13,899
different but I don't want to get into

453
00:19:11,320 --> 00:19:16,000
that but if we know the addresses of the

454
00:19:13,900 --> 00:19:18,130
code and the data what we can now do is

455
00:19:16,000 --> 00:19:23,530
create in memory in our you know a

456
00:19:18,130 --> 00:19:25,510
JavaScript array the bytes that would

457
00:19:23,530 --> 00:19:27,789
exist in memory if there was a

458
00:19:25,510 --> 00:19:30,610
JavaScript object a JavaScript object

459
00:19:27,789 --> 00:19:32,799
with a pointer to the method and a

460
00:19:30,610 --> 00:19:35,229
pointer to the data right it's a fake

461
00:19:32,799 --> 00:19:37,780
object doesn't really exist but it has

462
00:19:35,230 --> 00:19:40,330
the right address is there okay of

463
00:19:37,780 --> 00:19:42,850
course the JavaScript engine is not not

464
00:19:40,330 --> 00:19:45,370
aware of this object and it will never

465
00:19:42,850 --> 00:19:47,649
call the method but we know all the

466
00:19:45,370 --> 00:19:50,379
addresses we now have broken all of the

467
00:19:47,650 --> 00:19:54,789
address space randomization so what we

468
00:19:50,380 --> 00:19:57,429
can do is take an existing object all

469
00:19:54,789 --> 00:19:59,770
the way on the left there write an

470
00:19:57,429 --> 00:20:02,470
existing object which has a pointer to

471
00:19:59,770 --> 00:20:05,650
it somewhere the you know under the hood

472
00:20:02,470 --> 00:20:08,230
there's all all pointers and and use the

473
00:20:05,650 --> 00:20:11,289
row hammer vulnerability to flip exactly

474
00:20:08,230 --> 00:20:13,210
the right bit and we know which bits are

475
00:20:11,289 --> 00:20:15,100
going to flip because we templated the

476
00:20:13,210 --> 00:20:17,890
the memory first so which bits are gonna

477
00:20:15,100 --> 00:20:20,080
flip so we flip exactly the right bit to

478
00:20:17,890 --> 00:20:22,600
create the pointer now pointing to our

479
00:20:20,080 --> 00:20:24,520
fake object and that means that when

480
00:20:22,600 --> 00:20:26,980
Java the JavaScript runtime wants to

481
00:20:24,520 --> 00:20:29,290
execute a method in the object on the

482
00:20:26,980 --> 00:20:30,250
left it really is going to execute code

483
00:20:29,290 --> 00:20:33,580
that we

484
00:20:30,250 --> 00:20:35,650
and executed I think and that means that

485
00:20:33,580 --> 00:20:36,970
we are now have full control over the

486
00:20:35,650 --> 00:20:39,250
browser okay

487
00:20:36,970 --> 00:20:42,460
and with that you go and win a pony

488
00:20:39,250 --> 00:20:44,380
award so we want a pony award for most

489
00:20:42,460 --> 00:20:45,850
innovative research with that and we

490
00:20:44,380 --> 00:20:47,020
thought you know that's great I thought

491
00:20:45,850 --> 00:20:49,060
this was great because there's a

492
00:20:47,020 --> 00:20:50,980
Microsoft bounty program of a hundred

493
00:20:49,060 --> 00:20:52,990
thousands and I was gonna cash in get a

494
00:20:50,980 --> 00:20:54,700
terrace and everything but Microsoft

495
00:20:52,990 --> 00:20:56,470
came back to us and said yeah well you

496
00:20:54,700 --> 00:20:58,180
know it's a bit of an issue it's a

497
00:20:56,470 --> 00:21:00,220
serious problem can you please not

498
00:20:58,180 --> 00:21:01,810
publish this and I said you know who

499
00:21:00,220 --> 00:21:03,400
cares about publications but all my

500
00:21:01,810 --> 00:21:07,710
students said we can't do that we really

501
00:21:03,400 --> 00:21:09,970
need to publish that's really bad so

502
00:21:07,710 --> 00:21:13,690
even though we observed the 90 days

503
00:21:09,970 --> 00:21:15,850
disclosure period we got $0 for this but

504
00:21:13,690 --> 00:21:17,200
that was that that was the only the

505
00:21:15,850 --> 00:21:19,990
beginning so we thought started thinking

506
00:21:17,200 --> 00:21:23,260
what else can we attack what else can we

507
00:21:19,990 --> 00:21:25,270
attack and okay so with the d2 post

508
00:21:23,260 --> 00:21:27,629
machina the next thing we were thinking

509
00:21:25,270 --> 00:21:30,639
of was can we do something in the cloud

510
00:21:27,630 --> 00:21:32,830
okay so the next thing dr. Graham going

511
00:21:30,640 --> 00:21:34,960
to discuss is book free exploitation in

512
00:21:32,830 --> 00:21:37,330
the cloud which uses the same primitives

513
00:21:34,960 --> 00:21:39,510
so it uses a row hammer vulnerability so

514
00:21:37,330 --> 00:21:42,429
this Hardware clips where you flip a bit

515
00:21:39,510 --> 00:21:44,379
and it uses the memory deduplication to

516
00:21:42,430 --> 00:21:47,080
side-channel but now we don't do this as

517
00:21:44,380 --> 00:21:49,540
a sari it uses memory deduplication but

518
00:21:47,080 --> 00:21:54,310
not as a side channel but rather as a

519
00:21:49,540 --> 00:21:57,970
way of deciding which memory a victim is

520
00:21:54,310 --> 00:22:00,879
going to use right so and with that will

521
00:21:57,970 --> 00:22:03,270
as we shall see we can compromise Linux

522
00:22:00,880 --> 00:22:06,130
KVM clouds without software bugs so

523
00:22:03,270 --> 00:22:09,310
let's let me explain this right so so in

524
00:22:06,130 --> 00:22:12,340
a cloud you have and you run KVM right

525
00:22:09,310 --> 00:22:16,810
so the the virtualization technology in

526
00:22:12,340 --> 00:22:18,909
Linux it has this feature called kernel

527
00:22:16,810 --> 00:22:20,770
st. page merging its memory

528
00:22:18,910 --> 00:22:22,450
deduplication it basically means that if

529
00:22:20,770 --> 00:22:24,040
there are two pages that are the same

530
00:22:22,450 --> 00:22:26,070
there will be merged just like in the

531
00:22:24,040 --> 00:22:30,030
previous case where this was on Windows

532
00:22:26,070 --> 00:22:30,030
okay so if we have a

533
00:22:31,220 --> 00:22:35,390
virtual machines in the cloud and one

534
00:22:33,260 --> 00:22:38,720
machine is owned by the attacker

535
00:22:35,390 --> 00:22:41,960
and there is memory in in the victim

536
00:22:38,720 --> 00:22:44,750
virtual machine somewhere a map to a

537
00:22:41,960 --> 00:22:47,120
physical DRAM and there's memory in a

538
00:22:44,750 --> 00:22:49,490
memory page in the attacker virtual

539
00:22:47,120 --> 00:22:51,919
machine mapped into physical DRAM if

540
00:22:49,490 --> 00:22:55,610
those pages are the same they will be

541
00:22:51,920 --> 00:22:58,630
merged ok so that means that both of

542
00:22:55,610 --> 00:23:02,270
them again use the same physical memory

543
00:22:58,630 --> 00:23:06,410
now what we're using this time is the

544
00:23:02,270 --> 00:23:08,420
property that we decide which page is

545
00:23:06,410 --> 00:23:10,370
going to be used which physical memory

546
00:23:08,420 --> 00:23:12,550
is going to be used so what we're going

547
00:23:10,370 --> 00:23:16,669
to do is we're going to first find one

548
00:23:12,550 --> 00:23:18,409
page where there's a bit flip row hammer

549
00:23:16,670 --> 00:23:20,000
vulnerability we've you know simply

550
00:23:18,410 --> 00:23:22,010
hammer everything until we find a bunch

551
00:23:20,000 --> 00:23:24,230
of bit flips and we say oh this page has

552
00:23:22,010 --> 00:23:26,900
bit flips right and then we're going to

553
00:23:24,230 --> 00:23:30,470
make sure that the data that is going to

554
00:23:26,900 --> 00:23:32,540
be deduplicated is going to be on this

555
00:23:30,470 --> 00:23:34,340
physical page which we control anyway

556
00:23:32,540 --> 00:23:36,500
right so we can put anything we want

557
00:23:34,340 --> 00:23:39,230
there and that means that if the

558
00:23:36,500 --> 00:23:42,410
deduplication kicks in the victim also

559
00:23:39,230 --> 00:23:44,090
uses this vulnerable page with bit flips

560
00:23:42,410 --> 00:23:46,850
on them ok

561
00:23:44,090 --> 00:23:50,060
so now we determine the physical page

562
00:23:46,850 --> 00:23:54,590
and we can hammer it and that means that

563
00:23:50,060 --> 00:23:57,710
a bit will flip on the page now the

564
00:23:54,590 --> 00:24:00,199
question is what can we do this what can

565
00:23:57,710 --> 00:24:04,220
I flip to gain access to a victim

566
00:24:00,200 --> 00:24:06,440
virtual machine and another question is

567
00:24:04,220 --> 00:24:08,600
you know we need to have a page that is

568
00:24:06,440 --> 00:24:12,110
exactly the same as the page of a victim

569
00:24:08,600 --> 00:24:14,990
which pages do we know to be the same ok

570
00:24:12,110 --> 00:24:18,620
so here's what we did we simply try to

571
00:24:14,990 --> 00:24:20,870
associate into the victim machine right

572
00:24:18,620 --> 00:24:22,310
just an acetate and of course we're not

573
00:24:20,870 --> 00:24:24,820
allowed because we don't have access to

574
00:24:22,310 --> 00:24:27,740
this to this machine

575
00:24:24,820 --> 00:24:30,050
it'll never never work but what the

576
00:24:27,740 --> 00:24:32,900
victim machine will do so even though

577
00:24:30,050 --> 00:24:36,320
it's not allowed is it will check on

578
00:24:32,900 --> 00:24:38,240
Linux the authorized keys file right

579
00:24:36,320 --> 00:24:40,879
this is just a file on desk which says

580
00:24:38,240 --> 00:24:42,750
you know this is the key of the Linux

581
00:24:40,880 --> 00:24:45,900
administrator for this machine

582
00:24:42,750 --> 00:24:48,600
right and what this will accomplish is

583
00:24:45,900 --> 00:24:50,940
that this file will now be in memory so

584
00:24:48,600 --> 00:24:53,899
there's a page in memory with the key

585
00:24:50,940 --> 00:24:57,300
the public key of the the administrator

586
00:24:53,900 --> 00:25:01,020
okay and this is a public key and public

587
00:24:57,300 --> 00:25:03,120
keys by definition are not secret right

588
00:25:01,020 --> 00:25:06,900
you can just go to github and look at

589
00:25:03,120 --> 00:25:09,270
people's public hebes so so we now know

590
00:25:06,900 --> 00:25:11,940
this public key is in in on this

591
00:25:09,270 --> 00:25:14,850
vulnerable page right so it's it's here

592
00:25:11,940 --> 00:25:17,520
and we can hammer it and that means we

593
00:25:14,850 --> 00:25:21,540
can flip a bit in the key the public key

594
00:25:17,520 --> 00:25:25,230
of the administrator right so we hammer

595
00:25:21,540 --> 00:25:28,440
away and a bit flips and you know these

596
00:25:25,230 --> 00:25:31,200
keys are chosen RSA keys right there

597
00:25:28,440 --> 00:25:34,410
chosen not arbitrarily the chosen

598
00:25:31,200 --> 00:25:36,990
because they are really really difficult

599
00:25:34,410 --> 00:25:39,540
to factorize now if you flip only a

600
00:25:36,990 --> 00:25:41,040
single bit in one of those public keys

601
00:25:39,540 --> 00:25:42,240
and I don't understand the cryptography

602
00:25:41,040 --> 00:25:44,190
behind this because we're not

603
00:25:42,240 --> 00:25:46,170
cryptographers but if a single bit flips

604
00:25:44,190 --> 00:25:48,560
in one of these keys all of a sudden

605
00:25:46,170 --> 00:25:52,230
they become really easy to factorize

606
00:25:48,560 --> 00:25:54,570
right and that means that we can break

607
00:25:52,230 --> 00:25:57,110
this change this key and then find a

608
00:25:54,570 --> 00:26:00,300
private key that corresponds to this key

609
00:25:57,110 --> 00:26:03,810
okay we can find a key that corresponds

610
00:26:00,300 --> 00:26:06,510
to this broken public key and that means

611
00:26:03,810 --> 00:26:09,590
we can now just use the Associates again

612
00:26:06,510 --> 00:26:13,320
with our you know new private key and

613
00:26:09,590 --> 00:26:20,010
and entered it into the the victim

614
00:26:13,320 --> 00:26:22,129
machine and let me just see if I can in

615
00:26:20,010 --> 00:26:28,379
the interest of time I'm going to skip

616
00:26:22,130 --> 00:26:31,110
the follow-up of that okay so so this is

617
00:26:28,380 --> 00:26:34,200
ban and cavae breaking the internet so

618
00:26:31,110 --> 00:26:37,260
they could actually not just compromise

619
00:26:34,200 --> 00:26:38,850
the the other virtual machine but they

620
00:26:37,260 --> 00:26:41,430
could also make the other virtual

621
00:26:38,850 --> 00:26:43,280
machine you get all of its updates and

622
00:26:41,430 --> 00:26:46,309
all of its

623
00:26:43,280 --> 00:26:49,520
new installation of packages coming from

624
00:26:46,309 --> 00:26:52,070
our machine right so we made sure that

625
00:26:49,520 --> 00:26:54,500
you know all the updates from the victim

626
00:26:52,070 --> 00:26:56,330
would would basically be retrieved from

627
00:26:54,500 --> 00:26:58,340
our machine fantastic stuff we thought

628
00:26:56,330 --> 00:27:01,129
this would would get us really make us

629
00:26:58,340 --> 00:27:02,928
really rich in reality we got zero money

630
00:27:01,130 --> 00:27:06,350
for this right so this was not

631
00:27:02,929 --> 00:27:08,450
interesting enough super frustrating so

632
00:27:06,350 --> 00:27:10,610
the next thing we did was try this on

633
00:27:08,450 --> 00:27:12,289
ARM processors right because mobile

634
00:27:10,610 --> 00:27:15,559
phones such a huge market people are

635
00:27:12,289 --> 00:27:18,440
going to care we thought let's do bug

636
00:27:15,559 --> 00:27:21,289
free exploitation on phones on Android

637
00:27:18,440 --> 00:27:22,760
phones okay and this was work by by

638
00:27:21,289 --> 00:27:24,320
victor von the vein and victor was

639
00:27:22,760 --> 00:27:25,640
looking for a project and we said you

640
00:27:24,320 --> 00:27:29,240
know why don't we try this on mobile

641
00:27:25,640 --> 00:27:32,570
phones and he tried and you know not

642
00:27:29,240 --> 00:27:34,669
only the techniques that we had on x86

643
00:27:32,570 --> 00:27:37,490
worked and this is not for lack of

644
00:27:34,669 --> 00:27:40,549
trying we try it really really hard and

645
00:27:37,490 --> 00:27:43,400
we did not get anywhere and you know to

646
00:27:40,549 --> 00:27:46,400
make matters worse victor went on a

647
00:27:43,400 --> 00:27:48,559
conference and then on an internship so

648
00:27:46,400 --> 00:27:51,289
we went to Barbados and then to Santa

649
00:27:48,559 --> 00:27:53,960
Barbara which is this really nice beach

650
00:27:51,289 --> 00:27:56,679
town and on the west coast Mady said

651
00:27:53,960 --> 00:27:58,880
don't worry I will work on it from there

652
00:27:56,679 --> 00:28:02,150
but I you know to be honest I was a

653
00:27:58,880 --> 00:28:04,610
little bit worried because Victor sent

654
00:28:02,150 --> 00:28:07,280
me a picture right this is very what he

655
00:28:04,610 --> 00:28:09,168
was doing there and you know week went

656
00:28:07,280 --> 00:28:11,889
by and there were no results and you

657
00:28:09,169 --> 00:28:15,020
know three weeks went by no results a

658
00:28:11,890 --> 00:28:16,669
month went by nothing right so we got

659
00:28:15,020 --> 00:28:18,918
absolutely nothing and he kept sending

660
00:28:16,669 --> 00:28:21,679
us pictures like this so so I send an

661
00:28:18,919 --> 00:28:25,220
email to everybody in the project and

662
00:28:21,679 --> 00:28:27,280
this is the actual email so just adding

663
00:28:25,220 --> 00:28:31,100
victor to this list and he's working in

664
00:28:27,280 --> 00:28:33,110
UCSB getting bit flips and from now on

665
00:28:31,100 --> 00:28:36,709
he's not allowed to go surfing until he

666
00:28:33,110 --> 00:28:39,889
gets the flip two days later bit flip

667
00:28:36,710 --> 00:28:42,289
just showing management skills here and

668
00:28:39,890 --> 00:28:45,140
then immediately afterwards victor send

669
00:28:42,289 --> 00:28:47,030
me a picture and this was anyway so this

670
00:28:45,140 --> 00:28:48,840
was kind of cool the we were able to

671
00:28:47,030 --> 00:28:52,049
exploit these

672
00:28:48,840 --> 00:28:54,600
phones from JavaScript completely

673
00:28:52,049 --> 00:28:56,580
compromised the phones and won a bunch

674
00:28:54,600 --> 00:29:00,030
of prizes including a pony award and

675
00:28:56,580 --> 00:29:03,149
then we contacted Google about this with

676
00:29:00,030 --> 00:29:05,039
a list of suggested mitigations and this

677
00:29:03,150 --> 00:29:07,320
was 91 days before we were going to

678
00:29:05,039 --> 00:29:09,929
publicist and they said you know that's

679
00:29:07,320 --> 00:29:12,360
really cool you definitely deserve a

680
00:29:09,929 --> 00:29:14,299
bounty for this but please can you call

681
00:29:12,360 --> 00:29:17,189
a publicist at another conference and

682
00:29:14,299 --> 00:29:19,320
everybody said no one you know so that

683
00:29:17,190 --> 00:29:21,720
didn't work what if we give you money

684
00:29:19,320 --> 00:29:24,178
and there's the old SIL that all know

685
00:29:21,720 --> 00:29:26,039
it's a it's violating the academic

686
00:29:24,179 --> 00:29:29,549
process and then they said what if you

687
00:29:26,039 --> 00:29:33,110
obfuscate the paper and in the end we

688
00:29:29,549 --> 00:29:35,700
got $4,000 for this for a critical issue

689
00:29:33,110 --> 00:29:37,469
simply because it didn't we didn't have

690
00:29:35,700 --> 00:29:40,350
in our paper any of the phones that were

691
00:29:37,470 --> 00:29:41,789
in the the reward program explicitly so

692
00:29:40,350 --> 00:29:44,100
we fixed that and immediately afterwards

693
00:29:41,789 --> 00:29:47,158
of course those phones were also in that

694
00:29:44,100 --> 00:29:50,039
in the system but you know we got $4,000

695
00:29:47,159 --> 00:29:53,159
for let's see four months of work by

696
00:29:50,039 --> 00:29:57,600
nine people they was not gonna get me a

697
00:29:53,159 --> 00:29:59,909
terrace um so but we were not gonna give

698
00:29:57,600 --> 00:30:01,320
up so we tried to do this but this was

699
00:29:59,909 --> 00:30:04,049
not from JavaScript I should say we were

700
00:30:01,320 --> 00:30:05,490
going to try this from JavaScript which

701
00:30:04,049 --> 00:30:06,750
I don't want happen because a lot of

702
00:30:05,490 --> 00:30:10,440
people doubted that you could actually

703
00:30:06,750 --> 00:30:11,880
do this from from JavaScript so shall we

704
00:30:10,440 --> 00:30:14,159
try this I'm not gonna explain the

705
00:30:11,880 --> 00:30:17,250
attack I just want to say that the way

706
00:30:14,159 --> 00:30:19,440
we did it was not by using the CPU it's

707
00:30:17,250 --> 00:30:22,320
not just a CPU that is a problem but on

708
00:30:19,440 --> 00:30:24,419
modern phones you have besides you know

709
00:30:22,320 --> 00:30:27,928
not your normal CPU you know more course

710
00:30:24,419 --> 00:30:31,010
you have your GPUs right your graphics

711
00:30:27,929 --> 00:30:33,929
processing units and they are nowadays

712
00:30:31,010 --> 00:30:36,690
completely accessible to JavaScript via

713
00:30:33,929 --> 00:30:39,000
that WebGL right so and WebGL gave us a

714
00:30:36,690 --> 00:30:41,880
lot of accesses to memory that we

715
00:30:39,000 --> 00:30:43,799
couldn't get via the the CPU and it

716
00:30:41,880 --> 00:30:46,020
allowed us to exploit you know modern

717
00:30:43,799 --> 00:30:50,400
browsers on our mobile phones from

718
00:30:46,020 --> 00:30:51,690
JavaScript and it got us no money so the

719
00:30:50,400 --> 00:30:53,370
next thing we thought you know if they

720
00:30:51,690 --> 00:30:55,049
don't care if the consumer devices don't

721
00:30:53,370 --> 00:30:57,178
care the client devices don't care what

722
00:30:55,049 --> 00:31:00,990
about this servers can we do this on

723
00:30:57,179 --> 00:31:03,220
servers so you know we're a little bit

724
00:31:00,990 --> 00:31:05,860
further in a time line now we've

725
00:31:03,220 --> 00:31:08,290
or every device on the client size that

726
00:31:05,860 --> 00:31:13,240
the site that we could think of what

727
00:31:08,290 --> 00:31:15,550
about servers can we attack servers from

728
00:31:13,240 --> 00:31:17,530
across the network's over remote attack

729
00:31:15,550 --> 00:31:20,080
all of the attacks that we've seen so

730
00:31:17,530 --> 00:31:22,180
far assume that we had JavaScript or

731
00:31:20,080 --> 00:31:24,490
something similar running on the victim

732
00:31:22,180 --> 00:31:26,950
machine flipping bits and then you know

733
00:31:24,490 --> 00:31:28,510
exploiting the system but what if we

734
00:31:26,950 --> 00:31:31,720
don't have that can we actually do this

735
00:31:28,510 --> 00:31:33,430
remotely and again I'm not gonna there's

736
00:31:31,720 --> 00:31:35,530
no time to explain this but we had this

737
00:31:33,430 --> 00:31:37,600
attack called throw hammer where you

738
00:31:35,530 --> 00:31:39,550
actually you know across a network you

739
00:31:37,600 --> 00:31:43,120
send a lot of data to a server and

740
00:31:39,550 --> 00:31:45,460
because the the the data gets stored in

741
00:31:43,120 --> 00:31:47,860
memory it has a lot of memory accesses

742
00:31:45,460 --> 00:31:50,350
and bits will flip and we showed that

743
00:31:47,860 --> 00:31:55,659
you could you know compromised say a

744
00:31:50,350 --> 00:31:59,409
memcache D key value server and exploit

745
00:31:55,660 --> 00:32:02,470
software got us no money obviously so

746
00:31:59,410 --> 00:32:04,360
you know the next step we thought

747
00:32:02,470 --> 00:32:05,920
because we people said on servers we

748
00:32:04,360 --> 00:32:07,449
don't really care because we have much

749
00:32:05,920 --> 00:32:09,220
better memory we don't have this

750
00:32:07,450 --> 00:32:13,780
vulnerable memory we have error

751
00:32:09,220 --> 00:32:16,210
correcting codes what could go wrong so

752
00:32:13,780 --> 00:32:18,879
we thought let's try ECC memory then so

753
00:32:16,210 --> 00:32:21,130
can we with ECC memory so ECC memory has

754
00:32:18,880 --> 00:32:23,890
this property that if a bit flips it's

755
00:32:21,130 --> 00:32:25,690
fine because there's error correcting

756
00:32:23,890 --> 00:32:28,300
code and it will automatically flip it

757
00:32:25,690 --> 00:32:32,320
back right that's what the ECC stands

758
00:32:28,300 --> 00:32:34,870
for so you have to flip multiple bits

759
00:32:32,320 --> 00:32:36,520
not just not to bits though right so if

760
00:32:34,870 --> 00:32:38,669
you flip one bit it will be corrected if

761
00:32:36,520 --> 00:32:40,750
you flip two bits the machine will crash

762
00:32:38,670 --> 00:32:42,280
right that's not what you want it's a

763
00:32:40,750 --> 00:32:43,660
denial of service attack perhaps but

764
00:32:42,280 --> 00:32:45,310
it's not what you want so you have to

765
00:32:43,660 --> 00:32:48,490
flip three bits and you have to flip the

766
00:32:45,310 --> 00:32:54,730
right three bits right to make sure that

767
00:32:48,490 --> 00:32:58,600
the and the the error is not corrected

768
00:32:54,730 --> 00:33:00,100
and not detected right so it's it's

769
00:32:58,600 --> 00:33:02,800
really really complicated but it turns

770
00:33:00,100 --> 00:33:05,889
out that you can still do this we did a

771
00:33:02,800 --> 00:33:08,649
lot of reverse engineering to find out

772
00:33:05,890 --> 00:33:11,140
how all of this work found a new side

773
00:33:08,650 --> 00:33:13,810
channel and we have this this attack

774
00:33:11,140 --> 00:33:15,450
that that you can actually launch at an

775
00:33:13,810 --> 00:33:17,610
ECC server

776
00:33:15,450 --> 00:33:21,000
and here is them here we are right so we

777
00:33:17,610 --> 00:33:22,979
got a distinguished paper award for this

778
00:33:21,000 --> 00:33:24,690
but you can see how happy we are because

779
00:33:22,980 --> 00:33:27,180
we're going to get super rich now right

780
00:33:24,690 --> 00:33:30,060
the the defenders are going to pay us

781
00:33:27,180 --> 00:33:34,350
all the enormous amount of bounty and we

782
00:33:30,060 --> 00:33:35,940
got zero this is not going well right I

783
00:33:34,350 --> 00:33:38,669
was never gonna get a terrace this way

784
00:33:35,940 --> 00:33:40,500
so maybe we should look at the other

785
00:33:38,670 --> 00:33:42,750
side and forget about these bit flips

786
00:33:40,500 --> 00:33:47,370
and maybe see if we can work on the side

787
00:33:42,750 --> 00:33:48,660
channels leaked more information okay so

788
00:33:47,370 --> 00:33:50,699
that's what I'm gonna talk about in a

789
00:33:48,660 --> 00:33:53,880
remainder of this talk so we're going to

790
00:33:50,700 --> 00:33:55,620
talk about the side channels in sorry i

791
00:33:53,880 --> 00:33:57,480
yeah that's what I'm going to talk about

792
00:33:55,620 --> 00:33:59,370
them in the remainder of the talk and

793
00:33:57,480 --> 00:34:01,380
I'm gonna skip a number of these

794
00:33:59,370 --> 00:34:05,989
attempts that we made right so we have

795
00:34:01,380 --> 00:34:08,580
in total can attacks in this full

796
00:34:05,990 --> 00:34:11,190
presentation and I'm going to skip seven

797
00:34:08,580 --> 00:34:14,100
to nine so three of them just want to

798
00:34:11,190 --> 00:34:16,409
say that we didn't get any money but I

799
00:34:14,100 --> 00:34:18,299
thought you know last year I thought

800
00:34:16,409 --> 00:34:20,069
there's actually a lot of you know

801
00:34:18,300 --> 00:34:24,300
publicity about this new kind of

802
00:34:20,070 --> 00:34:26,160
speculative execution attacks and this

803
00:34:24,300 --> 00:34:27,690
is all over the news it wasn't seen Anna

804
00:34:26,159 --> 00:34:30,178
what you don't see an and I thought you

805
00:34:27,690 --> 00:34:31,830
know people clearly care about this so

806
00:34:30,179 --> 00:34:35,910
let's let's see if we can do something

807
00:34:31,830 --> 00:34:37,620
in in this space and the idea this is

808
00:34:35,909 --> 00:34:41,639
the last thing I want to present it's

809
00:34:37,620 --> 00:34:43,230
something that was you know in the news

810
00:34:41,639 --> 00:34:45,900
in in this country and also other

811
00:34:43,230 --> 00:34:48,179
countries quite quite massively it's its

812
00:34:45,900 --> 00:34:51,600
riddle right it's rope in flight data

813
00:34:48,179 --> 00:34:54,450
loads and it's a vulnerability in a

814
00:34:51,600 --> 00:34:57,560
class of either a meltdown and specter

815
00:34:54,449 --> 00:34:59,759
and foreshadow right so this was all

816
00:34:57,560 --> 00:35:02,160
2018 there were a lot of these these

817
00:34:59,760 --> 00:35:05,340
attacks and they're super scary right

818
00:35:02,160 --> 00:35:08,250
and it's this was one of those and it

819
00:35:05,340 --> 00:35:10,530
it's the only time that my research team

820
00:35:08,250 --> 00:35:13,440
made it to the front page of the the

821
00:35:10,530 --> 00:35:15,300
newspapers so this is a the picture on

822
00:35:13,440 --> 00:35:17,070
the newspapers and at the time two of

823
00:35:15,300 --> 00:35:19,440
the members were not there so this is

824
00:35:17,070 --> 00:35:23,610
Cristiano and this is your key so they

825
00:35:19,440 --> 00:35:27,180
were also part of the team and and what

826
00:35:23,610 --> 00:35:29,420
we did in in this let's see if this

827
00:35:27,180 --> 00:35:29,419
works

828
00:35:39,680 --> 00:35:44,970
so what we did was was you see

829
00:35:42,890 --> 00:35:47,879
vulnerability to leak sensitive

830
00:35:44,970 --> 00:35:52,529
information and here's one example where

831
00:35:47,880 --> 00:35:56,009
initially you see that the some user is

832
00:35:52,529 --> 00:35:58,200
trying to access the EDC shadow file on

833
00:35:56,009 --> 00:35:59,930
a UNIX system this is where all the

834
00:35:58,200 --> 00:36:02,220
hashes of passwords are stored

835
00:35:59,930 --> 00:36:05,098
super-secret you're not allowed to touch

836
00:36:02,220 --> 00:36:07,140
this as a normal user and you can see

837
00:36:05,099 --> 00:36:10,349
that right so the first line it tries to

838
00:36:07,140 --> 00:36:13,170
show this et Cie password file and it

839
00:36:10,349 --> 00:36:15,420
says permission denied okay because

840
00:36:13,170 --> 00:36:18,960
you're not super user if you do this a

841
00:36:15,420 --> 00:36:22,200
super user so with pseudo et Cie shadow

842
00:36:18,960 --> 00:36:23,819
then you can actually observe the

843
00:36:22,200 --> 00:36:25,799
content of that year and that shadow

844
00:36:23,819 --> 00:36:28,499
file so you can see that here there's

845
00:36:25,799 --> 00:36:32,759
one line of this shadow file that is

846
00:36:28,499 --> 00:36:35,339
shown is the route entry so it has a the

847
00:36:32,759 --> 00:36:37,769
hash of the password for the root user

848
00:36:35,339 --> 00:36:40,259
this is what you're after this is what

849
00:36:37,769 --> 00:36:43,140
you want as an attacker but you can't

850
00:36:40,259 --> 00:36:46,680
access it except if you see you know

851
00:36:43,140 --> 00:36:49,259
here there's them oh you don't see the

852
00:36:46,680 --> 00:36:51,660
pointer you see that the attacker runs

853
00:36:49,259 --> 00:36:54,029
hack password right hack password

854
00:36:51,660 --> 00:36:55,828
without being super user so it's not

855
00:36:54,029 --> 00:36:59,430
with the sudo command so it's a regular

856
00:36:55,829 --> 00:37:01,229
user and the it types hack password and

857
00:36:59,430 --> 00:37:04,109
then root : because it's after the root

858
00:37:01,229 --> 00:37:09,029
user and you see that it very gradually

859
00:37:04,109 --> 00:37:11,130
finds every byte in this et Cie shadows

860
00:37:09,029 --> 00:37:12,960
entry for your root user and this is

861
00:37:11,130 --> 00:37:15,680
nowadays really fast you can do this

862
00:37:12,960 --> 00:37:19,680
within a minute okay

863
00:37:15,680 --> 00:37:22,919
so how does that work the vulnerability

864
00:37:19,680 --> 00:37:25,288
is called rogue in-flight data load and

865
00:37:22,920 --> 00:37:28,259
this is really what it is there's data

866
00:37:25,289 --> 00:37:32,460
in flight on your processor all the time

867
00:37:28,259 --> 00:37:35,670
and sometimes Intel doesn't take good

868
00:37:32,460 --> 00:37:37,829
care of this data okay so it's a class

869
00:37:35,670 --> 00:37:39,930
of speculative execution attacks it's

870
00:37:37,829 --> 00:37:41,839
not just one attack and there's several

871
00:37:39,930 --> 00:37:43,879
aspects to it

872
00:37:41,839 --> 00:37:47,089
a class of speculative execution attack

873
00:37:43,880 --> 00:37:50,660
that Intel now calls micro architectural

874
00:37:47,089 --> 00:37:52,670
data sampling and just to emphasize what

875
00:37:50,660 --> 00:37:55,149
you can do with this you can leak data

876
00:37:52,670 --> 00:37:58,249
from a normal process without any

877
00:37:55,150 --> 00:38:00,079
privileges and you can leak data from

878
00:37:58,249 --> 00:38:02,899
another process right

879
00:38:00,079 --> 00:38:07,329
another hyper threat on the same core

880
00:38:02,900 --> 00:38:09,950
but also from the kernel from other

881
00:38:07,329 --> 00:38:14,089
virtual machines from the hypervisor

882
00:38:09,950 --> 00:38:18,109
itself and even from super secure and

883
00:38:14,089 --> 00:38:19,849
claves such as protected by pius IX okay

884
00:38:18,109 --> 00:38:23,420
moreover you can do this from the

885
00:38:19,849 --> 00:38:26,450
browser from javascript okay so this is

886
00:38:23,420 --> 00:38:28,519
kind of bad and it's different from the

887
00:38:26,450 --> 00:38:32,089
previous attacks melt inspector and

888
00:38:28,519 --> 00:38:34,968
foreshadow in the sense that all of

889
00:38:32,089 --> 00:38:37,519
these previous attacks used addresses

890
00:38:34,969 --> 00:38:40,219
you can leave speculatively leaked data

891
00:38:37,519 --> 00:38:42,618
using addresses and if you have you know

892
00:38:40,219 --> 00:38:44,329
the right sort of address you walk at

893
00:38:42,619 --> 00:38:46,819
you know some some part of the

894
00:38:44,329 --> 00:38:49,489
information but it also means that you

895
00:38:46,819 --> 00:38:54,319
can mitigate this by by focusing on the

896
00:38:49,489 --> 00:38:57,859
addresses right all of the mitigations

897
00:38:54,319 --> 00:39:00,950
simply focus on these these these

898
00:38:57,859 --> 00:39:04,249
addresses for instance for Spector you

899
00:39:00,950 --> 00:39:06,558
can leak addresses as you know at least

900
00:39:04,249 --> 00:39:09,649
one parent of of address of Spector you

901
00:39:06,559 --> 00:39:12,410
can leak information beyond a buffer

902
00:39:09,650 --> 00:39:14,450
boundary right and that that you know

903
00:39:12,410 --> 00:39:17,058
the mitigation simply make sure that all

904
00:39:14,450 --> 00:39:19,218
the addresses are inbound right so it

905
00:39:17,059 --> 00:39:21,289
makes your letter inbound from meltdown

906
00:39:19,219 --> 00:39:22,880
you can leak data from kernel addresses

907
00:39:21,289 --> 00:39:25,099
so you simply make sure that there is no

908
00:39:22,880 --> 00:39:27,259
kernel addresses in your address space

909
00:39:25,099 --> 00:39:29,119
anymore so so no kernel data in your

910
00:39:27,259 --> 00:39:31,640
address space anymore also all of these

911
00:39:29,119 --> 00:39:36,920
mitigations are spot mitigations for

912
00:39:31,640 --> 00:39:39,640
these particular things okay so a bunch

913
00:39:36,920 --> 00:39:44,180
of these this dis mitigation they're all

914
00:39:39,640 --> 00:39:45,410
you know as you know all the medications

915
00:39:44,180 --> 00:39:47,499
that we've seen so far our spot

916
00:39:45,410 --> 00:39:51,259
medication so they're not super

917
00:39:47,499 --> 00:39:53,180
structural and not complete okay

918
00:39:51,259 --> 00:39:54,500
so riddle doesn't use any addressing at

919
00:39:53,180 --> 00:39:56,990
all it doesn't care about

920
00:39:54,500 --> 00:39:59,420
addresses it simply leaks information

921
00:39:56,990 --> 00:40:00,529
that happens to be floating around your

922
00:39:59,420 --> 00:40:04,430
your CPU

923
00:40:00,530 --> 00:40:06,560
none of the mitigations work and and we

924
00:40:04,430 --> 00:40:09,529
don't believe in in logos so we don't

925
00:40:06,560 --> 00:40:12,110
have a logo for for riddle what we do

926
00:40:09,530 --> 00:40:16,190
have is a lot of CPUs so we bought every

927
00:40:12,110 --> 00:40:17,720
single Intel CPU since 2008 right and

928
00:40:16,190 --> 00:40:20,360
some of them are hard to get you have to

929
00:40:17,720 --> 00:40:22,339
go on eBay or marketplace or so on and

930
00:40:20,360 --> 00:40:24,890
get some old Intel CPUs so we bought

931
00:40:22,340 --> 00:40:27,260
every model since 2008 and we bought to

932
00:40:24,890 --> 00:40:30,500
IKEA racks right so these are actual

933
00:40:27,260 --> 00:40:32,200
IKEA racks in our students room that to

934
00:40:30,500 --> 00:40:35,300
store all of these all of these machines

935
00:40:32,200 --> 00:40:38,720
also buns bought a bunch of AMD's and

936
00:40:35,300 --> 00:40:42,920
ARM processors and riddle works on all

937
00:40:38,720 --> 00:40:45,770
Intel processors since 2008 hey doesn't

938
00:40:42,920 --> 00:40:47,390
work on AMD doesn't work in our okay so

939
00:40:45,770 --> 00:40:49,130
all of the Intel these are some of the

940
00:40:47,390 --> 00:40:50,990
the Intel processors that we tried and

941
00:40:49,130 --> 00:40:53,330
right after we submitted the paper we

942
00:40:50,990 --> 00:41:00,140
actually got a new Intel processor and

943
00:40:53,330 --> 00:41:02,690
the core i9 9900 and that had in

944
00:41:00,140 --> 00:41:04,490
hardware in silicon mitigations against

945
00:41:02,690 --> 00:41:07,190
the previous speculative execution

946
00:41:04,490 --> 00:41:09,770
attacks so we thought you know does that

947
00:41:07,190 --> 00:41:12,980
work and it sure enough riddles simply

948
00:41:09,770 --> 00:41:14,870
worked without any problem ok so it

949
00:41:12,980 --> 00:41:17,540
works great on Intel doesn't work on AMD

950
00:41:14,870 --> 00:41:19,940
doesn't work on own that's not to say

951
00:41:17,540 --> 00:41:21,380
that they're you know not other there's

952
00:41:19,940 --> 00:41:23,180
probably other vulnerabilities an arm

953
00:41:21,380 --> 00:41:28,070
and and AMD but just not know this one

954
00:41:23,180 --> 00:41:30,859
and and the way where we're leaking from

955
00:41:28,070 --> 00:41:33,380
is important so we're leaking not from

956
00:41:30,860 --> 00:41:36,550
the usual places so the usual we've you

957
00:41:33,380 --> 00:41:39,950
know everybody knows that CPUs have

958
00:41:36,550 --> 00:41:42,560
caches and level 1 cache and a level 2

959
00:41:39,950 --> 00:41:45,049
cache where data is temporarily stored

960
00:41:42,560 --> 00:41:47,120
but what very few people know is that

961
00:41:45,050 --> 00:41:49,580
there are lots and lots of other places

962
00:41:47,120 --> 00:41:52,190
lots and lots of other buffers on the

963
00:41:49,580 --> 00:41:56,029
processor where data is temporarily

964
00:41:52,190 --> 00:41:58,220
stored ok one of them is this thing

965
00:41:56,030 --> 00:42:00,080
called the line fill buffer there's a

966
00:41:58,220 --> 00:42:03,109
bunch of others the store and forward

967
00:42:00,080 --> 00:42:05,360
buffer and the load port ok but let's

968
00:42:03,110 --> 00:42:06,710
focus on on only the line fill buffer in

969
00:42:05,360 --> 00:42:09,260
the interest of time

970
00:42:06,710 --> 00:42:10,670
so line fill buffers if you look at the

971
00:42:09,260 --> 00:42:12,770
documentation and there's very little

972
00:42:10,670 --> 00:42:14,900
documentation we read about what the

973
00:42:12,770 --> 00:42:17,810
students I should say have read about 50

974
00:42:14,900 --> 00:42:20,420
patents right this is a probably the

975
00:42:17,810 --> 00:42:23,270
worst job that they've ever had so

976
00:42:20,420 --> 00:42:25,100
they're at 50 pen that patent and it

977
00:42:23,270 --> 00:42:28,220
says that you know these line fill

978
00:42:25,100 --> 00:42:30,740
buffers are used for asynchronous memory

979
00:42:28,220 --> 00:42:33,169
requests loads quashing were right

980
00:42:30,740 --> 00:42:34,520
combining on Casman who knows right so

981
00:42:33,170 --> 00:42:35,780
who knows what they all mean let's just

982
00:42:34,520 --> 00:42:38,000
look at one of them

983
00:42:35,780 --> 00:42:41,120
asynchronous memory requests what does

984
00:42:38,000 --> 00:42:47,900
that mean well it basically tries to use

985
00:42:41,120 --> 00:42:50,810
the cache more efficiently okay so it's

986
00:42:47,900 --> 00:42:55,370
a central buffer between the execution

987
00:42:50,810 --> 00:42:59,330
units here and the the caches to improve

988
00:42:55,370 --> 00:43:03,049
memory throughput so for instance if you

989
00:42:59,330 --> 00:43:06,380
have a cache miss right what you could

990
00:43:03,050 --> 00:43:09,680
do is simply go and look for the memory

991
00:43:06,380 --> 00:43:11,060
of the data memory so and wait until you

992
00:43:09,680 --> 00:43:12,230
get that and then give that data back

993
00:43:11,060 --> 00:43:13,970
but that's really an efficient because

994
00:43:12,230 --> 00:43:16,190
you're blocking the cache nobody else

995
00:43:13,970 --> 00:43:18,529
can use the cache in the mean time so

996
00:43:16,190 --> 00:43:22,160
what they're doing instead is they say

997
00:43:18,530 --> 00:43:24,470
let's allocate one entry in this special

998
00:43:22,160 --> 00:43:28,279
buffer this lfb the line fill buffer

999
00:43:24,470 --> 00:43:31,759
right and and that can deal with this

1000
00:43:28,280 --> 00:43:33,380
memory request that had a cache miss get

1001
00:43:31,760 --> 00:43:35,390
it from memory you know get it in the

1002
00:43:33,380 --> 00:43:40,850
line fill buffer and then later on I'll

1003
00:43:35,390 --> 00:43:42,049
put it in the cache so that's much more

1004
00:43:40,850 --> 00:43:44,870
efficient because in the meantime you

1005
00:43:42,050 --> 00:43:46,360
can use the cache for other things right

1006
00:43:44,870 --> 00:43:49,790
so that works really well

1007
00:43:46,360 --> 00:43:53,000
now unfortunately Intel is not is really

1008
00:43:49,790 --> 00:43:55,940
sloppy with that cache so the cache may

1009
00:43:53,000 --> 00:43:57,770
contain data right so may contain data

1010
00:43:55,940 --> 00:44:00,950
that have nothing to do with your

1011
00:43:57,770 --> 00:44:02,540
program could be containing data from

1012
00:44:00,950 --> 00:44:04,910
you know completely different program

1013
00:44:02,540 --> 00:44:09,140
from the kernel from other processes and

1014
00:44:04,910 --> 00:44:10,700
so on and in certain cases namely under

1015
00:44:09,140 --> 00:44:12,230
what is sometimes referred to as

1016
00:44:10,700 --> 00:44:14,660
speculative execution although it's a

1017
00:44:12,230 --> 00:44:17,540
little bit of a sloppy term here in some

1018
00:44:14,660 --> 00:44:19,109
cases you actually get the data from

1019
00:44:17,540 --> 00:44:22,440
somebody else

1020
00:44:19,109 --> 00:44:24,930
all right this is insane but it's fine

1021
00:44:22,440 --> 00:44:28,140
because what as intel sees it right

1022
00:44:24,930 --> 00:44:30,239
because you know or even if you get that

1023
00:44:28,140 --> 00:44:32,670
data the results will never be visible

1024
00:44:30,239 --> 00:44:34,680
right so there will squash those results

1025
00:44:32,670 --> 00:44:37,559
it will realize like oh that's not your

1026
00:44:34,680 --> 00:44:39,598
data or remove those and it's fine but

1027
00:44:37,559 --> 00:44:43,459
there are still traces there's traces in

1028
00:44:39,599 --> 00:44:46,170
the cache that that allow an attacker to

1029
00:44:43,459 --> 00:44:48,930
to see what that data is

1030
00:44:46,170 --> 00:44:50,940
okay so the attack that we showed

1031
00:44:48,930 --> 00:44:53,160
earlier basically does the following you

1032
00:44:50,940 --> 00:44:55,079
have a victim vm with this EDC shadow

1033
00:44:53,160 --> 00:44:57,058
file and you have an attacker vm and

1034
00:44:55,079 --> 00:44:59,069
there's this line fill buffer that is

1035
00:44:57,059 --> 00:45:03,180
shared by the victim and the attacker

1036
00:44:59,069 --> 00:45:07,319
and we have an ssh client connecting to

1037
00:45:03,180 --> 00:45:10,919
the to the victim via ok now because of

1038
00:45:07,319 --> 00:45:13,469
that the victim vm will load this et Cie

1039
00:45:10,920 --> 00:45:15,900
shadow file in memory and this will go

1040
00:45:13,469 --> 00:45:17,640
through this line fill buffer initially

1041
00:45:15,900 --> 00:45:19,170
it's a cache miss so the line fill

1042
00:45:17,640 --> 00:45:20,848
buffer will take care of this it's in

1043
00:45:19,170 --> 00:45:23,279
the data's in the in the line fill

1044
00:45:20,849 --> 00:45:28,410
buffer and then we run this riddle code

1045
00:45:23,279 --> 00:45:31,140
it's a secret little code and leak the

1046
00:45:28,410 --> 00:45:32,729
data now Intel tells you this is really

1047
00:45:31,140 --> 00:45:34,799
really difficult to exploit it's a

1048
00:45:32,729 --> 00:45:36,959
really complicated attack it actually

1049
00:45:34,799 --> 00:45:39,538
you know what is behind it is really

1050
00:45:36,959 --> 00:45:42,118
complicated but the attack is one line

1051
00:45:39,539 --> 00:45:43,289
of code literally one line of code it

1052
00:45:42,119 --> 00:45:45,239
could be this one there could be

1053
00:45:43,289 --> 00:45:47,039
actually other lines of code also that

1054
00:45:45,239 --> 00:45:50,009
leaked the same thing in this case we

1055
00:45:47,039 --> 00:45:52,170
simply under now whether you're familiar

1056
00:45:50,009 --> 00:45:54,269
with the C programming language but it's

1057
00:45:52,170 --> 00:45:56,609
in this case it's just a dereference of

1058
00:45:54,269 --> 00:45:58,169
a null pointer right that's the only

1059
00:45:56,609 --> 00:46:01,709
thing you need to do to get somebody

1060
00:45:58,170 --> 00:46:04,829
else's data right so it's not difficult

1061
00:46:01,709 --> 00:46:08,729
at all ok and then you use traditional

1062
00:46:04,829 --> 00:46:10,739
methods to you know infer what the data

1063
00:46:08,729 --> 00:46:12,930
is the only problem with this attack is

1064
00:46:10,739 --> 00:46:14,699
that it's not that it's difficult to get

1065
00:46:12,930 --> 00:46:16,828
somebody else's data but you're getting

1066
00:46:14,699 --> 00:46:19,890
too much of it you're getting all the

1067
00:46:16,829 --> 00:46:21,180
data right and figuring out what data is

1068
00:46:19,890 --> 00:46:23,459
interesting and what they does not

1069
00:46:21,180 --> 00:46:27,930
interesting is really the challenge here

1070
00:46:23,459 --> 00:46:29,788
ok so in the case of the EDC shadow file

1071
00:46:27,930 --> 00:46:32,490
and in many other cases it's actually

1072
00:46:29,789 --> 00:46:34,650
trivial so we know part of

1073
00:46:32,490 --> 00:46:36,118
the data that we're after and we just

1074
00:46:34,650 --> 00:46:38,790
want to figure out the rest of it for

1075
00:46:36,119 --> 00:46:42,390
instance in the et Cie shadow file we're

1076
00:46:38,790 --> 00:46:44,550
looking for the entry for route : so we

1077
00:46:42,390 --> 00:46:47,279
simply said we know that the data starts

1078
00:46:44,550 --> 00:46:49,050
with route : so what we're doing is the

1079
00:46:47,280 --> 00:46:51,750
same thing that the people do in D in

1080
00:46:49,050 --> 00:46:53,250
DNA sequencing sequence alignment we

1081
00:46:51,750 --> 00:46:54,930
have all of these bits and pieces

1082
00:46:53,250 --> 00:46:56,670
floating around and you just have to

1083
00:46:54,930 --> 00:46:59,549
match them up and try to figure okay

1084
00:46:56,670 --> 00:47:02,340
this is my genome for instance writes my

1085
00:46:59,550 --> 00:47:04,140
DNA we do something similar we know that

1086
00:47:02,340 --> 00:47:06,270
it has to start with route so we're

1087
00:47:04,140 --> 00:47:09,330
looking for data in this line fill

1088
00:47:06,270 --> 00:47:13,290
buffer that starts with route : okay and

1089
00:47:09,330 --> 00:47:15,000
then when we see data that you know

1090
00:47:13,290 --> 00:47:17,430
drinking from the fire hose and we're

1091
00:47:15,000 --> 00:47:19,440
seeing data that doesn't match that we

1092
00:47:17,430 --> 00:47:22,470
know that this is the wrong data but if

1093
00:47:19,440 --> 00:47:25,530
we do get data where we actually see

1094
00:47:22,470 --> 00:47:27,629
partial and partial match the first four

1095
00:47:25,530 --> 00:47:29,760
characters or five characters have the

1096
00:47:27,630 --> 00:47:32,130
same beginning then that's probably a

1097
00:47:29,760 --> 00:47:34,080
match right so we know that we then take

1098
00:47:32,130 --> 00:47:35,250
the next byte and we say oh that's the

1099
00:47:34,080 --> 00:47:37,680
that's the right part that's the next

1100
00:47:35,250 --> 00:47:39,510
point okay and then we see more daytime

1101
00:47:37,680 --> 00:47:41,790
we say oh that's no good and then we see

1102
00:47:39,510 --> 00:47:43,830
data again which starts with again the

1103
00:47:41,790 --> 00:47:46,590
same prefix and we take the next

1104
00:47:43,830 --> 00:47:49,529
character right we do the same you know

1105
00:47:46,590 --> 00:47:53,940
partial gassing for all of these things

1106
00:47:49,530 --> 00:47:56,640
until we have a full root password hash

1107
00:47:53,940 --> 00:48:03,000
of the root password okay so we disclose

1108
00:47:56,640 --> 00:48:04,500
this to Intel in September 2018 and this

1109
00:48:03,000 --> 00:48:06,270
time on December we heard that there

1110
00:48:04,500 --> 00:48:08,130
were some other finders so Intel told us

1111
00:48:06,270 --> 00:48:10,830
there were three other finders of this

1112
00:48:08,130 --> 00:48:13,109
vulnerability we thought you know and

1113
00:48:10,830 --> 00:48:14,759
that's too bad too you know two of them

1114
00:48:13,109 --> 00:48:16,710
were from the commercial world from

1115
00:48:14,760 --> 00:48:20,990
industry one of them was an academic so

1116
00:48:16,710 --> 00:48:23,790
we invited him on our paper and then oh

1117
00:48:20,990 --> 00:48:28,140
yeah guess how much we got for this in

1118
00:48:23,790 --> 00:48:31,980
terms of a bounty program one hundred

1119
00:48:28,140 --> 00:48:37,049
thousands we got a hundred thousand yeah

1120
00:48:31,980 --> 00:48:38,700
I got a terrace right and then the

1121
00:48:37,050 --> 00:48:43,500
university told us that all the bounty

1122
00:48:38,700 --> 00:48:45,740
money goes to the University anyway so

1123
00:48:43,500 --> 00:48:49,619
this photo process was a really you know

1124
00:48:45,740 --> 00:48:51,089
bizarre procedure with Intel telling us

1125
00:48:49,619 --> 00:48:53,130
you know one thing and unchanging the

1126
00:48:51,089 --> 00:48:56,009
story after a while and and you know

1127
00:48:53,130 --> 00:48:58,410
like I said we found other finders and

1128
00:48:56,010 --> 00:49:00,180
in December and then just before the

1129
00:48:58,410 --> 00:49:02,190
publication of a paper intel told us

1130
00:49:00,180 --> 00:49:05,279
wait there's actually you know a zillion

1131
00:49:02,190 --> 00:49:06,930
other finders right so and it's really

1132
00:49:05,280 --> 00:49:09,510
complicated now if you want to know the

1133
00:49:06,930 --> 00:49:12,720
full story go to MDS s and yesterday at

1134
00:49:09,510 --> 00:49:17,520
tax dot-com it's an interesting story so

1135
00:49:12,720 --> 00:49:19,109
conclusion Intel CPUs are vulnerable and

1136
00:49:17,520 --> 00:49:22,829
Intel really doesn't take care of its

1137
00:49:19,109 --> 00:49:24,390
data carefully and if you have Intel

1138
00:49:22,829 --> 00:49:26,520
CPUs you really should apply these

1139
00:49:24,390 --> 00:49:28,410
patches if you have you know four

1140
00:49:26,520 --> 00:49:30,650
different security domains running on

1141
00:49:28,410 --> 00:49:32,399
the same same machine if you have

1142
00:49:30,650 --> 00:49:34,230
different security domains and

1143
00:49:32,400 --> 00:49:36,329
hyper-threading turn off hyper threading

1144
00:49:34,230 --> 00:49:37,740
it's expensive but it's worth it if you

1145
00:49:36,329 --> 00:49:40,349
really don't trust the other domains

1146
00:49:37,740 --> 00:49:42,299
it's it's it's so hyper threading is

1147
00:49:40,349 --> 00:49:45,180
vulnerable even with whatever Intel

1148
00:49:42,300 --> 00:49:48,079
tells you in its advisory turn off hyper

1149
00:49:45,180 --> 00:49:52,379
threading there are other reasons

1150
00:49:48,079 --> 00:49:53,910
sharing is not caring the other thing is

1151
00:49:52,380 --> 00:49:56,849
that I still don't have a terrace we

1152
00:49:53,910 --> 00:49:59,220
suck at bounty programs attackers need

1153
00:49:56,849 --> 00:50:02,579
read/write primitives and for right

1154
00:49:59,220 --> 00:50:04,770
primitives they can use glitches we saw

1155
00:50:02,579 --> 00:50:06,510
ro hammer vulnerabilities that allow you

1156
00:50:04,770 --> 00:50:08,310
to flip it and even if it's just a

1157
00:50:06,510 --> 00:50:11,250
single bit it's enough for an attacker

1158
00:50:08,310 --> 00:50:14,220
to to get full compromise of your entire

1159
00:50:11,250 --> 00:50:16,109
system for reprinted we have managed

1160
00:50:14,220 --> 00:50:18,509
side channels right so there's many of

1161
00:50:16,109 --> 00:50:20,220
them including this new riddle attack

1162
00:50:18,510 --> 00:50:22,290
and these vulnerabilities change

1163
00:50:20,220 --> 00:50:24,810
everything because even if your software

1164
00:50:22,290 --> 00:50:27,000
is completely formally verified it's no

1165
00:50:24,810 --> 00:50:31,140
longer secure and I want to part with

1166
00:50:27,000 --> 00:50:35,490
this the defenders get this wrong also

1167
00:50:31,140 --> 00:50:37,710
right so Microsoft in in 2016 had this

1168
00:50:35,490 --> 00:50:41,520
statement really proudly said that at

1169
00:50:37,710 --> 00:50:43,470
blackhat 2016 it said thanks to our

1170
00:50:41,520 --> 00:50:44,690
mitigation improvements since releasing

1171
00:50:43,470 --> 00:50:46,970
the Microsoft ads for

1172
00:50:44,690 --> 00:50:49,540
one year ago that means no zero day

1173
00:50:46,970 --> 00:50:53,209
exploits targeting Microsoft ads on that

1174
00:50:49,540 --> 00:50:55,849
very same day we had a talk at that very

1175
00:50:53,210 --> 00:50:57,560
same conference saying you know there's

1176
00:50:55,849 --> 00:50:59,960
an exploit of the latest Microsoft ads

1177
00:50:57,560 --> 00:51:03,230
browser with all defenses up and not

1178
00:50:59,960 --> 00:51:05,720
having any software vulnerabilities at

1179
00:51:03,230 --> 00:51:10,210
all all right thank you very much

1180
00:51:05,720 --> 00:51:10,209
[Applause]

