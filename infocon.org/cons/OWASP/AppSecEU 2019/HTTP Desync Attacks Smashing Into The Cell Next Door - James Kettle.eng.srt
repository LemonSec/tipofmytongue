1
00:00:00,530 --> 00:00:05,000
you

2
00:00:02,480 --> 00:00:07,279
afternoon good morning even just about

3
00:00:05,000 --> 00:00:10,879
and welcome to httpd cinq attacks

4
00:00:07,279 --> 00:00:13,010
smashing into the cell next door have

5
00:00:10,880 --> 00:00:15,559
you ever seen a system that was so

6
00:00:13,010 --> 00:00:18,860
complex it just had to be vulnerable

7
00:00:15,559 --> 00:00:20,240
these days weevil on layer upon layer of

8
00:00:18,860 --> 00:00:22,160
abstraction to have the faintest

9
00:00:20,240 --> 00:00:25,070
understanding of what's really happening

10
00:00:22,160 --> 00:00:27,170
with a website and we tell people things

11
00:00:25,070 --> 00:00:30,019
like HTTP is stateless

12
00:00:27,170 --> 00:00:33,620
and you send one request you get one

13
00:00:30,019 --> 00:00:36,680
response but what if both of those were

14
00:00:33,620 --> 00:00:38,419
just kind of want in this session I'll

15
00:00:36,680 --> 00:00:41,299
share with you new tools and techniques

16
00:00:38,420 --> 00:00:42,830
to D synchronize complex systems smash

17
00:00:41,299 --> 00:00:45,440
through the barriers around HTTP

18
00:00:42,830 --> 00:00:48,949
requests and make websites rain exploits

19
00:00:45,440 --> 00:00:51,890
on their visitors during some research

20
00:00:48,949 --> 00:00:54,530
last year I came up with a theory which

21
00:00:51,890 --> 00:00:57,530
was if you're trying to select a topic

22
00:00:54,530 --> 00:00:59,420
to research then the best topic is the

23
00:00:57,530 --> 00:01:02,360
one that makes you personally the most

24
00:00:59,420 --> 00:01:04,699
nervous and this year I thought okay I'm

25
00:01:02,360 --> 00:01:08,509
gonna try this theory out so ask myself

26
00:01:04,699 --> 00:01:11,600
what topic am I really scared of and the

27
00:01:08,509 --> 00:01:13,909
answer for me was HTTP requests mugging

28
00:01:11,600 --> 00:01:16,038
I saw a talk on this a few years ago at

29
00:01:13,909 --> 00:01:19,399
Def Con called hiding what keys in HTTP

30
00:01:16,039 --> 00:01:21,530
and it was a thrilling presentation but

31
00:01:19,399 --> 00:01:24,109
it left me far too nervous to tackle

32
00:01:21,530 --> 00:01:24,740
that topic myself for a number of

33
00:01:24,109 --> 00:01:26,689
reasons

34
00:01:24,740 --> 00:01:30,020
one of them is that this technique was

35
00:01:26,689 --> 00:01:32,990
first documented way back in 2005 and

36
00:01:30,020 --> 00:01:36,829
yet I'd never seen it successfully used

37
00:01:32,990 --> 00:01:38,719
on a real website another issue was that

38
00:01:36,829 --> 00:01:40,600
some of the diagrams made absolutely no

39
00:01:38,719 --> 00:01:43,428
sense to me because my technical

40
00:01:40,600 --> 00:01:46,309
understanding at such low level HTTP

41
00:01:43,429 --> 00:01:47,810
stuff was not up to scratch and then

42
00:01:46,310 --> 00:01:51,109
also there were some really worrying

43
00:01:47,810 --> 00:01:53,060
statements on some of the slides one of

44
00:01:51,109 --> 00:01:56,449
them said you will not earn bounties

45
00:01:53,060 --> 00:01:58,219
using this research and another even

46
00:01:56,450 --> 00:02:00,049
worth said you will certainly not be

47
00:01:58,219 --> 00:02:02,658
considered like a white hat if you even

48
00:02:00,049 --> 00:02:04,880
test to see if any live web sites are

49
00:02:02,659 --> 00:02:08,440
vulnerable because this technique can

50
00:02:04,880 --> 00:02:10,299
have such catastrophic consequences

51
00:02:08,440 --> 00:02:12,160
so at the time I thought okay I'm just

52
00:02:10,300 --> 00:02:13,930
gonna leave this well alone but this

53
00:02:12,160 --> 00:02:18,040
year I thought I'll just try this out

54
00:02:13,930 --> 00:02:20,920
and see what happens and well quite a

55
00:02:18,040 --> 00:02:23,200
few things happened I did manage to earn

56
00:02:20,920 --> 00:02:25,630
some bounties and no one's called me a

57
00:02:23,200 --> 00:02:27,399
black hat for it so far although after I

58
00:02:25,630 --> 00:02:33,490
first gave this talk on Twitter someone

59
00:02:27,400 --> 00:02:35,290
did call me a terrorist but I did get

60
00:02:33,490 --> 00:02:37,510
quite a few interesting reactions a

61
00:02:35,290 --> 00:02:40,150
number of people were surprised but one

62
00:02:37,510 --> 00:02:41,620
guy was so surprised with the

63
00:02:40,150 --> 00:02:44,050
vulnerability that I found in his site

64
00:02:41,620 --> 00:02:46,030
that he seemed to think I was faking the

65
00:02:44,050 --> 00:02:48,310
entire thing that I was doing some kind

66
00:02:46,030 --> 00:02:51,820
of digital sleight of hand in order to

67
00:02:48,310 --> 00:02:53,140
trick him into paying me a bounty I now

68
00:02:51,820 --> 00:02:55,870
the other end of the spectrum a

69
00:02:53,140 --> 00:02:58,269
different guy liked the unique technique

70
00:02:55,870 --> 00:03:00,040
that I used on his company's website so

71
00:02:58,270 --> 00:03:01,540
much he thought he would take that

72
00:03:00,040 --> 00:03:03,340
technique for himself and try and earn

73
00:03:01,540 --> 00:03:06,880
himself some bounties using this

74
00:03:03,340 --> 00:03:08,320
technique behind my back and of course I

75
00:03:06,880 --> 00:03:10,380
had no idea he was doing this he didn't

76
00:03:08,320 --> 00:03:12,760
tell me who asked me or anything until

77
00:03:10,380 --> 00:03:13,660
he ran into some technical issues with

78
00:03:12,760 --> 00:03:15,040
it because it wasn't the easiest

79
00:03:13,660 --> 00:03:17,680
technique in the world

80
00:03:15,040 --> 00:03:19,720
and decided the best way to solve these

81
00:03:17,680 --> 00:03:22,930
issues was to pretend to be someone else

82
00:03:19,720 --> 00:03:26,290
and email me and ask for help which

83
00:03:22,930 --> 00:03:28,060
didn't work out very well for him but

84
00:03:26,290 --> 00:03:30,100
anyway out of all of this chaos I've

85
00:03:28,060 --> 00:03:32,050
been able to bring you safe detection

86
00:03:30,100 --> 00:03:33,790
methods which with with which you can

87
00:03:32,050 --> 00:03:36,430
find this vulnerability with no chance

88
00:03:33,790 --> 00:03:38,560
of being called a blackhat all new

89
00:03:36,430 --> 00:03:41,230
methods to trigger D synchronisation and

90
00:03:38,560 --> 00:03:43,000
exploit the results and methodology and

91
00:03:41,230 --> 00:03:45,780
talling to bring clarity to a topic

92
00:03:43,000 --> 00:03:48,280
that's been overlooked for far too long

93
00:03:45,780 --> 00:03:50,709
so first I'm going to talk about what

94
00:03:48,280 --> 00:03:52,450
makes this attack possible how to assess

95
00:03:50,709 --> 00:03:54,760
if a target is vulnerable and what to do

96
00:03:52,450 --> 00:03:56,799
next after that we'll look at how to

97
00:03:54,760 --> 00:03:59,230
exploit it with a load of case studies

98
00:03:56,800 --> 00:04:00,580
or looking at real websites starting out

99
00:03:59,230 --> 00:04:02,920
with some really simple easy ones

100
00:04:00,580 --> 00:04:05,350
building in complexity and ending with a

101
00:04:02,920 --> 00:04:07,000
live demo in which I'll also show how to

102
00:04:05,350 --> 00:04:08,470
use the open source tool that I'm

103
00:04:07,000 --> 00:04:10,530
releasing to accompany this research

104
00:04:08,470 --> 00:04:13,270
after that I'm going to talk about

105
00:04:10,530 --> 00:04:14,800
defense and then I probably will have

106
00:04:13,270 --> 00:04:15,850
time to answer questions with everyone

107
00:04:14,800 --> 00:04:19,810
but if you come and speak to me at the

108
00:04:15,850 --> 00:04:22,350
back I'll answer them then so if you

109
00:04:19,810 --> 00:04:25,020
picture a website as an end user

110
00:04:22,350 --> 00:04:26,850
it probably looked something like this

111
00:04:25,020 --> 00:04:29,070
because as an end user that's all that

112
00:04:26,850 --> 00:04:30,930
we can directly see but behind the

113
00:04:29,070 --> 00:04:32,909
scenes most websites are routing

114
00:04:30,930 --> 00:04:35,550
requests through a chain of servers

115
00:04:32,910 --> 00:04:37,590
speaking to each other using HTTP which

116
00:04:35,550 --> 00:04:41,820
is sent over a stream based transport

117
00:04:37,590 --> 00:04:44,369
layer protocol like TCP or TLS and for

118
00:04:41,820 --> 00:04:45,510
the sake of performance these streams in

119
00:04:44,370 --> 00:04:48,390
between the front end and back end

120
00:04:45,510 --> 00:04:51,420
server are heavily reused following the

121
00:04:48,390 --> 00:04:53,849
HTTP 1.1 keep a lot of protocol and that

122
00:04:51,420 --> 00:04:56,130
means the HTTP requests are placed back

123
00:04:53,850 --> 00:04:58,470
to back on these streams with no DES

124
00:04:56,130 --> 00:05:00,540
limiters in between them and each server

125
00:04:58,470 --> 00:05:02,820
in the chain is expected to parse the

126
00:05:00,540 --> 00:05:04,410
HTTP headers to find out how long the

127
00:05:02,820 --> 00:05:06,360
messages which tells it where that

128
00:05:04,410 --> 00:05:10,020
message stops and where the next one

129
00:05:06,360 --> 00:05:12,300
starts so we've got requests from users

130
00:05:10,020 --> 00:05:15,270
from all over the world being funneled

131
00:05:12,300 --> 00:05:17,640
through these tiny pools of TCP and TLS

132
00:05:15,270 --> 00:05:19,979
streams and then servers have them to do

133
00:05:17,640 --> 00:05:22,950
parsing to work out where the individual

134
00:05:19,980 --> 00:05:24,590
requests are within these streams what

135
00:05:22,950 --> 00:05:28,110
could possibly go wrong

136
00:05:24,590 --> 00:05:30,119
well what happens if as an attacker we

137
00:05:28,110 --> 00:05:31,770
send an ambiguous message one that gets

138
00:05:30,120 --> 00:05:33,900
paused as being a different length by

139
00:05:31,770 --> 00:05:36,690
the front end and the back end server so

140
00:05:33,900 --> 00:05:39,120
here we've sent one request shown in

141
00:05:36,690 --> 00:05:42,060
blue and orange and the front end thinks

142
00:05:39,120 --> 00:05:44,520
this is one request so it sends the

143
00:05:42,060 --> 00:05:46,800
whole thing on to the back end and when

144
00:05:44,520 --> 00:05:48,630
the back end is reassembling it for some

145
00:05:46,800 --> 00:05:51,810
reason it thinks the second Blue Square

146
00:05:48,630 --> 00:05:54,450
is the end of that request so it thinks

147
00:05:51,810 --> 00:05:56,490
that orange Square is the start of the

148
00:05:54,450 --> 00:05:58,229
next request and then it will wait for

149
00:05:56,490 --> 00:06:00,360
this phantom second request to be

150
00:05:58,230 --> 00:06:02,580
completed until the next real request

151
00:06:00,360 --> 00:06:04,710
gets sent down that stream maybe by the

152
00:06:02,580 --> 00:06:07,020
attacker or maybe by someone else and

153
00:06:04,710 --> 00:06:09,359
then effectively that orange bit of data

154
00:06:07,020 --> 00:06:13,440
just gets stuck on the start of the next

155
00:06:09,360 --> 00:06:15,360
request to hit the back end so using the

156
00:06:13,440 --> 00:06:18,060
request smuggling we can apply an

157
00:06:15,360 --> 00:06:20,790
arbitrary prefix to the next request to

158
00:06:18,060 --> 00:06:23,520
hit the back end server that's that's

159
00:06:20,790 --> 00:06:25,800
the essence of request smuggling and

160
00:06:23,520 --> 00:06:27,330
because we can't directly see what's

161
00:06:25,800 --> 00:06:29,100
happening behind the front end server

162
00:06:27,330 --> 00:06:30,870
it's really easy to get confused and

163
00:06:29,100 --> 00:06:33,120
bogged down in technical details I

164
00:06:30,870 --> 00:06:35,210
certainly did myself for several months

165
00:06:33,120 --> 00:06:37,970
but ultimately it's really

166
00:06:35,210 --> 00:06:41,590
that simple now let's zoom in and see

167
00:06:37,970 --> 00:06:44,360
what the data looks like on the wire

168
00:06:41,590 --> 00:06:46,039
this request is ambiguous because we're

169
00:06:44,360 --> 00:06:48,319
using an absolutely classic D

170
00:06:46,039 --> 00:06:50,318
synchronization technique we've simply

171
00:06:48,319 --> 00:06:53,180
specified the content F edit twice and

172
00:06:50,319 --> 00:06:54,800
in this example the front end is looking

173
00:06:53,180 --> 00:06:56,419
at the first content length header so

174
00:06:54,800 --> 00:06:59,150
it's forwarding all the blue data and

175
00:06:56,419 --> 00:07:00,770
the orange G onto the back end the back

176
00:06:59,150 --> 00:07:02,539
end looks at the second content length

177
00:07:00,770 --> 00:07:04,669
header so it reads off all the blue data

178
00:07:02,539 --> 00:07:06,560
and it thinks the G is the start of the

179
00:07:04,669 --> 00:07:09,198
next request so when the next request

180
00:07:06,560 --> 00:07:11,930
arrives it just gets this G at the start

181
00:07:09,199 --> 00:07:13,330
and whoever that is is probably going to

182
00:07:11,930 --> 00:07:16,880
get a response saying something like

183
00:07:13,330 --> 00:07:19,099
unknown method G post and that's it

184
00:07:16,880 --> 00:07:22,190
we've successfully done a request

185
00:07:19,099 --> 00:07:24,560
smuggling attack the only catch is this

186
00:07:22,190 --> 00:07:26,000
technique is so classic that it doesn't

187
00:07:24,560 --> 00:07:31,520
really work on anything that's actually

188
00:07:26,000 --> 00:07:33,800
worth hacking these days what does work

189
00:07:31,520 --> 00:07:37,789
on plenty of interesting systems is

190
00:07:33,800 --> 00:07:39,500
using chunked encoding so chunked

191
00:07:37,789 --> 00:07:41,229
encoding is an alternative way of

192
00:07:39,500 --> 00:07:44,320
specifying the length of a message

193
00:07:41,229 --> 00:07:46,340
whereby instead of specifying it upfront

194
00:07:44,320 --> 00:07:47,780
you just send chance for encoding

195
00:07:46,340 --> 00:07:49,849
chunked and then the server will parse

196
00:07:47,780 --> 00:07:51,979
the body of the message more or less

197
00:07:49,849 --> 00:07:55,250
until it reaches a zero followed by an

198
00:07:51,979 --> 00:07:56,990
empty line so in this example attack

199
00:07:55,250 --> 00:07:58,669
here it's basically exactly the same as

200
00:07:56,990 --> 00:08:00,380
the previous example the front end is

201
00:07:58,669 --> 00:08:02,870
looked at the content length its forded

202
00:08:00,380 --> 00:08:04,280
the blue data and the orange G and the

203
00:08:02,870 --> 00:08:06,560
back end is treated this message is

204
00:08:04,280 --> 00:08:08,030
being chunked so they've stopped parsing

205
00:08:06,560 --> 00:08:10,729
that message after the zero and the

206
00:08:08,030 --> 00:08:12,679
empty line I once again we inflicted G

207
00:08:10,729 --> 00:08:14,330
post response on someone else who

208
00:08:12,680 --> 00:08:18,020
happens to be browsing the web site at

209
00:08:14,330 --> 00:08:20,570
the time now what if the D

210
00:08:18,020 --> 00:08:21,430
synchronization happens the other way

211
00:08:20,570 --> 00:08:24,229
around

212
00:08:21,430 --> 00:08:25,909
so in this example the front end is

213
00:08:24,229 --> 00:08:28,099
treating this messages being chunked and

214
00:08:25,909 --> 00:08:30,080
the back end is looking at the content

215
00:08:28,099 --> 00:08:32,390
length well as you can see we can still

216
00:08:30,080 --> 00:08:34,309
exploit this you just need to change

217
00:08:32,390 --> 00:08:36,049
what the payload looks like slightly and

218
00:08:34,309 --> 00:08:39,109
we've got this small limitation in the

219
00:08:36,049 --> 00:08:40,609
the malicious prefix shown in shown in

220
00:08:39,110 --> 00:08:42,589
orange on every slide throughout this

221
00:08:40,610 --> 00:08:45,199
presentation has to end in a zero

222
00:08:42,589 --> 00:08:46,699
followed by an empty line but in general

223
00:08:45,199 --> 00:08:47,770
that's not going to cause us any

224
00:08:46,699 --> 00:08:49,910
problems

225
00:08:47,770 --> 00:08:51,770
now if you're looking at the content

226
00:08:49,910 --> 00:08:53,750
length header you might be wondering why

227
00:08:51,770 --> 00:08:56,060
is 3 when there's only one visible date

228
00:08:53,750 --> 00:08:57,890
byte of data shown in blue that's

229
00:08:56,060 --> 00:09:00,979
because just bear in mind every line

230
00:08:57,890 --> 00:09:03,439
ends with / r / n but in general I

231
00:09:00,980 --> 00:09:05,450
recommend using using the colors rather

232
00:09:03,440 --> 00:09:06,800
than the numbers in the slides I

233
00:09:05,450 --> 00:09:08,080
probably got some of the numbers wrong

234
00:09:06,800 --> 00:09:11,000
anyway

235
00:09:08,080 --> 00:09:14,060
so why does that chunk technique work on

236
00:09:11,000 --> 00:09:16,010
so many systems well I think we've got

237
00:09:14,060 --> 00:09:19,790
to give some credit to the specification

238
00:09:16,010 --> 00:09:21,290
the original spec RFC 261 6 says if

239
00:09:19,790 --> 00:09:23,089
you're a server and you receive a

240
00:09:21,290 --> 00:09:25,370
message that uses a content length and

241
00:09:23,090 --> 00:09:27,980
chunked encoding you should prioritize

242
00:09:25,370 --> 00:09:29,810
chunked encoding it doesn't say you

243
00:09:27,980 --> 00:09:31,580
shouldn't normalize this message or you

244
00:09:29,810 --> 00:09:33,560
could all or that you should reject this

245
00:09:31,580 --> 00:09:35,360
message so it's implicitly taken as

246
00:09:33,560 --> 00:09:38,420
saying these requests are acceptable and

247
00:09:35,360 --> 00:09:40,580
should be processed and chunked encoding

248
00:09:38,420 --> 00:09:44,150
is kind of complex so some servers

249
00:09:40,580 --> 00:09:46,370
simply don't support it so all you need

250
00:09:44,150 --> 00:09:48,800
to be able to exploit a given target is

251
00:09:46,370 --> 00:09:50,570
one Syst one server in the chain that

252
00:09:48,800 --> 00:09:53,150
doesn't support chocolate encoding and

253
00:09:50,570 --> 00:09:55,790
you can D synchronize it and hack it and

254
00:09:53,150 --> 00:09:57,500
this technique by itself worked on

255
00:09:55,790 --> 00:10:00,500
pretty much every single server using

256
00:09:57,500 --> 00:10:03,110
the content delivery network Akamai

257
00:10:00,500 --> 00:10:06,050
which was a lot of service they patch

258
00:10:03,110 --> 00:10:11,450
that roughly 48 hours after I first gave

259
00:10:06,050 --> 00:10:13,010
this presentation so yet that technique

260
00:10:11,450 --> 00:10:15,020
works on loads of stuff by itself but

261
00:10:13,010 --> 00:10:17,240
obviously we don't want to be limited to

262
00:10:15,020 --> 00:10:19,010
just using that we want to hack some

263
00:10:17,240 --> 00:10:20,540
some systems where all the servers in

264
00:10:19,010 --> 00:10:24,140
the chain do support transfer encoding

265
00:10:20,540 --> 00:10:26,719
and the good news is you often can all

266
00:10:24,140 --> 00:10:28,880
you have to do is find a way to hide the

267
00:10:26,720 --> 00:10:31,790
transfer encoding header from one server

268
00:10:28,880 --> 00:10:34,310
in the in the chain and thereby trick it

269
00:10:31,790 --> 00:10:36,920
into falling back to using the content

270
00:10:34,310 --> 00:10:38,959
nets one way of doing this is by

271
00:10:36,920 --> 00:10:42,229
sticking some white space before the

272
00:10:38,960 --> 00:10:44,390
colon in in the header name if you're

273
00:10:42,230 --> 00:10:45,980
using goal angle for your server and you

274
00:10:44,390 --> 00:10:49,310
didn't release the patch that came out

275
00:10:45,980 --> 00:10:53,630
yesterday then that's only it will work

276
00:10:49,310 --> 00:10:55,579
on your server and other servers grep

277
00:10:53,630 --> 00:10:57,320
the transfer encoding header for the

278
00:10:55,580 --> 00:10:58,760
word chunked instead of tokenizing it so

279
00:10:57,320 --> 00:11:00,140
they will think that message is chunked

280
00:10:58,760 --> 00:11:01,689
and you can D synchronize them and

281
00:11:00,140 --> 00:11:04,210
there's loads of tech

282
00:11:01,690 --> 00:11:06,250
that you can use to decent canal systems

283
00:11:04,210 --> 00:11:08,140
this is just a sampling of them but

284
00:11:06,250 --> 00:11:10,180
every tick every technique shown on this

285
00:11:08,140 --> 00:11:12,069
slide is one I've successfully used to

286
00:11:10,180 --> 00:11:15,459
exploit a real system that had a bug

287
00:11:12,070 --> 00:11:17,940
bounty program and the ones highlighted

288
00:11:15,460 --> 00:11:20,530
in orange are those that I came up with

289
00:11:17,940 --> 00:11:21,760
shown this research myself so I don't

290
00:11:20,530 --> 00:11:24,870
think they've ever been documented

291
00:11:21,760 --> 00:11:27,189
elsewhere and used for request smuggling

292
00:11:24,870 --> 00:11:28,780
now these are the techniques that I

293
00:11:27,190 --> 00:11:30,580
thought I presented when I first gave

294
00:11:28,780 --> 00:11:33,760
this technique gave this presentation at

295
00:11:30,580 --> 00:11:35,200
blackhat one month ago so some of the

296
00:11:33,760 --> 00:11:38,260
systems you could hack with these have

297
00:11:35,200 --> 00:11:40,000
been found and patched and I want to

298
00:11:38,260 --> 00:11:41,050
keep things interesting for you guys so

299
00:11:40,000 --> 00:11:44,080
I've spent the last couple of weeks

300
00:11:41,050 --> 00:11:45,969
exploring some new techniques and I'm

301
00:11:44,080 --> 00:11:49,720
gonna which have never been publicly

302
00:11:45,970 --> 00:11:52,720
released so here they are now

303
00:11:49,720 --> 00:11:55,090
over the years quite a few people have

304
00:11:52,720 --> 00:11:57,310
put quite a lot of effort into bypassing

305
00:11:55,090 --> 00:11:59,710
web application firewalls using

306
00:11:57,310 --> 00:12:01,719
malformed headers and it turns out and

307
00:11:59,710 --> 00:12:04,570
what you're doing there is basically the

308
00:12:01,720 --> 00:12:06,490
is using a decent command ization attack

309
00:12:04,570 --> 00:12:09,460
it's just that you're using it to merely

310
00:12:06,490 --> 00:12:11,200
bypass a graph rather than cause

311
00:12:09,460 --> 00:12:11,560
absolute chaos that we'll be seeing

312
00:12:11,200 --> 00:12:14,290
later

313
00:12:11,560 --> 00:12:17,290
so I've taken these techniques and ivory

314
00:12:14,290 --> 00:12:18,579
applied some of them and tested them out

315
00:12:17,290 --> 00:12:20,140
and here we're going to get three

316
00:12:18,580 --> 00:12:23,700
techniques that I've successfully used

317
00:12:20,140 --> 00:12:27,460
in the last week to exploit real systems

318
00:12:23,700 --> 00:12:28,930
this one's crazy some systems are really

319
00:12:27,460 --> 00:12:32,880
lazy they don't look for the word

320
00:12:28,930 --> 00:12:32,880
chunked they just look for siate you

321
00:12:33,010 --> 00:12:36,939
so using that they will they will treat

322
00:12:35,170 --> 00:12:39,910
their message as chunked other servers

323
00:12:36,940 --> 00:12:40,780
won't and you can be synchronize them as

324
00:12:39,910 --> 00:12:42,640
ever

325
00:12:40,780 --> 00:12:44,890
no bytes coming useful when you're

326
00:12:42,640 --> 00:12:46,960
trying to hack stuff some some servers

327
00:12:44,890 --> 00:12:49,840
will treat that message as being chunked

328
00:12:46,960 --> 00:12:52,300
and a decent amount won't and my

329
00:12:49,840 --> 00:12:54,220
favorite technique is a little bit more

330
00:12:52,300 --> 00:12:57,579
subtle way if you if you remember in

331
00:12:54,220 --> 00:13:01,810
HTTP line ending headers are supposed to

332
00:12:57,580 --> 00:13:03,820
end with slash are slash n but generally

333
00:13:01,810 --> 00:13:05,709
most of the time you can end them just

334
00:13:03,820 --> 00:13:09,310
using slash n so there's this kind of

335
00:13:05,710 --> 00:13:11,260
vagueness and ambiguity there and what I

336
00:13:09,310 --> 00:13:13,510
found is some servers let you end

337
00:13:11,260 --> 00:13:15,670
headers with slash are slash n slash R

338
00:13:13,510 --> 00:13:17,950
and that extra slash R

339
00:13:15,670 --> 00:13:19,930
means that other servers don't notice

340
00:13:17,950 --> 00:13:21,160
that header and think it's part of the

341
00:13:19,930 --> 00:13:23,069
previous header or something or just

342
00:13:21,160 --> 00:13:25,620
treat the whole value as being in

343
00:13:23,070 --> 00:13:27,760
invalid and you can D synchronize it and

344
00:13:25,620 --> 00:13:29,440
using that technique I was able to

345
00:13:27,760 --> 00:13:31,420
exploit some extremely well-known

346
00:13:29,440 --> 00:13:33,250
systems that haven't patched yet so I

347
00:13:31,420 --> 00:13:36,339
can't name them but you would definitely

348
00:13:33,250 --> 00:13:38,890
know if I didn't in them also a word of

349
00:13:36,340 --> 00:13:40,600
warning this technique if you scan also

350
00:13:38,890 --> 00:13:43,780
flags on the whole of Google's

351
00:13:40,600 --> 00:13:46,540
infrastructure as far as I can tell

352
00:13:43,780 --> 00:13:50,530
that's not exploitable but feel free to

353
00:13:46,540 --> 00:13:52,870
have a look and prove me well okay so

354
00:13:50,530 --> 00:13:54,880
now we understand the fundamentals of

355
00:13:52,870 --> 00:13:57,670
how to decent Kani service so we've got

356
00:13:54,880 --> 00:13:59,770
this really powerful building block but

357
00:13:57,670 --> 00:14:01,240
if we just try and whack a server with

358
00:13:59,770 --> 00:14:02,860
this building block I can tell you with

359
00:14:01,240 --> 00:14:05,260
confidence you'll run into hazards and

360
00:14:02,860 --> 00:14:07,630
complications and waste a lot of time so

361
00:14:05,260 --> 00:14:09,910
to avoid that I've developed this

362
00:14:07,630 --> 00:14:12,220
methodology to guide us in a controlled

363
00:14:09,910 --> 00:14:16,810
manner step by step towards a successful

364
00:14:12,220 --> 00:14:19,990
expert first off we need to detect

365
00:14:16,810 --> 00:14:21,910
Wendie synchronization is possible now

366
00:14:19,990 --> 00:14:24,550
there's a really obvious way of doing

367
00:14:21,910 --> 00:14:25,930
this which is to send two requests to

368
00:14:24,550 --> 00:14:28,030
the server where the first one is

369
00:14:25,930 --> 00:14:29,829
designed to D synchronize it and poison

370
00:14:28,030 --> 00:14:31,689
the backend socket and the second

371
00:14:29,830 --> 00:14:33,910
request is just a normal one that's

372
00:14:31,690 --> 00:14:37,180
designed to get poisoned by the first

373
00:14:33,910 --> 00:14:38,890
one but this approach comes with a

374
00:14:37,180 --> 00:14:41,199
massive catch which is that if anyone

375
00:14:38,890 --> 00:14:43,210
else's request hits that back-end in

376
00:14:41,200 --> 00:14:45,910
between our first and second requests

377
00:14:43,210 --> 00:14:47,920
they'll get the poisoned response though

378
00:14:45,910 --> 00:14:49,449
potentially have a better date and we

379
00:14:47,920 --> 00:14:52,120
won't find the vulnerability we'll get a

380
00:14:49,450 --> 00:14:55,660
false negative so we need a better way

381
00:14:52,120 --> 00:14:58,330
of finding this vulnerability and I

382
00:14:55,660 --> 00:15:00,040
think I've got one here so how this

383
00:14:58,330 --> 00:15:01,570
serve how this request gets processed

384
00:15:00,040 --> 00:15:02,050
depends on whether the front-end in the

385
00:15:01,570 --> 00:15:04,390
backend

386
00:15:02,050 --> 00:15:07,540
use the treated as being chunked or use

387
00:15:04,390 --> 00:15:09,610
the content let if both the front-end in

388
00:15:07,540 --> 00:15:11,589
the backend look at the continent header

389
00:15:09,610 --> 00:15:13,330
that's fine that the blue today the blue

390
00:15:11,590 --> 00:15:15,160
data will get forwarded and responded to

391
00:15:13,330 --> 00:15:18,060
and we'll get a fairly normal response

392
00:15:15,160 --> 00:15:20,319
immediately if the front-end system

393
00:15:18,060 --> 00:15:22,479
looks at the transfer encoding chunks

394
00:15:20,320 --> 00:15:24,340
header by then it will try and pass this

395
00:15:22,480 --> 00:15:26,710
message messages being chunked it will

396
00:15:24,340 --> 00:15:28,390
read into three it will read in that ABC

397
00:15:26,710 --> 00:15:29,410
and then all we did in the next chunk

398
00:15:28,390 --> 00:15:31,689
size which is

399
00:15:29,410 --> 00:15:33,459
Q's not of Valor chunk size so it will

400
00:15:31,690 --> 00:15:35,649
just reject this message outright and it

401
00:15:33,459 --> 00:15:39,160
generally won't get forwarded on to the

402
00:15:35,649 --> 00:15:41,199
back-end server but if the front-end

403
00:15:39,160 --> 00:15:42,939
looks at the content length header and

404
00:15:41,199 --> 00:15:45,399
thereby forwards the blow data but not

405
00:15:42,940 --> 00:15:46,899
the Q then and the backend treats the

406
00:15:45,399 --> 00:15:48,910
messages being chunked then it will

407
00:15:46,899 --> 00:15:51,699
timeout while waiting for the next chunk

408
00:15:48,910 --> 00:15:54,550
size to her wife so if you send that

409
00:15:51,699 --> 00:15:56,170
request and you get a timeout that's a

410
00:15:54,550 --> 00:15:58,959
decent indication that that server is

411
00:15:56,170 --> 00:16:01,029
vulnerable to requests smuggling and we

412
00:15:58,959 --> 00:16:03,790
can use a very similar technique to

413
00:16:01,029 --> 00:16:06,759
identify when servers are vulnerable the

414
00:16:03,790 --> 00:16:09,730
other way around this technique should

415
00:16:06,759 --> 00:16:12,430
be tried on every endpoint on a target

416
00:16:09,730 --> 00:16:14,050
website because websites may be routing

417
00:16:12,430 --> 00:16:16,479
different URLs to different back-end

418
00:16:14,050 --> 00:16:20,109
systems so you may find only some of

419
00:16:16,480 --> 00:16:22,240
those endpoints are vulnerable I've the

420
00:16:20,110 --> 00:16:24,279
open source tool that I'm releasing and

421
00:16:22,240 --> 00:16:26,829
core burp suite scanner both used this

422
00:16:24,279 --> 00:16:28,329
technique to find this vulnerability for

423
00:16:26,829 --> 00:16:31,449
you so you should never be needing to

424
00:16:28,329 --> 00:16:34,329
actually try that manually the real

425
00:16:31,449 --> 00:16:36,250
strength of this technique is that

426
00:16:34,329 --> 00:16:38,258
although because it's inference based it

427
00:16:36,250 --> 00:16:40,029
will get some false positives it doesn't

428
00:16:38,259 --> 00:16:42,870
get many and it gets vastly less false

429
00:16:40,029 --> 00:16:45,730
negatives for example on one real target

430
00:16:42,870 --> 00:16:46,209
this this approach said it was

431
00:16:45,730 --> 00:16:48,189
vulnerable

432
00:16:46,209 --> 00:16:50,949
every time I scanned it whereas trying

433
00:16:48,189 --> 00:16:53,980
the request pair technique took me 800

434
00:16:50,949 --> 00:16:58,680
failed attempts before I demonstrated

435
00:16:53,980 --> 00:17:00,730
that it was in fact exploitable now

436
00:16:58,680 --> 00:17:02,949
sometimes you can just stop there and

437
00:17:00,730 --> 00:17:04,480
report that but most of the time clients

438
00:17:02,949 --> 00:17:05,980
are not going to take a report seriously

439
00:17:04,480 --> 00:17:07,150
without a bit more evidence so that's

440
00:17:05,980 --> 00:17:10,000
when we're going to start using this

441
00:17:07,150 --> 00:17:11,319
this request pair technique that's kind

442
00:17:10,000 --> 00:17:14,349
of hazardous and is why you might

443
00:17:11,319 --> 00:17:17,438
theoretically get called a blackout so

444
00:17:14,349 --> 00:17:20,168
here the first request shown in orange

445
00:17:17,439 --> 00:17:21,610
and blue is designed to poison the back

446
00:17:20,169 --> 00:17:22,839
end server with the date in orange and

447
00:17:21,609 --> 00:17:25,958
then we're going to send a second one

448
00:17:22,839 --> 00:17:27,579
and the idea is the second request shown

449
00:17:25,959 --> 00:17:30,460
in green is one that would not not

450
00:17:27,579 --> 00:17:32,590
normally get a 404 back so if we send

451
00:17:30,460 --> 00:17:36,110
that and we do get a 44 it shows that

452
00:17:32,590 --> 00:17:38,330
the poison actually worked

453
00:17:36,110 --> 00:17:40,280
now there's a few things we need to bear

454
00:17:38,330 --> 00:17:42,320
in mind when trying this technique one

455
00:17:40,280 --> 00:17:45,110
is that it's really important that you

456
00:17:42,320 --> 00:17:47,240
don't send those two requests I've the

457
00:17:45,110 --> 00:17:49,790
attack and the victim request over the

458
00:17:47,240 --> 00:17:51,860
same connection yourself I don't use

459
00:17:49,790 --> 00:17:55,159
keepalive because if you do that you'll

460
00:17:51,860 --> 00:17:56,979
just get false positives also the end

461
00:17:55,160 --> 00:18:00,440
point that you send the blue-and-orange

462
00:17:56,980 --> 00:18:03,020
request to is really really important

463
00:18:00,440 --> 00:18:06,350
if the server isn't expecting to receive

464
00:18:03,020 --> 00:18:09,860
a post request to that end point in my

465
00:18:06,350 --> 00:18:11,899
it might respond with a 400 or 500 code

466
00:18:09,860 --> 00:18:13,610
and when servers do that they often

467
00:18:11,900 --> 00:18:15,470
close the connection to the front end

468
00:18:13,610 --> 00:18:17,809
and that will mean that the orange data

469
00:18:15,470 --> 00:18:21,020
is effectively thrown out and the attack

470
00:18:17,809 --> 00:18:22,730
will fail also even if you go to all of

471
00:18:21,020 --> 00:18:25,549
those lengths this technique is going to

472
00:18:22,730 --> 00:18:29,960
be non-deterministic even on websites

473
00:18:25,549 --> 00:18:32,110
that have no other users so at this

474
00:18:29,960 --> 00:18:34,790
point we've covered the theory of

475
00:18:32,110 --> 00:18:37,219
detecting this vulnerability how it

476
00:18:34,790 --> 00:18:38,899
works and how to confirm if a server is

477
00:18:37,220 --> 00:18:40,790
really vulnerable now we're finally

478
00:18:38,900 --> 00:18:42,940
going to take a look our damage we can

479
00:18:40,790 --> 00:18:42,940
do

480
00:18:43,039 --> 00:18:47,700
so as I mentioned these are all real

481
00:18:45,869 --> 00:18:50,639
systems although I've had I've have to

482
00:18:47,700 --> 00:18:51,960
adapt quite a few I'd like to give a

483
00:18:50,639 --> 00:18:53,668
shout out to the companies that actually

484
00:18:51,960 --> 00:18:55,740
let me name them please remember these

485
00:18:53,669 --> 00:18:58,740
are the guys that are now secure against

486
00:18:55,740 --> 00:18:59,970
these techniques also as usual during

487
00:18:58,740 --> 00:19:02,549
the section I'm going to keep a running

488
00:18:59,970 --> 00:19:06,690
total of the bounties earned during this

489
00:19:02,549 --> 00:19:09,720
research of those I get 0% 50% gets

490
00:19:06,690 --> 00:19:13,499
spent on beer by a by my company and the

491
00:19:09,720 --> 00:19:15,840
other 50% goes to local charities now

492
00:19:13,499 --> 00:19:17,580
probably the easiest attack that you can

493
00:19:15,840 --> 00:19:19,230
do with requests smuggling is simply

494
00:19:17,580 --> 00:19:21,449
bypassing security rules that have been

495
00:19:19,230 --> 00:19:23,820
implemented on the front end system for

496
00:19:21,450 --> 00:19:25,499
example a well-known software vendor has

497
00:19:23,820 --> 00:19:27,779
their front end set up to block access

498
00:19:25,499 --> 00:19:30,029
to slash admin but using request

499
00:19:27,779 --> 00:19:31,980
smuggling we can really easily bypass

500
00:19:30,029 --> 00:19:34,590
that because the front end thinks that

501
00:19:31,980 --> 00:19:37,139
orange bit of data is just the body of

502
00:19:34,590 --> 00:19:39,840
the first request so if we send a

503
00:19:37,139 --> 00:19:41,158
follow-up ourselves that's that

504
00:19:39,840 --> 00:19:43,080
follow-up from the front end point of

505
00:19:41,159 --> 00:19:46,080
view is trying to access slash but we

506
00:19:43,080 --> 00:19:49,860
actually get access to the admin page so

507
00:19:46,080 --> 00:19:52,289
far so simple now lots of front ends

508
00:19:49,860 --> 00:19:53,580
like to rewrite requests by adding

509
00:19:52,289 --> 00:19:55,529
headers to them and one header that

510
00:19:53,580 --> 00:19:57,539
practically every system uses some

511
00:19:55,529 --> 00:19:59,840
variation of is exported for which

512
00:19:57,539 --> 00:20:02,940
simply specifies the remote users IP and

513
00:19:59,840 --> 00:20:05,939
on well configured systems we can't

514
00:20:02,940 --> 00:20:08,159
spoof our our IP with this header is if

515
00:20:05,940 --> 00:20:11,429
we specify it the front end will just

516
00:20:08,159 --> 00:20:14,759
rewrite or remove it but by putting that

517
00:20:11,429 --> 00:20:16,559
header in the smuggled body we can hide

518
00:20:14,759 --> 00:20:18,690
that header from the front end and

519
00:20:16,559 --> 00:20:21,330
bypass this rewrite and therefore make

520
00:20:18,690 --> 00:20:24,330
it look like we're coming from any from

521
00:20:21,330 --> 00:20:26,789
any IP address out there and using that

522
00:20:24,330 --> 00:20:30,480
technique on a security vendor on their

523
00:20:26,789 --> 00:20:31,619
store I got an incredible $300 bounty so

524
00:20:30,480 --> 00:20:33,539
I'm not saying you can even get rich

525
00:20:31,619 --> 00:20:34,949
quick using that technique but it is

526
00:20:33,539 --> 00:20:37,440
worth knowing it may come and useful

527
00:20:34,950 --> 00:20:40,590
sometimes and also there's a slightly

528
00:20:37,440 --> 00:20:42,419
less obvious use for it which is imagine

529
00:20:40,590 --> 00:20:45,539
you have a target where the time out

530
00:20:42,419 --> 00:20:47,779
technique suggests it's vulnerable but

531
00:20:45,539 --> 00:20:50,340
the target gets a really high traffic

532
00:20:47,779 --> 00:20:51,929
traffic volume right so the request pair

533
00:20:50,340 --> 00:20:54,850
technique never works because you keep

534
00:20:51,929 --> 00:20:57,130
on just poisoning someone else's request

535
00:20:54,850 --> 00:20:59,469
what you've got there is effectively a

536
00:20:57,130 --> 00:21:01,480
blind request smuggling vulnerability

537
00:20:59,470 --> 00:21:03,789
how can you prove that that's really

538
00:21:01,480 --> 00:21:06,220
vulnerable well one way is to take a

539
00:21:03,789 --> 00:21:08,740
header like this and put a unique

540
00:21:06,220 --> 00:21:11,169
hostname in there if you send that and

541
00:21:08,740 --> 00:21:13,330
you get a DNS lookup for that hostname

542
00:21:11,169 --> 00:21:15,039
that proves that that data which is in

543
00:21:13,330 --> 00:21:17,740
the body of the request has been

544
00:21:15,039 --> 00:21:20,169
interpreted as a separate request by the

545
00:21:17,740 --> 00:21:23,200
backend system and thereby proves that

546
00:21:20,169 --> 00:21:25,690
it's vulnerable now

547
00:21:23,200 --> 00:21:27,340
yeah IP spoofing is okay but the really

548
00:21:25,690 --> 00:21:29,200
interesting behavior is going to tend to

549
00:21:27,340 --> 00:21:32,230
come from custom application specific

550
00:21:29,200 --> 00:21:33,480
headers and to make use of those we need

551
00:21:32,230 --> 00:21:35,440
to know what they are

552
00:21:33,480 --> 00:21:36,970
unfortunately it's generally pretty easy

553
00:21:35,440 --> 00:21:39,429
to find out as long as the application

554
00:21:36,970 --> 00:21:42,639
has one endpoint which expects to

555
00:21:39,429 --> 00:21:46,149
receive a post request and reflects one

556
00:21:42,639 --> 00:21:48,969
parameter so here I'm targeting New

557
00:21:46,149 --> 00:21:51,459
Relic and I've smuggled a request that's

558
00:21:48,970 --> 00:21:54,129
trying to sign in and I've made it so my

559
00:21:51,460 --> 00:21:55,629
email address is the last parameter and

560
00:21:54,129 --> 00:21:58,899
that means when I send the follow-up

561
00:21:55,629 --> 00:22:00,309
that request gets concatenated onto the

562
00:21:58,899 --> 00:22:02,799
email address that I'm trying to log in

563
00:22:00,309 --> 00:22:06,428
with and the response to that second

564
00:22:02,799 --> 00:22:08,350
message comes comes back and it pre

565
00:22:06,429 --> 00:22:11,169
fills my email address which contains

566
00:22:08,350 --> 00:22:13,149
the whole of the second request after

567
00:22:11,169 --> 00:22:15,759
it's been rewritten by the front end

568
00:22:13,149 --> 00:22:21,699
server thereby disclosing our headers

569
00:22:15,759 --> 00:22:23,279
with the front end server users so we're

570
00:22:21,700 --> 00:22:26,049
going to use some of those shortly now

571
00:22:23,279 --> 00:22:28,240
on you elect their back-end wasn't inter

572
00:22:26,049 --> 00:22:30,908
was a reverse proxy itself like they had

573
00:22:28,240 --> 00:22:32,620
a chain of quite a few servers so by

574
00:22:30,909 --> 00:22:34,720
changing the host header that I smuggled

575
00:22:32,620 --> 00:22:36,549
I could get access to different internal

576
00:22:34,720 --> 00:22:38,740
only systems but they all just came back

577
00:22:36,549 --> 00:22:39,970
with this redirect to HTTPS because they

578
00:22:38,740 --> 00:22:42,129
thought my message because my message

579
00:22:39,970 --> 00:22:44,679
was being downgraded to http by the

580
00:22:42,129 --> 00:22:46,000
front end but by looking at the head as

581
00:22:44,679 --> 00:22:48,399
they were using I saw they were using

582
00:22:46,000 --> 00:22:49,929
exported proto HTTP so I just talked

583
00:22:48,399 --> 00:22:53,918
about on there I'll actually got access

584
00:22:49,929 --> 00:22:56,230
to these internal systems and I went

585
00:22:53,919 --> 00:22:59,320
hunting for interesting information and

586
00:22:56,230 --> 00:23:02,169
I found this endpoint that gave a really

587
00:22:59,320 --> 00:23:04,149
teasing error message it said not

588
00:23:02,169 --> 00:23:05,889
authorized with header and then there

589
00:23:04,149 --> 00:23:07,449
was a colon and then I was it that was

590
00:23:05,889 --> 00:23:08,260
the whole response and it did not tell

591
00:23:07,450 --> 00:23:12,850
me what header

592
00:23:08,260 --> 00:23:14,140
I needed to authorize myself so I I look

593
00:23:12,850 --> 00:23:16,120
back at what had as the front end was

594
00:23:14,140 --> 00:23:17,890
using on that login page and saw this

595
00:23:16,120 --> 00:23:19,239
excel and our external service header

596
00:23:17,890 --> 00:23:22,240
and try that and it didn't work at all

597
00:23:19,240 --> 00:23:24,790
it actually made the problem worse so at

598
00:23:22,240 --> 00:23:26,350
this point where I could have done the

599
00:23:24,790 --> 00:23:29,168
proper way of doing this would have been

600
00:23:26,350 --> 00:23:31,540
to reuse that request reflection

601
00:23:29,169 --> 00:23:33,520
technique on load loads of different in

602
00:23:31,540 --> 00:23:36,639
New Relic endpoints until I found the

603
00:23:33,520 --> 00:23:38,889
name of this header but I was feeling

604
00:23:36,640 --> 00:23:40,600
kind of lazy so instead I cheated and I

605
00:23:38,890 --> 00:23:45,340
consulted my notes from last time I

606
00:23:40,600 --> 00:23:47,439
compromised New Relic and that included

607
00:23:45,340 --> 00:23:49,449
the service gateway account ID and

608
00:23:47,440 --> 00:23:52,480
service gateway is New Relic admin

609
00:23:49,450 --> 00:23:56,260
headers so by specifying those on a

610
00:23:52,480 --> 00:23:58,900
smuggled the request I could gain access

611
00:23:56,260 --> 00:24:01,000
to their core internal API as an

612
00:23:58,900 --> 00:24:03,030
arbitrary account as an admin in hand

613
00:24:01,000 --> 00:24:05,470
basically full control over everything

614
00:24:03,030 --> 00:24:10,059
and I got a decent few thousand dollar

615
00:24:05,470 --> 00:24:12,960
bounty for that so oh yeah and also they

616
00:24:10,059 --> 00:24:17,350
trace the root cause of this to their f5

617
00:24:12,960 --> 00:24:19,090
big IP front-end big IP responded a few

618
00:24:17,350 --> 00:24:22,600
weeks later by publishing and advisory

619
00:24:19,090 --> 00:24:24,639
please note this is just an advisory

620
00:24:22,600 --> 00:24:27,010
it's not a patch so you really need to

621
00:24:24,640 --> 00:24:30,640
read it and apply the fixes that they

622
00:24:27,010 --> 00:24:32,919
say you could do inside it so what we've

623
00:24:30,640 --> 00:24:34,330
seen here is sometimes with requests

624
00:24:32,919 --> 00:24:36,100
modeling if you're willing to put some

625
00:24:34,330 --> 00:24:38,830
time in you can brake directly into

626
00:24:36,100 --> 00:24:41,260
internal systems and have a great time

627
00:24:38,830 --> 00:24:44,490
but there's also much easier techniques

628
00:24:41,260 --> 00:24:47,200
focused on exploiting other users in

629
00:24:44,490 --> 00:24:50,320
particular if the application has any

630
00:24:47,200 --> 00:24:56,440
way of stalling text data persistently

631
00:24:50,320 --> 00:24:58,540
then exploitation is really easy so here

632
00:24:56,440 --> 00:25:01,270
I'm on Trello which is a well-known

633
00:24:58,540 --> 00:25:03,070
notetaking application and I'm just and

634
00:25:01,270 --> 00:25:05,379
I'm smuggling a request that says I'd

635
00:25:03,070 --> 00:25:08,409
like to update my public profile page

636
00:25:05,380 --> 00:25:11,049
and I've made it so the profile data

637
00:25:08,410 --> 00:25:12,910
which is just a text field is the last

638
00:25:11,049 --> 00:25:15,490
parameter so I'm going to send that and

639
00:25:12,910 --> 00:25:18,370
I didn't send any follow-up myself so

640
00:25:15,490 --> 00:25:21,400
someone else's requests got cancan got

641
00:25:18,370 --> 00:25:22,119
concatenated onto my profile and then I

642
00:25:21,400 --> 00:25:23,679
could just brow

643
00:25:22,119 --> 00:25:26,168
to my own profile and see the whole of

644
00:25:23,679 --> 00:25:28,269
their requests including all their

645
00:25:26,169 --> 00:25:30,249
session cookies and session headers and

646
00:25:28,269 --> 00:25:32,559
so on regardless of whether they're HTTP

647
00:25:30,249 --> 00:25:35,219
only or secure or whatever and just

648
00:25:32,559 --> 00:25:37,658
hijack their account real easily and

649
00:25:35,219 --> 00:25:39,609
every time I send out I just got access

650
00:25:37,659 --> 00:25:43,689
to a random different person's session

651
00:25:39,609 --> 00:25:46,089
with no use of interaction there's one

652
00:25:43,689 --> 00:25:47,679
small catch with this thing with this

653
00:25:46,089 --> 00:25:49,928
technique so that as soon as I saw this

654
00:25:47,679 --> 00:25:51,879
I was like great I can use this and hide

655
00:25:49,929 --> 00:25:53,379
your login requests and get passwords

656
00:25:51,879 --> 00:25:55,539
that'd be amazing

657
00:25:53,379 --> 00:25:57,488
unfortunately this technique will only

658
00:25:55,539 --> 00:26:00,519
let you steal data up to the first

659
00:25:57,489 --> 00:26:03,669
ampersand in the victims request so you

660
00:26:00,519 --> 00:26:08,429
typically can't steal post messages or

661
00:26:03,669 --> 00:26:10,899
you can steal the data in post messages

662
00:26:08,429 --> 00:26:13,719
but there is an exception if the login

663
00:26:10,899 --> 00:26:15,728
system uses JSON then you can as long as

664
00:26:13,719 --> 00:26:20,739
the victims password doesn't contain an

665
00:26:15,729 --> 00:26:22,869
ampersand and yeah I also exploited a

666
00:26:20,739 --> 00:26:24,699
different site using that where the text

667
00:26:22,869 --> 00:26:26,228
story there was no obvious way of

668
00:26:24,699 --> 00:26:28,809
storing text data and getting the

669
00:26:26,229 --> 00:26:31,599
response but I was able to concatenate

670
00:26:28,809 --> 00:26:33,519
the victims request onto a support

671
00:26:31,599 --> 00:26:36,369
ticket and eventually I would then get

672
00:26:33,519 --> 00:26:38,939
an email containing the victims request

673
00:26:36,369 --> 00:26:41,918
and session cookies and so on

674
00:26:38,939 --> 00:26:43,629
now what if you can't store data well

675
00:26:41,919 --> 00:26:46,119
it's a whole nother branch of attack

676
00:26:43,629 --> 00:26:49,629
that we can do based on serving up

677
00:26:46,119 --> 00:26:52,809
harmful responses to other people on the

678
00:26:49,629 --> 00:26:55,208
site now this example I kind of sucks

679
00:26:52,809 --> 00:26:58,109
but it's great for sharing the concept

680
00:26:55,209 --> 00:27:00,459
so on this site a well-known SAS vendor

681
00:26:58,109 --> 00:27:02,228
they had a reflected cross-site

682
00:27:00,459 --> 00:27:04,269
scripting vulnerability in by itself you

683
00:27:02,229 --> 00:27:05,979
know that's okay but it's not that great

684
00:27:04,269 --> 00:27:07,629
because it requires some kind of user

685
00:27:05,979 --> 00:27:09,129
interaction to exploit it they've got a

686
00:27:07,629 --> 00:27:11,769
clicker link I send them or something

687
00:27:09,129 --> 00:27:15,099
like that so it's not suitable for mass

688
00:27:11,769 --> 00:27:17,199
exploitation but by smuggling the

689
00:27:15,099 --> 00:27:19,418
request that triggered that payload and

690
00:27:17,199 --> 00:27:21,009
then not sending a follow-up then

691
00:27:19,419 --> 00:27:22,989
regardless of what of the quests someone

692
00:27:21,009 --> 00:27:25,809
else was sending they would get the

693
00:27:22,989 --> 00:27:29,459
response containing my payload I get

694
00:27:25,809 --> 00:27:34,428
exploited and that would once again

695
00:27:29,459 --> 00:27:36,809
expose HTTP only cookies and alike

696
00:27:34,429 --> 00:27:38,910
but the key thing is here this is just

697
00:27:36,809 --> 00:27:41,100
exploiting a random person fouling the

698
00:27:38,910 --> 00:27:42,390
website with no user interaction so I

699
00:27:41,100 --> 00:27:46,350
can send that over and over and just

700
00:27:42,390 --> 00:27:47,730
hijack everyone's accounts the other

701
00:27:46,350 --> 00:27:49,530
thing worth mentioning here is that this

702
00:27:47,730 --> 00:27:52,620
technique can be used with traditionally

703
00:27:49,530 --> 00:27:55,350
unexploited for XSS like XSS in the U in

704
00:27:52,620 --> 00:27:57,719
the user agent header and XSS in post

705
00:27:55,350 --> 00:28:06,209
requests that have C surf tokens and so

706
00:27:57,720 --> 00:28:07,169
on right now this is when things stopped

707
00:28:06,210 --> 00:28:10,410
going according to plan

708
00:28:07,169 --> 00:28:12,870
while testing one target I was trying to

709
00:28:10,410 --> 00:28:14,669
trigger a video X and for some reason I

710
00:28:12,870 --> 00:28:16,709
don't normally do this I happen to load

711
00:28:14,669 --> 00:28:18,660
their home page in a browser with the

712
00:28:16,710 --> 00:28:21,150
developer tools open and I got this

713
00:28:18,660 --> 00:28:23,040
error message and I recognized the IP

714
00:28:21,150 --> 00:28:25,470
address in this error message that's the

715
00:28:23,040 --> 00:28:26,668
verb collaborator server which you don't

716
00:28:25,470 --> 00:28:29,700
want appearing on someone else's home

717
00:28:26,669 --> 00:28:31,169
page and what was concerning was I saw

718
00:28:29,700 --> 00:28:33,240
that every message regardless of what

719
00:28:31,169 --> 00:28:37,200
device and what network I loaded their

720
00:28:33,240 --> 00:28:38,820
home page from and kind of trolling back

721
00:28:37,200 --> 00:28:41,490
through what payloads I've been sending

722
00:28:38,820 --> 00:28:44,280
I had sent something like this to try

723
00:28:41,490 --> 00:28:46,380
and to get a redirect and evidently what

724
00:28:44,280 --> 00:28:48,090
happened was someone else's request had

725
00:28:46,380 --> 00:28:49,770
snuck in after mine and they'd been

726
00:28:48,090 --> 00:28:51,270
trying to fetch an image now by itself

727
00:28:49,770 --> 00:28:53,370
you know they try to fetch an image they

728
00:28:51,270 --> 00:28:57,540
got a redirect whatever it's only one

729
00:28:53,370 --> 00:28:59,520
person but they had a cache like the

730
00:28:57,540 --> 00:29:00,690
server had a server-side cache and it

731
00:28:59,520 --> 00:29:02,490
had seen this happen so it saw this

732
00:29:00,690 --> 00:29:03,840
person trying to fetch this image by

733
00:29:02,490 --> 00:29:05,970
getting a read I back to the calibrator

734
00:29:03,840 --> 00:29:07,620
server by the way this image was on the

735
00:29:05,970 --> 00:29:09,450
target's home page

736
00:29:07,620 --> 00:29:11,129
and thereby it just saved that so from

737
00:29:09,450 --> 00:29:12,900
then on for several days

738
00:29:11,130 --> 00:29:14,820
anyone that loaded that websites home

739
00:29:12,900 --> 00:29:17,270
page ended up trying to fetch this image

740
00:29:14,820 --> 00:29:20,220
from the from the collaborator server

741
00:29:17,270 --> 00:29:22,410
and unfortunately because it was HTTP

742
00:29:20,220 --> 00:29:23,730
and an IP it just failed so I couldn't

743
00:29:22,410 --> 00:29:25,620
find out what the image was meant to be

744
00:29:23,730 --> 00:29:28,820
and then host it on my own server so

745
00:29:25,620 --> 00:29:28,820
that their website wasn't so broken

746
00:29:29,060 --> 00:29:35,520
so what we've seen here on the one hand

747
00:29:32,840 --> 00:29:38,010
cache poisoning with request smuggling

748
00:29:35,520 --> 00:29:42,360
is really easy it's so easy you can do

749
00:29:38,010 --> 00:29:43,500
it by accident but on the other hand you

750
00:29:42,360 --> 00:29:46,469
don't want this to happen by accident

751
00:29:43,500 --> 00:29:48,180
seriously so there's a few things we can

752
00:29:46,470 --> 00:29:50,130
do to try and reduce the chance of that

753
00:29:48,180 --> 00:29:51,750
happening one is to try and craft our

754
00:29:50,130 --> 00:29:55,470
prefix so that it triggers a response

755
00:29:51,750 --> 00:29:58,650
that has anti caching headers another is

756
00:29:55,470 --> 00:30:01,800
to if your victim request is a get make

757
00:29:58,650 --> 00:30:04,170
sure you put a cache buster on it I also

758
00:30:01,800 --> 00:30:05,430
try and send those send those requests

759
00:30:04,170 --> 00:30:07,110
as fast as possible

760
00:30:05,430 --> 00:30:09,060
with which the tool that I've released

761
00:30:07,110 --> 00:30:10,919
will help with and finally if you have a

762
00:30:09,060 --> 00:30:12,870
choice of which front-end to exploit for

763
00:30:10,920 --> 00:30:15,390
example because the target is using a

764
00:30:12,870 --> 00:30:16,919
CDN just try and target one in a

765
00:30:15,390 --> 00:30:19,940
geographical region that's asleep

766
00:30:16,920 --> 00:30:22,920
because they were getting less traffic

767
00:30:19,940 --> 00:30:24,960
now that was that but it left me

768
00:30:22,920 --> 00:30:27,420
wondering what happened if instead of

769
00:30:24,960 --> 00:30:29,100
trying to avoid that possibility of

770
00:30:27,420 --> 00:30:30,960
cache poisoning with them with an

771
00:30:29,100 --> 00:30:34,350
attackers hand of victims requests being

772
00:30:30,960 --> 00:30:36,900
combined we embrace it so here I've sent

773
00:30:34,350 --> 00:30:39,270
a request that's trying to fetch an API

774
00:30:36,900 --> 00:30:41,040
key and when the victims request gets

775
00:30:39,270 --> 00:30:43,050
stuck on the end it's completed using

776
00:30:41,040 --> 00:30:45,060
their cookie so it's in their session

777
00:30:43,050 --> 00:30:46,470
and it fetches their key and they're

778
00:30:45,060 --> 00:30:49,260
gonna be the person that sees that that

779
00:30:46,470 --> 00:30:50,880
response so by itself that's harmless

780
00:30:49,260 --> 00:30:53,430
but one is once there's a cache in the

781
00:30:50,880 --> 00:30:55,620
mix the cache may end up thinking that's

782
00:30:53,430 --> 00:30:57,510
actually some static resource and saving

783
00:30:55,620 --> 00:30:59,159
it over the static resource and then you

784
00:30:57,510 --> 00:31:02,730
can balance that JavaScript and just

785
00:30:59,160 --> 00:31:05,160
fetch their key this is basically web

786
00:31:02,730 --> 00:31:06,870
cache deception the main difference

787
00:31:05,160 --> 00:31:10,290
being that as usual it doesn't require

788
00:31:06,870 --> 00:31:12,360
any user interaction whatsoever I wasn't

789
00:31:10,290 --> 00:31:13,950
able to get a real example of this

790
00:31:12,360 --> 00:31:16,770
because it's not the right type of thing

791
00:31:13,950 --> 00:31:21,600
from my pipeline to find but I'm pretty

792
00:31:16,770 --> 00:31:22,950
short out there now on new relic we saw

793
00:31:21,600 --> 00:31:26,129
that their back-end was an internal

794
00:31:22,950 --> 00:31:27,360
proxy and on some other systems for a

795
00:31:26,130 --> 00:31:29,580
reason I've never been able to figure

796
00:31:27,360 --> 00:31:31,530
out they chained CD ends on to each

797
00:31:29,580 --> 00:31:33,240
other so like one target had the front

798
00:31:31,530 --> 00:31:35,010
end was Akamai and the back end from

799
00:31:33,240 --> 00:31:38,040
addy synchronization point of view was

800
00:31:35,010 --> 00:31:39,900
CloudFlare I couldn't exploit that one

801
00:31:38,040 --> 00:31:40,920
but these guys were chaining Akamai onto

802
00:31:39,900 --> 00:31:42,780
Akamai

803
00:31:40,920 --> 00:31:44,400
and that the two Akamai servers were

804
00:31:42,780 --> 00:31:46,440
configured differently so by changing

805
00:31:44,400 --> 00:31:48,630
the host header I could serve up content

806
00:31:46,440 --> 00:31:52,290
from anything anywhere on the Akamai

807
00:31:48,630 --> 00:31:52,950
Network on these guys home page and the

808
00:31:52,290 --> 00:31:54,420
front end

809
00:31:52,950 --> 00:31:55,860
ikomaya was happy to cache that so I

810
00:31:54,420 --> 00:31:58,020
could overwrite their home page more or

811
00:31:55,860 --> 00:32:01,830
less permanently with content from

812
00:31:58,020 --> 00:32:04,560
pretty much anywhere on the Internet now

813
00:32:01,830 --> 00:32:05,550
looking at Red Hat's website are they

814
00:32:04,560 --> 00:32:09,210
were using Akamai they were vulnerable

815
00:32:05,550 --> 00:32:10,770
and I was looking for a way to how I

816
00:32:09,210 --> 00:32:13,020
could do some damage with this technique

817
00:32:10,770 --> 00:32:15,240
and I found this dom-based to open

818
00:32:13,020 --> 00:32:17,160
redirect and that raised an interesting

819
00:32:15,240 --> 00:32:19,860
challenge because with requests

820
00:32:17,160 --> 00:32:22,140
smuggling we control the URL that the

821
00:32:19,860 --> 00:32:25,139
backend server thinks the user is trying

822
00:32:22,140 --> 00:32:28,050
to access but we don't control the URL

823
00:32:25,140 --> 00:32:29,880
in the victims browser so you can't die

824
00:32:28,050 --> 00:32:31,860
you can't hide you out the value that

825
00:32:29,880 --> 00:32:34,430
gets passed to this get query plan

826
00:32:31,860 --> 00:32:39,000
function and exploit this vulnerability

827
00:32:34,430 --> 00:32:41,930
but I was able to find a client a non I

828
00:32:39,000 --> 00:32:45,390
was able to find a local redirect a

829
00:32:41,930 --> 00:32:48,060
server-side local redirect on the target

830
00:32:45,390 --> 00:32:49,950
and use that to gain control of of the

831
00:32:48,060 --> 00:32:50,820
URL in the victims browser and then send

832
00:32:49,950 --> 00:32:53,790
them to the page where the dom-based

833
00:32:50,820 --> 00:32:55,700
open redirect to make that exploitable

834
00:32:53,790 --> 00:32:57,629
so this is a generic

835
00:32:55,700 --> 00:33:00,060
technique that will help you make many

836
00:32:57,630 --> 00:33:09,120
Dom based issues exploitable with

837
00:33:00,060 --> 00:33:10,980
requests smuggling what so we've seen

838
00:33:09,120 --> 00:33:12,689
local redirects can be useful when

839
00:33:10,980 --> 00:33:15,090
you've got done based XSS and suchlike

840
00:33:12,690 --> 00:33:17,670
but they also often just happen to turn

841
00:33:15,090 --> 00:33:19,530
into open redirects in the presence of

842
00:33:17,670 --> 00:33:21,810
requests smuggling because we can

843
00:33:19,530 --> 00:33:24,930
control the host header in particular

844
00:33:21,810 --> 00:33:26,970
there's a default behavior on Apache and

845
00:33:24,930 --> 00:33:28,770
some versions of iOS whereby if you try

846
00:33:26,970 --> 00:33:30,780
and access a folder without a trailing

847
00:33:28,770 --> 00:33:33,060
slash they just give you a redirect to

848
00:33:30,780 --> 00:33:36,030
send you to that folder and the host

849
00:33:33,060 --> 00:33:37,800
part of that redirect is populated using

850
00:33:36,030 --> 00:33:39,660
your smuggled host header so using this

851
00:33:37,800 --> 00:33:42,840
you can get AV direct to your server

852
00:33:39,660 --> 00:33:44,820
from pretty much any website and this

853
00:33:42,840 --> 00:33:46,679
combines really well with cache

854
00:33:44,820 --> 00:33:48,570
poisoning right because you can just

855
00:33:46,680 --> 00:33:50,490
take a JavaScript file and permanently

856
00:33:48,570 --> 00:33:52,649
convert that javascript file into a

857
00:33:50,490 --> 00:33:54,870
redirect to your malicious JavaScript

858
00:33:52,650 --> 00:33:57,420
file and that technique

859
00:33:54,870 --> 00:33:59,010
was so easy and didn't require much

860
00:33:57,420 --> 00:34:00,480
effort in terms of actually looking at

861
00:33:59,010 --> 00:34:02,129
the website you just use it as is on

862
00:34:00,480 --> 00:34:03,660
every target so it became my de-facto

863
00:34:02,130 --> 00:34:06,559
technique to exploit this vulnerability

864
00:34:03,660 --> 00:34:11,940
and I got a decent number of bounties

865
00:34:06,559 --> 00:34:13,620
using it also worth mentioning is if you

866
00:34:11,940 --> 00:34:16,860
can get an open redirect like this but

867
00:34:13,620 --> 00:34:17,638
with the 307 status code that's a

868
00:34:16,860 --> 00:34:20,580
wonderful news

869
00:34:17,639 --> 00:34:22,740
because if a browser is doing a post

870
00:34:20,580 --> 00:34:24,629
request like say trying to log someone

871
00:34:22,739 --> 00:34:27,418
in with a username and password and it

872
00:34:24,629 --> 00:34:29,699
sees the 307 it's gonna resend the

873
00:34:27,418 --> 00:34:34,440
username and password in plain text to

874
00:34:29,699 --> 00:34:37,408
that new destination now one of the

875
00:34:34,440 --> 00:34:42,240
targets that this I rely that poisoning

876
00:34:37,409 --> 00:34:44,580
technique worked on was PayPal so there

877
00:34:42,239 --> 00:34:46,859
was a couple of small caches one is that

878
00:34:44,580 --> 00:34:48,840
because there were two host headers in

879
00:34:46,860 --> 00:34:52,320
the smuggled request one coming for me

880
00:34:48,840 --> 00:34:54,030
and one coming from the victim though

881
00:34:52,320 --> 00:34:55,350
getting concatenated in the location

882
00:34:54,030 --> 00:34:58,230
header which wasn't great but I was able

883
00:34:55,350 --> 00:35:01,049
to fix that by syncing question mark at

884
00:34:58,230 --> 00:35:02,940
the end of a host header the other catch

885
00:35:01,050 --> 00:35:05,670
is that if you look closely you'll see

886
00:35:02,940 --> 00:35:07,950
the protocol in the location in the

887
00:35:05,670 --> 00:35:09,900
redirect is HTTP which means when we try

888
00:35:07,950 --> 00:35:12,210
to hijack scripts that may get blocked

889
00:35:09,900 --> 00:35:14,970
by mixed content protection but there

890
00:35:12,210 --> 00:35:16,650
are ways around that in Safari and edge

891
00:35:14,970 --> 00:35:17,819
and ie which I don't have time to cover

892
00:35:16,650 --> 00:35:19,260
now but they're covered in my

893
00:35:17,820 --> 00:35:22,980
presentation last year on web cache

894
00:35:19,260 --> 00:35:24,690
poisoning so we can poison this

895
00:35:22,980 --> 00:35:26,840
javascript file with a B direct to our

896
00:35:24,690 --> 00:35:30,030
server permanently in those browsers

897
00:35:26,840 --> 00:35:33,530
where is this JavaScript file used right

898
00:35:30,030 --> 00:35:35,940
it's used on PayPal sign-in page

899
00:35:33,530 --> 00:35:37,620
unfortunately there's a little bit of a

900
00:35:35,940 --> 00:35:40,050
catch which is that PayPal sign-in page

901
00:35:37,620 --> 00:35:44,210
also uses CSP meaning that this redirect

902
00:35:40,050 --> 00:35:47,670
will get blocked by the CSP wolves but

903
00:35:44,210 --> 00:35:49,920
PayPal also use on their sign-in page

904
00:35:47,670 --> 00:35:52,530
they've got an invisible iframe and this

905
00:35:49,920 --> 00:35:55,320
loads on C dot paypal.com and it also

906
00:35:52,530 --> 00:35:57,930
loads our poison JavaScript flow and it

907
00:35:55,320 --> 00:36:01,830
doesn't have CSP so that means we can

908
00:35:57,930 --> 00:36:03,660
hijack this iframe on this iframe that's

909
00:36:01,830 --> 00:36:06,060
being loaded in visibly on the login

910
00:36:03,660 --> 00:36:08,009
page but we can't just read the user's

911
00:36:06,060 --> 00:36:10,799
password out the parent page

912
00:36:08,010 --> 00:36:13,560
because of the same-origin policy the

913
00:36:10,800 --> 00:36:15,000
fact we want to see paypal calm here but

914
00:36:13,560 --> 00:36:19,620
my colleague Gareth faces

915
00:36:15,000 --> 00:36:22,140
Alice somewhere found paypal calm / us /

916
00:36:19,620 --> 00:36:23,910
gifts this is a static page it's on

917
00:36:22,140 --> 00:36:25,950
paypal calm

918
00:36:23,910 --> 00:36:28,230
it doesn't use CSP maybe because of

919
00:36:25,950 --> 00:36:31,680
static and it imports are malicious

920
00:36:28,230 --> 00:36:34,050
javascript file so we could hijack the

921
00:36:31,680 --> 00:36:37,080
iframe on c paypal calm and then we

922
00:36:34,050 --> 00:36:39,450
could redirect this iframe to the slash

923
00:36:37,080 --> 00:36:40,860
gif its page and then we could rehydrate

924
00:36:39,450 --> 00:36:43,410
matt using our malicious javascript file

925
00:36:40,860 --> 00:36:45,030
again and then really uses plain text

926
00:36:43,410 --> 00:36:47,490
PayPal password off the parent page and

927
00:36:45,030 --> 00:36:48,870
send it off to our website and for that

928
00:36:47,490 --> 00:36:59,430
I got a nineteen thousand dollar bounty

929
00:36:48,870 --> 00:37:01,350
off paper now PayPal fix this by making

930
00:36:59,430 --> 00:37:04,230
the front end system reject any message

931
00:37:01,350 --> 00:37:05,730
that looks like it was chunked and they

932
00:37:04,230 --> 00:37:07,380
said like hey James do you think this

933
00:37:05,730 --> 00:37:08,850
fix is solid and I spent half the

934
00:37:07,380 --> 00:37:12,000
morning poking at it and I was like yeah

935
00:37:08,850 --> 00:37:14,970
seems to write to me luckily I always

936
00:37:12,000 --> 00:37:17,310
phrase these things carefully and a

937
00:37:14,970 --> 00:37:19,049
couple of weeks later I came up with the

938
00:37:17,310 --> 00:37:20,700
new D synchronization technique and I

939
00:37:19,050 --> 00:37:22,500
didn't think this one was really gonna

940
00:37:20,700 --> 00:37:24,660
work so all I'm doing here is I'm using

941
00:37:22,500 --> 00:37:26,850
a line wrapped header so this is valid

942
00:37:24,660 --> 00:37:30,180
for the RFC spec and every server should

943
00:37:26,850 --> 00:37:32,040
treat this as being chunked and every

944
00:37:30,180 --> 00:37:34,140
server kind of did treat this as being

945
00:37:32,040 --> 00:37:35,820
chunked except that for some reason the

946
00:37:34,140 --> 00:37:38,279
line map made the word chunked invisible

947
00:37:35,820 --> 00:37:39,960
to Akamai so this bypass the filter then

948
00:37:38,280 --> 00:37:42,180
I could once again point poison PayPal's

949
00:37:39,960 --> 00:37:44,760
login page and they paid me another 20k

950
00:37:42,180 --> 00:37:46,500
bounty I thought that was really

951
00:37:44,760 --> 00:37:49,020
generous especially given it was kind of

952
00:37:46,500 --> 00:37:52,500
my fault that I didn't find bypass in

953
00:37:49,020 --> 00:37:54,030
the first place okay so now we've seen a

954
00:37:52,500 --> 00:37:56,070
whole range of different attacks we can

955
00:37:54,030 --> 00:38:04,260
do with requests smuggling I'm gonna

956
00:37:56,070 --> 00:38:07,100
attempt a live demo so let's see here

957
00:38:04,260 --> 00:38:09,450
yep something great I've got a replica a

958
00:38:07,100 --> 00:38:11,520
replica of a real system that may be

959
00:38:09,450 --> 00:38:15,730
familiar generally holds lots of GC

960
00:38:11,520 --> 00:38:19,300
Firefox relays this is a local replica

961
00:38:15,730 --> 00:38:21,760
and so I'm going to take a request of a

962
00:38:19,300 --> 00:38:23,410
site I'm gonna right click and click

963
00:38:21,760 --> 00:38:24,760
Launch smuggle probe that option is

964
00:38:23,410 --> 00:38:26,710
there because of the open-source

965
00:38:24,760 --> 00:38:28,230
extension I've installed and you can see

966
00:38:26,710 --> 00:38:30,160
there's loads of desync techniques and

967
00:38:28,230 --> 00:38:34,480
I've turned them all off apart from the

968
00:38:30,160 --> 00:38:36,700
one that's actually gonna work so if we

969
00:38:34,480 --> 00:38:39,310
look at this flow window we can see the

970
00:38:36,700 --> 00:38:40,180
requests that are being sent and you can

971
00:38:39,310 --> 00:38:42,009
see this technique

972
00:38:40,180 --> 00:38:45,730
this tool is using the time-out

973
00:38:42,010 --> 00:38:47,800
technique see here that I showed you

974
00:38:45,730 --> 00:38:50,410
earlier and we are in fact getting a

975
00:38:47,800 --> 00:38:51,670
timeout so it's just going to do some

976
00:38:50,410 --> 00:38:54,160
confirmations and stuff to make sure

977
00:38:51,670 --> 00:38:58,780
this time it's vulnerable and now if we

978
00:38:54,160 --> 00:39:00,368
look over idea if any second now if you

979
00:38:58,780 --> 00:39:01,660
look over here then in a second

980
00:39:00,369 --> 00:39:04,270
it should find an issue let me show you

981
00:39:01,660 --> 00:39:08,339
why is this D synchronizing it it's

982
00:39:04,270 --> 00:39:11,170
because of this header here this header

983
00:39:08,340 --> 00:39:14,080
ends this is gonna be way too small to

984
00:39:11,170 --> 00:39:18,310
see but after the bar this header ends

985
00:39:14,080 --> 00:39:20,160
with 0a it doesn't end with 0d 0a so

986
00:39:18,310 --> 00:39:22,720
that means that the front end server

987
00:39:20,160 --> 00:39:24,520
hasn't based on the front end of thing

988
00:39:22,720 --> 00:39:27,279
so that's one header and it falls back

989
00:39:24,520 --> 00:39:29,680
to using the content length right it's

990
00:39:27,280 --> 00:39:31,990
fine the issue excellent so I'll I click

991
00:39:29,680 --> 00:39:33,700
on the issue we've now got this smuggle

992
00:39:31,990 --> 00:39:36,850
attack option let's go to pop open a

993
00:39:33,700 --> 00:39:38,080
turbo intruder window threefold with a

994
00:39:36,850 --> 00:39:39,759
script that you don't need to change

995
00:39:38,080 --> 00:39:42,640
anything in this script except the

996
00:39:39,760 --> 00:39:44,800
prefix that the prefix is variable is

997
00:39:42,640 --> 00:39:47,319
them is is the malicious prefix as shown

998
00:39:44,800 --> 00:39:50,530
in orange on all the slides so when I

999
00:39:47,320 --> 00:39:51,790
press attack it's gonna send the it's

1000
00:39:50,530 --> 00:39:53,859
going to similar so I can send a whole

1001
00:39:51,790 --> 00:39:56,230
bunch of victim requests that are

1002
00:39:53,859 --> 00:39:57,310
identical and the idea is one of those

1003
00:39:56,230 --> 00:40:01,750
who'd get a 44

1004
00:39:57,310 --> 00:40:04,170
that's who happens yeah there we go

1005
00:40:01,750 --> 00:40:06,850
great so like these requests are long

1006
00:40:04,170 --> 00:40:12,040
identical Inc including this one but

1007
00:40:06,850 --> 00:40:14,140
this one got a 44 why because of this

1008
00:40:12,040 --> 00:40:15,480
bit of smuggle data in here so we now

1009
00:40:14,140 --> 00:40:21,460
know that this target is vulnerable

1010
00:40:15,480 --> 00:40:23,280
let's see what damage we could do so on

1011
00:40:21,460 --> 00:40:26,800
Bugzilla anyone can register an account

1012
00:40:23,280 --> 00:40:27,940
they could file a bug and they can put

1013
00:40:26,800 --> 00:40:29,500
an attachment on the bug and the

1014
00:40:27,940 --> 00:40:31,060
attachment can contain HTML

1015
00:40:29,500 --> 00:40:33,250
get surrendered on a Sun box tonight so

1016
00:40:31,060 --> 00:40:35,109
here we all be in my web dot VM that's

1017
00:40:33,250 --> 00:40:37,270
where the application is if I load the

1018
00:40:35,109 --> 00:40:38,799
attachment we won't be on my sandbox dot

1019
00:40:37,270 --> 00:40:44,140
VM so by itself this behavior it's

1020
00:40:38,800 --> 00:40:46,359
harmless but what I'm going to do is try

1021
00:40:44,140 --> 00:40:49,629
and take that request to fetch the

1022
00:40:46,359 --> 00:40:59,980
attachment and then I'm going to use

1023
00:40:49,630 --> 00:41:00,750
that in the malicious prefix here right

1024
00:40:59,980 --> 00:41:04,030
there we go

1025
00:41:00,750 --> 00:41:06,099
so now when I send that you can see one

1026
00:41:04,030 --> 00:41:08,200
of the requests to server has ended up

1027
00:41:06,099 --> 00:41:10,510
fetching this attachment even though it

1028
00:41:08,200 --> 00:41:14,890
was actually sent to be in my web dot VM

1029
00:41:10,510 --> 00:41:17,260
so now simply need to comment out the

1030
00:41:14,890 --> 00:41:18,700
victim request so now I'm gonna do the

1031
00:41:17,260 --> 00:41:20,410
same thing but I'm gonna leave the

1032
00:41:18,700 --> 00:41:23,770
poison light waiting on the socket in

1033
00:41:20,410 --> 00:41:25,450
the server and that means as soon as a

1034
00:41:23,770 --> 00:41:27,220
user clicks pretty much anything it

1035
00:41:25,450 --> 00:41:29,529
doesn't matter they're gonna get my

1036
00:41:27,220 --> 00:41:32,618
pillow back it's on being my web dot VM

1037
00:41:29,530 --> 00:41:35,349
and it's supposed to still the password

1038
00:41:32,619 --> 00:41:41,140
and it didn't there you go

1039
00:41:35,349 --> 00:41:43,119
it autofills not me Oh No so that's an

1040
00:41:41,140 --> 00:41:44,859
example just showing you how to use that

1041
00:41:43,119 --> 00:41:46,300
tool that's the first time that's demoed

1042
00:41:44,859 --> 00:41:51,490
failed out like the five times I've done

1043
00:41:46,300 --> 00:41:54,550
this lucky you guys I guess and for that

1044
00:41:51,490 --> 00:41:57,490
I got a line $8,000 bounty taking the

1045
00:41:54,550 --> 00:42:01,330
total to just shy of 75 K and so far

1046
00:41:57,490 --> 00:42:03,549
join us research now how do we prevent

1047
00:42:01,330 --> 00:42:07,660
this well you can't defend against these

1048
00:42:03,550 --> 00:42:10,930
attacks without tooling to find these

1049
00:42:07,660 --> 00:42:13,720
vulnerabilities and in particular quite

1050
00:42:10,930 --> 00:42:15,970
a few tools won't let you send invalid

1051
00:42:13,720 --> 00:42:18,910
countenance headers and they will

1052
00:42:15,970 --> 00:42:20,379
normalize the requests that you send and

1053
00:42:18,910 --> 00:42:22,319
both of those things can almost

1054
00:42:20,380 --> 00:42:25,720
invisibly stop you from finding these

1055
00:42:22,320 --> 00:42:27,910
vulnerabilities in particular curl is

1056
00:42:25,720 --> 00:42:28,779
not great for sending requests smuggling

1057
00:42:27,910 --> 00:42:31,000
payloads

1058
00:42:28,780 --> 00:42:33,880
please just use like netcat or just pipe

1059
00:42:31,000 --> 00:42:35,589
echo to open SSL or something like that

1060
00:42:33,880 --> 00:42:38,589
that gives you more control over what

1061
00:42:35,589 --> 00:42:40,630
the request looks like also some

1062
00:42:38,589 --> 00:42:43,119
companies like to force pen testers to

1063
00:42:40,630 --> 00:42:44,710
use a proxy or a VPN

1064
00:42:43,119 --> 00:42:47,319
or something like that and if that's

1065
00:42:44,710 --> 00:42:50,190
doing proxying that will be messing up

1066
00:42:47,319 --> 00:42:51,940
these payloads it will be masking real

1067
00:42:50,190 --> 00:42:53,710
vulnerabilities and it will also be

1068
00:42:51,940 --> 00:42:55,660
introducing fake vulnerabilities that

1069
00:42:53,710 --> 00:42:57,569
can only be used tack other pen testers

1070
00:42:55,660 --> 00:43:00,399
so please don't do that

1071
00:42:57,569 --> 00:43:02,589
as far as patching this goes the ideal

1072
00:43:00,400 --> 00:43:04,690
solution everyone gets annoyed when I

1073
00:43:02,589 --> 00:43:06,460
tell them sadly this is to use hasty to

1074
00:43:04,690 --> 00:43:09,930
be too exclusively to talk to back-end

1075
00:43:06,460 --> 00:43:12,519
servers but obviously not everyone can

1076
00:43:09,930 --> 00:43:14,950
can do that so what also works pretty

1077
00:43:12,519 --> 00:43:18,008
well is having the front-end I'm doing

1078
00:43:14,950 --> 00:43:21,609
extensive normalization of requests

1079
00:43:18,009 --> 00:43:24,569
before routing them on that saying that

1080
00:43:21,609 --> 00:43:26,650
technique is backed up by RFC 7230

1081
00:43:24,569 --> 00:43:28,660
finally if you're forced to try and

1082
00:43:26,650 --> 00:43:30,430
patch this on the back end you need to

1083
00:43:28,660 --> 00:43:33,160
and you get if you get an ambiguous

1084
00:43:30,430 --> 00:43:34,839
request you need to drop that request

1085
00:43:33,160 --> 00:43:37,779
and also drop the connection and

1086
00:43:34,839 --> 00:43:40,150
entirely to ensure any poisoned data is

1087
00:43:37,779 --> 00:43:42,519
thrown up there's a whole bunch of

1088
00:43:40,150 --> 00:43:45,099
further reading online the slides are

1089
00:43:42,519 --> 00:43:47,379
online - available from the top link

1090
00:43:45,099 --> 00:43:50,170
there the main thing I'd like to draw

1091
00:43:47,380 --> 00:43:51,849
your attention to is the online labs so

1092
00:43:50,170 --> 00:43:53,979
we've released a bunch of free online

1093
00:43:51,849 --> 00:43:56,589
labs that you can use to practice these

1094
00:43:53,979 --> 00:43:58,930
vulnerabilities on real issue websites

1095
00:43:56,589 --> 00:44:01,058
and gain experience with this for

1096
00:43:58,930 --> 00:44:03,719
yourself before you go out into the real

1097
00:44:01,059 --> 00:44:06,460
world and everything gets really chaotic

1098
00:44:03,719 --> 00:44:09,009
now the three key things to take away

1099
00:44:06,460 --> 00:44:10,479
are the HTTP requests muggin is real

1100
00:44:09,009 --> 00:44:12,190
regardless of how much you might not

1101
00:44:10,479 --> 00:44:15,038
want to think about it

1102
00:44:12,190 --> 00:44:17,529
HTTP 1.1 parsing is a security critical

1103
00:44:15,039 --> 00:44:19,170
function for functionality so when

1104
00:44:17,529 --> 00:44:21,039
you're making your choice of web server

1105
00:44:19,170 --> 00:44:24,339
this is something you should definitely

1106
00:44:21,039 --> 00:44:26,400
be factoring in and detection of request

1107
00:44:24,339 --> 00:44:29,440
smuggling doesn't have to be dangerous

1108
00:44:26,400 --> 00:44:32,229
I'm gonna answer questions at the back

1109
00:44:29,440 --> 00:44:33,759
in just a second if you don't get to me

1110
00:44:32,229 --> 00:44:35,890
feel free to send me an email

1111
00:44:33,759 --> 00:44:38,759
don't forget to follow me on Twitter and

1112
00:44:35,890 --> 00:44:38,759
thank you for listening

