1
00:00:00,530 --> 00:00:06,380
you

2
00:00:02,450 --> 00:00:10,219
working great I'd say my name is Sam and

3
00:00:06,380 --> 00:00:14,149
I'm from Cemil so I'll just quickly

4
00:00:10,219 --> 00:00:19,130
introduce myself so I am currently

5
00:00:14,150 --> 00:00:20,750
developer advocate for Samuel we just

6
00:00:19,130 --> 00:00:22,609
got acquired by github announced that

7
00:00:20,750 --> 00:00:25,430
last week so I'm technically now a

8
00:00:22,609 --> 00:00:27,050
developer advocate for github but we'll

9
00:00:25,430 --> 00:00:29,570
see how it goes I'm pretty excited for

10
00:00:27,050 --> 00:00:30,650
what's to come and before I was a

11
00:00:29,570 --> 00:00:33,890
developer advocate I was actually

12
00:00:30,650 --> 00:00:37,610
working full time on our main online

13
00:00:33,890 --> 00:00:38,930
platform LG TM I am passionate about

14
00:00:37,610 --> 00:00:41,960
everything to do with open source

15
00:00:38,930 --> 00:00:44,420
security privacy used to contribute to

16
00:00:41,960 --> 00:00:46,580
signal for example cryptography I love

17
00:00:44,420 --> 00:00:49,449
I'm super passionate about code quality

18
00:00:46,580 --> 00:00:52,010
and I also dabble in stage lighting and

19
00:00:49,449 --> 00:00:54,349
this is my twitter handle and github

20
00:00:52,010 --> 00:00:56,180
handle and almost like some my twitter

21
00:00:54,350 --> 00:01:00,199
handle in case you want to take any

22
00:00:56,180 --> 00:01:03,379
pictures of that any other slides so

23
00:01:00,199 --> 00:01:07,429
today I am gonna begin with a story it's

24
00:01:03,379 --> 00:01:11,149
a story of many bugs and it begins with

25
00:01:07,430 --> 00:01:14,210
a report on the 7th of September 2017 my

26
00:01:11,149 --> 00:01:17,780
colleague Moe submitted a vulnerability

27
00:01:14,210 --> 00:01:20,210
and an exploit example to pivotal for

28
00:01:17,780 --> 00:01:22,070
the Spring Framework now this particular

29
00:01:20,210 --> 00:01:23,538
vulnerability took advantage of

30
00:01:22,070 --> 00:01:24,859
something called the spring expression

31
00:01:23,539 --> 00:01:27,560
language which is a way that you could

32
00:01:24,859 --> 00:01:31,729
describe ways to access certain java

33
00:01:27,560 --> 00:01:33,170
objects from strings and if you're able

34
00:01:31,729 --> 00:01:35,960
to actually execute any of these

35
00:01:33,170 --> 00:01:38,020
particular expressions you could get

36
00:01:35,960 --> 00:01:40,850
remote code execution now what this

37
00:01:38,020 --> 00:01:43,520
particular vulnerability was was it was

38
00:01:40,850 --> 00:01:45,949
interpreting certain user data from HTTP

39
00:01:43,520 --> 00:01:47,539
requests and concatenated them in some

40
00:01:45,950 --> 00:01:49,520
strings that were eventually run as

41
00:01:47,539 --> 00:01:51,920
these expressions which meant that you

42
00:01:49,520 --> 00:01:54,259
could have remote code execution on any

43
00:01:51,920 --> 00:01:59,840
of these servers simply by sending an

44
00:01:54,259 --> 00:02:01,729
HTTP request that's pretty severe so in

45
00:01:59,840 --> 00:02:04,280
response on the 21st of September

46
00:02:01,729 --> 00:02:05,869
pivotal released a patch along with the

47
00:02:04,280 --> 00:02:08,330
public announcement encouraging everyone

48
00:02:05,869 --> 00:02:11,090
to upgrade to the latest version which

49
00:02:08,330 --> 00:02:13,840
fixed the vulnerability except that it

50
00:02:11,090 --> 00:02:13,840
didn't fix the vulnerability

51
00:02:13,910 --> 00:02:18,720
over the course of the next day or two

52
00:02:15,930 --> 00:02:20,970
know how to look at the patch and he

53
00:02:18,720 --> 00:02:22,440
discovered that it wasn't a partial fix

54
00:02:20,970 --> 00:02:25,590
it didn't actually fully address the

55
00:02:22,440 --> 00:02:26,730
issue so the next day he created a new

56
00:02:25,590 --> 00:02:29,130
exploit that took advantage of a

57
00:02:26,730 --> 00:02:31,950
slightly different code path and then

58
00:02:29,130 --> 00:02:34,440
sent that to pivotal a couple of days

59
00:02:31,950 --> 00:02:37,530
later rather than during straightaway

60
00:02:34,440 --> 00:02:39,270
and making it public they did a patch

61
00:02:37,530 --> 00:02:41,220
they sent it to Moe and then asked him

62
00:02:39,270 --> 00:02:43,560
to this time to verify before they told

63
00:02:41,220 --> 00:02:50,640
everyone about it turned out the patch

64
00:02:43,560 --> 00:02:52,080
was incomplete still so they kind of

65
00:02:50,640 --> 00:02:53,279
realized that this technique wasn't

66
00:02:52,080 --> 00:02:55,140
really working anymore and there was

67
00:02:53,280 --> 00:02:56,970
something else that they needed to do it

68
00:02:55,140 --> 00:02:58,500
wasn't really good just addressing these

69
00:02:56,970 --> 00:03:00,870
problems as as they were being made

70
00:02:58,500 --> 00:03:02,550
aware of it so over the course of the

71
00:03:00,870 --> 00:03:04,410
next month they actually decided to do a

72
00:03:02,550 --> 00:03:06,540
big refactoring of this particular part

73
00:03:04,410 --> 00:03:10,590
of the code base and then on the 25th of

74
00:03:06,540 --> 00:03:12,090
October released a new version that had

75
00:03:10,590 --> 00:03:13,620
completely refracted away and removed

76
00:03:12,090 --> 00:03:16,830
the possibility of this type of exploit

77
00:03:13,620 --> 00:03:19,019
altogether so I won't talk about a bit

78
00:03:16,830 --> 00:03:23,519
of a different story now it's also a

79
00:03:19,019 --> 00:03:24,959
story of many bugs this one for the

80
00:03:23,519 --> 00:03:28,110
purposes of the story will begin on the

81
00:03:24,959 --> 00:03:29,910
27th of April when a CVE was publicly

82
00:03:28,110 --> 00:03:33,150
disclosed that was a remote code

83
00:03:29,910 --> 00:03:35,160
execution in Apache struts - now Apache

84
00:03:33,150 --> 00:03:37,230
struts had something pretty similar to

85
00:03:35,160 --> 00:03:39,390
the spring framework they had a language

86
00:03:37,230 --> 00:03:41,459
called ode Janell which allows you to

87
00:03:39,390 --> 00:03:44,160
access our retrieve Java objects from

88
00:03:41,459 --> 00:03:46,730
strings that get executed and that of

89
00:03:44,160 --> 00:03:49,230
course allows for remote code execution

90
00:03:46,730 --> 00:03:52,320
now these strings aren't supposed to be

91
00:03:49,230 --> 00:03:54,149
really made accessible or available to

92
00:03:52,320 --> 00:03:56,250
use outside of the internals of the

93
00:03:54,150 --> 00:03:58,980
framework but nevertheless there was

94
00:03:56,250 --> 00:04:01,170
this vulnerability and pretty similar to

95
00:03:58,980 --> 00:04:05,459
the struts one it was interpreting the

96
00:04:01,170 --> 00:04:07,530
user data as I was using the user data

97
00:04:05,459 --> 00:04:11,760
directly to create these strings that

98
00:04:07,530 --> 00:04:13,560
would then execute so again you could

99
00:04:11,760 --> 00:04:15,120
have send an HTTP request to an Apache

100
00:04:13,560 --> 00:04:16,790
struts to server and get remote code

101
00:04:15,120 --> 00:04:19,790
execution

102
00:04:16,790 --> 00:04:22,880
so they fix the bug sent out a patch

103
00:04:19,790 --> 00:04:24,680
made an announcement on the 12th of May

104
00:04:22,880 --> 00:04:27,260
2016 there was another remote code

105
00:04:24,680 --> 00:04:29,150
execution bug that allowed user data to

106
00:04:27,260 --> 00:04:31,820
flow to an adrianel string say same

107
00:04:29,150 --> 00:04:33,950
thing again 2013 there was a

108
00:04:31,820 --> 00:04:37,460
vulnerability that interpreted user data

109
00:04:33,950 --> 00:04:38,900
is an OG now string 19th of March 2017

110
00:04:37,460 --> 00:04:40,370
there was another vulnerability that

111
00:04:38,900 --> 00:04:43,520
interpreted user data is an original

112
00:04:40,370 --> 00:04:46,130
string and on the 22nd of September 2017

113
00:04:43,520 --> 00:04:47,719
and then the latest one I believe is

114
00:04:46,130 --> 00:04:52,250
this one that was also discovered when

115
00:04:47,720 --> 00:04:56,270
my care work and my now there's only so

116
00:04:52,250 --> 00:04:57,320
much space on the slide and I wasn't

117
00:04:56,270 --> 00:04:58,549
really able to fit in all the

118
00:04:57,320 --> 00:05:08,810
vulnerabilities so here are the other

119
00:04:58,550 --> 00:05:11,540
ten and they're all the same type of

120
00:05:08,810 --> 00:05:13,850
mistake user data is flowing from an

121
00:05:11,540 --> 00:05:15,350
HTTP request and being used to construct

122
00:05:13,850 --> 00:05:19,340
a string that they execute allowing

123
00:05:15,350 --> 00:05:21,400
remote code execution so we have a bit

124
00:05:19,340 --> 00:05:23,719
of a problem here

125
00:05:21,400 --> 00:05:25,400
and it might make it might seem like I'm

126
00:05:23,720 --> 00:05:28,190
just making fun of these two open-source

127
00:05:25,400 --> 00:05:29,810
projects in particular but these kinds

128
00:05:28,190 --> 00:05:32,240
of stories are common across the entire

129
00:05:29,810 --> 00:05:34,040
software industry whether or not it's

130
00:05:32,240 --> 00:05:36,740
open source software or not it could be

131
00:05:34,040 --> 00:05:38,690
closed source it affects all of us and

132
00:05:36,740 --> 00:05:41,870
it's not just a small companies either

133
00:05:38,690 --> 00:05:44,510
for example Apple published the source

134
00:05:41,870 --> 00:05:47,720
code for part of Mac OS and OS X called

135
00:05:44,510 --> 00:05:49,370
the xnu kernel and this source code is

136
00:05:47,720 --> 00:05:51,980
available to download for you to have a

137
00:05:49,370 --> 00:05:54,350
look at and one of my other co-workers

138
00:05:51,980 --> 00:05:56,630
Kevin Backhouse discovered a remote code

139
00:05:54,350 --> 00:05:59,930
execution in a component called the

140
00:05:56,630 --> 00:06:03,890
packet Mangler now he reported this

141
00:05:59,930 --> 00:06:06,620
vulnerability to apple with a POC if

142
00:06:03,890 --> 00:06:10,340
they fixed the vulnerability pushed out

143
00:06:06,620 --> 00:06:11,450
an update when they later then published

144
00:06:10,340 --> 00:06:14,539
the source code for that particular

145
00:06:11,450 --> 00:06:16,400
version Kevin had a look at that source

146
00:06:14,540 --> 00:06:18,320
code and discovered that there was still

147
00:06:16,400 --> 00:06:22,340
a bug in the exact same block of code

148
00:06:18,320 --> 00:06:26,030
that they just put the patch in so he

149
00:06:22,340 --> 00:06:27,650
created a new exploit sent the exploit

150
00:06:26,030 --> 00:06:30,758
to Apple and then they later had to fix

151
00:06:27,650 --> 00:06:32,929
that in another patch or another

152
00:06:30,759 --> 00:06:34,810
so we're seeing the same kinds of

153
00:06:32,930 --> 00:06:36,620
mistakes being made over and over again

154
00:06:34,810 --> 00:06:40,159
leading to vulnerabilities that

155
00:06:36,620 --> 00:06:41,360
manifests over and over again so how do

156
00:06:40,159 --> 00:06:44,539
we deal with us how do we solve this

157
00:06:41,360 --> 00:06:46,789
problem could we potentially use the

158
00:06:44,539 --> 00:06:48,349
information of a new vulnerability as an

159
00:06:46,789 --> 00:06:52,460
opportunity rather than us trying to

160
00:06:48,349 --> 00:06:55,159
respond to it as quickly as possible for

161
00:06:52,460 --> 00:06:57,080
example could you once you've found the

162
00:06:55,159 --> 00:06:58,729
root cause of a vulnerability ask

163
00:06:57,080 --> 00:07:00,050
yourself the question is it possible

164
00:06:58,729 --> 00:07:02,719
that I've made a similar mistake

165
00:07:00,050 --> 00:07:04,819
anywhere else in my codebase there could

166
00:07:02,719 --> 00:07:06,319
be something architectural II about your

167
00:07:04,819 --> 00:07:07,789
project that means that you're

168
00:07:06,319 --> 00:07:09,919
susceptible to a certain class of

169
00:07:07,789 --> 00:07:11,840
vulnerability or it's more likely to

170
00:07:09,919 --> 00:07:13,128
happen for example your use of C may

171
00:07:11,840 --> 00:07:14,888
increase chances of having certain

172
00:07:13,129 --> 00:07:17,930
memory corruption vulnerabilities or

173
00:07:14,889 --> 00:07:20,960
using something like Apaches AGL or

174
00:07:17,930 --> 00:07:22,099
spring expression language might make

175
00:07:20,960 --> 00:07:25,758
you vulnerable to remote code execution

176
00:07:22,099 --> 00:07:27,620
when you're dealing with user data so

177
00:07:25,759 --> 00:07:29,389
you should try and find similar mistakes

178
00:07:27,620 --> 00:07:33,440
elsewhere because the chances are you

179
00:07:29,389 --> 00:07:36,740
will find something and companies such

180
00:07:33,440 --> 00:07:38,840
as Google and Microsoft who have been

181
00:07:36,740 --> 00:07:40,460
doing this for a while now actually have

182
00:07:38,840 --> 00:07:44,330
a name for this process and they call it

183
00:07:40,460 --> 00:07:45,650
variant analysis and for them it's

184
00:07:44,330 --> 00:07:47,120
simply not an option not to do it so

185
00:07:45,650 --> 00:07:50,109
this quote is from a blog post from

186
00:07:47,120 --> 00:07:53,060
Stephen hunter who works with Microsoft

187
00:07:50,110 --> 00:07:55,129
and he says after doing root cause

188
00:07:53,060 --> 00:07:57,860
analysis our next step is variant

189
00:07:55,129 --> 00:07:59,960
analysis finding and investigating any

190
00:07:57,860 --> 00:08:01,789
variants of the vulnerability it's

191
00:07:59,960 --> 00:08:03,049
important that we find all such variants

192
00:08:01,789 --> 00:08:05,599
and patch them to melt aeneas ly

193
00:08:03,050 --> 00:08:09,319
otherwise we bear the risk of that B of

194
00:08:05,599 --> 00:08:12,620
these being exploited in the wild and I

195
00:08:09,319 --> 00:08:14,659
would highly recommend taking a look at

196
00:08:12,620 --> 00:08:20,210
this blog basis it's very good very

197
00:08:14,659 --> 00:08:22,310
insightful so yeah so for these

198
00:08:20,210 --> 00:08:25,520
companies it's it's simply not an option

199
00:08:22,310 --> 00:08:26,900
not to do variant analysis as a stage of

200
00:08:25,520 --> 00:08:29,779
their vulnerability response that

201
00:08:26,900 --> 00:08:31,878
happens before making any details of a

202
00:08:29,779 --> 00:08:33,860
vulnerability public so that they can

203
00:08:31,879 --> 00:08:35,560
patch the original vulnerability as well

204
00:08:33,860 --> 00:08:38,449
as all the variants at the same time

205
00:08:35,559 --> 00:08:40,818
because if they don't do that when they

206
00:08:38,448 --> 00:08:42,769
do release a patch other people will

207
00:08:40,818 --> 00:08:44,329
take it upon themselves to try and find

208
00:08:42,769 --> 00:08:45,709
similar vulnerabilities potentially

209
00:08:44,329 --> 00:08:48,410
reverse engineering the patch if

210
00:08:45,709 --> 00:08:54,339
necessary and then of course exploiting

211
00:08:48,410 --> 00:08:57,649
it if they can so how do you do this

212
00:08:54,339 --> 00:09:00,759
mystical variant analysis well to be

213
00:08:57,649 --> 00:09:03,049
honestly to be honest until recently

214
00:09:00,759 --> 00:09:04,819
most of the big players have been

215
00:09:03,049 --> 00:09:08,029
predominately relying on a lot of manual

216
00:09:04,819 --> 00:09:10,069
work by their security response teams so

217
00:09:08,029 --> 00:09:12,230
focusing on particular sensitive areas

218
00:09:10,069 --> 00:09:14,509
of a code base that are more likely to

219
00:09:12,230 --> 00:09:16,129
have vulnerabilities or manually

220
00:09:14,509 --> 00:09:17,509
checking how data flows through an

221
00:09:16,129 --> 00:09:19,839
application using techniques like

222
00:09:17,509 --> 00:09:21,709
control flow or data flow analysis and

223
00:09:19,839 --> 00:09:23,899
checking the range of values that

224
00:09:21,709 --> 00:09:25,128
certain variables can take ensuring that

225
00:09:23,899 --> 00:09:27,920
you're checking bounds correctly that

226
00:09:25,129 --> 00:09:30,049
sort of thing and often doing this sort

227
00:09:27,920 --> 00:09:32,299
of research makes a lot of use of tech

228
00:09:30,049 --> 00:09:36,319
search tools like crap in a wk that sort

229
00:09:32,299 --> 00:09:39,410
of thing using something like an IDE or

230
00:09:36,319 --> 00:09:40,969
something else more language aware like

231
00:09:39,410 --> 00:09:42,709
sauce graph can be really helpful it

232
00:09:40,970 --> 00:09:46,009
allows you to jump to definition you can

233
00:09:42,709 --> 00:09:48,949
jump through the call graph make sure

234
00:09:46,009 --> 00:09:52,129
that you explore every path makes a lot

235
00:09:48,949 --> 00:09:53,599
easier than than just using grep but you

236
00:09:52,129 --> 00:09:54,980
can imagine this this sort of manual

237
00:09:53,600 --> 00:09:56,959
analysis might be difficult you might

238
00:09:54,980 --> 00:09:58,490
follow the cool graph go down a few

239
00:09:56,959 --> 00:10:00,349
functions then find yourself in a

240
00:09:58,490 --> 00:10:04,699
dead-end have to go back up and then

241
00:10:00,350 --> 00:10:06,410
explore a different path so this sort of

242
00:10:04,699 --> 00:10:08,079
this sort of process can be pretty

243
00:10:06,410 --> 00:10:09,920
repetitive and time-consuming

244
00:10:08,079 --> 00:10:12,498
it requires a lot of iterative

245
00:10:09,920 --> 00:10:15,979
exploration manually following kula

246
00:10:12,499 --> 00:10:18,110
graphs can be pretty tedious it's also

247
00:10:15,980 --> 00:10:20,240
I'm surprisingly praying through a lot

248
00:10:18,110 --> 00:10:21,410
of human error so the more complex that

249
00:10:20,240 --> 00:10:24,049
are certain mistake that you're trying

250
00:10:21,410 --> 00:10:26,209
to look for or the larger the code base

251
00:10:24,049 --> 00:10:27,499
or the closer the deadlines the more

252
00:10:26,209 --> 00:10:28,518
likely it is that something will be

253
00:10:27,499 --> 00:10:31,040
completely missed

254
00:10:28,519 --> 00:10:33,740
and it's also simply not scalable as the

255
00:10:31,040 --> 00:10:35,719
size of a code base increases manually

256
00:10:33,740 --> 00:10:37,699
checking for a particular class of

257
00:10:35,720 --> 00:10:40,459
vulnerability every time a new type of

258
00:10:37,699 --> 00:10:42,639
vulnerabilities discovered just becomes

259
00:10:40,459 --> 00:10:45,859
infeasible at least to do it thoroughly

260
00:10:42,639 --> 00:10:47,749
and as of course your list of types of

261
00:10:45,860 --> 00:10:49,610
mistakes continues to grow if as you're

262
00:10:47,749 --> 00:10:51,649
exposed to more and more types of

263
00:10:49,610 --> 00:10:53,779
vulnerabilities if you actually want to

264
00:10:51,649 --> 00:10:55,610
check these at code review time it gives

265
00:10:53,779 --> 00:10:56,570
you more and more things that you need

266
00:10:55,610 --> 00:10:58,130
to check and it can I

267
00:10:56,570 --> 00:11:01,870
completely slowed down code review or

268
00:10:58,130 --> 00:11:04,880
just make it ineffective on top of that

269
00:11:01,870 --> 00:11:07,250
even in the most high-tech companies the

270
00:11:04,880 --> 00:11:08,540
number of full-time developers far far

271
00:11:07,250 --> 00:11:11,959
outweighs the number of people working

272
00:11:08,540 --> 00:11:14,779
on security full-time so you know how

273
00:11:11,959 --> 00:11:16,880
can we expect these small teams to keep

274
00:11:14,779 --> 00:11:20,870
up with all of the code being written by

275
00:11:16,880 --> 00:11:23,389
the developers okay so that sounds

276
00:11:20,870 --> 00:11:25,160
potentially pretty bleak you need to be

277
00:11:23,389 --> 00:11:27,550
variant analysis and yet doing so is

278
00:11:25,160 --> 00:11:33,800
pretty much impossible to do thoroughly

279
00:11:27,550 --> 00:11:35,959
so can we do better than this what if we

280
00:11:33,800 --> 00:11:38,930
could automate it that sounds like it

281
00:11:35,959 --> 00:11:42,170
could be a good idea right we could

282
00:11:38,930 --> 00:11:44,060
potentially describe mistakes in a way

283
00:11:42,170 --> 00:11:46,849
that allows computers to automatically

284
00:11:44,060 --> 00:11:48,229
check for them for us so that we can

285
00:11:46,850 --> 00:11:50,839
find instances of that same mistake

286
00:11:48,230 --> 00:11:52,940
everywhere across the codebase using not

287
00:11:50,839 --> 00:11:54,949
just syntactic information but also a

288
00:11:52,940 --> 00:11:57,410
bunch of semantic information like the

289
00:11:54,949 --> 00:11:59,120
cool graph control flow data flow that

290
00:11:57,410 --> 00:12:01,010
sort of thing we could then run it

291
00:11:59,120 --> 00:12:03,079
across the entire code base get a load

292
00:12:01,010 --> 00:12:06,350
of results automatically run it across

293
00:12:03,079 --> 00:12:07,819
multiple code bases and even run it in

294
00:12:06,350 --> 00:12:09,579
the future to guard against people

295
00:12:07,819 --> 00:12:12,380
making that mistake again

296
00:12:09,579 --> 00:12:17,239
so you could use continuous analysis or

297
00:12:12,380 --> 00:12:18,529
periodic tracks well you might not be

298
00:12:17,240 --> 00:12:20,329
surprised by this but it turns out that

299
00:12:18,529 --> 00:12:23,510
there are a few tools out there that

300
00:12:20,329 --> 00:12:25,729
allow you to do exactly that so client

301
00:12:23,510 --> 00:12:28,160
ID for example I wish part of the client

302
00:12:25,730 --> 00:12:30,139
compiler can be extended to write rules

303
00:12:28,160 --> 00:12:33,620
for C++ that take into account both

304
00:12:30,139 --> 00:12:35,810
syntactic and semantic information and

305
00:12:33,620 --> 00:12:38,810
Mozilla actually have a custom set of

306
00:12:35,810 --> 00:12:40,189
rules that they run against every patch

307
00:12:38,810 --> 00:12:44,719
that's submitted to Firefox on

308
00:12:40,190 --> 00:12:47,269
fabricator to catch the sort of mistakes

309
00:12:44,720 --> 00:12:49,040
that they've experienced in the past and

310
00:12:47,269 --> 00:12:51,980
this is he's pretty extensively by their

311
00:12:49,040 --> 00:12:53,329
security teams and linters as well as

312
00:12:51,980 --> 00:12:55,579
starting to include more and more

313
00:12:53,329 --> 00:12:58,489
semantic information for their rule sets

314
00:12:55,579 --> 00:13:01,250
to use particularly those that work with

315
00:12:58,490 --> 00:13:03,889
subtly typed languages and there's also

316
00:13:01,250 --> 00:13:06,350
projects like also from pronouncing this

317
00:13:03,889 --> 00:13:08,779
right Koston l which is something that

318
00:13:06,350 --> 00:13:10,250
allows you to actually write semantic

319
00:13:08,779 --> 00:13:14,270
patches and automatically apply the

320
00:13:10,250 --> 00:13:16,100
updates and his here's the main thing

321
00:13:14,270 --> 00:13:17,630
that I'm talking about today there are

322
00:13:16,100 --> 00:13:19,700
also a number of technologies emerging

323
00:13:17,630 --> 00:13:21,830
that allow you to interactively write

324
00:13:19,700 --> 00:13:24,860
queries over the source code that

325
00:13:21,830 --> 00:13:28,880
includes semantic information including

326
00:13:24,860 --> 00:13:31,300
one solution by my company but I'm not

327
00:13:28,880 --> 00:13:33,710
going to compare all the different

328
00:13:31,300 --> 00:13:35,000
solutions in this or the different

329
00:13:33,710 --> 00:13:36,910
technologies in this presentation but I

330
00:13:35,000 --> 00:13:39,770
do want you to know that they exist and

331
00:13:36,910 --> 00:13:41,990
I do as well want to give you an idea of

332
00:13:39,770 --> 00:13:43,430
the sort of things you can write or the

333
00:13:41,990 --> 00:13:46,160
sort of checks you can write and look

334
00:13:43,430 --> 00:13:48,739
for and with these sorts of technologies

335
00:13:46,160 --> 00:13:50,089
so I'm going to go over an example from

336
00:13:48,740 --> 00:13:52,540
that same blog post I took the quote

337
00:13:50,090 --> 00:13:52,540
from earlier

338
00:13:57,790 --> 00:14:04,130
so this example code here is from

339
00:14:00,980 --> 00:14:04,460
chakracore now this is the JavaScript

340
00:14:04,130 --> 00:14:07,220
engine

341
00:14:04,460 --> 00:14:08,570
the powers Microsoft edge and a bunch of

342
00:14:07,220 --> 00:14:11,510
other Windows applications that are

343
00:14:08,570 --> 00:14:13,610
written in JavaScript and this C++ code

344
00:14:11,510 --> 00:14:15,860
is part of a built-in function that can

345
00:14:13,610 --> 00:14:20,030
be called from within JavaScript and

346
00:14:15,860 --> 00:14:21,680
I'll just go over what it does so the

347
00:14:20,030 --> 00:14:23,900
first thing it does is it gets the

348
00:14:21,680 --> 00:14:25,550
pointer to you in size of a particular

349
00:14:23,900 --> 00:14:28,670
block of memory that represents a

350
00:14:25,550 --> 00:14:31,459
javascript array buffer one that's being

351
00:14:28,670 --> 00:14:32,930
passed in via the arguments head and it

352
00:14:31,460 --> 00:14:36,470
assigns those values to the local

353
00:14:32,930 --> 00:14:38,810
variables P buffer and buffer size after

354
00:14:36,470 --> 00:14:40,280
that this call to vote in may

355
00:14:38,810 --> 00:14:43,400
potentially run arbitrary JavaScript

356
00:14:40,280 --> 00:14:46,250
code because it uses the passed an

357
00:14:43,400 --> 00:14:47,870
object's value of method to calculate

358
00:14:46,250 --> 00:14:49,390
the value and I'll explain that a little

359
00:14:47,870 --> 00:14:52,000
bit more in a bit

360
00:14:49,390 --> 00:14:55,400
but with this you could potentially

361
00:14:52,000 --> 00:14:57,260
override this value of method to free

362
00:14:55,400 --> 00:14:59,360
the buffer and then when this code

363
00:14:57,260 --> 00:15:01,550
returns P buffer would be a dangling

364
00:14:59,360 --> 00:15:03,680
pointer so at this point we don't know

365
00:15:01,550 --> 00:15:07,790
what buffer size or P buffer actually is

366
00:15:03,680 --> 00:15:09,439
at all and when you then need to try to

367
00:15:07,790 --> 00:15:12,650
use it to perform an operation for

368
00:15:09,440 --> 00:15:15,830
example looping over the array you could

369
00:15:12,650 --> 00:15:17,030
have undefined behavior because you

370
00:15:15,830 --> 00:15:18,650
could under encounter a memory

371
00:15:17,030 --> 00:15:21,890
corruption or something worse maybe like

372
00:15:18,650 --> 00:15:24,560
a remote code execution vulnerability

373
00:15:21,890 --> 00:15:26,300
and the the JavaScript exploit looks a

374
00:15:24,560 --> 00:15:28,160
little bit something like this and in

375
00:15:26,300 --> 00:15:32,719
particular they've overwritten this

376
00:15:28,160 --> 00:15:34,399
value of method two then free the buffer

377
00:15:32,720 --> 00:15:36,740
effectively and this is all illustrative

378
00:15:34,399 --> 00:15:40,360
code this isn't actually a likely IC but

379
00:15:36,740 --> 00:15:42,890
it's taken from the blog post so

380
00:15:40,360 --> 00:15:45,170
Microsoft assessed this vulnerability is

381
00:15:42,890 --> 00:15:46,880
critical and they wanted to know whether

382
00:15:45,170 --> 00:15:50,870
they had any similar mistakes to this

383
00:15:46,880 --> 00:15:52,459
anywhere else in the chakra code so as

384
00:15:50,870 --> 00:15:55,399
you could expect they wrote a query or a

385
00:15:52,459 --> 00:15:57,649
check that describes this the pattern of

386
00:15:55,399 --> 00:16:00,350
assigning a pointer of an array buffer

387
00:15:57,649 --> 00:16:02,269
to a variable then calling JavaScript

388
00:16:00,350 --> 00:16:06,140
code and then trying to use those

389
00:16:02,269 --> 00:16:09,110
variables and this is more or less what

390
00:16:06,140 --> 00:16:10,880
the query looked like I've modified it a

391
00:16:09,110 --> 00:16:12,380
little bit here to fit into into one

392
00:16:10,880 --> 00:16:14,510
slide and all I'll go through it and

393
00:16:12,380 --> 00:16:16,820
explain it but for anyone that's used a

394
00:16:14,510 --> 00:16:20,149
database query language like SQL you'll

395
00:16:16,820 --> 00:16:21,829
see pretty familiar concepts here we

396
00:16:20,149 --> 00:16:23,120
have a from clause that lists all the

397
00:16:21,829 --> 00:16:25,670
relations that were interested in

398
00:16:23,120 --> 00:16:28,850
looking at and so in this case we're

399
00:16:25,670 --> 00:16:31,300
looking at variables assignments of

400
00:16:28,850 --> 00:16:34,279
array buffer point array buffer pointers

401
00:16:31,300 --> 00:16:35,810
function calls and accesses to variables

402
00:16:34,279 --> 00:16:38,870
which is either something that's a read

403
00:16:35,810 --> 00:16:40,339
or a write we then have a where clause

404
00:16:38,870 --> 00:16:43,550
that lists some conditions that need to

405
00:16:40,339 --> 00:16:44,810
be satisfied and we have a select that

406
00:16:43,550 --> 00:16:47,560
lists all the columns that we want to

407
00:16:44,810 --> 00:16:50,329
output jumping into the where condition

408
00:16:47,560 --> 00:16:52,518
this line ensures that the pointer

409
00:16:50,329 --> 00:16:54,529
assignment and the variable use are

410
00:16:52,519 --> 00:16:56,720
talking about the same variable so in

411
00:16:54,529 --> 00:16:57,890
our example code here it's checking that

412
00:16:56,720 --> 00:17:02,390
they're both talking about the same

413
00:16:57,890 --> 00:17:04,760
variable P buffer this line ensures that

414
00:17:02,390 --> 00:17:06,740
the function call is to a function that

415
00:17:04,760 --> 00:17:10,369
may potentially execute JavaScript code

416
00:17:06,740 --> 00:17:12,319
now rather than enumerate in every

417
00:17:10,369 --> 00:17:15,168
single such function in the chakra code

418
00:17:12,319 --> 00:17:17,089
you can imagine this quite a few the

419
00:17:15,169 --> 00:17:19,250
security researchers knew that any code

420
00:17:17,089 --> 00:17:22,309
that calls back into JavaScript

421
00:17:19,250 --> 00:17:25,250
eventually calls this method or a calls

422
00:17:22,309 --> 00:17:28,220
a function method called a primitive so

423
00:17:25,250 --> 00:17:31,580
rather than saying so they could simply

424
00:17:28,220 --> 00:17:33,800
say an e they could use a call graph to

425
00:17:31,580 --> 00:17:35,629
say anything that may eventually or

426
00:17:33,800 --> 00:17:38,178
transitively call this function

427
00:17:35,630 --> 00:17:39,740
is something that we care about so they

428
00:17:38,179 --> 00:17:41,299
might call method called the primitive

429
00:17:39,740 --> 00:17:42,770
directly or they might call a function

430
00:17:41,299 --> 00:17:44,299
the calls method called a primitive or

431
00:17:42,770 --> 00:17:45,320
they might call a function that calls a

432
00:17:44,299 --> 00:17:47,090
function that calls method called a

433
00:17:45,320 --> 00:17:48,320
primitive and etc so that's what's

434
00:17:47,090 --> 00:17:50,389
expressed here and if you want me to

435
00:17:48,320 --> 00:17:53,110
explain that in more detail you can of

436
00:17:50,390 --> 00:17:55,370
course us ask me after the presentation

437
00:17:53,110 --> 00:17:57,229
so that's that's this function here

438
00:17:55,370 --> 00:18:00,020
ensuring that this might potentially

439
00:17:57,230 --> 00:18:02,750
execute JavaScript and then the last two

440
00:18:00,020 --> 00:18:04,490
causes this one says that the call to

441
00:18:02,750 --> 00:18:07,370
JavaScript happens after you assign the

442
00:18:04,490 --> 00:18:10,130
value to the variable so that happens

443
00:18:07,370 --> 00:18:13,580
first and then the call and this next

444
00:18:10,130 --> 00:18:15,140
one says that the use of the point of

445
00:18:13,580 --> 00:18:17,178
the use of the variable happens after

446
00:18:15,140 --> 00:18:21,950
the call to JavaScript code so it

447
00:18:17,179 --> 00:18:24,650
ensures that now in this Microsoft blog

448
00:18:21,950 --> 00:18:26,480
post Stephen hunter said that this query

449
00:18:24,650 --> 00:18:29,690
in addition to matching the original

450
00:18:26,480 --> 00:18:32,360
vulnerability that they were using as a

451
00:18:29,690 --> 00:18:33,799
seed it found four additional variants

452
00:18:32,360 --> 00:18:36,740
that they also assessed as having

453
00:18:33,799 --> 00:18:38,809
critical vulnerable critical severity so

454
00:18:36,740 --> 00:18:40,429
they were able to not find just one

455
00:18:38,809 --> 00:18:45,320
vulnerability but find five at the same

456
00:18:40,429 --> 00:18:47,299
time so that example was very specific

457
00:18:45,320 --> 00:18:49,490
to the chakra codebase but there are

458
00:18:47,299 --> 00:18:52,820
many kinds of mistakes that are a lot

459
00:18:49,490 --> 00:18:54,260
more general for example something

460
00:18:52,820 --> 00:18:56,270
that's a misuse of a particular language

461
00:18:54,260 --> 00:18:58,039
feature or mistakes that are commonly

462
00:18:56,270 --> 00:19:00,620
made with certain api's or frameworks

463
00:18:58,039 --> 00:19:02,270
and in those cases you can actually go a

464
00:19:00,620 --> 00:19:04,820
step further and rather than just

465
00:19:02,270 --> 00:19:07,730
running on your own code you can make

466
00:19:04,820 --> 00:19:09,230
your checks open-source and freely

467
00:19:07,730 --> 00:19:14,870
available share them with the world so

468
00:19:09,230 --> 00:19:16,039
that anyone else that has a code in that

469
00:19:14,870 --> 00:19:17,600
same language or uses that same

470
00:19:16,039 --> 00:19:19,309
framework can benefit from your tract

471
00:19:17,600 --> 00:19:22,340
and a sure they don't make the same sort

472
00:19:19,309 --> 00:19:24,080
of mistake and beyond that

473
00:19:22,340 --> 00:19:25,550
you can also take advantage of the

474
00:19:24,080 --> 00:19:27,320
queries and checks that other security

475
00:19:25,550 --> 00:19:29,899
teams open-sourcing especially if you're

476
00:19:27,320 --> 00:19:31,429
running anything continuously and just

477
00:19:29,900 --> 00:19:32,540
keep adding these queries to your checks

478
00:19:31,430 --> 00:19:36,980
so that you will find everything that

479
00:19:32,540 --> 00:19:38,120
you need to so let's have a slightly

480
00:19:36,980 --> 00:19:38,990
different story now to sort of

481
00:19:38,120 --> 00:19:43,969
illustrate this

482
00:19:38,990 --> 00:19:47,300
who here is head of zip slip okay cool I

483
00:19:43,970 --> 00:19:51,850
get to explain it so like cool cool

484
00:19:47,300 --> 00:19:55,010
vulnerabilities this one had a logo so

485
00:19:51,850 --> 00:19:57,350
this was a really discovered by snick

486
00:19:55,010 --> 00:20:00,530
and they did a blog post about it and

487
00:19:57,350 --> 00:20:06,949
I'm gonna explain exactly why it's

488
00:20:00,530 --> 00:20:08,930
important in a sec so to understand this

489
00:20:06,950 --> 00:20:10,640
vulnerability the first thing you need

490
00:20:08,930 --> 00:20:12,890
to do is understand exactly how zip

491
00:20:10,640 --> 00:20:15,140
files are structured so you may think

492
00:20:12,890 --> 00:20:17,390
that because they are usually contain

493
00:20:15,140 --> 00:20:19,850
directories of files that there might be

494
00:20:17,390 --> 00:20:21,620
some sort of tree like structure however

495
00:20:19,850 --> 00:20:25,070
zip files are simply lists of entries

496
00:20:21,620 --> 00:20:27,020
and that include the metadata the name

497
00:20:25,070 --> 00:20:31,159
or path of the file and the data

498
00:20:27,020 --> 00:20:34,550
themselves and notably here the path is

499
00:20:31,160 --> 00:20:35,780
just a string that might contain slashes

500
00:20:34,550 --> 00:20:39,260
in it which will indicate when

501
00:20:35,780 --> 00:20:40,820
something's on a certain directory now

502
00:20:39,260 --> 00:20:42,890
you might think hmm

503
00:20:40,820 --> 00:20:45,590
could I put arbitrary strings in the

504
00:20:42,890 --> 00:20:50,120
file paths here and you would be right

505
00:20:45,590 --> 00:20:51,649
and snick realized this and thought I

506
00:20:50,120 --> 00:20:53,899
wonder if anyone is just joining these

507
00:20:51,650 --> 00:20:55,310
strings onto the end of target directory

508
00:20:53,900 --> 00:20:58,490
is when they're writing unzipping code

509
00:20:55,310 --> 00:20:59,870
and it turns out that yes this was

510
00:20:58,490 --> 00:21:01,910
happening everywhere in every single

511
00:20:59,870 --> 00:21:06,260
programming language there are dozens of

512
00:21:01,910 --> 00:21:09,710
projects that are writing unzipping code

513
00:21:06,260 --> 00:21:12,110
that just joins the path on to at the

514
00:21:09,710 --> 00:21:15,200
end of a target directory so you could

515
00:21:12,110 --> 00:21:18,229
potentially create strings like this and

516
00:21:15,200 --> 00:21:21,250
if you know you're running a particular

517
00:21:18,230 --> 00:21:24,050
application as root you might be able to

518
00:21:21,250 --> 00:21:25,970
simply by trying to unzip a file you

519
00:21:24,050 --> 00:21:29,389
might be able to override the crontab

520
00:21:25,970 --> 00:21:30,290
and get remote code execution or even if

521
00:21:29,390 --> 00:21:31,220
you're not running as root you could

522
00:21:30,290 --> 00:21:33,710
still probably get remote code execution

523
00:21:31,220 --> 00:21:34,809
by overwriting the bash profile stuff

524
00:21:33,710 --> 00:21:39,340
like that

525
00:21:34,809 --> 00:21:41,980
so here's some example Java code of

526
00:21:39,340 --> 00:21:45,020
insecure unzipping which is

527
00:21:41,980 --> 00:21:46,370
understandably this sort of code is is

528
00:21:45,020 --> 00:21:47,809
everywhere whenever you look over Stack

529
00:21:46,370 --> 00:21:51,370
Overflow this is the correct way to

530
00:21:47,809 --> 00:21:53,570
unzip files and Java except this line is

531
00:21:51,370 --> 00:21:56,840
particularly problematic because it is

532
00:21:53,570 --> 00:22:00,918
destroying the path of a zip entry to

533
00:21:56,840 --> 00:22:02,149
the destination and the fix for most

534
00:22:00,919 --> 00:22:04,309
programming languages if you're writing

535
00:22:02,150 --> 00:22:06,230
on zipping code is only usually a couple

536
00:22:04,309 --> 00:22:08,600
of lines here it simply checks that when

537
00:22:06,230 --> 00:22:10,970
you normalize the path and collapse all

538
00:22:08,600 --> 00:22:13,189
of the path traversal elements that it's

539
00:22:10,970 --> 00:22:15,830
still within the target direct destined

540
00:22:13,190 --> 00:22:17,390
directory and hasn't actually isn't

541
00:22:15,830 --> 00:22:23,418
trying to unzip it to anywhere outside

542
00:22:17,390 --> 00:22:25,790
of that so when snick published this

543
00:22:23,419 --> 00:22:27,140
vulnerability Microsoft caught wind of

544
00:22:25,790 --> 00:22:30,110
it and they wanted to know if they were

545
00:22:27,140 --> 00:22:33,070
making any sort of mistake similar to

546
00:22:30,110 --> 00:22:36,229
this elsewhere or anywhere in their code

547
00:22:33,070 --> 00:22:38,840
so they wrote a query to search for this

548
00:22:36,230 --> 00:22:41,210
pattern and this particular query was

549
00:22:38,840 --> 00:22:44,059
for their c-sharp code and it looks for

550
00:22:41,210 --> 00:22:47,000
data flowing from a zip entry path to

551
00:22:44,059 --> 00:22:49,668
any i/o operation without some sort of

552
00:22:47,000 --> 00:22:51,410
sanitization along the way so they ran

553
00:22:49,669 --> 00:22:53,870
it across the code found a number of

554
00:22:51,410 --> 00:22:55,340
results fixed it but then the next thing

555
00:22:53,870 --> 00:22:58,100
they did was they open sourced it so

556
00:22:55,340 --> 00:23:00,290
that other people can take advantage of

557
00:22:58,100 --> 00:23:03,620
that now whoo raise your hand if you

558
00:23:00,290 --> 00:23:05,450
write any c-sharp code call as three

559
00:23:03,620 --> 00:23:08,540
people four people in the audience of

560
00:23:05,450 --> 00:23:10,820
the do well so there's a c-sharp query

561
00:23:08,540 --> 00:23:13,428
that you can use freely available for

562
00:23:10,820 --> 00:23:16,610
you to use that will check for this sort

563
00:23:13,429 --> 00:23:18,470
of vulnerability and my company also

564
00:23:16,610 --> 00:23:19,850
went ahead and wrote similar queries and

565
00:23:18,470 --> 00:23:21,740
four different programming languages so

566
00:23:19,850 --> 00:23:25,549
you can probably find automated checks

567
00:23:21,740 --> 00:23:31,640
online for your stack to find this sort

568
00:23:25,549 --> 00:23:33,980
of vulnerability so you might at this

569
00:23:31,640 --> 00:23:36,200
point potentially be interested in if

570
00:23:33,980 --> 00:23:38,630
you can use variant analysis yourself if

571
00:23:36,200 --> 00:23:44,179
it makes sense for your company and if

572
00:23:38,630 --> 00:23:45,270
not then I need to improve this talk and

573
00:23:44,179 --> 00:23:48,750
that I'm going to assume that you do

574
00:23:45,270 --> 00:23:50,220
and I'm also for now going to assume

575
00:23:48,750 --> 00:23:51,690
that you already have some sort of

576
00:23:50,220 --> 00:23:53,130
workflow in place for dealing with

577
00:23:51,690 --> 00:23:56,280
vulnerabilities that you find in your

578
00:23:53,130 --> 00:24:00,300
own software if you don't we'll briefly

579
00:23:56,280 --> 00:24:01,740
talk rather in the next slide so let's

580
00:24:00,300 --> 00:24:02,879
assume you have you have a workflow in

581
00:24:01,740 --> 00:24:04,980
place it probably looks something like

582
00:24:02,880 --> 00:24:07,620
this you receive information about a

583
00:24:04,980 --> 00:24:10,110
security bug it might be through a bug

584
00:24:07,620 --> 00:24:12,030
bounty or pentesting or code agree

585
00:24:10,110 --> 00:24:14,129
something like that you diagnose a root

586
00:24:12,030 --> 00:24:15,870
cause to investigate what's wrong fix

587
00:24:14,130 --> 00:24:19,140
the problem and publish a patch to your

588
00:24:15,870 --> 00:24:21,810
users well the the most obvious place

589
00:24:19,140 --> 00:24:23,640
for for something like that analysis to

590
00:24:21,810 --> 00:24:28,080
fit in would be as additional steps

591
00:24:23,640 --> 00:24:29,160
after you diagnose the root cause so

592
00:24:28,080 --> 00:24:30,960
firstly what you would do is you would

593
00:24:29,160 --> 00:24:32,760
describe the mistake as a check or a

594
00:24:30,960 --> 00:24:38,300
query in whatever tooling that you're

595
00:24:32,760 --> 00:24:38,300
using be a client ID or anything else

596
00:24:38,600 --> 00:24:42,449
you would then run this query against

597
00:24:40,950 --> 00:24:44,670
your codebase to see what results you

598
00:24:42,450 --> 00:24:46,260
get now to begin with you'll probably

599
00:24:44,670 --> 00:24:47,640
end up with a whole bunch of false

600
00:24:46,260 --> 00:24:49,680
positives because there'll be things you

601
00:24:47,640 --> 00:24:51,030
didn't account for reasons that mean

602
00:24:49,680 --> 00:24:53,280
that the code isn't actually vulnerable

603
00:24:51,030 --> 00:24:55,440
and so you have a bit of an iterative

604
00:24:53,280 --> 00:24:57,389
process you improve the query you reduce

605
00:24:55,440 --> 00:24:58,890
the false positives until the results

606
00:24:57,390 --> 00:25:01,140
are small enough that you can kind of

607
00:24:58,890 --> 00:25:03,600
try add your manually and go through and

608
00:25:01,140 --> 00:25:05,010
make sure that your make I'll check

609
00:25:03,600 --> 00:25:08,399
whether each particular bit is

610
00:25:05,010 --> 00:25:10,250
vulnerable at that point you can fix all

611
00:25:08,400 --> 00:25:13,260
of these variants at the same time and

612
00:25:10,250 --> 00:25:15,030
at that point you actually then deploy

613
00:25:13,260 --> 00:25:16,440
the fix to your users so that there

614
00:25:15,030 --> 00:25:21,389
isn't an opportunity to for other people

615
00:25:16,440 --> 00:25:22,950
to find those variants before you beyond

616
00:25:21,390 --> 00:25:25,440
that now that the query is actually

617
00:25:22,950 --> 00:25:28,800
written you could potentially run it on

618
00:25:25,440 --> 00:25:30,930
a regular basis monitoring continuously

619
00:25:28,800 --> 00:25:32,100
potentially is a nightly thing or maybe

620
00:25:30,930 --> 00:25:33,690
you could even integrate it into your

621
00:25:32,100 --> 00:25:38,520
code review system for your developers

622
00:25:33,690 --> 00:25:39,810
and for example if you've if you find

623
00:25:38,520 --> 00:25:42,360
any code review you can then discover

624
00:25:39,810 --> 00:25:43,980
these variants before the code has even

625
00:25:42,360 --> 00:25:47,610
been merged and fix it

626
00:25:43,980 --> 00:25:49,080
right than in that and this is

627
00:25:47,610 --> 00:25:50,790
effectively what Mozilla are doing with

628
00:25:49,080 --> 00:25:54,780
clanked ID with their customer also that

629
00:25:50,790 --> 00:25:55,889
they ring so beyond this like I

630
00:25:54,780 --> 00:25:58,570
mentioned a minute ago

631
00:25:55,890 --> 00:26:00,460
the final ideal step would be to

632
00:25:58,570 --> 00:26:01,928
this query that you've written if it's

633
00:26:00,460 --> 00:26:04,299
general pubs are nothing it makes sense

634
00:26:01,929 --> 00:26:05,919
with everyone else open source and our

635
00:26:04,299 --> 00:26:09,789
other people to take advantage of it and

636
00:26:05,919 --> 00:26:11,289
then of course bring in the external

637
00:26:09,789 --> 00:26:13,929
knowledge from security teams from

638
00:26:11,289 --> 00:26:16,019
outside a company to also check for

639
00:26:13,929 --> 00:26:18,639
things that they've found in their code

640
00:26:16,019 --> 00:26:20,500
and with this whole process in place

641
00:26:18,639 --> 00:26:21,939
your software will probably have far

642
00:26:20,500 --> 00:26:24,720
fewer of vulnerabilities caused by

643
00:26:21,940 --> 00:26:26,679
repeated and easily preventable mistakes

644
00:26:24,720 --> 00:26:27,940
so what about for those of us that don't

645
00:26:26,679 --> 00:26:30,820
actually have a security response

646
00:26:27,940 --> 00:26:32,620
process for example or you might be part

647
00:26:30,820 --> 00:26:33,850
of a small software start-up or you

648
00:26:32,620 --> 00:26:37,209
might be working on a bunch of rapin

649
00:26:33,850 --> 00:26:39,639
source projects well the first thing to

650
00:26:37,210 --> 00:26:41,830
understand is that sooner or later if

651
00:26:39,639 --> 00:26:43,360
you're developing software you may very

652
00:26:41,830 --> 00:26:45,220
well be faced with a vulnerability you

653
00:26:43,360 --> 00:26:46,389
probably will be faced with the

654
00:26:45,220 --> 00:26:48,429
vulnerability that you need to deal with

655
00:26:46,389 --> 00:26:50,139
and it would be good to have an idea of

656
00:26:48,429 --> 00:26:52,299
exactly how you would go about dealing

657
00:26:50,139 --> 00:26:54,129
with that situation but in the meantime

658
00:26:52,299 --> 00:26:56,049
until you get your first vulnerability

659
00:26:54,129 --> 00:26:58,719
discovery I would highly recommend

660
00:26:56,049 --> 00:27:01,000
making some thought of or some sort of

661
00:26:58,720 --> 00:27:03,039
automated security checks part of your

662
00:27:01,000 --> 00:27:04,389
workflow just add all of the tools use

663
00:27:03,039 --> 00:27:06,158
all of them especially if they're freely

664
00:27:04,389 --> 00:27:10,029
available this there's no excuse really

665
00:27:06,159 --> 00:27:11,799
not to automatically analyze your pull

666
00:27:10,029 --> 00:27:13,840
requests for things that are well-known

667
00:27:11,799 --> 00:27:15,158
and talked about and take advantage of

668
00:27:13,840 --> 00:27:17,019
all this knowledge that's being shared

669
00:27:15,159 --> 00:27:21,580
by the expert security teams from all

670
00:27:17,019 --> 00:27:23,139
these large tech companies so I'm

671
00:27:21,580 --> 00:27:24,970
getting pretty close to the end of my

672
00:27:23,139 --> 00:27:27,370
presentation I'm kind of whizzing

673
00:27:24,970 --> 00:27:28,870
through it but before I close up I

674
00:27:27,370 --> 00:27:31,330
wanted to talk about a couple of things

675
00:27:28,870 --> 00:27:34,418
that variant analysis is not to

676
00:27:31,330 --> 00:27:36,908
alleviate any confusion so variant

677
00:27:34,419 --> 00:27:38,950
analysis is not a replacement to good

678
00:27:36,909 --> 00:27:40,120
software architecture if you're

679
00:27:38,950 --> 00:27:43,299
encountering lots of memory

680
00:27:40,120 --> 00:27:45,039
vulnerabilities I would still recommend

681
00:27:43,299 --> 00:27:48,129
migrating to rust if you're considering

682
00:27:45,039 --> 00:27:49,629
that if you're using expression

683
00:27:48,129 --> 00:27:54,250
languages like they were in Apache

684
00:27:49,629 --> 00:27:56,799
struts and spring maybe don't and if you

685
00:27:54,250 --> 00:27:59,470
have like SQL operations that you're

686
00:27:56,799 --> 00:28:01,330
doing perhaps I would I would consider

687
00:27:59,470 --> 00:28:02,850
using auto escaping database libraries

688
00:28:01,330 --> 00:28:06,210
to completely eliminate that sort of

689
00:28:02,850 --> 00:28:06,209
vulnerability entirely

690
00:28:06,220 --> 00:28:10,840
very Nasus is not a replacement to

691
00:28:08,379 --> 00:28:13,029
exploit mitigation things like address

692
00:28:10,840 --> 00:28:15,039
space layout randomization and stack

693
00:28:13,029 --> 00:28:18,100
Canaries are very very important things

694
00:28:15,039 --> 00:28:20,320
to reduce the damage that someone can do

695
00:28:18,100 --> 00:28:21,820
when a vulnerability is found every

696
00:28:20,320 --> 00:28:24,100
layer of security is important and it

697
00:28:21,820 --> 00:28:29,019
and using one is not an excuse to not

698
00:28:24,100 --> 00:28:30,639
use another and finally fairness is not

699
00:28:29,019 --> 00:28:32,799
a replacement to other security

700
00:28:30,639 --> 00:28:34,149
practices if for example you're doing

701
00:28:32,799 --> 00:28:35,769
fuzzing it actually complements that

702
00:28:34,149 --> 00:28:38,320
sort of thing very well you might find a

703
00:28:35,769 --> 00:28:40,360
bug through fuzzing and a certain sort

704
00:28:38,320 --> 00:28:41,830
of mistake you like mmm I wonder if this

705
00:28:40,360 --> 00:28:43,689
exists on URLs and then instead of

706
00:28:41,830 --> 00:28:46,449
finding one vulnerability you find five

707
00:28:43,690 --> 00:28:48,730
or ten it's also you know not a not a

708
00:28:46,450 --> 00:28:50,370
replacement for doing vulnerability

709
00:28:48,730 --> 00:28:52,629
disclosure of bug bounty programs or

710
00:28:50,370 --> 00:28:54,850
audits or pen testing or red team

711
00:28:52,629 --> 00:28:55,990
exercises etc all of these things I

712
00:28:54,850 --> 00:28:58,350
would highly recommend that everyone

713
00:28:55,990 --> 00:29:02,649
does if they're creating software

714
00:28:58,350 --> 00:29:04,678
because the more security checks and

715
00:29:02,649 --> 00:29:08,529
systems you haven't placed the pattern

716
00:29:04,679 --> 00:29:10,240
so at this point you might be interested

717
00:29:08,529 --> 00:29:12,129
okay you've told me very nice is pretty

718
00:29:10,240 --> 00:29:16,509
good and I want to know how I can

719
00:29:12,129 --> 00:29:18,100
actually start using it myself so I'll

720
00:29:16,509 --> 00:29:20,200
give you a couple of pointers and I'm

721
00:29:18,100 --> 00:29:23,590
not going to recommend the ease github

722
00:29:20,200 --> 00:29:25,720
software specifically for this that is a

723
00:29:23,590 --> 00:29:27,699
choice for you to make but I do want you

724
00:29:25,720 --> 00:29:29,080
to consider what very analysis could do

725
00:29:27,700 --> 00:29:31,659
for you and if this story that I've told

726
00:29:29,080 --> 00:29:33,549
today is something that makes sense to

727
00:29:31,659 --> 00:29:36,820
you and feel and you feel like it's

728
00:29:33,549 --> 00:29:39,340
actually affects you so hopefully with

729
00:29:36,820 --> 00:29:40,658
these ideas that I've given you you'll

730
00:29:39,340 --> 00:29:42,250
be able to reduce the amount of manual

731
00:29:40,659 --> 00:29:44,590
work you're doing and potentially

732
00:29:42,250 --> 00:29:46,690
improve the software security of your

733
00:29:44,590 --> 00:29:49,090
software so if you're writing or

734
00:29:46,690 --> 00:29:51,190
maintaining software look at what other

735
00:29:49,090 --> 00:29:52,689
tools other teams are using look at the

736
00:29:51,190 --> 00:29:55,000
large enterprises look at smaller teams

737
00:29:52,690 --> 00:29:58,059
and see what they're blogging about see

738
00:29:55,000 --> 00:30:00,940
what they like and then try out a bunch

739
00:29:58,059 --> 00:30:03,220
see what lands and works for you you

740
00:30:00,940 --> 00:30:05,649
might find that certain tools make more

741
00:30:03,220 --> 00:30:07,330
sense than others and but they probably

742
00:30:05,649 --> 00:30:10,330
will fit into your workflow in a similar

743
00:30:07,330 --> 00:30:13,199
way and if you're a blue team owner a

744
00:30:10,330 --> 00:30:15,519
Security Response or security researcher

745
00:30:13,200 --> 00:30:16,840
experiment writing checks for

746
00:30:15,519 --> 00:30:18,730
vulnerabilities you found in the past

747
00:30:16,840 --> 00:30:19,990
using different tools see what feels

748
00:30:18,730 --> 00:30:21,730
easy what actually

749
00:30:19,990 --> 00:30:23,260
improves your workflow is there anything

750
00:30:21,730 --> 00:30:24,700
that allows you to get a bunch more bug

751
00:30:23,260 --> 00:30:26,860
bounties because you found many more

752
00:30:24,700 --> 00:30:28,480
vulnerabilities and you know there's a

753
00:30:26,860 --> 00:30:30,428
whole bunch of blog posts out there by

754
00:30:28,480 --> 00:30:33,220
many different security researchers

755
00:30:30,429 --> 00:30:34,720
doing versus at the moment say go hunt

756
00:30:33,220 --> 00:30:35,610
those out and see see what everyone's

757
00:30:34,720 --> 00:30:38,650
saying

758
00:30:35,610 --> 00:30:41,439
so to recap you should do variant

759
00:30:38,650 --> 00:30:44,830
analysis but you should do automated

760
00:30:41,440 --> 00:30:47,500
Verint analysis you can use and

761
00:30:44,830 --> 00:30:50,139
contribute to the shared knowledge and

762
00:30:47,500 --> 00:30:52,450
checks that this all open source that

763
00:30:50,140 --> 00:30:55,870
exists up there in whichever tools you

764
00:30:52,450 --> 00:30:57,820
prefer check should be run continuously

765
00:30:55,870 --> 00:30:59,320
not once off mistakes that are made in

766
00:30:57,820 --> 00:31:00,428
the past are very likely to be repeated

767
00:30:59,320 --> 00:31:03,490
in the future so you want to protect

768
00:31:00,429 --> 00:31:05,440
against those as well and then finally

769
00:31:03,490 --> 00:31:07,900
variant analysis is a process that

770
00:31:05,440 --> 00:31:11,290
complements and doesn't replace other

771
00:31:07,900 --> 00:31:12,550
security practices don't use it as an

772
00:31:11,290 --> 00:31:17,020
excuse not to do other things you should

773
00:31:12,550 --> 00:31:17,830
do everything ideally all right that's

774
00:31:17,020 --> 00:31:20,520
all I've got

775
00:31:17,830 --> 00:31:20,520
thank you

776
00:31:25,100 --> 00:31:31,199
welcome questions okay so can you please

777
00:31:29,880 --> 00:31:39,420
raise your hand so I can give you the

778
00:31:31,200 --> 00:31:41,460
mic thank you

779
00:31:39,420 --> 00:31:44,100
how is variant analysis different from

780
00:31:41,460 --> 00:31:48,810
sassed and writing your own custom rules

781
00:31:44,100 --> 00:31:50,909
for fast it's not it's it's a process

782
00:31:48,810 --> 00:31:54,290
run SAS would be one of the tools that

783
00:31:50,910 --> 00:31:54,290
would allow you to do variant analysis

784
00:31:56,210 --> 00:32:02,940
so it describes more is this morning for

785
00:32:00,180 --> 00:32:06,320
the process rather than a name for a

786
00:32:02,940 --> 00:32:08,760
particular capability of a toolset so

787
00:32:06,320 --> 00:32:10,110
the idea is that you want to embed it as

788
00:32:08,760 --> 00:32:12,810
part of your Security Response process

789
00:32:10,110 --> 00:32:15,959
it's not simply enough most people that

790
00:32:12,810 --> 00:32:17,399
use SAS as far as I have seen an

791
00:32:15,960 --> 00:32:18,720
experience they mostly sort of do as a

792
00:32:17,400 --> 00:32:20,160
set and forget thing it's not something

793
00:32:18,720 --> 00:32:22,020
that you're usually actively

794
00:32:20,160 --> 00:32:23,760
contributing to and configuring most

795
00:32:22,020 --> 00:32:25,110
people serve like cool I've gots asked

796
00:32:23,760 --> 00:32:26,850
my developers are getting reports

797
00:32:25,110 --> 00:32:28,800
they're either fixing them or not or

798
00:32:26,850 --> 00:32:31,050
whatever it's it's it's not that often

799
00:32:28,800 --> 00:32:32,700
the case or it hasn't been that often

800
00:32:31,050 --> 00:32:34,800
the case until more and more recently

801
00:32:32,700 --> 00:32:37,010
that people are actually configuring SAS

802
00:32:34,800 --> 00:32:39,629
to find more and more things and

803
00:32:37,010 --> 00:32:41,129
certainly not for every single

804
00:32:39,630 --> 00:32:50,070
vulnerability that they're experiencing

805
00:32:41,130 --> 00:32:52,320
which is which is the key thing here how

806
00:32:50,070 --> 00:32:57,679
how do I get us started with this type

807
00:32:52,320 --> 00:32:59,720
of approach without paying your company

808
00:32:57,680 --> 00:33:02,220
good question

809
00:32:59,720 --> 00:33:07,050
so if you want to get started playing

810
00:33:02,220 --> 00:33:10,080
around if you only use my companies in

811
00:33:07,050 --> 00:33:11,280
particular and it's a free free

812
00:33:10,080 --> 00:33:13,679
open-source project so you can play

813
00:33:11,280 --> 00:33:16,530
around with using it for open source

814
00:33:13,680 --> 00:33:17,580
code if you don't want to pay us but you

815
00:33:16,530 --> 00:33:21,090
want to play around with proprietary

816
00:33:17,580 --> 00:33:22,500
code then you can run a POC and for

817
00:33:21,090 --> 00:33:24,990
other tools I would just recommend using

818
00:33:22,500 --> 00:33:27,150
whatever their process is so there are

819
00:33:24,990 --> 00:33:28,140
other commercial tools that have that

820
00:33:27,150 --> 00:33:29,520
you can then go through their trial

821
00:33:28,140 --> 00:33:31,110
process and there are tools like you

822
00:33:29,520 --> 00:33:32,730
know clang tidy and Continental and you

823
00:33:31,110 --> 00:33:33,990
can just that open source and you can

824
00:33:32,730 --> 00:33:35,820
just play around with them for free so

825
00:33:33,990 --> 00:33:37,230
does that answer your question

826
00:33:35,820 --> 00:33:42,600
No

827
00:33:37,230 --> 00:33:42,600
if you can AskMe most of others

828
00:33:42,720 --> 00:33:48,840
anything else all right thank you

