1
00:00:00,000 --> 00:00:04,250
welcome to the last talk this evening

2
00:00:04,250 --> 00:00:08,130
which is very important even though

3
00:00:08,130 --> 00:00:10,440
many of you have probably already

4
00:00:10,440 --> 00:00:13,860
heard this topic and it is important

5
00:00:13,860 --> 00:00:16,289
for an educational problem

6
00:00:16,289 --> 00:00:19,500
because cyber security is now increasingly complex

7
00:00:19,500 --> 00:00:23,400
and perhaps a learning path is missing for new recruits

8
00:00:23,400 --> 00:00:26,340
from the basics

9
00:00:26,340 --> 00:00:28,080
up to the more complex things

10
00:00:28,080 --> 00:00:31,320
so we are here to study to

11
00:00:31,320 --> 00:00:34,530
learn new things and to brush up on

12
00:00:34,530 --> 00:00:35,340
just

13
00:00:35,340 --> 00:00:38,670
right then I leave the floor to

14
00:00:38,670 --> 00:00:43,170
fabriano z who attends the card the

15
00:00:43,170 --> 00:00:50,660
very first editions good talk thanks

16
00:00:54,980 --> 00:00:57,270
then what he actually

17
00:00:57,270 --> 00:01:00,180
said is that what  we will see

18
00:01:00,180 --> 00:01:02,370
this evening is one of

19
00:01:02,370 --> 00:01:04,650
the oldest attacks in quotation marks

20
00:01:04,650 --> 00:01:06,540
but nowadays it is still one of the

21
00:01:06,540 --> 00:01:11,610
most functional because in other words

22
00:01:11,610 --> 00:01:13,409
90 percent for amateurs cannot

23
00:01:13,409 --> 00:01:15,619
program

24
00:01:16,460 --> 00:01:18,630
then there is a 10 percent who knows how to

25
00:01:18,630 --> 00:01:19,710
program but  does not want to

26
00:01:19,710 --> 00:01:21,630
program indeed 9 percent

27
00:01:21,630 --> 00:01:23,580
will not be a percent who more or less

28
00:01:23,580 --> 00:01:25,530
knows how to program and can do it well

29
00:01:25,530 --> 00:01:27,840
but they are all  you in open sd for various

30
00:01:27,840 --> 00:01:28,229
reasons

31
00:01:28,229 --> 00:01:36,840
kurtz then what we will see now is

32
00:01:36,840 --> 00:01:41,090
an attack that I really like that is I

33
00:01:41,090 --> 00:01:43,439
all types of attack that I have seen

34
00:01:43,439 --> 00:01:48,270
this is what the two the

35
00:01:48,270 --> 00:01:51,090
network point of view I like the made man in

36
00:01:51,090 --> 00:01:51,659
the middle

37
00:01:51,659 --> 00:01:53,939
from the point of view and the attack on the

38
00:01:53,939 --> 00:01:56,250
software this is what I

39
00:01:56,250 --> 00:01:56,579


40
00:01:56,579 --> 00:01:59,310
like best because it is a set of

41
00:01:59,310 --> 00:02:01,280
techniques in the

42
00:02:01,280 --> 00:02:03,119
meantime you need to know the

43
00:02:03,119 --> 00:02:05,070
machine language and machine language it is not

44
00:02:05,070 --> 00:02:07,710
easily reproducible you need to know a little bit

45
00:02:07,710 --> 00:02:09,780
about how the processors work and

46
00:02:09,780 --> 00:02:11,530
therefore it is a

47
00:02:11,530 --> 00:02:14,660
you must also know the c so it is

48
00:02:14,660 --> 00:02:17,000
quite complex from the point of view

49
00:02:17,000 --> 00:02:19,430
however for someone who wants to waste

50
00:02:19,430 --> 00:02:21,740
time it is very suitable in the sense that you

51
00:02:21,740 --> 00:02:24,050
learn many things

52
00:02:24,050 --> 00:02:26,840
so I will david you or we tell the

53
00:02:26,840 --> 00:02:29,210
basic idea of how it works  for you those who

54
00:02:29,210 --> 00:02:31,820
want to develop think use their

55
00:02:31,820 --> 00:02:34,370
heads over because finding things already

56
00:02:34,370 --> 00:02:38,870
done on the internet is easy but does not help

57
00:02:38,870 --> 00:02:43,940
much to understand things unfortunately there is

58
00:02:43,940 --> 00:02:46,250
no evil

59
00:02:46,250 --> 00:02:49,160
in substance anyway  za what is the I call it boffo but it

60
00:02:49,160 --> 00:02:57,620
is buffer overflow in essence you go to

61
00:02:57,620 --> 00:03:02,110
dirty the stack to be able to

62
00:03:02,110 --> 00:03:05,480
modify the program that is to

63
00:03:05,480 --> 00:03:07,610
redirect the flow of the program to

64
00:03:07,610 --> 00:03:12,320
another part gets dirty on the stack

65
00:03:12,320 --> 00:03:13,820
because the person who made the

66
00:03:13,820 --> 00:03:18,440
program  he did not consider that is he did not

67
00:03:18,440 --> 00:03:21,800
program well ea and he forgot

68
00:03:21,800 --> 00:03:28,240
to remember that for any reason

69
00:03:28,240 --> 00:03:30,710
the lengths of the strings or the

70
00:03:30,710 --> 00:03:33,770
lengths must be well defined they

71
00:03:33,770 --> 00:03:36,680
must not go beyond the extent of

72
00:03:36,680 --> 00:03:38,360
what was then allocated I give

73
00:03:38,360 --> 00:03:40,040
an example if I say a  16

74
00:03:40,040 --> 00:03:42,080
character variable you have to check that there are

75
00:03:42,080 --> 00:03:44,380
16 in any way before

76
00:03:44,380 --> 00:03:47,420
fir is allocated before it is assigned

77
00:03:47,420 --> 00:03:49,430
that value to the variable otherwise

78
00:03:49,430 --> 00:03:55,670
it goes pretty much beyond what it

79
00:03:55,670 --> 00:03:59,650
has to go and goes to dirty the stack

80
00:03:59,650 --> 00:04:02,600
inside to explain it in a simple way

81
00:04:02,600 --> 00:04:04,280
because it knows  we don't need to be here for

82
00:04:04,280 --> 00:04:05,180
so long

83
00:04:05,180 --> 00:04:06,650
or if instead the program in c

84
00:04:06,650 --> 00:04:09,470
which basically has the

85
00:04:09,470 --> 00:04:11,420
program's man does nothing but do u  a

86
00:04:11,420 --> 00:04:12,860
request from paris has done what is

87
00:04:12,860 --> 00:04:14,270
required I pass it just to do

88
00:04:14,270 --> 00:04:17,839
something interesting it takes

89
00:04:17,839 --> 00:04:21,048
control of it takes what

90
00:04:21,048 --> 00:04:25,010
the user writes and prints

91
00:04:25,010 --> 00:04:29,940
basically the fine string leaves

92
00:04:29,940 --> 00:04:31,410
a bit of theory there would be

93
00:04:31,410 --> 00:04:33,150
password check if it passes and correct  the

94
00:04:33,150 --> 00:04:35,010
program in front bla bla bla i sonohra

95
00:04:35,010 --> 00:04:37,520
finish here

96
00:04:37,650 --> 00:04:39,540
the only thing the programmer admitted

97
00:04:39,540 --> 00:04:42,090
that the zynga of the easter becomes

98
00:04:42,090 --> 00:04:44,250
characters but he did not go to

99
00:04:44,250 --> 00:04:48,030
check so he you if you write 20 characters

100
00:04:48,030 --> 00:04:52,050
50 100 or three hundred he accepts everyone is

101
00:04:52,050 --> 00:04:53,850
clear enough here  of themes and

102
00:04:53,850 --> 00:04:56,640
stop so basically I have

103
00:04:56,640 --> 00:04:58,560
declared that buffer that what

104
00:04:58,560 --> 00:04:59,880
will count my step becomes

105
00:04:59,880 --> 00:05:02,100
characters but I did not then go to

106
00:05:02,100 --> 00:05:03,630
check it so I take green

107
00:05:03,630 --> 00:05:06,180
characters that is indeed I take everything

108
00:05:06,180 --> 00:05:07,890
that the person will pass me by

109
00:05:07,890 --> 00:05:13,080
writing that discourages  so what

110
00:05:13,080 --> 00:05:15,360
happens when we go to launch the

111
00:05:15,360 --> 00:05:17,930
program we compile it we basically launch it

112
00:05:17,930 --> 00:05:20,490
basically this is

113
00:05:20,490 --> 00:05:23,700
there  apart from where there is the program when

114
00:05:23,700 --> 00:05:25,890
a function is called so

115
00:05:25,890 --> 00:05:29,970
when we go to call the function

116
00:05:29,970 --> 00:05:33,960
of any type the function composed

117
00:05:33,960 --> 00:05:39,180
of parameters and values that we

118
00:05:39,180 --> 00:05:42,600
were not we do not go to insert them but the

119
00:05:42,600 --> 00:05:46,050
compiler lever insert which are the

120
00:05:46,050 --> 00:05:51,000
return  of the function to continue

121
00:05:51,000 --> 00:05:53,040
with the program I will explain better if I

122
00:05:53,040 --> 00:05:55,260
go to call a function and it passed a and

123
00:05:55,260 --> 00:05:58,830
b in the stack that grows down

124
00:05:58,830 --> 00:06:02,760
I will go the memory section will count the

125
00:06:02,760 --> 00:06:04,590
the variable v

126
00:06:04,590 --> 00:06:06,810
then the variable a and

127
00:06:06,810 --> 00:06:10,440
then there will be the return

128
00:06:10,440 --> 00:06:13,350
the address  return of the program to

129
00:06:13,350 --> 00:06:15,210
return to the point and continue the

130
00:06:15,210 --> 00:06:21,479
program there the variables have a

131
00:06:21,479 --> 00:06:23,580
well-defined memory space when

132
00:06:23,580 --> 00:06:25,830
you first wrote char buffer 20

133
00:06:25,830 --> 00:06:30,660
instances ra 20 memory locations

134
00:06:30,660 --> 00:06:32,310
for tears keep the password

135
00:06:32,310 --> 00:06:34,800
if you neither write 22 this

136
00:06:34,800 --> 00:06:37,240
overwrites  because

137
00:06:37,240 --> 00:06:39,699
the memory space that goes on the stack

138
00:06:39,699 --> 00:06:41,949
that I repeat grows

139
00:06:41,949 --> 00:06:44,560
downwards was

140
00:06:44,560 --> 00:06:47,110
allocated for 20 characters so there are 20

141
00:06:47,110 --> 00:06:49,509
memory cells occupied by if you

142
00:06:49,509 --> 00:06:53,699
go to write 22 this black over

143
00:06:56,400 --> 00:07:05,860
then what is it that when we go to

144
00:07:05,860 --> 00:07:08,949
call a program before going to

145
00:07:08,949 --> 00:07:13,630
see then the program is to be seen on the

146
00:07:13,630 --> 00:07:16,210
drawing first all these names what

147
00:07:16,210 --> 00:07:19,720
then mean the stack and what

148
00:07:19,720 --> 00:07:22,449
we say where the

149
00:07:22,449 --> 00:07:24,340
functions and variables are positioned and above all

150
00:07:24,340 --> 00:07:25,780
what interests us that

151
00:07:25,780 --> 00:07:27,819
the address of the return because the

152
00:07:27,819 --> 00:07:30,580
attack essentially overwrites this

153
00:07:30,580 --> 00:07:33,190
to make the program return no longer on

154
00:07:33,190 --> 00:07:35,169
the continuation of its  program but

155
00:07:35,169 --> 00:07:38,008
where we want

156
00:07:38,349 --> 00:07:40,599
and here there are two techniques one that

157
00:07:40,599 --> 00:07:42,070
calls a function that the one we

158
00:07:42,070 --> 00:07:44,830
will see now within the same

159
00:07:44,830 --> 00:07:47,380
program the other is to

160
00:07:47,380 --> 00:07:50,469
add some code that is the most difficult

161
00:07:50,469 --> 00:07:52,300
beyond the return vice and do  go

162
00:07:52,300 --> 00:07:53,979
the program beyond the

163
00:07:53,979 --> 00:07:55,630
return address of the stack always that is the

164
00:07:55,630 --> 00:07:58,180
software installed the program that you

165
00:07:58,180 --> 00:08:00,070
will make the machine language will go to

166
00:08:00,070 --> 00:08:02,289
fi  nire in the stack of course must

167
00:08:02,289 --> 00:08:05,949
be very small and usually it is

168
00:08:05,949 --> 00:08:09,610
called let's say a beige to throw

169
00:08:09,610 --> 00:08:15,219
something and so this is

170
00:08:15,219 --> 00:08:16,960
what we are interested in going to overwrite to

171
00:08:16,960 --> 00:08:22,389
understand where to overwrite the part of

172
00:08:22,389 --> 00:08:24,699
is the dynamic part where when we

173
00:08:24,699 --> 00:08:26,560
go to do  we send them takes a

174
00:08:26,560 --> 00:08:28,960
variable the oil I call

175
00:08:28,960 --> 00:08:31,780
dynamically the copper that is

176
00:08:31,780 --> 00:08:33,940
used and this as never

177
00:08:33,940 --> 00:08:35,770
seen before starts from the bottom and grows

178
00:08:35,770 --> 00:08:39,089
upwards access are the billag

179
00:08:39,089 --> 00:08:42,969
the global and static variables this is

180
00:08:42,969 --> 00:08:45,100
of a fixed position because the variables  and

181
00:08:45,100 --> 00:08:47,620
global and states that are instantiated

182
00:08:47,620 --> 00:08:49,089
immediately at the beginning of the program so

183
00:08:49,089 --> 00:08:50,649
he already knows how much space it occupies

184
00:08:50,649 --> 00:08:52,350
and therefore they were a fixed memory space

185
00:08:52,350 --> 00:08:59,829
the other the text is practically

186
00:08:59,829 --> 00:09:01,869
text is the part of the program so the

187
00:09:01,869 --> 00:09:06,389
code we have written compiled

188
00:09:08,850 --> 00:09:12,129
on the processor there are three registers that

189
00:09:12,129 --> 00:09:16,959
we are interested in knowing one is the

190
00:09:16,959 --> 00:09:19,929
pointer to the instruction this points to the

191
00:09:19,929 --> 00:09:21,220
next institution that must  be

192
00:09:21,220 --> 00:09:23,139
executed inside friend processor

193
00:09:23,139 --> 00:09:24,970
so when a program is going

194
00:09:24,970 --> 00:09:26,290
forward

195
00:09:26,290 --> 00:09:29,199
this here grows if the variable if a

196
00:09:29,199 --> 00:09:30,850
function I speak of assemblies at this

197
00:09:30,850 --> 00:09:33,579
moment is 3 bytes and the next is the

198
00:09:33,579 --> 00:09:36,300
fourth this will grow by four bytes

199
00:09:36,300 --> 00:09:39,189
the next discussion is a  no that

200
00:09:39,189 --> 00:09:40,990
there was one that cannot say that it does

201
00:09:40,990 --> 00:09:45,040
no operation for example spa points

202
00:09:45,040 --> 00:09:47,519
the last element inserted in the stack

203
00:09:47,519 --> 00:09:52,449
this point at the base of the stack

204
00:09:52,449 --> 00:09:54,040
at the beginning then this remains fixed

205
00:09:54,040 --> 00:09:59,410
the other grows as I said before if

206
00:09:59,410 --> 00:10:01,300
we have  this function is very simple

207
00:10:01,300 --> 00:10:04,149
where we pass two parameters so two

208
00:10:04,149 --> 00:10:10,389
integers substantially of the numbers 3 and 3

209
00:10:10,389 --> 00:10:11,199
this function does absolutely

210
00:10:11,199 --> 00:10:13,089
nothing because I am going to instantiate

211
00:10:13,089 --> 00:10:16,540
cie instantiate of and that's it if we

212
00:10:16,540 --> 00:10:19,269
go and see we pass 1 a and 2 to this

213
00:10:19,269 --> 00:10:20,649
function then we call this

214
00:10:20,649 --> 00:10:22,959
function with  a and 2 we will find in the meantime

215
00:10:22,959 --> 00:10:27,029
inverted the variables in the stack

216
00:10:27,029 --> 00:10:33,279
after which there is this that the

217
00:10:33,279 --> 00:10:34,779
return address

218
00:10:34,779 --> 00:10:36,610
substantially when i c  we have this

219
00:10:36,610 --> 00:10:40,629
this will return to the next code

220
00:10:40,629 --> 00:10:42,730
so if here there is a destruction canvas

221
00:10:42,730 --> 00:10:45,100
that at address 33 33

222
00:10:45,100 --> 00:10:48,490
this will count 33 33

223
00:10:48,490 --> 00:10:51,459
so what happens I step 21 and

224
00:10:51,459 --> 00:10:52,869
keep memory and the pro address where to

225
00:10:52,869 --> 00:10:53,819
return

226
00:10:53,819 --> 00:10:57,579
is basically a reminder to

227
00:10:57,579 --> 00:11:01,120
remember  where after we must go back what is

228
00:11:01,120 --> 00:11:03,970
that basically we are interested in

229
00:11:03,970 --> 00:11:05,560
going to overwrite this because if

230
00:11:05,560 --> 00:11:07,060
one has forgotten

231
00:11:07,060 --> 00:11:08,740
one of these variables and we can

232
00:11:08,740 --> 00:11:11,560
go, he has forgotten to adjust its

233
00:11:11,560 --> 00:11:13,389
length and we are able to

234
00:11:13,389 --> 00:11:14,800
overwrite then to go and

235
00:11:14,800 --> 00:11:17,350
write more data  this at some

236
00:11:17,350 --> 00:11:18,990
point going to overwrite this

237
00:11:18,990 --> 00:11:21,490
in most cases of when

238
00:11:21,490 --> 00:11:22,990
this happens without you

239
00:11:22,990 --> 00:11:26,500
noticing it happens that the program

240
00:11:26,500 --> 00:11:28,899
grows because it returns to

241
00:11:28,899 --> 00:11:33,009
something wrong soon as an invalid address

242
00:11:33,009 --> 00:11:35,259
example of invalid institutions and

243
00:11:35,259 --> 00:11:37,649
therefore to  that point the program grows

244
00:11:37,649 --> 00:11:40,540
when a program grows

245
00:11:40,540 --> 00:11:44,649
most of the time it is due to this is

246
00:11:44,649 --> 00:11:48,399
already a bell  llarme in fact

247
00:11:48,399 --> 00:11:50,139
we will see later that there are solutions to

248
00:11:50,139 --> 00:11:52,509
avoid this that not

249
00:11:52,509 --> 00:11:54,069
all operating systems are applied because some

250
00:11:54,069 --> 00:11:56,189
programs would grow continuously

251
00:11:56,189 --> 00:12:00,269
I can imagine world

252
00:12:00,430 --> 00:12:05,439
if you go and look at the program in we

253
00:12:05,439 --> 00:12:07,720
tell ourselves that these are the instructions

254
00:12:07,720 --> 00:12:10,689
that most usually come yes as

255
00:12:10,689 --> 00:12:12,480
these should not be used

256
00:12:12,480 --> 00:12:15,430
these are the functions that you should

257
00:12:15,430 --> 00:12:17,649
go looking for to understand if the

258
00:12:17,649 --> 00:12:22,449
program is proficient or not but let's

259
00:12:22,449 --> 00:12:24,629
see something more concrete

260
00:12:24,629 --> 00:12:28,720
what you see now is a

261
00:12:28,720 --> 00:12:34,569
working attack but I don't have not in

262
00:12:34,569 --> 00:12:35,529
quotes

263
00:12:35,529 --> 00:12:39,240
let's see if  it goes to full screen

264
00:12:41,920 --> 00:12:44,500
beautiful then the program we

265
00:12:44,500 --> 00:12:45,490
see

266
00:12:45,490 --> 00:12:52,240
is called esp 2016 point if I knew how to

267
00:12:52,240 --> 00:12:56,199
do it if it is in fact it has done against the most

268
00:12:56,199 --> 00:13:00,910
but it goes down to the most against more shift

269
00:13:00,910 --> 00:13:03,540
control more

270
00:13:13,230 --> 00:13:15,470
because used point is fine

271
00:13:15,470 --> 00:13:18,810
basically it is a system what

272
00:13:18,810 --> 00:13:21,690
we have  seen before on the

273
00:13:21,690 --> 00:13:25,160
slide then the step is set aside 20

274
00:13:25,160 --> 00:13:30,300
is printed buffer substantially  the

275
00:13:30,300 --> 00:13:32,880
mail does nothing but call this

276
00:13:32,880 --> 00:13:38,100
function we are interested in going here

277
00:13:38,100 --> 00:13:40,110
if you look at the program they have done that

278
00:13:40,110 --> 00:13:42,930
calling this function is to exit instead

279
00:13:42,930 --> 00:13:45,450
we want to overwrite the

280
00:13:45,450 --> 00:13:49,230
buffer and not to return here but come back here

281
00:13:49,230 --> 00:13:52,830
execute this and then it grows because this one

282
00:13:52,830 --> 00:13:55,470
here  on its own it does not go on but the

283
00:13:55,470 --> 00:13:57,270
program grows but I just want to

284
00:13:57,270 --> 00:14:00,180
foresee this thing here so to

285
00:14:00,180 --> 00:14:01,590
go and call that function that is

286
00:14:01,590 --> 00:14:03,930
in the program but which is never

287
00:14:03,930 --> 00:14:08,190
called in theory if this program

288
00:14:08,190 --> 00:14:09,990
then goes on it would go on

289
00:14:09,990 --> 00:14:13,200
so it does not  what we do

290
00:14:13,200 --> 00:14:15,390
if I call this program that I have already

291
00:14:15,390 --> 00:14:20,520
compiled then the program I

292
00:14:20,520 --> 00:14:23,960
compile it with this instruction

293
00:14:25,040 --> 00:14:27,420
this is a stack protection that

294
00:14:27,420 --> 00:14:28,950
we will see how it works that I remove

295
00:14:28,950 --> 00:14:30,870
otherwise it would not work it would not

296
00:14:30,870 --> 00:14:32,370
work I would have to make a billion

297
00:14:32,370 --> 00:14:35,190
attempts to do it so  this

298
00:14:35,190 --> 00:14:37,620
instruction does not stack

299
00:14:37,620 --> 00:14:39,750
protector says the name is used to

300
00:14:39,750 --> 00:14:42,890
protect the stack then let's see how

301
00:14:42,890 --> 00:14:45,150
then we  let's go compile this

302
00:14:45,150 --> 00:14:48,720
program as you can see there are also

303
00:14:48,720 --> 00:14:51,860
the bug's instructions

304
00:14:54,740 --> 00:14:58,190
ah sorry

305
00:15:04,050 --> 00:15:06,850
I did as he tress this

306
00:15:06,850 --> 00:15:11,529
thing I compiled it if I go to

307
00:15:11,529 --> 00:15:14,680
call the program it is that what he

308
00:15:14,680 --> 00:15:16,180
does asks me for the password shy hello

309
00:15:16,180 --> 00:15:20,019
exits does the printing  del chao and nothing

310
00:15:20,019 --> 00:15:20,920


311
00:15:20,920 --> 00:15:22,600
happens what if I write more than twenty

312
00:15:22,600 --> 00:15:26,949
characters it should crash

313
00:15:26,949 --> 00:15:31,540
because it needs to be strung because there is a

314
00:15:31,540 --> 00:15:32,829
segmentation role when it sees

315
00:15:32,829 --> 00:15:36,610
that error there has been a whisker and

316
00:15:36,610 --> 00:15:38,949
flop so you already know that you can

317
00:15:38,949 --> 00:15:47,189
attack

318
00:15:53,139 --> 00:15:57,879
if we go to see we go to see the source and

319
00:15:57,879 --> 00:16:08,649
fate sorry but ddt then apart from the

320
00:16:08,649 --> 00:16:12,100
initial part that interests us little that

321
00:16:12,100 --> 00:16:18,129
sounds you see that it went above

322
00:16:18,129 --> 00:16:21,939
you see this the address

323
00:16:21,939 --> 00:16:24,730
of the instruction here so here it is

324
00:16:24,730 --> 00:16:26,199
all the instruction that does for

325
00:16:26,199 --> 00:16:30,129
the instruction here this is the main and

326
00:16:30,129 --> 00:16:34,959
we go down this is les 2016 then

327
00:16:34,959 --> 00:16:37,389
by default it is a program not at the bug

328
00:16:37,389 --> 00:16:38,949
then one of the ars in search

329
00:16:38,949 --> 00:16:40,480
of the address of the functions  there

330
00:16:40,480 --> 00:16:42,399
are programs that are suitable

331
00:16:42,399 --> 00:16:43,509
I have done before because they are

332
00:16:43,509 --> 00:16:45,249
slackers and I have left the

333
00:16:45,249 --> 00:16:47,919
information laughs bug inside

334
00:16:47,919 --> 00:16:49,749
what we want to do we want to

335
00:16:49,749 --> 00:16:53,079
go and overwrite this and then

336
00:16:53,079 --> 00:16:57,040
replace with 08 04 84 8 b remember

337
00:16:57,040 --> 00:16:59,769
that the instructions  on the stack they are

338
00:16:59,769 --> 00:17:03,759
always put upside down so what is it that

339
00:17:03,759 --> 00:17:06,839
I went to do

340
00:17:11,970 --> 00:17:14,709
that knows the pearl I went to

341
00:17:14,709 --> 00:17:19,599
write the 32 times and then

342
00:17:19,599 --> 00:17:22,420
if you look at this instruction it is

343
00:17:22,420 --> 00:17:24,130
the address that I saw before the

344
00:17:24,130 --> 00:17:25,199
opposite

345
00:17:25,199 --> 00:17:27,609
so I  I go to overwrite events

346
00:17:27,609 --> 00:17:32,830
characters the information and as the last

347
00:17:32,830 --> 00:17:35,559
address actually to find where you

348
00:17:35,559 --> 00:17:40,330
go to write the return address you

349
00:17:40,330 --> 00:17:43,690
go in attempts I write 20 and see where

350
00:17:43,690 --> 00:17:45,220
I went to dirty I windux

351
00:17:45,220 --> 00:17:47,140
characters having played dirty I do

352
00:17:47,140 --> 00:17:49,420
22 and go on  so but I have been

353
00:17:49,420 --> 00:17:53,440
on jackets and that I have already found

354
00:17:53,440 --> 00:17:54,610
what was 20 and therefore it is easier to

355
00:17:54,610 --> 00:17:57,340
find it however the concept does not change

356
00:17:57,340 --> 00:18:00,429
so I am going to overwrite until I

357
00:18:00,429 --> 00:18:02,650
I see the memory address if you

358
00:18:02,650 --> 00:18:04,420
looked at the error before you saw that

359
00:18:04,420 --> 00:18:06,250
there was an address where it

360
00:18:06,250 --> 00:18:06,820
ended up

361
00:18:06,820 --> 00:18:09,040
going to see on that one I notice

362
00:18:09,040 --> 00:18:11,559
where one bite at a time where I go to

363
00:18:11,559 --> 00:18:13,150
dirty

364
00:18:13,150 --> 00:18:14,890
if I throw this you see that I

365
00:18:14,890 --> 00:18:17,620
do not do  other than printing 32 a

366
00:18:17,620 --> 00:18:20,440
and then he passed him the return address

367
00:18:20,440 --> 00:18:22,480
reversed naturally because the detachment

368
00:18:22,480 --> 00:18:25,510
takes one bite at a time from top

369
00:18:25,510 --> 00:18:28,300
to bottom and in the step esca 2016 it is

370
00:18:28,300 --> 00:18:30,010
as if I wrote all this stuff there

371
00:18:30,010 --> 00:18:32,350
when he asks me he passed the  hand

372
00:18:32,350 --> 00:18:34,510
I avoid writing the hand I this thing

373
00:18:34,510 --> 00:18:37,510
here also because barabino baits 88 b is

374
00:18:37,510 --> 00:18:40,920
difficult to send it with me

375
00:18:41,170 --> 00:18:46,770
according to you it works if I launch that

376
00:18:49,140 --> 00:18:52,450
you see that the

377
00:18:52,450 --> 00:18:55,050
function that was not there first

378
00:18:55,050 --> 00:18:58,059
then went to seeds went to call me  the fault because

379
00:18:58,059 --> 00:19:01,179
because the next instruction no

380
00:19:01,179 --> 00:19:03,220
longer made sense and then it closed but it

381
00:19:03,220 --> 00:19:05,679
worked so he printed the wings

382
00:19:05,679 --> 00:19:08,320
he passed the return address which

383
00:19:08,320 --> 00:19:10,660
was no longer what you saw before

384
00:19:10,660 --> 00:19:13,559
and he went to ch  iamare the function

385
00:19:13,559 --> 00:19:17,710
what succeeds 2016 and oh well I did

386
00:19:17,710 --> 00:19:20,790
to ghedini when to make them cool

387
00:19:20,790 --> 00:19:25,020
and then it worked this is one of the

388
00:19:25,020 --> 00:19:27,390
two types of attack is the least

389
00:19:27,390 --> 00:19:29,100
interesting because you have to go and

390
00:19:29,100 --> 00:19:30,750
see the functions the most

391
00:19:30,750 --> 00:19:31,470
interesting

392
00:19:31,470 --> 00:19:35,100
one we see on the slides after where

393
00:19:35,100 --> 00:19:38,040
we explain  instead not given the type of

394
00:19:38,040 --> 00:19:39,990
attack but the defenses that have been

395
00:19:39,990 --> 00:19:41,760
can be done to avoid these types of

396
00:19:41,760 --> 00:19:44,210
attack

397
00:19:44,310 --> 00:19:51,230
I liked it so far but it worked

398
00:19:51,230 --> 00:19:55,520
worse when you make the software so

399
00:19:58,370 --> 00:20:00,990
in theory it should come out of the

400
00:20:00,990 --> 00:20:11,360
full screen well zero for 32

401
00:20:13,639 --> 00:20:16,190
no why  there is other information

402
00:20:16,190 --> 00:20:18,409
inside it is not said then depending

403
00:20:18,409 --> 00:20:20,029
on the compiler it adds information on

404
00:20:20,029 --> 00:20:22,909
and now we will see them for example if it puts

405
00:20:22,909 --> 00:20:24,469
stack protector view

406
00:20:24,469 --> 00:20:26,690
there was an extra bit or 2 more bit

407
00:20:26,690 --> 00:20:28,969
depending on the type of to go and

408
00:20:28,969 --> 00:20:31,070
find it also because  there are other

409
00:20:31,070 --> 00:20:34,489
function calls and therefore

410
00:20:34,489 --> 00:20:36,649
there could be other addresses or others

411
00:20:36,649 --> 00:20:39,469
as you don't know because now we

412
00:20:39,469 --> 00:20:41,749
knew we had and sources  you

413
00:20:41,749 --> 00:20:43,549
but in 90% of the dear indeed in

414
00:20:43,549 --> 00:20:45,079
100% of the cases you have

415
00:20:45,079 --> 00:20:47,119
not I did not say a house where it will have to be

416
00:20:47,119 --> 00:20:49,489
open source but if it is not a source you

417
00:20:49,489 --> 00:20:53,299
cannot go in search of this way

418
00:20:53,299 --> 00:20:55,879
you have to go a little at a time when you see

419
00:20:55,879 --> 00:20:57,709
that writing  a million characters

420
00:20:57,709 --> 00:20:59,959
from the error you already know that there is at that

421
00:20:59,959 --> 00:21:02,599
moment onwards you start the search for

422
00:21:02,599 --> 00:21:04,849
what I like because it is not

423
00:21:04,849 --> 00:21:07,219
a ready-made meal and it works must

424
00:21:07,219 --> 00:21:10,159
begin to think about how and

425
00:21:10,159 --> 00:21:13,519
therefore the compiler does not actually  it is as

426
00:21:13,519 --> 00:21:15,379
they saw before it adds other things

427
00:21:15,379 --> 00:21:19,238
one we see it now here

428
00:21:28,490 --> 00:21:34,220
or we went from nec sx presentation

429
00:21:34,220 --> 00:21:37,070
the attack was made on ubuntu 16 06

430
00:21:37,070 --> 00:21:39,740
installed another day and these slides

431
00:21:39,740 --> 00:21:41,750
are super mixed so between the

432
00:21:41,750 --> 00:21:46,130
operating systems to make a [ __ ] waste  of

433
00:21:46,130 --> 00:21:49,280
absolute energies then this here is an

434
00:21:49,280 --> 00:21:53,000
old talk of the other up that as

435
00:21:53,000 --> 00:21:57,559
you know the founder of fb and of all

436
00:21:57,559 --> 00:21:59,330
these techniques we

437
00:21:59,330 --> 00:22:01,340
will see that these natives cannot

438
00:22:01,340 --> 00:22:03,710
use them for various reasons.

439
00:22:03,710 --> 00:22:08,630
to some obvious things but one

440
00:22:08,630 --> 00:22:11,260
of the interesting things

441
00:22:11,330 --> 00:22:15,830
is this we have just seen

442
00:22:15,830 --> 00:22:17,540
the return address that return address

443
00:22:17,540 --> 00:22:21,740
the 848 what was it is the same on

444
00:22:21,740 --> 00:22:24,740
any linux you go to start

445
00:22:24,740 --> 00:22:28,520
that east 2016 compiled because

446
00:22:28,520 --> 00:22:30,350
the information of where  map them memory

447
00:22:30,350 --> 00:22:32,960
is written inside the compiled file

448
00:22:32,960 --> 00:22:35,270
for which it is vg do

449
00:22:35,270 --> 00:22:38,120
there is no so when I

450
00:22:38,120 --> 00:22:41,510
found something wrong on my pc and I

451
00:22:41,510 --> 00:22:43,910
found the bug and I found the

452
00:22:43,910 --> 00:22:45,980
real mustache automatically this oil works

453
00:22:45,980 --> 00:22:47,450
on  all operating systems

454
00:22:47,450 --> 00:22:51,740
indeed sorry on all systems where that

455
00:22:51,740 --> 00:22:53,570
program e is launched because

456
00:22:53,570 --> 00:22:55,880
the memory address where it is

457
00:22:55,880 --> 00:22:58,540
allocated is written inside

458
00:22:58,540 --> 00:23:02,150
the program file itself for which it is a

459
00:23:02,150 --> 00:23:05,660
hard environment automatically will

460
00:23:05,660 --> 00:23:09,040
work everywhere

461
00:23:11,000 --> 00:23:14,580
let go of things that I was firmly

462
00:23:14,580 --> 00:23:20,460
oriented all open viesti now what i

463
00:23:20,460 --> 00:23:25,050
said before is that when the stack e

464
00:23:25,050 --> 00:23:28,580
grows down it is overwritten

465
00:23:28,580 --> 00:23:31,590
first we did return it to return

466
00:23:31,590 --> 00:23:35,610
the program anyway  eu on an address

467
00:23:35,610 --> 00:23:37,560
of the program but on another opposition

468
00:23:37,560 --> 00:23:40,770
then on another function

469
00:23:40,770 --> 00:23:43,260
the idea instead of basell and interesting mustache attacks

470
00:23:43,260 --> 00:23:45,270
are those that go

471
00:23:45,270 --> 00:23:48,660
overwrite the return address and

472
00:23:48,660 --> 00:23:51,930
write the code they want and there they

473
00:23:51,930 --> 00:23:53,970
washed overwriting of the

474
00:23:53,970 --> 00:23:56,670
return address makes the program always go

475
00:23:56,670 --> 00:23:58,320
inside the stack but where they have

476
00:23:58,320 --> 00:24:00,720
written the example code before

477
00:24:00,720 --> 00:24:01,440
the

478
00:24:01,440 --> 00:24:04,890
lea password to cover date any

479
00:24:04,890 --> 00:24:06,660
character to go up to

480
00:24:06,660 --> 00:24:07,620
the return

481
00:24:07,620 --> 00:24:08,940
address the return address must be

482
00:24:08,940 --> 00:24:12,150
overwritten a byte  after the end

483
00:24:12,150 --> 00:24:13,860
of the return address where you will

484
00:24:13,860 --> 00:24:16,410
begin to write the code that

485
00:24:16,410 --> 00:24:18,360
you want to execute so the

486
00:24:18,360 --> 00:24:19,980
program no longer exits the stack but

487
00:24:19,980 --> 00:24:22,770
continues forward that what happens

488
00:24:22,770 --> 00:24:25,290
here then goes back and continues the

489
00:24:25,290 --> 00:24:30,830
code that must not be executed

490
00:24:30,990 --> 00:24:33,210
then the  he idea what it is to go to

491
00:24:33,210 --> 00:24:35,040
overwrite then in the step to

492
00:24:35,040 --> 00:24:37,590
write the substantially a few

493
00:24:37,590 --> 00:24:39,660
characters to go ahead  you up to

494
00:24:39,660 --> 00:24:42,150
the return address above you will write

495
00:24:42,150 --> 00:24:44,340
the return address and then

496
00:24:44,340 --> 00:24:46,170
there will be all the code that must be

497
00:24:46,170 --> 00:24:47,370
executed naturally to be

498
00:24:47,370 --> 00:24:48,680
exclusively machine language

499
00:24:48,680 --> 00:24:50,970
the return address does more than alpha

500
00:24:50,970 --> 00:24:52,740
satisfy it return to the real program

501
00:24:52,740 --> 00:24:54,720
makes it return a  bite after the address

502
00:24:54,720 --> 00:24:57,050
of choruses there is your code

503
00:24:57,050 --> 00:25:02,130
that the most interesting idea on

504
00:25:02,130 --> 00:25:05,910
windows for facts then the initial idea

505
00:25:05,910 --> 00:25:08,490
I said before that if I start

506
00:25:08,490 --> 00:25:11,100
the same program 20 times on 500 on the

507
00:25:11,100 --> 00:25:13,320
same on the same pc or on the same pc

508
00:25:13,320 --> 00:25:18,870
on several pc the address 84 84 8b

509
00:25:18,870 --> 00:25:21,650
seems to me it was is always the same for all

510
00:25:21,650 --> 00:25:24,300
this is a serious error on open destiny

511
00:25:24,300 --> 00:25:25,920
it does not happen every time the program

512
00:25:25,920 --> 00:25:28,530
is allocated and there is a gap is

513
00:25:28,530 --> 00:25:33,900
called stec cup where the

514
00:25:33,900 --> 00:25:40,160
program always comes as 256k  it says

515
00:25:40,160 --> 00:25:42,930
added I have decreased with respect to the gap

516
00:25:42,930 --> 00:25:46,050
so it is not if I do it run a

517
00:25:46,050 --> 00:25:48,150
hundred times on linux as I have seen before

518
00:25:48,150 --> 00:25:50,370
or on all your linux pc with ubuntu

519
00:25:50,370 --> 00:25:52,290
the progra  mma will always be like this, that is,

520
00:25:52,290 --> 00:25:54,410
always located in the same

521
00:25:54,410 --> 00:25:56,760
shopping memory as it is not because

522
00:25:56,760 --> 00:25:59,310
a bland random variable stack is added

523
00:25:59,310 --> 00:26:01,290
for which automatically

524
00:26:01,290 --> 00:26:02,850
the return address of the function

525
00:26:02,850 --> 00:26:06,300
changes and therefore the stack, sorry

526
00:26:06,300 --> 00:26:10,940
, automatically changes that type of

527
00:26:10,940 --> 00:26:12,720
attack we saw before it would

528
00:26:12,720 --> 00:26:15,390
work  still but the attack that

529
00:26:15,390 --> 00:26:17,010
I dodge above and move forward

530
00:26:17,010 --> 00:26:18,360
in the stack no longer works because

531
00:26:18,360 --> 00:26:20,070
the address detaches it is no longer static

532
00:26:20,070 --> 00:26:22,350
but dynamic and I do not know it

533
00:26:22,350 --> 00:26:24,090
you will say of course I do it again a

534
00:26:24,090 --> 00:26:26,010
billion times in fact there are other

535
00:26:26,010 --> 00:26:28,410
additional protections  but this type of

536
00:26:28,410 --> 00:26:30,540
attack which is the most stupid would still make it

537
00:26:30,540 --> 00:26:32,460
difficult and require and whoever

538
00:26:32,460 --> 00:26:35,190
requests bellary ept viri ept that

539
00:26:35,190 --> 00:26:41,660
we therefore want to repeat

540
00:26:41,660 --> 00:26:44,370
the program several times until we randomly find

541
00:26:44,370 --> 00:26:46,110
that the address of the bridge corresponds to

542
00:26:46,110 --> 00:26:51,990
what the stack suitable l  'other is

543
00:26:51,990 --> 00:26:54,300
what I went to remove

544
00:26:54,300 --> 00:26:59,390
before basically I said before

545
00:26:59,390 --> 00:27:01,500
we saw c  he was there when we

546
00:27:01,500 --> 00:27:02,520
made the function the simplest one

547
00:27:02,520 --> 00:27:05,760
there was life in b and return to

548
00:27:05,760 --> 00:27:08,790
return function then 21 and then there is the

549
00:27:08,790 --> 00:27:10,740
return address when you

550
00:27:10,740 --> 00:27:12,810
go to compile without that option

551
00:27:12,810 --> 00:27:15,030
the compiler does one thing  interesting

552
00:27:15,030 --> 00:27:19,950
it takes a groove [ __ ] it's cute

553
00:27:19,950 --> 00:27:23,040
declares rino is a bird and women

554
00:27:23,040 --> 00:27:23,990
know it

555
00:27:23,990 --> 00:27:26,850
then the groove is basically a

556
00:27:26,850 --> 00:27:32,370
bite or 2bite where it is written and

557
00:27:32,370 --> 00:27:34,560
this is written by the compiler a random number

558
00:27:34,560 --> 00:27:36,679


559
00:27:36,679 --> 00:27:41,100
when returning from the function if that number

560
00:27:41,100 --> 00:27:42,240
does not correspond to that  that had been

561
00:27:42,240 --> 00:27:43,490
written before

562
00:27:43,490 --> 00:27:46,289
there is something wrong and it makes the program grow the

563
00:27:46,289 --> 00:27:50,070
clash program the mustache

564
00:27:50,070 --> 00:27:53,279
does not work anymore I can explain better if

565
00:27:53,279 --> 00:27:55,409
I wrote 20 here

566
00:27:55,409 --> 00:27:56,820
and since I do the argument must

567
00:27:56,820 --> 00:27:59,070
still go sorry the argument must

568
00:27:59,070 --> 00:28:01,740
go  to overwrite then go

569
00:28:01,740 --> 00:28:04,460
through here until you reach

570
00:28:04,460 --> 00:28:06,390
the return address

571
00:28:06,390 --> 00:28:07,440
if the return address does not

572
00:28:07,440 --> 00:28:10,830
match if I write all a and here

573
00:28:10,830 --> 00:28:14,940
it says 20 and the surely will be 65

574
00:28:14,940 --> 00:28:17,159
66 name I remember this only goes to

575
00:28:17,159 --> 00:28:19,260
write that 20 when

576
00:28:19,260 --> 00:28:20,730
the function comes back this is done by the

577
00:28:20,730 --> 00:28:23,370
compiler without you knowing

578
00:28:23,370 --> 00:28:24,929
before writing to go execute

579
00:28:24,929 --> 00:28:26,760
your code to check if the is the

580
00:28:26,760 --> 00:28:28,320
number that was written before at that

581
00:28:28,320 --> 00:28:31,620
point corresponds  to the one that when it

582
00:28:31,620 --> 00:28:33,899
realizes that it has been subscribed the

583
00:28:33,899 --> 00:28:35,970
program crashes goes into segmentation

584
00:28:35,970 --> 00:28:40,740
fault this is a [ __ ] to do and that is

585
00:28:40,740 --> 00:28:43,350
on windows for example there is not and then I

586
00:28:43,350 --> 00:28:45,059
will explain the reason indeed famous you alone

587
00:28:45,059 --> 00:28:47,090


588
00:28:47,419 --> 00:28:52,460
the last mechanism is used

589
00:28:52,460 --> 00:28:55,649
basically east now when

590
00:28:55,649 --> 00:28:57,630
this was done and live looping say the only one

591
00:28:57,630 --> 00:28:59,159
that used it now is a little bit used

592
00:28:59,159 --> 00:29:00,210
everywhere

593
00:29:00,210 --> 00:29:03,990
basically it's a beat that is inserted

594
00:29:03,990 --> 00:29:09,960
into the processor or pb on some

595
00:29:09,960 --> 00:29:12,870
processors had emulated it where you can tell

596
00:29:12,870 --> 00:29:15,419
since where c  'is the software and where there is

597
00:29:15,419 --> 00:29:19,289
the stack is in

598
00:29:19,289 --> 00:29:22,080
read-only quotes and where there is the program where there is

599
00:29:22,080 --> 00:29:25,110
the program and on the reading and where there is

600
00:29:25,110 --> 00:29:27,059
the stack and on the writing executable

601
00:29:27,059 --> 00:29:31,409
for  where where there is execution I cannot

602
00:29:31,409 --> 00:29:33,419
read where I can read there is no

603
00:29:33,419 --> 00:29:38,610
execution so either I write or execute at

604
00:29:38,610 --> 00:29:40,409
this point from one point of view it is

605
00:29:40,409 --> 00:29:44,669
impossible to detach the buffer

606
00:29:44,669 --> 00:29:47,520
overflow no longer works because because it

607
00:29:47,520 --> 00:29:48,450
permits

608
00:29:48,450 --> 00:29:49,860
the memory area

609
00:29:49,860 --> 00:29:53,130
if the only or in writing and therefore the

610
00:29:53,130 --> 00:29:55,830
detachment part, however, cannot be

611
00:29:55,830 --> 00:29:57,750
performed so what I said

612
00:29:57,750 --> 00:30:00,840
before returning the code of course you

613
00:30:00,840 --> 00:30:03,140
succeed but it cannot be executed

614
00:30:03,140 --> 00:30:05,100
because then only write

615
00:30:05,100 --> 00:30:07,470
it the stack is subscribable so you can

616
00:30:07,470 --> 00:30:09,330
write it because it takes  the functions but

617
00:30:09,330 --> 00:30:11,490
can not be stopped code and you are

618
00:30:11,490 --> 00:30:13,860
running this busy day

619
00:30:13,860 --> 00:30:17,760
immediately in the processor it is clear

620
00:30:17,760 --> 00:30:21,270
this concept I was saying before one of the

621
00:30:21,270 --> 00:30:23,040
basic concepts roots go

622
00:30:23,040 --> 00:30:25,080
overwrite putting an address that

623
00:30:25,080 --> 00:30:27,179
went just after the stack

624
00:30:27,179 --> 00:30:28,470
executing some code

625
00:30:28,470 --> 00:30:29,910
follows the code can not be  executed

626
00:30:29,910 --> 00:30:31,950
because it can only be the

627
00:30:31,950 --> 00:30:34,679
memory area can only be livable and

628
00:30:34,679 --> 00:30:37,380
therefore not executable automatically

629
00:30:37,380 --> 00:30:39,510
does not work  one thing executable only the

630
00:30:39,510 --> 00:30:42,390
given part given executable because the

631
00:30:42,390 --> 00:30:45,390
program for which it works to the other that

632
00:30:45,390 --> 00:30:46,980
goes to call the function but

633
00:30:46,980 --> 00:30:53,450
the execution no longer works so

634
00:30:53,450 --> 00:30:55,799
all these methods put together

635
00:30:55,799 --> 00:31:00,000
make it very difficult to make a

636
00:31:00,000 --> 00:31:03,690
bar flò run all these here  at this

637
00:31:03,690 --> 00:31:05,669
moment it has it now I do not do the

638
00:31:05,669 --> 00:31:12,990
whole pantomime of how it

639
00:31:12,990 --> 00:31:16,320
works how white oryx worked but

640
00:31:16,320 --> 00:31:18,150
basically it is that at a given moment

641
00:31:18,150 --> 00:31:21,570
the program can only be in the

642
00:31:21,570 --> 00:31:24,809
writing area or the sun in the

643
00:31:24,809 --> 00:31:26,640
execution area so the whole part  soft

644
00:31:26,640 --> 00:31:28,890
all the program part or in the zone or

645
00:31:28,890 --> 00:31:31,679
sorry or in the zone only writes

646
00:31:31,679 --> 00:31:33,330
therefore not executable here executable code

647
00:31:33,330 --> 00:31:35,669
therefore assembly instructions

648
00:31:35,669 --> 00:31:37,169
cannot be there will never be

649
00:31:37,169 --> 00:31:41,010
executed at the x86 processor level it is

650
00:31:41,010 --> 00:31:45,150
so and now damonte generations

651
00:31:45,150 --> 00:31:49,190
this is what we say makes you

652
00:31:50,070 --> 00:31:55,379
lose value  to buffalo beware that it

653
00:31:56,039 --> 00:31:59,260
must be implemented ie if you

654
00:31:59,260 --> 00:32:01,330
go them to level diet processors not to

655
00:32:01,330 --> 00:32:04,740
use this q  his is not used

656
00:32:06,179 --> 00:32:08,500
so okay without going to see there is

657
00:32:08,500 --> 00:32:10,419
a beat in the cpv when it goes to space out

658
00:32:10,419 --> 00:32:12,820
the memory page of his

659
00:32:12,820 --> 00:32:14,890
to say if you want it to be executable

660
00:32:14,890 --> 00:32:21,299
in itself of execution or only of writing

661
00:32:23,549 --> 00:32:27,929
let's not go to see all  is stuff here

662
00:32:32,740 --> 00:32:36,909
the other is the dynamic location when

663
00:32:36,909 --> 00:32:38,559
I do a mallock when I ask

664
00:32:38,559 --> 00:32:41,980
about the memory on one on most

665
00:32:41,980 --> 00:32:44,860
operating systems and this is

666
00:32:44,860 --> 00:32:47,350
always allocated in the same way so

667
00:32:47,350 --> 00:32:48,880
that the program always works in the

668
00:32:48,880 --> 00:32:54,490
same way and therefore there is no  it is as they

669
00:32:54,490 --> 00:32:57,700
say it is the software is static instead we are

670
00:32:57,700 --> 00:32:59,200
interested in having something more

671
00:32:59,200 --> 00:33:01,750
dynamic and therefore on the open bis of lama

672
00:33:01,750 --> 00:33:02,200
loc

673
00:33:02,200 --> 00:33:04,179
it randomly allocates things in the

674
00:33:04,179 --> 00:33:06,390
memory

675
00:33:07,690 --> 00:33:09,909
so if we go and see we have

676
00:33:09,909 --> 00:33:11,860
the program that does not start but the

677
00:33:11,860 --> 00:33:14,320
stack that goes up  and down depending on the

678
00:33:14,320 --> 00:33:17,799
gap as they say all the

679
00:33:17,799 --> 00:33:20,320
dynamic locations must be done randomly on the

680
00:33:20,320 --> 00:33:22,929
ramp then between the same programs that

681
00:33:22,929 --> 00:33:24,640
do the same things have the programs

682
00:33:24,640 --> 00:33:27,429
that is, sorry you go  and all the

683
00:33:27,429 --> 00:33:30,250
information scattered randomly compared

684
00:33:30,250 --> 00:33:31,929
to a classic program that is always

685
00:33:31,929 --> 00:33:33,010
like

686
00:33:33,010 --> 00:33:34,960
this makes it practically do not say

687
00:33:34,960 --> 00:33:36,640
impossible because it does not exist but it

688
00:33:36,640 --> 00:33:39,240
becomes

689
00:33:39,240 --> 00:33:43,290
very difficult to carry out a bar focus

690
00:33:43,290 --> 00:33:46,010
and almost practically impossible

691
00:33:46,010 --> 00:33:51,270
unfortunately some of these things

692
00:33:51,270 --> 00:33:59,190
are not not usable on  some

693
00:33:59,190 --> 00:34:00,840
operating systems

694
00:34:00,840 --> 00:34:03,150
I do the example the next version of

695
00:34:03,150 --> 00:34:06,390
open best in all the programs that

696
00:34:06,390 --> 00:34:09,330
are compiled later so

697
00:34:09,330 --> 00:34:13,168
those that go end user local bean

698
00:34:13,168 --> 00:34:17,119
a function of the rai 3x has been removed

699
00:34:17,119 --> 00:34:20,550
because many programs no

700
00:34:20,550 --> 00:34:23,699
longer worked so they did wrong and therefore

701
00:34:23,699 --> 00:34:25,230
they were forced or did not work

702
00:34:25,230 --> 00:34:27,899
anymore they removed a protection

703
00:34:27,899 --> 00:34:30,750
this is very telling how they are done

704
00:34:30,750 --> 00:34:33,629
with mine today that is a protection

705
00:34:33,629 --> 00:34:35,340
is removed because most of the

706
00:34:35,340 --> 00:34:37,290
volumes are made of crap and have been

707
00:34:37,290 --> 00:34:39,119
forced keep in mind that when not

708
00:34:39,119 --> 00:34:41,010
enabled with the functions  they found

709
00:34:41,010 --> 00:34:45,239
a mess of their own fix  or for the

710
00:34:45,239 --> 00:34:48,570
fact that when a program comes out in

711
00:34:48,570 --> 00:34:49,859
the way you have seen for

712
00:34:49,859 --> 00:34:51,119
then it has been going for a while very

713
00:34:51,119 --> 00:34:53,070
really due to the fact that it had

714
00:34:53,070 --> 00:34:55,050
an involuntary mustache towards you

715
00:34:55,050 --> 00:34:57,330
may not have noticed one of the most

716
00:34:57,330 --> 00:35:00,060
famous was the

717
00:35:00,060 --> 00:35:02,640
corrector's name  online spelling of word

718
00:35:02,640 --> 00:35:05,490
2 that occasionally grew and will give a

719
00:35:05,490 --> 00:35:09,770
more striking graphic mustache and that has

720
00:35:09,770 --> 00:35:14,640
remained for a long time so what

721
00:35:14,640 --> 00:35:18,150
I wanted to tell you is that technically it is

722
00:35:18,150 --> 00:35:20,310
still usable because on some

723
00:35:20,310 --> 00:35:22,530
operating systems many of those protections you

724
00:35:22,530 --> 00:35:24,180
have  seen they are not used or

725
00:35:24,180 --> 00:35:27,869
are not used at all what they are who is they

726
00:35:27,869 --> 00:35:29,670
are your things just pour on what

727
00:35:29,670 --> 00:35:31,290
you will find of everything

728
00:35:31,290 --> 00:35:33,300
windows xp is not even one of those

729
00:35:33,300 --> 00:35:34,500
you have seen here so you can

730
00:35:34,500 --> 00:35:36,280
safely puncture

731
00:35:36,280 --> 00:35:39,370
without problems windows 10 has something

732
00:35:39,370 --> 00:35:41,850
more than  these protections but not all

733
00:35:41,850 --> 00:35:44,230
that dynamic does not have the problem

734
00:35:44,230 --> 00:35:45,640
of these things I said that if the

735
00:35:45,640 --> 00:35:48,070
program is done badly it grows from a

736
00:35:48,070 --> 00:35:50,620
user's point of view q  When he sees

737
00:35:50,620 --> 00:35:53,370
the program grow, he says windows of

738
00:35:53,370 --> 00:35:56,560
or this and therefore it is better that

739
00:35:56,560 --> 00:35:58,990
some things work badly but still

740
00:35:58,990 --> 00:36:00,820
work rather than do not work at all

741
00:36:00,820 --> 00:36:05,710
and therefore I can assure that

742
00:36:05,710 --> 00:36:08,080
there are enough of them to be true and that

743
00:36:08,080 --> 00:36:10,840
I do not dedicate myself any more I have not discovered that

744
00:36:10,840 --> 00:36:13,060
I know how they work done once I don't

745
00:36:13,060 --> 00:36:15,490
care anymore and therefore it ends it was the

746
00:36:15,490 --> 00:36:18,190
thing I studied it out of

747
00:36:18,190 --> 00:36:21,040
my curiosity not because I had to do who knows what

748
00:36:21,040 --> 00:36:24,100
apart from 23 dlls of windows xp professional

749
00:36:24,100 --> 00:36:27,010
and things they did other in short it

750
00:36:27,010 --> 00:36:31,260
works at all for educational purposes  let's say,

751
00:36:31,260 --> 00:36:34,870
however, I can assure you that there are and

752
00:36:34,870 --> 00:36:40,750
still an open world especially for

753
00:36:40,750 --> 00:36:43,390
windows systems

754
00:36:43,390 --> 00:36:44,950
the only ones a little more difficult but if

755
00:36:44,950 --> 00:36:48,250
you look at linux kernel it is

756
00:36:48,250 --> 00:36:50,710
most and the errors if you have a mail

757
00:36:50,710 --> 00:36:55,200
list and you see that it is full constantly

758
00:36:55,200 --> 00:36:56,980
full

759
00:36:56,980 --> 00:36:59,170
not  i'm saying there is some full

760
00:36:59,170 --> 00:37:00,910
because looked at the other day it had

761
00:37:00,910 --> 00:37:04,530
34 only linux carnet

762
00:37:04,530 --> 00:37:07,030
so the only thing i can say if you

763
00:37:07,030 --> 00:37:10,210
write things n  never trust what people are

764
00:37:10,210 --> 00:37:11,590
giving you so

765
00:37:11,590 --> 00:37:14,140
check them and if you write the you have to

766
00:37:14,140 --> 00:37:16,090
check us as you are

767
00:37:16,090 --> 00:37:17,170
the memory managers you have to check

768
00:37:17,170 --> 00:37:21,970
anything and do not trust the

769
00:37:21,970 --> 00:37:23,530
fact that the user will never write more

770
00:37:23,530 --> 00:37:27,670
than twenty characters if you have any questions.

771
00:37:27,670 --> 00:37:29,050
I did not think of all these people because

772
00:37:29,050 --> 00:37:30,850
as a true old saying I do it

773
00:37:30,850 --> 00:37:32,920
because 11 in the evening nobody will move

774
00:37:32,920 --> 00:37:34,980
but there are too many people

775
00:37:34,980 --> 00:37:38,920
[ __ ] they are doing auctions hours

776
00:37:38,920 --> 00:37:42,990
petrol station beer you have questions

777
00:37:43,530 --> 00:37:48,280
ah ok then I understand says the wing  6 and

778
00:37:48,280 --> 00:37:52,330
on thesis six they have removed from rai

779
00:37:52,330 --> 00:37:54,280
fiction on the next release cachet

780
00:37:54,280 --> 00:37:56,619
which came out on September 1st today from

781
00:37:56,619 --> 00:37:58,720
today the first set I have been on vacation for a few

782
00:37:58,720 --> 00:38:00,730
days so I lost the then to the ex

783
00:38:00,730 --> 00:38:02,470
that the conception of the

784
00:38:02,470 --> 00:38:03,940
time is out today

785
00:38:03,940 --> 00:38:06,520
if you go and see on the changes that here

786
00:38:06,520 --> 00:38:07,330
I don't have internet

787
00:38:07,330 --> 00:38:10,119
strangely it is written that

788
00:38:10,119 --> 00:38:12,390
they have removed wx for all programs

789
00:38:12,390 --> 00:38:16,869
compiled externally on user local

790
00:38:16,869 --> 00:38:18,940
b because yes  can eliminate at the

791
00:38:18,940 --> 00:38:25,510
mount level because many are found it is ok

792
00:38:25,510 --> 00:38:31,270
country you attack it so you can see and they have

793
00:38:31,270 --> 00:38:33,730
substantially changed the beauty is

794
00:38:33,730 --> 00:38:36,400
that they put it as a

795
00:38:36,400 --> 00:38:39,880
security problem they have removed one thing because

796
00:38:39,880 --> 00:38:45,900
many programs do not go to grow periodically

797
00:38:51,210 --> 00:38:55,390
after the while  installed or

798
00:38:55,390 --> 00:38:57,150
babies of programs by default

799
00:38:57,150 --> 00:38:59,650
they already work they already have all the security

800
00:38:59,650 --> 00:39:02,080
you have seen before for many years already

801
00:39:02,080 --> 00:39:03,820
lives these slides and they are six years ago

802
00:39:03,820 --> 00:39:07,390
what you have seen before

803
00:39:07,390 --> 00:39:10,599
so the problem is the programs that

804
00:39:10,599 --> 00:39:12,430
since they are a vastness do not  they can

805
00:39:12,430 --> 00:39:17,500
check all the chest in my opinion the

806
00:39:17,500 --> 00:39:20,050
level of the pre amateurs c is very low

807
00:39:20,050 --> 00:39:23,890
I do not know how to program there are I consider myself

808
00:39:23,890 --> 00:39:26,820
a program of facts I do not do it but the

809
00:39:26,820 --> 00:39:29,200
level is low because the errors I

810
00:39:29,200 --> 00:39:33,640
see around are continuous I have never

811
00:39:33,640 --> 00:39:35,410
seen one  chopin di dio there are

812
00:39:35,410 --> 00:39:37,320
very few that is leave just one that

813
00:39:37,320 --> 00:39:39,849
then actually just program

814
00:39:39,849 --> 00:39:45,550
well after the bug the forgetfulness one can

815
00:39:45,550 --> 00:39:48,849
find however a con  to find one a

816
00:39:48,849 --> 00:39:51,070
year one thing is to find or two a

817
00:39:51,070 --> 00:39:53,440
day on inu meat you can't

818
00:39:53,440 --> 00:39:55,660
speak ill of it but for the mother that

819
00:39:55,660 --> 00:39:56,680
on the island her

820
00:39:56,680 --> 00:39:59,200
billions people who work there is the good there is

821
00:39:59,200 --> 00:40:02,559
the less good one  it's right people

822
00:40:02,559 --> 00:40:07,420
make chaos more questions so they

823
00:40:07,420 --> 00:40:12,210
can drink beer now guys

