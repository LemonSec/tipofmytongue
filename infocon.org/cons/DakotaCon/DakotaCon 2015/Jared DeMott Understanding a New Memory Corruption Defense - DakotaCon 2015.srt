1
00:00:00,179 --> 00:00:03,179
yeah alright

2
00:00:04,350 --> 00:00:12,260
a decir thanks for invite me back again
I've gotta use after free mitigation

3
00:00:12,260 --> 00:00:17,740
bypass the Tigers breaks Dave rule of
keeping it simple and in a but you know

4
00:00:17,740 --> 00:00:21,409
it's kinda interesting to talk about how
it's gotta be either social or technical

5
00:00:21,410 --> 00:00:24,119
and social instead of technical or
simple instead but it's actually

6
00:00:24,119 --> 00:00:28,340
everything right it is a technical
problem is a social problems both and it

7
00:00:28,340 --> 00:00:32,738
is simple and it is difficult it's it's
neither I don't think you can simplify

8
00:00:32,738 --> 00:00:36,290
it in that way right it's everything is
all the above when it comes to

9
00:00:36,290 --> 00:00:42,410
technology because it's invasive it's
everywhere crazy how much it's invaded

10
00:00:42,410 --> 00:00:46,349
our lives as far as where technology so
I'm Jared I think a lot of people here

11
00:00:46,350 --> 00:00:52,340
know me so I kind of skipped that I want
to look at this new protections that are

12
00:00:52,340 --> 00:00:56,219
in Internet Explorer for a lot of
reasons one of the reasons I've kinda

13
00:00:56,219 --> 00:01:01,730
have a history of doing that I looked
into and helped even shape some of what

14
00:01:01,730 --> 00:01:08,908
became eminent can talk about some new
bypasses against it last year so we're

15
00:01:08,909 --> 00:01:14,130
going to look at the new protections
that were in Internet Explorer as it

16
00:01:14,130 --> 00:01:18,798
relates to use it for free and I'll talk
a little bit about all that so one thing

17
00:01:18,799 --> 00:01:23,100
I wanted to do real quick in case you're
not you know as up to speed on this

18
00:01:23,100 --> 00:01:26,699
whole memory corruption is just do a
real fast

19
00:01:26,700 --> 00:01:35,259
summary of the different attacks that
have been against various things like

20
00:01:35,259 --> 00:01:39,130
stacks matches that could be so if you
look at a real simple example you have

21
00:01:39,130 --> 00:01:43,908
you know like some local buffer and the
way that was exploited is when a stack

22
00:01:43,909 --> 00:01:48,229
frame is set up some delicious copy
created a situation where you could

23
00:01:48,229 --> 00:01:51,400
change return a pointer and the way that
was fixed

24
00:01:51,400 --> 00:01:57,009
was basically by the compiler can insert
a cookie and then thats check before and

25
00:01:57,009 --> 00:01:59,759
after the frame to make sure it's the
same so that's the reason I want to give

26
00:01:59,759 --> 00:02:03,640
some of his background as I want to I
want to think about okay if there's a

27
00:02:03,640 --> 00:02:07,140
problem with the way that code is
written in the way that code

28
00:02:07,140 --> 00:02:11,390
ultimately is compiled and employed such
that an attacker can change the flow of

29
00:02:11,390 --> 00:02:13,299
execution or something like that

30
00:02:13,300 --> 00:02:17,340
what are you know what are the similar
ways of the past where we've dealt with

31
00:02:17,340 --> 00:02:20,720
that and how does that shape how things
are happening in the future

32
00:02:20,720 --> 00:02:27,230
likewise we had a situation in the past
where cookies weren't any good anymore

33
00:02:27,230 --> 00:02:31,040
and one situation with that would be as
if you had a long very long Stack

34
00:02:31,040 --> 00:02:35,970
Overflow what you could do is a
traditional heat spray against a browser

35
00:02:35,970 --> 00:02:39,620
that was kinda popularly 2007 time frame
is you can basically fill up the heat

36
00:02:39,620 --> 00:02:42,410
with a whole bunch announcing show code
and then you could trigger a

37
00:02:42,410 --> 00:02:46,709
stackoverflow so long you hit the end of
the stack which caused an exception and

38
00:02:46,709 --> 00:02:50,709
you'd overwritten exception handling you
could go to year shoko down the heat

39
00:02:50,709 --> 00:02:55,590
just a cookie was never check because
the function returns so that was you

40
00:02:55,590 --> 00:02:59,590
sort of have a situation where we had a
problem with fix the problem however

41
00:02:59,590 --> 00:03:03,630
from again we see that over and over and
over again and that's kind of a thing i

42
00:03:03,630 --> 00:03:11,160
wana I want to think about but if you
had a slight debt maybe that would solve

43
00:03:11,160 --> 00:03:15,700
this issue rights for example that would
allow that code execution if so maybe we

44
00:03:15,700 --> 00:03:20,589
can solve it again until something like
Rob comes along and basically what the

45
00:03:20,590 --> 00:03:25,040
typical way to exploit Arab deal is okay
so we have depth which marks the stack

46
00:03:25,040 --> 00:03:30,870
your individual pages really stack or
heap memory which should only either be

47
00:03:30,870 --> 00:03:35,459
read write or read executed generally
not what you can do is an attacker's you

48
00:03:35,459 --> 00:03:38,730
have some people over for something you
can pick up the stack pointer off the

49
00:03:38,730 --> 00:03:43,470
stack under the heat and you can call
your code reuse attack which which are

50
00:03:43,470 --> 00:03:49,579
narrated program is one of those things
so if you're not familiar with Rob I

51
00:03:49,579 --> 00:03:52,430
don't have time to go over it but
basically to visualize what happens is

52
00:03:52,430 --> 00:03:56,070
you return to some location i
construction 7 you do something and then

53
00:03:56,070 --> 00:04:00,230
you hit a red which triggers the next
instruction sequence of gadgets colorado

54
00:04:00,230 --> 00:04:10,048
has kinda at work so no way we want to
deal with rob is essentially is such

55
00:04:10,049 --> 00:04:15,150
that you don't know the address of any
kind of actually work and you don't know

56
00:04:15,150 --> 00:04:17,370
the address of module you can't read it

57
00:04:17,370 --> 00:04:23,380
Roxy unfortunately its allies mansur
challenging to get right historically

58
00:04:23,380 --> 00:04:28,240
third-party libraries sales were slow to
adopt an opt-in protection like many

59
00:04:28,240 --> 00:04:32,229
newer Visual Studio protection is
another new Visual Studio protection

60
00:04:32,229 --> 00:04:36,320
concept she did it and I talked about a
five-time those tend to be upset because

61
00:04:36,320 --> 00:04:39,770
you changed that you had to deal with
existing code race so you have to

62
00:04:39,770 --> 00:04:46,849
account for legacy essentially other
there were other problems in other parts

63
00:04:46,850 --> 00:04:51,310
of shared memory that were known even if
all the deal allows opted-in and even

64
00:04:51,310 --> 00:04:54,880
recently if you look carefully at some
of the season coming out this last year

65
00:04:54,880 --> 00:05:00,300
some of them will say things like
resolve an issue with a sore and I won't

66
00:05:00,300 --> 00:05:04,010
go into much detail he looked like a
bulletin or something but it's clear

67
00:05:04,010 --> 00:05:07,340
that you know even now that still
challenging but it's getting better as

68
00:05:07,340 --> 00:05:14,570
long as pretty good now taken some time
so one of the things that came out to

69
00:05:14,570 --> 00:05:19,460
help deal with Rob on Windows platforms
anywhere where there's tools like any

70
00:05:19,460 --> 00:05:24,650
other types of basically what they are
as usual and anti exploit toolkit take

71
00:05:24,650 --> 00:05:28,270
protections were you injected yellow and
you do some extra magic which hopefully

72
00:05:28,270 --> 00:05:33,650
will notice a rocket attack and cut it
short from allowing it to finish and I

73
00:05:33,650 --> 00:05:37,570
talked about that your last year one of
the ways to get around some of what Emma

74
00:05:37,570 --> 00:05:42,030
does for example one of the protections
of the five projects an image

75
00:05:42,030 --> 00:05:46,789
basically would check to make sure that
the stack pointer was actually on the

76
00:05:46,789 --> 00:05:51,800
set it was called this the stack period
protector and so what we did to bypass

77
00:05:51,800 --> 00:05:56,410
that was basically just took our
employees came in on the stack and then

78
00:05:56,410 --> 00:05:59,460
we triggered whatever we need to do from
this tax so that the stack pointer we we

79
00:05:59,460 --> 00:06:03,299
could pivot away virtually unlimited
before we called whatever critically I

80
00:06:03,300 --> 00:06:08,780
was checked so that's basically the
background as far as that goes around

81
00:06:08,780 --> 00:06:18,330
lives on display and it and one of the
things this facilitated this continued

82
00:06:18,330 --> 00:06:24,948
abuse has been the bug card use after
free ok we'll talk about what he's after

83
00:06:24,949 --> 00:06:25,870
four years

84
00:06:25,870 --> 00:06:29,300
works and how we can maybe stop that is
what this whole time really is about so

85
00:06:29,300 --> 00:06:36,120
one sort of high-level slide is we think
about it which to stop an attack so if

86
00:06:36,120 --> 00:06:40,280
somebody is going to attack your
endpoint your laptop which employ writer

87
00:06:40,280 --> 00:06:46,190
whatever it is you're in point is your
your application could be coated in a is

88
00:06:46,190 --> 00:06:49,300
fired especially as far as this so I'm
really talking about memory corruption

89
00:06:49,300 --> 00:06:53,780
but she writes injecting code shoko
through some memory corruption you've

90
00:06:53,780 --> 00:06:56,469
got some other issue where somebody can
just walk up and there's no user and

91
00:06:56,470 --> 00:06:59,440
passwords and then I'm not really
talking about that race in a time of

92
00:06:59,440 --> 00:07:06,210
design books really a darkness sense but
mostly mostly directly tell you if it

93
00:07:06,210 --> 00:07:11,450
were coded in a safer language that
would help alot and be pretty easy if

94
00:07:11,450 --> 00:07:14,849
not maybe there's other things in code
you can do that you can use smart

95
00:07:14,850 --> 00:07:18,490
pointers or some other way to memory
manage the lifecycle of objects which

96
00:07:18,490 --> 00:07:23,910
would help with the user for free but if
not maybe a salon that will help if not

97
00:07:23,910 --> 00:07:27,190
maybe it will help it at this point
you're kind of in a bad situation

98
00:07:27,190 --> 00:07:32,500
because the attack is essentially
running at this point rates and injects

99
00:07:32,500 --> 00:07:36,730
a deal on your process licious attacker
injection coating process in there sort

100
00:07:36,730 --> 00:07:40,470
of fighting for equal ground and then
the absolute worst place to try to stop

101
00:07:40,470 --> 00:07:44,080
an attack on your host is basically
after the attack is runny you've got a

102
00:07:44,080 --> 00:07:47,190
viewer something that's going to notice
this attack that's running and shut it

103
00:07:47,190 --> 00:07:51,140
down and clear your computer I because
it's been proven time and time again

104
00:07:51,140 --> 00:07:55,780
that you know where can disable TV or
whatever it is race in this kind of the

105
00:07:55,780 --> 00:08:00,630
least ideal place to try to stop the
attack and it so I just kinda went out

106
00:08:00,630 --> 00:08:07,880
to make sure that I have some high level
stuff in my target well-known can get

107
00:08:07,880 --> 00:08:13,110
everything down in the weeds maybe I
remember at least similar stuff so what

108
00:08:13,110 --> 00:08:16,440
I really want to talk about today are
two new protections that came out to

109
00:08:16,440 --> 00:08:19,969
deal with use after free isolated even
delayed free so that's kinda

110
00:08:19,969 --> 00:08:26,409
what the topic of conversation really is
about and use it for free if you're

111
00:08:26,409 --> 00:08:31,789
following Operation snowman and
operation clandestine facts and all

112
00:08:31,789 --> 00:08:37,490
these ridiculous names of most of those
operations apt operation 47 and whatever

113
00:08:37,490 --> 00:08:42,469
we're facility by a user for free but in
a browser generally a year whatever so

114
00:08:42,469 --> 00:08:46,870
it's a big problem to make a long story
short in the way it works is you have an

115
00:08:46,870 --> 00:08:49,879
object in this object live somewhere in
memory

116
00:08:49,879 --> 00:08:52,699
presumably in your browser that's kind
of what I'm talking about mostly in this

117
00:08:52,699 --> 00:08:56,199
cause this protections are in IE rates
are really talking about the brothers

118
00:08:56,199 --> 00:09:02,479
right now and then gets somehow
unexpectedly free and it's not

119
00:09:02,480 --> 00:09:06,410
surprising that this happens in browser
because it is basically a disconnect

120
00:09:06,410 --> 00:09:10,050
between what happens in javascript and
with the browser is doing so the

121
00:09:10,050 --> 00:09:13,699
browser's got all these objects in code
instead of running and stuff and memory

122
00:09:13,699 --> 00:09:17,810
everything else goes connects to a web
page that webpage goes do this to do

123
00:09:17,810 --> 00:09:21,040
this right JavaScript it programatically
tells your browser what to do via

124
00:09:21,040 --> 00:09:25,170
javascript so there's a little bit as
disconnection of your browser allocates

125
00:09:25,170 --> 00:09:28,389
an object in somehow through JavaScript
you're able to free then you know that

126
00:09:28,389 --> 00:09:33,850
you can read you can refill that memory
with your own payload just by allocating

127
00:09:33,850 --> 00:09:40,189
stringer something it'll end up in that
same spot in alligators do that by the

128
00:09:40,189 --> 00:09:43,550
way in case you wonder why would an
independent Zach same spot the reason

129
00:09:43,550 --> 00:09:48,019
that happens is basically alligators
don't want memory Defragmenter just like

130
00:09:48,019 --> 00:09:51,009
with your old hard drives and stuff you
don't want it gets in your car driver

131
00:09:51,009 --> 00:09:55,069
files used to live you wanna like you
don't have to do that with a good

132
00:09:55,069 --> 00:09:58,849
allocated is basically it just freed
memory of like 50 bytes and somebody

133
00:09:58,850 --> 00:10:02,339
asked for fifty basis I have a whole
waiting for you right here so it's it's

134
00:10:02,339 --> 00:10:08,500
it's by the nature of the efficiency of
the allocated that this happens and then

135
00:10:08,500 --> 00:10:14,699
of course when you know the legitimate
code tries to call a method on there are

136
00:10:14,699 --> 00:10:17,959
direct which has now been essentially
changed underneath the hood when it

137
00:10:17,959 --> 00:10:21,680
tries to free it or anything like that
little bad things will happen in a

138
00:10:21,680 --> 00:10:26,189
society one of the three parameters that
we need to actually allows for next play

139
00:10:26,189 --> 00:10:28,780
to take place like an arbitrary read
writer or

140
00:10:28,780 --> 00:10:32,740
executed probably also is what you need
generally speaking today has yet to deal

141
00:10:32,740 --> 00:10:42,030
with a sign that so yeah like I said the
alligators are to facilitate this why

142
00:10:42,030 --> 00:10:47,430
does this really happened so otherwise
is this really happen is just the nature

143
00:10:47,430 --> 00:10:51,390
of complexity of code race if you think
about C++ code which is really what I'm

144
00:10:51,390 --> 00:10:55,340
talking about now in memory corruption
bugs in general people generally are

145
00:10:55,340 --> 00:10:58,940
trading C code for their cafeteria menu
or something like that right and what

146
00:10:58,940 --> 00:11:02,100
they should be if they are it's like oh
my gosh what are they doing this they

147
00:11:02,100 --> 00:11:08,680
should be using dotnet C sharp so they
don't you see it C++ at all just in

148
00:11:08,680 --> 00:11:12,620
general but it's still get used as you
have to use it you need it for kernels

149
00:11:12,620 --> 00:11:15,330
you need it for browsers you need it for
hypervisors you need it for all this

150
00:11:15,330 --> 00:11:18,230
crazy stuff that still get written in
all those things that are still getting

151
00:11:18,230 --> 00:11:22,890
written are very non-trivial
applications very complex and they have

152
00:11:22,890 --> 00:11:29,430
this impossibly complex life cycle of
objects essentially within so stuff gets

153
00:11:29,430 --> 00:11:34,130
created disappears stuff is being
allocated delegated all the time just

154
00:11:34,130 --> 00:11:37,500
depending on whether it's rendering your
pictures are fun who knows what's

155
00:11:37,500 --> 00:11:41,490
happening right based on whatever the
applications to its complex and so

156
00:11:41,490 --> 00:11:46,660
because of these complex workflows the
life cycle of objects is hard to account

157
00:11:46,660 --> 00:11:51,189
for its hard to pinpoint when these
objects should be alive when maybe it's

158
00:11:51,190 --> 00:11:56,270
valid for it to go and if it happens to
go before then use it again accidentally

159
00:11:56,270 --> 00:12:00,439
and that chick is a problem when using
what's called naked bear pointers are

160
00:12:00,440 --> 00:12:05,740
role players or owners I don't know if
it's determined that so you can use this

161
00:12:05,740 --> 00:12:08,890
other thing which is called smart
pointers which basically you know

162
00:12:08,890 --> 00:12:12,230
generally speaking if you allocated
objects with new then you need to delete

163
00:12:12,230 --> 00:12:16,440
it later but if you try to do something
in between which caused an exception

164
00:12:16,440 --> 00:12:20,860
which also try to double free basically
when you try to delete it is essentially

165
00:12:20,860 --> 00:12:25,160
use every 30 bad things could happen
where with a smart pointer the ideas

166
00:12:25,160 --> 00:12:29,310
that the object manage its own life
cycle and it'll go away when it goes out

167
00:12:29,310 --> 00:12:34,250
of scope is usually some scope so when
that routine finishes or whatever it is

168
00:12:34,250 --> 00:12:38,330
that I just goes away it happens go away
before that is fine as a reference count

169
00:12:38,330 --> 00:12:40,310
0

170
00:12:40,310 --> 00:12:46,500
ever try to go away again twice at least
Nancy idea but it's never quite that

171
00:12:46,500 --> 00:12:47,120
easy

172
00:12:47,120 --> 00:12:51,690
C++ everything sort of very complicated
smart pointers are supposed to help with

173
00:12:51,690 --> 00:12:55,680
this use every problem that they don't
know is for a lot of reasons some of the

174
00:12:55,680 --> 00:12:57,779
reasons might be dead

175
00:12:57,779 --> 00:13:01,960
Windows API is that you need to actually
use the record code aren't smart player

176
00:13:01,960 --> 00:13:08,230
friendly so they still lacks pointers
minutes past him to interferon into your

177
00:13:08,230 --> 00:13:12,040
smart pointers anyway in cities all
these these places in code where if you

178
00:13:12,040 --> 00:13:16,790
if you look through complex code bases
you go oh my gosh this is ugly and I can

179
00:13:16,790 --> 00:13:19,980
see why this didn't help and I can see
why that happened so one of the things

180
00:13:19,980 --> 00:13:23,339
that make yourself wanted to do was say
okay so you've got all these protections

181
00:13:23,339 --> 00:13:29,020
right we've got any we've got excellent
applicable to step over still haven't we

182
00:13:29,020 --> 00:13:34,640
need to do more and more is that it's
not that difficult at least conceptually

183
00:13:34,640 --> 00:13:40,589
to create another he you can just do you
know he create another show that

184
00:13:40,589 --> 00:13:43,779
basically on the next leg you just call
this function

185
00:13:43,779 --> 00:13:50,900
create and you've got a handle another
he so not a problem to keep your default

186
00:13:50,900 --> 00:13:56,370
whatever used to you can keep certain
things there and for other objects

187
00:13:56,370 --> 00:13:58,830
particular objects you had trouble with
in the past

188
00:13:58,830 --> 00:14:02,790
another heaping you can allocate those
objects today each such that if one of

189
00:14:02,790 --> 00:14:04,349
those goes away

190
00:14:04,350 --> 00:14:07,320
generally the north the normal way that
we attack and use after freeze by

191
00:14:07,320 --> 00:14:11,000
allocating a string in javascript or
something extremely abundant if he got

192
00:14:11,000 --> 00:14:16,100
the X thirty so even though this user
free problem don't necessarily get fixed

193
00:14:16,100 --> 00:14:20,089
from a crash or something in these you
can exploit it is kind of the idea

194
00:14:20,089 --> 00:14:29,589
behind early and there is a number if
you're familiar with the deal out the

195
00:14:29,589 --> 00:14:33,670
critical deal and I i message you know
that deal that's basically the deal

196
00:14:33,670 --> 00:14:37,319
either does everything I and these are
some of the objects that live in that

197
00:14:37,320 --> 00:14:45,940
dir Comm those are funny actually see
some examples and so what are the things

198
00:14:45,940 --> 00:14:48,769
I did was I wrote a Python script which
I released already

199
00:14:48,769 --> 00:14:54,230
that basically just enumerates the DBM
from either pro and just finds all the

200
00:14:54,230 --> 00:14:56,670
different applications and says these
are all the ones that live on the

201
00:14:56,670 --> 00:15:02,079
isolated heap size use all of the sites
you can answer to help you if you're

202
00:15:02,079 --> 00:15:06,299
trying to figure out you know this
example to C textarea element object

203
00:15:06,299 --> 00:15:11,019
used to be on the process he now it's a
nice lady but it's really easy to tell

204
00:15:11,019 --> 00:15:16,920
it's not hard because the symbols are
there essentially and you can see

205
00:15:16,920 --> 00:15:26,149
clearly that it's the same size just
nothing too crazy they're really so

206
00:15:26,149 --> 00:15:28,429
unfortunately that's not enough and
you'll see why

207
00:15:28,429 --> 00:15:33,429
to just separate the IIPs so they are so
basically just kinda like deficit great

208
00:15:33,429 --> 00:15:38,509
alone without insulin is deprecated need
both the same situation here you need

209
00:15:38,509 --> 00:15:41,439
both of these kind of working well
together for this actually had a

210
00:15:41,439 --> 00:15:46,969
positive effect on fixing the UAF
problem and delivery is the second of

211
00:15:46,970 --> 00:15:49,839
those two basically what happens
normally when you come here for you on

212
00:15:49,839 --> 00:15:54,110
an object is that objects released radio
and it's ready for you to come take that

213
00:15:54,110 --> 00:15:58,600
whole idea was delayed three is like
well if I'm about to release its object

214
00:15:58,600 --> 00:16:03,089
fine but let me hang on for a while and
just in case somebody else tries to grab

215
00:16:03,089 --> 00:16:07,199
it again real quick I'm just gonna hold
zeroed out so many tries to use it

216
00:16:07,199 --> 00:16:11,559
basically will have an interception
something tri-city reference value and

217
00:16:11,559 --> 00:16:18,249
so they're crash but there won't be any
possibility in the short term so I sort

218
00:16:18,249 --> 00:16:23,889
of came up with it with an analogy of
school school school ground children and

219
00:16:23,889 --> 00:16:28,899
the way I can have the analogy a sort of
used was basically you know you try to

220
00:16:28,899 --> 00:16:33,220
separate the good kids in the bag is at
sea isolated he already you can see that

221
00:16:33,220 --> 00:16:36,240
that's a hard problem because kids are
in generally good or bad it could be

222
00:16:36,240 --> 00:16:39,350
both someday maybe they're good monday
met in excess not it's not an easy thing

223
00:16:39,350 --> 00:16:45,929
to do and that's that problem is it
happening as well it's not always clear

224
00:16:45,929 --> 00:16:47,980
should this object live on the

225
00:16:47,980 --> 00:16:52,370
this year that it's not as easy to
clearly separate objects and then the

226
00:16:52,370 --> 00:16:55,290
delay everything is sort of like if all
the kids are standing in line to get

227
00:16:55,290 --> 00:16:59,510
inside the school and one of them has to
leave to go use the restroom or

228
00:16:59,510 --> 00:17:03,740
something the teacher basically says I'm
gonna watch this as kind of delayed for

229
00:17:03,740 --> 00:17:07,780
anything so that nobody knows where the
other kids when it was in my cut to get

230
00:17:07,780 --> 00:17:11,869
ahead of the other children but the
obvious issue there's that the teacher

231
00:17:11,869 --> 00:17:16,109
is limited resources and she can watch
that one spot forever so we can see that

232
00:17:16,109 --> 00:17:20,040
neither one of these approaches is
perfect but together maybe their health

233
00:17:20,040 --> 00:17:26,460
that's kind of the idea of combining
these two approaches so created on a per

234
00:17:26,460 --> 00:17:31,880
thread basis is an object called the
seat memory protect your and it holds

235
00:17:31,880 --> 00:17:35,850
essentially some metadata about the
total size of all the things were

236
00:17:35,850 --> 00:17:41,959
hanging onto for the delayed free and
basically it's a big list of all the

237
00:17:41,960 --> 00:17:46,170
blacks were holding onto the address on
the size and the last two bids at the

238
00:17:46,170 --> 00:17:50,650
address you used for other metadata as
well just like they do in actual

239
00:17:50,650 --> 00:17:59,110
alligators so it's sort of like a custom
custom emery the alligator really kind

240
00:17:59,110 --> 00:18:00,870
of think of it that way

241
00:18:00,870 --> 00:18:08,300
ok so what happens is basically there's
this protected free function which will

242
00:18:08,300 --> 00:18:13,980
run when you when you try to create when
you free and object and what happens is

243
00:18:13,980 --> 00:18:17,530
that if if the size of all the chunks
you have now is greater than 200,000

244
00:18:17,530 --> 00:18:24,879
bites that's when will the market
reclaim or if they're smart and reclaim

245
00:18:24,880 --> 00:18:34,710
flag sit or a lot of notes on this one
so basically will happen is when you

246
00:18:34,710 --> 00:18:39,690
when you free an object it'll look to
this list added to the total size added

247
00:18:39,690 --> 00:18:43,750
to the account of the things in the list
but it won't ever try to free the one

248
00:18:43,750 --> 00:18:46,610
you just add it now basically there
needs to be another sweet for that to

249
00:18:46,610 --> 00:18:53,030
happen and if it's an isolated chunks
that one will be set so make a long

250
00:18:53,030 --> 00:18:57,070
story short without getting bogged down
in all the details there's an over them

251
00:18:57,070 --> 00:19:02,970
housings are freed and these are some of
the details of it which had been made

252
00:19:02,970 --> 00:19:10,409
public on our blog so you can go and
slides later ok so likewise with the

253
00:19:10,409 --> 00:19:17,539
plane what what happens as well first
sort chunks that are in the list and

254
00:19:17,539 --> 00:19:21,658
then check to see if there's any
references to the chance that we want to

255
00:19:21,659 --> 00:19:26,500
free still on the stack and if there are
we won't actually free those are be

256
00:19:26,500 --> 00:19:34,879
marked so the reclaim walks basically
says the blocks that are in my list call

257
00:19:34,879 --> 00:19:40,019
this go ahead and actually free those if
they're not marked and sizes on so

258
00:19:40,019 --> 00:19:48,649
there's a certain situations and then
clear the bits gonna get real resettle

259
00:19:48,649 --> 00:19:52,418
do research on every block every time to
make sure to see you next time this

260
00:19:52,419 --> 00:19:57,639
routine is called either still pointing
to this piece of memory so should we

261
00:19:57,639 --> 00:20:01,379
basically it's kind of try to figure out
when do I really like going this memory

262
00:20:01,379 --> 00:20:05,480
and of course that has to happen

263
00:20:05,980 --> 00:20:08,929
unconditionally at some point otherwise
you end up in this situation of

264
00:20:08,929 --> 00:20:14,840
essentially a giant memory holding on
too much need to find it I go and so the

265
00:20:14,840 --> 00:20:20,370
main way that that happens is when this
stack frame for this current dreadfully

266
00:20:20,370 --> 00:20:25,039
unwinds to where it started and it knows
that whatever was being done by this

267
00:20:25,039 --> 00:20:33,330
piece of code is ben is done so I can I
can really see you and so that's

268
00:20:33,330 --> 00:20:37,120
basically what I call the potential
really that's the big findings from this

269
00:20:37,120 --> 00:20:41,408
research is the potential for a long
live reference to be to bypass these

270
00:20:41,409 --> 00:20:46,559
every protection so many short lived
references if you are inside of a

271
00:20:46,559 --> 00:20:53,029
function a big class member function or
whatever it is and you free pc memory

272
00:20:53,029 --> 00:20:57,960
and then inside of their you use it
again that's the typical UAF that

273
00:20:57,960 --> 00:21:02,559
happened last night that situation is
essentially protected because you still

274
00:21:02,559 --> 00:21:07,690
because you had a reference to that
object array of it is when it's tax free

275
00:21:07,690 --> 00:21:12,929
heard that that that that memory will
actually be free to that point but if

276
00:21:12,929 --> 00:21:15,990
it's not until basically a long time
later and that whole stack frames online

277
00:21:15,990 --> 00:21:21,059
you're not on that regime are you doing
something different then there's a

278
00:21:21,059 --> 00:21:24,269
potential for use after free to really
take place because it will have really

279
00:21:24,269 --> 00:21:33,250
been freed by that ok so how affected by
the protections basically what I did was

280
00:21:33,250 --> 00:21:39,710
look at four different UAS and that was
enough for me because digging into each

281
00:21:39,710 --> 00:21:43,750
use every Freiburg takes quite some time
and really when you doing research like

282
00:21:43,750 --> 00:21:48,059
this if you figure out what changed
between this protection that maybe you

283
00:21:48,059 --> 00:21:53,440
look at different bugs or something to
really get some statistical interesting

284
00:21:53,440 --> 00:21:59,289
years but is it a bit of a chance to set
up version of the browser and find the

285
00:21:59,289 --> 00:22:03,779
actual POC for that attack and figure
out how to figure out specific things to

286
00:22:03,779 --> 00:22:08,320
do this sort of testing I figure out
what object was being used it for free

287
00:22:08,320 --> 00:22:13,789
and where to happen basically where was
it allocated where was the fault

288
00:22:13,789 --> 00:22:18,429
location what was the size of the object
in question and what he did before and

289
00:22:18,429 --> 00:22:22,019
after protections that was kind of
things that I wanted to track and

290
00:22:22,019 --> 00:22:26,830
interestingly enough we see that two of
the four still live under 25 even after

291
00:22:26,830 --> 00:22:33,379
the isolated gives you an idea that
clearly separating this ad goes it is

292
00:22:33,379 --> 00:22:36,379
even as we go this is not always a
trivial thing right

293
00:22:38,820 --> 00:22:47,529
ok I think I said basically talking
about some of the features isolated

294
00:22:47,529 --> 00:22:59,889
using combination of bypass it's really
easy to Philip endless says that there's

295
00:22:59,889 --> 00:23:02,678
a hundred thousand by the way to be
freed so you can basically forced air

296
00:23:02,679 --> 00:23:09,210
conditioning JavaScript when everyone
writes event that's easy finding objects

297
00:23:09,210 --> 00:23:13,690
on both the isolated and which could be
of interest is relatively

298
00:23:13,690 --> 00:23:18,230
straightforward so that's not too heard
the only bit that's really quite hard to

299
00:23:18,230 --> 00:23:23,049
buy passes if you have a bug that uses
object shortly after it's free

300
00:23:23,049 --> 00:23:30,450
the delayed free really messes that up
so here's some javascript to you know

301
00:23:30,450 --> 00:23:34,009
basically make sure that there is a
hundred K by twenty unless you can just

302
00:23:34,009 --> 00:23:39,570
allocated one job so that's that birds
super trivial to you can create their

303
00:23:39,570 --> 00:23:48,230
situation anytime you on JavaScript
there were some other esoteric ideas as

304
00:23:48,230 --> 00:23:51,950
far as by passing this protection like
if you had some other corruption bug you

305
00:23:51,950 --> 00:23:56,840
could maybe change you can 0 references
on the staggers and if you have a really

306
00:23:56,840 --> 00:23:59,970
good corruption but you don't really
need to do this so

307
00:23:59,970 --> 00:24:03,790
I kind of stayed focused and really
trying to understand these protections

308
00:24:03,790 --> 00:24:11,350
as it related to what was taking place
here so let's look at a few bugs there

309
00:24:11,350 --> 00:24:20,990
was one few years back I guess the CMS
HMF ed objected basically in JavaScript

310
00:24:20,990 --> 00:24:25,390
you create you do you call this exact
come in and it creates the subject of a

311
00:24:25,390 --> 00:24:28,960
certain size really for this point is
you can replace it with whatever it was

312
00:24:28,960 --> 00:24:34,600
and then as an attacker you basically
set up your code malicious web page such

313
00:24:34,600 --> 00:24:38,679
that an event will get called right away
and then you wipe out the page with this

314
00:24:38,680 --> 00:24:46,410
document array which is and that free
then object and then when you return

315
00:24:46,410 --> 00:24:50,420
from the event and there you tried to
use the add again not realizing that

316
00:24:50,420 --> 00:24:56,430
it's a difficult situation has
essentially the crux of many of the UFC

317
00:24:56,430 --> 00:25:02,030
in browser land are somehow related to
avenge her something like that where you

318
00:25:02,030 --> 00:25:06,260
were about to do something in an open
gotta go do this things things change

319
00:25:06,260 --> 00:25:09,390
and then you go back to finish whatever
it is you're doing it now

320
00:25:09,390 --> 00:25:15,550
York State has has been sort of move in
a real simple POC of this would

321
00:25:15,550 --> 00:25:20,310
basically look like the body is unload
you can't function be which basically

322
00:25:20,310 --> 00:25:25,810
make sure that the object in question is
allocated and then the first thing it

323
00:25:25,810 --> 00:25:30,270
does is this select are so and select
which is the event so it is calling it

324
00:25:30,270 --> 00:25:34,360
created by the way he's like everything
and so when everything gets elected as

325
00:25:34,360 --> 00:25:37,729
basically the same thing is basically
manually selecting the whole web page

326
00:25:37,730 --> 00:25:42,670
with your mouse that same thing and then
as soon as of the select all takes place

327
00:25:42,670 --> 00:25:47,110
you do this document that right side
that select which basically erases the

328
00:25:47,110 --> 00:25:53,260
current structures inside the current
web page so it's it's basically like

329
00:25:53,260 --> 00:25:59,190
automating simple things I like the
leading a page short of what it's doing

330
00:25:59,190 --> 00:26:04,260
in a way to programmatically such that
by the way it seems you delete it you

331
00:26:04,260 --> 00:26:07,620
can force freeze spray which fills that
space back up with stuff

332
00:26:08,790 --> 00:26:16,370
that goes back to where it was then you
have the music and so so how do you wa s

333
00:26:16,370 --> 00:26:21,750
like if you're in charge of browser
crash or something and you're trying to

334
00:26:21,750 --> 00:26:24,910
figure out is exploitable are you want
to write an exploding Chinese figure out

335
00:26:24,910 --> 00:26:29,570
how these things really work what's the
process like behind you know where you

336
00:26:29,570 --> 00:26:35,000
can understand these kind of bugs are
basically step one is either a night of

337
00:26:35,000 --> 00:26:37,770
power went to bug you need to learn
something about the object figure out

338
00:26:37,770 --> 00:26:42,170
what the object is when it's sizes what
it does help you need to like this one

339
00:26:42,170 --> 00:26:49,950
reason that you it's been kind of a pain
because first security bugs like if you

340
00:26:49,950 --> 00:26:52,890
think back to like a simple stack
overflow or something where somebody

341
00:26:52,890 --> 00:26:55,880
just did an unmonitored copy or
something from a developer standpoint

342
00:26:55,880 --> 00:27:00,470
it's like I can fix that just change the
size to be smaller and make it as their

343
00:27:00,470 --> 00:27:05,090
end cap here like it fixes trivial right
from a developer standpoint but in these

344
00:27:05,090 --> 00:27:09,340
cases the defects may or may not be true
of you may still be difficult ready have

345
00:27:09,340 --> 00:27:12,800
the source code or not it may be
difficult when you get a crash of ok

346
00:27:12,800 --> 00:27:17,230
crash here I don't know why it crashed
here that's pretty typical you look at

347
00:27:17,230 --> 00:27:20,480
these sort of crashes when you first
look at another even if you add source

348
00:27:20,480 --> 00:27:24,630
code you go I'm not quite sure why the
program crashed at this point because

349
00:27:24,630 --> 00:27:28,960
there's some object lifecycle problem
yet to figure out what that was and so

350
00:27:28,960 --> 00:27:31,810
it's not really that much harder without
the code basically which is the

351
00:27:31,810 --> 00:27:37,440
candidate good point for the attacker so
it's kind of bad really from a selfish

352
00:27:37,440 --> 00:27:41,690
security standpoint these kind of pain
to deal with so you have to figure out

353
00:27:41,690 --> 00:27:45,970
what the object is and then you can use
some of these flags abilities in Windows

354
00:27:45,970 --> 00:27:48,240
particularly where you

355
00:27:48,240 --> 00:27:54,690
Aug flags dash III explorer.exe + HPA
which is the debug so basically saying

356
00:27:54,690 --> 00:27:58,140
every time this process runs the city
using the regular heap allocator used

357
00:27:58,140 --> 00:28:05,890
about also use extra stack trace as well
so then when you get a crash inside

358
00:28:05,890 --> 00:28:10,150
Winterberg you can do this command banki
bez Pradesh address you get extra

359
00:28:10,150 --> 00:28:14,800
information about the allocation
basically this address was allocated

360
00:28:14,800 --> 00:28:20,059
this call stack so you can figure out
this sequence event led to this tragic

361
00:28:20,059 --> 00:28:24,970
being created and then you can do the
same thing both the free and create you

362
00:28:24,970 --> 00:28:28,670
need to figure out this is generally how
is created this is generally how was

363
00:28:28,670 --> 00:28:32,760
free and this is where crashes in you
basically put all three of those stack

364
00:28:32,760 --> 00:28:37,570
trace is next to each other and you draw
line across where the same we're like

365
00:28:37,570 --> 00:28:40,250
the lowest common denominator where
they're all the same in and at the point

366
00:28:40,250 --> 00:28:43,300
above that line is where you can
actually begin to understand what where

367
00:28:43,300 --> 00:28:49,440
things went wrong so that's kind of the
debugging process so if we look at this

368
00:28:49,440 --> 00:28:55,710
crash for this particular bug in
Winterberg where we didn't have to the

369
00:28:55,710 --> 00:28:59,090
original anytime you see the word for
these next four examples the original

370
00:28:59,090 --> 00:29:03,760
just means we don't have isolated he
been delayed three hits as it was before

371
00:29:03,760 --> 00:29:07,809
those protections were put in place in
the original case we see that this bug

372
00:29:07,809 --> 00:29:11,678
worked in in work in this case is
basically I'm just showing that we have

373
00:29:11,679 --> 00:29:16,350
simply become set that we can control
their contents of the register or

374
00:29:16,350 --> 00:29:22,559
register to get Steve reference in this
case we see all these 3939 $39.99 and

375
00:29:22,559 --> 00:29:31,350
the white version of asking 900 39 and
we see that we can put that in there is

376
00:29:31,350 --> 00:29:35,959
such that it crashes on our control the
content but where the protections were

377
00:29:35,960 --> 00:29:40,590
put in place what happens is that pc
memory isn't being freed because

378
00:29:40,590 --> 00:29:44,189
Adelaide Street it's still being hung
onto in 20 now because one of the things

379
00:29:44,190 --> 00:29:51,700
we did in our algorithm is zeroed out
the memory go so you get these crashes

380
00:29:51,700 --> 00:29:54,100
that look like in this case

381
00:29:54,100 --> 00:30:02,939
ECX EAX the contents of whatever your ex
contains an apparently has no memory so

382
00:30:02,940 --> 00:30:08,270
that's pretty typical of a crash at
their previously if you found a crash

383
00:30:08,270 --> 00:30:10,410
like that you might have thought to
yourself this is a very interesting

384
00:30:10,410 --> 00:30:13,570
maybe not exploitable but now when you
see him and said I if you do if you're

385
00:30:13,570 --> 00:30:15,678
running a 95 others like that now

386
00:30:15,679 --> 00:30:18,960
now if you get a crash on another point
you might think to yourself maybe this

387
00:30:18,960 --> 00:30:22,210
is an interesting UAF that's just
crashing because the delayed three

388
00:30:22,210 --> 00:30:27,530
things you can do about that I think you
can actually disabled delivery for

389
00:30:27,530 --> 00:30:30,309
example as a registry setting or
something like that she could be just

390
00:30:30,309 --> 00:30:33,309
disable it so that you can get to carry
on as normal

391
00:30:36,220 --> 00:30:39,140
look at a few other bugs and see how
they did it go so here's another bug and

392
00:30:39,140 --> 00:30:43,480
I don't really want to spend time to
explain what he decides it doesn't

393
00:30:43,480 --> 00:30:47,789
really make a difference I just want to
explain the idea that fixed things in

394
00:30:47,789 --> 00:30:50,789
some situations but not in every
situation is kinda take away from this

395
00:30:50,789 --> 00:30:57,110
time so this book is similar to the
first in there without the protections

396
00:30:57,110 --> 00:31:01,750
we see that were able to get the value
11 22 33 44 which is just so you know i

397
00:31:01,750 --> 00:31:06,110
retrieve value that we control we're
able to get down into a pointer that can

398
00:31:06,110 --> 00:31:11,240
influence execution in some way but with
protection in place we again get a crash

399
00:31:11,240 --> 00:31:16,890
on now because the same situation memory
has been freed but it has actually been

400
00:31:16,890 --> 00:31:21,270
freed its just zeroed out and waiting in
this basically like a linked list chunks

401
00:31:21,270 --> 00:31:25,270
later get free by delivery when there's
no more references on the stack and you

402
00:31:25,270 --> 00:31:27,179
can see I'm doing this

403
00:31:27,179 --> 00:31:33,799
dashte 0800 whatever that's basically
just a surge in Winterberg looking for

404
00:31:33,799 --> 00:31:38,360
all the places that that shows up in
memory we can see that it showed up on

405
00:31:38,360 --> 00:31:42,280
the stack the recent results where it
was found in memory which means that it

406
00:31:42,280 --> 00:31:46,080
won't be released yet tell some critical
situation

407
00:31:47,330 --> 00:31:47,960
ok

408
00:31:47,960 --> 00:31:57,860
so in another bug of the of the four UF
bugs when we do a search we we see that

409
00:31:57,860 --> 00:32:03,159
it's actually not finding any results on
the stack which is so that's a good

410
00:32:03,160 --> 00:32:07,420
thing so maybe we could give we can get
something workable for the third but one

411
00:32:07,420 --> 00:32:12,700
thing that's different about it is it's
been changed from the one of the ones

412
00:32:12,700 --> 00:32:17,910
that had had its position changed which
is a good thing is very security goes so

413
00:32:17,910 --> 00:32:21,460
what you need to do is basically you're
gonna have to use my python script or

414
00:32:21,460 --> 00:32:24,730
some other technique to search through
all the applications available in a

415
00:32:24,730 --> 00:32:31,470
message about deal out they go to the
aid of that size but one of the

416
00:32:31,470 --> 00:32:34,660
questions I had was does it really need
to be the exact same size as the prior

417
00:32:34,660 --> 00:32:40,470
allegation because they're really limits
the potential objects you have maybe you

418
00:32:40,470 --> 00:32:44,540
only have like four choices then and
only one of them could have a lot of

419
00:32:44,540 --> 00:32:48,120
choices because you'd like to replace it
with an idea that you can fully control

420
00:32:48,120 --> 00:32:51,530
the more control you have a view object
used to replace it when it was gone the

421
00:32:51,530 --> 00:32:57,800
more the greater the chance of
exploitation is kinda so let's look at

422
00:32:57,800 --> 00:33:05,090
the final book in the final bug if you
look at the malicious Java HTML

423
00:33:05,090 --> 00:33:10,820
JavaScript type code that the kills the
browser it's basically real similar to

424
00:33:10,820 --> 00:33:14,770
the other one where we set up some
tricky situation where we allocate an

425
00:33:14,770 --> 00:33:19,280
object we apply the object to the down
in some way and then we somehow call

426
00:33:19,280 --> 00:33:26,830
some some situation arises I see sync
issue where we go off and do something

427
00:33:26,830 --> 00:33:35,550
against freedom we come back very
similar in that sense of the burgh in

428
00:33:35,550 --> 00:33:39,760
its very promising in the sense that at
the time of the crash when we do a

429
00:33:39,760 --> 00:33:46,020
search for that objects address the base
player that object we see that there is

430
00:33:46,020 --> 00:33:50,629
now no results that are which is really
good so it's probably do something

431
00:33:50,630 --> 00:33:58,200
and then in fact this one we were able
to bypass both free and isolated

432
00:33:58,200 --> 00:34:03,620
incident question is is pretty
interesting how how are you able to

433
00:34:03,620 --> 00:34:07,219
bypass both those with this particular
but what was different about it and the

434
00:34:07,220 --> 00:34:10,800
main thing that was different is that
this bug was based was long live so if

435
00:34:10,800 --> 00:34:13,639
you think back to how we defeated stack
that cheese rolling back to the

436
00:34:13,639 --> 00:34:18,179
beginning to talk about strategies how
do we defeated equities we didn't really

437
00:34:18,179 --> 00:34:21,620
defeats decades we just found a bug was
different such a step could you didn't

438
00:34:21,620 --> 00:34:27,069
matter you know so you can do many of
these protections you can defeat since

439
00:34:27,070 --> 00:34:31,250
essentially by a man in a situation
where there protections basically

440
00:34:31,250 --> 00:34:35,560
doesn't matter and that's essentially
what language do so this is this point

441
00:34:35,560 --> 00:34:39,719
lives way beyond the area where the
object is really use it you look at the

442
00:34:39,719 --> 00:34:44,439
the stack trace which we can do with
that name he has peed a shave his case

443
00:34:44,440 --> 00:34:48,250
easy access the average looking at if
you look at the call stack which led to

444
00:34:48,250 --> 00:34:53,629
this object being free you can find out
what it did actually go through the

445
00:34:53,629 --> 00:34:56,489
protected free routine that later was
actually freed using

446
00:34:56,489 --> 00:35:02,069
ante de la depre API which is normally
provided free eventually really did you

447
00:35:02,070 --> 00:35:06,390
read it later used after that we didn't
have to do anything tricky to set this

448
00:35:06,390 --> 00:35:11,089
situation outrageous happen based on the
nature of this so that's kind of an

449
00:35:11,090 --> 00:35:15,070
interesting thing one of the things
that's interesting about it

450
00:35:15,070 --> 00:35:19,230
to answer my other question is does the
object that we replace the original

451
00:35:19,230 --> 00:35:24,580
object have to be exact same size and
the answer is really no because the

452
00:35:24,580 --> 00:35:30,590
object gets used and then freed in later
used against subsides X 480 on the

453
00:35:30,590 --> 00:35:36,310
isolated he believes in the idea that we
used to replace it was of size 64 which

454
00:35:36,310 --> 00:35:41,720
normally would work but we'll see if
that works in the way the object is one

455
00:35:41,720 --> 00:35:47,180
of these area so you just do document
that create an area and then you said

456
00:35:47,180 --> 00:35:56,230
its shape rectangle then you can sets
which is basically 41 41 41 in a way

457
00:35:56,230 --> 00:35:59,130
that works is what's called coalescing
which is kind of an interesting thing

458
00:35:59,130 --> 00:36:03,300
that we've been talking about for about
15 years in the security industry is

459
00:36:03,300 --> 00:36:08,230
used a long time ago to exploit the
linkage between each chunks basically

460
00:36:08,230 --> 00:36:13,619
you could do heber for overflow outside
a town near your child can override the

461
00:36:13,619 --> 00:36:18,020
metadata which describe the next
challenge and then next time those were

462
00:36:18,020 --> 00:36:22,509
both freed the allocator itself would
basically look at the meditating though

463
00:36:22,510 --> 00:36:25,830
I need to collect these two and make him
one bigger piece and if you could

464
00:36:25,830 --> 00:36:31,080
actually exploited based on this case
that's not happening here it's not based

465
00:36:31,080 --> 00:36:36,630
on the pointer manipulation between he
checks but it's the same idea of again

466
00:36:36,630 --> 00:36:39,770
the other kid wants to make sure that
we're not fragmented memories so when it

467
00:36:39,770 --> 00:36:43,070
sees a bunch of these texts forties
together and be free a couple of min

468
00:36:43,070 --> 00:36:46,800
arose I can squish them in space
together way for that to happen then we

469
00:36:46,800 --> 00:36:50,440
alligator size 64 objectivity there'll
be room

470
00:36:50,440 --> 00:36:55,339
in that same spot if we properly groomed
he said that their condition is reliable

471
00:36:55,339 --> 00:37:00,460
Friday things could happen some other
allocations take place in between or

472
00:37:00,460 --> 00:37:02,790
something that might mess up here

473
00:37:02,790 --> 00:37:06,839
scheme which is why after carefully
groomed and make sure you do that on a

474
00:37:06,839 --> 00:37:11,170
timely manner so that nothing changes in
between but in this case anyway you

475
00:37:11,170 --> 00:37:15,030
could set up a situation where you can
allocate a bigger object which is kinda

476
00:37:15,030 --> 00:37:19,700
nice because that big object might
overlap smaller adequate means you can

477
00:37:19,700 --> 00:37:23,069
use the data members to selectively over
right even if he table point which is a

478
00:37:23,069 --> 00:37:28,130
top 20 in a C++ object which is normally
hard to control if you operate within

479
00:37:28,130 --> 00:37:34,420
the same exact same size you probably
can controls selectively over a what you

480
00:37:34,420 --> 00:37:47,589
want anyway yeah basically to summarize
UAS a bad they're fairly easy to exploit

481
00:37:47,589 --> 00:37:50,819
even though they sound really
complicated is very excited about him

482
00:37:50,819 --> 00:37:57,490
basically if you can figure out the
situation it's free and it's used again

483
00:37:57,490 --> 00:38:02,009
you can allocate some string in
javascript to be some malicious but

484
00:38:02,010 --> 00:38:05,579
certainly it's relatively
straightforward as far as expectations

485
00:38:05,579 --> 00:38:09,930
for these days anyway to begin with but
as far as exploitation goes relatively

486
00:38:09,930 --> 00:38:12,919
straightforward in so

487
00:38:12,920 --> 00:38:17,050
protection standpoint how can we make
our coach safer if you're right if you

488
00:38:17,050 --> 00:38:21,310
have to write C and C++ code what can
you do to guard against use after free

489
00:38:21,310 --> 00:38:24,869
because if you are ready to C C++ code
which a lot of people are actually still

490
00:38:24,869 --> 00:38:28,319
believe it or not today even though it's
like a fairly dangerous language in

491
00:38:28,319 --> 00:38:31,319
terms of hard to get right but if you're
doing any embedded system

492
00:38:32,190 --> 00:38:36,589
kernels and complicate any stuff like
that is still a lot of code being

493
00:38:36,589 --> 00:38:43,920
written so we should think about this
some of the things you can do again you

494
00:38:43,920 --> 00:38:47,910
can use some safer way of managing the
lifecycle of your objects really

495
00:38:47,910 --> 00:38:53,420
carefully be careful with that maybe you
smart pointers in your particular code

496
00:38:53,420 --> 00:38:59,800
base and maybe even you some ideas

497
00:39:00,650 --> 00:39:04,990
separating using separate Street certain
objects because it's actually not that

498
00:39:04,990 --> 00:39:09,319
hard to implement its not a terribly
difficult to implement even the delayed

499
00:39:09,319 --> 00:39:15,200
treating is not terribly difficult to
implement you can look closely have done

500
00:39:15,200 --> 00:39:21,689
so what what could have done in this
case to make this a little harder I

501
00:39:21,690 --> 00:39:28,060
think that the long live dangling
pointer is kind of a problem so you can

502
00:39:28,060 --> 00:39:31,500
hang out for every have to actually free
at some point you can't search like the

503
00:39:31,500 --> 00:39:35,089
entire memories base to see if there's
some pointers still around before you

504
00:39:35,089 --> 00:39:38,210
freak is that would just be too
expensive every time you about the three

505
00:39:38,210 --> 00:39:42,520
some of the things that they can do and
this is what I think I alluded to it

506
00:39:42,520 --> 00:39:47,089
begins to target CHG which is controlled
logo which is this idea of control-flow

507
00:39:47,089 --> 00:39:51,430
integrity and this is something that
you're seeing coming out very modern

508
00:39:51,430 --> 00:39:58,319
composed 2013 has it playing habits so
this is this idea basically saying if

509
00:39:58,319 --> 00:40:05,990
you're about to do an indirect costs of
any kind side of virtual function method

510
00:40:05,990 --> 00:40:12,098
from inside this object you shouldn't be
able to colleges anywhere you should be

511
00:40:12,099 --> 00:40:17,640
along a calm to these three or four
point is valid and cited the members of

512
00:40:17,640 --> 00:40:21,680
that object is kind of interesting
because actually that's that was it's

513
00:40:21,680 --> 00:40:26,200
it's basically the reverse of the idea I
had I don't know how many years ago that

514
00:40:26,200 --> 00:40:29,480
was for the for the Blue have prize
contest for some of the research that

515
00:40:29,480 --> 00:40:33,780
went into my rock protection idea was
basically the accident at which is when

516
00:40:33,780 --> 00:40:37,589
you return from a function you shouldn't
be able to willingly return anywhere in

517
00:40:37,589 --> 00:40:41,060
space you should only be able to return
to where you came from essentially it's

518
00:40:41,060 --> 00:40:44,580
that same idea of basically enforcing
some say

519
00:40:44,580 --> 00:40:47,880
where r you to return our call to it
shouldn't just be anywhere any address

520
00:40:47,880 --> 00:40:53,420
space you can actually implement systems
that you know enforce the integrity of

521
00:40:53,420 --> 00:40:57,650
the calls their returns it take place
the only question is at what cost rate

522
00:40:57,650 --> 00:41:02,720
how much does that impact performances
because we all know when it comes to

523
00:41:02,720 --> 00:41:05,980
security maybe you don't know if you've
ever worked for a company that develops

524
00:41:05,980 --> 00:41:13,620
software there's no customer priorities
that we need to ship right away there's

525
00:41:13,620 --> 00:41:17,339
some day we'll get to this and then
there's like security that was Sunday

526
00:41:17,340 --> 00:41:21,440
get to later after that so security is
unfortunately generally not priority

527
00:41:21,440 --> 00:41:26,610
number one for most any development
organization I've ever seen it so it's

528
00:41:26,610 --> 00:41:32,620
so my point is if the CFIA idea sounds
great but if it if it but if it's like a

529
00:41:32,620 --> 00:41:36,980
10 percent to perform its not gonna work
has to be so they found a way to

530
00:41:36,980 --> 00:41:40,840
basically do it in a limited fashion is
protected checking all returns but it's

531
00:41:40,840 --> 00:41:45,450
just checking certain types of indirect
calls that isn't doesn't have very much

532
00:41:45,450 --> 00:41:49,450
overhead it works pretty well and would
limit some of these types of attacks so

533
00:41:49,450 --> 00:41:56,620
there's one thing that could be down to
deal with these attacks more broadly

534
00:41:56,620 --> 00:42:04,339
instead of just having some isolated
protection against specifically so just

535
00:42:04,340 --> 00:42:06,780
to point out the obvious I was talking
about you have to tax in memory

536
00:42:06,780 --> 00:42:10,760
corruption today not other there's other
still out there floating around they

537
00:42:10,760 --> 00:42:18,360
could not related to you so just kind of
point out the obvious there yes you can

538
00:42:18,360 --> 00:42:25,700
implement these into clothes just had a
few short tight I guess closing one of

539
00:42:25,700 --> 00:42:29,470
the things that's interesting is it
having been in this field for 15 years

540
00:42:29,470 --> 00:42:34,509
you see this cycle of you know really
complicated attacks being the rage the

541
00:42:34,510 --> 00:42:38,050
rage in its like without getting
protector so let's just go back to like

542
00:42:38,050 --> 00:42:41,200
common people and asking for the user
pass or whatever it is easier ways to

543
00:42:41,200 --> 00:42:42,279
get in systems

544
00:42:42,280 --> 00:42:46,820
you kind of see that are still a little
bit and memory corruption is getting I

545
00:42:46,820 --> 00:42:53,490
think fairly difficult next year to be
quite difficult is still what you'll see

546
00:42:53,490 --> 00:42:56,709
is my prediction anyways your see more
of these like if you look at some of the

547
00:42:56,710 --> 00:43:00,640
seized from last year certainly there
were plenty of options related to UF's

548
00:43:00,640 --> 00:43:04,410
but there were also other types of bugs
leg from one terminal browser to the

549
00:43:04,410 --> 00:43:08,310
other you could break sop the same
origin policy so you can like steal a

550
00:43:08,310 --> 00:43:12,720
cookie from the cookie from Amazon or
something like that

551
00:43:12,720 --> 00:43:15,730
basically that breaks the model of
browsing if you can do stuff like that

552
00:43:15,730 --> 00:43:21,320
it's not memory corruption these are all
basically designed the same thing with

553
00:43:21,320 --> 00:43:25,820
another flower which allowed contents of
the clipboard to be read from JavaScript

554
00:43:25,820 --> 00:43:26,970
which is bad

555
00:43:26,970 --> 00:43:34,930
clipboard consumed god knows what
scenario in there is a really

556
00:43:34,930 --> 00:43:35,790
interesting topic

557
00:43:35,790 --> 00:43:39,810
CDI folks gave last year blackout where
they talked about breaking out of sand

558
00:43:39,810 --> 00:43:50,580
boxes using essentially in one case they
were talking about it interesting that I

559
00:43:50,580 --> 00:43:53,500
would highly recommend you go and check
out the research they did because it was

560
00:43:53,500 --> 00:43:59,440
some pretty good stuff and so my
prediction is a couple more years of

561
00:43:59,440 --> 00:44:06,610
memory corruption can kind of still
flying high like it's been for a while

562
00:44:06,610 --> 00:44:11,770
and probably you'll see a rise again and
that rise will basically be some

563
00:44:11,770 --> 00:44:16,080
innovation in that same space right
they'll be on their stack buffer

564
00:44:16,080 --> 00:44:20,640
overflow free take a few doubles match
whatever it is there's all these

565
00:44:20,640 --> 00:44:23,379
different bugs it kind of pop up
throughout the years it'll be popular

566
00:44:23,380 --> 00:44:27,450
for a while until we get something like
stack cookies are a sovereign debt

567
00:44:27,450 --> 00:44:32,810
crisis whatever it is that deals with
that category attack you see they're

568
00:44:32,810 --> 00:44:39,390
kinda hit her pattern continued well
into things interesting knows I think

569
00:44:39,390 --> 00:44:42,920
because of the prevalence like Dave said
this industry is harder on the company's

570
00:44:42,920 --> 00:44:46,010
know it's a problem everybody's can
important resources into this so you see

571
00:44:46,010 --> 00:44:51,440
the field moving faster than it was
historically so like in 1888 cookies

572
00:44:51,440 --> 00:44:54,609
came out fourteen years later or stack
buffer overflow

573
00:44:54,609 --> 00:44:57,769
in fourteen years later we got this
technology so it wasn't the quickest

574
00:44:57,769 --> 00:45:02,508
turnaround we're with you a yes we see
him coming out around 2008 and we see

575
00:45:02,509 --> 00:45:08,289
isolated he coming out six years later
so a little better we see the tension

576
00:45:08,289 --> 00:45:13,630
medications happening faster and faster
we kind of expected field is happening

577
00:45:13,630 --> 00:45:20,400
faster and faster and one of the things
that I just want to point out there is

578
00:45:20,400 --> 00:45:28,700
that the litigation doesn't come up when
there's only like a few isolated attacks

579
00:45:28,700 --> 00:45:32,578
taking place rates in 2008 for example
there were like some small number of

580
00:45:32,579 --> 00:45:39,480
kernels are not enough to really get
anybody's attention is actually you know

581
00:45:39,480 --> 00:45:44,509
redirecting 5 engineers inside of a
company till like actually come up and

582
00:45:44,509 --> 00:45:48,059
think about how should we create
isolated because it takes time it takes

583
00:45:48,059 --> 00:45:53,930
money it takes that takes testing and
implementing protection role in your

584
00:45:53,930 --> 00:45:57,399
product is not trivial but usually what
happens with these attacks as if you

585
00:45:57,400 --> 00:46:01,390
look at likely yes you see some critical
moment where there's a pain point

586
00:46:01,390 --> 00:46:05,848
holding its crossroads like okay these
things are really bothered so now we

587
00:46:05,849 --> 00:46:09,369
gotta do something about that you see
that same kind of cycle where Intel

588
00:46:09,369 --> 00:46:14,759
somethings painful enough in that makes
sense right makes sense for everybody he

589
00:46:14,759 --> 00:46:18,609
wouldn't put a key in your car your
friend or if there wasn't some so if

590
00:46:18,609 --> 00:46:23,308
there's not really much needed my not do
it so it's pretty typical situation you

591
00:46:23,309 --> 00:46:31,589
see in low-level code as well as kind of
a practical social situations and

592
00:46:31,589 --> 00:46:34,589
questions

593
00:46:37,230 --> 00:46:42,950
securities litigations or anything like
that if not be around later today in

594
00:46:42,950 --> 00:46:46,410
chatter at my training tomorrow and
Sunday

