1
00:00:03,520 --> 00:00:05,200
so greetings everyone today we're going

2
00:00:05,200 --> 00:00:07,279
to be talking about writing tiny

3
00:00:07,279 --> 00:00:09,840
stealthy and reliable malware

4
00:00:09,840 --> 00:00:13,040
so let's get started about who am i so i

5
00:00:13,040 --> 00:00:15,599
do offensive security infoset and this

6
00:00:15,599 --> 00:00:17,920
consists of working on our internal c2

7
00:00:17,920 --> 00:00:19,680
or writing ransomware or whatever

8
00:00:19,680 --> 00:00:22,160
payloads are we need to work for for our

9
00:00:22,160 --> 00:00:24,640
engagements and in my spare time i love

10
00:00:24,640 --> 00:00:26,320
most things low level

11
00:00:26,320 --> 00:00:29,279
this includes hardware assembly and

12
00:00:29,279 --> 00:00:32,399
primarily cbt plus plus and uh obviously

13
00:00:32,399 --> 00:00:33,760
you guessed this also ties in with

14
00:00:33,760 --> 00:00:35,280
writing malware and viruses i love

15
00:00:35,280 --> 00:00:37,120
everything about them i love reading

16
00:00:37,120 --> 00:00:39,120
stories about them love reverse

17
00:00:39,120 --> 00:00:40,399
engineering them

18
00:00:40,399 --> 00:00:43,200
and mainly i love writing them and most

19
00:00:43,200 --> 00:00:44,399
importantly something that's quite close

20
00:00:44,399 --> 00:00:46,399
to my heart is making blue teamers cry

21
00:00:46,399 --> 00:00:49,039
when blue teamers pay 250 000 pounds a

22
00:00:49,039 --> 00:00:52,000
year for an endpoint security solution

23
00:00:52,000 --> 00:00:54,320
and we're able to walk through their

24
00:00:54,320 --> 00:00:56,079
network and their devices without

25
00:00:56,079 --> 00:00:59,840
getting caught it's a great feeling

26
00:01:00,000 --> 00:01:02,000
so let's go through the agenda of

27
00:01:02,000 --> 00:01:03,520
today's talk and what we're going to be

28
00:01:03,520 --> 00:01:04,959
covering

29
00:01:04,959 --> 00:01:06,320
firstly we're going to go through why

30
00:01:06,320 --> 00:01:08,320
you actually want to bother writing

31
00:01:08,320 --> 00:01:10,720
malware what is it in it for you and

32
00:01:10,720 --> 00:01:11,840
then we'll be going through what it

33
00:01:11,840 --> 00:01:14,080
takes to actually get set up and start

34
00:01:14,080 --> 00:01:17,040
writing malware on windows then another

35
00:01:17,040 --> 00:01:18,799
important thing to have reliable malware

36
00:01:18,799 --> 00:01:21,360
is being able to subvert user land hooks

37
00:01:21,360 --> 00:01:22,720
this will be quite a critical part of

38
00:01:22,720 --> 00:01:24,240
our talk and we'll spend some time on

39
00:01:24,240 --> 00:01:26,400
that then we'll be go through various

40
00:01:26,400 --> 00:01:28,799
ways in order to subvert that static

41
00:01:28,799 --> 00:01:32,000
analysis and uh we'll go through

42
00:01:32,000 --> 00:01:35,119
cool things such as import hashing etc

43
00:01:35,119 --> 00:01:38,159
and then we go through the next steps of

44
00:01:38,159 --> 00:01:40,320
where and what resources you could use

45
00:01:40,320 --> 00:01:41,840
to further better your malware

46
00:01:41,840 --> 00:01:43,920
development career

47
00:01:43,920 --> 00:01:46,560
so motivations importantly firstly and

48
00:01:46,560 --> 00:01:48,880
most importantly is uh i'll let everyone

49
00:01:48,880 --> 00:01:52,600
settle down quickly first

50
00:01:55,759 --> 00:01:57,520
so as i was saying the most important

51
00:01:57,520 --> 00:01:59,600
thing is to have less detections being

52
00:01:59,600 --> 00:02:01,280
able to have less detections means that

53
00:02:01,280 --> 00:02:03,520
we can have an increased effectiveness

54
00:02:03,520 --> 00:02:05,759
for our campaigns and this means that we

55
00:02:05,759 --> 00:02:07,680
can have more shells for a longer

56
00:02:07,680 --> 00:02:10,639
duration and being able to uh

57
00:02:10,639 --> 00:02:12,560
act in the network for a long duration

58
00:02:12,560 --> 00:02:14,959
lets us do cooler things and

59
00:02:14,959 --> 00:02:16,400
move around more

60
00:02:16,400 --> 00:02:17,920
another important thing is as we've

61
00:02:17,920 --> 00:02:20,239
written the malwareby by ourselves is

62
00:02:20,239 --> 00:02:21,840
that we can have better client feedback

63
00:02:21,840 --> 00:02:23,280
we can give our clients potentially

64
00:02:23,280 --> 00:02:25,520
snippets of our source code so that they

65
00:02:25,520 --> 00:02:27,280
can better understand what actually the

66
00:02:27,280 --> 00:02:29,440
malware is doing and how it's able to uh

67
00:02:29,440 --> 00:02:31,280
abuse the systems

68
00:02:31,280 --> 00:02:33,120
and um another important thing is that

69
00:02:33,120 --> 00:02:34,720
we can learn something new hopefully by

70
00:02:34,720 --> 00:02:36,080
the end of this talk you'll be able to

71
00:02:36,080 --> 00:02:38,319
learn something youtube

72
00:02:38,319 --> 00:02:42,160
so now let's move on to get himself

73
00:02:42,480 --> 00:02:44,640
what language do we want to do

74
00:02:44,640 --> 00:02:47,040
malware is just malicious software so

75
00:02:47,040 --> 00:02:49,519
anything that is

76
00:02:49,519 --> 00:02:50,959
you can write software in you can write

77
00:02:50,959 --> 00:02:53,360
malicious software however we have a few

78
00:02:53,360 --> 00:02:54,959
constraints that we'll go through in the

79
00:02:54,959 --> 00:02:56,480
next talk

80
00:02:56,480 --> 00:02:58,400
but for example we've got quite a few

81
00:02:58,400 --> 00:03:00,080
languages such as assembly but this

82
00:03:00,080 --> 00:03:02,640
isn't 1990s and we don't really have the

83
00:03:02,640 --> 00:03:04,720
time to write malwa from assembly by

84
00:03:04,720 --> 00:03:06,959
hand then we've got c in c plus plus

85
00:03:06,959 --> 00:03:08,239
which have been great languages they've

86
00:03:08,239 --> 00:03:10,560
been around for about 50 years or a bit

87
00:03:10,560 --> 00:03:11,840
less

88
00:03:11,840 --> 00:03:13,360
and they're they're a bit higher level

89
00:03:13,360 --> 00:03:15,120
than assembly and they're great then

90
00:03:15,120 --> 00:03:17,440
you've got c sharp which isn't really

91
00:03:17,440 --> 00:03:19,920
like c plus plus or c and it's more

92
00:03:19,920 --> 00:03:21,280
something that microsoft wrote for

93
00:03:21,280 --> 00:03:22,480
themselves

94
00:03:22,480 --> 00:03:23,760
then you've got some newer languages

95
00:03:23,760 --> 00:03:27,120
such as rust golang and nim name is just

96
00:03:27,120 --> 00:03:29,680
transpiled down to c plus and rust and

97
00:03:29,680 --> 00:03:32,319
golang are a bit bigger newer languages

98
00:03:32,319 --> 00:03:33,760
and you've got python which is an

99
00:03:33,760 --> 00:03:35,280
interpreted language

100
00:03:35,280 --> 00:03:37,760
which is quite different

101
00:03:37,760 --> 00:03:39,840
so when it comes to writing malware

102
00:03:39,840 --> 00:03:41,680
you're going to have a few requirements

103
00:03:41,680 --> 00:03:43,760
the first requirement we have is ryan

104
00:03:43,760 --> 00:03:45,840
this is being it's more than 150

105
00:03:45,840 --> 00:03:48,000
kilobytes this might seem like a magic

106
00:03:48,000 --> 00:03:50,159
number i pulled out yeah but no it's

107
00:03:50,159 --> 00:03:52,080
something that um in the vault seven

108
00:03:52,080 --> 00:03:54,400
leaks by the cia they said ideally the

109
00:03:54,400 --> 00:03:57,040
malware should be under 150 kilobytes

110
00:03:57,040 --> 00:03:58,879
this means i will spend less time in the

111
00:03:58,879 --> 00:04:01,680
air and more time actually doing um on

112
00:04:01,680 --> 00:04:03,120
on the network

113
00:04:03,120 --> 00:04:05,120
and then if you look at rosco and rust

114
00:04:05,120 --> 00:04:07,599
and golang a simple hello world is 600

115
00:04:07,599 --> 00:04:09,519
kilobytes from rust and to about two

116
00:04:09,519 --> 00:04:11,599
megabytes in golan this means that

117
00:04:11,599 --> 00:04:13,519
instantly too big and they got getting

118
00:04:13,519 --> 00:04:16,399
the bin nim it's a bit uh it's a bit

119
00:04:16,399 --> 00:04:18,720
iffy because um 70 kilobytes for a

120
00:04:18,720 --> 00:04:20,798
simple hello world that gives us about

121
00:04:20,798 --> 00:04:22,639
eight kilobytes of

122
00:04:22,639 --> 00:04:24,720
room to write malware in which is a lot

123
00:04:24,720 --> 00:04:27,120
but then that can quickly uh go over the

124
00:04:27,120 --> 00:04:30,960
150 kilobyte limit ideally c about 11

125
00:04:30,960 --> 00:04:33,280
kilobytes for a simple hello world

126
00:04:33,280 --> 00:04:35,040
which is perfect we've got a lot of room

127
00:04:35,040 --> 00:04:37,440
to work with and it's it gives us the

128
00:04:37,440 --> 00:04:39,360
lowest level of and the greatest level

129
00:04:39,360 --> 00:04:41,360
flexibility

130
00:04:41,360 --> 00:04:42,800
then we want to have a language that

131
00:04:42,800 --> 00:04:44,639
gives us the ability to interact with

132
00:04:44,639 --> 00:04:46,880
the memory and invoke various windows

133
00:04:46,880 --> 00:04:48,080
apis

134
00:04:48,080 --> 00:04:48,880
this

135
00:04:48,880 --> 00:04:50,720
having malwa which isn't able to do this

136
00:04:50,720 --> 00:04:52,000
or a language which isn't able to do

137
00:04:52,000 --> 00:04:54,479
this makes our malware useless and

138
00:04:54,479 --> 00:04:56,479
it's not even it's not even able to do

139
00:04:56,479 --> 00:04:57,840
anything malicious

140
00:04:57,840 --> 00:04:59,520
and another critical thing is that we

141
00:04:59,520 --> 00:05:01,280
want to have no version specific

142
00:05:01,280 --> 00:05:03,039
dependencies for example you don't want

143
00:05:03,039 --> 00:05:05,840
to rely on the certain version of net or

144
00:05:05,840 --> 00:05:08,000
a certain version of a specific dll

145
00:05:08,000 --> 00:05:10,639
that's only available on an older or

146
00:05:10,639 --> 00:05:12,160
newer operating system version of

147
00:05:12,160 --> 00:05:13,600
windows

148
00:05:13,600 --> 00:05:15,199
and this allows us to uh maintain

149
00:05:15,199 --> 00:05:17,199
backwards compatibility

150
00:05:17,199 --> 00:05:19,039
so a lot of you may have never written c

151
00:05:19,039 --> 00:05:20,720
before and that's the language we're

152
00:05:20,720 --> 00:05:22,479
going to be going through with today's

153
00:05:22,479 --> 00:05:23,680
talk

154
00:05:23,680 --> 00:05:25,680
so i just wanted to introduce a simple

155
00:05:25,680 --> 00:05:27,360
hello world so that you can understand

156
00:05:27,360 --> 00:05:29,360
it at the top we're just including a

157
00:05:29,360 --> 00:05:31,680
header file this header file uh allows

158
00:05:31,680 --> 00:05:33,759
us to use various functions such as

159
00:05:33,759 --> 00:05:36,720
printf and we're passing the hello world

160
00:05:36,720 --> 00:05:38,800
string to this function

161
00:05:38,800 --> 00:05:41,120
and the main is the entry point of our

162
00:05:41,120 --> 00:05:43,039
code the supposed entry point of our

163
00:05:43,039 --> 00:05:44,000
code

164
00:05:44,000 --> 00:05:46,000
as you'll see and we can see the size is

165
00:05:46,000 --> 00:05:48,240
around uh 10 and a half kilobytes but

166
00:05:48,240 --> 00:05:50,080
this changes depending on which uh

167
00:05:50,080 --> 00:05:52,479
windows compiler you use

168
00:05:52,479 --> 00:05:54,479
so looking at a bit more detail at this

169
00:05:54,479 --> 00:05:56,400
hello world we can see that it's got an

170
00:05:56,400 --> 00:05:59,120
entropy of about 4.7 entropy is quite

171
00:05:59,120 --> 00:06:01,039
important as we'll come to see in later

172
00:06:01,039 --> 00:06:04,319
slides and it's got various imports

173
00:06:04,319 --> 00:06:06,479
you may be wondering what's this vc

174
00:06:06,479 --> 00:06:10,000
runtime 140. eol as your one it's it's

175
00:06:10,000 --> 00:06:11,759
about isn't going to be an issue for us

176
00:06:11,759 --> 00:06:13,520
is if you try running this binary on an

177
00:06:13,520 --> 00:06:15,199
older system well you're just going to

178
00:06:15,199 --> 00:06:17,199
get a pop-up saying what look you can't

179
00:06:17,199 --> 00:06:20,560
run it uh because this dll doesn't exist

180
00:06:20,560 --> 00:06:22,080
then we've got a bunch of sections in

181
00:06:22,080 --> 00:06:24,160
like this uh executable section and this

182
00:06:24,160 --> 00:06:27,039
x executable such as the text section

183
00:06:27,039 --> 00:06:29,039
and uh various other ones the most

184
00:06:29,039 --> 00:06:30,639
important thing for us right now is that

185
00:06:30,639 --> 00:06:32,160
the text section which contains the

186
00:06:32,160 --> 00:06:34,319
executable instructions

187
00:06:34,319 --> 00:06:36,000
if you want to have a play and do this

188
00:06:36,000 --> 00:06:38,160
by yourself i just published a script on

189
00:06:38,160 --> 00:06:41,360
github and it just requires pe file so

190
00:06:41,360 --> 00:06:43,520
once you've imported that uh once you've

191
00:06:43,520 --> 00:06:45,120
installed that with pip you can have a

192
00:06:45,120 --> 00:06:46,960
go by yourself

193
00:06:46,960 --> 00:06:48,560
so in our previous slide we talked about

194
00:06:48,560 --> 00:06:49,599
entropy

195
00:06:49,599 --> 00:06:53,120
so what exactly is entropy it's a

196
00:06:53,120 --> 00:06:55,440
measure of randomness how random are the

197
00:06:55,440 --> 00:06:58,080
bytes in your binary and it's uh often

198
00:06:58,080 --> 00:07:00,840
used by edrs and avs

199
00:07:00,840 --> 00:07:02,160
as a

200
00:07:02,160 --> 00:07:04,080
static indicator

201
00:07:04,080 --> 00:07:05,919
some edrs will use this for their

202
00:07:05,919 --> 00:07:07,360
machine learning which is essentially

203
00:07:07,360 --> 00:07:09,840
just if statements and they'll say if

204
00:07:09,840 --> 00:07:12,639
this uh binary's entropy is below or

205
00:07:12,639 --> 00:07:14,400
higher than a certain value do some

206
00:07:14,400 --> 00:07:16,639
things and often you'll find with pap

207
00:07:16,639 --> 00:07:18,880
malware their entropy is higher than

208
00:07:18,880 --> 00:07:20,160
seven

209
00:07:20,160 --> 00:07:22,160
and uh some people have come to me with

210
00:07:22,160 --> 00:07:24,479
solutions for fixing entropy by just

211
00:07:24,479 --> 00:07:26,319
concatenating the first chapter of harry

212
00:07:26,319 --> 00:07:27,440
potter

213
00:07:27,440 --> 00:07:29,280
as you can see with a notepad from

214
00:07:29,280 --> 00:07:31,360
system32 it's got an entropy of around

215
00:07:31,360 --> 00:07:32,319
um

216
00:07:32,319 --> 00:07:35,039
6.5 which is a normal entropy and uh

217
00:07:35,039 --> 00:07:37,360
it's good but if you see log bit black

218
00:07:37,360 --> 00:07:39,520
which is um a new ransomware sample that

219
00:07:39,520 --> 00:07:41,599
was recently uh produced by them it's

220
00:07:41,599 --> 00:07:44,160
got an entropy of 7.28 which is higher

221
00:07:44,160 --> 00:07:46,639
than seven and uh it's almost as an

222
00:07:46,639 --> 00:07:49,680
indicator that's probably malicious

223
00:07:49,680 --> 00:07:53,680
and um we saw the vc runtime 140. dol in

224
00:07:53,680 --> 00:07:55,680
our previous slide you may be wondering

225
00:07:55,680 --> 00:07:58,400
what is that so the crt is essentially

226
00:07:58,400 --> 00:08:00,800
the c runtime library and this will do a

227
00:08:00,800 --> 00:08:03,360
bunch of useful things for programs

228
00:08:03,360 --> 00:08:05,039
which compile with it for example will

229
00:08:05,039 --> 00:08:07,599
sell the global sch filter it will call

230
00:08:07,599 --> 00:08:09,919
uh constructors it will initialize

231
00:08:09,919 --> 00:08:10,840
global

232
00:08:10,840 --> 00:08:13,680
variables and this when our program

233
00:08:13,680 --> 00:08:15,280
actually enters

234
00:08:15,280 --> 00:08:17,440
our main what we said before our main

235
00:08:17,440 --> 00:08:19,520
isn't called first it first calls the

236
00:08:19,520 --> 00:08:22,639
win crt main and which will then uh call

237
00:08:22,639 --> 00:08:25,039
our thread entry point

238
00:08:25,039 --> 00:08:26,960
so the first way to get around this uh

239
00:08:26,960 --> 00:08:29,919
dependency of having this uh bc runtime

240
00:08:29,919 --> 00:08:32,559
is by going into the configuration of

241
00:08:32,559 --> 00:08:35,839
your uh visual studio solution and move

242
00:08:35,839 --> 00:08:38,479
selecting from multi-threaded dol to

243
00:08:38,479 --> 00:08:42,159
multi-threaded this however has some bad

244
00:08:42,159 --> 00:08:44,240
side effects for example first of all

245
00:08:44,240 --> 00:08:46,320
your size is massive we're at 138

246
00:08:46,320 --> 00:08:48,959
kilobytes it's about 120 kilobytes

247
00:08:48,959 --> 00:08:50,560
bigger that's not good

248
00:08:50,560 --> 00:08:51,920
so

249
00:08:51,920 --> 00:08:54,720
and it also still is important various

250
00:08:54,720 --> 00:08:56,640
functions from the current 42 and has a

251
00:08:56,640 --> 00:08:58,800
quite high entropy

252
00:08:58,800 --> 00:09:01,440
so let's take a step back let's now try

253
00:09:01,440 --> 00:09:04,399
actually get rid of the crt in a more

254
00:09:04,399 --> 00:09:06,399
suitable long-term solution which

255
00:09:06,399 --> 00:09:08,800
doesn't increase the size

256
00:09:08,800 --> 00:09:10,399
so first we want to tell the compiler

257
00:09:10,399 --> 00:09:13,040
look we don't want to use the spring crt

258
00:09:13,040 --> 00:09:14,800
anymore we want to go straight to our

259
00:09:14,800 --> 00:09:17,600
entry point we can do this by saying a

260
00:09:17,600 --> 00:09:19,760
comment to the compiler which tells it

261
00:09:19,760 --> 00:09:23,680
look use our entry point not the win crt

262
00:09:23,680 --> 00:09:25,680
and immediately our size is smaller and

263
00:09:25,680 --> 00:09:28,240
it's about 5.1 kilobytes and we've got

264
00:09:28,240 --> 00:09:30,399
only eight pi imports compared to the

265
00:09:30,399 --> 00:09:33,120
odd 70 or something inputs these imports

266
00:09:33,120 --> 00:09:35,519
are used to sell the global sch filter

267
00:09:35,519 --> 00:09:38,000
as you saw before

268
00:09:38,000 --> 00:09:40,720
so this slide is quite um overwhelming

269
00:09:40,720 --> 00:09:42,320
slide but i'll try to go through each

270
00:09:42,320 --> 00:09:44,000
step individually

271
00:09:44,000 --> 00:09:45,680
the first thing we want to do is disable

272
00:09:45,680 --> 00:09:48,399
c plus exceptions as if we're not going

273
00:09:48,399 --> 00:09:50,240
to be linking to the crt there's no way

274
00:09:50,240 --> 00:09:52,800
we can actually um use try catch as

275
00:09:52,800 --> 00:09:55,440
these are just wrapper functions for the

276
00:09:55,440 --> 00:09:57,440
sch handling

277
00:09:57,440 --> 00:09:59,360
as you saw before we're linking to

278
00:09:59,360 --> 00:10:02,000
kernel 32 the way to get around this is

279
00:10:02,000 --> 00:10:04,000
that we want to ignore all the default

280
00:10:04,000 --> 00:10:05,519
libraries so we're no longer linking to

281
00:10:05,519 --> 00:10:06,959
kernel 32

282
00:10:06,959 --> 00:10:08,800
and then you'll get a little error

283
00:10:08,800 --> 00:10:11,680
saying unroll resolved uh security check

284
00:10:11,680 --> 00:10:13,440
the way to get around this is that we

285
00:10:13,440 --> 00:10:15,680
then disable security checks and then

286
00:10:15,680 --> 00:10:18,240
the compiler will tell us oh no our sdl

287
00:10:18,240 --> 00:10:20,079
checks have been overwritten

288
00:10:20,079 --> 00:10:23,040
so for complete full for fullness we'll

289
00:10:23,040 --> 00:10:25,680
just disable sdl checks

290
00:10:25,680 --> 00:10:27,920
and the last step is optional if you

291
00:10:27,920 --> 00:10:29,600
ever actually are right malware and go

292
00:10:29,600 --> 00:10:31,760
through these stages you'll probably um

293
00:10:31,760 --> 00:10:34,000
if you innately use mem set you'll get a

294
00:10:34,000 --> 00:10:35,839
little notification saying memsay isn't

295
00:10:35,839 --> 00:10:38,240
defined so you need to define your own

296
00:10:38,240 --> 00:10:41,120
intrinsic function which overwrites the

297
00:10:41,120 --> 00:10:43,760
mem set which the compiler knows and

298
00:10:43,760 --> 00:10:45,440
when it gets around to that hopefully

299
00:10:45,440 --> 00:10:47,920
this will be of use to you

300
00:10:47,920 --> 00:10:49,920
so immediately let's go through the cons

301
00:10:49,920 --> 00:10:52,560
of removing the crt well we've got no

302
00:10:52,560 --> 00:10:54,800
more try catch uh c plus plus accepted

303
00:10:54,800 --> 00:10:56,880
we've also got no more sch

304
00:10:56,880 --> 00:10:59,920
handling this is quite inconvenient but

305
00:10:59,920 --> 00:11:02,160
it's not the end of the world

306
00:11:02,160 --> 00:11:04,160
as we no longer have a crt which can

307
00:11:04,160 --> 00:11:06,560
manage uh all the c plus plus virtual

308
00:11:06,560 --> 00:11:08,079
functions and we no longer have a

309
00:11:08,079 --> 00:11:10,399
virtual table we can no longer use pure

310
00:11:10,399 --> 00:11:12,160
virtual functions as there's no virtual

311
00:11:12,160 --> 00:11:14,800
table to look up against and easy to use

312
00:11:14,800 --> 00:11:17,920
crt functions such as string copy or

313
00:11:17,920 --> 00:11:21,519
memser or mem copy no longer available

314
00:11:21,519 --> 00:11:24,079
and then it is possible to get c plus

315
00:11:24,079 --> 00:11:26,000
plus constructors and deconstructors

316
00:11:26,000 --> 00:11:29,760
working but it's quite a pain and simply

317
00:11:29,760 --> 00:11:31,360
if you're writing malware you don't

318
00:11:31,360 --> 00:11:33,360
really need object oriented programming

319
00:11:33,360 --> 00:11:36,320
it's not necessary for our goal

320
00:11:36,320 --> 00:11:38,000
another great thing is that we're going

321
00:11:38,000 --> 00:11:40,000
to have a lower entropy and our file

322
00:11:40,000 --> 00:11:41,760
size is tiny now we're about 2.6

323
00:11:41,760 --> 00:11:44,320
kilobytes which is a a core of what we

324
00:11:44,320 --> 00:11:46,399
previously want

325
00:11:46,399 --> 00:11:48,640
now to actually have a

326
00:11:48,640 --> 00:11:51,600
full full uh hello world i want to show

327
00:11:51,600 --> 00:11:53,120
you a way that you can do hello world

328
00:11:53,120 --> 00:11:57,200
without using the printf from the crt so

329
00:11:57,200 --> 00:11:59,760
we define a macro which takes um a

330
00:11:59,760 --> 00:12:01,680
format string and a variable number of

331
00:12:01,680 --> 00:12:04,480
arguments with at the top line

332
00:12:04,480 --> 00:12:07,279
we can then uh allocate a buffer format

333
00:12:07,279 --> 00:12:08,880
the buffer and then write to the console

334
00:12:08,880 --> 00:12:11,200
and then through the respective buffer

335
00:12:11,200 --> 00:12:13,440
the reason why you may be asking why is

336
00:12:13,440 --> 00:12:16,320
it an if one block statement is because

337
00:12:16,320 --> 00:12:18,399
the if you want to call this macro

338
00:12:18,399 --> 00:12:19,920
multiple times

339
00:12:19,920 --> 00:12:21,600
well then the variable names will

340
00:12:21,600 --> 00:12:23,440
collide so this way we don't get

341
00:12:23,440 --> 00:12:26,000
colliding variable names

342
00:12:26,000 --> 00:12:27,760
and what's beautiful about this is that

343
00:12:27,760 --> 00:12:30,480
we can now correlate which import is

344
00:12:30,480 --> 00:12:33,440
being used where as we previously uh

345
00:12:33,440 --> 00:12:34,880
were having a bunch of useless imports

346
00:12:34,880 --> 00:12:36,320
we didn't know where they're being

347
00:12:36,320 --> 00:12:38,320
imported from we can now correlate for

348
00:12:38,320 --> 00:12:40,560
example if we have right console we can

349
00:12:40,560 --> 00:12:42,800
see where it's being imported from this

350
00:12:42,800 --> 00:12:46,480
way we can control what we're using

351
00:12:46,480 --> 00:12:48,399
so when it comes to writing malware

352
00:12:48,399 --> 00:12:49,600
you've got a bunch of other common

353
00:12:49,600 --> 00:12:51,839
functions for example if you you worried

354
00:12:51,839 --> 00:12:53,920
about malik or free

355
00:12:53,920 --> 00:12:56,880
well malik is just a wrapper for hepatic

356
00:12:56,880 --> 00:12:58,320
and the heap functions are just a

357
00:12:58,320 --> 00:13:00,320
wrapper for the virtual functions the

358
00:13:00,320 --> 00:13:01,920
virtual functions are just wrappers for

359
00:13:01,920 --> 00:13:04,320
nt functions as malware developers we

360
00:13:04,320 --> 00:13:05,760
want to use something that gives us the

361
00:13:05,760 --> 00:13:07,440
greatest level of granularity and

362
00:13:07,440 --> 00:13:09,519
control so why would you not just start

363
00:13:09,519 --> 00:13:11,519
at the bottom and allocate virtual

364
00:13:11,519 --> 00:13:12,800
memory as this gives us the greatest

365
00:13:12,800 --> 00:13:14,560
level of control

366
00:13:14,560 --> 00:13:15,760
if you don't believe me that some of

367
00:13:15,760 --> 00:13:17,279
these functions are just wrappers you

368
00:13:17,279 --> 00:13:19,440
can open them up in a disassembler and

369
00:13:19,440 --> 00:13:21,519
we can see that a free is just calling

370
00:13:21,519 --> 00:13:24,560
heat free with uh default arguments

371
00:13:24,560 --> 00:13:26,079
if you're wondering where you can find

372
00:13:26,079 --> 00:13:27,760
some of the reimplementations of these

373
00:13:27,760 --> 00:13:30,560
various functions such as string related

374
00:13:30,560 --> 00:13:33,040
functions and whatnot vx on the ground

375
00:13:33,040 --> 00:13:35,040
have a great repository which has a

376
00:13:35,040 --> 00:13:37,519
bunch of useless re-implemented windows

377
00:13:37,519 --> 00:13:40,000
functions and uh another project i've

378
00:13:40,000 --> 00:13:41,920
been piggybacking off piggybacking off

379
00:13:41,920 --> 00:13:44,240
for a long time is uac me and they've

380
00:13:44,240 --> 00:13:46,639
got a shared library which contains a

381
00:13:46,639 --> 00:13:49,040
lot of useful uh functions which i just

382
00:13:49,040 --> 00:13:51,519
uh like to use

383
00:13:51,519 --> 00:13:53,199
so now we know about how to actually

384
00:13:53,199 --> 00:13:55,199
control our inputs and have potentially

385
00:13:55,199 --> 00:13:57,519
a binary with no imports let's talk

386
00:13:57,519 --> 00:14:01,360
about how we can subvert hooks of eds

387
00:14:01,360 --> 00:14:03,760
so why do etis even bother hook in the

388
00:14:03,760 --> 00:14:05,040
user land if they can just sit in the

389
00:14:05,040 --> 00:14:07,760
kernel and do everything from the kernel

390
00:14:07,760 --> 00:14:10,240
so when edrs are monitoring us there are

391
00:14:10,240 --> 00:14:11,600
quite a few things they want to monitor

392
00:14:11,600 --> 00:14:13,600
for example they want to monitor what

393
00:14:13,600 --> 00:14:15,279
kind of network connection i'll be

394
00:14:15,279 --> 00:14:17,440
making what kind of files are we opening

395
00:14:17,440 --> 00:14:19,600
what kind of registries are we reading

396
00:14:19,600 --> 00:14:22,560
and writing to and which processes if

397
00:14:22,560 --> 00:14:24,240
our own or other processes are we

398
00:14:24,240 --> 00:14:26,800
creating and allocating memory in

399
00:14:26,800 --> 00:14:28,320
with kernel hooks

400
00:14:28,320 --> 00:14:30,240
you've got a higher chance of

401
00:14:30,240 --> 00:14:31,839
instability because there's more chance

402
00:14:31,839 --> 00:14:33,600
for something to go wrong and if there's

403
00:14:33,600 --> 00:14:35,920
um something goes wrong in the kernel

404
00:14:35,920 --> 00:14:37,120
well you're just going to get a blue

405
00:14:37,120 --> 00:14:38,959
screen of death and that's not great

406
00:14:38,959 --> 00:14:40,800
especially in a business environment a

407
00:14:40,800 --> 00:14:42,800
blue screen in business you if you're

408
00:14:42,800 --> 00:14:45,680
causing uh no serve if edr providers are

409
00:14:45,680 --> 00:14:47,519
causing denial of service for your

410
00:14:47,519 --> 00:14:49,680
customers well that's going to be a

411
00:14:49,680 --> 00:14:51,360
lawsuit on the way

412
00:14:51,360 --> 00:14:52,880
and if you're in the colonel you can

413
00:14:52,880 --> 00:14:54,959
you're going to have to be affirmative

414
00:14:54,959 --> 00:14:57,839
that this is uh this is positive um

415
00:14:57,839 --> 00:15:00,000
detection and that means that would be

416
00:15:00,000 --> 00:15:02,000
more false negatives

417
00:15:02,000 --> 00:15:04,959
and if uh and kernel edr lit has to

418
00:15:04,959 --> 00:15:06,720
monitor all of that that's really

419
00:15:06,720 --> 00:15:08,560
expensive and time in the kernel is

420
00:15:08,560 --> 00:15:10,399
incredibly expensive so it's a lot

421
00:15:10,399 --> 00:15:12,720
easier to go uh to just hook in the user

422
00:15:12,720 --> 00:15:16,560
land and um as it's a cheaper operation

423
00:15:16,560 --> 00:15:18,880
so let's go through the creation of a

424
00:15:18,880 --> 00:15:20,000
process

425
00:15:20,000 --> 00:15:22,560
when a process is created this will just

426
00:15:22,560 --> 00:15:25,839
innately call empty create user process

427
00:15:25,839 --> 00:15:28,320
which essentially just verifies that

428
00:15:28,320 --> 00:15:30,000
is the right image format and in this

429
00:15:30,000 --> 00:15:31,519
case we're only concerned with

430
00:15:31,519 --> 00:15:33,440
executables so it's verifying that it's

431
00:15:33,440 --> 00:15:36,240
an executable then in the kernel the

432
00:15:36,240 --> 00:15:38,160
address space for this process will be

433
00:15:38,160 --> 00:15:41,199
initialized pb the the pd will accept

434
00:15:41,199 --> 00:15:43,759
yourself and um ntdol will be mapped

435
00:15:43,759 --> 00:15:47,920
into this process ntdol is the first dll

436
00:15:47,920 --> 00:15:50,079
that's mapped into every process this is

437
00:15:50,079 --> 00:15:51,839
done at the kernel level there's no way

438
00:15:51,839 --> 00:15:54,800
around it it that is a must

439
00:15:54,800 --> 00:15:57,360
and eds can essentially use register to

440
00:15:57,360 --> 00:15:58,480
various

441
00:15:58,480 --> 00:16:00,959
callbacks that will notify them on

442
00:16:00,959 --> 00:16:02,959
certain events for example on the

443
00:16:02,959 --> 00:16:05,040
creation of a process or the mapping of

444
00:16:05,040 --> 00:16:08,720
a various dol or executables memory edrs

445
00:16:08,720 --> 00:16:11,199
will be notified by this and they can

446
00:16:11,199 --> 00:16:13,120
act correspondingly

447
00:16:13,120 --> 00:16:15,600
so for example if they subscribe to uh

448
00:16:15,600 --> 00:16:19,680
ps uh set create process notify when the

449
00:16:19,680 --> 00:16:21,519
initial thread of this new process is

450
00:16:21,519 --> 00:16:24,079
started the edl will be notified and

451
00:16:24,079 --> 00:16:27,199
then the edr can correspondingly inject

452
00:16:27,199 --> 00:16:30,079
various dll into um our process which

453
00:16:30,079 --> 00:16:32,480
can then hook for various functions

454
00:16:32,480 --> 00:16:35,279
as we can see here in an actual edr it

455
00:16:35,279 --> 00:16:37,360
loads um the rdl

456
00:16:37,360 --> 00:16:40,800
evr doll into our process

457
00:16:40,800 --> 00:16:41,519
so

458
00:16:41,519 --> 00:16:44,480
in that uh what is ntdol ntdol consists

459
00:16:44,480 --> 00:16:46,320
of a lot of important things such as

460
00:16:46,320 --> 00:16:48,560
native system calls and this allows us

461
00:16:48,560 --> 00:16:50,800
to interact with uh

462
00:16:50,800 --> 00:16:53,199
files and uh memory and do a lot of

463
00:16:53,199 --> 00:16:54,959
other important things it allows us to

464
00:16:54,959 --> 00:16:55,839
call

465
00:16:55,839 --> 00:16:56,959
cisco's

466
00:16:56,959 --> 00:16:58,800
so a life of a system called at the

467
00:16:58,800 --> 00:17:00,959
start of every cisco

468
00:17:00,959 --> 00:17:03,600
you will have move rcx into r10 the

469
00:17:03,600 --> 00:17:04,959
reason why it's doing this is because

470
00:17:04,959 --> 00:17:08,000
rcx is destroyed in the kernel space and

471
00:17:08,000 --> 00:17:10,240
r10 is a register that's just not used

472
00:17:10,240 --> 00:17:12,559
then you've got eight eight move 18 into

473
00:17:12,559 --> 00:17:15,039
the eax register this is

474
00:17:15,039 --> 00:17:17,760
essentially just the argument and 18 is

475
00:17:17,760 --> 00:17:20,000
quite an important number because these

476
00:17:20,000 --> 00:17:21,280
fiscal numbers

477
00:17:21,280 --> 00:17:23,039
and edr has if they're hooking our

478
00:17:23,039 --> 00:17:26,079
process they have to hook on the 18 and

479
00:17:26,079 --> 00:17:28,319
hide the 18 from us

480
00:17:28,319 --> 00:17:30,720
then you've got a test by pointer and

481
00:17:30,720 --> 00:17:32,559
it's dereferencing this memory location

482
00:17:32,559 --> 00:17:34,640
against one

483
00:17:34,640 --> 00:17:35,919
so essentially it's just checking if

484
00:17:35,919 --> 00:17:38,480
it's a 32-bit operating system or it's

485
00:17:38,480 --> 00:17:40,559
uh windows on windows and if it's a

486
00:17:40,559 --> 00:17:42,400
32-bit operating system it'll make the

487
00:17:42,400 --> 00:17:45,200
jump and if it's not it'll call cisco

488
00:17:45,200 --> 00:17:49,280
and what into e is just a 32-bit way of

489
00:17:49,280 --> 00:17:51,360
entering kernel mode

490
00:17:51,360 --> 00:17:53,919
so now let's look a bit at how edrs may

491
00:17:53,919 --> 00:17:56,160
uh actually hook our program so i was

492
00:17:56,160 --> 00:17:59,200
saying before if we move eax into 18 it

493
00:17:59,200 --> 00:18:01,200
has to hook on the first or second

494
00:18:01,200 --> 00:18:03,039
instruction so as we can see in this

495
00:18:03,039 --> 00:18:05,039
specific edr

496
00:18:05,039 --> 00:18:08,080
it has a jump into another location in

497
00:18:08,080 --> 00:18:12,559
uh an ntdol this is the e9 if the e9 is

498
00:18:12,559 --> 00:18:15,200
just an op code for a short jump

499
00:18:15,200 --> 00:18:17,280
then this jump goes to another jump uh

500
00:18:17,280 --> 00:18:20,160
and which is probably in the edr doll

501
00:18:20,160 --> 00:18:22,080
and this also at the same time they'll

502
00:18:22,080 --> 00:18:24,480
save the stacking of registers in order

503
00:18:24,480 --> 00:18:26,720
to determine the nature of the call

504
00:18:26,720 --> 00:18:28,960
and then once it's in the edr dol

505
00:18:28,960 --> 00:18:30,799
they'll determine whether the nature of

506
00:18:30,799 --> 00:18:32,880
this function call this cisco is

507
00:18:32,880 --> 00:18:34,720
malicious or not

508
00:18:34,720 --> 00:18:36,720
and then if the edr determines that it's

509
00:18:36,720 --> 00:18:39,120
not malicious they'll then restore the

510
00:18:39,120 --> 00:18:42,559
stack in the registers and uh move uh

511
00:18:42,559 --> 00:18:46,000
our rcx into r10 and then move 18 back

512
00:18:46,000 --> 00:18:48,000
into ex and then jump back to the test

513
00:18:48,000 --> 00:18:49,840
byte point to where the program will

514
00:18:49,840 --> 00:18:52,559
continue so as you can see the edrs have

515
00:18:52,559 --> 00:18:54,160
to hook on the first two lines of the

516
00:18:54,160 --> 00:18:57,200
code and uh if they don't well then

517
00:18:57,200 --> 00:18:59,200
they're just giving us away the cisco

518
00:18:59,200 --> 00:19:00,960
number which is if we have the cisco

519
00:19:00,960 --> 00:19:03,919
number we can just call it ourselves

520
00:19:03,919 --> 00:19:06,480
so now let's determine if our cisco is

521
00:19:06,480 --> 00:19:10,799
hooked so as we saw below 4c8bd1

522
00:19:10,799 --> 00:19:13,360
v8 though if we have those instructions

523
00:19:13,360 --> 00:19:15,280
those op codes we can essentially

524
00:19:15,280 --> 00:19:17,600
determine if a cisco is hooked or not

525
00:19:17,600 --> 00:19:20,160
those op codes are present in every

526
00:19:20,160 --> 00:19:21,520
cisco

527
00:19:21,520 --> 00:19:22,960
on windows

528
00:19:22,960 --> 00:19:24,880
because that same cisco stuff is used

529
00:19:24,880 --> 00:19:27,440
for every cisco if a cisco is hooked

530
00:19:27,440 --> 00:19:29,520
however the the fourth byte which is

531
00:19:29,520 --> 00:19:32,400
normally b8 it has now turned into e9

532
00:19:32,400 --> 00:19:35,039
which is a jump if we can determine if

533
00:19:35,039 --> 00:19:36,880
it's jumped well then it's probably

534
00:19:36,880 --> 00:19:39,440
hooked and we can do this with a simple

535
00:19:39,440 --> 00:19:40,960
memory comparison

536
00:19:40,960 --> 00:19:43,280
we as we can see we get the address of

537
00:19:43,280 --> 00:19:44,080
um

538
00:19:44,080 --> 00:19:46,000
whichever function we want for example

539
00:19:46,000 --> 00:19:48,080
empty allocate virtual memory and then

540
00:19:48,080 --> 00:19:51,919
we can then compare the address to our

541
00:19:51,919 --> 00:19:54,000
cisco stuff and then if it's not equal

542
00:19:54,000 --> 00:19:56,000
to zero which means they don't match we

543
00:19:56,000 --> 00:19:57,760
then determine that it is hooked down

544
00:19:57,760 --> 00:19:59,919
then we can return true if it does match

545
00:19:59,919 --> 00:20:01,440
then um

546
00:20:01,440 --> 00:20:03,280
we just return false we're indicating

547
00:20:03,280 --> 00:20:05,520
it's not her

548
00:20:05,520 --> 00:20:07,440
so now let's uh this isn't a great

549
00:20:07,440 --> 00:20:09,200
example but let's look into how we can

550
00:20:09,200 --> 00:20:11,440
use compiler optimizations to our

551
00:20:11,440 --> 00:20:14,559
advantage when we're using o1 which is

552
00:20:14,559 --> 00:20:17,840
uh favor size we can see that it's um

553
00:20:17,840 --> 00:20:19,360
calling memcom

554
00:20:19,360 --> 00:20:21,039
and it's not actually optimizing this

555
00:20:21,039 --> 00:20:22,720
which is uh quite weird i found it was

556
00:20:22,720 --> 00:20:25,440
quite weird however if you were to use

557
00:20:25,440 --> 00:20:26,640
um

558
00:20:26,640 --> 00:20:29,200
o2 which is to favor size the memcom's

559
00:20:29,200 --> 00:20:31,679
disappeared and it actually does um

560
00:20:31,679 --> 00:20:34,000
it actually compares the memory directly

561
00:20:34,000 --> 00:20:35,840
and it doesn't it lines it which is

562
00:20:35,840 --> 00:20:37,200
quite nice if you want to have a play

563
00:20:37,200 --> 00:20:40,159
with this i've provided a link to uh god

564
00:20:40,159 --> 00:20:41,919
bolt which is essentially a compiler

565
00:20:41,919 --> 00:20:45,679
explorer so you can have a look yourself

566
00:20:45,679 --> 00:20:48,799
so now we can uh change it instead of um

567
00:20:48,799 --> 00:20:51,679
doing a memcomp we can re reproduce what

568
00:20:51,679 --> 00:20:56,080
the o2 version did uh and essentially uh

569
00:20:56,080 --> 00:20:58,720
do replicate it here

570
00:20:58,720 --> 00:21:01,520
so if we want to do a memory comparison

571
00:21:01,520 --> 00:21:03,679
we can uh just get the address

572
00:21:03,679 --> 00:21:05,840
dereference it a u long is just the same

573
00:21:05,840 --> 00:21:08,400
as a d word so we typecast it to that

574
00:21:08,400 --> 00:21:11,200
and then d reference and compare against

575
00:21:11,200 --> 00:21:13,200
our memory stuff because in memory the

576
00:21:13,200 --> 00:21:18,320
b8 d1 ab4c is these bytes are the same

577
00:21:18,320 --> 00:21:20,640
and this is just a nice way to save a

578
00:21:20,640 --> 00:21:23,039
few bytes and avoid making them a

579
00:21:23,039 --> 00:21:25,280
function call

580
00:21:25,280 --> 00:21:27,679
so now if for example we're talking

581
00:21:27,679 --> 00:21:30,320
about the dot tech section which

582
00:21:30,320 --> 00:21:32,799
essentially contains the executable code

583
00:21:32,799 --> 00:21:34,240
this will contain all of the

584
00:21:34,240 --> 00:21:36,720
instructions in the ntdol

585
00:21:36,720 --> 00:21:39,120
and uh if an evr hooks it we can then

586
00:21:39,120 --> 00:21:41,520
determine that it's uh compromised if it

587
00:21:41,520 --> 00:21:44,080
is compromised uh we can see that

588
00:21:44,080 --> 00:21:47,200
instead of move eax 18 we've now got a

589
00:21:47,200 --> 00:21:49,919
jump into another location now if we

590
00:21:49,919 --> 00:21:52,880
want to unhook our ntdol which contains

591
00:21:52,880 --> 00:21:54,640
all the important functions we want to

592
00:21:54,640 --> 00:21:57,679
think about how we can replace the text

593
00:21:57,679 --> 00:21:59,200
section

594
00:21:59,200 --> 00:22:01,520
so we can just read the text section of

595
00:22:01,520 --> 00:22:02,880
the different look

596
00:22:02,880 --> 00:22:05,919
of a location off disk or a known

597
00:22:05,919 --> 00:22:08,799
safe place such as known dlls and uh

598
00:22:08,799 --> 00:22:10,320
just read it and replace the text

599
00:22:10,320 --> 00:22:13,760
section in our in our binaries

600
00:22:13,760 --> 00:22:16,880
so unhooking with no dols is um you've

601
00:22:16,880 --> 00:22:18,880
we've seen uh the technique was first

602
00:22:18,880 --> 00:22:20,480
found by people uh two great people

603
00:22:20,480 --> 00:22:23,679
modex and john uh jonas who found it uh

604
00:22:23,679 --> 00:22:25,919
exclusively at different times but

605
00:22:25,919 --> 00:22:27,440
there's some great people that have done

606
00:22:27,440 --> 00:22:29,360
great work regarding windows so i'd

607
00:22:29,360 --> 00:22:31,039
recommend following both of them but

608
00:22:31,039 --> 00:22:32,400
essentially the first thing we want to

609
00:22:32,400 --> 00:22:36,640
do is open the no dll section object

610
00:22:36,640 --> 00:22:38,720
this will return a pointer to us and

611
00:22:38,720 --> 00:22:41,440
then we can map this pointer iterate

612
00:22:41,440 --> 00:22:44,080
through the various sections in this uh

613
00:22:44,080 --> 00:22:46,240
point i did in this dol

614
00:22:46,240 --> 00:22:49,440
and get the size of this uh text section

615
00:22:49,440 --> 00:22:50,960
and the virtual address of the text

616
00:22:50,960 --> 00:22:53,600
section in our process

617
00:22:53,600 --> 00:22:56,000
and then set our text section for our

618
00:22:56,000 --> 00:22:59,039
ntdo to read write executable previously

619
00:22:59,039 --> 00:23:01,840
it's uh only read executable the reason

620
00:23:01,840 --> 00:23:03,520
we're setting it to right is so we can

621
00:23:03,520 --> 00:23:06,799
overwrite it with the text section of

622
00:23:06,799 --> 00:23:09,440
the anti-doll we manually mapped

623
00:23:09,440 --> 00:23:11,440
and once we've copied the memory we can

624
00:23:11,440 --> 00:23:13,840
restore the permissions and uh we've

625
00:23:13,840 --> 00:23:16,080
unhooked it so now let's go into that in

626
00:23:16,080 --> 00:23:18,000
a bit more detail

627
00:23:18,000 --> 00:23:20,159
so for this for this example we'll just

628
00:23:20,159 --> 00:23:22,240
be using file test which is a great tool

629
00:23:22,240 --> 00:23:24,400
to play around with files so as you can

630
00:23:24,400 --> 00:23:27,360
see in the top left corner where

631
00:23:27,360 --> 00:23:29,280
we're opening a section handle to learn

632
00:23:29,280 --> 00:23:32,159
dlls and tto

633
00:23:32,159 --> 00:23:34,159
we're then going to map this as you can

634
00:23:34,159 --> 00:23:36,480
see as you can see it works as we get a

635
00:23:36,480 --> 00:23:39,039
state of success and then we're going to

636
00:23:39,039 --> 00:23:41,039
one we're going to want to map it with

637
00:23:41,039 --> 00:23:43,279
anti-map view section this maps into our

638
00:23:43,279 --> 00:23:45,520
process memory and if you are listening

639
00:23:45,520 --> 00:23:49,039
before uh edrs can also get a callback

640
00:23:49,039 --> 00:23:51,279
when processes map dlls into this their

641
00:23:51,279 --> 00:23:54,240
memory however i don't think any egrs

642
00:23:54,240 --> 00:23:56,159
are currently detecting this so you

643
00:23:56,159 --> 00:23:57,760
should be good for now

644
00:23:57,760 --> 00:24:00,000
and then once we have mapped this we can

645
00:24:00,000 --> 00:24:02,240
uh click map data editor and then we can

646
00:24:02,240 --> 00:24:04,880
see the infamous mz header which

647
00:24:04,880 --> 00:24:06,400
indicates that this is a portable

648
00:24:06,400 --> 00:24:08,559
executable

649
00:24:08,559 --> 00:24:10,480
so now let's go through some code about

650
00:24:10,480 --> 00:24:11,679
um

651
00:24:11,679 --> 00:24:13,679
how we can actually replace it so the

652
00:24:13,679 --> 00:24:15,200
first thing we want to do is iterate

653
00:24:15,200 --> 00:24:16,960
through the various sections in our

654
00:24:16,960 --> 00:24:20,080
process and compare it to the dot text

655
00:24:20,080 --> 00:24:23,600
which is essentially the uh text section

656
00:24:23,600 --> 00:24:25,679
what you're seeing at the top is we're

657
00:24:25,679 --> 00:24:28,799
oring against ox 20 20 20 in order to

658
00:24:28,799 --> 00:24:30,480
lower case it and then we'll be

659
00:24:30,480 --> 00:24:34,159
comparing it to the little uh to until

660
00:24:34,159 --> 00:24:36,720
to the text section uh in respect to

661
00:24:36,720 --> 00:24:38,720
little engine the first four bytes of it

662
00:24:38,720 --> 00:24:41,039
once we've found the text section we can

663
00:24:41,039 --> 00:24:43,760
then uh set the right memory protections

664
00:24:43,760 --> 00:24:45,760
on it which is execute read write as i

665
00:24:45,760 --> 00:24:48,000
was talking about before and then we can

666
00:24:48,000 --> 00:24:48,880
copy

667
00:24:48,880 --> 00:24:50,559
the um

668
00:24:50,559 --> 00:24:54,240
the source which is the known dols into

669
00:24:54,240 --> 00:24:57,440
uh the destination which is rdo or ntdol

670
00:24:57,440 --> 00:24:59,520
and then restore the memory permissions

671
00:24:59,520 --> 00:25:01,279
we can then print a nice little helper

672
00:25:01,279 --> 00:25:03,360
message which indicates that we've

673
00:25:03,360 --> 00:25:06,400
unhooked um whichever dll from known

674
00:25:06,400 --> 00:25:09,120
dlos um

675
00:25:09,120 --> 00:25:11,600
so when we're doing this the various um

676
00:25:11,600 --> 00:25:13,279
indicators of compromise which we need

677
00:25:13,279 --> 00:25:15,039
to be careful of as i've talked about

678
00:25:15,039 --> 00:25:17,520
before anti-map view of section has an

679
00:25:17,520 --> 00:25:21,440
edr callback uh when uh we map a dll

680
00:25:21,440 --> 00:25:24,240
into our process and then anti-map view

681
00:25:24,240 --> 00:25:26,320
reception also might be hooked when we

682
00:25:26,320 --> 00:25:29,039
first initially call it so an edr might

683
00:25:29,039 --> 00:25:31,120
wonder why are we opening a mapping a

684
00:25:31,120 --> 00:25:35,200
section handle of known dll's ntdo

685
00:25:35,200 --> 00:25:37,120
we also might have the plain texturing

686
00:25:37,120 --> 00:25:40,880
of no dlc ntdr in our process and this

687
00:25:40,880 --> 00:25:42,880
is also quite bad however it's something

688
00:25:42,880 --> 00:25:45,600
that we can easily fix

689
00:25:45,600 --> 00:25:47,440
and then when we uh set the memory

690
00:25:47,440 --> 00:25:50,720
protections of ntdrl then we make them

691
00:25:50,720 --> 00:25:53,520
read write executable having these three

692
00:25:53,520 --> 00:25:55,679
permissions is a clear indicator of

693
00:25:55,679 --> 00:25:57,679
compromise however this is only for a

694
00:25:57,679 --> 00:26:00,080
short duration in the time

695
00:26:00,080 --> 00:26:03,039
between uh copying the memory

696
00:26:03,039 --> 00:26:04,880
then we've also got an open handle to

697
00:26:04,880 --> 00:26:07,120
know the lsnt dol and this is not

698
00:26:07,120 --> 00:26:09,679
something that normal processes do

699
00:26:09,679 --> 00:26:12,720
and then another ioc if you're looking

700
00:26:12,720 --> 00:26:15,440
back in this uh slide we saw status

701
00:26:15,440 --> 00:26:17,039
image not base

702
00:26:17,039 --> 00:26:19,760
and you can see that the address of uh

703
00:26:19,760 --> 00:26:22,559
in the data editor is a in the choose

704
00:26:22,559 --> 00:26:24,240
and we can see here yeah we've got

705
00:26:24,240 --> 00:26:26,720
another ntdl in our process with

706
00:26:26,720 --> 00:26:28,320
different memory permissions so this is

707
00:26:28,320 --> 00:26:31,600
uh we've got a few ioc's to worry about

708
00:26:31,600 --> 00:26:32,559
so

709
00:26:32,559 --> 00:26:34,960
we've got um if anti-mount view section

710
00:26:34,960 --> 00:26:38,080
is hooked um we can just use uh direct

711
00:26:38,080 --> 00:26:41,039
cisco which is that we can store the for

712
00:26:41,039 --> 00:26:43,440
example the 18 number but the respective

713
00:26:43,440 --> 00:26:45,120
cisco for antimatter central in our

714
00:26:45,120 --> 00:26:47,520
process and call it directly

715
00:26:47,520 --> 00:26:49,279
vx underground posted a great white

716
00:26:49,279 --> 00:26:50,720
paper on that course help called

717
00:26:50,720 --> 00:26:52,720
hellsgate which i recommend checking out

718
00:26:52,720 --> 00:26:54,880
i won't be diving into that too much and

719
00:26:54,880 --> 00:26:56,480
there are also great blog posts out

720
00:26:56,480 --> 00:26:57,679
there

721
00:26:57,679 --> 00:27:00,080
and yeah as i was saying um an issue

722
00:27:00,080 --> 00:27:01,919
with this is that we now install the

723
00:27:01,919 --> 00:27:04,559
cisco numbers or we need to dynamically

724
00:27:04,559 --> 00:27:06,320
resolve them and if we're dynamically

725
00:27:06,320 --> 00:27:08,400
resolving them then what's the point of

726
00:27:08,400 --> 00:27:09,600
just uh

727
00:27:09,600 --> 00:27:11,039
unhooking when you can just use the

728
00:27:11,039 --> 00:27:12,880
direct systems

729
00:27:12,880 --> 00:27:15,279
and then for the known dlls ngr static

730
00:27:15,279 --> 00:27:18,080
string we can just uh zoro it or

731
00:27:18,080 --> 00:27:20,000
encrypt it with an aes key so if you're

732
00:27:20,000 --> 00:27:21,760
encrypting it within the aes key then

733
00:27:21,760 --> 00:27:25,279
you've got an issue of a static key

734
00:27:25,919 --> 00:27:27,679
so now we want to iterate through the

735
00:27:27,679 --> 00:27:29,840
loaded modules because uh this gives us

736
00:27:29,840 --> 00:27:31,440
a lot more power for example if we

737
00:27:31,440 --> 00:27:34,240
wanted to uh unhook all the dolls even

738
00:27:34,240 --> 00:27:36,000
if they want hook so we just refresh all

739
00:27:36,000 --> 00:27:39,600
the text sections so in in the pb loader

740
00:27:39,600 --> 00:27:40,799
data

741
00:27:40,799 --> 00:27:43,760
structure it contains um

742
00:27:43,760 --> 00:27:45,200
a list entry and this entry is

743
00:27:45,200 --> 00:27:47,600
essentially a doubly linked list which

744
00:27:47,600 --> 00:27:50,399
we can iterate through in order to

745
00:27:50,399 --> 00:27:53,279
see various info various information so

746
00:27:53,279 --> 00:27:55,520
it's a common data structure that's uh

747
00:27:55,520 --> 00:27:56,880
this entry is a common data structure

748
00:27:56,880 --> 00:27:58,960
that's using the kernel

749
00:27:58,960 --> 00:28:00,880
we can then iterate through in-memory or

750
00:28:00,880 --> 00:28:02,960
the module list and then type cast

751
00:28:02,960 --> 00:28:06,159
backwards in order to gain um access to

752
00:28:06,159 --> 00:28:08,559
the loader data table entry and this

753
00:28:08,559 --> 00:28:12,000
gives us access to the dol name and the

754
00:28:12,000 --> 00:28:14,000
dol base which is quite important for us

755
00:28:14,000 --> 00:28:16,080
and there's a bunch of other information

756
00:28:16,080 --> 00:28:17,360
here

757
00:28:17,360 --> 00:28:19,279
the reason why you see reserve is

758
00:28:19,279 --> 00:28:21,600
because these are structure definitions

759
00:28:21,600 --> 00:28:24,320
i pulled off msdn and the microsoft

760
00:28:24,320 --> 00:28:26,640
don't really like giving us um full

761
00:28:26,640 --> 00:28:29,039
insight into what process is done but if

762
00:28:29,039 --> 00:28:31,200
you just search undocumented uh pb

763
00:28:31,200 --> 00:28:33,360
definitions or whatnot you'll be able to

764
00:28:33,360 --> 00:28:35,840
find um a reverse engineered version of

765
00:28:35,840 --> 00:28:37,279
this

766
00:28:37,279 --> 00:28:39,200
so now we can iterate through the

767
00:28:39,200 --> 00:28:40,960
loading modules so the first thing we

768
00:28:40,960 --> 00:28:43,760
want to do is grab a handle to the peb

769
00:28:43,760 --> 00:28:46,000
and get a handle to the head of the

770
00:28:46,000 --> 00:28:49,440
double linked list and the next entry

771
00:28:49,440 --> 00:28:51,679
we can then iterate through this by

772
00:28:51,679 --> 00:28:54,159
pointing her to the next value of the w

773
00:28:54,159 --> 00:28:55,840
link list and

774
00:28:55,840 --> 00:28:57,600
we can then just print out the name of

775
00:28:57,600 --> 00:29:01,039
the dll and the address base

776
00:29:01,039 --> 00:29:02,559
as you can see we're using the print

777
00:29:02,559 --> 00:29:04,880
macro i was talking about earlier and

778
00:29:04,880 --> 00:29:07,120
this uh as you can see here at the

779
00:29:07,120 --> 00:29:09,360
bottom i don't know if you can see but

780
00:29:09,360 --> 00:29:10,480
we've got the

781
00:29:10,480 --> 00:29:13,520
c which is actually crowdstrike's dll

782
00:29:13,520 --> 00:29:15,440
and uh it's the last yellow loaded into

783
00:29:15,440 --> 00:29:16,640
our process

784
00:29:16,640 --> 00:29:18,720
and you maybe yeah it's got weird names

785
00:29:18,720 --> 00:29:21,600
so let's move on

786
00:29:21,600 --> 00:29:23,679
so as i've talked about before we can

787
00:29:23,679 --> 00:29:26,399
now iterate through all the dlls and

788
00:29:26,399 --> 00:29:29,679
then unhook them all so we first try

789
00:29:29,679 --> 00:29:31,919
open that alone dll's section handle to

790
00:29:31,919 --> 00:29:33,760
it and if this works well then it's

791
00:29:33,760 --> 00:29:35,919
probably a windows dll if it doesn't

792
00:29:35,919 --> 00:29:38,480
work then it's probably an edr doll

793
00:29:38,480 --> 00:29:41,360
because eds can't hijack the known dl

794
00:29:41,360 --> 00:29:43,919
section directory once we've opened the

795
00:29:43,919 --> 00:29:45,360
section handle we can do what i was

796
00:29:45,360 --> 00:29:48,159
talking about before and just replace

797
00:29:48,159 --> 00:29:49,840
the text section

798
00:29:49,840 --> 00:29:51,840
if we do this for all the dols we're

799
00:29:51,840 --> 00:29:54,640
essentially refreshing them refreshing

800
00:29:54,640 --> 00:29:56,159
them and if there were any hooks in the

801
00:29:56,159 --> 00:29:58,720
text section well they'll no longer be

802
00:29:58,720 --> 00:30:00,480
there

803
00:30:00,480 --> 00:30:02,399
so now if we want to do this with a

804
00:30:02,399 --> 00:30:05,200
crowd strike well we can well there is

805
00:30:05,200 --> 00:30:07,039
code for this don't worry

806
00:30:07,039 --> 00:30:09,200
so we can see that we're able to unhook

807
00:30:09,200 --> 00:30:11,440
crowdstrike the crowdstrike i spoke with

808
00:30:11,440 --> 00:30:14,480
some guys there they say they're unable

809
00:30:14,480 --> 00:30:16,559
they're able to detect unhooking for

810
00:30:16,559 --> 00:30:18,799
some scenarios but for this it doesn't

811
00:30:18,799 --> 00:30:21,760
seem to detect and they may be able to

812
00:30:21,760 --> 00:30:24,320
scan the memory and see that it's been

813
00:30:24,320 --> 00:30:27,039
undetected but that's very hypothetical

814
00:30:27,039 --> 00:30:28,720
and i've never seen this being done in

815
00:30:28,720 --> 00:30:32,399
practice against uh various edrs

816
00:30:32,399 --> 00:30:34,880
so now we know how to unhook edrs let's

817
00:30:34,880 --> 00:30:37,120
go through uh some various ways to um

818
00:30:37,120 --> 00:30:40,880
get around static uh detections oh

819
00:30:40,880 --> 00:30:43,279
so operation security you need offset

820
00:30:43,279 --> 00:30:46,000
optic is fundamental for

821
00:30:46,000 --> 00:30:48,000
malware we essentially just don't want

822
00:30:48,000 --> 00:30:50,799
to open our mouth which is what opsec is

823
00:30:50,799 --> 00:30:53,039
and this means we don't want to have

824
00:30:53,039 --> 00:30:55,279
static strings which contain for example

825
00:30:55,279 --> 00:30:59,760
our c2ip or configuration information

826
00:30:59,760 --> 00:31:01,519
so as i was saying before yeah we can

827
00:31:01,519 --> 00:31:03,760
get around static detections prevent the

828
00:31:03,760 --> 00:31:06,320
disclosure of key critical information

829
00:31:06,320 --> 00:31:08,960
to our engagement so

830
00:31:08,960 --> 00:31:10,720
if a reverse engineer just runs strings

831
00:31:10,720 --> 00:31:13,039
against our binary and they get an array

832
00:31:13,039 --> 00:31:15,760
of information this is bad

833
00:31:15,760 --> 00:31:18,000
we can also prevent import hashing so i

834
00:31:18,000 --> 00:31:20,320
was talking about before we can import a

835
00:31:20,320 --> 00:31:22,159
bunch of uh functions from various

836
00:31:22,159 --> 00:31:25,679
windows dlls edrs can uh and avs can use

837
00:31:25,679 --> 00:31:27,600
import hashing in order to write

838
00:31:27,600 --> 00:31:29,679
signatures for example if we're

839
00:31:29,679 --> 00:31:32,720
importing various functions uh which are

840
00:31:32,720 --> 00:31:34,720
specific so for example if you're

841
00:31:34,720 --> 00:31:36,880
importing cryptography and file

842
00:31:36,880 --> 00:31:40,000
functions an edr may write

843
00:31:40,000 --> 00:31:42,559
an import hash rule which says this is

844
00:31:42,559 --> 00:31:44,080
probably ransomware

845
00:31:44,080 --> 00:31:45,679
and another great thing is that we can

846
00:31:45,679 --> 00:31:47,919
slow down and raise the bar for static

847
00:31:47,919 --> 00:31:49,440
analysis

848
00:31:49,440 --> 00:31:52,880
so we can use um what is api hashing so

849
00:31:52,880 --> 00:31:55,360
essentially we can pass a string to a

850
00:31:55,360 --> 00:31:57,440
well world craft function and this

851
00:31:57,440 --> 00:32:00,640
function will return essentially

852
00:32:00,640 --> 00:32:03,360
a number or like a specific hash for

853
00:32:03,360 --> 00:32:05,600
this string so for example this is the

854
00:32:05,600 --> 00:32:08,880
dj b2 which is um a pretty popular

855
00:32:08,880 --> 00:32:10,799
hashing algorithm used by a lot of

856
00:32:10,799 --> 00:32:13,039
malware and the

857
00:32:13,039 --> 00:32:14,720
eight 5381 is just a magic number which

858
00:32:14,720 --> 00:32:16,320
just seems to work with uh less

859
00:32:16,320 --> 00:32:19,519
collisions so we can use um hash string

860
00:32:19,519 --> 00:32:22,320
dj b2 and create some

861
00:32:22,320 --> 00:32:24,480
a macro for this so we can write uh

862
00:32:24,480 --> 00:32:26,720
hashes a lot quicker so we don't have to

863
00:32:26,720 --> 00:32:28,559
retype code

864
00:32:28,559 --> 00:32:31,279
to do this we'll be using const express

865
00:32:31,279 --> 00:32:33,279
const expressions which are compile-time

866
00:32:33,279 --> 00:32:36,080
calculated values so we stick this in

867
00:32:36,080 --> 00:32:38,399
front of our function and then we define

868
00:32:38,399 --> 00:32:40,159
our hash which takes essentially a

869
00:32:40,159 --> 00:32:41,039
string

870
00:32:41,039 --> 00:32:43,360
and uh we'll string i would

871
00:32:43,360 --> 00:32:47,039
calculate the hash of this string so by

872
00:32:47,039 --> 00:32:49,440
concatenating so for example if you

873
00:32:49,440 --> 00:32:51,039
wanted to hash nt allocate virtual

874
00:32:51,039 --> 00:32:52,960
memory you would just write hash empty

875
00:32:52,960 --> 00:32:54,799
allocated virtual memory this will

876
00:32:54,799 --> 00:32:56,640
create um

877
00:32:56,640 --> 00:32:59,440
the hash by under the name of hash ntlk

878
00:32:59,440 --> 00:33:01,679
virtual memory and tokenize essentially

879
00:33:01,679 --> 00:33:03,840
just turns anti-allocate virtual memory

880
00:33:03,840 --> 00:33:06,159
into a string this allows us to uh

881
00:33:06,159 --> 00:33:08,960
change the hashing algorithm quickly and

882
00:33:08,960 --> 00:33:11,279
change potential magic numbers if you're

883
00:33:11,279 --> 00:33:12,720
interested in our various hashing

884
00:33:12,720 --> 00:33:14,880
algorithms oa labs has actually

885
00:33:14,880 --> 00:33:16,880
presented um a great database which

886
00:33:16,880 --> 00:33:19,279
contains a lot of implementations of

887
00:33:19,279 --> 00:33:21,279
various hashing algorithms if you're

888
00:33:21,279 --> 00:33:23,279
also a reverse engineer i highly

889
00:33:23,279 --> 00:33:25,120
recommend checking that out as a if you

890
00:33:25,120 --> 00:33:27,919
ever do come up against important i'll

891
00:33:27,919 --> 00:33:30,640
probably uh give you a good hand

892
00:33:30,640 --> 00:33:33,440
so the previous example is where a lot

893
00:33:33,440 --> 00:33:36,240
of um api hashing examples would just

894
00:33:36,240 --> 00:33:38,399
normally stop and the implementations

895
00:33:38,399 --> 00:33:41,120
they provided were slow and uh not

896
00:33:41,120 --> 00:33:42,640
useful

897
00:33:42,640 --> 00:33:44,320
so the first thing if you wanted to have

898
00:33:44,320 --> 00:33:46,720
practical api hashing we want to create

899
00:33:46,720 --> 00:33:48,880
uh two structures the first structure is

900
00:33:48,880 --> 00:33:51,039
going to have a pointer to i know it's

901
00:33:51,039 --> 00:33:53,200
going to have the half value and then

902
00:33:53,200 --> 00:33:54,799
the next one is going to have a pointer

903
00:33:54,799 --> 00:33:56,640
to the base address

904
00:33:56,640 --> 00:33:59,039
which is like the dol base of

905
00:33:59,039 --> 00:34:02,159
where the dr is loaded in our process

906
00:34:02,159 --> 00:34:04,000
so we can then create an array of this

907
00:34:04,000 --> 00:34:06,080
structure and as i was talking about

908
00:34:06,080 --> 00:34:10,239
before hash nt dol is just uh defined by

909
00:34:10,239 --> 00:34:12,079
this uh hash function so we just pass

910
00:34:12,079 --> 00:34:15,119
ntdol to it and then we just initialize

911
00:34:15,119 --> 00:34:17,359
the value of the address with a null

912
00:34:17,359 --> 00:34:19,119
pointer

913
00:34:19,119 --> 00:34:21,520
so to our practical api hashing we then

914
00:34:21,520 --> 00:34:24,079
want to populate this uh structure with

915
00:34:24,079 --> 00:34:27,040
the required dol bases and uh we can

916
00:34:27,040 --> 00:34:29,280
iterate through the loaded dlls as i've

917
00:34:29,280 --> 00:34:31,599
talked about in a few slides ago

918
00:34:31,599 --> 00:34:34,879
uppercase the dol names because uh if

919
00:34:34,879 --> 00:34:36,800
you saw

920
00:34:36,800 --> 00:34:39,119
here for example that not all the dolls

921
00:34:39,119 --> 00:34:41,839
have the same casing for example ntdol

922
00:34:41,839 --> 00:34:44,800
is located while kernel 32 is up case it

923
00:34:44,800 --> 00:34:47,599
varies on various systems

924
00:34:47,599 --> 00:34:50,000
so if we consist for consistency

925
00:34:50,000 --> 00:34:52,399
reliability will up against them

926
00:34:52,399 --> 00:34:54,800
and then we'll hash these strings and

927
00:34:54,800 --> 00:34:57,599
then if the hash matches what's stored

928
00:34:57,599 --> 00:35:00,240
in this structure we'll then store it

929
00:35:00,240 --> 00:35:04,480
with overwriting uh the null pointer

930
00:35:04,480 --> 00:35:05,599
so

931
00:35:05,599 --> 00:35:07,599
the next step is uh for example we want

932
00:35:07,599 --> 00:35:09,440
to create a function to actually resolve

933
00:35:09,440 --> 00:35:11,520
the house for the hash

934
00:35:11,520 --> 00:35:13,839
returning the function address so we'll

935
00:35:13,839 --> 00:35:15,680
create a function called get proc

936
00:35:15,680 --> 00:35:18,480
address hash and this essentially takes

937
00:35:18,480 --> 00:35:20,079
a hash of the function we want to

938
00:35:20,079 --> 00:35:23,839
resolve and the hash of the module the

939
00:35:23,839 --> 00:35:25,359
module name

940
00:35:25,359 --> 00:35:27,200
we can then iterate through the module

941
00:35:27,200 --> 00:35:30,160
hashes if the hash exists we then set

942
00:35:30,160 --> 00:35:33,520
the uh address uh the base value to this

943
00:35:33,520 --> 00:35:35,680
um the module base

944
00:35:35,680 --> 00:35:36,960
and if it doesn't exist we'll just

945
00:35:36,960 --> 00:35:39,200
return no and in this case it'll

946
00:35:39,200 --> 00:35:41,200
probably just cause undefined behavior

947
00:35:41,200 --> 00:35:44,480
as we try to call a null value and then

948
00:35:44,480 --> 00:35:46,880
we can uh all dlls will have a bunch of

949
00:35:46,880 --> 00:35:49,280
exports we can and these exports have a

950
00:35:49,280 --> 00:35:51,440
bunch of uh information related to these

951
00:35:51,440 --> 00:35:55,920
functions such as the name um and uh the

952
00:35:55,920 --> 00:35:58,720
function base and the ordinal and

953
00:35:58,720 --> 00:36:00,560
in these exports we've got the number of

954
00:36:00,560 --> 00:36:02,000
names so we're going to iterate through

955
00:36:02,000 --> 00:36:05,520
the dll for the number of names and hash

956
00:36:05,520 --> 00:36:08,079
each and every name if this name matches

957
00:36:08,079 --> 00:36:10,880
the specified the function hash will

958
00:36:10,880 --> 00:36:13,359
then resolve the function address and

959
00:36:13,359 --> 00:36:15,760
then return this address

960
00:36:15,760 --> 00:36:17,920
so now because i'm lazy i like to make

961
00:36:17,920 --> 00:36:20,240
my manual development a lot more

962
00:36:20,240 --> 00:36:22,400
graceful and easier to do so we'll

963
00:36:22,400 --> 00:36:25,599
define a simple macro which takes the

964
00:36:25,599 --> 00:36:28,480
dol name and the function name and this

965
00:36:28,480 --> 00:36:30,240
will essentially

966
00:36:30,240 --> 00:36:34,320
uh return to us and the address and

967
00:36:34,320 --> 00:36:36,160
actually dynamically call it so for

968
00:36:36,160 --> 00:36:38,320
example as we can see in the bottom

969
00:36:38,320 --> 00:36:40,400
bottom image that for example if we want

970
00:36:40,400 --> 00:36:43,280
to call anti-protect virtual memory we

971
00:36:43,280 --> 00:36:46,400
just pass ntdol which is the perspective

972
00:36:46,400 --> 00:36:50,000
of dll this function is located in and

973
00:36:50,000 --> 00:36:53,520
uh we dynamically enable the result

974
00:36:53,520 --> 00:36:55,839
i then have hash func which will then

975
00:36:55,839 --> 00:36:59,119
create the function hash with um

976
00:36:59,119 --> 00:37:01,599
this function it will create the the

977
00:37:01,599 --> 00:37:03,680
half of this and then it will also

978
00:37:03,680 --> 00:37:06,320
create a type definition with the

979
00:37:06,320 --> 00:37:08,480
arguments passed so ent status is what

980
00:37:08,480 --> 00:37:10,880
it will return in the top example and

981
00:37:10,880 --> 00:37:12,960
the handle in a pure void are the two

982
00:37:12,960 --> 00:37:14,640
arguments so we'll create the required

983
00:37:14,640 --> 00:37:16,800
type then

984
00:37:16,800 --> 00:37:18,400
so before for example if you wanted to

985
00:37:18,400 --> 00:37:21,520
create a simple calculator process and

986
00:37:21,520 --> 00:37:23,520
this uh just pop a simple calculator

987
00:37:23,520 --> 00:37:25,680
with our credit process we can see that

988
00:37:25,680 --> 00:37:28,160
it will have two imports these are

989
00:37:28,160 --> 00:37:30,160
imports that we know and control and

990
00:37:30,160 --> 00:37:32,000
this is like with the crt stuff we were

991
00:37:32,000 --> 00:37:34,000
talking about before

992
00:37:34,000 --> 00:37:36,079
and if a reverse engineer was to throw

993
00:37:36,079 --> 00:37:38,640
this into a disassembler they can

994
00:37:38,640 --> 00:37:41,200
quickly identify what the process is

995
00:37:41,200 --> 00:37:42,960
doing

996
00:37:42,960 --> 00:37:45,440
and now if we're in to implement api

997
00:37:45,440 --> 00:37:47,040
hashing and um

998
00:37:47,040 --> 00:37:48,480
it quickly makes it a lot more

999
00:37:48,480 --> 00:37:50,240
compliment complicated and now we've

1000
00:37:50,240 --> 00:37:52,640
also got low imports which is fabulous

1001
00:37:52,640 --> 00:37:54,880
and we've also got a nice small size so

1002
00:37:54,880 --> 00:37:56,560
we're able to open up create a

1003
00:37:56,560 --> 00:37:58,720
calculator process without having any

1004
00:37:58,720 --> 00:38:01,760
imports with uh import hashing

1005
00:38:01,760 --> 00:38:04,240
however one bad thing is uh we've got

1006
00:38:04,240 --> 00:38:06,320
the plain text string which is uh

1007
00:38:06,320 --> 00:38:10,079
calc.exe and uh so i'm just guessing a

1008
00:38:10,079 --> 00:38:12,400
simple guess would be right and in

1009
00:38:12,400 --> 00:38:13,839
guessing that this is uh just boarding

1010
00:38:13,839 --> 00:38:15,599
the calculator shelf if you want to try

1011
00:38:15,599 --> 00:38:17,760
this out uh i publish the code for this

1012
00:38:17,760 --> 00:38:20,160
specific example on github i do

1013
00:38:20,160 --> 00:38:22,560
recommend checking that out

1014
00:38:22,560 --> 00:38:24,960
so now let's talk about uh stack strings

1015
00:38:24,960 --> 00:38:27,520
so for example if you've got um hello

1016
00:38:27,520 --> 00:38:29,680
world a quick easy way to get around

1017
00:38:29,680 --> 00:38:32,480
this is just creating an array and

1018
00:38:32,480 --> 00:38:34,480
having these strings stored in array so

1019
00:38:34,480 --> 00:38:37,599
when they're used they're just users um

1020
00:38:37,599 --> 00:38:39,440
by being pushed onto the stack for

1021
00:38:39,440 --> 00:38:42,720
example if we have um

1022
00:38:42,720 --> 00:38:45,119
a main function and this may we've got

1023
00:38:45,119 --> 00:38:47,440
two strings hello world zero uh and uh

1024
00:38:47,440 --> 00:38:50,480
hello world new line so we can see that

1025
00:38:50,480 --> 00:38:52,960
the hello world is um

1026
00:38:52,960 --> 00:38:55,359
is actually being used and stored as a

1027
00:38:55,359 --> 00:38:58,320
global variable while the uh the string

1028
00:38:58,320 --> 00:39:01,680
example is being used by um

1029
00:39:01,680 --> 00:39:03,520
being pushed onto the stack and this is

1030
00:39:03,520 --> 00:39:05,119
a lot better as the simple strings you

1031
00:39:05,119 --> 00:39:07,200
can see against our binary would would

1032
00:39:07,200 --> 00:39:09,359
not show up this uh string that we

1033
00:39:09,359 --> 00:39:12,640
decide as a stack string

1034
00:39:12,640 --> 00:39:14,480
so now let's use uh some of the features

1035
00:39:14,480 --> 00:39:17,200
of c plus plus in order to make our life

1036
00:39:17,200 --> 00:39:19,440
as our mouth developers easier so we can

1037
00:39:19,440 --> 00:39:21,839
create a template uh which takes a type

1038
00:39:21,839 --> 00:39:25,119
name for example w chart or chart and

1039
00:39:25,119 --> 00:39:27,520
the length of the string we can then

1040
00:39:27,520 --> 00:39:29,440
create a function that'll be calculated

1041
00:39:29,440 --> 00:39:31,440
at compile time

1042
00:39:31,440 --> 00:39:32,880
and this will essentially go through the

1043
00:39:32,880 --> 00:39:35,599
string and just uh zory against the

1044
00:39:35,599 --> 00:39:38,160
key that we previously defined and then

1045
00:39:38,160 --> 00:39:40,160
during uh when we want to use it we can

1046
00:39:40,160 --> 00:39:42,240
just call the obfuscate against it and

1047
00:39:42,240 --> 00:39:43,920
this will just return the uh the

1048
00:39:43,920 --> 00:39:46,160
obfuscated string

1049
00:39:46,160 --> 00:39:47,599
now that the office cases string will be

1050
00:39:47,599 --> 00:39:49,839
uh stored in m data

1051
00:39:49,839 --> 00:39:51,440
so if you want to have a random

1052
00:39:51,440 --> 00:39:55,520
part-time keys we can use the time

1053
00:39:55,520 --> 00:39:56,400
time

1054
00:39:56,400 --> 00:39:59,200
compiler i mean the time variable which

1055
00:39:59,200 --> 00:40:01,839
is essentially just uh the time of

1056
00:40:01,839 --> 00:40:03,680
time right now and the compiler

1057
00:40:03,680 --> 00:40:05,920
understands this and we can just use the

1058
00:40:05,920 --> 00:40:07,680
this is just a random function i grabbed

1059
00:40:07,680 --> 00:40:09,200
off um

1060
00:40:09,200 --> 00:40:11,280
off github and we could just use this to

1061
00:40:11,280 --> 00:40:13,680
generate random uh seeds which i just

1062
00:40:13,680 --> 00:40:16,880
use as a as a key with a key between 0

1063
00:40:16,880 --> 00:40:20,079
and 256.

1064
00:40:20,560 --> 00:40:22,640
so now if i wanted to make my life even

1065
00:40:22,640 --> 00:40:24,720
easier we can now implement this into

1066
00:40:24,720 --> 00:40:27,680
macros so we can define an off w for

1067
00:40:27,680 --> 00:40:29,920
white character strings and an op a for

1068
00:40:29,920 --> 00:40:32,079
a c g because on windows you've got y

1069
00:40:32,079 --> 00:40:33,680
character strings and

1070
00:40:33,680 --> 00:40:36,560
a c g for backwards compatibility so for

1071
00:40:36,560 --> 00:40:38,880
example our previous example of uh known

1072
00:40:38,880 --> 00:40:41,760
dll's ntdl that static string

1073
00:40:41,760 --> 00:40:45,040
that we can now wrap in the macro of w

1074
00:40:45,040 --> 00:40:47,119
and this will essentially just uh saw

1075
00:40:47,119 --> 00:40:49,520
the string at compile time with a random

1076
00:40:49,520 --> 00:40:51,920
key and then we when we want to use it

1077
00:40:51,920 --> 00:40:54,160
it will just decrypt it so a simple

1078
00:40:54,160 --> 00:40:56,160
string to get this against this will

1079
00:40:56,160 --> 00:40:57,599
never actually

1080
00:40:57,599 --> 00:40:59,680
show the medial string

1081
00:40:59,680 --> 00:41:02,000
if you're into interested in um

1082
00:41:02,000 --> 00:41:03,680
string obfuscation i highly recommend

1083
00:41:03,680 --> 00:41:06,160
checking out these two repositories uh

1084
00:41:06,160 --> 00:41:09,119
that uh ad of skater that guy did a sick

1085
00:41:09,119 --> 00:41:11,680
talk at black cat and he's got a amazing

1086
00:41:11,680 --> 00:41:14,000
white paper which goes with the talk and

1087
00:41:14,000 --> 00:41:15,920
a great repository which goes through a

1088
00:41:15,920 --> 00:41:17,920
lot more features than uh what you can

1089
00:41:17,920 --> 00:41:19,599
see here and i highly recommend checking

1090
00:41:19,599 --> 00:41:21,760
that out

1091
00:41:21,760 --> 00:41:23,520
so now i know you're all interested in

1092
00:41:23,520 --> 00:41:26,880
some code so on my github i've i've

1093
00:41:26,880 --> 00:41:28,000
shared um

1094
00:41:28,000 --> 00:41:30,000
a nice repository which hopefully you

1095
00:41:30,000 --> 00:41:32,319
can go through and uh documented all the

1096
00:41:32,319 --> 00:41:33,520
code

1097
00:41:33,520 --> 00:41:34,960
and most things in this talk i've

1098
00:41:34,960 --> 00:41:37,440
applied in this repository and this will

1099
00:41:37,440 --> 00:41:40,079
allow you to unhook all the dlls and

1100
00:41:40,079 --> 00:41:41,760
yeah as i'm saying it works with a

1101
00:41:41,760 --> 00:41:44,319
crowdstrike but crowdstrike don't really

1102
00:41:44,319 --> 00:41:45,839
detect it but they're not meant to

1103
00:41:45,839 --> 00:41:48,000
detect it even though they say they are

1104
00:41:48,000 --> 00:41:51,119
but you know how mdr vendors get and um

1105
00:41:51,119 --> 00:41:52,960
it's got a nice low entropy and it's got

1106
00:41:52,960 --> 00:41:54,960
no imports um

1107
00:41:54,960 --> 00:41:57,520
so i highly do recommend checking it out

1108
00:41:57,520 --> 00:42:00,000
and uh it's it's commented well so

1109
00:42:00,000 --> 00:42:01,920
hopefully uh you do understand if you do

1110
00:42:01,920 --> 00:42:04,079
have any questions uh just i'll be happy

1111
00:42:04,079 --> 00:42:06,160
to answer

1112
00:42:06,160 --> 00:42:09,119
so let's go through some key takeaways

1113
00:42:09,119 --> 00:42:12,319
unhooking is uh an easy task and um it's

1114
00:42:12,319 --> 00:42:13,680
good but it doesn't mean you're in the

1115
00:42:13,680 --> 00:42:16,240
clear for example edr vendors while it

1116
00:42:16,240 --> 00:42:18,720
is theoretical they may for example

1117
00:42:18,720 --> 00:42:21,359
place a few bytes at the start of the

1118
00:42:21,359 --> 00:42:23,440
text section which indicate when they

1119
00:42:23,440 --> 00:42:25,359
hook it and if they're scanning for

1120
00:42:25,359 --> 00:42:26,800
these bytes uh

1121
00:42:26,800 --> 00:42:28,319
and since we've replaced the text

1122
00:42:28,319 --> 00:42:30,640
section it shows that it's been unhooked

1123
00:42:30,640 --> 00:42:32,160
or there are various other ways to do

1124
00:42:32,160 --> 00:42:33,599
this

1125
00:42:33,599 --> 00:42:36,000
offset can uh not can start to be

1126
00:42:36,000 --> 00:42:38,240
achieved by office getting strings and

1127
00:42:38,240 --> 00:42:40,640
import hashing in order to hide what

1128
00:42:40,640 --> 00:42:43,599
we're actually doing and i i highly do

1129
00:42:43,599 --> 00:42:44,640
recommend

1130
00:42:44,640 --> 00:42:47,280
using these uh in your malware

1131
00:42:47,280 --> 00:42:50,079
and uh most importantly keep it simple

1132
00:42:50,079 --> 00:42:51,920
kiss keep it super simple the less you

1133
00:42:51,920 --> 00:42:53,680
have is the less room there is for

1134
00:42:53,680 --> 00:42:56,000
detection because if people start using

1135
00:42:56,000 --> 00:42:58,000
like if you start using a lot of code

1136
00:42:58,000 --> 00:43:00,640
and uh throwing copy pasting random code

1137
00:43:00,640 --> 00:43:02,880
of github into your project you might

1138
00:43:02,880 --> 00:43:05,200
you might actually just uh step on a

1139
00:43:05,200 --> 00:43:07,839
signature and get detected

1140
00:43:07,839 --> 00:43:10,319
so going forward if uh if you enjoyed uh

1141
00:43:10,319 --> 00:43:12,160
this talk or you you're interested in

1142
00:43:12,160 --> 00:43:13,760
writing malware the first thing i

1143
00:43:13,760 --> 00:43:15,920
recommend you do if you don't know c is

1144
00:43:15,920 --> 00:43:17,920
checking out the c programming language

1145
00:43:17,920 --> 00:43:21,440
this is a great book it's only 263 pages

1146
00:43:21,440 --> 00:43:24,400
and it consists of um yeah it will teach

1147
00:43:24,400 --> 00:43:25,920
you how to write c it's probably the

1148
00:43:25,920 --> 00:43:27,760
best book if you've never written uh any

1149
00:43:27,760 --> 00:43:30,480
code before to learn programming

1150
00:43:30,480 --> 00:43:31,839
then if you want to learn a bit about

1151
00:43:31,839 --> 00:43:34,240
reverse engineering dennis your chef has

1152
00:43:34,240 --> 00:43:36,240
published an amazing book it used to be

1153
00:43:36,240 --> 00:43:38,720
free now it's one uh requires a one

1154
00:43:38,720 --> 00:43:41,520
dollar donation and uh it's about it

1155
00:43:41,520 --> 00:43:42,960
teaches you different instruction

1156
00:43:42,960 --> 00:43:45,200
architectures and how to reverse and

1157
00:43:45,200 --> 00:43:47,440
various compiler optimizations

1158
00:43:47,440 --> 00:43:49,760
if you're interested in uh optimizing

1159
00:43:49,760 --> 00:43:52,160
your code agnofolk has a great five book

1160
00:43:52,160 --> 00:43:54,480
series which is um absolutely

1161
00:43:54,480 --> 00:43:57,119
mind-boggling and i highly recommend do

1162
00:43:57,119 --> 00:43:58,800
checking it out

1163
00:43:58,800 --> 00:44:00,319
now if you want to learn programming on

1164
00:44:00,319 --> 00:44:01,359
windows

1165
00:44:01,359 --> 00:44:03,680
purple uh he's got a great book windows

1166
00:44:03,680 --> 00:44:05,680
10 system programming he's also got a

1167
00:44:05,680 --> 00:44:07,599
corresponding uh one for the kernel

1168
00:44:07,599 --> 00:44:10,000
programming and they both have uh

1169
00:44:10,000 --> 00:44:13,760
associated uh second edition second part

1170
00:44:13,760 --> 00:44:14,880
if you're interested in windows

1171
00:44:14,880 --> 00:44:16,720
internals there's the windows internal

1172
00:44:16,720 --> 00:44:18,960
seventh edition part one i highly

1173
00:44:18,960 --> 00:44:20,000
recommend

1174
00:44:20,000 --> 00:44:21,839
at least reading chapters one through

1175
00:44:21,839 --> 00:44:23,920
three uh the rest of the chapters aren't

1176
00:44:23,920 --> 00:44:26,480
necessary just read them as you need and

1177
00:44:26,480 --> 00:44:28,720
uh most importantly vx underground has a

1178
00:44:28,720 --> 00:44:31,119
great malware uh with repository and

1179
00:44:31,119 --> 00:44:33,599
they consist of grey also great white

1180
00:44:33,599 --> 00:44:35,839
papers if you just read through all that

1181
00:44:35,839 --> 00:44:38,240
um and just uh actually try it out

1182
00:44:38,240 --> 00:44:40,240
you'll get a lot further than uh most

1183
00:44:40,240 --> 00:44:42,640
courses will take you

1184
00:44:42,640 --> 00:44:45,520
and uh that's it does anyone have any

1185
00:44:45,520 --> 00:44:48,960
yeah does anyone have any questions

1186
00:44:49,119 --> 00:44:51,760
yeah i i enjoyed the talk thank you so

1187
00:44:51,760 --> 00:44:54,160
if you if you don't use the crt and you

1188
00:44:54,160 --> 00:44:55,839
don't really have any imports doesn't

1189
00:44:55,839 --> 00:44:58,078
matter

1190
00:44:58,319 --> 00:45:00,160
yeah yeah sure it looks suspicious but

1191
00:45:00,160 --> 00:45:02,480
then we can control we can actually just

1192
00:45:02,480 --> 00:45:04,400
choose to import various functions like

1193
00:45:04,400 --> 00:45:07,119
um just use them uselessly and those

1194
00:45:07,119 --> 00:45:09,200
will they'll be imported correspondingly

1195
00:45:09,200 --> 00:45:11,920
so yeah it does look suspicious but uh

1196
00:45:11,920 --> 00:45:13,680
it's better than having

1197
00:45:13,680 --> 00:45:15,839
uh a lot more imports which potentially

1198
00:45:15,839 --> 00:45:17,680
could look more suspicious so if we can

1199
00:45:17,680 --> 00:45:19,839
have no work from no imports and then

1200
00:45:19,839 --> 00:45:21,760
build the ground up

1201
00:45:21,760 --> 00:45:26,200
it works a lot better yeah

1202
00:45:33,680 --> 00:45:35,520
uh potentially but

1203
00:45:35,520 --> 00:45:37,280
a lot of you know a lot of processes

1204
00:45:37,280 --> 00:45:39,920
might map these dols so and

1205
00:45:39,920 --> 00:45:42,079
yeah i haven't seen yeah it could but i

1206
00:45:42,079 --> 00:45:44,839
haven't seen it been done yeah

1207
00:45:44,839 --> 00:45:49,759
yep um you had a slide for a fine base

1208
00:45:52,880 --> 00:45:54,480
yeah the keys change every time you

1209
00:45:54,480 --> 00:45:55,599
compile

1210
00:45:55,599 --> 00:45:57,680
so

1211
00:45:57,920 --> 00:46:00,880
because as you can see here uh well you

1212
00:46:00,880 --> 00:46:03,520
can't see here but key here is a global

1213
00:46:03,520 --> 00:46:05,200
variable yeah

1214
00:46:05,200 --> 00:46:07,280
and uh this variable oh yeah here you

1215
00:46:07,280 --> 00:46:09,040
can see the key is the global variable

1216
00:46:09,040 --> 00:46:11,119
and so this is used by the decryption

1217
00:46:11,119 --> 00:46:13,280
function here and the encryption

1218
00:46:13,280 --> 00:46:14,800
function so when you compile it it's

1219
00:46:14,800 --> 00:46:17,920
using the same key

1220
00:46:18,800 --> 00:46:21,280
basically

1221
00:46:21,280 --> 00:46:22,640
and you're

1222
00:46:22,640 --> 00:46:24,800
creating the key putting it in the

1223
00:46:24,800 --> 00:46:29,040
marker sending it over somebody click

1224
00:46:31,760 --> 00:46:33,280
the key for the decryption is the same

1225
00:46:33,280 --> 00:46:34,800
as the key for the encryption because

1226
00:46:34,800 --> 00:46:36,720
it's a global look we're using the

1227
00:46:36,720 --> 00:46:40,400
random seed this then stores uh it'll be

1228
00:46:40,400 --> 00:46:42,480
moduloed against oxff to get a value

1229
00:46:42,480 --> 00:46:44,960
between 0 and 256

1230
00:46:44,960 --> 00:46:46,400
and then this is stored in the key

1231
00:46:46,400 --> 00:46:47,760
variable

1232
00:46:47,760 --> 00:46:49,920
so the key value never changes after

1233
00:46:49,920 --> 00:46:52,960
compile time so the key here for example

1234
00:46:52,960 --> 00:46:55,839
if this is 17 here it will be 7 rx17

1235
00:46:55,839 --> 00:46:58,560
here as well so it's not it doesn't get

1236
00:46:58,560 --> 00:47:00,079
the time from

1237
00:47:00,079 --> 00:47:02,960
the um when it's being decrypted it gets

1238
00:47:02,960 --> 00:47:05,280
it or when it's being compiled

1239
00:47:05,280 --> 00:47:07,040
any other questions

1240
00:47:07,040 --> 00:47:10,040
yep

1241
00:47:11,050 --> 00:47:14,239
[Music]

1242
00:47:23,680 --> 00:47:24,800
yeah

1243
00:47:24,800 --> 00:47:25,599
yeah

1244
00:47:25,599 --> 00:47:27,280
because uh yeah i believe that um when a

1245
00:47:27,280 --> 00:47:29,520
process is created they don't know deals

1246
00:47:29,520 --> 00:47:31,839
is actually just a directory that um

1247
00:47:31,839 --> 00:47:33,359
allows you to load your wells faster

1248
00:47:33,359 --> 00:47:34,880
into the process

1249
00:47:34,880 --> 00:47:39,200
so yes and you have a couple questions

1250
00:47:39,200 --> 00:47:42,160
i'll leave it on this slide

1251
00:47:42,160 --> 00:47:45,640
thank you for coming

