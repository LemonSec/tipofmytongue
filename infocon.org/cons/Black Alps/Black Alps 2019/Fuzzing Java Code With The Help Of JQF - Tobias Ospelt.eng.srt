1
00:00:02,219 --> 00:00:08,170
Java code okay thank you yeah thank you

2
00:00:06,160 --> 00:00:10,450
very much from my side as well that

3
00:00:08,170 --> 00:00:12,419
you're all here tonight I know I

4
00:00:10,450 --> 00:00:15,578
appreciate it it's the last talk

5
00:00:12,419 --> 00:00:17,859
circumference and I'm gonna talk about

6
00:00:15,579 --> 00:00:20,380
fuzzing Java code as you hopefully

7
00:00:17,859 --> 00:00:23,470
expect it my name is Tobias bolt and

8
00:00:20,380 --> 00:00:25,660
sometimes I'm also called Floyd there's

9
00:00:23,470 --> 00:00:28,720
no really good story behind it but

10
00:00:25,660 --> 00:00:33,219
that's just what we what I am or Who I

11
00:00:28,720 --> 00:00:36,670
am so my co-founder markings over to me

12
00:00:33,219 --> 00:00:39,730
we found a Penta great okay and the

13
00:00:36,670 --> 00:00:41,949
pentagram act things so we do a

14
00:00:39,730 --> 00:00:44,980
penetration testing and security

15
00:00:41,949 --> 00:00:48,670
analysis for companies mainly in

16
00:00:44,980 --> 00:00:53,108
Switzerland and Germany and we have been

17
00:00:48,670 --> 00:00:56,620
doing this for a decade already and this

18
00:00:53,109 --> 00:01:00,489
is my main occupation really so Penta

19
00:00:56,620 --> 00:01:02,589
great pen testing and apart from that

20
00:01:00,489 --> 00:01:07,539
I'm also lecturing at Zurich University

21
00:01:02,590 --> 00:01:10,600
of Applied Sciences so lecture for

22
00:01:07,540 --> 00:01:13,780
information security and as a third

23
00:01:10,600 --> 00:01:16,059
thing I'm also participating with the

24
00:01:13,780 --> 00:01:20,409
cybersecurity Lichtenstein Association

25
00:01:16,060 --> 00:01:23,320
that's where we play CTF and basically

26
00:01:20,409 --> 00:01:26,680
everyone is invited but one of our main

27
00:01:23,320 --> 00:01:30,639
purposes is to prepare young people

28
00:01:26,680 --> 00:01:35,259
between 15 and 25 for the European cyber

29
00:01:30,640 --> 00:01:38,070
security challenge where we play four or

30
00:01:35,259 --> 00:01:42,430
into you against other countries and

31
00:01:38,070 --> 00:01:43,960
we're basically training the team

32
00:01:42,430 --> 00:01:47,409
Liechtenstein for this yearly

33
00:01:43,960 --> 00:01:50,740
competition so these are the main three

34
00:01:47,409 --> 00:01:54,460
things I'm doing information security

35
00:01:50,740 --> 00:01:58,600
wise and as you can see I just like blue

36
00:01:54,460 --> 00:02:01,899
logos basically so what I'm going to

37
00:01:58,600 --> 00:02:03,788
talk about today first of all I want to

38
00:02:01,899 --> 00:02:07,229
talk a little bit about the tools we're

39
00:02:03,789 --> 00:02:11,260
gonna see today and and who created them

40
00:02:07,229 --> 00:02:13,300
then I want to do a very quick one slide

41
00:02:11,260 --> 00:02:14,459
introduction into fuzzing so what is

42
00:02:13,300 --> 00:02:18,330
fuzzing we'll look at

43
00:02:14,460 --> 00:02:20,760
from a abstract point of view and then

44
00:02:18,330 --> 00:02:23,160
we're gonna look at one father in

45
00:02:20,760 --> 00:02:26,549
particular AFL it's a very popular

46
00:02:23,160 --> 00:02:30,840
puzzle by now and this is gonna be much

47
00:02:26,550 --> 00:02:34,770
more on the topic and technical and then

48
00:02:30,840 --> 00:02:37,920
we're gonna talk about jqf AFL which is

49
00:02:34,770 --> 00:02:42,030
basically taking the entire idea of this

50
00:02:37,920 --> 00:02:44,850
AFL phaser which is very well known and

51
00:02:42,030 --> 00:02:45,360
very successful and take it to the Java

52
00:02:44,850 --> 00:02:49,019
site

53
00:02:45,360 --> 00:02:51,540
so somebody took the entire idea of AFL

54
00:02:49,020 --> 00:02:53,250
to the Java side and then we're going to

55
00:02:51,540 --> 00:02:55,109
talk about the different Park lasses we

56
00:02:53,250 --> 00:02:58,650
can find I think this is probably the

57
00:02:55,110 --> 00:03:00,660
most important thing to realize when you

58
00:02:58,650 --> 00:03:04,440
do Java fussing is a walk can you find

59
00:03:00,660 --> 00:03:08,250
and then I'm gonna show you Jake we

60
00:03:04,440 --> 00:03:10,620
assessed and I'm really looking forward

61
00:03:08,250 --> 00:03:14,430
to this part because this should be

62
00:03:10,620 --> 00:03:18,390
closest to what your Java developers do

63
00:03:14,430 --> 00:03:22,910
in their daily business and you can

64
00:03:18,390 --> 00:03:28,350
really take home and try for yourself

65
00:03:22,910 --> 00:03:33,180
so AFL is the short version for American

66
00:03:28,350 --> 00:03:36,780
fuzzy lab it's created by Michael teleph

67
00:03:33,180 --> 00:03:41,910
ski when he was working at Google and it

68
00:03:36,780 --> 00:03:45,840
lists about 80 contributors on a UNIX

69
00:03:41,910 --> 00:03:48,660
web site so there are many many Forks of

70
00:03:45,840 --> 00:03:50,940
AFL and a lot of people use it for

71
00:03:48,660 --> 00:03:52,829
different things for fuzzing or the at

72
00:03:50,940 --> 00:03:55,050
least the idea is used for many

73
00:03:52,830 --> 00:03:58,950
different things too fast pricing code

74
00:03:55,050 --> 00:04:02,010
to fuss on Windows to test things on

75
00:03:58,950 --> 00:04:05,640
different platforms and so on and it's

76
00:04:02,010 --> 00:04:07,200
not really maintained by Michael anymore

77
00:04:05,640 --> 00:04:08,459
at least there was no official

78
00:04:07,200 --> 00:04:11,040
announcement saying hey I'm not

79
00:04:08,460 --> 00:04:13,650
maintaining it anymore but there were no

80
00:04:11,040 --> 00:04:17,339
more new releases so now there's AFL

81
00:04:13,650 --> 00:04:19,739
plus plus it's maintained by Mark Jose

82
00:04:17,339 --> 00:04:22,320
who's also very well known in our

83
00:04:19,738 --> 00:04:25,469
community in the IT security community

84
00:04:22,320 --> 00:04:27,540
and a couple of other people but

85
00:04:25,470 --> 00:04:29,310
then when AFL plus-plus come out came

86
00:04:27,540 --> 00:04:31,740
out and all the new features were added

87
00:04:29,310 --> 00:04:35,190
there at one point Google decided well

88
00:04:31,740 --> 00:04:38,160
we also want to publish the official AFL

89
00:04:35,190 --> 00:04:43,620
so there's not now also a google AFL

90
00:04:38,160 --> 00:04:45,480
version which is let's say very basic

91
00:04:43,620 --> 00:04:48,240
still or what what the last release of

92
00:04:45,480 --> 00:04:50,430
the official AFL was so all the new

93
00:04:48,240 --> 00:04:54,000
features are more or less in AFL plus

94
00:04:50,430 --> 00:04:57,330
plus and they haven't been many new

95
00:04:54,000 --> 00:05:00,090
feature releases from the Google site so

96
00:04:57,330 --> 00:05:02,130
there are a lot of Forks as it's very

97
00:05:00,090 --> 00:05:05,700
normal for a lot of open source projects

98
00:05:02,130 --> 00:05:09,060
and I just wanted to let you know this

99
00:05:05,700 --> 00:05:14,700
is not my tool but I'm kind of using it

100
00:05:09,060 --> 00:05:18,240
a lot so AFL finds security issues I

101
00:05:14,700 --> 00:05:22,200
think this is a list of projects where

102
00:05:18,240 --> 00:05:23,940
I've found security issues and well I

103
00:05:22,200 --> 00:05:28,530
think they just stopped at one point

104
00:05:23,940 --> 00:05:30,540
listing all the different software where

105
00:05:28,530 --> 00:05:32,460
security issues were found so it's very

106
00:05:30,540 --> 00:05:39,060
successful and I think this shows that

107
00:05:32,460 --> 00:05:43,169
shows it really well when we talk about

108
00:05:39,060 --> 00:05:46,950
jqf so the entire thing taken to Java it

109
00:05:43,169 --> 00:05:49,320
was created by Rohan at Berkeley

110
00:05:46,950 --> 00:05:51,570
University and it lists about six

111
00:05:49,320 --> 00:05:54,530
contributors so six people are involved

112
00:05:51,570 --> 00:05:58,110
in creating it and maintaining it and

113
00:05:54,530 --> 00:06:00,599
it's yeah as I said the entire idea of

114
00:05:58,110 --> 00:06:03,419
AFL for Java and there were two other

115
00:06:00,600 --> 00:06:07,590
buzzers that also tried a similar thing

116
00:06:03,419 --> 00:06:11,250
but those two are more or less already

117
00:06:07,590 --> 00:06:13,530
Maya unmaintained and yeah I haven't

118
00:06:11,250 --> 00:06:15,000
used them for a while I think a co F is

119
00:06:13,530 --> 00:06:18,000
really the one that that was

120
00:06:15,000 --> 00:06:21,120
successfully implementing it and is

121
00:06:18,000 --> 00:06:23,040
still maintained there are two main

122
00:06:21,120 --> 00:06:25,950
things in jqf one is called check with

123
00:06:23,040 --> 00:06:28,200
AFL which is really using AFL as well

124
00:06:25,950 --> 00:06:29,780
and the other one is Jacob obsessed and

125
00:06:28,200 --> 00:06:35,130
we're gonna look at both of them today

126
00:06:29,780 --> 00:06:37,650
and take where finds box as well I have

127
00:06:35,130 --> 00:06:38,980
to say it's not necessarily security

128
00:06:37,650 --> 00:06:41,380
issues so

129
00:06:38,980 --> 00:06:43,210
it finds bugs but it's also security

130
00:06:41,380 --> 00:06:46,990
issues so we're gonna talk about this

131
00:06:43,210 --> 00:06:50,289
later but the reason why this list is so

132
00:06:46,990 --> 00:06:53,290
small I think is because well just not a

133
00:06:50,290 --> 00:06:58,560
lot of people tried it yet so this list

134
00:06:53,290 --> 00:07:02,080
is longer so what's fuzzing fuzzing is

135
00:06:58,560 --> 00:07:05,280
the process of feeding input into a

136
00:07:02,080 --> 00:07:08,229
program and we do it in an automated way

137
00:07:05,280 --> 00:07:11,619
to find undesired behavior

138
00:07:08,230 --> 00:07:16,900
now undecide behavior is usually a bug

139
00:07:11,620 --> 00:07:20,950
and noticing that we found a bug we call

140
00:07:16,900 --> 00:07:23,679
this capability instrumentation so being

141
00:07:20,950 --> 00:07:28,000
able to see what the program is doing

142
00:07:23,680 --> 00:07:30,880
and being able to detect the bug is done

143
00:07:28,000 --> 00:07:33,550
through intermediary instrumentation so

144
00:07:30,880 --> 00:07:39,490
first for example for a simple C program

145
00:07:33,550 --> 00:07:41,650
this come in a crash now if we look at

146
00:07:39,490 --> 00:07:45,220
the same concept and from an AFL

147
00:07:41,650 --> 00:07:48,159
perspective we can exactly do this so we

148
00:07:45,220 --> 00:07:51,460
can use AFL and its file based so it

149
00:07:48,160 --> 00:07:55,420
uses a file and it will feed it into a

150
00:07:51,460 --> 00:07:57,909
program and the good thing is that AFL

151
00:07:55,420 --> 00:08:00,220
will notice when new behavior is

152
00:07:57,910 --> 00:08:02,680
triggered inside the program so it will

153
00:08:00,220 --> 00:08:05,920
know which code paths are taken and then

154
00:08:02,680 --> 00:08:12,610
it's able to prefer interesting inputs

155
00:08:05,920 --> 00:08:14,050
for the program so again noticing that

156
00:08:12,610 --> 00:08:16,390
we have different behavior in the

157
00:08:14,050 --> 00:08:19,830
program we can do that through

158
00:08:16,390 --> 00:08:23,590
instrumentation now let's look at more

159
00:08:19,830 --> 00:08:27,849
real-world example so we have live PNG

160
00:08:23,590 --> 00:08:30,250
which is library to parse PNG files and

161
00:08:27,850 --> 00:08:34,000
we have a picture of a rabbit we can

162
00:08:30,250 --> 00:08:37,030
mutate this picture of a rabbit and feed

163
00:08:34,000 --> 00:08:39,700
it into the program and it will

164
00:08:37,030 --> 00:08:44,680
hopefully trigger different code paths

165
00:08:39,700 --> 00:08:48,040
inside leap PNG until we find a lot of

166
00:08:44,680 --> 00:08:49,959
different code paths through leap PNG

167
00:08:48,040 --> 00:08:52,880
and we're trigger we're treating a lot

168
00:08:49,960 --> 00:08:54,860
of different behaviors maybe he

169
00:08:52,880 --> 00:08:57,439
all behaviors that are therefore lip

170
00:08:54,860 --> 00:09:01,640
pinchy until we find this undesired

171
00:08:57,440 --> 00:09:04,160
behavior so at one point hopefully we

172
00:09:01,640 --> 00:09:09,350
find the some buck by inputting

173
00:09:04,160 --> 00:09:11,600
something special now this is how AFL

174
00:09:09,350 --> 00:09:13,820
looks like so this is the UI of AFL and

175
00:09:11,600 --> 00:09:15,380
I don't want to talk about all of the

176
00:09:13,820 --> 00:09:18,980
details today because it's a little bit

177
00:09:15,380 --> 00:09:21,650
big but on the top right corner you see

178
00:09:18,980 --> 00:09:24,500
the overall results and we want to talk

179
00:09:21,650 --> 00:09:27,890
about that today so let's go back to

180
00:09:24,500 --> 00:09:30,110
this image we had before lip PNG so for

181
00:09:27,890 --> 00:09:33,439
lippy indeed if we had a run which would

182
00:09:30,110 --> 00:09:36,560
say total pass 871 we would have been

183
00:09:33,440 --> 00:09:40,180
able to trigger 871 different behaviors

184
00:09:36,560 --> 00:09:45,290
inside the PNG and unique crash means

185
00:09:40,180 --> 00:09:47,180
124 so we found 124 crashes for lip PNG

186
00:09:45,290 --> 00:09:50,480
this is just an example this is a very

187
00:09:47,180 --> 00:09:53,870
old version of lick PNG so we found one

188
00:09:50,480 --> 00:09:55,280
on 24 crashes inside leaf kimchi and we

189
00:09:53,870 --> 00:09:59,120
were able to notice it because of

190
00:09:55,280 --> 00:10:01,939
instrumentation and this is a simple

191
00:09:59,120 --> 00:10:05,570
crash force for C programs like lip PNG

192
00:10:01,940 --> 00:10:07,790
we simply find crashes now there's a

193
00:10:05,570 --> 00:10:12,230
third parameter called unique hangs and

194
00:10:07,790 --> 00:10:17,180
it says 221 it means that when we were

195
00:10:12,230 --> 00:10:19,580
feeding a file into leap PNG 221

196
00:10:17,180 --> 00:10:23,510
different files took too long to process

197
00:10:19,580 --> 00:10:26,660
so AFL decided well this takes too long

198
00:10:23,510 --> 00:10:29,930
I wanna board this test and I just let

199
00:10:26,660 --> 00:10:34,880
you know that there are 220 files that

200
00:10:29,930 --> 00:10:37,640
take longer than I'm I want to wait so

201
00:10:34,880 --> 00:10:40,100
this could mean it will take a lot of

202
00:10:37,640 --> 00:10:46,819
time to process or just a little bit

203
00:10:40,100 --> 00:10:49,610
more than a FL wanted to wait now so far

204
00:10:46,820 --> 00:10:53,120
we were talking about C programs and AFL

205
00:10:49,610 --> 00:10:55,340
now let's take a big jump to the Java

206
00:10:53,120 --> 00:10:57,740
world now we're talking about something

207
00:10:55,340 --> 00:11:00,110
completely different because we're

208
00:10:57,740 --> 00:11:02,900
applying it to Java so of course we

209
00:11:00,110 --> 00:11:05,630
don't have leap PNG anymore but we have

210
00:11:02,900 --> 00:11:06,480
a Java library that is also able to

211
00:11:05,630 --> 00:11:09,810
parts

212
00:11:06,480 --> 00:11:14,700
PNG files so we have Chama image i/o as

213
00:11:09,810 --> 00:11:17,729
a target and we still have jqf that is

214
00:11:14,700 --> 00:11:19,940
feeding input and triggering different

215
00:11:17,730 --> 00:11:22,980
paths so the blue part is the same and

216
00:11:19,940 --> 00:11:25,740
we have still unique Hanks so we still

217
00:11:22,980 --> 00:11:29,880
know which inputs take too long to

218
00:11:25,740 --> 00:11:33,510
process but what does crashes means in

219
00:11:29,880 --> 00:11:37,260
the case of Jaquith that's the basic

220
00:11:33,510 --> 00:11:40,350
question mark and I want to answer this

221
00:11:37,260 --> 00:11:41,660
question mark by doing the jqf tutorial

222
00:11:40,350 --> 00:11:45,570
with you

223
00:11:41,660 --> 00:11:48,630
so there's this jqf tutorial on the

224
00:11:45,570 --> 00:11:50,880
github web page and I made a small video

225
00:11:48,630 --> 00:11:54,450
and I'm gonna explain what we do so we

226
00:11:50,880 --> 00:11:58,200
have this test class that parses a PNG

227
00:11:54,450 --> 00:12:00,510
file with image i/o so we have to test

228
00:11:58,200 --> 00:12:03,030
class and we can look into it we have a

229
00:12:00,510 --> 00:12:05,670
adverse annotation we have a function

230
00:12:03,030 --> 00:12:10,079
called test read we can feed it an input

231
00:12:05,670 --> 00:12:12,420
stream which is what JQ f AFL expects we

232
00:12:10,080 --> 00:12:15,600
give it to image i/o and say parse this

233
00:12:12,420 --> 00:12:17,819
as a PNG file and then if an i/o

234
00:12:15,600 --> 00:12:19,170
exception occurs we say we don't care

235
00:12:17,820 --> 00:12:21,870
about i/o exceptions

236
00:12:19,170 --> 00:12:24,959
so I exceptions occur whenever there is

237
00:12:21,870 --> 00:12:30,690
something inputted which is not a PNG

238
00:12:24,960 --> 00:12:32,520
file obviously so I hope yeah we're

239
00:12:30,690 --> 00:12:37,620
going on so we can compile this test

240
00:12:32,520 --> 00:12:40,680
class with jqf and the regular Java

241
00:12:37,620 --> 00:12:44,760
compiler and then run Jake with AFL fuzz

242
00:12:40,680 --> 00:12:47,910
on it and it will happily take our test

243
00:12:44,760 --> 00:12:51,360
PNG file start to feed it into Java

244
00:12:47,910 --> 00:12:54,719
image io mutate it and then hopefully

245
00:12:51,360 --> 00:12:58,470
we'll find new paths which we do on the

246
00:12:54,720 --> 00:13:02,010
top right and the execution speed as we

247
00:12:58,470 --> 00:13:04,890
see is like roughly 500 tests per second

248
00:13:02,010 --> 00:13:08,160
which is already pretty quick and we

249
00:13:04,890 --> 00:13:13,250
find new behavior triggering inside java

250
00:13:08,160 --> 00:13:16,620
image away io now this was the tutorial

251
00:13:13,250 --> 00:13:18,600
so I thought why not change the tutorial

252
00:13:16,620 --> 00:13:20,610
a little bit and instead of PNG

253
00:13:18,600 --> 00:13:22,950
let's test chief

254
00:13:20,610 --> 00:13:27,240
files so I just change all the

255
00:13:22,950 --> 00:13:30,779
occurrences of PNG to chip and run the

256
00:13:27,240 --> 00:13:34,500
exact same tutorial from the jqf website

257
00:13:30,779 --> 00:13:37,290
on a different format again Java image

258
00:13:34,500 --> 00:13:39,589
i/o is able to parse chip files and we

259
00:13:37,290 --> 00:13:47,069
run it again

260
00:13:39,589 --> 00:13:51,170
and we're finding crashes so this was I

261
00:13:47,070 --> 00:13:55,560
think two weeks ago three weeks ago and

262
00:13:51,170 --> 00:13:57,000
we're still finding 22 crashes so we

263
00:13:55,560 --> 00:13:59,910
still don't know what crashes are I

264
00:13:57,000 --> 00:14:02,940
haven't told you that yet but at least

265
00:13:59,910 --> 00:14:05,610
we noticed that well the tutorial was

266
00:14:02,940 --> 00:14:09,720
obviously run a lot of time from the

267
00:14:05,610 --> 00:14:12,209
maintainer and he told Java about all

268
00:14:09,720 --> 00:14:15,240
the bugs they found and they fixed it

269
00:14:12,209 --> 00:14:18,449
but nobody bothered to change the

270
00:14:15,240 --> 00:14:20,550
tutorial just a little bit to find new

271
00:14:18,450 --> 00:14:23,279
security issues or not security issues

272
00:14:20,550 --> 00:14:26,790
or bugs or whatever it might be so I

273
00:14:23,279 --> 00:14:30,329
just want to tell you that it's still

274
00:14:26,790 --> 00:14:32,490
very easy to find box whatever they

275
00:14:30,329 --> 00:14:35,390
might be in Java and in a lot of

276
00:14:32,490 --> 00:14:38,279
libraries because nobody is doing it and

277
00:14:35,390 --> 00:14:42,750
jqf has been around for two years on

278
00:14:38,279 --> 00:14:45,269
github now and nobody did it so this is

279
00:14:42,750 --> 00:14:47,160
what we get now here comes the solution

280
00:14:45,269 --> 00:14:49,470
to the question I had so what are

281
00:14:47,160 --> 00:14:52,019
crashes it's a little bit disappointing

282
00:14:49,470 --> 00:14:55,560
for the security guys of you but well

283
00:14:52,019 --> 00:14:59,490
instead of crashes we only get uncaught

284
00:14:55,560 --> 00:15:02,310
exceptions so because Java is memory

285
00:14:59,490 --> 00:15:05,550
safe we cannot get memory corruptions

286
00:15:02,310 --> 00:15:07,529
and our program doesn't crash but we get

287
00:15:05,550 --> 00:15:08,519
things such as index out of bounds

288
00:15:07,529 --> 00:15:11,279
exception

289
00:15:08,519 --> 00:15:12,839
so if Java would be a memory unsafe

290
00:15:11,279 --> 00:15:15,269
language we would have a memory

291
00:15:12,839 --> 00:15:17,130
corruption but we don't in this case so

292
00:15:15,269 --> 00:15:20,100
this is not a really a security issue

293
00:15:17,130 --> 00:15:22,680
but this is a robustness issue inside

294
00:15:20,100 --> 00:15:24,839
your java code so as a developer you

295
00:15:22,680 --> 00:15:27,599
probably still want to know about these

296
00:15:24,839 --> 00:15:33,329
things but it's not really a security

297
00:15:27,600 --> 00:15:35,519
issue so as I said the read

298
00:15:33,329 --> 00:15:39,628
the crashes are just song uncaught

299
00:15:35,519 --> 00:15:42,119
exceptions now when you look at this

300
00:15:39,629 --> 00:15:44,639
image you can still see that there are

301
00:15:42,119 --> 00:15:46,739
unique hangs and in the case of Chicot

302
00:15:44,639 --> 00:15:49,379
fafl that's actually the more

303
00:15:46,739 --> 00:15:52,139
interesting part because that's where we

304
00:15:49,379 --> 00:15:56,189
find the security issues so I was able

305
00:15:52,139 --> 00:15:59,999
to find five different infinite loops

306
00:15:56,189 --> 00:16:03,480
inside Java programs by using the fuzzer

307
00:15:59,999 --> 00:16:07,079
so I was able to fast the Apache TCAP

308
00:16:03,480 --> 00:16:09,540
project with jqf AFL and I found an

309
00:16:07,079 --> 00:16:13,229
infinite loop so if it would part my

310
00:16:09,540 --> 00:16:15,509
image my file then it would just use up

311
00:16:13,230 --> 00:16:18,059
all the CPU that was there and will run

312
00:16:15,509 --> 00:16:20,429
in circles and the entire Java process

313
00:16:18,059 --> 00:16:24,600
would probably at one point be unusable

314
00:16:20,429 --> 00:16:28,259
I was able to do the same for J&R a

315
00:16:24,600 --> 00:16:31,350
library to to unpack rar files I was

316
00:16:28,259 --> 00:16:34,889
able to do this for PDF box which is as

317
00:16:31,350 --> 00:16:37,679
well an Apache project and I was even

318
00:16:34,889 --> 00:16:40,139
able to do this for Apache common

319
00:16:37,679 --> 00:16:43,249
compress now Apache common compress I

320
00:16:40,139 --> 00:16:47,009
think if you have to unpack a zip file

321
00:16:43,249 --> 00:16:49,769
in Java you usually use Apache common

322
00:16:47,009 --> 00:16:52,589
compress and this was exactly back in

323
00:16:49,769 --> 00:16:55,019
the zip archive input streamer so if you

324
00:16:52,589 --> 00:16:57,299
try to unpack my zip file it would

325
00:16:55,019 --> 00:17:02,220
result in an infinite loop and your java

326
00:16:57,299 --> 00:17:04,980
process will never return so I was the

327
00:17:02,220 --> 00:17:06,899
until a CV was even in Java itself so in

328
00:17:04,980 --> 00:17:08,760
one of the standard libraries it's a

329
00:17:06,898 --> 00:17:11,219
little bit exotic because it's a RIF

330
00:17:08,760 --> 00:17:14,519
reader parser but still even the

331
00:17:11,220 --> 00:17:16,980
standard standard library of Java had

332
00:17:14,519 --> 00:17:19,620
about where I was able to trigger an

333
00:17:16,980 --> 00:17:21,659
infinite loop where the code would never

334
00:17:19,619 --> 00:17:27,928
return as soon as you call it with my

335
00:17:21,659 --> 00:17:29,909
input file so this might be the might

336
00:17:27,929 --> 00:17:31,649
have been the interesting part for some

337
00:17:29,909 --> 00:17:34,830
of the security researchers you can find

338
00:17:31,649 --> 00:17:37,799
infinite loops but it's it's just part

339
00:17:34,830 --> 00:17:39,689
of it but now what I want to do first is

340
00:17:37,799 --> 00:17:42,779
take this entire thing a little bit

341
00:17:39,690 --> 00:17:47,080
closer to your development lifecycle so

342
00:17:42,779 --> 00:17:50,860
in your company you're you're developing

343
00:17:47,080 --> 00:17:54,279
other programs and usually programmers

344
00:17:50,860 --> 00:17:56,860
have to do unit tests and writing unit

345
00:17:54,279 --> 00:18:00,460
tests is probably not the favorite part

346
00:17:56,860 --> 00:18:03,100
of programming for a lot of Java

347
00:18:00,460 --> 00:18:06,789
developers so wouldn't it be nice to

348
00:18:03,100 --> 00:18:09,519
have at least a father that is very easy

349
00:18:06,789 --> 00:18:12,669
to use and generates very good inputs

350
00:18:09,519 --> 00:18:16,840
for your code and this is now possible

351
00:18:12,669 --> 00:18:19,389
because of jqf tests so Jayco abscessed

352
00:18:16,840 --> 00:18:21,879
takes the entire AFL approach so

353
00:18:19,389 --> 00:18:24,370
everything we just talked about being

354
00:18:21,880 --> 00:18:26,799
able to trigger code paths knowing when

355
00:18:24,370 --> 00:18:28,779
new code paths are triggered and using

356
00:18:26,799 --> 00:18:31,149
these files it's doing all that so

357
00:18:28,779 --> 00:18:34,720
everything we took just talked about but

358
00:18:31,149 --> 00:18:36,850
apart from that it's also unit using a

359
00:18:34,720 --> 00:18:40,990
unique quick check generators which

360
00:18:36,850 --> 00:18:45,789
means we can now not only fast

361
00:18:40,990 --> 00:18:50,669
Java code that expects input streams but

362
00:18:45,789 --> 00:18:54,879
also all kind of other simple Java types

363
00:18:50,669 --> 00:18:57,970
so the main things of jqf tests which

364
00:18:54,880 --> 00:19:01,389
are really good is that it's not only

365
00:18:57,970 --> 00:19:04,980
for input streams but more complex Java

366
00:19:01,389 --> 00:19:06,189
types and it will also understand

367
00:19:04,980 --> 00:19:08,799
preconditions

368
00:19:06,190 --> 00:19:12,340
so if you have ever written a unit test

369
00:19:08,799 --> 00:19:14,620
then it you might have written an

370
00:19:12,340 --> 00:19:18,250
assumed statement which basically says

371
00:19:14,620 --> 00:19:21,489
so if you get an input as a test and it

372
00:19:18,250 --> 00:19:23,470
doesn't it doesn't adhere to certain

373
00:19:21,490 --> 00:19:25,870
constraints then please don't run the

374
00:19:23,470 --> 00:19:27,850
test so you do an assumed statement at

375
00:19:25,870 --> 00:19:31,658
the beginning of the test to make sure

376
00:19:27,850 --> 00:19:35,399
that whatever you get is in the in a

377
00:19:31,659 --> 00:19:39,850
valid form so this is basically to test

378
00:19:35,399 --> 00:19:44,439
- to skip tests that are that don't make

379
00:19:39,850 --> 00:19:47,469
any sense and the third thing is a maven

380
00:19:44,440 --> 00:19:49,720
plug-in so j-curve says this is

381
00:19:47,470 --> 00:19:51,250
completely available as a maven plugin

382
00:19:49,720 --> 00:19:53,620
which means you don't need to install

383
00:19:51,250 --> 00:19:57,880
any command-line tool anymore you don't

384
00:19:53,620 --> 00:20:00,418
need to install a FL or jqf itself but

385
00:19:57,880 --> 00:20:02,909
just write it as a dependency

386
00:20:00,419 --> 00:20:05,669
your maven file and it will pull it down

387
00:20:02,909 --> 00:20:08,970
and install it by itself so this allows

388
00:20:05,669 --> 00:20:11,639
really easy continuous integration and

389
00:20:08,970 --> 00:20:14,070
this might be also very important for

390
00:20:11,639 --> 00:20:16,129
continuous integration platforms that

391
00:20:14,070 --> 00:20:19,739
can now run a fuzzer

392
00:20:16,129 --> 00:20:23,730
so this was the three theory to it I

393
00:20:19,739 --> 00:20:26,100
think the developers might be looking

394
00:20:23,730 --> 00:20:28,919
for something like this which is a

395
00:20:26,100 --> 00:20:33,238
little bit more applied so this is an

396
00:20:28,919 --> 00:20:37,710
example from the maintainer of jqf Rohan

397
00:20:33,239 --> 00:20:41,940
who did tests on a data structure called

398
00:20:37,710 --> 00:20:44,190
Patricia try now for this code it's not

399
00:20:41,940 --> 00:20:47,100
really important what a Patricia tries

400
00:20:44,190 --> 00:20:49,529
but we have our ad fast annotation again

401
00:20:47,100 --> 00:20:54,299
so it just means please fastest function

402
00:20:49,529 --> 00:20:57,480
but what we can do now is we can pass a

403
00:20:54,299 --> 00:21:00,059
map in a string and it will

404
00:20:57,480 --> 00:21:01,889
automatically know how to generate a map

405
00:21:00,059 --> 00:21:04,649
it will automatically know how to

406
00:21:01,889 --> 00:21:06,449
generate a string because we have j-unit

407
00:21:04,649 --> 00:21:09,090
quick check generators for these two

408
00:21:06,450 --> 00:21:11,340
types and we don't have to care about

409
00:21:09,090 --> 00:21:16,730
that the father will just know how this

410
00:21:11,340 --> 00:21:22,289
works so we pass in a map which Maps

411
00:21:16,730 --> 00:21:25,109
strings to integer and a string which is

412
00:21:22,289 --> 00:21:28,609
just the key and we assume at the

413
00:21:25,109 --> 00:21:31,918
beginning so here we only want to test

414
00:21:28,609 --> 00:21:35,369
maps that already contain the string so

415
00:21:31,919 --> 00:21:38,399
we have this assumed statements and

416
00:21:35,369 --> 00:21:40,678
tests will try to understand this

417
00:21:38,399 --> 00:21:43,320
assumed statement and only generate

418
00:21:40,679 --> 00:21:44,970
inputs that already comply to this

419
00:21:43,320 --> 00:21:48,450
assumed statement so it's very powerful

420
00:21:44,970 --> 00:21:51,149
there again it will put it into the

421
00:21:48,450 --> 00:21:54,389
Patricia try so we will parse the map

422
00:21:51,149 --> 00:21:58,649
into the Patricia try and afterwards it

423
00:21:54,389 --> 00:22:01,439
will simply say okay I assume I assert

424
00:21:58,649 --> 00:22:04,258
that the Patricia try now contains my

425
00:22:01,440 --> 00:22:07,159
key I mean this is very basic every data

426
00:22:04,259 --> 00:22:10,799
structure nearly if you put something in

427
00:22:07,159 --> 00:22:12,389
then if you ask afterwards is it still

428
00:22:10,799 --> 00:22:13,500
in there then it should still be in

429
00:22:12,389 --> 00:22:17,750
there right

430
00:22:13,500 --> 00:22:21,080
so this is a very basic test but he

431
00:22:17,750 --> 00:22:25,470
found a buck and this is actually very

432
00:22:21,080 --> 00:22:30,178
interesting buck its marked as priority

433
00:22:25,470 --> 00:22:32,309
critical and it's still unresolved so

434
00:22:30,179 --> 00:22:36,750
it's still open it was found by Rohan

435
00:22:32,309 --> 00:22:38,908
the maintainer himself of jqf and it was

436
00:22:36,750 --> 00:22:42,809
reported to Commons collection and

437
00:22:38,909 --> 00:22:47,640
Apache project and it says it ignores

438
00:22:42,809 --> 00:22:51,030
trailing null characters which means if

439
00:22:47,640 --> 00:22:55,440
we have a new patricia try and we put in

440
00:22:51,030 --> 00:22:58,500
X and we say is X still in the Patricia

441
00:22:55,440 --> 00:23:01,559
try then it will say yes X is of course

442
00:22:58,500 --> 00:23:07,980
in the Patricia try but if we then put

443
00:23:01,559 --> 00:23:11,940
in X backslash u 0 0 0 0 and afterwards

444
00:23:07,980 --> 00:23:16,140
we ask is it still in there it will say

445
00:23:11,940 --> 00:23:19,830
no X is not in there anymore so this

446
00:23:16,140 --> 00:23:21,840
violates every assumption of a developer

447
00:23:19,830 --> 00:23:23,490
of this data structure when you put

448
00:23:21,840 --> 00:23:25,590
something in the data structure and you

449
00:23:23,490 --> 00:23:27,450
put the second thing in it then the

450
00:23:25,590 --> 00:23:30,000
first thing should still be in there and

451
00:23:27,450 --> 00:23:32,130
this means from an attacker point of

452
00:23:30,000 --> 00:23:35,400
view from an information security point

453
00:23:32,130 --> 00:23:37,799
of view you can by putting something

454
00:23:35,400 --> 00:23:42,120
inside the data structure you can delete

455
00:23:37,799 --> 00:23:44,850
from it and this I don't really know

456
00:23:42,120 --> 00:23:46,590
what the implications are of this but as

457
00:23:44,850 --> 00:23:49,439
this is a very fundamental data

458
00:23:46,590 --> 00:23:51,899
structure this can be really bad and

459
00:23:49,440 --> 00:23:54,450
it's not only as far as I know it's not

460
00:23:51,900 --> 00:23:57,120
only present for Patricia try but they

461
00:23:54,450 --> 00:24:00,720
have these problems for for some of the

462
00:23:57,120 --> 00:24:07,080
other data structures inside the Apache

463
00:24:00,720 --> 00:24:10,620
Commons now the UI of jqf test looks

464
00:24:07,080 --> 00:24:13,678
kind of similar than AFL I mean not not

465
00:24:10,620 --> 00:24:15,780
exactly what we again get the elapsed

466
00:24:13,679 --> 00:24:19,140
time so how long the fossil was running

467
00:24:15,780 --> 00:24:21,510
so far and it says no time limit so I

468
00:24:19,140 --> 00:24:23,100
didn't specify a time limit but if you

469
00:24:21,510 --> 00:24:26,129
have a continuous integration platform

470
00:24:23,100 --> 00:24:27,389
and you want to say ok for each build

471
00:24:26,130 --> 00:24:29,700
we're doing please run

472
00:24:27,389 --> 00:24:31,978
fassl for five minutes you can do that

473
00:24:29,700 --> 00:24:35,639
so you can say in our continuous

474
00:24:31,979 --> 00:24:39,749
integration we allocate five minutes for

475
00:24:35,639 --> 00:24:42,508
the puzzle unique failures that's a

476
00:24:39,749 --> 00:24:44,309
combination of everything we've seen so

477
00:24:42,509 --> 00:24:47,579
far everything that can go wrong so it's

478
00:24:44,309 --> 00:24:51,719
uncaught exceptions its assert

479
00:24:47,579 --> 00:24:54,239
statements and it's hangs so we find all

480
00:24:51,719 --> 00:24:56,279
kind of on this I behavior in there and

481
00:24:54,239 --> 00:24:59,009
we also get the execution speed which is

482
00:24:56,279 --> 00:25:01,529
very important to notice here it's in

483
00:24:59,009 --> 00:25:04,559
this case it's three times faster than

484
00:25:01,529 --> 00:25:08,969
before so it's really really really

485
00:25:04,559 --> 00:25:10,889
quick so you can imagine because of jqf

486
00:25:08,969 --> 00:25:13,649
is very smart and it knows when a new

487
00:25:10,889 --> 00:25:17,279
code paths it is triggered and it's able

488
00:25:13,649 --> 00:25:20,609
to feed a lot of inputs it's very good

489
00:25:17,279 --> 00:25:23,999
to find its way through your code that

490
00:25:20,609 --> 00:25:27,178
you've written and the total coverage

491
00:25:23,999 --> 00:25:32,779
the branches is the same as the path so

492
00:25:27,179 --> 00:25:35,369
it found 579 different paths through

493
00:25:32,779 --> 00:25:42,599
through your bangers or through your

494
00:25:35,369 --> 00:25:47,609
code now for this presentation I thought

495
00:25:42,599 --> 00:25:52,289
I need to demonstrate the how powerful

496
00:25:47,609 --> 00:25:54,089
jqf cest can be and I did a run for a

497
00:25:52,289 --> 00:25:56,039
certain library and I was looking for a

498
00:25:54,089 --> 00:25:58,649
library and I thought why not use a

499
00:25:56,039 --> 00:26:00,239
cryptographic library because people

500
00:25:58,649 --> 00:26:02,399
will notice that when something goes

501
00:26:00,239 --> 00:26:05,789
wrong in a cryptographic library then

502
00:26:02,399 --> 00:26:07,918
that's bad right so in Java a lot of

503
00:26:05,789 --> 00:26:11,099
people use bouncy castle who has used

504
00:26:07,919 --> 00:26:12,959
bouncy castle before oh very nice yeah

505
00:26:11,099 --> 00:26:15,599
so we have a lot of Java developers here

506
00:26:12,959 --> 00:26:18,599
and it's also bouncy castle is in every

507
00:26:15,599 --> 00:26:22,129
of your Android phones so this is not

508
00:26:18,599 --> 00:26:26,729
like theory this is now getting applied

509
00:26:22,129 --> 00:26:29,009
so I part I tested the asn.1 parser of

510
00:26:26,729 --> 00:26:31,169
bouncy castle now again it's not it's

511
00:26:29,009 --> 00:26:33,629
not important that you know what the ACE

512
00:26:31,169 --> 00:26:37,229
and one what a is and one is but it's a

513
00:26:33,629 --> 00:26:40,830
very fundamental structure so if you

514
00:26:37,229 --> 00:26:43,980
have a certificate on the very basic a

515
00:26:40,830 --> 00:26:46,019
it's usually stored as asn.1 so although

516
00:26:43,980 --> 00:26:48,240
it might be there or whatever payment

517
00:26:46,019 --> 00:26:50,899
code and so on but on the basis it's

518
00:26:48,240 --> 00:26:55,950
very often isn't one

519
00:26:50,899 --> 00:27:00,209
so I ran Jake we obsessed against bouncy

520
00:26:55,950 --> 00:27:02,880
castle asn.1 parser and that's this is a

521
00:27:00,210 --> 00:27:05,370
video of how I did it so first of all we

522
00:27:02,880 --> 00:27:07,679
need to write a test class again this is

523
00:27:05,370 --> 00:27:09,989
just as before we have at fast

524
00:27:07,679 --> 00:27:12,779
we now parse in a byte array and that's

525
00:27:09,990 --> 00:27:15,120
nice because we have quite a quick check

526
00:27:12,779 --> 00:27:16,740
generators for that we say parts of

527
00:27:15,120 --> 00:27:19,260
destination one input stream

528
00:27:16,740 --> 00:27:21,149
take out all objects and if you get an

529
00:27:19,260 --> 00:27:23,190
i/o exception we don't care about our

530
00:27:21,149 --> 00:27:26,518
exceptions because we know those can

531
00:27:23,190 --> 00:27:29,940
happen so we only need the test class

532
00:27:26,519 --> 00:27:32,250
and the dependency file for Maimon we

533
00:27:29,940 --> 00:27:35,429
only write two files the dependency file

534
00:27:32,250 --> 00:27:38,580
will say okay I'm gonna use jqf please

535
00:27:35,429 --> 00:27:41,279
install it I'm gonna use quick check

536
00:27:38,580 --> 00:27:44,689
generators and I'm gonna use jQuery phos

537
00:27:41,279 --> 00:27:48,690
so I just specify my dependencies I need

538
00:27:44,690 --> 00:27:53,429
to run this test and of course I also

539
00:27:48,690 --> 00:27:56,370
need bouncy castle the target I'm going

540
00:27:53,429 --> 00:27:59,279
to fuss so this is just like regular

541
00:27:56,370 --> 00:28:02,850
Java development and then I can say

542
00:27:59,279 --> 00:28:05,549
maven please compile the test class and

543
00:28:02,850 --> 00:28:07,260
it will pull down all the dependencies

544
00:28:05,549 --> 00:28:09,720
which was already done and then compile

545
00:28:07,260 --> 00:28:12,600
them and we'll say build successful and

546
00:28:09,720 --> 00:28:12,960
then I can ask maven itself to run the

547
00:28:12,600 --> 00:28:16,320
fuzzer

548
00:28:12,960 --> 00:28:21,090
so I can say check with us please fast

549
00:28:16,320 --> 00:28:28,500
this class and this function called test

550
00:28:21,090 --> 00:28:33,270
with byte array and run it afterwards

551
00:28:28,500 --> 00:28:35,430
we should get our known UI of Jaquith

552
00:28:33,270 --> 00:28:38,460
assessed and you can already see in a

553
00:28:35,430 --> 00:28:43,920
couple of seconds because it's going so

554
00:28:38,460 --> 00:28:48,810
fast we find seven unique failures so we

555
00:28:43,920 --> 00:28:52,470
found seven seven distinct box inside

556
00:28:48,810 --> 00:28:57,840
the ACE and one parser in one minute 22

557
00:28:52,470 --> 00:29:00,780
seconds now as soon as I looked at all

558
00:28:57,840 --> 00:29:03,090
these bugs I found most of them again

559
00:29:00,780 --> 00:29:05,430
were interesting for developers because

560
00:29:03,090 --> 00:29:07,740
now the bouncy castle developers know

561
00:29:05,430 --> 00:29:10,940
how their code can fail and they were

562
00:29:07,740 --> 00:29:14,490
class cast exception z' and so on but

563
00:29:10,940 --> 00:29:19,020
one Bach was really interesting because

564
00:29:14,490 --> 00:29:23,190
it allowed me to fill up the Java memory

565
00:29:19,020 --> 00:29:26,340
and basically crash the Java process by

566
00:29:23,190 --> 00:29:29,700
using all memory so I'm able to send a

567
00:29:26,340 --> 00:29:31,709
very small ace and one input and Java

568
00:29:29,700 --> 00:29:34,530
will try to unpack it and unpack it and

569
00:29:31,710 --> 00:29:36,720
allocate really big rays for it and that

570
00:29:34,530 --> 00:29:39,570
will use up all memory and at one point

571
00:29:36,720 --> 00:29:42,210
the Java process will die because it

572
00:29:39,570 --> 00:29:46,580
doesn't have any memory left so again we

573
00:29:42,210 --> 00:29:50,790
have a denial of service condition here

574
00:29:46,580 --> 00:29:54,149
so the real success story behind this is

575
00:29:50,790 --> 00:29:56,879
not really that I found a bug but when I

576
00:29:54,150 --> 00:29:58,500
reported this to bouncy castle they were

577
00:29:56,880 --> 00:30:00,380
really interested in said oh this is

578
00:29:58,500 --> 00:30:03,420
interesting how did you find them and I

579
00:30:00,380 --> 00:30:05,100
supplied them with the two files and how

580
00:30:03,420 --> 00:30:08,370
to build it with maven and so on and

581
00:30:05,100 --> 00:30:11,310
they started to use it for their entire

582
00:30:08,370 --> 00:30:12,719
bouncy castle or not the entire but at

583
00:30:11,310 --> 00:30:13,710
least they said they use it for other

584
00:30:12,720 --> 00:30:16,860
places as well

585
00:30:13,710 --> 00:30:19,530
and they started to foster GPG

586
00:30:16,860 --> 00:30:22,280
implementation as well and I guess they

587
00:30:19,530 --> 00:30:25,620
found a lot of boxes well there so as

588
00:30:22,280 --> 00:30:29,580
you can see nearly every library I try

589
00:30:25,620 --> 00:30:32,070
to fuss I find box so I hope I can

590
00:30:29,580 --> 00:30:36,419
animate some of you to to try this

591
00:30:32,070 --> 00:30:40,310
buzzer okay

592
00:30:36,420 --> 00:30:42,390
let's talk about the back classes so far

593
00:30:40,310 --> 00:30:44,399
we've seen UNK

594
00:30:42,390 --> 00:30:48,630
exceptions which are not real security

595
00:30:44,400 --> 00:30:51,810
issues usually we find denial of service

596
00:30:48,630 --> 00:30:55,130
issues like using all the CPU infinite

597
00:30:51,810 --> 00:30:59,970
loops and using all the memory and so on

598
00:30:55,130 --> 00:31:02,910
but I hope that at one point with more

599
00:30:59,970 --> 00:31:05,850
instrumentation we're also able to find

600
00:31:02,910 --> 00:31:08,160
other bug classes now I'm saying this

601
00:31:05,850 --> 00:31:11,399
hopefully we will because this will

602
00:31:08,160 --> 00:31:13,650
probably not be easy to do automated

603
00:31:11,400 --> 00:31:15,510
like everything automated but as soon as

604
00:31:13,650 --> 00:31:18,000
you as a developer know a little bit

605
00:31:15,510 --> 00:31:21,629
what you expect from your code you can

606
00:31:18,000 --> 00:31:23,820
do assert statements and then jqf will

607
00:31:21,630 --> 00:31:27,420
try to violate these assert statements

608
00:31:23,820 --> 00:31:31,800
so you will notice box and I think it

609
00:31:27,420 --> 00:31:36,930
will be really easy to to find bugs by

610
00:31:31,800 --> 00:31:40,470
writing very little Java code now it's

611
00:31:36,930 --> 00:31:45,000
very hard to answer which kind of packet

612
00:31:40,470 --> 00:31:48,390
classes we might find with Jaquith but I

613
00:31:45,000 --> 00:31:53,280
think there is the possibility that we

614
00:31:48,390 --> 00:31:56,490
find cryptographic box with jqf cest

615
00:31:53,280 --> 00:31:59,490
simply by for example doing differential

616
00:31:56,490 --> 00:32:02,280
fuzzing so we need we take two Java

617
00:31:59,490 --> 00:32:04,980
libraries that do crypto and we give

618
00:32:02,280 --> 00:32:07,770
them input generated by JQ assessed and

619
00:32:04,980 --> 00:32:10,110
at the end it will output the result and

620
00:32:07,770 --> 00:32:12,330
if both libraries have the same result

621
00:32:10,110 --> 00:32:15,240
everything's fine but if they have

622
00:32:12,330 --> 00:32:17,490
different results then something is

623
00:32:15,240 --> 00:32:20,100
going wrong right both implementations

624
00:32:17,490 --> 00:32:24,500
should do the same so I think it there

625
00:32:20,100 --> 00:32:26,879
might be fuzzing might improve with this

626
00:32:24,500 --> 00:32:29,010
code coverage we have with Jake worth

627
00:32:26,880 --> 00:32:33,330
assessed so we might be able to find

628
00:32:29,010 --> 00:32:35,580
cryptographic box I quickly tried to run

629
00:32:33,330 --> 00:32:38,310
which approve if some of you know that

630
00:32:35,580 --> 00:32:42,000
project with Jake we assess and I didn't

631
00:32:38,310 --> 00:32:45,450
find any new bugs but really that was

632
00:32:42,000 --> 00:32:47,100
just a half an hour test and I need to

633
00:32:45,450 --> 00:32:51,180
do some more testing on it so might

634
00:32:47,100 --> 00:32:54,000
maybe we can reuse existing work and

635
00:32:51,180 --> 00:32:56,780
just plug in Jake worth test and then

636
00:32:54,000 --> 00:32:56,780
find new box

637
00:32:57,040 --> 00:33:02,600
cross-site scripting and cross-site

638
00:32:59,510 --> 00:33:04,610
request forgery these are very very

639
00:33:02,600 --> 00:33:06,500
common web application vulnerabilities I

640
00:33:04,610 --> 00:33:08,600
think this is not a good approach to to

641
00:33:06,500 --> 00:33:10,760
find these kind of things I can't

642
00:33:08,600 --> 00:33:13,699
imagine how you would in instrument your

643
00:33:10,760 --> 00:33:15,710
code to find these things so I mean

644
00:33:13,700 --> 00:33:18,549
they're they're probably ways to do it

645
00:33:15,710 --> 00:33:21,770
but it's probably too much work to do

646
00:33:18,549 --> 00:33:24,290
whereas injections it depends a little

647
00:33:21,770 --> 00:33:26,090
bit on how you on what kind of injection

648
00:33:24,290 --> 00:33:28,690
you have but for example in SQL

649
00:33:26,090 --> 00:33:31,360
injection I can imagine that you if you

650
00:33:28,690 --> 00:33:34,700
for example fast

651
00:33:31,360 --> 00:33:37,309
inputs from from a user and then at one

652
00:33:34,700 --> 00:33:39,470
point you get an SQL exception then you

653
00:33:37,309 --> 00:33:42,440
might have found an SQL injection as

654
00:33:39,470 --> 00:33:45,290
well right so this might be possible it

655
00:33:42,440 --> 00:33:48,590
depends on the case server-side requests

656
00:33:45,290 --> 00:33:50,240
for tree so service write request for

657
00:33:48,590 --> 00:33:52,639
tree means we can send something to a

658
00:33:50,240 --> 00:33:54,620
server and the server will do a network

659
00:33:52,640 --> 00:33:57,710
connection for us to a certain place

660
00:33:54,620 --> 00:33:59,510
which can be a big issue and I think

661
00:33:57,710 --> 00:34:03,080
there's also room there and I'm gonna

662
00:33:59,510 --> 00:34:06,530
talk about it on the next slide and then

663
00:34:03,080 --> 00:34:08,899
logic box can we find logic bugs well we

664
00:34:06,530 --> 00:34:11,179
can't find logic bugs because I already

665
00:34:08,899 --> 00:34:14,029
showed you a logic bug the Patricia try

666
00:34:11,179 --> 00:34:15,770
example is a logic bug if you put

667
00:34:14,030 --> 00:34:17,060
something in a data structure put

668
00:34:15,770 --> 00:34:19,070
something else in there and the first

669
00:34:17,060 --> 00:34:27,799
thing when Isha's then that's a logic

670
00:34:19,070 --> 00:34:31,070
bug so I think the future of Java

671
00:34:27,800 --> 00:34:34,070
fuzzing might involve the Java security

672
00:34:31,070 --> 00:34:36,020
policy manager the Java security policy

673
00:34:34,070 --> 00:34:38,840
manager is a not very well-known feature

674
00:34:36,020 --> 00:34:42,800
of your java runtime environment and it

675
00:34:38,840 --> 00:34:45,409
allows you to specify a policy that says

676
00:34:42,800 --> 00:34:47,810
ok the entire java program we're gonna

677
00:34:45,409 --> 00:34:50,240
run now is not allowed to open up any

678
00:34:47,810 --> 00:34:54,020
network connections that's just an

679
00:34:50,239 --> 00:34:56,750
example and you might ask well but how

680
00:34:54,020 --> 00:35:00,350
how does that help with with fuzzing

681
00:34:56,750 --> 00:35:03,290
well I have one example that fits really

682
00:35:00,350 --> 00:35:05,359
well and I'm unsure on how many other

683
00:35:03,290 --> 00:35:07,880
examples in the future will fit into

684
00:35:05,359 --> 00:35:10,100
this use case but at least for server

685
00:35:07,880 --> 00:35:12,320
side requests for tree a thing

686
00:35:10,100 --> 00:35:15,140
the Java security policy manager could

687
00:35:12,320 --> 00:35:20,120
help because can you match in image i/o

688
00:35:15,140 --> 00:35:23,359
a library that parses images doing a

689
00:35:20,120 --> 00:35:26,480
network connection well you might say no

690
00:35:23,360 --> 00:35:28,970
I think that's not possible but actually

691
00:35:26,480 --> 00:35:30,710
the word in the past not image i/o or at

692
00:35:28,970 --> 00:35:33,890
least I don't know that image i/o did it

693
00:35:30,710 --> 00:35:37,280
but other image libraries that when they

694
00:35:33,890 --> 00:35:39,589
encountered metadata they try to parse

695
00:35:37,280 --> 00:35:43,240
the metadata in an image file and

696
00:35:39,590 --> 00:35:48,470
metadata one of the format's is XMP an

697
00:35:43,240 --> 00:35:51,229
XMP is a format that is in XML and XML

698
00:35:48,470 --> 00:35:54,319
is a format that can have external

699
00:35:51,230 --> 00:35:57,110
references to other servers so there are

700
00:35:54,320 --> 00:35:59,390
image libraries that happily open up

701
00:35:57,110 --> 00:36:01,940
network connections for you if you

702
00:35:59,390 --> 00:36:05,779
supply it right metadata in the file

703
00:36:01,940 --> 00:36:07,700
format so if we have a Java security

704
00:36:05,780 --> 00:36:09,110
policy manager that would say an image

705
00:36:07,700 --> 00:36:11,660
library is not allowed to open up

706
00:36:09,110 --> 00:36:13,490
network connections then we will get an

707
00:36:11,660 --> 00:36:15,649
uncaught exception it would say hey

708
00:36:13,490 --> 00:36:17,899
something tried to open up the network

709
00:36:15,650 --> 00:36:23,030
connection here's an exception and we

710
00:36:17,900 --> 00:36:25,130
will notice during the fuzzing run so at

711
00:36:23,030 --> 00:36:27,370
the moment Java security policy manager

712
00:36:25,130 --> 00:36:31,820
is not really necessary to find bugs

713
00:36:27,370 --> 00:36:34,720
I've shown so far but at one point we

714
00:36:31,820 --> 00:36:37,760
might use it and there's a lot more

715
00:36:34,720 --> 00:36:41,600
testing necessary and I'm really looking

716
00:36:37,760 --> 00:36:46,520
forward to what is coming in the Java

717
00:36:41,600 --> 00:36:49,970
folding area now I hope you enjoyed my

718
00:36:46,520 --> 00:36:54,050
talk and I hope I was able to animate

719
00:36:49,970 --> 00:36:57,589
some of you and you developers to start

720
00:36:54,050 --> 00:37:00,170
using kqf it's very easy especially if

721
00:36:57,590 --> 00:37:03,740
you use maven it's very easy to do a

722
00:37:00,170 --> 00:37:06,770
fuzzing run and also for the security

723
00:37:03,740 --> 00:37:08,419
researchers I hope that can may be on

724
00:37:06,770 --> 00:37:10,550
your next engagement for example when

725
00:37:08,420 --> 00:37:13,580
you do pen testing I started doing this

726
00:37:10,550 --> 00:37:15,740
because one of our customers they gave

727
00:37:13,580 --> 00:37:17,840
me too much Java code and I was fed up

728
00:37:15,740 --> 00:37:21,080
with looking at too much fat Java code

729
00:37:17,840 --> 00:37:24,320
so I started fuzzing and I found bugs in

730
00:37:21,080 --> 00:37:26,210
their server and I was able to use all

731
00:37:24,320 --> 00:37:29,360
the all the memory on their server and

732
00:37:26,210 --> 00:37:36,350
they were very happy that I found all

733
00:37:29,360 --> 00:37:39,140
these issues so I hope some of you will

734
00:37:36,350 --> 00:37:41,660
try it in the future and I can just say

735
00:37:39,140 --> 00:37:52,490
come to the Java world there are lots of

736
00:37:41,660 --> 00:37:59,920
bugs to discover thank you ok thank you

737
00:37:52,490 --> 00:38:04,669
very much tobias any question yeah Hey

738
00:37:59,920 --> 00:38:07,550
so every time there is a failure or

739
00:38:04,670 --> 00:38:10,580
something that crashes normally if while

740
00:38:07,550 --> 00:38:12,770
you actually solve the coding issue you

741
00:38:10,580 --> 00:38:15,980
should actually also write probably your

742
00:38:12,770 --> 00:38:18,230
unit test to test that specific case is

743
00:38:15,980 --> 00:38:20,120
there a way to actually record the

744
00:38:18,230 --> 00:38:21,800
inputs that cause crashes so that you

745
00:38:20,120 --> 00:38:23,870
are sure that you're going to rerun them

746
00:38:21,800 --> 00:38:25,970
in the future every time yeah so I mean

747
00:38:23,870 --> 00:38:28,490
I wasn't able to show all the features

748
00:38:25,970 --> 00:38:31,759
of Shaker test but it actually takes an

749
00:38:28,490 --> 00:38:33,589
input directory where you can put all

750
00:38:31,760 --> 00:38:35,660
the old test cases and it will start

751
00:38:33,590 --> 00:38:37,670
fuzzing from there and it will notice oh

752
00:38:35,660 --> 00:38:39,319
this is like already triggering a lot of

753
00:38:37,670 --> 00:38:41,510
code passes that are really interesting

754
00:38:39,320 --> 00:38:43,760
so I will use this file from as a start

755
00:38:41,510 --> 00:38:45,380
and it will as soon as it generates new

756
00:38:43,760 --> 00:38:47,960
ones and you get an output directory

757
00:38:45,380 --> 00:38:49,780
where then we call it corpus so the

758
00:38:47,960 --> 00:38:53,120
entire corpus will be stored for you

759
00:38:49,780 --> 00:39:07,610
it's yeah so you can do that you can use

760
00:38:53,120 --> 00:39:10,730
it as an input for your next run yeah I

761
00:39:07,610 --> 00:39:12,770
don't actually have a question but you

762
00:39:10,730 --> 00:39:15,200
jump to the conclusion that people

763
00:39:12,770 --> 00:39:18,650
didn't try to change an example from

764
00:39:15,200 --> 00:39:21,410
fuzzing PNG file to G file just that

765
00:39:18,650 --> 00:39:23,540
they didn't report Berger make me very

766
00:39:21,410 --> 00:39:25,310
public that they did but I know you

767
00:39:23,540 --> 00:39:27,259
cannot assume anything about what people

768
00:39:25,310 --> 00:39:30,350
are doing this photos alright yeah

769
00:39:27,260 --> 00:39:31,670
you're absolutely right I mean that's a

770
00:39:30,350 --> 00:39:33,440
big problem in the fuzzing world

771
00:39:31,670 --> 00:39:36,470
especially that

772
00:39:33,440 --> 00:39:39,769
so a lot of people are running fuzzers

773
00:39:36,470 --> 00:39:41,419
and they find a lot of bucks but as long

774
00:39:39,769 --> 00:39:42,288
as they're not security issue that you

775
00:39:41,420 --> 00:39:44,420
throw them away

776
00:39:42,289 --> 00:39:46,190
they don't even report them they don't

777
00:39:44,420 --> 00:39:49,160
give it to maintain us they don't care

778
00:39:46,190 --> 00:39:51,979
about robustness because well they're

779
00:39:49,160 --> 00:39:54,140
probably various different reasons why

780
00:39:51,979 --> 00:39:56,649
it happens so one is if you're a

781
00:39:54,140 --> 00:40:00,259
security researcher you you're paid to

782
00:39:56,650 --> 00:40:03,200
find security issues not regular box for

783
00:40:00,259 --> 00:40:04,309
they're boring for you and the other

784
00:40:03,200 --> 00:40:07,879
thing is as well

785
00:40:04,309 --> 00:40:09,920
our entire ecosystem is more and more

786
00:40:07,880 --> 00:40:12,650
setup like that because I mean bug

787
00:40:09,920 --> 00:40:15,410
bounties it won't pay you for robustness

788
00:40:12,650 --> 00:40:18,849
issues I mean some started some started

789
00:40:15,410 --> 00:40:22,970
to to pay you if you just improve

790
00:40:18,849 --> 00:40:24,739
certain codes but regular bug bounty

791
00:40:22,970 --> 00:40:27,799
programs won't pay you for anything else

792
00:40:24,739 --> 00:40:30,049
than security bugs right thank you for

793
00:40:27,799 --> 00:40:32,720
mentioning the Google program which pays

794
00:40:30,049 --> 00:40:34,519
you for submitting security patches to

795
00:40:32,720 --> 00:40:37,308
open source code you can get money from

796
00:40:34,519 --> 00:40:43,488
it what what company ID in here did I

797
00:40:37,309 --> 00:40:53,809
just go on okay do we have another

798
00:40:43,489 --> 00:40:56,210
question yeah he's same generation of

799
00:40:53,809 --> 00:40:59,900
the faster deterministic or every run

800
00:40:56,210 --> 00:41:04,700
different so that's a good question so I

801
00:40:59,900 --> 00:41:07,130
know AFL plus plus now has a seat come

802
00:41:04,700 --> 00:41:10,249
online so you can say always start with

803
00:41:07,130 --> 00:41:12,589
this seat so it's deterministic and if

804
00:41:10,249 --> 00:41:14,328
it's really one percent deterministic

805
00:41:12,589 --> 00:41:17,719
you should ask the maintainer

806
00:41:14,329 --> 00:41:20,900
but I guess there should also be

807
00:41:17,719 --> 00:41:25,190
something similar for jqf and if it's

808
00:41:20,900 --> 00:41:27,979
not you can just basically change it to

809
00:41:25,190 --> 00:41:31,329
use the seed for the random generator so

810
00:41:27,979 --> 00:41:40,868
I think it should be fairly easy to make

811
00:41:31,329 --> 00:41:40,869
it deterministic in any other question

812
00:41:42,120 --> 00:41:47,870
okay thanks again thank you thanks to

813
00:41:45,750 --> 00:41:47,870
you

