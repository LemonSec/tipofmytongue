1
00:00:02,570 --> 00:00:10,740
good sir my name's Sam and I like this

2
00:00:09,210 --> 00:00:14,670
person said hair I'm a developer

3
00:00:10,740 --> 00:00:16,590
advocate and I github what that means

4
00:00:14,670 --> 00:00:18,210
really varies from company to company

5
00:00:16,590 --> 00:00:20,039
for me personally it means that all of

6
00:00:18,210 --> 00:00:22,039
my development is now in my free time

7
00:00:20,039 --> 00:00:24,539
for projects I care about rather than

8
00:00:22,039 --> 00:00:26,550
for a company which is kind of cool

9
00:00:24,539 --> 00:00:29,609
and I'm doing other stuff for my for my

10
00:00:26,550 --> 00:00:32,780
day job I joined github only a couple of

11
00:00:29,609 --> 00:00:35,880
months ago as part of an acquisition of

12
00:00:32,780 --> 00:00:38,700
my company which is still kind of exists

13
00:00:35,880 --> 00:00:40,980
called Cemil and for I was a developer

14
00:00:38,700 --> 00:00:43,230
advocate I was the lead developer for

15
00:00:40,980 --> 00:00:46,080
lgt m.com which is bringing cemil's

16
00:00:43,230 --> 00:00:47,910
tools for type and source projects and I

17
00:00:46,080 --> 00:00:49,620
started that in about 2014 was a

18
00:00:47,910 --> 00:00:54,510
developer for a three and a half years

19
00:00:49,620 --> 00:00:57,110
there today or my passions include open

20
00:00:54,510 --> 00:00:59,449
source security privacy cryptography for

21
00:00:57,110 --> 00:01:02,010
for a little while I was one of the

22
00:00:59,450 --> 00:01:05,789
contributors to the signal signals

23
00:01:02,010 --> 00:01:06,960
Android and desktop clients mercy super

24
00:01:05,789 --> 00:01:09,749
interested in vulnerability research

25
00:01:06,960 --> 00:01:11,908
code quality and lighting most of my

26
00:01:09,749 --> 00:01:13,619
projects on github were actually like

27
00:01:11,909 --> 00:01:17,130
lighting control and synchronization

28
00:01:13,619 --> 00:01:19,439
with music that sort of stuff that's my

29
00:01:17,130 --> 00:01:21,030
Twitter and github handles and they'll

30
00:01:19,439 --> 00:01:24,678
be on all of the slides in case you want

31
00:01:21,030 --> 00:01:25,999
to take any pictures for your own

32
00:01:24,679 --> 00:01:28,740
yourself

33
00:01:25,999 --> 00:01:30,509
so before I start I'm interested in

34
00:01:28,740 --> 00:01:32,908
knowing kind of the distribution of

35
00:01:30,509 --> 00:01:34,380
different expertise in the room so raise

36
00:01:32,909 --> 00:01:36,049
your hands if you're involved in

37
00:01:34,380 --> 00:01:38,310
software development is a developer or

38
00:01:36,049 --> 00:01:41,609
maybe an application security team or

39
00:01:38,310 --> 00:01:43,499
your company create software cool good

40
00:01:41,609 --> 00:01:45,119
number raise your hand if you're an

41
00:01:43,499 --> 00:01:46,619
independent security researcher maybe

42
00:01:45,119 --> 00:01:50,520
you go the bug bounty is that sort of

43
00:01:46,619 --> 00:01:52,770
thing okay couple cool raise hand if you

44
00:01:50,520 --> 00:01:54,149
work for a security consultancy fuse

45
00:01:52,770 --> 00:01:57,899
cool all right

46
00:01:54,149 --> 00:01:59,899
pretty good a good mix so today I'm

47
00:01:57,899 --> 00:02:02,850
gonna start off with a short story and

48
00:01:59,899 --> 00:02:07,499
it's a story of many bugs and it begins

49
00:02:02,850 --> 00:02:10,530
on the 7th of September 2017 when my co

50
00:02:07,499 --> 00:02:13,620
my colleague Moo discovered a

51
00:02:10,530 --> 00:02:15,030
vulnerability in the pivotal spring

52
00:02:13,620 --> 00:02:16,970
framework and he disclosed

53
00:02:15,030 --> 00:02:19,920
describe proudly displays it to pivotal

54
00:02:16,970 --> 00:02:21,300
now the the nature of this bug took

55
00:02:19,920 --> 00:02:23,160
advantage of something called the spring

56
00:02:21,300 --> 00:02:26,880
expression language which allows you to

57
00:02:23,160 --> 00:02:29,970
describe sort of Java accesses using a

58
00:02:26,880 --> 00:02:31,440
string now this was it's mostly intended

59
00:02:29,970 --> 00:02:33,090
to be used as an internal tool for the

60
00:02:31,440 --> 00:02:35,820
framework itself but with this

61
00:02:33,090 --> 00:02:38,790
particular bug there was a data from

62
00:02:35,820 --> 00:02:40,500
HTTP requests that were that flowed to

63
00:02:38,790 --> 00:02:42,600
one of these strings and you could

64
00:02:40,500 --> 00:02:46,680
actually do arbitrary remote code

65
00:02:42,600 --> 00:02:50,670
execution on certain configurations of

66
00:02:46,680 --> 00:02:52,710
the spring framework so reported the bug

67
00:02:50,670 --> 00:02:54,450
on a little while later the 21st of

68
00:02:52,710 --> 00:02:56,490
September pivotal made a public

69
00:02:54,450 --> 00:02:59,070
announcement where they had patched the

70
00:02:56,490 --> 00:03:01,950
bug and recommended that everyone

71
00:02:59,070 --> 00:03:05,160
updates so when were actually had a look

72
00:03:01,950 --> 00:03:07,700
at the announcement and the patch and he

73
00:03:05,160 --> 00:03:09,780
discovered it wasn't actually complete

74
00:03:07,700 --> 00:03:11,970
they were still making the same mistake

75
00:03:09,780 --> 00:03:13,890
somewhere slightly different so he

76
00:03:11,970 --> 00:03:16,350
created a new POC that took advantage of

77
00:03:13,890 --> 00:03:20,369
the new code path and sent that to

78
00:03:16,350 --> 00:03:21,960
pivotal a little while later pivotal

79
00:03:20,370 --> 00:03:23,220
made a patch but they didn't make it

80
00:03:21,960 --> 00:03:25,260
public yet they wanted a double check

81
00:03:23,220 --> 00:03:27,720
that they got it right this time so they

82
00:03:25,260 --> 00:03:33,109
sent it to me and the next day he sent

83
00:03:27,720 --> 00:03:33,109
them a new POC it was still vulnerable

84
00:03:33,200 --> 00:03:38,910
they at this point realized that this

85
00:03:37,590 --> 00:03:41,370
approach that they were taking wasn't

86
00:03:38,910 --> 00:03:42,660
really working so they took some time to

87
00:03:41,370 --> 00:03:44,730
actually refactor that part of the

88
00:03:42,660 --> 00:03:47,190
codebase completely to completely remove

89
00:03:44,730 --> 00:03:49,350
that that type of vulnerability and on

90
00:03:47,190 --> 00:03:51,150
the 25th of October published that

91
00:03:49,350 --> 00:03:54,480
refactoring again recommending everyone

92
00:03:51,150 --> 00:03:56,250
to update now a good thing for Marius he

93
00:03:54,480 --> 00:03:59,730
got a couple more than just just one CV

94
00:03:56,250 --> 00:04:01,080
out of this so that's kind of cool I'm

95
00:03:59,730 --> 00:04:05,369
going to talk about a slightly different

96
00:04:01,080 --> 00:04:08,490
story this one's about Apache struts so

97
00:04:05,370 --> 00:04:12,390
similar to a patch similar to pivotal

98
00:04:08,490 --> 00:04:14,130
spring Apache struts has this language

99
00:04:12,390 --> 00:04:17,488
called adrianel which allows you to

100
00:04:14,130 --> 00:04:21,238
using strings describe accesses to Java

101
00:04:17,488 --> 00:04:23,609
objects and if you can execute an

102
00:04:21,238 --> 00:04:26,280
arbitrary original string then you can

103
00:04:23,610 --> 00:04:29,110
have remote code execution on a factory

104
00:04:26,280 --> 00:04:32,018
strut server now in

105
00:04:29,110 --> 00:04:35,349
and then 27th of April 2016 that was a

106
00:04:32,019 --> 00:04:37,119
vulnerability where a HTTP data flow to

107
00:04:35,349 --> 00:04:41,169
an AG now string and loud remote code

108
00:04:37,119 --> 00:04:44,579
execution so this was announced and

109
00:04:41,169 --> 00:04:48,369
patched and fixed as you'd expect

110
00:04:44,579 --> 00:04:49,709
then on the 12th of May 2016 someone

111
00:04:48,369 --> 00:04:53,919
discovered a different vulnerabilities

112
00:04:49,709 --> 00:04:55,419
where user data was flowing from HTTP

113
00:04:53,919 --> 00:04:56,558
request to energy now string in a

114
00:04:55,419 --> 00:05:00,748
dramatic code execution

115
00:04:56,559 --> 00:05:02,459
so they passionately fixed it 2015-2016

116
00:05:00,749 --> 00:05:04,599
another remote code execution

117
00:05:02,459 --> 00:05:08,860
interpreting user data as an OG and L

118
00:05:04,599 --> 00:05:11,679
string 90 the March 2017 interpreting

119
00:05:08,860 --> 00:05:14,800
user data is no gene L string and then

120
00:05:11,679 --> 00:05:20,049
again on the 22nd of September 2017 and

121
00:05:14,800 --> 00:05:21,819
then on the 24th of September so there's

122
00:05:20,050 --> 00:05:23,169
also only a limited amount of space I

123
00:05:21,819 --> 00:05:24,519
have on the slide so I haven't actually

124
00:05:23,169 --> 00:05:26,849
included all of them and there are

125
00:05:24,519 --> 00:05:29,559
another ten CVEs that are all the same

126
00:05:26,849 --> 00:05:31,899
vulnerability interpreting user data

127
00:05:29,559 --> 00:05:37,889
from an HTTP request as an OD now string

128
00:05:31,899 --> 00:05:40,149
allowing for a remote code execution so

129
00:05:37,889 --> 00:05:42,399
we have a little bit of a problem here

130
00:05:40,149 --> 00:05:43,929
and in my sitting it might seem like I'm

131
00:05:42,399 --> 00:05:46,239
just making fun of these two open source

132
00:05:43,929 --> 00:05:48,429
projects in particular but these kinds

133
00:05:46,239 --> 00:05:50,529
of stories are common across the entire

134
00:05:48,429 --> 00:05:52,688
industry in open source and closed

135
00:05:50,529 --> 00:05:54,789
source software and it's not just small

136
00:05:52,689 --> 00:05:56,919
companies either so for example Apple

137
00:05:54,789 --> 00:05:59,529
published the source code for a part of

138
00:05:56,919 --> 00:06:01,568
Mac OS and OS X cool the xnu kernel

139
00:05:59,529 --> 00:06:01,839
which was understandably a core part of

140
00:06:01,569 --> 00:06:04,119
it

141
00:06:01,839 --> 00:06:07,539
I'm Kevin Backhouse one of my other

142
00:06:04,119 --> 00:06:10,719
co-workers found a vulnerability in a

143
00:06:07,539 --> 00:06:12,699
component called the packet Mangler so

144
00:06:10,719 --> 00:06:15,869
he sent the vulnerability reports apple

145
00:06:12,699 --> 00:06:19,239
with a POC they fix the vulnerability

146
00:06:15,869 --> 00:06:20,499
they pushed out an update when they

147
00:06:19,239 --> 00:06:23,049
later published the source code because

148
00:06:20,499 --> 00:06:24,039
Apple has a delayed publishing of the

149
00:06:23,050 --> 00:06:27,789
source code after they've actually

150
00:06:24,039 --> 00:06:29,558
released the binaries Kevin discovered

151
00:06:27,789 --> 00:06:32,979
that there was still a bug in the same

152
00:06:29,559 --> 00:06:34,149
block of code that they had hatched so

153
00:06:32,979 --> 00:06:35,649
he sent them a new exploit that

154
00:06:34,149 --> 00:06:37,119
triggered that vulnerability and then

155
00:06:35,649 --> 00:06:41,499
they had two later fix that in a later

156
00:06:37,119 --> 00:06:42,520
release same iris we're seeing the same

157
00:06:41,499 --> 00:06:44,710
sorts of mistake

158
00:06:42,520 --> 00:06:46,389
we made over and over again leading to

159
00:06:44,710 --> 00:06:48,878
vulnerabilities manifesting over and

160
00:06:46,389 --> 00:06:51,039
over again and if you REM from Eduardo's

161
00:06:48,879 --> 00:06:52,409
talk this morning he included some

162
00:06:51,039 --> 00:06:54,430
statistics that Katie missouri's

163
00:06:52,409 --> 00:06:57,840
previously shared about the number of

164
00:06:54,430 --> 00:06:59,680
non spam bug reports that Microsoft gets

165
00:06:57,840 --> 00:07:02,500
somewhere in the order of hundreds of

166
00:06:59,680 --> 00:07:04,659
thousands a year and how many of those

167
00:07:02,500 --> 00:07:06,879
do you think you know not just duplicate

168
00:07:04,659 --> 00:07:08,590
but instances of the same mistake being

169
00:07:06,879 --> 00:07:12,340
made throughout Microsoft software

170
00:07:08,590 --> 00:07:14,500
portfolio and you know I'm willing to

171
00:07:12,340 --> 00:07:15,880
bet that it's quite a lot and that

172
00:07:14,500 --> 00:07:18,580
Microsoft would save themselves a lot of

173
00:07:15,880 --> 00:07:21,370
effort oh sorry if they could reduce

174
00:07:18,580 --> 00:07:23,590
that number so how do we solve this

175
00:07:21,370 --> 00:07:25,780
problem could we potentially use

176
00:07:23,590 --> 00:07:29,008
information of a new vulnerability as we

177
00:07:25,780 --> 00:07:31,059
discover it as an opportunity instead

178
00:07:29,009 --> 00:07:33,729
once you've found the root cause of a

179
00:07:31,060 --> 00:07:36,520
vulnerability the underlying mistake

180
00:07:33,729 --> 00:07:37,990
could you ask yourself the question have

181
00:07:36,520 --> 00:07:40,270
I made this mistake anywhere else in my

182
00:07:37,990 --> 00:07:42,069
software there could be something

183
00:07:40,270 --> 00:07:43,479
architectural e that means that a

184
00:07:42,069 --> 00:07:45,659
certain cost of vulnerability is more

185
00:07:43,479 --> 00:07:48,789
likely to occur in your project perhaps

186
00:07:45,659 --> 00:07:50,080
your use of C may make you more prone to

187
00:07:48,789 --> 00:07:52,150
certain types of memory corrupts and

188
00:07:50,080 --> 00:07:56,080
vulnerabilities may be using things like

189
00:07:52,150 --> 00:07:57,159
Apaches Oh Janelle or Springs expression

190
00:07:56,080 --> 00:07:58,930
language might make you more vulnerable

191
00:07:57,159 --> 00:08:01,870
to certain types of remote code

192
00:07:58,930 --> 00:08:05,020
execution attacks so you should try and

193
00:08:01,870 --> 00:08:07,180
find similar mistakes in your code when

194
00:08:05,020 --> 00:08:08,789
you discover one mistake because the

195
00:08:07,180 --> 00:08:11,050
chances are that you will find something

196
00:08:08,789 --> 00:08:13,029
and companies such as Microsoft and

197
00:08:11,050 --> 00:08:14,440
Google who have been actually doing this

198
00:08:13,029 --> 00:08:21,580
for quite a while now I call this

199
00:08:14,440 --> 00:08:23,560
precise variant analysis so here's a

200
00:08:21,580 --> 00:08:24,969
quote from a blog post by Steven hunter

201
00:08:23,560 --> 00:08:28,090
from the Microsoft Security Response

202
00:08:24,969 --> 00:08:29,740
Center it says after doing very coarse

203
00:08:28,090 --> 00:08:32,199
analysis our next step is variant

204
00:08:29,740 --> 00:08:34,120
analysis finding and investigating any

205
00:08:32,200 --> 00:08:35,740
variants of the vulnerability it's

206
00:08:34,120 --> 00:08:38,049
important that we find all such variants

207
00:08:35,740 --> 00:08:39,579
and passions Immelt aeneas lee otherwise

208
00:08:38,049 --> 00:08:42,760
we bear the risk of these being

209
00:08:39,578 --> 00:08:45,189
exploited in the wild so for them it's

210
00:08:42,760 --> 00:08:46,569
simply not an option not to do it it's a

211
00:08:45,190 --> 00:08:48,579
stage of their vulnerability response

212
00:08:46,570 --> 00:08:49,959
process that happens before making

213
00:08:48,579 --> 00:08:52,329
details of a vulnerability or patch

214
00:08:49,959 --> 00:08:54,339
public so they can patch the original

215
00:08:52,329 --> 00:08:55,760
vulnerability and all of its variants at

216
00:08:54,339 --> 00:08:57,680
the same time the

217
00:08:55,760 --> 00:09:00,200
if they don't do that once the patch is

218
00:08:57,680 --> 00:09:02,989
released other people will take it upon

219
00:09:00,200 --> 00:09:04,100
themselves to try and find similar

220
00:09:02,990 --> 00:09:05,810
vulnerabilities in their code

221
00:09:04,100 --> 00:09:10,700
perhaps reverse engineering if they need

222
00:09:05,810 --> 00:09:13,430
to and if possible exploit them so how

223
00:09:10,700 --> 00:09:15,830
do you do variant analysis to be honest

224
00:09:13,430 --> 00:09:17,930
until recently most of the big players

225
00:09:15,830 --> 00:09:20,450
have predominately been relying on a lot

226
00:09:17,930 --> 00:09:22,640
of manual work by their security

227
00:09:20,450 --> 00:09:24,470
response teams focusing on particularly

228
00:09:22,640 --> 00:09:26,290
sensitive areas of a code base that are

229
00:09:24,470 --> 00:09:28,550
more likely to have vulnerabilities

230
00:09:26,290 --> 00:09:30,110
manually checking how data flows through

231
00:09:28,550 --> 00:09:32,390
an application using techniques like

232
00:09:30,110 --> 00:09:33,950
control flow or data flow analysis or

233
00:09:32,390 --> 00:09:36,410
like checking the range of values that

234
00:09:33,950 --> 00:09:39,740
certain variables can take ensuring that

235
00:09:36,410 --> 00:09:42,469
bounds are checked correctly and all of

236
00:09:39,740 --> 00:09:45,200
these sorts of manual investigations

237
00:09:42,470 --> 00:09:47,120
often more often than not actually need

238
00:09:45,200 --> 00:09:51,680
to make use of text search tools like

239
00:09:47,120 --> 00:09:53,540
rap na wk you can also use a IDE S or

240
00:09:51,680 --> 00:09:54,920
something else that's also more language

241
00:09:53,540 --> 00:09:57,110
aware like source graph that allows you

242
00:09:54,920 --> 00:09:58,640
to jump to definitions and find

243
00:09:57,110 --> 00:09:59,750
references quickly be able to jump

244
00:09:58,640 --> 00:10:03,110
through the core graph that sort of

245
00:09:59,750 --> 00:10:04,880
thing but as you can imagine this type

246
00:10:03,110 --> 00:10:07,070
of manual analysis is quite difficult

247
00:10:04,880 --> 00:10:08,780
it's it's repetitive and time-consuming

248
00:10:07,070 --> 00:10:11,170
and it requires a lot of iterative

249
00:10:08,780 --> 00:10:13,370
exploration throughout a code base

250
00:10:11,170 --> 00:10:15,979
manually checking a code base as well as

251
00:10:13,370 --> 00:10:18,380
is prone to human error so the the more

252
00:10:15,980 --> 00:10:21,440
complex the the mistake you're checking

253
00:10:18,380 --> 00:10:23,630
for or the larger the code base or the

254
00:10:21,440 --> 00:10:25,670
closer the deadline the more likely it

255
00:10:23,630 --> 00:10:27,920
is that you'll miss something and it

256
00:10:25,670 --> 00:10:30,020
says it's just not scalable as the size

257
00:10:27,920 --> 00:10:31,250
of the code base increases manually

258
00:10:30,020 --> 00:10:32,930
affecting for a particular cost of

259
00:10:31,250 --> 00:10:35,240
vulnerability every time that new one is

260
00:10:32,930 --> 00:10:37,430
discovered becomes infeasible as your

261
00:10:35,240 --> 00:10:38,570
list of mistakes need to grow or as your

262
00:10:37,430 --> 00:10:40,640
list of mistakes that you need to look

263
00:10:38,570 --> 00:10:42,440
for continue to grow the list of things

264
00:10:40,640 --> 00:10:45,260
you need to check a code review also

265
00:10:42,440 --> 00:10:48,140
increases making the code review process

266
00:10:45,260 --> 00:10:52,310
either much slower or inaccurate and

267
00:10:48,140 --> 00:10:54,319
insufficient and on top of that even in

268
00:10:52,310 --> 00:10:56,449
the most high-tech companies the number

269
00:10:54,320 --> 00:10:58,010
of full-time developers far outweigh the

270
00:10:56,450 --> 00:11:00,320
number of people working on the security

271
00:10:58,010 --> 00:11:02,480
teams so how can we expect these

272
00:11:00,320 --> 00:11:03,740
security teams to actually keep up with

273
00:11:02,480 --> 00:11:08,030
all of the code being written by their

274
00:11:03,740 --> 00:11:10,000
developers so what can you do if variant

275
00:11:08,030 --> 00:11:13,089
analysis is critical for you

276
00:11:10,000 --> 00:11:18,579
and yet doing so is infeasible some of

277
00:11:13,089 --> 00:11:20,829
you might already realize this but we

278
00:11:18,579 --> 00:11:21,849
can maybe we can automate it right what

279
00:11:20,829 --> 00:11:23,680
if there's a way in which we could

280
00:11:21,850 --> 00:11:25,750
describe certain types of coding

281
00:11:23,680 --> 00:11:27,758
mistakes that others automatically find

282
00:11:25,750 --> 00:11:30,399
instances of that mistake across an

283
00:11:27,759 --> 00:11:31,930
entire code base using not only like

284
00:11:30,399 --> 00:11:34,600
syntactic information about our software

285
00:11:31,930 --> 00:11:36,670
but also including a bunch of semantic

286
00:11:34,600 --> 00:11:40,569
information like the cool graphs control

287
00:11:36,670 --> 00:11:42,430
flow data flow we could then run them

288
00:11:40,569 --> 00:11:44,469
across run these checks across the our

289
00:11:42,430 --> 00:11:46,899
entire code base run them across

290
00:11:44,470 --> 00:11:48,910
multiple code bases and even run them

291
00:11:46,899 --> 00:11:51,100
continuously in the future to guard

292
00:11:48,910 --> 00:11:53,500
against repeating the past mistakes that

293
00:11:51,100 --> 00:11:56,259
we've made so it turns out there are

294
00:11:53,500 --> 00:11:58,149
actually a few tools already that allow

295
00:11:56,259 --> 00:12:00,819
you to do exactly this and they're

296
00:11:58,149 --> 00:12:02,740
definitely increasing in popularity so

297
00:12:00,819 --> 00:12:04,899
client ID for example part of the clan

298
00:12:02,740 --> 00:12:07,180
compiler can be extended to write rules

299
00:12:04,899 --> 00:12:09,300
for C++ that take into account both

300
00:12:07,180 --> 00:12:12,370
syntactic and semantic information

301
00:12:09,300 --> 00:12:14,920
Mozilla actually have a custom set of

302
00:12:12,370 --> 00:12:17,019
rules that they've written that run

303
00:12:14,920 --> 00:12:19,059
against every patch to Firefox that

304
00:12:17,019 --> 00:12:20,470
submit and fabricator and these are

305
00:12:19,059 --> 00:12:21,790
rules that they every time they come

306
00:12:20,470 --> 00:12:22,839
across a new security vulnerability

307
00:12:21,790 --> 00:12:24,579
they're like oh right coming around a

308
00:12:22,839 --> 00:12:27,509
clang rule for this and they then go

309
00:12:24,579 --> 00:12:30,250
through the effort of actually doing so

310
00:12:27,509 --> 00:12:31,569
and lint is as well are starting to

311
00:12:30,250 --> 00:12:33,420
include more and more semantic

312
00:12:31,569 --> 00:12:36,189
information for their rule set to use

313
00:12:33,420 --> 00:12:41,589
particularly those that work with

314
00:12:36,189 --> 00:12:44,529
statically typed languages there's also

315
00:12:41,589 --> 00:12:47,410
projects like cosa Nell I think I'm not

316
00:12:44,529 --> 00:12:49,149
sure how to say for C and there are a

317
00:12:47,410 --> 00:12:50,680
number of technologies emerging that

318
00:12:49,149 --> 00:12:54,279
allow you to interactively write queries

319
00:12:50,680 --> 00:12:57,699
over source code that includes semantic

320
00:12:54,279 --> 00:12:59,949
information including one solution by my

321
00:12:57,699 --> 00:13:01,779
company called a code QL you may have

322
00:12:59,949 --> 00:13:04,019
heard it before called sam'l QL we're

323
00:13:01,779 --> 00:13:06,639
actually in the process of renaming it

324
00:13:04,019 --> 00:13:08,290
now I'm not gonna in this presentation

325
00:13:06,639 --> 00:13:10,300
directly compare any of these different

326
00:13:08,290 --> 00:13:13,000
technologies or tell you why you should

327
00:13:10,300 --> 00:13:14,740
use code QL over one of the others but

328
00:13:13,000 --> 00:13:17,649
it is my aim to make sure we're this

329
00:13:14,740 --> 00:13:19,660
present presentation to show you why we

330
00:13:17,649 --> 00:13:21,069
need tools like this what they can do

331
00:13:19,660 --> 00:13:23,709
for us and how that might fit into your

332
00:13:21,069 --> 00:13:27,040
workflow altum Utley I don't really care

333
00:13:23,710 --> 00:13:28,390
which tool you use and I think that like

334
00:13:27,040 --> 00:13:29,709
personally I think that the more

335
00:13:28,390 --> 00:13:31,990
alternatives we have the better the

336
00:13:29,710 --> 00:13:33,630
healthier is for our ecosystem and it'll

337
00:13:31,990 --> 00:13:36,700
ultimately be up to you what you choose

338
00:13:33,630 --> 00:13:38,620
and that being said and cocuwa is the

339
00:13:36,700 --> 00:13:43,779
tool that I'm most familiar with so I'll

340
00:13:38,620 --> 00:13:46,720
be using it in my next example so this

341
00:13:43,779 --> 00:13:48,100
example is from the same blog post that

342
00:13:46,720 --> 00:13:51,450
I took the quote from earlier from the

343
00:13:48,100 --> 00:13:54,760
Microsoft Security Response Center and

344
00:13:51,450 --> 00:13:57,130
it is about chakra core which is the

345
00:13:54,760 --> 00:13:59,830
JavaScript engine that powers edge and a

346
00:13:57,130 --> 00:14:01,660
bunch of other Windows applications so

347
00:13:59,830 --> 00:14:06,670
how many people here are familiar with

348
00:14:01,660 --> 00:14:10,770
C++ - a decent amount okay I'll paste

349
00:14:06,670 --> 00:14:13,750
this somewhat slowly then in my case so

350
00:14:10,770 --> 00:14:14,949
this is this is the C plus this is C++

351
00:14:13,750 --> 00:14:17,290
code that is part of it built-in

352
00:14:14,950 --> 00:14:19,330
function that can be called from within

353
00:14:17,290 --> 00:14:20,620
JavaScript actually how many people are

354
00:14:19,330 --> 00:14:24,360
familiar with JavaScript as well

355
00:14:20,620 --> 00:14:28,810
a few more okay cool

356
00:14:24,360 --> 00:14:31,690
so this is actually you can imagine some

357
00:14:28,810 --> 00:14:32,859
of the built-in javascript methods that

358
00:14:31,690 --> 00:14:34,990
you can use the don't actually implement

359
00:14:32,860 --> 00:14:38,770
in JavaScript this this is an

360
00:14:34,990 --> 00:14:40,720
illustration of one of them and I'll

361
00:14:38,770 --> 00:14:44,500
just quickly explain what it does or the

362
00:14:40,720 --> 00:14:46,930
problem with with what it does so this

363
00:14:44,500 --> 00:14:49,360
particular function deals with an array

364
00:14:46,930 --> 00:14:52,390
buffers in JavaScript and the first

365
00:14:49,360 --> 00:14:54,850
thing it does is it gets the pointer to

366
00:14:52,390 --> 00:14:56,620
and the size of a particular block of

367
00:14:54,850 --> 00:14:58,300
memory that represents the JavaScript

368
00:14:56,620 --> 00:15:00,220
array buffer one that's passed in

369
00:14:58,300 --> 00:15:03,400
through the arguments of the function

370
00:15:00,220 --> 00:15:06,820
and it assigns those values to the

371
00:15:03,400 --> 00:15:09,819
variables P buffer and buffer size after

372
00:15:06,820 --> 00:15:11,709
that this call to var to int may

373
00:15:09,820 --> 00:15:14,980
potentially run jobs arbitrary

374
00:15:11,709 --> 00:15:16,930
JavaScript code because the way it works

375
00:15:14,980 --> 00:15:19,839
is it actually calls and the Java

376
00:15:16,930 --> 00:15:22,569
scripts or the the value of property of

377
00:15:19,839 --> 00:15:24,399
the passed object to calculate its value

378
00:15:22,570 --> 00:15:27,700
and I'll show you some Java scripts in a

379
00:15:24,399 --> 00:15:29,440
minute to illustrate that but with this

380
00:15:27,700 --> 00:15:31,270
given that you're calling back in

381
00:15:29,440 --> 00:15:34,690
JavaScript code you could for example

382
00:15:31,270 --> 00:15:37,089
override the value of property of the

383
00:15:34,690 --> 00:15:40,059
object that you pass in to free the

384
00:15:37,089 --> 00:15:41,980
buffer and then when this code returns P

385
00:15:40,059 --> 00:15:43,990
buff would be a dangling pointer it

386
00:15:41,980 --> 00:15:47,740
wouldn't it wouldn't refer to the array

387
00:15:43,990 --> 00:15:49,959
anymore okay so at this point P buffer

388
00:15:47,740 --> 00:15:51,100
is now a dangling pointer and buffer

389
00:15:49,959 --> 00:15:55,329
size refers to the size of the array

390
00:15:51,100 --> 00:15:56,889
that the buffer used to be so then when

391
00:15:55,329 --> 00:15:59,170
you later try to perform in an operand

392
00:15:56,889 --> 00:16:00,550
operation on this array using these two

393
00:15:59,170 --> 00:16:03,759
variables you encounter a memory

394
00:16:00,550 --> 00:16:06,490
corruption vulnerability so this is a

395
00:16:03,759 --> 00:16:08,470
more or less what a JavaScript exploit

396
00:16:06,490 --> 00:16:11,110
would look like and the key bit is their

397
00:16:08,470 --> 00:16:13,059
overriding this value of property which

398
00:16:11,110 --> 00:16:20,620
will be executed when you end up calling

399
00:16:13,059 --> 00:16:21,969
that native JavaScript function so in

400
00:16:20,620 --> 00:16:23,709
Microsoft discovered this vulnerability

401
00:16:21,970 --> 00:16:24,759
they assessed it is critical and they

402
00:16:23,709 --> 00:16:26,559
wanted to know if they were making any

403
00:16:24,759 --> 00:16:29,379
other similar mistakes in their

404
00:16:26,559 --> 00:16:32,529
JavaScript code oh sorry in the Shocker

405
00:16:29,379 --> 00:16:35,139
core code so they wrote a query that

406
00:16:32,529 --> 00:16:38,170
describes the pattern of assigning a

407
00:16:35,139 --> 00:16:40,870
pointer to an array buffer so this sorry

408
00:16:38,170 --> 00:16:43,389
pointer to an array buffer to a variable

409
00:16:40,870 --> 00:16:46,449
and then calling back into JavaScript

410
00:16:43,389 --> 00:16:49,240
before using the buff boys on the

411
00:16:46,449 --> 00:16:51,790
pointer and this is more or less what

412
00:16:49,240 --> 00:16:53,410
the query looked like and I've modified

413
00:16:51,790 --> 00:16:56,349
it a little bit to make it fit into one

414
00:16:53,410 --> 00:16:58,199
slide and for anyone that's use a

415
00:16:56,350 --> 00:17:00,999
database query language like SQL

416
00:16:58,199 --> 00:17:02,589
there'll be a few familiar concepts here

417
00:17:00,999 --> 00:17:05,350
and I'll step through and describe what

418
00:17:02,589 --> 00:17:07,929
the queries do so firstly we have a from

419
00:17:05,349 --> 00:17:10,599
clause here that describes the list of

420
00:17:07,929 --> 00:17:13,029
relations that we're looking at in in

421
00:17:10,599 --> 00:17:14,260
code ql you're actually you produce a

422
00:17:13,029 --> 00:17:16,539
database of the code and then you write

423
00:17:14,260 --> 00:17:19,390
queries on top of that database so we're

424
00:17:16,539 --> 00:17:21,669
just looking at tables of data and in

425
00:17:19,390 --> 00:17:24,010
this case we're looking at the variables

426
00:17:21,669 --> 00:17:25,539
in the program assignments of array

427
00:17:24,010 --> 00:17:28,299
buffer pointers which is something

428
00:17:25,539 --> 00:17:30,190
that's defined elsewhere function calls

429
00:17:28,299 --> 00:17:33,549
and accesses to variables which is a

430
00:17:30,190 --> 00:17:34,630
read or write to a variable we then have

431
00:17:33,549 --> 00:17:36,250
a where clause that lists some

432
00:17:34,630 --> 00:17:38,710
conditions need to be satisfied and I'll

433
00:17:36,250 --> 00:17:40,299
jump into that in a second and we have a

434
00:17:38,710 --> 00:17:43,289
select clause that lists the columns

435
00:17:40,299 --> 00:17:45,668
that we want to output from our query

436
00:17:43,289 --> 00:17:47,649
jumping into the where condition this

437
00:17:45,669 --> 00:17:50,230
line ensures that the pointer assignment

438
00:17:47,649 --> 00:17:50,830
and the variable use are talking about

439
00:17:50,230 --> 00:17:52,870
the same

440
00:17:50,830 --> 00:17:55,449
variable so in this case that's the P

441
00:17:52,870 --> 00:18:00,789
buffer variable making sure that both

442
00:17:55,450 --> 00:18:05,409
the this here and this here refer to the

443
00:18:00,789 --> 00:18:07,809
same variable this next line ensures

444
00:18:05,409 --> 00:18:09,490
that there is a this function call is a

445
00:18:07,809 --> 00:18:11,830
call to a function that might execute

446
00:18:09,490 --> 00:18:14,320
JavaScript code now rather than

447
00:18:11,830 --> 00:18:16,330
enumerate in every single function in

448
00:18:14,320 --> 00:18:18,039
the chakra codebase that could

449
00:18:16,330 --> 00:18:20,379
potentially execute JavaScript code and

450
00:18:18,039 --> 00:18:22,809
the security researchers knew that any

451
00:18:20,380 --> 00:18:26,019
code that cool calls back into

452
00:18:22,809 --> 00:18:29,110
JavaScript eventually uses a function

453
00:18:26,019 --> 00:18:30,970
called method call to primitive so they

454
00:18:29,110 --> 00:18:33,519
could simply use the call graph to say

455
00:18:30,970 --> 00:18:35,830
that any function that transitively

456
00:18:33,519 --> 00:18:37,870
calls method call to primitive may

457
00:18:35,830 --> 00:18:39,158
execute JavaScript code so they might

458
00:18:37,870 --> 00:18:40,899
call it directly or a might call a

459
00:18:39,159 --> 00:18:42,159
function the calls method called a

460
00:18:40,899 --> 00:18:43,330
primitive or a might call a function

461
00:18:42,159 --> 00:18:44,980
that calls a function that calls method

462
00:18:43,330 --> 00:18:48,730
called primitive and so on and that's

463
00:18:44,980 --> 00:18:50,230
expressed in this clause here so yeah it

464
00:18:48,730 --> 00:18:53,980
would be selecting that particular

465
00:18:50,230 --> 00:18:56,289
function this next line says that this

466
00:18:53,980 --> 00:19:00,279
call to JavaScript happens after we've

467
00:18:56,289 --> 00:19:02,019
assigned the pointer so firstly we

468
00:19:00,279 --> 00:19:05,080
assign the pointer then we call this

469
00:19:02,019 --> 00:19:06,580
function and this final Clause here says

470
00:19:05,080 --> 00:19:09,658
that the usage of the pointer happens

471
00:19:06,580 --> 00:19:13,269
after we call back in to JavaScript code

472
00:19:09,659 --> 00:19:17,889
which makes sure that the usage there

473
00:19:13,269 --> 00:19:20,139
happens afterwards now in this board

474
00:19:17,889 --> 00:19:22,059
post Stephen hunter said that this query

475
00:19:20,139 --> 00:19:24,340
in addition to match from the original

476
00:19:22,059 --> 00:19:27,010
vulnerability found four additional

477
00:19:24,340 --> 00:19:31,750
variants that they also assessed as

478
00:19:27,010 --> 00:19:33,220
having critical severity so they were

479
00:19:31,750 --> 00:19:38,549
able to patch all of them at the same

480
00:19:33,220 --> 00:19:41,049
time and then release them in one patch

481
00:19:38,549 --> 00:19:42,700
so that example was very specific to the

482
00:19:41,049 --> 00:19:43,929
chakra code base but there are many

483
00:19:42,700 --> 00:19:46,690
kinds of mistakes that are a lot more

484
00:19:43,929 --> 00:19:48,370
general for example something that's a

485
00:19:46,690 --> 00:19:50,289
misuse of a particular language feature

486
00:19:48,370 --> 00:19:52,389
or mistakes that are commonly made with

487
00:19:50,289 --> 00:19:55,139
certain api's or frameworks and in those

488
00:19:52,389 --> 00:19:57,908
cases you can go one step further and

489
00:19:55,139 --> 00:20:00,010
share your queries or your checks with

490
00:19:57,909 --> 00:20:01,029
everyone else make them open source so

491
00:20:00,010 --> 00:20:03,610
that no one has to repeat the same

492
00:20:01,029 --> 00:20:04,690
mistake that you do and beyond that you

493
00:20:03,610 --> 00:20:06,189
can also take advantage

494
00:20:04,690 --> 00:20:08,920
of the queries and checks that other

495
00:20:06,190 --> 00:20:10,600
security teams that Arkansas Singh so

496
00:20:08,920 --> 00:20:12,370
that you can automatically use that

497
00:20:10,600 --> 00:20:14,020
knowledge that they're sharing and

498
00:20:12,370 --> 00:20:18,040
augment the expertise of your own team

499
00:20:14,020 --> 00:20:20,050
to demonstrate this I'll gonna go over a

500
00:20:18,040 --> 00:20:23,680
slightly different story here who's

501
00:20:20,050 --> 00:20:26,020
heard of zips net cool I know me as I

502
00:20:23,680 --> 00:20:27,970
get to explain it like all of honorable

503
00:20:26,020 --> 00:20:32,410
like were all cool vulnerabilities this

504
00:20:27,970 --> 00:20:36,700
one had a logo and it was discovered by

505
00:20:32,410 --> 00:20:37,780
the researchers it's Nick now to explain

506
00:20:36,700 --> 00:20:39,840
this vulnerability I need to talk a

507
00:20:37,780 --> 00:20:42,250
little bit about how zip files work

508
00:20:39,840 --> 00:20:46,629
who's familiar with the anatomy of a zip

509
00:20:42,250 --> 00:20:50,380
file cool a few people so you might

510
00:20:46,630 --> 00:20:53,110
think that given that a zip file is an

511
00:20:50,380 --> 00:20:54,400
archive of a directory of files that

512
00:20:53,110 --> 00:20:57,899
there might be some sort of tree

513
00:20:54,400 --> 00:20:59,800
structure inherent in zip files

514
00:20:57,900 --> 00:21:02,220
unfortunately you would be mistaken a

515
00:20:59,800 --> 00:21:05,889
zip file is simply a list of entries

516
00:21:02,220 --> 00:21:07,150
where each entry has a path string which

517
00:21:05,890 --> 00:21:09,640
actually contains the hierarchical

518
00:21:07,150 --> 00:21:12,430
information of the zip file which is

519
00:21:09,640 --> 00:21:18,070
just going to be a bunch of folder names

520
00:21:12,430 --> 00:21:20,020
and slashes etc now there is a lot of

521
00:21:18,070 --> 00:21:24,310
code out there that performs unzipping

522
00:21:20,020 --> 00:21:28,629
operations and for a lot of them what

523
00:21:24,310 --> 00:21:30,159
they do is they take the path for each

524
00:21:28,630 --> 00:21:31,900
entry as they're going through the zip

525
00:21:30,160 --> 00:21:35,550
file and just concatenate it to the

526
00:21:31,900 --> 00:21:35,550
distance but their destination directory

527
00:21:35,700 --> 00:21:43,870
however you can have paths that look

528
00:21:37,810 --> 00:21:48,040
like this the laughter recognition there

529
00:21:43,870 --> 00:21:49,989
are definitely what I was hoping for so

530
00:21:48,040 --> 00:21:52,120
notably these have path traversal

531
00:21:49,990 --> 00:21:54,070
components and which allow you to go to

532
00:21:52,120 --> 00:21:55,270
a parent directory and when you

533
00:21:54,070 --> 00:21:56,919
concatenate this with a particular

534
00:21:55,270 --> 00:21:59,950
destination directory the operating

535
00:21:56,920 --> 00:22:03,820
system will resolve these to outside the

536
00:21:59,950 --> 00:22:06,340
target directory and if you are

537
00:22:03,820 --> 00:22:09,879
unfortunate enough to be running an

538
00:22:06,340 --> 00:22:11,199
unzip in program as route and someone

539
00:22:09,880 --> 00:22:12,010
could cause a lot of damage if they send

540
00:22:11,200 --> 00:22:14,170
you a zip file

541
00:22:12,010 --> 00:22:17,350
that's malicious that you then try to

542
00:22:14,170 --> 00:22:18,100
your extract anyone as well that's

543
00:22:17,350 --> 00:22:20,168
familiar with

544
00:22:18,100 --> 00:22:22,059
UNIX file systems knows that the parent

545
00:22:20,169 --> 00:22:25,559
of route is route which means that you

546
00:22:22,059 --> 00:22:28,299
could just have a very long string of

547
00:22:25,559 --> 00:22:30,220
these and then pretty much guarantee

548
00:22:28,299 --> 00:22:33,910
where the file will be unzipped to on

549
00:22:30,220 --> 00:22:39,220
the target computer anywhere you choose

550
00:22:33,910 --> 00:22:41,679
basically so you know

551
00:22:39,220 --> 00:22:42,970
snick found this out that lots of lots

552
00:22:41,679 --> 00:22:44,799
and lots and lots of applications and

553
00:22:42,970 --> 00:22:46,750
making this mistakes they do put a very

554
00:22:44,799 --> 00:22:48,850
big effort in to try and find as many of

555
00:22:46,750 --> 00:22:50,770
them as possible and they did a big

556
00:22:48,850 --> 00:22:56,020
disclosure with like a couple of dozen

557
00:22:50,770 --> 00:22:57,250
projects now Microsoft also wanted to

558
00:22:56,020 --> 00:22:59,289
know oh actually before I go on that

559
00:22:57,250 --> 00:23:02,230
here's an example of some vulnerable

560
00:22:59,289 --> 00:23:03,429
code and this is the problematic line

561
00:23:02,230 --> 00:23:07,090
where you're basically joining the

562
00:23:03,429 --> 00:23:11,169
destination directory to the path of the

563
00:23:07,090 --> 00:23:13,360
zip file entry and to prevent the

564
00:23:11,169 --> 00:23:16,690
vulnerability it requires this one line

565
00:23:13,360 --> 00:23:18,100
here or these two lines and in pretty

566
00:23:16,690 --> 00:23:21,159
much every programming language the

567
00:23:18,100 --> 00:23:24,070
fixes is about that simple so it's very

568
00:23:21,159 --> 00:23:25,539
worth doing regardless of what the

569
00:23:24,070 --> 00:23:27,460
threat model necessarily is of the

570
00:23:25,539 --> 00:23:31,179
application or whether you're expecting

571
00:23:27,460 --> 00:23:32,679
to extract malicious zip files so

572
00:23:31,179 --> 00:23:35,049
Microsoft want to know if they were

573
00:23:32,679 --> 00:23:40,360
making mistakes like this anywhere in

574
00:23:35,049 --> 00:23:44,350
their code so they wrote a query this

575
00:23:40,360 --> 00:23:48,908
query search for C flap code where data

576
00:23:44,350 --> 00:23:51,010
was flowing from zip entry paths to IO

577
00:23:48,909 --> 00:23:52,929
operations without some sort of

578
00:23:51,010 --> 00:23:56,650
standardization step like this along the

579
00:23:52,929 --> 00:24:00,510
way they ran across their code found a

580
00:23:56,650 --> 00:24:03,460
bunch of results fixed all the results

581
00:24:00,510 --> 00:24:05,860
but then what they did is they open

582
00:24:03,460 --> 00:24:07,480
source the query so that other people

583
00:24:05,860 --> 00:24:09,158
that had C shop code that did any

584
00:24:07,480 --> 00:24:10,900
unzipping operations could also

585
00:24:09,159 --> 00:24:15,220
automatically check for zip zip

586
00:24:10,900 --> 00:24:17,080
vulnerabilities and then there are few

587
00:24:15,220 --> 00:24:18,309
more queries written for other languages

588
00:24:17,080 --> 00:24:23,889
and other checks that people could run

589
00:24:18,309 --> 00:24:26,230
as well so I may have convinced you at

590
00:24:23,890 --> 00:24:29,559
this point of some of the value of doing

591
00:24:26,230 --> 00:24:31,879
variant analysis and I'd like to quickly

592
00:24:29,559 --> 00:24:33,259
go over what it might look like if you

593
00:24:31,879 --> 00:24:37,478
- very NASA's and fit it into the

594
00:24:33,259 --> 00:24:37,479
workflow for development of your company

595
00:24:37,719 --> 00:24:43,369
so this is a simplified model of

596
00:24:41,779 --> 00:24:45,799
basically what companies like Microsoft

597
00:24:43,369 --> 00:24:48,079
and Google are doing and I'm going to

598
00:24:45,799 --> 00:24:49,339
assume that you already have a workflow

599
00:24:48,079 --> 00:24:52,129
in place for responding to

600
00:24:49,339 --> 00:24:55,369
vulnerabilities and if not we'll go over

601
00:24:52,129 --> 00:24:56,478
that in a bit so you probably have

602
00:24:55,369 --> 00:24:58,968
something that looks similar to this you

603
00:24:56,479 --> 00:25:01,639
find out about a new bug diagnose it to

604
00:24:58,969 --> 00:25:04,819
find its root cause fix the bug and then

605
00:25:01,639 --> 00:25:06,109
deploy the fix to your users the natural

606
00:25:04,819 --> 00:25:07,729
place of Verret analysis to fit in it

607
00:25:06,109 --> 00:25:10,819
would be as additional steps after this

608
00:25:07,729 --> 00:25:12,589
after the root cause analysis firstly

609
00:25:10,819 --> 00:25:17,629
you would describe the mistake as a

610
00:25:12,589 --> 00:25:19,999
query in whichever tool you're using to

611
00:25:17,629 --> 00:25:22,279
do this automate event analysis you

612
00:25:19,999 --> 00:25:24,739
would run this query against your code

613
00:25:22,279 --> 00:25:25,789
basis to see what results you get you'll

614
00:25:24,739 --> 00:25:28,129
probably end up with a number of false

615
00:25:25,789 --> 00:25:30,559
positives or results that aren't

616
00:25:28,129 --> 00:25:32,059
actually vulnerable and so you'll

617
00:25:30,559 --> 00:25:34,369
probably want to improve your query

618
00:25:32,059 --> 00:25:36,889
until the false positives are at an

619
00:25:34,369 --> 00:25:39,799
acceptable level and low enough that you

620
00:25:36,889 --> 00:25:42,379
can actually try out them manually and

621
00:25:39,799 --> 00:25:44,329
go through each of the results by fixing

622
00:25:42,379 --> 00:25:47,389
all of these vulnerabilities that you

623
00:25:44,329 --> 00:25:50,329
actually found that a valid it would

624
00:25:47,389 --> 00:25:52,339
then be at this point after you've fixed

625
00:25:50,329 --> 00:25:55,489
always variants that you would then

626
00:25:52,339 --> 00:25:56,899
deploy a new version of the code to

627
00:25:55,489 --> 00:26:00,319
users fixing all of these

628
00:25:56,899 --> 00:26:02,299
vulnerabilities at the same time beyond

629
00:26:00,319 --> 00:26:04,309
this now that the query is written you

630
00:26:02,299 --> 00:26:06,440
can actually run these queries regularly

631
00:26:04,309 --> 00:26:10,489
continuously monitoring your code for

632
00:26:06,440 --> 00:26:12,859
new variants for example it could be run

633
00:26:10,489 --> 00:26:13,969
periodically or just before a release to

634
00:26:12,859 --> 00:26:16,099
make sure that you haven't introduced

635
00:26:13,969 --> 00:26:17,899
any new bugs since the last release or

636
00:26:16,099 --> 00:26:20,479
even better it could be incorporated

637
00:26:17,899 --> 00:26:22,609
into the CI process for your developers

638
00:26:20,479 --> 00:26:24,259
workflow to make sure that all incoming

639
00:26:22,609 --> 00:26:27,978
code changes are checked before they get

640
00:26:24,259 --> 00:26:29,209
matched you know discovering and fixing

641
00:26:27,979 --> 00:26:33,529
them in code review which is effectively

642
00:26:29,209 --> 00:26:35,629
what Mozilla are doing with time the

643
00:26:33,529 --> 00:26:37,399
final ideal step beyond this would be to

644
00:26:35,629 --> 00:26:38,658
share this query if it's a

645
00:26:37,399 --> 00:26:41,869
general-purpose query and it makes sense

646
00:26:38,659 --> 00:26:43,669
as widely as possible ideally open

647
00:26:41,869 --> 00:26:45,500
sourcing it so that other security

648
00:26:43,669 --> 00:26:47,450
researchers or other security

649
00:26:45,500 --> 00:26:48,740
and development teams can benefit from

650
00:26:47,450 --> 00:26:51,250
your research and the mistakes that

651
00:26:48,740 --> 00:26:53,540
you've made and then finally

652
00:26:51,250 --> 00:26:55,670
incorporating the queries and checks

653
00:26:53,540 --> 00:26:56,930
that other people are making so that you

654
00:26:55,670 --> 00:27:01,570
don't make those same mistakes that they

655
00:26:56,930 --> 00:27:03,740
happen with this whole process in place

656
00:27:01,570 --> 00:27:06,230
your software will probably have far

657
00:27:03,740 --> 00:27:07,940
fewer bugs or far fewer vulnerabilities

658
00:27:06,230 --> 00:27:12,490
caused by repeated and easily

659
00:27:07,940 --> 00:27:15,020
preventable mistakes I imagine that that

660
00:27:12,490 --> 00:27:18,290
would bring for example Microsoft's

661
00:27:15,020 --> 00:27:19,190
number of reports down quite a bit so

662
00:27:18,290 --> 00:27:20,300
what about for those of us that don't

663
00:27:19,190 --> 00:27:23,480
actually have a security response

664
00:27:20,300 --> 00:27:26,389
process for example you may be part of a

665
00:27:23,480 --> 00:27:30,710
small software start-up or working on

666
00:27:26,390 --> 00:27:31,670
open source projects well the first

667
00:27:30,710 --> 00:27:33,280
thing to understand is that sooner or

668
00:27:31,670 --> 00:27:35,960
later if you were developing software

669
00:27:33,280 --> 00:27:37,160
you are probably going to be faced with

670
00:27:35,960 --> 00:27:40,070
the vulnerability that you need to deal

671
00:27:37,160 --> 00:27:41,450
with and it would be good to have an

672
00:27:40,070 --> 00:27:43,280
idea of how you would go about dealing

673
00:27:41,450 --> 00:27:45,950
with that situation but in the meantime

674
00:27:43,280 --> 00:27:47,680
until you get your first form of reality

675
00:27:45,950 --> 00:27:50,390
discovery I would definitely recommend

676
00:27:47,680 --> 00:27:53,570
making some form of automated checks

677
00:27:50,390 --> 00:27:54,980
part of your workflow by running you

678
00:27:53,570 --> 00:27:57,290
know zoo security tools that are freely

679
00:27:54,980 --> 00:27:58,610
available to run and automatically

680
00:27:57,290 --> 00:28:02,690
analyze your pull requests for things

681
00:27:58,610 --> 00:28:04,669
and if things are already well known and

682
00:28:02,690 --> 00:28:05,990
talked about and take advantage of the

683
00:28:04,670 --> 00:28:09,050
knowledge that's already being shared by

684
00:28:05,990 --> 00:28:11,680
various security teams and if you're a

685
00:28:09,050 --> 00:28:14,149
security researcher or a consultant and

686
00:28:11,680 --> 00:28:15,650
you can actually take advantage of of

687
00:28:14,150 --> 00:28:17,810
tools like this to find even more

688
00:28:15,650 --> 00:28:19,280
vulnerabilities than you already are you

689
00:28:17,810 --> 00:28:21,050
go over pass vulnerabilities that you've

690
00:28:19,280 --> 00:28:22,879
discovered maybe write queries or checks

691
00:28:21,050 --> 00:28:25,010
for them see if there are any that you

692
00:28:22,880 --> 00:28:27,320
missed run these queries against other

693
00:28:25,010 --> 00:28:29,360
projects that might be applicable maybe

694
00:28:27,320 --> 00:28:36,020
you could get access to a few more

695
00:28:29,360 --> 00:28:38,090
bounties which is always good so if you

696
00:28:36,020 --> 00:28:40,430
want to get start with very analysis how

697
00:28:38,090 --> 00:28:41,810
do you do that well I'm not going to

698
00:28:40,430 --> 00:28:43,970
recommend that you go ahead again and

699
00:28:41,810 --> 00:28:45,560
use github software that's a choice for

700
00:28:43,970 --> 00:28:47,900
you to make but I do want you to

701
00:28:45,560 --> 00:28:49,040
consider what variant analysis could do

702
00:28:47,900 --> 00:28:51,830
for you if that's something that will

703
00:28:49,040 --> 00:28:55,040
work for you and what tools will help

704
00:28:51,830 --> 00:28:56,330
you achieve better security hopefully

705
00:28:55,040 --> 00:28:58,310
reduce the amount of manual work that

706
00:28:56,330 --> 00:28:59,389
you're doing see if you're writing or

707
00:28:58,310 --> 00:29:02,240
maintaining software

708
00:28:59,390 --> 00:29:03,890
look at which tools other companies are

709
00:29:02,240 --> 00:29:07,910
using some large software projects etc

710
00:29:03,890 --> 00:29:08,900
and try out a different selection see

711
00:29:07,910 --> 00:29:11,059
what works for you

712
00:29:08,900 --> 00:29:14,540
if you're a blue team ER or security

713
00:29:11,059 --> 00:29:15,950
researcher experiment writing checks or

714
00:29:14,540 --> 00:29:16,790
queries with different technologies it

715
00:29:15,950 --> 00:29:19,299
might be that the sorts of

716
00:29:16,790 --> 00:29:21,590
vulnerabilities that you're looking into

717
00:29:19,299 --> 00:29:24,440
even more easily expressed in one tool a

718
00:29:21,590 --> 00:29:25,669
for another and you know take a look at

719
00:29:24,440 --> 00:29:28,549
what other researchers are doing as well

720
00:29:25,670 --> 00:29:30,610
like a blog posts look at research go to

721
00:29:28,549 --> 00:29:36,370
talks and stuff

722
00:29:30,610 --> 00:29:39,790
so to recap you should do very analogous

723
00:29:36,370 --> 00:29:42,049
if you were creating software that is

724
00:29:39,790 --> 00:29:45,200
better yet you should do automated very

725
00:29:42,049 --> 00:29:46,580
analysis check should be run

726
00:29:45,200 --> 00:29:48,020
continuously not once off when a

727
00:29:46,580 --> 00:29:49,549
vulnerabilities discovered because you

728
00:29:48,020 --> 00:29:52,179
can there's always a chance you can make

729
00:29:49,549 --> 00:29:54,049
that mistake again in the future and

730
00:29:52,179 --> 00:29:55,910
using contribute to your open source

731
00:29:54,049 --> 00:29:58,660
queries help other security teams and

732
00:29:55,910 --> 00:30:01,429
use the knowledge that they're sharing

733
00:29:58,660 --> 00:30:04,040
if you are a security researcher you can

734
00:30:01,429 --> 00:30:05,330
use for analysis as a tool to find a

735
00:30:04,040 --> 00:30:07,879
many more vulnerabilities and really

736
00:30:05,330 --> 00:30:10,639
supercharge your research and then the

737
00:30:07,880 --> 00:30:12,799
last thing I want to say is that variant

738
00:30:10,640 --> 00:30:14,059
analysis is not a replacement to things

739
00:30:12,799 --> 00:30:16,668
that are already out there it is very

740
00:30:14,059 --> 00:30:18,320
much a complimentary enhancing thing to

741
00:30:16,669 --> 00:30:20,059
other things for example if you're

742
00:30:18,320 --> 00:30:22,730
already using fuzzing a lot at neo

743
00:30:20,059 --> 00:30:25,070
toolkit you can then take results for

744
00:30:22,730 --> 00:30:28,220
positive results from fuzzing and then

745
00:30:25,070 --> 00:30:29,480
write queries for that and then find

746
00:30:28,220 --> 00:30:31,250
even more vulnerabilities and prevent

747
00:30:29,480 --> 00:30:33,440
again against entire classes of

748
00:30:31,250 --> 00:30:36,650
vulnerabilities if you're using pen

749
00:30:33,440 --> 00:30:38,750
testing or red teaming that sort of

750
00:30:36,650 --> 00:30:42,440
thing then again your discoveries you

751
00:30:38,750 --> 00:30:46,309
make with that can be multiplied by when

752
00:30:42,440 --> 00:30:51,700
you use very nurses that's about all I

753
00:30:46,309 --> 00:30:54,809
have time for and all I have thank you

754
00:30:51,700 --> 00:30:54,809
[Applause]

755
00:30:58,289 --> 00:31:09,250
thank you very much for your talk we

756
00:31:00,669 --> 00:31:13,570
have time for questions do you know if

757
00:31:09,250 --> 00:31:16,659
any usage not as internal development to

758
00:31:13,570 --> 00:31:21,639
team but lifting the intermediate

759
00:31:16,659 --> 00:31:25,330
language or using these assembler to get

760
00:31:21,639 --> 00:31:28,240
the code of a close binary and usage and

761
00:31:25,330 --> 00:31:30,399
there have definitely and there are

762
00:31:28,240 --> 00:31:34,000
definitely tools that lie to do a lot of

763
00:31:30,399 --> 00:31:35,408
data flow analysis over binaries that

764
00:31:34,000 --> 00:31:37,600
sort of thing it took Mac QL

765
00:31:35,409 --> 00:31:39,639
specifically or yet to have the same

766
00:31:37,600 --> 00:31:42,009
kind of query to be able to do it there

767
00:31:39,639 --> 00:31:45,039
have been experiments a lot of sort of

768
00:31:42,009 --> 00:31:48,129
patents that you look for stuff that's

769
00:31:45,039 --> 00:31:50,830
often lost when it's something's

770
00:31:48,129 --> 00:31:53,049
compiled to binary like it might be you

771
00:31:50,830 --> 00:31:56,289
might use certain hints like the naming

772
00:31:53,049 --> 00:31:59,730
of certain functions and stuff that not

773
00:31:56,289 --> 00:32:02,408
a certain thing or usage of certain

774
00:31:59,730 --> 00:32:03,879
internal libraries and there's

775
00:32:02,409 --> 00:32:06,580
definitely people that have done that

776
00:32:03,879 --> 00:32:15,850
and found a bunch of things but it's not

777
00:32:06,580 --> 00:32:18,009
it's most common use case how would you

778
00:32:15,850 --> 00:32:22,289
assess that the external knowledge base

779
00:32:18,009 --> 00:32:29,470
doesn't use unknown vulnerabilities you

780
00:32:22,289 --> 00:32:31,299
don't you like the quite often the and

781
00:32:29,470 --> 00:32:32,649
then ask that's kind of the point of it

782
00:32:31,299 --> 00:32:35,590
as well like someone creates a new query

783
00:32:32,649 --> 00:32:37,090
that query may reveal something new that

784
00:32:35,590 --> 00:32:39,189
you didn't know about in your source

785
00:32:37,090 --> 00:32:40,840
code so you'll want to probably run that

786
00:32:39,190 --> 00:32:47,700
to check it and see if you can find

787
00:32:40,840 --> 00:32:47,699
anything yeah questions yep

788
00:32:52,850 --> 00:32:58,199
are there some tools that automatically

789
00:32:56,040 --> 00:33:04,530
generate queries based on that Susan's

790
00:32:58,200 --> 00:33:05,790
also figures there are some tools I

791
00:33:04,530 --> 00:33:08,910
think come Sanel might do something

792
00:33:05,790 --> 00:33:10,590
similar to that where you I'm not sure

793
00:33:08,910 --> 00:33:14,820
where it's generated on a patch but you

794
00:33:10,590 --> 00:33:16,770
can definitely describe you can describe

795
00:33:14,820 --> 00:33:18,179
patterns that also include fixes that

796
00:33:16,770 --> 00:33:19,440
can automatically generate patches so

797
00:33:18,180 --> 00:33:22,140
it's kind of the other the other way

798
00:33:19,440 --> 00:33:23,429
around I'm not sure if there are many

799
00:33:22,140 --> 00:33:25,410
tools that will do an analysis of a

800
00:33:23,429 --> 00:33:27,090
patch to work out what the vulnerability

801
00:33:25,410 --> 00:33:28,860
is I think quite often with that you

802
00:33:27,090 --> 00:33:30,959
might end up with situations where it's

803
00:33:28,860 --> 00:33:33,030
not general enough and will only end up

804
00:33:30,960 --> 00:33:36,120
finding just that particular patch and

805
00:33:33,030 --> 00:33:38,490
not similar problems so that's always

806
00:33:36,120 --> 00:33:40,919
kind of a when you're designing a check

807
00:33:38,490 --> 00:33:42,900
that's always sort of something you need

808
00:33:40,920 --> 00:33:55,050
to consider like how general-purpose can

809
00:33:42,900 --> 00:33:57,330
I make this yep so I'm gonna be really

810
00:33:55,050 --> 00:33:59,669
familiar but could you also state an

811
00:33:57,330 --> 00:34:02,280
outcome to remove false positives so not

812
00:33:59,670 --> 00:34:04,320
just how to find it but also and you

813
00:34:02,280 --> 00:34:06,570
should expect but by fasting whatever

814
00:34:04,320 --> 00:34:09,239
you find to have a dangling pointer for

815
00:34:06,570 --> 00:34:10,590
example so you then could potentially

816
00:34:09,239 --> 00:34:14,520
remove they're false positives on the

817
00:34:10,590 --> 00:34:18,000
search so again about kql specifically

818
00:34:14,520 --> 00:34:23,129
or so in the past we've definitely

819
00:34:18,000 --> 00:34:24,989
augmented those sorts of results with or

820
00:34:23,129 --> 00:34:26,279
we added other relational data to the

821
00:34:24,989 --> 00:34:27,810
database that you could then incorporate

822
00:34:26,280 --> 00:34:28,860
into queries I think for doing that

823
00:34:27,810 --> 00:34:30,418
you'd probably want to actually produce

824
00:34:28,860 --> 00:34:32,159
the results table and then actually run

825
00:34:30,418 --> 00:34:34,500
a a second step afterwards which would

826
00:34:32,159 --> 00:34:35,810
be something that Cody well doesn't

827
00:34:34,500 --> 00:34:39,120
specifically do but you could definitely

828
00:34:35,810 --> 00:34:40,500
do use Koki well in that fashion but I'm

829
00:34:39,120 --> 00:34:42,239
not aware of anyone that's actually

830
00:34:40,500 --> 00:34:44,219
doing it in that way they most of the

831
00:34:42,239 --> 00:34:51,928
triad ring is actually done manually

832
00:34:44,219 --> 00:34:54,350
afterwards more questions I actually

833
00:34:51,929 --> 00:34:58,470
have a question myself yeah

834
00:34:54,350 --> 00:35:02,700
so in this like crazy world we have some

835
00:34:58,470 --> 00:35:04,080
companies are actually running several

836
00:35:02,700 --> 00:35:06,569
different really

837
00:35:04,080 --> 00:35:09,900
as per day I'm thinking about DevOps for

838
00:35:06,570 --> 00:35:11,970
example does this fit in this kind of I

839
00:35:09,900 --> 00:35:13,920
definitely think so you would end up

840
00:35:11,970 --> 00:35:16,310
putting that you'd end up relying on

841
00:35:13,920 --> 00:35:19,710
something that you you run during the

842
00:35:16,310 --> 00:35:22,410
kind of like CI stage rather than kind

843
00:35:19,710 --> 00:35:23,820
of junior release so before I you know

844
00:35:22,410 --> 00:35:26,069
it's kind of at the same time you do

845
00:35:23,820 --> 00:35:28,320
code review you would run checks might

846
00:35:26,070 --> 00:35:30,630
okay this this patch does or doesn't

847
00:35:28,320 --> 00:35:33,020
introduce any results and then acts upon

848
00:35:30,630 --> 00:35:35,520
it as I mean that's effectively what

849
00:35:33,020 --> 00:35:37,350
Google and Microsoft again they hit they

850
00:35:35,520 --> 00:35:44,370
have a lot of very regular patches and

851
00:35:37,350 --> 00:35:46,100
they and Mozilla as well so yeah one

852
00:35:44,370 --> 00:35:49,900
last question

853
00:35:46,100 --> 00:35:53,078
okay thank you very much again thanks

854
00:35:49,900 --> 00:35:53,079
[Applause]

