1
00:00:02,840 --> 00:00:05,580
so hello everyone thank you to be here

2
00:00:05,580 --> 00:00:08,160
for my presentation some cracks in the

3
00:00:08,160 --> 00:00:10,500
Linux fireover I will present you

4
00:00:10,500 --> 00:00:13,080
several innovators iPhone in the Linux

5
00:00:13,080 --> 00:00:15,599
kernel during my internship

6
00:00:15,599 --> 00:00:19,619
so let's see the the plan of the day

7
00:00:19,619 --> 00:00:21,119
I will just start with a small

8
00:00:21,119 --> 00:00:23,460
introduction about some components we

9
00:00:23,460 --> 00:00:26,039
need for the presentation

10
00:00:26,039 --> 00:00:28,080
then I represent you in that filter the

11
00:00:28,080 --> 00:00:30,420
Linux firewall and I will present some

12
00:00:30,420 --> 00:00:32,460
technical details to understand the

13
00:00:32,460 --> 00:00:33,840
presentation

14
00:00:33,840 --> 00:00:36,780
and in the third part we will I will

15
00:00:36,780 --> 00:00:39,360
explain uh the winner the process and

16
00:00:39,360 --> 00:00:41,340
all iPhone two vulnerabilities in that

17
00:00:41,340 --> 00:00:42,120
filter

18
00:00:42,120 --> 00:00:44,340
and to conclude we have a small

19
00:00:44,340 --> 00:00:47,160
discussion on the Linux security and and

20
00:00:47,160 --> 00:00:49,860
we will conclude the presentation

21
00:00:49,860 --> 00:00:53,219
so as traditional few words about me so

22
00:00:53,219 --> 00:00:55,640
my name is

23
00:00:56,539 --> 00:00:59,100
a security researcher

24
00:00:59,100 --> 00:01:01,739
I'm mainly interesting about reverse

25
00:01:01,739 --> 00:01:04,440
engineering and binary exploitation I

26
00:01:04,440 --> 00:01:06,420
focused my research on low level

27
00:01:06,420 --> 00:01:09,240
components and more specially I like to

28
00:01:09,240 --> 00:01:10,619
work on scanners

29
00:01:10,619 --> 00:01:14,100
and I'm so a co-organizer of Greg

30
00:01:14,100 --> 00:01:16,260
security conference that occurs in

31
00:01:16,260 --> 00:01:17,939
growing up

32
00:01:17,939 --> 00:01:20,159
on on Friday

33
00:01:20,159 --> 00:01:22,560
so I arrive at Toronto research for my

34
00:01:22,560 --> 00:01:25,200
end of Studio internship and the goal of

35
00:01:25,200 --> 00:01:26,880
this internship was to find

36
00:01:26,880 --> 00:01:29,400
vulnerabilities in the Linux kernel

37
00:01:29,400 --> 00:01:31,680
using variant analysis

38
00:01:31,680 --> 00:01:34,920
and it will the technique I use to find

39
00:01:34,920 --> 00:01:37,920
bugs and back in the Linux kernel and

40
00:01:37,920 --> 00:01:39,420
that occurs to

41
00:01:39,420 --> 00:01:43,020
is to find two vulnerabilities

42
00:01:43,020 --> 00:01:46,079
so let's introduce some components so

43
00:01:46,079 --> 00:01:48,479
first of all what is variant analysis uh

44
00:01:48,479 --> 00:01:50,280
the variant analysis is a method we use

45
00:01:50,280 --> 00:01:54,240
to find vulnerabilities and bugs and to

46
00:01:54,240 --> 00:01:57,540
more specifying pattern in the coil so

47
00:01:57,540 --> 00:01:59,820
why we use this technique we find over

48
00:01:59,820 --> 00:02:02,880
the year that several Windows looks very

49
00:02:02,880 --> 00:02:05,460
similar for Buffalo for use after three

50
00:02:05,460 --> 00:02:06,659
and so on

51
00:02:06,659 --> 00:02:10,500
so we want to find the static method to

52
00:02:10,500 --> 00:02:13,020
to detect this pattern

53
00:02:13,020 --> 00:02:15,480
and we are to Define this pattern in

54
00:02:15,480 --> 00:02:16,739
order to

55
00:02:16,739 --> 00:02:19,319
okay see if several project contains the

56
00:02:19,319 --> 00:02:21,180
same bugs or vulnerabilities

57
00:02:21,180 --> 00:02:24,239
so today there is several tool that we

58
00:02:24,239 --> 00:02:27,660
can use to perform violent analysis

59
00:02:27,660 --> 00:02:30,360
uh there is the main one I use during my

60
00:02:30,360 --> 00:02:33,180
internship is cutware but there is also

61
00:02:33,180 --> 00:02:35,819
Jordan and coxinal

62
00:02:35,819 --> 00:02:39,540
so another component I will use a lot

63
00:02:39,540 --> 00:02:41,819
during my presentation is the Linux

64
00:02:41,819 --> 00:02:43,620
namespaces

65
00:02:43,620 --> 00:02:46,140
uh this is a feature of the Linux kernel

66
00:02:46,140 --> 00:02:48,000
that is used to create separate

67
00:02:48,000 --> 00:02:49,980
environments for applications

68
00:02:49,980 --> 00:02:53,519
we can find a several one for example we

69
00:02:53,519 --> 00:02:57,060
can find username spaces to have a

70
00:02:57,060 --> 00:02:59,940
different user as the main system

71
00:02:59,940 --> 00:03:03,300
and so on there is a list here and the

72
00:03:03,300 --> 00:03:07,319
main application of the name spaces are

73
00:03:07,319 --> 00:03:09,660
the first the containers and it is the

74
00:03:09,660 --> 00:03:10,519
main

75
00:03:10,519 --> 00:03:13,500
a feature that is used by Docker to to

76
00:03:13,500 --> 00:03:16,620
works but it also can be used to build

77
00:03:16,620 --> 00:03:19,440
some sandbox and to isolate application

78
00:03:19,440 --> 00:03:22,760
from the rest of the system

79
00:03:23,060 --> 00:03:25,860
to have a better understanding first of

80
00:03:25,860 --> 00:03:28,019
all we have a clear and fresh

81
00:03:28,019 --> 00:03:29,599
environment

82
00:03:29,599 --> 00:03:32,519
but in for an application we want to

83
00:03:32,519 --> 00:03:34,980
filter more packets that is coming from

84
00:03:34,980 --> 00:03:37,620
the outside so we want to define a

85
00:03:37,620 --> 00:03:40,260
specific filter in with net filter so we

86
00:03:40,260 --> 00:03:43,680
have a you can define a network and

87
00:03:43,680 --> 00:03:45,540
space to have a

88
00:03:45,540 --> 00:03:48,900
different network environment and in

89
00:03:48,900 --> 00:03:51,540
another case we would like to iterate

90
00:03:51,540 --> 00:03:54,000
the process the process from the other

91
00:03:54,000 --> 00:03:56,580
it cannot access to the running process

92
00:03:56,580 --> 00:03:58,200
on the system

93
00:03:58,200 --> 00:04:02,459
so we can create a pilgrim space and the

94
00:04:02,459 --> 00:04:04,680
main one this is the third uh this was

95
00:04:04,680 --> 00:04:06,900
very important to process

96
00:04:06,900 --> 00:04:10,140
to use uh to find vulnerabilities is to

97
00:04:10,140 --> 00:04:12,200
use username spaces

98
00:04:12,200 --> 00:04:16,260
so we can just take a random user

99
00:04:16,260 --> 00:04:19,260
and we can simulate it as to be the root

100
00:04:19,260 --> 00:04:22,560
user and it allowed to make some

101
00:04:22,560 --> 00:04:24,720
manipulation in the kernel that we are

102
00:04:24,720 --> 00:04:26,160
not

103
00:04:26,160 --> 00:04:28,680
able to access for standard users such

104
00:04:28,680 --> 00:04:31,020
as accessing a net filter

105
00:04:31,020 --> 00:04:32,040
oh

106
00:04:32,040 --> 00:04:35,460
so okay now we have the main components

107
00:04:35,460 --> 00:04:38,460
I will present a net filter

108
00:04:38,460 --> 00:04:40,620
so net filter is a big project that is

109
00:04:40,620 --> 00:04:44,400
uh composing from civil program

110
00:04:44,400 --> 00:04:47,220
uh almost everybody knows the IP tables

111
00:04:47,220 --> 00:04:50,580
which is a binary that is used to just

112
00:04:50,580 --> 00:04:53,160
set tables and configure the firewall

113
00:04:53,160 --> 00:04:56,040
but now there is also nft which is more

114
00:04:56,040 --> 00:04:58,199
developed that is my

115
00:04:58,199 --> 00:05:01,280
dealing with many kinds of Elementary

116
00:05:01,280 --> 00:05:04,740
such as IRP or something else

117
00:05:04,740 --> 00:05:08,580
and all this binary has to communicate

118
00:05:08,580 --> 00:05:10,560
with net filter the candle model which

119
00:05:10,560 --> 00:05:12,740
is in charge of

120
00:05:12,740 --> 00:05:16,020
managing to place oof within the network

121
00:05:16,020 --> 00:05:18,840
stack in order to catch incoming packets

122
00:05:18,840 --> 00:05:22,020
and to say okay we are accepting this

123
00:05:22,020 --> 00:05:24,060
incoming packet or not

124
00:05:24,060 --> 00:05:27,240
so to communicate with the kernel module

125
00:05:27,240 --> 00:05:29,639
they are using the net filter net link

126
00:05:29,639 --> 00:05:31,860
which is aware from the kernel to

127
00:05:31,860 --> 00:05:36,060
communicate within a model and binaries

128
00:05:36,060 --> 00:05:40,820
through for specific Cisco

129
00:05:40,979 --> 00:05:43,740
so okay

130
00:05:43,740 --> 00:05:46,620
what can we do we to work with net

131
00:05:46,620 --> 00:05:50,039
filter the easy way to try and to

132
00:05:50,039 --> 00:05:52,039
practice net filter is to use the nft

133
00:05:52,039 --> 00:05:55,560
that have an interactive chair to just

134
00:05:55,560 --> 00:05:57,600
Define some objects and try to

135
00:05:57,600 --> 00:05:59,220
manipulate them

136
00:05:59,220 --> 00:06:01,740
with net filter we can manipulate and

137
00:06:01,740 --> 00:06:04,620
targeting several objects we can just

138
00:06:04,620 --> 00:06:07,020
Target in packets with his incoming

139
00:06:07,020 --> 00:06:10,080
address IP address or the destination

140
00:06:10,080 --> 00:06:11,580
port number

141
00:06:11,580 --> 00:06:14,039
and we have several action that we can

142
00:06:14,039 --> 00:06:17,340
do in packets will seem a bit later the

143
00:06:17,340 --> 00:06:19,620
different possibilities but the main

144
00:06:19,620 --> 00:06:22,080
ones we can choose to drop a packet or

145
00:06:22,080 --> 00:06:23,840
to accept it

146
00:06:23,840 --> 00:06:27,000
so okay now

147
00:06:27,000 --> 00:06:29,460
let's see what is in that filter

148
00:06:29,460 --> 00:06:33,000
we'll just uh see some technical details

149
00:06:33,000 --> 00:06:34,740
in order to have a better understanding

150
00:06:34,740 --> 00:06:37,699
of the vulnerabilities

151
00:06:38,180 --> 00:06:42,960
now on some operating system we are able

152
00:06:42,960 --> 00:06:46,740
to reach that filter with using improve

153
00:06:46,740 --> 00:06:50,340
Edge username spaces so it does that it

154
00:06:50,340 --> 00:06:52,680
was previously a component from the

155
00:06:52,680 --> 00:06:55,440
kernel that we was exclusively reserved

156
00:06:55,440 --> 00:06:58,620
for the root user but now as as I

157
00:06:58,620 --> 00:07:01,440
explained previously with username

158
00:07:01,440 --> 00:07:03,979
spaces we are able to take random users

159
00:07:03,979 --> 00:07:08,460
to be as a root user of its environment

160
00:07:08,460 --> 00:07:11,460
I also present the net link socket and

161
00:07:11,460 --> 00:07:13,380
to communicate with net filter we use

162
00:07:13,380 --> 00:07:15,360
the Cisco send message

163
00:07:15,360 --> 00:07:19,460
to send information to the kernel model

164
00:07:19,460 --> 00:07:21,780
and if you want to have some feedbacks

165
00:07:21,780 --> 00:07:25,080
from the Canon model we have the receive

166
00:07:25,080 --> 00:07:27,000
message Discord

167
00:07:27,000 --> 00:07:31,080
and the format of data is we are

168
00:07:31,080 --> 00:07:33,479
encapsulating message and we are

169
00:07:33,479 --> 00:07:36,180
descripting all the object manipulating

170
00:07:36,180 --> 00:07:39,060
by net filter within networking

171
00:07:39,060 --> 00:07:40,400
attributes

172
00:07:40,400 --> 00:07:45,120
uh here so here it's a presentation of

173
00:07:45,120 --> 00:07:47,759
all the different the main object of net

174
00:07:47,759 --> 00:07:48,780
filter

175
00:07:48,780 --> 00:07:51,360
the main was is the table where we will

176
00:07:51,360 --> 00:07:54,539
Define uh several objects within there

177
00:07:54,539 --> 00:07:56,220
is two kind of object we will Define

178
00:07:56,220 --> 00:07:59,819
some object relative to data we can

179
00:07:59,819 --> 00:08:04,500
adjust here on the slide find the set

180
00:08:04,500 --> 00:08:07,680
which is a responsible for storing just

181
00:08:07,680 --> 00:08:10,020
elements that we can use later

182
00:08:10,020 --> 00:08:13,560
uh we can for example in red store IP

183
00:08:13,560 --> 00:08:15,900
address several IP addresses that we

184
00:08:15,900 --> 00:08:17,340
could use later

185
00:08:17,340 --> 00:08:20,039
and we could Define chain of force that

186
00:08:20,039 --> 00:08:21,539
is in green

187
00:08:21,539 --> 00:08:24,360
and this four will be in shares of

188
00:08:24,360 --> 00:08:27,660
detecting packets and to deal with them

189
00:08:27,660 --> 00:08:30,300
so choosing if we accept this packet or

190
00:08:30,300 --> 00:08:32,159
if we are dropping them

191
00:08:32,159 --> 00:08:36,360
it's uh the generator it's very

192
00:08:36,360 --> 00:08:37,740
interesting to use the set because

193
00:08:37,740 --> 00:08:40,559
several rules can refer to the same

194
00:08:40,559 --> 00:08:43,820
object and we are able to

195
00:08:43,820 --> 00:08:46,260
manipulate this object and have access

196
00:08:46,260 --> 00:08:48,180
so it increase the performance of net

197
00:08:48,180 --> 00:08:49,740
filter

198
00:08:49,740 --> 00:08:50,880
so

199
00:08:50,880 --> 00:08:53,940
two main objects two main elements are

200
00:08:53,940 --> 00:08:57,000
composing net filter and the rules the

201
00:08:57,000 --> 00:09:00,240
first one is the expression as I use too

202
00:09:00,240 --> 00:09:02,880
much packets so we are we have to

203
00:09:02,880 --> 00:09:05,040
describe the incoming packets on the

204
00:09:05,040 --> 00:09:05,820
system

205
00:09:05,820 --> 00:09:09,120
and to do that we have to use some

206
00:09:09,120 --> 00:09:12,120
expression and we have several way to to

207
00:09:12,120 --> 00:09:14,220
describe this expression to describe

208
00:09:14,220 --> 00:09:16,740
this incoming packet effectively there

209
00:09:16,740 --> 00:09:19,140
is more than 40 types of expression so

210
00:09:19,140 --> 00:09:21,300
we have a lot of choices it's very

211
00:09:21,300 --> 00:09:22,920
practice

212
00:09:22,920 --> 00:09:26,279
practical and we can link it to several

213
00:09:26,279 --> 00:09:29,399
objects set and Maps as defined

214
00:09:29,399 --> 00:09:31,140
previously but also the rules because

215
00:09:31,140 --> 00:09:34,140
they are in charge of matching the

216
00:09:34,140 --> 00:09:35,220
packet

217
00:09:35,220 --> 00:09:36,959
and now

218
00:09:36,959 --> 00:09:39,000
we have matched the packet we have to

219
00:09:39,000 --> 00:09:40,320
deal with them

220
00:09:40,320 --> 00:09:42,600
so for that

221
00:09:42,600 --> 00:09:45,300
we have statements so this is all the

222
00:09:45,300 --> 00:09:47,640
statements that we are

223
00:09:47,640 --> 00:09:50,279
or the instruction that you can use when

224
00:09:50,279 --> 00:09:52,080
we have matchup packet the first thing

225
00:09:52,080 --> 00:09:54,540
we can do is to accept it or drop it as

226
00:09:54,540 --> 00:09:57,839
I told previously but we can also share

227
00:09:57,839 --> 00:10:00,300
the user and application to manipulate

228
00:10:00,300 --> 00:10:02,160
them and to choose if we are dropping or

229
00:10:02,160 --> 00:10:04,920
accepting it so we have to use the queue

230
00:10:04,920 --> 00:10:06,300
instruction

231
00:10:06,300 --> 00:10:10,019
but as the Aurora just the change of

232
00:10:10,019 --> 00:10:12,959
rule just taking a reward apply it go to

233
00:10:12,959 --> 00:10:13,860
the second

234
00:10:13,860 --> 00:10:16,380
so we can just choose to continue to the

235
00:10:16,380 --> 00:10:18,779
next rule or just stopping here this

236
00:10:18,779 --> 00:10:21,420
general rule and returning

237
00:10:21,420 --> 00:10:25,019
and uh we can Define also several change

238
00:10:25,019 --> 00:10:27,240
of world so we can interact between the

239
00:10:27,240 --> 00:10:30,240
different chains so for that we can just

240
00:10:30,240 --> 00:10:33,060
use the go to the jump instruction

241
00:10:33,060 --> 00:10:35,160
uh the difference between them is

242
00:10:35,160 --> 00:10:37,500
similar to the jumper encode instruction

243
00:10:37,500 --> 00:10:39,660
on x86

244
00:10:39,660 --> 00:10:42,060
so the go-to expression will jump to the

245
00:10:42,060 --> 00:10:45,420
chain to the chain without returning but

246
00:10:45,420 --> 00:10:47,579
the jump instruction will return to the

247
00:10:47,579 --> 00:10:51,680
cooling one when the chain is finished

248
00:10:51,680 --> 00:10:56,579
so okay we have seen all the components

249
00:10:56,579 --> 00:10:58,320
we need to understand the

250
00:10:58,320 --> 00:11:01,019
vulnerabilities I will explain

251
00:11:01,019 --> 00:11:05,040
now so what I did to find is

252
00:11:05,040 --> 00:11:06,480
vulnerabilities

253
00:11:06,480 --> 00:11:08,459
the first thing I was working with

254
00:11:08,459 --> 00:11:11,040
violent analysis so I started from

255
00:11:11,040 --> 00:11:13,860
recent vulnerabilities from also in that

256
00:11:13,860 --> 00:11:15,120
filter

257
00:11:15,120 --> 00:11:17,339
this variability was formed by David

258
00:11:17,339 --> 00:11:20,880
Bowman and it is an integer overflow

259
00:11:20,880 --> 00:11:23,220
you can take overflow happens in the

260
00:11:23,220 --> 00:11:26,540
compact reason with a

261
00:11:26,540 --> 00:11:31,560
which is taking some some the data

262
00:11:31,560 --> 00:11:34,380
provided by the user here in the example

263
00:11:34,380 --> 00:11:37,800
uh the the user is providing the the reg

264
00:11:37,800 --> 00:11:38,640
value

265
00:11:38,640 --> 00:11:40,980
at line seven

266
00:11:40,980 --> 00:11:43,500
and we see a multiplication

267
00:11:43,500 --> 00:11:46,560
and it occurs that uh the red value is

268
00:11:46,560 --> 00:11:49,860
uh controlled by the user and previously

269
00:11:49,860 --> 00:11:52,320
the kernel was not controlling it

270
00:11:52,320 --> 00:11:55,560
so in this multiplication in this

271
00:11:55,560 --> 00:11:56,579
comparison

272
00:11:56,579 --> 00:12:01,260
David uh was able to get a an integer

273
00:12:01,260 --> 00:12:03,980
overflow and bypass this verification

274
00:12:03,980 --> 00:12:08,820
so he gets after an out of one primitive

275
00:12:08,820 --> 00:12:10,680
and you success to get a previous

276
00:12:10,680 --> 00:12:12,779
destination on Linux

277
00:12:12,779 --> 00:12:16,560
so okay I decided to see if I can match

278
00:12:16,560 --> 00:12:19,079
the other pattern like that in the in

279
00:12:19,079 --> 00:12:20,940
the Linux kernel

280
00:12:20,940 --> 00:12:25,860
so okay we have to find a description to

281
00:12:25,860 --> 00:12:28,500
write or cut create query

282
00:12:28,500 --> 00:12:31,320
so the what we can see in the square in

283
00:12:31,320 --> 00:12:34,440
this pattern we have a if condition with

284
00:12:34,440 --> 00:12:35,820
multiplication

285
00:12:35,820 --> 00:12:37,980
but also it is important to notice that

286
00:12:37,980 --> 00:12:41,519
it's returning an error so we have also

287
00:12:41,519 --> 00:12:44,279
to maybe just taking continuation

288
00:12:44,279 --> 00:12:45,959
consideration

289
00:12:45,959 --> 00:12:47,540
only the

290
00:12:47,540 --> 00:12:50,639
verification is a if condition that is

291
00:12:50,639 --> 00:12:53,399
retaining an error if it doesn't if the

292
00:12:53,399 --> 00:12:55,560
condition is verified

293
00:12:55,560 --> 00:12:59,279
so I use so I decide to use control to

294
00:12:59,279 --> 00:13:03,660
do my query and let's see if I find

295
00:13:03,660 --> 00:13:05,339
other

296
00:13:05,339 --> 00:13:08,519
if I find variance of this bug

297
00:13:08,519 --> 00:13:11,639
so let's see the query and uh oh I write

298
00:13:11,639 --> 00:13:13,980
it the first thing I Define is a class

299
00:13:13,980 --> 00:13:18,360
to represent a check on the user input

300
00:13:18,360 --> 00:13:21,720
so it's mainly composed with uh just uh

301
00:13:21,720 --> 00:13:24,000
if on the if statement that is written

302
00:13:24,000 --> 00:13:25,860
uh

303
00:13:25,860 --> 00:13:30,060
negative value when the user is

304
00:13:30,060 --> 00:13:32,100
that is returning a negative value when

305
00:13:32,100 --> 00:13:33,720
the condition is verified

306
00:13:33,720 --> 00:13:35,579
so here we have a smaller representation

307
00:13:35,579 --> 00:13:38,300
we have the definition intactual

308
00:13:38,300 --> 00:13:41,880
and uh just after the query is just now

309
00:13:41,880 --> 00:13:44,880
simple we want to get the search game

310
00:13:44,880 --> 00:13:46,440
with condition

311
00:13:46,440 --> 00:13:48,360
which is a

312
00:13:48,360 --> 00:13:50,399
involving a multiplication operation

313
00:13:50,399 --> 00:13:55,320
expression and uh a bit uh specific case

314
00:13:55,320 --> 00:13:58,200
I have to deal during when I got

315
00:13:58,200 --> 00:14:00,480
Discovery I have a lot Force positive

316
00:14:00,480 --> 00:14:03,480
between multiplication between macros so

317
00:14:03,480 --> 00:14:06,000
the result of the multiplication will

318
00:14:06,000 --> 00:14:09,360
cons Y is always constant so it is not

319
00:14:09,360 --> 00:14:12,240
interesting so I write another condition

320
00:14:12,240 --> 00:14:14,880
to exclude where the multiplication were

321
00:14:14,880 --> 00:14:16,800
constant

322
00:14:16,800 --> 00:14:20,579
and as a result with iPhone 1 variant

323
00:14:20,579 --> 00:14:23,880
very interesting also in that filter

324
00:14:23,880 --> 00:14:27,480
here this is the

325
00:14:27,480 --> 00:14:29,660
the

326
00:14:30,200 --> 00:14:34,260
second bag we can find it at line eight

327
00:14:34,260 --> 00:14:37,500
at line eight we can see the

328
00:14:37,500 --> 00:14:40,019
multiplication within a comparison

329
00:14:40,019 --> 00:14:43,560
and uh it's returning an error

330
00:14:43,560 --> 00:14:45,899
uh okay so the first thing that we can

331
00:14:45,899 --> 00:14:47,760
see that this line is provided by the

332
00:14:47,760 --> 00:14:51,360
user okay so it's 32-bit integer that

333
00:14:51,360 --> 00:14:53,519
the user can control

334
00:14:53,519 --> 00:14:57,540
and just after it it enter in the

335
00:14:57,540 --> 00:15:00,480
comparison without any previous check on

336
00:15:00,480 --> 00:15:04,139
this uh integer integer and it is first

337
00:15:04,139 --> 00:15:06,360
multiplied by 8 before to be divided by

338
00:15:06,360 --> 00:15:07,940
32

339
00:15:07,940 --> 00:15:09,839
so

340
00:15:09,839 --> 00:15:12,959
there is no optimization that occurs in

341
00:15:12,959 --> 00:15:15,360
the canon in this operation the kernel

342
00:15:15,360 --> 00:15:17,579
so effectively it just results in a

343
00:15:17,579 --> 00:15:21,120
division by four but effectively uh the

344
00:15:21,120 --> 00:15:23,339
multiplication by 8 is previously done

345
00:15:23,339 --> 00:15:25,399
so we are able to

346
00:15:25,399 --> 00:15:27,839
have a buffer overflow because learn is

347
00:15:27,839 --> 00:15:31,320
a 32-bit integer and there is no way to

348
00:15:31,320 --> 00:15:34,019
avoid it if the user wanted

349
00:15:34,019 --> 00:15:38,279
so okay here we are about to find a

350
00:15:38,279 --> 00:15:41,820
variant so just screw

351
00:15:41,820 --> 00:15:45,899
try to use 2z to get a better primitive

352
00:15:45,899 --> 00:15:50,279
however it occurs that uh it is assigned

353
00:15:50,279 --> 00:15:52,920
to a buffer at line 11.

354
00:15:52,920 --> 00:15:56,519
and unfortunately the buffer is 8 Bits

355
00:15:56,519 --> 00:15:57,959
interior buffer

356
00:15:57,959 --> 00:16:02,579
so there is an implicit cast to uh

357
00:16:02,579 --> 00:16:06,300
to outline 11 so the integral overflow

358
00:16:06,300 --> 00:16:10,139
was just useless and it was not possible

359
00:16:10,139 --> 00:16:11,940
to use it so

360
00:16:11,940 --> 00:16:15,240
it was a bit sad

361
00:16:15,240 --> 00:16:20,519
but I just remember at line 11 something

362
00:16:20,519 --> 00:16:23,820
very wired so we are in a function that

363
00:16:23,820 --> 00:16:28,260
is and she's got an integration of user

364
00:16:28,260 --> 00:16:31,380
input so we can provide a several lens

365
00:16:31,380 --> 00:16:32,639
uh

366
00:16:32,639 --> 00:16:36,240
from the user run and there is no

367
00:16:36,240 --> 00:16:38,459
verification done on the film current

368
00:16:38,459 --> 00:16:40,259
value

369
00:16:40,259 --> 00:16:44,940
so and I also reserved that Finland is a

370
00:16:44,940 --> 00:16:50,839
fixed size buffer so okay I can set

371
00:16:50,839 --> 00:16:54,420
uh sorry

372
00:16:54,420 --> 00:16:57,120
I can fill the buffer with any elements

373
00:16:57,120 --> 00:17:00,300
I want so and any number of elements so

374
00:17:00,300 --> 00:17:01,759
very practice

375
00:17:01,759 --> 00:17:07,020
very convenient sorry and uh okay and

376
00:17:07,020 --> 00:17:10,939
finally I found the buffer flow

377
00:17:10,939 --> 00:17:13,079
within this function

378
00:17:13,079 --> 00:17:17,339
so okay maybe I have a useless intake

379
00:17:17,339 --> 00:17:19,020
overflow but I have something else so

380
00:17:19,020 --> 00:17:20,459
I'm happy

381
00:17:20,459 --> 00:17:23,520
so let's see a bit uh the concerning

382
00:17:23,520 --> 00:17:24,419
feature

383
00:17:24,419 --> 00:17:27,059
so the feature concerned by this

384
00:17:27,059 --> 00:17:29,580
vulnerability is the set concatenation

385
00:17:29,580 --> 00:17:32,040
so when we are defining a certain filter

386
00:17:32,040 --> 00:17:33,840
we have to define the type of the

387
00:17:33,840 --> 00:17:35,760
element that we are storing in it

388
00:17:35,760 --> 00:17:38,760
and here in this example we are just

389
00:17:38,760 --> 00:17:41,400
doing uh the concatenation of an IP

390
00:17:41,400 --> 00:17:43,500
address and a part

391
00:17:43,500 --> 00:17:46,320
so it is a feature that he was

392
00:17:46,320 --> 00:17:47,880
introduced to increase the performance

393
00:17:47,880 --> 00:17:49,559
of net filter

394
00:17:49,559 --> 00:17:52,140
and we can associate any element to any

395
00:17:52,140 --> 00:17:55,320
type of object that we want and match a

396
00:17:55,320 --> 00:17:57,660
mini IP address we can match several

397
00:17:57,660 --> 00:17:58,799
port

398
00:17:58,799 --> 00:18:02,520
and the here the the issue was that

399
00:18:02,520 --> 00:18:05,100
in fact they just expected that we

400
00:18:05,100 --> 00:18:08,160
provide we concentrate just 16 elements

401
00:18:08,160 --> 00:18:12,179
or less but this it was not my choice so

402
00:18:12,179 --> 00:18:14,160
I didn't did it

403
00:18:14,160 --> 00:18:17,340
so the buffer was touring the land of

404
00:18:17,340 --> 00:18:19,799
each field so in the previous example I

405
00:18:19,799 --> 00:18:23,280
was storing an IP address and approach

406
00:18:23,280 --> 00:18:28,020
so the two main case of the buffer will

407
00:18:28,020 --> 00:18:29,039
be filled

408
00:18:29,039 --> 00:18:31,799
with the value 4 and 2 4 by 4 for the

409
00:18:31,799 --> 00:18:33,600
length of the IP address and two for the

410
00:18:33,600 --> 00:18:38,940
lengths of the board but we can just add

411
00:18:38,940 --> 00:18:41,940
up to 16 elements so we are just filling

412
00:18:41,940 --> 00:18:45,900
the buffer and I was able to add a 17th

413
00:18:45,900 --> 00:18:46,559
one

414
00:18:46,559 --> 00:18:49,919
so I was able to realize the number of

415
00:18:49,919 --> 00:18:51,740
elements that is stored in this buffer

416
00:18:51,740 --> 00:18:56,580
and this value is also used to know when

417
00:18:56,580 --> 00:18:59,340
at which place we are writing the next

418
00:18:59,340 --> 00:19:03,360
element so when I decide to write a 19th

419
00:19:03,360 --> 00:19:04,200
one

420
00:19:04,200 --> 00:19:06,840
I was able to get another one primitive

421
00:19:06,840 --> 00:19:10,860
and I was able to write anywhere a bit

422
00:19:10,860 --> 00:19:13,020
later in the memory not anywhere

423
00:19:13,020 --> 00:19:16,860
and all this components were happening

424
00:19:16,860 --> 00:19:19,020
in the stack so

425
00:19:19,020 --> 00:19:22,380
it gets now to summarize the type buffer

426
00:19:22,380 --> 00:19:25,020
flow that we can able to

427
00:19:25,020 --> 00:19:27,539
get some stack out of one primitive

428
00:19:27,539 --> 00:19:30,620
however uh if we get back the condition

429
00:19:30,620 --> 00:19:34,460
uh in the previous slide

430
00:19:34,460 --> 00:19:36,120
here

431
00:19:36,120 --> 00:19:38,820
if we invert the condition we have we

432
00:19:38,820 --> 00:19:42,299
take uh we find that length should be

433
00:19:42,299 --> 00:19:46,799
lower than 64. and it's pretty pretty

434
00:19:46,799 --> 00:19:49,380
bad primitive so we cannot write bytes

435
00:19:49,380 --> 00:19:53,100
bigger than 64. however in practice uh

436
00:19:53,100 --> 00:19:55,919
there is a bird with the division by

437
00:19:55,919 --> 00:19:59,220
four and two things less significant

438
00:19:59,220 --> 00:20:02,160
bits offline was not verified

439
00:20:02,160 --> 00:20:05,640
so we are able to write a lens bytes

440
00:20:05,640 --> 00:20:07,740
with the 67 value

441
00:20:07,740 --> 00:20:10,980
but it was not enough to get good

442
00:20:10,980 --> 00:20:13,919
primitive and but let's see what we can

443
00:20:13,919 --> 00:20:15,960
do with

444
00:20:15,960 --> 00:20:18,960
so the first thing we searched to do is

445
00:20:18,960 --> 00:20:23,160
to get a name footage and for that I use

446
00:20:23,160 --> 00:20:24,500
the fact that

447
00:20:24,500 --> 00:20:26,820
the previous buffer was just in

448
00:20:26,820 --> 00:20:29,640
temporary buffer which is allocating on

449
00:20:29,640 --> 00:20:32,280
the stack and to persist after the set

450
00:20:32,280 --> 00:20:33,360
creation

451
00:20:33,360 --> 00:20:36,539
this data is copied into the hip of the

452
00:20:36,539 --> 00:20:39,240
kernel in the set structure

453
00:20:39,240 --> 00:20:43,320
and it occurs that the organization is

454
00:20:43,320 --> 00:20:45,660
the same in the second structure there

455
00:20:45,660 --> 00:20:49,140
is a 16 bytes buffer reserved for for

456
00:20:49,140 --> 00:20:52,500
this buffer and just one byte for the

457
00:20:52,500 --> 00:20:54,720
lens for its length for the number of

458
00:20:54,720 --> 00:20:57,240
elements storing it

459
00:20:57,240 --> 00:21:00,179
and it depends that when we are just

460
00:21:00,179 --> 00:21:04,980
copying being the previous buffer we are

461
00:21:04,980 --> 00:21:07,200
using uh the number of elements stored

462
00:21:07,200 --> 00:21:08,460
in uh

463
00:21:08,460 --> 00:21:11,520
in the previous one so we are able to

464
00:21:11,520 --> 00:21:14,880
erase some data within this uh

465
00:21:14,880 --> 00:21:17,100
within the set structure

466
00:21:17,100 --> 00:21:20,880
so here we are able to import some data

467
00:21:20,880 --> 00:21:24,360
from the stack within the canary

468
00:21:24,360 --> 00:21:27,840
and this is information about the set we

469
00:21:27,840 --> 00:21:30,720
have watches register so we use the fact

470
00:21:30,720 --> 00:21:33,900
that when we register a set we are able

471
00:21:33,900 --> 00:21:35,460
to see all the information we are

472
00:21:35,460 --> 00:21:38,179
already we have registered previously

473
00:21:38,179 --> 00:21:42,480
and it leads to anaphylic so it's time

474
00:21:42,480 --> 00:21:45,240
for a small demo

475
00:21:45,240 --> 00:21:48,200
sorry

476
00:21:48,299 --> 00:21:51,299
so let's go

477
00:21:51,299 --> 00:21:54,179
so I've just wise uh on the custom

478
00:21:54,179 --> 00:21:58,260
canner and a park without privilege

479
00:21:58,260 --> 00:22:00,720
and we can see several thing in this

480
00:22:00,720 --> 00:22:03,240
leak and it was pretty good I was a bird

481
00:22:03,240 --> 00:22:05,760
uh in this specific case because we are

482
00:22:05,760 --> 00:22:08,700
money we are manipulating data from the

483
00:22:08,700 --> 00:22:12,179
stacks so some optimization does that it

484
00:22:12,179 --> 00:22:14,580
will vary from the different kernel

485
00:22:14,580 --> 00:22:17,640
and we see there some interesting

486
00:22:17,640 --> 00:22:19,919
element the first one seems to be random

487
00:22:19,919 --> 00:22:23,280
data but it's the stack Gallery so with

488
00:22:23,280 --> 00:22:26,340
this link we will be able later if to

489
00:22:26,340 --> 00:22:28,500
produce a buffer overflow to bypass the

490
00:22:28,500 --> 00:22:30,120
stock Cannery protection

491
00:22:30,120 --> 00:22:33,120
the second one is an address from the

492
00:22:33,120 --> 00:22:37,860
Eep so now we are able to write within

493
00:22:37,860 --> 00:22:40,320
the Eep and we know a place where we can

494
00:22:40,320 --> 00:22:42,840
write and read data

495
00:22:42,840 --> 00:22:46,280
and the third one is an address from the

496
00:22:46,280 --> 00:22:51,539
kernel itself so it will very useful to

497
00:22:51,539 --> 00:22:53,760
defeat the kslr

498
00:22:53,760 --> 00:22:56,400
so okay and the third the third one was

499
00:22:56,400 --> 00:22:58,500
just useless

500
00:22:58,500 --> 00:23:02,039
so okay here we are able to average but

501
00:23:02,039 --> 00:23:05,580
we still have a bad primitive

502
00:23:05,580 --> 00:23:09,960
so what can we do so as we are equipping

503
00:23:09,960 --> 00:23:12,059
the set structure

504
00:23:12,059 --> 00:23:14,100
um n is storing the length of the

505
00:23:14,100 --> 00:23:15,780
element that after

506
00:23:15,780 --> 00:23:18,299
so I was looking to create a signal

507
00:23:18,299 --> 00:23:20,700
buffer flow with a better primitive so

508
00:23:20,700 --> 00:23:24,240
where I can write about more than 67

509
00:23:24,240 --> 00:23:25,799
and

510
00:23:25,799 --> 00:23:28,020
I did not create one but I found another

511
00:23:28,020 --> 00:23:29,340
one

512
00:23:29,340 --> 00:23:33,600
so and this other one was resulting of

513
00:23:33,600 --> 00:23:36,419
the result of a type confusion that

514
00:23:36,419 --> 00:23:39,900
occurs between uh within the set and the

515
00:23:39,900 --> 00:23:40,860
maps

516
00:23:40,860 --> 00:23:45,480
so the maps is a kind of a set which is

517
00:23:45,480 --> 00:23:47,760
a type of net filter

518
00:23:47,760 --> 00:23:51,419
and a set we are just defining a random

519
00:23:51,419 --> 00:23:53,940
elements of just IP address in the map

520
00:23:53,940 --> 00:23:56,460
we can associate with an object a

521
00:23:56,460 --> 00:23:59,400
statement to do with and for example we

522
00:23:59,400 --> 00:24:01,440
can want to drop every packet from the

523
00:24:01,440 --> 00:24:03,059
all three address

524
00:24:03,059 --> 00:24:05,820
so and here we can accept all the

525
00:24:05,820 --> 00:24:08,400
packets from the off for address so this

526
00:24:08,400 --> 00:24:12,059
is the use case of this uh

527
00:24:12,059 --> 00:24:14,100
of these two kind of sets so very

528
00:24:14,100 --> 00:24:18,059
efficient but the question is uh okay we

529
00:24:18,059 --> 00:24:21,360
can Define such kind of data and objects

530
00:24:21,360 --> 00:24:26,179
but what occurs when I try to add a

531
00:24:26,179 --> 00:24:29,520
verdict element within a set and a set

532
00:24:29,520 --> 00:24:32,100
element within a verdict map so yes we

533
00:24:32,100 --> 00:24:33,140
can

534
00:24:33,140 --> 00:24:36,480
so this is the type of fission that

535
00:24:36,480 --> 00:24:39,659
occurs and occas but here I thought

536
00:24:39,659 --> 00:24:41,880
about the buffer of robots

537
00:24:41,880 --> 00:24:44,299
object seems to have the same size so

538
00:24:44,299 --> 00:24:46,919
the network if the object doesn't have

539
00:24:46,919 --> 00:24:49,559
the same and in fact yes

540
00:24:49,559 --> 00:24:54,419
so okay we can maybe find the

541
00:24:54,419 --> 00:24:56,520
uh okay the idea where the buffer

542
00:24:56,520 --> 00:24:59,400
overflow is so we are not adding more

543
00:24:59,400 --> 00:25:01,799
data that should be stored within a drag

544
00:25:01,799 --> 00:25:06,260
boat in writing is the invert uh in fact

545
00:25:06,260 --> 00:25:09,440
the space in the hip was located

546
00:25:09,440 --> 00:25:12,539
using the type of the elements we are

547
00:25:12,539 --> 00:25:15,780
added so here in the in the set we are

548
00:25:15,780 --> 00:25:17,700
just allocating data according to the

549
00:25:17,700 --> 00:25:19,440
value element in red

550
00:25:19,440 --> 00:25:23,039
and the data is after copying using the

551
00:25:23,039 --> 00:25:25,860
the size of the object stored in the set

552
00:25:25,860 --> 00:25:28,320
so here it will be the size of the

553
00:25:28,320 --> 00:25:29,760
element in blue

554
00:25:29,760 --> 00:25:33,120
so here we will we have a big issue so

555
00:25:33,120 --> 00:25:34,980
we have a buffer overflow but we are

556
00:25:34,980 --> 00:25:38,520
providing less data that the copy so we

557
00:25:38,520 --> 00:25:41,100
have to manipulate it it's not very

558
00:25:41,100 --> 00:25:44,640
useful and not convenient to

559
00:25:44,640 --> 00:25:47,100
just control an overflow or produce an

560
00:25:47,100 --> 00:25:48,360
expert

561
00:25:48,360 --> 00:25:51,360
to do that I use an initials variable

562
00:25:51,360 --> 00:25:54,000
because that I was copying to Temporary

563
00:25:54,000 --> 00:25:55,080
buffer

564
00:25:55,080 --> 00:25:57,840
and uh using this I was able to confirm

565
00:25:57,840 --> 00:25:59,820
my both overflow and

566
00:25:59,820 --> 00:26:02,700
now I have a way to work and to corrupt

567
00:26:02,700 --> 00:26:04,440
the kernel memory

568
00:26:04,440 --> 00:26:07,440
so the big Advantage I had with this

569
00:26:07,440 --> 00:26:10,679
primitive is that I was able to work in

570
00:26:10,679 --> 00:26:13,200
several caches this is a different

571
00:26:13,200 --> 00:26:15,900
allocation as you can remember we can

572
00:26:15,900 --> 00:26:17,220
memorization

573
00:26:17,220 --> 00:26:20,640
so okay I can maybe correct different

574
00:26:20,640 --> 00:26:23,580
kind of object and I'm not trusted to a

575
00:26:23,580 --> 00:26:25,320
specific set of objects

576
00:26:25,320 --> 00:26:28,440
and I have a pretty big buff overflow I

577
00:26:28,440 --> 00:26:31,919
can write up to 40 head bytes

578
00:26:31,919 --> 00:26:34,679
and it will very useful because we can

579
00:26:34,679 --> 00:26:38,100
go deeper in the object in order to

580
00:26:38,100 --> 00:26:42,720
erase some useful components

581
00:26:42,720 --> 00:26:45,720
um the first thing now we need is to

582
00:26:45,720 --> 00:26:48,179
produce another footage in order to

583
00:26:48,179 --> 00:26:51,840
bypass some protection especially the

584
00:26:51,840 --> 00:26:54,980
case area

585
00:26:55,940 --> 00:27:00,360
I choose to work with the rkc score

586
00:27:00,360 --> 00:27:04,020
and use a key period users can in the

587
00:27:04,020 --> 00:27:06,000
kennel register some keys that destroy

588
00:27:06,000 --> 00:27:09,179
that are stored and when we are

589
00:27:09,179 --> 00:27:12,000
registering a key we are providing the

590
00:27:12,000 --> 00:27:14,720
length of the this key and we are and

591
00:27:14,720 --> 00:27:17,940
buffer I just allocated just after

592
00:27:17,940 --> 00:27:21,659
a data here in this uh

593
00:27:21,659 --> 00:27:25,260
this structure and okay the goal will be

594
00:27:25,260 --> 00:27:28,620
to correct just the either so the seu

595
00:27:28,620 --> 00:27:31,080
and data land the length of the buffer

596
00:27:31,080 --> 00:27:34,080
in order to okay make sure we have a

597
00:27:34,080 --> 00:27:39,179
good buffer a prop uh and in this state

598
00:27:39,179 --> 00:27:41,880
so good either good buffer and we

599
00:27:41,880 --> 00:27:44,100
recruit the eater and we get a bigger

600
00:27:44,100 --> 00:27:47,520
buffer and when we try to get back

601
00:27:47,520 --> 00:27:49,340
information

602
00:27:49,340 --> 00:27:52,260
about this key because we registered

603
00:27:52,260 --> 00:27:54,980
this key we should be able to use it

604
00:27:54,980 --> 00:27:57,900
uh the calendar will return more data

605
00:27:57,900 --> 00:28:01,740
that it than expected so okay here we

606
00:28:01,740 --> 00:28:03,539
will have several objects that is

607
00:28:03,539 --> 00:28:06,240
overlap that are overlapped by my new

608
00:28:06,240 --> 00:28:07,440
buffer

609
00:28:07,440 --> 00:28:11,220
and uh by this way I was able to

610
00:28:11,220 --> 00:28:13,679
like to leak the case area and the

611
00:28:13,679 --> 00:28:16,159
fistmap base basis

612
00:28:16,159 --> 00:28:19,559
therefore uh okay now we have the main

613
00:28:19,559 --> 00:28:20,580
protection

614
00:28:20,580 --> 00:28:24,779
um bypass uh defect so we have to write

615
00:28:24,779 --> 00:28:26,700
something in the memory in order to get

616
00:28:26,700 --> 00:28:28,559
more privilege

617
00:28:28,559 --> 00:28:31,460
so I choose to use the anointing attack

618
00:28:31,460 --> 00:28:34,559
I was inspired from the write-up from LG

619
00:28:34,559 --> 00:28:37,559
wrong which is attacking a linked list

620
00:28:37,559 --> 00:28:42,419
in the k l using the Lister function

621
00:28:42,419 --> 00:28:45,419
and the bigger of the my attack was to

622
00:28:45,419 --> 00:28:47,700
edit the matplot path to gain wood

623
00:28:47,700 --> 00:28:48,779
privilege

624
00:28:48,779 --> 00:28:51,240
multiple path is a technique used to

625
00:28:51,240 --> 00:28:53,820
gain a privilege more privilege in the

626
00:28:53,820 --> 00:28:55,159
link scanner

627
00:28:55,159 --> 00:28:58,440
We Are The Meta path is the path to the

628
00:28:58,440 --> 00:29:02,039
map binary and it should the candle is

629
00:29:02,039 --> 00:29:04,760
using it when we try to load a

630
00:29:04,760 --> 00:29:08,640
non-binary and it will execute the

631
00:29:08,640 --> 00:29:11,220
binary pointed by this path with the

632
00:29:11,220 --> 00:29:14,279
root privileges so if we are able to

633
00:29:14,279 --> 00:29:17,340
modify this path to control binary we

634
00:29:17,340 --> 00:29:20,340
are able to execute any binary with the

635
00:29:20,340 --> 00:29:23,039
root privileges so this is the way we

636
00:29:23,039 --> 00:29:24,899
use

637
00:29:24,899 --> 00:29:28,200
so we have a buffer overflow so what can

638
00:29:28,200 --> 00:29:30,360
we do with the least there operation

639
00:29:30,360 --> 00:29:34,020
so we are able to correct a list either

640
00:29:34,020 --> 00:29:36,179
and thanks to this either

641
00:29:36,179 --> 00:29:38,159
we are confirming we are able to control

642
00:29:38,159 --> 00:29:40,919
the previews and the next pointer here

643
00:29:40,919 --> 00:29:42,240
in this function

644
00:29:42,240 --> 00:29:44,760
so we are able to write it at the next

645
00:29:44,760 --> 00:29:48,000
address uh the value prep at the preva

646
00:29:48,000 --> 00:29:50,460
the address value next

647
00:29:50,460 --> 00:29:54,299
so okay let's sing practice uh what's

648
00:29:54,299 --> 00:29:55,200
happened

649
00:29:55,200 --> 00:29:57,840
uh it is important to need that we need

650
00:29:57,840 --> 00:29:59,760
to provide a

651
00:29:59,760 --> 00:30:03,419
valid address to use this function

652
00:30:03,419 --> 00:30:05,940
and for this is the way we have to leave

653
00:30:05,940 --> 00:30:09,080
the fismap and physical map

654
00:30:09,080 --> 00:30:13,380
okay in practice uh just I register a

655
00:30:13,380 --> 00:30:15,600
list within the canners there is many

656
00:30:15,600 --> 00:30:17,340
ways to to have one

657
00:30:17,340 --> 00:30:20,960
and I correct it so the two pointers are

658
00:30:20,960 --> 00:30:24,720
pointing to new elements in the kernel

659
00:30:24,720 --> 00:30:27,360
memory and as we've seen in the previous

660
00:30:27,360 --> 00:30:30,419
function when we will try to remove this

661
00:30:30,419 --> 00:30:31,740
corrupt element

662
00:30:31,740 --> 00:30:35,039
uh we write the two addresses we're

663
00:30:35,039 --> 00:30:38,399
writing and it's either at the opposite

664
00:30:38,399 --> 00:30:42,179
so okay now we find a way to edit my top

665
00:30:42,179 --> 00:30:43,320
path

666
00:30:43,320 --> 00:30:47,340
so by this way the the fact is that we

667
00:30:47,340 --> 00:30:50,640
need to write a slash TMP to able to

668
00:30:50,640 --> 00:30:52,140
control the

669
00:30:52,140 --> 00:30:56,039
the binary and for that we can use the

670
00:30:56,039 --> 00:31:00,899
fact that a near we can the first less

671
00:31:00,899 --> 00:31:05,100
significant bytes can be random and

672
00:31:05,100 --> 00:31:08,460
and but the inconvenience of this

673
00:31:08,460 --> 00:31:12,240
technique is that the big part of the

674
00:31:12,240 --> 00:31:15,000
the other part of the canal path should

675
00:31:15,000 --> 00:31:17,580
be uh different and should be random and

676
00:31:17,580 --> 00:31:20,399
we cannot control it but as we are in

677
00:31:20,399 --> 00:31:22,679
the TMP folder this is this is a way we

678
00:31:22,679 --> 00:31:26,340
can just name the binary as we want

679
00:31:26,340 --> 00:31:31,320
so it leads to a small demo

680
00:31:31,320 --> 00:31:32,880
uh

681
00:31:32,880 --> 00:31:35,600
take

682
00:31:35,899 --> 00:31:38,700
here I was on the latest in winter at

683
00:31:38,700 --> 00:31:40,020
the time

684
00:31:40,020 --> 00:31:43,799
and I didn't have any privilege on this

685
00:31:43,799 --> 00:31:46,760
binary and I finished to be rich

686
00:31:46,760 --> 00:31:50,480
so okay

687
00:31:50,640 --> 00:31:53,720
so in this uh

688
00:31:53,720 --> 00:31:57,960
this demonstration so when I just

689
00:31:57,960 --> 00:32:01,080
realized this book uh point one just

690
00:32:01,080 --> 00:32:04,500
passed so we just like to report the

691
00:32:04,500 --> 00:32:07,200
vulnerability to the link scanner and

692
00:32:07,200 --> 00:32:09,360
they patch the vulnerability one week

693
00:32:09,360 --> 00:32:10,740
later

694
00:32:10,740 --> 00:32:16,320
so here so now let's just discuss about

695
00:32:16,320 --> 00:32:20,700
uh a bit about the Linux security

696
00:32:20,700 --> 00:32:23,580
so this year's was pretty hard for on

697
00:32:23,580 --> 00:32:26,940
the Twitter and especially net nft Birds

698
00:32:26,940 --> 00:32:29,640
uh at the university has been found in

699
00:32:29,640 --> 00:32:32,640
this model just it is a lot and we can

700
00:32:32,640 --> 00:32:34,200
see that there is different kind of

701
00:32:34,200 --> 00:32:36,600
linear bases there is not a significant

702
00:32:36,600 --> 00:32:40,320
pattern that is you can see in order one

703
00:32:40,320 --> 00:32:43,620
so we can ask why this vulnerabilities

704
00:32:43,620 --> 00:32:47,159
are just opening this year and not

705
00:32:47,159 --> 00:32:47,880
before

706
00:32:47,880 --> 00:32:50,760
this is you that in the filter thanks to

707
00:32:50,760 --> 00:32:53,340
username spaces and privilege username

708
00:32:53,340 --> 00:32:56,159
spaces are accessible on several

709
00:32:56,159 --> 00:32:59,640
operating system uh sold by a

710
00:32:59,640 --> 00:33:01,080
unpreviewed user

711
00:33:01,080 --> 00:33:04,140
so everybody can access it and

712
00:33:04,140 --> 00:33:07,980
manipulate it so it comes an interesting

713
00:33:07,980 --> 00:33:11,399
Target for an attacker

714
00:33:11,399 --> 00:33:14,519
and okay so what can we do to protect

715
00:33:14,519 --> 00:33:16,679
against uh

716
00:33:16,679 --> 00:33:19,919
this kind of attacks and maybe do not

717
00:33:19,919 --> 00:33:23,039
have to expose our system so Justin if

718
00:33:23,039 --> 00:33:24,240
you

719
00:33:24,240 --> 00:33:26,220
advise to

720
00:33:26,220 --> 00:33:28,019
outline your system

721
00:33:28,019 --> 00:33:30,240
the first thing is to disable and

722
00:33:30,240 --> 00:33:33,000
previous username spaces uh the this is

723
00:33:33,000 --> 00:33:34,860
just an option that you can modify with

724
00:33:34,860 --> 00:33:38,940
this controller but in fact uh it it

725
00:33:38,940 --> 00:33:42,019
will make your Dockers not working

726
00:33:42,019 --> 00:33:44,659
almost for in privileged

727
00:33:44,659 --> 00:33:47,940
containers so you have to run your

728
00:33:47,940 --> 00:33:50,519
container as root and everybody knows

729
00:33:50,519 --> 00:33:52,559
that it's not a good idea

730
00:33:52,559 --> 00:33:54,899
so the solution is you know choose

731
00:33:54,899 --> 00:33:57,000
containers directly in the system maybe

732
00:33:57,000 --> 00:34:00,360
use some virtualization solution it will

733
00:34:00,360 --> 00:34:02,159
be safer and

734
00:34:02,159 --> 00:34:05,700
better you can use some candle modules

735
00:34:05,700 --> 00:34:07,820
of the runtime word

736
00:34:07,820 --> 00:34:12,080
which is a which will be detect some

737
00:34:12,080 --> 00:34:16,199
exploit attempts within the kernel so in

738
00:34:16,199 --> 00:34:18,119
my techniques I used to edit multiple

739
00:34:18,119 --> 00:34:19,918
path and this is something that should

740
00:34:19,918 --> 00:34:21,119
never happen

741
00:34:21,119 --> 00:34:24,719
so lkg will be able to detect such kind

742
00:34:24,719 --> 00:34:26,580
of attempt

743
00:34:26,580 --> 00:34:29,580
so it should be other for an attacker to

744
00:34:29,580 --> 00:34:31,739
get a previous decoration

745
00:34:31,739 --> 00:34:34,440
and if you want to get more advice about

746
00:34:34,440 --> 00:34:37,940
the other or to add on your system

747
00:34:37,940 --> 00:34:40,379
Alexander pop-up did a nice tool for

748
00:34:40,379 --> 00:34:42,780
that can configure the net check which

749
00:34:42,780 --> 00:34:45,060
is available in GitHub and just will

750
00:34:45,060 --> 00:34:48,780
tell you what what option of the your

751
00:34:48,780 --> 00:34:50,940
configuration is increasing the attack

752
00:34:50,940 --> 00:34:54,179
surface of your kernel or some advice to

753
00:34:54,179 --> 00:34:57,000
mitigate some kind of heart attack very

754
00:34:57,000 --> 00:34:58,200
nicely

755
00:34:58,200 --> 00:35:01,859
so it's time for the conclusion of this

756
00:35:01,859 --> 00:35:03,720
presentation

757
00:35:03,720 --> 00:35:06,480
so I use the violent analysis to find

758
00:35:06,480 --> 00:35:08,760
vulnerabilities in that filter and it

759
00:35:08,760 --> 00:35:10,920
was efficient because I was able to find

760
00:35:10,920 --> 00:35:12,060
a bag

761
00:35:12,060 --> 00:35:14,760
and the first bug that was a simpler

762
00:35:14,760 --> 00:35:18,720
integer overflow leads to

763
00:35:18,720 --> 00:35:22,320
uh two vulnerabilities and

764
00:35:22,320 --> 00:35:24,359
different abilities was accessible

765
00:35:24,359 --> 00:35:28,140
thanks to and privileged user and spaces

766
00:35:28,140 --> 00:35:31,560
so this is a nice feature because it

767
00:35:31,560 --> 00:35:35,060
allows to run containers with a non-root

768
00:35:35,060 --> 00:35:39,240
privilege but it's exposing the more the

769
00:35:39,240 --> 00:35:42,180
Linux scanner so maybe not the greatest

770
00:35:42,180 --> 00:35:43,619
solution

771
00:35:43,619 --> 00:35:47,880
and as the Linux scanner is the net

772
00:35:47,880 --> 00:35:50,579
filter is now a new attack surface it's

773
00:35:50,579 --> 00:35:52,740
very interesting to

774
00:35:52,740 --> 00:35:54,980
I'll be looking and maybe it is

775
00:35:54,980 --> 00:35:58,380
important it's a good idea to search

776
00:35:58,380 --> 00:35:59,880
within this model

777
00:35:59,880 --> 00:36:02,220
uh a metal spread murder has been

778
00:36:02,220 --> 00:36:04,800
written by my colleague red one and I

779
00:36:04,800 --> 00:36:07,020
will thank to him for all the work he

780
00:36:07,020 --> 00:36:11,160
did for the the expert I brought for the

781
00:36:11,160 --> 00:36:12,900
second vulnerability

782
00:36:12,900 --> 00:36:15,180
if you are interesting from more

783
00:36:15,180 --> 00:36:17,640
technical details you can read the two

784
00:36:17,640 --> 00:36:20,160
write apps on a Blog

785
00:36:20,160 --> 00:36:23,339
and the source code of the exploits are

786
00:36:23,339 --> 00:36:26,099
also available in detail

787
00:36:26,099 --> 00:36:28,880
thank you

788
00:36:33,740 --> 00:36:35,579
[Applause]

789
00:36:35,579 --> 00:36:38,300
oh

790
00:36:40,260 --> 00:36:42,540
thank you thank you for the talk so I

791
00:36:42,540 --> 00:36:44,400
have interest so you demonstrated to

792
00:36:44,400 --> 00:36:46,440
exploit an out of stock Ubuntu at that

793
00:36:46,440 --> 00:36:49,140
time as you said so has any of the

794
00:36:49,140 --> 00:36:51,119
hardened kernel config options have been

795
00:36:51,119 --> 00:36:54,119
I mean if used would prevently exploit

796
00:36:54,119 --> 00:36:56,460
including when your ones which emerge

797
00:36:56,460 --> 00:36:58,560
later including like stack repairs Cisco

798
00:36:58,560 --> 00:37:01,740
stack randomization things like that if

799
00:37:01,740 --> 00:37:03,300
that help and there was the

800
00:37:03,300 --> 00:37:06,119
randomization so I was not able to for

801
00:37:06,119 --> 00:37:09,359
the first one to to have the same league

802
00:37:09,359 --> 00:37:11,720
on Ubuntu Canal for example

803
00:37:11,720 --> 00:37:15,480
but uh are all the standard mitigation

804
00:37:15,480 --> 00:37:17,700
that are on operating system I have to

805
00:37:17,700 --> 00:37:20,099
deal also for this other net I have to

806
00:37:20,099 --> 00:37:22,920
deal with with my second exploit at the

807
00:37:22,920 --> 00:37:27,300
time but I did not have to deal with

808
00:37:27,300 --> 00:37:30,119
many other mitigation

809
00:37:30,119 --> 00:37:31,980
I guess my question is to have around if

810
00:37:31,980 --> 00:37:34,440
let's say if if

811
00:37:34,440 --> 00:37:36,240
you enable all of the you know

812
00:37:36,240 --> 00:37:38,099
applications that exist in the kernel

813
00:37:38,099 --> 00:37:40,680
which not not everyone enables them but

814
00:37:40,680 --> 00:37:43,260
so would explode be stopped or on

815
00:37:43,260 --> 00:37:45,660
something or uh yes it will stop because

816
00:37:45,660 --> 00:37:48,060
I use multiple path and ltig will detect

817
00:37:48,060 --> 00:37:50,060
it so I will stop it

818
00:37:50,060 --> 00:37:52,920
so I guess the bottom line is that the

819
00:37:52,920 --> 00:37:55,079
vendors of the OS tester should really

820
00:37:55,079 --> 00:37:57,300
be enabling more hardening mitigations

821
00:37:57,300 --> 00:37:59,700
yes it has to he has to choose between

822
00:37:59,700 --> 00:38:01,619
the performance of the system and of

823
00:38:01,619 --> 00:38:03,420
course lkg so

824
00:38:03,420 --> 00:38:06,240
costly and this is one reason that is

825
00:38:06,240 --> 00:38:10,020
not an important effort and Ubuntu by

826
00:38:10,020 --> 00:38:12,380
default

827
00:38:19,810 --> 00:38:22,969
[Music]

828
00:38:31,110 --> 00:38:34,159
[Music]

