1
00:00:03,319 --> 00:00:05,819
hello to all so in this

2
00:00:05,819 --> 00:00:07,680
presentation we are going to explain to you

3
00:00:07,680 --> 00:00:10,320
how we obtained code execution

4
00:00:10,320 --> 00:00:12,480
on a Canon printer as part of

5
00:00:12,480 --> 00:00:15,740
the pountoon 2021 which took place in Austin

6
00:00:15,740 --> 00:00:17,820
so to start we are going to introduce ourselves

7
00:00:17,820 --> 00:00:21,119
quickly so I am with medItalie

8
00:00:21,119 --> 00:00:24,720
and  Thomas Genet my name is Rémi

9
00:00:24,720 --> 00:00:26,279
Julian and we all three work at

10
00:00:26,279 --> 00:00:28,800
synactiv so if an asset is a

11
00:00:28,800 --> 00:00:30,539
French company specializing in

12
00:00:30,539 --> 00:00:32,159
offensive security which was created in

13
00:00:32,159 --> 00:00:33,440
2012

14
00:00:33,440 --> 00:00:36,780
we have premises in France in Paris Lyon

15
00:00:36,780 --> 00:00:38,820
Toulouse and Rennes today  today we have

16
00:00:38,820 --> 00:00:41,660
four poles riverson genering pentast

17
00:00:41,660 --> 00:00:44,040
secure application development

18
00:00:44,040 --> 00:00:46,379
and incident response we are about

19
00:00:46,379 --> 00:00:48,840
120 and we recruit for those who are

20
00:00:48,840 --> 00:00:50,879
enough

21
00:00:50,879 --> 00:00:53,579
so we actually worked on

22
00:00:53,579 --> 00:00:54,960
this printer because it was one

23
00:00:54,960 --> 00:00:57,059
of the targets  pontoon so for those who do

24
00:00:57,059 --> 00:00:58,620
n't know pountoon it's an

25
00:00:58,620 --> 00:01:00,539


26
00:01:00,539 --> 00:01:03,660
international computer security competition organized by ZI so

27
00:01:03,660 --> 00:01:06,540
zero Day Initiative which is affiliated with the

28
00:01:06,540 --> 00:01:09,299
antivirus company trait de micro the idea

29
00:01:09,299 --> 00:01:10,740
of ​​this competition is that there  has a

30
00:01:10,740 --> 00:01:12,119
set of devices that are up to

31
00:01:12,119 --> 00:01:14,040
date and the goal for attackers

32
00:01:14,040 --> 00:01:15,659
is to find unknown vulnerabilities

33
00:01:15,659 --> 00:01:18,000
to exploit in order to achieve

34
00:01:18,000 --> 00:01:21,060
code execution on one on the

35
00:01:21,060 --> 00:01:23,640
device so for the edit that

36
00:01:23,640 --> 00:01:26,340
took place at  Austin there were a total of 19

37
00:01:26,340 --> 00:01:28,740
different devices so there were

38
00:01:28,740 --> 00:01:30,180
different types of devices there

39
00:01:30,180 --> 00:01:32,460
were routers NAS

40
00:01:32,460 --> 00:01:35,460
printers Bluetooth speakers this

41
00:01:35,460 --> 00:01:36,900
edition was

42
00:01:36,900 --> 00:01:39,659
particularly successful since there

43
00:01:39,659 --> 00:01:41,460
are a total of 58 entries so 58

44
00:01:41,460 --> 00:01:43,439
attempts  of tablets on the 19

45
00:01:43,439 --> 00:01:46,200
peripherals there are 22 teams that

46
00:01:46,200 --> 00:01:48,479
participated and at synactiv we were a

47
00:01:48,479 --> 00:01:50,340
team of 11 people we were I think the

48
00:01:50,340 --> 00:01:52,439
biggest team there which allowed us

49
00:01:52,439 --> 00:01:54,899
to win this this edition

50
00:01:54,899 --> 00:01:56,700
there

51
00:01:56,700 --> 00:01:58,380
so as I said he  there were 19

52
00:01:58,380 --> 00:02:00,600
different peripherals among these

53
00:02:00,600 --> 00:02:01,740
peripherals there were three

54
00:02:01,740 --> 00:02:04,380
printers an HP printer a

55
00:02:04,380 --> 00:02:06,299
Lexmark printer and a

56
00:02:06,299 --> 00:02:09,479
Canon printer so quite active we worked

57
00:02:09,479 --> 00:02:11,099
on the three printers we had

58
00:02:11,099 --> 00:02:13,440
code exceptions on the three and this

59
00:02:13,440 --> 00:02:16,400
talk goes  focus on

60
00:02:16,400 --> 00:02:19,500
the Canon printer on which we

61
00:02:19,500 --> 00:02:21,620
worked

62
00:02:21,780 --> 00:02:24,599
last little slide on the pountoon so

63
00:02:24,599 --> 00:02:25,760
in fact the idea is that each

64
00:02:25,760 --> 00:02:27,480
device that we will succeed in

65
00:02:27,480 --> 00:02:29,700
compromising will bring back a number of

66
00:02:29,700 --> 00:02:31,200
points which is variable and a cash Price

67
00:02:31,200 --> 00:02:32,819
which is variable for example a

68
00:02:32,819 --> 00:02:35,040
printer it brought back two points so

69
00:02:35,040 --> 00:02:36,060
what we call the points of

70
00:02:36,060 --> 00:02:39,239
masterphone and 20000 dollars and the idea

71
00:02:39,239 --> 00:02:40,140
is that at the end there is a classification

72
00:02:40,140 --> 00:02:42,000
which is done and the team which arrives  in the

73
00:02:42,000 --> 00:02:43,980
lead she receives the title of what is

74
00:02:43,980 --> 00:02:45,900
called master of pown and for the little

75
00:02:45,900 --> 00:02:48,000
anecdote it was quite nice for us

76
00:02:48,000 --> 00:02:50,760
since in fact we finished just ahead of

77
00:02:50,760 --> 00:02:53,160
the effort team by two points so that's

78
00:02:53,160 --> 00:02:54,959
really play until the end on

79
00:02:54,959 --> 00:02:56,400
our on our last entry so

80
00:02:56,400 --> 00:02:58,560
it was quite a fan

81
00:02:58,560 --> 00:03:00,840
here for the introduction so the idea

82
00:03:00,840 --> 00:03:02,580
is really to remember that if we

83
00:03:02,580 --> 00:03:03,780
made this stop there it was because

84
00:03:03,780 --> 00:03:06,360
it was  a pountoon target and that

85
00:03:06,360 --> 00:03:10,019
it was quite fun I'm going to let

86
00:03:10,019 --> 00:03:11,879
Thomas speak who is going to talk to you about the

87
00:03:11,879 --> 00:03:14,720
buttercup

88
00:03:17,099 --> 00:03:19,200
so actually concretely how do you

89
00:03:19,200 --> 00:03:21,540
attack a printer

90
00:03:21,540 --> 00:03:23,040
it's all well and good to have a printer

91
00:03:23,040 --> 00:03:24,720
but what do we concretely do

92
00:03:24,720 --> 00:03:27,540
with us so what we have done we have already

93
00:03:27,540 --> 00:03:31,200
tried to find the PCB the

94
00:03:31,200 --> 00:03:32,640
computer board on which is executed

95
00:03:32,640 --> 00:03:36,599
all the code that the printer does

96
00:03:36,599 --> 00:03:38,280
once we have identified  the PCB we

97
00:03:38,280 --> 00:03:40,260
identify the different the different

98
00:03:40,260 --> 00:03:42,599
types that are above we identify quite

99
00:03:42,599 --> 00:03:46,319
quickly a CPU it was a CPAM we

100
00:03:46,319 --> 00:03:47,640
also identify the train quite quickly

101
00:03:47,640 --> 00:03:50,700
below and we do that suddenly by

102
00:03:50,700 --> 00:03:51,900
looking at what is printed on the

103
00:03:51,900 --> 00:03:54,180
types it allows to  know what

104
00:03:54,180 --> 00:03:56,840
these different types are precisely

105
00:03:56,840 --> 00:03:59,519
in the other interesting things that

106
00:03:59,519 --> 00:04:01,799
suddenly we searched for to move forward

107
00:04:01,799 --> 00:04:04,860
we identified a

108
00:04:04,860 --> 00:04:06,480
UART connector up there which allows us

109
00:04:06,480 --> 00:04:07,860
to interact afterwards to have a little

110
00:04:07,860 --> 00:04:10,260
something else  just the

111
00:04:10,260 --> 00:04:11,819
printer screen to see what's going

112
00:04:11,819 --> 00:04:12,620
on

113
00:04:12,620 --> 00:04:15,420
and we have storage that's what will

114
00:04:15,420 --> 00:04:18,560
interest us later

115
00:04:32,600 --> 00:04:35,300
we focus on Luart

116
00:04:35,300 --> 00:04:37,620
Luart's idea is to try to  see

117
00:04:37,620 --> 00:04:39,120
how what are the different films

118
00:04:39,120 --> 00:04:41,180
and what are their

119
00:04:41,180 --> 00:04:43,680
uses we first identify the

120
00:04:43,680 --> 00:04:45,919
mass which then makes it possible to find

121
00:04:45,919 --> 00:04:49,139
the inputs and the outputs to

122
00:04:49,139 --> 00:04:50,580
identify what can possibly

123
00:04:50,580 --> 00:04:55,080
come out on this serial console and we have to

124
00:04:55,080 --> 00:04:57,300
dig a little bit  the

125
00:04:57,300 --> 00:05:00,060
different possible speeds for these

126
00:05:00,060 --> 00:05:03,080
serial consoles then identify in the end

127
00:05:03,080 --> 00:05:05,940
by starting the printer we press

128
00:05:05,940 --> 00:05:07,080
identify the message that we see at the bottom

129
00:05:07,080 --> 00:05:10,259
right there and therefore to know that

130
00:05:10,259 --> 00:05:11,699
the printer is indeed lazy on

131
00:05:11,699 --> 00:05:13,199
this on this serial console and that  'we

132
00:05:13,199 --> 00:05:15,000
would have a little more information than

133
00:05:15,000 --> 00:05:17,720
simply with the screen

134
00:05:17,720 --> 00:05:21,000
I also spoke about it previously what

135
00:05:21,000 --> 00:05:22,199
interests us in these cases is to

136
00:05:22,199 --> 00:05:23,400
recover the firmware to try

137
00:05:23,400 --> 00:05:24,300
to analyze how

138
00:05:24,300 --> 00:05:26,580
the printer works concretely so on  the

139
00:05:26,580 --> 00:05:28,020
basis of what we press to identify the

140
00:05:28,020 --> 00:05:29,520
flash we press to identify its

141
00:05:29,520 --> 00:05:31,460
precise model so

142
00:05:31,460 --> 00:05:36,060
w25q 16v and with this information we

143
00:05:36,060 --> 00:05:37,380
can extract the manufacturer's documentation,

144
00:05:37,380 --> 00:05:41,400
in particular how

145
00:05:41,400 --> 00:05:44,280
the package is physically built and

146
00:05:44,280 --> 00:05:46,500
what each of the pins of this type correspond to

147
00:05:46,500 --> 00:05:47,479


148
00:05:47,479 --> 00:05:49,620
it's a standard format so it's

149
00:05:49,620 --> 00:05:53,460
rather practical SEIC format which

150
00:05:53,460 --> 00:05:55,500
actually allows us to with the tool that we

151
00:05:55,500 --> 00:05:57,840
see on the right so the clip is a

152
00:05:57,840 --> 00:06:00,180
USB adapter and the tool and the flashROM software

153
00:06:00,180 --> 00:06:01,280


154
00:06:01,280 --> 00:06:04,020
to extract the  memory which is which is

155
00:06:04,020 --> 00:06:05,639
stored based on the

156
00:06:05,639 --> 00:06:08,699
input information which is which is on

157
00:06:08,699 --> 00:06:10,440
this package there

158
00:06:10,440 --> 00:06:13,380
once we have that we can dump

159
00:06:13,380 --> 00:06:15,900
the binary all the memory and then

160
00:06:15,900 --> 00:06:19,259
analyze this dump to try to see what

161
00:06:19,259 --> 00:06:22,039
we  can find in it it turns

162
00:06:22,039 --> 00:06:25,199
out that so what we extracted

163
00:06:25,199 --> 00:06:28,380
was code directly arm it was

164
00:06:28,380 --> 00:06:30,539
the code of the bootloader so it's

165
00:06:30,539 --> 00:06:33,840
really the first thing that is by

166
00:06:33,840 --> 00:06:35,840
the printer when it starts

167
00:06:35,840 --> 00:06:38,340
on the other hand the size of  memory was

168
00:06:38,340 --> 00:06:40,259
2 megabytes of memory and therefore not necessarily

169
00:06:40,259 --> 00:06:42,419
sufficient to store the entire

170
00:06:42,419 --> 00:06:43,639
format of the printer

171
00:06:43,639 --> 00:06:45,840
and by actually digging a little

172
00:06:45,840 --> 00:06:47,759
more what we need to identify is

173
00:06:47,759 --> 00:06:48,380
that

174
00:06:48,380 --> 00:06:50,580
this piece of code this code we

175
00:06:50,580 --> 00:06:51,319
had

176
00:06:51,319 --> 00:06:53,180
was able to

177
00:06:53,180 --> 00:06:55,520
recover someware and install it

178
00:06:55,520 --> 00:06:59,819
and then Lodé in memory and

179
00:06:59,819 --> 00:07:03,000
then here is to execute the code from

180
00:07:03,000 --> 00:07:06,300
the IMC so the other clipset that was

181
00:07:06,300 --> 00:07:10,380
identified previously and simply

182
00:07:10,380 --> 00:07:12,479
from this information there we

183
00:07:12,479 --> 00:07:14,220
suddenly know  that you have to look for on the immc

184
00:07:14,220 --> 00:07:16,440
but on the other hand you can have a lot of

185
00:07:16,440 --> 00:07:17,940
interesting information, in particular at

186
00:07:17,940 --> 00:07:20,840
what address in memory and my peace

187
00:07:20,840 --> 00:07:23,759
this code there so to be able to analyze it

188
00:07:23,759 --> 00:07:26,220
more simply and more cleanly and

189
00:07:26,220 --> 00:07:28,259
something else as interesting when

190
00:07:28,259 --> 00:07:32,520
the bootloader therefore does not find any

191
00:07:32,520 --> 00:07:35,580
firmware on the immc it checks itself

192
00:07:35,580 --> 00:07:37,620
it executes itself to install

193
00:07:37,620 --> 00:07:40,139
new firmware and by installing

194
00:07:40,139 --> 00:07:42,419
new firmware we were able to

195
00:07:42,419 --> 00:07:45,440
identify how to move this

196
00:07:45,440 --> 00:07:48,900
was happening  the parking of the firmware of the

197
00:07:48,900 --> 00:07:52,139
update format and also we

198
00:07:52,139 --> 00:07:54,599
therefore press to identify a deshoxification routine

199
00:07:54,599 --> 00:07:57,919
which then allowed us to

200
00:07:57,919 --> 00:08:00,139
from the farmware

201
00:08:00,139 --> 00:08:02,759
recover a readable version of the code

202
00:08:02,759 --> 00:08:04,680
therefore in fact this

203
00:08:04,680 --> 00:08:07,819
dehoxification routine and rather simple but

204
00:08:07,819 --> 00:08:11,900
necessary for  to be able to continue

205
00:08:12,020 --> 00:08:15,599
it's rather simple it suddenly takes by

206
00:08:15,599 --> 00:08:18,139
by byte byte by byte

207
00:08:18,139 --> 00:08:21,660
the update binary and it

208
00:08:21,660 --> 00:08:23,759
applies the modification to it finally here are

209
00:08:23,759 --> 00:08:27,300
the small shifts that we see

210
00:08:27,300 --> 00:08:30,479
down and then simply return this

211
00:08:30,479 --> 00:08:33,899
this hotel  there so that's it there is

212
00:08:33,899 --> 00:08:36,059
really rather simple byte by byte

213
00:08:36,059 --> 00:08:39,059
and technically other people

214
00:08:39,059 --> 00:08:41,880
have not analyzed this farmware without going

215
00:08:41,880 --> 00:08:45,120
through this by this code snippet there and

216
00:08:45,120 --> 00:08:46,200
we simply do a

217
00:08:46,200 --> 00:08:48,540
statistical analysis for that's enough for

218
00:08:48,540 --> 00:08:52,399
for  decipher all that

219
00:08:53,040 --> 00:08:55,500
so now that we have how

220
00:08:55,500 --> 00:08:56,760
the format works and how above all

221
00:08:56,760 --> 00:08:59,160
and how it is packaged we must be

222
00:08:59,160 --> 00:09:02,220
able to recover it too so the

223
00:09:02,220 --> 00:09:05,279
hardway part will be to

224
00:09:05,279 --> 00:09:07,740
recover from the IMC the problem is

225
00:09:07,740 --> 00:09:10,800
that the IMC  was in BGR format, that is to

226
00:09:10,800 --> 00:09:13,620
say that the connections to the PCB are

227
00:09:13,620 --> 00:09:15,240
much more difficult to access

228
00:09:15,240 --> 00:09:18,720
than with the standard SOS format, so

229
00:09:18,720 --> 00:09:21,120
it's more complicated to dump and it's

230
00:09:21,120 --> 00:09:24,000
not the path we took.  chose

231
00:09:24,000 --> 00:09:24,920
a slightly easier path

232
00:09:24,920 --> 00:09:26,820
the printer is able to update itself

233
00:09:26,820 --> 00:09:29,040
when it is started it is

234
00:09:29,040 --> 00:09:30,240
able to search for

235
00:09:30,240 --> 00:09:32,519
updates on the internet so what we did

236
00:09:32,519 --> 00:09:34,399
was simply

237
00:09:34,399 --> 00:09:37,220
set up a  HTTP proxy on the printer

238
00:09:37,220 --> 00:09:40,140
which was suddenly a burpe for us and

239
00:09:40,140 --> 00:09:41,519
we intercepted all the requests to

240
00:09:41,519 --> 00:09:44,279
see what request

241
00:09:44,279 --> 00:09:46,620
the printer was making and then recover the

242
00:09:46,620 --> 00:09:48,440
vinegar in the end,

243
00:09:48,440 --> 00:09:50,880
especially since it was rather simple it's

244
00:09:50,880 --> 00:09:52,500
not  of the https is only the http so

245
00:09:52,500 --> 00:09:54,540
it's really quite easy to

246
00:09:54,540 --> 00:09:55,580
recover all that

247
00:09:55,580 --> 00:10:00,560
and after the fact we have actually

248
00:10:00,600 --> 00:10:01,740
identified another another

249
00:10:01,740 --> 00:10:04,680
simpler way which is in fact to go to

250
00:10:04,680 --> 00:10:06,360
the support site of  canon to recover

251
00:10:06,360 --> 00:10:08,160
the update tools so either for

252
00:10:08,160 --> 00:10:11,160
Windows or for Mac which contain

253
00:10:11,160 --> 00:10:13,260
themselves which do it medium in the

254
00:10:13,260 --> 00:10:15,420
resources associated with the download

255
00:10:15,420 --> 00:10:17,940
and therefore we can directly extract the

256
00:10:17,940 --> 00:10:19,440
medium fire from since this

257
00:10:19,440 --> 00:10:21,899
download there

258
00:10:21,899 --> 00:10:25,200
and little little joke d  Moreover the

259
00:10:25,200 --> 00:10:26,940
update on the proxy is often

260
00:10:26,940 --> 00:10:28,380
well behind the versions

261
00:10:28,380 --> 00:10:31,740
to the versions deployed via the

262
00:10:31,740 --> 00:10:34,080
support site which means that when we were

263
00:10:34,080 --> 00:10:35,399
waiting to know if the guest city

264
00:10:35,399 --> 00:10:37,920
was corrected in fact we did not see

265
00:10:37,920 --> 00:10:39,660
that the  printer was already up to date

266
00:10:39,660 --> 00:10:41,459
and a patch was already released

267
00:10:41,459 --> 00:10:43,200
because we were just trying to

268
00:10:43,200 --> 00:10:45,180
get the update through the proxy and

269
00:10:45,180 --> 00:10:48,319
not to the support site

270
00:10:49,040 --> 00:10:53,220
so for this Farmer I will describe the

271
00:10:53,220 --> 00:10:55,200
package format in which we

272
00:10:55,200 --> 00:10:57,899
retrieve we retrieve this Farmer it's

273
00:10:57,899 --> 00:11:01,260
different blocks of data that are inside

274
00:11:01,260 --> 00:11:02,760
each other in nested lighter

275
00:11:02,760 --> 00:11:05,360
matryoshka style

276
00:11:05,360 --> 00:11:08,040
I'm going to review the different

277
00:11:08,040 --> 00:11:10,079
packages precisely to see

278
00:11:10,079 --> 00:11:10,640
later

279
00:11:10,640 --> 00:11:13,160
what interests us and how we can

280
00:11:13,160 --> 00:11:15,660
extract the code directly  to be

281
00:11:15,660 --> 00:11:18,060
smart as we did the first block

282
00:11:18,060 --> 00:11:20,579
we come across when we analyze the

283
00:11:20,579 --> 00:11:22,740
binary we have a cefw block with a

284
00:11:22,740 --> 00:11:25,640
header and a content the

285
00:11:25,640 --> 00:11:29,700
aesthesidic content and this type of block is the

286
00:11:29,700 --> 00:11:31,560
W on  identified it only on

287
00:11:31,560 --> 00:11:33,480
direct downloads from the

288
00:11:33,480 --> 00:11:35,279
Canon site so as a printer

289
00:11:35,279 --> 00:11:37,079
updates itself it recovers

290
00:11:37,079 --> 00:11:40,519
gipated content otherwise when you recover the

291
00:11:40,519 --> 00:11:43,019
firmware from the support site there is

292
00:11:43,019 --> 00:11:45,660
no there is no  this this block there and

293
00:11:45,660 --> 00:11:46,860
we arrive directly on the second

294
00:11:46,860 --> 00:11:48,779
block which is the ncfw block

295
00:11:48,779 --> 00:11:51,019
which precisely contains

296
00:11:51,019 --> 00:11:54,300
the data opusquées with the routine

297
00:11:54,300 --> 00:11:55,920
that we press to identify previously and

298
00:11:55,920 --> 00:11:59,339
it is this binary there this content there that we

299
00:11:59,339 --> 00:12:01,320
deconstruct to extract  the interesting data

300
00:12:01,320 --> 00:12:02,420


301
00:12:02,420 --> 00:12:05,339
once we have finally been able to extract from the

302
00:12:05,339 --> 00:12:07,500
offices sorry from the officers at this block

303
00:12:07,500 --> 00:12:10,740
there we arrive

304
00:12:10,740 --> 00:12:14,339
on a block on a content which is

305
00:12:14,339 --> 00:12:18,120
formed by several NCA blocks therefore the

306
00:12:18,120 --> 00:12:20,820
NCA blocks which have a header which specifies

307
00:12:20,820 --> 00:12:24,420
to  what address on the immc is

308
00:12:24,420 --> 00:12:26,279
this information written there so there are

309
00:12:26,279 --> 00:12:28,560
different blocks there is in particular the

310
00:12:28,560 --> 00:12:31,140
block with the code which will make it do the

311
00:12:31,140 --> 00:12:33,120
format itself and we also

312
00:12:33,120 --> 00:12:35,339
typically have the slots and this kind

313
00:12:35,339 --> 00:12:37,620
of information which  goes from resources

314
00:12:37,620 --> 00:12:39,300
which is used by the printer in

315
00:12:39,300 --> 00:12:43,160
various other NCA blocks

316
00:12:43,160 --> 00:12:47,220
in one case we have in the case where finally the

317
00:12:47,220 --> 00:12:48,779
block in the set of blocks which

318
00:12:48,779 --> 00:12:51,540
contains the code we also have the

319
00:12:51,540 --> 00:12:53,579
particular case of the first NCA block therefore the

320
00:12:53,579 --> 00:12:57,300
block that we called block zero which will

321
00:12:57,300 --> 00:12:59,880
contain a cryptographic signature

322
00:12:59,880 --> 00:13:02,060
which is associated with each of these blocks

323
00:13:02,060 --> 00:13:05,760
and several mm headers which

324
00:13:05,760 --> 00:13:07,139
correspond to

325
00:13:07,139 --> 00:13:10,139
information specific to each block and

326
00:13:10,139 --> 00:13:12,000
with the way of this information the

327
00:13:12,000 --> 00:13:13,740
bootloader is able to  write the

328
00:13:13,740 --> 00:13:16,860
form on the on the immc and we

329
00:13:16,860 --> 00:13:18,360
are also able to extract the

330
00:13:18,360 --> 00:13:20,100
binary and then analyze it to

331
00:13:20,100 --> 00:13:23,040
return this binary to move forward

332
00:13:23,040 --> 00:13:25,760
in our research

333
00:13:30,160 --> 00:13:33,250
[Music]

334
00:13:40,350 --> 00:13:45,009
[Music]

335
00:14:10,320 --> 00:14:11,519
I'm going to leave the hand now  to

336
00:14:11,519 --> 00:14:14,200
Rémi for the analysis

337
00:14:14,200 --> 00:14:15,600
[Music]

338
00:14:15,600 --> 00:14:17,279
very well so once we have recovered

339
00:14:17,279 --> 00:14:19,380
the black dog in clear that we have

340
00:14:19,380 --> 00:14:21,540
decompressed the opusqués we can

341
00:14:21,540 --> 00:14:23,820
start the analysis so with

342
00:14:23,820 --> 00:14:25,200
the aim of looking for the

343
00:14:25,200 --> 00:14:27,660
vulnerabilities so the  firmware is

344
00:14:27,660 --> 00:14:30,300
made up of arm instructions so

345
00:14:30,300 --> 00:14:32,040
like the bootloader so far nothing is

346
00:14:32,040 --> 00:14:34,820
surprising what the firmware is a

347
00:14:34,820 --> 00:14:36,899
it will contain the operating system

348
00:14:36,899 --> 00:14:38,339
of Ios we will talk about it a little

349
00:14:38,339 --> 00:14:39,360
later  so radiohey it's a

350
00:14:39,360 --> 00:14:40,800
proprietary operating system which is

351
00:14:40,800 --> 00:14:43,740
designed by Canon one of the difficulties

352
00:14:43,740 --> 00:14:46,500
we have with this when we go to analyze this

353
00:14:46,500 --> 00:14:47,880
kind of firmware is that everything is

354
00:14:47,880 --> 00:14:50,699
in a single large file and the

355
00:14:50,699 --> 00:14:51,779
consequence is  is that we will end up

356
00:14:51,779 --> 00:14:53,519
with more than 100,000 functions which will

357
00:14:53,519 --> 00:14:56,579
be recognized by Ida and with 0 symbol

358
00:14:56,579 --> 00:14:58,320
so we have the name of no function so

359
00:14:58,320 --> 00:14:59,459
it is not necessarily super easy to

360
00:14:59,459 --> 00:15:01,199
find an entry point so what  what we

361
00:15:01,199 --> 00:15:03,000
tried to do was identify

362
00:15:03,000 --> 00:15:05,300
a way to automate

363
00:15:05,300 --> 00:15:08,279
our parsing and

364
00:15:08,279 --> 00:15:10,139
function renaming a little bit and we saw that in fact there

365
00:15:10,139 --> 00:15:11,040
was a Lock function that was

366
00:15:11,040 --> 00:15:13,500
used by quite a few times

367
00:15:13,500 --> 00:15:15,959
in the firmware and this function there

368
00:15:15,959 --> 00:15:17,220
it takes as a parameter the name of the

369
00:15:17,220 --> 00:15:18,600
function in which it is used

370
00:15:18,600 --> 00:15:21,000
this log function there it allows you

371
00:15:21,000 --> 00:15:22,920
to write

372
00:15:22,920 --> 00:15:24,600
bug information on Luart and therefore we wrote

373
00:15:24,600 --> 00:15:28,019
a script based on the counting

374
00:15:28,019 --> 00:15:30,540
extracted by using the API to

375
00:15:30,540 --> 00:15:32,399
automatically rename as many

376
00:15:32,399 --> 00:15:33,420
functions as possible so that allowed us

377
00:15:33,420 --> 00:15:35,100
to rename more than 2700

378
00:15:35,100 --> 00:15:37,260
functions and therefore to see a little

379
00:15:37,260 --> 00:15:38,600
more clearly on

380
00:15:38,600 --> 00:15:40,860
what we could find inside

381
00:15:40,860 --> 00:15:43,440
this at  me there

382
00:15:43,440 --> 00:15:47,160
so i said the firmware it's it

383
00:15:47,160 --> 00:15:48,480
contains the dryos operating system

384
00:15:48,480 --> 00:15:51,120
so it's a RTOS real time aper acting

385
00:15:51,120 --> 00:15:53,880
System which is designed by Canon it's an

386
00:15:53,880 --> 00:15:55,680
RTOS who use for their

387
00:15:55,680 --> 00:15:57,959
printers but also their

388
00:15:57,959 --> 00:15:59,519
digital camera and probably for

389
00:15:59,519 --> 00:16:01,519
two types of peripherals

390
00:16:01,519 --> 00:16:03,540
we know that this is a

391
00:16:03,540 --> 00:16:04,740
bone that has been using for some time

392
00:16:04,740 --> 00:16:06,720
since in the case of another R&D we

393
00:16:06,720 --> 00:16:07,980
had looked at another Canon printer

394
00:16:07,980 --> 00:16:11,279
which was also based on dryos and

395
00:16:11,279 --> 00:16:12,360
early firmware  for this

396
00:16:12,360 --> 00:16:14,100
printer there was over 10 years old

397
00:16:14,100 --> 00:16:15,060
so here it is something that has been

398
00:16:15,060 --> 00:16:17,480
using dryos for some time

399
00:16:17,480 --> 00:16:21,300
it is based on another finally if

400
00:16:21,300 --> 00:16:23,639
it is based on a Japanese RTOS

401
00:16:23,639 --> 00:16:26,720
called micro industrial Toine

402
00:16:26,720 --> 00:16:29,660
so this

403
00:16:29,660 --> 00:16:33,060
Japanese RTS has specifications that

404
00:16:33,060 --> 00:16:35,639
are freely available online and

405
00:16:35,639 --> 00:16:36,839
so that's interesting if we want to

406
00:16:36,839 --> 00:16:38,160
take a little interest in the different

407
00:16:38,160 --> 00:16:40,199
low-level mechanisms implemented by this

408
00:16:40,199 --> 00:16:41,480
RTOS

409
00:16:41,480 --> 00:16:43,860
so our printer was

410
00:16:43,860 --> 00:16:46,860
based on dryos version 2.3 which was

411
00:16:46,860 --> 00:16:50,160
based  on micro industrial index Tron in

412
00:16:50,160 --> 00:16:52,440
version 4.0 so what we will find

413
00:16:52,440 --> 00:16:55,259
in this tosla is an API which will

414
00:16:55,259 --> 00:16:56,279
allow to create different types

415
00:16:56,279 --> 00:16:59,279
of objects of the type mutex socket task

416
00:16:59,279 --> 00:17:00,720
semaphore etc so something

417
00:17:00,720 --> 00:17:03,560
quite classic

418
00:17:04,260 --> 00:17:07,520
if we  keep from a security point of view

419
00:17:07,520 --> 00:17:09,599
this operating system it will be

420
00:17:09,599 --> 00:17:10,819
quite interesting for us

421
00:17:10,819 --> 00:17:13,500
attackers since we will find

422
00:17:13,500 --> 00:17:15,599
almost no

423
00:17:15,599 --> 00:17:17,220
modern mutilation as we could find

424
00:17:17,220 --> 00:17:20,220
today so there is no there is

425
00:17:20,220 --> 00:17:22,679
no  'aslr and the system is composed

426
00:17:22,679 --> 00:17:26,099
of a single block that is mapped

427
00:17:26,099 --> 00:17:29,400
to a fixed address so the

428
00:17:29,400 --> 00:17:31,559
consequence of this is that the address of

429
00:17:31,559 --> 00:17:33,419
each function is predictable even

430
00:17:33,419 --> 00:17:35,780
after restarting the  printer there is

431
00:17:35,780 --> 00:17:39,480
no implementation of

432
00:17:39,480 --> 00:17:41,460
protection on the memory pages so

433
00:17:41,460 --> 00:17:44,400
the firmware and mapped in RWX for

434
00:17:44,400 --> 00:17:47,340
all the code there is no stack

435
00:17:47,340 --> 00:17:48,660
cookies either

436
00:17:48,660 --> 00:17:50,760
and therefore the consequence of that is

437
00:17:50,760 --> 00:17:54,480
say that if we find a stack of for

438
00:17:54,480 --> 00:17:56,160
overflow for example a single bug can be

439
00:17:56,160 --> 00:17:57,539
enough to obtain code execution

440
00:17:57,539 --> 00:17:59,660


441
00:17:59,660 --> 00:18:01,980
obviously there is no

442
00:18:01,980 --> 00:18:04,640
modern protection like control flow integrity

443
00:18:04,640 --> 00:18:08,280
lastacle and the hips are executable there

444
00:18:08,280 --> 00:18:10,380
is not  security to some as one

445
00:18:10,380 --> 00:18:12,539
might find today in

446
00:18:12,539 --> 00:18:15,080


447
00:18:15,080 --> 00:18:18,179
modern tenant waters etc etc what can

448
00:18:18,179 --> 00:18:19,880
also be noted is that

449
00:18:19,880 --> 00:18:23,460
the plates can access the STAC and

450
00:18:23,460 --> 00:18:25,620
the hype of other tasks so there is

451
00:18:25,620 --> 00:18:29,479
really no no segmentation

452
00:18:30,360 --> 00:18:32,580
something that was particularly

453
00:18:32,580 --> 00:18:35,160
useful for us is a debug boss

454
00:18:35,160 --> 00:18:37,919
called dryichel so

455
00:18:37,919 --> 00:18:39,780
earlier Thomas told you about Luart

456
00:18:39,780 --> 00:18:41,700
so we saw that when

457
00:18:41,700 --> 00:18:43,860
the printer started  on the the bootloader

458
00:18:43,860 --> 00:18:45,360
was writing some strings

459
00:18:45,360 --> 00:18:46,919
on the Hart what is quite interesting

460
00:18:46,919 --> 00:18:49,380
is that once the printer has

461
00:18:49,380 --> 00:18:50,760
finished booting there is a cup which

462
00:18:50,760 --> 00:18:52,919
is dedicated to implementing a

463
00:18:52,919 --> 00:18:55,580
debug leader and therefore which is accessible

464
00:18:55,580 --> 00:18:58,980
simply what so this shawl there it

465
00:18:58,980 --> 00:19:01,919
implements 413 commands which are

466
00:19:01,919 --> 00:19:04,799
distributed in 46 different families of commands

467
00:19:04,799 --> 00:19:05,640
so we are going to see

468
00:19:05,640 --> 00:19:07,080
system commands network commands

469
00:19:07,080 --> 00:19:09,960
debug commands etc etc so this is

470
00:19:09,960 --> 00:19:10,620
something that will be

471
00:19:10,620 --> 00:19:12,240
particularly

472
00:19:12,240 --> 00:19:13,820
useful when we go  want to

473
00:19:13,820 --> 00:19:17,160
write debug a shelcodes or when we

474
00:19:17,160 --> 00:19:18,919
want to

475
00:19:18,919 --> 00:19:22,080
obtain code execution

476
00:19:22,080 --> 00:19:23,160
two commands which were

477
00:19:23,160 --> 00:19:25,919
particularly useful for the

478
00:19:25,919 --> 00:19:28,140
exploitation part this is the first it is xD

479
00:19:28,140 --> 00:19:29,940
So it is a command which allows to

480
00:19:29,940 --> 00:19:31,799
make a hexadecimal dump d  'one at a

481
00:19:31,799 --> 00:19:33,720
particular address so that's quite

482
00:19:33,720 --> 00:19:34,679
practical when you want to write a

483
00:19:34,679 --> 00:19:36,240
shelcodes for example if you don't know if

484
00:19:36,240 --> 00:19:38,280
it will run correctly you will be able to

485
00:19:38,280 --> 00:19:39,539
write a Magic value at a

486
00:19:39,539 --> 00:19:40,799
particular address and then check that it

487
00:19:40,799 --> 00:19:43,440
has been  written and the second is XM

488
00:19:43,440 --> 00:19:45,539
which allows in the same way to

489
00:19:45,539 --> 00:19:48,539
modify a word one byte one of the World

490
00:19:48,539 --> 00:19:50,179
no matter at a particular address

491
00:19:50,179 --> 00:19:54,299
finally another command which can be

492
00:19:54,299 --> 00:19:55,980
quite interesting it is even sedum

493
00:19:55,980 --> 00:19:57,900
so we have seen that the  firmoire was

494
00:19:57,900 --> 00:20:00,419
stored in plain text on the IMC but

495
00:20:00,419 --> 00:20:02,400
it was not necessarily easy to dump

496
00:20:02,400 --> 00:20:03,860
the MC

497
00:20:03,860 --> 00:20:06,440
via so we will say

498
00:20:06,440 --> 00:20:08,880
in a hardware way and in fact

499
00:20:08,880 --> 00:20:10,740
simply with the Hart using the

500
00:20:10,740 --> 00:20:12,419
IMC DOM command and giving the address

501
00:20:12,419 --> 00:20:15,480
to  which they want to pay me the same

502
00:20:15,480 --> 00:20:16,620
it's like the firmant is stored in

503
00:20:16,620 --> 00:20:18,419
clear it's an alternative way to

504
00:20:18,419 --> 00:20:20,039
recover the feminine that unfortunately

505
00:20:20,039 --> 00:20:22,020
we realized after

506
00:20:22,020 --> 00:20:23,160
all the work we did to

507
00:20:23,160 --> 00:20:24,240
get the firmware  clearly

508
00:20:24,240 --> 00:20:26,100
the identification of the

509
00:20:26,100 --> 00:20:29,178
decryption routine etc etc

510
00:20:29,700 --> 00:20:31,860
that's it for the bit analysis part of the

511
00:20:31,860 --> 00:20:33,059
chamware and now I'm going to

512
00:20:33,059 --> 00:20:34,500
tell you a little bit about our

513
00:20:34,500 --> 00:20:36,059
methodology to

514
00:20:36,059 --> 00:20:38,220
identify the attack surface and to

515
00:20:38,220 --> 00:20:42,780
choose a service to attack

516
00:20:42,900 --> 00:20:45,179
so to analyze  the attack surface

517
00:20:45,179 --> 00:20:47,880
is we have the methodology it's quite

518
00:20:47,880 --> 00:20:49,500
simple we roughly did a scan

519
00:20:49,500 --> 00:20:52,200
and map where we also coupled with the

520
00:20:52,200 --> 00:20:55,380
netat command which is available via

521
00:20:55,380 --> 00:20:57,840
Luart and that allowed us to have the

522
00:20:57,840 --> 00:20:59,340
list  suddenly services which were

523
00:20:59,340 --> 00:21:00,360
available on the network and which we

524
00:21:00,360 --> 00:21:01,280
could attack

525
00:21:01,280 --> 00:21:05,520
so what we will find on TCP is

526
00:21:05,520 --> 00:21:08,039
a set of services of the type we will

527
00:21:08,039 --> 00:21:10,740
find an HTTP server which is designed

528
00:21:10,740 --> 00:21:12,059
by Canon so it is a  custom HTTP server

529
00:21:12,059 --> 00:21:13,919
which is not based for example on

530
00:21:13,919 --> 00:21:16,980
an implementation of the Apache or

531
00:21:16,980 --> 00:21:20,340
engine x type we will find different

532
00:21:20,340 --> 00:21:22,220
printing protocols

533
00:21:22,220 --> 00:21:24,120
different protocols which are linked we

534
00:21:24,120 --> 00:21:25,980
will say to

535
00:21:25,980 --> 00:21:27,720
printing protocols and which are linked to the fact

536
00:21:27,720 --> 00:21:29,340
that  we target a printer therefore we will

537
00:21:29,340 --> 00:21:31,679
find LPD therefore line printerdiman

538
00:21:31,679 --> 00:21:34,559
protocol we will find IPP therefore

539
00:21:34,559 --> 00:21:36,240
Internet a team protocol which is a

540
00:21:36,240 --> 00:21:38,100
protocol which is based on http therefore

541
00:21:38,100 --> 00:21:40,679
implemented coupled with HTTP tightening

542
00:21:40,679 --> 00:21:44,340
we will also find jet

543
00:21:44,340 --> 00:21:47,460
what we will also find  on

544
00:21:47,460 --> 00:21:49,020
UDP it will be a set of protocols

545
00:21:49,020 --> 00:21:51,419
which will allow

546
00:21:51,419 --> 00:21:52,980
the printer to be discovered on the network so this is

547
00:21:52,980 --> 00:21:53,640
typically what it will do that

548
00:21:53,640 --> 00:21:55,620
the printer will be visible on a

549
00:21:55,620 --> 00:21:58,559
Windows network without any particular action on the

550
00:21:58,559 --> 00:22:01,980
Workstations of the domain so  we will

551
00:22:01,980 --> 00:22:04,820
find NetBIOS WSD type protocols

552
00:22:04,820 --> 00:22:07,380
so web service of mini Discovery

553
00:22:07,380 --> 00:22:09,780
SLP service location protocol or even

554
00:22:09,780 --> 00:22:11,760
zero account that's all of a set of

555
00:22:11,760 --> 00:22:13,620
protocols that will send messages

556
00:22:13,620 --> 00:22:15,240
to the broadcast address so that's going to

557
00:22:15,240 --> 00:22:16,620
be that can be  targets also

558
00:22:16,620 --> 00:22:18,659
which are interesting since these are

559
00:22:18,659 --> 00:22:20,880
protocols that we will be able to target without

560
00:22:20,880 --> 00:22:24,659
without authentication afterwards if we take

561
00:22:24,659 --> 00:22:27,120
the example of the HTTP server in terms of

562
00:22:27,120 --> 00:22:28,500
attack surface there are different

563
00:22:28,500 --> 00:22:30,059
CGI scripts which are implemented so that

564
00:22:30,059 --> 00:22:31,460
that  can be a good target

565
00:22:31,460 --> 00:22:33,860
the disadvantage is that to be able to

566
00:22:33,860 --> 00:22:36,120
target the CGI scripts we will

567
00:22:36,120 --> 00:22:39,240
need to identify ourselves beforehand and

568
00:22:39,240 --> 00:22:40,380
since we do not have the

569
00:22:40,380 --> 00:22:42,059
administrator password we are not within the

570
00:22:42,059 --> 00:22:44,159
framework of the rules  pontoon where we want to

571
00:22:44,159 --> 00:22:46,320
obtain code execution on a

572
00:22:46,320 --> 00:22:49,679
device without authentication

573
00:22:49,679 --> 00:22:52,919
finally what we will find is two

574
00:22:52,919 --> 00:22:56,700
canon proprietary protocols so mfnp

575
00:22:56,700 --> 00:22:58,679
so this is a protocol that allows

576
00:22:58,679 --> 00:23:00,240
printing or scanning

577
00:23:00,240 --> 00:23:03,840
documents via the network and finally it's

578
00:23:03,840 --> 00:23:06,600
ADM which has a canon proprietary protocol

579
00:23:06,600 --> 00:23:07,559
that allows

580
00:23:07,559 --> 00:23:09,200


581
00:23:09,200 --> 00:23:12,179
printer administration across networks so

582
00:23:12,179 --> 00:23:13,559
I'm going to let me tell you a

583
00:23:13,559 --> 00:23:16,639
little more about CDM

584
00:23:16,820 --> 00:23:19,320
so we're going  now move on to the

585
00:23:19,320 --> 00:23:20,940
presentation of the vulnerability and

586
00:23:20,940 --> 00:23:23,700
that we have identified and how we have

587
00:23:23,700 --> 00:23:26,480
exploited it within the framework of the poetoune therefore

588
00:23:26,480 --> 00:23:28,620
the vulnerability that we have identified is

589
00:23:28,620 --> 00:23:30,179
a hip-hovers flow which is present in

590
00:23:30,179 --> 00:23:32,220
the service in Emilien  just

591
00:23:32,220 --> 00:23:34,380
spoken it's ADM we will come to it just

592
00:23:34,380 --> 00:23:36,000
after in the next slide for more

593
00:23:36,000 --> 00:23:39,780
details on this service there so

594
00:23:39,780 --> 00:23:41,760
this vulnerability has been assigned the

595
00:23:41,760 --> 00:23:44,580
following CV number and the vulnerability

596
00:23:44,580 --> 00:23:46,919
has been reported by ZI at  manufacturer on

597
00:23:46,919 --> 00:23:49,620
January 21, 2022 and approximately

598
00:23:49,620 --> 00:23:51,840
two months later the city a

599
00:23:51,840 --> 00:23:54,059
security bulletin was issued by ZI once

600
00:23:54,059 --> 00:23:55,679
the vulnerability was patched by

601
00:23:55,679 --> 00:23:58,380
by Canon

602
00:23:58,380 --> 00:24:01,140
so it's ADM what's this service

603
00:24:01,140 --> 00:24:03,120
so it's probably the

604
00:24:03,120 --> 00:24:05,039
canon administration service

605
00:24:05,039 --> 00:24:07,080
judging first by the title of it's for Canon

606
00:24:07,080 --> 00:24:09,240
and DNA for administration and then

607
00:24:09,240 --> 00:24:11,460
by the nature of the operations supported

608
00:24:11,460 --> 00:24:13,020
by this protocol there because this

609
00:24:13,020 --> 00:24:15,179
protocol allows for example to add

610
00:24:15,179 --> 00:24:17,280
a new user change his

611
00:24:17,280 --> 00:24:19,380
password start a new job or

612
00:24:19,380 --> 00:24:21,720
simply restart the device

613
00:24:21,720 --> 00:24:24,240
and in the code we found 41

614
00:24:24,240 --> 00:24:27,140
operations supported by this protocol

615
00:24:27,140 --> 00:24:29,159
now why we

616
00:24:29,159 --> 00:24:30,659
particularly chose this service there because

617
00:24:30,659 --> 00:24:33,000
it is a canon proprietary service

618
00:24:33,000 --> 00:24:34,559
and it says proprietary service

619
00:24:34,559 --> 00:24:37,580
often says presence of life

620
00:24:38,780 --> 00:24:41,580
so the protocol is DNA it is quite

621
00:24:41,580 --> 00:24:43,559
simple so we have here the format of the

622
00:24:43,559 --> 00:24:44,940
messages it is ADM which develops which

623
00:24:44,940 --> 00:24:47,240
starts at the top with a Magic CDCA

624
00:24:47,240 --> 00:24:50,280
followed by the version of the protocol we

625
00:24:50,280 --> 00:24:51,480
then have the code  of the operation which will

626
00:24:51,480 --> 00:24:52,919
distinguish which operation at the top to

627
00:24:52,919 --> 00:24:54,960
redo among the 41 that we have identified

628
00:24:54,960 --> 00:24:59,039
and we have the pelo which will

629
00:24:59,039 --> 00:25:00,720
obviously depend on this operation code in

630
00:25:00,720 --> 00:25:01,860
the format will depend on this operation code

631
00:25:01,860 --> 00:25:03,840


632
00:25:03,840 --> 00:25:05,880
now when  we started auditing

633
00:25:05,880 --> 00:25:08,340
this service the first thing we

634
00:25:08,340 --> 00:25:10,200
wanted to do was to know is there

635
00:25:10,200 --> 00:25:11,700
some kind of

636
00:25:11,700 --> 00:25:14,280
authentication mechanism and start this

637
00:25:14,280 --> 00:25:16,640
amplification would take shape so we came

638
00:25:16,640 --> 00:25:18,960
up with this function-  there which is

639
00:25:18,960 --> 00:25:20,580
called check user password 2 which is

640
00:25:20,580 --> 00:25:23,100
one of the routines among the 41 that we have

641
00:25:23,100 --> 00:25:25,140
identified and in this case we were

642
00:25:25,140 --> 00:25:26,279
lucky because the first routine

643
00:25:26,279 --> 00:25:28,380
that we looked at is coming so this

644
00:25:28,380 --> 00:25:29,940
function which is  calls check user

645
00:25:29,940 --> 00:25:31,500
password 2 what it does is that it

646
00:25:31,500 --> 00:25:35,279
will rent a structure of 428 bytes which

647
00:25:35,279 --> 00:25:37,919
contains several buffers does

648
00:25:37,919 --> 00:25:38,940
this function do it is that it will

649
00:25:38,940 --> 00:25:41,460
decode the pelo check user password 2

650
00:25:41,460 --> 00:25:43,559
which is  displayed here at the bottom of this slime

651
00:25:43,559 --> 00:25:46,320
this bike contains several buffers of

652
00:25:46,320 --> 00:25:47,640
several fixed size data blocks

653
00:25:47,640 --> 00:25:50,220
each prefixed by one by a

654
00:25:50,220 --> 00:25:52,799
size encoded on a Byte is that what

655
00:25:52,799 --> 00:25:54,240
this function does it will

656
00:25:54,240 --> 00:25:55,980
copy its blocks from  data whose

657
00:25:55,980 --> 00:25:59,760
buffers in the buffers of the

658
00:25:59,760 --> 00:26:01,380
structure we have to rent either we

659
00:26:01,380 --> 00:26:02,820
check the size we

660
00:26:02,820 --> 00:26:04,700
therefore end up here with several

661
00:26:04,700 --> 00:26:06,900
overflows in the structure we have to

662
00:26:06,900 --> 00:26:09,600
rent we have in particular two buffers which

663
00:26:09,600 --> 00:26:11,039
are vulnerable there are  a buffer

664
00:26:11,039 --> 00:26:12,960
called room which is 32 bytes and

665
00:26:12,960 --> 00:26:15,419
another buffer called h and which is

666
00:26:15,419 --> 00:26:17,940
28 bytes the advantage here is that

667
00:26:17,940 --> 00:26:19,860
we can overflow with data that we

668
00:26:19,860 --> 00:26:23,279
control and we also control the

669
00:26:23,279 --> 00:26:24,960
size  from the opening to one up to a

670
00:26:24,960 --> 00:26:26,580
given limit

671
00:26:26,580 --> 00:26:27,779
so which is very practical for us

672
00:26:27,779 --> 00:26:30,900
from an exploitability point of view

673
00:26:30,900 --> 00:26:33,179
so as we have to flow to be

674
00:26:33,179 --> 00:26:34,260
able to exploit it we need to

675
00:26:34,260 --> 00:26:36,299
understand how the tenant

676
00:26:36,299 --> 00:26:39,179
of dry west works  so it's a best fit the

677
00:26:39,179 --> 00:26:40,679
tenant it's a best fit allocator

678
00:26:40,679 --> 00:26:43,020
so it maintains a linked list of

679
00:26:43,020 --> 00:26:45,480
chunks which are fried which we call the

680
00:26:45,480 --> 00:26:48,360
Free smooth so each chunk of this

681
00:26:48,360 --> 00:26:50,220
finist it contains 40 bytes of

682
00:26:50,220 --> 00:26:52,500
metadata which start with a  Magic

683
00:26:52,500 --> 00:26:54,240
which is either free when it is changed and

684
00:26:54,240 --> 00:26:56,360
Free or ALC when the chunk is allocated

685
00:26:56,360 --> 00:26:58,919
we then have the size of the Chun which

686
00:26:58,919 --> 00:27:00,480
also includes the size of the

687
00:27:00,480 --> 00:27:02,340
metadata and then we have a

688
00:27:02,340 --> 00:27:04,980
next pointer which points to the next chunk

689
00:27:04,980 --> 00:27:08,039
which is free in  the Free list

690
00:27:08,039 --> 00:27:10,559
now when we use a Mac

691
00:27:10,559 --> 00:27:12,480
so what the tenant will do is

692
00:27:12,480 --> 00:27:13,980
it will iterate over the smooth Free and

693
00:27:13,980 --> 00:27:16,020
retrieve the first chunk that satisfies

694
00:27:16,020 --> 00:27:18,480
the size condition the

695
00:27:18,480 --> 00:27:21,059
important point for us here is  that when

696
00:27:21,059 --> 00:27:23,159
we make an allocation and there is

697
00:27:23,159 --> 00:27:24,720
enough free space left in the

698
00:27:24,720 --> 00:27:27,000
chunk from which we were allocated a

699
00:27:27,000 --> 00:27:29,100
new chunk will be created in the space

700
00:27:29,100 --> 00:27:30,840
that remains free, that is to say that if

701
00:27:30,840 --> 00:27:34,380
ever the size of the change  we remove the

702
00:27:34,380 --> 00:27:35,419
size

703
00:27:35,419 --> 00:27:39,779
of the we requested and if it is

704
00:27:39,779 --> 00:27:41,159
greater than the size of the metadata we

705
00:27:41,159 --> 00:27:42,480
are we will be able to create a new

706
00:27:42,480 --> 00:27:44,640
chunk in the space that remains free

707
00:27:44,640 --> 00:27:46,260
and finally when we have rented a chunk

708
00:27:46,260 --> 00:27:47,820
it will be  removed from the Free list and

709
00:27:47,820 --> 00:27:50,279
return to the user

710
00:27:50,279 --> 00:27:52,980
now when we fry a trunk you

711
00:27:52,980 --> 00:27:54,419
have to know that the elements in the

712
00:27:54,419 --> 00:27:55,440
Free smooth they are ordered by their

713
00:27:55,440 --> 00:27:56,820
address so when we brake a jump we

714
00:27:56,820 --> 00:27:58,440
will simply iterate over the freelice and

715
00:27:58,440 --> 00:28:01,799
insert the  chunk to its good position and

716
00:28:01,799 --> 00:28:05,700
if one of these neighbors is and free it

717
00:28:05,700 --> 00:28:07,740
will be emerged with the chunks will be merged

718
00:28:07,740 --> 00:28:10,340
with 100%

719
00:28:10,740 --> 00:28:14,039
so that we can facilitate the

720
00:28:14,039 --> 00:28:15,480
exploitation phase of the vulnerability so

721
00:28:15,480 --> 00:28:18,659
we have implemented a drychel command which

722
00:28:18,659 --> 00:28:20,580
will allow to  visualize the state of the Hip

723
00:28:20,580 --> 00:28:22,620
so this command that we called HD

724
00:28:22,620 --> 00:28:24,720
it will simply iterate over the

725
00:28:24,720 --> 00:28:26,220
Free list and use the xD command

726
00:28:26,220 --> 00:28:29,460
To display each time the

727
00:28:29,460 --> 00:28:32,100
metadata of each Tchang, namely

728
00:28:32,100 --> 00:28:34,440
here we limit ourselves to dumping, for example, the

729
00:28:34,440 --> 00:28:36,840
Magic the size of the chunk and the value of the

730
00:28:36,840 --> 00:28:39,360
pointer next

731
00:28:39,360 --> 00:28:42,539
ok now that we have an idea that we are

732
00:28:42,539 --> 00:28:44,779
walking the tenant

733
00:28:44,779 --> 00:28:48,659
we have we ask ourselves the question how we

734
00:28:48,659 --> 00:28:49,860
could attack its allocators there

735
00:28:49,860 --> 00:28:50,940
first of all it is necessary to know that this

736
00:28:50,940 --> 00:28:52,260
allocator there  there is none like the

737
00:28:52,260 --> 00:28:53,460
director earlier there is no

738
00:28:53,460 --> 00:28:55,260
protection so we are able to

739
00:28:55,260 --> 00:28:57,179
how we can see in the in

740
00:28:57,179 --> 00:28:58,980
modern allocators we can come and

741
00:28:58,980 --> 00:29:02,159
modify the metadata as we please

742
00:29:02,159 --> 00:29:04,020
on the other hand we cannot put just

743
00:29:04,020 --> 00:29:06,059
any  value we took it lately

744
00:29:06,059 --> 00:29:10,080
another deposit that we are trying to poker

745
00:29:10,080 --> 00:29:11,340
our vulnerability we

746
00:29:11,340 --> 00:29:12,720
realized that there is a parallel task that

747
00:29:12,720 --> 00:29:15,120
has nothing to do with the vulnerability

748
00:29:15,120 --> 00:29:16,860
which is responsible for collecting

749
00:29:16,860 --> 00:29:19,399
statistics on the  memory usage and

750
00:29:19,399 --> 00:29:22,260
memory usage and this task it will

751
00:29:22,260 --> 00:29:23,640
stretch on the freelice so if we put an

752
00:29:23,640 --> 00:29:24,960
invalid pointer in the freelice it will

753
00:29:24,960 --> 00:29:26,880
make the task spit and make

754
00:29:26,880 --> 00:29:29,779
the printer curl so tonight be careful

755
00:29:29,779 --> 00:29:32,940
against the Hip but be careful

756
00:29:32,940 --> 00:29:34,380
now  what are our options to

757
00:29:34,380 --> 00:29:36,899
attack the tenant so we probably have

758
00:29:36,899 --> 00:29:38,039
several options one of the options

759
00:29:38,039 --> 00:29:39,600
would be to for example modify the size

760
00:29:39,600 --> 00:29:42,600
of the chunk in order to enlarge it and hope to

761
00:29:42,600 --> 00:29:46,260
enlarge our overflow

762
00:29:46,260 --> 00:29:48,240
we can also modify the pointer

763
00:29:48,240 --> 00:29:50,100
next it is to do it  point somewhere

764
00:29:50,100 --> 00:29:51,600
we have function pointers hope

765
00:29:51,600 --> 00:29:54,000
to have an arbitrary allocation and this is

766
00:29:54,000 --> 00:29:57,059
the option that we have chosen

767
00:29:57,059 --> 00:30:00,360
so for that we have established this

768
00:30:00,360 --> 00:30:02,340
exploitation strategy so we have at

769
00:30:02,340 --> 00:30:03,840
first we need to do  a

770
00:30:03,840 --> 00:30:06,179
minimum of Hip shipping we will see

771
00:30:06,179 --> 00:30:07,440
why we need to do it and

772
00:30:07,440 --> 00:30:09,539
how we do it the second step

773
00:30:09,539 --> 00:30:12,419
is to trigger the vulnerability and

774
00:30:12,419 --> 00:30:14,520
it is to corrupt the next pointer of the

775
00:30:14,520 --> 00:30:17,159
Chun which is contiguous in memory in order to

776
00:30:17,159 --> 00:30:19,200
make it point somewhere where we have

777
00:30:19,200 --> 00:30:21,120
function pointers the third

778
00:30:21,120 --> 00:30:23,100
step is to retrieve our invoice

779
00:30:23,100 --> 00:30:24,899
having this arbitrary allocation

780
00:30:24,899 --> 00:30:27,960
in order to copy a sheld two corrupt

781
00:30:27,960 --> 00:30:29,159
the function pointer and make it

782
00:30:29,159 --> 00:30:31,020
point to the shell code and the last

783
00:30:31,020 --> 00:30:33,240
step c  is to trigger

784
00:30:33,240 --> 00:30:34,860
code execution by forcing a call to the function

785
00:30:34,860 --> 00:30:38,039
whose pointer we have corrupted

786
00:30:38,039 --> 00:30:39,860
we will start with the first step

787
00:30:39,860 --> 00:30:42,659
our objective here when we go to P8

788
00:30:42,659 --> 00:30:45,299
we need to force an allocation

789
00:30:45,299 --> 00:30:46,980
from a Chun  which is

790
00:30:46,980 --> 00:30:48,840
wide enough why we need to do that

791
00:30:48,840 --> 00:30:50,520
because once our

792
00:30:50,520 --> 00:30:51,899
vulnerable chunk will be Free and reintegrate

793
00:30:51,899 --> 00:30:53,820
into Africa there will be

794
00:30:53,820 --> 00:30:55,500
parity allocations and we don't see that

795
00:30:55,500 --> 00:30:57,299
these parasitic allocations seek

796
00:30:57,299 --> 00:30:59,940
our fakes  wants it's

797
00:30:59,940 --> 00:31:01,740
parasitic allocations to be able to draw

798
00:31:01,740 --> 00:31:04,340
their allocation from this from

799
00:31:04,340 --> 00:31:07,740
this large space so we're going how we're going to

800
00:31:07,740 --> 00:31:10,020
do that we're going we found that by

801
00:31:10,020 --> 00:31:11,940
making an HTTP request to the

802
00:31:11,940 --> 00:31:14,340
Web server was enough to fragment the Hip into

803
00:31:14,340 --> 00:31:15,840
chunks which  which are quite large in size

804
00:31:15,840 --> 00:31:17,940
and it is more than enough for

805
00:31:17,940 --> 00:31:20,399
our reason

806
00:31:20,399 --> 00:31:22,200
so the second step now is

807
00:31:22,200 --> 00:31:24,720
to trigger our vulnerability so

808
00:31:24,720 --> 00:31:27,600
for that we have forged a hello check user

809
00:31:27,600 --> 00:31:30,360
password 2 so as to overlap on

810
00:31:30,360 --> 00:31:31,799
the next pointer of the  chunk which is

811
00:31:31,799 --> 00:31:33,899
contiguous in memory and we decided to

812
00:31:33,899 --> 00:31:35,640
make it point somewhere we have the

813
00:31:35,640 --> 00:31:38,279
CADM structures in particular the

814
00:31:38,279 --> 00:31:40,080
state machine which contains lots of function pointers

815
00:31:40,080 --> 00:31:41,760


816
00:31:41,760 --> 00:31:44,220
two conditions on our sheet on the

817
00:31:44,220 --> 00:31:46,020
choice of our invoice so we have a  we

818
00:31:46,020 --> 00:31:47,940
need to have a postman with

819
00:31:47,940 --> 00:31:50,039
a size that is

820
00:31:50,039 --> 00:31:52,080
large enough so that we can reserve it and

821
00:31:52,080 --> 00:31:56,460
not be served by the tchun

822
00:31:56,460 --> 00:31:57,480
who precede we

823
00:31:57,480 --> 00:31:59,880
particularly want to recover this postman

824
00:31:59,880 --> 00:32:02,220
without there in particular  and we

825
00:32:02,220 --> 00:32:06,179
need to have after this size

826
00:32:06,179 --> 00:32:07,860
there a pointer next which is worth zero so

827
00:32:07,860 --> 00:32:10,939
that we can close the fribe

828
00:32:12,260 --> 00:32:14,640
there we have a visualization of our

829
00:32:14,640 --> 00:32:16,679
invoice in memory so there we see that

830
00:32:16,679 --> 00:32:19,320
we have a very substantial size which is

831
00:32:19,320 --> 00:32:21,539
followed by a null pointer and not very

832
00:32:21,539 --> 00:32:23,399
far from there we have what represents a bit of

833
00:32:23,399 --> 00:32:25,559
the state machine it is ADM which is

834
00:32:25,559 --> 00:32:27,360
which contains a lot of function counters

835
00:32:27,360 --> 00:32:29,479


836
00:32:29,820 --> 00:32:31,559
now how will our

837
00:32:31,559 --> 00:32:33,240
faction recover knowing that our faction it

838
00:32:33,240 --> 00:32:34,620
is a large enough size and so

839
00:32:34,620 --> 00:32:37,020
that we can iterate on the freelice and

840
00:32:37,020 --> 00:32:39,779
only retrieve this field there we need

841
00:32:39,779 --> 00:32:41,940
we need to have an allocation that

842
00:32:41,940 --> 00:32:43,500
is large enough and for that we will

843
00:32:43,500 --> 00:32:45,440
use another operation of the

844
00:32:45,440 --> 00:32:47,399
c protocol  it's ADN which is the

845
00:32:47,399 --> 00:32:49,159
Eco operation which is very practical because

846
00:32:49,159 --> 00:32:52,080
this echo operation allows you

847
00:32:52,080 --> 00:32:53,880
to make allocations of

848
00:32:53,880 --> 00:32:56,460
arbitrary size and with

849
00:32:56,460 --> 00:32:58,200
totally controlled data and you can allocate

850
00:32:58,200 --> 00:33:00,779
up to xrx 10000 ok which is

851
00:33:00,779 --> 00:33:02,159


852
00:33:02,159 --> 00:33:03,779
therefore significant  this operation which is an echo what

853
00:33:03,779 --> 00:33:05,940
does it just do it will we

854
00:33:05,940 --> 00:33:07,320
send it a message it will

855
00:33:07,320 --> 00:33:08,700
send us back an identical copy of this

856
00:33:08,700 --> 00:33:11,000
message there so as I say this

857
00:33:11,000 --> 00:33:14,399
operation echo and practical because we

858
00:33:14,399 --> 00:33:16,080
have the combo of  controlled data plus

859
00:33:16,080 --> 00:33:17,820
a controlled size

860
00:33:17,820 --> 00:33:18,960
so it will allow us to recover

861
00:33:18,960 --> 00:33:21,120
our invoice so once we

862
00:33:21,120 --> 00:33:23,159
recover our faction what we are going to do

863
00:33:23,159 --> 00:33:24,720
is as we recovered it with an

864
00:33:24,720 --> 00:33:25,919
Eco operation what we are going to do c  is that

865
00:33:25,919 --> 00:33:28,260
once we have retrieved this fiction

866
00:33:28,260 --> 00:33:29,940
that we will copy our shell code and

867
00:33:29,940 --> 00:33:31,860
modify the pointer which is

868
00:33:31,860 --> 00:33:33,299
responsible for processing

869
00:33:33,299 --> 00:33:36,000
echo operations like that once our

870
00:33:36,000 --> 00:33:37,500
once we have sent our message we have

871
00:33:37,500 --> 00:33:39,179
one in accordance with the cup and

872
00:33:39,179 --> 00:33:40,679
DNA machine we are going to have directly from the

873
00:33:40,679 --> 00:33:42,720
code execution

874
00:33:42,720 --> 00:33:44,580
what we are also doing that we have a large

875
00:33:44,580 --> 00:33:45,960
location we are going to copy our scale code

876
00:33:45,960 --> 00:33:47,220
modify the function pointer and

877
00:33:47,220 --> 00:33:48,960
also we are going to try to preserve  the

878
00:33:48,960 --> 00:33:51,500
rest of the data so as not to spit

879
00:33:51,500 --> 00:33:54,299
while trying to too current for the

880
00:33:54,299 --> 00:33:56,059
CNM state machine

881
00:33:56,059 --> 00:33:58,080
so now once we have

882
00:33:58,080 --> 00:34:01,260
code execution one of the rules of

883
00:34:01,260 --> 00:34:03,299
puntun is to prove that we have

884
00:34:03,299 --> 00:34:04,919
code execution so in the absence of being

885
00:34:04,919 --> 00:34:07,440
able to start a calculator or a

886
00:34:07,440 --> 00:34:09,719
shell so we fell back on the

887
00:34:09,719 --> 00:34:12,659
LCD screen and we said to ourselves that we were going to display

888
00:34:12,659 --> 00:34:14,839
an image on the LCD screen so for that

889
00:34:14,839 --> 00:34:18,119
it  had to find the address of the brake

890
00:34:18,119 --> 00:34:19,918
buffer so to find the address of the

891
00:34:19,918 --> 00:34:21,418
train buffer so when we started to

892
00:34:21,418 --> 00:34:22,918
analyze the end of the smell we

893
00:34:22,918 --> 00:34:25,679
found some strings which are connected

894
00:34:25,679 --> 00:34:28,619
to the LCD screen and looking at the

895
00:34:28,619 --> 00:34:30,839
functions  where are these strings referenced

896
00:34:30,839 --> 00:34:33,179
there we found this address which is x

897
00:34:33,179 --> 00:34:37,500
40 90 00 and we said to ourselves potentially

898
00:34:37,500 --> 00:34:39,480
this address is the frame buffer so

899
00:34:39,480 --> 00:34:41,280
to test that what we did is that

900
00:34:41,280 --> 00:34:43,500
we used the  command X the

901
00:34:43,500 --> 00:34:46,139
dryfel XM command to modify a few bytes

902
00:34:46,139 --> 00:34:47,699
at this address there and we

903
00:34:47,699 --> 00:34:50,399
realized that the upper left corner of

904
00:34:50,399 --> 00:34:52,619
the LCD screen has changed color so

905
00:34:52,619 --> 00:34:53,760
what there is confirms our hypothesis

906
00:34:53,760 --> 00:34:55,440
that this address there  well the address

907
00:34:55,440 --> 00:34:58,859
of the frame so from there we wrote

908
00:34:58,859 --> 00:35:01,740
a sheld which will consist of opening a

909
00:35:01,740 --> 00:35:04,080
socket on a server which is in Python

910
00:35:04,080 --> 00:35:06,599
which is based on stack this server there will

911
00:35:06,599 --> 00:35:09,480
distribute an image at the top and our

912
00:35:09,480 --> 00:35:12,480
code scale will  read from read from

913
00:35:12,480 --> 00:35:13,980
this sock and write to the frame

914
00:35:13,980 --> 00:35:16,079
buffer and all that in an infinite loop

915
00:35:16,079 --> 00:35:18,000


916
00:35:18,000 --> 00:35:21,440
the result is the following

917
00:35:29,220 --> 00:35:31,740
ok so to conclude now so

918
00:35:31,740 --> 00:35:34,380
it was our first participation in the

919
00:35:34,380 --> 00:35:36,359
contour not that of synactiv but the

920
00:35:36,359 --> 00:35:37,260
three of us it was our  first

921
00:35:37,260 --> 00:35:38,880
participation for everyone we

922
00:35:38,880 --> 00:35:40,440
had a lot of fun doing this

923
00:35:40,440 --> 00:35:42,000
competition there and we recommend it's

924
00:35:42,000 --> 00:35:44,520
not very complicated to do it

925
00:35:44,520 --> 00:35:47,220
in terms of prospects so there

926
00:35:47,220 --> 00:35:48,420
was recently a conference at

927
00:35:48,420 --> 00:35:51,480
hexacon which talked about having

928
00:35:51,480 --> 00:35:54,800
persistence on Lexmark printers

929
00:35:54,800 --> 00:35:57,060
we could imagine with

930
00:35:57,060 --> 00:35:58,200
additional efforts having the same thing on

931
00:35:58,200 --> 00:36:00,599
the Canon so that we could resist

932
00:36:00,599 --> 00:36:02,760
a reboot of the machine and

933
00:36:02,760 --> 00:36:05,040
possibly a possible firmware update

934
00:36:05,040 --> 00:36:07,140


935
00:36:07,140 --> 00:36:08,700
another act on which we could

936
00:36:08,700 --> 00:36:10,140
work today  'now

937
00:36:10,140 --> 00:36:12,420
when we run our Shu alcohol

938
00:36:12,420 --> 00:36:13,560
it runs in an infinite loop and the

939
00:36:13,560 --> 00:36:15,359
functionalities the printers it

940
00:36:15,359 --> 00:36:16,500
no longer works we can't print we

941
00:36:16,500 --> 00:36:18,060
can't do anything so another axis on

942
00:36:18,060 --> 00:36:19,380
which we could move forward is to

943
00:36:19,380 --> 00:36:21,260
work on the continuity of execution

944
00:36:21,260 --> 00:36:23,099
by trying for example to

945
00:36:23,099 --> 00:36:25,200
ensure that restoring the tenant

946
00:36:25,200 --> 00:36:27,960
and having our shelco run for example

947
00:36:27,960 --> 00:36:29,339
in a separate task so that

948
00:36:29,339 --> 00:36:30,839
we do not impact the rest of the

949
00:36:30,839 --> 00:36:33,000
operation of the printer

950
00:36:33,000 --> 00:36:35,220
another point there  see you soon the new

951
00:36:35,220 --> 00:36:36,540
edition in two or three weeks and

952
00:36:36,540 --> 00:36:39,480
the new edition of pountoon where the

953
00:36:39,480 --> 00:36:41,280
Canon is put back into play are we going to

954
00:36:41,280 --> 00:36:44,760
participate perhaps

955
00:36:46,280 --> 00:36:50,339
among all the tools we

956
00:36:50,339 --> 00:36:52,680
used developed during this

957
00:36:52,680 --> 00:36:55,440
research  they are on

958
00:36:55,440 --> 00:36:58,020
synactiv's GitHub repository so we have published the exploit

959
00:36:58,020 --> 00:37:01,200
which is in version 10.02 we also have

960
00:37:01,200 --> 00:37:04,140
published the Ida loader which allows you to

961
00:37:04,140 --> 00:37:06,359
boost bootstrap research and

962
00:37:06,359 --> 00:37:07,460
make a lot of tedious tasks easier

963
00:37:07,460 --> 00:37:10,020
when you start the analysis

964
00:37:10,020 --> 00:37:12,300
to reverse like that of the Canon and

965
00:37:12,300 --> 00:37:14,280
the scripts the various scripts like

966
00:37:14,280 --> 00:37:15,480
the script which makes it possible to rename the

967
00:37:15,480 --> 00:37:17,680
functions and to simplify the analysis

968
00:37:17,680 --> 00:37:20,280
[Music]

969
00:37:20,280 --> 00:37:21,980
a last point

970
00:37:21,980 --> 00:37:24,320
some references here

971
00:37:24,320 --> 00:37:27,480
which were useful to us which will be able to be useful

972
00:37:27,480 --> 00:37:29,040
for others which us  have kicked off

973
00:37:29,040 --> 00:37:32,700
the Canon printer search

974
00:37:32,700 --> 00:37:34,140
and I think that's about it

975
00:37:34,140 --> 00:37:35,820
for us if you have any questions we

976
00:37:35,820 --> 00:37:39,440
'll be happy to answer thanks

977
00:37:45,380 --> 00:37:48,869
[Applause]

978
00:37:55,500 --> 00:37:57,480
super interesting thank you very much just

979
00:37:57,480 --> 00:37:58,859
one question it took you about  nearly

980
00:37:58,859 --> 00:38:00,359
how long from when you

981
00:38:00,359 --> 00:38:02,339
got the Canon printer until

982
00:38:02,339 --> 00:38:04,320
you managed to put the image on the

983
00:38:04,320 --> 00:38:06,130
Canon

984
00:38:06,130 --> 00:38:08,520
[Music]

985
00:38:08,520 --> 00:38:10,680
in fact we didn't work in a

986
00:38:10,680 --> 00:38:13,320
linear way but compiled it all

987
00:38:13,320 --> 00:38:14,940
together  maybe it took us

988
00:38:14,940 --> 00:38:18,060
three weeks maybe but not we're

989
00:38:18,060 --> 00:38:21,060
never all day on it sometimes

990
00:38:21,060 --> 00:38:23,099
we work in the evening sometimes

991
00:38:23,099 --> 00:38:24,300
little half-days here and there but

992
00:38:24,300 --> 00:38:27,540
by putting everything together it

993
00:38:27,540 --> 00:38:29,839
seems  three weeks

994
00:38:29,839 --> 00:38:33,140
a little less maybe

995
00:38:40,800 --> 00:38:42,680
hi

996
00:38:42,680 --> 00:38:45,440
in the part

997
00:38:45,440 --> 00:38:48,180
i think you have you

998
00:38:48,180 --> 00:38:51,919
found the function of

999
00:38:53,060 --> 00:38:55,920
what is the use of implementing the

1000
00:38:55,920 --> 00:38:58,440
fiscation functions since a

1001
00:38:58,440 --> 00:38:59,599
protection

1002
00:38:59,599 --> 00:39:03,560
is a protection so

1003
00:39:03,560 --> 00:39:06,660
that the code is not  not visible to

1004
00:39:06,660 --> 00:39:09,060
everyone and you found the

1005
00:39:09,060 --> 00:39:13,800
deoxification function for the challenge from an

1006
00:39:13,800 --> 00:39:16,500
expertise point of view what is

1007
00:39:16,500 --> 00:39:18,300
the use for developers to

1008
00:39:18,300 --> 00:39:20,220
implement in fact we found the

1009
00:39:20,220 --> 00:39:21,960
bond function in the

1010
00:39:21,960 --> 00:39:24,599
bootloader code so in it  extracting

1011
00:39:24,599 --> 00:39:28,020
directly from memory and on the other hand

1012
00:39:28,020 --> 00:39:29,700
the firmware the update of the Farmer does

1013
00:39:29,700 --> 00:39:31,740
not contain this desofluation code and

1014
00:39:31,740 --> 00:39:33,780
this code is offended so a priori

1015
00:39:33,780 --> 00:39:35,880
the idea is rather for

1016
00:39:35,880 --> 00:39:38,400
updates typically not display not

1017
00:39:38,400 --> 00:39:40,440
have  the strings in clear which

1018
00:39:40,440 --> 00:39:41,700
could be finally here give a

1019
00:39:41,700 --> 00:39:44,160
lot of information to simply hide

1020
00:39:44,160 --> 00:39:47,780
the strings typically the code too and

1021
00:39:47,780 --> 00:39:50,460
simply slow down someone who

1022
00:39:50,460 --> 00:39:51,420
would just like to dig a little bit

1023
00:39:51,420 --> 00:39:54,000
without having a lot of expertise who will

1024
00:39:54,000 --> 00:39:55,859
just watch say bah  I don't see anything

1025
00:39:55,859 --> 00:39:58,440
interesting I won't be able to

1026
00:39:58,440 --> 00:40:00,140
do anything about it actually

1027
00:40:00,140 --> 00:40:02,760
clearly it didn't take us a lot

1028
00:40:02,760 --> 00:40:04,920
of time with the bootloader clearly

1029
00:40:04,920 --> 00:40:07,800
we were able to find it even other teams

1030
00:40:07,800 --> 00:40:09,599
were able to do a statistical analysis

1031
00:40:09,599 --> 00:40:11,240
to get past it

1032
00:40:11,240 --> 00:40:15,720
so it  is not an effective measure for

1033
00:40:15,720 --> 00:40:17,400
someone motivated but I think it

1034
00:40:17,400 --> 00:40:19,740
will block those who want to

1035
00:40:19,740 --> 00:40:21,780
look a little bit at extracting the

1036
00:40:21,780 --> 00:40:23,339
binary and see if there are strings of

1037
00:40:23,339 --> 00:40:24,780
particular keywords that may

1038
00:40:24,780 --> 00:40:26,220
interest them to try to  continue

1039
00:40:26,220 --> 00:40:28,020
more I think that's the point of

1040
00:40:28,020 --> 00:40:30,680
this function okay

1041
00:40:30,960 --> 00:40:33,560
thank you

1042
00:40:38,460 --> 00:40:41,280
but suddenly they like a

1043
00:40:41,280 --> 00:40:42,599
more cassation function but they don't put any

1044
00:40:42,599 --> 00:40:44,579
protection on the binaries so I do

1045
00:40:44,579 --> 00:40:46,140
n't know if you were able to exchange with

1046
00:40:46,140 --> 00:40:49,320
them and  if they said well yes we do

1047
00:40:49,320 --> 00:40:50,520
officecation to hide the thing a bit

1048
00:40:50,520 --> 00:40:51,960
but at the same time we leave the

1049
00:40:51,960 --> 00:40:54,140
binary open bar so

1050
00:40:54,140 --> 00:40:58,260
there is still one in the next to

1051
00:40:58,260 --> 00:41:00,599
NCA blocks there are blocks of

1052
00:41:00,599 --> 00:41:03,140
signatures that will be associated with these

1053
00:41:03,140 --> 00:41:06,599
different blocks NCA we did not find either

1054
00:41:06,599 --> 00:41:09,359
not particularly looked for the

1055
00:41:09,359 --> 00:41:10,500
cryptographic verification that was

1056
00:41:10,500 --> 00:41:12,359
done at this level but a priori there

1057
00:41:12,359 --> 00:41:13,380
is still a signature associated with

1058
00:41:13,380 --> 00:41:15,540
each of the blocks so we cannot

1059
00:41:15,540 --> 00:41:17,099
modify a priori we cannot

1060
00:41:17,099 --> 00:41:18,839
modify its blocks we cannot modify

1061
00:41:18,839 --> 00:41:21,119
the firmware and install it on a

1062
00:41:21,119 --> 00:41:25,520
printer arbitrarily without problem

1063
00:41:35,480 --> 00:41:37,760
hello

1064
00:41:37,760 --> 00:41:40,020
precisely my question was about these

1065
00:41:40,020 --> 00:41:41,420
signatures

1066
00:41:41,420 --> 00:41:43,440
what kind are they of

1067
00:41:43,440 --> 00:41:45,000
is-  what it's just a

1068
00:41:45,000 --> 00:41:46,520
checkton or

1069
00:41:46,520 --> 00:41:49,460
a

1070
00:41:49,460 --> 00:41:52,440
memory path it was cat 256 and I

1071
00:41:52,440 --> 00:41:53,220
think it wasn't even a long way

1072
00:41:53,220 --> 00:41:55,500
so indeed there is surely

1073
00:41:55,500 --> 00:41:56,359
something to do to

1074
00:41:56,359 --> 00:41:59,099
do things after I have more

1075
00:41:59,099 --> 00:42:00,960
precisely  in mind the whole

1076
00:42:00,960 --> 00:42:02,060
package

1077
00:42:02,060 --> 00:42:03,720
it seems to me that there were still

1078
00:42:03,720 --> 00:42:05,760
potentially other signatures to

1079
00:42:05,760 --> 00:42:07,200
dig up because I don't have all that in

1080
00:42:07,200 --> 00:42:09,780
mind anymore but actually that

1081
00:42:09,780 --> 00:42:11,700
suggests who would surely have if we

1082
00:42:11,700 --> 00:42:13,800
really want to typically

1083
00:42:13,800 --> 00:42:15,780
persist  that it would clearly be a

1084
00:42:15,780 --> 00:42:19,260
track to dig in order to exploit

1085
00:42:19,260 --> 00:42:21,060
something on this side as much

1086
00:42:21,060 --> 00:42:23,640
Doom player on it directly perhaps in the

1087
00:42:23,640 --> 00:42:26,420
long term perhaps

1088
00:42:29,160 --> 00:42:31,440
hello very interesting I have a small

1089
00:42:31,440 --> 00:42:33,540
question beyond fixing this city there

1090
00:42:33,540 --> 00:42:35,160
what you  have made

1091
00:42:35,160 --> 00:42:37,020
more general recommendations to canon

1092
00:42:37,020 --> 00:42:39,599
to improve the status quo and

1093
00:42:39,599 --> 00:42:41,700
perhaps improve if their other

1094
00:42:41,700 --> 00:42:43,320
devices which obviously use the

1095
00:42:43,320 --> 00:42:45,440
same system

1096
00:42:46,980 --> 00:42:48,420
in fact we did not communicate

1097
00:42:48,420 --> 00:42:50,040
directly with canon in fact in the

1098
00:42:50,040 --> 00:42:51,599
context of participation in the  point toon

1099
00:42:51,599 --> 00:42:53,160
we communicate with the

1100
00:42:53,160 --> 00:42:55,940
ZI teams who behind them are going to

1101
00:42:55,940 --> 00:42:58,380
work with canon after us we have

1102
00:42:58,380 --> 00:43:00,300
n't we haven't worked with them on the

1103
00:43:00,300 --> 00:43:03,380
countermeasure part

1104
00:43:05,760 --> 00:43:07,560
if they listen to us and who are ready to

1105
00:43:07,560 --> 00:43:09,060
work with us we we  is willing to

1106
00:43:09,060 --> 00:43:11,480
work with them anyway

1107
00:43:38,180 --> 00:43:40,400
than

1108
00:43:40,400 --> 00:43:43,800
more than process because the all share

1109
00:43:43,800 --> 00:43:48,180
like the same memoryton

