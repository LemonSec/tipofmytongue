1
00:00:02,820 --> 00:00:06,540
coming so first of all um I'm Silva

2
00:00:06,540 --> 00:00:08,700
pelicia I'm a security researcher at

3
00:00:08,700 --> 00:00:10,280
kudelski security

4
00:00:10,280 --> 00:00:12,780
most of my work is on applied

5
00:00:12,780 --> 00:00:14,280
cryptography project

6
00:00:14,280 --> 00:00:16,320
I used to do Hardware attacks in the

7
00:00:16,320 --> 00:00:19,320
past and sometimes I I do last minute

8
00:00:19,320 --> 00:00:21,300
talks like today

9
00:00:21,300 --> 00:00:24,300
and I will let I will let Nicola present

10
00:00:24,300 --> 00:00:26,660
himself

11
00:00:26,880 --> 00:00:31,080
so I'm Nicola barley I do embedded

12
00:00:31,080 --> 00:00:34,079
system security evaluations as a day job

13
00:00:34,079 --> 00:00:36,780
how to attacks in the evening so it's

14
00:00:36,780 --> 00:00:39,140
basically the same but cheaper

15
00:00:39,140 --> 00:00:43,020
uh I am also co-organize uh black Alps

16
00:00:43,020 --> 00:00:45,660
so I really enjoyed to see all the

17
00:00:45,660 --> 00:00:47,340
people here thank you very much for

18
00:00:47,340 --> 00:00:48,660
being here

19
00:00:48,660 --> 00:00:50,760
I also work on open source projects

20
00:00:50,760 --> 00:00:52,980
related to how to attacks like Hydro bus

21
00:00:52,980 --> 00:00:55,620
and as he said I'm also the last minute

22
00:00:55,620 --> 00:00:58,399
speaker here

23
00:00:58,500 --> 00:00:59,940
so

24
00:00:59,940 --> 00:01:02,699
we started this project a long time ago

25
00:01:02,699 --> 00:01:05,760
now A friend of mine got really excited

26
00:01:05,760 --> 00:01:08,520
with a new microcontroller with a lot of

27
00:01:08,520 --> 00:01:11,820
high-speed interfaces uh debugging

28
00:01:11,820 --> 00:01:14,820
interface it was a risk 5 MCU etc etc

29
00:01:14,820 --> 00:01:17,159
but the thing that's really interested

30
00:01:17,159 --> 00:01:18,299
me was

31
00:01:18,299 --> 00:01:21,360
this part here with the encryption as it

32
00:01:21,360 --> 00:01:23,759
says a yes we know every everybody knows

33
00:01:23,759 --> 00:01:27,240
this but sm4 and this I had absolutely

34
00:01:27,240 --> 00:01:28,619
no idea

35
00:01:28,619 --> 00:01:31,259
so what I did first is Google for it of

36
00:01:31,259 --> 00:01:32,460
course

37
00:01:32,460 --> 00:01:34,920
and Wikipedia tells us that it's a block

38
00:01:34,920 --> 00:01:37,020
Cipher used in the Chinese National

39
00:01:37,020 --> 00:01:39,540
Standard blah blah blah blah

40
00:01:39,540 --> 00:01:43,140
so it's a it's an encryption algorithm

41
00:01:43,140 --> 00:01:46,619
that I've never heard about so I started

42
00:01:46,619 --> 00:01:49,500
to look for the papers that describe the

43
00:01:49,500 --> 00:01:50,720
algorithm

44
00:01:50,720 --> 00:01:53,579
implementations in C in python or

45
00:01:53,579 --> 00:01:54,840
something else

46
00:01:54,840 --> 00:01:58,259
but couldn't find lots of uh published

47
00:01:58,259 --> 00:02:00,360
attacks and tools

48
00:02:00,360 --> 00:02:03,180
so unfortunately for me I'm not that

49
00:02:03,180 --> 00:02:06,659
good at math neither at crypto so I

50
00:02:06,659 --> 00:02:08,280
looked at the C implementation to

51
00:02:08,280 --> 00:02:10,380
understand exactly what happens

52
00:02:10,380 --> 00:02:12,780
and unfortunately all the papers about

53
00:02:12,780 --> 00:02:15,360
the attacks on this algorithm look like

54
00:02:15,360 --> 00:02:17,580
Chinese to me but literally because most

55
00:02:17,580 --> 00:02:20,220
of them are written in Chinese directly

56
00:02:20,220 --> 00:02:21,420
in Chinese

57
00:02:21,420 --> 00:02:24,720
so in order to get further information

58
00:02:24,720 --> 00:02:27,239
about this I needed a crypto guide so

59
00:02:27,239 --> 00:02:29,340
that's why I asked Silva to help me on

60
00:02:29,340 --> 00:02:31,700
this project

61
00:02:34,739 --> 00:02:37,560
so I I didn't know that black Cipher

62
00:02:37,560 --> 00:02:40,800
before but I I had a look uh so I

63
00:02:40,800 --> 00:02:42,239
figured out that yeah it's a it's a

64
00:02:42,239 --> 00:02:45,260
standard by People's Republic of China

65
00:02:45,260 --> 00:02:49,019
uh hopefully there is a draft available

66
00:02:49,019 --> 00:02:51,239
um ietf draft available in English so

67
00:02:51,239 --> 00:02:53,519
it's very helpful to to understand the

68
00:02:53,519 --> 00:02:57,120
algorithm so basically it takes a key of

69
00:02:57,120 --> 00:03:01,200
128 bits uh the encryption is composed

70
00:03:01,200 --> 00:03:04,019
of 32 runs and most of the operation

71
00:03:04,019 --> 00:03:08,040
inside the Run are 32-bit done on

72
00:03:08,040 --> 00:03:10,920
32-bits world and we figure out that

73
00:03:10,920 --> 00:03:12,959
it's indeed interesting to study this

74
00:03:12,959 --> 00:03:14,819
algorithm because it's more and more

75
00:03:14,819 --> 00:03:18,180
deployed in practice in fact now in arm

76
00:03:18,180 --> 00:03:22,860
since version 8.4 uh there is a hardware

77
00:03:22,860 --> 00:03:25,879
instruction to perform this encryption

78
00:03:25,879 --> 00:03:29,659
even as well for risk 5

79
00:03:29,659 --> 00:03:32,459
cryptography extension and more and more

80
00:03:32,459 --> 00:03:34,200
in system and ship we have Hardware

81
00:03:34,200 --> 00:03:36,840
accelerators like the one Nikola showed

82
00:03:36,840 --> 00:03:39,480
before and it happened that sometimes

83
00:03:39,480 --> 00:03:41,220
it's even mandatory to have this

84
00:03:41,220 --> 00:03:42,959
algorithm if you want to deploy your

85
00:03:42,959 --> 00:03:46,440
product in uh in China

86
00:03:46,440 --> 00:03:51,000
uh so now the the algorithm itself so it

87
00:03:51,000 --> 00:03:53,459
like yes it use a key schedule which is

88
00:03:53,459 --> 00:03:57,319
invertible to produce 36 front keys

89
00:03:57,319 --> 00:04:00,360
it's computed from some constant CK and

90
00:04:00,360 --> 00:04:05,700
FK uh the first uh the first round keys

91
00:04:05,700 --> 00:04:09,420
are with the constant FK we don't know

92
00:04:09,420 --> 00:04:13,620
why but just because and uh and then uh

93
00:04:13,620 --> 00:04:17,399
it will produce the other run keys and

94
00:04:17,399 --> 00:04:20,100
like for as there is relation between

95
00:04:20,100 --> 00:04:22,380
each servant key so it's possible to

96
00:04:22,380 --> 00:04:24,780
identify them in in memory uh if there

97
00:04:24,780 --> 00:04:26,040
is a key schedule

98
00:04:26,040 --> 00:04:28,680
I will come back to that later

99
00:04:28,680 --> 00:04:31,199
so the key schedule is uh quite simple

100
00:04:31,199 --> 00:04:34,560
it's a face Style Network so all the

101
00:04:34,560 --> 00:04:38,180
capital uh cases letter are 32-bits Road

102
00:04:38,180 --> 00:04:42,240
and so at each run we produce only one

103
00:04:42,240 --> 00:04:45,120
new round key here the other one are

104
00:04:45,120 --> 00:04:48,500
shifted on the left

105
00:04:49,320 --> 00:04:54,479
then a run for sm4 so uh it the the

106
00:04:54,479 --> 00:04:58,320
algorithm work on 128-bit State

107
00:04:58,320 --> 00:05:01,100
the first state is a plain text itself

108
00:05:01,100 --> 00:05:04,380
and it will work on this uh C State the

109
00:05:04,380 --> 00:05:05,759
only difference between encryption and

110
00:05:05,759 --> 00:05:07,259
decryption is the order of the of the

111
00:05:07,259 --> 00:05:09,840
wrong Keys how they are used

112
00:05:09,840 --> 00:05:13,320
and one run is uh perform I mean it's

113
00:05:13,320 --> 00:05:15,840
similar to uh to the key schedule only

114
00:05:15,840 --> 00:05:17,759
the key function is a bit different here

115
00:05:17,759 --> 00:05:20,880
I will go into the detail after and we

116
00:05:20,880 --> 00:05:23,639
have the state X which are input here

117
00:05:23,639 --> 00:05:25,500
and the Run key we have generated with

118
00:05:25,500 --> 00:05:27,840
the with the key schedule before

119
00:05:27,840 --> 00:05:30,720
and again we produce only 32 bits one

120
00:05:30,720 --> 00:05:34,080
word of State at each one

121
00:05:34,080 --> 00:05:37,020
so now this is the T function so now

122
00:05:37,020 --> 00:05:40,500
lowercase letter are byte not word

123
00:05:40,500 --> 00:05:42,960
anymore so each byte is start with the

124
00:05:42,960 --> 00:05:46,320
wrong key byte then uh it goes to the s

125
00:05:46,320 --> 00:05:48,720
box and then to the L function and we

126
00:05:48,720 --> 00:05:50,880
have the output

127
00:05:50,880 --> 00:05:53,039
so the L function is basically used for

128
00:05:53,039 --> 00:05:56,699
diffusion to diffuse the bits among the

129
00:05:56,699 --> 00:05:59,699
the full world and the s-box are 8-bit

130
00:05:59,699 --> 00:06:02,520
input and 8-bit output and the

131
00:06:02,520 --> 00:06:04,979
construction is similar to AES it's

132
00:06:04,979 --> 00:06:06,600
based on affin transformation and

133
00:06:06,600 --> 00:06:07,979
inverse

134
00:06:07,979 --> 00:06:10,979
and one thing uh to have in mind which

135
00:06:10,979 --> 00:06:14,940
is not really important but the output

136
00:06:14,940 --> 00:06:16,680
of the black Cipher at the end is

137
00:06:16,680 --> 00:06:19,919
reverse so the ciphertext is uh the

138
00:06:19,919 --> 00:06:23,280
reverse of the of the states uh so it

139
00:06:23,280 --> 00:06:25,620
does not change anything to attacks but

140
00:06:25,620 --> 00:06:27,660
it can make you lose a lot of time in

141
00:06:27,660 --> 00:06:31,819
practice when you debug your neurotype

142
00:06:31,919 --> 00:06:33,539
so the first thing we've implemented

143
00:06:33,539 --> 00:06:35,780
during this project is the Yahoo rule to

144
00:06:35,780 --> 00:06:38,340
identify inner firmware

145
00:06:38,340 --> 00:06:42,000
if there is a sm4 so we are searching

146
00:06:42,000 --> 00:06:45,360
for the constant FK and CK which are

147
00:06:45,360 --> 00:06:47,400
coded usually in software

148
00:06:47,400 --> 00:06:50,699
also for the s-boxes and it can help you

149
00:06:50,699 --> 00:06:52,199
to identify in a firmware if you have

150
00:06:52,199 --> 00:06:55,139
sm4 implementation or not

151
00:06:55,139 --> 00:06:57,780
then I as I explain the key schedule

152
00:06:57,780 --> 00:07:01,319
service relation in between all the Run

153
00:07:01,319 --> 00:07:04,860
keys so we've implemented those key

154
00:07:04,860 --> 00:07:06,660
scale I mean the research for his

155
00:07:06,660 --> 00:07:08,759
schedule in radar 2 so it was already

156
00:07:08,759 --> 00:07:11,639
existing for as and we have just added

157
00:07:11,639 --> 00:07:14,400
the support for sm4 so if you have a

158
00:07:14,400 --> 00:07:16,860
memory damp of a new thing there is a

159
00:07:16,860 --> 00:07:18,960
key schedule of sm4 you can just use

160
00:07:18,960 --> 00:07:21,180
this command to to search and it will

161
00:07:21,180 --> 00:07:26,180
output uh the the Run keys

162
00:07:26,520 --> 00:07:28,979
so now for Hardware attack basically

163
00:07:28,979 --> 00:07:31,139
there is two possible approach so such

164
00:07:31,139 --> 00:07:34,860
Channel analysis and fault analysis and

165
00:07:34,860 --> 00:07:37,860
we are two so we splitted the work like

166
00:07:37,860 --> 00:07:39,120
that

167
00:07:39,120 --> 00:07:41,039
we started to study the software

168
00:07:41,039 --> 00:07:42,599
implementation because usually it's

169
00:07:42,599 --> 00:07:45,180
easier to apply a hardware attack on

170
00:07:45,180 --> 00:07:47,400
that and then we move to a hardware

171
00:07:47,400 --> 00:07:49,560
implementation

172
00:07:49,560 --> 00:07:51,840
so for the first part it was a Nicolas

173
00:07:51,840 --> 00:07:56,419
part so I will let him speak about that

174
00:07:58,919 --> 00:08:01,080
so for those who don't know what side

175
00:08:01,080 --> 00:08:04,620
Channel analysis is the idea is to

176
00:08:04,620 --> 00:08:07,139
deploy techniques to recover the secret

177
00:08:07,139 --> 00:08:10,319
key based on some kind of leakage that

178
00:08:10,319 --> 00:08:12,240
is produced during the computation of

179
00:08:12,240 --> 00:08:14,220
either the encryption or the decryption

180
00:08:14,220 --> 00:08:15,599
of the algorithm

181
00:08:15,599 --> 00:08:17,340
so this can either be the power

182
00:08:17,340 --> 00:08:19,379
consumption of the device encrypting

183
00:08:19,379 --> 00:08:23,160
data electromagnetic emissions timing

184
00:08:23,160 --> 00:08:24,479
etc etc

185
00:08:24,479 --> 00:08:27,720
this technique is well known mostly for

186
00:08:27,720 --> 00:08:30,060
AES there are a lot of various papers

187
00:08:30,060 --> 00:08:32,279
and open source tools to attack AES

188
00:08:32,279 --> 00:08:35,159
using side Channel analysis

189
00:08:35,159 --> 00:08:38,039
but unfortunately for sm4 there was

190
00:08:38,039 --> 00:08:40,440
absolutely none we found some papers

191
00:08:40,440 --> 00:08:42,000
again in Chinese

192
00:08:42,000 --> 00:08:45,360
about this but no public tool to attack

193
00:08:45,360 --> 00:08:47,100
sm4

194
00:08:47,100 --> 00:08:49,140
using side channels

195
00:08:49,140 --> 00:08:51,420
so first of all what we need to do is

196
00:08:51,420 --> 00:08:53,160
get some traces

197
00:08:53,160 --> 00:08:56,339
so what I did is I took sm4

198
00:08:56,339 --> 00:08:58,320
implementation in C

199
00:08:58,320 --> 00:09:02,040
built a small firmware on an esp32 so

200
00:09:02,040 --> 00:09:04,260
those small microcontrollers that you

201
00:09:04,260 --> 00:09:08,040
had on the Black Ops badge before

202
00:09:08,040 --> 00:09:10,740
run the acquisition so I basically ask

203
00:09:10,740 --> 00:09:13,500
the firmware to encrypt some plain texts

204
00:09:13,500 --> 00:09:15,720
and give me the output and while it's

205
00:09:15,720 --> 00:09:18,600
doing the computation I will record all

206
00:09:18,600 --> 00:09:20,820
the power consumption of the device

207
00:09:20,820 --> 00:09:25,440
and what I did is I took 50 000 average

208
00:09:25,440 --> 00:09:29,959
traces and each Trace is a 100

209
00:09:29,959 --> 00:09:33,060
encryptions that means I did 50 million

210
00:09:33,060 --> 00:09:34,920
encryptions just to get

211
00:09:34,920 --> 00:09:37,140
this kind of graphs

212
00:09:37,140 --> 00:09:39,300
doesn't look really impressive honestly

213
00:09:39,300 --> 00:09:41,399
but what you can see here is that you

214
00:09:41,399 --> 00:09:43,620
have a repeating pattern

215
00:09:43,620 --> 00:09:46,560
and if you count them you have 32 of

216
00:09:46,560 --> 00:09:49,380
them means that the CPU does something

217
00:09:49,380 --> 00:09:54,060
32 times and as Silva explained sm4 is a

218
00:09:54,060 --> 00:09:56,459
32 round algorithm

219
00:09:56,459 --> 00:09:59,519
just for clarification I show here the

220
00:09:59,519 --> 00:10:02,100
first round that is done here the second

221
00:10:02,100 --> 00:10:04,260
round is done here third one is here

222
00:10:04,260 --> 00:10:06,540
fourth one is here blah blah blah up

223
00:10:06,540 --> 00:10:10,820
until the last round which is right here

224
00:10:10,820 --> 00:10:13,740
so once I have those traces what I need

225
00:10:13,740 --> 00:10:16,740
to do is Implement a library to analyze

226
00:10:16,740 --> 00:10:19,560
those traces and try to to recover the

227
00:10:19,560 --> 00:10:20,760
encryption key

228
00:10:20,760 --> 00:10:23,640
so I either have the choice to build a

229
00:10:23,640 --> 00:10:26,399
new tool or use an existing library and

230
00:10:26,399 --> 00:10:28,560
implement the support for sm4 and that's

231
00:10:28,560 --> 00:10:31,620
exactly what I did using a library which

232
00:10:31,620 --> 00:10:34,620
is called scared made by eshat

233
00:10:34,620 --> 00:10:37,740
I chose this one because the code was

234
00:10:37,740 --> 00:10:39,420
really clean there was a lot of

235
00:10:39,420 --> 00:10:41,940
documentation the code base is open

236
00:10:41,940 --> 00:10:43,680
source of course

237
00:10:43,680 --> 00:10:46,800
and most of most of all it's written in

238
00:10:46,800 --> 00:10:49,680
Python so it's way easier for me to add

239
00:10:49,680 --> 00:10:51,240
support for that

240
00:10:51,240 --> 00:10:54,600
so I first started to implement the

241
00:10:54,600 --> 00:10:58,320
whole sm4 algorithm in Python to be used

242
00:10:58,320 --> 00:11:00,899
in that library that means I had to uh

243
00:11:00,899 --> 00:11:03,000
play along with the

244
00:11:03,000 --> 00:11:05,000
um

245
00:11:05,540 --> 00:11:09,240
various python libraries just to get the

246
00:11:09,240 --> 00:11:11,880
right inputs do the computation get the

247
00:11:11,880 --> 00:11:13,160
right outputs

248
00:11:13,160 --> 00:11:16,800
work with a batches of a hundreds or

249
00:11:16,800 --> 00:11:19,380
thousands of traces

250
00:11:19,380 --> 00:11:20,940
etc etc

251
00:11:20,940 --> 00:11:23,339
what I also did is add some helper

252
00:11:23,339 --> 00:11:26,459
functions that will help the analysts to

253
00:11:26,459 --> 00:11:28,920
play with the traces so I implemented

254
00:11:28,920 --> 00:11:31,160
both the forward

255
00:11:31,160 --> 00:11:33,740
functions so you saw the T function

256
00:11:33,740 --> 00:11:36,839
presented by silver I implemented also

257
00:11:36,839 --> 00:11:40,260
the reverse T functions reverse all the

258
00:11:40,260 --> 00:11:42,720
the algorithm can be done in Reverse as

259
00:11:42,720 --> 00:11:44,899
well

260
00:11:45,480 --> 00:11:48,240
then once I have this algorithm what I

261
00:11:48,240 --> 00:11:50,519
need to do is create what we call

262
00:11:50,519 --> 00:11:52,560
selection functions that means a

263
00:11:52,560 --> 00:11:55,620
function that can tell you okay so if

264
00:11:55,620 --> 00:11:57,240
the key is

265
00:11:57,240 --> 00:11:59,880
a specific value then during the

266
00:11:59,880 --> 00:12:02,399
computation it will use that much power

267
00:12:02,399 --> 00:12:04,200
more or less

268
00:12:04,200 --> 00:12:07,920
and this will be used to calculate the

269
00:12:07,920 --> 00:12:10,380
estimated consumption for all the

270
00:12:10,380 --> 00:12:12,420
possible key candidates

271
00:12:12,420 --> 00:12:15,240
and this will then be applied during the

272
00:12:15,240 --> 00:12:17,399
attack to see if there was one match

273
00:12:17,399 --> 00:12:19,380
during the computation to find the

274
00:12:19,380 --> 00:12:21,860
correct key

275
00:12:21,959 --> 00:12:25,440
so uh pretty much like AES what I did is

276
00:12:25,440 --> 00:12:28,140
I took the output of the s-box so the

277
00:12:28,140 --> 00:12:31,019
value that is computed right here

278
00:12:31,019 --> 00:12:33,600
it's a good candidate because we know

279
00:12:33,600 --> 00:12:36,240
the input because it's the plain text

280
00:12:36,240 --> 00:12:39,240
that we provided to the firmware

281
00:12:39,240 --> 00:12:42,660
and we can compute the estimated value

282
00:12:42,660 --> 00:12:45,959
of the output here based on key

283
00:12:45,959 --> 00:12:48,899
candidates that we can select so we will

284
00:12:48,899 --> 00:12:51,000
calculate the value the output value if

285
00:12:51,000 --> 00:12:55,019
the key is zero if the key is 1 2 3 etc

286
00:12:55,019 --> 00:12:58,440
etc for the whole uh the all the values

287
00:12:58,440 --> 00:13:00,600
all the possible values of these key

288
00:13:00,600 --> 00:13:02,940
bytes then do the same for this key by

289
00:13:02,940 --> 00:13:05,040
do the same for this key by this then do

290
00:13:05,040 --> 00:13:07,260
the same for this one well that's a huge

291
00:13:07,260 --> 00:13:10,260
table in the end and then this will be

292
00:13:10,260 --> 00:13:13,320
provided directly to the scared Library

293
00:13:13,320 --> 00:13:15,600
which does all the computation for you

294
00:13:15,600 --> 00:13:18,120
in the end to try to find if there was

295
00:13:18,120 --> 00:13:21,360
one match uh in the trace that matches

296
00:13:21,360 --> 00:13:24,300
one of your key candidates

297
00:13:24,300 --> 00:13:26,639
so the helper function takes the plain

298
00:13:26,639 --> 00:13:29,579
text inputs and provides you with four

299
00:13:29,579 --> 00:13:32,160
different byte values that could be the

300
00:13:32,160 --> 00:13:34,260
guess

301
00:13:34,260 --> 00:13:37,019
and if you do the small code that is

302
00:13:37,019 --> 00:13:39,240
here so what I did is I used the scare

303
00:13:39,240 --> 00:13:40,320
Library

304
00:13:40,320 --> 00:13:43,380
tell it to use my selection function

305
00:13:43,380 --> 00:13:45,720
that I did so the calculate the output

306
00:13:45,720 --> 00:13:46,980
of the s-box

307
00:13:46,980 --> 00:13:49,860
and then try to find in the whole traces

308
00:13:49,860 --> 00:13:53,339
if for one key candidate there is a

309
00:13:53,339 --> 00:13:55,920
correlation value that is higher than

310
00:13:55,920 --> 00:13:58,500
the average and if you look at the

311
00:13:58,500 --> 00:14:01,440
output here for the whole traces my

312
00:14:01,440 --> 00:14:04,440
correlation value is quite low here but

313
00:14:04,440 --> 00:14:06,860
at some point you just have

314
00:14:06,860 --> 00:14:10,220
one huge Spike there's only one value

315
00:14:10,220 --> 00:14:12,899
that rises above the rest

316
00:14:12,899 --> 00:14:15,660
and fortunately for me this is the

317
00:14:15,660 --> 00:14:18,839
correct key byte that that is used for

318
00:14:18,839 --> 00:14:21,899
the computation so that way I was able

319
00:14:21,899 --> 00:14:24,420
to recover at least one byte of the

320
00:14:24,420 --> 00:14:26,399
round key for the first round

321
00:14:26,399 --> 00:14:28,019
it's already good

322
00:14:28,019 --> 00:14:30,060
I did the same for the four other key

323
00:14:30,060 --> 00:14:33,899
bytes and was able to recover a one

324
00:14:33,899 --> 00:14:37,440
round key of uh the sm4 algorithm

325
00:14:37,440 --> 00:14:39,000
unfortunately

326
00:14:39,000 --> 00:14:42,060
for the sm4 algorithm to recover the

327
00:14:42,060 --> 00:14:44,279
master key you need four consecutive

328
00:14:44,279 --> 00:14:47,519
round keys that means that my attack for

329
00:14:47,519 --> 00:14:49,440
the first round key needs to be done

330
00:14:49,440 --> 00:14:52,980
again but for the next round

331
00:14:52,980 --> 00:14:55,019
as Silva mentioned the next round is

332
00:14:55,019 --> 00:14:58,500
calculated based on the first key so I

333
00:14:58,500 --> 00:15:01,680
need to do exactly the same here but I

334
00:15:01,680 --> 00:15:04,139
just need to add one particular line

335
00:15:04,139 --> 00:15:06,380
that I uh implemented in the library

336
00:15:06,380 --> 00:15:09,480
just to say that with the plain text I

337
00:15:09,480 --> 00:15:11,880
have now that I know the first round key

338
00:15:11,880 --> 00:15:15,180
K1 here I just need to forward one round

339
00:15:15,180 --> 00:15:18,600
so the library will calculate the next

340
00:15:18,600 --> 00:15:23,940
uh the next words for the the round and

341
00:15:23,940 --> 00:15:26,160
then we'll do the exact same attack so

342
00:15:26,160 --> 00:15:28,139
calculates the

343
00:15:28,139 --> 00:15:32,220
uh the potential keys for the Xbox

344
00:15:32,220 --> 00:15:34,800
output for the second round

345
00:15:34,800 --> 00:15:38,339
and if we do that again you will see

346
00:15:38,339 --> 00:15:41,160
pretty much the same kind of spikes but

347
00:15:41,160 --> 00:15:43,199
for the next round that means that

348
00:15:43,199 --> 00:15:45,600
during this attack four times you will

349
00:15:45,600 --> 00:15:47,519
get the second round key then you have

350
00:15:47,519 --> 00:15:49,560
to do the same again for the third round

351
00:15:49,560 --> 00:15:51,480
then the fourth round

352
00:15:51,480 --> 00:15:54,420
and if you have all four rounds

353
00:15:54,420 --> 00:15:57,839
what you can do then is revert the key

354
00:15:57,839 --> 00:16:00,540
schedule and then get back the master

355
00:16:00,540 --> 00:16:02,880
key which is shown here

356
00:16:02,880 --> 00:16:05,060
foreign

357
00:16:05,279 --> 00:16:08,160
I also did the same because the

358
00:16:08,160 --> 00:16:10,320
algorithm is exactly the same for all

359
00:16:10,320 --> 00:16:12,000
the rounds that means that you can do

360
00:16:12,000 --> 00:16:14,579
the same if you know the the output of

361
00:16:14,579 --> 00:16:16,860
the algorithm you can do the same attack

362
00:16:16,860 --> 00:16:20,160
but in Reverse based on the output and

363
00:16:20,160 --> 00:16:23,100
try to find the input of the s-box and

364
00:16:23,100 --> 00:16:24,779
do the same but for the last round

365
00:16:24,779 --> 00:16:27,660
instead of the first ones

366
00:16:27,660 --> 00:16:30,180
one thing that I I had a lot of trouble

367
00:16:30,180 --> 00:16:33,180
I spent like literally one night to find

368
00:16:33,180 --> 00:16:35,940
this error Sylvan told you that the

369
00:16:35,940 --> 00:16:38,699
output is revert right so for the whole

370
00:16:38,699 --> 00:16:41,399
night I tried to find correlation on the

371
00:16:41,399 --> 00:16:44,339
algorithm and couldn't find any any

372
00:16:44,339 --> 00:16:47,459
correct uh correlation until I added

373
00:16:47,459 --> 00:16:50,279
this simple flip call which basically

374
00:16:50,279 --> 00:16:53,519
does the inverts of the output which is

375
00:16:53,519 --> 00:16:55,620
in the norm but I forgot about this and

376
00:16:55,620 --> 00:16:58,170
lost one night on this

377
00:16:58,170 --> 00:16:59,279
[Music]

378
00:16:59,279 --> 00:17:03,680
so I can show you a small demo of that

379
00:17:03,839 --> 00:17:07,079
oh that's not this one

380
00:17:07,079 --> 00:17:09,260
foreign

381
00:17:11,099 --> 00:17:14,040
hopefully you will see

382
00:17:14,040 --> 00:17:16,199
the choices here

383
00:17:16,199 --> 00:17:19,760
so now it loads my library

384
00:17:20,339 --> 00:17:23,160
do the first attack on the first round

385
00:17:23,160 --> 00:17:26,459
of the algorithm what I did is just to

386
00:17:26,459 --> 00:17:29,220
to be a bit faster I

387
00:17:29,220 --> 00:17:31,140
um I don't do the the attack on the

388
00:17:31,140 --> 00:17:33,480
whole Trace but only on the the first

389
00:17:33,480 --> 00:17:35,700
slide so only on those points which

390
00:17:35,700 --> 00:17:38,400
already takes a lot of time but if I run

391
00:17:38,400 --> 00:17:40,260
this

392
00:17:40,260 --> 00:17:43,520
and graph the output

393
00:17:48,900 --> 00:17:50,520
you will see that for the first round

394
00:17:50,520 --> 00:17:53,940
for the first key byte you will just see

395
00:17:53,940 --> 00:17:56,940
one value Rising Above the Rest

396
00:17:56,940 --> 00:17:59,640
for the second key byte only one value

397
00:17:59,640 --> 00:18:01,799
Rising above the third one the fourth

398
00:18:01,799 --> 00:18:03,600
one etc etc

399
00:18:03,600 --> 00:18:06,000
it's the correct one and we can do the

400
00:18:06,000 --> 00:18:09,120
same for the second Xbox so again I'm

401
00:18:09,120 --> 00:18:11,940
using the value I found for the first

402
00:18:11,940 --> 00:18:13,799
round

403
00:18:13,799 --> 00:18:18,480
apply on the next round so I take the

404
00:18:18,480 --> 00:18:21,059
input calculate the first round output

405
00:18:21,059 --> 00:18:23,640
then do the same attack for the second

406
00:18:23,640 --> 00:18:26,520
round and again

407
00:18:26,520 --> 00:18:28,620
it will show me just one value Rising

408
00:18:28,620 --> 00:18:32,220
Above the Rest for all the key bytes

409
00:18:32,220 --> 00:18:34,200
and

410
00:18:34,200 --> 00:18:36,840
of course it works for the for the

411
00:18:36,840 --> 00:18:40,699
others otherwise I wouldn't do the demo

412
00:18:43,020 --> 00:18:46,820
you will see the same for the third one

413
00:18:47,960 --> 00:18:51,620
for the fourth one

414
00:18:57,600 --> 00:19:00,179
and in the end if you remember you have

415
00:19:00,179 --> 00:19:04,440
to apply this uh CK constant on the

416
00:19:04,440 --> 00:19:05,880
algorithm

417
00:19:05,880 --> 00:19:08,760
and in the output you have the correct

418
00:19:08,760 --> 00:19:11,880
master key that was uh written in the

419
00:19:11,880 --> 00:19:15,299
VMware that I used to

420
00:19:15,299 --> 00:19:16,460
to

421
00:19:16,460 --> 00:19:20,059
encrypt the data

422
00:19:22,320 --> 00:19:24,918
foreign

423
00:19:28,400 --> 00:19:30,600
analysis part

424
00:19:30,600 --> 00:19:34,020
so basically fold analysis is another

425
00:19:34,020 --> 00:19:35,640
way of attacking Hardware so by

426
00:19:35,640 --> 00:19:38,100
injecting faults during the encryption

427
00:19:38,100 --> 00:19:40,860
or decryption and analyzing the

428
00:19:40,860 --> 00:19:43,860
resulting fault to reduce the the master

429
00:19:43,860 --> 00:19:45,240
key

430
00:19:45,240 --> 00:19:47,940
hopefully for me some previous paper

431
00:19:47,940 --> 00:19:50,340
were published on a full attack against

432
00:19:50,340 --> 00:19:54,500
sm4 the first one was published in

433
00:19:54,500 --> 00:19:58,860
2006. the paper is in English but this

434
00:19:58,860 --> 00:20:00,960
attack is really the building block for

435
00:20:00,960 --> 00:20:03,960
all further attack which were written in

436
00:20:03,960 --> 00:20:05,520
English for some of them so it was

437
00:20:05,520 --> 00:20:07,740
explained again in those paper

438
00:20:07,740 --> 00:20:10,320
uh all the paper have a performance

439
00:20:10,320 --> 00:20:12,419
section explaining how good is the

440
00:20:12,419 --> 00:20:15,179
attack but no one released the code so

441
00:20:15,179 --> 00:20:16,980
it was really painful to reproduce the

442
00:20:16,980 --> 00:20:18,299
results

443
00:20:18,299 --> 00:20:20,100
but I could figure out one

444
00:20:20,100 --> 00:20:22,799
implementation on GitHub implementing

445
00:20:22,799 --> 00:20:26,820
this attack so I started from this point

446
00:20:26,820 --> 00:20:29,100
so the attack is uh

447
00:20:29,100 --> 00:20:32,340
is really interesting and quite simple

448
00:20:32,340 --> 00:20:35,520
the idea is to inject a byte fold here

449
00:20:35,520 --> 00:20:39,419
for example and see if we do that at the

450
00:20:39,419 --> 00:20:41,580
last run we'll directly observe this

451
00:20:41,580 --> 00:20:44,580
fault at the output in the ciphertext

452
00:20:44,580 --> 00:20:47,160
and this thought will also corrupt the

453
00:20:47,160 --> 00:20:49,620
input of the T function meaning that we

454
00:20:49,620 --> 00:20:52,980
will correct the full output word and we

455
00:20:52,980 --> 00:20:56,520
will observe the fault also in the

456
00:20:56,520 --> 00:20:58,679
ciphertext

457
00:20:58,679 --> 00:21:01,260
this is really interesting uh in

458
00:21:01,260 --> 00:21:03,539
practice because you can observe this

459
00:21:03,539 --> 00:21:05,340
fault when you're injecting fault at

460
00:21:05,340 --> 00:21:07,860
random during encryption some of the

461
00:21:07,860 --> 00:21:10,740
ciphertexts will have a nice property if

462
00:21:10,740 --> 00:21:13,200
you saw those the correct ciphertext

463
00:21:13,200 --> 00:21:15,480
without any fault and the faulted

464
00:21:15,480 --> 00:21:17,340
ciphertext you will observe this nice

465
00:21:17,340 --> 00:21:21,179
pattern so one by fold one byte fault as

466
00:21:21,179 --> 00:21:24,660
I as I explained and a full word faulted

467
00:21:24,660 --> 00:21:27,960
sometimes you have only one byte folded

468
00:21:27,960 --> 00:21:30,240
it's when you have injected fault here

469
00:21:30,240 --> 00:21:32,340
you you won't correct the input of the T

470
00:21:32,340 --> 00:21:36,419
function so it's not directly useful

471
00:21:36,419 --> 00:21:39,000
so I will go a bit uh into the attack so

472
00:21:39,000 --> 00:21:40,919
if you want to have a sleep it's the

473
00:21:40,919 --> 00:21:43,260
best time now

474
00:21:43,260 --> 00:21:45,919
so basically it's a differential attack

475
00:21:45,919 --> 00:21:50,100
so we take a faulted byte voltage by a

476
00:21:50,100 --> 00:21:52,140
value Alpha and we know this Alpha

477
00:21:52,140 --> 00:21:54,900
because we can observe the output and we

478
00:21:54,900 --> 00:21:58,200
write the output the difference of the

479
00:21:58,200 --> 00:22:00,480
output after the rest box

480
00:22:00,480 --> 00:22:03,659
for the faulted ciphertext and for the

481
00:22:03,659 --> 00:22:07,280
correct one and we can just gather all

482
00:22:07,280 --> 00:22:10,320
the input value into a variable X which

483
00:22:10,320 --> 00:22:12,720
is unknown because we it also depends of

484
00:22:12,720 --> 00:22:16,080
the round key byte and a value Alpha

485
00:22:16,080 --> 00:22:18,000
which we know

486
00:22:18,000 --> 00:22:20,520
then if we start from the corrupted

487
00:22:20,520 --> 00:22:23,520
output we can apply the inverse L

488
00:22:23,520 --> 00:22:26,780
function on the difference of the two

489
00:22:26,780 --> 00:22:30,240
outputs and we will obtain a word which

490
00:22:30,240 --> 00:22:33,059
is all zero except for one byte which is

491
00:22:33,059 --> 00:22:36,059
the byte we have faulted so now the

492
00:22:36,059 --> 00:22:41,340
problem uh is to find a x unknown which

493
00:22:41,340 --> 00:22:44,580
satisfies this equation s of X X or S of

494
00:22:44,580 --> 00:22:48,299
X or Alpha equal beta but we can deduce

495
00:22:48,299 --> 00:22:51,539
we can we know Alpha and beta so the

496
00:22:51,539 --> 00:22:55,260
idea of the attack is to um compute a

497
00:22:55,260 --> 00:22:59,580
static table T and for each index we

498
00:22:59,580 --> 00:23:03,419
will enter all the X which satisfies

499
00:23:03,419 --> 00:23:05,880
this equation and if you build this

500
00:23:05,880 --> 00:23:07,860
table you will notice that on average

501
00:23:07,860 --> 00:23:10,500
you will have only two candidates for

502
00:23:10,500 --> 00:23:12,299
each index

503
00:23:12,299 --> 00:23:14,820
so then we start injected fault to the

504
00:23:14,820 --> 00:23:17,460
to the cipher we compute Alpha and beta

505
00:23:17,460 --> 00:23:20,760
from the output of the cipher we look at

506
00:23:20,760 --> 00:23:24,539
the T Alpha Beta and it's we can deduce

507
00:23:24,539 --> 00:23:28,140
some key byte candidates so on average

508
00:23:28,140 --> 00:23:29,280
two

509
00:23:29,280 --> 00:23:31,380
and then we redo that again with another

510
00:23:31,380 --> 00:23:35,100
40 ciphertext we intersect the key

511
00:23:35,100 --> 00:23:37,080
candidates and hopefully we'll have one

512
00:23:37,080 --> 00:23:38,460
uh

513
00:23:38,460 --> 00:23:41,460
key byte which is the correct one so

514
00:23:41,460 --> 00:23:44,520
that's how we we cover one key byte we

515
00:23:44,520 --> 00:23:47,460
can do that for the four key byte of a

516
00:23:47,460 --> 00:23:51,380
round key and as for a side Channel

517
00:23:51,380 --> 00:23:54,720
we can then decrypt the so revert to

518
00:23:54,720 --> 00:23:58,080
last run apply the full attack again and

519
00:23:58,080 --> 00:23:59,700
recover the

520
00:23:59,700 --> 00:24:02,100
the wrong key before and so on until

521
00:24:02,100 --> 00:24:05,159
four run keys are recovered and then we

522
00:24:05,159 --> 00:24:07,980
can uh revert completely the key

523
00:24:07,980 --> 00:24:10,620
schedule and get the master key so on

524
00:24:10,620 --> 00:24:13,140
average with this attack uh we need such

525
00:24:13,140 --> 00:24:15,960
two fold in total

526
00:24:15,960 --> 00:24:19,320
so we started to test this uh attack on

527
00:24:19,320 --> 00:24:22,020
simulated fault so we we Implement some

528
00:24:22,020 --> 00:24:25,260
SM for uh black ciphero in Python we

529
00:24:25,260 --> 00:24:27,559
introduced some fault we

530
00:24:27,559 --> 00:24:30,480
exactly at the place we wanted and then

531
00:24:30,480 --> 00:24:35,900
we moved to uh arm firmware written in C

532
00:24:35,900 --> 00:24:39,360
uh and we use a tool we we have released

533
00:24:39,360 --> 00:24:42,240
before in the past called the glitchozer

534
00:24:42,240 --> 00:24:46,980
3000 which will help us to emulate uh

535
00:24:46,980 --> 00:24:48,120
fault

536
00:24:48,120 --> 00:24:50,700
and our food model was to skip an

537
00:24:50,700 --> 00:24:53,580
instruction at a random place which is

538
00:24:53,580 --> 00:24:54,960
something we have observed in practice

539
00:24:54,960 --> 00:24:58,919
when we inject fault in a real device

540
00:24:58,919 --> 00:25:01,980
we fix the key we fix the plain text and

541
00:25:01,980 --> 00:25:02,900
then we

542
00:25:02,900 --> 00:25:06,480
collected the output from our tool so

543
00:25:06,480 --> 00:25:09,000
here we have the address and the

544
00:25:09,000 --> 00:25:11,820
instruction where the Fault happen and

545
00:25:11,820 --> 00:25:13,440
the result at the end

546
00:25:13,440 --> 00:25:17,100
and we so we collected this um this

547
00:25:17,100 --> 00:25:18,360
fault

548
00:25:18,360 --> 00:25:21,020
and then

549
00:25:22,020 --> 00:25:26,220
we apply uh our attack I mean not our

550
00:25:26,220 --> 00:25:28,559
attack but the the first attack I

551
00:25:28,559 --> 00:25:30,059
presented

552
00:25:30,059 --> 00:25:33,720
so uh so this is the general year in the

553
00:25:33,720 --> 00:25:36,240
first uh part this is the fault I

554
00:25:36,240 --> 00:25:39,179
generated in software so they are all uh

555
00:25:39,179 --> 00:25:41,279
perfect the pattern is really nice what

556
00:25:41,279 --> 00:25:44,700
I I wanted and if I apply the first

557
00:25:44,700 --> 00:25:48,480
attack I see that I'm able to recover a

558
00:25:48,480 --> 00:25:51,779
rune key byte for each two folded

559
00:25:51,779 --> 00:25:55,140
ciphertext at the end I have the full uh

560
00:25:55,140 --> 00:25:57,720
run key recovered

561
00:25:57,720 --> 00:26:00,539
and then the attack tried to decrypt the

562
00:26:00,539 --> 00:26:03,000
run and apply it again unfortunately

563
00:26:03,000 --> 00:26:06,600
here I don't have a nice fault so it

564
00:26:06,600 --> 00:26:09,960
stopped but if I I would have uh any

565
00:26:09,960 --> 00:26:13,080
foot it would have been recover the full

566
00:26:13,080 --> 00:26:15,960
then I moved to my arm firmware

567
00:26:15,960 --> 00:26:19,080
and now if I look to uh the 40

568
00:26:19,080 --> 00:26:21,960
ciphertext I don't have this pattern I

569
00:26:21,960 --> 00:26:24,120
want it to to use for my full attack so

570
00:26:24,120 --> 00:26:27,840
I was stuck even though there is uh here

571
00:26:27,840 --> 00:26:30,480
nice Fort which seems interesting but

572
00:26:30,480 --> 00:26:32,820
the First full attack was not covered by

573
00:26:32,820 --> 00:26:35,779
uh for this case

574
00:26:38,460 --> 00:26:41,520
so I'm I go back I went back to the

575
00:26:41,520 --> 00:26:44,820
literature and there was a second attack

576
00:26:44,820 --> 00:26:48,059
uh published in 2007.

577
00:26:48,059 --> 00:26:50,460
and this is an extension of the first

578
00:26:50,460 --> 00:26:51,740
attack

579
00:26:51,740 --> 00:26:55,740
doctors explained that you can fold one

580
00:26:55,740 --> 00:26:58,799
hand earlier and you will corrupt all

581
00:26:58,799 --> 00:27:00,960
the byte of the following World so now

582
00:27:00,960 --> 00:27:03,840
you can apply the attack I presented but

583
00:27:03,840 --> 00:27:06,419
in parallel on all the four bytes of the

584
00:27:06,419 --> 00:27:08,820
round key and also it's interesting

585
00:27:08,820 --> 00:27:10,740
because it transform a byte-fold model

586
00:27:10,740 --> 00:27:13,620
into a world fold model now we can take

587
00:27:13,620 --> 00:27:18,120
some fault happening into a full uh well

588
00:27:18,120 --> 00:27:19,679
so

589
00:27:19,679 --> 00:27:22,860
to have a picture of that now if we fall

590
00:27:22,860 --> 00:27:25,260
to one around earlier we will correct

591
00:27:25,260 --> 00:27:29,039
the first T function which will create

592
00:27:29,039 --> 00:27:30,659
the

593
00:27:30,659 --> 00:27:31,559
um

594
00:27:31,559 --> 00:27:34,020
the input of the last one but now it

595
00:27:34,020 --> 00:27:38,159
will corrupt all the input here and we

596
00:27:38,159 --> 00:27:40,919
can still observe the output again into

597
00:27:40,919 --> 00:27:42,720
the the ciphertext

598
00:27:42,720 --> 00:27:46,020
and again we have also the input which

599
00:27:46,020 --> 00:27:49,440
are not uh hidden here because they are

600
00:27:49,440 --> 00:27:52,860
directly shifted so that's uh still nice

601
00:27:52,860 --> 00:27:55,320
for us

602
00:27:55,320 --> 00:27:58,260
and in the paper they are even going uh

603
00:27:58,260 --> 00:28:00,960
further uh by folding even one round

604
00:28:00,960 --> 00:28:03,779
earlier and in this case you can recover

605
00:28:03,779 --> 00:28:07,500
two round key uh in a row only with uh

606
00:28:07,500 --> 00:28:09,240
with two foot so it's really really

607
00:28:09,240 --> 00:28:10,500
powerful

608
00:28:10,500 --> 00:28:12,900
and it means that with four-fold we can

609
00:28:12,900 --> 00:28:15,480
recover the keyer completely

610
00:28:15,480 --> 00:28:16,500
foreign

611
00:28:16,500 --> 00:28:19,860
and now there is still a pattern which

612
00:28:19,860 --> 00:28:22,500
is interesting if we we saw the correct

613
00:28:22,500 --> 00:28:25,500
ciphertext and the faulted ciphertext a

614
00:28:25,500 --> 00:28:28,559
bit different different there is a more

615
00:28:28,559 --> 00:28:32,940
World corrupted but still uh

616
00:28:32,940 --> 00:28:36,360
uh we we can still filter those pattern

617
00:28:36,360 --> 00:28:39,419
it just doesn't work if we fold this one

618
00:28:39,419 --> 00:28:43,860
x i plus 1 because now it will be so the

619
00:28:43,860 --> 00:28:45,260
fourth will be

620
00:28:45,260 --> 00:28:48,659
injected into the first T function but

621
00:28:48,659 --> 00:28:51,480
it will be hidden by another value here

622
00:28:51,480 --> 00:28:55,220
so it's not directly applicable

623
00:28:55,700 --> 00:28:58,320
uh and also for completeness

624
00:28:58,320 --> 00:29:02,039
completeness there is another attack uh

625
00:29:02,039 --> 00:29:05,940
going one round further so now you you

626
00:29:05,940 --> 00:29:09,299
just need one uh fold and basically you

627
00:29:09,299 --> 00:29:12,600
will brute force uh the dff for each

628
00:29:12,600 --> 00:29:15,659
candidate so it's really it takes uh

629
00:29:15,659 --> 00:29:18,720
um like two to the power 10 uh GFF for

630
00:29:18,720 --> 00:29:22,140
each candidate so it's quite uh long so

631
00:29:22,140 --> 00:29:23,820
we we didn't Implement that attack

632
00:29:23,820 --> 00:29:26,940
because we we didn't need that maybe it

633
00:29:26,940 --> 00:29:28,559
would be interesting if you don't have

634
00:29:28,559 --> 00:29:32,340
access to a lot of uh faulted ciphertext

635
00:29:32,340 --> 00:29:34,980
and the main problem is now you don't

636
00:29:34,980 --> 00:29:37,320
have this nice pattern

637
00:29:37,320 --> 00:29:40,320
um in the ciphertext as the output so it

638
00:29:40,320 --> 00:29:42,179
can be difficult

639
00:29:42,179 --> 00:29:45,480
however implementing those attacks we

640
00:29:45,480 --> 00:29:47,880
figure out that there is still some room

641
00:29:47,880 --> 00:29:50,940
from for improvement uh

642
00:29:50,940 --> 00:29:54,240
again if you fold this x i plus one you

643
00:29:54,240 --> 00:29:56,520
don't have access to the input for your

644
00:29:56,520 --> 00:29:59,520
attack but it happened sometimes that if

645
00:29:59,520 --> 00:30:02,279
it's a byte fault you can still try all

646
00:30:02,279 --> 00:30:06,419
the 256 possible value during the GFA

647
00:30:06,419 --> 00:30:08,820
and it still work and also what we

648
00:30:08,820 --> 00:30:11,399
observe for Hardware implementation

649
00:30:11,399 --> 00:30:13,860
sometimes you fold only the computation

650
00:30:13,860 --> 00:30:16,860
of T not the register itself so

651
00:30:16,860 --> 00:30:18,960
basically the difference will stay to

652
00:30:18,960 --> 00:30:21,059
zero and the attack is also applicable

653
00:30:21,059 --> 00:30:23,659
in this case

654
00:30:23,659 --> 00:30:28,700
so what we did we implemented this

655
00:30:28,700 --> 00:30:31,559
extended fault attack and in fact you

656
00:30:31,559 --> 00:30:32,940
can combine the first one with the

657
00:30:32,940 --> 00:30:35,460
second one and keep track of the click

658
00:30:35,460 --> 00:30:37,020
on the date

659
00:30:37,020 --> 00:30:40,500
we did that so we we included that in uh

660
00:30:40,500 --> 00:30:43,799
the side Channel Marvels from flip to n

661
00:30:43,799 --> 00:30:47,520
so it was a tool used for uh AES to

662
00:30:47,520 --> 00:30:50,039
perform full attack on AES so now there

663
00:30:50,039 --> 00:30:53,700
is a package Phoenix sm4 for sm4

664
00:30:53,700 --> 00:30:56,220
implementing those attacks so if you

665
00:30:56,220 --> 00:30:59,220
want to uh to use it it's just a PP

666
00:30:59,220 --> 00:31:00,320
install

667
00:31:00,320 --> 00:31:03,720
so it's quite quite convenient and I

668
00:31:03,720 --> 00:31:06,559
will show how it's for

669
00:31:06,840 --> 00:31:10,799
now we have the fold I had before

670
00:31:10,799 --> 00:31:11,820
here

671
00:31:11,820 --> 00:31:13,100
I can

672
00:31:13,100 --> 00:31:16,440
apply my attack

673
00:31:16,440 --> 00:31:20,120
and as you see for some run the full

674
00:31:20,120 --> 00:31:24,120
full run Keys recover at each step so

675
00:31:24,120 --> 00:31:27,440
it's going uh really fast then

676
00:31:27,440 --> 00:31:31,980
run is decrypted then the next round key

677
00:31:31,980 --> 00:31:34,380
is recover and again and again and at

678
00:31:34,380 --> 00:31:36,960
the end we have forerun key so we can

679
00:31:36,960 --> 00:31:38,220
recover the

680
00:31:38,220 --> 00:31:40,980
thermostat so it's working uh quite good

681
00:31:40,980 --> 00:31:43,440
for this kind of fold so we were happy

682
00:31:43,440 --> 00:31:45,980
with that

683
00:31:49,140 --> 00:31:51,840
and now we had all the Tool uh to

684
00:31:51,840 --> 00:31:53,520
perform uh attack against Hardware

685
00:31:53,520 --> 00:31:55,740
implementation and I will let Nicola

686
00:31:55,740 --> 00:31:58,399
explain that

687
00:32:00,299 --> 00:32:04,260
so while we were working on this uh the

688
00:32:04,260 --> 00:32:05,700
friend of mine who was talking to me

689
00:32:05,700 --> 00:32:08,640
about this chip released this really

690
00:32:08,640 --> 00:32:12,059
nice dev kit for the aforementioned

691
00:32:12,059 --> 00:32:13,980
microcontroller

692
00:32:13,980 --> 00:32:16,620
uh by the way uh by the end of the the

693
00:32:16,620 --> 00:32:19,140
week uh he will do a presentation at

694
00:32:19,140 --> 00:32:21,779
grac another conference in Grenoble if

695
00:32:21,779 --> 00:32:23,760
you want to see the the outcome it

696
00:32:23,760 --> 00:32:25,320
should be available on YouTube thanks

697
00:32:25,320 --> 00:32:27,860
Cooper

698
00:32:27,860 --> 00:32:32,120
so again it's based on this my this CH

699
00:32:32,120 --> 00:32:35,820
569w from wch which is a Chinese

700
00:32:35,820 --> 00:32:38,520
manufacturer of microcontrollers

701
00:32:38,520 --> 00:32:41,100
it's a risk five macro controller with

702
00:32:41,100 --> 00:32:44,700
the hardware sm4ip so means once I got

703
00:32:44,700 --> 00:32:47,340
access to this board I was able to

704
00:32:47,340 --> 00:32:50,520
develop a small C firmware but instead

705
00:32:50,520 --> 00:32:52,260
of doing a software implementation of

706
00:32:52,260 --> 00:32:57,000
sm4 I'm using the SDK to ask politely

707
00:32:57,000 --> 00:32:59,580
the microcontroller to use the hardware

708
00:32:59,580 --> 00:33:03,539
sm4 to encrypt the data

709
00:33:03,539 --> 00:33:07,679
and output the ciphertext so hopefully

710
00:33:07,679 --> 00:33:12,179
everything works correctly so I uh did

711
00:33:12,179 --> 00:33:16,080
the the setup at home prepared the site

712
00:33:16,080 --> 00:33:19,679
Channel analysis and unfortunately for

713
00:33:19,679 --> 00:33:22,380
all the captures and traces I tried to

714
00:33:22,380 --> 00:33:27,179
do I had no correlation on any part of

715
00:33:27,179 --> 00:33:28,679
the algorithm

716
00:33:28,679 --> 00:33:31,140
I have correlation on the plain text

717
00:33:31,140 --> 00:33:34,740
inputs on the ciphertext outputs but in

718
00:33:34,740 --> 00:33:38,340
between I just have some garbage and no

719
00:33:38,340 --> 00:33:41,460
user usable information

720
00:33:41,460 --> 00:33:44,700
so my guess is my setup at home is uh

721
00:33:44,700 --> 00:33:48,059
not fast enough so I will need to find

722
00:33:48,059 --> 00:33:51,779
time and find better oscilloscopes and

723
00:33:51,779 --> 00:33:55,320
better testing equipments to do a better

724
00:33:55,320 --> 00:33:59,039
uh setup and being able to implement

725
00:33:59,039 --> 00:34:02,640
software Hardware side Channel analysis

726
00:34:02,640 --> 00:34:04,860
on this chip

727
00:34:04,860 --> 00:34:06,120
but

728
00:34:06,120 --> 00:34:08,159
for the fault injection

729
00:34:08,159 --> 00:34:12,239
here I was able to do the same setup so

730
00:34:12,239 --> 00:34:14,760
the same firmware doing the encryption

731
00:34:14,760 --> 00:34:17,520
Etc but this time I used the cheap

732
00:34:17,520 --> 00:34:20,179
Shelter From a new AE which is of

733
00:34:20,179 --> 00:34:23,580
electromagnetic fault injection tool

734
00:34:23,580 --> 00:34:27,659
uh the setup I used uh is using a four

735
00:34:27,659 --> 00:34:32,339
400 volts uh pulse injection uh for 150

736
00:34:32,339 --> 00:34:34,199
nanoseconds

737
00:34:34,199 --> 00:34:37,020
I used the stock clockwise coil if you

738
00:34:37,020 --> 00:34:38,940
want to try this at home

739
00:34:38,940 --> 00:34:42,540
and I let it run for several days uh

740
00:34:42,540 --> 00:34:45,960
trying to always send the same plain

741
00:34:45,960 --> 00:34:48,418
text and collecting the output and if

742
00:34:48,418 --> 00:34:50,040
the output was different than the

743
00:34:50,040 --> 00:34:53,219
expected one that means ID defaults and

744
00:34:53,219 --> 00:34:55,859
I collected everything in the trace and

745
00:34:55,859 --> 00:34:59,280
then once I have enough of faulted

746
00:34:59,280 --> 00:35:02,820
ciphers I gave it to Silva and hopefully

747
00:35:02,820 --> 00:35:04,980
he was able to do something with it

748
00:35:04,980 --> 00:35:07,220
foreign

749
00:35:07,940 --> 00:35:10,619
thing you didn't mention is that the

750
00:35:10,619 --> 00:35:13,680
chip was uh the package was not removing

751
00:35:13,680 --> 00:35:15,599
that that at all it was just 40

752
00:35:15,599 --> 00:35:19,079
injection above the the package so we

753
00:35:19,079 --> 00:35:23,359
collected uh 1400 fold

754
00:35:23,359 --> 00:35:25,980
283 of them were unique

755
00:35:25,980 --> 00:35:28,740
and we apply the same tool I presented

756
00:35:28,740 --> 00:35:33,240
before and so now Mr kiwa's phone so it

757
00:35:33,240 --> 00:35:34,980
shows that this uh Hardware

758
00:35:34,980 --> 00:35:37,920
implementation of sm4 is not secure

759
00:35:37,920 --> 00:35:40,680
against chip fault injection because you

760
00:35:40,680 --> 00:35:43,380
you are able to to recover the the key

761
00:35:43,380 --> 00:35:46,740
use for during encryption

762
00:35:46,740 --> 00:35:50,280
so to sum up uh We've presented the sm4

763
00:35:50,280 --> 00:35:52,740
which is another block Cipher but we

764
00:35:52,740 --> 00:35:54,420
think it's interesting to study this

765
00:35:54,420 --> 00:35:56,880
black Cipher uh because it will be more

766
00:35:56,880 --> 00:35:59,160
and more deploy uh thanks to

767
00:35:59,160 --> 00:36:01,079
standardization

768
00:36:01,079 --> 00:36:03,900
uh We've released uh all the tool we we

769
00:36:03,900 --> 00:36:06,180
use during this project so the key

770
00:36:06,180 --> 00:36:09,839
schedule finder the Yahoo rules uh the

771
00:36:09,839 --> 00:36:11,940
pro analysis Library will be included

772
00:36:11,940 --> 00:36:16,619
into a scared soon and the full analysis

773
00:36:16,619 --> 00:36:19,200
part is already included in the site

774
00:36:19,200 --> 00:36:23,040
Channel Marvels and if you think this

775
00:36:23,040 --> 00:36:25,560
talk was useless it's easy to prevent

776
00:36:25,560 --> 00:36:27,240
that in the future if you have new

777
00:36:27,240 --> 00:36:29,160
Attack Just publish your code and it

778
00:36:29,160 --> 00:36:31,859
will be simpler for everybody

779
00:36:31,859 --> 00:36:33,599
thank you and if you have any question

780
00:36:33,599 --> 00:36:36,619
we are here

781
00:36:42,420 --> 00:36:43,859
thank you for the great presentation

782
00:36:43,859 --> 00:36:45,480
Silva Nicola

783
00:36:45,480 --> 00:36:48,859
does anyone have any question

784
00:36:51,240 --> 00:36:52,619
um

785
00:36:52,619 --> 00:36:55,200
you just

786
00:36:55,200 --> 00:36:58,160
put yourself

787
00:36:59,660 --> 00:37:02,400
thank you for the presentation out of

788
00:37:02,400 --> 00:37:04,940
curiosity given that this is a Chinese

789
00:37:04,940 --> 00:37:09,180
encryption algorithm do they use a

790
00:37:09,180 --> 00:37:11,339
standard mode of operation or they use a

791
00:37:11,339 --> 00:37:14,599
Chinese mode of operation

792
00:37:14,760 --> 00:37:19,920
how it is written for TLS it's standout

793
00:37:19,920 --> 00:37:22,500
like CBC if I remember well so nothing

794
00:37:22,500 --> 00:37:25,260
strange I've seen

795
00:37:25,260 --> 00:37:28,220
even in the hardware I think you said

796
00:37:28,220 --> 00:37:32,299
yeah ECB and CBC

797
00:37:41,460 --> 00:37:45,839
so that's clear hopefully

798
00:37:46,680 --> 00:37:49,339
thank you

799
00:37:50,579 --> 00:37:54,900
may I still inject a question

800
00:37:54,900 --> 00:37:57,839
um looking at this key schedule do you

801
00:37:57,839 --> 00:37:59,099
think

802
00:37:59,099 --> 00:38:02,460
there was a ulterior motive on how it is

803
00:38:02,460 --> 00:38:04,859
built in the first place like that it is

804
00:38:04,859 --> 00:38:08,640
easier to attack than it could be or do

805
00:38:08,640 --> 00:38:10,260
you have no opinion about the strength

806
00:38:10,260 --> 00:38:13,040
of the algorithm

807
00:38:13,579 --> 00:38:17,480
I don't really know it was treated a lot

808
00:38:17,480 --> 00:38:21,619
in terms of crypto analysis

809
00:38:21,780 --> 00:38:22,980
I mean

810
00:38:22,980 --> 00:38:25,619
it comes from the government directly

811
00:38:25,619 --> 00:38:28,940
without any public

812
00:38:28,940 --> 00:38:33,780
like a yes for the public competition so

813
00:38:33,780 --> 00:38:36,780
but it's it's resisted for a long time

814
00:38:36,780 --> 00:38:40,040
so I think it's okay

815
00:38:54,660 --> 00:38:58,399
no more questions yeah

816
00:38:59,599 --> 00:39:02,900
that's all

817
00:39:05,700 --> 00:39:09,720
knowing risk 5 a lot of the forward L is

818
00:39:09,720 --> 00:39:11,820
open source and can also be looked at

819
00:39:11,820 --> 00:39:13,440
have you looked at the hardware

820
00:39:13,440 --> 00:39:16,200
implementation if it could be harder not

821
00:39:16,200 --> 00:39:16,920
against

822
00:39:16,920 --> 00:39:20,060
some of your attacks

823
00:39:21,960 --> 00:39:24,119
um not really honestly this was the

824
00:39:24,119 --> 00:39:26,700
first time we've seen how to

825
00:39:26,700 --> 00:39:29,760
implementation of sm4 it happened to be

826
00:39:29,760 --> 00:39:32,640
on a risk 5 chip but that that was the

827
00:39:32,640 --> 00:39:36,259
only one that was available at the time

828
00:39:39,960 --> 00:39:43,680
okay last chance to ask a question

829
00:39:43,680 --> 00:39:45,900
nobody okay let's thank the speaker

830
00:39:45,900 --> 00:39:47,579
again

831
00:39:47,579 --> 00:39:50,359
thank you

