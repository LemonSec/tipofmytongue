1
00:00:04,460 --> 00:00:08,099
hello guys my name is Roman

2
00:00:08,099 --> 00:00:09,980
um currently I'm independent contractor

3
00:00:09,980 --> 00:00:12,780
my main specialization is side Channel

4
00:00:12,780 --> 00:00:15,000
and fault attacks I also work with

5
00:00:15,000 --> 00:00:16,800
cryptography and let's say low level

6
00:00:16,800 --> 00:00:18,000
attacks

7
00:00:18,000 --> 00:00:21,420
currently I am in contract with Sony so

8
00:00:21,420 --> 00:00:23,760
I'm mostly doing work for Sony

9
00:00:23,760 --> 00:00:27,000
and in Sony I'm working in a team worth

10
00:00:27,000 --> 00:00:30,000
let's say 15 to 12 20 people like being

11
00:00:30,000 --> 00:00:32,700
honest don't remember we are spread all

12
00:00:32,700 --> 00:00:34,739
over the world we are doing different

13
00:00:34,739 --> 00:00:37,620
kind of been testing device when testing

14
00:00:37,620 --> 00:00:41,219
application web services

15
00:00:41,219 --> 00:00:46,079
um and the the main goal is to test Sony

16
00:00:46,079 --> 00:00:49,440
internal products so that's what we do

17
00:00:49,440 --> 00:00:51,539
I also have my small lab here in

18
00:00:51,539 --> 00:00:53,579
Switzerland so where I have oscilloscope

19
00:00:53,579 --> 00:00:56,520
PM fault injection glitches Etc so I

20
00:00:56,520 --> 00:00:58,260
really perform side Channel fault

21
00:00:58,260 --> 00:01:00,420
attacks here in Switzerland in all you

22
00:01:00,420 --> 00:01:02,100
are very welcome to visit my lab if you

23
00:01:02,100 --> 00:01:02,879
wish

24
00:01:02,879 --> 00:01:04,799
I have more than 10 years of experience

25
00:01:04,799 --> 00:01:07,439
I worked at Naga St microelectronics I

26
00:01:07,439 --> 00:01:09,540
hold a PhD but I believe it's boring for

27
00:01:09,540 --> 00:01:11,100
you to listen

28
00:01:11,100 --> 00:01:14,159
so on the agenda for tonight it's very

29
00:01:14,159 --> 00:01:16,500
short so I will try to introduce and to

30
00:01:16,500 --> 00:01:17,299
reason

31
00:01:17,299 --> 00:01:20,939
what which problems I faced and how I

32
00:01:20,939 --> 00:01:22,680
try to solve them

33
00:01:22,680 --> 00:01:26,159
I will show that I implemented an arc

34
00:01:26,159 --> 00:01:28,140
version to gidra support so it's an

35
00:01:28,140 --> 00:01:29,759
instruction set which nowadays

36
00:01:29,759 --> 00:01:31,500
implemented in gindra

37
00:01:31,500 --> 00:01:35,579
and later I will show that how this can

38
00:01:35,579 --> 00:01:37,560
be used in order to emulate small

39
00:01:37,560 --> 00:01:39,240
portions of code

40
00:01:39,240 --> 00:01:41,939
and also how I can emulate faults in

41
00:01:41,939 --> 00:01:44,759
this motion small portions of code and

42
00:01:44,759 --> 00:01:46,680
clearly later I will conclude the the

43
00:01:46,680 --> 00:01:48,180
presentation

44
00:01:48,180 --> 00:01:51,360
so reasoning is very simple

45
00:01:51,360 --> 00:01:55,140
well very simple you probably saw words

46
00:01:55,140 --> 00:01:59,460
false and you probably saw a talk from

47
00:01:59,460 --> 00:02:02,939
Nicola and Sylvan so what what are these

48
00:02:02,939 --> 00:02:04,020
faults

49
00:02:04,020 --> 00:02:06,860
false is something we

50
00:02:06,860 --> 00:02:09,538
inject into the device so we take a

51
00:02:09,538 --> 00:02:12,300
device and we can physically stress it

52
00:02:12,300 --> 00:02:15,660
for example we can have a very short but

53
00:02:15,660 --> 00:02:18,379
super intense electromagnetic pulse

54
00:02:18,379 --> 00:02:22,560
nearby this device and device I speak

55
00:02:22,560 --> 00:02:24,720
about microcontroller or smart cart or

56
00:02:24,720 --> 00:02:27,180
whatever the device will not freeze or

57
00:02:27,180 --> 00:02:29,400
will not mute what happens it will skip

58
00:02:29,400 --> 00:02:32,040
an instruction it will modify some data

59
00:02:32,040 --> 00:02:34,920
internally and an attacker can use this

60
00:02:34,920 --> 00:02:37,680
in order to bypass certain security

61
00:02:37,680 --> 00:02:42,060
measures for example faults they are

62
00:02:42,060 --> 00:02:44,160
very commonly used unfortunately for

63
00:02:44,160 --> 00:02:47,580
sp32 so esp32 is a very common Target

64
00:02:47,580 --> 00:02:51,420
where Faults Are reported uh first it

65
00:02:51,420 --> 00:02:54,360
was used to bypass secure boot then

66
00:02:54,360 --> 00:02:57,060
esp32 fixed it then it was another

67
00:02:57,060 --> 00:02:59,519
problem to bypass encryption and there

68
00:02:59,519 --> 00:03:02,040
are many many problems but the esp32 is

69
00:03:02,040 --> 00:03:03,959
not the only chip I mean all

70
00:03:03,959 --> 00:03:07,980
semiconductor devices uh in a way can be

71
00:03:07,980 --> 00:03:11,040
vulnerable to fault injection and there

72
00:03:11,040 --> 00:03:13,140
are some open Publications from limited

73
00:03:13,140 --> 00:03:16,860
results from failover flow from Thomas

74
00:03:16,860 --> 00:03:19,260
Road and some other people where the

75
00:03:19,260 --> 00:03:23,040
attack stm32 and f52 and many many many

76
00:03:23,040 --> 00:03:26,580
other iot chipsets and smart cards

77
00:03:26,580 --> 00:03:28,739
however

78
00:03:28,739 --> 00:03:31,080
sometimes

79
00:03:31,080 --> 00:03:33,360
when we develop a device so Sony

80
00:03:33,360 --> 00:03:36,120
develops certain devices we want to

81
00:03:36,120 --> 00:03:38,580
protect against faults so we want to

82
00:03:38,580 --> 00:03:41,700
First in which kind of counter measures

83
00:03:41,700 --> 00:03:44,280
we can put in order for example to

84
00:03:44,280 --> 00:03:46,500
secure secure boot

85
00:03:46,500 --> 00:03:48,780
and since the device is still in

86
00:03:48,780 --> 00:03:50,819
production we cannot really work with a

87
00:03:50,819 --> 00:03:52,620
device it's it's in production it's

88
00:03:52,620 --> 00:03:55,440
still physically made but we're already

89
00:03:55,440 --> 00:03:57,599
developing the code and we want to run

90
00:03:57,599 --> 00:04:01,860
it and to help this situation what we

91
00:04:01,860 --> 00:04:04,500
use its emulation

92
00:04:04,500 --> 00:04:07,980
we use emulation in order to run some

93
00:04:07,980 --> 00:04:10,739
portions of code but also we use

94
00:04:10,739 --> 00:04:13,319
simulation to emulate fault injection in

95
00:04:13,319 --> 00:04:15,239
the code for example we can skip

96
00:04:15,239 --> 00:04:17,760
instructions we can modify data and see

97
00:04:17,760 --> 00:04:21,620
how our code will react to this

98
00:04:22,260 --> 00:04:26,759
in my case I ended up with this task

99
00:04:26,759 --> 00:04:29,580
because I was working with a populator

100
00:04:29,580 --> 00:04:32,220
instruction set which is has never been

101
00:04:32,220 --> 00:04:34,560
supported by any reverse engineering

102
00:04:34,560 --> 00:04:37,020
tool and I needed to implement certain

103
00:04:37,020 --> 00:04:39,000
let's say I needed to implement this

104
00:04:39,000 --> 00:04:43,020
instruction set however since I didn't

105
00:04:43,020 --> 00:04:45,600
know which tool would be the best I did

106
00:04:45,600 --> 00:04:48,300
some study to see

107
00:04:48,300 --> 00:04:51,540
which tool I can use in order to

108
00:04:51,540 --> 00:04:54,120
implement relatively fast and reliably

109
00:04:54,120 --> 00:04:58,500
an instruction set so which will be used

110
00:04:58,500 --> 00:05:01,259
for emulation and I ended up with the

111
00:05:01,259 --> 00:05:03,300
three common tools it's gidra but true

112
00:05:03,300 --> 00:05:06,479
and qmu probably heard of all of them I

113
00:05:06,479 --> 00:05:07,979
did some studies

114
00:05:07,979 --> 00:05:11,220
and to study how easy to implement an

115
00:05:11,220 --> 00:05:13,979
instruction set I used Arc version 2.

116
00:05:13,979 --> 00:05:17,100
it's quite a rare CPU Arc version 2 It's

117
00:05:17,100 --> 00:05:19,680
relatively rare that's why it's usually

118
00:05:19,680 --> 00:05:22,139
not very well supported so I did my

119
00:05:22,139 --> 00:05:25,139
studies and I saw for example that gidra

120
00:05:25,139 --> 00:05:28,919
well it's more suitable for me and most

121
00:05:28,919 --> 00:05:33,000
suitable for my goals radar too can also

122
00:05:33,000 --> 00:05:35,699
do the same job as ginra but is it's

123
00:05:35,699 --> 00:05:38,639
less user friendly so and for me it was

124
00:05:38,639 --> 00:05:40,620
very important to share my results with

125
00:05:40,620 --> 00:05:42,479
other units and while other business

126
00:05:42,479 --> 00:05:46,139
departments so I ended up with gidra and

127
00:05:46,139 --> 00:05:48,900
today I'm going to present you the work

128
00:05:48,900 --> 00:05:52,800
I did to support our version 2. I also

129
00:05:52,800 --> 00:05:55,259
would like to show how emulation is done

130
00:05:55,259 --> 00:05:58,080
and how I can do fault emulation with

131
00:05:58,080 --> 00:06:01,080
gidra and gidra just couple of words

132
00:06:01,080 --> 00:06:04,800
it's a very nowadays no one tool it

133
00:06:04,800 --> 00:06:06,900
competes with Eda Pro it competes with

134
00:06:06,900 --> 00:06:10,560
radar 2 it's uh it's nowadays complex

135
00:06:10,560 --> 00:06:13,639
system so it has a disassembly

136
00:06:13,639 --> 00:06:16,560
decompilation emulation and also

137
00:06:16,560 --> 00:06:19,440
debugging facilities in one package it's

138
00:06:19,440 --> 00:06:22,380
user friendly we can develop plugins so

139
00:06:22,380 --> 00:06:24,060
it's it's a nice tool

140
00:06:24,060 --> 00:06:26,660
foreign

141
00:06:27,440 --> 00:06:29,940
once again step back

142
00:06:29,940 --> 00:06:32,819
a couple of words about Arc version 2.

143
00:06:32,819 --> 00:06:35,580
so in my practice I encountered this

144
00:06:35,580 --> 00:06:39,539
device well this instruction set twice

145
00:06:39,539 --> 00:06:42,960
um and since I suck so I am very bad in

146
00:06:42,960 --> 00:06:45,840
reverse engineering and I I I didn't

147
00:06:45,840 --> 00:06:48,360
have back in times nice tools I could

148
00:06:48,360 --> 00:06:50,400
not do anything with Arc version 2

149
00:06:50,400 --> 00:06:51,419
devices

150
00:06:51,419 --> 00:06:54,120
so I started slowly step by step to

151
00:06:54,120 --> 00:06:56,220
implement this version to supporting

152
00:06:56,220 --> 00:06:57,600
gidra

153
00:06:57,600 --> 00:07:01,080
but our version 2 is quite unique CPU

154
00:07:01,080 --> 00:07:04,139
instruction set it's used in very

155
00:07:04,139 --> 00:07:06,539
special purpose devices for example in

156
00:07:06,539 --> 00:07:09,479
solid state driver controllers or I give

157
00:07:09,479 --> 00:07:11,280
another example it's a high resolution

158
00:07:11,280 --> 00:07:13,620
image radar chipset so it's not very

159
00:07:13,620 --> 00:07:15,240
common and you don't see it normally on

160
00:07:15,240 --> 00:07:17,940
the market it's still used in many iot

161
00:07:17,940 --> 00:07:20,520
devices for example I list two of them

162
00:07:20,520 --> 00:07:22,380
as there are some other devices which

163
00:07:22,380 --> 00:07:24,300
are on the market and they're not very

164
00:07:24,300 --> 00:07:25,800
disclosed

165
00:07:25,800 --> 00:07:28,919
so but they're a very very very few

166
00:07:28,919 --> 00:07:31,500
tools that can do reverse engineering of

167
00:07:31,500 --> 00:07:35,479
version 2. nowadays

168
00:07:35,479 --> 00:07:39,599
edible has decompilation facilities for

169
00:07:39,599 --> 00:07:42,300
Arc version 2 but you need to buy it so

170
00:07:42,300 --> 00:07:45,000
you need to buy a special model for this

171
00:07:45,000 --> 00:07:47,160
and up to today the current state of

172
00:07:47,160 --> 00:07:50,840
zart was work done by Nicola

173
00:07:50,840 --> 00:07:55,199
EOS from Ledger dungeon he implemented

174
00:07:55,199 --> 00:07:57,720
Arc compact it's it's slightly different

175
00:07:57,720 --> 00:08:01,560
its predecessor of art version 2 but he

176
00:08:01,560 --> 00:08:03,539
brought this support for gidrat so if

177
00:08:03,539 --> 00:08:05,639
back in times it was the only he

178
00:08:05,639 --> 00:08:09,360
released the the two in 2021 and it was

179
00:08:09,360 --> 00:08:10,380
only

180
00:08:10,380 --> 00:08:13,740
tool that supported sort of Arc reverse

181
00:08:13,740 --> 00:08:14,940
engineering

182
00:08:14,940 --> 00:08:18,960
however in my case Arc compact is

183
00:08:18,960 --> 00:08:20,699
drastically different from Arc version

184
00:08:20,699 --> 00:08:23,639
2. it has different instructions so for

185
00:08:23,639 --> 00:08:26,460
example a version 2 is clearly more rich

186
00:08:26,460 --> 00:08:28,680
in terms of instructions so I could not

187
00:08:28,680 --> 00:08:30,660
use our compact also there are some

188
00:08:30,660 --> 00:08:32,219
other registers which are totally

189
00:08:32,219 --> 00:08:34,500
different different addresses so I could

190
00:08:34,500 --> 00:08:37,500
not use his work in order to do my

191
00:08:37,500 --> 00:08:40,080
reverse engineering

192
00:08:40,080 --> 00:08:43,620
so I started to implement the this Arc

193
00:08:43,620 --> 00:08:46,620
version to support and how easily it

194
00:08:46,620 --> 00:08:49,500
works with Kindra so when you have

195
00:08:49,500 --> 00:08:52,519
the mouse

196
00:08:52,580 --> 00:08:56,880
seems not or whatever so when you have a

197
00:08:56,880 --> 00:09:00,660
binary you take it's just a sequence of

198
00:09:00,660 --> 00:09:05,040
bytes a binary we put it in gidra guidra

199
00:09:05,040 --> 00:09:08,279
parse all the bytes and decode them into

200
00:09:08,279 --> 00:09:09,839
the commands

201
00:09:09,839 --> 00:09:12,019
foreign

202
00:09:12,380 --> 00:09:15,839
bytes into commands guidra uses

203
00:09:15,839 --> 00:09:19,080
so-called Sledge a description of an

204
00:09:19,080 --> 00:09:21,320
instruction

205
00:09:21,660 --> 00:09:24,720
and slate description it's what I'm

206
00:09:24,720 --> 00:09:27,060
going to show you in in the next example

207
00:09:27,060 --> 00:09:29,279
so let's assume you take one instruction

208
00:09:29,279 --> 00:09:34,200
or some some documentation from CPU you

209
00:09:34,200 --> 00:09:36,839
see on the top the table which

210
00:09:36,839 --> 00:09:39,180
shows you how instructions shall be

211
00:09:39,180 --> 00:09:42,060
decoded in our specific case let's say

212
00:09:42,060 --> 00:09:45,000
you take two bytes first five bytes it's

213
00:09:45,000 --> 00:09:48,000
a major opcode which will be used to

214
00:09:48,000 --> 00:09:50,160
understand which instruction is it is

215
00:09:50,160 --> 00:09:53,459
then it falls by three bytes which show

216
00:09:53,459 --> 00:09:55,320
your register another three bytes

217
00:09:55,320 --> 00:09:58,380
register two bytes like two bits sorry

218
00:09:58,380 --> 00:10:01,080
I'm sorry two bits two bits

219
00:10:01,080 --> 00:10:04,560
um show the sub op code so like measure

220
00:10:04,560 --> 00:10:06,120
and sub-up code

221
00:10:06,120 --> 00:10:08,700
answer is an immediate value so if we

222
00:10:08,700 --> 00:10:12,899
want to write this instruction in gidra

223
00:10:12,899 --> 00:10:16,200
what we will do we will declare a filter

224
00:10:16,200 --> 00:10:19,860
token of 16 bits and we say that first

225
00:10:19,860 --> 00:10:24,000
five bits it's a op code and then we

226
00:10:24,000 --> 00:10:26,399
describe the other bits

227
00:10:26,399 --> 00:10:30,000
for each of the fields we assign the

228
00:10:30,000 --> 00:10:33,180
register set since it's only three bit

229
00:10:33,180 --> 00:10:35,339
Fields the maximum number of registers

230
00:10:35,339 --> 00:10:38,459
is 8 so you can see there are eight

231
00:10:38,459 --> 00:10:39,839
registers

232
00:10:39,839 --> 00:10:42,600
and then we simply write the instruction

233
00:10:42,600 --> 00:10:46,339
for example add underscore s

234
00:10:46,339 --> 00:10:49,620
it's followed with two registers and one

235
00:10:49,620 --> 00:10:51,480
immediate value

236
00:10:51,480 --> 00:10:53,940
will appear whenever

237
00:10:53,940 --> 00:10:59,100
yidra will face this constraints in the

238
00:10:59,100 --> 00:11:03,360
in the binary so whenever it finds an

239
00:11:03,360 --> 00:11:06,420
opcode where the first fifth five bits

240
00:11:06,420 --> 00:11:09,540
are equal to zero one one zero one

241
00:11:09,540 --> 00:11:11,940
it will try to understand which

242
00:11:11,940 --> 00:11:14,399
instruction will be decoded and print

243
00:11:14,399 --> 00:11:15,839
out this instruction

244
00:11:15,839 --> 00:11:20,180
for example if we take the value 6B A1

245
00:11:20,180 --> 00:11:22,980
the binary representation of this

246
00:11:22,980 --> 00:11:25,200
instruction is given like this and this

247
00:11:25,200 --> 00:11:27,240
instruction shall be decoded in add

248
00:11:27,240 --> 00:11:31,079
underscore s r13 r301

249
00:11:31,079 --> 00:11:32,640
and I give you

250
00:11:32,640 --> 00:11:34,019
um

251
00:11:34,019 --> 00:11:37,140
explanations why either does this like

252
00:11:37,140 --> 00:11:37,920
that

253
00:11:37,920 --> 00:11:41,420
so if we come back to our binary

254
00:11:41,420 --> 00:11:46,260
I really wish to find my mouse

255
00:11:46,260 --> 00:11:48,120
yeah perfect

256
00:11:48,120 --> 00:11:50,519
so if we come back our binary

257
00:11:50,519 --> 00:11:53,240
we go to the to the instruction

258
00:11:53,240 --> 00:11:56,700
we take these two bytes since it's a

259
00:11:56,700 --> 00:12:00,240
little engine we need to swap them

260
00:12:00,240 --> 00:12:03,000
so then we will decode

261
00:12:03,000 --> 00:12:05,399
and we see that these two bytes will

262
00:12:05,399 --> 00:12:08,579
correspond to this instruction and what

263
00:12:08,579 --> 00:12:11,399
does this instruction do it adds to

264
00:12:11,399 --> 00:12:14,160
register with an immediate value

265
00:12:14,160 --> 00:12:18,120
and everything is done in gidra so this

266
00:12:18,120 --> 00:12:21,180
was written in guindra Sledge uh

267
00:12:21,180 --> 00:12:22,200
description

268
00:12:22,200 --> 00:12:25,140
and it was decoded by the the guitar

269
00:12:25,140 --> 00:12:27,600
correctly and we see

270
00:12:27,600 --> 00:12:31,200
that our well our operations that we

271
00:12:31,200 --> 00:12:33,000
Define to this instruction is really

272
00:12:33,000 --> 00:12:37,079
taken by Gideon so when we will do

273
00:12:37,079 --> 00:12:38,880
emulation

274
00:12:38,880 --> 00:12:42,839
so this is disassembly so we take binary

275
00:12:42,839 --> 00:12:46,139
we disassemble it into the instructions

276
00:12:46,139 --> 00:12:51,019
and then also we can see that our

277
00:12:51,019 --> 00:12:54,300
can decompile those instructions into C

278
00:12:54,300 --> 00:12:56,060
code

279
00:12:56,060 --> 00:12:59,820
now what we want to do is to emulate

280
00:12:59,820 --> 00:13:02,700
those instructions and emulation is done

281
00:13:02,700 --> 00:13:06,240
thanks to this uh descriptive language

282
00:13:06,240 --> 00:13:09,060
slate or B code

283
00:13:09,060 --> 00:13:12,839
and all this is defined in the

284
00:13:12,839 --> 00:13:15,180
let's say in the

285
00:13:15,180 --> 00:13:17,760
in the description language I'm sorry to

286
00:13:17,760 --> 00:13:19,500
come back and hear so all this is

287
00:13:19,500 --> 00:13:21,720
defined

288
00:13:21,720 --> 00:13:24,660
in the instruction definitions

289
00:13:24,660 --> 00:13:26,639
so I wrote

290
00:13:26,639 --> 00:13:30,120
for Arc version 2 I wrote description

291
00:13:30,120 --> 00:13:32,940
for almost all the instructions so

292
00:13:32,940 --> 00:13:35,700
nowadays Giver can disassemble and

293
00:13:35,700 --> 00:13:39,000
decompile Arc version to binaries it

294
00:13:39,000 --> 00:13:41,339
contains module the the things I wrote

295
00:13:41,339 --> 00:13:44,880
contains 5500 lines of code and there

296
00:13:44,880 --> 00:13:47,760
are 380 instructions descriptions but

297
00:13:47,760 --> 00:13:51,500
sometimes I the same instructions is

298
00:13:51,500 --> 00:13:53,940
described twice in order to optimize

299
00:13:53,940 --> 00:13:55,139
some speed

300
00:13:55,139 --> 00:13:57,839
the

301
00:13:57,839 --> 00:14:00,420
the code can be found to this address I

302
00:14:00,420 --> 00:14:02,579
will release code publicly after the

303
00:14:02,579 --> 00:14:03,720
talk

304
00:14:03,720 --> 00:14:06,300
just keep in mind that this work is

305
00:14:06,300 --> 00:14:08,100
still in progress and there are two

306
00:14:08,100 --> 00:14:09,899
classes of instructions that are not

307
00:14:09,899 --> 00:14:12,200
implemented so this

308
00:14:12,200 --> 00:14:14,700
f32x5 class is not implemented because

309
00:14:14,700 --> 00:14:17,399
it's mostly DSP it's signal processing

310
00:14:17,399 --> 00:14:22,079
class and also F32 Apex it's this class

311
00:14:22,079 --> 00:14:24,300
in Arc version 2. it can be only

312
00:14:24,300 --> 00:14:27,180
disassembled because in advance you

313
00:14:27,180 --> 00:14:28,800
don't know how this what this

314
00:14:28,800 --> 00:14:31,440
instruction does a customer who buys

315
00:14:31,440 --> 00:14:33,779
this CPU can put his own functionality

316
00:14:33,779 --> 00:14:36,180
to the instructions

317
00:14:36,180 --> 00:14:39,000
so just to conclude this first small

318
00:14:39,000 --> 00:14:40,639
part

319
00:14:40,639 --> 00:14:44,040
version 2 is quite rare CPU architecture

320
00:14:44,040 --> 00:14:46,500
not very many people I mean very few

321
00:14:46,500 --> 00:14:49,079
people take care about the question too

322
00:14:49,079 --> 00:14:52,019
you could find support in the Pro back

323
00:14:52,019 --> 00:14:54,839
in times but nowadays I hope thanks to

324
00:14:54,839 --> 00:14:57,060
the tool I developed you can also do

325
00:14:57,060 --> 00:15:00,120
reverse engineering of fact version 2.

326
00:15:00,120 --> 00:15:02,820
it's not the ultimate goal of my project

327
00:15:02,820 --> 00:15:06,300
My ultimate goal was to show you how we

328
00:15:06,300 --> 00:15:08,639
can use gindra in order to emulate the

329
00:15:08,639 --> 00:15:09,480
code

330
00:15:09,480 --> 00:15:11,459
and for this

331
00:15:11,459 --> 00:15:13,680
I invite you for the second part of the

332
00:15:13,680 --> 00:15:14,399
talk

333
00:15:14,399 --> 00:15:17,339
when we take our binary we disassemble

334
00:15:17,339 --> 00:15:19,079
it we can decompile we can reverse

335
00:15:19,079 --> 00:15:21,360
engineer it but also we can emulate the

336
00:15:21,360 --> 00:15:24,060
code and how emulation is done

337
00:15:24,060 --> 00:15:26,880
after we disassemble the code we take

338
00:15:26,880 --> 00:15:29,399
our external python script

339
00:15:29,399 --> 00:15:31,680
so it's a very simple python script I

340
00:15:31,680 --> 00:15:34,019
will show you some code examples from it

341
00:15:34,019 --> 00:15:35,399
later

342
00:15:35,399 --> 00:15:39,720
and we jump to a certain address

343
00:15:39,720 --> 00:15:42,959
and ask to execute whatever instruction

344
00:15:42,959 --> 00:15:46,079
this address does so if it's addition it

345
00:15:46,079 --> 00:15:48,120
will just basically execute addition

346
00:15:48,120 --> 00:15:50,160
we will step let's say this instruction

347
00:15:50,160 --> 00:15:53,040
and then we can step next instruction

348
00:15:53,040 --> 00:15:55,019
Etc so we can step all the instructions

349
00:15:55,019 --> 00:15:58,139
in the binary in some small space and

350
00:15:58,139 --> 00:16:02,720
this will emulate our code

351
00:16:04,019 --> 00:16:07,380
so make this emulation happen I wrote a

352
00:16:07,380 --> 00:16:08,339
small

353
00:16:08,339 --> 00:16:13,560
is 128 encryption algorithm it takes a

354
00:16:13,560 --> 00:16:16,139
fixed plain text it encrypts with the

355
00:16:16,139 --> 00:16:17,760
key which is let's say hidden inside

356
00:16:17,760 --> 00:16:21,600
tables and it gets a ciphertext this is

357
00:16:21,600 --> 00:16:24,060
a c code so it could be compiled for any

358
00:16:24,060 --> 00:16:27,480
architecture so I compiled it for x64 I

359
00:16:27,480 --> 00:16:29,420
executed and you see there as a result

360
00:16:29,420 --> 00:16:33,899
B7 C3 Etc so this is the code example

361
00:16:33,899 --> 00:16:35,760
that let's say that the highest API code

362
00:16:35,760 --> 00:16:38,639
that I wrote but the same code I also

363
00:16:38,639 --> 00:16:41,459
compiled for Arc version 2.

364
00:16:41,459 --> 00:16:44,160
and I just assembled it with a tool that

365
00:16:44,160 --> 00:16:47,399
I developed so this is a disassembly and

366
00:16:47,399 --> 00:16:50,000
this is a decompilation of our

367
00:16:50,000 --> 00:16:54,199
is you can actually see that Jesus

368
00:16:54,199 --> 00:16:59,759
decompulation of the test encryption

369
00:16:59,759 --> 00:17:02,699
yeah it's it's quite similar to the

370
00:17:02,699 --> 00:17:04,199
original code

371
00:17:04,199 --> 00:17:07,740
so the compilation really looks like SC

372
00:17:07,740 --> 00:17:08,939
code

373
00:17:08,939 --> 00:17:11,339
and it can only be achieved if we

374
00:17:11,339 --> 00:17:13,559
correctly implemented instructions like

375
00:17:13,559 --> 00:17:15,119
correctly you've described what

376
00:17:15,119 --> 00:17:16,859
instruction does

377
00:17:16,859 --> 00:17:19,439
just keep in mind that if there are some

378
00:17:19,439 --> 00:17:21,059
complex instructions I don't know if

379
00:17:21,059 --> 00:17:22,439
there are let's say there is an

380
00:17:22,439 --> 00:17:23,819
instruction which modifies many

381
00:17:23,819 --> 00:17:26,280
registers and jumps somewhere and does

382
00:17:26,280 --> 00:17:28,079
something else for githra it's very

383
00:17:28,079 --> 00:17:30,000
complicated to do the compilation after

384
00:17:30,000 --> 00:17:31,559
so it can disassemble but the

385
00:17:31,559 --> 00:17:34,520
calculation is pretty hard for Gita

386
00:17:34,520 --> 00:17:38,160
and this how my python script looks like

387
00:17:38,160 --> 00:17:40,320
for emulation it's very simple

388
00:17:40,320 --> 00:17:43,919
so if I want to emulate my binary I

389
00:17:43,919 --> 00:17:45,600
basically

390
00:17:45,600 --> 00:17:48,120
set some stack pointer it can be

391
00:17:48,120 --> 00:17:51,179
whatever value I want I initialize some

392
00:17:51,179 --> 00:17:53,400
memory if it required for example I can

393
00:17:53,400 --> 00:17:54,840
write plain text or I can write

394
00:17:54,840 --> 00:17:56,880
ciphertext to do something else

395
00:17:56,880 --> 00:18:00,539
I also Define registers of the CPU

396
00:18:00,539 --> 00:18:03,120
and also Define some success exit

397
00:18:03,120 --> 00:18:04,679
conditions so whenever I reach certain

398
00:18:04,679 --> 00:18:07,080
point I know I know that my program is

399
00:18:07,080 --> 00:18:08,700
finished

400
00:18:08,700 --> 00:18:11,100
and the emulation is done like a simple

401
00:18:11,100 --> 00:18:13,980
Loop so I go to the address

402
00:18:13,980 --> 00:18:16,440
and I step into instruction so like this

403
00:18:16,440 --> 00:18:18,539
all the emulation is going to happen

404
00:18:18,539 --> 00:18:21,240
it's very simple

405
00:18:21,240 --> 00:18:23,460
and with this simulation

406
00:18:23,460 --> 00:18:25,500
I will show you

407
00:18:25,500 --> 00:18:28,620
for example this is a test test

408
00:18:28,620 --> 00:18:31,039
I don't see it very well on my laptop

409
00:18:31,039 --> 00:18:34,860
yes it's a entry to the test encryption

410
00:18:34,860 --> 00:18:37,020
so this is the first instruction where I

411
00:18:37,020 --> 00:18:39,900
will emulate and on this slide I show

412
00:18:39,900 --> 00:18:41,880
how emulation looks like

413
00:18:41,880 --> 00:18:44,480
so first I print out my instruction

414
00:18:44,480 --> 00:18:46,980
enter s

415
00:18:46,980 --> 00:18:50,520
then I print out the CPU stack which

416
00:18:50,520 --> 00:18:53,340
exact which is exactly at this moment of

417
00:18:53,340 --> 00:18:55,740
instruction which exactly moment of time

418
00:18:55,740 --> 00:18:58,320
I also print out all the CPU registers

419
00:18:58,320 --> 00:19:00,919
and I highlight by Red here

420
00:19:00,919 --> 00:19:03,539
registers that are used by instructions

421
00:19:03,539 --> 00:19:06,299
and also I show the new and all the

422
00:19:06,299 --> 00:19:09,900
values after the instruction execution

423
00:19:09,900 --> 00:19:14,460
I also use for example some CPU flux Etc

424
00:19:14,460 --> 00:19:16,679
so I can print a lot of information from

425
00:19:16,679 --> 00:19:19,080
my emulation for example enter

426
00:19:19,080 --> 00:19:22,020
underscore s what it will do it will

427
00:19:22,020 --> 00:19:25,200
push the register to the stacks to to

428
00:19:25,200 --> 00:19:27,360
registers to a stock

429
00:19:27,360 --> 00:19:29,760
we see that this registers stop push

430
00:19:29,760 --> 00:19:32,220
indeed and also it will decrease the

431
00:19:32,220 --> 00:19:34,980
stack pointer value so indeed we see

432
00:19:34,980 --> 00:19:38,220
that our python script thanks to gidra

433
00:19:38,220 --> 00:19:41,940
can emulate enter underscore s correctly

434
00:19:41,940 --> 00:19:44,580
so like this we can step all other

435
00:19:44,580 --> 00:19:47,100
instructions for example I give another

436
00:19:47,100 --> 00:19:50,280
example a certain moment of time we will

437
00:19:50,280 --> 00:19:51,419
enter

438
00:19:51,419 --> 00:19:52,140
um

439
00:19:52,140 --> 00:19:55,260
and other functions called Cipher

440
00:19:55,260 --> 00:19:57,059
underscore Unit 8

441
00:19:57,059 --> 00:19:59,460
it's it will happen a bit later in the

442
00:19:59,460 --> 00:20:01,140
execution

443
00:20:01,140 --> 00:20:03,600
when it will happen our stock is going

444
00:20:03,600 --> 00:20:05,280
to be already populated and some

445
00:20:05,280 --> 00:20:07,200
registers of the CPU will be different

446
00:20:07,200 --> 00:20:10,500
and that's exactly what we see so when

447
00:20:10,500 --> 00:20:12,600
we will execute entry to this

448
00:20:12,600 --> 00:20:14,640
instruction it's going to happen at

449
00:20:14,640 --> 00:20:15,620
instruction

450
00:20:15,620 --> 00:20:18,980
109 from the beginning so we emulated

451
00:20:18,980 --> 00:20:21,780
109th instruction before

452
00:20:21,780 --> 00:20:23,760
we see that our stock is already

453
00:20:23,760 --> 00:20:26,220
populated with a plain text

454
00:20:26,220 --> 00:20:30,179
and again we can see that the the same

455
00:20:30,179 --> 00:20:33,840
some registers pushed to stock Etc so

456
00:20:33,840 --> 00:20:35,960
like this we will execute step by step

457
00:20:35,960 --> 00:20:40,679
until we get our ciphertext

458
00:20:40,679 --> 00:20:43,559
in the console printing so I take the

459
00:20:43,559 --> 00:20:46,260
ciphertext from the stack and I print it

460
00:20:46,260 --> 00:20:49,980
here so like this we can take

461
00:20:49,980 --> 00:20:54,000
whatever uh exotic CPU architecture we

462
00:20:54,000 --> 00:20:56,460
can find it can be Arc version 2 where

463
00:20:56,460 --> 00:20:58,200
it can be some proprietary architecture

464
00:20:58,200 --> 00:21:01,020
and with gidra we can run the code

465
00:21:01,020 --> 00:21:04,320
inside it so we don't need actual device

466
00:21:04,320 --> 00:21:07,500
I found it's quite nice and Powerful

467
00:21:07,500 --> 00:21:09,179
in addition we can do reverse

468
00:21:09,179 --> 00:21:10,980
engineering and we can understand like

469
00:21:10,980 --> 00:21:12,900
with thanks to the compilation what

470
00:21:12,900 --> 00:21:15,020
exactly is going on

471
00:21:15,020 --> 00:21:18,660
so this I found this very powerful

472
00:21:18,660 --> 00:21:22,320
for example at the end of the

473
00:21:22,320 --> 00:21:26,460
is execution my ciphertext is going to

474
00:21:26,460 --> 00:21:28,260
be written after the plain text which is

475
00:21:28,260 --> 00:21:31,260
very logical and you see it's B7 C3

476
00:21:31,260 --> 00:21:34,260
exactly the same values that we got for

477
00:21:34,260 --> 00:21:38,460
x 64 compilation

478
00:21:40,260 --> 00:21:42,659
so now I would like to switch to The

479
00:21:42,659 --> 00:21:46,679
Fault injection so we saw that gidra can

480
00:21:46,679 --> 00:21:49,320
run certain parts of the code so I could

481
00:21:49,320 --> 00:21:52,500
execute is in gidra without actual

482
00:21:52,500 --> 00:21:53,760
device

483
00:21:53,760 --> 00:21:56,460
now I want to show how we can use it in

484
00:21:56,460 --> 00:21:58,860
order to inject faults

485
00:21:58,860 --> 00:22:01,080
just to give you a bit of insight

486
00:22:01,080 --> 00:22:02,880
so faults can be used to attack

487
00:22:02,880 --> 00:22:05,220
cryptographic algorithms it was shown in

488
00:22:05,220 --> 00:22:08,520
the presentation of Nikola and Sylvan

489
00:22:08,520 --> 00:22:11,159
and I'm using what is called white box

490
00:22:11,159 --> 00:22:13,140
cryptography I'm not going to dip to

491
00:22:13,140 --> 00:22:15,419
dive into details about lightbox crypto

492
00:22:15,419 --> 00:22:18,539
but it's a specific way to implement a

493
00:22:18,539 --> 00:22:21,240
cryptographic algorithms where you hide

494
00:22:21,240 --> 00:22:23,400
the key inside permutations inside

495
00:22:23,400 --> 00:22:26,520
tables so you don't see key and clear

496
00:22:26,520 --> 00:22:29,460
whitebox crypto nowadays quite commonly

497
00:22:29,460 --> 00:22:33,659
used in in ctfs also for example why the

498
00:22:33,659 --> 00:22:36,260
Box crypto is used in um

499
00:22:36,260 --> 00:22:40,320
grms Google white wine using a white box

500
00:22:40,320 --> 00:22:43,320
in the level 3 of the protection

501
00:22:43,320 --> 00:22:45,480
so it's it's let's say used there are

502
00:22:45,480 --> 00:22:47,280
common attacks on White box crypto its

503
00:22:47,280 --> 00:22:48,900
differential fault attacks the one I'm

504
00:22:48,900 --> 00:22:51,120
going to show you but also you can do

505
00:22:51,120 --> 00:22:52,860
reverse engineering against mathematical

506
00:22:52,860 --> 00:22:55,080
tricks and also there is a differential

507
00:22:55,080 --> 00:22:58,140
computation analysis

508
00:22:58,140 --> 00:23:00,000
um the very the basic idea of the attack

509
00:23:00,000 --> 00:23:02,820
so inside is you cannot reverse order of

510
00:23:02,820 --> 00:23:05,220
operations so operations are kind of the

511
00:23:05,220 --> 00:23:06,000
same

512
00:23:06,000 --> 00:23:08,820
so if you inject the fault just before

513
00:23:08,820 --> 00:23:11,760
last mixed column operation of in one

514
00:23:11,760 --> 00:23:14,280
byte this fault is injected in one byte

515
00:23:14,280 --> 00:23:17,880
then this fault will modify only four

516
00:23:17,880 --> 00:23:20,900
bytes on the of the output ciphertext

517
00:23:20,900 --> 00:23:24,059
and by comparing correct and faulty

518
00:23:24,059 --> 00:23:25,740
Cipher text and by redoing some

519
00:23:25,740 --> 00:23:27,299
reversing some mathematical operations

520
00:23:27,299 --> 00:23:29,400
we can find the kitten

521
00:23:29,400 --> 00:23:32,340
so like this we can make an attack

522
00:23:32,340 --> 00:23:34,919
there are very common tools to do it so

523
00:23:34,919 --> 00:23:36,600
most probably you've heard of side

524
00:23:36,600 --> 00:23:38,760
Channel models it's a tool from Philip

525
00:23:38,760 --> 00:23:40,559
toewan and it's one of the most popular

526
00:23:40,559 --> 00:23:42,299
tool to make this kind of operations

527
00:23:42,299 --> 00:23:46,500
it's based on instrumentation Intel pin

528
00:23:46,500 --> 00:23:48,960
or Val grid so it's one of the way of

529
00:23:48,960 --> 00:23:51,720
doing this riskier also released their

530
00:23:51,720 --> 00:23:54,419
own tool based on qmu to do exactly the

531
00:23:54,419 --> 00:23:56,600
same

532
00:23:59,360 --> 00:24:02,159
and you can find it it's based on radar

533
00:24:02,159 --> 00:24:04,919
2 and nowadays with this let's say

534
00:24:04,919 --> 00:24:07,559
support of gibra we can do the same in

535
00:24:07,559 --> 00:24:11,220
general so basically I uh contribute a

536
00:24:11,220 --> 00:24:14,280
bit in this tool sets

537
00:24:14,280 --> 00:24:16,740
when we speak about faults so when we

538
00:24:16,740 --> 00:24:18,720
take a device and we try to inject the

539
00:24:18,720 --> 00:24:20,940
fault electromagnetic power so glitch or

540
00:24:20,940 --> 00:24:23,640
whatever we don't know in advance which

541
00:24:23,640 --> 00:24:25,740
effects we are going to achieve it can

542
00:24:25,740 --> 00:24:27,240
be instruction skipping register

543
00:24:27,240 --> 00:24:30,299
modification or whatever

544
00:24:30,299 --> 00:24:32,640
we don't know so we sometimes we

545
00:24:32,640 --> 00:24:34,380
observed very exotic faults in practice

546
00:24:34,380 --> 00:24:37,860
however very common for CPU we observe

547
00:24:37,860 --> 00:24:40,380
two effects it's an instruction skipping

548
00:24:40,380 --> 00:24:41,940
and a second one it's a register

549
00:24:41,940 --> 00:24:44,280
modification and I'm going to show you

550
00:24:44,280 --> 00:24:46,559
emulation for gidra of these two

551
00:24:46,559 --> 00:24:49,740
specific faults so if in our binary we

552
00:24:49,740 --> 00:24:52,919
want to again my mouse we want to skip

553
00:24:52,919 --> 00:24:53,900
an instruction

554
00:24:53,900 --> 00:24:55,860
basically we will take the current

555
00:24:55,860 --> 00:24:58,380
instruction we will read next

556
00:24:58,380 --> 00:25:00,240
instruction address

557
00:25:00,240 --> 00:25:03,000
we this we will write this address in

558
00:25:03,000 --> 00:25:04,980
the program counter and then we will

559
00:25:04,980 --> 00:25:07,860
continue our Loop without executing

560
00:25:07,860 --> 00:25:10,679
anything Excel without emulating our

561
00:25:10,679 --> 00:25:12,240
current instruction

562
00:25:12,240 --> 00:25:15,000
it spreads as simple I would say

563
00:25:15,000 --> 00:25:19,799
and when I applied this trick to my is

564
00:25:19,799 --> 00:25:22,080
binary

565
00:25:22,080 --> 00:25:25,380
for this is an instruction skipping so

566
00:25:25,380 --> 00:25:26,880
you will see

567
00:25:26,880 --> 00:25:29,880
which instruction is skipped so this

568
00:25:29,880 --> 00:25:32,220
instruction 250 from the beginning of

569
00:25:32,220 --> 00:25:34,919
emulation this instruction is located at

570
00:25:34,919 --> 00:25:38,640
that oh my gosh at this address

571
00:25:38,640 --> 00:25:40,860
and this is a mnemonic of the

572
00:25:40,860 --> 00:25:42,900
instruction and if we skip it actually

573
00:25:42,900 --> 00:25:45,480
nothing happens it can happen I mean if

574
00:25:45,480 --> 00:25:46,679
we inject the fault into device

575
00:25:46,679 --> 00:25:49,020
sometimes it doesn't happen the same for

576
00:25:49,020 --> 00:25:51,900
for for the binary if we skip an

577
00:25:51,900 --> 00:25:54,059
instruction which does nothing

578
00:25:54,059 --> 00:25:56,460
it doesn't affect our final result

579
00:25:56,460 --> 00:25:59,159
however later for example at instruction

580
00:25:59,159 --> 00:26:03,059
700 when we inject instruction skipping

581
00:26:03,059 --> 00:26:05,340
I'm sorry I need to do step back and

582
00:26:05,340 --> 00:26:07,620
explain that this is a correct

583
00:26:07,620 --> 00:26:10,260
ciphertext so this is what we expect to

584
00:26:10,260 --> 00:26:13,559
see this ciphertext is what we obtain

585
00:26:13,559 --> 00:26:16,500
due to a fault injection so we had this

586
00:26:16,500 --> 00:26:19,260
ciphertext before without any fault

587
00:26:19,260 --> 00:26:22,140
injection this ciphertext we get with

588
00:26:22,140 --> 00:26:24,840
the fault injection and this one is the

589
00:26:24,840 --> 00:26:27,299
difference between two draw of them so

590
00:26:27,299 --> 00:26:28,980
it's the next door

591
00:26:28,980 --> 00:26:31,620
so here when we skip instruction at 700

592
00:26:31,620 --> 00:26:34,140
we see that our ciphertext is totally

593
00:26:34,140 --> 00:26:36,299
different xor is totally different let's

594
00:26:36,299 --> 00:26:39,559
say however if we skip instruction in

595
00:26:39,559 --> 00:26:43,200
1250 we see that there is actually an

596
00:26:43,200 --> 00:26:45,480
interesting diagonal and it's exactly

597
00:26:45,480 --> 00:26:48,059
the fault model we are looking for so

598
00:26:48,059 --> 00:26:50,159
there are four bytes modified so go on

599
00:26:50,159 --> 00:26:52,320
to three four so a lying on kind of a

600
00:26:52,320 --> 00:26:55,020
diagonal and this kind of faults can be

601
00:26:55,020 --> 00:26:57,179
used to attack a yes so we can get is

602
00:26:57,179 --> 00:27:00,840
cryptographic thanks to those faults

603
00:27:00,840 --> 00:27:02,039
[Music]

604
00:27:02,039 --> 00:27:04,799
if we want to modify register it's also

605
00:27:04,799 --> 00:27:07,200
very simple we basically take a register

606
00:27:07,200 --> 00:27:09,380
we

607
00:27:09,380 --> 00:27:12,360
write a new value so we extort it with 0

608
00:27:12,360 --> 00:27:14,400
1 for example we write this register

609
00:27:14,400 --> 00:27:15,360
back

610
00:27:15,360 --> 00:27:17,159
and we read it again just to be sure

611
00:27:17,159 --> 00:27:20,340
that it the modification really took

612
00:27:20,340 --> 00:27:21,240
place

613
00:27:21,240 --> 00:27:25,200
and like this we can do again fault

614
00:27:25,200 --> 00:27:27,900
injection I did it exactly in the same

615
00:27:27,900 --> 00:27:30,120
instructions as before

616
00:27:30,120 --> 00:27:32,820
and we can see again that this

617
00:27:32,820 --> 00:27:34,740
instruction doesn't change it doesn't

618
00:27:34,740 --> 00:27:37,799
change anything if we modify registered

619
00:27:37,799 --> 00:27:40,320
this step it will completely corrupt our

620
00:27:40,320 --> 00:27:43,020
Cipher text and here we have a diagonal

621
00:27:43,020 --> 00:27:45,000
but with different values

622
00:27:45,000 --> 00:27:48,720
so it just shows these fault models and

623
00:27:48,720 --> 00:27:50,880
this fault emulation shows how we can

624
00:27:50,880 --> 00:27:54,059
inject faults in the in the binary

625
00:27:54,059 --> 00:27:56,400
however we are not limited with what I'm

626
00:27:56,400 --> 00:27:58,020
presenting for example

627
00:27:58,020 --> 00:28:00,240
you can imagine a situation that you

628
00:28:00,240 --> 00:28:01,980
have a

629
00:28:01,980 --> 00:28:04,620
signature computation over a small part

630
00:28:04,620 --> 00:28:07,140
of the code and then you have a check

631
00:28:07,140 --> 00:28:09,539
which checks if your signature is

632
00:28:09,539 --> 00:28:11,820
correct or not so with default emulation

633
00:28:11,820 --> 00:28:14,279
you can try to bypass this

634
00:28:14,279 --> 00:28:16,980
check and understand at which moment of

635
00:28:16,980 --> 00:28:17,880
time

636
00:28:17,880 --> 00:28:20,340
in the execution of the real device you

637
00:28:20,340 --> 00:28:23,240
need to inject the fault

638
00:28:24,299 --> 00:28:27,539
application of emulation is not limited

639
00:28:27,539 --> 00:28:29,640
to faults

640
00:28:29,640 --> 00:28:33,600
for example there is a nice work which

641
00:28:33,600 --> 00:28:36,720
uses gidra emulation for fuzzing so we

642
00:28:36,720 --> 00:28:39,120
can run our binary and we can use

643
00:28:39,120 --> 00:28:43,080
fuzzing with IFL American fuzzing logic

644
00:28:43,080 --> 00:28:46,140
we can also do attack on whitebox crypto

645
00:28:46,140 --> 00:28:50,159
again but we can use the simulation in

646
00:28:50,159 --> 00:28:52,679
order to optimize our algorithm or in

647
00:28:52,679 --> 00:28:56,480
order to check certain properties

648
00:28:57,419 --> 00:28:59,940
just to conclude this talk

649
00:28:59,940 --> 00:29:03,740
so givera emulation

650
00:29:03,779 --> 00:29:04,620
um

651
00:29:04,620 --> 00:29:08,220
is very useful I find it super useful

652
00:29:08,220 --> 00:29:10,559
um any exotic instruction set for

653
00:29:10,559 --> 00:29:12,720
example Arc version 2 can be relatively

654
00:29:12,720 --> 00:29:16,140
easy added to gidra so we can do reverse

655
00:29:16,140 --> 00:29:18,840
engineering the compilation

656
00:29:18,840 --> 00:29:22,020
and also we can do emulation of this

657
00:29:22,020 --> 00:29:25,799
nowadays gidra will have Arc version to

658
00:29:25,799 --> 00:29:27,179
support so

659
00:29:27,179 --> 00:29:30,360
I I have released it but I'm going to

660
00:29:30,360 --> 00:29:32,760
continue the support of this tool

661
00:29:32,760 --> 00:29:35,039
and this talk presented also how we can

662
00:29:35,039 --> 00:29:37,380
use this simulation in order to attack

663
00:29:37,380 --> 00:29:38,580
is

664
00:29:38,580 --> 00:29:41,220
I give you some couple of useful links

665
00:29:41,220 --> 00:29:44,220
which you can which you can check if you

666
00:29:44,220 --> 00:29:45,659
wish

667
00:29:45,659 --> 00:29:48,179
pretty much that's all for my talk I

668
00:29:48,179 --> 00:29:50,100
would like to show you a couple of

669
00:29:50,100 --> 00:29:52,559
examples like practical emulation like

670
00:29:52,559 --> 00:29:55,799
briefly to show how githra works so I

671
00:29:55,799 --> 00:29:58,260
will try to do it

672
00:29:58,260 --> 00:30:01,460
tick tick tick

673
00:30:03,059 --> 00:30:06,720
do all perfect you see it

674
00:30:06,720 --> 00:30:11,059
so this is exactly the is

675
00:30:11,120 --> 00:30:13,500
binary that I was

676
00:30:13,500 --> 00:30:15,059
using

677
00:30:15,059 --> 00:30:17,600
so on the right you see the

678
00:30:17,600 --> 00:30:20,580
decompilation of my code

679
00:30:20,580 --> 00:30:22,860
and we can jump for example in the side

680
00:30:22,860 --> 00:30:24,419
for you and eight

681
00:30:24,419 --> 00:30:27,779
we can go deeper and observe

682
00:30:27,779 --> 00:30:30,120
how the compilation is done

683
00:30:30,120 --> 00:30:32,940
so on the middle window let's say you

684
00:30:32,940 --> 00:30:34,740
see the disassembly

685
00:30:34,740 --> 00:30:36,779
and we can

686
00:30:36,779 --> 00:30:38,340
show

687
00:30:38,340 --> 00:30:42,000
what every instruction does in reality

688
00:30:42,000 --> 00:30:44,880
for example when we use enter s we need

689
00:30:44,880 --> 00:30:46,919
to push the registers into the stack and

690
00:30:46,919 --> 00:30:48,779
we can read it here

691
00:30:48,779 --> 00:30:53,100
so in order to emulate the code

692
00:30:53,100 --> 00:30:54,779
I have a small

693
00:30:54,779 --> 00:30:58,860
python binary which does the simulation

694
00:30:58,860 --> 00:31:02,520
so what I will do I will go to script

695
00:31:02,520 --> 00:31:07,220
manager and then run this

696
00:31:07,320 --> 00:31:10,320
it will create few files for me to have

697
00:31:10,320 --> 00:31:11,220
them

698
00:31:11,220 --> 00:31:14,760
the logs and it also will play print out

699
00:31:14,760 --> 00:31:17,640
the ciphertext and now if I want to see

700
00:31:17,640 --> 00:31:21,260
the locks they are here

701
00:31:21,659 --> 00:31:24,179
so every single instruction which was

702
00:31:24,179 --> 00:31:27,240
execute executed contains printings of

703
00:31:27,240 --> 00:31:30,539
stock contain printings of the CPU

704
00:31:30,539 --> 00:31:33,899
registers Etc we can we can monitor

705
00:31:33,899 --> 00:31:36,779
every instruction you wish so these are

706
00:31:36,779 --> 00:31:37,919
all of them

707
00:31:37,919 --> 00:31:40,620
if we go to the very end

708
00:31:40,620 --> 00:31:43,620
we see how our stack is populated

709
00:31:43,620 --> 00:31:47,719
now if I want to inject false

710
00:31:48,600 --> 00:31:53,299
simplify I basically will do like this

711
00:31:59,039 --> 00:32:01,440
so now I will inject faults in every

712
00:32:01,440 --> 00:32:04,500
single possible instruction of my is I

713
00:32:04,500 --> 00:32:06,720
think it's an instruction skipping and

714
00:32:06,720 --> 00:32:09,659
then I can analyze whatever I want so

715
00:32:09,659 --> 00:32:11,279
for example if I inject fault

716
00:32:11,279 --> 00:32:14,340
instruction 900 my ciphertext is totally

717
00:32:14,340 --> 00:32:19,159
corrupted but if I go below whatever

718
00:32:19,159 --> 00:32:21,659
here for example

719
00:32:21,659 --> 00:32:26,100
if I go here you see that my fault

720
00:32:26,100 --> 00:32:28,020
injection caused some diagonal

721
00:32:28,020 --> 00:32:30,960
modification which is super nice

722
00:32:30,960 --> 00:32:33,600
this is an instruction skipping and if I

723
00:32:33,600 --> 00:32:36,539
want to to have one

724
00:32:36,539 --> 00:32:38,820
I know this is one bit fold but if I

725
00:32:38,820 --> 00:32:40,320
want to have an instruction skipping I

726
00:32:40,320 --> 00:32:42,120
just basically uncomment

727
00:32:42,120 --> 00:32:44,580
inside my plugin

728
00:32:44,580 --> 00:32:47,100
and again execute the

729
00:32:47,100 --> 00:32:48,720
emulation

730
00:32:48,720 --> 00:32:51,840
and you can see it's relatively fast

731
00:32:51,840 --> 00:32:54,840
so that's pretty much all for my talk

732
00:32:54,840 --> 00:32:58,559
thank you for for your time and I hope

733
00:32:58,559 --> 00:33:01,639
you don't fall asleep

