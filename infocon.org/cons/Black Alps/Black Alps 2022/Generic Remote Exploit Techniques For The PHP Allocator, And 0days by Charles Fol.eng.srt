1
00:00:02,820 --> 00:00:04,560
okay thank you

2
00:00:04,560 --> 00:00:06,240
um so I'm going to talk about the PHP

3
00:00:06,240 --> 00:00:08,039
allocator yes but I'm going to talk

4
00:00:08,039 --> 00:00:10,320
about how you can exploit uh remote

5
00:00:10,320 --> 00:00:14,160
binary bugs onto PHP as well so that's

6
00:00:14,160 --> 00:00:17,100
the important part I'm gonna illustrate

7
00:00:17,100 --> 00:00:19,859
with one zero day maybe one like another

8
00:00:19,859 --> 00:00:23,820
one if we have time but one should be

9
00:00:23,820 --> 00:00:25,939
enough

10
00:00:26,060 --> 00:00:29,220
so we are really quickly we are a French

11
00:00:29,220 --> 00:00:31,439
offensive security company called lex4

12
00:00:31,439 --> 00:00:34,079
we are based in France and we have two

13
00:00:34,079 --> 00:00:36,420
technical blogs one about Canada and

14
00:00:36,420 --> 00:00:37,700
system which is

15
00:00:37,700 --> 00:00:40,379
blood.lexo.fr and mode which is more

16
00:00:40,379 --> 00:00:42,320
about web exploitation which is

17
00:00:42,320 --> 00:00:45,980
ambionics.io blog

18
00:00:46,320 --> 00:00:48,899
um well PHP and I have been feeling with

19
00:00:48,899 --> 00:00:52,379
PHP for another 15 years I really like

20
00:00:52,379 --> 00:00:57,199
the language for exploiting it uh

21
00:00:57,899 --> 00:01:01,140
I've found a lot of bugs on like

22
00:01:01,140 --> 00:01:03,480
standard Frameworks such as Drupal

23
00:01:03,480 --> 00:01:06,180
Magento stuff like this but I'm also

24
00:01:06,180 --> 00:01:08,520
into binary exploitation as I was sure

25
00:01:08,520 --> 00:01:11,760
today uh I've published a few sandbox

26
00:01:11,760 --> 00:01:14,520
Escape bugs you might think that sandbox

27
00:01:14,520 --> 00:01:17,760
Escape in PHP is useless it basically is

28
00:01:17,760 --> 00:01:20,580
but sometimes it's useful because in PHP

29
00:01:20,580 --> 00:01:23,520
you could have like disable disabled

30
00:01:23,520 --> 00:01:25,799
functions so you find a RCA on the

31
00:01:25,799 --> 00:01:27,240
website and you cannot execute any

32
00:01:27,240 --> 00:01:29,700
function so it's pretty annoying so

33
00:01:29,700 --> 00:01:31,500
using a Sandbox Escape bug you can

34
00:01:31,500 --> 00:01:33,960
actually call any function you want

35
00:01:33,960 --> 00:01:36,600
also it's useful to get access to the

36
00:01:36,600 --> 00:01:39,180
process that is executing PHP and if you

37
00:01:39,180 --> 00:01:41,100
get access to this process maybe you can

38
00:01:41,100 --> 00:01:43,320
access the master process that runs as

39
00:01:43,320 --> 00:01:45,720
fruits and this way you can probably get

40
00:01:45,720 --> 00:01:49,380
a local route on Apache or on PHP fpm so

41
00:01:49,380 --> 00:01:52,740
that's why I did a long time ago and

42
00:01:52,740 --> 00:01:55,259
also maintain a PHP GGC which is

43
00:01:55,259 --> 00:01:57,659
basically why so serial but for PHP so

44
00:01:57,659 --> 00:01:59,700
it celebrates payload for entire life

45
00:01:59,700 --> 00:02:02,360
which is php's digitalization function

46
00:02:02,360 --> 00:02:05,219
decoded and serialized for some reason

47
00:02:05,219 --> 00:02:08,940
foreign so a quick history of PHP and

48
00:02:08,940 --> 00:02:10,860
binary bugs

49
00:02:10,860 --> 00:02:13,020
as you know PHP security is pretty

50
00:02:13,020 --> 00:02:15,180
approximative

51
00:02:15,180 --> 00:02:17,900
like the comparison here returns true

52
00:02:17,900 --> 00:02:21,660
it's a hash and a float and it says true

53
00:02:21,660 --> 00:02:24,540
for some reason and there have been like

54
00:02:24,540 --> 00:02:26,280
lots of bugs that are still in patch

55
00:02:26,280 --> 00:02:27,840
because PHP doesn't really care if the

56
00:02:27,840 --> 00:02:30,480
bug has to be exploited locally

57
00:02:30,480 --> 00:02:32,940
so you have many sandbox Escape bugs

58
00:02:32,940 --> 00:02:35,879
over the Internet the thing is you don't

59
00:02:35,879 --> 00:02:38,459
really have remote exploits available in

60
00:02:38,459 --> 00:02:41,099
over the Internet so I'm gonna try and

61
00:02:41,099 --> 00:02:43,579
change this

62
00:02:43,620 --> 00:02:45,900
um so what kind of bugs can we find in

63
00:02:45,900 --> 00:02:48,360
PHP work PHP is a weekly type scripting

64
00:02:48,360 --> 00:02:50,640
language so it needs to type check and

65
00:02:50,640 --> 00:02:52,860
wave count variables properly otherwise

66
00:02:52,860 --> 00:02:55,260
you can have bugs such as type confusion

67
00:02:55,260 --> 00:02:57,300
where for instance an array is used

68
00:02:57,300 --> 00:02:59,819
instead of a string and use after three

69
00:02:59,819 --> 00:03:01,800
bugs where something is free then you

70
00:03:01,800 --> 00:03:03,420
can fill out the memory with something

71
00:03:03,420 --> 00:03:05,280
else and then you get some kind of

72
00:03:05,280 --> 00:03:06,540
primitive right

73
00:03:06,540 --> 00:03:08,340
so it's very easy to export locally

74
00:03:08,340 --> 00:03:09,959
because you're just writing code so that

75
00:03:09,959 --> 00:03:12,900
would be basically the same as writing a

76
00:03:12,900 --> 00:03:14,879
JavaScript renderer exploit you're just

77
00:03:14,879 --> 00:03:17,700
writing PHP so you can set up for the

78
00:03:17,700 --> 00:03:19,440
bug for instance you can like create the

79
00:03:19,440 --> 00:03:21,360
e-player that you want then you can

80
00:03:21,360 --> 00:03:22,860
trigger the bug for instance you create

81
00:03:22,860 --> 00:03:25,800
an object and call some function that is

82
00:03:25,800 --> 00:03:27,720
vulnerable and then you can use the bug

83
00:03:27,720 --> 00:03:29,099
you have your primitive and then you

84
00:03:29,099 --> 00:03:30,480
want to get like called execution with

85
00:03:30,480 --> 00:03:34,319
the bug so locally pretty easy to do

86
00:03:34,319 --> 00:03:36,540
however remotely it gets a little bit

87
00:03:36,540 --> 00:03:40,080
harder one thing is really annoying when

88
00:03:40,080 --> 00:03:42,540
PHP creates a like receives a request it

89
00:03:42,540 --> 00:03:45,060
will create a heap allocate your inputs

90
00:03:45,060 --> 00:03:48,299
so get post cookies stuff like this and

91
00:03:48,299 --> 00:03:49,860
then it will run the code and then

92
00:03:49,860 --> 00:03:52,739
discard the Eep entirely so if you have

93
00:03:52,739 --> 00:03:55,440
a new uif for instance so use after free

94
00:03:55,440 --> 00:03:58,980
well it will be gone uh after the record

95
00:03:58,980 --> 00:04:02,400
the request has been executed so you

96
00:04:02,400 --> 00:04:04,260
have to find a bug you have to find a

97
00:04:04,260 --> 00:04:07,920
CMS or framework that actually uses the

98
00:04:07,920 --> 00:04:10,080
function that has the bug then you have

99
00:04:10,080 --> 00:04:12,299
to find a way to trigger it and then you

100
00:04:12,299 --> 00:04:14,580
have to use the bug afterwards all in

101
00:04:14,580 --> 00:04:17,339
the same request so it gets pretty hard

102
00:04:17,339 --> 00:04:20,279
also you have a few limitations since

103
00:04:20,279 --> 00:04:22,740
it's a data that is sent over HTTP you

104
00:04:22,740 --> 00:04:24,900
have limitations on the size and you

105
00:04:24,900 --> 00:04:27,419
have limitations on the types you can

106
00:04:27,419 --> 00:04:29,720
usually only send like strings or arrays

107
00:04:29,720 --> 00:04:33,600
luckily the those are the two types that

108
00:04:33,600 --> 00:04:35,400
we need to exploit so it's

109
00:04:35,400 --> 00:04:38,759
perfect voice we also have to beat ASL

110
00:04:38,759 --> 00:04:41,520
and buy remotely obviously and we have

111
00:04:41,520 --> 00:04:44,280
one thing going for us uh crashes are

112
00:04:44,280 --> 00:04:45,780
pretty much okay because there's always

113
00:04:45,780 --> 00:04:47,699
been going to be always sorry gonna be

114
00:04:47,699 --> 00:04:49,800
your main process the main process runs

115
00:04:49,800 --> 00:04:52,440
as roots whenever you crash a walker is

116
00:04:52,440 --> 00:04:54,780
going to be respond automatically uh the

117
00:04:54,780 --> 00:04:56,280
main process doesn't really care it just

118
00:04:56,280 --> 00:04:58,919
responds it if it crashes and also that

119
00:04:58,919 --> 00:05:01,919
means that the every worker has the same

120
00:05:01,919 --> 00:05:05,639
aslr and by randomization so if you can

121
00:05:05,639 --> 00:05:08,580
leak the aslr in one worker you're gonna

122
00:05:08,580 --> 00:05:11,820
have the same aslr in the other worker

123
00:05:11,820 --> 00:05:15,000
so to illustrate a little bit when you

124
00:05:15,000 --> 00:05:16,440
do a remote exploit generally you're

125
00:05:16,440 --> 00:05:17,820
going to have a few steps a few

126
00:05:17,820 --> 00:05:19,500
interactions and you're going to set up

127
00:05:19,500 --> 00:05:21,479
the Eep get some kind of leak with some

128
00:05:21,479 --> 00:05:24,720
bug then set up the memory get some kind

129
00:05:24,720 --> 00:05:27,000
of Auto bug and then probably like spray

130
00:05:27,000 --> 00:05:29,340
the Eep to put your object instead and

131
00:05:29,340 --> 00:05:32,280
then get some kind of shell in PHP well

132
00:05:32,280 --> 00:05:34,620
you have to do this in one request so

133
00:05:34,620 --> 00:05:37,020
that's what it's pretty annoying

134
00:05:37,020 --> 00:05:39,900
one thing to note though is that since

135
00:05:39,900 --> 00:05:43,080
we have the same aslr and Pi on

136
00:05:43,080 --> 00:05:44,880
different workers we don't really care

137
00:05:44,880 --> 00:05:47,039
about getting a leak in one request we

138
00:05:47,039 --> 00:05:49,080
can get a leak once and then afterwards

139
00:05:49,080 --> 00:05:51,539
exploit with a second request so let's

140
00:05:51,539 --> 00:05:54,479
say that you get two requests to exploit

141
00:05:54,479 --> 00:05:56,460
so to me it comes on to picking the

142
00:05:56,460 --> 00:05:58,199
right targets like what kind of function

143
00:05:58,199 --> 00:06:01,259
can I look into to find the bug that I

144
00:06:01,259 --> 00:06:03,840
can exploit remotely with PHP

145
00:06:03,840 --> 00:06:06,600
well the go-to candidate has always been

146
00:06:06,600 --> 00:06:09,539
until allies and why it is because it's

147
00:06:09,539 --> 00:06:10,979
basically a way to interact several

148
00:06:10,979 --> 00:06:13,320
times with PHP in one request

149
00:06:13,320 --> 00:06:15,720
and serialized is PHP digitalization

150
00:06:15,720 --> 00:06:17,460
function as you can see in the payload

151
00:06:17,460 --> 00:06:20,039
here invites it describes an array with

152
00:06:20,039 --> 00:06:21,720
two elements and then in this array

153
00:06:21,720 --> 00:06:24,419
there is an object which contains an

154
00:06:24,419 --> 00:06:26,819
attribute and then there is another key

155
00:06:26,819 --> 00:06:29,220
that contains a string so that shows you

156
00:06:29,220 --> 00:06:30,960
that you can basically create any kind

157
00:06:30,960 --> 00:06:32,960
of memory layout then create an object

158
00:06:32,960 --> 00:06:35,280
potentially trigger a bug on this object

159
00:06:35,280 --> 00:06:37,199
and then use the rest of the array to

160
00:06:37,199 --> 00:06:39,720
fill up the Eep or modify the Heap again

161
00:06:39,720 --> 00:06:42,780
and get a really useful primitive so

162
00:06:42,780 --> 00:06:45,240
this is a really good function to find

163
00:06:45,240 --> 00:06:47,039
bugs into if you want to expose remotely

164
00:06:47,039 --> 00:06:50,220
however well entire life is not that

165
00:06:50,220 --> 00:06:53,160
much use anymore because it was pretty

166
00:06:53,160 --> 00:06:55,500
much a way to destroy any PHP website

167
00:06:55,500 --> 00:06:58,800
for I don't know 10 years so

168
00:06:58,800 --> 00:07:00,360
I kind of wanted to look at something

169
00:07:00,360 --> 00:07:01,560
else

170
00:07:01,560 --> 00:07:03,780
and so my idea was I wanted to look at

171
00:07:03,780 --> 00:07:06,900
database driver functions the idea with

172
00:07:06,900 --> 00:07:09,300
this is that when PHP interacts with the

173
00:07:09,300 --> 00:07:10,860
database it's basically a way to

174
00:07:10,860 --> 00:07:13,800
interact several times with PHP all in

175
00:07:13,800 --> 00:07:15,240
one request

176
00:07:15,240 --> 00:07:17,460
also that's a way to use a bug after

177
00:07:17,460 --> 00:07:19,199
you've triggered it for instance you

178
00:07:19,199 --> 00:07:21,479
take you trigger a bug with one SQL

179
00:07:21,479 --> 00:07:23,759
query and then when the second SQL query

180
00:07:23,759 --> 00:07:25,500
comes in you can potentially change the

181
00:07:25,500 --> 00:07:27,479
IFA layout and use the bug that you have

182
00:07:27,479 --> 00:07:28,979
created

183
00:07:28,979 --> 00:07:31,680
the setup phase where you have to like

184
00:07:31,680 --> 00:07:33,960
set up the layout it has to be done

185
00:07:33,960 --> 00:07:36,000
another way but I will describe how you

186
00:07:36,000 --> 00:07:37,740
can do this

187
00:07:37,740 --> 00:07:41,220
so uh I reported two bugs the first one

188
00:07:41,220 --> 00:07:43,740
we're going to talk about a lot and the

189
00:07:43,740 --> 00:07:45,120
other one may be at the end if we have

190
00:07:45,120 --> 00:07:48,000
some time in any case the second one I

191
00:07:48,000 --> 00:07:50,580
couldn't find any useful CMS or

192
00:07:50,580 --> 00:07:52,080
framework that used it so it's basically

193
00:07:52,080 --> 00:07:55,020
a user's bug the other one however it

194
00:07:55,020 --> 00:07:57,419
affects any kind of database management

195
00:07:57,419 --> 00:08:01,380
utility so admin PSP my admin any kind

196
00:08:01,380 --> 00:08:04,639
of share hosting I don't know CMS

197
00:08:04,639 --> 00:08:08,000
stuff like this

198
00:08:08,039 --> 00:08:10,500
so before I talk about the bugs we have

199
00:08:10,500 --> 00:08:13,080
to talk about php's internals and don't

200
00:08:13,080 --> 00:08:15,240
worry it's very very simple and we are

201
00:08:15,240 --> 00:08:18,120
only going to keep it for anything we

202
00:08:18,120 --> 00:08:20,300
need

203
00:08:22,699 --> 00:08:25,620
so obviously PHP is a weekly type

204
00:08:25,620 --> 00:08:28,020
language so it has to store every

205
00:08:28,020 --> 00:08:30,300
variable with a type and then the

206
00:08:30,300 --> 00:08:33,059
representation of the Bible so if your

207
00:08:33,059 --> 00:08:35,940
variable is a string the type is string

208
00:08:35,940 --> 00:08:39,059
and then it's the description of the

209
00:08:39,059 --> 00:08:42,360
data is stored in a Zen swing structure

210
00:08:42,360 --> 00:08:44,279
for an array that would be type array

211
00:08:44,279 --> 00:08:47,339
and then array structure so before being

212
00:08:47,339 --> 00:08:49,560
used every variable is type checked so

213
00:08:49,560 --> 00:08:51,720
PHP will check the type and then it will

214
00:08:51,720 --> 00:08:53,880
reference the complex object

215
00:08:53,880 --> 00:08:57,899
that is instant value and use this

216
00:08:57,899 --> 00:08:59,580
object instead

217
00:08:59,580 --> 00:09:01,200
we don't really care about zverse

218
00:09:01,200 --> 00:09:03,000
because they are mostly allocated on the

219
00:09:03,000 --> 00:09:05,519
stack or at places that we don't really

220
00:09:05,519 --> 00:09:07,560
care about in the Heap but what we care

221
00:09:07,560 --> 00:09:10,080
about are complex types I will describe

222
00:09:10,080 --> 00:09:12,060
only two types these are the only two

223
00:09:12,060 --> 00:09:14,040
types that we need to exploit so then

224
00:09:14,040 --> 00:09:16,680
swing and then array and coincidentally

225
00:09:16,680 --> 00:09:18,720
it's pretty good because this these

226
00:09:18,720 --> 00:09:20,279
those are the only types that we can

227
00:09:20,279 --> 00:09:22,740
send Using get and pass data

228
00:09:22,740 --> 00:09:25,560
so what is this answering well obviously

229
00:09:25,560 --> 00:09:27,779
it stores a string in PHP so if you

230
00:09:27,779 --> 00:09:29,040
create a string with like three

231
00:09:29,040 --> 00:09:31,920
characters PHP is going to create a Zen

232
00:09:31,920 --> 00:09:33,660
string structure and allocate it on the

233
00:09:33,660 --> 00:09:37,380
Eep the elements are a GC which contains

234
00:09:37,380 --> 00:09:39,540
the ref count and some Flags the hash

235
00:09:39,540 --> 00:09:40,920
value we don't really care about this

236
00:09:40,920 --> 00:09:43,560
one then the length of the string and

237
00:09:43,560 --> 00:09:45,660
then right after this the buffer of the

238
00:09:45,660 --> 00:09:47,640
string is not a pointer to the buffer

239
00:09:47,640 --> 00:09:49,440
it's just straight up the buffer as you

240
00:09:49,440 --> 00:09:52,140
can see in the X damp here like you have

241
00:09:52,140 --> 00:09:55,980
the headers so the GC the Ash and the

242
00:09:55,980 --> 00:09:57,779
length and then straight after this you

243
00:09:57,779 --> 00:09:59,700
have your buffer and the final final

244
00:09:59,700 --> 00:10:03,839
null bytes so if I send a string of orix

245
00:10:03,839 --> 00:10:05,820
14 characters it's going to allocate

246
00:10:05,820 --> 00:10:09,060
enough space for the header so ox18 plus

247
00:10:09,060 --> 00:10:11,580
the length of the string of x14 and then

248
00:10:11,580 --> 00:10:13,380
a nude byte

249
00:10:13,380 --> 00:10:14,839
foreign

250
00:10:14,839 --> 00:10:17,519
as an attacker obviously we can control

251
00:10:17,519 --> 00:10:19,440
the length we have a good Advantage

252
00:10:19,440 --> 00:10:21,839
because if we can make PHP think that a

253
00:10:21,839 --> 00:10:23,880
string is way bigger than it really is

254
00:10:23,880 --> 00:10:26,100
we're going to be able to see the memory

255
00:10:26,100 --> 00:10:28,380
that comes after the string and by

256
00:10:28,380 --> 00:10:31,800
seeing I mean writing and reading so

257
00:10:31,800 --> 00:10:34,380
that's a pretty good way to get control

258
00:10:34,380 --> 00:10:37,740
over the in PHP

259
00:10:37,740 --> 00:10:39,240
the second structure that we're going to

260
00:10:39,240 --> 00:10:41,160
look at and that's the last one is

261
00:10:41,160 --> 00:10:43,440
underways so obviously it represents a

262
00:10:43,440 --> 00:10:46,440
PHP array which is more like like it's

263
00:10:46,440 --> 00:10:49,320
more it's closer sorry to a hashmap than

264
00:10:49,320 --> 00:10:52,500
an array and we don't really care about

265
00:10:52,500 --> 00:10:56,100
what's inside it but the last element

266
00:10:56,100 --> 00:10:58,680
which is very strictor the restrictor is

267
00:10:58,680 --> 00:11:00,300
a function pointer which is called

268
00:11:00,300 --> 00:11:02,040
whenever you remove an element from an

269
00:11:02,040 --> 00:11:04,019
array so in the code snippet here the

270
00:11:04,019 --> 00:11:05,579
descriptor will decode on the first

271
00:11:05,579 --> 00:11:07,220
element so one

272
00:11:07,220 --> 00:11:09,779
the good thing about this is that as an

273
00:11:09,779 --> 00:11:10,920
attacker

274
00:11:10,920 --> 00:11:13,200
if we control the restrictor that means

275
00:11:13,200 --> 00:11:15,420
that we control the PC because we can

276
00:11:15,420 --> 00:11:17,579
simply clear an array or wait for the

277
00:11:17,579 --> 00:11:20,100
request to end when the request ends the

278
00:11:20,100 --> 00:11:22,200
arrays are deleted and super respecter

279
00:11:22,200 --> 00:11:23,940
gets called

280
00:11:23,940 --> 00:11:25,740
so now you have enough to understand the

281
00:11:25,740 --> 00:11:28,620
local PHP exploit it's really easy so

282
00:11:28,620 --> 00:11:30,720
you use a bug to correct the length of

283
00:11:30,720 --> 00:11:33,420
some Zen string so the the length is way

284
00:11:33,420 --> 00:11:35,100
bigger than it should be then you get

285
00:11:35,100 --> 00:11:36,720
read write Primitives over the E for

286
00:11:36,720 --> 00:11:38,700
free because you can just use the array

287
00:11:38,700 --> 00:11:40,440
notation

288
00:11:40,440 --> 00:11:44,040
and then you can spray arrays and in the

289
00:11:44,040 --> 00:11:45,660
Apes that you have leaked you can find

290
00:11:45,660 --> 00:11:48,000
the address of a pedestructor you can

291
00:11:48,000 --> 00:11:50,000
just then change display

292
00:11:50,000 --> 00:11:53,160
sorry and then you can insert the array

293
00:11:53,160 --> 00:11:55,019
and the structure will get caught and

294
00:11:55,019 --> 00:11:58,459
you get coexecution very very simple

295
00:11:58,459 --> 00:12:01,980
however to understand remote exploits we

296
00:12:01,980 --> 00:12:04,380
have to go a little bit into the php's

297
00:12:04,380 --> 00:12:07,079
Eep which is the simplest if I've ever

298
00:12:07,079 --> 00:12:09,959
seen so it's very easy to understand

299
00:12:09,959 --> 00:12:12,720
um so two main functions one to allocate

300
00:12:12,720 --> 00:12:15,959
one two three uh to allocate you use

301
00:12:15,959 --> 00:12:18,540
email log n to allocate n bytes and to

302
00:12:18,540 --> 00:12:22,040
free you use E3 of some pointer

303
00:12:22,040 --> 00:12:25,680
the epin PHP is a memory region of two

304
00:12:25,680 --> 00:12:28,140
megabytes is divided in pages so you get

305
00:12:28,140 --> 00:12:32,399
like a five uh 512 Pages the first page

306
00:12:32,399 --> 00:12:34,140
of the Eep is going to be metadata we

307
00:12:34,140 --> 00:12:35,459
don't really care about this one but the

308
00:12:35,459 --> 00:12:37,200
rest is used for storage

309
00:12:37,200 --> 00:12:39,420
so what do you saw in Pages you saw

310
00:12:39,420 --> 00:12:42,120
chunks one page can only store chunks of

311
00:12:42,120 --> 00:12:44,399
the same size so for instance page 10

312
00:12:44,399 --> 00:12:48,360
could store chunks of size 8.

313
00:12:48,360 --> 00:12:51,060
page 11 strength of size 16 of 32

314
00:12:51,060 --> 00:12:53,519
anything and this is all determined by

315
00:12:53,519 --> 00:12:55,320
the heat metadata

316
00:12:55,320 --> 00:12:58,740
if we want to allocate more than a 3072

317
00:12:58,740 --> 00:13:01,260
bytes however the allocation is going to

318
00:13:01,260 --> 00:13:03,899
be straight in pages instead of using

319
00:13:03,899 --> 00:13:06,180
chunks

320
00:13:06,180 --> 00:13:08,160
so how does the allocation and the

321
00:13:08,160 --> 00:13:10,620
allocation work well for each chunk size

322
00:13:10,620 --> 00:13:13,380
PHP will maintain a linked list of three

323
00:13:13,380 --> 00:13:17,220
chunks okay which is called a bin

324
00:13:17,220 --> 00:13:18,540
um

325
00:13:18,540 --> 00:13:20,700
so there's been zero for chunks of size

326
00:13:20,700 --> 00:13:23,760
eight then bin one for size size 16 etc

327
00:13:23,760 --> 00:13:26,940
etc up until 3072.

328
00:13:26,940 --> 00:13:29,880
so when you free your pointer PHP will

329
00:13:29,880 --> 00:13:32,220
just take the pointer address find out

330
00:13:32,220 --> 00:13:35,399
which page it is in then did use from

331
00:13:35,399 --> 00:13:38,040
the eat metadata which bin it should go

332
00:13:38,040 --> 00:13:38,880
into

333
00:13:38,880 --> 00:13:40,500
and then from there it's going to put

334
00:13:40,500 --> 00:13:42,000
the pointer at the beginning of the

335
00:13:42,000 --> 00:13:44,160
episode at the edge of the linked list

336
00:13:44,160 --> 00:13:46,139
when you want to allocate it basically

337
00:13:46,139 --> 00:13:48,839
does the opposite it finds out the bin

338
00:13:48,839 --> 00:13:50,519
for n so for instance I want to allocate

339
00:13:50,519 --> 00:13:52,500
14 bytes it's going to use bin one

340
00:13:52,500 --> 00:13:55,860
because it's chunks for size 16. and

341
00:13:55,860 --> 00:13:57,600
it's going to remove the head of the

342
00:13:57,600 --> 00:14:00,060
list and return it for us so it's a

343
00:14:00,060 --> 00:14:02,040
lethal structure

344
00:14:02,040 --> 00:14:04,260
obviously there is a edge case where if

345
00:14:04,260 --> 00:14:06,240
the bin is empty PHP has to create new

346
00:14:06,240 --> 00:14:08,519
chunks so it will just look at the

347
00:14:08,519 --> 00:14:11,220
metadata if there's nothing in some page

348
00:14:11,220 --> 00:14:13,380
it's going to reserve the page for some

349
00:14:13,380 --> 00:14:16,200
chunks and then you will create the

350
00:14:16,200 --> 00:14:18,360
chunks in the page and add them to the

351
00:14:18,360 --> 00:14:20,720
free list

352
00:14:21,420 --> 00:14:24,120
so quick example to understand it on the

353
00:14:24,120 --> 00:14:26,459
very left there is the Eep with its

354
00:14:26,459 --> 00:14:28,920
Pages let's say let's say that on page

355
00:14:28,920 --> 00:14:31,820
10 you have strength of size Ox 100

356
00:14:31,820 --> 00:14:37,079
those chunks are reside in B9 so if they

357
00:14:37,079 --> 00:14:39,480
are free they are going to go in B9 so

358
00:14:39,480 --> 00:14:41,100
let's say for instance the bin looks

359
00:14:41,100 --> 00:14:42,899
like this at the beginning if I feel an

360
00:14:42,899 --> 00:14:44,820
element it's going to be added on the

361
00:14:44,820 --> 00:14:47,699
beginning of the list and if I allocate

362
00:14:47,699 --> 00:14:48,899
it's going to take the elements from the

363
00:14:48,899 --> 00:14:50,639
beginning of the list right very very

364
00:14:50,639 --> 00:14:52,920
simple it would be like t-cash and see

365
00:14:52,920 --> 00:14:55,860
ellipse for instance

366
00:14:55,860 --> 00:14:58,139
so now we have enough to understand the

367
00:14:58,139 --> 00:15:00,959
the first bug which is a hip overflow in

368
00:15:00,959 --> 00:15:02,760
the MySQL energy

369
00:15:02,760 --> 00:15:04,860
so obviously you need to understand what

370
00:15:04,860 --> 00:15:07,860
is MySQL indeed well it's a PSPs on

371
00:15:07,860 --> 00:15:12,540
MySQL driver so PHP devs developed this

372
00:15:12,540 --> 00:15:13,440
thing

373
00:15:13,440 --> 00:15:16,620
and it's pretty pretty horrible like

374
00:15:16,620 --> 00:15:19,800
I try to fuzz it and like I couldn't

375
00:15:19,800 --> 00:15:21,540
reach any important part of the code it

376
00:15:21,540 --> 00:15:23,339
was just crashing crashing crashing plus

377
00:15:23,339 --> 00:15:24,959
it's super slow because it's VSP

378
00:15:24,959 --> 00:15:28,620
obviously so I was like I hate fuzzing

379
00:15:28,620 --> 00:15:30,180
anyways I'm going to read the code and

380
00:15:30,180 --> 00:15:33,600
that's why I did and so I got this bug

381
00:15:33,600 --> 00:15:35,579
um this bag is pretty easy to spot

382
00:15:35,579 --> 00:15:36,600
actually

383
00:15:36,600 --> 00:15:40,139
when you connect to a database the

384
00:15:40,139 --> 00:15:41,639
database can ask you for several

385
00:15:41,639 --> 00:15:43,860
authentication methods and if the

386
00:15:43,860 --> 00:15:46,079
database tells you to authenticate with

387
00:15:46,079 --> 00:15:49,260
clear text PHP will just send a MySQL

388
00:15:49,260 --> 00:15:52,440
header of size 4 and the clear text of

389
00:15:52,440 --> 00:15:54,180
the password

390
00:15:54,180 --> 00:15:56,220
the thing is if your passcode is big

391
00:15:56,220 --> 00:15:58,680
enough is going to want to allocate your

392
00:15:58,680 --> 00:16:01,560
password with the header but it only

393
00:16:01,560 --> 00:16:03,300
allocates the size for the password

394
00:16:03,300 --> 00:16:05,699
so when it does the mem copy afterwards

395
00:16:05,699 --> 00:16:08,760
you get four bytes word of bound right

396
00:16:08,760 --> 00:16:11,820
so 4 byte overflow so to trigger the bug

397
00:16:11,820 --> 00:16:13,260
you just have to force PHP into

398
00:16:13,260 --> 00:16:15,360
connecting to your database with some

399
00:16:15,360 --> 00:16:18,420
use passwords a new database then says I

400
00:16:18,420 --> 00:16:20,279
want the clear text password and then

401
00:16:20,279 --> 00:16:22,620
PHP allocates the wrong buffer size and

402
00:16:22,620 --> 00:16:26,339
then it gets the Overflow there

403
00:16:26,339 --> 00:16:28,320
so Target of choice for today was

404
00:16:28,320 --> 00:16:30,240
adminer which is a database management

405
00:16:30,240 --> 00:16:33,540
PHP utility we often find this in pen

406
00:16:33,540 --> 00:16:36,060
test because like the Cs admin puts it

407
00:16:36,060 --> 00:16:38,040
there they use it once and then they

408
00:16:38,040 --> 00:16:40,980
forget it exists and then you just go

409
00:16:40,980 --> 00:16:43,440
onto the website type slash adminer.php

410
00:16:43,440 --> 00:16:45,560
and then you get this

411
00:16:45,560 --> 00:16:48,240
so the idea behind admin is very simple

412
00:16:48,240 --> 00:16:51,060
it's one simple PHP file and then you

413
00:16:51,060 --> 00:16:53,459
give a server address username password

414
00:16:53,459 --> 00:16:55,920
you can connect to it you can then issue

415
00:16:55,920 --> 00:16:57,839
queries you can then import data you can

416
00:16:57,839 --> 00:16:59,759
then export data it's basically the same

417
00:16:59,759 --> 00:17:02,699
as phpmyadmin like any kind of database

418
00:17:02,699 --> 00:17:04,380
management utility but you can connect

419
00:17:04,380 --> 00:17:06,240
to whatever you want and for us it's

420
00:17:06,240 --> 00:17:07,859
perfect because we want to connect to a

421
00:17:07,859 --> 00:17:09,540
Vogue MySQL server a server that we

422
00:17:09,540 --> 00:17:11,579
control with a password that we control

423
00:17:11,579 --> 00:17:13,799
as well

424
00:17:13,799 --> 00:17:15,140
okay

425
00:17:15,140 --> 00:17:18,419
so if we go back to the Primitive PHP

426
00:17:18,419 --> 00:17:20,220
will allocate our password on at least

427
00:17:20,220 --> 00:17:21,900
two eight pages because the password has

428
00:17:21,900 --> 00:17:24,540
to be bigger than one page

429
00:17:24,540 --> 00:17:26,339
um so the idea is that we can override

430
00:17:26,339 --> 00:17:27,959
the first four bytes of the next page

431
00:17:27,959 --> 00:17:30,540
right very simple

432
00:17:30,540 --> 00:17:32,400
um what can we override with four bytes

433
00:17:32,400 --> 00:17:34,860
well we could try and override a Zen

434
00:17:34,860 --> 00:17:36,900
swing or as an array but we would only

435
00:17:36,900 --> 00:17:39,539
overwrite part of the wave count so it

436
00:17:39,539 --> 00:17:41,460
doesn't really matter I mean we could

437
00:17:41,460 --> 00:17:43,200
exploit with this but it gets really

438
00:17:43,200 --> 00:17:46,380
complicated so my ID was more to exploit

439
00:17:46,380 --> 00:17:49,919
by overwriting partially the next chunk

440
00:17:49,919 --> 00:17:52,799
the next pointer of a free chunk when

441
00:17:52,799 --> 00:17:55,140
the chunk is free is going to be in the

442
00:17:55,140 --> 00:17:56,820
linked list so it's going to point to

443
00:17:56,820 --> 00:17:59,039
another frame check if we can modify the

444
00:17:59,039 --> 00:18:01,440
address of this free Chunk we can alter

445
00:18:01,440 --> 00:18:03,720
the link list of the bin and when we

446
00:18:03,720 --> 00:18:07,440
allocate for the strings well the linked

447
00:18:07,440 --> 00:18:08,700
list is going to be modified and we're

448
00:18:08,700 --> 00:18:10,020
going to be able to allocate a different

449
00:18:10,020 --> 00:18:12,600
spot so maybe do other things

450
00:18:12,600 --> 00:18:15,120
the standard ID behind this is that we

451
00:18:15,120 --> 00:18:17,520
try and make two chunks overlap when we

452
00:18:17,520 --> 00:18:20,039
control the linked list and then we can

453
00:18:20,039 --> 00:18:22,320
overwrite a structure such as the Zen

454
00:18:22,320 --> 00:18:24,059
string or send away and we are getting

455
00:18:24,059 --> 00:18:28,340
pretty close to well code execution

456
00:18:29,039 --> 00:18:30,960
the only problem with this is that

457
00:18:30,960 --> 00:18:33,179
whenever we use admina the first thing

458
00:18:33,179 --> 00:18:34,740
that PHP will do is connect to the

459
00:18:34,740 --> 00:18:36,960
database but to exploit the bug we

460
00:18:36,960 --> 00:18:39,720
really need to do a Eep setup like a

461
00:18:39,720 --> 00:18:41,240
some kind of if

462
00:18:41,240 --> 00:18:43,799
layout that we want to have to exploit

463
00:18:43,799 --> 00:18:44,700
the bug

464
00:18:44,700 --> 00:18:47,640
so the only way for us to do this is to

465
00:18:47,640 --> 00:18:49,620
use get and post data right on cookies

466
00:18:49,620 --> 00:18:52,799
and whatever but the input so we can

467
00:18:52,799 --> 00:18:55,980
actually do this do this pretty easily

468
00:18:55,980 --> 00:18:58,620
as I'm sure you know there are two

469
00:18:58,620 --> 00:19:00,059
things that you can allocate in PHP

470
00:19:00,059 --> 00:19:02,940
strings uh very simply like page equal

471
00:19:02,940 --> 00:19:05,100
news and ID equals one two three so you

472
00:19:05,100 --> 00:19:07,919
will get news allocated page allocated

473
00:19:07,919 --> 00:19:10,440
ID allocated and one to Fair located all

474
00:19:10,440 --> 00:19:13,320
as then swing objects and you can also

475
00:19:13,320 --> 00:19:15,900
send a raise if you use the bracket

476
00:19:15,900 --> 00:19:18,419
notation you can force PHP to create a

477
00:19:18,419 --> 00:19:20,160
race that's pretty good but that's on

478
00:19:20,160 --> 00:19:22,080
the allocation what we want to do is

479
00:19:22,080 --> 00:19:24,840
free as well uh once we do that we can

480
00:19:24,840 --> 00:19:26,940
simply send the key twice if we send the

481
00:19:26,940 --> 00:19:28,799
key twice PHP will first allocate the

482
00:19:28,799 --> 00:19:31,260
first value so in this example value one

483
00:19:31,260 --> 00:19:33,419
and then you will realize that there is

484
00:19:33,419 --> 00:19:35,039
another key so it will allocate the

485
00:19:35,039 --> 00:19:37,320
second value value 2 and then you will

486
00:19:37,320 --> 00:19:39,960
free value one so this is pretty good

487
00:19:39,960 --> 00:19:41,580
for us because only with get and post

488
00:19:41,580 --> 00:19:44,100
data we can allocate anything

489
00:19:44,100 --> 00:19:46,980
basically anything and free basically

490
00:19:46,980 --> 00:19:49,380
anything as well so this is pretty nice

491
00:19:49,380 --> 00:19:51,120
however there's one thing that is

492
00:19:51,120 --> 00:19:53,580
annoying uh whenever we send a variable

493
00:19:53,580 --> 00:19:55,260
it's going to be duplicated so it gets

494
00:19:55,260 --> 00:19:57,840
allocated twice so when we free it as

495
00:19:57,840 --> 00:19:59,280
well it's going to be free twice as well

496
00:19:59,280 --> 00:20:02,100
but it's not that hard to uh to to

497
00:20:02,100 --> 00:20:05,039
understand and to bypass afterwards so

498
00:20:05,039 --> 00:20:07,260
only with gas and post data we get a

499
00:20:07,260 --> 00:20:08,820
very precise Eep setup so that's pretty

500
00:20:08,820 --> 00:20:10,740
good

501
00:20:10,740 --> 00:20:14,280
uh as a quick example uh as how we can

502
00:20:14,280 --> 00:20:16,260
do this let's say we want to create a

503
00:20:16,260 --> 00:20:19,080
hundred chunks of size 0x100 and we want

504
00:20:19,080 --> 00:20:21,179
to free one in the middle right

505
00:20:21,179 --> 00:20:23,400
so how do we create a chunk of seismic

506
00:20:23,400 --> 00:20:26,760
700 we send the string of size Ox E7 why

507
00:20:26,760 --> 00:20:28,440
because the header of the string is

508
00:20:28,440 --> 00:20:32,220
going to be headed so it's a 1 8 in

509
00:20:32,220 --> 00:20:34,799
hexadecimal plus the null bytes added as

510
00:20:34,799 --> 00:20:38,039
well and so this end up being this ends

511
00:20:38,039 --> 00:20:41,400
up being ox100

512
00:20:42,120 --> 00:20:44,940
um so then we have a string of size 800

513
00:20:44,940 --> 00:20:46,980
what we can do is send it 100 times

514
00:20:46,980 --> 00:20:49,919
because we want 100 100 chunks and we

515
00:20:49,919 --> 00:20:51,600
want to free one in the middle so we

516
00:20:51,600 --> 00:20:54,840
just change the value of some value in

517
00:20:54,840 --> 00:20:57,480
the middle of the array so 49 here and

518
00:20:57,480 --> 00:20:59,280
we get our if setup

519
00:20:59,280 --> 00:21:02,059
so it's very easy

520
00:21:04,620 --> 00:21:06,600
so what is the current state of affairs

521
00:21:06,600 --> 00:21:08,940
we can set up any kind of Eep layout

522
00:21:08,940 --> 00:21:11,880
using only get and pause

523
00:21:11,880 --> 00:21:13,679
um we can trigger the bug by simply

524
00:21:13,679 --> 00:21:15,900
asking adminar to connect to a rogue

525
00:21:15,900 --> 00:21:18,720
mySQL database so the mySQL database

526
00:21:18,720 --> 00:21:21,000
asked for all clear text passwords and

527
00:21:21,000 --> 00:21:22,980
that triggers debug and then we can use

528
00:21:22,980 --> 00:21:24,900
the bug because we can send arbitrary

529
00:21:24,900 --> 00:21:28,200
query results when a PHP sends SQL

530
00:21:28,200 --> 00:21:30,559
queries

531
00:21:31,440 --> 00:21:34,140
so let's try and exploit with this so

532
00:21:34,140 --> 00:21:36,240
that's why I asked for the pointer

533
00:21:36,240 --> 00:21:38,220
and so

534
00:21:38,220 --> 00:21:40,380
first thing that we need to do a good

535
00:21:40,380 --> 00:21:42,600
Eep setup so the idea is to have two

536
00:21:42,600 --> 00:21:44,700
empty pages in which the overflown

537
00:21:44,700 --> 00:21:47,400
buffer is going to be then the Red Zone

538
00:21:47,400 --> 00:21:51,360
which contains uh freed chunks what we

539
00:21:51,360 --> 00:21:53,100
want to do is Overflow here in the

540
00:21:53,100 --> 00:21:55,020
pointer here so they Point somewhere

541
00:21:55,020 --> 00:21:58,140
else and then a use region here which is

542
00:21:58,140 --> 00:22:00,480
one megabyte long which you can do

543
00:22:00,480 --> 00:22:02,700
easily by sending a get and post data

544
00:22:02,700 --> 00:22:04,799
which is one gigabyte long

545
00:22:04,799 --> 00:22:08,940
and and that's it that's a good setup so

546
00:22:08,940 --> 00:22:11,220
then what can we do well we have to beat

547
00:22:11,220 --> 00:22:13,620
a setup first

548
00:22:13,620 --> 00:22:18,360
so gig was to make this pointer here

549
00:22:18,360 --> 00:22:20,700
instead of pointing to one of these

550
00:22:20,700 --> 00:22:23,520
points here if we can make it Point here

551
00:22:23,520 --> 00:22:24,960
we can then control the free list

552
00:22:24,960 --> 00:22:26,460
entirely and then we can allocate

553
00:22:26,460 --> 00:22:28,440
wherever we want which is pretty good

554
00:22:28,440 --> 00:22:30,960
however

555
00:22:30,960 --> 00:22:34,020
we have to buy data SLR so the first

556
00:22:34,020 --> 00:22:36,059
bytes that I care about are these ones

557
00:22:36,059 --> 00:22:38,400
in the middle that those are the like

558
00:22:38,400 --> 00:22:41,820
the highest bytes that we can uh touch

559
00:22:41,820 --> 00:22:45,659
with the Overflow and so this byte and a

560
00:22:45,659 --> 00:22:47,360
half you have

561
00:22:47,360 --> 00:22:49,679
4096 possibilities so you can just put

562
00:22:49,679 --> 00:22:52,679
forces over HTTP is not that long but

563
00:22:52,679 --> 00:22:54,179
there's one question how do we know that

564
00:22:54,179 --> 00:22:56,760
we are indeed pointing to huge well to

565
00:22:56,760 --> 00:22:59,940
do this we can test every address twice

566
00:22:59,940 --> 00:23:03,059
once with the region filled with zeros

567
00:23:03,059 --> 00:23:05,820
so when we actually point to this

568
00:23:05,820 --> 00:23:08,179
address we will get this

569
00:23:08,179 --> 00:23:12,000
pointer which points to nil because we

570
00:23:12,000 --> 00:23:13,559
only have zeros here and so the

571
00:23:13,559 --> 00:23:15,960
allocation will work however

572
00:23:15,960 --> 00:23:19,260
if we fill the region with FF

573
00:23:19,260 --> 00:23:21,179
the free list will be a little bit

574
00:23:21,179 --> 00:23:24,000
 and so PSP when it allocates will

575
00:23:24,000 --> 00:23:25,380
simply crash

576
00:23:25,380 --> 00:23:28,200
so this this allows us to determine the

577
00:23:28,200 --> 00:23:30,059
first one and a half bytes

578
00:23:30,059 --> 00:23:32,940
we got a few not a few more to do the

579
00:23:32,940 --> 00:23:34,919
idea is to repeat the process keep the

580
00:23:34,919 --> 00:23:37,140
same address but this time split the

581
00:23:37,140 --> 00:23:39,960
region into on the top zeros on the

582
00:23:39,960 --> 00:23:42,960
bottom FF so I start the exploit again

583
00:23:42,960 --> 00:23:45,179
if it crashes that means I am on the

584
00:23:45,179 --> 00:23:46,260
bottom

585
00:23:46,260 --> 00:23:49,679
if it doesn't I am on the top and so I

586
00:23:49,679 --> 00:23:51,780
can determine very precisely where I am

587
00:23:51,780 --> 00:23:53,520
in this region

588
00:23:53,520 --> 00:23:55,799
there's one more byte to determine this

589
00:23:55,799 --> 00:23:58,740
is the fifth byte byte 5 is not

590
00:23:58,740 --> 00:24:00,360
reachable with the Overflow because we

591
00:24:00,360 --> 00:24:02,940
have a four byte overflow so the only

592
00:24:02,940 --> 00:24:04,740
way to do this is simply since we

593
00:24:04,740 --> 00:24:07,140
control this this region is to create a

594
00:24:07,140 --> 00:24:09,299
fake pointer here remember we we know

595
00:24:09,299 --> 00:24:11,340
these bytes now so we create a fake

596
00:24:11,340 --> 00:24:13,620
pointer here and Brute Force like 256

597
00:24:13,620 --> 00:24:16,200
possibilities and after this we have

598
00:24:16,200 --> 00:24:17,580
beaten the aslr

599
00:24:17,580 --> 00:24:20,159
and we also have a complete control over

600
00:24:20,159 --> 00:24:22,500
some free list

601
00:24:22,500 --> 00:24:25,200
so this is pretty good to exploit

602
00:24:25,200 --> 00:24:26,940
the next thing that we need to do is

603
00:24:26,940 --> 00:24:28,559
disclose the Eep to get information

604
00:24:28,559 --> 00:24:31,080
about the Eep layout and the pointers

605
00:24:31,080 --> 00:24:34,200
that are in the well to do this since we

606
00:24:34,200 --> 00:24:36,240
since we control some free list we can

607
00:24:36,240 --> 00:24:38,760
make it so two chunks overlap and so we

608
00:24:38,760 --> 00:24:40,320
allocate the Chunk on the bottom with

609
00:24:40,320 --> 00:24:42,360
the string and then we allocate the

610
00:24:42,360 --> 00:24:45,600
Chunk on the top to overflow to overflow

611
00:24:45,600 --> 00:24:47,520
into the first one

612
00:24:47,520 --> 00:24:49,500
and from there we can just change the

613
00:24:49,500 --> 00:24:51,419
length of the string and when the string

614
00:24:51,419 --> 00:24:52,980
is displayed well it's going to display

615
00:24:52,980 --> 00:24:57,179
the whole Eep with it so we get a a hip

616
00:24:57,179 --> 00:24:59,280
disclosure and we get a lot of

617
00:24:59,280 --> 00:25:01,320
information from this

618
00:25:01,320 --> 00:25:04,140
one of this information is when we

619
00:25:04,140 --> 00:25:06,240
create a race at some point we're going

620
00:25:06,240 --> 00:25:07,740
to see them in the Eep and so we're

621
00:25:07,740 --> 00:25:09,059
going to find the address of the

622
00:25:09,059 --> 00:25:11,700
descriptor the descriptor's address is

623
00:25:11,700 --> 00:25:14,400
in the php's main program so this way we

624
00:25:14,400 --> 00:25:15,840
beat by because we have the address of

625
00:25:15,840 --> 00:25:16,919
domain program

626
00:25:16,919 --> 00:25:18,720
then afterwards what we can do is simply

627
00:25:18,720 --> 00:25:21,480
continue to use the the free list that

628
00:25:21,480 --> 00:25:24,539
we have modified to go and modify the

629
00:25:24,539 --> 00:25:26,640
whole centralized structure and change

630
00:25:26,640 --> 00:25:28,440
the pedestrator if we change the

631
00:25:28,440 --> 00:25:30,419
password we can just use the stack pivot

632
00:25:30,419 --> 00:25:33,000
or just simply call system or Zip system

633
00:25:33,000 --> 00:25:35,700
the PHP equivalent and when the array

634
00:25:35,700 --> 00:25:37,080
gets destroyed at the end of the request

635
00:25:37,080 --> 00:25:38,340
well it's going to copy the structure

636
00:25:38,340 --> 00:25:40,320
and we get coexecution

637
00:25:40,320 --> 00:25:42,000
so

638
00:25:42,000 --> 00:25:44,880
you've already expect a demo now but I

639
00:25:44,880 --> 00:25:48,720
was actually uh unlucky uh when I tried

640
00:25:48,720 --> 00:25:51,659
to report the bug uh PHP actually

641
00:25:51,659 --> 00:25:54,179
changed the code

642
00:25:54,179 --> 00:25:56,760
um but it wasn't really on purpose uh I

643
00:25:56,760 --> 00:25:59,880
hadn't reported debugger already but I I

644
00:25:59,880 --> 00:26:02,580
saw that the uh they had they added some

645
00:26:02,580 --> 00:26:04,620
patch because I think there was a memory

646
00:26:04,620 --> 00:26:06,480
leak at some point and so they added a

647
00:26:06,480 --> 00:26:08,700
new byte after the end of the MySQL

648
00:26:08,700 --> 00:26:11,580
password so the exportation was dead

649
00:26:11,580 --> 00:26:13,620
because you wanted to control the last

650
00:26:13,620 --> 00:26:17,220
bite of the of the Overflow and if it is

651
00:26:17,220 --> 00:26:19,679
zero then you cannot point to the huge

652
00:26:19,679 --> 00:26:20,640
region

653
00:26:20,640 --> 00:26:23,100
however it made me think that I was very

654
00:26:23,100 --> 00:26:24,840
stupid and there was a way better way to

655
00:26:24,840 --> 00:26:26,880
exploit so I'm going to show it this way

656
00:26:26,880 --> 00:26:28,260
now

657
00:26:28,260 --> 00:26:29,940
um

658
00:26:29,940 --> 00:26:32,700
we have a four bytes overflow yes but

659
00:26:32,700 --> 00:26:34,740
the allocation of the buffer is Page

660
00:26:34,740 --> 00:26:38,220
align so if we send a buffer of size Ox

661
00:26:38,220 --> 00:26:41,340
2000 -3 the Overflow is actually on one

662
00:26:41,340 --> 00:26:43,740
byte so we don't have to deal with four

663
00:26:43,740 --> 00:26:46,860
bytes of overflow we can just use one

664
00:26:46,860 --> 00:26:49,260
byte overflow which is inherently a null

665
00:26:49,260 --> 00:26:52,020
byte to get a new off by one in the if

666
00:26:52,020 --> 00:26:54,600
so this is a kind of exploit that is

667
00:26:54,600 --> 00:26:58,500
pretty standard so it's pretty easy to

668
00:26:58,500 --> 00:27:01,260
get an idea of how to exploit

669
00:27:01,260 --> 00:27:04,740
so the idea is we can change one byte

670
00:27:04,740 --> 00:27:08,760
from anything to zero zero well what we

671
00:27:08,760 --> 00:27:10,679
want to do again is change the next byte

672
00:27:10,679 --> 00:27:14,039
the next pointer in a free list and for

673
00:27:14,039 --> 00:27:16,980
this I will use a chunks of size Ox 70.

674
00:27:16,980 --> 00:27:19,740
the reason is you want to pick chunks

675
00:27:19,740 --> 00:27:21,179
that are not very much used by the

676
00:27:21,179 --> 00:27:22,740
application normally because otherwise

677
00:27:22,740 --> 00:27:24,900
when you do your if setup and then PHP

678
00:27:24,900 --> 00:27:26,880
connects then you're going to have a lot

679
00:27:26,880 --> 00:27:28,860
of new allocations of this size and it's

680
00:27:28,860 --> 00:27:30,480
going to mess up your your setup so it's

681
00:27:30,480 --> 00:27:33,120
annoying so I use this size and also the

682
00:27:33,120 --> 00:27:35,100
good thing about this size that you

683
00:27:35,100 --> 00:27:38,100
actually get useful addresses for

684
00:27:38,100 --> 00:27:39,779
instance here if I override the two last

685
00:27:39,779 --> 00:27:41,820
bytes it gets to zero so it doesn't

686
00:27:41,820 --> 00:27:44,039
change anything if I modify this one

687
00:27:44,039 --> 00:27:46,020
it's actually going to point to this one

688
00:27:46,020 --> 00:27:47,840
again so you have some kind of circular

689
00:27:47,840 --> 00:27:50,220
dependency and it's going to be annoying

690
00:27:50,220 --> 00:27:52,440
again here it points to this one so it's

691
00:27:52,440 --> 00:27:55,380
circular again it sucks what I want is

692
00:27:55,380 --> 00:27:57,779
this one once a zero if I override this

693
00:27:57,779 --> 00:28:00,900
one it points right before 150 so when

694
00:28:00,900 --> 00:28:02,820
150 gets allocated

695
00:28:02,820 --> 00:28:05,279
then this one gets allocated but it's

696
00:28:05,279 --> 00:28:07,440
been modified it points right up right

697
00:28:07,440 --> 00:28:09,360
before this and you get two chunks that

698
00:28:09,360 --> 00:28:11,039
overlap

699
00:28:11,039 --> 00:28:12,720
and then we repeat basically the same

700
00:28:12,720 --> 00:28:14,520
expertise before we have two overlapping

701
00:28:14,520 --> 00:28:16,320
chunks uh we get called execution from

702
00:28:16,320 --> 00:28:18,439
this

703
00:28:19,020 --> 00:28:21,000
so

704
00:28:21,000 --> 00:28:23,100
uh you have to keep in mind this is a

705
00:28:23,100 --> 00:28:25,080
new exploit so we don't have a SLR we

706
00:28:25,080 --> 00:28:26,700
don't have a pi we don't know anything

707
00:28:26,700 --> 00:28:29,640
so how can we do to do this well

708
00:28:29,640 --> 00:28:31,440
basically the same setup as before we

709
00:28:31,440 --> 00:28:32,760
don't need the huge block anyways we

710
00:28:32,760 --> 00:28:35,159
cannot point to it anyways we just do

711
00:28:35,159 --> 00:28:37,440
something like this but in this exploit

712
00:28:37,440 --> 00:28:39,240
we really need to know which pointer is

713
00:28:39,240 --> 00:28:42,360
here so how do we know this well

714
00:28:42,360 --> 00:28:44,779
a good way to know this is simply to

715
00:28:44,779 --> 00:28:48,000
free everything but keep only one that

716
00:28:48,000 --> 00:28:49,140
you are located

717
00:28:49,140 --> 00:28:51,419
if the value that we kept allocated is

718
00:28:51,419 --> 00:28:53,100
on the top of the page it won't crash

719
00:28:53,100 --> 00:28:56,340
but if it is at not the top of the page

720
00:28:56,340 --> 00:28:59,220
PHP will get overflowed here and it will

721
00:28:59,220 --> 00:29:01,440
crash

722
00:29:01,440 --> 00:29:04,200
so here if it's on the top which we just

723
00:29:04,200 --> 00:29:05,460
overflowing the right count and doesn't

724
00:29:05,460 --> 00:29:07,980
crash so this way you can determine uh

725
00:29:07,980 --> 00:29:11,100
the the post index of the value that we

726
00:29:11,100 --> 00:29:14,220
are modifying the thing is I could use

727
00:29:14,220 --> 00:29:16,320
dichotomy here in theory the thing is

728
00:29:16,320 --> 00:29:18,360
well it's not possible because whenever

729
00:29:18,360 --> 00:29:20,279
I send post data that has a different

730
00:29:20,279 --> 00:29:22,799
size well PHP is going to do a lot of

731
00:29:22,799 --> 00:29:24,899
different allocations so it's going to

732
00:29:24,899 --> 00:29:26,820
mess up everything I've did I've done

733
00:29:26,820 --> 00:29:29,220
here simply because I've sent a few more

734
00:29:29,220 --> 00:29:31,980
chunks and so the Eep layout is going to

735
00:29:31,980 --> 00:29:33,240
be and I'm going to in fact as

736
00:29:33,240 --> 00:29:35,700
well so what I do is on this like free

737
00:29:35,700 --> 00:29:37,260
everything and only send one more

738
00:29:37,260 --> 00:29:40,140
element and this way I I don't have the

739
00:29:40,140 --> 00:29:41,220
problem

740
00:29:41,220 --> 00:29:43,620
in any case it's pretty fast I think I

741
00:29:43,620 --> 00:29:46,799
have like 100 requests maximum it gets

742
00:29:46,799 --> 00:29:49,380
done like really really fast

743
00:29:49,380 --> 00:29:52,799
so now it's basically a problem of

744
00:29:52,799 --> 00:29:54,539
setting up the free list

745
00:29:54,539 --> 00:29:57,539
so what we want is we want to allocate

746
00:29:57,539 --> 00:30:00,620
this one first because it's going to be

747
00:30:00,620 --> 00:30:03,419
overlapped with the other one and then

748
00:30:03,419 --> 00:30:07,020
we want this guy two points here why

749
00:30:07,020 --> 00:30:09,240
because this means that

750
00:30:09,240 --> 00:30:11,039
here you're gonna have the pointer to

751
00:30:11,039 --> 00:30:13,200
here and then when we overflow it's

752
00:30:13,200 --> 00:30:16,740
going to modify c0 here so it's not that

753
00:30:16,740 --> 00:30:18,299
hard to do with get on post data you

754
00:30:18,299 --> 00:30:19,919
just have to do a couple of freeze and

755
00:30:19,919 --> 00:30:22,260
allocations if you have two pointers

756
00:30:22,260 --> 00:30:23,880
that are messed up because as I said

757
00:30:23,880 --> 00:30:26,520
when when you allocate with post it also

758
00:30:26,520 --> 00:30:28,200
allocates with request you can just

759
00:30:28,200 --> 00:30:30,419
allocate free and then reallocate and we

760
00:30:30,419 --> 00:30:32,640
just swap the pointers around so it's

761
00:30:32,640 --> 00:30:35,100
not too much of a problem and you end up

762
00:30:35,100 --> 00:30:37,679
with this free list here so this guy

763
00:30:37,679 --> 00:30:39,299
gets allocated first then we don't

764
00:30:39,299 --> 00:30:42,059
really care about it then the guy on the

765
00:30:42,059 --> 00:30:46,080
top of the page here gets uh is in the

766
00:30:46,080 --> 00:30:48,240
free list sorry and it actually points

767
00:30:48,240 --> 00:30:50,220
to the one with byte if we want to

768
00:30:50,220 --> 00:30:51,299
overflow

769
00:30:51,299 --> 00:30:53,399
so this is the setup phase

770
00:30:53,399 --> 00:30:57,360
whenever then I trigger the bug well

771
00:30:57,360 --> 00:30:59,940
the byte changes and so now the free

772
00:30:59,940 --> 00:31:02,460
list has two overlapping checks this one

773
00:31:02,460 --> 00:31:04,860
and this one and so then it's basically

774
00:31:04,860 --> 00:31:06,679
the same expertise before

775
00:31:06,679 --> 00:31:09,360
you make two strings overlap you leak

776
00:31:09,360 --> 00:31:11,399
the Eep then you leak an array and then

777
00:31:11,399 --> 00:31:13,500
from there you can modify an array and

778
00:31:13,500 --> 00:31:14,279
just

779
00:31:14,279 --> 00:31:17,760
call a bit Destructor on this array very

780
00:31:17,760 --> 00:31:18,500
simple

781
00:31:18,500 --> 00:31:21,600
I've got a demo for this

782
00:31:21,600 --> 00:31:22,750
foreign

783
00:31:22,750 --> 00:31:25,910
[Music]

784
00:31:34,039 --> 00:31:37,020
so this is actually adminer but I have

785
00:31:37,020 --> 00:31:39,179
messed up the configuration so there's

786
00:31:39,179 --> 00:31:44,299
no CSS but you can recognize it I guess

787
00:31:45,659 --> 00:31:49,200
and this

788
00:31:49,200 --> 00:31:51,960
is the exploit so live demo so it might

789
00:31:51,960 --> 00:31:55,520
not work obviously but

790
00:31:58,320 --> 00:32:01,320
foreign

791
00:32:12,240 --> 00:32:14,580
so I just created a PHP file at the web

792
00:32:14,580 --> 00:32:16,860
root so that it's easy to understand I

793
00:32:16,860 --> 00:32:20,418
just displayed ID as well here

794
00:32:23,720 --> 00:32:27,320
I lost my mouse

795
00:32:33,840 --> 00:32:36,559
thank you

796
00:32:43,740 --> 00:32:46,620
what is it

797
00:32:46,620 --> 00:32:50,239
oh sorry

798
00:32:55,400 --> 00:32:58,200
[Music]

799
00:32:58,200 --> 00:33:00,380
thank you

800
00:33:02,820 --> 00:33:06,480
is this place strange or is it just me

801
00:33:06,480 --> 00:33:09,179
no it's fine okay

802
00:33:09,179 --> 00:33:11,340
so demons done

803
00:33:11,340 --> 00:33:13,740
um so I actually thought I was on a 30

804
00:33:13,740 --> 00:33:16,080
minute slot so I think I actually have

805
00:33:16,080 --> 00:33:18,120
45 minutes but then we can talk about

806
00:33:18,120 --> 00:33:20,399
the the other bug so quick conclusion

807
00:33:20,399 --> 00:33:22,799
before we talk about the other bug

808
00:33:22,799 --> 00:33:24,659
um php's Eep has no protections but

809
00:33:24,659 --> 00:33:26,940
finding a bug to exploit it actually

810
00:33:26,940 --> 00:33:28,799
requires a lot of

811
00:33:28,799 --> 00:33:31,740
information a luck because you need the

812
00:33:31,740 --> 00:33:33,480
bug then you need the CMS that uses the

813
00:33:33,480 --> 00:33:34,799
bug and then you need to use it

814
00:33:34,799 --> 00:33:37,200
afterwards so my advice if you want to

815
00:33:37,200 --> 00:33:39,600
find remotely exportable bugs is to look

816
00:33:39,600 --> 00:33:41,700
into and serialize maybe maybe there are

817
00:33:41,700 --> 00:33:43,440
steel box in there but you could also

818
00:33:43,440 --> 00:33:45,840
look at things that make PHP interact

819
00:33:45,840 --> 00:33:47,760
several times with

820
00:33:47,760 --> 00:33:51,779
um uh anything basically database maybe

821
00:33:51,779 --> 00:33:54,240
I don't know like five protocols in PHP

822
00:33:54,240 --> 00:33:55,380
you can do a lot of things with them

823
00:33:55,380 --> 00:33:57,360
maybe you should look there stuff like

824
00:33:57,360 --> 00:33:59,880
this or you could also find bugs that do

825
00:33:59,880 --> 00:34:02,760
not disappear with the Eep and this was

826
00:34:02,760 --> 00:34:04,740
supposed to be a teaser but since we

827
00:34:04,740 --> 00:34:06,240
have some time left I'm going to explain

828
00:34:06,240 --> 00:34:07,860
it a little bit

829
00:34:07,860 --> 00:34:10,260
so PG query pumps it basically sets up

830
00:34:10,260 --> 00:34:14,040
the parameters for prepared query for PG

831
00:34:14,040 --> 00:34:18,899
and the idea here is that it will copy a

832
00:34:18,899 --> 00:34:20,580
lot of Zen strings that you have sent

833
00:34:20,580 --> 00:34:24,060
into an array that contains Char

834
00:34:24,060 --> 00:34:26,520
pointers so if I send like threes and

835
00:34:26,520 --> 00:34:27,960
swings as parameters it's going to

836
00:34:27,960 --> 00:34:30,300
convert them into a chart array and then

837
00:34:30,300 --> 00:34:34,260
add them to the array of chart pointers

838
00:34:34,260 --> 00:34:37,320
so even around an error happens during

839
00:34:37,320 --> 00:34:40,020
the conversion PSP will try and free

840
00:34:40,020 --> 00:34:42,719
every pointer there is in the array but

841
00:34:42,719 --> 00:34:44,280
they won't really matter they won't

842
00:34:44,280 --> 00:34:46,139
really care if the array is initialized

843
00:34:46,139 --> 00:34:48,359
or not so that means that if I can

844
00:34:48,359 --> 00:34:49,980
trigger an error in the first element of

845
00:34:49,980 --> 00:34:52,080
the array every other value is going to

846
00:34:52,080 --> 00:34:54,719
be freed but those values weren't

847
00:34:54,719 --> 00:34:57,439
initialized

848
00:34:58,020 --> 00:35:00,720
so the Primitive that we have is a goal

849
00:35:00,720 --> 00:35:03,300
of three on any pointer the thing is

850
00:35:03,300 --> 00:35:04,980
this pointer we can't really control it

851
00:35:04,980 --> 00:35:07,640
because it's on in an initial S memory

852
00:35:07,640 --> 00:35:10,560
but how do we get a valid pointer into

853
00:35:10,560 --> 00:35:13,020
this memory because we know that PHP

854
00:35:13,020 --> 00:35:15,359
removes the Eep on every request the

855
00:35:15,359 --> 00:35:17,820
thing is PHP removed the Eep but it will

856
00:35:17,820 --> 00:35:21,240
use the same memory region to put the

857
00:35:21,240 --> 00:35:24,660
the new Eep so that means that every

858
00:35:24,660 --> 00:35:26,760
data that we have in the old Eep is

859
00:35:26,760 --> 00:35:31,280
going to link the so we have a way of

860
00:35:31,280 --> 00:35:34,700
putting any kind of pointer at any place

861
00:35:34,700 --> 00:35:37,380
using one request and then triggering

862
00:35:37,380 --> 00:35:40,920
the E3 on this pointer using another

863
00:35:40,920 --> 00:35:42,060
request

864
00:35:42,060 --> 00:35:45,359
so that means that for instance if we

865
00:35:45,359 --> 00:35:47,520
are located differently in V class 1 and

866
00:35:47,520 --> 00:35:50,339
request two we can make it so we have a

867
00:35:50,339 --> 00:35:51,900
pointer that points in the middle of

868
00:35:51,900 --> 00:35:54,300
some Zen string and if we have a pointer

869
00:35:54,300 --> 00:35:55,560
that points in the middle of some then

870
00:35:55,560 --> 00:35:58,140
string when we free it it's gonna add

871
00:35:58,140 --> 00:36:01,020
the pointer to the next free chunk into

872
00:36:01,020 --> 00:36:03,119
it and so when we display the string

873
00:36:03,119 --> 00:36:05,119
we're going to have a leak of a pointer

874
00:36:05,119 --> 00:36:08,160
uh same thing for the adverse if they

875
00:36:08,160 --> 00:36:10,560
are allocated on the hip if if we free

876
00:36:10,560 --> 00:36:12,540
the contents of the Z Val instead of

877
00:36:12,540 --> 00:36:15,180
pointing to the original value so then

878
00:36:15,180 --> 00:36:16,680
swing out as an array it's actually

879
00:36:16,680 --> 00:36:19,020
going to point to whichever tank was

880
00:36:19,020 --> 00:36:21,240
freed before so using this we can

881
00:36:21,240 --> 00:36:23,460
actually get a whole execution using

882
00:36:23,460 --> 00:36:26,280
this function but as I said nobody uses

883
00:36:26,280 --> 00:36:29,839
this so it's pretty useless

884
00:36:30,320 --> 00:36:34,220
and I'm done

885
00:36:42,300 --> 00:36:44,280
thanks Charles for this great

886
00:36:44,280 --> 00:36:45,420
presentation

887
00:36:45,420 --> 00:36:49,220
does someone have any question

888
00:36:50,820 --> 00:36:52,740
um thanks for the presentation uh do you

889
00:36:52,740 --> 00:36:55,320
know if uh in php8 they changed the

890
00:36:55,320 --> 00:36:57,300
allocator or something or improved

891
00:36:57,300 --> 00:36:59,780
anything they didn't change much

892
00:36:59,780 --> 00:37:02,220
basically it's more of a change from

893
00:37:02,220 --> 00:37:04,740
php5 to php7 where they change a lot of

894
00:37:04,740 --> 00:37:06,060
things not really in the allocator but

895
00:37:06,060 --> 00:37:08,700
even in like the structures in php5 for

896
00:37:08,700 --> 00:37:10,079
instance the Zen swing there was a

897
00:37:10,079 --> 00:37:12,180
pointer to the Chart buffer so it was

898
00:37:12,180 --> 00:37:15,119
way easier to exploit but in psp8 they

899
00:37:15,119 --> 00:37:18,839
mostly made improvements to the op code

900
00:37:18,839 --> 00:37:21,660
and uh not really to the allocator well

901
00:37:21,660 --> 00:37:23,240
I don't think so I haven't seen anything

902
00:37:23,240 --> 00:37:25,619
regarding this

903
00:37:25,619 --> 00:37:27,839
and so basically the exploits here that

904
00:37:27,839 --> 00:37:31,820
I showed easy you know on php8

905
00:37:33,420 --> 00:37:36,200
other questions

906
00:37:40,020 --> 00:37:43,910
no okay let's thank the speaker again

907
00:37:43,910 --> 00:37:47,060
[Music]

