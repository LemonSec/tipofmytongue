1
00:00:02,840 --> 00:00:07,200
okay great so I'm Quentin Kaiser I'm a

2
00:00:07,200 --> 00:00:10,679
lead security researcher at Swanky it's

3
00:00:10,679 --> 00:00:13,139
a company that does uh automated

4
00:00:13,139 --> 00:00:15,360
firmware security analysis and today

5
00:00:15,360 --> 00:00:17,640
I'll speak about the pure long journey

6
00:00:17,640 --> 00:00:20,039
that took us to the open sourcing of

7
00:00:20,039 --> 00:00:22,020
envelope which is a firmware extraction

8
00:00:22,020 --> 00:00:22,920
tool

9
00:00:22,920 --> 00:00:25,439
and we'll see all the details

10
00:00:25,439 --> 00:00:26,820
so

11
00:00:26,820 --> 00:00:29,820
um to get a shared understanding of why

12
00:00:29,820 --> 00:00:31,800
we developed envelope this is what we do

13
00:00:31,800 --> 00:00:34,320
people can upload firmers we do

14
00:00:34,320 --> 00:00:36,840
automated extraction then we perform

15
00:00:36,840 --> 00:00:40,020
from a composition analysis based on

16
00:00:40,020 --> 00:00:42,120
that we do security checks that allows

17
00:00:42,120 --> 00:00:44,640
us to provide compliance and reporting

18
00:00:44,640 --> 00:00:47,340
to a customer but I'm not here for a

19
00:00:47,340 --> 00:00:50,820
marketing talk so let's focus on the

20
00:00:50,820 --> 00:00:52,980
subject at end which is upload and

21
00:00:52,980 --> 00:00:55,620
extraction so I joined the company 18

22
00:00:55,620 --> 00:00:59,340
months ago and there were a few issues

23
00:00:59,340 --> 00:01:03,660
so on the upload side we are receiving

24
00:01:03,660 --> 00:01:06,840
lots and lots and lots of different

25
00:01:06,840 --> 00:01:10,200
firmers from different sources apart

26
00:01:10,200 --> 00:01:12,240
from our internal scrippers that

27
00:01:12,240 --> 00:01:14,880
download firmers from vendors and

28
00:01:14,880 --> 00:01:17,640
manufacturers we get upload from our

29
00:01:17,640 --> 00:01:20,460
customers but also from students or from

30
00:01:20,460 --> 00:01:24,540
researchers at universities which leads

31
00:01:24,540 --> 00:01:27,659
to different issues on their own like I

32
00:01:27,659 --> 00:01:30,320
amount of uploads lots of concurrency

33
00:01:30,320 --> 00:01:33,479
we love our customers but we should not

34
00:01:33,479 --> 00:01:35,520
trust them especially since we don't

35
00:01:35,520 --> 00:01:37,439
know the source of those uploads or

36
00:01:37,439 --> 00:01:40,220
where they found the actual Farmers

37
00:01:40,220 --> 00:01:43,439
on the extraction side we they were

38
00:01:43,439 --> 00:01:45,840
using binwook initially

39
00:01:45,840 --> 00:01:50,100
which led to a lot of timeouts there is

40
00:01:50,100 --> 00:01:53,520
a very very limited format support and

41
00:01:53,520 --> 00:01:56,399
of course the memory footprint was quite

42
00:01:56,399 --> 00:01:59,520
intense on large firmers

43
00:01:59,520 --> 00:02:02,399
so in conclusion we need to

44
00:02:02,399 --> 00:02:04,079
automatically well we need to

45
00:02:04,079 --> 00:02:06,240
automatically extract firmers of

46
00:02:06,240 --> 00:02:09,179
arbitrary Source formats coming from

47
00:02:09,179 --> 00:02:12,540
untrusted sources and do this at scale

48
00:02:12,540 --> 00:02:16,020
so that's why we started working on

49
00:02:16,020 --> 00:02:17,819
envelope which is a firmer extraction

50
00:02:17,819 --> 00:02:21,780
framework it can parse unknown files and

51
00:02:21,780 --> 00:02:24,000
much on more than well 30 different

52
00:02:24,000 --> 00:02:25,280
formats

53
00:02:25,280 --> 00:02:27,360
specifically archives compression

54
00:02:27,360 --> 00:02:30,959
streams and file systems internally we

55
00:02:30,959 --> 00:02:33,720
support like 70 formats like we have our

56
00:02:33,720 --> 00:02:37,319
internal handlers but at the moment the

57
00:02:37,319 --> 00:02:38,879
open source version you have like 10

58
00:02:38,879 --> 00:02:40,920
archive formats 10 compression streams

59
00:02:40,920 --> 00:02:43,260
and 10 Force systems

60
00:02:43,260 --> 00:02:44,879
um when we started developing envelope

61
00:02:44,879 --> 00:02:47,700
we had four clear objectives in mind

62
00:02:47,700 --> 00:02:51,480
that are derived from the um problems I

63
00:02:51,480 --> 00:02:54,239
just mentioned so we want it to be

64
00:02:54,239 --> 00:02:57,360
accurate we wanted to be secure

65
00:02:57,360 --> 00:03:00,180
extensible and fast

66
00:03:00,180 --> 00:03:03,300
so let's first look at accuracy and

67
00:03:03,300 --> 00:03:07,080
we'll see why other existing extractors

68
00:03:07,080 --> 00:03:12,000
are problematic so you get a big binary

69
00:03:12,000 --> 00:03:15,060
blob and unblock will start scanning the

70
00:03:15,060 --> 00:03:18,060
files up until the point where it will

71
00:03:18,060 --> 00:03:21,720
find a signature like most of the format

72
00:03:21,720 --> 00:03:23,819
speed compression or kind of file system

73
00:03:23,819 --> 00:03:26,159
they will start with the same magic

74
00:03:26,159 --> 00:03:29,459
bytes that you can match on and the

75
00:03:29,459 --> 00:03:32,120
magic thing with envelope is that

76
00:03:32,120 --> 00:03:35,940
it a specific antler format Ender will

77
00:03:35,940 --> 00:03:38,459
receive a reference to the file and the

78
00:03:38,459 --> 00:03:40,319
sort of set and by following the

79
00:03:40,319 --> 00:03:42,840
standards so parsing the header or

80
00:03:42,840 --> 00:03:46,140
trying to decompress and up until it

81
00:03:46,140 --> 00:03:49,860
reaches an error we will calculate the

82
00:03:49,860 --> 00:03:53,280
exact end of set of that chunk of data

83
00:03:53,280 --> 00:03:56,220
so in this case it's an ltma compressed

84
00:03:56,220 --> 00:03:59,040
stream we carve it out to disk we

85
00:03:59,040 --> 00:04:03,560
decompress it and then the decompressed

86
00:04:03,560 --> 00:04:06,780
stream is then fed back to envelope

87
00:04:06,780 --> 00:04:10,140
recursively the scanning continues

88
00:04:10,140 --> 00:04:12,780
um we identify something else again we

89
00:04:12,780 --> 00:04:15,480
can calculate the end of that so the end

90
00:04:15,480 --> 00:04:17,519
of set we calculated for

91
00:04:17,519 --> 00:04:19,918
um for some formats the whole chunk size

92
00:04:19,918 --> 00:04:22,800
is located in the header sometime we

93
00:04:22,800 --> 00:04:25,139
need to just parse the different

94
00:04:25,139 --> 00:04:27,919
subheaders well there's lots of parsing

95
00:04:27,919 --> 00:04:31,199
in there but anyway we have a specific

96
00:04:31,199 --> 00:04:34,199
end of set we covered it out it's an

97
00:04:34,199 --> 00:04:37,080
extra phase file system we extracted all

98
00:04:37,080 --> 00:04:39,660
the files within the xtfs extraction

99
00:04:39,660 --> 00:04:42,380
directory are then fed back to envelope

100
00:04:42,380 --> 00:04:46,320
recursively so it's a big change

101
00:04:46,320 --> 00:04:49,759
compared to other extractors in that

102
00:04:49,759 --> 00:04:52,860
previously or other scripts and

103
00:04:52,860 --> 00:04:55,139
techniques they will match this

104
00:04:55,139 --> 00:04:58,199
beginning and then they will feed to the

105
00:04:58,199 --> 00:04:59,940
the compressor or the extractor

106
00:04:59,940 --> 00:05:02,699
everything from the start offset up to

107
00:05:02,699 --> 00:05:04,380
the very end of the file

108
00:05:04,380 --> 00:05:07,680
if you're trying to decompress a stream

109
00:05:07,680 --> 00:05:10,320
and you have like garbage data at the

110
00:05:10,320 --> 00:05:12,860
end it will fail and the decompress

111
00:05:12,860 --> 00:05:16,680
decompress data won't be there or your

112
00:05:16,680 --> 00:05:19,740
extractor will crash silently and you

113
00:05:19,740 --> 00:05:22,440
will know nothing about this

114
00:05:22,440 --> 00:05:25,440
another thing is that since we can

115
00:05:25,440 --> 00:05:27,840
identify specifically the start of set

116
00:05:27,840 --> 00:05:31,039
and end offset of those uh chunks

117
00:05:31,039 --> 00:05:36,660
once the file has been fully scanned we

118
00:05:36,660 --> 00:05:40,020
can identify what's while turned the

119
00:05:40,020 --> 00:05:43,199
unknown unknowns into known unknowns so

120
00:05:43,199 --> 00:05:47,100
we can carve them out to disk and

121
00:05:47,100 --> 00:05:49,800
usually when you look at this these

122
00:05:49,800 --> 00:05:52,380
unknown chunks on disk this will be null

123
00:05:52,380 --> 00:05:54,900
padding zero xff padding or custom

124
00:05:54,900 --> 00:05:59,000
header and this allows us to identify

125
00:05:59,000 --> 00:06:01,380
vendor formats that we should add

126
00:06:01,380 --> 00:06:04,680
support for in on globe

127
00:06:04,680 --> 00:06:05,940
so

128
00:06:05,940 --> 00:06:09,060
um speaking of accuracy it's really

129
00:06:09,060 --> 00:06:11,639
difficult because you would think the

130
00:06:11,639 --> 00:06:13,919
just following the soundboard will be

131
00:06:13,919 --> 00:06:16,320
sufficient to support formats but it's

132
00:06:16,320 --> 00:06:19,199
not I'll give you two examples we have

133
00:06:19,199 --> 00:06:22,319
many more but for most of them I can't

134
00:06:22,319 --> 00:06:26,160
discuss them publicly so I'll start with

135
00:06:26,160 --> 00:06:29,580
squash FS so squash FS version 2 gets

136
00:06:29,580 --> 00:06:33,620
released in the early 2000s with two

137
00:06:33,620 --> 00:06:36,720
signatures one for the little Indian

138
00:06:36,720 --> 00:06:38,759
version one for the big Indian version

139
00:06:38,759 --> 00:06:44,840
so sqsh for squash and hsqs which is uh

140
00:06:44,840 --> 00:06:48,300
bytesweight byte swapped

141
00:06:48,300 --> 00:06:50,639
um so over within version three comes

142
00:06:50,639 --> 00:06:53,759
along and then version four and we

143
00:06:53,759 --> 00:06:55,800
already have a problem there because uh

144
00:06:55,800 --> 00:06:58,620
per the standard there should only be

145
00:06:58,620 --> 00:07:01,139
version four big Indian little Indian is

146
00:07:01,139 --> 00:07:04,080
non-standard but some vendors chose to

147
00:07:04,080 --> 00:07:08,580
implement it anyway then did you DDWRT

148
00:07:08,580 --> 00:07:12,479
choose to use tqsh uh as their signature

149
00:07:12,479 --> 00:07:16,259
for no specific reason protcom did it

150
00:07:16,259 --> 00:07:20,699
some a known vendor yet to identify uh

151
00:07:20,699 --> 00:07:23,699
also change the signature and then avian

152
00:07:23,699 --> 00:07:26,699
chose to well let's put the headering

153
00:07:26,699 --> 00:07:28,800
big engine and the chunks in Lillian in

154
00:07:28,800 --> 00:07:30,660
the end because why not

155
00:07:30,660 --> 00:07:33,300
and then this is quite recent I'm still

156
00:07:33,300 --> 00:07:36,180
working into on into this one uh so

157
00:07:36,180 --> 00:07:38,340
Netgear used the

158
00:07:38,340 --> 00:07:43,139
um exact same signature so this one

159
00:07:43,139 --> 00:07:44,699
um but they don't follow the standard

160
00:07:44,699 --> 00:07:47,580
they're using this lgma plus XC

161
00:07:47,580 --> 00:07:50,220
compression which of course

162
00:07:50,220 --> 00:07:52,199
um like doing two parts of compressions

163
00:07:52,199 --> 00:07:55,699
uh is always useful

164
00:07:55,860 --> 00:07:57,780
um so this is the standard and this is

165
00:07:57,780 --> 00:08:00,120
not standard but if you want to extract

166
00:08:00,120 --> 00:08:01,740
any kind of firmers you need to support

167
00:08:01,740 --> 00:08:04,520
all of those

168
00:08:04,919 --> 00:08:07,979
um let's switch to this one

169
00:08:07,979 --> 00:08:12,060
um so this was making on blob fail on

170
00:08:12,060 --> 00:08:14,220
some Crum FS

171
00:08:14,220 --> 00:08:20,099
so this is the expected CRC and this is

172
00:08:20,099 --> 00:08:22,379
the observed CRC

173
00:08:22,379 --> 00:08:26,580
this is weird something's off

174
00:08:26,580 --> 00:08:28,520
so it's Cisco

175
00:08:28,520 --> 00:08:31,319
they decided that

176
00:08:31,319 --> 00:08:34,500
um well it's still unclear if either

177
00:08:34,500 --> 00:08:37,700
it's an implementation mistake or they

178
00:08:37,700 --> 00:08:39,919
don't mind

179
00:08:39,919 --> 00:08:42,659
following the standard so it's a Serial

180
00:08:42,659 --> 00:08:45,899
methods but in Cisco world the CRC is

181
00:08:45,899 --> 00:08:47,640
quite soft

182
00:08:47,640 --> 00:08:49,740
um so we had to add support to envelope

183
00:08:49,740 --> 00:08:52,380
and working on envelope is a constant

184
00:08:52,380 --> 00:08:54,779
stream of those vendors not following uh

185
00:08:54,779 --> 00:08:56,519
standards

186
00:08:56,519 --> 00:08:58,980
so the second objective of envelope is

187
00:08:58,980 --> 00:09:02,279
security and well to be secure and we

188
00:09:02,279 --> 00:09:04,200
are looking at four

189
00:09:04,200 --> 00:09:04,800
um

190
00:09:04,800 --> 00:09:08,160
main Avenues extraction attacks

191
00:09:08,160 --> 00:09:09,420
so

192
00:09:09,420 --> 00:09:12,120
um extracting extracting uh untrusted

193
00:09:12,120 --> 00:09:15,600
firmers is kind of like pretty much

194
00:09:15,600 --> 00:09:20,959
detonating malware so you should be very

195
00:09:20,959 --> 00:09:25,500
wary of all of potential path traversal

196
00:09:25,500 --> 00:09:28,019
and extraction attacks or zip bombs for

197
00:09:28,019 --> 00:09:29,240
example

198
00:09:29,240 --> 00:09:32,640
for stability so we run on globe in

199
00:09:32,640 --> 00:09:35,339
production so it needs to be stable we

200
00:09:35,339 --> 00:09:37,740
don't want to get any crushes

201
00:09:37,740 --> 00:09:39,720
there's the question of privilege I'll

202
00:09:39,720 --> 00:09:41,480
get back to this and of course

203
00:09:41,480 --> 00:09:45,000
dependencies so for extraction attacks

204
00:09:45,000 --> 00:09:48,120
we audited uh the third party extractors

205
00:09:48,120 --> 00:09:50,279
that we rely on and we found path

206
00:09:50,279 --> 00:09:53,160
traversal vulnerabilities in Jefferson

207
00:09:53,160 --> 00:09:55,820
which is the gffs2

208
00:09:55,820 --> 00:09:59,580
fast systemic structure in Ubi feeder

209
00:09:59,580 --> 00:10:03,060
which is the UB ifs extractor in yaf

210
00:10:03,060 --> 00:10:06,420
shiv the jafas for systemic structure

211
00:10:06,420 --> 00:10:10,019
and in bin work specifically in the PFS

212
00:10:10,019 --> 00:10:13,200
for system extractor and also a few

213
00:10:13,200 --> 00:10:15,720
other logic bugs related to inode and

214
00:10:15,720 --> 00:10:19,160
Link I Stefan

215
00:10:19,160 --> 00:10:23,040
but I'll just show you a few examples

216
00:10:23,040 --> 00:10:25,920
so this is Jefferson

217
00:10:25,920 --> 00:10:28,740
um they were not even trying to protect

218
00:10:28,740 --> 00:10:31,260
against both traversal so if you were to

219
00:10:31,260 --> 00:10:34,380
craft a gfs2 file system with dot dot

220
00:10:34,380 --> 00:10:37,320
slash in a name it would be written

221
00:10:37,320 --> 00:10:41,519
outside of your extraction directory

222
00:10:41,519 --> 00:10:45,360
um similar thing with UB ifs so

223
00:10:45,360 --> 00:10:49,500
easy to identify easy to patch this

224
00:10:49,500 --> 00:10:50,880
one's a bit different it's in Europe

225
00:10:50,880 --> 00:10:54,079
shiv so we see that they were trying to

226
00:10:54,079 --> 00:10:58,459
protect against path traversal

227
00:10:58,459 --> 00:11:02,220
but this is totally well this is

228
00:11:02,220 --> 00:11:04,920
insufficient because you could craft a

229
00:11:04,920 --> 00:11:07,620
Javas file system where the name starts

230
00:11:07,620 --> 00:11:09,720
with Slash

231
00:11:09,720 --> 00:11:12,660
um so slash Etc something and it will be

232
00:11:12,660 --> 00:11:15,600
written there so this this is not

233
00:11:15,600 --> 00:11:17,399
sufficient

234
00:11:17,399 --> 00:11:21,000
um and the last one is yeah so the story

235
00:11:21,000 --> 00:11:23,579
actually started like this uh it's on

236
00:11:23,579 --> 00:11:25,800
our internal slack

237
00:11:25,800 --> 00:11:27,899
um this is on binwog

238
00:11:27,899 --> 00:11:33,680
this is the PFS file system extractor so

239
00:11:33,680 --> 00:11:38,700
the bug is uh there this line and this

240
00:11:38,700 --> 00:11:39,660
line

241
00:11:39,660 --> 00:11:44,220
so basically the condition will never be

242
00:11:44,220 --> 00:11:47,700
true this will never be this path will

243
00:11:47,700 --> 00:11:50,240
never be taken because

244
00:11:50,240 --> 00:11:52,500
os.path.join does not resolve the

245
00:11:52,500 --> 00:11:55,860
absolute path so if you do if you join

246
00:11:55,860 --> 00:11:58,160
slash Temp and dot dot slash something

247
00:11:58,160 --> 00:12:01,500
dot dot slash will stay there and ALT

248
00:12:01,500 --> 00:12:03,959
file path will always starts with out

249
00:12:03,959 --> 00:12:07,440
here so the condition will never be true

250
00:12:07,440 --> 00:12:10,019
um so the fix is super simple you just

251
00:12:10,019 --> 00:12:13,019
like resolve the absolute buff

252
00:12:13,019 --> 00:12:16,260
so it seems

253
00:12:16,260 --> 00:12:19,980
um not important I'm just looking at I

254
00:12:19,980 --> 00:12:22,620
did this way but I'll show you

255
00:12:22,620 --> 00:12:26,339
so I posted this on Twitter a few days

256
00:12:26,339 --> 00:12:28,740
ago I guess two weeks ago

257
00:12:28,740 --> 00:12:30,779
um so this is a see through the again

258
00:12:30,779 --> 00:12:32,760
sunblobe there is a pull request to fix

259
00:12:32,760 --> 00:12:35,339
it uh it's still open the ones looking

260
00:12:35,339 --> 00:12:39,140
into it so I'll just do a demo

261
00:12:39,660 --> 00:12:42,439
all right

262
00:12:42,800 --> 00:12:48,620
so I got this file open I'll download it

263
00:12:50,040 --> 00:12:52,279
foreign

264
00:12:52,820 --> 00:12:58,139
connection is quite low it's low okay

265
00:12:58,139 --> 00:13:02,839
so we see I'm downloading FG whatever

266
00:13:08,880 --> 00:13:11,279
all right so I'll parse the file with

267
00:13:11,279 --> 00:13:13,200
bin work so you can see what's in there

268
00:13:13,200 --> 00:13:15,800
uh

269
00:13:23,339 --> 00:13:28,260
so we got a JPEG image with a PFS file

270
00:13:28,260 --> 00:13:30,779
system embedded in the ICC which is the

271
00:13:30,779 --> 00:13:35,180
color profile if I do the extraction

272
00:13:37,019 --> 00:13:40,160
no ants

273
00:13:41,040 --> 00:13:43,079
you get rickrolled it should load

274
00:13:43,079 --> 00:13:44,339
YouTube

275
00:13:44,339 --> 00:13:48,060
hopefully connection is quite slow but

276
00:13:48,060 --> 00:13:48,959
anyway

277
00:13:48,959 --> 00:13:51,240
um the idea is that by abusing the buff

278
00:13:51,240 --> 00:13:54,120
traversal I'm writing a binwheel plugin

279
00:13:54,120 --> 00:13:56,040
to the bin work plugin directory which

280
00:13:56,040 --> 00:13:58,100
is always located at the same location

281
00:13:58,100 --> 00:14:01,200
and interestingly bin will constantly

282
00:14:01,200 --> 00:14:05,339
tries to load plugins as it is executing

283
00:14:05,339 --> 00:14:08,700
for some reason I don't know why but

284
00:14:08,700 --> 00:14:11,160
like in a single front like just trying

285
00:14:11,160 --> 00:14:14,399
to extract the file you will get a code

286
00:14:14,399 --> 00:14:17,459
execution on the analyst workstation so

287
00:14:17,459 --> 00:14:19,920
this is a very important problem we're

288
00:14:19,920 --> 00:14:21,839
trying to protect against with uh and

289
00:14:21,839 --> 00:14:23,279
globe

290
00:14:23,279 --> 00:14:26,279
foreign

291
00:14:28,639 --> 00:14:31,880
in terms of stability we first tested

292
00:14:31,880 --> 00:14:34,740
envelope the whole code base we found

293
00:14:34,740 --> 00:14:37,200
and fixed 19 books so far which are

294
00:14:37,200 --> 00:14:40,019
mostly logic books we have integration

295
00:14:40,019 --> 00:14:44,339
tests with integration test files and

296
00:14:44,339 --> 00:14:47,519
all over we could we managed to build a

297
00:14:47,519 --> 00:14:51,120
corpus out of those if you go to the

298
00:14:51,120 --> 00:14:54,540
GitHub repo and filter all the issues

299
00:14:54,540 --> 00:14:57,779
with the fuzzing label you will see all

300
00:14:57,779 --> 00:15:01,620
the bugs if that's of interest to you

301
00:15:01,620 --> 00:15:03,660
um regarding dependencies or or

302
00:15:03,660 --> 00:15:06,120
dependencies are locked we are using

303
00:15:06,120 --> 00:15:08,339
poetry so we are protecting against

304
00:15:08,339 --> 00:15:11,100
potential supply chain attacks

305
00:15:11,100 --> 00:15:13,199
um and it's even better if you use NYX

306
00:15:13,199 --> 00:15:15,680
but I will get into next uh a bit later

307
00:15:15,680 --> 00:15:19,680
also we took the kind of opinionated

308
00:15:19,680 --> 00:15:22,940
decision to not require not require

309
00:15:22,940 --> 00:15:26,760
elevated privileges which means we can't

310
00:15:26,760 --> 00:15:29,160
create special files like block devices

311
00:15:29,160 --> 00:15:31,860
or character devices

312
00:15:31,860 --> 00:15:32,639
um

313
00:15:32,639 --> 00:15:36,420
it's okay for reviews but for example if

314
00:15:36,420 --> 00:15:38,699
you wanted to emulate

315
00:15:38,699 --> 00:15:42,240
um a device with this file system using

316
00:15:42,240 --> 00:15:45,959
qmu for example this decision May limit

317
00:15:45,959 --> 00:15:50,719
you in what you you can actually emulate

318
00:15:50,940 --> 00:15:53,519
um third objective is to be extensible

319
00:15:53,519 --> 00:15:55,440
and I'm using the analogy with

320
00:15:55,440 --> 00:15:59,519
metasploits so when HTML started working

321
00:15:59,519 --> 00:16:02,459
on on Metasploit it's because he was

322
00:16:02,459 --> 00:16:04,800
spending all of his time validating and

323
00:16:04,800 --> 00:16:08,339
sanitizing exploit code and it's pretty

324
00:16:08,339 --> 00:16:10,620
much the same situation at the moment if

325
00:16:10,620 --> 00:16:13,079
you're doing embedded firmware security

326
00:16:13,079 --> 00:16:16,320
and looking at all those vendors formats

327
00:16:16,320 --> 00:16:18,899
like everyone is publishing their own

328
00:16:18,899 --> 00:16:22,800
tools this is like for Netgear then for

329
00:16:22,800 --> 00:16:26,579
IG vision for three three Tech three

330
00:16:26,579 --> 00:16:28,560
Tech healing from the guys that's

331
00:16:28,560 --> 00:16:30,139
inactive

332
00:16:30,139 --> 00:16:33,000
so everyone is like rewriting the same

333
00:16:33,000 --> 00:16:35,040
thing over and over and over again

334
00:16:35,040 --> 00:16:38,399
mostly in Python and then the tools are

335
00:16:38,399 --> 00:16:41,220
published and they're not maintained so

336
00:16:41,220 --> 00:16:43,980
the idea is to provide with envelope a

337
00:16:43,980 --> 00:16:46,639
firmware that will do all the AV lifting

338
00:16:46,639 --> 00:16:50,699
and will constantly maintain all the a

339
00:16:50,699 --> 00:16:53,160
potential format Enders that you add to

340
00:16:53,160 --> 00:16:55,339
it

341
00:16:55,399 --> 00:16:59,579
last objective is to be blazing fast so

342
00:16:59,579 --> 00:17:02,759
we took a few decisions there we are

343
00:17:02,759 --> 00:17:04,859
using hyperscan which is an Intel

344
00:17:04,859 --> 00:17:07,079
pattern matching Library which takes

345
00:17:07,079 --> 00:17:09,079
advantage of

346
00:17:09,079 --> 00:17:12,179
architecture op codes like all of those

347
00:17:12,179 --> 00:17:16,020
CMD operations we were initially using

348
00:17:16,020 --> 00:17:21,119
javra to do pattern matching but we

349
00:17:21,119 --> 00:17:24,179
found so many bugs and it was getting

350
00:17:24,179 --> 00:17:27,059
quite slow the more Handler we were

351
00:17:27,059 --> 00:17:29,400
adding that we switched to hyperscan and

352
00:17:29,400 --> 00:17:31,740
it's the best decision that we that we

353
00:17:31,740 --> 00:17:33,179
took

354
00:17:33,179 --> 00:17:35,760
um we are free lagging on the thrust for

355
00:17:35,760 --> 00:17:37,500
memory intensive operation like

356
00:17:37,500 --> 00:17:39,780
calculating the Shannon entropy of on

357
00:17:39,780 --> 00:17:42,059
unknown chunks at the beginning of the

358
00:17:42,059 --> 00:17:43,679
talk I showed you like the unknown

359
00:17:43,679 --> 00:17:46,320
chunks being carved out to disk um this

360
00:17:46,320 --> 00:17:48,120
is interesting to calculate the entropy

361
00:17:48,120 --> 00:17:51,000
so that we can detect whether it's

362
00:17:51,000 --> 00:17:54,059
um heavily compressed or potentially

363
00:17:54,059 --> 00:17:55,679
encrypted

364
00:17:55,679 --> 00:17:57,960
and the last thing is that we are using

365
00:17:57,960 --> 00:18:01,020
modern python using mapped file which

366
00:18:01,020 --> 00:18:04,620
means it's even faster

367
00:18:04,620 --> 00:18:06,539
um just to take a look

368
00:18:06,539 --> 00:18:10,320
um I calculated so I run envelope on I

369
00:18:10,320 --> 00:18:12,419
think a thousand samples that I took

370
00:18:12,419 --> 00:18:15,900
picked up randomly from our our Corpus

371
00:18:15,900 --> 00:18:20,039
uh most of our Corpus is below the 500

372
00:18:20,039 --> 00:18:22,620
megabytes uh line

373
00:18:22,620 --> 00:18:26,120
um and everything is like

374
00:18:26,120 --> 00:18:29,100
below way below uh two minutes of

375
00:18:29,100 --> 00:18:31,559
extraction time and you get like kind of

376
00:18:31,559 --> 00:18:33,240
a trend if you look at the actual

377
00:18:33,240 --> 00:18:36,020
extracted size

378
00:18:37,140 --> 00:18:40,620
all right so just a quick shout out to

379
00:18:40,620 --> 00:18:42,299
the team behind that blob it's not only

380
00:18:42,299 --> 00:18:46,740
me uh it's uh of a very dedicated uh

381
00:18:46,740 --> 00:18:49,140
python uh development team and my

382
00:18:49,140 --> 00:18:51,480
research team uh all of them are there

383
00:18:51,480 --> 00:18:55,020
so thanks to all of them so um the

384
00:18:55,020 --> 00:18:58,679
objective is to teach you how to get

385
00:18:58,679 --> 00:19:00,900
sorted with envelope or you can create

386
00:19:00,900 --> 00:19:02,419
Enders

387
00:19:02,419 --> 00:19:06,179
or you can create extractors and I'll

388
00:19:06,179 --> 00:19:09,240
switch to this so um there are different

389
00:19:09,240 --> 00:19:11,640
ways you can install envelope you can

390
00:19:11,640 --> 00:19:13,860
use Docker you can use NYX or you can go

391
00:19:13,860 --> 00:19:18,780
the hardcore way and use source so um

392
00:19:18,780 --> 00:19:21,299
for Docker we have a container that is

393
00:19:21,299 --> 00:19:23,960
published to the GitHub Docker registry

394
00:19:23,960 --> 00:19:26,940
we just recommend that you use the dash

395
00:19:26,940 --> 00:19:28,980
dash pool always so you always get the

396
00:19:28,980 --> 00:19:31,080
latest version it's under every

397
00:19:31,080 --> 00:19:33,780
development so if you don't do this you

398
00:19:33,780 --> 00:19:37,918
won't get the latest fixes

399
00:19:38,880 --> 00:19:41,640
um and we are using bind mounts with the

400
00:19:41,640 --> 00:19:43,860
minus V option so that you can get the

401
00:19:43,860 --> 00:19:46,380
input directory to put your firmware

402
00:19:46,380 --> 00:19:48,059
file there and the output directory

403
00:19:48,059 --> 00:19:52,320
where all the extraction will be located

404
00:19:52,320 --> 00:19:56,760
um we also have a NYX nerds in the team

405
00:19:56,760 --> 00:20:00,660
so mix is a way to perform reproducible

406
00:20:00,660 --> 00:20:01,820
builds

407
00:20:01,820 --> 00:20:05,160
and if you do next profile install it

408
00:20:05,160 --> 00:20:07,440
will install and block with all of its

409
00:20:07,440 --> 00:20:10,520
dependencies in a self-contained

410
00:20:10,520 --> 00:20:13,200
environment that won't pollute your

411
00:20:13,200 --> 00:20:16,140
whole file system

412
00:20:16,140 --> 00:20:19,200
and the last way is just clone the repo

413
00:20:19,200 --> 00:20:22,620
use poetry to uh to install it

414
00:20:22,620 --> 00:20:24,840
um so let's take for example and we'll

415
00:20:24,840 --> 00:20:28,399
see how it actually works

416
00:20:36,320 --> 00:20:39,299
all right so

417
00:20:39,299 --> 00:20:43,140
um I'll start with an open WT open wrt

418
00:20:43,140 --> 00:20:46,740
image so we'll see how it actually looks

419
00:20:46,740 --> 00:20:47,480
like

420
00:20:47,480 --> 00:20:50,940
uh so first three years from envelope

421
00:20:50,940 --> 00:20:53,700
will run in verbose modes I'll extract

422
00:20:53,700 --> 00:20:57,120
to slash them slash out

423
00:20:57,120 --> 00:21:01,219
I want to extract

424
00:21:04,799 --> 00:21:07,200
so it's quite verbose at the moment uh

425
00:21:07,200 --> 00:21:10,140
we'll see it's part of future work

426
00:21:10,140 --> 00:21:12,120
um so the extraction is done and we can

427
00:21:12,120 --> 00:21:15,600
go into the extraction directory just

428
00:21:15,600 --> 00:21:18,379
take a look

429
00:21:21,240 --> 00:21:22,620
all right

430
00:21:22,620 --> 00:21:24,600
um so all the files are named after

431
00:21:24,600 --> 00:21:28,140
their start and end offset in

432
00:21:28,140 --> 00:21:32,220
um decimal representation so we see that

433
00:21:32,220 --> 00:21:36,179
we have like 64 bytes of unknown data an

434
00:21:36,179 --> 00:21:39,059
lcma stream followed by another random

435
00:21:39,059 --> 00:21:42,360
chunk and then a squash FS V4 for system

436
00:21:42,360 --> 00:21:46,320
followed Again by some unknown data I'm

437
00:21:46,320 --> 00:21:48,480
using the HX command which is basically

438
00:21:48,480 --> 00:21:52,799
an alias 4X dump in ASCII so if we look

439
00:21:52,799 --> 00:21:56,159
into it into this one it's basically the

440
00:21:56,159 --> 00:21:58,860
open w RT custom header with the

441
00:21:58,860 --> 00:22:01,799
metadata about this package

442
00:22:01,799 --> 00:22:03,000
um

443
00:22:03,000 --> 00:22:07,020
so whenever we get uploads uh and that

444
00:22:07,020 --> 00:22:09,059
we have like a custom header uh it's

445
00:22:09,059 --> 00:22:11,340
super easy like we take a x term of this

446
00:22:11,340 --> 00:22:14,400
value we open a ticket and whenever we

447
00:22:14,400 --> 00:22:16,260
have time we extend like the list of

448
00:22:16,260 --> 00:22:19,440
envelope Enders to uh to support those

449
00:22:19,440 --> 00:22:22,080
um I'll quickly show you the uh

450
00:22:22,080 --> 00:22:24,900
different unknown chunks

451
00:22:24,900 --> 00:22:28,980
so um between the lcma and the Squash FS

452
00:22:28,980 --> 00:22:32,340
file system we get null bytes so like

453
00:22:32,340 --> 00:22:37,159
this this is proof that or

454
00:22:37,159 --> 00:22:39,840
extractor is actually accurate in

455
00:22:39,840 --> 00:22:41,940
identifying the start and end offset of

456
00:22:41,940 --> 00:22:46,200
those valid lcma and squash FS

457
00:22:46,200 --> 00:22:48,299
and if we look at this one it's just

458
00:22:48,299 --> 00:22:51,480
zero xff padding with that code at the

459
00:22:51,480 --> 00:22:57,679
end which is a marker used by open wdrt

460
00:22:57,679 --> 00:23:02,580
if we look at the lcma content

461
00:23:02,580 --> 00:23:04,679
it got decompressed and within the

462
00:23:04,679 --> 00:23:09,120
decompressed lcma stream we found other

463
00:23:09,120 --> 00:23:10,679
things

464
00:23:10,679 --> 00:23:13,760
I'll just

465
00:23:15,179 --> 00:23:17,000
um and this is actually

466
00:23:17,000 --> 00:23:21,120
the Linux kernel so the lgma stream is

467
00:23:21,120 --> 00:23:22,860
actually the busy image that is used to

468
00:23:22,860 --> 00:23:24,120
boot

469
00:23:24,120 --> 00:23:25,919
um we have and the rotative that we have

470
00:23:25,919 --> 00:23:28,500
yet to open source that's uh much on

471
00:23:28,500 --> 00:23:31,440
those kernels uh that makes things

472
00:23:31,440 --> 00:23:34,500
better than this output but anyway you

473
00:23:34,500 --> 00:23:37,640
see uh you see the point

474
00:23:37,980 --> 00:23:42,120
and of course the last one is this

475
00:23:42,120 --> 00:23:44,460
squasher first of all system got

476
00:23:44,460 --> 00:23:47,820
extracted you get your usual suspects

477
00:23:47,820 --> 00:23:51,000
there in a Linux

478
00:23:51,000 --> 00:23:54,000
repo

479
00:23:56,400 --> 00:23:59,100
one thing we can do with envelope is

480
00:23:59,100 --> 00:24:02,159
also to generate reports so you can

481
00:24:02,159 --> 00:24:03,299
generate

482
00:24:03,299 --> 00:24:06,419
um generate jsons reports that will

483
00:24:06,419 --> 00:24:10,380
contain a lot of metadata about the

484
00:24:10,380 --> 00:24:12,960
extraction process so I'll just do this

485
00:24:12,960 --> 00:24:15,200
now

486
00:24:15,659 --> 00:24:19,140
so minus F so we overwrite

487
00:24:19,140 --> 00:24:22,159
then Freeport

488
00:24:23,400 --> 00:24:26,400
foreign

489
00:24:33,679 --> 00:24:36,360
structure so

490
00:24:36,360 --> 00:24:39,780
um this ship jsons report will contain

491
00:24:39,780 --> 00:24:41,539
um permissions information

492
00:24:41,539 --> 00:24:45,960
uh the magic mime type the ashes in

493
00:24:45,960 --> 00:24:48,120
different formats for all of the files

494
00:24:48,120 --> 00:24:50,460
the files that were analyzed to files

495
00:24:50,460 --> 00:24:52,740
that were extracted the files that were

496
00:24:52,740 --> 00:24:54,500
decompressed

497
00:24:54,500 --> 00:24:58,260
the objective for the future is to store

498
00:24:58,260 --> 00:25:01,260
even more metadata prior to the

499
00:25:01,260 --> 00:25:04,020
extraction you have some formats for

500
00:25:04,020 --> 00:25:07,980
example like tar which store the owner

501
00:25:07,980 --> 00:25:12,720
information as a text so for example if

502
00:25:12,720 --> 00:25:14,940
the guitar archive was created by Alice

503
00:25:14,940 --> 00:25:17,400
and it's extracted by Bob we want to

504
00:25:17,400 --> 00:25:18,900
store the information that it was

505
00:25:18,900 --> 00:25:21,360
compressed by well created by Alice

506
00:25:21,360 --> 00:25:24,600
because once it's extracted by Bob the

507
00:25:24,600 --> 00:25:28,020
information is lost because the uids are

508
00:25:28,020 --> 00:25:30,000
different and because the torque much is

509
00:25:30,000 --> 00:25:32,340
not relying on this owner information to

510
00:25:32,340 --> 00:25:35,159
do anything on disk actually one

511
00:25:35,159 --> 00:25:36,720
interesting thing you can do with those

512
00:25:36,720 --> 00:25:39,779
reports is to generate diagrams and

513
00:25:39,779 --> 00:25:41,940
visualizations of what's what got

514
00:25:41,940 --> 00:25:44,480
extracted

515
00:25:46,799 --> 00:25:51,620
so I'll just start my Jupiter notebook

516
00:25:56,340 --> 00:25:58,620
all right so we're basically using

517
00:25:58,620 --> 00:26:01,740
portly reading the jsons report to

518
00:26:01,740 --> 00:26:04,700
generate the diagram

519
00:26:07,200 --> 00:26:10,559
okay so um

520
00:26:10,559 --> 00:26:15,779
this one is a uh is a trim up view so

521
00:26:15,779 --> 00:26:20,220
you see the uh overall firmer then you

522
00:26:20,220 --> 00:26:22,200
get the squash effects on one side then

523
00:26:22,200 --> 00:26:24,779
the PC image on the other side and

524
00:26:24,779 --> 00:26:27,240
whatever got extracted from the squash

525
00:26:27,240 --> 00:26:30,840
of us is grouped by file type which you

526
00:26:30,840 --> 00:26:32,600
can also do

527
00:26:32,600 --> 00:26:36,600
sunburst visualizations

528
00:26:39,960 --> 00:26:43,559
like this and you can navigate uh just

529
00:26:43,559 --> 00:26:46,500
clicking on any Inner Circle to

530
00:26:46,500 --> 00:26:48,840
understand what what is actually

531
00:26:48,840 --> 00:26:52,380
contained in any uh lower layers of your

532
00:26:52,380 --> 00:26:55,220
firmware

533
00:27:03,960 --> 00:27:05,279
all right

534
00:27:05,279 --> 00:27:09,120
um I'll switch to uh how to write Enders

535
00:27:09,120 --> 00:27:14,178
and show you how easy it is to do it

536
00:27:19,159 --> 00:27:22,260
we used to do the live demo like live

537
00:27:22,260 --> 00:27:24,900
coding demonstration but in the end we

538
00:27:24,900 --> 00:27:27,240
have just tags in our GitHub

539
00:27:27,240 --> 00:27:29,580
in order for kids repo because it's

540
00:27:29,580 --> 00:27:32,100
easier

541
00:27:32,100 --> 00:27:34,639
so

542
00:27:40,020 --> 00:27:42,960
I'll um quickly show you an example it's

543
00:27:42,960 --> 00:27:47,880
a Netgear firmware for the r7000 halter

544
00:27:47,880 --> 00:27:51,799
I'll just extract it

545
00:28:04,440 --> 00:28:06,059
all right

546
00:28:06,059 --> 00:28:06,840
um

547
00:28:06,840 --> 00:28:09,439
so

548
00:28:12,779 --> 00:28:14,820
um what's interesting is that this

549
00:28:14,820 --> 00:28:17,880
Netgear firmware format is actually an

550
00:28:17,880 --> 00:28:22,320
uh chk format if you look at it so it

551
00:28:22,320 --> 00:28:25,679
always starts with this uh these magic

552
00:28:25,679 --> 00:28:31,320
bytes like Star Dash uh tool or correct

553
00:28:31,320 --> 00:28:31,980
um

554
00:28:31,980 --> 00:28:35,460
so we want to write a custom Handler for

555
00:28:35,460 --> 00:28:39,620
this chk to take it into account

556
00:28:45,539 --> 00:28:50,159
hope this is visible yes so the idea

557
00:28:50,159 --> 00:28:53,400
with envelope is that you just need to

558
00:28:53,400 --> 00:28:56,760
um create a another class that should

559
00:28:56,760 --> 00:28:58,919
interpret either Handler or strict

560
00:28:58,919 --> 00:29:02,159
Handler all of those Handler must Define

561
00:29:02,159 --> 00:29:06,600
a patterns list which can be defined as

562
00:29:06,600 --> 00:29:08,760
strings or X strings so in this case

563
00:29:08,760 --> 00:29:11,279
those are the four magic bytes that

564
00:29:11,279 --> 00:29:16,020
starts the chk header and all of those

565
00:29:16,020 --> 00:29:18,779
Handler must implement the calculate

566
00:29:18,779 --> 00:29:21,840
chunk function which takes a file a

567
00:29:21,840 --> 00:29:23,460
reference to the file which is our

568
00:29:23,460 --> 00:29:26,100
mapped file and the sort of sets where

569
00:29:26,100 --> 00:29:29,240
the pattern was actually identified

570
00:29:29,240 --> 00:29:32,039
with the structender you get the ability

571
00:29:32,039 --> 00:29:36,419
to define a structure in C so this is

572
00:29:36,419 --> 00:29:38,760
the actual structure of chk so you get

573
00:29:38,760 --> 00:29:41,220
the magic the header Len and then those

574
00:29:41,220 --> 00:29:43,080
firmware

575
00:29:43,080 --> 00:29:46,740
change two things well one or two things

576
00:29:46,740 --> 00:29:50,159
a kernel and the fruit FS so you get

577
00:29:50,159 --> 00:29:52,500
your header then the kernel then the

578
00:29:52,500 --> 00:29:55,559
root FS so if you know the length of

579
00:29:55,559 --> 00:29:57,320
each you can

580
00:29:57,320 --> 00:30:00,299
exactly calculate the end of set which

581
00:30:00,299 --> 00:30:02,760
is or start to set close the length of

582
00:30:02,760 --> 00:30:04,500
the header plus the length of the kernel

583
00:30:04,500 --> 00:30:07,100
that's the length of the root FS

584
00:30:07,100 --> 00:30:11,100
and the struct tender just supported

585
00:30:11,100 --> 00:30:14,220
with this bar Setter function

586
00:30:14,220 --> 00:30:16,940
so

587
00:30:18,899 --> 00:30:22,880
if I run the extraction again

588
00:30:22,880 --> 00:30:26,100
this time we see the header which is

589
00:30:26,100 --> 00:30:29,460
printed out in the in the console or

590
00:30:29,460 --> 00:30:31,080
calculation is so good that the chunk

591
00:30:31,080 --> 00:30:33,240
covers till the end of the file and we

592
00:30:33,240 --> 00:30:36,659
didn't Define any extractor yet so uh it

593
00:30:36,659 --> 00:30:39,240
just stayed there there are no extracted

594
00:30:39,240 --> 00:30:41,659
content so now we need to actually

595
00:30:41,659 --> 00:30:46,520
Implement an extractor for chk

596
00:30:52,740 --> 00:30:54,980
foreign

597
00:31:20,159 --> 00:31:22,620
I'll switch to the rests

598
00:31:22,620 --> 00:31:27,559
well I get connectivity for some reason

599
00:31:29,720 --> 00:31:33,179
uh anyway

600
00:31:33,179 --> 00:31:35,760
um so for extractors you can Implement

601
00:31:35,760 --> 00:31:38,220
them in unblock but for most of our

602
00:31:38,220 --> 00:31:41,159
formats we rely on third-party

603
00:31:41,159 --> 00:31:44,580
extractors like the ones I named like

604
00:31:44,580 --> 00:31:49,159
Jefferson Sasquatch Ubi reader reactive

605
00:31:49,159 --> 00:31:52,980
but for the most complex one we just

606
00:31:52,980 --> 00:31:57,080
showed them in envelope

607
00:31:57,179 --> 00:32:00,600
um in terms of future work we want a

608
00:32:00,600 --> 00:32:02,159
clean report of the extraction process

609
00:32:02,159 --> 00:32:05,220
in the console as you've seen it's quite

610
00:32:05,220 --> 00:32:08,340
verbose and they're like struct logs uh

611
00:32:08,340 --> 00:32:10,500
everywhere so

612
00:32:10,500 --> 00:32:12,179
um what we want is to provide just a

613
00:32:12,179 --> 00:32:14,700
clean summary to end users with for

614
00:32:14,700 --> 00:32:17,820
example X percentage of the firmware was

615
00:32:17,820 --> 00:32:21,179
properly identified why files were

616
00:32:21,179 --> 00:32:25,620
extracted just to get a nice and clean

617
00:32:25,620 --> 00:32:29,700
summary as I mentioned with the tar

618
00:32:29,700 --> 00:32:31,220
archive

619
00:32:31,220 --> 00:32:34,440
example we want to increase metadata

620
00:32:34,440 --> 00:32:37,740
extraction so prior to actually doing

621
00:32:37,740 --> 00:32:39,779
the the compression to disk or the

622
00:32:39,779 --> 00:32:42,140
extraction to disk we want to collect

623
00:32:42,140 --> 00:32:45,320
any kind of metadata information

624
00:32:45,320 --> 00:32:48,299
that can be collected from the header or

625
00:32:48,299 --> 00:32:51,559
metadata metadata structures on those

626
00:32:51,559 --> 00:32:53,539
formats

627
00:32:53,539 --> 00:32:57,419
one interesting example are you go to

628
00:32:57,419 --> 00:32:59,580
your image where in the header you get

629
00:32:59,580 --> 00:33:01,860
the load address it's of great interest

630
00:33:01,860 --> 00:33:05,100
to us in the uh firmware analysis

631
00:33:05,100 --> 00:33:07,940
pipeline so we want to keep it in our

632
00:33:07,940 --> 00:33:11,039
jsons reports

633
00:33:11,039 --> 00:33:14,039
um unknown chunks Auto identification is

634
00:33:14,039 --> 00:33:16,200
also a big project we've got some proof

635
00:33:16,200 --> 00:33:18,559
of concept but they're not public yet

636
00:33:18,559 --> 00:33:22,679
basically an unknown chunk is uh like

637
00:33:22,679 --> 00:33:24,360
the one I've shown at the very beginning

638
00:33:24,360 --> 00:33:26,760
that contains like null bytes or zero

639
00:33:26,760 --> 00:33:30,059
rakes FF bytes they're basically python

640
00:33:30,059 --> 00:33:31,100
objects

641
00:33:31,100 --> 00:33:34,220
we want them to be able to perform

642
00:33:34,220 --> 00:33:36,840
introspections so looking into their own

643
00:33:36,840 --> 00:33:41,640
memory and mutate themselves so if an

644
00:33:41,640 --> 00:33:44,039
unknown chunk is full of null bytes it

645
00:33:44,039 --> 00:33:47,399
would meet it into a null padding so it

646
00:33:47,399 --> 00:33:50,899
would be even visible from the file name

647
00:33:50,899 --> 00:33:54,000
the analysts don't even need to like do

648
00:33:54,000 --> 00:33:56,159
an accident of the trunk it would be

649
00:33:56,159 --> 00:33:59,059
just dot nil padding or dot FF padding

650
00:33:59,059 --> 00:34:02,700
it would be even cleaner of course we

651
00:34:02,700 --> 00:34:06,899
want to extend the format support uh any

652
00:34:06,899 --> 00:34:08,879
kind of vendor format that you can think

653
00:34:08,879 --> 00:34:13,040
of we'd like to support it

654
00:34:13,040 --> 00:34:16,560
you are all very welcome to contribute

655
00:34:16,560 --> 00:34:20,339
uh test it on your weirdest files uh any

656
00:34:20,339 --> 00:34:22,800
kind of weird files just run from

657
00:34:22,800 --> 00:34:27,599
envelope on onto it report box frequent

658
00:34:27,599 --> 00:34:29,940
support for new formats we got a few of

659
00:34:29,940 --> 00:34:32,159
them since this summer when we presented

660
00:34:32,159 --> 00:34:37,739
at Defcon for qnx ifs and QT resource

661
00:34:37,739 --> 00:34:42,179
file if I'm not mistaken of course

662
00:34:42,179 --> 00:34:45,239
if you used envelope into your own

663
00:34:45,239 --> 00:34:47,879
projects uh submit the post requests if

664
00:34:47,879 --> 00:34:49,500
you're not a professional python

665
00:34:49,500 --> 00:34:51,839
developer the team will help you and

666
00:34:51,839 --> 00:34:55,859
there are lots of car Trails into the um

667
00:34:55,859 --> 00:34:59,160
the way we we develop uh we're using

668
00:34:59,160 --> 00:35:01,940
black to

669
00:35:01,940 --> 00:35:05,520
link the python files we are using

670
00:35:05,520 --> 00:35:08,040
vulture to identify that code there are

671
00:35:08,040 --> 00:35:09,660
lots of integration tests that are

672
00:35:09,660 --> 00:35:11,760
running so it's really difficult to make

673
00:35:11,760 --> 00:35:14,880
mistakes writing a loop code I'll check

674
00:35:14,880 --> 00:35:19,579
if okay cool step two

675
00:35:22,040 --> 00:35:27,900
so uh we want to do the chk extractor

676
00:35:27,900 --> 00:35:30,839
um so an extractor must inherit the

677
00:35:30,839 --> 00:35:34,280
extractor class and this class

678
00:35:34,280 --> 00:35:36,900
has a single function that you must

679
00:35:36,900 --> 00:35:39,000
overload which is the extract

680
00:35:39,000 --> 00:35:42,720
two parameters in path which is uh the

681
00:35:42,720 --> 00:35:45,180
path to the curvedoor chunk that was

682
00:35:45,180 --> 00:35:47,760
written to disk and the old deer which

683
00:35:47,760 --> 00:35:50,700
is the extraction directory well where

684
00:35:50,700 --> 00:35:53,180
you need to perform your extraction

685
00:35:53,180 --> 00:35:56,460
so basically this chk extractor is

686
00:35:56,460 --> 00:35:59,220
forcing the header seeking to the end of

687
00:35:59,220 --> 00:36:02,000
the header and then dumping the kernel

688
00:36:02,000 --> 00:36:04,380
kernel chunk and then the root of this

689
00:36:04,380 --> 00:36:09,000
chunk so if we re-run unblock with this

690
00:36:09,000 --> 00:36:12,000
addition

691
00:36:15,060 --> 00:36:16,740
we get

692
00:36:16,740 --> 00:36:19,640
something new

693
00:36:20,400 --> 00:36:22,980
all right so in this case there is no

694
00:36:22,980 --> 00:36:25,680
fruit Fs in this chk firmware we only

695
00:36:25,680 --> 00:36:27,660
got the kernel and if we go to the

696
00:36:27,660 --> 00:36:29,880
kernel

697
00:36:29,880 --> 00:36:34,440
um we still have a 28 bytes of unknown

698
00:36:34,440 --> 00:36:36,680
data

699
00:36:36,680 --> 00:36:41,220
hdr0 it's actually another format from

700
00:36:41,220 --> 00:36:44,160
Netgear called TRX or actually or used

701
00:36:44,160 --> 00:36:46,440
by Netgear called TRX

702
00:36:46,440 --> 00:36:49,020
so next step is actually to implement a

703
00:36:49,020 --> 00:36:54,020
TRX format Handler with envelope

704
00:36:57,180 --> 00:37:01,879
and it will block again so I'll switch

705
00:37:05,220 --> 00:37:07,260
foreign

706
00:37:07,260 --> 00:37:09,599
I'll go back to the code if you have

707
00:37:09,599 --> 00:37:12,599
time but in the meantime uh thank you

708
00:37:12,599 --> 00:37:15,060
very much for your attention instantiary

709
00:37:15,060 --> 00:37:18,839
emails can be sent to research 1k.com

710
00:37:18,839 --> 00:37:21,500
um thank you

711
00:37:31,079 --> 00:37:34,220
do we have any questions

712
00:37:35,700 --> 00:37:38,419
yes

713
00:37:38,940 --> 00:37:41,280
it seems that you're using a lot of

714
00:37:41,280 --> 00:37:43,740
different tools to extract like 7-Zip

715
00:37:43,740 --> 00:37:46,380
tire and whatnot yeah are you sandboxing

716
00:37:46,380 --> 00:37:48,900
tools are you fuzzing them

717
00:37:48,900 --> 00:37:52,859
um so we audited mostly the python-based

718
00:37:52,859 --> 00:37:54,540
extraction tools

719
00:37:54,540 --> 00:37:57,900
um and other like in our infrastructure

720
00:37:57,900 --> 00:38:00,599
we are using sandboxing like on top of

721
00:38:00,599 --> 00:38:02,640
Unblock we're not relying just on the

722
00:38:02,640 --> 00:38:04,880
fact that we audited them

723
00:38:04,880 --> 00:38:09,240
we are using fire kill with like all

724
00:38:09,240 --> 00:38:11,760
everything disabled uh

725
00:38:11,760 --> 00:38:14,820
that's uh

726
00:38:14,820 --> 00:38:16,800
and also do you plan to open sort your

727
00:38:16,800 --> 00:38:18,839
fuzzing infrastructure I haven't seen

728
00:38:18,839 --> 00:38:21,480
the fuzzers in you the source code

729
00:38:21,480 --> 00:38:23,160
um yeah the first order is not is not

730
00:38:23,160 --> 00:38:25,680
public but we could make it public it's

731
00:38:25,680 --> 00:38:28,020
basically feeding off the so all the

732
00:38:28,020 --> 00:38:31,260
integration tests for example

733
00:38:31,260 --> 00:38:34,339
if I were to

734
00:38:37,200 --> 00:38:38,640
yay

735
00:38:38,640 --> 00:38:42,060
that's it um so if you run Pi test uh on

736
00:38:42,060 --> 00:38:46,500
the freepo um you will see that it tries

737
00:38:46,500 --> 00:38:48,480
to run all the Androids on different

738
00:38:48,480 --> 00:38:50,880
integration test files

739
00:38:50,880 --> 00:38:53,820
so if I do

740
00:38:53,820 --> 00:38:56,460
three

741
00:38:56,460 --> 00:38:58,680
it will collect the samples but anyway

742
00:38:58,680 --> 00:39:02,040
you can officer will just

743
00:39:02,040 --> 00:39:04,200
um take all the integration test files

744
00:39:04,200 --> 00:39:07,500
as Corpus and do like uh mutation on

745
00:39:07,500 --> 00:39:09,300
them and just feeding them to envelope

746
00:39:09,300 --> 00:39:11,760
to see what's happening

747
00:39:11,760 --> 00:39:14,300
thanks

748
00:39:25,560 --> 00:39:29,460
and do you have the what you showed to

749
00:39:29,460 --> 00:39:32,220
create a new a new password is it

750
00:39:32,220 --> 00:39:34,440
available on your GitHub repository so

751
00:39:34,440 --> 00:39:38,579
that we can actually do another one

752
00:39:38,579 --> 00:39:42,079
so if you go to

753
00:39:42,079 --> 00:39:46,520
envelope.org and go to development

754
00:39:46,520 --> 00:39:49,079
there is a whole guide like developer

755
00:39:49,079 --> 00:39:52,520
guidelines uh that explains with really

756
00:39:52,520 --> 00:39:55,560
simple example how to write a new

757
00:39:55,560 --> 00:39:58,440
Handler so first thing setting up the

758
00:39:58,440 --> 00:40:00,420
the dev on

759
00:40:00,420 --> 00:40:03,839
and then like writing Elders so this is

760
00:40:03,839 --> 00:40:04,980
a really

761
00:40:04,980 --> 00:40:09,000
super simple example that you can start

762
00:40:09,000 --> 00:40:12,060
off to to write your own handlers or

763
00:40:12,060 --> 00:40:16,820
extractors it it's uh on envelope.org

764
00:40:22,000 --> 00:40:25,199
[Music]

765
00:40:28,970 --> 00:40:32,060
[Music]

766
00:40:32,060 --> 00:40:34,380
just another question on these handlers

767
00:40:34,380 --> 00:40:36,720
so they could handle the case that we

768
00:40:36,720 --> 00:40:38,280
saw in the morning with the printers

769
00:40:38,280 --> 00:40:41,040
where they need to de-oppuscate the

770
00:40:41,040 --> 00:40:43,619
binary first before then and then they

771
00:40:43,619 --> 00:40:46,320
could pass it in a queue to the actual

772
00:40:46,320 --> 00:40:49,500
extraction will that also work

773
00:40:49,500 --> 00:40:53,460
uh so if if we take the the

774
00:40:53,460 --> 00:40:56,220
um Canon printer example uh they could

775
00:40:56,220 --> 00:40:59,760
write a enter that would match on uh

776
00:40:59,760 --> 00:41:01,859
like the first layer uh based on the

777
00:41:01,859 --> 00:41:04,200
four bytes header then perform the the

778
00:41:04,200 --> 00:41:05,760
obfuscation there

779
00:41:05,760 --> 00:41:09,480
uh and then do the extraction from the

780
00:41:09,480 --> 00:41:11,820
for the second layer by writing another

781
00:41:11,820 --> 00:41:13,320
Handler

782
00:41:13,320 --> 00:41:15,720
um so any kind it's not only limited to

783
00:41:15,720 --> 00:41:18,119
like extraction if you have a vendor

784
00:41:18,119 --> 00:41:20,480
that performs some kind of weak

785
00:41:20,480 --> 00:41:22,920
encryption or if you can describe the

786
00:41:22,920 --> 00:41:25,560
key based on the firmware header or if

787
00:41:25,560 --> 00:41:28,260
the key is known you can also do it uh

788
00:41:28,260 --> 00:41:33,240
just uh but it's also based on the like

789
00:41:33,240 --> 00:41:35,280
you're making the assumption that you

790
00:41:35,280 --> 00:41:38,640
can identify that the binary blob is

791
00:41:38,640 --> 00:41:41,579
encrypted using this specific technique

792
00:41:41,579 --> 00:41:43,920
so you need the header to be in plain

793
00:41:43,920 --> 00:41:48,560
text another way is to specifically

794
00:41:48,560 --> 00:41:51,119
mention the Handler that you want to run

795
00:41:51,119 --> 00:41:54,180
if you precisely know that the blob you

796
00:41:54,180 --> 00:41:56,040
are trying to extract is encrypted with

797
00:41:56,040 --> 00:41:59,720
this this technique

798
00:42:02,940 --> 00:42:05,599
last question

799
00:42:10,140 --> 00:42:12,710
all right

800
00:42:12,710 --> 00:42:15,789
[Music]

801
00:42:29,220 --> 00:42:30,780
thank you

802
00:42:30,780 --> 00:42:33,420
um do you have experiences or plan to

803
00:42:33,420 --> 00:42:36,300
support weird and obscure encryption

804
00:42:36,300 --> 00:42:39,180
mechanism a compression algorithm that

805
00:42:39,180 --> 00:42:41,280
implemented by some vendors like

806
00:42:41,280 --> 00:42:43,440
hypothetically Siemens

807
00:42:43,440 --> 00:42:46,440
uh

808
00:42:47,400 --> 00:42:49,920
um we we did foursome I don't have um

809
00:42:49,920 --> 00:42:52,619
the exact examples in mind but yeah we

810
00:42:52,619 --> 00:42:57,480
so we have like 40 internal antlers uh

811
00:42:57,480 --> 00:43:00,540
and they are for

812
00:43:00,540 --> 00:43:01,579
um

813
00:43:01,579 --> 00:43:04,980
pyramidal image like you can think of

814
00:43:04,980 --> 00:43:07,800
Intel X or Motorola X records uh some

815
00:43:07,800 --> 00:43:10,200
custom compression streams implemented

816
00:43:10,200 --> 00:43:13,619
by vendors uh weird archives or file

817
00:43:13,619 --> 00:43:16,619
systems uh for example ecos from um yeah

818
00:43:16,619 --> 00:43:20,579
ecos from FS which is not traditional

819
00:43:20,579 --> 00:43:22,020
from FS is just a file system

820
00:43:22,020 --> 00:43:23,900
implementation on equals

821
00:43:23,900 --> 00:43:28,619
so we have some examples we will try to

822
00:43:28,619 --> 00:43:33,260
slowly open source them over time

823
00:43:35,490 --> 00:43:38,000
[Music]

824
00:43:38,000 --> 00:43:41,060
thank you

