1
00:00:08,960 --> 00:00:11,040
hi my name is yusra afer it's my

2
00:00:11,040 --> 00:00:12,960
pleasure to present our word android

3
00:00:12,960 --> 00:00:14,799
smart tv's vulnerability discovery

4
00:00:14,799 --> 00:00:16,560
vialog via lock guided fuzzin

5
00:00:16,560 --> 00:00:17,920
this is a joint work between the

6
00:00:17,920 --> 00:00:20,000
university of waterloo renmin university

7
00:00:20,000 --> 00:00:22,480
of china purdue university and uc

8
00:00:22,480 --> 00:00:24,720
riverside

9
00:00:24,720 --> 00:00:26,560
before diving into the details of our

10
00:00:26,560 --> 00:00:28,720
technique let me start by motivating our

11
00:00:28,720 --> 00:00:29,519
work

12
00:00:29,519 --> 00:00:32,159
why is smart tv security important

13
00:00:32,159 --> 00:00:34,079
well smart tvs are the most widely

14
00:00:34,079 --> 00:00:36,160
adopted home-based iot devices they

15
00:00:36,160 --> 00:00:38,640
account for the largest market share

16
00:00:38,640 --> 00:00:40,480
the great success of course does not

17
00:00:40,480 --> 00:00:43,360
come with no risks attackers can exploit

18
00:00:43,360 --> 00:00:45,680
physical channels as well as traditional

19
00:00:45,680 --> 00:00:47,120
cyber channels to achieve various

20
00:00:47,120 --> 00:00:48,239
damages

21
00:00:48,239 --> 00:00:50,640
which could be manifested in both cyber

22
00:00:50,640 --> 00:00:53,440
and physical harm

23
00:00:54,800 --> 00:00:56,879
to proactively address this attack model

24
00:00:56,879 --> 00:00:58,719
we perform in this study and evaluation

25
00:00:58,719 --> 00:01:00,879
of android smart tv security

26
00:01:00,879 --> 00:01:03,199
our evaluation particularly targets

27
00:01:03,199 --> 00:01:05,438
customization aspect that are performed

28
00:01:05,438 --> 00:01:08,080
by smart tv vendors

29
00:01:08,080 --> 00:01:09,840
to facilitate discussion i'll first

30
00:01:09,840 --> 00:01:12,640
cover a brief background android smart

31
00:01:12,640 --> 00:01:14,799
tvs typically run a heavily customized

32
00:01:14,799 --> 00:01:16,960
version of asb with additional hardware

33
00:01:16,960 --> 00:01:18,640
and system components

34
00:01:18,640 --> 00:01:20,720
the custom functionality is usually

35
00:01:20,720 --> 00:01:22,479
implemented by customizing android

36
00:01:22,479 --> 00:01:25,280
system services and the functionality is

37
00:01:25,280 --> 00:01:27,439
exposed to framework developers via

38
00:01:27,439 --> 00:01:30,000
dedicated apis

39
00:01:30,000 --> 00:01:32,240
the apis allow triggering and managing

40
00:01:32,240 --> 00:01:34,240
different smart tv functionalities

41
00:01:34,240 --> 00:01:36,000
including those related to physical

42
00:01:36,000 --> 00:01:39,119
aspect such as display and audio control

43
00:01:39,119 --> 00:01:42,320
as well as those related to

44
00:01:42,320 --> 00:01:44,000
cyber aspects such as remote control

45
00:01:44,000 --> 00:01:47,200
management and file management

46
00:01:47,200 --> 00:01:49,040
we note that these apis

47
00:01:49,040 --> 00:01:50,720
execute in the context of highly

48
00:01:50,720 --> 00:01:53,280
privileged processes so obviously any

49
00:01:53,280 --> 00:01:55,520
improper protection can be exploited to

50
00:01:55,520 --> 00:01:58,640
achieve various damages

51
00:01:59,040 --> 00:02:01,439
consider the following example xiaomi mi

52
00:02:01,439 --> 00:02:03,840
box introduces a new native api called

53
00:02:03,840 --> 00:02:06,479
the system control set position

54
00:02:06,479 --> 00:02:08,399
it allows to set up the display

55
00:02:08,399 --> 00:02:13,200
at a position x y with size wh

56
00:02:13,440 --> 00:02:15,120
we found that the api does not enforce

57
00:02:15,120 --> 00:02:17,280
any access control

58
00:02:17,280 --> 00:02:19,120
implying that any app can mess up the

59
00:02:19,120 --> 00:02:21,760
display under specific parameters

60
00:02:21,760 --> 00:02:23,440
for the figure on the right shows how

61
00:02:23,440 --> 00:02:25,360
the display is corrupt after invoking

62
00:02:25,360 --> 00:02:28,319
the api with the highlighted parameters

63
00:02:28,319 --> 00:02:31,680
in such scenario use users would resort

64
00:02:31,680 --> 00:02:33,360
to rebooting the device to fix the

65
00:02:33,360 --> 00:02:35,519
problem however it turns out that these

66
00:02:35,519 --> 00:02:38,080
parameters are persistent across reboots

67
00:02:38,080 --> 00:02:40,160
making it impossible to fix the problem

68
00:02:40,160 --> 00:02:43,120
without a hard reset

69
00:02:43,120 --> 00:02:45,200
with the smart tv ransomware already in

70
00:02:45,200 --> 00:02:47,599
the wild we envisioned that such apis

71
00:02:47,599 --> 00:02:49,440
could be exploited to mount the os

72
00:02:49,440 --> 00:02:51,840
attacks

73
00:02:52,640 --> 00:02:54,560
in this study we developed a specialized

74
00:02:54,560 --> 00:02:56,319
analysis framework to uncover such

75
00:02:56,319 --> 00:02:57,760
hidden flaws

76
00:02:57,760 --> 00:03:00,080
now adopting by code javabycostatic

77
00:03:00,080 --> 00:03:02,159
analysis may sound compelling for this

78
00:03:02,159 --> 00:03:04,480
purpose however it turned out that this

79
00:03:04,480 --> 00:03:06,800
is infeasible because vendor edition are

80
00:03:06,800 --> 00:03:09,200
implemented in c plus plus and or in

81
00:03:09,200 --> 00:03:10,239
java

82
00:03:10,239 --> 00:03:12,319
so dynamic analysis or testing is more

83
00:03:12,319 --> 00:03:13,680
applicable here

84
00:03:13,680 --> 00:03:16,319
but the direct adoption is challenging

85
00:03:16,319 --> 00:03:17,599
for example

86
00:03:17,599 --> 00:03:19,599
simply relying on the internal states of

87
00:03:19,599 --> 00:03:21,440
the system to assess

88
00:03:21,440 --> 00:03:23,680
a physical execution output might not be

89
00:03:23,680 --> 00:03:25,040
sufficient

90
00:03:25,040 --> 00:03:27,280
because the audio and visual behavior is

91
00:03:27,280 --> 00:03:31,560
decoupled from the internal state

92
00:03:32,080 --> 00:03:34,080
to address these limitations we propose

93
00:03:34,080 --> 00:03:36,080
a new fast testing approach

94
00:03:36,080 --> 00:03:37,760
our approach is composed of the four

95
00:03:37,760 --> 00:03:40,560
components a fuzzing target locator a

96
00:03:40,560 --> 00:03:43,200
dynamic fuzzer an input generator and a

97
00:03:43,200 --> 00:03:45,360
monitoring system

98
00:03:45,360 --> 00:03:47,760
given a target smart tv rom the fuzzy

99
00:03:47,760 --> 00:03:49,760
target locator would analyze the system

100
00:03:49,760 --> 00:03:52,319
services and identifies apis to be fed

101
00:03:52,319 --> 00:03:53,519
to the fuzzer

102
00:03:53,519 --> 00:03:55,680
we know that these apis include java

103
00:03:55,680 --> 00:03:58,959
apis as well as native apis

104
00:03:58,959 --> 00:04:00,560
then the dynamic fuzzer would generate

105
00:04:00,560 --> 00:04:02,879
test cases for each target api initially

106
00:04:02,879 --> 00:04:04,879
with random inputs

107
00:04:04,879 --> 00:04:06,720
our system features a novel input

108
00:04:06,720 --> 00:04:08,159
generation module

109
00:04:08,159 --> 00:04:10,400
to facilitate smart fuzzing

110
00:04:10,400 --> 00:04:12,640
specifically the input generator would

111
00:04:12,640 --> 00:04:14,799
leverage the dumped execution locks to

112
00:04:14,799 --> 00:04:17,839
spot potential input validation messages

113
00:04:17,839 --> 00:04:20,238
it then accordingly infers valid input

114
00:04:20,238 --> 00:04:22,079
specification and feeds it back to the

115
00:04:22,079 --> 00:04:23,919
dynamic fuzzer

116
00:04:23,919 --> 00:04:25,840
as such it could drive the fuzzer

117
00:04:25,840 --> 00:04:27,759
towards exploring code regions that are

118
00:04:27,759 --> 00:04:30,639
guarded by these validation messages

119
00:04:30,639 --> 00:04:32,960
this closed log-guided fuzzing loop is

120
00:04:32,960 --> 00:04:35,199
carried out until no newer inputs can be

121
00:04:35,199 --> 00:04:38,320
recovered from the logs

122
00:04:39,360 --> 00:04:41,600
the monitoring system would analyze the

123
00:04:41,600 --> 00:04:44,160
execution output to uncover potential

124
00:04:44,160 --> 00:04:45,520
vulnerabilities

125
00:04:45,520 --> 00:04:47,120
specifically to detect physical

126
00:04:47,120 --> 00:04:50,160
anomalies we redirect the execution hdmi

127
00:04:50,160 --> 00:04:53,280
output to the system via an hdmi capture

128
00:04:53,280 --> 00:04:54,479
device

129
00:04:54,479 --> 00:04:56,080
the monitor would capture and compare

130
00:04:56,080 --> 00:04:58,639
the display and the audio signals before

131
00:04:58,639 --> 00:05:00,560
and after each test case

132
00:05:00,560 --> 00:05:03,120
it then output alerts if discrepancies

133
00:05:03,120 --> 00:05:05,759
are detected

134
00:05:05,759 --> 00:05:07,759
now we will explain details about the

135
00:05:07,759 --> 00:05:11,840
fuzzing target locator

136
00:05:12,320 --> 00:05:14,720
this component recovers apis at the java

137
00:05:14,720 --> 00:05:16,720
or native layers here we dive into the

138
00:05:16,720 --> 00:05:19,120
details of how apis can be invoked via

139
00:05:19,120 --> 00:05:21,440
the binder ipc mechanism

140
00:05:21,440 --> 00:05:23,759
to implement a system service framework

141
00:05:23,759 --> 00:05:25,840
developers define its interface and as

142
00:05:25,840 --> 00:05:27,759
an adl description

143
00:05:27,759 --> 00:05:31,039
a client's app can invoke an api say

144
00:05:31,039 --> 00:05:33,600
method a by binder transactions

145
00:05:33,600 --> 00:05:35,360
specifically the client proxy would

146
00:05:35,360 --> 00:05:37,039
marshal the parameters and maps the

147
00:05:37,039 --> 00:05:39,600
method called to raw transaction id and

148
00:05:39,600 --> 00:05:41,680
initiates the transaction call

149
00:05:41,680 --> 00:05:43,440
this tab on the server side would

150
00:05:43,440 --> 00:05:45,520
unmarshal the data and call the actual

151
00:05:45,520 --> 00:05:47,199
server implementation

152
00:05:47,199 --> 00:05:50,400
it also marshals replies if any

153
00:05:50,400 --> 00:05:52,320
while the process of identifying java

154
00:05:52,320 --> 00:05:54,400
level apis is straightforward

155
00:05:54,400 --> 00:05:56,479
identifying native apis is more

156
00:05:56,479 --> 00:05:57,680
challenging

157
00:05:57,680 --> 00:05:59,199
because the binaries are largely

158
00:05:59,199 --> 00:06:00,240
stripped

159
00:06:00,240 --> 00:06:02,240
to solve the problem we perform a

160
00:06:02,240 --> 00:06:04,800
lightweight binary analysis specifically

161
00:06:04,800 --> 00:06:05,520
we

162
00:06:05,520 --> 00:06:08,160
recover the transaction ids the argument

163
00:06:08,160 --> 00:06:10,800
types and order from the native binaries

164
00:06:10,800 --> 00:06:12,560
essentially we're replicating the client

165
00:06:12,560 --> 00:06:14,880
proxy transactions to invoke the target

166
00:06:14,880 --> 00:06:17,280
api

167
00:06:17,840 --> 00:06:20,080
generating valid input specs via log

168
00:06:20,080 --> 00:06:21,840
analysis is challenging

169
00:06:21,840 --> 00:06:23,360
consider the following messages that

170
00:06:23,360 --> 00:06:26,720
were dumped while executing a target api

171
00:06:26,720 --> 00:06:29,120
the red messages indicate that the input

172
00:06:29,120 --> 00:06:31,520
is rejected because two argument values

173
00:06:31,520 --> 00:06:33,360
are larger than 16.

174
00:06:33,360 --> 00:06:35,520
such information is clearly valuable and

175
00:06:35,520 --> 00:06:37,360
can be used by the fuzzer to generate

176
00:06:37,360 --> 00:06:40,319
smarter inputs

177
00:06:40,560 --> 00:06:42,720
now these messages further depicts a few

178
00:06:42,720 --> 00:06:44,160
challenges

179
00:06:44,160 --> 00:06:46,160
first derive in messages that are

180
00:06:46,160 --> 00:06:49,280
uniquely triggered by a target execution

181
00:06:49,280 --> 00:06:50,720
is challenging

182
00:06:50,720 --> 00:06:51,759
because

183
00:06:51,759 --> 00:06:53,280
other messages are being dumped

184
00:06:53,280 --> 00:06:55,840
concurrently by other processes

185
00:06:55,840 --> 00:06:58,080
second the rejection does not correspond

186
00:06:58,080 --> 00:07:00,639
to a standard exception but rather it is

187
00:07:00,639 --> 00:07:02,720
in free text form

188
00:07:02,720 --> 00:07:04,800
we address these challenges through a

189
00:07:04,800 --> 00:07:07,039
synergy of different techniques

190
00:07:07,039 --> 00:07:09,120
we use a statistical methodology to

191
00:07:09,120 --> 00:07:11,280
identify target logs that are uniquely

192
00:07:11,280 --> 00:07:13,360
triggered by an api

193
00:07:13,360 --> 00:07:16,080
and to recognize input validations we

194
00:07:16,080 --> 00:07:18,639
devise a deep learning approach

195
00:07:18,639 --> 00:07:20,720
our proposed method leverages the

196
00:07:20,720 --> 00:07:22,479
observation that a large number of

197
00:07:22,479 --> 00:07:24,000
logging statements can be statically

198
00:07:24,000 --> 00:07:25,840
extracted from the bytecode of android

199
00:07:25,840 --> 00:07:26,720
roms

200
00:07:26,720 --> 00:07:28,800
through string and static taint analysis

201
00:07:28,800 --> 00:07:30,560
we can extract these messages and

202
00:07:30,560 --> 00:07:32,560
determine if they are input validation

203
00:07:32,560 --> 00:07:33,680
related

204
00:07:33,680 --> 00:07:35,360
we could then leverage that to check

205
00:07:35,360 --> 00:07:37,360
whether a message dumped by a native

206
00:07:37,360 --> 00:07:40,560
layer is input validation message

207
00:07:40,560 --> 00:07:43,039
specifically we start by analyzing the

208
00:07:43,039 --> 00:07:44,879
bytecode of a large corpus of android

209
00:07:44,879 --> 00:07:47,039
roms and look for java level input

210
00:07:47,039 --> 00:07:49,199
validation checks here we're showing two

211
00:07:49,199 --> 00:07:51,440
examples we then look for potential

212
00:07:51,440 --> 00:07:53,120
login statements that are guarded by

213
00:07:53,120 --> 00:07:54,240
these checks

214
00:07:54,240 --> 00:07:56,160
as we see here we can identify two

215
00:07:56,160 --> 00:07:59,520
instances of input validation messages

216
00:07:59,520 --> 00:08:02,160
and we can also identify an instance of

217
00:08:02,160 --> 00:08:04,800
a non-input validation message

218
00:08:04,800 --> 00:08:07,280
we accordingly label each method with

219
00:08:07,280 --> 00:08:10,559
its corresponding label

220
00:08:10,639 --> 00:08:12,319
we use these automatically labeled

221
00:08:12,319 --> 00:08:14,960
messages to train a set of classifiers

222
00:08:14,960 --> 00:08:16,639
which can be used to predict the class

223
00:08:16,639 --> 00:08:19,599
of a target lock message

224
00:08:19,599 --> 00:08:21,440
here we elaborate on how the dynamic

225
00:08:21,440 --> 00:08:23,199
fuzzer proceeds under the guidance of

226
00:08:23,199 --> 00:08:24,639
the log output

227
00:08:24,639 --> 00:08:26,800
we use the native api abc to walk you

228
00:08:26,800 --> 00:08:28,160
through the procedure

229
00:08:28,160 --> 00:08:31,199
as shown the api takes three arguments

230
00:08:31,199 --> 00:08:32,799
in the first phase in iteration the

231
00:08:32,799 --> 00:08:34,799
fuzzer starts without any input

232
00:08:34,799 --> 00:08:37,279
specification it invokes the api with

233
00:08:37,279 --> 00:08:39,039
random inputs

234
00:08:39,039 --> 00:08:40,958
the resulting log is analyzed to

235
00:08:40,958 --> 00:08:42,640
identify target logs which are

236
00:08:42,640 --> 00:08:44,399
highlighted in green here

237
00:08:44,399 --> 00:08:46,320
and then they are further analyzed to

238
00:08:46,320 --> 00:08:48,800
recognize input validation and potential

239
00:08:48,800 --> 00:08:50,240
specifications

240
00:08:50,240 --> 00:08:52,560
as we see here one input validation is

241
00:08:52,560 --> 00:08:55,600
identify reflecting a range check

242
00:08:55,600 --> 00:08:57,360
note here that we cannot infer to which

243
00:08:57,360 --> 00:08:59,920
parameter x refers to

244
00:08:59,920 --> 00:09:02,800
the fuzzer speculate that x is the first

245
00:09:02,800 --> 00:09:05,440
parameter so it does generate a value 10

246
00:09:05,440 --> 00:09:07,040
within this range

247
00:09:07,040 --> 00:09:08,800
without changing the second and third

248
00:09:08,800 --> 00:09:10,080
arguments

249
00:09:10,080 --> 00:09:13,120
the resulting log messages are further

250
00:09:13,120 --> 00:09:16,800
disclosing a new input validation here

251
00:09:16,800 --> 00:09:19,440
indicating a parameter equality check so

252
00:09:19,440 --> 00:09:21,760
x and y should be the same the fuzzer

253
00:09:21,760 --> 00:09:23,040
then concludes that the first

254
00:09:23,040 --> 00:09:24,959
speculation is correct

255
00:09:24,959 --> 00:09:27,040
x is the first parameter now it

256
00:09:27,040 --> 00:09:29,279
speculates that y refers to the second

257
00:09:29,279 --> 00:09:31,839
parameter so it sets it to be 10. the

258
00:09:31,839 --> 00:09:34,160
resulting log message did not yield to

259
00:09:34,160 --> 00:09:37,360
any input validation at this stage the

260
00:09:37,360 --> 00:09:40,720
fuzzer will start a random mutation

261
00:09:40,720 --> 00:09:42,399
now to detect potential anomaly is

262
00:09:42,399 --> 00:09:44,959
triggered by the by test case the fuzzer

263
00:09:44,959 --> 00:09:46,560
leverages two channels

264
00:09:46,560 --> 00:09:48,640
first it inspect the execution log to

265
00:09:48,640 --> 00:09:51,600
spot indications of cyber anomalies

266
00:09:51,600 --> 00:09:54,480
second it relies on the external

267
00:09:54,480 --> 00:09:57,440
monitor to capture physical changes

268
00:09:57,440 --> 00:10:00,080
specifically we launch a media player to

269
00:10:00,080 --> 00:10:02,640
play visual and audio content before and

270
00:10:02,640 --> 00:10:05,519
after detect each test execution

271
00:10:05,519 --> 00:10:07,680
and then we redirect the signals by an

272
00:10:07,680 --> 00:10:11,360
hdmi capture to the observer comparison

273
00:10:11,360 --> 00:10:13,680
the signals are compared using image and

274
00:10:13,680 --> 00:10:15,680
audio comparison algorithms and if there

275
00:10:15,680 --> 00:10:18,399
are any discrepancies alerts will be

276
00:10:18,399 --> 00:10:20,959
outputted

277
00:10:21,680 --> 00:10:23,839
we run our law guided fuzzing on 11

278
00:10:23,839 --> 00:10:27,200
android tv boxes we discovered 37 flows

279
00:10:27,200 --> 00:10:28,399
including

280
00:10:28,399 --> 00:10:30,640
11 cyber attacks 16 physical

281
00:10:30,640 --> 00:10:33,519
disturbances and 10 memory corruptions

282
00:10:33,519 --> 00:10:35,600
the table here shows the discovered

283
00:10:35,600 --> 00:10:36,959
cyber attacks

284
00:10:36,959 --> 00:10:39,040
the highlighted column report the apis

285
00:10:39,040 --> 00:10:41,120
that triggered at least one useful input

286
00:10:41,120 --> 00:10:43,279
validation which we have leveraged to

287
00:10:43,279 --> 00:10:46,480
discover the vulnerable path

288
00:10:46,480 --> 00:10:48,640
here we report the physical disturbances

289
00:10:48,640 --> 00:10:50,720
that were discovered by the fuzzer the

290
00:10:50,720 --> 00:10:52,800
fuzzer detected a wide range of visual

291
00:10:52,800 --> 00:10:54,880
and auditory anomalies allowing

292
00:10:54,880 --> 00:10:56,800
unprivileged applications to drop off

293
00:10:56,800 --> 00:10:59,760
the hdmi signals to blackout the display

294
00:10:59,760 --> 00:11:02,079
to rescale and to fully manipulate the

295
00:11:02,079 --> 00:11:03,440
color aspect

296
00:11:03,440 --> 00:11:05,120
others enables to control the audio

297
00:11:05,120 --> 00:11:06,480
signals as well

298
00:11:06,480 --> 00:11:08,560
these anomalies can be exploited to

299
00:11:08,560 --> 00:11:10,320
achieve various damages for example they

300
00:11:10,320 --> 00:11:13,200
can be used to put the smart tv into

301
00:11:13,200 --> 00:11:14,399
fake off mode

302
00:11:14,399 --> 00:11:16,640
and it can even be used to stiltly

303
00:11:16,640 --> 00:11:18,640
affect the viewer's health

304
00:11:18,640 --> 00:11:20,480
specifically the visuals held through

305
00:11:20,480 --> 00:11:24,160
manipulating color aspects

306
00:11:24,399 --> 00:11:26,399
this concludes my presentation thank you

307
00:11:26,399 --> 00:11:28,320
for your time i'm happy to take any

308
00:11:28,320 --> 00:11:31,320
questions

