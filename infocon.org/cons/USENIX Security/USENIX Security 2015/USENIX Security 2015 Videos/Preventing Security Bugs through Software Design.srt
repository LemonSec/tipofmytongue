1
00:00:10,580 --> 00:00:15,990
thanks for the introduction I mean I
guess what I'm going to talk about today

2
00:00:15,990 --> 00:00:20,410
this is joint work with a fairly large
number of people like a will there is a

3
00:00:20,410 --> 00:00:25,290
small team I work with to actually work
on these API's and improve them and do

4
00:00:25,290 --> 00:00:28,710
some of the refactorings to adjust
existing code to them and then there's

5
00:00:28,710 --> 00:00:32,710
actually a much larger group of people
in various teams we work with teams like

6
00:00:32,710 --> 00:00:36,730
Gmail and Google+ to actually apply
these at large scale and I want to thank

7
00:00:36,730 --> 00:00:40,790
all these people for being willing to
actually tries out and then showing that

8
00:00:40,790 --> 00:00:44,300
can be done and and making it successful
and then I'd also like to thank the

9
00:00:44,300 --> 00:00:50,709
invited talks committee for for inviting
me to speaker so thanks for that ok so

10
00:00:50,710 --> 00:00:56,260
as practitioners and I guess also at the
arrests in the field of software

11
00:00:56,260 --> 00:00:59,379
security I think we also share this and
that there's certain classes of bugs

12
00:00:59,379 --> 00:01:06,460
that just will not go away you know if
we look at some of these common classes

13
00:01:06,460 --> 00:01:09,289
I'm going to be talking about injection
bugs here today and in particular

14
00:01:09,290 --> 00:01:13,520
sequence accent russet scripting they
always feature at the very top of the

15
00:01:13,520 --> 00:01:19,810
top 10 or top 25 list and and have been
doing so for many years ever since they

16
00:01:19,810 --> 00:01:23,179
sort of came into existence and they're
really not things aren't getting any

17
00:01:23,179 --> 00:01:24,030
better

18
00:01:24,030 --> 00:01:28,939
incidentally also I'm quite happy that
this is almost album cover title yes I'm

19
00:01:28,939 --> 00:01:37,139
in light of the last night's room says
that in here naked ladies are anyway so

20
00:01:37,140 --> 00:01:43,060
why is this why are there so many bugs
there are some reasons that I can think

21
00:01:43,060 --> 00:01:47,899
of one is that we essentially rely on
developers the primary reason is we we

22
00:01:47,899 --> 00:01:51,649
put the burden on developers to avoid
these parts right we're asking them to

23
00:01:51,649 --> 00:01:56,359
write code on top of ATIS air inherently
prone to the entire introduction of

24
00:01:56,359 --> 00:02:00,699
these bugs and then we try to educate
the developers and teach them how to

25
00:02:00,700 --> 00:02:05,189
work around these sharp edges and those
FBI so to speak and that clearly doesn't

26
00:02:05,189 --> 00:02:08,449
seem to work some of the reasons I can
think of for that are that there's just

27
00:02:08,449 --> 00:02:12,470
a typically very large number of
opportunities in a large-scale

28
00:02:12,470 --> 00:02:16,170
application to introduce these books if
you look at exercise you literally find

29
00:02:16,170 --> 00:02:20,809
thousands or hundreds in a large-scale
application of both sides that could

30
00:02:20,810 --> 00:02:25,940
result in excessive there is a mistake
where things are being contaminated so

31
00:02:25,940 --> 00:02:30,109
you have lots of opportunities to make
these mistakes and people are human so

32
00:02:30,110 --> 00:02:33,070
in some of those cases they will
actually make the mistaken introduced

33
00:02:33,070 --> 00:02:39,530
about there's maybe also the aspect that
in light of these cases the primary

34
00:02:39,530 --> 00:02:43,310
focus of the developer has nothing
whatever to do with security right there

35
00:02:43,310 --> 00:02:48,620
focused on rendering some UI in a
browser or selecting tables from some

36
00:02:48,620 --> 00:02:53,060
rows from a database table and that's
not really a security related activities

37
00:02:53,060 --> 00:02:55,820
that may actually be less inclined to
think about that I'm not interested in

38
00:02:55,820 --> 00:03:00,310
talking to do this sort of security and
usability aspects I'm actually kind of

39
00:03:00,310 --> 00:03:04,360
interest in chatting about that later
because this is just my intuition I'm

40
00:03:04,360 --> 00:03:08,400
not really sure if this is really the
case sometimes it's just that these

41
00:03:08,400 --> 00:03:10,580
issues are quite sad all

42
00:03:10,580 --> 00:03:13,920
Perry are fundamentally exercise and CEO
injection aren't really difficult to

43
00:03:13,920 --> 00:03:17,390
understand I think if we give developer
training most of our developers actually

44
00:03:17,390 --> 00:03:20,829
get it right the they know what the
problem is but sometimes there are some

45
00:03:20,830 --> 00:03:25,790
cases for instance in excess there there
are some scenarios where

46
00:03:25,790 --> 00:03:29,900
the injection involves multiple embedded
some languages you might have a

47
00:03:29,900 --> 00:03:35,030
JavaScript string literal insider
JavaScript expression inside a event

48
00:03:35,030 --> 00:03:38,659
handler attribute inside HTML and then
what you need to do to escape that

49
00:03:38,659 --> 00:03:42,420
directly isn't actually all that obvious
and so you may have some mistakes from

50
00:03:42,420 --> 00:03:46,679
that angle as well as it is really
doesn't work right so we have lots of

51
00:03:46,680 --> 00:03:50,390
opportunities for bugs will end up with
bugs in the code base and this is pretty

52
00:03:50,390 --> 00:03:55,779
much I think our expertise experience so
we do then is we try to find these bugs

53
00:03:55,780 --> 00:04:02,019
before we ship the product we use
various dynamic and static techniques we

54
00:04:02,019 --> 00:04:07,430
use manual testing automated testing
static analysis human code reviews and

55
00:04:07,430 --> 00:04:11,669
we'll find some of those bugs but we
never will find all of these these

56
00:04:11,669 --> 00:04:16,228
methods are inherently incomplete and
will miss bugs and then we'll get back

57
00:04:16,228 --> 00:04:20,310
to production we made up my upper body
program which hopefully will report them

58
00:04:20,310 --> 00:04:24,139
to us responsibility but we basically
failed at a point right we ship the body

59
00:04:24,139 --> 00:04:30,620
and it's too late I think one reason
these methods for finding bugs are so

60
00:04:30,620 --> 00:04:34,110
incomplete is that in particular with
respect to these injection bugs very

61
00:04:34,110 --> 00:04:37,650
often the data for involved a really
really complicated and involved

62
00:04:37,650 --> 00:04:41,239
essentially right you have that makes it
through multiple systems across our PCs

63
00:04:41,240 --> 00:04:46,370
into persistent storage and back out and
then somewhere along that path there is

64
00:04:46,370 --> 00:04:50,060
a lack of escaping her sanitization and
then you have an injection bug and

65
00:04:50,060 --> 00:04:53,960
that's really difficult to reason about
all three humans and for automated

66
00:04:53,960 --> 00:04:57,599
systems and so I think that's one of the
reasons we have such a hard time finding

67
00:04:57,599 --> 00:05:03,010
these bugs after the fact and then you
know in result we kind of get low

68
00:05:03,010 --> 00:05:08,690
confidence as a security engineer I'm
being asked to assess an application for

69
00:05:08,690 --> 00:05:13,909
exercise or particular types of bugs
single injection other classifieds and I

70
00:05:13,909 --> 00:05:18,800
kind of look are using tools I find some
of them but really it would be a stretch

71
00:05:18,800 --> 00:05:22,199
to say I'm confident this large
application you know hundreds of

72
00:05:22,199 --> 00:05:24,610
thousands of lines of code is free of
that budget simply can't make that

73
00:05:24,610 --> 00:05:25,620
statement

74
00:05:25,620 --> 00:05:28,919
I can say I've looked for a couple of
days or a couple of weeks or whatever

75
00:05:28,919 --> 00:05:33,979
but but there's always the possibility
that there are more bucks so what can we

76
00:05:33,979 --> 00:05:37,590
do about this essentially what this
comes down to again is that we put the

77
00:05:37,590 --> 00:05:41,570
burden for avoiding these bugs on the
developer we have a few guys that

78
00:05:41,570 --> 00:05:45,919
fundamentally allowed code to be written
that has been abilities that that

79
00:05:45,919 --> 00:05:49,659
introduces vulnerabilities and we put
the burden on the developer to work

80
00:05:49,660 --> 00:05:53,340
around that essentially and so what I'm
proposing is to instead actually blame

81
00:05:53,340 --> 00:05:58,340
the API it's about API if it allows the
developer to write code and has a bug in

82
00:05:58,340 --> 00:06:01,340
particular if that bug is sort of
largely orthogonal to what they're

83
00:06:01,340 --> 00:06:04,570
really trying to do right it's a it's a
subtle consideration that's easily

84
00:06:04,570 --> 00:06:08,789
missed so the question of course can we
do this in practice right i mean it's

85
00:06:08,789 --> 00:06:12,849
easy to say but we basically have to
actually come up with a few guys that

86
00:06:12,850 --> 00:06:16,610
are both still usable and expressive
enough for the developers to write the

87
00:06:16,610 --> 00:06:20,830
code they're they're supposed to write
and ideally not actually make it much

88
00:06:20,830 --> 00:06:25,539
more cumbersome for them or or or
convoluted and at the same time also

89
00:06:25,539 --> 00:06:31,840
give us these properties we want the API
to be of a form of a design that makes

90
00:06:31,840 --> 00:06:36,020
it essentially impossible for the
developers to write code that has a

91
00:06:36,020 --> 00:06:38,930
particular class about and so that
that's an interesting questions I'm

92
00:06:38,930 --> 00:06:42,740
going to talk about to specific classes
of bugs I reflect on where I think we

93
00:06:42,740 --> 00:06:47,020
actually succeeded in doing us the first
one i wanna talk about a single

94
00:06:47,020 --> 00:06:52,250
injection fuel injection as we all know
arises if there is a query being sent to

95
00:06:52,250 --> 00:06:57,860
a database where some part of the career
is derived from an untrusted input and

96
00:06:57,860 --> 00:07:01,580
an attacker can essentially inject some
additional increase in tax cuts

97
00:07:01,580 --> 00:07:06,198
evaluated and then typically what
happens is that they subvert the

98
00:07:06,199 --> 00:07:10,630
simplicity intended access control
that's better

99
00:07:10,630 --> 00:07:14,979
interested in the semantics in this case
is a table of maybe albums if some

100
00:07:14,979 --> 00:07:19,430
employers are sharing application and
intended that the requested only ever

101
00:07:19,430 --> 00:07:23,479
select rows that are actually owned by
the album is owned by the currently

102
00:07:23,479 --> 00:07:27,159
logged in user but by doing that you
told one equals one thing or what it

103
00:07:27,160 --> 00:07:29,710
calls one thing the attacker can
basically it's like all the rows and so

104
00:07:29,710 --> 00:07:34,750
the injection takes place and it's
intended access policy

105
00:07:34,750 --> 00:07:40,140
what we tell developers to do to avoid
this there there's sort of a couple of

106
00:07:40,140 --> 00:07:44,180
common patterns that we ask developers
to do when we are due to stick to when

107
00:07:44,180 --> 00:07:47,790
we when we do our developer education
the most common one is prepared

108
00:07:47,790 --> 00:07:51,840
statements we tell people always use
prepared statements which basically

109
00:07:51,840 --> 00:07:55,919
addresses the issue if it was
consistently followed because in a

110
00:07:55,920 --> 00:08:00,380
prepared statement scenario the clearing
its parts first and then instead of

111
00:08:00,380 --> 00:08:06,300
parameters actual internal external
inputs being just donated into it

112
00:08:06,300 --> 00:08:09,750
their place all there is an end the
actual value of the parameter gets

113
00:08:09,750 --> 00:08:13,430
applied separately and so it cannot
possibly influenced the passing of the

114
00:08:13,430 --> 00:08:16,570
query and the structure of the Carrizo
there is no potential for injection

115
00:08:16,570 --> 00:08:20,430
unfortunately in practice is just a
guideline people are going to follow it

116
00:08:20,430 --> 00:08:23,350
right they might forget or they might
just think in my particular case it's

117
00:08:23,350 --> 00:08:27,260
going to be ok and I don't have to worry
about it as we basically still end up

118
00:08:27,260 --> 00:08:32,700
with code that is not inherently safe
there's potential bugs and sometimes

119
00:08:32,700 --> 00:08:35,930
there will be mistakes if we have
potential bugs will have some actual

120
00:08:35,929 --> 00:08:39,500
bugs the only thing that sort of
sometimes happens is that they stick to

121
00:08:39,500 --> 00:08:43,510
the guideline by the letter and it's a
the always use prepared statements but

122
00:08:43,510 --> 00:08:47,240
then they actually prepared statement
that already has been injected I don't

123
00:08:47,240 --> 00:08:53,810
see that very often but I have seen this
not the other thing we recommend is

124
00:08:53,810 --> 00:09:00,270
structural dreary builders so or
employers like hibernate and so on the

125
00:09:00,270 --> 00:09:05,350
they have problematic if you guys for
creating queries create a blog select

126
00:09:05,350 --> 00:09:10,130
object and the losses and so on and
that's also inherently resistant to a

127
00:09:10,130 --> 00:09:13,420
single injection but it's also
relatively cumbersome in comparison just

128
00:09:13,420 --> 00:09:17,199
contaminating strains and developers
really don't like it very much right so

129
00:09:17,200 --> 00:09:22,339
it works but it's not not exactly
popular so the question is can we come

130
00:09:22,339 --> 00:09:27,490
up with an API that has a property that
it's inherently resistant to injection

131
00:09:27,490 --> 00:09:33,020
but it's all so simple it's based on
essentially string concatenation of its

132
00:09:33,020 --> 00:09:39,900
so if we look at what we actually need
from the CPI in terms of a guarantee is

133
00:09:39,900 --> 00:09:45,360
that the decree that ends up being
executed has no data for dependency on

134
00:09:45,360 --> 00:09:45,640
external

135
00:09:45,640 --> 00:09:49,130
in part because the injection arises
from a dealer for dependency on

136
00:09:49,130 --> 00:09:53,240
interested in parts and so we can
prevent that from happening then there's

137
00:09:53,240 --> 00:09:58,370
no injection and this in turn turn this
condition around we can get by having an

138
00:09:58,370 --> 00:10:03,390
API that ensures that the query is a
concatenation of application control

139
00:10:03,390 --> 00:10:08,930
strings so trusted strings string
literals and Parkinson's Law Program our

140
00:10:08,930 --> 00:10:14,239
queries only composed of such values and
by definition it cannot be subject

141
00:10:14,240 --> 00:10:18,780
injection because it never has any
possibility for unprecedented influence

142
00:10:18,780 --> 00:10:26,140
degree in terms of the US so can we do
this well here's an example it's

143
00:10:26,140 --> 00:10:29,520
actually really trivial right we have a
filter that basically describes the

144
00:10:29,520 --> 00:10:35,160
string and we have independent method
that basically allows the programmer to

145
00:10:35,160 --> 00:10:39,120
add a snippet of the query and we
documents that you should only call this

146
00:10:39,120 --> 00:10:43,020
with compile time clinton expression so
you can call us with a string literal or

147
00:10:43,020 --> 00:10:47,069
you can call this with you know
decontamination of several things like

148
00:10:47,070 --> 00:10:53,920
that and then you know I this contract
by this constraint straightforwardly get

149
00:10:53,920 --> 00:10:58,089
the the invariant that the resulting
slurry is actually a concatenation of

150
00:10:58,090 --> 00:11:04,390
trusted strains of programs hansen's and
if the only carries that end up being

151
00:11:04,390 --> 00:11:08,520
sent to the database arteries produced
by this builder can no longer being so

152
00:11:08,520 --> 00:11:13,250
sensible unfortunately it developers
don't always read documentation in my

153
00:11:13,250 --> 00:11:17,530
experience if we just put this out it's
it's virtually guaranteed month within

154
00:11:17,530 --> 00:11:21,120
months within a few months will have
many many users that look like this

155
00:11:21,120 --> 00:11:27,210
where somebody basically didn't heed
their contract I mean lots of anecdotes

156
00:11:27,210 --> 00:11:31,030
in their dangers here it's guaranteed
right so what we did to prevent us

157
00:11:31,030 --> 00:11:34,610
because we really wanted to get to a
place where you just have to stop just

158
00:11:34,610 --> 00:11:37,910
stop looking for extra effort single
injection bugs in our code base is we

159
00:11:37,910 --> 00:11:42,959
actually rigorously enforce that
constraint that the API documents and

160
00:11:42,960 --> 00:11:47,329
its in its in its contract and what we
did to do that is we added a

161
00:11:47,329 --> 00:11:52,170
a very very simple checkered to our
compiler toolchain that simply enforces

162
00:11:52,170 --> 00:11:56,559
the check is built on top of the
airplane framework which is a framework

163
00:11:56,559 --> 00:12:01,309
for building static checks like this way
essentially Express credit cards on the

164
00:12:01,309 --> 00:12:06,290
type decorated asserts index tree in the
Java compiler and then you can turn this

165
00:12:06,290 --> 00:12:12,699
into a tinderbox findings errors and
this this this checker is is built into

166
00:12:12,699 --> 00:12:16,429
our standard tool chains are always runs
every time you compile Java program it's

167
00:12:16,429 --> 00:12:20,759
there and we've built a checar that
essentially enforces this constraint on

168
00:12:20,759 --> 00:12:26,980
parameters so now to try to compile is
you actually get compiler and so without

169
00:12:26,980 --> 00:12:32,519
now in place we really have a pretty
solid guarantee that you cannot write

170
00:12:32,519 --> 00:12:38,420
code against us builder that results in
a string that is injectable because the

171
00:12:38,420 --> 00:12:42,459
builder basically enforces invariant
that it's always a concatenation of

172
00:12:42,459 --> 00:12:48,518
string literals effectively so what does
it look like if we look at sort of code

173
00:12:48,519 --> 00:12:52,679
that would have been written ad hoc and
then what is the equivalent code look

174
00:12:52,679 --> 00:13:00,569
like using this filter is one example of
a piece of a piece of code that again is

175
00:13:00,569 --> 00:13:04,429
part of some photo sharing application
in here the intent of that statement is

176
00:13:04,429 --> 00:13:09,629
to select rows from the table of albums
that are shared with the current user

177
00:13:09,629 --> 00:13:14,259
and then optionally select a subset of
rows that correspond to albums that have

178
00:13:14,259 --> 00:13:17,649
a certain ratings of these albums have a
star rating from 1 to 5 or something

179
00:13:17,649 --> 00:13:23,249
like that this is a very common pattern
where you basically have code that

180
00:13:23,249 --> 00:13:29,589
instructs queries dynamically where
certain clauses of the only get used to

181
00:13:29,589 --> 00:13:34,110
the query if a particular corresponding
parameter is present in the external

182
00:13:34,110 --> 00:13:37,839
request so this is something that we
need to accommodate and isn't it

183
00:13:37,839 --> 00:13:41,899
incidentally is the reason why we do
actually allow control for dependencies

184
00:13:41,899 --> 00:13:46,079
on the query just that's a very calm
pattern we have to accommodate it so if

185
00:13:46,079 --> 00:13:49,489
you look at and this is actually also as
you can see

186
00:13:49,490 --> 00:13:54,510
subject so this has a single injection
vulnerabilities so if you look at what

187
00:13:54,510 --> 00:13:58,350
this code would look like using our
builder it basically looks exactly the

188
00:13:58,350 --> 00:14:03,010
same we're still contaminating the same
snippets of query strings except instead

189
00:14:03,010 --> 00:14:06,480
of a plane string music career builder
instead of class equals used to depend

190
00:14:06,480 --> 00:14:12,149
but it's it's essentially the same code
except of course now the deep end of

191
00:14:12,149 --> 00:14:20,930
this original snippet here present
wouldn't compile anymore because it's

192
00:14:20,930 --> 00:14:24,989
not a compile-time constant expression
as we get a compiler error and we have

193
00:14:24,990 --> 00:14:30,510
to change this code to essentially
comply with the best practice of always

194
00:14:30,510 --> 00:14:34,649
using bind parameters to supply all the
parameters to the query so essentially

195
00:14:34,649 --> 00:14:37,970
what I built it actually does enforce
this best practices effectively which is

196
00:14:37,970 --> 00:14:41,300
kind of what we want the only thing
we've done with this building so that

197
00:14:41,300 --> 00:14:44,120
when I showed you is like the really
really straightforward simple version

198
00:14:44,120 --> 00:14:48,430
that has just as an apparent method
that's the essence of it in practice to

199
00:14:48,430 --> 00:14:51,649
make it a little nicer to use and in
particular to make these kind of

200
00:14:51,649 --> 00:14:56,110
refactorings more practical we've added
some syntactic sugar to it in particular

201
00:14:56,110 --> 00:15:00,980
it has the facility to keep track of the
bind parameters as part of that rebuild

202
00:15:00,980 --> 00:15:07,410
itself which allows you to move the code
that attaches the actual value for a

203
00:15:07,410 --> 00:15:11,750
bind parameter right next to the code
that uses that bind parameter in a clear

204
00:15:11,750 --> 00:15:15,070
snow but and this is kind of Mexico Dr
will be nice and more readable in

205
00:15:15,070 --> 00:15:18,839
particular if you have several genes
involved at you call to make certain

206
00:15:18,839 --> 00:15:21,930
queries snippets and so it actually
turns out the developers with you like

207
00:15:21,930 --> 00:15:27,520
this so we actually made life easier on
top of making it more secure so I didn't

208
00:15:27,520 --> 00:15:31,100
turn out in practice we basically went
and implemented builders like this for

209
00:15:31,100 --> 00:15:37,459
the widely used sequel backends within a
single back and several widely used

210
00:15:37,459 --> 00:15:41,520
within Google in particular f1 in
Spanish which are too I guess planet

211
00:15:41,520 --> 00:15:50,459
scale transactional as a semi relational
transactional databases that we use and

212
00:15:50,459 --> 00:15:54,880
as well for hibernate which is more used
in smaller scale corporate applications

213
00:15:54,880 --> 00:15:59,370
so these API's they used to have when
they were launched the used to have the

214
00:15:59,370 --> 00:16:03,850
traditional method that consumes the
query as a plain string and then subject

215
00:16:03,850 --> 00:16:07,130
to injections were getting really
worried about having to deal with

216
00:16:07,130 --> 00:16:12,579
injections incidentally before these it
really wasn't possible to use sequel at

217
00:16:12,579 --> 00:16:16,180
scale at Google because it just doesn't
like my sequel doesn't scale that scales

218
00:16:16,180 --> 00:16:20,010
and nobody was using it essentially
everybody's using no sequel databases

219
00:16:20,010 --> 00:16:23,010
big table and so on and so we didn't
actually have to deal with a single

220
00:16:23,010 --> 00:16:26,870
injection as an issue very much but now
as these scalable data became available

221
00:16:26,870 --> 00:16:31,510
and it was a great concern and that's
why we introduce this builder there's

222
00:16:31,510 --> 00:16:34,150
also an example of a case where we
actually got on top of a vulnerability

223
00:16:34,150 --> 00:16:40,970
class before it ever happened which is
really nice and implemented and then we

224
00:16:40,970 --> 00:16:45,890
went around the existing code of all the
call sites into the methods that you

225
00:16:45,890 --> 00:16:49,130
know took the place of the query as a
plain string and we're affected them in

226
00:16:49,130 --> 00:16:54,570
a similar way to what I just told you to
use the safe filter this was somewhat

227
00:16:54,570 --> 00:16:58,709
epic refactoring I mean it was a couple
of person quarters effort from people in

228
00:16:58,709 --> 00:17:01,819
my team but in the big scheme of things
it's actually not such a big deal

229
00:17:01,820 --> 00:17:05,339
these types of large cover factoring
happen all the time ago that the people

230
00:17:05,339 --> 00:17:09,688
who curated the core API such as guava
which might be familiar with when they

231
00:17:09,689 --> 00:17:13,699
find a better way of expressing a
particular API they do similar effect

232
00:17:13,699 --> 00:17:17,809
earnings to adjust existing message to
the new API and then get rid of the old

233
00:17:17,809 --> 00:17:22,599
API and that's it's very common and much
much larger scale than what we did here

234
00:17:22,599 --> 00:17:26,399
so this might seem to have a big deal
but it really wasn't a relatively

235
00:17:26,400 --> 00:17:29,460
speaking and then we're done with that
reflected in with just removed the

236
00:17:29,460 --> 00:17:35,030
execute query method that took a string
together so it's gone so you can call it

237
00:17:35,030 --> 00:17:38,480
anymore now the only way to interact
with that if you I is through the safe

238
00:17:38,480 --> 00:17:42,820
shelter in Hibernate we could do this
because it's a third-party ATI witch

239
00:17:42,820 --> 00:17:46,230
hunters remove message from it and so
will be doing instead is at another

240
00:17:46,230 --> 00:17:50,290
custom error prone checker that really
just essentially constrains work all

241
00:17:50,290 --> 00:17:51,399
sides to these

242
00:17:51,400 --> 00:17:55,600
hibernate query method can occur and
their constrained to be within

243
00:17:55,600 --> 00:17:59,428
a robbery belies its peak which gives us
essentially the same effect in a bit

244
00:17:59,429 --> 00:18:02,799
more roundabout way and so with that
we're basically done worrying about

245
00:18:02,799 --> 00:18:07,160
single injection right you simply cannot
write code against these API against the

246
00:18:07,160 --> 00:18:12,700
CPI that is injectable because it will
not allow you to add any non constant

247
00:18:12,700 --> 00:18:17,490
string into the into the area so it it
simply not possible to write code that

248
00:18:17,490 --> 00:18:22,360
has injection which is really nice I
mean we're basically done worrying about

249
00:18:22,360 --> 00:18:24,178
this as a class of all abilities

250
00:18:24,179 --> 00:18:28,409
well sort of and there is one little
wrinkle so there's always exceptions

251
00:18:28,409 --> 00:18:33,580
there there is always going to be a few
use cases that cannot be expressed in

252
00:18:33,580 --> 00:18:37,360
terms of this ATT I saw one example
would be a command-line tool that's used

253
00:18:37,360 --> 00:18:41,260
by database administrators to send
arbitrary query

254
00:18:41,260 --> 00:18:46,020
increase of the database in that case
there is really an injection is not a

255
00:18:46,020 --> 00:18:51,289
concern because the principal who's
running the tool is the same as the

256
00:18:51,289 --> 00:18:54,730
principal thats authenticated to the
database and they have full authority to

257
00:18:54,730 --> 00:18:59,760
execute queries on whatever tables have
access to it right now he only had the

258
00:18:59,760 --> 00:19:06,240
API that is constrained to use to use to
build queries from clinton strings is

259
00:19:06,240 --> 00:19:09,669
really wouldn't work because here the
query comes from standard input and so

260
00:19:09,669 --> 00:19:15,169
to accommodate as we basically
interviews or kept a potentially unsafe

261
00:19:15,169 --> 00:19:18,520
I'm constrained IT guy which is really
just the old API that consumes a string

262
00:19:18,520 --> 00:19:22,580
but to make sure that developers don't
end up using it without thinking about

263
00:19:22,580 --> 00:19:27,820
it and without a strict need we actually
enforced

264
00:19:27,820 --> 00:19:33,299
whitelisted usage of that API and
reusing in our case a mechanism that's

265
00:19:33,299 --> 00:19:37,668
provided by our build system that allows
you to configure packages in the build

266
00:19:37,669 --> 00:19:41,700
system to have limited visibility to
other packages they basically enforce

267
00:19:41,700 --> 00:19:47,350
that only packages that we've reviewed
and that have a good reason to uses

268
00:19:47,350 --> 00:19:48,789
battery died so to speak

269
00:19:48,789 --> 00:19:53,390
actually get to use it for anybody else
if they try to build because they're not

270
00:19:53,390 --> 00:19:59,429
in the bill bill bill you is what's
important is that this backdoor API that

271
00:19:59,429 --> 00:20:03,140
way is really really needed in practice
we only needed it

272
00:20:03,140 --> 00:20:07,100
like one or two percent of the cost
sites and so doing the manual review and

273
00:20:07,100 --> 00:20:11,929
in particular doing manual generation of
new proposed uses of it is very very

274
00:20:11,930 --> 00:20:16,300
feasible and basically sort of get like
an email about this like every two weeks

275
00:20:16,300 --> 00:20:19,790
on average from you know all of Google's
it's very practical to do it this way

276
00:20:19,790 --> 00:20:27,000
right so let's move on to preventing
access which is a bit more difficult

277
00:20:27,000 --> 00:20:32,160
problem access fundamentally as a sort
of mention the beginning is is a much

278
00:20:32,160 --> 00:20:37,240
more complex these and there's much more
complexity in the different context in

279
00:20:37,240 --> 00:20:41,130
which injection can happen and what
needs to be done to prevent the

280
00:20:41,130 --> 00:20:47,920
injection vulnerability there's lots of
different variants of exercise I think

281
00:20:47,920 --> 00:20:55,160
two of the main reasons we see exercise
are due to calling pattern to a couple

282
00:20:55,160 --> 00:20:59,430
of voting patterns one is the sort of ad
hoc generation of HTML markup it's

283
00:20:59,430 --> 00:21:02,950
basically and written code that can
catch an eight string together to make

284
00:21:02,950 --> 00:21:04,280
to me

285
00:21:04,280 --> 00:21:08,080
HTML markup here's an example is
incidentally one that's a little bit

286
00:21:08,080 --> 00:21:12,730
more subtle was a real bug I forget what
application but basically the the just a

287
00:21:12,730 --> 00:21:16,970
bit here is that this variable category
is is externally controlled it's

288
00:21:16,970 --> 00:21:20,350
potentially attacker controlled and then
the intent of the program I was to

289
00:21:20,350 --> 00:21:25,120
render an anchor tag with an
undercounter that when press calls the

290
00:21:25,120 --> 00:21:30,060
Javascript method with the value of that
string category as an argument and then

291
00:21:30,060 --> 00:21:33,830
they basically want to feel that into
the innerHTML of this particular element

292
00:21:33,830 --> 00:21:39,000
and it looks like the actually knew
about excess because they the used

293
00:21:39,000 --> 00:21:41,860
escaping methods in fact they used the
correct ones right the used to correct

294
00:21:41,860 --> 00:21:45,679
standard library methods to do the
escaping in particular the use the right

295
00:21:45,680 --> 00:21:50,180
method to to the escaping for the strain
JavaScript string literal context and

296
00:21:50,180 --> 00:21:54,390
then the used also the right method
string it's another scape these methods

297
00:21:54,390 --> 00:21:59,570
in the closure library to do the
escaping for HTML context but there's

298
00:21:59,570 --> 00:22:07,460
still about just a show of hands who can
see what the bogus

299
00:22:07,460 --> 00:22:19,720
this is the director of the bag is that
the order of escaping operations are

300
00:22:19,720 --> 00:22:23,440
reversed they should have first
JavaScript string literal escaped and

301
00:22:23,440 --> 00:22:28,460
then escaped on top of that this is an
example of a more subtle consideration

302
00:22:28,460 --> 00:22:33,590
incidentally I think this might also be
a tricky case to catch for a static

303
00:22:33,590 --> 00:22:36,809
analysis tool am trying but if you
surprised if existing static analysis

304
00:22:36,809 --> 00:22:40,200
tools would be able to figure this out
its principle as possible in principle

305
00:22:40,200 --> 00:22:44,200
already have to basically keep track of
the context within the HTML markup is

306
00:22:44,200 --> 00:22:49,850
being created here but we preach
challenging so you know what we tell

307
00:22:49,850 --> 00:22:52,820
people is to not do this right in this
case probably the better pattern would

308
00:22:52,820 --> 00:22:58,189
have been to use the DOM API to create
this corresponding Dom or what we tell

309
00:22:58,190 --> 00:23:02,970
people to do is is just use templates
html template systems to created in the

310
00:23:02,970 --> 00:23:08,120
market up there is an example of a
little template in this case it renders

311
00:23:08,120 --> 00:23:13,500
a part of a profile page for social
network for instance or blogging

312
00:23:13,500 --> 00:23:19,380
application or something like that and
so will assume that this template system

313
00:23:19,380 --> 00:23:22,760
actually has a future that's pretty
widely available which is automatic

314
00:23:22,760 --> 00:23:25,690
escaping so there's a lot of template
systems that can be configured on may be

315
00:23:25,690 --> 00:23:31,679
in by default do this to automatically
HTML entity escape and code all the

316
00:23:31,679 --> 00:23:36,320
substitutions that go into the system so
let's assume this this temperature does

317
00:23:36,320 --> 00:23:41,450
this this is closure templates in taxes
as an example and so what this does is

318
00:23:41,450 --> 00:23:45,289
designed to escaping will actually
prevent excess due to the substitution

319
00:23:45,289 --> 00:23:50,890
of this profile name field because this
is regular as a body of an element

320
00:23:50,890 --> 00:23:56,870
context and so it's Jamel escaping is
sufficient to prevent XSS however with

321
00:23:56,870 --> 00:24:03,389
the with the bloody LLC little bit
different right because there's actually

322
00:24:03,390 --> 00:24:07,890
occurs in the context of NHS attribute
of an anchor tag and hence will be

323
00:24:07,890 --> 00:24:11,789
interpreted as a URL and if this is
completely unconstrained from external

324
00:24:11,789 --> 00:24:16,509
input which is reasonable to this is the
route to their own blog that

325
00:24:16,509 --> 00:24:21,059
user may be allowed to put in here so
they can link to their own blog from

326
00:24:21,059 --> 00:24:26,599
their profile page in our social network
if this is not valid anywhere then it

327
00:24:26,599 --> 00:24:30,329
might actually be set by a malicious
user to JavaScript colon

328
00:24:30,329 --> 00:24:35,089
expression and then if another user fees
and click on it to get access right so

329
00:24:35,089 --> 00:24:41,599
what's missing here is basically a
template directive filter that first

330
00:24:41,599 --> 00:24:48,269
sanitizes this value as a nine URL like
a well-formed HTTPS URL and would reject

331
00:24:48,269 --> 00:24:52,309
JavaScript and other URLs and then his
two most kids it right so in this case

332
00:24:52,309 --> 00:24:58,119
we have a Nexus S because the developer
forgot to introduce a context-specific

333
00:24:58,119 --> 00:25:02,109
standardization and that's possible even
if the default

334
00:25:02,109 --> 00:25:06,978
skipping is in place the other kid
that's tricky about this template of the

335
00:25:06,979 --> 00:25:10,549
by this particular example is that we
have a block here where the developers

336
00:25:10,549 --> 00:25:15,259
intent is actually to render HTML markup
without escaping through the use case

337
00:25:15,259 --> 00:25:19,549
here is that we allow our end users to
enter a little blurb about themselves

338
00:25:19,549 --> 00:25:24,908
and we give them an HTML editor so they
can add to can use of funds and both

339
00:25:24,909 --> 00:25:26,489
face that kind of stuff you know

340
00:25:26,489 --> 00:25:31,839
pictures of cats or whatever they want
but its intent is that it's inert HTML

341
00:25:31,839 --> 00:25:35,458
that will not cause script execution and
therefore is actually safe to render

342
00:25:35,459 --> 00:25:41,299
here and so to do this the developer
used a directive to disable the

343
00:25:41,299 --> 00:25:45,289
automatic escaping for this particular
substitution now we looked at this in

344
00:25:45,289 --> 00:25:50,919
the bigger picture and we consider that
this application is not given to one of

345
00:25:50,919 --> 00:25:57,359
our security engineers to do a cordon
sanitaire and you get this gets as cold

346
00:25:57,359 --> 00:26:01,168
and so this is a slice of the order a
petition and so what you have to do is

347
00:26:01,169 --> 00:26:07,779
basically find all the things that are
prone to process scripting injections

348
00:26:07,779 --> 00:26:12,879
such as Simon's in Times I called and
server-side code that renders its

349
00:26:12,879 --> 00:26:17,728
responses and so on and then back trace
the data flow into those thinks and

350
00:26:17,729 --> 00:26:21,609
figure out if they are as appropriate
escaping of everything that goes into it

351
00:26:21,609 --> 00:26:27,009
in this case she knows that this render
as a template and then assigns the

352
00:26:27,009 --> 00:26:28,760
result of rendering the template

353
00:26:28,760 --> 00:26:34,870
to the innerHTML property here and then
the next step would be to be to look at

354
00:26:34,870 --> 00:26:40,419
the template and issued notice that
there is an auto escape directive on

355
00:26:40,420 --> 00:26:45,170
this about it you know what that means
that now the the flow of the value into

356
00:26:45,170 --> 00:26:50,500
this field is irrelevant at this this is
now required to be outraged email that

357
00:26:50,500 --> 00:26:54,890
is in art and will not result in third
party control script execution so you

358
00:26:54,890 --> 00:26:58,750
should go back and basically it
backwards Dre Studio flow this comes

359
00:26:58,750 --> 00:27:04,000
from an RPC from a web front end and
then there's another RPC from

360
00:27:04,000 --> 00:27:08,050
application back and which now reaches
from a process or and so far there

361
00:27:08,050 --> 00:27:11,649
hasn't been any kind of sanitization
along this flow so now we're kind of in

362
00:27:11,650 --> 00:27:14,950
a bit of a trouble because we have to
now find all the different applications

363
00:27:14,950 --> 00:27:18,040
that might be writing to this record
store might even be something owned by

364
00:27:18,040 --> 00:27:23,879
different team we have to validate and
assert or as a chain that all the front

365
00:27:23,880 --> 00:27:26,470
ends of which there might be different
ones right there might be a weapon and

366
00:27:26,470 --> 00:27:31,450
my t-mobile front-end developer facing
API that they all do proper sanitization

367
00:27:31,450 --> 00:27:36,590
of the valuables in their creepy quickly
we're down like deep into the weeds and

368
00:27:36,590 --> 00:27:41,179
this is just one assignment in a
large-scale applications they'll be many

369
00:27:41,180 --> 00:27:45,440
of these and so really doing a
comprehensive review of this type of

370
00:27:45,440 --> 00:27:48,860
thing is is very very challenging and
very time-consuming and error-prone we

371
00:27:48,860 --> 00:27:54,370
might get some help from static analysis
tools and optimistic I have tried to use

372
00:27:54,370 --> 00:27:57,969
them but in this type of scenario I mean
we're reprising three languages to

373
00:27:57,970 --> 00:28:02,050
different IPC mechanisms and the data
flow goes to a persistent storage and

374
00:28:02,050 --> 00:28:05,360
this is just really really hard for a
static analysis system to reason about

375
00:28:05,360 --> 00:28:09,780
right and I tried it really doesn't work
so this is this is bad right so what do

376
00:28:09,780 --> 00:28:15,340
we do about this so their first thing we
did is we introduce what we call a

377
00:28:15,340 --> 00:28:20,959
strictly context we are escaping
template systems this is a mouthful but

378
00:28:20,960 --> 00:28:26,200
when it comes down to is essentially an
extension to context sensitive are

379
00:28:26,200 --> 00:28:31,170
escaping which is something that we've
developed over the years and there's

380
00:28:31,170 --> 00:28:35,410
there's one context where this was
actually published by my colleague Mike

381
00:28:35,410 --> 00:28:35,940
Samuels

382
00:28:35,940 --> 00:28:41,230
and projects action out I think Berkeley
at the time and essentially ideas that

383
00:28:41,230 --> 00:28:45,230
the template system actually understands
the HTML markup and it inspires the

384
00:28:45,230 --> 00:28:49,059
context within the rendered HTML of
which substitution takes place

385
00:28:49,059 --> 00:28:53,158
workouts that for instance substitution
is taking place within the address

386
00:28:53,159 --> 00:28:57,259
attribute on an anchor element and then
it knows that this is going to be a URL

387
00:28:57,259 --> 00:29:01,360
enhance it needs to be sanitized as a
URL and then HTML escape in order to

388
00:29:01,360 --> 00:29:06,490
avoid exercise and so this helps a lot
because it basically by default does the

389
00:29:06,490 --> 00:29:10,139
right thing right the developer if they
don't add any escaping directives as

390
00:29:10,139 --> 00:29:13,699
well pretty much guarantee that
everything is correctly escape for the

391
00:29:13,700 --> 00:29:17,850
context that it appears in unfortunately
in practice there are still a lot of

392
00:29:17,850 --> 00:29:22,269
bugs even if we use contextual er
escaping template systems due to reasons

393
00:29:22,269 --> 00:29:27,889
like this about HTML example that had
right we have we have legitimate cases

394
00:29:27,889 --> 00:29:30,840
and sometimes cases where the developer
thinks it's legitimate but it just sort

395
00:29:30,840 --> 00:29:34,428
of had the wrong reasoning about it
where they disabled or modify the

396
00:29:34,429 --> 00:29:38,919
automatically inferred template escaping
and then if they make a mistake in doing

397
00:29:38,919 --> 00:29:39,519
that

398
00:29:39,519 --> 00:29:45,610
introduced across its so what we've done
is we've essentially strengthens the

399
00:29:45,610 --> 00:29:50,969
constraints that the template system and
imposes and we basically just said we

400
00:29:50,970 --> 00:29:56,049
had a strict mode that completely this
allows the use of escaping modifiers

401
00:29:56,049 --> 00:29:59,840
within the temple system so now you're
no longer allowed to use in autos gave

402
00:29:59,840 --> 00:30:05,320
or at any manual escaping directives in
the template and we've also made this

403
00:30:05,320 --> 00:30:09,769
recursive so strict template can only
call another script template and so that

404
00:30:09,769 --> 00:30:13,730
taken together we essentially sort of
get the guarantee that a strict

405
00:30:13,730 --> 00:30:17,559
templates gives rise to a function from
template parameters to a string that

406
00:30:17,559 --> 00:30:21,789
it's a mark-up that's guaranteed by
construction do not result in excess

407
00:30:21,789 --> 00:30:22,980
when rendered

408
00:30:22,980 --> 00:30:27,919
essentially taken the templates out of
the equation as far as a source for

409
00:30:27,919 --> 00:30:33,559
cross-site scripting vulnerabilities is
concerned that we look at this again in

410
00:30:33,559 --> 00:30:37,980
this example where the remake the
template strict basically looks the same

411
00:30:37,980 --> 00:30:44,309
except there's no escaping directives
escaping soldier modifiers allowed those

412
00:30:44,309 --> 00:30:46,399
are inferred by the template engine

413
00:30:46,400 --> 00:30:49,680
and sort of implicitly inserted I did it
it does the right thing it works out

414
00:30:49,680 --> 00:30:55,280
that profile name just needs to be HTML
escaped and the blog URL because it

415
00:30:55,280 --> 00:30:59,580
appears in the URL context is to be
sanitized as you're out and then escaped

416
00:30:59,580 --> 00:31:04,090
because it's also an attributes and so
everything is is is safe now

417
00:31:04,090 --> 00:31:09,490
unfortunately is now also broken the
future of rendering legitimate markup in

418
00:31:09,490 --> 00:31:12,800
this about HTML box right because the
template system hasn't heard that there

419
00:31:12,800 --> 00:31:16,220
should be a journalist caped and not
allowed to turn it off because it's a

420
00:31:16,220 --> 00:31:21,910
strict template so what do we do about
this recently introduced types that

421
00:31:21,910 --> 00:31:27,980
designate data that is safe to use in a
particular context implementation wise

422
00:31:27,980 --> 00:31:31,340
these are just really trivial of rappers
for a string the type is really just

423
00:31:31,340 --> 00:31:37,240
dare to attach a security contractor
directly to the value and we have types

424
00:31:37,240 --> 00:31:41,120
that correspond to other contexts that
are relevant in HTML so we friends and

425
00:31:41,120 --> 00:31:46,850
have safe HTML as a type that's
basically promises that its value it

426
00:31:46,850 --> 00:31:51,689
rendered its string value it rendered as
HTML in its context will not cause

427
00:31:51,690 --> 00:31:55,490
script execution or malicious script
execution externally controlled

428
00:31:55,490 --> 00:32:01,040
execution similar force if you're out if
you put it in context and the restaurant

429
00:32:01,040 --> 00:32:06,399
is it nothing bad will happen and so on
the idea of using these types like it

430
00:32:06,400 --> 00:32:13,490
goes back to some work we didn't talk at
sort of around 2 2009 I think we we now

431
00:32:13,490 --> 00:32:18,530
have sort of generalized us and and
created instance our implementations of

432
00:32:18,530 --> 00:32:22,889
these types there in a general-purpose
library but it's basically the same idea

433
00:32:22,890 --> 00:32:28,660
for a program to create instances of
these types we had a couple of options

434
00:32:28,660 --> 00:32:34,320
when his we have libraries of builders
and producers for these types for values

435
00:32:34,320 --> 00:32:38,830
of these types that themselves uphold
the type contract by construction so

436
00:32:38,830 --> 00:32:43,600
they themselves expose an interface that
is inherently safe with respect to

437
00:32:43,600 --> 00:32:47,209
guarantee in the type contract so we
don't actually have to review any of the

438
00:32:47,210 --> 00:32:50,980
code that uses these builders their
structural builders it sort of give you

439
00:32:50,980 --> 00:32:54,370
kind of a DOM API like interface leak
rate

440
00:32:54,370 --> 00:33:00,110
element and attribute to it and the
implementation of the builder will

441
00:33:00,110 --> 00:33:04,889
ensure that things get escaped intended
highs appropriately you can also create

442
00:33:04,890 --> 00:33:09,150
instances of these HTML tied by
rendering a strip steak template because

443
00:33:09,150 --> 00:33:13,250
they're strict template system back
construction support that i contract and

444
00:33:13,250 --> 00:33:20,420
so are the result of rendering a strict
template essentially satisfies contract

445
00:33:20,420 --> 00:33:25,620
and we can give you the result as a type
of the only have unchecked conversions

446
00:33:25,620 --> 00:33:29,969
which are basically and safe potentially
unsafe pass from stranger those types of

447
00:33:29,970 --> 00:33:35,850
those are there in this model to
accommodate these exceptional use cases

448
00:33:35,850 --> 00:33:39,129
right so we might have for instance a
situation where somebody wants to render

449
00:33:39,130 --> 00:33:44,570
a URL that is your out for an Android
intent and that's like a really weird

450
00:33:44,570 --> 00:33:48,230
format so we don't have support for
sanitizing it in the standard template

451
00:33:48,230 --> 00:33:52,380
system implementation and on that case
they can use a custom builder for this

452
00:33:52,380 --> 00:33:57,210
type of your offer and intend or else
and then that builder will wrap the

453
00:33:57,210 --> 00:33:59,710
result of what it does

454
00:33:59,710 --> 00:34:04,260
as that type all uses of these versions
of course need to be security review

455
00:34:04,260 --> 00:34:08,520
because they are basically security
critical ran into the conversion has to

456
00:34:08,520 --> 00:34:12,080
satisfy the type contract that we
require and to make sure that that

457
00:34:12,080 --> 00:34:16,179
happens we can use this build visibility
mechanism to ensure that only people who

458
00:34:16,179 --> 00:34:18,070
talk to us and we've got a review

459
00:34:18,070 --> 00:34:23,470
can actually use them helps us to keep a
lid on inappropriate use of those under

460
00:34:23,469 --> 00:34:30,399
conversions do is to disallow the use of
injection problems things directly an

461
00:34:30,399 --> 00:34:34,399
application code we basically banned the
use of interest in El Simons in

462
00:34:34,399 --> 00:34:38,750
application-level JavaScript code you're
only allowed to use it in white list of

463
00:34:38,750 --> 00:34:44,000
places such as inside the runtime for
the template system and inside rapper

464
00:34:44,000 --> 00:34:50,830
said take a seat belt I for instance and
rapid and then we basically clean up all

465
00:34:50,830 --> 00:34:55,500
the application level code from these
potentially injection prone things and

466
00:34:55,500 --> 00:34:59,500
the again enforcement for that is very
simple static check just basically

467
00:34:59,500 --> 00:35:00,950
whitelisting call sites

468
00:35:00,950 --> 00:35:08,000
what is look like if you put it all
together now this slice of the

469
00:35:08,000 --> 00:35:12,599
application you'll see that in the
JavaScript code down here we used to

470
00:35:12,599 --> 00:35:16,030
have an interesting assignment we now
just directly call into the runtime of

471
00:35:16,030 --> 00:35:19,720
the template system to render a strict
template and render Instructables always

472
00:35:19,720 --> 00:35:26,140
say something our contributors really
have to look at the because the template

473
00:35:26,140 --> 00:35:28,040
strict is no more and no escape

474
00:35:28,040 --> 00:35:34,310
instead what we did is change the
declaration of this process structures

475
00:35:34,310 --> 00:35:38,390
that this field about HTML is not all
types if HTML instead of typing in

476
00:35:38,390 --> 00:35:42,618
strength and comfort system recognizes
those types and will then suppress

477
00:35:42,619 --> 00:35:47,230
automatically inferred escaping so this
this behaves as intended from a

478
00:35:47,230 --> 00:35:52,589
functional perspective this field so
traces through the whole system as a

479
00:35:52,589 --> 00:35:56,220
types of this structure basically makes
its way with this field of that type

480
00:35:56,220 --> 00:36:00,470
across all these are between IPC
mechanisms and we have implementations

481
00:36:00,470 --> 00:36:05,299
of these types in other languages and we
have IPC mechanisms that have a way of

482
00:36:05,300 --> 00:36:08,560
serializing those types and then
somewhere down here in the back end

483
00:36:08,560 --> 00:36:13,880
we're now in the situation where the
code reads the value of these fields

484
00:36:13,880 --> 00:36:17,290
from the proper storage comes up as a
plain string but we actually what we

485
00:36:17,290 --> 00:36:23,460
need to to set this profile fields about
feel about HTML field in the profile

486
00:36:23,460 --> 00:36:27,950
structure is of type stated we have type
mismatch and we just try to compile it

487
00:36:27,950 --> 00:36:32,310
would get a compiler so we need to
basically take the strain string about

488
00:36:32,310 --> 00:36:37,060
which we cannot make any assumptions and
turning to save it ml and what we do for

489
00:36:37,060 --> 00:36:41,310
that is we call out to a library that
sanitized HTML markup what it really

490
00:36:41,310 --> 00:36:47,569
does is just parsing HTML markup and
potentially reduce it down to an inert

491
00:36:47,569 --> 00:36:51,550
safe subset of HTML that will not cause
any script execution and then it gives

492
00:36:51,550 --> 00:36:54,609
you back the result of doing that as

493
00:36:54,609 --> 00:37:01,538
as it uses one of those conversions to
do that now if this goes back to our

494
00:37:01,539 --> 00:37:07,420
you're the only thing look at now is is
the fountain of this engine conversion

495
00:37:07,420 --> 00:37:10,980
because that's really the only security
sensitive code nine other stuff out

496
00:37:10,980 --> 00:37:15,599
there is something we kind of Trust Rlty
system reasonably is relevant right we

497
00:37:15,599 --> 00:37:18,319
don't have to read the templates because
they always safe and we don't have to

498
00:37:18,319 --> 00:37:22,599
read the code that transports these
values in the form of that type around

499
00:37:22,599 --> 00:37:27,430
the system so they really only security
code is eaten into those places where we

500
00:37:27,430 --> 00:37:30,890
actually make instance of this type and
incidentally this is actually shared

501
00:37:30,890 --> 00:37:33,950
libraries it's already been reviewed and
the first review is straightforward

502
00:37:33,950 --> 00:37:39,038
because we can apply local reasoning
within that module its HTML sanitizer

503
00:37:39,039 --> 00:37:42,400
that anyway security sensitive in fact
it's cold that's been around for 10

504
00:37:42,400 --> 00:37:46,859
years from the early days of gmail so
we've already refuted probably five

505
00:37:46,859 --> 00:37:50,470
times and we have high confidence ahead
and we really doing is just take the

506
00:37:50,470 --> 00:37:55,058
output of that and turn it into an email
and we we basically know that out of the

507
00:37:55,059 --> 00:37:59,440
sanitizer always satisfied that a
contract so this is like a very easy

508
00:37:59,440 --> 00:38:02,279
thing to reason about right and
particularly don't have to look at any

509
00:38:02,279 --> 00:38:07,499
of the application told it's really
local to that module to look at how this

510
00:38:07,499 --> 00:38:11,459
turned out in practice we basically
implemented strict context to escaping

511
00:38:11,460 --> 00:38:16,059
modes in closer templates and and other
widely used template systems a go and

512
00:38:16,059 --> 00:38:19,249
then we had a couple of flagship
applications adopt this approach in

513
00:38:19,249 --> 00:38:23,299
particular Gmail and Google+ where some
of the early adopters and we'd seen

514
00:38:23,299 --> 00:38:29,930
drastic reduction in bugs in particular
Google+ had something like thirty XSS

515
00:38:29,930 --> 00:38:34,200
vulnerabilities in the bug tracker in
the year 2011 there's maybe a little bit

516
00:38:34,200 --> 00:38:37,230
high for that size of application they
were under very rapid development at the

517
00:38:37,230 --> 00:38:42,749
time but still it's you know it's a it's
a sizable number of bugs and then once

518
00:38:42,749 --> 00:38:46,549
adopted this approach and refactored all
the code used templates and get rid of

519
00:38:46,549 --> 00:38:48,549
all the time and so on

520
00:38:48,549 --> 00:38:53,609
they really have had no application
level access in September 2013 so this

521
00:38:53,609 --> 00:38:57,619
this is really a very nice result
there's little star there's a little bit

522
00:38:57,619 --> 00:38:58,779
fine print

523
00:38:58,779 --> 00:38:59,540
get to him

524
00:38:59,540 --> 00:39:03,750
in a second and then there's more to it
so if you want to read up on this there

525
00:39:03,750 --> 00:39:11,310
is an article in communications of the
ACM in September 2012 the fine print

526
00:39:11,310 --> 00:39:15,680
right there is there something some
limitations 1 I've kind of already

527
00:39:15,680 --> 00:39:21,100
touched on is essentially rely on the
type system to uphold the integrity of

528
00:39:21,100 --> 00:39:25,970
those types as it around the system and
in the real world languages that we use

529
00:39:25,970 --> 00:39:30,080
type systems are not exactly watertight
right so we have reflection in Java we

530
00:39:30,080 --> 00:39:34,819
have casts we have sort of convention
based visibility enforcement in dynamic

531
00:39:34,820 --> 00:39:39,020
languages and in principle it's possible
for a program to write code that uses

532
00:39:39,020 --> 00:39:43,560
reflection that pokes inches into the
implementation of the safety multiband

533
00:39:43,560 --> 00:39:47,190
just a sign whatever they want to it and
violate the type contract so we could

534
00:39:47,190 --> 00:39:51,470
have bugs that way but you know we kind
of assume our developers are reasonable

535
00:39:51,470 --> 00:39:57,220
in particular threat model we actually
assumed that the developers not militias

536
00:39:57,220 --> 00:40:00,790
just human and prone to making mistakes
right so we're not trying to catch

537
00:40:00,790 --> 00:40:06,800
actually evil people there's other
mechanisms that the thing that is sort

538
00:40:06,800 --> 00:40:10,660
of a big factor there i think is the
idiomatic using the language it's

539
00:40:10,660 --> 00:40:15,470
basically a complete no-no in in our
environment least to use reflection in

540
00:40:15,470 --> 00:40:18,879
application level Java code you would
never get this passed a code review this

541
00:40:18,880 --> 00:40:22,520
is just the thing you don't do it
belongs you know it deep down into the

542
00:40:22,520 --> 00:40:26,150
guts of a web app framework or something
like that in other languages like Ruby

543
00:40:26,150 --> 00:40:29,700
for instance I think it's more for par
for the course to use make sense to

544
00:40:29,700 --> 00:40:33,069
crack open a type and then add behavior
to it and so in that case it might be

545
00:40:33,070 --> 00:40:38,690
more difficult to reason about the
integrity of the type but in in Java I'm

546
00:40:38,690 --> 00:40:41,010
not really too worried about this

547
00:40:41,010 --> 00:40:46,220
more fundamentally there are no formal
guarantees and no formal underpinnings

548
00:40:46,220 --> 00:40:51,339
for this approach in particular the
safest of all types have no formal

549
00:40:51,340 --> 00:40:54,970
specification for that how contract the
type contract is sort of their beliefs

550
00:40:54,970 --> 00:40:56,689
specified is kind of safe

551
00:40:56,690 --> 00:41:00,930
preferential rights basically the
definition of excess of the safest and

552
00:41:00,930 --> 00:41:05,440
I'll type is that it's a string that
will not cause exercise when rendered as

553
00:41:05,440 --> 00:41:10,940
HTML and this is so I come from way back
from her former background from a formal

554
00:41:10,940 --> 00:41:14,790
methods background for this kind of
angles me a little bit and would be nice

555
00:41:14,790 --> 00:41:19,029
to have a more formal approach to
defining these types which would allow

556
00:41:19,030 --> 00:41:23,480
us to make more rigorous arguments that
for instance our sanitizers now attempt

557
00:41:23,480 --> 00:41:29,650
assistant actually hold that a contract
in practice I'm not yet too much worried

558
00:41:29,650 --> 00:41:34,030
about it because I mean right now the
problem is essentially that the these

559
00:41:34,030 --> 00:41:38,870
properties adherence to the type
contract is established entirely on you

560
00:41:38,870 --> 00:41:43,609
know that ho chi minh reasoning if you
will but the one thing that is important

561
00:41:43,610 --> 00:41:49,370
to note is that the the reasoning is is
local it's it's module local right it's

562
00:41:49,370 --> 00:41:52,839
just reasoning about the template system
in isolation its reasoning about the

563
00:41:52,840 --> 00:41:56,820
sanitizer and isolation we don't have to
do this reasoning about the entire

564
00:41:56,820 --> 00:42:02,360
program which is what really mixes in
the Free State intractable and then the

565
00:42:02,360 --> 00:42:05,270
other observation is that impact is
really the bodies are not there at the

566
00:42:05,270 --> 00:42:08,460
bugs are an application code people used
the wrong escaping forget to use

567
00:42:08,460 --> 00:42:11,360
escaping and that's where the bugs come
from

568
00:42:11,360 --> 00:42:18,430
Indies in in what is now so I guess the
trust the core of this this this

569
00:42:18,430 --> 00:42:24,759
framework are really really rare right i
mean sanitizer was discovered for

570
00:42:24,760 --> 00:42:27,720
instance so in practice I'm not too
worried about it but in principle it

571
00:42:27,720 --> 00:42:34,819
does something we can talk about after
I'm done to see what the sort of more

572
00:42:34,820 --> 00:42:40,470
academic review things about this aspect
then there's also some I guess

573
00:42:40,470 --> 00:42:46,560
pathological uses so in the case for
instance the builder her basically makes

574
00:42:46,560 --> 00:42:52,070
a guarantee that the resulting query has
no data for dependency on interested in

575
00:42:52,070 --> 00:42:53,600
what we do allow control

576
00:42:53,600 --> 00:42:57,339
codependency which is something we have
to allow for practical reasons now turns

577
00:42:57,340 --> 00:43:02,410
out that of course a control for
dependency essentially implies an

578
00:43:02,410 --> 00:43:05,870
effective data flow dependency right
like somebody could write code that just

579
00:43:05,870 --> 00:43:09,240
iterate character by character over the
input and then producers and

580
00:43:09,240 --> 00:43:12,450
coordination of trust it strange that
exactly equal to the input and then they

581
00:43:12,450 --> 00:43:19,850
basically turned into a nominally
trusted and untrusted value again this

582
00:43:19,850 --> 00:43:22,500
is something that I'm not too worried
about because this would sort of border

583
00:43:22,500 --> 00:43:30,190
on the militias and we probably have a
stern talking to them right i mean in

584
00:43:30,190 --> 00:43:36,930
practice I hope this wouldn't happen
when it happens it hasn't yet but again

585
00:43:36,930 --> 00:43:41,230
this is kind of a limitation of the form
of guarantees that we can make with

586
00:43:41,230 --> 00:43:48,800
these approaches are summarized in talk
a little bit about some of the against

587
00:43:48,800 --> 00:43:52,860
sort of key insights and lessons that we
learned as we did this and some of the

588
00:43:52,860 --> 00:43:56,760
aspects of this approach that were
crucial to making it work

589
00:43:56,760 --> 00:44:02,490
the first observation is that it's
actually ok to change code so if I look

590
00:44:02,490 --> 00:44:05,720
at the related work in the literature
there does seem to be a lot of work

591
00:44:05,720 --> 00:44:09,279
where there is an implicit assumption
that you just have to take the program

592
00:44:09,280 --> 00:44:13,830
as it is even if it's like global b2b
spaghetti code to somehow make that work

593
00:44:13,830 --> 00:44:18,130
and and give guarantees in that in that
model right and so then you end up with

594
00:44:18,130 --> 00:44:20,320
very complicated approaches using

595
00:44:20,320 --> 00:44:26,570
dynamic flow analysis done at 10
tracking and data analysis and so on in

596
00:44:26,570 --> 00:44:30,880
this case we basically we're ok actually
to change a little bit how programmers

597
00:44:30,880 --> 00:44:34,950
write told her ok to do the global
refactoring to adjust our cold days to

598
00:44:34,950 --> 00:44:38,850
the new API once if it's reasonable we
changing little bit not too much right

599
00:44:38,850 --> 00:44:42,470
so for instance in the in a single case
we're really still allowing the

600
00:44:42,470 --> 00:44:46,980
programmer to do string concatenation
just requiring them to express it a

601
00:44:46,980 --> 00:44:49,930
little bit differently from what they
did before they basically have to use .

602
00:44:49,930 --> 00:44:55,129
opinions but otherwise it's really still
the same thing but just making that

603
00:44:55,130 --> 00:44:58,840
little change allowed us to get the
guarantee that we want and in particular

604
00:44:58,840 --> 00:45:03,380
allowed us to have a very very simple
implementation of that guarantee I mean

605
00:45:03,380 --> 00:45:07,810
that the core that is really almost
embarrassingly simple right it's it's

606
00:45:07,810 --> 00:45:11,970
like what I saw on that slide and the
checkers like together maybe sixty lines

607
00:45:11,970 --> 00:45:15,220
of actual code + boilerplate right and
that's that's that's not all

608
00:45:15,220 --> 00:45:18,759
implementations we end up with a very
very simple approach that gives us the

609
00:45:18,760 --> 00:45:25,310
guarantee and in return we have to do
some work to adjust existing code to

610
00:45:25,310 --> 00:45:29,340
that project we have to ask developers
must change their ways a little bit but

611
00:45:29,340 --> 00:45:34,180
not too much and I think that's a really
valuable thing to keep in mind with

612
00:45:34,180 --> 00:45:45,419
these types of projects I think the the
kind of fundamental inside this whole

613
00:45:45,420 --> 00:45:50,920
approach is that we we essentially
require from our guys in the

614
00:45:50,920 --> 00:45:55,990
implementations to not make any
assumptions about values of basic data

615
00:45:55,990 --> 00:46:00,890
types in particular strengths writes a
few consumers strength in API you have

616
00:46:00,890 --> 00:46:04,490
to assume that it might be potentially
attacker controlled you're not allowed

617
00:46:04,490 --> 00:46:07,509
to assume anything about it which in
practice means you have to do whatever

618
00:46:07,510 --> 00:46:12,880
the appropriate runtime validation or
escaping is within the implementation of

619
00:46:12,880 --> 00:46:17,870
this might seem like it actually creates
a lot of extra work and application but

620
00:46:17,870 --> 00:46:21,420
it really doesn't write because the
escaping for instance has to happen

621
00:46:21,420 --> 00:46:25,720
somewhere along as long data flow and so
you might as well just happen in the

622
00:46:25,720 --> 00:46:30,390
place actually matters and so we
basically essentially hoisted

623
00:46:30,390 --> 00:46:34,308
all the escaping operations into the
implementation of the API and we've

624
00:46:34,309 --> 00:46:39,329
relieve all the rest of the code from
even worrying about it so I think that's

625
00:46:39,329 --> 00:46:46,619
a that's a really crucial concept I
think now there are cases where I just

626
00:46:46,619 --> 00:46:51,079
has a semantic reasons to make
assumptions about some of it in spurts

627
00:46:51,079 --> 00:46:56,230
for instance if we're trying to render
some blob of HTML that we have to assume

628
00:46:56,230 --> 00:46:57,109
is safe

629
00:46:57,109 --> 00:46:59,990
we basically can't escape it because
otherwise it wouldn't do what you want

630
00:46:59,990 --> 00:47:04,009
to do and in those cases against taking
to the rule that we can't make

631
00:47:04,010 --> 00:47:09,930
assumptions about plain string value
it's played string type values within

632
00:47:09,930 --> 00:47:14,750
structure our API so that the client is
required to essentially prove to us that

633
00:47:14,750 --> 00:47:18,170
the values actually safe to use and our
preferred way of doing that is to use

634
00:47:18,170 --> 00:47:24,329
types we just use language native types
to energy these values effectively would

635
00:47:24,329 --> 00:47:28,769
use type annotations for instance you
double check a framework might have

636
00:47:28,769 --> 00:47:32,490
worked quite nicely we chose types for
practical reasons because it simpler and

637
00:47:32,490 --> 00:47:36,729
all the ideas knows about know about
them and it was less Cottam you know

638
00:47:36,730 --> 00:47:41,839
worry about maintained but there might
be occasions where using annotations is

639
00:47:41,839 --> 00:47:46,990
using native types I think it's a
relatively small mistakes and then there

640
00:47:46,990 --> 00:47:53,419
are cases where we can actually express
an epi constraint constraint on correct

641
00:47:53,420 --> 00:47:58,170
use of an API using the type system
using tanks at near signatures and so

642
00:47:58,170 --> 00:48:02,759
instead in in that case in those cases
we resort to typically very simple

643
00:48:02,759 --> 00:48:08,309
static checks keeping those checks
simple i think is extremely valuable and

644
00:48:08,309 --> 00:48:11,880
light weights because it allows us to
actually run them in the context of the

645
00:48:11,880 --> 00:48:15,299
existing to change so they can run on
every compiled because they're really

646
00:48:15,299 --> 00:48:20,589
cheap we don't run down after the fact
in like you know later on

647
00:48:20,589 --> 00:48:25,529
unit testing cycle whatever they just
run right when the going gets compiled

648
00:48:25,529 --> 00:48:30,069
and so if we if we find a violation of
these checks we can basically make it a

649
00:48:30,069 --> 00:48:33,369
hard compiler error in the code never
even gets checked in because it never

650
00:48:33,369 --> 00:48:35,620
even compile since I think that's that's
really

651
00:48:35,620 --> 00:48:43,080
another way to look at this is so
injection bugs are fundamentally

652
00:48:43,080 --> 00:48:47,480
attended a double problem right there is
entrusted input that stained it at some

653
00:48:47,480 --> 00:48:50,430
of those with the system gets combined
with other values and then makes it to

654
00:48:50,430 --> 00:48:55,129
us think that interprets in a way that
subject to injection and I think there

655
00:48:55,130 --> 00:49:00,510
is a natural inclination to actually use
tape tracking approaches to to attack

656
00:49:00,510 --> 00:49:05,180
this problem and I think sort of from
what I've learned in doing this this

657
00:49:05,180 --> 00:49:10,270
doesn't work that well and the intuition
behind that is that if you if you if you

658
00:49:10,270 --> 00:49:14,350
look at a typical transactional
application what it does is manipulate

659
00:49:14,350 --> 00:49:18,779
user data if it didn't it would probably
be doing anything very interesting and

660
00:49:18,780 --> 00:49:23,130
so what that means is that actually most
of the variables that the program

661
00:49:23,130 --> 00:49:27,180
manipulates are tainted right there all
painted everything is tainted and so now

662
00:49:27,180 --> 00:49:32,379
you have all these values that year you
have to keep track of their intended

663
00:49:32,380 --> 00:49:35,390
mess after they've been sanitized and on
top of that you have these really

664
00:49:35,390 --> 00:49:40,230
complicated long data flows so applying
tracking both static and dynamic to this

665
00:49:40,230 --> 00:49:43,810
problem is actually really really hard
right and so what we've done instead is

666
00:49:43,810 --> 00:49:47,180
essentially turned the problem upside
down we just said everything by default

667
00:49:47,180 --> 00:49:50,490
is soon to be changed it and the
implementation of the FBI has to deal

668
00:49:50,490 --> 00:49:51,359
with that

669
00:49:51,360 --> 00:49:56,790
by either runtime escaping or is it
can't in those cases then it has to use

670
00:49:56,790 --> 00:50:00,910
something that tracks the safeties and
in this case we just use types so used

671
00:50:00,910 --> 00:50:04,960
to annotate values that are known to be
safe and then we also get the benefit

672
00:50:04,960 --> 00:50:08,710
that the type system basically does the
whole program reasoning for us and it's

673
00:50:08,710 --> 00:50:13,850
very good at that I mean that's the type
checkers of my favorite static analyzer

674
00:50:13,850 --> 00:50:17,819
right it's always there and works and
it's great yeah so this is really I

675
00:50:17,820 --> 00:50:20,950
think another good way to put this is
like you

676
00:50:20,950 --> 00:50:27,379
worried about the safety and you assume
anything else is is is one important

677
00:50:27,380 --> 00:50:30,680
thing is this actually works in practice
because most of the values are tainted

678
00:50:30,680 --> 00:50:35,910
and it's very very uncommon to have the
need to annotate values are safe

679
00:50:35,910 --> 00:50:42,339
the use of this HTML type is really
relatively rare just because in practice

680
00:50:42,339 --> 00:50:47,130
most strings program manipulates are
really just plain tax-writing somebody's

681
00:50:47,130 --> 00:50:51,190
name or it's just plain text where
there's no market and they're typically

682
00:50:51,190 --> 00:50:55,180
it's very uncommon and so this is what
makes its practical otherwise we'd have

683
00:50:55,180 --> 00:50:59,368
to have we have too much work where we
have to basically use those types to

684
00:50:59,369 --> 00:51:04,570
annotate to annotate safety but in
practice it happens really is so it's

685
00:51:04,570 --> 00:51:11,359
not an issue we did is we basically
tried to design Epistar really simple

686
00:51:11,359 --> 00:51:16,250
and relatively similar to what the
program is used to be doing and we made

687
00:51:16,250 --> 00:51:22,660
them safe but the simplicity is is is
pretty essential I think and we try to

688
00:51:22,660 --> 00:51:27,540
do it in a way such that the very vast
majority of use cases in real programs

689
00:51:27,540 --> 00:51:31,440
can be satisfied by the CBI industries
out to be the case I mean this is not

690
00:51:31,440 --> 00:51:34,349
obvious but in hindsight it actually
worked and I think it's crucial to make

691
00:51:34,349 --> 00:51:41,800
it work because to satisfy the sort of
unusual cases we have this potentially

692
00:51:41,800 --> 00:51:47,740
unsafe and all the use of that we have
to manually only practical if it's

693
00:51:47,740 --> 00:51:52,750
really needed and then as it turns out
it is so it takes a very small team of

694
00:51:52,750 --> 00:51:56,599
people to kind of pureed the use of this
API and make sure that all its users are

695
00:51:56,599 --> 00:52:00,569
actually reviewed incidentally so this
one aspect I've been thinking about you

696
00:52:00,569 --> 00:52:04,390
know whether or not this approach might
transfer outside of an organization like

697
00:52:04,390 --> 00:52:09,770
Google into the open source world and
this is one area where I'm not sure how

698
00:52:09,770 --> 00:52:15,170
to do that because it potentially relies
on having somebody in charge of curating

699
00:52:15,170 --> 00:52:18,690
the use of these potentially unsafe
CBI's it's just open these up in my

700
00:52:18,690 --> 00:52:22,190
experience they end up being overused
and then you basically back to square

701
00:52:22,190 --> 00:52:25,579
one that you have some experience with
us earlier work we didn't go back to get

702
00:52:25,579 --> 00:52:29,369
we basically had one of these in check
conversion from string to this Google

703
00:52:29,369 --> 00:52:31,980
Web Toolkit equivalent of the city
genotype

704
00:52:31,980 --> 00:52:35,920
and we didn't have any kind of
restriction lines use and over the years

705
00:52:35,920 --> 00:52:40,150
we ended up with like something like a
thousand words most of which were

706
00:52:40,150 --> 00:52:45,800
completely unnecessary and actually
introduced plugs right so basically this

707
00:52:45,800 --> 00:52:50,280
didn't help and we had to go back and do
some refactoring to lock down the user

708
00:52:50,280 --> 00:52:53,480
list so there's this approach really
only works if somebody who knows about

709
00:52:53,480 --> 00:53:00,619
security security team or as security
minded engineer on a project team keeps

710
00:53:00,619 --> 00:53:08,640
a lid on the use of these days the only
numbers I think really valuable for us

711
00:53:08,640 --> 00:53:14,400
to be able to build on existing tooling
so these things I mentioned error prone

712
00:53:14,400 --> 00:53:19,290
JavaScript informants were controlling
called sites in in JavaScript code and

713
00:53:19,290 --> 00:53:22,320
the build visibility mechanism in the
bill system those were all there and

714
00:53:22,320 --> 00:53:26,410
they were built by our language and
platforms team in support of general

715
00:53:26,410 --> 00:53:33,819
code quality desires essentially right
and we were able to tag along with ease

716
00:53:33,820 --> 00:53:40,240
and effectively configure them for our
purposes which helped because we need to

717
00:53:40,240 --> 00:53:43,290
write a whole bunch of old for this kind
of tooling and I think it also helps a

718
00:53:43,290 --> 00:53:46,430
little bit with adoption because
developers are used to these tools are

719
00:53:46,430 --> 00:53:51,109
used to getting compilation errors from
them and so if they just get another

720
00:53:51,109 --> 00:53:54,890
compilation error that happens to be
security-related they already know what

721
00:53:54,890 --> 00:53:57,950
to do with it right it's it's a
compiling program is know how to deal

722
00:53:57,950 --> 00:54:02,180
with it it's not some very specific tool
that comes in after the fact and

723
00:54:02,180 --> 00:54:05,419
complains saddam about something
security-related and then they're like

724
00:54:05,420 --> 00:54:10,350
what are these security people giving us
a hassle about right so I think this has

725
00:54:10,350 --> 00:54:16,080
a lot to do with making it so this recap
the benefits I think the most important

726
00:54:16,080 --> 00:54:20,529
thing is as a as a as I said before is
that potentially vulnerable code just

727
00:54:20,530 --> 00:54:26,510
never even compile it never gets checked
in and so we we end up in a state where

728
00:54:26,510 --> 00:54:34,600
there is no potential vulnerability it
it really what the to have a potential

729
00:54:34,600 --> 00:54:41,390
vulnerability lies a misuse of the API
that we can at compile time per hit so

730
00:54:41,390 --> 00:54:44,450
this is very different from the current
stage where there's lots of code that is

731
00:54:44,450 --> 00:54:45,100
potentially

732
00:54:45,100 --> 00:54:50,160
like this long data flow of this about
it you feel that there should be in the

733
00:54:50,160 --> 00:54:55,299
original state of that slice of the
program and now I have to reason about

734
00:54:55,300 --> 00:55:00,410
it and I get warnings from static
analysis system and have to debate with

735
00:55:00,410 --> 00:55:03,779
a programmer pretty please refer to this
so it's a little bit more obviously

736
00:55:03,780 --> 00:55:07,160
correct but then they'll go well I
really have time and unless you show me

737
00:55:07,160 --> 00:55:11,879
an actual blog I won't do it raised in
this model we visit me turn around that

738
00:55:11,880 --> 00:55:15,110
they just cannot write the code that has
even potential bugs I think that's

739
00:55:15,110 --> 00:55:19,350
really really valuable and of course I
mean this very drastic but again we've

740
00:55:19,350 --> 00:55:23,589
done this in a way where we really don't
make their lives significantly harder I

741
00:55:23,590 --> 00:55:27,370
don't forget to use the same template
system and very arguably we've made our

742
00:55:27,370 --> 00:55:30,440
lives easier because they never have to
worry about escaping the only time they

743
00:55:30,440 --> 00:55:34,780
have to do something special is if they
if they won the template system do not

744
00:55:34,780 --> 00:55:39,250
apply the default escaping and then they
have to use those types but that's

745
00:55:39,250 --> 00:55:44,890
that's pretty reasonable because it
happens very infrequently so the

746
00:55:44,890 --> 00:55:50,100
property of this whole approach is that
it it confines need potential for bugs

747
00:55:50,100 --> 00:55:54,779
into a very small part of the code base
if there's an exercise in an application

748
00:55:54,780 --> 00:55:59,710
that uses approach it basically has to
be within the template system or within

749
00:55:59,710 --> 00:56:05,610
the sanitizer within the implementation
of those types it can be an application

750
00:56:05,610 --> 00:56:09,380
called right and so this is really
powerful right because it of course

751
00:56:09,380 --> 00:56:14,150
drastically reduces the potential for
bugs because now the whole application

752
00:56:14,150 --> 00:56:20,710
code is basically no longer no longer
contributes to the potential for bugs

753
00:56:20,710 --> 00:56:24,460
and then also result in drastic
reduction in the actual bugs that we

754
00:56:24,460 --> 00:56:28,550
also have far fewer potential bugs we
obviously have to your actual bugs in

755
00:56:28,550 --> 00:56:32,920
our sort of anecdotal stats I guess from
their projects we've applied the store

756
00:56:32,920 --> 00:56:38,660
in sort of before and after a state
actually bears out the fire there is

757
00:56:38,660 --> 00:56:43,920
also that the review burden for security
engineer needs to make an assessment of

758
00:56:43,920 --> 00:56:46,940
this application is drastically reduced
because they don't really have to read

759
00:56:46,940 --> 00:56:50,580
most of the application code anymore
they only have to read

760
00:56:50,580 --> 00:56:55,110
easily identified security sensitive
piece of code which other fan into these

761
00:56:55,110 --> 00:56:59,550
conversions in most cases they might
actually be in common libraries and have

762
00:56:59,550 --> 00:57:04,150
already been reviewed in the past so it
reduces their work and it makes actually

763
00:57:04,150 --> 00:57:09,190
practical for them to read all the code
is security security relevant right in

764
00:57:09,190 --> 00:57:12,520
the current state basically talking
about hundreds of thousands of lines of

765
00:57:12,520 --> 00:57:15,759
code is really not practical to analyze
it in depth and and really reason about

766
00:57:15,760 --> 00:57:18,790
it whereas now we're in a state where
the code you need to look at is really

767
00:57:18,790 --> 00:57:25,310
relatively small and easily identified
as a way that we also get significantly

768
00:57:25,310 --> 00:57:28,799
increased confidence in the correctness
as I said there's no formal guarantees

769
00:57:28,800 --> 00:57:33,430
but as a Security Auditor as a cold or
you can make a much stronger statement

770
00:57:33,430 --> 00:57:37,790
about code it's organized like this as
opposed to code that is in the ad hoc

771
00:57:37,790 --> 00:57:44,050
way as it was before and so just to
summarize important takeaway is that

772
00:57:44,050 --> 00:57:48,540
this is it's it's all about API design
ready was no fancy static analysis or 10

773
00:57:48,540 --> 00:57:52,570
tracking or anything like this we
basically just go ahead and taken

774
00:57:52,570 --> 00:57:58,470
security as an emergent property of the
design of the application and applied

775
00:57:58,470 --> 00:58:03,899
that as a primary driver to the design
of these API's API design of course the

776
00:58:03,900 --> 00:58:09,540
big topic and I think there is in in
most cases the desire is to make the API

777
00:58:09,540 --> 00:58:14,990
design an API that started reduces the
possibility for bugs rights over there

778
00:58:14,990 --> 00:58:19,959
is the principle of least surprise for
instance we don't want an API that has a

779
00:58:19,960 --> 00:58:25,020
method that sounds like from its name
that it'll be very quick and very small

780
00:58:25,020 --> 00:58:27,290
amount of work and then that thing all
of a sudden actually in the

781
00:58:27,290 --> 00:58:30,460
implementations and upgrades and makes
our PCs and my blog for a long time

782
00:58:30,460 --> 00:58:34,290
that's a surprise to the program which
in this case result in a performance

783
00:58:34,290 --> 00:58:40,330
issue right and so in the same thing we
have a few guys that surprised a

784
00:58:40,330 --> 00:58:47,140
programmer by allowing the introduction
of security bugs and now security bugs

785
00:58:47,140 --> 00:58:51,690
are in many ways different from regular
bugs there in many ways more or bad

786
00:58:51,690 --> 00:58:55,360
right because we for instance can not
choose to fix them they're more urgent

787
00:58:55,360 --> 00:58:57,999
to fix their more expensive in general
the more damaging

788
00:58:57,999 --> 00:59:02,529
and so in this case we've actually been
able to serve elevate this principle of

789
00:59:02,529 --> 00:59:05,529
least surprised and they get principle
of no surprise that we've actually made

790
00:59:05,529 --> 00:59:09,499
the API we change the FBI into a state
where you really cannot write code

791
00:59:09,499 --> 00:59:15,698
anymore that has the price of bugs and
so that's all I have to say thanks for

792
00:59:15,699 --> 00:59:25,720
listening on time so any questions

793
00:59:25,720 --> 01:00:04,810
come to mind because program too much
choice

794
01:00:04,810 --> 01:00:20,810
responsible for supplying

795
01:00:20,810 --> 01:00:33,470
training and in return and that's all it
does and it doesn't give you any choices

796
01:00:33,470 --> 01:00:36,339
so that's that's another area we've
worked on that we're thinking about

797
01:00:36,339 --> 01:00:41,680
there is there some other areas that are
more tenuous one year after talking

798
01:00:41,680 --> 01:00:45,819
about his authorization are there ways
to structure code so that it becomes

799
01:00:45,820 --> 01:00:51,400
easier to reason about the domain
specific authorization code that's part

800
01:00:51,400 --> 01:00:52,820
of the codebase

801
01:00:52,820 --> 01:00:56,410
not things that could be provided by
like a lower storage layer but rather

802
01:00:56,410 --> 01:01:01,399
domain-specific code in the application
that has to do with authorization and

803
01:01:01,400 --> 01:01:05,440
typically if you don't do anything about
this this kind of code tends to spread

804
01:01:05,440 --> 01:01:10,400
out all over the code base and then it
becomes very difficult for a reason

805
01:01:10,400 --> 01:01:11,740
about

806
01:01:11,740 --> 01:01:15,109
emergent properties from all the
combination of these pieces of code that

807
01:01:15,110 --> 01:01:19,910
are already thinking about whether or
not we can come up with ways to help

808
01:01:19,910 --> 01:01:24,460
programmers structure their program in a
way that this all this security relevant

809
01:01:24,460 --> 01:01:30,570
code ends up in one place or in some
ways more discovered by an auditor and

810
01:01:30,570 --> 01:01:42,890
more easy to reason about examples
there's probably more

811
01:01:42,890 --> 01:01:47,759
yes I mean we actually have this
integrated in some of the remarks were

812
01:01:47,760 --> 01:01:50,720
used internally as we don't use open
source frameworks for the most part we

813
01:01:50,720 --> 01:01:59,058
have internally developed framework that
are you know go to find in the world and

814
01:01:59,059 --> 01:02:05,400
for instance we have integrated
rendering of strict templates with those

815
01:02:05,400 --> 01:02:11,750
sites all your default way of rendering
service that responds to one of the

816
01:02:11,750 --> 01:02:19,740
stick templates rather than writing a
string to us to an output so this

817
01:02:19,740 --> 01:02:25,540
doesn't great

818
01:02:25,540 --> 01:02:37,630
necessarily I mean you against the work
you would have to do in a in a web

819
01:02:37,630 --> 01:02:41,650
application it's built on a different
framework is essentially identified you

820
01:02:41,650 --> 01:02:46,370
server-side injectable things which is
basically a server-side rendering

821
01:02:46,370 --> 01:02:52,779
content over responses and then
constrain those to use instead safe

822
01:02:52,780 --> 01:02:57,760
rappers such as the rain during one of
those templates and that's relatively

823
01:02:57,760 --> 01:03:01,890
straightforward to write these
constraints in something like

824
01:03:01,890 --> 01:03:02,759
error-prone

825
01:03:02,760 --> 01:03:09,580
you know we use these mechanisms like
error-prone and JavaScript compiler

826
01:03:09,580 --> 01:03:14,299
performance framework because they the
kind of far more scalable but in a

827
01:03:14,300 --> 01:03:18,750
smaller project you could probably do
almost all of that with just a regular

828
01:03:18,750 --> 01:03:23,400
expression base resubmit hope in your
code repositories something like this I

829
01:03:23,400 --> 01:03:44,750
mean you just basically 95% there so
it's it doesn't have to be complicated

830
01:03:44,750 --> 01:03:58,660
did we measure the usability of the new
API's we didn't directly measured we

831
01:03:58,660 --> 01:04:02,899
have some anecdotal evidence in terms of
sort of a lack of developer complaints

832
01:04:02,900 --> 01:04:06,500
right i mean so we basically deployed
this we just went I mean so for instance

833
01:04:06,500 --> 01:04:11,320
the GI the sequel API really just went
through all the coding Google and we

834
01:04:11,320 --> 01:04:15,280
didn't even talk to all the people who
use it we just sent out see else to do

835
01:04:15,280 --> 01:04:18,820
we had a robot else to change their code
and this is kind of a pretty common

836
01:04:18,820 --> 01:04:21,520
things that people are used to it than
just accept them if their tests to pass

837
01:04:21,520 --> 01:04:28,080
and and then just change and so after
that we haven't really gotten a lot of

838
01:04:28,080 --> 01:04:32,990
complaints so it seems to be working
right i mean it's it's probably be I

839
01:04:32,990 --> 01:04:36,560
mean I guess we could do some studies
but unless we get any complaints it's

840
01:04:36,560 --> 01:04:41,710
probably not worth it and engineers are
people people like it they will tell you

841
01:04:41,710 --> 01:04:47,930
right so it's sort of silence in terms
of complaints has probably been pretty

842
01:04:47,930 --> 01:05:17,720
good indication that it's reasonable

843
01:05:17,720 --> 01:05:25,319
either ways to make it easier to apply
these approaches with respect to the

844
01:05:25,320 --> 01:05:30,820
design of the underlying languages like
Java script in HTML so I think with

845
01:05:30,820 --> 01:05:36,270
respect to programming languages having
static types really helps because it it

846
01:05:36,270 --> 01:05:40,599
makes it much easier to enforce these
kinds of constraints with precision as

847
01:05:40,599 --> 01:05:43,580
it turns out within Google JavaScript is
actually a statically typed language

848
01:05:43,580 --> 01:05:47,009
right it's basically required that
people use Closure Compiler and use

849
01:05:47,010 --> 01:05:51,490
dietitians on the JavaScript and so we
get to leverage this it's not a

850
01:05:51,490 --> 01:05:56,189
requirement you can you can do all these
things with runtime types it's basically

851
01:05:56,190 --> 01:05:58,780
for people who like to live dangerously
and only find out that they made a

852
01:05:58,780 --> 01:06:03,150
mistake when they run their applications
if you want to live that way is fine

853
01:06:03,150 --> 01:06:08,340
right but you get the same guarantees
it's it's easy to do this with precision

854
01:06:08,340 --> 01:06:13,950
if the language is tight I think HTML
and the whole that platform is is kind

855
01:06:13,950 --> 01:06:20,118
of a bit of a different beast I think I
mean the web platform is just

856
01:06:20,119 --> 01:06:23,990
fundamentally full of sharp edges and
it's sort of a conglomerate of things

857
01:06:23,990 --> 01:06:28,618
that have been stacked on top of each
other and it sort of does seem to have

858
01:06:28,619 --> 01:06:33,170
been a whole lot of coherent thought
about sort of the security properties i

859
01:06:33,170 --> 01:06:36,170
mean you're basically I know if you've
probably read my colleague Michael

860
01:06:36,170 --> 01:06:43,589
celeste is it's you know it's good
bedtime reading your pride parades it's

861
01:06:43,589 --> 01:06:51,130
really hard and so so you know what i
mean france is one thing that comes to

862
01:06:51,130 --> 01:06:56,349
mind is is things like just having
JavaScript in line with the document in

863
01:06:56,349 --> 01:07:00,680
hindsight is a really bad idea and
essentially retro fits what should have

864
01:07:00,680 --> 01:07:04,310
happened in the beginning it in the
first place is that the script is

865
01:07:04,310 --> 01:07:09,369
supplied out of band specified by DPA
response header or something like this

866
01:07:09,369 --> 01:07:12,410
and then a lot of these issues wouldn't
even

867
01:07:12,410 --> 01:07:18,990
impossible right similar things like
JavaScript deemed corrals seem like a

868
01:07:18,990 --> 01:07:22,580
really bad idea in hindsight I probably
had their purpose at some point in the

869
01:07:22,580 --> 01:07:30,650
development of the web so I think I
guess in in more general terms what it

870
01:07:30,650 --> 01:07:35,820
comes down to is that basically you have
guys that fundamentally are to their

871
01:07:35,820 --> 01:07:42,570
design subject to injection because they
mix data and and behavior and that just

872
01:07:42,570 --> 01:07:46,500
seems like always a bad idea that should
be avoided

873
01:07:46,500 --> 01:07:51,210
I mean it's you know there's good reason
for it is very convenient but it does

874
01:07:51,210 --> 01:07:57,650
cause a lot of headaches and so I think
one's instinct I guess API design in the

875
01:07:57,650 --> 01:08:01,590
future maybe should be to avoid that
altogether possible and to avoid things

876
01:08:01,590 --> 01:08:07,400
like strongly typed values I always used
instead of a strange things but it's

877
01:08:07,400 --> 01:08:10,630
it's a it's a difficult problem I mean a
lot of constraints I don't think any

878
01:08:10,630 --> 01:08:47,680
more useful answers on that

879
01:08:47,680 --> 01:09:00,310
data consistency and I think so and and
how this approach is actually a very

880
01:09:00,310 --> 01:09:08,070
good question I mean so one thing I what
we're basically doing here is one of the

881
01:09:08,069 --> 01:09:14,750
key tenants teaching and security is to
always validate your inputs right puts

882
01:09:14,750 --> 01:09:21,620
it turns out that with respect to
validation with respect to specific

883
01:09:21,620 --> 01:09:25,819
contexts such as injection I'm actually
of the opinion that that's bad advised

884
01:09:25,819 --> 01:09:33,080
right it's much more practical to just
do the validation by this year the same

885
01:09:33,080 --> 01:09:36,019
right because then you know you
validating for that context as opposed

886
01:09:36,020 --> 01:09:39,950
to validating ahead of time where your
data might be used in all kinds of

887
01:09:39,950 --> 01:09:44,460
different contexts now this is
validation with respect to specific

888
01:09:44,460 --> 01:09:50,970
classes of security vulnerabilities such
as a specific kind of injection there is

889
01:09:50,970 --> 01:09:55,750
of course higher-level issues that
relate to data consistency and

890
01:09:55,750 --> 01:10:01,590
Princeton's basically I mean about
injection it's more about confusing the

891
01:10:01,590 --> 01:10:05,650
control flow in your application due to
inconsistent data and that kind of

892
01:10:05,650 --> 01:10:10,370
validation is extremely important and
valuable and so but I think it's largely

893
01:10:10,370 --> 01:10:14,490
or talk to these concerns I take you if
your friends don't see any one example

894
01:10:14,490 --> 01:10:18,490
might be that when year when you're
consuming an external input that

895
01:10:18,490 --> 01:10:20,010
supposed to be an email address

896
01:10:20,010 --> 01:10:24,610
maybe it's actually a better idea rather
than passing this thing around as a

897
01:10:24,610 --> 01:10:25,650
plain string

898
01:10:25,650 --> 01:10:29,389
actually passage into the main object
that represents an email address that

899
01:10:29,390 --> 01:10:38,590
then has itself time contract at 10 or
whatever and then use that type

900
01:10:38,590 --> 01:10:42,640
throughout your program because then
that I can actually give you meaningful

901
01:10:42,640 --> 01:10:48,380
contracts and the government guarantees
that way also avoid sort of the

902
01:10:48,380 --> 01:10:52,920
repetition of the validation with it

903
01:10:52,920 --> 01:10:53,630
type value

904
01:10:53,630 --> 01:11:00,679
strength that you have two recent highs
or validate in every context where you

905
01:11:00,679 --> 01:11:26,929
might be acting on it

906
01:11:26,929 --> 01:11:33,179
open sourcing they saw it so I didn't
actually say I don't want to open

907
01:11:33,179 --> 01:11:38,559
sources in fact the compilers to quote
is actually open source already it's

908
01:11:38,559 --> 01:11:42,760
part of a compiler distribution there's
some other things that we're currently

909
01:11:42,760 --> 01:11:45,939
working on open source thing that hasn't
been a priority because its work right i

910
01:11:45,939 --> 01:11:50,519
mean we're all busy but I'm not all
opposed to open sourcing this my my

911
01:11:50,519 --> 01:11:54,920
comment about open source was more about
how this actually can be effectively

912
01:11:54,920 --> 01:12:00,679
applied because it does seem in order to
actually work that has to be somebody on

913
01:12:00,679 --> 01:12:04,110
the project who plays the curator and
the enforcer that it actually gets

914
01:12:04,110 --> 01:12:08,570
applied correctly and so unless you have
project teams that actually have a

915
01:12:08,570 --> 01:12:12,360
security personnel security audit or
that you are set up their pre submit

916
01:12:12,360 --> 01:12:18,959
scripts to limit the use of these
conversions and potentially unsafe API's

917
01:12:18,959 --> 01:12:23,570
you tend to probably end up with too
many uses of that and then you lose the

918
01:12:23,570 --> 01:12:28,799
whole benefit so I think to some extent
that's maybe meditation thing maybe some

919
01:12:28,800 --> 01:12:33,599
of the projects could actually be
convinced that this is a good idea I

920
01:12:33,599 --> 01:12:37,039
mean we were able to convince large
teams within Google that it's a good

921
01:12:37,039 --> 01:12:40,438
idea and the in fact put up their own
head count to do all the restructuring

922
01:12:40,439 --> 01:12:45,739
right so the the clearly see the value
and so it's not inconceivable that open

923
01:12:45,739 --> 01:12:49,299
source projects with similar didn't see
the value but it would require some

924
01:12:49,300 --> 01:13:07,429
basically change in mindset in education

925
01:13:07,429 --> 01:13:32,349
we actually have some of these builders
we have added additional features that

926
01:13:32,349 --> 01:13:36,969
allow you to essentially introspective
schema and then allow you to attend a

927
01:13:36,969 --> 01:13:41,889
papal name that's actually part of the
scheme of course you put this is

928
01:13:41,889 --> 01:13:44,780
essentially its syntactic sugar item you
could write this code your own and then

929
01:13:44,780 --> 01:13:53,179
basically admit a table that's or a
dictionary that's a mapping from strings

930
01:13:53,179 --> 01:13:59,139
to Little People builder snippets that
value and then you basically end up

931
01:13:59,139 --> 01:14:05,510
turning these people is independence and
you can I don't think this is a

932
01:14:05,510 --> 01:14:08,389
fundamental constrained and then also I
mean there are certain things are for

933
01:14:08,389 --> 01:14:16,949
instance in our languages or dialects
you can find value durables and it'll

934
01:14:16,949 --> 01:14:20,138
automatically sort of the expansion
whereas in my seek for instance you have

935
01:14:20,139 --> 01:14:24,630
to expand this into a like a question
marks and and like into a vector

936
01:14:24,630 --> 01:14:28,789
basically the exact same lands that's
again something you could add to the

937
01:14:28,789 --> 01:14:34,380
corresponding builder that but I don't
think it's it's a fundamental limitation

938
01:14:34,380 --> 01:14:37,530
and again the worst case you know if
there's some really unusual case you

939
01:14:37,530 --> 01:14:42,179
can't express you have this backdoor epi
you can actually use this to just create

940
01:14:42,179 --> 01:14:48,189
a snippet that just basically a build
her a custom builder for just that

941
01:14:48,189 --> 01:14:52,400
particular snippets of agree that you
need and then only that little piece of

942
01:14:52,400 --> 01:14:54,409
it becomes

943
01:14:54,409 --> 01:15:16,199
dude and the rest of it still

944
01:15:16,199 --> 01:15:39,749
i think im really not too worried about
things worse in the case it's less

945
01:15:39,749 --> 01:15:45,239
obvious and it would be nice as I said
to apply some more fundraising and

946
01:15:45,239 --> 01:15:48,860
formally specify the type contract for
instance for these HTML tags and then

947
01:15:48,860 --> 01:15:54,719
tried to make a rigorous argument that a
sanitizer produces always values that

948
01:15:54,719 --> 01:15:58,769
are compliant with that type contract in
practice I'm not quite sure about how to

949
01:15:58,769 --> 01:16:02,809
how to go about this and particularly
considering that there isn't really a

950
01:16:02,809 --> 01:16:08,449
good form aspect of course some work
that has attempt to do this but I think

951
01:16:08,449 --> 01:16:12,219
in practice a lot of the bugs actually
arise from code that doesn't that stole

952
01:16:12,219 --> 01:16:15,570
the outside of this back I mean we have
cold in there that for instance deals

953
01:16:15,570 --> 01:16:23,018
with you know there's like the fact that
you can use the expression syntax in CSS

954
01:16:23,019 --> 01:16:32,340
in IE coordinates right so that I mean
only does or we have things to deal with

955
01:16:32,340 --> 01:16:38,090
the fact that any document that has a
PDF header in the first one case of the

956
01:16:38,090 --> 01:16:42,760
document can actually be read by the
plugin as a PDF document and then if we

957
01:16:42,760 --> 01:16:47,110
don't worry about it correctly escape
this then then we have problems we

958
01:16:47,110 --> 01:16:50,630
actually have bowed in our Jason
encoders it deals with the fact that a

959
01:16:50,630 --> 01:16:55,070
document could be interpreted by the PDF
document and misinterpreted as such

960
01:16:55,070 --> 01:16:58,070
right and so there's a lot of these
things that I just really weird stuff

961
01:16:58,070 --> 01:17:04,289
that that would seem very very difficult
to capture in a formal specification and

962
01:17:04,289 --> 01:17:07,978
studies eg cases actually where the bugs
come from and really in the end what it

963
01:17:07,979 --> 01:17:11,890
comes down to is we write this code and
then we give it to people like

964
01:17:11,890 --> 01:17:21,980
what you think about it and in the end
this is really an empiric science in a

965
01:17:21,980 --> 01:17:28,290
way to to figure out what you need to do
to avoid script injections across all

966
01:17:28,290 --> 01:17:33,500
the available browsers sadly maybe get
better I mean once everybody's text HTML

967
01:17:33,500 --> 01:17:37,890
5 maybe something but that might be more
profitable but for now I think just

968
01:17:37,890 --> 01:17:40,750
doing that is a limitation i mean you
could do some formal reasoning but I

969
01:17:40,750 --> 01:17:46,850
think the spec itself would be based on
empirical work about the actual behavior

970
01:17:46,850 --> 01:17:50,660
of real browsers and a lot of that would
be based on like a reverse engineer or

971
01:17:50,660 --> 01:17:55,090
something which is not a good way to
write aspect right so I'm not too sure

972
01:17:55,090 --> 01:18:46,389
if it's worth spending a lot of time on
that at this time

973
01:18:46,389 --> 01:18:56,849
if you have a level code that basically
has a stored procedure in the database

974
01:18:56,849 --> 01:19:02,499
that itself is subject to legal
injection then that sort of another

975
01:19:02,499 --> 01:19:07,249
layer of this problem and the builder at
the level of the client language

976
01:19:07,249 --> 01:19:10,619
couldn't prevent that obviously right so
I think in that case what you would have

977
01:19:10,619 --> 01:19:15,598
to do I guess is maybe implement a
simple similar builder in as a single

978
01:19:15,599 --> 01:19:21,530
procedure and then use some kind of
study check or whatever to enforce that

979
01:19:21,530 --> 01:19:26,789
all the stored procedure code uses that
built instead of string concatenation to

980
01:19:26,789 --> 01:19:35,009
make further queries right i mean i cant
say no we don't we don't have that

981
01:19:35,010 --> 01:19:35,729
problem

