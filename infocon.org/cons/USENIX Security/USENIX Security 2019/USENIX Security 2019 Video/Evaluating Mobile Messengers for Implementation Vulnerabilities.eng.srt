1
00:00:10,540 --> 00:00:15,639
so today I'm gonna talk about evaluating

2
00:00:13,430 --> 00:00:18,740
mobile messengers for implementation

3
00:00:15,640 --> 00:00:21,140
vulnerabilities i'm natali salvado vich

4
00:00:18,740 --> 00:00:24,049
and I'm a member of project zero at

5
00:00:21,140 --> 00:00:26,090
Google project zero is a team that looks

6
00:00:24,050 --> 00:00:28,700
at software from a user focused

7
00:00:26,090 --> 00:00:31,310
perspective we look at all software not

8
00:00:28,700 --> 00:00:34,100
just Google software and our mission is

9
00:00:31,310 --> 00:00:36,050
to make zero-day hard a lot of attackers

10
00:00:34,100 --> 00:00:38,030
use your own a vulnerabilities

11
00:00:36,050 --> 00:00:40,190
these are vulnerabilities that are not

12
00:00:38,030 --> 00:00:42,409
yet known by the vendor for all sorts of

13
00:00:40,190 --> 00:00:44,540
purposes and we want to make these types

14
00:00:42,409 --> 00:00:48,379
of bugs less prevalent and less

15
00:00:44,540 --> 00:00:50,960
available to attackers our biggest piece

16
00:00:48,379 --> 00:00:53,000
of work is that we spend a lot of time

17
00:00:50,960 --> 00:00:54,559
looking for these vulnerabilities so we

18
00:00:53,000 --> 00:00:56,330
can report them to the vendor so they

19
00:00:54,559 --> 00:00:59,150
get fixed and they're no longer

20
00:00:56,330 --> 00:01:01,280
available to attackers but we also spend

21
00:00:59,150 --> 00:01:03,920
time working with vendors to make their

22
00:01:01,280 --> 00:01:06,200
software less bug prone and we also

23
00:01:03,920 --> 00:01:08,510
spend a lot of time writing and talking

24
00:01:06,200 --> 00:01:10,130
about zero-day vulnerabilities so that

25
00:01:08,510 --> 00:01:14,030
information about state-of-the-art

26
00:01:10,130 --> 00:01:16,219
attacks is available to defenders so one

27
00:01:14,030 --> 00:01:18,619
thing we've looked at recently is mobile

28
00:01:16,219 --> 00:01:21,288
messengers and there's been a lot of

29
00:01:18,619 --> 00:01:24,950
indications that malicious people are

30
00:01:21,289 --> 00:01:27,320
using them for example this is a payout

31
00:01:24,950 --> 00:01:29,780
table from a company called sir rhodium

32
00:01:27,320 --> 00:01:32,148
the rhodium will buy zero-day

33
00:01:29,780 --> 00:01:35,270
vulnerabilities and they post their

34
00:01:32,149 --> 00:01:37,340
price list online so if you find a

35
00:01:35,270 --> 00:01:39,829
remote jailbreak in an iphone that

36
00:01:37,340 --> 00:01:42,380
doesn't require any click to compromise

37
00:01:39,829 --> 00:01:45,589
someone's device they say they'll pay

38
00:01:42,380 --> 00:01:47,658
1.5 million dollars for this meanwhile

39
00:01:45,590 --> 00:01:50,329
if you find a vulnerability that lets

40
00:01:47,659 --> 00:01:50,869
you access someone's messages in various

41
00:01:50,329 --> 00:01:54,499
messengers

42
00:01:50,869 --> 00:01:56,570
they'll pay up to $500,000 for

43
00:01:54,499 --> 00:02:00,229
messengers like WeChat facebook

44
00:01:56,570 --> 00:02:02,029
Messenger signal what's up and this is

45
00:02:00,229 --> 00:02:04,729
an indication that they're buying these

46
00:02:02,030 --> 00:02:07,009
bugs so that they can use them so this

47
00:02:04,729 --> 00:02:09,380
is one sign that attackers are looking

48
00:02:07,009 --> 00:02:12,319
for bugs in mobile messengers there was

49
00:02:09,380 --> 00:02:15,350
also this news article about the UAE

50
00:02:12,319 --> 00:02:16,459
secret hacking team and they used a tool

51
00:02:15,350 --> 00:02:18,829
called Karma

52
00:02:16,460 --> 00:02:21,470
that did not require the the target to

53
00:02:18,830 --> 00:02:22,430
click and relied on an undisclosed Deval

54
00:02:21,470 --> 00:02:25,909
in their ability

55
00:02:22,430 --> 00:02:28,220
in Apple's iMessage meanwhile there was

56
00:02:25,909 --> 00:02:30,679
not very much public information about

57
00:02:28,220 --> 00:02:33,290
how these attacks might work or where

58
00:02:30,680 --> 00:02:36,079
the bugs might be so we started a

59
00:02:33,290 --> 00:02:37,939
project to find vulnerabilities in

60
00:02:36,079 --> 00:02:40,790
messaging clients so that they could be

61
00:02:37,939 --> 00:02:42,950
fixed and we also wanted to gain a

62
00:02:40,790 --> 00:02:44,750
better understanding of how bugs and

63
00:02:42,950 --> 00:02:47,119
exploits work on these targets and

64
00:02:44,750 --> 00:02:48,859
finally we were hoping to understand

65
00:02:47,120 --> 00:02:52,220
possible structural improvements for

66
00:02:48,859 --> 00:02:54,470
messengers so just to look a little bit

67
00:02:52,220 --> 00:02:56,659
of a technical level what was my goal

68
00:02:54,470 --> 00:02:58,489
here so typically you have some sort of

69
00:02:56,659 --> 00:03:00,920
messaging client and you have a user who

70
00:02:58,489 --> 00:03:03,230
writes a message and then the message

71
00:03:00,920 --> 00:03:05,119
gets encrypted and it's often just sent

72
00:03:03,230 --> 00:03:06,738
to the other user over the network and

73
00:03:05,120 --> 00:03:09,019
then they decrypt the message and they

74
00:03:06,739 --> 00:03:11,420
have it sometimes it's a little bit more

75
00:03:09,019 --> 00:03:15,290
complicated sometimes there's also an

76
00:03:11,420 --> 00:03:16,939
intermediary server that will add an add

77
00:03:15,290 --> 00:03:19,099
a layer so now you have your user

78
00:03:16,939 --> 00:03:21,319
encrypting their message and then the

79
00:03:19,099 --> 00:03:22,790
server adds a layer and this is just

80
00:03:21,319 --> 00:03:26,030
data that the device wants to give to

81
00:03:22,790 --> 00:03:28,429
the server and then this server that

82
00:03:26,030 --> 00:03:31,489
looks nothing like an actual server will

83
00:03:28,430 --> 00:03:33,379
process it remove the layer add in a new

84
00:03:31,489 --> 00:03:35,720
one that's information for this next

85
00:03:33,379 --> 00:03:38,929
device and then give back the encrypted

86
00:03:35,720 --> 00:03:40,790
message and then it gets decrypted but

87
00:03:38,930 --> 00:03:42,650
what's really important is what we

88
00:03:40,790 --> 00:03:45,500
wanted to do was put a malicious payload

89
00:03:42,650 --> 00:03:47,629
here so before encryption create some

90
00:03:45,500 --> 00:03:50,209
sort of malformed message that would

91
00:03:47,629 --> 00:03:52,879
allow code execution or some other

92
00:03:50,209 --> 00:03:56,060
undesired behavior here so we're hoping

93
00:03:52,879 --> 00:03:58,909
to basically you know nor encryption

94
00:03:56,060 --> 00:04:01,069
alter what's underneath it and find a

95
00:03:58,909 --> 00:04:05,120
vulnerability that hopefully had some

96
00:04:01,069 --> 00:04:07,159
malicious effect so we looked at

97
00:04:05,120 --> 00:04:09,079
whatsapp and I messaged these are the

98
00:04:07,159 --> 00:04:10,879
examples I'll share today we actually

99
00:04:09,079 --> 00:04:12,829
spent a fair amount of time looking at

100
00:04:10,879 --> 00:04:15,948
messengers so this is by no means a

101
00:04:12,829 --> 00:04:17,449
comprehensive list so for whatsapp on

102
00:04:15,949 --> 00:04:19,699
the attack surface was kind of

103
00:04:17,449 --> 00:04:22,789
interesting it was mostly written in

104
00:04:19,699 --> 00:04:24,830
Java and Java is unlikely to have memory

105
00:04:22,789 --> 00:04:28,849
corruption bugs it's a lot more likely

106
00:04:24,830 --> 00:04:32,359
to have logic bugs so we decided we were

107
00:04:28,849 --> 00:04:34,449
going to focus on the areas that

108
00:04:32,360 --> 00:04:37,009
native code which it was only

109
00:04:34,449 --> 00:04:39,430
videoconferencing so this was a fairly

110
00:04:37,009 --> 00:04:41,990
small attack surface all considered I

111
00:04:39,430 --> 00:04:44,599
mean here's how videoconferencing works

112
00:04:41,990 --> 00:04:47,840
and this is not specific to whatsapp at

113
00:04:44,599 --> 00:04:49,789
all you have here on this diagram is

114
00:04:47,840 --> 00:04:52,250
browsers but if it's whatsapp it's two

115
00:04:49,789 --> 00:04:54,680
mobile clients and they'll first

116
00:04:52,250 --> 00:04:58,219
communicate to each other to figure out

117
00:04:54,680 --> 00:05:00,530
what they support do a key exchange that

118
00:04:58,219 --> 00:05:02,479
sort of thing and then they'll have this

119
00:05:00,530 --> 00:05:05,770
encrypted stream of whatever they

120
00:05:02,479 --> 00:05:08,000
negotiated off in audio and video and

121
00:05:05,770 --> 00:05:09,799
from a perspective level a

122
00:05:08,000 --> 00:05:13,129
videoconferencing typically looks like

123
00:05:09,800 --> 00:05:15,379
this and this is I'm consistent against

124
00:05:13,129 --> 00:05:19,159
most implementations I looked at a

125
00:05:15,379 --> 00:05:21,379
FaceTime and whatsapp and WebRTC which

126
00:05:19,159 --> 00:05:22,550
is in all browsers allowing

127
00:05:21,379 --> 00:05:24,830
videoconference saying

128
00:05:22,550 --> 00:05:27,590
and typically they all used a protocol

129
00:05:24,830 --> 00:05:30,800
stack that looked like this so a

130
00:05:27,590 --> 00:05:32,810
focusing on my right side there is the

131
00:05:30,800 --> 00:05:34,759
network and then there's transport which

132
00:05:32,810 --> 00:05:38,000
is typically UDP though there's no

133
00:05:34,759 --> 00:05:41,300
reason it can't be TCP and then you use

134
00:05:38,000 --> 00:05:47,270
a nice stun intern just to resolve um IP

135
00:05:41,300 --> 00:05:49,129
addresses and make it so that packets

136
00:05:47,270 --> 00:05:52,190
can be routed directly from one device

137
00:05:49,129 --> 00:05:55,370
to another then typically your call will

138
00:05:52,190 --> 00:05:58,669
be wrapped in TLS and then there's a

139
00:05:55,370 --> 00:06:00,560
protocol called SRTP and this is the

140
00:05:58,669 --> 00:06:02,120
real-time protocol which is what

141
00:06:00,560 --> 00:06:04,400
actually contains the videoconferencing

142
00:06:02,120 --> 00:06:07,729
content and it often has its own layer

143
00:06:04,400 --> 00:06:10,479
of encryption as well so what happens

144
00:06:07,729 --> 00:06:13,490
when the device actually gets on SRTP

145
00:06:10,479 --> 00:06:16,400
well it will decrypt it and there's

146
00:06:13,490 --> 00:06:18,620
problems with SRTP encryption

147
00:06:16,400 --> 00:06:20,750
historically so often this will also be

148
00:06:18,620 --> 00:06:25,400
under TLS so it's kind of double

149
00:06:20,750 --> 00:06:26,839
encrypted and then there is the RTP RTP

150
00:06:25,400 --> 00:06:29,029
will go through an error correction

151
00:06:26,839 --> 00:06:32,719
sequence if that's enabled to get the

152
00:06:29,029 --> 00:06:35,569
real RTP and then it will be decoded

153
00:06:32,719 --> 00:06:39,650
into a buffer it'll be given to a codec

154
00:06:35,569 --> 00:06:41,860
which processes the incoming image or

155
00:06:39,650 --> 00:06:44,479
audio and then you see it on your screen

156
00:06:41,860 --> 00:06:45,360
so this is a fairly reasonable attack

157
00:06:44,479 --> 00:06:48,090
surface

158
00:06:45,360 --> 00:06:52,770
even if in what's the only native code

159
00:06:48,090 --> 00:06:54,810
is videoconferencing so I looked at the

160
00:06:52,770 --> 00:06:58,020
Android app because the desktop app

161
00:06:54,810 --> 00:07:00,180
doesn't do voice and I looked at the

162
00:06:58,020 --> 00:07:02,128
binary in Ida and there weren't any

163
00:07:00,180 --> 00:07:04,439
symbols but there were lots of log

164
00:07:02,129 --> 00:07:08,340
entries from a commercial library called

165
00:07:04,439 --> 00:07:11,939
Lib SRTP or or sir from called peach a

166
00:07:08,340 --> 00:07:14,609
sip live our CSR TVP is an open source

167
00:07:11,939 --> 00:07:20,699
library that does I'm the RTP processing

168
00:07:14,610 --> 00:07:22,409
but anyhow these two libraries both have

169
00:07:20,699 --> 00:07:23,969
the source available even though for PJs

170
00:07:22,409 --> 00:07:26,069
if you have to license it to actually

171
00:07:23,969 --> 00:07:27,960
use it so I could see the log entries in

172
00:07:26,069 --> 00:07:30,270
there so I looked through the binary for

173
00:07:27,960 --> 00:07:32,430
similar log entries and I found one

174
00:07:30,270 --> 00:07:34,440
place we're at mem coffees a packet

175
00:07:32,430 --> 00:07:36,270
right before I guess encrypt did so I

176
00:07:34,440 --> 00:07:37,620
found that spot in the binary and

177
00:07:36,270 --> 00:07:40,159
thought that would be a good place to

178
00:07:37,620 --> 00:07:43,259
start altering the encrypted messages I

179
00:07:40,159 --> 00:07:45,210
wrote a script in Freda Freda is a tool

180
00:07:43,259 --> 00:07:47,069
that allows you on mobile devices to

181
00:07:45,210 --> 00:07:49,229
quite easily just hook all instances of

182
00:07:47,069 --> 00:07:53,270
a function and then send them to Python

183
00:07:49,229 --> 00:07:55,770
so you can do stuff with them and I

184
00:07:53,270 --> 00:07:58,409
tried this but this didn't quite work

185
00:07:55,770 --> 00:08:00,659
out I could use it to confirm that this

186
00:07:58,409 --> 00:08:02,729
mem copy definitely did mem copy the

187
00:08:00,659 --> 00:08:03,930
packet and it was the right spot but if

188
00:08:02,729 --> 00:08:05,250
I tried to actually make it a call with

189
00:08:03,930 --> 00:08:06,839
it hooked it would be like such a slow

190
00:08:05,250 --> 00:08:09,659
call it would eventually draw because

191
00:08:06,839 --> 00:08:12,029
this slowed down the packet so much so

192
00:08:09,659 --> 00:08:14,310
basically used it to debug minor changes

193
00:08:12,029 --> 00:08:16,710
but I didn't use it for the final result

194
00:08:14,310 --> 00:08:18,569
so I ended up changing this specific mem

195
00:08:16,710 --> 00:08:20,878
copy to point somewhere else in the

196
00:08:18,569 --> 00:08:24,270
binary and then I wrote code in assembly

197
00:08:20,879 --> 00:08:26,550
so that it would blow in my library and

198
00:08:24,270 --> 00:08:28,710
then make a call in my library that

199
00:08:26,550 --> 00:08:32,310
would actually allow me to see and

200
00:08:28,710 --> 00:08:33,809
change the use encrypted packets if

201
00:08:32,309 --> 00:08:36,059
you're interested I ended up overwriting

202
00:08:33,809 --> 00:08:37,409
the gist transcoder for this because you

203
00:08:36,059 --> 00:08:39,088
only use that when you're sending

204
00:08:37,409 --> 00:08:41,000
messages so I thought you know so long

205
00:08:39,089 --> 00:08:43,680
as I don't use my special version to

206
00:08:41,000 --> 00:08:48,660
actually send gifts it would still work

207
00:08:43,679 --> 00:08:50,189
and it did so I tried this and I had

208
00:08:48,660 --> 00:08:52,230
like regular debugging issues it took a

209
00:08:50,190 --> 00:08:54,930
long time to like to bug that assembly

210
00:08:52,230 --> 00:08:58,520
and make sure it was correct but after a

211
00:08:54,930 --> 00:09:01,370
while I could log in and alter the ink

212
00:08:58,520 --> 00:09:03,079
in packets when I made a call so I'd

213
00:09:01,370 --> 00:09:04,520
make a call the system generates the

214
00:09:03,080 --> 00:09:07,100
packets and then encrypts them and that

215
00:09:04,520 --> 00:09:11,030
was where I was able to hook straight in

216
00:09:07,100 --> 00:09:13,400
and logging was great everything looked

217
00:09:11,030 --> 00:09:16,189
correct but when I tried to replay

218
00:09:13,400 --> 00:09:19,730
packets that was by using these logs it

219
00:09:16,190 --> 00:09:21,440
didn't work it was not great because you

220
00:09:19,730 --> 00:09:23,780
know I get a crash one so I'm like

221
00:09:21,440 --> 00:09:27,170
that's a bad bug and then I can never

222
00:09:23,780 --> 00:09:29,689
get the crash again so I look at it a

223
00:09:27,170 --> 00:09:34,550
bit more and it turned out the problem

224
00:09:29,690 --> 00:09:37,820
was in a format called RTP and

225
00:09:34,550 --> 00:09:40,099
specifically in a field called the SSRC

226
00:09:37,820 --> 00:09:41,600
if you think about videoconferencing

227
00:09:40,100 --> 00:09:44,030
theoretically you could be doing it a

228
00:09:41,600 --> 00:09:45,980
lot you could be you know on a Facebook

229
00:09:44,030 --> 00:09:47,990
call well you're also streaming a video

230
00:09:45,980 --> 00:09:50,840
well you're also doing all these other

231
00:09:47,990 --> 00:09:52,850
things and the endpoint needs a way to

232
00:09:50,840 --> 00:09:55,370
keep it all straight so every time you

233
00:09:52,850 --> 00:09:56,900
create a channel like video or audio or

234
00:09:55,370 --> 00:09:59,180
anything like that it'll have this

235
00:09:56,900 --> 00:10:01,400
random SSRC and this is just random

236
00:09:59,180 --> 00:10:04,069
every time you do a video call it is

237
00:10:01,400 --> 00:10:06,410
different so it turns out that this was

238
00:10:04,070 --> 00:10:07,760
my problem I needed to make sure that

239
00:10:06,410 --> 00:10:10,010
when I replayed it it was the same

240
00:10:07,760 --> 00:10:12,710
identifier as the system thought it

241
00:10:10,010 --> 00:10:15,740
should be so I fixed this up

242
00:10:12,710 --> 00:10:18,350
I discovered that whatsapp has four RTP

243
00:10:15,740 --> 00:10:20,540
streams even if you mute the call my

244
00:10:18,350 --> 00:10:22,490
joke here was you know one for audio one

245
00:10:20,540 --> 00:10:25,310
for video one for synchronization and

246
00:10:22,490 --> 00:10:27,290
one for good luck I truly cannot figure

247
00:10:25,310 --> 00:10:30,380
out what someone would do with four RTP

248
00:10:27,290 --> 00:10:33,050
streams luckily they all had different

249
00:10:30,380 --> 00:10:35,270
payload types so if you look here

250
00:10:33,050 --> 00:10:37,130
there's the payload type so that made

251
00:10:35,270 --> 00:10:38,840
things easy I would look for a packet

252
00:10:37,130 --> 00:10:40,370
with the correct payload type Pullman

253
00:10:38,840 --> 00:10:43,190
out of the log with the same type and

254
00:10:40,370 --> 00:10:45,770
then just fix the SSRC and it worked I'm

255
00:10:43,190 --> 00:10:48,110
so that was cool I could you know make a

256
00:10:45,770 --> 00:10:51,199
call and then make exactly the same call

257
00:10:48,110 --> 00:10:53,830
and send the packets again so I had one

258
00:10:51,200 --> 00:10:56,390
more problem which was crash detection I

259
00:10:53,830 --> 00:10:58,910
discovered that whatsapp handle signal

260
00:10:56,390 --> 00:11:00,920
crashes internally so if you have a

261
00:10:58,910 --> 00:11:03,680
crash in whatsapp what'll happen is

262
00:11:00,920 --> 00:11:06,260
whatsapp will catch it it will crash it

263
00:11:03,680 --> 00:11:07,579
it will log it and that asset probably

264
00:11:06,260 --> 00:11:10,340
send it to the server so they can figure

265
00:11:07,580 --> 00:11:11,920
out why you crashed so this meant

266
00:11:10,340 --> 00:11:13,960
unfortunately it

267
00:11:11,920 --> 00:11:15,250
handled by the Android logging system

268
00:11:13,960 --> 00:11:17,650
which meant that I couldn't see the

269
00:11:15,250 --> 00:11:19,720
crash for a while I thought I was going

270
00:11:17,650 --> 00:11:22,150
crazy and eventually I went and I

271
00:11:19,720 --> 00:11:24,610
stubbed out signal and sig said and

272
00:11:22,150 --> 00:11:26,439
basically every call that I thought

273
00:11:24,610 --> 00:11:27,880
could be handling signals and once I

274
00:11:26,440 --> 00:11:32,710
made all these calls do nothing I

275
00:11:27,880 --> 00:11:34,120
started getting logs in Android so this

276
00:11:32,710 --> 00:11:36,340
was an interesting problem something

277
00:11:34,120 --> 00:11:38,740
that I wasn't expecting but a lot of

278
00:11:36,340 --> 00:11:43,300
Android applications actually do this

279
00:11:38,740 --> 00:11:46,150
crash suppression thing so I fast a bit

280
00:11:43,300 --> 00:11:48,069
so I sent it random data over and over

281
00:11:46,150 --> 00:11:50,500
until it crashed and I found this one

282
00:11:48,070 --> 00:11:55,390
vulnerability which was heap corruption

283
00:11:50,500 --> 00:11:59,110
in the RTP processing so um as I did

284
00:11:55,390 --> 00:12:00,910
this it became clear the the signaling

285
00:11:59,110 --> 00:12:04,300
for the video conferencing was also done

286
00:12:00,910 --> 00:12:06,339
in native code so when you were sending

287
00:12:04,300 --> 00:12:12,040
your key and saying what you supported

288
00:12:06,340 --> 00:12:13,840
this was also a native thing and what

289
00:12:12,040 --> 00:12:15,880
was even more interesting is it wasn't

290
00:12:13,840 --> 00:12:17,800
limited to the correct packet for the

291
00:12:15,880 --> 00:12:19,630
state so normally if you are doing a

292
00:12:17,800 --> 00:12:21,400
call it'll be something like I want to

293
00:12:19,630 --> 00:12:23,530
call sure I want to call

294
00:12:21,400 --> 00:12:25,750
oh I'll pre accept you okay I'll pre

295
00:12:23,530 --> 00:12:28,030
accept back that sort of thing and in

296
00:12:25,750 --> 00:12:30,130
whatsapp I think there's about four or

297
00:12:28,030 --> 00:12:33,280
five of these exchanges and what was

298
00:12:30,130 --> 00:12:34,930
weird is let's say you had not started a

299
00:12:33,280 --> 00:12:36,880
call and you said well I want to pre

300
00:12:34,930 --> 00:12:41,560
accept it would still process it and

301
00:12:36,880 --> 00:12:43,150
even weirder let's say you know you said

302
00:12:41,560 --> 00:12:45,189
oh I want to call oh that's a call

303
00:12:43,150 --> 00:12:47,319
except if you sent a call except in the

304
00:12:45,190 --> 00:12:48,540
wrong direction it would also process

305
00:12:47,320 --> 00:12:51,130
that even though there was no reason

306
00:12:48,540 --> 00:12:53,280
that someone on that end of the call

307
00:12:51,130 --> 00:12:55,960
would ever need that packet so this was

308
00:12:53,280 --> 00:12:58,990
unnecessary attack surface so I thought

309
00:12:55,960 --> 00:13:01,690
that made this even more interesting so

310
00:12:58,990 --> 00:13:04,210
I reviewed each entry point each packet

311
00:13:01,690 --> 00:13:06,730
processing and I found some extremely

312
00:13:04,210 --> 00:13:08,260
boring crashes it would you know you

313
00:13:06,730 --> 00:13:09,700
would try and start a call and start

314
00:13:08,260 --> 00:13:10,900
starting a call it would have no pointer

315
00:13:09,700 --> 00:13:15,220
exception and then the process would

316
00:13:10,900 --> 00:13:17,050
respawn so it did absolutely nothing but

317
00:13:15,220 --> 00:13:19,240
then I found something even more

318
00:13:17,050 --> 00:13:21,310
interesting which was you know how

319
00:13:19,240 --> 00:13:24,279
sometimes these um packets have the

320
00:13:21,310 --> 00:13:26,619
server layer in this server layer you

321
00:13:24,279 --> 00:13:29,680
get the voit params from the server and

322
00:13:26,620 --> 00:13:31,569
this was a huge JSON blob and it said

323
00:13:29,680 --> 00:13:33,638
that dozens of properties like I'm not

324
00:13:31,569 --> 00:13:36,430
exaggerating if I said like I think it

325
00:13:33,639 --> 00:13:38,800
could set up to 200 different properties

326
00:13:36,430 --> 00:13:41,019
initialization properties and what's up

327
00:13:38,800 --> 00:13:43,240
and I discovered that there was a way

328
00:13:41,019 --> 00:13:46,300
that you could send this and trick the

329
00:13:43,240 --> 00:13:48,999
server into sending your version to the

330
00:13:46,300 --> 00:13:52,089
peer most packet types would not do this

331
00:13:48,999 --> 00:13:57,370
but one packet type would and I thought

332
00:13:52,089 --> 00:14:00,370
this might be a good source of a bug so

333
00:13:57,370 --> 00:14:02,259
I'm Travis or Mindy helped me take this

334
00:14:00,370 --> 00:14:04,569
whatsapp library that processed the

335
00:14:02,259 --> 00:14:06,249
Jason and set the parameters I'm running

336
00:14:04,569 --> 00:14:08,949
on Linux so we could do distributed

337
00:14:06,249 --> 00:14:13,300
fuzzing and see if there were any bugs

338
00:14:08,949 --> 00:14:14,709
in that apple on a large scale and this

339
00:14:13,300 --> 00:14:18,969
turned out to be a lot of work and we

340
00:14:14,709 --> 00:14:20,559
did not find any bugs doing this so I

341
00:14:18,970 --> 00:14:21,550
contacted whatsapp it was sort of

342
00:14:20,559 --> 00:14:24,550
interesting

343
00:14:21,550 --> 00:14:26,199
they said they were aware of other VoIP

344
00:14:24,550 --> 00:14:28,660
RAM issues they're not the one I had

345
00:14:26,199 --> 00:14:31,689
filed and honestly they fixed this

346
00:14:28,660 --> 00:14:33,670
report like extremely quickly so I'm not

347
00:14:31,689 --> 00:14:36,969
quite sure what the impact was but I

348
00:14:33,670 --> 00:14:38,259
feel like it was probably something they

349
00:14:36,970 --> 00:14:41,290
said also that they were considering

350
00:14:38,259 --> 00:14:42,879
signing this this blob so that they

351
00:14:41,290 --> 00:14:45,430
would never have a pure issue again you

352
00:14:42,879 --> 00:14:50,470
can imagine if a device or a server has

353
00:14:45,430 --> 00:14:52,930
to sign it and do you use public key

354
00:14:50,470 --> 00:14:54,939
cryptography then the other the other

355
00:14:52,930 --> 00:14:56,138
side would have to check the sign and

356
00:14:54,939 --> 00:14:57,370
then you would never be able to send it

357
00:14:56,139 --> 00:14:59,379
from the peer unless you had the

358
00:14:57,370 --> 00:15:02,470
server's key and I think that's a pretty

359
00:14:59,379 --> 00:15:04,360
good idea and then they also had plans

360
00:15:02,470 --> 00:15:05,680
to reduce the attack surface make it so

361
00:15:04,360 --> 00:15:08,319
that the packets have to be an order

362
00:15:05,680 --> 00:15:12,008
that sort of thing so I thought that was

363
00:15:08,319 --> 00:15:15,759
pretty exciting but then this happened

364
00:15:12,009 --> 00:15:17,709
and what was interesting about it is it

365
00:15:15,759 --> 00:15:20,290
was just so similar to what I looked at

366
00:15:17,709 --> 00:15:23,410
in terms of the actual bug it was also a

367
00:15:20,290 --> 00:15:28,599
bug in RTP but what was interesting is

368
00:15:23,410 --> 00:15:29,920
this NSO group who wrote this spyware

369
00:15:28,600 --> 00:15:31,749
that was used a fully remote

370
00:15:29,920 --> 00:15:33,939
vulnerability they found a bug in

371
00:15:31,749 --> 00:15:36,550
signaling that made it so that when you

372
00:15:33,939 --> 00:15:37,459
started RTP the person would not need to

373
00:15:36,550 --> 00:15:40,130
pick up the

374
00:15:37,460 --> 00:15:42,890
so this made this vulnerability that I

375
00:15:40,130 --> 00:15:44,360
found where you would call the person

376
00:15:42,890 --> 00:15:46,160
they pick up the phone and then they'd

377
00:15:44,360 --> 00:15:47,660
have the problem to one where they could

378
00:15:46,160 --> 00:15:48,890
just call the person they wouldn't need

379
00:15:47,660 --> 00:15:50,600
to pick up the phone would and then it

380
00:15:48,890 --> 00:15:53,449
would cause the problem so this turned

381
00:15:50,600 --> 00:15:56,980
out to be a bug that not requiring any

382
00:15:53,450 --> 00:15:59,330
interaction and it was very serious and

383
00:15:56,980 --> 00:16:00,740
what was interesting about this is one

384
00:15:59,330 --> 00:16:03,650
of the most challenging things about

385
00:16:00,740 --> 00:16:05,960
this type of work is figuring out when

386
00:16:03,650 --> 00:16:08,660
to stop and this was a situation where

387
00:16:05,960 --> 00:16:10,610
you know I'd spent a mum and Thomas had

388
00:16:08,660 --> 00:16:12,589
spent a couple weeks on looking at the

389
00:16:10,610 --> 00:16:13,490
signalling and it got to the point where

390
00:16:12,590 --> 00:16:15,650
I was like oh I think I should probably

391
00:16:13,490 --> 00:16:17,270
move on there's nothing here and then

392
00:16:15,650 --> 00:16:19,550
that turned out not to be the case and

393
00:16:17,270 --> 00:16:22,689
that happens but it is one of the most

394
00:16:19,550 --> 00:16:25,729
challenging things in this type of work

395
00:16:22,690 --> 00:16:29,630
so one of the things I did afterwards

396
00:16:25,730 --> 00:16:31,940
was iMessage and unlike whatsapp the

397
00:16:29,630 --> 00:16:34,130
messaging features of iMessage are

398
00:16:31,940 --> 00:16:36,140
written in objective-c so there was a

399
00:16:34,130 --> 00:16:39,260
good potential for memory corruption

400
00:16:36,140 --> 00:16:41,000
vulnerabilities here I also looked at

401
00:16:39,260 --> 00:16:43,640
FaceTime which turned out to be an

402
00:16:41,000 --> 00:16:45,380
extremely large project so I won't talk

403
00:16:43,640 --> 00:16:48,050
about it today that would be the

404
00:16:45,380 --> 00:16:52,790
equivalent of whatsapp video

405
00:16:48,050 --> 00:16:55,579
conferencing on the iPhone but I'll talk

406
00:16:52,790 --> 00:16:58,280
a bit about what we found an iMessage

407
00:16:55,580 --> 00:17:01,610
and I want to mention that I worked with

408
00:16:58,280 --> 00:17:03,020
this with Samuel gross on my team so

409
00:17:01,610 --> 00:17:07,700
he's responsible for a lot of this work

410
00:17:03,020 --> 00:17:09,619
so um when he started off samuel wrote

411
00:17:07,700 --> 00:17:12,860
this iMessage sending an intercepting

412
00:17:09,619 --> 00:17:14,300
client and like with whatsapp it used

413
00:17:12,859 --> 00:17:16,069
frida but because it was a single

414
00:17:14,300 --> 00:17:19,599
message we didn't have to improve it any

415
00:17:16,069 --> 00:17:22,220
more than that we could just hook this

416
00:17:19,599 --> 00:17:24,379
hook the right spot and send and receive

417
00:17:22,220 --> 00:17:26,450
outgoing messages and we ended up

418
00:17:24,380 --> 00:17:29,360
hooking I think it was dictionary

419
00:17:26,450 --> 00:17:31,400
encoding and decoding because VI

420
00:17:29,360 --> 00:17:34,969
messages are a dictionary so it was a

421
00:17:31,400 --> 00:17:36,560
good spot so now that we could dump a

422
00:17:34,970 --> 00:17:39,170
messages here's what a message actually

423
00:17:36,560 --> 00:17:41,720
looked like and it's typically in what's

424
00:17:39,170 --> 00:17:44,360
called a binary plist format which is a

425
00:17:41,720 --> 00:17:47,480
compressed XML format but you can also

426
00:17:44,360 --> 00:17:48,919
expand it to regular XML and an iMessage

427
00:17:47,480 --> 00:17:50,600
is a dictionary

428
00:17:48,920 --> 00:17:53,960
you can see it has a lot of properties

429
00:17:50,600 --> 00:17:55,550
and here are some of what I thought were

430
00:17:53,960 --> 00:17:57,980
the important properties

431
00:17:55,550 --> 00:17:59,810
there's the plaintext message content

432
00:17:57,980 --> 00:18:01,970
which is like when you type hello hello

433
00:17:59,810 --> 00:18:04,940
goes in the T field but then there is

434
00:18:01,970 --> 00:18:06,380
this blue an identifier and bullet

435
00:18:04,940 --> 00:18:08,870
balloon data and this is for what's

436
00:18:06,380 --> 00:18:11,240
called plugins so if you have an iPhone

437
00:18:08,870 --> 00:18:12,409
and you open up iMessage for example

438
00:18:11,240 --> 00:18:14,930
there's this feature where you can talk

439
00:18:12,410 --> 00:18:17,450
like a giraffe right you if you point

440
00:18:14,930 --> 00:18:18,890
the camera at your face and you move

441
00:18:17,450 --> 00:18:20,420
your mouth within the giraffes mouth

442
00:18:18,890 --> 00:18:23,930
moves like your mouth and then you can

443
00:18:20,420 --> 00:18:26,510
hit Send and it's kind of fun so that's

444
00:18:23,930 --> 00:18:29,660
called an iMessage extension and these

445
00:18:26,510 --> 00:18:32,990
two fields deal with it the balloon

446
00:18:29,660 --> 00:18:34,160
identifier will tell the receiver what

447
00:18:32,990 --> 00:18:37,730
type of message it is so it'll say like

448
00:18:34,160 --> 00:18:39,950
I am a giraffe and then the plug-in data

449
00:18:37,730 --> 00:18:42,560
will be you know the actual giraffe

450
00:18:39,950 --> 00:18:45,200
video and so this was an interesting

451
00:18:42,560 --> 00:18:48,500
italic surface and then there's the ATI

452
00:18:45,200 --> 00:18:50,540
which is the tribute attribution info

453
00:18:48,500 --> 00:18:53,210
which is used if you happen to send

454
00:18:50,540 --> 00:18:56,620
attachment it has information about them

455
00:18:53,210 --> 00:18:58,640
and then there is the participants and

456
00:18:56,620 --> 00:19:01,189
the most interesting fields were

457
00:18:58,640 --> 00:19:02,600
actually this BP and ATI because it

458
00:19:01,190 --> 00:19:04,640
turned out that they usually contain

459
00:19:02,600 --> 00:19:08,990
serialized data and it was serialized

460
00:19:04,640 --> 00:19:11,990
using the nskeyedarchiver class and this

461
00:19:08,990 --> 00:19:14,210
serialization format is also a plist and

462
00:19:11,990 --> 00:19:16,130
it contains a dictionaries that have

463
00:19:14,210 --> 00:19:20,330
class properties and other properties

464
00:19:16,130 --> 00:19:23,090
and what happens is these objects are

465
00:19:20,330 --> 00:19:24,439
created by calling a method in the class

466
00:19:23,090 --> 00:19:26,209
called a net with coder which then

467
00:19:24,440 --> 00:19:28,580
processes other properties and

468
00:19:26,210 --> 00:19:31,700
specifically on these and it with coders

469
00:19:28,580 --> 00:19:35,050
have had several past bugs some of which

470
00:19:31,700 --> 00:19:37,490
were found by Ian beer on my team so

471
00:19:35,050 --> 00:19:42,470
here's how the serialization actually

472
00:19:37,490 --> 00:19:44,660
works so you can see on my right there

473
00:19:42,470 --> 00:19:47,240
are some properties there's a string and

474
00:19:44,660 --> 00:19:49,220
then there's this class dictionary which

475
00:19:47,240 --> 00:19:52,070
has the class hierarchy of this class

476
00:19:49,220 --> 00:19:54,170
called NS URL and then on the right is

477
00:19:52,070 --> 00:19:57,830
the actual or on my left is the actual

478
00:19:54,170 --> 00:20:00,100
object so you can see there's this class

479
00:19:57,830 --> 00:20:01,449
that refers to this class hierarchy

480
00:20:00,100 --> 00:20:03,219
and then there's the NSPS and the

481
00:20:01,450 --> 00:20:06,010
relative which are actually the contents

482
00:20:03,220 --> 00:20:07,570
of the URL and you can see the relative

483
00:20:06,010 --> 00:20:10,419
is number six which points to this

484
00:20:07,570 --> 00:20:12,010
string which is now - encode CA so

485
00:20:10,419 --> 00:20:14,020
what'll happen is when this gets

486
00:20:12,010 --> 00:20:16,480
decoding it'll say oh this is an nsurl

487
00:20:14,020 --> 00:20:18,910
and then it will call nsurl and it with

488
00:20:16,480 --> 00:20:20,620
coder and then that will pull these base

489
00:20:18,910 --> 00:20:24,520
and relative properties and use them to

490
00:20:20,620 --> 00:20:26,979
initialize the URL so the serialization

491
00:20:24,520 --> 00:20:30,160
mass messaging does have some security

492
00:20:26,980 --> 00:20:33,370
features and a secure coding has two

493
00:20:30,160 --> 00:20:35,110
requirements one is that if you write

494
00:20:33,370 --> 00:20:37,539
ending it with code or implementation

495
00:20:35,110 --> 00:20:41,260
you also have to inherit another method

496
00:20:37,539 --> 00:20:42,908
and what this does is it will make it so

497
00:20:41,260 --> 00:20:44,620
that you can't accidentally create an

498
00:20:42,909 --> 00:20:48,039
init with coder you have to have on

499
00:20:44,620 --> 00:20:51,129
purpose exposed it the other thing is

500
00:20:48,039 --> 00:20:54,190
that it requires you to provide a list

501
00:20:51,130 --> 00:20:56,110
of allowed classes so at no point in to

502
00:20:54,190 --> 00:20:58,450
serialization can you say I wanted to

503
00:20:56,110 --> 00:20:59,168
code anything you have to say I wanted

504
00:20:58,450 --> 00:21:01,990
to go to URL

505
00:20:59,169 --> 00:21:03,580
I wanted to code a URL or an array you

506
00:21:01,990 --> 00:21:07,150
can have a long list but you can't have

507
00:21:03,580 --> 00:21:09,879
nothing so what's unfortunate is that

508
00:21:07,150 --> 00:21:12,070
this isn't mandatory you can create a

509
00:21:09,880 --> 00:21:14,530
safety serialization which require is

510
00:21:12,070 --> 00:21:17,080
secure coding or you can create unsafe -

511
00:21:14,530 --> 00:21:18,840
serialization and unfortunately some of

512
00:21:17,080 --> 00:21:21,730
these methods are hard to tell apart

513
00:21:18,840 --> 00:21:23,020
like you're totally gonna remember which

514
00:21:21,730 --> 00:21:26,710
one of these is safe and which one of

515
00:21:23,020 --> 00:21:28,870
these is unsafe at like all times so our

516
00:21:26,710 --> 00:21:31,169
first idea is we thought you know

517
00:21:28,870 --> 00:21:35,889
someone has to have picked the wrong one

518
00:21:31,169 --> 00:21:39,070
so we tried to figure out where -

519
00:21:35,890 --> 00:21:40,990
serialization happened I think the most

520
00:21:39,070 --> 00:21:43,720
interesting one was in springboard which

521
00:21:40,990 --> 00:21:47,559
is the UI of the iPhone and it DC

522
00:21:43,720 --> 00:21:50,200
realizes this BP field for previews also

523
00:21:47,559 --> 00:21:53,020
if it's an extension and based on that

524
00:21:50,200 --> 00:21:55,090
extension type it can also call a custom

525
00:21:53,020 --> 00:21:58,720
method called preview text on it which

526
00:21:55,090 --> 00:22:00,908
is even more attack surface it can all

527
00:21:58,720 --> 00:22:03,070
this some same field is - serialized in

528
00:22:00,909 --> 00:22:04,809
mobile SMS but this requires one-click

529
00:22:03,070 --> 00:22:07,899
you actually have to open the SMS and

530
00:22:04,809 --> 00:22:09,570
then also this ATI field is to serialize

531
00:22:07,900 --> 00:22:13,380
using the same decoding

532
00:22:09,570 --> 00:22:15,270
a TI and we decided to focus on the BP

533
00:22:13,380 --> 00:22:17,850
and springboard just because that had

534
00:22:15,270 --> 00:22:22,050
the large number of classes allowed as

535
00:22:17,850 --> 00:22:25,020
well as it had high privileges so we

536
00:22:22,050 --> 00:22:28,350
started off trying to find this insecure

537
00:22:25,020 --> 00:22:30,360
deserialization code call and despite

538
00:22:28,350 --> 00:22:33,030
the confusing names we looked at all the

539
00:22:30,360 --> 00:22:35,250
springboard and all of IMS agent and did

540
00:22:33,030 --> 00:22:38,310
not find a single insecure call so that

541
00:22:35,250 --> 00:22:40,590
was good so then we decided let's look

542
00:22:38,310 --> 00:22:43,260
at these extensions the ones that can do

543
00:22:40,590 --> 00:22:47,159
previews and see if there's any misuse

544
00:22:43,260 --> 00:22:49,140
there and there was this one bug it's

545
00:22:47,160 --> 00:22:51,000
not a very high quality bug I think it's

546
00:22:49,140 --> 00:22:52,770
unlikely that an attacker could ever do

547
00:22:51,000 --> 00:22:55,980
anything useful with it but it was just

548
00:22:52,770 --> 00:22:57,750
sort of interesting it would just you

549
00:22:55,980 --> 00:22:59,730
realize some byte arrays and then it

550
00:22:57,750 --> 00:23:00,870
would to serialize a separate length but

551
00:22:59,730 --> 00:23:02,370
that length was not actually too

552
00:23:00,870 --> 00:23:06,689
guaranteed to be the length of the byte

553
00:23:02,370 --> 00:23:10,260
array so it could read out of bounds so

554
00:23:06,690 --> 00:23:12,030
we also had this idea let's look at the

555
00:23:10,260 --> 00:23:14,640
link presentation layer link

556
00:23:12,030 --> 00:23:17,670
presentation is if you send a link in

557
00:23:14,640 --> 00:23:19,710
iMessage and you'll get a preview on the

558
00:23:17,670 --> 00:23:22,140
other side and this is actually a fairly

559
00:23:19,710 --> 00:23:24,000
good design in that all the risk of

560
00:23:22,140 --> 00:23:26,760
sending the link is taken by the person

561
00:23:24,000 --> 00:23:28,560
who sends the link you send the link you

562
00:23:26,760 --> 00:23:31,320
are a version of iMessage loads it in

563
00:23:28,560 --> 00:23:33,510
WebKit will pull out an image pull out

564
00:23:31,320 --> 00:23:36,060
the title and then send that to the

565
00:23:33,510 --> 00:23:38,160
receiver so the receiver is not actually

566
00:23:36,060 --> 00:23:40,409
pulling that link unless they click that

567
00:23:38,160 --> 00:23:41,850
link which is good but you're hoping

568
00:23:40,410 --> 00:23:43,680
that you know maybe if we send some

569
00:23:41,850 --> 00:23:45,990
really malformed stuff there was a way

570
00:23:43,680 --> 00:23:51,000
to trick it into opening the WebKit

571
00:23:45,990 --> 00:23:52,680
instance on the receiver side and we

572
00:23:51,000 --> 00:23:54,690
looked and looked and looked at this and

573
00:23:52,680 --> 00:23:56,550
we couldn't get it to work and the

574
00:23:54,690 --> 00:23:58,560
reason this would have been a good bug

575
00:23:56,550 --> 00:24:01,169
is because I'm WebKit Explorer

576
00:23:58,560 --> 00:24:02,850
exploitation is well know there's lots

577
00:24:01,170 --> 00:24:04,590
of bugs in WebKit I people know how to

578
00:24:02,850 --> 00:24:07,320
exploit them so this would have been

579
00:24:04,590 --> 00:24:10,679
like an easy way to do an exploit on

580
00:24:07,320 --> 00:24:13,919
iMessage but unfortunately yeah we

581
00:24:10,680 --> 00:24:16,920
couldn't find any bugs like this so then

582
00:24:13,920 --> 00:24:18,990
we decided let's look at all the in it

583
00:24:16,920 --> 00:24:20,730
with coders they've had bugs in them

584
00:24:18,990 --> 00:24:22,900
before you know they might have bugs in

585
00:24:20,730 --> 00:24:24,880
them again and

586
00:24:22,900 --> 00:24:27,250
made us have to figure out what didn't

587
00:24:24,880 --> 00:24:31,570
it with Co tourism could we actually hit

588
00:24:27,250 --> 00:24:33,820
and for um springboard this was the full

589
00:24:31,570 --> 00:24:36,129
list I won't read them out but it's you

590
00:24:33,820 --> 00:24:38,290
know typical classes like string and

591
00:24:36,130 --> 00:24:41,560
data and number but what's also

592
00:24:38,290 --> 00:24:43,810
interesting is that any subclasses of

593
00:24:41,560 --> 00:24:46,899
these classes that have an it with coder

594
00:24:43,810 --> 00:24:47,889
implemented are also available for

595
00:24:46,900 --> 00:24:50,080
deserialization

596
00:24:47,890 --> 00:24:53,590
and the way these end up being available

597
00:24:50,080 --> 00:24:55,659
is any library you import or DL open

598
00:24:53,590 --> 00:24:59,050
becomes part of what's available and

599
00:24:55,660 --> 00:24:59,800
it's not the whole shared cache but if

600
00:24:59,050 --> 00:25:02,200
you can think about something like

601
00:24:59,800 --> 00:25:04,210
springboard it imports like dozens and

602
00:25:02,200 --> 00:25:06,430
dozens of libraries so that means that

603
00:25:04,210 --> 00:25:11,470
there were many many subclasses of all

604
00:25:06,430 --> 00:25:15,070
these classes so um looking at this one

605
00:25:11,470 --> 00:25:18,850
bug we found was in de si realizing a

606
00:25:15,070 --> 00:25:20,950
URL so pretty much missing it with coder

607
00:25:18,850 --> 00:25:23,740
supports several decoding methodologies

608
00:25:20,950 --> 00:25:25,750
and one was a byte array that was a book

609
00:25:23,740 --> 00:25:27,220
bookmark and then it turned out that

610
00:25:25,750 --> 00:25:29,110
this bookmark was in its own

611
00:25:27,220 --> 00:25:31,450
serialization format but it's different

612
00:25:29,110 --> 00:25:34,810
than the one I described and that one

613
00:25:31,450 --> 00:25:36,190
had a heap overflow in it and what I

614
00:25:34,810 --> 00:25:39,010
thought was interesting about this bug

615
00:25:36,190 --> 00:25:41,140
is that bookmarks whenever legitimately

616
00:25:39,010 --> 00:25:43,120
used by iMessage if you're sending a

617
00:25:41,140 --> 00:25:45,040
link an iMessage it is a string it is

618
00:25:43,120 --> 00:25:47,350
not a bookmark but because of how the

619
00:25:45,040 --> 00:26:01,060
serialization is a general library and

620
00:25:47,350 --> 00:26:03,189
it has to be able to deserialization s

621
00:26:01,060 --> 00:26:06,460
theta subclass and it could actually

622
00:26:03,190 --> 00:26:08,170
pull files off of your device remotely

623
00:26:06,460 --> 00:26:11,500
which I thought was actually pretty wild

624
00:26:08,170 --> 00:26:16,360
for a single bug like this so basically

625
00:26:11,500 --> 00:26:18,940
there's this class which is NS data file

626
00:26:16,360 --> 00:26:21,300
back future which subclasses NS data and

627
00:26:18,940 --> 00:26:25,170
what this is supposed to do

628
00:26:21,300 --> 00:26:28,110
it will fill a buffer with a file late

629
00:26:25,170 --> 00:26:31,320
so it will wait until you access it to

630
00:26:28,110 --> 00:26:33,870
load the file so this class actually had

631
00:26:31,320 --> 00:26:35,909
two problems one was when it would to

632
00:26:33,870 --> 00:26:37,830
serialize a length and not check the

633
00:26:35,910 --> 00:26:40,560
length of the file so it's some similar

634
00:26:37,830 --> 00:26:41,790
problem to that digital touch bug where

635
00:26:40,560 --> 00:26:44,879
it could go out of bounds because I

636
00:26:41,790 --> 00:26:48,240
trusted the length but what was more

637
00:26:44,880 --> 00:26:50,220
interesting is you could bypass the

638
00:26:48,240 --> 00:26:52,260
check that the URL was local so this was

639
00:26:50,220 --> 00:26:54,390
intended you would load a local file and

640
00:26:52,260 --> 00:26:57,120
they test tested but this is a local

641
00:26:54,390 --> 00:27:00,270
file but you could put in like kind of a

642
00:26:57,120 --> 00:27:01,709
slightly malformed URL and say actually

643
00:27:00,270 --> 00:27:04,620
I want to pull that file from a server

644
00:27:01,710 --> 00:27:07,170
and it would and the reason this became

645
00:27:04,620 --> 00:27:10,080
a problem is now this lets you pull

646
00:27:07,170 --> 00:27:13,320
files because you create this data with

647
00:27:10,080 --> 00:27:15,179
the local file and then I'm gonna gloss

648
00:27:13,320 --> 00:27:19,230
over this a bit but there's a way you

649
00:27:15,180 --> 00:27:23,910
can convert an NS data to an nsurl with

650
00:27:19,230 --> 00:27:25,470
the whole file URL encoded so you would

651
00:27:23,910 --> 00:27:27,090
just append this to the end of the URL

652
00:27:25,470 --> 00:27:29,370
as a parameter and then you would use

653
00:27:27,090 --> 00:27:30,720
this bug again and visit that URL and

654
00:27:29,370 --> 00:27:35,370
that means that all the contents of that

655
00:27:30,720 --> 00:27:39,570
file would I go to your server so we

656
00:27:35,370 --> 00:27:41,909
wanted to keep looking though so uh we

657
00:27:39,570 --> 00:27:44,909
had another idea which is wait a sec so

658
00:27:41,910 --> 00:27:47,100
there's all these inheritances that that

659
00:27:44,910 --> 00:27:50,070
implementing it with coder but what if

660
00:27:47,100 --> 00:27:52,740
they don't and it turns out that regular

661
00:27:50,070 --> 00:27:54,510
inheritance rules apply so let's say you

662
00:27:52,740 --> 00:27:56,580
have an it with coder that you know

663
00:27:54,510 --> 00:27:58,770
pulls out a bunch of objects and then

664
00:27:56,580 --> 00:28:02,189
calls in it with capacity if you have a

665
00:27:58,770 --> 00:28:04,920
subclass that that defines in it with

666
00:28:02,190 --> 00:28:08,130
capacity that will get called and that's

667
00:28:04,920 --> 00:28:09,960
even I think harder to visualize than

668
00:28:08,130 --> 00:28:11,940
the end it with coder I think if someone

669
00:28:09,960 --> 00:28:14,280
creates a class within it with capacity

670
00:28:11,940 --> 00:28:15,270
and a library they are not imagining

671
00:28:14,280 --> 00:28:19,260
that that's going to be part of the

672
00:28:15,270 --> 00:28:21,090
remote attack surface but it is so there

673
00:28:19,260 --> 00:28:23,010
are some direct inheritance checks so

674
00:28:21,090 --> 00:28:24,360
there are a few classes in serialization

675
00:28:23,010 --> 00:28:27,690
that actually directly check but you

676
00:28:24,360 --> 00:28:30,899
don't do this but most of them don't so

677
00:28:27,690 --> 00:28:32,600
here's the bug we found this was in a

678
00:28:30,900 --> 00:28:34,580
class called PF array

679
00:28:32,600 --> 00:28:38,330
and it defined it with objects count

680
00:28:34,580 --> 00:28:40,909
which is a classic way to define an

681
00:28:38,330 --> 00:28:42,139
array but unfortunately this array I

682
00:28:40,910 --> 00:28:44,900
don't know what it's supposed to be used

683
00:28:42,140 --> 00:28:46,760
for but it doesn't create references to

684
00:28:44,900 --> 00:28:49,070
the objects in this array I'm assuming

685
00:28:46,760 --> 00:28:52,070
it's used in some context only where

686
00:28:49,070 --> 00:28:54,379
they already have references but because

687
00:28:52,070 --> 00:28:56,120
this was a subclass and the NS in it

688
00:28:54,380 --> 00:28:58,520
with array in it with coder called this

689
00:28:56,120 --> 00:29:00,469
method on this subclass that would get

690
00:28:58,520 --> 00:29:04,030
called and created this a reference free

691
00:29:00,470 --> 00:29:06,980
array and then when these objects were

692
00:29:04,030 --> 00:29:08,330
freed or when the last reference was

693
00:29:06,980 --> 00:29:12,590
dropped they would still be in the array

694
00:29:08,330 --> 00:29:15,020
and this was a use after free so that

695
00:29:12,590 --> 00:29:17,689
was one fun bug and we found out another

696
00:29:15,020 --> 00:29:19,520
similar one that I won't go through but

697
00:29:17,690 --> 00:29:20,810
then we started thinking even more about

698
00:29:19,520 --> 00:29:24,050
this deserialization

699
00:29:20,810 --> 00:29:24,590
for example what if an object has cycles

700
00:29:24,050 --> 00:29:27,490
in it

701
00:29:24,590 --> 00:29:30,470
like I showed you that example with the

702
00:29:27,490 --> 00:29:32,210
nsurl dot base that was six which

703
00:29:30,470 --> 00:29:33,560
referred to the string what if it

704
00:29:32,210 --> 00:29:37,430
doesn't refer to the string what if it

705
00:29:33,560 --> 00:29:40,010
refers to itself and the answer is it's

706
00:29:37,430 --> 00:29:42,410
complicated so here's how to

707
00:29:40,010 --> 00:29:43,970
serialization actually works let's say

708
00:29:42,410 --> 00:29:45,560
you know you've pulled out the P list

709
00:29:43,970 --> 00:29:48,650
and you know you're trying to decode and

710
00:29:45,560 --> 00:29:51,350
s some class what it will do is it will

711
00:29:48,650 --> 00:29:53,600
Alec that class and then it will add it

712
00:29:51,350 --> 00:29:55,550
to a temporary dictionary which has no

713
00:29:53,600 --> 00:29:57,590
references it just stores the pointer

714
00:29:55,550 --> 00:30:00,350
and then it will call in it with coder

715
00:29:57,590 --> 00:30:02,540
on the object then it will remove this

716
00:30:00,350 --> 00:30:03,919
from the temporary dictionary then it

717
00:30:02,540 --> 00:30:06,800
will add it to a permanent dictionary

718
00:30:03,920 --> 00:30:08,510
and return it now what happens if you

719
00:30:06,800 --> 00:30:12,020
try and retrieve this object a second

720
00:30:08,510 --> 00:30:14,090
time well it will pull it on a temporary

721
00:30:12,020 --> 00:30:15,620
dictionary if possible otherwise it will

722
00:30:14,090 --> 00:30:18,169
pull it out of the permanent dictionary

723
00:30:15,620 --> 00:30:19,820
and then if that doesn't work then you

724
00:30:18,170 --> 00:30:21,970
actually have an instantiated this yet

725
00:30:19,820 --> 00:30:25,669
and you go through the regular process

726
00:30:21,970 --> 00:30:27,530
so there's two problems one is that an

727
00:30:25,670 --> 00:30:29,660
object could be used before the Indian

728
00:30:27,530 --> 00:30:31,850
with coder is complete you can imagine

729
00:30:29,660 --> 00:30:33,860
with this if it's pulled another

730
00:30:31,850 --> 00:30:36,409
temporary dictionary from the Annette

731
00:30:33,860 --> 00:30:38,510
with coder itself stuff could not be

732
00:30:36,410 --> 00:30:40,640
initialized because you're still in the

733
00:30:38,510 --> 00:30:42,740
middle of initializing it the first time

734
00:30:40,640 --> 00:30:46,190
and then there's this other problem

735
00:30:42,740 --> 00:30:48,290
which is if you read the documentation

736
00:30:46,190 --> 00:30:50,450
any type of a net function including an

737
00:30:48,290 --> 00:30:53,659
it with coder is not guaranteed to

738
00:30:50,450 --> 00:30:56,540
return the object created by alec you

739
00:30:53,660 --> 00:30:59,060
provided as a parameter and then it can

740
00:30:56,540 --> 00:31:01,100
release it or it can create an own

741
00:30:59,060 --> 00:31:03,290
object or it can return it and that's

742
00:31:01,100 --> 00:31:05,719
the functions choice so you can imagine

743
00:31:03,290 --> 00:31:07,760
a decoder where it immediately freeze

744
00:31:05,720 --> 00:31:09,410
this object and then start some decoding

745
00:31:07,760 --> 00:31:13,190
stuff and then that stuff wouldn't have

746
00:31:09,410 --> 00:31:14,930
any references to it I've never actually

747
00:31:13,190 --> 00:31:17,360
seen it bug like this but it's something

748
00:31:14,930 --> 00:31:19,670
that you know bothers me a bit because

749
00:31:17,360 --> 00:31:22,310
even if things are written as they're

750
00:31:19,670 --> 00:31:26,030
designed in the documentation this could

751
00:31:22,310 --> 00:31:27,500
lead to use after freeze so um most of

752
00:31:26,030 --> 00:31:30,139
the problems we found though we're due

753
00:31:27,500 --> 00:31:32,390
to that first problem so this one

754
00:31:30,140 --> 00:31:34,700
unfortunately the fix that Apple issue

755
00:31:32,390 --> 00:31:37,220
did not fully resolve the issue

756
00:31:34,700 --> 00:31:39,920
so I've removed info about the bug a bit

757
00:31:37,220 --> 00:31:42,080
so basically it is in a class that I

758
00:31:39,920 --> 00:31:45,980
won't name and the problem with this

759
00:31:42,080 --> 00:31:48,530
class is that it decodes a linked list

760
00:31:45,980 --> 00:31:50,480
and then based on that linked list it

761
00:31:48,530 --> 00:31:52,100
will create a buffer and then it will

762
00:31:50,480 --> 00:31:54,530
put the stuff from the linked list into

763
00:31:52,100 --> 00:31:56,600
the buffer but then if you have a cycle

764
00:31:54,530 --> 00:31:58,250
in it what will happen is you can create

765
00:31:56,600 --> 00:32:00,020
a situation where you know it's creating

766
00:31:58,250 --> 00:32:02,360
the linked list and then it grabs the

767
00:32:00,020 --> 00:32:04,340
object itself which forces it to create

768
00:32:02,360 --> 00:32:06,320
the buffer but then when you use the

769
00:32:04,340 --> 00:32:09,470
object more things have been added to

770
00:32:06,320 --> 00:32:11,659
the linked list and then this buffer is

771
00:32:09,470 --> 00:32:15,650
too short and stuff gets written in are

772
00:32:11,660 --> 00:32:18,230
read out of bounds and just in case

773
00:32:15,650 --> 00:32:21,080
you're ever wondering how I do this

774
00:32:18,230 --> 00:32:23,840
I I spent about eight hours drawing

775
00:32:21,080 --> 00:32:25,250
diagrams like this and writing XML to

776
00:32:23,840 --> 00:32:27,230
make this object that actually caused

777
00:32:25,250 --> 00:32:28,910
this crash it was not that simple and

778
00:32:27,230 --> 00:32:33,410
the most important part is that arrow

779
00:32:28,910 --> 00:32:34,880
that says bad but yeah you know people

780
00:32:33,410 --> 00:32:39,380
ask me why would you have a good way to

781
00:32:34,880 --> 00:32:41,990
do this and the answer is no so here's

782
00:32:39,380 --> 00:32:43,850
another bug that was like this this was

783
00:32:41,990 --> 00:32:46,010
in a class called pennis no keys

784
00:32:43,850 --> 00:32:48,080
dictionary one which is one of those

785
00:32:46,010 --> 00:32:50,360
classes where you have to declare all

786
00:32:48,080 --> 00:32:52,370
the keys in the dictionary first and you

787
00:32:50,360 --> 00:32:55,340
get a lot of performance benefit in

788
00:32:52,370 --> 00:32:57,169
exchange for doing that and in this one

789
00:32:55,340 --> 00:32:58,749
you provide all the keys and then you've

790
00:32:57,170 --> 00:33:00,789
read the link that

791
00:32:58,749 --> 00:33:03,849
which doesn't have to be consistent and

792
00:33:00,789 --> 00:33:06,129
this one it actually does check that it

793
00:33:03,849 --> 00:33:08,019
is consistent but it checks too late it

794
00:33:06,129 --> 00:33:09,879
will to serialize the length that will

795
00:33:08,019 --> 00:33:11,319
decir lies the buffer and then it will

796
00:33:09,879 --> 00:33:13,059
to serialize other stuff that allows you

797
00:33:11,319 --> 00:33:15,188
to deserialize this again and at which

798
00:33:13,059 --> 00:33:16,749
point you can now use the object even

799
00:33:15,189 --> 00:33:22,629
though this check hasn't been performed

800
00:33:16,749 --> 00:33:26,049
yet and this was basically a consistency

801
00:33:22,629 --> 00:33:28,708
problem and basically they they fixed it

802
00:33:26,049 --> 00:33:31,389
pretty much by doing the check earlier

803
00:33:28,709 --> 00:33:34,299
so you might wonder why are there so

804
00:33:31,389 --> 00:33:37,359
many bikes in this and here's the

805
00:33:34,299 --> 00:33:40,359
problem let's say you wanted to

806
00:33:37,359 --> 00:33:42,609
serialize a URL just one object one URL

807
00:33:40,359 --> 00:33:43,958
what's the attack surface what are all

808
00:33:42,609 --> 00:33:46,299
the things that could have bugs in it

809
00:33:43,959 --> 00:33:48,549
well I think the first problem is it

810
00:33:46,299 --> 00:33:50,649
depends a lot on how you compile this it

811
00:33:48,549 --> 00:33:52,869
depends on what frameworks you include

812
00:33:50,649 --> 00:33:54,879
in compilation and for this example

813
00:33:52,869 --> 00:33:58,478
let's say you just included one

814
00:33:54,879 --> 00:34:01,299
framework user notifications well then

815
00:33:58,479 --> 00:34:03,519
your attack surface is obviously nsurl

816
00:34:01,299 --> 00:34:05,229
Annette with coder and then if you have

817
00:34:03,519 --> 00:34:07,209
any subclasses in your application

818
00:34:05,229 --> 00:34:09,639
that's calling this then that in it with

819
00:34:07,209 --> 00:34:12,190
coder is in the italic surface but also

820
00:34:09,639 --> 00:34:15,849
in that framework you included if it

821
00:34:12,190 --> 00:34:18,579
ever subclasses URL NS URL that is also

822
00:34:15,849 --> 00:34:21,549
in your italic surface but then there's

823
00:34:18,579 --> 00:34:24,309
more so what does this NS URL and it

824
00:34:21,549 --> 00:34:26,079
with coder actually do well as I said

825
00:34:24,309 --> 00:34:28,450
there are two options it could decode a

826
00:34:26,079 --> 00:34:30,609
bookmark in which case it will decode

827
00:34:28,449 --> 00:34:32,799
this data or it could decode some

828
00:34:30,609 --> 00:34:35,319
strings in which case it will use the

829
00:34:32,799 --> 00:34:37,629
strings to initialize the URL so to

830
00:34:35,319 --> 00:34:41,349
start off this bookmark to codings in

831
00:34:37,629 --> 00:34:43,598
the attack surface but also all those

832
00:34:41,349 --> 00:34:46,059
types that were just decoded all their

833
00:34:43,599 --> 00:34:48,429
subclasses are now in the italic surface

834
00:34:46,059 --> 00:34:50,679
so now you have this Janus dispatch data

835
00:34:48,429 --> 00:34:52,629
all these string types including an

836
00:34:50,679 --> 00:34:56,769
extra string type that was in this user

837
00:34:52,629 --> 00:34:59,739
notification framework and then you have

838
00:34:56,768 --> 00:35:01,689
to continue down right all of these

839
00:34:59,739 --> 00:35:03,549
subclasses will also to code other

840
00:35:01,690 --> 00:35:05,829
classes so there's NS array and s

841
00:35:03,549 --> 00:35:07,450
dictionary NS date NS number and then

842
00:35:05,829 --> 00:35:08,930
those will have subclasses and this

843
00:35:07,450 --> 00:35:10,970
keeps going down and down in

844
00:35:08,930 --> 00:35:14,359
until you have this huge attack surface

845
00:35:10,970 --> 00:35:17,419
but also there's this thing with the

846
00:35:14,360 --> 00:35:18,890
inheritance so you use any ellipse

847
00:35:17,420 --> 00:35:20,510
string and the string in it with coder

848
00:35:18,890 --> 00:35:22,549
so now all these and needless strings

849
00:35:20,510 --> 00:35:24,650
are in the attack surface and when you

850
00:35:22,550 --> 00:35:26,120
decode data you end it with byte so now

851
00:35:24,650 --> 00:35:29,810
all these in yet with bytes are in the

852
00:35:26,120 --> 00:35:31,250
attack surface and you can imagine this

853
00:35:29,810 --> 00:35:33,920
for every class and every in it with

854
00:35:31,250 --> 00:35:37,160
coder and I think the worst thing here

855
00:35:33,920 --> 00:35:40,850
is that legitimate URLs certainly

856
00:35:37,160 --> 00:35:42,830
contain one string right almost all of

857
00:35:40,850 --> 00:35:45,680
these features are never used except for

858
00:35:42,830 --> 00:35:48,290
the string and imagine how much worse

859
00:35:45,680 --> 00:35:50,600
this gets for a large project imagine

860
00:35:48,290 --> 00:35:53,330
adding a few extra classes that are

861
00:35:50,600 --> 00:35:55,610
allowed maybe not just a URL imagine

862
00:35:53,330 --> 00:35:58,279
importing a few more libraries imagine

863
00:35:55,610 --> 00:36:00,650
importing like 40 libraries as many

864
00:35:58,280 --> 00:36:02,540
applications will do and imagine being a

865
00:36:00,650 --> 00:36:04,340
developer trying to secure this imagine

866
00:36:02,540 --> 00:36:06,620
being a third-party developer not

867
00:36:04,340 --> 00:36:08,330
knowing what the subclass is in those

868
00:36:06,620 --> 00:36:09,799
libraries are because this doesn't just

869
00:36:08,330 --> 00:36:13,940
include public classes it includes

870
00:36:09,800 --> 00:36:16,130
private classes so my opinion is that

871
00:36:13,940 --> 00:36:18,620
securing this interface is an

872
00:36:16,130 --> 00:36:20,500
intractable problem there are too many

873
00:36:18,620 --> 00:36:23,540
inter dependencies between unrelated

874
00:36:20,500 --> 00:36:25,160
components you can have you know one

875
00:36:23,540 --> 00:36:26,300
class from one library containing a

876
00:36:25,160 --> 00:36:28,040
property that's another class from

877
00:36:26,300 --> 00:36:30,920
another library that was never meant to

878
00:36:28,040 --> 00:36:33,620
go together but requires full knowledge

879
00:36:30,920 --> 00:36:35,570
of all other components to understand

880
00:36:33,620 --> 00:36:37,310
the attack surface and it makes small

881
00:36:35,570 --> 00:36:39,950
changes to low-risk components have

882
00:36:37,310 --> 00:36:41,570
unexpected consequences I don't think

883
00:36:39,950 --> 00:36:43,370
any of these bugs happened because

884
00:36:41,570 --> 00:36:45,140
someone knowing that this was part of

885
00:36:43,370 --> 00:36:47,330
iMessage decided to add these features

886
00:36:45,140 --> 00:36:49,279
and make them available what happened

887
00:36:47,330 --> 00:36:51,560
was that someone made a change to the

888
00:36:49,280 --> 00:36:52,880
calculator which is local and then they

889
00:36:51,560 --> 00:36:54,320
needed to add two numbers then they

890
00:36:52,880 --> 00:36:55,970
imported the calculator and then

891
00:36:54,320 --> 00:36:58,760
suddenly that became a part of the

892
00:36:55,970 --> 00:37:04,209
remote attack surface so now I'm going

893
00:36:58,760 --> 00:37:05,780
to show a few demos you should be fun

894
00:37:04,210 --> 00:37:09,110
because I'm using someone else's

895
00:37:05,780 --> 00:37:11,440
computer sure I will request access to

896
00:37:09,110 --> 00:37:11,440
this

897
00:37:48,260 --> 00:37:51,369
yes I am sure

898
00:38:10,940 --> 00:38:16,819
there we go hopefully that works up so

899
00:38:14,030 --> 00:38:18,559
this is the demo of pulling the file and

900
00:38:16,819 --> 00:38:23,359
this unfortunately is very low

901
00:38:18,559 --> 00:38:27,010
production value so you've got you I'm

902
00:38:23,359 --> 00:38:27,009
showing you the image right now and

903
00:38:27,280 --> 00:38:32,750
what's happening here is I'm going to

904
00:38:30,109 --> 00:38:34,220
show you what the image is and then I'm

905
00:38:32,750 --> 00:38:43,640
going to send a message that pulls this

906
00:38:34,220 --> 00:38:44,990
image off of the remote device so so

907
00:38:43,640 --> 00:38:46,700
I'll start off by sending the message

908
00:38:44,990 --> 00:38:49,629
and then it will take a few seconds for

909
00:38:46,700 --> 00:38:49,629
this message to arrive

910
00:39:17,600 --> 00:39:22,279
yeah I think so the reason this takes so

911
00:39:19,490 --> 00:39:24,379
long is because unfortunately the way

912
00:39:22,280 --> 00:39:26,270
that I decoded the URL it requires you

913
00:39:24,380 --> 00:39:29,360
to send a URL that is equal in size to

914
00:39:26,270 --> 00:39:31,910
the file you get back I'm limited this

915
00:39:29,360 --> 00:39:33,770
is about 40 kilobytes so it's kind of

916
00:39:31,910 --> 00:39:35,540
slow to arrive but it does work and is

917
00:39:33,770 --> 00:39:37,580
enough to retrieve things like images

918
00:39:35,540 --> 00:39:39,620
and you know see a few messages and that

919
00:39:37,580 --> 00:39:47,450
sort of thing so now this is my server

920
00:39:39,620 --> 00:39:51,650
and and you can see that it's getting

921
00:39:47,450 --> 00:39:53,330
this URL and then this is pre-prepared

922
00:39:51,650 --> 00:39:54,860
I didn't want to do the thing where I

923
00:39:53,330 --> 00:39:57,049
was with videoing with one hand and then

924
00:39:54,860 --> 00:39:58,190
typing the link within my left hand so

925
00:39:57,050 --> 00:40:00,350
you'll see I'll send a pre-prepared

926
00:39:58,190 --> 00:40:01,700
message that had this link in it but if

927
00:40:00,350 --> 00:40:02,810
you were setting up a real framework to

928
00:40:01,700 --> 00:40:04,759
this you would have it somehow

929
00:40:02,810 --> 00:40:06,680
transmitted chadzmuth the link and then

930
00:40:04,760 --> 00:40:08,240
put the correct link in so now I'm

931
00:40:06,680 --> 00:40:11,410
sending a second message that actually

932
00:40:08,240 --> 00:40:11,410
dumps the image

933
00:40:53,590 --> 00:40:56,620
that's funny this is a video and I'm

934
00:40:55,330 --> 00:40:58,270
still a little nervous about whether

935
00:40:56,620 --> 00:41:06,940
it's going to arrive every time I watch

936
00:40:58,270 --> 00:41:08,890
it so there we go I think we got the

937
00:41:06,940 --> 00:41:11,520
message and it's gonna start sending the

938
00:41:08,890 --> 00:41:11,520
image soon

939
00:41:33,420 --> 00:41:36,470
there we go

940
00:41:46,900 --> 00:41:51,790
so you can see there's the image

941
00:41:49,600 --> 00:41:53,049
starting to arrive and then what I have

942
00:41:51,790 --> 00:41:54,970
to do is I have to download this buffer

943
00:41:53,050 --> 00:41:58,570
and decode it unfortunately the way I

944
00:41:54,970 --> 00:42:00,549
encoded the URL ended up being very very

945
00:41:58,570 --> 00:42:03,820
interesting so I ended up just writing a

946
00:42:00,550 --> 00:42:05,830
separate Python script and decoding it

947
00:42:03,820 --> 00:42:09,840
so I'll basically just download this

948
00:42:05,830 --> 00:42:09,840
buffer and then run the script

949
00:42:24,040 --> 00:42:31,220
there we go running it and then I guess

950
00:42:29,240 --> 00:42:37,879
I hopefully it'll just load the image

951
00:42:31,220 --> 00:42:45,230
but no it is buffering again and there

952
00:42:37,880 --> 00:42:47,450
we go there's the image yay and then I

953
00:42:45,230 --> 00:42:52,819
have one word more demo that's a little

954
00:42:47,450 --> 00:42:56,680
bit a little bit faster thankfully I'm

955
00:42:52,819 --> 00:43:00,220
gonna request permission for it before I

956
00:42:56,680 --> 00:43:00,220
show it to you

957
00:43:10,250 --> 00:43:14,780
so this one's actually quite exciting so

958
00:43:13,160 --> 00:43:16,609
I gave a similar talk at blackhat and we

959
00:43:14,780 --> 00:43:20,180
got this working like two hours before a

960
00:43:16,609 --> 00:43:21,890
black hat which was quite exciting but

961
00:43:20,180 --> 00:43:23,779
this is actually a real exploit for

962
00:43:21,890 --> 00:43:25,970
these iMessage bugs so one of the

963
00:43:23,780 --> 00:43:27,020
questions we get asked most often is you

964
00:43:25,970 --> 00:43:30,368
know sure these are memory corruption

965
00:43:27,020 --> 00:43:35,530
but can you actually exploit them and

966
00:43:30,369 --> 00:43:38,060
pretty much we can on this exploit demo

967
00:43:35,530 --> 00:43:40,010
uses a nun fixed bug but we don't feel

968
00:43:38,060 --> 00:43:41,390
that it's bike specific we feel that

969
00:43:40,010 --> 00:43:43,430
basically most of the memory corruption

970
00:43:41,390 --> 00:43:45,799
bugs the one with video references in

971
00:43:43,430 --> 00:43:49,450
the arrays the one with the

972
00:43:45,800 --> 00:43:53,450
out-of-bounds link twist they could also

973
00:43:49,450 --> 00:43:56,000
do this exploit the way this works is

974
00:43:53,450 --> 00:43:57,859
the biggest problem is breaking a SLR

975
00:43:56,000 --> 00:43:59,210
which is basically that every time you

976
00:43:57,859 --> 00:44:01,190
load a library it's in a different

977
00:43:59,210 --> 00:44:03,830
location and this is a technique they

978
00:44:01,190 --> 00:44:06,140
used to prevent exploitation so what we

979
00:44:03,830 --> 00:44:08,810
did is we sent a message that would

980
00:44:06,140 --> 00:44:10,339
cause a crash if the memory was laid out

981
00:44:08,810 --> 00:44:12,109
a certain way and would not cause a

982
00:44:10,340 --> 00:44:14,030
crash if it was written it was laid out

983
00:44:12,109 --> 00:44:16,848
another way and then Samuel wrote an

984
00:44:14,030 --> 00:44:18,619
algorithm that based on whether or not

985
00:44:16,849 --> 00:44:20,810
you received a delivery notification

986
00:44:18,619 --> 00:44:23,869
from the message basically did it crash

987
00:44:20,810 --> 00:44:26,930
where his memory laid out and then after

988
00:44:23,869 --> 00:44:30,369
that basically you put data on the heap

989
00:44:26,930 --> 00:44:34,700
and make a fake object and then you can

990
00:44:30,369 --> 00:44:39,950
call make fake calls on the object and

991
00:44:34,700 --> 00:44:42,339
that allows kind of execution so here is

992
00:44:39,950 --> 00:44:42,339
the

993
00:44:45,430 --> 00:44:51,790
video actually I don't think I'm gonna

994
00:44:47,950 --> 00:44:55,149
show it because it's on YouTube but

995
00:44:51,790 --> 00:44:56,620
basically just imagine that you're

996
00:44:55,150 --> 00:44:58,270
getting a bunch of messages that say

997
00:44:56,620 --> 00:45:00,759
breaking your a SLR and then a

998
00:44:58,270 --> 00:45:03,880
calculator pops up that's basically what

999
00:45:00,760 --> 00:45:05,860
happens but the idea is that we are able

1000
00:45:03,880 --> 00:45:09,700
to use these bugs to actually have a

1001
00:45:05,860 --> 00:45:11,950
concrete effect on the device so um I

1002
00:45:09,700 --> 00:45:13,839
want to end off with some observations

1003
00:45:11,950 --> 00:45:18,160
based on this research

1004
00:45:13,840 --> 00:45:20,830
one is that managed code reduces read do

1005
00:45:18,160 --> 00:45:22,629
reduces risk and it's not cost free of

1006
00:45:20,830 --> 00:45:24,610
course it's lower performance it can be

1007
00:45:22,630 --> 00:45:27,340
harder to use in certain situations but

1008
00:45:24,610 --> 00:45:30,610
I do think that we have noticed that

1009
00:45:27,340 --> 00:45:32,380
pattern where stuff that's written in

1010
00:45:30,610 --> 00:45:33,790
managed code will typically only have

1011
00:45:32,380 --> 00:45:35,140
logic bugs meanwhile stuff that's

1012
00:45:33,790 --> 00:45:38,050
written in native code will have both

1013
00:45:35,140 --> 00:45:40,480
memory corruption and logic bugs another

1014
00:45:38,050 --> 00:45:43,270
thing is that attack surface is

1015
00:45:40,480 --> 00:45:46,060
important I talked about serialization

1016
00:45:43,270 --> 00:45:47,830
which that was an unnecessary attack

1017
00:45:46,060 --> 00:45:50,380
surface but there was also a similar

1018
00:45:47,830 --> 00:45:52,090
situation in whatsapp where they were

1019
00:45:50,380 --> 00:45:54,730
able to call these messages I would have

1020
00:45:52,090 --> 00:45:56,440
order even though normally I wouldn't

1021
00:45:54,730 --> 00:45:58,660
require user interaction to get to

1022
00:45:56,440 --> 00:46:01,150
certain stages and that was unnecessary

1023
00:45:58,660 --> 00:46:03,520
attack surface 2 so it's important to

1024
00:46:01,150 --> 00:46:05,590
consider that and make sure that the the

1025
00:46:03,520 --> 00:46:08,320
smallest amount of code possible is

1026
00:46:05,590 --> 00:46:10,450
available to attackers and you know you

1027
00:46:08,320 --> 00:46:12,450
put as much as you can behind the click

1028
00:46:10,450 --> 00:46:14,859
behind the user having to do something

1029
00:46:12,450 --> 00:46:16,720
and decide is important in this case of

1030
00:46:14,860 --> 00:46:18,490
a serialization but I think it's

1031
00:46:16,720 --> 00:46:20,230
important to make sure the things are

1032
00:46:18,490 --> 00:46:22,299
designed in a way that they don't lead

1033
00:46:20,230 --> 00:46:27,160
to exploding attack surface and it's

1034
00:46:22,300 --> 00:46:29,710
easy to enumerate also I wanted to

1035
00:46:27,160 --> 00:46:31,720
mention that I feel like encryption is

1036
00:46:29,710 --> 00:46:33,190
by far the most studied area of either

1037
00:46:31,720 --> 00:46:35,470
of these apps and it's kind of

1038
00:46:33,190 --> 00:46:36,940
unfortunate I mean it's important that

1039
00:46:35,470 --> 00:46:38,529
encryption is good it's important that

1040
00:46:36,940 --> 00:46:40,360
people can't read messages over the

1041
00:46:38,530 --> 00:46:42,370
network but I also feel that there's

1042
00:46:40,360 --> 00:46:44,740
tons of research you know trying to find

1043
00:46:42,370 --> 00:46:45,819
problems in these protocols trying to

1044
00:46:44,740 --> 00:46:47,200
make sure that they're absolutely

1045
00:46:45,820 --> 00:46:49,900
perfect that there are no small

1046
00:46:47,200 --> 00:46:51,970
inferences you can make meanwhile there

1047
00:46:49,900 --> 00:46:54,100
is not much as much attention to you

1048
00:46:51,970 --> 00:46:55,490
know can you just execute code on the

1049
00:46:54,100 --> 00:46:57,440
other device and access

1050
00:46:55,490 --> 00:46:59,089
messages after they're encrypted and I

1051
00:46:57,440 --> 00:47:01,460
think that's fairly unfortunate that's

1052
00:46:59,090 --> 00:47:04,280
an area that needs more attention

1053
00:47:01,460 --> 00:47:05,810
because my observation is you don't see

1054
00:47:04,280 --> 00:47:07,400
a lot of attacks where attackers were

1055
00:47:05,810 --> 00:47:09,259
attacking the encryption they found a

1056
00:47:07,400 --> 00:47:11,150
way around it it's a lot more common for

1057
00:47:09,260 --> 00:47:14,000
them to do something like this to get

1058
00:47:11,150 --> 00:47:16,250
access to the messages so I also want to

1059
00:47:14,000 --> 00:47:18,560
suggest some future projects some for

1060
00:47:16,250 --> 00:47:20,660
people who do research in these areas I

1061
00:47:18,560 --> 00:47:22,460
think a very important area is

1062
00:47:20,660 --> 00:47:25,250
preventing implementation errors

1063
00:47:22,460 --> 00:47:27,020
the reason these errors exist outside of

1064
00:47:25,250 --> 00:47:28,700
design problems is because people make

1065
00:47:27,020 --> 00:47:31,009
mistakes and I feel like the technology

1066
00:47:28,700 --> 00:47:33,618
and the understanding of how to prevent

1067
00:47:31,010 --> 00:47:34,970
developers from making mistakes is not

1068
00:47:33,619 --> 00:47:37,220
as good as it could be and I think

1069
00:47:34,970 --> 00:47:39,109
that's a good research area I think it's

1070
00:47:37,220 --> 00:47:41,868
also important that people look at high

1071
00:47:39,110 --> 00:47:43,670
performance and safe languages the

1072
00:47:41,869 --> 00:47:46,010
reason that a lot of developers use

1073
00:47:43,670 --> 00:47:47,810
native code is because manage code

1074
00:47:46,010 --> 00:47:49,100
doesn't meet their needs and I think the

1075
00:47:47,810 --> 00:47:51,259
more things that could be in managed

1076
00:47:49,100 --> 00:47:53,450
code it would reduce Elise B's memory

1077
00:47:51,260 --> 00:47:55,430
corruption vulnerabilities I think it's

1078
00:47:53,450 --> 00:47:58,730
also important to focus on the

1079
00:47:55,430 --> 00:48:00,890
implementation aspects of design for

1080
00:47:58,730 --> 00:48:04,910
example recently I was reviewing papers

1081
00:48:00,890 --> 00:48:06,710
for another conference and there were a

1082
00:48:04,910 --> 00:48:08,720
lot of papers where it was like I

1083
00:48:06,710 --> 00:48:10,400
designed this thing and the thing is

1084
00:48:08,720 --> 00:48:12,740
perfect and if you looked at the design

1085
00:48:10,400 --> 00:48:15,590
the thing was perfect but there was no

1086
00:48:12,740 --> 00:48:17,390
thought given to you know is it humanly

1087
00:48:15,590 --> 00:48:20,480
possible for a developer to make this

1088
00:48:17,390 --> 00:48:22,580
thing you know will it be bug prone and

1089
00:48:20,480 --> 00:48:24,619
I think that's a very important part of

1090
00:48:22,580 --> 00:48:27,109
design that gets missed quite often not

1091
00:48:24,619 --> 00:48:28,369
just like if you build it perfectly you

1092
00:48:27,109 --> 00:48:30,500
know will it work

1093
00:48:28,369 --> 00:48:32,990
but considering the practical aspects of

1094
00:48:30,500 --> 00:48:35,000
how likely things are to have errors in

1095
00:48:32,990 --> 00:48:36,979
them is the best design and I think

1096
00:48:35,000 --> 00:48:39,380
that's something that is valuable I

1097
00:48:36,980 --> 00:48:41,270
think as its owns topic but also for

1098
00:48:39,380 --> 00:48:42,950
people who design things to not just

1099
00:48:41,270 --> 00:48:45,890
think about in theory but in practice

1100
00:48:42,950 --> 00:48:49,160
and finally I think it attack surface

1101
00:48:45,890 --> 00:48:51,770
enumeration is an important topic a lot

1102
00:48:49,160 --> 00:48:54,319
of this was attack surfaces that weren't

1103
00:48:51,770 --> 00:48:55,640
obvious I spent a lot of time you know

1104
00:48:54,320 --> 00:48:57,440
figuring out oh you can do video

1105
00:48:55,640 --> 00:48:59,480
conferencing oh you can do signaling Oh

1106
00:48:57,440 --> 00:49:01,190
serialization is remote and would be

1107
00:48:59,480 --> 00:49:02,810
nice if there were more tools to help

1108
00:49:01,190 --> 00:49:05,600
developers and help people who are

1109
00:49:02,810 --> 00:49:07,549
securing things I figure that out so

1110
00:49:05,600 --> 00:49:10,359
that's it thanks a lot and hopefully we

1111
00:49:07,550 --> 00:49:10,359
have a few minutes for questions

