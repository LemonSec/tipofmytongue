1
00:00:10,360 --> 00:00:15,410
hello everyone I'm Sam Kumar from UC

2
00:00:13,700 --> 00:00:17,060
Berkeley and I'll be presenting Jedi

3
00:00:15,410 --> 00:00:19,460
many-to-many end-to-end encryption and

4
00:00:17,060 --> 00:00:20,959
key delegation for IOT this is joint

5
00:00:19,460 --> 00:00:23,450
work with Yoon Seung who Michael

6
00:00:20,960 --> 00:00:27,500
Anderson Raluca papa and David color

7
00:00:23,450 --> 00:00:28,849
also from UC Berkeley so the two devices

8
00:00:27,500 --> 00:00:30,860
on the Internet of Things collect

9
00:00:28,849 --> 00:00:33,140
privacy sensitive data and the often

10
00:00:30,860 --> 00:00:35,269
exchange this data via intermediaries in

11
00:00:33,140 --> 00:00:37,550
order to perform their function what

12
00:00:35,270 --> 00:00:39,110
this means however is that if one of the

13
00:00:37,550 --> 00:00:40,760
intermediaries or one of the network

14
00:00:39,110 --> 00:00:43,460
links becomes compromised by an

15
00:00:40,760 --> 00:00:45,019
adversary then that adversary can see

16
00:00:43,460 --> 00:00:47,420
the messages that are being exchanged in

17
00:00:45,020 --> 00:00:49,070
the system so it's natural to use

18
00:00:47,420 --> 00:00:52,370
end-to-end encryption to protect data

19
00:00:49,070 --> 00:00:54,020
while it's in transit and would argue

20
00:00:52,370 --> 00:00:56,030
however that existing end-to-end

21
00:00:54,020 --> 00:00:57,920
encryption protocols aren't a great fit

22
00:00:56,030 --> 00:00:59,630
for large-scale IOT systems as they

23
00:00:57,920 --> 00:01:01,520
exist today and the reason is that

24
00:00:59,630 --> 00:01:04,400
existing end-to-end encryption protocols

25
00:01:01,520 --> 00:01:05,900
like say TLS assume a one to one form of

26
00:01:04,400 --> 00:01:07,700
communication where one principal

27
00:01:05,900 --> 00:01:10,009
communicates directly with another one

28
00:01:07,700 --> 00:01:12,170
but if you look at the large-scale IOT

29
00:01:10,009 --> 00:01:13,640
systems that are out there almost all of

30
00:01:12,170 --> 00:01:15,590
them use a different paradigm called

31
00:01:13,640 --> 00:01:17,270
publish/subscribe for communication and

32
00:01:15,590 --> 00:01:19,280
I will explain that as follows

33
00:01:17,270 --> 00:01:21,020
so suppose there's a temperature sensor

34
00:01:19,280 --> 00:01:23,030
there's producing temperature readings

35
00:01:21,020 --> 00:01:26,030
that are being consumed by an individual

36
00:01:23,030 --> 00:01:27,890
and by a service in the cloud the bit

37
00:01:26,030 --> 00:01:29,899
publish/subscribe handles this is that

38
00:01:27,890 --> 00:01:31,759
there's an intermediate broker that

39
00:01:29,899 --> 00:01:33,469
actually forwards the messages and that

40
00:01:31,759 --> 00:01:35,630
an API level the temperature sensor

41
00:01:33,469 --> 00:01:37,428
produces its reading and publishes it to

42
00:01:35,630 --> 00:01:40,460
a resource in this case the resource is

43
00:01:37,429 --> 00:01:42,679
soda Hall / atrium / temp and each of

44
00:01:40,460 --> 00:01:45,499
the two recipients subscribe two sets of

45
00:01:42,679 --> 00:01:47,179
resources in this case the cloud service

46
00:01:45,499 --> 00:01:49,359
for example is subscribing to all the

47
00:01:47,179 --> 00:01:51,979
resources that begin with soda Hall and

48
00:01:49,359 --> 00:01:53,658
the reason for doing it this way is that

49
00:01:51,979 --> 00:01:55,459
the temperature sensor doesn't have to

50
00:01:53,659 --> 00:01:56,539
know in advance who the recipients are

51
00:01:55,459 --> 00:01:58,609
going to be it was a very nice

52
00:01:56,539 --> 00:02:00,020
separation of concerns the sensor only

53
00:01:58,609 --> 00:02:03,889
has to worry about his temperature

54
00:02:00,020 --> 00:02:05,959
reading and the resource so the overall

55
00:02:03,889 --> 00:02:07,339
system consists of many such principles

56
00:02:05,959 --> 00:02:09,649
all of which are interacting with

57
00:02:07,340 --> 00:02:11,330
different resources so a natural

58
00:02:09,649 --> 00:02:13,819
question is okay how do we do access

59
00:02:11,330 --> 00:02:16,160
control how does the broker know who is

60
00:02:13,819 --> 00:02:17,359
allowed to subscribe to one and there's

61
00:02:16,160 --> 00:02:18,950
a different mechanism that's typically

62
00:02:17,360 --> 00:02:21,110
used for this called decentralized

63
00:02:18,950 --> 00:02:23,298
delegation and the way that brooks is

64
00:02:21,110 --> 00:02:24,090
that if there's some principal say alice

65
00:02:23,299 --> 00:02:26,190
who has acts

66
00:02:24,090 --> 00:02:28,530
to all the resources beginning with

67
00:02:26,190 --> 00:02:30,720
Aurra home what she can do is she can

68
00:02:28,530 --> 00:02:32,550
delegate to another principal access to

69
00:02:30,720 --> 00:02:34,800
a subset of those resources for a

70
00:02:32,550 --> 00:02:37,319
limited duration and the delegation is

71
00:02:34,800 --> 00:02:39,629
transitive so if this principal has some

72
00:02:37,319 --> 00:02:41,670
device like a light bulb he can delegate

73
00:02:39,629 --> 00:02:44,640
access for an even smaller subset of

74
00:02:41,670 --> 00:02:46,349
resources for an even smaller duration

75
00:02:44,640 --> 00:02:48,660
so that the laptop can perform its

76
00:02:46,349 --> 00:02:51,000
function so jus centralized delegation

77
00:02:48,660 --> 00:02:53,040
is actually a really old idea was

78
00:02:51,000 --> 00:02:56,190
developed in the late 90s and early

79
00:02:53,040 --> 00:02:57,450
2000s but it's since become the state of

80
00:02:56,190 --> 00:02:59,730
the art for access control and

81
00:02:57,450 --> 00:03:01,410
large-scale IOT systems because it very

82
00:02:59,730 --> 00:03:04,679
naturally matches the flow of

83
00:03:01,410 --> 00:03:06,540
permissions that you typically see one

84
00:03:04,680 --> 00:03:08,040
final aspect of IOT I want to mention is

85
00:03:06,540 --> 00:03:09,900
that IOT devices are resource

86
00:03:08,040 --> 00:03:12,120
constrained so if you look at the

87
00:03:09,900 --> 00:03:13,920
devices that participate in IOT you can

88
00:03:12,120 --> 00:03:16,049
put them on a spectrum for more powerful

89
00:03:13,920 --> 00:03:17,640
to less powerful and as you can see they

90
00:03:16,049 --> 00:03:19,079
differ by more than three orders of

91
00:03:17,640 --> 00:03:22,109
magnitude in what they're able to

92
00:03:19,079 --> 00:03:23,819
compute now the nature of IOT is that

93
00:03:22,110 --> 00:03:25,500
all these devices have to be able to

94
00:03:23,819 --> 00:03:27,569
communicate with each other so an

95
00:03:25,500 --> 00:03:29,609
end-to-end encryption protocol for IOT

96
00:03:27,569 --> 00:03:31,018
has to work on even the least powerful

97
00:03:29,609 --> 00:03:34,049
end of the spectrum the ultra-low-power

98
00:03:31,019 --> 00:03:35,489
deeply embedded sensors so with this

99
00:03:34,049 --> 00:03:37,290
background I'm going to present Jedi

100
00:03:35,489 --> 00:03:40,200
which is joining encryption and

101
00:03:37,290 --> 00:03:42,510
delegation for IOT and Jedi is an end to

102
00:03:40,200 --> 00:03:44,280
an intra print protocol that allows

103
00:03:42,510 --> 00:03:46,290
senders and receivers to be decoupled as

104
00:03:44,280 --> 00:03:48,750
in publish/subscribe supports

105
00:03:46,290 --> 00:03:50,510
decentralized delegation and can run

106
00:03:48,750 --> 00:03:53,250
even on resource-constrained iot devices

107
00:03:50,510 --> 00:03:54,870
in other words it works within the three

108
00:03:53,250 --> 00:03:57,630
constraints of IOT that i mentioned

109
00:03:54,870 --> 00:03:59,700
earlier so the bulk of the talk is going

110
00:03:57,630 --> 00:04:02,099
to focus on how jedi works in particular

111
00:03:59,700 --> 00:04:03,690
how we handle encryption in the new

112
00:04:02,099 --> 00:04:06,000
model with publish/subscribe and

113
00:04:03,690 --> 00:04:07,500
decentralized delegation and how we can

114
00:04:06,000 --> 00:04:10,669
make the scheme lightweight enough to

115
00:04:07,500 --> 00:04:13,680
run on resource-constrained iot devices

116
00:04:10,669 --> 00:04:15,239
so how do we encrypt something in Jedi

117
00:04:13,680 --> 00:04:17,728
so first the temperature sensor produces

118
00:04:15,239 --> 00:04:19,108
a reading it labels it with the

119
00:04:17,728 --> 00:04:21,389
resources being published to and then

120
00:04:19,108 --> 00:04:23,700
the question is okay how do we actually

121
00:04:21,389 --> 00:04:25,229
encrypt this and the way typical and to

122
00:04:23,700 --> 00:04:26,909
and if different protocols would work is

123
00:04:25,229 --> 00:04:29,340
that you encrypt using the public key of

124
00:04:26,910 --> 00:04:31,229
the recipient but the whole point of

125
00:04:29,340 --> 00:04:32,849
using publish/subscribe here was so that

126
00:04:31,229 --> 00:04:34,830
the sender of the message doesn't have

127
00:04:32,849 --> 00:04:36,930
to know who the recipients are so we

128
00:04:34,830 --> 00:04:37,950
don't actually know whose public key D

129
00:04:36,930 --> 00:04:40,800
used to encrypt this

130
00:04:37,950 --> 00:04:42,360
message so our idea to get around this

131
00:04:40,800 --> 00:04:44,460
in Jedi is that we encrypt the message

132
00:04:42,360 --> 00:04:45,900
according to the resource to which is

133
00:04:44,460 --> 00:04:47,520
being published not according to the

134
00:04:45,900 --> 00:04:49,710
recipient as you would do in most

135
00:04:47,520 --> 00:04:51,659
end-to-end encryption protocols in this

136
00:04:49,710 --> 00:04:53,880
case the resources Sora Hall / the

137
00:04:51,660 --> 00:04:55,620
atrium / temp so we're going to somehow

138
00:04:53,880 --> 00:04:57,650
derive from this an encryption key that

139
00:04:55,620 --> 00:05:00,330
we use to encrypt the message

140
00:04:57,650 --> 00:05:02,280
similarly the recipients are subscribers

141
00:05:00,330 --> 00:05:04,409
as their resources so they also have

142
00:05:02,280 --> 00:05:06,000
some resource pacific decryption keys

143
00:05:04,410 --> 00:05:08,910
that allowed them to decrypt messages

144
00:05:06,000 --> 00:05:10,170
publish to those resources so now once

145
00:05:08,910 --> 00:05:12,210
we have done this we can send the

146
00:05:10,170 --> 00:05:13,890
message to the broker the broker reads

147
00:05:12,210 --> 00:05:15,750
the resource name and forwards it to the

148
00:05:13,890 --> 00:05:18,900
appropriate recipients who can then

149
00:05:15,750 --> 00:05:20,340
decrypt the message using their keys so

150
00:05:18,900 --> 00:05:21,810
what this means is that in the overall

151
00:05:20,340 --> 00:05:24,330
system messages are encrypted with the

152
00:05:21,810 --> 00:05:25,950
resource name so an adversary who

153
00:05:24,330 --> 00:05:27,539
controls the broker either because the

154
00:05:25,950 --> 00:05:29,520
broker has been hacked or because the

155
00:05:27,540 --> 00:05:30,750
broker is malicious cannot see the

156
00:05:29,520 --> 00:05:32,969
contents and messages that are being

157
00:05:30,750 --> 00:05:34,950
exchanged in the system so let's take a

158
00:05:32,970 --> 00:05:37,140
look at the keys for just a moment a

159
00:05:34,950 --> 00:05:39,420
natural question again is how do we

160
00:05:37,140 --> 00:05:41,340
control who has which decryption keys

161
00:05:39,420 --> 00:05:42,600
and this comes back to the same access

162
00:05:41,340 --> 00:05:45,630
control mechanism from earlier

163
00:05:42,600 --> 00:05:47,040
decentralized delegation so I did a

164
00:05:45,630 --> 00:05:49,320
brief example of decentralized

165
00:05:47,040 --> 00:05:51,030
delegation earlier on in the talk but I

166
00:05:49,320 --> 00:05:52,950
want to do a more in-depth example to

167
00:05:51,030 --> 00:05:54,450
make sure we're all on the same page so

168
00:05:52,950 --> 00:05:56,909
typically in a system with decentralized

169
00:05:54,450 --> 00:05:59,760
delegation the system consists of many

170
00:05:56,910 --> 00:06:01,380
different trust domains in every trusted

171
00:05:59,760 --> 00:06:02,789
me in tourism there's a set of resources

172
00:06:01,380 --> 00:06:04,890
that are typically organized in a

173
00:06:02,790 --> 00:06:06,870
hierarchy and furthermore there is some

174
00:06:04,890 --> 00:06:09,240
Authority who has control implicitly

175
00:06:06,870 --> 00:06:10,830
over all the resources in the hierarchy

176
00:06:09,240 --> 00:06:12,450
in this case we're doing a smart city's

177
00:06:10,830 --> 00:06:15,000
example so the levels in the hierarchy

178
00:06:12,450 --> 00:06:18,180
correspond to buildings floors rooms and

179
00:06:15,000 --> 00:06:20,580
sensors so now if another principal

180
00:06:18,180 --> 00:06:22,020
comes along and needs access to say all

181
00:06:20,580 --> 00:06:24,300
the resources in one of the buildings

182
00:06:22,020 --> 00:06:26,430
the way these systems typically handle

183
00:06:24,300 --> 00:06:28,050
that is that the authority signed the

184
00:06:26,430 --> 00:06:29,490
certificate attesting that the building

185
00:06:28,050 --> 00:06:32,190
manager has access to those resources

186
00:06:29,490 --> 00:06:33,900
and then he can present that to anyone

187
00:06:32,190 --> 00:06:36,570
in order to prove that he has access and

188
00:06:33,900 --> 00:06:38,760
this continues transitively so if the

189
00:06:36,570 --> 00:06:40,020
lab director needs access he doesn't

190
00:06:38,760 --> 00:06:42,330
have to go all the way back to the

191
00:06:40,020 --> 00:06:43,740
campus facilities manager the building

192
00:06:42,330 --> 00:06:45,840
manager can directly grant him a

193
00:06:43,740 --> 00:06:47,160
certificate and then he can present

194
00:06:45,840 --> 00:06:49,049
those two certificates together as a

195
00:06:47,160 --> 00:06:51,330
bundle to prove he has access to any

196
00:06:49,050 --> 00:06:51,870
subset of resources and so on for

197
00:06:51,330 --> 00:06:54,960
additional

198
00:06:51,870 --> 00:06:56,550
delegation now this works fine in

199
00:06:54,960 --> 00:06:58,620
typical systems that used a centralized

200
00:06:56,550 --> 00:07:00,810
delegation but in Jedi we wanted to

201
00:06:58,620 --> 00:07:02,280
end-to-end encryption so simply handing

202
00:07:00,810 --> 00:07:04,080
out certificates isn't enough we have to

203
00:07:02,280 --> 00:07:06,419
hand out decryption keys that can be

204
00:07:04,080 --> 00:07:07,650
used to actually decrypt messages so

205
00:07:06,419 --> 00:07:09,659
what does that look like well the

206
00:07:07,650 --> 00:07:11,940
Capitol facilities manager as before it

207
00:07:09,660 --> 00:07:14,310
literally owns everything in this trust

208
00:07:11,940 --> 00:07:16,350
domain so he has some kind of master key

209
00:07:14,310 --> 00:07:19,320
that can decrypt all the resources in

210
00:07:16,350 --> 00:07:21,210
the domain similarly when the building

211
00:07:19,320 --> 00:07:23,760
manager needs access he has to generate

212
00:07:21,210 --> 00:07:25,739
some key that only works for a subset of

213
00:07:23,760 --> 00:07:27,630
those resources and give back to the

214
00:07:25,740 --> 00:07:30,060
building manager and the one for

215
00:07:27,630 --> 00:07:32,310
additional levels of delegation so again

216
00:07:30,060 --> 00:07:33,840
the the key difficulty here is that we

217
00:07:32,310 --> 00:07:35,490
can't simply hand our certificates we

218
00:07:33,840 --> 00:07:38,280
have to hand out keys that can be used

219
00:07:35,490 --> 00:07:40,380
to decrypt messages so based on these

220
00:07:38,280 --> 00:07:42,599
high-level ideas I'm going to talk about

221
00:07:40,380 --> 00:07:44,880
a first cut of Jedi how we can

222
00:07:42,600 --> 00:07:47,490
instantiate these ideas using attribute

223
00:07:44,880 --> 00:07:48,900
based encryption and for now let's set

224
00:07:47,490 --> 00:07:51,560
aside efficiency I'll come back and

225
00:07:48,900 --> 00:07:54,060
address efficiency later on in the talk

226
00:07:51,560 --> 00:07:55,500
so as you recall that we're going to

227
00:07:54,060 --> 00:07:58,560
encrypt the message according to the

228
00:07:55,500 --> 00:07:59,789
resources being published to so an

229
00:07:58,560 --> 00:08:01,169
attribute based encryption you can

230
00:07:59,789 --> 00:08:02,820
encrypt a message using a set of

231
00:08:01,169 --> 00:08:06,389
attributes where each attribute can be

232
00:08:02,820 --> 00:08:08,490
an arbitrary string so in this case we

233
00:08:06,389 --> 00:08:10,590
can encode the resource soda Hall atrium

234
00:08:08,490 --> 00:08:12,750
ten into three attributes one sort of

235
00:08:10,590 --> 00:08:14,960
how to atrium three temp and use those

236
00:08:12,750 --> 00:08:17,370
three attributes to encrypt the message

237
00:08:14,960 --> 00:08:19,530
now we also to figure out what the keys

238
00:08:17,370 --> 00:08:21,510
look like and an attribute based

239
00:08:19,530 --> 00:08:23,460
encryption keys correspond to policies

240
00:08:21,510 --> 00:08:25,169
that check for certain attributes to be

241
00:08:23,460 --> 00:08:27,599
present in a ciphertext before they can

242
00:08:25,169 --> 00:08:29,580
decrypt it so if we look at these two

243
00:08:27,599 --> 00:08:31,740
keys here the key for sort of hall slash

244
00:08:29,580 --> 00:08:34,529
star that can decrypt all the resources

245
00:08:31,740 --> 00:08:36,360
beginning with Sora Hall it has the

246
00:08:34,529 --> 00:08:37,979
policy 1 soda Hall that checks for that

247
00:08:36,360 --> 00:08:39,150
one attribute to be present before it'll

248
00:08:37,979 --> 00:08:42,029
decrypt the ciphertext

249
00:08:39,150 --> 00:08:44,218
similarly the orange key corresponds to

250
00:08:42,029 --> 00:08:45,630
the policy 1 soda Hall and to floor for

251
00:08:44,219 --> 00:08:48,000
the checks for both of those attributes

252
00:08:45,630 --> 00:08:49,290
to be present and a final property of

253
00:08:48,000 --> 00:08:51,839
attribute based encryption we're using

254
00:08:49,290 --> 00:08:53,640
here is that given a key for one policy

255
00:08:51,839 --> 00:08:55,620
you can generate a key for a more

256
00:08:53,640 --> 00:08:57,330
restrictive policy and that allows us to

257
00:08:55,620 --> 00:08:59,070
generate the orange key from the green

258
00:08:57,330 --> 00:09:01,950
key in order to support decentralized

259
00:08:59,070 --> 00:09:03,959
delegation now I'm going to talk about

260
00:09:01,950 --> 00:09:05,640
how we can add a limited duration onto

261
00:09:03,959 --> 00:09:07,349
this delegation so you can delegate

262
00:09:05,640 --> 00:09:10,620
someone access to some resources that

263
00:09:07,350 --> 00:09:12,240
expires at a certain fixed time so the

264
00:09:10,620 --> 00:09:14,280
first thing that we do is that we

265
00:09:12,240 --> 00:09:16,560
encrypt using the current time alongside

266
00:09:14,280 --> 00:09:17,970
the resource name so as before we

267
00:09:16,560 --> 00:09:19,619
include the three attributes

268
00:09:17,970 --> 00:09:21,660
corresponding to the resource but we

269
00:09:19,620 --> 00:09:23,340
also include three additional attributes

270
00:09:21,660 --> 00:09:25,020
describing the time at which the message

271
00:09:23,340 --> 00:09:28,500
is being published in this case year

272
00:09:25,020 --> 00:09:30,600
2019 month August day 16 and then we

273
00:09:28,500 --> 00:09:33,720
need to encode the limited duration into

274
00:09:30,600 --> 00:09:35,520
the keys into the a Bek scores into the

275
00:09:33,720 --> 00:09:37,920
ABI policies corresponding to the keys

276
00:09:35,520 --> 00:09:39,990
and we do that by recognizing time as

277
00:09:37,920 --> 00:09:41,910
being another hierarchy with levels

278
00:09:39,990 --> 00:09:45,630
corresponding to for example here's

279
00:09:41,910 --> 00:09:47,699
months days and hours so if we want to

280
00:09:45,630 --> 00:09:50,370
generate a key with a fixed expiry date

281
00:09:47,700 --> 00:09:51,870
like February 2nd 2020 what we do is we

282
00:09:50,370 --> 00:09:53,640
take that limited duration and we

283
00:09:51,870 --> 00:09:56,550
express it as a time interval in this

284
00:09:53,640 --> 00:09:58,380
hierarchy and then we we decompose a

285
00:09:56,550 --> 00:09:59,880
time interval into a set of sub trees

286
00:09:58,380 --> 00:10:03,060
that exactly cover that time interval

287
00:09:59,880 --> 00:10:04,710
and note that because note that because

288
00:10:03,060 --> 00:10:06,660
we're expressing time as being another

289
00:10:04,710 --> 00:10:08,010
hierarchy there will never be too many

290
00:10:06,660 --> 00:10:09,150
of these sub trees the number of sub

291
00:10:08,010 --> 00:10:11,610
trees will be logged with making the

292
00:10:09,150 --> 00:10:13,620
length of the time range and now we can

293
00:10:11,610 --> 00:10:15,720
now we can actually construct the key

294
00:10:13,620 --> 00:10:17,790
with the limited duration simply by

295
00:10:15,720 --> 00:10:19,860
assigning one a ve key to each of the

296
00:10:17,790 --> 00:10:21,930
sub trees and bundling them together and

297
00:10:19,860 --> 00:10:24,510
together these for a ve keys in this

298
00:10:21,930 --> 00:10:28,680
example provide access for the time

299
00:10:24,510 --> 00:10:30,540
range that we desire so so far I've

300
00:10:28,680 --> 00:10:32,370
talked about how we can achieve expiry

301
00:10:30,540 --> 00:10:33,839
but now I'm going to talk about how we

302
00:10:32,370 --> 00:10:35,760
can take the scheme that we have so far

303
00:10:33,840 --> 00:10:37,680
that uses attribute based encryption and

304
00:10:35,760 --> 00:10:39,480
make it lightweight enough to run on

305
00:10:37,680 --> 00:10:41,430
even resource constrained IOT devices

306
00:10:39,480 --> 00:10:43,110
and to make the discussion concrete i'm

307
00:10:41,430 --> 00:10:45,089
going to introduce the hamilton platform

308
00:10:43,110 --> 00:10:47,090
which is the platform for low-power

309
00:10:45,090 --> 00:10:49,680
sensing that we used in our evaluation

310
00:10:47,090 --> 00:10:52,050
the device is based on a low power

311
00:10:49,680 --> 00:10:54,329
system on chip with the cortex m0 plus

312
00:10:52,050 --> 00:10:56,579
processor at 48 megahertz and 32

313
00:10:54,330 --> 00:10:58,410
kilobytes of data memory so this is much

314
00:10:56,580 --> 00:11:00,960
much more resource constrained than for

315
00:10:58,410 --> 00:11:02,430
example a raspberry pi and the internet

316
00:11:00,960 --> 00:11:04,020
use case of a something platform like

317
00:11:02,430 --> 00:11:05,670
this is so that you can deploy Daboo

318
00:11:04,020 --> 00:11:07,260
Curtis Lee and say a building to collect

319
00:11:05,670 --> 00:11:09,449
ambient sensor readings for several

320
00:11:07,260 --> 00:11:12,270
years at a time and in order to make

321
00:11:09,450 --> 00:11:13,800
that in order to make such applications

322
00:11:12,270 --> 00:11:15,840
practical we need to see several years

323
00:11:13,800 --> 00:11:17,459
of battery life and the system has to be

324
00:11:15,840 --> 00:11:18,720
low cost sorry powering it with a one

325
00:11:17,460 --> 00:11:21,480
dollar battery

326
00:11:18,720 --> 00:11:23,069
and and for the something platform like

327
00:11:21,480 --> 00:11:24,720
this it turns out that the limiting

328
00:11:23,069 --> 00:11:27,000
factor the hardest thing to make a

329
00:11:24,720 --> 00:11:28,410
protocol like Jedi run on a device like

330
00:11:27,000 --> 00:11:29,970
this turns out to be the power

331
00:11:28,410 --> 00:11:32,399
consumption of attribute based

332
00:11:29,970 --> 00:11:33,779
encryption so we're already making

333
00:11:32,399 --> 00:11:35,519
efforts to use attribute based

334
00:11:33,779 --> 00:11:37,350
encryption rarely in particular we use

335
00:11:35,519 --> 00:11:39,060
hybrid encryption which means that we

336
00:11:37,350 --> 00:11:40,350
first was a symmetric key encrypt the

337
00:11:39,060 --> 00:11:42,060
symmetric key with attribute based

338
00:11:40,350 --> 00:11:44,009
encryption and then use a symmetric key

339
00:11:42,060 --> 00:11:45,628
for subsequent messages so we only

340
00:11:44,009 --> 00:11:47,250
actually have to invoke attribute based

341
00:11:45,629 --> 00:11:50,220
encryption when the attributes change

342
00:11:47,250 --> 00:11:51,930
and that happens once every hour when

343
00:11:50,220 --> 00:11:53,910
the attributes corresponding to the time

344
00:11:51,930 --> 00:11:54,899
changed when we read in the time

345
00:11:53,910 --> 00:11:57,120
increments

346
00:11:54,899 --> 00:11:59,430
but despite invoking a B II rarely once

347
00:11:57,120 --> 00:12:01,529
every hour attribute based encryption

348
00:11:59,430 --> 00:12:04,500
dominates the overall power consumption

349
00:12:01,529 --> 00:12:07,199
and to put that in perspective we we

350
00:12:04,500 --> 00:12:08,970
measured that B calculator that an

351
00:12:07,199 --> 00:12:10,829
attribute based encryption takes for

352
00:12:08,970 --> 00:12:12,569
minister computer and Hamilton and you

353
00:12:10,829 --> 00:12:14,160
know in and of itself the four minutes

354
00:12:12,569 --> 00:12:15,810
isn't a problem because you can encrypt

355
00:12:14,160 --> 00:12:16,500
in the background to mask the latency

356
00:12:15,810 --> 00:12:18,750
and so on

357
00:12:16,500 --> 00:12:20,670
but the power cost doesn't go away and

358
00:12:18,750 --> 00:12:22,259
that one a B ei encryption per hour the

359
00:12:20,670 --> 00:12:23,579
battery won't even last a hundred days

360
00:12:22,259 --> 00:12:26,610
which is a problem because we want

361
00:12:23,579 --> 00:12:28,109
several years of battery life so a first

362
00:12:26,610 --> 00:12:29,459
step is to choose a more efficient

363
00:12:28,110 --> 00:12:31,439
encryption scheme than attribute based

364
00:12:29,459 --> 00:12:33,809
encryption and the literature is pretty

365
00:12:31,439 --> 00:12:35,250
enormous here there there's a very large

366
00:12:33,809 --> 00:12:37,139
variety of in frequencies we could

367
00:12:35,250 --> 00:12:38,519
possibly choose that all make different

368
00:12:37,139 --> 00:12:41,819
trade-offs between functionality

369
00:12:38,519 --> 00:12:44,040
performance and security so we identify

370
00:12:41,819 --> 00:12:45,719
wicked ibe as an encryption scheme

371
00:12:44,040 --> 00:12:47,189
that's more efficient than attribute

372
00:12:45,720 --> 00:12:50,579
based encryption at the cost of being

373
00:12:47,189 --> 00:12:53,639
less flexible yet we realize that it's

374
00:12:50,579 --> 00:12:55,979
flexible enough to to instantiate Jedi

375
00:12:53,639 --> 00:12:58,559
if we use it carefully so here's a

376
00:12:55,980 --> 00:13:00,540
summary of how wicked ibe works so in

377
00:12:58,559 --> 00:13:02,550
wicked ibe each ciphertext of key

378
00:13:00,540 --> 00:13:04,439
corresponds to a vector of strings and

379
00:13:02,550 --> 00:13:06,000
wild cards looks like this where some of

380
00:13:04,439 --> 00:13:08,579
the entries are strings others are wild

381
00:13:06,000 --> 00:13:10,439
cards the rule is that a key can decrypt

382
00:13:08,579 --> 00:13:12,989
the ciphertext if they're vectors match

383
00:13:10,439 --> 00:13:15,149
and what makes this interesting is that

384
00:13:12,990 --> 00:13:16,529
given a key you can generate a key where

385
00:13:15,149 --> 00:13:18,569
some wild cards are replaced with

386
00:13:16,529 --> 00:13:20,459
strings so for example if we had a key

387
00:13:18,569 --> 00:13:22,259
corresponding to this vector we can

388
00:13:20,459 --> 00:13:24,239
generate a key corresponding to this new

389
00:13:22,259 --> 00:13:27,000
vector where we replace one of the wild

390
00:13:24,240 --> 00:13:29,509
cards with a string so Jedi use this

391
00:13:27,000 --> 00:13:31,949
wicked ibe in a very particular way

392
00:13:29,509 --> 00:13:32,430
where we encode multiple concurrent

393
00:13:31,949 --> 00:13:34,439
higher

394
00:13:32,430 --> 00:13:36,780
he's one for the resourced and one for

395
00:13:34,440 --> 00:13:38,430
the time into a single wicked ibe vector

396
00:13:36,780 --> 00:13:41,040
just interesting because the original

397
00:13:38,430 --> 00:13:43,349
intended use case in in the wicked IBE

398
00:13:41,040 --> 00:13:45,180
paper was generalized allocation within

399
00:13:43,350 --> 00:13:47,040
a single hierarchy which were able to

400
00:13:45,180 --> 00:13:49,020
use the to encode multiple so for

401
00:13:47,040 --> 00:13:51,240
example if we have this resource prefix

402
00:13:49,020 --> 00:13:53,819
in this time range we can encode it into

403
00:13:51,240 --> 00:13:55,290
a vector like this where we're using the

404
00:13:53,820 --> 00:13:57,150
first few components for the resource

405
00:13:55,290 --> 00:13:59,760
and the last few components for the time

406
00:13:57,150 --> 00:14:01,620
and then we can support decentralized

407
00:13:59,760 --> 00:14:03,480
allocation to generate a private key for

408
00:14:01,620 --> 00:14:05,730
a more restrictive set of resources and

409
00:14:03,480 --> 00:14:07,380
a more limited time duration simply by

410
00:14:05,730 --> 00:14:11,760
replacing wildcards with strings as

411
00:14:07,380 --> 00:14:13,710
follows so so in this way we're able to

412
00:14:11,760 --> 00:14:14,970
use the delegation property of wicked

413
00:14:13,710 --> 00:14:16,920
idea there's a fork is centralized

414
00:14:14,970 --> 00:14:19,830
allocation maintaining the expiry and

415
00:14:16,920 --> 00:14:22,500
the resource properties from before now

416
00:14:19,830 --> 00:14:24,960
using wicked ibe instead of a b e helps

417
00:14:22,500 --> 00:14:27,120
a lot but it isn't quite enough to reach

418
00:14:24,960 --> 00:14:28,050
several years of battery life so we

419
00:14:27,120 --> 00:14:30,360
additionally make cryptographic

420
00:14:28,050 --> 00:14:33,359
improvements to wicked ìbe to make the

421
00:14:30,360 --> 00:14:34,740
scheme more efficient as used in jedi so

422
00:14:33,360 --> 00:14:36,840
here's the existing wicked ibe

423
00:14:34,740 --> 00:14:38,280
encryption algorithm from a no7 and it

424
00:14:36,840 --> 00:14:39,720
works as you might expect it takes in

425
00:14:38,280 --> 00:14:42,510
the message they attribute vector as

426
00:14:39,720 --> 00:14:44,610
inputs and outputs a ciphertext our

427
00:14:42,510 --> 00:14:46,920
observation in Jedi however is that

428
00:14:44,610 --> 00:14:48,660
adjacent encryptions using is that

429
00:14:46,920 --> 00:14:51,000
adjacent encryptions using wicked ibe

430
00:14:48,660 --> 00:14:53,100
differ and only a few attributes and the

431
00:14:51,000 --> 00:14:55,080
way to see this is as follows we only

432
00:14:53,100 --> 00:14:56,730
invoke wicked IB even the attributes

433
00:14:55,080 --> 00:14:59,010
change which happens once every hour

434
00:14:56,730 --> 00:14:59,670
when the attributes corresponding to the

435
00:14:59,010 --> 00:15:01,800
time change

436
00:14:59,670 --> 00:15:03,270
but even then all the attributes occurs

437
00:15:01,800 --> 00:15:05,189
according to the resource actually

438
00:15:03,270 --> 00:15:06,630
remained the same and furthermore the

439
00:15:05,190 --> 00:15:08,490
attributes corresponding to the high

440
00:15:06,630 --> 00:15:10,800
level components of time like the Year

441
00:15:08,490 --> 00:15:12,840
month and day are changing rarely it's

442
00:15:10,800 --> 00:15:14,130
only the last component that component

443
00:15:12,840 --> 00:15:16,560
corresponding to the hour that's

444
00:15:14,130 --> 00:15:18,330
changing on every single encryption so

445
00:15:16,560 --> 00:15:20,609
we're idea is that we develop a new

446
00:15:18,330 --> 00:15:22,500
encryption algorithm for wicked IBE that

447
00:15:20,610 --> 00:15:24,350
allows us to do work only according to

448
00:15:22,500 --> 00:15:26,910
the Delta from the previous encryption

449
00:15:24,350 --> 00:15:28,890
so our new encryption algorithm would

450
00:15:26,910 --> 00:15:30,600
ideally look like this it takes in the

451
00:15:28,890 --> 00:15:32,670
message and the attributes that changed

452
00:15:30,600 --> 00:15:34,830
since last time as inputs and outputs a

453
00:15:32,670 --> 00:15:36,689
ciphertext now in order to actually make

454
00:15:34,830 --> 00:15:38,430
this efficient we alter output some

455
00:15:36,690 --> 00:15:39,840
cryptographic state that encodes the

456
00:15:38,430 --> 00:15:40,739
work we have done for the existing

457
00:15:39,840 --> 00:15:43,140
attributes and what the existing

458
00:15:40,740 --> 00:15:44,610
attributes are and then we take in the

459
00:15:43,140 --> 00:15:46,319
previous state when we do the encryption

460
00:15:44,610 --> 00:15:47,700
that allows us to reuse

461
00:15:46,320 --> 00:15:49,710
some of the work from before in some

462
00:15:47,700 --> 00:15:53,190
sense and only do work according to the

463
00:15:49,710 --> 00:15:56,760
Delta so that concludes this part of the

464
00:15:53,190 --> 00:15:58,320
talk about Jedi's approach there are

465
00:15:56,760 --> 00:15:59,939
also two additional properties in Jedi

466
00:15:58,320 --> 00:16:00,990
and anonymous signatures in revocation

467
00:15:59,940 --> 00:16:02,490
which I don't have time to talk about

468
00:16:00,990 --> 00:16:04,830
but you can see those details in the

469
00:16:02,490 --> 00:16:05,910
paper or come talk to me afterwards now

470
00:16:04,830 --> 00:16:07,920
I'm going to talk about our

471
00:16:05,910 --> 00:16:10,079
implementation and evaluation so

472
00:16:07,920 --> 00:16:11,640
implementation consists of two parts the

473
00:16:10,080 --> 00:16:13,170
first part is our crypto library that

474
00:16:11,640 --> 00:16:15,449
implements wicked ibe in our new

475
00:16:13,170 --> 00:16:17,490
encryption algorithm it also contains

476
00:16:15,450 --> 00:16:19,020
assembly optimizations for cortex-m zero

477
00:16:17,490 --> 00:16:21,240
plus the processor used on Hamilton

478
00:16:19,020 --> 00:16:22,590
which provide a 4 to 5 X performance

479
00:16:21,240 --> 00:16:25,290
improvement over a pure C or C++

480
00:16:22,590 --> 00:16:26,670
implementation second part is a

481
00:16:25,290 --> 00:16:28,260
prototype of the generator protocol

482
00:16:26,670 --> 00:16:30,599
which we implemented for PW 2 a

483
00:16:28,260 --> 00:16:32,010
messaging system for smart cities so

484
00:16:30,600 --> 00:16:35,370
here are the performance results from

485
00:16:32,010 --> 00:16:37,380
running BW 2 widget I applied to it

486
00:16:35,370 --> 00:16:39,030
most of Jedi's overhead as you can see

487
00:16:37,380 --> 00:16:40,920
from the blue region on the graph comes

488
00:16:39,030 --> 00:16:43,350
from the symmetric key crypto library

489
00:16:40,920 --> 00:16:45,180
they're producing and furthermore Jedi's

490
00:16:43,350 --> 00:16:46,560
overall overhead is only about 10

491
00:16:45,180 --> 00:16:47,910
milliseconds for small messages which

492
00:16:46,560 --> 00:16:52,050
makes it practical for smart cities

493
00:16:47,910 --> 00:16:54,689
applications second we want to look at

494
00:16:52,050 --> 00:16:56,219
we want to evaluate our optimizations to

495
00:16:54,690 --> 00:16:58,830
make it IBE how they affect the battery

496
00:16:56,220 --> 00:17:01,110
life on Hamilton the first result here

497
00:16:58,830 --> 00:17:02,790
is that encryption with Jedi is 37 times

498
00:17:01,110 --> 00:17:07,050
more efficient than a evily applying

499
00:17:02,790 --> 00:17:08,670
attribute based encryption and and here

500
00:17:07,050 --> 00:17:10,740
are the here's the battery left numbers

501
00:17:08,670 --> 00:17:12,390
that we measure by empirically measuring

502
00:17:10,740 --> 00:17:15,870
the current and the time it takes of our

503
00:17:12,390 --> 00:17:17,790
encryption so what we can see is that we

504
00:17:15,869 --> 00:17:19,800
don't quite get a 37 X and proven in

505
00:17:17,790 --> 00:17:21,240
overall battery life because the cost

506
00:17:19,800 --> 00:17:22,800
because an improvement ends up being

507
00:17:21,240 --> 00:17:24,390
amortized but the cost of symmetric key

508
00:17:22,800 --> 00:17:26,609
encryption and sampling from the sensors

509
00:17:24,390 --> 00:17:28,530
using the network and so on but we see a

510
00:17:26,609 --> 00:17:30,330
14x improvement over attribute based

511
00:17:28,530 --> 00:17:33,960
encryption and battery a lifetime where

512
00:17:30,330 --> 00:17:35,610
within 2 X of the battery lifetime using

513
00:17:33,960 --> 00:17:36,780
AES only which we consider kind of an

514
00:17:35,610 --> 00:17:39,330
upper bound and what we're able to

515
00:17:36,780 --> 00:17:41,340
achieve and furthermore the battery life

516
00:17:39,330 --> 00:17:43,860
is several years long so it's practical

517
00:17:41,340 --> 00:17:45,600
enough for for the intended use of this

518
00:17:43,860 --> 00:17:48,179
sensor widespread deployment in a

519
00:17:45,600 --> 00:17:49,949
building so one final point of when I

520
00:17:48,180 --> 00:17:51,600
mention is that we're collaborating with

521
00:17:49,950 --> 00:17:52,890
other researchers at Berkley who are

522
00:17:51,600 --> 00:17:54,629
working in the smart city space to

523
00:17:52,890 --> 00:17:56,700
actually deploy a Jedi in smart

524
00:17:54,630 --> 00:17:58,170
buildings so you can see some sample

525
00:17:56,700 --> 00:17:59,520
data from a pilot deployment a flippant

526
00:17:58,170 --> 00:18:01,080
end to end with Jedi

527
00:17:59,520 --> 00:18:02,460
we continue this in the future so if we

528
00:18:01,080 --> 00:18:04,169
have any interesting use cases would be

529
00:18:02,460 --> 00:18:05,120
happy to be happy to talk about that

530
00:18:04,170 --> 00:18:07,980
afterwards

531
00:18:05,120 --> 00:18:09,899
so in conclusion Jedi is an end-to-end

532
00:18:07,980 --> 00:18:11,580
encryption protocol for large-scale IOT

533
00:18:09,900 --> 00:18:12,960
systems that allows thinners and

534
00:18:11,580 --> 00:18:14,580
receivers to be decoupled as in

535
00:18:12,960 --> 00:18:16,290
publish/subscribe the Porsche

536
00:18:14,580 --> 00:18:18,780
decentralized a location with expiry and

537
00:18:16,290 --> 00:18:21,149
can run on devices across a spectrum of

538
00:18:18,780 --> 00:18:22,620
IOT resource constraints so it's all I

539
00:18:21,150 --> 00:18:24,800
have prepared thank you for listening

540
00:18:22,620 --> 00:18:30,918
and I'm happy to take any questions

541
00:18:24,800 --> 00:18:34,590
[Applause]

542
00:18:30,919 --> 00:18:36,630
hi I'm Lia Kistner from whom ooh you

543
00:18:34,590 --> 00:18:38,580
said if I understood it correctly that

544
00:18:36,630 --> 00:18:41,400
you're using one hierarchy for resources

545
00:18:38,580 --> 00:18:44,370
in one hierarchy for time does that mean

546
00:18:41,400 --> 00:18:50,159
that this is limited to each subscriber

547
00:18:44,370 --> 00:18:52,408
getting one resource no no so we're

548
00:18:50,159 --> 00:18:54,480
using one hierarchy for resources and

549
00:18:52,409 --> 00:18:56,309
one hierarchy for time in the attribute

550
00:18:54,480 --> 00:18:58,890
use for encryption yeah yeah but the

551
00:18:56,309 --> 00:19:00,928
reason I asked this is if I give you

552
00:18:58,890 --> 00:19:03,570
resource a and resource B and each of

553
00:19:00,929 --> 00:19:04,710
them has an expiration but they're

554
00:19:03,570 --> 00:19:07,530
different expirations

555
00:19:04,710 --> 00:19:09,440
what stopping me from using the pub the

556
00:19:07,530 --> 00:19:11,460
private key corresponding to a later

557
00:19:09,440 --> 00:19:13,890
expiration over here and just jamming it

558
00:19:11,460 --> 00:19:15,990
in this one that's an excellent question

559
00:19:13,890 --> 00:19:18,240
the reason we're able to prevent that is

560
00:19:15,990 --> 00:19:21,090
because we're encoding the exploration

561
00:19:18,240 --> 00:19:22,799
that and the time into the stay I mean

562
00:19:21,090 --> 00:19:26,010
the expiration and the resource into the

563
00:19:22,799 --> 00:19:28,020
same key opportunity to mix and match

564
00:19:26,010 --> 00:19:29,340
keys so in fact if you look at some of

565
00:19:28,020 --> 00:19:30,990
the other a cryptic schemes we could

566
00:19:29,340 --> 00:19:32,459
have chosen instead of wicked ibe for

567
00:19:30,990 --> 00:19:34,440
example if you as hierarchical identity

568
00:19:32,460 --> 00:19:36,210
based encryption then you'd be able to

569
00:19:34,440 --> 00:19:37,830
mix and match the expert and the

570
00:19:36,210 --> 00:19:38,970
resource but given that we're including

571
00:19:37,830 --> 00:19:42,539
them in the same key that is impossible

572
00:19:38,970 --> 00:19:43,470
in Jedi awesome thank you all right

573
00:19:42,539 --> 00:19:45,720
thanks

574
00:19:43,470 --> 00:19:48,299
regarding the motivation for this work

575
00:19:45,720 --> 00:19:51,150
what's the occurrence of like malicious

576
00:19:48,299 --> 00:19:54,000
or potentially exploited pub/sub brokers

577
00:19:51,150 --> 00:19:56,580
versus like and IOT device is actually

578
00:19:54,000 --> 00:19:58,919
getting exploited so so our motivation

579
00:19:56,580 --> 00:20:01,020
in protecting against the broker is that

580
00:19:58,919 --> 00:20:02,789
the broker can if it's not protected

581
00:20:01,020 --> 00:20:04,650
consists of a single point of failure in

582
00:20:02,789 --> 00:20:06,150
the system so what what happened is that

583
00:20:04,650 --> 00:20:08,130
even is that

584
00:20:06,150 --> 00:20:10,049
sure okay you have a good point in that

585
00:20:08,130 --> 00:20:12,210
if an adversary compromises one of the

586
00:20:10,049 --> 00:20:14,700
IOT devices they can see all the data

587
00:20:12,210 --> 00:20:16,350
that that device is interacting with but

588
00:20:14,700 --> 00:20:17,760
they have to compromise all the

589
00:20:16,350 --> 00:20:19,639
individual IOT devices to do that

590
00:20:17,760 --> 00:20:21,510
whereas in contrast if the program

591
00:20:19,640 --> 00:20:23,309
protected then if they compromised the

592
00:20:21,510 --> 00:20:25,890
broker they can see the data for all the

593
00:20:23,309 --> 00:20:27,149
devices in the system so that's our

594
00:20:25,890 --> 00:20:30,210
motivation for protecting against this

595
00:20:27,150 --> 00:20:31,590
particular use case but and then are

596
00:20:30,210 --> 00:20:34,740
there instances of that happening in the

597
00:20:31,590 --> 00:20:38,189
wild I'm actually not aware of any

598
00:20:34,740 --> 00:20:39,570
instances with publish/subscribe part of

599
00:20:38,190 --> 00:20:40,710
the reality is that these largely of

600
00:20:39,570 --> 00:20:42,030
publish/subscribe systems typically

601
00:20:40,710 --> 00:20:43,890
happen in industrial

602
00:20:42,030 --> 00:20:45,980
use cases and I'm actually not familiar

603
00:20:43,890 --> 00:20:48,630
with any attacks happening there though

604
00:20:45,980 --> 00:20:51,830
though I'm not sure if information about

605
00:20:48,630 --> 00:20:53,820
that even if it were all right thank you

606
00:20:51,830 --> 00:20:55,620
okay well thank you let's thank the

607
00:20:53,820 --> 00:20:56,490
speaker and all of the speakers it was a

608
00:20:55,620 --> 00:20:57,850
terrific session

609
00:20:56,490 --> 00:21:00,940
[Applause]

610
00:20:57,850 --> 00:21:00,939
[Music]

