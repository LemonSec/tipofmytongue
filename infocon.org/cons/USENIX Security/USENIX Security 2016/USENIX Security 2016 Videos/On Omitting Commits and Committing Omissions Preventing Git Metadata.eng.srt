1
00:00:10,559 --> 00:00:13,519
hello everybody i'm santiago a second

2
00:00:13,519 --> 00:00:16,640
year phd student at nyu and i'll be

3
00:00:16,640 --> 00:00:17,920
presenting this paper on admitting

4
00:00:17,920 --> 00:00:20,480
commits and committing omissions

5
00:00:20,480 --> 00:00:23,840
this work is basically

6
00:00:23,840 --> 00:00:26,080
about the design flow that we found in

7
00:00:26,080 --> 00:00:27,119
git

8
00:00:27,119 --> 00:00:29,119
and i'm going to talk about how an

9
00:00:29,119 --> 00:00:31,840
attacker can

10
00:00:31,920 --> 00:00:34,320
exploit this vulnerability what can an

11
00:00:34,320 --> 00:00:36,079
attacker achieve when he exploits this

12
00:00:36,079 --> 00:00:38,480
vulnerability how we fixed this

13
00:00:38,480 --> 00:00:40,800
vulnerability and how these fixes have

14
00:00:40,800 --> 00:00:43,600
made their way into git

15
00:00:43,600 --> 00:00:45,600
before moving forward i'd like to

16
00:00:45,600 --> 00:00:48,719
introduce my collaborators anil and resa

17
00:00:48,719 --> 00:00:54,160
from ngit and justin captos my advisor

18
00:00:54,320 --> 00:00:56,719
before starting i'd like to

19
00:00:56,719 --> 00:00:58,160
talk a little bit about the rules of the

20
00:00:58,160 --> 00:01:00,879
game maybe not all of us are familiar

21
00:01:00,879 --> 00:01:04,159
with how git works or what git really is

22
00:01:04,159 --> 00:01:06,880
so i'll start with a story about

23
00:01:06,880 --> 00:01:07,760
a

24
00:01:07,760 --> 00:01:10,560
repository in the center at your left

25
00:01:10,560 --> 00:01:12,799
and two developers you can see on your

26
00:01:12,799 --> 00:01:14,320
right hand side what's the state of the

27
00:01:14,320 --> 00:01:16,960
repository in the center in the

28
00:01:16,960 --> 00:01:18,479
in the of the repository that's on the

29
00:01:18,479 --> 00:01:19,520
center

30
00:01:19,520 --> 00:01:20,320
now

31
00:01:20,320 --> 00:01:22,159
git is a distributed version control

32
00:01:22,159 --> 00:01:24,720
system this means that every developer

33
00:01:24,720 --> 00:01:27,119
has their own copy of the repository as

34
00:01:27,119 --> 00:01:28,320
a local

35
00:01:28,320 --> 00:01:30,320
this also means that every developer has

36
00:01:30,320 --> 00:01:32,640
their own perception of what the state

37
00:01:32,640 --> 00:01:35,280
of the central repository

38
00:01:35,280 --> 00:01:37,759
when the first developer works

39
00:01:37,759 --> 00:01:39,759
he commits locally and he performs some

40
00:01:39,759 --> 00:01:42,000
change some changes to the source code

41
00:01:42,000 --> 00:01:44,000
and then he pushes the changes this will

42
00:01:44,000 --> 00:01:46,560
add a new commit object to a new branch

43
00:01:46,560 --> 00:01:47,920
called feature

44
00:01:47,920 --> 00:01:50,079
that maybe will be pulled by the second

45
00:01:50,079 --> 00:01:51,920
developer will be reviewed and may be

46
00:01:51,920 --> 00:01:54,720
merged into master after the second

47
00:01:54,720 --> 00:01:57,040
developer pushes the changes into master

48
00:01:57,040 --> 00:01:58,960
we see that the updated state of the

49
00:01:58,960 --> 00:02:01,280
repository has changes from both feature

50
00:02:01,280 --> 00:02:02,960
and master

51
00:02:02,960 --> 00:02:04,799
now maybe the first developer wants to

52
00:02:04,799 --> 00:02:07,600
pull these changes tag a release

53
00:02:07,600 --> 00:02:10,000
and push the new tag for

54
00:02:10,000 --> 00:02:13,280
package maintainers and users to

55
00:02:13,280 --> 00:02:15,440
fetch the newest version of kit

56
00:02:15,440 --> 00:02:17,840
of the software

57
00:02:17,840 --> 00:02:18,720
now

58
00:02:18,720 --> 00:02:20,560
what i want to

59
00:02:20,560 --> 00:02:22,400
emphasize is that these repositories can

60
00:02:22,400 --> 00:02:24,959
be compromised

61
00:02:24,959 --> 00:02:26,800
while we were having a chips in

62
00:02:26,800 --> 00:02:28,080
guacamole

63
00:02:28,080 --> 00:02:30,959
tuesday night someone was trying to

64
00:02:30,959 --> 00:02:32,959
actively break into a

65
00:02:32,959 --> 00:02:35,360
the github account of a developer for

66
00:02:35,360 --> 00:02:37,200
requests which is a

67
00:02:37,200 --> 00:02:38,560
ca

68
00:02:38,560 --> 00:02:40,000
well a

69
00:02:40,000 --> 00:02:41,120
general

70
00:02:41,120 --> 00:02:44,400
http request framework that also handles

71
00:02:44,400 --> 00:02:47,040
ca verification

72
00:02:47,040 --> 00:02:48,959
i

73
00:02:48,959 --> 00:02:51,200
i agree with him and i quote that a

74
00:02:51,200 --> 00:02:54,959
crafty attacker he says a government or

75
00:02:54,959 --> 00:02:57,760
a powerful attacker could just sneak a

76
00:02:57,760 --> 00:03:00,000
little back door that would be then

77
00:03:00,000 --> 00:03:02,319
propagated into systems running in

78
00:03:02,319 --> 00:03:06,080
almost major tech corporation

79
00:03:06,080 --> 00:03:08,239
and exploit them afterwards

80
00:03:08,239 --> 00:03:10,159
now this is not the first it hap first

81
00:03:10,159 --> 00:03:12,080
time it happens the linux kernel was

82
00:03:12,080 --> 00:03:13,200
hacked

83
00:03:13,200 --> 00:03:14,879
there was a man in the middle between

84
00:03:14,879 --> 00:03:16,720
china and github

85
00:03:16,720 --> 00:03:19,200
between users in china and github

86
00:03:19,200 --> 00:03:21,680
the ruby gems was hacked

87
00:03:21,680 --> 00:03:24,000
sourceforge was also hacked

88
00:03:24,000 --> 00:03:26,000
uh a couple of weeks ago

89
00:03:26,000 --> 00:03:27,840
fasthop was hacked and it deleted the

90
00:03:27,840 --> 00:03:28,879
mbr

91
00:03:28,879 --> 00:03:30,560
entries of many people

92
00:03:30,560 --> 00:03:32,640
the adobe was another

93
00:03:32,640 --> 00:03:34,400
major hack

94
00:03:34,400 --> 00:03:37,840
the fsf was compromised f pro ftpd

95
00:03:37,840 --> 00:03:39,040
google

96
00:03:39,040 --> 00:03:41,519
red hat

97
00:03:41,519 --> 00:03:44,560
now i want to

98
00:03:45,200 --> 00:03:48,080
reiterate on this uh compromises happen

99
00:03:48,080 --> 00:03:49,519
compromises on source code happen

100
00:03:49,519 --> 00:03:50,959
because they're really attractive to

101
00:03:50,959 --> 00:03:52,879
attackers

102
00:03:52,879 --> 00:03:54,159
now

103
00:03:54,159 --> 00:03:57,280
luckily we have git and we have some get

104
00:03:57,280 --> 00:03:59,280
some security features we get

105
00:03:59,280 --> 00:04:00,400
the most

106
00:04:00,400 --> 00:04:03,120
well-known is hash chaining right

107
00:04:03,120 --> 00:04:05,760
if someone compromises a repository they

108
00:04:05,760 --> 00:04:06,799
cannot

109
00:04:06,799 --> 00:04:09,200
put changes for that far down into the

110
00:04:09,200 --> 00:04:11,280
history and expect them to be propagated

111
00:04:11,280 --> 00:04:12,879
it also means that if someone tampers

112
00:04:12,879 --> 00:04:15,040
with the commits

113
00:04:15,040 --> 00:04:17,519
the history will

114
00:04:17,519 --> 00:04:18,399
fail

115
00:04:18,399 --> 00:04:20,478
to tell to

116
00:04:20,478 --> 00:04:22,079
to verify

117
00:04:22,079 --> 00:04:22,960
now

118
00:04:22,960 --> 00:04:24,720
we also have git commit and tax

119
00:04:24,720 --> 00:04:26,880
signatures that prevent attackers from

120
00:04:26,880 --> 00:04:29,040
creating new commit objects to new

121
00:04:29,040 --> 00:04:31,919
attack objects so every change in the

122
00:04:31,919 --> 00:04:34,080
history could be authenticated and

123
00:04:34,080 --> 00:04:36,320
attributed to a user

124
00:04:36,320 --> 00:04:38,160
we also have a push certificates which

125
00:04:38,160 --> 00:04:41,680
is a relatively recent edition i'll talk

126
00:04:41,680 --> 00:04:42,880
a little bit more about this later

127
00:04:42,880 --> 00:04:44,880
they're not so popular i haven't seen

128
00:04:44,880 --> 00:04:46,720
them in production yet

129
00:04:46,720 --> 00:04:50,320
however things can go wrong

130
00:04:50,479 --> 00:04:51,919
i'd like to

131
00:04:51,919 --> 00:04:54,840
show you how things can go wrong with an

132
00:04:54,840 --> 00:04:58,280
example i was trying to install django

133
00:04:58,280 --> 00:05:02,320
1.9.3 in my own modified

134
00:05:02,320 --> 00:05:04,000
github server

135
00:05:04,000 --> 00:05:06,639
github repository and for some reason i

136
00:05:06,639 --> 00:05:09,840
ended up with django 1.4.11

137
00:05:09,840 --> 00:05:11,759
interestingly if you try to verify the

138
00:05:11,759 --> 00:05:13,039
tag

139
00:05:13,039 --> 00:05:15,680
gpg verification passes so everything

140
00:05:15,680 --> 00:05:17,520
should be fine i'm actually running code

141
00:05:17,520 --> 00:05:20,320
that's uh that's valid code right

142
00:05:20,320 --> 00:05:22,880
if i ask for a little bit more detail i

143
00:05:22,880 --> 00:05:25,039
realize that i'm actually getting the

144
00:05:25,039 --> 00:05:29,039
right the wrong tag i'm getting 1.11

145
00:05:29,039 --> 00:05:30,800
needless to say

146
00:05:30,800 --> 00:05:33,039
django 1.4.11

147
00:05:33,039 --> 00:05:33,840
is

148
00:05:33,840 --> 00:05:35,360
vulnerable for more than eight remote

149
00:05:35,360 --> 00:05:37,520
code execution vulnerabilities

150
00:05:37,520 --> 00:05:39,600
and i also got the false impression that

151
00:05:39,600 --> 00:05:41,360
everything was

152
00:05:41,360 --> 00:05:43,360
going smooth because gpg verification

153
00:05:43,360 --> 00:05:45,039
told me everything was fine

154
00:05:45,039 --> 00:05:45,919
now

155
00:05:45,919 --> 00:05:48,400
why did this happen

156
00:05:48,400 --> 00:05:51,360
let me introduce you to the problem then

157
00:05:51,360 --> 00:05:53,600
the problem is that some git metadata is

158
00:05:53,600 --> 00:05:56,240
not signed if we run tree on the git

159
00:05:56,240 --> 00:05:58,400
metadata folder we'll see that some

160
00:05:58,400 --> 00:06:01,199
elements such as objects which are git

161
00:06:01,199 --> 00:06:03,199
tags and git commits

162
00:06:03,199 --> 00:06:06,639
are actually signed that's what gpg gpg

163
00:06:06,639 --> 00:06:07,840
signing does

164
00:06:07,840 --> 00:06:09,120
there's some other stuff such as

165
00:06:09,120 --> 00:06:12,400
references which are pointers to this

166
00:06:12,400 --> 00:06:14,240
tag and commit objects which are not

167
00:06:14,240 --> 00:06:15,520
signed

168
00:06:15,520 --> 00:06:17,840
this is our target

169
00:06:17,840 --> 00:06:20,160
now an attacker with right access to the

170
00:06:20,160 --> 00:06:21,520
repository could be a malicious

171
00:06:21,520 --> 00:06:23,280
developer that doesn't want to want to

172
00:06:23,280 --> 00:06:26,400
authenticate any actions or it could be

173
00:06:26,400 --> 00:06:28,479
someone who broke into a repository

174
00:06:28,479 --> 00:06:30,240
could modify this information and make

175
00:06:30,240 --> 00:06:32,000
it look and change the state of the

176
00:06:32,000 --> 00:06:34,639
repository into something that maybe

177
00:06:34,639 --> 00:06:37,840
may cause unintended actions

178
00:06:37,840 --> 00:06:39,440
of course after these attacks are

179
00:06:39,440 --> 00:06:40,880
performed it would look like a regular

180
00:06:40,880 --> 00:06:42,639
git operation so they're really really

181
00:06:42,639 --> 00:06:44,400
subtle

182
00:06:44,400 --> 00:06:47,759
with this knowledge and having seen that

183
00:06:47,759 --> 00:06:50,160
these attacks can be performed just by

184
00:06:50,160 --> 00:06:51,520
slightly tweaking what's on the

185
00:06:51,520 --> 00:06:53,520
reference files we came up with a

186
00:06:53,520 --> 00:06:56,880
metadata manipulation attack taxonomy

187
00:06:56,880 --> 00:06:57,759
we

188
00:06:57,759 --> 00:07:01,440
found a catalog of seven different

189
00:07:01,440 --> 00:07:04,319
metadata manipulation attacks

190
00:07:04,319 --> 00:07:06,000
for in the interest of time i'll only

191
00:07:06,000 --> 00:07:08,080
focus on the first three which i

192
00:07:08,080 --> 00:07:10,400
think they will convey what exactly is

193
00:07:10,400 --> 00:07:12,080
happening with these things

194
00:07:12,080 --> 00:07:14,240
and if you want to learn a little bit

195
00:07:14,240 --> 00:07:15,759
more about the rest you can of course

196
00:07:15,759 --> 00:07:18,000
read the paper

197
00:07:18,000 --> 00:07:19,520
now let's go back to a central

198
00:07:19,520 --> 00:07:21,440
repository that's compromised you see a

199
00:07:21,440 --> 00:07:22,800
little devil there

200
00:07:22,800 --> 00:07:24,800
there's a buggy branch there that says

201
00:07:24,800 --> 00:07:26,479
do not merge maybe it's experimental

202
00:07:26,479 --> 00:07:28,560
code maybe it's apples duplicate it go

203
00:07:28,560 --> 00:07:30,400
to

204
00:07:30,400 --> 00:07:32,240
and someone is

205
00:07:32,240 --> 00:07:34,960
asking the repository for to know what's

206
00:07:34,960 --> 00:07:36,240
the state

207
00:07:36,240 --> 00:07:38,000
now maybe the repository wants to

208
00:07:38,000 --> 00:07:39,759
equivocate then because it's malicious

209
00:07:39,759 --> 00:07:41,759
and will change the reference pointer

210
00:07:41,759 --> 00:07:44,479
that was originally master to this do

211
00:07:44,479 --> 00:07:46,479
not merge branch

212
00:07:46,479 --> 00:07:48,879
of course this will make the developer

213
00:07:48,879 --> 00:07:50,479
think that there's new changes upstream

214
00:07:50,479 --> 00:07:52,479
and actually git will automatically

215
00:07:52,479 --> 00:07:53,759
merge this

216
00:07:53,759 --> 00:07:55,840
after this happens then we manage to

217
00:07:55,840 --> 00:07:57,919
trick the user into committing and

218
00:07:57,919 --> 00:07:59,599
signing a change that contains a

219
00:07:59,599 --> 00:08:01,599
vulnerable bug a vulnerable piece of

220
00:08:01,599 --> 00:08:04,878
code into the production

221
00:08:07,039 --> 00:08:09,120
analogous to the example that i gave you

222
00:08:09,120 --> 00:08:10,800
in the beginning of the talk

223
00:08:10,800 --> 00:08:14,080
there's a tag teleport attack in which a

224
00:08:14,080 --> 00:08:16,400
reference is teleported into another

225
00:08:16,400 --> 00:08:18,319
place in the history of git

226
00:08:18,319 --> 00:08:20,800
in this case we have a tag that's known

227
00:08:20,800 --> 00:08:23,000
to be vulnerable think about django

228
00:08:23,000 --> 00:08:26,400
1.4.11 and we also have a version 1.1

229
00:08:26,400 --> 00:08:28,160
which should be running smoothly which

230
00:08:28,160 --> 00:08:29,280
should be

231
00:08:29,280 --> 00:08:31,280
trustworthy to some extent

232
00:08:31,280 --> 00:08:33,519
now a developer wants to

233
00:08:33,519 --> 00:08:34,559
install

234
00:08:34,559 --> 00:08:37,360
version 1.1 because that's the trusted

235
00:08:37,360 --> 00:08:38,640
one or the

236
00:08:38,640 --> 00:08:40,559
non-vulnerable one

237
00:08:40,559 --> 00:08:43,200
and again the server may want to equip

238
00:08:43,200 --> 00:08:43,919
it

239
00:08:43,919 --> 00:08:46,720
this attack teleport attack simply

240
00:08:46,720 --> 00:08:50,240
requires the attacker to move a pointer

241
00:08:50,240 --> 00:08:52,240
back into the

242
00:08:52,240 --> 00:08:53,519
previous stack

243
00:08:53,519 --> 00:08:55,519
of course this will be installed and

244
00:08:55,519 --> 00:08:57,839
most of the package managers in which we

245
00:08:57,839 --> 00:08:59,839
tested this simple attack

246
00:08:59,839 --> 00:09:02,320
uh resulted in a clean installation of

247
00:09:02,320 --> 00:09:03,680
everything

248
00:09:03,680 --> 00:09:06,000
even in conda that actually you can ask

249
00:09:06,000 --> 00:09:09,440
it to verify gpg signatures

250
00:09:09,440 --> 00:09:11,120
anyway

251
00:09:11,120 --> 00:09:13,200
in addition to this there's other types

252
00:09:13,200 --> 00:09:14,880
of attacks this is

253
00:09:14,880 --> 00:09:17,760
a rollback attack a rollback attack

254
00:09:17,760 --> 00:09:19,440
requires an

255
00:09:19,440 --> 00:09:22,399
well will just be so that an attacker

256
00:09:22,399 --> 00:09:23,839
pulls back

257
00:09:23,839 --> 00:09:26,320
in the history sort of like rewinding

258
00:09:26,320 --> 00:09:28,720
the building into something else

259
00:09:28,720 --> 00:09:31,120
imagine there's a developer

260
00:09:31,120 --> 00:09:33,120
that just made a new feature

261
00:09:33,120 --> 00:09:35,279
that went through the code review and

262
00:09:35,279 --> 00:09:37,360
some bug was preemptively found by the

263
00:09:37,360 --> 00:09:39,120
developer that's above

264
00:09:39,120 --> 00:09:41,920
now he committed he committed the fix

265
00:09:41,920 --> 00:09:43,600
and he pushed it to the feature branch

266
00:09:43,600 --> 00:09:44,320
so

267
00:09:44,320 --> 00:09:46,720
the resulting merge should not happen

268
00:09:46,720 --> 00:09:49,440
the bug it's fixed right by the

269
00:09:49,440 --> 00:09:51,920
subsequent commit however an attacker

270
00:09:51,920 --> 00:09:53,519
could lie about this

271
00:09:53,519 --> 00:09:55,360
we could rewind the branch

272
00:09:55,360 --> 00:09:57,680
and upon merging we have a vulnerable

273
00:09:57,680 --> 00:10:02,079
piece of code again in production

274
00:10:03,680 --> 00:10:05,120
now

275
00:10:05,120 --> 00:10:06,800
this is pretty much what you can achieve

276
00:10:06,800 --> 00:10:09,040
with these kinds of things it's a really

277
00:10:09,040 --> 00:10:10,880
simple attack it's just tinkering with

278
00:10:10,880 --> 00:10:14,399
what's on the reference files you could

279
00:10:14,399 --> 00:10:16,160
present you could

280
00:10:16,160 --> 00:10:19,360
include buggy code into production

281
00:10:19,360 --> 00:10:21,519
by tracking

282
00:10:21,519 --> 00:10:23,200
people into merging things you could

283
00:10:23,200 --> 00:10:24,000
also

284
00:10:24,000 --> 00:10:27,120
make package managers or users or even

285
00:10:27,120 --> 00:10:29,519
get some modules during initialization

286
00:10:29,519 --> 00:10:32,160
and include the vulnerable vulnerable

287
00:10:32,160 --> 00:10:34,240
version of the code you could also omit

288
00:10:34,240 --> 00:10:36,079
the security patch like it was on the

289
00:10:36,079 --> 00:10:37,600
rollback attacks

290
00:10:37,600 --> 00:10:38,720
and

291
00:10:38,720 --> 00:10:39,600
delete

292
00:10:39,600 --> 00:10:42,399
delete references and other things

293
00:10:42,399 --> 00:10:45,360
that may just result in annoyance

294
00:10:45,360 --> 00:10:46,959
now

295
00:10:46,959 --> 00:10:48,320
seeing this we

296
00:10:48,320 --> 00:10:50,880
we and all of the team with try to find

297
00:10:50,880 --> 00:10:52,399
a way to fix this

298
00:10:52,399 --> 00:10:53,680
we

299
00:10:53,680 --> 00:10:55,600
recognize that this is actually really

300
00:10:55,600 --> 00:10:58,800
similar to fork consistency attacks

301
00:10:58,800 --> 00:11:01,120
now the problem is that we cannot use

302
00:11:01,120 --> 00:11:03,040
for consistency attacks because of two

303
00:11:03,040 --> 00:11:04,320
main reasons

304
00:11:04,320 --> 00:11:06,079
first of all they tried

305
00:11:06,079 --> 00:11:08,399
for consistency systems most of the time

306
00:11:08,399 --> 00:11:09,600
try to

307
00:11:09,600 --> 00:11:11,839
create a

308
00:11:11,839 --> 00:11:14,320
consistent state of every single element

309
00:11:14,320 --> 00:11:16,320
within all of the repositories the

310
00:11:16,320 --> 00:11:18,560
problem with this is that this doesn't

311
00:11:18,560 --> 00:11:20,959
play well with some distributed systems

312
00:11:20,959 --> 00:11:22,560
also some other

313
00:11:22,560 --> 00:11:24,640
consistency systems assume that you will

314
00:11:24,640 --> 00:11:26,240
be able to call home

315
00:11:26,240 --> 00:11:27,200
every

316
00:11:27,200 --> 00:11:30,399
30 seconds every 10 minutes and if i for

317
00:11:30,399 --> 00:11:32,160
example wanted to write some code in the

318
00:11:32,160 --> 00:11:34,160
playing then i cannot use a

319
00:11:34,160 --> 00:11:36,560
for consistency system

320
00:11:36,560 --> 00:11:37,839
now

321
00:11:37,839 --> 00:11:39,600
given this and given that git is

322
00:11:39,600 --> 00:11:41,120
actually really smart in the way it

323
00:11:41,120 --> 00:11:43,440
synchronizes and identifies which

324
00:11:43,440 --> 00:11:45,120
elements are

325
00:11:45,120 --> 00:11:47,920
needed to synchronize then we piggyback

326
00:11:47,920 --> 00:11:49,680
on git

327
00:11:49,680 --> 00:11:52,240
we also assume that uh some

328
00:11:52,240 --> 00:11:53,680
like large

329
00:11:53,680 --> 00:11:56,399
scale attacks like four star attacks are

330
00:11:56,399 --> 00:11:59,519
not a concern because if you divide

331
00:11:59,519 --> 00:12:02,320
two groups of developers separately they

332
00:12:02,320 --> 00:12:04,320
will if they don't see changes from each

333
00:12:04,320 --> 00:12:06,240
other they will start wondering that

334
00:12:06,240 --> 00:12:08,320
something's wrong we've got element

335
00:12:08,320 --> 00:12:10,480
we've got tools like mailing lists bug

336
00:12:10,480 --> 00:12:13,200
trackers slack irc

337
00:12:13,200 --> 00:12:15,600
etc that can let the developers

338
00:12:15,600 --> 00:12:18,000
coordinate from the outside the trick

339
00:12:18,000 --> 00:12:19,760
here is that all of the attackers that i

340
00:12:19,760 --> 00:12:22,160
presented are actually

341
00:12:22,160 --> 00:12:25,040
temporary they are reconcilable fork

342
00:12:25,040 --> 00:12:27,120
attacks the state of the repository

343
00:12:27,120 --> 00:12:29,360
breaks and changes for

344
00:12:29,360 --> 00:12:31,600
five minutes at most or something and

345
00:12:31,600 --> 00:12:33,600
then it comes back to a state in which

346
00:12:33,600 --> 00:12:35,279
everyone agrees that everyone everything

347
00:12:35,279 --> 00:12:36,880
is fine

348
00:12:36,880 --> 00:12:39,120
we also assume that the repository can

349
00:12:39,120 --> 00:12:40,639
be initialized on the route of trust

350
00:12:40,639 --> 00:12:42,800
this is although

351
00:12:42,800 --> 00:12:45,279
key management is an issue and there's

352
00:12:45,279 --> 00:12:47,519
many clever solutions in how to handle

353
00:12:47,519 --> 00:12:50,800
this we're assuming that

354
00:12:50,800 --> 00:12:52,160
this can be integrated this can be

355
00:12:52,160 --> 00:12:54,160
integrated into a system and actually we

356
00:12:54,160 --> 00:12:55,519
integrated

357
00:12:55,519 --> 00:12:57,360
key management into our system in a

358
00:12:57,360 --> 00:13:00,000
really simplistic way

359
00:13:00,000 --> 00:13:02,560
now without further ado i'll introduce

360
00:13:02,560 --> 00:13:04,079
my solution

361
00:13:04,079 --> 00:13:05,519
we'd like to

362
00:13:05,519 --> 00:13:07,440
we have three main goals when we thought

363
00:13:07,440 --> 00:13:09,120
of our solution first of all we wanted

364
00:13:09,120 --> 00:13:10,800
to preserve all of the git workflows

365
00:13:10,800 --> 00:13:12,720
this means that if someone is using git

366
00:13:12,720 --> 00:13:14,720
send email to send a patch to a mailing

367
00:13:14,720 --> 00:13:17,040
list that should work or if someone is

368
00:13:17,040 --> 00:13:18,959
using github or gitlab or whatever that

369
00:13:18,959 --> 00:13:21,200
should also work this means that you

370
00:13:21,200 --> 00:13:23,839
that we cannot make assumptions in how

371
00:13:23,839 --> 00:13:25,839
people should use git

372
00:13:25,839 --> 00:13:28,480
we also align with what's uh

373
00:13:28,480 --> 00:13:31,040
git's philosophy of supporting older

374
00:13:31,040 --> 00:13:33,360
versions and backwards compatibility

375
00:13:33,360 --> 00:13:35,680
right now if you are running a server

376
00:13:35,680 --> 00:13:38,399
with kit 2.9.4

377
00:13:38,399 --> 00:13:42,399
you can talk with a server running 1.7.0

378
00:13:42,399 --> 00:13:44,560
and vice versa this means that

379
00:13:44,560 --> 00:13:47,120
we couldn't make any drastic or like

380
00:13:47,120 --> 00:13:49,680
disruptive changes into the way that pac

381
00:13:49,680 --> 00:13:51,519
protocol worked

382
00:13:51,519 --> 00:13:53,680
and we also want to provide the

383
00:13:53,680 --> 00:13:55,199
increased security partial adoption

384
00:13:55,199 --> 00:13:56,560
scenarios this is also a really

385
00:13:56,560 --> 00:13:58,639
realistic thing because

386
00:13:58,639 --> 00:14:00,399
by no one's

387
00:14:00,399 --> 00:14:02,399
not everyone's going to use our solution

388
00:14:02,399 --> 00:14:04,720
at the offset we introduce this and

389
00:14:04,720 --> 00:14:06,959
we'll eventually start providing greater

390
00:14:06,959 --> 00:14:10,480
benefits as people start using

391
00:14:10,480 --> 00:14:12,720
we also

392
00:14:12,720 --> 00:14:15,680
we also focused on these three qualities

393
00:14:15,680 --> 00:14:16,399
that

394
00:14:16,399 --> 00:14:18,079
and we are sure that if we provide these

395
00:14:18,079 --> 00:14:19,680
qualities then we are able to prevent

396
00:14:19,680 --> 00:14:21,279
these attacks and many

397
00:14:21,279 --> 00:14:22,240
and

398
00:14:22,240 --> 00:14:23,440
ensure

399
00:14:23,440 --> 00:14:26,320
that the repository cannot equivocate on

400
00:14:26,320 --> 00:14:28,240
the metadata files

401
00:14:28,240 --> 00:14:30,639
now if you see these three uh

402
00:14:30,639 --> 00:14:32,399
characteristics you'll see that

403
00:14:32,399 --> 00:14:33,839
preventing modification of committed

404
00:14:33,839 --> 00:14:35,920
data is actually provided by git

405
00:14:35,920 --> 00:14:38,160
ensuring that con consistent repository

406
00:14:38,160 --> 00:14:39,760
state is provided by something that we

407
00:14:39,760 --> 00:14:41,839
designed called the reference state log

408
00:14:41,839 --> 00:14:43,600
and we also added something new that's

409
00:14:43,600 --> 00:14:45,920
called a non-spec which will ensure that

410
00:14:45,920 --> 00:14:47,360
all of the

411
00:14:47,360 --> 00:14:49,440
that the repository presents fresh

412
00:14:49,440 --> 00:14:51,519
information

413
00:14:51,519 --> 00:14:53,120
now in the interest of time i'll only

414
00:14:53,120 --> 00:14:55,839
focus on the reference state law

415
00:14:55,839 --> 00:14:57,440
reference to state log is a really

416
00:14:57,440 --> 00:14:59,600
really simple protocol or addition to

417
00:14:59,600 --> 00:15:00,480
get

418
00:15:00,480 --> 00:15:02,639
instead of doing a regular push which

419
00:15:02,639 --> 00:15:04,880
only sends the objects this is what you

420
00:15:04,880 --> 00:15:06,800
should see here

421
00:15:06,800 --> 00:15:09,519
it also pushes a signed statement that

422
00:15:09,519 --> 00:15:10,560
says

423
00:15:10,560 --> 00:15:12,880
this is the references that i'm changing

424
00:15:12,880 --> 00:15:14,800
this is what you should be seeing now

425
00:15:14,800 --> 00:15:16,800
when these changes make it to the other

426
00:15:16,800 --> 00:15:19,279
side then

427
00:15:19,279 --> 00:15:21,519
the objects are transmitted as they are

428
00:15:21,519 --> 00:15:24,320
usually done and there's also some

429
00:15:24,320 --> 00:15:26,320
consistency assurance that the

430
00:15:26,320 --> 00:15:27,519
references were changed by an

431
00:15:27,519 --> 00:15:29,680
authenticated user

432
00:15:29,680 --> 00:15:32,480
now a reference state log is basically a

433
00:15:32,480 --> 00:15:35,040
series of rsl push entries

434
00:15:35,040 --> 00:15:37,199
these rsl push entries contain really

435
00:15:37,199 --> 00:15:39,519
simple information which is what's the

436
00:15:39,519 --> 00:15:41,279
reference that's changing like branch

437
00:15:41,279 --> 00:15:42,560
master

438
00:15:42,560 --> 00:15:43,759
what's the

439
00:15:43,759 --> 00:15:45,519
actual commit object in which the branch

440
00:15:45,519 --> 00:15:46,959
should be pointing to

441
00:15:46,959 --> 00:15:49,279
a hash of the previous entries so that

442
00:15:49,279 --> 00:15:51,600
an attacker cannot remove rsl push

443
00:15:51,600 --> 00:15:54,079
entries or it cannot change the ordering

444
00:15:54,079 --> 00:15:56,000
of the entries or anything of the like

445
00:15:56,000 --> 00:15:57,360
and finally a signature that

446
00:15:57,360 --> 00:16:00,240
authenticates the user

447
00:16:00,240 --> 00:16:03,839
that made the there's a specific change

448
00:16:03,839 --> 00:16:06,560
we then with this really simple solution

449
00:16:06,560 --> 00:16:09,759
we made a prototype we did something

450
00:16:09,759 --> 00:16:12,880
that's called the git extensions

451
00:16:12,880 --> 00:16:15,839
it's pretty much a

452
00:16:16,959 --> 00:16:19,040
script that you have to the path and you

453
00:16:19,040 --> 00:16:21,680
can use it as you would use any git push

454
00:16:21,680 --> 00:16:23,519
or get patch operation

455
00:16:23,519 --> 00:16:25,279
and we made it so that the reference

456
00:16:25,279 --> 00:16:27,759
state log lives on a separate branch in

457
00:16:27,759 --> 00:16:29,279
the in as a special branch in the

458
00:16:29,279 --> 00:16:31,759
repository this means that

459
00:16:31,759 --> 00:16:33,519
we didn't change any of the protocol we

460
00:16:33,519 --> 00:16:34,800
didn't

461
00:16:34,800 --> 00:16:37,120
actually do anything weird to get we

462
00:16:37,120 --> 00:16:38,800
just managed to

463
00:16:38,800 --> 00:16:42,000
send the the rsl along with the regular

464
00:16:42,000 --> 00:16:43,279
push

465
00:16:43,279 --> 00:16:45,519
as long as you would write get secure

466
00:16:45,519 --> 00:16:48,160
push instead of git push

467
00:16:48,160 --> 00:16:50,480
now synchronization is really easy

468
00:16:50,480 --> 00:16:52,240
if we go back to the example

469
00:16:52,240 --> 00:16:54,320
from which i started in this uh

470
00:16:54,320 --> 00:16:55,600
presentation

471
00:16:55,600 --> 00:16:57,120
we had the developer worked and

472
00:16:57,120 --> 00:16:59,440
committed locally and this time he'll do

473
00:16:59,440 --> 00:17:01,040
a git secure push

474
00:17:01,040 --> 00:17:02,320
instead of only having the feature

475
00:17:02,320 --> 00:17:05,280
branch added to the to the repository we

476
00:17:05,280 --> 00:17:07,760
also have a new commit that contains all

477
00:17:07,760 --> 00:17:10,640
of the information about this rsl entry

478
00:17:10,640 --> 00:17:12,319
when the other developer

479
00:17:12,319 --> 00:17:14,079
does a secure

480
00:17:14,079 --> 00:17:16,319
secure pull or fetch

481
00:17:16,319 --> 00:17:17,280
he'll

482
00:17:17,280 --> 00:17:18,880
be able to

483
00:17:18,880 --> 00:17:20,480
verify and ensure that all of the

484
00:17:20,480 --> 00:17:22,880
references are in the right place

485
00:17:22,880 --> 00:17:24,480
once the merge is done that's what

486
00:17:24,480 --> 00:17:26,559
happened in our example before

487
00:17:26,559 --> 00:17:29,679
and the push is made back to master and

488
00:17:29,679 --> 00:17:31,919
new rsl entry with a new state of the

489
00:17:31,919 --> 00:17:34,080
repository is pushed when the other

490
00:17:34,080 --> 00:17:35,840
developer pulls

491
00:17:35,840 --> 00:17:38,720
he'll be he or she'll be sure that

492
00:17:38,720 --> 00:17:41,840
the state of the references are correct

493
00:17:41,840 --> 00:17:44,720
now verification is really simple

494
00:17:44,720 --> 00:17:46,640
on the rsl we just want to be sure that

495
00:17:46,640 --> 00:17:48,400
all of the entries are signed by a

496
00:17:48,400 --> 00:17:50,000
trusted party

497
00:17:50,000 --> 00:17:52,480
we also want to make sure that the rsl

498
00:17:52,480 --> 00:17:54,640
entries are linked together this is just

499
00:17:54,640 --> 00:17:56,559
doing simple

500
00:17:56,559 --> 00:17:58,320
uh hash chaining in the same way that

501
00:17:58,320 --> 00:18:00,720
git does right now and also that the

502
00:18:00,720 --> 00:18:02,000
references are pointing in the right

503
00:18:02,000 --> 00:18:03,280
place this is what we wanted to achieve

504
00:18:03,280 --> 00:18:06,080
in the first place right

505
00:18:07,120 --> 00:18:09,679
now with our prototype we evaluate it

506
00:18:09,679 --> 00:18:12,240
and check whether our solution is

507
00:18:12,240 --> 00:18:14,640
practical and how

508
00:18:14,640 --> 00:18:16,799
how much would it cost to provide these

509
00:18:16,799 --> 00:18:18,640
kind of security guarantees to users of

510
00:18:18,640 --> 00:18:19,760
git

511
00:18:19,760 --> 00:18:21,919
we

512
00:18:22,080 --> 00:18:23,200
we basically

513
00:18:23,200 --> 00:18:25,200
checked that the uh

514
00:18:25,200 --> 00:18:28,240
that the solution was proper this means

515
00:18:28,240 --> 00:18:29,280
that

516
00:18:29,280 --> 00:18:30,559
if you want to perform any of these

517
00:18:30,559 --> 00:18:33,360
attacks you would have to

518
00:18:33,360 --> 00:18:34,640
you have to have an attacker that

519
00:18:34,640 --> 00:18:36,240
contains a key that can authenticate the

520
00:18:36,240 --> 00:18:37,760
change in the rsl

521
00:18:37,760 --> 00:18:40,000
or an attacker that could be able to

522
00:18:40,000 --> 00:18:43,039
present older versions of the rsl to a

523
00:18:43,039 --> 00:18:44,640
user and that's why we added the

524
00:18:44,640 --> 00:18:45,919
non-space

525
00:18:45,919 --> 00:18:47,840
with the non-spac none of the rollback

526
00:18:47,840 --> 00:18:50,240
attacks should happen and the

527
00:18:50,240 --> 00:18:51,840
teleport attacks shouldn't happen with

528
00:18:51,840 --> 00:18:54,240
the rs with the teleport or deletion

529
00:18:54,240 --> 00:18:55,840
attack shouldn't happen with the rsl

530
00:18:55,840 --> 00:18:57,919
push entries

531
00:18:57,919 --> 00:19:01,520
we also explored and compared our rsl

532
00:19:01,520 --> 00:19:04,000
and nonspark here compares to other

533
00:19:04,000 --> 00:19:06,400
solutions push certificates are similar

534
00:19:06,400 --> 00:19:09,520
to the rsl in that they contain

535
00:19:09,520 --> 00:19:12,160
uh similar fields but they are not

536
00:19:12,160 --> 00:19:14,400
changed together and they also change

537
00:19:14,400 --> 00:19:16,640
the way that the

538
00:19:16,640 --> 00:19:18,160
well they extended the way that pack

539
00:19:18,160 --> 00:19:20,799
protocol works so you have a

540
00:19:20,799 --> 00:19:23,039
bigger well you need a newer version of

541
00:19:23,039 --> 00:19:25,679
git to be able to use push certificates

542
00:19:25,679 --> 00:19:26,880
they also

543
00:19:26,880 --> 00:19:28,400
since they do not have something that's

544
00:19:28,400 --> 00:19:30,880
equivalent to a non-space then rollback

545
00:19:30,880 --> 00:19:33,679
attacks and duplication attacks also

546
00:19:33,679 --> 00:19:36,160
cannot be prevented either or something

547
00:19:36,160 --> 00:19:37,919
really important to notice is that also

548
00:19:37,919 --> 00:19:41,280
push certificates do not have a default

549
00:19:41,280 --> 00:19:42,960
distribution mechanism this means that

550
00:19:42,960 --> 00:19:44,400
you may have to

551
00:19:44,400 --> 00:19:46,880
have a separate server or some other

552
00:19:46,880 --> 00:19:49,360
instance of something to be able to host

553
00:19:49,360 --> 00:19:51,360
and to distribute the push certificates

554
00:19:51,360 --> 00:19:53,840
to other users

555
00:19:54,640 --> 00:19:55,760
we also

556
00:19:55,760 --> 00:19:57,760
made sure that the partial adoption of

557
00:19:57,760 --> 00:20:01,919
our defense which is one of the goals is

558
00:20:02,400 --> 00:20:05,600
is achieved and we see that although all

559
00:20:05,600 --> 00:20:08,480
the attacks are possible we reduce the

560
00:20:08,480 --> 00:20:10,080
attack surface by

561
00:20:10,080 --> 00:20:12,000
only allowing commits after the latest

562
00:20:12,000 --> 00:20:14,799
rsl entry was made this is similar to

563
00:20:14,799 --> 00:20:16,559
just reducing the number of rough

564
00:20:16,559 --> 00:20:19,600
gadgets that someone can use

565
00:20:19,600 --> 00:20:22,320
we also checked the storage size

566
00:20:22,320 --> 00:20:25,600
in the right hand side of the

567
00:20:25,600 --> 00:20:27,120
of the table you'll see that most of the

568
00:20:27,120 --> 00:20:28,799
time this is under one percent that this

569
00:20:28,799 --> 00:20:30,400
is actually less than what push

570
00:20:30,400 --> 00:20:32,480
certificates require

571
00:20:32,480 --> 00:20:34,480
we also check the network overhead is

572
00:20:34,480 --> 00:20:36,880
less than 25 kilobytes

573
00:20:36,880 --> 00:20:38,799
uh and

574
00:20:38,799 --> 00:20:40,320
it's double round through time but this

575
00:20:40,320 --> 00:20:41,760
is

576
00:20:41,760 --> 00:20:43,840
this will go away once the complete

577
00:20:43,840 --> 00:20:45,679
solution is part of the git

578
00:20:45,679 --> 00:20:46,840
pack

579
00:20:46,840 --> 00:20:49,440
protocol then we

580
00:20:49,440 --> 00:20:51,600
made all of this theory and this is what

581
00:20:51,600 --> 00:20:54,720
like where usually uh regular theory

582
00:20:54,720 --> 00:20:56,159
paper ends

583
00:20:56,159 --> 00:20:58,480
but we didn't stop there we

584
00:20:58,480 --> 00:21:00,400
reached out to the git community we

585
00:21:00,400 --> 00:21:03,200
presented these issues and we started

586
00:21:03,200 --> 00:21:05,360
the working with them in order to fix

587
00:21:05,360 --> 00:21:07,039
what they call the low hanging fruit

588
00:21:07,039 --> 00:21:09,520
first we

589
00:21:09,520 --> 00:21:12,159
we refactor the get tac pgp verification

590
00:21:12,159 --> 00:21:13,919
code you should be seeing these things

591
00:21:13,919 --> 00:21:17,840
in version 2.9.0

592
00:21:17,840 --> 00:21:20,799
it was really really well the world is

593
00:21:20,799 --> 00:21:23,039
not painful but really thorough or

594
00:21:23,039 --> 00:21:25,600
unlike expensive and time-consuming

595
00:21:25,600 --> 00:21:27,120
effort because

596
00:21:27,120 --> 00:21:28,960
they do care about their code they will

597
00:21:28,960 --> 00:21:30,880
not let the single white space go

598
00:21:30,880 --> 00:21:33,679
through and the commit message must be

599
00:21:33,679 --> 00:21:35,840
perfect and not ambiguous and everything

600
00:21:35,840 --> 00:21:37,520
should be fine

601
00:21:37,520 --> 00:21:38,320
after

602
00:21:38,320 --> 00:21:41,520
eight iterations of the same six series

603
00:21:41,520 --> 00:21:43,600
batch series of six patches i finally

604
00:21:43,600 --> 00:21:46,400
made it through and now you have a

605
00:21:46,400 --> 00:21:47,760
pretty much all the groundwork for all

606
00:21:47,760 --> 00:21:49,600
these fixes to be there

607
00:21:49,600 --> 00:21:50,640
we

608
00:21:50,640 --> 00:21:53,440
started trying to fix the

609
00:21:53,440 --> 00:21:56,000
ge tag teleport attack which is

610
00:21:56,000 --> 00:21:57,600
the simplest

611
00:21:57,600 --> 00:22:00,000
attack effects because there's already a

612
00:22:00,000 --> 00:22:02,320
header an element in the git tag header

613
00:22:02,320 --> 00:22:04,400
that tells you which tag is this so

614
00:22:04,400 --> 00:22:07,360
adding a simple a quality check sheet is

615
00:22:07,360 --> 00:22:08,480
really simple

616
00:22:08,480 --> 00:22:10,799
we also start exploring how to fix the

617
00:22:10,799 --> 00:22:12,480
rest of the things

618
00:22:12,480 --> 00:22:14,080
and uh

619
00:22:14,080 --> 00:22:15,360
will it

620
00:22:15,360 --> 00:22:17,679
will mostly imply taking push

621
00:22:17,679 --> 00:22:19,679
certificates which is their

622
00:22:19,679 --> 00:22:22,080
mature solution and integrate them

623
00:22:22,080 --> 00:22:25,039
somehow into this

624
00:22:25,039 --> 00:22:29,280
uh non-spack our cell ideology or like

625
00:22:29,280 --> 00:22:32,080
design constraints

626
00:22:32,080 --> 00:22:33,600
we also started exploring if these

627
00:22:33,600 --> 00:22:34,960
attacks are possible in other version

628
00:22:34,960 --> 00:22:36,880
control systems

629
00:22:36,880 --> 00:22:38,880
we realize that the bit keeper doesn't

630
00:22:38,880 --> 00:22:40,960
support gbe signing which was a pretty a

631
00:22:40,960 --> 00:22:43,360
little bit disappointing uh but we also

632
00:22:43,360 --> 00:22:45,200
saw that mercurial and monotone support

633
00:22:45,200 --> 00:22:47,120
gpg signing to different extents

634
00:22:47,120 --> 00:22:49,520
actually monotone is mandatory

635
00:22:49,520 --> 00:22:51,440
and

636
00:22:51,440 --> 00:22:53,280
these two other version control systems

637
00:22:53,280 --> 00:22:55,520
do prevent the metadata manipulation

638
00:22:55,520 --> 00:22:56,559
attacks

639
00:22:56,559 --> 00:22:58,080
this doesn't mean that they are not

640
00:22:58,080 --> 00:22:59,679
vulnerable to other types of attacks

641
00:22:59,679 --> 00:23:01,360
this just means that you cannot tinker

642
00:23:01,360 --> 00:23:03,039
with the references and expect people to

643
00:23:03,039 --> 00:23:06,400
do unintended operations

644
00:23:06,400 --> 00:23:07,600
now

645
00:23:07,600 --> 00:23:09,039
i'd like to wrap up with the following

646
00:23:09,039 --> 00:23:11,039
uh take away points

647
00:23:11,039 --> 00:23:12,880
first of all first of all do not trust

648
00:23:12,880 --> 00:23:14,320
infrastructure

649
00:23:14,320 --> 00:23:16,400
uh if the repository is presenting you

650
00:23:16,400 --> 00:23:18,559
with this information

651
00:23:18,559 --> 00:23:19,760
be sure that this is actually

652
00:23:19,760 --> 00:23:22,159
information that should be proper for

653
00:23:22,159 --> 00:23:23,360
example

654
00:23:23,360 --> 00:23:25,520
github added the pgp verification

655
00:23:25,520 --> 00:23:27,200
service but it could really lie to you

656
00:23:27,200 --> 00:23:30,000
right you should be really verifying all

657
00:23:30,000 --> 00:23:31,840
of this information locally with a

658
00:23:31,840 --> 00:23:34,959
keychain that you can trust

659
00:23:35,039 --> 00:23:37,200
now

660
00:23:37,440 --> 00:23:40,240
dpd signatures on git objects and tags

661
00:23:40,240 --> 00:23:41,120
is

662
00:23:41,120 --> 00:23:42,960
currently not enough this doesn't mean

663
00:23:42,960 --> 00:23:45,360
you shouldn't be doing that actually

664
00:23:45,360 --> 00:23:47,760
it's way better than nothing we

665
00:23:47,760 --> 00:23:50,240
also checked with our signatures and

666
00:23:50,240 --> 00:23:52,400
everything was used on

667
00:23:52,400 --> 00:23:54,480
on popular repositories and it seems

668
00:23:54,480 --> 00:23:56,000
that the usage is increasing which is a

669
00:23:56,000 --> 00:23:58,240
really uh good news

670
00:23:58,240 --> 00:24:00,480
also do not use references for things

671
00:24:00,480 --> 00:24:01,520
like

672
00:24:01,520 --> 00:24:04,000
cloning from installing from using pip

673
00:24:04,000 --> 00:24:05,520
or something

674
00:24:05,520 --> 00:24:07,840
because these things can happen to you

675
00:24:07,840 --> 00:24:09,520
but you should be uh

676
00:24:09,520 --> 00:24:10,880
you should be using the xiao one which

677
00:24:10,880 --> 00:24:12,559
provides you a tight boundary binding

678
00:24:12,559 --> 00:24:14,720
between what you want and what you

679
00:24:14,720 --> 00:24:17,120
what you want and what you get

680
00:24:17,120 --> 00:24:19,440
also and also like update kit there's

681
00:24:19,440 --> 00:24:20,880
also changes there that will make your

682
00:24:20,880 --> 00:24:23,440
life better and easier

683
00:24:23,440 --> 00:24:26,159
that's pretty much it

684
00:24:26,400 --> 00:24:29,400
questions

685
00:24:39,520 --> 00:24:44,600
so no one understood anything or

686
00:24:47,840 --> 00:24:49,679
uh so i had a question while we're

687
00:24:49,679 --> 00:24:52,000
waiting to see if anyone else does uh

688
00:24:52,000 --> 00:24:53,520
you mentioned

689
00:24:53,520 --> 00:24:55,679
that uh use of sign commits is

690
00:24:55,679 --> 00:24:57,840
increasing yes do you can you say

691
00:24:57,840 --> 00:25:00,080
anything more like is it still fairly

692
00:25:00,080 --> 00:25:02,320
low or

693
00:25:02,320 --> 00:25:05,440
is it is it uh do you see it in

694
00:25:05,440 --> 00:25:06,960
the packages we would think are sort of

695
00:25:06,960 --> 00:25:09,520
most security relevant uh so yeah

696
00:25:09,520 --> 00:25:11,520
actually it's it's interesting because

697
00:25:11,520 --> 00:25:13,200
uh

698
00:25:13,200 --> 00:25:15,200
it depends on the community and actually

699
00:25:15,200 --> 00:25:16,159
the

700
00:25:16,159 --> 00:25:19,520
kinds of people that use this uh

701
00:25:19,520 --> 00:25:20,559
speech

702
00:25:20,559 --> 00:25:22,640
software for example

703
00:25:22,640 --> 00:25:24,159
the one that we found with the highest

704
00:25:24,159 --> 00:25:26,000
commit rate was

705
00:25:26,000 --> 00:25:27,520
metasploit

706
00:25:27,520 --> 00:25:28,880
they have a

707
00:25:28,880 --> 00:25:31,279
70-something percent and this is

708
00:25:31,279 --> 00:25:32,400
actually

709
00:25:32,400 --> 00:25:34,400
it means that one in every four commits

710
00:25:34,400 --> 00:25:36,159
assigned which means that if they are

711
00:25:36,159 --> 00:25:37,279
pushing

712
00:25:37,279 --> 00:25:39,600
uh one and every four commits the

713
00:25:39,600 --> 00:25:42,559
history is completely

714
00:25:42,559 --> 00:25:44,799
proper it cannot be tempered

715
00:25:44,799 --> 00:25:46,559
we also saw that for example if you

716
00:25:46,559 --> 00:25:48,640
check the linux kernel there was pretty

717
00:25:48,640 --> 00:25:52,080
much no signing whatsoever until about a

718
00:25:52,080 --> 00:25:55,840
year and a half ago and now

719
00:25:55,840 --> 00:25:58,720
it's hard to tell uh which push which

720
00:25:58,720 --> 00:26:01,120
commits our pushes and which are not

721
00:26:01,120 --> 00:26:04,400
you can you will only see uh

722
00:26:04,400 --> 00:26:06,240
certain signatures mostly on merch

723
00:26:06,240 --> 00:26:08,400
commits and actually done by torvalds

724
00:26:08,400 --> 00:26:10,480
himself

725
00:26:10,480 --> 00:26:13,520
this makes it so that you see less than

726
00:26:13,520 --> 00:26:15,760
five percent or something in the signing

727
00:26:15,760 --> 00:26:18,000
ratio but it also

728
00:26:18,000 --> 00:26:19,919
doesn't provide a like the complete

729
00:26:19,919 --> 00:26:21,120
picture because

730
00:26:21,120 --> 00:26:24,960
if torvalds is merging a patch set of 40

731
00:26:24,960 --> 00:26:27,760
different commits then the signature for

732
00:26:27,760 --> 00:26:30,400
the merge commit actually applies to the

733
00:26:30,400 --> 00:26:33,919
40 commits that are there

734
00:26:36,080 --> 00:26:36,960
hi

735
00:26:36,960 --> 00:26:39,520
joe tam from syracuse university

736
00:26:39,520 --> 00:26:42,720
um so i'm wondering um

737
00:26:42,720 --> 00:26:44,799
how you handle the freshness problem

738
00:26:44,799 --> 00:26:46,799
let's say alice push

739
00:26:46,799 --> 00:26:49,200
version one and then she pushes version

740
00:26:49,200 --> 00:26:52,559
two later on and bob owning wants to get

741
00:26:52,559 --> 00:26:54,640
the latest version how can you ensure

742
00:26:54,640 --> 00:26:55,919
bobcats

743
00:26:55,919 --> 00:26:58,320
version 2 rather than version one

744
00:26:58,320 --> 00:27:01,679
yes so this is handled by the

745
00:27:01,679 --> 00:27:03,279
addition that i didn't introduce in the

746
00:27:03,279 --> 00:27:04,320
talk

747
00:27:04,320 --> 00:27:07,520
it's called the nonspec it's uh

748
00:27:07,520 --> 00:27:09,440
to keep it really simple and we can talk

749
00:27:09,440 --> 00:27:10,960
a little bit more about it after the

750
00:27:10,960 --> 00:27:11,760
talk

751
00:27:11,760 --> 00:27:14,080
you put the random number into this

752
00:27:14,080 --> 00:27:16,799
non-spark and this will be used to

753
00:27:16,799 --> 00:27:19,360
verify when you get the next version

754
00:27:19,360 --> 00:27:21,679
when you pull the next time if you pull

755
00:27:21,679 --> 00:27:23,200
and you don't get the

756
00:27:23,200 --> 00:27:25,279
your nons back then you have been

757
00:27:25,279 --> 00:27:27,440
completely forked from the history and

758
00:27:27,440 --> 00:27:28,799
you could

759
00:27:28,799 --> 00:27:31,520
safely go to irc or to the mailing list

760
00:27:31,520 --> 00:27:33,200
and complain that somewhere someone is

761
00:27:33,200 --> 00:27:34,720
equivocating

762
00:27:34,720 --> 00:27:37,840
so seems like you assume uh in the

763
00:27:37,840 --> 00:27:40,480
scenario you assume there is a channel

764
00:27:40,480 --> 00:27:42,080
combination communication channel

765
00:27:42,080 --> 00:27:43,919
between alice and the bob

766
00:27:43,919 --> 00:27:46,559
um sorry i couldn't understand that

767
00:27:46,559 --> 00:27:48,640
could you repeat please i mean do you

768
00:27:48,640 --> 00:27:50,399
assume there is a communication channel

769
00:27:50,399 --> 00:27:52,720
between alice and bob directly without

770
00:27:52,720 --> 00:27:54,320
going through the repo

771
00:27:54,320 --> 00:27:56,399
oh yeah that's a

772
00:27:56,399 --> 00:27:58,480
sparse i know that's a

773
00:27:58,480 --> 00:28:00,960
realistic assumption i haven't worked on

774
00:28:00,960 --> 00:28:02,640
being in any project in which they don't

775
00:28:02,640 --> 00:28:05,200
even have like a google group

776
00:28:05,200 --> 00:28:07,520
thank you

777
00:28:08,880 --> 00:28:10,870
let's thank the speaker again

778
00:28:10,870 --> 00:28:16,889
[Applause]

779
00:28:18,399 --> 00:28:20,479
you

