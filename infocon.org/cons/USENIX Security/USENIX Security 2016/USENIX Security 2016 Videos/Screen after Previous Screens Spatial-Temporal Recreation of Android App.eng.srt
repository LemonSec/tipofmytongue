1
00:00:10,719 --> 00:00:12,559
and thank you everybody else for staying

2
00:00:12,559 --> 00:00:14,719
all the way till the last session

3
00:00:14,719 --> 00:00:16,960
again my name is brendan saltoformaggio

4
00:00:16,960 --> 00:00:19,199
and i'm a phd candidate at purdue

5
00:00:19,199 --> 00:00:21,359
university and today i'm going to be

6
00:00:21,359 --> 00:00:24,000
talking about my newest memory forensics

7
00:00:24,000 --> 00:00:27,439
technique called retroscope

8
00:00:27,439 --> 00:00:30,320
retroscope enables the spatial temporal

9
00:00:30,320 --> 00:00:31,920
reconstruction

10
00:00:31,920 --> 00:00:34,399
of a previous screens that an android

11
00:00:34,399 --> 00:00:36,880
app was displaying based only on an

12
00:00:36,880 --> 00:00:39,120
input memory image

13
00:00:39,120 --> 00:00:40,559
but first

14
00:00:40,559 --> 00:00:42,800
this is a forensics talk and i think

15
00:00:42,800 --> 00:00:44,879
that any forensics talk must begin with

16
00:00:44,879 --> 00:00:48,239
a crime that we're here to investigate

17
00:00:48,239 --> 00:00:50,640
so imagine before the investigation

18
00:00:50,640 --> 00:00:51,760
begins

19
00:00:51,760 --> 00:00:53,840
we're watching the suspect interact with

20
00:00:53,840 --> 00:00:56,399
their applications in this case using

21
00:00:56,399 --> 00:00:58,480
the telegram app to message one of their

22
00:00:58,480 --> 00:01:00,239
contacts

23
00:01:00,239 --> 00:01:02,239
maybe setting up some kind of illegal

24
00:01:02,239 --> 00:01:04,319
deal because he's telling them let's

25
00:01:04,319 --> 00:01:05,920
meet tonight

26
00:01:05,920 --> 00:01:08,000
but before the suspect sends off this

27
00:01:08,000 --> 00:01:10,080
message he hears the police coming to

28
00:01:10,080 --> 00:01:12,640
the door and panics

29
00:01:12,640 --> 00:01:15,920
quickly logging out of the telegram app

30
00:01:15,920 --> 00:01:17,759
and now the suspect thinks that he's

31
00:01:17,759 --> 00:01:18,720
safe

32
00:01:18,720 --> 00:01:20,640
because as some of you probably know

33
00:01:20,640 --> 00:01:23,840
telegram is a very secure app especially

34
00:01:23,840 --> 00:01:27,200
once you've already logged out

35
00:01:27,200 --> 00:01:29,280
so the police are going to arrive

36
00:01:29,280 --> 00:01:31,840
they'll confiscate that device image its

37
00:01:31,840 --> 00:01:33,520
memory and we're going to see how

38
00:01:33,520 --> 00:01:35,840
retroscope is going to reconstruct the

39
00:01:35,840 --> 00:01:38,079
previous screens we just saw the suspect

40
00:01:38,079 --> 00:01:40,560
using

41
00:01:40,560 --> 00:01:43,200
but i'm gonna go a step further

42
00:01:43,200 --> 00:01:45,680
and say that retroscope is gonna do this

43
00:01:45,680 --> 00:01:48,799
without access to the suspect's password

44
00:01:48,799 --> 00:01:51,119
and without breaking telegrams fully

45
00:01:51,119 --> 00:01:54,680
encrypted storage

46
00:01:54,720 --> 00:01:57,439
so like i said this is memory forensics

47
00:01:57,439 --> 00:01:59,840
and the goal here is to recover all of

48
00:01:59,840 --> 00:02:01,920
that evidence that we just saw on the

49
00:02:01,920 --> 00:02:04,799
suspect's screens from an input memory

50
00:02:04,799 --> 00:02:06,159
image

51
00:02:06,159 --> 00:02:07,280
however

52
00:02:07,280 --> 00:02:10,318
this may be mission impossible

53
00:02:10,318 --> 00:02:11,920
some of you might remember my paper

54
00:02:11,920 --> 00:02:14,400
guitar which got the best paper at ccs

55
00:02:14,400 --> 00:02:15,520
last year

56
00:02:15,520 --> 00:02:18,160
but guitar was only able to recover the

57
00:02:18,160 --> 00:02:20,640
most recent screen that an application

58
00:02:20,640 --> 00:02:24,239
was displaying by geometrically piecing

59
00:02:24,239 --> 00:02:26,879
back together all of the remaining gui

60
00:02:26,879 --> 00:02:29,680
data structures in a memory image

61
00:02:29,680 --> 00:02:31,920
and because of that guitar comes with a

62
00:02:31,920 --> 00:02:34,720
very serious limitation

63
00:02:34,720 --> 00:02:37,280
for every new screen that an application

64
00:02:37,280 --> 00:02:38,480
displays

65
00:02:38,480 --> 00:02:41,040
it's going to overwrite and destroy the

66
00:02:41,040 --> 00:02:43,599
gui data structures from the previous

67
00:02:43,599 --> 00:02:45,519
screens

68
00:02:45,519 --> 00:02:47,280
so no matter how many screens an app

69
00:02:47,280 --> 00:02:50,239
displays guitar will always be limited

70
00:02:50,239 --> 00:02:52,800
to only the most recent one

71
00:02:52,800 --> 00:02:55,120
if we number these screens backwards in

72
00:02:55,120 --> 00:02:57,360
time then we can say that guitar is

73
00:02:57,360 --> 00:03:00,239
limited to only screen zero and none of

74
00:03:00,239 --> 00:03:02,080
the previous

75
00:03:02,080 --> 00:03:04,800
and what's even worse if the suspect has

76
00:03:04,800 --> 00:03:06,959
already logged out like we just saw in

77
00:03:06,959 --> 00:03:09,360
that video then that screen zero is

78
00:03:09,360 --> 00:03:13,040
going to be of no use to investigators

79
00:03:13,040 --> 00:03:15,360
but i know what you're thinking

80
00:03:15,360 --> 00:03:18,480
are those old screens really gone when i

81
00:03:18,480 --> 00:03:21,200
use my android apps the screen changes

82
00:03:21,200 --> 00:03:23,440
are highly dynamic

83
00:03:23,440 --> 00:03:26,640
if all that gui data is gone then how

84
00:03:26,640 --> 00:03:30,400
can every screen be rebuilt so quickly

85
00:03:30,400 --> 00:03:33,200
some data must remain to allow the

86
00:03:33,200 --> 00:03:35,680
applications to bring those old screens

87
00:03:35,680 --> 00:03:37,120
back

88
00:03:37,120 --> 00:03:37,920
well

89
00:03:37,920 --> 00:03:40,480
we're all scientists here so we did some

90
00:03:40,480 --> 00:03:43,360
experiments to answer those questions

91
00:03:43,360 --> 00:03:46,319
we profiled the app's memory usage so

92
00:03:46,319 --> 00:03:49,120
you can see that the x-axis here is time

93
00:03:49,120 --> 00:03:51,440
and the y-axis is data structures that

94
00:03:51,440 --> 00:03:52,560
remain

95
00:03:52,560 --> 00:03:55,200
and we found that the application's gui

96
00:03:55,200 --> 00:03:58,239
data gets allocated and lost with each

97
00:03:58,239 --> 00:04:01,120
change of the screen now these are the

98
00:04:01,120 --> 00:04:03,599
android frameworks generic data

99
00:04:03,599 --> 00:04:06,239
structures that every application uses

100
00:04:06,239 --> 00:04:08,159
that are ready to be rendered on the

101
00:04:08,159 --> 00:04:10,080
device's screen

102
00:04:10,080 --> 00:04:12,640
and this is exactly why guitar is

103
00:04:12,640 --> 00:04:15,439
limited to only screen zero because

104
00:04:15,439 --> 00:04:18,320
guitar can't recover the gui data that

105
00:04:18,320 --> 00:04:20,880
no longer exists

106
00:04:20,880 --> 00:04:23,600
but we also found that an application's

107
00:04:23,600 --> 00:04:27,120
internal data accumulates during the

108
00:04:27,120 --> 00:04:28,720
app's use

109
00:04:28,720 --> 00:04:31,040
this is all of that raw data that an

110
00:04:31,040 --> 00:04:33,919
application generates internally things

111
00:04:33,919 --> 00:04:37,040
like chat strings or account balances

112
00:04:37,040 --> 00:04:38,800
that if an investigator wanted to

113
00:04:38,800 --> 00:04:41,120
understand they would have to perform

114
00:04:41,120 --> 00:04:44,000
application specific reverse engineering

115
00:04:44,000 --> 00:04:47,040
on each of these apps

116
00:04:47,040 --> 00:04:49,040
so to answer that question are the old

117
00:04:49,040 --> 00:04:50,800
screens really gone

118
00:04:50,800 --> 00:04:52,960
well yes and no

119
00:04:52,960 --> 00:04:55,520
yes the screens themselves are totally

120
00:04:55,520 --> 00:04:57,360
gone from memory

121
00:04:57,360 --> 00:05:00,560
but also no because the app's internal

122
00:05:00,560 --> 00:05:02,960
data that used to be shown on those

123
00:05:02,960 --> 00:05:05,680
screens does remain

124
00:05:05,680 --> 00:05:09,280
and so that got us wondering

125
00:05:09,520 --> 00:05:12,160
how does android handle transitions in

126
00:05:12,160 --> 00:05:13,280
screens

127
00:05:13,280 --> 00:05:15,440
what turns out that android just asks

128
00:05:15,440 --> 00:05:17,199
the application

129
00:05:17,199 --> 00:05:20,080
android sends a redraw command to a

130
00:05:20,080 --> 00:05:22,479
running app and provides it a blank

131
00:05:22,479 --> 00:05:25,280
canvas to draw its screen into

132
00:05:25,280 --> 00:05:28,080
the application's customized drawing

133
00:05:28,080 --> 00:05:31,440
routines then execute and package up all

134
00:05:31,440 --> 00:05:34,080
of that internal data to fill up the

135
00:05:34,080 --> 00:05:35,919
canvas

136
00:05:35,919 --> 00:05:38,720
it's this operation that destroys and

137
00:05:38,720 --> 00:05:41,199
overwrites all of that previous screen's

138
00:05:41,199 --> 00:05:43,440
gui data

139
00:05:43,440 --> 00:05:45,600
and then once the app's custom drawing

140
00:05:45,600 --> 00:05:47,759
routines are finished

141
00:05:47,759 --> 00:05:50,160
that newly filled canvas can be rendered

142
00:05:50,160 --> 00:05:53,680
on the device's screen it's this redraw

143
00:05:53,680 --> 00:05:55,759
mechanism that allows the android

144
00:05:55,759 --> 00:05:58,000
framework to bring up any of the app

145
00:05:58,000 --> 00:06:00,240
screens that it needs without

146
00:06:00,240 --> 00:06:02,720
interacting directly with that internal

147
00:06:02,720 --> 00:06:05,360
data that it can't understand

148
00:06:05,360 --> 00:06:07,120
sort of like when you turn on your car

149
00:06:07,120 --> 00:06:09,759
using the key versus hacking directly

150
00:06:09,759 --> 00:06:11,840
into the engine

151
00:06:11,840 --> 00:06:14,240
but this gave us an idea

152
00:06:14,240 --> 00:06:16,479
why don't we ask the app that's in a

153
00:06:16,479 --> 00:06:19,840
memory image to redraw its screen

154
00:06:19,840 --> 00:06:22,880
i know sounds a little crazy first off

155
00:06:22,880 --> 00:06:25,759
how do you even inject a redraw command

156
00:06:25,759 --> 00:06:28,960
into a memory image it's just a blob of

157
00:06:28,960 --> 00:06:30,880
data right

158
00:06:30,880 --> 00:06:31,840
second

159
00:06:31,840 --> 00:06:34,800
do we need to understand all of that

160
00:06:34,800 --> 00:06:37,440
application internal data in order to do

161
00:06:37,440 --> 00:06:40,479
this i hope not because we want an

162
00:06:40,479 --> 00:06:43,520
application agnostic solution

163
00:06:43,520 --> 00:06:45,280
something that will allow investigators

164
00:06:45,280 --> 00:06:47,360
to plug in a memory image and get

165
00:06:47,360 --> 00:06:50,000
results out for any application that

166
00:06:50,000 --> 00:06:52,080
they're investigating

167
00:06:52,080 --> 00:06:54,400
and then even if we did solve those two

168
00:06:54,400 --> 00:06:55,680
problems

169
00:06:55,680 --> 00:06:58,800
a memory image is still just static data

170
00:06:58,800 --> 00:07:02,000
so how can we get that new gui screen

171
00:07:02,000 --> 00:07:04,720
rendered outside of the memory image for

172
00:07:04,720 --> 00:07:08,080
investigators to take a look at

173
00:07:08,080 --> 00:07:10,639
but that's exactly what retroscope is

174
00:07:10,639 --> 00:07:12,240
going to do

175
00:07:12,240 --> 00:07:14,720
see retroscope acts sort of like a

176
00:07:14,720 --> 00:07:16,479
puppeteer

177
00:07:16,479 --> 00:07:19,840
steering the live android gui drawing

178
00:07:19,840 --> 00:07:22,960
code towards that memory image and all

179
00:07:22,960 --> 00:07:26,479
of the apps internal data that it holds

180
00:07:26,479 --> 00:07:29,199
this allows retroscope to perform app

181
00:07:29,199 --> 00:07:31,840
agnostic screen recovery

182
00:07:31,840 --> 00:07:34,800
for as many of the previous screens from

183
00:07:34,800 --> 00:07:36,560
that app that the memory image can

184
00:07:36,560 --> 00:07:38,080
support

185
00:07:38,080 --> 00:07:39,440
and now i'm going to go through how this

186
00:07:39,440 --> 00:07:42,720
technique works in detail

187
00:07:42,720 --> 00:07:45,280
so first the symbiont app

188
00:07:45,280 --> 00:07:47,599
the symbiont app is just a minimal

189
00:07:47,599 --> 00:07:50,479
android application with its own runtime

190
00:07:50,479 --> 00:07:53,680
environment and gui that executes all by

191
00:07:53,680 --> 00:07:55,199
itself

192
00:07:55,199 --> 00:07:57,599
but this symbiant app is going to serve

193
00:07:57,599 --> 00:08:00,639
as a host for the memory image apps

194
00:08:00,639 --> 00:08:02,400
redrawing

195
00:08:02,400 --> 00:08:05,120
so retroscope is going to move all of

196
00:08:05,120 --> 00:08:08,000
the state from the memory image app into

197
00:08:08,000 --> 00:08:09,599
the symbiant app

198
00:08:09,599 --> 00:08:11,599
this requires remapping all of the

199
00:08:11,599 --> 00:08:13,199
memory segments

200
00:08:13,199 --> 00:08:15,120
merging the two java runtime

201
00:08:15,120 --> 00:08:17,440
environments together and bringing back

202
00:08:17,440 --> 00:08:19,520
all of the old code that the memory

203
00:08:19,520 --> 00:08:21,680
image app was using

204
00:08:21,680 --> 00:08:24,240
so at this point the symbiont app is

205
00:08:24,240 --> 00:08:27,120
essentially two apps in one

206
00:08:27,120 --> 00:08:29,440
but neither of those apps knows how to

207
00:08:29,440 --> 00:08:32,559
communicate with each other

208
00:08:32,559 --> 00:08:34,479
to take care of that

209
00:08:34,479 --> 00:08:36,799
we use our novel interleaved

210
00:08:36,799 --> 00:08:41,440
re-execution engine or ire for short

211
00:08:41,440 --> 00:08:44,240
now this figure may look pretty complex

212
00:08:44,240 --> 00:08:46,240
but this is actually a simplified

213
00:08:46,240 --> 00:08:48,959
version of an even more complex state

214
00:08:48,959 --> 00:08:52,240
transition diagram in the paper

215
00:08:52,240 --> 00:08:53,600
basically

216
00:08:53,600 --> 00:08:56,959
we've formally modeled the interleaving

217
00:08:56,959 --> 00:08:59,600
of these two executions as a finite

218
00:08:59,600 --> 00:09:00,959
automata

219
00:09:00,959 --> 00:09:04,000
with state transition rules based on

220
00:09:04,000 --> 00:09:07,839
each executing instruction

221
00:09:07,839 --> 00:09:09,120
if you're interested in all the

222
00:09:09,120 --> 00:09:11,200
different state transition rules then

223
00:09:11,200 --> 00:09:12,640
please see the paper because it's

224
00:09:12,640 --> 00:09:15,040
actually a pretty fascinating technique

225
00:09:15,040 --> 00:09:17,680
but if i were to really over simplify

226
00:09:17,680 --> 00:09:18,720
this

227
00:09:18,720 --> 00:09:21,200
the ire is going to make sure that the

228
00:09:21,200 --> 00:09:22,800
live code

229
00:09:22,800 --> 00:09:26,320
outputs to the live gui environment

230
00:09:26,320 --> 00:09:29,200
and the old code is gonna read from that

231
00:09:29,200 --> 00:09:31,600
old internal data that's in the memory

232
00:09:31,600 --> 00:09:33,920
image

233
00:09:35,040 --> 00:09:36,080
now i'm going to go through a quick

234
00:09:36,080 --> 00:09:37,360
example

235
00:09:37,360 --> 00:09:39,839
to show you exactly how the ire allows

236
00:09:39,839 --> 00:09:42,320
us to redraw those screens from within

237
00:09:42,320 --> 00:09:45,760
the symbiont application

238
00:09:45,920 --> 00:09:48,640
so first retroscope starts just like the

239
00:09:48,640 --> 00:09:51,440
android framework does sending a redraw

240
00:09:51,440 --> 00:09:53,519
command to the symbiont app and giving

241
00:09:53,519 --> 00:09:56,320
it a blank canvas to draw into

242
00:09:56,320 --> 00:09:58,720
but instead of executing the symbian

243
00:09:58,720 --> 00:10:01,519
apps drawing routines the ire is going

244
00:10:01,519 --> 00:10:03,680
to be monitoring the state transitions

245
00:10:03,680 --> 00:10:06,160
and correct the execution

246
00:10:06,160 --> 00:10:08,320
into the memory image apps drawing

247
00:10:08,320 --> 00:10:09,600
routines

248
00:10:09,600 --> 00:10:11,200
and you can follow along i'm going to

249
00:10:11,200 --> 00:10:13,040
highlight the state transitions we go

250
00:10:13,040 --> 00:10:16,160
through on the side here

251
00:10:16,240 --> 00:10:17,600
at this point

252
00:10:17,600 --> 00:10:19,760
the memory image apps drawing routines

253
00:10:19,760 --> 00:10:21,839
are going to execute naturally and

254
00:10:21,839 --> 00:10:24,240
handle all of that internal data that

255
00:10:24,240 --> 00:10:26,720
only they know how to

256
00:10:26,720 --> 00:10:28,959
and this is going to cause all of that

257
00:10:28,959 --> 00:10:33,120
previously lost gui data to be rebuilt

258
00:10:33,120 --> 00:10:34,959
from the internal data in the memory

259
00:10:34,959 --> 00:10:37,199
image

260
00:10:37,440 --> 00:10:39,200
finally the drawing routines are going

261
00:10:39,200 --> 00:10:42,079
to begin to fill that canvas

262
00:10:42,079 --> 00:10:44,320
but the ire is going to realize that the

263
00:10:44,320 --> 00:10:47,519
canvas is not from the memory image it

264
00:10:47,519 --> 00:10:50,640
comes from the live gui environment

265
00:10:50,640 --> 00:10:52,320
and so it's going to correct that

266
00:10:52,320 --> 00:10:55,040
execution back into the live gui

267
00:10:55,040 --> 00:10:57,680
environment to fill up the canvas with

268
00:10:57,680 --> 00:11:01,120
the gui data and you can kind of see on

269
00:11:01,120 --> 00:11:04,560
this automata that these mixed execution

270
00:11:04,560 --> 00:11:06,240
states are where things begin to get

271
00:11:06,240 --> 00:11:08,800
tricky because the ire needs to make

272
00:11:08,800 --> 00:11:11,760
sure that the old code interacts

273
00:11:11,760 --> 00:11:14,079
properly with objects from the live

274
00:11:14,079 --> 00:11:17,199
execution environment

275
00:11:18,160 --> 00:11:20,160
and then finally once the canvas is

276
00:11:20,160 --> 00:11:22,320
filled it's already in the live

277
00:11:22,320 --> 00:11:24,560
environment and so it can be rendered

278
00:11:24,560 --> 00:11:26,959
naturally by android

279
00:11:26,959 --> 00:11:28,640
and then the newly rendered screen can

280
00:11:28,640 --> 00:11:30,560
be saved for investigators to take a

281
00:11:30,560 --> 00:11:32,959
look at

282
00:11:33,440 --> 00:11:35,760
and then retroscope is going to reset

283
00:11:35,760 --> 00:11:38,160
and repeat this process for every

284
00:11:38,160 --> 00:11:40,079
drawing routine that the memory image

285
00:11:40,079 --> 00:11:43,839
app had previously registered

286
00:11:44,399 --> 00:11:46,240
so remember that case we started off

287
00:11:46,240 --> 00:11:48,240
with at the beginning of this talk now

288
00:11:48,240 --> 00:11:50,000
we're going to watch how retroscope is

289
00:11:50,000 --> 00:11:52,800
going to break that case wide open

290
00:11:52,800 --> 00:11:55,120
so retroscope runs in this modified

291
00:11:55,120 --> 00:11:57,040
android emulator

292
00:11:57,040 --> 00:11:58,720
and we're going to watch retroscope's

293
00:11:58,720 --> 00:12:01,760
progress in the terminal

294
00:12:01,760 --> 00:12:03,839
the investigator just needs to start the

295
00:12:03,839 --> 00:12:06,000
symbiont app running inside of the

296
00:12:06,000 --> 00:12:08,240
emulator

297
00:12:08,240 --> 00:12:10,079
and once that loads up it's going to

298
00:12:10,079 --> 00:12:12,399
begin pulling in the memory image and

299
00:12:12,399 --> 00:12:15,519
merging all of that state to prepare the

300
00:12:15,519 --> 00:12:19,760
memory for interleaved re-execution

301
00:12:19,760 --> 00:12:21,279
this process is going to take about

302
00:12:21,279 --> 00:12:22,880
three minutes

303
00:12:22,880 --> 00:12:24,959
but thanks to the magic of hollywood

304
00:12:24,959 --> 00:12:26,399
we're not going to have to wait that

305
00:12:26,399 --> 00:12:27,519
long

306
00:12:27,519 --> 00:12:30,399
and we'll skip right past that

307
00:12:30,399 --> 00:12:33,360
and get to the re-execution piece

308
00:12:33,360 --> 00:12:35,440
okay so once everything is prepared for

309
00:12:35,440 --> 00:12:37,920
re-execution retroscope's going to begin

310
00:12:37,920 --> 00:12:40,639
reanimating those drawing routines so

311
00:12:40,639 --> 00:12:42,880
remember that state transition diagram

312
00:12:42,880 --> 00:12:46,320
we just saw this is retroscope logging

313
00:12:46,320 --> 00:12:48,320
each of the state transitions that it

314
00:12:48,320 --> 00:12:50,639
goes through while it's reanimating so

315
00:12:50,639 --> 00:12:53,040
you can see that it requires quite a few

316
00:12:53,040 --> 00:12:55,680
state transitions just to reanimate a

317
00:12:55,680 --> 00:12:58,240
single drawing function

318
00:12:58,240 --> 00:13:00,480
it took two minutes to reanimate all of

319
00:13:00,480 --> 00:13:02,160
the drawing functions that were in this

320
00:13:02,160 --> 00:13:03,680
memory image

321
00:13:03,680 --> 00:13:06,240
and then once this is closed once this

322
00:13:06,240 --> 00:13:08,720
is finished retroscope will close to

323
00:13:08,720 --> 00:13:10,480
tell investigators that the results are

324
00:13:10,480 --> 00:13:12,800
ready

325
00:13:15,040 --> 00:13:17,200
okay so retroscope is done and

326
00:13:17,200 --> 00:13:18,880
investigators can take a look at the

327
00:13:18,880 --> 00:13:21,760
results to do this we just have to pull

328
00:13:21,760 --> 00:13:23,360
them down from the emulator where

329
00:13:23,360 --> 00:13:25,360
they've been saved

330
00:13:25,360 --> 00:13:27,279
this will take a quick second and then

331
00:13:27,279 --> 00:13:29,120
we'll be able to look at them on the

332
00:13:29,120 --> 00:13:31,200
local computer

333
00:13:31,200 --> 00:13:33,360
okay so in this case retroscope

334
00:13:33,360 --> 00:13:36,000
recovered six screens out of that memory

335
00:13:36,000 --> 00:13:37,839
image we're gonna go ahead and take a

336
00:13:37,839 --> 00:13:40,399
look at them starting with screen zero

337
00:13:40,399 --> 00:13:42,639
right that's the most recent screen that

338
00:13:42,639 --> 00:13:44,800
the suspect was looking at

339
00:13:44,800 --> 00:13:47,920
and for comparison i'm gonna rewind the

340
00:13:47,920 --> 00:13:50,240
suspect's activities that we saw at the

341
00:13:50,240 --> 00:13:52,720
beginning of this talk

342
00:13:52,720 --> 00:13:55,519
so of course we recover the login screen

343
00:13:55,519 --> 00:13:58,639
as screen 0 because we saw the suspect

344
00:13:58,639 --> 00:14:01,600
previously log out at the end of his use

345
00:14:01,600 --> 00:14:03,920
and investigators know the suspect tried

346
00:14:03,920 --> 00:14:05,760
to log out because we actually recovered

347
00:14:05,760 --> 00:14:09,760
the log out dialogue as screen minus one

348
00:14:09,760 --> 00:14:12,000
before that the suspect had logged out

349
00:14:12,000 --> 00:14:14,079
from the profile screen so that's what's

350
00:14:14,079 --> 00:14:17,519
recovered as screen minus two

351
00:14:17,519 --> 00:14:19,760
and then we did that from the recent

352
00:14:19,760 --> 00:14:22,079
chats stream so that's what's recovered

353
00:14:22,079 --> 00:14:25,040
as screen minus three

354
00:14:25,040 --> 00:14:27,839
now this is interesting the chat screen

355
00:14:27,839 --> 00:14:30,880
is still recovered with the draft intact

356
00:14:30,880 --> 00:14:32,639
because of course that's how it looked

357
00:14:32,639 --> 00:14:34,959
the last time that the suspect had it up

358
00:14:34,959 --> 00:14:37,120
on the device's screen and so it's still

359
00:14:37,120 --> 00:14:38,880
in memory and that's what retroscope

360
00:14:38,880 --> 00:14:42,079
recovers for screen minus four

361
00:14:42,079 --> 00:14:43,920
and then of course the first screen we

362
00:14:43,920 --> 00:14:46,079
started off on was the contacts list

363
00:14:46,079 --> 00:14:48,079
screen so that's recovered as screen

364
00:14:48,079 --> 00:14:50,480
minus five so that's the six screens

365
00:14:50,480 --> 00:14:52,079
that retroscope recovered from that

366
00:14:52,079 --> 00:14:54,000
memory image and if you're interested

367
00:14:54,000 --> 00:14:56,160
retroscope is publicly available there's

368
00:14:56,160 --> 00:14:58,399
a link there there's a link in the paper

369
00:14:58,399 --> 00:15:00,800
there's also a link on my web page but

370
00:15:00,800 --> 00:15:02,639
what i'm working on right now and it's

371
00:15:02,639 --> 00:15:04,160
going to be up probably by the end of

372
00:15:04,160 --> 00:15:06,480
the week is what i call retroscope in a

373
00:15:06,480 --> 00:15:09,440
box it's a pre-configured vm with

374
00:15:09,440 --> 00:15:11,440
retroscope in it and some test case

375
00:15:11,440 --> 00:15:13,279
memory images that you can download and

376
00:15:13,279 --> 00:15:15,360
play around with on your own i'm have

377
00:15:15,360 --> 00:15:17,040
that up on my website as soon as it's

378
00:15:17,040 --> 00:15:19,199
done

379
00:15:19,199 --> 00:15:21,120
so we just saw some results in that

380
00:15:21,120 --> 00:15:22,720
video

381
00:15:22,720 --> 00:15:25,279
in the paper we actually investigated 15

382
00:15:25,279 --> 00:15:27,440
different applications across three

383
00:15:27,440 --> 00:15:29,920
suspect devices these are the results

384
00:15:29,920 --> 00:15:32,480
for the htc one device you can find the

385
00:15:32,480 --> 00:15:34,399
rest in the paper but these are pretty

386
00:15:34,399 --> 00:15:37,120
representative of all of our findings

387
00:15:37,120 --> 00:15:40,000
retroscope recovered anywhere from three

388
00:15:40,000 --> 00:15:42,320
all the way up to a maximum of eleven

389
00:15:42,320 --> 00:15:45,199
screens for each app that we tested with

390
00:15:45,199 --> 00:15:47,920
an average around five to six screens

391
00:15:47,920 --> 00:15:50,079
per app

392
00:15:50,079 --> 00:15:52,079
it's worth pointing out that that

393
00:15:52,079 --> 00:15:54,560
maximum eleven screens actually came

394
00:15:54,560 --> 00:15:57,199
from the chase banking application and

395
00:15:57,199 --> 00:15:58,959
we were able to recover all of the

396
00:15:58,959 --> 00:16:01,600
screens of a banking transaction sending

397
00:16:01,600 --> 00:16:04,959
money from my account to someone else's

398
00:16:04,959 --> 00:16:06,959
i should say this is not anything that

399
00:16:06,959 --> 00:16:09,120
the chase banking app has done wrong

400
00:16:09,120 --> 00:16:11,519
right we are just telling the chase bank

401
00:16:11,519 --> 00:16:13,839
app that android needs it to redraw its

402
00:16:13,839 --> 00:16:16,800
screen now and so the app is doing what

403
00:16:16,800 --> 00:16:19,600
it's programmed to do

404
00:16:19,600 --> 00:16:21,360
some other really interesting results

405
00:16:21,360 --> 00:16:23,839
these are metrics from the re-execution

406
00:16:23,839 --> 00:16:26,000
piece you can see that it takes a

407
00:16:26,000 --> 00:16:28,480
tremendous amount of re-execution to

408
00:16:28,480 --> 00:16:30,480
rebuild these screens we found an

409
00:16:30,480 --> 00:16:33,279
average of over 40 000 byte codes

410
00:16:33,279 --> 00:16:34,720
re-executed

411
00:16:34,720 --> 00:16:36,800
and over 150

412
00:16:36,800 --> 00:16:40,639
new java objects and over 13 000 new cc

413
00:16:40,639 --> 00:16:43,600
plus plus structures per screen

414
00:16:43,600 --> 00:16:45,519
so this is all of that data that was

415
00:16:45,519 --> 00:16:48,560
previously lost that has to be rebuilt

416
00:16:48,560 --> 00:16:51,839
through this re-execution

417
00:16:52,800 --> 00:16:54,560
so now one interesting case study that

418
00:16:54,560 --> 00:16:57,199
we found these are deleted messages and

419
00:16:57,199 --> 00:16:59,600
what you're looking at is the wechat app

420
00:16:59,600 --> 00:17:01,279
but we actually found this on a number

421
00:17:01,279 --> 00:17:03,519
of applications that we tested

422
00:17:03,519 --> 00:17:05,359
what was happening here was the suspect

423
00:17:05,359 --> 00:17:07,199
was actively trying to delete the

424
00:17:07,199 --> 00:17:10,480
message that you see in screen minus one

425
00:17:10,480 --> 00:17:12,319
but of course just because that message

426
00:17:12,319 --> 00:17:14,319
is no longer shown on the device's

427
00:17:14,319 --> 00:17:16,000
screen doesn't mean that it's totally

428
00:17:16,000 --> 00:17:18,319
gone it was still in memory and so

429
00:17:18,319 --> 00:17:20,480
retroscope was able to re-render that

430
00:17:20,480 --> 00:17:23,039
deleted message as it looked when it was

431
00:17:23,039 --> 00:17:25,359
last on the screen and even better

432
00:17:25,359 --> 00:17:27,679
investigators get motive here they know

433
00:17:27,679 --> 00:17:29,360
that the suspect was trying to delete

434
00:17:29,360 --> 00:17:32,320
this message because of screen minus 2

435
00:17:32,320 --> 00:17:37,120
is the delete message options drop down

436
00:17:38,320 --> 00:17:40,480
and here's a really bizarre case study

437
00:17:40,480 --> 00:17:41,520
we found

438
00:17:41,520 --> 00:17:44,160
retroscope actually recovered a screen

439
00:17:44,160 --> 00:17:47,039
plus one that's a screen that even the

440
00:17:47,039 --> 00:17:49,760
suspect didn't get a chance to see

441
00:17:49,760 --> 00:17:51,679
now the way this happened was the

442
00:17:51,679 --> 00:17:54,480
suspect was using whatsapp and then put

443
00:17:54,480 --> 00:17:56,080
it in the background and put down the

444
00:17:56,080 --> 00:17:57,200
device

445
00:17:57,200 --> 00:17:59,440
but before we could collect a memory

446
00:17:59,440 --> 00:18:02,559
image they received a new message

447
00:18:02,559 --> 00:18:05,280
and whatsapp actually prepared a whole

448
00:18:05,280 --> 00:18:08,480
new screen with the new message on it

449
00:18:08,480 --> 00:18:10,559
that was ready for the next time the

450
00:18:10,559 --> 00:18:12,720
suspect was going to open that app

451
00:18:12,720 --> 00:18:14,480
and so of course it was in memory and

452
00:18:14,480 --> 00:18:16,799
retroscope recovered it and it you could

453
00:18:16,799 --> 00:18:19,440
call it a screen plus one if you will

454
00:18:19,440 --> 00:18:20,960
it's interesting because we only

455
00:18:20,960 --> 00:18:23,919
observed this in whatsapp so we assume

456
00:18:23,919 --> 00:18:26,000
this is some kind of whatsapp specific

457
00:18:26,000 --> 00:18:28,400
optimization to speed up bringing the

458
00:18:28,400 --> 00:18:30,480
app back from the background but it's

459
00:18:30,480 --> 00:18:34,720
also a really cool result forensically

460
00:18:35,520 --> 00:18:37,120
so of course there's a lot of great

461
00:18:37,120 --> 00:18:39,200
related works in memory forensics we

462
00:18:39,200 --> 00:18:40,960
started off this talk talking about

463
00:18:40,960 --> 00:18:43,280
guitar i also just want to point out my

464
00:18:43,280 --> 00:18:45,520
paper discrete because it's probably the

465
00:18:45,520 --> 00:18:48,799
most related work discrete also reflects

466
00:18:48,799 --> 00:18:52,320
this methodology of logic reuse but for

467
00:18:52,320 --> 00:18:54,640
a totally different goal and discrete

468
00:18:54,640 --> 00:18:56,799
actually operates in a data structure

469
00:18:56,799 --> 00:18:59,760
specific fashion so it's not at all

470
00:18:59,760 --> 00:19:03,679
automatic the way that retroscope is

471
00:19:04,320 --> 00:19:06,000
so in conclusion we've developed

472
00:19:06,000 --> 00:19:08,320
retroscope which we really kind of

473
00:19:08,320 --> 00:19:10,799
believe is a new paradigm in memory

474
00:19:10,799 --> 00:19:13,679
forensics being able to reconstruct all

475
00:19:13,679 --> 00:19:16,080
of that spatial temporal evidence that

476
00:19:16,080 --> 00:19:18,400
wasn't even available still in the

477
00:19:18,400 --> 00:19:20,640
memory image and of course retroscope

478
00:19:20,640 --> 00:19:22,640
does this via the novel interleaved

479
00:19:22,640 --> 00:19:24,960
re-execution engine that we saw

480
00:19:24,960 --> 00:19:27,600
and you saw the evaluation results where

481
00:19:27,600 --> 00:19:30,320
retroscope reconstructed these sequences

482
00:19:30,320 --> 00:19:32,640
of temporally ordered screens from three

483
00:19:32,640 --> 00:19:35,440
all the way up to 11 for a wide variety

484
00:19:35,440 --> 00:19:38,080
of privacy sensitive applications

485
00:19:38,080 --> 00:19:40,000
so with that i thank you all very much

486
00:19:40,000 --> 00:19:42,150
and i'm happy to take any questions

487
00:19:42,150 --> 00:19:47,600
[Applause]

488
00:19:47,600 --> 00:19:50,159
questions

489
00:19:50,799 --> 00:19:53,840
really okay

490
00:19:58,160 --> 00:20:01,280
uh rabimbo rice university awesome work

491
00:20:01,280 --> 00:20:03,360
uh i just wanted to know uh did you also

492
00:20:03,360 --> 00:20:06,640
notice this for only app specific or

493
00:20:06,640 --> 00:20:09,039
like system apps for example

494
00:20:09,039 --> 00:20:11,840
will you be able to see the patterns of

495
00:20:11,840 --> 00:20:13,280
unlocking a phone

496
00:20:13,280 --> 00:20:15,280
like this

497
00:20:15,280 --> 00:20:18,080
man that's a really good question so i

498
00:20:18,080 --> 00:20:21,760
don't know if the pattern draw that went

499
00:20:21,760 --> 00:20:23,600
to unlock the phone you're talking about

500
00:20:23,600 --> 00:20:25,679
i don't know if that is in itself an

501
00:20:25,679 --> 00:20:27,600
application or if it's like a system

502
00:20:27,600 --> 00:20:29,840
service if it is an application i'm

503
00:20:29,840 --> 00:20:31,679
going to run back to the lab and test

504
00:20:31,679 --> 00:20:34,000
that

505
00:20:34,000 --> 00:20:36,880
um but we did test other system apps

506
00:20:36,880 --> 00:20:39,679
things like the default mms app that

507
00:20:39,679 --> 00:20:41,919
came with each of those three vendor

508
00:20:41,919 --> 00:20:45,039
phone you know vendor customized phones

509
00:20:45,039 --> 00:20:47,120
and those worked all just the same so

510
00:20:47,120 --> 00:20:48,960
yeah it does work on system apps but i

511
00:20:48,960 --> 00:20:50,960
didn't test the the pattern that's a

512
00:20:50,960 --> 00:20:53,440
great idea thank you

513
00:20:53,440 --> 00:20:56,320
hey brandon great talk this was really

514
00:20:56,320 --> 00:20:58,000
interesting um

515
00:20:58,000 --> 00:21:00,880
so what would what would a defense to

516
00:21:00,880 --> 00:21:03,360
this bee if i want to hide my data from

517
00:21:03,360 --> 00:21:04,240
yeah

518
00:21:04,240 --> 00:21:06,159
that's a great question so

519
00:21:06,159 --> 00:21:07,600
um

520
00:21:07,600 --> 00:21:09,520
defenses for this

521
00:21:09,520 --> 00:21:11,840
well let me let me do this i actually

522
00:21:11,840 --> 00:21:13,919
have a backup slide for sort of the

523
00:21:13,919 --> 00:21:16,480
privacy implications of retroscope

524
00:21:16,480 --> 00:21:17,919
because that's actually

525
00:21:17,919 --> 00:21:19,919
in fact to be honest when we ran

526
00:21:19,919 --> 00:21:22,320
retroscope even we were shocked at how

527
00:21:22,320 --> 00:21:24,480
much it recovered so that kind of made

528
00:21:24,480 --> 00:21:26,240
us think like what's up with the privacy

529
00:21:26,240 --> 00:21:28,480
implications of this so

530
00:21:28,480 --> 00:21:29,919
like i said before these privacy

531
00:21:29,919 --> 00:21:31,520
sensitive applications that we ran

532
00:21:31,520 --> 00:21:33,679
retroscope on they're not broken

533
00:21:33,679 --> 00:21:36,799
retroscope is not exploiting anything to

534
00:21:36,799 --> 00:21:39,600
do this recovery uh the the thing here

535
00:21:39,600 --> 00:21:42,080
is that most apps just assume that their

536
00:21:42,080 --> 00:21:45,039
memory is private you know you so

537
00:21:45,039 --> 00:21:46,960
there's little incentive nowadays to

538
00:21:46,960 --> 00:21:49,360
protect an application's own memory

539
00:21:49,360 --> 00:21:51,280
right like for instance if you get a

540
00:21:51,280 --> 00:21:53,360
malware into your own memory then you

541
00:21:53,360 --> 00:21:55,200
kind of assume all bets are off at that

542
00:21:55,200 --> 00:21:56,640
point

543
00:21:56,640 --> 00:21:58,400
but what retroscope is doing is it's

544
00:21:58,400 --> 00:22:01,039
just emulating the natural behavior of

545
00:22:01,039 --> 00:22:03,200
the android framework and so if you

546
00:22:03,200 --> 00:22:05,760
wanted to disrupt retroscope you would

547
00:22:05,760 --> 00:22:08,000
also kind of have to hinder the app's

548
00:22:08,000 --> 00:22:10,159
own ability to draw its screen because

549
00:22:10,159 --> 00:22:13,360
we're just reusing those in place uh

550
00:22:13,360 --> 00:22:15,200
redrawing routines

551
00:22:15,200 --> 00:22:17,520
so you could think maybe one extreme way

552
00:22:17,520 --> 00:22:19,760
would be to add encryption logic into

553
00:22:19,760 --> 00:22:22,559
the app to encrypt that that memory but

554
00:22:22,559 --> 00:22:24,400
that probably wouldn't work because the

555
00:22:24,400 --> 00:22:26,559
decryption routines would have to also

556
00:22:26,559 --> 00:22:28,640
be in the drawing code so the app could

557
00:22:28,640 --> 00:22:30,960
show its own memory

558
00:22:30,960 --> 00:22:32,240
and then you could come up with other

559
00:22:32,240 --> 00:22:34,480
approaches like zeroing out all of the

560
00:22:34,480 --> 00:22:37,120
data after you show a new screen but

561
00:22:37,120 --> 00:22:38,720
then that's going to come with a lot of

562
00:22:38,720 --> 00:22:40,559
usability constraints because you'll

563
00:22:40,559 --> 00:22:43,039
have to get that data back the next time

564
00:22:43,039 --> 00:22:44,799
you want to show the screen and you'll

565
00:22:44,799 --> 00:22:47,039
have to go to the network or to disk to

566
00:22:47,039 --> 00:22:49,440
do that so you can think of a bunch of

567
00:22:49,440 --> 00:22:52,080
different ways of zeroing out memory

568
00:22:52,080 --> 00:22:53,840
more efficiently but it's always going

569
00:22:53,840 --> 00:22:56,000
to come down to this privacy versus

570
00:22:56,000 --> 00:22:58,000
usability situation

571
00:22:58,000 --> 00:23:00,400
and just in case you're worried

572
00:23:00,400 --> 00:23:02,000
i don't know how much it comforts you

573
00:23:02,000 --> 00:23:04,559
but normal citizens like you and i are

574
00:23:04,559 --> 00:23:06,720
protected from this kind of invasive

575
00:23:06,720 --> 00:23:09,280
forensics by pretty strict legal

576
00:23:09,280 --> 00:23:10,880
protocols

577
00:23:10,880 --> 00:23:12,400
and this is things like you have to

578
00:23:12,400 --> 00:23:14,240
obtain a search warrant before you can

579
00:23:14,240 --> 00:23:16,240
do these kinds of invasive forensics and

580
00:23:16,240 --> 00:23:17,919
there's also very strict chains of

581
00:23:17,919 --> 00:23:20,880
custody to use this stuff as evidence in

582
00:23:20,880 --> 00:23:22,880
court so that's just something to

583
00:23:22,880 --> 00:23:24,559
consider i don't know if it comforts you

584
00:23:24,559 --> 00:23:26,879
or not

585
00:23:27,760 --> 00:23:30,000
i'll just reduce google so you mentioned

586
00:23:30,000 --> 00:23:32,400
zeroing out memory i'm wondering if

587
00:23:32,400 --> 00:23:35,280
something less

588
00:23:35,280 --> 00:23:38,159
involved like just nulling out or just

589
00:23:38,159 --> 00:23:40,720
unlinking data structures on logout

590
00:23:40,720 --> 00:23:44,240
would be sufficient to block retroscope

591
00:23:44,240 --> 00:23:46,720
so if you explicitly went through and

592
00:23:46,720 --> 00:23:49,440
nulled out pointers then it would make

593
00:23:49,440 --> 00:23:51,600
things more difficult for retroscope but

594
00:23:51,600 --> 00:23:54,000
then that's the same question of how is

595
00:23:54,000 --> 00:23:56,400
the app going to redraw that screen if

596
00:23:56,400 --> 00:23:58,000
it's already messed up the data

597
00:23:58,000 --> 00:24:00,240
structures that it was using right if on

598
00:24:00,240 --> 00:24:01,279
logout

599
00:24:01,279 --> 00:24:03,679
on logout oh okay so that's a different

600
00:24:03,679 --> 00:24:05,760
question yeah when you log out of an app

601
00:24:05,760 --> 00:24:08,159
it probably should be cleaning up behind

602
00:24:08,159 --> 00:24:10,640
itself but that goes to the first point

603
00:24:10,640 --> 00:24:13,120
where apps just assume that their memory

604
00:24:13,120 --> 00:24:15,440
is private and so usually when you log

605
00:24:15,440 --> 00:24:17,360
out of an app it's just setting a bit

606
00:24:17,360 --> 00:24:19,840
right to tell the app to ask you to log

607
00:24:19,840 --> 00:24:21,840
back in the next time you open it and it

608
00:24:21,840 --> 00:24:24,320
just assumes its memory is private i

609
00:24:24,320 --> 00:24:26,240
mean when you log out it'll lock you

610
00:24:26,240 --> 00:24:28,559
know the encrypted databases and stuff

611
00:24:28,559 --> 00:24:30,640
and it uses encrypted network traffic

612
00:24:30,640 --> 00:24:31,440
but

613
00:24:31,440 --> 00:24:33,919
yeah no one really has incentives yet to

614
00:24:33,919 --> 00:24:36,080
protect their own app's memory maybe

615
00:24:36,080 --> 00:24:37,520
this will start it i guess you'd think

616
00:24:37,520 --> 00:24:38,880
you'd think that they'd want to null out

617
00:24:38,880 --> 00:24:40,080
the pointers to trigger garbage

618
00:24:40,080 --> 00:24:42,159
collection just as a sort of performance

619
00:24:42,159 --> 00:24:43,840
thing yeah anyway thanks a lot awesome

620
00:24:43,840 --> 00:24:45,039
research yeah it's a great question

621
00:24:45,039 --> 00:24:46,400
thanks

622
00:24:46,400 --> 00:24:48,880
hi i've got a uh patrick hulen mit

623
00:24:48,880 --> 00:24:50,400
lincoln lab uh i've got a pretty

624
00:24:50,400 --> 00:24:52,159
technical question um is is there a

625
00:24:52,159 --> 00:24:55,120
reason you went the route of like sort

626
00:24:55,120 --> 00:24:57,679
of kind of grafting this process from

627
00:24:57,679 --> 00:25:00,400
the target device out into a new

628
00:25:00,400 --> 00:25:02,320
android emulator and then executing it

629
00:25:02,320 --> 00:25:04,400
there instead of just using the memory

630
00:25:04,400 --> 00:25:06,400
image as like

631
00:25:06,400 --> 00:25:09,120
a snapshot to begin running in like a

632
00:25:09,120 --> 00:25:12,240
new emulated android process

633
00:25:12,240 --> 00:25:14,880
yeah so that's a good question and and

634
00:25:14,880 --> 00:25:16,640
actually one that i get frequently with

635
00:25:16,640 --> 00:25:19,159
the memory forensics work it's actually

636
00:25:19,159 --> 00:25:21,520
surprisingly difficult to start

637
00:25:21,520 --> 00:25:24,159
re-executing a a you know a static

638
00:25:24,159 --> 00:25:26,640
memory image because especially on

639
00:25:26,640 --> 00:25:29,279
android there is a ton of system

640
00:25:29,279 --> 00:25:32,080
services like open pipes like we just

641
00:25:32,080 --> 00:25:34,080
saw two talks about the binders and the

642
00:25:34,080 --> 00:25:36,159
intents and all these things that have

643
00:25:36,159 --> 00:25:38,400
to pair up very carefully with the

644
00:25:38,400 --> 00:25:40,960
runtime environment so you could go the

645
00:25:40,960 --> 00:25:43,039
route that would be a ton of engineering

646
00:25:43,039 --> 00:25:45,279
to like re-piece back together all of

647
00:25:45,279 --> 00:25:47,520
those things but the way that we did it

648
00:25:47,520 --> 00:25:50,640
was to use a good live environment as it

649
00:25:50,640 --> 00:25:53,279
was and then start grafting in from the

650
00:25:53,279 --> 00:25:54,960
memory image

651
00:25:54,960 --> 00:25:57,200
i see okay thanks yeah yeah great

652
00:25:57,200 --> 00:25:58,799
question here

653
00:25:58,799 --> 00:26:01,360
hi uh i'm monsieur kravchuk from cisco

654
00:26:01,360 --> 00:26:03,919
great talk uh just a quick uh

655
00:26:03,919 --> 00:26:06,000
question could you elaborate on did you

656
00:26:06,000 --> 00:26:08,640
grab the physical memory of the device

657
00:26:08,640 --> 00:26:11,919
or it was application only memory

658
00:26:11,919 --> 00:26:12,880
so

659
00:26:12,880 --> 00:26:14,799
that's a good question because in a real

660
00:26:14,799 --> 00:26:16,640
forensics investigation you could it

661
00:26:16,640 --> 00:26:18,799
depends on how you're grabbing the

662
00:26:18,799 --> 00:26:22,320
memory retroscope the tool is kind of at

663
00:26:22,320 --> 00:26:24,720
the end of that tool chain so it only

664
00:26:24,720 --> 00:26:27,679
takes in a single applications virtual

665
00:26:27,679 --> 00:26:28,960
memory session

666
00:26:28,960 --> 00:26:30,960
but if you're an investigator to get

667
00:26:30,960 --> 00:26:33,679
there then you take you know all the way

668
00:26:33,679 --> 00:26:35,679
at the bottom you could take a physical

669
00:26:35,679 --> 00:26:37,840
memory image and then there's already

670
00:26:37,840 --> 00:26:40,640
tools that exist like volatility plugins

671
00:26:40,640 --> 00:26:42,559
that take in a physical memory image

672
00:26:42,559 --> 00:26:44,640
split it into multiple virtual memory

673
00:26:44,640 --> 00:26:46,400
images and then you could insert those

674
00:26:46,400 --> 00:26:48,880
to retroscope thank you yeah no problem

675
00:26:48,880 --> 00:26:50,159
thanks

676
00:26:50,159 --> 00:26:53,840
all right thank you very much

677
00:26:54,000 --> 00:26:57,470
[Applause]

