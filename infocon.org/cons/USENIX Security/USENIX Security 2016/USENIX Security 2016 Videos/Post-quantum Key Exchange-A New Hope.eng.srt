1
00:00:11,280 --> 00:00:13,519
okay thank you very much

2
00:00:13,519 --> 00:00:16,079
yeah i'll be speaking about new hope for

3
00:00:16,079 --> 00:00:18,240
post quantum key exchange and this is

4
00:00:18,240 --> 00:00:20,240
joint work with erdem alchem who's at

5
00:00:20,240 --> 00:00:22,880
aggie university in izmir in turkey

6
00:00:22,880 --> 00:00:25,119
leo duca who's at cwi in amsterdam in

7
00:00:25,119 --> 00:00:26,640
the netherlands

8
00:00:26,640 --> 00:00:28,320
thomas potman who's at infinion in

9
00:00:28,320 --> 00:00:30,720
munich in germany and myself and i'm

10
00:00:30,720 --> 00:00:32,000
also in the netherlands in the

11
00:00:32,000 --> 00:00:34,320
university of nijmegen

12
00:00:34,320 --> 00:00:36,719
let me start my talk by a quote and it's

13
00:00:36,719 --> 00:00:39,840
a quote from about four years ago by

14
00:00:39,840 --> 00:00:42,719
mark katchen who's doing research at ibm

15
00:00:42,719 --> 00:00:45,280
and he's doing research on quantum

16
00:00:45,280 --> 00:00:46,879
computers and

17
00:00:46,879 --> 00:00:49,360
on well eventually building a large

18
00:00:49,360 --> 00:00:51,120
universal quantum computer

19
00:00:51,120 --> 00:00:54,239
and in 2012 markets said that

20
00:00:54,239 --> 00:00:57,039
in the past people have said maybe it's

21
00:00:57,039 --> 00:00:59,680
50 years away it's a dream maybe it'll

22
00:00:59,680 --> 00:01:01,920
happen sometime i used to think it was

23
00:01:01,920 --> 00:01:02,960
50.

24
00:01:02,960 --> 00:01:05,119
now i'm thinking like it's 15 or a

25
00:01:05,119 --> 00:01:07,360
little more it's within reach it's

26
00:01:07,360 --> 00:01:10,840
within our lifetime it's going to happen

27
00:01:10,840 --> 00:01:14,400
so why would we care as cryptographers

28
00:01:14,400 --> 00:01:15,920
if somebody builds a large quantum

29
00:01:15,920 --> 00:01:17,119
computer

30
00:01:17,119 --> 00:01:18,400
well

31
00:01:18,400 --> 00:01:20,880
essentially it means that if

32
00:01:20,880 --> 00:01:22,640
researchers do that if quantum engineers

33
00:01:22,640 --> 00:01:24,240
and physicists are able to build such a

34
00:01:24,240 --> 00:01:26,320
computer large enough maybe in the next

35
00:01:26,320 --> 00:01:28,159
two decades then that's the end of

36
00:01:28,159 --> 00:01:29,680
crypto as we know it

37
00:01:29,680 --> 00:01:31,600
or maybe a bit more specifically it's

38
00:01:31,600 --> 00:01:33,360
the end of asymmetric crypto as we know

39
00:01:33,360 --> 00:01:34,240
it

40
00:01:34,240 --> 00:01:37,119
and the reason for this is that in 1994

41
00:01:37,119 --> 00:01:38,240
already

42
00:01:38,240 --> 00:01:40,400
ashore published an algorithm which

43
00:01:40,400 --> 00:01:44,159
already in the title of the paper um

44
00:01:44,159 --> 00:01:46,320
well says it's doing two things two very

45
00:01:46,320 --> 00:01:47,759
special things namely it's factoring

46
00:01:47,759 --> 00:01:49,840
integers in polynomial time on such a

47
00:01:49,840 --> 00:01:51,439
universal quantum computer

48
00:01:51,439 --> 00:01:53,040
and it's computing discrete logarithms

49
00:01:53,040 --> 00:01:54,479
in polynomial time

50
00:01:54,479 --> 00:01:57,280
on a big universal quantum computer

51
00:01:57,280 --> 00:01:58,799
now these are essentially the two

52
00:01:58,799 --> 00:02:00,799
problems that all of our current

53
00:02:00,799 --> 00:02:02,719
asymmetric crypto is based on

54
00:02:02,719 --> 00:02:04,560
so for example this would mean a

55
00:02:04,560 --> 00:02:07,600
complete break of rsa of algamal

56
00:02:07,600 --> 00:02:10,479
dsa defeathelman key exchange all the

57
00:02:10,479 --> 00:02:13,520
elliptic curve variants thereof so ecdsa

58
00:02:13,520 --> 00:02:15,520
ecdh

59
00:02:15,520 --> 00:02:18,640
hdsa whatever you want to come up with

60
00:02:18,640 --> 00:02:19,520
so

61
00:02:19,520 --> 00:02:21,120
that's pretty scary

62
00:02:21,120 --> 00:02:23,040
um but well it feels like it's still

63
00:02:23,040 --> 00:02:25,680
like one or two decades away right so

64
00:02:25,680 --> 00:02:27,120
you know let's maybe do some research

65
00:02:27,120 --> 00:02:28,720
let's get some cool stuff done and maybe

66
00:02:28,720 --> 00:02:30,879
we can find solutions to this

67
00:02:30,879 --> 00:02:34,319
but actually the situation is even worse

68
00:02:34,319 --> 00:02:36,720
imagine an attacker has been named in

69
00:02:36,720 --> 00:02:38,319
the question and answers of the previous

70
00:02:38,319 --> 00:02:40,800
talk for example attacker using large

71
00:02:40,800 --> 00:02:43,200
data centers to record internet traffic

72
00:02:43,200 --> 00:02:45,760
encrypted internet traffic today

73
00:02:45,760 --> 00:02:47,440
and then maybe in like one or two

74
00:02:47,440 --> 00:02:49,040
decades when this attacker has a large

75
00:02:49,040 --> 00:02:51,360
quantum computer it's just going back

76
00:02:51,360 --> 00:02:53,440
and decrypting all that traffic that has

77
00:02:53,440 --> 00:02:55,519
been recorded before

78
00:02:55,519 --> 00:02:56,400
now

79
00:02:56,400 --> 00:02:58,239
honestly for some of the communication

80
00:02:58,239 --> 00:02:59,599
that i have on the internet which i

81
00:02:59,599 --> 00:03:00,560
encrypt

82
00:03:00,560 --> 00:03:02,400
in 20 years i probably don't care

83
00:03:02,400 --> 00:03:04,800
anymore but for some communication some

84
00:03:04,800 --> 00:03:06,640
people really do care and that would

85
00:03:06,640 --> 00:03:08,480
probably be exactly the communication

86
00:03:08,480 --> 00:03:11,360
that this attacker would target

87
00:03:11,360 --> 00:03:13,280
now sometimes when you're when you're

88
00:03:13,280 --> 00:03:14,640
looking at this kind of attack where

89
00:03:14,640 --> 00:03:15,920
somebody's recording today and then

90
00:03:15,920 --> 00:03:17,519
later looking back at it people say wait

91
00:03:17,519 --> 00:03:19,200
wait wait we have perfect forward

92
00:03:19,200 --> 00:03:20,879
secrecy

93
00:03:20,879 --> 00:03:23,200
um that's a great concept but it doesn't

94
00:03:23,200 --> 00:03:24,159
help

95
00:03:24,159 --> 00:03:26,000
so the idea in perfect forward secrecy

96
00:03:26,000 --> 00:03:28,560
is to use long-term keys only for

97
00:03:28,560 --> 00:03:30,159
authentication and use short-term

98
00:03:30,159 --> 00:03:32,400
ephemeral keys for encryption and the

99
00:03:32,400 --> 00:03:34,000
idea is that if the long term keys get

100
00:03:34,000 --> 00:03:35,519
compromised for example by somebody

101
00:03:35,519 --> 00:03:37,040
breaking into my laptop and stealing all

102
00:03:37,040 --> 00:03:39,040
my keys it's not possible to just go

103
00:03:39,040 --> 00:03:40,799
back and use those keys to decrypt all

104
00:03:40,799 --> 00:03:43,360
old information because it has been

105
00:03:43,360 --> 00:03:45,440
encrypted under short time ephemeral

106
00:03:45,440 --> 00:03:47,840
keys that have been immediately deleted

107
00:03:47,840 --> 00:03:49,519
however that doesn't help against a

108
00:03:49,519 --> 00:03:51,519
cryptographic break because you can just

109
00:03:51,519 --> 00:03:53,200
go back to all the recorded traffic and

110
00:03:53,200 --> 00:03:54,879
break one of the key exchanges after the

111
00:03:54,879 --> 00:03:56,720
other that's a linear slowdown but

112
00:03:56,720 --> 00:03:58,080
that's still not particularly good if

113
00:03:58,080 --> 00:03:59,519
you have a polynomial time algorithm to

114
00:03:59,519 --> 00:04:01,120
break stuff

115
00:04:01,120 --> 00:04:02,400
now not saying that perfect forward

116
00:04:02,400 --> 00:04:04,239
secrecy is bad we definitely want this

117
00:04:04,239 --> 00:04:06,799
it's giving us a very very strong

118
00:04:06,799 --> 00:04:09,120
protection against a real life real

119
00:04:09,120 --> 00:04:12,400
world issue so what we want today

120
00:04:12,400 --> 00:04:13,439
is

121
00:04:13,439 --> 00:04:16,399
post quantum perfect for its secret um

122
00:04:16,399 --> 00:04:18,320
crypto

123
00:04:18,320 --> 00:04:20,000
and obviously if we want this we can't

124
00:04:20,000 --> 00:04:21,918
build it on the problems um that i wrote

125
00:04:21,918 --> 00:04:25,040
down be above so we can't build this on

126
00:04:25,040 --> 00:04:27,280
discrete logarithms as in

127
00:04:27,280 --> 00:04:29,040
diffie-hellman for example or elliptic

128
00:04:29,040 --> 00:04:31,759
curve discrete logarithms or factoring

129
00:04:31,759 --> 00:04:34,479
so there needs to be some other problem

130
00:04:34,479 --> 00:04:36,320
which we can use to build asymmetric

131
00:04:36,320 --> 00:04:38,400
crypto and more specifically that we can

132
00:04:38,400 --> 00:04:40,720
use to build ephemeral key exchanges

133
00:04:40,720 --> 00:04:43,759
that quantum computers as far as we know

134
00:04:43,759 --> 00:04:46,479
do not completely break

135
00:04:46,479 --> 00:04:48,479
here's that problem well at least the

136
00:04:48,479 --> 00:04:50,080
problem that i will use for the rest of

137
00:04:50,080 --> 00:04:52,560
the talk there are some others

138
00:04:52,560 --> 00:04:54,400
so the problem that i will use in the

139
00:04:54,400 --> 00:04:55,680
rest of the talk is called the ring

140
00:04:55,680 --> 00:04:57,759
learning with errors problem

141
00:04:57,759 --> 00:05:00,000
and i will use this slide to introduce a

142
00:05:00,000 --> 00:05:02,560
bit of notation so what we will need is

143
00:05:02,560 --> 00:05:04,240
one mathematical structure that we're

144
00:05:04,240 --> 00:05:06,800
working in and that is this ring r key

145
00:05:06,800 --> 00:05:08,160
and the ring argue that simply

146
00:05:08,160 --> 00:05:11,120
polynomials in a variable x

147
00:05:11,120 --> 00:05:12,479
and

148
00:05:12,479 --> 00:05:14,400
all the coefficients are taken modulo

149
00:05:14,400 --> 00:05:16,160
and integer q

150
00:05:16,160 --> 00:05:18,000
and then so that the polynomials don't

151
00:05:18,000 --> 00:05:19,919
grow arbitrarily in multiplications we

152
00:05:19,919 --> 00:05:22,639
reduce them modulo some polynomial and

153
00:05:22,639 --> 00:05:26,160
that polynomial is x to the n plus one

154
00:05:26,160 --> 00:05:27,199
okay

155
00:05:27,199 --> 00:05:29,440
so then we need chi to be an error

156
00:05:29,440 --> 00:05:31,919
distribution on this ring so typically

157
00:05:31,919 --> 00:05:34,880
something that chooses with small errors

158
00:05:34,880 --> 00:05:37,120
we will come back to that in a bit

159
00:05:37,120 --> 00:05:38,720
and then we have a secret we always have

160
00:05:38,720 --> 00:05:40,479
some secret in asymmetric cryptography

161
00:05:40,479 --> 00:05:42,160
well in almost all of cryptography

162
00:05:42,160 --> 00:05:43,759
that's s and that's just an element of

163
00:05:43,759 --> 00:05:45,120
this ring

164
00:05:45,120 --> 00:05:47,199
and now the attacker is given

165
00:05:47,199 --> 00:05:50,560
pairs of a and a s plus e

166
00:05:50,560 --> 00:05:53,120
where a is uniformly

167
00:05:53,120 --> 00:05:54,800
sampled uniformly at random from this

168
00:05:54,800 --> 00:05:56,000
ring rq

169
00:05:56,000 --> 00:05:58,080
and e is sampled from this noise or

170
00:05:58,080 --> 00:06:00,160
error distribution chi

171
00:06:00,160 --> 00:06:02,000
and the task of the attacker is to find

172
00:06:02,000 --> 00:06:02,960
s

173
00:06:02,960 --> 00:06:04,639
so that's the problem that we're going

174
00:06:04,639 --> 00:06:06,080
to base the crypto on that i will be

175
00:06:06,080 --> 00:06:08,000
talking about

176
00:06:08,000 --> 00:06:10,479
there's two very common choices here one

177
00:06:10,479 --> 00:06:12,400
very common choice for kai is to use the

178
00:06:12,400 --> 00:06:14,560
so-called discrete gaussian distribution

179
00:06:14,560 --> 00:06:15,919
it's very nice gives a very nice

180
00:06:15,919 --> 00:06:18,240
mathematic properties it allows to prove

181
00:06:18,240 --> 00:06:20,400
certain properties here

182
00:06:20,400 --> 00:06:21,840
it's not so nice when you have to

183
00:06:21,840 --> 00:06:23,759
implement this so typically when you

184
00:06:23,759 --> 00:06:25,520
implement a high quality discrete

185
00:06:25,520 --> 00:06:28,080
gaussian you end up with either

186
00:06:28,080 --> 00:06:29,919
very inefficient

187
00:06:29,919 --> 00:06:32,560
implementations or implementations that

188
00:06:32,560 --> 00:06:34,160
leak through timing information about

189
00:06:34,160 --> 00:06:35,840
the values of this noise distribution

190
00:06:35,840 --> 00:06:37,039
which is something that we really want

191
00:06:37,039 --> 00:06:38,880
to avoid in the real world

192
00:06:38,880 --> 00:06:40,720
um i will come back to this later

193
00:06:40,720 --> 00:06:42,560
because we decided not to do to use a

194
00:06:42,560 --> 00:06:44,240
discrete gaussian

195
00:06:44,240 --> 00:06:46,319
then there's a very common optimization

196
00:06:46,319 --> 00:06:48,720
and that is to use the same a for all

197
00:06:48,720 --> 00:06:49,759
users

198
00:06:49,759 --> 00:06:51,599
so you don't need to you re-sample this

199
00:06:51,599 --> 00:06:52,639
every time

200
00:06:52,639 --> 00:06:54,240
you just do this once and you compile it

201
00:06:54,240 --> 00:06:55,680
into your software

202
00:06:55,680 --> 00:06:57,120
we also didn't do that and i will also

203
00:06:57,120 --> 00:06:59,599
come back to that later

204
00:06:59,599 --> 00:07:01,280
let me give you a bit of a history of

205
00:07:01,280 --> 00:07:04,240
how this ring lwe and some variants of

206
00:07:04,240 --> 00:07:06,639
it have been used this is completely not

207
00:07:06,639 --> 00:07:08,240
a complete overview of the history you

208
00:07:08,240 --> 00:07:10,639
can find like typically tens of papers

209
00:07:10,639 --> 00:07:12,720
every year being published in this area

210
00:07:12,720 --> 00:07:14,720
um but it's sort of a bit of the history

211
00:07:14,720 --> 00:07:16,240
that builds up to well what i'm

212
00:07:16,240 --> 00:07:18,240
presenting in this talk

213
00:07:18,240 --> 00:07:21,440
in 1996 um hofstein pifer and silverman

214
00:07:21,440 --> 00:07:23,520
presented the entry crypto system which

215
00:07:23,520 --> 00:07:25,919
is still around today um you could can

216
00:07:25,919 --> 00:07:28,000
be seen maybe as a bit of a predecessor

217
00:07:28,000 --> 00:07:29,759
to ring lwe it can maybe also be seen as

218
00:07:29,759 --> 00:07:31,919
a bit of a competition so it's similar

219
00:07:31,919 --> 00:07:33,520
but a bit different but that was sort of

220
00:07:33,520 --> 00:07:36,000
the first cryptosystem that is well that

221
00:07:36,000 --> 00:07:38,240
survived and that is still um that

222
00:07:38,240 --> 00:07:40,479
appeared in this in this realm

223
00:07:40,479 --> 00:07:44,960
um off related to ring lwe then in 2005

224
00:07:44,960 --> 00:07:48,560
regev introduced an lwe based encryption

225
00:07:48,560 --> 00:07:50,000
so that's learning with errors without

226
00:07:50,000 --> 00:07:51,440
the ring and essentially then

227
00:07:51,440 --> 00:07:53,680
polynomials turn into large matrices and

228
00:07:53,680 --> 00:07:54,720
vectors

229
00:07:54,720 --> 00:07:56,800
so that means that keys typically become

230
00:07:56,800 --> 00:07:58,960
quite a bit larger

231
00:07:58,960 --> 00:08:01,599
and you can think of the ring lwe

232
00:08:01,599 --> 00:08:03,840
version as a specialized version of lwe

233
00:08:03,840 --> 00:08:05,919
where these large matrices have a

234
00:08:05,919 --> 00:08:07,599
certain structure that allows us to

235
00:08:07,599 --> 00:08:09,440
compress

236
00:08:09,440 --> 00:08:10,840
well compress the

237
00:08:10,840 --> 00:08:14,800
matrix in 2010 lubashovsky pyker and

238
00:08:14,800 --> 00:08:17,120
regev introduced ring lwe and then also

239
00:08:17,120 --> 00:08:19,360
while based on ringwe ring lwe-based

240
00:08:19,360 --> 00:08:20,479
encryption

241
00:08:20,479 --> 00:08:23,199
and two years later dingshier and lin

242
00:08:23,199 --> 00:08:25,360
showed how to transform this into a key

243
00:08:25,360 --> 00:08:27,360
exchange protocol

244
00:08:27,360 --> 00:08:30,479
this was improved by picard in 2014

245
00:08:30,479 --> 00:08:32,399
in particular pycat showed how to obtain

246
00:08:32,399 --> 00:08:35,519
keys that are not biased

247
00:08:35,679 --> 00:08:36,640
and

248
00:08:36,640 --> 00:08:39,440
interestingly in this 2014 paper there

249
00:08:39,440 --> 00:08:40,799
were no parameters that you could just

250
00:08:40,799 --> 00:08:42,479
take and implement this thing so i'm

251
00:08:42,479 --> 00:08:44,320
looking at this from a person who's

252
00:08:44,320 --> 00:08:45,680
writing some cryptographic software from

253
00:08:45,680 --> 00:08:48,160
time to time that paper was not actually

254
00:08:48,160 --> 00:08:50,080
telling you what to really implement um

255
00:08:50,080 --> 00:08:52,080
there was a follow-up in 2015 by boss

256
00:08:52,080 --> 00:08:54,160
castell and eric and stabila and what

257
00:08:54,160 --> 00:08:56,320
they did is they chose parameters for

258
00:08:56,320 --> 00:08:58,640
this key exchange proposed by picard in

259
00:08:58,640 --> 00:09:01,600
2014 and they implemented this and they

260
00:09:01,600 --> 00:09:04,080
integrated it into openssl and showed

261
00:09:04,080 --> 00:09:06,720
that you can actually in tls do post

262
00:09:06,720 --> 00:09:08,720
quantum key exchanges using this

263
00:09:08,720 --> 00:09:10,560
approach

264
00:09:10,560 --> 00:09:13,360
now the parameters that they chose were

265
00:09:13,360 --> 00:09:16,000
well this ring r q as i showed it before

266
00:09:16,000 --> 00:09:18,480
polynomials of um

267
00:09:18,480 --> 00:09:20,240
n coefficients

268
00:09:20,240 --> 00:09:22,160
with each coefficient being an integer

269
00:09:22,160 --> 00:09:26,000
mod q where n is 1024.

270
00:09:26,000 --> 00:09:28,720
sq they chose 2 to the 32 minus 1. for

271
00:09:28,720 --> 00:09:29,920
those if you're interested that's not a

272
00:09:29,920 --> 00:09:33,279
prime um it's obviously a 32-bit integer

273
00:09:33,279 --> 00:09:34,959
um and as a noise distribution that

274
00:09:34,959 --> 00:09:36,320
chose exactly what i mentioned before

275
00:09:36,320 --> 00:09:38,560
this discrete gaussian with a

276
00:09:38,560 --> 00:09:40,640
standard deviation sigma of something

277
00:09:40,640 --> 00:09:43,040
like 3.19 t

278
00:09:43,040 --> 00:09:45,040
and what their paper claimed

279
00:09:45,040 --> 00:09:48,480
was that they have 128 bits of security

280
00:09:48,480 --> 00:09:50,399
but only pre-quanta

281
00:09:50,399 --> 00:09:52,080
so they did not look at okay so what

282
00:09:52,080 --> 00:09:53,680
happens if an attacker has a big quantum

283
00:09:53,680 --> 00:09:55,839
computer as far as we know the attacker

284
00:09:55,839 --> 00:09:57,440
doesn't break this in polynomial time

285
00:09:57,440 --> 00:09:59,120
otherwise while we would be in very

286
00:09:59,120 --> 00:10:01,040
serious trouble but that doesn't mean

287
00:10:01,040 --> 00:10:02,640
that a large quantum computer can't do

288
00:10:02,640 --> 00:10:04,480
anything they didn't analyze that they

289
00:10:04,480 --> 00:10:06,800
just said well pre-quantum currently 128

290
00:10:06,800 --> 00:10:08,240
bets

291
00:10:08,240 --> 00:10:10,240
and then they had a failure probability

292
00:10:10,240 --> 00:10:13,120
in there which was extremely small so

293
00:10:13,120 --> 00:10:17,040
something like 2 to the minus 131 000

294
00:10:17,040 --> 00:10:18,640
this idea of a failure probability is

295
00:10:18,640 --> 00:10:20,560
essentially that if you make the noise

296
00:10:20,560 --> 00:10:22,320
too large then at some point everything

297
00:10:22,320 --> 00:10:23,920
will fail if you make the noise too

298
00:10:23,920 --> 00:10:25,760
small it will become insecure

299
00:10:25,760 --> 00:10:27,680
um very obviously if the set or set the

300
00:10:27,680 --> 00:10:29,760
noise to zero you get um you can solve

301
00:10:29,760 --> 00:10:31,200
the whole thing just with a gaussian

302
00:10:31,200 --> 00:10:33,120
elimination and if you make it too large

303
00:10:33,120 --> 00:10:34,560
then it doesn't help so basically this

304
00:10:34,560 --> 00:10:36,880
noise balances between security and

305
00:10:36,880 --> 00:10:38,399
failure probability and the failure

306
00:10:38,399 --> 00:10:41,279
probability was enormously small

307
00:10:41,279 --> 00:10:43,120
okay so what we decided is let's

308
00:10:43,120 --> 00:10:45,040
reconsider this and let's see whether we

309
00:10:45,040 --> 00:10:46,880
can do better in terms of security in

310
00:10:46,880 --> 00:10:49,120
terms of performance and let's see where

311
00:10:49,120 --> 00:10:50,480
we get and whether we can make this

312
00:10:50,480 --> 00:10:52,720
maybe a bit more practical because the

313
00:10:52,720 --> 00:10:54,000
performance

314
00:10:54,000 --> 00:10:55,760
well we will see numbers later was not

315
00:10:55,760 --> 00:10:58,720
as good as it can be

316
00:10:58,880 --> 00:11:00,959
before i look at what we did let's look

317
00:11:00,959 --> 00:11:02,480
at the protocol because this is a pretty

318
00:11:02,480 --> 00:11:04,560
nice well sort of easy version of how

319
00:11:04,560 --> 00:11:06,880
this how this key exchange works

320
00:11:06,880 --> 00:11:09,279
so again up here you have um you have

321
00:11:09,279 --> 00:11:10,800
the system parameters as i mentioned

322
00:11:10,800 --> 00:11:12,160
then before with the the other

323
00:11:12,160 --> 00:11:13,680
distribution and then there's some

324
00:11:13,680 --> 00:11:15,600
global system parameter that's this a

325
00:11:15,600 --> 00:11:17,120
and as i mentioned before they use this

326
00:11:17,120 --> 00:11:20,720
optimization of saying here's a global a

327
00:11:20,720 --> 00:11:22,480
then

328
00:11:22,480 --> 00:11:25,519
alice the server samples some

329
00:11:25,519 --> 00:11:27,519
s and e and actually s is also sampled

330
00:11:27,519 --> 00:11:29,200
from this noise distribution that's

331
00:11:29,200 --> 00:11:31,440
common way to do it and then compute b

332
00:11:31,440 --> 00:11:33,279
which is a s plus e so that's exactly

333
00:11:33,279 --> 00:11:34,959
this computation that we saw before

334
00:11:34,959 --> 00:11:36,800
which is then handed over to an attacker

335
00:11:36,800 --> 00:11:38,320
and yeah this handed over to attackers

336
00:11:38,320 --> 00:11:39,760
sent over the channel

337
00:11:39,760 --> 00:11:42,160
and then bob receives this and does two

338
00:11:42,160 --> 00:11:43,440
very similar computations here to

339
00:11:43,440 --> 00:11:45,680
compute u and v

340
00:11:45,680 --> 00:11:48,720
and then sends u over to alice

341
00:11:48,720 --> 00:11:50,639
and alice multiplies that by s and by

342
00:11:50,639 --> 00:11:53,279
two and then obtains this term

343
00:11:53,279 --> 00:11:56,320
this is this two a s s prime plus 2 e

344
00:11:56,320 --> 00:11:57,440
prime s

345
00:11:57,440 --> 00:11:59,519
and bob on this side has a similar value

346
00:11:59,519 --> 00:12:00,959
that's this v bar

347
00:12:00,959 --> 00:12:03,279
which is well you take the v value and

348
00:12:03,279 --> 00:12:04,639
then you put it through a randomized

349
00:12:04,639 --> 00:12:06,560
double function so this randomized

350
00:12:06,560 --> 00:12:08,560
double function that has a bit of

351
00:12:08,560 --> 00:12:10,639
randomness coming in and that is exactly

352
00:12:10,639 --> 00:12:12,079
ensuring it's this trick by to

353
00:12:12,079 --> 00:12:13,279
make sure that in the end you have an

354
00:12:13,279 --> 00:12:15,440
unbiased key

355
00:12:15,440 --> 00:12:18,240
and then what bob gets is this v bar

356
00:12:18,240 --> 00:12:20,800
which is well this two a s s prime plus

357
00:12:20,800 --> 00:12:22,000
two e s

358
00:12:22,000 --> 00:12:24,880
e s prime plus 2 e double prime

359
00:12:24,880 --> 00:12:26,480
now these terms here that's sort of the

360
00:12:26,480 --> 00:12:28,639
large term that's this

361
00:12:28,639 --> 00:12:30,240
term that both have the same and then

362
00:12:30,240 --> 00:12:32,639
behind there there's some error terms

363
00:12:32,639 --> 00:12:34,560
so the idea of this key exchange is that

364
00:12:34,560 --> 00:12:36,720
both parties have a value which is well

365
00:12:36,720 --> 00:12:38,880
similar but not the same

366
00:12:38,880 --> 00:12:40,399
and then one party sends a bit of extra

367
00:12:40,399 --> 00:12:42,320
information over this

368
00:12:42,320 --> 00:12:44,160
v prime here

369
00:12:44,160 --> 00:12:46,240
and this v prime is then being used to

370
00:12:46,240 --> 00:12:49,920
agree on an exact value

371
00:12:50,079 --> 00:12:51,040
okay

372
00:12:51,040 --> 00:12:52,880
now our contributions was that first of

373
00:12:52,880 --> 00:12:54,959
all we said we don't really need a

374
00:12:54,959 --> 00:12:56,480
failure probability which is that

375
00:12:56,480 --> 00:12:57,519
terribly

376
00:12:57,519 --> 00:12:59,839
low we don't need 2 to the minus 131

377
00:12:59,839 --> 00:13:00,880
000.

378
00:13:00,880 --> 00:13:03,440
um we discussed it with a few people

379
00:13:03,440 --> 00:13:05,920
who are actually um well working on tls

380
00:13:05,920 --> 00:13:08,320
libraries and we heard that 2 to the

381
00:13:08,320 --> 00:13:10,160
minus 60 is just fine

382
00:13:10,160 --> 00:13:12,079
if something happens with probability 2

383
00:13:12,079 --> 00:13:14,000
to the minus 60 there's failures that

384
00:13:14,000 --> 00:13:15,360
happen more often than well you just

385
00:13:15,360 --> 00:13:17,120
retry you just agree on a new well you

386
00:13:17,120 --> 00:13:19,760
run the whole thing again

387
00:13:19,760 --> 00:13:21,600
then we came up with a very tight

388
00:13:21,600 --> 00:13:23,120
analysis of what the failure probability

389
00:13:23,120 --> 00:13:24,399
actually is which allowed us to choose

390
00:13:24,399 --> 00:13:26,560
the other parameters to actually get to

391
00:13:26,560 --> 00:13:29,040
this failure probability

392
00:13:29,040 --> 00:13:31,519
we decided to keep the dimension so 1024

393
00:13:31,519 --> 00:13:33,440
as as a dimension n

394
00:13:33,440 --> 00:13:36,079
but choose q much much smaller

395
00:13:36,079 --> 00:13:37,600
now typically in cryptography when you

396
00:13:37,600 --> 00:13:39,600
make parameters smaller things become

397
00:13:39,600 --> 00:13:40,880
less secure

398
00:13:40,880 --> 00:13:42,959
and here exactly the opposite happens

399
00:13:42,959 --> 00:13:45,199
when you make q smaller the intuition is

400
00:13:45,199 --> 00:13:47,199
that then the noise matters more

401
00:13:47,199 --> 00:13:49,920
so what you care about is how much does

402
00:13:49,920 --> 00:13:51,440
the noise matter in relation to the

403
00:13:51,440 --> 00:13:53,360
value q so if you make q smaller

404
00:13:53,360 --> 00:13:55,279
everything becomes more secure also

405
00:13:55,279 --> 00:13:57,680
messages become shorter and well if you

406
00:13:57,680 --> 00:13:59,279
work with smaller values there's some

407
00:13:59,279 --> 00:14:01,519
speed ups

408
00:14:01,519 --> 00:14:03,440
um we decided to analyze the post

409
00:14:03,440 --> 00:14:05,519
quantum security so we said we're not so

410
00:14:05,519 --> 00:14:06,959
interested in what can attackers do

411
00:14:06,959 --> 00:14:09,199
today but what does an attacker do

412
00:14:09,199 --> 00:14:10,639
breaking this maybe in a few years with

413
00:14:10,639 --> 00:14:13,440
a quantum computer

414
00:14:13,440 --> 00:14:15,199
um then we said we don't want discussion

415
00:14:15,199 --> 00:14:17,040
noise because it's really hard to sample

416
00:14:17,040 --> 00:14:19,440
and quite a bit of the inefficiency

417
00:14:19,440 --> 00:14:21,120
of this bcns proposal that i showed

418
00:14:21,120 --> 00:14:22,480
before came from the fact that they were

419
00:14:22,480 --> 00:14:24,160
using a discrete gaussian

420
00:14:24,160 --> 00:14:26,160
and we realized that you need something

421
00:14:26,160 --> 00:14:27,839
which looks kinda gaussian but it

422
00:14:27,839 --> 00:14:29,839
doesn't have to be a real gaussian so

423
00:14:29,839 --> 00:14:32,079
you just say okay take two k-bit

424
00:14:32,079 --> 00:14:33,440
integers a and b

425
00:14:33,440 --> 00:14:34,959
compute the hamming weight of them and

426
00:14:34,959 --> 00:14:36,480
then just subtract the hemming weights

427
00:14:36,480 --> 00:14:39,440
that looks kinda awesome

428
00:14:39,440 --> 00:14:41,519
and that's just good enough

429
00:14:41,519 --> 00:14:42,880
and there's a proof that this is good

430
00:14:42,880 --> 00:14:45,120
enough in the paper

431
00:14:45,120 --> 00:14:47,040
and then we said we choose a fresh a for

432
00:14:47,040 --> 00:14:48,639
every protocol run which is obviously

433
00:14:48,639 --> 00:14:50,480
making things slower i mean if you need

434
00:14:50,480 --> 00:14:52,240
to sample in ua every time it's

435
00:14:52,240 --> 00:14:54,240
definitely slower i'll come back to why

436
00:14:54,240 --> 00:14:56,399
we did this later

437
00:14:56,399 --> 00:14:58,240
and then we encode polynomials that we

438
00:14:58,240 --> 00:14:59,760
send over the channel in the entity

439
00:14:59,760 --> 00:15:01,360
domain so basically you can think of

440
00:15:01,360 --> 00:15:02,880
this as we take a polynomial and run an

441
00:15:02,880 --> 00:15:04,399
fft over it

442
00:15:04,399 --> 00:15:06,079
and that allows us to do very efficient

443
00:15:06,079 --> 00:15:08,480
multiplications and actually save a few

444
00:15:08,480 --> 00:15:10,320
of those fft transformations which is

445
00:15:10,320 --> 00:15:13,040
the main arithmetic cost

446
00:15:13,040 --> 00:15:14,720
and then we implemented the whole thing

447
00:15:14,720 --> 00:15:16,959
um and well i'll say a bit about the

448
00:15:16,959 --> 00:15:18,240
speed later

449
00:15:18,240 --> 00:15:20,000
so now i can't really talk about any of

450
00:15:20,000 --> 00:15:21,839
these contributions in very much detail

451
00:15:21,839 --> 00:15:23,600
the paper has very nice pictures on all

452
00:15:23,600 --> 00:15:25,040
of this i can't show those that would

453
00:15:25,040 --> 00:15:26,720
take too much time so we'll give a bit

454
00:15:26,720 --> 00:15:27,839
of an idea of what each of these

455
00:15:27,839 --> 00:15:29,839
contributions means and then see where

456
00:15:29,839 --> 00:15:31,040
we end up in the end in terms of

457
00:15:31,040 --> 00:15:33,680
performance and security

458
00:15:33,680 --> 00:15:35,279
first this is what our protocol now

459
00:15:35,279 --> 00:15:38,000
looks like you see that up here there's

460
00:15:38,000 --> 00:15:39,920
no system parameter anymore what we get

461
00:15:39,920 --> 00:15:43,519
instead is that alice the server

462
00:15:43,519 --> 00:15:46,639
is taking a seed and then is expanding

463
00:15:46,639 --> 00:15:49,279
this seed through shake 128 that's an

464
00:15:49,279 --> 00:15:51,040
extendable output function from the fib

465
00:15:51,040 --> 00:15:53,040
202 standard

466
00:15:53,040 --> 00:15:54,480
and then while

467
00:15:54,480 --> 00:15:56,720
parsing this into a uniformly

468
00:15:56,720 --> 00:15:58,480
distributed a

469
00:15:58,480 --> 00:16:00,320
and sending the seed over so that bob

470
00:16:00,320 --> 00:16:02,639
can do the same on that side

471
00:16:02,639 --> 00:16:04,320
and what also changed compared to the

472
00:16:04,320 --> 00:16:05,600
previous

473
00:16:05,600 --> 00:16:07,360
protocol is that while choosing noise

474
00:16:07,360 --> 00:16:09,199
from a different distribution

475
00:16:09,199 --> 00:16:10,160
and

476
00:16:10,160 --> 00:16:12,240
down here this error reconciliation

477
00:16:12,240 --> 00:16:14,000
works in a different way

478
00:16:14,000 --> 00:16:16,320
and i will come back to that so we don't

479
00:16:16,320 --> 00:16:18,320
have this randomized doubling anymore

480
00:16:18,320 --> 00:16:19,600
this is now replaced by something that

481
00:16:19,600 --> 00:16:21,839
we call help rack it's a somewhat of a

482
00:16:21,839 --> 00:16:23,680
generalized version of this and then in

483
00:16:23,680 --> 00:16:24,959
the end

484
00:16:24,959 --> 00:16:27,440
both part parties have a value while v

485
00:16:27,440 --> 00:16:28,560
and v prime

486
00:16:28,560 --> 00:16:30,320
they're very similar as before except

487
00:16:30,320 --> 00:16:32,480
that the factor two is missing and then

488
00:16:32,480 --> 00:16:34,160
they have this vector r of

489
00:16:34,160 --> 00:16:35,600
reconciliation information that they

490
00:16:35,600 --> 00:16:39,360
used to extract k a key uh k here and

491
00:16:39,360 --> 00:16:41,600
that one um as part of the protocol we

492
00:16:41,600 --> 00:16:43,199
put through a final hash we use chart

493
00:16:43,199 --> 00:16:44,639
three there

494
00:16:44,639 --> 00:16:48,079
that's essentially the protocol

495
00:16:48,079 --> 00:16:51,279
now this error reconciliation well as i

496
00:16:51,279 --> 00:16:53,759
said we agree on a somewhat similar

497
00:16:53,759 --> 00:16:55,360
value on both sides and we need to have

498
00:16:55,360 --> 00:16:57,040
the same well we need to extract a

499
00:16:57,040 --> 00:16:58,880
common key from that

500
00:16:58,880 --> 00:16:59,839
and

501
00:16:59,839 --> 00:17:00,880
what is

502
00:17:00,880 --> 00:17:03,040
known is that well you need to send some

503
00:17:03,040 --> 00:17:05,199
additional information this r you can't

504
00:17:05,199 --> 00:17:06,959
do it without it's by the way a very fun

505
00:17:06,959 --> 00:17:08,880
exercise to think through why you can't

506
00:17:08,880 --> 00:17:10,319
spend a few hours thinking this through

507
00:17:10,319 --> 00:17:11,520
and at some point convince myself that

508
00:17:11,520 --> 00:17:13,199
it's really not possible and i think

509
00:17:13,199 --> 00:17:14,559
everybody working in this field at some

510
00:17:14,559 --> 00:17:16,880
point did

511
00:17:16,880 --> 00:17:19,439
so what is known is that you can extract

512
00:17:19,439 --> 00:17:21,439
one bit from each of the coefficients

513
00:17:21,439 --> 00:17:23,280
that you find in the literature it's

514
00:17:23,280 --> 00:17:25,280
also known how to extract multiple bits

515
00:17:25,280 --> 00:17:26,160
from

516
00:17:26,160 --> 00:17:28,079
each coefficient and then essentially

517
00:17:28,079 --> 00:17:28,960
that means that you need to choose

518
00:17:28,960 --> 00:17:30,799
slightly lower noise and that means that

519
00:17:30,799 --> 00:17:32,799
you're lower the security but we wanted

520
00:17:32,799 --> 00:17:34,880
to do something else because we had a

521
00:17:34,880 --> 00:17:37,360
1024 coefficient sitting around and we

522
00:17:37,360 --> 00:17:39,039
won the post quantum symmetric key so we

523
00:17:39,039 --> 00:17:41,840
wanted 256 bit key

524
00:17:41,840 --> 00:17:44,400
and so what we did is we showed how to

525
00:17:44,400 --> 00:17:45,760
extract one bit from multiple

526
00:17:45,760 --> 00:17:48,960
coefficients and increase the security

527
00:17:48,960 --> 00:17:51,039
and the idea is well specifically we do

528
00:17:51,039 --> 00:17:52,880
well one bit from four coefficients of

529
00:17:52,880 --> 00:17:55,120
this noisy polynomial

530
00:17:55,120 --> 00:17:57,600
and it's a method that is inspired by

531
00:17:57,600 --> 00:17:59,440
error correcting codes

532
00:17:59,440 --> 00:18:01,280
what you find in the paper is sort of a

533
00:18:01,280 --> 00:18:03,039
two-dimensional intuition for this and

534
00:18:03,039 --> 00:18:04,400
then really what is happening is a

535
00:18:04,400 --> 00:18:07,440
four-dimensional thing

536
00:18:07,440 --> 00:18:10,000
and then we generalized piker's approach

537
00:18:10,000 --> 00:18:12,320
this with this randomized doubling um to

538
00:18:12,320 --> 00:18:14,640
obtain unbiased keys

539
00:18:14,640 --> 00:18:17,520
okay so error reconciliation works

540
00:18:17,520 --> 00:18:18,799
let's take a look at post quantum

541
00:18:18,799 --> 00:18:20,000
security

542
00:18:20,000 --> 00:18:21,679
and post quantum security is pretty

543
00:18:21,679 --> 00:18:23,360
tricky because many of the algorithms

544
00:18:23,360 --> 00:18:24,320
that

545
00:18:24,320 --> 00:18:27,280
we know to solve this problem it is not

546
00:18:27,280 --> 00:18:29,120
entirely understood how

547
00:18:29,120 --> 00:18:31,520
costly they are for real parameters

548
00:18:31,520 --> 00:18:33,440
so there is some asymptotic estimation

549
00:18:33,440 --> 00:18:35,840
estimates but it's not it's not so clear

550
00:18:35,840 --> 00:18:36,960
if you throw in real parameters like

551
00:18:36,960 --> 00:18:38,400
this will be the runtime and in

552
00:18:38,400 --> 00:18:39,600
particular not if you do this whole

553
00:18:39,600 --> 00:18:41,200
thing post quantum because we don't even

554
00:18:41,200 --> 00:18:42,880
know exactly what the quantum computer

555
00:18:42,880 --> 00:18:44,400
will look like

556
00:18:44,400 --> 00:18:46,640
so we said okay the best algorithm is an

557
00:18:46,640 --> 00:18:48,799
algorithm called bkz you don't need to

558
00:18:48,799 --> 00:18:50,000
understand anything about it what you

559
00:18:50,000 --> 00:18:51,919
need to understand is as a black box

560
00:18:51,919 --> 00:18:54,240
it's calling an oracle multiple times

561
00:18:54,240 --> 00:18:55,919
and that is the shortest vector problem

562
00:18:55,919 --> 00:18:57,919
in a smaller dimension so that's this

563
00:18:57,919 --> 00:18:59,919
svp oracle here

564
00:18:59,919 --> 00:19:01,200
we just said well

565
00:19:01,200 --> 00:19:02,720
we don't really care about how often we

566
00:19:02,720 --> 00:19:04,559
need to call this oracle let's just say

567
00:19:04,559 --> 00:19:06,480
call it once everything else we give to

568
00:19:06,480 --> 00:19:07,760
the attacker for free and we just want

569
00:19:07,760 --> 00:19:09,039
to know how long does it take the

570
00:19:09,039 --> 00:19:10,480
attacker to solve this

571
00:19:10,480 --> 00:19:13,120
sap oracle once and that's what we call

572
00:19:13,120 --> 00:19:16,160
the svp core svp hardness

573
00:19:16,160 --> 00:19:17,520
and then we look at the asymptotically

574
00:19:17,520 --> 00:19:19,520
best algorithm for this in the ram model

575
00:19:19,520 --> 00:19:20,799
so we also say

576
00:19:20,799 --> 00:19:22,480
if the attacker needs a huge bunch of

577
00:19:22,480 --> 00:19:24,400
storage for this we give this storage to

578
00:19:24,400 --> 00:19:26,000
the attacker for free we only care about

579
00:19:26,000 --> 00:19:28,000
the runtime here and then we look at the

580
00:19:28,000 --> 00:19:30,000
asymptotic runtime and just assume well

581
00:19:30,000 --> 00:19:32,640
that's that's going to be the runtime

582
00:19:32,640 --> 00:19:35,919
and the best known cost for this is

583
00:19:35,919 --> 00:19:39,200
well 2 to the 0.264 n

584
00:19:39,200 --> 00:19:40,640
for dimension n

585
00:19:40,640 --> 00:19:42,640
um the best plausible quantum cost we

586
00:19:42,640 --> 00:19:44,720
also analyzed and essentially the idea

587
00:19:44,720 --> 00:19:46,480
behind this best possible quantum cost

588
00:19:46,480 --> 00:19:48,480
is that before even running anything the

589
00:19:48,480 --> 00:19:50,080
attacker needs a certain set of input

590
00:19:50,080 --> 00:19:52,000
and that is generated classically on a

591
00:19:52,000 --> 00:19:53,360
classical computer there's no quantum

592
00:19:53,360 --> 00:19:55,280
computation involved and the amount of

593
00:19:55,280 --> 00:19:57,200
inputs that it need the attacker needs

594
00:19:57,200 --> 00:20:00,559
is this so that's what we say that's the

595
00:20:00,559 --> 00:20:02,159
even if you can find some cool speed ups

596
00:20:02,159 --> 00:20:04,240
in the later runtime in the sieving well

597
00:20:04,240 --> 00:20:06,960
you first need to have the input

598
00:20:06,960 --> 00:20:09,280
okay and then we analyzed this we

599
00:20:09,280 --> 00:20:12,080
analyzed this for uh the proposal by bus

600
00:20:12,080 --> 00:20:13,600
costal and eric and stabila and we

601
00:20:13,600 --> 00:20:16,400
analyzed this for the new parameters

602
00:20:16,400 --> 00:20:17,280
and

603
00:20:17,280 --> 00:20:19,039
what we see here that the

604
00:20:19,039 --> 00:20:20,720
best known classical attack without

605
00:20:20,720 --> 00:20:23,200
involving a quantum computer we get

606
00:20:23,200 --> 00:20:26,559
a bit security of 86 for bcns and almost

607
00:20:26,559 --> 00:20:29,840
300 for new hope now as i said this is

608
00:20:29,840 --> 00:20:32,320
for shorter messages and

609
00:20:32,320 --> 00:20:33,840
well we will see quite a bit of faster

610
00:20:33,840 --> 00:20:36,559
computation um and even if we go for the

611
00:20:36,559 --> 00:20:39,520
best plausible so not even currently

612
00:20:39,520 --> 00:20:42,000
clear how this would work um post

613
00:20:42,000 --> 00:20:44,000
quantum or quantum computation algorithm

614
00:20:44,000 --> 00:20:45,600
we get something like 200 bits of

615
00:20:45,600 --> 00:20:47,600
security here

616
00:20:47,600 --> 00:20:48,400
now

617
00:20:48,400 --> 00:20:50,480
this does not mean that you can actually

618
00:20:50,480 --> 00:20:53,679
break bcns in 2 to the 86

619
00:20:53,679 --> 00:20:55,440
as i said before we give a whole lot of

620
00:20:55,440 --> 00:20:56,799
things for free to the attacker so it

621
00:20:56,799 --> 00:20:58,159
could well be that the analysis that

622
00:20:58,159 --> 00:21:00,880
bcns got with 128 bits of security is

623
00:21:00,880 --> 00:21:03,120
just fine if you try to get a somewhat

624
00:21:03,120 --> 00:21:05,360
tighter analysis we just said we want

625
00:21:05,360 --> 00:21:06,880
lower bounds on the

626
00:21:06,880 --> 00:21:08,880
on the bit security here and

627
00:21:08,880 --> 00:21:11,600
be done with it

628
00:21:11,760 --> 00:21:12,640
okay

629
00:21:12,640 --> 00:21:14,960
now i mentioned that

630
00:21:14,960 --> 00:21:16,960
um we don't pick a fixed system

631
00:21:16,960 --> 00:21:18,480
parameter a

632
00:21:18,480 --> 00:21:20,000
and one reason for this is that it's

633
00:21:20,000 --> 00:21:21,840
very hard for

634
00:21:21,840 --> 00:21:24,000
um cryptographers to agree on a fixed

635
00:21:24,000 --> 00:21:25,760
random system parameter

636
00:21:25,760 --> 00:21:27,520
if you if you ask around here then

637
00:21:27,520 --> 00:21:29,039
everybody would somehow probably come up

638
00:21:29,039 --> 00:21:30,159
with some system parameter and then

639
00:21:30,159 --> 00:21:31,679
afterwards you have to agree and

640
00:21:31,679 --> 00:21:33,039
everybody who comes up with one

641
00:21:33,039 --> 00:21:34,400
parameter needs to convince everyone

642
00:21:34,400 --> 00:21:36,320
else that i don't have a backdoor

643
00:21:36,320 --> 00:21:38,080
it's not so easy

644
00:21:38,080 --> 00:21:40,320
um there is this so-called nothing up my

645
00:21:40,320 --> 00:21:42,480
sleeves approach where while you take

646
00:21:42,480 --> 00:21:43,440
some

647
00:21:43,440 --> 00:21:44,960
digits of pi for example you feed them

648
00:21:44,960 --> 00:21:46,799
through a hash function and even then

649
00:21:46,799 --> 00:21:48,559
you can write scientific papers about

650
00:21:48,559 --> 00:21:50,320
how to attack this approach so it's

651
00:21:50,320 --> 00:21:51,840
really really hard to get cryptographers

652
00:21:51,840 --> 00:21:53,919
to agree on this

653
00:21:53,919 --> 00:21:56,000
even if you manage to do this

654
00:21:56,000 --> 00:21:57,679
there's another problem

655
00:21:57,679 --> 00:21:59,840
and this other problem is assume that

656
00:21:59,840 --> 00:22:01,760
lattice script analysis really improves

657
00:22:01,760 --> 00:22:02,559
and

658
00:22:02,559 --> 00:22:03,679
there are

659
00:22:03,679 --> 00:22:05,600
possibly really big improvements ahead

660
00:22:05,600 --> 00:22:07,360
it's not like

661
00:22:07,360 --> 00:22:09,360
it's really well understood how hard

662
00:22:09,360 --> 00:22:11,360
these things are

663
00:22:11,360 --> 00:22:12,799
and let's say maybe there is an

664
00:22:12,799 --> 00:22:16,000
algorithm in say 20 years maybe 30 years

665
00:22:16,000 --> 00:22:17,840
that can solve these problems

666
00:22:17,840 --> 00:22:20,240
but not almost free but maybe it takes a

667
00:22:20,240 --> 00:22:21,679
year to compute

668
00:22:21,679 --> 00:22:23,440
now if you choose a fixed a you do this

669
00:22:23,440 --> 00:22:25,440
computation once which costs a year

670
00:22:25,440 --> 00:22:27,679
maybe under each supercomputer in 20 30

671
00:22:27,679 --> 00:22:29,200
years and then afterwards you can just

672
00:22:29,200 --> 00:22:31,280
break every single key exchange

673
00:22:31,280 --> 00:22:32,880
because the computation that you need to

674
00:22:32,880 --> 00:22:35,360
do the expensive one only depends on a

675
00:22:35,360 --> 00:22:37,200
now if you choose a different one

676
00:22:37,200 --> 00:22:39,039
different a for each key exchange then

677
00:22:39,039 --> 00:22:40,400
you would need to do a computation of

678
00:22:40,400 --> 00:22:42,240
one year for each single key exchange

679
00:22:42,240 --> 00:22:44,240
which is an additional safeguard

680
00:22:44,240 --> 00:22:45,760
so this attack that i just sketched is

681
00:22:45,760 --> 00:22:47,440
in the spirit of a lock jam attack where

682
00:22:47,440 --> 00:22:48,799
you also had like this huge

683
00:22:48,799 --> 00:22:50,720
precomputation done once and then once

684
00:22:50,720 --> 00:22:52,159
this was done and you had this this

685
00:22:52,159 --> 00:22:53,919
pre-competition results sitting around

686
00:22:53,919 --> 00:22:56,159
you could afterwards attack well every

687
00:22:56,159 --> 00:22:58,000
single diffie-hellman key exchange

688
00:22:58,000 --> 00:22:59,280
if they were using the same system

689
00:22:59,280 --> 00:23:02,640
parameter in that case the prime number

690
00:23:02,640 --> 00:23:05,120
um so as i said solution in new hope is

691
00:23:05,120 --> 00:23:08,480
well expand and fresh seed every single

692
00:23:08,480 --> 00:23:09,360
time

693
00:23:09,360 --> 00:23:10,559
and then we'll expand it through the

694
00:23:10,559 --> 00:23:13,120
shake 128 gigs off

695
00:23:13,120 --> 00:23:14,799
you can cache this so if you have a

696
00:23:14,799 --> 00:23:16,400
server that is really bottlenecked by

697
00:23:16,400 --> 00:23:18,559
computations then the server can just

698
00:23:18,559 --> 00:23:20,240
say i'm caching this for an hour and

699
00:23:20,240 --> 00:23:22,720
then an attacker in say 20 30 years with

700
00:23:22,720 --> 00:23:24,080
this advanced algorithm that we don't

701
00:23:24,080 --> 00:23:26,080
even know that will exist needs to break

702
00:23:26,080 --> 00:23:27,919
one needs to do one year of computation

703
00:23:27,919 --> 00:23:30,640
per hour it's still not so bad

704
00:23:30,640 --> 00:23:33,360
one word of warning you must not reuse

705
00:23:33,360 --> 00:23:35,120
the keys and the noise so this s and

706
00:23:35,120 --> 00:23:36,480
this e and this

707
00:23:36,480 --> 00:23:38,559
s prime e prime and e double prime

708
00:23:38,559 --> 00:23:40,960
um in diffie-hellman in or elliptic rift

709
00:23:40,960 --> 00:23:42,880
if your helmet it's common optimization

710
00:23:42,880 --> 00:23:43,679
to

711
00:23:43,679 --> 00:23:45,840
reuse ephemeral keys for like an hour or

712
00:23:45,840 --> 00:23:46,640
so

713
00:23:46,640 --> 00:23:48,480
which in ssl libraries is happening on a

714
00:23:48,480 --> 00:23:50,080
somewhat higher level now if you replace

715
00:23:50,080 --> 00:23:52,720
this or if you add in

716
00:23:52,720 --> 00:23:54,880
post quantum say new hope key exchange

717
00:23:54,880 --> 00:23:56,480
there make very sure that you're not

718
00:23:56,480 --> 00:23:58,159
reusing these secrets then things become

719
00:23:58,159 --> 00:24:00,640
insecure

720
00:24:00,720 --> 00:24:02,080
okay i said we implemented the whole

721
00:24:02,080 --> 00:24:03,039
thing

722
00:24:03,039 --> 00:24:05,840
and the multi the costly operations in

723
00:24:05,840 --> 00:24:07,200
there are these multiplications in this

724
00:24:07,200 --> 00:24:08,559
polynomial ring

725
00:24:08,559 --> 00:24:11,600
and we chose parameters such that we can

726
00:24:11,600 --> 00:24:13,279
do this through something which is uh

727
00:24:13,279 --> 00:24:14,880
well a very very efficient number

728
00:24:14,880 --> 00:24:16,799
theoretic transform so essentially the

729
00:24:16,799 --> 00:24:18,880
idea is if you have take two polynomials

730
00:24:18,880 --> 00:24:20,880
you send them through an fft then you

731
00:24:20,880 --> 00:24:22,400
multiply coefficient-wise and you do

732
00:24:22,400 --> 00:24:25,360
then an inverse fft of the result

733
00:24:25,360 --> 00:24:27,440
and fft in a finite field is well

734
00:24:27,440 --> 00:24:29,039
becomes an entity and this one is really

735
00:24:29,039 --> 00:24:30,240
really fast

736
00:24:30,240 --> 00:24:32,320
and because we're sending polynomials in

737
00:24:32,320 --> 00:24:34,880
ntt domain we don't on one side first

738
00:24:34,880 --> 00:24:36,799
transform back and then on the next side

739
00:24:36,799 --> 00:24:38,799
transform again to entity domain we just

740
00:24:38,799 --> 00:24:41,200
leave it there which saves us

741
00:24:41,200 --> 00:24:44,880
two of the required entities

742
00:24:44,880 --> 00:24:46,080
we came up with a c reference

743
00:24:46,080 --> 00:24:48,559
implementation um and when writing this

744
00:24:48,559 --> 00:24:49,840
we really kept in mind that this should

745
00:24:49,840 --> 00:24:51,360
be portable also to small embedded

746
00:24:51,360 --> 00:24:54,240
devices so we only use 16-bit and 32-bit

747
00:24:54,240 --> 00:24:57,679
integers um except in um catch-up so in

748
00:24:57,679 --> 00:24:58,559
the

749
00:24:58,559 --> 00:25:00,400
in the final hashing that is inherently

750
00:25:00,400 --> 00:25:02,799
64-bit arithmetic so we left that from

751
00:25:02,799 --> 00:25:04,320
the implementation that the catrick

752
00:25:04,320 --> 00:25:05,760
designers came up with

753
00:25:05,760 --> 00:25:06,720
um

754
00:25:06,720 --> 00:25:08,240
there's no division operators there's no

755
00:25:08,240 --> 00:25:10,080
modular operator in the whole thing so

756
00:25:10,080 --> 00:25:11,679
the whole module of arithmetic is done

757
00:25:11,679 --> 00:25:13,760
just through multiplications

758
00:25:13,760 --> 00:25:16,159
we use a trick for efficient reductions

759
00:25:16,159 --> 00:25:18,000
inside the entity modular reductions we

760
00:25:18,000 --> 00:25:20,480
use montgomery representation

761
00:25:20,480 --> 00:25:22,240
and for this noise sampling what we use

762
00:25:22,240 --> 00:25:24,640
is chacha 20 which is very portable very

763
00:25:24,640 --> 00:25:26,240
fast very easily protected against

764
00:25:26,240 --> 00:25:28,400
timing attacks

765
00:25:28,400 --> 00:25:30,000
we also optimized this for large intel

766
00:25:30,000 --> 00:25:32,080
processors and used the av x2 vector

767
00:25:32,080 --> 00:25:33,360
instruction set

768
00:25:33,360 --> 00:25:36,240
basically through all computationally

769
00:25:36,240 --> 00:25:37,919
expensive tasks

770
00:25:37,919 --> 00:25:40,000
so the entity is vectorized the centroid

771
00:25:40,000 --> 00:25:42,480
binomial sampling is vectorized

772
00:25:42,480 --> 00:25:44,400
error reconciliation is vectorized noise

773
00:25:44,400 --> 00:25:45,520
sampling

774
00:25:45,520 --> 00:25:48,240
ah here we use as256 for noise sampling

775
00:25:48,240 --> 00:25:49,760
because on all these processors there is

776
00:25:49,760 --> 00:25:52,720
aes 256 in hardware or as in hardware

777
00:25:52,720 --> 00:25:54,720
and

778
00:25:54,720 --> 00:25:56,159
as you can see it doesn't matter these

779
00:25:56,159 --> 00:25:58,000
are compatible this is a local decision

780
00:25:58,000 --> 00:26:00,080
how you sample your noise it's a local

781
00:26:00,080 --> 00:26:01,679
your local secret so you can just use

782
00:26:01,679 --> 00:26:02,880
whatever you have sitting around as an

783
00:26:02,880 --> 00:26:05,600
efficient rng

784
00:26:05,600 --> 00:26:07,600
so here's the performance as opposed to

785
00:26:07,600 --> 00:26:10,720
the performance of a bcns so you can see

786
00:26:10,720 --> 00:26:12,159
that our c reference implementation of

787
00:26:12,159 --> 00:26:15,039
the key generation and this well shared

788
00:26:15,039 --> 00:26:17,279
key computation on the client side is

789
00:26:17,279 --> 00:26:20,159
about an order of magnitude faster than

790
00:26:20,159 --> 00:26:22,640
the bcns proposal and then our avx

791
00:26:22,640 --> 00:26:24,559
implementation well is still well a

792
00:26:24,559 --> 00:26:26,159
factor of three roughly faster than our

793
00:26:26,159 --> 00:26:27,679
c implementation

794
00:26:27,679 --> 00:26:28,480
um

795
00:26:28,480 --> 00:26:30,400
for the shared key we unfortunately did

796
00:26:30,400 --> 00:26:33,039
not get exactly to the

797
00:26:33,039 --> 00:26:34,400
order of magnitude speed up but still

798
00:26:34,400 --> 00:26:36,000
it's quite a bit faster about five times

799
00:26:36,000 --> 00:26:36,960
faster

800
00:26:36,960 --> 00:26:39,120
now these numbers here include on both

801
00:26:39,120 --> 00:26:41,200
the server side and the client side this

802
00:26:41,200 --> 00:26:42,080
um

803
00:26:42,080 --> 00:26:44,720
this generation of a on both sides which

804
00:26:44,720 --> 00:26:47,120
bcns don't have and which at least on

805
00:26:47,120 --> 00:26:49,360
the server side we could cache but well

806
00:26:49,360 --> 00:26:52,080
we didn't really bother

807
00:26:52,080 --> 00:26:52,880
if

808
00:26:52,880 --> 00:26:55,039
cycles don't tell you all that much on

809
00:26:55,039 --> 00:26:57,440
intel processors to give you an idea the

810
00:26:57,440 --> 00:26:59,279
currently fastest thing that you can use

811
00:26:59,279 --> 00:27:02,080
for key exchange in tls that would be

812
00:27:02,080 --> 00:27:04,159
the x25519 elliptic curve scalar

813
00:27:04,159 --> 00:27:06,400
multiplication and if you use purely

814
00:27:06,400 --> 00:27:09,679
ephemeral things with no caching then

815
00:27:09,679 --> 00:27:11,440
each part you would need to do two

816
00:27:11,440 --> 00:27:14,000
scalar multiplications so two times this

817
00:27:14,000 --> 00:27:15,840
so in other words

818
00:27:15,840 --> 00:27:18,240
new hope is faster than what is

819
00:27:18,240 --> 00:27:19,840
currently

820
00:27:19,840 --> 00:27:21,679
included

821
00:27:21,679 --> 00:27:24,559
okay now at this point of the talk

822
00:27:24,559 --> 00:27:25,760
i should maybe answer the question

823
00:27:25,760 --> 00:27:27,440
whether you should be using this and

824
00:27:27,440 --> 00:27:29,600
then i would give you a super biased

825
00:27:29,600 --> 00:27:31,120
author opinion here whether you should

826
00:27:31,120 --> 00:27:33,039
be using it and i'm very lucky that i

827
00:27:33,039 --> 00:27:34,640
don't have to do this

828
00:27:34,640 --> 00:27:37,120
because it is currently being used

829
00:27:37,120 --> 00:27:38,080
um

830
00:27:38,080 --> 00:27:40,399
so on july 7 google announced that they

831
00:27:40,399 --> 00:27:42,640
would be running an experiment um it's a

832
00:27:42,640 --> 00:27:45,679
two-year experiment between

833
00:27:45,679 --> 00:27:48,399
chrome canary and some google services

834
00:27:48,399 --> 00:27:49,279
and

835
00:27:49,279 --> 00:27:51,919
they're running tls with a new key

836
00:27:51,919 --> 00:27:53,520
exchange

837
00:27:53,520 --> 00:27:56,640
hybrid which they call cec pq1

838
00:27:56,640 --> 00:27:58,480
and that hybrid is using exactly the

839
00:27:58,480 --> 00:28:01,360
x25519 elliptic curve key exchange that

840
00:28:01,360 --> 00:28:04,720
i mentioned before and new hope

841
00:28:04,720 --> 00:28:07,440
and well if you can run google canary

842
00:28:07,440 --> 00:28:09,279
which i cannot because i have linux and

843
00:28:09,279 --> 00:28:10,799
it's apparently not supported then you

844
00:28:10,799 --> 00:28:12,240
can see pictures like this where

845
00:28:12,240 --> 00:28:13,840
actually you see that the protocol is

846
00:28:13,840 --> 00:28:16,799
tls 1.2 with the key exchange being

847
00:28:16,799 --> 00:28:19,520
something that uses new hope

848
00:28:19,520 --> 00:28:21,200
now

849
00:28:21,200 --> 00:28:23,200
google here is actually doing exactly

850
00:28:23,200 --> 00:28:25,600
what we would also recommend namely yeah

851
00:28:25,600 --> 00:28:27,760
you should be using it if you need post

852
00:28:27,760 --> 00:28:30,000
quantum key exchange ephemeral key

853
00:28:30,000 --> 00:28:32,240
exchange now which might be because you

854
00:28:32,240 --> 00:28:33,600
have users that really care about long

855
00:28:33,600 --> 00:28:35,600
term security or because you want to

856
00:28:35,600 --> 00:28:37,279
experiment early to figure out whether

857
00:28:37,279 --> 00:28:38,960
the larger messages so messages become

858
00:28:38,960 --> 00:28:40,720
larger compared to ecc

859
00:28:40,720 --> 00:28:42,240
whether your system can handle that

860
00:28:42,240 --> 00:28:43,440
that's actually what google wants to

861
00:28:43,440 --> 00:28:45,360
also try out with this experiment

862
00:28:45,360 --> 00:28:46,640
then the second thing is you should

863
00:28:46,640 --> 00:28:48,320
always combine it with a key exchange

864
00:28:48,320 --> 00:28:50,960
that we're currently using so x25519 to

865
00:28:50,960 --> 00:28:52,399
be sure that you're not lowering

866
00:28:52,399 --> 00:28:53,919
security by using something which is

867
00:28:53,919 --> 00:28:56,159
still it feels a bit experimental and

868
00:28:56,159 --> 00:28:57,600
then the third thing is google said

869
00:28:57,600 --> 00:28:59,360
they're doing this for two years and

870
00:28:59,360 --> 00:29:00,320
they're hoping that there will be

871
00:29:00,320 --> 00:29:01,919
something better in two years and i

872
00:29:01,919 --> 00:29:04,320
would say this is entirely realistic so

873
00:29:04,320 --> 00:29:05,840
if you do it then write it in a modular

874
00:29:05,840 --> 00:29:07,200
way so that you can plug in something

875
00:29:07,200 --> 00:29:08,960
else

876
00:29:08,960 --> 00:29:10,080
if you're interested in this if you're

877
00:29:10,080 --> 00:29:11,360
interested in learning more about new

878
00:29:11,360 --> 00:29:12,640
hope or if you're interested in playing

879
00:29:12,640 --> 00:29:14,640
with the software um it's both online

880
00:29:14,640 --> 00:29:16,799
software's in the public domain

881
00:29:16,799 --> 00:29:19,279
both for download on cryptojedi.org

882
00:29:19,279 --> 00:29:20,320
and

883
00:29:20,320 --> 00:29:22,000
after we put this paper online several

884
00:29:22,000 --> 00:29:24,320
people well followed up on this

885
00:29:24,320 --> 00:29:26,799
there's now more software um there's

886
00:29:26,799 --> 00:29:29,200
software by um by adam who's also an

887
00:29:29,200 --> 00:29:32,320
author of this paper and philip yakubite

888
00:29:32,320 --> 00:29:34,399
and myself we optimized this also for

889
00:29:34,399 --> 00:29:36,159
embedded arm processors

890
00:29:36,159 --> 00:29:38,240
um yawning angel

891
00:29:38,240 --> 00:29:40,720
optimized it in go uh isis lovecraft

892
00:29:40,720 --> 00:29:43,200
wrote a rust implementation rusevlay

893
00:29:43,200 --> 00:29:45,120
wrote the java implementation and only

894
00:29:45,120 --> 00:29:47,120
very recently i learned that alexander

895
00:29:47,120 --> 00:29:49,360
farrar is wrote an erlang implementation

896
00:29:49,360 --> 00:29:50,559
of new hope

897
00:29:50,559 --> 00:29:51,760
so

898
00:29:51,760 --> 00:29:53,279
i know that most of this code is in

899
00:29:53,279 --> 00:29:55,279
public domain for the ones that i didn't

900
00:29:55,279 --> 00:29:56,720
write please double check on the on the

901
00:29:56,720 --> 00:29:58,399
respective websites

902
00:29:58,399 --> 00:29:59,440
if you have any questions about this

903
00:29:59,440 --> 00:30:00,799
then of course i'm open for questions

904
00:30:00,799 --> 00:30:02,240
now you can also write us an email to

905
00:30:02,240 --> 00:30:04,559
newhope cryptojedi.org and for now i

906
00:30:04,559 --> 00:30:06,450
thank you for your attention

907
00:30:06,450 --> 00:30:08,600
[Applause]

908
00:30:08,600 --> 00:30:09,910
[Music]

909
00:30:09,910 --> 00:30:15,650
[Applause]

910
00:30:15,840 --> 00:30:16,960
um

911
00:30:16,960 --> 00:30:19,840
sorry diminishing culture luxembourg

912
00:30:19,840 --> 00:30:22,399
what are the units of cost where you

913
00:30:22,399 --> 00:30:25,200
measure the security

914
00:30:25,200 --> 00:30:27,120
um

915
00:30:27,120 --> 00:30:29,120
so that would be the asymptotic

916
00:30:29,120 --> 00:30:30,720
complexity of

917
00:30:30,720 --> 00:30:32,080
the

918
00:30:32,080 --> 00:30:33,840
of the sieving algorithm

919
00:30:33,840 --> 00:30:35,440
and then this is hiding all kind of

920
00:30:35,440 --> 00:30:36,960
linear factors that you might want to

921
00:30:36,960 --> 00:30:39,200
want to throw in there so this is so you

922
00:30:39,200 --> 00:30:41,840
would need something like two to the 199

923
00:30:41,840 --> 00:30:43,279
operations where these operations are

924
00:30:43,279 --> 00:30:44,960
actually pretty large things

925
00:30:44,960 --> 00:30:46,399
but we give those large things to the

926
00:30:46,399 --> 00:30:47,760
attacker for free we just say it's an

927
00:30:47,760 --> 00:30:49,679
operation some

928
00:30:49,679 --> 00:30:52,480
small atomic operations

929
00:30:52,480 --> 00:30:54,000
as far as i understand not all that

930
00:30:54,000 --> 00:30:56,240
small and they also involve pretty big

931
00:30:56,240 --> 00:30:57,840
access to pretty big memory even if you

932
00:30:57,840 --> 00:30:59,760
want to do it but let's say

933
00:30:59,760 --> 00:31:02,960
small in in some sense of small yes but

934
00:31:02,960 --> 00:31:04,640
more costly than for example in a call

935
00:31:04,640 --> 00:31:06,080
to aes

936
00:31:06,080 --> 00:31:07,519
interesting how much memory just for

937
00:31:07,519 --> 00:31:10,159
curiosity

938
00:31:10,399 --> 00:31:12,240
how much memory

939
00:31:12,240 --> 00:31:13,519
i don't know

940
00:31:13,519 --> 00:31:16,480
i'd have to take a look at it

941
00:31:17,120 --> 00:31:18,640
mike mike petula from west point hi

942
00:31:18,640 --> 00:31:19,840
peter um

943
00:31:19,840 --> 00:31:21,840
two related questions uh have you talked

944
00:31:21,840 --> 00:31:23,840
to any other tls implementations other

945
00:31:23,840 --> 00:31:25,440
than boring ssl and then are we going to

946
00:31:25,440 --> 00:31:28,320
see this in salt as well

947
00:31:28,320 --> 00:31:32,480
um we had a bit of an exchange with um

948
00:31:32,480 --> 00:31:33,360
the

949
00:31:33,360 --> 00:31:35,919
people who did the bcns implementation

950
00:31:35,919 --> 00:31:37,919
and we also discussed whether we should

951
00:31:37,919 --> 00:31:40,559
integrate it in openssl now i myself

952
00:31:40,559 --> 00:31:42,320
have very little experience with writing

953
00:31:42,320 --> 00:31:44,000
code for open there's some code that i

954
00:31:44,000 --> 00:31:45,360
wrote in openssl but other people

955
00:31:45,360 --> 00:31:46,480
integrated it

956
00:31:46,480 --> 00:31:48,480
and i looked at the at the integration

957
00:31:48,480 --> 00:31:51,200
openssl i found a large cascade of if

958
00:31:51,200 --> 00:31:52,880
devs where i realized that it's very

959
00:31:52,880 --> 00:31:54,880
easy to screw this up and i decided that

960
00:31:54,880 --> 00:31:56,240
if we're doing this i'm interested in

961
00:31:56,240 --> 00:31:57,519
helping with this

962
00:31:57,519 --> 00:31:59,279
but i'd really rather have someone who's

963
00:31:59,279 --> 00:32:01,360
really familiar with openssl

964
00:32:01,360 --> 00:32:04,320
will we see this in salt

965
00:32:04,320 --> 00:32:06,000
i think currently our priorities for

966
00:32:06,000 --> 00:32:08,240
salt are others

967
00:32:08,240 --> 00:32:10,399
i think maybe at some point when salt

968
00:32:10,399 --> 00:32:12,240
goes completely post quantum

969
00:32:12,240 --> 00:32:13,440
i would hope that there's something

970
00:32:13,440 --> 00:32:14,960
better than that but it's not entirely

971
00:32:14,960 --> 00:32:17,919
impossible the is the post quantum uh

972
00:32:17,919 --> 00:32:19,440
some time away

973
00:32:19,440 --> 00:32:22,960
do you think or maybe post questions

974
00:32:22,960 --> 00:32:25,519
um i don't see this happening this year

975
00:32:25,519 --> 00:32:27,679
okay i'm not going to hold you to it

976
00:32:27,679 --> 00:32:30,720
okay thanks peter

977
00:32:30,720 --> 00:32:32,880
uh kenny patterson from royal holloway

978
00:32:32,880 --> 00:32:34,880
um i got a bit confused about some of

979
00:32:34,880 --> 00:32:36,799
your security analysis so could you put

980
00:32:36,799 --> 00:32:39,200
slide 10 up for me

981
00:32:39,200 --> 00:32:40,320
thanks

982
00:32:40,320 --> 00:32:41,120
uh

983
00:32:41,120 --> 00:32:42,880
i think it was like 10.

984
00:32:42,880 --> 00:32:44,480
yeah okay so

985
00:32:44,480 --> 00:32:46,799
um i guess the first question is

986
00:32:46,799 --> 00:32:48,159
and you didn't explicitly mention this

987
00:32:48,159 --> 00:32:49,840
but i assume it's true do you have a

988
00:32:49,840 --> 00:32:51,519
security proof that reduces to the

989
00:32:51,519 --> 00:32:53,840
hardness of our of ring lwe for you

990
00:32:53,840 --> 00:32:55,039
there is a security proof in the

991
00:32:55,039 --> 00:32:58,399
original um in the original paper by a

992
00:32:58,399 --> 00:33:00,720
pie code yeah and does that proof carry

993
00:33:00,720 --> 00:33:03,760
over to your slightly different protocol

994
00:33:03,760 --> 00:33:04,799
um

995
00:33:04,799 --> 00:33:06,960
there is so we don't have this

996
00:33:06,960 --> 00:33:08,640
average case to worst case reductions

997
00:33:08,640 --> 00:33:12,000
with the parameters that we choose

998
00:33:12,000 --> 00:33:14,799
we do show that if we don't use gaussian

999
00:33:14,799 --> 00:33:17,519
noise that the advantage of an attacker

1000
00:33:17,519 --> 00:33:18,559
is

1001
00:33:18,559 --> 00:33:20,480
small so you can say if there is an

1002
00:33:20,480 --> 00:33:22,880
algorithm distinguishing

1003
00:33:22,880 --> 00:33:24,320
with gaussian noise then the same

1004
00:33:24,320 --> 00:33:25,600
algorithm has a so with a certain

1005
00:33:25,600 --> 00:33:27,039
probability then with a certain slightly

1006
00:33:27,039 --> 00:33:28,000
lower probability you can also

1007
00:33:28,000 --> 00:33:30,159
distinguish uh with with this noise

1008
00:33:30,159 --> 00:33:31,600
because the binomial distribution is

1009
00:33:31,600 --> 00:33:33,120
close to the gaussian distribution yes

1010
00:33:33,120 --> 00:33:34,720
right but that's not the same as a

1011
00:33:34,720 --> 00:33:36,240
structure you shouldn't be using this in

1012
00:33:36,240 --> 00:33:37,679
signatures though

1013
00:33:37,679 --> 00:33:39,360
so in signatures this is a completely

1014
00:33:39,360 --> 00:33:41,760
different situation so this is something

1015
00:33:41,760 --> 00:33:45,200
um which actually even if you use it um

1016
00:33:45,200 --> 00:33:46,480
for

1017
00:33:46,480 --> 00:33:48,799
if you did a cca transformation of this

1018
00:33:48,799 --> 00:33:50,960
to to reuse keys at some point and have

1019
00:33:50,960 --> 00:33:52,559
long-term keys it's not entirely clear

1020
00:33:52,559 --> 00:33:54,000
to me what happened so this is something

1021
00:33:54,000 --> 00:33:55,760
only for purely ephemeral for the purely

1022
00:33:55,760 --> 00:33:56,960
ephemeral situations at least i won't

1023
00:33:56,960 --> 00:33:58,640
make any statements beyond that so let's

1024
00:33:58,640 --> 00:34:00,399
suppose that we assume that that proof

1025
00:34:00,399 --> 00:34:01,519
carries over

1026
00:34:01,519 --> 00:34:03,679
let's be optimistic

1027
00:34:03,679 --> 00:34:05,120
you have this quite conservative

1028
00:34:05,120 --> 00:34:06,480
analysis here where you're saying well

1029
00:34:06,480 --> 00:34:08,639
let's just count the cost of one

1030
00:34:08,639 --> 00:34:11,040
svp oracle and call that the the

1031
00:34:11,040 --> 00:34:12,879
security of the scheme

1032
00:34:12,879 --> 00:34:14,879
but if you take into account the cost of

1033
00:34:14,879 --> 00:34:17,839
the reduction in the security proof then

1034
00:34:17,839 --> 00:34:19,359
maybe you go in a different direction

1035
00:34:19,359 --> 00:34:21,599
with your parameters completely so can

1036
00:34:21,599 --> 00:34:22,719
you just say a little bit more about

1037
00:34:22,719 --> 00:34:24,560
that for this audience and what what's

1038
00:34:24,560 --> 00:34:26,320
what's missing there okay so if you if

1039
00:34:26,320 --> 00:34:28,000
you look at the at the tightness of of

1040
00:34:28,000 --> 00:34:29,760
the reductions the parameters are not

1041
00:34:29,760 --> 00:34:31,918
chosen to take those into account what

1042
00:34:31,918 --> 00:34:35,119
we're looking at is the best algorithms

1043
00:34:35,119 --> 00:34:38,639
that we know to solve this problem

1044
00:34:38,639 --> 00:34:40,480
and not another problem that it's being

1045
00:34:40,480 --> 00:34:42,719
reduced to but just much smaller or

1046
00:34:42,719 --> 00:34:44,800
something like that um also something

1047
00:34:44,800 --> 00:34:46,800
that i should mention here we look at

1048
00:34:46,800 --> 00:34:49,119
this ring lwe instance as an lwe

1049
00:34:49,119 --> 00:34:50,719
instance right that was my next question

1050
00:34:50,719 --> 00:34:51,520
yeah

1051
00:34:51,520 --> 00:34:52,960
very good so you're implicitly assuming

1052
00:34:52,960 --> 00:34:53,679
that

1053
00:34:53,679 --> 00:34:56,159
ring lwe is just as hard as lw and i

1054
00:34:56,159 --> 00:34:57,520
would really want to see much much more

1055
00:34:57,520 --> 00:34:59,680
research on this so any phd student who

1056
00:34:59,680 --> 00:35:01,680
reads a really cool topic encrypt

1057
00:35:01,680 --> 00:35:03,839
asymmetric cryptanalysis i think this is

1058
00:35:03,839 --> 00:35:04,720
really

1059
00:35:04,720 --> 00:35:07,119
something extremely important to look at

1060
00:35:07,119 --> 00:35:09,760
because um this is not clear that this

1061
00:35:09,760 --> 00:35:11,200
actually holds at the moment there are

1062
00:35:11,200 --> 00:35:12,640
no better algorithm there's no algorithm

1063
00:35:12,640 --> 00:35:14,839
that would exploit the structure

1064
00:35:14,839 --> 00:35:17,680
but i would be extremely excited to see

1065
00:35:17,680 --> 00:35:19,040
such an algorithm okay because that

1066
00:35:19,040 --> 00:35:20,960
would really improve our understanding

1067
00:35:20,960 --> 00:35:22,560
so the chair isn't stopping me asking

1068
00:35:22,560 --> 00:35:24,000
questions yeah last time there's no one

1069
00:35:24,000 --> 00:35:26,800
behind me so you talked about the uh

1070
00:35:26,800 --> 00:35:28,320
the number of cycles you needed to run

1071
00:35:28,320 --> 00:35:29,839
the key exchange protocol you didn't

1072
00:35:29,839 --> 00:35:31,359
talk about the bandwidth consumption i

1073
00:35:31,359 --> 00:35:33,920
wonder why about the amount of bandwidth

1074
00:35:33,920 --> 00:35:35,280
that your protocol consumes when you

1075
00:35:35,280 --> 00:35:37,520
send messages on the network so um what

1076
00:35:37,520 --> 00:35:38,640
we're sending

1077
00:35:38,640 --> 00:35:40,800
is about two kilobytes in each each

1078
00:35:40,800 --> 00:35:43,119
direction okay that's improving by a bit

1079
00:35:43,119 --> 00:35:44,720
more than a factor of two compared to

1080
00:35:44,720 --> 00:35:46,000
bcns

1081
00:35:46,000 --> 00:35:47,359
and it's

1082
00:35:47,359 --> 00:35:48,960
way way worse than elliptic curve

1083
00:35:48,960 --> 00:35:50,480
department like ten times or something

1084
00:35:50,480 --> 00:35:52,640
but almost hundred times hundred times i

1085
00:35:52,640 --> 00:35:54,800
mean you get 32 bytes which way elliptic

1086
00:35:54,800 --> 00:35:59,200
enough cryptography okay so um yeah so

1087
00:35:59,200 --> 00:36:00,960
i think what we will have to live with

1088
00:36:00,960 --> 00:36:02,160
at least from everything i understand

1089
00:36:02,160 --> 00:36:03,440
right now in a post-quantum world as

1090
00:36:03,440 --> 00:36:05,200
things will become larger messages will

1091
00:36:05,200 --> 00:36:06,720
become larger okay

1092
00:36:06,720 --> 00:36:09,759
thank you very much thanks

1093
00:36:11,040 --> 00:36:13,680
uh hello jose fernandez up with uh

1094
00:36:13,680 --> 00:36:15,839
uh echo polytechnic

1095
00:36:15,839 --> 00:36:17,680
um

1096
00:36:17,680 --> 00:36:21,280
i'm um there are applications where um

1097
00:36:21,280 --> 00:36:22,240
uh

1098
00:36:22,240 --> 00:36:24,240
that where key exchange is not gonna cut

1099
00:36:24,240 --> 00:36:26,320
it but you're gonna need certificates or

1100
00:36:26,320 --> 00:36:28,640
you know some certificate based

1101
00:36:28,640 --> 00:36:30,000
public key

1102
00:36:30,000 --> 00:36:32,340
implementation so i'm wondering

1103
00:36:32,340 --> 00:36:34,079
[Music]

1104
00:36:34,079 --> 00:36:36,000
what is standing in the way of having of

1105
00:36:36,000 --> 00:36:37,920
using this as a certificate based public

1106
00:36:37,920 --> 00:36:39,599
key infrastructure is it just a

1107
00:36:39,599 --> 00:36:41,040
certificate size or is there something

1108
00:36:41,040 --> 00:36:42,640
else that i that you didn't talk care

1109
00:36:42,640 --> 00:36:44,400
about um so you mean using this was

1110
00:36:44,400 --> 00:36:46,160
long-term keys basically that have

1111
00:36:46,160 --> 00:36:47,680
signatures on them yeah

1112
00:36:47,680 --> 00:36:50,880
um the very basic idea is that

1113
00:36:50,880 --> 00:36:53,359
what an attacker can do if you so you

1114
00:36:53,359 --> 00:36:54,800
choose your long term key and i'm

1115
00:36:54,800 --> 00:36:56,640
communicating to you and i can choose

1116
00:36:56,640 --> 00:36:58,880
noise such that with relatively high

1117
00:36:58,880 --> 00:37:01,599
probability the key exchange fails

1118
00:37:01,599 --> 00:37:03,760
and this probability depends on your key

1119
00:37:03,760 --> 00:37:05,680
now i keep just sending you messages and

1120
00:37:05,680 --> 00:37:07,280
play with the noise and then

1121
00:37:07,280 --> 00:37:09,440
keep learning about your key if i do

1122
00:37:09,440 --> 00:37:10,960
this plain thing

1123
00:37:10,960 --> 00:37:13,119
um now if we do this ephemeral then i

1124
00:37:13,119 --> 00:37:14,320
can learn something about your key by

1125
00:37:14,320 --> 00:37:15,599
doing this but also afterwards you throw

1126
00:37:15,599 --> 00:37:16,640
it away

1127
00:37:16,640 --> 00:37:18,400
the key exchange failed and it doesn't

1128
00:37:18,400 --> 00:37:19,920
matter at all

1129
00:37:19,920 --> 00:37:22,160
but you can't reuse the keys for roughly

1130
00:37:22,160 --> 00:37:24,079
that reason um there are transformations

1131
00:37:24,079 --> 00:37:25,440
for this but this is

1132
00:37:25,440 --> 00:37:27,599
something beyond the paper that we that

1133
00:37:27,599 --> 00:37:30,000
we currently have okay so it's because

1134
00:37:30,000 --> 00:37:31,440
of the noise model and the fact that

1135
00:37:31,440 --> 00:37:33,760
it's not deterministic as in

1136
00:37:33,760 --> 00:37:36,400
standard pki uh it is really because

1137
00:37:36,400 --> 00:37:38,400
this has only a chosen plain text

1138
00:37:38,400 --> 00:37:40,400
security and no chosen cipher text

1139
00:37:40,400 --> 00:37:42,480
security

1140
00:37:42,480 --> 00:37:44,400
so let me take one last question so the

1141
00:37:44,400 --> 00:37:46,000
failure probability you you settled on

1142
00:37:46,000 --> 00:37:48,320
was 2 to the negative negative 60. which

1143
00:37:48,320 --> 00:37:50,800
still strikes me as a extremely low

1144
00:37:50,800 --> 00:37:52,400
failure probability

1145
00:37:52,400 --> 00:37:54,480
um because the consequences of a failure

1146
00:37:54,480 --> 00:37:56,960
are just try it again right there's no

1147
00:37:56,960 --> 00:37:59,760
security loss there's no big harm so if

1148
00:37:59,760 --> 00:38:02,160
you set it to say two to negative eight

1149
00:38:02,160 --> 00:38:04,960
some ridiculously high failure rate

1150
00:38:04,960 --> 00:38:06,880
would there be benefits of doing that

1151
00:38:06,880 --> 00:38:09,280
given the cost of failure so though

1152
00:38:09,280 --> 00:38:10,640
um

1153
00:38:10,640 --> 00:38:12,400
you can so if you do this then the

1154
00:38:12,400 --> 00:38:13,520
obvious thing that you can do is you can

1155
00:38:13,520 --> 00:38:15,280
increase the noise and then you get even

1156
00:38:15,280 --> 00:38:16,640
more security

1157
00:38:16,640 --> 00:38:18,640
um now this is not necessarily something

1158
00:38:18,640 --> 00:38:20,320
that we're still aiming for at something

1159
00:38:20,320 --> 00:38:22,240
like 255 bits while at some point you

1160
00:38:22,240 --> 00:38:23,839
say it's enough

1161
00:38:23,839 --> 00:38:26,880
um what you can maybe do is you can make

1162
00:38:26,880 --> 00:38:28,960
the dimensions smaller and what the

1163
00:38:28,960 --> 00:38:31,440
paper has is we have an instantiation

1164
00:38:31,440 --> 00:38:33,599
with n equals 512

1165
00:38:33,599 --> 00:38:35,040
and we're aiming for the same error

1166
00:38:35,040 --> 00:38:38,160
probability a failure probability sorry

1167
00:38:38,160 --> 00:38:40,240
and we don't get 128 bits of

1168
00:38:40,240 --> 00:38:41,440
post-quantum security with this

1169
00:38:41,440 --> 00:38:42,960
conservative estimates

1170
00:38:42,960 --> 00:38:45,200
now we could have argued that

1171
00:38:45,200 --> 00:38:46,640
somewhat tighter analysis would still

1172
00:38:46,640 --> 00:38:47,839
give us

1173
00:38:47,839 --> 00:38:49,920
good security there and then we could

1174
00:38:49,920 --> 00:38:51,520
have maybe said that 2 to the minus 30

1175
00:38:51,520 --> 00:38:53,119
for example would still be okay and

1176
00:38:53,119 --> 00:38:54,880
increase the noise a bit and puzzle this

1177
00:38:54,880 --> 00:38:55,920
together

1178
00:38:55,920 --> 00:38:58,079
um for me the only reason to use this at

1179
00:38:58,079 --> 00:39:00,240
the moment is really long-term security

1180
00:39:00,240 --> 00:39:01,119
and

1181
00:39:01,119 --> 00:39:02,720
i'm expecting

1182
00:39:02,720 --> 00:39:05,359
some advances in encrypt analysis there

1183
00:39:05,359 --> 00:39:06,880
so i would really want to go for really

1184
00:39:06,880 --> 00:39:08,240
conservative parameters in particular

1185
00:39:08,240 --> 00:39:09,359
because

1186
00:39:09,359 --> 00:39:10,960
it feels like there's no reason to not

1187
00:39:10,960 --> 00:39:12,240
do it the only

1188
00:39:12,240 --> 00:39:15,040
message has become roughly half the size

1189
00:39:15,040 --> 00:39:17,359
but it somehow feels more comfortable

1190
00:39:17,359 --> 00:39:18,880
for long-term security to stay away from

1191
00:39:18,880 --> 00:39:20,000
that

1192
00:39:20,000 --> 00:39:21,599
thank you so let's thank our speaker

1193
00:39:21,599 --> 00:39:24,599
again

1194
00:39:25,610 --> 00:39:25,780
[Applause]

1195
00:39:25,780 --> 00:39:28,909
[Music]

1196
00:39:31,839 --> 00:39:33,920
you

