1
00:00:10,960 --> 00:00:12,480
all right uh

2
00:00:12,480 --> 00:00:14,400
so hi i'm david colbrunner and this is

3
00:00:14,400 --> 00:00:16,320
work with my advisor hobav shockum at

4
00:00:16,320 --> 00:00:18,560
ucsd and today i'm going to be talking

5
00:00:18,560 --> 00:00:20,720
to you about a different type of side

6
00:00:20,720 --> 00:00:21,840
channel we're going to be talking about

7
00:00:21,840 --> 00:00:24,720
timing side channels and browsers and

8
00:00:24,720 --> 00:00:26,320
kind of more specifically i'm going to

9
00:00:26,320 --> 00:00:28,720
be talking about building a browser that

10
00:00:28,720 --> 00:00:31,359
can provably mitigate timing attacks and

11
00:00:31,359 --> 00:00:33,920
mitigate is an important word there

12
00:00:33,920 --> 00:00:35,360
and to get to that i'm going to talk

13
00:00:35,360 --> 00:00:36,960
about several different things we're

14
00:00:36,960 --> 00:00:38,239
going to start with

15
00:00:38,239 --> 00:00:40,960
timing attacks kind of in the wild and

16
00:00:40,960 --> 00:00:42,879
some status of them in in the context

17
00:00:42,879 --> 00:00:44,800
that we care about for this uh and i'm

18
00:00:44,800 --> 00:00:46,480
going to talk about some mitigating

19
00:00:46,480 --> 00:00:49,280
techniques from the early 90s that came

20
00:00:49,280 --> 00:00:51,680
from the vax secure operating systems

21
00:00:51,680 --> 00:00:53,120
design community

22
00:00:53,120 --> 00:00:53,920
and then we're going to talk about how

23
00:00:53,920 --> 00:00:55,199
we can apply those techniques to

24
00:00:55,199 --> 00:00:57,120
browsers today

25
00:00:57,120 --> 00:00:58,239
so we're going to start with timing

26
00:00:58,239 --> 00:01:00,719
attacks relatively obviously

27
00:01:00,719 --> 00:01:02,640
and browsers are vulnerable to timing

28
00:01:02,640 --> 00:01:05,119
attacks browsers kind of innately have a

29
00:01:05,119 --> 00:01:07,040
bunch of different privileged domains

30
00:01:07,040 --> 00:01:09,040
and within those privileged domains they

31
00:01:09,040 --> 00:01:10,960
have different types of secrets they

32
00:01:10,960 --> 00:01:12,640
have user secrets which are things like

33
00:01:12,640 --> 00:01:14,560
passwords and browsing history or

34
00:01:14,560 --> 00:01:17,119
identity as we just saw they have system

35
00:01:17,119 --> 00:01:18,560
secrets which are things like file

36
00:01:18,560 --> 00:01:20,560
system information or the state of the

37
00:01:20,560 --> 00:01:22,640
cache and they have origin secrets which

38
00:01:22,640 --> 00:01:24,400
are private pieces of information to one

39
00:01:24,400 --> 00:01:25,840
origin that should not be given to

40
00:01:25,840 --> 00:01:26,960
another

41
00:01:26,960 --> 00:01:29,920
and browsers also expose a detailed uh

42
00:01:29,920 --> 00:01:31,759
kind of interface to information about

43
00:01:31,759 --> 00:01:34,320
their execution to javascript and they

44
00:01:34,320 --> 00:01:36,960
give a access to a high precision uh

45
00:01:36,960 --> 00:01:39,439
timer performance.now and they also give

46
00:01:39,439 --> 00:01:41,840
things like the get animation frame api

47
00:01:41,840 --> 00:01:43,119
which in combination with timing

48
00:01:43,119 --> 00:01:45,600
information allows a page to determine

49
00:01:45,600 --> 00:01:48,799
uh how long a frame took to render

50
00:01:48,799 --> 00:01:50,399
and since browsers compute and

51
00:01:50,399 --> 00:01:51,840
communicate between these different

52
00:01:51,840 --> 00:01:53,439
privilege levels and expose all this

53
00:01:53,439 --> 00:01:55,759
information that kind of end up being

54
00:01:55,759 --> 00:01:57,360
innately vulnerable to a variety of

55
00:01:57,360 --> 00:01:59,040
timing attacks and we've seen this

56
00:01:59,040 --> 00:02:00,320
historically

57
00:02:00,320 --> 00:02:02,479
there's been a series of svg filter

58
00:02:02,479 --> 00:02:04,799
timing attacks wherein one origin can

59
00:02:04,799 --> 00:02:06,880
learn pixel information about another

60
00:02:06,880 --> 00:02:08,878
origin and then use that pixel

61
00:02:08,878 --> 00:02:11,120
information to do something like run a

62
00:02:11,120 --> 00:02:13,680
optical character recognition algorithm

63
00:02:13,680 --> 00:02:15,440
additionally uh recently we've seen

64
00:02:15,440 --> 00:02:17,840
javascript cache timing attacks which

65
00:02:17,840 --> 00:02:19,520
have opened up kind of the entire space

66
00:02:19,520 --> 00:02:22,239
of cache timing to javascript that

67
00:02:22,239 --> 00:02:23,360
sounds like it's going to be a lot of

68
00:02:23,360 --> 00:02:24,480
fun

69
00:02:24,480 --> 00:02:26,800
unless excitingly we have things kind of

70
00:02:26,800 --> 00:02:28,319
continuously like fingerprinting

71
00:02:28,319 --> 00:02:30,879
de-anonymization and history sniffing

72
00:02:30,879 --> 00:02:32,319
attacks

73
00:02:32,319 --> 00:02:34,480
now browsers are aware obviously that

74
00:02:34,480 --> 00:02:35,519
they're getting hit with these different

75
00:02:35,519 --> 00:02:38,000
types of timing attacks and this is uh

76
00:02:38,000 --> 00:02:40,080
from the mozilla bug thread

77
00:02:40,080 --> 00:02:43,040
for paul stone's svg timing attack

78
00:02:43,040 --> 00:02:45,200
and the goal here that the the engineers

79
00:02:45,200 --> 00:02:47,200
decided on was implementing constant

80
00:02:47,200 --> 00:02:48,840
time code in c

81
00:02:48,840 --> 00:02:50,640
plus and if you've ever tried to

82
00:02:50,640 --> 00:02:52,959
implement cross-platform constant time

83
00:02:52,959 --> 00:02:54,800
code in c plus plus you will know that

84
00:02:54,800 --> 00:02:56,959
this is an absolute nightmare

85
00:02:56,959 --> 00:02:59,680
it does solve the problem but it's very

86
00:02:59,680 --> 00:03:01,040
difficult

87
00:03:01,040 --> 00:03:03,760
now a far more interesting approach was

88
00:03:03,760 --> 00:03:05,360
taken by

89
00:03:05,360 --> 00:03:08,080
both chrome and firefox in response to

90
00:03:08,080 --> 00:03:10,080
the cache timing attacks in the spine

91
00:03:10,080 --> 00:03:11,519
sandbox paper

92
00:03:11,519 --> 00:03:14,319
which was to round down

93
00:03:14,319 --> 00:03:16,720
the explicit clock in the system that's

94
00:03:16,720 --> 00:03:18,319
available to javascript specifically

95
00:03:18,319 --> 00:03:20,560
this performance.now high resolution

96
00:03:20,560 --> 00:03:22,720
timer and they rounded it down to five

97
00:03:22,720 --> 00:03:24,000
microseconds

98
00:03:24,000 --> 00:03:25,519
because they're trying to deal with a

99
00:03:25,519 --> 00:03:28,400
hardware attack in this particular case

100
00:03:28,400 --> 00:03:31,200
now this same approach was taken by tor

101
00:03:31,200 --> 00:03:33,519
browser tor browser has a different

102
00:03:33,519 --> 00:03:35,599
usability and privacy trade-off

103
00:03:35,599 --> 00:03:36,879
obviously

104
00:03:36,879 --> 00:03:39,360
and so they chose 100 milliseconds as

105
00:03:39,360 --> 00:03:40,720
the granularity that they wanted to

106
00:03:40,720 --> 00:03:42,400
round the clock down to and the idea

107
00:03:42,400 --> 00:03:43,599
here is they're trying to prevent a

108
00:03:43,599 --> 00:03:45,519
large class of timing attacks by

109
00:03:45,519 --> 00:03:47,680
removing the ability of the attacker to

110
00:03:47,680 --> 00:03:50,080
measure fine grain's time

111
00:03:50,080 --> 00:03:51,120
now i'm going to show you in just a

112
00:03:51,120 --> 00:03:52,400
second that unfortunately this doesn't

113
00:03:52,400 --> 00:03:54,400
work

114
00:03:54,400 --> 00:03:56,640
the attacker is able to gain fine grain

115
00:03:56,640 --> 00:03:58,400
timing information using the exact

116
00:03:58,400 --> 00:04:00,239
interface that i just showed you even

117
00:04:00,239 --> 00:04:02,080
though it's rounded down

118
00:04:02,080 --> 00:04:03,920
and so we're going to do that with using

119
00:04:03,920 --> 00:04:05,439
a couple different clocks

120
00:04:05,439 --> 00:04:07,200
so remember we're talking about in this

121
00:04:07,200 --> 00:04:09,280
particular context

122
00:04:09,280 --> 00:04:11,200
they're taking the floor right so we're

123
00:04:11,200 --> 00:04:12,560
rounding down which means whenever

124
00:04:12,560 --> 00:04:14,239
you're querying this clock you're going

125
00:04:14,239 --> 00:04:16,079
to query it until it close it crosses a

126
00:04:16,079 --> 00:04:18,079
100 millisecond threshold and then

127
00:04:18,079 --> 00:04:19,120
you're immediately going to see an

128
00:04:19,120 --> 00:04:20,079
update

129
00:04:20,079 --> 00:04:21,680
and the technique we do is here we call

130
00:04:21,680 --> 00:04:23,440
the clock edge technique this is not

131
00:04:23,440 --> 00:04:25,520
anything particularly novel but its

132
00:04:25,520 --> 00:04:28,160
application here is quite a bit of fun

133
00:04:28,160 --> 00:04:29,759
we're going to need two clocks to do

134
00:04:29,759 --> 00:04:31,440
this we're going to need what we call a

135
00:04:31,440 --> 00:04:33,199
major clock and a minor clock and this

136
00:04:33,199 --> 00:04:35,280
is a nomenclature from our paper the

137
00:04:35,280 --> 00:04:37,759
major clock contain is a clock that has

138
00:04:37,759 --> 00:04:40,479
some very regular known period so let's

139
00:04:40,479 --> 00:04:41,919
pretend it's something like our

140
00:04:41,919 --> 00:04:44,320
performance.now rounded down clock it's

141
00:04:44,320 --> 00:04:46,560
got a 100 millisecond period we then

142
00:04:46,560 --> 00:04:48,400
need what we call a minor clock the

143
00:04:48,400 --> 00:04:50,960
minor clock has some high

144
00:04:50,960 --> 00:04:52,960
rapid period but we don't necessarily

145
00:04:52,960 --> 00:04:55,759
know what it is additionally it's likely

146
00:04:55,759 --> 00:04:57,360
that running the minor clock will load

147
00:04:57,360 --> 00:04:59,840
the system and we can't kind of query it

148
00:04:59,840 --> 00:05:01,280
whenever we want so a good example here

149
00:05:01,280 --> 00:05:02,960
would be an incrementing for loop that

150
00:05:02,960 --> 00:05:05,600
we can just check the index on

151
00:05:05,600 --> 00:05:06,960
so the first thing we're going to do is

152
00:05:06,960 --> 00:05:08,800
determine how fast the minor clock is

153
00:05:08,800 --> 00:05:10,880
running by lining up on a major clock

154
00:05:10,880 --> 00:05:12,960
edge starting the minor clock running it

155
00:05:12,960 --> 00:05:14,960
till the next major clock edge we then

156
00:05:14,960 --> 00:05:16,800
count the number of minor clock edges we

157
00:05:16,800 --> 00:05:18,880
saw so let's pretend we saw eight

158
00:05:18,880 --> 00:05:20,639
and then when we want to time some

159
00:05:20,639 --> 00:05:23,039
target event we're going to again line

160
00:05:23,039 --> 00:05:24,880
up on the start of a major clock edge

161
00:05:24,880 --> 00:05:26,479
we're going to start the major we're

162
00:05:26,479 --> 00:05:28,400
going to start this target when the

163
00:05:28,400 --> 00:05:30,320
target completes we're going to start

164
00:05:30,320 --> 00:05:32,560
the minor clock and wait until the next

165
00:05:32,560 --> 00:05:34,080
major clock edge again

166
00:05:34,080 --> 00:05:36,160
and then if all we did was look at the

167
00:05:36,160 --> 00:05:38,400
major clock we would say we saw one edge

168
00:05:38,400 --> 00:05:40,960
so 100 milliseconds but by using the

169
00:05:40,960 --> 00:05:43,600
fact that we saw six minor edges we can

170
00:05:43,600 --> 00:05:45,199
say well we actually saw one and a

171
00:05:45,199 --> 00:05:47,520
quarter major clock edges during the

172
00:05:47,520 --> 00:05:50,479
target so it was 125 milliseconds

173
00:05:50,479 --> 00:05:52,400
and so we can improve the accuracy

174
00:05:52,400 --> 00:05:54,479
of some clock that the system gives us

175
00:05:54,479 --> 00:05:56,160
by using these kind of clever little

176
00:05:56,160 --> 00:05:57,199
tricks

177
00:05:57,199 --> 00:05:58,400
and i'm going to show you a bunch of

178
00:05:58,400 --> 00:06:00,000
graphs that look like this throughout

179
00:06:00,000 --> 00:06:01,039
the talk

180
00:06:01,039 --> 00:06:03,120
these graphs are all based on data that

181
00:06:03,120 --> 00:06:04,880
we gathered by designing test web pages

182
00:06:04,880 --> 00:06:06,000
and then putting them through various

183
00:06:06,000 --> 00:06:07,360
browsers

184
00:06:07,360 --> 00:06:10,479
the x-axis shows the duration of some

185
00:06:10,479 --> 00:06:12,160
target event that we were trying to

186
00:06:12,160 --> 00:06:14,080
measure

187
00:06:14,080 --> 00:06:14,720
in

188
00:06:14,720 --> 00:06:16,160
the exact duration essentially in

189
00:06:16,160 --> 00:06:19,600
milliseconds and the y-axis shows the

190
00:06:19,600 --> 00:06:21,680
measurement that the clock technique we

191
00:06:21,680 --> 00:06:24,160
are using gave us so a perfectly

192
00:06:24,160 --> 00:06:26,240
accurate clock whatever it is would go

193
00:06:26,240 --> 00:06:28,639
exactly along the x equals y axis along

194
00:06:28,639 --> 00:06:30,720
the gray dashed line and an inaccurate

195
00:06:30,720 --> 00:06:32,000
clock would be kind of spread all over

196
00:06:32,000 --> 00:06:32,880
the place

197
00:06:32,880 --> 00:06:35,120
so this is data for the 100 millisecond

198
00:06:35,120 --> 00:06:37,520
rounded down performance.now clock and

199
00:06:37,520 --> 00:06:39,360
we get the exact kind of step function

200
00:06:39,360 --> 00:06:40,800
we would expect to see at 100

201
00:06:40,800 --> 00:06:42,319
millisecond intervals because that's

202
00:06:42,319 --> 00:06:44,240
when the clock updates

203
00:06:44,240 --> 00:06:45,759
but by applying that fun little clock

204
00:06:45,759 --> 00:06:48,400
edge technique we get the blue x's

205
00:06:48,400 --> 00:06:50,639
which is notably more accurate than the

206
00:06:50,639 --> 00:06:51,520
uh

207
00:06:51,520 --> 00:06:53,120
the kind of the step function we saw and

208
00:06:53,120 --> 00:06:54,639
actually in our testing that hundred

209
00:06:54,639 --> 00:06:56,880
millisecond granularity clock was able

210
00:06:56,880 --> 00:06:59,440
to give measurements down to half or one

211
00:06:59,440 --> 00:07:00,639
millisecond

212
00:07:00,639 --> 00:07:02,080
which is a little bit finer grain than

213
00:07:02,080 --> 00:07:04,639
what was expected

214
00:07:04,639 --> 00:07:06,800
so a natural approach here of course

215
00:07:06,800 --> 00:07:08,240
might be let's just take away all of the

216
00:07:08,240 --> 00:07:10,000
clocks from javascript we'll remove

217
00:07:10,000 --> 00:07:11,680
their performance.now we'll take away

218
00:07:11,680 --> 00:07:13,280
date and time they won't be able to know

219
00:07:13,280 --> 00:07:14,800
anything right

220
00:07:14,800 --> 00:07:16,000
unfortunately browsers have a lot of

221
00:07:16,000 --> 00:07:17,599
features and it turns out that a lot of

222
00:07:17,599 --> 00:07:18,960
those features can be used to make

223
00:07:18,960 --> 00:07:21,680
implicit clocks in the system

224
00:07:21,680 --> 00:07:24,800
so uh we used things like video frame

225
00:07:24,800 --> 00:07:26,960
data so what frame of the video you're

226
00:07:26,960 --> 00:07:27,759
on

227
00:07:27,759 --> 00:07:30,720
the web speech interface um css

228
00:07:30,720 --> 00:07:33,840
animations uh kind of dripping data with

229
00:07:33,840 --> 00:07:35,680
a cooperating server to construct a

230
00:07:35,680 --> 00:07:37,039
whole series of additional clock

231
00:07:37,039 --> 00:07:39,520
mechanisms and we talk about a kind of a

232
00:07:39,520 --> 00:07:41,120
taxonomy for these clocks and look at

233
00:07:41,120 --> 00:07:42,479
them in different browsers in the paper

234
00:07:42,479 --> 00:07:44,639
and you should take a look at that

235
00:07:44,639 --> 00:07:46,400
the thing about this list is these are

236
00:07:46,400 --> 00:07:48,000
the ones that i bothered to write tests

237
00:07:48,000 --> 00:07:48,800
for

238
00:07:48,800 --> 00:07:50,319
there's a million more of these you just

239
00:07:50,319 --> 00:07:52,800
kind of open up the dom apis folder in

240
00:07:52,800 --> 00:07:54,800
firefox and every file in there is an

241
00:07:54,800 --> 00:07:56,800
implicit clock as far as i can tell if

242
00:07:56,800 --> 00:07:58,560
you've heard for example of web speech

243
00:07:58,560 --> 00:08:00,240
web speech would make a great clock i

244
00:08:00,240 --> 00:08:02,479
was just too lazy to write a test

245
00:08:02,479 --> 00:08:03,360
but we're going to talk about one in

246
00:08:03,360 --> 00:08:05,680
detail very quickly which is webvtt uh

247
00:08:05,680 --> 00:08:07,840
webvtt was one of my favorites

248
00:08:07,840 --> 00:08:12,720
webvtt is subtitling for video elements

249
00:08:12,720 --> 00:08:16,319
html5 video elements you specify a vtt

250
00:08:16,319 --> 00:08:18,160
file that looks something like this you

251
00:08:18,160 --> 00:08:19,360
can have

252
00:08:19,360 --> 00:08:21,440
subtitles specified up to millisecond

253
00:08:21,440 --> 00:08:23,440
granularity so we just specify a whole

254
00:08:23,440 --> 00:08:25,120
bunch of subtitles that look like this

255
00:08:25,120 --> 00:08:27,120
and then javascript can query

256
00:08:27,120 --> 00:08:29,039
what subtitles are currently displayed

257
00:08:29,039 --> 00:08:32,559
and so we can use this as a clock right

258
00:08:32,559 --> 00:08:33,679
it works

259
00:08:33,679 --> 00:08:35,760
you get this out the other end

260
00:08:35,760 --> 00:08:37,039
you will notice this is not one

261
00:08:37,039 --> 00:08:39,279
millisecond of granularity of step

262
00:08:39,279 --> 00:08:40,799
function it's like 30 something

263
00:08:40,799 --> 00:08:43,760
milliseconds and that's because uh of

264
00:08:43,760 --> 00:08:45,360
how the video gets rendered and how the

265
00:08:45,360 --> 00:08:46,880
subtitling system decides to update

266
00:08:46,880 --> 00:08:48,240
subtitles it's a bunch of kind of

267
00:08:48,240 --> 00:08:50,480
engineering and implementation details

268
00:08:50,480 --> 00:08:51,920
but this is where it starts to get fun

269
00:08:51,920 --> 00:08:53,440
again because we can apply that clock

270
00:08:53,440 --> 00:08:55,040
edge technique to it

271
00:08:55,040 --> 00:08:57,040
and we can make it a bunch more accurate

272
00:08:57,040 --> 00:08:58,399
and you can do this actually for all of

273
00:08:58,399 --> 00:08:59,839
the implicit clocks that we found in the

274
00:08:59,839 --> 00:09:01,839
system now you might need a different

275
00:09:01,839 --> 00:09:03,120
minor clock and you might need to use

276
00:09:03,120 --> 00:09:04,160
the technique a little bit differently

277
00:09:04,160 --> 00:09:05,519
but it works

278
00:09:05,519 --> 00:09:07,519
and you kind of get this same we have a

279
00:09:07,519 --> 00:09:09,279
step function and then we can improve it

280
00:09:09,279 --> 00:09:12,160
by using this trick

281
00:09:12,399 --> 00:09:13,920
so

282
00:09:13,920 --> 00:09:16,399
we want to remove this capability and

283
00:09:16,399 --> 00:09:18,320
browsers are already trying to degrade

284
00:09:18,320 --> 00:09:20,240
clocks as we saw they're rounding them

285
00:09:20,240 --> 00:09:21,279
down

286
00:09:21,279 --> 00:09:23,120
but we want to do this right and so the

287
00:09:23,120 --> 00:09:25,279
answer is we need to degrade all of the

288
00:09:25,279 --> 00:09:27,279
clocks available to the attacker and

289
00:09:27,279 --> 00:09:29,279
that means all the explicit clocks which

290
00:09:29,279 --> 00:09:30,560
they're currently doing but it's not

291
00:09:30,560 --> 00:09:32,160
working and we need to do all the

292
00:09:32,160 --> 00:09:33,760
implicit clocks which are the type of

293
00:09:33,760 --> 00:09:35,440
the type that i just showed you

294
00:09:35,440 --> 00:09:37,120
and thankfully there is this fantastic

295
00:09:37,120 --> 00:09:38,959
body of work that we can draw on from

296
00:09:38,959 --> 00:09:41,920
like 91 it was first presented by who at

297
00:09:41,920 --> 00:09:44,320
oakland in 91 called fuzzy time and now

298
00:09:44,320 --> 00:09:46,320
fuzzy time was a system for the vax

299
00:09:46,320 --> 00:09:47,920
secure kernel

300
00:09:47,920 --> 00:09:50,160
that was designed to mitigate timing

301
00:09:50,160 --> 00:09:52,480
covert channels by

302
00:09:52,480 --> 00:09:55,040
putting a cap on the bandwidth available

303
00:09:55,040 --> 00:09:56,720
to any covert channel in the system

304
00:09:56,720 --> 00:09:58,399
regardless of what it was

305
00:09:58,399 --> 00:09:59,920
and when i say covert channels here i'm

306
00:09:59,920 --> 00:10:01,760
going to be kind of thinking in terms of

307
00:10:01,760 --> 00:10:04,000
the nomenclature from from john ray

308
00:10:04,000 --> 00:10:05,760
which is that a covert channel consists

309
00:10:05,760 --> 00:10:07,600
of two clocks one of which is a

310
00:10:07,600 --> 00:10:10,160
modulated clock one of which is a

311
00:10:10,160 --> 00:10:12,640
a reference clock the modulated clock is

312
00:10:12,640 --> 00:10:14,160
what we think of as the channel the high

313
00:10:14,160 --> 00:10:16,240
privilege process is modulating in some

314
00:10:16,240 --> 00:10:18,000
way and you need a reference clock as

315
00:10:18,000 --> 00:10:19,360
well because you need to be able to

316
00:10:19,360 --> 00:10:22,720
figure out what the modulation was

317
00:10:22,720 --> 00:10:25,839
now the the vax security kernel is not a

318
00:10:25,839 --> 00:10:28,560
web browser obviously they didn't really

319
00:10:28,560 --> 00:10:31,200
have a web browser for it um

320
00:10:31,200 --> 00:10:32,480
they were running in a situation where

321
00:10:32,480 --> 00:10:34,720
they had a bunch of vax vms each vm was

322
00:10:34,720 --> 00:10:36,560
single threaded each one was kind of its

323
00:10:36,560 --> 00:10:38,240
own privilege domain they had this

324
00:10:38,240 --> 00:10:39,839
beautiful clean interface between the

325
00:10:39,839 --> 00:10:42,399
trusted computing base and the vm and

326
00:10:42,399 --> 00:10:43,760
this made a lot of the decisions

327
00:10:43,760 --> 00:10:45,279
relatively easy

328
00:10:45,279 --> 00:10:46,399
to

329
00:10:46,399 --> 00:10:48,000
actually build

330
00:10:48,000 --> 00:10:49,920
now the problem they had was that they

331
00:10:49,920 --> 00:10:53,279
had covert channels via shared buses

332
00:10:53,279 --> 00:10:54,959
in their system and this could be

333
00:10:54,959 --> 00:10:57,920
anything from the disk scheduling

334
00:10:57,920 --> 00:10:59,760
to kind of any other piece of hardware

335
00:10:59,760 --> 00:11:00,880
in there and they didn't really have a

336
00:11:00,880 --> 00:11:02,399
good way to remove these channels

337
00:11:02,399 --> 00:11:03,519
because they were kind of innate to the

338
00:11:03,519 --> 00:11:05,440
hardware

339
00:11:05,440 --> 00:11:07,279
so the solution they proposed was to

340
00:11:07,279 --> 00:11:09,120
reduce the accuracy and precision of

341
00:11:09,120 --> 00:11:11,680
system clocks this should sound familiar

342
00:11:11,680 --> 00:11:14,160
and randomly alter the timings of i o

343
00:11:14,160 --> 00:11:16,079
operations

344
00:11:16,079 --> 00:11:17,279
and this does

345
00:11:17,279 --> 00:11:18,800
several things but first we're going to

346
00:11:18,800 --> 00:11:20,079
talk about how it handles explicit

347
00:11:20,079 --> 00:11:21,200
clocks

348
00:11:21,200 --> 00:11:23,040
what they do is they take the the timing

349
00:11:23,040 --> 00:11:24,560
interrupts that are going to the vm that

350
00:11:24,560 --> 00:11:26,399
need to arrive at regular intervals and

351
00:11:26,399 --> 00:11:28,079
they just deliver them randomly a little

352
00:11:28,079 --> 00:11:29,839
bit late

353
00:11:29,839 --> 00:11:31,760
and what this actually does is this lies

354
00:11:31,760 --> 00:11:34,800
about when the clock edge happens so if

355
00:11:34,800 --> 00:11:36,160
you were to try and apply a technique

356
00:11:36,160 --> 00:11:37,920
like we talked about earlier you

357
00:11:37,920 --> 00:11:39,680
couldn't do that because this edge will

358
00:11:39,680 --> 00:11:40,640
occur

359
00:11:40,640 --> 00:11:42,640
somewhere in that red region and we're

360
00:11:42,640 --> 00:11:44,320
not exactly sure where and so the

361
00:11:44,320 --> 00:11:45,920
attacker isn't able to kind of get this

362
00:11:45,920 --> 00:11:48,240
fine-grained hard edge

363
00:11:48,240 --> 00:11:49,839
and for implicit clocks what they're

364
00:11:49,839 --> 00:11:51,680
doing is they're taking all of the i o

365
00:11:51,680 --> 00:11:53,360
operations and they're putting them into

366
00:11:53,360 --> 00:11:55,519
queues and these cues are being emptied

367
00:11:55,519 --> 00:11:58,560
kind of randomly uh and so the attacker

368
00:11:58,560 --> 00:12:01,519
isn't able to put things together

369
00:12:01,519 --> 00:12:02,639
and this actually gives a bunch of

370
00:12:02,639 --> 00:12:04,880
really really nice guarantees um we're

371
00:12:04,880 --> 00:12:06,639
degrading all of the clocks and because

372
00:12:06,639 --> 00:12:09,040
all the clocks are degraded both the the

373
00:12:09,040 --> 00:12:10,560
kind of the modulated and the reference

374
00:12:10,560 --> 00:12:11,600
clock

375
00:12:11,600 --> 00:12:13,519
and they choose some time granularity g

376
00:12:13,519 --> 00:12:14,800
that they're also rounding the entire

377
00:12:14,800 --> 00:12:16,720
system down to you're able to say

378
00:12:16,720 --> 00:12:18,720
something about the the maximum possible

379
00:12:18,720 --> 00:12:20,399
channel bandwidth and it turns out that

380
00:12:20,399 --> 00:12:22,639
the minimum the maximum granularity or

381
00:12:22,639 --> 00:12:23,920
i'm sorry the minimum granularity the

382
00:12:23,920 --> 00:12:25,600
attacker can measure is usually

383
00:12:25,600 --> 00:12:27,760
something like the g over two of the

384
00:12:27,760 --> 00:12:30,079
time granularity

385
00:12:30,079 --> 00:12:31,519
and this is pretty this is going to be

386
00:12:31,519 --> 00:12:32,480
pretty nice because we're going to use

387
00:12:32,480 --> 00:12:34,160
this in a second i'm going to quickly

388
00:12:34,160 --> 00:12:35,839
mention their their i o cueing here or

389
00:12:35,839 --> 00:12:37,440
give a brief overview of it so it makes

390
00:12:37,440 --> 00:12:39,120
a little bit sense when i talk about web

391
00:12:39,120 --> 00:12:42,240
browsers um so if we have a shared bus

392
00:12:42,240 --> 00:12:43,839
situation that they're talking about we

393
00:12:43,839 --> 00:12:45,680
have some device that has a bunch of

394
00:12:45,680 --> 00:12:47,120
currently cued events we can pretend

395
00:12:47,120 --> 00:12:49,440
it's a disc that has a bunch of seeks

396
00:12:49,440 --> 00:12:51,680
and when new events arrive from a vm it

397
00:12:51,680 --> 00:12:53,680
makes a request for a read rather than

398
00:12:53,680 --> 00:12:55,519
give it to the disk we put it into some

399
00:12:55,519 --> 00:12:57,120
next queue that we're going to to

400
00:12:57,120 --> 00:12:59,360
eventually empty

401
00:12:59,360 --> 00:13:01,760
and at some and as events complete we're

402
00:13:01,760 --> 00:13:03,519
going to put them into a response queue

403
00:13:03,519 --> 00:13:06,160
rather than give them directly to the vm

404
00:13:06,160 --> 00:13:07,680
and so at some point we're going to end

405
00:13:07,680 --> 00:13:09,600
up with this we're going to randomly

406
00:13:09,600 --> 00:13:12,000
empty empty the next queue at kind of uh

407
00:13:12,000 --> 00:13:14,399
within some interval of time and this

408
00:13:14,399 --> 00:13:17,760
divorces when the vm made a request from

409
00:13:17,760 --> 00:13:18,560
when the

410
00:13:18,560 --> 00:13:20,480
request gets scheduled

411
00:13:20,480 --> 00:13:22,160
and then at some point in the future

412
00:13:22,160 --> 00:13:23,839
we're going to randomly empty the

413
00:13:23,839 --> 00:13:26,320
response queue and this divorces the

414
00:13:26,320 --> 00:13:29,440
completion of the event from when the vm

415
00:13:29,440 --> 00:13:31,120
receives it now obviously they're still

416
00:13:31,120 --> 00:13:32,639
receiving events we haven't completely

417
00:13:32,639 --> 00:13:34,079
stopped time so they're learning

418
00:13:34,079 --> 00:13:36,399
something but it's at a known max known

419
00:13:36,399 --> 00:13:39,120
granularity

420
00:13:39,760 --> 00:13:41,279
but this is for the vax

421
00:13:41,279 --> 00:13:42,800
obviously we're not talking about it

422
00:13:42,800 --> 00:13:44,320
back we're talking about a web browser

423
00:13:44,320 --> 00:13:47,040
so uh in our paper we present fermata

424
00:13:47,040 --> 00:13:49,040
formatta is an adaptation of the fuzzy

425
00:13:49,040 --> 00:13:51,440
time model to web browsers

426
00:13:51,440 --> 00:13:53,839
now why did we why did we choose this

427
00:13:53,839 --> 00:13:56,160
we wanted to degrade clocks

428
00:13:56,160 --> 00:13:57,120
because

429
00:13:57,120 --> 00:13:58,639
that's what we were seeing web browsers

430
00:13:58,639 --> 00:14:00,320
try and do but we wanted to do it in a

431
00:14:00,320 --> 00:14:02,560
way that was verifiable and would give

432
00:14:02,560 --> 00:14:04,320
us guarantees that we could write down

433
00:14:04,320 --> 00:14:05,440
and prove

434
00:14:05,440 --> 00:14:06,720
it also turns out that browsers are

435
00:14:06,720 --> 00:14:08,320
shockingly well suited to this because

436
00:14:08,320 --> 00:14:09,760
for the most part they're single

437
00:14:09,760 --> 00:14:11,760
threaded they have one big main event

438
00:14:11,760 --> 00:14:13,120
queue

439
00:14:13,120 --> 00:14:14,839
and that only runs on one

440
00:14:14,839 --> 00:14:17,440
thread so this shouldn't be too bad was

441
00:14:17,440 --> 00:14:18,880
our was our observation we should be

442
00:14:18,880 --> 00:14:20,000
able to take this right we just like

443
00:14:20,000 --> 00:14:21,600
bolt a javascript engine into it we

444
00:14:21,600 --> 00:14:22,800
stick it into a browser and it's going

445
00:14:22,800 --> 00:14:24,480
to work

446
00:14:24,480 --> 00:14:26,160
we'll take all of the i o operations all

447
00:14:26,160 --> 00:14:28,639
of our http our local storage we'll put

448
00:14:28,639 --> 00:14:31,120
it into cues we'll randomly empty them

449
00:14:31,120 --> 00:14:32,560
we'll take all the explicit clocks in

450
00:14:32,560 --> 00:14:34,320
the system we'll make them fuzzy in kind

451
00:14:34,320 --> 00:14:37,360
of this verifiable way uh that turns out

452
00:14:37,360 --> 00:14:38,959
for example in firefox to not be too

453
00:14:38,959 --> 00:14:40,399
difficult because there's really two

454
00:14:40,399 --> 00:14:42,320
underlying sources of time that firefox

455
00:14:42,320 --> 00:14:43,440
uses

456
00:14:43,440 --> 00:14:45,120
we'd like to prove that everything falls

457
00:14:45,120 --> 00:14:46,880
into this fuzzy time defense which might

458
00:14:46,880 --> 00:14:49,360
require us to build a whole new browser

459
00:14:49,360 --> 00:14:51,680
um but more scarily we would have to

460
00:14:51,680 --> 00:14:53,199
change all dom accesses to be

461
00:14:53,199 --> 00:14:55,040
asynchronous now we believe that this is

462
00:14:55,040 --> 00:14:56,800
a solvable problem but it's a pretty

463
00:14:56,800 --> 00:14:58,160
tricky engineering solution and you

464
00:14:58,160 --> 00:14:59,839
should look at our paper to kind of see

465
00:14:59,839 --> 00:15:02,160
where we're thinking to go with this

466
00:15:02,160 --> 00:15:03,920
now as i said these these two parts

467
00:15:03,920 --> 00:15:06,880
don't look super hard um but then you

468
00:15:06,880 --> 00:15:09,519
try and build them which we did in fuzzy

469
00:15:09,519 --> 00:15:11,519
fox fuzzy fox is an engineering

470
00:15:11,519 --> 00:15:13,360
prototype that we built on top of

471
00:15:13,360 --> 00:15:16,639
firefox um we did this because we didn't

472
00:15:16,639 --> 00:15:18,480
know what parts of fermata were going to

473
00:15:18,480 --> 00:15:21,360
work we didn't know whether if we kind

474
00:15:21,360 --> 00:15:23,199
of mess with the way the queuing works

475
00:15:23,199 --> 00:15:24,639
in the system we delay all of these

476
00:15:24,639 --> 00:15:26,320
events we mess with the time whether you

477
00:15:26,320 --> 00:15:28,480
could browse websites like our browser

478
00:15:28,480 --> 00:15:30,560
is going to just fall over if we do this

479
00:15:30,560 --> 00:15:32,000
and and kind of more critically we also

480
00:15:32,000 --> 00:15:33,759
wanted to be able to figure out what are

481
00:15:33,759 --> 00:15:35,920
these mitigations and strategies could

482
00:15:35,920 --> 00:15:38,160
we push to browsers today for example

483
00:15:38,160 --> 00:15:40,399
that explicit clock fuzzing

484
00:15:40,399 --> 00:15:42,560
and just put that out there now

485
00:15:42,560 --> 00:15:44,880
um so fuzzy fox is as its name would

486
00:15:44,880 --> 00:15:47,279
imply a patch set on top of mozilla

487
00:15:47,279 --> 00:15:49,519
firefox we tested a bunch of different

488
00:15:49,519 --> 00:15:51,199
time granularities which have different

489
00:15:51,199 --> 00:15:53,279
performance costs from half a

490
00:15:53,279 --> 00:15:56,000
millisecond up to 100 and even 500

491
00:15:56,000 --> 00:15:58,320
although that's completely unusable

492
00:15:58,320 --> 00:16:00,800
and it fully fuzzes the explicit time

493
00:16:00,800 --> 00:16:02,880
sources in firefox

494
00:16:02,880 --> 00:16:05,120
um it breaks the main thread into these

495
00:16:05,120 --> 00:16:08,399
implicit cues and we delay all going out

496
00:16:08,399 --> 00:16:10,480
http start now that's a that's a much

497
00:16:10,480 --> 00:16:13,120
shorter list than all i o operations and

498
00:16:13,120 --> 00:16:14,720
that's because fuzzyfox is designed to

499
00:16:14,720 --> 00:16:16,240
test whether or not these ideas can

500
00:16:16,240 --> 00:16:18,560
function uh and not be and it's not

501
00:16:18,560 --> 00:16:20,079
designed to be a provable system like

502
00:16:20,079 --> 00:16:22,160
ramada is

503
00:16:22,160 --> 00:16:23,759
so i'm going to talk about how how we

504
00:16:23,759 --> 00:16:25,839
did the main thread queuing briefly here

505
00:16:25,839 --> 00:16:27,839
um because it has some implications for

506
00:16:27,839 --> 00:16:29,920
how the system it functions what we

507
00:16:29,920 --> 00:16:31,120
would like

508
00:16:31,120 --> 00:16:34,480
is to break the main firefox event queue

509
00:16:34,480 --> 00:16:36,560
into kind of an infinite series of

510
00:16:36,560 --> 00:16:38,880
multiple queues where there's some queue

511
00:16:38,880 --> 00:16:40,639
that we're currently executing on that

512
00:16:40,639 --> 00:16:42,160
has events we've finished has some we

513
00:16:42,160 --> 00:16:43,519
need to do one that we're doing right

514
00:16:43,519 --> 00:16:45,839
now and then anytime a new event would

515
00:16:45,839 --> 00:16:48,800
show up it would go into the next queue

516
00:16:48,800 --> 00:16:50,240
and then at some point in the future we

517
00:16:50,240 --> 00:16:52,399
would randomly empty the next queue into

518
00:16:52,399 --> 00:16:53,920
the current queue just like we saw with

519
00:16:53,920 --> 00:16:56,079
with the fuzzy time model um after

520
00:16:56,079 --> 00:16:57,920
talking to the mozilla engineers and

521
00:16:57,920 --> 00:16:59,600
looking at it ourselves this was not

522
00:16:59,600 --> 00:17:01,519
going to happen firefox was not going to

523
00:17:01,519 --> 00:17:02,880
be amenable to us destroying their

524
00:17:02,880 --> 00:17:05,520
entire queueing model

525
00:17:05,520 --> 00:17:06,319
but

526
00:17:06,319 --> 00:17:08,640
we we realized after

527
00:17:08,640 --> 00:17:10,880
some thought and talking to uh mozilla

528
00:17:10,880 --> 00:17:12,559
engineer kyle huey who was a great help

529
00:17:12,559 --> 00:17:14,400
on this that what we actually wanted was

530
00:17:14,400 --> 00:17:16,720
we wanted a randomized pause between

531
00:17:16,720 --> 00:17:18,559
when we finished these events and when

532
00:17:18,559 --> 00:17:21,199
these events were allowed to execute

533
00:17:21,199 --> 00:17:22,959
and so instead of having multiple cues

534
00:17:22,959 --> 00:17:25,439
we can just take all of our cues smash

535
00:17:25,439 --> 00:17:27,679
them together and schedule a pause event

536
00:17:27,679 --> 00:17:28,720
in the middle

537
00:17:28,720 --> 00:17:31,120
it's the same thing essentially

538
00:17:31,120 --> 00:17:33,200
so that's what we did um

539
00:17:33,200 --> 00:17:34,799
uh we

540
00:17:34,799 --> 00:17:36,720
we built an event we call the pause task

541
00:17:36,720 --> 00:17:38,320
that kind of runs the entire fuzzy time

542
00:17:38,320 --> 00:17:40,480
system inside of fuzzyfox and as we're

543
00:17:40,480 --> 00:17:42,160
executing what happens is we eventually

544
00:17:42,160 --> 00:17:44,480
hit this pause the pause waits a

545
00:17:44,480 --> 00:17:47,120
randomized period of time based on on

546
00:17:47,120 --> 00:17:48,320
the time granularity and some other

547
00:17:48,320 --> 00:17:50,559
parameters and then it schedules the

548
00:17:50,559 --> 00:17:52,160
next pause

549
00:17:52,160 --> 00:17:53,679
and what this does is this implicitly

550
00:17:53,679 --> 00:17:56,960
splits up the syst the the execution of

551
00:17:56,960 --> 00:17:59,760
firefox into multiple cues and then we

552
00:17:59,760 --> 00:18:02,160
can say things about those cues

553
00:18:02,160 --> 00:18:04,160
so as we're executing then along further

554
00:18:04,160 --> 00:18:06,000
we'll get new events and they'll show up

555
00:18:06,000 --> 00:18:07,760
but implicitly this is actually

556
00:18:07,760 --> 00:18:09,360
something like three queues one we've

557
00:18:09,360 --> 00:18:11,440
completed a randomized pause

558
00:18:11,440 --> 00:18:13,039
one we're working on randomized pause

559
00:18:13,039 --> 00:18:14,640
and then another queue

560
00:18:14,640 --> 00:18:16,880
and between these pauses time does not

561
00:18:16,880 --> 00:18:19,600
advance as far as javascript is able to

562
00:18:19,600 --> 00:18:22,160
tell so anybody executing javascript in

563
00:18:22,160 --> 00:18:24,080
one of these events is unable to

564
00:18:24,080 --> 00:18:26,000
determine kind of

565
00:18:26,000 --> 00:18:27,840
any timing information between the

566
00:18:27,840 --> 00:18:30,000
pauses

567
00:18:30,000 --> 00:18:31,120
and these are you know essentially

568
00:18:31,120 --> 00:18:33,280
therefore clock epics now as i said the

569
00:18:33,280 --> 00:18:34,640
implementation of this turns out to be a

570
00:18:34,640 --> 00:18:36,480
little bit tricky uh it needs to do

571
00:18:36,480 --> 00:18:39,520
things like randomly sleep possibly

572
00:18:39,520 --> 00:18:42,080
design retroactive information it needs

573
00:18:42,080 --> 00:18:44,000
to update all of the clocks flush all of

574
00:18:44,000 --> 00:18:45,919
the different cues or decide when to do

575
00:18:45,919 --> 00:18:48,080
them and schedule the next pause

576
00:18:48,080 --> 00:18:49,679
and you should look at the the paper for

577
00:18:49,679 --> 00:18:51,679
details on how we made this decisions

578
00:18:51,679 --> 00:18:53,120
and why

579
00:18:53,120 --> 00:18:55,440
but kind of the obvious question is does

580
00:18:55,440 --> 00:18:57,360
that work does this do anything to

581
00:18:57,360 --> 00:18:59,200
clocks in the system and thankfully the

582
00:18:59,200 --> 00:19:01,120
answer is yes it does

583
00:19:01,120 --> 00:19:04,640
so this is a comparison of that exact

584
00:19:04,640 --> 00:19:07,039
performance.now rounded down clock i

585
00:19:07,039 --> 00:19:08,320
showed you earlier

586
00:19:08,320 --> 00:19:10,000
on the left we have the same graph you

587
00:19:10,000 --> 00:19:12,080
saw earlier for firefox

588
00:19:12,080 --> 00:19:14,240
and on the left on the right we have

589
00:19:14,240 --> 00:19:16,400
effectively the same attack code running

590
00:19:16,400 --> 00:19:18,720
in fuzzyfox and what you see is we don't

591
00:19:18,720 --> 00:19:20,960
get a nice step function we don't get

592
00:19:20,960 --> 00:19:22,559
this nice improvement when we apply the

593
00:19:22,559 --> 00:19:24,240
clock edge technique we kind of just get

594
00:19:24,240 --> 00:19:26,240
these striations

595
00:19:26,240 --> 00:19:27,600
and this is great so it works for

596
00:19:27,600 --> 00:19:28,880
explicit clocks does it work for

597
00:19:28,880 --> 00:19:32,320
implicit clocks yes it does so if on the

598
00:19:32,320 --> 00:19:35,120
left we have that webvtt subtitling

599
00:19:35,120 --> 00:19:36,880
implicit clock we see that you know

600
00:19:36,880 --> 00:19:38,559
you've got step function and improvement

601
00:19:38,559 --> 00:19:40,400
and on the right again we've kind of got

602
00:19:40,400 --> 00:19:43,039
noise and all of the different implicit

603
00:19:43,039 --> 00:19:44,799
clocks we looked at ended up actually

604
00:19:44,799 --> 00:19:46,559
behaving somewhat like this including

605
00:19:46,559 --> 00:19:47,919
the ones that our system wasn't even

606
00:19:47,919 --> 00:19:50,640
designed to fix

607
00:19:51,120 --> 00:19:52,960
now all of those graphs and all of that

608
00:19:52,960 --> 00:19:54,640
data was still kind of in this 100

609
00:19:54,640 --> 00:19:56,720
millisecond rounded down granularity

610
00:19:56,720 --> 00:19:57,600
space

611
00:19:57,600 --> 00:19:59,679
uh that's a big number especially for

612
00:19:59,679 --> 00:20:01,840
for a web browser that is expected to be

613
00:20:01,840 --> 00:20:03,760
performant so performance is a totally

614
00:20:03,760 --> 00:20:05,600
reasonable question

615
00:20:05,600 --> 00:20:07,039
what we wanted to look at for

616
00:20:07,039 --> 00:20:08,960
performance in this system was kind of

617
00:20:08,960 --> 00:20:11,200
some mental micro benchmarks to

618
00:20:11,200 --> 00:20:14,000
understand where the the pain points in

619
00:20:14,000 --> 00:20:16,159
the design that we came up with were

620
00:20:16,159 --> 00:20:18,000
some sort of macro benchmarks to look at

621
00:20:18,000 --> 00:20:20,240
real websites and then really the big

622
00:20:20,240 --> 00:20:21,760
one would have been interactivity into

623
00:20:21,760 --> 00:20:23,039
user study

624
00:20:23,039 --> 00:20:24,159
i've already told you a whole bunch of

625
00:20:24,159 --> 00:20:25,760
things we ran out of time to run a user

626
00:20:25,760 --> 00:20:26,640
study

627
00:20:26,640 --> 00:20:28,080
but i will talk briefly about some of

628
00:20:28,080 --> 00:20:29,679
the micro performance benchmarks that we

629
00:20:29,679 --> 00:20:31,200
had

630
00:20:31,200 --> 00:20:32,400
so uh

631
00:20:32,400 --> 00:20:35,039
for the the microperformance we measured

632
00:20:35,039 --> 00:20:37,520
page load time because we interfered

633
00:20:37,520 --> 00:20:39,520
rather heavily with page loads we're

634
00:20:39,520 --> 00:20:41,840
breaking the main thread up um we're

635
00:20:41,840 --> 00:20:44,159
stopping outgoing http requests for some

636
00:20:44,159 --> 00:20:45,600
period of time

637
00:20:45,600 --> 00:20:46,799
and we want to look at the effects of

638
00:20:46,799 --> 00:20:48,799
both sequential resource loads and

639
00:20:48,799 --> 00:20:50,720
parallel resource loads now parallel

640
00:20:50,720 --> 00:20:52,640
resource loads uh turned out to be

641
00:20:52,640 --> 00:20:54,159
perfectly fine because we're doing a

642
00:20:54,159 --> 00:20:56,480
natural cueing and batching system so if

643
00:20:56,480 --> 00:20:57,679
you have a bunch of parallel resource

644
00:20:57,679 --> 00:20:58,880
loads they all get fired at once and

645
00:20:58,880 --> 00:21:00,320
everything's okay

646
00:21:00,320 --> 00:21:03,360
that's good news because http 2 likes to

647
00:21:03,360 --> 00:21:04,960
encourage things like parallel resource

648
00:21:04,960 --> 00:21:07,360
loads so we like that um sequential

649
00:21:07,360 --> 00:21:09,280
resource loads start incurring penalties

650
00:21:09,280 --> 00:21:11,120
based on the time granularity in the

651
00:21:11,120 --> 00:21:12,799
system

652
00:21:12,799 --> 00:21:15,120
so this is a graph of our page load of

653
00:21:15,120 --> 00:21:18,159
the 95th percentile page load times uh

654
00:21:18,159 --> 00:21:20,159
on the on the y and then on the x we

655
00:21:20,159 --> 00:21:21,679
have the number of sequential resource

656
00:21:21,679 --> 00:21:24,480
loads and the different uh lines here

657
00:21:24,480 --> 00:21:26,720
are different time granularity settings

658
00:21:26,720 --> 00:21:29,440
for fuzzy fox now remember that the the

659
00:21:29,440 --> 00:21:31,039
guarantees for channel bandwidth that

660
00:21:31,039 --> 00:21:33,120
you get are directly related to the time

661
00:21:33,120 --> 00:21:35,039
granularity you have set

662
00:21:35,039 --> 00:21:36,880
so if you have a time granularity of

663
00:21:36,880 --> 00:21:38,880
like one or five milliseconds the

664
00:21:38,880 --> 00:21:40,720
overhead over the zero which is

665
00:21:40,720 --> 00:21:43,679
essentially firefox uh is pretty minimal

666
00:21:43,679 --> 00:21:45,679
it looks totally usable uh i can tell

667
00:21:45,679 --> 00:21:47,360
you from experience that it is

668
00:21:47,360 --> 00:21:48,799
whereas if you have something like 100

669
00:21:48,799 --> 00:21:50,559
milliseconds these penalties start to

670
00:21:50,559 --> 00:21:52,320
look a little bit ridiculous you're

671
00:21:52,320 --> 00:21:54,400
talking about two seconds to you know

672
00:21:54,400 --> 00:21:56,799
five seconds

673
00:21:56,799 --> 00:21:59,200
and while those penalties are high

674
00:21:59,200 --> 00:22:00,960
uh we wanted to compare them against

675
00:22:00,960 --> 00:22:02,640
something that has a kind of similar

676
00:22:02,640 --> 00:22:05,360
threat model which is tor browser

677
00:22:05,360 --> 00:22:07,440
so these are ranges of load times on the

678
00:22:07,440 --> 00:22:09,760
same types of

679
00:22:09,760 --> 00:22:11,600
micro benchmark tests

680
00:22:11,600 --> 00:22:13,440
the blue here is tor browser or the

681
00:22:13,440 --> 00:22:15,039
green depending on the color

682
00:22:15,039 --> 00:22:17,520
and the orange here is fuzzy fox and you

683
00:22:17,520 --> 00:22:20,080
shouldn't draw lots of detailed

684
00:22:20,080 --> 00:22:21,919
results data out of this graph because

685
00:22:21,919 --> 00:22:23,760
our our tor browser data is incredibly

686
00:22:23,760 --> 00:22:25,520
noisy you're running through the tor

687
00:22:25,520 --> 00:22:27,679
network um but the

688
00:22:27,679 --> 00:22:29,520
the thing you should draw is if you're

689
00:22:29,520 --> 00:22:30,640
talking about somebody who has a very

690
00:22:30,640 --> 00:22:32,400
serious threat model somebody who's

691
00:22:32,400 --> 00:22:33,520
running tor browser and cares a lot

692
00:22:33,520 --> 00:22:35,679
about privacy

693
00:22:35,679 --> 00:22:37,280
running what we found to be essentially

694
00:22:37,280 --> 00:22:39,200
the highest granularity fuzzy fox that

695
00:22:39,200 --> 00:22:41,679
was that had that was usable

696
00:22:41,679 --> 00:22:42,960
still doesn't have the kind of

697
00:22:42,960 --> 00:22:44,720
performance overhead that makes tor

698
00:22:44,720 --> 00:22:46,240
browser look uh

699
00:22:46,240 --> 00:22:48,080
fast

700
00:22:48,080 --> 00:22:49,679
so pushing these types of defenses to

701
00:22:49,679 --> 00:22:51,360
something like tor browser makes a lot

702
00:22:51,360 --> 00:22:52,960
of sense

703
00:22:52,960 --> 00:22:54,080
now i talked about a whole bunch of

704
00:22:54,080 --> 00:22:55,600
different things what are the kind of

705
00:22:55,600 --> 00:22:57,679
the takeaways here um the first is that

706
00:22:57,679 --> 00:23:00,240
you should read uh fuzzy time by who

707
00:23:00,240 --> 00:23:02,720
from oakland 91 it's a fantastic paper

708
00:23:02,720 --> 00:23:04,320
uh then you should read our paper but

709
00:23:04,320 --> 00:23:06,559
you should read that one first

710
00:23:06,559 --> 00:23:08,799
the second is that that uh the the

711
00:23:08,799 --> 00:23:11,280
timing attack stuff i was showing you um

712
00:23:11,280 --> 00:23:12,640
browsers are attempting to round down

713
00:23:12,640 --> 00:23:15,120
clocks and this is not working for the

714
00:23:15,120 --> 00:23:16,640
defensive guarantees we would kind of

715
00:23:16,640 --> 00:23:18,000
hope out of it

716
00:23:18,000 --> 00:23:19,600
thankfully there is this body of work

717
00:23:19,600 --> 00:23:21,600
called fuzzy time that we can draw upon

718
00:23:21,600 --> 00:23:23,039
that does give the guarantees that we

719
00:23:23,039 --> 00:23:25,280
want for rounded down clocks and we can

720
00:23:25,280 --> 00:23:28,000
apply that model to browsers to build a

721
00:23:28,000 --> 00:23:30,320
trusted browser

722
00:23:30,320 --> 00:23:32,480
and then that a bunch of the the kind of

723
00:23:32,480 --> 00:23:34,480
engineering details of that we have

724
00:23:34,480 --> 00:23:36,720
tested they seem totally plausible and

725
00:23:36,720 --> 00:23:38,559
we think we can even deploy some of them

726
00:23:38,559 --> 00:23:40,320
to browsers today

727
00:23:40,320 --> 00:23:42,400
um obviously thank you to many people

728
00:23:42,400 --> 00:23:43,520
who helped with this especially a bunch

729
00:23:43,520 --> 00:23:45,600
of mozilla engineers and with that i

730
00:23:45,600 --> 00:23:48,100
will go to questions

731
00:23:48,100 --> 00:23:56,990
[Applause]

732
00:24:01,360 --> 00:24:03,279
uh dan wallach rice university i really

733
00:24:03,279 --> 00:24:05,360
like this work and i'm curious how it

734
00:24:05,360 --> 00:24:08,400
interacts with animations and games that

735
00:24:08,400 --> 00:24:10,960
want to look at the clock at a very fine

736
00:24:10,960 --> 00:24:12,320
resolution so that way they can have

737
00:24:12,320 --> 00:24:14,320
smooth animation so if you want for

738
00:24:14,320 --> 00:24:16,400
example those high granularity settings

739
00:24:16,400 --> 00:24:18,880
the games won't work um our argument

740
00:24:18,880 --> 00:24:20,960
there is if you're setting you know we

741
00:24:20,960 --> 00:24:22,559
we envision a

742
00:24:22,559 --> 00:24:25,039
an ideal world where we have a system

743
00:24:25,039 --> 00:24:27,600
like the the fuzzy time system set up

744
00:24:27,600 --> 00:24:30,559
and a browser like firefox has a time

745
00:24:30,559 --> 00:24:32,159
granularity setting that is that is

746
00:24:32,159 --> 00:24:34,720
small um and does not significantly

747
00:24:34,720 --> 00:24:36,159
interfere with things like animation so

748
00:24:36,159 --> 00:24:37,039
we're talking about a couple

749
00:24:37,039 --> 00:24:39,360
milliseconds of time granularity at most

750
00:24:39,360 --> 00:24:41,679
and then a browser like tor browser that

751
00:24:41,679 --> 00:24:43,200
is going to make a different trade-off

752
00:24:43,200 --> 00:24:44,960
is able to set a higher granularity

753
00:24:44,960 --> 00:24:46,480
without the overhead of having to build

754
00:24:46,480 --> 00:24:48,240
a whole new system on top

755
00:24:48,240 --> 00:24:50,480
so what's the smallest or i guess what's

756
00:24:50,480 --> 00:24:52,559
the largest time granularity you can set

757
00:24:52,559 --> 00:24:55,200
where 60 hertz animations and games and

758
00:24:55,200 --> 00:24:57,120
things still work i mean it would be

759
00:24:57,120 --> 00:24:59,679
something like 16 milliseconds

760
00:24:59,679 --> 00:25:01,840
okay

761
00:25:03,840 --> 00:25:06,159
hi eric worstro university of colorado

762
00:25:06,159 --> 00:25:08,720
boulder nice work i i'm curious how this

763
00:25:08,720 --> 00:25:09,679
is

764
00:25:09,679 --> 00:25:11,360
this would play out if you have an

765
00:25:11,360 --> 00:25:13,120
adversary that's streaming

766
00:25:13,120 --> 00:25:15,760
time over a websocket network connection

767
00:25:15,760 --> 00:25:18,799
for example um and if if the order of

768
00:25:18,799 --> 00:25:20,799
those events are all preserved perhaps

769
00:25:20,799 --> 00:25:23,120
they can observe absolutely so

770
00:25:23,120 --> 00:25:24,880
so web sockets are a great example here

771
00:25:24,880 --> 00:25:26,559
um we didn't interfere with websockets

772
00:25:26,559 --> 00:25:28,480
in fuzzy fox and then again that was

773
00:25:28,480 --> 00:25:30,080
just due to kind of like we had so many

774
00:25:30,080 --> 00:25:32,320
parts to build um so in fuzzyfox

775
00:25:32,320 --> 00:25:34,640
websockets would do would do

776
00:25:34,640 --> 00:25:36,799
actually shockingly poorly as long as

777
00:25:36,799 --> 00:25:38,159
they were being delivered on the main

778
00:25:38,159 --> 00:25:40,799
event thread so we don't uh

779
00:25:40,799 --> 00:25:43,039
care about somebody you know some some

780
00:25:43,039 --> 00:25:45,440
process or some socket delivering high

781
00:25:45,440 --> 00:25:47,679
precision time as long as when those

782
00:25:47,679 --> 00:25:49,760
events arrive they're no longer fresh

783
00:25:49,760 --> 00:25:51,919
they're stale essentially and so the

784
00:25:51,919 --> 00:25:54,320
because of the the main event the thread

785
00:25:54,320 --> 00:25:56,240
being broken up in the way that it is as

786
00:25:56,240 --> 00:25:58,000
the events arrive they're going to be

787
00:25:58,000 --> 00:25:59,520
able to learn some information but not

788
00:25:59,520 --> 00:26:01,440
more now for websockets specifically it

789
00:26:01,440 --> 00:26:02,640
could be the case that what we need to

790
00:26:02,640 --> 00:26:04,640
do is put them into a queuing system of

791
00:26:04,640 --> 00:26:05,760
their own

792
00:26:05,760 --> 00:26:07,279
and then fire that queue randomly and

793
00:26:07,279 --> 00:26:08,400
that would be something that we would

794
00:26:08,400 --> 00:26:11,120
want to do in fermata well i'm curious

795
00:26:11,120 --> 00:26:13,919
more specifically if if i as the

796
00:26:13,919 --> 00:26:15,679
attacker happened to get two events that

797
00:26:15,679 --> 00:26:17,440
straddled the pauses that you have in

798
00:26:17,440 --> 00:26:19,679
the in the main queue then the

799
00:26:19,679 --> 00:26:21,039
attacker's javascript would be able to

800
00:26:21,039 --> 00:26:22,559
observe that pause and since it's a

801
00:26:22,559 --> 00:26:26,000
global uh state then they can uh infer

802
00:26:26,000 --> 00:26:27,679
that you might be able to observe that

803
00:26:27,679 --> 00:26:29,279
pause it depends on if the pause updated

804
00:26:29,279 --> 00:26:31,360
the clocks or not so so one thing i

805
00:26:31,360 --> 00:26:32,799
didn't have time to go over was that the

806
00:26:32,799 --> 00:26:34,240
the pauses don't always update the

807
00:26:34,240 --> 00:26:36,320
clocks it depends on both the time

808
00:26:36,320 --> 00:26:38,320
granularity and how long the pause took

809
00:26:38,320 --> 00:26:40,080
and so it can it can be the case that

810
00:26:40,080 --> 00:26:42,640
you run into a pause and then time still

811
00:26:42,640 --> 00:26:44,400
doesn't advance as far as javascript can

812
00:26:44,400 --> 00:26:45,840
tell

813
00:26:45,840 --> 00:26:47,520
and and that could that could make that

814
00:26:47,520 --> 00:26:48,720
trickier for the attacker to tell

815
00:26:48,720 --> 00:26:50,640
whether or not a pause occurred i see

816
00:26:50,640 --> 00:26:52,080
but eventually there will be sort of

817
00:26:52,080 --> 00:26:53,600
queuing that happens up with this right

818
00:26:53,600 --> 00:26:55,520
so eventually and and that gets back to

819
00:26:55,520 --> 00:26:57,039
kind of the one of the core assumptions

820
00:26:57,039 --> 00:26:58,400
of this which is that the attacker does

821
00:26:58,400 --> 00:27:00,080
learn information they just learn it at

822
00:27:00,080 --> 00:27:01,840
a rate that we know what they're

823
00:27:01,840 --> 00:27:04,840
learning in the app cool

824
00:27:04,840 --> 00:27:08,720
thanks hi uh dev from dropbox uh i love

825
00:27:08,720 --> 00:27:10,559
this work it's fascinating

826
00:27:10,559 --> 00:27:12,240
i was curious uh i'm trying to get a

827
00:27:12,240 --> 00:27:14,320
sense of how important this model that

828
00:27:14,320 --> 00:27:16,559
the browser has a single event queue

829
00:27:16,559 --> 00:27:18,640
was to the mitigations because i think

830
00:27:18,640 --> 00:27:20,399
some modern browsers are moving and in

831
00:27:20,399 --> 00:27:21,840
general we have many more event queues

832
00:27:21,840 --> 00:27:23,679
even in firefox but like chrome is

833
00:27:23,679 --> 00:27:24,960
moving to a multi-processor like each

834
00:27:24,960 --> 00:27:27,679
iframe in a separate process uh how will

835
00:27:27,679 --> 00:27:29,440
that impact uh i could just have a

836
00:27:29,440 --> 00:27:30,880
separate iphone that's only doing web

837
00:27:30,880 --> 00:27:32,720
sockets so it ends up depending entirely

838
00:27:32,720 --> 00:27:35,679
on on the shared state problem so for

839
00:27:35,679 --> 00:27:36,960
example javascript is currently

840
00:27:36,960 --> 00:27:39,440
considering adding shared memory uh that

841
00:27:39,440 --> 00:27:41,520
would destroy this entire model

842
00:27:41,520 --> 00:27:43,600
because then separate javascript threads

843
00:27:43,600 --> 00:27:44,880
could one of them could act as a clock

844
00:27:44,880 --> 00:27:47,039
and increment memory so if the if the

845
00:27:47,039 --> 00:27:49,440
browser splits up the the kind of the

846
00:27:49,440 --> 00:27:50,720
main event thread processing into

847
00:27:50,720 --> 00:27:52,799
multiple queues and we interdict on all

848
00:27:52,799 --> 00:27:54,320
of those those cues in the same way that

849
00:27:54,320 --> 00:27:56,320
we currently are and they don't have

850
00:27:56,320 --> 00:27:59,360
synchronous communication we're fine

851
00:27:59,360 --> 00:28:01,600
if that's if if that communication ends

852
00:28:01,600 --> 00:28:02,960
up being synchronous we run into a

853
00:28:02,960 --> 00:28:04,399
shared state problem and the defense

854
00:28:04,399 --> 00:28:06,159
starts to have issues

855
00:28:06,159 --> 00:28:08,480
but uh separately adding noise to each

856
00:28:08,480 --> 00:28:10,000
event queue

857
00:28:10,000 --> 00:28:11,840
like right now your impact on usability

858
00:28:11,840 --> 00:28:13,279
and performance is lower because that

859
00:28:13,279 --> 00:28:14,720
like that impact is shared across

860
00:28:14,720 --> 00:28:17,520
multiple but if you add noise separately

861
00:28:17,520 --> 00:28:19,440
to each event queue i feel like the

862
00:28:19,440 --> 00:28:21,039
usability or performance would have a

863
00:28:21,039 --> 00:28:22,320
much worse impact or am i

864
00:28:22,320 --> 00:28:24,720
misunderstanding something uh

865
00:28:24,720 --> 00:28:26,559
i am not sure because obviously

866
00:28:26,559 --> 00:28:27,760
we haven't been able to test that um i

867
00:28:27,760 --> 00:28:29,039
would suspect that you could get it to

868
00:28:29,039 --> 00:28:30,880
something that looks like the current

869
00:28:30,880 --> 00:28:34,159
impact okay thanks

870
00:28:36,640 --> 00:28:41,080
all right let's thank the speaker again

871
00:28:45,120 --> 00:28:47,199
you

