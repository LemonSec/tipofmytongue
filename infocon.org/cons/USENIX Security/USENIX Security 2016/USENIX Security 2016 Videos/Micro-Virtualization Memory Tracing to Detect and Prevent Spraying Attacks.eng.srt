1
00:00:10,960 --> 00:00:12,559
thank you for introducing me so i'm

2
00:00:12,559 --> 00:00:14,400
mariano graziano i'm a security

3
00:00:14,400 --> 00:00:17,600
researcher for cisco and today this talk

4
00:00:17,600 --> 00:00:19,680
is about a framework to detect and

5
00:00:19,680 --> 00:00:22,320
prevent any kind of spraying attacks

6
00:00:22,320 --> 00:00:24,720
this is a joint walk between university

7
00:00:24,720 --> 00:00:27,760
of milano between cisco and eurocoming

8
00:00:27,760 --> 00:00:29,519
funds

9
00:00:29,519 --> 00:00:32,320
so let's start with uh the definition of

10
00:00:32,320 --> 00:00:34,239
spraying what is spraying so spraying is

11
00:00:34,239 --> 00:00:36,079
a generic common payload delivery

12
00:00:36,079 --> 00:00:37,600
technique that has been specifically

13
00:00:37,600 --> 00:00:38,640
designed

14
00:00:38,640 --> 00:00:41,840
with the goal to bypass the address

15
00:00:41,840 --> 00:00:43,920
space layout randomization

16
00:00:43,920 --> 00:00:45,600
that is an operating system protection

17
00:00:45,600 --> 00:00:47,680
to randomize the base address of the

18
00:00:47,680 --> 00:00:49,840
code and libraries

19
00:00:49,840 --> 00:00:51,840
so over the years security researcher

20
00:00:51,840 --> 00:00:54,160
has shown how to spray the heap how to

21
00:00:54,160 --> 00:00:56,079
spray the kernel pools or how to spray

22
00:00:56,079 --> 00:00:59,680
the just in time compiler pages

23
00:00:59,680 --> 00:01:01,760
and

24
00:01:01,760 --> 00:01:03,680
over the years

25
00:01:03,680 --> 00:01:05,199
basically

26
00:01:05,199 --> 00:01:07,600
we know how to spray these memory

27
00:01:07,600 --> 00:01:09,439
regions but we can also categorize

28
00:01:09,439 --> 00:01:12,320
spraying depending on how that on how

29
00:01:12,320 --> 00:01:14,159
the attacker is playing okay so for

30
00:01:14,159 --> 00:01:16,560
historical reason the first method is

31
00:01:16,560 --> 00:01:17,759
uh

32
00:01:17,759 --> 00:01:19,520
the so-called traditional code based

33
00:01:19,520 --> 00:01:22,320
brain okay in this case

34
00:01:22,320 --> 00:01:24,479
uh the scenario is that the operating

35
00:01:24,479 --> 00:01:26,880
system has the aslr so the other

36
00:01:26,880 --> 00:01:28,240
specialized randomization that is

37
00:01:28,240 --> 00:01:29,200
enabled

38
00:01:29,200 --> 00:01:31,759
but the data execution prevention

39
00:01:31,759 --> 00:01:34,479
is either disabled or not supported okay

40
00:01:34,479 --> 00:01:36,479
nowadays it is not so common but first

41
00:01:36,479 --> 00:01:38,240
for historical reason i have to mention

42
00:01:38,240 --> 00:01:40,159
also this approach so in this case

43
00:01:40,159 --> 00:01:42,720
anyway when as aslr is in place the

44
00:01:42,720 --> 00:01:44,399
attacker needs to

45
00:01:44,399 --> 00:01:46,399
guess or anyway know the

46
00:01:46,399 --> 00:01:49,600
address of its payload okay

47
00:01:49,600 --> 00:01:51,840
so in order to increase the probability

48
00:01:51,840 --> 00:01:54,640
of success of the attack one of the

49
00:01:54,640 --> 00:01:57,119
possible ways is to fill

50
00:01:57,119 --> 00:01:58,399
the

51
00:01:58,399 --> 00:02:00,560
the memory of the target application

52
00:02:00,560 --> 00:02:03,439
with hundreds of thousands of copies

53
00:02:03,439 --> 00:02:04,399
of

54
00:02:04,399 --> 00:02:06,880
of the payload that in this case is

55
00:02:06,880 --> 00:02:09,119
either the shell code okay

56
00:02:09,119 --> 00:02:12,400
so then another another possible case is

57
00:02:12,400 --> 00:02:14,400
the so-called jit strain

58
00:02:14,400 --> 00:02:17,120
in this case um the idea is that the

59
00:02:17,120 --> 00:02:20,160
attacker wants to bypass both slr and

60
00:02:20,160 --> 00:02:22,400
that execution prevention

61
00:02:22,400 --> 00:02:24,080
in this way um

62
00:02:24,080 --> 00:02:26,400
in this case the attacker basically is

63
00:02:26,400 --> 00:02:27,920
using um

64
00:02:27,920 --> 00:02:31,120
the executable pages that are as that

65
00:02:31,120 --> 00:02:33,120
are dynamic that are generated on the

66
00:02:33,120 --> 00:02:35,440
fly by the just-in-time compiler

67
00:02:35,440 --> 00:02:37,920
then for the case of data spraying and

68
00:02:37,920 --> 00:02:40,560
and then for um the stack pivoting the

69
00:02:40,560 --> 00:02:42,720
main idea in this case is that again

70
00:02:42,720 --> 00:02:44,800
okay the attacker wants to bypass both

71
00:02:44,800 --> 00:02:46,560
slr and that

72
00:02:46,560 --> 00:02:48,800
but in this case uh it fills their

73
00:02:48,800 --> 00:02:51,920
memory with data but in this case data

74
00:02:51,920 --> 00:02:53,840
is in the form of blockchain so we have

75
00:02:53,840 --> 00:02:55,360
hundreds of thousands of copy of the

76
00:02:55,360 --> 00:02:57,040
same opt chain

77
00:02:57,040 --> 00:02:58,480
then

78
00:02:58,480 --> 00:02:59,680
the

79
00:02:59,680 --> 00:03:01,599
one of the first

80
00:03:01,599 --> 00:03:04,560
gadgets of this rock chain perform the

81
00:03:04,560 --> 00:03:06,959
so-called pivoting so this means that

82
00:03:06,959 --> 00:03:09,920
the stack pointer is changing two points

83
00:03:09,920 --> 00:03:13,440
to desperate data okay

84
00:03:14,080 --> 00:03:16,000
so

85
00:03:16,000 --> 00:03:17,519
in the last decade the spraying of

86
00:03:17,519 --> 00:03:19,519
phenomena has been studied a lot by

87
00:03:19,519 --> 00:03:21,280
different researchers and from different

88
00:03:21,280 --> 00:03:23,040
different perspectives

89
00:03:23,040 --> 00:03:24,560
now i'm going to talk a little bit about

90
00:03:24,560 --> 00:03:26,159
the relative work for the defensive

91
00:03:26,159 --> 00:03:28,560
solutions we have

92
00:03:28,560 --> 00:03:30,560
a couple of good papers about possible

93
00:03:30,560 --> 00:03:32,640
defensive solution for the hip strength

94
00:03:32,640 --> 00:03:34,879
for instance we have neutral we have a

95
00:03:34,879 --> 00:03:36,000
bubble

96
00:03:36,000 --> 00:03:38,080
it has a different approach but

97
00:03:38,080 --> 00:03:40,159
all these approaches uh

98
00:03:40,159 --> 00:03:42,560
basically they are all all application

99
00:03:42,560 --> 00:03:44,720
specific so they just work for instance

100
00:03:44,720 --> 00:03:47,280
for one specific browser or sometimes

101
00:03:47,280 --> 00:03:49,760
they only work for a specific javascript

102
00:03:49,760 --> 00:03:51,360
engine

103
00:03:51,360 --> 00:03:53,120
then we have also a couple of good

104
00:03:53,120 --> 00:03:55,280
interesting papers about the jit spring

105
00:03:55,280 --> 00:03:56,080
like

106
00:03:56,080 --> 00:03:58,720
gtech or gt fender lobotomy and we have

107
00:03:58,720 --> 00:04:01,120
also here some um

108
00:04:01,120 --> 00:04:03,040
browser developers that

109
00:04:03,040 --> 00:04:05,280
like another talk yesterday at usinix

110
00:04:05,280 --> 00:04:08,080
they show that we have

111
00:04:08,080 --> 00:04:10,400
like the code blinding or the nope

112
00:04:10,400 --> 00:04:12,000
insertions

113
00:04:12,000 --> 00:04:13,280
in the browser

114
00:04:13,280 --> 00:04:16,160
and anyway all all these approaches have

115
00:04:16,160 --> 00:04:18,720
been bypassed by motivated attacker or

116
00:04:18,720 --> 00:04:20,320
again they are really application

117
00:04:20,320 --> 00:04:22,000
specific like they work only for indian

118
00:04:22,000 --> 00:04:23,840
explorer

119
00:04:23,840 --> 00:04:25,759
or even if they are more comprehensive

120
00:04:25,759 --> 00:04:27,919
they just solve one instance of the

121
00:04:27,919 --> 00:04:29,919
strain problem like in this case the jet

122
00:04:29,919 --> 00:04:31,600
stream

123
00:04:31,600 --> 00:04:33,120
then we have the problem with that we

124
00:04:33,120 --> 00:04:34,720
have some defensive solutions for data

125
00:04:34,720 --> 00:04:35,840
strain

126
00:04:35,840 --> 00:04:37,600
with some companies that propose like

127
00:04:37,600 --> 00:04:39,840
microsoft that propose emmet and it is a

128
00:04:39,840 --> 00:04:41,280
more generic

129
00:04:41,280 --> 00:04:44,320
solution in order to harden applications

130
00:04:44,320 --> 00:04:46,080
and among the other things i've really a

131
00:04:46,080 --> 00:04:47,919
really interesting feature that is the

132
00:04:47,919 --> 00:04:49,520
anti-pivoting

133
00:04:49,520 --> 00:04:51,280
then we have again some

134
00:04:51,280 --> 00:04:53,600
solution proposed some by some browser

135
00:04:53,600 --> 00:04:55,040
developers

136
00:04:55,040 --> 00:04:57,680
like the isolated deep or delayed free

137
00:04:57,680 --> 00:04:59,520
that anyway they hindered about the

138
00:04:59,520 --> 00:05:02,160
exploitation in which the strain is one

139
00:05:02,160 --> 00:05:04,880
of the is one of the steps but again

140
00:05:04,880 --> 00:05:05,759
these

141
00:05:05,759 --> 00:05:07,919
solutions are either application

142
00:05:07,919 --> 00:05:10,720
specific they work only for a browser

143
00:05:10,720 --> 00:05:12,639
or

144
00:05:12,639 --> 00:05:14,560
they solve only a single instance of

145
00:05:14,560 --> 00:05:16,400
destroying problem

146
00:05:16,400 --> 00:05:19,199
so at this point should be quite clear

147
00:05:19,199 --> 00:05:20,080
that

148
00:05:20,080 --> 00:05:22,479
we need a kind of solution that is able

149
00:05:22,479 --> 00:05:24,639
to cope with all the possible spraying

150
00:05:24,639 --> 00:05:26,080
implementations

151
00:05:26,080 --> 00:05:27,919
so we what we would like is to have a

152
00:05:27,919 --> 00:05:30,000
compressing scalable solution that can

153
00:05:30,000 --> 00:05:33,360
defeat any form of springs and ideally

154
00:05:33,360 --> 00:05:35,360
should be also operating system agnostic

155
00:05:35,360 --> 00:05:37,600
so it can work transparently both with

156
00:05:37,600 --> 00:05:41,280
linux and for instance windows

157
00:05:41,280 --> 00:05:43,120
so at the first site if we want to

158
00:05:43,120 --> 00:05:45,280
design such a system i mean such as

159
00:05:45,280 --> 00:05:47,680
spraying a defensive mechanism

160
00:05:47,680 --> 00:05:50,800
the design at the at the first site it

161
00:05:50,800 --> 00:05:53,120
seems really simple

162
00:05:53,120 --> 00:05:54,880
because if we think about the strain

163
00:05:54,880 --> 00:05:57,280
definition okay the first

164
00:05:57,280 --> 00:05:59,680
characteristics come up in our mind

165
00:05:59,680 --> 00:06:02,240
is that when an attacker performs spring

166
00:06:02,240 --> 00:06:04,160
it basically is allocating a large

167
00:06:04,160 --> 00:06:06,560
amount of memory in a small in a small

168
00:06:06,560 --> 00:06:09,199
amount of time so uh

169
00:06:09,199 --> 00:06:11,440
mistakenly one can think that we can

170
00:06:11,440 --> 00:06:13,680
perform a really uh

171
00:06:13,680 --> 00:06:16,800
basic waste exclusive such as stocks and

172
00:06:16,800 --> 00:06:18,560
if we look at these graphs basically we

173
00:06:18,560 --> 00:06:22,080
have in green in green and in red

174
00:06:22,080 --> 00:06:23,440
the behavior

175
00:06:23,440 --> 00:06:26,080
of some normal browser activities like

176
00:06:26,080 --> 00:06:28,160
we have a user that

177
00:06:28,160 --> 00:06:30,160
is browsing like google google maps

178
00:06:30,160 --> 00:06:33,520
youtube and another user that has a

179
00:06:33,520 --> 00:06:36,720
other tabs open and there is a

180
00:06:36,720 --> 00:06:38,720
browsing like for on

181
00:06:38,720 --> 00:06:40,639
news website

182
00:06:40,639 --> 00:06:43,840
and here we have the the memory uh the

183
00:06:43,840 --> 00:06:46,400
memory behavior then we have engraved

184
00:06:46,400 --> 00:06:49,520
the attacks or the destroying attacks

185
00:06:49,520 --> 00:06:53,280
from with a default um exploit taken

186
00:06:53,280 --> 00:06:54,960
from the default configuration from

187
00:06:54,960 --> 00:06:57,680
metasploit and we can clearly see that i

188
00:06:57,680 --> 00:06:58,960
mean the behavior is completely

189
00:06:58,960 --> 00:07:00,479
different and we have a large amount of

190
00:07:00,479 --> 00:07:02,560
memory allocated in a small amount of

191
00:07:02,560 --> 00:07:04,800
time

192
00:07:07,039 --> 00:07:08,400
so

193
00:07:08,400 --> 00:07:09,919
we have to keep in mind that we cannot

194
00:07:09,919 --> 00:07:12,319
design also such a system with such

195
00:07:12,319 --> 00:07:14,400
simple logistics because

196
00:07:14,400 --> 00:07:16,319
the tattoo control the two important

197
00:07:16,319 --> 00:07:18,160
parameters the attacker

198
00:07:18,160 --> 00:07:20,080
can control the size of the allocated

199
00:07:20,080 --> 00:07:22,080
memory and the attacker can control the

200
00:07:22,080 --> 00:07:25,039
speed so the time of the allocation

201
00:07:25,039 --> 00:07:28,000
so a motivated attacker can

202
00:07:28,000 --> 00:07:31,120
can can mimic basically the behavior

203
00:07:31,120 --> 00:07:34,160
of a banana of a banana of a benign

204
00:07:34,160 --> 00:07:36,400
application and these are what we see

205
00:07:36,400 --> 00:07:37,360
here

206
00:07:37,360 --> 00:07:40,319
basically uh we can mimic the

207
00:07:40,319 --> 00:07:42,400
the normal uh the normal browsing

208
00:07:42,400 --> 00:07:45,400
activities

209
00:07:45,680 --> 00:07:46,960
so

210
00:07:46,960 --> 00:07:50,000
we need a way to create a more complex

211
00:07:50,000 --> 00:07:51,360
system okay

212
00:07:51,360 --> 00:07:53,039
so we

213
00:07:53,039 --> 00:07:56,160
we try to list some important goals to

214
00:07:56,160 --> 00:07:58,639
define such an important system so

215
00:07:58,639 --> 00:07:59,759
the first

216
00:07:59,759 --> 00:08:01,280
the first goal should be to have an

217
00:08:01,280 --> 00:08:03,680
independent is to to have a system that

218
00:08:03,680 --> 00:08:05,280
is a completely independent from the

219
00:08:05,280 --> 00:08:06,879
memory allocator

220
00:08:06,879 --> 00:08:09,440
so in this way we can plug our system to

221
00:08:09,440 --> 00:08:12,400
any kind of application from ranging

222
00:08:12,400 --> 00:08:15,599
from a browser to a pdf viewer

223
00:08:15,599 --> 00:08:16,400
then

224
00:08:16,400 --> 00:08:18,240
we need

225
00:08:18,240 --> 00:08:20,000
we need a system that is operating

226
00:08:20,000 --> 00:08:21,599
system agnosis so can work again

227
00:08:21,599 --> 00:08:24,639
transparently on windows and macro

228
00:08:24,639 --> 00:08:26,960
effects then

229
00:08:26,960 --> 00:08:29,520
we want a system that it's modular

230
00:08:29,520 --> 00:08:32,240
because we want to plug

231
00:08:32,240 --> 00:08:34,799
many plugins uh that implements summary

232
00:08:34,799 --> 00:08:37,120
sticks to detect to detect the different

233
00:08:37,120 --> 00:08:39,360
instances of a spring

234
00:08:39,360 --> 00:08:42,320
and last but not least we want a system

235
00:08:42,320 --> 00:08:44,399
that has a

236
00:08:44,399 --> 00:08:47,279
low overhead because we want to deploy

237
00:08:47,279 --> 00:08:49,279
it on a real system machine or at least

238
00:08:49,279 --> 00:08:51,519
the overlap to be reasonable compared to

239
00:08:51,519 --> 00:08:55,399
other hypervisor solutions

240
00:08:55,920 --> 00:08:58,320
so this is the architecture of the

241
00:08:58,320 --> 00:09:00,560
system that we design

242
00:09:00,560 --> 00:09:02,480
so let's imagine that someone is

243
00:09:02,480 --> 00:09:05,120
visiting a website that can be either

244
00:09:05,120 --> 00:09:06,880
malicious or benign but anyway the

245
00:09:06,880 --> 00:09:08,640
important part is that at the given

246
00:09:08,640 --> 00:09:10,000
point there will be some kind of a

247
00:09:10,000 --> 00:09:11,839
location okay

248
00:09:11,839 --> 00:09:13,680
so this allocation is generally for an

249
00:09:13,680 --> 00:09:16,240
api then it's translating a system call

250
00:09:16,240 --> 00:09:18,080
and then it's going down to the kernel

251
00:09:18,080 --> 00:09:21,279
up to the page tables at this point

252
00:09:21,279 --> 00:09:23,279
our system this is uh that is a

253
00:09:23,279 --> 00:09:26,160
hypervisor based is able to intercept

254
00:09:26,160 --> 00:09:28,000
this memory request

255
00:09:28,000 --> 00:09:30,160
and this memory request is forward to

256
00:09:30,160 --> 00:09:32,080
the first component of our system that

257
00:09:32,080 --> 00:09:34,399
is called the memory tracer

258
00:09:34,399 --> 00:09:37,519
then when a given memory threshold

259
00:09:37,519 --> 00:09:38,720
um

260
00:09:38,720 --> 00:09:40,480
is reached

261
00:09:40,480 --> 00:09:42,160
the the memory tracer component

262
00:09:42,160 --> 00:09:44,399
basically activates the second component

263
00:09:44,399 --> 00:09:46,480
that is the attack detector that is the

264
00:09:46,480 --> 00:09:48,720
component in charge of detecting

265
00:09:48,720 --> 00:09:52,720
possible spraying attempts

266
00:09:52,800 --> 00:09:54,720
now i will talk in detail about each

267
00:09:54,720 --> 00:09:56,560
component so i will talk first about the

268
00:09:56,560 --> 00:09:58,959
memory tracer and then about the attack

269
00:09:58,959 --> 00:10:01,518
detector

270
00:10:01,680 --> 00:10:04,000
so in order to understand the semantic

271
00:10:04,000 --> 00:10:06,240
of the memory operations in the guest

272
00:10:06,240 --> 00:10:08,640
operating system

273
00:10:08,640 --> 00:10:11,760
our our framework

274
00:10:11,760 --> 00:10:14,560
needs to monitor all the memory

275
00:10:14,560 --> 00:10:17,120
operations that happens on

276
00:10:17,120 --> 00:10:19,839
the paging structures of the monitored

277
00:10:19,839 --> 00:10:21,200
application

278
00:10:21,200 --> 00:10:23,680
this is a possible thanks to the

279
00:10:23,680 --> 00:10:26,880
feature provided by the intel algorithm

280
00:10:26,880 --> 00:10:29,360
that is called the extended page table

281
00:10:29,360 --> 00:10:30,839
in short

282
00:10:30,839 --> 00:10:34,160
ept so in order to understand then the

283
00:10:34,160 --> 00:10:36,720
natural of these operations this kind of

284
00:10:36,720 --> 00:10:39,120
operation are like the creation the

285
00:10:39,120 --> 00:10:41,279
modification of the elimination of a

286
00:10:41,279 --> 00:10:43,200
memory page

287
00:10:43,200 --> 00:10:44,800
in order to understand the

288
00:10:44,800 --> 00:10:47,600
the nature of this operation we

289
00:10:47,600 --> 00:10:49,920
need because we want to know if these

290
00:10:49,920 --> 00:10:52,720
memory operations is attaching directly

291
00:10:52,720 --> 00:10:56,320
the paging structure or is creating

292
00:10:56,320 --> 00:10:58,839
like a normal new memory

293
00:10:58,839 --> 00:11:01,839
page like we can see in this picture our

294
00:11:01,839 --> 00:11:04,480
framework basically is checking

295
00:11:04,480 --> 00:11:06,880
the page directory the page the page

296
00:11:06,880 --> 00:11:08,560
directory entries and the page table

297
00:11:08,560 --> 00:11:09,760
entries

298
00:11:09,760 --> 00:11:11,600
in particular we check the bit

299
00:11:11,600 --> 00:11:14,959
permissions in order to understand if

300
00:11:14,959 --> 00:11:17,360
the page has been created modified or

301
00:11:17,360 --> 00:11:18,640
eliminated

302
00:11:18,640 --> 00:11:19,920
and

303
00:11:19,920 --> 00:11:21,279
in order to understand if the memory

304
00:11:21,279 --> 00:11:23,600
operation is happening

305
00:11:23,600 --> 00:11:25,440
on the page in structure itself we

306
00:11:25,440 --> 00:11:27,600
monitor the page directory

307
00:11:27,600 --> 00:11:29,920
if the operation instead is just

308
00:11:29,920 --> 00:11:32,480
creating a page in a normal memory page

309
00:11:32,480 --> 00:11:36,399
we check the page tables entries

310
00:11:37,920 --> 00:11:40,959
then as i said before if

311
00:11:40,959 --> 00:11:42,959
our system basically monitor all the

312
00:11:42,959 --> 00:11:45,519
paging structure but if we do that for

313
00:11:45,519 --> 00:11:47,519
the system-wide for the entire operating

314
00:11:47,519 --> 00:11:50,000
system or we do it

315
00:11:50,000 --> 00:11:51,839
for multiple applications at the same

316
00:11:51,839 --> 00:11:54,720
time during our experiments we

317
00:11:54,720 --> 00:11:57,839
we this a huge overhead okay

318
00:11:57,839 --> 00:11:59,760
and this is and this already is somehow

319
00:11:59,760 --> 00:12:02,240
problematic because one of our goals is

320
00:12:02,240 --> 00:12:03,440
to have

321
00:12:03,440 --> 00:12:05,519
a lower or at least a reasonable

322
00:12:05,519 --> 00:12:07,040
overhead okay

323
00:12:07,040 --> 00:12:09,600
so we try to investigate these this

324
00:12:09,600 --> 00:12:11,120
issue

325
00:12:11,120 --> 00:12:13,200
and what we notice is that even if we

326
00:12:13,200 --> 00:12:17,200
are monitoring a single a single process

327
00:12:17,200 --> 00:12:19,519
what uh what we expect is that we only

328
00:12:19,519 --> 00:12:22,160
notice the memory violation

329
00:12:22,160 --> 00:12:23,920
on the paging structure only for that

330
00:12:23,920 --> 00:12:25,680
particular process

331
00:12:25,680 --> 00:12:27,680
but actually we notice that the kernel

332
00:12:27,680 --> 00:12:29,680
at the same time is modifying

333
00:12:29,680 --> 00:12:31,920
the paging structures of also of other

334
00:12:31,920 --> 00:12:33,760
processes

335
00:12:33,760 --> 00:12:36,320
so what we want

336
00:12:36,320 --> 00:12:37,600
so first of all this is something that

337
00:12:37,600 --> 00:12:39,839
we noticed though the first thing to do

338
00:12:39,839 --> 00:12:41,600
is to try to measure this problem that

339
00:12:41,600 --> 00:12:43,440
we call the interference problem so the

340
00:12:43,440 --> 00:12:45,760
first experiment that we do

341
00:12:45,760 --> 00:12:48,240
that we did was to measure the ever the

342
00:12:48,240 --> 00:12:50,079
overhead for a single process in this

343
00:12:50,079 --> 00:12:52,320
case we choose the internet explorer 10

344
00:12:52,320 --> 00:12:56,000
and the overall in this case was 22 okay

345
00:12:56,000 --> 00:12:58,160
then we try to measure the again the

346
00:12:58,160 --> 00:13:00,639
overhead for the same application but at

347
00:13:00,639 --> 00:13:02,959
the same time we were monitoring um

348
00:13:02,959 --> 00:13:05,600
either two additional

349
00:13:05,600 --> 00:13:08,880
applications like acrobat reader or and

350
00:13:08,880 --> 00:13:10,000
firefox

351
00:13:10,000 --> 00:13:12,800
and in this case the

352
00:13:12,800 --> 00:13:14,800
the overhead for the application is

353
00:13:14,800 --> 00:13:18,720
jumping from 22 to 63 okay so basically

354
00:13:18,720 --> 00:13:20,399
we are increasing a lot it's increasing

355
00:13:20,399 --> 00:13:22,480
a lot then

356
00:13:22,480 --> 00:13:24,560
the overall ending is something that we

357
00:13:24,560 --> 00:13:27,440
we need to solve

358
00:13:27,440 --> 00:13:28,240
so

359
00:13:28,240 --> 00:13:30,079
we

360
00:13:30,079 --> 00:13:31,600
we've been streaming a lot and we come

361
00:13:31,600 --> 00:13:32,560
up with

362
00:13:32,560 --> 00:13:34,560
a possible solution that is we that we

363
00:13:34,560 --> 00:13:36,639
call the micro virtualization

364
00:13:36,639 --> 00:13:38,399
it is the main contribution of this

365
00:13:38,399 --> 00:13:39,440
research

366
00:13:39,440 --> 00:13:41,120
so the idea the main idea of micro

367
00:13:41,120 --> 00:13:42,959
visualization

368
00:13:42,959 --> 00:13:45,760
is to create a memory sandbox

369
00:13:45,760 --> 00:13:46,839
for

370
00:13:46,839 --> 00:13:50,880
every monitored application

371
00:13:50,880 --> 00:13:52,480
so um

372
00:13:52,480 --> 00:13:54,240
more in detail the micro virtualization

373
00:13:54,240 --> 00:13:56,560
is based on the intel hardware assisted

374
00:13:56,560 --> 00:13:59,519
virtualization uh features the vtx and

375
00:13:59,519 --> 00:14:02,560
in particular it heavily relies on the

376
00:14:02,560 --> 00:14:04,959
extended page tables feature

377
00:14:04,959 --> 00:14:07,680
so at the process creation our system

378
00:14:07,680 --> 00:14:10,399
basically selects a set of physical

379
00:14:10,399 --> 00:14:12,320
pages that are related to the paging

380
00:14:12,320 --> 00:14:14,240
structures

381
00:14:14,240 --> 00:14:17,600
and we monitor only these particular

382
00:14:17,600 --> 00:14:20,560
pages when the process is actually

383
00:14:20,560 --> 00:14:22,000
running

384
00:14:22,000 --> 00:14:24,000
how this is possible this is possible

385
00:14:24,000 --> 00:14:26,320
thanks to the so-called extended page

386
00:14:26,320 --> 00:14:28,000
table pointer

387
00:14:28,000 --> 00:14:30,560
so at every process which basically

388
00:14:30,560 --> 00:14:32,320
we we change

389
00:14:32,320 --> 00:14:34,959
the these this pointer to points to the

390
00:14:34,959 --> 00:14:37,600
set of physical pages that we want uh to

391
00:14:37,600 --> 00:14:39,120
monitor

392
00:14:39,120 --> 00:14:41,519
so this means that we create

393
00:14:41,519 --> 00:14:44,480
an ept pointer for every application

394
00:14:44,480 --> 00:14:47,519
that we want to monitor

395
00:14:48,320 --> 00:14:50,079
so now we will talk about the second

396
00:14:50,079 --> 00:14:51,760
component that is called the attack

397
00:14:51,760 --> 00:14:53,440
detector

398
00:14:53,440 --> 00:14:56,160
this component is activated only when we

399
00:14:56,160 --> 00:14:59,199
reach a certain activation

400
00:14:59,199 --> 00:15:00,800
threshold

401
00:15:00,800 --> 00:15:02,560
and it's important also to notice that i

402
00:15:02,560 --> 00:15:05,760
mean this detector is implemented

403
00:15:05,760 --> 00:15:08,480
with many plugins okay

404
00:15:08,480 --> 00:15:11,040
on top of the memory tracing system so

405
00:15:11,040 --> 00:15:13,279
anyone then can plug its own plugins and

406
00:15:13,279 --> 00:15:16,800
implement its own heuristics

407
00:15:18,079 --> 00:15:20,560
so the first

408
00:15:20,560 --> 00:15:22,880
the first uh plugin that we implemented

409
00:15:22,880 --> 00:15:24,639
is called the malicious code detector

410
00:15:24,639 --> 00:15:26,639
again here is the scenario is that the

411
00:15:26,639 --> 00:15:28,880
operating system has aslr that is

412
00:15:28,880 --> 00:15:30,000
enabled

413
00:15:30,000 --> 00:15:31,040
but

414
00:15:31,040 --> 00:15:32,959
dep is um

415
00:15:32,959 --> 00:15:34,560
is not activated

416
00:15:34,560 --> 00:15:37,199
so the idea here is that we randomly

417
00:15:37,199 --> 00:15:39,040
scan

418
00:15:39,040 --> 00:15:40,959
the allocated pages so far for that

419
00:15:40,959 --> 00:15:42,800
particular application

420
00:15:42,800 --> 00:15:46,800
you know and we look for um evidences of

421
00:15:46,800 --> 00:15:48,639
shell codes there are several approaches

422
00:15:48,639 --> 00:15:50,079
in the literature like a paper from

423
00:15:50,079 --> 00:15:53,040
access 2010 or using security papers

424
00:15:53,040 --> 00:15:55,279
from 2011 the important part is that we

425
00:15:55,279 --> 00:15:57,600
can port these heuristics to our own

426
00:15:57,600 --> 00:15:59,920
plugin on top of our memory tracing

427
00:15:59,920 --> 00:16:01,680
system

428
00:16:01,680 --> 00:16:05,120
then another plugin that we implemented

429
00:16:05,120 --> 00:16:06,639
is called the self-impacting shell code

430
00:16:06,639 --> 00:16:10,160
detector so basically here we want to

431
00:16:10,160 --> 00:16:11,519
detect

432
00:16:11,519 --> 00:16:13,519
any possible um

433
00:16:13,519 --> 00:16:16,160
unpacking behavior so this means

434
00:16:16,160 --> 00:16:18,160
the common unpacking behavior is that

435
00:16:18,160 --> 00:16:19,920
when you write a page and then you

436
00:16:19,920 --> 00:16:22,720
execute it so basically we we are

437
00:16:22,720 --> 00:16:25,440
we search uh on the memory pages this

438
00:16:25,440 --> 00:16:28,079
particular behavior of write and then

439
00:16:28,079 --> 00:16:30,560
execute and we implement these logistics

440
00:16:30,560 --> 00:16:33,440
that is again the is not an already it's

441
00:16:33,440 --> 00:16:37,440
taken from a paper from access 2007.

442
00:16:37,440 --> 00:16:40,639
then for the data for we have the

443
00:16:40,639 --> 00:16:42,959
another plugin that is another use case

444
00:16:42,959 --> 00:16:45,440
for our framework it implements a data

445
00:16:45,440 --> 00:16:47,519
screen detector

446
00:16:47,519 --> 00:16:48,480
again

447
00:16:48,480 --> 00:16:50,639
in this case

448
00:16:50,639 --> 00:16:52,720
what we want to do is we scan

449
00:16:52,720 --> 00:16:54,720
the memory pages allocated so far for

450
00:16:54,720 --> 00:16:56,800
that particular application

451
00:16:56,800 --> 00:16:58,320
and we

452
00:16:58,320 --> 00:16:59,199
we

453
00:16:59,199 --> 00:17:01,519
we implemented

454
00:17:01,519 --> 00:17:03,600
an heuristic that checks the frequency

455
00:17:03,600 --> 00:17:06,400
of the code pointers

456
00:17:06,400 --> 00:17:07,439
and

457
00:17:07,439 --> 00:17:09,520
but again we can put also other previous

458
00:17:09,520 --> 00:17:11,520
approaches as a form of plugin in order

459
00:17:11,520 --> 00:17:14,559
to detect data strain

460
00:17:14,799 --> 00:17:16,799
so now let's talk about the experiments

461
00:17:16,799 --> 00:17:18,720
that we did the first experiment

462
00:17:18,720 --> 00:17:21,359
either that we did perform is to measure

463
00:17:21,359 --> 00:17:23,919
the overhead of the first component that

464
00:17:23,919 --> 00:17:25,599
is the memory tracer that is the only

465
00:17:25,599 --> 00:17:28,720
component that is always active

466
00:17:28,720 --> 00:17:30,640
so what we did is that we use this quest

467
00:17:30,640 --> 00:17:32,960
width that is a benchmark suite

468
00:17:32,960 --> 00:17:34,480
that

469
00:17:34,480 --> 00:17:36,400
basically stress their location in the

470
00:17:36,400 --> 00:17:37,840
location

471
00:17:37,840 --> 00:17:39,760
and in particular this application will

472
00:17:39,760 --> 00:17:42,480
some create a program that

473
00:17:42,480 --> 00:17:45,280
simulates a lot of allocation allocation

474
00:17:45,280 --> 00:17:48,080
and we did it for windows 7 and linux

475
00:17:48,080 --> 00:17:50,240
3.2

476
00:17:50,240 --> 00:17:52,240
and we found with an allocation the

477
00:17:52,240 --> 00:17:54,240
location speed over on average eight

478
00:17:54,240 --> 00:17:56,400
megabytes every two seconds we measured

479
00:17:56,400 --> 00:17:59,760
the overhead and we had for windows 7 24

480
00:17:59,760 --> 00:18:02,080
and for linux 25

481
00:18:02,080 --> 00:18:04,799
only for the memory tracer but this is

482
00:18:04,799 --> 00:18:06,880
this is the worst case because we are

483
00:18:06,880 --> 00:18:10,000
using a stressing suite

484
00:18:10,080 --> 00:18:12,559
then another experiment that we did

485
00:18:12,559 --> 00:18:13,280
is

486
00:18:13,280 --> 00:18:15,840
to measure the overhead

487
00:18:15,840 --> 00:18:17,760
uh for our system

488
00:18:17,760 --> 00:18:20,400
uh by changing the activation threshold

489
00:18:20,400 --> 00:18:22,640
that is that threshold that is in charge

490
00:18:22,640 --> 00:18:25,440
of activating the second component that

491
00:18:25,440 --> 00:18:28,960
is performing basically the the checks

492
00:18:28,960 --> 00:18:31,600
for the possible spraying attempts

493
00:18:31,600 --> 00:18:33,520
so we start with a really conservative

494
00:18:33,520 --> 00:18:36,480
threshold over 100 megabytes and we went

495
00:18:36,480 --> 00:18:37,440
up to

496
00:18:37,440 --> 00:18:40,960
a threshold of 400 megabytes as expected

497
00:18:40,960 --> 00:18:43,520
i mean the the lower is the activation

498
00:18:43,520 --> 00:18:46,400
threshold the higher it's the

499
00:18:46,400 --> 00:18:49,280
is the overhead because we have more

500
00:18:49,280 --> 00:18:52,799
uh switches between the memory tracer

501
00:18:52,799 --> 00:18:57,000
of course and the attack detector

502
00:18:57,520 --> 00:18:59,919
then we did a couple of experiments to

503
00:18:59,919 --> 00:19:02,400
measure the effectiveness of our system

504
00:19:02,400 --> 00:19:04,480
so in this case we took

505
00:19:04,480 --> 00:19:07,120
six different at six different

506
00:19:07,120 --> 00:19:10,480
attacks six different real exploits

507
00:19:10,480 --> 00:19:13,039
that we carefully choose

508
00:19:13,039 --> 00:19:15,919
to be a representative for the possible

509
00:19:15,919 --> 00:19:17,840
strain implementation

510
00:19:17,840 --> 00:19:21,679
so and in fact we rank from some

511
00:19:21,679 --> 00:19:24,160
plain shell code spraying to the data

512
00:19:24,160 --> 00:19:27,200
spraying with of course with rob

513
00:19:27,200 --> 00:19:29,600
and then we also choose different uh

514
00:19:29,600 --> 00:19:31,600
applications like browsers like internet

515
00:19:31,600 --> 00:19:34,160
explorers of firefox to pdf reader and

516
00:19:34,160 --> 00:19:36,960
to up to flash player in all the cases

517
00:19:36,960 --> 00:19:38,880
our system was able to detect and

518
00:19:38,880 --> 00:19:43,039
prevent the spraying behavior

519
00:19:43,360 --> 00:19:45,039
then another

520
00:19:45,039 --> 00:19:47,840
experiment that we perform is to assess

521
00:19:47,840 --> 00:19:51,120
the accuracy of our system

522
00:19:51,120 --> 00:19:55,760
so in this case we took uh one uh 1000

523
00:19:55,760 --> 00:19:58,320
of benign pdf and then 1 000 of

524
00:19:58,320 --> 00:20:00,400
malicious pdf

525
00:20:00,400 --> 00:20:02,480
we configure our system with really

526
00:20:02,480 --> 00:20:05,760
conservative threshold of 150 megabytes

527
00:20:05,760 --> 00:20:06,960
and we

528
00:20:06,960 --> 00:20:09,280
and for the case of the pda over the

529
00:20:09,280 --> 00:20:12,799
pdfs we we were monitoring only the pdf

530
00:20:12,799 --> 00:20:14,720
viewer

531
00:20:14,720 --> 00:20:17,600
in this case our framework graffiti was

532
00:20:17,600 --> 00:20:18,640
able to

533
00:20:18,640 --> 00:20:20,799
detect with any false positive and then

534
00:20:20,799 --> 00:20:23,520
false negative all the attacks

535
00:20:23,520 --> 00:20:25,360
and then we did the same the same

536
00:20:25,360 --> 00:20:27,840
experiment with by monitoring a browser

537
00:20:27,840 --> 00:20:30,080
with the same conservative threshold and

538
00:20:30,080 --> 00:20:33,360
we visited the top 1000 alexa website

539
00:20:33,360 --> 00:20:35,840
and here was we were expecting is of

540
00:20:35,840 --> 00:20:38,159
course to not find any any possible

541
00:20:38,159 --> 00:20:39,840
attacks and this is what happened so we

542
00:20:39,840 --> 00:20:41,919
didn't have again any false positive or

543
00:20:41,919 --> 00:20:45,200
any photo negative

544
00:20:45,360 --> 00:20:47,120
then at the final experiment given the

545
00:20:47,120 --> 00:20:49,840
fact that we want to deploy a real

546
00:20:49,840 --> 00:20:52,320
system on a real user machines we

547
00:20:52,320 --> 00:20:55,520
install our system on two different

548
00:20:55,520 --> 00:20:56,559
machines

549
00:20:56,559 --> 00:20:58,559
and we ask to two users to use our

550
00:20:58,559 --> 00:21:01,679
system for one week for the daily

551
00:21:01,679 --> 00:21:03,919
activities so they they were using on

552
00:21:03,919 --> 00:21:05,919
average for eight to ten hours per day

553
00:21:05,919 --> 00:21:07,120
our system

554
00:21:07,120 --> 00:21:08,880
we

555
00:21:08,880 --> 00:21:11,200
specifically we configured

556
00:21:11,200 --> 00:21:13,919
our system to monitor uh the browser

557
00:21:13,919 --> 00:21:15,679
that these users were using that there

558
00:21:15,679 --> 00:21:17,919
was internet explorer 8 on their

559
00:21:17,919 --> 00:21:20,480
operating system that was windows 7

560
00:21:20,480 --> 00:21:23,440
and we set and we set up a really a

561
00:21:23,440 --> 00:21:27,600
conservative threshold of 150 megabytes

562
00:21:27,600 --> 00:21:29,280
and also in this case we for the attack

563
00:21:29,280 --> 00:21:31,039
detector we activated all the three

564
00:21:31,039 --> 00:21:34,400
plugins that i explained before

565
00:21:34,559 --> 00:21:36,559
then after one week we check out we

566
00:21:36,559 --> 00:21:39,520
check the results so the users visited

567
00:21:39,520 --> 00:21:40,720
more than

568
00:21:40,720 --> 00:21:42,000
400

569
00:21:42,000 --> 00:21:44,400
different websites

570
00:21:44,400 --> 00:21:46,559
the attack detector has been activated

571
00:21:46,559 --> 00:21:48,640
more than fifty times with an average of

572
00:21:48,640 --> 00:21:50,720
eight times per day

573
00:21:50,720 --> 00:21:52,159
interestingly we know this i mean

574
00:21:52,159 --> 00:21:54,799
surprisingly we noticed that we had 12

575
00:21:54,799 --> 00:21:56,799
hollers on pages that at the end were

576
00:21:56,799 --> 00:21:59,280
benign so these are real i mean false

577
00:21:59,280 --> 00:22:00,480
positives

578
00:22:00,480 --> 00:22:03,200
and we investigated this issue and we

579
00:22:03,200 --> 00:22:05,039
discovered that it was related to the

580
00:22:05,039 --> 00:22:07,679
data spraying detector plugin

581
00:22:07,679 --> 00:22:10,559
and then we performed again experiments

582
00:22:10,559 --> 00:22:12,720
by improving this plugin

583
00:22:12,720 --> 00:22:13,760
uh

584
00:22:13,760 --> 00:22:16,559
the plugin was only checking the

585
00:22:16,559 --> 00:22:18,720
the code of the the frequency of the

586
00:22:18,720 --> 00:22:20,720
code pointers we are we perform an

587
00:22:20,720 --> 00:22:23,520
additional check if these code pointers

588
00:22:23,520 --> 00:22:27,679
uh basically uh contains a rope gadget

589
00:22:27,679 --> 00:22:29,520
and in this way we filter out

590
00:22:29,520 --> 00:22:30,880
these

591
00:22:30,880 --> 00:22:32,640
these false positives so the important

592
00:22:32,640 --> 00:22:35,840
part here is to understand that

593
00:22:35,840 --> 00:22:40,080
the plugins can be improved a lot

594
00:22:40,080 --> 00:22:41,679
as a conclusion

595
00:22:41,679 --> 00:22:44,000
uh here i present uh graffiti that is

596
00:22:44,000 --> 00:22:45,679
that is a

597
00:22:45,679 --> 00:22:48,320
framework that is a should be the first

598
00:22:48,320 --> 00:22:50,240
efficient and comprehensive solution to

599
00:22:50,240 --> 00:22:52,159
defeat any kind of possible spring

600
00:22:52,159 --> 00:22:53,679
implementation

601
00:22:53,679 --> 00:22:55,679
we i described

602
00:22:55,679 --> 00:22:57,120
the main idea of the micro

603
00:22:57,120 --> 00:22:58,480
virtualization

604
00:22:58,480 --> 00:23:00,880
so in order to create this kind of

605
00:23:00,880 --> 00:23:02,480
memory sandbox for a specific

606
00:23:02,480 --> 00:23:04,400
application and then most importantly we

607
00:23:04,400 --> 00:23:06,720
are releasing our tools as open source

608
00:23:06,720 --> 00:23:08,960
and you can download it from this

609
00:23:08,960 --> 00:23:12,159
website uh feel free to try it through i

610
00:23:12,159 --> 00:23:14,799
mean send us your pull requests or i

611
00:23:14,799 --> 00:23:16,720
mean create your own plugins on top of

612
00:23:16,720 --> 00:23:19,200
our memory tracer and if you do it

613
00:23:19,200 --> 00:23:20,640
please let's keep

614
00:23:20,640 --> 00:23:23,360
let's stay in touch

615
00:23:23,360 --> 00:23:25,200
so that's all for me

616
00:23:25,200 --> 00:23:27,360
thanks for your attention and i'm open

617
00:23:27,360 --> 00:23:29,180
to any questions

618
00:23:29,180 --> 00:23:37,699
[Applause]

619
00:23:38,480 --> 00:23:39,919
no takers

620
00:23:39,919 --> 00:23:42,559
i have one for you um it seems to me

621
00:23:42,559 --> 00:23:45,440
that you're equating a process in an

622
00:23:45,440 --> 00:23:48,080
application in in your framework

623
00:23:48,080 --> 00:23:50,000
but some of the browsers i might have

624
00:23:50,000 --> 00:23:51,840
misunderstood this but browsers like

625
00:23:51,840 --> 00:23:53,600
chrome they have this multi-process

626
00:23:53,600 --> 00:23:54,880
architecture

627
00:23:54,880 --> 00:23:56,799
which seems to me that might look like

628
00:23:56,799 --> 00:23:59,679
multiple applications to you and if so

629
00:23:59,679 --> 00:24:02,559
could an adversary try to

630
00:24:02,559 --> 00:24:04,799
distribute his spring attempt over

631
00:24:04,799 --> 00:24:07,120
multiple taps which would have their own

632
00:24:07,120 --> 00:24:09,840
processes and and thereby go undetected

633
00:24:09,840 --> 00:24:11,360
yeah i mean for yeah for chrome

634
00:24:11,360 --> 00:24:13,120
expression should be i mean a little bit

635
00:24:13,120 --> 00:24:15,919
more different also with like also more

636
00:24:15,919 --> 00:24:18,240
modern browsers because now every tab is

637
00:24:18,240 --> 00:24:20,000
a single process so probably you should

638
00:24:20,000 --> 00:24:22,240
have to configure

639
00:24:22,240 --> 00:24:24,960
the system for these different process

640
00:24:24,960 --> 00:24:26,640
so this means that you

641
00:24:26,640 --> 00:24:28,000
with micro virtualization you are

642
00:24:28,000 --> 00:24:30,080
protecting all let's say all the

643
00:24:30,080 --> 00:24:31,600
different tabs

644
00:24:31,600 --> 00:24:33,919
but then the track again is on the

645
00:24:33,919 --> 00:24:35,120
single tab

646
00:24:35,120 --> 00:24:36,640
and then i mean there is a the same box

647
00:24:36,640 --> 00:24:39,279
so now all the modern browsers have a

648
00:24:39,279 --> 00:24:41,360
sandbox remember sandbox so then you

649
00:24:41,360 --> 00:24:43,039
have to escape from the sandbox and then

650
00:24:43,039 --> 00:24:46,000
you have another attack so now even more

651
00:24:46,000 --> 00:24:47,760
chaining more attacks together in order

652
00:24:47,760 --> 00:24:50,080
to escape and then run code inside the

653
00:24:50,080 --> 00:24:51,520
operating system

654
00:24:51,520 --> 00:24:53,919
i understand but let's say that for a

655
00:24:53,919 --> 00:24:56,720
given given amount of data you have

656
00:24:56,720 --> 00:25:00,000
x percent a success rate if i then spray

657
00:25:00,000 --> 00:25:03,039
a tenth of that in 10 10 taps i might go

658
00:25:03,039 --> 00:25:05,440
below your threshold but viewed across

659
00:25:05,440 --> 00:25:07,360
the tab the same likelihood of

660
00:25:07,360 --> 00:25:10,639
succeeding with my exploit

661
00:25:11,600 --> 00:25:13,279
but every tab is a different process

662
00:25:13,279 --> 00:25:15,760
right yes but only one of them has to

663
00:25:15,760 --> 00:25:17,279
successfully exploit

664
00:25:17,279 --> 00:25:19,520
the process yeah but okay yeah of course

665
00:25:19,520 --> 00:25:22,159
but i can tune i mean you can tune the

666
00:25:22,159 --> 00:25:23,760
the interesting part of our system that

667
00:25:23,760 --> 00:25:25,600
you can tune the

668
00:25:25,600 --> 00:25:28,559
threshold right so basically if

669
00:25:28,559 --> 00:25:30,559
if you put a lower

670
00:25:30,559 --> 00:25:31,919
if you're a little really paranoid and

671
00:25:31,919 --> 00:25:33,360
you mean and

672
00:25:33,360 --> 00:25:34,320
in the world there are this kind of

673
00:25:34,320 --> 00:25:36,559
attacks what you can do is to lower the

674
00:25:36,559 --> 00:25:39,279
threshold so in this way i mean you have

675
00:25:39,279 --> 00:25:41,919
a little bit uh

676
00:25:41,919 --> 00:25:44,480
more higher overhead of course but you

677
00:25:44,480 --> 00:25:45,679
are protected

678
00:25:45,679 --> 00:25:48,080
right right

679
00:25:48,080 --> 00:25:50,880
um just kind of a follow-up on that if

680
00:25:50,880 --> 00:25:52,400
uh the

681
00:25:52,400 --> 00:25:54,799
overhead that required using separate

682
00:25:54,799 --> 00:25:58,000
eptp pointers for every process

683
00:25:58,000 --> 00:25:59,520
had to do with

684
00:25:59,520 --> 00:26:02,880
the shared pages between processes

685
00:26:02,880 --> 00:26:07,200
wouldn't a browser that's opening

686
00:26:07,200 --> 00:26:08,320
or

687
00:26:08,320 --> 00:26:10,480
the turning of every tab in a separate

688
00:26:10,480 --> 00:26:11,600
process

689
00:26:11,600 --> 00:26:14,880
reintroduced that overhead even with um

690
00:26:14,880 --> 00:26:18,640
having a separate ebtp for every tab

691
00:26:18,640 --> 00:26:21,039
no i mean what we notice is that if we

692
00:26:21,039 --> 00:26:23,440
were using only one apt we added these

693
00:26:23,440 --> 00:26:25,039
huge overheads so we try to debug

694
00:26:25,039 --> 00:26:27,120
investigate a lot this issue

695
00:26:27,120 --> 00:26:29,039
and is probably related to the shared

696
00:26:29,039 --> 00:26:30,960
pages

697
00:26:30,960 --> 00:26:31,679
but

698
00:26:31,679 --> 00:26:33,039
most interesting probably something

699
00:26:33,039 --> 00:26:36,480
related to some optimization on the

700
00:26:36,480 --> 00:26:38,960
memory subsystem inside the kernel

701
00:26:38,960 --> 00:26:40,000
okay

702
00:26:40,000 --> 00:26:40,880
so

703
00:26:40,880 --> 00:26:42,799
and then what we noticed is that if we

704
00:26:42,799 --> 00:26:44,960
were creating

705
00:26:44,960 --> 00:26:46,400
more

706
00:26:46,400 --> 00:26:47,360
say

707
00:26:47,360 --> 00:26:49,760
more apt for the different process that

708
00:26:49,760 --> 00:26:50,840
we are

709
00:26:50,840 --> 00:26:54,640
monitoring we were filtering out

710
00:26:54,640 --> 00:26:56,799
the huge part of this overhead that

711
00:26:56,799 --> 00:26:58,880
software was related to some shared

712
00:26:58,880 --> 00:27:00,320
pages between the user application and

713
00:27:00,320 --> 00:27:01,600
the kernel

714
00:27:01,600 --> 00:27:02,799
but it's something that i mean for the

715
00:27:02,799 --> 00:27:04,320
future work we are still investigating

716
00:27:04,320 --> 00:27:05,279
because

717
00:27:05,279 --> 00:27:07,279
uh you know

718
00:27:07,279 --> 00:27:09,679
it's it's something that for us was just

719
00:27:09,679 --> 00:27:10,960
a shared page

720
00:27:10,960 --> 00:27:13,520
okay but then you were asking about uh

721
00:27:13,520 --> 00:27:13,900
um

722
00:27:13,900 --> 00:27:15,039
[Music]

723
00:27:15,039 --> 00:27:16,480
your question was in two points right

724
00:27:16,480 --> 00:27:19,039
one about the overhead uh of the

725
00:27:19,039 --> 00:27:21,120
interference problem and the other part

726
00:27:21,120 --> 00:27:24,640
can you rephrase please is uh

727
00:27:24,640 --> 00:27:26,799
if

728
00:27:26,799 --> 00:27:27,600
so

729
00:27:27,600 --> 00:27:28,960
there's still going to be

730
00:27:28,960 --> 00:27:31,279
uh

731
00:27:31,440 --> 00:27:33,279
it seems like the colonel would still

732
00:27:33,279 --> 00:27:35,200
have to do a lot of extra work that

733
00:27:35,200 --> 00:27:36,640
would get caught

734
00:27:36,640 --> 00:27:38,240
on a

735
00:27:38,240 --> 00:27:41,360
forked or copied

736
00:27:41,440 --> 00:27:44,480
process from the

737
00:27:44,880 --> 00:27:47,279
from the brow from the original browser

738
00:27:47,279 --> 00:27:48,720
process

739
00:27:48,720 --> 00:27:50,799
and it seems like that

740
00:27:50,799 --> 00:27:53,200
work would be the same as the overhead

741
00:27:53,200 --> 00:27:54,740
that you would see

742
00:27:54,740 --> 00:27:56,799
[Music]

743
00:27:56,799 --> 00:27:59,279
using just the single

744
00:27:59,279 --> 00:28:03,120
eptp because it's the same uh

745
00:28:03,120 --> 00:28:05,360
page table rec page table entries that

746
00:28:05,360 --> 00:28:06,480
have to get

747
00:28:06,480 --> 00:28:08,320
uh amended

748
00:28:08,320 --> 00:28:10,240
because they were copy on right and now

749
00:28:10,240 --> 00:28:11,600
they're

750
00:28:11,600 --> 00:28:14,320
uh being changed for the new process

751
00:28:14,320 --> 00:28:16,159
yeah that's one of the points something

752
00:28:16,159 --> 00:28:17,760
that we were investigating for the

753
00:28:17,760 --> 00:28:19,760
future work well what we're trying to do

754
00:28:19,760 --> 00:28:23,279
is just to do an apt only for the kernel

755
00:28:23,279 --> 00:28:25,440
and monitor what's only happening for

756
00:28:25,440 --> 00:28:26,799
the candle because what we don't have

757
00:28:26,799 --> 00:28:29,919
clear at this point is i mean why

758
00:28:29,919 --> 00:28:32,880
sometimes the world is getting so high

759
00:28:32,880 --> 00:28:34,000
okay

760
00:28:34,000 --> 00:28:35,279
it's something that we are i mean

761
00:28:35,279 --> 00:28:37,039
actively investigating

762
00:28:37,039 --> 00:28:39,360
and if you probably will check out the

763
00:28:39,360 --> 00:28:40,320
github

764
00:28:40,320 --> 00:28:42,080
hopefully we are gonna commit something

765
00:28:42,080 --> 00:28:43,039
soon

766
00:28:43,039 --> 00:28:44,880
okay

767
00:28:44,880 --> 00:28:46,960
i have another question um

768
00:28:46,960 --> 00:28:49,760
so the vm func instruction um

769
00:28:49,760 --> 00:28:52,960
that allows a

770
00:28:53,200 --> 00:28:56,480
guest to request a specific eptp

771
00:28:56,480 --> 00:28:58,880
i believe that uh

772
00:28:58,880 --> 00:29:00,159
runs

773
00:29:00,159 --> 00:29:02,240
in ring three so it's an unprivileged uh

774
00:29:02,240 --> 00:29:05,360
command did you do any tests to see if

775
00:29:05,360 --> 00:29:07,440
you had a piece of shell code that just

776
00:29:07,440 --> 00:29:09,039
kind of sprayed

777
00:29:09,039 --> 00:29:10,799
uh vm funk

778
00:29:10,799 --> 00:29:13,919
um would it crash the

779
00:29:13,919 --> 00:29:15,760
just i mean that's an interesting point

780
00:29:15,760 --> 00:29:17,360
no we didn't do it but it is something

781
00:29:17,360 --> 00:29:19,360
that it could be really interesting to

782
00:29:19,360 --> 00:29:21,039
do

783
00:29:21,039 --> 00:29:22,399
which what

784
00:29:22,399 --> 00:29:24,559
part of the system crashes when you do

785
00:29:24,559 --> 00:29:25,520
that

786
00:29:25,520 --> 00:29:26,880
yeah well

787
00:29:26,880 --> 00:29:28,720
most probably yeah

788
00:29:28,720 --> 00:29:29,919
thanks for your point it's something

789
00:29:29,919 --> 00:29:31,279
that we're gonna do

790
00:29:31,279 --> 00:29:33,039
all right let's close the session by

791
00:29:33,039 --> 00:29:37,399
thanking all the speakers one last time

792
00:29:38,980 --> 00:29:42,930
[Applause]

793
00:29:44,880 --> 00:29:46,960
you

