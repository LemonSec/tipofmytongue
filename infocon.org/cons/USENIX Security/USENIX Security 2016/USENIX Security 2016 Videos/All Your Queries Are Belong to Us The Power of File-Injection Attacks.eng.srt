1
00:00:10,240 --> 00:00:12,559
hello everyone i'm ivan zhang from the

2
00:00:12,559 --> 00:00:14,799
university of maryland

3
00:00:14,799 --> 00:00:17,359
today i'm going to talk about our work

4
00:00:17,359 --> 00:00:20,480
on attacks for social encryption

5
00:00:20,480 --> 00:00:22,640
this is a joint work with my advisors

6
00:00:22,640 --> 00:00:26,560
jonathan cass and bobby's papamento

7
00:00:26,960 --> 00:00:29,439
so here's the agenda of my talk

8
00:00:29,439 --> 00:00:30,880
first i'll go through some background

9
00:00:30,880 --> 00:00:32,640
knowledge on search of encryption and

10
00:00:32,640 --> 00:00:34,559
then present our tags

11
00:00:34,559 --> 00:00:36,880
after that i will show some experimental

12
00:00:36,880 --> 00:00:40,640
results of our tags and conclude my talk

13
00:00:40,640 --> 00:00:43,040
so let's get started

14
00:00:43,040 --> 00:00:45,120
uh i'm sure nowadays everybody's using

15
00:00:45,120 --> 00:00:47,680
email systems which means

16
00:00:47,680 --> 00:00:49,680
we host our emails on the server side

17
00:00:49,680 --> 00:00:51,840
and the server has access to the plain

18
00:00:51,840 --> 00:00:54,640
text of our emails

19
00:00:54,640 --> 00:00:55,840
so

20
00:00:55,840 --> 00:00:58,239
privacy becomes a major concern how to

21
00:00:58,239 --> 00:01:00,239
guarantee the privacy of our emails

22
00:01:00,239 --> 00:01:03,199
there are email breaches in real life

23
00:01:03,199 --> 00:01:05,040
happening

24
00:01:05,040 --> 00:01:07,119
recently

25
00:01:07,119 --> 00:01:08,720
so

26
00:01:08,720 --> 00:01:12,080
obviously we can encrypt our emails

27
00:01:12,080 --> 00:01:14,080
before sending them to the server

28
00:01:14,080 --> 00:01:16,560
but then the problem becomes how can the

29
00:01:16,560 --> 00:01:18,320
server still search

30
00:01:18,320 --> 00:01:21,919
on the encrypted emails for you

31
00:01:22,240 --> 00:01:24,080
to solve this problem here comes search

32
00:01:24,080 --> 00:01:26,240
of encryption

33
00:01:26,240 --> 00:01:28,880
searchable encryption is a crypto scheme

34
00:01:28,880 --> 00:01:30,079
that allows

35
00:01:30,079 --> 00:01:32,240
a client to encrypt

36
00:01:32,240 --> 00:01:34,640
his files and in the meantime generate

37
00:01:34,640 --> 00:01:36,960
some metadata and upload both of them to

38
00:01:36,960 --> 00:01:40,079
the server side

39
00:01:40,079 --> 00:01:42,240
and later the client can issue an

40
00:01:42,240 --> 00:01:45,040
encrypted search query for public for

41
00:01:45,040 --> 00:01:47,280
particular keywords which we call it in

42
00:01:47,280 --> 00:01:49,600
this talk as a search token

43
00:01:49,600 --> 00:01:51,280
and with the help of this token and the

44
00:01:51,280 --> 00:01:54,399
metadata the server is able to return

45
00:01:54,399 --> 00:01:56,560
only those files that contain this

46
00:01:56,560 --> 00:01:58,560
keyword but nothing else

47
00:01:58,560 --> 00:02:00,719
and the security of social encryption

48
00:02:00,719 --> 00:02:04,399
guarantees that for a semi-honest server

49
00:02:04,399 --> 00:02:06,560
cannot learn anything about the

50
00:02:06,560 --> 00:02:09,280
underlying content of the files or the

51
00:02:09,280 --> 00:02:13,200
underlying keyword of the search token

52
00:02:13,520 --> 00:02:15,520
since its invention search of encryption

53
00:02:15,520 --> 00:02:18,640
has a lot of applications in practice

54
00:02:18,640 --> 00:02:20,319
for example there are

55
00:02:20,319 --> 00:02:22,640
products of encrypted storage like sky

56
00:02:22,640 --> 00:02:24,800
high networks and cyber cloud and there

57
00:02:24,800 --> 00:02:27,120
are also developments of encrypted email

58
00:02:27,120 --> 00:02:28,720
systems

59
00:02:28,720 --> 00:02:30,480
and the major reason

60
00:02:30,480 --> 00:02:33,840
uh of its popularity is because

61
00:02:33,840 --> 00:02:37,519
social encryption is very efficient

62
00:02:37,519 --> 00:02:39,440
social encryption only use the simple

63
00:02:39,440 --> 00:02:41,519
symmetric key encryptions and hashes

64
00:02:41,519 --> 00:02:44,319
such such that the crypto operations are

65
00:02:44,319 --> 00:02:46,239
usually not the bottleneck and the

66
00:02:46,239 --> 00:02:48,720
overhead compared to plain text search

67
00:02:48,720 --> 00:02:51,920
is a quite small

68
00:02:51,920 --> 00:02:54,319
however this efficiency

69
00:02:54,319 --> 00:02:57,599
comes at a price of leakage

70
00:02:57,599 --> 00:03:00,239
for example going back to the

71
00:03:00,239 --> 00:03:02,239
figure i showed you before

72
00:03:02,239 --> 00:03:03,360
first

73
00:03:03,360 --> 00:03:05,840
although this search query is encrypted

74
00:03:05,840 --> 00:03:08,000
but it's deterministic

75
00:03:08,000 --> 00:03:09,760
which means the server can learn when

76
00:03:09,760 --> 00:03:12,159
the same query repeats

77
00:03:12,159 --> 00:03:15,280
this is called search pattern leakage

78
00:03:15,280 --> 00:03:16,959
second

79
00:03:16,959 --> 00:03:18,640
the server is hosting the encrypted

80
00:03:18,640 --> 00:03:20,400
files although they are encrypted the

81
00:03:20,400 --> 00:03:23,200
server knows exactly whether

82
00:03:23,200 --> 00:03:25,440
a particular file is returned as the

83
00:03:25,440 --> 00:03:28,080
search results result or not

84
00:03:28,080 --> 00:03:30,560
this is called file access pattern

85
00:03:30,560 --> 00:03:32,400
and for those who are familiar with the

86
00:03:32,400 --> 00:03:34,080
construction of search of encryption

87
00:03:34,080 --> 00:03:37,519
even if the metadata or the search index

88
00:03:37,519 --> 00:03:39,760
is hosted on the client side this file

89
00:03:39,760 --> 00:03:41,440
access pad is still leaked because the

90
00:03:41,440 --> 00:03:43,280
client still needs to curate the server

91
00:03:43,280 --> 00:03:46,239
for the for the files

92
00:03:46,239 --> 00:03:48,400
in addition in dynamic search

93
00:03:48,400 --> 00:03:50,879
encryptions

94
00:03:51,680 --> 00:03:54,080
in a scenario if the client has ever

95
00:03:54,080 --> 00:03:56,879
issued a search token before and later

96
00:03:56,879 --> 00:03:59,680
he wants to insert a new file into the

97
00:03:59,680 --> 00:04:01,519
file collection

98
00:04:01,519 --> 00:04:04,480
then the server can automatically tell

99
00:04:04,480 --> 00:04:06,959
whether this old keyword is in the new

100
00:04:06,959 --> 00:04:08,640
file or not

101
00:04:08,640 --> 00:04:10,720
or currently the server can search an

102
00:04:10,720 --> 00:04:14,560
old token on newly inserted files

103
00:04:14,560 --> 00:04:18,399
this is called no forward privacy

104
00:04:19,279 --> 00:04:21,120
so to sum up we have search pattern

105
00:04:21,120 --> 00:04:24,240
leakage access padded leakage

106
00:04:24,240 --> 00:04:25,919
they are leaked by all efficient

107
00:04:25,919 --> 00:04:27,199
surgical encryption schemes by

108
00:04:27,199 --> 00:04:28,400
definition

109
00:04:28,400 --> 00:04:31,919
and then we have no forward privacy

110
00:04:31,919 --> 00:04:33,840
all social encryption schemes except

111
00:04:33,840 --> 00:04:36,320
these three do not have forward privacy

112
00:04:36,320 --> 00:04:39,280
and actually the third one just

113
00:04:39,280 --> 00:04:40,400
comes out

114
00:04:40,400 --> 00:04:42,320
after our paper emphasize the importance

115
00:04:42,320 --> 00:04:44,320
of foreign privacy

116
00:04:44,320 --> 00:04:46,720
so here we are trying to abstract the

117
00:04:46,720 --> 00:04:49,040
leakage profile so that and utilize them

118
00:04:49,040 --> 00:04:52,160
in our attacks such that our attack

119
00:04:52,160 --> 00:04:54,639
attacks applied to all or most of search

120
00:04:54,639 --> 00:04:57,280
recruitment schemes instead of any

121
00:04:57,280 --> 00:05:00,880
particular construction

122
00:05:02,479 --> 00:05:04,320
so searchable encryption improves the

123
00:05:04,320 --> 00:05:07,520
security under this well-defined

124
00:05:07,520 --> 00:05:08,720
leakage

125
00:05:08,720 --> 00:05:11,759
but what information does this leakage

126
00:05:11,759 --> 00:05:13,440
review

127
00:05:13,440 --> 00:05:14,400
so

128
00:05:14,400 --> 00:05:15,680
probably there's some relationship

129
00:05:15,680 --> 00:05:17,840
between this leakage and the content of

130
00:05:17,840 --> 00:05:19,600
the files or the

131
00:05:19,600 --> 00:05:21,120
curious search

132
00:05:21,120 --> 00:05:22,880
but the practical meaning of this

133
00:05:22,880 --> 00:05:26,719
leakage is not well understood before

134
00:05:26,800 --> 00:05:30,479
so to answer this question in 2012

135
00:05:30,479 --> 00:05:31,919
israel medal

136
00:05:31,919 --> 00:05:34,400
initiated this line of work by proposing

137
00:05:34,400 --> 00:05:36,720
a curie recovery attacks namely an

138
00:05:36,720 --> 00:05:39,120
attack trying to recover the keyword

139
00:05:39,120 --> 00:05:41,360
under a search token

140
00:05:41,360 --> 00:05:44,160
later cash at all in 2015 proposed

141
00:05:44,160 --> 00:05:45,680
another hack with higher success

142
00:05:45,680 --> 00:05:47,680
probability

143
00:05:47,680 --> 00:05:50,160
but there's a big sampling

144
00:05:50,160 --> 00:05:52,800
in these two attacks they assume the

145
00:05:52,800 --> 00:05:54,720
server knows all the clients files in

146
00:05:54,720 --> 00:05:56,639
plain text and in the meantime the

147
00:05:56,639 --> 00:05:58,240
server is also hosting the encrypted

148
00:05:58,240 --> 00:06:01,120
version in search of encryption

149
00:06:01,120 --> 00:06:03,600
so this is could be potentially a big

150
00:06:03,600 --> 00:06:05,680
assumption in practice it's hard to

151
00:06:05,680 --> 00:06:07,039
get

152
00:06:07,039 --> 00:06:08,560
therefore in our paper the main

153
00:06:08,560 --> 00:06:10,080
contributions are

154
00:06:10,080 --> 00:06:12,319
we study another attack model called

155
00:06:12,319 --> 00:06:14,560
file injection attacks and this attack

156
00:06:14,560 --> 00:06:16,479
model is first first proposed in the

157
00:06:16,479 --> 00:06:19,360
cgpr15 paper but it's not used for pure

158
00:06:19,360 --> 00:06:21,440
recovery

159
00:06:21,440 --> 00:06:23,759
under this attack model we show that

160
00:06:23,759 --> 00:06:25,680
there exists attacks that significantly

161
00:06:25,680 --> 00:06:28,319
improve their success probability and

162
00:06:28,319 --> 00:06:30,880
eliminate or relax the client's file

163
00:06:30,880 --> 00:06:33,199
leakage assumption

164
00:06:33,199 --> 00:06:36,080
finally our task attacks can be extended

165
00:06:36,080 --> 00:06:38,000
to conjunctive search

166
00:06:38,000 --> 00:06:40,160
where the clients can ask for files

167
00:06:40,160 --> 00:06:41,759
containing two or more keywords

168
00:06:41,759 --> 00:06:44,319
simultaneously

169
00:06:44,319 --> 00:06:46,720
so with these results we suggest to

170
00:06:46,720 --> 00:06:49,840
reduce or eliminate the leakage in

171
00:06:49,840 --> 00:06:51,919
social encryption instead of accepting

172
00:06:51,919 --> 00:06:55,359
them by defaulting definitions

173
00:06:56,880 --> 00:06:58,880
before going into details of our attacks

174
00:06:58,880 --> 00:07:01,199
i want to emphasize the attack target

175
00:07:01,199 --> 00:07:03,759
the curious so why curry privacy is

176
00:07:03,759 --> 00:07:05,680
important

177
00:07:05,680 --> 00:07:07,680
in the practical point of view

178
00:07:07,680 --> 00:07:09,280
first keywords are just parts of the

179
00:07:09,280 --> 00:07:11,680
files they are extracted from the files

180
00:07:11,680 --> 00:07:13,520
and it's shown before that if the server

181
00:07:13,520 --> 00:07:15,360
knows enough keywords the file content

182
00:07:15,360 --> 00:07:17,120
can be recovered

183
00:07:17,120 --> 00:07:19,280
second keywords can also be used to

184
00:07:19,280 --> 00:07:22,479
classify files so that with this attack

185
00:07:22,479 --> 00:07:24,560
the server can identify those files with

186
00:07:24,560 --> 00:07:26,800
sensitive keywords and this may help to

187
00:07:26,800 --> 00:07:29,120
launch other attacks

188
00:07:29,120 --> 00:07:32,319
in the theoretical aspect

189
00:07:32,319 --> 00:07:34,160
query privacy is intended to be

190
00:07:34,160 --> 00:07:35,599
guaranteed

191
00:07:35,599 --> 00:07:37,280
by social encryption

192
00:07:37,280 --> 00:07:38,160
and

193
00:07:38,160 --> 00:07:39,759
if there exists

194
00:07:39,759 --> 00:07:42,800
query recover recovery attacks utilizing

195
00:07:42,800 --> 00:07:45,120
the leakage there might be unexpected

196
00:07:45,120 --> 00:07:46,560
vulnerability

197
00:07:46,560 --> 00:07:48,479
if search of encryption is used as a

198
00:07:48,479 --> 00:07:51,919
building block for a larger system

199
00:07:52,560 --> 00:07:55,199
so with that said i'm ready to present

200
00:07:55,199 --> 00:07:56,560
our attacks

201
00:07:56,560 --> 00:07:58,639
so first the tech model file injection

202
00:07:58,639 --> 00:08:00,160
attack

203
00:08:00,160 --> 00:08:02,639
so again imagine the case of an

204
00:08:02,639 --> 00:08:05,840
encrypted email system

205
00:08:05,840 --> 00:08:07,039
a client

206
00:08:07,039 --> 00:08:09,360
encrypts all of his emails under the

207
00:08:09,360 --> 00:08:11,440
social encryption scheme

208
00:08:11,440 --> 00:08:13,039
and host it on a server

209
00:08:13,039 --> 00:08:15,199
but as it's an email system

210
00:08:15,199 --> 00:08:17,520
the client has no way to prevent anyone

211
00:08:17,520 --> 00:08:19,280
from sending him emails

212
00:08:19,280 --> 00:08:20,160
so

213
00:08:20,160 --> 00:08:21,840
what if the server send one to the

214
00:08:21,840 --> 00:08:22,960
client

215
00:08:22,960 --> 00:08:24,840
as the client is using search of

216
00:08:24,840 --> 00:08:27,680
encryption he will encrypt process this

217
00:08:27,680 --> 00:08:29,199
email encrypted

218
00:08:29,199 --> 00:08:31,759
and send it back to the server side so

219
00:08:31,759 --> 00:08:33,679
now the server knows exactly this file

220
00:08:33,679 --> 00:08:34,880
is the one

221
00:08:34,880 --> 00:08:37,279
he just sent to the client and knows the

222
00:08:37,279 --> 00:08:39,039
underlying content

223
00:08:39,039 --> 00:08:41,039
so this is quite similar to the chosen

224
00:08:41,039 --> 00:08:45,120
plain text attack for encryption schemes

225
00:08:45,120 --> 00:08:47,680
and then later when the client issues a

226
00:08:47,680 --> 00:08:51,120
search query or a token

227
00:08:51,120 --> 00:08:53,920
from the file access pattern leakage the

228
00:08:53,920 --> 00:08:56,160
server can tell whether this injected

229
00:08:56,160 --> 00:08:59,600
file is in the search results or not

230
00:08:59,600 --> 00:09:03,839
so this is called file injection attack

231
00:09:03,839 --> 00:09:06,399
so to argue about the practicality of

232
00:09:06,399 --> 00:09:08,160
this attack model for email system is

233
00:09:08,160 --> 00:09:10,000
quite clear you cannot prevent anyone

234
00:09:10,000 --> 00:09:12,000
from sending your emails and even if the

235
00:09:12,000 --> 00:09:14,640
client has a legitimate list the server

236
00:09:14,640 --> 00:09:16,959
can simply spoof the email address of a

237
00:09:16,959 --> 00:09:20,560
legitimate user and launch this attack

238
00:09:20,560 --> 00:09:22,320
also in other scenarios where search of

239
00:09:22,320 --> 00:09:24,399
encryption is used to build a public

240
00:09:24,399 --> 00:09:26,640
database or public chatting room

241
00:09:26,640 --> 00:09:29,120
applications the server has the freedom

242
00:09:29,120 --> 00:09:31,760
to enter these applications as a regular

243
00:09:31,760 --> 00:09:34,640
user and to launch these attacks so

244
00:09:34,640 --> 00:09:36,240
there are various scenarios where this

245
00:09:36,240 --> 00:09:39,200
attack model is quite reasonable

246
00:09:39,200 --> 00:09:41,040
so under this attack model there's a

247
00:09:41,040 --> 00:09:43,600
quite easy attack

248
00:09:43,600 --> 00:09:46,240
if the server injects

249
00:09:46,240 --> 00:09:48,640
a file containing only one keyword in it

250
00:09:48,640 --> 00:09:51,040
and this file happens to be returned as

251
00:09:51,040 --> 00:09:53,200
the result of search token then this

252
00:09:53,200 --> 00:09:56,320
token must be that keyword

253
00:09:56,320 --> 00:09:57,440
so

254
00:09:57,440 --> 00:10:00,240
that's a naive version of the attack

255
00:10:00,240 --> 00:10:02,000
but in this naive version the server

256
00:10:02,000 --> 00:10:03,680
needs to inject a lot of emails

257
00:10:03,680 --> 00:10:05,600
containing one keyword each

258
00:10:05,600 --> 00:10:07,600
which is quite easy to detect to be

259
00:10:07,600 --> 00:10:08,800
detected

260
00:10:08,800 --> 00:10:10,959
so

261
00:10:11,279 --> 00:10:13,279
therefore we present a smarter way in

262
00:10:13,279 --> 00:10:16,959
our paper called binary search attack

263
00:10:16,959 --> 00:10:19,120
so let's say we have a well-defined

264
00:10:19,120 --> 00:10:21,040
universe of keywords which can be drawn

265
00:10:21,040 --> 00:10:23,360
from the dictionary or defined arbitrary

266
00:10:23,360 --> 00:10:24,720
by the server

267
00:10:24,720 --> 00:10:26,720
and then the server injects this this

268
00:10:26,720 --> 00:10:27,920
file

269
00:10:27,920 --> 00:10:30,079
containing half of the keywords in the

270
00:10:30,079 --> 00:10:31,440
universe

271
00:10:31,440 --> 00:10:33,839
and for example the second half as

272
00:10:33,839 --> 00:10:35,760
shown and shaded on a slide

273
00:10:35,760 --> 00:10:37,200
and then the server learns that this

274
00:10:37,200 --> 00:10:38,800
file is not in the search result of a

275
00:10:38,800 --> 00:10:39,760
token

276
00:10:39,760 --> 00:10:40,640
then

277
00:10:40,640 --> 00:10:42,480
it he knows that

278
00:10:42,480 --> 00:10:44,079
the keyword you search in the first is

279
00:10:44,079 --> 00:10:45,440
in the first half of the universe but

280
00:10:45,440 --> 00:10:46,880
not the second half

281
00:10:46,880 --> 00:10:48,640
right

282
00:10:48,640 --> 00:10:51,279
similarly if the server injects these

283
00:10:51,279 --> 00:10:52,880
two files

284
00:10:52,880 --> 00:10:55,440
and the search result is zero one zero

285
00:10:55,440 --> 00:10:57,040
which means only file two is in the

286
00:10:57,040 --> 00:11:00,240
search result but not file one three

287
00:11:00,240 --> 00:11:03,600
then the server can uniquely identifies

288
00:11:03,600 --> 00:11:06,160
the keyword the client search

289
00:11:06,160 --> 00:11:08,720
searches is a k2

290
00:11:08,720 --> 00:11:10,640
because only k2 can give you this access

291
00:11:10,640 --> 00:11:11,920
pattern

292
00:11:11,920 --> 00:11:13,839
and if you think about it it's actually

293
00:11:13,839 --> 00:11:16,240
the classical binary search and 0 1 0 is

294
00:11:16,240 --> 00:11:17,519
actually the binary representation of

295
00:11:17,519 --> 00:11:20,959
the index of the keyword in the universe

296
00:11:20,959 --> 00:11:23,200
so with this attack the server only

297
00:11:23,200 --> 00:11:24,800
needs to inject

298
00:11:24,800 --> 00:11:26,640
logarithmic many

299
00:11:26,640 --> 00:11:29,200
files in terms of the

300
00:11:29,200 --> 00:11:31,519
universe size or concretely only 14

301
00:11:31,519 --> 00:11:33,200
files for a universe of about 10 000

302
00:11:33,200 --> 00:11:34,959
keywords

303
00:11:34,959 --> 00:11:37,600
after that the server can recover all

304
00:11:37,600 --> 00:11:39,600
queries ever issued by the client with

305
00:11:39,600 --> 00:11:40,839
perfect

306
00:11:40,839 --> 00:11:43,519
accuracy furthermore this attack

307
00:11:43,519 --> 00:11:46,160
is we call non-adaptive these files can

308
00:11:46,160 --> 00:11:48,160
be generated and injected before seeing

309
00:11:48,160 --> 00:11:50,399
any queries and they apply for all the

310
00:11:50,399 --> 00:11:52,800
keywords

311
00:11:53,519 --> 00:11:55,600
and in this attack we only use file

312
00:11:55,600 --> 00:11:57,920
access pattern and as i mentioned before

313
00:11:57,920 --> 00:11:59,600
this universe can be defined by the

314
00:11:59,600 --> 00:12:01,279
server arbitrarily so if the server is

315
00:12:01,279 --> 00:12:03,279
only interested in a small subset of

316
00:12:03,279 --> 00:12:05,519
sensitive keywords he can further reduce

317
00:12:05,519 --> 00:12:07,920
the number of injected files

318
00:12:07,920 --> 00:12:10,160
so so far this attack is very powerful

319
00:12:10,160 --> 00:12:11,600
you can the server can recover

320
00:12:11,600 --> 00:12:12,800
everything with a small number of

321
00:12:12,800 --> 00:12:14,079
injector files

322
00:12:14,079 --> 00:12:15,920
we're done

323
00:12:15,920 --> 00:12:18,480
but not quite actually because there's a

324
00:12:18,480 --> 00:12:21,279
limitation of this attack

325
00:12:21,279 --> 00:12:22,720
so the observation is that those

326
00:12:22,720 --> 00:12:24,720
injected files are quite long

327
00:12:24,720 --> 00:12:27,200
each of the file needs to include half

328
00:12:27,200 --> 00:12:29,760
of the keywords in the universe

329
00:12:29,760 --> 00:12:32,079
which leads to a natural counter measure

330
00:12:32,079 --> 00:12:33,760
called threshold countermeasure on the

331
00:12:33,760 --> 00:12:35,200
file length

332
00:12:35,200 --> 00:12:37,839
the idea is what if the client

333
00:12:37,839 --> 00:12:40,079
filters all files that contain more than

334
00:12:40,079 --> 00:12:41,600
t keywords

335
00:12:41,600 --> 00:12:43,200
then the server can no longer inject

336
00:12:43,200 --> 00:12:44,880
those long files

337
00:12:44,880 --> 00:12:46,720
by filtering we don't mean delete those

338
00:12:46,720 --> 00:12:48,800
files it simply means that the client

339
00:12:48,800 --> 00:12:50,720
can simply index

340
00:12:50,720 --> 00:12:52,480
a subset of t keywords

341
00:12:52,480 --> 00:12:54,800
from a file that has more than key

342
00:12:54,800 --> 00:12:56,880
keywords

343
00:12:56,880 --> 00:12:59,279
so to test if this account measures

344
00:12:59,279 --> 00:13:01,920
reasonable we choose the iran that data

345
00:13:01,920 --> 00:13:04,240
sets which is the

346
00:13:04,240 --> 00:13:07,040
data set consists consisting of

347
00:13:07,040 --> 00:13:09,360
real-world emails obtained from a data

348
00:13:09,360 --> 00:13:11,760
breach and is used widely for research

349
00:13:11,760 --> 00:13:13,200
purposes

350
00:13:13,200 --> 00:13:16,320
under universe of 5000 keywords only 3

351
00:13:16,320 --> 00:13:19,040
of the files have more than 200 keywords

352
00:13:19,040 --> 00:13:20,880
which means if the client

353
00:13:20,880 --> 00:13:23,279
sets the threshold

354
00:13:23,279 --> 00:13:26,079
as 200 only three percent of regular

355
00:13:26,079 --> 00:13:28,320
files will be affected

356
00:13:28,320 --> 00:13:31,279
so this is a kind of good count measure

357
00:13:31,279 --> 00:13:32,720
and under this kind of measure the

358
00:13:32,720 --> 00:13:35,279
server cannot inject those long files

359
00:13:35,279 --> 00:13:38,240
what what can he do now

360
00:13:38,240 --> 00:13:39,360
the

361
00:13:39,360 --> 00:13:40,880
alternative is

362
00:13:40,880 --> 00:13:43,120
what if the server generates a new

363
00:13:43,120 --> 00:13:46,399
defines a new universe that is smaller

364
00:13:46,399 --> 00:13:50,320
or namely 2t of size 2t keywords

365
00:13:50,320 --> 00:13:52,880
and launch the binary search attack

366
00:13:52,880 --> 00:13:53,600
but

367
00:13:53,600 --> 00:13:56,160
if the server defines this new universe

368
00:13:56,160 --> 00:13:57,920
randomly

369
00:13:57,920 --> 00:13:59,680
and inject files based on this new

370
00:13:59,680 --> 00:14:02,720
universe then for a particular token is

371
00:14:02,720 --> 00:14:04,800
very unlikely this token is included in

372
00:14:04,800 --> 00:14:07,040
the new universe and the attack

373
00:14:07,040 --> 00:14:08,880
will fail

374
00:14:08,880 --> 00:14:10,639
so therefore

375
00:14:10,639 --> 00:14:14,480
we propose a smarter way to define this

376
00:14:14,480 --> 00:14:16,399
new universe

377
00:14:16,399 --> 00:14:18,160
relying on some actual information

378
00:14:18,160 --> 00:14:20,079
called partial file leakage which is

379
00:14:20,079 --> 00:14:22,800
actually exactly the same

380
00:14:22,800 --> 00:14:25,680
kind of assumption from two prior papers

381
00:14:25,680 --> 00:14:27,600
the server learns a portion of client's

382
00:14:27,600 --> 00:14:29,519
files in plain text

383
00:14:29,519 --> 00:14:31,760
and in practice these files could be

384
00:14:31,760 --> 00:14:34,480
obtained through announcement or alert

385
00:14:34,480 --> 00:14:39,120
emails broadcasted to a group of people

386
00:14:39,920 --> 00:14:42,480
so with this information the idea is

387
00:14:42,480 --> 00:14:44,959
that first we define a term frequency of

388
00:14:44,959 --> 00:14:47,440
a token or keyword as the total number

389
00:14:47,440 --> 00:14:50,639
of files containing it divided by the

390
00:14:50,639 --> 00:14:52,000
the total number of files in the file

391
00:14:52,000 --> 00:14:54,000
collection

392
00:14:54,000 --> 00:14:56,399
then for every keyword in the universe

393
00:14:56,399 --> 00:14:58,639
from the list files the server can

394
00:14:58,639 --> 00:15:01,600
calculate an estimated frequency

395
00:15:01,600 --> 00:15:03,680
denoted by f-star this is called

396
00:15:03,680 --> 00:15:06,240
estimated because the leaked files are a

397
00:15:06,240 --> 00:15:08,480
subset of the file collection

398
00:15:08,480 --> 00:15:10,800
on the other hand when seeing a token

399
00:15:10,800 --> 00:15:13,279
the server knows exactly how many files

400
00:15:13,279 --> 00:15:15,920
are returned in the search result so he

401
00:15:15,920 --> 00:15:19,199
knows the exact frequency of this token

402
00:15:19,199 --> 00:15:21,920
then based on the constraint that

403
00:15:21,920 --> 00:15:23,760
the estimated frequency should be

404
00:15:23,760 --> 00:15:26,399
somehow close to the exact frequency

405
00:15:26,399 --> 00:15:29,199
the server can based on this information

406
00:15:29,199 --> 00:15:33,120
to select a subset of 2d keywords as

407
00:15:33,120 --> 00:15:35,199
candidate universe

408
00:15:35,199 --> 00:15:37,360
and then launch the binary search attack

409
00:15:37,360 --> 00:15:39,920
on top of this candidate universe in

410
00:15:39,920 --> 00:15:42,399
this way all the injected files will be

411
00:15:42,399 --> 00:15:45,920
shorter than keyword t keywords each

412
00:15:45,920 --> 00:15:47,680
and later experiments will show that

413
00:15:47,680 --> 00:15:49,440
this attack works with very good

414
00:15:49,440 --> 00:15:52,000
probability

415
00:15:53,360 --> 00:15:55,360
okay to highlight some difference

416
00:15:55,360 --> 00:15:56,959
between this attack

417
00:15:56,959 --> 00:16:00,720
and the prior binary search attack first

418
00:16:00,720 --> 00:16:02,800
this attack is adaptive

419
00:16:02,800 --> 00:16:03,680
those

420
00:16:03,680 --> 00:16:06,160
injected files are generated targeting a

421
00:16:06,160 --> 00:16:08,320
particular token but it will not work

422
00:16:08,320 --> 00:16:10,320
for other tokens

423
00:16:10,320 --> 00:16:11,440
second

424
00:16:11,440 --> 00:16:13,680
this in order to get the exact frequency

425
00:16:13,680 --> 00:16:16,000
this token must be searched before and

426
00:16:16,000 --> 00:16:19,120
then the server injects those files and

427
00:16:19,120 --> 00:16:20,720
then get the search result on those

428
00:16:20,720 --> 00:16:22,560
injected files again

429
00:16:22,560 --> 00:16:24,639
which means the attack applies to social

430
00:16:24,639 --> 00:16:26,160
entrepreneur schemes with no forward

431
00:16:26,160 --> 00:16:28,639
privacy because here the server can

432
00:16:28,639 --> 00:16:30,160
simply search this old token on the

433
00:16:30,160 --> 00:16:32,639
newly injected files himself

434
00:16:32,639 --> 00:16:35,199
or this token must be searched twice

435
00:16:35,199 --> 00:16:37,440
before and after injection

436
00:16:37,440 --> 00:16:39,519
however as i mentioned before

437
00:16:39,519 --> 00:16:41,920
almost all social encryption schemes has

438
00:16:41,920 --> 00:16:45,279
no forward privacy so our attacks will

439
00:16:45,279 --> 00:16:48,079
apply to most of them

440
00:16:48,079 --> 00:16:49,600
finally the server does not always

441
00:16:49,600 --> 00:16:50,800
succeed

442
00:16:50,800 --> 00:16:52,720
if the estimated frequency is really far

443
00:16:52,720 --> 00:16:54,959
away from the exact frequency such that

444
00:16:54,959 --> 00:16:56,880
the keyword is not included in the

445
00:16:56,880 --> 00:16:59,199
candidate universe the attack fails

446
00:16:59,199 --> 00:17:01,040
but the very important property of our

447
00:17:01,040 --> 00:17:02,639
tag is that the server can determine

448
00:17:02,639 --> 00:17:04,480
whether attack fails

449
00:17:04,480 --> 00:17:06,160
because if none of the injected files

450
00:17:06,160 --> 00:17:07,520
are returned

451
00:17:07,520 --> 00:17:09,599
the attack simply does not work unless

452
00:17:09,599 --> 00:17:11,599
the server can relaunch the attack

453
00:17:11,599 --> 00:17:13,760
with the different candidate units

454
00:17:13,760 --> 00:17:15,280
this is not the case in the two prior

455
00:17:15,280 --> 00:17:16,880
papers

456
00:17:16,880 --> 00:17:19,599
the the attacks in the two prior papers

457
00:17:19,599 --> 00:17:20,240
will

458
00:17:20,240 --> 00:17:21,679
succeed with some probability but the

459
00:17:21,679 --> 00:17:23,760
server cannot tell whether it succeeds

460
00:17:23,760 --> 00:17:26,160
or not

461
00:17:26,720 --> 00:17:28,960
and we also have a more complicated

462
00:17:28,960 --> 00:17:30,840
algorithm targeting multiple tokens

463
00:17:30,840 --> 00:17:32,640
simultaneously and you can refer to our

464
00:17:32,640 --> 00:17:36,000
papers from for details

465
00:17:37,120 --> 00:17:38,960
so after presenting the attack

466
00:17:38,960 --> 00:17:40,720
algorithms i'm ready to show some

467
00:17:40,720 --> 00:17:42,559
experiments

468
00:17:42,559 --> 00:17:44,720
so for methodology we took the iran

469
00:17:44,720 --> 00:17:47,919
dataset with 30 000 emails in it

470
00:17:47,919 --> 00:17:50,160
and choose top 5 000 keywords with high

471
00:17:50,160 --> 00:17:52,080
frequency highest frequency at the

472
00:17:52,080 --> 00:17:54,799
universe just to compare with the prior

473
00:17:54,799 --> 00:17:58,720
two papers the settings are consistent

474
00:17:58,720 --> 00:18:00,720
recall that for our basic binary search

475
00:18:00,720 --> 00:18:02,080
attack we don't need to do any

476
00:18:02,080 --> 00:18:04,320
experiments as long as those files are

477
00:18:04,320 --> 00:18:05,440
injected

478
00:18:05,440 --> 00:18:08,240
the text works perfectly

479
00:18:08,240 --> 00:18:09,600
so here we show some experimental

480
00:18:09,600 --> 00:18:12,320
results for this uh advanced attacks

481
00:18:12,320 --> 00:18:14,240
under the threshold countermeasure but

482
00:18:14,240 --> 00:18:16,000
with some actual information from leaked

483
00:18:16,000 --> 00:18:17,280
files

484
00:18:17,280 --> 00:18:19,280
so here we are using this figure the

485
00:18:19,280 --> 00:18:21,919
x-axis is the percentage of leaked files

486
00:18:21,919 --> 00:18:23,919
obtained by the server in plain text and

487
00:18:23,919 --> 00:18:27,679
the y-axis is the accuracy of the attack

488
00:18:27,679 --> 00:18:29,520
this red line is the attack at the

489
00:18:29,520 --> 00:18:31,760
performance of the attack in cgpr 15

490
00:18:31,760 --> 00:18:32,640
paper

491
00:18:32,640 --> 00:18:35,600
as you can see if the server knows all

492
00:18:35,600 --> 00:18:36,559
the

493
00:18:36,559 --> 00:18:38,559
clients files in plain text the tags

494
00:18:38,559 --> 00:18:41,280
works pretty well but the performance

495
00:18:41,280 --> 00:18:43,760
drops dramatically as the server learns

496
00:18:43,760 --> 00:18:46,000
less

497
00:18:46,000 --> 00:18:48,080
on the contrary the blue line shows the

498
00:18:48,080 --> 00:18:50,320
performance of our attack even if the

499
00:18:50,320 --> 00:18:52,559
server learns only one percent of the

500
00:18:52,559 --> 00:18:54,559
client's files in plain text

501
00:18:54,559 --> 00:18:56,480
he still has a success for probability

502
00:18:56,480 --> 00:18:58,000
of 30 percent

503
00:18:58,000 --> 00:19:00,640
and the pro the accuracy approaches one

504
00:19:00,640 --> 00:19:02,720
quickly as the server learns more and

505
00:19:02,720 --> 00:19:04,799
also the server can

506
00:19:04,799 --> 00:19:07,280
know whether the attack succeeds or not

507
00:19:07,280 --> 00:19:08,000
and

508
00:19:08,000 --> 00:19:09,919
run the attack again to further increase

509
00:19:09,919 --> 00:19:12,559
the success probability

510
00:19:12,559 --> 00:19:14,640
and this performance is under a

511
00:19:14,640 --> 00:19:17,840
threshold of 200 keywords for each file

512
00:19:17,840 --> 00:19:19,360
and the number of injected files is

513
00:19:19,360 --> 00:19:21,600
always 9 files it's very reasonable in

514
00:19:21,600 --> 00:19:24,000
practice

515
00:19:24,000 --> 00:19:26,400
uh here i want to clarify that this is

516
00:19:26,400 --> 00:19:28,559
not a fully fair comparison because we

517
00:19:28,559 --> 00:19:30,640
are in different attack models but here

518
00:19:30,640 --> 00:19:33,520
i just want to show the effectiveness of

519
00:19:33,520 --> 00:19:36,400
our attack in this figure

520
00:19:36,400 --> 00:19:38,799
similarly here's the performance of

521
00:19:38,799 --> 00:19:41,039
attacks targeting multiple tokens

522
00:19:41,039 --> 00:19:43,440
and as you can see the

523
00:19:43,440 --> 00:19:46,080
accuracy is improved significantly and

524
00:19:46,080 --> 00:19:47,840
the number of injected files

525
00:19:47,840 --> 00:19:50,000
is always less or equal to 40 which is

526
00:19:50,000 --> 00:19:53,320
quite reasonable

527
00:19:54,880 --> 00:19:57,039
to prop to provide some insights why our

528
00:19:57,039 --> 00:19:59,280
attacks works better

529
00:19:59,280 --> 00:20:01,600
the two prior tags

530
00:20:01,600 --> 00:20:05,120
relies on the leaked files to build a

531
00:20:05,120 --> 00:20:06,640
frequency distribution of all the

532
00:20:06,640 --> 00:20:09,120
keywords and try to find the best match

533
00:20:09,120 --> 00:20:11,520
between the keywords and the tokens on

534
00:20:11,520 --> 00:20:13,600
the frequency information

535
00:20:13,600 --> 00:20:16,080
however this best mesh will soon be

536
00:20:16,080 --> 00:20:18,840
distorted but less files are

537
00:20:18,840 --> 00:20:23,039
leaked on the other hand our attacks

538
00:20:23,039 --> 00:20:25,039
use this information to rule out those

539
00:20:25,039 --> 00:20:26,880
bad meshes to rule out those keywords

540
00:20:26,880 --> 00:20:29,039
that are likely to be the

541
00:20:29,039 --> 00:20:31,039
the real keywords for the token

542
00:20:31,039 --> 00:20:33,120
and then search on the remaining ones so

543
00:20:33,120 --> 00:20:37,439
this improves the accuracy significantly

544
00:20:38,159 --> 00:20:39,840
also our attacks can be extended to

545
00:20:39,840 --> 00:20:41,600
conjunct the search and you can refer to

546
00:20:41,600 --> 00:20:44,959
our paper for details

547
00:20:45,520 --> 00:20:47,520
finally i want to discuss some potential

548
00:20:47,520 --> 00:20:49,600
countermeasures

549
00:20:49,600 --> 00:20:52,240
as in our attack

550
00:20:52,240 --> 00:20:53,120
for

551
00:20:53,120 --> 00:20:54,559
under the threshold countermeasure we

552
00:20:54,559 --> 00:20:56,240
are using the frequency information of

553
00:20:56,240 --> 00:20:56,960
the

554
00:20:56,960 --> 00:20:58,400
of the token

555
00:20:58,400 --> 00:21:00,799
a natural counter measure which is also

556
00:21:00,799 --> 00:21:03,360
proposed in both of the two papers

557
00:21:03,360 --> 00:21:04,400
before

558
00:21:04,400 --> 00:21:06,880
is called search result padding

559
00:21:06,880 --> 00:21:08,720
the idea is

560
00:21:08,720 --> 00:21:10,400
we want to pad the search result with

561
00:21:10,400 --> 00:21:12,640
some random files some raw files not

562
00:21:12,640 --> 00:21:14,960
containing the keyword such that

563
00:21:14,960 --> 00:21:16,960
multiple tokens will have the same exact

564
00:21:16,960 --> 00:21:19,440
frequency so in this way the exact

565
00:21:19,440 --> 00:21:21,360
frequency information will

566
00:21:21,360 --> 00:21:23,600
have a lot of noise in it

567
00:21:23,600 --> 00:21:25,760
and this will ruin the attack algorithms

568
00:21:25,760 --> 00:21:27,679
in the two private papers however we

569
00:21:27,679 --> 00:21:29,360
argue that this does not work at all

570
00:21:29,360 --> 00:21:31,120
against our attack

571
00:21:31,120 --> 00:21:33,280
because first we argue this does not

572
00:21:33,280 --> 00:21:35,120
affect the basic binary search attack

573
00:21:35,120 --> 00:21:36,480
because simply we don't rely on this

574
00:21:36,480 --> 00:21:38,000
information

575
00:21:38,000 --> 00:21:40,559
second it does not affect the advanced

576
00:21:40,559 --> 00:21:42,960
attacks you even if we use this

577
00:21:42,960 --> 00:21:45,520
information because no matter path or

578
00:21:45,520 --> 00:21:48,000
not closed frequencies are still closed

579
00:21:48,000 --> 00:21:49,600
and we still can use this information to

580
00:21:49,600 --> 00:21:53,120
rule out those bad matches

581
00:21:53,360 --> 00:21:56,000
to justify our argument

582
00:21:56,000 --> 00:21:57,919
we show some experiments first i want to

583
00:21:57,919 --> 00:21:59,919
define a parameter

584
00:21:59,919 --> 00:22:01,120
on padding

585
00:22:01,120 --> 00:22:03,600
called beta of a keyword k as the number

586
00:22:03,600 --> 00:22:06,080
of padded files for a cadillac keyword

587
00:22:06,080 --> 00:22:08,240
divided by the number of files in the

588
00:22:08,240 --> 00:22:10,240
original search result

589
00:22:10,240 --> 00:22:13,360
and then beta as the average of all beta

590
00:22:13,360 --> 00:22:14,159
case

591
00:22:14,159 --> 00:22:16,960
so intuitively if the data is larger you

592
00:22:16,960 --> 00:22:19,200
will pass more and more wrong files to

593
00:22:19,200 --> 00:22:21,440
the search results so this introduces a

594
00:22:21,440 --> 00:22:23,840
higher overhead on the communication but

595
00:22:23,840 --> 00:22:25,039
on the other hand it should be more

596
00:22:25,039 --> 00:22:27,679
secure

597
00:22:27,679 --> 00:22:29,600
but then this figure shows that as we

598
00:22:29,600 --> 00:22:31,280
increase beta

599
00:22:31,280 --> 00:22:34,320
our the performance of our attack is not

600
00:22:34,320 --> 00:22:36,080
affected that much

601
00:22:36,080 --> 00:22:38,880
we still can approach 90 of accuracy as

602
00:22:38,880 --> 00:22:41,120
the server learns more and more files

603
00:22:41,120 --> 00:22:43,120
and here's the performance

604
00:22:43,120 --> 00:22:46,320
under different data of the the of the

605
00:22:46,320 --> 00:22:49,679
attacks targeting multiple tokens

606
00:22:49,679 --> 00:22:51,280
on the contrary

607
00:22:51,280 --> 00:22:53,760
this slide shows the effect of the

608
00:22:53,760 --> 00:22:55,760
condom measure on the

609
00:22:55,760 --> 00:22:58,720
attacks in cgp 15 paper as you can see

610
00:22:58,720 --> 00:23:02,000
as beta approaches 0.6 the prior attack

611
00:23:02,000 --> 00:23:05,120
cannot recover anything at all but our

612
00:23:05,120 --> 00:23:09,440
attack is uh not affecting much

613
00:23:09,440 --> 00:23:10,720
so

614
00:23:10,720 --> 00:23:12,240
this shows that this quantum measure

615
00:23:12,240 --> 00:23:15,760
does not work against our attack

616
00:23:16,400 --> 00:23:17,120
to

617
00:23:17,120 --> 00:23:19,120
also list some other potential

618
00:23:19,120 --> 00:23:21,840
countermeasures recall that our attacks

619
00:23:21,840 --> 00:23:24,000
relies heavily on the attack model

620
00:23:24,000 --> 00:23:25,440
called file injection attacks where the

621
00:23:25,440 --> 00:23:27,600
server can identify which file is

622
00:23:27,600 --> 00:23:28,960
injected by him

623
00:23:28,960 --> 00:23:31,600
so in a static search of encryption

624
00:23:31,600 --> 00:23:33,919
the idea is what if we pad all the file

625
00:23:33,919 --> 00:23:36,480
to the same lens before after encryption

626
00:23:36,480 --> 00:23:38,640
so that the server cannot use this

627
00:23:38,640 --> 00:23:41,200
uniqueness of the lens to identify the

628
00:23:41,200 --> 00:23:43,760
files he injects

629
00:23:43,760 --> 00:23:46,720
because this partially works because

630
00:23:46,720 --> 00:23:48,480
first there's a

631
00:23:48,480 --> 00:23:51,039
large storage overhead if you do this

632
00:23:51,039 --> 00:23:52,880
for example in neural net set if you pad

633
00:23:52,880 --> 00:23:54,400
everything to maximum

634
00:23:54,400 --> 00:23:57,200
it introduces 1000 times overhead on

635
00:23:57,200 --> 00:23:58,799
storage

636
00:23:58,799 --> 00:24:01,039
second it only works for static search

637
00:24:01,039 --> 00:24:02,880
of encryption because in dynamic case

638
00:24:02,880 --> 00:24:04,480
the server can simply relies on the

639
00:24:04,480 --> 00:24:06,480
timing information to identify these

640
00:24:06,480 --> 00:24:08,640
injected files because the next file you

641
00:24:08,640 --> 00:24:10,159
upload to the server is the one he just

642
00:24:10,159 --> 00:24:12,559
sent to you

643
00:24:12,559 --> 00:24:15,200
therefore we further proposed a

644
00:24:15,200 --> 00:24:17,440
countermeasure called batched updates

645
00:24:17,440 --> 00:24:19,840
the clients should wait for several

646
00:24:19,840 --> 00:24:21,039
files

647
00:24:21,039 --> 00:24:23,039
pad them to the same lens and shuffle

648
00:24:23,039 --> 00:24:25,279
them before uploading them to the server

649
00:24:25,279 --> 00:24:26,799
so in this way the server cannot

650
00:24:26,799 --> 00:24:29,679
identify which one of them is the one he

651
00:24:29,679 --> 00:24:31,039
injects

652
00:24:31,039 --> 00:24:33,520
however this again

653
00:24:33,520 --> 00:24:35,840
is partially works because

654
00:24:35,840 --> 00:24:37,520
even the if the server repeats the

655
00:24:37,520 --> 00:24:39,360
original attack with one injected file

656
00:24:39,360 --> 00:24:40,640
per batch

657
00:24:40,640 --> 00:24:43,360
this still succeeds

658
00:24:43,360 --> 00:24:46,240
with a very tiny probability but this

659
00:24:46,240 --> 00:24:47,760
probability can be amplified

660
00:24:47,760 --> 00:24:50,320
exponentially by repeating one injected

661
00:24:50,320 --> 00:24:52,000
files many times

662
00:24:52,000 --> 00:24:54,799
so by injecting a little bit more files

663
00:24:54,799 --> 00:24:56,720
the attacks still succeed with very good

664
00:24:56,720 --> 00:24:59,279
probability

665
00:24:59,679 --> 00:25:02,559
so finally to conclude my talk

666
00:25:02,559 --> 00:25:05,039
we show that the file injection attacks

667
00:25:05,039 --> 00:25:06,799
are devastating for curate privacy in

668
00:25:06,799 --> 00:25:09,279
search of encryption and we start to

669
00:25:09,279 --> 00:25:12,080
question is that a satisfactory tradeoff

670
00:25:12,080 --> 00:25:14,159
between efficiency and the leakage for

671
00:25:14,159 --> 00:25:16,480
existing search of encryption schemes

672
00:25:16,480 --> 00:25:18,880
we may start to reconsider the

673
00:25:18,880 --> 00:25:21,279
definition of leakage profile instead of

674
00:25:21,279 --> 00:25:24,400
accepting them by default

675
00:25:24,400 --> 00:25:26,720
some potential future research direction

676
00:25:26,720 --> 00:25:29,600
is trying to reduce or eliminate the

677
00:25:29,600 --> 00:25:31,679
file access pattern leakage

678
00:25:31,679 --> 00:25:34,320
or to explore some

679
00:25:34,320 --> 00:25:36,720
new settings like multi-server schemes

680
00:25:36,720 --> 00:25:39,039
or interactive schemes

681
00:25:39,039 --> 00:25:40,880
finally forward privacy is a very

682
00:25:40,880 --> 00:25:42,400
important feature for search of

683
00:25:42,400 --> 00:25:44,720
encryption we are the first to show

684
00:25:44,720 --> 00:25:46,720
attacks that utilize this lack of

685
00:25:46,720 --> 00:25:49,039
forward privacy to improve the power of

686
00:25:49,039 --> 00:25:50,080
the attacks

687
00:25:50,080 --> 00:25:52,799
and we recommend future social

688
00:25:52,799 --> 00:25:55,279
increasing construction constructions to

689
00:25:55,279 --> 00:25:57,360
always include forward privacy as an

690
00:25:57,360 --> 00:25:59,679
important feature

691
00:25:59,679 --> 00:26:01,440
that's all from my talk thank you for

692
00:26:01,440 --> 00:26:04,440
listening

693
00:26:11,200 --> 00:26:13,279
you

