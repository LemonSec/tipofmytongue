1
00:00:10,880 --> 00:00:12,240
hello everyone

2
00:00:12,240 --> 00:00:14,559
thanks for attending my talk it will be

3
00:00:14,559 --> 00:00:16,000
about egalitarian computing by

4
00:00:16,000 --> 00:00:19,279
egalitarian so uh we with my author alex

5
00:00:19,279 --> 00:00:20,880
biruko far from western europe for

6
00:00:20,880 --> 00:00:23,119
university of luxembourg so the problem

7
00:00:23,119 --> 00:00:25,760
of uh doing egalitarian everything is

8
00:00:25,760 --> 00:00:26,640
very

9
00:00:26,640 --> 00:00:27,439
like

10
00:00:27,439 --> 00:00:29,519
prominent in western europe

11
00:00:29,519 --> 00:00:31,760
and this is about how computing should

12
00:00:31,760 --> 00:00:34,079
be equal for everyone why computing

13
00:00:34,079 --> 00:00:36,320
should be equal for everyone

14
00:00:36,320 --> 00:00:37,360
well because we are talking about

15
00:00:37,360 --> 00:00:39,520
attackers and defenders the problems

16
00:00:39,520 --> 00:00:41,600
with the comparing attackers and

17
00:00:41,600 --> 00:00:43,680
defenders is that attackers might always

18
00:00:43,680 --> 00:00:44,399
have

19
00:00:44,399 --> 00:00:46,399
been much more powerful they have more

20
00:00:46,399 --> 00:00:49,120
resources they are more viable and even

21
00:00:49,120 --> 00:00:51,520
one weakness is sufficient for a

22
00:00:51,520 --> 00:00:53,760
successful attack whereas uh

23
00:00:53,760 --> 00:00:55,760
defenders have to protect all of them

24
00:00:55,760 --> 00:00:57,920
and attackers can spend much more time

25
00:00:57,920 --> 00:01:00,640
so defenders are in a much weaker

26
00:01:00,640 --> 00:01:03,039
position and

27
00:01:03,039 --> 00:01:04,640
should

28
00:01:04,640 --> 00:01:06,320
spend more resources

29
00:01:06,320 --> 00:01:07,600
and

30
00:01:07,600 --> 00:01:09,680
we can of course as defenders can harden

31
00:01:09,680 --> 00:01:11,760
the protection for example increase the

32
00:01:11,760 --> 00:01:14,479
key length in the crystal systems we use

33
00:01:14,479 --> 00:01:16,960
and sometimes try to restrict the attack

34
00:01:16,960 --> 00:01:18,640
vector for example by limiting the

35
00:01:18,640 --> 00:01:20,799
exposure time of a web server so

36
00:01:20,799 --> 00:01:22,799
limiting the number of

37
00:01:22,799 --> 00:01:25,520
online password attacks but this uh

38
00:01:25,520 --> 00:01:27,520
doesn't always work

39
00:01:27,520 --> 00:01:29,280
for example well the secure

40
00:01:29,280 --> 00:01:30,880
cryptographic algorithm with the very

41
00:01:30,880 --> 00:01:33,520
sufficiently long key is a good solution

42
00:01:33,520 --> 00:01:35,600
for quite a lot of protocols but quite

43
00:01:35,600 --> 00:01:38,320
often we just don't have the keys we

44
00:01:38,320 --> 00:01:40,479
have to rely on such an imperfect

45
00:01:40,479 --> 00:01:44,399
mechanism as a human memory and uh

46
00:01:44,399 --> 00:01:46,799
human memory it can memorize mainly

47
00:01:46,799 --> 00:01:48,079
passwords the passwords are very

48
00:01:48,079 --> 00:01:49,520
important instruments

49
00:01:49,520 --> 00:01:50,240
but

50
00:01:50,240 --> 00:01:51,840
the passwords don't have very low

51
00:01:51,840 --> 00:01:54,240
entropy and as a result brute force

52
00:01:54,240 --> 00:01:56,719
attacks become possible for example uh

53
00:01:56,719 --> 00:01:59,680
attackers may try to guess a pin for

54
00:01:59,680 --> 00:02:03,680
a mobile phone or for a credit card

55
00:02:03,680 --> 00:02:05,520
the question is

56
00:02:05,520 --> 00:02:08,080
if we have some secret with very low

57
00:02:08,080 --> 00:02:11,360
entropy can we withstand attackers

58
00:02:11,360 --> 00:02:12,800
and the

59
00:02:12,800 --> 00:02:14,800
additional problem is that

60
00:02:14,800 --> 00:02:18,239
this slow entropy secrets are very much

61
00:02:18,239 --> 00:02:20,879
easier to break on special hardware so

62
00:02:20,879 --> 00:02:24,239
many people really underestimate the

63
00:02:24,239 --> 00:02:26,720
power of special hardware but on the

64
00:02:26,720 --> 00:02:29,440
example of bitcoin it's very clear that

65
00:02:29,440 --> 00:02:32,239
by using dedicated asics one can win up

66
00:02:32,239 --> 00:02:36,720
to like 30 000 factor in energy costs

67
00:02:36,720 --> 00:02:38,720
which is like the dominating

68
00:02:38,720 --> 00:02:41,200
of the total running cost of the attack

69
00:02:41,200 --> 00:02:43,519
this effectively means that if

70
00:02:43,519 --> 00:02:47,040
we use just a normal uh

71
00:02:47,040 --> 00:02:49,040
normal soft normal hardware like laptops

72
00:02:49,040 --> 00:02:51,200
or servers whereas attackers switch to

73
00:02:51,200 --> 00:02:55,040
asic our keys our passwords our pins

74
00:02:55,040 --> 00:02:57,599
effectively loses a lot of security keys

75
00:02:57,599 --> 00:03:00,319
lose 15 bits and passwords effectively

76
00:03:00,319 --> 00:03:03,040
become three lower case later shorter

77
00:03:03,040 --> 00:03:05,360
and pins if they are just of digits they

78
00:03:05,360 --> 00:03:06,959
lose five digits

79
00:03:06,959 --> 00:03:10,000
so we uh suspect that asic equipped

80
00:03:10,000 --> 00:03:11,599
attackers are the threat from the near

81
00:03:11,599 --> 00:03:14,000
future and we if we're going to protect

82
00:03:14,000 --> 00:03:14,800
uh

83
00:03:14,800 --> 00:03:17,120
from them we

84
00:03:17,120 --> 00:03:20,159
have to design some sort of proto set of

85
00:03:20,159 --> 00:03:22,239
protocols that would withstand potential

86
00:03:22,239 --> 00:03:25,280
regression of special hardware

87
00:03:25,280 --> 00:03:27,760
so and uh the problem is we have to slow

88
00:03:27,760 --> 00:03:29,680
down attackers without slowing down the

89
00:03:29,680 --> 00:03:30,879
defenders

90
00:03:30,879 --> 00:03:33,200
this means that we should use the

91
00:03:33,200 --> 00:03:36,400
features of x86 architecture or wherever

92
00:03:36,400 --> 00:03:39,519
the defense is going on uh in order to

93
00:03:39,519 --> 00:03:42,400
prohibit in order to make the switch to

94
00:03:42,400 --> 00:03:44,720
other architectures inefficient for

95
00:03:44,720 --> 00:03:46,239
attackers

96
00:03:46,239 --> 00:03:48,959
one of the solution popular since 2003

97
00:03:48,959 --> 00:03:50,400
is the use of memory intensive

98
00:03:50,400 --> 00:03:51,680
computations

99
00:03:51,680 --> 00:03:54,560
because uh when you or memory hard

100
00:03:54,560 --> 00:03:56,000
computations when you use a lot of

101
00:03:56,000 --> 00:03:58,640
memory because when you want to

102
00:03:58,640 --> 00:04:01,439
implement an algorithm that uses a lot

103
00:04:01,439 --> 00:04:03,760
of memory on this on a chip

104
00:04:03,760 --> 00:04:06,400
then uh quite big uh the very big

105
00:04:06,400 --> 00:04:08,319
proportion of area will be devoted to

106
00:04:08,319 --> 00:04:12,840
memory and chips will never no longer be

107
00:04:12,840 --> 00:04:15,680
as they will they will become much more

108
00:04:15,680 --> 00:04:17,918
expensive compared to just chips that

109
00:04:17,918 --> 00:04:19,918
implement the logic and with large

110
00:04:19,918 --> 00:04:21,759
memory on chip the asic advantage will

111
00:04:21,759 --> 00:04:23,280
effectively vanish

112
00:04:23,280 --> 00:04:25,919
the question is how to uh devise an

113
00:04:25,919 --> 00:04:27,919
algorithm that uses a lot of memory in

114
00:04:27,919 --> 00:04:30,560
irreducible way and how to

115
00:04:30,560 --> 00:04:32,240
um how to

116
00:04:32,240 --> 00:04:34,479
use this algorithm in many different

117
00:04:34,479 --> 00:04:36,240
protocols

118
00:04:36,240 --> 00:04:37,840
of course when we talk about the

119
00:04:37,840 --> 00:04:39,840
algorithms that use a lot of memory this

120
00:04:39,840 --> 00:04:42,400
amount of memory cannot be reduced

121
00:04:42,400 --> 00:04:43,919
an attacker shouldn't be able to compute

122
00:04:43,919 --> 00:04:46,400
the same thing with less memory at the

123
00:04:46,400 --> 00:04:48,560
same cost that's why we introduced the

124
00:04:48,560 --> 00:04:50,240
notion of well we use the notion of

125
00:04:50,240 --> 00:04:53,360
time-space trade-off meaning that if

126
00:04:53,360 --> 00:04:55,680
how much the computation time how much

127
00:04:55,680 --> 00:04:57,759
the accommodation complexity increases

128
00:04:57,759 --> 00:04:59,280
if we

129
00:04:59,280 --> 00:05:01,919
use less space and there can be

130
00:05:01,919 --> 00:05:03,840
different sorts of trade-offs linear

131
00:05:03,840 --> 00:05:06,000
trade-off means that time and space can

132
00:05:06,000 --> 00:05:08,320
be traded equally meaning that an

133
00:05:08,320 --> 00:05:10,800
adversary can use smaller chips but for

134
00:05:10,800 --> 00:05:12,720
longer time and efficiently you could

135
00:05:12,720 --> 00:05:14,400
save on the design cost so linear

136
00:05:14,400 --> 00:05:16,560
trade-offs are not

137
00:05:16,560 --> 00:05:18,400
desirable we need something better we

138
00:05:18,400 --> 00:05:20,720
need f to be super polynomial or even

139
00:05:20,720 --> 00:05:22,560
better

140
00:05:22,560 --> 00:05:25,280
so one some earlier works of using

141
00:05:25,280 --> 00:05:28,000
memory hard functions for

142
00:05:28,000 --> 00:05:30,160
uh increasing the security of practical

143
00:05:30,160 --> 00:05:32,639
protocols is one of our earlier design

144
00:05:32,639 --> 00:05:34,800
argon 2 the memory heart hash function

145
00:05:34,800 --> 00:05:36,080
the winner of password fashion

146
00:05:36,080 --> 00:05:38,320
competition so the idea is to when you

147
00:05:38,320 --> 00:05:40,720
hash passwords use as much memory as you

148
00:05:40,720 --> 00:05:43,680
can in an irreducible way and apparently

149
00:05:43,680 --> 00:05:46,080
after many investigations the time space

150
00:05:46,080 --> 00:05:48,960
trade-off is sort of exponential so

151
00:05:48,960 --> 00:05:51,680
when you reduce the space the so the

152
00:05:51,680 --> 00:05:55,199
logarithm of time is uh equally traded

153
00:05:55,199 --> 00:05:56,000
for

154
00:05:56,000 --> 00:05:57,919
the inverse of space

155
00:05:57,919 --> 00:06:00,080
so that the time increases exponential

156
00:06:00,080 --> 00:06:02,240
of the space reduction

157
00:06:02,240 --> 00:06:04,240
another example is the design of

158
00:06:04,240 --> 00:06:06,000
so-called aqua hash it's memory card

159
00:06:06,000 --> 00:06:08,000
proof of work so the proof of work you

160
00:06:08,000 --> 00:06:10,240
know from the previous talk on bitcoins

161
00:06:10,240 --> 00:06:12,000
the crucial feature of this proof of

162
00:06:12,000 --> 00:06:14,319
work is that even though for computing

163
00:06:14,319 --> 00:06:16,560
their proof you need a lot of memory to

164
00:06:16,560 --> 00:06:18,240
verify the proof you don't need a lot of

165
00:06:18,240 --> 00:06:20,479
memory it's asymmetric in this sense

166
00:06:20,479 --> 00:06:22,479
and with fast verification the idea

167
00:06:22,479 --> 00:06:25,840
inside is the generalized dirty problem

168
00:06:25,840 --> 00:06:29,039
exactly you need to find a solution to

169
00:06:29,039 --> 00:06:31,840
the truth of the cake soar by playing

170
00:06:31,840 --> 00:06:35,120
with different x1 x2 and so on which are

171
00:06:35,120 --> 00:06:36,720
all hashed and stored together you

172
00:06:36,720 --> 00:06:39,440
should get a zero string

173
00:06:39,440 --> 00:06:41,440
and interestingly that

174
00:06:41,440 --> 00:06:43,199
a proof that

175
00:06:43,199 --> 00:06:46,160
shows that you have used 700 megabytes

176
00:06:46,160 --> 00:06:48,880
is only 120 bytes long and

177
00:06:48,880 --> 00:06:51,360
takes about two seconds to find

178
00:06:51,360 --> 00:06:53,599
so interestingly but not the topic of

179
00:06:53,599 --> 00:06:55,840
our talk that almost any np complete

180
00:06:55,840 --> 00:06:57,599
problem is a good candidate for memory

181
00:06:57,599 --> 00:07:00,160
hard proof work

182
00:07:00,160 --> 00:07:02,240
the egalitarian computing concept is

183
00:07:02,240 --> 00:07:05,440
about using memory heart primitives in

184
00:07:05,440 --> 00:07:07,199
different areas

185
00:07:07,199 --> 00:07:09,039
because well

186
00:07:09,039 --> 00:07:11,039
the problem uh

187
00:07:11,039 --> 00:07:12,720
the word equalitarian comes from the

188
00:07:12,720 --> 00:07:15,759
original paper on bitcoin where it was

189
00:07:15,759 --> 00:07:17,840
dreamed that every user will be able to

190
00:07:17,840 --> 00:07:20,400
mine bitcoins on his own laptop this is

191
00:07:20,400 --> 00:07:23,120
apparently not the case the bitcoins are

192
00:07:23,120 --> 00:07:25,280
currently mined on the huge farms

193
00:07:25,280 --> 00:07:26,639
attached to

194
00:07:26,639 --> 00:07:28,000
uh

195
00:07:28,000 --> 00:07:29,039
he drop

196
00:07:29,039 --> 00:07:31,840
electric power plants or some places

197
00:07:31,840 --> 00:07:33,599
where you have cheap electricity and

198
00:07:33,599 --> 00:07:35,120
apparently only a bunch of people

199
00:07:35,120 --> 00:07:38,000
control a huge amount of mining power in

200
00:07:38,000 --> 00:07:40,160
the world

201
00:07:40,160 --> 00:07:41,360
so

202
00:07:41,360 --> 00:07:43,360
argon 2 made password hashing more

203
00:07:43,360 --> 00:07:45,280
secure but apparently with using a lot

204
00:07:45,280 --> 00:07:46,400
of memory

205
00:07:46,400 --> 00:07:48,960
you can make other protocols equally

206
00:07:48,960 --> 00:07:51,280
secure so

207
00:07:51,280 --> 00:07:53,440
for example or many password-based

208
00:07:53,440 --> 00:07:55,280
protocols like key agreement or secret

209
00:07:55,280 --> 00:07:57,360
sharing and password-based encryption

210
00:07:57,360 --> 00:07:59,919
can be made more secure proofs of work

211
00:07:59,919 --> 00:08:01,440
can be improved even compared to

212
00:08:01,440 --> 00:08:03,120
equihash

213
00:08:03,120 --> 00:08:04,560
if we use

214
00:08:04,560 --> 00:08:06,400
memory hard proofs of work because they

215
00:08:06,400 --> 00:08:08,639
will allow again

216
00:08:08,639 --> 00:08:11,120
users of regular laptops regular

217
00:08:11,120 --> 00:08:13,599
desktops to mine and be competitive on

218
00:08:13,599 --> 00:08:15,199
the market of

219
00:08:15,199 --> 00:08:18,479
cryptocurrencies even client puzzles for

220
00:08:18,479 --> 00:08:20,639
denial of service protection

221
00:08:20,639 --> 00:08:23,840
can use a lot of memory meaning that

222
00:08:23,840 --> 00:08:26,240
adversaries with special hardware cannot

223
00:08:26,240 --> 00:08:27,840
compute these client puzzles more

224
00:08:27,840 --> 00:08:29,280
efficiently than

225
00:08:29,280 --> 00:08:32,159
regular clients

226
00:08:32,159 --> 00:08:34,240
so the concept of a glittering computing

227
00:08:34,240 --> 00:08:36,399
ensures that legitimate users and

228
00:08:36,399 --> 00:08:38,559
attackers are equal

229
00:08:38,559 --> 00:08:40,399
because they effectively have to use the

230
00:08:40,399 --> 00:08:42,479
same platform well of course if you

231
00:08:42,479 --> 00:08:45,519
design a special asic that has

232
00:08:45,519 --> 00:08:47,360
some small computing core and a lot of

233
00:08:47,360 --> 00:08:49,519
memory you can make it very similar to

234
00:08:49,519 --> 00:08:51,519
the x86 architecture but then what's the

235
00:08:51,519 --> 00:08:53,760
point you can just use this regular

236
00:08:53,760 --> 00:08:55,200
laptop

237
00:08:55,200 --> 00:08:58,160
so the summer second advantage will

238
00:08:58,160 --> 00:09:00,240
be present still but it will be much

239
00:09:00,240 --> 00:09:02,480
much smaller advantage

240
00:09:02,480 --> 00:09:05,040
the idea of how we

241
00:09:05,040 --> 00:09:07,519
propose to implement this this concept

242
00:09:07,519 --> 00:09:10,080
in practice is that if you ever have a

243
00:09:10,080 --> 00:09:13,200
scheme uh where some

244
00:09:13,200 --> 00:09:15,440
exact output value is not that important

245
00:09:15,440 --> 00:09:18,399
for example you have encryption but the

246
00:09:18,399 --> 00:09:19,760
output of the encryption is not that

247
00:09:19,760 --> 00:09:21,839
important just important that uh the

248
00:09:21,839 --> 00:09:24,640
encryption scheme is secure um in some

249
00:09:24,640 --> 00:09:26,240
traditional sense of security like

250
00:09:26,240 --> 00:09:28,640
semantic security against the

251
00:09:28,640 --> 00:09:31,440
chosen platform or signature schemes

252
00:09:31,440 --> 00:09:32,560
where you can

253
00:09:32,560 --> 00:09:34,640
play a bit with the algorithms and still

254
00:09:34,640 --> 00:09:37,760
making it more secure then we propose to

255
00:09:37,760 --> 00:09:40,000
amalgamate this construction and augment

256
00:09:40,000 --> 00:09:41,680
it with adding

257
00:09:41,680 --> 00:09:44,320
argon 2 computation imperial or any

258
00:09:44,320 --> 00:09:45,839
other memory heart function whatever

259
00:09:45,839 --> 00:09:47,360
your favorite is

260
00:09:47,360 --> 00:09:50,000
the idea is if you already spend some

261
00:09:50,000 --> 00:09:52,640
cpu time for encryption for

262
00:09:52,640 --> 00:09:54,399
sign-in for verification of signatures

263
00:09:54,399 --> 00:09:57,519
why not use it uh for uh why not fill in

264
00:09:57,519 --> 00:09:59,440
the your why not working with the memory

265
00:09:59,440 --> 00:10:01,519
at the same time because it will bring

266
00:10:01,519 --> 00:10:03,279
the protocols additional security if

267
00:10:03,279 --> 00:10:05,360
they are trying to be broken on a

268
00:10:05,360 --> 00:10:07,519
special hardware

269
00:10:07,519 --> 00:10:10,079
for example on the top of this

270
00:10:10,079 --> 00:10:12,640
scheme you have well suppose we have

271
00:10:12,640 --> 00:10:14,800
some computation which undergoes a

272
00:10:14,800 --> 00:10:16,640
series of transformations like whatever

273
00:10:16,640 --> 00:10:18,320
transformation it's not hash function

274
00:10:18,320 --> 00:10:19,839
every transformation would work

275
00:10:19,839 --> 00:10:22,480
transformations h1 h2 like t different

276
00:10:22,480 --> 00:10:24,560
steps and the idea is that you compute a

277
00:10:24,560 --> 00:10:26,959
memory heart function

278
00:10:26,959 --> 00:10:29,920
at the top of it and you feed

279
00:10:29,920 --> 00:10:32,640
uh the out the intermediate values of

280
00:10:32,640 --> 00:10:35,200
the memory heart function its memory

281
00:10:35,200 --> 00:10:37,760
blocks into the computation

282
00:10:37,760 --> 00:10:40,880
and sort here and then effectively any

283
00:10:40,880 --> 00:10:43,279
adversary would try to repeat this

284
00:10:43,279 --> 00:10:45,200
protocol with different values of in and

285
00:10:45,200 --> 00:10:47,279
out so suppose he do some brute force

286
00:10:47,279 --> 00:10:50,079
guessing there he would have to compute

287
00:10:50,079 --> 00:10:51,920
this argument to function or any other

288
00:10:51,920 --> 00:10:54,480
memory heart function in parallel so any

289
00:10:54,480 --> 00:10:57,760
chip that computes uh this

290
00:10:57,760 --> 00:11:01,040
scheme would have to contain a lot of

291
00:11:01,040 --> 00:11:03,680
memory for this memory heart function to

292
00:11:03,680 --> 00:11:05,120
operate

293
00:11:05,120 --> 00:11:06,800
and

294
00:11:06,800 --> 00:11:08,560
this can be used in different

295
00:11:08,560 --> 00:11:10,640
environments for example you can compute

296
00:11:10,640 --> 00:11:12,640
memory hard you can obfuscate the

297
00:11:12,640 --> 00:11:15,120
computing by computing so-called memory

298
00:11:15,120 --> 00:11:17,360
hard bits

299
00:11:17,360 --> 00:11:20,240
when you

300
00:11:20,480 --> 00:11:22,560
when the

301
00:11:22,560 --> 00:11:25,040
original non-obfuscated

302
00:11:25,040 --> 00:11:28,720
branch statement is replaced by uh

303
00:11:28,720 --> 00:11:30,560
x sort some

304
00:11:30,560 --> 00:11:32,560
some bits which are the

305
00:11:32,560 --> 00:11:34,399
bits in the memory of a memory heart

306
00:11:34,399 --> 00:11:36,560
function

307
00:11:36,560 --> 00:11:38,959
another example a bit more interesting

308
00:11:38,959 --> 00:11:40,720
and from my point of view so called

309
00:11:40,720 --> 00:11:42,399
memory heart encryption

310
00:11:42,399 --> 00:11:43,200
so

311
00:11:43,200 --> 00:11:45,519
we look primarily at the disk encryption

312
00:11:45,519 --> 00:11:48,000
so quite some time uh when you encrypt

313
00:11:48,000 --> 00:11:50,240
your own hard drive

314
00:11:50,240 --> 00:11:52,880
you the there the key is derived from a

315
00:11:52,880 --> 00:11:55,120
password the idea is that you would be

316
00:11:55,120 --> 00:11:58,079
able to decrypt the hard drive even if

317
00:11:58,079 --> 00:12:00,240
you lose computational power if you just

318
00:12:00,240 --> 00:12:01,839
have the password in mind so you would

319
00:12:01,839 --> 00:12:04,399
be able to recover it the problem is

320
00:12:04,399 --> 00:12:06,480
that

321
00:12:06,480 --> 00:12:07,440
this

322
00:12:07,440 --> 00:12:09,120
encryption is

323
00:12:09,120 --> 00:12:10,720
and decryption

324
00:12:10,720 --> 00:12:12,720
doesn't uh take uh doesn't take any

325
00:12:12,720 --> 00:12:15,680
memory the idea is just the disk space

326
00:12:15,680 --> 00:12:18,560
is uh partitioned into chunks and every

327
00:12:18,560 --> 00:12:20,880
chunk is encrypted with a standard

328
00:12:20,880 --> 00:12:22,720
encryption algorithm say yes and the

329
00:12:22,720 --> 00:12:25,200
counter mode or the cbc mode or xts mode

330
00:12:25,200 --> 00:12:27,920
whatever and

331
00:12:27,920 --> 00:12:30,480
any attack uh suppose that bursary

332
00:12:30,480 --> 00:12:33,200
steals uh your hard drive then how would

333
00:12:33,200 --> 00:12:36,399
he try different passwords he would take

334
00:12:36,399 --> 00:12:38,959
passwords one two three four five uh

335
00:12:38,959 --> 00:12:41,279
compute derive a key from it and then

336
00:12:41,279 --> 00:12:43,440
try the ski for decryption he decrypts

337
00:12:43,440 --> 00:12:45,279
only a small block of data

338
00:12:45,279 --> 00:12:46,639
and

339
00:12:46,639 --> 00:12:49,040
and checks if the result in plain text

340
00:12:49,040 --> 00:12:51,680
has sufficient redundancy if he decrypts

341
00:12:51,680 --> 00:12:53,519
for example

342
00:12:53,519 --> 00:12:55,440
a word document or any other document

343
00:12:55,440 --> 00:12:57,440
that has redundancy

344
00:12:57,440 --> 00:12:59,120
the problem is that even if you use the

345
00:12:59,120 --> 00:13:01,360
memory heart function for key derivation

346
00:13:01,360 --> 00:13:04,000
there's this encryption keys can still

347
00:13:04,000 --> 00:13:06,240
be computed offline pre-computed for

348
00:13:06,240 --> 00:13:08,720
example on memory device but the trial

349
00:13:08,720 --> 00:13:11,440
decryption can be still doing memoryless

350
00:13:11,440 --> 00:13:16,079
by uh taking this pre-computed keys from

351
00:13:16,079 --> 00:13:17,680
other

352
00:13:17,680 --> 00:13:19,600
from other machine

353
00:13:19,600 --> 00:13:23,200
and our idea is uh where where we follow

354
00:13:23,200 --> 00:13:25,600
uh greg zavruha's earlier proposal from

355
00:13:25,600 --> 00:13:29,200
2015 is that not only the key should be

356
00:13:29,200 --> 00:13:30,800
derived from with the memory heart

357
00:13:30,800 --> 00:13:33,519
function but the encryption itself also

358
00:13:33,519 --> 00:13:34,720
should use

359
00:13:34,720 --> 00:13:37,839
as much memory as you could then if

360
00:13:37,839 --> 00:13:40,480
sufficient memory is used

361
00:13:40,480 --> 00:13:44,240
then uh trial decryption cannot be

362
00:13:44,240 --> 00:13:46,160
done without memory and then the

363
00:13:46,160 --> 00:13:48,880
adversary would have who would want to

364
00:13:48,880 --> 00:13:51,360
brute force passwords would have to do

365
00:13:51,360 --> 00:13:52,959
it on the same machine almost on the

366
00:13:52,959 --> 00:13:55,440
same machine where

367
00:13:55,440 --> 00:13:57,839
the cipher text is stored

368
00:13:57,839 --> 00:14:00,160
so the idea of

369
00:14:00,160 --> 00:14:02,079
gregor was to use the all or nothing

370
00:14:02,079 --> 00:14:04,959
transform by ronda best where the chunks

371
00:14:04,959 --> 00:14:07,120
uh

372
00:14:07,120 --> 00:14:09,120
the data chunks are decrypted are

373
00:14:09,120 --> 00:14:11,920
decryptable in two passes and for the

374
00:14:11,920 --> 00:14:13,760
second pass it must be fully decrypted

375
00:14:13,760 --> 00:14:15,440
and kept into memory

376
00:14:15,440 --> 00:14:18,240
and then the memory is inevitably bound

377
00:14:18,240 --> 00:14:20,399
to the chunk length

378
00:14:20,399 --> 00:14:23,839
our idea is to improve on it and use the

379
00:14:23,839 --> 00:14:25,360
memory heart

380
00:14:25,360 --> 00:14:27,600
function not only for the key generation

381
00:14:27,600 --> 00:14:29,360
but in the middle of the process of

382
00:14:29,360 --> 00:14:30,560
encryption

383
00:14:30,560 --> 00:14:32,880
to make the decryption run on some heart

384
00:14:32,880 --> 00:14:34,079
on the same hardware and being

385
00:14:34,079 --> 00:14:36,320
irreversible so you can see it on this

386
00:14:36,320 --> 00:14:37,279
picture

387
00:14:37,279 --> 00:14:38,320
so

388
00:14:38,320 --> 00:14:40,399
uh here at the top is the memory heart

389
00:14:40,399 --> 00:14:43,440
function that has been computed and

390
00:14:43,440 --> 00:14:47,120
here uh this m1 m2 are message blocks

391
00:14:47,120 --> 00:14:49,279
that are to be encrypted the idea is

392
00:14:49,279 --> 00:14:52,079
that you can you

393
00:14:52,079 --> 00:14:55,440
encrypt the con the memory blocks and

394
00:14:55,440 --> 00:14:58,800
use it uh on some random key and use it

395
00:14:58,800 --> 00:15:02,639
as the key stream encrypt the memo the

396
00:15:02,639 --> 00:15:04,320
plaintext blocks and then encrypt them

397
00:15:04,320 --> 00:15:07,839
again on some key password derived key

398
00:15:07,839 --> 00:15:10,560
and eventually you store this random key

399
00:15:10,560 --> 00:15:13,279
in the very last block

400
00:15:13,279 --> 00:15:16,160
so the idea is that and you also

401
00:15:16,160 --> 00:15:18,880
feedback the ciphertext blocks back to

402
00:15:18,880 --> 00:15:21,440
the argon 2 computation or any other

403
00:15:21,440 --> 00:15:23,440
memory heart function computation the

404
00:15:23,440 --> 00:15:26,880
idea is that you can uh use much more

405
00:15:26,880 --> 00:15:28,480
memory because the

406
00:15:28,480 --> 00:15:30,560
the argument computation is faster than

407
00:15:30,560 --> 00:15:32,320
encryption you can you use much more

408
00:15:32,320 --> 00:15:35,519
memory than you use for the chunk and

409
00:15:35,519 --> 00:15:38,079
you can make this memory and chunk size

410
00:15:38,079 --> 00:15:40,720
independently and

411
00:15:40,720 --> 00:15:42,560
there is no way to pre-compute either

412
00:15:42,560 --> 00:15:45,440
part of it to try the decryption

413
00:15:45,440 --> 00:15:47,600
offline

414
00:15:47,600 --> 00:15:49,759
for example if the encryption is aes

415
00:15:49,759 --> 00:15:51,920
then we can fill four or six times

416
00:15:51,920 --> 00:15:55,040
faster memory than you compute aes and

417
00:15:55,040 --> 00:15:57,199
for example if we work with one megabyte

418
00:15:57,199 --> 00:15:59,680
chunk and we can tolerate one tenth of a

419
00:15:59,680 --> 00:16:01,680
second for decryption then we can

420
00:16:01,680 --> 00:16:04,880
effectively use 256 megabytes of ram

421
00:16:04,880 --> 00:16:07,040
which is quite a prohibitive factor if

422
00:16:07,040 --> 00:16:09,839
we tolerate one second then we can use

423
00:16:09,839 --> 00:16:12,480
up to two gigabytes of frame which would

424
00:16:12,480 --> 00:16:16,480
be prohibitive even for bat for botnets

425
00:16:16,480 --> 00:16:18,959
this is not and our last example is the

426
00:16:18,959 --> 00:16:21,199
egalitarian proofs of work so one

427
00:16:21,199 --> 00:16:23,120
example you have seen already this

428
00:16:23,120 --> 00:16:24,959
equihash thing

429
00:16:24,959 --> 00:16:27,839
but the subject of another work and

430
00:16:27,839 --> 00:16:30,000
our new proof of work

431
00:16:30,000 --> 00:16:32,880
is based on argon 2. interestingly the

432
00:16:32,880 --> 00:16:34,880
proofs of work have to satisfy quite a

433
00:16:34,880 --> 00:16:36,720
lot of properties so it's not easy to

434
00:16:36,720 --> 00:16:38,639
build them even if you have a memory

435
00:16:38,639 --> 00:16:41,040
heart function in the pocket so

436
00:16:41,040 --> 00:16:43,279
the proofs of work have to have a

437
00:16:43,279 --> 00:16:45,600
symmetry they have to be hard to compute

438
00:16:45,600 --> 00:16:47,680
but easy to verify they have to be

439
00:16:47,680 --> 00:16:49,440
amortization free meaning that every

440
00:16:49,440 --> 00:16:51,600
next solution is should be as much

441
00:16:51,600 --> 00:16:54,000
expensive as the first one if memory

442
00:16:54,000 --> 00:16:56,079
hard hardness has claimed that the time

443
00:16:56,079 --> 00:16:58,000
step space trade-offs should be

444
00:16:58,000 --> 00:17:00,160
sufficiently steep time and memory

445
00:17:00,160 --> 00:17:02,399
should be tuned independently the best

446
00:17:02,399 --> 00:17:04,000
algorithms for memory heart functions

447
00:17:04,000 --> 00:17:06,240
should have already been found

448
00:17:06,240 --> 00:17:07,520
and uh

449
00:17:07,520 --> 00:17:09,439
also interestingly that the progress

450
00:17:09,439 --> 00:17:11,919
free property that chances to find the

451
00:17:11,919 --> 00:17:14,480
solution do not accumulate over time so

452
00:17:14,480 --> 00:17:16,720
that uh the solution finding is some

453
00:17:16,720 --> 00:17:18,640
sort of a stochastic process some sort

454
00:17:18,640 --> 00:17:21,280
of post-on process where every time you

455
00:17:21,280 --> 00:17:22,079
do

456
00:17:22,079 --> 00:17:23,839
every small portion of a second to do

457
00:17:23,839 --> 00:17:25,919
computation you have nonzero chance to

458
00:17:25,919 --> 00:17:27,839
find it you cannot spend 10 minutes to

459
00:17:27,839 --> 00:17:29,840
find proof of work because it would

460
00:17:29,840 --> 00:17:32,960
stimulate centralization in

461
00:17:32,960 --> 00:17:35,600
among cryptocurrency minors and also be

462
00:17:35,600 --> 00:17:37,919
ideally parallel unfriendly meaning that

463
00:17:37,919 --> 00:17:40,400
if you employ multiple cores they will

464
00:17:40,400 --> 00:17:42,880
not uh

465
00:17:42,880 --> 00:17:44,960
your implementation will not be

466
00:17:44,960 --> 00:17:46,880
more energy efficient

467
00:17:46,880 --> 00:17:48,720
interestingly that different proofs of

468
00:17:48,720 --> 00:17:51,760
work they miss uh one or two of these

469
00:17:51,760 --> 00:17:54,000
properties for example the bitcoins is

470
00:17:54,000 --> 00:17:56,400
not proof of work equihash

471
00:17:56,400 --> 00:17:59,360
is not so much progress free and if you

472
00:17:59,360 --> 00:18:02,080
employ a regular proof of space

473
00:18:02,080 --> 00:18:05,120
then they don't have that nice

474
00:18:05,120 --> 00:18:07,840
trade-offs and

475
00:18:07,840 --> 00:18:08,640
they

476
00:18:08,640 --> 00:18:10,400
every next solution is not as much

477
00:18:10,400 --> 00:18:11,840
expensive because there are several

478
00:18:11,840 --> 00:18:15,120
interesting attacks on them so

479
00:18:15,120 --> 00:18:16,559
if you just employ a memory heart

480
00:18:16,559 --> 00:18:19,360
function for proof of work and follow it

481
00:18:19,360 --> 00:18:20,559
with

482
00:18:20,559 --> 00:18:24,000
so-called difficulty test if you first

483
00:18:24,000 --> 00:18:25,919
run it and then apply a hash function at

484
00:18:25,919 --> 00:18:27,360
the very end to check for the leading

485
00:18:27,360 --> 00:18:28,400
zeros

486
00:18:28,400 --> 00:18:30,400
then the problem is that it doesn't

487
00:18:30,400 --> 00:18:33,440
allow a fast verification so to verify

488
00:18:33,440 --> 00:18:36,240
it to verify the first scheme you would

489
00:18:36,240 --> 00:18:37,760
need a lot of memory also for

490
00:18:37,760 --> 00:18:39,679
verification that's not nice there are

491
00:18:39,679 --> 00:18:42,160
concepts like proof of space where you

492
00:18:42,160 --> 00:18:43,679
compute

493
00:18:43,679 --> 00:18:45,760
some memory heart function then compute

494
00:18:45,760 --> 00:18:48,880
miracle 3 over it and the miracle root

495
00:18:48,880 --> 00:18:51,600
determines which which memory blocks you

496
00:18:51,600 --> 00:18:53,679
have to open to prove that you computed

497
00:18:53,679 --> 00:18:56,640
it properly but there are some subtle

498
00:18:56,640 --> 00:18:58,799
things here so if you

499
00:18:58,799 --> 00:19:01,120
supply the nonce for proof of work as an

500
00:19:01,120 --> 00:19:03,200
input to this proof of space then there

501
00:19:03,200 --> 00:19:05,919
is a called grinding attack that

502
00:19:05,919 --> 00:19:08,400
allows to

503
00:19:08,400 --> 00:19:10,080
repeat only small parts of this

504
00:19:10,080 --> 00:19:13,120
computation to pass the difficulty test

505
00:19:13,120 --> 00:19:16,000
so suppose you make one comp you

506
00:19:16,000 --> 00:19:18,000
selected a nonce you have made a

507
00:19:18,000 --> 00:19:19,679
computation but in the end you

508
00:19:19,679 --> 00:19:22,400
eventually failed with having say d

509
00:19:22,400 --> 00:19:25,520
leading zeros for the output then

510
00:19:25,520 --> 00:19:27,200
the idea of the attack is not to

511
00:19:27,200 --> 00:19:29,200
recompute the whole thing from scratch

512
00:19:29,200 --> 00:19:31,440
but exploit the fact that not all blocks

513
00:19:31,440 --> 00:19:34,000
are opened by this procedure you can

514
00:19:34,000 --> 00:19:35,120
cheat by

515
00:19:35,120 --> 00:19:36,240
trying

516
00:19:36,240 --> 00:19:38,320
only the very last block until you

517
00:19:38,320 --> 00:19:40,080
succeed and there is a very big chance

518
00:19:40,080 --> 00:19:42,640
that this last block will never be part

519
00:19:42,640 --> 00:19:45,600
of the opening and not only the last

520
00:19:45,600 --> 00:19:47,200
block but the block before last would

521
00:19:47,200 --> 00:19:48,880
also work

522
00:19:48,880 --> 00:19:52,480
our idea is to

523
00:19:52,480 --> 00:19:55,200
build a similar but more secure

524
00:19:55,200 --> 00:19:57,679
construction on the top of argon 2. the

525
00:19:57,679 --> 00:19:59,760
idea is that we select the nonce only

526
00:19:59,760 --> 00:20:03,120
after the merkle tree is computed and we

527
00:20:03,120 --> 00:20:06,159
open a certain number of blocks like 100

528
00:20:06,159 --> 00:20:08,080
different blocks

529
00:20:08,080 --> 00:20:09,679
the thing is

530
00:20:09,679 --> 00:20:12,640
the parallelism is still possible here

531
00:20:12,640 --> 00:20:14,080
but

532
00:20:14,080 --> 00:20:16,159
since we select

533
00:20:16,159 --> 00:20:18,640
and open random blocks here

534
00:20:18,640 --> 00:20:20,799
the any parallel implementation of this

535
00:20:20,799 --> 00:20:23,360
proof of work would have to have a very

536
00:20:23,360 --> 00:20:26,559
high memory bandwidth with random access

537
00:20:26,559 --> 00:20:28,799
to memory and this problem is considered

538
00:20:28,799 --> 00:20:30,640
to be hard so

539
00:20:30,640 --> 00:20:32,159
even the best

540
00:20:32,159 --> 00:20:34,480
gpu do not have a memory bandwidth more

541
00:20:34,480 --> 00:20:36,960
than one terabyte per second and we

542
00:20:36,960 --> 00:20:39,840
think that if we employ like 100 cores

543
00:20:39,840 --> 00:20:41,760
here then this bandwidth will be

544
00:20:41,760 --> 00:20:44,720
exceeded so we don't think that

545
00:20:44,720 --> 00:20:46,880
special hardware would be

546
00:20:46,880 --> 00:20:50,240
very helpful in implementing this scheme

547
00:20:50,240 --> 00:20:52,720
and the benefit of it is that it's very

548
00:20:52,720 --> 00:20:54,640
fast in terms that

549
00:20:54,640 --> 00:20:55,919
if you

550
00:20:55,919 --> 00:20:57,679
feel what two gigabytes it will take

551
00:20:57,679 --> 00:20:59,280
only one second because they are going

552
00:20:59,280 --> 00:21:02,720
to is very fast and fill in memory

553
00:21:02,720 --> 00:21:03,760
so

554
00:21:03,760 --> 00:21:06,400
these are several examples of

555
00:21:06,400 --> 00:21:09,039
how egalitarian computing can bring more

556
00:21:09,039 --> 00:21:12,640
security to different protocols

557
00:21:12,640 --> 00:21:15,200
interestingly so it can make

558
00:21:15,200 --> 00:21:18,000
the ski it can make six letter passwords

559
00:21:18,000 --> 00:21:20,320
that were deemed insecure before they

560
00:21:20,320 --> 00:21:22,640
can still they can become secure again

561
00:21:22,640 --> 00:21:25,600
if we uh hash them with the memory heart

562
00:21:25,600 --> 00:21:27,440
function and deploy them in the memory

563
00:21:27,440 --> 00:21:29,840
heart protocols the 80 80-bit keys can

564
00:21:29,840 --> 00:21:32,000
be secure again because

565
00:21:32,000 --> 00:21:33,520
if we employ them in memory hard

566
00:21:33,520 --> 00:21:35,679
constructions then special hardware will

567
00:21:35,679 --> 00:21:38,080
be no benefit so for example we can we

568
00:21:38,080 --> 00:21:40,480
have heard that the des cipher was

569
00:21:40,480 --> 00:21:43,600
broken on a special hardware on fpga but

570
00:21:43,600 --> 00:21:45,039
we didn't hear that

571
00:21:45,039 --> 00:21:47,200
the key was brute forced on a regular

572
00:21:47,200 --> 00:21:49,120
laptop or a server that's still too

573
00:21:49,120 --> 00:21:51,760
expensive so denial of service attacks

574
00:21:51,760 --> 00:21:54,080
are also made harder with this concept

575
00:21:54,080 --> 00:21:57,039
and blockchain users can again be

576
00:21:57,039 --> 00:21:58,960
regular miners

577
00:21:58,960 --> 00:22:01,600
so this or this concept it suffrages a

578
00:22:01,600 --> 00:22:03,679
lot of users and make finally the

579
00:22:03,679 --> 00:22:06,559
defenders equal to the attackers and

580
00:22:06,559 --> 00:22:07,520
make

581
00:22:07,520 --> 00:22:10,000
our defenses much

582
00:22:10,000 --> 00:22:11,360
much better

583
00:22:11,360 --> 00:22:14,400
so uh very similarly to as it happened

584
00:22:14,400 --> 00:22:17,280
uh more than one hundred years ago uh we

585
00:22:17,280 --> 00:22:19,120
uh the concept of egalitarian computing

586
00:22:19,120 --> 00:22:22,159
will hopefully bring uh more

587
00:22:22,159 --> 00:22:25,200
security and

588
00:22:25,280 --> 00:22:27,039
more equality

589
00:22:27,039 --> 00:22:29,600
to regular people

590
00:22:29,600 --> 00:22:30,950
thank you

591
00:22:30,950 --> 00:22:39,339
[Applause]

592
00:22:41,360 --> 00:22:44,159
you have time for questions

593
00:22:44,159 --> 00:22:46,320
so i'll i'll start things off so i

594
00:22:46,320 --> 00:22:48,159
really like the idea here and it seems

595
00:22:48,159 --> 00:22:50,960
to work well given the current computing

596
00:22:50,960 --> 00:22:52,240
um

597
00:22:52,240 --> 00:22:54,799
economics and availability the question

598
00:22:54,799 --> 00:22:57,360
is is there a counter egalitarian

599
00:22:57,360 --> 00:22:59,200
computing where an organization that has

600
00:22:59,200 --> 00:23:02,159
say many billions of dollars and has an

601
00:23:02,159 --> 00:23:04,000
incentive to break crypto and won't name

602
00:23:04,000 --> 00:23:05,919
any particular organizations

603
00:23:05,919 --> 00:23:07,520
could construct hardware that would give

604
00:23:07,520 --> 00:23:09,679
them a bigger advantage and then

605
00:23:09,679 --> 00:23:11,200
actually have more of an asymmetric

606
00:23:11,200 --> 00:23:12,640
advantage because they have hardware

607
00:23:12,640 --> 00:23:14,559
that no one else has that's designed

608
00:23:14,559 --> 00:23:15,919
around these kinds of memory hard

609
00:23:15,919 --> 00:23:16,960
problems

610
00:23:16,960 --> 00:23:18,480
is there a fundamental reason why that's

611
00:23:18,480 --> 00:23:20,320
not possible or it's just the economics

612
00:23:20,320 --> 00:23:21,120
of it

613
00:23:21,120 --> 00:23:23,440
so could you repeat the question exactly

614
00:23:23,440 --> 00:23:25,520
um so the question is if the nsa wanted

615
00:23:25,520 --> 00:23:26,880
to spend

616
00:23:26,880 --> 00:23:28,480
20 billion dollars

617
00:23:28,480 --> 00:23:30,240
trying to break memory hard functions

618
00:23:30,240 --> 00:23:32,000
could they do it

619
00:23:32,000 --> 00:23:34,799
well i think they wouldn't break

620
00:23:34,799 --> 00:23:36,400
the functions with 20 million dollars

621
00:23:36,400 --> 00:23:39,200
they can build special they can build

622
00:23:39,200 --> 00:23:42,080
hardware that be very close to regular

623
00:23:42,080 --> 00:23:43,360
servers but

624
00:23:43,360 --> 00:23:45,120
they will be it will be efficient by a

625
00:23:45,120 --> 00:23:47,440
small factor maybe by the factor of 10

626
00:23:47,440 --> 00:23:50,559
or 15 so it will probably not worth the

627
00:23:50,559 --> 00:23:53,840
cost that's the whole feature so uh the

628
00:23:53,840 --> 00:23:56,000
special hardware will still be slightly

629
00:23:56,000 --> 00:23:58,240
more efficient but not to the extent

630
00:23:58,240 --> 00:24:00,640
that it will uh worth billions of

631
00:24:00,640 --> 00:24:02,559
dollars spent for this purpose

632
00:24:02,559 --> 00:24:05,120
so is there a fundamental reason why

633
00:24:05,120 --> 00:24:06,159
building

634
00:24:06,159 --> 00:24:07,760
that there there couldn't be a design

635
00:24:07,760 --> 00:24:09,440
for special hardware that makes these

636
00:24:09,440 --> 00:24:10,480
memory

637
00:24:10,480 --> 00:24:12,240
hard fun you know you're not designing a

638
00:24:12,240 --> 00:24:13,760
custom basic now there's a lot of

639
00:24:13,760 --> 00:24:15,120
history in building custom basics to

640
00:24:15,120 --> 00:24:17,200
make um straight-line computation more

641
00:24:17,200 --> 00:24:18,799
efficient

642
00:24:18,799 --> 00:24:20,559
why someone with enough resource

643
00:24:20,559 --> 00:24:22,159
couldn't do something to make

644
00:24:22,159 --> 00:24:26,000
large-scale memory access more efficient

645
00:24:26,000 --> 00:24:27,520
well no

646
00:24:27,520 --> 00:24:29,520
fundamental

647
00:24:29,520 --> 00:24:31,360
barrier probably

648
00:24:31,360 --> 00:24:34,880
but uh well uh if uh such uh

649
00:24:34,880 --> 00:24:37,520
construction appear in the future

650
00:24:37,520 --> 00:24:39,360
i think we'll

651
00:24:39,360 --> 00:24:40,960
i do not have any inside information

652
00:24:40,960 --> 00:24:42,480
that the nsa is working on this so i

653
00:24:42,480 --> 00:24:43,679
think i think we're safe for a while i

654
00:24:43,679 --> 00:24:44,720
think it

655
00:24:44,720 --> 00:24:46,799
i hope to make sense given what we know

656
00:24:46,799 --> 00:24:51,360
now so thank you uh any other questions

657
00:24:51,520 --> 00:24:53,360
so do we have a speaker for the fourth

658
00:24:53,360 --> 00:24:55,678
paper

659
00:24:57,310 --> 00:24:58,840
[Applause]

660
00:24:58,840 --> 00:25:03,399
yes give the tree again

