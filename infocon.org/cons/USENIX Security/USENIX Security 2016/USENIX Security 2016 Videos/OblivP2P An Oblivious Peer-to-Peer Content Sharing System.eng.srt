1
00:00:10,480 --> 00:00:12,320
hello everyone thank you for coming to

2
00:00:12,320 --> 00:00:13,280
the talk

3
00:00:13,280 --> 00:00:15,360
i am shruti topley and today i'll be

4
00:00:15,360 --> 00:00:18,080
talking about our work obliv p2p a

5
00:00:18,080 --> 00:00:20,080
protocol for an oblivious peer-to-peer

6
00:00:20,080 --> 00:00:22,640
content sharing system

7
00:00:22,640 --> 00:00:24,640
traffic analysis is a well-known problem

8
00:00:24,640 --> 00:00:27,279
in the area of peer-to-peer systems

9
00:00:27,279 --> 00:00:29,679
content sharing systems like bittorrent

10
00:00:29,679 --> 00:00:32,719
and others have reported heavily to

11
00:00:32,719 --> 00:00:36,399
users of millions of users per month

12
00:00:36,399 --> 00:00:39,280
which is around 3.35 percent of overall

13
00:00:39,280 --> 00:00:41,280
world bandwidth

14
00:00:41,280 --> 00:00:43,280
in these systems peers usually

15
00:00:43,280 --> 00:00:44,879
communicate with each other to access

16
00:00:44,879 --> 00:00:47,360
resources for ease of availability and

17
00:00:47,360 --> 00:00:49,440
efficiency reasons

18
00:00:49,440 --> 00:00:51,840
but with this benefit comes a drawback

19
00:00:51,840 --> 00:00:53,600
where these peer-to-peer systems are

20
00:00:53,600 --> 00:00:55,840
susceptible to long-term global traffic

21
00:00:55,840 --> 00:00:58,000
analysis through adversaries or

22
00:00:58,000 --> 00:01:00,480
organizations that have access to the

23
00:01:00,480 --> 00:01:02,879
network traffic or through devices and

24
00:01:02,879 --> 00:01:06,240
tools that allow global monitoring

25
00:01:06,240 --> 00:01:08,000
we ask the question that with these

26
00:01:08,000 --> 00:01:11,040
capabilities what can an adversary do by

27
00:01:11,040 --> 00:01:13,200
observing the network traffic between

28
00:01:13,200 --> 00:01:15,520
the peers in the network

29
00:01:15,520 --> 00:01:17,680
the adversary can learn substantial

30
00:01:17,680 --> 00:01:19,759
private information about the users

31
00:01:19,759 --> 00:01:21,600
through several leakage channels like

32
00:01:21,600 --> 00:01:23,680
the plain text data the length of the

33
00:01:23,680 --> 00:01:26,799
messages and the time interval

34
00:01:26,799 --> 00:01:28,720
previous work has heavily focused on

35
00:01:28,720 --> 00:01:30,240
these side channels and proposed

36
00:01:30,240 --> 00:01:32,880
solutions like secure channel padding of

37
00:01:32,880 --> 00:01:35,840
messages and fixed interval messaging

38
00:01:35,840 --> 00:01:38,079
if we assume that these defenses are

39
00:01:38,079 --> 00:01:39,920
already deployed and exist in the

40
00:01:39,920 --> 00:01:41,520
peer-to-peer systems

41
00:01:41,520 --> 00:01:43,360
what we show in this work is that the

42
00:01:43,360 --> 00:01:45,439
adversary can still learn enough

43
00:01:45,439 --> 00:01:47,600
information by simply observing the

44
00:01:47,600 --> 00:01:49,520
access patterns between the peers in the

45
00:01:49,520 --> 00:01:51,200
network

46
00:01:51,200 --> 00:01:53,439
by access pattern what we mean is that

47
00:01:53,439 --> 00:01:55,600
which resource which peer is accessing

48
00:01:55,600 --> 00:01:57,680
which resource and communicating with

49
00:01:57,680 --> 00:01:59,680
which receiver in the network

50
00:01:59,680 --> 00:02:02,159
a global adversary who is observing this

51
00:02:02,159 --> 00:02:04,799
can easily link senders and receiver in

52
00:02:04,799 --> 00:02:06,880
the network and understand information

53
00:02:06,880 --> 00:02:08,560
about the resources exchange between

54
00:02:08,560 --> 00:02:10,399
them

55
00:02:10,399 --> 00:02:12,080
what is the problem with the current

56
00:02:12,080 --> 00:02:14,239
solutions that are used to hide this

57
00:02:14,239 --> 00:02:16,160
linkability property

58
00:02:16,160 --> 00:02:18,640
anonymous systems such as mix network

59
00:02:18,640 --> 00:02:21,200
and tar are good enough to hide online

60
00:02:21,200 --> 00:02:23,200
identity of users and guarantee

61
00:02:23,200 --> 00:02:25,200
anonymity properties

62
00:02:25,200 --> 00:02:27,520
but these solutions fail to guarantee

63
00:02:27,520 --> 00:02:29,599
the property of unlinkability outlined

64
00:02:29,599 --> 00:02:30,959
earlier

65
00:02:30,959 --> 00:02:33,680
in presence of an adversary who has both

66
00:02:33,680 --> 00:02:36,400
long-term view of the traffic and global

67
00:02:36,400 --> 00:02:39,040
view of the entire network

68
00:02:39,040 --> 00:02:41,200
this leads us to ask the question is

69
00:02:41,200 --> 00:02:43,519
anonymizing sufficient to hide

70
00:02:43,519 --> 00:02:45,840
unlinkability

71
00:02:45,840 --> 00:02:48,000
as a contribution in this work we

72
00:02:48,000 --> 00:02:50,879
present oblivi a protocol that

73
00:02:50,879 --> 00:02:53,280
guarantees unlinkability between the

74
00:02:53,280 --> 00:02:55,599
peers in the network while allowing

75
00:02:55,599 --> 00:02:57,680
obliviousness of the access patterns in

76
00:02:57,680 --> 00:02:59,840
p2p systems

77
00:02:59,840 --> 00:03:01,760
we present a prototype implementation of

78
00:03:01,760 --> 00:03:03,840
our system and have made it available

79
00:03:03,840 --> 00:03:05,440
online on this link for users to

80
00:03:05,440 --> 00:03:06,959
download

81
00:03:06,959 --> 00:03:09,599
finally we evaluate our system and find

82
00:03:09,599 --> 00:03:12,000
that oblive p2p has no centralized

83
00:03:12,000 --> 00:03:14,319
bottleneck on any single entity

84
00:03:14,319 --> 00:03:16,400
and the performance of our system

85
00:03:16,400 --> 00:03:18,239
linearly scales with the number of peers

86
00:03:18,239 --> 00:03:20,480
in the network

87
00:03:20,480 --> 00:03:22,640
now let's step back and look at what is

88
00:03:22,640 --> 00:03:25,280
the actual problem and why are existing

89
00:03:25,280 --> 00:03:28,000
solutions insufficient in providing the

90
00:03:28,000 --> 00:03:30,720
unlinkability guarantees

91
00:03:30,720 --> 00:03:32,879
consider a peer-to-peer system that is

92
00:03:32,879 --> 00:03:34,159
using the

93
00:03:34,159 --> 00:03:36,959
mix network as a solution to guarantee

94
00:03:36,959 --> 00:03:39,040
uh unlinkability

95
00:03:39,040 --> 00:03:41,360
here the senders can submit their

96
00:03:41,360 --> 00:03:43,040
information to the mixed network where

97
00:03:43,040 --> 00:03:45,120
it is re-encrypted and permuted and

98
00:03:45,120 --> 00:03:47,280
distributed to the receivers

99
00:03:47,280 --> 00:03:49,040
a global adversary who observes this

100
00:03:49,040 --> 00:03:51,760
communication cannot learn which sender

101
00:03:51,760 --> 00:03:53,760
is actually transferring which resource

102
00:03:53,760 --> 00:03:55,200
to which receiver

103
00:03:55,200 --> 00:03:57,599
thus what we get is unlinkability for

104
00:03:57,599 --> 00:03:59,200
the single round

105
00:03:59,200 --> 00:04:01,120
but let's see what happens when the same

106
00:04:01,120 --> 00:04:03,680
adversary can observe over arbitrary

107
00:04:03,680 --> 00:04:06,879
number of rounds for a long term and see

108
00:04:06,879 --> 00:04:08,560
what communication is happening in the

109
00:04:08,560 --> 00:04:10,159
network

110
00:04:10,159 --> 00:04:12,159
this adversary can now do an

111
00:04:12,159 --> 00:04:13,920
intersection between the senders and the

112
00:04:13,920 --> 00:04:16,639
recipient sets of the people and

113
00:04:16,639 --> 00:04:18,079
understand what are the common

114
00:04:18,079 --> 00:04:20,399
participants in the network and create a

115
00:04:20,399 --> 00:04:21,680
link between the senders and the

116
00:04:21,680 --> 00:04:24,080
receivers thus again getting the

117
00:04:24,080 --> 00:04:26,840
property of unlinkability through

118
00:04:26,840 --> 00:04:28,240
long-term uh prop

119
00:04:28,240 --> 00:04:30,160
capacity

120
00:04:30,160 --> 00:04:32,080
this is a very well-known attack called

121
00:04:32,080 --> 00:04:33,919
as intersection hitting set or

122
00:04:33,919 --> 00:04:36,160
statistical disclosure attack for mixed

123
00:04:36,160 --> 00:04:38,320
networks with an adversary who has

124
00:04:38,320 --> 00:04:41,680
long-term observation capacities

125
00:04:41,680 --> 00:04:44,080
in our work what we propose is making

126
00:04:44,080 --> 00:04:45,759
the access patents oblivious in

127
00:04:45,759 --> 00:04:47,440
peer-to-peer systems

128
00:04:47,440 --> 00:04:49,199
using the well-known cryptographic

129
00:04:49,199 --> 00:04:51,840
primitive of oblivious ram

130
00:04:51,840 --> 00:04:53,680
oram is essentially proposed to hide

131
00:04:53,680 --> 00:04:56,720
access pattern between cpu and memory

132
00:04:56,720 --> 00:04:58,880
where the data is shuffled periodically

133
00:04:58,880 --> 00:05:02,000
in the memory to hide access patterns

134
00:05:02,000 --> 00:05:04,479
orap is applied to various other areas

135
00:05:04,479 --> 00:05:06,800
like cloud storage and file system to

136
00:05:06,800 --> 00:05:08,639
hide access patterns

137
00:05:08,639 --> 00:05:10,639
this makes us wonder can we just take

138
00:05:10,639 --> 00:05:12,160
oram and directly apply it to

139
00:05:12,160 --> 00:05:14,400
peer-to-peer system to achieve similar

140
00:05:14,400 --> 00:05:17,360
guarantees of obliviousness

141
00:05:17,360 --> 00:05:19,280
before i get into answering this

142
00:05:19,280 --> 00:05:20,960
question let me give you a quick

143
00:05:20,960 --> 00:05:23,039
background about oran

144
00:05:23,039 --> 00:05:25,680
in our work we use the tree based oram

145
00:05:25,680 --> 00:05:27,440
where the data blocks are arranged in a

146
00:05:27,440 --> 00:05:29,360
tree pattern and there are two

147
00:05:29,360 --> 00:05:32,160
operations read and write

148
00:05:32,160 --> 00:05:33,840
for reading a particular block what

149
00:05:33,840 --> 00:05:35,919
auram does it fetches a path that

150
00:05:35,919 --> 00:05:37,280
contains a block

151
00:05:37,280 --> 00:05:39,199
and that path is then stored on the

152
00:05:39,199 --> 00:05:41,520
local storage called stash

153
00:05:41,520 --> 00:05:43,680
for writing blocks to this tree it

154
00:05:43,680 --> 00:05:45,919
selects a random path industry and the

155
00:05:45,919 --> 00:05:47,840
blocks are shuffled between the stash

156
00:05:47,840 --> 00:05:50,160
and this random path

157
00:05:50,160 --> 00:05:52,240
with this background now let's see how

158
00:05:52,240 --> 00:05:54,160
we can map the oram scheme to our

159
00:05:54,160 --> 00:05:56,000
peer-to-peer system

160
00:05:56,000 --> 00:05:57,759
let's consider a client server model

161
00:05:57,759 --> 00:05:59,360
that is using overapp

162
00:05:59,360 --> 00:06:01,039
the client is trusted and stores the

163
00:06:01,039 --> 00:06:04,000
position map of the blocks and the stash

164
00:06:04,000 --> 00:06:06,080
the server is untrusted and stores the

165
00:06:06,080 --> 00:06:08,400
data blocks in the tree pattern

166
00:06:08,400 --> 00:06:10,080
whenever the client wants to access a

167
00:06:10,080 --> 00:06:12,080
particular block it will look up into

168
00:06:12,080 --> 00:06:14,960
its position map and fetch a random path

169
00:06:14,960 --> 00:06:17,280
that contains the block next the client

170
00:06:17,280 --> 00:06:18,800
can decrypt the block and get the

171
00:06:18,800 --> 00:06:20,319
resource

172
00:06:20,319 --> 00:06:22,240
a global adversary who is observing this

173
00:06:22,240 --> 00:06:24,319
communication sees that the client is

174
00:06:24,319 --> 00:06:26,319
just accessing a random path every time

175
00:06:26,319 --> 00:06:28,319
to access a resource thus he learns

176
00:06:28,319 --> 00:06:30,240
nothing about actually which resource is

177
00:06:30,240 --> 00:06:33,039
accessed from which memory

178
00:06:33,039 --> 00:06:36,080
mapping this solution to our p2p system

179
00:06:36,080 --> 00:06:36,800
we

180
00:06:36,800 --> 00:06:39,919
use a trusted tracker a tracker is also

181
00:06:39,919 --> 00:06:41,919
present in bittorrent like system which

182
00:06:41,919 --> 00:06:43,520
manages the communication between the

183
00:06:43,520 --> 00:06:45,199
peers in the network

184
00:06:45,199 --> 00:06:46,880
this trusted tracker similar to the

185
00:06:46,880 --> 00:06:48,800
client holds the position map and the

186
00:06:48,800 --> 00:06:50,240
stash

187
00:06:50,240 --> 00:06:52,240
now the peers in the network play the

188
00:06:52,240 --> 00:06:54,960
role of the storage devices and store

189
00:06:54,960 --> 00:06:57,199
the blocks in the tree pattern depending

190
00:06:57,199 --> 00:06:59,120
upon their storage capacities they can

191
00:06:59,120 --> 00:07:01,199
either store one or more blocks of the

192
00:07:01,199 --> 00:07:02,960
network

193
00:07:02,960 --> 00:07:05,759
finally whenever a peer who is a part of

194
00:07:05,759 --> 00:07:08,319
the network or outside we call this peer

195
00:07:08,319 --> 00:07:10,400
an initiator once you request for a

196
00:07:10,400 --> 00:07:12,639
particular block it will contact the

197
00:07:12,639 --> 00:07:14,880
tracker the tracker similar to the

198
00:07:14,880 --> 00:07:17,039
client looks up into its position map

199
00:07:17,039 --> 00:07:18,960
and fetches the correct path that

200
00:07:18,960 --> 00:07:20,880
contains a block

201
00:07:20,880 --> 00:07:23,199
now what the tracker can do he can just

202
00:07:23,199 --> 00:07:25,840
send the ciphertext of the corresponding

203
00:07:25,840 --> 00:07:27,599
block to the initiator

204
00:07:27,599 --> 00:07:30,160
but this is not secure because a global

205
00:07:30,160 --> 00:07:31,680
adversary who is observing this

206
00:07:31,680 --> 00:07:33,759
communication can see that the

207
00:07:33,759 --> 00:07:35,759
ciphertext that is sent to the initiator

208
00:07:35,759 --> 00:07:37,919
and the ciphertext that is fetched from

209
00:07:37,919 --> 00:07:40,160
the peer that holds the block is the

210
00:07:40,160 --> 00:07:42,000
same and learns eventually that the

211
00:07:42,000 --> 00:07:43,759
initiator requested the block from this

212
00:07:43,759 --> 00:07:46,319
peer hence what the tracker does it

213
00:07:46,319 --> 00:07:48,560
decrypts the block on its local server

214
00:07:48,560 --> 00:07:50,560
and then re-encrypts and sends to the

215
00:07:50,560 --> 00:07:52,000
initiator

216
00:07:52,000 --> 00:07:53,919
this solves our problem and guarantees

217
00:07:53,919 --> 00:07:56,400
obliviousness that is the adversary

218
00:07:56,400 --> 00:07:58,479
again who is observing the communication

219
00:07:58,479 --> 00:08:00,879
sees that the tracker is randomly

220
00:08:00,879 --> 00:08:02,479
accessing a path

221
00:08:02,479 --> 00:08:04,080
irrespective of what resource is

222
00:08:04,080 --> 00:08:06,160
accessed and does not learn actually

223
00:08:06,160 --> 00:08:08,400
which resource is being fetched

224
00:08:08,400 --> 00:08:10,960
this solution we call as our oblique p2p

225
00:08:10,960 --> 00:08:13,120
zero protocol

226
00:08:13,120 --> 00:08:15,199
even though oblique p2p0 gives our

227
00:08:15,199 --> 00:08:18,560
security guarantees it is not efficient

228
00:08:18,560 --> 00:08:20,319
the tracker here mainly becomes a

229
00:08:20,319 --> 00:08:23,039
bottleneck because every time a request

230
00:08:23,039 --> 00:08:25,840
is made the tracker has to fetch blocks

231
00:08:25,840 --> 00:08:29,360
of order of login from the network

232
00:08:29,360 --> 00:08:31,280
we do a quick evaluation of this scheme

233
00:08:31,280 --> 00:08:34,240
and see that oblique to p0 the tracker

234
00:08:34,240 --> 00:08:37,360
has to fetch almost 118 megabytes of

235
00:08:37,360 --> 00:08:39,919
block per request when the network sizes

236
00:08:39,919 --> 00:08:41,760
of 2 million users

237
00:08:41,760 --> 00:08:43,760
this is almost equal to the maximum

238
00:08:43,760 --> 00:08:46,080
bandwidth that the server can support in

239
00:08:46,080 --> 00:08:48,240
our experimental setup

240
00:08:48,240 --> 00:08:51,200
what this makes us realize is we need a

241
00:08:51,200 --> 00:08:52,959
distributed oblivious peer-to-peer

242
00:08:52,959 --> 00:08:54,640
protocol

243
00:08:54,640 --> 00:08:57,360
as a solution we next present oblivious

244
00:08:57,360 --> 00:09:00,160
peer-to-peer one protocol

245
00:09:00,160 --> 00:09:01,920
the naive approach of converting the

246
00:09:01,920 --> 00:09:04,000
zero protocol to one and removing the

247
00:09:04,000 --> 00:09:06,399
bottleneck is that whenever the

248
00:09:06,399 --> 00:09:08,160
initiator requests a block to the

249
00:09:08,160 --> 00:09:09,360
tracker

250
00:09:09,360 --> 00:09:11,440
just make the tracker send the actual

251
00:09:11,440 --> 00:09:13,200
path position and the key to the

252
00:09:13,200 --> 00:09:15,600
initiator instead of himself fetching

253
00:09:15,600 --> 00:09:18,080
the entire path from the network

254
00:09:18,080 --> 00:09:20,240
now the initiator can fetch the path

255
00:09:20,240 --> 00:09:22,880
that contains the block and then decrypt

256
00:09:22,880 --> 00:09:24,800
it on its local machine and get access

257
00:09:24,800 --> 00:09:26,480
to the resource

258
00:09:26,480 --> 00:09:28,640
as we can see with this simple tweak to

259
00:09:28,640 --> 00:09:31,440
oblivi to p0 now we have made our

260
00:09:31,440 --> 00:09:33,440
protocol

261
00:09:33,440 --> 00:09:35,360
performant as the tracker does not

262
00:09:35,360 --> 00:09:37,760
actually transfer any of the real blocks

263
00:09:37,760 --> 00:09:40,480
hence not becoming a bottleneck

264
00:09:40,480 --> 00:09:41,279
but

265
00:09:41,279 --> 00:09:44,000
this scheme still suffers from a

266
00:09:44,000 --> 00:09:45,680
security problem

267
00:09:45,680 --> 00:09:47,760
let us see what is exactly that security

268
00:09:47,760 --> 00:09:49,680
problem

269
00:09:49,680 --> 00:09:52,240
oram works is while writing blocks to

270
00:09:52,240 --> 00:09:54,880
the tree it writes the most recently

271
00:09:54,880 --> 00:09:57,120
accessed block to the top of the tree

272
00:09:57,120 --> 00:09:59,120
and eventually during the right

273
00:09:59,120 --> 00:10:01,360
operation the blocks are pushed down

274
00:10:01,360 --> 00:10:02,880
which makes the least frequently

275
00:10:02,880 --> 00:10:06,320
accessed blocks stay at the leaves

276
00:10:06,320 --> 00:10:08,480
for example let's take this particular

277
00:10:08,480 --> 00:10:09,279
path

278
00:10:09,279 --> 00:10:12,560
here we can easily know that the block 5

279
00:10:12,560 --> 00:10:14,959
is least less frequently accessed

280
00:10:14,959 --> 00:10:17,040
whereas block 1 is the most recently

281
00:10:17,040 --> 00:10:19,839
accessed block thus if an initiator

282
00:10:19,839 --> 00:10:21,920
requests for block one and it knows that

283
00:10:21,920 --> 00:10:23,680
the position in the path is at the top

284
00:10:23,680 --> 00:10:26,000
of the tree it will know that this block

285
00:10:26,000 --> 00:10:28,000
has been recently accessed by some other

286
00:10:28,000 --> 00:10:30,800
peer thus leaking private information

287
00:10:30,800 --> 00:10:33,839
about the blocks accessed by other peers

288
00:10:33,839 --> 00:10:35,440
this is a well-known problem called as

289
00:10:35,440 --> 00:10:38,079
the block history problem and it appears

290
00:10:38,079 --> 00:10:40,720
mostly when the resources are shared

291
00:10:40,720 --> 00:10:43,440
between many users

292
00:10:43,440 --> 00:10:45,680
hence the security flaw also appears in

293
00:10:45,680 --> 00:10:48,480
our peer-to-peer system because multiple

294
00:10:48,480 --> 00:10:51,120
users access the same resource in p2p

295
00:10:51,120 --> 00:10:54,000
system for example two people can access

296
00:10:54,000 --> 00:10:56,000
the same website or download the same

297
00:10:56,000 --> 00:10:57,839
movie thus becoming the owner of that

298
00:10:57,839 --> 00:11:00,320
particular resource

299
00:11:00,320 --> 00:11:02,399
to solve this challenge we propose our

300
00:11:02,399 --> 00:11:04,880
new primitive which we call as oblivious

301
00:11:04,880 --> 00:11:07,040
selection

302
00:11:07,040 --> 00:11:09,279
oblivious selection guarantees that we

303
00:11:09,279 --> 00:11:11,440
can select a particular block without

304
00:11:11,440 --> 00:11:14,000
actually learning the block position the

305
00:11:14,000 --> 00:11:16,800
cryptographic key as well as not having

306
00:11:16,800 --> 00:11:20,560
any centralized bottleneck in the system

307
00:11:20,560 --> 00:11:22,160
let me present you the construction of

308
00:11:22,160 --> 00:11:24,640
our oblivious selection primitive

309
00:11:24,640 --> 00:11:27,120
as a first step we use the cryptographic

310
00:11:27,120 --> 00:11:28,720
primitive of private information

311
00:11:28,720 --> 00:11:31,680
retrieval on top of the oram scheme that

312
00:11:31,680 --> 00:11:35,279
we are using for oblivion p2p0

313
00:11:35,279 --> 00:11:37,920
using pir what we do is we obviously

314
00:11:37,920 --> 00:11:40,480
select a block from a path that is

315
00:11:40,480 --> 00:11:43,120
returned by the oram protocol

316
00:11:43,120 --> 00:11:45,519
note that we could directly use pir to

317
00:11:45,519 --> 00:11:47,200
fetch obliviously a block from the

318
00:11:47,200 --> 00:11:50,079
entire network but that is not efficient

319
00:11:50,079 --> 00:11:52,320
as it is linear to the number of blocks

320
00:11:52,320 --> 00:11:53,600
in the network

321
00:11:53,600 --> 00:11:56,880
using pir over oram makes it efficient

322
00:11:56,880 --> 00:11:59,600
as now the operation is just logarithmic

323
00:11:59,600 --> 00:12:02,320
to the number of blocks

324
00:12:02,320 --> 00:12:04,639
now whenever an initiator makes a

325
00:12:04,639 --> 00:12:06,240
request to the tracker

326
00:12:06,240 --> 00:12:08,480
the tracker instead of actually fetching

327
00:12:08,480 --> 00:12:10,399
the path from the network or sending it

328
00:12:10,399 --> 00:12:12,800
to the initiator he selects amperes in

329
00:12:12,800 --> 00:12:14,160
the network

330
00:12:14,160 --> 00:12:17,120
and each of these mps now downloads all

331
00:12:17,120 --> 00:12:19,200
the blocks that correspond to the path

332
00:12:19,200 --> 00:12:20,800
that holds the particular requested

333
00:12:20,800 --> 00:12:22,000
block

334
00:12:22,000 --> 00:12:24,160
this path is now replicated at each of

335
00:12:24,160 --> 00:12:26,240
these mp's machine

336
00:12:26,240 --> 00:12:28,320
the tracker further computes a pir

337
00:12:28,320 --> 00:12:30,160
metadata corresponding to the requested

338
00:12:30,160 --> 00:12:32,240
block and send it to each of these

339
00:12:32,240 --> 00:12:33,920
amperes

340
00:12:33,920 --> 00:12:36,639
now every peer in the selected amperes

341
00:12:36,639 --> 00:12:39,200
has to compute an encrypted share using

342
00:12:39,200 --> 00:12:42,399
the pir metadata and the downloaded

343
00:12:42,399 --> 00:12:44,240
encrypted blocks

344
00:12:44,240 --> 00:12:46,480
note that throughout this point none of

345
00:12:46,480 --> 00:12:48,560
the peers actually know what is the

346
00:12:48,560 --> 00:12:51,200
block position of the requested block

347
00:12:51,200 --> 00:12:53,519
and also observe that the trusted

348
00:12:53,519 --> 00:12:55,920
tracker is not actually transferring any

349
00:12:55,920 --> 00:12:58,160
of the real blocks that is there is no

350
00:12:58,160 --> 00:13:00,079
centralized bottleneck all the

351
00:13:00,079 --> 00:13:01,839
operations are distributed among the

352
00:13:01,839 --> 00:13:04,079
peers in the network more the peers in

353
00:13:04,079 --> 00:13:06,079
the network more we can parallelize the

354
00:13:06,079 --> 00:13:08,000
computation

355
00:13:08,000 --> 00:13:10,240
thus guaranteing us the block position

356
00:13:10,240 --> 00:13:13,440
and no centralized bottleneck properties

357
00:13:13,440 --> 00:13:15,760
but at the end of step one what we have

358
00:13:15,760 --> 00:13:17,440
achieved is every peer having an

359
00:13:17,440 --> 00:13:19,040
encrypted share

360
00:13:19,040 --> 00:13:21,200
the next challenge lies in how we can

361
00:13:21,200 --> 00:13:23,040
decrypt the shares without actually

362
00:13:23,040 --> 00:13:26,320
revealing the cryptographic key

363
00:13:26,320 --> 00:13:29,279
what we do for this is as a second step

364
00:13:29,279 --> 00:13:30,399
we use the

365
00:13:30,399 --> 00:13:32,399
primitive called seed homomorphic

366
00:13:32,399 --> 00:13:35,120
pseudorandom generator seed homo orphic

367
00:13:35,120 --> 00:13:36,959
pseudorandom generators allows us to

368
00:13:36,959 --> 00:13:39,199
decrypt shares without actually giving

369
00:13:39,199 --> 00:13:41,440
away the key to any of the peers in the

370
00:13:41,440 --> 00:13:45,360
network including the initiator

371
00:13:45,519 --> 00:13:48,000
after the first step what every peer has

372
00:13:48,000 --> 00:13:50,240
is an encrypted share of the requested

373
00:13:50,240 --> 00:13:51,120
block

374
00:13:51,120 --> 00:13:53,440
now the trusted tracker generates a

375
00:13:53,440 --> 00:13:55,600
valid key share for each of these

376
00:13:55,600 --> 00:13:58,880
amperes and distributes them

377
00:13:58,880 --> 00:14:01,360
finally each of these peers uses their

378
00:14:01,360 --> 00:14:03,600
encrypted share and the key share that

379
00:14:03,600 --> 00:14:06,320
is submitted by the tracker and computes

380
00:14:06,320 --> 00:14:08,240
a decrypted share on their local

381
00:14:08,240 --> 00:14:09,920
machines

382
00:14:09,920 --> 00:14:12,880
note that even until this point the

383
00:14:12,880 --> 00:14:15,199
track the peers that are selected have

384
00:14:15,199 --> 00:14:16,880
no information about what is the

385
00:14:16,880 --> 00:14:18,560
underlying plaintext of the requested

386
00:14:18,560 --> 00:14:21,120
block or the block position

387
00:14:21,120 --> 00:14:23,440
what they only know is that some

388
00:14:23,440 --> 00:14:25,600
decrypted share which looks like some

389
00:14:25,600 --> 00:14:27,680
random text to them storing at their

390
00:14:27,680 --> 00:14:29,120
local machine

391
00:14:29,120 --> 00:14:32,320
as long as one of the mps is honest they

392
00:14:32,320 --> 00:14:34,160
cannot collude and

393
00:14:34,160 --> 00:14:36,560
combine each of their shares to get the

394
00:14:36,560 --> 00:14:38,560
decrypted block

395
00:14:38,560 --> 00:14:40,959
the only way to do is to is to send the

396
00:14:40,959 --> 00:14:43,519
decrypted shares to the initiator where

397
00:14:43,519 --> 00:14:45,600
the initiator will combine all the

398
00:14:45,600 --> 00:14:47,680
decrypted shares and get back the

399
00:14:47,680 --> 00:14:50,079
original decrypted block

400
00:14:50,079 --> 00:14:52,240
throughout this protocol what we see is

401
00:14:52,240 --> 00:14:55,120
that including the initiator or the mps

402
00:14:55,120 --> 00:14:56,880
or other peers in the network who are

403
00:14:56,880 --> 00:14:59,680
not participating in the protocol learn

404
00:14:59,680 --> 00:15:01,760
nothing about which resource is being

405
00:15:01,760 --> 00:15:03,920
accessed what is the block position of

406
00:15:03,920 --> 00:15:06,160
the resource or even the cryptographic

407
00:15:06,160 --> 00:15:07,839
key that is corresponding to the

408
00:15:07,839 --> 00:15:09,199
resource

409
00:15:09,199 --> 00:15:11,199
it's only the tracker who has this

410
00:15:11,199 --> 00:15:13,760
information and is generating metadata

411
00:15:13,760 --> 00:15:15,440
about the requested resource and

412
00:15:15,440 --> 00:15:17,839
distributing the computation to the

413
00:15:17,839 --> 00:15:19,600
peers in the network

414
00:15:19,600 --> 00:15:21,279
the second important point to note is

415
00:15:21,279 --> 00:15:25,040
that as an oblive p2p0 oblique p2p1 does

416
00:15:25,040 --> 00:15:27,279
not suffer from a centralized bottleneck

417
00:15:27,279 --> 00:15:29,440
as every computation is distributed

418
00:15:29,440 --> 00:15:31,440
among the peers in the network the

419
00:15:31,440 --> 00:15:33,680
trusted tracker is not transferring any

420
00:15:33,680 --> 00:15:35,120
of the blocks

421
00:15:35,120 --> 00:15:37,600
in the actual real blocks but is only

422
00:15:37,600 --> 00:15:40,000
operating on position map and metadata

423
00:15:40,000 --> 00:15:42,880
corresponding to the requested block

424
00:15:42,880 --> 00:15:46,480
finally using said homomorphic uh prg in

425
00:15:46,480 --> 00:15:48,800
step two we solved the problem of not

426
00:15:48,800 --> 00:15:51,040
revealing the cryptographic key and thus

427
00:15:51,040 --> 00:15:55,360
achieve our properties discussed before

428
00:15:55,360 --> 00:15:58,160
as a security guarantee of our system we

429
00:15:58,160 --> 00:16:00,560
show that oblique p2p

430
00:16:00,560 --> 00:16:02,639
in oblique p2p any two equivalent

431
00:16:02,639 --> 00:16:03,759
accesses

432
00:16:03,759 --> 00:16:07,040
by two peers are indistinguishable for a

433
00:16:07,040 --> 00:16:09,680
honest but curious adversary with the

434
00:16:09,680 --> 00:16:11,839
constraint that the number of dishonest

435
00:16:11,839 --> 00:16:14,560
peers or colluding peers who can talk to

436
00:16:14,560 --> 00:16:16,399
each other and share the information

437
00:16:16,399 --> 00:16:18,399
that they see while operating in the

438
00:16:18,399 --> 00:16:21,040
protocol is limited to order of n raised

439
00:16:21,040 --> 00:16:23,199
to epsilon where epsilon is less than

440
00:16:23,199 --> 00:16:24,320
one

441
00:16:24,320 --> 00:16:27,360
we also gave a theorem to prove the for

442
00:16:27,360 --> 00:16:29,600
this and provide a detailed proof in the

443
00:16:29,600 --> 00:16:31,440
paper

444
00:16:31,440 --> 00:16:34,480
lastly we do a extensive evaluation of

445
00:16:34,480 --> 00:16:37,040
our system to understand its performance

446
00:16:37,040 --> 00:16:38,880
properties

447
00:16:38,880 --> 00:16:40,880
we evaluate our system on data lab

448
00:16:40,880 --> 00:16:41,920
servers

449
00:16:41,920 --> 00:16:45,120
and simulate up to 16 000 peers on this

450
00:16:45,120 --> 00:16:47,120
15 data lab servers

451
00:16:47,120 --> 00:16:49,120
each server in our network shares a

452
00:16:49,120 --> 00:16:51,759
bandwidth of 128 mbps

453
00:16:51,759 --> 00:16:53,920
and the block size that we use for the

454
00:16:53,920 --> 00:16:56,320
data transfer is 5 and 2 kb

455
00:16:56,320 --> 00:16:58,320
we select this block size because it is

456
00:16:58,320 --> 00:17:00,000
similar to the chunks that are used in

457
00:17:00,000 --> 00:17:02,079
the bittorrent system so we wanted to

458
00:17:02,079 --> 00:17:03,440
keep consistency with the real

459
00:17:03,440 --> 00:17:05,919
bittorrent network

460
00:17:05,919 --> 00:17:08,079
the first result that we observe is that

461
00:17:08,079 --> 00:17:09,679
oblivion

462
00:17:09,679 --> 00:17:11,760
has no centralized bottleneck that is

463
00:17:11,760 --> 00:17:13,520
the amount of data transferred through

464
00:17:13,520 --> 00:17:16,160
the tracker is independent of the block

465
00:17:16,160 --> 00:17:19,039
size and it drops down to only 1 mb per

466
00:17:19,039 --> 00:17:20,880
request

467
00:17:20,880 --> 00:17:23,119
as compared to the obvious p2p 0 the

468
00:17:23,119 --> 00:17:25,119
simple solution

469
00:17:25,119 --> 00:17:27,119
the second important result that we see

470
00:17:27,119 --> 00:17:29,520
is that the throughput of our solution

471
00:17:29,520 --> 00:17:31,520
linearly scales with the number of peers

472
00:17:31,520 --> 00:17:32,960
in the network

473
00:17:32,960 --> 00:17:35,360
that is if you see from the network size

474
00:17:35,360 --> 00:17:37,679
2 raised to 5 to 2 raised to 14 the

475
00:17:37,679 --> 00:17:40,160
throughput keeps on increasing and it

476
00:17:40,160 --> 00:17:42,400
becomes stable after that

477
00:17:42,400 --> 00:17:44,080
what we see is that the throughput is

478
00:17:44,080 --> 00:17:46,960
3.59 mb per second for 2 raised to 14

479
00:17:46,960 --> 00:17:50,080
pairs and it stays constant after that

480
00:17:50,080 --> 00:17:53,280
this observation is that the if we scale

481
00:17:53,280 --> 00:17:55,440
it to larger networks the throughput can

482
00:17:55,440 --> 00:17:56,480
improve

483
00:17:56,480 --> 00:17:59,520
and the 3.59 mb per second is due to the

484
00:17:59,520 --> 00:18:01,600
limited infrastructure in which we did

485
00:18:01,600 --> 00:18:04,960
our tests for example we simulated 16

486
00:18:04,960 --> 00:18:07,840
000 peers on just 15 servers where the

487
00:18:07,840 --> 00:18:10,000
computation and the bandwidth was shared

488
00:18:10,000 --> 00:18:11,520
among between the

489
00:18:11,520 --> 00:18:13,679
peers in the network

490
00:18:13,679 --> 00:18:16,160
where there was the bottleneck was

491
00:18:16,160 --> 00:18:17,840
computational that is the computation

492
00:18:17,840 --> 00:18:20,320
resources were limited and the peers had

493
00:18:20,320 --> 00:18:22,640
to share slowing down the performance

494
00:18:22,640 --> 00:18:24,880
whereas in real bittorrent networks if

495
00:18:24,880 --> 00:18:25,840
we

496
00:18:25,840 --> 00:18:28,320
apply this protocol every pure will be

497
00:18:28,320 --> 00:18:30,400
having a separate machine and separate

498
00:18:30,400 --> 00:18:32,480
bandwidth link and computation resource

499
00:18:32,480 --> 00:18:34,240
so we expect that the performance will

500
00:18:34,240 --> 00:18:36,240
be better if this protocol is actually

501
00:18:36,240 --> 00:18:39,120
simulated on bittorrent network

502
00:18:39,120 --> 00:18:42,400
finally as our conclusion we propose

503
00:18:42,400 --> 00:18:44,320
hiding access patterns in peer-to-peer

504
00:18:44,320 --> 00:18:45,679
systems

505
00:18:45,679 --> 00:18:48,080
we propose oblive p2p which is a first

506
00:18:48,080 --> 00:18:50,320
work to repurpose oram in peer-to-peer

507
00:18:50,320 --> 00:18:51,280
systems

508
00:18:51,280 --> 00:18:53,840
and lastly oblive p2p is linearly

509
00:18:53,840 --> 00:18:55,919
scalable and is highly paralyzable with

510
00:18:55,919 --> 00:18:59,120
the number of peers in the network

511
00:18:59,120 --> 00:19:01,440
thank you and once again the

512
00:19:01,440 --> 00:19:04,070
implementation is available online

513
00:19:04,070 --> 00:19:07,849
[Applause]

514
00:19:08,640 --> 00:19:10,720
we have time for a few questions

515
00:19:10,720 --> 00:19:13,200
thanks for your talk um as you noted in

516
00:19:13,200 --> 00:19:15,760
the beginning whenever you do a a read

517
00:19:15,760 --> 00:19:18,320
from an oram you have to mix the things

518
00:19:18,320 --> 00:19:20,640
in the stash and write it back

519
00:19:20,640 --> 00:19:22,640
i didn't see that in

520
00:19:22,640 --> 00:19:25,200
the later part of your yeah so that's a

521
00:19:25,200 --> 00:19:27,200
more detailed we have shown that in the

522
00:19:27,200 --> 00:19:29,200
paper but what we do is we using the

523
00:19:29,200 --> 00:19:31,760
oblivious select as a primitive to

524
00:19:31,760 --> 00:19:34,160
perform the shuffling as well so for

525
00:19:34,160 --> 00:19:35,919
eviction what we do is we select the

526
00:19:35,919 --> 00:19:38,080
path from the network and the blocks in

527
00:19:38,080 --> 00:19:40,320
the stash and we call oblivious select

528
00:19:40,320 --> 00:19:41,919
recursively

529
00:19:41,919 --> 00:19:43,360
the number of times so that the

530
00:19:43,360 --> 00:19:46,080
permutation happens each time and the

531
00:19:46,080 --> 00:19:48,559
positions of the boxes change so where

532
00:19:48,559 --> 00:19:49,600
does the

533
00:19:49,600 --> 00:19:51,679
so you select m

534
00:19:51,679 --> 00:19:54,080
peers to do the pir

535
00:19:54,080 --> 00:19:56,880
where do they get the stash data so the

536
00:19:56,880 --> 00:19:59,679
stash is also stored at one uh stylus is

537
00:19:59,679 --> 00:20:01,200
distributed between the peers in the

538
00:20:01,200 --> 00:20:04,159
network so yeah the tracker yes exactly

539
00:20:04,159 --> 00:20:07,159
okay

540
00:20:10,000 --> 00:20:13,840
so thanks triti very interesting ideas

541
00:20:13,840 --> 00:20:15,840
i'm curious to hear your thoughts about

542
00:20:15,840 --> 00:20:18,080
the overall scalability of the protocol

543
00:20:18,080 --> 00:20:19,600
so i think currently your protocol

544
00:20:19,600 --> 00:20:21,280
achieves throughput on the order of a

545
00:20:21,280 --> 00:20:23,840
few megabits per second so i'm wondering

546
00:20:23,840 --> 00:20:25,280
if you could share some potential

547
00:20:25,280 --> 00:20:26,559
optimizations that the research

548
00:20:26,559 --> 00:20:27,679
community could think about in the

549
00:20:27,679 --> 00:20:29,360
future to make these systems more

550
00:20:29,360 --> 00:20:30,400
practical

551
00:20:30,400 --> 00:20:33,120
yeah so uh it's because first of all as

552
00:20:33,120 --> 00:20:34,960
i mentioned in the talk as well the

553
00:20:34,960 --> 00:20:36,559
tests were done on a very limited

554
00:20:36,559 --> 00:20:38,559
infrastructure where we were just

555
00:20:38,559 --> 00:20:40,480
restricted to 15 servers and we were

556
00:20:40,480 --> 00:20:43,120
replicating as many peers possible to

557
00:20:43,120 --> 00:20:46,000
increase the network size if we extend

558
00:20:46,000 --> 00:20:48,080
that to actual bittorrent network which

559
00:20:48,080 --> 00:20:50,240
is having individual resources and the

560
00:20:50,240 --> 00:20:52,240
computation and bandwidth is

561
00:20:52,240 --> 00:20:54,320
separate for each peer

562
00:20:54,320 --> 00:20:56,480
we can utilize that computation and make

563
00:20:56,480 --> 00:20:58,080
the computation more parallel and

564
00:20:58,080 --> 00:21:01,120
increase the performance

565
00:21:01,120 --> 00:21:03,600
hi uh what would happen if two people

566
00:21:03,600 --> 00:21:05,919
wanted to ask access the same block at

567
00:21:05,919 --> 00:21:08,400
one time yeah so for that purpose like

568
00:21:08,400 --> 00:21:10,240
it's not mentioned in this paper but uh

569
00:21:10,240 --> 00:21:12,559
to guarantee uh parallel accesses what

570
00:21:12,559 --> 00:21:14,400
we do is we replicate the blocks in the

571
00:21:14,400 --> 00:21:16,960
network and create several copies of the

572
00:21:16,960 --> 00:21:18,960
same block so that whenever one peer

573
00:21:18,960 --> 00:21:20,559
wants to access

574
00:21:20,559 --> 00:21:22,799
that same block won't be uh

575
00:21:22,799 --> 00:21:24,480
submitted to the other peer and a

576
00:21:24,480 --> 00:21:26,080
different copy and a different position

577
00:21:26,080 --> 00:21:28,840
will be accessed for the next pair

578
00:21:28,840 --> 00:21:31,840
thanks uh i have a quick question uh

579
00:21:31,840 --> 00:21:34,640
well brad sets up uh

580
00:21:34,640 --> 00:21:35,440
uh

581
00:21:35,440 --> 00:21:37,600
how do it sounds like uh you would need

582
00:21:37,600 --> 00:21:39,840
uh everybody all those communication

583
00:21:39,840 --> 00:21:42,320
lines between the peers and the tracker

584
00:21:42,320 --> 00:21:44,799
and the initiator to be secure channels

585
00:21:44,799 --> 00:21:46,480
uh because you assume there's a global

586
00:21:46,480 --> 00:21:47,919
adversary so how do they establish

587
00:21:47,919 --> 00:21:49,280
secure channels do you assume that

588
00:21:49,280 --> 00:21:51,200
everybody knows each other's public key

589
00:21:51,200 --> 00:21:54,159
uh that i think we can just use uh https

590
00:21:54,159 --> 00:21:57,120
or ssl uh communication to establish to

591
00:21:57,120 --> 00:21:58,960
know the identity of everybody right you

592
00:21:58,960 --> 00:21:59,919
need to

593
00:21:59,919 --> 00:22:00,720
like

594
00:22:00,720 --> 00:22:02,640
i need to know that okay this is a

595
00:22:02,640 --> 00:22:04,720
certain peer that i selected and this is

596
00:22:04,720 --> 00:22:06,240
their identity and therefore yeah that

597
00:22:06,240 --> 00:22:07,840
can be established so whenever a peer

598
00:22:07,840 --> 00:22:09,520
wants to join the network he will first

599
00:22:09,520 --> 00:22:11,360
establish that okay i want to be a part

600
00:22:11,360 --> 00:22:12,880
of the network and installing a

601
00:22:12,880 --> 00:22:14,880
bittorrent client at that time the

602
00:22:14,880 --> 00:22:16,480
secure connection can be established

603
00:22:16,480 --> 00:22:18,559
before the communication actually begins

604
00:22:18,559 --> 00:22:20,320
okay thanks thank you

605
00:22:20,320 --> 00:22:22,620
all right let's thank trudean

606
00:22:22,620 --> 00:22:23,450
[Applause]

607
00:22:23,450 --> 00:22:26,640
[Music]

608
00:22:30,320 --> 00:22:32,399
you

