1
00:00:10,480 --> 00:00:12,320
this talk is about malicious peripheral

2
00:00:12,320 --> 00:00:14,240
devices that can compromise your machine

3
00:00:14,240 --> 00:00:15,679
and what we can do to prevent such

4
00:00:15,679 --> 00:00:17,840
compromise from taking place

5
00:00:17,840 --> 00:00:19,439
so in this talk i'm going to focus a

6
00:00:19,439 --> 00:00:20,960
little bit on usb so i'm just going to

7
00:00:20,960 --> 00:00:23,039
give you a very quick summary

8
00:00:23,039 --> 00:00:24,960
on the hardware side there's a host

9
00:00:24,960 --> 00:00:26,960
controller which is a

10
00:00:26,960 --> 00:00:28,560
the master of the usb bus and it's a

11
00:00:28,560 --> 00:00:30,080
device that's physically connected to

12
00:00:30,080 --> 00:00:32,719
the motherboard perhaps via pcie

13
00:00:32,719 --> 00:00:34,559
and then we also have hubs for example

14
00:00:34,559 --> 00:00:36,399
your monitor may contain one or you may

15
00:00:36,399 --> 00:00:38,320
have just a separate one like an adapter

16
00:00:38,320 --> 00:00:39,440
like this

17
00:00:39,440 --> 00:00:42,640
and finally we have peripherals

18
00:00:42,640 --> 00:00:44,480
and on the software side we have drivers

19
00:00:44,480 --> 00:00:45,680
that control each of these hardware

20
00:00:45,680 --> 00:00:47,039
components

21
00:00:47,039 --> 00:00:50,239
now devices can be malicious uh because

22
00:00:50,239 --> 00:00:51,760
they have been designed to do so for

23
00:00:51,760 --> 00:00:54,559
example stuxnet but also firmware of

24
00:00:54,559 --> 00:00:56,719
benign devices can be modified

25
00:00:56,719 --> 00:00:58,399
by compromise machines as was

26
00:00:58,399 --> 00:01:00,559
demonstrated by bad usb

27
00:01:00,559 --> 00:01:02,000
furthermore government agencies have

28
00:01:02,000 --> 00:01:03,840
been known to intercept shipments and

29
00:01:03,840 --> 00:01:05,119
compromise

30
00:01:05,119 --> 00:01:07,760
devices with backdoors and malware

31
00:01:07,760 --> 00:01:09,280
now with this in mind here are a couple

32
00:01:09,280 --> 00:01:11,119
of ways in which malicious peripherals

33
00:01:11,119 --> 00:01:13,040
can harm your machine

34
00:01:13,040 --> 00:01:15,439
so a device can issue a particularly

35
00:01:15,439 --> 00:01:17,200
crafted payload that exploits a drive of

36
00:01:17,200 --> 00:01:19,520
vulnerability now we all know that

37
00:01:19,520 --> 00:01:21,119
drivers are pretty hard to get right so

38
00:01:21,119 --> 00:01:23,200
it's not surprising that this year alone

39
00:01:23,200 --> 00:01:25,040
we've seen reports of

40
00:01:25,040 --> 00:01:26,720
13 vulnerabilities already and this is

41
00:01:26,720 --> 00:01:29,920
only for the linux's usb stack i mean

42
00:01:29,920 --> 00:01:32,240
other peripherals and also other

43
00:01:32,240 --> 00:01:34,880
operating systems show a similar pattern

44
00:01:34,880 --> 00:01:36,720
another attack vector is direct memory

45
00:01:36,720 --> 00:01:39,680
access so devices can leverage dma to

46
00:01:39,680 --> 00:01:41,200
write anywhere in memory and this is

47
00:01:41,200 --> 00:01:42,960
particularly problematic since dma

48
00:01:42,960 --> 00:01:46,560
bypasses the cpu and also bypasses most

49
00:01:46,560 --> 00:01:48,880
software defenses now to be fair

50
00:01:48,880 --> 00:01:50,799
in the context of usb this type of

51
00:01:50,799 --> 00:01:52,399
attack does require compromising the

52
00:01:52,399 --> 00:01:53,680
host controller

53
00:01:53,680 --> 00:01:55,360
or one of its drivers but such

54
00:01:55,360 --> 00:01:58,240
compromise can take place

55
00:01:58,240 --> 00:01:59,759
another example is a device that just

56
00:01:59,759 --> 00:02:01,280
lies to the operating system about its

57
00:02:01,280 --> 00:02:03,280
identity when it is asked

58
00:02:03,280 --> 00:02:05,040
you know what are you the device

59
00:02:05,040 --> 00:02:06,240
obviously we all know that this is a

60
00:02:06,240 --> 00:02:08,000
flash drive but the operating system

61
00:02:08,000 --> 00:02:09,440
doesn't know that so it'll accept any

62
00:02:09,440 --> 00:02:10,959
answer

63
00:02:10,959 --> 00:02:12,480
in this example this flash drive is

64
00:02:12,480 --> 00:02:14,560
capable of getting keyboard access and

65
00:02:14,560 --> 00:02:16,720
can therefore have the ability to change

66
00:02:16,720 --> 00:02:19,920
passwords install malware or leak data

67
00:02:19,920 --> 00:02:21,520
sadly raising awareness about the

68
00:02:21,520 --> 00:02:23,120
dangers of sketchy devices has not

69
00:02:23,120 --> 00:02:24,239
really proved to be an effective

70
00:02:24,239 --> 00:02:26,800
solution so far

71
00:02:26,800 --> 00:02:28,640
one last issue is that communication

72
00:02:28,640 --> 00:02:30,640
sent on the bus is transmitted in clear

73
00:02:30,640 --> 00:02:33,280
text so what's even worse

74
00:02:33,280 --> 00:02:35,360
is that usb 2 and below

75
00:02:35,360 --> 00:02:37,440
hubs actually broadcast all messages to

76
00:02:37,440 --> 00:02:39,840
devices so as a result if a device is

77
00:02:39,840 --> 00:02:42,720
promiscuous that device can drop on all

78
00:02:42,720 --> 00:02:45,120
downstream communication

79
00:02:45,120 --> 00:02:46,720
and if the hub is compromised or if the

80
00:02:46,720 --> 00:02:48,160
hub is malicious

81
00:02:48,160 --> 00:02:50,000
then the hub can inspect all traffic

82
00:02:50,000 --> 00:02:51,840
downstream or upstream and you can even

83
00:02:51,840 --> 00:02:54,160
modify that traffic

84
00:02:54,160 --> 00:02:56,319
so what can we do about this issues well

85
00:02:56,319 --> 00:02:57,680
fortunately there are a couple of really

86
00:02:57,680 --> 00:02:59,599
good solutions so the first one is just

87
00:02:59,599 --> 00:03:01,519
to stop using computers

88
00:03:01,519 --> 00:03:02,640
now

89
00:03:02,640 --> 00:03:04,400
another alternative is just to close all

90
00:03:04,400 --> 00:03:06,159
the ports now this becomes a little bit

91
00:03:06,159 --> 00:03:07,840
problematic if you have a new laptop

92
00:03:07,840 --> 00:03:09,840
because typically new laptops only have

93
00:03:09,840 --> 00:03:11,840
one port and they share that for power

94
00:03:11,840 --> 00:03:13,840
as well

95
00:03:13,840 --> 00:03:15,519
both of these solutions promote

96
00:03:15,519 --> 00:03:18,000
isolationism though and instead what we

97
00:03:18,000 --> 00:03:19,040
would like

98
00:03:19,040 --> 00:03:20,560
is we would like to enable control

99
00:03:20,560 --> 00:03:23,360
interactions in this adversarial world

100
00:03:23,360 --> 00:03:24,879
but here's the thing

101
00:03:24,879 --> 00:03:26,799
our machine already interacts in an

102
00:03:26,799 --> 00:03:27,920
adversarial

103
00:03:27,920 --> 00:03:29,519
world every day

104
00:03:29,519 --> 00:03:31,360
when we're connected to the internet you

105
00:03:31,360 --> 00:03:33,040
see our machine already has logic that

106
00:03:33,040 --> 00:03:34,640
determines and verifies what he's

107
00:03:34,640 --> 00:03:35,760
talking to

108
00:03:35,760 --> 00:03:37,440
he has logic to prevent eavesdropping

109
00:03:37,440 --> 00:03:39,200
and data tampering and there are even

110
00:03:39,200 --> 00:03:40,480
tools that defend the machine from

111
00:03:40,480 --> 00:03:42,159
malicious traffic

112
00:03:42,159 --> 00:03:43,519
so i think one question that we should

113
00:03:43,519 --> 00:03:46,239
be asking ourselves is how can we port

114
00:03:46,239 --> 00:03:48,720
this solutions to the bus context

115
00:03:48,720 --> 00:03:50,720
now one option of course is just to

116
00:03:50,720 --> 00:03:52,879
modify the motherboard the bus protocols

117
00:03:52,879 --> 00:03:54,879
and the hardware however we want to

118
00:03:54,879 --> 00:03:57,200
ensure that our proposal is deployable

119
00:03:57,200 --> 00:03:58,879
so we don't want to modify the uh we

120
00:03:58,879 --> 00:04:01,760
don't have want to have to modify the

121
00:04:01,760 --> 00:04:03,120
the motherboard we don't want to have to

122
00:04:03,120 --> 00:04:05,040
modify operating systems and we

123
00:04:05,040 --> 00:04:06,799
definitely don't want to modify billions

124
00:04:06,799 --> 00:04:08,400
of peripheral devices that are already

125
00:04:08,400 --> 00:04:09,599
out there

126
00:04:09,599 --> 00:04:11,200
now we could also install network

127
00:04:11,200 --> 00:04:14,000
security logic directly in the usb stack

128
00:04:14,000 --> 00:04:15,519
but the problem here is that we need to

129
00:04:15,519 --> 00:04:17,040
ensure that the bus is kept at arm's

130
00:04:17,040 --> 00:04:19,040
length so you cannot perform dma or

131
00:04:19,040 --> 00:04:20,560
compromise low-level drivers that do

132
00:04:20,560 --> 00:04:22,479
among other things demultiplexing and

133
00:04:22,479 --> 00:04:25,759
deal with like providing power

134
00:04:25,759 --> 00:04:27,280
and well there's a lot of related work

135
00:04:27,280 --> 00:04:28,800
and i'm going to discuss a lot of this

136
00:04:28,800 --> 00:04:30,320
later in the talk i think it's fair to

137
00:04:30,320 --> 00:04:32,080
say that cinch is the first word to

138
00:04:32,080 --> 00:04:34,400
respond to all of these questions

139
00:04:34,400 --> 00:04:36,400
sinch makes deploying network defenses

140
00:04:36,400 --> 00:04:38,479
naturally in the bus context and based

141
00:04:38,479 --> 00:04:41,120
on our security evaluation we find that

142
00:04:41,120 --> 00:04:42,560
cinch is effective at addressing the

143
00:04:42,560 --> 00:04:44,720
threats that i just described although

144
00:04:44,720 --> 00:04:46,880
to be fair it is not perfect

145
00:04:46,880 --> 00:04:48,560
our implementation of cinch is backwards

146
00:04:48,560 --> 00:04:51,120
compatible and is also portable

147
00:04:51,120 --> 00:04:53,280
in particular it works across completely

148
00:04:53,280 --> 00:04:55,199
unmodified operating systems we tested

149
00:04:55,199 --> 00:04:56,960
several versions of windows we also

150
00:04:56,960 --> 00:04:59,759
tested linux and freebsd

151
00:04:59,759 --> 00:05:01,199
cinch separates the bus from your

152
00:05:01,199 --> 00:05:03,039
machine and creates an interposition

153
00:05:03,039 --> 00:05:04,720
point where enforcement policies can be

154
00:05:04,720 --> 00:05:08,000
used to ensure safe interactions

155
00:05:08,000 --> 00:05:09,680
now in the rest of this talk i'm going

156
00:05:09,680 --> 00:05:12,320
to discuss how we actually build cinch

157
00:05:12,320 --> 00:05:14,639
the types of defenses that we implement

158
00:05:14,639 --> 00:05:16,160
and the effectiveness and cost of these

159
00:05:16,160 --> 00:05:18,000
defenses

160
00:05:18,000 --> 00:05:19,520
so i'm going to start by describing how

161
00:05:19,520 --> 00:05:20,800
we separate the bus from the rest of the

162
00:05:20,800 --> 00:05:21,919
system

163
00:05:21,919 --> 00:05:23,440
so here's what our current architecture

164
00:05:23,440 --> 00:05:25,600
looks like the bus is directly connected

165
00:05:25,600 --> 00:05:26,960
to your machine so it has a chance to

166
00:05:26,960 --> 00:05:28,720
perform dma attacks or issue malicious

167
00:05:28,720 --> 00:05:30,000
payloads

168
00:05:30,000 --> 00:05:31,360
here's an abstract view of what we

169
00:05:31,360 --> 00:05:32,479
really want

170
00:05:32,479 --> 00:05:33,919
so we want to take the bus and we want

171
00:05:33,919 --> 00:05:35,280
to make a remote

172
00:05:35,280 --> 00:05:36,880
and then we want to reconnect it to your

173
00:05:36,880 --> 00:05:39,440
machine with some communication channel

174
00:05:39,440 --> 00:05:42,240
that is amenable to interposition

175
00:05:42,240 --> 00:05:44,080
now one possible way to achieve this

176
00:05:44,080 --> 00:05:46,400
abstraction is to just simply use two

177
00:05:46,400 --> 00:05:47,600
machines

178
00:05:47,600 --> 00:05:50,000
now under this proposal

179
00:05:50,000 --> 00:05:51,520
we can just plug devices to the

180
00:05:51,520 --> 00:05:53,280
sacrificial machine and then we can

181
00:05:53,280 --> 00:05:56,000
export this device's via some network

182
00:05:56,000 --> 00:05:57,440
and then this is going to ensure that

183
00:05:57,440 --> 00:05:59,440
any dma attack or attacks on low level

184
00:05:59,440 --> 00:06:01,199
drivers only affect the sacrificial

185
00:06:01,199 --> 00:06:03,120
machine and that we can interpose an all

186
00:06:03,120 --> 00:06:04,960
communication before it has a chance to

187
00:06:04,960 --> 00:06:06,319
reach the protected machine which is the

188
00:06:06,319 --> 00:06:08,240
one on the left

189
00:06:08,240 --> 00:06:09,680
now the obvious downside of this

190
00:06:09,680 --> 00:06:10,960
approach is that it requires two

191
00:06:10,960 --> 00:06:12,080
machines

192
00:06:12,080 --> 00:06:14,639
uh so one might wonder can we do it with

193
00:06:14,639 --> 00:06:15,840
just one

194
00:06:15,840 --> 00:06:17,280
and the answer is yes

195
00:06:17,280 --> 00:06:18,639
and i'm going to show you how we do it

196
00:06:18,639 --> 00:06:21,360
using virtual machines in the paper we

197
00:06:21,360 --> 00:06:22,560
also describe other possible

198
00:06:22,560 --> 00:06:25,199
instantiations

199
00:06:25,199 --> 00:06:27,120
so usually just just a brief primary

200
00:06:27,120 --> 00:06:28,800
virtualization usually the way virtual

201
00:06:28,800 --> 00:06:29,759
machines

202
00:06:29,759 --> 00:06:31,199
communicate with devices is through a

203
00:06:31,199 --> 00:06:32,800
virtual device

204
00:06:32,800 --> 00:06:34,960
that is emulated by the hypervisor

205
00:06:34,960 --> 00:06:36,160
now one of the reasons that the

206
00:06:36,160 --> 00:06:38,479
hypervisor emulates devices instead of

207
00:06:38,479 --> 00:06:41,600
giving direct devices access to vms

208
00:06:41,600 --> 00:06:43,680
is that dma capable devices have access

209
00:06:43,680 --> 00:06:45,919
to all of memory and this also includes

210
00:06:45,919 --> 00:06:49,039
the hypervisor's memory

211
00:06:49,039 --> 00:06:51,360
which means that if the vm were

212
00:06:51,360 --> 00:06:54,240
malicious and you were given access to

213
00:06:54,240 --> 00:06:56,400
the device direct access to the device

214
00:06:56,400 --> 00:06:58,240
then it could use the device's dma

215
00:06:58,240 --> 00:07:00,639
ability to compromise the hypervisor

216
00:07:00,639 --> 00:07:02,080
however recent processors and

217
00:07:02,080 --> 00:07:04,240
motherboards now include an immune which

218
00:07:04,240 --> 00:07:06,319
is a piece of hardware that restricts

219
00:07:06,319 --> 00:07:08,400
wearing memory a device can write

220
00:07:08,400 --> 00:07:10,319
and so as a result the hypervisor can

221
00:07:10,319 --> 00:07:11,840
give the vm direct control over the

222
00:07:11,840 --> 00:07:13,680
device without having to worry about the

223
00:07:13,680 --> 00:07:15,280
device being able to

224
00:07:15,280 --> 00:07:17,360
compromise the hypervisor's address

225
00:07:17,360 --> 00:07:18,240
space

226
00:07:18,240 --> 00:07:20,400
so in effect an imu can be used to

227
00:07:20,400 --> 00:07:22,639
prevent unwanted dma which is a critical

228
00:07:22,639 --> 00:07:24,080
feature that we need in order to

229
00:07:24,080 --> 00:07:26,240
separate the bus

230
00:07:26,240 --> 00:07:28,080
now we can revisit today's architecture

231
00:07:28,080 --> 00:07:30,319
and see how we can actually apply

232
00:07:30,319 --> 00:07:32,160
virtualization to separate the bus in in

233
00:07:32,160 --> 00:07:33,599
a very natural way

234
00:07:33,599 --> 00:07:34,960
so the first thing we do is we just

235
00:07:34,960 --> 00:07:37,360
instantiate both machines as vms

236
00:07:37,360 --> 00:07:38,319
and then we're just going to add a

237
00:07:38,319 --> 00:07:40,400
network between them an internal network

238
00:07:40,400 --> 00:07:41,840
and then we're just going to use the

239
00:07:41,840 --> 00:07:43,759
immu to map

240
00:07:43,759 --> 00:07:44,879
the

241
00:07:44,879 --> 00:07:47,280
bus to the sacrificial machine and so

242
00:07:47,280 --> 00:07:48,720
this gives us the precise abstraction

243
00:07:48,720 --> 00:07:51,120
that we were looking for

244
00:07:51,120 --> 00:07:53,039
so now that we have this architecture

245
00:07:53,039 --> 00:07:55,599
all we need to do is insert an enforcer

246
00:07:55,599 --> 00:07:57,680
that interposes all traffic

247
00:07:57,680 --> 00:08:00,240
now internally this enforcer is really

248
00:08:00,240 --> 00:08:02,479
just a set of middle boxes or modules

249
00:08:02,479 --> 00:08:04,560
that will act on packets and so these

250
00:08:04,560 --> 00:08:06,319
modules can be arranged in a chain as i

251
00:08:06,319 --> 00:08:08,160
depicted here

252
00:08:08,160 --> 00:08:09,520
so the output of one module can be the

253
00:08:09,520 --> 00:08:11,360
input of the next or they can be

254
00:08:11,360 --> 00:08:12,720
arranged in parallel so you can have

255
00:08:12,720 --> 00:08:14,080
multiple chains

256
00:08:14,080 --> 00:08:15,599
and the design of the enforcer is

257
00:08:15,599 --> 00:08:17,919
inspired by the click modular router so

258
00:08:17,919 --> 00:08:19,680
one of the benefits is that writing a

259
00:08:19,680 --> 00:08:21,440
new module and plugging it in is

260
00:08:21,440 --> 00:08:24,240
actually very easy

261
00:08:24,400 --> 00:08:25,759
now let's turn to the defense that we

262
00:08:25,759 --> 00:08:28,400
can actually build on this architecture

263
00:08:28,400 --> 00:08:30,319
so the first defense is just to ensure

264
00:08:30,319 --> 00:08:32,479
that devices interact with usb drivers

265
00:08:32,479 --> 00:08:34,559
in a way that is consistent with the usb

266
00:08:34,559 --> 00:08:36,000
protocol

267
00:08:36,000 --> 00:08:37,679
to achieve this what we do is we just go

268
00:08:37,679 --> 00:08:38,880
through several of the usb

269
00:08:38,880 --> 00:08:40,479
specifications and then we drag

270
00:08:40,479 --> 00:08:41,919
constraints on the different types of

271
00:08:41,919 --> 00:08:44,080
usb packets and so these constraints

272
00:08:44,080 --> 00:08:45,440
cover packet formats they cover

273
00:08:45,440 --> 00:08:47,519
individual fields and they also cover

274
00:08:47,519 --> 00:08:49,200
packet sequences

275
00:08:49,200 --> 00:08:50,880
and so one example of an individual

276
00:08:50,880 --> 00:08:53,040
field constraint will be ensuring that a

277
00:08:53,040 --> 00:08:54,640
particular value is not restricted or

278
00:08:54,640 --> 00:08:57,120
the proper encoding is used

279
00:08:57,120 --> 00:08:58,080
um

280
00:08:58,080 --> 00:08:59,360
and then we can use this constraints to

281
00:08:59,360 --> 00:09:01,120
build a state machine and this is going

282
00:09:01,120 --> 00:09:02,800
to allow us to keep a history of the

283
00:09:02,800 --> 00:09:05,279
package that we've seen so far uh and

284
00:09:05,279 --> 00:09:07,040
then given an incoming packet we can

285
00:09:07,040 --> 00:09:09,680
decide if we want to allow it or not

286
00:09:09,680 --> 00:09:11,200
now this is a very simple type of

287
00:09:11,200 --> 00:09:12,880
defense but it is actually quite

288
00:09:12,880 --> 00:09:15,920
effective against many types of attacks

289
00:09:15,920 --> 00:09:17,920
however there are still exploits out

290
00:09:17,920 --> 00:09:19,760
there that follow every single line of

291
00:09:19,760 --> 00:09:21,680
the usb specification and even while

292
00:09:21,680 --> 00:09:23,279
doing that they can still compromise

293
00:09:23,279 --> 00:09:24,560
your machine

294
00:09:24,560 --> 00:09:26,800
and this brings me to defense number two

295
00:09:26,800 --> 00:09:28,640
in defense number two uh the goal is

296
00:09:28,640 --> 00:09:30,320
just to keep a database of non-malicious

297
00:09:30,320 --> 00:09:31,440
payloads and this is just going to be

298
00:09:31,440 --> 00:09:33,040
similar to the way anti-viruses

299
00:09:33,040 --> 00:09:34,560
firewalls or some intrusion detection

300
00:09:34,560 --> 00:09:36,240
systems work and then we're just going

301
00:09:36,240 --> 00:09:38,399
to spec traffic and we're going to look

302
00:09:38,399 --> 00:09:39,760
for matches in this database and if

303
00:09:39,760 --> 00:09:40,880
there's a match we're just going to

304
00:09:40,880 --> 00:09:42,480
reject the interaction of the device so

305
00:09:42,480 --> 00:09:44,560
this is very similar to say it's north

306
00:09:44,560 --> 00:09:47,279
but for usb

307
00:09:47,279 --> 00:09:49,200
so one obvious benefit of this approach

308
00:09:49,200 --> 00:09:51,600
is that typically deriving a signature

309
00:09:51,600 --> 00:09:53,839
is easier than figuring out where in the

310
00:09:53,839 --> 00:09:56,320
source code a particular bug is

311
00:09:56,320 --> 00:09:57,839
another benefit is that it makes it

312
00:09:57,839 --> 00:10:00,000
possible for users and i.t departments

313
00:10:00,000 --> 00:10:02,240
to react quickly without having to wait

314
00:10:02,240 --> 00:10:04,880
for os vendors to release a patch

315
00:10:04,880 --> 00:10:06,320
now the obvious downside of this

316
00:10:06,320 --> 00:10:07,839
approach is that we need a signature so

317
00:10:07,839 --> 00:10:09,600
this is completely useless against zero

318
00:10:09,600 --> 00:10:11,680
day attacks

319
00:10:11,680 --> 00:10:13,120
there's also some tension between

320
00:10:13,120 --> 00:10:15,279
protection and compatibility so

321
00:10:15,279 --> 00:10:17,200
on one extreme point we can just choose

322
00:10:17,200 --> 00:10:19,600
to match every single packet and drop it

323
00:10:19,600 --> 00:10:21,360
and this will prevent against many

324
00:10:21,360 --> 00:10:22,800
attacks but

325
00:10:22,800 --> 00:10:24,079
this is not much different than just

326
00:10:24,079 --> 00:10:25,680
closing all the ports so it's gonna just

327
00:10:25,680 --> 00:10:27,760
ruin uh functionality

328
00:10:27,760 --> 00:10:29,040
and then on the other extreme point we

329
00:10:29,040 --> 00:10:30,640
can just let everything through and

330
00:10:30,640 --> 00:10:32,640
that's to retain functionality but it's

331
00:10:32,640 --> 00:10:33,839
going to do nothing for security and

332
00:10:33,839 --> 00:10:35,760
then finding a good balance between

333
00:10:35,760 --> 00:10:37,920
these two is actually quite challenging

334
00:10:37,920 --> 00:10:39,279
and the last limitation of course is

335
00:10:39,279 --> 00:10:40,560
that signatures don't really solve the

336
00:10:40,560 --> 00:10:42,560
underlying issue you know one can still

337
00:10:42,560 --> 00:10:44,800
exploit the same vulnerability with a

338
00:10:44,800 --> 00:10:47,360
different payload

339
00:10:47,360 --> 00:10:48,640
our third defense is adding

340
00:10:48,640 --> 00:10:51,200
authentication and encryption to the bus

341
00:10:51,200 --> 00:10:52,800
so imagine a scenario here where we have

342
00:10:52,800 --> 00:10:54,320
a trusted device

343
00:10:54,320 --> 00:10:55,839
manufacturer that installs a signed

344
00:10:55,839 --> 00:10:58,560
certificate into a device's firmware so

345
00:10:58,560 --> 00:11:00,000
under this arrangement it should be

346
00:11:00,000 --> 00:11:01,600
possible for the device to just prove

347
00:11:01,600 --> 00:11:03,440
its identity to your machine

348
00:11:03,440 --> 00:11:05,040
so this will prevent other devices from

349
00:11:05,040 --> 00:11:06,880
masquerading as

350
00:11:06,880 --> 00:11:08,959
i guess in this case this keyboard

351
00:11:08,959 --> 00:11:11,600
now if we revisit cinch's architecture

352
00:11:11,600 --> 00:11:13,519
what we see immediately is that we still

353
00:11:13,519 --> 00:11:14,560
have problems since all the

354
00:11:14,560 --> 00:11:16,160
communication on the bus is in clear

355
00:11:16,160 --> 00:11:18,399
text and is unauthenticated which means

356
00:11:18,399 --> 00:11:20,000
that a malicious hub can impersonate

357
00:11:20,000 --> 00:11:21,600
devices or it can even drop on all

358
00:11:21,600 --> 00:11:23,040
communication

359
00:11:23,040 --> 00:11:25,440
however under synch we can actually

360
00:11:25,440 --> 00:11:28,000
install tls endpoints at the device and

361
00:11:28,000 --> 00:11:30,720
another tls endpoint on the enforcer

362
00:11:30,720 --> 00:11:32,480
and as a result we can ensure that all

363
00:11:32,480 --> 00:11:34,160
communication on the bus is encrypted

364
00:11:34,160 --> 00:11:36,000
and authenticated

365
00:11:36,000 --> 00:11:37,519
and then what we can do is we can add

366
00:11:37,519 --> 00:11:39,040
logic at the enforcer that for example

367
00:11:39,040 --> 00:11:41,200
disallow certain unauthenticated devices

368
00:11:41,200 --> 00:11:43,360
for example we might not want to have

369
00:11:43,360 --> 00:11:45,440
uh unauthenticated keyboards but maybe

370
00:11:45,440 --> 00:11:46,880
we're okay having

371
00:11:46,880 --> 00:11:48,560
an unauthenticated device that only

372
00:11:48,560 --> 00:11:50,000
draws power so you can you can have this

373
00:11:50,000 --> 00:11:51,519
kind of

374
00:11:51,519 --> 00:11:52,880
functionality

375
00:11:52,880 --> 00:11:54,480
now notice that communication between

376
00:11:54,480 --> 00:11:56,880
the enforcer and your machine remains

377
00:11:56,880 --> 00:11:58,800
completely in clear text and this is to

378
00:11:58,800 --> 00:12:00,160
preserve our goal of backwards

379
00:12:00,160 --> 00:12:02,320
compatibility

380
00:12:02,320 --> 00:12:04,240
now a major issue is that

381
00:12:04,240 --> 00:12:06,160
existing devices don't really support

382
00:12:06,160 --> 00:12:07,680
tls

383
00:12:07,680 --> 00:12:10,000
so what we do is we just build

384
00:12:10,000 --> 00:12:12,480
an adapter and one thing that we found

385
00:12:12,480 --> 00:12:14,959
is that this adapter is actually cheap

386
00:12:14,959 --> 00:12:16,800
and straightforward to build

387
00:12:16,800 --> 00:12:18,560
and in the paper we describe the details

388
00:12:18,560 --> 00:12:20,800
of how we build this adapter and how we

389
00:12:20,800 --> 00:12:22,720
actually create a tls session without

390
00:12:22,720 --> 00:12:26,639
having to modify the usb protocol at all

391
00:12:26,639 --> 00:12:28,320
now in addition to the three defenses

392
00:12:28,320 --> 00:12:29,839
that i've highlighted here

393
00:12:29,839 --> 00:12:31,839
we also discuss others in the paper so

394
00:12:31,839 --> 00:12:33,360
for example we have a mechanism for

395
00:12:33,360 --> 00:12:35,279
logging and replaying interactions with

396
00:12:35,279 --> 00:12:36,480
devices

397
00:12:36,480 --> 00:12:38,639
we also have a way of sending all bus

398
00:12:38,639 --> 00:12:40,959
traffic to our real-time remotes remote

399
00:12:40,959 --> 00:12:43,040
server perhaps for auditing

400
00:12:43,040 --> 00:12:44,320
we also

401
00:12:44,320 --> 00:12:46,720
can export device functionality via a

402
00:12:46,720 --> 00:12:48,880
higher level protocol for example we can

403
00:12:48,880 --> 00:12:53,560
access a webcam feed using http

404
00:12:53,680 --> 00:12:55,360
so now that we've discussed the types of

405
00:12:55,360 --> 00:12:57,600
defenses that we can build on singh um i

406
00:12:57,600 --> 00:12:59,279
can answer two questions uh the first

407
00:12:59,279 --> 00:13:01,519
one is how well do these defenses work

408
00:13:01,519 --> 00:13:03,839
and what is their cost

409
00:13:03,839 --> 00:13:05,200
so i'm going to answer these questions

410
00:13:05,200 --> 00:13:06,800
in the context of our prototype

411
00:13:06,800 --> 00:13:08,320
implementation so

412
00:13:08,320 --> 00:13:10,320
in our case the hypervisor is just linux

413
00:13:10,320 --> 00:13:12,560
jvm and the enforcer is just a user

414
00:13:12,560 --> 00:13:14,560
level process uh

415
00:13:14,560 --> 00:13:16,720
that is written in rust

416
00:13:16,720 --> 00:13:18,959
we built the tls adapter on an arm based

417
00:13:18,959 --> 00:13:20,399
embedded computer

418
00:13:20,399 --> 00:13:22,560
and other exploits are implemented using

419
00:13:22,560 --> 00:13:24,480
a phased answer 21 which is a device

420
00:13:24,480 --> 00:13:26,000
that can be used to emulate arbitrary

421
00:13:26,000 --> 00:13:27,600
usb devices

422
00:13:27,600 --> 00:13:29,120
it's this device here depicted on this

423
00:13:29,120 --> 00:13:30,880
slide

424
00:13:30,880 --> 00:13:33,040
so let's talk about effectiveness first

425
00:13:33,040 --> 00:13:34,800
so we evaluated cinch's defenses in

426
00:13:34,800 --> 00:13:36,560
three different ways

427
00:13:36,560 --> 00:13:38,480
so each set of these experiments gave us

428
00:13:38,480 --> 00:13:40,240
a better understanding of the strengths

429
00:13:40,240 --> 00:13:41,920
and weaknesses of cinch

430
00:13:41,920 --> 00:13:43,279
so in this talk i'm going to focus on

431
00:13:43,279 --> 00:13:44,720
the first two and then you can find the

432
00:13:44,720 --> 00:13:46,880
third one in the paper

433
00:13:46,880 --> 00:13:49,600
so the first experiment consists of

434
00:13:49,600 --> 00:13:51,199
implementing and testing exploits for

435
00:13:51,199 --> 00:13:54,240
many existing usb driver vulnerabilities

436
00:13:54,240 --> 00:13:56,320
uh so the goal here was to get an idea

437
00:13:56,320 --> 00:13:59,040
of what would happen if sinch had been

438
00:13:59,040 --> 00:14:00,399
deployed prior to finding these

439
00:14:00,399 --> 00:14:02,320
vulnerabilities

440
00:14:02,320 --> 00:14:04,959
and what we find is that 16 out of 18

441
00:14:04,959 --> 00:14:06,880
exploits were prevented immediately by

442
00:14:06,880 --> 00:14:08,639
an out-of-the-box configuration of sync

443
00:14:08,639 --> 00:14:10,079
so we didn't have to install any

444
00:14:10,079 --> 00:14:12,240
signatures we didn't have to

445
00:14:12,240 --> 00:14:14,000
do anything special

446
00:14:14,000 --> 00:14:15,920
and the remaining two exploits uh both

447
00:14:15,920 --> 00:14:18,079
of this which affected linux

448
00:14:18,079 --> 00:14:19,920
were actually able to compromise drivers

449
00:14:19,920 --> 00:14:21,519
in the protected machine and the reason

450
00:14:21,519 --> 00:14:23,680
for this is that this exploits were

451
00:14:23,680 --> 00:14:25,040
fully compliant with the usb

452
00:14:25,040 --> 00:14:27,199
specification and they mostly targeted

453
00:14:27,199 --> 00:14:28,720
really poor logic in the drivers so it

454
00:14:28,720 --> 00:14:30,160
was very hard to prevent just with an

455
00:14:30,160 --> 00:14:32,399
out of box configuration

456
00:14:32,399 --> 00:14:34,320
however once we derive signatures for

457
00:14:34,320 --> 00:14:36,320
this exploits we can actually prevent

458
00:14:36,320 --> 00:14:38,000
this exploits from compromising this and

459
00:14:38,000 --> 00:14:41,040
other machines in the future

460
00:14:41,279 --> 00:14:43,120
we also conduct a three-phase

461
00:14:43,120 --> 00:14:45,120
penetration testing exercise to ensure

462
00:14:45,120 --> 00:14:47,199
that cinch's effectiveness is not really

463
00:14:47,199 --> 00:14:49,279
a by-product of

464
00:14:49,279 --> 00:14:51,600
us knowing the attacks ahead of time

465
00:14:51,600 --> 00:14:53,279
and what we do is we introduce a red

466
00:14:53,279 --> 00:14:54,959
team which is a group of people who are

467
00:14:54,959 --> 00:14:57,120
in charge of writing and testing

468
00:14:57,120 --> 00:14:59,199
exploits and one thing to note is that

469
00:14:59,199 --> 00:15:00,560
the red team was not involved in the

470
00:15:00,560 --> 00:15:02,480
development of cinch at all

471
00:15:02,480 --> 00:15:04,079
so as we go through the phases what we

472
00:15:04,079 --> 00:15:05,760
do is we disclose more information about

473
00:15:05,760 --> 00:15:08,079
cinch to this red team and the goal here

474
00:15:08,079 --> 00:15:09,839
really is to model an attacker that has

475
00:15:09,839 --> 00:15:12,320
ever greater knowledge of cinch

476
00:15:12,320 --> 00:15:14,160
and then the red team just has their

477
00:15:14,160 --> 00:15:16,480
exploits on a machine without cinch and

478
00:15:16,480 --> 00:15:18,720
i'm shooting with cinch and what we find

479
00:15:18,720 --> 00:15:20,480
it's i guess it's a bit intuitive which

480
00:15:20,480 --> 00:15:21,360
is that

481
00:15:21,360 --> 00:15:22,959
as the red team learned more about sench

482
00:15:22,959 --> 00:15:25,519
they were able to to craft a more

483
00:15:25,519 --> 00:15:27,199
intricate exploit that sort of bypass

484
00:15:27,199 --> 00:15:29,360
sort of the security of cinch and then

485
00:15:29,360 --> 00:15:31,279
the second is that the red team quickly

486
00:15:31,279 --> 00:15:32,880
realized that exploits that respect the

487
00:15:32,880 --> 00:15:34,399
usb specification and they are

488
00:15:34,399 --> 00:15:36,320
polymorphic by polymorphic i really mean

489
00:15:36,320 --> 00:15:37,120
that

490
00:15:37,120 --> 00:15:38,800
the same exploit just sort of changes

491
00:15:38,800 --> 00:15:40,399
the payload on every run

492
00:15:40,399 --> 00:15:41,759
and so signatures don't really don't

493
00:15:41,759 --> 00:15:43,360
really work for that

494
00:15:43,360 --> 00:15:44,959
those type of exploits cannot be

495
00:15:44,959 --> 00:15:48,000
prevented by saints at all

496
00:15:48,399 --> 00:15:49,759
now we can talk about sort of what is

497
00:15:49,759 --> 00:15:52,240
the cost of these defenses

498
00:15:52,240 --> 00:15:54,240
and i'm going to answer this question uh

499
00:15:54,240 --> 00:15:55,759
compared to a baseline so the best

500
00:15:55,759 --> 00:15:58,000
baseline here is just connecting devices

501
00:15:58,000 --> 00:15:59,279
directly to your machine so there's no

502
00:15:59,279 --> 00:16:01,199
virtualization there's no tls adapter no

503
00:16:01,199 --> 00:16:03,519
enforcer nothing

504
00:16:03,519 --> 00:16:05,519
and then we run two experiments so in

505
00:16:05,519 --> 00:16:07,680
the first experiment we transfer a one

506
00:16:07,680 --> 00:16:10,399
gigabyte file to a usb uh

507
00:16:10,399 --> 00:16:12,000
ssd

508
00:16:12,000 --> 00:16:13,519
and then we report throughput the memory

509
00:16:13,519 --> 00:16:15,680
and the cpu cycles use and what we find

510
00:16:15,680 --> 00:16:18,079
is that under cinch throughput is 38

511
00:16:18,079 --> 00:16:19,759
lower and this is primarily due to

512
00:16:19,759 --> 00:16:21,279
memory copies at many points in the

513
00:16:21,279 --> 00:16:23,199
stack

514
00:16:23,199 --> 00:16:24,880
also memory overhead is about 200

515
00:16:24,880 --> 00:16:27,279
megabytes which is mostly for the

516
00:16:27,279 --> 00:16:29,440
sacrificial vm

517
00:16:29,440 --> 00:16:32,560
now this is high but keep in mind that

518
00:16:32,560 --> 00:16:34,160
it is roughly on the same ballpark as

519
00:16:34,160 --> 00:16:36,639
having one or two browser tabs

520
00:16:36,639 --> 00:16:38,639
um the cpu overhead is also high it's

521
00:16:38,639 --> 00:16:41,120
about 8x uh but and

522
00:16:41,120 --> 00:16:42,880
but the absolute the so this is the

523
00:16:42,880 --> 00:16:44,240
relative overhead but the absolute

524
00:16:44,240 --> 00:16:45,519
overhead is actually not that bad

525
00:16:45,519 --> 00:16:47,920
because uh the the cpu cost of

526
00:16:47,920 --> 00:16:50,079
transferring a one gigabyte file was not

527
00:16:50,079 --> 00:16:52,160
high to begin with

528
00:16:52,160 --> 00:16:54,160
so for the second experiment uh what we

529
00:16:54,160 --> 00:16:56,240
do is we connect the usb adapter we

530
00:16:56,240 --> 00:16:58,639
connect a usb ethernet adapter so to the

531
00:16:58,639 --> 00:17:00,240
operating system this looks basically

532
00:17:00,240 --> 00:17:01,759
like a network card

533
00:17:01,759 --> 00:17:03,120
and then on the other end of this

534
00:17:03,120 --> 00:17:05,919
adapter we just plug another machine and

535
00:17:05,919 --> 00:17:07,439
then we do a ping test and so this is

536
00:17:07,439 --> 00:17:09,919
going to let us measure the rtt between

537
00:17:09,919 --> 00:17:11,839
the two machines and what we find is

538
00:17:11,839 --> 00:17:13,520
that we add about two milliseconds of

539
00:17:13,520 --> 00:17:16,000
latent of rtt and this includes all the

540
00:17:16,000 --> 00:17:17,439
encryption and all the processing logic

541
00:17:17,439 --> 00:17:20,640
so we have the adapter here as well

542
00:17:20,640 --> 00:17:22,240
now as i mentioned at the beginning of

543
00:17:22,240 --> 00:17:24,880
the talk sinch makes network defenses

544
00:17:24,880 --> 00:17:26,959
applicable to the bus but it also

545
00:17:26,959 --> 00:17:29,440
inherits all of their limitations

546
00:17:29,440 --> 00:17:31,440
so our signature module is not really

547
00:17:31,440 --> 00:17:33,919
effective against polymorphic attacks

548
00:17:33,919 --> 00:17:35,440
in order to prevent devices from lying

549
00:17:35,440 --> 00:17:37,919
about their identity we need either to

550
00:17:37,919 --> 00:17:40,160
identify trusted manufacturers or we

551
00:17:40,160 --> 00:17:41,840
need ways to bootstrap trust for example

552
00:17:41,840 --> 00:17:43,440
another way would be to use a pairing

553
00:17:43,440 --> 00:17:45,039
procedure like the one found in

554
00:17:45,039 --> 00:17:47,280
bluetooth

555
00:17:47,280 --> 00:17:48,960
the functionality of devices needs to be

556
00:17:48,960 --> 00:17:51,200
augmented or an adapter needs to be used

557
00:17:51,200 --> 00:17:53,679
so that's another limitation and finally

558
00:17:53,679 --> 00:17:55,919
to make the bus remote we require

559
00:17:55,919 --> 00:17:58,000
hardware support for virtualizing io and

560
00:17:58,000 --> 00:18:00,080
what this while the support is available

561
00:18:00,080 --> 00:18:01,919
in most recent processors it is not yet

562
00:18:01,919 --> 00:18:03,360
universal

563
00:18:03,360 --> 00:18:05,520
now there's a lot of work that relates

564
00:18:05,520 --> 00:18:07,120
to cinch in one way or another i mean

565
00:18:07,120 --> 00:18:09,039
aside from the entire field of network

566
00:18:09,039 --> 00:18:10,960
security uh here's just a couple of

567
00:18:10,960 --> 00:18:12,559
areas

568
00:18:12,559 --> 00:18:14,320
so one way to look and see a cinch it

569
00:18:14,320 --> 00:18:15,919
says re-architecting the os in a way

570
00:18:15,919 --> 00:18:17,679
that interacts with uh

571
00:18:17,679 --> 00:18:18,799
devices

572
00:18:18,799 --> 00:18:19,679
so

573
00:18:19,679 --> 00:18:21,440
one word that is particularly related to

574
00:18:21,440 --> 00:18:23,679
cinch is separation kernels

575
00:18:23,679 --> 00:18:25,600
and in fact we share the same view that

576
00:18:25,600 --> 00:18:26,640
separation

577
00:18:26,640 --> 00:18:28,799
and interposition are two critical

578
00:18:28,799 --> 00:18:30,640
properties uh to achieve secure

579
00:18:30,640 --> 00:18:32,000
interactions

580
00:18:32,000 --> 00:18:34,080
now works on driver reliability are

581
00:18:34,080 --> 00:18:35,760
complementary and in many cases they're

582
00:18:35,760 --> 00:18:38,080
also composable with cinch

583
00:18:38,080 --> 00:18:39,919
and in fact making drivers robust

584
00:18:39,919 --> 00:18:43,280
enhances cinches other defenses as well

585
00:18:43,280 --> 00:18:45,200
finally hub plug and device containment

586
00:18:45,200 --> 00:18:46,960
frameworks are good ways of preventing

587
00:18:46,960 --> 00:18:48,640
unauthorized devices from connecting to

588
00:18:48,640 --> 00:18:49,840
your machine

589
00:18:49,840 --> 00:18:51,360
and sort of some of these frameworks can

590
00:18:51,360 --> 00:18:53,039
actually be implemented as modules in

591
00:18:53,039 --> 00:18:54,320
singh

592
00:18:54,320 --> 00:18:56,080
however cinch does suffer from the

593
00:18:56,080 --> 00:18:57,840
limitation that it doesn't really have

594
00:18:57,840 --> 00:19:00,000
visibility inside of the os

595
00:19:00,000 --> 00:19:01,840
so the types of authorization decisions

596
00:19:01,840 --> 00:19:04,080
that it can make are very coarse-grained

597
00:19:04,080 --> 00:19:05,600
and i think in the next talk we're going

598
00:19:05,600 --> 00:19:07,679
to see the benefits of having access to

599
00:19:07,679 --> 00:19:10,640
this inside information

600
00:19:10,640 --> 00:19:11,919
to summarize

601
00:19:11,919 --> 00:19:14,480
cinch provides backward compatible

602
00:19:14,480 --> 00:19:16,240
and portable support

603
00:19:16,240 --> 00:19:17,039
for

604
00:19:17,039 --> 00:19:19,120
implementing network security tools to

605
00:19:19,120 --> 00:19:20,960
the peripheral boss

606
00:19:20,960 --> 00:19:22,640
cinch's enforcer is modular and the

607
00:19:22,640 --> 00:19:25,679
fences are natural and easy to implement

608
00:19:25,679 --> 00:19:27,600
and while cinch is not perfect we

609
00:19:27,600 --> 00:19:29,360
believe that it eliminates some attacks

610
00:19:29,360 --> 00:19:31,679
and increases the barrier for others

611
00:19:31,679 --> 00:19:33,120
with this i conclude my talk and i'm

612
00:19:33,120 --> 00:19:35,700
happy to take any questions

613
00:19:35,700 --> 00:19:36,430
[Applause]

614
00:19:36,430 --> 00:19:37,900
[Music]

615
00:19:37,900 --> 00:19:43,719
[Applause]

616
00:19:45,360 --> 00:19:47,200
rick farrow so

617
00:19:47,200 --> 00:19:50,400
how much do you expose to the user

618
00:19:50,400 --> 00:19:52,640
of the enforcer does it like logging

619
00:19:52,640 --> 00:19:54,640
what it's seeing so it says i just saw

620
00:19:54,640 --> 00:19:56,160
this attack

621
00:19:56,160 --> 00:19:58,160
so

622
00:19:58,160 --> 00:19:59,840
it depends on the modules that are

623
00:19:59,840 --> 00:20:01,600
written in the forces so

624
00:20:01,600 --> 00:20:02,960
the enforcer

625
00:20:02,960 --> 00:20:04,799
the way you configure the enforcer is

626
00:20:04,799 --> 00:20:07,039
there is a we have a configuration file

627
00:20:07,039 --> 00:20:08,799
where you can specify which modules you

628
00:20:08,799 --> 00:20:10,720
want to load and in which arrangement

629
00:20:10,720 --> 00:20:12,159
you want to load them so which which

630
00:20:12,159 --> 00:20:13,679
module you want to act first and so on

631
00:20:13,679 --> 00:20:15,280
and so forth and where do the enforcer

632
00:20:15,280 --> 00:20:16,720
modules run

633
00:20:16,720 --> 00:20:19,760
they run as a user level process in the

634
00:20:19,760 --> 00:20:21,919
hypervisor so the hypervisor

635
00:20:21,919 --> 00:20:24,480
okay and um do you

636
00:20:24,480 --> 00:20:27,360
did you consider the idea of exposing

637
00:20:27,360 --> 00:20:29,200
the user of the device

638
00:20:29,200 --> 00:20:31,919
to what the device was claiming to be

639
00:20:31,919 --> 00:20:33,280
so in other words if you plugged in

640
00:20:33,280 --> 00:20:35,200
something you thought was a

641
00:20:35,200 --> 00:20:37,039
a storage device and it's really a

642
00:20:37,039 --> 00:20:39,200
keyboard that it would actually announce

643
00:20:39,200 --> 00:20:41,760
you know just just as a matter of

644
00:20:41,760 --> 00:20:44,559
information yeah so so we built a module

645
00:20:44,559 --> 00:20:46,720
like that into the enforcer where as

646
00:20:46,720 --> 00:20:48,720
soon as the device is plugged in the

647
00:20:48,720 --> 00:20:50,720
enforcer asks the user you know is this

648
00:20:50,720 --> 00:20:52,000
the device that you meant to plug in and

649
00:20:52,000 --> 00:20:53,840
then you can say yes no but sort of the

650
00:20:53,840 --> 00:20:56,320
key decision of allowing the device to

651
00:20:56,320 --> 00:20:58,159
connect to the protected machine should

652
00:20:58,159 --> 00:20:59,679
be done before it gets a chance to

653
00:20:59,679 --> 00:21:01,919
connect to the machine not not during

654
00:21:01,919 --> 00:21:03,760
the connection process sure yeah that

655
00:21:03,760 --> 00:21:06,720
makes sense okay thank you

656
00:21:08,720 --> 00:21:11,200
amit so devon scilab great talk couple

657
00:21:11,200 --> 00:21:12,559
of questions

658
00:21:12,559 --> 00:21:13,919
number one

659
00:21:13,919 --> 00:21:17,120
were you able to sort of apply

660
00:21:17,120 --> 00:21:20,000
cinch to other buses for example

661
00:21:20,000 --> 00:21:23,280
something like pci so let's say you have

662
00:21:23,280 --> 00:21:25,440
a hard disk that's connected to a pci

663
00:21:25,440 --> 00:21:27,679
bus which is running a firmware

664
00:21:27,679 --> 00:21:30,240
which can do you know a lot of things

665
00:21:30,240 --> 00:21:31,679
these days

666
00:21:31,679 --> 00:21:32,880
i was wondering if you have any

667
00:21:32,880 --> 00:21:34,880
experiments that you've done with such

668
00:21:34,880 --> 00:21:36,880
such buses no we have not experimented

669
00:21:36,880 --> 00:21:39,120
with other buses i think that's sort of

670
00:21:39,120 --> 00:21:41,440
our plan right now okay uh second

671
00:21:41,440 --> 00:21:45,200
question the sacrificial vm that you use

672
00:21:45,200 --> 00:21:47,280
how tiny can it be in terms of the

673
00:21:47,280 --> 00:21:48,480
footprint i mean i'm just trying to

674
00:21:48,480 --> 00:21:51,280
understand whether you need a full-blown

675
00:21:51,280 --> 00:21:53,200
vm or you could run it as an instance

676
00:21:53,200 --> 00:21:55,840
within the hypervisor itself so

677
00:21:55,840 --> 00:21:57,039
so

678
00:21:57,039 --> 00:21:59,200
it basically needs to have

679
00:21:59,200 --> 00:22:04,559
enough of the usb stack to be able to

680
00:22:04,559 --> 00:22:07,600
demultiplex uh devices and then provide

681
00:22:07,600 --> 00:22:09,840
power initially to devices so once you

682
00:22:09,840 --> 00:22:12,000
have and also to manage hubs once you

683
00:22:12,000 --> 00:22:15,120
have that part of the usb stack uh then

684
00:22:15,120 --> 00:22:16,960
that that's really all you need um and

685
00:22:16,960 --> 00:22:18,000
then you need a way to sort of

686
00:22:18,000 --> 00:22:21,600
encapsulate this usb packets into ip we

687
00:22:21,600 --> 00:22:23,760
do tcp so once you have those two things

688
00:22:23,760 --> 00:22:25,039
that's all you need sounds good thank

689
00:22:25,039 --> 00:22:27,919
you so much appreciate it

690
00:22:28,640 --> 00:22:30,080
we're running a little bit ahead of

691
00:22:30,080 --> 00:22:32,080
schedule so if somebody else is awake

692
00:22:32,080 --> 00:22:33,760
and has questions

693
00:22:33,760 --> 00:22:36,400
we have time

694
00:22:37,039 --> 00:22:39,280
uh i have one um maybe you mentioned

695
00:22:39,280 --> 00:22:41,520
this but um if you're in the mode where

696
00:22:41,520 --> 00:22:42,720
you provide authentication and

697
00:22:42,720 --> 00:22:44,960
encryption and you need a dongle how do

698
00:22:44,960 --> 00:22:46,799
you prevent the adversary from sort of

699
00:22:46,799 --> 00:22:48,720
unplugging that and going directly into

700
00:22:48,720 --> 00:22:51,200
to the system i'm assuming that in that

701
00:22:51,200 --> 00:22:53,360
mode you you require any connection to

702
00:22:53,360 --> 00:22:55,120
be authenticated

703
00:22:55,120 --> 00:22:56,960
uh so

704
00:22:56,960 --> 00:22:59,440
let's see so is your question that the

705
00:22:59,440 --> 00:23:02,960
adversary is physically present

706
00:23:02,960 --> 00:23:05,200
uh yeah i think

707
00:23:05,200 --> 00:23:07,520
our we do not provide we do not provide

708
00:23:07,520 --> 00:23:09,039
any mechanisms to prevent the adversary

709
00:23:09,039 --> 00:23:11,039
from unplugging physically the the

710
00:23:11,039 --> 00:23:12,080
dongle

711
00:23:12,080 --> 00:23:14,559
but cinch can have a policy that says

712
00:23:14,559 --> 00:23:16,640
unless the device is authenticated just

713
00:23:16,640 --> 00:23:17,840
don't let it

714
00:23:17,840 --> 00:23:19,520
through so maybe that's a mechanism that

715
00:23:19,520 --> 00:23:23,080
you can use right

716
00:23:23,120 --> 00:23:25,600
is there a question on the way

717
00:23:25,600 --> 00:23:27,440
no no question no further questions

718
00:23:27,440 --> 00:23:31,170
let's thank the speaker again

719
00:23:31,170 --> 00:23:32,860
[Music]

720
00:23:32,860 --> 00:23:36,020
[Applause]

721
00:23:38,080 --> 00:23:40,158
you

