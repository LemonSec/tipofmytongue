1
00:00:10,320 --> 00:00:13,120
thank you stefan and as stefan said i am

2
00:00:13,120 --> 00:00:15,360
advaith nadkarni and i am going to talk

3
00:00:15,360 --> 00:00:18,000
about making data secrecy enforcement

4
00:00:18,000 --> 00:00:20,000
practical on android

5
00:00:20,000 --> 00:00:22,080
so these operating systems like android

6
00:00:22,080 --> 00:00:23,920
and ios are very different from your

7
00:00:23,920 --> 00:00:26,400
traditional windows desktop for instance

8
00:00:26,400 --> 00:00:27,599
on android

9
00:00:27,599 --> 00:00:30,560
applications are security principles and

10
00:00:30,560 --> 00:00:32,000
simply what that means is that

11
00:00:32,000 --> 00:00:35,120
applications execute with a small subset

12
00:00:35,120 --> 00:00:37,040
of the user's overall security

13
00:00:37,040 --> 00:00:39,280
privileges and these privileges are tied

14
00:00:39,280 --> 00:00:40,800
to their identities our security

15
00:00:40,800 --> 00:00:42,480
principles

16
00:00:42,480 --> 00:00:44,000
so this is very different from your

17
00:00:44,000 --> 00:00:45,600
windows desktop where an application

18
00:00:45,600 --> 00:00:48,320
executes as the user and has all the

19
00:00:48,320 --> 00:00:50,000
privileges that the user has on the

20
00:00:50,000 --> 00:00:51,120
system

21
00:00:51,120 --> 00:00:52,800
now since applications are security

22
00:00:52,800 --> 00:00:55,199
principles on android

23
00:00:55,199 --> 00:00:57,120
applications cannot normally access each

24
00:00:57,120 --> 00:00:58,480
other's data

25
00:00:58,480 --> 00:00:59,280
so

26
00:00:59,280 --> 00:01:01,120
when the user wants to combine different

27
00:01:01,120 --> 00:01:02,879
applications applications must share

28
00:01:02,879 --> 00:01:04,799
data and i'll give you an example of how

29
00:01:04,799 --> 00:01:06,479
the sharing takes place

30
00:01:06,479 --> 00:01:08,560
so say you get an email in an email

31
00:01:08,560 --> 00:01:10,960
application and the email consists of an

32
00:01:10,960 --> 00:01:13,040
attachment now you click on the

33
00:01:13,040 --> 00:01:15,200
attachment and the attachment opens up

34
00:01:15,200 --> 00:01:17,439
in a document viewer and this

35
00:01:17,439 --> 00:01:19,360
flow is very seamless

36
00:01:19,360 --> 00:01:21,119
what's happening in the background is

37
00:01:21,119 --> 00:01:23,680
that the email application is sharing

38
00:01:23,680 --> 00:01:26,080
the attachment with the document viewer

39
00:01:26,080 --> 00:01:27,840
now this sharing is really useful you

40
00:01:27,840 --> 00:01:30,000
could then convert the attachment to a

41
00:01:30,000 --> 00:01:31,520
different format or you could sign it

42
00:01:31,520 --> 00:01:33,040
with your physical signature and you

43
00:01:33,040 --> 00:01:34,720
could even export it back through the

44
00:01:34,720 --> 00:01:36,640
email application all within staying in

45
00:01:36,640 --> 00:01:38,320
the same workflow

46
00:01:38,320 --> 00:01:40,560
at the same time this sharing can be

47
00:01:40,560 --> 00:01:41,840
risky

48
00:01:41,840 --> 00:01:43,600
what if one of these applications say

49
00:01:43,600 --> 00:01:46,079
the document of your application decides

50
00:01:46,079 --> 00:01:48,000
to become malicious or is compromised

51
00:01:48,000 --> 00:01:50,479
and exports your data to a remote server

52
00:01:50,479 --> 00:01:52,079
on the internet

53
00:01:52,079 --> 00:01:54,479
so the question for us is

54
00:01:54,479 --> 00:01:56,399
how do we enable this data sharing

55
00:01:56,399 --> 00:01:58,399
amongst applications while also

56
00:01:58,399 --> 00:02:00,560
preventing such unauthorized disclosure

57
00:02:00,560 --> 00:02:02,000
of data

58
00:02:02,000 --> 00:02:04,320
now if you look at it the problem stems

59
00:02:04,320 --> 00:02:06,079
from the loss of control over the flow

60
00:02:06,079 --> 00:02:08,000
of shared data that is the email

61
00:02:08,000 --> 00:02:10,318
application can control

62
00:02:10,318 --> 00:02:12,800
sharing of data but once this data is

63
00:02:12,800 --> 00:02:14,800
shared with an adversary it loses all

64
00:02:14,800 --> 00:02:16,480
control over what the adversary does

65
00:02:16,480 --> 00:02:17,599
with it

66
00:02:17,599 --> 00:02:19,280
so since this is a problem of

67
00:02:19,280 --> 00:02:20,720
controlling the flow of one's

68
00:02:20,720 --> 00:02:23,520
information the solution is

69
00:02:23,520 --> 00:02:25,599
information flow control right think

70
00:02:25,599 --> 00:02:27,760
about uh think about the secrecy model

71
00:02:27,760 --> 00:02:29,360
like bellapadla

72
00:02:29,360 --> 00:02:30,239
now

73
00:02:30,239 --> 00:02:31,920
information flow control has been around

74
00:02:31,920 --> 00:02:34,160
for over four decades but it has seen

75
00:02:34,160 --> 00:02:36,239
very limited use in commodity operating

76
00:02:36,239 --> 00:02:37,280
systems

77
00:02:37,280 --> 00:02:40,080
and one of the reasons for this is that

78
00:02:40,080 --> 00:02:42,080
most information flow control models

79
00:02:42,080 --> 00:02:44,879
require a centrally administered policy

80
00:02:44,879 --> 00:02:47,760
and what this essentially means is that

81
00:02:47,760 --> 00:02:49,920
a system administrator sets the policy

82
00:02:49,920 --> 00:02:52,080
for systems objects and objects now

83
00:02:52,080 --> 00:02:53,760
while this is reasonable to assume for

84
00:02:53,760 --> 00:02:55,040
system data

85
00:02:55,040 --> 00:02:57,280
what about application specific data

86
00:02:57,280 --> 00:02:59,040
like email attachments and notes and

87
00:02:59,040 --> 00:03:00,400
messages

88
00:03:00,400 --> 00:03:02,159
a system administrator cannot be

89
00:03:02,159 --> 00:03:04,159
expected to reason about third party

90
00:03:04,159 --> 00:03:05,840
applications like email gmail and

91
00:03:05,840 --> 00:03:08,480
whatsapp let alone the secrecy policy

92
00:03:08,480 --> 00:03:10,159
for the data

93
00:03:10,159 --> 00:03:13,040
so for application specific data we have

94
00:03:13,040 --> 00:03:15,120
decentralized information flow control

95
00:03:15,120 --> 00:03:16,720
or diffc

96
00:03:16,720 --> 00:03:18,800
this c allows applications to become the

97
00:03:18,800 --> 00:03:21,680
data owners for their own secret data

98
00:03:21,680 --> 00:03:23,680
and essentially these data owners can

99
00:03:23,680 --> 00:03:25,680
create the security classes to mark

100
00:03:25,680 --> 00:03:27,360
which of the data is secret and which is

101
00:03:27,360 --> 00:03:28,159
not

102
00:03:28,159 --> 00:03:30,319
they can even define the policy define

103
00:03:30,319 --> 00:03:32,000
the secrecy policy for the security

104
00:03:32,000 --> 00:03:34,159
classes that is they can define the

105
00:03:34,159 --> 00:03:35,680
arrangement between these security

106
00:03:35,680 --> 00:03:37,599
classes which defines the flow that is

107
00:03:37,599 --> 00:03:39,120
possible between them

108
00:03:39,120 --> 00:03:41,519
and more importantly they can define

109
00:03:41,519 --> 00:03:43,680
what declassification means for their

110
00:03:43,680 --> 00:03:45,360
own security classes

111
00:03:45,360 --> 00:03:48,000
now to simply say this declassification

112
00:03:48,000 --> 00:03:50,000
is the removal of the security policy it

113
00:03:50,000 --> 00:03:52,159
is the removal of the label and data

114
00:03:52,159 --> 00:03:54,720
owners can control when the label over

115
00:03:54,720 --> 00:03:56,799
this over the secret data might be

116
00:03:56,799 --> 00:03:58,080
removed

117
00:03:58,080 --> 00:04:01,040
now to go back to the email example the

118
00:04:01,040 --> 00:04:03,280
email application can easily protect its

119
00:04:03,280 --> 00:04:05,760
data by specifying a simple security

120
00:04:05,760 --> 00:04:08,640
policy and the policy is as follows

121
00:04:08,640 --> 00:04:10,799
the email applications policy allows

122
00:04:10,799 --> 00:04:13,519
every single data owner in the system to

123
00:04:13,519 --> 00:04:15,200
access and share his data with one

124
00:04:15,200 --> 00:04:18,320
another to give the user utility but at

125
00:04:18,320 --> 00:04:20,560
the same time only allows the email

126
00:04:20,560 --> 00:04:22,800
application itself to declassify this

127
00:04:22,800 --> 00:04:25,040
information

128
00:04:25,040 --> 00:04:26,400
now we are not presenting the first

129
00:04:26,400 --> 00:04:28,160
distribution for android but we have

130
00:04:28,160 --> 00:04:28,960
been

131
00:04:28,960 --> 00:04:30,560
working on integrating the scene to

132
00:04:30,560 --> 00:04:33,520
android for a while so in 2013 we gave

133
00:04:33,520 --> 00:04:35,360
the first district system for android

134
00:04:35,360 --> 00:04:37,919
that was aquifer and aquiver focused

135
00:04:37,919 --> 00:04:40,880
mostly on dc policy for android

136
00:04:40,880 --> 00:04:43,040
now right right about the same time

137
00:04:43,040 --> 00:04:45,040
another group from cmu gave their own

138
00:04:45,040 --> 00:04:46,560
distribution system for android and

139
00:04:46,560 --> 00:04:48,240
proposed a non-interference proof for

140
00:04:48,240 --> 00:04:50,000
the difficulty system

141
00:04:50,000 --> 00:04:52,639
now most recently shu and witches have

142
00:04:52,639 --> 00:04:54,320
provided maxoid which gives some

143
00:04:54,320 --> 00:04:56,000
interesting storage level enforcement

144
00:04:56,000 --> 00:04:58,160
primitives for devc on android

145
00:04:58,160 --> 00:05:00,080
now while we've learned a lot of

146
00:05:00,080 --> 00:05:01,680
valuable lessons from these existing

147
00:05:01,680 --> 00:05:03,039
systems

148
00:05:03,039 --> 00:05:04,880
what we have learned the most is that

149
00:05:04,880 --> 00:05:07,759
it's very hard to make deci enforcement

150
00:05:07,759 --> 00:05:10,320
that is both secure as well as backwards

151
00:05:10,320 --> 00:05:12,479
compatible with unmodified legacy

152
00:05:12,479 --> 00:05:13,759
applications

153
00:05:13,759 --> 00:05:16,560
essentially what we observed was that

154
00:05:16,560 --> 00:05:17,919
if you want to make if you want to

155
00:05:17,919 --> 00:05:20,720
provide really strong secrecy guarantees

156
00:05:20,720 --> 00:05:23,360
then you risk breaking applications

157
00:05:23,360 --> 00:05:25,600
but if you want to continue if you want

158
00:05:25,600 --> 00:05:27,360
to work with unmodified legacy

159
00:05:27,360 --> 00:05:29,120
applications then you have to loosen

160
00:05:29,120 --> 00:05:31,759
your security guarantee somewhere

161
00:05:31,759 --> 00:05:34,240
so prior approaches have exposed three

162
00:05:34,240 --> 00:05:36,240
main challenges in diff reinforcement on

163
00:05:36,240 --> 00:05:38,560
android namely determination of the

164
00:05:38,560 --> 00:05:40,240
subject granularity and labeling

165
00:05:40,240 --> 00:05:41,520
precision

166
00:05:41,520 --> 00:05:44,160
the label change and propagation logic

167
00:05:44,160 --> 00:05:45,919
and network declassification in a

168
00:05:45,919 --> 00:05:47,919
network driven environment

169
00:05:47,919 --> 00:05:49,440
and i'm going to explain all of these

170
00:05:49,440 --> 00:05:50,880
challenges individually and then we're

171
00:05:50,880 --> 00:05:52,639
going to look at how we resolve these

172
00:05:52,639 --> 00:05:54,720
challenges in our system

173
00:05:54,720 --> 00:05:56,639
so for subject granularity we have two

174
00:05:56,639 --> 00:05:57,680
options

175
00:05:57,680 --> 00:05:59,360
you have the fine grained programming

176
00:05:59,360 --> 00:06:01,520
language variable that has the obvious

177
00:06:01,520 --> 00:06:02,960
advantage of precision right find

178
00:06:02,960 --> 00:06:05,440
maintained tracking is extremely precise

179
00:06:05,440 --> 00:06:07,600
but at the same time fine graintain

180
00:06:07,600 --> 00:06:08,800
tracking is

181
00:06:08,800 --> 00:06:11,520
susceptible to implicit flows in code

182
00:06:11,520 --> 00:06:13,520
there is flows that occur not due to the

183
00:06:13,520 --> 00:06:15,840
explicit transfer of information but due

184
00:06:15,840 --> 00:06:17,360
to control flow

185
00:06:17,360 --> 00:06:20,000
now for security what you really want is

186
00:06:20,000 --> 00:06:22,080
the granularity of the operating system

187
00:06:22,080 --> 00:06:23,039
process

188
00:06:23,039 --> 00:06:24,880
the process is completely mediated by

189
00:06:24,880 --> 00:06:26,560
the operating system so all the flows in

190
00:06:26,560 --> 00:06:28,080
and out of a process go through the

191
00:06:28,080 --> 00:06:30,560
operating system but at the same time

192
00:06:30,560 --> 00:06:32,479
the process is a very coarse grained

193
00:06:32,479 --> 00:06:34,000
abstraction

194
00:06:34,000 --> 00:06:36,880
especially on android many instances of

195
00:06:36,880 --> 00:06:39,680
the same application may actually exist

196
00:06:39,680 --> 00:06:42,240
simultaneously in the same process and

197
00:06:42,240 --> 00:06:44,160
these instances may be taking part in

198
00:06:44,160 --> 00:06:46,319
completely unrelated user tasks and

199
00:06:46,319 --> 00:06:48,400
dealing with completely unrelated user

200
00:06:48,400 --> 00:06:49,440
data

201
00:06:49,440 --> 00:06:51,680
so when we restrict these different user

202
00:06:51,680 --> 00:06:53,680
tasks with the same secrecy policy or

203
00:06:53,680 --> 00:06:56,319
with a superset of all the secrecy

204
00:06:56,319 --> 00:06:58,880
policies we actually have a lot of false

205
00:06:58,880 --> 00:07:00,319
positives

206
00:07:00,319 --> 00:07:02,000
so what we really want for this

207
00:07:02,000 --> 00:07:03,599
reinforcement in terms of the subject

208
00:07:03,599 --> 00:07:05,120
granularity is

209
00:07:05,120 --> 00:07:06,800
the security of process level in

210
00:07:06,800 --> 00:07:09,440
tracking without the false positives

211
00:07:09,440 --> 00:07:11,440
now in terms of label propagation again

212
00:07:11,440 --> 00:07:13,280
we have two options

213
00:07:13,280 --> 00:07:15,759
there is a class of system that proposes

214
00:07:15,759 --> 00:07:17,680
explicitly defining labels and

215
00:07:17,680 --> 00:07:20,240
explicitly changing labels on subjects

216
00:07:20,240 --> 00:07:22,800
so if there are two subjects p and q

217
00:07:22,800 --> 00:07:24,639
and if p and q have different labels

218
00:07:24,639 --> 00:07:25,919
right now

219
00:07:25,919 --> 00:07:29,199
such systems expect p or q or both to

220
00:07:29,199 --> 00:07:31,039
change the labels in time for any

221
00:07:31,039 --> 00:07:32,960
communication to occur

222
00:07:32,960 --> 00:07:33,759
if

223
00:07:33,759 --> 00:07:35,759
the pnq don't adjust the labels in time

224
00:07:35,759 --> 00:07:38,000
then the call is simply denied

225
00:07:38,000 --> 00:07:41,360
now explicit flows are very hard to

226
00:07:41,360 --> 00:07:43,680
model in android because on android most

227
00:07:43,680 --> 00:07:45,840
communication is user directed and most

228
00:07:45,840 --> 00:07:47,520
sharing between applications is usually

229
00:07:47,520 --> 00:07:49,440
directed so applications aren't really

230
00:07:49,440 --> 00:07:50,879
aware of when they're going to be part

231
00:07:50,879 --> 00:07:52,639
of such communication

232
00:07:52,639 --> 00:07:54,319
what we really need for android is

233
00:07:54,319 --> 00:07:56,319
floating labels or implicit label

234
00:07:56,319 --> 00:07:57,680
propagation

235
00:07:57,680 --> 00:07:59,280
so in floating labels

236
00:07:59,280 --> 00:08:01,440
communication between different subjects

237
00:08:01,440 --> 00:08:04,160
is always enabled but what happens is

238
00:08:04,160 --> 00:08:07,599
when p calls q the restrictions on p are

239
00:08:07,599 --> 00:08:09,199
propagated to q

240
00:08:09,199 --> 00:08:11,280
so the restrictions propagate in the

241
00:08:11,280 --> 00:08:13,840
direction of the flow of information

242
00:08:13,840 --> 00:08:15,840
now while this is exactly what we want

243
00:08:15,840 --> 00:08:17,280
on android because we want seamless

244
00:08:17,280 --> 00:08:19,840
communication and while this propagation

245
00:08:19,840 --> 00:08:21,520
of restriction looks

246
00:08:21,520 --> 00:08:24,160
secure floating labels as they are are

247
00:08:24,160 --> 00:08:26,560
far from being secure or practical so

248
00:08:26,560 --> 00:08:28,000
i'm now going to discuss an attack on

249
00:08:28,000 --> 00:08:29,360
floating labels that has been discussed

250
00:08:29,360 --> 00:08:31,520
in literature for a while

251
00:08:31,520 --> 00:08:33,039
so say you have

252
00:08:33,039 --> 00:08:35,599
two processes p and q

253
00:08:35,599 --> 00:08:38,880
and p has read the secret data bits 0 1.

254
00:08:38,880 --> 00:08:41,360
now p has also acquired the label l 1

255
00:08:41,360 --> 00:08:43,760
that is associated with the secret data

256
00:08:43,760 --> 00:08:45,839
now the objective of this attack is for

257
00:08:45,839 --> 00:08:48,720
p to propagate the data to q without

258
00:08:48,720 --> 00:08:50,720
actually propagating the label

259
00:08:50,720 --> 00:08:52,959
so obviously p is not going to directly

260
00:08:52,959 --> 00:08:54,880
call q because that would propagate the

261
00:08:54,880 --> 00:08:56,640
label l1 to q

262
00:08:56,640 --> 00:08:58,000
instead

263
00:08:58,000 --> 00:09:00,399
q creates two workers q one and q two

264
00:09:00,399 --> 00:09:02,160
and these are also processes or subjects

265
00:09:02,160 --> 00:09:03,920
in the system

266
00:09:03,920 --> 00:09:05,680
now these workers note that there are

267
00:09:05,680 --> 00:09:07,360
two workers for two bits there's one

268
00:09:07,360 --> 00:09:08,959
worker per bit

269
00:09:08,959 --> 00:09:10,560
now all of these participants in the

270
00:09:10,560 --> 00:09:13,120
system agree to a set of rules

271
00:09:13,120 --> 00:09:14,720
the first rule

272
00:09:14,720 --> 00:09:17,279
is that the workers q1 and q2 will call

273
00:09:17,279 --> 00:09:19,680
q back at a predetermined time interval

274
00:09:19,680 --> 00:09:21,279
the only reason when they won't call

275
00:09:21,279 --> 00:09:23,600
back is if one of them gets a call from

276
00:09:23,600 --> 00:09:25,600
p first

277
00:09:25,600 --> 00:09:28,320
the other rule is that p will call the

278
00:09:28,320 --> 00:09:31,519
ith worker of q q i if it wants to

279
00:09:31,519 --> 00:09:33,920
indicate a zero at the i pit

280
00:09:33,920 --> 00:09:35,760
so in this case since p wants to

281
00:09:35,760 --> 00:09:38,000
indicate a zero at the first bit

282
00:09:38,000 --> 00:09:40,720
it calls the worker q one

283
00:09:40,720 --> 00:09:42,720
now at the predetermined time interval q

284
00:09:42,720 --> 00:09:44,959
one and q two must both call q back but

285
00:09:44,959 --> 00:09:47,279
q two is the only component that calls q

286
00:09:47,279 --> 00:09:50,640
since q one has already been called by p

287
00:09:50,640 --> 00:09:53,440
now at this point q has gotten a call

288
00:09:53,440 --> 00:09:56,240
from q 2 which allows it to guess that q

289
00:09:56,240 --> 00:09:59,200
2 signifies the bit 1 since

290
00:09:59,200 --> 00:10:00,959
since q 2 has called it must not have

291
00:10:00,959 --> 00:10:02,560
been called by p

292
00:10:02,560 --> 00:10:04,880
so q correctly guesses the database 0

293
00:10:04,880 --> 00:10:06,959
and since q2 symbolizes the bit 1 and

294
00:10:06,959 --> 00:10:10,959
the absent call symbolizes the bit 0.

295
00:10:10,959 --> 00:10:12,399
now floating labels are not only not

296
00:10:12,399 --> 00:10:14,160
secure they're also not practical on

297
00:10:14,160 --> 00:10:15,200
android

298
00:10:15,200 --> 00:10:18,000
so say you have a component or a subject

299
00:10:18,000 --> 00:10:19,600
that provides a shared

300
00:10:19,600 --> 00:10:21,600
service to other different subjects in

301
00:10:21,600 --> 00:10:23,839
the system and let's assume all of these

302
00:10:23,839 --> 00:10:26,160
other subjects have different labels

303
00:10:26,160 --> 00:10:28,320
so initially all of these subjects in

304
00:10:28,320 --> 00:10:30,880
the system call a and a accumulates a

305
00:10:30,880 --> 00:10:33,279
label that is a join of all of the label

306
00:10:33,279 --> 00:10:34,800
since we're using floating labels this

307
00:10:34,800 --> 00:10:37,360
is the exact enforcement that we want

308
00:10:37,360 --> 00:10:40,000
now when a replies to the calls by all

309
00:10:40,000 --> 00:10:41,519
of these subjects

310
00:10:41,519 --> 00:10:43,760
this used label that a had accumulated

311
00:10:43,760 --> 00:10:45,360
now propagates back to all of these

312
00:10:45,360 --> 00:10:46,399
subjects

313
00:10:46,399 --> 00:10:49,519
so what we really have here is a huge

314
00:10:49,519 --> 00:10:51,920
label that no single security principle

315
00:10:51,920 --> 00:10:53,440
can declassify

316
00:10:53,440 --> 00:10:55,440
which is propagated to most parts of the

317
00:10:55,440 --> 00:10:57,680
system that are not isolated and this

318
00:10:57,680 --> 00:11:00,320
problem is known as label explosion and

319
00:11:00,320 --> 00:11:02,480
this problem is especially serious on

320
00:11:02,480 --> 00:11:04,959
android because on android the component

321
00:11:04,959 --> 00:11:06,640
a could be anything it could be a

322
00:11:06,640 --> 00:11:08,800
service or a content provider component

323
00:11:08,800 --> 00:11:10,240
these are actual android components that

324
00:11:10,240 --> 00:11:12,480
are shared amongst applications

325
00:11:12,480 --> 00:11:14,240
it could be a file that is shared by

326
00:11:14,240 --> 00:11:15,920
multiple instances of the same

327
00:11:15,920 --> 00:11:17,920
application irrespective of whatever

328
00:11:17,920 --> 00:11:19,920
secrecy context they're in

329
00:11:19,920 --> 00:11:21,839
and it could also be a general purpose

330
00:11:21,839 --> 00:11:24,399
application like a pdf reader or an

331
00:11:24,399 --> 00:11:26,320
image editor that's called from many

332
00:11:26,320 --> 00:11:27,920
different secrecy contexts by other

333
00:11:27,920 --> 00:11:30,000
applications this problem of label

334
00:11:30,000 --> 00:11:33,360
explosion is really drastic on android

335
00:11:33,360 --> 00:11:34,480
now we're going to talk about the

336
00:11:34,480 --> 00:11:36,480
challenge of network declassification on

337
00:11:36,480 --> 00:11:39,040
android so like i said before data must

338
00:11:39,040 --> 00:11:41,120
be declassified before it is exported to

339
00:11:41,120 --> 00:11:42,640
the public domain and the network is

340
00:11:42,640 --> 00:11:44,320
considered to be public

341
00:11:44,320 --> 00:11:46,880
now there are two primary ways in which

342
00:11:46,880 --> 00:11:49,200
declassification is being done right now

343
00:11:49,200 --> 00:11:51,920
the first way is to query the data owner

344
00:11:51,920 --> 00:11:53,600
to declassify the data so essentially

345
00:11:53,600 --> 00:11:55,279
you call back the data owner and the

346
00:11:55,279 --> 00:11:57,040
data owner either allows or denies a

347
00:11:57,040 --> 00:11:58,720
declassification

348
00:11:58,720 --> 00:12:01,040
the other approach is for the data owner

349
00:12:01,040 --> 00:12:03,279
to actually specify a small set of

350
00:12:03,279 --> 00:12:05,519
security principles that can declassify

351
00:12:05,519 --> 00:12:07,279
data on its behalf

352
00:12:07,279 --> 00:12:08,560
now both of these approaches are

353
00:12:08,560 --> 00:12:10,240
problematic the first approach is

354
00:12:10,240 --> 00:12:12,240
problematic on android because android

355
00:12:12,240 --> 00:12:13,760
is extremely network driven right you

356
00:12:13,760 --> 00:12:14,959
have many applications that are

357
00:12:14,959 --> 00:12:17,120
continuously connecting to the network

358
00:12:17,120 --> 00:12:19,279
and in such a network driven environment

359
00:12:19,279 --> 00:12:21,279
it is very inefficient to continuously

360
00:12:21,279 --> 00:12:23,279
call back the data owner

361
00:12:23,279 --> 00:12:25,040
the other problem is that when you

362
00:12:25,040 --> 00:12:27,040
specify other security principles to

363
00:12:27,040 --> 00:12:29,440
declassify your data for you you then

364
00:12:29,440 --> 00:12:31,120
include them in your trusted computing

365
00:12:31,120 --> 00:12:33,519
base and this is dangerous other than

366
00:12:33,519 --> 00:12:35,839
that using only a small subset of

367
00:12:35,839 --> 00:12:39,040
applications to declassify data

368
00:12:39,040 --> 00:12:40,959
prohibits the user from using a

369
00:12:40,959 --> 00:12:43,120
third-party client to export data to the

370
00:12:43,120 --> 00:12:44,560
network so the user is prohibited from

371
00:12:44,560 --> 00:12:46,160
using a third-party email client or a

372
00:12:46,160 --> 00:12:48,079
third-party cloud client to sync with

373
00:12:48,079 --> 00:12:50,480
the very servers that any other regular

374
00:12:50,480 --> 00:12:52,720
permitted client would do

375
00:12:52,720 --> 00:12:54,000
so now that you've described all the

376
00:12:54,000 --> 00:12:56,480
challenges i present veer

377
00:12:56,480 --> 00:12:58,880
a different system that provides secure

378
00:12:58,880 --> 00:13:00,720
as well as backwards compatible

379
00:13:00,720 --> 00:13:02,480
enforcement for android

380
00:13:02,480 --> 00:13:04,639
now our system viewer uses two

381
00:13:04,639 --> 00:13:06,800
techniques for such enforcement and for

382
00:13:06,800 --> 00:13:08,320
solving the challenges that we described

383
00:13:08,320 --> 00:13:10,320
before the techniques of lazy poly

384
00:13:10,320 --> 00:13:11,760
instantiation and domain

385
00:13:11,760 --> 00:13:13,839
declassification

386
00:13:13,839 --> 00:13:15,839
now paul instantiation is best

387
00:13:15,839 --> 00:13:17,279
understood in our context when you

388
00:13:17,279 --> 00:13:19,279
compare it with explicit and floating

389
00:13:19,279 --> 00:13:22,240
labels so to give you a brief recap in

390
00:13:22,240 --> 00:13:24,720
explicit labels when p calls q

391
00:13:24,720 --> 00:13:26,639
p and q have to adjust the labels in

392
00:13:26,639 --> 00:13:27,839
order for the call to take place

393
00:13:27,839 --> 00:13:30,240
otherwise the call is simply denied

394
00:13:30,240 --> 00:13:32,639
in case of loading labels the call is

395
00:13:32,639 --> 00:13:34,560
always allowed and the restrictions are

396
00:13:34,560 --> 00:13:36,480
simply propagated from the caller to the

397
00:13:36,480 --> 00:13:37,920
callee and we've already seen the

398
00:13:37,920 --> 00:13:40,480
problems with the simple propagation

399
00:13:40,480 --> 00:13:42,639
now when you combine floating labels

400
00:13:42,639 --> 00:13:44,800
with poly instantiation the following

401
00:13:44,800 --> 00:13:46,240
happens

402
00:13:46,240 --> 00:13:48,079
the current instances of p and q have

403
00:13:48,079 --> 00:13:50,560
different labels and p is going to call

404
00:13:50,560 --> 00:13:52,160
the component q

405
00:13:52,160 --> 00:13:54,079
but this call is not delivered to the

406
00:13:54,079 --> 00:13:56,959
existing instance of q instead a new

407
00:13:56,959 --> 00:13:59,839
instance of q q prime is created in the

408
00:13:59,839 --> 00:14:01,760
secrecy context of p that is with the

409
00:14:01,760 --> 00:14:03,120
label of p

410
00:14:03,120 --> 00:14:04,880
so what we are essentially doing here is

411
00:14:04,880 --> 00:14:06,959
we are making floating labels context

412
00:14:06,959 --> 00:14:09,360
sensitive that is we are creating

413
00:14:09,360 --> 00:14:11,120
instances of different parts of the

414
00:14:11,120 --> 00:14:13,360
system say components or processes or

415
00:14:13,360 --> 00:14:15,839
files for every different secrecy

416
00:14:15,839 --> 00:14:18,959
context whenever the call demands it

417
00:14:18,959 --> 00:14:21,199
so why is this lazy well first of all

418
00:14:21,199 --> 00:14:23,680
like i said paul instantiation is event

419
00:14:23,680 --> 00:14:26,320
driven right we only do it

420
00:14:26,320 --> 00:14:28,240
in succession of a call

421
00:14:28,240 --> 00:14:30,399
and the other thing that makes it lazy

422
00:14:30,399 --> 00:14:32,639
is that the operating system keeps track

423
00:14:32,639 --> 00:14:35,360
of all existing instances and a new

424
00:14:35,360 --> 00:14:37,440
instance is created only when it is

425
00:14:37,440 --> 00:14:39,360
required only when it doesn't exist in

426
00:14:39,360 --> 00:14:41,440
the required secrecy context

427
00:14:41,440 --> 00:14:43,839
so if a new call came in for the

428
00:14:43,839 --> 00:14:46,399
component queue again and in the secrecy

429
00:14:46,399 --> 00:14:47,839
context lp

430
00:14:47,839 --> 00:14:49,920
that call will be delivered to the

431
00:14:49,920 --> 00:14:51,600
component instance q prime that is

432
00:14:51,600 --> 00:14:53,680
already created in the context lp so a

433
00:14:53,680 --> 00:14:55,120
new instance would not be created this

434
00:14:55,120 --> 00:14:56,959
time

435
00:14:56,959 --> 00:14:59,519
now paul instantiation is resistant to

436
00:14:59,519 --> 00:15:00,880
the data leak and floating labels that

437
00:15:00,880 --> 00:15:02,560
we showed before so the figure on the

438
00:15:02,560 --> 00:15:05,519
left is the data leak in floating labels

439
00:15:05,519 --> 00:15:06,959
and the figure on the right is how it's

440
00:15:06,959 --> 00:15:09,199
going to happen with poly instantiation

441
00:15:09,199 --> 00:15:11,199
so again p wants to transfer the data

442
00:15:11,199 --> 00:15:12,959
bits 0 1 to q without actually

443
00:15:12,959 --> 00:15:14,880
transferring the label and q has created

444
00:15:14,880 --> 00:15:17,040
two workers for this job

445
00:15:17,040 --> 00:15:19,680
now note that q's workers currently have

446
00:15:19,680 --> 00:15:22,160
the label have an empty label whereas p

447
00:15:22,160 --> 00:15:24,079
has a label l1

448
00:15:24,079 --> 00:15:27,040
so when p calls q 1 instead of the call

449
00:15:27,040 --> 00:15:29,759
being delivered to q 1 a new instance of

450
00:15:29,759 --> 00:15:32,639
q 1 q 1 prime is created in p secrecy

451
00:15:32,639 --> 00:15:35,199
context and a call is delivered to it

452
00:15:35,199 --> 00:15:37,839
so as a result when the time interval

453
00:15:37,839 --> 00:15:40,720
comes for q's workers to call queue back

454
00:15:40,720 --> 00:15:43,519
only q1 and q2 call q back and q will

455
00:15:43,519 --> 00:15:45,759
always get these data bits 1 1

456
00:15:45,759 --> 00:15:47,680
irrespective what the actual data is

457
00:15:47,680 --> 00:15:50,000
because we always keep creating context

458
00:15:50,000 --> 00:15:53,839
specific instances of queues workers

459
00:15:53,839 --> 00:15:55,839
it is also easy to see why paul

460
00:15:55,839 --> 00:15:57,759
instantiation makes floating labels

461
00:15:57,759 --> 00:16:00,399
resistant to label explosion

462
00:16:00,399 --> 00:16:01,279
since

463
00:16:01,279 --> 00:16:03,279
no single component is ever going to

464
00:16:03,279 --> 00:16:05,199
accumulate labels since we are always

465
00:16:05,199 --> 00:16:06,320
going to create

466
00:16:06,320 --> 00:16:08,639
instances for every different separate

467
00:16:08,639 --> 00:16:11,040
secrecy context you're never going to

468
00:16:11,040 --> 00:16:12,639
see a label explosion you're never going

469
00:16:12,639 --> 00:16:14,480
to see label accumulation in the first

470
00:16:14,480 --> 00:16:15,680
place

471
00:16:15,680 --> 00:16:16,639
also

472
00:16:16,639 --> 00:16:18,720
if we paul instantiate processes which

473
00:16:18,720 --> 00:16:19,839
we do

474
00:16:19,839 --> 00:16:21,519
then you will never have multiple

475
00:16:21,519 --> 00:16:24,160
secrecy contexts coexisting in the same

476
00:16:24,160 --> 00:16:26,480
process for every separate secrecy

477
00:16:26,480 --> 00:16:28,480
context you will always have a separate

478
00:16:28,480 --> 00:16:30,720
process so you get process level

479
00:16:30,720 --> 00:16:32,720
labeling without the resultant false

480
00:16:32,720 --> 00:16:34,480
positives

481
00:16:34,480 --> 00:16:36,160
now we designed poll instantiation on

482
00:16:36,160 --> 00:16:39,120
android in terms of memory and storage

483
00:16:39,120 --> 00:16:42,079
for memory we created separate instances

484
00:16:42,079 --> 00:16:43,839
of processes as well as android

485
00:16:43,839 --> 00:16:45,040
components

486
00:16:45,040 --> 00:16:47,279
in terms of the caller's label

487
00:16:47,279 --> 00:16:48,079
and

488
00:16:48,079 --> 00:16:50,079
on android developers can specify a

489
00:16:50,079 --> 00:16:51,680
mapping between processor and components

490
00:16:51,680 --> 00:16:53,759
so developers can specify a component to

491
00:16:53,759 --> 00:16:56,079
run in a specific process and we can

492
00:16:56,079 --> 00:16:57,920
maintain this mapping in our approach

493
00:16:57,920 --> 00:17:00,480
but per secrecy context so we cannot

494
00:17:00,480 --> 00:17:02,399
really maintain cross-context secrecy

495
00:17:02,399 --> 00:17:04,000
mappings and it doesn't even make sense

496
00:17:04,000 --> 00:17:06,240
because in every secrecy context every

497
00:17:06,240 --> 00:17:08,079
process and every component is available

498
00:17:08,079 --> 00:17:10,240
so that mapping can always be made in

499
00:17:10,240 --> 00:17:12,480
that particular secrecy context

500
00:17:12,480 --> 00:17:14,240
now in terms of storage

501
00:17:14,240 --> 00:17:16,559
we created context specific layers for

502
00:17:16,559 --> 00:17:18,400
each secrecy context to access the

503
00:17:18,400 --> 00:17:19,599
storage

504
00:17:19,599 --> 00:17:22,079
so every label has its own layer through

505
00:17:22,079 --> 00:17:24,160
which to access the default unlabeled

506
00:17:24,160 --> 00:17:26,720
file system and layers cannot and

507
00:17:26,720 --> 00:17:29,280
processes in an unlabeled label secrecy

508
00:17:29,280 --> 00:17:31,120
context cannot directly access the file

509
00:17:31,120 --> 00:17:32,720
system

510
00:17:32,720 --> 00:17:35,520
so for transparent storage access

511
00:17:35,520 --> 00:17:37,919
processes in label secrecy context can

512
00:17:37,919 --> 00:17:39,919
read from any file unmodified file on

513
00:17:39,919 --> 00:17:41,520
the default file system

514
00:17:41,520 --> 00:17:43,840
but once they try to modify a file on

515
00:17:43,840 --> 00:17:45,760
the file system the file is copied over

516
00:17:45,760 --> 00:17:47,600
to their layer and then the future

517
00:17:47,600 --> 00:17:49,840
modification and future reads and writes

518
00:17:49,840 --> 00:17:53,120
are made to that copy of the file

519
00:17:53,120 --> 00:17:55,200
so why does this work on android

520
00:17:55,200 --> 00:17:57,520
well on android the developer is forced

521
00:17:57,520 --> 00:18:00,000
to adopt a very stringent application

522
00:18:00,000 --> 00:18:01,760
model where the application is composed

523
00:18:01,760 --> 00:18:04,480
of specific types of components and

524
00:18:04,480 --> 00:18:06,080
where each of these components has its

525
00:18:06,080 --> 00:18:09,360
own specific api and more importantly

526
00:18:09,360 --> 00:18:11,760
can be called in only a certain specific

527
00:18:11,760 --> 00:18:13,200
number of ways

528
00:18:13,200 --> 00:18:15,039
so all the communication between

529
00:18:15,039 --> 00:18:17,520
components is initiated through a system

530
00:18:17,520 --> 00:18:19,919
service the activity manager service so

531
00:18:19,919 --> 00:18:21,760
this communication essentially is

532
00:18:21,760 --> 00:18:23,200
indirect

533
00:18:23,200 --> 00:18:25,919
when one component calls another

534
00:18:25,919 --> 00:18:28,640
the activity manager chooses the instant

535
00:18:28,640 --> 00:18:30,720
of instance of the receiver that should

536
00:18:30,720 --> 00:18:32,240
actually receive the call

537
00:18:32,240 --> 00:18:35,679
so the caller can specify who to call

538
00:18:35,679 --> 00:18:37,600
but not the instance that should receive

539
00:18:37,600 --> 00:18:38,559
the call so there's this fine

540
00:18:38,559 --> 00:18:40,160
distinction between specifying the

541
00:18:40,160 --> 00:18:42,640
component's identity versus specifying

542
00:18:42,640 --> 00:18:44,320
one of its many instances that must

543
00:18:44,320 --> 00:18:45,520
receive the call

544
00:18:45,520 --> 00:18:47,919
and we extend this exact indirect call

545
00:18:47,919 --> 00:18:50,480
mechanism for a context specific quality

546
00:18:50,480 --> 00:18:51,679
instantiation

547
00:18:51,679 --> 00:18:53,360
now there is also direct communication

548
00:18:53,360 --> 00:18:55,520
in android through the binder rpc but

549
00:18:55,520 --> 00:18:57,919
again for such communication take place

550
00:18:57,919 --> 00:18:59,919
you first need to establish a connection

551
00:18:59,919 --> 00:19:01,520
between two components and for that you

552
00:19:01,520 --> 00:19:03,120
again need to go through the indirect

553
00:19:03,120 --> 00:19:04,160
route

554
00:19:04,160 --> 00:19:06,000
so we can still leverage poly

555
00:19:06,000 --> 00:19:08,320
instantiation that way

556
00:19:08,320 --> 00:19:09,360
finally

557
00:19:09,360 --> 00:19:11,679
i'll present the primitive domain

558
00:19:11,679 --> 00:19:13,520
declassification that we use for network

559
00:19:13,520 --> 00:19:15,600
declassification on android and the

560
00:19:15,600 --> 00:19:17,840
intuition behind this is very simple

561
00:19:17,840 --> 00:19:19,760
so in android's network driven

562
00:19:19,760 --> 00:19:20,880
environment

563
00:19:20,880 --> 00:19:23,039
it makes more sense to reason about

564
00:19:23,039 --> 00:19:25,520
where the data is going to be delivered

565
00:19:25,520 --> 00:19:27,520
rather than what client is performing

566
00:19:27,520 --> 00:19:28,720
the export

567
00:19:28,720 --> 00:19:30,640
so what we really do is we allow data

568
00:19:30,640 --> 00:19:33,840
owners to reason about trust in terms of

569
00:19:33,840 --> 00:19:36,160
web domains on the network rather than

570
00:19:36,160 --> 00:19:38,559
applications on the device

571
00:19:38,559 --> 00:19:40,880
and whenever whenever data is to be

572
00:19:40,880 --> 00:19:42,480
exported to one of the domains trusted

573
00:19:42,480 --> 00:19:45,039
by the data owner the data on a security

574
00:19:45,039 --> 00:19:47,840
tag is simply declassified

575
00:19:47,840 --> 00:19:50,559
we implemented a system on android 5.0.1

576
00:19:50,559 --> 00:19:52,400
and our implementation is open source i

577
00:19:52,400 --> 00:19:54,240
encourage you to check it out

578
00:19:54,240 --> 00:19:56,080
we use the flume policy model the

579
00:19:56,080 --> 00:19:58,480
specific policy model for implementation

580
00:19:58,480 --> 00:20:00,160
but then our mechanisms as we've

581
00:20:00,160 --> 00:20:01,440
described in the paper are policy

582
00:20:01,440 --> 00:20:03,919
agnostic and can be adapted to suit

583
00:20:03,919 --> 00:20:07,120
other policy languages

584
00:20:07,120 --> 00:20:08,880
we ran some micro benchmarks for our

585
00:20:08,880 --> 00:20:10,720
performance evaluation and micro

586
00:20:10,720 --> 00:20:12,400
benchmarks for common operations such as

587
00:20:12,400 --> 00:20:14,240
starting components or reading writing

588
00:20:14,240 --> 00:20:17,440
files etc and we did not notice any high

589
00:20:17,440 --> 00:20:19,840
overhead in terms of the absolute value

590
00:20:19,840 --> 00:20:21,600
when we compared the performance of our

591
00:20:21,600 --> 00:20:25,120
system with that of vanilla android

592
00:20:25,120 --> 00:20:27,360
we also evaluated the scalability of

593
00:20:27,360 --> 00:20:29,919
starting a single component when a large

594
00:20:29,919 --> 00:20:32,000
number of its instances already existed

595
00:20:32,000 --> 00:20:34,400
in the system so we started up 200

596
00:20:34,400 --> 00:20:36,640
instances of a component and then

597
00:20:36,640 --> 00:20:38,240
started the component just to measure

598
00:20:38,240 --> 00:20:40,159
how long it takes to start it and we

599
00:20:40,159 --> 00:20:42,880
noticed a very linear rise in the start

600
00:20:42,880 --> 00:20:44,960
time of that component even for the

601
00:20:44,960 --> 00:20:46,880
final instance where we started up 200

602
00:20:46,880 --> 00:20:49,120
components the

603
00:20:49,120 --> 00:20:50,880
start time was only delayed by 50

604
00:20:50,880 --> 00:20:52,400
milliseconds now in the paper we

605
00:20:52,400 --> 00:20:54,400
described why we described by the start

606
00:20:54,400 --> 00:20:56,559
time of a single component is affected

607
00:20:56,559 --> 00:20:58,799
by its concurrent instances but the

608
00:20:58,799 --> 00:21:01,039
concurrent instances do not affect the

609
00:21:01,039 --> 00:21:02,559
global start time i would encourage you

610
00:21:02,559 --> 00:21:04,480
to go and read it

611
00:21:04,480 --> 00:21:07,200
now we executed a case study with a k9

612
00:21:07,200 --> 00:21:09,440
email application an application that is

613
00:21:09,440 --> 00:21:11,280
a very popular email client and the

614
00:21:11,280 --> 00:21:13,280
objective of this case study was to

615
00:21:13,280 --> 00:21:16,000
separate personal and work email data

616
00:21:16,000 --> 00:21:17,280
within the same application

617
00:21:17,280 --> 00:21:18,720
simultaneously

618
00:21:18,720 --> 00:21:20,559
so what we did was we configured canine

619
00:21:20,559 --> 00:21:22,799
email to use both the user account as

620
00:21:22,799 --> 00:21:24,559
well as the enterprise account like many

621
00:21:24,559 --> 00:21:25,679
of us do

622
00:21:25,679 --> 00:21:27,520
and then we simulated business data

623
00:21:27,520 --> 00:21:29,120
through an application known as bcloud

624
00:21:29,120 --> 00:21:31,760
so we created the b cloud application to

625
00:21:31,760 --> 00:21:33,360
import some business contacts and

626
00:21:33,360 --> 00:21:35,600
business documents onto the device

627
00:21:35,600 --> 00:21:38,080
now what bcloud does is that before

628
00:21:38,080 --> 00:21:39,679
sharing this data with any other

629
00:21:39,679 --> 00:21:41,440
application on the device

630
00:21:41,440 --> 00:21:43,600
it creates a policy and enterprise

631
00:21:43,600 --> 00:21:45,840
policy for his data and the enterprise

632
00:21:45,840 --> 00:21:47,440
policy is a very simple domain

633
00:21:47,440 --> 00:21:49,280
declassification policy

634
00:21:49,280 --> 00:21:51,679
it says that vcloud's data should only

635
00:21:51,679 --> 00:21:53,919
be exported to the domains belonging to

636
00:21:53,919 --> 00:21:57,520
bcloud.com that's it that's the policy

637
00:21:57,520 --> 00:21:59,760
now to run the case study we shared some

638
00:21:59,760 --> 00:22:02,159
data from the b cloud application with

639
00:22:02,159 --> 00:22:04,000
the k9 email application and the data

640
00:22:04,000 --> 00:22:06,720
opened in canine emails compose window

641
00:22:06,720 --> 00:22:09,039
now in the compose ui we added contacts

642
00:22:09,039 --> 00:22:10,960
we had tried attaching documents but we

643
00:22:10,960 --> 00:22:13,360
did not send the email instead

644
00:22:13,360 --> 00:22:15,600
we switched back to the home screen

645
00:22:15,600 --> 00:22:17,840
now we opened up another application and

646
00:22:17,840 --> 00:22:20,080
shared some unlabeled data with k9 email

647
00:22:20,080 --> 00:22:21,919
and repeated the procedure of attaching

648
00:22:21,919 --> 00:22:24,240
contacts and attaching documents

649
00:22:24,240 --> 00:22:26,480
then we quickly toggled between the two

650
00:22:26,480 --> 00:22:28,080
instances of k9 email in both the

651
00:22:28,080 --> 00:22:31,120
context and sent out both the emails

652
00:22:31,120 --> 00:22:33,280
now a general observation was that

653
00:22:33,280 --> 00:22:35,440
instances of k9 email existed

654
00:22:35,440 --> 00:22:37,760
simultaneously in both the context in

655
00:22:37,760 --> 00:22:40,480
the secret context of bcloud as well as

656
00:22:40,480 --> 00:22:42,400
in the non-secret context

657
00:22:42,400 --> 00:22:44,000
now specifically in the enterprise

658
00:22:44,000 --> 00:22:46,559
context of vcloud we observed that we

659
00:22:46,559 --> 00:22:48,880
could see data from the label layer that

660
00:22:48,880 --> 00:22:51,360
is b cloud layer as well as we could see

661
00:22:51,360 --> 00:22:52,880
the unlabeled data from the unlabeled

662
00:22:52,880 --> 00:22:55,120
file system whereas in the unlabeled

663
00:22:55,120 --> 00:22:58,080
instance of canine email we could only

664
00:22:58,080 --> 00:23:00,799
see data from the unlabeled file system

665
00:23:00,799 --> 00:23:02,960
also in terms of network export we

666
00:23:02,960 --> 00:23:05,039
observed that in the business context

667
00:23:05,039 --> 00:23:07,280
canine email was constantly being denied

668
00:23:07,280 --> 00:23:09,360
connections to the personal accounts and

669
00:23:09,360 --> 00:23:10,480
this is essentially domain

670
00:23:10,480 --> 00:23:13,360
declassification in action

671
00:23:13,360 --> 00:23:15,440
now we also observed a couple of caveats

672
00:23:15,440 --> 00:23:16,799
of our approach where we run this case

673
00:23:16,799 --> 00:23:19,120
study now like i said before we observed

674
00:23:19,120 --> 00:23:20,799
that we could see labeled as well as

675
00:23:20,799 --> 00:23:23,440
unlabeled data in the label secrecy

676
00:23:23,440 --> 00:23:26,320
context but at the same time what if the

677
00:23:26,320 --> 00:23:28,159
user wants to see different kinds of

678
00:23:28,159 --> 00:23:29,760
label data in the same context what are

679
00:23:29,760 --> 00:23:31,039
the user wants to see medical and

680
00:23:31,039 --> 00:23:33,120
financial and enterprise in the same

681
00:23:33,120 --> 00:23:34,240
context

682
00:23:34,240 --> 00:23:35,760
in that case you would need an

683
00:23:35,760 --> 00:23:37,600
application that actually accumulates

684
00:23:37,600 --> 00:23:39,600
labels rather than suffers from poly

685
00:23:39,600 --> 00:23:41,360
instantiation so essentially you would

686
00:23:41,360 --> 00:23:43,520
need an application that is a system map

687
00:23:43,520 --> 00:23:45,919
that can be trusted and can override all

688
00:23:45,919 --> 00:23:48,320
instantiation for its uh

689
00:23:48,320 --> 00:23:51,679
for its workflows the other caveat that

690
00:23:51,679 --> 00:23:54,000
we observed was that updates made to

691
00:23:54,000 --> 00:23:55,840
files on the default layer were not

692
00:23:55,840 --> 00:23:57,440
actually being propagated to their

693
00:23:57,440 --> 00:23:59,520
copies on label layers so essentially

694
00:23:59,520 --> 00:24:01,440
what we observed was that the contacts

695
00:24:01,440 --> 00:24:04,559
from the unlabeled context that we saw

696
00:24:04,559 --> 00:24:06,559
in the enterprise instance of canine

697
00:24:06,559 --> 00:24:09,600
email were actually their old versions

698
00:24:09,600 --> 00:24:11,440
the updates that had been made to the

699
00:24:11,440 --> 00:24:13,600
contacts on the unlabeled layer had not

700
00:24:13,600 --> 00:24:14,960
actually been propagated and this is

701
00:24:14,960 --> 00:24:16,640
actually a very hard problem that

702
00:24:16,640 --> 00:24:18,480
results from using a file layer copy and

703
00:24:18,480 --> 00:24:21,120
write mechanism

704
00:24:21,120 --> 00:24:23,760
so to summarize we need diffic on

705
00:24:23,760 --> 00:24:25,600
android if you want to keep using

706
00:24:25,600 --> 00:24:27,840
application data sharing without the

707
00:24:27,840 --> 00:24:30,400
risk of unauthorized data disclosure

708
00:24:30,400 --> 00:24:32,720
at the same time enforcing dfc is really

709
00:24:32,720 --> 00:24:34,720
hard when we can't solve the problems

710
00:24:34,720 --> 00:24:36,880
associated with floating labels

711
00:24:36,880 --> 00:24:39,120
so our approach makes floating label

712
00:24:39,120 --> 00:24:41,840
enforcement context sensitive thereby

713
00:24:41,840 --> 00:24:44,720
making it possible to use on android

714
00:24:44,720 --> 00:24:46,320
that said there are still some open

715
00:24:46,320 --> 00:24:47,840
challenges now we've already discussed

716
00:24:47,840 --> 00:24:48,960
the first two challenges of a

717
00:24:48,960 --> 00:24:50,960
centralized perspective or propagating

718
00:24:50,960 --> 00:24:53,360
changes made to the default layer

719
00:24:53,360 --> 00:24:54,960
the other challenge is that of instance

720
00:24:54,960 --> 00:24:57,120
explosion so an application could launch

721
00:24:57,120 --> 00:24:58,960
a denial of service attack on another

722
00:24:58,960 --> 00:25:01,679
application by starting a large number

723
00:25:01,679 --> 00:25:03,520
of instances of that application and

724
00:25:03,520 --> 00:25:05,279
that is possible and we're trying ways

725
00:25:05,279 --> 00:25:07,760
to rate limit instance creation in order

726
00:25:07,760 --> 00:25:08,960
to prevent that

727
00:25:08,960 --> 00:25:10,400
the final challenge that we're trying to

728
00:25:10,400 --> 00:25:12,640
deal with is that of defining trusted

729
00:25:12,640 --> 00:25:14,240
domain so defining trusted domains for

730
00:25:14,240 --> 00:25:16,080
domain declassification that essentially

731
00:25:16,080 --> 00:25:18,400
is a policy specification challenge

732
00:25:18,400 --> 00:25:20,080
so with this and my talk and i'll be

733
00:25:20,080 --> 00:25:23,460
happy to take questions thank you

734
00:25:23,460 --> 00:25:29,499
[Applause]

735
00:25:29,600 --> 00:25:32,080
questions

736
00:25:32,960 --> 00:25:35,200
uh oh lins fernandez university michigan

737
00:25:35,200 --> 00:25:37,120
um so when you explain uh floating

738
00:25:37,120 --> 00:25:39,440
labels with poly instantiation

739
00:25:39,440 --> 00:25:41,760
um i don't understand why i think on

740
00:25:41,760 --> 00:25:44,960
flyer slide 15 and 16 why w prime cannot

741
00:25:44,960 --> 00:25:45,840
just

742
00:25:45,840 --> 00:25:47,279
uh contact

743
00:25:47,279 --> 00:25:48,559
the

744
00:25:48,559 --> 00:25:51,918
the recipient of the pits

745
00:25:52,480 --> 00:25:54,000
could you repeat the question please

746
00:25:54,000 --> 00:25:56,480
like on on slide 15 or 16

747
00:25:56,480 --> 00:25:58,720
uh when you introduce floating labels

748
00:25:58,720 --> 00:26:01,440
with uh poly instantiation

749
00:26:01,440 --> 00:26:04,400
um yeah why can't why can't that q prime

750
00:26:04,400 --> 00:26:06,480
yeah just contact q

751
00:26:06,480 --> 00:26:09,279
so q prime is a fresh instance of q1

752
00:26:09,279 --> 00:26:12,720
that is created from a static copy of q1

753
00:26:12,720 --> 00:26:14,240
so android components always have a

754
00:26:14,240 --> 00:26:16,159
static definition and new components are

755
00:26:16,159 --> 00:26:18,480
created from the static copy and q prime

756
00:26:18,480 --> 00:26:22,000
is just a copy of the component q1 now q

757
00:26:22,000 --> 00:26:25,279
prime is just like q1 and q2 q prime is

758
00:26:25,279 --> 00:26:27,279
programmed to contact q

759
00:26:27,279 --> 00:26:29,360
only if it has not been contacted by p

760
00:26:29,360 --> 00:26:30,240
first

761
00:26:30,240 --> 00:26:32,400
so since q prime has been called by p it

762
00:26:32,400 --> 00:26:34,240
will not queue back call q back that is

763
00:26:34,240 --> 00:26:36,240
the whole point of this attack now if q

764
00:26:36,240 --> 00:26:38,240
prime really calls q then q gets the

765
00:26:38,240 --> 00:26:41,520
label l1 and the attack is defeated

766
00:26:41,520 --> 00:26:44,720
i see but but um p has called q prime

767
00:26:44,720 --> 00:26:45,919
here right

768
00:26:45,919 --> 00:26:48,400
right p no p has called so the way this

769
00:26:48,400 --> 00:26:50,640
works is that p calls q one but the call

770
00:26:50,640 --> 00:26:53,120
is intercepted and diverted to q prime

771
00:26:53,120 --> 00:26:55,279
and the operating system does i see okay

772
00:26:55,279 --> 00:26:57,520
okay so actually it was a call at q one

773
00:26:57,520 --> 00:26:59,279
right and p is completely unaware of

774
00:26:59,279 --> 00:27:01,200
this he's even unaware of that it has

775
00:27:01,200 --> 00:27:03,360
actually been delivered to q prime yeah

776
00:27:03,360 --> 00:27:06,600
thank you

777
00:27:08,559 --> 00:27:10,720
university very nice work first of all

778
00:27:10,720 --> 00:27:12,799
uh two short questions

779
00:27:12,799 --> 00:27:14,880
the first about the network network

780
00:27:14,880 --> 00:27:16,960
declassification and creating

781
00:27:16,960 --> 00:27:20,399
of labels so applications today uh make

782
00:27:20,399 --> 00:27:23,279
more and more use of web views to

783
00:27:23,279 --> 00:27:24,960
integrate like platform independent

784
00:27:24,960 --> 00:27:26,320
languages

785
00:27:26,320 --> 00:27:28,159
and web users can interact with the

786
00:27:28,159 --> 00:27:31,200
system through java bridge code so

787
00:27:31,200 --> 00:27:34,399
in declassification and creating labels

788
00:27:34,399 --> 00:27:36,399
when you have web views with potentially

789
00:27:36,399 --> 00:27:38,960
different origins do you consider this

790
00:27:38,960 --> 00:27:39,760
or

791
00:27:39,760 --> 00:27:41,520
i mean this could be a cool extension

792
00:27:41,520 --> 00:27:45,039
for or right yes i see a point so

793
00:27:45,039 --> 00:27:47,600
what whenever we start a new instance of

794
00:27:47,600 --> 00:27:48,399
an

795
00:27:48,399 --> 00:27:50,159
application or a component we started

796
00:27:50,159 --> 00:27:52,480
based on the caller's context now if

797
00:27:52,480 --> 00:27:54,080
there are calls from different context

798
00:27:54,080 --> 00:27:56,640
the webview will be re-initialized so we

799
00:27:56,640 --> 00:27:57,520
do

800
00:27:57,520 --> 00:27:59,360
to some extent we do pauline instantiate

801
00:27:59,360 --> 00:28:00,960
webviews but they're just

802
00:28:00,960 --> 00:28:02,960
created as a part of their parent

803
00:28:02,960 --> 00:28:04,640
activity instances okay but it also has

804
00:28:04,640 --> 00:28:06,720
to the wave work back so if data's

805
00:28:06,720 --> 00:28:08,080
coming in from the network you also

806
00:28:08,080 --> 00:28:10,240
probably have to so if data is coming

807
00:28:10,240 --> 00:28:12,000
into the network it'll still coming keep

808
00:28:12,000 --> 00:28:13,679
coming into the instance that is already

809
00:28:13,679 --> 00:28:15,520
active that instance won't be disturbed

810
00:28:15,520 --> 00:28:17,440
you'll just create another copy that

811
00:28:17,440 --> 00:28:19,840
will execute that particular call and

812
00:28:19,840 --> 00:28:21,360
the way activities work is that they

813
00:28:21,360 --> 00:28:23,600
react to the call right so if there's an

814
00:28:23,600 --> 00:28:25,679
activity that has a webview it is also

815
00:28:25,679 --> 00:28:27,440
going to react to a call that it gets

816
00:28:27,440 --> 00:28:30,159
based on what the calls attributes say

817
00:28:30,159 --> 00:28:31,360
okay so it is going to initialize the

818
00:28:31,360 --> 00:28:33,679
babies according to goal anyways and

819
00:28:33,679 --> 00:28:36,159
secondly a very short question um

820
00:28:36,159 --> 00:28:38,240
you create the instances also based on

821
00:28:38,240 --> 00:28:40,640
the labels assigned to files

822
00:28:40,640 --> 00:28:41,520
um

823
00:28:41,520 --> 00:28:43,360
i presume these labels are persistent so

824
00:28:43,360 --> 00:28:44,720
if the file is

825
00:28:44,720 --> 00:28:46,159
if the application that created this

826
00:28:46,159 --> 00:28:47,840
label is de-installed you might have

827
00:28:47,840 --> 00:28:51,200
like dangling labels that right might be

828
00:28:51,200 --> 00:28:52,960
a problem then that have to be cleaned

829
00:28:52,960 --> 00:28:53,919
up or

830
00:28:53,919 --> 00:28:55,360
right so

831
00:28:55,360 --> 00:28:57,120
while instantiation partially solves

832
00:28:57,120 --> 00:28:59,760
this problem so an application can only

833
00:28:59,760 --> 00:29:01,679
leave dangling labels to its own

834
00:29:01,679 --> 00:29:03,440
internal files which are deleted anyways

835
00:29:03,440 --> 00:29:05,600
on android so on android if you'd say

836
00:29:05,600 --> 00:29:07,039
internal directory or if it's your

837
00:29:07,039 --> 00:29:09,760
external directory it's deleted when the

838
00:29:09,760 --> 00:29:11,520
application is uninstalled so the files

839
00:29:11,520 --> 00:29:12,399
don't remain

840
00:29:12,399 --> 00:29:14,399
now when it comes to common files that

841
00:29:14,399 --> 00:29:16,720
the application can write to those files

842
00:29:16,720 --> 00:29:19,279
are still context specific so we are

843
00:29:19,279 --> 00:29:21,360
still looking for ways to

844
00:29:21,360 --> 00:29:23,600
use other applications super user

845
00:29:23,600 --> 00:29:25,360
applications for the user that can

846
00:29:25,360 --> 00:29:27,039
actually allow the user to pick a

847
00:29:27,039 --> 00:29:28,559
different label and view files of that

848
00:29:28,559 --> 00:29:30,399
label so the files would still be

849
00:29:30,399 --> 00:29:32,159
accessible and you're right the label is

850
00:29:32,159 --> 00:29:33,440
persistent so otherwise there would be

851
00:29:33,440 --> 00:29:35,520
dangling cables but that's still that's

852
00:29:35,520 --> 00:29:37,279
still a part of the usability aspect of

853
00:29:37,279 --> 00:29:38,399
the operator that we're looking into

854
00:29:38,399 --> 00:29:41,799
okay thank you

855
00:29:42,159 --> 00:29:44,320
hi great work amir ramadi from

856
00:29:44,320 --> 00:29:46,559
university of michigan uh

857
00:29:46,559 --> 00:29:48,640
the poll instantiation doesn't really

858
00:29:48,640 --> 00:29:51,039
take care of the dead man switch side

859
00:29:51,039 --> 00:29:54,080
channel does it so if for example q1

860
00:29:54,080 --> 00:29:55,600
knows that

861
00:29:55,600 --> 00:29:58,159
it should be contacted by p

862
00:29:58,159 --> 00:30:00,320
in a given time

863
00:30:00,320 --> 00:30:03,440
and if if such a contact isn't made it

864
00:30:03,440 --> 00:30:05,520
knows that it probably gained

865
00:30:05,520 --> 00:30:06,840
that

866
00:30:06,840 --> 00:30:09,840
label then it would then it could still

867
00:30:09,840 --> 00:30:13,039
transfer to q that's so this hasn't

868
00:30:13,039 --> 00:30:14,640
happened yeah i see the point in trying

869
00:30:14,640 --> 00:30:16,799
to make so if q1 knows that it's

870
00:30:16,799 --> 00:30:18,640
supposed to be contacted by p in a

871
00:30:18,640 --> 00:30:20,559
certain time

872
00:30:20,559 --> 00:30:21,360
and

873
00:30:21,360 --> 00:30:23,679
if p already has a label cp already has

874
00:30:23,679 --> 00:30:26,799
a label l1 even if p calls q1 the call

875
00:30:26,799 --> 00:30:28,559
will not be delivered to q1 but it will

876
00:30:28,559 --> 00:30:30,960
be delivered to another instance of q1

877
00:30:30,960 --> 00:30:33,679
so that instance of q1

878
00:30:33,679 --> 00:30:35,679
will be labeled accordingly so it will

879
00:30:35,679 --> 00:30:38,320
not escape the label and this existing

880
00:30:38,320 --> 00:30:39,919
instance of q and we'll still keep

881
00:30:39,919 --> 00:30:41,200
thinking

882
00:30:41,200 --> 00:30:42,000
that

883
00:30:42,000 --> 00:30:43,760
uh will still keep will still be

884
00:30:43,760 --> 00:30:45,840
ambiguous it won't know if the data if p

885
00:30:45,840 --> 00:30:48,320
even exists or if p has made the call or

886
00:30:48,320 --> 00:30:50,080
if we already have the secret data true

887
00:30:50,080 --> 00:30:53,120
but doesn't that instantiation create an

888
00:30:53,120 --> 00:30:55,360
obvious time difference timing side

889
00:30:55,360 --> 00:30:57,279
channel so the time it takes to

890
00:30:57,279 --> 00:30:58,960
instantiate

891
00:30:58,960 --> 00:31:01,039
compared to the time when q1 the

892
00:31:01,039 --> 00:31:02,960
original q1 would contact you there

893
00:31:02,960 --> 00:31:05,039
would be a difference in timing right so

894
00:31:05,039 --> 00:31:06,960
it may so it may create for a

895
00:31:06,960 --> 00:31:08,880
conventional system but for android

896
00:31:08,880 --> 00:31:10,480
where most of the communication is

897
00:31:10,480 --> 00:31:11,840
indirect

898
00:31:11,840 --> 00:31:13,679
application components cannot really

899
00:31:13,679 --> 00:31:15,519
observe the time for instantiation

900
00:31:15,519 --> 00:31:17,760
before they're actually instantiated

901
00:31:17,760 --> 00:31:19,440
so before you instantiate it you don't

902
00:31:19,440 --> 00:31:21,120
know actually when the instantiation

903
00:31:21,120 --> 00:31:22,720
started there is no way for a component

904
00:31:22,720 --> 00:31:25,440
to know when the call was actually made

905
00:31:25,440 --> 00:31:26,640
unless

906
00:31:26,640 --> 00:31:28,320
unless it has some communication with

907
00:31:28,320 --> 00:31:29,360
the caller

908
00:31:29,360 --> 00:31:31,039
okay thank you

909
00:31:31,039 --> 00:31:35,080
all right thank you very much

