1
00:00:10,639 --> 00:00:11,599
hi

2
00:00:11,599 --> 00:00:13,280
as you heard i'll be presenting faster

3
00:00:13,280 --> 00:00:15,040
malicious two-party secure computation

4
00:00:15,040 --> 00:00:17,520
with online offline dual execution

5
00:00:17,520 --> 00:00:21,439
a joint works myself and mike roselek

6
00:00:24,240 --> 00:00:25,199
so

7
00:00:25,199 --> 00:00:27,119
at high level secure two-party

8
00:00:27,119 --> 00:00:29,359
computation allows alice and bob to

9
00:00:29,359 --> 00:00:31,119
evaluate a function f

10
00:00:31,119 --> 00:00:33,200
without revealing their respective

11
00:00:33,200 --> 00:00:35,440
inputs to the other party

12
00:00:35,440 --> 00:00:37,200
another way of thinking about it is to

13
00:00:37,200 --> 00:00:40,079
compare it to the so-called ideal world

14
00:00:40,079 --> 00:00:41,840
where alice and bob privately will hand

15
00:00:41,840 --> 00:00:44,399
their inputs to a magical black box

16
00:00:44,399 --> 00:00:47,039
this box will compute the function f and

17
00:00:47,039 --> 00:00:51,120
hand them back the final result

18
00:00:51,680 --> 00:00:53,680
and furthermore in this work we're

19
00:00:53,680 --> 00:00:55,760
concerned about malicious adversaries

20
00:00:55,760 --> 00:00:57,280
that can arbitrarily deviate from the

21
00:00:57,280 --> 00:00:58,960
protocol so we don't put any

22
00:00:58,960 --> 00:01:01,359
restrictions on what bob can do

23
00:01:01,359 --> 00:01:02,320
and

24
00:01:02,320 --> 00:01:04,400
even in this uh

25
00:01:04,400 --> 00:01:06,479
with this much power we'd like to say

26
00:01:06,479 --> 00:01:08,799
that a bob in the real protocol can do

27
00:01:08,799 --> 00:01:10,640
no more than he would be able to do in

28
00:01:10,640 --> 00:01:12,640
this sort of idealized world where he

29
00:01:12,640 --> 00:01:14,080
effectively just gets to choose his

30
00:01:14,080 --> 00:01:16,399
input

31
00:01:16,479 --> 00:01:18,560
this could be formalized into saying

32
00:01:18,560 --> 00:01:20,960
that for all adversaries bob there

33
00:01:20,960 --> 00:01:22,960
should exist a simulator and what this

34
00:01:22,960 --> 00:01:24,240
simulator should do is be able to

35
00:01:24,240 --> 00:01:26,960
generate a view of bob's

36
00:01:26,960 --> 00:01:28,720
bob's view of the protocol and

37
00:01:28,720 --> 00:01:30,320
furthermore this view

38
00:01:30,320 --> 00:01:32,560
should only depend on bob's input and

39
00:01:32,560 --> 00:01:34,960
the final result that is we should be

40
00:01:34,960 --> 00:01:37,040
able to generate this view bob zoo

41
00:01:37,040 --> 00:01:41,000
without knowing x itself

42
00:01:41,280 --> 00:01:43,119
to make it a little bit more concrete uh

43
00:01:43,119 --> 00:01:44,399
we've sent some of my favorite

44
00:01:44,399 --> 00:01:46,960
applications of two-party computation

45
00:01:46,960 --> 00:01:48,640
firstly is like private database

46
00:01:48,640 --> 00:01:52,000
querying uh maybe alice holds a database

47
00:01:52,000 --> 00:01:54,079
and bob holds a query and they both want

48
00:01:54,079 --> 00:01:55,119
to keep them private from the other

49
00:01:55,119 --> 00:01:57,840
party and so this can be framed as a

50
00:01:57,840 --> 00:01:59,360
classic two-party secure computation

51
00:01:59,360 --> 00:02:01,200
where the query is just simply evaluated

52
00:02:01,200 --> 00:02:03,840
inside of this protocol

53
00:02:03,840 --> 00:02:05,119
similarly machine learning can be

54
00:02:05,119 --> 00:02:06,719
performed by

55
00:02:06,719 --> 00:02:08,639
providing private data sets and then the

56
00:02:08,639 --> 00:02:10,878
model is released uh only at the end

57
00:02:10,878 --> 00:02:12,400
without revealing any intermediate

58
00:02:12,400 --> 00:02:16,000
values or the data sets themselves

59
00:02:16,000 --> 00:02:18,400
uh in this work we build on the yao's

60
00:02:18,400 --> 00:02:20,640
garble circuit protocol which at a high

61
00:02:20,640 --> 00:02:22,480
level can be thought of as the following

62
00:02:22,480 --> 00:02:24,560
one of the parties in this case bob does

63
00:02:24,560 --> 00:02:26,720
what we call garble the function f and

64
00:02:26,720 --> 00:02:28,640
this can be thought of as computing a

65
00:02:28,640 --> 00:02:29,840
sort of an encrypted version of the

66
00:02:29,840 --> 00:02:30,959
function

67
00:02:30,959 --> 00:02:33,120
and he hard codes his input into this

68
00:02:33,120 --> 00:02:34,560
encryption

69
00:02:34,560 --> 00:02:36,640
uh and then the two parties perform this

70
00:02:36,640 --> 00:02:39,200
sub protocol known as oblivious transfer

71
00:02:39,200 --> 00:02:41,760
where alice obtains a sort of a garbled

72
00:02:41,760 --> 00:02:43,120
version of her input sort of an

73
00:02:43,120 --> 00:02:44,720
encryption of it

74
00:02:44,720 --> 00:02:45,519
uh

75
00:02:45,519 --> 00:02:48,480
and along with um the garbled function

76
00:02:48,480 --> 00:02:50,560
in which she can then evaluate the

77
00:02:50,560 --> 00:02:53,040
function and obtain

78
00:02:53,040 --> 00:02:55,440
a garbled output encoding

79
00:02:55,440 --> 00:02:57,519
and i'll use this notation of f x in the

80
00:02:57,519 --> 00:02:59,599
box to denote this sort of output

81
00:02:59,599 --> 00:03:01,360
encoding

82
00:03:01,360 --> 00:03:03,519
and uh furthermore bob since he

83
00:03:03,519 --> 00:03:05,200
generated the circuit knows

84
00:03:05,200 --> 00:03:07,120
uh the whole uh possible set of

85
00:03:07,120 --> 00:03:08,720
encodings while alice just knows this

86
00:03:08,720 --> 00:03:10,959
one which encodes the output

87
00:03:10,959 --> 00:03:12,480
uh there are several security properties

88
00:03:12,480 --> 00:03:13,840
that we get from this protocol and the

89
00:03:13,840 --> 00:03:15,680
first is uh the alice should learn no

90
00:03:15,680 --> 00:03:17,360
more than f x

91
00:03:17,360 --> 00:03:18,640
y

92
00:03:18,640 --> 00:03:20,239
and the second one is that this output

93
00:03:20,239 --> 00:03:21,840
encoding should have this authenticity

94
00:03:21,840 --> 00:03:24,319
property that she shouldn't be able to

95
00:03:24,319 --> 00:03:26,720
guess any of the other output encodings

96
00:03:26,720 --> 00:03:28,159
and we'll use this fact later when we

97
00:03:28,159 --> 00:03:29,760
start combining this protocol in more

98
00:03:29,760 --> 00:03:31,760
complicated ways

99
00:03:31,760 --> 00:03:34,640
so zooming out bob provides the function

100
00:03:34,640 --> 00:03:35,360
f

101
00:03:35,360 --> 00:03:37,840
and alice provides her input and she

102
00:03:37,840 --> 00:03:39,680
obtains sort of output encoding of the

103
00:03:39,680 --> 00:03:41,519
function evaluated at their inputs and

104
00:03:41,519 --> 00:03:44,480
this is all she learns

105
00:03:44,879 --> 00:03:47,599
one big problem with this uh protocol is

106
00:03:47,599 --> 00:03:50,080
that it is not secure against uh when

107
00:03:50,080 --> 00:03:51,920
bob acts maliciously in that he can

108
00:03:51,920 --> 00:03:53,519
provide a different function in this

109
00:03:53,519 --> 00:03:57,200
case g which just takes alice's input uh

110
00:03:57,200 --> 00:03:59,439
and so in this case alice will obtain

111
00:03:59,439 --> 00:04:02,319
this authenticated output encoding for g

112
00:04:02,319 --> 00:04:04,400
evaluated at her input

113
00:04:04,400 --> 00:04:05,680
and uh

114
00:04:05,680 --> 00:04:07,200
this there are only a few restrictions

115
00:04:07,200 --> 00:04:09,200
on what this g function can be and for

116
00:04:09,200 --> 00:04:11,040
one example it could just output alice's

117
00:04:11,040 --> 00:04:13,439
input and if in the larger context that

118
00:04:13,439 --> 00:04:15,599
this protocol is being run it may be

119
00:04:15,599 --> 00:04:17,759
possible that alice will then show bob

120
00:04:17,759 --> 00:04:19,199
this output

121
00:04:19,199 --> 00:04:22,160
and so alice would lose all her privacy

122
00:04:22,160 --> 00:04:23,680
and there's we've definitely lost

123
00:04:23,680 --> 00:04:25,520
correctness in that alice thought she

124
00:04:25,520 --> 00:04:27,919
was evaluating the function f x y but in

125
00:04:27,919 --> 00:04:29,840
reality she wasn't

126
00:04:29,840 --> 00:04:31,919
and this is not always detectable

127
00:04:31,919 --> 00:04:33,759
maybe in the case where g is just output

128
00:04:33,759 --> 00:04:35,840
x but in general bob can be clever about

129
00:04:35,840 --> 00:04:39,440
he how he constructs this function g

130
00:04:39,440 --> 00:04:41,199
all right so one of the major lines of

131
00:04:41,199 --> 00:04:44,720
research in this area has been how to

132
00:04:44,720 --> 00:04:46,560
strengthen this weakness of the in the

133
00:04:46,560 --> 00:04:48,479
owl's global circuit protocol and one of

134
00:04:48,479 --> 00:04:50,160
the promising

135
00:04:50,160 --> 00:04:53,199
techniques is known as dual execution

136
00:04:53,199 --> 00:04:56,240
started by mahasal and franklin in 2006

137
00:04:56,240 --> 00:04:58,720
in which you simply run this protocol in

138
00:04:58,720 --> 00:05:00,479
both directions where the each party

139
00:05:00,479 --> 00:05:02,080
gets to specify the function in one of

140
00:05:02,080 --> 00:05:04,080
the instances

141
00:05:04,080 --> 00:05:06,400
they proceed by providing inputs

142
00:05:06,400 --> 00:05:08,160
and each of them receive the

143
00:05:08,160 --> 00:05:10,880
corresponding output encoding under

144
00:05:10,880 --> 00:05:12,560
different encodings shown by the

145
00:05:12,560 --> 00:05:13,840
subscripts here

146
00:05:13,840 --> 00:05:16,400
and so one idea oh yeah the first one is

147
00:05:16,400 --> 00:05:18,400
secure against alice

148
00:05:18,400 --> 00:05:19,759
in that she doesn't get to specify the

149
00:05:19,759 --> 00:05:21,280
function and similarly the second one is

150
00:05:21,280 --> 00:05:24,560
secure against bob

151
00:05:24,560 --> 00:05:26,080
and now one idea would be simply to

152
00:05:26,080 --> 00:05:29,039
compare these two output encodings

153
00:05:29,039 --> 00:05:31,520
for equality however we have one little

154
00:05:31,520 --> 00:05:33,039
hiccup in that

155
00:05:33,039 --> 00:05:34,160
because they're under different

156
00:05:34,160 --> 00:05:35,440
encodings

157
00:05:35,440 --> 00:05:36,800
we can't directly compare them for

158
00:05:36,800 --> 00:05:39,759
equality and so we defined this uh or

159
00:05:39,759 --> 00:05:42,320
they define this uh common output

160
00:05:42,320 --> 00:05:44,080
encoding

161
00:05:44,080 --> 00:05:45,440
which is just the xor of the two

162
00:05:45,440 --> 00:05:47,600
encodings and since alice knows all of

163
00:05:47,600 --> 00:05:49,919
hers and she knows one under bobs she

164
00:05:49,919 --> 00:05:52,800
can compute one output encoding that is

165
00:05:52,800 --> 00:05:55,759
for f x y under this common encoding and

166
00:05:55,759 --> 00:05:57,520
so then they can simply compare for

167
00:05:57,520 --> 00:05:58,639
equality

168
00:05:58,639 --> 00:06:00,560
now assuming that these parties are all

169
00:06:00,560 --> 00:06:03,120
honest that equality check check will

170
00:06:03,120 --> 00:06:06,160
always say yes they are equal

171
00:06:06,160 --> 00:06:09,520
however if bob is malicious again he may

172
00:06:09,520 --> 00:06:11,520
provide this other function g

173
00:06:11,520 --> 00:06:13,120
and now alice will hold an output

174
00:06:13,120 --> 00:06:14,800
encoding for

175
00:06:14,800 --> 00:06:17,360
g evaluated at x and so there are

176
00:06:17,360 --> 00:06:19,199
intuitively two possible outcomes of a

177
00:06:19,199 --> 00:06:21,199
quality check either they're equal or

178
00:06:21,199 --> 00:06:23,759
they're not in the case they are equal

179
00:06:23,759 --> 00:06:24,880
then

180
00:06:24,880 --> 00:06:27,120
alice will accept her output as in fact

181
00:06:27,120 --> 00:06:29,120
g of x is the correct value

182
00:06:29,120 --> 00:06:30,880
however if they're not equal alice will

183
00:06:30,880 --> 00:06:33,440
know bob was being malicious and she'll

184
00:06:33,440 --> 00:06:35,600
simply abort and not accept the output

185
00:06:35,600 --> 00:06:38,080
however from bob's perspective he learns

186
00:06:38,080 --> 00:06:39,680
two things the

187
00:06:39,680 --> 00:06:42,160
correct output f x y and the single bit

188
00:06:42,160 --> 00:06:44,560
of additional information which can be

189
00:06:44,560 --> 00:06:46,639
expressed as this predicate

190
00:06:46,639 --> 00:06:48,240
and so this can be formally said that

191
00:06:48,240 --> 00:06:49,840
bob learns only a single bit of

192
00:06:49,840 --> 00:06:51,759
additional information

193
00:06:51,759 --> 00:06:53,440
uh and we get one other additional

194
00:06:53,440 --> 00:06:55,520
security property that is nice in that

195
00:06:55,520 --> 00:06:57,599
alice will never accept uh incorrect

196
00:06:57,599 --> 00:06:58,720
output

197
00:06:58,720 --> 00:07:00,639
because the only time she holds the

198
00:07:00,639 --> 00:07:02,400
incorrect output encoding the equality

199
00:07:02,400 --> 00:07:03,599
check will say

200
00:07:03,599 --> 00:07:05,759
no and she'll simply abort

201
00:07:05,759 --> 00:07:07,759
and so this property will carry over

202
00:07:07,759 --> 00:07:11,120
into our protocol as well

203
00:07:11,440 --> 00:07:13,759
moving forward at klesnikov mahasal riva

204
00:07:13,759 --> 00:07:15,759
and roselek in 2015

205
00:07:15,759 --> 00:07:17,840
improved this protocol by adding a

206
00:07:17,840 --> 00:07:20,000
technique known as cut and choose

207
00:07:20,000 --> 00:07:22,960
uh here instead of sending one

208
00:07:22,960 --> 00:07:24,800
circuit or function in both direction

209
00:07:24,800 --> 00:07:27,039
they send many copies shown here i have

210
00:07:27,039 --> 00:07:29,280
four but in practice they may be more

211
00:07:29,280 --> 00:07:31,120
like 40.

212
00:07:31,120 --> 00:07:33,120
and then once the circuits arrive at the

213
00:07:33,120 --> 00:07:34,800
other party they check some of them for

214
00:07:34,800 --> 00:07:36,800
correctness and if any were shown to be

215
00:07:36,800 --> 00:07:38,880
maliciously constructed they'll simply

216
00:07:38,880 --> 00:07:40,560
abort and otherwise they have some

217
00:07:40,560 --> 00:07:42,960
confidence that the remaining circuits

218
00:07:42,960 --> 00:07:44,960
have were at least mostly generated

219
00:07:44,960 --> 00:07:47,520
correctly that's the hope anyways

220
00:07:47,520 --> 00:07:49,440
um so they can provide inputs the

221
00:07:49,440 --> 00:07:51,360
remaining unopened

222
00:07:51,360 --> 00:07:53,840
instances and obtain this

223
00:07:53,840 --> 00:07:55,759
common output encoding

224
00:07:55,759 --> 00:07:57,120
and since right now all parties are

225
00:07:57,120 --> 00:07:59,039
honest they should only get this single

226
00:07:59,039 --> 00:08:01,199
output encoding value and again we can

227
00:08:01,199 --> 00:08:03,199
compare for equality

228
00:08:03,199 --> 00:08:06,800
uh so great this sounds good but however

229
00:08:06,800 --> 00:08:09,599
what happens if bob is malicious again

230
00:08:09,599 --> 00:08:11,199
well first let's consider the case where

231
00:08:11,199 --> 00:08:13,360
he just uh provides one malicious

232
00:08:13,360 --> 00:08:14,319
function

233
00:08:14,319 --> 00:08:16,879
and so all the check circuits are

234
00:08:16,879 --> 00:08:19,280
checked by alice still pass but he gets

235
00:08:19,280 --> 00:08:21,520
one maliciously constructed

236
00:08:21,520 --> 00:08:22,960
circuit through

237
00:08:22,960 --> 00:08:24,560
and in this case

238
00:08:24,560 --> 00:08:26,319
alice will have two possible output

239
00:08:26,319 --> 00:08:28,319
encoding values the one for the correct

240
00:08:28,319 --> 00:08:30,800
evaluate on the correct circuit and this

241
00:08:30,800 --> 00:08:33,279
other one z and now alice has a problem

242
00:08:33,279 --> 00:08:35,200
in that she doesn't know which

243
00:08:35,200 --> 00:08:37,440
output encoding to provide to this

244
00:08:37,440 --> 00:08:38,880
equality check

245
00:08:38,880 --> 00:08:40,240
however if we think about this problem a

246
00:08:40,240 --> 00:08:41,599
little bit more

247
00:08:41,599 --> 00:08:43,440
we can see we can think of these two

248
00:08:43,440 --> 00:08:45,120
parties having sets of outputting

249
00:08:45,120 --> 00:08:46,720
codings and then we simply want to see

250
00:08:46,720 --> 00:08:48,720
which one is in an intersection this

251
00:08:48,720 --> 00:08:50,800
follows from alice knowing that bob

252
00:08:50,800 --> 00:08:52,320
holds the correct one and only the

253
00:08:52,320 --> 00:08:54,000
correct one and all other ones are

254
00:08:54,000 --> 00:08:55,839
unpredictable to them

255
00:08:55,839 --> 00:08:58,720
by the security of the garbled circuits

256
00:08:58,720 --> 00:09:00,720
and so we can simply replace this

257
00:09:00,720 --> 00:09:02,560
equality check with the private set

258
00:09:02,560 --> 00:09:04,320
intersection protocol

259
00:09:04,320 --> 00:09:06,640
in this case it will output the correct

260
00:09:06,640 --> 00:09:08,399
output and alice will know which of her

261
00:09:08,399 --> 00:09:10,320
two possible values was actually the

262
00:09:10,320 --> 00:09:11,680
correct one

263
00:09:11,680 --> 00:09:13,600
and furthermore as long as there's one

264
00:09:13,600 --> 00:09:16,160
correct circuit that makes it through

265
00:09:16,160 --> 00:09:19,279
bob will learn no additional information

266
00:09:19,279 --> 00:09:21,920
however if bob gets lucky and gets both

267
00:09:21,920 --> 00:09:24,480
the evaluation circuits to be this

268
00:09:24,480 --> 00:09:26,720
incorrect then alice may hold two output

269
00:09:26,720 --> 00:09:28,480
encodings with neither of them being

270
00:09:28,480 --> 00:09:30,880
equal to the correct value in this case

271
00:09:30,880 --> 00:09:32,640
the intersection of these two sets can

272
00:09:32,640 --> 00:09:34,839
be the null set

273
00:09:34,839 --> 00:09:36,800
and uh

274
00:09:36,800 --> 00:09:38,399
and therefore

275
00:09:38,399 --> 00:09:39,839
this will leak a different additional

276
00:09:39,839 --> 00:09:40,959
information

277
00:09:40,959 --> 00:09:44,000
uh in fact we can say that for if all

278
00:09:44,000 --> 00:09:46,480
the evaluation circuits were maliciously

279
00:09:46,480 --> 00:09:48,720
constructed then uh

280
00:09:48,720 --> 00:09:50,800
this initial predicate one single bit of

281
00:09:50,800 --> 00:09:52,880
information is leaked which is do all

282
00:09:52,880 --> 00:09:55,920
the gi's not equal the correct value

283
00:09:55,920 --> 00:09:58,640
and however this only happens with uh

284
00:09:58,640 --> 00:10:00,560
when all the evaluation circuits are

285
00:10:00,560 --> 00:10:02,720
incorrect and all the check circuits

286
00:10:02,720 --> 00:10:04,720
were correct and so it's not hard to see

287
00:10:04,720 --> 00:10:06,720
that this happens with probability to

288
00:10:06,720 --> 00:10:09,040
the minus s and so if we send 40

289
00:10:09,040 --> 00:10:10,800
circuits we get

290
00:10:10,800 --> 00:10:13,920
quite good statistical security

291
00:10:13,920 --> 00:10:14,800
and so

292
00:10:14,800 --> 00:10:17,040
in our work we take this

293
00:10:17,040 --> 00:10:18,800
dual execution protocol to the online

294
00:10:18,800 --> 00:10:20,640
offline setting where we want to

295
00:10:20,640 --> 00:10:23,760
evaluate the function f end times

296
00:10:23,760 --> 00:10:25,519
so the two parties

297
00:10:25,519 --> 00:10:26,880
construct enough circuits for all

298
00:10:26,880 --> 00:10:29,279
executions and send them over we again

299
00:10:29,279 --> 00:10:31,120
do this cut and choose where you will

300
00:10:31,120 --> 00:10:34,079
bore if you see any incorrect circuits

301
00:10:34,079 --> 00:10:36,160
and otherwise we proceed

302
00:10:36,160 --> 00:10:38,720
however now instead of needing

303
00:10:38,720 --> 00:10:40,800
so we proceed by mapping the remaining

304
00:10:40,800 --> 00:10:43,600
circuits into bins

305
00:10:43,600 --> 00:10:45,440
which in a bin will be used per

306
00:10:45,440 --> 00:10:47,040
evaluation

307
00:10:47,040 --> 00:10:49,279
however before we need like s circuits

308
00:10:49,279 --> 00:10:51,360
but now we need s over log n circuits

309
00:10:51,360 --> 00:10:52,959
where n is the number of evaluations we

310
00:10:52,959 --> 00:10:54,320
want to do

311
00:10:54,320 --> 00:10:56,160
and so it might be reasonable to do a

312
00:10:56,160 --> 00:10:58,320
thousand evaluations of this function

313
00:10:58,320 --> 00:11:00,079
and so this would result in an order

314
00:11:00,079 --> 00:11:01,519
magnitude improvement in the number of

315
00:11:01,519 --> 00:11:03,600
circuits that you need uh and

316
00:11:03,600 --> 00:11:05,120
considering that

317
00:11:05,120 --> 00:11:06,399
the sending of these circuits is the

318
00:11:06,399 --> 00:11:08,240
primary overhead in these protocols this

319
00:11:08,240 --> 00:11:10,480
is a significant improvement

320
00:11:10,480 --> 00:11:12,880
and so the parties can just continue to

321
00:11:12,880 --> 00:11:15,040
map the remaining circuits into these

322
00:11:15,040 --> 00:11:17,120
bins n of them

323
00:11:17,120 --> 00:11:19,839
and then later on they may obtain inputs

324
00:11:19,839 --> 00:11:21,279
and would like to evaluate the function

325
00:11:21,279 --> 00:11:22,560
f

326
00:11:22,560 --> 00:11:24,240
and so they take some of the bins and

327
00:11:24,240 --> 00:11:27,279
run the previous dual execution protocol

328
00:11:27,279 --> 00:11:29,279
evaluate the circuits input the output

329
00:11:29,279 --> 00:11:30,959
encodings into this private set

330
00:11:30,959 --> 00:11:33,760
intersection protocol and reconcile what

331
00:11:33,760 --> 00:11:36,959
value they think it should be

332
00:11:37,440 --> 00:11:40,320
however it's never quite that simple in

333
00:11:40,320 --> 00:11:42,320
that there are several challenges to

334
00:11:42,320 --> 00:11:44,000
face when uh

335
00:11:44,000 --> 00:11:45,839
coming from this previous dual execution

336
00:11:45,839 --> 00:11:48,079
protocol to the online offline setting

337
00:11:48,079 --> 00:11:50,160
and first among them was this problem

338
00:11:50,160 --> 00:11:52,720
known as input consistency

339
00:11:52,720 --> 00:11:54,639
but first let's take a second and think

340
00:11:54,639 --> 00:11:56,800
about what's going on here alice holds

341
00:11:56,800 --> 00:11:58,959
many circuits generated by bob

342
00:11:58,959 --> 00:12:02,320
and vice versa and we need to ensure

343
00:12:02,320 --> 00:12:05,519
that bob provides the correct the same y

344
00:12:05,519 --> 00:12:09,440
to all these circuits or else bob i

345
00:12:09,440 --> 00:12:11,519
provide inconsistent wise which could

346
00:12:11,519 --> 00:12:13,440
open up a attack vector that he could

347
00:12:13,440 --> 00:12:16,079
use to gain additional information

348
00:12:16,079 --> 00:12:19,440
and so we need some way to ensure this

349
00:12:19,440 --> 00:12:21,600
uh looking a little deeper it's not too

350
00:12:21,600 --> 00:12:23,040
hard to see that for the circuits that

351
00:12:23,040 --> 00:12:24,880
were generated by alice which will be

352
00:12:24,880 --> 00:12:27,519
evaluated by bob it's relatively easy to

353
00:12:27,519 --> 00:12:29,920
enforce consistency

354
00:12:29,920 --> 00:12:31,839
in that bob will use this oblivious

355
00:12:31,839 --> 00:12:34,079
transfer protocol to obtain this sort of

356
00:12:34,079 --> 00:12:35,360
garbled y

357
00:12:35,360 --> 00:12:37,519
and it's relatively easy to enforce this

358
00:12:37,519 --> 00:12:40,720
property so that's that's good

359
00:12:40,720 --> 00:12:43,040
however it's much harder for the to

360
00:12:43,040 --> 00:12:44,639
enforce this property for the circuits

361
00:12:44,639 --> 00:12:46,480
that were generated by bob

362
00:12:46,480 --> 00:12:47,920
in this case instead of using this

363
00:12:47,920 --> 00:12:49,839
oblivious transfer protocol

364
00:12:49,839 --> 00:12:51,680
which has some security in it bob simply

365
00:12:51,680 --> 00:12:54,160
just sends this sort of garbled version

366
00:12:54,160 --> 00:12:57,120
of his y for his circuit so alice has no

367
00:12:57,120 --> 00:12:59,360
uh straightforward way of

368
00:12:59,360 --> 00:13:02,079
ensuring that he sent even consistent uh

369
00:13:02,079 --> 00:13:04,480
a consistent y between his circuits or

370
00:13:04,480 --> 00:13:06,800
that the y that he sent for his circuits

371
00:13:06,800 --> 00:13:08,399
or is consistent with the ones he

372
00:13:08,399 --> 00:13:11,360
obtained using oblivious transfer

373
00:13:11,360 --> 00:13:13,760
however we noticed

374
00:13:13,760 --> 00:13:16,399
that we can have bob tell alice a

375
00:13:16,399 --> 00:13:18,399
relationship between the actions that

376
00:13:18,399 --> 00:13:20,320
he'll perform when he does the oblivious

377
00:13:20,320 --> 00:13:22,399
transfer and the actions that he'll

378
00:13:22,399 --> 00:13:24,320
perform when he sends his inputs for his

379
00:13:24,320 --> 00:13:26,639
circuits and furthermore we'll have him

380
00:13:26,639 --> 00:13:29,040
report this relationship in the offline

381
00:13:29,040 --> 00:13:32,000
phase before we do the cut and choose

382
00:13:32,000 --> 00:13:33,519
during the cut and shoes we'll open some

383
00:13:33,519 --> 00:13:35,839
of these uh circuits and we'll check

384
00:13:35,839 --> 00:13:37,600
that bob did in fact tell the truth

385
00:13:37,600 --> 00:13:38,560
about this

386
00:13:38,560 --> 00:13:40,480
relationship

387
00:13:40,480 --> 00:13:43,199
and then given this uh

388
00:13:43,199 --> 00:13:45,760
showing in the online phase alice will

389
00:13:45,760 --> 00:13:47,760
enforce that he sends inputs consistent

390
00:13:47,760 --> 00:13:49,839
with this relationship which implies

391
00:13:49,839 --> 00:13:52,720
that at least one of the circuits held

392
00:13:52,720 --> 00:13:54,880
by alice has the relationship which is

393
00:13:54,880 --> 00:13:57,519
followed and so

394
00:13:57,519 --> 00:13:59,600
and so at least one of the evaluations

395
00:13:59,600 --> 00:14:02,160
that alice holds will in fact evaluate

396
00:14:02,160 --> 00:14:03,600
the correct value

397
00:14:03,600 --> 00:14:05,120
our output encoding and if you recall

398
00:14:05,120 --> 00:14:07,920
from the previous uh slide we all we

399
00:14:07,920 --> 00:14:10,320
need for the psi protocol to succeed is

400
00:14:10,320 --> 00:14:12,399
that she holds at least one circuit

401
00:14:12,399 --> 00:14:16,160
which was correctly uh constructed which

402
00:14:16,160 --> 00:14:18,800
we just satisfied and so in fact this is

403
00:14:18,800 --> 00:14:21,360
all we needed and so we can ensure that

404
00:14:21,360 --> 00:14:24,560
bob sends consistent inputs

405
00:14:24,560 --> 00:14:26,720
and furthermore unlike some previous

406
00:14:26,720 --> 00:14:27,839
approaches

407
00:14:27,839 --> 00:14:29,279
our technique requires almost no

408
00:14:29,279 --> 00:14:31,199
cryptographic operations in the online

409
00:14:31,199 --> 00:14:32,560
phase

410
00:14:32,560 --> 00:14:34,480
which is cannot be said for some of the

411
00:14:34,480 --> 00:14:36,079
other techniques and so this is one of

412
00:14:36,079 --> 00:14:37,760
the reasons why we get

413
00:14:37,760 --> 00:14:41,600
good performance which i'll show later

414
00:14:41,680 --> 00:14:44,079
the second major challenge was how to

415
00:14:44,079 --> 00:14:45,279
instantiate this private set

416
00:14:45,279 --> 00:14:46,959
intersection protocol

417
00:14:46,959 --> 00:14:48,959
the prior works had just left it as a

418
00:14:48,959 --> 00:14:51,360
sort of open question how to best do it

419
00:14:51,360 --> 00:14:53,600
however during when we were implementing

420
00:14:53,600 --> 00:14:57,440
it we saw that uh this psi protocol from

421
00:14:57,440 --> 00:14:59,760
pinkish schneider and zoner of 2014

422
00:14:59,760 --> 00:15:02,399
presented here actually was the fastest

423
00:15:02,399 --> 00:15:04,240
however it was only in the semi-honest

424
00:15:04,240 --> 00:15:05,760
setting

425
00:15:05,760 --> 00:15:07,440
and uh it did not obtain malicious

426
00:15:07,440 --> 00:15:09,360
security

427
00:15:09,360 --> 00:15:11,199
to give some intuition about why it's

428
00:15:11,199 --> 00:15:13,440
not uh malicious secure oh first of all

429
00:15:13,440 --> 00:15:15,760
let me say what it is uh it builds on

430
00:15:15,760 --> 00:15:17,839
this idea of if you have a secure

431
00:15:17,839 --> 00:15:19,199
comparison between

432
00:15:19,199 --> 00:15:21,279
two values you can build a private set

433
00:15:21,279 --> 00:15:23,040
intersection protocol by simply

434
00:15:23,040 --> 00:15:25,519
comparing all all pairwise

435
00:15:25,519 --> 00:15:27,600
and then it's outputting if if any of

436
00:15:27,600 --> 00:15:30,720
your values equal any of his values

437
00:15:30,720 --> 00:15:32,000
however

438
00:15:32,000 --> 00:15:34,160
to see why it's not malicious secure we

439
00:15:34,160 --> 00:15:36,240
can consider sort of a different setting

440
00:15:36,240 --> 00:15:38,399
in that where alice holds three items

441
00:15:38,399 --> 00:15:40,800
and bob just holds one

442
00:15:40,800 --> 00:15:42,800
and so what bob's supposed to do is just

443
00:15:42,800 --> 00:15:45,519
input hit his one value three times

444
00:15:45,519 --> 00:15:47,440
however it's possible for him for the

445
00:15:47,440 --> 00:15:49,759
first comparison to guess that alice's

446
00:15:49,759 --> 00:15:51,199
element was a

447
00:15:51,199 --> 00:15:53,040
and provide a for the first equality

448
00:15:53,040 --> 00:15:55,519
check and so bob will learn the a is in

449
00:15:55,519 --> 00:15:57,600
alice's set and then because he's

450
00:15:57,600 --> 00:15:59,040
malicious he could switch his input

451
00:15:59,040 --> 00:16:01,199
halfway through provide b to the second

452
00:16:01,199 --> 00:16:03,600
equality check learn that b is analysis

453
00:16:03,600 --> 00:16:05,440
set and similarly for the third equality

454
00:16:05,440 --> 00:16:07,680
track you could learn that c is here so

455
00:16:07,680 --> 00:16:10,320
this definitely just violated the

456
00:16:10,320 --> 00:16:12,079
sort of security definition of private

457
00:16:12,079 --> 00:16:13,920
set intersection that

458
00:16:13,920 --> 00:16:15,199
the intersection should have at least

459
00:16:15,199 --> 00:16:17,360
been or at most been one item however

460
00:16:17,360 --> 00:16:19,759
bob just learned alice's full set so

461
00:16:19,759 --> 00:16:22,880
this clearly isn't malicious secure

462
00:16:22,880 --> 00:16:23,920
however

463
00:16:23,920 --> 00:16:26,160
we notice that in our setting bob

464
00:16:26,160 --> 00:16:28,480
doesn't have multiple output encodings

465
00:16:28,480 --> 00:16:29,920
which he can provide to the private set

466
00:16:29,920 --> 00:16:32,639
intersection protocol instead he we know

467
00:16:32,639 --> 00:16:35,680
for a fact that he holds at most one

468
00:16:35,680 --> 00:16:37,279
valid output encoding and this is the

469
00:16:37,279 --> 00:16:39,759
one for the correct value and so alice

470
00:16:39,759 --> 00:16:42,160
holds may hold several but she knows

471
00:16:42,160 --> 00:16:44,160
that all of them are unpredictable to

472
00:16:44,160 --> 00:16:46,000
bob except for possibly the one correct

473
00:16:46,000 --> 00:16:48,240
value and so this attack of switching

474
00:16:48,240 --> 00:16:50,480
inputs no longer applies

475
00:16:50,480 --> 00:16:51,600
and while

476
00:16:51,600 --> 00:16:53,440
so this sort of intuition about why that

477
00:16:53,440 --> 00:16:55,279
previous attack doesn't work can be

478
00:16:55,279 --> 00:16:57,920
formalized into

479
00:16:57,920 --> 00:16:58,959
that

480
00:16:58,959 --> 00:17:00,959
sentence that bob doesn't need or the

481
00:17:00,959 --> 00:17:03,199
simulator doesn't need to extract bob's

482
00:17:03,199 --> 00:17:06,000
input which is a common property to get

483
00:17:06,000 --> 00:17:08,880
malicious secure simulation but instead

484
00:17:08,880 --> 00:17:11,439
we simply just need to test whether

485
00:17:11,439 --> 00:17:14,559
bobset holds this one special value

486
00:17:14,559 --> 00:17:16,880
and so in this way

487
00:17:16,880 --> 00:17:20,000
we are able to show that this psi

488
00:17:20,000 --> 00:17:22,400
protocol is actually malicious secure in

489
00:17:22,400 --> 00:17:24,799
our restricted setting where bob will

490
00:17:24,799 --> 00:17:27,599
know at most one of these inputs

491
00:17:27,599 --> 00:17:29,200
and so our final private set

492
00:17:29,200 --> 00:17:30,960
intersection protocol is just to use

493
00:17:30,960 --> 00:17:32,960
this private equality test to compare

494
00:17:32,960 --> 00:17:34,960
all pairwise except for we show that it

495
00:17:34,960 --> 00:17:38,080
is actually much as secure

496
00:17:39,600 --> 00:17:41,600
now for

497
00:17:41,600 --> 00:17:43,360
talking about performance of our of our

498
00:17:43,360 --> 00:17:45,919
protocol and implementation we evaluated

499
00:17:45,919 --> 00:17:48,960
the aes function and the sha-256

500
00:17:48,960 --> 00:17:50,480
function

501
00:17:50,480 --> 00:17:52,080
and we compare ourselves to the prior

502
00:17:52,080 --> 00:17:55,120
fastest work of lindelriva 2015. they

503
00:17:55,120 --> 00:17:57,280
were also in this online offline setting

504
00:17:57,280 --> 00:17:59,600
we do some pre-processing

505
00:17:59,600 --> 00:18:01,919
and on our online time free value in the

506
00:18:01,919 --> 00:18:03,760
as circuit required just 1.3

507
00:18:03,760 --> 00:18:06,320
milliseconds compared to their

508
00:18:06,320 --> 00:18:10,320
7 milliseconds and almost 5x improvement

509
00:18:10,320 --> 00:18:12,960
we also receive an even bigger order

510
00:18:12,960 --> 00:18:14,240
improvement in the offline phase

511
00:18:14,240 --> 00:18:16,080
requiring just five sec milliseconds

512
00:18:16,080 --> 00:18:18,000
compared to their 74.

513
00:18:18,000 --> 00:18:20,400
and similarly for the larger sha-256

514
00:18:20,400 --> 00:18:22,640
circuit we see a large improvement

515
00:18:22,640 --> 00:18:24,880
requiring just 8.1 milliseconds to their

516
00:18:24,880 --> 00:18:26,400
33.

517
00:18:26,400 --> 00:18:28,960
we also compare ourselves to the

518
00:18:28,960 --> 00:18:31,600
dam guard zachariah work of 2015 while

519
00:18:31,600 --> 00:18:33,919
they use different cryptographic

520
00:18:33,919 --> 00:18:36,160
primitives to build their protocol they

521
00:18:36,160 --> 00:18:38,799
also receive quite good online times of

522
00:18:38,799 --> 00:18:41,520
six milliseconds however

523
00:18:41,520 --> 00:18:43,679
they do not specify their offline times

524
00:18:43,679 --> 00:18:45,520
due to uh requiring some heavy

525
00:18:45,520 --> 00:18:47,280
cryptographic operations and it's

526
00:18:47,280 --> 00:18:49,760
suspected to be quite uh quite slow

527
00:18:49,760 --> 00:18:51,039
and

528
00:18:51,039 --> 00:18:52,880
yeah

529
00:18:52,880 --> 00:18:53,840
um

530
00:18:53,840 --> 00:18:56,000
here is shown sort of the improvement

531
00:18:56,000 --> 00:18:57,840
over the last decade of evaluating the

532
00:18:57,840 --> 00:18:59,440
aes circuit

533
00:18:59,440 --> 00:19:01,440
just to give you an idea of how big our

534
00:19:01,440 --> 00:19:03,760
contribution is so back in 2009 it took

535
00:19:03,760 --> 00:19:05,679
18 minutes to maliciously evaluate this

536
00:19:05,679 --> 00:19:06,799
function

537
00:19:06,799 --> 00:19:10,160
and there's some headway made in 2012

538
00:19:10,160 --> 00:19:11,760
bringing it down to just three about

539
00:19:11,760 --> 00:19:13,440
three seconds

540
00:19:13,440 --> 00:19:15,120
uh however

541
00:19:15,120 --> 00:19:15,840
we

542
00:19:15,840 --> 00:19:18,320
show that uh provided certain order

543
00:19:18,320 --> 00:19:20,000
magnitude improvement from the prior

544
00:19:20,000 --> 00:19:22,840
work of linda riva just requiring six

545
00:19:22,840 --> 00:19:24,960
milliseconds and furthermore if you

546
00:19:24,960 --> 00:19:26,960
compare ourselves to moore's law just

547
00:19:26,960 --> 00:19:28,559
for fun i guess

548
00:19:28,559 --> 00:19:30,559
we can see that this improvement is not

549
00:19:30,559 --> 00:19:32,559
just from faster computers

550
00:19:32,559 --> 00:19:34,880
in fact we are actually introducing many

551
00:19:34,880 --> 00:19:36,240
cryptographic improvements these

552
00:19:36,240 --> 00:19:38,000
protocols which make them substantially

553
00:19:38,000 --> 00:19:39,679
faster

554
00:19:39,679 --> 00:19:40,880
and we aren't just running on bigger

555
00:19:40,880 --> 00:19:43,600
computers because the 2012 work was on a

556
00:19:43,600 --> 00:19:45,520
64 node cluster

557
00:19:45,520 --> 00:19:48,160
followed by performing on a gpu

558
00:19:48,160 --> 00:19:50,400
however the last two works of linda riva

559
00:19:50,400 --> 00:19:51,600
and

560
00:19:51,600 --> 00:19:53,200
was performed on an equal benchmark

561
00:19:53,200 --> 00:19:55,600
using an amazon aws machine which had

562
00:19:55,600 --> 00:19:58,799
like roughly 36 cores or so it's pretty

563
00:19:58,799 --> 00:20:01,280
reasonable

564
00:20:01,440 --> 00:20:04,000
and so in summary uh i guess i'd like

565
00:20:04,000 --> 00:20:06,720
your takeaway to be that for certain

566
00:20:06,720 --> 00:20:08,400
functions at least we can get extremely

567
00:20:08,400 --> 00:20:11,200
fast uh online times with pretty modest

568
00:20:11,200 --> 00:20:13,200
offline times of just five milliseconds

569
00:20:13,200 --> 00:20:14,080
for the

570
00:20:14,080 --> 00:20:16,000
aes circuit

571
00:20:16,000 --> 00:20:18,720
and uh our dual execution protocol also

572
00:20:18,720 --> 00:20:21,440
gets several security advantages over uh

573
00:20:21,440 --> 00:20:23,200
some more classical cut and choose

574
00:20:23,200 --> 00:20:24,480
approach it's a different approach to

575
00:20:24,480 --> 00:20:26,559
get malicious security which was uh sort

576
00:20:26,559 --> 00:20:29,360
of used by the lindo riva work and that

577
00:20:29,360 --> 00:20:31,679
uh in the worst case we still leak only

578
00:20:31,679 --> 00:20:33,919
a single bit of information that

579
00:20:33,919 --> 00:20:35,840
and secondly

580
00:20:35,840 --> 00:20:38,159
when we do fail

581
00:20:38,159 --> 00:20:40,159
we still obtain guaranteed output

582
00:20:40,159 --> 00:20:42,080
correctness and that the honest party

583
00:20:42,080 --> 00:20:44,159
will never accept an answer that was not

584
00:20:44,159 --> 00:20:46,159
correctly generated because the psi

585
00:20:46,159 --> 00:20:49,280
protocol will fail in that case and

586
00:20:49,280 --> 00:20:51,280
this is detectable

587
00:20:51,280 --> 00:20:54,320
and uh for future works uh we're looking

588
00:20:54,320 --> 00:20:55,280
into

589
00:20:55,280 --> 00:20:57,840
combining the our work

590
00:20:57,840 --> 00:20:59,840
with the work of damn guard zachariah

591
00:20:59,840 --> 00:21:01,120
2015

592
00:21:01,120 --> 00:21:03,200
in that we could perform a fast offline

593
00:21:03,200 --> 00:21:05,600
phase and then use their protocol in the

594
00:21:05,600 --> 00:21:08,559
on online phase and gain uh sort of this

595
00:21:08,559 --> 00:21:10,720
function independent property in that we

596
00:21:10,720 --> 00:21:12,880
could compute any function uh without

597
00:21:12,880 --> 00:21:14,320
having to decide on it during the

598
00:21:14,320 --> 00:21:17,440
offline phase and furthermore we think

599
00:21:17,440 --> 00:21:19,600
some of the advances that we came up

600
00:21:19,600 --> 00:21:20,720
with in this

601
00:21:20,720 --> 00:21:22,559
setting of online offline

602
00:21:22,559 --> 00:21:24,000
can also be transferred to the single

603
00:21:24,000 --> 00:21:26,159
execution setting

604
00:21:26,159 --> 00:21:28,480
in that

605
00:21:28,480 --> 00:21:30,480
one possible approach would be to break

606
00:21:30,480 --> 00:21:32,640
the circuit up into smaller chunks uh

607
00:21:32,640 --> 00:21:33,760
which is a

608
00:21:33,760 --> 00:21:36,640
line of active research

609
00:21:36,640 --> 00:21:38,880
uh this concludes my talking faster

610
00:21:38,880 --> 00:21:40,720
malicious two-party secure computation

611
00:21:40,720 --> 00:21:43,520
with online offline dual execution

612
00:21:43,520 --> 00:21:44,400
all the source code for the

613
00:21:44,400 --> 00:21:46,640
implementation can be found on github at

614
00:21:46,640 --> 00:21:49,490
that address thank you

615
00:21:49,490 --> 00:21:57,280
[Applause]

616
00:21:57,280 --> 00:21:59,760
time for some questions

617
00:21:59,760 --> 00:22:01,919
uh hi oleo framienko from microsoft

618
00:22:01,919 --> 00:22:04,799
research um so yeah you can um great

619
00:22:04,799 --> 00:22:06,640
talk and uh so on your comparison slide

620
00:22:06,640 --> 00:22:08,799
you mainly use the other multi-party

621
00:22:08,799 --> 00:22:10,320
computation

622
00:22:10,320 --> 00:22:12,480
methods so i was just wondering uh what

623
00:22:12,480 --> 00:22:15,360
would be the baseline like if you had no

624
00:22:15,360 --> 00:22:17,600
like no circuits or anything you just

625
00:22:17,600 --> 00:22:21,600
ran a s and chat to 56 how would oh as

626
00:22:21,600 --> 00:22:23,919
well as is implementing like hardware so

627
00:22:23,919 --> 00:22:25,520
it's like

628
00:22:25,520 --> 00:22:27,600
zero time almost

629
00:22:27,600 --> 00:22:28,480
uh

630
00:22:28,480 --> 00:22:29,840
yeah um

631
00:22:29,840 --> 00:22:31,919
you can do thousands and thousands of

632
00:22:31,919 --> 00:22:33,679
blocks or a thousand blocks in a few

633
00:22:33,679 --> 00:22:36,240
milliseconds

634
00:22:36,240 --> 00:22:38,720
yes yeah it's about yeah seven cycles or

635
00:22:38,720 --> 00:22:41,520
so per block hi i'm lee from indiana

636
00:22:41,520 --> 00:22:43,600
university my question is when you

637
00:22:43,600 --> 00:22:45,760
combine everything with current truths

638
00:22:45,760 --> 00:22:47,840
you have two different challenges is

639
00:22:47,840 --> 00:22:51,440
check or evaluation right so what is the

640
00:22:51,440 --> 00:22:54,320
cost ratio between check and evaluation

641
00:22:54,320 --> 00:22:57,440
in your work um in our work well there's

642
00:22:57,440 --> 00:22:59,120
some tricks that you can do which will

643
00:22:59,120 --> 00:23:01,919
be a talk i guess on friday but uh we

644
00:23:01,919 --> 00:23:06,240
just they're roughly equivalent i guess

645
00:23:06,640 --> 00:23:07,840
check circuits are kind of more

646
00:23:07,840 --> 00:23:09,840
expensive because they affect our online

647
00:23:09,840 --> 00:23:11,440
i mean evaluation circuits are kind of

648
00:23:11,440 --> 00:23:12,640
more expensive because we're concerned

649
00:23:12,640 --> 00:23:14,400
with the online setting and they can't

650
00:23:14,400 --> 00:23:16,240
be amortized away in the same sense that

651
00:23:16,240 --> 00:23:18,240
they can in offline so

652
00:23:18,240 --> 00:23:20,159
in some senses check circuits are

653
00:23:20,159 --> 00:23:22,880
cheaper but an actual like amount of

654
00:23:22,880 --> 00:23:24,240
work you have to do there

655
00:23:24,240 --> 00:23:26,000
the way we do it is the same okay thank

656
00:23:26,000 --> 00:23:28,080
you

657
00:23:28,080 --> 00:23:29,919
so i have one question so this very

658
00:23:29,919 --> 00:23:31,440
impressive work um

659
00:23:31,440 --> 00:23:32,240
so

660
00:23:32,240 --> 00:23:33,919
this works for certain class of

661
00:23:33,919 --> 00:23:35,200
functions

662
00:23:35,200 --> 00:23:36,799
so can you

663
00:23:36,799 --> 00:23:38,720
maybe speculate a little more on sort of

664
00:23:38,720 --> 00:23:40,799
how

665
00:23:40,799 --> 00:23:42,559
can this be what kinds of functions can

666
00:23:42,559 --> 00:23:44,240
this approach work for

667
00:23:44,240 --> 00:23:46,240
and what is it limited to

668
00:23:46,240 --> 00:23:48,640
yeah so the biggest limitation which i

669
00:23:48,640 --> 00:23:50,400
guess i kind of skipped over is that

670
00:23:50,400 --> 00:23:52,159
during the offline these circuits can

671
00:23:52,159 --> 00:23:54,559
get big and so during the offline you

672
00:23:54,559 --> 00:23:56,159
have to store this circuit and you have

673
00:23:56,159 --> 00:23:58,000
to store it for many executions if you

674
00:23:58,000 --> 00:24:00,240
want to get these great parameters

675
00:24:00,240 --> 00:24:01,840
um and so

676
00:24:01,840 --> 00:24:04,640
yeah you definitely run into sort of the

677
00:24:04,640 --> 00:24:06,880
how much can you store for later use is

678
00:24:06,880 --> 00:24:09,200
probably our main bottleneck and so the

679
00:24:09,200 --> 00:24:11,600
aes circuit is relatively

680
00:24:11,600 --> 00:24:13,520
not too bad to store

681
00:24:13,520 --> 00:24:14,880
but if you want to do this for like

682
00:24:14,880 --> 00:24:16,400
larger like

683
00:24:16,400 --> 00:24:18,400
big functions on large data sets it

684
00:24:18,400 --> 00:24:20,400
probably wouldn't scale too well but i

685
00:24:20,400 --> 00:24:22,720
also think uh that's a great opportunity

686
00:24:22,720 --> 00:24:23,760
for where

687
00:24:23,760 --> 00:24:25,679
you could apply reapply these

688
00:24:25,679 --> 00:24:28,320
techniques to a single execution where

689
00:24:28,320 --> 00:24:31,120
you can uh sort of get away with more

690
00:24:31,120 --> 00:24:33,840
if you decompose the circuit

691
00:24:33,840 --> 00:24:35,360
thank you so let's thank our speaker

692
00:24:35,360 --> 00:24:36,610
again

693
00:24:36,610 --> 00:24:38,310
[Music]

694
00:24:38,310 --> 00:24:39,000
[Applause]

695
00:24:39,000 --> 00:24:42,190
[Music]

