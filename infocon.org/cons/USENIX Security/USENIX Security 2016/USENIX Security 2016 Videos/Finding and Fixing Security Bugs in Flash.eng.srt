1
00:00:10,880 --> 00:00:12,960
and thanks everyone for coming to this

2
00:00:12,960 --> 00:00:15,360
very or well slightly early morning

3
00:00:15,360 --> 00:00:17,119
presentation

4
00:00:17,119 --> 00:00:19,039
today i'm going to talk about finding

5
00:00:19,039 --> 00:00:22,160
and fixing security bugs in adobe flash

6
00:00:22,160 --> 00:00:23,680
i've been working to improve the

7
00:00:23,680 --> 00:00:26,400
security of flash for over a year now so

8
00:00:26,400 --> 00:00:28,480
i wanted to share with everyone how that

9
00:00:28,480 --> 00:00:31,359
year went what sort of bugs i found what

10
00:00:31,359 --> 00:00:33,600
sort of exploits turned up in the wild

11
00:00:33,600 --> 00:00:35,040
and what sort of mitigations were

12
00:00:35,040 --> 00:00:37,280
implemented to prevent them

13
00:00:37,280 --> 00:00:40,000
but before i begin who am i i'm natalie

14
00:00:40,000 --> 00:00:42,320
slovanovic and i'm a security researcher

15
00:00:42,320 --> 00:00:45,039
on google's project zero project zero is

16
00:00:45,039 --> 00:00:46,800
a team at google that works to reduce

17
00:00:46,800 --> 00:00:49,440
the impact of zero days in the wild and

18
00:00:49,440 --> 00:00:51,600
i specifically work on flash

19
00:00:51,600 --> 00:00:53,520
trying to reduce the impact of zero day

20
00:00:53,520 --> 00:00:55,440
vulnerabilities there

21
00:00:55,440 --> 00:00:57,440
before i worked on project zero i worked

22
00:00:57,440 --> 00:01:00,239
in mobile security for about five years

23
00:01:00,239 --> 00:01:01,760
and something that a lot of people don't

24
00:01:01,760 --> 00:01:04,400
realize is that up to about five years

25
00:01:04,400 --> 00:01:06,960
ago back in the dark ages it was really

26
00:01:06,960 --> 00:01:08,640
common for virtual machines to be the

27
00:01:08,640 --> 00:01:10,880
rate of trust on a mobile device

28
00:01:10,880 --> 00:01:13,119
the most common one was the java virtual

29
00:01:13,119 --> 00:01:15,280
machine but a lot of other virtual

30
00:01:15,280 --> 00:01:17,600
machines were used too in fact there was

31
00:01:17,600 --> 00:01:19,680
even a blackberry device the blackberry

32
00:01:19,680 --> 00:01:22,000
playbook tablet where the main vm was

33
00:01:22,000 --> 00:01:23,759
adobe flash

34
00:01:23,759 --> 00:01:26,080
so that's how i really got into flash

35
00:01:26,080 --> 00:01:28,560
now i would describe myself as a flash

36
00:01:28,560 --> 00:01:31,280
enthusiast i love finding bugs in flash

37
00:01:31,280 --> 00:01:32,960
i love making the sad puzzle piece

38
00:01:32,960 --> 00:01:35,600
appear and currently i report about one

39
00:01:35,600 --> 00:01:38,479
third of flash vulnerabilities

40
00:01:38,479 --> 00:01:39,759
so what's the problem i'm trying to

41
00:01:39,759 --> 00:01:40,880
solve

42
00:01:40,880 --> 00:01:42,640
well bugs

43
00:01:42,640 --> 00:01:44,960
lots and lots of bugs

44
00:01:44,960 --> 00:01:48,000
i have the classic headline slide here

45
00:01:48,000 --> 00:01:49,439
with every problem the flash

46
00:01:49,439 --> 00:01:51,920
vulnerabilities have caused you have

47
00:01:51,920 --> 00:01:54,159
high level state attackers you have

48
00:01:54,159 --> 00:01:56,560
financially motivated attackers

49
00:01:56,560 --> 00:01:58,640
you have malware served through ads you

50
00:01:58,640 --> 00:02:01,520
have ransomware basically any attack you

51
00:02:01,520 --> 00:02:04,240
can think of that involves compromising

52
00:02:04,240 --> 00:02:06,960
a user's host a flash vulnerability has

53
00:02:06,960 --> 00:02:09,360
been used for it at some point so i was

54
00:02:09,360 --> 00:02:11,599
hoping to try to make an impact on this

55
00:02:11,599 --> 00:02:13,680
problem and reduce the number of

56
00:02:13,680 --> 00:02:15,360
vulnerabilities that were found in the

57
00:02:15,360 --> 00:02:16,400
wild

58
00:02:16,400 --> 00:02:18,239
here's another

59
00:02:18,239 --> 00:02:20,319
sample of what the landscape looks like

60
00:02:20,319 --> 00:02:22,640
this is a timeline of the year and i've

61
00:02:22,640 --> 00:02:24,480
got kind of the good guys at the top and

62
00:02:24,480 --> 00:02:26,239
the bad guys at the bottom

63
00:02:26,239 --> 00:02:28,560
so you can see there are many flash

64
00:02:28,560 --> 00:02:30,480
updates and a few mitigations

65
00:02:30,480 --> 00:02:32,800
implemented and then you can see the

66
00:02:32,800 --> 00:02:35,120
timeline of zero days on the bottom and

67
00:02:35,120 --> 00:02:36,319
depending on how you count there were at

68
00:02:36,319 --> 00:02:38,160
least seven last year

69
00:02:38,160 --> 00:02:40,400
so it seems every few months a zero day

70
00:02:40,400 --> 00:02:42,160
turns up in the wild and that's just

71
00:02:42,160 --> 00:02:44,480
what we know about

72
00:02:44,480 --> 00:02:46,640
so what's kind of the technical problem

73
00:02:46,640 --> 00:02:48,800
here sometimes i think people are a

74
00:02:48,800 --> 00:02:51,440
little too quick to bash flash for

75
00:02:51,440 --> 00:02:53,680
having bugs in it because really what

76
00:02:53,680 --> 00:02:56,319
has led to this is just how widespread

77
00:02:56,319 --> 00:02:57,680
flashes

78
00:02:57,680 --> 00:02:59,599
if you attack a browser well the user

79
00:02:59,599 --> 00:03:01,840
might have different browsers and that's

80
00:03:01,840 --> 00:03:03,920
the same with lots of software not

81
00:03:03,920 --> 00:03:05,760
everyone has it installed but almost

82
00:03:05,760 --> 00:03:08,080
everyone has flash installed so it makes

83
00:03:08,080 --> 00:03:10,720
a temp an attempting target regardless

84
00:03:10,720 --> 00:03:12,400
of whether an attacker is trying to

85
00:03:12,400 --> 00:03:14,159
attack one person

86
00:03:14,159 --> 00:03:15,519
and you know doesn't know a lot about

87
00:03:15,519 --> 00:03:17,440
them and hopes they have this installed

88
00:03:17,440 --> 00:03:19,280
or if they're trying to do a widespread

89
00:03:19,280 --> 00:03:21,360
attack and compromise a lot of people

90
00:03:21,360 --> 00:03:23,360
flash can be very valuable because

91
00:03:23,360 --> 00:03:25,440
almost everyone uses it

92
00:03:25,440 --> 00:03:26,239
and

93
00:03:26,239 --> 00:03:27,920
there are a few other aspects of flash

94
00:03:27,920 --> 00:03:29,760
that make it a good target there are

95
00:03:29,760 --> 00:03:31,360
indeed a lot of vulnerabilities being

96
00:03:31,360 --> 00:03:34,080
found in it and also attackers can

97
00:03:34,080 --> 00:03:36,720
easily exploit vulnerabilities and i

98
00:03:36,720 --> 00:03:37,920
have easily

99
00:03:37,920 --> 00:03:39,840
asked risk that's comparative to other

100
00:03:39,840 --> 00:03:41,840
software and this has improved a lot

101
00:03:41,840 --> 00:03:44,879
over the last year but up to about last

102
00:03:44,879 --> 00:03:46,720
august there was a limited number of

103
00:03:46,720 --> 00:03:48,879
mitigations in flash and it was fairly

104
00:03:48,879 --> 00:03:50,959
easy to exploit

105
00:03:50,959 --> 00:03:53,040
so what are we going to talk about today

106
00:03:53,040 --> 00:03:55,280
i'll start to start by going over what

107
00:03:55,280 --> 00:03:57,519
flash is in the attack surface

108
00:03:57,519 --> 00:03:58,480
and

109
00:03:58,480 --> 00:04:00,480
then talk about reducing vulnerabilities

110
00:04:00,480 --> 00:04:02,799
in flash then i'll talk about exploit

111
00:04:02,799 --> 00:04:04,959
mitigations that got implemented and

112
00:04:04,959 --> 00:04:06,720
then i'll go through a bit the future of

113
00:04:06,720 --> 00:04:08,879
flash where i think flash bugs and

114
00:04:08,879 --> 00:04:11,439
exploitation are going

115
00:04:11,439 --> 00:04:13,200
so to start off i'm going to do a quick

116
00:04:13,200 --> 00:04:14,879
overview of what flash is and what the

117
00:04:14,879 --> 00:04:17,279
problem is i'm trying to solve here

118
00:04:17,279 --> 00:04:20,639
so flash is a browser plugin and the way

119
00:04:20,639 --> 00:04:22,320
it starts is there's a developer that

120
00:04:22,320 --> 00:04:24,800
writes code in action script that's the

121
00:04:24,800 --> 00:04:26,320
language the script language that is

122
00:04:26,320 --> 00:04:28,639
supported by flash and

123
00:04:28,639 --> 00:04:30,560
they use a flash compiler and many of

124
00:04:30,560 --> 00:04:31,919
them are available and they create a

125
00:04:31,919 --> 00:04:34,240
swift file and then the swift file is

126
00:04:34,240 --> 00:04:36,080
hosted on a website

127
00:04:36,080 --> 00:04:37,680
and then the user visits the website

128
00:04:37,680 --> 00:04:39,520
their browser downloads it and then the

129
00:04:39,520 --> 00:04:41,120
flash plug-in

130
00:04:41,120 --> 00:04:43,120
will parse the swift file and display

131
00:04:43,120 --> 00:04:45,600
content to the user like videos and

132
00:04:45,600 --> 00:04:46,880
audio

133
00:04:46,880 --> 00:04:48,960
and then the user has a wonderful web

134
00:04:48,960 --> 00:04:52,320
experience rainbows appear as they enjoy

135
00:04:52,320 --> 00:04:56,000
their game or their music or whatever

136
00:04:56,000 --> 00:04:58,160
now the problem i'm trying to solve is

137
00:04:58,160 --> 00:05:00,000
that there is a malicious developer who

138
00:05:00,000 --> 00:05:02,320
writes unlicious swift usually an action

139
00:05:02,320 --> 00:05:04,000
script though sometimes they'll write a

140
00:05:04,000 --> 00:05:05,360
swift directly

141
00:05:05,360 --> 00:05:07,520
and then they put it on a website and it

142
00:05:07,520 --> 00:05:09,600
could be a malicious website they own or

143
00:05:09,600 --> 00:05:11,039
they could have somehow compromised

144
00:05:11,039 --> 00:05:13,600
someone else's website but regardless

145
00:05:13,600 --> 00:05:16,000
they convinced the user to browse there

146
00:05:16,000 --> 00:05:16,800
and

147
00:05:16,800 --> 00:05:18,639
then the browser downloads the swift and

148
00:05:18,639 --> 00:05:20,880
then the flash plug-in parses the swift

149
00:05:20,880 --> 00:05:23,199
in such a way that it leads to arbitrary

150
00:05:23,199 --> 00:05:25,120
code being executed even though the

151
00:05:25,120 --> 00:05:27,680
flash player doesn't normally allow this

152
00:05:27,680 --> 00:05:29,440
and then the user is very sad because

153
00:05:29,440 --> 00:05:31,039
they've been compromised

154
00:05:31,039 --> 00:05:32,800
and the reason i'm showing these slides

155
00:05:32,800 --> 00:05:34,160
is just i want to be very clear on the

156
00:05:34,160 --> 00:05:36,000
problem i'm solving here there

157
00:05:36,000 --> 00:05:38,000
definitely are some other problems with

158
00:05:38,000 --> 00:05:40,160
flash for example sometimes the flash

159
00:05:40,160 --> 00:05:42,400
developer writes a vulnerability

160
00:05:42,400 --> 00:05:44,479
in the swift file and

161
00:05:44,479 --> 00:05:45,840
that is a problem but not the one i'm

162
00:05:45,840 --> 00:05:48,320
trying to solve also there have been

163
00:05:48,320 --> 00:05:50,479
cross domain or browser policy issues

164
00:05:50,479 --> 00:05:53,360
with flash where the swift file tries to

165
00:05:53,360 --> 00:05:55,039
access other other parts of the web that

166
00:05:55,039 --> 00:05:56,960
it shouldn't be allowed to access

167
00:05:56,960 --> 00:05:58,400
and that's a different problem but it's

168
00:05:58,400 --> 00:06:00,479
not an especially common one the vast

169
00:06:00,479 --> 00:06:02,639
vast majority of flash attacks follow

170
00:06:02,639 --> 00:06:04,400
this pattern where someone finds a

171
00:06:04,400 --> 00:06:06,880
memory corruption vulnerability in flash

172
00:06:06,880 --> 00:06:09,759
and uses it to execute code

173
00:06:09,759 --> 00:06:10,639
so

174
00:06:10,639 --> 00:06:12,639
i talked about actionscript being

175
00:06:12,639 --> 00:06:15,600
compiled into a swiff what actually is a

176
00:06:15,600 --> 00:06:18,319
swiff it has a few components as i said

177
00:06:18,319 --> 00:06:20,080
the most important component is the

178
00:06:20,080 --> 00:06:22,160
script that the developer writes and

179
00:06:22,160 --> 00:06:23,680
there's two types of script that's

180
00:06:23,680 --> 00:06:24,800
supported

181
00:06:24,800 --> 00:06:27,120
there is actionscript 2 which was the

182
00:06:27,120 --> 00:06:28,639
original actionscript language and it

183
00:06:28,639 --> 00:06:30,479
was eventually deprecated in favor of

184
00:06:30,479 --> 00:06:33,360
actionscript3 but since flash has to

185
00:06:33,360 --> 00:06:34,720
support all swifts that have been

186
00:06:34,720 --> 00:06:37,039
created on the web ever

187
00:06:37,039 --> 00:06:38,639
it still supports action script two but

188
00:06:38,639 --> 00:06:40,319
these are completely separate you either

189
00:06:40,319 --> 00:06:42,080
write an action script too swiff and

190
00:06:42,080 --> 00:06:43,280
then you have to always use action

191
00:06:43,280 --> 00:06:44,960
script two or you write an action script

192
00:06:44,960 --> 00:06:46,880
three swift you can't combine the two

193
00:06:46,880 --> 00:06:48,960
languages and other things that might be

194
00:06:48,960 --> 00:06:52,400
in a swift include metadata so things

195
00:06:52,400 --> 00:06:55,520
that say where the script is images

196
00:06:55,520 --> 00:06:58,000
music fonts and they also contain

197
00:06:58,000 --> 00:07:00,400
something that called frames

198
00:07:00,400 --> 00:07:02,960
and this is where um in the development

199
00:07:02,960 --> 00:07:05,440
environment you can actually draw stuff

200
00:07:05,440 --> 00:07:07,199
and create an animation and go from

201
00:07:07,199 --> 00:07:08,720
frame to frame

202
00:07:08,720 --> 00:07:10,800
and a lot of swifts i use this feature a

203
00:07:10,800 --> 00:07:12,639
lot and only have a minimum of script it

204
00:07:12,639 --> 00:07:14,240
depends on what tool you use to develop

205
00:07:14,240 --> 00:07:16,000
it but that's another feature that

206
00:07:16,000 --> 00:07:18,240
support supported the ability to make

207
00:07:18,240 --> 00:07:20,479
dynamic frames and go from one frame to

208
00:07:20,479 --> 00:07:22,319
another

209
00:07:22,319 --> 00:07:24,319
so from a virtual machine perspective

210
00:07:24,319 --> 00:07:26,639
from the flash plug-in perspective

211
00:07:26,639 --> 00:07:29,120
it consists of three main components the

212
00:07:29,120 --> 00:07:31,599
first one is the actionscript 2 vm as i

213
00:07:31,599 --> 00:07:34,000
mentioned and this is the old

214
00:07:34,000 --> 00:07:37,360
interpreted vm it is just a huge while

215
00:07:37,360 --> 00:07:40,000
loop and um if it needs to call into a

216
00:07:40,000 --> 00:07:42,000
native api while it just branches out of

217
00:07:42,000 --> 00:07:44,080
the while loop and branches back it has

218
00:07:44,080 --> 00:07:45,840
a reduced api set because it only

219
00:07:45,840 --> 00:07:48,000
supports the apis up until when it was

220
00:07:48,000 --> 00:07:49,280
deprecated

221
00:07:49,280 --> 00:07:51,280
and i would say it generally has more

222
00:07:51,280 --> 00:07:54,000
bugs but with lower exploitability

223
00:07:54,000 --> 00:07:56,080
the thing with actionscript 2 is it was

224
00:07:56,080 --> 00:07:58,000
written before what i'd call the modern

225
00:07:58,000 --> 00:08:00,800
security environment so they made a lot

226
00:08:00,800 --> 00:08:02,160
of decisions that would not have been

227
00:08:02,160 --> 00:08:05,039
made today for example if you

228
00:08:05,039 --> 00:08:07,520
write a native api for action script 2

229
00:08:07,520 --> 00:08:09,440
you have to manually type check the type

230
00:08:09,440 --> 00:08:11,840
of every single parameter that's put in

231
00:08:11,840 --> 00:08:13,520
and that was because i guess they

232
00:08:13,520 --> 00:08:15,199
weren't expecting malicious people to

233
00:08:15,199 --> 00:08:17,599
try and put in bad parameters and this

234
00:08:17,599 --> 00:08:19,599
sort of thing is hard to fix once it's

235
00:08:19,599 --> 00:08:21,759
been implemented so there's often a lot

236
00:08:21,759 --> 00:08:24,080
of bugs in actionscript too but the flip

237
00:08:24,080 --> 00:08:26,000
side is they tend not to be as

238
00:08:26,000 --> 00:08:28,000
exploitable because the thing about

239
00:08:28,000 --> 00:08:30,639
actionscript 2 is there's not as much

240
00:08:30,639 --> 00:08:32,320
stuff in there because it doesn't have

241
00:08:32,320 --> 00:08:34,719
as many features so let's say you have

242
00:08:34,719 --> 00:08:36,479
an overflow vulnerability and you're

243
00:08:36,479 --> 00:08:38,240
trying to find that perfect object

244
00:08:38,240 --> 00:08:40,399
overflow to exploit it um it's less

245
00:08:40,399 --> 00:08:42,799
likely to exist in actionscript too

246
00:08:42,799 --> 00:08:45,200
and some um people who write exploits

247
00:08:45,200 --> 00:08:46,959
try to get around this by having an

248
00:08:46,959 --> 00:08:48,560
action script three swift and then

249
00:08:48,560 --> 00:08:50,720
loading an action script to swift and

250
00:08:50,720 --> 00:08:52,399
this sometimes works but it doesn't

251
00:08:52,399 --> 00:08:54,800
always work there are sometimes bugs

252
00:08:54,800 --> 00:08:58,160
that have a very narrow window

253
00:08:58,160 --> 00:08:59,839
for example there's a pointer and then

254
00:08:59,839 --> 00:09:01,360
it gets free then it gets used and then

255
00:09:01,360 --> 00:09:02,959
it goes out of scope and in that case

256
00:09:02,959 --> 00:09:04,560
it's not possible

257
00:09:04,560 --> 00:09:06,880
so in action script two it can generally

258
00:09:06,880 --> 00:09:09,920
be more difficult to exploit a bug

259
00:09:09,920 --> 00:09:12,080
action script three is the answer to

260
00:09:12,080 --> 00:09:15,360
action script two it is flash's modern

261
00:09:15,360 --> 00:09:18,000
vm it has just in time compilation and

262
00:09:18,000 --> 00:09:20,480
an interpreter and something cool about

263
00:09:20,480 --> 00:09:22,399
it is it's open source

264
00:09:22,399 --> 00:09:24,959
so if you go on the tamarind project on

265
00:09:24,959 --> 00:09:26,560
mozilla you can actually see the

266
00:09:26,560 --> 00:09:28,720
actionscript 3vm

267
00:09:28,720 --> 00:09:31,200
and it's extendable so the way you write

268
00:09:31,200 --> 00:09:33,760
native code in

269
00:09:33,760 --> 00:09:36,399
actual in actionscript three is you

270
00:09:36,399 --> 00:09:38,160
declare an action script api and there's

271
00:09:38,160 --> 00:09:40,399
very clear boundaries and it's quite

272
00:09:40,399 --> 00:09:42,240
easy to extend it

273
00:09:42,240 --> 00:09:44,000
um it also has two heaps there's a

274
00:09:44,000 --> 00:09:46,320
garbage collected heap that i describe

275
00:09:46,320 --> 00:09:49,120
as conservative non-strict non-exact it

276
00:09:49,120 --> 00:09:50,640
takes a while for things to get freed

277
00:09:50,640 --> 00:09:51,920
and you generally don't have the problem

278
00:09:51,920 --> 00:09:54,320
with stuff getting spuriously freed but

279
00:09:54,320 --> 00:09:56,080
it does happen eventually

280
00:09:56,080 --> 00:09:59,200
and then there is a fixed heap which

281
00:09:59,200 --> 00:10:00,959
is used for really long-lived objects

282
00:10:00,959 --> 00:10:02,880
for example frames and bitmaps and that

283
00:10:02,880 --> 00:10:05,440
sort of thing and this is all optimized

284
00:10:05,440 --> 00:10:07,760
by flash for flash but as i said you can

285
00:10:07,760 --> 00:10:09,680
use it for anything you can also find

286
00:10:09,680 --> 00:10:13,920
the heap on mozilla the project is mmgc

287
00:10:13,920 --> 00:10:14,959
and

288
00:10:14,959 --> 00:10:16,800
with regards to actual actionscript 3

289
00:10:16,800 --> 00:10:20,240
apis things like arrays vectors strings

290
00:10:20,240 --> 00:10:22,399
and that sort of thing the really common

291
00:10:22,399 --> 00:10:24,720
ones you can find in the open source

292
00:10:24,720 --> 00:10:27,200
project but the proprietary ones things

293
00:10:27,200 --> 00:10:29,920
like i don't know image filtering

294
00:10:29,920 --> 00:10:31,839
are proprietary to adobe and you can't

295
00:10:31,839 --> 00:10:33,200
get the source

296
00:10:33,200 --> 00:10:35,200
and i'd say in general uh bugs in action

297
00:10:35,200 --> 00:10:36,959
script 3 are less dense but more

298
00:10:36,959 --> 00:10:39,279
exploitable it's fairly hard to find a

299
00:10:39,279 --> 00:10:41,279
bug in action script 3 these days

300
00:10:41,279 --> 00:10:42,959
because it has a lot of features that

301
00:10:42,959 --> 00:10:44,959
prevent bugs but if you do find one it

302
00:10:44,959 --> 00:10:46,560
tends to be very exploitable because you

303
00:10:46,560 --> 00:10:48,320
just have so many flash features to use

304
00:10:48,320 --> 00:10:50,720
in your exploit

305
00:10:50,720 --> 00:10:53,040
and the final portion of flash is what

306
00:10:53,040 --> 00:10:56,000
we like to call the anti-corpus and this

307
00:10:56,000 --> 00:10:58,160
is the functionality outside of script

308
00:10:58,160 --> 00:11:00,480
things like the mp4 parsers ad lib regex

309
00:11:00,480 --> 00:11:04,079
image decoders all that stuff

310
00:11:04,079 --> 00:11:05,519
so when i talk about flash

311
00:11:05,519 --> 00:11:07,200
vulnerabilities what sort of

312
00:11:07,200 --> 00:11:10,320
vulnerabilities tend to happen in flash

313
00:11:10,320 --> 00:11:12,720
the most common one as i said is bugs

314
00:11:12,720 --> 00:11:15,360
that allow loading a swift to execute

315
00:11:15,360 --> 00:11:18,079
code and typically these are memory

316
00:11:18,079 --> 00:11:20,959
corruption bugs though there have been

317
00:11:20,959 --> 00:11:22,000
others

318
00:11:22,000 --> 00:11:24,000
just to give a brief overview these are

319
00:11:24,000 --> 00:11:25,680
the types of vulnerabilities i'll show

320
00:11:25,680 --> 00:11:27,120
you today

321
00:11:27,120 --> 00:11:29,200
there is the general overflow class

322
00:11:29,200 --> 00:11:31,120
which is you have a small buffer and you

323
00:11:31,120 --> 00:11:32,880
copy a large buffer into it and then you

324
00:11:32,880 --> 00:11:35,760
can overflow onto the heap or the stack

325
00:11:35,760 --> 00:11:38,399
there are use after freeze where you

326
00:11:38,399 --> 00:11:40,000
have a buffer and then you delete it and

327
00:11:40,000 --> 00:11:41,760
then you do something with it and

328
00:11:41,760 --> 00:11:43,279
especially in flash it can be fairly

329
00:11:43,279 --> 00:11:45,519
easy to move that into a state where the

330
00:11:45,519 --> 00:11:48,320
buffer is reallocated and you have two

331
00:11:48,320 --> 00:11:50,560
different places in the code contending

332
00:11:50,560 --> 00:11:52,880
over that buffer and that can lead to

333
00:11:52,880 --> 00:11:56,079
code execution and another type of bug

334
00:11:56,079 --> 00:11:58,079
that's really common in flash and i'd

335
00:11:58,079 --> 00:12:01,120
say common in script engines in general

336
00:12:01,120 --> 00:12:03,760
is type confusion and that is where you

337
00:12:03,760 --> 00:12:05,360
create one type of object and then you

338
00:12:05,360 --> 00:12:07,040
cast it to another type and you start

339
00:12:07,040 --> 00:12:08,399
calling stuff

340
00:12:08,399 --> 00:12:10,800
and since you have basically the wrong v

341
00:12:10,800 --> 00:12:12,720
table in there it leads to all sorts of

342
00:12:12,720 --> 00:12:15,279
weird function calls that can often lead

343
00:12:15,279 --> 00:12:17,600
to code execution

344
00:12:17,600 --> 00:12:19,200
so what's my goal here

345
00:12:19,200 --> 00:12:21,839
i want to find all of the flashbacks i

346
00:12:21,839 --> 00:12:24,000
want to find every last one and then

347
00:12:24,000 --> 00:12:26,720
sometime around 2022 i will have found

348
00:12:26,720 --> 00:12:29,519
the last flashbug and that's it flash

349
00:12:29,519 --> 00:12:32,160
will be secure

350
00:12:32,880 --> 00:12:34,320
now obviously this isn't a very

351
00:12:34,320 --> 00:12:35,839
realistic goal

352
00:12:35,839 --> 00:12:38,240
what i really want to do is make flash

353
00:12:38,240 --> 00:12:39,360
better

354
00:12:39,360 --> 00:12:41,519
my current priority right now is finding

355
00:12:41,519 --> 00:12:42,639
bugs

356
00:12:42,639 --> 00:12:44,639
while i might not find all of the bugs i

357
00:12:44,639 --> 00:12:46,160
want to find enough bugs that it

358
00:12:46,160 --> 00:12:48,079
decreases the bug density and makes it

359
00:12:48,079 --> 00:12:49,920
more difficult for other people to find

360
00:12:49,920 --> 00:12:50,880
bugs

361
00:12:50,880 --> 00:12:53,519
i mostly do this through code review

362
00:12:53,519 --> 00:12:55,440
though i do do some fuzzing with my

363
00:12:55,440 --> 00:12:57,920
colleague matthias hurick

364
00:12:57,920 --> 00:13:00,160
when i started i was finding one bug per

365
00:13:00,160 --> 00:13:02,560
day and now i'm down to about one bug

366
00:13:02,560 --> 00:13:03,680
per week

367
00:13:03,680 --> 00:13:05,680
and something i wanted to mention is

368
00:13:05,680 --> 00:13:07,920
that bugs in flash once they're fixed

369
00:13:07,920 --> 00:13:10,160
they stay gone something people ask me

370
00:13:10,160 --> 00:13:11,839
fairly often is do you think you're

371
00:13:11,839 --> 00:13:13,519
finding bugs faster than they're being

372
00:13:13,519 --> 00:13:16,399
added and the answer here is definitely

373
00:13:16,399 --> 00:13:18,560
yes because development on flash has

374
00:13:18,560 --> 00:13:20,480
stopped so they're not making any new

375
00:13:20,480 --> 00:13:21,440
bugs

376
00:13:21,440 --> 00:13:23,680
so this is really a unique opportunity

377
00:13:23,680 --> 00:13:25,839
to reduce the bug density by finding

378
00:13:25,839 --> 00:13:27,600
bugs because we know they're not putting

379
00:13:27,600 --> 00:13:29,680
any more in

380
00:13:29,680 --> 00:13:31,920
something else i do is i spend a lot of

381
00:13:31,920 --> 00:13:33,839
time analyzing external bugs and

382
00:13:33,839 --> 00:13:36,320
exploits i don't just want to know about

383
00:13:36,320 --> 00:13:39,360
my bugs i want to know about every bug

384
00:13:39,360 --> 00:13:42,240
in flash so that i can understand how

385
00:13:42,240 --> 00:13:44,079
they happened and how they were

386
00:13:44,079 --> 00:13:46,560
exploited and then both find variants of

387
00:13:46,560 --> 00:13:48,160
those bugs and also think about

388
00:13:48,160 --> 00:13:49,760
mitigations that might prevent the

389
00:13:49,760 --> 00:13:51,760
exploit

390
00:13:51,760 --> 00:13:54,079
i also occasionally exploit bugs answer

391
00:13:54,079 --> 00:13:55,440
questions

392
00:13:55,440 --> 00:13:57,839
for example is exploitation possible is

393
00:13:57,839 --> 00:14:00,480
it reliable and how do certain factors

394
00:14:00,480 --> 00:14:03,279
impact exploitability

395
00:14:03,279 --> 00:14:05,440
and also my team mostly my colleagues

396
00:14:05,440 --> 00:14:07,760
james forshaw and mark brand works on

397
00:14:07,760 --> 00:14:09,680
mitigations

398
00:14:09,680 --> 00:14:11,760
we worked with adobe to try and put in

399
00:14:11,760 --> 00:14:14,639
mitigations that make the most common

400
00:14:14,639 --> 00:14:17,760
types of exploits less likely to happen

401
00:14:17,760 --> 00:14:19,279
so i'm going to start off by talking

402
00:14:19,279 --> 00:14:21,440
about how to find a flash bug and the

403
00:14:21,440 --> 00:14:24,160
different ways that people find them

404
00:14:24,160 --> 00:14:26,240
there's three main options here there's

405
00:14:26,240 --> 00:14:29,279
code review ida and fuzzing

406
00:14:29,279 --> 00:14:32,160
and one way to do this is through code

407
00:14:32,160 --> 00:14:33,279
review

408
00:14:33,279 --> 00:14:35,120
the benefits of code review is they find

409
00:14:35,120 --> 00:14:37,920
deep unusual bugs but the downside is

410
00:14:37,920 --> 00:14:40,320
that they require source though a lot of

411
00:14:40,320 --> 00:14:43,040
flash is open source and it is a bit of

412
00:14:43,040 --> 00:14:44,959
an upfront investment when you start

413
00:14:44,959 --> 00:14:46,560
looking at the code you do have to look

414
00:14:46,560 --> 00:14:47,760
at it for quite a while before you

415
00:14:47,760 --> 00:14:49,839
understand it but i think once you do

416
00:14:49,839 --> 00:14:52,560
you can pick out bugs quite quickly

417
00:14:52,560 --> 00:14:54,480
um to give you some examples of bugs

418
00:14:54,480 --> 00:14:56,720
that i found through code review to

419
00:14:56,720 --> 00:14:58,399
start off there's this issue which i

420
00:14:58,399 --> 00:15:00,800
call the convolution filter issue and

421
00:15:00,800 --> 00:15:02,720
what's interesting about this one is it

422
00:15:02,720 --> 00:15:04,639
was independently discovered at least

423
00:15:04,639 --> 00:15:07,279
three times i found it and reported it

424
00:15:07,279 --> 00:15:09,360
to adobe and then it was used to win a

425
00:15:09,360 --> 00:15:11,920
hacking competition called pwn to own

426
00:15:11,920 --> 00:15:13,839
and then it turned up in the hacking

427
00:15:13,839 --> 00:15:15,680
team dump and in case people don't

428
00:15:15,680 --> 00:15:18,320
recall hacking team was an organization

429
00:15:18,320 --> 00:15:20,959
that sold flash vulnerabilities to a

430
00:15:20,959 --> 00:15:23,600
variety of customers and they themselves

431
00:15:23,600 --> 00:15:26,399
got hacked and then all their emails and

432
00:15:26,399 --> 00:15:28,240
exploits and source code got dumped on

433
00:15:28,240 --> 00:15:29,360
the internet

434
00:15:29,360 --> 00:15:32,160
and in that dump we found evidence that

435
00:15:32,160 --> 00:15:33,759
they'd had access to this bug and had

436
00:15:33,759 --> 00:15:35,759
used it to compromise people before it

437
00:15:35,759 --> 00:15:38,079
closed up due to being reported so this

438
00:15:38,079 --> 00:15:39,839
is an example where finding and fixing a

439
00:15:39,839 --> 00:15:41,680
bug actually stopped attackers from

440
00:15:41,680 --> 00:15:43,040
using it

441
00:15:43,040 --> 00:15:44,880
and the core issue here is that

442
00:15:44,880 --> 00:15:47,120
actionscript 2 allows any method to be

443
00:15:47,120 --> 00:15:49,279
defined as any method so if you say

444
00:15:49,279 --> 00:15:51,279
function1 equals function2 and then you

445
00:15:51,279 --> 00:15:53,759
call function1 function2 will get called

446
00:15:53,759 --> 00:15:55,199
and this is what some people call monkey

447
00:15:55,199 --> 00:15:57,680
patching and what makes the situation

448
00:15:57,680 --> 00:16:00,320
even worse is that when you call a

449
00:16:00,320 --> 00:16:02,880
function an action script

450
00:16:02,880 --> 00:16:05,120
it converts the parameter you can pass

451
00:16:05,120 --> 00:16:06,880
in any parameter and then it converts it

452
00:16:06,880 --> 00:16:08,959
so let's say you need a string and you

453
00:16:08,959 --> 00:16:11,120
pass in an object it will call to string

454
00:16:11,120 --> 00:16:13,279
on that object and that can cause a

455
00:16:13,279 --> 00:16:15,040
number of problems

456
00:16:15,040 --> 00:16:16,160
so

457
00:16:16,160 --> 00:16:18,800
for this um bug what happens here is you

458
00:16:18,800 --> 00:16:20,560
create this class called a convolution

459
00:16:20,560 --> 00:16:22,880
filter there it is and then you create

460
00:16:22,880 --> 00:16:25,120
this other object it's an object and it

461
00:16:25,120 --> 00:16:27,120
has a function called value of defined

462
00:16:27,120 --> 00:16:29,680
and then you put it in an array

463
00:16:29,680 --> 00:16:31,279
and then you call this vulnerable

464
00:16:31,279 --> 00:16:32,880
function and what this vulnerable

465
00:16:32,880 --> 00:16:35,680
function does is it allocates memory and

466
00:16:35,680 --> 00:16:37,440
then tries to copy this array into the

467
00:16:37,440 --> 00:16:38,399
memory

468
00:16:38,399 --> 00:16:39,920
and it has to be an array of floats

469
00:16:39,920 --> 00:16:42,000
because that's what image filters use so

470
00:16:42,000 --> 00:16:43,680
it starts off it allocates this float

471
00:16:43,680 --> 00:16:46,079
array and then it tries to convert the

472
00:16:46,079 --> 00:16:48,160
array to floats and

473
00:16:48,160 --> 00:16:50,160
it does this but since this is actually

474
00:16:50,160 --> 00:16:52,320
an object with value of defined it calls

475
00:16:52,320 --> 00:16:54,160
value of and

476
00:16:54,160 --> 00:16:57,199
then it calls the matrix setter again

477
00:16:57,199 --> 00:16:59,199
and that's the behavior that the vm

478
00:16:59,199 --> 00:17:00,560
doesn't expect

479
00:17:00,560 --> 00:17:02,639
so this starts the whole process over it

480
00:17:02,639 --> 00:17:04,959
deletes this memory and then it

481
00:17:04,959 --> 00:17:07,839
reallocates and sets the pointer to it

482
00:17:07,839 --> 00:17:10,160
and then this is a proper matrix with an

483
00:17:10,160 --> 00:17:12,400
integer in it so it just sets that

484
00:17:12,400 --> 00:17:14,640
matrix and then this function is done

485
00:17:14,640 --> 00:17:16,400
but the previous call to the function

486
00:17:16,400 --> 00:17:18,799
still needs to complete so that then

487
00:17:18,799 --> 00:17:20,480
writes this freed memory and this is a

488
00:17:20,480 --> 00:17:23,280
use after free

489
00:17:23,280 --> 00:17:25,280
so another example of this type of

490
00:17:25,280 --> 00:17:28,000
problem is this bug and this is an

491
00:17:28,000 --> 00:17:30,880
overflow caused by the same situation

492
00:17:30,880 --> 00:17:32,720
so to start off you create an array and

493
00:17:32,720 --> 00:17:34,480
you put stuff in the array and this

494
00:17:34,480 --> 00:17:36,240
isn't especially exciting but the

495
00:17:36,240 --> 00:17:38,080
interesting part is you set the length

496
00:17:38,080 --> 00:17:40,400
of the array to this object with once

497
00:17:40,400 --> 00:17:42,799
again value of defined

498
00:17:42,799 --> 00:17:44,559
and then you call this vulnerable

499
00:17:44,559 --> 00:17:46,640
function sword on

500
00:17:46,640 --> 00:17:48,400
and then what this function does is it

501
00:17:48,400 --> 00:17:50,000
starts off by checking if the array

502
00:17:50,000 --> 00:17:52,320
length is equal to zero so it calls this

503
00:17:52,320 --> 00:17:54,400
function and then this function returns

504
00:17:54,400 --> 00:17:56,480
100 000 and that's not zero so it

505
00:17:56,480 --> 00:17:57,760
continues

506
00:17:57,760 --> 00:17:59,520
and then it

507
00:17:59,520 --> 00:18:01,360
fetches the length again and it calls

508
00:18:01,360 --> 00:18:02,960
this function again and then it returns

509
00:18:02,960 --> 00:18:05,840
100 000 and then it stores it then it

510
00:18:05,840 --> 00:18:07,919
tries to allocate memory and it fetches

511
00:18:07,919 --> 00:18:08,640
the

512
00:18:08,640 --> 00:18:11,039
length again but this time you return to

513
00:18:11,039 --> 00:18:11,919
and

514
00:18:11,919 --> 00:18:13,919
it only allocates two bytes of memory

515
00:18:13,919 --> 00:18:15,120
and i bet you can guess what's going to

516
00:18:15,120 --> 00:18:18,000
happen next here it copies it into this

517
00:18:18,000 --> 00:18:20,240
new memory with the old length and then

518
00:18:20,240 --> 00:18:23,280
that's an overflow

519
00:18:23,280 --> 00:18:25,440
so um another interesting bug that i

520
00:18:25,440 --> 00:18:27,520
found through code review is this bug in

521
00:18:27,520 --> 00:18:29,520
a serialization and there's a few

522
00:18:29,520 --> 00:18:31,120
interesting things about it

523
00:18:31,120 --> 00:18:33,280
one is that this is another time where

524
00:18:33,280 --> 00:18:35,840
the bug was used maliciously in the wild

525
00:18:35,840 --> 00:18:38,320
i reported this bug and then two weeks

526
00:18:38,320 --> 00:18:40,840
later it was found being used in the

527
00:18:40,840 --> 00:18:42,880
wild and

528
00:18:42,880 --> 00:18:45,559
it's a type confusion in action script 3

529
00:18:45,559 --> 00:18:47,760
serialization and i reported a few

530
00:18:47,760 --> 00:18:49,280
variants of it that all got fixed in

531
00:18:49,280 --> 00:18:51,520
this emergency patch and also i don't

532
00:18:51,520 --> 00:18:52,960
want to mention that this specific

533
00:18:52,960 --> 00:18:55,200
example does not compile the code i'll

534
00:18:55,200 --> 00:18:56,880
show you is conceptual but if you try

535
00:18:56,880 --> 00:18:59,200
this in your compiler it won't work so i

536
00:18:59,200 --> 00:19:01,039
had to create the swift with the correct

537
00:19:01,039 --> 00:19:03,280
bytecode by hand

538
00:19:03,280 --> 00:19:04,960
so this is from the open source

539
00:19:04,960 --> 00:19:06,720
actionscript vm this is actually the

540
00:19:06,720 --> 00:19:09,039
real code and you'll notice there's a

541
00:19:09,039 --> 00:19:11,760
check here and what this check does is

542
00:19:11,760 --> 00:19:13,440
it checks if the binding equals binding

543
00:19:13,440 --> 00:19:15,280
none and then throws an illegal override

544
00:19:15,280 --> 00:19:16,960
error and what this is actually trying

545
00:19:16,960 --> 00:19:19,120
to do is make sure that you're not

546
00:19:19,120 --> 00:19:21,679
trying to override a function with

547
00:19:21,679 --> 00:19:23,200
something that's not a function like you

548
00:19:23,200 --> 00:19:24,640
can't override an integer with a

549
00:19:24,640 --> 00:19:26,880
function but you'll notice that this

550
00:19:26,880 --> 00:19:29,440
check has a very serious problem it is

551
00:19:29,440 --> 00:19:31,520
commented out

552
00:19:31,520 --> 00:19:34,240
so um

553
00:19:34,799 --> 00:19:37,360
so um just to be clear what can happen

554
00:19:37,360 --> 00:19:38,960
that should violate your sense of all

555
00:19:38,960 --> 00:19:41,520
things object oriented programming you

556
00:19:41,520 --> 00:19:43,760
have a super class here and you have red

557
00:19:43,760 --> 00:19:45,440
external defined and then you have a

558
00:19:45,440 --> 00:19:47,440
subclass and write external is an

559
00:19:47,440 --> 00:19:50,840
integer field it's not a function

560
00:19:50,840 --> 00:19:54,400
and so now let's go to the avm some more

561
00:19:54,400 --> 00:19:56,880
and this right external function it does

562
00:19:56,880 --> 00:19:59,360
something very special in flash if you

563
00:19:59,360 --> 00:20:01,840
don't like what flash serialization does

564
00:20:01,840 --> 00:20:03,760
you can define this function and then

565
00:20:03,760 --> 00:20:06,799
you'll override serialization so

566
00:20:06,799 --> 00:20:08,960
if i define this function and flash

567
00:20:08,960 --> 00:20:10,480
tries to serialize it'll call red

568
00:20:10,480 --> 00:20:12,159
external and give me an object then i

569
00:20:12,159 --> 00:20:13,760
have to return the byte array and then

570
00:20:13,760 --> 00:20:15,679
you also define read external where you

571
00:20:15,679 --> 00:20:17,120
get the byte array and give the object

572
00:20:17,120 --> 00:20:19,679
back it's a serialization override and

573
00:20:19,679 --> 00:20:21,520
then this part of the avm is trying to

574
00:20:21,520 --> 00:20:24,559
do serialization using this override so

575
00:20:24,559 --> 00:20:26,080
you can see oh it gets the function

576
00:20:26,080 --> 00:20:27,679
binding but wait a sec it's not a

577
00:20:27,679 --> 00:20:29,919
function so that's not correct

578
00:20:29,919 --> 00:20:31,760
and then it tries to convert it binding

579
00:20:31,760 --> 00:20:34,400
to method id which is just arithmetic

580
00:20:34,400 --> 00:20:35,919
but that's not correct either because

581
00:20:35,919 --> 00:20:38,080
it's not a function and then it goes out

582
00:20:38,080 --> 00:20:40,400
of bounds of this table and then it

583
00:20:40,400 --> 00:20:42,640
calls a virtual method on it so this is

584
00:20:42,640 --> 00:20:44,559
a type confusion vulnerability and it's

585
00:20:44,559 --> 00:20:45,919
fairly exploitable because you're just

586
00:20:45,919 --> 00:20:47,440
calling the virtual method on

587
00:20:47,440 --> 00:20:48,720
unallocated

588
00:20:48,720 --> 00:20:52,320
parts of the heap that you can control

589
00:20:52,320 --> 00:20:54,640
another interesting type of bug i saw

590
00:20:54,640 --> 00:20:56,880
was exception bugs and exceptions are

591
00:20:56,880 --> 00:20:58,640
actually very difficult to implement in

592
00:20:58,640 --> 00:21:01,200
virtual machines i have my grumpy cat

593
00:21:01,200 --> 00:21:03,440
there because there's two ways to design

594
00:21:03,440 --> 00:21:05,919
it and both designs are bad

595
00:21:05,919 --> 00:21:09,120
your one option is that let's say you're

596
00:21:09,120 --> 00:21:11,840
in a native call and you want and you

597
00:21:11,840 --> 00:21:13,360
call into script and the script throws

598
00:21:13,360 --> 00:21:15,840
an exception you just keep going and

599
00:21:15,840 --> 00:21:18,000
this is what actionscript 2 does and it

600
00:21:18,000 --> 00:21:20,559
has some advantages the main advantage

601
00:21:20,559 --> 00:21:22,080
is that you'll never end up in a bad

602
00:21:22,080 --> 00:21:24,720
state because since the code keeps going

603
00:21:24,720 --> 00:21:26,640
everything you think will happen will

604
00:21:26,640 --> 00:21:27,760
happen

605
00:21:27,760 --> 00:21:30,400
the downside is that developers don't

606
00:21:30,400 --> 00:21:31,919
think that this is going to happen it's

607
00:21:31,919 --> 00:21:34,000
kind of a counterintuitive behavior they

608
00:21:34,000 --> 00:21:36,400
throw an exception and nothing happens

609
00:21:36,400 --> 00:21:38,559
and while i've never seen a bug in flash

610
00:21:38,559 --> 00:21:40,400
due to this i have seen bugs in other

611
00:21:40,400 --> 00:21:43,039
vms so it can be problematic

612
00:21:43,039 --> 00:21:45,360
actionscript 3 uses the more intuitive

613
00:21:45,360 --> 00:21:47,679
behavior if you throw an exception in

614
00:21:47,679 --> 00:21:49,280
actionscript 3 the stack actually

615
00:21:49,280 --> 00:21:51,760
unwinds and you exit from the native

616
00:21:51,760 --> 00:21:52,960
function

617
00:21:52,960 --> 00:21:54,960
and this is more expected behavior but

618
00:21:54,960 --> 00:21:57,280
then you have this problem of did the

619
00:21:57,280 --> 00:21:59,760
developer think about every single time

620
00:21:59,760 --> 00:22:02,000
they called into script did they think

621
00:22:02,000 --> 00:22:04,799
what happens if the stack unwinds and if

622
00:22:04,799 --> 00:22:06,320
they don't think about this every single

623
00:22:06,320 --> 00:22:08,960
time then this can lead to bugs

624
00:22:08,960 --> 00:22:11,440
so i've got two examples here

625
00:22:11,440 --> 00:22:14,000
one is this bug and it involves both

626
00:22:14,000 --> 00:22:16,400
script and the asset table in this in

627
00:22:16,400 --> 00:22:17,919
the swift

628
00:22:17,919 --> 00:22:20,000
so the swift has this asset table that

629
00:22:20,000 --> 00:22:21,919
includes all the stuff like the font

630
00:22:21,919 --> 00:22:24,000
videos that sort of thing with inline

631
00:22:24,000 --> 00:22:26,000
types and something interesting about

632
00:22:26,000 --> 00:22:28,240
this table is that it also has some

633
00:22:28,240 --> 00:22:31,919
reserved values for example fff7 is an

634
00:22:31,919 --> 00:22:34,159
empty text field and what's even more

635
00:22:34,159 --> 00:22:36,000
problematic is that you can override

636
00:22:36,000 --> 00:22:38,320
these so if you declare your own ff7

637
00:22:38,320 --> 00:22:40,000
that takes precedence and that will

638
00:22:40,000 --> 00:22:42,159
override the empty text field

639
00:22:42,159 --> 00:22:44,000
so then what happens if you want to

640
00:22:44,000 --> 00:22:46,240
create a text field well

641
00:22:46,240 --> 00:22:48,080
you create it and then you create the

642
00:22:48,080 --> 00:22:49,520
object and then it makes a pointer to

643
00:22:49,520 --> 00:22:51,440
this table and at this point this is

644
00:22:51,440 --> 00:22:53,120
actually okay because you have the

645
00:22:53,120 --> 00:22:56,240
inline type so it will detect this and

646
00:22:56,240 --> 00:22:57,760
then it will

647
00:22:57,760 --> 00:23:00,559
throw the error and

648
00:23:00,559 --> 00:23:02,159
then something weird it does is it will

649
00:23:02,159 --> 00:23:04,159
change the type to be of type text and

650
00:23:04,159 --> 00:23:05,280
that's to prevent the error from

651
00:23:05,280 --> 00:23:07,039
spawning again and again as you shut

652
00:23:07,039 --> 00:23:09,280
down the player but the thing is i think

653
00:23:09,280 --> 00:23:10,960
they really wanted to throw a fatal

654
00:23:10,960 --> 00:23:13,039
error here because they didn't consider

655
00:23:13,039 --> 00:23:15,280
what happens if you can catch it

656
00:23:15,280 --> 00:23:16,880
so you catch it and then you create a

657
00:23:16,880 --> 00:23:19,120
new text field and this time it creates

658
00:23:19,120 --> 00:23:20,960
the pointer to

659
00:23:20,960 --> 00:23:22,880
this font again but now the type's been

660
00:23:22,880 --> 00:23:24,640
changed so that's type confusion again

661
00:23:24,640 --> 00:23:28,720
you're casting a text field to a font

662
00:23:28,720 --> 00:23:31,039
another interesting exception bug is

663
00:23:31,039 --> 00:23:32,240
this guy

664
00:23:32,240 --> 00:23:33,280
and

665
00:23:33,280 --> 00:23:35,760
this is a use after free you create this

666
00:23:35,760 --> 00:23:38,159
sound class and then you create a byte

667
00:23:38,159 --> 00:23:40,240
array with a thousand bytes and then you

668
00:23:40,240 --> 00:23:42,400
call this vulnerable function

669
00:23:42,400 --> 00:23:45,039
and what it does is it will try and copy

670
00:23:45,039 --> 00:23:47,279
this byte array into memory it allocates

671
00:23:47,279 --> 00:23:49,279
so you can see that there and this is

672
00:23:49,279 --> 00:23:51,120
actually a correct call this one works

673
00:23:51,120 --> 00:23:52,240
properly

674
00:23:52,240 --> 00:23:53,760
and then you create another byte array

675
00:23:53,760 --> 00:23:55,279
and you call it again

676
00:23:55,279 --> 00:23:56,000
and

677
00:23:56,000 --> 00:23:58,480
this one doesn't work correctly it

678
00:23:58,480 --> 00:24:01,200
deletes the buffer but then it tries to

679
00:24:01,200 --> 00:24:02,559
load

680
00:24:02,559 --> 00:24:04,960
the stuff from the byte array before it

681
00:24:04,960 --> 00:24:07,440
creates the new buffer except this byte

682
00:24:07,440 --> 00:24:08,880
array is tiny it doesn't even have

683
00:24:08,880 --> 00:24:11,039
enough bytes for one float so it throws

684
00:24:11,039 --> 00:24:12,320
an exception

685
00:24:12,320 --> 00:24:14,159
and now you have this dangling pointer

686
00:24:14,159 --> 00:24:16,159
you can catch the exception and then

687
00:24:16,159 --> 00:24:18,000
when you call the extract function which

688
00:24:18,000 --> 00:24:19,600
extracts the sound data you can just

689
00:24:19,600 --> 00:24:23,039
read memory off the heap

690
00:24:23,760 --> 00:24:24,559
so

691
00:24:24,559 --> 00:24:26,880
another way you can find bugs is using

692
00:24:26,880 --> 00:24:29,919
reverse engineering especially ida

693
00:24:29,919 --> 00:24:32,400
and complete citation needed but i think

694
00:24:32,400 --> 00:24:34,320
this is how most flash vulnerabilities

695
00:24:34,320 --> 00:24:36,000
are found i've talked to other people

696
00:24:36,000 --> 00:24:37,760
who find flash vulnerabilities and

697
00:24:37,760 --> 00:24:40,080
people that participate in contests and

698
00:24:40,080 --> 00:24:41,520
almost all of the flash vulnerabilities

699
00:24:41,520 --> 00:24:42,799
they've told me about they say they

700
00:24:42,799 --> 00:24:44,559
found by reverse engineering flash with

701
00:24:44,559 --> 00:24:45,520
ida

702
00:24:45,520 --> 00:24:47,679
the benefit of it is it finds deep and

703
00:24:47,679 --> 00:24:50,880
unusual bugs the sort of thing you would

704
00:24:50,880 --> 00:24:53,760
never find through fuzzing but it has an

705
00:24:53,760 --> 00:24:55,840
extremely long ramp up people i've

706
00:24:55,840 --> 00:24:58,480
talked to have said oh they spent months

707
00:24:58,480 --> 00:25:00,480
looking at ida before they had a usable

708
00:25:00,480 --> 00:25:02,640
image to start finding flash films and

709
00:25:02,640 --> 00:25:05,039
it is very slow but it seems to be the

710
00:25:05,039 --> 00:25:08,880
way that most attackers find their bugs

711
00:25:08,880 --> 00:25:10,880
so one sort of bug that was found

712
00:25:10,880 --> 00:25:12,159
through ida

713
00:25:12,159 --> 00:25:14,799
is something i call mcu's after freeze

714
00:25:14,799 --> 00:25:16,159
and this was actually originally

715
00:25:16,159 --> 00:25:17,760
reported to the chrome vulnerability

716
00:25:17,760 --> 00:25:20,320
rewards program and the guy who found it

717
00:25:20,320 --> 00:25:21,679
confirmed that he definitely reversed

718
00:25:21,679 --> 00:25:23,760
engineered to find the bug

719
00:25:23,760 --> 00:25:26,640
and it's the most common bug in flash by

720
00:25:26,640 --> 00:25:27,760
far

721
00:25:27,760 --> 00:25:29,840
over 100 instances have been reported

722
00:25:29,840 --> 00:25:32,799
this year and by this year i mean 2015

723
00:25:32,799 --> 00:25:34,960
but it's a super common bug

724
00:25:34,960 --> 00:25:37,039
it's really only one type of object that

725
00:25:37,039 --> 00:25:39,279
gets freed but there's very very many

726
00:25:39,279 --> 00:25:41,760
paths to this use after free

727
00:25:41,760 --> 00:25:43,440
and the real cause of this issue has to

728
00:25:43,440 --> 00:25:46,080
do with how flash display fields work

729
00:25:46,080 --> 00:25:48,320
the problem with flash display fields is

730
00:25:48,320 --> 00:25:49,760
if you delete one

731
00:25:49,760 --> 00:25:52,799
you really really delete it even though

732
00:25:52,799 --> 00:25:54,880
it's a garbage collected object that has

733
00:25:54,880 --> 00:25:56,880
references to it which is not how

734
00:25:56,880 --> 00:25:58,240
garbage collection is supposed to work

735
00:25:58,240 --> 00:25:59,520
it's supposed to be if you still have a

736
00:25:59,520 --> 00:26:01,200
reference you don't delete it but this

737
00:26:01,200 --> 00:26:02,799
is a special case

738
00:26:02,799 --> 00:26:04,320
and the reason they did this has to do

739
00:26:04,320 --> 00:26:05,440
with lag

740
00:26:05,440 --> 00:26:08,480
let's say you want to

741
00:26:08,480 --> 00:26:10,799
make a text field scroll across a screen

742
00:26:10,799 --> 00:26:12,559
one way you might do this is create a

743
00:26:12,559 --> 00:26:14,080
text field delete it then create it a

744
00:26:14,080 --> 00:26:15,440
little bit over then delete it then

745
00:26:15,440 --> 00:26:17,120
create it a little bit over

746
00:26:17,120 --> 00:26:18,640
and you know that'll look like a smooth

747
00:26:18,640 --> 00:26:20,559
scrolling text field but let's say this

748
00:26:20,559 --> 00:26:22,480
is garbage collected then you create

749
00:26:22,480 --> 00:26:25,760
create create delete lag create create

750
00:26:25,760 --> 00:26:28,080
so it doesn't make it as smooth so to

751
00:26:28,080 --> 00:26:30,240
prevent this problem they immediately

752
00:26:30,240 --> 00:26:34,480
delete the text field but problems ensue

753
00:26:34,480 --> 00:26:36,320
and more specifically this problem

754
00:26:36,320 --> 00:26:38,000
happens when function parameters are

755
00:26:38,000 --> 00:26:39,919
converted after local variables are

756
00:26:39,919 --> 00:26:42,159
initialized but before they are used

757
00:26:42,159 --> 00:26:44,240
what does this actually mean it means

758
00:26:44,240 --> 00:26:46,080
that you can usually avoid this problem

759
00:26:46,080 --> 00:26:47,520
by converting parameters at the

760
00:26:47,520 --> 00:26:49,760
beginning of a function and actually if

761
00:26:49,760 --> 00:26:51,279
you look at how browsers do this the

762
00:26:51,279 --> 00:26:53,120
majority of browsers have a coding

763
00:26:53,120 --> 00:26:54,480
guideline that makes you convert

764
00:26:54,480 --> 00:26:55,520
parameters at the beginning of the

765
00:26:55,520 --> 00:26:57,760
function for this exact reason

766
00:26:57,760 --> 00:26:59,279
and of course it's sometimes hard to

767
00:26:59,279 --> 00:27:01,200
tell exactly what order a code does

768
00:27:01,200 --> 00:27:03,440
stuff but this prevents the majority of

769
00:27:03,440 --> 00:27:05,120
problems if you always do early

770
00:27:05,120 --> 00:27:07,360
conversion

771
00:27:07,360 --> 00:27:10,240
so to give an example of this bug

772
00:27:10,240 --> 00:27:12,080
you create a movie clip which is one of

773
00:27:12,080 --> 00:27:14,400
the vulnerable objects and

774
00:27:14,400 --> 00:27:16,000
then you create

775
00:27:16,000 --> 00:27:18,399
a parameter which has two string defined

776
00:27:18,399 --> 00:27:19,600
and then you call the vulnerable

777
00:27:19,600 --> 00:27:22,320
function which is called swap depths

778
00:27:22,320 --> 00:27:23,600
so you call into this function and the

779
00:27:23,600 --> 00:27:24,960
first thing the function does is it

780
00:27:24,960 --> 00:27:26,960
initializes pointers to these two

781
00:27:26,960 --> 00:27:28,080
objects

782
00:27:28,080 --> 00:27:29,120
and then it tries to convert the

783
00:27:29,120 --> 00:27:30,720
parameter which is of course the wrong

784
00:27:30,720 --> 00:27:32,720
order and

785
00:27:32,720 --> 00:27:34,880
it calls this tostring function and then

786
00:27:34,880 --> 00:27:36,640
this calls remove movie clip which

787
00:27:36,640 --> 00:27:38,480
deletes the movie clip and then the

788
00:27:38,480 --> 00:27:40,080
function will continue with dangling

789
00:27:40,080 --> 00:27:42,559
pointers to the heap

790
00:27:42,559 --> 00:27:44,080
and this this is the most frequent bug

791
00:27:44,080 --> 00:27:46,080
in flash

792
00:27:46,080 --> 00:27:48,159
another way that i found bugs is with

793
00:27:48,159 --> 00:27:49,679
fuzzing and i do this with my colleague

794
00:27:49,679 --> 00:27:51,120
matthias

795
00:27:51,120 --> 00:27:53,840
and we've done a few surfaces

796
00:27:53,840 --> 00:27:55,600
we try and do the three main ones which

797
00:27:55,600 --> 00:27:57,760
is action script two action script three

798
00:27:57,760 --> 00:28:00,159
and the anti-corpus and we've only ever

799
00:28:00,159 --> 00:28:02,399
done mutation fuzzing so basically we

800
00:28:02,399 --> 00:28:05,039
scan the web for every swift file ever

801
00:28:05,039 --> 00:28:08,080
that has existed and then

802
00:28:08,080 --> 00:28:10,880
mutate them change bits and bytes and

803
00:28:10,880 --> 00:28:12,159
feed them through the flash player and

804
00:28:12,159 --> 00:28:14,080
then see when it crashes

805
00:28:14,080 --> 00:28:15,840
some people do do generation fuzzing

806
00:28:15,840 --> 00:28:17,600
i've never personally tried this but

807
00:28:17,600 --> 00:28:19,279
especially with the movie clip use after

808
00:28:19,279 --> 00:28:21,039
freeze once people discover they were

809
00:28:21,039 --> 00:28:23,039
that common a bug some people said they

810
00:28:23,039 --> 00:28:24,799
have written fuzzers that just generate

811
00:28:24,799 --> 00:28:26,480
code that's likely to cause that problem

812
00:28:26,480 --> 00:28:28,880
and have had success with it

813
00:28:28,880 --> 00:28:30,399
with mutation fuzzing it's very

814
00:28:30,399 --> 00:28:32,399
dependent on templates

815
00:28:32,399 --> 00:28:34,080
so it's past the point where you can

816
00:28:34,080 --> 00:28:35,760
just take a swift and fuzz it and find

817
00:28:35,760 --> 00:28:38,880
bugs you need to find a lot of swifts to

818
00:28:38,880 --> 00:28:41,440
find one bug and we actually use um code

819
00:28:41,440 --> 00:28:43,600
coverage measurements so that we focus

820
00:28:43,600 --> 00:28:45,440
on templates that have different code

821
00:28:45,440 --> 00:28:48,159
coverage than other templates to reduce

822
00:28:48,159 --> 00:28:49,120
the

823
00:28:49,120 --> 00:28:51,279
efficiency of fuzzing

824
00:28:51,279 --> 00:28:53,120
what's challenging about fuzzing is it

825
00:28:53,120 --> 00:28:55,360
does find lower quality bugs

826
00:28:55,360 --> 00:28:57,520
with when you're looking at code review

827
00:28:57,520 --> 00:28:58,799
you know when you see a bug you can tell

828
00:28:58,799 --> 00:29:00,480
right away is it a good bug is it a bad

829
00:29:00,480 --> 00:29:02,720
bug with fuzzing especially in flash you

830
00:29:02,720 --> 00:29:04,640
just get so many null pointers and not

831
00:29:04,640 --> 00:29:06,320
especially good bugs

832
00:29:06,320 --> 00:29:07,520
and this can be useful if you're

833
00:29:07,520 --> 00:29:09,520
planning on fixing every bug but if

834
00:29:09,520 --> 00:29:11,200
you're just looking for the exploitable

835
00:29:11,200 --> 00:29:12,399
bugs then

836
00:29:12,399 --> 00:29:14,720
it can take a lot of time

837
00:29:14,720 --> 00:29:16,159
and one more thing i want to mention

838
00:29:16,159 --> 00:29:18,159
about fuzzing flash is that the heap

839
00:29:18,159 --> 00:29:20,240
matters a lot when we started off

840
00:29:20,240 --> 00:29:22,399
fuzzing we weren't finding any use after

841
00:29:22,399 --> 00:29:24,720
free bugs we were kind of wondering why

842
00:29:24,720 --> 00:29:26,640
and then eventually we realized that it

843
00:29:26,640 --> 00:29:28,960
was probably because the thing that

844
00:29:28,960 --> 00:29:30,000
you know was supposed to be in memory

845
00:29:30,000 --> 00:29:31,279
was still in memory and it wasn't

846
00:29:31,279 --> 00:29:33,600
getting really so we changed it so that

847
00:29:33,600 --> 00:29:36,480
the heap had ac ac ac on it every time

848
00:29:36,480 --> 00:29:38,080
it was freed and then that made a big

849
00:29:38,080 --> 00:29:39,520
difference and we found tons of use

850
00:29:39,520 --> 00:29:41,200
after freeze and if you don't want to

851
00:29:41,200 --> 00:29:43,679
recompile another way you can do this is

852
00:29:43,679 --> 00:29:45,919
just create a frame in flash that just

853
00:29:45,919 --> 00:29:47,279
turns and runs a lot of code and

854
00:29:47,279 --> 00:29:48,960
allocates a lot of memory and that makes

855
00:29:48,960 --> 00:29:50,720
it a lot more likely that if you ever

856
00:29:50,720 --> 00:29:54,320
use after free it will cause a crash

857
00:29:54,320 --> 00:29:56,000
so here's an example of a bug we found

858
00:29:56,000 --> 00:29:57,360
through fuzzing

859
00:29:57,360 --> 00:29:59,360
and that is the park in its entirety and

860
00:29:59,360 --> 00:30:01,279
i'm sure you can all tell exactly what's

861
00:30:01,279 --> 00:30:03,840
wrong there

862
00:30:04,000 --> 00:30:07,120
what exactly is happening here is that

863
00:30:07,120 --> 00:30:09,600
when flash calls a function it allocates

864
00:30:09,600 --> 00:30:12,559
the args on the stack and it uses alaka

865
00:30:12,559 --> 00:30:14,399
and that has a minimum size of eight

866
00:30:14,399 --> 00:30:16,320
bytes so you have this allocated eight

867
00:30:16,320 --> 00:30:18,080
bytes that has nothing in it because

868
00:30:18,080 --> 00:30:20,640
there's no parameters to actually copy

869
00:30:20,640 --> 00:30:22,000
and then you call this function convert

870
00:30:22,000 --> 00:30:23,440
to string on that and that's

871
00:30:23,440 --> 00:30:25,679
uninitialized on the stack so

872
00:30:25,679 --> 00:30:26,960
that means you're calling it on an

873
00:30:26,960 --> 00:30:29,200
unknown pointer and the way this got

874
00:30:29,200 --> 00:30:31,520
found through fuzzing is that this

875
00:30:31,520 --> 00:30:32,880
function actually is supposed to have

876
00:30:32,880 --> 00:30:35,360
one parameter but the fuzzing bit

877
00:30:35,360 --> 00:30:37,679
flipped that one to a zero and then you

878
00:30:37,679 --> 00:30:39,200
had zero parameters and this caused the

879
00:30:39,200 --> 00:30:41,600
crash

880
00:30:41,600 --> 00:30:42,640
so

881
00:30:42,640 --> 00:30:44,159
that's it for bugs i'm going to talk a

882
00:30:44,159 --> 00:30:47,360
bit about how flash exploits work now

883
00:30:47,360 --> 00:30:49,120
um and what were the problems when i

884
00:30:49,120 --> 00:30:52,159
started with flash exploitation

885
00:30:52,159 --> 00:30:53,919
well there are kind of two main ones the

886
00:30:53,919 --> 00:30:55,679
first one is what i'd call generic

887
00:30:55,679 --> 00:30:58,320
exploit techniques up to about last

888
00:30:58,320 --> 00:31:00,640
august almost every flash exploit looked

889
00:31:00,640 --> 00:31:02,559
identical and it got to the point where

890
00:31:02,559 --> 00:31:04,240
there were certain organizations so you

891
00:31:04,240 --> 00:31:06,000
could tell were using the same exploit

892
00:31:06,000 --> 00:31:07,279
code over and over and over with

893
00:31:07,279 --> 00:31:08,880
different bugs

894
00:31:08,880 --> 00:31:10,240
you know they almost never had to write

895
00:31:10,240 --> 00:31:12,480
a special exploit for a bug there were

896
00:31:12,480 --> 00:31:13,919
techniques that were so well known and

897
00:31:13,919 --> 00:31:15,679
so reliable they never had to write any

898
00:31:15,679 --> 00:31:18,000
new code and that's not good because you

899
00:31:18,000 --> 00:31:19,519
want attackers to have to take a lot of

900
00:31:19,519 --> 00:31:22,000
time to write their exploits at least

901
00:31:22,000 --> 00:31:23,760
and also there are techniques that work

902
00:31:23,760 --> 00:31:26,000
with low-quality bugs usually there's

903
00:31:26,000 --> 00:31:27,919
kind of a trade-off either you have a

904
00:31:27,919 --> 00:31:30,559
really high quality vulnerability and

905
00:31:30,559 --> 00:31:33,200
exploitation is maybe easy meanwhile if

906
00:31:33,200 --> 00:31:34,480
you have a very low quality

907
00:31:34,480 --> 00:31:36,320
vulnerability you have to put in a lot

908
00:31:36,320 --> 00:31:39,440
more work to make stuff um

909
00:31:39,440 --> 00:31:40,960
make it exploitable

910
00:31:40,960 --> 00:31:42,720
but there were techniques that even with

911
00:31:42,720 --> 00:31:44,720
not very good bugs you could get really

912
00:31:44,720 --> 00:31:47,360
really high reliability exploitation and

913
00:31:47,360 --> 00:31:50,159
that was problematic

914
00:31:50,159 --> 00:31:51,919
yeah i also want to talk a bit about how

915
00:31:51,919 --> 00:31:54,480
flash exploitation works um if you look

916
00:31:54,480 --> 00:31:56,240
at almost every flash exploit in the

917
00:31:56,240 --> 00:31:57,760
wild actually i would probably say every

918
00:31:57,760 --> 00:31:59,760
flash exploit in the wild

919
00:31:59,760 --> 00:32:02,080
the first state they want to obtain is

920
00:32:02,080 --> 00:32:04,640
read write access to all of memory

921
00:32:04,640 --> 00:32:06,000
and i think there's a few reasons they

922
00:32:06,000 --> 00:32:07,760
want to do that and to start with it's a

923
00:32:07,760 --> 00:32:10,799
clearly exploitable state if you

924
00:32:10,799 --> 00:32:12,640
always work towards that goal with the

925
00:32:12,640 --> 00:32:14,240
bug you know there is no doubt that you

926
00:32:14,240 --> 00:32:15,760
can exploit that bug if you can read and

927
00:32:15,760 --> 00:32:17,840
write to all of memory

928
00:32:17,840 --> 00:32:20,240
also um with regards to i'm writing like

929
00:32:20,240 --> 00:32:21,919
a real exploit that's practical in the

930
00:32:21,919 --> 00:32:24,480
wild there's a lot of benefit to that

931
00:32:24,480 --> 00:32:25,919
you know if you're just doing a poc it's

932
00:32:25,919 --> 00:32:27,279
usually good enough just to show oh you

933
00:32:27,279 --> 00:32:29,360
can make a system call but if you're

934
00:32:29,360 --> 00:32:30,799
going to like download malware or

935
00:32:30,799 --> 00:32:33,840
whatever else these bugs do

936
00:32:33,840 --> 00:32:35,440
it really is useful to have rewrite

937
00:32:35,440 --> 00:32:36,640
access of all

938
00:32:36,640 --> 00:32:38,399
to all of memories so

939
00:32:38,399 --> 00:32:40,480
that is basically what every attacker

940
00:32:40,480 --> 00:32:43,279
tries to do with a bug

941
00:32:43,279 --> 00:32:45,600
so the first way that attackers did this

942
00:32:45,600 --> 00:32:48,000
was using a class called the vector

943
00:32:48,000 --> 00:32:49,919
and the vector class was extremely

944
00:32:49,919 --> 00:32:53,039
extremely useful for exploitation and um

945
00:32:53,039 --> 00:32:55,360
this is this is because of a few things

946
00:32:55,360 --> 00:32:58,000
it has this inline length parameter so

947
00:32:58,000 --> 00:32:59,760
if you correct this length parameter and

948
00:32:59,760 --> 00:33:01,440
then access the vector you can access

949
00:33:01,440 --> 00:33:03,519
all of memory so that's kind of cool but

950
00:33:03,519 --> 00:33:05,679
more importantly

951
00:33:05,679 --> 00:33:08,159
it's variable type and variable length

952
00:33:08,159 --> 00:33:10,880
so no matter what type of object you can

953
00:33:10,880 --> 00:33:12,080
overflow

954
00:33:12,080 --> 00:33:13,919
you know be it a big object or a small

955
00:33:13,919 --> 00:33:16,240
object be it an integer or an object you

956
00:33:16,240 --> 00:33:18,000
could make a vector fit in there and

957
00:33:18,000 --> 00:33:19,519
then you could correct it so this made

958
00:33:19,519 --> 00:33:21,760
this a very reliable type of exploit

959
00:33:21,760 --> 00:33:22,640
because

960
00:33:22,640 --> 00:33:24,399
you know no matter what your bug was you

961
00:33:24,399 --> 00:33:25,600
could find something that would fit into

962
00:33:25,600 --> 00:33:27,039
the slot that got corrupted and then

963
00:33:27,039 --> 00:33:28,559
cracked this length

964
00:33:28,559 --> 00:33:30,159
to give an example of how this worked

965
00:33:30,159 --> 00:33:32,240
with use after free it's kind of the

966
00:33:32,240 --> 00:33:33,600
same deal

967
00:33:33,600 --> 00:33:35,600
you have this dangling pointer and

968
00:33:35,600 --> 00:33:38,240
because this object is so versatile you

969
00:33:38,240 --> 00:33:40,240
can almost always find one that fits

970
00:33:40,240 --> 00:33:42,880
into the area that was unused after

971
00:33:42,880 --> 00:33:44,240
freed and then you can just write this

972
00:33:44,240 --> 00:33:45,679
length and then that allows you to

973
00:33:45,679 --> 00:33:47,360
access anywhere in the vector read or

974
00:33:47,360 --> 00:33:48,880
write out of bounds

975
00:33:48,880 --> 00:33:51,679
and that helps a lot with exploitation

976
00:33:51,679 --> 00:33:53,200
so the first mitigation that went into

977
00:33:53,200 --> 00:33:55,760
flash and this was last august was the

978
00:33:55,760 --> 00:33:57,440
vector mitigation

979
00:33:57,440 --> 00:33:59,600
and this did two things it added

980
00:33:59,600 --> 00:34:01,679
checksums to vectors so now if you

981
00:34:01,679 --> 00:34:03,679
correct the length of the vector like

982
00:34:03,679 --> 00:34:05,760
you do here the next time you try to

983
00:34:05,760 --> 00:34:07,919
access it it will check a checksum and

984
00:34:07,919 --> 00:34:09,520
if that checksum isn't correct it will

985
00:34:09,520 --> 00:34:12,879
fail gracefully so this causes a crash

986
00:34:12,879 --> 00:34:14,800
also some vectors are put on their own

987
00:34:14,800 --> 00:34:16,960
heap page and that means that it's less

988
00:34:16,960 --> 00:34:18,480
likely that you can find a bug where you

989
00:34:18,480 --> 00:34:21,040
can corrupt a vector in the first place

990
00:34:21,040 --> 00:34:23,440
and this did two things it started off

991
00:34:23,440 --> 00:34:25,520
by reducing the reusability of exploit

992
00:34:25,520 --> 00:34:27,040
code everyone who had been using the

993
00:34:27,040 --> 00:34:29,280
same exploit code for years

994
00:34:29,280 --> 00:34:31,839
now had to write some new code

995
00:34:31,839 --> 00:34:34,000
also it generally increased the quality

996
00:34:34,000 --> 00:34:36,239
of bug needed for an exploit there were

997
00:34:36,239 --> 00:34:38,159
some exploits in the wild where the bug

998
00:34:38,159 --> 00:34:40,239
was like super low quality something

999
00:34:40,239 --> 00:34:43,040
like you could change one bit of some

1000
00:34:43,040 --> 00:34:43,839
some

1001
00:34:43,839 --> 00:34:45,199
specific object that was used after

1002
00:34:45,199 --> 00:34:46,719
freed but because you could shuffle it

1003
00:34:46,719 --> 00:34:48,879
so that length was at the beginning of

1004
00:34:48,879 --> 00:34:50,879
that bit set you could get the full

1005
00:34:50,879 --> 00:34:53,599
rewrite access to memory and this means

1006
00:34:53,599 --> 00:34:54,399
that

1007
00:34:54,399 --> 00:34:56,239
you know it's usually harder to exploit

1008
00:34:56,239 --> 00:34:57,680
a bug like that

1009
00:34:57,680 --> 00:35:00,160
at the very least it's a lot more work

1010
00:35:00,160 --> 00:35:01,680
and some people say that you can

1011
00:35:01,680 --> 00:35:03,599
substitute the byte array or the bitmap

1012
00:35:03,599 --> 00:35:04,640
data

1013
00:35:04,640 --> 00:35:06,640
for the vector object and this is

1014
00:35:06,640 --> 00:35:09,359
totally true but it's not as good what

1015
00:35:09,359 --> 00:35:10,640
was good about the vector is it was

1016
00:35:10,640 --> 00:35:12,400
variable size and variable type

1017
00:35:12,400 --> 00:35:14,640
meanwhile byte array and bitmap data are

1018
00:35:14,640 --> 00:35:16,480
static size static type

1019
00:35:16,480 --> 00:35:18,640
so you need a better bug you either need

1020
00:35:18,640 --> 00:35:20,560
a bug that happens to be that size and

1021
00:35:20,560 --> 00:35:22,480
type or one that's variable size or

1022
00:35:22,480 --> 00:35:26,480
variable type to make exploitation work

1023
00:35:26,480 --> 00:35:28,960
so after this mitigation went in in a

1024
00:35:28,960 --> 00:35:30,880
couple of months there was a zero day

1025
00:35:30,880 --> 00:35:33,040
and that was the one i showed you with

1026
00:35:33,040 --> 00:35:35,119
the commented out check

1027
00:35:35,119 --> 00:35:36,000
and

1028
00:35:36,000 --> 00:35:37,359
this

1029
00:35:37,359 --> 00:35:40,079
and this one um

1030
00:35:40,079 --> 00:35:41,200
was still exploitable with the

1031
00:35:41,200 --> 00:35:44,160
mitigation and it was exploited using

1032
00:35:44,160 --> 00:35:46,720
the byte array because the traits array

1033
00:35:46,720 --> 00:35:48,880
what that you were indexing outside of

1034
00:35:48,880 --> 00:35:51,280
was variable size it was possible to get

1035
00:35:51,280 --> 00:35:52,640
it to be just the right size that you

1036
00:35:52,640 --> 00:35:54,640
could allocate a byte array in there so

1037
00:35:54,640 --> 00:35:56,320
they use this to get read write access

1038
00:35:56,320 --> 00:35:59,119
to the entire memory space

1039
00:35:59,119 --> 00:36:00,960
so at this point the second mitigation

1040
00:36:00,960 --> 00:36:02,320
set went in

1041
00:36:02,320 --> 00:36:03,119
and

1042
00:36:03,119 --> 00:36:05,440
this had a few different things in it

1043
00:36:05,440 --> 00:36:07,440
the first one is what we call the iso

1044
00:36:07,440 --> 00:36:09,839
heap and this splits the heap into three

1045
00:36:09,839 --> 00:36:12,320
partitions a pointer partition a

1046
00:36:12,320 --> 00:36:14,240
non-pointer or data partition in a

1047
00:36:14,240 --> 00:36:16,480
dangerous partition the dangerous

1048
00:36:16,480 --> 00:36:18,560
partition is for objects that have a

1049
00:36:18,560 --> 00:36:20,800
history of being used in exploits for

1050
00:36:20,800 --> 00:36:23,280
example i'm contiguous data types

1051
00:36:23,280 --> 00:36:25,440
and this helps prevent exploitation

1052
00:36:25,440 --> 00:36:27,040
mostly just because it causes a bit more

1053
00:36:27,040 --> 00:36:29,200
heap entropy but also because most

1054
00:36:29,200 --> 00:36:31,680
exploits on some level involve confusing

1055
00:36:31,680 --> 00:36:33,680
data for pointers or confusing pointers

1056
00:36:33,680 --> 00:36:34,800
for data

1057
00:36:34,800 --> 00:36:36,720
and if those are on separate heaps then

1058
00:36:36,720 --> 00:36:38,560
that gets a lot harder to do

1059
00:36:38,560 --> 00:36:41,119
and of course this isn't really perfect

1060
00:36:41,119 --> 00:36:43,040
most objects have a combination of data

1061
00:36:43,040 --> 00:36:44,320
and pointers and you have to decide

1062
00:36:44,320 --> 00:36:46,720
where to put them but this is a good

1063
00:36:46,720 --> 00:36:48,560
first step and it does make certain

1064
00:36:48,560 --> 00:36:49,839
types of exploitation a lot more

1065
00:36:49,839 --> 00:36:51,200
difficult

1066
00:36:51,200 --> 00:36:52,640
and the other thing that the iso heap

1067
00:36:52,640 --> 00:36:55,119
included was also

1068
00:36:55,119 --> 00:36:57,760
increased segmentation by size so

1069
00:36:57,760 --> 00:36:59,359
depending on the size of a block they're

1070
00:36:59,359 --> 00:37:01,520
all on different heaps as well

1071
00:37:01,520 --> 00:37:03,200
they also put check sums on the binary

1072
00:37:03,200 --> 00:37:04,560
object that got used in the previous

1073
00:37:04,560 --> 00:37:06,160
exploit because they knew attackers were

1074
00:37:06,160 --> 00:37:08,480
using it and they also implemented

1075
00:37:08,480 --> 00:37:10,640
something called jit spray mitigations

1076
00:37:10,640 --> 00:37:12,079
which basically makes it a lot more

1077
00:37:12,079 --> 00:37:14,480
difficult to use the jit to generate a

1078
00:37:14,480 --> 00:37:16,320
ton of code that you can just stick the

1079
00:37:16,320 --> 00:37:18,320
instruction pointer into and it's

1080
00:37:18,320 --> 00:37:20,000
actually been several years since there

1081
00:37:20,000 --> 00:37:22,160
was an exploit like that in the wild but

1082
00:37:22,160 --> 00:37:23,839
they decided to put in the mitigation

1083
00:37:23,839 --> 00:37:27,359
anyhow i'm just in case that turned up

1084
00:37:27,359 --> 00:37:29,760
so um after this um the first

1085
00:37:29,760 --> 00:37:32,240
expectation we saw was a one day and a

1086
00:37:32,240 --> 00:37:34,480
one day is typically used by certain

1087
00:37:34,480 --> 00:37:36,640
financially motivated attackers they

1088
00:37:36,640 --> 00:37:38,240
don't have zero days but as soon as

1089
00:37:38,240 --> 00:37:41,680
flash issues an update they will create

1090
00:37:41,680 --> 00:37:43,119
an exploit for it and then put that in

1091
00:37:43,119 --> 00:37:44,800
the wild and then use it for stuff like

1092
00:37:44,800 --> 00:37:46,960
ransomware and usually these aren't

1093
00:37:46,960 --> 00:37:50,960
especially interesting but in this case

1094
00:37:50,960 --> 00:37:52,320
it was because it was the first time we

1095
00:37:52,320 --> 00:37:55,040
saw someone exploit these mitigations

1096
00:37:55,040 --> 00:37:57,280
and the way they did this

1097
00:37:57,280 --> 00:37:58,880
was they had this bug which was a

1098
00:37:58,880 --> 00:38:00,240
controllable size and also a

1099
00:38:00,240 --> 00:38:02,160
controllable size of an override it was

1100
00:38:02,160 --> 00:38:03,760
an overflow

1101
00:38:03,760 --> 00:38:06,320
so they were able to fit in the last

1102
00:38:06,320 --> 00:38:08,800
remaining type that um accessed

1103
00:38:08,800 --> 00:38:10,800
contiguous data which was the bitmap

1104
00:38:10,800 --> 00:38:12,640
data type and then they were able to

1105
00:38:12,640 --> 00:38:14,560
overwrite the size and get read write

1106
00:38:14,560 --> 00:38:16,640
access to all of memory

1107
00:38:16,640 --> 00:38:18,560
and then there was a second zero day

1108
00:38:18,560 --> 00:38:20,400
that turned up in the wild and this was

1109
00:38:20,400 --> 00:38:22,640
used for a very targeted attack and it

1110
00:38:22,640 --> 00:38:25,680
was a heap overflow vulnerability

1111
00:38:25,680 --> 00:38:27,680
and um what was very interesting about

1112
00:38:27,680 --> 00:38:30,240
this exploit is that it was a swift that

1113
00:38:30,240 --> 00:38:33,680
actually contained two exploits

1114
00:38:33,680 --> 00:38:35,520
one was the typical vector exploit that

1115
00:38:35,520 --> 00:38:37,200
i described at the beginning and the

1116
00:38:37,200 --> 00:38:38,960
second was one that worked after the

1117
00:38:38,960 --> 00:38:40,480
isolated heap

1118
00:38:40,480 --> 00:38:42,640
and here is what this

1119
00:38:42,640 --> 00:38:44,640
exploit involved

1120
00:38:44,640 --> 00:38:46,640
long if statements nested almost 100

1121
00:38:46,640 --> 00:38:49,040
times using both the media file and an

1122
00:38:49,040 --> 00:38:50,880
image file to fill heaps layouts at

1123
00:38:50,880 --> 00:38:52,800
different points in the exploit

1124
00:38:52,800 --> 00:38:55,280
triggering the bug almost 600 times and

1125
00:38:55,280 --> 00:38:57,520
then eventually they were able to

1126
00:38:57,520 --> 00:39:00,079
correct the check sums of the byte array

1127
00:39:00,079 --> 00:39:01,760
and get rewrite access to all of memory

1128
00:39:01,760 --> 00:39:02,720
space

1129
00:39:02,720 --> 00:39:03,920
so there's kind of two things you can

1130
00:39:03,920 --> 00:39:05,200
learn from this

1131
00:39:05,200 --> 00:39:07,680
on one hand the mitigations didn't

1132
00:39:07,680 --> 00:39:10,079
really prevent exploitation but on the

1133
00:39:10,079 --> 00:39:11,680
other hand they had to really really

1134
00:39:11,680 --> 00:39:13,920
want to do this this was so much more

1135
00:39:13,920 --> 00:39:17,440
difficult than the original exploit

1136
00:39:17,440 --> 00:39:21,359
so then we moved on to iso heap 2 and

1137
00:39:21,359 --> 00:39:23,119
this was a few changes there were some

1138
00:39:23,119 --> 00:39:24,960
subtle changes in heat partitioning

1139
00:39:24,960 --> 00:39:26,800
moving even more objects to the

1140
00:39:26,800 --> 00:39:28,480
dangerous partition

1141
00:39:28,480 --> 00:39:30,160
so that it was less likely they could be

1142
00:39:30,160 --> 00:39:32,720
used in exploits and also the bitmap

1143
00:39:32,720 --> 00:39:34,640
data object which we believe is the last

1144
00:39:34,640 --> 00:39:37,359
contiguous object was check summed

1145
00:39:37,359 --> 00:39:38,400
and then

1146
00:39:38,400 --> 00:39:40,000
also extendable checks something was

1147
00:39:40,000 --> 00:39:43,040
implemented so now if another type of

1148
00:39:43,040 --> 00:39:45,760
object shows up in a zero day adobe can

1149
00:39:45,760 --> 00:39:48,640
very easily add check summing right away

1150
00:39:48,640 --> 00:39:50,400
and then a final i don't know if this is

1151
00:39:50,400 --> 00:39:52,560
actually a mitigation a final feature

1152
00:39:52,560 --> 00:39:55,119
was zero freeing and this came out of

1153
00:39:55,119 --> 00:39:56,640
the fact that there were a few use after

1154
00:39:56,640 --> 00:39:58,079
freeze where you would just look at them

1155
00:39:58,079 --> 00:39:59,760
and be like how did this possibly not

1156
00:39:59,760 --> 00:40:02,000
happen in normal use and the truth was

1157
00:40:02,000 --> 00:40:04,160
they were happening in normal use just

1158
00:40:04,160 --> 00:40:06,000
the right thing was always on the heat

1159
00:40:06,000 --> 00:40:08,079
so no one noticed so the point of zero

1160
00:40:08,079 --> 00:40:09,440
freeing is just a detectability

1161
00:40:09,440 --> 00:40:11,280
mechanism if there is a use after free

1162
00:40:11,280 --> 00:40:12,720
that's happening in normal use you're

1163
00:40:12,720 --> 00:40:14,160
now going to notice because you'll get

1164
00:40:14,160 --> 00:40:15,520
an all pointer exception because

1165
00:40:15,520 --> 00:40:18,400
everything was zeroed out

1166
00:40:18,400 --> 00:40:20,400
so at this point

1167
00:40:20,400 --> 00:40:22,560
this set of mitigations went in and we

1168
00:40:22,560 --> 00:40:25,119
didn't see a zero day for a while

1169
00:40:25,119 --> 00:40:27,520
so um i started writing an explain for

1170
00:40:27,520 --> 00:40:30,240
it just to get an idea of what the next

1171
00:40:30,240 --> 00:40:33,119
set of exploitation might look look like

1172
00:40:33,119 --> 00:40:35,359
and i used two bugs for this the first

1173
00:40:35,359 --> 00:40:37,359
one was this unwatched bug this is the

1174
00:40:37,359 --> 00:40:39,200
one we found through fuzzing

1175
00:40:39,200 --> 00:40:41,520
and it's very unintuitive and it's

1176
00:40:41,520 --> 00:40:43,119
because you're missing the parameter of

1177
00:40:43,119 --> 00:40:46,000
the and watch and just to review this

1178
00:40:46,000 --> 00:40:47,520
you get the alika which is an

1179
00:40:47,520 --> 00:40:50,240
uninitialized variable on the stack and

1180
00:40:50,240 --> 00:40:51,680
then you call convert to string on this

1181
00:40:51,680 --> 00:40:54,319
variable so you can basically control

1182
00:40:54,319 --> 00:40:57,119
where this converts to string thing gets

1183
00:40:57,119 --> 00:40:58,640
what it gets called on

1184
00:40:58,640 --> 00:41:00,480
and to go into more detail what does the

1185
00:41:00,480 --> 00:41:03,520
string conversion function actually do

1186
00:41:03,520 --> 00:41:05,280
well the first thing it does is it

1187
00:41:05,280 --> 00:41:07,440
checks to see if the pointer ends in six

1188
00:41:07,440 --> 00:41:09,359
and then returns if it doesn't

1189
00:41:09,359 --> 00:41:12,000
and this is kind of a weird thing to do

1190
00:41:12,000 --> 00:41:14,560
the reason it happens is that in flash

1191
00:41:14,560 --> 00:41:16,000
and actually i would say in almost all

1192
00:41:16,000 --> 00:41:19,119
ecmascript implementations the unaligned

1193
00:41:19,119 --> 00:41:21,359
bits of the pointer are used as a type

1194
00:41:21,359 --> 00:41:22,319
check

1195
00:41:22,319 --> 00:41:24,160
so six means it's an object and then

1196
00:41:24,160 --> 00:41:25,760
there's different values for say an

1197
00:41:25,760 --> 00:41:28,000
integer or a string so it does this type

1198
00:41:28,000 --> 00:41:28,960
check

1199
00:41:28,960 --> 00:41:30,880
and then

1200
00:41:30,880 --> 00:41:33,119
if

1201
00:41:33,520 --> 00:41:36,400
the type check passes then it casts this

1202
00:41:36,400 --> 00:41:37,599
to

1203
00:41:37,599 --> 00:41:39,200
a pointer and then calls the virtual

1204
00:41:39,200 --> 00:41:41,040
call on the pointer

1205
00:41:41,040 --> 00:41:43,359
so if you think about it um there's a

1206
00:41:43,359 --> 00:41:44,640
few different ways you could try to

1207
00:41:44,640 --> 00:41:46,640
exploit this and one thing you know if

1208
00:41:46,640 --> 00:41:48,160
you look at this bug it's almost

1209
00:41:48,160 --> 00:41:50,480
certainly exploitable if alsr is

1210
00:41:50,480 --> 00:41:54,240
bypassed aslr is a mitigation in most

1211
00:41:54,240 --> 00:41:57,200
executables where things like libraries

1212
00:41:57,200 --> 00:41:59,040
and the heap and the stack get loaded at

1213
00:41:59,040 --> 00:42:00,839
different locations

1214
00:42:00,839 --> 00:42:03,599
and if you imagine a situation where

1215
00:42:03,599 --> 00:42:05,520
that didn't exist and you knew where

1216
00:42:05,520 --> 00:42:07,280
everything was loaded then it's fairly

1217
00:42:07,280 --> 00:42:10,240
easy to put a pointer on the stack like

1218
00:42:10,240 --> 00:42:12,640
an absolute pointer and then

1219
00:42:12,640 --> 00:42:14,480
make a virtual call into something you

1220
00:42:14,480 --> 00:42:17,280
know stuff about but in this case since

1221
00:42:17,280 --> 00:42:18,720
i don't know

1222
00:42:18,720 --> 00:42:20,560
that's going to be a bit of a challenge

1223
00:42:20,560 --> 00:42:22,319
so there are kind of three options i

1224
00:42:22,319 --> 00:42:23,599
thought of here

1225
00:42:23,599 --> 00:42:25,520
the first one was let's say i

1226
00:42:25,520 --> 00:42:27,119
initialized the stack as an absolute

1227
00:42:27,119 --> 00:42:28,960
pointer well that one you know you

1228
00:42:28,960 --> 00:42:31,280
definitely need to bypass the lsr

1229
00:42:31,280 --> 00:42:33,520
separately there's no hope there

1230
00:42:33,520 --> 00:42:35,839
the second one was what if i initialize

1231
00:42:35,839 --> 00:42:38,640
a valid pointer on the stack

1232
00:42:38,640 --> 00:42:40,400
of the wrong type

1233
00:42:40,400 --> 00:42:41,920
i kind of thought there were two ways i

1234
00:42:41,920 --> 00:42:43,760
could do this um the real challenge here

1235
00:42:43,760 --> 00:42:45,280
is that this needs to be a pointer that

1236
00:42:45,280 --> 00:42:47,119
ends in six and like when are you ever

1237
00:42:47,119 --> 00:42:49,040
putting a pointer that ends in six on

1238
00:42:49,040 --> 00:42:50,240
the stack

1239
00:42:50,240 --> 00:42:51,920
there's two different situations i

1240
00:42:51,920 --> 00:42:54,160
thought could happen in flash one was

1241
00:42:54,160 --> 00:42:56,160
maybe with a string buffer you know if

1242
00:42:56,160 --> 00:42:57,359
you're iterating through the string

1243
00:42:57,359 --> 00:42:58,480
buffer

1244
00:42:58,480 --> 00:43:00,000
maybe you know you get this unaligned

1245
00:43:00,000 --> 00:43:02,720
pointer on the stack and then you can

1246
00:43:02,720 --> 00:43:05,200
you know set the context text the

1247
00:43:05,200 --> 00:43:06,880
contents of the string and maybe that's

1248
00:43:06,880 --> 00:43:08,079
okay

1249
00:43:08,079 --> 00:43:09,599
but i didn't think this would actually

1250
00:43:09,599 --> 00:43:12,000
work because the problem is that for

1251
00:43:12,000 --> 00:43:13,520
eight bit pointers they have a lot of

1252
00:43:13,520 --> 00:43:16,160
zeros in them meanwhile in flash most

1253
00:43:16,160 --> 00:43:18,000
strings are utf-16 which means they

1254
00:43:18,000 --> 00:43:20,319
terminate if you have two zeros in them

1255
00:43:20,319 --> 00:43:22,160
so i didn't think i'd be able to get you

1256
00:43:22,160 --> 00:43:24,079
know very many pointers in that string

1257
00:43:24,079 --> 00:43:26,079
so i don't think this will work the

1258
00:43:26,079 --> 00:43:27,440
other option was to do the same thing

1259
00:43:27,440 --> 00:43:28,800
with a bitmap you know what if you're

1260
00:43:28,800 --> 00:43:31,119
calculating the pixels but the problem

1261
00:43:31,119 --> 00:43:34,560
with bitmaps in flash is that they do a

1262
00:43:34,560 --> 00:43:36,240
lot of color correction

1263
00:43:36,240 --> 00:43:38,720
so your image is kind of always churning

1264
00:43:38,720 --> 00:43:40,319
with being averaged and that sort of

1265
00:43:40,319 --> 00:43:42,160
thing so that seemed unideal for

1266
00:43:42,160 --> 00:43:44,240
pointers as well

1267
00:43:44,240 --> 00:43:45,680
so i didn't think that this would work

1268
00:43:45,680 --> 00:43:46,880
or at least there were very limited

1269
00:43:46,880 --> 00:43:48,640
options that might not end up turning

1270
00:43:48,640 --> 00:43:51,119
out so the other option

1271
00:43:51,119 --> 00:43:54,160
is that maybe you could initialize the

1272
00:43:54,160 --> 00:43:56,480
stack with a stale pointer maybe you

1273
00:43:56,480 --> 00:43:58,560
know you could put an object on the

1274
00:43:58,560 --> 00:44:00,319
stack and then wait for the object to be

1275
00:44:00,319 --> 00:44:02,319
freed and then allocate it as something

1276
00:44:02,319 --> 00:44:06,240
else and then do this call and um

1277
00:44:06,240 --> 00:44:07,760
i thought that could work but the iso

1278
00:44:07,760 --> 00:44:10,319
heap actually really prevented that

1279
00:44:10,319 --> 00:44:12,240
because there's now the type splitting

1280
00:44:12,240 --> 00:44:13,839
and the psi splitting there are actually

1281
00:44:13,839 --> 00:44:15,680
only two objects in all of flash that

1282
00:44:15,680 --> 00:44:17,839
would fit into the same heap slot as an

1283
00:44:17,839 --> 00:44:20,400
object that ends in six that gets freed

1284
00:44:20,400 --> 00:44:21,920
so when i tried both of those they were

1285
00:44:21,920 --> 00:44:24,000
both very boring objects that i couldn't

1286
00:44:24,000 --> 00:44:26,400
do a lot with so and this was prevented

1287
00:44:26,400 --> 00:44:28,640
with the iso heap so at this point i

1288
00:44:28,640 --> 00:44:30,000
accepted that i'm going to need to use

1289
00:44:30,000 --> 00:44:31,839
another bug here there's no way you can

1290
00:44:31,839 --> 00:44:33,040
use this bug on your own for

1291
00:44:33,040 --> 00:44:34,400
exploitation or at least i couldn't

1292
00:44:34,400 --> 00:44:36,960
think of one but if you bypass the lsr

1293
00:44:36,960 --> 00:44:39,280
you could use the first option which is

1294
00:44:39,280 --> 00:44:41,119
absolute pointer

1295
00:44:41,119 --> 00:44:43,599
so i added in this other bug and this is

1296
00:44:43,599 --> 00:44:45,119
the one that has to do with exception

1297
00:44:45,119 --> 00:44:46,319
handling

1298
00:44:46,319 --> 00:44:48,319
just as a quick reminder

1299
00:44:48,319 --> 00:44:50,400
you create a you create a sound object

1300
00:44:50,400 --> 00:44:52,640
that has the buffer and then you call

1301
00:44:52,640 --> 00:44:54,640
the function that throws an exception

1302
00:44:54,640 --> 00:44:56,560
and it frees the buffer and then you can

1303
00:44:56,560 --> 00:44:58,960
just read data off the heap so this is a

1304
00:44:58,960 --> 00:45:01,200
nice info leak that i thought you could

1305
00:45:01,200 --> 00:45:03,680
use to bypass alsr

1306
00:45:03,680 --> 00:45:06,160
but of course once again the iso heap

1307
00:45:06,160 --> 00:45:08,480
gets annoying here there was not a lot

1308
00:45:08,480 --> 00:45:10,640
of stuff that you could read off the

1309
00:45:10,640 --> 00:45:12,640
heap that had pointers in it

1310
00:45:12,640 --> 00:45:14,960
because the sound waves are data

1311
00:45:14,960 --> 00:45:17,200
and after a lot of effort i eventually

1312
00:45:17,200 --> 00:45:18,880
figured out there was one thing i could

1313
00:45:18,880 --> 00:45:20,720
access on the

1314
00:45:20,720 --> 00:45:23,119
data heap and that was when

1315
00:45:23,119 --> 00:45:26,560
flash calculates jit it sometimes

1316
00:45:26,560 --> 00:45:28,800
allocates stuff on the data heap except

1317
00:45:28,800 --> 00:45:30,800
these jit objects are virtual so they

1318
00:45:30,800 --> 00:45:33,280
have a v table so i managed to make a

1319
00:45:33,280 --> 00:45:34,720
sound thing that was just the right size

1320
00:45:34,720 --> 00:45:36,480
that one of these jit calculations would

1321
00:45:36,480 --> 00:45:38,480
end up where the unallocated memory was

1322
00:45:38,480 --> 00:45:40,240
and then you could read the v table and

1323
00:45:40,240 --> 00:45:41,839
that was nice once i was able to read a

1324
00:45:41,839 --> 00:45:44,000
v table then i could bypass the lsr and

1325
00:45:44,000 --> 00:45:46,560
figure out where everything was

1326
00:45:46,560 --> 00:45:47,359
so

1327
00:45:47,359 --> 00:45:49,040
that was good but the next thing i

1328
00:45:49,040 --> 00:45:51,440
really needed was a contiguous buffer

1329
00:45:51,440 --> 00:45:52,319
because

1330
00:45:52,319 --> 00:45:54,240
a good way to exploit this bug with the

1331
00:45:54,240 --> 00:45:56,000
absolute pointer is that you create

1332
00:45:56,000 --> 00:45:58,319
something that looks like a fake

1333
00:45:58,319 --> 00:46:01,680
c plus object and then you um have a

1334
00:46:01,680 --> 00:46:03,440
fake v table there and then you create a

1335
00:46:03,440 --> 00:46:06,079
fake v table that then points into

1336
00:46:06,079 --> 00:46:09,040
different memory that you can wrap but

1337
00:46:09,040 --> 00:46:10,880
this was hard to do on the iso heap

1338
00:46:10,880 --> 00:46:13,440
because um all the contiguous data types

1339
00:46:13,440 --> 00:46:16,400
are on the dangerous partition and the

1340
00:46:16,400 --> 00:46:18,319
info leak i had was in the data

1341
00:46:18,319 --> 00:46:21,200
partition so i needed to find a way i

1342
00:46:21,200 --> 00:46:22,800
could find a buffer and know the

1343
00:46:22,800 --> 00:46:25,200
location of the buffer on the data

1344
00:46:25,200 --> 00:46:26,880
partition of the heap

1345
00:46:26,880 --> 00:46:28,400
i ended up looking through all the flash

1346
00:46:28,400 --> 00:46:31,040
functions and using a combination of two

1347
00:46:31,040 --> 00:46:32,319
functions

1348
00:46:32,319 --> 00:46:34,560
so to start off there's this function

1349
00:46:34,560 --> 00:46:36,880
called determine preferred locales and

1350
00:46:36,880 --> 00:46:39,680
what this does um as a part of the

1351
00:46:39,680 --> 00:46:41,200
processing it does and these are just

1352
00:46:41,200 --> 00:46:44,079
temporary structures is it creates an

1353
00:46:44,079 --> 00:46:46,880
array of character pointers and then it

1354
00:46:46,880 --> 00:46:48,640
makes each of these character pointers

1355
00:46:48,640 --> 00:46:50,640
point to a string and what's kind of

1356
00:46:50,640 --> 00:46:51,680
interesting what makes this a really

1357
00:46:51,680 --> 00:46:53,680
useful function is that you can change

1358
00:46:53,680 --> 00:46:55,920
both the size of the character array

1359
00:46:55,920 --> 00:46:57,760
like the number of strings you have and

1360
00:46:57,760 --> 00:47:00,000
the length of each string so i was able

1361
00:47:00,000 --> 00:47:02,560
to make it so that this character array

1362
00:47:02,560 --> 00:47:04,720
fit into the same slot that was freed by

1363
00:47:04,720 --> 00:47:07,599
that sound bug so that was good then i

1364
00:47:07,599 --> 00:47:09,359
was able to get the

1365
00:47:09,359 --> 00:47:11,599
get the read out the location of this

1366
00:47:11,599 --> 00:47:13,920
pointer so i would

1367
00:47:13,920 --> 00:47:15,440
read this pointer and then at that point

1368
00:47:15,440 --> 00:47:17,119
it doesn't really matter if this is free

1369
00:47:17,119 --> 00:47:18,480
because you know the location of the

1370
00:47:18,480 --> 00:47:19,599
string

1371
00:47:19,599 --> 00:47:21,680
so then this function exits

1372
00:47:21,680 --> 00:47:22,800
and

1373
00:47:22,800 --> 00:47:25,119
also the string gets freed but that

1374
00:47:25,119 --> 00:47:26,720
doesn't matter you still know the

1375
00:47:26,720 --> 00:47:29,440
location of that string in memory so

1376
00:47:29,440 --> 00:47:31,920
then i call this other function

1377
00:47:31,920 --> 00:47:34,480
palette map and what this does is it

1378
00:47:34,480 --> 00:47:35,839
creates um

1379
00:47:35,839 --> 00:47:37,920
a palette so basically a color array and

1380
00:47:37,920 --> 00:47:40,480
memory that you can use to define

1381
00:47:40,480 --> 00:47:42,720
different colors in flash and this is

1382
00:47:42,720 --> 00:47:45,599
nice because this array is an integer

1383
00:47:45,599 --> 00:47:47,680
array so you can control every value in

1384
00:47:47,680 --> 00:47:49,520
it it's a contiguous array

1385
00:47:49,520 --> 00:47:51,200
and i called this in such a way that it

1386
00:47:51,200 --> 00:47:53,119
was guaranteed to take the same slot as

1387
00:47:53,119 --> 00:47:54,960
this string that had been freed

1388
00:47:54,960 --> 00:47:56,800
so now you have

1389
00:47:56,800 --> 00:47:57,920
you know where the pointer is because

1390
00:47:57,920 --> 00:47:59,119
you were able to read the pointer and

1391
00:47:59,119 --> 00:48:00,559
you know where the string is so this is

1392
00:48:00,559 --> 00:48:02,000
how you can get

1393
00:48:02,000 --> 00:48:04,000
an array you can control with a pointer

1394
00:48:04,000 --> 00:48:04,839
to

1395
00:48:04,839 --> 00:48:07,119
it and

1396
00:48:07,119 --> 00:48:09,119
so i have this and i'll explain um what

1397
00:48:09,119 --> 00:48:11,520
this stuff means in a sec

1398
00:48:11,520 --> 00:48:13,280
for this exploit it was really useful if

1399
00:48:13,280 --> 00:48:16,160
i could get two buffers but

1400
00:48:16,160 --> 00:48:17,599
once i had this technique it was easy

1401
00:48:17,599 --> 00:48:19,599
enough to just create a second buffer

1402
00:48:19,599 --> 00:48:21,280
using exactly the same technique so you

1403
00:48:21,280 --> 00:48:22,880
have a buffer with a pointer to another

1404
00:48:22,880 --> 00:48:24,319
buffer

1405
00:48:24,319 --> 00:48:26,640
so this is good i have my structure for

1406
00:48:26,640 --> 00:48:28,079
the exploit set up

1407
00:48:28,079 --> 00:48:30,559
the next thing i needed to do is trigger

1408
00:48:30,559 --> 00:48:31,680
the bug

1409
00:48:31,680 --> 00:48:32,800
and

1410
00:48:32,800 --> 00:48:33,599
you know

1411
00:48:33,599 --> 00:48:35,119
once i got to this point i realized it

1412
00:48:35,119 --> 00:48:36,319
would have been better to think about

1413
00:48:36,319 --> 00:48:37,839
how i was going to get an absolute value

1414
00:48:37,839 --> 00:48:40,000
on the stack before i did all that but i

1415
00:48:40,000 --> 00:48:41,680
was now at this point and had to figure

1416
00:48:41,680 --> 00:48:44,160
out how to get an absolute value on the

1417
00:48:44,160 --> 00:48:45,200
stack

1418
00:48:45,200 --> 00:48:49,680
and eventually i figured out that

1419
00:48:49,680 --> 00:48:51,520
one way to really do this with a lot of

1420
00:48:51,520 --> 00:48:54,640
the stack was that if in if there is a

1421
00:48:54,640 --> 00:48:56,000
small string in a swift and it gets

1422
00:48:56,000 --> 00:48:58,640
converted to utf-16 this is actually

1423
00:48:58,640 --> 00:49:00,079
done on the stack

1424
00:49:00,079 --> 00:49:02,319
so i made a swift that does this and the

1425
00:49:02,319 --> 00:49:04,000
unfortunate thing is that this doesn't

1426
00:49:04,000 --> 00:49:06,800
work with dynamic strings so if you say

1427
00:49:06,800 --> 00:49:08,480
like var a equals string this won't end

1428
00:49:08,480 --> 00:49:10,400
up on the stack but if your string is

1429
00:49:10,400 --> 00:49:12,400
actually in the swift this will end up

1430
00:49:12,400 --> 00:49:13,520
in the stack

1431
00:49:13,520 --> 00:49:15,839
so what i ended up doing was making a

1432
00:49:15,839 --> 00:49:18,079
python application that would generate a

1433
00:49:18,079 --> 00:49:20,079
swift so i started off with the swift

1434
00:49:20,079 --> 00:49:22,640
that generated that structure and then

1435
00:49:22,640 --> 00:49:24,319
this would make a call with the pointer

1436
00:49:24,319 --> 00:49:25,920
location of the structure into this

1437
00:49:25,920 --> 00:49:27,440
other python script that would generate

1438
00:49:27,440 --> 00:49:29,200
a new swift that when you called that

1439
00:49:29,200 --> 00:49:30,559
that would put the right things on the

1440
00:49:30,559 --> 00:49:31,599
stack

1441
00:49:31,599 --> 00:49:33,680
and then it would trigger the bug

1442
00:49:33,680 --> 00:49:35,200
and then just to run through how this

1443
00:49:35,200 --> 00:49:37,119
works now that everything is set up so

1444
00:49:37,119 --> 00:49:38,960
you trigger the bug and it checks

1445
00:49:38,960 --> 00:49:41,040
whether the pointer ends in sticks but

1446
00:49:41,040 --> 00:49:43,119
you set the pointer so it does

1447
00:49:43,119 --> 00:49:45,440
and then it does this call on it and you

1448
00:49:45,440 --> 00:49:47,280
start off with this first red array from

1449
00:49:47,280 --> 00:49:48,640
the palette map

1450
00:49:48,640 --> 00:49:52,160
and this is a virtual call so um

1451
00:49:52,160 --> 00:49:53,599
it looks for the v table and then goes

1452
00:49:53,599 --> 00:49:55,440
into the second array and for this

1453
00:49:55,440 --> 00:49:57,119
specific call it starts off in the

1454
00:49:57,119 --> 00:49:59,680
middle and this will put

1455
00:49:59,680 --> 00:50:02,079
the beginning of the array into the this

1456
00:50:02,079 --> 00:50:03,920
pointer and then

1457
00:50:03,920 --> 00:50:05,920
call later in the array which is 28

1458
00:50:05,920 --> 00:50:07,839
which is system so this leads to a

1459
00:50:07,839 --> 00:50:09,280
system call

1460
00:50:09,280 --> 00:50:10,640
with a pointer to the beginning of this

1461
00:50:10,640 --> 00:50:12,160
array so that

1462
00:50:12,160 --> 00:50:13,680
that will allow you to call one system

1463
00:50:13,680 --> 00:50:15,599
command and at least prove this exploit

1464
00:50:15,599 --> 00:50:17,040
works

1465
00:50:17,040 --> 00:50:18,000
um so

1466
00:50:18,000 --> 00:50:20,720
this is what i came up with to bypass

1467
00:50:20,720 --> 00:50:21,680
this

1468
00:50:21,680 --> 00:50:23,119
mitigation

1469
00:50:23,119 --> 00:50:25,520
and of course as soon as i did this but

1470
00:50:25,520 --> 00:50:28,319
before i released it someone else

1471
00:50:28,319 --> 00:50:30,800
or a zero day turned up in the wild

1472
00:50:30,800 --> 00:50:32,400
and

1473
00:50:32,400 --> 00:50:34,480
what was interesting about this one is

1474
00:50:34,480 --> 00:50:36,319
that it didn't actually work

1475
00:50:36,319 --> 00:50:38,880
so it was reported by meg by trend micro

1476
00:50:38,880 --> 00:50:40,559
and it was in the magnitude exploit kit

1477
00:50:40,559 --> 00:50:42,319
which is another um financial exploit

1478
00:50:42,319 --> 00:50:43,440
kit that is used for things like

1479
00:50:43,440 --> 00:50:45,040
ransomware

1480
00:50:45,040 --> 00:50:48,559
and the bug in there was not fixed

1481
00:50:48,559 --> 00:50:50,559
but it only worked on old versions of

1482
00:50:50,559 --> 00:50:52,960
flash and that was because the people

1483
00:50:52,960 --> 00:50:54,640
who had written this explain weren't

1484
00:50:54,640 --> 00:50:56,000
able to make it work with the new

1485
00:50:56,000 --> 00:50:57,680
mitigation set

1486
00:50:57,680 --> 00:51:00,079
so um that was kind of cool the zero day

1487
00:51:00,079 --> 00:51:02,000
was reported but even though they had an

1488
00:51:02,000 --> 00:51:03,760
unknown bug they couldn't make it work

1489
00:51:03,760 --> 00:51:05,359
the mitigations had stopped them so that

1490
00:51:05,359 --> 00:51:06,800
was interesting

1491
00:51:06,800 --> 00:51:08,880
but then there was another zero day

1492
00:51:08,880 --> 00:51:10,240
which did work

1493
00:51:10,240 --> 00:51:12,720
and this was a targeted attack reported

1494
00:51:12,720 --> 00:51:15,440
by kaspersky and um

1495
00:51:15,440 --> 00:51:17,920
it used

1496
00:51:17,920 --> 00:51:20,160
it used out of bound array x it was an

1497
00:51:20,160 --> 00:51:21,920
out-of-bounds array access and it used

1498
00:51:21,920 --> 00:51:24,640
the similar v-table attack to what i did

1499
00:51:24,640 --> 00:51:26,319
so you know we're still at the point

1500
00:51:26,319 --> 00:51:27,200
where

1501
00:51:27,200 --> 00:51:30,000
um the mitigations are working a bit

1502
00:51:30,000 --> 00:51:31,680
but um

1503
00:51:31,680 --> 00:51:32,559
you know we're

1504
00:51:32,559 --> 00:51:34,720
one for two one set of attackers was

1505
00:51:34,720 --> 00:51:37,280
stopped but the other one wasn't

1506
00:51:37,280 --> 00:51:38,960
so um

1507
00:51:38,960 --> 00:51:41,280
what do i think this all means

1508
00:51:41,280 --> 00:51:43,599
overall i think reducing bugs and

1509
00:51:43,599 --> 00:51:45,040
mitigating exploits has made it more

1510
00:51:45,040 --> 00:51:47,119
difficult to attack flash

1511
00:51:47,119 --> 00:51:49,599
we've seen some evidence of this

1512
00:51:49,599 --> 00:51:51,359
one thing we're seeing is more complex

1513
00:51:51,359 --> 00:51:52,960
exploits

1514
00:51:52,960 --> 00:51:55,119
it used to be that every single exploit

1515
00:51:55,119 --> 00:51:56,960
was a vector exploit but that's not the

1516
00:51:56,960 --> 00:51:59,440
case anymore we've seen a lot of new

1517
00:51:59,440 --> 00:52:01,599
techniques because attackers have been

1518
00:52:01,599 --> 00:52:03,520
forced to move to new techniques as

1519
00:52:03,520 --> 00:52:05,520
their old ones have dried up

1520
00:52:05,520 --> 00:52:08,079
we've also seen exploit kits using other

1521
00:52:08,079 --> 00:52:10,000
bugs and you don't always see this when

1522
00:52:10,000 --> 00:52:11,520
you're just looking at the flash zero

1523
00:52:11,520 --> 00:52:12,480
days

1524
00:52:12,480 --> 00:52:14,720
but um

1525
00:52:14,720 --> 00:52:17,040
what's interesting is what's not there

1526
00:52:17,040 --> 00:52:18,960
it's you know when we started off for

1527
00:52:18,960 --> 00:52:21,280
every single flash update there were

1528
00:52:21,280 --> 00:52:23,680
these exploit kits that would find a bug

1529
00:52:23,680 --> 00:52:25,119
and then update their exploit kit and

1530
00:52:25,119 --> 00:52:28,000
exploit it and now a lot fewer exploit

1531
00:52:28,000 --> 00:52:29,599
kits are doing that in fact a lot of

1532
00:52:29,599 --> 00:52:31,680
them are moving to other bugs for

1533
00:52:31,680 --> 00:52:33,839
example silverlight

1534
00:52:33,839 --> 00:52:36,160
other vulnerable software and also a lot

1535
00:52:36,160 --> 00:52:38,480
of them are not working

1536
00:52:38,480 --> 00:52:40,480
we it was like basically quite a long

1537
00:52:40,480 --> 00:52:42,240
time ago that they issued their last

1538
00:52:42,240 --> 00:52:44,160
update and they haven't been able to get

1539
00:52:44,160 --> 00:52:46,079
another working exploit and that's

1540
00:52:46,079 --> 00:52:49,599
fairly good so it seems that at least

1541
00:52:49,599 --> 00:52:52,319
a lot of these financially motivated

1542
00:52:52,319 --> 00:52:54,319
exploit kit authors are having a lot of

1543
00:52:54,319 --> 00:52:55,599
trouble now and this is actually

1544
00:52:55,599 --> 00:52:57,839
preventing them from mounting their

1545
00:52:57,839 --> 00:52:59,200
attacks

1546
00:52:59,200 --> 00:53:01,680
and fundamentally uh mitigations are a

1547
00:53:01,680 --> 00:53:03,839
cat and mouse game you can't expect that

1548
00:53:03,839 --> 00:53:05,200
you'll put in a mitigation and you'll

1549
00:53:05,200 --> 00:53:07,119
never get an exploit again the real goal

1550
00:53:07,119 --> 00:53:08,880
is to slow down attackers make it so

1551
00:53:08,880 --> 00:53:10,640
that there's fewer zero days and they

1552
00:53:10,640 --> 00:53:12,480
have to spend a lot more effort and that

1553
00:53:12,480 --> 00:53:15,520
seems to be what's happening here

1554
00:53:15,520 --> 00:53:17,200
i'd say finding bugs has become a lot

1555
00:53:17,200 --> 00:53:19,839
more difficult um as i said i am down to

1556
00:53:19,839 --> 00:53:22,400
one bug per week versus one bug per day

1557
00:53:22,400 --> 00:53:23,680
and what's more interesting is that

1558
00:53:23,680 --> 00:53:25,280
whole classes of bugs are starting to

1559
00:53:25,280 --> 00:53:26,559
disappear

1560
00:53:26,559 --> 00:53:27,760
and there are kind of two classes of

1561
00:53:27,760 --> 00:53:29,680
bugs that i showed there was the ones

1562
00:53:29,680 --> 00:53:31,680
i'm using the value of and then there

1563
00:53:31,680 --> 00:53:33,760
was the movie clip use after freeze and

1564
00:53:33,760 --> 00:53:35,119
those are both types that there were

1565
00:53:35,119 --> 00:53:36,800
tens intensive reports of and now

1566
00:53:36,800 --> 00:53:38,960
they're basically down to zero

1567
00:53:38,960 --> 00:53:40,880
it seems that you know once a certain

1568
00:53:40,880 --> 00:53:42,800
blood class becomes popular they start

1569
00:53:42,800 --> 00:53:44,640
to all get found and get fixed and adobe

1570
00:53:44,640 --> 00:53:46,800
has also done a few wide scale changes

1571
00:53:46,800 --> 00:53:48,880
to make them more difficult to find and

1572
00:53:48,880 --> 00:53:50,720
less likely to happen

1573
00:53:50,720 --> 00:53:52,480
and it means that these bad classes are

1574
00:53:52,480 --> 00:53:54,640
basically going away another thing i've

1575
00:53:54,640 --> 00:53:57,520
been seeing is more bug finders there's

1576
00:53:57,520 --> 00:53:59,680
a lot fewer people now who are finding

1577
00:53:59,680 --> 00:54:02,000
you know 10 bugs every update or you

1578
00:54:02,000 --> 00:54:04,319
know bit huge batches of bugs now a lot

1579
00:54:04,319 --> 00:54:05,520
more people have become more interested

1580
00:54:05,520 --> 00:54:08,000
in the area but it's usually each person

1581
00:54:08,000 --> 00:54:09,520
is only reporting one or two bugs so i

1582
00:54:09,520 --> 00:54:11,359
think this is another sign that they're

1583
00:54:11,359 --> 00:54:13,760
becoming more difficult to find

1584
00:54:13,760 --> 00:54:15,520
and a final thing is that we've also

1585
00:54:15,520 --> 00:54:17,440
started seeing lower quality bugs and

1586
00:54:17,440 --> 00:54:20,319
exploits things that

1587
00:54:20,319 --> 00:54:22,319
maybe even a year ago is not the bug

1588
00:54:22,319 --> 00:54:24,079
that the attacker would choose but now

1589
00:54:24,079 --> 00:54:25,760
as they're getting more picked over

1590
00:54:25,760 --> 00:54:28,160
they're starting to be used

1591
00:54:28,160 --> 00:54:31,040
so i think there's some

1592
00:54:31,040 --> 00:54:33,440
some progress here though

1593
00:54:33,440 --> 00:54:35,040
i think what we're all really hoping for

1594
00:54:35,040 --> 00:54:37,119
is flash deprecation and i think it's

1595
00:54:37,119 --> 00:54:38,799
going to be a few years now but that's

1596
00:54:38,799 --> 00:54:40,880
probably the future and i think what

1597
00:54:40,880 --> 00:54:42,640
this will mean is that attackers will

1598
00:54:42,640 --> 00:54:44,079
move somewhere else

1599
00:54:44,079 --> 00:54:45,760
personally i'm moving to browsers

1600
00:54:45,760 --> 00:54:47,359
because that's what what i think the

1601
00:54:47,359 --> 00:54:49,839
next area of attack will be

1602
00:54:49,839 --> 00:54:51,599
so that's it i want to end off by

1603
00:54:51,599 --> 00:54:53,119
thanking adobe

1604
00:54:53,119 --> 00:54:54,640
they have been super helpful with this

1605
00:54:54,640 --> 00:54:56,799
research they of course implemented all

1606
00:54:56,799 --> 00:54:59,119
the mitigations and have also fixed all

1607
00:54:59,119 --> 00:55:01,040
the bugs and they have a very difficult

1608
00:55:01,040 --> 00:55:02,720
task and i think they've done well with

1609
00:55:02,720 --> 00:55:04,000
it

1610
00:55:04,000 --> 00:55:06,160
and that's it and i like to open the

1611
00:55:06,160 --> 00:55:08,340
floor for questions

1612
00:55:08,340 --> 00:55:15,040
[Applause]

1613
00:55:15,040 --> 00:55:18,319
uh i'm rick farrow so this reminds me of

1614
00:55:18,319 --> 00:55:20,000
showing up for using username security

1615
00:55:20,000 --> 00:55:22,319
three years ago in washington dc

1616
00:55:22,319 --> 00:55:24,880
riding the metro the subway

1617
00:55:24,880 --> 00:55:26,640
and there's a big poster in there and it

1618
00:55:26,640 --> 00:55:29,920
says adobe owns washington

1619
00:55:29,920 --> 00:55:32,880
and of course to my mind it means yes

1620
00:55:32,880 --> 00:55:35,520
flash owns washington

1621
00:55:35,520 --> 00:55:36,640
um

1622
00:55:36,640 --> 00:55:38,240
what do you think of the

1623
00:55:38,240 --> 00:55:41,440
when i you describe the language

1624
00:55:41,440 --> 00:55:42,799
i'm just

1625
00:55:42,799 --> 00:55:44,079
appalled

1626
00:55:44,079 --> 00:55:46,079
what do you think people the people who

1627
00:55:46,079 --> 00:55:47,440
design

1628
00:55:47,440 --> 00:55:50,160
activescript in the first place

1629
00:55:50,160 --> 00:55:51,680
they don't seem like they're language

1630
00:55:51,680 --> 00:55:53,680
described designers you know they're

1631
00:55:53,680 --> 00:55:54,960
certainly not

1632
00:55:54,960 --> 00:55:56,640
people designing go they're designing

1633
00:55:56,640 --> 00:55:58,640
something very strange i mean like the

1634
00:55:58,640 --> 00:56:00,079
ability to

1635
00:56:00,079 --> 00:56:02,640
redefine a method

1636
00:56:02,640 --> 00:56:04,480
a lot of very strange things could you

1637
00:56:04,480 --> 00:56:06,640
comment on that and also how big how

1638
00:56:06,640 --> 00:56:10,480
many lines of code is flash currently

1639
00:56:10,480 --> 00:56:12,400
i'll start with your

1640
00:56:12,400 --> 00:56:14,799
second question

1641
00:56:14,799 --> 00:56:16,400
i don't really know but i think it's

1642
00:56:16,400 --> 00:56:18,720
about like more than a gig of code so

1643
00:56:18,720 --> 00:56:20,000
i've never actually counted but it's

1644
00:56:20,000 --> 00:56:22,319
very very large yeah

1645
00:56:22,319 --> 00:56:24,559
that more than it's hundreds of

1646
00:56:24,559 --> 00:56:26,960
thousands of lines of code let's say

1647
00:56:26,960 --> 00:56:31,040
yeah um and with regards to um

1648
00:56:31,040 --> 00:56:33,280
flash um i think it's actually blame

1649
00:56:33,280 --> 00:56:34,240
ecma

1650
00:56:34,240 --> 00:56:35,920
there's nothing they've really done that

1651
00:56:35,920 --> 00:56:38,240
is not in the ecmascript standard um you

1652
00:56:38,240 --> 00:56:40,079
know the things like oh

1653
00:56:40,079 --> 00:56:41,680
you know you can redefine stuff you can

1654
00:56:41,680 --> 00:56:44,559
convert stuff um you know none of this

1655
00:56:44,559 --> 00:56:46,400
was their idea it was all the ecmascript

1656
00:56:46,400 --> 00:56:47,920
standards idea

1657
00:56:47,920 --> 00:56:49,200
and um

1658
00:56:49,200 --> 00:56:52,319
i think um part of what happened here is

1659
00:56:52,319 --> 00:56:54,000
so um

1660
00:56:54,000 --> 00:56:56,640
what what as2 i think was ecma-3 and

1661
00:56:56,640 --> 00:57:01,599
then they defined ecma-4 as as3 and then

1662
00:57:01,599 --> 00:57:04,720
ecma-4 never got adopted so

1663
00:57:04,720 --> 00:57:06,640
as3 actually doesn't have these problems

1664
00:57:06,640 --> 00:57:07,760
because they realized they were having

1665
00:57:07,760 --> 00:57:09,920
them but as2

1666
00:57:09,920 --> 00:57:11,440
is now implementing this really

1667
00:57:11,440 --> 00:57:13,920
difficult standard that and doesn't you

1668
00:57:13,920 --> 00:57:15,119
know isn't being kept up to date because

1669
00:57:15,119 --> 00:57:18,079
it's not an active um

1670
00:57:18,079 --> 00:57:19,359
you know it's not a language that people

1671
00:57:19,359 --> 00:57:21,280
are actively writing code in so i think

1672
00:57:21,280 --> 00:57:22,960
you know browsers do theoretically have

1673
00:57:22,960 --> 00:57:24,640
the same problem everything you can do

1674
00:57:24,640 --> 00:57:26,400
in actionscript you can do in javascript

1675
00:57:26,400 --> 00:57:28,160
it's just because i guess that code is

1676
00:57:28,160 --> 00:57:30,480
still alive and people are still

1677
00:57:30,480 --> 00:57:32,079
writing scripts for it it's you know

1678
00:57:32,079 --> 00:57:34,160
better maintained and you know some

1679
00:57:34,160 --> 00:57:35,359
things have been redesigned and i

1680
00:57:35,359 --> 00:57:37,119
mentioned i'm coding styles that force

1681
00:57:37,119 --> 00:57:40,160
you to move conversion to the top um

1682
00:57:40,160 --> 00:57:41,359
yeah like those are all the things you

1683
00:57:41,359 --> 00:57:44,640
can do to prevent it and i think um

1684
00:57:44,640 --> 00:57:46,319
actionscript 2 is just in this space

1685
00:57:46,319 --> 00:57:48,319
that it's like almost abandoned but not

1686
00:57:48,319 --> 00:57:50,079
quite that you know all that good stuff

1687
00:57:50,079 --> 00:57:51,520
didn't happen and then you ended up with

1688
00:57:51,520 --> 00:57:52,960
all these problems

1689
00:57:52,960 --> 00:57:55,839
okay thanks

1690
00:57:57,760 --> 00:57:59,839
hi uh jeremy epstein darpa really

1691
00:57:59,839 --> 00:58:01,680
interesting talk um i wanted to actually

1692
00:58:01,680 --> 00:58:03,280
go back to something you talked about

1693
00:58:03,280 --> 00:58:05,359
almost at the very beginning where you

1694
00:58:05,359 --> 00:58:07,200
said that the good news is when problems

1695
00:58:07,200 --> 00:58:10,400
get fixed they stay fixed

1696
00:58:10,400 --> 00:58:11,200
and

1697
00:58:11,200 --> 00:58:12,960
when i heard you say that i was reminded

1698
00:58:12,960 --> 00:58:15,200
of of something from the mythical man

1699
00:58:15,200 --> 00:58:16,400
month i don't know if you've ever read

1700
00:58:16,400 --> 00:58:18,319
that book it's it's one of the great

1701
00:58:18,319 --> 00:58:20,559
books of software engineering about 40

1702
00:58:20,559 --> 00:58:23,760
years old and um

1703
00:58:23,760 --> 00:58:27,040
they did studies and concluded that that

1704
00:58:27,040 --> 00:58:29,760
fixing bugs beyond a certain point

1705
00:58:29,760 --> 00:58:31,680
um every time you fix something you

1706
00:58:31,680 --> 00:58:33,760
break something else and so i was kind

1707
00:58:33,760 --> 00:58:36,559
of surprised when you you said that when

1708
00:58:36,559 --> 00:58:38,960
bugs get fixed they stay fixed i was

1709
00:58:38,960 --> 00:58:41,359
wondering have you seen any evidence

1710
00:58:41,359 --> 00:58:42,960
either that

1711
00:58:42,960 --> 00:58:45,359
that new bugs do get introduced as they

1712
00:58:45,359 --> 00:58:48,000
fix things or conversely that they've

1713
00:58:48,000 --> 00:58:51,760
broken the cycle that was noted 40 years

1714
00:58:51,760 --> 00:58:52,720
ago

1715
00:58:52,720 --> 00:58:53,680
um

1716
00:58:53,680 --> 00:58:54,640
yeah i think that was a bit of an

1717
00:58:54,640 --> 00:58:57,440
exaggeration i would say that 98 of bugs

1718
00:58:57,440 --> 00:58:59,680
when they get fixed stay fixed

1719
00:58:59,680 --> 00:59:02,079
we have seen twice we're adding in a fix

1720
00:59:02,079 --> 00:59:04,160
out of 100 bugs

1721
00:59:04,160 --> 00:59:06,480
did cause another vulnerability

1722
00:59:06,480 --> 00:59:07,280
and

1723
00:59:07,280 --> 00:59:08,880
i think you know maybe that rule doesn't

1724
00:59:08,880 --> 00:59:10,319
necessarily

1725
00:59:10,319 --> 00:59:13,200
apply to security bugs like kind of what

1726
00:59:13,200 --> 00:59:14,640
i care about is that the vulnerability

1727
00:59:14,640 --> 00:59:16,319
goes away i don't care if anything works

1728
00:59:16,319 --> 00:59:18,079
that's probably bad but that's kind of

1729
00:59:18,079 --> 00:59:20,480
my thought process here

1730
00:59:20,480 --> 00:59:21,680
and i think

1731
00:59:21,680 --> 00:59:23,680
maybe the likelihood that fixing a

1732
00:59:23,680 --> 00:59:24,960
vulnerability will add another

1733
00:59:24,960 --> 00:59:26,480
vulnerability is less than fixing a

1734
00:59:26,480 --> 00:59:28,400
vulnerability we'll add another bug

1735
00:59:28,400 --> 00:59:30,079
because there also have been some

1736
00:59:30,079 --> 00:59:31,680
vulnerabilities where we just had to

1737
00:59:31,680 --> 00:59:33,520
accept that it would break a small

1738
00:59:33,520 --> 00:59:35,280
number of swifts you know as an

1739
00:59:35,280 --> 00:59:36,960
acceptable cost there was no way to fix

1740
00:59:36,960 --> 00:59:39,280
it without breaking swifts and that has

1741
00:59:39,280 --> 00:59:42,000
happened in a small portion of bugs too

1742
00:59:42,000 --> 00:59:43,760
but um

1743
00:59:43,760 --> 00:59:45,119
you know at some point you know you

1744
00:59:45,119 --> 00:59:46,880
can't leave vulnerabilities in because

1745
00:59:46,880 --> 00:59:48,400
i'm certainly not arguing for leaving

1746
00:59:48,400 --> 00:59:52,000
vulnerabilities in i mean it's just

1747
00:59:54,160 --> 00:59:55,599
like

1748
00:59:55,599 --> 00:59:57,119
windows

1749
00:59:57,119 --> 00:59:59,599
i don't know xp or or some of the

1750
00:59:59,599 --> 01:00:01,760
earlier versions uh

1751
01:00:01,760 --> 01:00:03,440
after a while it seemed like microsoft

1752
01:00:03,440 --> 01:00:04,559
sort of threw up their hands and said

1753
01:00:04,559 --> 01:00:06,799
there's nothing we can ever do that's

1754
01:00:06,799 --> 01:00:07,920
going to

1755
01:00:07,920 --> 01:00:10,319
redeem this pile of crap we need to

1756
01:00:10,319 --> 01:00:11,839
start over

1757
01:00:11,839 --> 01:00:13,599
and i wonder whether

1758
01:00:13,599 --> 01:00:16,960
that thought has occurred in adobe that

1759
01:00:16,960 --> 01:00:18,960
that this is beyond hope

1760
01:00:18,960 --> 01:00:21,200
uh we need to start over both with a

1761
01:00:21,200 --> 01:00:24,000
redesign of the language and a redesign

1762
01:00:24,000 --> 01:00:27,920
of the implementation um

1763
01:00:35,359 --> 01:00:36,720
yeah like i think deprecation

1764
01:00:36,720 --> 01:00:38,960
complicates this for sure like you know

1765
01:00:38,960 --> 01:00:40,559
if they were thinking of 20 more years

1766
01:00:40,559 --> 01:00:42,480
of flash my guess is that a rewrite

1767
01:00:42,480 --> 01:00:44,880
would be in the cards but right now

1768
01:00:44,880 --> 01:00:46,079
because they know there's no active

1769
01:00:46,079 --> 01:00:48,480
development it's just a matter of you

1770
01:00:48,480 --> 01:00:50,720
know what can you do and i think

1771
01:00:50,720 --> 01:00:52,480
without the option of redevelopment

1772
01:00:52,480 --> 01:00:54,000
fixing bugs is better than not fixing

1773
01:00:54,000 --> 01:00:56,079
bugs

1774
01:00:56,079 --> 01:00:58,400
thank you

1775
01:01:04,559 --> 01:01:06,799
adrian felt google so

1776
01:01:06,799 --> 01:01:09,200
um you found an enormous number of bugs

1777
01:01:09,200 --> 01:01:12,319
primarily through code review

1778
01:01:12,319 --> 01:01:14,799
why didn't adobe find them like before

1779
01:01:14,799 --> 01:01:16,799
shipping the code i mean that seems like

1780
01:01:16,799 --> 01:01:19,200
that would have been the ideal time

1781
01:01:19,200 --> 01:01:21,040
is it because

1782
01:01:21,040 --> 01:01:23,280
they they weren't reviewing the code at

1783
01:01:23,280 --> 01:01:24,799
the time and looking for these types of

1784
01:01:24,799 --> 01:01:27,280
bugs or is it because they they lacked

1785
01:01:27,280 --> 01:01:28,880
the kind of security researchers who

1786
01:01:28,880 --> 01:01:30,799
could find these bugs

1787
01:01:30,799 --> 01:01:32,079
um

1788
01:01:32,079 --> 01:01:33,920
that's a good question i think there's a

1789
01:01:33,920 --> 01:01:36,160
few aspects so

1790
01:01:36,160 --> 01:01:38,079
what i think is kind of a staffing

1791
01:01:38,079 --> 01:01:39,760
concern um

1792
01:01:39,760 --> 01:01:41,200
you know not everyone can find these

1793
01:01:41,200 --> 01:01:42,799
types of bugs and it's hard to find

1794
01:01:42,799 --> 01:01:44,480
people who

1795
01:01:44,480 --> 01:01:46,960
can i think also early on there was some

1796
01:01:46,960 --> 01:01:49,359
disagreement about the importance of

1797
01:01:49,359 --> 01:01:51,760
these types of bugs too i you know some

1798
01:01:51,760 --> 01:01:53,839
people ask the question of well if we

1799
01:01:53,839 --> 01:01:55,440
can never fix all of them is it worth

1800
01:01:55,440 --> 01:01:57,599
fixing any of them yeah or maybe it's

1801
01:01:57,599 --> 01:01:58,960
just better to wait for them to turn up

1802
01:01:58,960 --> 01:02:00,799
in the wild and i don't agree with them

1803
01:02:00,799 --> 01:02:03,520
either of those statements but i suspect

1804
01:02:03,520 --> 01:02:04,319
that

1805
01:02:04,319 --> 01:02:06,559
some of what happened was a concern that

1806
01:02:06,559 --> 01:02:07,920
you know if we can't fix the whole

1807
01:02:07,920 --> 01:02:09,440
problem maybe we shouldn't try fixing

1808
01:02:09,440 --> 01:02:11,119
the problem at all

1809
01:02:11,119 --> 01:02:12,160
and i don't think that's the right

1810
01:02:12,160 --> 01:02:13,599
thought process but i suspect that might

1811
01:02:13,599 --> 01:02:16,799
be what's behind some of it

1812
01:02:19,599 --> 01:02:21,520
are there any additional questions

1813
01:02:21,520 --> 01:02:24,880
yeah yes one more sure

1814
01:02:24,880 --> 01:02:26,400
so um

1815
01:02:26,400 --> 01:02:27,119
do

1816
01:02:27,119 --> 01:02:29,440
when you find these bugs are they more

1817
01:02:29,440 --> 01:02:31,520
for one platform than another i mean i

1818
01:02:31,520 --> 01:02:33,119
guess that's sort of a naive question

1819
01:02:33,119 --> 01:02:35,920
but what comes to mind is that when i

1820
01:02:35,920 --> 01:02:38,720
started looking at nt security in 98

1821
01:02:38,720 --> 01:02:40,480
i noticed they had a system call that

1822
01:02:40,480 --> 01:02:42,079
said

1823
01:02:42,079 --> 01:02:44,559
download this file

1824
01:02:44,559 --> 01:02:46,000
and once you downloaded the file the

1825
01:02:46,000 --> 01:02:47,760
next system call will be execute this

1826
01:02:47,760 --> 01:02:48,720
file

1827
01:02:48,720 --> 01:02:50,720
and so it to my mind this made

1828
01:02:50,720 --> 01:02:52,960
exploitation of windows systems really

1829
01:02:52,960 --> 01:02:54,480
easy

1830
01:02:54,480 --> 01:02:55,359
so

1831
01:02:55,359 --> 01:02:56,880
is there any kind of relationship

1832
01:02:56,880 --> 01:02:59,599
between flash and the platform that's

1833
01:02:59,599 --> 01:03:00,839
easiest to

1834
01:03:00,839 --> 01:03:02,559
exploit

1835
01:03:02,559 --> 01:03:04,079
yes there is there's

1836
01:03:04,079 --> 01:03:06,400
kind of two

1837
01:03:06,400 --> 01:03:08,400
subsets of this one is there are

1838
01:03:08,400 --> 01:03:10,799
actually platform specific bugs in flash

1839
01:03:10,799 --> 01:03:12,480
and um it's actually

1840
01:03:12,480 --> 01:03:14,559
fairly rare to see them used in the wild

1841
01:03:14,559 --> 01:03:16,880
but we have recently just because i

1842
01:03:16,880 --> 01:03:18,559
think the bugs are getting picked over

1843
01:03:18,559 --> 01:03:20,400
so that does occasionally happen though

1844
01:03:20,400 --> 01:03:23,200
i think that isn't any likely to happen

1845
01:03:23,200 --> 01:03:25,119
to you know one platform over the other

1846
01:03:25,119 --> 01:03:26,400
it's just kind of random chance which

1847
01:03:26,400 --> 01:03:28,400
ones ended up with the bugs in them but

1848
01:03:28,400 --> 01:03:31,280
with regards to exploitation we do see

1849
01:03:31,280 --> 01:03:34,559
os differences and browser differences

1850
01:03:34,559 --> 01:03:37,599
um with regards to os um it is usually

1851
01:03:37,599 --> 01:03:39,520
targeting windows just because like

1852
01:03:39,520 --> 01:03:42,000
that's where the popular targets are

1853
01:03:42,000 --> 01:03:43,920
especially with things like ransomware

1854
01:03:43,920 --> 01:03:46,400
male malware i think because so many

1855
01:03:46,400 --> 01:03:48,640
people use windows that's what they pick

1856
01:03:48,640 --> 01:03:51,520
um also we find a browser differential

1857
01:03:51,520 --> 01:03:52,559
um

1858
01:03:52,559 --> 01:03:55,599
i'd say chrome in some level i.e are

1859
01:03:55,599 --> 01:03:58,079
least likely to get exploited

1860
01:03:58,079 --> 01:04:00,960
just because of sandboxing and now ie

1861
01:04:00,960 --> 01:04:02,799
also has some mitigations related to

1862
01:04:02,799 --> 01:04:06,160
freeze that make it harder

1863
01:04:06,160 --> 01:04:07,359
well thank you

1864
01:04:07,359 --> 01:04:08,640
appreciate it

1865
01:04:08,640 --> 01:04:10,319
interesting look into something i've

1866
01:04:10,319 --> 01:04:12,559
always wondered about

1867
01:04:12,559 --> 01:04:14,319
thanks

1868
01:04:14,319 --> 01:04:16,380
let's thank the speaker

1869
01:04:16,380 --> 01:04:22,019
[Applause]

1870
01:04:29,839 --> 01:04:31,920
you

